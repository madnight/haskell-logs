00:00:00 <raspy> applicative: I had a more practical use case a few days ago, but I can't remember it now
00:00:04 <elliott> DEFINITION: DevHC_ is the sole GHC developer.
00:00:06 <shachaf> DEFINITION: GHC is a PHP compiler.
00:00:06 <elliott> DevHC_: Fix it plz
00:00:14 <elliott> > <?php echo "hello world" ?>
00:00:15 <lambdabot>   <no location info>: parse error on input `<?'
00:00:18 <kmc> that's not just an unassigned codepoint, it's an invalid codepoint which is known to stay invalid forever and which will show up as the result of various common mistakes
00:00:43 <shachaf> kmc: What should [minBound..maxBound] be?
00:00:44 <Sgeo|web> > putStr $ chr 0xFFFD
00:00:44 <lambdabot>   Couldn't match expected type `GHC.Base.String'
00:00:44 <lambdabot>         against inferred typ...
00:00:51 <elliott> kmc: I think it's a missing feature.
00:00:53 <Sgeo|web> > putStr $ [chr 0xFFFD]
00:00:54 <lambdabot>   <IO ()>
00:00:56 <elliott> kmc: The Report is ridiculously loose about Char.
00:01:01 <Sgeo|web> >  [chr 0xFFFD]
00:01:01 <lambdabot>   "\65533"
00:01:03 <elliott> But by GHC's stricter interpretation it's a bug.
00:01:21 <kmc> i agree that UTF-8 can be thought of as a protocol for serializing numbers in [0..0x10FFFF]
00:01:36 <kmc> but i'm not onboard with saying that's what it "is" or that any implementation which fails to generalize thus is broken
00:01:38 <Sgeo|web> > doc [chr 0xFFFD]
00:01:38 <lambdabot>   Not in scope: `doc'
00:01:41 <elliott> kmc: You can use the same code to produce a similar algorithm.
00:01:42 <sanjoyd> What does [: String :] mean?
00:01:43 <elliott> But the types are wrong.
00:01:44 <Sgeo|web> > text [chr 0xFFFD]
00:01:45 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
00:01:50 <kmc> sanjoyd, it's a Data Parallel Haskell array
00:01:56 <sanjoyd> kmc: thanks!
00:02:01 * sanjoyd googles.
00:02:12 <kmc> > text "\xD800"
00:02:13 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
00:02:55 <elliott> Doesn't lambdabot fail on Unicode in general?
00:02:58 <Sgeo|web> > text "Text, does it work?"
00:02:58 <lambdabot>   Text, does it work?
00:03:02 <kmc> > text "☭"
00:03:03 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
00:03:05 <elliott> Yep.
00:03:05 <kmc> derp
00:03:06 <shachaf> elliott: s/on Unicode //
00:03:12 <elliott> shachaf: Also that.
00:03:21 <BleuM937> greetings
00:03:30 <kmc> "i don't always produce UTF-8, but when I do, I make sure to separately encode each half of a UTF-16 surrogate pair"
00:03:39 <applicative> sanjoyd: check out the fancy comprehensions that come with it http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell#A_simple_example
00:03:40 <elliott> kmc: :(
00:03:51 <kmc> this is a thing, it even has a name which I forgot
00:03:51 <elliott> kmc: You'll give DevHC_ ideas.
00:03:58 <GutenTag> lol @ dos equis reference.
00:04:04 <DevHC_> elliott: he already did
00:04:10 <shachaf> More like "reddit reference".
00:04:14 <shachaf> I assume.
00:04:16 <elliott> DevHC_: You just voided your support warranty.
00:04:19 <kmc> more like java reference
00:04:22 <Sgeo|web> I don't think DevHC_ knows what a surrogate pair is
00:04:25 <applicative> hi BleuM937 what are your expected and actual types
00:04:31 <kmc> haha
00:04:37 <elliott> Sgeo|web: Have we blocked off Google sufficiently? I'm worried. :(
00:04:37 <Sgeo|web> DevHC_: Do you know what a surrogate pair is?
00:04:45 <GutenTag> It's source is from a commercial for Dos Equis, shachaf.  "The Most Interesting Man in the World" commercials.
00:04:50 <shachaf> GutenTag: I know.
00:05:11 <shachaf> But at this point it's more of an Internet joke that has turned in on itself.
00:05:20 <BleuM937> @applicative, haha, I'm not having a problem with Haskell itself, just with cabal-install
00:05:20 <lambdabot> Unknown command, try @list
00:05:24 <shachaf> Kind of like an ivory tower, except more plastic.
00:05:29 <elliott> BleuM937: You might not want to start pings with @ in here.
00:05:35 <elliott> lambdabot will get very confused.
00:05:37 <applicative> BleuM937: oh, thats a little harder than Haskell
00:05:41 <elliott> shachaf++
00:05:42 <DevHC_> Sgeo|web: no idea
00:05:47 <kmc> @elliott you mean IRC is not the same as twitter? #lol #fail #haskell
00:05:47 <lambdabot> Unknown command, try @list
00:05:55 <BleuM937> elliott woops, just realised that
00:05:55 <XexonixXexillion> BleuM937: unless it is @slap
00:06:01 <applicative> BleuM937: what is the problem?
00:06:14 <elliott> kmc: augh
00:06:14 <shachaf> Twitter didn't invent @-notation.
00:06:22 <Sgeo|web> DevHC_: In UTF-16, you often use one 16-bit unit to represent a codepoint, but some codepoints can't be represented like that
00:06:25 <GutenTag> It just made it famous.
00:06:40 <kmc> T SHACHAF GALHUGALHAGLUHGALHUHGH
00:06:49 <BleuM937> applicative is there a way to completely remove a package and its dependencies?
00:07:00 <shachaf> kmc: Are the Kan extensions getting to you?
00:07:00 <Sgeo|web> So, instead, you use two 16-bit units, each would be an invalid codepoint, but combined together in UTF-16 represents a higher codepoint
00:07:05 <elliott> kmc++
00:07:11 <kmc> t BleuM937 ghc-pkg unregister
00:07:16 <elliott> kmc: I was going to try and remember the syntax of Multics mail to respond to that, but then I was a lazy person.
00:07:21 <shachaf> Oh.
00:07:24 <Sgeo|web> Note that it is NOT correct to say that two of these surrogates in general equal a higher codepoint
00:07:33 <Sgeo|web> It's ONLY in the context of utf-16 that that makes sense
00:07:38 <applicative> BleuM937: there are several steps.  you know how to unregister with ghc-pkg unregister stupid-package-101.1
00:07:46 <Sgeo|web> elliott: Is my explanation not entirely horrible?
00:07:49 <elliott> Sgeo|web: Are you sure this is a good idea?
00:08:07 <Sgeo|web> elliott: No, but my motivation was secretly to be sure I knew what I was talking about
00:08:17 <elliott> Sgeo|web: Maybe I should have paid attention.
00:08:23 <kmc> it is not wrong Sgeo|web
00:09:01 <Sgeo|web> Yay!
00:09:04 <applicative> BleuM937: if you just want ghc to forget about it forever, then ghc-pkg unregister will do it, it will tell you what else to unregister if it has dependencies
00:09:23 <BleuM937> applicative: I'd like to go the other way around
00:09:38 <BleuM937> and clean up a package and all its dependencies
00:09:39 * shachaf >=> sleep
00:09:49 <BleuM937> I've tried using cabal install --reinstall
00:09:56 <elliott> shachaf: My mental typechecker froze.
00:10:01 <BleuM937> but that didn't fix the issue
00:10:19 <Sgeo|web> :t (>=>)
00:10:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
00:10:30 <BleuM937> It's a package I've previously had working, but is now failing to install
00:10:54 <kmc> another way to put it is:  UTF-16 represents a code point with one or two 16-bit code units
00:10:55 <kmc> just as UTF-8 represents a code point with one to four 8-bit code units
00:11:01 <applicative> BleuM937: unregister the offending package, also unregister all of its dependencies this is done through ghc-pkg unregister
00:11:05 <Sgeo|web> So, it's like where one would use >>= in a pointed style, you'd use >=> for pointfree composition ?
00:11:07 <kmc> they are similar in some ways, but UTF-16 is simpler
00:11:34 <Sgeo|web> UTF-8 doesn't rely on there being invalid codepoints in the Unicode spec though
00:11:43 <elliott> kmc: You just made me realise that there are probably people who use UTF-16 over UTF-8 because it's simpler. :/
00:11:52 <applicative> BleuM937: then, depending on the source of the original problem you should be able to reinstall all the unregistered packages in one command
00:11:52 <kmc> elliott, I'm fine with that
00:11:52 <Sgeo|web> ..or does it?
00:12:08 <kmc> Sgeo|web, not to my knowledge
00:12:12 * elliott thinks we should have outlawed UTF-16 once Unicode started being bigger than that.
00:12:22 <applicative> BleuM937: in general it is best to get cabal install to install as many things at once, since the inference it makes is much simpler that way
00:12:24 <kmc> nah, it's a good encoding for some purposes
00:12:37 <kmc> if your language lives in the BMP and outside ASCII
00:12:51 <Sgeo|web> It's still lengthy to find the nth character, isn't it?
00:12:53 <kmc> which is true for the native languages of most people on earth
00:12:59 <kmc> Sgeo|web, yes
00:13:25 <elliott> kmc: I'd rather just use UTF-32 for the warm fuzzies.
00:13:40 * elliott 's opinions may not be popular, but they are comforting.
00:13:44 <kmc> and now everything is twice as big and slow :/
00:13:45 <applicative> BleuM937: so you can do cabal install snap-core snap-server snap-bells-and-whistles etc all at once
00:13:47 <shachaf> I'd rather use UTF-29.
00:13:51 <shachaf> More space-efficient, man
00:13:55 <elliott> Here's one: we really need a /me's command so I can avoid that ugly space.
00:14:01 <elliott> shachaf: Isn't it UTF-21.something?
00:14:05 <shachaf> Er.
00:14:10 <shachaf> Whatever it is.
00:14:10 <kmc> Sgeo|web, some of the goals of UTF-8 depend on the fact that the first 128 Unicode characters are also the first 128 ASCII characters
00:14:14 <shachaf> We need that many bits.
00:14:22 <elliott> shachaf: It's not an integral number.
00:14:27 <elliott> They're too cool for that.
00:14:31 <shachaf> elliott: We need ceil(that many bits)
00:14:37 <elliott> shachaf: Noooo, that's giving up.
00:14:44 <Sgeo|web> shachaf: But fractional-sized bits are more fun!
00:14:49 <kmc> it's kind of lucky that the high half of the 8-bit character space is not quite as standardized as ASCII
00:15:04 <kmc> otherwise people would demand backwards compatibility with that too
00:15:11 <BleuM937> applicative: Thanks, I'll try that out shortly
00:15:11 <shachaf> But, like, CP437, man!
00:15:16 <kmc> and we'd have to redesign all our machines to have a 9th bit
00:15:21 <elliott> shachaf: You can pack 100 * UTF-1.5 atoms into 150 bytes as opposed to 200.
00:15:23 <kmc> yeah man shachaf
00:15:26 <kmc> best codepage
00:15:30 <elliott> shachaf: Encoding and decoding is a bit of a pain though.
00:15:31 <Sgeo|web> kmc: Ah, so that's sort of used as indicators like the surrogates for UTF-16?
00:15:38 <kmc> Sgeo|web, I don't follow
00:15:47 <applicative> BleuM937: if you dont have a huge number of cabal-installed things, you might just unregister them all, and then reinstall everything with one command
00:15:49 <shachaf> Wait, wasn't I >=>ingsleep?
00:16:08 <elliott> shachaf: No.
00:16:15 <shachaf> Oh, right.
00:16:16 <Sgeo|web> kmc: Oh, n/m.
00:16:17 <shachaf> Wait a minute...
00:16:30 <shachaf> No, I was >=>ingsleep.
00:16:32 <kmc> Sgeo|web, I'm just saying that the encoding goal "be backwards compatible with ASCII" is easier due to the structure of the Unicode codepoint space
00:16:37 * shachaf vanishes in a puff of orange smoke.
00:18:00 <Sgeo|web> Suppose a unicode-encoding could be designed to be space-efficient for common-use cases, like UTF-8, but was not beholden to backwards compatibility like UTF-8. WHat might it look like?
00:18:26 <Sgeo|web> > kmc: Be psychic
00:18:26 <lambdabot>   Not in scope: `kmc'Not in scope: data constructor `Be'Not in scope: `psychic'
00:18:35 <kmc> lzma on UTF-8
00:19:05 <kmc> that breaks some of the other desirable properties of UTF-8
00:19:25 <elliott> UTF-8 doesn't really lose anything from its compatibility at all.
00:19:53 <kmc> o hey http://en.wikipedia.org/wiki/Standard_Compression_Scheme_for_Unicode
00:20:25 <elliott> That sounds kind of gross.
00:25:28 <GutenTag> This seems to work as expected, but is it reasonable style?  myIsPalindrome list = list == myRev list
00:26:03 <GutenTag> I'm actually not sure how else to write it...but it definitely looks so foreign to me.
00:26:17 <elliott> s/myRev/reverse/
00:26:28 <elliott> s/myIsPalindrome/palindrome/ too for that matter :P
00:26:45 <kmc> it's fine
00:26:47 <kmc> why does it look foreign?
00:26:49 <ion> palindrome = (==) <*> reverse   -- ;-)
00:27:09 <elliott> ion: I was resisting the urge, I was resisting!!!
00:27:12 <elliott> You ruined everything!
00:27:18 <ion> I couldn’t help it.
00:27:24 <GutenTag> elliot: No, I wrote my own reverse (I'm doing the 99 problems)
00:27:29 <elliott> (That's a lie, I was checking it worked.)
00:27:32 <elliott> GutenTag: Okay. (What 99 problems?)
00:27:37 <kmc> technically, you can do it with half as many comparisons
00:27:38 <ion> I didn’t even bother to check.
00:28:02 <kmc> but the code will get uglier
00:28:11 <GutenTag> elliot: This: http://www.haskell.org/haskellwiki/99_Haskell_exercises
00:28:23 <GutenTag> 99 problems/solutions.
00:28:27 <elliott> GutenTag: Oh, /those/ things.
00:28:35 <elliott> I wouldn't bother doing those. But whatever you want.
00:28:52 <elliott> A list of 99 problems designed to teach you Prolog is of very questionable utility for Haskell.
00:28:58 <GutenTag> elliot: Well, I honestly just have to learn basic Haskell for a test.  These are about the level of our questions, I believe.
00:29:07 <kmc> they're probably fine
00:29:11 <kmc> i also like the exercises at
00:29:12 <kmc> @where cs11
00:29:12 <lambdabot> http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
00:29:18 <GutenTag> ah, thanks kmc.
00:30:33 <GutenTag> This is actually for a class from last semester.  I was injured, missed class and an exam.  So, I have an incomplete to complete before this semester is out.
00:31:19 <GutenTag> I've written a fair amount of these in LISP/ACL2, but's it's been a long time since then.
00:32:42 <kmc> oh cool, ACL2
00:34:24 <GutenTag> kmc: What was cooler is that J Moore was my professor for it.
00:35:19 <kmc> nice
00:43:07 <erus`> i there an unboxing tutorial/ example?
00:47:35 <erus`> is everyone asleep ?
00:50:33 <zeiris> Hypothetically speaking, how fancy a static type system do you need to do useful things with monads?
00:52:45 <kmc> not very
00:53:56 <kmc> erus`, i am not asleep
00:54:59 <kmc> zeiris, say you have a language of dynamically-typed, duck-typed classes and objects
00:55:01 <erus`> can i just put bangs infront of the arguements of a type constructor and its quicker?
00:55:14 <kmc> erus`, that's not unboxing, but yes it can help
00:55:25 <kmc> you can then pass -funbox-strict-fields to ghc
00:55:37 <kmc> zeiris, then (>>=) can be a dynamically dispatched method of its left-hand argument
00:55:40 <kmc> I think that works fine
00:56:02 <kmc> 'return' is trickier because in these languages you usually don't have return-type polymorphism
00:56:11 <kmc> but i think you can hack it
00:56:11 <GutenTag> if I have 5 lines of code, should I use a pastebin?
00:56:14 <kmc> yes
00:57:34 <hpaste> GutenTaag pasted “myCompress” at http://hpaste.org/53848
00:58:04 <GutenTag> misspelled my own nick.
00:59:45 <GutenTag> oh, shoot.  I bet I know what it is.  Let me try some parens.
01:00:04 <GutenTag> oh, shoot.  I bet I know what it is.  Let me try some parens.
01:00:12 <GutenTag> oops, sorry.  Yes, the parens worked.
01:01:07 <erus`> frerich: backslashes after ' should not be converted to lambda symbols i dont think
01:01:55 <Maxdamantus> Would it make sense to have a type system similar to Haskell's, but with a special "random" type, where you might have something like `a :: (?, Int); b :: (t, Int) -> (t, Int)`, and be unable to do something like `let f = b in (f a, f a)`, because `a` includes a random type, so others of the same expression have a different type?
01:02:14 <Maxdamantus> (prevented by the monomorphism restriction)
01:02:27 <Maxdamantus> (b a, b a) should be fine though.
01:02:58 <Maxdamantus> So you'd be able to derive values from some `a` that can only be used in conjunction with other derivatives of that `a`, not others.
01:03:43 <Maxdamantus> (as long as you don't have a `(a, Int) -> (Int, Int)`)
01:05:07 <jpcooper> hello
01:05:40 <applicative> GutenTag: it's just bracketing http://ideone.com/p83Fx
01:06:23 <applicative> GutenTag: oh i see, you figured it out; late as usual
01:06:45 <jpcooper> I'm trying to install the pcap package with cabal install. I'm on Windows, and I've been trying to do this on Cygwin. For some reason, cabal says "unrecognized options: --with-gcc" even though gcc is installed. Could anyone give some pointers?
01:10:38 <BleuM937> Hello folks
01:10:43 <BleuM937> Is applicative still around?
01:11:07 <Maxdamantus> He spoke five minutes ago.
01:11:53 <applicative> BleuM937: yeah, i'm back, i guess.
01:12:08 <applicative> BleuM937: has my advice produced chaos?
01:12:16 <erus`> can i generate a cabal file automagically?
01:12:22 <BleuM937> applicative: It did produce chaos
01:12:26 <applicative> cabal init
01:12:35 <BleuM937> applicative: but I've managed to fix it!
01:12:45 <applicative> you left as I was about to give further caveats
01:12:49 <applicative> BleuM937: oh good.
01:13:02 <applicative> BleuM937: what was the problem or fix?
01:13:40 <BleuM937> applicative: I ended up manually unregistering about a dozen packages
01:13:51 <erus`> cabal init is cool
01:13:56 <erus`> i never knew about that
01:14:17 <applicative> BleuM937: yea, I was going to say you need to clean up back to wherever the problem originated, at least in simple cases.
01:14:30 <BleuM937> applicative: It seems there were at least 2 separate dependency conflicts
01:15:28 <BleuM937> applicative: I'm not sure if cabal was being silly or whether I managed to break something
01:15:57 <BleuM937> applicative: one involving containers, deepseq, and aeson-native
01:16:27 <applicative> BleuM937: i see, aeson aeson-native etc. can produce real difficulties
01:17:15 <ts3xt6layf20keqm> http://pastebin.com/nVd4pW6U
01:17:17 <mauke> The paste nVd4pW6U has been copied to http://hpaste.org/53849
01:17:29 <ts3xt6layf20keqm> ^ could someone take a look at my code please
01:17:52 <ts3xt6layf20keqm> it uses too much memory
01:23:25 <applicative> ts3xt6layf20keqm: how many files are being written?
01:24:01 <ts3xt6layf20keqm> depends on the size of the source file and the chunk size
01:24:36 <ts3xt6layf20keqm> example: if the file is 30mb large and the target size is 1mb, it produces 30 files
01:27:55 <whald> ts3xt6layf20keqm: you are immediately unpacking your lazy bytestring into a [Word8]
01:28:31 <ts3xt6layf20keqm> what's the way around it?
01:28:36 <whald> ts3xt6layf20keqm: I recommend using the lazy BS throughout your program
01:29:46 <whald> let the line be just "content <- BL.readFile filename" and fix the type errors as they come up
01:30:34 <whald> ts3xt6layf20keqm: it's basically the split function which needs to be converted from [Word8] to BS
01:31:37 <whald> ts3xt6layf20keqm: that's not a problem at all, because there's the span function for lazy bytestrings
01:31:43 <whald> ts3xt6layf20keqm: http://hackage.haskell.org/packages/archive/bytestring/0.9.2.0/doc/html/Data-ByteString-Lazy.html
01:32:26 <ts3xt6layf20keqm> ok i get the idea
01:34:28 <whald> ts3xt6layf20keqm: I think performance may be much better once the (un)packs are gone, and it will even be somewhat shorter
01:34:39 <erus`> im having trouble setting up a cabal test
01:35:10 <applicative> ts3xt6layf20keqm: intuitively, you should be able to rewrite split with the take and drop of ByteString
01:36:15 <whald> ts3xt6layf20keqm: and your expand_io_list is already in the Prelude, where it's called "sequence_"
01:38:02 <applicative> yes, it is just specialized sequence_
01:39:16 <hpaste> applicative annotated “pastebin.com/nVd4pW6U” with “pastebin.com/nVd4pW6U (annotation)” at http://hpaste.org/53849#a53850
01:39:24 <applicative> ts3xt6layf20keqm: so following whald main looks more 'idiomatic' like that ^^^
01:40:00 <applicative> ts3xt6layf20keqm: but the problem is that you are turning your bytestring into a list to work with it
01:40:48 <applicative> oooh, don't know i knew 'zipWithM' advised by hlint
01:40:55 <erus`> cabal: No test suites enabled. Did you remember to configure with --enable-tests
01:41:00 <erus`> why do i have todo this
01:41:04 <erus`> no other package does
01:41:07 <whald> applicative: I already suggested getting rid of pack/unpack and using ByteString's native functions instead
01:41:53 <whald> whoops, I talked about using "span" which doesn't really help here, so a BL.drop/BL.take pair is the way to go
01:41:57 <applicative> whald: yes, i was agreeing with that, though it occurs to me I didn't write much of what I was thinking as I fiddled :)
01:43:04 <whald> applicative: i'm not really into file io w/ haskell, but I think there should be a O(1) way to get the file size, instead of using length?
01:43:13 <applicative> ts3xt6layf20keqm: also, what command are you compiling with? ghc --make -O2 or the like?
01:44:13 <applicative> he doesn't actually use filesize does he?
01:44:20 <ts3xt6layf20keqm> just ghc --make
01:44:38 <ts3xt6layf20keqm> i think i use it somewhere
01:44:40 <applicative> ts3xt6layf20keqm: add -O2
01:45:10 <ts3xt6layf20keqm> what does it do?
01:45:23 <kmc> optimize
01:45:53 <applicative> optimizations are added. i'm not sure what bytestring does best with, but you won't get its machinery going until you get the list manipulation out
01:47:24 <gienah> erus`: I guess because when you do configre --enable-tests it often then wants more dependencies
01:48:38 <erus`> yeah but...
01:49:02 <erus`> i have neverhad todo that before, and i am swure other packages have run tests
01:49:28 <applicative> ts3xt6layf20keqm: you might take a look at the vector package, especially Data.Vector.Unboxed
01:49:38 <gienah> erus`: cabal >= 1.8 has a new tests feature
01:50:11 <kmc> needing to explicitly enable optimizations is probably counterintuitive
01:51:11 <whald> ts3xt6layf20keqm: I just tested it, and with -O2 and working on bytestring directly it runs on constant space
01:51:13 <kmc> it's traditional, though
01:51:44 <ts3xt6layf20keqm> that was quick
01:52:01 <gienah> erus`: http://cabaltest.blogspot.com/search/label/cabal http://www.haskell.org/cabal/users-guide/#test-suites
01:52:09 <applicative> kmc, i don't think it's a big deal, the defect is that people don't print the exact compiler instruction in ever blog post :)
01:52:53 <applicative> kmc, I learned it by chance from a little tutorial by stepcut months after I started learning Haskell.  It's just a matter of publicity.
01:53:05 <whald> ts3xt6layf20keqm: the remaining problem is that the "BL.length" scans through the file once to determine it's size, and then the splitting scans the file again to perform the actual work
01:54:16 <kmc> what we really need is something that pops up in ghci and says "It looks like you're bruteforcing Project Euler problems in the interpreter!  Have you considered compiling?  Or learning maths?"
01:54:28 <applicative> kmc, I mean, I learned to add an optimization flag.  It should be on every other page of LYAH for example
01:54:42 <Jafet> I bruteforce monad transformers
01:54:46 <Jafet> Is that bad?
01:55:08 <gienah> erus`: s/cabal >= 1.8 has a new tests feature/cabal >= 1.9.2 has a new tests feature/
01:55:22 <strager> I'm looking to rewrite a do block in a more applicative style; is there something to do this for me?  http://slexy.org/view/s2Ofeu1DLv
01:56:00 <kmc> that's  liftA2 c funcA funcB
01:56:03 <applicative> strager: just write c <$> a <*> b
01:56:08 <applicative> or like kmc says
01:56:11 <kmc> also, funcA and funcB aren't functions there, most likely
01:56:19 <kmc> so it's weird to call them that ;)
01:56:24 <strager> Yeah, you're right; they're not functions
01:56:46 <applicative> the could be though, as kmc is implicitly noticing
01:56:51 <whald> ts3xt6layf20keqm: when getting the filesize using "filesize <- withFile filename ReadMode hFileSize", the whole thing is done almost instantly here (splitting a 100MB file to 1MB chunks)
01:57:14 <whald> ts3xt6layf20keqm: you'll have to import System.IO for this
01:57:34 <Jafet> preflex, nickometer ts3xt6layf20keqm
01:57:35 <preflex>  ts3xt6layf20keqm is 99.911689% lame
01:57:39 <ts3xt6layf20keqm> i supposed that gets the data from the file system
01:57:54 <ts3xt6layf20keqm> haha
01:58:15 <applicative> preflex, nickometer applicatice
01:58:16 <whald> ts3xt6layf20keqm: I just noticed that we don't need the file size at all :-D
01:58:16 <preflex>  applicatice is 0% lame
01:58:19 <applicative> preflex, nickometer applicative
01:58:19 <preflex>  applicative is 0% lame
01:58:37 <mux> preflex, nickometer mux
01:58:37 <preflex>  mux is 0% lame
01:58:47 <mux> phew, I was worried there.
01:58:51 <rostayob> preflex, nickometer 1337
01:58:51 <applicative> nice nick mux
01:58:51 <preflex>  1337 is 63% lame
01:58:54 <erus`> how do i get my cabal version?
01:58:57 <mux> hah
01:59:08 <rostayob> preflex, nickometer rostayob
01:59:09 <preflex>  rostayob is 0% lame
01:59:09 <kmc> erus`, ghc-pkg list Cabal
01:59:13 <ts3xt6layf20keqm> whald: hows that?
01:59:14 <rostayob> thanks preflex.
01:59:21 <applicative> nice nick rostayob
01:59:22 <strager> Thanks applicative, kmc
01:59:49 <gienah> erus`: cabal --version
01:59:55 <whald> ts3xt6layf20keqm: just look at your code, the filesize variable is not used anywhere
02:00:20 <ts3xt6layf20keqm> good point ;]
02:00:26 <kmc> ah, cabal --version prints versions of both Cabal and cabal-install
02:00:27 <kmc> cool
02:00:35 <whald> ts3xt6layf20keqm: :-)
02:01:25 <kmc> but you can upgrade the Cabal library without rebuilding the cabal-install binary
02:03:52 <gienah> kmc: I guess since cabal-install is an executable, it could be left being being built with the old Cabal library
02:05:44 <erus`> http://stackoverflow.com/questions/8077896/cabal-tests-on-windows-7
02:06:10 <gienah> kmc: I'm not sure though as maybe using the cabal-install built with the old Cabal library might (I don't know) cause other problems
02:08:55 <gienah> erus`: I'm not sure, I never use cabal, I wonder if you need to do (after the cabal configure --enable-tests): cabal build
02:12:29 <erus`> ah thanks
02:13:06 <gienah> erus`: no worries
02:13:39 <applicative> whald it just occurred to me that strict bytestrings have O 1 length
02:17:48 <erus`> hmm can i import a package like this ../Blah.Meh ?
02:19:00 <kmc> you mean from the directory above where you're running ghc?
02:19:06 <kmc> (and did you mean 'module' not 'package"?)
02:20:28 <erus`> ah i am an idiot ignore
02:21:06 <kmc> do you understand the difference between modules and packages?
02:21:09 <kmc> they're different kinds of things
02:21:18 <erus`> yeah i meant module
02:21:21 <erus`> or even file
02:24:22 <applicative> you mean something like ghci ../Test/Nonsense.hs ?
02:24:37 <erus`> yeah
02:24:53 <erus`> but it turned out i just wasnt laying out my root directory correctly
02:25:12 <applicative> erus` for that you have to use the file system language, obviously, though i frequently have to retype....
02:25:22 <applicative> oh i see
02:27:56 <Baughn> gwern: mueval 0.8.1 breaks --loadfile?
02:37:15 <ts3xt6layf20keqm> http://pastebin.com/1bVXhE8q
02:37:16 <mauke> The paste 1bVXhE8q has been copied to http://hpaste.org/53851
02:37:43 <ts3xt6layf20keqm> ^ i made changes, and now the pack/unpack are gone
02:38:49 <ts3xt6layf20keqm> and i compiled it with -O2, but it doesnt run on constant space
02:39:14 <ts3xt6layf20keqm> did i miss something?
02:40:46 <ddarius> By calculating the length of the list of chunks, you need to read in all the chunks.
02:41:30 <ddarius> Also, x <- return $ f y is usually better written let x = f y
02:43:20 <ts3xt6layf20keqm> is there another way to do it?
02:44:26 <deggis> i've some kind of type/package problem http://hpaste.org/53853 ideas?
02:46:30 <Baughn> > 42
02:46:31 <lambdabot>   42
02:46:39 <Baughn> @check \n -> n == 42
02:46:39 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
02:46:51 <Baughn> ..right. Which version of mueval is that?
02:47:14 <Baughn> 0.8.1 doesn't work with @check, 0.8 doesn't work with >...
02:47:20 * Baughn grumbles
02:48:51 <Tinned_Tuna> > (\n -> n) 42
02:48:52 <lambdabot>   42
02:49:55 <whald> ts3xt6layf20keqm: your code looks good now, what kind of file do you test it with?
02:50:13 <whald> ts3xt6layf20keqm: e.g. what (chunk, file) sizes?
02:50:37 <ts3xt6layf20keqm> source = 600mb, chunk = 300mb
02:51:22 <whald> ts3xt6layf20keqm: hmm, you're right, there's still something fishy. :-/
02:51:41 <whald> ts3xt6layf20keqm: I'll have a look, now I'm curious :-)
02:53:41 <ddarius> ts3xt6layf20keqm: To test, you can simply pass in 2 (or 3) for where you are passing in length and see if that makes it perform better.
02:54:28 <ts3xt6layf20keqm> ok ill try 3
02:54:33 <ddarius> But as written, you definitely will be reading the entire input into memory before you begin writing at all.
02:57:50 <Blkt> (a late) good morning everyone
02:58:48 <deggis> better advertisement for http://hpaste.org/53853 : type synonyme problem of some kind, ideas?
03:01:33 <hpaste> amtal pasted “Combinatoric parser trouble” at http://hpaste.org/53854
03:02:00 <zeiris> I've got a problem with a parser discarding parse state or something. I have the feeling i'm incorrectly parsing zeroth-order symbols.
03:02:18 <zeiris> What should I be using instead of Foo <$ symbol "foo" <?> "descr"?
03:02:59 <o-_-o> What is the Pilot DSL ?
03:03:29 <ion> parseTest (lang <* eof)
03:04:31 <zeiris> (My problem is in http://hpaste.org/53854)
03:04:38 <ion> You’ll want to make sure you parse successfully all the way to the end.
03:04:50 <whald> ts3xt6layf20keqm: getting rid of the length really helps, it's *really* in constant space now, tried splitting a 5GB file to 10 MB chunks
03:05:01 <Jaak> yep, seems like "foo" is in the grammar, but not "foo,bar"
03:05:50 <amtal> But "foo" and "bar" are, and are joined by sepBy :: m a -> m sep -> m [a]
03:06:27 <whald> ts3xt6layf20keqm: I pasted a hlint-clean version to http://hpaste.org/53855 (just in case)
03:06:33 <ion> Did you try my suggested change to the test function yet?
03:06:45 <amtal> I'm not sure what that change entails.
03:07:14 <amtal> Should I seq over it?
03:07:31 <ion> < ion> parseTest (lang <* eof)
03:08:26 <ts3xt6layf20keqm> yes, getting rid of length seems to help
03:09:08 <ts3xt6layf20keqm> still, it seems to load whole chunks into memory
03:09:10 <amtal> ion: hm, that seems to work - forces an error if it doesn't parse to EOL. Thanks :)
03:09:35 <ts3xt6layf20keqm> so if the chunk size is 300mb, it uses 300mb of memory and so on
03:10:29 <ts3xt6layf20keqm> i want it to be like 10mb regardless of the target segment length
03:10:49 <whald> ts3xt6layf20keqm: i see, mompl
03:10:55 <amtal> sepBy still seems to behave weird around newlines. Hm.
03:11:28 <ion> Hint: "foo,bar" contains zero newlines.
03:11:38 <amtal> Yes, fixed that :)
03:11:55 <jello> hello
03:12:32 <jello> hei hei heiee
03:12:34 <jello> ...
03:12:56 <opqdonut> hi.
03:14:15 <jello> wew
03:45:41 <peng_> Can haskell code run on Android right now?
03:48:52 <HugoDaniel> hi
03:49:06 <HugoDaniel> i need to format some data types to one of those old school cobol output .txt files
03:49:29 <HugoDaniel> with fixed dimension in each line, and special characters/numbers in given column positions
03:49:35 <HugoDaniel> what is the best haskell package to do this ?
03:50:11 <kmc> i'd just use Text.Printf unless i had a huge number of these to lay out
03:50:37 <HugoDaniel> not many, about 8k lines
03:50:41 <HugoDaniel> cool
03:50:43 <HugoDaniel> thanks :)
03:51:02 <kmc> i mean the number of different layouts
03:51:24 <kmc> if you had to describe lots of different layouts then it might be worth implementing a little language for them
03:51:34 <kmc> but the printf format language is already close
03:51:50 <HugoDaniel> its only 3 layouts, one for header lines, one for body lines, and one for footer lines
03:51:58 <kmc> cool
03:52:00 <HugoDaniel> yes, printf seems to be the perfect fit for this :)
03:52:05 <Jafet> kmc does not grok the cobol way
03:53:20 <Jafet> Wow, the SDL package has great haddocks
03:55:07 <HugoDaniel> SDL = the opengl stuff?
03:55:21 <Jafet> http://hackage.haskell.org/packages/archive/SDL/0.6.2/doc/html/Graphics-UI-SDL-Video.html#v:createRGBSurface
03:55:35 <HugoDaniel> i have done a small package to open a opengl 3.3 context in xorg: http://hackage.haskell.org/package/GLHUI
03:57:05 <kmc> Jafet, what's so remarkable about this haddock?
03:57:32 <Jafet> Well, it seems to contain no actual documentation
03:57:51 <HugoDaniel> it should be a direct 1-1 mapping of the c function
03:57:58 <kmc> ah, good old sarcasm :)
03:58:16 <kmc> yeah I expect you're supposed to refer to upstream SDL docs
03:58:20 <kmc> they could still be much better though
03:58:27 <kmc> in particular these should be organized into sections
03:58:45 <Jafet> I hope not, because the upstream docs aren't much better
03:59:00 <kmc> haha
03:59:03 <kmc> that could explain it then
03:59:28 <Jafet> Heh
03:59:45 <Jafet> They at least describe how to use functions, though
04:26:35 <bxc> doh missed dutch-hug this month
04:29:57 * hackagebot hexpat 0.19.8 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.8 (StephenBlackheath)
04:37:58 <hpaste> Taejo pasted “cabal-dev woes” at http://hpaste.org/53857
04:38:15 <Taejo> I'm getting an error from cabal-dev ghci -- any ideas?
04:50:23 <erus`> how do i test doubles equality with an epsilon
04:51:14 <kmc> :t ((<= ?eps).) . (-)
04:51:15 <lambdabot> forall a. (?eps::a, Ord a, Num a) => a -> a -> Bool
04:55:17 <opqdonut> kmc: you forgot an abs
04:55:30 <kmc> ah yeah
04:57:12 <Phyx-> is there a concatMapM somewhere?
04:59:27 <kmc> @hoogle concatMapM
04:59:28 <lambdabot> No results found
05:00:01 <kmc> hayoo finds some with weird types
05:00:09 <kmc> but i'd just write fmap concat . mapM f
05:00:18 <quicksilver> what would be the advantage over concat <$> mapM f?
05:00:30 <kmc> http://hackage.haskell.org/packages/archive/Agda/latest/doc/html/Agda-Utils-Monad.html :D
05:00:38 <quicksilver> there are some concatMapMs in some of the enumerator/interatee libraries IIRC
05:00:41 <erus`> thanks kmc :)
05:05:27 <Phyx-> kmc: yeah, ended up doing that
05:05:48 <Phyx-> quicksilver: rather not add another package dependency
05:05:53 <Phyx-> i'll just define it locally
05:07:49 <erus`> Phyx-: did you manage to get rid of the cabal permission error?
05:12:06 <Phyx-> erus`: I wasn't the one with the error, I used to have it, but then it just went away before i could get a chance to see why it happened
05:12:38 <erus`> you wernt the one with the error but you used to have it :|
05:12:51 <Phyx-> well, i phrased that wrong..
05:13:06 <Phyx-> I meant to say, I'm not the one currently with the problem :P
05:13:14 <erus`> no I am...
05:13:23 <Phyx-> ah
05:13:25 <erus`> im lost :P
05:13:40 <Phyx-> did you try deleting the dist? nothing changed?
05:14:22 <erus`> yep deleted and did cabal build
05:15:11 <Phyx-> what's the last line you get before the error? does it tell you that all tests suites completed?
05:15:39 <erus`> yep it says all PASS then Test suite logged to: dist\test\S3DM-0.0.1-test-s3dm.log
05:17:25 <Phyx-> lemme see if that string is being printed by cabal (e.g. someone in the code) or something else
05:21:35 <dgpratt> what's the best way to get the Haskell tool chain on Arch?
05:22:25 <mm_freak> dgpratt: pacman -S ghc
05:22:26 <mm_freak> basically
05:22:54 <mm_freak> you might also want:  pacman -S cabal-install
05:23:01 <Abraxas> :t (\msg -> const (Left msg::String))
05:23:01 <dgpratt> mm_freak: ok, thanks
05:23:02 <lambdabot>     Couldn't match expected type `String'
05:23:02 <lambdabot>            against inferred type `Either a b'
05:23:02 <lambdabot>     In the first argument of `const', namely `(Left msg :: String)'
05:24:31 <Abraxas> :t (\msg -> const (Left (msg::String)))
05:24:32 <lambdabot> forall b b1. String -> b1 -> Either String b
05:25:39 <Abraxas> hey mm_freak, it was just failure for that errorMsg function, you were right
05:25:56 <Phyx-> erus`: you can try using process monitor to see what cabal is trying to do. Should show you the failing call
05:28:33 <KitB> Is there a reason amelie isn't on hackage?
05:29:17 <KitB> (or if it is, why I can't find it?)
05:30:20 <Nimatek> dgpratt: the haskell-platform package
05:33:18 <Abraxas> let swap x y = y x
05:33:22 <Abraxas> :t swap
05:33:23 <lambdabot> Not in scope: `swap'
05:33:46 <Phyx-> erus`: did you get anything?
05:33:58 <Jaak> :t let swap x y = y x in swap
05:33:59 <lambdabot> forall t t1. t -> (t -> t1) -> t1
05:34:05 <erus`> not really sure what to look for
05:34:13 <Abraxas> ah
05:34:35 <Abraxas> right, let is an expression
05:34:41 <Phyx-> erus`: filter by cabal.exe, <test-suit-name>.exe, ghc.exe, gcc.exe and realgcc.exe
05:34:48 <Phyx-> and then filter by failed results
05:34:53 <Jaak> :t let swap (x,y) = (y,x) in swap -- mebbe?
05:34:54 <lambdabot> forall t t1. (t, t1) -> (t1, t)
05:37:22 <Abraxas> i wanted to ask why it's t and t1 instead of a and b
05:37:36 <Abraxas> i guess, because of the missing instance declaration
05:37:43 <erus`> sharing violation?
05:38:16 <erus`> name collision...
05:39:57 <Phyx-> erus`: what's the package you're trying to test? i'll see if i can reproduce it locally
05:40:13 <erus`> https://github.com/tm1rbrt/S3DM
05:41:01 <kmc> Abraxas, instance declaration?
05:41:10 <Phyx-> the command to checkout is get clone right?
05:41:23 <erus`> yup
05:41:27 <erus`> git clone*
05:41:42 <kmc> ghc will try to use the type variables given in the type signature (if any) but it's all a bit arbitrary
05:41:42 <Phyx-> i'm getting "error: error setting certificate verify locations:"
05:41:47 <Phyx-> i'll grab a zip
05:42:32 <Abraxas> nm, was nonsense
05:42:42 <Abraxas> i called it with swap 3 4 :D
05:42:47 <Abraxas> there is no show
05:43:06 <Abraxas> then my question still stands
05:43:44 <Abraxas> how is it determined whether it's t, a, b or whatever for the type
05:44:19 <quicksilver> you do realise it doesn't matter, yes?
05:44:31 <Abraxas> sure
05:44:32 <kmc> right, they are arbitrary names for freshly-introduced variables
05:44:34 <quicksilver> what GHC does in practice is use the letters used in the type signatures of the functions you use
05:44:36 <kmc> if you give a type signature, ghc will try to use the variables from the signature
05:44:38 <quicksilver> if there are any
05:44:47 <quicksilver> otherwise it just uses t,t1,t2,t3 I think
05:44:47 <kmc> :t let swap :: (a,b) -> (b,a); swap (x,y) = (y,x) in swap
05:44:48 <lambdabot> forall a b. (a, b) -> (b, a)
05:44:51 <Abraxas> but it's always t and t1 in this case
05:44:59 <Abraxas> but a and b in others
05:45:08 <quicksilver> because they have type signatures
05:45:12 <quicksilver> :t map
05:45:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:45:15 <kmc> like the example i just gave
05:45:18 <Phyx-> erus`: yeah, i get it too, i'll try and find why
05:45:18 <quicksilver> ^^ defined in map's type sig
05:45:22 <quicksilver> :t (map,map)
05:45:23 <lambdabot> forall a b a1 b1. ((a -> b) -> [a] -> [b], (a1 -> b1) -> [a1] -> [b1])
05:45:34 <quicksilver> ^^ tries to use map's type sig, but needs a fresh a and b
05:45:38 <Abraxas> that makes sense
05:45:38 <quicksilver> so it uses a1 and b1
05:45:41 <Abraxas> haha
05:45:55 <kmc> :t (undefined,undefined,undefined,undefined,undefined,undefined,undefined)
05:45:56 <lambdabot> forall a a1 a2 a3 a4 a5 a6. (a, a1, a2, a3, a4, a5, a6)
05:53:50 <Phyx-> damn internet
05:54:49 <Phyx-> erus`: yeah, seems you were right
05:55:05 <erus`> whats wrong with it?
05:56:30 <Phyx-> erus`: there's a sharing violation going on with the log file. it seems like a bug in cabal
05:56:48 <erus`> :O
06:01:08 <Phyx-> wonder why it's trying to create two log files
06:01:10 <Phyx-> for one test
06:04:10 <Phyx-> erus`: if i'm reading this right, it's trying to delete a file that doesn't exist
06:04:56 <Taejo> isn't the point of Data.GraphViz.graphToGraph to add attributes to the graph? I'm getting empty attribute lists
06:05:22 <Phyx-> erus`: http://p.zhox.com/inrqcgop
06:08:59 <erus`> looks like double dutch to me
06:13:39 <Taejo> > let x+3 = 6 in x*7
06:13:40 <lambdabot>   x * 7
06:13:55 <Taejo> > let (x + 3) = 6 in x*7
06:13:56 <lambdabot>   <no location info>: Parse error in pattern
06:26:30 <Phyx-> erus`: think i've narrowed it down
06:27:35 <Phyx-> erus`: it seems cabal has a race condition going on
06:28:08 <erus`> is it only on windows?
06:28:08 <Phyx-> if the test suits don't last long enough, it'll try to delete a log file while something else has the lock
06:28:15 <Phyx-> i'm not sure, I only have windows
06:28:42 <Phyx-> you can confirm it by putting like "print [1..1000000]" in runTest
06:28:48 <Phyx-> you'll see the error go away
06:29:10 <khs> is there a way in haskell to run a program without IO ?  like, main = 3+3 , and have the result returned?
06:29:25 <Phyx-> mine robably went away because my test-suits when completed take 3-5mins each
06:29:28 <Phyx-> probably*
06:30:37 <Phyx-> khs: no, the result of main is ignored
06:30:53 <Phyx-> you can print it to a handle or something though
06:33:00 <Phyx-> erus`: did making it last longer make it go away there too? wanna check that it's just not a fluke here
06:33:41 <kmc> khs, returned where? printed to the screen?
06:33:48 <khs> yes
06:33:55 <kmc> main = print (3+3)  -- ;P
06:34:04 <kmc> but you can also type 3+3 at the ghci command line
06:34:15 <kmc> or at the shell command line like so:    ghc -e '3+3'
06:34:38 <erus`> 1 sec
06:34:53 <Phyx-> guess i shoulda asked what he meant with return...
06:35:09 <Phyx-> i think i covered all my basis though :P
06:35:31 <khs> thanks, but not exactly what I'm looking for (I think), I would like a program that does not depend on anything but primitive functions. I need an extremely simple Core program.
06:35:55 <kmc> ah, then you should probably write it by hand
06:35:59 <kmc> what do you need it for?
06:36:23 <kmc> also what do you mean by 'primitive functions'? the things in GHC.Prim?
06:36:30 <rotflcopter> hi
06:36:33 <kmc> i think some more context about what you're doing would be useful
06:36:33 <rotflcopter> bline from (10,10) to (10,10)
06:36:33 <rotflcopter> deltaerr=-nan
06:36:34 <khs> I need it to test an interpreter
06:36:38 <kmc> hi rotflcopter
06:36:43 <rotflcopter> should i be concerned? && plot a pixel instead?
06:36:47 <Phyx-> kmc: wth do you mean write it by hand? lol
06:37:10 <kmc> Phyx-, Core ≠ Haskell, if you want the shortest possible Core, you should probably write it yourself
06:37:20 <DRMacIver> So I'm attempting a new Haskell project and (somewhat reluctantly) using cabal for it. I can't seem to figure out how to get a test suite to work. It's failing in remarkably unhelpful ways. http://pastebin.com/PAJ4vY2E for details
06:37:22 <mauke> The paste PAJ4vY2E has been copied to http://hpaste.org/53862
06:37:50 <Phyx-> kmc: ah, like that. I did not interpret correctly what he meant with Core, my bad
06:38:38 <khs> I have a parser and an interpreter for Core programs, I just need to build an AST from the parsed Core. The interpreter has no IO implemented.
06:38:41 <erus`> Phyx-: nope stil lerror for me :|
06:38:43 <kmc> khs, did you write the interpreter?
06:38:47 <khs> nope
06:38:47 <Phyx-> DRMacIver: did you look at the log file? (and it's asking you to reconfigure)
06:39:16 <kmc> also what do you mean by "build an AST from the parsed Core"
06:39:20 <Phyx-> erus`: heh, weird. it goes away here, did you remember to build? i forgot it the first time myself :P
06:39:20 <kmc> if it's parsed, isn't it already an AST?
06:39:47 <hpaste> erus` pasted “math error?” at http://hpaste.org/53863
06:39:53 <khs> kmc: Well, I guess it is not parsed then, tokenized
06:39:57 <erus`> can anyone see the issue there ?
06:40:09 <erus`> Phyx-: yep lol
06:40:23 <erus`> test took about 10 seconds too
06:40:32 <DRMacIver> Phyx-: Yes, I not only looked at it I pasted it in that paste
06:40:40 <DRMacIver> Phyx-: It contains no useful information
06:40:51 <Phyx-> DRMacIver: oh my bad, i didn't see that part
06:41:29 <Phyx-> DRMacIver: it usually logs anything that your test program prints out. try running the compiled test program yourself, see if you get more info
06:41:33 <DRMacIver> Phyx-: Also it wasn't asking me to reconfigure, it was saying "I'm reconfiguring. Try it manually if it goes wrong" (I had reconfigured manually)
06:42:00 <DRMacIver> Phyx-: I'm sure it's failing to compile. I can't find any evidence that it's built an executable. But I can't figure out why
06:42:04 <Phyx-> erus`: weird,
06:42:29 <Phyx-> DRMacIver: cabal test doesn't build anything, so if it's building cabal build would have the the one to fail
06:42:58 <Phyx-> afaik atleast
06:42:58 <DRMacIver> Oh, I see
06:43:26 <DRMacIver> this is another instances of Cabal's *hilarious* role as a build system that doesn't track dependencies between tasks.
06:43:33 <DRMacIver> So I have to do cabal build then cabal test or nothing works.
06:44:38 <DRMacIver> FFS. This is why I had the parenthetical "somewhat reluctantly". Every time I come back to Haskell I have to relearn all over again how much I hate cabal.
06:44:43 <Phyx-> erus`: I still think it's some kind of race condition, but I would guess dcoutts_ would be the one to ask if that's possible or not
06:44:44 <DRMacIver> Anyway, thanks Phyx-, that solved it :)
06:45:03 <Phyx-> DRMacIver: np
06:45:33 <rotflcopter> DRMacIver<< hahah yes im sharing the opininon, a simple bash script coul dreplace Cabal and be better
06:46:39 <rotflcopter> or maybe install all libraries instead
06:46:45 <kmc> i've done dozens of projects with cabal and it's always been pleasant
06:46:51 <Phyx-> same
06:47:11 <rotflcopter> kmc<< what do you mean by that?
06:47:14 <Phyx-> I don't really have an issue with Cabal, now make on the other hand..
06:47:20 <kmc> what do you mean by what do i mean by it
06:47:39 <rotflcopter> cabal is not just installing libraries and dependencies from the hackageM
06:47:40 <rotflcopter> ?
06:48:08 <kmc> rotflcopter, you know how those libraries get there?
06:48:27 <rotflcopter> kmc<< well.. you wrote them?
06:48:40 <kmc> most of the libraries on hackage were not written by me
06:48:42 <kmc> but yes
06:49:22 * Phyx- has been trying to fix a bug in cabal for a while now, but can't figure out where Setup.(l)hs is stored in the process
06:49:34 <rotflcopter> kmc<< so what would be the downside of installing every library ?
06:49:48 <kmc> you want to install every library from hackage?
06:49:55 <DRMacIver> kmc: fair enough. Personally, I don't understand how you possibly can not have had issues with cabal.
06:49:56 <kmc> i don't understand why, or how it relates to the previous topic
06:50:06 <rotflcopter> kmc<< so i dont need cabal
06:50:07 <kmc> DRMacIver, I have had issues
06:50:10 <rotflcopter> that was my point
06:50:26 <kmc> i've also had issues with every other build system in the world
06:50:48 <DRMacIver> A build system which tells you "I can't do that because you need to manually run this command first" is pretty ridiculous.
06:50:58 <rotflcopter> :)
06:51:00 <rotflcopter> ahaha
06:51:08 <Phyx-> DRMacIver: to be fait, you can just run cabal install --enable-tests
06:51:14 <Phyx-> and it'll do all those phases
06:51:18 <Phyx-> except for testing
06:51:26 <rotflcopter> DRMacIver<< and counting spaces (unsuccessfully) in config file
06:51:32 <rotflcopter> ;>>
06:51:35 <DRMacIver> Phyx-: Well except this is starting a new project, not doing cabal install...
06:51:42 <kmc> i'm kind of annoyed by the attitude online where every piece of software is either "awesome sexy rainbows unicorns" or "utter shit, total garbage, the developers need to go to hell and eat pig shit and die for eternity"
06:52:02 <Phyx-> DRMacIver: you can cabal install local projects too
06:52:07 <kmc> cabal works pretty well, it's not perfect
06:52:11 <Phyx-> just ommit the last parameter
06:52:15 <DRMacIver> kmc: I'm kind of annoyed by people parodying legitimate complaints as hyperbole
06:52:16 <kmc> same with all the software i use
06:52:42 <DRMacIver> No, sorry, I genuinely can't agree with the statement that cabal works pretty well.
06:52:49 <kmc> it's clearly not working well for you
06:52:50 <DRMacIver> But I also don't really care to get into an argument baout it.
06:52:59 <kmc> i'm sure your complaint is legitimate
06:53:07 <rotflcopter> maybe the problem is cabal is too functional, and the functions are not complex enough
06:53:16 <kmc> but there's a channel full of people who use it successfully
06:53:25 <kmc> so your data point is one out of many
06:53:45 <DRMacIver> The history of computing is the history of people managing to somehow function with crappy software. That doesn't make the software good. :)
06:53:47 <erus`> cabal is absolutely unusable! because i get a non-critical warning after running cabal test on my project
06:53:57 <rotflcopter> im currently applying functional programming logic in a C source
06:53:57 <DRMacIver> erus`: Err, what?
06:54:14 <DRMacIver> erus`: I didn't get a non-critical warning. I got a complete failure to work and no useful explanation of the error.
06:54:14 <rotflcopter> its way cool
06:54:16 <rotflcopter> :)
06:54:32 <erus`> tough break :) i just got a warning
06:54:33 <Phyx-> to be fair to cabal
06:54:37 <Phyx-> you could have also RTFM
06:55:32 <DRMacIver> Phyx-: to be fair to cabal, it could also have worked in a sensible way rather than me needing to read a manual to get an explanation of why it doesn't work in a sensible.
06:55:34 <luite> cabal work better if you use it more often :)
06:56:07 <roconnor_> luite: that has been the opposite of my experience.  The more I use cabal the less it works
06:56:21 <Phyx-> lol, for every ying there's a yang
06:56:24 <rotflcopter> Phyx-<< i was demotivated by cabal when i read it attempts to count the number of spaces in the config file, and rejected working when installed with prefix :(
06:56:38 <DRMacIver> Sensible ways here would include either of "doing the right thing and having task dependencies" or "give an actually useful error message". I'm not terribly fussy
06:56:49 <DRMacIver> (granted the error message would have pissed me off, but at least I'd have known what was wrong)
06:57:13 <erus`> DRMacIver: yeah but that would be too easy. You enjoy a puzzle dont you?
06:57:13 <Phyx-> rotflcopter: "rejected working when installed with prefix" ?
06:57:14 <roconnor_> that said, I respect that the task that cabal attempts to solve is really really hard
06:57:32 <luite> roconnor_: hehe, I mean in a relative sense. if you don't use it for a long time and then cabal update, cabal install, it's often not able to complete the installation because it cannot solve the dependencies due to old installed packages
06:57:36 <Phyx-> I remember cabal had a prefix bug a while back (few years) but hey, all software have bugs though
06:57:40 <roconnor_> and that cabal + hackage has been overwhelmingly better than without
06:57:47 <DRMacIver> rotflcopter: My experience seems to suggest that it's actually all the really easy things that cabal does badly and the hard stuff it does quite well. :)
06:57:51 <DRMacIver> err. roconnor_ ^^
06:58:03 <Phyx->  I have bugs that prevent me from using sdist and clean, but yet I still think cabal is a good tool
06:58:04 <rotflcopter> Phyx-<< yes it does not work to me, i have installed GHC with prefix, and then cabal (they were in 7.02 haskell package)
06:58:05 <roconnor_> DRMacIver: oh interesting.
06:58:09 <dafis> DRMacIver: examples?
06:58:09 <kmc> DRMacIver, i understand that you're frustrated, but it usually doesn't go over too well here to phrase your question as "your software sucks and I'll abandon it and hate you forever unless you fix my problem right now"
06:58:16 <kmc> i know it's very effective in some other channels
06:58:29 <DRMacIver> kmc: And again with the parodying.
06:58:36 <DRMacIver> kmc: My problem was fixed a while ago...
06:58:56 <rotflcopter> kmc<< ahah, i'd say i wanted to start it, but could not yet
06:59:08 <kmc> rotflcopter, what?
06:59:09 <DRMacIver> kmc: I am observing a problem. If you choose to pretend that problem doesn't exist and the problem is with me, go wild.
06:59:38 <DRMacIver> roconnor_: As you say, cabal makes the hackage ecosystem a lot better than its absence would, and manages to set some decent cross project standards.
06:59:46 <DRMacIver> But as a build system it's significantly inferior to even things like make.
06:59:50 <erus`> DRMacIver: did you file a bug report/ feature request?
07:00:07 <rotflcopter> kmc<< well i was considering to start coding something useful with GHC but its on hold line, because currently i cannot even plot a pixel into a window without having the cabal thing install some includes :)
07:00:16 <roconnor_> DRMacIver: I guess that is possible.  I've never use anything beyond ghc --make for my make process
07:00:36 <rotflcopter> so im coding in C instead
07:00:45 <kmc> ok
07:00:51 <erus`> rotflcopter: use GLUT. it comes with the platform
07:00:51 <Phyx-> DRMacIver: i would disagree whole heartedly
07:00:55 <Phyx-> Make is a complete mess
07:01:18 <cheater> yeah, make is so freaking annoying
07:01:22 <rotflcopter> erus`<< wanted to do that, but since cabal will not install it i cant :)
07:01:40 <rotflcopter> and im unsure its worth the time trying to install it manually
07:01:41 <DRMacIver> Phyx-: On the other hand when I type "make test" it doesn't fail mysteriously or tell me "I can't run make test because you haven't yet typed make build" :)
07:01:53 <Phyx-> And I postulate, that the reason test doesn't do any building is because your tests can depend directly on your program. for instance when testing a library. in which case the rest needs to be rebuild too.
07:01:58 <erus`> rotflcopter: it comes with the platform! :)
07:02:08 <roconnor_> DRMacIver: doesn't it say something like run ./configure first?
07:02:12 <rotflcopter> erus`<< i have 'installed' the platform
07:02:18 <rotflcopter> :P
07:02:24 <erus`> well then you can use it
07:02:27 <DRMacIver> roconnor_: That's autoconf. I made no claim that autoconf was superior to cabal :)
07:02:34 <rotflcopter> i seem not to be able
07:02:58 <roconnor_> Isn't make useless without something like autoconf?
07:03:17 <kmc> no
07:03:37 <Phyx-> DRMacIver: out of curiousity, were you useing the IO based test suit or the more detailed variant?
07:03:54 <Phyx-> test interface*
07:06:42 <DRMacIver> Phyx-: My "test interface" at the moment is "main = return ()" :)
07:06:58 <DRMacIver> Phyx-: It doesn't contain any actual tests. I wanted to get it running first...
07:07:04 <DRMacIver> roconnor_: No. Make is fine without autoconf.
07:07:20 <Phyx-> DRMacIver: I was refering to the "type" file in your cabal file
07:07:23 <Phyx-> under Test-suite
07:07:38 <Phyx-> but it's probably exitcode-stdio?
07:07:42 <DRMacIver> Oh, right. It's down as exitcode-stdiot
07:07:55 <roconnor_> I'm pretty sure you cannot usually tar up a make file and source code and transport it to another machine and get it to build in most cases.
07:08:13 <roconnor_> well, maybe you add all the sources of all the dependencies to make
07:08:25 <roconnor_> (not that make will tell you alll the dependencies)
07:08:42 <kmc> you can and many projects do exactly that
07:08:51 <mike-burns> autoconf has a use, but until you hit that use just make is fine.
07:08:53 <kmc> but also many projects use a small configure script which is not autoconf-based
07:09:11 <rotflcopter> seriously, i can do everything ghc does in C in 10 years
07:09:22 <rotflcopter> ;>>
07:09:54 <kmc> and everything that ever will be done has already been done in Lisp 40 years ago, so what
07:11:38 <cheater> everything that you could do in lisp has already been said in arameic 2000 years ago
07:11:48 <roconnor_> this reminds me that I need to make an OS with more controled access to system calls to make builds more reproducable.
07:12:36 <rotflcopter> roconnor_<< ever tried linux?
07:12:53 <kmc> what is with this rotflcopter<< thing
07:13:01 <rotflcopter> :)
07:13:10 <kmc> is roconnor_ an std::ostream?
07:13:11 <rotflcopter> its C++
07:13:14 <kmc> haha i knew it
07:13:18 <rotflcopter> ;>>
07:13:28 <rotflcopter> cout<<"hi!";
07:13:40 <cheater> kmC++
07:13:42 <roconnor_> rotflcopter: ya, but the execuable you build all have the system time stored in the executable, so builds are not reproducable, IIRC.
07:13:44 <kmc> you should go to ##c++ and play with their C++ eval bot
07:13:57 <hpc> there's a c++ eval bot?
07:14:03 <rotflcopter> roconnor_<< so strip the headers
07:14:04 <hpc> that sounds phenomenally dangerous
07:14:07 <cheater> hpc: sure why not?
07:14:08 <kmc> yes, named geordi
07:14:21 <kmc> it has various system-level sandboxing
07:14:30 <roconnor_> rotflcopter: strip the headers of what? ghc?
07:14:31 <Phyx-> 16:24:19 < hpc> that sounds phenomenally dangerous <--- for some reason, this made me laugh so hard milk came out of my nose
07:14:31 <roconnor_> er
07:14:34 <roconnor_> rotflcopter: strip the headers of what? gcc?
07:14:48 <rotflcopter> roconnor_<< i thought you were talking about compiled executables
07:14:49 <hpc> Phyx-: :D
07:14:53 <kmc> #esoteric has a bot that will execute lots of languages including arbitrary shell commands
07:15:02 <kmc> Phyx-, gross :(
07:15:11 <Phyx-> lol
07:15:20 <cheater> roconnor_: i think he means stripping the *symbols*
07:15:35 <cheater> roconnor_: but i don't think binary stripping would pick that one up
07:15:37 <roconnor_> cheater: ah ok
07:15:39 <hpc> on another network we were joking about how useless a python eval-bot would be, because you couldn't fit anything useful on one line
07:15:47 <cheater> roconnor_: you can intercept syscalls with LD_PRELOAD
07:16:02 <kmc> not always but usually
07:16:15 <roconnor_> rotflcopter: only if libc is used right?
07:16:17 <kmc> you can also intercept syscalls with ptrace
07:16:31 <kmc> but i'm not sure you can abort a syscall in progress
07:16:34 <kmc> or just trace them
07:17:08 <roconnor_> this might work, but it is a hack.  What is need is similar to the SAFE mode of ghc.
07:17:24 <roconnor_> well maybe not that similar
07:17:37 <hpc> what's SAFE mode? it's not on the man page
07:17:53 <luite> you can ptrace break before teh syscall
07:17:58 <roconnor_> hpc -XSafe
07:18:03 <luite> and then change it if you don't want it to be made
07:18:36 <Tinned_Tuna> you'd be surprised how much one line of python can actually do. It just takes a long while to write the line, and it's very unreadable.
07:19:09 <Tinned_Tuna> It's not as powerful as Haskell, but it can still do a semi-reasonable amount :-p
07:19:22 <roconnor_> luite: This would work, but it is like the access restriction method of doing security where you try to patch up all the unsafe bits.  Better is the capabilities approach where only safe things are allowed to begin with.
07:19:45 <luite> roconnor_: right I missed part of the discussion
07:19:57 <roconnor_> still, it is good to know what can be done in Linux
07:20:10 <Jafet> roconnor: so block any syscalls you don't like
07:20:13 <luite> roconnor_: it's not really a good security mechanisme due to race conditions though
07:20:14 <roconnor_> since patching Linux is certainly easier than rewriting an operating system.
07:20:55 <luite> roconnor_: for my own sandboxed haskell project I opted against it for that reason
07:21:14 <kmc> ptrace-based sandboxing is vulnerable to race conditions?
07:21:14 <roconnor_> Jafet: then I also need to patch gcc to stop making those system calls.  But yes, blocking certain system calls would be a start.
07:21:40 <kmc> there is lots of work in this area on linux
07:21:47 <roconnor_> well maybe it is the linker who is putting in the timestamps; who knows
07:21:49 <kmc> for example seccomp
07:21:54 <Jafet> Well, ptrace gcc separately
07:21:56 <kmc> i think there was a recent project to make seccomp more fine-grained
07:22:06 <Jafet> And hope it doesn't have privilege escalation holes
07:23:13 <luite> kmc: yes in some situations. if you have indirect parameters, you can prepare it in such a way that the checker gets a page fault during the check, and then get a chance modify a part of the argument that has already been checked, from a different thread
07:23:40 <luite> kmc: checking syscall numbers seems safe for that attack, but checking file paths for access not
07:23:55 <kmc> luite, very tricky
07:23:58 <kmc> thanks for telling me about this :)
07:24:21 <rotflcopter> roconnor_<< well i started at the beginning, ASM, that's close to hardware, the OS specific header parts in executables are just decorations in a program binary...
07:25:00 <kmc> ASM is not very close to hardware at all
07:25:14 <luite> kmc: Eelis told me about it, there was a pdf presentation of some guy that had succesfully demonstrated it
07:25:42 <rotflcopter> kmc<< well you can manupilate the CPU registers directly, and use CPU instructions
07:26:10 <kmc> rotflcopter, sure, but CPU registers and instructions are not physical things
07:26:28 <kmc> they're another layer of abstraction, implemented by tons of hidden complexity
07:26:42 <kmc> it is very hard to take an assembly program and determine what the actual physical CPU parts are going to do at each point in time
07:26:58 <erus`> interpret it?
07:27:14 <jophish_> Yo yo yo!
07:27:43 <jophish_> I understand that lists in haskell are not doubly linked, out of interest, why is this?
07:28:38 <DRMacIver> jophish_: Doubly linked lists don't work very well as a purely functional data structure. With single linked ones it's cheap to take the tail and return it, with doubly linked lists you'd have to rebuild the whole structure
07:28:59 <frigga1> jophish_: I don't know if this is "the reason", but it's harder to construct pure doubly linked lists functionally.
07:29:00 <kmc> rotflcopter, your "CPU instructions" get decoded into microcode and then executed in a superscalar, out-of-order pipeline with speculative execution, branch prediction, register renaming, simultaneous multithreading, interrupts (some hidden from the OS, look up x86 SMM sometime)
07:29:20 <frigga1> jophish_: Singly linked lists lend themselves well to recursive formulations.
07:29:24 <kmc> rotflcopter, and your CPU cores, caches, and main memory are basically a distributed system implementing various complex protocols which are, again, totally hidden
07:29:38 <rotflcopter> kmc<< cool, do you know any other language closer to hardware than ASM ?
07:29:39 <kmc> so no ASM is not "close to the hardware"
07:29:51 <kmc> it's close to the contract provided by the hardware, not close to the implementation details of the hardware
07:29:55 <Ikarus> hehehe
07:29:56 <Ikarus> so true
07:30:03 <Ikarus> especially on x86
07:30:04 <kmc> rotflcopter, yes, design your own CPU in Verilog or VHDL or SystemC or Bluespec
07:30:10 <rotflcopter> :)
07:30:16 <kmc> burn it into a FPGA or drop a few million dollars to get it fabbed for real
07:30:19 <erus`> so the guys who said C is close to the machine and haskell is not are being silly?
07:30:26 <rotflcopter> ok well i have a project involving FPGA-s
07:30:30 <kmc> erus`, they're both pretty far; Haskell is a lot further
07:31:22 <kmc> it's just funny how much dickwaving there is about C and assembly being "close to the machine" and how very wrong it all is
07:31:48 <mysticc> preflex: list
07:31:49 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
07:31:50 <preflex>  ZCode: [zdec, zenc]
07:32:05 <mysticc> preflex: karma mysticc
07:32:06 <preflex>  mysticc has no karma
07:32:36 <rotflcopter> kmc<< should "closer" be defined in a functional way? :)
07:32:42 <kmc> dunno what that means
07:32:50 <mysticc> preflex: quote mysticc
07:32:50 <preflex>  no quotes found for mysticc
07:33:32 <hpaste> AtnNn pasted “Delay Errors Until Runtime” at http://hpaste.org/53864
07:33:33 <rotflcopter> create a function that gets the distance between hardware and programming language and plot onto a graph?
07:33:38 <erus`> 'dickwaving' lol
07:34:00 <rotflcopter> i'd guess it will be related to the time same transfer function takes.
07:35:12 <copumpkin> @ask mzero what do you think _is_ the best way to switch versions of GHC on Mac OS? frustratingly, my GHC bug got closed, despite not having any clear resolution, even if my initial suggestion for how to approach it might have been invalid. What benefit does keeping old versions around give?
07:35:13 <lambdabot> Consider it noted.
07:35:28 <troydm> can any1 exlain me why Nothing >> Just 3 results to Nothing
07:35:42 <kmc> yes
07:35:44 <troydm> x >> y = \_ -> y
07:35:48 <copumpkin> > Nothing `mplus` Just 3
07:35:49 <lambdabot>   Just 3
07:35:56 <kmc> x >> y  ≡   x >>= (\_ -> y)
07:35:58 <gwern> Baughn: not deliberately
07:36:02 <kmc> that's the definition of (>>)
07:36:05 <kmc> now what about (>>=)
07:36:16 <kmc> (>>=) is a type class method, so it's defined differently for each type
07:36:18 <kmc> @src Maybe (>>=)
07:36:18 <lambdabot> (Just x) >>= k      = k x
07:36:18 <lambdabot> Nothing  >>= _      = Nothing
07:36:19 <copumpkin> you can think of >> as an "and" on Maybe and `mplus` as an "or" :)
07:36:49 <copumpkin> well, not sure if you'd want to think of it that way
07:36:53 <copumpkin> but you _can_ :P
07:36:54 <Baughn> gwern: It leaves me wondering what exactly \bot is using. I've been unable to make both evaluation and @check work for my own; one is broken with 0.8, the other with 0.8.1.
07:37:10 <hpc> @version
07:37:10 <lambdabot> lambdabot 4.2.2.1
07:37:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
07:37:32 <Baughn> hpc: As in, what version of mueval is installed on the server. Not so easy to check.
07:37:48 <hpc> ah
07:38:23 <troydm> but still if Nothing >> Just 3 doesn't do any type conversions
07:38:30 <troydm> it should return Just 3 and not Nothing
07:38:36 <copumpkin> wat
07:38:37 <kmc> i don't see how that follows
07:38:43 <mux> neither do I
07:38:46 <kmc> Nothing >> Just 3  ≡  Nothing >>= (\_ -> Just 3)
07:38:51 <kmc> @src Maybe (>>=)
07:38:51 <lambdabot> (Just x) >>= k      = k x
07:38:51 <lambdabot> Nothing  >>= _      = Nothing
07:38:59 <kmc> the second line tells you
07:39:11 <troydm> lambdabot: ohhh
07:39:13 <troydm> lambdabot: thx
07:39:14 <copumpkin> @src (&&)
07:39:15 <lambdabot> True  && x = x
07:39:15 <lambdabot> False && _ = False
07:39:20 <copumpkin> @src Maybe (>>=)
07:39:20 <lambdabot> (Just x) >>= k      = k x
07:39:20 <lambdabot> Nothing  >>= _      = Nothing
07:39:39 <mux> > Nothing `mplus` Just 3
07:39:40 <lambdabot>   Just 3
07:39:47 <mux> mayeb that's what you wanted?
07:39:56 <copumpkin> @src (||)
07:39:57 <lambdabot> True  || _ =  True
07:39:57 <lambdabot> False || x =  x
07:39:59 <copumpkin> @src Maybe mplus
07:39:59 <lambdabot> Nothing `mplus` ys = ys
07:40:00 <lambdabot> xs      `mplus` ys = xs
07:40:07 <mysticc> @src mplus
07:40:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:40:08 <hpc> troydm: http://hpaste.org/53865
07:40:19 <mysticc> :t mplus
07:40:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
07:41:03 <troydm> hpc: i get it thx
07:47:47 <hpaste> aryslan pasted “convert to list of string” at http://hpaste.org/53866
07:49:25 <hpc> > words "aryslan: it helps if you actually ask your question, instead of waiting for someone to read the paste ;)"
07:49:26 <lambdabot>   ["aryslan:","it","helps","if","you","actually","ask","your","question,","in...
07:50:29 * albel727 lold
07:50:50 <aryslan> hpc thanks
07:51:22 <aryslan> "apply + ( ab d )"
07:51:49 <aryslan> how to write a function that take a string input and convert it to a list of String
07:52:11 <hpc> > words "apply + ( ab d )"
07:52:12 <lambdabot>   ["apply","+","(","ab","d",")"]
07:52:18 <hpc> :t words
07:52:19 <lambdabot> String -> [String]
07:52:38 <hpc> a more robust way to do it would be with lex
07:52:39 <hpc> :t lex
07:52:40 <lambdabot> String -> [(String, String)]
07:52:48 <hpc> :t scanl lex
07:52:48 <lambdabot>     Couldn't match expected type `b -> String'
07:52:48 <lambdabot>            against inferred type `[(String, String)]'
07:52:49 <lambdabot>     In the first argument of `scanl', namely `lex'
07:52:51 <hpc> :t scanl
07:52:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
07:53:27 <hpc> > lex "apply+(ab d)
07:53:27 <lambdabot>   <no location info>:
07:53:28 <lambdabot>      lexical error in string/character literal at end o...
07:53:30 <hpc> > lex "apply+(ab d)"
07:53:30 <lambdabot>   [("apply","+(ab d)")]
07:53:37 <ski> > replicateM 3 (StateT lex) `runStateT` "(foo)"
07:53:38 <lambdabot>   [(["(","foo",")"],"")]
07:54:30 <aryslan> thanks hpc
07:57:40 <quicksilver> > replicateM 3 (StateT lex) `runStateT` "[(\"foo\")]"
07:57:41 <lambdabot>   [(["[","(","\"foo\""],")]")]
07:58:17 <mysticc> @hoogle StateT
07:58:17 <lambdabot> Control.Monad.State.Lazy StateT :: (s -> m (a, s)) -> StateT s a
07:58:17 <lambdabot> Control.Monad.State.Strict StateT :: (s -> m (a, s)) -> StateT s a
07:58:17 <lambdabot> Control.Monad.Trans.State.Lazy StateT :: (s -> m (a, s)) -> StateT s m a
08:00:57 <mysticc> aryslan: What do you mean by String to list of String ?
08:01:52 <aryslan> mysticc like if the input string is "how are you"  the output is ["how", "are", "you"]
08:02:19 <mysticc> oh then words is what you need as told by hpc ..
08:02:53 * djanatyn is reading "Beautiful Concurrency" by SPJ
08:03:12 <djanatyn> I actually learned a *lot* about the IO type
08:03:20 <djanatyn> it confused me a lot before, but now it's nowhere near as intimidatingt
08:03:24 <kmc> cool!
08:03:38 <kmc> a good introduction to IO can be found at http://www.haskell.org/haskellwiki/Introduction_to_IO
08:09:35 <aryslan> thx mysticc
08:10:41 <djanatyn> anyone read "Tackling the Awkward Squad"?
08:10:57 <aryslan> if h == "apply" || h == "define" || h == "let" || h == "return" || h == "~" || h == "(" || h == ")" || h == "+"
08:11:02 <roconnor_> djanatyn: A while ago
08:11:03 <aryslan> what's wrong with this?
08:11:09 <aryslan> h is a string
08:11:34 <aryslan> h == "+" give error cause + is a character
08:11:45 <kmc> no '+' and "+" are different
08:11:50 <kmc> :t '+'
08:11:51 <lambdabot> Char
08:11:52 <kmc> :t "+"
08:11:53 <lambdabot> [Char]
08:12:58 <mysticc> > let x=10
08:12:58 <lambdabot>   not an expression: `let x=10'
08:13:05 <mysticc> > x=10
08:13:06 <lambdabot>   <no location info>: parse error on input `='
08:13:21 <bxc> > let x=10 in x+5
08:13:22 <kmc> > let x = 10 in x
08:13:22 <lambdabot>   15
08:13:23 <lambdabot>   10
08:13:29 <bxc> kmc, mine's bigger
08:13:48 <kmc> ono
08:13:56 <mysticc> bxc: Yeah 1.5 times of that of kmc :p
08:14:11 <bxc> mysticc: what's the numerical value of "x=10" ?
08:14:45 <mysticc> bxc: what ?
08:14:52 <poincare101> Hi everyone. I'm having some trouble with Haskell (I'm just getting started with it), can someone tell me why this code doesn't work: http://hpaste.org/53867 It gives me an error about the expected type not matching the return type on the addSet function.
08:15:01 <bxc> mysticc: that's why your first two tries didn't work - lambdabot is saying "what ?"
08:15:20 <bxc> mysticc: its trying to give you a result, but you didn't put in anything that would give a result
08:15:39 <mysticc> poincare101: x:xs in brackets make it (x:xs)
08:15:49 <poincare101> oh
08:15:58 <mysticc> bxc: I was expecting something like in ghci
08:16:09 <poincare101> mysticc: wait, where do you see (x:xs)?
08:16:23 <mysticc> poincare101: line 4
08:16:39 <poincare101> mysticc: you mean (GroupSet x:xs)?
08:16:41 <aryslan> kmc: lol, silly me thx, i was putting the input string as (h:t) and compare h to "+", h then is a char and therefore generate the error
08:16:44 * bxc imagines how many variable bindings there would be after a few years int his channel
08:17:00 <mysticc> poincare101: Yeas change it to  (GroupSet (x:xs))
08:17:14 <poincare101> mysticc: why so? (Sorry if being stupid)
08:17:41 <kmc> ah yeah
08:17:50 <mysticc> poincare101: Think of it as : having less precedence than function
08:17:58 <poincare101> mysticc: Ah, I see :) Thanks a lot
08:19:08 * mysticc I think lambdabot can handle that many bindings :p
08:20:00 * hackagebot mongoDB 1.1.1 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.1.1 (TonyHannan)
08:20:21 <augur> for anyone familiar with computational classes: can all computational classes be translated into a class constrained in memory or time?
08:21:28 <kmc> lambdabot has @let but they expire
08:22:04 <tijn> Who wrote lambdabot? Is he open source?
08:22:37 <kmc> she is, http://hackage.haskell.org/package/lambdabot
08:22:47 <mysticc> @hoogle lambdabot
08:22:47 <lambdabot> package lambdabot
08:22:48 <lambdabot> package lambdabot-utils
08:22:53 <tijn> very cool!
08:23:03 <mysticc> kmc: Oh she ... :p
08:24:13 <tijn> I see: definitely a she :-)
08:26:01 <erus`> how do i add more than 1 thing to Build-depends?
08:26:08 <erus`> i tried comma seperated
08:26:12 <erus`> it doesnt work
08:26:13 <Philonous> Apropos she, is there an eta for 7.4?
08:26:41 <Saizan> erus`: it should
08:27:03 <Saizan> you can look at .cabal files on hackage for reference
08:29:38 <min> augur, no. consider: "for every computable function f, there exists a function g such that g(n) gives the time complexity of the turing machine computing f(n)."
08:30:02 <min> * computing f on input n
08:30:14 <augur> minsa: what about for most classes that people are interested in?
08:30:20 <hpaste> erus` pasted “cabal file” at http://hpaste.org/53869
08:30:30 <erus`> thats like the snap one
08:30:44 <augur> er, min*
08:31:14 <Saizan> erus`: Graphics.Rendering.OpenGL is a module, not a package
08:31:20 <augur> min: i mean, i know that the chomsky hierarchy can be described by automata bound in space in a certain way
08:31:38 <erus`> ah i need hopengl?
08:31:38 <augur> but are there important subclasses that are also bounded similarly?
08:31:48 <Saizan> erus`: yeah, i guess
08:31:53 <augur> or important subclasses that cant be bounded similarly?
08:32:04 <aryslan> how do I call a helper function to work on a list that is return by another function? such as
08:32:22 <jhance> aryslan: Composition?
08:32:43 <aryslan> parseProg str = convertToTokenlist (words str)
08:33:09 <jhance> aryslan: Better written as parseProg = convertToTokenList . words
08:33:32 <mysticc> aryslan: prefer using $ or pointfree is even better
08:33:37 <aryslan> so convertToTokenlist take the string list str and convert it to token list now how do i call another helper function to work with that list??
08:33:56 <mysticc> aryslan: Just compose it ..
08:34:04 <aryslan> compose?
08:34:24 <mysticc> parseProg = newFun . convertToTokenList . words
08:34:51 <aryslan> oh
08:35:30 <Saizan> which is the same as "parseProg str = newFun (convertToTokenList (words str))" if that wasn't clear
08:35:43 <mysticc> aryslan: Remember that types should properly match during composition
08:36:45 <aryslan> ok thx guy
08:36:50 <mysticc> parseProg str = newFun $ convertToTokenList $ words str ..
08:37:16 <mysticc> aryslan: Avoid using bracket instead use $ ^^
08:37:33 <ian_mi> Should I be concerned if I'm shocked when my programs work?
08:38:00 * mysticc is shocked 
08:38:15 <ski> s/work/work on first succesful compile/ ?
08:38:18 <kmc> erus`, the package is named OpenGL.  i don't think anyone's called it "hopengl" in forever
08:38:33 <erus`> yeah i had to look it up :)
08:38:38 <erus`> its working with haddock now
08:38:44 <erus`> awesome fun times
08:39:09 <min> augur, listing examples probably isn't helpful. but take a look here <http://en.wikipedia.org/wiki/Complexity_classes> if you want a list.
08:39:19 <tijn> ian_mi, http://www.haskell.org/haskellwiki/Why_Haskell_just_works
08:40:54 <Baughn> Can I somehow run ghci with -O2?
08:40:58 <Baughn> -fobject-code is great and all, but..
08:41:00 <parcs> no
08:41:08 <Baughn> (..but my program stack overflows without optimization)
08:41:47 <parcs> increase the stack size
08:41:54 <parcs> if thats possible in ghci
08:41:54 <dafis> Baughn: compile your code with optimisations and load that in ghci
08:42:06 <Baughn> parcs: I can't increase it that much
08:42:10 <augur> min: sure but i mean, that doesnt say whether or not the classes are space/time bound
08:42:16 <Baughn> parcs: As in, several gigabytes
08:42:34 <roconnor> Baughn: if you compile your code with -O2 and then load it in ghci, it will used the optimized version
08:42:58 <Baughn> Yes. I'd like to have :r work, but I suppose that /is/ an option.
08:43:21 <augur> min: also, im not sure, but are any complexity classes defined solely by space/time bounds, or do they also require structural differences
08:43:22 <augur> ?
08:45:24 <Baughn> augur: Space/time bounds.
08:45:34 <Baughn> augur: Not sure what you mean by structural differences..
08:46:22 <augur> Baughn: structural as in differences in the state space structure, or whatever. or like, whether its a tape machine or a stack machine or ...
08:46:33 <Baughn> augur: Yes, not relevan.t
08:47:12 <augur> Baughn: because i could imagine that just taking turing machines and saying "with linear space bounds" or whatever wouldnt necessarily give you a complexity class that is describable in other ways
08:48:20 <Baughn> augur: Certainly, translating from one structure to another will often change the complexity class
08:48:25 <geheimdienst> the code "#{peek XKeyEvent,keycode} p" by some witchcraft gets turned into "(\hsc_ptr -> peekByteOff hsc_ptr 52) p". does anyone know if that works on big-endian like a ppc? on a BE system, i'd expect the 52 to be 49 or something
08:48:39 <Baughn> augur: But that's changing the class. Knowing the class still tells you everything about how it runs on the architecture it was designed for.
08:48:50 <Baughn> augur: ..you know, in the limit. :P
08:49:00 <aryslan> how do you write a function that take a Token list and if that llist is not empty return the item specify by an index of that list?
08:49:07 <augur> Baughn: sure. im just curious about the shape of these classes, how they relate to space/time bounds vs. structure
08:49:36 <gtirloni> is it correct to read that "unboxed" are thunks that were forced to be evaluated so the parameter is strict?
08:50:02 <kmc> geheimdienst, that's hsc2hs right?
08:50:11 <min> i suppose the canonical example is the complexity classes dtime and ntime, which are described "structurally" in terms of deterministic and nondeterministic turing machines.
08:50:36 <kmc> geheimdienst, hsc2hs turns your .hsc file into a .c file which, when compiled and executed, outputs the .hs file that is actually used in the library
08:50:37 <geheimdienst> kmc: probably yes. it's an .hsc file. how do i find out?
08:50:40 <augur> minsa: hmm. in what way?
08:50:43 <Baughn> gtirloni: No, unboxed are types that were never thunks
08:50:59 <kmc> geheimdienst, that C program will invoke sizeof, offsetof, etc.
08:51:08 <Baughn> gtirloni: A boxed type can be a thunk /or/ an evaluated value, and needs an extra bit (or more likely a word..) to tell which
08:51:25 <Baughn> gtirloni: A boxed type is just, say, a raw machine int. It cannot ever be anything else.
08:51:25 <kmc> geheimdienst, so as long as you're running the code on the machine where hsc2hs was run, you should be fine
08:51:29 <Baughn> gtirloni: *unboxed
08:51:50 <gtirloni> Baughn: crystal clear now. thanks!
08:53:15 <geheimdienst> kmc: thanks ...
08:54:14 <jhance> gtirloni: Couldn't it be any newtype of an unboxed type
08:54:22 <kmc> geheimdienst, yeah, .hsc extension means it's almost certainly built with hsc2hs
08:54:43 <copumpkin> jhance: that's not allowed, as far as I know
08:54:44 <kmc> geheimdienst, Cabal will invoke hsc2hs by default if you tell it you want to build module Foo.Bar and it finds a file Foo/Bar.hsc
08:55:10 <jhance> copumpkin: Why not? At runtime there is no difference between the type and the newtype...
08:55:14 <Baughn> copumpkin: Really? Why?
08:55:15 <Cale> (from the GHC user guide) You cannot define a newtype whose representation type (the argument type of the data constructor) is an unboxed type. Thus, this is illegal:  newtype A = MkA Int#
08:55:17 <kmc> you can't newtype an unboxked type
08:55:31 <jhance> Aw that's sad
08:55:37 <copumpkin> jhance: it makes sense, and why would you want to?
08:55:44 <Baughn> It's not completely surprising, but what's the actual thought behind that?
08:55:52 <Baughn> Well, to define type-classes on it. :P
08:55:53 <kmc> just that algebraic types are always boxed
08:55:54 <copumpkin> Baughn: homogeneous representation of values
08:55:57 <duri_> hi guys, could you please help me with eta reduction of (\ x y z -> y (z x))? I successfully managed to remove z argument and ended up with (\ x y -> flip (y.) x) but I have no idea what to do next
08:56:08 <kmc> there would still be utility to newtypes for unboxed types
08:56:09 <ski> `newtype's shouldn't need to be boxed
08:56:10 <geheimdienst> kmc: right. i haven't much dealt with that kind of thing. isn't there some alternative tool instead of hsc2hs?
08:56:14 <Cale> Probably to make it hard to confuse users with unboxed types that don't have pointy-looking names
08:56:23 <kmc> but they wouldn't let you magically use them as boxed types
08:56:28 <copumpkin> the point is that newtype uses the same representation as the underlying type
08:56:31 <kmc> they would just prevent you confusing one use of Int# with another
08:56:34 <kmc> geheimdienst, there are several
08:56:39 <ski> Cale : well, we have kinds to tell the difference :)
08:56:58 <copumpkin> ski: so you'd have newtype take on the kind of the underlying type?
08:57:01 <copumpkin> I'd be fine with that
08:57:04 <ski> yes
08:57:13 <ski> at least for `*' and `#'
08:57:13 <aryslan> i got an error when i do this : getNextToken tlist = if (tlist !null) then (head tlist)                  Syntax error in expression (unexpected `}'
08:57:30 <kmc> i don't think (tlist !null) means what you think it means
08:57:32 <copumpkin> ski: what would be the benefit? low-level abstraction?
08:57:43 <ski> copumpkin : and type classes
08:57:46 <kmc> aryslan, also using 'null' and 'head' on a list is a big warning sign
08:57:52 <kmc> you should be using pattern matching instea'd
08:58:00 <rwbarton> where is the 'else'
08:58:11 <copumpkin> ski: why would typeclasses work if they don't work on current primitive types?
08:58:24 <aryslan> how should i write it?
08:58:29 <kmc> using pattern matching
08:58:32 <ski> copumpkin : also, i think it could be nice to be able to define basically an unboxed tuple type, but with it's own name and constructor
08:58:38 <aryslan> like?
08:58:40 <kmc> read a Haskell tutorial
08:59:01 <Cale> getNextToken [] = ...
08:59:06 <Cale> getNextToken (x:xs) = ...
08:59:15 <copumpkin> ski: so it would only work on primitive/unboxable types, but would be polymorphic on them?
08:59:27 <ski> copumpkin : "it" being ?
08:59:33 <copumpkin> your magic unboxed tuple type
09:00:17 <ski> copumpkin : i mean something like `data Foo# :: (#) = MkFoo# Int# Int#'
09:00:27 <copumpkin> oh
09:00:31 <kmc> data# :)
09:00:43 <copumpkin> ski: what's the benefit of being in # there?
09:00:50 <copumpkin> oh, completely unlifted
09:01:38 <copumpkin> so it'd need to behave like two separate values in most contexts
09:01:59 <ski> (i suppose one could even allow multiple branches, if it allocated a register to keep track of which kind of data is there)
09:02:02 <ski> yes
09:02:19 <copumpkin> so we could just make it so that (#,#) and friends worked in the domain as well as the codomain
09:02:26 <copumpkin> and make the kind hierarchy cleaner
09:02:41 <copumpkin> :k (->)
09:02:42 <lambdabot> ?? -> ? -> *
09:02:47 <ski> yes, i don't really see why argument types can't be `(#)'
09:02:53 <kmc> isn't it even worse in GHC 7.4 :)
09:03:08 <copumpkin> probably cause it was a pain to take care of breaking them up and treating them like multiple values
09:03:19 <copumpkin> but it does seem strange to construct a whole kind around an implementation detail :)
09:03:24 <copumpkin> ski: GHC FEATURE REQUEST
09:03:27 <ski> well, they needed it for results anycase ..
09:03:38 <rotflcopter> roconnor<< http://www.muppetlabs.com/~breadbox/software/tiny/hello.asm.txt :)
09:04:11 <ski> i'm not sure, if we remove the (imo) arbitrary restriction, there is any point in separating `#' and `(#)'
09:04:23 <copumpkin> no
09:04:27 <ski> maybe unboxed arrays really want `#' rather than `(#)'
09:04:45 <copumpkin> unboxed arrays aren't even aware of their contents
09:04:57 <copumpkin> they just have accessor primitive functions on them
09:05:05 * hackagebot atom 1.0.10 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.10 (LeePike)
09:05:53 <ski> yeah, but i mean if we had `UArray ix (# Int# , Int# #)', would that then amount to two separate arrays ?
09:06:08 <copumpkin> UArray clearly needs to be a data family :P
09:06:16 <ski> *nod*
09:06:28 <copumpkin> or it could just store the elements adjacent to one another
09:06:37 <ski> yea
09:07:19 <copumpkin> which of those you want kind of depends on what you're doing
09:07:37 <ski> but if `UArray ix (# a , b #)' is supposed to be determined abstractly out of `UArray ix a' and `UArray ix b', that becomes more difficult, i think
09:07:47 <copumpkin> yeah
09:08:22 <ski> (yeah, i'm assuming here the invariant that each of the two arrays have the same bounds &c.)
09:08:57 <ptrf> ok, i might be an idiot, but how do i go from IO String to just String?
09:09:09 <ski> @wiki Introduction_to_IO
09:09:09 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
09:09:10 <jhance> ptrf: unsafePerformIO
09:09:13 <rwbarton> ...
09:09:21 <jhance> ptrf: But obviously that's unsafe, so you don't do it ;)
09:09:23 <ptrf> thank you
09:09:24 <copumpkin> @quote monochrom IO
09:09:24 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
09:09:26 <copumpkin> @quote monochrom IO
09:09:27 <lambdabot> monochrom says: Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more
09:09:27 <lambdabot> godawful construct?
09:09:31 <copumpkin> dammit monochrom
09:09:36 <geheimdienst> jhance: please stop confusing beginners
09:09:41 <mux> yes please
09:09:42 <ski> ptrf : see that wiki limk ^
09:09:54 <geheimdienst> ptrf: ignore jhance, he's joking
09:09:58 <mux> ptrf: see those links ski gave you; the short answer is "you don't"
09:10:06 * hackagebot copilot-c99 0.2 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2 (LeePike)
09:10:13 <aryslan> how come when I do this : getNextToken [x:xs] = x , it give me the error *** Type           : [Token] -> [a]  *** Type           : [Token] -> [a]
09:10:19 <ptrf> mux: thanks, geheimdienst: yeah i know
09:10:23 <copumpkin> ptrf: the basic idea is that instead of taking something out of IO so you can work on it, you put your work into IO so it can work on it in there
09:10:30 <ben> aryslan: maybe you meant (x:xs)
09:10:33 <Cale> ptrf: Let me know if you're still confused after reading that intro. I wrote it :)
09:10:35 <ptrf> i think the issue here is at large that I don't have any experience writing haskell
09:11:04 <mux> ptrf: it's quite normal to ask yourself such a question when learning haskell btw, definitely not a stupid question
09:11:06 <kmc> there's no String hiding inside the IO String.  it represents an IO action which has not yet occurred
09:11:06 <ptrf> Cale: it's probably marvellous. searching for IO on the wiki doesn't dig it up though
09:11:09 <jhance> Yeah you basically use the do notation so do { s <- ioStr; return $ s ++ "stuff" }
09:11:15 <aryslan> same error
09:11:17 <ski> ptrf : if you have seen `do'-notation, then in that you write `myString <- myIOString', and then use the `myString'
09:11:19 <kmc> you could perform that IO action more than once and get different Strings each time
09:11:52 <Cale> ptrf: The basic idea is that values of type (IO t) are thought of as little programs which if you were to run them, may have input and output effects (or really do anything your computer can do), in order to produce a result of type t
09:12:19 <ptrf> Cale: thanks :) but i kind of know.
09:12:28 <ptrf> https://gist.github.com/0016a85536a6255189dc <- i did this within the last couple of days for an exam
09:12:42 <ptrf> basically it takes this: http://stuff.anarcho.dk/sunseed2.logo and turns it into https://secure.0x90.dk/~ptrf/sunflower.svg
09:12:47 <Cale> ptrf: So, in a do block, if you have x :: IO t, and you write v <- x, then v :: t
09:13:01 <ski> aryslan : `x:xs' is a list starting with `x', continuing with the elements of the list `xs'
09:13:06 <Cale> and the do block as a whole will have type IO s, for some other type s (whatever the result type of the last action in the block is)
09:13:17 <ptrf> Cale: yeah, but when I return v, it's still captured in the monad. so unsafePerformIO is what i was looking for
09:13:19 <ski> aryslan : `[x:xs]' otoh is a list with a *single* element, namely the list just above
09:13:28 <Cale> ptrf: It probably isn't...
09:13:44 <jhance> ptrf: Doubtful unless there is something inheritantly unsafe like FFI going on
09:13:54 <Cale> ptrf: unsafePerformIO is something you use as a last resort when your only other option is modifying GHC
09:13:55 <ptrf> it's even more dirty
09:14:04 <rotflcopter> hey Cale ;>
09:14:06 <ptrf> it's me toying around in ghci trying to run some quick and dirty programs
09:14:10 <ski> ptrf : you can't do I/O in an operation without `IO' ending up in the result type (either directly, or hidden inside another type) -- that's the point of `IO'
09:14:15 <PiRSquared17> @type print
09:14:16 <lambdabot> forall a. (Show a) => a -> IO ()
09:14:23 <Cale> ptrf: In that case, you can run an IO action at the ghci prompt with v <- x too
09:14:26 <aryslan> ski i want to write a function that return the first element or whatever index element specify by the function if the list is not empty
09:14:28 <PiRSquared17> @type show
09:14:29 <lambdabot> forall a. (Show a) => a -> String
09:14:41 <jhance> if you have an ioString in ghci binded just type "ioString"
09:14:43 <Cale> (or just x)
09:14:43 <ptrf> Cale: hmm, i surrender. I might as well try to do that. it just feels akward
09:14:44 <jhance> and it will show the result
09:15:05 <PiRSquared17> @type iterate
09:15:06 * hackagebot copilot 2.0.1 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0.1 (LeePike)
09:15:06 <lambdabot> forall a. (a -> a) -> a -> [a]
09:15:09 <Cale> ptrf: or just write the name of the action
09:15:17 <jhance> geheimdienst: He's not a beginner... Look at his code, he's using Parsec
09:15:38 <ptrf> what I mean is: everyone can look at the Maybe monad and say "oh, monads is nice, this is easy", but it doesn't really capture the notion fully :)
09:15:51 <ptrf> so I'm not really at easy with monads yet
09:15:53 <geheimdienst> jhance: "how do i get the String out of IO String" is clearly a beginner question as far as i can tell
09:15:56 <ptrf> i guess I just have to dive into it
09:15:57 <ski> ptrf : the point is to separate the code that might do I/O from the code that doesn't do I/O. the code that might do I/O needs to be carefully sequenced, the other code doesn't
09:16:19 <Cale> ptrf: Are you familiar with the OO programming concept of model-view-controller?
09:16:44 <ptrf> i hate it..
09:16:58 <ski> haha
09:17:02 <Cale> ptrf: A good way to look at it is that the separation between code which is pure and code which may involve some IO is similar to the separation between the model and the view/controller.
09:17:06 <ptrf> i'm used to functors in sml
09:17:11 <ptrf> that is something I can grasp
09:17:15 <ptrf> this is a whole new level
09:17:16 <ski> aryslan : maybe you could paste the whole function you're trying to write ?
09:17:21 <Cale> hmm
09:18:05 <ptrf> i still haven't grasped it all yet, and naturally i'm more prone to try and bang around as i do when i code ocaml or sml or erlang for that matter
09:18:38 <aryslan> getNextToken :: [Token] -> Token   getNextToken [] = []  getNextToken (x:xs) = x
09:18:43 <Cale> ptrf: Well, don't get too hung up on the fact that it's a monad. There's an IO library, and it just happens to define some combinators which look vaguely like combinators that show up in other libraries. We've captured a pattern there and given it a name (monad), but you don't have to care too much about what that pattern means in general to get work done.
09:18:59 <PiRSquared17> > sum (map (\x -> 1/2^x) [0..1000])
09:19:00 <lambdabot>   2.0
09:19:17 <ski> aryslan : how is `Token' defined ?
09:19:44 <alistra> > sum (map (\x -> 1/2^x) [0..500])
09:19:44 <PiRSquared17> > sum (map (\x -> 1/2^x) [0..100])
09:19:45 <lambdabot>   2.0
09:19:45 <lambdabot>   2.0
09:19:51 <alistra> > sum (map (\x -> 1/2^x) [0..50])
09:19:51 <ptrf> geheimdienst: it is a beginner question, definitely. but mostly because I haven't done anything that directly require IO yet
09:19:51 <lambdabot>   1.9999999999999991
09:19:54 <Cale> Basically, the main point about it being a monad is that a bunch of control-structure-like operations are already defined for free without needing to be separately defined for IO and parsers and lists, and so on
09:19:58 <monochrom> sml functor and haskell functor are unrelated
09:20:00 <alistra> > sum (map (\x -> 1/2^x) [0..75])
09:20:01 <lambdabot>   2.0
09:20:02 <aryslan> data Token = Token { tokentype :: String  spelling :: String } deriving (Eq)
09:20:03 <ski> ptrf : if you've used O'Caml, then you might know that the LWT thread library basically uses a monad as well ..
09:20:04 <PiRSquared17> ?
09:20:07 <alistra> > sum (map (\x -> 1/2^x) [0..64])
09:20:07 <lambdabot>   2.0
09:20:11 <ski> aryslan : ok, so `getNextToken [] = []' is wrong because the result type `Token' is not a list type
09:20:13 <ptrf> geheimdienst: also, if you look at my runProg function, that is one ugle mofo
09:20:34 <alistra> > sum (map (\x -> 1/2^x) [0..57])
09:20:34 <lambdabot>   2.0
09:20:36 <monochrom> in fact, how about: c++ functor and sml functor and haskell functor are pairwise unrelated
09:20:38 <PiRSquared17> > sum (map (\x -> 1/x^2) [0..1000])
09:20:39 <lambdabot>   Infinity
09:20:43 <Cale> (all the stuff in Control.Monad will work as well for IO as for parsers and lists)
09:20:54 <alistra> > sum (map (\x -> 1/2^x) [0..54])
09:20:55 <ptrf> ski: oh well, i guess I'm just familiar with ocaml then :)
09:20:55 <lambdabot>   2.0
09:21:05 <ski> aryslan : do you care what happens if `getNextToken' is called on an empty list ? otherwise you could have it generate an error in that case
09:21:10 <alistra> > sum (map (\x -> 1/2^x) [0..52])
09:21:11 <lambdabot>   1.9999999999999998
09:21:12 <PiRSquared17> > sum (map (\x -> 1/(2^x)) [0..1000])
09:21:13 <lambdabot>   2.0
09:21:14 <mysticc> aryslan: You cant do that .. either use Maybe or prepare for your function to fail on empty list like head do
09:21:14 <alistra> > sum (map (\x -> 1/2^x) [0..53])
09:21:15 <lambdabot>   2.0
09:21:15 <ptrf> Cale: ski: geheimdienst jhance thanks for your help though :)
09:21:42 <Cale> ptrf: No problem, let us know if you get stuck or need help cleaning things up.
09:21:45 <aryslan> it should generate an error
09:21:47 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [0..1000])
09:21:48 <lambdabot>   Infinity
09:22:01 <ptrf> Cale: I'll take a look on the Introduction to IO page later and give some feedback if I have any
09:22:08 <ski> monochrom : hehe, <http://www.catonmat.net/blog/on-functors/>
09:22:09 <mysticc> aryslan: Then just remove the code for empty list in your code ...
09:22:18 <Cale> ptrf: another one you might check out is: http://www.haskell.org/haskellwiki/Monads_as_computation
09:22:44 <monochrom> oh, prolog, I should add that next time
09:22:48 <Cale> ptrf: which gives a bit of the general philosophy of why we bother talking about monads, if that's what you're interested in.
09:22:51 <aryslan> what if I want to return an empty list if the list is empty?
09:22:59 <ski> aryslan : ok, so e.g. `getNextToken [] = error "getNextToken : empty list"' could be ok
09:23:01 <ptrf> Cale: right, thanks!
09:23:02 <jhance> aryslan: f [] = []
09:23:03 <PiRSquared17> > sum (take 1000 (iterate (\n -> n^2-n/2) 9))
09:23:03 <lambdabot>   NaN
09:23:25 <monochrom> oh joy, prolog offers two functors! prolog wins.
09:23:34 <geheimdienst> ptrf: sorry if i mistakenly called you a beginner. i only saw that somebody comes in and asks how to get the String out of IO String, and that somebody else casually replies "unsafePerformIO". my point was that this behavior is lunacy. my point was not if you are a beginner or not, or exactly how much experience you have. that is all besides the point
09:23:34 <Cale> aryslan: Given your type signature, you're not allowed to return an empty list
09:23:40 <monochrom> so much for self-documenting names!
09:23:41 <ski> monochrom : two ?
09:23:54 <Cale> aryslan: That is, if you're still talking about the function [Token] -> Token
09:23:55 <monochrom> "Functors in Prolog are the simplest of all. They refer to two things."
09:24:01 <Cale> (the result here isn't a list at all)
09:24:04 * ski can only recall one, on the top of head
09:24:44 <monochrom> well, I guess the two things are related
09:24:47 <aryslan> actually it is more like if the list is not empty return the next element in the list, if it is empty do nothing...
09:25:24 <rwbarton> "do"?
09:25:24 <ski> aryslan : ok, maybe you should show (or explain) the code that is supposed to call this function, then
09:25:26 <mysticc> aryslan: What is do nothing ...
09:25:28 <Sgeo|web> aryslan: There is no way for your type to do nothing
09:25:36 <Sgeo|web> It _has_ to return a value
09:25:37 <ski> rwbarton ?
09:25:43 <aryslan> parseProg str = show getNextToken $ convertToTokenList $ words str
09:25:43 <Sgeo|web> You can change the type signature to fix that
09:25:55 <mysticc> aryslan: what do you expect here x = yourFunc [] ?
09:25:56 <rwbarton> functions don't "do"
09:26:44 * monochrom is tempted to suggest dependent types to aryslan
09:26:54 <ski> aryslan : so `convertToTokenList' gets you a list of tokens -- what do you wan to do with the tokens ?
09:26:55 <Cale> The problem with asking how to get the String out of IO String is that it's kind of like asking how to get the file out of wget.
09:26:59 <ski> aryslan : show all of them ?
09:27:10 <aryslan> actually no....
09:27:16 <geheimdienst> cale: "cat -v $(where wget)"
09:27:18 <mysticc> monochrom: Dont hold your tamptations :p
09:27:18 <geheimdienst> :)
09:27:21 <ski> Cale : or the cake out of the recipe
09:27:23 <aryslan> i just do show to make sure i have the result correctly
09:27:24 <monochrom> \∩/
09:27:30 <Cale> Indeed
09:27:41 <aryslan> i need to take the list... go through the list match it up to the type and do parsing....
09:28:11 <aryslan> the program i am trying to write is a recursive descent parsing.... of an input string....
09:28:53 <ski> aryslan : well, if your program itself doesn't need to `show' the tokens, then you could just use `show' when you test things in your interactor, so omit the `show getNextToken $ ' part of your code
09:28:54 <monochrom> aryslan: Agda allows you to write this function and its type signature: if the input list is non-empty, return the first element; if the input list is empty, return () (the closest you can get to "do nothing"). Haskell doesn't allow it, but Agda does.
09:29:35 <ski> monochrom : yeah :) the question is whether doing this would be of much help to aryslan
09:29:52 * monochrom 's latest strategy for XY problems is to help turn them into XYZABCDEFG... problems
09:30:04 <ski> (maybe the "help" would be to not have to disentangle one's confused thoughts)
09:30:33 <Cale> The question makes it sound like there's a String in there to begin with, even before the thing has run. It's on the one hand a sensible thing to ask, because it's possible to get hold of a String (in a local context) by using an IO String appropriately, but the wording seems to betray a subtle misunderstanding of what an IO String is -- specifically that you'd have to run it to allow it to produce a String.
09:31:01 <aryslan> is there a really good example of recurse descent parsing that take a string and parse it?
09:31:21 <brisingr> I want to write a "paper" elaborating the usability of Haskell in space settlement designs, any recommended reading?
09:31:30 <ski> aryslan : i suppose one could write a simplistic sexp parser
09:32:11 <aryslan> to be honest I am totally new to Haskell and the haskell syntax is just killing me....
09:32:28 <ski> aryslan : what are you trying to do ?
09:32:37 <aryslan> I wrote the recursive descent parsing in java and try to implement the same logic to haskell
09:32:38 <ski> any specific problem you'd like to try to solve ?
09:32:46 <ski> or just learn basic Haskell for the moment ?
09:32:48 <monochrom> don't
09:32:49 <mysticc> aryslan: Hope you can survive that till you are used to it :p
09:32:54 <aryslan> yes..
09:33:08 <monochrom> I mean: don't translate the same logic to haskell
09:33:27 <monochrom> especially all those blasted "do nothing" steps
09:33:38 <ski> aryslan : one common way to write recursive descent parsers in Haskell is to use a parser combinator library, like e.g. Parsec (maybe you're already trying to do that, i'm not sure)
09:34:10 <mysticc> If you just want to parse then use Parsec ..
09:34:11 <hpaste> aryslan pasted “recursive program” at http://hpaste.org/53872
09:34:15 <jhance> learning parsec doesn't help much to learn haskell :|
09:34:17 <ski> if you really want to, you can implement the basics of the recursive descent parsing by hand, though
09:35:01 <aryslan> can ur guys take a look at the hpaste and see the pseudocode of the program?
09:35:06 <Cale> aryslan: you might enjoy http://www.cs.nott.ac.uk/~gmh/monparsing.pdf
09:36:12 <Cale> aryslan: This sort of thing we usually do with a library such as Parsec
09:36:58 <aryslan> well how do i use parsec?
09:37:20 <aryslan> ski how do you do it by hand?
09:37:44 <Cale> aryslan: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- there's a pretty good tutorial here, though the module names are a little out of date on it unfortunately.
09:38:17 <Cale> http://hackage.haskell.org/package/parsec -- this is the documentation for the latest version of the library
09:38:46 <Cale> You'll want to import Text.Parsec and Text.Parsec.String, most likely
09:39:07 <ski> e.g. `FunctionDefinition -> define Signature Program' could be transliterated into something like :
09:39:22 <ski>   data FunctionDefinition = FD Signature Program
09:39:37 <ski>   parseFunctionDefinition :: Parser FunctionDefinition
09:39:43 <ski>   parseFunctionDefinition = do
09:39:49 <ski>     symbol "define"
09:39:57 <ski>     sig <- parseSignature
09:39:59 <Sgeo|web> Cale: I feel weird about that thing calling <- an operator
09:40:02 <ski>     prg <- parseProgram
09:40:05 <mysticc> ski: better to hpaste
09:40:08 <ski>     return (FD sig prg)
09:40:09 <Cale> Sgeo|web: sorry, what?
09:40:18 <monochrom> "<-" is definitely not an operator
09:40:24 <Sgeo|web> "The (<-) operator will be used to bind the intermediate values returned by the parsers."
09:40:28 <Cale> Yeah, <- isn't an operator
09:40:45 <monochrom> don't feel weird. feel betrayed.
09:40:49 <ski> `<-' might be called a *syntactic* operator (and `::' as well)
09:41:21 <ski> (also e.g. `@', which is perhaps a more convincing example)
09:41:37 <Cale> Yeah, I suppose you have the problem that if you're not going to call it an operator, what are you going to call it here?
09:41:53 <mysticc> Cale: what sky said
09:41:58 <mysticc> *ski
09:42:00 <Cale> yeah
09:42:17 <ski> aryslan : so, each of the three parts in `define Signature Program' correspond directly to a line in the `do'-block, with the final `return' line packaging up the parsed data into a parsetree
09:42:32 <monochrom> "<-", "::", and "@" are reserved words
09:43:01 <ski> (in the same sense, function application is a syntactic operator)
09:43:05 <aryslan> wow this is a bit confusing....
09:43:34 <simon> aryslan, starting out with parser combinators is perhaps not the easiest.
09:43:56 <aryslan> this is a prog i have to write for a class, and I have to turn it in by 12 noon today, been struggle with it for the past week, just couldn't get it write...
09:44:10 <aryslan> right
09:44:14 <ski> aryslan : the idea with parser combinators is that the code will look more or less the same as the BNF, just with some more annotations for constructing parse-trees
09:44:18 <monochrom> you should have come a week ago
09:44:34 <aryslan> just find out about your guys like 2 days ago....
09:44:47 <simon> aryslan, does it have to be in haskell?
09:44:49 <mysticc> > id id
09:44:50 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:44:50 <lambdabot>    arising from a use of `...
09:44:52 <aryslan> yes
09:44:57 <aryslan> i already wrote it in java
09:44:57 <mysticc> :t id id
09:44:58 <lambdabot> forall a. a -> a
09:45:04 <monochrom> but then I can't believe the first assignment is already parsing
09:45:08 <aryslan> i am better verse in java then haskell
09:45:19 <aryslan> haskell is a new lang i am learning
09:45:31 <Sgeo|web> @hoogle (i -> a) -> [a] -> [a]
09:45:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:45:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
09:45:33 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
09:45:39 <monochrom> in any case translating from java to haskell takes three times more effort than writing native haskell
09:45:46 <poincare101> Hi everyone. I'm some trouble with datatypes in Haskell. Can I do this: data Group = Group [a] (a -> a) where a can be set later as a type?
09:45:46 <Sgeo|web> @hoogle (i -> a -> a) -> [a] -> [a]
09:45:46 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
09:45:47 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
09:45:47 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
09:45:59 <aryslan> thx for the info monochrom :(
09:46:15 <mysticc> poincare101: Nope
09:46:22 <monochrom> don't underestimate the power of paradigm shifts
09:46:28 <mysticc> poincare101: Oh sorry ..
09:46:28 <poincare101> mysticc: what should I be doing then?
09:46:28 <wavewave> hi.
09:46:35 <aryslan> i just can't tie the concept of function programming in relation to object programming
09:46:37 <Sgeo|web> poincare101: Do you want data Group a = Group [a] (a -> a)
09:46:40 <ski> aryslan : anyway, i would say it probably takes less time to write the parser in Parsec, than writing your own recursive-descent parsing
09:46:40 <simon> poincare101, data Group a = Group ...
09:46:42 <poincare101> aryslan: not related
09:46:50 <Sgeo|web> Then Group Int will be a type where a is Int
09:46:56 <poincare101> Sgeo|web: Ah, there we go. Thanks a lot.
09:47:09 <Sgeo|web> yw
09:47:11 <wavewave> is it not possible to include a C header file with some c function taking function as a parameter in hsc file?
09:47:15 <monochrom> set up a virtual machine in your mind and learn haskell there. clean slate.
09:47:30 <poincare101> Sgeo|web: however, how would I declare a Group then? Like: a = Group Int [1,2,3,4] f ?
09:47:35 <monochrom> (yes, I did exactly that when I learned haskell)
09:47:47 <aryslan> *sigh
09:47:53 <monochrom> (actually I did that to learn everything)
09:47:54 <ski> monochrom : need to learn mother tounge in that virtual machine first
09:47:57 <Sgeo|web> poincare101: Don't mention Int, let the compiler figure it out
09:48:02 <simon> poincare101, no, like... Group [1,2,3,4] (someF)
09:48:07 <poincare101> Sgeo|web: okay.
09:48:09 <aryslan> I just might have to give up this assignment .. and catch up later...
09:48:10 <poincare101> simon: thanks.
09:48:26 <monochrom> oh, sure, use English and math to bootstrap the virtual machine. just don't put java or c++ or prolog there.
09:49:01 <mysticc> poincare101: you are confusing constructor with type
09:49:05 <scshunt> 1/win 12
09:49:10 <simon> most implementations of English are buggy and non-standardized.
09:49:28 <Sgeo|web> simon: To be fair, English is overly-complex
09:50:10 * mysticc says haskell should be the standard language for all .
09:50:16 <ski> aryslan : btw, have you already written code to convert the string to a list of tokens ?
09:50:30 <aryslan> yes
09:50:32 <hpaste> wavewave pasted “include function ptr” at http://hpaste.org/53875
09:50:58 <Philippa> ski: for a C or bigger grammar, it takes less time to rewrite Parsec and use it!
09:51:05 <jophish> Yo!
09:51:10 <ski> Philippa :)
09:51:19 <jophish> If a function returns Nothing, can I check that as a bool
09:51:41 <wavewave> In my hpaste, mcfioC_Block takes a c-function xdr_filtercode as a parameter.
09:51:55 <Sgeo|web> :t isNothing
09:51:56 <mysticc> jophish: isNothing
09:51:56 <lambdabot> forall a. Maybe a -> Bool
09:52:02 <Sgeo|web> But you probably don't want to
09:52:22 <ski> @type fromMaybe
09:52:23 <kmc> wavewave, your .h file is not valid C syntax
09:52:24 <lambdabot> forall a. a -> Maybe a -> a
09:52:26 <ski> @type maybe
09:52:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:52:41 <kmc> change xdr_filtercode to (*xdr_filtercode)
09:52:41 <jophish> ah, awesome
09:52:42 <jophish> thanks
09:52:58 <mysticc> jophish: read Data.Maybe from haddock :)
09:53:03 <jophish> will do
09:53:29 <wavewave> kmc: hmm. it's not from my library.. I cannot change it.
09:53:55 <wavewave> kmc: is it a kind of language extension in C? hmm
09:54:02 <ptrf> Cale: ok, so one of the reasons I'm refraining a bit from doing stuff the do-way is because of this... i want to do something like
09:54:47 <Philippa> aryslan: honestly, you're better off forgetting OO while learning FP and thinking in mathematical terms
09:54:48 <ptrf> do {readin <- readFile "dart.logo" ; x <- parseString readin ... return something}
09:54:51 <wavewave> kmc: anyway, if I have * in front of that, then haskell side has no problem?
09:54:58 <Cale> ptrf: okay
09:55:23 <ptrf> rpoblem is
09:55:28 <hpaste> aryslan pasted “recursive program” at http://hpaste.org/53876
09:55:33 <ptrf> parseString has type Either ... Stringo
09:55:47 <ptrf> so even if I do liftM it still comes out with the wrong type
09:56:09 <mysticc> ptrf: use let x = ..
09:56:19 <ptrf> hmm okay
09:56:20 <Cale> ptrf: You just want let
09:56:22 <Cale> yeah
09:56:26 <ptrf> tried that before
09:56:30 <Cale> or case perhaps
09:56:36 <Cale> case parseString readin of
09:56:44 <Cale>   Left err -> print err
09:56:47 <troydm> is there a filter variant that is (a -> b) -> [a] -> ([b],[b]) ?
09:56:51 <ptrf> right
09:56:58 <Cale>   Right res -> ...
09:57:04 <wavewave> kmc: nah... it didn't compile after I change xdr_filtercode to (*xdr_filtercode)  (although it cannot be successful in the final solution anyway.)
09:57:05 <simon> ptrf, that's what I did.
09:57:14 <ptrf> so, about that - once you do the {.. ;.. }-notation, are you then still allowed to leave the in out in let expr in?
09:57:17 <copumpkin> troydm: I don't understand what that would do
09:57:23 <ptrf> simon: :)
09:57:38 <troydm> well first is [b] is values that are true
09:57:46 <troydm> second [b] are values that are false
09:57:46 <copumpkin> :t partition
09:57:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:57:51 <poincare101> Hi again. Is the find function included by default, or do I have to include some module to use it? Currently, the compiler is saying that it can't find a function named find.
09:57:53 <poincare101> :t find
09:57:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:57:54 <simon> ptrf, I did this other cool thing where it either accepts an argv[1] filename or stdin. :P
09:57:59 <ptrf> simon: maybe I should just look at your code
09:58:01 <copumpkin> > partition even [1..10]
09:58:02 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
09:58:06 <copumpkin> troydm: that?
09:58:06 <Cale> ptrf: yeah, you can leave out the 'in' and the definitions bound by the let will scope over the remainder of the do-block (and mutually recursively amongst themselves)
09:58:11 <ptrf> simon: I did see you ahve an Main
09:58:13 <simon> ptrf, it's just a case that matches Left and Right.
09:58:17 <troydm> copumpkin: yes thx
09:58:37 <simon> ptrf, it prints errors to stderr, that's it.
09:58:37 <wavewave> kmc: probably I need to typedef the function pointer type in a separate header file. I couldn't avoid boilerplate... ;-/
09:58:38 <ptrf> i would have loved to be able to ask questions here during the exam
09:59:02 <ptrf> i would have done it in half the time :)
09:59:45 <Sgeo|web> I remember seeing an article saying that Template Haskell is both too strongly-typed and too weakly-typed
10:00:02 <mysticc> Sgeo|web: Send me the link ..
10:00:13 <Sgeo|web> mysticc: I wish I remember where it was
10:00:22 <Sgeo|web> I don't remember the argument for too-strongly-typed
10:00:27 <rwbarton> @google Template Haskell is both too strongly-typed and too weakly-typed
10:00:30 <Sgeo|web> Which is why I was asking
10:00:33 <lambdabot> http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
10:00:33 <lambdabot> Title: Blog: New directions for Template Haskell – GHC
10:00:34 <wavewave> Sgeo|web: it's probably on ghc dev blog
10:00:48 <wavewave> bingo.
10:00:56 <ptrf> simon: do {readin <- readFile "dart.logo"; let (Right prog) = parseString readin; writeFile "dart.svg" $ pictureToSvg $ runProg prog  }
10:00:58 <Cale> That's something people have been saying for a long while though
10:01:00 <ptrf> why does this fail then?
10:01:10 <Sgeo|web> mysticc: ^^
10:01:20 <Cale> ptrf: oh, just because it can't tell where your let ends
10:01:22 <ski> aryslan : do you think there's any chance for you to have a second try attempt on this laboration, if you don't pass this hand-in ?
10:01:29 <mysticc> Sgeo|web: Yup .. found it .. google :)
10:01:53 <Cale> ptrf: you need braces around the definitions like  ... ; let { ... } ; ..
10:02:09 <ski> btw
10:02:11 <ski>   h == "apply" || h == "define" || h == "let" || h == "return" || h == "~" || h == "(" || h == ")" || h == "+"
10:02:11 <Cale> ptrf: if you're not going to lay things out vertically
10:02:13 <mysticc> ptrf: why are you using { and ; .. not a good practice
10:02:15 <ski> is simpler written as
10:02:28 <Sgeo|web> "A very serious weakness"?
10:02:45 <ski>   h `elem` ["apply","define","let","return","~","(",")","+"]
10:02:55 <Cale> Sgeo|web: haha, I know the Jacques that it's talking about :)
10:03:15 <brisingr> Cale, I want to write something about using haskell abstractions in designing space settlements, any recommended reading?
10:03:20 <ptrf> mysticc: because I'm writing in ghci...
10:03:20 <Cale> Sgeo|web: *he's* where I'd heard it said initially that TH is both too strongly and too weakly typed
10:03:28 <ptrf> Cale: ah, so that's the restriction :)
10:04:19 <Cale> ptrf: You can put as many definitions inside a single let as you want, and they're allowed to refer to each other
10:04:21 <wavewave> kmc: just copied mcfio.h to hs_mcfio.h and comment out the function. :-P  for the time being, I hope there is no need for that function on haskell side.
10:04:46 <mysticc> ptrf: better to write in a file and then load it in ghci ...
10:04:59 <wavewave> by the way, which FFI tool do you guys prefer?  c2hs or (hsc2hs + bindings-DSL)?
10:05:06 <Cale> ghci has a :r command which will reload your source file
10:05:08 <brisingr> I mean, what better way to learn haskell than to write a paper?
10:05:27 <ski> brisingr : write a Haskell compiler, in Haskell
10:05:35 <Cale> So most people will keep an editor open alongside ghci and just tap :r whenever they edit their source
10:05:49 <mysticc> */me give +1 to ski
10:05:54 * mysticc give +1 to ski
10:06:18 <brisingr> ski: yeah but that way I can cover another project too
10:06:39 <poincare101> Hi again. Is the find function included by default, or do I have to include some module to use it? Currently, the compiler is saying that it can't find a function named find.
10:08:04 <mysticc> @hoogle find
10:08:04 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:08:04 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
10:08:04 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
10:08:26 <mysticc> poincare101: ^^
10:08:46 <poincare101> mysticc: I see. I don't really understand what that means, sorry.
10:08:52 <poincare101> mysticc: do I have to include anything?
10:09:01 <alistra> import Data.List for example
10:09:11 <alistra> at the top of the file :P
10:09:24 <mysticc> poincare101: What do you want to do with find ... depends on that .. like Data.List module ..
10:09:25 <alistra> unless you're using a Foldable structure other then list
10:09:37 <poincare101> alistra: Thank you.
10:09:47 <poincare101> mysticc: okay, I'm using a simple list, so, thanks a lot.
10:10:28 <mysticc> poincare101: read Data.List on haddock .. just google it ..
10:10:40 <poincare101> mysticc: I did.
10:10:54 <mike-burns> Hey! Who was I talking about example code in the reference docs with the other night!
10:11:04 <mike-burns> THey should look at this conversation that's happening right now.
10:11:41 <ski>   "My reasoning was simple, by writing a Haskell compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and dark corners since I actually needed to implement it correctly."
10:11:46 <ski>   "Writing a compiler is also doubly efficient to begin with, since if you self-compile improvements not only give you a better optimizer, but also speed up your self-compiled compiler. All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic."
10:11:52 <ski>   -- John Meacham, <http://repetae.net/computer/jhc/jhc.shtml>
10:12:02 <ski> brisingr,mysticc ^
10:12:19 <mysticc> ski: hey , I agreed with you .. :p
10:12:46 <ski> just providing the source of the idea
10:13:20 <brisingr> ski: I also agree with you. but my main purpose is to make an "ames space settlement design competition" entry
10:13:34 <brisingr> [don't worry, it's not against the rules to ask random internet people for references]
10:13:57 * ski isn't sure he agrees with himself
10:14:08 <yrlnry> What's "Henk" referred to at http://repetae.net/computer/jhc/jhc.shtml ?
10:14:37 <ski> Henk Barendregt, probably
10:14:38 <erus`> my stackoverflow question got 2 downvotes :(
10:14:45 <erus`> -2 votes even
10:14:51 <yrlnry> No, it seems to be some sort of type system named after Barendregt.
10:15:01 <Philippa> http://www.staff.science.uu.nl/~jeuri101/MSc/jwroorda/
10:15:02 <ski> oh, ok
10:15:08 <erus`> no one left a comment nor a close request
10:15:09 <Philippa> it's a language rather than a type system
10:15:14 * hackagebot timezone-olson 0.1.2 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.2 (YitzGale)
10:15:23 <yrlnry> Philippa:  thanks.
10:15:44 <aryslan> ski: I surely can try... can you help?
10:15:56 * ski str something about "Henk: a typed intermediate langague for .."
10:16:15 <mysticc> erus`: :D :D Dont blame me ..
10:16:17 <Sgeo|web> erus`: Hmm?
10:16:50 <erus`> I know it was 2 of you grumpy people
10:17:08 <dafis> erus`: which question?
10:17:12 * mysticc thinks I am exposed 
10:17:18 <ski> aryslan : well, less than two hours seems maybe too little time to understand the basics of Parsec -- with more time i can help, sure
10:17:32 <yrlnry> Oh, there's a reference at the bottom of the page:
10:17:38 <yrlnry> Henk paper - http://research.microsoft.com/~simonpj/Papers/henk.ps.gz
10:17:39 <erus`> "why is my rotation matrix giving me strange results" or something
10:17:47 <erus`> should still be one of the newest haskell questions
10:18:11 <dafis> erus`: bad news, when I refreshed a few moments ago it was at -3
10:18:18 <aryslan> we can try right?
10:18:39 <erus`> i wish people would leave a message
10:19:22 <mysticc> erus`: There is one answer with +3 votes :p
10:19:28 <dafis> erus`: understandable
10:19:32 <erus`> yeah i mean about the downvotes
10:19:46 <erus`> What were they expecting when they click a question with that title :|
10:19:59 <erus`> a bug in ghc i guess
10:20:16 * hackagebot timezone-series 0.1.2 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.2 (YitzGale)
10:20:27 <dafis> erus`: I think they didn't like that you just posted the code and asked "Can you see the error", they want more context, probably
10:20:45 <erus`> i gave two examples though
10:21:00 <erus`> i was sure the error was in the Y component for some reason
10:21:44 <ski> aryslan : of course, i can also help with the specific code you're attempting to write atm (did you notice my `elem' suggestion a bit up ?) -- but i think doing the parsing by hand in this way will take more time (and possibly be more errorprone)
10:22:27 <aryslan> ski: much simpler
10:23:07 <ski> which is much simpler ? :)
10:23:14 <aryslan> the elem
10:23:26 <ski> ok
10:23:51 <aryslan> ski: you see the grammar that I need to parse?
10:23:54 <ski> btw, if i did a `getType :: String -> String' at all, i'd change it to `getType :: String -> TokenType'
10:24:15 <aryslan> ok
10:24:23 <ski> i.e. why return strings `"Identifier"',`"Identifier"', if we can return symbolic constants instead
10:24:30 <ski> er, i mean like
10:24:46 <ski>   data TokenType = Identifier | StringLiteral
10:24:57 <mysticc> Is there a way to get the type of a function from ghc ?
10:25:05 <ski> of course, it's probably even better to directly return a value of
10:25:19 <ski>   data TypedToken = Identifier String | StringLiteral String
10:25:30 <rwbarton> mysticc: :t ?
10:25:33 <ski> mysticc : in GHCi, you can ask `:t foo'
10:26:11 <mysticc> I want a fun f wuch that f g gives me the type of g in String ?
10:26:17 <mysticc> *such
10:26:30 <ski> at run-time ?
10:26:40 <mysticc> ski: yup
10:26:47 <ski> can't be done in general
10:27:10 <ski> one can use `Typable' to get more or less this, but i'd say don't do that unless you really want it
10:27:11 <dafis> mysticc: typeof, if everything has Typeable instances
10:27:23 <ski> > typeOf (1 :: Int)
10:27:25 <lambdabot>   Int
10:27:28 <ski> > typeOf (1 :: Double)
10:27:29 <lambdabot>   Double
10:27:35 <ski> > typeOf (typeOf (1 :: Double))
10:27:36 <lambdabot>   TypeRep
10:27:55 <ski> > typeOf (typeOf :: Bool -> TypeRep)
10:27:55 <mysticc> @hoogle Typeable
10:27:55 <lambdabot> Data.Typeable module Data.Typeable
10:27:55 <lambdabot> Data.Typeable class Typeable a
10:27:55 <lambdabot> Data.Typeable class Typeable1 t
10:27:56 <lambdabot>   Bool -> TypeRep
10:28:12 <ski> @type typeOf
10:28:13 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:28:20 <ski> mysticc : what do you want this for ?
10:28:28 <alistra> @type typeOf typeOf
10:28:29 <lambdabot>     Ambiguous type variable `a' in the constraint:
10:28:29 <lambdabot>       `Typeable a' arising from a use of `typeOf' at <interactive>:1:7-12
10:28:29 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:28:54 <mysticc> ski: Nothing .. Just wondering .. so what does ghci do in :t ?
10:29:22 <ski> mysticc : it computes the type *without* even compiling the expression to runnable code
10:29:31 <ski> i.e. at compile-time, not at run-time
10:30:16 <mysticc> ski: So If the code it compiled ..then shouldn't all the types be available at runtime
10:30:28 <ski> (of course, in GHCi, compile-time and run-time are interleaved processes -- they're still conceptually distinct, though)
10:30:37 <dafis> mysticc: no, they're only necessary for compilation
10:30:44 <ski> mysticc : except that types are removed before run-time
10:30:50 <mysticc> oh ... thanks ...
10:31:21 <ski> the ability to remove types before run-time is one thing which contributes to generating efficient code
10:32:17 <ski> it means that code which needs to access say a `[Int]' doesn't need to *check* at run-time that it's actually a list of `Ints', instead of e.g. a `Bool' or a `Char -> IO ()'
10:32:37 <ski> it just knows that it will only ever be passed `[Int]'s
10:33:05 <ski> so the only things it has to check is whether the list is empty or has at least one element
10:34:04 <ski> (and we have defined the term "type" so that that distinction between values isn't due to having different types)
10:34:54 <ski> mysticc : does that clarify anything ?
10:35:36 <mysticc> yup .. thanks
10:37:01 <ski> mysticc : btw, note that if you have a polymorphic function `foo :: forall a. [a] -> ...', then because it doesn't know what type `a' is, it can't manipulate the elements of the input list in any other way that discarding them, passing them around (including returning them), and duplicating them (i.e. passing them to more than once place)
10:37:43 <ski> mysticc : this is why you can't write `typeOf :: forall a. a -> TypeOf', there simply is no type information associated with the `a'-value which could be inspected
10:38:29 <mysticc> oh
10:38:36 <ski> otoh, in `typeOf :: forall a. Typeable a => a -> TypeOf' the class constraint `Typeable a' implicitly passes information about the type of the `a'-argument (the argument itself is completely ignored)
10:39:58 <ski> the only reason it isn't `typeOf :: forall a. Typeable a => TypeOf' (no argument passed) is because that would lead to ambiguity problems (which `a' do you want info on ?) -- you can possibly work around this by using explicit type ascriptions, but it'd be a pain in the ass
10:41:56 <ski> (oh, sorry, the `TypeOf' in the result there should of course be `TypeRep')
10:42:36 <ski> @type let myTypeOf :: forall a. Typeable a => TypeRep; myTypeOf = typeOf (undefined :: a) in myTypeOf
10:42:37 <lambdabot>     Ambiguous constraint `Typeable a'
10:42:37 <lambdabot>         At least one of the forall'd type variables mentioned by the constraint
10:42:37 <lambdabot>         must be reachable from the type after the '=>'
10:42:50 <ski> hm, it doesn't appear to like the ambiguous signature
10:43:21 <ski> if it worked, one could possibly use it like `myTypeOf :: Typeable Bool => TypeRep' to get `Bool :: TypeRep' returned
11:10:15 * hackagebot type-unary 0.1.5 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.5 (ConalElliott)
11:17:31 <Upgrayedd> hi so I was playing around with Haskell, trying to understand type constructors etc. I made this: data MyList a = Empty | a :> MyList a   by analogy to the standard built in list type.  It mostly works, but there's one thing I can't figure out: how can I construct a nested empty list analagous to [[]]?
11:18:34 <parcs> :t [] :: [[a]]
11:18:35 <lambdabot> forall a. [[a]]
11:18:39 <parcs> :t [] :: [[[[a]]]]
11:18:40 <lambdabot> forall a. [[[[a]]]]
11:18:53 <byorgey> Upgrayedd: Empty :> Empty ?
11:19:05 <byorgey> > [] : []
11:19:06 <lambdabot>   [[]]
11:19:09 <shachaf> Upgrayedd: [[]] is shorthand for [] : []
11:19:17 <Upgrayedd> aha
11:19:22 <shachaf> Just like [1] is shorthand for 1 : []
11:19:44 <Upgrayedd> actually i had thought about that but it didn't seem right... this stuff is obfuscated because the built in list type has special handling
11:19:50 <byorgey> it can be a bit confusing because the two occurrences of [] have different types
11:20:04 <byorgey> the same is true in  Empty :> Empty
11:20:29 <byorgey> if the first Empty has type  MyList T  then the second Empty has type  MyList (MyList T)
11:21:03 <erus`> kmc; no quotes in this weeks haskell news
11:21:20 <erus`> i am disappoint
11:21:31 <byorgey> Upgrayedd: this is actually a good exercise for understanding polymorphic types =)
11:21:40 <ski> Upgrayedd : the only special handling in the list syntax is that there's some syntactic sugar for it
11:22:04 <Upgrayedd> yes but it is exactly that that causes me to not understand it fully
11:22:35 <Upgrayedd> by doing the exercise with named type constructors, it makes it easier to see what is actually going on
11:23:37 <shachaf> If you find it clearer you can use a prefix constructor, as in data List a = Nil | Cons a (List a)
11:23:43 <Upgrayedd> like if I do :t [[]] I get [[a]] which is not so useful :)
11:24:19 <Upgrayedd> true, i guess the infix :> wasn't helping
11:24:20 <min> think of types as uninterpreted terms and run unification on them: if nil : list a and cons : b -> list b -> list b, then cons nil : list (list c) -> list (list c).
11:25:11 <min> (after generating fresh variablese and substituting list c for b)
11:33:19 <byorgey> I'm thinking of proposing an undergrad course entitled "The Art of Recursion". I'd cover a little Haskell but it wouldn't be the main focus.  What would you like to see in such a course?
11:33:31 <byorgey> I'm just brainstorming topics.
11:33:53 <c_wraith> Tarjan's liner-time order statistics?
11:34:12 <c_wraith> crazy bizarre recursion scheme in that.
11:34:17 <byorgey> oooh, nice
11:34:43 <alpounet_> byorgey, people are scared of recursion, so just don't make it look more complicated than what it is, for a starter :P
11:35:21 <c_wraith> Also, a strong treatment of writing recurrence relations and solving them.  Proving the results of the Master Method, for instance.
11:35:51 <byorgey> alpounet_: of course.  That's how I'm going to sell it. "Recursion is often seen as scary and to be avoided, but that's a shame... in this course we'll demystify recursion and see some of the beautiful things you can do with it and its relationship to blah blah blah"
11:35:52 <c_wraith> err, Master Theorem?  I can't even remember the name of it.
11:36:37 <byorgey> yeah, the Master Theorem
11:37:03 <alpounet_> byorgey, ok, then yeah well probably its relationship with data structures (inductive types), that kind of things
11:37:38 <c_wraith> I'm not completely sure if you're talking about an introduction to recursion or an in-depth study of it.  So, I'm a little unsure if something like the master theorem is outside the intended scope
11:38:10 <byorgey> c_wraith: I'm not completely sure either.  I'm just brainstorming right now, so any and all ideas are welcome =)
11:38:52 <byorgey> in practice since it's a half-credit course we won't really be able to go to too much depth. But that doesn't rule out talking about recurrence relations.
11:40:59 <Upgrayedd> > subs (1 :> 2 :> 3 :> Empty) Empty :> ((3 :> Empty) :> ((2 :> Empty) :> ((2 :> (3 :> Empty)) :> ((1 :> Empty) :> ((1 :> (3 :> Empty)) :> ((1 :> (2 :> Empty)) :> ((1 :> (2 :> (3 :> Empty))) :> Empty)))))))
11:41:00 <lambdabot>   Not in scope: `subs'Not in scope: data constructor `:>'Not in scope: data c...
11:41:10 <Upgrayedd> it works!  thanks for all your help
11:41:14 <shachaf> byorgey: _The Little Schemer_ might be a good place for inspiration, depending on the background of the students.
11:41:18 <c_wraith> possibly some discussion of the various "types" of recursion (natural induction, structural induction, etc), where they come from, why they're discussed differently sometimes, how they're essentially the same underneath it all...
11:41:29 <byorgey> Upgrayedd: =D
11:42:03 <byorgey> c_wraith: what's "natural induction"?  you mean induction on natural numbers?
11:42:07 <c_wraith> yes
11:42:13 <byorgey> ok, yeah
11:43:49 <c_wraith> maybe some discussion of the implementation of recursion...  going so far as to discuss pushdown automata, if you're amazingly brave. :)
11:45:59 <JoeyA> What switch do you give ghc to use the native code generator?  Or is that the default?
11:46:50 <dafis> JoeyA: default
11:46:55 <JoeyA> Thanks
11:47:51 <JoeyA> I thought GHC currently has (at least) three code generation methods: 1) Generate C and compile with GCC, 2) LLVM, and 3) Generate instructions directly
11:48:03 <JoeyA> and I thought (1) was the default.
11:50:16 <keep_learning> byorgey, According to my Haskell language ( although its very limited ) but combining Haskell with algorithm would be great.
11:50:35 <int-e> It used to be, but compilation via C is no longer supported (-fvia-C is a no-op), as far as I know.
11:50:43 <JoeyA> Ah, okay
11:53:29 <int-e> (see http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/release-7-2-1.html ... there's still support for compilation via C (but unregisterised) for platforms without NCG, if I read this correctly. Does this actually work?)
11:58:12 <singpolyma> I'm writing some code that handles n-space vectors.  I'm currently representing them as [Float].  All of them are the same "length" since the application will only be working on one dimension-space at a time.  So my question is: is there a way to type-check that they are all the same length, while leaving what that length is parametrizable/inferable ?
12:04:35 <ocharles> singpolyma: there are a few ways I know of, but they require some fairly complex type trickery and extensions
12:05:08 <ocharles> and it won't let you use [Float], you'll have to define your own list type
12:05:40 <ocharles> with prelude's [], I don't think you can verify what you want with the type checker. you'll have to complement it with something extra
12:07:24 <singpolyma> ocharles: right, I figured I would need a new type
12:07:37 <byorgey> singpolyma: see http://hackage.haskell.org/package/tagged-list  perhaps
12:07:52 <singpolyma> Though if nothing similar is already out there I may forgo it for now
12:08:27 <ocharles> mmm, unicode syntax
12:09:58 <singpolyma> hmm, that one looks interesting
12:13:46 <luite> there's also vector-static, but it's not actively developed anymore
12:17:29 <k0ral> how would you name the infix operator :: Maybe a -> (a -> IO ()) -> IO () that returns () for Nothing and feed the second argument with the first for Just something ?
12:18:16 <rwbarton> :t traverse
12:18:17 <lambdabot> Not in scope: `traverse'
12:18:21 <rwbarton> @hoogle traverse
12:18:21 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:18:21 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:18:21 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
12:18:42 <shachaf> @ty maybe (return ())
12:18:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
12:19:16 <shachaf> No need to restrict it to IO.
12:19:18 <rwbarton> if I had to give it an infix operator name, maybe something like >>=? or >>?=
12:19:40 <k0ral> shachaf: fair point, but not answering my question :)
12:19:53 <shachaf> rwbarton: If it was Maybe (IO a) or IO (Maybe a) then maybe, but it seems odd to use a >>=-inspired name for that.
12:20:02 <rwbarton> oh right
12:20:34 <k0ral> any other suggestion then ?
12:20:35 <rwbarton> then I can't really imagine writing this operator infix
12:21:10 <k0ral> why couldn't you ? it looks like a binding behavior
12:21:24 <mike-burns> It looks like (>>=)
12:21:37 <mike-burns> Except with two monads instead of one.
12:21:52 <shachaf> Inter-monad (>>=)! Think of the papers!
12:22:15 <dafis>  (>?>~)
12:22:28 <k0ral> why the ending ~ ?
12:22:33 <mike-burns> (>>=>>=)
12:22:36 <k0ral> >?> looks good
12:22:37 <shachaf> >=?!#>--==
12:22:41 <dafis> 'cause it twiddles two monads
12:22:45 <shachaf> k0ral: What are you using the operator for?
12:22:45 <k0ral> =D
12:23:00 <k0ral> I have a lot of a -> IO () functions and a lot of Maybe a
12:23:07 <k0ral> I'm tired of writing maybe (return ())
12:23:36 <shachaf> If this is all in one place, you could just mapM_ (maybe (return ())) :-)
12:23:42 <shachaf> Or sequence_ . catMaybes
12:23:58 <k0ral> unfortunately that's not
12:24:17 <k0ral> I'll adopt the >?>
12:24:36 <rwbarton> something like $? would be closer imo
12:24:38 <rwbarton> f $? x
12:25:04 <rwbarton> Certainly I don't see a reason to put the argument on the left...
12:25:48 <k0ral> rwbarton: it makes sense to me since "depending on the value of the argument, we may or may not run the function"
12:27:40 <k0ral> but actually it's not really useful since it cannot be chained
12:32:28 <ski> k0ral : i would name it  `forMaybe_`  ..
12:32:56 <ski>   forMaybe (...) $ \x -> do
12:32:57 <rwbarton> @hoogle forM_
12:32:57 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
12:32:57 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
12:32:58 <shachaf> ski: Hmm, interesting name.
12:33:01 <ski>     ..x..
12:33:04 <ski> alt.
12:33:06 <rwbarton> it already exists as forM_, does it not
12:33:11 <ski>   ... `forMaybe` \x -> do
12:33:13 <ski>     ..x..
12:33:15 <shachaf> Except of course the M doesn't stand for "list". :-)
12:34:26 <ski> @type Data.Foldable.forM_
12:34:27 <lambdabot> forall (t :: * -> *) a (m :: * -> *) b. (Data.Foldable.Foldable t, Monad m) => t a -> (a -> m b) -> m ()
12:34:36 <shachaf> @instances Foldable
12:34:36 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
12:34:42 <shachaf> @instances-importing Data.Foldable Foldable
12:34:44 <lambdabot> Maybe, []
12:35:11 <rwbarton> see, it's much more general :P
12:36:21 <alistra> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
12:36:22 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w ->
12:36:22 <lambdabot> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33)
12:36:38 <alistra> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
12:36:39 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
12:36:39 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
12:36:39 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143. a -> b -> c -> d -> e -> f -
12:36:39 <lambdabot> > g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 ->
12:36:39 <lambdabot>  t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 ->
12:36:41 <lambdabot> [7 @more lines]
12:37:26 <alistra> well that's the most damage i've done with lambdabot, print out  lines
12:37:31 <wlangstroth> poor lambdabot
12:38:21 <acowley> have you stolen his innocence?
12:40:03 <alistra> it's his fault, look what he's wearing
12:43:33 <ben> > id id id id id id id id id id id id id id id id id id id id id id id id id 0
12:43:37 <lambdabot>   mueval-core: Time limit exceeded
12:43:58 <yrlnry> heh
12:45:12 <yrlnry> why does that happen?
12:45:28 <alistra> yrlnry: lack of $ inbetween
12:45:29 <yrlnry> :t (that expression) is quick, so presumably it isn't a failure in the tpe inference algorithm.
12:45:35 <yrlnry> alistra:  so?
12:45:36 <lambdabot> parse error on input `,'
12:45:37 <ski> acowley : lambdabot is traditionally a "her"
12:45:55 <yrlnry> Yeah, if it were male it would be lambdusbot.
12:46:00 <alistra> it's his fault, look what he's wearing
12:46:11 <alistra> it's her fault, look what she's wearing*
12:46:18 <ben> :t id id id id id id id id id id id id id id id id id id id id id id id id id
12:46:18 <int-e> yrlnry: type checking?
12:46:19 <lambdabot> forall a. a -> a
12:46:26 <ben> how's that "slower" than regular id
12:46:37 <int-e> :t \f -> (id `asTypeOf` f) id id 0
12:46:38 <lambdabot> forall a. (Num a) => (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a
12:46:42 <rwbarton> sometimes lambdabot is very slow for no particular reason
12:46:42 <int-e> :t \f -> (id `asTypeOf` f) id id id 0
12:46:43 <lambdabot> forall a. (Num a) => ((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> a
12:46:44 <rwbarton> > id id id id id id id id id id id id id id id id id id id id id id id id id 0
12:46:45 <int-e> and so on.
12:46:51 <lambdabot>   mueval: ExitFailure 1
12:46:51 <lambdabot>  mueval-core: Time limit exceeded
12:46:54 <rwbarton> > id id id id id id id id id id id id id id id id id id id id id id id id id 0
12:46:57 <alistra> > id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ 0
12:47:01 <lambdabot>   mueval-core: Time limit exceeded
12:47:01 <lambdabot>   mueval: ExitFailure 1
12:47:01 <lambdabot>  mueval-core: Time limit exceeded
12:47:02 <alistra> oh
12:47:04 <rwbarton> > 0
12:47:07 <lambdabot>   0
12:47:12 <rwbarton> hmm
12:47:14 <alistra> > id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ id $ 0
12:47:15 <lambdabot>   0
12:47:49 <rwbarton> Prelude> id id id id id id id id id id id id id id id id id id id id id id id id id 0
12:47:53 <rwbarton> Killed
12:47:55 <int-e> the size of the type of the first id grows exponentially in the number of ids
12:47:55 <rwbarton> odd!
12:47:58 <rwbarton> yes
12:48:18 <rwbarton> but :t id id id id id id id id id id id id id id id id id id id id id id id id id 0 is fast
12:48:43 <copumpkin> > id `asTypeIn` (\i -> i id id id id id id id id id id id id id)
12:48:45 <lambdabot>   Overlapping instances for GHC.Show.Show
12:48:45 <lambdabot>                              ((((((...
12:48:47 <copumpkin> :t id `asTypeIn` (\i -> i id id id id id id id id id id id id id)
12:48:55 <lambdabot> forall a. (((((((((((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) ->
12:48:55 <lambdabot> a -> a) -> ((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a)
12:48:55 <lambdabot> -> (((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((
12:48:55 <lambdabot> a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((((a ->
12:48:55 <lambdabot> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((a -> a) -> a
12:48:57 <lambdabot> [490 @more lines]
12:48:59 <copumpkin> lol
12:49:27 <int-e> rwbarton: true, that is funny ... but type checking happens on haskell code actually; so I guess the translation to system F (which requires explicit type arguments to each id function) fails afterwards.
12:49:40 <alistra> what's asTypeIn?
12:49:41 <Tomsik> What is going on here?
12:49:43 <Tomsik> :t id id id
12:49:44 <lambdabot> forall a. a -> a
12:49:51 <Tomsik> That doesn't seem big at all
12:49:51 <int-e> rwbarton: which means it isn't type checking after all ... but strongly related.
12:50:03 <alistra> @def asTypeIn
12:50:03 <lambdabot> Maybe you meant: bf do let
12:50:04 <wlangstroth> is Core still "system F", or am I mixing up two different things?
12:50:10 <copumpkin> alistra: asTypeIn = const
12:50:14 <copumpkin> with a stricter type
12:50:30 <int-e> (well, ghc's core language, not system F)
12:50:58 <int-e> rwbarton: it's definitely a funny example
12:51:06 <jhance> wlangstroth: I think that core is based on System F
12:51:24 <int-e> jhance: it is
12:51:29 <wlangstroth> ah, I see
12:52:32 <rwbarton> yeah, when I try to compile it, the compiler fails ("Killed")
12:52:51 <int-e> rwbarton: so I /suppose/ that type checking this expression actually produces a nice type with shared subtypes, but that in the translation to core, that sharing gets lost. I'm guessing though.
12:53:08 <rwbarton> That sounds plausible
12:55:16 <JoeyA> *regurgitating what I think I read in "Haskell: Lazy with Class" yesterday* Core is based on System Fω.  I don't really know what that means, though.
12:55:36 <JoeyA> But if it showed up on a multiple choice test, I'd get 4 points.
12:55:58 <jhance> hmm is there a nice way to integrate benchmarking with profiling? Since if you use Criterion it'd run the case ~100 times and I would only want to run it once, but I also wouldn't want to create an entirely new executable to test a library
12:57:17 <acowley> Run your benchmark manually for the profiling run
12:57:38 <acowley> oh you want to do it from one executable
12:57:55 <acowley> then write your own main to take an argument specifying if it should do a profiling run or a benchmark run
12:58:57 <acowley> You could use defaultMainWith, and change the Config parameter based on a command line argument
13:00:18 <jhance> acowley: I'd like to use the same criterion selection machinery though. I will look at defaultMainWith
13:01:03 <hpaste> elliott pasted “Pure Haskell2010 IORef implementation” at http://hpaste.org/53881
13:01:12 <elliott> Oops, didn't mean to send that to the channel...
13:01:19 <elliott> I guess you can all enjoy the horror now.
13:01:20 <jhance> I guess I could use the Benchmarkable typeclass to run whatever but I'd have to write code to parse the arguments etc
13:01:41 <jhance> Basically what I want is to have all the profiling tests under one executable and be able to run either benchmark or profile on any run
13:02:04 <jhance> without having to re-write a lot of Criterion code that deals with finding the Benchmarkable :\
13:03:27 <elliott> Kind of annoying that GHC just violates the Report and only tells you about it when you program crashes :(
13:03:28 <acowley> elliot: it's beautiful
13:03:33 <copumpkin> looks like that id id id id id id thing already made it to reddit
13:03:34 <copumpkin> wow
13:03:38 <copumpkin> it's as if someone is observing us
13:03:47 <copumpkin> who's fishdicks?
13:03:52 <elliott> It's not even in the documentation for base's Foreign.ForeignPtr.
13:03:55 <elliott> acowley: thanks :P
13:04:39 <elliott> I wonder how it performs :)
13:04:41 <elliott> probably terribly
13:05:09 <chrisdone> copumpkin: they forgot to compile with -TO2
13:05:36 <copumpkin> :O
13:06:36 <ski> elliott : i wonder whether `atomicModifyIORef' is really atomic
13:06:55 <copumpkin> why wouldn't it be?
13:07:24 <ski> i mean elliott's reimplementation of it
13:07:27 <copumpkin> oh
13:07:31 <elliott> ski: nope!
13:07:37 <elliott> ski: but threads aren't haskell2010 either
13:07:40 <elliott> so it's ok :p
13:07:52 <copumpkin> surely the correct type is
13:07:59 <copumpkin> atomicModifyIORef :: IORef a -> (a -> b) -> IO c
13:08:04 * copumpkin coughs
13:08:11 <elliott> copumpkin: :(
13:08:35 <Tomsik> haha
13:08:41 <Tomsik> IO c, funny you
13:08:46 * ski stares blankly
13:09:11 <elliott> copumpkin is referencing the worst thing in GHC.Prim.
13:09:15 <acowley> it's an olympics joke
13:09:46 <elliott> or if he's not he should be
13:09:50 <copumpkin> I am
13:10:13 <copumpkin> ski: atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (#State# s, c#)
13:10:21 <elliott> there's a lot of ways to do multiple return values: tuples, CPS, unboxed tuples, ... unsafeCoerce...
13:10:46 <Tomsik> Excuse my ignorance, how can you return multiple values with CPS?
13:10:47 <ski> copumpkin : strange :)
13:10:57 <elliott> Tomsik: forall r. (a -> b -> r) -> r
13:10:59 <elliott> ~ (a,b)
13:11:00 <copumpkin> ski: tuples don't exist at that point in compilation, so they hide them
13:11:12 <copumpkin> not hide
13:11:16 <elliott> edwardk should make trifecta use an unsafeCoerce state monad
13:11:17 <copumpkin> but they inspect the closure
13:11:24 <ski> copumpkin : i would have expected `atomicModifyMutVar# :: MutVar# s a -> (a -> (# a , b #)) -> State# s -> (#State# s, b#)' or something similar
13:11:42 <elliott> StateT m a = s -> m b
13:11:48 <elliott> the unsafeCoerce makes it closer to C, thus faster
13:11:53 <copumpkin> ski: you should suggest it :)
13:12:11 <copumpkin> elliott++
13:12:44 * ski has been pondering a type system that allows C++-like references, but nestedly
13:12:52 <elliott> ooh, I wonder if you can make the CPS and unboxed tuple state monads somehow have overlapping representations
13:12:59 <elliott> so you can choose the fastest one for the situation with unsafeCoerce!
13:13:16 <ski> so you can not only say `& x = ...;', you can in some cases say `& & x = ...;', and so on :)
13:13:36 <Tomsik> Either I'm dumb or have drank too much beer, but I do not understand your explanation :( Could you elaborate?
13:13:42 <roconnor_> > ٤
13:13:44 <lambdabot>   <no location info>: lexical error at character '\1636'
13:13:58 <elliott> Tomsik: say you have a function taking an Int and a Double
13:14:04 <elliott> and returning two Strings
13:14:08 <elliott> here's one way:
13:14:14 <elliott> f a b = (show a, show b)
13:14:17 <elliott> here's another:
13:14:22 <elliott> f k a b = k (show a) (show b)
13:14:22 <ski> Tomsik : instead of `let (x,y) = foo in ..x..y..', you do `fooCPS (\x y -> ..x..y..)'
13:14:29 <elliott> first one: f :: Int -> Double -> (String,String)
13:14:38 <elliott> second one: f :: (String -> String -> r) -> Int -> Double -> r
13:14:40 <elliott> latter is CPS
13:14:51 <Tomsik> Oh I see now, thanks
13:15:03 <ski> could also be `f :: Int -> Double -> (String -> String -> r) -> r', of course
13:15:05 <elliott> np  :)
13:15:10 <elliott> ski: yeah
13:15:15 <elliott> i realised i should have said that three seconds too late
13:15:30 <elliott> ski: otoh currying on the continuation is nice
13:15:33 <elliott> erm
13:15:34 <elliott> partially applying
13:15:46 <ski> *nod*, there's advantages to both
13:16:41 <chrisdone> forgot what i came on for, bbl
13:18:02 <erus`> > id id id id id id id id id id id id id id id id id id id id id id id id id 0
13:18:12 <lambdabot>   mueval-core: Time limit exceeded
13:18:36 <acowley> Is RenderableRenderer as awesome a module name as it seems?
13:18:57 <monochrom> haha sounds javaish, if that's what you mean
13:19:17 <acowley> Yeah, that's the vibe I was getting, too.
13:19:36 <wlangstroth> RenderableRendererFactory
13:19:52 <slack1256> guys, i want to check if my opinion is right
13:20:00 <slack1256> attopàrsec goal is for network protocols
13:20:19 <slack1256> so it would make sense that they aren't planning to add support for Data.Text right?
13:20:32 <elliott> sure
13:20:45 <elliott> you can use it with Data.Text
13:20:47 <elliott> you just have to decode explicitly
13:21:06 * monochrom stays away from opinions
13:21:10 <c_wraith> given that the same guy wrote Data.Text and Attoparsec, the fact that they don't work together isn't accidental
13:21:12 <slack1256> but it kill the efficiency and purpose right?
13:21:24 <slack1256> oh, i didn't know that
13:21:32 <newbie|2> hello
13:21:32 <acowley> What's the current opinion on converting between Float and GLfloat?
13:21:35 <Taejo> > id id id id id id id id id id id id id id id id id id id id ()
13:21:39 * ski . o O ( <http://www.haskell.org/haskellwiki/Tangible_Value> )
13:21:39 <lambdabot>   ()
13:21:40 <mertis> hows it goin:d
13:21:46 <Taejo> > id id id id id id id id id id id id id id id id id id id id id id id id ()
13:21:51 <lambdabot>   mueval-core: Time limit exceeded
13:22:14 <acowley> I tend to unsafeCoerce when nobody's looking as we await a more principled solution.
13:22:16 <elliott> slack1256: i don't think it'd make it inefficient
13:22:19 <elliott> but eh
13:22:45 <mertis> anyone mind looking at a function i wrote and telling me why its doing what it is doing
13:22:57 <ski> sure
13:22:59 <mertis> http://snipt.org/Hgnj9
13:23:03 <mertis> what is happening
13:23:04 <mertis> is
13:23:05 <Taejo> GHC is terrible, it can't even compute the identity function efficiently ;)
13:23:05 <alistra> 28.5 MB
13:23:05 <alistra> 2697 x 3693 px (8.99 x 12.31 in.) - 300 dpi - RGB
13:23:05 <alistra> File size on download 3.88 MB
13:23:05 <alistra>  EUR 155,00 Add to cart
13:23:08 <mertis> when i get to the last element
13:23:09 <alistra> 28.5 MB
13:23:09 <alistra> 2697 x 3693 px (8.99 x 12.31 in.) - 300 dpi - RGB
13:23:09 <alistra> File size on download 3.88 MB
13:23:09 <alistra>  EUR 155,00 Add to cart
13:23:14 <slack1256> elliott: i thought that the step from Data.Text to byteString was expensive
13:23:21 <elliott> slack1256: huh?
13:23:25 <alistra> sorry, same button for link click and paste is not a good combo
13:23:30 <mertis> it is adding a empty list that i dont want to be there
13:23:40 <slack1256> elliott: even when the two are arrays at the bottom
13:23:52 <elliott> slack1256: well, they are different types :P
13:23:58 <elliott> but Text is just UTF-16 afaik
13:24:03 <elliott> so for sequential parsing I don't see why it'd be slow
13:25:03 <ski> mertis : maybe you want to replace at least one of the `[[]]'s in there with `[]' ?
13:25:17 <mertis> mertis: where at?
13:25:24 <mertis> ski: ski: where at?
13:25:39 <ski> i mean the three occurances after `='
13:25:47 <acowley> the third line should be removed
13:26:08 <ski> note that `[]' is a valid value (it's the empty list) of type `[[Float]]'
13:26:28 <ski> while `[[]]' is not an empty list, it's a list that contains the empty list as its sole element
13:27:12 <ski> mertis : hm, right. as acowley says, `checkAltOutOfBound [[]] _ _ = [[]]' and `checkAltOutOfBounds [[]] low high = [[]]' does the exact same thing, so you can remove any one of those
13:27:37 <mertis> ski: ok i did that
13:27:55 <mertis> but its still not doing what i want. It is adding an empty list at the end
13:27:57 <mertis> which i dont want
13:28:13 <ski> did you replace `= [[]]' with `= []' yet ?
13:28:22 <ski> (there's two places to replace at)
13:28:30 <mertis> i updated at
13:28:32 <mertis> http://snipt.org/Hgnj9
13:28:42 <mertis> the function return type is [[]]
13:28:52 <ski> it doesn't matter
13:29:05 <ski> the function return type is `[[Float]]'
13:29:12 <ski> <ski> note that `[]' is a valid value (it's the empty list) of type `[[Float]]'
13:29:31 <ski> if you don't want to return any element in the output list, you should return an empty list, which is written as `[]'
13:29:48 <ski> `[[]]' is not an empty list, it is a list that has a single element : the empty list
13:30:04 <mertis> ha
13:30:06 <mertis> i <3 u
13:30:10 <mertis> fixed it
13:30:24 <ski> also, i think you can probably simplify the base case, i.e.
13:30:27 <ski>   checkAltOutOfBound [[]] _ _ = []
13:31:03 <ski> i'm assuming you just want to loop through every element in the list, checking whether to remove it or not
13:31:07 <ski> in that case, you can just have a base case of :
13:31:10 <ski>   checkAltOutOfBound [] _ _ = []
13:31:40 <mertis> ok cool
13:31:45 <ski> which means that when the recursion reaches the empty list (the end of the whole list), it will stop generating any more output elements (because it returns the empty list, which becomes the end of the output list)
13:32:13 <wlangstroth> mertis: it looks like you want to use filter
13:32:29 <ski> now, after having done that, you can merge the two last cases into one, simplifying your code even more
13:32:30 <wlangstroth> (I am not a paperclip)
13:33:05 * ski clips wlangstroth around a paper about run-time code generation
13:33:12 <mertis> i probably do want to use filter
13:33:34 <mertis> im just inexperienced with haskell so i dont know all the usefull functions and how they work
13:33:41 <ski> mertis : btw, note that `(removeAltOutOfBounds x low high) == True' is simpler written as just `removeAltOutOfBounds x low high'
13:34:18 <wlangstroth> :)
13:34:22 <ski> mertis : no problem. it's probably just good practice to make recursive functions on your own, since there isn't always a nice ready-made function like `filter' or `map' which you can use
13:34:48 <wlangstroth> what does removeAltOutOfBounds look like?
13:34:57 <mertis> ill post it
13:34:58 <mertis> momen
13:34:58 <mertis> t
13:35:26 * hackagebot HaskellForMaths 0.4.1 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.1 (DavidAmos)
13:35:37 <mertis> http://snipt.org/Hgnj9
13:36:42 <ski> you could redefine `removeAltOutOfBounds' to say
13:36:42 <mertis> the naming of the functions
13:36:42 <mertis> is backwards
13:36:51 <ski>   removeAltOutOfBounds [a,b,c,d] x y = not (x <= c && y >= c)
13:36:55 <mertis> what they are called is backward from what they do
13:36:57 <ski> or, if you prefer
13:37:13 <ski>   removeAltOutOfBounds [a,b,c,d] x y = x >= c || y <= c
13:37:28 <wlangstroth> the latter is what it looked like to me
13:37:40 <ski> maloi : hm, the naming of which functions ?
13:37:54 <ski> er
13:37:57 <ski> mertis : ^
13:38:21 <Taejo> interesting phenomenon here, what's going on: http://www.reddit.com/r/haskell/comments/m7uph/whats_going_on_with_id_id_id_id_0/
13:38:24 <mertis> the remove and the check functions, i should have named them the other way around
13:38:29 <ski> oh
13:38:40 * ski thought mertis was talking about any standard functions
13:39:14 <danlei> does anyone know how to make gnuplot (0.4.2) close the gnuplot shell on windows after output? (I have to type 'q' manually in ghci and in cmd)
13:39:41 <mertis> this assignment we were given had 4 problems
13:39:49 <mertis> i spent maybe 4-5 hours total on the first 3
13:39:55 <mertis> ive spent 3 days on the last one
13:40:02 <mertis> such a dick problem for haskell newbs
13:40:19 <ski> well, it's (hopefully) good exercise in how to think
13:40:29 <wlangstroth> also, your prof might be on this channel
13:40:43 <Tomsik> haha
13:40:45 <mertis> lol
13:40:50 <jhance> be nice ^_^
13:40:51 <wlangstroth> (I kid! I kid!)
13:40:53 <mertis> i have no problem with the professor
13:41:03 <mertis> hes a good teacher, its just this probelm
13:41:04 <Tomsik> Just make sure you're behind seven proxies
13:41:19 * ski professes to be the profoss
13:41:39 <mertis> O.o
13:41:51 <mertis> whats ur name then?
13:41:57 <mertis> your initials at least
13:41:59 <mertis> :)
13:42:19 <Tomsik> I bet his name ends in -ski!
13:42:20 <Tomsik> :P
13:42:30 <ski> hehe, "profoss" is not the same as "professor"
13:42:39 <ski> mertis : also, i was kidding :)
13:42:40 <copumpkin> protoss?
13:42:43 <mauke> Stefan Ljungstrand
13:42:47 <mertis> ski: :D
13:42:55 <mauke> and he's currently away
13:43:10 <ski> that i am
13:43:32 <ski> mertis : btw, i hope you know you can do `/whois ski', e.g.
13:43:33 <acowley> edwardk zerg rushes hackage periodically
13:43:37 <acowley> it all fits
13:43:38 <jhance> I always feel like ghc's compilation performance is so spread out
13:43:41 <Cale> We require additional pylons.
13:43:47 <jhance> I've had short modules take ~5 minutes to compile
13:43:53 <jhance> and longer ones take less than a second
13:44:10 <jhance> anyone else experience this?
13:45:15 <Cale> jhance: heh, that's one of the problems with our custom arrow preprocessor -- GHC seems to take a pathologically long time compiling some of the (admittedly somewhat absurd by human standards) code that it constructs.
13:45:19 <gwern> @quote
13:45:19 <lambdabot> psnively says: All your Data.Foldable are belong to base.
13:46:02 <Cale> jhance: It's a hard problem in general. Typechecking is theoretically exponential space in code size.
13:46:03 <gwern> I remember seeing a non-Free haskell tool which turns a bunch of modules into a single big GHC module, for considerable speedups. I wonder if that's still true
13:46:12 <ski> oh, actually "profoss" is "provost" in english
13:46:25 <jhance> Cale: Yes, I was just wondering. The compiler tends to go to 100% cpu usage too.
13:46:36 <acowley> argh, imports are about 25% of the lines in basically everything I write
13:46:56 <jhance> acowley: Sounds like 25% less lines to write.
13:47:01 <Cale> (though I only know of contrived examples where anything close to that worst case is attained)
13:47:16 <acowley> jhance: it's just ugly
13:47:33 <jhance> Cale: The package that has the longest time for me is Criterion... One module in particular takes forever
13:47:35 <jhance> I don't recall which
13:47:43 <ski> @all-dicts provost
13:47:43 <lambdabot> *** "Provost" gcide "The Collaborative International Dictionary of English v.0.48"
13:47:44 <lambdabot> Provost \Prov"ost\, n. [OF. provost (L. prae and pro being
13:47:44 <lambdabot>    confused), F. prev[^o]t, fr. L. praepositus placed before, a
13:47:44 <lambdabot>    chief, fr. praeponere to place before: cf. AS. pr[=a]fost,
13:47:44 <lambdabot>    pr[=o]fast. See {Preposition}, and cf. {Propound}.]
13:47:45 <lambdabot> [47 @more lines]
13:48:08 <acowley> While in theory I like the idea of being able to look at imports to see where an unfamiliar name came from, it just seems to get out of hand.
13:48:35 <ski> acowley : use qualified imports ?
13:48:53 <jhance> acowley: What alternative would you propose? We have to have some sort of qualification
13:49:09 <ski> (Cale : hm, istr it was double exponential or something like that ..)
13:49:11 <acowley> ski: it's not that each import is long. It's just that things like Applicative, Arrow, Monad, List, Maybe, Monoid, and Map are used so frequently
13:49:22 <acowley> jhance: I think I just want a beefy prelude
13:49:30 <acowley> jhance: but the community hasn't really rallied around one
13:50:09 <acowley> jhance: and without a particular beefy prelude becoming commonly accepted, it will be to confusing
13:50:23 <luite> import Control.*
13:50:28 <CosmicRay> @seen syntaxninja
13:50:28 <preflex>  syntaxninja was last seen on #haskell-blah 104 days, 14 minutes and 8 seconds ago, saying: but take either red or blue train, doesn't matter. whichever one gets there first.
13:50:28 <lambdabot> Unknown command, try @list
13:51:07 <Cale> ski: Oh, perhaps
13:51:38 <SyntaxNinja> CosmicRay: y0
13:52:12 <Cale> ski: At least, I know a sequence of programs where the sizes of the types of the programs are exponential in the length of the program.
13:52:52 <SyntaxNinja> CosmicRay: I think you'll be in town for this talk, which you're welcome to come to: http://corp.galois.com/blog/2011/11/10/tech-talk-candid-experiences-from-a-hardware-startup.html
13:53:15 <CosmicRay> afternoon - /msg sent
13:53:15 <luite> from the cabal-install repository, how do I get the 0.12 branch?
13:53:33 <ski> Cale : *nod*
13:54:16 <CosmicRay> SyntaxNinja: hmmm hmmm!  sounds interesting
13:54:32 <luite> (why is there still no cabal-install release on hackage that works with ghc 7.2 btw, are there known serious problems?)
13:55:21 <mertis> blah
13:55:27 * hackagebot epic 0.9 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.9 (EdwinBrady)
13:55:28 <mertis> getting the problem where im adding an empty list again
13:55:36 <elliott> luite: well, that would lead most people to a broken tarball when they want to install cabal-install
13:55:43 <elliott> since most people don't use 7.2
13:55:48 <elliott> admittedly with the platform that's probably less of an issue nowadays
13:56:21 <theddy> Anybody care to comment on how to generate a large sequence of CFloats quickly? Has to be contiguous in memory because I use the pointer in C
13:56:43 <rwbarton> do you care what the values of the CFloats are?
13:56:44 <Cale> theddy: You'll want to use a StorableArray
13:56:47 <theddy> Alloc and pokeElemOff seem to be a bottleneck
13:57:06 <acowley> theddy: Vector.Storable
13:57:59 <Cale> ^^ or that :)
13:58:35 <theddy> Thanks, I'll give those a shot
13:58:46 <luite> elliott: hmm, is that really the reason... that sounds a bit hard to believe...
14:00:07 <mertis> anyone know why im getting an empty list at the end of the output of this function http://snipt.org/Hgnj9
14:00:29 <mertis> checkinbetweens returns a listoflists
14:00:50 <elliott> luite: either that or nobody's bothered yet, especially since 7.2.1 is a preview release :)
14:00:50 <theddy> rwbarton: They are generated using another data structure, it's vertex data for the GPU
14:00:50 <Cale> I kinda think we really need a vertically split hackage which can be used to do some global "phase locking" of package versions.
14:00:53 <luite> elliott: 7.2.2 is out now
14:00:58 <luite> well in the archives at least
14:00:58 <elliott> luite: it is?
14:01:10 <elliott> i know there's a release candidate
14:01:12 <jhance> luite: You just have to patch cabal-install's version
14:01:17 <jhance> dependencies
14:01:31 <parcs> is there a changelog for 7.2.2?
14:01:45 <luite> jhance: I did that once and then ran into a cabal-install bug
14:01:53 <luite> so I installed the new one from the repository and it worked
14:01:54 <rwbarton> theddy: anyways, I was going to suggest storablevector also
14:02:01 <jhance> http://hackage.haskell.org/trac/ghc/browser/docs/users_guide/7.2.2-notes.xml?rev=edbea0b716a105735cc96729ec5ddaaa14c30f83
14:02:04 <jhance> is an xml version of release notes.
14:02:05 <luite> but now the repository contains the 0.14 version
14:02:22 <luite> so how do I get the 0.12 branch?
14:02:22 <Cale> mertis: What is the intention for this code?
14:02:28 <luite> I usually only work with git :(
14:02:41 <rwbarton> but if you're starting with a list or something, probably you will not gain much if anything over pokeElemOff...
14:02:52 <Cale> mertis: did you know that you can match two elements from the beginning of a list like (x:y:xs) ?
14:02:57 <jhance> luite: There's probably a tag? I don't know how to use darcs
14:03:00 <mertis> yea
14:03:06 <jhance> luite: I normally download 0.11 and patch the dep
14:03:26 <mertis> input is a list of waypoints such as
14:03:26 <luite> jhance: me  neither, I already tried darcs tags :p
14:03:41 <mertis> [[1,1,1,1],[4,5,6,7],[5,4,4,3]]
14:03:52 <mertis> interior lists will always have 4 elemenst
14:03:59 <mertis> [lat, long, alt, speed]
14:04:23 <mertis> checkinbetweens decides if any predefined significant points are crossed between 2 waypoints
14:04:25 <Cale> okay, that's a really bad way to represent that data, but fine :)
14:04:26 <jhance> luite: There is some simple patch you can find online that will fix 0.11 to work with 7.2
14:04:30 <mertis> and returns a list of those points
14:04:34 <jhance> luite: Just use that.
14:04:56 <mertis> so the output will be all of the original waypoints, and any significant points that are crossed
14:05:32 <jhance> luite: See [1], which works for all archs, not just Mac OS X 10.7. I think this is in the channel topic, too
14:05:36 <jhance> [1] https://gist.github.com/1169332
14:07:44 * jhance learned to set all packages to include profiling support to avoid having to recompile 90 packages
14:07:56 <Cale> mertis: Okay. Here's how I'd think about it. We have a function f :: a -> a -> [a], and a list xs :: [a], and we want to apply the function f to each pair of adjacent elements of that list, and produce a list like the original one, but with the results of f spliced in between the elements it was applied to, yes?
14:08:15 <mertis> Cale: exactly
14:08:31 <Cale> mertis: So let's forget about the lists of lists, and just worry about this abstractly, taking the function f as a parameter
14:09:27 <Cale> spliceBetween :: (a -> a -> [a]) -> [a] -> [a]
14:10:01 <mertis> Cale: what kind of function is that for a parameter
14:10:02 <Cale> The solution to our problem is then  spliceBetween checkInBetweens
14:10:39 <Cale> It's a function which takes two adjacent elements from our list, and produces a list of elements to splice in between them
14:10:47 <Cale> (in the result)
14:11:07 <jhance> sliceBetween f (x:y:ys) = x:y ++ f x y ++ splitBetween f ys
14:11:09 <mertis> Cale: ok so basically what my checkinbetweens function does
14:11:11 <jhance> should do the trick I think
14:11:28 <mertis> well
14:11:29 <Cale> jhance: except for the two typos ;)
14:11:45 <jhance> Cale: Haha yeah
14:11:45 <Cale> er, and y being in the wrong place
14:12:00 <Cale> and not being in the recursive call ;)
14:12:16 <jhance> Cale: Untested code without a warrantly :)
14:12:23 <jhance> Darn another typo
14:13:17 <luite> jhance: ok just did that, let's see if it works this time :)
14:13:22 <Cale> mertis: Okay, so let's knock out the base cases where there are 0 or 1 elements in the input list. We won't be applying the splicing function in those cases.
14:13:35 <mertis> Cale: alright
14:13:37 <jhance> spliceBetween (x:y:ys) = [x] ++ f x y ++ [y] ++ splitBetween f ys (why does y need to be in the recursive call? Didn't we already chew it up? Or do we have to use each element in two parirs)?
14:13:37 <Cale> spliceBetween f [] = ...
14:13:40 <Cale> spliceBetween f [x] = ...
14:14:01 <jhance> Dang it I typed splitBetween again -.-
14:14:10 <Cale> jhance: because you need to compare y with the element following it using f as well
14:14:49 <jhance> Cale: Oh, okay. So
14:14:51 <jhance> spliceBetween (x:y:ys) = [x] ++ f x y ++ spliceBetween (y:ys)
14:14:55 <Cale> mertis: In these cases, there's not much to do, so our only option is pretty much to produce the input list untouched
14:15:28 <mertis> Cale: like
14:15:46 <mertis> Cale: spliceBetween f [] = []
14:15:46 <mertis> spliceBetween f [x] = [x]
14:15:46 <mertis>  
14:15:46 <mertis>  
14:15:49 <Cale> yes
14:16:03 <jhance> yeah except you should probably make the f a _
14:16:06 <mertis> k
14:16:23 <Cale> I actually dislike _ for some weird reason
14:16:29 <Cale> But it's just personal preference
14:16:55 <jhance> It makes it more clear that you intend for the parameter not to be used though. That's why I like it
14:16:56 <Mitsu> :t read
14:17:00 <lambdabot> forall a. (Read a) => String -> a
14:17:12 <Cale> It does do that, yes
14:17:38 <Cale> Though the code in cases like this is so short that it's easy to see that the parameter is unused
14:17:39 <shachaf> You can start a named parameter with _ for that.
14:17:55 <shachaf> As in f x _y = x
14:18:03 <shachaf> (That disables the GHC warning.)
14:18:11 <Cale> Really, I just dislike _ typographically, I think.
14:18:26 <copumpkin> yeah
14:18:30 <Cale> But anyway
14:18:32 <c_wraith> did that convention come from ML?
14:18:37 <jhance> Yeah it is kind of awkward. At least its not that whole style from OOP where you have to type private members as _stuff
14:18:44 <ski> c_wraith : i'm not sure, but ML has `_' as well, yes
14:18:46 <Cale> I'm trying to explain to mertis
14:19:12 <Cale> mertis: The remaining case is when the list has two or more elements. In this case, we have some work to do:
14:19:14 <Kaidelong> I think prolog patterns also had a wildcard that didn't bind
14:19:21 <Kaidelong> might also have been _
14:19:22 <Cale> spliceBetween f (x:y:xs) = ...
14:19:36 <mertis> Cale: spliceBetween :: (a -> a -> [a]) -> [a] -> [a]
14:19:36 <mertis> spliceBetween f [] = []
14:19:36 <mertis> spliceBetween f [x] = [x]
14:19:36 <mertis> spliceBetween (x:y:ys) = [x] ++ f x y ++ spliceBetween (y:ys)
14:19:36 <mertis>  
14:20:15 <Cale> mertis: that is correct, but did you just steal jhance's code, or did you write that yourself? :)
14:20:32 <Cale> actually, it's not correct
14:20:37 <Cale> But for a trivial reason
14:20:46 <mertis> ok
14:20:47 <rwbarton> suggesting it may be the former
14:20:55 <Cale> (you stole jhance's code, he has the same bug)
14:21:06 <mertis> of course i did
14:21:15 <mertis> :D
14:21:21 <Cale> So let's actually think about it instead of guessing randomly
14:21:33 <mertis> Zamarok:
14:21:34 <Cale> spliceBetween (x:y:xs) = ...
14:21:36 <mertis> k
14:21:42 <Cale> What should the first element of the result be?
14:21:52 <mertis> the first element of the original list
14:21:55 <mertis> so x
14:21:56 <Cale> right
14:21:59 <Cale> spliceBetween (x:y:xs) = x : ...
14:22:01 <ski> Kaidelong : Prolog has `_' as well, yes
14:22:06 <jhance> Don't just steal untested code ;)
14:22:21 <Zamarok> mertis: ?
14:22:23 <ski> Kaidelong : and it's not just patterns -- patterns and expressions are the same thing in Prolog
14:22:29 <mertis> x:checkInBetween x y++spliceBetween (y:ys)
14:22:29 <Cale> After that, we want to have the elements that are being spliced in
14:22:39 <mertis> Zamarok: missclick sorry
14:22:44 <Cale> right, though not checkInBetween
14:22:46 <Cale> f
14:22:54 <Zamarok> mertis: k ;)
14:23:21 <Cale> The point is that we're separating the reponsibility of doing this kind of list operation from the specifics of our problem
14:23:32 <mertis> Cale: ok
14:23:43 <Cale> and in that way, we're eliminating the possibility of a lot of mistakes using the type system
14:23:59 <Cale> Because our more generic list operation has to work on lists of *any* type
14:24:07 <gwern> > log e
14:24:09 <lambdabot>   log e
14:24:10 <mertis> got it
14:24:11 <Cale> and can't secretly rely on operations which involve Floats
14:24:17 <gwern> huh.
14:24:20 <gwern> > log 1
14:24:21 <lambdabot>   0.0
14:24:29 <Cale> > log (exp 1)
14:24:30 <lambdabot>   1.0
14:24:40 <Cale> e is not a prelude definition :)
14:24:56 <erus`> > pi
14:24:57 <lambdabot>   3.141592653589793
14:25:01 <Cale> (pi is)
14:25:04 <gwern> Cale: so we can have pi but not e?
14:25:12 <Cale> We have e as exp 1
14:25:13 <gwern> we're such law-abiding fatties
14:25:22 <Cale> Stealing a one-letter variable name would be evil.
14:25:25 <slack1256> >exp 1
14:25:29 <slack1256> > exp 1
14:25:31 <lambdabot>   2.718281828459045
14:25:33 <rwbarton> e-vil
14:25:38 <wlangstroth> you're forced to derive e from pi
14:25:40 <Cale> e-vil indeed!
14:25:58 <wlangstroth> clearly, there is no other way
14:26:01 <slack1256> no no, e-xperienced
14:26:38 <mertis> Cale: ok then, so how do i incorporate that with what im doing though, the splice function.. moment, updating code
14:26:41 <shachaf> > exp pi
14:26:42 <lambdabot>   23.140692632779267
14:26:50 <shachaf> > exp (0 :+ pi)
14:26:51 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
14:26:59 <slack1256> > exp pi - pi
14:27:00 <lambdabot>   19.999099979189474
14:27:02 <erus`> 1 and a half hours till skyrim
14:27:06 <slack1256> xkcd *wink*
14:27:14 <Cale> mertis: You apply our new operation to your 'checkInBetweens' which presumably has type [Float] -> [Float] -> [[Float]]
14:27:24 <shachaf> slack1256: You should be happy kmc isn't in here right now.
14:27:25 <mertis> Cale: http://snipt.org/Hgnj9
14:27:48 <slack1256> shachaf: why? he hates the webcomic?
14:27:58 <Cale> mertis: oh, lol, don't forget the f in the recursive case
14:28:12 <Cale> (in the parameters)
14:28:21 <Cale> We've been leaving it off
14:28:44 <mertis> Cale: spliceBetween (x:y:ys) = x:f x y++spliceBetween f (y:ys)
14:28:54 <Cale> on the lhs as well
14:29:13 <mertis> spliceBetween f (x:y:ys) = x:f x y++spliceBetween f (y:ys) ?
14:29:17 <Cale> yeah
14:29:52 <shachaf> slack1256: It's more of a culture thing.
14:30:15 <mertis> id paste all my code but, its crazed, and everyone will laugh at my imperative language brain doing haskell
14:30:30 <Cale> shachaf: I don't get it. Maybe I don't know kmc well enough.
14:30:42 <shachaf> Cale: It's more of a #-blah thing.
14:30:45 <Mitsu> mertis: all part of learning :3
14:30:54 <Cale> mertis: okay, so now we have buildSigPointList = spliceBetween checkInBetweens
14:31:09 <Mitsu> I've looked back at old codes I've made and wanted to hit myself for doing stuff like it
14:31:10 <Mitsu> xD
14:31:18 <Cale> Indeed
14:31:18 <shachaf> Ha, ha, look at that imperative language brain doing Haskell!
14:31:24 <shachaf> There, now it's out of the way, so you can @paste your code.
14:32:10 <Cale> He... already did paste his code, I don't know what he's talking about ;)
14:32:26 <Cale> Well, the most relevant part anyway
14:32:32 <mertis> Cale: ok so like
14:32:39 <mertis> Cale: buildSigPointList :: [[Float]] -> [[Float]]
14:32:40 <mertis> buildSigPointList [[]] = []
14:32:40 <mertis> buildSigPointList [[a,b,c,d]] = [[a,b,c,d]]
14:32:40 <mertis> buildSigPointList x = spiceBetween checkInBetweens x
14:32:43 <Cale> no
14:32:50 <Cale> you don't need base cases there now
14:33:11 <mertis> buildSigPointList :: [[Float]] -> [[Float]]
14:33:11 <mertis> buildSigPointList x = spiceBetween checkInBetweens x
14:33:17 <Cale> yeah
14:33:25 <Cale> Except that splice has an l in it
14:33:34 <mertis> indeed it does
14:33:35 <mertis> im scared
14:33:39 <Cale> You can cancel the x from both sides if you want
14:33:42 <mertis> ive been working on this forever
14:33:57 <Cale> (it's just like algebra ;)
14:34:12 <mertis> lulz, it compiled
14:34:14 <mertis> thats good
14:35:19 <Cale> (I've been programming in Haskell for 10 years, you should be more scared if this wasn't easy for me :)
14:35:22 <mertis> alright for those of u who want to see the crazed code of someones first go at anything haskell, here u go
14:35:26 <mertis> http://snipt.org/Hgnj9
14:35:39 <mertis> its not finished
14:35:41 <mertis> but
14:35:44 <mertis> its getting there
14:35:51 <Cale> okay
14:35:58 <Cale> so some general style things...
14:36:14 <Cale> If you're using head or null, it's a sign that you're not pattern matching enough
14:36:35 <Cale> It's never necessary to write x == True
14:36:38 <rwbarton> if you paste to hpaste.org, it will give you lots of good style suggestions
14:36:44 <Cale> Because x == True = x
14:36:53 <Cale> and x == False = not x
14:37:07 <mertis> hmm
14:37:10 <XexonixXexillion> and you shouldn't use magic numbers
14:37:20 <luite> how do you specify more than one --extra-lib-dirs for cabal?
14:37:25 <luite> in the config
14:38:24 <Cale> crossesAlt specifies a bunch of conditions under which something is true, followed by saying that it's false in other cases
14:38:37 <Cale> Can you think of a way to say that sort of thing in English?
14:38:43 <mertis> ok
14:38:47 <mertis> Alt is altitude
14:38:52 <mertis> the 3rd element of the waypoints
14:38:59 <mertis> there are significant altitudes
14:39:05 <mertis> 100,1000, and 10000
14:39:14 <mertis> if i cross one of those planes, between 2 waypoints
14:39:28 <mertis> i need to say so, and output the point in which it does so
14:40:27 <Cale> Okay, rephrase this English sentence for me: If I don't eat my breakfast, then I get hungry is true, if I don't eat my lunch, then I get hungry is true, if I don't eat my dinner then I get hungry is true.
14:40:37 <instinctive> is there a projected release for a ghc 7.2+ haskell platform?
14:40:57 <Cale> (the same thing that is awkward about my sentence is what is awkward about your code ;)
14:41:15 <jhance> instinctive: Never
14:41:49 <rwbarton> it looks like crossesAlt is wrong anyways
14:41:49 <jhance> instinctive: Oh, +. I don't know about 7.4 but its not even out yet so it'll be a bit :)
14:41:54 <mertis> yea i figured there is a better way to do it, but, it was working as far as i could tell
14:42:00 <mertis> maybe its wrong
14:42:01 <jhance> instinctive: 7.2 is just a preview so I doubt there will be a 7.2 platform
14:42:07 <mertis> i wrote it last night at like 2 a.m.
14:42:22 <Cale> mertis: Yeah, this is a point about style that I'm making, though the fact that it does equality tests against Float values is somewhat disconcerting
14:42:38 <instinctive> jhance: thx
14:42:42 <luite> "Next release: July 2011"
14:43:04 <mertis> Cale: the input this program runs with is guaranteed to be lists of floats
14:43:25 <Cale> mertis: In fact, you use one of the possible solutions to the problem inside the conditions that you've already written :)
14:43:39 <Cale> Specifically, you're forgetting about the || operator
14:43:48 <rwbarton> in general crossesAlt is an instance of not saying what you mean
14:44:11 <mertis> Cale: eh?
14:44:19 <rwbarton> you basically said it in English earlier, your Haskell code should match that a lot more closely
14:44:40 <mertis> so instead of 5 lines, i need 1 with ||'s
14:45:12 <Cale> mertis: that would be good, though in fact, now that I see your English description, there's an even better way
14:45:27 <shachaf> curry :: (If I don't eat breakfast and I don't eat lunch then I get hungry.) -> (If I don't eat breakfast then if I don't eat lunch then I get hungry.)
14:45:30 <mertis> Cale: instruct me oh master
14:45:51 <rwbarton> mertis: take a look at crossesLong, can you generalize it?
14:46:17 <shachaf> If I don't eat curry then I get hungry.
14:46:28 <mertis> Cale: rwbarton: i could reduce it to one line
14:47:45 <Cale> mertis: You want to know if x and y lie on opposite sides of one of three points. First of all, we should be able to say  crosses p x y  in order to express the condition that x and y lie on opposite sides of a single point p.
14:48:46 <Cale> Then we should say  any (\p -> crosses p x y) [100,1000,10000]
14:48:51 <mertis> Cale: ok yea that way it makes more sense
14:50:02 <Cale> or we could write   or [crosses p x y | p <- [100,1000,10000]]
14:50:12 <Cale> which is equivalent
14:50:31 <mertis> so i need a crosses function written
14:50:39 <Cale> incidentally, I chose the parameter order incorrectly for this application of crosses
14:50:44 <Cale> the point should be last :)
14:51:09 <rwbarton> then you can't write crossesLong as easily
14:51:18 <Cale> That's true
14:52:00 <DukeDave> Is there something equivalent to ifdef in Haskell? I'd like to provide two definitions of a function depending which version of a library we linked against..
14:52:15 <blackdog> DukeDave: you can use CPP.
14:52:15 <Cale> DukeDave: There's CPP
14:52:16 <jhance> DukeDave: Possibly you could use CPP
14:52:19 <Cale> lol
14:52:25 <jhance> Aww slowest.
14:52:34 <DukeDave> You guys ;)
14:52:40 <blackdog> #haskell, where your questions are answered in majestic ... tristereo?
14:52:48 <DukeDave> CPP, as in the language?
14:52:56 <jhance> DukeDave: No, the preprocessor
14:53:04 <jhance> DukeDave: so you can #ifdef and #include etc
14:53:06 <alistra> DukeDave: man cpp
14:53:08 <mertis> Cale: just simply  crosses :: Float -> Float -> Float -> Bool
14:53:08 <mertis> crosses x y p = x <= p && y >= p
14:53:09 <DukeDave> I did find this: http://stackoverflow.com/questions/6361846/where-can-i-learn-about-ifdef
14:53:12 <Cale> Triskaphonic sound?
14:53:42 <DukeDave> alistra: Thanks
14:53:50 <DukeDave> So can I have GHC call CPP?
14:54:01 <XexonixXexillion> mertis: What about when x is high, and y is low?
14:54:02 <Cale> {-# LANGUAGE CPP #-}
14:54:07 <Cale> at the top of your source file
14:54:15 <Cale> and GHC will run it for you
14:54:31 <blackdog> DukeDave: it's a pretty common technique - you'll see it in the yesod scaffolding, for instance
14:54:33 <mertis> XexonixXexillion: good point
14:55:20 <blackdog> although there are other ways of distinguishing between different libs - you could provide a typeclass
14:55:54 <mertis> ok so
14:55:56 <mertis> crosses :: Float -> Float -> Float -> Bool
14:55:56 <mertis> crosses x y p
14:55:56 <mertis>         |x < y = x <= p && y >= p
14:55:56 <mertis>         |x > y = x >= p && y <= p
14:56:54 <jhance> Yeahhh finally finished recompiling with +profile USE :)
14:57:24 <XexonixXexillion> mertis: what happens if x == y?
14:57:41 <Cale> mertis: use ||
14:58:19 <mertis> .use || for what
14:58:46 <Cale> To combine the cases in which your condition is true
14:59:18 * edwardk waves hello.
14:59:19 <mertis> crosses x y p
14:59:19 <mertis>         |x < y = x <= p && y >= p || x > y = x >= p && y <= p
14:59:23 <mertis> ?
14:59:31 <Cale> don't use guards
14:59:47 <XexonixXexillion> mertis: remove the guard, you don't need to explicity check if x is less then y
15:00:15 <mertis> hmm
15:02:03 <DukeDave> How interesting: I added LANGUAGE CPP, and now its causing the compile to fail on a multiple line string constant :O
15:02:03 <mertis> i guess i dont know how to do it without the gaurds
15:02:35 <XexonixXexillion> mertis: In that case, try it using min and max
15:03:37 <mertis> yea i can use min on x and y and based on that use different logic
15:03:48 <mertis> but i dont understand how to do that not using gaurds
15:04:39 <dylex> DukeDave: yes, that'll happen: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#cpp-string-gaps
15:05:13 <XexonixXexillion> mertis: something like if x is the less than or equal to p, and y is greater than or equal to p, OR x is greater than or equal to p, and y is less than or equal to p
15:05:30 <Kaidelong> since he's returning a Bool
15:05:38 * hackagebot grapefruit-frp 0.1.0.0 - Functional Reactive Programming core  http://hackage.haskell.org/package/grapefruit-frp-0.1.0.0 (WolfgangJeltsch)
15:05:40 <Kaidelong> you probably don't even need an if
15:05:42 <mertis> i can use if? lol
15:06:04 <mertis> oh wait
15:06:06 <DukeDave> dylex: Good link, thanks
15:06:06 <mertis> i think
15:06:07 <mertis> i get it
15:06:49 <Kaidelong> between x y p = min x p == max y p || min y p == max x p
15:07:13 <mertis> crosses :: Float -> Float -> Float -> Bool
15:07:13 <mertis> crosses x y p = (x <= p && y >= p) || (x >= p && y <= p)
15:07:38 <Kaidelong> @hoogle (Ord a) => a -> a -> a -> a
15:07:39 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
15:07:39 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
15:07:39 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
15:07:41 <copumpkin> betwixt x y p = p >= x && p <= y
15:07:43 <copumpkin> :P
15:08:35 * dafis appreciates copumpkin's choice of function name
15:10:40 * hackagebot grapefruit-records 0.1.0.0 - A record system for Functional Reactive Programming  http://hackage.haskell.org/package/grapefruit-records-0.1.0.0 (WolfgangJeltsch)
15:10:42 * hackagebot grapefruit-ui 0.1.0.0 - Declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-0.1.0.0 (WolfgangJeltsch)
15:10:44 * hackagebot grapefruit-ui-gtk 0.1.0.0 - GTK+-based backend for declarative user interface programming  http://hackage.haskell.org/package/grapefruit-ui-gtk-0.1.0.0 (WolfgangJeltsch)
15:10:46 * hackagebot grapefruit-examples 0.1.0.0 - Examples using the Grapefruit library  http://hackage.haskell.org/package/grapefruit-examples-0.1.0.0 (WolfgangJeltsch)
15:15:16 <UpgrayeddAtHome> Hi Haskell dudes, earlier I made my own list type and managed to make it work.  Just trying to understand how type constructors work, and undoing the obfuscation that the special syntax for lists causes.  Then I started thinking...  OK so I had to make a special version of map, ++, foldr, etc for my new list type.  Probably ignore that it's a list, you'll miss the point.  The point is that there's a whole load of standard li
15:15:41 <UpgrayeddAtHome> containing any type, but map only works on haskell lists
15:15:48 <newsham> "whoe load of standard li"<cutoff>
15:15:55 <newsham> ?type fmap
15:16:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:16:08 <UpgrayeddAtHome> for example in c++ with stl I could iterate over anything that supported iteration
15:16:27 <newsham> you can make your custom list an instance of functor
15:16:31 <Cale> UpgrayeddAtHome: In Haskell, you would probably provide a way to turn it into a list ;)
15:16:44 <UpgrayeddAtHome> so my question is, is it possible to somehow adapt standard library functions to work over things that are isomorphic to lists?
15:17:11 <Nimatek> In C++ you'd have to provide an iterator for your own data structures.
15:17:13 <Cale> But there is a class called Foldable which essentially is just that (along with the ability to specially implement a bunch of things)
15:17:14 <newsham> you can dow hat cale said and make a toList conversion
15:17:31 <Cale> UpgrayeddAtHome: Converting something to a list is a generic way to iterate over it
15:17:33 <ski> UpgrayeddAtHome : i think newsham meant that your first message got cut off after ".. The point is that there's a whole load of standard li" -- maybe you would be so kind as to provide the rest of it ?
15:18:17 <newsham> there are lots of different type classes that you can make your data structure a member of to make use of its utilities
15:18:35 <ski> UpgrayeddAtHome : `Foldable' is basically for lists which are isomorphic to lists
15:18:43 <ski> s/for lists/for things/
15:18:43 <UpgrayeddAtHome> how would making my custom list an instance of functor help?  map (for example) takes a haskell list.  I couldn't think of a way to spoof it with something that wasn't, short of converting my whole custom list to a haskell list
15:18:45 <shachaf> Why use a type class when you can use a data type?
15:19:01 <UpgrayeddAtHome> "standard library that only understands lists; it's generic in that say map can work on lists..."
15:19:12 <shachaf> Isn't Foldable more or less equivalent to "has toList"?
15:19:38 <Cale> UpgrayeddAtHome: It's generic in that turning something into a list is exactly the same thing as iterating over it, in general.
15:19:43 <ski> shachaf : yes, that's basically what i meant
15:19:44 <UpgrayeddAtHome> dudes I am kind of a newbie at all of this
15:19:46 <Cale> Because that's what lists are :)
15:19:50 <Nimatek> UpgrayeddAtHome: Make functor. In the case of lists map is equivalent to fmap
15:19:50 <newsham> uah: if you make it a functor you can use any of the libs based on fmap
15:19:52 <UpgrayeddAtHome> so "why x not y" is not so useful...
15:19:55 <shachaf> ski: That's only half of an isomorphism. :-)
15:19:57 <Nimatek> Make it an instance of functor*
15:20:48 <UpgrayeddAtHome> hmm, i suppose lazily, it is not so bad
15:20:53 <ski> shachaf : conceded :)
15:21:18 <Cale> Lists are essentially our loops.
15:21:35 <Cale> A loop either never happens, or it consists of a single iteration followed by another loop.
15:21:44 <UpgrayeddAtHome> i mean in general there is no isomorphism between things, my list type is basically isomorphic, but it's trivial to think of data types that are not; so I knew I would have to point it out to haskell somehow
15:21:53 <Cale> A list is either empty, or it consists of a single element followed by another list.
15:22:18 <Cale> Yeah, you'd write a toList function which converted your structure to a list
15:22:29 <Cale> By traversing over it in some way
15:22:40 <Cale> (there might be more than one way in general to do it)
15:22:40 <Eduard_Munteanu> Hm... is there a generic fromList? Well, preferably one that fuses with toList.
15:22:44 <UpgrayeddAtHome> it's probably missing the point to think about lists right now...  it is just an example, what I was working with
15:23:06 <shachaf> Foldable is a bad class name for toList.
15:23:19 <newsham> uah: are you familiar with Data.Foldable and Data.Traversable ?
15:23:44 <newsham> uah: not entirely missing the point.. you were talking about STL iterables..  lists are kinda like those
15:23:46 <mertis> Cale: ty for the help btw, made good progress, got more stupic crap to figure out with it now
15:23:53 <UpgrayeddAtHome> what I mean is about genericity... if you have an existing function that works basically on pattern matching on a particular type, how can it be adapted to work on a type which is isomorphic in some way... sorry, I am new to Haskell, I don't know the right terms
15:24:37 <UpgrayeddAtHome> newsham: no, but I will research those tomorrow.  gotta let my 5 pints cool down :(
15:24:43 <newsham> "Many of these functions generalize Prelude, Control.Monad and Data.List functions of the same names from lists to any Foldable functor. "
15:24:48 <newsham> from the Data.Foldable documentation
15:24:54 <byorgey> shachaf: I agree. It's quite confusing.  You'd think "Foldable" had to do with catamorphisms but it doesn't; it's actually less expressive.
15:25:41 <byorgey> I didn't realize this when I wrote the Typeclassopedia; I only realized it later when teaching a Haskell course and talking about Foldable after talking about folds... and realizing they were different.
15:26:26 <UpgrayeddAtHome> newsham: yes but lists are irrelevant.  what I am talking about is some sort of second order genericity.  if I am iterating over something in STL, the type of the things is generic of course.  but also the type of the container is generic...  it just has to support iteration.  the fact that it's a list in my example is a red herring, please ignore it
15:27:00 <rwbarton> the way you "support iteration" in haskell, in general, is to provide a function from your type to lists
15:27:06 <Eduard_Munteanu> UpgrayeddAtHome: if you actually have that isomorphism, then you could do   f^-1 . function . f
15:27:08 <rwbarton> For example, say I have a binary tree type Tree a
15:27:20 <newsham> uah: i get that, but i think converting from some arbitrary type to a list is what you are probably asking for.
15:27:34 <rwbarton> I might want to write some "traversal" functions corresponding to in-order or pre-order traversal or whatever
15:27:40 <shachaf> byorgey: Typeclassopedia says that Foldable is for any fold?
15:27:44 <rwbarton> those would just be inOrder, preOrder :: Tree a -> [a]
15:28:24 <rwbarton> then if I want to print the elements of the tree in an in-order traversal, I write mapM_ print $ inOrder t
15:28:48 <rwbarton> so that solves the problem you solved in C++ using iterators
15:29:02 <newsham> iterator is just like a lazy list, no?
15:29:12 <newsham> you get the current element and you can walk to the next element
15:29:37 <newsham> unless you want a zipper perhaps?
15:29:47 <newsham> which lets you move forward and backwards in interating something
15:31:30 <UpgrayeddAtHome> hm... not entirely convinced that the fact my thing is a list is not directing you guys down the wrong path.  on the other hand, it had slipped my mind that haskell is lazy, so converting something into something else is not as bad as it might seem.  so in general, I guess the thing is to deal with whatever standard library function you have, and convert to what it wants
15:32:15 <newsham> uah: seriously, a haskell list is what is often used for iterating.. like cale said "lists are essentially our loops"
15:32:27 <newsham> you woulda got the same answer if you came in asking about yoru fancy trees :)
15:32:53 <newsham> but if you just want is the ability to map a function over a data type, you want fmap
15:32:56 <newsham> and functor
15:33:17 <newsham> or maybe you might want Data.Traversable
15:33:36 <UpgrayeddAtHome> rather than say trying to write some kind of map that could work generically like eol = [] and cons = (:) vs eol = Empty and cons = (:>)
15:33:54 <rwbarton> "deal with whatever standard library function you have, and convert to what it wants" <- yes
15:34:19 <rwbarton> that's not the only option, but it is the most straightforward and it works fine because of lazy evaluation, right
15:34:29 <Eduard_Munteanu> Laziness itself doesn't really save you there.
15:34:38 <blackdog> UpgrayeddAtHome: yes, you won't generally have to have the whole list in memory at any given time (although you can screw your usage pattern up in such a way that you might)
15:34:40 <rwbarton> hmm?
15:34:49 <rwbarton> how about in my example "mapM_ print $ inOrder tree"?
15:34:56 <UpgrayeddAtHome> seriously, iterating is not the point, it is part of my example, but i am talking about genericty here...  i could construct examples that don't involve lists.  but of course much of the standard library takes lists, so there is a large body of code to be reused, and that is kind of a point
15:35:03 <newsham> data MyList a = Nil | Cons a (MyList a);  unMyList f g Nil = f; unMyList f g (Cons x xs) = g x xs;   toList = unMyList [] (:)
15:35:23 <rwbarton> I suppose I only save space linear in the amount of space the tree already consumes
15:35:24 <blackdog> UpgrayeddAtHome: perhaps a concrete example would help.
15:35:24 <Eduard_Munteanu> I should rephrase.
15:35:49 <Eduard_Munteanu> You also need fusion if you want to lose nothing.
15:35:49 <newsham> uah: a lot of genericity comes from type classes, like functor, monad, foldable, traversable, monoid, etc..
15:35:59 <rwbarton> oh, well, sure
15:36:20 <kfish> Upgrayedd, do you want to generically traverse different container structures, or do you want to have an iterator function that can apply various generically-defined functions?
15:36:58 <rwbarton> fusion only gains me some constant factor, though, it's not terribly important
15:37:05 <simon> how do I find out where <+> is defined when I don't know its signature?
15:37:10 <UpgrayeddAtHome> blackdog: lists are a concrete example.  but please don't focus on lists.  say you have a great function that works on a certain type.  you have another type which is (for that function) isomorphic.  can you use the function with your other type somehow?
15:37:17 <newsham> ?hoogle (<+>)
15:37:18 <simon> ah, hoogle can do that too.
15:37:19 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
15:37:19 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
15:37:19 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
15:37:28 <UpgrayeddAtHome> please please please everyone stop focusing on lists / iteration... i am asking about genericity
15:37:37 <rwbarton> not without exhibiting the isomorphism somehow
15:37:52 <rwbarton> (of course, since there may be many choices of isomorphism)
15:37:53 <kfish> UpgrayeddAtHome, i'm asking what you mean by genericity
15:38:05 <newsham> uah: toList/fromList will give you a lot of genericity when composing with list functions :)
15:38:14 <newsham> so you cant completely throw that out :)
15:38:33 <blackdog> UpgrayeddAtHome: that's why i suggested a concrete example of something else
15:38:36 <rwbarton> the question is perhaps about how you exhibit the isomorphism?
15:38:56 <UpgrayeddAtHome> sure, the isomorphism has to be explicit, because there's no automatic isomorphism in general.  but if I could express that isomorphism somehow, how would I do it?
15:38:57 <Eduard_Munteanu> Well... is there a typeclass containing fromList?
15:39:19 <newsham> uah: perhaps consider fmap over binary trees?
15:39:27 <rwbarton> newFunction = greatFunction . theIsomorphism
15:39:32 <UpgrayeddAtHome> i fear that giving you another example will only lead you down the wrong path again
15:39:41 <rwbarton> or possibly  newFunction = theInverseIsomorphism . greatFunction . theIsomorphism
15:39:51 <Eduard_Munteanu> (yeah you can write it separately, that wasn't the point)
15:40:05 <kfish> UpgrayeddAtHome, there's many paths that involve genericity in haskell, which are you on?
15:40:08 <rwbarton> where theIsomorphism :: MyNewType -> TheOriginalType
15:40:14 <kfish> (also they're all fun)
15:40:17 <newsham> uah: i guess what you're saying is there are lots of different ways you might want polymorphism and we're saying the list thing is one of them, and the type classthing is one of them...
15:41:16 <Eduard_Munteanu> UpgrayeddAtHome: the isomorphism here is actually given by fromList and toList, in case your type is isomorphic to lists
15:41:28 <UpgrayeddAtHome> right, so basically it's about converting (lazily, and hopefully inlined somehow) the whole thing explicitly
15:41:28 <UpgrayeddAtHome> which I can deal with, I guess...
15:42:06 <rwbarton> there are some other approaches to generic programming in Haskell which have been alluded to
15:42:13 <UpgrayeddAtHome> I will have to research that.... as I said I am new to Haskell
15:42:35 <newsham> data BinTree a = Leaf | Node (BinTree a) a (BinTree a); unBinTree f g Leaf = f; unBinTree f g (Leaf l x r) = g l x r; toList = unBinTree [] (\l x r -> l ++ [x] ++ r); fmap f = unBinTree Nil (\l x r -> Node (fmap f l) (f x) (fmap f r))
15:42:57 <kfish> UpgrayeddAtHome, yes when you get that far you can completely inline things away
15:43:03 <newsham> now you can map over bin trees, and you can use any list functions to iterate over bin trees...
15:43:32 <kfish> UpgrayeddAtHome, but until then, perhaps read up on fmap, Functors, Data.Traversable, Data.Foldable
15:44:11 <jhance> GHC 7.2's -caf-all doesn't seem to be functioning right... I thought something was wrong so I decided to check my results on the RWH profiling example
15:44:21 <jhance> I get a big black triangle and it won't split up the main cafs
15:44:55 <Tyr42> Hey, I'm having a issue with haskell.org
15:45:03 <UpgrayeddAtHome> are we talking about toList in terms of Foldable?
15:45:12 <Tyr42> if I try and load the site in Opera, it just hangs
15:45:16 <Tyr42> but it works on chrome
15:45:24 <UpgrayeddAtHome> kfish: ok will do
15:45:24 <Tyr42> and I can ping the server
15:45:33 <rwbarton> Foldable is essentially just toList, yes
15:46:15 <newsham> so how come minimal implementation of foldable isnt making toList?
15:46:32 <newsham> (its foldMap or foldr)
15:46:39 <Tyr42> Any idea why it's failing?
15:47:14 <rwbarton> I don't know, obviously I can write either toList or foldr in terms of the other
15:47:35 <Peaker> conal: isn't GHC getting type-level naturals built-in?
15:47:55 <rwbarton> I suppose defining toList in terms of foldr, rather than vice versa, means I don't construct unnecessary cons cells in foldr
15:48:35 <Peaker> rwbarton: ideally the "sufficiently smart compiler" could remove the intermediate cons cells :)
15:49:17 <Peaker> rwbarton: though the problem with the foldr representation is probably somewhat limited recursive patterns (and translating to a list and recursing on that is even more expensive)
15:50:36 <newsham> ghc getting numbers in types?
15:51:25 <conal> Peaker: seems to be -- from a few different directions. i'll be happy to scrap mine.
15:52:33 <UpgrayeddAtHome> hmm well that's a lot to investigate / think about.  Thanks, Haskell dudes...
15:56:50 * conal looks forward to the type-checker knowing that + is associative and that 0 is a right identity.
16:03:09 <dgpratt> conal: I remember once upon a time thinking that'd be cool, but now I can't remember why
16:04:20 <conal> dgpratt: i get stuck on things like statically type-safe reverse for length-typed vectors.
16:05:51 <dgpratt> conal: yeah, that gets me, too
16:07:07 <dgpratt> conal: hey, do you know anything about making a good pie crust?
16:07:29 <conal> dgpratt: nope.
16:07:47 <dgpratt> conal: ok, thanks, feeling just a tiny bit better, now
16:08:30 <shachaf> dgpratt: From scratch? I'm told you must invent the universe, first.
16:08:35 <copumpkin> conal: I wrote that once
16:08:51 <dgpratt> shachaf: :)
16:08:52 <conal> copumpkin: in haskell? agda? ...
16:08:57 <copumpkin> haskell
16:08:58 <copumpkin> and agda
16:09:16 <copumpkin> http://hpaste.org/41453 is the haskell one
16:09:34 <copumpkin> it's foldl (flip (:)) [] hidden behind a pile of newtype noise
16:16:29 <copumpkin> conal: I don't think it's possible to do without the newtypes, sadly
16:16:38 <copumpkin> at least not until we get more flexible type functions
16:16:39 * ddarius usually invents two universes before his coffee in the morning.
16:17:00 <hpc> ddarius: the first universe is for practice, the second is just to find somewhere that makes good coffee?
16:18:38 <conal> copumpkin: wow. tricky.
16:19:19 <ddarius> copumpkin: You should redo it to define foldl in terms of foldr.
16:38:01 <ocharles> copumpkin: do you have the agda version around?
16:41:14 <Eduard_Munteanu> ocharles: there's one in the stdlib
16:42:31 <ocharles> oh, right
16:46:18 <newsham> if I wanted to -ddump-asm, what options can I provide to turn of as much optimizations and rewriting as possible?
16:46:27 <newsham> ie. i want to see the most straightforward translation
16:47:06 <Zamarok> Am I correct in thinking that type Int is faster than type Integer?
16:47:08 <napping> Is -O0 not enoght?
16:47:23 <newsham> i tried that, didnt seem to make too much diff.. though perhaps thats as low as it goes
16:47:24 <Eduard_Munteanu> Zamarok: yeah
16:47:30 <Mitsu> <Zamarok> Am I correct in thinking that type Int is faster than type Integer?
16:48:06 <Eduard_Munteanu> Int is like an 'int' in C.
16:48:14 <mauke> except not
16:48:27 <Eduard_Munteanu> Integer goes through at least some indirection.
16:48:39 <Zamarok> Eduard_Munteanu: by a noticable amount? I am doing number-crunching.. projecteuler problems. I want 'fast', but sometimes I need really large numbers
16:48:40 <napping> How about -ddump-ds?
16:49:03 <jhance> Integer is like a gmp integer
16:49:16 <napping> > :info Integer
16:49:17 <Eduard_Munteanu> mauke has a point
16:49:18 <lambdabot>   <no location info>: parse error on input `:'
16:49:27 <newsham> napping: interesting but not what i'm looking for.
16:49:27 <jhance> And thus it won't be machine level but the compiler will often make an Int a Int#
16:49:37 <newsham> i would like to see simplest asm as possible
16:49:41 <Eduard_Munteanu> It's a boxed integer.
16:49:49 <Mitsu> of course
16:49:51 <napping> newsham: That should show you the minimally desugared form, and you can see if the asm corresponds to it
16:50:08 <Mitsu> maxBound :: Int
16:50:15 <Mitsu> ._.
16:50:23 * Mitsu is going to stick to ignoring lamba
16:50:28 <Mitsu> lambda*
16:50:51 <napping> data Integer = S# Int# | J# Int# ByteArray#
16:50:57 <newsham> napping: it doesnt
16:51:00 <ddarius> @src Integer
16:51:00 <lambdabot> data Integer = S# Int#
16:51:00 <lambdabot>              | J# Int# ByteArray#
16:51:04 <newsham> at least not in a straightforward manner.
16:51:06 <napping> it only promotes to a GMP integer when it overflows
16:51:14 <jhance> Oh neat.
16:51:16 <newsham> also is there a way I can use unboxed Int in my test program easily?
16:51:21 <Eduard_Munteanu> Anyway, there's a bit more work to be done if you go through GMP, no matter how smart it is about optimizing "small" cases.
16:51:25 <Mitsu> <newsham> also is there a way I can use unboxed Int in my test program easily?
16:51:28 <Mitsu> use an Integer
16:51:31 <napping> Core -> STG -> asm?
16:51:44 <newsham> i want to use ghc core type if possible
16:51:51 <newsham> since i'm only trying to watch its translation to asm
16:51:55 <Mitsu> although unless you're looking at using an int greater than 2 billion I don't really think you're going to have a problem..
16:51:55 <Mitsu> lol
16:51:56 <Eduard_Munteanu> Hm.
16:52:06 <newsham> would be ncie if i can get rid of any dictionary lookups for things like "+"
16:52:12 <rwbarton> you can write Int#
16:52:18 <jhance> > something much greater than 2 billion for those of us who use modern machines ;)
16:52:19 <lambdabot>   <no location info>: parse error on input `of'
16:52:20 <ddarius> newsham: You can use unboxed types in your source code.
16:52:45 <newsham> rwbarton: import GHC.Types?
16:52:48 <PiRSquared17> @pl \x -> \y -> y x (y x (x x y))
16:52:48 <lambdabot> ap (ap . flip id) (ap (ap . flip id) (join id))
16:52:56 <Eduard_Munteanu> Would the overflow thingy be implemented as an explicit check, or is it something smarter?
16:53:00 <ddarius> @index Int#
16:53:00 <lambdabot> bzzt
16:53:01 <PiRSquared17> @type join
16:53:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:53:07 <ddarius> @hoogle Int#
16:53:08 <lambdabot> No results found
16:53:31 <PiRSquared17> @hoogle Complex#
16:53:31 <lambdabot> No results found
16:53:33 <PiRSquared17> @hoogle Complex
16:53:33 <lambdabot> Data.Complex data RealFloat a => Complex a
16:53:33 <lambdabot> Data.Complex module Data.Complex
16:53:34 <lambdabot> package complex-integrate
16:53:41 <rwbarton> seems to be GHC.Prim
16:53:41 <Eduard_Munteanu> @google ghc unboxed
16:53:50 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
16:53:50 <lambdabot> Title: 7.2.�Unboxed types and primitive operations
16:54:55 <PiRSquared17> > (sum [0..10]) == (10 * (10+1) / 2)
16:54:57 <lambdabot>   True
16:57:06 <PiRSquared17> > (sum [0..n]) == (n * (n+1) / 2)
16:57:08 <lambdabot>   *Exception: not a number
16:57:41 <PiRSquared17> > map (\n -> (sum [0..n]) == (n * (n+1) / 2)) [0..1000]
16:57:42 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
16:58:00 <PiRSquared17> > fodl (&&) (map (\n -> (sum [0..n]) == (n * (n+1) / 2)) [0..1000]) True
16:58:01 <lambdabot>   Not in scope: `fodl'
16:58:06 <mauke> > head $ filter (\n -> (sum [0..n]) /= (n * (n+1) / 2)) [0..]
16:58:07 <PiRSquared17> > foldl (&&) (map (\n -> (sum [0..n]) == (n * (n+1) / 2)) [0..1000]) True
16:58:08 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:58:08 <lambdabot>         against inferred type ...
16:58:09 <lambdabot>   mueval-core: Time limit exceeded
16:58:14 <PiRSquared17> > foldl (&&) (map (\n -> (sum [0..n]) == (n * (n+1) / 2)) [0..1000]) True
16:58:15 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
16:58:15 <lambdabot>         against inferred type ...
16:58:34 <PiRSquared17> > head $ filter (\n -> (sum [0..n]) /= (n * (n+1) / 2)) [0..]
16:58:37 <lambdabot>   mueval-core: Time limit exceeded
16:59:17 <Eduard_Munteanu> Zamarok: anyway, you could just stick to Integer for correctness, and profile if the need for speed arises.
16:59:31 <Eduard_Munteanu> The bottleneck could very well not be there.
16:59:45 <jhance> Zamarok: Criterion it!
17:00:03 <newsham> cant seem to use "Int#" in my decls even though I import GHC.Exts and GHC.Prim.
17:00:13 <newsham> do I need some flag to allow use of those types in my src?
17:00:16 <rwbarton> oh, also -XMagicHash
17:00:17 <mauke> you need more magichash
17:00:55 <c_wraith> without that flag, # is treated as an operator
17:01:06 <Eduard_Munteanu> Also you can't just replace Int with Int# everywhere.
17:01:20 <rwbarton> right, that extension just makes # one of the valid characters in identifiers
17:01:23 <newsham> i'm trying to use ==# and +# and *# too
17:01:44 <jhance> note that Int is defined as I# Int# so would using Int# instead of Int have any effect
17:02:08 <rwbarton> @src Int
17:02:08 <lambdabot> data Int = I# Int#
17:02:13 <rwbarton> it's a data
17:02:37 <jhance> rwbarton: But the # on the I indicates we can expect it to be strictified to an unboxed type anyway, I think
17:02:45 <Zamarok> Eduard_Munteanu: thanks, I will
17:02:49 <rwbarton> you can hope but in general it will not be
17:02:59 <rwbarton> the I# is the "box"
17:03:00 <newsham> -XMagicHash was what i wanted
17:03:08 <Eduard_Munteanu> I# is just a name, no?
17:03:15 <jhance> Eduard_Munteanu: Yes
17:03:17 <rwbarton> strictness analysis might allow GHC to remove the boxing
17:03:27 <rwbarton> it's not "just a name" like with newtypes
17:03:33 <napping> more like worker/wrapper and specconstr, but yeah
17:03:51 <rwbarton> a value of type Int# is really an integer, a value of type Int could be _|_ for example
17:03:57 <napping> well, you need strictness to enable that
17:04:04 <Eduard_Munteanu> Nah, I meant the '#' in I# doesn't make it special.
17:04:08 <rwbarton> oh, right.
17:04:28 <jhance> I'm pretty sure strictness analysis will usually kick in :\
17:04:43 <jhance> It just doesn't seem right to litter the code with Int#'s everywhere
17:04:46 <rwbarton> so in other words, you agree that Int and Int# are different. :P
17:05:00 <newsham> ok, how do I make an "Int#" constant :)
17:05:03 <rwbarton> 3#
17:05:14 <PiRSquared17> > \x->map
17:05:14 <lambdabot>   Overlapping instances for GHC.Show.Show
17:05:15 <lambdabot>                              (t -> ...
17:05:23 <PiRSquared17> > map
17:05:24 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
17:05:24 <lambdabot>    arising...
17:05:28 <jhance> yes I agree they are _different_; I never said otherwise. However I believe that in most cases where it is
17:05:30 <jhance> allowed by strictness we can expect them to act the same after optimization
17:05:34 <rwbarton> (and yeah, I'm not entirely sure why newsham wants Int#, or whether what he is trying to do will work...)
17:05:34 <PiRSquared17> > map id []
17:05:36 <lambdabot>   []
17:05:45 <PiRSquared17> > map f []
17:05:46 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:05:46 <lambdabot>    `SimpleReflect.FromExpr ...
17:06:06 <Eduard_Munteanu> Working with unboxed stuff also allows you to make direct conversions.
17:06:34 <Eduard_Munteanu> like 32-bit to 16-bit etc
17:06:48 <napping> newsham: it's hard to tell, but I thin -O0 is compiled straighforwardly
17:07:18 <napping> at least if you read about the STG intermediate language and it's operational reading
17:07:49 <napping> Huge and unreadable, certainly
17:07:57 <rwbarton> so is putting a field in a data constructor of the form {-# UNPACK #-} !Int the same as putting in a field Int#?  Am I allowed to do the latter?
17:08:51 <Eduard_Munteanu> You can't use Int# like it was a regular one.
17:09:19 <rwbarton> oh, right
17:10:25 <newsham> ed: i'm not trynig to.
17:10:31 <rwbarton> so if I write {-# UNPACK #-} !Int, then the Int will be stored right in the data as 4 or 8 bytes, but when I pattern-match it out, GHC will make a box for the resulting value?
17:10:32 <newsham> but i would like to know how to make an "Int#" constant
17:11:05 <rwbarton> newsham: like this: 3#
17:11:06 <Eduard_Munteanu> rwbarton: that's one downside to unboxing strict fields indiscriminately
17:11:26 <newsham> danke
17:11:27 <Eduard_Munteanu> The unboxing/reboxing might offset any gains.
17:11:44 <rwbarton> I see.
17:12:07 <Eduard_Munteanu> Well, I'm not sure if just pattern-matching does that, but I guess it has to rebox at some point if you pass it into other code expecting boxed stuff.
17:12:35 <rwbarton> Well, if it's a data type I created, pattern-matching is the only way I can get it out
17:12:45 <rwbarton> (aside from derived instances or whatever)
17:13:22 <rwbarton> oh, you mean, ... I see.
17:13:28 <Eduard_Munteanu> Yeah, though I'm unsure what happens if, e.g., you add two strict fields like that.
17:13:51 <wavewave> hi
17:13:52 <Eduard_Munteanu> Does addition work straight on unboxed values, or does reboxing happen before passing them to (+)
17:13:57 <rwbarton> something like case myData of Foo x -> "hello" won't need to make a box
17:14:29 <Eduard_Munteanu> wavewave: hi
17:14:34 <rwbarton> I could also use an Int# field and manage the boxes myself, right?
17:14:43 <rwbarton> if I was so inclined for some reason?
17:15:10 <lpsmith> In all fairness, ghc will try to optimize boxing/unboxing away as much as possible.
17:15:55 <rwbarton> sure (and in the application I have in mind, I care a lot about memory usage in the data but not at all about the cost of reboxing since that code is doing stuff like printing the value)
17:16:14 <Eduard_Munteanu> rwbarton: AFAIR yes, but then you have to use primops to do any real work
17:16:26 <rwbarton> or I can use I# myself
17:16:49 <lpsmith> I mean,  I haven't looked at the source code of split recently,  but IIRC a few versions back (6.8?) a simple version without dealing with Int# was actually a little bit faster than the hacky version using Int#
17:19:37 * wavewave wondered I# as a new language for a millisecond
17:19:42 <Eduard_Munteanu> rwbarton: yeah, it looks like it works just fine to do stuff like   data PartlyBoxedData = D Int# Int Int#
17:19:57 <mauke> wavewave: yeah, it's INTERCAL for .Net
17:20:13 <Eduard_Munteanu> erm, that name is misleading
17:21:18 <rwbarton> I'd think if I wrote something like   case d of D x y z -> x + z  then ghc could inline the pattern match on I# ((I# a) + (I# b) = I# (a +# b)) and avoid creating the extra boxes
17:21:30 <newsham> http://www.thenewsh.com/~newsham/x/machine/fac.hs
17:22:01 <rwbarton> because first you'd have   case d of D x' y z' -> let { x = I# x' ; z = I# z' } in x + z
17:22:40 <rwbarton> er, where the first D is defined by D {-# UNPACK #-} !Int Int {-# UNPACK #-} !Int
17:24:47 <ocharles> Does -XScopedTypeVariables allow me to use a type variable from a function type signature inside a function defined in the 'where' part of a function? That is, I have a type signature 'Something a => a', and later want to do: where something = unProxy (proxyValue :: Proxy a)
17:24:54 <ocharles> (hopefully that makes sense?)
17:25:29 <ocharles> can provide a minimal paste if not
17:25:35 <rwbarton> yes, but you need to write the outer type signature as forall a. Something a => a to enable it for that function
17:25:44 <ocharles> ah, that's what I was missing!
17:25:45 <Eduard_Munteanu> I guess so. At least, unboxing strict fields isn't just a time-space tradeoff, it's also faster in some cases.
17:25:47 <ocharles> always gets me
17:26:13 <wavewave> ocharles: yes.. that's somewhat difficult rule to remember.
17:26:19 <wavewave> forall rule.
17:26:22 <ocharles> rwbarton: and what provides forall? -XRankNTypes?
17:26:38 <rwbarton> I assume -XScopedTypeVariables does...
17:26:50 <Eduard_Munteanu> ExplicitForall something, IIRC, if not that extension
17:26:58 <ocharles> hrm, I'm getting malformed class assertion, but that's presumably my fault
17:27:02 <ocharles> time to stfu and rtfm
17:27:15 <ocharles> thanks :)
17:28:15 <wavewave> ocharles: you can ask us about some detail of the errors you get.
17:30:17 <ocharles> sure, but in this case it was just me putting the forall inside parenthesis with my type classes, but it's meant to be outside
17:30:29 <ski> heh
17:30:37 <ocharles> which makes sense, now that I think about it
17:30:44 <ski> (that would mean a completely different thing)
17:30:51 <ocharles> yep
17:31:29 <wavewave> like this ? (forall a. SomeClass a) =>
17:31:41 <ocharles> yea, that's what I first tried
17:32:00 <ocharles> forall a. (SomeClass a) => is obviously what I mean, because the scope of a is more than just the constraints :)
17:32:12 * ski wouldn't expect that to be accepted, but maybe recent GHC's have been allowing more cool things :)
17:32:21 <ocharles> no, it's malformed syntax
17:32:25 * wavewave is thinking that (forall a. SomeClass a) => can now mean something with new ConstraintKind
17:32:32 * ski would write that as `forall a. SomeClass a => ..a..', though
17:32:44 <ocharles> ski: multiple classes in my actual code
17:32:54 <ski> wavewave : possibly, yes, if quantifiers are allowed there
17:33:09 <ocharles> i'm doing (what to me is) insanely cool HaskellDB abstraction stuff :)
17:33:11 <ski> ocharles : and to nitpick, s/classes/class constraints/ :)
17:33:29 <ocharles> yes, i know, in bed laptop typing makes me lazy :)
17:33:45 <wavewave> especially it may make sense with two type variables. (forall b. SomeClass a b) =>
17:34:03 <ocharles> first bit of playing with type families too, they are quite fun
17:34:25 <wavewave> ocharles: yeah. type families are indispensible.. ;-)
17:34:29 <ocharles> (especially when you combine them with type classes)
17:34:42 <ocharles> now that this stuff is starting to click, it's making my jaw drop at just how much can be asserted at compile time
17:35:05 <wavewave> ocharles: also try GADTs. ;-D
17:35:20 <ocharles> I know of them, but haven't got round to needing them myself yet
17:35:29 <ocharles> sure when I do, that'll be the aha-moment though :)
17:35:52 <ocharles> so to me, the examples feel a little contrived (but of course, they aren't)
17:35:52 <hpc> ocharles: functional dependencies are pretty similar to type families too; you might like to check those out
17:35:54 <wavewave> ocharles: you can think of GADTs as a type-level pattern matching..
17:36:24 <Eduard_Munteanu> ocharles: didn't you ask about Agda earlier? If you tried it, then Agda's data is a lot like GADTs.
17:36:29 <ocharles> hpc: yea, I've used them a bit, though it seems like they are pretty close to type families?
17:36:49 <ocharles> Eduard_Munteanu: yep, but my Agda experience is only half way through one of the tutorials :)
17:37:02 <hpc> ocharles: in most cases, there's a direct translation from one to the other
17:37:12 <ocharles> I know generally what a GADT is and how it differs to Haskell 98s ADTs, but I don't fully understand the motivation yet
17:37:16 <ocharles> and why I need that extra bit of power
17:37:39 <Eduard_Munteanu> Vec would be a simple example of a GADT there... or should I say indexed families.
17:37:48 <hpc> ocharles: it's great for embedded DSLs
17:37:49 <wavewave> it makes your type carries an information of your data.
17:38:14 <wavewave> ocharles: you can think it as some kind of tag
17:38:25 <wavewave> Expr  becomes Expr a
17:38:28 <ocharles> Eduard_Munteanu: oh cool, I've written Vec, but got so caught up in the awesomeness of having it depently typed, I didn't realise part of that coolness was from GADTs
17:39:00 <ocharles> are there any haskell papers that are a good introduction to gadts?
17:39:02 <hpc> data Header; data Body; data Document; data HTML a where doc :: HTML Header -> HTML Body -> HTML Document
17:39:03 <wavewave> and a is different for the content of Expr
17:39:08 <ocharles> is there a paper that motivated the gadt extension?
17:39:11 <hpc> ^ is another example
17:39:54 <Eduard_Munteanu> Dunno, this looks alright... http://haskell.org/haskellwiki/GADT
17:40:13 <ocharles> hpc: and with just H 98 you can only have doc :: HTML a?
17:40:55 <PiRSquared17> @type id
17:40:55 <lambdabot> forall a. a -> a
17:40:58 <PiRSquared17> @type const
17:40:59 <lambdabot> forall a b. a -> b -> a
17:41:00 <Eduard_Munteanu> Yeah, with GADTs the constructors get to pick type indices
17:41:05 <PiRSquared17> @type ap
17:41:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:41:22 <PiRSquared17> @pl \x -> \y -> \z -> x z (y z)
17:41:22 <lambdabot> ap
17:41:26 <Eduard_Munteanu> Actually with H98 you can only have doc :: ... -> HTML a
17:41:32 <PiRSquared17> @type ap ap ap
17:41:33 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
17:41:33 <lambdabot>     Probable cause: `ap' is applied to too few arguments
17:41:33 <lambdabot>     In the second argument of `ap', namely `ap'
17:41:38 <ski> s/doc/Doc/
17:41:41 <PiRSquared17> @type ap ap id
17:41:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
17:41:42 <lambdabot>       Expected type: m a
17:41:42 <lambdabot>       Inferred type: m (a -> b)
17:41:49 <PiRSquared17> @type ap const const
17:41:50 <lambdabot> forall b. b -> b
17:41:55 <Eduard_Munteanu> Oops, right.
17:41:56 <hpc> ocharles: yes; and i should have written "Doc" there
17:42:23 <hpc> ocharles: you can have a constructor "Doc :: HTML a", but then you have to have "doc = Doc :: blahblah -> HTML Document"
17:42:29 <wavewave> ocharles: Depending on data constructor, you can have different concrete type of a in Html a.
17:43:01 <wavewave> ocharles: you can think that as inserting concrete type value into generic type variable a.
17:43:02 <newsham> blah, optimizer is still inlining lotsa stuff before generating cmm or asm
17:43:42 <ocharles> interesting
17:43:48 <wavewave> ocharles: I am using GADTs as a kind of sessions.
17:44:15 <wavewave> if my task is roughly divided as A or B.
17:44:40 <newsham> oh, i can just not include main and it wont have anything to inline with
17:44:59 <wavewave> all the function related A will have an explicit A type dep..
17:45:15 <wavewave> but generic interface will be just Expr a
17:45:49 <wavewave> then I can catch some bug using a B function for A task.
17:45:55 <Eduard_Munteanu> (comparing to Agda, it's like when you have type parameters on the right hand side of ':' in the data declaration)
17:47:27 <wavewave> initiation of a session must be GADT in this case.
17:47:46 <ski> Eduard_Munteanu : hehe, i typically prefer to write that in Haskell as `data HTML :: * -> * where ...', since the `a' in `data HTML a where ...' is quite useless
17:48:50 <wavewave> I hope that some time we will have Generalized GADT in haskell from agda.
17:49:42 <snappy> win 29
17:49:53 <hpaste> ocharles pasted “HaskellDB abstraction stuff” at http://hpaste.org/53884
17:50:03 <ocharles> anyway, this is what I was working on with type families and scoped types
17:50:11 <ocharles> bit messy type signatures, but those can be cleaned up
17:50:42 <ocharles> Proxy/unProxy is the only way I can see to write coreEntityField, which is the messiest
17:51:14 <ocharles> it would be nicer if I could provide a value to it and have the type inference figure it out, but I don't think I have a value that I can use
17:51:38 <wavewave> ocharles : you can use data keyword for data family
17:51:51 <wavewave> ocharles: if you need injective mapping
17:51:51 <ocharles> is this a data family? :) I couldn't tell the difference
17:52:12 <wavewave> type family does not guarantee 1-1 mapping
17:52:14 <ocharles> I just know the type of constructCoreEntity differs for each CoreEntityRecord instance
17:52:27 <wavewave> data family guarantees it.
17:52:44 <ocharles> ah. not sure if I need that or not yet
17:52:56 <wavewave> ocharles: I do not know if your case is with that though
17:53:56 <wavewave> just sounds like need for Proxy may be related to it
17:55:00 <wavewave> anyway, Proxy solution does not look bad.
17:55:12 <ocharles> it works, and the only stuff it makes messy is internal anyway
17:55:41 <wavewave> some kind of tagging type may be relevant.
17:56:06 <wavewave> since you actually don't need internal structure of Proxy type anyway..
17:56:14 <ocharles> how would that look?
17:57:28 <wavewave> ocharles: I cannot make it right now.. but my feeling is that you need relations between types basically.
17:58:27 <wavewave> ocharles: first see 'tagged' package by ekmett
17:58:47 <wavewave> s/ekmett/edwardk
17:58:49 <ocharles> ah
17:58:57 <ocharles> yes, this looks like it will be good reading
17:59:31 <wavewave> in fact, Tagged is the same as your Proxy ;-P
17:59:35 <ocharles> yea :)
18:01:56 <ocharles> oh, completely different question now, TH this time
18:02:12 <ocharles> I have: field "RevisionID" "revisionId" "rev_id" [t|Ref (Revision Book)|]
18:02:23 <ocharles> is there anyway to replace "Book" with a type variable?
18:02:40 <Eduard_Munteanu> ski: oh interesting, I didn't know kind signatures let you omit variables like that...
18:02:43 <ocharles> I tried literally replacing it with 'a' and then I get the error: Not in scope: type variable `a'
18:03:22 <c_wraith> ocharles: make it in scope then...  try [t| forall a. Ref (Revision a) |]
18:03:28 <ocharles> tried that
18:03:33 <ocharles> Illegal polymorphic or qualified type:
18:03:33 <ocharles>       forall a[a2F7s]. Ref (Revision a[a2F7s])
18:03:43 <ocharles> (Try -XImpredictiveTypes)
18:03:51 <ocharles> oh wait, that's somewhere else...
18:03:57 <c_wraith> huh.  does TH not let you create polymorphic type signatures?
18:04:05 <ski> c_wraith : possibly ocharles doesn't want the `forall' at that position
18:04:07 <wavewave> forall outside ?
18:04:09 <ocharles> oh wait, it is on that line
18:04:25 <ocharles> field "RevisionID" "revisionId" "rev_id" [t|forall a. Ref (Revision a)|] gives the above error
18:04:54 <wavewave> how about doing forall where a must be defined first?
18:04:58 <c_wraith> ski: Well...  hard to have it scoped at a different level with stage restrictions
18:05:05 <wavewave> like type signature of function
18:05:14 * ski understood what ocharles wanted to do as merely wanting to parameterize the definition, not to do some higher-rank or impredicative thing
18:05:37 <ski> c_wraith : what is this `field' function supposed to generate ?
18:05:48 <ski> maybe i should ask ocharles that, actually
18:05:50 <ocharles> this is using chris done's haskelldb helper stuff
18:05:52 <ocharles> I'll get a link to that
18:06:16 <ocharles> http://chrisdone.com/posts/2011-11-06-haskelldb-tutorial.html and http://hpaste.org/53595 for the definition of field
18:06:40 <c_wraith> ocharles: looks like it works for me...
18:06:41 <c_wraith> Prelude Language.Haskell.TH> :set -XScopedTypeVariables
18:06:42 <c_wraith> Prelude Language.Haskell.TH> runQ [t| forall a. Maybe a |]
18:06:42 <c_wraith> ForallT [PlainTV a_0] [] (AppT (ConT Data.Maybe.Maybe) (VarT a_0))
18:07:53 <c_wraith> must be something about the scoping of the type variable, if it's talking about impredicative typing
18:08:08 <ski> c_wraith : i'm still unsure ocharles really wants that, though
18:08:30 <c_wraith> well, if it's talking about impredicative typing, it sounds like that type expression is being used *inside* another one
18:09:14 <ocharles> http://hpaste.org/53595#line74 yes, it appears it is
18:09:35 <zzo38> I put a username/password in the cabal configuration file but it won't go. Did I do it wrong?
18:09:56 <ocharles> I don't think I can do what I want with that function, because of it prepending some stuff before the TypeQ is added
18:10:27 <ski>         -> TypeQ -- ^ Defines: varName :: Attr TypeName ColType
18:10:31 <ski> this means that
18:10:39 <ski>   field "RevisionID" "revisionId" "rev_id" [t|forall a. Ref (Revision a)|]
18:10:42 <ski> would define
18:10:59 <zzo38> It says "You can store your Hackage login in the ~/.cabal/config file" but that doesn't seem to work.
18:11:19 <ocharles> ski: yea, that's why I think the current function as it stands can't do what I want
18:11:20 <ski>   revisionId :: Attr RevisionID (forall a. Ref (Revision a))
18:11:22 <zzo38> Actually it is "F:\Documents and Settings\user\Application Data\cabal\config" it says that underneath, and that is the correct file. But it doesn't work
18:11:27 <c_wraith> zzo38: prod dcoutts, and see if he's helpful :)
18:11:36 <ski> which is indeed an impredicate type, and is probably now what ocharles want
18:11:45 <ocharles> ski: right ,which is different to :: forall a. Attr RevisionID (Ref (Revision a))
18:11:50 <ski> indeed
18:12:08 <c_wraith> ocharles: is there a type variable in the type?
18:12:20 <ocharles> c_wraith: which is "the type"?
18:12:20 <c_wraith> ocharles: are are you trying to create some sort of existential?
18:12:36 <c_wraith> oh, I see
18:12:43 <c_wraith> this isn't a field of a larger structure, it's just a value
18:12:54 <c_wraith> and you want it to be polymorphic
18:13:08 <ocharles> yes, that sounds right
18:13:08 <ski> i think ocharles probably really wants to define `data RevisionID a = ...' with `revisionId :: forall a. Attr (RevisionID a) (Ref (Revision a))'
18:13:25 <ocharles> ski: yep
18:13:44 <ocharles> again, I think :) I'm just kinda hacking stuff together atm, because TH is new to me
18:13:53 <ocharles> and HaskellDB too
18:14:00 <ocharles> too many new things at once and I get a bit lost, heh
18:14:51 <ski> ocharles : i think the `[]' in `dataDef = DataD context typeName [] constructors derives' says that it defines `RevisionID' with no parameters
18:14:59 <ocharles> correct
18:15:08 <ocharles> I think I see enough of the problem now to start working on fixing it
18:15:08 <ski> so, you'll probably want to attempt to modify that, to also accept parameters
18:15:13 <ocharles> yea
18:15:28 <zzo38> dcoutts seem not answering my questions either.
18:15:36 <c_wraith> zzo38: he's probably asleep
18:15:48 <c_wraith> zzo38: it is like 2 in the morning there
18:16:07 <zzo38> Yes, it is. I just tried checking his time, and that is what it is, 2:26
18:16:14 <zzo38> Do you know the answer?
18:16:17 <c_wraith> no
18:27:08 <zzo38> I figured out how to do it. It need "hackage-username" instead of "username" as the field.
18:34:45 <Sgeo|web> Well, that was interesting
18:34:59 <Sgeo|web> I was talking about Haskell in another channel, where someone just started learning Haskell
18:35:19 <Sgeo|web> I say some list comprehension, but get it wrong and don't realize it
18:35:43 <Sgeo|web> The person who is just now learning Haskell, I don't think has reached list comprehensions yet, and was able to correct me due to the legibility of the error
18:36:03 <shachaf> I don't think list comprehensions aren't a very important part of Haskell.
18:36:27 <Philippa> also, if you've met set comprehensions elsewhere they're pretty obvious
18:36:49 <mike-burns> Harsh crowd tonight.
18:37:02 <wavewave> hm
18:37:12 <Sgeo|web> "ok so this syntax is familiar from math, it means the set of all things for which these conditions hold"
18:38:16 <dmwit> Sgeo|web: Nice! Go Haskell for being awesome!
18:38:41 <shachaf> [x | x `notElem` x]
18:39:10 <Sgeo|web> shachaf: That can't typecheck, can it?
18:39:21 <Sgeo|web> > null [x | x `notElem` x]
18:39:21 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
18:39:21 <lambdabot>         against inferre...
18:39:34 <Sgeo|web> > null [xyzzy | xyzzy `notElem` xyzzy]
18:39:35 <lambdabot>   Not in scope: `xyzzy'Not in scope: `xyzzy'Not in scope: `xyzzy'
18:39:46 <Sgeo|web> Oh, darn
18:40:00 <Sgeo|web> > let xyzzy = xyzzy null [xyzzy | xyzzy `notElem` xyzzy]
18:40:01 <lambdabot>   not an expression: `let xyzzy = xyzzy null [xyzzy | xyzzy `notElem` xyzzy]'
18:40:06 <Sgeo|web> > let xyzzy = xyzzy in null [xyzzy | xyzzy `notElem` xyzzy]
18:40:09 <lambdabot>   mueval-core: Time limit exceeded
18:40:17 <Sgeo|web> ...huh
18:40:32 <wavewave> let x = x in x
18:40:37 <wavewave> > let x = x in x
18:40:40 <lambdabot>   mueval-core: Time limit exceeded
18:41:04 <Sgeo|web> wavewave: But `elem` should for the type of xyzzy to not equal itself
18:41:10 <Sgeo|web> So it shouldn't typecheck
18:41:14 <Sgeo|web> At least, imo
18:41:18 <wavewave> it shouldn't.
18:41:54 <Sgeo|web> s/for/force/
18:44:04 <Sgeo|web> > undefined `elem` undefined
18:44:04 <lambdabot>   *Exception: Prelude.undefined
18:44:22 <Sgeo|web> > let x = undefined in x `elem` x
18:44:23 <lambdabot>   *Exception: Prelude.undefined
18:44:25 <Sgeo|web> Uh
18:44:42 <Sgeo|web> Does it think it's an infinite list?
18:44:49 <mauke> > join elem
18:44:49 <wavewave> > elem undefined undefined
18:44:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:44:50 <lambdabot>   *Exception: Prelude.undefined
18:44:55 <shachaf> What would it being an infinite list have to do with it?
18:45:01 <shachaf> It's instantiating it to two different types.
18:45:21 <Sgeo|web> It's instantiating the same x to two different types?
18:45:31 <dmwit> > (\x -> [x | x `notElem` x]) undefined
18:45:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:45:40 <dmwit> You happy now, Sgeo|web?
18:45:49 <Sgeo|web> dmwit: why wasn't it doing that with the let?
18:45:57 <dmwit> Sgeo|web: Because lets are polymorphic.
18:46:32 <shachaf> > (\x -> x `elem` x) undefined
18:46:33 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:46:35 <dmwit> When you write "undefined `notElem` undefined", it's using *two different undefined's*.
18:46:35 <shachaf> > ((\x -> x `elem` x) :: (forall a. a) -> Bool) undefined
18:46:36 <lambdabot>   *Exception: Prelude.undefined
18:46:54 <shachaf> dmwit: Well, the same undefined instantiated to two different types. :-)
18:47:12 <dmwit> Yeah, we don't have syntax for type application.
18:47:16 <dmwit> So things can get a bit confusing.
18:47:28 <dmwit> But it's using undefined@a and undefined@[a].
18:47:42 <dmwit> Which I would call "two different undefined's", but many wouldn't.
18:47:50 <shachaf> @?
18:47:55 <dmwit> Type application.
18:48:54 * shachaf looks up, finds documents on Content-Type: application/*
18:49:16 <dmwit> You know how "f x" is the application of "f" to "x"?
18:49:32 <dmwit> Well, that's term application. Some languages have syntax for applying terms to types.
18:49:36 <dmwit> That's type application.
18:49:57 <dmwit> And, in particular, the way you use a "forall" type is by first applying it to another type to choose which particular monomorphic version you want.
18:50:24 <shachaf> Ah, I see.
18:50:29 <dmwit> Since "undefined :: forall a. a", to actually use it, you should first apply it to a monomorphic type (say, Int, or String, or [b]). But the application is implicit in Haskell -- it's all inferred.
18:51:04 <shachaf> In Agda you have it explicitly, as in id : (A:Set) -> A -> A, right?
18:51:27 <dmwit> Yes, though Agda does have some implicit parameters, I think.
18:51:33 <dmwit> I'm not an Agda expert, though.
18:53:38 <rwbarton> I have a Vector and I want to update one entry in it.
18:54:14 <rwbarton> What do I have to do to make sure the old Vector isn't referenced by the new Vector?
18:55:07 <shachaf> So you want to copy the whole vector except for one element?
18:55:12 <rwbarton> right
18:55:28 <rwbarton> but I don't want the old vector to be lying around afterwards
18:55:45 <shachaf> Why would it be?
18:55:48 <rwbarton> (assume it's not being used by anything else)
18:56:32 <rwbarton> well, I could imagine that the updated entry is a thunk of the form "updated (oldVector ! i)"
18:56:53 <shachaf> Oh, I see.
18:58:00 <rwbarton> Maybe I need to think more about my evaluation strategy here...
18:58:09 <shachaf> Hmm, that's tricky, actually.
18:58:41 <rwbarton> (basically, I'm trying to insert a bunch of entries into a trie where the pointers to the children are stored in a vector)
18:59:05 <shachaf> You could just force the whole thing, I suppose.
18:59:34 <rwbarton> yeah, I might want to force the new child anyways... need to think about that.
19:00:42 * hackagebot sednaDBXML 0.1.2.5 - Sedna C API XML Binding  http://hackage.haskell.org/package/sednaDBXML-0.1.2.5 (EricJones)
19:02:15 <shachaf> rwbarton: Or maybe you just want a strict/unboxed vector?
19:02:33 <rwbarton> an unboxed vector of trie nodes?
19:02:59 <shachaf> Oh, I misunderstood.
19:05:53 <rwbarton> There's also this interesting operation "modify"
19:06:06 <rwbarton> "Apply a destructive operation to a vector. The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise."
19:06:52 <rwbarton> How does it know whether it's safe?
19:07:37 <shachaf> Huh, that's an odd operation.
19:10:42 * hackagebot gps 0.8.3 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8.3 (ThomasDuBuisson)
19:12:50 <rwbarton> hey copumpkin, maybe you can answer my vector questions
19:13:07 <copumpkin> I can certainly try :)
19:13:26 <rwbarton> one thing I want to do is grow a vector and set the newly created entries to a certain value
19:13:43 <rwbarton> what's the best way to do that?
19:14:19 <rwbarton> grow + slice + set?
19:15:00 <copumpkin> hmm, that's actually one area where repa gives you more flexibility
19:16:06 <rwbarton> well if there isn't an easy way, that's fine, my vectors are tiny anyways so performance of this operation won't matter
19:16:17 <rwbarton> I was just curious whether I was missing a more convenient way to do it
19:16:43 <rwbarton> my actual question is: how does the "modify" function work?
19:17:15 <rwbarton> How does it know whether it can modify the vector in place?
19:17:21 <shachaf> That wasn't your question a moment ago. :-)
19:17:38 <rwbarton> well, true :)
19:17:51 <copumpkin> rwbarton: hmm, substructural typing!
19:17:55 <rwbarton> I figured out a little more about what I want to do since then, though
19:18:39 <copumpkin> rwbarton: I think the only times it won't make a copy is if you pile up consecutive calls to modify
19:18:47 <copumpkin> then it'll perform them on the same buffer
19:19:02 <shachaf> Oh, it's just a fusion thing?
19:19:08 <copumpkin> yeah
19:19:11 <rwbarton> consecutive meaning at the source level? ok
19:19:22 <copumpkin> modify p = new . fancyModify p . clone
19:19:29 <copumpkin> so if you string together new and clone, it'll erase them
19:19:35 <rwbarton> got it.
19:21:14 <rwbarton> OK, so suppose I have a Vector Int and I want to increment the value in position i
19:21:32 <rwbarton> btw it's a boxed vector (because in my actual application it's not a Vector Int)
19:22:23 <rwbarton> is there any especially idiomatic way to go about that? In particular I want to make sure that I don't reference the entire old vector
19:26:13 <byorgey> shachaf: sorry I missed your question earlier.  I don't remember precisely what Typeclassopedia says about Foldable.  I just know it doesn't make the distinction between Foldable and folds in general very clear.
19:27:17 <PiRSquared17> Typeclassopedia?
19:28:43 <ion> @where typeclassopedia
19:28:44 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:28:58 <ion> Recommended reasing.
19:29:01 <ion> d
19:29:45 <copumpkin> kfish: your secret trading strategy was on that notepad in the photo on G+
19:29:52 <copumpkin> and you can download the full-sized photo
19:30:06 <kfish> copumpkin, yup
19:30:09 <kfish> pen and paper ftw
19:30:10 <PiRSquared17> ion: Didn't know about that thank you!
19:30:39 <copumpkin> kfish: just figured I'd warn you before I implemented the strategy first and stole all your profits
19:31:33 <shachaf> copumpkin: Surely you're going to be implementing them on the BTC market?
19:32:20 <copumpkin> nah, his secret formulas only apply to a different market
19:32:39 <shachaf> Oh, I see.
19:32:43 <copumpkin> I have already analyzed them, improved them, and have made 4 million in the time since I warned him
19:32:55 <shachaf> copumpkin: Just makin' the market more efficient, eh?
19:33:03 <kfish> copumpkin: the resulting code is in this patch: https://github.com/kfish/zoom-cache/commit/51f18d10f08053ebf76f353fc319edbc3bc76a24
19:33:06 <copumpkin> I prefer to call it scalping
19:33:19 <kfish> let me know how you go :)
19:33:30 <copumpkin> kfish: yeah, but I can see through the paper to the sheet under it!
19:33:35 <copumpkin> with my super 'shop skillz
19:33:47 <kfish> kewl :)
19:34:10 <shachaf> copumpkin: Like, whoa, man, now that you mention it, that picture *does* have some pixels.
19:34:42 <copumpkin> you know the enhance software they use in CSI?
19:34:44 <copumpkin> I wrote it
19:34:51 <copumpkin> I can see between the paper fibers
19:34:57 <kfish> does g+ preserve the original picture? that'd be like 8 megas or something
19:35:03 <kfish> mostly dog hair
19:35:16 <copumpkin> kfish: it was large, but not that large
19:35:31 <copumpkin> I also found a picture of kfish in the reflection on the highlight of his coffee cup
19:36:35 <kfish> stalker alert
19:37:02 <copumpkin> lol
19:39:01 <powoire> does anyone do game programming with haskell?
19:39:13 <shachaf> The answer is, "Yes!"
19:39:20 * shachaf abuses commas.
19:39:31 <Clint> ,
19:39:38 <kfish> powoire, do you mean "anyone who's here and awake" or "anyone in the world"? :)
19:39:53 <uucico> why might ghci tell me "module is not loaded: `Foo' (./Foo.hs)", with no other errors, when i try to "import Foo"?
19:40:14 <shachaf> uucico: You can't really import source files in ghci.
19:40:22 <shachaf> Try :load foo, or running "ghci Foo".
19:40:35 <powoire> I was looking in to this lanauge...  I would prefer using an IDE and a compiler instead of console method when it comes to writing programs.
19:40:54 <shachaf> Not a lot of work is put into that, though there is some.
19:40:55 <uucico> ah, :load, thanks!  (what an intuitive error message.)
19:41:07 <PiRSquared17> Lekash powoire
19:41:24 <PiRSquared17> http://www.haskell.org/haskellwiki/Haskell_IDE
19:41:24 <shachaf> Yes, there exists a project claiming to be a Haskell IDE.
19:41:34 <powoire> I'll check it out.
19:41:37 <prem_> hi
19:41:38 <shachaf> What do you want from an IDE in particular?
19:41:41 <Clint> IDEs are like games
19:41:57 <kfish> and what kind of game do you want to write?
19:41:58 <prem_> i want to learn haskell
19:42:08 <powoire> Well.. the ability to highlight syntax, a key or a command to compile it to an exe, and then to run.
19:42:12 <shachaf> prem_: The Haskell FAQ will probably help. :-)
19:42:16 <powoire> I think that's about it for now.
19:42:21 <PiRSquared17> prem_ You want to learn you a Haskell?  http://tryhaskell.org too
19:42:23 <kfish> hi prem_
19:42:29 <shachaf> @where faq
19:42:29 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
19:42:36 <shachaf> powoire: Most good text editors will highlight syntax.
19:42:43 <kfish> @where lyah
19:42:43 <lambdabot> http://www.learnyouahaskell.com/
19:42:47 <prem_> good mornong kfish
19:43:21 <shachaf> powoire: Honestly, you're probably going to be spending some time in a console-ish thing as you learn/use Haskell anyway.
19:43:34 <shachaf> A REPL is very helpful for this, and for Haskell even more than for some other languages.
19:44:35 <powoire> Yeah that's what I was afraid of.. I'm normally just a person that writes programs in a txt file and then compile it.
19:44:53 <powoire> thanks for the info
19:45:19 <shachaf> powoire: Why are you afraid of it? :-)
19:45:44 <Jafet> Perhaps because they're coloured black.
19:45:56 <powoire> I'm not just used to writing code in a console line but I'll still look in to it.
19:46:19 <powoire> sort of like what BASIC on the apple computer used to be.
19:46:20 <Jafet> And named "cmd.exe".
19:47:19 <wavewave> I entirely program in emacs and compile and run... almost no interpreter.
19:47:51 <PiRSquared17> Is there a download of GHC for Mac which doesn't make you download Xcode?
19:48:08 <shachaf> PiRSquared17: I doubt it, because GHC probably uses tools that are included therein.
19:48:26 <PiRSquared17> Is there a way to get Xcode w/o creating an account?
19:48:56 <shachaf> I don't know. I've never gotte Xcode.
19:49:34 <wavewave> run vmware and install linux there? ;-P
19:50:14 <PiRSquared17> Would the Windows version work under Wine?
19:50:20 <PiRSquared17> (for Mac)?
19:51:15 <haldean> Look into homebrew
19:51:27 <haldean> I know I installed haskell-platform via homebrew
19:51:35 <haldean> And I never paid for xcode
19:51:43 <wavewave> gcc can be installed using homebrew?
19:51:56 <PiRSquared17> gcc should be downloadable from gnu.org
19:52:20 <haldean> I think you have to install it first
19:52:29 <stepcut> xcode is on the OS install DVD
19:52:33 <haldean> Homebrew is source code based
19:52:44 <haldean> Not binary packages
19:53:01 <wavewave> yeah, in fact i am using it now
19:53:18 <PiRSquared17> Is it legal?
19:53:31 <wavewave> yes.
19:53:36 <wavewave> it's just open-source.
19:53:48 <PiRSquared17> GPL?
19:53:49 <wavewave> the name sounds hackish though.
19:54:03 <wavewave> mainly GPLed packages I guess.
19:54:29 <haldean> It's a package manager -- the software on it has to be open source but could have any license.
19:55:05 <PiRSquared17> Download where?
19:55:19 <wavewave> @google homebrew mac os x
19:55:20 <lambdabot> http://mxcl.github.com/homebrew/
19:55:20 <lambdabot> Title: Homebrew — MacPorts driving you to drink? Try Homebrew!
19:55:33 <wavewave> there
19:55:43 * hackagebot husk-scheme 3.4 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.4 (JustinEthier)
19:56:33 <PiRSquared17> "Illegal variable name."
19:56:39 <wavewave> ?
19:56:42 <PiRSquared17> When I run "/usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)""
19:56:53 <PiRSquared17> Is that bash, tcsh, csh, ... ?
19:58:24 <wavewave> do you have curl?
19:58:29 <PiRSquared17> What???
19:58:45 <wavewave> type 'curl' in your terminal
19:58:53 <PiRSquared17> curl: try 'curl --help' or 'curl --manual' for more information
19:59:03 <wavewave> okay.. you have it
19:59:23 <haldean> What about "ruby --help"?
19:59:57 <ion> Try downloading https://raw.github.com/gist/323731 and running ruby /path/to/script
20:00:03 <PiRSquared17> It gives me a list of ... something
20:00:27 <PiRSquared17> command line switches?
20:00:36 <shachaf> What are you trying to do?
20:00:58 <PiRSquared17> Install homebrew, to install GHC
20:01:00 <wavewave> shachaf: he is trying to install homebrew
20:01:14 <wavewave> PiRSquared17: anyway, you probably need Xcode
20:01:41 <shachaf> Why are you trying to ruby -e that?
20:01:52 <PiRSquared17> https://github.com/mxcl/homebrew/wiki/installation
20:02:05 <shachaf> It looks like you'd want to -- oh.
20:02:11 <shachaf> Weird.
20:02:15 <wavewave> homebrew is ruby-based package manager
20:02:37 <wavewave> btw, mac has ruby by default?
20:02:48 <PiRSquared17> I think so
20:03:04 <wavewave> why not haskell? ;-/
20:03:19 <PiRSquared17> No idea
20:03:32 <PiRSquared17> Why not gcc to compile GHC?
20:04:12 <shachaf> PiRSquared17: ?
20:04:19 <PiRSquared17> ?
20:04:24 <wavewave> ?
20:04:27 <mm_freak> PiRSquared17: because GHC is not written in C?
20:04:47 <mm_freak> frankly i don't understand how anyone can write a compiler for any language in C
20:04:55 <PiRSquared17> But how do I install Homebrew?
20:04:59 <copumpkin> mm_freak: that's just cause you're not l33t enough
20:05:04 <copumpkin> mm_freak: a sufficiently smart programmer
20:05:08 <wavewave> probably, he wants to say why not gcc as a default in mac os x..
20:05:08 <copumpkin> would not have these issues
20:05:23 <PiRSquared17> wavewave: exactly
20:05:23 <mm_freak> copumpkin: yeah, that sounds reasonable
20:06:31 <PiRSquared17> So ...
20:06:42 <mm_freak> i'd probably scream in pain every two lines of C code i write
20:06:53 <PiRSquared17>   usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"
20:06:58 <mm_freak> that's what i do with PHP anyway
20:07:10 <PiRSquared17> On-topic: help?
20:07:30 <wavewave> just type curl -fsSL https://raw.github.com/gist/323731
20:07:42 <mgccl> How does Haskell do dynamic programming without side effects?
20:08:03 <PiRSquared17> brew_ Command not found
20:08:08 <PiRSquared17> _ -> : sorry
20:08:11 <shachaf> mgccl: Is that a question-answer pair? :-)
20:08:18 <wavewave> curl -fsSL https://raw.github.com/gist/323731 > script
20:08:24 <shachaf> "How does Haskell do dynamic programming?" "Without side effects."
20:08:54 <wavewave> and run   " ruby script"
20:09:10 <PiRSquared17> unless badlibs.empty?
20:09:12 <PiRSquared17>   warn "The following *evil* dylibs exist in /usr/local/lib"
20:09:13 <PiRSquared17>   puts "They may break builds or worse. You should consider deleting them:"
20:09:15 <PiRSquared17>   puts *badlibs
20:09:16 <PiRSquared17> end
20:10:09 <wavewave> PiRSquared17 : add  > script  after the curl statement as above, then you will have 'script' file in your directory
20:10:14 <smoofra> question: if i have something with a weird type like this  (MyClass a b) => b , is there any way to actually *use* it?  how do you supply the instance if you can only bind types to b?
20:10:15 <mgccl> shachaf: lol, I meant usually dynamic programming requires an array, but how to do it if one want to stay pure.
20:10:24 <PiRSquared17> wavewave: Which directory?
20:10:28 <wavewave> PiRSquared17 : then run   "ruby script"
20:10:35 <mm_freak> mgccl: there is nothing impure about an array =)
20:10:39 <wavewave> just current directory
20:10:50 <shachaf> mgccl: I don't think dynamic programming has anything to do with arrays.
20:10:58 <mm_freak> mgccl: though for dynamic programming in haskell you would usually use other data structures
20:11:02 <blackdog> mgccl: stuff an array full of closures and robert is your mother's brother.
20:11:12 <PiRSquared17> I need root password for that ...
20:11:22 <rwbarton> normally I use arrays when doing dynamic programming in Haskell
20:11:30 <wavewave> PiRSquared17 : oh...
20:11:34 <rwbarton> as blackdog describes
20:11:57 <wavewave> PiRSquared17 : you don't have an admin previllage for your machine?
20:12:02 <mm_freak> i find myself using Map/Set/Seq/[]
20:12:07 <mm_freak> and sometimes Vector
20:12:10 <PiRSquared17> wavewave: ! :(
20:12:29 <smoofra> the weid thign is haskell seems to let me make something with that kind of type
20:12:36 <smoofra> but i can't find any way to actually evaluate it
20:13:04 <wavewave> PiRSquared17 : in fact, homebrew can be installed without admin previllage, but installing gcc or xcode may be tricky..
20:13:04 <rwbarton> smoofra: right, you can't use it
20:13:11 <rwbarton> unless MyClass has a functional dependency from b to a
20:13:11 <PiRSquared17> !!!
20:13:15 <PiRSquared17> I give up
20:13:31 <wavewave> so you do not have?
20:13:31 <rwbarton> I thought that newer ghcs will stop you from defining values with such types
20:13:59 <mm_freak> rwbarton: undefined?
20:14:01 <PiRSquared17> wavewave: homebrew, GHC, GCC, Xcode
20:14:07 <smoofra> rwbarton: it wouln't have a dependency.  the particular exmaple i was thinking of is an algorithm that's polymorphic in the kind of array it uses internally
20:14:16 <PiRSquared17> ^^ I have none now.
20:14:24 <rwbarton> undefined does not have any context
20:14:44 <rwbarton> smoofra: right, somewhere somebody has to make that choice...
20:14:51 <wavewave> PiRSquared17: no, I am asking if you do not have admin previllege.
20:15:01 <smoofra> yea i thought there would be some way to "pass" it the choice
20:15:16 <rwbarton> you can add a proxy argument or use a Tagged type
20:15:33 <rwbarton> but there's no direct way to do "type application"
20:15:41 <mm_freak> smoofra: it's also common to pass a value solely for its type
20:15:51 <smoofra> yea thats the workaround i've got right now
20:16:08 <smoofra> i guess thats a somewhat normal thing to do then?
20:16:14 <smoofra> what is a Tagged type?
20:16:15 <wavewave> PiRSquared17: if you don't, ask you administrator to install ghc, that may be the fastest way.
20:16:16 <rwbarton> there are a few variants on the Tagged idea, but yeah, that's pretty much your only option
20:16:23 <mm_freak> smoofra: that's how the base library does it anyway, see for example the 'floatRadix' function
20:16:24 <PiRSquared17> wavewave: Je n'ai pas de root prvs
20:16:24 <wavewave> s/you/your
20:16:26 <mm_freak> :t floatRadix
20:16:26 <rwbarton> something like   data Tagged a b = Tagged b
20:16:27 <lambdabot> forall a. (RealFloat a) => a -> Integer
20:16:35 <mm_freak> > floatRadix (undefined :: Double)
20:16:36 <lambdabot>   2
20:16:43 <rwbarton> or newtype rather
20:16:44 <PiRSquared17> I don't have an admin
20:16:54 <PiRSquared17> > sum
20:16:54 <smoofra> oh ok, so a Tagged b is just a b that carries info about a in its type?
20:16:54 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
20:16:54 <lambdabot>    arising from a use of...
20:17:26 <rwbarton> right, so that you can specify the variable a by using your function at a particular type, then throw away the Tagged constructor to get at the value within
20:17:45 <rwbarton> it's semantically cleaner than passing an argument which is ignored
20:17:56 <smoofra> yea  i like that better
20:18:11 <ion> Some code using Tagged (and incidentally floatRadig too). https://gist.github.com/1188115
20:18:16 <smoofra> thanks!
20:18:19 <rwbarton> I think there may be a semi-standard implementation floating around somewhere, yeah
20:18:57 <ion> It seems today’s a typo day.
20:19:00 <smoofra> one more question: is there any way to define a polymorphic function in a picewise-by-type way without using Typeable?
20:19:11 <shachaf> ion: Every day is typo day in #haskell!
20:19:30 <rwbarton> that's what type classes do, isn't it?
20:19:32 <wavewave> piecewise-by-type way?
20:19:45 <mgccl> oh I see, after looking into it the array is actually functional, interesting...
20:19:48 <ion> Strongly typoed
20:19:52 <wavewave> ad hoc polymorphism?
20:20:01 <mm_freak> smoofra: do you mean partial type signatures?
20:20:01 <smoofra> yea ad hoc polymorpism
20:20:03 <smoofra> exactly
20:20:11 <smoofra> er, i dunno what's a partial type signature
20:20:17 <wavewave> smoofra: that's typeclass
20:20:40 <smoofra> well, yea but lets say that for some reason i don't want to use a typeclass
20:20:46 <mm_freak> smoofra: type classes or existential types
20:20:48 <smoofra> i just want foobar :: forall a. a
20:20:57 <rwbarton> well Typeable is itself a type class
20:20:59 <PiRSquared17> > take 1000 (map (join (*)) [0..])
20:21:00 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
20:21:07 <smoofra> and i want it to be defined for Int and Char, and anything else it jsut rraises an undefined exception
20:21:17 <ion> > map (^2) [0..]
20:21:18 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
20:21:24 <mm_freak> smoofra: that's not possible…  there is only one value of type forall a. a
20:21:26 <PiRSquared17> > take 1000 (map (join (+)) [0..])
20:21:27 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:21:30 <mm_freak> and that's the undefined value
20:21:42 <PiRSquared17> > take 1000 (map (join (^)) [0..]) -- Tetrate by 2 ?
20:21:43 <lambdabot>   [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611...
20:21:48 <wavewave> smoofra: what's wrong with foobar :: (SomeClass a ) => a ?
20:21:56 <mm_freak> smoofra: you need either to require some information about 'a' (context) or receive information about 'a' (existential type)
20:22:22 <wavewave> instance SomeClass Int   where ...
20:22:41 <rwbarton> you could use overlapping/incoherent instances
20:22:51 <PiRSquared17> > take 1000 (map (join (^)) [0..]) -- Tetratation by 2; i.e., ^{x}{2}
20:22:51 <rwbarton> (but then you'd be a bad person)
20:22:52 <lambdabot>   [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611...
20:23:07 <smoofra> mm_freak: i understand the first option, but not the second
20:23:15 <smoofra> how do you receive information about 'a'
20:23:18 <wavewave> smoofra: for Typeable, anyway you need foobar :: (Typeable a )=> a
20:23:35 <PiRSquared17> > take 1000 (map (join (^)) [0..]) -- Tetratation by 2; i.e., ^{2}{x}
20:23:36 <lambdabot>   [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611...
20:23:49 <rwbarton> PiRSquared17: haskell is a pure language
20:23:56 <PiRSquared17> rwbarton: I know ...
20:24:04 <rwbarton> so why do you keep entering the same thing
20:24:17 <PiRSquared17> Typo in comment
20:24:19 <smoofra> wavewave: right, if it's typable then i can grab a TypeRep and examine that and return cast <appropriate value>
20:24:24 <PiRSquared17> :p
20:24:26 <rwbarton> ...
20:24:27 <mm_freak> smoofra: the equivalent of Monoid would be:  data MyMonoid = forall a. MyMonoid (a, a -> a -> a)
20:24:30 <shachaf> Haskell can trace its lineage way back, not like those mutt languages.
20:24:50 <codemac> how do I handle these cabal install issues? I'd like to install cabal-dev
20:24:57 <codemac> but it fails on some containers version
20:25:14 <wavewave> smoofra: hmm.. I do not understand why you prefer more complicated and uglier method...
20:25:30 <codemac> I seem to not know how to uninstall, update, or much of anything with cabal
20:25:31 <mm_freak> smoofra: don't need the tuple actually…  my bad habit from arrows =)
20:26:05 <rwbarton> I like how OverlappingInstances doesn't imply FlexibleInstances.
20:26:14 <smoofra> wavewave: the point of the question is mostly just to fill in gaps in my understanding of the type system, not to re-invent classes
20:26:38 <mm_freak> smoofra: in any case, i think a type class is fine here…  the existential type is really for the cases the /receiver/ shouldn't know what type the value is of
20:26:55 <mm_freak> smoofra: otherwise you can also do something like:  f :: a -> (a -> a -> a) -> a
20:27:01 <mm_freak> that's basically:  f :: Monoid a => a
20:27:57 <wavewave> smoofra: okay. your original question was 'is there a way of ad hoc polymorphism without using Typeable".. and you do not want to use typeclass.. then the answer is no.
20:28:33 <mm_freak> wavewave: i'd count a higher order function to be ad hoc-polymorphic in a certain sense
20:28:55 <smoofra> mm_freak: yea but not in the particular way i mean it
20:29:11 <wavewave> mm_freak: but no way to look into a type.
20:29:12 <PiRSquared17> @type foldr1
20:29:13 <smoofra> i mean literally, is there any way to define an object of type forall a. a that actually does something
20:29:13 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:29:20 <mm_freak> the ($) function is the canonical example for ad hoc polymorphism in haskell without type classes…  its meaning totally depends on the arguments =)
20:29:21 <PiRSquared17> @type foldr1 (^)
20:29:22 <lambdabot> forall a. (Integral a) => [a] -> a
20:29:28 <PiRSquared17> @type ($)
20:29:29 <lambdabot> forall a b. (a -> b) -> a -> b
20:29:48 <PiRSquared17> @pl ($)
20:29:48 <lambdabot> id
20:29:58 <mm_freak> smoofra: there is really little difference between specifying a class vs. specifying the operations
20:30:07 <rwbarton> smoofra: no
20:30:29 <rwbarton> not counting unsafePerformIO I suppose
20:30:43 * hackagebot statistics 0.10.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.0.0 (BryanOSullivan)
20:30:43 <smoofra> hah
20:30:45 <wavewave> oh yeah.... all mighty unsafePerformIO
20:30:47 <smoofra> yea not counting that
20:30:52 <mm_freak> smoofra: in C++ by choosing a particular class you choose the operations…  instead of specifying the class you can just as well specify the operations
20:31:08 <rwbarton> then you can only write undefined/error "foo"/an infinite loop
20:31:12 <PiRSquared17> > take 1000 (map (join (join ^)) [0..]))
20:31:12 <lambdabot>   <no location info>: parse error on input `)'
20:31:14 <wavewave> or FFI ;-)
20:31:16 <codemac> is there a good guide on cabal I can look into?
20:31:19 <PiRSquared17> > take 1000 (map (join (join ^)) [0..])
20:31:20 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Real.Integral (m (m a)))
20:31:20 <lambdabot>    arisin...
20:31:26 <mm_freak> smoofra: and as said, there is only one valid value of type forall a. a
20:31:29 <mm_freak> and that's undefined
20:31:34 <mm_freak> (or anything equivalent)
20:31:36 <PiRSquared17> @tpye join
20:31:36 <lambdabot> Maybe you meant: time type
20:31:41 <PiRSquared17> @type join
20:31:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:31:46 <PiRSquared17> @type join ^
20:31:47 <lambdabot> parse error (possibly incorrect indentation)
20:31:50 <PiRSquared17> @type join (^)
20:31:50 <lambdabot> forall a. (Integral a) => a -> a
20:32:07 <mm_freak> smoofra: that also makes sense…  it would be totally illogical to have any defined value of that type
20:32:08 <PiRSquared17> > map (join (^)) [0..]
20:32:08 <lambdabot>   [1,1,4,27,256,3125,46656,823543,16777216,387420489,10000000000,285311670611...
20:32:16 <wavewave> mm_freak : I am confused about your statement on higher order function and ad hoc polymorphism.
20:32:23 <PiRSquared17> @type (join (join ^))
20:32:24 <lambdabot> forall (m :: * -> *) a. (Monad m, Num (m a), Integral (m (m a))) => m (m a) -> m a
20:32:33 <PiRSquared17> @type (foldr1 (join ^))
20:32:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
20:32:35 <lambdabot>       Expected type: m (m a)
20:32:35 <lambdabot>       Inferred type: m a
20:32:35 <wavewave> mm_freak : I think that's parametric polymorphism. isn't it?
20:32:38 <PiRSquared17> @type (foldr (join ^))
20:32:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
20:32:39 <lambdabot>       Expected type: m (m a)
20:32:39 <lambdabot>       Inferred type: m a
20:33:03 <mm_freak> wavewave: ad hoc polymorphism chooses an implementation based on the type, right?
20:33:45 <wavewave> mm_freak : let's pin down to ($) case...
20:34:01 <smoofra> yea, like in python  you would just examine the type and then return a value based on that
20:34:04 <mm_freak> wavewave: instead of fixing types, you could also leave them polymorphic and specify operations instead
20:34:11 <smoofra> but in haskell you cant examine the type unless its Typeable
20:34:15 <rwbarton> in python you wouldn't have a type to examine
20:34:16 <mm_freak> that's basically what ($) does
20:34:17 <rwbarton> in the case of forall a. a
20:34:30 <mm_freak> ad hoc polymorphism at the value level, basically
20:34:40 <smoofra> rwbarton: forall a.a is the only type python has!
20:34:46 <mm_freak> i think that's haskell's way of expressing it anyway
20:34:46 <shachaf> rwbarton: Because it would be non-terminating?
20:34:57 <rwbarton> shachaf: no, because it's "overloaded on the return type"
20:34:57 <shachaf> smoofra: No, Python has a huge sum type.
20:35:05 <shachaf> Oh.
20:35:20 <rwbarton> Unless you implement that by passing an argument which is the type you expect to get out, in which case it would work.
20:35:24 <mm_freak> wavewave: nothing formal here, it's just my interpretation, since haskell has no real "overloading"
20:35:46 <smoofra> shachaf: but i can add new types at runtime, you you can't say it's a particular sum type
20:36:10 <rwbarton> = ... | SmoofrasType String Dict | ...
20:36:44 <rwbarton> or maybe your "types" are indexed by objects (IORefs), but anyways you can always subsume them into a big sum
20:36:53 <shachaf> = ... | Smoofra'sType String Dict | ...
20:36:54 <wavewave> mm_freak : hmm. I see your point but I think that behavior is still reserved for 'parametric' polymorphism.
20:37:08 <mm_freak> wavewave: the point i'm trying to make is that you get overloading by having multiple implementations for a single type…  you get that through subtyping, for example
20:37:13 <mm_freak> haskell has no subtyping
20:37:17 <rwbarton> oh right, I can use that ' character :)
20:37:36 <wavewave> mm_freak: yeah.. I understand why you said so now..
20:37:43 <shachaf> I wonder whether there exists a reasonable language that lets you use spaces in identifiers.
20:37:48 <smoofra> mm_freak:  isn't Int -> Int a subtype of (Num a) => a -> a
20:37:48 <shachaf> In a non-awkward way, I mean.
20:38:05 <mm_freak> smoofra: no, but the types unify
20:38:29 <mm_freak> smoofra: there is a difference between specialization and subtyping
20:38:31 <wavewave> mm_freak: in my interpretation, you are explaining how one can implement subtyping (ad hoc polymorphism in oop) in terms of parametric polymorphism and dictionary map.
20:38:36 <smoofra> what's the difference between "a unifys with b resultsing in a" and "a is a a subtype of b"
20:38:47 <mm_freak> smoofra: where something of type A is expected, you can pass a value of type A or any subtype of it
20:39:41 <smoofra> oh i guess i have the co/contravarice backwards
20:39:52 <smoofra> Num a => a -> a is substitutable for Int -> Int
20:39:58 <smoofra> so really it's the subtype
20:39:59 <mm_freak> in haskell there are no subtypes…  so if you expect Int, then Int is the only thing you'll get…  but you get type variables in haskell
20:40:52 <smoofra> mm_freak: so what is happening when something gets made-less-polymorphic-than-it-really-is
20:40:53 <mm_freak> you find the same difference in OO languages with inheritance:  generics vs. class inheritance
20:41:05 <mm_freak> in the latter case you are dealing with concrete types, not type variables
20:41:15 <_ralts> @pl \x -> x
20:41:15 <lambdabot> id
20:41:56 <PiRSquared17> @pl \x -> x const ap
20:41:56 <lambdabot> flip ($ const) ap
20:42:00 <mm_freak> smoofra: it's really the difference between type variables and subtyping:  if what you showed were subtyping, you could add an Int to an Integer
20:42:06 <PiRSquared17> @pl \x -> \y -> x
20:42:06 <lambdabot> const
20:42:13 <PiRSquared17> @pl \x -> \y -> \z -> x z (y z)
20:42:14 <lambdabot> ap
20:42:24 <PiRSquared17> @pl \x -> x const ap
20:42:24 <lambdabot> flip ($ const) ap
20:42:43 <smoofra> mm_freak: i can't add an Int to an Integer, but i can add it to a Num a => a
20:42:52 <mm_freak> smoofra: that's what happens when an addition function in an OO language expects two objects of class Num
20:42:52 <smoofra> and Num a => a in't an Int
20:43:07 <mm_freak> smoofra: Num myAdd(Num x, Num y)
20:43:10 <PiRSquared17> (flip ($ const) ap) combinator alone forms iota: Turing complete
20:43:47 <PiRSquared17> *untyped iota -> Turing complete ?
20:43:52 <mm_freak> smoofra: the key difference is that Num is now a concrete type!
20:43:56 <rwbarton> mm_freak: this is not the kind of example I think smoofra is thinking of
20:43:56 <mm_freak> that's subtyping
20:44:42 <rwbarton> but something more like "id $ 'x'"
20:45:16 <smoofra> mm_freak: i guess the distinction is that the literal 1 isn't the same actual object as the 1 :: Int
20:45:23 <mm_freak> rwbarton: i think smoofra is asking about the difference between subtyping and unification
20:45:27 <rwbarton> hmm, this is not the best possible example
20:45:42 <rwbarton> let { y :: Char; y = id $ 'x' }
20:46:17 <rwbarton> we see that whatever 'id' is, it's a function of type Char -> Char
20:46:32 <rwbarton> now actually I have this function 'id' which has type forall a. a -> a
20:46:42 <rwbarton> but (Char -> Char) /= (forall a. a -> a)
20:46:54 <wavewave> the confusion is from there are two levels : a set of values = type , a set of types = typeclasses.
20:47:05 <rwbarton> this question has nothing to do with type classes
20:47:13 <wavewave> subtyping is type-to-type relation.
20:47:20 <rwbarton> just parametric polymorphism
20:47:33 <mm_freak> it's really just:  in subtyping any subtype of A can unify with A, where A is a concrete type, not a type variable
20:47:34 <shachaf> A type class isn't a set of types in the same way that a type is a set of values.
20:47:38 <mm_freak> in haskell only A can unify with A
20:48:07 <smoofra> mm_freak: but forall a. a -> a can unify with Int -> Int
20:48:08 <wavewave> shachaf: yes. it's sub category  basically.
20:48:14 <wavewave> in Hask category
20:48:23 <mm_freak> smoofra: because 'a' is a type variable
20:48:39 <_ralts> @pl \x xs -> (:) <$> x <*> xs
20:48:39 <lambdabot> (((:) <$>) .) . (<*>)
20:48:47 <mm_freak> smoofra: that's not subtyping, it's really just type application
20:48:57 <rwbarton> I think the correct answer is "id does not really have type forall a. a -> a"
20:48:58 <mm_freak> smoofra: add an implicit type lambda
20:49:32 <shachaf> _ralts: liftA2 (:)
20:49:33 <mm_freak> actually the lambda is there…  it's the "forall"
20:49:44 <mm_freak> but type application is implicit in haskell
20:49:54 <mm_freak> you don't write (forall a. a -> a) Int
20:50:04 <mm_freak> you just unify with Int -> Int a
20:50:34 <smoofra> you know of a good book on the theory of types?
20:51:07 <wavewave> I remember R. Harper's book.
20:51:50 <wavewave> or B.C. Pierce's book
20:52:03 <wavewave> Types and Programming Languages
20:52:26 <wavewave> http://www.cis.upenn.edu/~bcpierce/tapl
20:52:57 <PiRSquared17> wavewave: can you help me w/ brew
20:53:25 <wavewave> PiRSquared17: yes. what's the problem?
20:53:40 <PiRSquared17> How do I install it
20:53:53 <PiRSquared17> ruby script calls sudo
20:54:01 <wavewave> http://www-2.cs.cmu.edu/~rwh/plbook/book.pdf
20:54:22 <PiRSquared17> I can't use root/sysamdin
20:54:44 <wavewave> PiRSquared17: you don't have admin. then you should install homebrew on your local directory.
20:54:56 <PiRSquared17> How?
20:56:13 <wavewave> in the homebrew wiki installation page, you can find Alternate Installs.
20:56:54 <PiRSquared17> Homebrew reqs:
20:57:00 <PiRSquared17> Requirements
20:57:01 <PiRSquared17> An Intel CPU 1
20:57:04 <PiRSquared17> OS X 10.5 or higher
20:57:05 <PiRSquared17> Xcode with X11 2
20:57:07 <PiRSquared17> ...
20:57:12 <PiRSquared17> I don't have Xcode /OR/ X11 ...
20:57:33 <PiRSquared17> Or java Developer Update
20:57:39 <tensorpudding> you can get xcode online
20:57:43 <tensorpudding> beware of the huge download
20:57:59 <wavewave> so in fact I do not know how to install without Xcode.
20:58:10 <wavewave> for xcode, you need admin
20:58:40 <PiRSquared17> I give up, I'll just use lambdabot and tryhaskell.org
20:58:41 <wavewave> in the above,  somebody told us that you can install gcc without xcode.
20:58:50 <PiRSquared17> Liez!
20:59:05 <wavewave> What happened  to your admin ?
20:59:08 <PiRSquared17> 2 Homebrew itself does not depend on Xcode and not all formulae require Xcode. Homebrew will still attempt to install formulae if Xcode is not installed; this is so people can create custom Homebrew installations, that e.g. only install binaries. The X11 components are automatically installed if you installed Xcode via the App Store. If you are not on Lion you will have to register with...
20:59:09 <PiRSquared17> ...Apple Connect and then download Xcode. If you do install via the App Store, you will need to run the “Install Xcode” app that is placed in /Applications.
20:59:32 <PiRSquared17> I'M NOT ON LION!
21:00:09 <wavewave> without admin, your option is very limited..
21:00:27 <wavewave> you cannot install any virtualization tools, either.
21:00:30 <PiRSquared17> Why isn't gcc free (both meanings) for Mac?
21:00:57 <tensorpudding> you can get the gcc source for free, and it'll build on mac, probably
21:00:59 <wavewave> gcc is free.. you can download gcc. and
21:01:04 <tensorpudding> but i mean, chicken and egg problem there
21:01:18 <tensorpudding> do you really want to bootstrap it?
21:01:29 <tensorpudding> wasted cpu cycles
21:01:31 <wavewave> but again you need to have admin.. to install binary for bootstrap.
21:01:42 <smoofra> compiling gcc is always more difficult than it ought to be
21:01:42 <tensorpudding> also i'm not sure, does the free gcc have the ability to do all the mac-ish things
21:01:45 <tensorpudding> like create dylibs
21:01:48 <wavewave> tensorpudding: he doesn't have admin prev.
21:01:59 <tensorpudding> there's always local install
21:02:12 <wavewave> tensorpudding: but then chicken and egg problem.
21:02:26 <wavewave> tensorpudding: usually binary package need admin.
21:02:29 <rwbarton> how many words does an empty Vector use?
21:02:33 <tensorpudding> you don't need admin to put the binary in your PATH
21:02:56 <PiRSquared17> I hate Xcode.  Why do they make you pay for it?
21:03:02 <wavewave> if that's possible, then one can start..
21:03:08 <smoofra> they make you pay for it!?
21:03:11 <tensorpudding> but i mean, seriously, why are you trying to do dev on an osx machine you have no rights to, and lacks any dev tools installed
21:03:13 <rwbarton> aha, 3 words
21:03:16 <smoofra> they didn't in the past
21:03:18 <wavewave> it's about $5...
21:03:53 <PiRSquared17> I don't have a credit card to use ...
21:04:22 <wavewave> I do not use any features apple added from Xcode.. but I had to pay $5.
21:04:42 <tensorpudding> xcode used to be included with the osx install cds
21:04:43 <wavewave> although I use gcc from Xcode, it should be free.
21:04:48 <PiRSquared17> No compiled (binary) gcc on gnu.org ?
21:05:28 <wavewave> just use linux
21:05:30 <wavewave> ;-P
21:05:34 <PiRSquared17> Why does GHC need homebrew, Xcode, gcc, X11, ruby, and curl??!!
21:05:56 <smoofra> lol ruby
21:05:57 <rwbarton> it just needs gcc
21:06:02 <shachaf> I don't think GHC needs Ruby.
21:06:15 <PiRSquared17> shachaf: to get gcc I need the others
21:06:19 <rwbarton> all those other things are things you are trying to install to install gcc
21:06:21 <parcs> does ghc need gcc?
21:06:23 <rwbarton> this isn't ghc's fault
21:06:25 <shachaf> I don't think you need Homebrew either.
21:06:28 <parcs> i thought it needed binutils
21:06:38 <tensorpudding> it's needs gmp
21:06:41 <tensorpudding> er, it
21:06:41 <rwbarton> it needs a linker, presumably, yeah, not sure whether it really needs gcc?
21:06:43 <smoofra> mac-binutils is not the same as normal binutils
21:06:45 <PiRSquared17> Can I do this in one install ?
21:06:49 <tensorpudding> and gcc
21:06:51 <smoofra> apple linker is weird
21:06:52 <shachaf> rwbarton: Well, it does compile C programs.
21:06:58 <tensorpudding> no need for x11 or curl, that i know of
21:07:27 <PiRSquared17> I have literally been trying to get gcc for years!
21:07:37 <wavewave> hmm
21:07:39 <shachaf> PiRSquared17: You know, there are operating systems that make it easier...
21:07:39 <tensorpudding> you can bootstrap gcc
21:07:59 <tensorpudding> and i would be astonished if it were not possible using a limited account
21:08:09 <PiRSquared17> shachaf: but then I would need to but linux and a new computer (?)
21:08:14 <tensorpudding> just download the danged source
21:08:17 <rwbarton> that said you probably have better things to do with your time
21:08:35 <shachaf> PiRSquared17: You could just get Xcode, then.
21:08:39 <rwbarton> what is he even going to bootstrap it from
21:08:50 <shachaf> I think a version of Xcode comes with the Mac OS installation compact disc.
21:08:58 <rwbarton> it used to, yes
21:08:58 <tensorpudding> i thought it had a script that could be used to bootstrap it
21:09:07 <PiRSquared17> What is 'bootstrap from'?
21:09:08 <tensorpudding> he said he doesn't have lion
21:09:29 <shachaf> I don't think you need the latest version of Xcode. The old one, I heard, was available for free.
21:09:32 <tensorpudding> PiRSquared17, bootstrapping is the process of making a compiler able to compile itself
21:09:37 <rwbarton> well gcc is written in C so if you want to compile it you need a C compiler first
21:09:54 <wavewave> hmm... looks like this channel became #macosx or #gcc
21:10:14 <tensorpudding> why don't you ask your admin to install xcode
21:10:20 <PiRSquared17> But the goal was to get GCC
21:10:32 <tensorpudding> xcode has gcc
21:10:36 <PiRSquared17> So that I could get GHC
21:10:39 <tensorpudding> and other stuff that you probably want
21:10:45 <PiRSquared17> But I don't have Xcode
21:11:02 <shachaf> rwbarton: Is it just me or have you been spending a lot more time in this channel than you used to?
21:11:05 * shachaf enjoys watching people slowly descend into the depths of IRC addiction.
21:11:23 <rwbarton> shachaf: depends how far back you go :P
21:11:33 <tensorpudding> you can download it for free
21:11:37 <shachaf> Ah, I suppose that's fair.
21:11:45 <PiRSquared17> tensorpudding: personal info
21:12:01 <shachaf> PiRSquared17: If you don't like how Apple does things, don't use their OS. :-)
21:12:19 <PiRSquared17> I give up.
21:12:27 <tensorpudding> PiRSquared17, download virtualbox
21:12:34 <tensorpudding> download ubuntu 11.10
21:12:37 <tensorpudding> install in virtualbox
21:12:39 <tensorpudding> install gcc
21:12:46 <PiRSquared17> how?
21:12:55 <shachaf> tensorpudding: I heard downloading things was illegal.
21:12:55 <rwbarton> can you run virtualbox as non-root?
21:13:05 <smoofra> somehow i doubt that
21:13:12 <wavewave> rwbarton: I don't think so.
21:13:12 <shachaf> PiRSquared17: Wait, you're restricted to a non-administrator account?
21:13:21 <PiRSquared17> A lot of .dmgs require root too.
21:13:23 <smoofra> considering it installs a kernel module
21:13:26 <tensorpudding> you can run virtualbox as a non-root in other unixy systems
21:13:34 <PiRSquared17> shachaf: I'm not kidding
21:13:37 <smoofra> tensorpudding: slooooowwwwly
21:13:42 <PiRSquared17> maybe I should go to #gcc
21:14:03 <shachaf> PiRSquared17: Not kidding about what?
21:14:07 <PiRSquared17> root
21:14:24 <shachaf> PiRSquared17: ?
21:14:33 <shachaf> You are restricted to non-root or you aren't?
21:14:37 <PiRSquared17> I don't have access to root (easily)
21:14:39 <tensorpudding> i still think you should ask your admin to install it for you
21:14:40 <shachaf> Ah.
21:14:46 <PiRSquared17> No admin!
21:14:56 <smoofra> no root + no admin
21:14:56 <rwbarton> either that or ... what?
21:15:00 <smoofra> that's not a good situation
21:15:04 <tensorpudding> no admin?
21:15:15 <tensorpudding> how does your machine stay updated? who set it up?
21:15:23 <rwbarton> Next we're going to find out that this Mac doesn't exist at all!
21:15:27 <wavewave> sounds like smartphone :-P
21:15:32 <PiRSquared17> LOL
21:15:43 * hackagebot type-unary 0.1.6 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.6 (ConalElliott)
21:15:58 <PiRSquared17> I have no idea what's going on, I just wanted to run Haskell programs
21:16:37 <rwbarton> how about using hugs
21:16:39 <wavewave> hmm, is helium project still alive?
21:16:45 <PiRSquared17> http://codepad.org is prob. the best option at this pint
21:16:49 <PiRSquared17> *point
21:16:59 <tensorpudding> i don't see how you'll run haskell programs, since it doesn't look like you can install anything
21:17:04 <shachaf> There should be a "portable GHC" or something that people can just download.
21:17:22 <tensorpudding> i assumed that ghc had a universal mac binary
21:17:26 <shachaf> I never knew installing GHC was such a hassle.
21:17:28 <tensorpudding> since it has binaries for everything else
21:17:43 <tensorpudding> but meh, it's not a "real mac app"
21:17:56 <tensorpudding> it gets pissy if it can't put feelers into your /usr hierarchy
21:18:04 <rwbarton> but the binaries for everything else rely on a working gcc, right?
21:18:13 <shachaf> tensorpudding: Not portable in that sense, sorry.
21:18:15 <tensorpudding> everything else?
21:18:20 * shachaf self-annoys.
21:18:21 <rwbarton> I thought you meant, like, linux.
21:18:34 <rwbarton> or do you mean Macs have binaries for everything else
21:18:37 <tensorpudding> you don't need a working gcc to install it on linux
21:18:50 <rwbarton> hmm
21:18:50 <tensorpudding> i think you need gnu make though
21:18:59 <shachaf> rwbarton: I think the WIndows version includes gcc, or something.
21:19:08 <PiRSquared17> tensorpudding: make requires gcc
21:19:19 <tensorpudding> only to build from source
21:19:26 <PiRSquared17> Hwlium or Hugs at this point
21:19:31 <PiRSquared17> *Helium
21:19:44 <PiRSquared17> Download icludes gcc?
21:19:45 <tensorpudding> i think your best bet is to get a shell account somewhere
21:19:54 <rwbarton> right... I think there just isn't a large enough Mac user base to cater to those who have no root permissions and no admin... from what I hear you're lucky if you can get a 64-bit build at all.
21:20:01 <PiRSquared17> What is a 'shell' account?
21:20:07 <PiRSquared17> What is 'shell'?
21:20:12 <shachaf> What is?
21:20:15 <rwbarton> what?
21:20:16 <ibid> What?
21:20:21 <ibid> ?
21:20:28 <wavewave> what?
21:20:28 <PiRSquared17>  .
21:20:32 <smoofra> lol wut
21:20:32 <tensorpudding> shell is the name for the interface for entering commands, that runs in the terminal
21:20:32 <shachaf> ibid: Your nick is quite appropriate.
21:20:39 <ibid> shachaf: oh?
21:20:57 <shachaf> Well, for repetition of what rwbarton said.
21:21:03 <tensorpudding> there are servers out there where they allow you to sign up for an account
21:21:06 <ibid> not really
21:21:09 <tensorpudding> and you get to connect to their shell
21:21:10 <PiRSquared17> Insecure
21:21:11 <shachaf> Well, fine.
21:21:13 <ibid> besides, we posted at the same time
21:21:26 <tensorpudding> some shell servers are sketchy
21:21:26 <wavewave> is mac bootable using usb?
21:21:33 <tensorpudding> but there are plenty that aren't
21:21:34 <PiRSquared17> tensorpudding: is Helium or Hugs Mac-compatible?
21:21:35 <shachaf> IRC imposes an ordering on your messages.
21:21:42 <PiRSquared17> ?
21:21:43 <shachaf> Possibly more than one, though. I don't know.
21:21:56 <tensorpudding> someone write a haskell compiler in javascript
21:22:00 <rwbarton> I have used hugs on a mac
21:22:00 <tensorpudding> embed it in browsers
21:22:16 <ibid> shachaf: no rwbarton was a bit earlier than i was, but the delay was below my reaction time :)
21:22:25 <tensorpudding> whose machine are you using
21:22:30 <PiRSquared17> tensorpudding: (function(){return "computed";})()
21:22:41 <rwbarton> just run ghc through ghc2js!
21:22:51 <ibid> shachaf: but i am curious why you think "ibid" is appropriate for repetition.  it's from latin "ibidem" 'in the same place'
21:23:06 <Jafet> Just run ghc in Bellard's jslinux
21:23:08 <PiRSquared17> rwbarton: where is that downloadable from?  Good enough for me
21:23:20 <smoofra> so why are ST arrays so much slower than IO arrays?  i figured they'd be exactly the same under the hood, but aparently IO is waaaay faster
21:23:22 <wavewave> Mac can be booted from usb linux.
21:23:30 <shachaf> smoofra: They are?
21:23:33 <rwbarton> well... I got it through... fink I think? It was a long time ago
21:23:38 <shachaf> smoofra: Do you have a test case?
21:23:39 <PiRSquared17> What is fink?
21:23:40 <wavewave> so there you can start linux and install ghc.
21:23:44 <tensorpudding> fink is not going to let you install as a regular user
21:23:54 <tensorpudding> any more than homebrew or macports
21:24:08 <rwbarton> you can't configure it with --prefix=$HOME ?
21:24:08 <smoofra> shachaf: yea i benchmareked them, just doing a bunch of array ops
21:24:12 <PiRSquared17> The issue w/ brew was that it required Xcode.
21:24:18 <tensorpudding> oh
21:24:20 <smoofra> same exact code, and IO is way faster
21:24:21 <PiRSquared17> Unless you have Lion
21:24:26 <rwbarton> I think it also builds from source though maybe...?
21:24:33 <tensorpudding> fink is compiled
21:24:37 <rwbarton> ok
21:24:39 <tensorpudding> but i believe fink is defunct nowadays
21:24:44 <PiRSquared17> ghc2js is real?
21:24:56 <rwbarton> it seemed a little defunct when I was using it 5 years ago
21:24:57 <tensorpudding> hugs is defunct in any case
21:25:02 <wavewave> define 'real'
21:25:26 <wavewave> it looks working up to a certain level.
21:25:51 <tensorpudding> oh, hmm
21:25:54 <tensorpudding> fink is still around
21:25:56 <tensorpudding> and it has ghc
21:26:04 <tensorpudding> but not binary
21:26:13 <PiRSquared17> GHC is Mac-compatible?
21:26:28 <wavewave> mmmmmmm
21:26:29 <tensorpudding> yes
21:26:55 <PiRSquared17> Is Hugs?
21:26:56 <tensorpudding> oh
21:27:06 <tensorpudding> you need xcode for ghc even if it's in binary
21:27:09 <tensorpudding> right
21:27:16 <tensorpudding> you need xcode for linking and all that junk
21:27:42 <tensorpudding> hugs is dead
21:27:52 <PiRSquared17> Thanks for trying to help me
21:27:53 <tensorpudding> it hasn't been updated in the better part of a decade
21:28:12 <rwbarton> And yet we still get to read hugs error messages here on #haskell
21:28:23 <tensorpudding> but seriously
21:28:30 <PiRSquared17> I think I'll go.
21:28:31 <tensorpudding> what do you mean by your computer not having an administrator
21:28:45 <PiRSquared17> I'll come back tomorrow sometime.
21:29:09 <PiRSquared17> tensorpudding: I don't have access to anyone who has access to root
21:29:28 <tensorpudding> but how do you have access to this machine, then?
21:29:29 <PiRSquared17> This is going nowhere and I wasted your time
21:29:33 <PiRSquared17> Sorry
21:29:42 <PiRSquared17> tensorpudding: non-admin acces
21:29:44 <PiRSquared17> *ss
21:29:53 <PiRSquared17> /quit
21:30:03 <wavewave> hm
21:30:04 <tensorpudding> god that made no sense
21:30:13 <rwbarton> oh
21:30:35 <rwbarton> he didn't understand the difference between "I have root access" and "there exists someone who is an administrator for this machine"
21:31:18 <shachaf> installGHC :: (exists administrator. administrator) -> Machine WithoutGHC -> Machine WithGHC
21:31:45 <ibid> that's pure?
21:31:53 <shachaf> Er, wait. That's not what I meant at all.
21:32:10 <wavewave> just assuming his case is real, I think the best option was installing linux usb stick. ;-P
21:32:59 <wavewave> it can be pure in purely functional package management.
21:35:19 <rwbarton> it's so hard to design data structures with reasonable memory usage when your pointers are 8 bytes long.
21:36:29 <ibid> well, you could (perhaps not in haskell though) take a page out of TeX's book
21:36:49 <ibid> not that i'd recommend it
21:37:01 <rwbarton> something involving reasonably-sized indexes into a big table?
21:37:35 <ibid> yeah
21:38:06 <ibid> you know why TeX did it?
21:38:34 <rwbarton> no, why?
21:38:43 <rwbarton> besides being written in the 70s or so
21:38:47 <josh_> i've got a ghci question if anyone can help me
21:38:58 <josh_> i wanted to add a :clear command to ghci
21:39:06 <ibid> apparently pointers were not portable enought to knuth's taste when he wrote it
21:39:10 <josh_> i found online that the following added to ~/.ghci should do it
21:39:13 <josh_> :def clear \_ -> return $ ":!clear"
21:39:21 <ibid> rwbarton: well, i believe the current version is a rewrite from 1982
21:39:23 <josh_> but this doesn't seem to be working on my laptop
21:39:28 <josh_> did does on my desktop
21:39:30 <rwbarton> oh man, that takes me back!
21:39:37 <ibid> portable, that is, on pascal
21:39:39 <josh_> so think the issue must be that it's not getting read
21:39:57 <josh_> not sure why
21:42:52 <ibid> (also could be, of course, that it's because it's knuth.  the guy whose algorithms textbook uses assembler for example programs:-)
21:43:16 <ibid> (assembler, that is, of a fictional computer)
21:49:35 <rwbarton> I wonder whether there would be any sense at all in GHC having a mode where it uses 4-byte words even on 64-bit systems
21:51:40 <AtnNn> rwbarton: maybe for cross-compiling?
21:52:06 <shachaf> AtnNn: I think rwbarton means for saving memory?
21:52:24 <josh_> :t just
21:52:25 <lambdabot> Not in scope: `just'
21:52:33 <josh_> :t Just
21:52:33 <lambdabot> forall a. a -> Maybe a
21:52:45 <copumpkin> is this an elaborate troll?
21:53:36 <rwbarton> yeah, I'm just interested in not throwing away half my RAM :P
21:53:48 <shachaf> rwbarton: But you can address so much more of it!
21:53:56 <rwbarton> But I have less than 4 gigs anyways!
21:54:06 <rwbarton> (So why did you install a 64-bit OS, you might ask...)
21:54:10 <shachaf> rwbarton: Get more RAM.
21:54:27 <shachaf> It's almost cheaper/GB than hard drives these days. :-)
21:55:08 <shachaf> (Why do you have <4GB RAM?)
21:55:50 <rwbarton> well this is on an old-ish laptop
21:56:51 <ibid> hah.  when i started looking into amd64 when it was new, there was talk that nobod should use 64-bit mode unless they were using huge databases or similar
21:57:41 <shachaf> Hmm, you can still get a 4GB chip for <$20.
21:57:57 <rwbarton> hmm.
21:57:59 <shachaf> Of course space still matters.
21:58:06 <rwbarton> is that laptop RAM?
21:58:12 <shachaf> Yes.
22:00:07 <rwbarton> Well, maybe I'll buy a couple of those then and remove a bunch of {-# UNPACK #-} pragmas from my code.
22:00:29 <shachaf> Hah.
22:00:43 <ibid> what's interesting is that we have very good speed-optimizing compilers but almost no compiler attempts to optimize space usage
22:01:10 <shachaf> Well, optimizing space usage often helps with optimizing speed.
22:01:50 <ibid> all the more reason
22:02:29 <ibid> (of course, optimizing space usage can also hinder speed.  but that just makes it a multiobjective problem, not an impossible problem)
22:02:37 <edwardk> does anyone have any idea why https://github.com/ekmett/revisions won't haddock?
22:04:00 <edwardk> i half jokingly wisecrack that i don't write documentation because of haddock problems but right i'm more serious about that than usual =/
22:04:30 <shachaf> Hey, IVars.
22:04:43 <edwardk> just 1  =)
22:05:27 <shachaf> How does one try to build documentation?
22:05:36 <rwbarton> What is "spark-based deterministic concurrent revision control"?
22:05:41 <rwbarton> I'd read the haddocks, but...
22:06:32 <edwardk> rwbarton: you can fork and join, you make up versioned variables, you can specify how they merge back together after a join
22:06:44 <edwardk> each time you fork the two branches get their own copy of all versioned variables
22:07:04 <edwardk> the result of the Rev computation is deterministic but also parallel
22:07:13 <edwardk> so you can use it like ST but you can use a LOT of cores for it
22:08:03 <edwardk> and momentarily you'll also get a 'record' functionality to take a Rev action and record it while its being done, so it can be replayed later after you've mutated some of the variables it used. at that point it'll only recompute the branches necessary out of the entire fork/join tree
22:08:44 <augur> conal: is this LTL paper any good?
22:09:08 <conal> augur: LTL??
22:09:26 <shachaf> Linear temporal logic?
22:09:35 <edwardk> rwbarton: the idea is you can get a small 2-6x speedup out of 8 cores by using the fork/join model then for many problems which go through and spend a lot of time recomputing the same kinds of things (css layouts for pages, raytracing after you recolor stuff) you can share results with previous iterations without explicitly reinventing your algorithm
22:10:10 <augur> conal: http://ect.bell-labs.com/who/ajeffrey/papers/plpv12.pdf
22:10:17 <augur> you're the most-cited author!
22:10:20 <edwardk> the main difference between this version and the one from microsoft research is that mine is built on sparks so you can use it with impunity and not worry about cleaning up after yourself
22:11:01 <shachaf> What's the version from Microsoft Research?
22:11:03 <edwardk> augur: you have it backwards. the guys who get cited aren't the ones to ask, its the ones doing the citing ;)
22:11:29 <edwardk> daan leijen has a c# implementation and a stub of a haskell one
22:11:35 <augur> edwardk: sure, but conals like *the* FRP guy from my perspective, so i'm sure his opinion is worth something on this matter!
22:11:35 <augur> :P
22:11:50 <edwardk> heh
22:12:28 <conal> augur: what's the title? i'm riding the ragged edge of my internet usage limit
22:12:47 <augur> conal: "LTL types FRP"
22:12:51 <augur> which is a horrible title
22:12:51 <augur> lol
22:13:01 <augur> the subtitle is
22:13:07 <augur> Linear-time Temporal Logic Propositions as Types \n Proofs as Functional Reactive Programs
22:13:15 <edwardk> wait, usage limits still exist?
22:13:17 <conal> augur: i hadn't heard of it.
22:13:32 <conal> augur: is it continuous-time?
22:13:39 <shachaf> edwardk: They do where conal lives.
22:13:48 * edwardk envisions conal sitting at home on a 2400 bps modem using dialup
22:13:58 <shachaf> That's the impression I get also.
22:14:40 <augur> conal: no idea. looks it tho
22:15:02 <conal> augur: added to my download-while-in-civilization list. thx.
22:15:34 <shachaf> conal: I thought you were usually in civilization during the week? :-)
22:15:56 <edwardk> now i have visions of conal fighting off mutants and dinosaurs in the savage land
22:15:56 <augur> conal: you running off to the mountains like Groethendijk? :)
22:16:00 <conal> shachaf: yeah. this week i got a nasty sinus infection. :(
22:16:08 <edwardk> conal: =(
22:16:15 <shachaf> Oh. :-(
22:16:15 <conal> edwardk: yeah. thx.
22:16:50 <tigger_> I feel like this might come up a lot suppose a datatype looks like data MyType = MyType Int Int Int Int Int, and I have a list [1,2,3,4,5], is there a nice function that will apply the list to the data constructor
22:17:14 <tigger_> as opposed to having to do so with heads and tails filling the arguments
22:17:21 <shachaf> Hmm, that paper has an implementation in Agda.
22:17:47 <shachaf> tigger_: No, although you can write f [a,b,c,d,e] = MyType a b c d e
22:17:55 <tigger_> hmmm bummer
22:17:58 <tigger_> thanks
22:18:06 <shachaf> Of course that function is evil.
22:18:20 <shachaf> You want f [a,b,c,d,e] = Just (MyType a b c d e); f _ = Nothing
22:18:33 <u_> i'm guessing he doesn't need to worry about that
22:18:36 <u_> even though i just got here :P
22:18:55 <tigger_> sure, sure, yeah just curious, if lengths were fine and what not, but good to know, thanks!
22:19:11 <shachaf> u_: Of course he does.
22:19:12 <tigger_> or if there is a nice pattern that ppl usually use to deal with this
22:19:16 <tigger_> applicatives or something
22:19:23 <edwardk> tigger_: the pattern is not to do it ;)
22:19:26 <shachaf> edwardk++
22:19:35 <u_> how long can a linked list get before sequences are faster for "last"?
22:19:42 <rwbarton> the question is where did the list come from
22:19:48 <shachaf> runIdentity $ MyType <$> Identity a <*> Identity b <*> Identity c <*> Identity d <*> Identity e
22:20:07 <edwardk> tigger_: since if you got it into a list like that you were probably doing something wrong in the first place. if you know your list has five elements, why build it as a list?
22:20:09 <tigger_> haha cool edward. thx
22:20:32 <shachaf> u_: You should you benchmark it. :-)
22:20:46 <edwardk> rwbarton: did the explanation make any sense?
22:20:51 <rwbarton> yes, more or less
22:20:54 <tigger_> well that wasn't the point, I'm saying you have an arbitrary number, different amounts in different places, just if there was a general item ppl use to handle that case
22:20:58 <shachaf> The answer turns out to be 24 elements, though. No matter what.
22:21:05 <u_> i dun really know how :(
22:21:05 <shachaf> (The previous sentence is false.)
22:21:05 <u_> but ok
22:21:18 <shachaf> @google haskell criterion
22:21:18 <lambdabot> http://hackage.haskell.org/package/criterion
22:21:19 <lambdabot> Title: HackageDB: criterion-0.5.1.0
22:21:20 <rwbarton> how do you guarantee that merging is deterministic? does that depend on the user's merge strategy?
22:21:48 <edwardk> rwbarton: they give a 2 or 3 way merge function, i only apply them in known evaluation order
22:21:55 <u_> shachaf: thanks
22:21:56 <edwardk> think fork join parallelism
22:22:01 <edwardk> with a fixed join hierarchy
22:22:18 <rwbarton> oh, ok
22:22:22 <edwardk> i may race 'par''d task evaluation but i don't race joining
22:23:02 <rwbarton> so in your page layout example what are we fork/joining? layout of subregions?
22:23:09 <edwardk> the only things that i do that are scary are juggling a variable supply behind your back which puts the blocks of variables in magic places to avoid running out
22:23:20 <edwardk> any subcomputations involved, but yes
22:23:49 <edwardk> simple example, parallel sum over an array of versioned variables
22:23:55 <edwardk> that doesn't write to any so its trivial
22:24:04 <edwardk> joining back together has no conflicts to resolve
22:24:25 <rwbarton> ok, and there is some mechanism where I can update one variable and only recalculate log(n) sums?
22:24:28 <edwardk> and if i glue together a 'recording' of the tree as i go, i can replay that recording later after i've modified some of the variables
22:24:29 <edwardk> yeah
22:24:46 <rwbarton> I see
22:24:48 <edwardk> thats the 'record' primitive which is going in next
22:25:45 <rwbarton> I was thinking of "fork/join" and "revisions" like forking and merging in a VCS...
22:25:49 <edwardk> fork :: MonadTask m => m a -> m (Task m a); join :: MonadTask m => Task m a -> m a;  record :: MonadRev m => m a -> m (m a)
22:25:54 <edwardk> they actually are
22:26:04 <edwardk> the variables merge together using the VCS style 3 way merges
22:26:11 <edwardk> just the function is responsible for the merge
22:26:26 <edwardk> and the function is bound to the variable (think file) upon creation
22:26:31 <edwardk> as a bookkeeping detail
22:27:21 <shachaf> All these things you're saying in IRC should probably go in the Haddock. :-)
22:27:25 <edwardk> you could use acc <- versioned def { merging = \p f m -> f - p + m } 0 -- as an accumulator that after a fork had the running total seen so far
22:27:31 <rwbarton> but when I subdivide my "sum a bunch of variables" problem into two subproblems
22:27:33 <edwardk> then you can fork, and each side has its own total
22:28:22 <rwbarton> hmm
22:28:26 <edwardk> then when it joins, it uses that merging function, to make a new total for the accumulator, adding the two current values and subtracting their common parent
22:28:43 <edwardk> to avoid double counting the common region
22:28:50 <rwbarton> oh
22:28:57 <edwardk> and that parent version is the value as far up the tree as i had to go to find a common ancestor
22:29:03 <edwardk> it really is a 3 way merge
22:29:14 <rwbarton> so I fork and then I stick in one of the values I wanted to add
22:29:32 <edwardk> or hundreds of them
22:29:38 <edwardk> and then join
22:29:38 <rwbarton> right, I mean in each new fork
22:29:44 <edwardk> yeah
22:30:01 <edwardk> but you can do large amounts of stuff over the course of one of your branches
22:30:06 <edwardk> then merge
22:30:27 <edwardk> here i'm looking at a large number of versioned variables, and writing to another (or just returning it in the monad)
22:30:56 <edwardk> then in addition to the fork/join/merge machinery you can record an action in the rev monad to play it back later
22:31:10 <edwardk> and i only invalidate parts of that action based on what has changed
22:31:48 <edwardk> so if you have a game where you have a loop where you update the scene and calculate a bunch of stuff over and over every frame
22:32:01 <edwardk> you record the calculator
22:32:05 <edwardk> then play it back after each frame
22:32:20 <edwardk> and i'll try to share as much as i can with the previous scene's calculation
22:32:33 <edwardk> only invalidating those branches which read from variables that i've written to in the meantime
22:32:59 <edwardk> (and even then trying to patch it up using the 'equating' machinery that you can optionally enable on a versioned resource)
22:33:39 <edwardk> another variant i've been playing with is a checkpointing monad. where you write a computation and put in checkpoints i can use to fastforward it when you restart
22:34:08 <edwardk> it is a bit uglier requiring invariants much like those of cloud haskell about serialization for closures, etc. but its the same general idea
22:34:20 <edwardk> that way i can deal with this separated across time
22:34:21 <rwbarton> that is a more linear sort of thing?
22:34:39 <edwardk> nothing says i can't fork and join in the tape =)
22:34:48 <rwbarton> ok, sure
22:34:57 <edwardk> but essentially, yes
22:35:09 <edwardk> that is uglier in some ways because i can't use my magic variable supply
22:35:28 <edwardk> or if i do, i have to record some of the choices in the tape =/
22:36:57 <edwardk> anyways for things like raytracing after minor scene edits, or doing css layout after minor page edits, daan got some really nice results
22:37:16 <edwardk> and i realized i could rebuild it in a nicer way on top of sparks rather than old school IO
22:37:38 <edwardk> that way the rev monad doesn't cost you anything really when your CPU has something to do
22:37:40 <rwbarton> or parsing?
22:37:55 <edwardk> the flagship for me is type checking actually
22:38:19 <edwardk> since i want to use it to re typecheck after minor changes in the source problem
22:38:42 <edwardk> in particular as i remove labels in a type error slicer
22:39:04 <edwardk> so i can start with one set of labels, then try to minimize the set involved in the error recycling as much of the previous computation as possible
22:39:23 <edwardk> to avoid a large part of the O(n^2) hit i'd pay removing them one at a time
22:39:29 <rwbarton> right
22:39:47 <edwardk> parsing is another candidate but the problem is somewhat dualized there.
22:40:23 <edwardk> there is a parser by warren li which would adapt to this approach nicely
22:40:34 <edwardk> but not so much a parsec/trifecta style parser
22:41:20 <edwardk> well those'd benefit up to the point where the parses diverged and then never come back together
22:42:18 <edwardk> perhaps something that acted a bit more like a packrat parser, using packrat to memoize leaves, and then holding onto rev actions for things like symbol table lookups
22:42:29 <edwardk> but giving up on sharing the AST calculations for the most part would be the best compromise
22:42:52 <edwardk> that way you share the stateless leaf calculations and you share the bigger calculations that were based on looking stuff up in the environment
22:45:25 <edwardk> actually that looks like it'd work rather well if i tied the actual memoization to the rope structure
22:45:33 <mgsloan> edwardk - I'm very interested how incremental type checking is going.  Does it require a new typechecker? Do all the GHC extensions still work
22:46:10 <mgsloan> yeah, rope monoids are great for partial updates of sequenced data
22:46:17 <edwardk> mgsloan: its a new typechecker, its going slowly because other shiny things keep grabbing my attention, but it does support ghc kinds right now.
22:46:19 <mgsloan> *queries on
22:46:30 <edwardk> mgsloan: trifecta is built on ropes all the way down
22:46:40 <mgsloan> awesome!!
22:47:08 <edwardk> mgsloan: basically what i have right now is a kind checker for ghc kinds with the new polymorphic kinds extension, so really its a crappy type checker that i call a kind checker
22:47:16 <edwardk> that i intend to eventually extend with a type system ;)
22:48:17 <mgsloan> gotcha, very cool!  props for building it incremental from the start
22:48:41 <edwardk> what i find hilarious is that all this versioned variable stuff is making me take my nice pretty functional code and force it to look imperative
22:49:39 <mgsloan> yeah, efficiency concerns have a habit of doing that..
22:49:56 <edwardk> well, its just that the paradigm is an imperative one. newRef, readRef, etc.
22:53:00 <mgsloan> right.  Seems like concurrent data reuse is usually going to need to do that - make sequencing explicit, that is.
22:53:54 <edwardk> well, i get the benefit that within a fork no external mutations happen until join, whereupon they get merged in deterministically
22:54:46 <edwardk> but i still wind up having/wanting to talk about these on references rather than merging pure values by hand
22:55:13 <mgsloan> If kind-checking fails, can you still get the constraints for different variables?  Maybe that question doesn't make sense in the new kinds, but what I really care about is getting type information for subexpressions despite overall type checking failing
22:55:30 <edwardk> well, have you seen amakuni?
22:55:59 <mgsloan> hmmm, nope. And google isn't very enlightening
22:56:02 <edwardk> http://www.macs.hw.ac.uk:8080/techreps/docs/files/HW-MACS-TR-0079.pdf
22:56:09 <edwardk> page 2, figure 2
22:56:20 <edwardk> that is what i've been trying to do with haskell types
22:57:04 <edwardk> my first cut at it was to do what they do, my second stab is to try to make a magic monad that i can find a problem and then try to simplify and look for the same unification error in
22:57:54 <edwardk> mgsloan: basically show the 2 source ranges that directly led to the conflict and also highlight every other bit of code that was involved in the error through bringing stuff that contributed into scope, etc.
22:58:12 <edwardk> mgsloan: that way you could erase / mark undefined the rest of the program and still get the error
22:58:43 <mgsloan> we're working on very similar projects :)
22:59:13 <mgsloan> I wish this was prettier http://www.mgsloan.com/sinu3.svg
22:59:20 <mgsloan> but it will be soon :)
22:59:25 <edwardk> mgsloan: mine was mostly coz i needed to work on a variant of HMF for work and GHC's kinds had just the right level of complexity to model what i needed
22:59:27 <mgsloan> http://www.mgsloan.com/sinu4.svg
22:59:32 <mgsloan> this'll make a little more sense
22:59:36 <mgsloan> but ugllly
23:00:30 <edwardk> one of the things trifecta tracks is an interval map of what it parses (mostly for highlighting purposes)
23:01:56 <Sgeo|web> >id id id id id id id id id id id id id id id id id id id id id id id 0
23:02:08 <Sgeo|web> > id id id id id id id id id id id id id id id id id id id id id id id 0
23:02:12 <lambdabot>   mueval-core: Time limit exceeded
23:02:26 <Sgeo|web> > id id id id id id id id id id id id id id id id id id id id id id id ()
23:02:30 <lambdabot>   mueval-core: Time limit exceeded
23:05:39 <smoge> how to visualize darcs history?
23:05:44 <smoge> is there a GUI for linux?
23:08:46 <mgsloan> edwardk - yeah, I've got few intervalmaps for source locations and building up the drawing of the type explanations
23:09:01 <mgsloan> TODO is annotating those lines with the constraints on those parametric vars
23:10:00 <mgsloan> edwardk - I recursively set chunks of the program to undefined in order to discover small subsets that can be removed to make it typecheck
23:10:26 <mgsloan> then I replace all of the polymorphic variables with dummy data constructors
23:10:38 <edwardk> what i'm doing is a bit braindead. as i parse i just name intervals, then when i assign type constraints i'm just tracking the dependency on the source interval    and later on tying to relax the set of input constraints until i can't shrink the set without changing the type error
23:10:42 <edwardk> yeah
23:10:51 <mgsloan> then it fixes all of the errors ghc tosses at it, giving the typing environment
23:11:06 <mgsloan> course that last bit is incomplete
23:11:12 <mgsloan> only handles equality and class constraints atm
23:11:20 <edwardk> tom schilling has something similar: http://www.cs.kent.ac.uk/research/groups/plas/seminars/20091123-ts.pdf
23:14:14 <mgsloan> wow.. I had no idea a lot of this existed
23:14:35 <mgsloan> I know about the Seminal paper because I'm trying to work with the professor that worked on it
23:14:46 <edwardk> *nods*
23:14:48 <mgsloan> (mentioned in schilling's slides)
23:15:23 <mgsloan> trying == refining this type explanations idea til it's usable
23:15:31 <edwardk> what i'm trying now is to see if i can get away with type error slicing without using constraint handling rules at all
23:15:33 <mgsloan> and meanwhile doing nothing
23:15:40 <mgsloan> probably not a good strategy
23:15:53 <edwardk> *nods*
23:17:15 <mgsloan> do you know if they've released the haskell version of this?
23:18:28 <Sgeo|web> Why does GuiTV have so many build failures listed?
23:18:33 <edwardk> mgsloan: schilling's?
23:19:02 <edwardk> i have a copy of it from him, but he hasn't released it. you might want to just ask him if you can poke around it
23:19:15 <mgsloan> yup, in the slides it says "Scaling to full Haskell syntax in progress"
23:19:17 <mgsloan> gotcha
23:19:26 <mgsloan> yeah, I'd like to, I'm sure its better than mine
23:19:36 <Sgeo|web> Hmm, is GtkTV the more modern thing?
23:19:39 <edwardk> its pretty straightforward
23:20:12 <mgsloan> https://github.com/mgsloan/sinuhask/blob/master/src/Main.hs#L561
23:20:20 <edwardk> i have to admit the biggest problem is he doesn't have a way to deal with the fact that by slicing blind through ghc's api he doesn't have a good way to check that the errors didn't swap underneath him
23:20:31 <edwardk> so he can slice his way to a completely different problem
23:21:09 <mgsloan> ahh.  I have a rudimentary type error parser - that might help
23:22:42 <edwardk> the main thing i've been playing with is how to nicely separate ambiguous from unambiguous quantification. so what i have now is a (start of) a type checker that turns quantification over variables that only occur in negative position relative to the => arrow into existentials in the constraint
23:23:32 <edwardk> so you get reverted :: forall m. (exists s. MonadState s m) => m ()   rather than the ambiguous position s sitting in the outer forall
23:24:06 <edwardk> that lets me do hmf style impredicativity for all the other variables, and makes it clear why a lot of the type equality constraints etc, are instantiated free
23:24:49 <edwardk> it isn't perfect though because if you have references to ambiguous variables from one constraint set that occurs later in another constraint set you get stuck again
23:25:16 <edwardk> but it was enough to solve a particularly thorny type sytem problem at work
23:26:12 <Hayshi> can someone help a noob figure out how to implement Read for new data types?
23:26:39 <edwardk> Hayshi: does deriving (Read) not work for your type?
23:28:36 <Hayshi> anything I try gives me a "no parse" exception
23:29:10 <edwardk> Hayshi: what is the type?
23:29:15 <Hayshi> just this
23:29:16 <Hayshi> data ComplexInt = Complex Int Int
23:29:45 <Hayshi> I'm really new at Haskell though haha
23:29:48 <edwardk> and (read "Complex 12 32" :: ComplexInt) doesn't parse?
23:30:23 <Hayshi> Ha! it does. syntax! Thanks.
23:30:32 <edwardk> the problem is read is polymorphic
23:30:34 <edwardk> :t read
23:30:35 <lambdabot> forall a. (Read a) => String -> a
23:30:47 <edwardk> so how would it know you wanted a Complexint unless you tell it =)
23:31:02 <edwardk> it probably used defaulting to guess that you wanted to parse an Int or a () or something at the console
23:31:21 <edwardk> > read "()"
23:31:22 <lambdabot>   ()
23:31:25 <edwardk> > read "12"
23:31:26 <lambdabot>   *Exception: Prelude.read: no parse
23:33:11 <Hayshi> could I make it so that it could parse "ComplexInt 1" as Complex 1 0 ?
23:34:19 <edwardk> probably but it'd be a pain in the neck coz you'd have to manually build the Read instance
23:34:33 <edwardk> in general when you want something that isn't exactly the haskell syntax, you want something other than Read
23:34:51 <Hayshi> hmmm
23:34:53 <edwardk> you want a parser or something else
23:35:31 <edwardk> Read and Show should maintain the invariant that Read . Show = id
23:35:47 <edwardk> :t read . show
23:35:48 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
23:36:00 <edwardk> > (read . show) "()"
23:36:04 <lambdabot>   mueval-core: Time limit exceeded
23:36:10 <edwardk> hah
23:39:16 <shachaf> edwardk: That would be _|_ either way. :-)
23:39:34 <edwardk> shachaf: hah the parens
23:39:49 <shachaf> ?
23:39:54 <liyang> Is it bad form to have Show instances that produce output readable only by hu-mans? D:
23:40:20 <edwardk> > (show . read) "()"
23:40:21 <lambdabot>   "()"
23:40:31 <shachaf> Oh. Well, yes.
23:40:35 <edwardk> thats what i wanted
23:40:36 <edwardk> liyang: generally yes
23:40:43 * hackagebot atom 1.0.11 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.11 (LeePike)
23:41:00 <edwardk> liyang: they seem like a good idea at first until you start getting them mixed in with other show instances
23:41:08 <shachaf> It would be nice if there was a standard pretty-print class.
23:41:17 <edwardk> liyang: i recommend making some kind of class Pretty p where pretty :: p -> Doc
23:41:22 <liyang> Pretty++
23:41:36 <edwardk> shachaf: i have one in wl-pprint-extras
23:41:57 <edwardk> and another in wl-pprint-terminfo
23:42:22 <shachaf> edwardk: Is it standard enough that a randomly-chosen type on Hackage have instances for it? :-)
23:42:23 <liyang> That said, when would you use the property that read . show == id anyway?
23:42:24 <edwardk> the former is parametric in the set of annotations on the pretty printer, the latter produces them with terminfo-style highlights
23:42:34 <liyang> If you're using that for serialisation, you're insane.
23:42:40 <edwardk> shachaf: sure, as long as that type is in trifecta ;)
23:43:18 <edwardk> liyang   read . show   as a law is useful if you serialize using show then read it back in
23:43:38 <shachaf> I wonder how far you could get with something that pseudo-parsed Show output (from derived instances) and pretty-printed them, with a fallback to just printing the string (or just wrapping it or something).
23:43:53 <edwardk> shachaf: ezyang has a library for doing that
23:44:09 <edwardk> uses a cheap haskell parser so it can reflow it
23:44:47 <shachaf> Hmm, interesting. What's it called?
23:44:59 <edwardk> don't remember off hand
23:45:56 <edwardk> i found one by iavor: http://hackage.haskell.org/package/pretty-show
23:46:00 <edwardk> maybe that was what i was thinking of
23:46:26 <liyang> edwardk: I wouldn't, and wouldn't recommend it either. ^^;;
23:47:28 <edwardk> aha! http://hackage.haskell.org/package/groom
23:47:39 <edwardk> it was ed
23:48:18 <shachaf> liyang: xmonad uses it for serialization.
23:48:34 <edwardk> so complicated: http://hackage.haskell.org/packages/archive/groom/0.1.1/doc/html/src/Text-Groom.html
23:48:35 <liyang> the only times where that might be useful is for e.g. small configuration files, but the Read instances tend to be rather brittle.
23:49:01 <edwardk> liyang: it works and its a half-way viable way to get started ;)
23:49:08 <edwardk> but yes
23:49:17 <edwardk> Read is generally a poor tool
23:49:37 <liyang> shachaf: ah. I've been using Show for pretty-printing, completely ignoring Read, and have a separate class for serialisation.
23:50:31 <edwardk> liyang: the problem comes in when you actually want to see the code of something that happens to contain one of your structures
23:50:31 <shachaf> liyang: I didn't say I recommend it. :-)
23:50:50 <edwardk> you get nicely formatted haskell code, and thenyou get pretty human readable text mashed up
23:52:45 <liyang> I wouldn't consider the default Show instances' output ‘nicely formatted Haskell code’… ;)
23:52:52 <edwardk> =P
23:55:33 <poindontcare> question, how does one get the max item from Data.map, I am storing a freq_map [(item freq) ...] need to find most freq item
23:55:46 <poindontcare> *Data.Map
23:56:10 <edwardk> maximum key or value?
23:56:11 <shachaf> poindontcare: You could convert it to a list and then use maximumBy...
23:56:44 <shachaf> Though there are probably more clever things you can do in this particular case.
23:56:46 <poindontcare> value
23:56:55 <poindontcare> i mean freq
23:56:58 <edwardk> there is a combinator for viewingthe min and max by key, but to get it by value you need to toList and use something
23:57:13 <hpaste> liyang pasted “pretty printing” at http://hpaste.org/53889
23:57:34 <poindontcare> hmm
23:57:35 <poindontcare> k
23:58:05 <liyang> edwardk: what I've been using for some FFI bindings: http://hpaste.org/53889
23:58:21 <edwardk> the overlapping instance for Show a => ShowRecord a just made me throw up in my mouth a little
23:58:46 <edwardk> because it means you can't get reliable dispatch for any instances you define outside of that single source file
23:59:51 <edwardk> annoyingly the 'right' solution is to make a showRecordDefault :: Show a => (String, [String])  and then make each instance by hand for the other cases
23:59:53 <liyang> Alternatives? Without explicitly writing ShowRecord instances for every Show instance.
