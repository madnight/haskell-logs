00:00:00 <DaIRC49157> yeah, main expects to have type  IO ()
00:00:00 <shachaf> Kus: Oh, there's also that.
00:00:10 <Axman6> Kus: you need: print $ combineList (MakeEntry ("a","b")) (MakeEntry ("c","d"))
00:00:14 <shachaf> You need parentheses: combineList (MakeEntry ("a","b") -- yes.
00:00:16 <DaIRC49157> and your combinelist has type Entry->Entry->Entry
00:00:18 * shachaf )
00:02:07 <Eduard_Munteanu> GutenTag: '-' can't be in a name, it parses as "element - at"
00:02:47 <Kus> Axman6: What will it print?
00:03:07 <GutenTag> Eduard_Munteanu: I am using an underscore, right?  Is that the error to which you refer?  It was my first time to try and use _.  Perhaps I am only THINKING that is an underscore (looking at examples)
00:03:11 <Eduard_Munteanu> In Haskell you probably want to use camelCase.
00:03:23 <GutenTag> OOOOOOh
00:03:24 <GutenTag> I see
00:03:31 <GutenTag> nevermind, in element-at.  gotcha.
00:03:39 <DaIRC49157> if there's multiple epolls which one gets a given event?  by fork i presume you mean iofork
00:03:48 <Axman6> Kus: the result of the computation you've made. if you don't print it, your program will do absolutely nothing at all
00:04:24 <Kus> Axman6: it says something about no (Show Entry) instance
00:04:52 <shachaf> Kus: Yes. If you add "deriving Show" after your data declaration, it'll fix it.
00:05:06 <shachaf> What are you actually trying to do? Are you using a guide of some sort?
00:05:18 <Eduard_Munteanu> On the same line, it should do.
00:05:38 <shachaf> DaIRC49157: Presumably multiple concurrent epolls don't listen for events on the same fds.
00:06:14 <Eduard_Munteanu> GutenTag: the underscore there is alright
00:06:19 * hackagebot zoom-cache 0.5.1.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.5.1.0 (ConradParker)
00:06:32 <GutenTag> Eduard_Munteanu: I got it to work, thanks. :)
00:06:43 <ddarius> DaIRC49157: "each instance managing a disjoint set of files or network connections."
00:06:54 <Axman6> Kus: data Entry = MakeEntry (String,String) deriving Show
00:07:00 <DaIRC49157> hmm
00:08:18 <DaIRC49157> ic, so the server accepts a connection (which creates a socket) and hands off the newly created socket to another thread that runs its own event mgr instance?
00:11:39 <Eduard_Munteanu> DaIRC49157: I'm not sure, but from what I'm reading above, you don't get an event manager per *thread*.
00:12:19 <Axman6> DaIRC49157: are you talking about when you use forkIO? if so, all threads share the same event manager. this is ok though, it's almost certainly not going to be the bottleneck in your code
00:13:05 <Axman6> even with a simple server that forks a thread for each connection and just writes a simple string and closes the connection, you'll find that it will easily service tens of thousands of requests per second
00:13:25 <Axman6> possibly even hundreds of thousands
00:13:37 <kalven> what about millions?
00:15:25 <Axman6> i think you'd be doing pretty damn well to be able to serve millions of requests a second on desktop hardware with any language, unless you can implement your server in an ethernet driver. and even then, you'd probably want to use 10gbit ethernet ;)
00:15:27 <Eduard_Munteanu> Supposedly there would be some contention / communication overhead if the managed resources are independent and mainly thread-local.
00:16:18 <shachaf> A million requests per second is certainly possible.
00:16:19 * hackagebot zoom-cache-pcm 0.1.0.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.1.0.0 (ConradParker)
00:18:04 <ddarius> "If we use fork before accepting connections, the listening port is shared among the processes and the OS kernel dispatches a new connection randomly to one of processes when accepting."
00:18:07 <GutenTag>  myLength x = (myLen x 0) // gives an 'unexpected =' error.  I originally tried it w/o parens around the "myLen x 0".
00:19:02 <GutenTag> Argh.  Nevermind, I just noticed I had an extra space at the beginning of each line.
00:19:11 <Eduard_Munteanu> :)
00:19:17 <kmc> over nine thousand connections per second
00:19:41 <shachaf> kmc: That's a lot of connections.
00:19:50 <Eduard_Munteanu> Yeah, and by forking I guess that usually means forking a new process.
00:20:03 <Eduard_Munteanu> (not threads)
00:20:23 <DaIRC49157> Axman6, desktops are the new mainframes :).  lots of servers these days run on small VPS's that are basically the equivalent (cpu and memory) of midrange cell phones
00:21:04 <Axman6> sure
00:21:18 <kmc> haha so true
00:21:49 <ddarius> Lots of servers back in the day ran on mainframes that are basically the equivalent of low-end cell phones.
00:22:03 <kmc> if not for virtualization we might see racks full of thousands of ARM chips running these sites
00:22:08 <DaIRC49157> ddarius yeah but those weren't programmed in haskell :)
00:22:12 <kmc> (also if not for x86 lock-in)
00:22:34 <Axman6> kmc: it's coming
00:22:58 <kmc> i'm not convinced
00:23:05 <kmc> isn't die-level integration more efficient than board-level integration?
00:23:22 <Eduard_Munteanu> I used to set up servers on some pretty terrible hardware.
00:23:35 <DaIRC49157> virtualization means the size of each "computer" can dynamically adjust
00:23:37 <kmc> there was some brief "physicalization" trend but I think that was driven by weird Intel pricing rather than anything fundamental
00:23:38 <Axman6> kmc: power is where the cost of servers is these days
00:23:49 <Eduard_Munteanu> (consumer, old and under-sized)
00:23:58 <kmc> (extra markup on Xeons, low margins on Atoms)
00:24:22 <kmc> Axman6, oh, sure, you'll want to use low-power architectures, but it will still be more efficient (in terms of money *and* power) to get beefy chips and virtualize them
00:24:44 <kmc> i guess what I mean is that even if servers move to ARM, they will move to something higher-end than is in your average cell phone
00:24:55 <kmc> but maybe not, because of economies of scale making those cellphone chips
00:24:55 <Axman6> of course
00:24:58 <Axman6> hence the A15
00:25:07 <Eduard_Munteanu> kmc: that usually requires beefy I/O as well I guess
00:25:10 <kmc> didn't know about that one, cool
00:25:10 <Axman6> an OOO multicore chip
00:25:27 <DaIRC49157> i think they are doing a 64 bit arm
00:25:30 <kmc> i'm also interested to see what happens with Loongson
00:25:35 <DaIRC49157> i wonder if it supports virtualization
00:25:37 <ddarius> kmc: Shit out 1000 ARMs on a single die.
00:26:13 <Axman6> there's a company who's just announced a very interesting architecture, which uses something like 2 A9 cores and 2 or 4 A15 cores, to save power when needed, and boost performance when demanded
00:26:19 * hackagebot zoom-cache-sndfile 0.1.0.0 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.1.0.0 (ConradParker)
00:26:26 <DaIRC49157> Axman6, kal-el?
00:26:29 <kmc> TSMC is making the A15 in 20 nm  o_O
00:26:30 <Axman6> no
00:26:35 <Eduard_Munteanu> So yeah, I guess you could save up on power if you sold "parts" of your computing power provided by a consumer chip if you don't need it, but I'm not sure the I/O bandwidth is always there.
00:26:38 <kmc> cool Axman6
00:26:47 <Axman6> kmc: see what i mean about 'it's coming'? =)
00:27:15 <Axman6> apparently Apple have been working for quite some time on ARM based computers (ie the MacBook Air)
00:27:20 <Eduard_Munteanu> (including network bandwidth and all that)
00:27:23 <DaIRC49157> http://en.wikipedia.org/wiki/Cortex_A15
00:27:27 <kmc> well if they can convince everyone to give up on OS X and move to iOS
00:27:30 <kmc> then it will be easy :)
00:27:50 <kmc> too bad SMT rework is so labor intensive, otherwise I would build a business on retooling those thrown-out iPads into servers :)
00:27:52 <Axman6> why would they need to give up on OS X?
00:27:56 <ddarius> kmc: What if you've already given up on OS X?
00:28:03 <Axman6> it's very likely it already runs fine on ARM
00:28:05 <Blkt> good morning everyone
00:28:11 <Eduard_Munteanu> Blkt: morning
00:28:13 <kmc> Axman6, except for all the applications software
00:28:20 <Blkt> :)
00:28:29 <kmc> developers are probably sick of apple switching architectures
00:28:31 <ddarius> SMT is a bitch.
00:28:36 <Axman6> kmc: sure, but they've got the tech to make moving to a new arch relatively painless
00:28:54 <Eduard_Munteanu> Not all SMT, really.
00:29:04 <kmc> it's an easier sell to say "make an iPad app on the side; also some iPads now have a keyboard and cost $1000"
00:29:16 <kmc> plus you can get paid on iOS and piracy is harder
00:29:33 <kmc> yeah, soldering SOIC by hand is not so bad
00:29:40 <Eduard_Munteanu> Stuff like BGA(-ish) chips are annoying though.
00:29:57 <kmc> actually there is a trend towards doing even regular DIPs surface-mount for hobby stuff
00:30:05 <kmc> if you make your own PCBs, that's fewer holes to drill
00:30:05 <Eduard_Munteanu> Even lots-of-pins-*QFPs are pretty doable.
00:30:23 <GutenTag> I notice when I define functions like: myLast'' = head . reverse or myLength'' = sum . map(\x -> 1), I do not do something like myLast'' X =   or myLength'' x =.  What would I google to learn about that construct?
00:30:55 <Axman6> GutenTag: it's pointfree style
00:31:16 <ddarius> When you define numbers like: one = 1 you also don't do that.
00:31:17 <Eduard_Munteanu> kmc: I've usually found DIP is more expensive these days, and it might be even easier to do SMT if drill your own holes.
00:31:20 <Axman6> kmc: http://www.theregister.co.uk/2011/11/01/calxeda_energycore_arm_server_chip/
00:31:27 <Eduard_Munteanu> And rarer.
00:32:03 <GutenTag> thanks Axman6 and ddarius.
00:32:04 <Axman6> hmm, maybe that's not the one i was after. but still a very interesting architecture. somewhat like SeaMicro's Atom based servers
00:32:11 <adimit> @pl f x = g.h $ x -- @pl can apply pointfree style for you.
00:32:12 <lambdabot> f = g . h
00:33:02 <Eduard_Munteanu> @unpl f = g . h
00:33:02 <lambdabot> f c = g (h c)
00:36:56 <ddarius> > let one = 1 in one 2
00:36:57 <lambdabot>   1
00:37:38 <kmc> > let 2 + 2 = 5 in 2 + 2
00:37:39 <lambdabot>   5
00:38:06 <GutenTag> scary.
00:38:46 <GutenTag> thanks for your help, everyone.  Time for me to sleep.
00:39:57 <erus`> @pl a b c d = c
00:39:57 <lambdabot> a = const const
00:40:05 <erus`> @pl a b c d = d c b a
00:40:05 <lambdabot> a = fix (flip (flip . (flip .) . flip (flip . flip id)))
00:40:24 <erus`> @unpl a = fix (flip (flip . (flip .) . flip (flip . flip id)))
00:40:24 <lambdabot> a = fix (\ b c f i -> i f c b)
01:36:19 <frerich> I really love QuickTest, but I wonder: is it possible (and maybe even practical) to determine the boundary test values for pure functions automatically instead of using random strings? For a function like '\x -> if x > 3 then 3 else x' it may be possible to tell that in order to get 100% branch coverage, the function should be passed a value <= 3 and another value > 3?
01:37:29 <frerich> I can imagine that this requires some rather expensive backtracking algorithms, but still - maybe it's easier to do for pure Haskell functions than for e.g. some C function?
01:38:03 <shachaf> frerich: What sort of backtracking algorithms are you thinking of?
01:38:25 <shachaf> frerich: QuickCheck figures out tests entirely based on the type. The function itself is opaque.
01:38:49 <flux> frerich, I guess it would be feasible for simple functions, but once you have recursion etc, it becomes extremely complicated or impossible. I guess quite outside the scope of QuickCheck.
01:38:56 <shachaf> Unless you were to try calling it with every single possible value (in cases where that's possible), you could never be sure.
01:39:00 <ddarius> frerich: You would need to be able to, at least, instantiate the used values at different (unusual) types, or, as shachaf says, the function is just a black box.
01:39:45 <frerich> shachaf: Well yes, but AFAICS QuickCheck tries 'random' input and verifies that certain assertions hold for each input. I don't want to replace QuickCheck, but I wonder whether it can be made more useful by not having to use random functions but by combining it with a tool for which the function is not a black box (and thus the function might be able to determine when all the control paths are taken).
01:40:02 <ddarius> frerich: Not the same thing, but you may be interested in looking at SmallCheck and LazyCheck as well.
01:40:50 <ddarius> frerich: There are static analysis approaches that do things like that.  I'm not aware of any for GHC Haskell.
01:41:06 <frerich> A colleague recently did something like this for Pascal (working on the generated assembler code). He determined the exit points of a function and then backtracked all the way to the start to determine all the different conditions (The conditional jumps) which are tested. And in the end his program could print something like '-12313, 1' or so for a recursive factorial program in Pascal
01:41:19 * frerich was quite impressed but fears that it doesn't scale to larger functions
01:41:35 <frerich> ddarius: Thanks, I'll google for that :-)
01:42:50 <flux> ddarius, you could do it in a dynamic fashion
01:42:58 <ddarius> http://www.stanford.edu/~engler/klee-osdi-2008.pdf or Dawson Engler's work in general http://www.stanford.edu/~engler/
01:43:17 <flux> ddarius, 1) run function with an argument 2) end up in a branch 3) make sure next time you call the same function with values that make it end up in another branch
01:43:31 <flux> (step 0.5: convert all and/or conditions into multiple branches)
01:43:47 <frerich> ddarius: KLEE is exactly what inspired my colleague :-)
01:43:54 <flux> oops, I meant to say frerich instead of ddarius
01:44:13 <flux> also, 4) iterate until you have 100% branch coverage
01:44:45 <flux> but if that were the only test, I have a feeling you might still under-test the function
01:45:00 <ddarius> flux: The problem is figuring out what values will lead to another branch.
01:45:14 <flux> ddarius, for the example you provided it would be easy :)
01:45:44 <flux> I guess if you have code if tm_terminates (..tm here..) then.. it wouldn't be so easy :)
01:46:20 <ddarius> flux: But that general idea plus the tools to track the information back is how KLEE works, or if not KLEE some similar things.
01:46:47 <flux> something like that could work interactively
01:46:59 <flux> the machine would churn out the paths it can handle and query more information for the rest
01:47:51 <flux> also some kind of dependant typing would be nice to have in that analysis, so you would be able to rule out this: if a > 0 then if a > 0 then.. when there is no value where the second if can reach its else branch
01:47:58 <ddarius> frerich: You may also be interested in the work using BitBlaze on Sting and related technologies.
01:50:17 <ddarius> In that vein, this sounds most relevant to what you asked (going by the title): http://bitblaze.cs.berkeley.edu/sdse-testgen.html
01:50:25 <ddarius> That said, Sting is just cool.
01:50:37 <kmc> did anyone mention QuickSpec yet? it's not really relevant but it's damn cool anyway
01:52:02 <ddarius> kmc: What kind of things were you looking to actually work on for HacBoston as far as the binary analysis stuff is concerned?
01:52:47 <ddarius> Well, I guess the project section says.
01:52:52 <kmc> well i listed five example projects
01:53:01 <kmc> i'm personally most interested in radare bindings
01:53:31 <kmc> somewhat as an excuse to learn radare
01:54:22 <aryslan> hello
01:54:30 <ddarius> I wouldn't mind modifying the elf support.  I have a soft spot for "file" formats.
01:55:03 <kmc> another thing that i want (that's not on there) is a ptrace-based live profiler for ghc-compiled haskell code
01:55:35 <kmc> you attach this to your long-running daemon (which is compiled the usual way) and the profiler tells you which code has been entered in the past n seconds
01:55:44 <aryslan> I need to write a recursive descent parser, can any one help?
01:56:50 <kmc> so you wouldn't need to build or run with any special profiling option
01:56:56 <kmc> you could attach it when you notice a load problem
01:58:11 <aryslan> can any one help me to write a recursive descent parser?
01:59:56 <oldwzd> aryslan: homework?
02:00:10 <aryslan> oldwzd yes
02:00:45 <aryslan> oldwzd can u help?
02:01:22 <kmc> you should give a more detailed description of what you're trying to do
02:01:27 <kmc> you can put code or text on hpaste.org
02:03:41 <min> If you're having trouble organizing the parser, you might glance at Eric Meijer's paper on monadic parsing.
02:04:44 <aryslan> i need to write a recursive descent parsing that able to parse the following grammar:       Program -> {VariableDefinition} {FunctionDefinition} Expr
02:04:58 <aryslan>    VariableDefinition -> let Identifier Expr
02:05:18 <aryslan>  FunctionDefinition -> define Signature Program
02:05:33 <aryslan> Signature -> Identifier ( {Identifier} )
02:05:48 <aryslan> Expr -> StringLiteral | Identifier | Application
02:05:56 <dudko> hi. i'm trying to define function extr. > :l sq.hs
02:05:56 <dudko> [1 of 1] Compiling Main             ( sq.hs, interpreted )
02:05:56 <dudko> sq.hs:23:25:
02:05:56 <dudko>     Couldn't match expected type `[Double]' with actual type `Bool'
02:05:56 <dudko>     In the second argument of `map', namely `(filter > 0 s)'
02:05:58 <dudko>     In the expression: map sqrt (filter > 0 s)
02:06:01 <dudko>     In an equation for `odmocniny':
02:06:03 <dudko>         odmocniny s = map sqrt (filter > 0 s)
02:06:05 <dudko> Failed, modules loaded: none.
02:06:11 <dudko> ups
02:06:14 <dudko> oops
02:06:15 <aryslan>  Application -> @pply FunctionName ( {Expr} )
02:06:17 <dudko> sorry
02:06:40 <aryslan> FunctionName -> Identifier | + | ~
02:06:42 <dudko> I just wanted to paste link. http://pastebin.com/uqX4Shaq#
02:06:44 <mauke> The paste uqX4Shaq has been copied to http://hpaste.org/53742
02:07:42 <silver> erm, try (filter (>0) s)
02:07:44 <danr> dudoku: extr s = map sqrt (filter (>0) s)
02:07:52 <danr> dudko: or extr = map sqort . filter (>0)
02:08:10 <min> :t \s > map sqrt (filter (> 0) s)
02:08:11 <lambdabot> parse error on input `>'
02:08:26 <dudko> silver: thanks.:)
02:09:29 <dudko> danr: pointfree looks fine, too. thanks.
02:12:14 <hpaste> aryslan pasted “haskell prog” at http://hpaste.org/53743
02:15:31 <hpaste> dudko pasted “toUpperStr” at http://hpaste.org/53744
02:16:03 <quicksilver> dudko: you need to import Data.Char in sq.hs
02:17:44 <dudko> quicksilver: I've tried to add "import Data.Char" into the script, but with the same result
02:18:15 <hpaste> dudko pasted “toUpperStr - result2” at http://hpaste.org/53745
02:18:38 <quicksilver> dudko: it has to be at the top of the script
02:18:47 <quicksilver> dudko: and that is not "the same result"
02:18:59 <quicksilver> dudko: how can you describe a complete different error message as the same result?
02:19:16 <dudko> quicksilver: oops:) that's true. then +- with the same result:)
02:20:16 <dudko> quicksilver: thanks
02:21:01 <quicksilver> good :)
02:21:22 <shachaf> quicksilver: Well, there are only two results: It works and it doesn't work. :-)
02:21:43 <dudko> shachaf: exactly:)
02:22:19 <dudko> does this channel have some log site?
02:23:09 <dudko> http://tunes.org/~nef/logs/haskell/
02:23:42 <min> aryslan: Do you understand how recursive descent parsing works? You can algorithmically construct a recursive descent parser from a context-free grammar (in your case, an EBNF specification). In your case, the task is simplified because you're only required to recognize strings, not return an abstract syntax tree. Which part in particular are you having trouble with?
02:24:29 <quicksilver> shachaf: on another channel on another network, the local bot responds to "doesn't work" with "Look buddy, doesn't work is a strong statement. Does it sit on the couch all day? Is it making faces at you? Does it want more money? Is it sleeping with your girlfriend? Please be specific!"
02:24:39 <ddarius> One of the main benefits of recursive descent is the relative ease of adding "semantic actions" such as building AST nodes to such parsers.
02:24:53 <aryslan> min: kinda don't know where to start
02:25:28 <aryslan> min: i understand how it work, but i am kinda new to haskell and having trouble with the syntax
02:26:33 <aryslan> min: i wrote a recursive descent parsing in java, that's achieve the same result, just can't seem to translate it to haskell
02:27:16 <oldwzd> aryslan: http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
02:32:28 <min> aryslan: If you understand how to construct the parser, but aren't familiar with Haskell's syntax, perhaps posting your progress on hpaste would prompt more help.
02:32:51 <aryslan> min ok
02:38:45 <sp3ctum> what is the use of exceptions in haskell?
02:39:00 <sp3ctum> from what i gather they are largely side effects in imperative code
02:39:52 <sp3ctum> and i've been reading these haskell books, lyah and rwh, and lyah barely touched on the subject while it spent quite a bit of time explaining monads
02:40:29 <shachaf> sp3ctum: There are several different kinds of exceptions.
02:40:32 <sp3ctum> i undestrand the Either monad can be used in place of an exception, also the Maybe monad ofc
02:41:27 <shachaf> Yes, that's one kind.
02:42:03 <shachaf> You can consider Nothing or Left to be an "exception" in a chain of code that terminates early as soon as it encounters one of those.
02:42:52 <sp3ctum> hmm, it's true that merely Maybe or Either will not stop execution. is this what exceptions are used for?
02:42:52 <shachaf> There are also IO exceptions, in IO, which behave kind of like exceptions in a normal imperative language.
02:42:58 <sp3ctum> ah, i see
02:43:39 <shachaf> sp3ctum: No, "exceptions" in the context of Maybe and Either don't refer to any magic property of the languag or anything.
02:44:03 <shachaf> > do { x <- Just 1; y <- Just 2; return (x + y) }
02:44:05 <lambdabot>   Just 3
02:44:09 <shachaf> > do { x <- Just 1; y <- Nothing; return (x + y) }
02:44:09 <lambdabot>   Nothing
02:44:17 <sp3ctum> yeah, i worded my message poorly
02:44:17 <shachaf> See, an exception.
02:44:28 <quicksilver> Mabye and Either certainly can "stop execution"
02:45:05 <sp3ctum> quicksilver, doesn't it depend on the functions they are passed to? they could easily continue execution if they received Nothing or Left foo
02:45:06 <shachaf> quicksilver: Well, only if you happen to be using functions that respect Nothing and Left in that particular way. :-)
02:45:18 <sp3ctum> ^yes
02:45:19 <quicksilver> try do { liftIO $ putStrLn "hello"; fail "stops here"; liftIO $ putStrLn "world" } in the ErrorT IO monad
02:45:33 <quicksilver> sp3ctum: yes, of course.
02:45:35 <sp3ctum> :t liftIO
02:45:36 <lambdabot>     Ambiguous occurrence `liftIO'
02:45:36 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
02:45:36 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
02:45:48 <quicksilver> but if you're using them "as exceptions" which is what I understood the context to be
02:45:51 <sp3ctum> :t Control.Monad.Logic.liftIO
02:45:53 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
02:46:03 <quicksilver> then they do indeed behave like exceptions.
02:46:39 <sp3ctum> true
02:47:02 <shachaf> Sure, but that's a property of the functions more than the data types.
02:47:07 <quicksilver> yes indeed.
02:47:19 <sp3ctum> >  try do { liftIO $ putStrLn "hello"; fail "stops here"; liftIO $ putStrLn "world" } in the ErrorT
02:47:19 <lambdabot>   <no location info>: parse error on input `do'
02:47:44 <sp3ctum> hmm :S
02:47:46 <quicksilver> sp3ctum: "try" and "in the ErrorT IO monad" were english, not haskell :P
02:47:56 <shachaf> And it won't work in lambdabot anyway.
02:47:57 <sp3ctum> ah :)
02:48:01 <shachaf> sp3ctum: I think you should learn the more fundamental parts of Haskell before worrying about this sort of thing.
02:48:05 <quicksilver> the haskell part was only do { ... }, and lambdabot isn't going to do the IO for you.
02:48:48 <shachaf> Just ignore "exceptions" and learn about functions and types and syntax and what not. :-) They're not a feature of the language itself anyway.
02:50:09 <sp3ctum> i hoogled 'exception' and read "In addition to exceptions thrown by IO operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the IO monad"
02:50:30 <sp3ctum> can you tell me if this has to specified in the function's type
02:50:55 <shachaf> Nope, these are evil exceptions that can't.
02:51:47 <shachaf> This isn't really something to worry about at this point. :-)
02:52:02 <sp3ctum> but doesn't that make the type declarations unreliable? e.g. any function can return/throw an exception instead of being pure?
02:52:19 <kmc> yep
02:52:25 <sp3ctum> i got interested when a coworker asked me to define exceptions in haskell
02:52:30 <kmc> but you can only catch exceptions in IO
02:52:42 <shachaf> sp3ctum: Want to hear something even worse?
02:52:49 <kmc> as far as pure computation is concerned, a function that throws an exception is like a function that enters an infinite loop
02:52:49 <sp3ctum> yes :D
02:53:00 <shachaf> Any function can just not terminate, if it feels like it.
02:53:05 <shachaf> And there's no way to tell from the type.
02:53:13 <shachaf> And there's no doing anything about it*.
02:53:39 <shachaf> Someone from #agda can fill in the footnote if they like.
02:53:55 <sp3ctum> how? infinite recursion or some evil blocking actions?
02:54:05 <kmc> infinite recursion would be the main way
02:54:23 <kmc> there are other things which are like exceptions but don't involve explicitly throwing
02:54:31 <kmc> like non-exhaustive pattern matching
02:54:49 <ddarius> shachaf: Or ##sql
02:54:52 <sp3ctum> yes
02:55:10 <shachaf> sp3ctum: From the point of view of pure code, undefined, infinite recursion, an incomplete pattern match, and so on are all equivalent.
02:55:21 <kmc> sp3ctum, the point is, a function which calls an infinite loop never sees it return.  a function which calls an exception-raising thing also never sees it return
02:55:34 <kmc> but in the latter case, an IO action can capture that exception and do something else
02:55:49 <sp3ctum> i see
02:56:10 <kmc> in fact GHC can convert some types of infinite looping or deadlock into catchable exceptions
02:56:47 <ddarius> An IO action could convert infinite loops to catchable exceptions.
02:56:47 <sp3ctum> thanks a lot for the explanations
02:58:02 <kmc> sp3ctum, now if you want to see something really magical, check out http://hackage.haskell.org/package/lub
02:58:21 <kmc> which has the ability to combine (3, <thing which raises exception>) and (<thing which raises exception>, 4) to get (3,4)
02:58:31 <kmc> you can't write a function like that in ordinary Haskell, though
03:00:02 <kmc> in fact it can combine (3, <infinite loop>) and (<infinite loop>, 4) to get (3,4)
03:00:19 <sp3ctum> i now understand exceptions being like special data types that can be caught in IO, and maybe somewhere else, and they can halt execution
03:00:29 <kmc> they can halt /evaluation/
03:00:36 <kmc> (also execution)
03:01:02 <sp3ctum> hmm, true. good point
03:02:07 <shachaf> The really dangerous kind are the ones that can halt evacuation.
03:03:03 <sp3ctum> can ghc automatically optimise pure code to be processed in parallel?
03:03:44 <shachaf> Well, it doesn't.
03:03:55 <kmc> sp3ctum, no
03:04:08 <shachaf> Theoretically it could, but it turns out to be tricky.
03:04:14 <kmc> but you can insert parallelism annotations
03:04:30 <sp3ctum> i see. i too would have thought it to be trivial
03:04:31 <kmc> which do not require creating threads and synchronizing them
03:04:57 <kmc> sp3ctum, it's easy to do /everything/ in parallel, but it's slower than the sequential code
03:05:11 <Eduard_Munteanu> DPH does attempt to parallelize heuristically, AFAIK.
03:05:16 <kmc> there's an optimal level of granularity at which to divide things
03:05:29 <kmc> and right now GHC leaves deciding that up to the programmer
03:05:33 <kmc> and it's tricky even to tune manually
03:05:37 <shachaf> Eduard_Munteanu: That's also not implicit automatic parallelization. :-)
03:05:47 <kmc> anyway http://hackage.haskell.org/package/parallel has the stuff for pure parallelism
03:05:56 <shachaf> kmc: There exist things that are tricky to tune manually but easy to automate, of course.
03:05:57 <sp3ctum> interesting that you say it's slower
03:06:17 <Eduard_Munteanu> shachaf: yes, but it's close.
03:06:18 <kmc> sp3ctum, there is overhead to parallelizing a computation
03:06:34 <kmc> sp3ctum, if you parallelize absolutely every evaluation in your program, you lose
03:06:36 <kosmikus> sp3ctum: it's very difficult to judge the amount of work that a particular computation takes. since most computations are trivial, it's not worth parallelizing them, as the overhead is too large. therefore annotations are needed.
03:06:36 <Eduard_Munteanu> Like... "go deep and parallel, but don't ask me about granluarity".
03:06:39 <kmc> because most evaluations are very quick
03:06:53 <shachaf> Eduard_Munteanu: Well, only for very particular types of code.
03:07:02 <kmc> sp3ctum, you can also fork concurrent threads of IO, which is a totally different mechanism
03:07:09 <kmc> and is more suitable to circumstances where you want threaded semantics
03:07:17 <shachaf> I wonder whether a JIT of some sort for figuring out a good parallelization granularity would work well.
03:07:19 <sp3ctum> yeah
03:07:50 * Eduard_Munteanu wonders whether GCC + graphite does that in AOT land already
03:08:17 <Eduard_Munteanu> Like, profile-guided autoparallelization.
03:08:39 <kosmikus> shachaf: there's a paper "Feedback directed implicit parallelism" that's describing an automatic approach based on information from the program itself
03:08:53 <kosmikus> shachaf: unfortunately, it's only moderately promising
03:11:43 <kosmikus> in addition, though, there's also an algorithmic problem. many programs in Haskell are traditionally written as linear list traversals. linear list traversals are, in general, not so easy to parallelize.
03:12:41 <shachaf> That part is kind of unfortunate.
03:16:02 <kosmikus> shachaf: it's a point rather nicely made by Guy Steele in his invited ICFP 2009 talk "Organizing Functional Code for Parallelization or: foldl and foldr Considered Slightly Harmful"
03:17:19 <shachaf> Wherein he recommends balanced trees instead, I suppose?
03:17:20 * Eduard_Munteanu wonders if there's anything like cost inference
03:18:10 <Ornedan_> Is it possible to give the GHC "-N" option at compile-time? I tried, but all I got was a binary that said "Most RTS options are disabled. Link with -rtsopts to enable them." when run
03:18:31 <kmc> did this work? ghc -with-rtsops="-N"
03:18:32 <Eduard_Munteanu> Say if you could guess the size of a term at compile time and decide whether it's worth parallelizing.
03:18:40 <Ornedan_> kmc: That's what I tried
03:18:48 <benny_> Ornedan_: to do that you need to specify -rtsopts as well
03:19:11 <kmc> shachaf, yeah.  well they don't have to be that balanced, even
03:19:17 <benny_> Ornedan_: ghc -rtsopts ...
03:19:28 <hpaste> lunaris pasted “Boxing tagless lambdas” at http://hpaste.org/53747
03:19:39 <lunaris> Hi all
03:19:59 <ddarius> Eduard_Munteanu: You can imagine all kinds of schemes to do such things, but doing it well is difficult and fragile.
03:20:08 <lunaris> I'm trying to write a finally tagless interpreter for some lambda-based language in the style of http://www.mail-archive.com/haskell-cafe@haskell.org/msg76764.html.
03:20:13 <benny_> Has anyone got a minute to explain combinators for me. I know what they are and how to use them, but why are they considered any different to normal functions? We already have the name 'higher order function' so we do we have the name 'combinator' as well?
03:20:21 <ddarius> Autoparallelism has its employment theorem.
03:20:23 <Ornedan_> Thanks. Now it works
03:20:27 <lunaris> But I'm not sure it's possible to box up such things.
03:20:52 <lunaris> benny_: http://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man might help.
03:20:59 <kmc> benny_, they are normal functions
03:21:27 * hackagebot transformers-base 0.3 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.3 (MikhailVorozhtsov)
03:22:02 <Eduard_Munteanu> ddarius: hm, true, but so does asm and microoptimization. I wonder if this issue won't be more easily dismissed in the future.
03:22:05 <lunaris> Ornedan_: You'll likely need -threaded too, in case you've omitted that.
03:22:20 <Ornedan_> I think the classification comes from the result type. In that you can feed back the result of using a combinator function to other combinator functions
03:22:28 <ddarius> benny_: There is a technical meaning to "combinator" but it is usually not what people mean.  As typically used, it's almost meaningless.
03:22:35 <benny_> kmc: I get this feeling about a lot of constructs. For example, people talk about DSLs, and I just see a module with some types and some functions, just like any other module, used in exactly the same way.
03:22:59 <Ornedan_> "higher order functions" do not necessarily have that property
03:23:14 * lunaris goes back to tagless hell
03:23:44 <ddarius> It vaguely suggests a particular perspective and style.
03:23:52 <Eduard_Munteanu> benny_: well, EDSL is just a name for domain-specific convenient API, you try to mimick a target language, but that's subject to limitations.
03:24:56 <benny_> Eduard_Munteanu: does that make the complex number module an EDSL? What about Data.Array? That module is in the domain of arrays and mimics set theory, so is it a EDSL? I recon you could call any module an EDSL
03:25:45 <Eduard_Munteanu> Presumably EDSLs try to mimick a language, like that BASIC stuff
03:25:57 <ddarius> That wouldn't really be an EDSL.
03:26:04 <ddarius> At least, it isn't a DSL.
03:26:08 <Eduard_Munteanu> Well, not DS
03:26:17 <kmc> benny_, you are correct, there are no sharp lines
03:26:29 * hackagebot transformers-abort 0.3 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.3 (MikhailVorozhtsov)
03:26:31 * hackagebot monad-abort-fd 0.3 - A better error monad transformer  http://hackage.haskell.org/package/monad-abort-fd-0.3 (MikhailVorozhtsov)
03:26:33 * hackagebot data-timeout 0.2 - 64-bit timeouts of nanosecond precision  http://hackage.haskell.org/package/data-timeout-0.2 (MikhailVorozhtsov)
03:26:35 * hackagebot posix-timer 0.3 - Bindings to POSIX clock and timer functions.  http://hackage.haskell.org/package/posix-timer-0.3 (MikhailVorozhtsov)
03:26:47 <ddarius> benny_: What's the difference between a "framework" and a "library" ?
03:26:49 <kmc> "EDSL" is a fuzzy philosophy about how to design libraries
03:27:00 <kmc> it's not a hard technical thing
03:27:15 <kmc> there are various technical traits which are more common in things advertised as EDSLs than not
03:27:22 <kmc> but no one trait is definitive
03:27:43 <kmc> (Array mimics set theory?)
03:27:51 <shachaf> @wn framework
03:27:54 <lambdabot> *** "framework" wn "WordNet (r) 2.0"
03:27:56 <lambdabot> framework
03:27:56 <ddarius> Yeah, that was from left field.
03:27:58 <lambdabot>      n 1: a simplified description of a complex entity or process;
03:28:00 <lambdabot>           "the computer program was based on a model of the
03:28:02 <lambdabot>           circulatory and respiratory systems" [syn: {model}, {theoretical
03:28:04 <lambdabot> [6 @more lines]
03:30:35 <kmc> benny_, if you really want to see all the lines melt away, you should learn lisp :D
03:31:24 <quicksilver> ddarius: a framework is a russian reversal of a library.
03:32:02 <benny_> kmc: I always thought a DSL was about syntax - you use syntax to describe something more elegantly that you can do with a library. And Haskell and LISP DSLs don't have that at all!
03:32:28 <ddarius> SQL is not just another syntax.
03:32:43 <kmc> benny_, they both do
03:32:50 <ddarius> Also, SQL is often not more elegant than what could be done with a library.
03:33:04 <ddarius> (But that is missing the point.)
03:33:06 <benny_> ddarius: but you could write SQL in Haskell using Haskell syntax, with the same engine and semantics underneath both, but it would not be as elegant.
03:33:28 <kmc> benny_, Haskell EDSLs often define infix operators, override existing operators in type classes, override the "do" notation, etc.
03:33:31 <kmc> all of which is syntactic
03:33:37 <ddarius> benny_: Why do you think it would not be as elegant?
03:33:46 <kmc> Lisp EDSLs define lots of new syntax
03:34:13 <fabjan> there is no way to do SQL elegantly
03:34:24 <benny_> kmc: They define new functions, but the syntax - prefix application - stays the same
03:34:38 <kmc> benny_, that's only the most superficial layer of what is properly called syntax
03:34:48 <kmc> i might as well say "the syntax -- Unicode characters in a text file -- stays the same"
03:34:49 <ddarius> Also there are reader macros so that's not even true.
03:35:33 <ddarius> At any rate, the point of a DSL, particularly as juxtaposed against an EDSL, is not just syntax.
03:35:45 <kmc> the syntax of Lisp -- and of every Lisp EDSL -- is primarily a description of how to interpret certain trees of atoms as programs or some other thing
03:36:05 <kmc> both Lisp's advocates and its detractors consistently miss this point
03:36:34 <benny_> kmc: if I define an operator x **--** y, for example, that's not new syntax, because that's the way that haskell syntax already works, with infix functions working as operators, you can't add new syntax in haskell without some kind of preprocessor. otherwise you're using the existing constructs in the standard way, so it's not new
03:36:39 <ddarius> But kmc brings us the Truth.
03:36:54 <fabjan> a language is not just syntax
03:36:57 <quicksilver> you're both right.
03:37:21 <quicksilver> it is new syntax, but of course it doesn't change syntax "more than you can do with a library"
03:37:30 <quicksilver> in haskell, an EDSL is precisely a library.
03:37:46 <quicksilver> in lisp too as long as you don't abitrarily say libraries aren't allowed to set up new macros.
03:37:59 <quicksilver> "more than you can do with a library" is a strange benchmark IMO.
03:39:03 <sipa> what distinguishes an EDSL from just any library is the fact that it tries to present a concise a domain-specific subset that can be understood as a separate language
03:39:47 <quicksilver> yes
03:41:33 <sipa> so it is more a property of intention than of objectively-measurable expressivity it brings
03:41:46 <kmc> yeah
03:41:49 <kmc> too bad benny_ left
03:41:53 <sipa> oh
03:41:54 <sipa> dang
03:42:24 <_Vi> Is there something like reverse of "pointfree" tool that converts [point-free] expression to form that avoids more complicated things like "join", "=<<" and others (heuristically)?
03:42:37 <kmc> @unpl join f . g
03:42:37 <lambdabot> (\ c -> (f >>= \ d -> d) (g c))
03:51:15 <_Vi> "unpl" only makes things even more complex. I'm expect it to traverse equivalent expressions and choose the "simplest" (by some metric) from them. Like "FullSimplify" from Mathematica
03:52:24 <quicksilver> _Vi: unpl is 'simplest' by some metric.
03:52:30 <quicksilver> _Vi: pl is 'simpest' by another metric
03:52:35 <quicksilver> sounds like you want a third metric though :)
03:54:08 <_Vi> quicksilver, The metric should be to minimize length (in tokens) of result and minimize usage of (for example), higher order functions like fmap, ">>=", ".".
03:54:51 <_Vi> Somethings like automatic "Please explain this expression in simple terms".
03:59:42 <shachaf> _Vi: One issue is that many of those functions are polymorphic, so it's easy to convert an expression to use them but not easy to convert back.
03:59:43 <kmc> those two goals are rather in conflict
04:00:27 <ibid> no, it's just a multiobjective problem
04:00:47 <ibid> however, multiobjective optimization requires decision-maker interaction for best results
04:01:45 <erus`> can ghc translate not . not into id?
04:01:49 <ibid> (or the tool could just enumerate the pareto set, of course)
04:01:56 <_Vi> ibid, Is there ready-made expression traverser where I can put my own metric and it will return the optimal one?
04:02:09 <ibid> _Vi: not that i am aware of
04:03:09 <Saizan> if unpl was type-directed it'd be easy to do what _Vi wants
04:04:10 <ddarius> erus`: I'd imagine it does.  It should be a straightforward case-of-case optimization.
04:08:34 <ddarius> not (not b) ~> case (case b of True -> False; False -> True) of True -> False; False -> True ~> case b of True -> case True of { True -> False; False -> True}; False -> case False of { True -> False; False -> True } ~> case b of True -> True; False -> False ~> b
04:08:58 <aszlig> hm, anyone here interested in a haskell/erlang job based in augsburg/germany?
04:09:00 <Entroacceptor> Yes.
04:09:16 <Entroacceptor> (that was to ddarius)
04:09:25 <aszlig> Entroacceptor: that's what i assumed ;-)
04:10:02 <Entroacceptor> I'd even be interesteed in the job if I knew enough haskell and any erlang :)
04:10:08 <luite_> aszlig: what kind of job / industry, other qualifications required?
04:11:10 <aszlig> luite_: gaming industry, other qualifications are just optional, at least the person should be familiar with linux/bsd/unix-environments
04:11:29 <aszlig> oh, and it's for a full-time (optionally, part-time) employment
04:12:57 <luite_> ah interesting, more haskell games :)
04:13:30 <luite_> this isn't joyride labs right?
04:13:30 <aszlig> and unfortunately it's necessary to move to augsburg/germany :-/
04:14:04 <aszlig> nah, they're in berlin
04:14:12 <kmc> "Augsburg is the only German city with its own legal holiday, the Augsburger Hohes Friedensfest, celebrated on August 8 of every year. This gives Augsburg more legal holidays than any other region or city in Germany."
04:14:21 <luite_> hehe I'd love to move closer to the south for skiing and mountainbiking :P
04:14:21 <aszlig> we're (redmoon studios) at augsburg
04:15:32 <aszlig> s/at/in/ ;-)
04:18:25 <kosmikus> aszlig: interesting, I'm in Regensburg
04:19:19 <Eduard_Munteanu> aszlig: you should probably mention whether Erlang is a requirement, or if it's either a Haskell *or* Erlang job.
04:19:32 <aszlig> it's haskell _or_ erlang
04:20:07 <aszlig> if it's both that's a plus
04:20:20 <Eduard_Munteanu> Well, yeah, I guess so :)
04:21:12 <aszlig> kmc: oh, regarding the friedensfest... we're actually in gersthofen, that's not officially part of augsburg, so the holiday doesn't count there
04:21:21 <kosmikus> aszlig: if you're doing Haskell in Augsburg, you should consider coming to the next Munich Haskell User Group meeting
04:22:21 <quicksilver> ddarius: not with variables, I suspect.
04:22:37 <quicksilver> ddarius: hmm, scrolled way up. never mind.
04:23:39 <aszlig> kosmikus: nov 29... hm... i guess i'm in :-)
04:23:52 <kosmikus> aszlig: great.
04:24:41 <kosmikus> aszlig: you want to hire an employee, I guess, and not a consultant?
04:25:51 <aszlig> kosmikus: yah, as said, it would be for employment...
04:26:40 <aszlig> and about 60% to 100% (that is to be decided) will be open-source
04:27:40 <Eduard_Munteanu> Interesting.
04:27:40 <luite_> oh that's great. what kind of thing will the open source part be? web related? frp?
04:28:00 <kosmikus> aszlig: then I can't directly help you, even though it sounds very interesting. but you should send a mail to the Haskell list (if you haven't already), and perhaps to the mailing list mentioned on the Haskell Munich site, too
04:29:29 <aszlig> mhm... but as said, if there's a community in munich, i guess i'll go to the next haskell user group meeting
04:30:44 <aszlig> at least i'm not sure if external consultants are allowed (the whole project is part of ZIM -> http://www.zim-bmwi.de/
04:30:54 <kosmikus> aszlig: I'll try to be there too. Although Regensburg-Munich is always a bit far already.
04:31:54 <kosmikus> aszlig: oh, interesting.
04:35:43 <Arnar> hey there, I could use some help troubleshooting a scratchpad
04:36:01 <Arnar> I've set up the key and manage hook, but nothing happens when I press it :/
04:36:09 <Arnar> any way I can see what is going on?
04:37:23 <opqdonut> in xmonad? you might get more help from #xmonad...
04:37:30 <Arnar> woops
04:37:32 <opqdonut> but have you remembered add the management hook?
04:37:46 <Arnar> I meant to ask in #xmonad, but yes, the manage hook is there
04:37:54 <Arnar> moving to #xmonad :P
04:45:08 <robbert> does anyone know about work on zippers for mutually inductive types?
04:48:11 <quicksilver> robbert: it's not hard
04:48:18 <quicksilver> robbert: you just have mutually recursive zippers
04:49:15 <kosmikus> robbert: check the zipper library on Hackage
04:50:54 <kosmikus> robbert: there are other approaches, too. "syz" is one. and there seems to be "pez", too, which is rather recent. I haven't looked at it.
04:51:36 * hackagebot hstyle 0.2.0.3 - Checks Haskell source code for style compliance.  http://hackage.haskell.org/package/hstyle-0.2.0.3 (JasperVanDerJeugt)
04:54:05 <robbert> quicksilver: following Huet's paper I tried the following, given mutual inductive types A and B, I mutually define a type Apath and Bpath, but then my location becomes of the shape Either (A * APath) (B * Bpath) which is quite inconvenient... I suppose I'm doing it too naively.
04:54:09 <robbert> kosmikus: I am going to check out those libraries!
04:55:26 <kosmikus> robbert: I think (but I'm biased) that the "proper" way to do it is to view mutually recursive datatypes as an indexed fixed points on a family of datatypes. Then everything else follows from there.
04:56:12 <kosmikus> robbert: That's essentially the approach taken in the "zipper" library I mentioned. It's all a bit cluttered because there's a lot of type-level programming in Haskell. I see you're on #agda, too. Much easier to do in Agda.
05:11:36 * hackagebot safecopy 0.6.0 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.6.0 (DavidHimmelstrup)
05:11:38 * hackagebot acid-state 0.6.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.6.0 (DavidHimmelstrup)
05:17:13 <robbert> kosmikus: I tried something similar already. But my lack of experience with Haskell made me fail there.
05:17:25 <robbert> Coq and Agda are indeed a lot nicer to do these kind of things.
05:17:42 * robbert is going to read "Generic programming with fixed points for mutually recursive datatypes" by Rodriguez et al.
05:20:19 <Kus1> why does this give me a parse error: "eachFeuille :: [(Int)] -> (Int, Int, Int)"
05:20:29 <roconnor__> @where TTFP
05:20:29 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
05:21:06 <hpc> Kus1: [Int]
05:21:29 <hpc> Kus1: dunno why it panics when it sees those parens, but the rest of it looks right
05:21:37 <Kus1> hpc with [Int] -> (Int, Int, Int)  too
05:21:52 <hpc> Kus1: then it is probably something on the lines above it
05:22:11 <hpc> Kus1: or are you entering this into ghci?
05:22:59 <Kus1> hpc: yeah, i am loading the hs file into ghci
05:23:31 <hpc> @where hpaste
05:23:31 <lambdabot> http://hpaste.org/
05:23:33 <sipa> Kus1: can you paste the code somewhere?
05:24:37 <Kus1> hpc: http://pastebin.com/2vZwEc6S
05:24:51 <mauke> The paste 2vZwEc6S has been copied to http://hpaste.org/53751
05:25:19 <Kus1> there is a "(" left of maximum ;(
05:26:11 <hpc> Kus1: also, function application in haskell is
05:26:27 <hpc> is "length a", not "length(a)"
05:26:41 <kosmikus> robbert: http://dreixel.net/research/pdf/gpif.pdf also has something on zippers (in Agda)
05:27:00 <hpc> and you should have the [] pattern first, because patterns are in order from top to bottom
05:27:24 <hpc> it will match against 'a' because pattern variables match everything, and then never see the [] case
05:28:29 <Kus1> hpc: thanks, this is my 2nd day at haskell
05:32:10 <robbert> kosmikus: thanks!
05:39:14 <mrakan> When implementing a (trim :: Int -> [a] -> [a]) function, is it better to make it (trim n xs = drop n $ take (length xs - n) xs), or use a (reverse . drop n . reverse . drop n) chain?
05:41:37 * hackagebot network-stream 0.1.0 - ByteString and Text streams for networking  http://hackage.haskell.org/package/network-stream-0.1.0 (JaredHance)
05:41:46 <ClaudiusMaximus> > let n = 3 ; xs = "hello world" in drop n $ zipWith const xs (drop n xs)
05:41:47 <lambdabot>   "lo wo"
05:42:16 <kmc> mrakan, define "better"?
05:42:27 <kmc> the code looks nicer in the second case
05:42:31 <kmc> i think the first one will run faster
05:42:34 <kmc> you could check that with Criterion
05:42:42 <kmc> in general this isn't an operation one expects to do efficiently for lists
05:42:47 <mrakan> kmc: Yes, you're right, I just checked and the first one does run much faster.
05:42:51 <kmc> so either your lists are small and it doesn't matter, or you should switch to another data structure
05:43:05 <mrakan> ClaudiusMaximus: Nice!
05:43:51 <ClaudiusMaximus> mrakan: i picked up that idea from someone else here, forgot who exactly..
05:44:28 <joab> How can I use Data.SegmentTree to store additional data with each interval? I have for example [(1,2,"Some value"), (2,3,"Other value")]. http://hackage.haskell.org/packages/archive/SegmentTree/0.2/doc/html/Data-SegmentTree.html
05:44:48 <pfo> i'm trying to install GHC 6.10.4 x86_64 bin release on a SLES11 box and the make install fails with this: http://pastebin.com/hrvKqBVY
05:44:49 <pfo> any ideas?
05:44:50 <mauke> The paste hrvKqBVY has been copied to http://hpaste.org/53753
05:44:59 <pfo> i need 6.x to bootstrap 7.2
05:45:17 <joab> I'm probably missing something really basic. Just starting out with haskell.
05:47:15 <hpaste> joab pasted “SegmentTree” at http://hpaste.org/53754
05:48:40 <joab> I've gotten it to work with simple list of tuples like this: getIntervals [(1,2),(1,3),(3,4)] [4, 3]
05:49:02 <Botje> heh. stabbingQuery.
05:49:07 <monadic> pfo: What is SLES? (don't know many acronyms ;( )
05:49:24 <pfo> suse linx enterprise server
05:50:26 <monadic> hmm.
05:50:31 <pfo> anyway - what is this "c" supposed to be? so intermediate bootstrapping product ?
05:50:38 <monadic> isn't 6.10 rather old anyway?
05:50:39 <joab> What I'd really like is this: getIntervals [(1,2,"foo")] [1] -- return foo
05:50:55 <monadic> @pfo I think it is cminusminus compiler
05:50:55 <lambdabot> Maybe you meant: bf do ft pl
05:50:59 <gienah> pfo: there are some binaries for 6.10.4 here: http://www.haskell.org/ghc/dist/6.10.4/
05:51:17 <ClaudiusMaximus> joab: it looks to me like the package doesn't expose enough to actually let you supply tags for each interval, though i've never used it
05:51:18 <pfo> gienah: this is where i dl'd from.
05:51:23 <monadic> pfo: You should go with 7.x anyways it really is better
05:51:41 <pfo> no question about that. but i'm having trouble building 7.2 from sources
05:51:48 <joab> ClaudiusMaximus: Oh. Ok. Thanks :)
05:52:04 <gienah> pfo: maybe try building it with ghc 6.12.3: http://www.haskell.org/ghc/dist/6.12.3/
05:52:11 <monadic> pfo: Seems like you are having trouble with 6.10 too.
05:52:19 <monadic> I would install 6.12 to bootstrap 7.2
05:52:28 <erus`> what does pipes around a variable mean in maths. e.g. |A| ?
05:52:42 <Botje> absolute value, most of the time.
05:52:51 <Botje> or vector length.
05:52:52 <o-_-o> If I have something like b = Data.Vector.Unboxed.fromList [3,3,5,7,34,2,4,6,76] and I want to call the sort function in this page http://hackage.haskell.org/packages/archive/vector-algorithms/0.3.2/doc/html/Data-Vector-Algorithms-Intro.html, how would I do it ?
05:52:53 <monadic> erus`: Magnitude
05:52:53 <Eduard_Munteanu> erus`: absolute value, or cardinality if A is a set
05:53:11 <erus`> vector length makes sense in the context
05:53:18 <pfo> 7.2.1 configure fails with this: http://pastebin.com/vpxDhfns
05:53:19 <monadic> |a|^2 = a conj(a)
05:53:19 <mauke> The paste vpxDhfns has been copied to http://hpaste.org/53755
05:53:22 <pfo> which is creeping me out
05:53:23 <geekosaur> the "c" looks to me like configure didn't find the bootstrap compiler correctly
05:53:39 <Eduard_Munteanu> Length is an extension of absolute value anyway.
05:53:45 <monadic> pfo: You need a ghc to compile ghc.
05:53:57 <pfo> providing sane target, build, host doesn't help.
05:54:09 <monadic> pfo: You need to download a 6.12 binary
05:54:15 <pfo> yeah, that's what i figured too and got the 6.10 binary release
05:54:37 <monadic> pfo: Try 6.12?
05:54:49 <monadic> pfo: What you were doing with 6.10 didn't look like a binary
05:54:49 <pfo> i'm going to give 6.12 a shot
05:55:52 <pfo> i just ran ``make install' after untaring  and ./configure --prefix'ing.
05:57:25 <ClaudiusMaximus> joab: maybe you could expose more by cabal unpack ; edit the .cabal file to move the Other-modules: to exposed-modules: and bump the version with a .1 at the end, then cabal install from that directory - or send a mail to the maintainer
05:57:48 <monadic> pfo: Hmm, weird.
05:58:37 <joab> ClaudiusMaximus: I wouldn't know how to begin even if it did expose the right things :/
05:59:36 <monadic> pfo: Doesn't your distribution provide ghc packages?
06:00:07 <pfo> erm nope - it's actually for a large HPC cluster where software is generally rolled from source due to multiple tool chains etc.
06:00:23 <pfo> and it's a installation for the nodes that resides on a parallel file system
06:00:41 <monadic> pfo: if software is generally rolled from source you ought to just use a source-based distribution :P
06:00:44 <pfo> so no way go with a distro package and novell doesn't package GHC.
06:00:55 <pfo> monadic: i did but that is even worse :P
06:01:16 <monadic> pfo: Well _my_ ghc compiled correctly so... :P
06:01:46 <pfo> well it is a build system/config issue when rolling from source - it would  compile probably  :P
06:05:35 <pfo> the 6.12.3 binary installs just fine
06:05:38 <pfo> thanks
06:05:42 <monadic> pfo: Neat.
06:06:03 <monadic> pfo: So now just bootstrap that 7.2 :)
06:06:09 <monadic> Anyone know when 7.4 is slotted to be released?
06:06:23 <monadic> I'm interested in the new "more consistent" profiling
06:06:30 <pfo> are there any environment variables besides path and manpath that need to be set for a correct ghc installation?
06:07:00 <monadic> pfo: Doubtful
06:07:13 <monadic> pfo: The configure step should tell you regardless.
06:08:17 <monadic> pfo: The only docs that the Building guide say is to ./configure && make && make install
06:12:07 <andras> hi everyone, I'm looking for a website that I found a while ago and I simply can't remember what it was called:
06:13:24 <andras> it allowed me to enter a piece of Haskell code (usually starting with something like "import Graphics" or so) which then created a plot in another frame on the push of a button using some primitives such as "circle" in the Haskell code
06:13:33 <andras> does anyone know what I'm talking about?
06:14:00 <Kus1> http://pastebin.com/2PSTaWLT
06:14:02 <mauke> The paste 2PSTaWLT has been copied to http://hpaste.org/53756
06:15:05 <Kus1> if i launch "fringe koks" i get back a array of [Int], and if i give it as a parameter for test it works but "test (fringe koks)" does not
06:15:18 <koala_man> andras: could it be http://dac4.designacourse.com:8000/ ?
06:15:51 <andras> koala_man: yeah, that's the one, you just saved me day! thank you a lot!
06:16:11 <andras> %s/me/my/
06:16:16 <lep-delete> andras: http://dac4.designacourse.com:8000/ ?
06:16:21 <lep-delete> argh
06:16:23 <lep-delete> too slow
06:17:48 <gienah> andras: this is probably the wrong site: http://tryhaskell.org/
06:18:06 <sipa> Kus1: test takes a [[Int]]. you give it a [Int]
06:18:14 <o-_-o> Hello Can anyone tell me how to feed a type of Vector Double to the sort function on this page ? http://hackage.haskell.org/packages/archive/vector-algorithms/0.3.2/doc/html/Data-Vector-Algorithms-Intro.html
06:18:30 <sipa> Kus1: oh, i'm wrong
06:19:38 <sipa> Kus1: ghci defaulted to Integer instead of Int
06:19:52 <sipa> as you never said what type koks is
06:26:10 <Dodek> i've seen some people calling expressions like [ x * x | x <- [1..]] "ZF-expressions"
06:26:18 <Dodek> i wonder what's the etymology of this term
06:26:26 <ski> they are usually called "list comprehensions"
06:26:31 <Dodek> does ZF stand here for zermelo fraenkel?
06:26:36 <Dodek> ski: yeah, i know
06:27:00 <byorgey> Dodek: hmm, I'd never heard of that
06:27:05 <ski> in math, `{ x : |R | x^2 = 0}' things are often called "set comphrenesions"
06:27:12 <kmc> yeah, it probably refers to the axiom of comprehension in ZF set theory
06:27:19 <kmc> did Z and/or F invent that notation?
06:27:22 <ski> ZF would probably refer to Zermelo-Frnkel, yes
06:27:23 <Dodek> ski: yeah, but this notation has nothing to do with ZF set theory
06:27:30 <ski> kmc : not that i know of
06:27:37 <byorgey> Dodek: looks like it comes from David Turner
06:27:42 <byorgey> inventor of Miranda
06:27:52 <byorgey> and yes, it does stand for Zermelo-Fraenkel
06:27:58 <Dodek> byorgey: actually, i've read it in miranda context
06:28:08 <Dodek> byorgey: okay, thanks
06:46:37 * hackagebot xml-enumerator 0.4.3.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.3.2 (MichaelSnoyman)
06:55:59 <dgpratt> installing arch presently...feeling very hard-core...and also a little frightened
06:58:51 <Cale> dgpratt: I'm gonna install Debian once I have some free time. I will feel significantly less hard-core and frightened. (Especially given that I ran Debian for 6 or 7 years before I started running Ubuntu :)
06:59:09 <dgpratt> Cale: :)
06:59:29 <kmc> i've been hearing a lot of bad things about Ubuntu lately
06:59:43 <koala_man> just lately?
07:00:25 <dgpratt> Cale: what's your current OS?
07:01:25 <Cale> Ubuntu. I've decided that I'm not putting up with any more of their bullshit upgrades and I'm switching back to Debian, so I bought a new 2TB disk to make the install easy, and it's just sitting on my shelf until I have some free time on the weekend.
07:03:33 <Cale> The direction that Ubuntu's configuration (the only thing which sets it apart from Debian) has been taking has perhaps been fine for a certain set of users, but it's been consistently moving away from how I want my machine set up for the last several versions, and it's becoming more and more work. Having to recompile packages with different configuration to make my sound setup work on every upgrade is unacceptable to m
07:03:33 <Cale> e, and lately I've been having weird graphical problems with X.
07:04:41 <Mkman> Cale: try gentoo :)
07:04:43 <Cale> (compiz had bugs where YouTube could cause it to freeze, so I switched back to metacity, and now I get random rectangles of my background blitted on top of my windows occasionally)
07:05:00 <Cale> Mkman: Well, that is far less acceptable.
07:05:13 <Mkman> LOL
07:05:19 <Mkman> gentoo is pretty cool
07:08:01 <Nimatek> Mint does it better and will probably diverge from Ubuntu and maintain its own debian build.
07:10:54 <kmc> gentoo is cool if you have a lot of time on your hands
07:11:02 <kmc> i learned a lot by running gentoo way back when
07:26:37 * hackagebot geniplate 0.6.0.0 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.0 (LennartAugustsson)
07:32:45 <_Vi> Is there an operator that is like "$", but with reversed argument order? Like ' "string"   |   (\x->concat["333",x])  |  length'.
07:33:07 <cheater> yes it's called bind
07:34:01 <Cale> _Vi: not really
07:34:05 <Cale> _Vi: But you could make one
07:34:52 <_Vi> Cale, Of course. But there is no such customary thing, isn't there?
07:35:03 <Cale> _Vi: Not to the best of my knowledge
07:37:06 <ski> _Vi : i've sometimes called that `>$'
07:37:36 <hpc> _Vi: ive seen several libraries that call it (#)
07:37:48 <hpc> > let x # f = f x in x # f
07:37:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:37:52 <lambdabot>    `SimpleReflect.FromExpr ...
07:37:55 <hpc> > let x # f = f x in x # f :: Expr
07:37:56 <lambdabot>   f x
07:38:04 <hpc> > let x # f = f x in x # f # g :: Expr
07:38:05 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:38:05 <lambdabot>    `GHC.Show.Show t'
07:38:05 <lambdabot>      a...
07:38:07 <hpc> arg
07:39:55 <ski> > let infixl 0 #; x # f = f x in x # (f :: Expr -> Expr) # (g :: Expr -> Expr)
07:39:57 <lambdabot>   g (f x)
07:41:54 <copumpkin> preflex: seen kirindave
07:41:54 <preflex>  kirindave was last seen on #haskell-blah 1 day, 21 hours, 24 minutes and 29 seconds ago, saying: Sosoon?
07:45:28 <_Vi> How to declare a thing in "ghci" to make it persist in this ghci session?
07:45:50 <ski> ?
07:45:57 * ski doesn't understand the question
07:46:37 <_Vi> ski, When I try to do things like "f x = x + 1" in ghci it complains on "=".
07:46:37 * hackagebot hpodder 1.1.6 - Podcast Aggregator (downloader)  http://hackage.haskell.org/package/hpodder-1.1.6 (JohnGoerzen)
07:46:47 <deggis> _Vi: prefix that line with let
07:47:06 <tac-tics> _Vi: In GHCi, you need to use the let keyword before any definitions.
07:47:14 <_Vi> deggis, OK. Why this "let" is not implied when it see "="?
07:47:20 <tac-tics> That would work fine in actual haskell source code, but in GHCi, you need let
07:47:31 <tac-tics> It's just a quirk
07:47:46 <tac-tics> (And in lambdabot, you can use @let)
07:47:51 <tac-tics> @let f x = x + 1
07:47:53 <lambdabot>  Defined.
07:47:54 <tac-tics> > f 0
07:47:55 <lambdabot>   Ambiguous occurrence `f'
07:47:55 <lambdabot>  It could refer to either `L.f', defined at <local...
07:47:59 <_Vi> Are there deep underlying difference between "let f x = x+1" and "f x = x+1" in normal Haskell code?
07:48:01 <tac-tics> (close enough)
07:48:11 <ski> the things you enter in GHCi is more or less the commands that go into a `do'-expression (and some more commands)
07:48:36 <tac-tics> _Vi: the "let" variant is used inside another definition. Top level functions don't require it ever.
07:48:44 <ski> > do {x <- Just 2; let {y = x + x}; return y}
07:48:45 <lambdabot>   Just 4
07:49:41 <ski> _Vi : to a first approximation, GHCi takes expressions to evaluate, while you write declarations in a file : `f x = x + 1' is a declaration, not an expression
07:50:13 <ski> _Vi : to a second approximation, GHCi takes `do'-commands (including expressions, as well as `let blah = bleh' and `foo <- bar' commands)
07:50:40 <ski> > L.f 0
07:50:42 <lambdabot>   1
07:50:45 <ski> tac-tics ^
07:51:13 <_Vi> ski, What will fail if make it check for presence of "=" and assume it is declaration if true?
07:52:59 <ski> i'm not sure if anything will fail
07:53:54 <ski> error messages might get worse in cases where it can't determine if an expression or a declaration was intended
07:55:03 <_Vi> May be it should print a suggestion (like "Use 'let f x = x+1' if it meant to be declaration") when "parse error on input `='"?
07:55:32 <tac-tics> _Vi: That would probably be a nice feature request :)
07:58:09 <_Vi> tac-tics, Looking for ghci tracker -> "http://sourceforge.net/tracker/..." -> "Go to the new bug tracker" (http://cvs.haskell.org/...) -> 404 not found
07:58:39 <_Vi> 404 - bugs in Haskell are not found?
07:58:49 <tac-tics> There are no bugs in Haskell
07:59:10 <tac-tics> _Vi: http://hackage.haskell.org/trac/ghc/
07:59:46 <_Vi> http://sourceforge.net/tracker/?group_id=8032&atid=108032 should point there.
08:03:45 <_Vi> Looks like similar feature request is already there: http://hackage.haskell.org/trac/ghc/ticket/1388
08:05:11 <tac-tics> "milestone changed from 6.8 branch to _|_"
08:05:17 <tac-tics> What does that usually signify in GHC's trac?
08:05:25 <tac-tics> does that mean the feature was rejected?
08:05:28 <tac-tics> or just that no one is working on it?
08:26:29 <stepkut> is there an XML library that has functions like, toXML :: (Data a) => a -> Text and fromXML :: (Data a) => Text -> a
08:27:45 <Phlogistique> it would be Text -> Maybe a
08:27:47 <Phlogistique> at most
08:28:58 <stepkut> Phlogistique: true
08:30:18 <ClaudiusMaximus> hoogle search for xml returns 27 packages...
08:32:46 <Ke> how do I get rid of these when using forall
08:32:53 <Ke> "    The type signature for `createSyncKernel'"
08:32:53 <Ke>       lacks an accompanying binding
08:33:30 <Ke> using the function even once removes this, but it's no good for libs
08:33:51 <mm_freak> first c1 . second c2 = second c2 . first c1   ⇐ this is not an arrow law, because of side effects, right?
08:34:52 <mm_freak> Ke: createSyncKernel = undefined
08:35:36 <Ke> the function is defined already, I guess the generic forall is disliked by ghc
08:36:14 <mm_freak> Ke: that shouldn't have anything to do with the forall
08:36:37 <monochrom> check for typo?
08:37:31 <monochrom> you know it's very easy to write "createSyncKernel :: type sig here" and then "createSynKernel = definition here" and think you're done
08:39:58 <ClaudiusMaximus> mm_freak: i think you're right, the law in http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf p31 is   first f >>> second (arr g) = second (arr g) >>> first f
08:40:23 <Ke> hmm true, it was a typo
08:41:06 <Ke> thanks
08:41:14 <monochrom> yeah, give your compiler a bit more trust
08:41:46 <ClaudiusMaximus> -Wall would tell you that the typo'd version has no type signature
08:43:54 <mm_freak> ClaudiusMaximus: yeah, that makes more sense
08:44:04 <mm_freak> arr can't have side effects
08:44:17 <ClaudiusMaximus> yep, paper gives that rationale
08:46:59 <lpsmith> hmm,  is there a synchronous message passing scheme for Haskell?  I'm looking at CloudHaskell and I could use async to implement sync,  but the thing I don't like is the requirement that processes that can send and receive messages must be CloudHaskell processes.
08:48:06 <lpsmith> Basically,  I've decided to use a Haskell thread to represent a database connection... I'm not really opposed for making it a CloudHaskell process in my own apps,  but that might be less attractive to potential users.
08:48:35 <lpsmith> I mean, I suppose I could just use channels and whatnot
08:49:13 <monochrom> mvar is sync channel
08:49:53 <monochrom> sorry, mvar is a tiny step away from sync channel
08:51:41 * monochrom cheats! steals idea from gtk2hs's postSyncGUI
08:51:54 <lpsmith> :)
08:52:34 <edwardk> lpsmith: check back in with me in a month or so. something i'm working on may be appropriate ;)
08:52:56 <edwardk> shaving a slightly different yak at the moment though
08:52:56 <lpsmith> edwardk, cool :)
08:56:20 <Cale> lpsmith: So you want a kind of "stateful variable" where when you write to it, it blocks until some other thread reads, and vice versa?
08:56:31 <Cale> (and then both operations finish at the same time)
08:57:25 <ski> Cale : hm, a zero-buffer `Chan', a `SynchVar' thing ?
08:57:40 <XexonixXexillion> couldn't you just achieve that with a pair of MVars?
08:57:45 <Cale> ski: that's what I'm thinking
08:57:52 <Cale> XexonixXexillion: yeah, or maybe a nested MVar
08:57:53 <monadic> @seen bos
08:57:53 <preflex>  bos was last seen on #haskell 1 day, 51 minutes and 22 seconds ago, saying: monadic: just fixed that one. i'll look for other offenders later. thanks!
08:57:53 <lambdabot> Unknown command, try @list
08:58:13 <bos> wut?
08:58:35 <monadic> bos: Just seeing if you were here. Are you planning on updating RWH's thing where it uses uvector to use Vector? I was mentioned in comments
08:58:49 <monochrom> have mvars ack, dat initially empty. send msg = (putMVar dat msg; takeMVar ack). recv = (putMVar ack (); takeMVar dat)
08:58:51 <bos> monadic: not until i start a new edition
08:59:24 <Cale> Where a reader will put an MVar a into the MVar (MVar a), and then immediately try to read from it, and the writer will try to take the MVar (MVar a) and write a value into the MVar a
08:59:25 <monochrom> unless cloud haskell has something different from mvar
08:59:26 <copumpkin> bos: I thought you were talking about that recently
08:59:49 <ski> lpsmith : it sounds like a useful addition to the concurrency lib
09:00:17 <bos> copumpkin: yeah, but that doesn't mean i'm starting on it right away :-)
09:00:18 <lpsmith> I think what you want is MVar (a, Mvar b)
09:00:52 <kmc> Mu MVar!!!!!!!
09:00:57 <Cale> MVars are really quite flexible when it comes to schemes like this, if for no other reason that they're first class values and can be nested inside other concurrent datastructures.
09:01:03 <tac-tics> kmc: It's MVars all the way down!
09:01:04 * kmc has yet to discover a use for Mu MVar
09:01:09 <copumpkin> kmc is the master of Mu MVar
09:01:19 <copumpkin> kmc: I thought that's what you used
09:01:26 <tac-tics> kmc what about a Mu (\t -> MVar (Int, t))
09:01:29 <copumpkin> I wasn't actually present for that talk though
09:01:35 <monochrom> Mu MVar can be used to provide recursion :)
09:01:36 <kmc> the π-calculus thing used a Mu Chan
09:01:43 <copumpkin> oh, that's what I was thinking of
09:01:58 <sipa> Mum Var?
09:02:13 <ski> Cale : yeah, though it seems to be like `SynchVar' maybe should be implemented at the same level as `MVar', instead of above it
09:02:21 <copumpkin> wow, I had no idea that forkOn existed
09:02:24 <monochrom> yo mumvar
09:02:32 <Cale> ski: true
09:02:45 <Cale> ski: It might be possible to gain some efficiency that way
09:02:50 <shk> Hi, all
09:03:11 <Cale> There's probably also an easy implementation in terms of STM, but that's also probably not as efficient
09:03:16 <shk> Where can i find A comprehensive guide to the theory and practice of monadic programming in Haskell? I see 404 error in http://www.haskell.org/haskellwiki/All_About_Monads page
09:03:41 <Cale> shk: Maybe start with http://www.haskell.org/haskellwiki/Monads_as_computation
09:03:55 <Cale> (which is my little meta-tutorial)
09:04:06 <Cale> I also wrote http://www.haskell.org/haskellwiki/Monads_as_containers
09:04:11 <Cale> which provides another view
09:04:20 <monadic> shk: I like Real World Haskell's and there's also You could have invented Monad's which I thought was okay
09:04:31 <ski> shk : btw, if you really just want to know how to do `IO' atm, you probably want to look at another page
09:04:37 <Cale> If you're just looking to use IO, then don't worry about monads yet
09:04:41 <ski> (:
09:04:42 * monochrom likes Cale's MVar (MVar msg)
09:04:43 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO has a little intro ;)
09:04:50 <shk> Hello Cale, thank you for links,
09:05:11 <Cale> There are a bunch of other monad tutorials out there, only some of them are good.
09:05:40 <monadic> For IO I like the Yesod Book's 3 blog posts on Data.Enumerator :)
09:06:01 * monochrom recalls the old method of "to receive a FREE luck draw ticket, send us a stamped self-addressed envelope" - MVar (MVar ticket)
09:06:41 <shk> I read learn you haskell about monad, i think it was good start for beginners, and now i want to find more detailed information about monads from the practical side
09:06:41 <Cale> monadic: ;___; Data.Enumerator
09:07:06 <Cale> shk: Another thing to look into is Parsec
09:07:11 <XexonixXexillion> If you want a practical look at monads, real world haskell is a good start
09:07:26 <Cale> shk: I don't think I really "got" monads until I learned about parser combinator libraries
09:07:40 <shk> Cale: Yes, now I just versed with Parsec
09:07:45 <monochrom> yes, the parser monad was my last straw too
09:07:59 * ski thinks `;___;' looks like two persons carrying a stretcher
09:08:12 <Cale> shk: Basically, picking up examples of monads is probably more helpful than trying to study monads in general terms.
09:08:18 <monadic> I got it at State/Reader/Writer
09:08:28 <Cale> The monad interface is really simple and there's not a whole lot to really say about it
09:08:51 <Cale> What's interesting is in the wide range of examples
09:08:56 <monadic> The IO instance is so abstract that it doesn't really help too much
09:08:58 <Cale> and the details of their implementations
09:09:37 <monochrom> IO is also so implementation-detailed that it obscures
09:09:55 <monochrom> "miss the monad for the rts"
09:10:20 <Cale> (some of which end up being people's introduction to proper functional programming, in that they really use functions as data more than the average piece of code you'll bump into)
09:10:23 <monadic> Especially since IO cheats alot with all that Lazy IO/unsafeInterleaveIO
09:10:44 <ski> monadic : not to mention all that concurrency
09:11:01 <monadic> ski: And then unsafePerformIO on top of that ;)
09:11:15 <Cale> People often seem to get stuck on the implementation of the State monad for example, and end up thinking that monads are hard to understand, when what's really happening is that they're not used to functional programming yet :)
09:11:30 * ski still thinks `unsafe' should be dropped from `unsafeInterleaveIO'
09:11:30 <lpsmith> http://hpaste.org/53760
09:12:18 <lpsmith> there is a rough draft of an idea.  I didn't consider asynchronous exceptions,  and I'm not sure that the interface of "recv" is good enough to treat Call as an abstract type.
09:12:50 <hpc> ski: it technically still escapes the IO monad
09:13:09 <hpc> ski: it makes it so evaluating the value causes IO to happen
09:13:37 <hpc> it disconnects the side effects from the sequencing imposed by (>>=)
09:13:40 <Cale> unsafeInterleaveIO creates magical values that couldn't otherwise be obtained, and which to properly understand, you need to understand the operational semantics of GHC.
09:13:50 <Younder> Ahh the monad group..
09:13:56 <elliott> hpc: surely you know the standard responses to that by now :p
09:14:12 * ski thinks what matters is the abstract semantics, the operational details not so much
09:14:12 <lpsmith> Also,  how would I block taking an MVar or read from a handle,  and unblock once either one is available?
09:14:39 <elliott> lpsmith: two threads and another temporary MVar?
09:14:43 <Cale> lpsmith: use more than one thread
09:15:05 <Younder> Why use monads for everything when there are functional data structures?
09:15:06 <Cale> lpsmith: Our interface to select/kqueue/epoll is just doing stuff from multiple threads :)
09:15:07 <lpsmith> yeah,  I thought of that already.  Though I wonder if that's really the best solution.
09:15:12 <elliott> do { tmp <- newEmptyMVar; forkIO (takeMVar foo >>= putMVar tmp . Left); forkIO (readFromHandle >>= putMVar tmp . Right); x <- takeMVar tmp }
09:15:17 <lpsmith> I understand that =)
09:15:18 <ski> hpc : `forkIO' also does that
09:15:22 <hpc> Younder: because monads are functional data structures?
09:15:37 <hpc> ski: no it doesn't; the other thread happens whether you like it or not
09:15:50 <Younder> hpc no, they are a excuse
09:16:00 <Cale> Younder: You misunderstand the purpose of monads :)
09:16:07 <ski> hpc : to clarify, i was responding to your "it disconnects the side effects from the sequencing imposed by (>>=)"
09:16:21 <monochrom> unsafeForkIO
09:16:26 <hpc> ski: ah
09:16:26 <Cale> Younder: You might be better off asking "Why use the IO monad for everything when there are functional data structures?"
09:16:42 <Cale> Younder: That would be a valid complaint, but few people do this :)
09:16:47 <edwardk> Younder: many data structures _are_ monads
09:16:48 <Younder> Cale, I am fine with IO monads.
09:16:54 <elliott> <Younder> hpc no, they are a excuse
09:16:54 <hpc> ski: yeah, the main point was that performing IO becomes contingent on a pattern match, which is exactly what makes unsafePerformIO scary
09:16:58 <elliott> Younder: it sounds like you don't know what monads really are yet :)
09:17:00 <monadic> Why use monads when there are lists? OH WAIT
09:17:01 <Cale> Younder: There's no problem with, say, the list monad.
09:17:10 <copumpkin> ತ_ತ
09:17:20 <Cale> Younder: (which is just an abstract interface to list-comprehension-like computations)
09:17:26 <elliott> I use only data structures which admit Applicative but not Monad.
09:17:26 <ski> Younder : monads is just a handy way to do effectful programming in a pure language. the question of why use effects when one can use effect-free data structures is a valid one
09:17:29 <edwardk> Younder: lists are a monad for instance, but its also a 'functional data structure'
09:17:37 <Younder> Cale, again a list monad by it's nature is sequential
09:17:38 * monochrom takes the stance "why argue"
09:17:44 <hpc> > [x + y | x <- [1..5], y <- [10, 20]] -- Younder
09:17:46 <lambdabot>   [11,21,12,22,13,23,14,24,15,25]
09:18:05 <hpc> > do {x <- [1..5]; y <- [10, 20]; return (x + y)} -- Younder
09:18:06 <lambdabot>   [11,21,12,22,13,23,14,24,15,25]
09:18:13 <elliott> Younder: dunno what you mean by sequential. if you want something that proves monads aren't inherently "sequential", try the reverse state monad
09:18:23 <edwardk> there are monads for iterative deepening, tree grafting, etc. that aren't as sequential as this mental model you have
09:18:25 <hpc> Younder: or the Cont monad
09:18:26 <Cale> Younder: Well, it's only sequential in that you're making a sequence of choices. The evaluation of the resulting list takes on a completely different sequence of steps.
09:18:30 * ski assumes Younder already understands monads, and is asking about why use monadic interfaces so much
09:18:42 <elliott> > concatMap (\x -> map (\y -> x+y) [10, 20]) [1..5]
09:18:43 <lambdabot>   [11,21,12,22,13,23,14,24,15,25]
09:18:44 <elliott> lambdas are sequential!
09:18:47 <lpsmith> I mean, I know haskell threads are lightweight and all, it just still seems a bit more work than strictly necessary.
09:18:49 <dolio> Why use domain specific languages when you could not do that?
09:19:08 <Cale> Younder: The advantage of recognising that something is a monad is that you get all the nice functions in Control.Monad for free, and don't have to write them yourself as part of your library.
09:19:14 <elliott> lpsmith: you could abstract it -- switch :: [IO a] -> IO a
09:19:15 <hpc> why use ($) and id when you can use Identity?!
09:19:17 <geekosaur> to some extent, the list monad is sequential only because that happens to be the simplest implementation, not because it has to be a list instead of e.g. a bag
09:19:33 <lpsmith> elliott, I also don't think your solution is correct
09:19:35 <elliott> lpsmith: switch xs = do { result <- newEmptyMVar; mapM_ (forkIO . putMVar result) xs; takeMVar result }
09:19:41 <Cale> Younder: I don't think anyone is advocating that people set out to design their library in such a way that it be a monad from the outset. But monadic libraries are nonetheless common.
09:19:47 <elliott> lpsmith: hmm, I guess you need tryPutMVar
09:19:52 <elliott> so that the threads don't end up lying around dormant
09:20:05 <Cale> Younder: Monad is just a name for a pattern which occurs in some libraries' APIs quite naturally
09:20:23 <Cale> and when it does, we can take advantage of it, and get a bunch of useful machinery for free
09:20:30 <lpsmith> Well, the problem I see is that if both happens,  you take the MVar *and* read something from the handle,   then you could lose some data
09:20:55 <Cale> It has nothing to do with being imperative or "non-functional" -- indeed, most of these libraries are a tour-de-force of functional programming.
09:21:03 <elliott> lpsmith: hmm. that's not really avoidable is it?
09:21:15 <elliott> lpsmith: even C's select() can tell you both happened
09:21:25 <elliott> you can't psychically know whether there'll be data on the handle
09:21:31 <elliott> you can only try and read it
09:22:19 <Cale> Younder: The only way in which it's "imperative" to any degree in the general case is that do-notation looks vaguely like an imperative program, but that doesn't mean that the program you write using do-notation runs anything like an imperative program would.
09:22:45 <XexonixXexillion> There is a single thread solution to the MVar/handle problem, it just requires a busy loop, which is almost never ideal
09:22:46 <lpsmith> Well, it is avoidable.   If both happen, I won't care too much which event I get first,  but I can't lose the other event
09:22:53 <lpsmith> It still needs to be available later.
09:23:24 <monadic> Ha! Now I will never again be tagged whenever someone says "monadic"
09:23:30 <monadic> wait what
09:23:35 <monadic> My nick didn't change -.-
09:24:10 <elliott> lpsmith: How is it avoidable?
09:24:15 <elliott> lpsmith: You will need to maintain your own buffers.
09:24:18 <Cale> It desugars in terms of the operations defined for the monad in question, and those operations decide how the program actually runs, and are usually free of side effects (except in the case of IO, ST or STM being involved) and the evaluation may actually happen "out of order" to some extent with respect to the sequence that the do-notation specifies.
09:24:20 <lpsmith> by not losing an event :)
09:24:28 <elliott> That's a problem, not a solution.
09:24:37 <lpsmith> I'm aware.
09:24:54 <Cale> (to the extent to which the data dependencies don't force things to be computed in the same order)
09:25:05 <lpsmith> Select doesn't have that problem.  If two events happen, I can handle one, or both, and not lose them
09:25:24 <lpsmith> I can't prevent two things happening at once,  so I need to handle that case correctly :)
09:25:32 <Cale> You can have a "state monad" where the state flows backward in "time" from the place where you set it, so that a 'get' operation will get the state which is set by the *following* 'put'
09:25:41 <elliott> lpsmith: alright... then switch :: [IO a] -> IO [a]
09:25:51 <elliott> lpsmith: it kills each thread in sequence as soon as a single result comes in
09:25:53 <monochrom> monadic: were you in a channel that bans or quiets you? that would forbid changing nick
09:25:56 <elliott> whatever else comes in in the meantime is added to the list
09:26:23 <monadic> monochrom: I don't think so. I didn't even just "change" nicks, I completely got off IRC, changed my settings, reregistered a new nick
09:26:36 <monadic> I'm going to log out and log in, maybe telepathy needs to restart or something like that.
09:26:37 <monochrom> haha ok
09:27:20 <lpsmith> elliott, that still doesn't work
09:27:27 * monochrom will have to get used to the new nick of jhance :)
09:27:36 <elliott> lpsmith: well, what's wrong with that?
09:27:39 <jhance> oh hey so it did work :)
09:28:18 <jhance> monochrom: It could easily have been WordWow though; how'd you know?
09:28:18 <WordWow> jhance: o
09:28:34 <lpsmith> well,  hmm,  you might be able to make that work.  but that seems kludgy and inefficient
09:28:44 <monochrom> I track the ~jared@cpe-75-186-2-19.cinci.res.rr.com part
09:28:51 <jhance> monochrom: Uncool :P
09:29:07 <lpsmith> the type isn't quite right
09:29:20 <elliott> lpsmith: yep! but i think what you are trying to do is ugly.
09:29:28 <elliott> lpsmith: why not just fork two threads, each one blocks on the relevant events and handles it separately?
09:29:44 <elliott> rather than trying to emulate a low-level event interface on top of a threading interface on top of a low-level event interface :)
09:29:49 * monochrom might have said something like "I track your infrared signature" :)
09:30:05 * monochrom unsafeLaunchMissile
09:30:50 <jhance> unsafeLaunchMissile = unsafePerformIO launchMissile
09:30:57 <gtirloni> Cale: is it possible to have lambdabot lending a hand on #haskell-br ? :)
09:30:59 <jhance> so launchMissile itself is safe ;)
09:31:38 <XexonixXexillion> as safe as anything else in the IO monad
09:31:48 <jhance> gtirloni: Well it is open source so I would assume so, see http://www.haskell.org/haskellwiki/Lambdabot
09:32:55 <kmc> well it's much more convenient to get the existing lambdabot instance to join your channel
09:33:08 <gtirloni> yep
09:33:11 <lpsmith> elliott, well,  the problem is that I don't know which event is going to happen at any point in time,   and if something comes in on the MVar,  I need to use the handle that the other thread is blocked on.
09:33:31 <elliott> lpsmith: hmm. yuck.
09:33:40 <lpsmith> Honestly I'm not seeing a way around this issue at the moment
09:34:20 <elliott> i'd restructure things :P
09:34:24 <elliott> helpful, I know
09:35:29 <monochrom> how would you write it if select were available?
09:35:48 * monochrom asks because there are a lot of important details omitted
09:36:48 <XexonixXexillion> how about something like MVar (Either a Handle) perhaps? forkIO with both placing into the parent's MVar on becoming unblocked, read it, then tryTake it, then respond to it
09:39:14 <XexonixXexillion> sorry, should be take it, then tryTake it
09:39:26 <lpsmith> Yeah I'd have to see some code
09:39:53 <lpsmith> Actually I could write to the handle without a problem
09:40:11 <lpsmith> hmm
09:44:49 <Cale> lambdabot: @join #haskell-br
09:45:09 <Cale> gtirloni: I'll get it to join automatically if you like
09:45:12 <gtirloni> Cale: thanks!
09:45:14 <gtirloni> sure
09:49:00 <mots> hey, is there anything like "map", but for two lists?
09:49:10 <mots> i.e. apply a function two to elements of same indices?
09:49:16 <Eduard_Munteanu> mots: zipWith?
09:49:28 <Eduard_Munteanu> :t zipWith
09:49:29 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:49:35 <mots> Eduard_Munteanu: exactly
09:49:35 <mots> :D
09:49:41 <Cale> > zipWith (+) [1,2,3] [10,20,30,40]
09:49:42 <lambdabot>   [11,22,33]
09:49:47 <mots> thanks a ton
09:51:29 <smns> mots, I think zip == zipWith (,)
09:52:34 <_Vi> How to declare function with pattern matching in "ghci"? I try to type "let" and just paste the code into ghci, but it complains to the second line. When I use separate "let"s for parts it gets wrong.
09:53:00 <elliott> _Vi: you need to do it all in one big let :)
09:53:04 <elliott> let f 0 = x; f 1 = y; ....
09:53:18 <_Vi> elliott, How to use it with '|' guards?
09:53:44 <geekosaur> they just work
09:53:46 <jhance> let f 0 x | x > 5 = 0; | otherwise = 5; -- I think
09:54:09 <geekosaur> yes
09:54:15 <elliott> jhance: without the ;
09:54:17 <elliott> I think
09:54:21 <elliott> although I guess it might work like that too
09:55:27 <mots> let's say i have two 2d lists, and i want to multiply their elements of same index
09:56:04 <_Vi> jhance, "parse error on input `|'"
09:56:11 <mots> i.e. [[1,2], [3,4]] [[5,6],[7,8]] -> [[1*5, 2*6], [3*7, 4*8]]
09:56:21 <mots> i tried zipWith (zipWith *)
09:56:30 <mots> but obviously I'm doing something wrong
09:57:49 <kmc> :t zipWith (zipWith (*))
09:57:50 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
09:58:05 <kmc> > zipWith (zipWith (*)) [[1,2], [3,4]] [[5,6],[7,8]]
09:58:06 <lambdabot>   [[5,12],[21,32]]
09:58:06 <Sgeo|web> > let f x | x == 0 = 1 | x > 5 = 3 | otherwise = 2 in (f 0, f 1, f 10)
09:58:07 <lambdabot>   (1,2,3)
09:58:23 <mots> kmc: so only my brackets were off?
09:58:25 <kmc> > zipWith (zipWith (*)) [[a,b], [c,d]] [[w,x],[y,z]]
09:58:26 <lambdabot>   [[a * w,b * x],[c * y,d * z]]
09:58:34 <kmc> mots, yeah
09:58:56 <kmc> when you want to refer to an infix operator without actually applying it to stuff
09:59:01 <kmc> you surround the operator in parentheses
09:59:02 <kmc> :t (*)
09:59:03 <lambdabot> forall a. (Num a) => a -> a -> a
09:59:04 <kmc> :t *
09:59:05 <lambdabot> parse error on input `*'
09:59:14 <Sgeo|web> kmc: WOw, I misread that as asking "why"
09:59:27 <kmc> ?
09:59:54 <mots> thanks, I'm still new to haskell
10:00:20 <kmc> :)
10:00:30 <_Vi> (about ghci) The correct one seems to be "let f 0 x | x > 5 = 0; f 0 x | otherwise = 5"
10:01:00 <Sgeo|web> _Vi: Um, that ; and redoing f 0 x looks needless, o.O
10:01:02 * Sgeo|web tries
10:01:15 <_Vi> Sgeo|web, But it fails without them.
10:01:31 <elliott> _Vi: no
10:01:36 <elliott> _Vi: let f 0 x | x > 5 = 0 | otherwise = 5
10:03:04 <smns> so when drop takes an Int and not an Integer, isn't there a more general drop?
10:03:10 <kmc> yes, in Data.List
10:03:18 <dolio> @type genericDrop
10:03:19 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
10:03:24 <smns> ah, generic, thanks.
10:03:32 <kmc> i think it's a design bug; I don't think Int should be in Prelude at all
10:03:40 <kmc> Prelude should contain the conceptually simplest types
10:03:42 <smns> kmc, I hear it's backwards-compatibility.
10:03:46 <_Vi> elliott, OK, was trying with "; |" before.
10:04:02 <kmc> if you want something uglier and faster, import a module
10:04:10 <kmc> smns, sure, that is why i said 'design bug' and not 'implementation bug'
10:04:13 <dolio> Some of the uses of Int are just bizarre.
10:04:14 <kmc> a bug in the design of the Haskell language
10:04:18 <dolio> @type fromEnum
10:04:18 <lambdabot> forall a. (Enum a) => a -> Int
10:04:19 <_Vi> How it's easier to generate [1,2,3,4,...,n-1,n]? Is there something like range(1,n)?
10:04:25 <kmc> > [1..20]
10:04:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:04:32 <kmc> > enumFromTo 1 20
10:04:33 * elliott uses Int much more than Integer, but only because fromIntegral and genericBlah are uglier than sacrificing your principles.
10:04:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:04:49 <kmc> > [1,5..20]
10:04:49 <geekosaur> also, the more abstract the types, the weirder the error messages; fear of the latter seems to have led to many unfortunate decisions
10:04:52 <lambdabot>   [1,5,9,13,17]
10:05:01 <kmc> > [1,5..]
10:05:01 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,10...
10:05:01 <_Vi> kmc, Thanks.
10:05:02 <geekosaur> (I think monad fail is in that set...)
10:05:24 <dolio> fail isn't exactly an error message thing.
10:05:37 <Eduard_Munteanu> @src Just fail
10:05:37 <lambdabot> Source not found. Are you on drugs?
10:05:41 <Eduard_Munteanu> @src Maybe fail
10:05:41 <lambdabot> fail _      = Nothing
10:05:44 <dolio> It's kind of complicated to explain.
10:05:51 <geekosaur> to the extent that requiring MonadZero complicates things
10:06:14 <dolio> It's not just MonadZero.
10:06:23 <dolio> Pattern matching in monads used to be a little fancier.
10:06:46 <dolio> '(x, y) <- m' used to not generate a MonadZero constraint.
10:07:00 <dolio> Because there's only one well-defined case.
10:07:28 <dolio> And they wanted to preserve that behavior while getting rid of the special pattern distinction.
10:07:53 <dolio> So they invented fail and made matching in a do use that, to keep the Monad m constraint.
10:08:02 <dolio> Instead of making everything MonadZero m.
10:08:50 <dolio> I don't think it's particularly compelling reasoning, though.
10:09:53 <Sgeo|web> What do you mean, only one well-defined case?
10:10:10 <Sgeo|web> What's in MonadZero that's not in Monad?
10:10:13 <dolio> case p of { (x, y) -> ... } is an exhaustive match.
10:10:29 <dolio> case m of { Just x -> ... } is not.
10:10:46 <Sgeo|web> Can't the compiler work out whether it's exhaustive or not, and if not, force MonadZero?
10:10:53 <dolio> So 'Just x <- m' is in MonadZero, since it can fail, and '(x, y) <- m' is not.
10:11:01 <dolio> That's how it used to work.
10:11:08 <dolio> But they wanted it to stop working that way.
10:11:12 <Sgeo|web> Why?
10:11:23 <dolio> Not sure. Extra complications to explain, maybe.
10:11:42 <kmc> Sgeo|web, you would keep the desugaring how it is now, and move 'fail' to the MonadZero class, and the types would all work out
10:12:22 <dolio> Are you sure? Does it still not generate a fail case for (x, y)?
10:12:31 <kmc> hm, not sure
10:12:54 * kmc scrolls up
10:13:30 <kmc> right, you would need a new type rule :/
10:13:47 <kmc> or a desugaring rule which is not so syntax-directed
10:14:12 <dolio> edwardk says it does work correctly for (x, y) with rebindable syntax.
10:14:17 <Eduard_Munteanu> I don't think fail belongs in MonadZero either.
10:14:25 <edwardk> not sure about gadts though
10:15:02 <Eduard_Munteanu> I could require MonadZero, though.
10:15:07 <edwardk> i don't think monadzero should exist, so we're in agreement ;)
10:15:44 <Eduard_Munteanu> Erm, nvm, I was confusing that with MonadPlus
10:15:47 <edwardk> the <|> structure is more valuable than some arbtrary unhandleable zero element
10:15:59 <edwardk> which has no laws
10:16:04 <edwardk> other than cancellation
10:16:08 <dolio> It has laws.
10:16:14 <dolio> And you can use it to write a generic filter.
10:16:28 <Eduard_Munteanu> edwardk: isn't cancellation necesarry so it unwinds on failure?
10:17:00 <edwardk> hrmm
10:17:12 <edwardk> perhaps monadzero has a bit more going for it than pointed
10:17:22 * edwardk is willing to concede the point
10:17:30 <Eduard_Munteanu> I presume you want zero >>= f = zero one way or another
10:17:44 <edwardk> thats cancellation
10:24:15 <Sgeo|web> ...I thought Clean came after Haskell
10:24:47 * Sgeo|web is reading A History of Haskell
10:24:59 <cheater> haskell didn't get bullied for long though and retaliated against Clean
10:28:57 <Sgeo|web> "Only later did we realise that this was too easily confused with Pascal or Has- sle! "
10:29:30 <Sgeo|web> I don't think I've had a single teacher I tried to tell about Haskell who didn't hear "Pascal"
10:29:52 <roconnor__> edwardk: pointed is used to define partial lenses in van laarhoven style
10:30:07 * MostAwesomeDude learned to say them as pass-KAL and hass-KEL
10:30:59 <mots> sooo, i tried making a oneliner for matrix products
10:31:01 <mots> but failed terribly
10:31:01 <mots> :D
10:31:49 <Eduard_Munteanu> I think it might be worth writing a 'transpose' function first.
10:31:59 <mots> i have a transpose function already
10:32:05 <roconnor> sum [x!(i,k) <.> y!(k,j) | k <- entireRange]
10:32:21 <Eduard_Munteanu> roconnor: he uses lists of lists
10:32:46 <roconnor> sum [x!!i!!k <.> y!!k!!j | k <- entireRange]
10:33:01 <ziman> ouch :)
10:33:04 <roconnor> ... granted entireRange becomes a bit more tricky
10:33:15 <Eduard_Munteanu> Every element in the result is a dot product.
10:33:23 <roconnor> I guess a zipWith and a transpose is in order
10:33:43 <mots> roconnor: yeah, i tried a wild combination of zipwith, map and transpose
10:35:51 <Sgeo|web> "To keep matters short, we assume basic familiarity with both Haskell and Perl.  One additional non-standard Haskell idea we use heavily herein is "monadic I/O" [3]."
10:36:12 <Eduard_Munteanu> So you can think of it as v_ij = a_i * b^T_j. A 'fromList' might also be useful.
10:36:45 <Eduard_Munteanu> (where '*' is a dot product)
10:37:44 <rotflcopter> hi
10:37:51 <rotflcopter> can someone tell me the syntax for swap 2 variables in gcc? >><< ???
10:37:56 <Eduard_Munteanu> rotflcopter: hi
10:37:58 <elliott> <Sgeo|web> "To keep matters short, we assume basic familiarity with both Haskell and Perl.  One additional non-standard Haskell idea we use heavily herein is "monadic I/O" [3]."
10:38:03 <elliott> Sgeo|web: welcome to the early 90s!
10:38:07 <Eduard_Munteanu> rotflcopter: erm, GCC?
10:38:11 <rotflcopter> C
10:38:11 <Eduard_Munteanu> C?
10:38:15 <danr> rotflcopter: you either do the xor trick or you use a temp variable
10:38:18 <elliott> rotflcopter: this is #haskell
10:38:28 <elliott> danr: you have those two in the wrong order :)
10:38:32 <Eduard_Munteanu> Or the minus trick. :)
10:38:35 <rotflcopter> isnt there such a thing that swaps only the 2 string address as an operator ? >><< ?
10:38:45 <roconnor> doesn't the xor trick only work when the two values are different?
10:38:47 <mauke_> string address? what?
10:38:49 <roconnor> or something like that?
10:38:49 <rotflcopter> elliott<< ok but noone knows ;<
10:38:52 <rotflcopter> in programming
10:38:56 <Eduard_Munteanu> But there's no standard swap function AFAIK, not even special syntax or builtins
10:38:58 <elliott> rotflcopter: ##c
10:38:59 <monochrom> the xor trick always works
10:39:05 <elliott> monochrom: no it doesn't
10:39:10 <elliott> not if the two variables share a location
10:39:12 <monochrom> also >><< is not the swap operator
10:39:12 <danr> elliott: proof or it didn't happen
10:39:22 <roconnor> oh right, it was an aliasing problem
10:39:26 <roconnor> elliott: thanks
10:39:29 <danr> aha ok
10:39:31 <copumpkin> (>>>>><<<<<) :: IORef a -> IORef a -> IO ()
10:39:32 <elliott> roconnor: np :p
10:39:40 <roconnor> that makes more sense
10:39:45 <mauke_> xor is also limited to integers
10:39:45 <danr> copumpkin: best operator ever
10:39:49 * copumpkin bows
10:39:55 <elliott> copumpkin: can we get that into base?
10:40:01 <copumpkin> (<<<<<>>>>>) :: IORef a -> IORef a -> IO ()
10:40:05 <copumpkin> swaps them in the opposite order
10:40:06 <copumpkin> >_>
10:40:09 <monochrom> hahaha
10:40:10 <danr> hahaha
10:40:14 <roconnor> copumpkin: does it come with a precondition that the two IORefs don't alias?
10:40:20 <copumpkin> no
10:40:24 <roconnor> :O
10:40:31 <roconnor> I'd like to see you implement that
10:40:33 <aristid> copumpkin: but what if i want to swap 3 IORefs?
10:40:41 <danr> (>>>>^<<<<) :: XORable a => IORef a -> IORef a -> IO ()
10:40:42 <roconnor> without using unsafeEqualThing
10:40:48 <Eduard_Munteanu> ∞><∞ : Mu IORef -> Mu IORef -> IO ()    -- :P
10:40:54 <copumpkin> (>>>>><<<<<>>>>>) :: IORef a -> IORef a -> IORef a -> IO ()
10:40:55 <Eduard_Munteanu> Bah, ::
10:40:57 <copumpkin> aristid
10:41:07 <danr> Eduard_Munteanu: too much Agda? :) I do it all the time
10:41:15 <aristid> copumpkin: clearly we need mixfix.
10:41:16 <Eduard_Munteanu> I guess so :)
10:41:17 <elliott> roconnor: IORefs have Eq
10:41:34 <elliott> a >>>>><<<<< b | a == b = fail "oh no!" | otherwise = ...
10:41:39 <roconnor> elliott: oh?
10:41:44 <roconnor> @instances Eq
10:41:44 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:41:48 <roconnor> :P
10:41:56 <c_wraith> @instances-importing Data.IORef Eq
10:41:57 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, IORef a, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:42:02 <c_wraith> bam!
10:42:08 <elliott> roconnor: it disturbs me a bit that they do :)
10:42:11 <danr> @info IORef
10:42:11 <lambdabot> IORef
10:42:14 <elliott> you can use IORef () as Unique
10:42:32 <c_wraith> I'm assuming that's "is it the same IORef" equality, not "do they contain equal objects"
10:42:53 <danr> c_wraith: the latter would  be weird, that would return an IO Bool
10:42:53 <roconnor> elliott: why do we have a Unique library then?
10:42:53 <Eduard_Munteanu> Yeah, it's a bit like pointer equality IIRC
10:43:01 <c_wraith> danr: indeed
10:43:06 <elliott> roconnor: to avoid allocating a reference for each unique value? :P
10:43:10 <elliott> roconnor: and so that you can hash them?
10:43:39 <roconnor> clearly Hashable should be a prequisite of Eq :P
10:44:37 <elliott> roconnor: clearly!
10:58:45 <Sgeo|web> "Wadler conceived of type classes in a conversation with Joe Fasel after one of the Haskell meetings. Fasel had in mind a different idea, but it was he who had the key insight that overloading should be reflected in the type of the function. Wadler misunderstood what Fasel had in mind, and type classes were born! "
10:58:53 <Sgeo|web> What was Fasel's idea?
11:06:17 <roconnor> apparently it was nobody's idea
11:09:04 <Sgeo|web> "The Haskell Committee in fact did not want any prefix  operators, but we couldn’t bring ourselves to force users to write   something like minus 42 or ~42 for the more conventional -42. "
11:09:06 <Sgeo|web> Too bad
11:09:45 <elliott> It's perfectly possible to allow -42 without prefix operators.\
11:10:15 <c_wraith> the answer is to be like agda
11:10:21 <c_wraith> and make whitespace matter
11:10:29 <c_wraith> hence (- 5) is different from (-5)
11:10:44 <shachaf> In Agda is "-5" just an identifier?
11:10:51 <elliott> c_wraith: I would be happy with that, as long as -(f x) was still possible, and the actual negation sign bound as tightly as possible.
11:11:04 <elliott> I would also be happy with - being part of numeric literals, and having to use "negate" for expressions.
11:11:59 <Eduard_Munteanu> shachaf: yeah, I think so
11:12:15 <Eduard_Munteanu> Just like a,b
11:12:25 <shachaf> elliott: The latter makes more sense to me.
11:12:39 <elliott> shachaf: Yes, but it's uglier.
11:12:46 <shachaf> It is?
11:12:49 <Eduard_Munteanu> You'd have to type   a , b  for Agda to make sense of _,_
11:12:51 <elliott> shachaf: For users, yes.
11:13:03 <elliott> I would prefer a little more complexity in the grammar for the convenience of uniform negation.
11:13:25 <shachaf> Next will you ask to be able to say "x.25" for "x + 0.25"?
11:14:01 <elliott> shachaf: No. Obviously the only reason people want this is because it's common notation; that's not surprising.
11:14:09 <elliott> shachaf: We don't really need infix operators, either.
11:14:50 <shachaf> I think a one-off prefix operator is probably worse.
11:15:03 <elliott> It's not an opeartor in c_wraith's version :)
11:15:08 <elliott> It's syntax.
11:15:52 <shachaf> evilPerformSyntax
11:18:17 <Sgeo|web> "semantics is discussed half as much as syntax, syntax is discussed half as much as lexical syntax, and lexical syntax is discussed half as much as the syntax of comments. "
11:19:03 <elliott> Sgeo|web: wadler's law
11:20:33 <kmc> > "-}" ++ "hello world"
11:20:35 <lambdabot>   "-}hello world"
11:20:38 <kmc> > {- "-}" ++ -}  "hello world"
11:20:39 <lambdabot>   <no location info>:
11:20:39 <lambdabot>      lexical error in string/character literal at end o...
11:20:53 <kmc> so there is valid Haskell code which cannot be commented out!
11:20:53 <elliott> what
11:20:56 <elliott> oh
11:21:02 <kmc> OCaml makes the opposite design decision
11:21:09 <kmc> (* "*)" *) is a well-formed comment
11:21:13 <kmc> but this means (* " *) is not
11:21:20 <elliott> kmc: it might be nice to reassign {-...-} to be exclusively for commenting out code :P
11:21:23 <elliott> like, it actually parses the inside
11:21:28 <kmc> comments are required to lex
11:21:45 <shachaf> kmc: You admit it wouldn't be a functional programming language without {- -} for comments.
11:21:46 <elliott> i guess that's what ocaml does, except it probably just specialcases strings
11:21:52 <kmc> it's true shachaf
11:21:53 <elliott> which is soooo inelegant
11:22:07 <kmc> elliott, I think it just requires a lower level of lexical analysis, rather than a full parse
11:22:16 <kmc> i mean, which node of the parse tree would you start at
11:22:21 <tac-tics> {- -} is the most awkward thing in the world for comments
11:22:31 * elliott just uses M-; and never types {- or -} ever.
11:22:32 <tac-tics> Also shachaf (* *) :)
11:22:42 * shachaf likes the Whitespace syntax for comments.
11:22:45 <kmc> (* ____ *)
11:22:49 <shachaf> tac-tics: No.
11:22:57 <monochrom> are you trying to illustrate wadler's law? :)
11:23:06 <kmc> let's reopen that bug about adding /* comments */ to GHC
11:23:08 <tac-tics> No'caml for shachaf? :(
11:23:31 * shachaf {-# LANGUAGE CPP #-} /* C-style comments */
11:26:14 <tromp> kmc's example looks like a bug to me
11:26:35 <tromp> comment syntax has to recognize strings
11:26:58 <kmc> by "bug" you mean that lambdabot is not faithfully implementing Haskell, or that the Haskell spec is philosophically wrong?
11:27:08 <kmc> why should comment syntax recognize strings?
11:27:18 <tromp> spec is wrong, to extend that ghc implements it
11:27:24 <kmc> the thing is, you can't have it both ways
11:27:25 <tromp> extent
11:27:37 <kmc> either {- "-}" -} or {- " -} is an invalid comment
11:28:16 <kmc> now if we could get rid of " and switch to matching open-close delimiters for quotes
11:28:35 <kmc> i think  {- «-}» -}  and  {- « -}  would both be fine
11:28:44 <kmc> it would ruin my IRCing a bit
11:28:49 <tromp> i'd prefer making  {- " -} invalid
11:29:02 <Sgeo|web> > let f x y = True in f undefined undefined
11:29:03 <lambdabot>   True
11:29:05 <kmc> but there are plenty of other delimiters
11:29:14 <shachaf> kmc: You're going to have to find more and more obscure quotation marks.
11:29:21 <shachaf> And watch in horror as they all go mainstream.
11:29:25 <Sgeo|web> " Miranda’s design identified      ⊥ with (⊥, ⊥), which influenced us considerably. Furthermore,              this identification made currying an exact isomorphism:                (a,b) -> c ∼ a -> b -> c  "
11:29:33 <kmc> tromp, it's much more common that I want to comment out some incomplete code (so i can test something else, or build docs)
11:29:39 <Sgeo|web> How is currying currently not an exact isomorphism?
11:29:48 <kmc> tromp, much less common that I want to comment out code which contains -} within a string literal
11:29:48 <shachaf> Sgeo|web: Tuples are lifted.
11:29:56 <kmc> that pretty much only happens if you are writing a Haskell compiler ;P
11:29:58 <shachaf> I.e., there's an additional _|_.
11:30:18 <tromp> kmc: why would incomplete code contain unbalanced " ?
11:30:26 <shachaf> f (x,y) = ... can be passed _|_, (1,_|_), (_|_,2), (1,2)
11:30:26 <kmc> because i'm still writing it
11:30:41 <kmc> i mean yes I can end with "-}
11:30:50 <shachaf> Er, and (_|_,_|_)
11:30:50 <kmc> but it's an extra thing to remember
11:31:00 <shachaf> Whereas f x y can be passed 1 _|_, _|_ 2, _|_ _|_, and 1 2.
11:31:08 <roconnor> schroedinbug: heh, you almost missed the extra thing
11:31:19 <roconnor> ah oops
11:31:20 <tromp> i don't see having to keep " balanced in incomplete code as a real nuisance
11:31:21 <Sgeo|web> shachaf: Oh, but not _|_
11:31:23 <roconnor> that was for shachaf
11:31:31 <kmc> i don't think either is a real nuisance
11:31:55 <roconnor> I guess it is a matter of taste which of (_|_,_|_) or _|_ is the extra one
11:32:06 <mots> [map sum [zipWith (*) n m | n <- x, m <- (transpose y)]] <- my miserable attempt at a matrix product
11:32:10 <roconnor> well, maybe it is the _|_ that is extra ...
11:32:10 <tromp> you also have to leep nested {- -} balanced
11:32:25 <mots> two problems: 1) it doesn't always work, 2) it returns a list instead of a list of lists
11:32:31 <mots> could anyone help me fix those?
11:32:54 <roconnor> mots: [[map sum [zipWith (*) n m | n <- x| m <- (transpose y)]]] ?
11:32:55 <kmc> "doesn't work"?
11:33:05 <roconnor> mots: er
11:33:07 <shachaf> roconnor: Seems to me like _|_ is the extra one. :-)
11:33:09 <roconnor> mots: [[map sum [zipWith (*) n m | n <- x ]| m <- (transpose y)]] ?
11:33:18 <roconnor> shachaf: ya, I think you are right
11:33:52 <shachaf> roconnor: If you have an n-tuple and you eliminate the values one by one, it doesn't make sense for it to suddenly jump from (_|_,2,_|_,_|_,_|_) to _|_
11:33:53 <roconnor> mots: [[sum (zipWith (*) n m) | n <- x ]| m <- (transpose y)] ?
11:34:56 <roconnor> let foo x y = [[sum (zipWith (*) n m) | n <- x ]| m <- (transpose y)] in foo [[a,b],[c,d]] [[a,b],[c,d]]
11:34:59 <mots> roconnor: thanks a lot, that looks better :)
11:35:03 <roconnor> > let foo x y = [[sum (zipWith (*) n m) | n <- x ]| m <- (transpose y)] in foo [[a,b],[c,d]] [[a,b],[c,d]]
11:35:04 <lambdabot>   [[0 + a * a + b * c,0 + c * a + d * c],[0 + a * b + b * d,0 + c * b + d * d]]
11:35:43 <roconnor> mots: [[sum (zipWith (*) n m) | n <- x ]| m <- transpose y] ?
11:38:02 <jgreene> anyone have experience with HaskellNet SMTP?
11:41:00 <mots> hm, somehow it still doesn't produce the correct result, any idea why?
11:43:53 <roconnor> mots: do you need to transpose x insteady of y?
11:44:15 <roconnor> or reverse the order of x and y maybe
11:44:23 <roconnor> that seems more likely the problem
11:44:23 <kmc> mots, you should probably try to narrow down what kind of incorrect result it's giving
11:44:34 <roconnor> mots: [[sum (zipWith (*) n m) | n <- (transpose y) ]| m <- x] ?
11:44:52 <mots> is the code correct for a matrix multiplication in principle?
11:45:09 <roconnor> I would try random permuations of the positions of x and y and the position of transpose until something passes your unit tests :P
11:45:10 <kmc> what does "correct in principle" mean
11:45:46 <jjohnsson> roconnor: that seems to give the correct result.
11:46:18 <roconnor> kmc: that the collection of subexpressions is correct, but not necessarily in the correct order :P
11:47:48 * Sgeo|web gets to the bit about the monomorphism restriction
11:47:50 <Sgeo|web> Question:
11:48:25 <Sgeo|web> Why not essentially have the desugared function that takes the dictionary be memoizing on the first argument?
11:48:34 * roconnor recalls one occasion where the monomorphism restriction actually helped a little.
11:50:28 <mots> :D
11:50:37 <mots> i think I've tried every possible permutation
11:51:02 <mots> but none of them gives me mm [[1,2,3],[4,5,6]] [[1,2],[3,4],[5,6]]  == [[22,28],[49,64]]
11:51:10 <kmc> try to come up with a very simple input which gives the wrong output
11:51:12 <kmc> then figure out why
11:51:24 <kmc> QuickCheck might help
11:51:30 <kmc> it can automatically shrink test cases
11:52:42 <jjohnsson> mots: well, roconnor's last attempts gives that result. At least on my computer.
11:53:57 <mots> jjohnsson: weird, I get [[7,10,3,3],[19,28,9,9],[4,6,2,2]]
11:54:37 <jjohnsson> > let matmul x y = [[sum (zipWith (*) n m) | n <- (transpose y) ]| m <- x] in matmul [[1,2,3],[4,5,6]] [[1,2],[3,4],[5,6]]
11:54:38 <lambdabot>   [[22,28],[49,64]]
12:01:19 <jjohnsson> let matmul x y = [[sum (zipWith (*) n m) | n <- (transpose y) ]| m <- x] in matmul [[1,2],[3,4],[5,6]] [[1,2,3],[4,5,6]]
12:01:32 <jjohnsson> > let matmul x y = [[sum (zipWith (*) n m) | n <- (transpose y) ]| m <- x] in matmul [[1,2],[3,4],[5,6]] [[1,2,3],[4,5,6]]
12:01:33 <lambdabot>   [[9,12,15],[19,26,33],[29,40,51]]
12:01:41 <jjohnsson> hm.
12:01:50 * hackagebot HROOT 0.7 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.7 (IanWooKim)
12:02:33 <mots> oh wow, i feel stupid
12:02:38 <mots> there was an error in my other code
12:02:46 <mots> sorry for having bothered you guys
12:03:41 <FUZxxl> Am I unbanned?
12:03:44 <FUZxxl> wow
12:04:03 <elliott> you were banned?
12:04:04 <jhance> FUZxxl: What'd you do to get banned? lol
12:04:22 <FUZxxl> jhance: Ah... wrong window... I am muted on ##c for "flooding"
12:05:13 <ion> I wonder how to set up signal handlers with a Remote application? I’d need to send messages to Remote processes from IO (not ProcessM) since System.Posix.Signals.installHandler takes an IO action.
12:06:54 <smns> I've got an Integer, and replicateM takes an Int. I suppose there isn't a genericReplicateM somewhere.
12:07:09 <jhance> smns: Hoogle :)
12:07:34 <smns> jhance, right! I gotta get used to that. :)
12:08:12 <jhance> smns: My search yielded replicateM as the frist result  so I don't think it exists
12:08:38 <scooty-puff2> is there anything in Map or Set along the lines of (a -> b) -> IntMap a -> IntMap b -> IntMap b
12:08:44 <scooty-puff2> *IntMap or IntSet
12:08:55 <scooty-puff2> er, scratch that
12:09:04 <scooty-puff2> b -> IntMap a -> IntMap b -> IntMap b
12:09:04 <kmc> \_ _ x -> x
12:09:16 <mm_freak> scooty-puff2: there is (a -> b) -> IntMap a -> IntMap b
12:09:18 <mm_freak> called fmap
12:09:26 <jhance> scooty-puff2: Hoogle :)
12:09:28 <ion> genericReplicateM n xs = sequence (genericReplicate n xs)
12:09:34 <scooty-puff2> union the first map with the second, using the default value b where a value does not exist in the first map
12:09:36 <mots> is there any shorthand for "apply function f x times to list l"?
12:09:58 <kmc> why a list mots?
12:09:59 <scooty-puff2> whoops - mistated the type sig:
12:10:07 <mots> kmc: or anything for that matter
12:10:08 <scooty-puff2> b -> IntMap a -> IntMap b -> IntMap b
12:10:11 <kmc> :t iterate
12:10:12 <lambdabot> forall a. (a -> a) -> a -> [a]
12:10:14 <ion> > iterate (map (+1)) [1..10]
12:10:15 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4...
12:10:23 <mm_freak> scooty-puff2: unionWith?
12:10:28 <kmc> > iterate show "" !! 10
12:10:29 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:10:32 <ion> > iterate (map (+1)) [1..10] !! 5
12:10:33 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
12:10:34 <jhance> scooty-puff2: How can you take the union of an IntMap a and IntMap b?
12:10:42 <mots> that sounds like what I need, thanks
12:10:43 <scooty-puff2> by providing a default value for the first map
12:10:45 <mm_freak> scooty-puff2: of course it's a -> IntMap a -> IntMap a -> IntMap a
12:11:00 <ion> One of the few places where !! is actually safe. :-P
12:11:03 <mm_freak> scooty-puff2: your type signature does not make much sense
12:11:06 <Sgeo|web> Lexically scoped type variables
12:11:17 <parcs_> scooty-puff2: foo x m1 m2 = (x <$ m1) `union` m2 ?
12:12:24 <scooty-puff2> i would like to merge info into a symbol table, transforming the table from IntMap a to IntMap (With a SomeInfo), but do not want to remove old values from the map that do not exist in the new map - by providing a default value
12:12:39 <scooty-puff2> (i.e. i can't just intersect)
12:12:46 <scooty-puff2> parcs_: i will try that
12:13:40 <parcs_> you may want to flip the arguments to union
12:14:31 <mm_freak> isn't that just union + fmap?
12:15:09 <parcs_> yeah, <$ = fmap . const
12:15:10 <mm_freak> (<$) pratically destroys the first map and merges the infoless map with the second one
12:15:25 <mm_freak> so the more general fmap seems more appropriate
12:15:35 <scooty-puff2> yeah - so want i have avialable to me is a default "b", "a -> b", IntMap a, and IntMap b
12:15:44 <scooty-puff2> hmm, nm
12:15:56 <parcs_> really i'm not sure what scooty-puff2 want, i'm just going by the type he provided :P
12:16:12 <mm_freak> i'm not sure i get the problem anyway…  i don't understand scooty-puff2
12:16:22 <scooty-puff2> let me post the code i'm doing now...
12:17:29 <hpaste> scooty-puff2 pasted “Symbol Table” at http://hpaste.org/53763
12:18:16 <scooty-puff2> NameMap is a trivial wrapper for IntMap
12:19:40 <jgreene> anyone know a way to do plaintext authentication with: http://hackage.haskell.org/package/SMTPClient-1.0.4 ?
12:20:53 <geheimdienst> jgreene: if nobody is around who happens to have used smtp stuff, you'll have a better chance by asking on the haskell-cafe mailing list
12:21:50 <jgreene> geheimdienst: thanks, I'll give it a shot.
12:25:46 <Sgeo|web> "One should read “M a” as the type of a computation that returns a value of type a (and perhaps performs some side effects).  "
12:25:58 <Sgeo|web> I was hoping not to read something like that in something as ... important as A History of Haskell
12:26:13 <mm_freak> jgreene: that library does not support authentication
12:26:44 <mm_freak> unfortunately i know no library that does
12:27:05 <jgreene> HaskellNet supposedly does, but I can't even get it to connect to a simple smtp server without authentication
12:27:30 <Sgeo|web> "A state transformer is used to thread state through a program. Here M a is ST s a, where s is the state type. type ST s a = s -> (a,s) "
12:27:49 <Sgeo|web> Uh, was State called ST in 2007 or something?
12:28:23 <mm_freak> jgreene: with HaskellNet requires you to write the authentication sequence yourself
12:28:30 <mm_freak> shouldn't be too difficult though
12:28:39 <shachaf> Sgeo|web: No, they're completely different things.
12:28:46 <shachaf> That particular guide is just confused.
12:29:06 <Sgeo|web> shachaf: the author of A History of Haskell is confused, then
12:29:07 <jgreene> mm_freak: yeah, that's not the problem with haskellnet, the problem is that it won't connect to a local smtp server at all.  Gives me an (Connection Refused) error.  Whereas the SMTPClient library will connect just fine
12:29:41 <shachaf> Sgeo|web: Makes sense.
12:29:52 <Sgeo|web> shachaf: Um, it does?
12:29:58 <mm_freak> jgreene: might be a binding issue…  your local SMTP server may be listening on a specific interface (eth0), while HaskellNet tries to connect to another (lo)
12:30:00 <shachaf> Probably that guide isn't referring to actual Haskell.
12:30:14 <mm_freak> jgreene: make sure your local SMTP server listens on 0.0.0.0 or 127.0.0.1
12:30:43 <scooty-puff2> ok - so hopefully this is stated clearer: is there anything in Data.IntMap that has type (a -> c) -> (b -> c) -> (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
12:30:44 <jgreene> mm_freak: it does, I connect to it using SMTPClient using localhost just fine
12:30:50 <elliott> Sgeo|web: Typos exist.
12:31:03 <shachaf> "ST" does stand for "State Transformer", I believe.
12:31:07 <mm_freak> jgreene: another issue i've had was IPv4 vs. IPv6
12:31:07 <mots> mm a a (s,s,s,f) <- how do I use that with iterate? (a being the part that should change)
12:31:08 <shachaf> It's probably just a simplification.
12:31:32 <shachaf> Notice how they also use "SR" instead of "Reader".
12:31:56 <shachaf> And Exc instead of Either.
12:32:04 <elliott> scooty-puff2: What would that do?
12:32:16 <scooty-puff2> perform a union
12:32:40 <scooty-puff2> using the first the first 3 arguments to produce or combine the pervious elements
12:32:41 <parcs_> scooty-puff2: either (a -> b -> c) or (a -> c) and (b -> c) is redundant
12:32:48 <scooty-puff2> its a union though
12:32:50 <mm_freak> Sgeo|web: ST is a generalization of IO, while a "state transformer" in the usual terminology would be this:  newtype StateT s m a = StateT (s -> m (a, s))
12:32:51 <kmc> _All About Monads_ also calls their state monad ST
12:32:53 <elliott> scooty-puff2: Can't you do that based on existing combinators.
12:33:17 <scooty-puff2> currently, with a combination of intersectionWith, etc.
12:33:23 <elliott> Right.
12:33:29 <kmc> Sgeo|web, the statement about "M a" isn't really incorrect, I don't think
12:33:29 <elliott> That sounds like the best you'll get to me.
12:33:34 <scooty-puff2> wasn't sure if something that already existed i was just missing
12:33:34 <scooty-puff2> k
12:33:39 <kmc> Sgeo|web, it's phrased in a way that's probably confusing
12:34:07 <kmc> i mean for it to work, you have to take a very liberal definition of "side effect"
12:34:09 <kmc> but that's common
12:34:18 <kmc> it's not saying that /evaluating/ the (M a) value has a side effect
12:34:43 <shachaf> The state of the art in "explaining monads" is in #haskell; everyone knows that.
12:34:47 <kmc> :)
12:35:13 <kmc> i wouldn't call the current ST a generalization of IO, either
12:35:19 <kmc> it generalizes in one way and specializes in another
12:35:25 <elliott> IO is an extension of ST :)
12:35:43 * elliott wonders why stToIO :: IO a -> ST RealWorld a doesn't exist.
12:35:59 <elliott> Maybe because it lets you break sequential reasoning about STRefs with forkIO?
12:36:04 <Eduard_Munteanu> That sounds backwards.
12:36:19 <elliott> Erm
12:36:20 <elliott> ioToST
12:36:26 <elliott> There's already stToIO :: ST RealWorld a -> IO a.
12:36:48 <Eduard_Munteanu> Because you'd have unsafePerformIO = runST . stToIO I guess
12:36:57 <elliott> No?
12:37:00 <elliott> :t runST
12:37:01 <lambdabot> forall a. (forall s. ST s a) -> a
12:37:08 <elliott> The rank-2 type is kind of the whole reason ST is safe :P
12:37:12 <Eduard_Munteanu> erm...
12:37:21 <Eduard_Munteanu> ioToST, you confused me as well :)
12:37:31 <elliott> still doesn't work
12:37:36 <elliott> ioToST m :: ST RealWorld a
12:37:44 <elliott> can't pass ST RealWorld a to (forall s. ST s a) -> ...
12:38:26 <Eduard_Munteanu> Hrm, right.
12:38:52 <Eduard_Munteanu> But you won't be able to run it, will you?
12:39:05 <shachaf> @ty Control.Monad.ST.unsafeIOToST -- /me whistles.
12:39:06 <lambdabot> forall a s. IO a -> ST s a
12:39:59 <elliott> shachaf: That's why you make it safe by restricting s.
12:40:03 <elliott> Eduard_Munteanu: Sure you can:
12:40:10 <elliott> @ty Control.Monad.ST.stToIO
12:40:10 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
12:40:13 <shachaf> elliott: Right.
12:40:29 <elliott> > Control.Monad.ST.unsafeIOToST (print 99)
12:40:30 <lambdabot>   Not in scope: `Control.Monad.ST.unsafeIOToST'
12:40:33 <elliott> :-(
12:40:40 <shachaf> Exactly.
12:40:55 <Eduard_Munteanu> Hm, you have a point... you could drop IO-ish capabilities for a while and get them back later, no?
12:41:01 <elliott> But yeah, I guess stToIO lets you smuggle forkIO in.
12:41:05 <elliott> Erm.
12:41:07 <elliott> ioToST.
12:41:08 <elliott> God I'm bad at this.
12:41:09 <Eduard_Munteanu> :)
12:41:24 <elliott> And that's kinda gross, because it breaks sequential reasoning about STRefs...
12:41:28 <elliott> But I don't think it's unsafe at all.
12:41:53 <mm_freak> elliott: what would you use such a function for anyway?
12:42:25 <smns> I miss Standard ML's List.tabulate.
12:42:36 <mm_freak> smns: what's that?
12:42:38 <elliott> mm_freak: Well, if we have stToIO, might as well have the other way around :-)
12:42:55 <mm_freak> elliott: do we?
12:43:00 <elliott> yes.
12:43:04 <shachaf> smns: map f [0..n-1] ?
12:43:05 <smns> mm_freak, tabulate(n, f) = [f(0), f(1), ..., f(n-1)]
12:43:11 <elliott> :t Control.Monad.ST.stToIO
12:43:12 <mm_freak> elliott: well, ok, we have return . runST
12:43:12 <lambdabot> forall a. ST GHC.Prim.RealWorld a -> IO a
12:43:13 <smns> shachaf, ah! duh. :)
12:43:15 <elliott> mm_freak: ^
12:43:19 <mm_freak> elliott: ah, ok
12:43:24 * elliott used that in the "vault" package
12:43:31 <elliott> smns: map f [0..n]
12:43:35 <elliott> erm
12:43:36 <elliott> n-1, yeah
12:43:40 <elliott> > map f [0..n-1]
12:43:41 <lambdabot>   Ambiguous occurrence `f'
12:43:41 <lambdabot>  It could refer to either `L.f', defined at <local...
12:43:43 <elliott> gah
12:43:44 <elliott> > map g [0..n-1]
12:43:45 <lambdabot>   Ambiguous type variable `b' in the constraints:
12:43:45 <lambdabot>    `GHC.Show.Show b'
12:43:45 <smns> yeah.
12:43:45 <lambdabot>      a...
12:43:48 <elliott> > map g [0..n-1] :: Expr
12:43:49 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
12:43:49 <lambdabot>         against inferred ...
12:43:51 <elliott> >:(
12:43:52 <elliott> > map g [0..n-1] :: [Expr]
12:43:57 <lambdabot>   mueval-core: Time limit exceeded
12:44:00 <elliott> :-|
12:44:01 <shachaf> elliott: It's not going to work.
12:44:04 <mm_freak> smns: \n -> (`map` [0..n - 1])
12:44:07 <mm_freak> :t \n -> (`map` [0..n - 1])
12:44:08 <lambdabot> forall b a. (Num a, Enum a) => a -> (a -> b) -> [b]
12:44:09 <elliott> Yeah, I realised that somewhere along the line.
12:44:19 <Eduard_Munteanu> mm_freak: I think the point is you could share IORefs with ST-ish code, not for runST, but for dropping IO capabilities.
12:44:19 <elliott> > f . [0..10] :: [Expr]
12:44:20 <lambdabot>   Ambiguous occurrence `f'
12:44:20 <lambdabot>  It could refer to either `L.f', defined at <local...
12:44:23 <elliott> > g . [0..10] :: [Expr]
12:44:24 <lambdabot>   [g 0,g 1,g 2,g 3,g 4,g 5,g 6,g 7,g 8,g 9,g 10]
12:44:25 <elliott> What now, science???
12:44:33 <shachaf> elliott: But like a true #haskeller, you kept on going.
12:46:04 <mm_freak> Eduard_Munteanu: well, there are so many little changes you could make…  ;)
12:46:20 <mm_freak> for example i'd get rid of Monad altogether and use only ArrowApply =)
12:47:05 * Eduard_Munteanu thinks breaking IO into multiple, separate and composable capabilities would be nice
12:47:57 <elliott> Eduard_Munteanu: Thankfully you can do that without any language changes.
12:48:06 <Eduard_Munteanu> Yeah, sure.
12:49:31 <incluye> feelin so fly
12:49:33 <incluye> > g 6
12:49:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:49:34 <lambdabot>    `SimpleReflect.FromExpr ...
12:49:36 * shachaf thinks eliminating IO would be nice.
12:49:44 <incluye> > g 6 :: Expr
12:49:45 <lambdabot>   g 6
12:49:49 <mm_freak> i don't think it would be nice
12:49:52 <Nimatek> IO should be made more obscure, lest people actually figure out how to write real world programs in haskell.
12:50:51 <mm_freak> there is nothing wrong with IO for the underlying real world interaction
12:51:05 <mm_freak> for example not every application can easily use withFile
12:51:27 <mm_freak> and not every programmer cares for absolute super-high safety
12:51:28 <Sgeo|web> Hmm
12:51:31 <Eduard_Munteanu> I wonder whether there's a way to safely *gain* rather than drop "privileges".
12:51:33 <Sgeo|web> Is Core Lint on by default?
12:52:53 <Eduard_Munteanu> I'm thinking along the lines of uniqueness typing a RealWorld so you could only gain a single IO thread, for example. I'm not sure if it makes sense.
12:52:57 <hpaste> justin pasted “SMTP email” at http://hpaste.org/53764
12:53:03 <byorgey> Sgeo|web: I doubt it, although I don't know for sure.
12:55:20 <tsaad> what would be the easiest way to do a multi delimiter bytestring split?
12:56:02 <joseanpg> Hello
12:56:08 <Eduard_Munteanu> main :: Unique RealWorld -> NoCaps (); main rw = runIO rw main'; main' :: IO (); main' = print "Hello world"   -- something along those lines
12:57:10 <elliott> <Eduard_Munteanu> I'm thinking along the lines of uniqueness typing a RealWorld so you could only gain a single IO thread, for example. I'm not sure if it makes sense.
12:57:17 <elliott> Eduard_Munteanu: Isn't that basically exactly what the IO monad is, but without additional semantics?
12:57:41 <mm_freak> elliott: the IO monad can express forkIO without caring a lot for what it means
12:58:07 <mm_freak> IO is just a language, whereas Clean is a bit more specific
12:58:09 <elliott> mm_freak: arguably, the World just happens to contain multiple little worlds :)
12:58:10 <Eduard_Munteanu> elliott: yeah, you can achieve pretty much the same, but only by dropping "capabilities"
12:58:10 <joseanpg> Does someone know what is the entity that follows *of* in *case pat of ¿? { ...* in GHC Core?
12:58:37 * shachaf waits for conal to pop up and talk about how uniqueness typing for IO still doesn't give your program any meaning.
12:58:47 <mm_freak> elliott: don't view IO a as (RealWorld -> (a, RealWorld))…  that analogy doesn't work well
12:58:49 <joseanpg> for example: *case ds of _ {       [] -> c1; ...*
12:58:51 <elliott> mm_freak: I know it doesn't.
12:59:05 <elliott> mm_freak: I was just talking in the context of Eduard_Munteanu's thing.
12:59:15 <shachaf> View IO as RealWorld -> RealWorld.
12:59:17 <elliott> joseanpg: that binds the result of evaluation to a variable i think
12:59:23 <elliott> joseanpg: case f x of x' { ... }
12:59:34 <elliott> I may be wrong
12:59:43 <shachaf> Or maybe ImaginaryWorld -> (ImaginaryWorld,a)
12:59:58 <Eduard_Munteanu> RealWorld here would contain a SocketWorld, ConsoleWorld, ThreadedWorld etc.
13:00:13 <mm_freak> Eduard_Munteanu: that's not necessary
13:00:17 <mm_freak> Eduard_Munteanu: newtype FileIO s a = FileIO (IO a)
13:00:44 <mm_freak> withFile :: FilePath -> (forall s. Handle s -> FileIO s a) -> IO a
13:01:03 <joseanpg> elliott: thanks
13:01:05 <mm_freak> add some more arguments to make this useful
13:01:12 <Eduard_Munteanu> Yeah, I know you can drop privileges that way, I was merely thinking if the other direction made sense, that is asking for privileges.
13:01:36 <mm_freak> Eduard_Munteanu: you are asking for privileges through withFile
13:01:52 <joseanpg> where can I find doc about it?
13:01:55 <mm_freak> either you succeed (the continuation is called) or you fail (something else happens)
13:02:02 <Eduard_Munteanu> mm_freak: mm, actually you are dropping them since you're in IO already :)
13:02:12 <elliott> Eduard_Munteanu: not if you can't read files in IO
13:02:15 <mm_freak> Eduard_Munteanu: if you have no file handling functions in IO
13:02:17 <mm_freak> ?
13:02:20 <Eduard_Munteanu> Ah.
13:02:34 <mm_freak> you have only:  readFile :: Handle s -> FileIO s String
13:02:41 <elliott> Eduard_Munteanu: it's like how runST grants you the privilege to use mutable variables in pure code
13:02:43 <Sgeo|web> How am I supposed to know when to use seq?
13:02:51 <shachaf> Please don't turn everything into runST-esque rank-2 madness.
13:02:53 <Eduard_Munteanu> Wait, that can't be right.
13:02:58 <shachaf> Sgeo|web: When it's the right time, you will know.
13:03:00 <elliott> Sgeo|web: by understanding how your haskell code is evaluated
13:03:21 <Eduard_Munteanu> elliott: it's perfectly fine to have multiple ST threads, but not multiple IO threads, I think
13:03:30 <mndrix> i'm preparing a package for hackage, but am not sure what to name it. any suggestions?  https://gist.github.com/1349212
13:03:32 <Eduard_Munteanu> (not in the concurrency sense)
13:03:36 <mm_freak> Sgeo|web: or when you have a long running program that seems to eat more and more memory =)
13:03:41 <elliott> Eduard_Munteanu: I was just giving an example of how you can use rank-n types to grant privileges
13:03:49 <elliott> by making demands of the code inside
13:04:38 <Phyx-> i'm having a small problem compiling a package with ghc 7.2, i'm getting "It is a member of the hidden package `haskell98-2.0.0.0'." but haskell98 >= 1.1.0.1 is listed as a dependency in the cabal file
13:04:47 <mm_freak> Eduard_Munteanu: however, withFile can't be used everywhere, and that's why i wouldn't vote for changing the way IO works
13:04:48 <Eduard_Munteanu> What's preventing you from using withFile (or similar functions) multiple times, or nested?
13:05:09 <Phyx-> it seems to be failing when compiling the customm Setup.hs file
13:05:20 <elliott> Eduard_Munteanu: why would you need to be stopped?
13:05:27 <mm_freak> Eduard_Munteanu: the only thing i'd be happy with is:  fileIO :: MonadIO m => (forall s. FileIO s m a) -> m a
13:05:57 <mm_freak> Eduard_Munteanu: some programs don't have a specific code region to map to a certain file handle
13:06:05 <mm_freak> Eduard_Munteanu: think about resource-managing servers
13:06:25 <shachaf> It's-a me, MonadIO!
13:06:26 <mm_freak> long running connections, which can be broken and reestablished in the middle without losing state
13:06:30 <mm_freak> etc.
13:06:52 <mm_freak> those don't really fit well into the with* concept, although you can still make them fit into the concept of regions to some extent
13:06:53 * hackagebot generic-binary 1.0.0 - Generic Data.Binary derivation using GHC generics.  http://hackage.haskell.org/package/generic-binary-1.0.0 (SebastiaanVisser)
13:07:01 <mm_freak> lol shachaf
13:07:07 <byorgey> @remember shachaf It's-a me, MonadIO!
13:07:07 <lambdabot> Done.
13:07:22 <Eduard_Munteanu> elliott: TBH I'm unsure, but AFAIU IO-ish stuff that doesn't fit in ST should consist of a single thread.
13:08:13 <Eduard_Munteanu> mm_freak: I see...
13:08:20 <mm_freak> you know, safety is just one great feature of haskell…  another great feature is that you can express complicated programs easily
13:08:38 <mm_freak> by forcing everything into a supposedly-absolutely-safe framework you steal some of that expressivity
13:08:40 <byorgey> Thank you MonadIO! But our princess is in another thunk!
13:09:00 <Phyx-> anyone got any ideas?
13:09:38 <Eduard_Munteanu> Bah, I misread...
13:09:53 <Eduard_Munteanu> withFile is already in IO.
13:10:25 <Eduard_Munteanu> Anyway, I'm not advocating one way or the other, just trying to imagine stuff.
13:10:33 <mm_freak> Eduard_Munteanu: there are libraries for monadic regions, but they usually don't give you static guarantees
13:10:40 <galagala> Hi, I'm starting to learn haskell, now that I'm finished with a course on SML, I don't quite understand the main function, as far as I know SML doesn't have anything like it, I can't find a good explaination about it, can anyone help?
13:10:43 <mm_freak> only dynamic ones, which you can easily cheat
13:10:52 <shachaf> galagala: main isn't a function, it's an IO action.
13:11:01 <Eduard_Munteanu> Interesting, I should have a look at those.
13:11:14 <elliott> mm_freak: isn't the regions package meant to be static?
13:11:19 <shachaf> galagala: Haskell has this notion of "IO actions" that can be "executed"; they can be composed of other IO actions.
13:11:21 <elliott> runRegionT :: RegionControlIO pr => (forall s. RegionT s pr α) -> pr α
13:11:26 <elliott> there's the tell-tale sign, rank-2 types :)
13:11:45 <galagala> shachaf, ah okay, thanks
13:11:46 <mm_freak> elliott: indeed, regions is static
13:11:52 <shachaf> galagala: Read an introduction to IO in Haskell for more information, probably. :-)
13:11:55 <Eduard_Munteanu> @hackage regions
13:11:55 <lambdabot> http://hackage.haskell.org/package/regions
13:12:09 * Phyx- takes MonadIO hostage until someone helps him :P
13:12:24 <galagala> shachaf, okay, I'll have a look for that. Thanks again for the help :)
13:12:26 <shachaf> galagala: E.g. http://www.haskell.org/haskellwiki/Introduction_to_IO
13:12:52 <mm_freak> Phyx-: paste the cabal file together with the exact error message
13:13:07 <galagala> shachaf, thats seems to be just what i need :)
13:13:24 <shachaf> galagala: The important thing to remember is that an IO action is a static thing; evaluating it doesn't do anything. At the beginning of your program the RTS executes the "main" IO action, which can in turn execute others.
13:13:27 <byorgey> Phyx-: I vaguely recall something about the dependencies not applying to the Setup.hs file
13:13:27 <Phyx-> k, one sec
13:13:36 <byorgey> Phyx-: you may want to just edit Setup.hs so it does not require haskell98
13:13:44 <byorgey> Phyx-: presumably it is doing something like  'import List'
13:13:45 <Eduard_Munteanu> Random thought: has anybody investigated the possibility / safety of coST (TS?), as opposed to the OI comonad?
13:14:07 <daavidb> could some explain to me why the "memoized" fibonnaci function in section 2 of http://www.haskell.org/haskellwiki/Memoization uses memoization? how does the use of the map fib [0 ..] turn it into a memoized implementation?
13:14:07 <Phyx-> byorgey: that would be a problem, since it uses directory, don't know any other way to do a directory listing
13:14:17 <mm_freak> Phyx-: does it work, when you use 'cabal configure' instead of the Setup.lhs script?
13:14:23 <Sgeo|web> "Yet Haskell encour- ages programmers—even forces them—to forget space optimisa- tion until after the code is written, profiled, and the major space leaks found, and at that point puts powerful tools at the program- mer’s disposal to fix them. Maybe this is nothing to be ashamed of, after all. "
13:14:29 <Sgeo|web> I have to admit, this makes me sad
13:14:40 <Phyx-> mm_freak: i don't use the Setup.lhs file directly, I'm using a custom build type, so cabal itself is compiling it
13:14:42 <elliott> Eduard_Munteanu: I don't think you can do TS s a -> a, which you need for a comonad
13:14:53 <elliott> Eduard_Munteanu: unless it's like...
13:14:53 <Sgeo|web> It's almost like a weakly typed language telling users to fix their types as runtime errors come up
13:14:58 <elliott> Eduard_Munteanu: a -> (forall s. TS s a)
13:15:09 <Eduard_Munteanu> My initial guess is it's unsafe since we can't even provide a STT safely depending on the transformed monad.
13:15:16 <elliott> Sgeo|web: no, it's not trying to guess how a program will perform without scienceing on it
13:15:19 <mm_freak> Eduard_Munteanu: i remember edwardk stating that I/O doesn't form a comonad
13:15:26 <galagala> shachaf, ahh, i see. That's pretty different to what I've seen so far, seems interesting
13:15:34 <Phyx-> one sec, pasting
13:15:44 <elliott> Sgeo|web: it's very hard to figure out how fast a program will go without very specific knowledge of how it will be run
13:16:02 <Eduard_Munteanu> mm_freak: it breaks referential transparency AFAIK
13:16:04 <Phyx-> mm_freak: http://p.zhox.com/wosqpwxr
13:16:07 <elliott> anyway, that's standard practice in any language, I haven't seen anyone recommend optimising before profiling in a long time
13:16:14 <byorgey> daavidb: evaluating memoized_fib just indexes into a list
13:16:15 <Eduard_Munteanu> As for strict categorical properties, I'm unsure.
13:16:16 <mm_freak> Eduard_Munteanu: I/O might be an Extend, but definitely not a Comonad
13:16:16 <elliott> mm_freak: it gives you IO a -> a, so...
13:16:33 <mm_freak> though even Extend seems unlikely
13:16:43 <Sgeo|web> elliott: Not even replacing, say, O(n^n) space usage with O(n), hypothetically?
13:16:46 <mm_freak> because you need to pass it an (IO a -> b)
13:16:46 <byorgey> daavidb: and any parts of the list which are evaluated will hang around in memory, it won't be recomputed.
13:16:59 <elliott> Sgeo|web: optimisation here means microoptimisation
13:17:05 <elliott> as was being discussed in that quote, pretty much
13:17:07 <Eduard_Munteanu> mm_freak: presumably you'd be denied access to coreturn?
13:17:08 <elliott> algorithms are another thing
13:17:19 <byorgey> Phyx-: yeah, edit Setup.hs so it imports System.Directory instead of Directory
13:17:25 <elliott> mm_freak: I'm sure it is an Extend, but probably a pretty useless one
13:17:28 <Sgeo|web> But I thought Haskell space issues tend not to be microoptimization, as in severe space complexity issues
13:17:35 <daavidb> byorgey: and why does a list have this property and not a usual function call?
13:17:43 <elliott> Sgeo|web: they're also usually easy to fix
13:17:48 <byorgey> daavidb: because a list is a data structure
13:17:51 <Phyx-> byorgey: oh, damn, One of the only files I didn't write myself imported Directory
13:17:53 <Eduard_Munteanu> IIRC, the problems of OI were deeper than that :/
13:18:00 <Phyx-> byorgey: i didn't even notice that, thanks
13:18:00 <elliott> Sgeo|web: anyway, they reduce in frequency the better you get.
13:18:08 <elliott> I rarely get space leaks.
13:18:09 <mm_freak> Phyx-: sorry, i don't know how the Custom build-type works, but try to get rid of the h98 modules
13:18:12 <daavidb> hmmm so a list isn't a function?
13:18:17 <byorgey> daavidb: no
13:18:19 <DanBurton> @hoogle Ord a => [Maybe a] -> Maybe a
13:18:20 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
13:18:20 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
13:18:20 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
13:18:23 <Phyx-> mm_freak: yeah, byorgey's suggestion worked
13:18:45 <DanBurton> Does this function exist? minMaybe :: Ord a => [Maybe a] -> Maybe a
13:18:46 <daavidb> so everything is a function, except integers, floating point numbers, lists, etc?
13:18:49 <Eduard_Munteanu> Unless I'm misremembering it's something involving multiple world threads.
13:18:51 <byorgey> daavidb: a list is either empty []  or an element consed (:) onto another list
13:19:16 <byorgey> daavidb: I don't know what you mean by 'everything is a function'.  Functions are functions, and nothing else is. =)
13:19:32 <byorgey> that 'etc' is a long list.
13:19:50 * Phyx- releases MonadIO back into society
13:19:54 <byorgey> DanBurton: what should it do with Nothings?
13:19:59 <mm_freak> Sgeo|web: why does that make you sad?  space leaks seem to be our main concern…  other programmers struggle with buffer overflows, injection attacks, etc.
13:19:59 <Eduard_Munteanu> byorgey: admittedly Haskell blurs the lines between functions and values
13:20:00 <elliott> daavidb: only things that look like (a -> b) are functions
13:20:20 <elliott> Eduard_Munteanu: I don't think so. Unless you're using a really weird definition of function.
13:20:26 <elliott> Anyway, functions are values, just like integers are values.
13:20:41 <byorgey> Eduard_Munteanu: functions ARE values.  I don't think there's any line to be blurred.
13:20:45 <c_wraith> > 1 0
13:20:46 <lambdabot>   1
13:20:51 <mm_freak> Sgeo|web: i think once you are fluent in haskell even space leaks become less of a concern…  mostly you concern yourself with:  "how do i express …?"
13:20:51 <DanBurton> byorgey: if there are any Just x, it should find the minimum x
13:20:52 <byorgey> the line between function values and non-function values is not blurry.
13:20:54 <c_wraith> look, numeric literals can sometimes be functions!
13:20:57 <Eduard_Munteanu> elliott: it does depend on your definition of a function. For instance, you call void f(void) a function in C.
13:20:58 <shachaf> @google haskell everything is a function
13:20:59 <lambdabot> http://www.haskell.org/tutorial/functions.html
13:20:59 <lambdabot> Title: A Gentle Introduction to Haskell: Functions
13:21:00 <DanBurton> byorgey: if it is an empty list, or if it is full of Nothing, then Nothing
13:21:07 <shachaf> @google conal haskell everything is a function
13:21:08 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
13:21:08 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
13:21:24 <elliott> shachaf++ conal++
13:21:24 <shachaf> daavidb: Everything is a function, except for things that aren't functions, i.e., everything else.
13:21:24 <elliott> shachaf += conal;
13:21:26 <Eduard_Munteanu> So all values can be functions in that sense
13:21:30 <conal> :)
13:21:37 <joseanpg> where could I find documentation about real GHC Core?
13:21:44 <Phyx-> shachaf >> conal
13:21:59 <elliott> shachaf %= sqrt(conal)
13:21:59 <Eduard_Munteanu> (nullary, but still)
13:21:59 <mm_freak> byorgey: some people call functions wrapped in a newtype constructor functions…  i catch myself doing that from time to time
13:21:59 <shachaf> Um...
13:22:07 * shachaf is getting a bit uncomfortable with this.
13:22:43 <mm_freak> there is a slight blur in colloquial language
13:22:44 <conal> if you're very liberal with your definition of X, then yes everything is an X in Y.
13:23:05 <Eduard_Munteanu> Not mathematically though.
13:24:09 <DanBurton> @let minMaybe xs = case filter isJust xs of [] -> Nothing; js -> minimum js
13:24:11 <lambdabot>  Defined.
13:24:31 <shachaf> conal: I expect one reason people say "everything is a function" is that they think of functions as taking n arguments instead of just one, and then let n = 0 and see that it's just a value.
13:25:10 <conal> shachaf: that's one of the reasons/rationalizations i encountered.
13:25:17 <byorgey> DanBurton: minimumMay . catMaybes
13:25:24 <byorgey> DanBurton: get minimumMay from the 'safe' package
13:25:45 <byorgey> minimumMay :: Ord a => [a] -> Maybe a
13:26:51 <mm_freak> shachaf: another reason is that many non-functional programmers confuse "function" with "procedure"
13:26:53 * hackagebot concurrent-supply 0.1 - A fast current unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1 (EdwardKmett)
13:27:11 <elliott> edwardk: current?
13:27:13 <edwardk> can someone with 7.2 install that and let me know if the Trustworthy flag that caused cabal to whine works?
13:27:18 <edwardk> hah
13:27:26 <edwardk> concurrent =)
13:27:50 <Sgeo|web> Isn't everything a function in lambda calculus?
13:27:53 <DanBurton> byorgey: thanks
13:28:10 <mm_freak> Sgeo|web: no
13:28:32 <edwardk> i pushed a version with *con*current in the title, and removed the Trustworthy flag until cabal figures it out
13:28:34 <Sgeo|web> iirc, numbers and booleans are functions
13:28:36 <byorgey> Sgeo|web: yes, but Haskell is not lambda calculus, it is based on a lambda calculus extended with algebraic data types
13:28:39 <Sgeo|web> What aren't functions?
13:28:42 <Sgeo|web> Oh
13:29:04 <Sgeo|web> Well, I did say "lambda calculus" and not Haskell for a reason
13:29:05 <mm_freak> Sgeo|web: functions are an interpretation in λC…  there are no functions in lambda calculus…  there is the lambda abstraction, and there is beta-reduction
13:29:14 <edwardk> now i can rely on the external package from revisions
13:29:20 <byorgey> Sgeo|web: although even in the pure lambda calculus you still have variables which are not functions.
13:29:26 <byorgey> you just can't do much with variables and nothing else.
13:29:30 <Sgeo|web> ....oh
13:30:16 <mm_freak> though i think the story is different in typed lambda calculus, when you have a real function type
13:30:23 <rwbarton> mm_freak: you could use the same argument to say that there are no functions in haskell...
13:30:57 <rwbarton> it seems like a consistent point of view, but not a very practical one
13:30:58 <mm_freak> rwbarton: a function in haskell is a value of type a -> b for all a and b
13:31:15 <rwbarton> yes and a function in the lambda calculus is a value
13:31:42 <mm_freak> i don't think the term "function" makes a lot of sense in untyped lambda calculus, because you can apply everything to everything
13:31:57 * hackagebot concurrent-supply 0.1.1 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.1 (EdwardKmett)
13:31:57 <rwbarton> that just tells you that everything is a function
13:32:11 <daavidb> hmm still don't get it. if i call "memoized_fib 2", what "happens"? (see http://www.haskell.org/haskellwiki/Memoization)
13:32:13 <scooty-puff2> i am writing a toy compiler and am performing some passes to build the symbol table using Data.Generics - is this a common use of that library (traversing ASTs)?
13:33:03 <elliott> scooty-puff2: that is pretty much what syb is for
13:33:47 <scooty-puff2> k, thanks (wanted to check i wasn't doing something that was just in general a bad idea)
13:35:18 <bga_> wow joseanpg in irc
13:35:24 <byorgey> daavidb: memoized_fib 2 = map fib [0 ..] !! 2 = ((fib 0) : map fib [1..]) !! 2 = map fib [1..] !! 1 = ((fib 1) : map fib [2..]) !! 1 = map fib [2..] !! 0 ...
13:35:53 <byorgey> daavidb: however, the important thing to realize is that 'memoized_fib' still refers to the list being generated so it is not garbage collected
13:36:40 <byorgey> now   map fib [2..] !! 0 = fib 2 = memoized_fib 0 + memoized_fib 1
13:37:04 <byorgey> but at this point  memoized_fib n = (fib 0 : fib 1 : fib 2 : map fib [3..]) !! n
13:37:42 <byorgey> and after we evaluate fib 2, fib 1, and fib 0, it will now be  memoized_fib n = (0 : 1 : 1 : map fib [3..]) !! n
13:38:06 <joseanpg> bga_ !!!
13:38:12 <byorgey> in other words, the definition of memoized_fib is incrementally evaluated as needed
13:38:15 <joseanpg> hehehe
13:38:38 <bga_> joseanpg you ignore my lang :(
13:39:01 <byorgey> daavidb: does that help?  It is a bit hard to wrap your head around at first.  It depends on the particular way in which lazy evaluation happens.
13:39:12 <joseanpg> tell me
13:39:25 <joseanpg> bga_ news?
13:39:40 <joseanpg> channel?
13:39:57 <byorgey> joseanpg, bga_: #haskell-blah please
13:40:08 <bga_> ok
13:41:06 <Sgeo|web> If all binary builds of all Haskell compilers were to cease to exist, how could GHC be recompiled?
13:41:20 <Sgeo|web> Would it require early versions of GHC that implemented Haskell 1.x?
13:41:41 <Sgeo|web> Recompiling the forerunner of GHC in whatever language it was written in?
13:41:52 <mm_freak> Sgeo|web: same problem as with GCC
13:41:59 <mm_freak> you need a C compiler to compile GCC
13:42:29 <daavidb> byorgey: i'm struggling. should i try to imagine how tree reduction would work on the expression?
13:42:32 <Sgeo|web> What was the last version of GHC to not need a Haskell compiler to be compiled?
13:42:45 <byorgey> daavidb: do you mean graph reduction?
13:42:52 <daavidb> sorry graph reduction
13:43:09 <roconnor> Sgeo|web: nix has builds ghc from scratch
13:43:17 <roconnor> s/has//
13:43:21 <byorgey> daavidb: yes, I think you really can't understand this fully without thinking in terms of graph reduction
13:43:42 <roconnor> nix builds everything from a small set of binaries
13:43:56 <daavidb> ok cool i'll give it a try. thanks for the help.
13:43:59 <roconnor> (and a bunch of souces)
13:44:03 <elliott> Sgeo|web: please don't destroy all those binaries
13:44:07 <elliott> it would be very unkind
13:44:12 <elliott> also nearly impossible
13:44:36 <elliott> Sgeo|web: but i presume the last ghc to not need a haskell compiler would be the one written in lml
13:48:42 <Sgeo|web> Hmm, using the runtime that GHC can give as part of an OS
13:49:11 <c_wraith> halvm?
13:49:16 <mm_freak> roconnor: do you use NixOS?
13:49:19 * Sgeo|web is reading about House
13:49:34 <c_wraith> halvm is the successor to house, I believe
13:49:53 <mm_freak> Sgeo|web, c_wraith: http://hasp.cs.pdx.edu/
13:50:24 <Sgeo|web> Huh, didn't realize House had a successor, ty
13:50:51 <mm_freak> Sgeo|web: the HASP project is a successor, but they are developing a haskell-like language for systems programming
13:50:56 <mm_freak> so it's not exactly haskell
13:51:01 <elliott> c_wraith: Sgeo|web: I don't think so
13:51:04 <elliott> HalVM just runs on Xen
13:51:34 <elliott> and I don't think it has any "OS-like" stuff
13:51:37 <Sgeo|web> "In addition to this real implementation, we have developed a model implementation of (most of) the hardware monad entirely in pure Haskell 98.  "
13:51:43 <Sgeo|web> (from the House paper0
13:51:49 <Sgeo|web> That's basically an emulator?
13:52:33 <mm_freak> Sgeo|web, c_wraith: http://vimeo.com/14069325
13:52:57 <mm_freak> a talk on Habit, a haskell-like systems programming language, part of the HASP project
14:05:57 <copumpkin> quiet in here
14:06:14 <ecuageo> until you said something
14:06:53 <ddarius> License.
14:07:09 <Phlogistique> is there a way to access docs in command line?
14:07:31 <shachaf> cat
14:07:32 <ddarius> start Foo.docx
14:07:43 <Phlogistique> GHC docs
14:07:52 <rwbarton> hoogle?
14:07:52 <ddarius> wget
14:08:12 <Phlogistique> so nothing really made for programmatic use?
14:08:17 <shachaf> vi ghc/ghc/libraries/base/foo.hs
14:08:35 <shachaf> "command line" /= "programmatic"
14:08:48 <rwbarton> What is the program going to do with these docs?
14:08:50 <rwbarton> read them?
14:09:07 <Phlogistique> rwbarton: yes. cat them on the output
14:09:14 <ddarius> Excellent idea!  Let's automate the process of reading documentation so we don't have to anymore!
14:09:16 <Phlogistique> or in a pager
14:09:51 <Phlogistique> I mean, something like man 3 for C or ri for Ruby
14:10:38 <mm_freak> Phlogistique: get your favorite text browser and point it at your local haddock manual
14:10:46 <MostAwesomeDude> Hm.
14:10:46 <ddarius> Is there a web user file system?
14:10:58 <MostAwesomeDude> Okay, so IIUC I can use the ST monad to have state, inside the monad.
14:11:00 <mm_freak> lynx ~/.cabal/share/doc/index.html
14:11:09 <MostAwesomeDude> And then when I'm finished, I can return "out
14:11:22 <MostAwesomeDude> Er, "out" from runST, and back to whomever called me. Right?
14:11:26 <mm_freak> MostAwesomeDude: yes, though a monad is a type…  you have a stateful computation
14:11:33 <mm_freak> or action or whatever you call it
14:11:35 <ion> You might want to look at State first. Perhaps it’s enough.
14:11:42 <Phlogistique> mm_freak: this is clearly not even nearly equivalent to man or ri
14:11:55 <MostAwesomeDude> But I don't appear to be able to *persist* the stuff inside any given ST section.
14:12:03 <ddarius> It's better.
14:12:04 <mm_freak> Phlogistique: personally i use firefox…  together with search-as-i-type i'm usually faster than with man
14:12:08 <MostAwesomeDude> Do I need to use MVars if I want things to persist beyond any single given call?
14:12:33 <Phlogistique> mm_freak: "search-as-i-type", you mean Google?
14:12:34 <mm_freak> Phlogistique: open firefox (with a blank page as the start page), type "hstd", press enter, you are in the haddock manual
14:12:40 <c_wraith> MostAwesomeDude: IORef is fine, in many cases
14:12:46 <shachaf> MVars are a concurrency thing.
14:12:56 <shachaf> What are you actually trying to do?
14:12:57 <mm_freak> Phlogistique: to get that, create a bookmark to the manual giving it the "hstd" keyword
14:13:09 <rwbarton> or create a search keyword "h" for Hoogle/Hayoo
14:13:12 <MostAwesomeDude> shachaf: Stateful network protocols.
14:13:24 <mm_freak> Phlogistique: then you can just type part of the module name, press enter, type part of the symbol name, press enter
14:13:27 <shachaf> MostAwesomeDude: ST is for making pure functions that happen to use mutable refs internally.
14:13:30 <Phlogistique> rwbarton, mm_freak: I'd love being able not to rely on an Internet connection
14:13:45 <ion> > evalState (put "persists" *> modify (++ "?") *> get) "blah"
14:13:47 <lambdabot>   "persists?"
14:14:08 <mm_freak> Phlogistique: i don't rely on an internet connection
14:14:23 <mm_freak> Phlogistique: put "documentation: True" into your ~/.cabal/config
14:14:30 <mm_freak> then everything gets built with local documentation
14:14:31 <ddarius> mm_freak: Perhaps Phlogistique can only connect to his own computer through an internet connection.
14:14:33 <MostAwesomeDude> shachaf: I see. What would I do to have a stateful network protocol, then?
14:15:03 <ddarius> @google representing state machines in Haskell
14:15:05 <lambdabot> http://hackage.haskell.org/package/fsmActions
14:15:05 <lambdabot> Title: HackageDB: fsmActions-0.4.3
14:15:19 <Phlogistique> mm_freak: oh, thanks
14:15:21 <mm_freak> MostAwesomeDude: i think we covered that yesterday:  concurrency + StateT + perhaps STM
14:15:48 <Phlogistique> ddarius: your sarcasm is quite unhelpful.
14:16:07 <MostAwesomeDude> mm_freak: Yes and yet no.
14:16:51 <mm_freak> ddarius: IMO state machines are better represented as an arrow
14:17:15 <mm_freak> MostAwesomeDude: well, you didn't see examples, but i really recommend you to just go ahead and write a small server for a small custom protocol
14:17:20 <mm_freak> like a chat protocol
14:17:42 <mm_freak> with STM this should be really easy
14:17:58 <MostAwesomeDude> "Really easy" is relative, I think.
14:18:37 <shachaf> MostAwesomeDude: Which part is not easy?
14:18:44 <mm_freak> sorry, i always do that…  it shouldn't be too difficult =)
14:19:06 <mm_freak> with "really easy" meaning "really easy if you understand concurrency and STM"
14:19:41 <ddarius> A simple chat server doesn't require too much understanding of concurrency and doesn't really benefit a whole lot from STM.
14:20:18 <mm_freak> ddarius: the STM variable to hold all the other clients for broadcasting
14:20:28 <mm_freak> otherwise you need a manager thread or something like that
14:21:48 <ddarius> mm_freak: An MVar works just as well, and I would do it with a thread that explicitly handled the broadcasting.
14:22:44 <mm_freak> i'd write functions around an STM variable…  in practice i found that to be faster
14:23:09 <mm_freak> and also less code
14:23:14 <ddarius> I don't think speed is going to be a big deal.
14:23:39 <mm_freak> well, it really depends on whether you like messaging or not =)
14:23:47 <c_wraith> I'm still looking for a case where STM really makes sense...
14:24:07 <ddarius> c_wraith: Pretty much any time you are working with shared mutable state, STM makes sense.
14:24:16 <mm_freak> c_wraith: you can always do without STM
14:24:21 <c_wraith> ddarius: well, not with the current implementation.
14:24:44 <mm_freak> c_wraith: when you have to wait for multiple concurrent events, STM makes sense
14:24:58 <c_wraith> bos used STM in his Pool implementation.  But I'm not sure that's the best pool approach.
14:25:25 <mm_freak> atomically $ (Nothing <$ (readTVar quitVar >>= check)) <|> (Just <$> readTVar nextVar)
14:25:43 <mm_freak> should we quit or process the next whatever?
14:27:02 <mm_freak> also when moving something from one variable to another…  without STM you need locking for that (or, as an always valid last resort solution, a manager thread)
14:27:18 <acowley> STM lets you easily refine the granularity of access to shared state
14:27:48 <c_wraith> acowley: but with the current implementation, I've yet to see cases that have a real benefit from more granular access.
14:27:52 <acowley> you start with a simple value in an MVar, then you put a record in the MVar, then you want lenses on that record or something
14:28:26 <acowley> c_wraith: I don't know if one can come up with a satisfying, concise, canonical example
14:28:57 <ddarius> The typical bank example seems, as I think SPJ went over in one of his STM talks, seems to be all three of those.
14:29:13 <acowley> c_wraith: is your contention that the STM implementation precludes simultaneous execution when the transaction logs are disjoint?
14:29:31 <acowley> yes
14:29:54 <c_wraith> acowley: not at all.  The opposite, in fact.  That it harms performance *except* when the transaction logs are disjoint.  And disjoint transaction logs are not common.
14:30:24 <ddarius> c_wraith: Okay, it's as I thought.  Don't think of it as "How does STM improve performance?"  STM is about correctness.
14:30:36 <acowley> c_wraith: I disagree! Run a bank, have an STM TVar for each account.
14:30:59 <c_wraith> ddarius: fine, but it's no more correct than "entire bank state in one MVar", and more complicated.
14:31:29 <acowley> c_wraith: I used STM when I had to implement local coordination in a population of concurrently executing agents. The transient coalitions would typically be disjoint, meaning that avoiding a global lock enabled parallelism.
14:31:46 <mm_freak> c_wraith: disjoint transaction logs are very common for me
14:31:57 <c_wraith> mm_freak: in what problem domain?
14:32:01 <acowley> I don't think it is more complicated
14:32:11 <acowley> and it offers improved performance when that is possible
14:32:16 <acowley> that's the whole point
14:32:16 <mm_freak> i don't use STM only for large stuff…  i frequently use STM only to have a separate variable to signal a thread to quit
14:32:22 <ddarius> c_wraith: No, that wouldn't work.  If I had a deposit and a withdraw, transfer would not be deposit >> withdraw with "entire bank state in one MVar"
14:32:47 <c_wraith> ddarius: ok, yes.  The composition there needs to be done explicitly, instead of just working.
14:33:07 <ddarius> c_wraith: Yes, and when you screw that up you get deadlock.  Deadlock cannot happen with STM.
14:33:15 <acowley> c_wraith: how is using STM harder than manually obtaining a global lock?
14:33:16 <c_wraith> ddarius: but none of this changes that those access patterns just aren't what I ever run into problems I solve
14:33:41 <c_wraith> acowley: not harder, just more verbose compared to working on pure structures.
14:34:00 <ddarius> c_wraith: The comparison isn't to pure structures.
14:34:07 <acowley> well, I though the point here was that we were working with shared variables
14:34:12 <acowley> so they're not pure from the outset
14:36:00 <acowley> c_wraith: None of this is to say that STM will be an easy way to gain parallelism in your application, of course. I think the argument is instead that it is virtually zero programmer overhead when compared to just working in IO, and when you have irregular access to the shared resource, you can have multiple threads making progress simultaneously.
14:36:08 <c_wraith> Well, it really is a comparison to pure structures.  gated by access to an MVar, but still a pure structure inside it.  No part of manipulating the structure needs to care about the details of handling the MVar.  As opposed to STM, where all parts of manipulating TVars need to care that they're TVars
14:36:45 <ddarius> c_wraith: You can just as well have a single TVar with a pure structure inside.  I already demonstrated that a single pure structure inside an MVar in inadequate.
14:36:58 <acowley> c_wraith: But then every transaction has to lock the whole bank!
14:37:09 <c_wraith> ddarius: if you do that, you will have horrible performance.  trust me, I've tried.
14:37:18 <ddarius> c_wraith: Again, it's not about performance.
14:37:21 <c_wraith> acowley: yep.  Turns out to not matter in most use cases.
14:37:25 <acowley> c_wraith: if your shared state is a pure structure in an MVar, you can never have simultaneous updates to shared state.
14:37:42 <c_wraith> ddarius: it *is* about performance, when STM becomes too slow to work.
14:37:50 <mm_freak> c_wraith: also you might have tried wrong…  if you have only a single TVar, the TVar performs just like an MVar and probably even better
14:37:50 <c_wraith> ddarius: livelock is not better than deadlock
14:37:59 <c_wraith> mm_freak: very, very, very false
14:38:11 <acowley> c_wraith: That conjecture is not true. In the example I gave, it was critical to the system working at all.
14:38:25 <ddarius> c_wraith: The STM in Fraser's thesis is actually lock-free (a particular technical term) which means it can't live-lock either (though it is subject to starvation.)
14:38:35 <ddarius> Also performance is a bit moot if your code is broken.
14:39:03 <mm_freak> c_wraith: i'm a regular user of STM…  done properly you won't have performance loss, at least not in the noticable scale
14:39:17 <c_wraith> I've done these tests.  With a single reference that all transactions update, TVars perform horribly under load.  MVars degrade gracefully.
14:39:27 <Phlogistique> mm_freak and ddarius, by the way: I had not noticed that Hoogle has a command line interface. That's what I was looking for.
14:39:41 <acowley> On c_wraith's side is that we don't have a wealth of readily available, real world STM killer app examples.
14:39:45 <mm_freak> Phlogistique: that gives you symbols and locations, but not documentation
14:40:01 <ddarius> Phlogistique: hoogle was one of the first things that was said to you.
14:40:06 <AtnNn> what is a better way to do (header >> fmap (parse payload . decompress) takeLazyByteString) in attoparsec? the result is a stacked (Result (Result a))
14:40:12 <mm_freak> acowley: unfortunately much of the code i write is commercial, but i do have some libraries on hackage, which use STM
14:40:14 <acowley> I thought I remembered SimonM saying what mm_freak said
14:40:18 <c_wraith> acowley: none of this is to say I don't think STM is a terrific idea.  It just doesn't solve any problem I've had better than other approaches.
14:40:35 <c_wraith> there are many problems I've never had.
14:40:36 <acowley> (about TVar being faster than MVar in some cases)
14:40:39 <Phlogistique> ddarius: yes. I thought it was only available though a web browser.
14:40:48 <Phlogistique> mm_freak: oh. OK
14:40:54 <mm_freak> c_wraith: whenever you are urged to write a manager thread or write a thread just for waiting on multiple variables, STM would be your friend
14:41:15 <mm_freak> c_wraith: you just have to try it and learn to use it properly
14:41:39 <acowley> I probably use Chans and threads and whatnot more than STM myself :/
14:41:41 <c_wraith> mm_freak: this isn't about not understanding it.  This is about "why does that program keep exploding?  oh, it's using STM.  replace that, and it works"
14:42:09 <acowley> c_wraith: it would be really helpful if you could make available a reasonably sized example of this
14:42:24 <mm_freak> c_wraith: "it's using STM" can't be the reason, because STM code can boil down to whatever you would have written using traditional concurrency constructs
14:42:28 <acowley> c_wraith: if it's a compelling example, then we want as much of the community to think about it as possible
14:42:33 <mm_freak> c_wraith: on the other hand "STM used wrong" can very well be a reason
14:42:41 <c_wraith> acowley: no examples I have could charitably be called "reasonably sized"
14:42:54 <mm_freak> just understanding what all the constructs are about and what the functions do does not make an understanding of how to use STM
14:43:06 <acowley> yeah, so we're all making unfounded assertions about our own anecdotal experience
14:43:11 <c_wraith> mm_freak: yes, but my point is that "using only one TVar in all overlapping STM transactions is using STM wrong"
14:43:34 <mm_freak> c_wraith: yeah, i'd totally agree with that
14:43:46 <mm_freak> at least in most applications
14:44:03 <MostAwesomeDude> I'm sorry to have started this argument. :c
14:44:28 <acowley> also, I don't think burying state accessors in the STM monad is so deletorious to the effort to write pure code
14:44:49 <acowley> I have lots of code that looks more or less like,  atomically $ f <$> getA <*> getB <*> getC
14:45:03 <acowley> all my time is spent writing f
14:46:14 <c_wraith> Hmm.  I guess I'm thinking of structures that use TVars recursively.  There are plenty of options short of that.
14:46:38 <ddarius> c_wraith: Indeed.  Think of just having two variables, like two bank accounts.
14:46:40 <c_wraith> Also, are there TArrays?  It'd be nice to have something with the functionality of an array of TVars, but simpler access.
14:46:55 <mm_freak> c_wraith: yes
14:47:14 <mm_freak> though i guess Map k (TVar a) is probably a better abstraction in most applications
14:49:46 <ddarius> (If bank account is too unrealistic, consider the beginning and end of a queue.)
14:50:05 <acowley> or credit unions
14:50:54 <c_wraith> the thing that bugs me about the bank account example really is that I object to the premise on the basis of not being rational.  The lack of durability really does just kill it, for me.
14:51:11 <c_wraith> Hmm.  Isn't TChan just that simple queue?
14:51:19 <ddarius> I believe so.
14:51:51 <ddarius> As I said, you can think of the ends of a queue instead of bank accounts, as an example that might (and does) actually happen.
14:52:07 <zmv> @protontorpedo
14:52:07 <lambdabot> why is haskell bette than java? java has a shitload of frameworks. its xrazy
14:52:25 <c_wraith> xrazy is a good term for something.  I'm just not sure what, yet.
14:52:57 <zmv> looks like somebody failed on his/her lojban classes :P
14:52:58 <acowley> it's how you describe late night at a radiology conference
14:53:12 <ddarius> This rotating, plasma consuming black hole is xrazy.
14:53:40 <Philonous> Is there some documentation for the high-level design of yi?
14:53:51 <acowley> asstrofisx
14:54:35 <acowley> Philonous: I guess you've seen the haskellwiki page?
14:56:30 <Philonous> acowley:  Yes, and it's not particularly helpful, just a bunch of outdated miscellanea.
14:59:58 <dibblego> how do I load a module in ghci that is compiled with CPP and other extensions in the cabal file?
15:00:58 <dibblego> specifically, pasec3
15:01:01 <dibblego> parsec3
15:02:02 <acowley> Philonous: Maybe you could email a maintainer to ask for some help
15:03:40 <bovinespirit> \quit
15:04:40 <lcfrs> hi, is there something like a `cabal-dev runhaskell`? i want to use runhaskell, but import things from the cabal-dev sandbox?
15:04:57 <smns> dibblego, 'import Text.Parsec'?
15:05:23 <dibblego> smns: I am trying to :load Text/Parsec.hs
15:05:27 <smns> dibblego, sorry, in ghci, ':m + Text.Parsec'?
15:05:49 <dibblego> I want to load the source
15:06:44 <smns> dibblego, does it give you some error? maybe you need to make sure its dependencies are compiled and/or available in path.
15:06:55 <ricree> Anyone familiar with Yesod?  I'm playing around with it for the first time, and the widgets don't always seem to load correctly.  With the default scaffolding, do you have to do something more than just place the properly named files in the right directory?  Because the hamlet templates load fine, but the css ones don't and the javascript ones didn't for a while either
15:06:57 <dibblego> the error is about CPP directives in the source
15:07:20 <dibblego> it is compile with a .cabal file which includes this extension and many others
15:07:33 <rwbarton> ricree, sounds like there could be an issue with caching in your browser?
15:09:19 <ricree> rwbarton:  I thought of that, but when I open up the temporary files it generates, they're also incorrect.  I tried deleting them, and it generates them again.  same with restarting the dev server
15:11:21 <Phlogistique> @pl \a -> (a, a)
15:11:21 <lambdabot> join (,)
15:11:22 <shachaf> dibblego: ghci -XCPP
15:11:42 <shachaf> (And -XAllTheOtherExtensions.)
15:12:35 <Phlogistique> @pl \a -> [a, a]
15:12:35 <lambdabot> ap (:) return
15:13:00 <Ferdirand> such a gain in clarity !
15:13:49 <Phlogistique> @pl \f a -> f a a
15:13:49 <lambdabot> join
15:13:49 <c_wraith> hahaha
15:14:16 <c_wraith> :t (:) <*> pure
15:14:17 <lambdabot> forall a. a -> [a]
15:14:21 <Phlogistique> Is this join the same as http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:join ?
15:14:23 <c_wraith> clearly that's better.
15:14:26 <c_wraith> yes
15:14:29 <c_wraith> that's the same join
15:14:40 <c_wraith> > join (+) 7
15:14:40 <lambdabot>   14
15:14:52 <ion> > join [[1, 2], [3, 4, 5], [], [6]]
15:14:53 <lambdabot>   [1,2,3,4,5,6]
15:14:58 <ion> > join (Just (Just 42))
15:14:59 <lambdabot>   Just 42
15:15:33 <Phlogistique> c_wraith: I don't understand how (+) has type (Monad m) => m (m a)
15:15:43 <ion> @type join
15:15:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:15:44 <c_wraith> Phlogistique: m = (a ->)
15:15:55 <ion> @type join `asAppliedTo` (undefined :: a -> a -> b)
15:15:56 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
15:16:22 <ion> @djinn (a1 -> a1 -> a) -> a1 -> a
15:16:23 <lambdabot> f a b = a b b
15:16:43 <lcfrs> jaspervdj: ping
15:16:56 <c_wraith> Phlogistique: so a -> (a -> b), after join, becomes (a -> b)
15:17:05 <Ferdirand> the Reader monad in disguise
15:17:16 <c_wraith> Phlogistique: of course, that only works because there's a Monad instance for ((->) a)
15:17:27 <ion> phlogistique: http://heh.fi/haskell/functors/#function-instance
15:17:28 <Phlogistique> c_wraith: ok
15:17:34 <c_wraith> (it uses that syntax because you can't partially apply type functions)
15:17:37 <rwbarton> (to be pedantic, (+) doesn't have type [forall a m.] (Monad m) => m (m a), it has type m (m a) for some particular m which is a Monad)
15:17:55 <c_wraith> (err, can't do sections of infix type operators)
15:18:01 <lcfrs> jaspervdj: i'm looking at extending your websockets library so that i can return an http response without upgrading to the websocket depending on the request path... am i heading into dangerous territory?
15:25:40 <singpolyma> Is there a cleaner way to do this: http://pastie.org/2833653
15:27:05 <elliott> singpolyma: you close the handle if it's closed?
15:27:27 <rostayob> does anybody uses the unification-fd package? I get what it does, but I don't get how you can do something useful with it
15:28:27 <smns> singpolyma, either you could certify that it's either open or closed, or you could try and close a closed file, if that doesn't give errors.
15:29:07 <singpolyma> elliott: I do, though I suppose I could just return () in that case as well
15:29:35 <singpolyma> smns: the problem is that hIsEOF errors on a closed stream
15:29:50 <elliott> singpolyma: you could just catch the exception
15:30:13 <singpolyma> elliott: could. that seems suboptimal
15:30:30 <elliott> singpolyma: it's probably faster :-P
15:30:49 <singpolyma> really?  I'm used to exceptions being slower
15:30:55 <singpolyma> they're certainly uglier
15:31:07 <elliott> singpolyma: Well, hIsEOF is already doing the check to figure out whether it's EOF.
15:31:08 <elliott> erm
15:31:09 <elliott> singpolyma: Well, hIsEOF is already doing the check to figure out whether it's closed.
15:31:16 <elliott> You're duplicating that check by using a conditional.
15:31:36 <singpolyma> Does it check, or does it just encounter some terrible error?
15:32:13 <elliott> singpolyma: It's not going to crash, if that's what you maen.
15:32:18 <elliott> We don't do things like that around here. :p
15:33:30 <singpolyma> elliott: sure, I don't mean a crash.  I mean, I've seen what happens as-is without the check.  It just prints an error message
15:33:38 <elliott> right.
15:33:48 <elliott> I'd just catch the exception: the handle being closed is presumably an exception state here
15:33:58 <elliott> Haskell's exceptions are really not that ugly.
15:35:05 <singpolyma> In my case the handle being closed is actually something I expect to happen.  It's a TCP socket handle, so closed means the other guy disconnected
15:35:35 <elliott> well, it's still not the norm for that piece of code, right? for every time it's closed, it will be unclosed many more tmies
15:35:36 <elliott> times
15:36:02 <singpolyma> sure
15:36:45 <jaspervdj> lcfrs: pong
15:36:46 <lambdabot> jaspervdj: You have 1 new message. '/msg lambdabot @messages' to read it.
15:37:14 <jaspervdj> lcfrs: Yeah, you shouldn't go there
15:38:14 <jaspervdj> lcfrs: You probably want to hook up websockets with either snap or yesod
15:38:34 <lcfrs> right, except they seem a little heavy
15:38:39 <lcfrs> for my usecase
15:39:35 <lcfrs> in runWebSocketsWith, just before tryFinishRequest, i thought maybe i could defer to something else
15:39:42 <lcfrs> and then pass its result into encodeResponse
15:40:23 <singpolyma> so, http://pastie.org/2833712 seems to work.  Am I guarenteed that hIsEOF will not run if hIsClosed was true, though?
15:40:48 <elliott> singpolyma: no, it will definitely run
15:40:57 <elliott> always
15:41:24 <singpolyma> really?  because it's not running in my tests...
15:41:34 <elliott> it is running, it's just not failing
15:41:36 <elliott> for whatever reason
15:42:12 <jaspervdj> lcfrs: If we expose Network.WebSockets.sendResponse from the library, you should be able to send your arbitrary HTTP response, neglecting acceptRequest/rejectRequest
15:43:41 <Cale> hIsEOF *does* normally throw an exception if run on a closed handle though.
15:44:38 <singpolyma> huh... you're right.  I can't reproduce the exception just now
15:47:01 * hackagebot scalable-server 0.1.1 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.1.1 (JamieTurner)
15:47:22 <instinctive> noob cabal q?
15:47:23 <instinctive> $ cabal-dev install unordered-containers
15:47:23 <instinctive> import Data.HashMap.Strict
15:47:23 <instinctive> => Could not find module `Data.HashMap.Strict'
15:47:23 <instinctive> do I need to add something to a path somewhere?
15:48:56 <jhance> instinctive: Not if everything is set up correctly
15:49:03 <jaspervdj> lcfrs: Got my last message?
15:49:03 <c_wraith> if you used cabal-dev to install unordered-containers, you'll need to use cabal-dev in the same environment to see it
15:49:13 <lcfrs> jaspervdj: i think it got lost
15:49:18 <jhance> instinctive: oh cabal-dev
15:49:19 <jaspervdj> lcfrs: If we expose Network.WebSockets.sendResponse from the library, you should be able to send your arbitrary HTTP response, neglecting acceptRequest/rejectRequest
15:49:21 <copumpkin> omg it's a jaspervdj
15:49:42 <liyang> Is there an equivalent of iteratee's NullPoint outside of the iteratee package?
15:49:46 <singpolyma> elliott et al: thanks for the help :)
15:49:48 <jaspervdj> Hello copumpkin
15:50:22 <jaspervdj> I got your message, didn't get it earlier because I haven't talked much on here lately, you should mail me next time ;-)
15:50:42 <jaspervdj> copumpkin: Basically, the easiest way for custom highlighters to plug in would be at pandoc level, I think
15:51:08 <copumpkin> jaspervdj: hmm! so not even touching hakyll?
15:51:25 <elliott> liyang: you probably want Monoid
15:51:37 <rostayob> copumpkin: highlighting-kate
15:51:44 <rostayob> that's how pandoc highlights stuff
15:51:51 <rostayob> but the flag is turned off by default
15:51:58 <copumpkin> yeah, but I don't want that kind of highlighting
15:51:59 <liyang> elliott: no, I don't have mappend. :-/
15:52:03 <jaspervdj> yeah but copumpkin wants to go and implement his own highlighter :-D
15:52:05 <copumpkin> I need much more sophisticated highlighting
15:52:11 <rostayob> incredibly sophisticated
15:52:20 <elliott> liyang: what semantics do you think empty has, then?
15:52:22 <copumpkin> because a shitty limited CFG isn't good enough for my high-brow languages
15:52:27 <elliott> a typeclass is nothing without semantics
15:52:31 <rostayob> what languages may i ask?
15:52:50 <ski> elliott++
15:53:08 <copumpkin> rostayob: agda
15:53:14 <ski> @remember elliott a typeclass is nothing without semantics
15:53:14 <lambdabot> Done.
15:53:18 <liyang> elliott: just a special element of the set.
15:53:20 <rostayob> copumpkin: i thought so.
15:53:22 <copumpkin> good luck specifying mixfix with layout in kate syntax files
15:54:00 <elliott> liyang: give it a name then
15:54:05 <elliott> liyang: or, here's a question:
15:54:13 <elliott> liyang: what code can you right given only the assumption about a type that it contains a special element?
15:54:17 <elliott> s/right/write/
15:54:31 <liyang> Compare against it.
15:54:58 <elliott> liyang: that requires Eq too. but okay, what useful algorithms does that produce?
15:55:05 <rostayob> copumpkin: then i don't know, it's probably going to be something ugly
15:55:10 <elliott> liyang: i.e.: when could you ever use this typeclass to write code that you'd want to use with more than one instance?
15:55:20 <copumpkin> I wonder if highlighting-kate plugs into pandoc in a nice manner
15:55:27 <jaspervdj> lcfrs: I'm off for some sleep, if you have some questions, mail me, I'll answer diligently tomorrow
15:55:27 <copumpkin> or whether pandoc is hardcoded to be aware of it
15:55:39 <rostayob> hardcoded i think
15:55:45 <jaspervdj> copumpkin: if it's hardcoded, you'll have to plug into haskell
15:55:54 <copumpkin> ugh
15:55:56 <rostayob> copumpkin: since it's a cpp flag
15:56:06 <copumpkin> oh, I mean the library interface that pandoc uses
15:56:08 <jaspervdj> copumpkin: but once you have something of the form String -> String which produces HTML...
15:56:25 <copumpkin> jaspervdj: I have such a thing
15:56:39 <copumpkin> but it seems less than ideal because I'd be hardcoding css classnames and such into it
15:56:48 <lcfrs> jaspervdj: thanks for replying
15:56:53 <copumpkin> I assumed it wanted a more semantic markup
15:57:18 <lcfrs> jaspervdj: i'll do more thinking and submit a pull request that you can give me some feedback on
15:57:25 <liyang> elliott: nonempty = filter (empty /=) perhaps?
15:57:26 <jaspervdj> lcfrs: awesome, thanks!
15:58:01 <elliott> liyang: you're pretending it has semantics by calling it "empty" :)
15:58:02 <jaspervdj> copumpkin: it's a bit ugly, I admit, but it's currently the best way with pandoc
15:58:08 <copumpkin> ah :/
15:58:21 <elliott> liyang: nonquux = filter (/= quux) -- what meaning does this code have? what algorithm is it implementing?
15:58:28 <liyang> elliott: fine, notspecial = filter (special /=) ;p
15:58:45 <jaspervdj> copumpkin: could you send me some kind of reminder? That way, I can quickly come up with a dummy highlighting filter tomorrow
15:58:53 <elliott> liyang: really though, I don't think you want such a typeclass at all
15:59:00 <copumpkin> jaspervdj: a dummy highlighting filter?
15:59:05 <elliott> out of curiosity, what structure is it that has something "empty" but not mappend?
15:59:14 <copumpkin> liyang: you looked at the default package
15:59:16 <copumpkin> ?
15:59:18 <copumpkin> @hackage default
15:59:18 <lambdabot> http://hackage.haskell.org/package/default
15:59:29 <copumpkin> gah
15:59:33 <copumpkin> what was it called
15:59:44 <copumpkin> http://hackage.haskell.org/package/data-default
16:00:06 <jaspervdj> copumpkin: An example of how you can plug in your highlighter, that is
16:00:31 <liyang> copumpkin: ah, am actually using that elsewhere… XD
16:00:34 <copumpkin> jaspervdj: well, my highlighter works but is still a work-in-progress because I haven't figured out how it'll need to tie in with the tools I want to use it with
16:00:45 <copumpkin> so I don't really have a fixed interface :)
16:00:50 <jaspervdj> copumpkin: I see
16:00:50 <elliott> copumpkin: another typeclass without semantics :(
16:00:51 <copumpkin> but yeah, I'll poke you tomorrow or something
16:00:59 <copumpkin> and you can tell me what works best and I can make that work
16:01:07 <copumpkin> elliott: "a distinguished value"
16:01:08 <hpc> elliott: https://en.wikipedia.org/wiki/Loop_%28algebra%29
16:01:25 <jaspervdj> copumpkin: How pandoc does it is produce a literal HTML string, and you can request the default CSS that goes with it
16:01:32 <copumpkin> jaspervdj: ah, I see
16:01:35 <jaspervdj> copumpkin: but yeah, I need some sleep :-)
16:01:40 <copumpkin> alright, thanks for the help!
16:01:40 <jaspervdj> talk to you later
16:01:41 <elliott> hpc: ?
16:01:58 <hpc> elliott: a structure with mempty but not mappend
16:02:02 * hackagebot scalable-server 0.1.2 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.1.2 (JamieTurner)
16:02:06 <hpc> though apparently it has division, so nvm :P
16:02:09 <elliott> hpc: well, ok :)
16:03:03 <liyang> elliott: if you really must know, it involves FFI bindings. ¬_¬
16:03:19 <elliott> that doesn't answer my question, but now i'm not sure i want an answer
16:03:23 <elliott> :)
16:04:01 <liyang> I just want to be able to supply a default value, and compare against it. I don't see what other semantics it needs.
16:04:32 <PiRSquared17> @pl \x -> (not (not x))
16:04:32 <lambdabot> id
16:05:14 <copumpkin> elliott: I don't see what's wrong with just saying you have a distinguished value
16:05:23 <elliott> copumpkin: well, calling it "empty".
16:05:41 <liyang> What's in a name anyway? ;p
16:05:42 <elliott> i can't really comment further without knowing liyang's actual structure :)
16:05:52 <liyang> There is no more structure!
16:06:00 <copumpkin> presumably it behaves "emptily" for some other operations that liyang cares about :)
16:06:09 <elliott> liyang: you have exactly one value and no operations?
16:06:11 <copumpkin> but that don't fit into the usual algebraic structure
16:06:14 <elliott> let me introduce you to ()
16:06:39 <liyang> elliott: it's an opaque datatype with a distinguished value.
16:09:00 <liyang> I pass it to some foreign function, I get another one back. I pass that back in. Repeat. When the foreign function is done, it returns this distinguished value.
16:10:16 <liyang> elliott: May I please have your blessings to use something like Data.Default now? :p~~
16:10:33 <elliott> liyang: hmm, that doesn't seem "default" to me
16:10:38 <elliott> I'd just export it as a regular named value
16:10:42 <copumpkin> REQUEST DENIED
16:10:42 <elliott> "finished" or whatever
16:10:50 * elliott is the typeclass police
16:10:52 * copumpkin pounds liyang into submission
16:11:07 <liyang> Except I give it as the initial value.
16:11:46 <liyang> I think I'll just call it class Whatever a where whatever :: a
16:13:04 <elliott> liyang: why do you need a typeclass at all?
16:13:12 <liyang> elliott: I have multiple types (and FFs) with this property. I want to write some generic code that works on all of them.
16:13:19 <elliott> hmm, fair enough
16:13:23 <elliott> sounds weird :P
16:13:25 <copumpkin> liyang: random thought
16:13:37 <liyang> elliott: it's FFI. ¬_¬
16:13:39 <copumpkin> liyang: could the foreign functions that need this initial value also be part of the typeclass?
16:13:59 <copumpkin> I think that would appease master elliott
16:14:24 <liyang> copumpkin: no. :)
16:14:33 <elliott> copumpkin: I don't know. It's a very slippery slope.
16:14:35 <copumpkin> data Whatever a where initial :: a; foreignWankery :: a -> CInt -> IO CInt
16:14:37 <liyang> copumpkin: they're different in other respects that don't fit this general pattern.
16:14:40 <copumpkin> ah okay
16:14:47 <elliott> Soon we'll have one big Num typeclass that corresponds to nothing even vaguely algebraic, with no laws, and a Show superclass!
16:15:05 <copumpkin> elliott is the sheriff
16:15:22 <elliott> liyang: ...so how can you write generic code, if you can't call the foreign functions with the distinguished values because they're not in the typeclass? :p (do you pass them to the generic code?)
16:15:27 <elliott> (couldn't you just pass the initial value too?)
16:15:30 <elliott> (ok, ok, I give up)
16:15:31 <Cale> elliott: If we're going to have instances like Float, there aren't all that many laws to be had anyway :P
16:15:47 <copumpkin> hey, Float has almost commutative operations
16:16:45 <elliott> almost commutative!
16:16:51 <liyang> elliott: I pass them to the generic code.
16:17:03 <copumpkin> elliott: just like fields have almost inverses
16:17:08 <Cale> actually, I think they may be properly commutative...
16:17:18 <Cale> But they're certainly not associative
16:17:24 <copumpkin> Cale: yeah, you're right
16:17:55 <Cale> Though commutativity of multiplication probably isn't something we want to demand of Num instances anyway
16:18:01 <liyang> elliott: I suppose we could drop typeclasses altogether and pass dictionaries explicitly.
16:18:03 <copumpkin> yeah
16:18:20 <elliott> liyang: the dictionary is one value in this case :P
16:18:38 <elliott> liyang: but... you might want to instead move more things from parameters into the typeclass
16:18:53 * copumpkin walks away
16:21:33 <liyang> elliott: thinking about it…
16:22:21 <augustss> > div (-1) 2
16:22:22 <liyang> elliott: no. Not possible.
16:22:22 <lambdabot>   -1
16:22:22 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
16:24:02 <elliott> liyang: so no two types share a possible function type to pass to a generic function?
16:24:10 <elliott> i.e., all of your generic functions actually only work on one type each?
16:24:27 <liyang> No, that's not the case.
16:24:43 <elliott> hmm, or is it that each function only covers like 3 types
16:24:45 <elliott> out of a possible 10
16:24:53 <elliott> so you can't put any one into the typeclass, because all 10 have to implement it
16:27:48 <stephan> what would be a good data structure to represent SKOS concepts (from semantic web)?
16:28:02 <stephan> I already posted a question  on stackoverflow ( http://stackoverflow.com/questions/8032731/haskell-data-structure-for-skos-semantic-web )
16:29:43 <stephan> my current solution would be to use directed graphs or binary relations
16:31:33 <liyang> elliott: Okay, I'm writing bindings to a library that does chained queries. More than one FF follow this pattern. I give it an initial sequence number (of sorts), it gives me an answer along with the next sequence number. When it's done enumerating the answers, it returns this special sequence number. Except there are multiple types of such sequence numbers.
16:32:40 <snappy> 1
16:32:47 <liyang> Why am I wasting time justifying myself here? ¬_¬
16:33:00 <elliott> liyang: class FF n t where { initial :: n; step :: n -> (t, n) } ?
16:33:04 <stephan> is there a library for binary relations on hackage?
16:33:35 <liyang> elliott: step there would require additional parameters.
16:33:45 <elliott> liyang: meh, ok :)
16:34:26 <liyang> I should have prefixed this discussion with "Look, I know what I'm doing." Not sure that would havve helped.
16:35:40 <elliott> liyang: don't worry, I'm like this to people who I know know what they're doing too :)
16:36:25 * liyang adds elliott to the ‘disregard’ list 
16:36:33 <liyang> All happy? =)
16:36:58 <elliott> I demand you undisregard this sentence!
16:40:41 <kfish> liyang: how about making a wrapper that returns in Maybe, returning Nothing when done?
16:41:02 <kfish> Nothing is special :)
16:43:13 <Sgeo|web> You know, if you're sufficiently demented, and write the right (horrendous) libraries, you could use Haskell like a vanilla strict impure language with strange syntax
16:43:16 <Sgeo|web> Possibly
16:43:35 <liyang> kfish: that'd add another level of indirection. :(
16:43:46 <kfish> yeah, indirection makes FFI go faster
16:44:50 <ircleuser> Hello
16:44:54 <liyang> I mean, I could try to enforce that “Just special” never shows up and is always converted to a Nothing…
16:45:12 <kfish> liyang: so instead of maybe, wrap the ffi calls in a continuation that calls the ffi call again if still valid ;-P
16:45:16 <Isthan> Would anyone be willing to give assistance with haskell questions?
16:46:04 <kfish> Isthan, sure, just ask
16:46:08 <PiRSquared17> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
16:46:08 <lambdabot> ap (. join id) (. join id)
16:46:09 <liyang> kfish: yes, there will be an iteratees interface. :p
16:46:32 <kfish> heh
16:46:37 <liyang> kfish: but someone else is going deal with that. ;p
16:47:44 <Isthan> I'm working with a 2 dimensional list of floats.  The list describes waypoints that a UAV travels.
16:48:00 <kfish> liyang: class GTFO a where ...
16:48:32 <Isthan> Each waypoint is formatted [a,b,c,d] where a=latitude, b=longitude, c=altitude, d=speed
16:48:45 <Sgeo|web> Isthan: Are you looking through the list in order, or are you looking up arbitrary values at arbitrary times
16:48:52 <Sgeo|web> Isthan: Wait, is that always 4 elements?
16:48:58 <Isthan> in order
16:49:00 <Isthan> yes always 4 elements
16:49:27 <Sgeo|web> If you always know what sort of thing each element is, you should use a tuple
16:49:35 <kfish> liyang: class GTFO a where gtfo :: a
16:49:46 <Sgeo|web> It allows for different types for each of the 4 elements, and forces the 4 element requirement
16:49:57 <Isthan> the 2 dimensional list is given in the input
16:50:18 <liyang> kfish: instance GTFO Nyan where gtfo = gtfo
16:50:40 <Isthan> (its not my choice of data structure, its given)
16:50:47 <byorgey> no, don't use a tuple. use a data type.
16:51:03 <PiRSquared17> A tuple isn't a data type?
16:51:17 <Sgeo|web> byorgey: I don't have much experience actually _using_ Haskell >.>
16:51:18 <PiRSquared17> Do you mean Constructor (a,b,c,d) ?
16:51:31 <kfish> Isthan: and what do you want to do with these waypoints?
16:51:48 <byorgey> ok, what's your question then?
16:51:51 <elliott> Constructor a b c d
16:51:52 <Isthan> Given a list of waypoints (waypoints being list of 4 floats) I need to simulate the mission that this figurative UAV travels
16:52:03 * hackagebot texmath 0.5.0.3 - Conversion of LaTeX math formulas to MathML.  http://hackage.haskell.org/package/texmath-0.5.0.3 (JohnMacFarlane)
16:52:21 <PiRSquared17> elliott: that's probably the best way :)
16:52:32 <byorgey> PiRSquared17: I meant a user-defined data type, like data Foo = Constructor Float Float Float Float
16:52:38 <PiRSquared17> I know
16:52:46 <PiRSquared17> I've used Haskell before...
16:53:19 <Isthan> So far i've been able to tell the distance and the elapsed time between each waypoint
16:53:44 <DanBurton> Is anyone here knowledgeable enough to help me with EclipseFP? I'm trying to install it but it is complaining about something related to Maven
16:54:03 * stepkut really needs to import two versions of the same library into his app at once :-/
16:54:09 <Isthan> I think I need to ask a more specific question, however
16:54:15 <Mertis> Im working with Isthan, i have a more specific question
16:54:37 <magn3ts> I feel dumb, I can't figure out how to do a print inside of a function when I'm doing some list processing.
16:54:39 <byorgey> you could even give the floats record labels so you don't forget which is which.
16:54:56 <PiRSquared17> magn3ts: Look up monads :)
16:54:57 <Mertis> given a list of floats, i want to creat another list, that cumulatively adds the numbers. the original list always starts with zero, so given [0,2,5,9], the resulting list sould be [0,2,7,16]
16:55:04 <DanBurton> stepkut: is the library open source? If so, fork it and give it a slightly different name
16:55:11 <Sgeo|web> Isthan: You can write a function to try to translate those 4-element lists to your own data type
16:55:50 <DanBurton> magn3ts: that's because you're not supposed to. In Haskell most functions are supposed to be pure: no side effects
16:56:00 <magn3ts> DanBurton, Unfortunately, the TA is an idiot.
16:56:23 <Sgeo|web> DanBurton: Why do you want to print? Output, or debugging?
16:56:31 <magn3ts> DanBurton, I appreciate that fact, and a minor change would make that possible, but if I change the main function, I will miss the entire section.
16:56:33 <stepkut> DanBurton: won't really help. The problem is there is a Serialize-type class and the stored format changed. So I need to read in the data with the old code, but write it out with the new code. But the code works by creating a bunch of Serialize instances for all your types.. so I can't just copy the functions. I would have to make two versions of all the Serialize instances as well..
16:56:34 <Sgeo|web> Erm, magn3ts
16:56:49 <XexonixXexillion> Mertis: scanl (+) 0 yourList will do the cumulative adding
16:56:49 <DanBurton> magn3ts: fortunately, everyone at #haskell is a genius :)
16:56:53 <magn3ts> Sgeo|web, it's how the TA is verifying that we are writing the function properly.
16:57:06 <Cale> magn3ts: Are you all using Haskell?
16:57:13 <byorgey> magn3ts: if you just want to do some debugging you can use Debug.Trace
16:57:30 <magn3ts> DanBurton, heh, certainly more than this guy, the last assignment was modified a dozen times becuase he didn't bother implementing it and hand wrote the output files before realizing what he was asking for was effectively impossible.
16:57:33 <magn3ts> Cale, yes.
16:57:38 <Cale> magn3ts: lol
16:57:40 <PiRSquared17> Don't use unsafe perform IO whatever you do...
16:57:44 <magn3ts> byorgey, I might be able to skate by with that.
16:58:01 <stephan> does anyone know where I find Data.Relation on hackage?
16:58:02 <Sgeo|web> magn3ts: What is the type of the function you're expected to write?
16:58:07 <stepkut> DanBurton: alternatively, I could read the old format, write it to some temporary format and recompile against the new library, and read back in the temp format. But there is no library like, toBS :: (Data a) => a -> ByteString, fromBS :: (Data a) => ByteString -> Maybe a. That actually works for types like Set AFAIK
16:58:12 <Axman6> magn3ts: does your tutor even know haskell? if they're asking you to print things inside your functions, they almost certainly do not
16:58:23 <magn3ts> Sgeo|web, [[Float]] -> [[Float]]
16:58:27 <DanBurton> PiRSquared17: The Function Which Shall Not Be Named!
16:58:31 <magn3ts> Axman6, I make no excuses for the guy.
16:58:34 <Sgeo|web> magn3ts: Then don't print inside it
16:58:35 <magn3ts> Axman6, lol.
16:58:36 <PiRSquared17> ! sorry
16:58:47 <magn3ts> Sgeo|web, I'm not allowed to modify the calling main function.
16:58:54 <Axman6> magn3ts: print the output in main
16:58:59 <magn3ts> :P
16:59:00 <Sgeo|web> magn3ts: what is the exact assignment?
16:59:00 <Axman6> :/
16:59:02 <elliott> magn3ts: give up
16:59:02 <magn3ts> I know, I know. lol.
16:59:08 <elliott> magn3ts: or import System.IO.Unsafe
16:59:11 <elliott> and use unsafePerformIO
16:59:12 <DanBurton> magn3ts: you can paste your code at http://hpaste.org/new/haskell if you'd like us to review it
16:59:14 <Axman6> no!
16:59:15 <elliott> note: requires defending yourself
16:59:17 <geheimdienst> how about Debug.Trace?
16:59:25 <elliott> Axman6: it's what i'd do in response to a request like that :P
16:59:26 <PiRSquared17> elliottThe function which shall not be named
16:59:28 <DanBurton> note: requires tainting your soul
16:59:41 <Sgeo|web> geheimdienst: I think Debug.Trace uses unsafePerformIO
16:59:46 <Axman6> it does
16:59:52 <Sgeo|web> Maybe main does some printing and magn3ts doesn't see it?
17:00:02 <magn3ts> DanBurton, there's no code yet. I'm supposed to implement a function of type [[Float]]->[[Float]] and inside it is supposed to print out.
17:00:06 <Axman6> but at least it only needed to be written once, and we can be sure it's correct
17:00:10 <magn3ts> Sgeo|web, the first three parts do. The last one doesn't. ;)
17:00:27 <Axman6> magn3ts: then your tutor/whoever set the task is an idiot
17:00:32 <Sgeo|web> Maybe it's a trick question
17:00:32 <geheimdienst> Sgeo|web: yes, but i think it's kind of acceptable. it's not likely to bite you in the behinditude in some subtle way. it seems to be a benign use of uPIO
17:00:32 <magn3ts> Which is why I was shaking my head when I read the description for part4 :)
17:00:35 <Cale> maybe write a function [[Float]] -> ([String],[[Float]]) instead?
17:00:41 <DanBurton> magn3ts: are you sure *that* function is supposed to print? maybe you simply mean it is supposed to produce a result, which is not the same as printing
17:00:56 <Cale> What is it supposed to print?
17:01:04 <monochrom> I want to look at the assignment verbatim no paraphrasing
17:01:05 <Cale> and what is it supposed to compute?
17:01:07 <magn3ts> DanBurton, I'm given output for the function, there is no print in main, and the assignment explicitly says to print the things in the output file.
17:01:22 <magn3ts> Yes, I'm 100% sure. And like I said, it was done "correctly" for the first 3 parts. :/
17:01:29 <DanBurton> magn3ts: I cannot imagine your teacher *actually* wants a pure function to cause side effects like printing
17:01:41 <Axman6> magn3ts: can you please paste the main function you've been given to hpaste.org?
17:01:42 <XexonixXexillion> I don't think his teacger want a pure functions at all
17:01:42 <monochrom> (and of course, if it is what you claim, I then want to see the assignment author solve it, too)
17:01:47 <Sgeo|web> I wish we could sign a note to the professor
17:01:50 <DanBurton> magn3ts: either that is the worst Haskell teacher ever, or the assignment specification is unclear
17:02:07 <magn3ts> http://hpaste.org/53765
17:02:20 <monochrom> (the scientific method: show me evidence, don't just talk)
17:02:36 <Axman6> uh... that's not at all what you were describing to us :\
17:02:41 <DanBurton> fireMissiles!
17:03:04 <magn3ts> ""Every time a [blahblahblah] the simulation must print a statement""
17:03:10 <Sgeo|web> magn3ts: yourMain is an IO thingy
17:03:31 <Axman6> you need to implement yourMain, which will act as your own version of main, but taking waypoints as an argument
17:03:32 <Sgeo|web> magn3ts: You can write IO code in yourMain
17:03:40 <Sgeo|web> Wait
17:03:41 <magn3ts> lol, sorry, I'll be more explicit.
17:03:47 <Sgeo|web> floatListSquared is also IO
17:03:55 * monochrom does not understand why bother with "mission = waypoints"
17:04:04 <Axman6> me either :\
17:04:05 <magn3ts> annotated: I am ONLY supposed to implement simulate.
17:04:05 <magn3ts> http://hpaste.org/53765
17:04:29 <PiRSquared17> So that it reads Your main mission probably monochrom
17:04:33 <Axman6> magn3ts: that clearly says you need to implement yourMain and simulate
17:04:45 <magn3ts> lol
17:04:52 <Sgeo|web> What Axman6 said
17:04:58 <magn3ts> okay, I was simply say Thank You and take the advice I've been given :)
17:05:29 <Sgeo|web> But that partFourOutput looks wrong
17:05:33 <magn3ts> Besides printing those statements, the function [simulate] should .....
17:05:46 <magn3ts> ^^ the verbage from the assignment.
17:06:15 <Sgeo|web> magn3ts: change yourMain, and complain about the wording stating that simulate should print stuff
17:06:29 <Axman6> that code is all hossible >_<
17:06:42 <Cale> There are tabs in this code
17:06:44 <Sgeo|web> hossible?
17:06:59 <magn3ts> I'm guessing "not that great", at the mildest.
17:07:02 <Sgeo|web> I can imagine writing code like that >.>
17:07:21 <Axman6> TABS!
17:07:24 <Cale> partFourOutput :: [[Float]] -> IO ()
17:07:24 <Cale> partFourOutput mission = do
17:07:24 <Cale> 	putStrLn "Simulation Ended"
17:07:27 <Axman6> :'(
17:07:33 <Cale> ^^ that doesn't use 'mission'
17:07:40 <magn3ts> Are tabs not idiomatic Haskell? /noobquestion
17:07:49 <Axman6> no, never use tabs in haskell
17:07:53 <Cale> Tabs are pure evil and must be eradicated
17:07:55 <monochrom> tabs can be made to work but tricky
17:07:56 <Sgeo|web> magn3ts: In general, for most programming languages, use spaces
17:07:59 <XexonixXexillion> kill it with fire
17:08:07 <Sgeo|web> Well, most indentation-sensitive
17:08:19 <magn3ts> Cale, right, it ought to just say putStrLn mission or something in there, where mission is the output array of my function
17:08:22 <Sgeo|web> Which, um, mainstream would be Python and Haskell
17:08:25 <monochrom> in general, paste on hpaste to see what GHC really sees. don't trust your editor.
17:08:34 <Axman6> magn3ts: email the lecturer or whoever and tell them to give you some code that could possibly work. this code as it stands, and with the bits you can't modify marked, is completely useless
17:08:54 <Sgeo|web> Axman6: It says you can modify yourMain
17:08:58 <magn3ts> Axman6, this is where it looks bad for me because it's due in 12 hours, and I've had weeks to do it.
17:09:04 <Sgeo|web> At least, as it's currently marked
17:09:18 <Axman6> magn3ts: heh... youre rooted =)
17:09:23 <Axman6> you're*
17:09:46 <magn3ts> I'm going to take Sgeo|web's suggestion and mark it as an "assumption" in the readme.
17:09:49 * monochrom still hasn't seen the complete assignment verbatim and is not fully convinced of all the claims
17:09:52 <Axman6> neurogeek: note, we won't do your homework for you, but we will give advice about writing haskell
17:10:06 <Axman6> uh, magn3ts, not neurogeek
17:10:09 <magn3ts> Axman6, lol, assuming that was at me.
17:10:21 <shachaf> Tabs are probably the third-best thing in the world.
17:10:24 <shachaf> After Comic Sans.
17:10:38 <monochrom> and what is the first best thing?
17:10:39 <magn3ts> monochrom, the assignment says verbatim "the function must print", and the function in question is of specified type [[Float]]->[[Float]] :P
17:11:41 <shachaf> They probably mean "the function must be".
17:11:52 <shachaf> That or unsafePerformIO.
17:12:02 <DanBurton> magn3ts: tell the teacher that #haskell finds the statement, "the function (referring to a function of type [[Float]] -> [[Float]] ) must print", to be most atrocious
17:12:13 <magn3ts> DanBurton, It's already in my readme. :)
17:12:18 <DanBurton> :)
17:12:47 <magn3ts> shachaf, after the number of times I've been told not to do that, I will avoid it simply to be "more correct". In the eyes of dear #haskell at least, haha.
17:12:56 <shachaf> Tell the teacher that #haskell told you to unsafePerformIO.
17:13:01 <XexonixXexillion> unsafePerformIO in a function that probably won't even be evaluated... -shudder-
17:13:20 <shachaf> XexonixXexillion: Huh? That's probably the best place you could possibly put unsafePerformIO.
17:13:21 <Sgeo|web> XexonixXexillion: ooh, nice catch
17:13:47 <magn3ts> Wait, why will it probably never be evaluated?
17:13:51 <magn3ts> Again, noobie here, sorry.
17:13:54 <elliott> because the other code doesn't call it
17:13:59 <elliott> at all
17:14:06 <elliott> you could implement it as anything you want as long as it types
17:14:08 <elliott> same results
17:14:11 <Cale> I already mentioned this ;)
17:14:37 <Axman6> magn3ts: if you never actually use a value in haskell, it never gets computed
17:15:02 <Axman6> > (\_ -> 7) (sum [1..])
17:15:03 <lambdabot>   7
17:15:04 <Cale> If you're not allowed to change main, no matter how you alter the code you're allowed to change, the program won't do anything different because they've assigned you to editing a piece of dead code.
17:15:04 <shachaf> Tell the teacher that #haskell told you to unsafeCoerce#
17:15:26 <elliott> magn3ts: Tell the teacher that #haskell told you to switch to F#.
17:15:30 <monochrom> tell the teacher to come to #haskell
17:15:31 * shachaf looks for the actual code.
17:15:32 <Axman6> shachaf: have you been introduced to the trollface emoticon yet? :7
17:16:18 <DanBurton> @slap shachaf
17:16:18 <lambdabot> I'd rather not; shachaf looks rather dangerous.
17:16:24 <DanBurton> -____-
17:16:27 <Sgeo|web> @slap lambdabot
17:16:27 * lambdabot throws some pointy lambdas at lambdabot
17:16:35 <Sgeo|web> @slap Sgeo|web
17:16:36 * lambdabot jabs Sgeo|web with a C pointer
17:16:37 <shachaf> lambdabot has a special case where she never @slaps me.
17:16:50 <monochrom> @slep shachaf
17:16:50 * lambdabot loves shachaf, so no slapping
17:16:55 <smns> it seems that when I play with records, changing a record always becomes an infix-expression, so I can't make it pointfree. (e.g. somerecord { foo = f $ foo somerecord }). is there any syntactic fix to this?
17:16:57 <monochrom> creepy
17:17:00 <monochrom> @slep shachaf
17:17:00 <lambdabot> why on earth would I slap shachaf?
17:17:05 <elliott> smns: you want lenses
17:17:07 <monochrom> ok I'm convinced!
17:17:11 <shachaf> smns: Look up lenses, e.g. data-lens.
17:18:11 <smns> shachaf, elliott: thanks, I'm sold. I like how they seem to be particularly for nested structures in state monads, which is exactly what I'm dealing with.
17:18:27 * monochrom wonders why lambdabot doesn't slap shachaf
17:19:10 <elliott> smns: :)
17:19:36 <elliott> smns: see http://hackage.haskell.org/package/data-lens-template for deriving them from a record declaration
17:19:37 <shachaf> Lenses are a breath of fresh in a world of more and more convoluted abstractions with no apparent point.
17:19:46 <elliott> A breath of fresh indeed.
17:19:57 <shachaf> Mmm, fresh.
17:20:00 <smns> yeah, thanks a bunch.
17:20:05 <MostAwesomeDude> Has anybody else used iterIO?
17:20:07 <shachaf> They oughtta make that stuff illegal.
17:20:20 <shachaf> monochrom: Because I don't deserve it.
17:20:24 <DanBurton> I've...read the amazing docs of IterIO
17:20:28 <MostAwesomeDude> I want to turn Iter t m a -> Iter t m a2, wrapping some function a -> a2.
17:20:28 <DanBurton> but never used it
17:20:46 <elliott> MostAwesomeDude: I used it briefly, and then switched away for various reasons. (Basically iteratees weren't very suited to my use-case.)
17:20:46 <Axman6> magn3ts: i think i have, i remember it had the nicest iteratee interface of any of the iteratee packages
17:20:57 <elliott> I liked it though (apart from the mass of dependencies).
17:20:57 <DanBurton> is Iter t m an instance of functor? sounds like a job for fmap
17:20:58 <Axman6> magn3ts: you can probably use fmap...
17:20:58 <shachaf> magn3ts: Wait, what's the actual code that's being discussed?
17:21:00 <Enigmagic> MostAwesomeDude: fmap ?
17:21:04 <Axman6> heh
17:21:05 <shachaf> magn3ts: Is it http://hpaste.org/53765 ?
17:21:12 <magn3ts> shachaf, yup
17:21:14 <elliott> MostAwesomeDude: You might want fmapI from iterIO.
17:21:26 <elliott> I think it does something slightly different, though I forget what.
17:21:38 <MostAwesomeDude> elliott: Hm, fmapI might do it.
17:21:43 <shachaf> magn3ts: Looks to me like yourMain is your function, i.e., it can do whatever you want, e.g., do something other than call partFourOutput.
17:21:48 <elliott> MostAwesomeDude: Well, fmap would do it too, as would liftM :-)
17:21:53 <elliott> But maybe fmapI does it better in some case or something.
17:21:59 <shachaf> As would unsafeCoerce.
17:21:59 <Sgeo|web> Do I need to understand comonads to understand lenses?
17:22:05 <magn3ts> shachaf, yeah, that's what someone else was telling me. but it looks like yourMain isn't actually called?
17:22:05 <shachaf> Sgeo|web: No.
17:22:33 <shachaf> magn3ts: main = do { blah blah; let blah blah in yourMain blah } ?
17:22:39 <shachaf> Looks like it's called to me.
17:22:41 <elliott> Sgeo|web: No.
17:22:44 <shachaf> Sgeo|web: A lens is really simple.
17:22:47 <elliott> Sgeo|web: data-lens uses the Store comonad underneath, but it's irrelevant.
17:22:52 <magn3ts> shachaf, others were telling me it won't be called??
17:22:53 <elliott> Lens whole part = whole -> (part, part -> whole)
17:23:10 <magn3ts> shachaf, Cale was saying it's not ever called?
17:23:15 <XexonixXexillion> partFourOutput doesn't look at mission
17:23:17 <Sgeo|web> Ok
17:23:19 <shachaf> magn3ts: I think there must be some misunderstanding.
17:23:19 <Cale> yourMain is called, but partFourOutput doesn't use its parameter
17:23:34 <shachaf> Who wrote partFourOutput? Your or your teacher?
17:23:34 <Cale> So I guess you can still do it if you don't use partFourOutput
17:23:45 <elliott> Sgeo|web: (The Store comonad used in data-lens is literally just (a, a -> b).)
17:24:01 <magn3ts> shachaf, not me.
17:24:11 <shachaf> Sgeo|web: Can you smell the fresh?
17:24:48 <elliott> Fresh smells the best.
17:25:19 <Sgeo|web> Automatically generated lenses as part of the language would be cool
17:25:32 <magn3ts> Someone was implying I can use IO inside of yourMain, but it doesn't like it and/or I'm an idiot.
17:26:07 <shachaf> magn3ts: Sure, yourMain is a function that gets "waypoints" and return an IO action.
17:27:27 <magn3ts> shachaf, okay, so I tried something like this: http://hpaste.org/53765 (at the very bottom) and it didn't care for it.
17:28:05 <Cale> magn3ts: Isn't simulate :: [[Float]] -> [[Float]] ?
17:28:10 <magn3ts> Cale, yes.
17:28:15 <shachaf> magn3ts: Did GHC print "I don't care for this code"?
17:28:17 <Cale> magn3ts: so simulate mission :: [[Float]]
17:28:25 <Cale> magn3ts: and thus is not an IO action which you can run
17:28:56 <Axman6> you can say let missionoutput = simulate mission though
17:28:57 <Cale> So  missionoutput <- simulate mission  doesn't make sense, because it says "run the IO action  simulate mission  and call its result  missionoutput"
17:29:31 <magn3ts> OH. I was repeating a pattern I didn't understand. I apologize. '<-' is reserved for IO?
17:29:46 <Sgeo|web> magn3ts: It's part of do notation
17:29:49 <Axman6> it's reserved for monadic computations
17:29:57 <Sgeo|web> Which can be used for IO, but can be used for other things
17:30:07 <Axman6> but don't worry about it for now, just assume it's for IO only as far as you're concerned
17:30:21 <shachaf> <- is just the thing you use when you want GHC to do something.
17:30:26 <Cale> Well, more generally for any monad m, if you have v <- x and if x :: m a, then v :: a
17:30:30 <shachaf> Sometimes if you really want to get your point across, you can put a few of them in a row:
17:30:36 <Axman6> we'll teach you the wonders of monads once you've handed in the assignment ;)
17:30:43 <Cale> shachaf: please don't troll the beginners
17:30:44 * shachaf stops.
17:30:53 <Axman6> </:7>
17:31:01 <gio123> Cale: hi
17:31:05 <SamB_XP> like "I wonder what a monad is?"
17:31:14 <magn3ts> :) This is quickly becoming my favorite IRC room ever, and I don't say that because I'm going to get stuck again :P
17:31:16 * shachaf apologizes.
17:32:00 <SamB_XP> or more like "I wonder what spacesuits have to do with waste-disposal containers?"
17:32:40 <elliott> shachaf: Troll the regulars instead.
17:32:41 <magn3ts> Ok, well I don't print "in the function" but I *never* thought that sounded like a good idea anyway. Now that the cruft is out of the way I can actually make this equally silly function do something useful.
17:32:58 <SamB_XP> yeah, the regulars understand and appreciate said trolling better
17:33:03 <magn3ts> elliott, shachaf, it was so far over my head that it was as equally un-understandable as what Cale said :P
17:33:55 <SamB_XP> magn3ts: you don't know what it means to "troll the beginners"?
17:34:13 <shachaf> I wish jokes came across more easily in IRC.
17:34:21 <magn3ts> SamB_XP, I mean shachaf's trolling was indistinguishable from the other bits.
17:34:32 <Sgeo|web> Are lenses allowed to contain effective getters but nil setters?
17:34:41 <Sgeo|web> The way one might set up something similar in an OO language?
17:34:41 <magn3ts> I've never had to explain that I got he was trolling, even without understanding what any of them were talking about RE: monads :P
17:34:51 <shachaf> Sufficiently advanced Haskell code is indistinguishable from trolling.
17:35:00 <c_wraith> Sgeo|web: that could be done with the new version of fclabels.
17:35:06 <magn3ts> hehe
17:35:08 <c_wraith> Sgeo|web: though it's not supported by default
17:35:13 <magn3ts> based on some code I've seen, I believe it.
17:35:34 <rwbarton> A lens without a setter is effectively just a function
17:35:41 <Axman6> magn3ts: have you managed to write the simulate function yet?
17:35:55 <shachaf> Lenses with nil setters are evil.
17:35:55 <c_wraith> rwbarton: well.  It's a data structure that allows a bunch of functions to use it.
17:36:01 <magn3ts> Axman6, working on it. I got the yourMain written to print the ret value of simulate though :)
17:36:08 <elliott> Sgeo|web: The get part of a lens looks like this: (->).
17:36:15 <elliott> whole -> part
17:36:20 <Axman6> magn3ts: good. now on to the hard part ;)
17:36:21 <shachaf> because get l (put l v r) should be v.
17:36:42 <Sgeo|web> shachaf: I don't think data-lenses uses get and put
17:36:52 <magn3ts> Axman6, I hope not. I think I understand what I need to do. We'll see in an hour, ha.
17:37:00 <elliott> Sgeo|web: Sure it has get and put.
17:37:06 <elliott> Sgeo|web: What use would it be without those?
17:37:07 <Axman6> what's the one edwardk wrote again? it has .^ and .= or something i think
17:37:12 <elliott> Axman6: data-lens
17:37:16 <shachaf> Sgeo|web: Whatever it uses.
17:37:21 <shachaf> getL and setL?
17:37:25 <elliott> Yes.
17:40:30 <magn3ts> when comparing two side by side elements in a list, is it necessary the best strategy to do an offset zipWith to do some analysis of two elements?
17:41:02 <shachaf> magn3ts: That depends on the context.
17:41:06 <shachaf> That's often a good strategy.
17:42:35 <magn3ts> Hm, so conceptually this problem makes sense to print in line, though I understand that's a bad practice. My input list may only have two elements but the output could have like 8 :S
17:45:58 <mm_freak> the (| |) syntax in arrow notation can get really ugly =/
17:46:02 <Mertis> anyone want to take a quick look at where im getting a type error. i know the line, just dont know why
17:46:20 <Mertis> http://snipt.org/vmmo7
17:46:22 <shachaf> Mertis: We can't look unless you post the code somewhere. :-)
17:46:31 <Mertis> already up
17:46:37 <Cale> (x head(xs))
17:46:38 <shachaf> Mertis: Are you the same person as magn3ts?
17:46:38 <mm_freak> still haven't found the best way to lay out code between (| |)
17:46:41 <Cale> looks wrong
17:46:41 <shachaf> Or just in the same class?
17:46:47 <Mertis> nope
17:47:04 <Mertis> im in the same class as isthan
17:47:07 <Cale> in fact, there are several things which look wrong about that line
17:47:09 <Mertis> i dont know who magn3ts is
17:47:21 <shachaf> Mertis: Function application in Haskell doesn't use parentheses.
17:47:22 <Cale> x (head xs) means "apply the function x to the value (head xs)
17:47:26 <Cale> "
17:47:32 <shachaf> To apply f to x, you just say "f x".
17:47:38 <Cale> But here, x is a list of Floats
17:47:45 <Cale> So that's not right
17:47:50 <shachaf> "f (x y)" means "f applied to the value of (x applied to y)".
17:47:56 <magn3ts> shachaf, Aw, :{ come on man :[
17:48:04 <shachaf> magn3ts: Huh?
17:48:29 <shachaf> People change nick in IRC all the time; both nicks started with 'm'.
17:48:43 <magn3ts> And yes, we are in the same class.
17:48:45 <magn3ts> Hi Mertis.
17:48:53 <Mertis> hi
17:49:08 <int80_h> any yesod people here?
17:49:22 <JoeyA> Does cabal install not support upgrading packages recursively?
17:49:40 <Axman6> no :\
17:50:03 <Mertis> ok
17:50:12 <int80_h> check out cab, it might
17:50:24 <Mertis> i changed some things but still something similar, im missing somwhere where im calling something incorrectly
17:50:45 <Mertis> http://snipt.org/vmpl6
17:51:04 <Cale> you're now applying calcDistance to three parameters
17:51:08 <Cale> x, head, and xs
17:51:25 <Cale> and you're applying calcTime to three parameters as well
17:51:37 <Cale> (calcDistance ...), last, and x
17:51:38 <XexonixXexillion> try calcDistance x (head xs)
17:51:47 <Mertis> so this instead?
17:51:47 <Mertis> createTimeList (x:xs) = calcTime (calcDistance x (head xs)) last(x):createTimeList(xs)
17:52:29 <shachaf> Mertis: There's never a reason to write "f(x)" ever.
17:52:32 <shachaf> Use "(f x)".
17:52:58 <Mertis> ha
17:52:58 <Mertis> wow
17:52:59 <shachaf> In this case, you probably want something along the lines of calcTime (calcDistance x (head xs)) (last x : createTimeList xs)
17:53:01 <Mertis> didnt know that
17:53:22 <Cale> well, it's not clear
17:53:47 <shachaf> Yes, actually, I have no idea what you want.
17:54:01 <shachaf> Just move parentheses around randomly until the type checker stops complaining. :-)
17:54:05 <shachaf> (This approach is not recommended.)
17:54:06 <Cale> you may want calcTime (calcDistance x (head xs)) (last x) : createTimeList xs
17:54:29 <shachaf> For instance.
17:54:29 <Sgeo|web> Are there pointed expressions that CANNOT be turned into pointfree expressions?
17:54:39 <shachaf> Sgeo|web: Things that involve pattern-matching.
17:54:39 <Sgeo|web> CANNOT, rather than should not
17:54:47 <XexonixXexillion> no
17:54:48 <Sgeo|web> Ooh, true
17:54:50 <shachaf> As far as just functions go, no.
17:54:59 <Sgeo|web> Ah, ok
17:55:01 <shachaf> @google combinatory logic
17:55:02 <lambdabot> http://en.wikipedia.org/wiki/Combinatory_logic
17:55:02 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
17:55:13 <XexonixXexillion> SK calculus is best calculus
17:55:15 <shachaf> You can make any function in the untyped lambda calculus from S and K.
17:55:55 <Sgeo|web> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z = t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
17:55:55 <lambdabot> (line 1, column 54):
17:55:55 <lambdabot> unexpected "="
17:55:56 <lambdabot> expecting pattern or "->"
17:56:04 <Sgeo|web> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
17:56:07 <lambdabot> (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .)
17:56:08 <lambdabot> .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((
17:56:08 <lambdabot> (((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((
17:56:08 <lambdabot> ((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .)
17:56:08 <lambdabot> .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
17:56:09 <lambdabot> [65 @more lines]
17:56:11 <incluye> WHY
17:56:11 <lambdabot> optimization suspended, use @pl-resume to continue.
17:56:16 <elliott> Sgeo|web: thanks
17:56:21 <incluye> I needed that
17:56:38 <shachaf> @pl (\x -> x x) (\x -> x x)
17:56:41 <lambdabot> ap id id (ap id id)
17:56:41 <lambdabot> optimization suspended, use @pl-resume to continue.
17:56:58 <Sgeo|web> elliott: what?
17:57:03 <elliott> Sgeo|web: for the flood
17:57:15 <elliott> was a good time for floodin' :p
17:57:16 <shachaf> Hmm, is @pl's optimizer Turing-complete?
17:57:28 <shachaf> Sgeo|web: Thanks to you, hard drive prices have gone up again.
17:57:36 <Sgeo|web> I am certain that my function is useful for something
17:58:09 <Sgeo|web> :t \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g
17:58:10 <lambdabot>     Occurs check: cannot construct the infinite type:
17:58:10 <lambdabot>       t
17:58:10 <lambdabot>       =
17:58:16 <Sgeo|web> Aww
17:58:24 <Sgeo|web> Then how did the pl thing operate?
17:58:35 <shachaf> pl's language is untyped.
17:58:48 <shachaf> Just because something doesn't type-check doesn't mean it's not valid, though.
17:58:50 <JoeyA> :t \a b c d e f g h i j k l m n o p q r s t u v w x y z -> t h e q u i c k b r o w n f o x j u m p e d o v e r t h e l a z y d o g
17:58:51 <lambdabot>     Occurs check: cannot construct the infinite type:
17:58:51 <lambdabot>       t
17:58:51 <lambdabot>       =
17:58:59 <rwbarton> [50 @more lines
17:59:01 <rwbarton> ]
17:59:47 <rwbarton> actually, it's more like 80
18:00:05 <Sgeo|web> JoeyA: you're aware of the difference between jumps and jumped?
18:00:29 <JoeyA> Sgeo|web: Did that on purpose
18:00:35 <Sgeo|web> Ah, ok
18:00:40 <JoeyA> oh
18:00:44 <JoeyA> I guess that loses the s
18:00:49 <Sgeo|web> Yeah
18:01:16 <rwbarton> That's probably why it didn't typecheck.
18:01:32 <rwbarton> Wait, does Sgeo|web count as a newbie?
18:01:48 <shachaf> rwbarton: For what purpose?
18:01:52 <Sgeo|web> Inexperienced but reads a lot, what does that count as?
18:01:53 <rwbarton> shachaf: Trolling.
18:02:04 * hackagebot scalable-server 0.2.0 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.2.0 (JamieTurner)
18:02:11 <shachaf> I think the rule of thumb is "don't troll anybody".
18:02:20 <elliott> That's a rubbish rule of thumb. Who do you troll then?
18:02:42 * Sgeo|web would like to see someone successfully troll Cale. Or better yet, elliott
18:02:44 <shachaf> The trick is that some people won't be able to distinguish your mumbo-jumbo jokes from all the rest of the mumbo-jumbo that goes on in this channel.
18:02:46 <XexonixXexillion> Trolling is important
18:03:03 <XexonixXexillion> teach people to call their main loop in a server program 'alone'
18:03:11 <JoeyA> Strong typing is hurting my wrists.  Has anyone else had this problem?
18:03:20 <XexonixXexillion> so they can write 'forever alone'
18:04:13 <shachaf> JoeyA: Start playing the piano.
18:05:18 <JoeyA> shachaf: Nice response
18:05:56 <Sgeo|web> askDoctor :: String -> IO String
18:07:14 <stepkut> M-x doctor
18:08:13 <MostAwesomeDude> map ooh [eee, ah ah]
18:09:48 <stepkut> is this valid?, ah ah, or is than an infinite type?
18:10:11 <stepkut> no it's fine
18:10:24 <stepkut> > id id
18:10:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
18:10:25 <lambdabot>    arising from a use of `...
18:11:04 <shachaf> > 1 1
18:11:05 <lambdabot>   1
18:11:12 <hpaste> “John Watson” pasted “Map reference error” at http://hpaste.org/53768
18:11:44 <john_r_watson> Can anyone help my Data.Map linking errors?
18:12:00 <shachaf> john_r_watson: What version of GHC is that?
18:12:05 <john_r_watson> I'm running GHC version 6.12.3 if that matters
18:12:05 <shachaf> Maybe use ghc --make?
18:13:22 <john_r_watson> shachaf: facepalm wow - I never even saw that when I ran ghc --help -eyes just passed it everytime
18:13:26 <john_r_watson> shachaf++
18:13:36 <john_r_watson> shachaf: that was it btw
18:13:38 <shachaf> john_r_watson: I believe that in GHC 7 it's no longer necessary. :-)
18:13:41 <john_r_watson> shachaf: thanks
18:14:32 <Sgeo|web> Wait what, 1 1?
18:14:39 <Sgeo|web> Oh right, Nums are functins
18:14:41 <Sgeo|web> > 2 1
18:14:41 <lambdabot>   2
18:14:48 <shachaf> Sgeo|web: No, functions are Nums.
18:14:59 <Sgeo|web> Constants are Nums which can be functions
18:15:23 <shachaf> Constants are any Num at all, which includes functions, yes.
18:15:31 <Sgeo|web> > 1 2 3 4 5 -- 1?
18:15:31 <lambdabot>   1
18:16:08 <shachaf> 1 is a constant function which returns 1.
18:16:15 <Mertis> ok getting closer, getting an indentation error at the first line of the createCumulativeTime fxn.   http://snipt.org/vnlh2
18:16:57 <shachaf> Mertis: That's because you're not closing your parenthesis on the previous line.
18:17:14 <Mertis> lulz im retarded
18:17:16 <shachaf> (You should @paste actual errors, not just code, when asking about an error.)
18:22:41 <magn3ts> I think in trying to make this part of the assignment easier, they've made it more confusing and ambiguous.
18:23:06 <magn3ts> If you ignore altitude in speed/time calculations, then you can't tell when alt changes occur relative to a lat/long change.
18:26:32 <Sgeo|web> Are view patterns popular?
18:26:41 <Mertis> hmm i dont seem to be getting any output :(
18:26:59 <Cale> Mertis: You should be aware that at least if the code magn3ts posted containing partFourOutput is really what they gave you guys, partFourOutput doesn't actually do anything with the thing it's given
18:27:34 <Cale> Mertis: you're basically writing dead code, because partFourOutput ignores its parameter
18:27:48 <shachaf> Cale: Well, no, because you're writing an IO action.
18:27:59 <magn3ts> Cale, I added the print to the yourMain and it was okay.
18:27:59 <shachaf> Also, I have a vague feeling that there was amisunderstanding somewhere along the way.
18:28:16 <Mertis> i didnt post the whole code to keep it clean but one sec
18:28:16 <magn3ts> Mertis, the TA didn't put a print in Part4.
18:28:18 <Cale> Yeah, if you change 'yourMain' you'll be fine
18:28:33 <Mertis> http://snipt.org/vnlm5
18:28:34 <shachaf> > take 4 "yourMain"
18:28:34 <lambdabot>   "your"
18:28:59 <magn3ts> Honestly, I'm not even just on the Haskell of part4, there is trig and they try to have you ignore a dimension when ordering events in all three dimensions.
18:29:05 <magn3ts> s/just/stuck/
18:29:15 <Mertis> i noticed that magn3ts
18:29:21 <Mertis> you are instructed to ignore altitude
18:29:42 <Mertis> but then you need it to calculate the waypoint of when you cross a significant line
18:29:50 <Mertis> breaks when crossing altitude lone
18:29:57 <magn3ts> so are you ignoring the "ignore altitude" specification then?
18:30:12 <Mertis> i dont know yet
18:30:15 <Mertis> ot there yet
18:30:32 <Mertis> ok
18:30:44 <magn3ts> *sigh* This TA is one of my least favorite. The first assignment was like this too. The test cases for part4 don't even have "Simulation Begin" in them.
18:30:45 <Mertis> the altitude isnt supposed to be a factor when calculating the distance between two points
18:30:53 <Mertis> which in turn effects the time it takes between each point
18:30:55 <Mertis> that is fine and easy
18:31:12 <Mertis> but when we need the waypoint for when it crosses an altitude barrier, we have to take it into account
18:31:50 <Sgeo|web> One function for what you need that ignores altitude, and one function that doesn't?
18:31:53 <magn3ts> Mertis, but your time for those two events will be the same, even though, in reality they don't occur at the same time, so how will your order them?
18:32:05 <magn3ts> Sgeo|web, ;)
18:32:13 <Sgeo|web> Then again, I'm not following the assignment that closely
18:32:37 <Mertis> not sure yet
18:33:20 <Mertis> so you are saying, between two points, if they cross both and altitude, and a longitude barrier, what order will you put them in?
18:33:40 <magn3ts> effectively.
18:33:41 <Mertis> im going to go ahead and assume that only one barrier is going to be broken between waypoints
18:34:11 <magn3ts> That's an invalid assumption, see test case #2.
18:34:35 <Mertis> yea
18:34:36 <Mertis> it is
18:34:37 <Mertis> i see it
18:34:42 <Mertis> hmm
18:34:57 <Mertis> well
18:35:02 <Mertis> that sucks a bag o dicks
18:36:51 <Sceptrix> Is there a simple way to remove duplicate lists in a list of lists?
18:37:05 <Sgeo|web> :t nub
18:37:05 <lambdabot> forall a. (Eq a) => [a] -> [a]
18:37:07 <tromp> :t nub
18:37:08 <lambdabot> forall a. (Eq a) => [a] -> [a]
18:37:09 <shachaf> That's an ambiguous question.
18:37:34 <shachaf> An example is worth four dozen words.
18:38:00 <Sceptrix> For example, in [[1,2,3],[4,5,6],[1,2,3]] remove the second [1,2,3]
18:38:22 <shachaf> Oh. So you just mean remove duplicates in a list of comparable things, which in this case happen to be lists.
18:38:30 <Axman6> > nub [[1,2,3],[4,5,6],[1,2,3]]
18:38:31 <lambdabot>   [[1,2,3],[4,5,6]]
18:38:33 <shachaf> Rather than, say, removing individual elements in the sublists.
18:38:34 <Sceptrix> Yes
18:38:48 <magn3ts> basically, the time stamps will be wrong.
18:38:52 <magn3ts> Mertis ^.
18:39:05 <magn3ts> You have to stop thinking that the time stamps are accurate and try to not use time to do the ordering.
18:39:09 <magn3ts> (I think)
18:39:15 <shachaf> Keep in mind that nub is an O(n^2) thing, which is often less efficient than it needs to be.
18:40:16 <Sgeo|web> Sceptrix: A list of lists is just a list of values. If those values are comparable, you can, inefficiently, remove duplicates. If it is a list of lists, then the lists inside the list might be comparable, if the data type inside is comparable.
18:40:23 <Sgeo|web> I shouldn't be using the word comparable here
18:40:37 <Daegalus> can anyone help me with the errors I am getting: http://hpaste.org/53769 they are unimformative to me and I can't tell whats wrong.
18:40:43 <Sceptrix> Well my issue is that using nub on [[1,2,3],[4,5,6],[1,2,0]] removes [1,2,0]
18:40:50 <Sceptrix> At least I think it does, testing again.
18:41:02 <shachaf> Sceptrix: No, it just compares the elements of the outer lists, as opaque things.
18:41:39 <Sgeo|web> > nub [[1,2,3], [4,5,6], [1,2,0]]
18:41:39 <lambdabot>   [[1,2,3],[4,5,6],[1,2,0]]
18:41:46 <Sgeo|web> Sceptrix: ^
18:42:16 <Sgeo|web> Note that this will not work if the lists are infinite
18:42:24 <shachaf> Well, it'll work.
18:42:38 <rwbarton> Daegalus: looks like it might be an error in whatever came before getType
18:42:42 <rwbarton> can you paste the whole file
18:42:51 <shachaf> > map (take 10) $ nub [[1..], [2..], [3..]]
18:42:51 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12]]
18:43:12 <Sgeo|web> > map (take 10) $ nub [[1..], [2..], [1..]]
18:43:16 <lambdabot>   mueval-core: Time limit exceeded
18:43:22 <shachaf> Well, sure.
18:43:29 <shachaf> It worked fine, and the answer was _|_.
18:43:32 <Sceptrix> Okay here's a really noob question: How do I import the nub module to use in ghci?
18:43:34 <Daegalus> rwbarton: I can, but its probalby riddled with errors, Im currently going through and debugging my drycode. but I can still post it. Its messy, and probably really bad. FYI this is a homework assignment.
18:43:39 <shachaf> Actually, no, the answer shouldn't be _|_.
18:43:53 <Axman6> Sceptrix: import Data.List
18:44:02 <Sgeo|web> @hoogle nub
18:44:08 <shachaf> lambdabot is just being annoying.
18:44:25 <rwbarton> Daegalus: well, basically it looks like you maybe forgot a close parenthesis or something before getType
18:44:31 <Daegalus> rwbarton: http://hpaste.org/53770 there is the whole program
18:44:34 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
18:44:34 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
18:45:19 <rwbarton> yeah the error is on the previous line of code
18:45:44 <Daegalus> rwbarton: you mean the match statement?
18:45:45 <Sceptrix> Trickier question - Let's say I want it to ignore the last element of the lists when comparing.
18:45:50 <rwbarton> Yeah
18:46:02 <Sgeo|web> Daegalus: You need an else
18:46:03 <Sceptrix> Use forall?
18:46:10 <shachaf> Sceptrix: (compare `on` safeInit), approximately.
18:46:20 <Daegalus> Sgeo|web: OH, wow bonehead mistake, thanks
18:46:31 <Sgeo|web> Daegalus: yw
18:46:51 <Axman6> > nubBy ((==) `on` init) [[1,2,3],[4,5,6],[1,2,0]]
18:46:55 <lambdabot>   [[1,2,3],[4,5,6]]
18:47:13 <shachaf> > nubBy ((==) `on` init) [[1,2,3],[4,5,6],[]]
18:47:14 <lambdabot>   [[1,2,3],[4,5,6]*Exception: Prelude.init: empty list
18:47:52 <Axman6> > nubBy ((==) `on` (reverse . drop 1 . reverse)) [[1,2,3],[4,5,6],[1,2,0],[],[1]]
18:47:55 <lambdabot>   mueval-core: Time limit exceeded
18:47:57 <Axman6> >_>
18:48:01 <Axman6> wut?
18:48:07 <elliott> > nubBy ((==) `on` (reverse . drop 1 . reverse)) [[1,2,3],[4,5,6],[1,2,0],[],[1]]
18:48:08 <shachaf> Axman6: Didn't you hear how reverse is slow?
18:48:10 <lambdabot>   [[1,2,3],[4,5,6],[]]
18:48:14 <elliott> lambdabot gives you about 0 seconds.
18:48:26 <shachaf> Anyway, there's a bug there.
18:48:38 <shachaf> Which is why you need safeInit or similar.
18:48:42 <Sgeo|web> elliott: I don't see what you changed
18:49:15 <Cale> Sgeo|web: nothing
18:49:19 <Cale> He just tried it again
18:49:25 <shachaf> > nubBy ((==) `on` (reverse . drop 1 . (undefined:) . reverse)) [[1,2,3],[4,5,6],[1,2,0],[],[1]]
18:49:26 <lambdabot>   [[1,2,3],[4,5,6],[1,2,0],[],[1]]
18:49:33 <shachaf> undefined++
18:49:42 <shachaf> Wait.
18:49:45 <shachaf> That didn't work...
18:49:49 <Cale> Sometimes if something else runs on the server that lambdabot is running on, it can take a little longer and cause the thing to time out
18:49:50 * shachaf feels silly.
18:50:10 <Axman6> why would you need that?
18:50:14 <Axman6> drop is safe...
18:50:22 <Sgeo|web> shachaf: I'm pretty sure you're allowed to troll yourself
18:50:28 <shachaf> Axman6: Because your function is eliminating the...
18:50:34 <Sgeo|web> Axman6: The undefined: counteracts the drop 1
18:50:34 <shachaf> You know, maybe I'll just stop talking now.
18:50:39 <Sgeo|web> Meaning there's no point to it
18:50:40 <Sceptrix> Okay thanks, nubBy looks like the right way to go.
18:50:48 * shachaf achievement unlocked
18:51:08 <shachaf> Sceptrix: Note that nubBy can be inefficient, as I mentioned before. :-)
18:52:03 <magn3ts> Can I insert to the head of a list while traversing it without messing up my traversal?
18:52:03 <elliott> I wonder if the Ord-based nubs are in a library yet.
18:52:47 <dcolish> does anyone know of a service like heroku or app engine for haskell frameworks?
18:52:50 <shachaf> magn3ts: Are you pretending mutation exists again?
18:53:00 <shachaf> It doesn't. The world is pure and beautiful.
18:53:09 <Daegalus> anyone able to tell me why I am having a scoping issue with line 14, 27, 40, 51, 64, etc (anything trying to create a Result) on this code: http://hpaste.org/53770 -- I get these errors: a5.hs:14:31: Not in scope: data constructor `Result'
18:53:09 <Daegalus>  ---- ERROR file:.\a5.hs:14 - Undefined data constructor "Result"
18:53:09 <shachaf> magn3ts: (You can't modify a list, you can only construct a new list.)
18:53:32 <Cale> > map snd . nubBy ((==) `on` fst) . map (\x -> (init x, x)) $ [[1,2,3],[4,5,6],[1,2,0]]
18:53:33 <lambdabot>   [[1,2,3],[4,5,6]]
18:53:34 <elliott> Daegalus: You're not using Hugs, are you?
18:53:37 <elliott> That error looks like a Hugs error.
18:53:43 <shachaf> Daegalus: Result is a type, not a value.
18:53:53 <shachaf> data Result = Either String [Token] -- This looks confused.
18:53:54 <elliott> Also, import Data.Char, not Char.
18:53:56 <Daegalus> elliott: I have to use Hugs, its what our professor uses to grade.
18:54:03 <elliott> Daegalus: My condolences. :(
18:54:17 <shachaf> @Hugs all around!
18:54:17 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:54:26 <Daegalus> Its why I provide a GHC erorr too, incase people aren't familiar with hugs
18:54:26 <elliott> :-D
18:54:27 <elliott> Perfect
18:54:33 <Cale> data Result = Either String [Token]
18:54:37 <Cale> ^^ this is problematic :)
18:54:51 <Daegalus> Cale: it is the type he has given us.
18:54:51 <shachaf> Cale: It's not *technically* an error all on its own.
18:54:59 <shachaf> Daegalus: Are you sure he didn't use "type"?
18:55:00 <edwardk> Daegalus: it is interesting to hear from a real life caveman. Do mammoths still roam your campus? =)
18:55:18 <Daegalus> http://cs.sjsu.edu/faculty/smithj/classes/152/a5.html <--- assignment if you want to see what he wants
18:55:40 <shachaf> Daegalus: You should come to bahaskell to complain about your class.
18:55:41 <Daegalus> edwardk: Yes, we have armor plating for them when we have to fend off the evil Java bugs.
18:55:44 <magn3ts> We apparently used hugs last year >+>
18:55:52 <Cale> You didn't give a name to the data constructor for the type, but your code assumes there's a data constructor called Result
18:55:55 <edwardk> Daegalus: understandable, java bugs can be massive
18:56:07 <shachaf> Daegalus: He doesn't say "data Result = Either String [Token]" anywhere on that page.
18:56:23 <Daegalus> shachaf: Your recognizers are to be of type Result -> Result where Result is defined as Either String [Token].
18:56:24 <shachaf> Daegalus: He says "Result is defined as Either String [Token]".
18:56:39 <shachaf> But that's not how data works.
18:56:45 <edwardk> copumpkin: _finally_ have join written, now i need to fix up versioned variable writes
18:56:54 <copumpkin> edwardk: yay
18:56:56 <shachaf> You might use something like "data Result = Result (Either String [Token])".
18:56:59 <shachaf> edwardk: What join is this?
18:57:02 <Cale> Daegalus: data Result = Either String [Token] defines the type Result as consisting of values Either x y where x :: String and y :: [Token]
18:57:08 <copumpkin> shachaf: the joiniest of joins
18:57:16 <edwardk> https://github.com/ekmett/revisions/blob/master/Control/Concurrent/Revision.hs
18:57:18 <shachaf> copumpkin: Semilattices, then.
18:57:24 <Cale> Daegalus: That is, it defines a data constructor   Either :: String -> [Token] -> Result
18:57:38 <Cale> This is confusing because there's also a type constructor called Either
18:57:55 <Cale> (which lives in a different namespace in the world of types)
18:58:00 <Daegalus> so any suggestions on how I can rectify this.
18:58:06 <Cale> Two options:
18:58:15 <Cale> data Result = Result (Either String [Token])
18:58:17 <Cale> or
18:58:25 <Cale> type Result = Either String [Token]
18:58:34 <shachaf> Oh. Or newtype Result = Result (Either String [Token])
18:58:38 <shachaf> s/ ....//
18:58:42 * shachaf sighs.
18:58:48 <shachaf> Nothing I type is coming out right today.
18:58:55 <Cale> yeah, that's also an option, but it's only marginally different from the data one
18:59:02 <edwardk> shachaf: parallel version controlled variables with deterministic merge strategies as a monad
18:59:05 <Axman6> define types ALL the ways! \o|
18:59:08 <shachaf> Or #define Result Either String [Token]
18:59:14 <Cale> rofl
18:59:24 <magn3ts> If I'm defining a recurv function that takes a list as (x:xs), will xs==null on the last elem or something?
18:59:30 <shachaf> edwardk: Ah, neat.
18:59:46 <Cale> magn3ts: null xs will be True, or xs == [] ;)
18:59:50 <Daegalus> Cale: Ok, that helped, it has moved onto other errors. Need to figure out why its not scoping "Either" now on line 14.
19:00:07 <Cale> Because Either isn't a value
19:00:11 <elliott> shachaf: cpp? Real Haskell experts use m4.
19:00:11 <edwardk> shachaf: http://research.microsoft.com/pubs/150180/oopsla065-burckhardt.pdf is a really good motivation for the approach
19:00:18 <Cale> It's a type constructor, and only lives on the right hand side of ::
19:00:20 <magn3ts> oh silly haskell.
19:00:26 * magn3ts probably a death warrant in this room :P
19:00:35 <edwardk> elliott: i ran an entire business off of websites served using m4. never again ;)
19:00:49 <elliott> edwardk: But... why....
19:01:04 <edwardk> elliott: because i was young, dumb, and hadn't seen perl yet
19:01:11 <shachaf> edwardk: Which business was that?
19:01:20 <Daegalus> Btw, I have said this before when asking for help in this channel, our professor is horrible, and skips a ton of information in lectures and slides, and doesn't bother filling us in on minor things. So if you see me making very noobish mistakes, you will know why
19:01:29 <elliott> edwardk: I dunno, between m4 and Perl...
19:01:45 <elliott> Daegalus: We've had a lot of terrible teachers today.
19:01:47 <edwardk> 'otakuland.com' back in the ncsa mosaic -> early netscape era
19:01:48 <elliott> (2 is a lot.)
19:01:50 <Cale> Daegalus: You might want to try reading "Learn You A Haskell"
19:01:59 <Cale> http://learnyouahaskell.com/
19:02:02 <shachaf> Daegalus: If your professor is horrible, you can just study Haskell on your own like everyone else. :-)
19:02:14 <shachaf> If it was good enough for my great-grandfather, etc.
19:02:17 <magn3ts> oh man this is so damn cool :D this functions I'm writing
19:02:25 <Cale> It's pretty hard to learn/teach a programming language in lecture format
19:02:45 <Cale> (it's possible, but probably more boring than other methods even when done right)
19:02:58 <edwardk> elliott: if it wasn't for perl i'd never have found haskell
19:03:03 <edwardk> elliott: so take that for what its worth
19:03:16 <edwardk> hackagebot would be far less stress tested at least ;)
19:03:20 <shachaf> edwardk: s/haskell/haskell the way i did/
19:03:39 <edwardk> shachaf: dunno
19:03:56 <shachaf> edwardk: Exactly.
19:04:15 <smns> I've been working on these 270 lines of Haskell, and for three days all I did was verify that things typecheck before I move on. and in the end, it works. no logical bugs I've found so far.
19:04:18 <shachaf> Of course, if it wasn't for Perl, the evil mangler would never have existed.
19:04:36 <Jafet> shachaf: it would have been written in m4
19:04:38 <shachaf> So I guess Perl has its place.
19:04:44 <Cale> smns: isn't it nice?
19:04:45 <edwardk> Jafet: or awk
19:04:48 <shachaf> Jafet: It wouldn't be the same thing.
19:04:49 <smns> with other languages, if it just works after three days of coding, I *know* something is wrong.
19:05:08 * shachaf >=>
19:05:14 <Cale> smns: Even when type correct programs do something you didn't want, they often do something useful anyway
19:05:33 <Daegalus> Cale, shachaf: ya I know, I try but I am also busy with other things, I havent had a chance to read through everything on learn You A Haskell (he actually linked us that site first day).
19:05:35 <smns> shachaf, haha. I was looking at the >=> operator earlier and thought to myself, "This is the worst documentation possible (if you can't deduce its meaning from its type alone).
19:05:47 <shachaf> smns: ?
19:05:55 <shachaf> smns: You can deduce its meaning from the type alone.
19:06:08 <shachaf> In fact, there's only one reasonable implementation of its type.
19:06:21 <smns> shachaf, yes you can. but I think Haskell documentation lacks examples.
19:06:27 <shachaf> Well, depends on what you mean by implementation.
19:06:41 <Jafet> "(f >=> g) a: does some abstract stuff with f, g, and a."
19:07:08 <shachaf> Anyway, what does the documentation say? "Kleislli composition"?
19:07:12 <smns> yes :)
19:07:19 * shachaf `fmap`
19:07:21 <dmwit> Somebody ought to formalize what definitions are sensible.
19:07:23 <Cale> The fact that you can deduce the implementations of things from their types usually is what's making the rest of the documentation bad, because people who know what they're doing already wouldn't need more than the type in those cases. ;) (It's not great for beginners though...)
19:07:46 <Jafet> smns: cool. Now you know that a Kleisli composition is (>=>).
19:07:57 <Jafet> (Who says definitions have to be forwards?)
19:07:58 <Cale> heh, so just look up what Kleisli composition is in your favourite textbook on category theory
19:08:01 <smns> dmwit, it was a reasonable definition. I looked up Kleisli composition on Wikipedia and found a bunch of equations.
19:08:07 <elliott> Cale: At least it makes them pick up the art :)
19:08:10 <smns> Jafet, yeah, I suppose I can learn things that way. ;-)
19:08:21 <dmwit> smns: s/definition/implementation/
19:08:24 <smns> Jafet, it's like drunkards learning math through counting beer-bottles. I'll learn it from deducing type expressions.
19:26:18 <Mertis> im trying to pass in a sample input of a list of lists of floats,  i am getting now out put at all and i cant see why http://snipt.org/vokm8
19:26:28 <Mertis> no output*
19:27:20 <zygoloid> Mertis: not even "Simulation Begin" ?
19:28:00 <Mertis> no
19:28:04 <Mertis> im getting simulation begon
19:28:07 <Mertis> and simulation end
19:28:24 <Mertis> but im trying to get back the list im trying to create
19:28:48 <Mertis> the top part of the code is working skeleton code, the problem is in the bottom
19:29:00 <zygoloid> Mertis: partFourOutput just prints out "Simulation Ended"
19:29:29 <elliott> Mertis: Ooh, we had someone with the same problem earlier ;-)
19:29:43 <Mertis> ha
19:29:44 <elliott> shachaf: I forget, was the skeleton code really broken after all?
19:30:54 <zygoloid> you could add some printing to yourMain
19:31:07 <dmwit> The skeleton code is all there, and doesn't look broken. His problem is that he calls a function, but discards its result.
19:31:31 <zygoloid> dmwit: should partFourOutput not do something with 'mission' ?
19:31:33 <shachaf> elliott: What skeleton code?
19:31:44 <Mertis> well i compared some of my other skeleton code i used in other programs, and this one is missing print mission
19:31:46 <shachaf> Oh, that.
19:32:00 <Mertis> i added it
19:32:00 <shachaf> elliott: I don't think we ever figured out exactly what the skeleton code consisted of.
19:32:06 <Mertis> im at least getting back an empty list
19:32:06 <elliott> dmwit: Well, you were apparently meant to make a pure function print...
19:32:09 <magn3ts> Mertis, If you want to be "right" in terms of the assignment, you can print inside yourMain
19:32:09 <Mertis> instead of nothing at all
19:32:13 <dmwit> zygoloid: ...oh, is that part of the skeleton code? I assumed Mertis wrote partFourOutput.
19:32:18 <magn3ts> Mertis, otherwise you can add it to the skeleton code...
19:32:49 <zygoloid> dmwit: i'm not sure, but it's above the 'YOUR CODE SHOULD COME AFTER THIS POINT' line :)
19:33:01 <dmwit> ...good point =)
19:33:23 <Mertis> well either way
19:33:29 <Mertis> its returning an empty list
19:33:32 <Mertis> which is wrong
19:33:34 <dmwit> Mertis: Anyway, you could print something in "yourMain".
19:33:44 <zygoloid> Mertis: for what input?
19:33:57 <Mertis> the input im testing is a list of lists of floats
19:34:03 <Mertis> 3 lists of floats to be exact
19:34:20 <Mertis> the lists of floats are all 4 elements in size
19:34:51 <shachaf> 3 lists of 4 floats each? Is that known at compile-time?
19:34:59 <Mertis> yes
19:35:01 <Mertis> well
19:35:04 <Mertis> not necessarily 3
19:35:06 <byorgey> shachaf: how could it?
19:35:13 <Mertis> its a list of a list of floats
19:35:17 <Mertis> is all that matters
19:35:27 <Mertis> but it will always be lists of 4 elements
19:35:28 <Mertis> the sub lists
19:35:29 <shachaf> byorgey: Well, my question was whether it should actually be lists or maybe tuples or something.
19:35:38 <Mertis> i could be tuples
19:35:44 <Mertis> but
19:35:48 * shachaf has little context.
19:35:50 <Mertis> the inputs are standard
19:35:50 <zygoloid> shachaf: that appears to be part of the skeleton
19:35:57 <byorgey> someone else was in here talking about this earlier, and claimed the data format was given and could not be changed
19:35:57 <shachaf> Ah, good old skeleton.
19:36:00 <shachaf> Mu []
19:36:11 <Mertis> in the form [[a,b,c,d],[x,y,w,z]]
19:36:13 <dmwit> I wonder if the person who wrote this skeleton is really qualified to be teaching Haskell.
19:36:38 <Mertis> well the teacher for this class is quite bright
19:37:24 <magn3ts> yes, it should be tuples.
19:37:31 <magn3ts> Also, I'm quite sure Sebastian didn't write this.
19:37:31 <Mertis> anyways, i compile fine, but at runtime it is giving an empty list
19:37:36 <Mertis> yea it should be tuples
19:37:38 <Mertis> yea
19:37:43 <Mertis> i dont think he did
19:37:48 <dmwit> Mertis: Do you know about ghci?
19:37:58 <Mertis> yea i have it
19:38:09 <dmwit> Mertis: You should test out your "simulate" function (and the others in there!) in ghci.
19:38:16 <Isthan> it breaks in ghci
19:38:16 <shachaf> The person who's teaching your class didn't write your assignments?
19:38:23 <dmwit> Try typing, for example,
19:38:29 <shachaf> Isthan: That's one of the best places for a function to break. :-)
19:38:30 <dmwit> simulate [[0,0,0,0]]
19:38:30 <dmwit> or so
19:38:31 <magn3ts> shachaf, TA's baby!
19:38:35 <dmwit> See if it matches what you expect.
19:38:39 <Mertis> alright
19:38:42 <Isthan> I mean the input doesnt work
19:38:46 <Mertis> who are u magn3t>?
19:38:48 <shachaf> magn3ts: What, really? Isn't writing assignments something that can be done once and then duplicated?
19:38:50 <dmwit> If you don't, test out createTimeList; if that doesn't do what you expect, test calcDistance and calcTime.
19:38:50 <Isthan> it works from command line
19:38:52 <Mertis> u are obviously in my class
19:38:59 <magn3ts> shachaf, no, they change them, or at least this prof does.
19:39:02 <magn3ts> Mertis, or am I
19:39:04 <magn3ts> o_0
19:39:15 <Sgeo|web> If Haskell were to support lenses as a built-in... hmm
19:39:28 <Mertis> ok well you are most likely a student anyways, maybe not in this class
19:39:31 <Mertis> but i might know you
19:39:31 <Mertis> :D
19:39:32 <dmwit> Isthan: What exactly do you mean by "it breaks in ghci"?
19:39:40 <Mertis> ignore his comment i told him
19:39:41 <Mertis> dmwit
19:39:49 <magn3ts> Mertis, my name is Cole. I haven't been to class in two weeks so :S
19:39:58 <shachaf> Prelude> simulate
19:40:03 <dmwit> Isthan: I suspect what you mean is that the "main" function doesn't do getArgs correctly.
19:40:04 <shachaf> *** Exception: it broke
19:40:15 <Isthan> right dmwit
19:40:19 <dmwit> Isthan: If so, there is the ":main" command available to provide main's getArgs correctly.
19:40:20 <Mertis> hmm id recognize you if i saw you
19:40:23 <Mertis> im sure
19:40:27 <dmwit> Isthan: But you should just test the underlying functions instead of calling main.
19:40:37 <magn3ts> Mertis, I probably can't say the same. I'm shit for names.
19:40:39 <dmwit> Isthan: Test pure things, and you don't have to worry about command-line arguments or files. =)
19:40:41 <shachaf> Are you at SJSU? Or was that a different group?
19:41:00 <Sgeo|web> But that doesn't mean you shouldn't test :main too, I'd think
19:41:01 <Isthan> when I load the .hs file in ghci, I cant say call a subfunction by name
19:41:07 <Isthan> it says its out of scope
19:41:13 <Isthan> i'm probably a ghci nub though.
19:41:18 <dmwit> Isthan: Try this: ghci '*foo.hs'
19:41:33 <dmwit> Isthan: Where "foo.hs" is the name of your file, and the quotes and * are not typos.
19:41:47 <Isthan> ok
19:41:48 <dmwit> Isthan: Or, once you're in ghci, try :l *foo
19:42:03 <Isthan> *foo, i'll try that
19:42:03 <Sgeo|web> What's * there?
19:42:04 <dmwit> The * says to interpret the file (rather than using the pre-compiled version, which doesn't expose all the functions).
19:42:19 <Axman6> :o
19:43:16 <Isthan> Ah, thats exactly what I needed dmwit
19:43:24 <dmwit> \o/
19:43:40 <Isthan> now if only this dreaded assignment wasn't such a whore :)
19:43:40 <shachaf> > nub "ghci"
19:43:41 <lambdabot>   "ghci"
19:44:01 <Axman6> Isthan: does it have something to do with simulation?
19:44:18 <Isthan> Axman6: yes, indeed
19:45:33 <magn3ts> I keep using (head xs) in my return value, is there no way to make that a variable or something?
19:46:13 <shachaf> magn3ts: Pattern-match on the list.
19:46:25 <shachaf> magn3ts: "head" is an evil function and you should avoid i if possible.
19:46:30 <magn3ts> :o
19:46:31 <magn3ts> wat!
19:46:41 <magn3ts> Oh shit balls, I meant "first"
19:46:48 <mauke> fst?
19:47:13 <magn3ts> no, I did mean head.
19:47:18 <magn3ts> Why is it evil? o_0
19:47:24 <shachaf> Because it can fail.
19:47:30 <rwbarton> what if the list is empty?
19:47:33 <shachaf> It's not up to our standards as Haskellers.
19:47:37 <shachaf> It's also ugly.
19:47:40 <Isthan> write edge cases that prevent the failure of head though
19:47:40 <magn3ts> I already check to see if it's empty?
19:47:47 <shachaf> magn3ts: Well, don't do that either.
19:47:48 <Isthan> but, perhaps this is a naive approach
19:47:52 <shachaf> Just pattern-match on the list.
19:48:12 <magn3ts> shachaf, okay, but I'm already doing x:xs as my func parameter, I want to handle the base case.
19:48:16 <magn3ts> So I check (null xs) ?
19:48:26 <shachaf> magn3ts: Well, do x:y:xs or something.
19:49:33 <dmwit> magn3ts: What? no.
19:49:43 <shachaf> dmwit++
19:49:43 <dmwit> magn3ts: You have two cases for your function: one for [] and one for (x:xs).
19:51:28 <dmwit> > let f [] = "base case"; f (x:xs) = "recursive case " ++ x ++ f xs in (f [], f ["one element "], f ["i can ", "only count ", "to three "])
19:51:30 <lambdabot>   ("base case","recursive case one element base case","recursive case i can r...
19:51:46 <Sgeo|web> Hmm
19:52:12 <Sgeo|web> lenses assumes in the State monad and gives handy functions for use outside it, and data-lenses does the opposite
19:52:47 <elliott> nobody uses lenses
19:53:21 <elliott> isn't that even the one that doesn't actually provide a type for lenses
19:53:26 <elliott> Sgeo|web: anyway see Data.Lens.{Lazy,Strict}
19:53:28 <elliott> for state monad functions
19:53:32 <elliott> with data-lens
19:53:47 <shachaf> If I was using lenses I would use data-lens.
19:54:02 <shachaf> If I was using lenses and not using data-lens, I would probably use fclabels.
19:54:27 * shachaf notes an ambiguity in previous two lines.
19:54:38 <elliott> fclabels are arrows nowadays. :(
19:54:50 <shachaf> ?
19:55:02 <elliott> fclabels is built on arrows since 2.0.
19:55:15 <shachaf> Is that bad?
19:55:23 * shachaf has not examined fclabels very closely.
19:56:08 <Sgeo|web> Suppose I'm writing a library meant to be used by others. Is it ok to export data-lens lenses?
19:56:20 <dmwit> Sure.
19:56:41 <elliott> shachaf: It just triggers my knee-jerk anti-arrowism. :)
19:57:04 * shachaf hasn't figured out Arrow very thoroughly yet.
19:57:18 <shachaf> elliott: data-lens is a Category. Do you have an objection to that too? :-)
19:57:28 <elliott> Naw, categories are great.
19:57:38 <shachaf> Well, all arrows are categories.
19:57:41 <shachaf> Therefore, all arrows are great.
19:57:47 <elliott> shachaf: But more specifically: fclabels /takes/ arrows as type arguments.
19:57:48 * shachaf defeats elliott with logic.
19:59:01 <shachaf> elliott: fclabels is still on version 1.0.4.
19:59:09 <elliott> Hmm, maybe it's version 1.0 then.
19:59:09 <shachaf> ANyway, yes, I see.
19:59:12 <Sgeo|web> What's the difference between ^. and ^! ?
19:59:28 * Sgeo|web guesses some strictness thingy
19:59:29 <magn3ts> dmwit, alright, trying to understand that, all on one line is a challenge, one sec
19:59:44 <shachaf> Presumably it still works with (->)? :-)
20:00:11 <elliott> I hope so :P
20:00:12 <shachaf> a ^. Lens f = pos (f a)
20:00:12 <shachaf> a ^! Lens f = pos (f $! a)
20:00:14 <elliott> Sgeo|web: Strictness.
20:00:38 <hpaste> dmwit pasted “for magn3ts” at http://hpaste.org/53771
20:00:47 <magn3ts> I think I understand
20:00:59 <shachaf> $! needs to have a prefix form called "strictify" or something.
20:01:13 <magn3ts> well, I understood the other thing you posted at least :S
20:01:36 <Jafet> strictify x = x `seq` x?
20:01:44 <shachaf> Jafet: Right.
20:01:48 <shachaf> Er, no.
20:01:50 <shachaf> $!
20:01:52 <shachaf> @src $!
20:01:52 <lambdabot> f $! x = x `seq` f x
20:01:53 <magn3ts> I need to rework my logic to do it the "right" way though, my logic depends on being on "other" element :S
20:02:05 <dmwit> x `seq` x is a noop
20:02:08 <shachaf> Jafet: It makes a function strict, not a value. join seq === id
20:02:21 <Jafet> strictify f x = f $! x?
20:02:26 <shachaf> Yes.
20:02:36 <shachaf> Hence my choice of words.
20:02:47 <Jafet> It's shorter to type ($!)
20:03:00 <shachaf> I guess.
20:03:01 <Mertis> ok good
20:03:06 <Mertis> got this function working
20:03:15 <Mertis> now, to figure out how to do what i think is the hardest
20:03:42 <Mertis> and that is, creating the outputs for when a special "point" is crossed
20:04:03 <Mertis> major lattitudes, and certain altitudes
20:04:03 <magn3ts> time is fun :)
20:04:13 <Mertis> i have time figured out i think
20:04:20 <Mertis> im not worried about that
20:04:30 <shachaf> Warning: Nuclear missile launched.
20:04:32 <magn3ts> I'm still trying to figure out the best way to pass it as I recurse.
20:05:01 <shachaf> Arguments are a popular choice for passing things as you recurse.
20:05:02 <Mertis> im calculating the time seperate from the rest
20:05:09 <magn3ts> shachaf, haha
20:05:16 <magn3ts> Mertis, oh :o
20:06:04 <shachaf> elliott: fclabels looks way too fancy now.
20:06:07 <Mertis> i have the time part working actually,  well it will work when i find all the coordinates of the waypoints needed for the outputs
20:06:25 <magn3ts> Mertis, but those are timeoffsets, you have to print abs times
20:06:27 <elliott> shachaf: They saw they were losing market share to data-lens and reacted in exactly the wrong way! (Note: Probably false theory.)
20:06:37 <Mertis> i know i do
20:06:41 <Mertis> i have that figured out
20:06:47 <magn3ts> that's the part I'm goofed on a bit
20:07:03 <magn3ts> Mertis you never did tell me who you were
20:07:07 <shachaf> elliott: Don't worry, I mentally add "(Note: Probably false theory.)" to everything you say automatically.
20:07:12 <Mertis> my name is Derek
20:07:27 <elliott> shachaf: This statement is true.
20:07:53 <shachaf> elliott: In that particular case I just added it twice, the second inside the parentheses of the first.
20:07:56 <dmwit> Probabilistic paradox!
20:08:18 <dmwit> This sentence is probably confusing.
20:08:48 <Mertis> anyways, i first calculate the time it takes between each waypoint
20:08:52 <Mertis> and then i use that information
20:09:02 <Mertis> to create a absolute time list
20:09:20 <Mertis> which i will append to another list
20:09:25 <Mertis> to create the final output
20:09:35 <vaibhav> hello
20:09:38 <shachaf> Lists everywhere.
20:09:45 <shachaf> vaibhav: Good afternoon.
20:10:02 <vaibhav> morning on my side
20:10:15 <vaibhav> i am new to Haskell
20:10:17 <shachaf> Evening on mine, so I averaged.
20:10:28 <vaibhav> looks like a great language
20:10:59 <shachaf> As the unbiased community of #haskell will tell you, Haskell is undisputedly the best language.
20:11:51 <vaibhav> got ot know from a friend plz advice me some books
20:12:08 <dmwit> ?where rwh
20:12:08 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:12:09 <shachaf> @where lyah
20:12:09 <lambdabot> http://www.learnyouahaskell.com/
20:12:10 <dmwit> ?where lyah
20:12:10 <lambdabot> http://www.learnyouahaskell.com/
20:12:25 <dmwit> ?where soe
20:12:26 <lambdabot> http://haskell.org/soe/
20:12:36 <shachaf> @where books
20:12:36 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`wikibook',`non-haskell-books'
20:12:36 <vaibhav> thanks
20:12:54 <dmwit> ?wiki books
20:12:54 <lambdabot> http://www.haskell.org/haskellwiki/books
20:14:21 <dmwit> That wiki page is quite thorough, actually.
20:14:27 <shachaf> Is haskell.org/soe down?
20:14:28 <magn3ts> dmwit, I'm iterating on my work here: I'm a bit at a mental loss (dumb recursion) on my base case still :S http://hpaste.org/53772
20:15:16 <shachaf> magn3ts: More parenthesis, less comma.
20:15:31 <shachaf> Function application in Haskell is "function argument", not "function argument".
20:15:38 <dmwit> magn3ts: Instead of "simInner (x:xs) | null xs = foo", how about "simInner [x] = foo"?
20:16:00 <dmwit> shachaf: wut
20:16:01 <shachaf> As a convention function application with two arguments is "fun arg1 arg2", not "fun (arg1, arg2)".
20:16:04 <Rotaerk> is there a difference between "function argument" and "function argument"?
20:16:09 <shachaf> dmwit: Er.
20:16:28 <shachaf> Function application in Haskell is "function argument", not "function(argument)".
20:17:12 <Rotaerk> technically there's simply no such thing as application with "two arguments"
20:17:21 <magn3ts> dmwit, I like leveraging the x:y:xs though rather than doing head xs so much.
20:17:31 <shachaf> Rotaerk: Sure.
20:18:07 <Rotaerk> it's either application to a 2-tuple, or application to a single expression which returns a function which is then applied to the next expression
20:18:37 <dmwit> magn3ts: I am not advocating using "head xs". Where did I advocate that?
20:18:52 <magn3ts> dmwit, sorry, didn't mean that! that's what I was using before.
20:19:09 <dmwit> (x:y:rest) is a perfectly brilliant pattern, and I strongly suggest using it when you're interested in the first two elements of a list.
20:19:13 <magn3ts> dmwit, also, I may have miunderstood, I'm thinking if I have x:y:xs, I also have to have x:y, [x] both?
20:19:29 <magn3ts> (as cases?)
20:19:43 <dmwit> If you want your function to be total, and one of your patterns is (x:y:xs), you should have [x] and [] patterns as well.
20:19:44 <shachaf> You don't have to have anything.
20:19:51 <dmwit> I'm not sure if that lines up with what you said or not.
20:19:52 <shachaf> But, yes.
20:20:06 <byorgey> magn3ts: you should cover every possibility. there are many ways to do that.
20:20:27 <magn3ts> byorgey, yeah, trying to wrap my head around the various cases at work here :)
20:21:15 <mm_freak> i'm observing a very peculiar phenomenon with GHC
20:21:16 <magn3ts> I guess my real question is, does the case x:y:xs cover [1,2] ?
20:21:22 <XexonixXexillion> yes
20:21:28 <byorgey> (x:y:rest) matches any list with at least two elements
20:21:29 <mm_freak> it seems to get things a bit wrong with CSE
20:21:35 <shachaf> magn3ts: It's a good exercise to figure that out on your own. :-)
20:21:36 <blackdog> magn3ts: [] is a perfectly good list
20:21:40 <byorgey> magn3ts: yes, rest could be the empty list
20:21:41 <dibblego> [1,2] is shorthand for 1:2:[] which obviously matches x:y:xs
20:22:21 <hpaste> “Ertugrul Söylemez” pasted “CSE gone wild” at http://hpaste.org/53775
20:22:23 <magn3ts> shachaf, I was doing it in ghci and am too dumb to declare functions in it!
20:22:25 <magn3ts> haha
20:22:39 <mm_freak> http://hpaste.org/53775 ⇐ i have two counter automata, countFrom 0 and countFrom 0
20:22:43 <mm_freak> this causes a space leak
20:22:46 <magn3ts> byorgey, okay, that's why my question was so dumb to dmwit then probably :P
20:23:03 <mm_freak> when i change one of the counter to countFrom 1 the problem disappears
20:23:10 <mm_freak> the only difference is the starting value for the counter
20:23:21 <byorgey> magn3ts: nope, you haven't asked any dumb questions
20:23:26 <dmwit> agreed
20:23:29 <dmwit> No dumb questions yet.
20:23:31 <mm_freak> is this a CSE bug?
20:24:13 <byorgey> magn3ts: a dumb question would be something like, "can someone write my homework for me plz kthx"
20:24:41 <dmwit> mm_freak: coooool
20:24:49 <byorgey> which you obviously haven't asked
20:24:52 <mm_freak> dmwit: ?
20:24:58 <dmwit> mm_freak: What if you compute one of the zeros?
20:25:05 <dmwit> mm_freak: Like "countFrom (3-3)" or something.
20:25:47 <magn3ts> I like CS and (so far) Haskell too much to do that anyway, (ignoring the obvious academic problems that would create)
20:27:13 <mm_freak> dmwit: doesn't make a difference for simple calculations like 3 - 3
20:27:23 <mm_freak> it does make a difference for less trivial ones like mod 30 15
20:27:46 <mm_freak> this is really weird…  GHC isn't supposed to do that much CSE
20:28:17 <magn3ts> what does CSE stand for here?
20:28:26 <mm_freak> magn3ts: common subexpression elimination
20:28:50 <mm_freak> haskell is the one language, where implicit CSE can be harmful
20:29:02 <magn3ts> I'll take your word ;)
20:29:05 <dmwit> Yeah, I thought CSE was explicitly not done in GHC.
20:29:26 <mm_freak> there was a flag to explicitly disable CSE…  i'll try that out
20:29:33 <shachaf> dmwit: What does -fcse do, then?
20:29:45 <dmwit> Turn on CSE?
20:30:10 <dmwit> s/not done/not done by default/
20:30:11 <dmwit> Sorry.
20:30:13 <shachaf> Ah.
20:30:16 <dmwit> I'm bad at word.
20:30:17 <shachaf> But it is done with -O.
20:30:25 <mm_freak> by explicitly disabling CSE (-fno-cse) the problem disappears
20:30:26 * shachaf good with winword.exe.
20:30:41 <dmwit> Okay. I didn't know that -- I thought it was left out no matter what -O you passed.
20:31:22 <dmwit> I'm actually somewhat surprised that GHC will optimize 3-3 to 0.
20:31:38 <dmwit> Oh, maybe these 3's are type-restricted.
20:31:44 <mm_freak> as long as it can infer 3-3 :: Int, it does
20:31:45 <elliott> yeah
20:31:47 <dmwit> To like Int or something. Where that's okay.
20:31:52 <dmwit> yeah
20:32:19 <magn3ts> I'm apparently using the wrong terminology to google this, how can I check if Num a is in a range of Float x, Float y?
20:32:40 <dmwit> There's a couple things you could mean.
20:32:55 <dmwit> One is, "If I know x :: Float, is x :: Num a => a?"
20:32:57 <mauke> magn3ts: huh?
20:33:13 <magn3ts> Um, let's pretend I didn't ask that question and never, ever speak of it again.
20:33:17 <dmwit> Another is, "If I know x :: Float, can I pass x to a function expecting a Num, as in f :: Num a => a -> b?"
20:33:35 <magn3ts> No, no, you're giving me far too much credit. I fear mauke may understand.
20:33:39 <mm_freak> magn3ts: generally when comparing values, you first have to match their types
20:33:51 <mauke> dmwit: you're interpreting the question in a way that admits a sensible answer
20:33:56 <Mertis> so magnets
20:33:58 <dmwit> trying to, yeah
20:33:58 <Mertis> any more luck
20:34:01 <Mertis> im stuck
20:34:16 <magn3ts> Mertis, ? I am implementing what I am praying will work after lots of debugging.
20:34:41 <Mertis> im not sure how to go about calculating the lat and long of the significant point occurences
20:34:49 <mm_freak> does anyone know a way to disable CSE explicitly for certain variables?  perhaps a pragma?
20:35:05 <magn3ts> Mertis, think percentages
20:35:24 <elliott> dmwit: magn3ts is trying to compare numbers
20:35:26 <magn3ts> also, that's the last thing I saved to implement :)
20:35:26 <elliott> i believe
20:35:37 <dmwit> :t (<)
20:35:38 <lambdabot> forall a. (Ord a) => a -> a -> Bool
20:35:44 <Mertis> well thats where i am, and it is going to involve some calculation ind 3 space
20:35:53 <magn3ts> if (x < n && y > n  || x > n && y < n)  is what I'm thinking.
20:35:56 <Mertis> finding distance using x,y,z
20:36:35 <dmwit> You want x and y to be on opposite "sides" of n?
20:36:40 <magn3ts> dmwit, sure.
20:37:07 <magn3ts> dmwit, I guess it's an easy predicate, wasn't sure if there was a `n in [x..y]` notation.
20:37:08 <shachaf> instance Num Bool; (1 < 2) < 3
20:37:23 <dmwit> > 3 `elem` [1..5]
20:37:24 <lambdabot>   True
20:37:37 <dmwit> > 1 < 3 && 3 < 5
20:37:37 <lambdabot>   True
20:37:40 <shachaf> dmwit: That doesn't do what magn3ts wants for Floats.
20:37:46 <dmwit> No it does not.
20:37:50 <dmwit> The latter does, though.
20:38:26 <dmwit> > inRange 3 (1,5)
20:38:27 <lambdabot>   False
20:38:34 <dmwit> ...
20:38:39 <dmwit> :t inRange
20:38:40 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
20:38:45 <dmwit> > range (1,5)
20:38:46 <lambdabot>   [1,2,3,4,5]
20:38:52 <dmwit> I am confuse.
20:38:55 <magn3ts> hehe
20:39:02 <byorgey> > inRange (1,5) 3
20:39:02 <lambdabot>   True
20:39:08 <dmwit> Oh, that's horrible.
20:39:10 <elliott> lol
20:39:11 <magn3ts> thats what I was going to try!
20:39:15 <dmwit> That's so freaking horrible.
20:39:16 <byorgey> hahaha
20:39:27 <elliott> that's amazing
20:39:40 <elliott> Cale: KILL THAT INSTANCE :)
20:39:55 <dmwit> That instance is convenient once in a while... but confusing ALWAYS. =)
20:40:09 * byorgey likes it =)
20:40:13 <elliott> it even nested there
20:40:18 <byorgey> > 3 + (5.6)
20:40:19 <lambdabot>   8.6
20:40:21 <mauke> > 1 :: (Int, Int)
20:40:21 <elliott> glorious
20:40:21 <lambdabot>   (1,1)
20:40:24 <byorgey> > 3 + (5,6)
20:40:25 <lambdabot>   (8,9)
20:40:38 <Daegalus> question, lets say I have a variable a that is Either String [Num], and I do Left a to get the string. Is there any way for me to get just a  (of type String) instead of Either String b that Left a returns?
20:40:39 <elliott> byorgey: , makes it use european mathematics
20:40:41 <dmwit> > inRange 3 (3,3)
20:40:42 <lambdabot>   True
20:40:49 <byorgey> elliott: hehe
20:40:57 <magn3ts> ugh, this is impossible to do on edge conditions because I have no sense of direction >_<
20:41:06 <byorgey> dmwit: hehe
20:41:08 <dmwit> Daegalus: Use pattern matching or the "either" function.
20:41:22 <mauke> Daegalus: Num is not a type. 'Left' does not "get" a string
20:42:33 <Daegalus> mauke: i know, i am just giving an example, i have a custom type. and I know it doesnt "get" a string, I am just explaining it how I best I know how.
20:42:45 <mauke> Daegalus: example of what?
20:42:54 <mauke> of going in the wrong direction?
20:43:13 <Daegalus> dmwit: you mean like functionName (Left a) = blah?
20:43:34 <mauke> Daegalus: or case/of
20:43:54 <augur> so question regarding ghc
20:43:57 <byorgey> Daegalus: if a is of type Either String [Int], then Left a :: Either (Either String [Int]) b
20:44:29 <augur> if you have a program the will do something like... f : Record -> Record, and apply f lets say 1000000 times
20:44:41 <Daegalus> byorgey: ok, that makes sense. time to fix all my code.
20:44:43 <Daegalus> thx
20:44:45 <augur> f (f (f (f ... x ...)))
20:44:52 <augur> maybe via a fold or something
20:44:59 <augur> does ghc handle this efficiently?
20:45:04 <augur> or will it hog memory?
20:45:10 <elliott> foldl'
20:45:37 <magn3ts> turns out checking in a range wasn't what I would have needed anyway :S
20:45:43 <rwbarton> If f is strict, then you will get a stack overflow as soon as you try to evaluate f (f (f (f ... x ...)))
20:46:08 * edwardk just realized his spec combinators can be used to do speculative evaluation for the future any any codensity monadic computation as well
20:46:18 <edwardk> not just cont
20:46:28 <edwardk> revisions just picked up a speculation combinator =)
20:47:16 <Axman6> @hackage ScalableServer
20:47:17 <lambdabot> http://hackage.haskell.org/package/ScalableServer
20:47:59 <magn3ts> Is it irrational of me to hate !! as an array accessor?
20:48:14 <elliott> !! doesn;t access arrays
20:48:28 <magn3ts> oh crap, that's probably a cardinal sin :o
20:48:34 <edwardk> :t (!!)
20:48:35 <lambdabot> forall a. [a] -> Int -> a
20:48:41 <elliott> it accesses lists
20:48:41 <Axman6> (!!) isn't very widely used
20:48:42 <magn3ts> and would explain why I'm an idiot. Obviously I should stop talking.
20:48:42 <edwardk> (!!) indexes (slowly) into lists
20:48:45 <elliott> in O(n)
20:48:56 <elliott> ! is for arrays, magn3ts
20:49:05 <edwardk> :t (Data.Array.!)
20:49:06 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
20:49:11 <shachaf> elliott: What's !!! for?
20:49:18 <shachaf> Please prove by induction.
20:49:19 <byorgey> magn3ts: so the answer is, no it's quite rational =)
20:49:26 <magn3ts> Oh, interesting. I'm using x!!0, x!!1, x!!2, x!!3 in a lot of places I could be using x0:x1:x2:x3
20:49:39 <shachaf> magn3ts: Yes.
20:49:43 <shachaf> All these list functions are evil.
20:49:43 <companion_cube> it also indexes maps  iirc
20:49:46 <edwardk> magn3ts: in general if you find yourself using !! you're doing something wrong ;)
20:49:49 <magn3ts> cool :)
20:49:51 <byorgey> magn3ts: yeah, use [x0,x1,x2,x3] if you know it's four elements
20:49:52 <shachaf> (!!), head, tail, null, etc.
20:50:04 <magn3ts> edwardk, I picked up on that and then realized I could use x0:x1...
20:50:05 <byorgey> magn3ts: otherwise if you want just the first four you can do (x0:x1:x2:x3:_)
20:50:10 <elliott> byorgey: or a tuple/datatype...
20:50:27 <byorgey> elliott: magn3ts can't change the data format
20:50:35 <elliott> ugh
20:50:41 <magn3ts> byorgey, elliott, now I'm confused again, ha! I'm receiving lists of Num but I know that I will always get 4.
20:50:50 <magn3ts> byorgey, this is some inner functions that I can be flexible with.
20:51:05 <magn3ts> for example, I'm writing, checktt x0:x1:x2:x3, y0:y1:y2:y3, time
20:51:05 <elliott> magn3ts: yeah the types you have to work with suck
20:51:15 <elliott> btw there are no lists of Num
20:51:22 <magn3ts> [x0,x1...] and (x0:x1...)
20:51:34 <magn3ts> Float*
20:51:40 <byorgey> magn3ts: [x,y,z] is just syntactic sugar for (x:y:z:[])
20:51:42 <elliott> right
20:51:56 <byorgey> magn3ts: is that what you were confused about?
20:52:10 <magn3ts> byorgey, yup
20:52:29 <byorgey> magn3ts: so [x0,x1,x2,x3] as a pattern matches lists with exactly four elements
20:52:41 <magn3ts> well, is function declarations is that still a tuple? the (x:y:z:[]) ?
20:52:56 <byorgey> magn3ts: I don't understand the question
20:53:09 <Axman6> magn3ts: that's not a tuple at all
20:53:19 <byorgey> (x:y:z:[]) is a pattern which matches a list
20:53:20 <Axman6> tuples are (a,b,c).
20:53:30 <shachaf> Axman6: Sure, it's a one-tuple.
20:53:32 <magn3ts> like I said, I should stop talking
20:53:44 <byorgey> magn3ts: please don't, you appear to be learning =)
20:53:46 <elliott> sshc:
20:53:48 <elliott> oops
20:53:50 <shachaf> > ((), (1), (1,2), (1,2,3)) -- 0-tuple, 1-tuple, 2-tuple, 3-tuple
20:53:51 <lambdabot>   ((),1,(1,2),(1,2,3))
20:53:57 <magn3ts> byorgey, I've never had an IRC room be this nice about it :)
20:53:57 <elliott> shachaf: with no arguments? :)
20:54:01 <byorgey> 1-tuple, hehe
20:54:11 <shachaf> elliott: Exactly!
20:54:13 <byorgey> magn3ts: that's because you've never been to #haskell ;)
20:54:15 <shachaf> Everything is a tuple, in Haskell.
20:54:45 <byorgey> everything is a tuple, and also a function, and also a zygohistomorphic prepromorphism
20:54:49 <Axman6> haskell has syntactic sugar for 1-tuples, you can choose to omit the the brackets
20:54:53 <byorgey> =P
20:55:00 <elliott> a, IO a, IO (IO a) -- the IO hierarchy. everything is an IO in Haskell
20:55:08 <elliott> > () -- 0-IO
20:55:08 <lambdabot>   ()
20:55:09 <byorgey> hehehe
20:55:24 <monochrom> @quote monochrom little
20:55:25 <lambdabot> No quotes match. Wrong!  You cheating scum!
20:55:30 <shachaf> @let evil = undefined :: Mu IO
20:55:31 <lambdabot>  Defined.
20:55:37 <elliott> join goes one down
20:55:37 <shachaf> I don't think I want to know what that is.
20:55:41 <ddarius> :k (##)
20:55:42 <lambdabot> Not in scope: type variable `##'
20:55:42 <monochrom> @quote monochrom 5
20:55:43 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
20:55:44 <elliott> which is why it's unsafw
20:55:45 <elliott> e
20:55:46 <ddarius> :k (# #)
20:55:46 <lambdabot> ? -> (#)
20:55:48 <monochrom> @quote monochrom 8
20:55:49 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
20:55:49 <magn3ts> oh crap, so if my function takes x0:x1 I don't get access to just x then, do I have to recompose it to pass it to another function?
20:55:53 <monochrom> @quote monochrom 13
20:55:53 <elliott> it's unsafePerformIO!
20:55:54 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
20:55:57 <ddarius> That's (the type of) a one-tuple.
20:56:02 <monochrom> @quote monochrom 13
20:56:02 <lambdabot> monochrom says: These 113 blogging accounts of course don't cost me.  But I still get the feeling of lying around with 113 prostitutes... XD
20:56:17 <byorgey> magn3ts: you can use an @ pattern
20:56:17 <shachaf> Control.Monad.Identity is also a one-tuple.
20:56:19 * Axman6 suggests everyone shuts up and gets back on topic again
20:56:20 <elliott> @quote monochrom 9
20:56:21 <lambdabot> monochrom says: but yes there is hope that haskell 2039 becomes haskell 1971, all is not lost.
20:56:21 <shachaf> But it's not lifted. :-(
20:56:27 <monochrom> gosh, lambdabot certainly forgot many of my quotes
20:56:31 <magn3ts> byorgey, thats going to be fun to google for ha
20:56:58 <magn3ts> actually wasn't that bad :D
20:57:10 <byorgey> magn3ts: for example, l@(x0:x1:_)  is a pattern which matches a list of at least two elements. x0 and x1 are bound to those two elements, and l is bound to the entire list
20:57:29 <byorgey> magn3ts: so it's a way to give a name to an entire structure while also taking it apart
20:57:49 <magn3ts> so is it going to roar at me for not including :_ at the end then?
20:58:18 <byorgey> magn3ts: well, (x0:x1) matches a list with at least one element, where the first element is called x0 and the rest of the list is called x1
20:58:27 <magn3ts> byorgey, oh no!
20:58:34 <Jafet> rawr
20:58:40 <magn3ts> duh that should have been obvious from the pattern...
20:58:54 <byorgey> magn3ts: (x0:x1:_) means "x0 is the first element, x1 is the second element, and I don't care (_) about the rest of the list"
20:59:02 <magn3ts> yup got that :)
20:59:11 <magn3ts> meaning that the last :whatever is the end of the list no matter what.
20:59:17 <byorgey> yep
21:00:13 <Sgeo|web> Does data-lenses require GHC 7.*?
21:00:51 <shachaf> Probably not.
21:01:06 <byorgey> Sgeo|web: it depends on base-4.* so probably not
21:01:07 <shachaf> You're probably as capable of finding out as we are. :-)
21:01:43 <Jafet> Who doesn't have GHC 7.*?
21:02:01 <parcs_> debian stable
21:02:02 <kmc> people running debian stable
21:02:05 <kmc> ha parcs_
21:02:08 <parcs_> :)
21:02:23 * shachaf shachaf shachaf *
21:02:23 <Jafet> aka. "Old Hat Linux"
21:03:53 <Mertis> getting and error, non exaustive patter, its for the last function i wrote at the bottom http://snipt.org/wgJ4
21:04:08 <kmc> 7.0 has been out for less than a year
21:04:23 <shachaf> Old hat.
21:04:51 <hpaste> levkin pasted “loop search” at http://hpaste.org/53776
21:04:55 <elliott> Sgeo|web: it's data-lens
21:05:00 <elliott> not data-lenses
21:05:21 <kmc> sure, home users and developers will upgrade to the latest and greatest
21:05:56 <monochrom> non-exhaustive pattern is just a warning, not an error
21:06:26 <shachaf> Warnings are just 1-errors.
21:06:33 <shachaf> When there's no message, that's a 0-error.
21:06:40 <shachaf> Everything is an error.
21:06:42 <elliott> :D
21:06:47 <elliott> shachaf++
21:07:01 <monochrom> god
21:07:16 <kmc> companies with real money on the line are not going to upgrade to a new major version of a compiler, which is less than a year old, without some good reason
21:07:17 <Mertis> well it is causing a problem because im getting no other output
21:07:18 <ddarius> A 2-error has errors between errors.
21:07:34 <shachaf> A 2-tuple has tuples between tuples?
21:07:48 <shachaf> monochrom: We need to you to get witty again following the Great Lambdabot Crash.
21:07:49 <ddarius> (((a),(b)))
21:08:11 <Mertis> was testing getOutPutLongLatWithAlt with and input of [1,2,3,4] [3,4,5,6] 100
21:08:13 <shachaf> That looks to me like a one-tuple of a two-tuple of two one-tuples.
21:08:16 <Mertis> no output
21:08:18 <monochrom> @botsnack
21:08:18 <lambdabot> :)
21:08:29 <Sgeo|web> I don't think I entirely understand the full implications of lenses
21:08:37 <elliott> shachaf: it's clearly a 0-IO
21:09:45 <shachaf> Sgeo|web: Tell us which part you don't understand, and we'll tell it to you.
21:09:51 <ddarius> Sgeo|web: Modus ponens?
21:10:31 <monochrom> getOutPutLongLatWithAlt is a typo
21:10:34 <Sgeo|web> If I wasn't looking at libraries other than data-lens, I would have missed that you can compose them easily
21:10:43 <Sgeo|web> What other things am I likely to miss?
21:10:46 <monochrom> getOutputLongLatWithAlt [1,2,3,4] [3,4,5,6] 100  gives me [98.0,99.0,100.0]
21:10:55 <monochrom> so, works for me
21:11:00 <elliott> that's what the Category instance is for, Sgeo|web.
21:11:19 * Sgeo|web isn't that familiar with categories etc. ec.
21:11:22 <Sgeo|web> *etc.
21:11:35 <elliott> its trivial, id + (.)
21:12:03 <Sgeo|web> elliott: as in, I'm also not familiar with the other things Lenses are instances of. Or their superclasses
21:12:20 <elliott> see instance list, click to read docs of classes
21:12:28 <shachaf> $ ghci
21:12:33 <shachaf> λ> :i Lens
21:12:49 <kmc> that works when the class is documented
21:13:28 <elliott> kmc: when it's not, there's #haskell
21:13:46 <ddarius> s/#haskell/Typeclassopedia/
21:16:30 <kmc> docs will tell you that your type is an instance of some class named after a tangentially related concept in abstract algebra
21:16:39 <kmc> not always clear how that's useful in code
21:16:56 <kmc> even if you know some abstract algebra!
21:16:57 <elliott> lenses don't have many instances
21:16:57 <ddarius> Do we have any classes like that in the "standard" libraries?
21:17:10 <elliott> Monad :p
21:17:15 <ddarius> I guess Monoid, though I wouldn't say that's tangentially related.
21:17:27 <ddarius> Monad usually isn't considered part of abstract algebra.
21:17:39 <shachaf> s/algebra/nonsense/
21:17:43 <elliott> shhh you're killing my funny with facts
21:17:53 <monochrom> but IO is tangentially related to Monad :)
21:17:55 <kmc> category theory is not part of abstract algebra?
21:18:25 <ddarius> People don't usually study category theory as an algebraic object.
21:18:34 <ddarius> s/category theory/categories/
21:18:41 <monochrom> don't forget there is universal algebra
21:18:51 <mike-burns> So in short, we need more concrete examples of how to actually use these things to solve actual problems.
21:19:02 <ddarius> Which a category isn't an instance of a universal algebra (admittedly it is closer to one than a field is.)
21:19:05 <kmc> mike-burns, i think so.  though i may be spreading FUD
21:19:10 <kmc> i don't have so many concrete examples
21:19:12 <kmc> not from the std lib anyway
21:19:14 <geheimdienst> no, kmc++
21:19:36 <kmc> certainly the problem with Monad is not that there's too little written about it
21:19:49 <magn3ts> how do I get more than "parse error" out of ghc?
21:19:51 <shachaf> We could use some FUD around here.
21:19:58 * ddarius is hungry.
21:20:04 <shachaf> @quote monochrom IO.String
21:20:04 <lambdabot> monochrom says: How do I extract the IO out of IO String?
21:20:25 * ddarius needs to find a restaurant that is decent and open 24 hours and is near me.
21:20:31 <mike-burns> It's all well and good that these type classes have the same names as mathematical concepts, but it's more interesting to people like me to know how it's supposed to be used to solve my problems.
21:20:36 <shachaf> Oh. I read that as «how do I get the "parse error" out of ghc?»
21:20:41 <monochrom> ghc usually spews out way more than "parser error". in other words I don't believe you
21:20:45 <dibblego> by reading mathematics of course
21:20:51 <mike-burns> Ah, of course.
21:20:54 <dibblego> np
21:20:55 <dolio> 24 hours is tough.
21:21:02 <magn3ts> monochrom, okay, and a line number :P
21:21:08 <monochrom> hahahaha shachaf. how do I get the Haskell out of GHC? :)
21:21:16 <mike-burns> magn3ts: Paste the code.
21:21:23 <mike-burns> Use hpaste.
21:21:31 <monochrom> don't paste the code. we love blind-guessing. or ignoring.
21:21:33 * ddarius used to go to a Greek restaurant back near where he grew up in these situations.
21:21:37 * ddarius misses Greek restaurants.
21:21:38 <geheimdienst> magn3ts: check the line that the error message mentions, and the line before. usually you have indentation wrong or missed parens
21:22:02 <monochrom> however, do take a screenshot. "pics or didn't happen"
21:22:07 <magn3ts> Um, lol monochrom, my reluctance is that this is an assignment and posting it here puts me at risk.
21:22:08 * hackagebot speculation 1.3 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.3 (EdwardKmett)
21:22:10 <kmc> mike-burns, well, part of the problem is that they're so general
21:22:13 <Mertis> ok so i wrote a function to calculate the coordinate of a point on a line in 3 space, given 2 points, and a Z parameter.  it is giving me incorrect values http://snipt.org/wglp4
21:22:14 <shachaf> hey #haskell how do i turn String into IO String
21:22:20 <kmc> shachaf, hint
21:22:30 <elliott> shachaf: unsafeCoerce#
21:22:33 <shachaf> Actually, when I was learnig Haskell, I had that issue.
21:22:35 <monochrom> then choose a pastebin that expires quickly
21:22:36 <mike-burns> kmc: Agreed, but I'd be fine with seeing three examples.
21:22:43 <geheimdienst> > let f = ("IO " ++) in f "lolcats" -- shachaf
21:22:44 <lambdabot>   "IO lolcats"
21:23:02 <shachaf> I tried to use «IO x» to turn a to IO a.
21:23:03 <mike-burns> Hah.
21:23:07 <kmc> mike-burns, easy to say that a WidgetSprocketAdaptorFactory is used when you have a widget and a sprocket and need to make them communicate
21:23:16 <ddarius> shachaf: You see that reasonably often.
21:23:24 <hpaste> magn3ts pasted “Parse error in pattern: simInner” at http://hpaste.org/53777
21:23:28 <elliott> Either 42
21:23:33 <kmc> Monoid is used for, uh, stuff that, uh, goes together
21:23:37 <shachaf> ddarius: Yes.
21:23:47 <shachaf> In my defense I was reading a confusing monad tutorial.
21:23:47 <kmc> appendishly
21:23:59 <elliott> appendishly++
21:24:02 <kmc> mike-burns, but yeah, more examples would be nice
21:24:06 <dmwit> magn3ts: More parentheses.
21:24:12 <dmwit> magn3ts: simInner (x:y:xs) time
21:24:19 <kmc> Cale has a really cool example of using the Monoid instances of Ord and ((->) r)
21:24:19 <magn3ts> really? haha
21:24:21 <shachaf> kmc: Can't you just say "associative unital magmas"?
21:24:22 <kmc> err of Ordering
21:24:28 <mike-burns> kmc: Yeah, but then you can show things like monoidal parsers and also addition and maybe that will make (people like) me see how I'm supposed to use a monoid.
21:24:28 <shachaf> Yes, that example is neat.
21:24:30 <monochrom> "blah.hs:61:1: Parse error in pattern: simInner" is still a lot more than "parse error and line number"
21:24:39 <kmc> it would be nice if those examples could make their way into the haddock for 'base'
21:24:41 <dmwit> magn3ts: Probably later, too: ... ++ (simInner (y:xs) (time + ...))
21:24:46 <kmc> really a lot of the 'base' docs are crap
21:24:46 <monochrom> this is why I take almost all askers as liers.
21:24:54 <geheimdienst> kmc+++
21:24:54 <monochrom> s/liers/liars/
21:25:04 <shachaf> > sortBy (comparing length ++ compare) (words "Cale has a really cool example of using the Monoid instances of Ord and ((->) r)")
21:25:05 <lambdabot>   ["a","of","of","r)","Ord","and","has","the","Cale","cool","((->)","using","...
21:25:08 <monochrom> anyway, simInner (x:y:xs) time =
21:25:12 <kmc> like you can't learn about monads by reading the docs for Control.Monad
21:25:26 <mike-burns> kmc: +1 to putting examples in the docs themselves. I try to do that for all docs I write (in any language).
21:25:27 <shachaf> kmc: Sounds like the situation calls for someone to write a Monad tutorial.
21:25:32 <mike-burns> Haha.
21:25:38 <geheimdienst> kmc: absolutely, it often doesn't even point you in the right direction. it just mystifies
21:25:39 <shachaf> kmc: I don't know if documentation of that sort really belongs in the source file.
21:25:45 <magn3ts> ugh, I have commas everywhere /idiotidiot
21:25:47 <elliott> Data.NuclearWastw
21:25:49 <elliott> e
21:25:52 <mike-burns> shachaf: It does.
21:25:54 <kmc> you have to google all day and find 100 blog posts about monads
21:26:00 <kmc> 96 of which will be crap
21:26:03 <shachaf> kmc: Maybe a link to haskell.org/howdoimonad would be reasonable to put in there.
21:26:05 <Mertis> anyone real good at math to see why this isnt working.  http://snipt.org/wglp4
21:26:05 <geheimdienst> kmc, i recently wondered why the haddocks don't look like the "tour de monad"
21:26:09 <kmc> 80 of which will look useful and waste your time
21:26:26 <Mertis> given two points in 3 space and a z, find the point where that z is on the line
21:26:50 <geheimdienst> (i.e. the tour could be copied into the haddocks)
21:26:58 <mike-burns> Reading Control.Monad has nothing to help a new user figure out how to get an `a' into an `IO a'.
21:27:18 <shachaf> mike-burns: Eh, I was too confused about surrounding concepts at the time for it to be much help.
21:27:25 <dmwit> ?hoogle a -> IO a
21:27:26 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
21:27:27 <lambdabot> Control.Exception evaluate :: a -> IO a
21:27:27 <lambdabot> Control.OldException evaluate :: a -> IO a
21:27:45 <mike-burns> Haha, thanks Hoogle.
21:27:48 <shachaf> There's no real reason someone who's trying to turn a to IO a should have to think about the M-word.
21:27:57 <shachaf> Well, there's a bit of a reason. But it's probably not helpful at first.
21:27:59 <mike-burns> Oh sure, agreed.
21:28:00 <edwardk> and 16 o them were written while someone was on a diet and thinking about burritos
21:28:12 <ddarius> kmc: Reference documentations is rarely a tutorial.
21:28:19 <shachaf> Mmm, burritos.
21:28:29 <kmc> shachaf, sure, but they will anyway, because they see the words "monadic IO" everywhere
21:28:45 <kmc> and read 100 more blog posts about people who are giving up haskell because "monads are too hard"
21:28:48 <shachaf> kmc: OK, so a few disclaimers at the top of the file will maybe be helpful.
21:28:52 <kmc> so clearly it must be the key concept to grasp
21:28:56 <dmwit> ddarius: ...which is not to say tutorials aren't important, of course.
21:29:10 <shachaf> dmwit: Right, but they don't belong in the reference documentation.
21:29:14 <dmwit> Too many negatives there to be sure that says what I meant. I meant, tutorials are important.
21:29:27 <geheimdienst> ddarius: haskell reference documentation _is_ really bad. often the main purpose seems to  mystify and show off how lofty mathy smarty the writer was
21:29:33 <ddarius> dmwit: That seems rather orthogonal t owhat I said.
21:29:42 <ddarius> geheimdienst: Example?
21:29:50 <magn3ts> square isn't part of Prelude?
21:29:57 <ddarius> (^2)
21:30:01 <mike-burns> Tutorials are slightly more important than reference docs, and especially for people unfamiliar with your library, but I see more reference docs than tutorials for most packages.
21:30:22 <dmwit> (^2), or (**2), or (^^2)
21:30:39 <ddarius> If I had to choose between reference documentation or a tutorial, I'd hands-down choose the reference documentation.
21:30:51 <dmwit> Exponents are such an important topic Haskell covered it thrice.
21:30:56 <geheimdienst> e.g. "mappend :: a -> a -> a -- An associative operation". that's the whole docs
21:30:58 <kmc> geheimdienst, I'm curious, do you have a specific example like that?
21:31:08 <dmwit> Reference docs are easier to write than tutorials, I think.
21:31:10 <kmc> I don't think that's to show off...
21:31:12 <mike-burns> I'd choose a tutorial and a link to the source code.
21:31:16 <ddarius> geheimdienst: What would you prefer it say?  And is "associative" a sign of erudition?
21:31:22 <kmc> mathematicians invent all these crazy words because it enables them to communicate quickly with other mathematicians
21:31:37 <kmc> that's just a symptom of forgetting that your audience is not all mathematicians
21:31:42 <geheimdienst> "Boolean monoid under disjunction" is another
21:32:47 <ddarius> That could be "Boolean monoid under or" or (||), but "disjunction" is far from out there.
21:33:06 <kmc> i do not think the purpose is to show off or to mystify
21:33:11 <mike-burns> OK, so some of us recognize this as an issue. What can someone like me do to fix it?
21:33:15 <kmc> that may be a slightly intentional secondary effect
21:33:20 <mike-burns> Where do I submit a pull request?
21:33:37 <kmc> but "Boolean monoid under disjunction" is a really nice way to express that idea to someone who knows what those words mean
21:33:38 <shachaf> "Moolean monoid under zygojunction"
21:33:39 <magn3ts> here goes dumb again
21:33:40 <magn3ts> > let distToTime (startx endx starty endy speed) = (sqrt square startx-endx + square starty-endy) / (speed * (1/111) * (1/3600))
21:33:41 <lambdabot>   <no location info>: Parse error in pattern
21:33:42 <geheimdienst> true, i should collect some good examples
21:33:46 <Mertis> anyone good with handling a parameterized equaiton
21:33:50 <kmc> it's just forgetting about your audience
21:34:10 <shachaf> magn3ts: Maybe get rid of the parentheses?
21:34:11 <mike-burns> magn3ts: Can't do that from ghci.
21:34:12 <Mertis> finding a poing on a line in 3 space given two points, and one parameter of a 3rd point
21:34:17 <mike-burns> (Or can you now?)
21:34:27 <shachaf> That function takes one argument, whose pattern is (startx endx starty endy speed) (which is invalid).
21:34:29 <monochrom> cannot yet
21:34:35 <kmc> also standardized math jargon is less obnoxious than language-specific jargon invented from whole cloth
21:34:37 <dmwit> magn3ts: Less parentheses. distToTime startx endx starty endy speed = ...
21:34:40 <ddarius> kmc: In the documentation for Monoid, I think it is quite reasonable to call something a boolean monoid.
21:34:54 <Mertis> im sooo close to a major breakthrough on this
21:34:59 <ddarius> geheimdienst: I still want an answer to my earlier questions.
21:35:02 <kmc> the latter is common in every language
21:35:03 <Mertis> if i get this its smooth sailin i think
21:35:06 <companion_cube> monoid is common enough
21:35:10 <geheimdienst> about mappend being an associative operation: it might be applicable, but it doesn't tell you much at all. it's almost as if the docs were "A function that takes 2 arguments."
21:35:13 <mike-burns> ddarius: it's also reasonable to then explain what a Boolean monoid is, for those who didn't understand it.
21:35:43 <dmwit> Mertis: That problem specification is not guaranteed to have a solution...
21:35:47 <magn3ts>  hm they paren are throwing me a bit
21:35:47 <Jafet> Well, the only thing you can literally say about mappend is that it's "an associative operation"
21:35:50 <Jafet> @instances Monoid
21:35:50 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:36:11 <kmc> also I much prefer people showing off how mathy smart they are to people showing off how they're true red-blooded anti-intellectual Real Programmers
21:36:14 <ddarius> mike-burns: I expect any programmer to know what a boolean is.  And the package is about monoids, so clearly it is a monoid, in the sense of the package, for booleans.
21:36:22 <kmc> there is a very wide spectrum between these two points
21:36:30 <Mertis> ok i gave it inputs but the point im given as a result can no way be on the line
21:36:31 <kmc> but I do consider it a useful feature that the latter people run screaming from Haskell
21:36:32 <Mertis> so
21:36:34 <dmwit> Mertis: For example, suppose I give you the two points (0, 0, 0) and (0, 0, 1) and ask for a point on that line that has x = 1...
21:36:35 <Mertis> i think its my math
21:36:59 <Mertis> dmwit: Ill hand that later, i think my math is wrong
21:37:08 * hackagebot speculation 1.4 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.4 (EdwardKmett)
21:37:42 <ddarius> geheimdienst: I agree that it doesn't tell you much.  There is literally almost nothing to say.  It basically is not much more than "a function that takes 2 arguments."  But 1) what would you want there instead and 2) how is this an example of trying to mystify or show off?
21:37:42 <mike-burns> See, look at the docs for speculation: an example right at the top.
21:38:09 <mike-burns> Of course, that's the only documentation for it ...
21:38:14 <ddarius> An example is not a tutorial.
21:38:25 <ddarius> I'm fine with reference documentation including examples.
21:38:30 <mike-burns> I've only ever said I wanted examples.
21:38:34 <mike-burns> (I think I've only said that.)
21:38:38 <shachaf> I think the definition of instance Monoid Any is more illuminating than that text.
21:38:51 <mike-burns> (Oh I said tutorial a few times.)
21:38:59 <ddarius> The Parsec documentation includes several small examples.
21:39:00 <shachaf> Which is why I prefer reading .hs files instead of generated Haddock.
21:39:24 <monochrom> how would you write the haddock for (+)?
21:39:36 <mike-burns> To clarify my stance, which shachaf seems to agree with: I want examples and a link to the source code.
21:39:39 <kmc> well you see, a Num is like a burrito
21:39:41 * elliott thinks base's documentation is mostly fine. At most it should point to LYAH or similar, but perhaps endorsing something like that in official sources is unwise.
21:39:47 <elliott> Definitely don't try and give "monad examples".
21:39:50 <kmc> (+) is kind of like unrolling the two burritos and mushing them together inside a larger tortilla
21:39:55 <ddarius> "(+) -- a non-associative, non-unital, closed binary operation"
21:39:59 <elliott> That's a nonsense idea, you can't give examples of such a general API.
21:40:06 <elliott> It will inevitably lead to misleading impressions based on the choice of examples.
21:40:07 <kmc> fromInteger is like where you order a burrito plate by number at the taqueria
21:40:08 <monochrom> mind you, "addition" hides a lot more ugly details and corner cases than mappend's "associative"
21:40:11 <kmc> hope that helps
21:40:31 <magn3ts> dmwit, when I call distToTime do I need to wrap the args in parens?
21:40:31 <shachaf> kmc: What is (*) like?
21:40:32 <mike-burns> How about examples of Either, using it to e.g. produce error/success values? Is that too general to bother with?
21:40:33 <elliott> kmc: what's (*)?
21:40:35 <elliott> shachaf: ^5
21:40:43 <elliott> mike-burns: That would be fine.
21:40:56 <elliott> mike-burns: But still, people should not read base documentation to learn Haskell.
21:41:03 <ddarius> Hopefully we can all agree that (+) is closed for the appropriate notion of "closed" for Haskell.
21:41:04 <kmc> disagree
21:41:08 <elliott> It's reference documentation; yes, it still has quality standards.
21:41:09 <monochrom> the only reason you accept "addition" as the be-all-end-all haddock for (+) is you have been brainwashed to accept it. by schooling.
21:41:11 <kmc> people should not /only/ read base documentation
21:41:15 <elliott> But it should be more useful for returning users than new ones.
21:41:16 <dmwit> magn3ts: You may need to wrap particular arguments in parentheses.
21:41:18 <elliott> kmc: That's what I mean.
21:41:19 <kmc> but reference docs are useful at each stage
21:41:19 <mike-burns> elliott: At some point they're reading base docs because they have learned Haskell and now need to use it.
21:41:25 <kmc> not just for experts
21:41:38 <elliott> mike-burns: They've learned Haskell but don't get simple typeclasses like Monoid?
21:41:42 <dmwit> magn3ts: For example, "f x y" applies "f" to arguments "x" and "y", but "f (x y)" applies "f" to the argument which is the application of "x" to "y".
21:41:46 <elliott> They read a bad tutorial: they haven't learned Haskell yet.
21:41:47 <kmc> good reference docs for Prelude and Data.List are really important for beginners
21:42:04 <magn3ts> dmwit, hm ok
21:42:05 <mike-burns> When I need to use e.g. time I don't go looking for a tutorial. I go to Hoogle.
21:42:07 <kmc> maybe they don't need overloading like Monoid or Arrow
21:42:08 * hackagebot kan-extensions 2.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.1 (EdwardKmett)
21:42:10 <ddarius> Good reference documentation is important.
21:42:11 <elliott> kmc: agreed. But while light examples for types are a good idea, I disagree that examples for typeclasses are a good idea
21:42:13 <kmc> kaaaaaaaaaan!
21:42:27 <elliott> because they're abstract, that's the point :)
21:42:30 <shachaf> Prelude documentation should be kept simple. Expert-only documentation should go in Fugue.
21:42:35 <mike-burns> Improving base's documentation can only be good for us!
21:42:36 <elliott> shachaf: :D
21:42:50 <ddarius> kmc: Daniel was way more positive than Immanuel.
21:43:01 <dmwit> magn3ts: Perhaps a better dichotomy is between "(f x) y" and "f (x y)". You would obviously expect these to mean different things.
21:43:27 <dmwit> magn3ts: Work out how you would want them to be different. Then observe that you usually want the former, and you will understand why parentheses work the way they do in Haskell.
21:43:29 <shachaf> instance Monoid " "
21:43:36 <ddarius> Prelude types should be kept simple.  Expert-only types should go in Control.Monad.
21:43:56 <magn3ts> dmwit, yeah, I was using them correctly, just having a rough time with ghc's errors.
21:44:06 <magn3ts> I've been lucky so far to not have to deal with them much
21:44:20 <dmwit> kmc: I like that joke. =)
21:44:44 <shachaf> magn3ts: Compiler errors aren't necessarily a bad thing.
21:44:54 <shachaf> You should get used to dealing with them, at least.
21:45:01 <mike-burns> You'll learn to love them.
21:45:17 <mike-burns> In very much the same way test-driven developers learn to love failing tests.
21:45:28 <shachaf> Better to have a compiler error than not to have a compiler error.
21:46:00 <magn3ts> Oh no, don't get me wrong, I appreciate compile time checking, just haskells errors are a bit of a mystery to me still :)
21:46:22 <kmc> GHC could certainly improve the error messages
21:46:40 <mike-burns> Improve the error messages?! But us experts don't need improved error messages!
21:47:00 <elliott> GHC should just drop everything after the second or so line of errors :)
21:47:05 <kmc> in a system with type inference, there is tremendous potential to explain a type error through a series of deductions, with code highlights at each stage
21:47:13 <kmc> i think edwardk is working on something like that
21:47:14 <shachaf> We need the error messages edwardk is working on.
21:47:18 <shachaf> Hah. Yes.
21:47:30 <ddarius> ?
21:47:31 <ddarius> ^
21:47:31 <elliott> Actually it should just never print errors, we should just all use flymake and never get any more information than "bad red code".
21:47:43 <edwardk> ddarius: i've been spending a lot of time working on type error slicing
21:47:46 <elliott> That might actually be more productive than figuring out GHC's messages nowadays. :/
21:47:58 <ddarius> edwardk: I was just about to say that that sounds like type error slicing.
21:48:00 <kmc> "x must have type Int because y has type Char and f has type Char -> Int and you used (f y) over here"
21:48:10 <ddarius> edwardk: You should remake Chameleon's type debugger.
21:48:11 <kmc> with highlighted source at each step
21:48:14 <mike-burns> Oh it's like an hour and a half beyond when I wanted to sleep. Later.
21:48:23 <edwardk> ddarius: i have a kind checker and part of a type checker for haskell which is using amakuni style type error slices
21:48:34 <edwardk> which i happen to like better than the ones from chameleon
21:48:49 <edwardk> mainly coz they let me see the data declarations that contributed to the error, etc. as well
21:48:51 <ddarius> kmc: The key thing about type error slicing is that you don't arbitrarily pick one part as being at fault.
21:49:11 <ddarius> Chameleon didn't do type error slicing.
21:49:41 <elliott> GHC should just do the minimum possible changes to make your program type.
21:49:49 <shachaf> main = undefined
21:49:53 <monochrom> explaining type inference turns out to be very hard. I tried.
21:49:56 <edwardk> my current work on the revisions project has to do with the fact that i want to be able to run a typing problem in parallel getting a deterministic result, make minor edits to the type and replay the check only computing deltas for what has changed
21:49:57 <ddarius> unsafeCoerce (expr)
21:49:58 <elliott> shachaf: That types.
21:50:07 <elliott> Oh, I see.
21:50:11 <ddarius> monochrom: Teach logic programming first.
21:50:13 <elliott> Without unsafe functions or _|_. :p
21:50:23 <elliott> shachaf: Anyway, that's a huge change (removes all code)
21:50:35 <monochrom> yeah, that's what happens
21:50:36 <edwardk> elliott: i welcome your dissertation on how to find said global minimum ;)
21:50:36 <shachaf> elliott: Fine, <problematicpart> = undefined
21:50:47 <elliott> edwardk: Heuristics, maaaan.
21:50:51 <elliott> shachaf: I said no _|_!
21:51:06 <elliott> edwardk: It'll just try like fifty modifications in parallel and then pick whichever one it likes best based on the phase of the moon.
21:51:09 <ddarius> <problematic part> = 3, iterate.
21:51:13 <monochrom> I eventually stopped writing my type inference tutorial and started writing my lazy evaluation tutorial. oh boy the latter was so much easier!
21:51:17 <edwardk> elliott: but how is it to know if its dropping a bottom in there? it might find a term and substitute it leading to an infinite loop
21:51:18 <companion_cube> <problematicpart> = <problematicpart>
21:51:21 <elliott> ddarius: That would produce gigantic changes.
21:51:30 <elliott> edwardk: OK, fine, so we need a halting oracle, so what!
21:51:34 <elliott> Sheesh.
21:51:40 <Isthan> Can anyone take a look at this http://snipt.org/wqj7 code to see why runtimeList function causes type error?
21:51:40 <elliott> You guys need a more "can-do" work ethic.
21:51:43 <copumpkin> ooo aaaa
21:51:48 <copumpkin> I am the oracle
21:51:49 <copumpkin> of Halting
21:51:54 <shachaf> * copumpkin is now known as
21:52:00 <Isthan> expecting Float, inferred [Float]
21:52:03 <elliott> Isthan: You don't want those caps.
21:52:04 <ddarius> Being a halting oracle is easy. "Will this halt?" "Yes.
21:52:05 <ddarius> "
21:52:05 <companion_cube> a code synthesis given the correct type would be nice
21:52:14 <shachaf> ddarius++
21:52:14 <ddarius> @djinn a -> b -> a
21:52:14 <monochrom> * copumpkin is now known as diagonalization
21:52:15 <lambdabot> f a _ = a
21:52:17 <OracleOfHalting> ddarius: needs more oos and aaas
21:52:19 <Isthan> they arent caps, the website did that
21:52:32 <edwardk> ddarius++
21:52:36 <companion_cube> OracleOfHalting: you need an OracleOfOracleOfHalting
21:52:37 <magn3ts> dmwit, am I right in guessing I've messed up parens again on createPtW http://hpaste.org/53778
21:52:51 <elliott> <shachaf> * copumpkin is now known as
21:52:52 <elliott> shachaf++
21:52:59 <shachaf> elliott: ?
21:53:11 <elliott> shachaf: You predicted copumpkin's name change.
21:53:13 <elliott> At least from here.
21:53:32 <Isthan> elliot: I formatted the code wrong on URL, I updated it
21:53:43 <shachaf> I was wondering whether I predicted or caused it.
21:53:50 <shachaf> I suppose the former implies the latter.
21:53:59 * shachaf insider
21:54:04 <byorgey> magn3ts: function application binds more tightly than anything else
21:54:11 <monochrom> > [1,2] !! 0 + 1
21:54:12 <lambdabot>   2
21:54:17 * ddarius predicts stock price increases.
21:54:21 <byorgey> magn3ts: so, for example, distToTime x!!0  parses as  (distToTime x) !! 0
21:54:26 <monochrom> oops
21:54:33 <magn3ts> wow thats greedy of it :P
21:54:34 <byorgey> so all of those x!!n need parentheses
21:54:35 <monochrom> > [1,10] !! 0 + 1
21:54:36 <lambdabot>   2
21:54:46 <Mertis> i need someone that is good with parametric equations
21:54:48 <Mertis> anyone
21:54:50 <monochrom> > [1,10] !! 0 * 2
21:54:51 <lambdabot>   2
21:55:05 <companion_cube> Mertis: sorry, can't help with that
21:55:21 <byorgey> magn3ts: but I thought you were going to pattern-match on x instead of using !! everywhere?
21:55:30 <Isthan> > [1,10] !! 1 + 1
21:55:31 <lambdabot>   11
21:56:02 <byorgey> magn3ts: also, square startx-endx == (square startx) - endx, don't know if that's what you meant
21:56:10 <min> elapsedTime returns [Float] and runTimeList conses [Float]s only [[Floats]]s, but you're saying the return type is [Float].
21:56:41 <monochrom> most likely you should square (startx-endx) if I understand euclidean distance correctly
21:57:12 * magn3ts nods
21:57:28 <monochrom> seriously, time to write a syntax tree rather than write in text encodings
21:57:33 <hpaste> asdasdasd annotated “adf” with “adf (annotation)” at http://hpaste.org/53778#a53779
21:58:10 <monochrom> it's almost like you already know how to write a movie review in English but pervertedly I demand you write the review in Martian
21:58:12 <ddarius> monochrom: "I can't figure out how to enter 'hello world'"
21:58:24 <Mertis> nevermind im an idiot
21:58:29 <Mertis> i had it correct the entire time
21:58:35 <ddarius> #haskell solves another problem
21:58:57 <Mertis> i thought the output i was getting was bogus but it is actually correct with what i gave it
21:59:06 <ddarius> monochrom: Martian has a much more regular structure than English.
21:59:34 <monochrom> ok, make it pig latin
21:59:41 <monochrom> it's almost like you already know how to write a movie review in English but pervertedly I demand you write the review in pig latin
22:00:11 <shachaf> "There were Tenants on Earth, it said. Why not on Mars, too?"
22:00:33 <ddarius> Those Martians don't pay rent.  That's why.
22:01:11 <elliott> Haskell should just be Lojban instead, whereby Lojban I mean Esperanto, whereby Esperanto I mean Miranda.
22:01:28 <shachaf> s/whereby/where by/g :-(
22:01:33 <Isthan> min: I dont quite understand your response
22:01:44 <elliott> shachaf: :-)
22:01:50 <ddarius> map : (* -> **) -> list * -> list **
22:02:03 <companion_cube> monochrom: then you want to write lisp, if you want to write syntax trees ? :)
22:02:17 <shachaf> ddarius: At least they use ":".
22:02:22 <shachaf> Much more sensible than "::".
22:02:27 <ddarius> companion_cube: That's definitely not what he wants to do.
22:02:33 <kmc> better than  ('a -> 'b) -> 'a list -> 'b list
22:02:54 <elliott> Speaking of weird function arrow syntaxes, why does Clean omit the arrow for higher-ordered functions?
22:03:13 <kmc> example?
22:03:14 <edwardk> some of my function signatures would look rather epic in miranda, if they could get past the type checker
22:03:16 <shachaf> (α → β) → α* → β*
22:03:25 <monochrom> I want to see the tree drawn out on the screen. but if the keyboarding coincides with s-expr entering, I don't mind
22:03:27 <elliott> (Additional Clean syntax question: why do they call (x:xs) [x:xs]??)
22:03:27 <edwardk> that or they'd look like i'd been beeped out
22:03:28 <ddarius> It doesn't.  Clean has a slight distinction between juxtaposition and (curried use of) function types.
22:03:38 <elliott> kmc: haskell: (a -> b) -> [a] -> [b]
22:03:42 <elliott> kmc: clean: (a -> b) [a] -> [b]
22:03:46 <kmc> weird
22:03:49 <elliott> at least that's what wikipedia claims
22:03:58 <elliott> (f . g) is (f o g) too, which must be great for obfuscated code :)
22:03:58 <kmc> can you always write  (a) b  instead of  a -> b ?
22:04:03 <kmc> or only when a is a function type
22:04:05 <edwardk> elliott: you can't nicely partially apply in clean so they aren't curried
22:04:09 <elliott> kmc: dunno
22:04:10 <ddarius> Yes, that mostly behaves the same as (a -> b) -> [a] -> [b] which is also valid Clean.
22:04:17 <kmc> what's the difference then
22:04:22 <elliott> edwardk: oh, so is (a -> b -> c) writable as (a b -> c) in Clean then?
22:04:27 <ddarius> Yes.
22:04:31 <elliott> Wikipedia I guess obscures the issue by implying it's about higher-order functions
22:04:42 <elliott> ...still, [x:xs] is an unforgivable cons syntax...
22:04:46 <ddarius> Which leads to a horrible ambiguity with type application.
22:04:52 <edwardk> elliott: it has to do with the fact that in clean, due to uniqueness typing, partial application isn't legal in some circumstances
22:05:01 <shachaf> elliott: Is [x|xs] unforgivable?
22:05:02 <elliott> edwardk: oh cool, it's like runST!
22:05:09 <min> elapsedTime has type Float -> Float -> [Float]. runtimeList has type [[Float]] -> [[Float]]. The expression (elapsedTime n m : runtimeList xs)  requires that runTimeList xs have type [[Float]]. But it doesn't, it has type [Float].
22:05:17 <elliott> shachaf: Well... That looks more like the xs is a different part, because | is about as tall as ][.
22:05:18 <elliott> [].
22:05:21 <companion_cube> shachaf: looks like prolog. erk
22:05:21 <elliott> So it's more forgivable.
22:05:22 <ddarius> There is also a difference in the operational behavior.
22:05:27 <elliott> [x:xs] definitely looks enclosed though.
22:05:40 <edwardk> elliott: i gave up on clean. i had one project where i was working with a nice quantum probability monad that would have made an awesome monad in clean, but… i can't define such a thing
22:05:51 <edwardk> the state of the tools is somewhat sad
22:06:02 <ddarius> They have Sparkle!
22:06:09 <edwardk> they had a parser, a maybe monad, and a few other things
22:06:13 <elliott> We should all just use Mercury. As far as I can tell, it's basically Haskell.
22:06:34 <ddarius> Talking to one former developer of Mercury, you don't want to use Mercury.
22:06:44 <edwardk> elliott: lets not
22:07:07 <companion_cube> would it totally break haskell if linear types were added?
22:07:10 <steakknife> speaking of tools, there have to be some fun hacks like a llvm css backend.
22:07:12 <elliott> My experience with Mercury was reading a tutorial, looking at the manual, noticing that basically every advanced Haskell type system feature is in there, and then being completely flabbergasted at the number of times it wanted to build its standard library.
22:07:17 <elliott> Took like 3 hours.
22:07:20 <ddarius> companion_cube: No, but it would be a huge change.
22:07:35 <companion_cube> could be interesting though
22:07:39 <elliott> ddarius: What's wrong with it, out of curiosity?
22:07:48 <ddarius> companion_cube: It would be useful.
22:07:52 <ddarius> It's useful in Clean.
22:08:01 * companion_cube wonders if it would still be a rewriting system then
22:08:25 <edwardk> companion_cube: lots of optimizations like lambda lifting/lowering have to be reconsidered once you add linear types to a language
22:08:32 <shachaf> @remember Jafet I didn't know what your question was so I answered the question that I liked
22:08:32 <lambdabot> Okay.
22:08:43 <tomprince> llvm css backend?
22:08:50 <ddarius> elliott: Some of the design decisions, like the way it does modes turn out to be a lot of tedium and complexity for negative gain.
22:09:11 <companion_cube> edwardk: but then you can gain new optimizations by mutating linear values
22:09:11 <edwardk> companion_cube: it really messes with your ability to write a lot of optimizations, work with closures, you get a lot of spooky action at a distance as to whether or not something typechecks based on those lollipops somewhere seemingly unrelated
22:09:22 <edwardk> companion_cube: yes. i really really wanted this at one point =)
22:09:31 <elliott> companion_cube: Why can't you just mutate an STRef or whatever the same?
22:09:38 <ddarius> Haskell isn't (trivially) a rewriting system now, nor would I see why uniqueness types would change this.
22:09:53 <elliott> The only thing I can think of when reading about linear typing stuff is "I can't wait to abstract this away into a monad!".
22:10:04 <edwardk> you can go further, you can add uniqueness linear, relevant, affine, all to the type system as a family of comonads, then the thunks on non-strict values become affine closures, etc.
22:10:19 <edwardk> i'll say this i'm not smart enough to program in the language that results
22:10:20 <companion_cube> ddarius: oh? I thought it was a rewriting system to rhnf
22:10:46 <elliott> edwardk: :D
22:10:57 <ddarius> More LolliMon!
22:11:02 <edwardk> elliott: i'm serious, my second thesis was based on doing just that!
22:11:05 <elliott> language design is just a race to a language so good nobody can use it
22:11:13 <ddarius> edwardk: Second thesis?
22:11:20 <edwardk> ddarius: for my c.s. masters
22:11:34 <ddarius> What was your other thesis for?
22:11:53 <companion_cube> so you did 2 thesis in a row?
22:11:57 <magn3ts> dmwit, can I PM you some code I can't/won't post here?
22:12:26 <edwardk> stabbing line problems, oriented projective geometry, updating plucker and study coordinates to talk about OPG, and realtime visible surface determination
22:12:28 <ddarius> Sequential composition would not be the optimal scheduling, silly companion_cube.
22:12:51 <edwardk> basically writing up crap i'd done 10 years prior to becoming an academic
22:12:53 <ddarius> edwardk: What degree was it for?
22:13:00 <edwardk> ddarius: m.a. in mathematics
22:13:40 <companion_cube> ddarius: writing a thesis seems like an operation that takes a big lock on one's brain
22:13:42 <edwardk> http://comonad.com/thesis.pdf was a preprint. that draft has errors around the 11th chapter
22:13:56 <companion_cube> (unless your brain supports concurrent runtime)
22:14:21 <steakknife> I approve all uses of stabbing.
22:14:56 <OracleOfHalting> Ypsilanti is an interesting name
22:15:04 <ddarius> Vote for steakknife at your next murder spree.
22:15:47 <burritochainsaw> vote for me, rather !
22:15:48 <steakknife> Not sure where that line is headed, but whatever.
22:15:49 <edwardk> OracleOfHalting: yeah
22:16:12 * ddarius didn't know edwardk's middle name.
22:16:20 <shachaf> I vote for ddarius in the library with the rope.
22:16:21 <edwardk> i have another version of that lying around somewhere written in geometric algebra terms which comes in closer to 25 pages
22:16:33 * burritochainsaw chainssaws shachaf 
22:16:50 <elliott> steakknife, burritochainsaw... it's a family of food-based murder weapons.
22:16:50 <steakknife> Complexification = wow + 1
22:16:52 <burritochainsaw> (in the kitchen with a chainsaw)
22:17:00 <ddarius> shachaf: I did just buy Ashley's book of knots.
22:17:03 <edwardk> ddarius: basically that was my spring break ;)
22:17:08 <steakknife> elliott feels left out i guess.
22:17:22 <burritochainsaw> he's not hungry
22:17:22 <ddarius> edwardk: I was hoping that was the CS thesis.
22:17:26 <steakknife> or a sharp pain, but who knows.
22:17:32 <elliott> Oh wait, those are actually new nicks.
22:17:38 <elliott> I thought it was just a wonderful coincidence.
22:17:42 <elliott> Disappointing.
22:18:00 <edwardk> ddarius: nah, that largely got killed. my advisor became dean and had no time to do anything let alone deal with his only student =/
22:18:06 * ddarius will refer to edwardk as eak from now on.
22:18:31 <edwardk> ddarius: amy is 'arr', so between the two we have a 2 word play.
22:18:49 <ddarius> You have two 2 word plays.
22:19:01 <ddarius> Or four, but the remainder would be a bit drudge.
22:19:07 <edwardk> 4 if we're willing to do more with one of the words
22:19:07 <steakknife> i have a half-eaten steak burrito next to me if it's any irony.
22:19:08 <edwardk> yeah
22:19:31 <elliott> steakknife: And a knife chainsaw?
22:19:32 <edwardk> did you cut it with a knife?
22:19:40 <ddarius> or a chainsaw.
22:19:54 <steakknife> it's a burritto
22:19:58 <elliott> A knife chainsaw sounds like it has very few practical purposes other than murder.
22:20:01 * burritochainsaw does not have a burrito, sadly
22:20:11 <ddarius> Me neither.
22:20:18 <ddarius> I can't even get a steak burrito if I wanted to.
22:20:20 * steakknife shares
22:20:31 <edwardk> steakknife: well if it was one of those cheap knockoff burritos that ddarius likes you might need a knife, chainsaw, jackhammer or what have you get get it down your gullet
22:20:37 <steakknife> female unit forbids?
22:20:51 <mm_freak> uh…  haddock seems to have a huge problem with prefix type operators
22:20:54 <dmwit> magn3ts: I guess.
22:21:26 <steakknife> ddarius: see $ previous
22:21:38 <edwardk> haddock has a problem with something that isn't bog standard syntax? say it ain't so!
22:21:56 * ddarius wonders if there are a lot of bogs in Michigan.
22:22:06 <kmc> frozen burrito?
22:22:21 <edwardk> i fell into one when i was 6, so, there is at least one ;)
22:22:44 <magn3ts> dmwit, I'm still making progress on it :S
22:22:53 <shachaf> edwardk: Do you originate from "Redford, MI"?
22:22:59 <dmwit> magn3ts: Great.
22:23:01 <burritochainsaw> so, i don't really feel like chainsawing burritos right now, undo()
22:23:03 <edwardk> shachaf: more or less
22:23:20 <edwardk> shachaf: did you find one of those people finder sites?
22:23:49 <shachaf> companion_cube: The transaction is committed, you can't undo now.
22:24:05 <elliott> edwardk: shachaf is actually just omniscient.
22:24:07 <shachaf> edwardk: I was looking for your age, actually, but it came up.
22:24:16 * shachaf was previously asked.
22:24:31 * edwardk counts on his hands, and feet and hands and feet again…. 36
22:24:40 <companion_cube> shachaf: nested transactions :]
22:25:26 <elliott> edwardk is an octopus. You heard it here first.
22:26:05 <shachaf> Octopuses can count to 36?
22:26:11 <shachaf> I didn't think they had fingers.
22:26:32 <ddarius> They don't, but they're pretty intelligent.
22:26:39 <companion_cube> with 8 tentacles, they should be able to count up to 31
22:26:46 <ddarius> Or so the idiot box has whispered to me upon occasion.
22:26:55 <companion_cube> err, 255
22:27:14 <elliott> edwardk will live to 255 years old and then the unsigned char will overflow.
22:27:17 <monochrom> wait, then I can count to 2047...
22:27:18 <elliott> That is the way of the octopus.
22:27:19 <shachaf> Is the idiot box a box that turns you into an idiot?
22:27:30 <ddarius> shachaf: Yes.
22:27:30 <steakknife> angle division multiplexing, count to 1024. :)
22:27:32 <edwardk> companion_cube: assuming they aren't smart enough to discover that they can count the way its bent as more than 2 alternatives and don't move to a larger radix
22:27:43 <shachaf> ddarius: I wouldn't trust anything it says, in that case.
22:27:48 <ddarius> shachaf: It also stores idiots inside of it.
22:27:56 <edwardk> elliott: that'll do. that should carry me to the singularity. then i'll rely on a hardware upgrade
22:28:02 <shachaf> On the other hand, maybe it tries to get you to stop thinking for yourself by conveniently providing facts whenever necessary.
22:28:09 <monochrom> http://creatroninc.com/contact/  note the cool street number!
22:28:16 <elliott> edwardk: You're an /octopus/. You don't /count/.
22:28:30 <elliott> You don't even have _fingers_!
22:28:33 <elliott> HAHAHAHAHA okay I have to stop myself.
22:28:44 <shachaf> elliott mad
22:28:48 <ddarius> concur
22:30:11 <monochrom> elliottt: you are a teapot...
22:30:26 <shachaf> monochrom: Where did elliottt get into this?
22:30:38 <ddarius> monochrom is tist.
22:30:44 <monochrom> where? in #haskell, that's where
22:31:20 <monochrom> but anyway I'm betting on elliottt being mad, so I tell him he's a teapot, want to see more madness
22:31:36 <shachaf> Who said elliottt was mad?
22:31:38 <shachaf> I guess you did.
22:31:45 <monochrom> next thing I may try is "you're e^x"
22:32:49 <shachaf> We need to organize the "get Cale out of Canada" initiative.
22:32:49 <steakknife> identity issues, interesting.
22:33:06 <monochrom> why out of canada?
22:33:19 <shachaf> Just temporarily.
22:33:20 * ddarius moves Cale to Brazil.
22:33:24 <shachaf> To go to Hac Boston, for instance.
22:33:33 <ddarius> HacBoston is in Brazil?
22:33:37 <ddarius> That would be sweet!
22:33:41 <monochrom> canada is actually a safe place
22:33:43 <shachaf> That reminds me that I was told I should watch the movie _Brazil_.
22:33:54 <ddarius> I watched that very recently.
22:34:18 <companion_cube> it's excellent.
22:34:41 <monochrom> the us is already pretty safe after you pass us custom, but us custom is about the most unsafe place
22:34:55 * ddarius infers that monochrom hasn't been to the US.
22:35:12 <monochrom> I have been to the us
22:35:20 * ddarius pats his shotgun.
22:35:27 <shachaf> monochrom: Are you going to Hac Boston?
22:35:32 <monochrom> no
22:35:34 <OracleOfHalting> YES
22:36:02 <shachaf> Hey, monochrom `(==) \`on\` approximateGeographicLocation` Cale.
22:36:08 <steakknife> I swear managing staff offshore is like the ministry of information.
22:36:38 <NeedDerivative> hi there, please i need help with a program that derives, could someone please help me?
22:36:57 <monochrom> what does that mean?
22:36:58 <edwardk> we still have several slots open for hac boston
22:37:01 <shachaf> monochrom: Now's the chance for your e^x to shine!
22:37:02 <ddarius> NeedDerivative: Throw it away and use one of the existing libraries.
22:37:07 <monochrom> tee hee hee!
22:37:09 <shachaf> edwardk: Wait, the number of slots is limited?
22:37:18 <steakknife> x = i * pi
22:37:18 <edwardk> shachaf: we have confirmed room for ~40 people
22:37:29 <kmc> NeedDerivative, don't ask to ask, just ask
22:37:33 * ddarius thought it was 30.
22:37:33 <shachaf> edwardk: How can I defer my decision until the last minute this way?
22:37:36 <dmwit> NeedDerivative: What have you tried, and where does that do something you didn't expect?
22:37:37 <kmc> NeedDerivative, put your code on hpaste.org along with a description of the problem
22:37:45 <ddarius> shachaf: Crash HacBoston.
22:37:48 <kmc> edwardk, do you know which room at MIT will have us?
22:37:49 <edwardk> shachaf: beyond that we'll need to figure out how to split between rooms, get more facilities, figure out how to feed all you people, etc.
22:38:01 <edwardk> kmc: not yet, we're not likely to know until relatively close to the event
22:38:04 <shachaf> ddarius: Oh, man, that's, like, radical, dude.
22:38:07 <kmc> ok
22:38:18 * shachaf intercalate ", "
22:38:22 <ddarius> EOUTOFCOMMA
22:38:23 <companion_cube> edwardk: if there are too many people, you're going to have to solve pigeonhole (at the type level)
22:38:30 <NeedDerivative> i tried to do the program on Java, but was soo long and then my teacher send me to a functional one
22:38:55 <Axman6> NeedDerivative: we can't help you unless we know what your problem is
22:39:06 <steakknife> rsvping is a good idea in light of what it takes to put on an event.
22:39:08 * ddarius helped without knowing wha the problem is.
22:39:11 <NeedDerivative> parsing expressions
22:39:20 <NeedDerivative> is easier in haskell?
22:39:29 <kmc> it's harder if you don't know Haskell :)
22:39:36 <kmc> it will take you a long time to learn the language
22:39:38 <dmwit> It turned out ddarius didn't help, because NeedDerivative hadn't even gotten to the math part yet.
22:39:40 <kmc> it is very different from Java
22:40:04 <kmc> anyway you should show us the code you have and any description of what's going wrong
22:40:11 * ddarius makes an EDSL to embed Java into Haskell.
22:40:14 <kmc> or ask a more specific question
22:40:20 <shachaf> Haskell is a lot like Java except with a dwim() operator for parsing.
22:40:21 <shachaf> Please disregard previous message.
22:40:33 <kmc> shachaf is a lot like a troll except
22:40:45 <companion_cube> ddarius: SingletonFactoryFactoryMonad?
22:40:47 <shachaf> kmc: Is that an empty set? :-(
22:40:56 <monochrom> ... except lambdabot doesn't slape shachaf
22:41:00 <shachaf> It's true.
22:41:02 <monochrom> s/slape/slap/
22:41:06 <kmc> @slape shachaf
22:41:07 * lambdabot will count to five...
22:41:26 <monochrom> ho hum, I swear I tried three times in vain
22:41:30 <companion_cube> > dropWhile (< 5) [1..5]
22:41:31 <lambdabot>   [5]
22:41:35 <ddarius> @snape shachaf
22:41:35 * lambdabot puts on her slapping gloves, and slaps shachaf
22:41:35 <shachaf> monochrom: That wasn't actually slapping.
22:41:39 * shachaf sighs.
22:41:42 <shachaf> It was a good run.
22:42:05 <shachaf> lambdabot doesn't slap me. That's robotics law number 2.
22:42:12 <shachaf> Law number 1 is that lambdabot does what ddarius says.
22:42:19 <kmc> @slape shachaf
22:42:20 * lambdabot secretly deletes shachaf's source code
22:42:24 <monochrom> what about law number 0?
22:42:37 <ddarius> Law number 0 is that laws are 1-indexed.
22:42:42 <shachaf> Law number 0 is that lambdabot starts -- yes.
22:42:43 <monochrom> hahahaha ok!
22:43:38 <steakknife> That would be good except that the number system was redefined.
22:44:14 <companion_cube> what if we were in a non-standard model of arithmetic?
22:44:21 <dmwit> ?remember ddarius Law number 0 is that laws are 1-indexed.
22:44:21 <lambdabot> Done.
22:44:46 <steakknife> Tensor type system.
22:45:48 <monochrom> "the phantom of the type system is there, inside my mind"
22:46:07 <steakknife> Skip multidimensional types and go straight types that can express general relativity.
22:46:25 <monochrom> haha
22:46:45 <monochrom> @remember steakknife Skip multidimensional types and go straight types that can express general relativity.
22:46:46 <lambdabot> It is forever etched in my memory.
22:49:32 <edwardk> steakknife: those are multidimensional types, you are just in a quadratic space with non-zero isotropic vectors
22:50:08 <steakknife> help i'm in quadratic space.  where are my eigenvectors?
22:50:41 <steakknife> : )
22:50:43 <edwardk> if you're in a convex region you can fake em, and if not, then change the problem =)
22:51:09 <steakknife> invent a few more dimensions seems to be the solution, at least probably
22:51:21 <companion_cube> in quadratic space, no one can hear you screaming²
22:51:21 <a215> > Just Nothing
22:51:22 <lambdabot>   Just Nothing
22:51:28 <steakknife> want graphics, bust out quaternions.
22:51:42 <edwardk> that just makes it so you swim in the extra dimensions why you try to optimize
22:51:49 <Zamarok> "Learn You A Haskell" mentions Data.Set.setNub, but I can't find that this function actually exists...
22:51:55 <steakknife> the screaming echoes in imaginary time along 2 dimensions
22:52:10 <kmc> Zamarok, to remove the duplicate elements from a set?
22:52:25 <kmc> Zamarok, Sets already have no duplicate elements
22:52:36 <kmc> maybe you want (Set.toList . Set.fromList)
22:52:41 <a215> what's that site with the programming problems?
22:52:42 <Zamarok> From a list. Data.List.nub works, but read this http://learnyouahaskell.com/modules
22:52:44 <edwardk> Zamarok: you can go back and forth like… ah kmc got it
22:52:50 <a215> programming/math
22:52:51 <steakknife> I hear yelling works.  The elements get awkwardly frightened and run away.
22:52:51 <Zamarok> ctrl+f "setNub"
22:53:00 <a215> should be someone's first guess
22:53:07 <edwardk> especially when you are a steakknife
22:53:18 <Zamarok> They claim that setNub is faster than nub, and does the same thing but does not perserve order... I can't even find setNub O_o
22:53:22 <steakknife> steakknife chainsaw burritto
22:53:34 <Zamarok> a215: projecteuler.net
22:53:37 <kmc> Zamarok, is it in the online edition?
22:53:38 <a215> ahh yes
22:53:40 <edwardk> Zamarok:    write setNub = Data.Set.toList  . Data.Set.fromList
22:53:40 <steakknife> whatever that looks like.
22:53:45 <a215> thought it was euclid
22:54:09 <Zamarok> edwardk: ahh ok, they renamed it I guess.
22:54:11 <edwardk> Zamarok: its just taking your list, building a set out of it, then turning it back into a list
22:54:22 <monochrom> "ghci> let setNub xs = Set.toList $ Set.fromList xs" right on that page
22:54:26 <edwardk> Zamarok: i don't think it was ever there
22:54:40 <edwardk> he defined it above on the page
22:54:41 <Zamarok> I just need a list without duplicates. it's for a projecteuler problem actually. I already solved it, but I'm researching optimizations
22:55:05 <kmc> speaking of ctrl+f
22:55:34 <Zamarok> edwardk: lol.. any idea wtf it is doing in the LYAH book?
22:55:49 <Zamarok> edwardk: Oh ok, I see, I didn't notice that
22:55:50 <edwardk> Zamarok: look on the page in question, he defines it inline
22:55:57 <Cale> Zamarok: You could also try  map head . group . sort
22:56:19 <Cale> which I recall being marginally faster than converting back and forth from Set
22:56:31 <ddarius> First erroneous expectation of #haskell: people read.
22:56:36 <Zamarok> hmm that's an interesting idea
22:56:39 <companion_cube> not sure, you pay the sort + the group
22:57:14 <Cale> (ddarius: Was that already suggested? I haven't been following closely and just popped in)
22:57:20 <Zamarok> I guess it depends on how many things need sorting. Mine will be completely out of order
22:57:32 <kmc> ddarius, or people who mention ctrl+f have tried it themselves
22:57:56 <ddarius> reverse
22:58:02 <Cale> You can also implement nub on ordered things such that it preserves the ordering of the original list, but is similarly efficient to going via Set
22:58:25 <a215> > [ i | i <- [1..1000], i `mod` 3 == 0 || i `mod `5 == 0]
22:58:26 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
22:58:30 <Cale> (simply build a Set as you traverse the list, doing lookups to see if you've seen those elements before)
22:58:31 <a215> mmnn yes
22:58:32 <steakknife> Statistically, the most difficult problem is apparently Largest Roots of Cubic Polynomials.
22:58:41 <monochrom> no, Cale, the irony is this: the person who tell you to go to a page and ctrl-f for a word, is the one who can't find the word
22:58:56 <Cale> heh
22:58:59 <a215> > sum [ i | i <- [1..1000], i `mod` 3 == 0 || i `mod `5 == 0]
22:59:00 <lambdabot>   234168
22:59:01 <Zamarok> Cale: I just need one of each integer. I'm summing a set of numbers. Fast as possible. It's already solved, but 6 seconds is too long I think
22:59:16 <kmc> Zamarok, you're compiling your code with ghc -O2?
22:59:23 <Zamarok> yep
22:59:34 <Zamarok> well, -O
22:59:38 <a215> can someone explain to me... what's it called
22:59:39 <Zamarok> sometimes I try -O2
22:59:41 <a215> big O notation?
22:59:41 <steakknife> There should be a direct formula.
22:59:44 <kmc> okay, -O is usually close enough
22:59:47 <steakknife> Think about it.
22:59:58 <steakknife> O(1)
23:00:10 <Zamarok> I do samples with +RTS -sstderr and compare efficiency
23:00:13 <kmc> a215, not really a Haskell question.  try http://en.wikipedia.org/wiki/Big_O_notation and http://en.wikipedia.org/wiki/Asymptotic_analysis
23:00:18 <kmc> a215, better yet, try an algorithms textbook
23:00:26 <companion_cube> Zamarok: you should work directly with sets, not lists
23:00:26 * a215 reads it
23:00:48 <a215> oh yeah this is simple
23:00:52 <kmc> a215, most programmers misuse asymptotic complexity arguments as a way to avoid actually testing their code's speed
23:00:52 <Jafet> O(1) program runs
23:01:14 <a215> i test speed with cpu time :P
23:01:17 <Zamarok> companion_cube: I am filtering lists of numbers in a list comprehension with a few predicates.. is that not the fastest way?
23:01:28 <a215> and thinking as much as possible.. about what's actually happening
23:01:28 <steakknife> Most programmers prematurely optimize in areas that don't matter also.
23:01:29 <kmc> theoretical asymptotic complexity is often irrelevant
23:01:51 <companion_cube> Zamarok: i don't think it is faster than writing filter . map
23:01:57 <kmc> especially once you go below O(n)
23:02:07 <companion_cube> but truly, lit comprehensions are nice for expressiveness
23:02:17 <steakknife> Get millions of users, then optimize.
23:02:31 <companion_cube> like facebook with php
23:02:36 <companion_cube> oh, wait :]
23:02:37 <a215> lol
23:02:46 <Jafet> steakknife: sleep(0.05)
23:02:46 <steakknife> Hiphop
23:02:49 <kmc> this is a sore topic here because people are always complaining about the difference between O(1) hash tables in their favorite imperative language and O(log n) functional maps
23:02:51 <ddarius> Get millions of users, then sell their information.
23:02:52 <kmc> without actually testing it
23:02:56 <Jafet> Optimizing for users
23:03:11 <kmc> (also there are functional tree-shaped structures which are just as "O(1)" as hash tables, but they're not well-known)
23:03:25 <a215> what's that kmc
23:03:26 <steakknife> When you have to scale to offshore, you're not going to expect shakespeare in haskell unless you get enough bananas.
23:03:29 <a215> b trees?
23:03:33 <companion_cube> kmc: hash tries ?
23:03:41 <a215> lol
23:03:46 <kmc> yeah like hash tries
23:04:10 <steakknife> Try Christmas trees.
23:04:16 <blackdog> kmc: hash tables are only O(1) expected/asymptotic, right?
23:04:28 <kmc> O(_) typically means asymptotic, yes
23:04:45 <kmc> you should care about this stuff in mainstream imperative languages too, because persistent immutable structures are way the hell easier to use concurrently
23:04:46 <scshunt> it's an omicron
23:04:53 * ddarius thought O(_) meant beer stein.
23:05:13 <Axman6> isn't that (_)D?
23:05:14 <steakknife> It's empty, darn.
23:05:22 <kmc> hash tables definitely are not O(1) because it's physically impossible to address an arbitrary amount of memory with constant resources
23:05:26 <Axman6> full (~)D
23:05:40 <steakknife> Half full or half empty? :)
23:05:44 <Jafet> Each hash table operation takes O(1) hash table operations
23:05:49 <steakknife> It looks like half on my font. ;)
23:06:04 <companion_cube> kmc: but memory management for persistent structures is also harder
23:06:17 <c_wraith> Jafet: let me tell you about my new TSP solution.
23:06:21 <kmc> companion_cube, how so?
23:06:29 <Zamarok> companion_cube: [ x*y | x <- [1..10^4], y <- [1..10^3], myPredicate x y ]
23:06:41 <Daegalus> is there a simple way to do breakpoint debugging without having to setup workspaces/packages (I tried leksah). Just need to debug a small file.
23:06:50 <ddarius> Luckily, we have a finite amount of memory.  We can even bound the amount of memory for any computer by a constant.
23:06:50 <ddarius> Moral of the story, everything is O(1).
23:06:51 <Zamarok> companion_cube: that's what I'm doing.. I can do that directly to a set, rather than like that, you say?
23:06:56 <Jafet> c_wraith: only if it uses fewer than O(1) non-deterministic Turing machine runs.
23:07:02 <ddarius> Daegalus: Use the debugger in GHCi.
23:07:12 <companion_cube> Zamarok: no, list comprehensions only work for lists
23:07:23 <companion_cube> but you may convert it to a set afterwards
23:07:47 <Zamarok> I see.. in the process of that now
23:07:51 <companion_cube> kmc: most persistent data structures are trees, and persistence comes from partial structure sharing
23:07:56 <Daegalus> ddarius: i looked that up and tried doing ":break add Main 23" to add a breakpoint to line 23 but it started complaining about "Add" not being in scope or something
23:08:09 <companion_cube> so if you're doing manual memory management, you're gonna have to use refcouting
23:08:10 <steakknife> lambdabot apparently has an infinite amount of memory. ;)
23:08:30 <kmc> companion_cube, sure, I said "mainstream imperative languages" not "C and C++"
23:08:39 <kmc> mainstream imperative languages have automatic memory management
23:08:42 <kmc> for the most part
23:08:51 * companion_cube thought C was mainstream
23:08:51 <qop2> what was the name of this site that shows coding examples in many languages....?
23:08:58 <ddarius> "the most part" being the ones that aren't C and C++.
23:08:59 <companion_cube> qop2: wikipedia
23:09:01 <kmc> we should stop pretending that any idea which doesn't work in C is totally untenable
23:09:03 <steakknife> it was, like Perl.
23:09:08 <qop2> companion_cube: no
23:09:10 <kmc> qop2, rosetta code?
23:09:15 <Axman6> qop2: rosettacode?
23:09:17 <qop2> kmc: thanks :)
23:09:23 <qop2> Axman6: aye forgot
23:09:39 <kmc> companion_cube, also tons of C and C++ projects use refcounting
23:09:55 <kmc> in C++ with the right libraries it is nearly as convenient as garbage collection
23:10:01 <monochrom> C used to be mainstream
23:10:03 <ddarius> Many use garbage collection.
23:10:33 <companion_cube> kmc: ok :)
23:10:41 <companion_cube> (but in C it remains hard)
23:10:44 <kmc> sure
23:10:48 <kmc> like everything else in C
23:10:50 * qop2 is always amazed by the amount of zealotry that programming language discussions bring up
23:11:10 <monochrom> @quote monochrom religion
23:11:11 <lambdabot> No quotes match. Are you on drugs?
23:11:15 <kmc> qop2, you're amazed that people who use these tools have opinions on which ones are better than others?
23:11:28 <steakknife> There needs to be a good crusade every now and then.
23:11:28 <kmc> sure it's easy to dismiss as "zealotry"
23:11:39 * ddarius is always amazed by the amount of metadiscussion that programmer's have.
23:11:40 <a215> wee
23:11:41 <steakknife> Heads on spikes.
23:11:43 <a215> i built an isPrime function
23:11:47 <a215> now... all i have to do is...
23:11:55 <monochrom> erase it
23:12:05 <ddarius> -'
23:12:11 <qop2> kmc: I talk of when people say THAT other language is garbage because of (insert here rationalizations and selective examples)
23:12:13 <companion_cube> map it
23:12:22 <steakknife> ddarius: anything to avoid actual labor.
23:12:42 <ddarius> steakknife: We're already programmers.  I think we've successfully avoid any actual labor.
23:12:47 <a215> > [i | i <- [1..], isPrime i] !! 10001
23:12:51 <qop2> especially when that somebody knows nothing about that -other- language... when clearly there are up and downs for everything
23:12:51 <lambdabot>   mueval-core: Time limit exceeded
23:12:51 <kmc> qop2, sure, sometimes it's that, and sometimes they're having a rational discussion about the advantages and disadvantages of various systems
23:12:52 <companion_cube> qop2: <your favorite language> is garbage. Example: <the last thing you had trouble to code>
23:12:53 <a215> damn!
23:12:58 <a215> would that work otherwise
23:13:04 <qop2> kmc: yes
23:13:05 <a215> > [i | i <- [1..], isPrime i] !! 5
23:13:09 <lambdabot>   mueval-core: Time limit exceeded
23:13:11 <a215> i guess not
23:13:13 <steakknife> ddarius: Not if we can get some shmoe to think for us, because well, that's also work.
23:13:17 <qop2> companion_cube: hehe yes
23:13:26 <a215> how do i get the nth item of that infinite list
23:13:28 <kmc> qop2, you can get anyone to agree with platitudes like "use the right tool for the job"
23:13:40 <qop2> kmc: I was talking in general not about what you wre saing :P
23:13:47 <ddarius> "use the right platitude for the job"
23:13:56 * monochrom has grown out of "use the right tool for the job", too
23:13:57 <kmc> @remember ddarius "use the right platitude for the job"
23:13:57 <lambdabot> It is forever etched in my memory.
23:13:57 <companion_cube> kmc: so you believe C isn't the right tool for any job?
23:14:03 <kmc> companion_cube, did i say that?
23:14:06 <qop2> just recalled because lots of c++ guys are extreme zealots
23:14:16 <kmc> qop2, i think you're a c++-guys-are-zealots zealot
23:14:17 <kmc> what now
23:14:31 <kmc> companion_cube, so you believe kittens should be fed into wood chippers?
23:14:40 <qop2> are you trolling me? because it feels like it
23:14:42 <steakknife> Anyone that says "X is Y" is Z.
23:14:46 <ddarius> kmc: Only at puberty.
23:14:50 <companion_cube> kmc: if I knew what wood chippers were, I would probably :)
23:15:17 <a215> > isPrime 17
23:15:19 <lambdabot>   False
23:15:20 <companion_cube> steakknife: if I replace Z by f(X), I can refute your argument by occur check.
23:15:23 <a215> :/
23:15:34 <a215> back to the drawing board
23:15:40 <Saizan> monochrom: decided there's no right tool?
23:15:45 <ddarius> companion_cube: You are missing the difference between syntax and semantics.
23:15:59 <monochrom> no, decided it says nothing
23:15:59 <magn3ts> This awesome TA? Just spent 45 mins finding out that he can't fucking keep units straight.
23:16:03 <magn3ts> Gives us km/h
23:16:31 <kmc> companion_cube, if you want to know what I actually think instead of putting words in my mouth: I think C is a terrible choice for most ordinary applications development.  it's one of the best tools we have for certain specialized things like embedded systems, low layers of operating systems, and exceptionally high-performance code
23:16:32 <companion_cube> ddarius: hmm, i neglected the ""
23:16:32 <Saizan> yep. that's how i see it too
23:16:44 <kmc> it's still a flawed tool for those things and could be better
23:16:52 <kmc> but it's not such a bad language if you actually use it for those things
23:17:03 <companion_cube> ok, i totally agree with you then
23:17:05 <qop2> there are better options than C for embedded
23:17:27 <companion_cube> (since I'm using it for one of those use cases)
23:17:38 <kmc> i'm mostly annoyed at the people who write an IRC client in C, so that it could handle 10 million messages per second, and introduce a humongous security hole through some tiny mistake in string processing
23:17:39 <Axman6> qop2: like Ada
23:17:45 <qop2> also low layers and exceptional performance
23:17:54 <ddarius> "I use the right tool for the job.  My tool is the right tool for every job."
23:17:59 <qop2> Axman6: in that case yes
23:18:00 <kmc> the same people will tell you again and again that Real Programmers don't make mistakes
23:18:16 <kmc> and if you use a language other than C then you have a small penis
23:18:28 <a215> not making mistakes in programming is a matter of zen
23:18:34 <steakknife> security | safety <- - - -> speed | usability
23:18:38 <monochrom> "survival of the fittest"  (hint: define "fittest"... um, those who survive?)
23:18:39 <kmc> zen eh
23:18:42 <qop2> and for the performance part depends what level we are talking about
23:18:43 <ddarius> The code is the specification.  There are no errors.
23:18:44 <companion_cube> using C for string processing is just absurd
23:18:48 <companion_cube> unless you write grep
23:18:51 <a215> i'm about to have a limit break you guys
23:18:58 <kmc> companion_cube, too bad most programming has string processing.  even much of the Linux kernel is string processing
23:19:08 <steakknife> a215: and sufficient regression testing and code coverage.
23:19:16 <Cale> monochrom: survival of the surviviest
23:19:31 <qop2> survival of the noisy?
23:19:49 <a215> http://images2.wikia.nocookie.net/__cb20080919145708/finalfantasy/images/4/40/FFVII_Limit_Break_Red_XIII_Lunatichigh.jpg lol
23:19:52 <a215> > isPrime 12
23:19:53 <lambdabot>   False
23:19:57 <a215> > isPrime 13
23:19:59 <lambdabot>   False
23:20:08 <kmc> > map isPrime [2..]
23:20:10 * ddarius goes to find food.
23:20:10 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
23:20:14 <companion_cube> kmc: lots of hgh performance programs have as little string processing as "parse a problem in some format and print yes/no"
23:20:26 <a215> mmn...that would do it
23:20:31 <Cale> cool isPrime bro
23:20:35 <steakknife> wow, that's efficient.
23:20:40 <shachaf> Cale: So did you end up deciding to go to Hac Boston?
23:20:41 <steakknife> lol
23:20:43 <a215> solves the problem forever
23:20:53 <a215> how do i unset lambdabot again
23:20:53 <companion_cube> isPrime = (== 2) ? nice
23:20:57 <steakknife> isPrime /= story
23:20:59 <Axman6> > take 10 $ filter isPrime [1..]
23:21:03 <lambdabot>   mueval-core: Time limit exceeded
23:21:20 <magn3ts> Despite the TA fucking me over in more ways than one, this assignment is a custom sort away from being done =D
23:21:22 <a215> it was...  @set isPrime x = (length [ i| i <- [2..x], (x `mod` i) /= 0]) == 0
23:21:32 <Saizan> @undefine
23:21:41 <steakknife> > print "brogramming"
23:21:42 <lambdabot>   <IO ()>
23:21:49 <a215> let me see
23:21:55 <a215> it was...  @set isPrime x = (length [ x| i <- [2..x], (x `mod` i) /= 0]) == 0
23:21:59 <a215> @set isPrime x = (length [ x| i <- [2..x], (x `mod` i) /= 0]) == 0
23:21:59 <Cale> shachaf: I didn't decide against deciding not to go
23:22:00 <lambdabot>  Defined.
23:22:05 <steakknife> Too cool to show stdout, makes sense.
23:22:05 <a215> > map isPrime [1..20]
23:22:07 <lambdabot>   [True,True,False,False,False,False,False,False,False,False,False,False,Fals...
23:22:11 <a215> close enough
23:22:22 <kmc> > filter isPrime [1..20]
23:22:24 <steakknife> Secret monad society.
23:22:24 <lambdabot>   [1,2]
23:22:26 <a215> @undefine
23:22:43 <shachaf> Cale: Does that mean you decided not to go? Or just haven't decided?
23:22:49 <shachaf> You don't sound very decisive.
23:22:49 <ddarius> > putStr "<IO ()>" -- works for me
23:22:50 <lambdabot>   <IO ()>
23:22:54 <Cale> Haven't decided
23:23:10 <kmc> it's not "not showing stdout" it's "not executing IO actions"
23:23:12 <shachaf> Well, I have it on reliable authority that it would be sweet if you went.
23:23:21 <ddarius> Cale will raise the hair to person ratio.
23:23:22 <monochrom> Cale is saying (Go->False)->False in intuitionistic logic
23:23:44 <steakknife> invoke /= curry
23:23:46 <companion_cube> ¬¬go :/
23:23:49 <a215> > ([ 20| i <- [2..20], (20 `mod` i) /= 0])
23:23:50 <lambdabot>   [20,20,20,20,20,20,20,20,20,20,20,20,20,20]
23:23:55 * shachaf used to have a lot of hair.
23:24:25 <steakknife> Chicks dig baldies.
23:24:26 <shachaf> I shaved my head ~3 months before I visited Boston.
23:25:12 <a215> oh yes
23:25:13 <a215> @set isPrime x = (length ([ i| i <- [2..x], (x `mod` i) == 0]) == 0)
23:25:14 <lambdabot>  Defined.
23:25:21 * edwardk considers saying "I shaved my head ~3 months before I visited Boston", but I don't think you'd believe me
23:25:26 <a215> > filter isPrime [1..100]
23:25:28 <lambdabot>   [1]
23:25:40 <a215> sigh
23:25:46 <a215> too tired for this
23:25:54 <steakknife> If you need a shave, let me know.
23:26:02 <monochrom> hahahaha
23:26:11 <edwardk> hah
23:26:25 <monochrom> steakknife shaves you like it shaves roast beef
23:26:41 <companion_cube> ie, bleeding?
23:26:50 <monochrom> ie yummy!
23:26:58 <steakknife> Hey, I might be an inanimate object but still a dude.
23:27:08 * hackagebot haskell-src 1.0.1.5 - Support for manipulating Haskell source code  http://hackage.haskell.org/package/haskell-src-1.0.1.5 (ConradParker)
23:27:19 <steakknife> Nawh, surgical steel.
23:27:28 <shachaf> edwardk: When did you visit Boston?
23:27:44 <edwardk> =P
23:28:07 <edwardk> When I came back from California where I belong, obviously
23:31:09 <edwardk> oh nice.
23:31:09 <edwardk>   (GHC version 7.3.20111017 for x86_64-apple-darwin):
23:31:09 <edwardk> 	cgLookupPanic (probably invalid Core; try -dcore-lint)
23:31:20 <edwardk> now to figure out what the hell i broke
23:32:04 <a215> > filter isPrime [1..1000]
23:32:06 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:32:10 <a215> ah
23:32:15 <a215> dumb
23:32:45 <shachaf> @let isn'tPrime = not . isPrime
23:32:46 <lambdabot>  Defined.
23:32:55 <kmc> > filter odd [1..]
23:32:56 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:33:12 <a215> > (map isPrime [1..]) !! 10001
23:33:14 <lambdabot>   False
23:33:20 <a215> what?
23:33:23 <kmc> > isPrime 10001
23:33:25 <lambdabot>   False
23:33:27 <shachaf> > nubBy(((>1).).gcd)[2..]
23:33:29 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
23:33:37 <companion_cube> > head . filter even . map isPrime [1..]
23:33:38 <lambdabot>   Couldn't match expected type `[a]'
23:33:39 <lambdabot>         against inferred type `GHC.Bool....
23:33:51 <monochrom> need $
23:33:52 <a215> how do you get the nth element of a list
23:33:57 <companion_cube> > head . filter even . filter isPrime [1..]
23:33:58 <lambdabot>   No instance for (GHC.Real.Integral [a])
23:33:59 <lambdabot>    arising from a use of `e_11' at ...
23:34:01 <kmc> a215,  x !! n
23:34:08 <kmc> a215, but lists aren't intended for that kind of use
23:34:12 <a215> oh dumb
23:34:15 <a215> didn't realize what i did
23:34:24 <kmc> they're linked lists, so you have to traverse the elements one by one
23:34:30 <monochrom> 10001 = 73 * 137
23:34:37 <a215> > (filter isPrime [1..]) !! 10001
23:34:41 <a215> too slow
23:34:41 <lambdabot>   mueval-core: Time limit exceeded
23:34:52 <a215> so how do i find the 10001st
23:35:05 <kmc> you should write an expression for a list of all primes
23:35:12 <earthy> a215: drop 10001 . filter isPrime $ [1..]
23:35:13 <kmc> start with that, not with a primality test
23:35:15 <monochrom> use a faster computer or a faster algorithm or wait more time
23:35:25 <a215> > drop 10001 . filter isPrime $ [1..]
23:35:29 <lambdabot>   mueval-core: Time limit exceeded
23:35:33 * earthy gins
23:35:35 <earthy> grins
23:35:39 <kmc> > nubBy(((>1).).gcd)[2..] !! 10001
23:35:43 <lambdabot>   mueval-core: Time limit exceeded
23:36:01 <edwardk> yay! the revision monad works
23:36:05 <copumpkin> edwardk: whee!
23:36:15 <copumpkin> edwardk: what will you revise?
23:36:17 <edwardk> vmodify was scary
23:36:21 <shachaf> Whoa, man, it's earthy.
23:36:23 <kmc> the nubBy sieve is really slow too
23:36:31 <shachaf> Are you the same earthy as the person who was here a few years ago?
23:36:39 <a215> haskell docs are annoying
23:36:42 <copumpkin> shachaf: wait, you were here a few years ago?
23:36:55 <edwardk> https://github.com/ekmett/revisions/blob/master/Control/Concurrent/Revision.hs#L129
23:36:59 <shachaf> copumpkin: "years" is an estimate, probably distorted.
23:37:06 <a215> what does nubby do
23:37:13 <copumpkin> edwardk: wow
23:37:17 <kmc> @hoogle nubBy
23:37:18 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
23:37:19 <Maxdamantus> Is there such a concept somewhere of a "random type" or something?
23:37:25 <a215> i saw the type already
23:37:29 <kmc> a215, then you go to http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
23:37:29 <edwardk> thats the shorter version
23:37:31 <kmc> and look up Data.List
23:37:39 <edwardk> when it was using unboxing rather than cps it was worse
23:37:39 <copumpkin> edwardk: I guess there are some recurring patterns in there
23:37:44 <earthy> @src nubBy
23:37:44 <lambdabot> nubBy eq []             =  []
23:37:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:37:48 <kmc> "O(n^2). The nub function removes duplicate elements from a list. In particular, it keeps only the first occurrence of each element. (The name nub means `essence'.) It is a special case of nubBy, which allows the programmer to supply their own equality test."
23:37:48 <edwardk> they _almost_ repeat
23:37:49 <edwardk> =/
23:37:50 <earthy> that's what nubBy does. ;)
23:37:51 <Maxdamantus> Being able to create forms of the same data structure, but each time getting one with a different type.
23:38:05 <copumpkin> edwardk: yeah
23:38:17 <a215> damn recursion
23:38:19 <edwardk> the blind fork is not updating the read map, etc.
23:38:26 <earthy> sachaf: yeah, I've been on #haskell for at least 8 years
23:38:34 <Maxdamantus> but probably also being able to hide that uniqueness as you store it somewhere alongside others of the similar type.
23:38:34 <edwardk> i was going to special case (=:) but after vmodify i was like ehhhh.
23:38:43 <shachaf> earthy: Were you gone for a while?
23:38:46 <a215> that (x:xs) stuff is never gonna feel comfortable
23:38:52 <earthy> 'gone' is a big word
23:38:55 <earthy> paying less attention
23:38:55 <copumpkin> edwardk: I think the last two guys do actually repeat?
23:38:55 <shachaf> I wonder whether I'm confusing you with an ISP...
23:39:00 <kmc> a215, so give up now?
23:39:04 <shachaf> No, I think I remember you.
23:39:05 <a215> lol
23:39:10 <copumpkin> edwardk: the case blocks: http://snapplr.com/7enk ?
23:39:17 <edwardk> yeah
23:39:36 <earthy> you were just starting out, ISTR
23:39:43 <earthy> with Haskell, that is
23:39:48 <copumpkin> probably not worth factoring out though
23:39:55 <edwardk> so maybe i can factor those out into a helper function in the where clause
23:40:30 <companion_cube> newtype Rev s a = Rev { unrev :: forall r. (a -> Supply -> Segment -> History -> r) -> Supply -> Segment -> History -> r }    edwardk, what's the difference between this and "a"?
23:40:45 <edwardk> copumpkin: what that is is basically a cps'd state monad
23:40:52 <edwardk> you can modify the supply, segment, and history
23:41:25 <edwardk> forall r. (a -> r) -> r    is very much like 'a' but this is bigger
23:41:51 <edwardk> forall r. (a -> s -> r) -> s -> r)   is a cps'd state
23:42:09 <companion_cube> oh, because you can provide a different "a" depending on s ?
23:42:14 <edwardk> yeah
23:42:27 <companion_cube> cooool
23:42:27 <edwardk> and a different s as well
23:42:28 <edwardk> so you can change the output
23:42:33 <magn3ts> How can I take [[1,1],[2,3],[6,5]] and print [1,1]\n[2,3]\n[6,5]
23:42:37 <companion_cube> right
23:42:40 <edwardk> the forall keeps you from ignoring the function
23:42:44 <kmc> you could also write  ((a,s) -> r) -> s -> r
23:42:47 <kmc> magn3ts, mapM_ print
23:43:00 <kmc> you could also write  ((a,s) -> r) -> s -> r  which would be the CPS of (s -> (a,s))
23:43:04 <edwardk> kmc: you could, but then all you do is add more heap allocation and a spurious bottom
23:43:08 <kmc> right
23:43:09 <companion_cube> the forall is an existential type, right?
23:43:13 <kmc> but it's conceptually closer
23:43:20 <kmc> companion_cube, no, it's inside the constructor
23:43:29 <kmc> it's a polymorphic (universally quantified) data field
23:43:38 <companion_cube> ok
23:43:43 <shachaf> marvinalone: Why don't you want a \n on the end?
23:43:47 <companion_cube> it's existential only as an argument of a function
23:43:51 <kmc> the user of a Rev value decides which r to use
23:43:51 <shachaf> s/marvinalone/magn3ts/
23:44:04 <edwardk> sure, there you're using the adjunction between (,s) and (s ->)  to compose state.
23:44:24 <companion_cube> all CPS types must be universally quantified, i presume
23:44:54 <shachaf> So the closest counterpart of currying a function that takes multiple arguments for returning multiple arguments is CPS and then currying the continuation?
23:45:00 <edwardk> companion_cube: well, you could use (a -> s -> r) -> s -> r  -- with r unquantified but then you risk someone who knows an r using callCC, etc.
23:45:31 <edwardk> shachaf: yeah you could also just use (#   #) for the result, which i was doing originally
23:45:41 <edwardk> but then i can't use the MonadSpec instance that is in there now
23:45:51 <monochrom> strange that unboxing is slower than CPSing
23:46:05 <edwardk> by moving to cps it makes the frames out onto the heap, letting me speculate
23:46:10 <edwardk> er moves the frames
23:46:25 <edwardk> monochrom: well, unboxing and cpsing here are pretty competitive
23:46:42 <monochrom> alright, I withdraw that
23:47:14 <edwardk> the main advantage of cpsing is that you get some interesting cases where things like fmap, etc are obviously able to avoid touching a bunch of args they don't care about
23:47:55 <edwardk> forall r. (a -> A -> B -> C -> D -> E -> F -> r) -> A -> B -> C -> D -> E -> F -> r  is much nicer to fmap over than
23:48:10 <edwardk> A -> B -> C -> D -> E -> F -> (# a, A, B, C, D, E, F #)
23:48:43 <edwardk> because fmap f (Foo m) = Foo $ \k -> m (k . f)    works regardless of how many of those args there are
23:49:23 <edwardk> similarly the return and bind of the monad don't even _look_ at those args
23:49:34 <edwardk> its only the operations that need them that inspect that far down the stack
23:49:51 <edwardk> trifecta uses this trick a lot
23:50:08 <edwardk> which reminds me i need to make a MonadSpec instance for trifecta prim
23:50:15 <edwardk> er for trifecta's prim parser
23:50:19 <monochrom> that is like the best argument for pointfree since my unix pipe analogy
23:50:39 <edwardk> well its tricky because you need to weigh it against those functions not getting inlined
23:50:51 <edwardk> and the fact that ghc will some times fight you and eta expand
23:51:46 <edwardk> monochrom: if you want to see the absurd extreme version i have a monad-ran package somewhere
23:51:59 <edwardk> its bitrotted a bit, but it has examples of 'right kan extension transformers'
23:52:09 <companion_cube> do you have a monad-rant package too?
23:52:11 <edwardk> and uses this representation for everything from IO, etc.
23:52:19 <monochrom> no, I don't want to see absurd extremes
23:52:20 <edwardk> RanT is in the package =P =)
23:52:25 <companion_cube> :D
23:52:43 <edwardk> http://hackage.haskell.org/packages/archive/monad-ran/0.1.0/doc/html/Control-Monad-Ran.html'
23:53:31 <edwardk> the instances in there are rather interesting
23:53:53 <edwardk> it led me to realize i only really want to move to right kan extension form for codensity monads or things that are nearly codensity
23:54:27 <edwardk> i did get some really nice 4x performance wins for some microbenchmarks when it helped the inliner see a bunch of stuff
23:54:33 * companion_cube understands why edwardk began with a thesis in maths
23:54:38 <edwardk> on the other hand i also got a lot of 16x slowdowns
23:55:13 <edwardk> companion_cube: i did the math thesis because i was having a good time in academia
23:56:19 <earthy> wow... I'm really behind on my category theory
23:56:30 <earthy> don't even know what a codensity monad is.
23:57:23 <edwardk> earthy: codensity (in haskell) is just a universally quantified CPS transformation such that   you wind up with           forall r. (a -> f r) -> f r
23:57:36 * ddarius eats some apple smoked Gruyere with sourdough bread.
23:57:57 <kmc> that sounds incredibly tasty
23:58:04 <edwardk> for _any_ f. it doesn't have to be a functor, or anything, just any type of kind * -> *
23:58:24 <edwardk> earthy: it is a fun exercise to work out the monad for that
23:58:33 <edwardk> earthy: after that its a lot less scary
23:58:47 <earthy> for *any* f... cool
23:58:55 <sanjoyd> Suggestions for texts that will help me understand the lambda cube, calculus of constructions etc. ?
23:59:25 <edwardk> http://comonad.com/reader/2011/free-monads-for-less/ was the start of a series of articles i wrote recently talking about abuses of codensity
23:59:34 <kmc> sanjoyd, have you read TaPL?
23:59:37 <sanjoyd> kmc: no.
23:59:41 <sanjoyd> kmc: full form?
23:59:45 <kmc> i'd start there
23:59:46 <kmc> full form?
23:59:50 <earthy> edwardk: yah, I've not kept up to date. ;)
23:59:51 <kmc> @where tapl
23:59:51 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
23:59:52 <sanjoyd> TaPL?
23:59:58 <sanjoyd> kmc: thanks!
