00:05:43 <silver> hey, is there a tool to paste stuff to hpaste from shell?
00:15:59 <cts> silver: https://launchpad.net/pastebinit/
00:26:22 <silver> cts, thank you
00:26:30 <silver> this might do
00:27:48 <cts> silver: I just noticed that hpaste is not in pastebinit's list of supported pastebins...  :(
00:29:26 <silver> yeah, but this is not critical I guess :)
00:29:59 <mysticc> what does this means in the type : f :: (A b ~ C ) => ....
00:30:09 <mysticc> what does ~ mean
00:30:32 <mysticc> Here A is a monad and C is a Data Constructor
00:31:37 <Phyx->  awww "Phyx" is already taken on github
00:33:00 <Phyx-> mysticc: type equality constrain
00:33:11 <mysticc> Phyx-: means ?
00:33:13 <Phyx-> t1 ~ t2 denotes that t1 and t2 need to be the same
00:33:26 <Phyx-> mysticc: http://www.haskell.org/haskellwiki/GHC/Type_families look at section 6.3
00:33:41 <mysticc> Phyx-: kk thanks ..
00:33:50 <edwardk> mysticc: that shouldn't be satisfiable if A is a Monad
00:34:00 <edwardk> (though it could if A was a type family)
00:34:14 <mysticc> edwardk: Oh ..
00:35:01 <edwardk> f :: (a ~ (b,c)) => (a -> d) -> b -> c -> d           = f :: ((b,c) -> d) -> b -> c -> d
00:35:12 <edwardk> but some of those can't be so simply expanded
00:36:43 <mysticc> edwardk: Thanks .. that really helped :)
00:37:27 <edwardk> in the above A b ~ C   would require that C = A b, which it can't, since the constructors don't match =)
00:38:07 <edwardk> if you had 'type C = A Int   -- then (A b ~ C) => could match. but only if b = Int
00:43:37 <Phyx-> yo Spockz
00:49:50 <Blkt> good morning everyone
00:50:22 <Phyx-> morning
00:51:25 <Phyx-> hmm does anyone know where the haddock trac is? or doesn't it have a seperate trac ?
00:52:04 <Phyx-> ah, nvm, found it
00:52:47 <Phyx-> not strictly a haskell question, but how you you specifically clone a branch in git?
00:55:20 <MasseR> git checkout -b foo origin/foo
00:55:26 <MasseR> I assume that you mean that
00:57:16 <Phyx-> MasseR: ah ok, i'll give that a go, thanks!
00:57:40 <mysticc> is there any function opposite of intercalate .. which gives me back the original list given the separator and result of intercalate .?
00:58:17 <mysticc> > intercalate "," ["foo","bar","biz"]
00:58:18 <lambdabot>   "foo,bar,biz"
01:00:00 <Eduard_Munteanu> Phyx-: mind that also switches to the new branch
01:00:44 <Phyx-> Eduard_Munteanu: yup, that's what i want in this case :)
01:03:07 <Spockz> yo Phyx-
01:03:57 <Spockz> mysticc: that's just a parser?
01:04:47 <Spockz> mysticc: and that's not possible in general (intercalate "," ["foo , baar", "smth"]
01:06:17 <mysticc> Spockz: Thanks ... I got that ,, well my string was constrained not to contain the separator .. anyways thanks ..
01:08:36 <Phyx-> Spockz: wassa?
01:09:02 <Spockz> Phyx-: not much, have to learn for an exam… but it's boring :)
01:09:17 <Spockz> Phyx-: and I'm trying to fix wxHaskell with kowey
01:09:32 <Phyx-> mysticc: well, Bytestring has it with "split" but the standard prelude unfortunately doesn't, only SplitAt
01:09:46 <Phyx-> Spockz: what's a kowey?
01:09:57 <Spockz> Phyx-: it's the nickname of someone here
01:10:03 <Phyx-> ah
01:10:04 <Phyx-> lol
01:10:08 <Phyx-> cool
01:12:28 <Phyx-> Spockz: you're not on skype today :P
01:23:55 <yitz> mysticc: see the split package
01:23:58 <yitz> @hackage split
01:23:58 <lambdabot> http://hackage.haskell.org/package/split
01:25:05 <yitz> Phyx-: kowey is the project leader of darcs, and an employee of well-typed
01:27:14 <Phyx-> yitz: cool
01:28:02 <Phyx-> speaking of darcs.. a lot of haskell projects seem to be moving to git
01:46:20 <erus`> i have changed my mind about hopengl
01:46:28 <erus`> i quite like it now
01:48:00 <erus`> why cant i go up a namespace in haddock?
02:26:46 <tomh> so is there any way to use cyclic imports? :>
02:27:15 <quicksilver> yes.
02:27:25 <quicksilver> there are instructions in the GHC manual
02:27:35 <tomh> cool
02:27:46 <quicksilver> it's a bit fiddly.
02:27:50 <tomh> so if its possible, why is it not possible by default?
02:28:14 <Axman6> tomh: if you have cyclic imports, that strongly suggests that you've separated things that should be grouped together
02:28:43 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
02:29:02 <quicksilver> tomh: I'm not sure what you mean. It is possible by default. There is no special option or flag to switch it on.
02:29:09 <tomh> Axman6: yeah maybe I'm thinking too much like an OO programmer
02:29:11 <quicksilver> just a fiddly procedure is required.
02:29:15 <tomh> ok
02:29:28 <quicksilver> I've never actaully needed to use it.
02:29:48 <quicksilver> breaking cycles has always seemed to me to clarify my design, but I'm assured that there are cases where that is not true.
02:30:06 * Phyx- has had to use that procedure in cases where no matter how hard he thought he couldn't escape the cyclicness without cluthering a module with stuff that didn't belong there
02:30:13 <tomh> I guess I should rethink my design
02:30:34 <vharishankar> I've progressed a bit more in Haskell and I wanted to record my thoughts again. You can find it here: http://harishankar.org/blog/entry.php/five-tips-about-functional-programming-for-a-haskell-newbie-from-a-haskell-newbie
02:30:47 <vharishankar> I hope somebody finds it useful.
02:32:03 <vharishankar> I cannot contribute so much technically, but I wanted to give back something to the community for their help :-)
02:34:03 <amtal> Hi! I'm taking over a package on hackage at the request of the current maintainers. Could anyone check over my .cabal file to ensure things are okay? https://github.com/amtal/CoreErlang
02:35:01 <amtal> vharishankar: yay, good to see you're progressing :)
02:35:17 <vharishankar> amtal, thank you. :-)
02:41:37 <Phyx-> amtal: looks ok to me, http://hackage.haskell.org/packages/upload.html has a tester on it, you can try that too
02:43:06 <amtal> Phyx-: tester checks out (I assume it just runs `cabal check`)
02:44:02 <Phyx-> amtal: yeah, beleive so
03:22:13 <erus`> which came first, hayoo or hoogle?
03:22:41 <quicksilver> hoogle.
03:22:48 <quicksilver> "Hayoo! is an example application of the Holumbus framework and was heavily inspired by Hoogle"
03:25:57 <dickon> newbie question: if importing a package for one specific function is it good style to list the function name in brackets in the import line?
03:26:35 <quicksilver> dickon: you mean module, not package. I would say that is good style, yes.
03:26:48 <dickon> thanks
03:34:42 <kmc> dickon, my general rule is that any import should be qualified or should have an explicit import list (which could be one thing, yes)
03:34:59 <kmc> dickon, this makes it much easier to search for the origin of a name
03:35:19 <kmc> dickon, but I make exceptions for 'standard modules' and for other modules from the same project
03:38:28 <paolino> hello, I'm looking for a method to label a rose tree with different int each node. Finding it somewhat difficult. If anyone has hints, they are welcome
03:41:03 <paolino> I see , using mapM with State monad resolves, but I was wondering for a more direct method
03:41:36 <cts> paolino: What is a 'rose tree'?
03:41:51 <paolino> Data.Tree
03:42:05 <paolino> data Tree a = Node a [Tree a]
03:44:14 <cts> paolino: And 'a' contains the int label?
03:44:29 <kmc> paolino, you can unfold the State monad sugar
03:44:33 <paolino> labella :: [a] -> Tree b -> Tree (a,b)
03:44:53 <kmc> @unmtl label :: Tree a -> State Int (Tree (Int, a))
03:44:54 <lambdabot> err: Parse error
03:44:58 <kmc> @unmtl Tree a -> State Int (Tree (Int, a))
03:44:58 <lambdabot> Tree a -> State Int (Tree (Int, a))
03:45:03 <kmc> hmm it does not like
03:45:05 <kmc> @unmtl State Int (Tree (Int, a))
03:45:06 <lambdabot> Int -> (Tree (Int, a), Int)
03:45:28 <kmc> if you want to do it without passing "new states" back up the tree
03:45:41 <kmc> you will need a way to split a list of ints into n disjoint lists of ints
03:46:41 <kmc> (where both the input and output lists may be infinite)
03:46:48 <paolino> actually, it's just a way to give different names to each node
03:46:51 <kmc> in fact it's easiest if you assume they are infinite
03:47:10 <paolino> a different name
03:47:52 <Eduard_Munteanu> @hoogle (a -> b -> c) -> f a -> g b -> h c
03:47:52 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> c) -> IntMap a -> IntMap b -> IntMap c
03:47:53 <lambdabot> Data.Sequence zipWith :: (a -> b -> c) -> Seq a -> Seq b -> Seq c
03:47:53 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:48:08 <paolino> kmc , I cannot imagine how to make an infinite of infinite from an infinite
03:48:17 <Eduard_Munteanu> Something like that would make an interesting generic zipWith
03:49:33 <Eduard_Munteanu> (the idea being you'd zipWith your tree and a list of labels)
03:50:30 <quicksilver> Eduard_Munteanu: see zipWithTF at http://www.haskell.org/haskellwiki/Foldable_and_Traversable
03:51:08 <Eduard_Munteanu> Yeah, I guess something like that would be useful to have in the core libs.
03:51:53 <kmc> zipWhatTF
03:52:05 <Eduard_Munteanu> Heh :)
03:52:55 <erus`> has anyone ever written a triangle packing algorithm ? :)
03:53:50 * Eduard_Munteanu also wishes for a flipped zipWithM where the zipping function came last
03:54:04 <Eduard_Munteanu> a-la forM
03:54:18 <koala_man> erus`: arbitrary or right angled?
03:54:28 <erus`> arbitrary
03:54:37 <erus`> packing into a square
03:55:59 <erus`> i guess its gonna be some kinda brute force thing
03:56:20 <hpaste> kmc pasted “labeling a rose tree (for paolino)” at http://hpaste.org/53689
03:59:09 <kmc> paolino, you can do this with the regular list type and save some code too
03:59:37 <kmc> but you will have some "missing pattern" warnings because you have not proved to the compiler that your lists are infinite
04:05:13 <hpaste> kmc annotated “labeling a rose tree (for paolino)” with “labeling a rose tree (for paolino) (annotation)” at http://hpaste.org/53689#a53690
04:05:42 <kmc> this one i like better; it should also work on tree nodes of infinite fan-out
04:05:50 <erus`> http://stackoverflow.com/questions/8036306/project-3d-triangle-onto-its-own-plane some karma, if you guys would like
04:30:17 <erus`> http://stackoverflow.com/questions/8036533/generating-texture-coords-for-3d-triangle fixed
04:32:55 <quicksilver> erus`: this is very off-topic, but your question doesn't have anything like enough information.
04:33:10 <quicksilver> that triangle could be projected at any rotation, what's special about the one you want?
04:33:18 <quicksilver> anyhow, please only post SO links here if they're about haskell.
04:33:28 <erus`> im implementing in haskell
04:34:33 <quicksilver> that question is still unrelated to haskell. You could implement a french -> english natural language translator in haskell and questions about french grammar would remain offtopic :P
04:34:34 <erus`> quicksilver: it is projected onto a plane that the CCW triangle lies on
04:37:54 <cts> erus': CCW means what?
04:38:24 <erus`> counter clockwise. Assuming a plane is a point and a direction
04:41:02 <cts> erus': I don't understand the question.  Please specify what is given and what you look for.
04:41:51 <clsmith> that's a backtick, not a comma :p
04:42:59 <frerich> Apostrophe. Ahem. ;-)
04:43:21 <erus`> i have a triangle. I need to generate texture coords for the triangle.
04:45:33 <kmc> i choose the texture coordinate (0,0) for every point on the texture
04:45:37 <kmc> on the triangle
04:45:53 <erus`> no the dimensions have to be in scale with the original
04:45:59 <kmc> ?
04:46:02 <erus`> just in 2 dimensions rather than 3
04:46:10 <hpc> i choose (0 * xScale, 0 * yScale)
04:46:56 <erus`> ok i have some random triangle -> i (move/rotate) it flat against my screen, i get the pixel coords for each point
04:47:03 <erus`> does that make more sense?
04:47:22 <quicksilver> your question is quite underspecified. Once properly specified it becomes totally trivial.
04:47:23 <erus`> like a ortho project on the triangles own plane
04:47:32 <quicksilver> it's hard to understand how you can even ask it.
04:47:33 <kmc> look up the math for ortho project then
04:47:36 <quicksilver> but it's definitely off topic.
04:48:02 <quicksilver> there are an infinite number of projections from a triangle to its own plane. As far as you have said so far, any of them might be acceptable.
04:48:26 <erus`> yeah any is fine i just need to preserve the order of the points
04:49:24 <cts> erus': You didn't specify any order, and you didn't name the points.
04:50:03 <erus`> a triangle is p1, p2, p3
04:50:07 <kmc> i project all points to (0,0)
04:50:32 <erus`> kmc i think your matrix is corrupt
04:50:47 <frerich> erus`: I think what you're trying to do is commonly called "texture mapping"; it's probably offtopic here, but the articles at http://chrishecker.com/Miscellaneous_Technical_Articles might be useful.
04:50:48 <kmc> woah
04:50:51 <cts> erus': And what is "its own plane"?  The triangle defines a plane, but its corners are in that plane already...
04:50:51 <kmc> i know kung fu
04:51:16 <luite_> erus`: it looks a bit singular, but not corrupt
04:53:27 <erus`> i could just rotate my triangle so that its normal faces z
04:53:38 <quicksilver> you could in fact pick (0,0) for one point, ANYTHING for the second point, and ANYTHING ELSE which isn't a multiple of the first one for the third point
04:53:46 <quicksilver> and that would be a correct non-degenerate projection.
04:54:04 <quicksilver> so I think you need to make it a lot more clear what you want to do.
04:54:15 <quicksilver> and it's still nothing do with haskell!
04:54:34 <hpc> erus`: you could look up the math yourself... or read the documentation of whatever graphics language you are using, because they should have already solved that problem
04:55:34 <cts> erus`: And what is the orientation of a triangle in 3space?
04:56:27 <erus`> my triangle starts in 3 dimensions. I need to project it (into/onto) 2 dimensions
04:58:22 <Cale> erus`: any reason why you didn't decide to make one of the edges of the rectangle one of the sides of the triangle?
04:58:57 <erus`> no reason
05:12:01 <kmc> derp
05:15:30 <hpaste> huangyi pasted “Why directory-1.1.0.1 is different package to directory-1.1.0.1, Is this a bug of cabal?” at http://hpaste.org/53693
05:15:54 <shk> Hi all
05:17:15 <shk> I'm new in haskell, I want to use Parsec in my small project, i made cabal install parsec, all ok, but when i try import Parsec i got error: Could not find module `Parsec'
05:17:33 <shk> what's wrong in my action?
05:17:55 <hpc> shk: http://hackage.haskell.org/package/parsec -- the package contains modules; the modules are what you import
05:18:02 <hpc> in this case, Text.Parsec
05:18:26 <Phlogistique> shk: the doc is outdated
05:18:37 <Phlogistique> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html this doc is outdated, I mean
05:18:44 <Phlogistique> if that's what you're following
05:19:14 <Cale> But only a little bit :)
05:19:23 <shk> <Phlogistique>: yes, you're right, thank you
05:19:29 <Cale> It just has outdated module names, and some of the types have been generalised
05:20:23 <shk> But i got the same error: Could not find module `Text.Parsec
05:22:00 <shk> sorry, now it's all right
05:22:08 <shk> thank's for you replys
05:24:27 <shk> btw, anybody using leksah for haskell developing? I use emacs for it, maybe lekash will be more comfortable?
05:33:23 <s951> Is it possible to overload an instance of Show for a data type?
05:33:39 <Cale> s951: There can be only one instance per type.
05:33:53 <Cale> But you can wrap the datatype in a newtype with its own instances.
05:33:55 <simon> s951, you can create an alias and create an instance of Show for that.
05:34:13 <Cale> You can't just make a type alias with 'type'
05:34:30 <simon> sorry, I was thinking of newtype but was being imprecise.
05:35:06 <s951> Hmm. Can I add guards to a show statement?
05:41:13 <cts> s951: You can write your own function showlikeiwant :: ... -> IO () and use that, I guess.
05:41:41 <Tyr42> Hello, I've got a question about using Haskell for Maths
05:41:42 <s951> So something like: show ( Op "Plus" (a,b) ) = show a ++ " + " ++ show b
05:41:55 <s951> But when a = 0, then just = show b
05:41:56 <s951> etc.
05:41:57 <Eduard_Munteanu> Tyr42: hi
05:42:08 <Tyr42> I was working with the polynomials, but I want to work in Z3[x]
05:42:10 <s951> Ah, k.
05:42:27 <Tyr42> how can I tell it to make a polynomial over a different field?
05:43:52 <cts> s951: And you don't have to use the derived version of show, you can write your own one.
05:48:54 <Eduard_Munteanu> Tyr42: I guess you want to work with / build polynomials in GlexPoly F3 v
05:49:29 <Tyr42> sure.  Does he have a post about how to set up that kind of stuff?
05:50:10 * hackagebot CoreErlang 0.0.2 - Manipulating Core Erlang source code  http://hackage.haskell.org/package/CoreErlang-0.0.2 (AlexKropivny)
05:51:07 <Tyr42> Also, I would like to work with those polynomials mod another polynomial
05:51:07 <Eduard_Munteanu> Tyr42: dunno, I never used HfM. But I think you should look at 'var' here:  http://hackage.haskell.org/packages/archive/HaskellForMaths/0.4.0/doc/html/Math-CommutativeAlgebra-Polynomial.html
05:51:15 <Tyr42> alright
06:13:27 <Tyr42> Eduard_Munteanu: that works, thanks
06:13:43 <erus`> can i construct a new Matrix (hopengl) without using IO ?
06:14:36 <tac-tics> erus`: I don't know anything about Hopengl, but considering matrix arithmetic is often delegated to the gpu, I would imagine that it isn't a "pure" operation
06:16:08 <quicksilver> well, hopengl matrices are a class not a type so conceivably you could implement your own instance or someone else could
06:16:13 <quicksilver> but, basically, the answer is no.
06:16:25 <quicksilver> GLMatrixes represent C style pointers and are created in IO
06:16:34 <erus`> is there a matrix type included in the platform?
06:16:40 <kmc> opengl is an incredibly stateful API
06:17:02 <kmc> and the Haskell 'OpenGL' package does not attempt to hide that
06:17:11 <quicksilver> the simplest thing is just to use a list, erus`
06:17:18 <quicksilver> that's what the HOpenGL bindings assume you will do.
06:17:25 <erus`> what and re implement matrix multiplication ?
06:17:27 <tac-tics> kmc: you could say that it's not a very "creative" API binding
06:17:29 <quicksilver> all the OpenGL matrix stuff is deprecated of course.
06:17:33 <tac-tics> which can be both a good and bad thing
06:17:34 <kmc> it's pretty damn easy erus`
06:17:36 <kmc> if you don't need speed etc
06:17:45 <quicksilver> erus`: yes, that's what all C and C++ OpenGL programmers do anyway.
06:17:48 <kmc> tac-tics, *nod* it's layer 2 or so
06:17:49 <flux> I think in general low level bindings + high level bindings is a good approach
06:17:49 <tac-tics> erus`: unsafePerformIO
06:17:50 <erus`> yeah but how is there no library for this :P
06:17:56 <kmc> yes
06:17:59 <quicksilver> there are many, many, libraries for this.
06:18:03 <flux> in principle you can then write an alternative high level binding for the low level stuff, because you have all the parts for it
06:18:07 <quicksilver> it's just that OpenGL isn't that library.
06:18:12 <erus`> whats the standard lib in haskell ?
06:18:14 <kmc> i would hope that a library for GPGPU matrix math would expose a pure interface
06:18:15 <tac-tics> unsafeIt'sPureEnoughForWhatYouCareAbout
06:18:17 <erus`> for matrix*
06:18:24 <kmc> but i don't expect that from a low level graphics api
06:19:17 <tswett> Suppose that using the FFI, I import a C function and declare it to be pure.
06:19:22 * kmc supposes
06:19:28 <tswett> Will multiple execution threads be allowed to call the function at the same time?
06:19:35 <kmc> yes
06:19:45 <cheater> kmc
06:19:52 <cheater> woops wrong channel
06:20:09 * tswett nods.
06:20:10 <tswett> Thank you.
06:20:24 <kmc> tswett, that's always allowed, unless you take pains to prevent it
06:20:41 <kmc> doesn't matter whether you import IO or pure, safe or 'unsafe'
06:20:44 <tswett> Like sticking some weird semaphore thing around it?
06:21:21 <kmc> (however with GHC, if you foreign import unsafe, then all Haskell threads on that OS thread will be blocked until the call returns)
06:21:27 <kmc> tswett, sec, I wrote a blog post about this recently
06:21:33 <tswett> (Or sticking some perfectly normal semaphore thing around it?  }:P)
06:22:03 <kmc> it's hard to get a single global semaphore
06:22:19 <kmc> http://mainisusuallyafunction.blogspot.com/2011/11/global-locking-through-stableptr.html
06:22:21 <tswett> kmc: how could they *not* all be blocked until the call returns?  Surely an OS thread cannot execute foreign code and Haskell code at the same time.
06:22:45 <kmc> tswett, if you import 'safe' (the default), then GHC will bounce the foreign call to another OS thread
06:22:52 <kmc> (or bounce all the Haskell threads, forget which)
06:22:59 <tswett> Mm.
06:23:13 <kmc> GHC: It's Basically an OS™
06:23:49 <kmc> tswett, the other consequence of importing unsafe is that you cannot call back into Haskell from that foreign call
06:24:05 <quicksilver> erus`: dunno. I always did the maths by hand. I think one of the popular haskell ones was called 'vector-space' or something.
06:24:12 <kmc> generally you should use safe, unsafe saves a fixed latency on the order of 100 ns
06:24:18 <kmc> so most of the time it doesn't matter and just causes horrible bugs
06:24:32 <tswett> So the only reason to use unsafe is to get a little bit more speed.
06:24:33 <kmc> the blog post says a bit more about this
06:24:48 <Peaker> how often do FFI calls call back into Haskell?
06:24:51 <cheater> why is this latency there
06:24:59 <kmc> tswett, yes, and it will only matter for very very short C functions
06:25:07 <kmc> even for sinf it's like a factor of 2 difference in my benchmarks
06:25:17 <tswett> What's sinf?
06:25:19 <kmc> cheater, <kmc> tswett, if you import 'safe' (the default), then GHC will bounce the foreign call to another OS thread
06:25:26 <kmc> sine for floats
06:25:33 * tswett nods.
06:25:34 <cheater> ah
06:26:02 <cheater> interestingggg.
06:26:03 <kmc> bouncing the foreign call to another OS thread would take much more than 100 ns, because you'd have to wait for that thread to get scheduled
06:26:06 <kmc> so i think it does the opposite
06:26:27 <kmc> hands off the Haskell Evaluation Capability to another OS thread, does the foreign call, and possibly gets the HEC back before any OS-level scheduling has occured
06:26:49 <kmc> but that still takes time — you need to do synchronized memory ops and such
06:28:35 <tswett> I suddenly wonder how to write atomic operations in C.
06:28:41 <kmc> "don't"
06:28:52 <kmc> there is no way in portable C90
06:29:17 <kmc> afaik, the language doesn't specify a memory model that's complete enough to make a good atomic ops library
06:29:20 <cheater> yea your best bet is to use ASM
06:29:33 <lmth> Hi, I'm having a bit of trouble understanding the return types for Regex queries.  There's a list of them here: http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-Context.html but I don't fully understand them.  Can you explain to me how they work?
06:29:42 <tswett> So you pretty much have to do something silly, like giving each thread its own "i am working!" variable, and have each thread acquire the mutex by setting its own variable and then checking the other.
06:29:46 <kmc> even if that library itself were implemented with asm, you could not provide a totally portable nice API
06:29:54 <tswett> ...Or ASM, yes.
06:29:55 <cheater> if it did we'd have one already kmc
06:30:05 <kmc> for the blog post i mentioned, i used http://gcc.gnu.org/onlinedocs/gcc/Atomic-Builtins.html
06:30:13 <kmc> which works all right as long as you're on GCC
06:30:20 <tac-tics> Portable C90 sounds a lot like Haskell 98 to me. (ie: no one uses it)
06:30:29 <kmc> lots of people use both
06:30:35 <kmc> anyway the real problem isn't single atomic memory operations
06:30:43 <kmc> but the lack of a platform-independent model of when you need memory barriers
06:30:51 <kmc> i think C++11 has this
06:30:55 <kmc> and C1x might too
06:31:20 <kmc> fwiw GHC implements its own atomic operations in inline assembly
06:31:27 <kmc> and yeah they have to worry about memory barries
06:31:41 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html has some of the details towards the end
06:33:30 <monadic> Why does something like "streamEnum handle (E.Continue k) = (read some bytes from handle...) k (E.Chunks [bytes]) E.>>== streamEnum h" where E = Data.Enumerator seem to enumerate the bytes in a backward order?
06:39:47 <monadic> Nevermind; I was just being silly.
06:48:51 <monadic> Eh, how do people usually maintain things that have both a Strict and Lazy bytestring? I'm writing a library that can work with both Strict and Lazy ByteString's and it seems like copying the Strict version and modifying it to be Lazy seems like it will become a bit of a pain for maintenance
06:51:48 <Peaker> Lack of type-class for generality with ByteString code (and other kinds of containers) is a weak spot in Haskell's libs...
06:52:07 <Peaker> monadic: Maybe the ugly ListLike hack is good enough to work with both?
06:52:45 <monadic> Peaker: Maybe, except then you have the problem of having to use cereal for strict and binary for lazy
06:53:18 <monadic> It really feels like ByteString and Text should both be classes so that anything can work with both Lazy and Strict ones, but alas...
06:53:48 <kmc> monadic, it depends, sometimes one is actually implemented in terms of the other
06:54:02 <kmc> like hdis86 can disassemble lazy or strict bytestrings
06:54:15 <monadic> Is a strict-to-lazy O(1)?
06:54:20 <kmc> yes
06:54:28 <kmc> lazy bytestring is a list of strict bytestrings, more or less
06:54:33 <monadic> yeah
06:54:39 <kmc> the chunks are allowed to be any size
06:54:56 <kmc> in hdis86, the lazy functionality is implemented on top of strict, and involves solving a non-trivial domain-specific problem which I also expose by itself
06:55:10 <kmc> so i feel that's value and not duplication
06:55:30 <monadic> Okay. I'll look at implementing the Lazy API that way.
06:55:44 <kmc> (note to all interested parties: i subscribe to the radical notion that "trivial" means something other than "easy", and therefore "non-trivial" does not mean "difficult")
06:56:36 <monadic> kmc: Is strict-to-lazy Text also O(1)? I plan on adding Text support later
06:56:48 <kmc> don't recall, but probably
06:57:10 <jerry_> when you create instance of read class and define parser for type....when you call "read" that function uses that parser and returns tuple [a,restOfInput]
06:57:14 <jerry_> is that correct?
06:57:21 <kmc> :t reads
06:57:22 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:57:25 <jerry_> should be in bracket
06:57:38 <kmc> the tuples returned by 'reads' do represent (value, rest of input)
06:57:44 <kmc> that's not what 'read' returns
06:57:58 <monadic> jerry_: Why aren't you deriving (Read)? If you are doing something besides the default derivation then you probably should not be using Read
06:58:35 <jerry_> kmc: so how do you process something like this "type1,type2,type3"..suppose read function takes this in and returns [(type1,"type2,type3)]
06:58:48 <kmc> use a real parser
06:58:49 <jerry_> how do you get to type2
06:58:52 <kmc> like Parsec
06:58:55 <kmc> or Trifecta
06:59:14 <kmc> (or in this case, use the 'split' library and go from there
06:59:15 <kmc> )
06:59:33 <jerry_> kmc: tx
06:59:34 <Eduard_M1nteanu> It depends on what type{1,2,3} are.
06:59:49 <Eduard_M1nteanu> If it's that simple, then I guess split is enough.
07:00:06 <jerry_> Eduard_M1nteanu: those are my own types
07:00:10 * hackagebot time-recurrence 0.6.1 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.6.1 (ChrisHeller)
07:00:16 <kmc> you can read a tuple
07:00:28 <kmc> > read "(3,4,'x')" :: (Int, Double, Char)
07:00:29 <lambdabot>   (3,4.0,'x')
07:01:03 <kmc> jerry_, Read/Show exist basically to help you get data in/out of GHCi during debugging
07:01:16 <kmc> it's unwise to use them for real parsing
07:01:44 <jerry_> kmc: ok
07:01:55 <erus`> would be nice if haskell had built in matrix operations like J and aplk
07:01:59 <erus`> apl*
07:02:42 <monadic> kmc: Actually the lazy api would involve both the reading and writing of strict bytestrings. Hence should I just give up trying to implement one in terms of the other as doing it either way would involve lazy-to-strict conversion
07:03:10 <monadic> or I guess I could reimplement the specific sections.
07:03:46 <kmc> erus`, ugh.  why should Haskell have "built in" operators to support your particular problem domain?
07:04:35 <monadic> there's no difference between built in operators and user operators.
07:04:37 <erus`> I just said it would be nice :) seems like a fairly common problem
07:05:10 * hackagebot kansas-lava 0.2.4 - Kansas Lava is a hardware simulator and VHDL generator.  http://hackage.haskell.org/package/kansas-lava-0.2.4 (AndyGill)
07:05:11 <monadic> so is Unicode IO and it has its own package (Text) [since who uses String
07:05:14 <monadic> anymore]
07:05:31 <simon> erus`, built-in operators as opposed to a library?
07:05:33 <kmc> who uses string? people who are writing small programs
07:05:33 <osfameron> of course haskell does allow you to not import the prelude, doesn't it?  So having the wrong stuff in core isn't as dangerous as in some languages
07:05:41 <kmc> that don't need to be fast or eat huge data
07:06:01 <monadic> kmc: I meant that not in a completely true sense, just saying that for major IO you need outside packages as well. And I prefer it this way to be honest
07:06:34 <monadic> I'm that weird guy that refuses to install the Haskell Platform because it has 1-2 packages I don't want :P
07:08:08 <osfameron> monadic: why is that a problem?  Surely it'll only link the packages that you import?
07:08:23 <bscarlet> Is there a good discussion of the limitations of String and the strengths and weakenesses of alternatives somewhere?
07:08:40 <kmc> ezyang's blog had a post a while back
07:08:50 <kmc> the limitations are summarized as "slow; huge"
07:09:12 <bscarlet> why slow? Per char allocation? Something else?
07:09:17 <kmc> yes
07:09:21 <kmc> per char allocation of large boxed characters
07:09:26 <kmc> the strength of String is that it's a very simple data type you can implement in 1 line of haskell
07:09:44 <bscarlet> Why huge? non-lazy usage creating lots at once?
07:09:48 <monadic> osfameron: Yeah, but what reason do I have to install the entire platform anyway? I'll just let cabal-install grab stuff for me if I need it
07:10:23 <monadic> bscarlet: Well its a list so you have the overhead of pointers for one thing...
07:11:32 <bscarlet> Has anyone looked at making string better? e.g. some compiler stuff to represent lists of small stuff (like characters) better when possible?
07:11:52 <kmc> i'd rather have fancy libraries than compiler-specific hacks
07:12:22 <Axman6> also ghc stores string literals as C strings i think
07:13:16 <bscarlet> kmc: why? fancy libraries mean we spend lots of time with annoying inter-interface glue code. Compiler technology might only get implemented in one compiler first, but it can be disseminated and it fixes problems for all or most users of the compiler.
07:13:40 <kmc> i think you'll find the requisite compiler technology is very hard to implement
07:13:50 <kmc> and reasoning about Haskell performance is hard enough
07:13:51 <bscarlet> kmc: I agree wholeheartedly.
07:14:01 <kmc> without more brittle optimizations which work great in specific benchmarks
07:14:09 <bscarlet> kmc: I also enjoy thinking about hard compiler problems.
07:14:47 <monadic> Hmm is there a specific encoding which Data.Text would encode to a ByteString the fastest? I'm guessing one of the UTF16 variants since that is what Text seems to use internally, but which one?
07:15:10 * hackagebot kansas-lava-cores 0.1.2 - FPGA Cores Written in Kansas Lava.  http://hackage.haskell.org/package/kansas-lava-cores-0.1.2 (AndyGill)
07:15:15 <parcs> how fast are Strings compared to utf8-aware strings in other languages?
07:15:16 <kmc> bscarlet, with an implementation like GHC, String is huge because for every character, you have a heap-allocated (:)-cell with a pointer to a heap-allocated Char cell with a UTF-32 unicode character inside
07:15:28 <monadic> parcs: Depends on task
07:15:36 <bscarlet> kmc: sure. I understand that.
07:15:37 <kmc> Strings are not "utf8-aware" (though I don't know if you were implying they are)
07:15:58 <monadic> kmc: Hmm? Lots of languages have utf8-aware strings
07:16:16 <kmc> that's stupid, why would you make your core string type "aware" of a particular encoding?
07:16:37 <monadic> I think he just means unicode strings as opposed to ASCII limited like a char *
07:16:44 <parcs> yeah
07:16:47 <parcs> unicode
07:16:51 <kmc> ah yes
07:16:55 <kmc> unicode ≠ utf8
07:17:14 <kmc> yes, plenty of languages have unicode string types built in
07:17:16 <kmc> haskell among them
07:17:21 <kmc> (fsvo 'built in')
07:17:55 <quicksilver> the answer is, Strings are really rather slow compared to  many other language's unicode string types
07:18:03 <quicksilver> however, they're still perfectly fast enough for many purposes
07:18:13 <kmc> anyway I suspect Haskell's simple String with a one-line implementation will be crushed by the heavily tuned, interpreter-special-cased strings of other languages
07:18:35 <quicksilver> we have faster options available when we need them
07:18:39 <kmc> i think we don't do a good enough job telling beginners that if they need performance, they need to import things outside of Prelude
07:18:44 <quicksilver> and "Strings are just lists" is quite a convenience payback.
07:18:45 <kmc> it's really different from say Python
07:18:53 <quicksilver> perhaps
07:19:05 <quicksilver> but each particular axis of performance is quite divisive
07:19:06 <kmc> in Python you expect the built-in list, string, dict to be the right tool for most jobs
07:19:15 <kmc> and they all have deep implementation magic
07:19:19 <quicksilver> X% of programmers will never hit a String bottleneck in their life
07:19:22 <vharishankar> So for parsing purposes, string is not ideal?
07:19:28 <quicksilver> (100-X)% of programs will find String to be a disaster.
07:19:31 <quicksilver> I don't know what X is ;)
07:19:46 <kmc> vharishankar, how big is the thing you're parsing?
07:19:56 <vharishankar> kmc: let's say a HTML file.
07:19:57 <quicksilver> vharishankar: it's fine if you don't end up CPU bottlenecked on parsing.
07:19:58 <kmc> vharishankar, if it's the size of a typical source code file, it will not matter
07:20:04 <simon> quicksilver, you know that X < 100!
07:20:04 <kmc> some HTML files are much bigger than others...
07:20:07 <monadic> If I encode, say, 10 Text's to ByteStrings, then append the ByteStrings, will the appended ByteString decode successfully
07:20:14 <kmc> monadic, which encoding?
07:20:20 <kmc> the answer is "yes" with any reasonable unicode encoding
07:20:27 <vharishankar> kmc and quicksilver, thanks.
07:20:28 <kmc> utf-{8,16,32} all have this property
07:20:28 <monadic> kmc: utf16LE but I'm open to switching to something else if it doesn't work
07:20:42 <monadic> Okay, good, won't have to write an iteratee to take care of it
07:20:44 <kmc> utf8 is shockingly well-designed :)
07:20:49 <quicksilver> if it's a 500megabyte HTML behemoth then parsing might be a big part of your execution time.
07:21:10 <kmc> monadic, every character in utf-16 is either one or two 16-bit units
07:21:14 <bscarlet> kmc: while I certainly understand your argument about brittle performance, I think that just sets a high bar for the sort of optimization I'm talking about.
07:21:18 <simon> yes, why not use utf8?
07:21:19 <kmc> and the ones which come in pairs are distinct from the ones which don't
07:21:28 <vharishankar> Right now most of my haskell programs are just for learning :)
07:22:02 <MonsterSoul> yo
07:22:36 <monadic> simon: If you are talking to me, I use 16 because Text uses utf16 internally so I figured there might be better performance if it doesn't have to switch encodings
07:22:46 <kmc> you should test the performance!
07:22:48 <kmc> very easy with Criterion
07:22:51 <monadic> I will once it is done
07:22:55 <monadic> :
07:22:57 <monadic> :)
07:23:02 <vharishankar> I'm finding Project Euler too mathematical and difficult for my level. Is there something easier to work on? (for practising Haskell skills)
07:23:19 <monadic> vharishankar: There are some exercises in RWH, not sure of the quality though
07:23:21 <kmc> vharishankar, what do you actually want to program?
07:23:31 <kmc> monadic, I just meant testing the respective encode/decode function
07:23:38 <vharishankar> kmc: I want to learn the more advanced techniques, but in stages.
07:23:46 <kmc> no i mean
07:23:56 <kmc> why would you learn a programming language if you don't want to make any things
07:24:06 <vharishankar> kmc: I am looking for knowledge. :)
07:24:13 <kmc> http://prog21.dadgum.com/80.html?Programming
07:24:13 <bxc> vharishankar: i found it most useful to write small apps - one is a photo ranking program and the other is a timesheet processor for my consulting hours
07:24:19 <kmc> maybe you should study maths instead
07:24:26 <bxc> vharishankar: oh and a duplicate file detector
07:24:37 <vharishankar> bxc: thanks for the suggestions.
07:24:40 <bxc> vharishankar: between those three i've got a fairly good spread of haskell knowledge ;)
07:24:46 <monadic> kmc: Yes, I know. But first I want to get this done :) then I'll benchmark
07:24:50 <monadic> those encodings
07:24:51 <kmc> fair enough
07:24:53 <bxc> vharishankar: but go find something you want to do and do it
07:24:54 <simon> vharishankar, if you pick a type of application and learn to write it, you'll learn parts of the standard library that are significant to your goals. it helps remembering an API when you have a practical use for it that you attach it to.
07:25:10 <vharishankar> SimonRC: thanks.
07:25:22 <vharishankar> I'm sorry simon
07:25:27 <vharishankar> bxc: thanks.
07:25:58 <vharishankar> kmc: actually Haskell is kind of a hobby for me. I'm not too keen on mathematics though.
07:26:01 <simon> vharishankar, like... write an interpreter for a toy language, write a small game, etc.
07:26:13 <bxc> if you like hanging out on irc, write an IRC client
07:26:20 <vharishankar> simon yes, I actually thought of that.
07:26:27 <simon> yup. I used to always write IRC clients in new languages.
07:26:44 <kmc> i still don't understand why you'd learn a programming language if you don't like to program
07:26:53 <vharishankar> kmc: I like to program.
07:27:03 <kmc> then you probably have some things you want to program
07:27:25 <kmc> most people I know who enjoy programming have more ideas than time
07:27:27 <vharishankar> kmc: I also like to draw, but I don't always get inspiration. :-)
07:27:30 <bxc> vharishankar: what was the last program you wrote?
07:27:46 <vharishankar> bxc: I've written a lot of programs in Python -
07:27:58 <vharishankar> you can find some of it in my website at http://harishankar.org/software
07:28:26 <vharishankar> bxc: I'm also currently trying to write a game in Python/pygame. :-)
07:28:27 <kmc> maybe you can rewrite one in Haskell
07:28:32 <kmc> or extend it in some way
07:29:10 <vharishankar> kmc: agreed. I am just at that stage when I'm not quite sure how skilled I am in Haskell, so... trying to take it in small steps. :-)
07:29:11 <kmc> i mean this is a hard problem for Haskell
07:29:17 <parcs> vharishankar: write a chat server. it will demonstrate how easy and powerful concurrency is in haskell
07:29:24 <kmc> because for a beginner any interesting problem at all seems too hard
07:29:39 <vharishankar> kmc: yes, a bit like that.
07:29:42 <bartavelle> Will this be possible in reasonnable time to happy/alex working both with the monadic variant of what they are doing if I'm still afraid of monads ?
07:29:42 <kmc> vharishankar, maybe you can take a small part of one of those python programs as your small step
07:30:12 <bartavelle> because the alex / happy documentation is seriously lacking for clueless people like me
07:30:14 <vharishankar> parcs: thanks. I am not sure of how to write client/server programs in any language. :-)
07:30:32 <bxc> vharishankar: start with an IRC client, then
07:30:34 <kmc> vharishankar, have you read RWH? it might give you some project ideas and tools for approaching those projects
07:30:37 <vharishankar> kmc: OK.
07:30:45 <bxc> vharishankar: its a relatively straightforward protocol and it'll teach you how to write the client side at least
07:30:45 <kmc> I also advise, if you want to learn Haskell, that you spend some time away from #haskell
07:30:58 <vharishankar> kmc: OK.
07:30:59 <kmc> and away from blogging about how you're learning haskell
07:31:04 <kmc> not that your blog posts aren't valuable
07:31:08 <vharishankar> bxc: Thanks.
07:31:13 <kmc> but it's easy to get distracted worrying about how to learn and whether you're doing it right
07:31:16 <kmc> i see that a lot here
07:31:19 <parcs> vharishankar: networking isn't very hard, especially in haskell
07:31:24 <kmc> people who ask every day what they should learn, and then don't learn any of it
07:31:33 <monadic> Oh great when people say monadic it tags the message as being sent to me
07:31:38 <vharishankar> parcs: OK, I'll give it a shot.
07:31:46 <vharishankar> kmc: you've raised some interesting points.
07:31:51 <bxc> also there's some CGI stuff so you can write CGIs in haskell
07:31:53 <bartavelle> monadic,  I suppose this should happen a lot here ...
07:31:58 <bxc> which is fun if you want to put stuff online for others to look at
07:32:10 <vharishankar> Yes, RWH is great. In fact, it gives me more insight when I read in leisure.
07:32:10 <osfameron> monadic: heh
07:33:43 <vharishankar> kmc: I've got as far as writing a postfix expression evaluator (on my own) in Haskell.
07:33:48 <kmc> cool
07:34:11 <vharishankar> It's not like I'm not learning but suddenly I read some advanced concept and feel I know nothing.
07:34:25 <vharishankar> Maybe just focus on the book, chapter by chapter.
07:34:28 <kmc> yes
07:34:35 <kmc> there are many advanced concepts you could learn
07:34:41 <kmc> but you don't need them all in order to make useful software
07:35:31 <kmc> you will never run out of advanced concepts to learn
07:35:34 <vharishankar> quite true.
07:35:35 <kmc> not even if you study Haskell for 20 years
07:35:55 <kmc> it's really a much more general statement, not just about haskell
07:36:09 <bartavelle> when I do that : http://www.haskell.org/happy/doc/html/sec-monads.html#sec-exception, why can't I write a "case" block like in "catchE" ? It complains it doesn't know of Ok and Failed, and I can't seem to find the syntax to export them ...
07:36:10 <vharishankar> kmc: agreed.
07:36:16 <Nimatek> That's true for programming in general. Advanced concepts are not that dependent on language.
07:36:40 <parcs> haskell is pretty researchy though
07:36:43 <bartavelle> (obviously that's in a distinct module that I'm trying to do this)
07:37:37 <kmc> haskell is the language in which much of the interesting PL research is done
07:37:57 <kmc> doesn't mean those concepts are actually haskell-specific
07:38:47 <vharishankar> kmc: Haskell has kind of caught my fancy. I must get back down to earth. :-)
07:38:51 <kmc> it's like learning latin to read scientific articles, hundreds of years ago
07:39:00 <kmc> the science isn't about latin, but that's the language they use
07:39:43 <kmc> (except that programming languages vary more widely than natural languages, in the ability to represent concepts)
07:39:58 <monadic> kmc: Trying to benchmark but I don't have an NFData instance for ByteString
07:40:06 <monadic> and I don't think that whnf will do it
07:40:21 <vharishankar> kmc: One thing I must do is mentally unwind. Haskell has got my brain into over-drive.
07:40:25 <kmc> (so while people could and did translate those Latin articles to French, you can't really translate all the Haskell-language PL research to Java and expect anyone to like the result)
07:40:35 <vharishankar> Maybe that explains my slight anxiety to "learn" more...
07:40:39 <kmc> monadic, why not?
07:40:50 <kmc> strict bytestring?
07:40:55 <kmc> then asking for the first byte should be enough
07:40:59 <monadic> kmc: Well I guess it is a strict bytestring
07:41:28 <monadic> kmc: I fear that stream fusion may ruin this benchmark
07:41:32 <kmc> heh
07:42:04 <monadic> interesting... utf8 wins by a landslide
07:42:15 <kmc> heh
07:42:17 <monadic> but it performs less well in a -O3 than in runhaskell
07:42:20 <kmc> memory bandwidth > all things
07:42:22 <kmc> woah
07:42:30 <kmc> is your text mostly ascii?
07:42:41 <monadic> oh oops you are right
07:42:48 <monadic> yeah I just replicated a's :P
07:43:58 <monadic> Even with half-ASCII half-unicode (I used π) it still beats the rest
07:44:29 <monadic> however -O3 now is better
07:44:30 <kmc> that's half-ascii, all unicode ;P
07:44:42 <monadic> I mean half-ascii, half-only-unicode
07:44:49 <kmc> sorry, I know I'm being pedantic
07:45:22 <monadic> https://gist.github.com/1345332 if you are interested is the results
07:45:44 <monadic> it wins by a factor of 10 :\
07:46:34 <quicksilver> interesting.
07:47:03 <monadic> it has a much smaller standard deviation too - factor of 100. So not only is it faster, it is more consistent
07:47:58 <monadic> the utf16's have ranges of like .5ms
07:48:45 <quicksilver> very surprised by the size of the difference; either something is badly wrong with one code path or you are right on a cache size boundary or something
07:48:46 <kmc> monadic, very interesting
07:49:04 <quicksilver> try halving your demo data set so that utf16 fits in the same physical space as utf8 did.
07:49:59 <monadic> on it
07:50:42 <monadic> ~100 micros vs ~900 micros using half the data set on the 16 versions
07:50:47 <monadic> I'm going to gist up the code
07:51:04 <perra> hi guys!!!!
07:51:28 <monadic> https://gist.github.com/1345354
07:52:40 <cauamero> hi
07:52:49 <perro> que onda cauamero
07:52:53 <cauamero> whta's up
07:52:59 <perro> ¬¬
07:54:14 <vharishankar> Anyway, thanks a lot for all your inputs.
07:55:50 <kmc> monadic, I get similar results
07:56:00 <monadic> kmc: This is odd
07:56:20 <monadic> kmc: I think I might have actually seen some encoding benchmarks on BOS's blog
07:56:27 <kmc> one theory is that people care a lot more about utf-8
07:56:36 <kmc> and so more effort has gone into optimizing that code
07:58:13 <cauamero> saquen las chelas
07:58:15 <vharishankar> kmc: thanks as always. I'll follow your advice and keep away from #haskell for a while, until I read RWH a little more.
07:59:31 <quicksilver> perro, cauamero: Hi; this channel is for discussing the Haskell programming language, are you learning to write Haskell?
07:59:36 <monadic> I found a blog post on the Text performance but... its empty
07:59:36 <quicksilver> bos: speak of the devil ;)
07:59:39 <monadic> :\
07:59:41 <rotflcopter> hii
07:59:45 <bos> wut?
07:59:51 <monadic> bos: We are interested about the performance of encodings on Text
08:00:06 <kmc> seems that encoding utf-8 is an order of magnitude faster than encoding utf-16
08:00:09 <quicksilver> bos: monadic has just shown that utf8 encode/decode is 900% fast than utf16 (Data.Text.Encoding)
08:00:11 <monadic> bos: We ran a benchmark on a half-ASCII half-non-ASCII text input and utf16 variants were significantly slower
08:00:13 <quicksilver> bos: are you suprised?
08:00:22 <bos> i'm not surprised at all.
08:00:33 <bos> i put far more work into making the UTF-8 decoder fast.
08:00:40 * kmc called it.
08:00:42 <monadic> Look's like kmc's prediction was correct then
08:00:45 <bos> since it's >> 100x more common than UTF-16.
08:01:08 <perro> if  I want to learn the language
08:01:24 <quicksilver> bos: even on windows?
08:01:41 <bos> quicksilver: as far as i know.
08:01:47 <quicksilver> interesting.
08:01:57 * quicksilver thought he'd heard windows <3 utf16, but has no personal experience.
08:02:13 <vharishankar> perro: Get a copy of Real World Haskell. http://www.amazon.com/Real-World-Haskell-Bryan-OSullivan/dp/0596514980
08:02:14 <bos> besides, the UTF-16 decoder is susceptible to the same techniques as the UTF-8 decoder, if anyone cared to implement them.
08:02:28 <zetan> hi
08:02:34 <kmc> bos, we were talking about encoding, not decoding
08:02:35 <perro> thanks!
08:02:36 <koala_man> quicksilver: it's widely used internally and in apis, but not so much in userland
08:02:38 <monadic> UTF-16 is used for text used in the OS API in Microsoft Windows 2000/XP/2003/Vista/CE.[
08:02:49 <vharishankar> perro: or read this excellent tutorial http://learnyouahaskell.com/chapters
08:03:08 <bos> kmc: ah. same difference, really.
08:03:10 <quicksilver> koala_man: ah.
08:03:11 <kmc> userland wchar_t is UTF-16 on Windows, is it not?
08:03:13 <vharishankar> perro: the second one is also available as a book.
08:03:15 <kmc> (or UCS-2 maybe)
08:03:30 <monadic> kmc: According to Wikipedia, UTF-16
08:03:36 <kmc> that's... awkward
08:03:53 <monadic> oh and according to msdn.
08:04:16 <kmc> are wchar_t arrays supposed to be random-indexable as character arrays?
08:04:25 <perro> thanks vharshankar
08:04:28 <monadic> bos: Also some of your blog posts seem to be mysteriously empty with only comments :\
08:04:32 <bos> kmc: no
08:04:43 <bos> monadic: really? do you have a URL i could check for that, please?
08:04:50 <monadic> bos: Yes, one second, let me find it
08:05:06 <monadic> bos: This is one of them: http://www.serpentine.com/blog/2011/06/03/attoparsec-0-9-a-major-release/
08:05:10 <bos> monadic: thanks. i moved blog hosts, must have misconfigured something.
08:05:42 <monadic> Was searching for that post on the Text Benchmarks earlier, it was empty too
08:05:49 <bos> monadic: ok, cool.
08:07:04 <bos> monadic: just fixed that one. i'll look for other offenders later. thanks!
08:07:11 <monadic> bos: No problem
08:08:34 <monadic> The enumerator package docs talk about how just about everything is being removed in enumerator-5, is there any documentation on what the version 5 API will be like?
08:10:11 <ben> Aren't those the things that got moved to Data.Enumerator.List/.Binary/.Text?
08:10:35 <monadic> ben: It's the operators too though, I don't think they got moved anywhere
08:11:29 <monadic> Operators
08:11:33 <simon> how do I refer to unary -? (-) seems to reflect Num a => a -> a -> a.
08:11:33 <monadic> Compatibility note: Most of these will be obsoleted by version 0.5. Please make sure your .cabal files have a <0.5 limit on the enumerator dependency.
08:11:41 <ski> simon : `negate'
08:11:41 <sadgur> subtract
08:11:45 <sadgur> ah
08:11:47 <sadgur> that's it
08:11:49 <sadgur> ha
08:11:51 <ski> also, `\x -> - x'
08:12:34 <simon> ski, is negate in Prelude?
08:12:37 <ski> yes
08:12:40 <ski> @index negate
08:12:41 <lambdabot> Prelude
08:23:00 <mah_b> Hi, could someone point me to a nice latex listings style for typesetting haskell code? The existing one shows an interesting understanding of what keywords are.
08:23:39 <sipa> lhs2tex :)
08:30:26 <kmc> mah_b, http://mainisusuallyafunction.blogspot.com/2011/08/new-slides-and-how-i-made-them.html
08:30:32 <kmc> see bottom
08:32:22 <mah_b> kmc: thank you, I like it
08:35:08 <hpaste> nameless pasted “alps” at http://hpaste.org/53703
08:36:02 <quicksilver> kmc: is a finalizer really the right way to do that? (the newUD stuff)
08:36:48 <Abraxas> that was my hpaste just now
08:37:27 <Abraxas> can someone explain to me why for the function mountains the parameter (Down End) works, but (Up End) doesn't?
08:37:50 <Abraxas> it is not supposed to be called that way, but i don't really get what's the difference
08:37:53 <k0ral> say I define a type class A which defines function f A :: Something; can I make the following datatype an instance of A: data B = B {f :: Something} ?
08:38:14 <mauke> k0ral: huh?
08:38:28 <quicksilver> Abraxas: "Up" only works on types of the form Mountains (Succ k)
08:38:44 <zetan> hola edgar
08:38:49 <quicksilver> Abraxas: End is of type Mountains (Zero) which is not Mountains (Succ k)
08:39:02 <erzh> Hola Pablo!!
08:39:21 <k0ral> I mean: can I use the automatically generated functions from a datatype as functions to implement an instance of a type class ?
08:40:06 <monadic> k0ral: Do you mean like NewtypeDeriving
08:40:36 <monadic> -is confused-
08:41:20 <k0ral> NewTypeDeriving ?!
08:41:27 * k0ral is confused too
08:41:46 <k0ral> let me rephrase it
08:42:07 <ecuageo> wow, there are more users in #haskell than in #ruby
08:42:23 <k0ral> class A a where f a :: Something
08:42:25 <Peaker> wow, more than #python now too!
08:42:38 <k0ral> data B = B (f :: Something)
08:42:46 <kmc> quicksilver, well, I'm not positive... what would you propose instead?
08:42:51 <k0ral> I then an existing f :: B -> Something
08:42:53 <monadic> ecuageo: Probably because we confuse more people in here... Haha
08:42:53 <Peaker> which programming channels are still bigger than #haskell?
08:43:04 <k0ral> can I do instance A B ?
08:43:06 <quicksilver> kmc: explicit free which is hidden by the higher level API
08:43:19 <quicksilver> k0ral: well your syntax is all wrong.
08:43:30 <quicksilver> k0ral: if I guess at what I think you might be asking then the answer is :
08:43:34 <kmc> quicksilver, well, there is a level below as well
08:43:41 <quicksilver> yes, you can write the instance, but nothing writes it for you. YOu have to write it yourself.
08:43:57 <quicksilver> kmc: my (irrational) instincts tell me finalizers are almost always wrong.
08:43:59 <k0ral> quicksilver: sorry for the syntax mistakes
08:44:10 <kmc> quicksilver, well, this one really is just cleaning up memory
08:44:10 <k0ral> quicksilver: I'm aware of them but I just did want to make my point
08:44:19 <quicksilver> k0ral: perhaps you meant class A a where f :: a -> Something ?
08:44:33 <Abraxas> ok, i got confused by what Down maps to, but that doesn't matter
08:44:48 <k0ral> quicksilver: oh yes, this error isn't only syntactic actually
08:44:55 <Abraxas> basically this mean, there has to be a Down before an Up, right
08:44:59 <quicksilver> and data B = B { f :: Something }
08:45:09 <quicksilver> then instance A B where f = f
08:45:10 <k0ral> quicksilver: indeed
08:45:17 <quicksilver> except that you have used the same name 'f' for two things
08:45:29 <quicksilver> but rename one of them or put it in a different modulate and that's fine.
08:45:38 <quicksilver> doesn't look like a useful type class though.
08:45:39 <k0ral> that's even better :)
08:45:44 <Abraxas> which doesn't make sense to me
08:46:05 <k0ral> quicksilver: I want to expose a data type to the user but I want him to be able to extend it
08:46:44 <quicksilver> kmc: if it is only memory maybe that's fine
08:48:42 <siracusa> Peaker: #jquery as far as I can see
08:48:49 <Abraxas> is there some way to make this work in a stepeval?
08:49:12 <parcs> #python is slightly bigger
08:49:16 <Peaker> siracusa: wow, surprisingly big
08:49:24 <Peaker> parcs: was smaller just a short while ago :)
08:49:26 <Abraxas> i guess i don't have a clue what it's doing, exactly
08:49:31 <parcs> hehe
08:51:32 <chrisdone> is there already have a function to print number extensions st,nd,rd,th, etc in a library somewhere?
08:51:48 <chrisdone> if not, i don't know what module name to use
08:52:25 <ben__> "stndrdth" imo
08:52:54 <dylex> chrisdone: they're called ordinals, if that helps
08:53:03 <dolio> What do those signify?
08:53:13 <dolio> Oh, wait, I see.
08:53:25 <dolio> preflex: 6st 1 2 3 4 5 6 7 8 9 10
08:53:25 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th 9th 10th
08:54:21 <quicksilver> perlers call it Lingua::EN::Inflect
08:54:39 <quicksilver> well that's a package of languagy things, the stndrdth part is called 'ord'
08:54:53 <quicksilver> ORD rather
08:55:51 <ocharles> Hrm, someone mentioned a database library that begins with "g". I can't see anything matching on hackage... does anyone have any idea what I could be on about from that limited information? :)
08:56:40 <dylex> ocharles: gdbm?
08:56:54 <ocharles> hrm, no
08:56:57 <ocharles> had a pronouncable name
08:57:03 <quicksilver> none of the following begin with g. Or even contain gs:takusen, hdbc, haskelldb, macid
08:57:08 <mauke> google
08:57:16 <quicksilver> yet, they are the ones I hear about most often
08:57:48 <ocharles> mmm, it was mentioned to me when edward kmett said "ewww, SQL as strings" to me, and I said I wanted something that was like a EDSL for SQL, but not HaskellDB
08:57:59 <ocharles> and I'm sure the name he mentioned I'd heard dropped in #snapframework too
08:59:15 <ben__> > let o = "th":"st":"nd":"rd":replicate 6 "th" ; ords = o ++ replicate 10 "th" ++ cycle o in zipWith ((++) . show) [0..100] ords
08:59:16 <lambdabot>   ["0th","1st","2nd","3rd","4th","5th","6th","7th","8th","9th","10th","11th",...
08:59:31 <Abraxas> is the benmachine the most powerful stepeval tool?
09:00:18 <_mpu> Hi, I use (\_ -> ()) . length to force the contents of a list to be evaluated, is it correct ?
09:00:27 <quicksilver> no.
09:00:52 <monadic> _mpu: This is what Deepseq is for
09:01:06 <chrisdone> ocharles: needs more haskelldb
09:01:06 <quicksilver> > (\_ -> ()) . length $ ("if this list was evaluated it would cause an error" ++ error "but it isn't")
09:01:08 <lambdabot>   ()
09:01:54 <monochrom> \∩/
09:02:09 <_mpu> > (\_ -> ()) . length $ ("if this list was evaluated it would cause an error" ++ error "but it  isn't")
09:02:10 <lambdabot>   ()
09:02:18 <_mpu> > (\_ -> ()) . length $! ("if this list was evaluated it would cause an error" ++ error "but it  isn't")
09:02:20 <lambdabot>   ()
09:02:24 <monochrom> \∩/
09:02:36 <mauke> > (\_ -> () . error $ "lol wut"
09:02:36 <_mpu> > length $! ("if this list was evaluated it would cause an error" ++ error "but it  isn't")
09:02:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:02:38 <lambdabot>   *Exception: but it  isn't
09:02:42 <copumpkin> _mpu: length won't technically force the entire list
09:02:42 <sipa> > length (map error "test")
09:02:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:02:43 <lambdabot>         against inferred ty...
09:02:46 <mauke> > (\_ -> ()) . error $ "lol wut"
09:02:48 <lambdabot>   ()
09:03:00 <_mpu> copumpkin: why ?
09:03:07 <copumpkin> > length (map undefined "test")
09:03:08 <lambdabot>   4
09:03:12 <sipa> > length (map (\x -> error [x]) "test")
09:03:13 <lambdabot>   4
09:03:24 <_mpu> but my objects are char
09:03:35 <geheimdienst> _mpu: could you tell us more about why you want to "evaluate" the list?
09:03:36 <_mpu> so it will do the job :)
09:03:40 <copumpkin> > length ('a':'b':undefined:'d':[])
09:03:40 <lambdabot>   4
09:03:45 <copumpkin> :t ('a':'b':undefined:'d':[])
09:03:46 <lambdabot> [Char]
09:03:48 <mauke> evaluate (length list);
09:03:51 <_mpu> geheimdienst: to be able to close the file
09:04:00 <mauke> _mpu: don't use lazy I/O then
09:04:04 <ben__> > foldr seq () ('a':'b':undefined:'d':[])
09:04:04 <lambdabot>   *Exception: Prelude.undefined
09:04:44 <_mpu> mauke: this is the default framework and I'm definitely not an expert :)
09:06:19 <_mpu> > (\_ -> ()) . seq . length $ ("if this list was evaluated it would cause an error" ++ error "but it  isn't")
09:06:21 <lambdabot>   ()
09:06:28 <_mpu> so hard to make it work ...
09:06:56 <mauke> _mpu: (\_ -> ()) is what breaks it
09:07:07 <_mpu> mauke: yes
09:07:20 <dolio> (\_ -> ()) . f = (\_ -> ())
09:07:26 <dolio> For all f.
09:07:34 <quicksilver> mauke: you
09:07:36 <quicksilver> sry
09:07:46 <quicksilver> _mpu: if you want to control evaluation you will need to use seq or evaluate.
09:07:59 <quicksilver> it would be better just not to use the broken lazy IO in the standard library.
09:08:12 <copumpkin> rnf works too
09:08:17 <dolio> Or use it correctly.
09:08:21 <_mpu> quicksilver: what do you recommand
09:08:39 <quicksilver> possibly a strict bytestring read
09:08:45 <_mpu> dolio: how ? I don't want my application to leak resources
09:08:59 <quicksilver> dolio: (for some value of =)
09:09:14 <dolio> Extensional equality.
09:09:51 <_mpu> leibniz fails, that's what remains...
09:10:20 <dolio> I don't know your program. Maybe lazy I/O is completely inappropriate.
09:10:57 <_mpu> dolio: my program is my window manager :) I want to launch dmenu and GET the result!
09:12:58 <geheimdienst> _mpu: i'm fairly happy with XMonad.Prompt, once you get the hang of configuring it
09:13:23 <geheimdienst> ... but that's really sidestepping the question of what to do against lazy i/o. i don't know about that, sorry
09:13:29 <_mpu> geheimdienst: ty, but I want to hack my xmonad myself :)
09:13:56 <PatrickRobotham> Hi everyone. Is there a more elegant way of doing binary search guessing than this? http://hpaste.org/53707
09:15:33 <quicksilver> _mpu: well the answer is length list `seq` whatever you reallyw ant to do
09:15:39 <mah_b> is there some function that returns a random permutation of a given list?
09:15:40 <quicksilver> length list `seq` list, possibly
09:15:55 <quicksilver> then if the list is inspected at all, the spine will be forced to the end.
09:16:15 <bscarlet> _mpu: what are you using to execute dmenu?
09:16:30 <_mpu> bscarlet: runInteractiveProcess
09:19:32 <dmwit> _mpu: I didn't read all the way back, but in case you're talking about xmonad, you might like XMonad.Prompt
09:19:47 <dmwit> _mpu: Or XMonad.Util.Dmenu
09:20:42 <dmwit> _mpu: (Those take care of a few other things that are important in the xmonad context, like masking signal handlers and stuff.)
09:20:43 <edwardk> it seems somewhat sad that the length of my language pragmas in a recent module exceeded the length of the rest of the module
09:20:57 <dmwit> We need more metapragmas.
09:21:23 <quicksilver> edwardk: what is a database module beginnign with 'g' that has an eDSL for SQL?
09:21:25 <mah_b> PatrickRobotham: you could shrink nextguess to 4 lines using patterns for ans and upper.
09:21:35 <geheimdienst> edwardk: the proper proportions for haskell code is 2:5:1 pragmas : imports : code
09:21:47 <monochrom> write an essay to explain why you use those pragmas, so that the internal documentation is yet longer than the pragmas.
09:22:08 <edwardk> gosh-i-dont-know ? =)
09:22:16 <_mpu> dmwit: I read this code, and I mask signal handlers :)
09:22:17 <quicksilver> edwardk: apparently you do.
09:22:37 <_mpu> edwardk: sorry I missed my target...
09:22:43 <_mpu> oops
09:22:57 <edwardk> _mpu: yes, yes you did =)
09:22:59 <quicksilver> 17:04 < ocharles> Hrm, someone mentioned a database library that begins with "g". I can't see anything matching on hackage... does anyone have any idea what I could be on about from that limited information? :)
09:23:03 <quicksilver> 17:06 < ocharles> mmm, it was mentioned to me when edward kmett said "ewww, SQL as strings" to me, and I said I wanted something that was like a EDSL for SQL, but not HaskellDB
09:23:06 <quicksilver> edwardk: ^^
09:23:10 <kmc> you dreamed of it
09:23:24 <edwardk> i think i mentioned that gershom had something perhaps
09:23:32 <edwardk> but i was talking about a person =)
09:23:33 <dmwit> _mpu: Why would you go through all of the trouble of figuring out how to mask signal handlers, handle strictness, and find other inevitable bugs when the code is already written *and* you already knew about it?
09:23:43 <dylex> mah_b: nothing in base, but there are a a few shuffle implementations on hackage.  I tend to use a O(n) ST-based one.
09:24:02 <edwardk> at least that is the context i can re-intuit from the comment there
09:24:16 <quicksilver> edwardk: ah, ok.
09:24:27 <quicksilver> I've not heard of anything other than haskelldb myself
09:24:55 <parcs> i think youre talking about groundhog
09:24:55 <yitz> dmwit: propose pragma aliases
09:25:07 <edwardk> quicksilver: not sure if he's released it
09:25:48 <paolino> @pl  \(x:xs) y -> (xs,(x,y))
09:25:48 <lambdabot> ap (flip ((.) . (,)) . (,) . head) tail
09:25:51 <mah_b> dylex: do you have a link/package name?
09:25:59 <quicksilver> edwardk: I'm not familiar with a haskeller called gershom. Does he have an IRC nick I'd recognise?
09:26:30 <edwardk> sclv
09:27:21 <ocharles> edwardk: oh, that might of been it :)
09:27:36 <quicksilver> sclv's sterling clover isn't he?
09:27:43 <ocharles> quicksilver: and yes, mightybyte suggest groundhog, but it's sadly not quite what I want either
09:27:52 <ocharles> suggested*
09:27:54 <quicksilver> evidently not.
09:28:09 <quicksilver> erm
09:28:11 <quicksilver> yes it is.
09:28:15 <edwardk> quicksilver: that was a pseudonym that he let peel away
09:28:22 <quicksilver> oh
09:28:26 <quicksilver> right.
09:28:36 * quicksilver adds another node to The Identity Graph
09:28:41 <edwardk> something about when he got into the haskell community he used the name he'd used in some music community or other
09:28:42 <ocharles> edwardk: so what's gershom working on?
09:28:44 <quicksilver> and dispatches new version to all agents.
09:29:39 <dylex> mah_b: random-extras, random-shuffle, or you could use permutation to write one a bit better.  I ended up just writing my own.
09:30:28 <paolino> @pl  \(x:xs) _ -> (xs,x)
09:30:28 <lambdabot> ap ((const .) . flip (,) . head) tail
09:31:22 <paolino> @type  \(x:xs) _ -> (xs,x)
09:31:22 <lambdabot> forall t t1. [t] -> t1 -> ([t], t)
09:31:26 <edwardk> ocharles: he works at deutsche bank work with jeff polakow (not sure if that got through before i got disconnected)
09:31:31 <danr> @type const (tail &&& head)
09:31:32 <lambdabot> forall a b. b -> [a] -> ([a], a)
09:31:52 <danr> @type flip const (tail &&& head)
09:31:53 <lambdabot> forall b. b -> b
09:31:57 <danr> oops
09:32:18 <dmwit> flip const = const id
09:32:22 <ocharles> edwardk: right, but he's working on some db/sqly stuff?
09:32:32 <mah_b> dylex: have seen them, but none of them imho offers O(n)
09:32:32 <danr> dmwit: yeah I know :)
09:32:51 <paolino> @type flip $ const (tail &&& head)
09:32:51 <lambdabot> forall a b. [a] -> b -> ([a], a)
09:32:59 <danr> that's what I meant
09:33:00 <hpaste> dylex pasted “random shuffle” at http://hpaste.org/53711
09:33:08 <edwardk> ocharles: they do lots of crazy things there. they probably do more abusing of hlists than anyone elsewhere on the planet
09:33:22 <edwardk> ocharles: but for the most part its writing tools to support traders
09:33:34 <paolino> @type mapAccumL . flip $ const (tail &&& head)
09:33:35 <lambdabot> forall x a. [a] -> [x] -> ([a], [a])
09:33:56 <edwardk> by abusing hlists i mean 30 minute compile times ;)
09:34:01 <ocharles> ah, ok :)
09:36:06 <dylex> mah_b: hm, that might depend on some other things, but it's the right idea
09:38:02 <paolino> @type snd . Data.Traversable.mapAccumL . flip $ const (tail &&& head)
09:38:03 <lambdabot>     Couldn't match expected type `(a, b)'
09:38:03 <lambdabot>            against inferred type `a1 -> t b1 -> (a1, t c)'
09:38:03 <lambdabot>     In the first argument of `(.)', namely `Data.Traversable.mapAccumL'
09:38:49 <paolino> @type (snd .) . Data.Traversable.mapAccumL . flip $ const (tail &&& head)
09:38:49 <lambdabot>     Couldn't match expected type `(a, b)'
09:38:50 <lambdabot>            against inferred type `t b1 -> (a1, t c)'
09:38:50 <lambdabot>     Probable cause: `Data.Traversable.mapAccumL' is applied to too few arguments
09:40:32 <angstrom> > (\n -> take n [ take n $ replicate x 0 ++ [1] ++ [0,0..] | x <- [0..] ]) 5
09:40:33 <lambdabot>   [[1,0,0,0,0],[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1]]
09:40:43 <Peaker> @type flip . const
09:40:44 <lambdabot> forall a b b1. (a -> b) -> a -> b1 -> b
09:42:16 <parcs> is there an efficient (O(log n)) way of implementing the function filterOrd :: Ord k => Ordering -> (k -> Ordering) -> Map k a -> Map k a ?
09:42:55 <MostAwesomeDude> parcs: What does it do, exactly?
09:43:12 <Peaker> parcs: If (k -> Ordering) is free to use a different one from the Ord instance of k, then surely that can't be possible to implement?
09:44:35 <parcs> Peaker: oh right.. maybe something like Ord k => Ordering -> k -> Map k a -> Map k a then?
09:44:37 <_mpu> is Prelude.catch really deprecated
09:44:38 <Abraxas> for this hpaste: http://hpaste.org/steps/53703   can someone help me understanding the simple call map mountains ((generate 1) :: [Alps])?
09:44:52 <edwardk> parcs: well, you can always use the map split functions if need be
09:45:03 <copumpkin> parcs: you mean something that splits the map based on that key?
09:45:12 <edwardk> partition on k then choose what to do with the split point
09:45:12 <parcs> oh! haha
09:45:13 <Abraxas> i end up getting [] in the call of generate 1
09:45:15 <parcs> i guess i do
09:45:16 <copumpkin> parcs: Map actually uses functions almost exactly like that in its implementation
09:45:28 <copumpkin> but I don't think they're exported
09:46:08 <rwbarton> :t Data.Map.split
09:46:09 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
09:46:10 <parcs> MostAwesomeDude: i was basically looking for a specific version of Data.Map.split
09:46:16 <parcs> but split will do fine
09:46:23 <Cale> Abraxas: I can try
09:46:29 <MostAwesomeDude> parcs: Ah, I see.
09:46:36 <Abraxas> generate 1 has to be of type Mountain Zero, so generate 1 is called with the instance of Generate Zero, right?
09:47:46 <Abraxas> which should be this: map Up (generate(0))::Mountains(Succ k) ++ map Equal (generate(0))::Mountains k
09:47:46 <Cale> Abraxas: yeah
09:48:13 <Abraxas> i have weird brackets in there...
09:50:05 <Abraxas> which means those generate(0) are definitely not an instance of Generate Zero?
09:50:39 <Abraxas> therefore the other instance is used and that always returns []
09:51:04 <Cale> Well, it'll be whatever it has to be in order to typecheck :)
09:51:27 <_mpu> catchAll d m = m `catch` (const $ return d :: SomeException -> IO a)
09:51:36 <_mpu> why isn't this working ?
09:52:11 <Abraxas> the first one is Generate (Succ k), the second one is Generate k ?
09:52:25 <Cale> So we know that  map Up (generate (n-1)) :: [Mountains Zero], and Up :: Mountains (Succ k) -> Mountains k, so  map Up :: [Mountains (Succ k)] -> [Mountains k], and hence k = Zero here.
09:52:31 <Abraxas> the parameter of Mountains is passed to the Generate
09:53:19 <Cale> and generate (n-1) :: [Mountains (Succ Zero)] in this case
09:53:25 <paolino> :t catch
09:53:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:54:01 <fhmp> Hi could someone help me with my signatur?  It should be what it is now, but it is not running...
09:54:01 <fhmp> durchschnitt :: [Integer] -> Integer
09:54:01 <fhmp> durchschnitt liste = div (sum liste) (length liste)
09:54:24 <mauke> fhmp: length returns Int, not Integer
09:54:26 <paolino> _mpu you have ScopedTypeVariables ?
09:54:37 * copumpkin learned a word of german today
09:54:46 <mauke> fhmp: you can use (fromIntegral (length liste))
09:54:49 <fhmp> ok, is there an alternative for Integer?
09:55:14 <Cale> Or if you import Data.List, you can use genericLength
09:55:26 <Cale> It's really sad that length doesn't use Integer
09:55:28 <mauke> > let länge = genericLength in länge [1,2,3]
09:55:28 <lambdabot>   3
09:55:42 <Cale> mauke: heh
09:55:44 <copumpkin> Cale: or natural
09:55:53 <_mpu> paolino: no
09:55:53 <Abraxas> mmmh
09:56:31 <_mpu> :t guard
09:56:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:56:52 <paolino> you need that for the signature maybe and a forall a. in front of the signature if it is the case
09:57:31 <big_dog> Riggy dick diggy!
09:57:38 <big_dog> I mean in ancient times the Egyptians used hard muscle-demanding labor to create large pyramids... and stone age people, the neanderthals, needed to burn 5000-6000 calories a day to survive
09:57:40 <big_dog> But now people at Amazon use fork lifts, or skyscraper builders use heavy machinery
09:57:43 <big_dog> heavy machinery by companies like Hitachi or Kabuto or C.A.T. or whatever requires some object movement by people to make but not that of bodybuilders
09:57:44 <yitz> Cale: do you prefer Integer to Integral a for length (like generic)?
09:57:46 <big_dog> But now all weight lifting is good for is police, military, or football/sports players
09:57:49 <big_dog> Police don't really "contribute" and product to society, but it's always good pay and it's sort of needed
09:57:51 <big_dog> Military is a waste of time and money
09:57:56 <big_dog> And football players are like playing video games only in real life
09:57:56 <big_dog> Throwing a ball around doesn't help other people no matter how much someone is paid
09:57:56 <big_dog> Police are mostly worthless
09:57:57 <big_dog> Football is like a virus to the world
09:57:58 <big_dog> What if I throw your balls around?
09:57:59 <big_dog> Police don't deter crime
09:58:00 <kmc> @where ops
09:58:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:58:03 <big_dog> They just mop up and catch the crooks
09:58:06 <big_dog> Sometimes
09:58:08 <big_dog> I look at the future and think: Computers will be obsolete because brain implants will replace them
09:58:08 --- mode: ChanServ set +o mauke
09:58:08 --- kick: big_dog was kicked by mauke (big_dog)
09:58:10 <Cale> yitz: I'd be okay with either of those
09:58:19 --- mode: ChanServ set +o dcoutts
09:58:22 <big_dog> N c    F ` o +  K  S 3  n n S  Z F , M n H = x  _ B < ( h Z n w  A X + " l S } +  j 4 Q  ] K o    ? . I ^ T U T \
09:58:25 <big_dog> O f  D & ^ +   w N \ ? ~ % ?   : ? | B u ) t C  J X ^ k ; q - ?    O n y X T d .  {  J } m a ; ?   U | ) m g = n
09:58:25 --- mode: dcoutts set +b *!*regnorgs@182.7.102.218
09:58:25 --- kick: big_dog was kicked by dcoutts (big_dog)
09:58:37 <parcs> tsk tsk
09:58:51 <Cale> Abraxas: okay, I understand what this program is computing now :)
09:58:58 --- mode: mauke set -o mauke
09:59:29 --- mode: ChanServ set -o dcoutts
10:00:22 <Cale> Abraxas: Mountains k is the type of mountainous paths which doesn't go below level 0, and starts at level k
10:00:26 <Phyx-> heh, i wonder.. what's the point of a bot like that
10:00:29 <cheater> i think i would be much happier with life if big_dog's spam didn't look like maxima code.
10:00:47 <dcoutts> Phyx-: the lols?
10:01:04 <Cale> That was clearly a dc program
10:01:07 <Phyx-> lol, lulsec style :P
10:01:22 <Abraxas> dc?
10:01:59 <monochrom> hahaha cheater
10:02:04 <Cale> Abraxas: that wasn't aimed at you ;)  Unix dc is a stack based calculator which is incidentally Turing complete, and whose programs look like line noise
10:02:26 <Abraxas> oh ok
10:02:36 <Abraxas> i am totally confused by my type inference attempt
10:03:09 <Cale> Abraxas: generate n :: Mountains k is intended to generate all possible mountain ranges of length n which start at height k, and end at height 0.
10:03:24 <Abraxas> yeah, i know what it does =)
10:03:34 <Abraxas> but not how
10:03:46 <Abraxas> i screwed up the type inference
10:04:45 <Abraxas> generate (n-1) :: [Mountains (Succ Zero)]
10:04:58 <Cale> So if we're starting at height 0, and we want to generate a mountain range of length 0, all we can do is end here. If we want to generate one of length n > 0, then our first move is either to go Up (followed by a mountain range of length (n-1) starting at level 1 (or Succ Zero)
10:04:58 <Abraxas> generate 0, in this case
10:05:26 <Abraxas> that's instance Generate (Succ Zero)...which is []
10:05:26 <Cale> or we stay at level 0 using Equal, and follow that with a mountain range of length (n-1) starting at level Zero
10:05:58 <big_dog> Hell yo
10:06:08 <big_dog> What is alicedsl, like Alice and Wonderland?
10:06:10 --- mode: ChanServ set +o Cale
10:06:14 --- mode: Cale set +b *!*@182.7.140.129
10:06:14 --- kick: big_dog was kicked by Cale (big_dog)
10:06:39 --- mode: Cale set -o Cale
10:06:41 <Abraxas> but then the result of the call would be [] and it's not
10:06:48 <Abraxas> it's [0,0]
10:06:49 <Cale> hm?
10:06:54 <yitz> hmm it was a new ip
10:06:59 <Abraxas> it's [[0,0]]
10:07:09 <Cale> Well, what are we asking for?
10:08:03 <Cale> We're asking for the mountain ranges with 1 step and which start and end at level 0
10:08:16 <Cale> There's exactly one of those, Equal End
10:08:50 <Cale> You forgot about the right parameter to the (++)
10:08:52 <Jeanne-Kamikaze> I think big_dog's performance deserves more attention xD
10:08:59 <Cale> map Equal (generate (n-1))
10:09:02 <Jeanne-Kamikaze> what the fuck was that
10:09:19 <Cale> which in this case is  map Equal (generate 0 :: [Mountains Zero])
10:09:22 <mauke> Jeanne-Kamikaze: no.
10:09:55 <Jeanne-Kamikaze> it was so random I find it even funny
10:10:37 <Cale> and generate 0 :: [Mountains Zero] = [End]
10:10:50 <Cale> so that's  map Equal [End] = [Equal End]
10:11:16 <Abraxas> ah right, i only had Generate k as instance for that one, because i didn't infer k=Zero :D
10:11:17 <Cale> btw, this is much easier to follow if you write a proper Show instance for Mountains k
10:11:28 <rotflcopter> 182.7.0.0/16 ban plz
10:11:29 <Abraxas> yeah, i thought as much
10:11:33 <Abraxas> that might help
10:11:47 <hpaste> Cale pasted “Show instance for Mountains” at http://hpaste.org/53713
10:12:57 <Abraxas> what i couldn't get past was my old type inference, where i used the wrong instance...i thought it was strange not to match k with anything :D
10:15:14 * hackagebot sfml-audio 0.3.1816.0 - minimal bindings to the audio module of sfml  http://hackage.haskell.org/package/sfml-audio-0.3.1816.0 (SoenkeHahn)
10:16:14 <rotflcopter> or lameban
10:16:16 <rotflcopter> * a3li sets ban on $r:diggit*
10:16:17 <rotflcopter> <;
10:16:46 <hpaste> gwern pasted “Guessing (complete)” at http://hpaste.org/53714
10:17:03 <Abraxas> thx cale
10:17:57 <Abraxas> need to do the steps more carefully, keep in mind that i have the type of the generate and therefore the partial lists need to have that same type...
10:18:45 <Younder> by the way if you add the last two digits of your birth date (say for me 67) and add your age the sum is 111. this is true for all people born between 1900 ipto 2000.
10:19:04 <gwern> anyone have any suggestions for shortening my guessing game program?
10:21:31 <gwern> I thought I did a pretty good job in shortening someone else's, by exploiting the Read machinery to parse the user response, but it seems there's always some monadic function...
10:21:33 <copumpkin> > map (ap (+) (sum . map digitToInt . show)) [0..100]
10:21:34 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,11,13,15,17,19,21,23,25,27,29,22,24,26,28,30,32,3...
10:22:01 <copumpkin> oh whoops
10:22:32 <copumpkin> > map (\x -> (2011 - x) + sum . map digitToInt . show $ x) [0..100]
10:22:33 <lambdabot>   Occurs check: cannot construct the infinite type:
10:22:33 <lambdabot>    a = a -> GHC.Types.Int
10:22:37 <copumpkin> gah
10:22:46 <copumpkin> > map (\x -> (2011 - x) + (sum . map digitToInt . show $ x)) [0..100]
10:22:47 <lambdabot>   [2011,2011,2011,2011,2011,2011,2011,2011,2011,2011,2002,2002,2002,2002,2002...
10:23:01 <copumpkin> > map (\x -> (111 - x) + (sum . map digitToInt . show $ x)) [0..100]
10:23:03 <lambdabot>   [111,111,111,111,111,111,111,111,111,111,102,102,102,102,102,102,102,102,10...
10:23:17 <geheimdienst> gwern: how about using Ordering from Data.Ord or wherever?
10:23:27 <geheimdienst> it seems to have Read and Show instances
10:24:05 <gwern> geheimdienst: I thought that wouldn't save me any lines, but I guess I should check
10:24:37 <geheimdienst> i guess it is -1 line for "data =" and +1 line for "import ..."
10:24:58 <gwern> geheimdienst: no, Prelude exports it
10:25:08 <gwern> geheimdienst: that's why I had those Main.GT qualifiers
10:25:21 <geheimdienst> oh i see
10:25:59 <hpaste> gwern annotated “Guessing (complete)” with “Guessing (complete) (annotation)” at http://hpaste.org/53714#a53715
10:28:19 <gwern> so it's -1 line, and changes to 3 others (2 shortenings)
10:30:38 <hydo> arch users: do you normally use the distro ghc version or install by hand?
10:31:02 <roconnor> hi gwern
10:31:07 <hydo> I always install a binary dist when on ubuntu, but given the arch legendary haskell support, I thought I'd ask.
10:31:11 <geheimdienst> hydo: for ghc, distro package. for everything else, cabal /my 2 cents
10:31:37 <hydo> geheimdienst: ok, that was going to be my path.  ghc distro and then download and bootstrap cabal.
10:33:40 <Nimatek> hydo: I use haskell-platform from the extra repo.
10:34:12 <hydo> oh yeaaa... I'll try that first.
10:34:16 <hydo> thanks, Nimatek
10:35:50 <geheimdienst> gwern: something is borked about the computation :) is this thing supposed to support negative numbers? try starting and entering "LT" 3 times ...
10:35:57 <Nimatek> hydo: Also https://wiki.archlinux.org/index.php/Haskell_package_guidelines
10:36:13 <gwern> geheimdienst: it did say 'natural numbers' :)
10:36:31 <geheimdienst> i don't grok the interaction of j and i. it seems a tad complicated to me ... i-(j-i `div` 2)
10:37:24 <gwern> geheimdienst: imagine the last guess was 10. the user says 'too small'. you double and then guess 20. the user says 'too big'. now you know that the number must be 11-19
10:37:33 <wto> @src curry
10:37:34 <lambdabot> curry f x y = f (x, y)
10:38:33 <geheimdienst> yeah ... however i'd still maintain that something stinks :) if i keep saying LT, it guesses as follows: 1 0 0 1 2 3 3 2 1 0
10:38:50 <kyagrd> Is there a backward compatible function for mkTyCon3 in Data.Typeable?
10:39:17 <kyagrd> to make things both compile in 7.2 and 7.0 ...
10:39:18 <gwern> geheimdienst: so what's the midpoint of 11-19? the offset is (19-11) / 2, or 4, and then turn the offset into an absolute address, 11+4 = 15
10:39:37 <gwern> geheimdienst: 15 is now the new guess. if it's too low, we now know the number is 16-19... etc.
10:39:56 <geheimdienst> yeah, if you put it that way, sounds plausible ...
10:40:19 <ecuageo> Im trying to install hmatrix and I keep getting an error saying it cant link to gsl. Any ideas?
10:41:15 <kyagrd> seems not ...
10:41:26 <gwern> geheimdienst: if I wanted to support 0, I'd have to put in checks for the divsion and multiplication; if I want to support negative numbers, I think I'd need to bring in abs among other things
10:44:12 <geheimdienst> right, you have me convinced ... so when we have 1 and the user says LT, the correct thing to do is print "you suck"
10:44:14 <geheimdienst> or something
10:44:15 <geheimdienst> :)
10:45:25 <geheimdienst> gwern: related -- look what kmc made the other day http://hpaste.org/52533
10:45:55 <gwern> geheimdienst: heh. exitWith (Error "you accursed liar")
10:46:47 <gwern> geheimdienst: what is that?
10:48:03 * yitz wonders how gwern lost control of his nick
10:48:32 * gwern has lost control of nothing
10:48:45 <yitz> gwern: not you, the other gwern :)
10:48:53 <gwern> oh. he was a putz
10:50:18 * hackagebot representable-functors 2.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.1 (EdwardKmett)
10:51:21 <geheimdienst> gwern: you call "numberwang 42" and it tells you True or False. it's random, so it will vary when you run the program multiple times, but deterministic. once you called numberwang the first time, the algorithm won't "change its mind". it won't give you True for a number it previously gave you False for
10:51:50 <edwardk> geheimdienst: hahaha
10:51:59 <gwern> geheimdienst: curious. reminds me of something but I can't remember what
10:52:07 <gwern> the amb operator? not quite.
10:53:01 <geheimdienst> it's pretty clever really. as i understand it, it's kind of a binary tree that gets its nodes lazily evaluated, with the "path" through the tree being the bits of the number it was asked for
10:53:15 <geheimdienst> so apparently it works efficiently even for very large numbers
10:53:47 <gwern> as opposed to memoizing numbers into a global map?
10:53:53 <monochrom> most humans work like numberwang when it comes to opinions
10:54:23 <ski> geheimdienst : you're talking about random functions ?
10:54:58 <edwardk> Saizan: implemented
10:55:20 * hackagebot adjunctions 2.0.4 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.4 (EdwardKmett)
10:55:22 * hackagebot representable-tries 2.0.4 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.4 (EdwardKmett)
10:55:24 * hackagebot algebra 2.0.4 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.4 (EdwardKmett)
10:55:48 <gwern> geheimdienst: did kmc say what he was using that for?
10:56:29 <geheimdienst> ski: i'm more or less talking out of my behinditude, really. it's what i recall about the inner working of a clever bit of code that kmc made a few weeks ago
10:56:55 <geheimdienst> gwern: he wanted to try out this trick with the lazy tree that he saw some guru use. but you better ask him yourself :)
10:57:11 <geheimdienst> ski: (see hpaste link i pasted above)
10:57:28 <ski> geheimdienst : sometimes i wish one could make "oracle values"
10:58:13 <gwern> and come to think of it, you could just use a crypto hash on numbers if you want deterministic random booleans...
10:58:15 <ski> geheimdienst : when the system tries to force the value, it pops up a query where you can enter a value (unless it has already been forced before)
10:58:37 <ski> geheimdienst : and you can enter `?' in the value, which represent new oracle values, which you can specify later, if needed
10:59:29 <Eduard_Munteanu> ski: like Agda's holes?
11:00:01 <ski> Eduard_Munteanu : a bit, but these would be passed around dynamically, at run-time
11:00:13 <Eduard_Munteanu> I guess that sort of interactive editing would be nice to have in Haskell as well.
11:00:29 <Eduard_Munteanu> Ah, hm.
11:01:28 <ski> i suppose the part which i'm not sure about is how to tell the user which oracle value it wants atm
11:02:37 <ski> one could consider an operation `oracle :: String -> IO a', which creates a new oracle value, labelled by the string
11:03:04 <ski> and then when it forces the value the first time, it prompts out that string, so you know which oracle it wants
11:22:17 <dmos> I have code which reads: fmap (return . Just . show . length) wl
11:22:41 <dmos> any stylistic improvements recommended?
11:23:07 <ion> @type fmap (return . Just . show . length)
11:23:08 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f [a] -> f (m (Maybe String))
11:23:55 <roconnor> dmos: I don't see any
11:24:28 <danr> dmos: you can write return instead of Just :)
11:24:38 <ocharles> danr: return . Just != return
11:24:57 <danr> ocharles: no but return = Just for Maybe
11:25:08 <ocharles> oh, so return . return
11:25:10 <danr> @type fmap (return . return . show . length)
11:25:11 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a (f :: * -> *). (Monad m, Monad m1, Functor f) => f [a] -> f (m (m1 String))
11:25:27 <dmos> roconnor: ok. I just thought I might be overlooking something to compress it a bit more.
11:25:29 <ocharles> I wonder if traverse fits into this at all
11:25:43 <ion> @type fmap (pure . pure . show . length)
11:25:44 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (f2 :: * -> *). (Applicative f, Applicative f1, Functor f2) => f2 [a] -> f2 (f (f1 String))
11:26:29 <ion> (The type looks slightly like a X-Y problem.)
11:26:56 <ocharles> what's the type of wl, dmos?
11:27:45 <dmos> Ugh, it's xmonad stuff. the outer monad is X, the full type is X (Maybe String), and the inner I have to check.
11:29:37 <dmos> inner is [Windows], and I only care about the length.
11:30:08 <ski> hm, maybe it would be better to make a new monad, which is included in `IO' -- that way you could have the oracle input create new oracles
11:30:46 <gwern> better yet, just use undefined, and catch all exceptions, firing up an IO command like a GUI to fill in the exceptional value and continue computing
11:31:06 <gwern> exceptions - they're exceptional! then we can continue reinventing common lisp's condition system :)
11:32:20 <hpaste> dylex annotated “Guessing (complete)” with “Guessing (integers)” at http://hpaste.org/53714#a53716
11:35:23 <dylex> that old guessing game wasn't very smart: 1 GT, 2 GT, 4 GT, 8 LT, 7 LT, 3 ... but I already said > 4
11:38:26 <scooty-puff> is there a reason IntMap.unionWith does have type (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a?
11:38:31 <scooty-puff> *does not
11:38:59 <scooty-puff> nm, stupid question
11:39:04 <hpaste> “Joey Adams” pasted “Asynchronous exception discarded after FFI call” at http://hpaste.org/53717
11:39:48 <JoeyA> On GHC 7.0.3, the killThread blocks until the FFI call completes, but ThreadKilled isn't actually delivered.  That's a bug, I think.
11:40:34 <JoeyA> Can anyone reproduce that in a later version of GHC?
11:40:47 <monadic> JoeyA: Can you post some test code somewhere and I'll run it on 7.2
11:40:57 <JoeyA> monadic: Did; see the hpaste above.
11:41:07 <monadic> Oh
11:41:22 <dylex> JoeyA: seems to work on 7.2.1
11:41:39 <ski> gwern : yes, but how do we explain to the user *which* value the system wanted to get ?
11:41:52 <JoeyA> Don't forget to compile with -threaded
11:42:27 <monadic> it does not reproduce for me either
11:43:05 <JoeyA> Thanks
11:46:00 <monochrom> has bug in 7.0.3 and 7.0.4, no bug in 7.2.1
11:46:41 <JoeyA> I'll submit a bug report to http://hackage.haskell.org/trac/ghc, so at least it will be documented somewhere.
11:47:30 <JoeyA> monochrom: Thanks for testing
11:48:41 <gwern> ski: store symbols somewhere; we have to do it already for profiling
11:51:51 <ski> gwern : that only gives a static code location, it doesn't identify the dynamic value
11:52:11 <gwern> ski: it doesn't have a dynamic value, that is the point of asking the user to supply one
11:54:55 * monochrom uses TH to ask user input at compile time, unsafePerformIO to ask user input at run time
11:55:51 <monochrom> s <- runIO (putStrLn "enter a line:" >> getLine); [|putStrLn s|]   \∩/
12:05:00 <FUZxxl> What is the correct syntax to import a C function int foo(void) using the FFI?
12:05:09 <k0ral> how can I write a data type where one of the "component" is "abstract" (i.e. only defined as belonging to a type class)
12:05:10 <FUZxxl> I don't know how to declare the empty argument list.
12:05:10 <k0ral> ?
12:05:24 <mauke> foreign import ccall "foo" :: IO CInt
12:05:26 <mauke> or something like that
12:05:36 <k0ral> where should I put the (TypeClass a => ... ?
12:05:46 <mauke> k0ral: nowhere
12:06:21 <k0ral> mauke: ? that won't compile
12:06:26 <FUZxxl> mauke: thx
12:06:28 <FUZxxl> kthxbye
12:06:41 <byorgey> k0ral: you can put it right before the data constructor.
12:06:53 <shachaf> k0ral: What are you actually trying to do?
12:07:11 <monochrom> you can but not useful at all
12:07:52 <monochrom> or maybe you mean existential type
12:08:03 <monochrom> in general you need to be more specific
12:08:27 <k0ral> data A = A { something :: a } ----> I want a to be "abstract"
12:08:40 <mauke> k0ral: data A a = A{ something :: a }
12:08:47 <k0ral> so I tried data A a = A { something :: TypeClass a => a }
12:09:16 <parcs> k0ral: using GADTs or existentials
12:09:33 <parcs> data A where A :: a -> A or data A = forall a. A a
12:09:37 <bscarlet> k0ral: often one would leave the TypeClass constraint out of the type and include it in the functions that act on the type.
12:09:40 <monochrom> {-# LANGUAGE ExistentialTypes #-} and data A = forall a. Typeclass a => A a
12:10:15 <k0ral> trying all that one by one
12:10:17 <monochrom> and no, I no longer care that I may be answering an XY problem
12:10:27 <shachaf> k0ral: What are you actually trying to do?
12:10:35 <shachaf> What type class are you using, for instance?
12:10:38 <k0ral> without any constraint
12:10:57 <rwbarton> can you complete this English sentence: "A value of type A is a _____"
12:11:27 <parcs> value of type A
12:11:28 <ocharles> value?
12:11:31 <k0ral> hmmm
12:11:48 <k0ral> rwbarton: are you referring to my issue ?
12:11:52 <rwbarton> yes
12:11:54 <monochrom> everyone is
12:13:01 <k0ral> ... a custom version of the data type
12:14:49 <rwbarton> That sounds like a "no".
12:15:13 <k0ral> hmmm
12:15:31 <k0ral> this works (of course) : data A a = A{ something :: a }
12:15:55 <k0ral> but then I have to explicitly give a
12:16:03 <k0ral> or not ?
12:17:21 <bscarlet> k0ral: yes, you do. Do you really want two A's of the _same_ type to be able to have two different somethings?
12:17:49 <bscarlet> k0ral: not that that's wrong, but it's a common pattern of thinking among people transitioning from OO languages.
12:18:07 <bscarlet> koral: ... which often isn't as necessary as it feels.
12:18:49 <k0ral> bscarlet: I won't have ever two A's at all
12:19:03 <k0ral> bscarlet: so I can't even think of how to answer your first question
12:19:39 <bscarlet> k0ral: then why do you want "a" to be abstract?
12:19:57 <bscarlet> k0ral: if you'll only have one, what's the point in letting it vary?
12:19:59 <rwbarton> then why do you even want A to exist as a type at all?
12:20:07 <k0ral> because each user will compile my code with a possibly different a
12:20:47 <k0ral> that's the customizing part of my library
12:20:52 <bscarlet> k0ral: then you may have two of your A's, because I, as a user, may want to use it twice with different "a"s.
12:21:09 <bscarlet> k0ral: (I'm awkward that way)
12:21:14 <k0ral> bscarlet: you won't for each single executable
12:21:33 <bscarlet> k0ral: why are you trying to tell me where to put my executable boundaries? :-)
12:21:41 <k0ral> k0ral: :D
12:21:44 <k0ral> oops
12:21:48 <k0ral> bscarlet: :D
12:22:23 <k0ral> say you realy use two A's
12:22:26 <k0ral> really*
12:22:44 <k0ral> my answer would then be yes
12:23:03 <k0ral> I want two A's of the *same* type to be able to have two different somethings :: a
12:23:17 <k0ral> if by "somethings" you actually mean the :: a
12:24:25 <dylex> k0ral: maybe if you explained what this library does and what the A is used for more concretely people will be better able to answer.
12:24:35 <bscarlet> k0ral: then you a) want existential types and b) should probably look at the result after you try them and see if there's a cleaner architecture for this customization.
12:25:14 <k0ral> AAAARG
12:25:28 <k0ral> seriously I need to learn how to manage this forall/exists
12:25:38 <k0ral> it's driving me nuts
12:25:52 <k0ral> now I'm getting this: Illegal polymorphic or qualified type
12:26:15 <monochrom> no, you first need to write an unambiguous specification
12:26:21 <k0ral> forall a. TypeClass a => DataType a
12:27:07 <k0ral> well, that specification is clear to my mind, I just don't know exactly how to write it, hence my first question
12:28:06 <k0ral> that sounds odd to me not putting the constraint right onto the data type definition
12:30:19 * hackagebot iteratee 0.8.7.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.1 (JohnLato)
12:40:19 * hackagebot type-unary 0.1.4 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.4 (ConalElliott)
12:40:32 <k0ral> existential type is what I needed
12:50:51 <Yarou> looking for dota 2 key, /q me (amsg)
12:51:13 <Clint> how do i convert a bytestring to a string based on a charset specified within that bytestring?
12:52:46 <bscarlet> With just that information, it's not necessarily a well defined problem.
12:52:49 <dmwit> Clint: Depends how the charset is specified within the bytestring.
12:53:03 <bscarlet> Clint: are you dealing w/ XML?
12:55:15 <Clint> dmwit: well, it's an email, so it's theoretically correct in the content-type header
12:55:20 * hackagebot iteratee 0.8.7.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.2 (JohnLato)
12:55:24 <Clint> bscarlet: no
12:56:33 <bscarlet> Clint: I would have guessed that for e-mail the headers were ascii, followed by other stuff encoded w/ encoding specified in the headers.
12:56:41 <Clint> right
12:56:47 <dmwit> Clint: I don't know much about the email format. Are there separate blocks that are encoded and not encoded?
12:57:00 <mauke> dmwit: yes, yes, and yes
12:57:01 <bscarlet> dmwit: everything's encoded.
12:57:02 <Clint> dmwit: everything above a double newline is "guaranteed" to be ascii
12:57:18 <dylex> Clint: in an email, only the body is actually encoded in that charset. the headers are ascii.  you can look at something like the mime or mime-string package.
12:57:19 <dmwit> If so, step one is separate the blocks, step two is parse the unencoded block, and step three is decode the encoded block using the information parsed in step two.
12:57:21 <Clint> after that it's randomly utf-8 or ascii or windows-1252 or crap
12:57:34 <mauke> dmwit: http://video.google.com/videoplay?docid=7054401183589794595 if you want to cry
12:57:39 <dmwit> mauke: I don't.
12:58:16 * Clint looks at mime.
12:58:39 <dmwit> Clint: (I used a similar but slightly modified approach for parsing SGF. But SGF has the bonus that the name of the encoding and the surrounding bytes that you need to parse to find out the encoding are themselves encoded. Yummy.)
12:58:44 <bscarlet> Clint: the point being that because the headers are ascii and ascii is a 1-byte to 1-char encoding, you should be able to use byte operations to find the end of the header.
12:59:24 <bscarlet> Clint: then chop off the header and "decode" it (fairly trivially) as ascii.
12:59:38 <bscarlet> Clint: then that'll tell you what to do with the rest.
12:59:39 <dmwit> Actually, I'm a bit surprised there isn't an email parsing library on Hackage already.
13:00:00 <Clint> there's mbox and codec-mbox
13:00:04 <geheimdienst> i could've sworn there was ...
13:00:06 <Clint> but they aren't entirely helpful
13:00:47 <dylex> mime and mime-string are both exactly that.
13:00:53 <Clint> but they use strings
13:00:58 <Clint> the problem is that i can't do a hakyll getResourceString on the files that aren't utf-8
13:01:54 <dylex> Clint: right, i wasn't saying that they're enough, just that there are email parsing libraries.
13:02:00 <Clint> fair enough
13:03:03 <geheimdienst> i haven't used any of them, but there's http://hackage.haskell.org/package/SMTPClient-1.0.1 , http://gitorious.org/hsemail , and happs has something called happs-smtp
13:03:14 <geheimdienst> http://happs.org/
13:05:21 <dylex> ah right, hsemail. how did I forget -- that's the one I use. and it's parsec-based.
13:09:07 <Clint> oh great, i packaged that for debian and then forgot about it
13:10:20 * hackagebot flow2dot 0.9 - Library and binary to generate sequence/flow diagrams from plain text source  http://hackage.haskell.org/package/flow2dot-0.9 (DmitryAstapov)
13:15:21 * hackagebot lzma-enumerator 0.1.2 - Enumerator interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-enumerator-0.1.2 (NathanHowell)
13:17:00 <lmth> Does anyone know if there is a version of subRegex which supports PCRE?
13:17:13 <tswett> You know, the problem with Haddock is that it makes me think that all Haskell library documentation is on the same web site.
13:20:16 <balor> If I compile with "ghc  -threaded -eventlog -rtsopts --make count-words.hs", why do I get " Most RTS options are disabled. Link with -rtsopts to enable them." when running "./count-words  +RTS -ls -N2"
13:22:11 <singpolyma> Is there a "right way" to build evented network servers in haskell?  I found System.Event, but it seems fairly low level (dealing with specific fds)
13:22:35 <Enigmagic> singpolyma: haskell is already event driven, just fire up another thread using forkIO
13:22:42 <MostAwesomeDude> singpolyma: The best thing I've found so far is using forkIO and thread-per-connection.
13:22:52 <singpolyma> So, using threads instead.  hmm
13:22:57 <MostAwesomeDude> There's nothing like Twisted or Event Machine, if that's what you're thinking of.
13:23:00 <Enigmagic> haskell thread != os thread. GHC uses an event handler to do dispatching
13:23:07 <balor> singpolyma, if it's web services you're doing, I tend to use Happstack
13:23:22 <singpolyma> MostAwesomeDude: Yes, EventMachine is my past experience
13:23:46 <singpolyma> Enigmagic: So, how do you mean "uses an event handler to do dispatching" ?
13:25:20 <Enigmagic> singpolyma: GHC already does what you want, it creates one thread per processor (with -N) and uses an event handler (like epoll or kqueues) do deal with IO
13:26:04 <Enigmagic> singpolyma: forkIO creates a lightweight thread that contains all the state that you normally would associate with an evented IO programming model.
13:26:06 <MostAwesomeDude> Enigmagic: It should be noted that "doing what you want" WRT Twisted and Event Machine is not something GHC provides natively.
13:26:26 <MostAwesomeDude> Because those libraries also provide per-listening-socket state and per-connection state.
13:26:45 <singpolyma> Enigmagic: so, it gives me the same performance benefits of EventMachine, but not the programming model
13:26:46 <MostAwesomeDude> I've been experimenting with using ST to provide those, but it's not very straightforward. Programming is hard. :c
13:26:49 <singpolyma> ok
13:26:57 <Enigmagic> singpolyma: right
13:27:20 <geheimdienst> MostAwesomeDude: but what prevents you from putting per-connection state in the IO action that will handle the connection, after you passed it to forkIO?
13:27:35 <geheimdienst> similar for per-listening-socket state
13:28:19 <singpolyma> Well, what I like most about EventMachine is the "call this function when new data comes in" model
13:29:07 <lmth> http://stackoverflow.com/questions/8042889/is-there-a-version-of-subregex-which-supports-pcre
13:29:51 <geekosaur> laziness lends itself more to a function that continuously reads data from a handle, which is activated when new data arrives
13:31:06 <Enigmagic> singpolyma: hGetBufNonBlocking in a loop should do something like that
13:31:57 <Enigmagic> should/could..
13:37:48 <mm_freak> singpolyma: the non-experimental way to deal with per-connection state in haskell is to have a thread for each connection…  as noted by others you are not dealing with OS threads, just with lightweight haskell threads, which are a control structure
13:38:41 <applicative> balor, use -fforce-recomp?
13:38:47 <singpolyma> mm_freak: right.  I was basically just wondering if anyone had built per-event abstractions on top of that :)
13:39:10 <mm_freak> singpolyma: i did, but it's experimental
13:39:19 <MostAwesomeDude> geheimdienst: I guess I haven't really seen an effective way of storing state in the IO monad. I know about MVar and ST, but I don't know how to do this in a way which scales up to more than a few functions in the handler.
13:39:22 <singpolyma> right
13:39:49 <mm_freak> MostAwesomeDude: StateT over IO
13:39:56 <mm_freak> that's what i used to do
13:40:11 <balor> applicative, yes, thanks
13:40:14 <mm_freak> in some cases IORef is also fine
13:40:47 * balor mergesorts the words in war and peace...literally
13:41:23 <balor> explete me! that was fast.  11s
13:41:37 <MostAwesomeDude> mm_freak: Is StateT somehow easier or better than ST?
13:41:48 <mm_freak> MostAwesomeDude: they are unrelated
13:42:02 <mm_freak> StateT s m a = s -> m (a, s)
13:42:24 <mm_freak> ST = delimited, restricted IO
13:42:36 <mm_freak> (unless you use GHC and s = RealWorld, but let's ignore that)
13:42:59 <singpolyma> can I use getContents on a socket handle and just read lazily across the session?
13:43:19 <MostAwesomeDude> Well, for my purposes, how would I craft a setup such that I can have a list of all my connections, and also have each connection have some state? I haven't seen any practical network servers that do this kind of thing in Haskell yet. Maybe people just don't generally build this kind of thing?
13:43:19 <mm_freak> singpolyma: you could use hGetContents, but you wouldn't want to
13:43:28 <dylex> MostAwesomeDude: MVar, IORef, STRef, and the like are for mutable references, often for sharing state between threads.  StateT is about embedding extra data in an existing monad (within a thread).
13:43:39 <singpolyma> mm_freak: no?  is there a bad side effect?
13:43:53 <mm_freak> MostAwesomeDude: you can use StateT in the individual threads and also have a manager thread
13:44:02 <mm_freak> manager :: IO (ManagerMsg -> IO ())
13:44:26 <dylex> MostAwesomeDude: Maintaining state, non-blocking polling, lists of connections are (rather more annoying) ways to implement what haskell does far better (with forkIO) already
13:44:52 <mm_freak> MostAwesomeDude: another option is STM, where you don't necessarily need a manager thread
13:45:12 <mm_freak> MostAwesomeDude: finally i'm experimenting with an arrow-based approach
13:45:28 <MostAwesomeDude> dylex: If I have a stateful network protocol, how would you recommend organizing my code in order to respond to requests made with that protocol?
13:45:41 <dylex> programming with forkIO and StateT is really far easier than event-based callbacks for that sort of stuff, so the latter is often unnecessary.
13:45:51 <mm_freak> singpolyma: error handling is difficult, and you can't easily manage read timeouts
13:46:21 <singpolyma> mm_freak: hmm, I guess so
13:46:23 <mm_freak> MostAwesomeDude: if you are comfortable with STM, go for that one
13:46:31 <MostAwesomeDude> mm_freak: I am comfortable with Twisted. :3
13:46:53 <MostAwesomeDude> I want to know, preferably with a real example, how one would create a handler for a stateful network protocol.
13:46:53 <mm_freak> singpolyma: http://www.yesodweb.com/book/enumerator
13:47:43 <dylex> MostAwesomeDude: fork a new thread for each incoming connection, and just sit there in each waiting for data.
13:48:15 <MostAwesomeDude> dylex: The protocol is stateful. Each command sent from the client can modify server state and change the reponses of future commands. How do I manage that?
13:48:19 <dylex> MostAwesomeDude: any per-connection state you can essentially just keep in variables (or, equivalently in StateT).  Any shared state between threads just stick in an MVar created at the beginning.
13:48:45 <mm_freak> MostAwesomeDude: i don't know Twisted…  for the state, again, use STM for global state and StateT for client-specific state
13:49:26 <MostAwesomeDude> I'm understanding each of the libraries you guys are suggesting, but I'm hoping there's *examples* of people writing all of this together in a single file somewhere.
13:49:27 <mm_freak> equivalent to StateT you can have a client loop:  loop :: ClientState -> IO ClientState
13:49:52 <mm_freak> well, i'm writing servers, but unfortunately they are not online…  only libraries they use
13:50:30 <mm_freak> MostAwesomeDude: recently i'm going for an entirely different approach:  the automaton arrow
13:50:36 <mm_freak> but it's highly experimental
13:51:01 <mm_freak> very promising though and i hope to release a library for it this week
13:51:57 <dylex> MostAwesomeDude: ah, I remember where I wrote one of these most recently: https://github.com/dylex/huzblem/blob/master/huzblem.hs
13:52:00 <MostAwesomeDude> What's an arrow?
13:52:19 <monadic> MostAwesomeDude: Run
13:52:44 <dylex> MostAwesomeDude: the key is line 153
13:52:47 <Enigmagic> lol
13:52:52 <mm_freak> lol monadic
13:53:01 <mm_freak> MostAwesomeDude: don't bother for now ;)
13:53:21 <MostAwesomeDude> monadic: I *will* get this. :3
13:53:34 <monadic> MostAwesomeDude: You'd best leave Arrows out for now
13:53:35 <Clint> so how do i use a TextDecoder on something that's not a Handle?
13:53:40 <monadic> MostAwesomeDude: If you don't get the simpler solutions
13:53:59 <MostAwesomeDude> monadic: I get the ST examples. I get the IO examples. I don't get the interaction of the two.
13:54:04 <mm_freak> dylex: btw, as we're on the topic, the function name "proc" is quite unfortunate ;)
13:54:26 <monadic> MostAwesomeDude: I didn't see the conversation prior to "What's an arrow?"
13:54:47 <dylex> mm_freak: agreed, I am very bad with top-level-control function names.
13:54:57 <monadic> Also if you want interaction... IO and ST are both instances of MonadPrim
13:54:57 <mm_freak> MostAwesomeDude: ST is a version of IO restricted to the set of operations, which can be wrapped up in runST without losing referential transparency
13:55:35 <MostAwesomeDude> monadic: I want to build network servers. I want to build stateful protocol servers, specifically. I was hoping to find some example of people doing that.
13:55:55 <monadic> MostAwesomeDude: STM!
13:56:01 <mm_freak> MostAwesomeDude: arrows are something between applicative functors and monads…  they trade expressiveness for the power to implement some control constructs, which are not monads
13:56:12 <MostAwesomeDude> Curious.
13:57:01 <monadic> I think I had some stateful server somewhere
13:57:03 <mm_freak> dylex: the problem with "proc" is that it becomes a reserved word once you activate the Arrows language extension
13:57:09 <monadic> but I rm -rf'd it recently
13:57:14 <monadic> because I didn't like it hoggin' my bash completion
13:57:52 <mm_freak> MostAwesomeDude: why don't you look into existing server implementations?  there are warp, snap and happstack-server
13:58:01 <mm_freak> all of them are HTTP servers
13:58:26 <MostAwesomeDude> mm_freak: Mostly because HTTP tends to be highly specialized and not carry reusable components. I'll take a look.
13:58:38 <mm_freak> they give you the basic idea
14:00:03 <dylukes> MostAwesomeDude: What are you doing i nhere?
14:00:08 <dylukes> mm_freak: Also, Yesod.
14:00:16 <MostAwesomeDude> dylukes: Baskerville. Bravo, in Haskell. :3
14:00:20 <dylukes> Oh, fun.
14:00:26 <MostAwesomeDude> "Fun," yes.
14:00:36 <dylukes> Most of the Haskell web servers actually separate their components.
14:00:38 <mm_freak> dylukes: yesod is not a server…  the server part is WAI, which you would usually use with warp
14:00:44 <mm_freak> you may also use snap
14:00:52 <dylukes> Snap's server is separate from its templating and stuff.
14:08:35 <balor> Is there an existing implementation of something like "partition :: [a] -> Int -> [[a]]" which partitions the list into n-sublists?
14:09:41 <wyfrn> hi all ... i got a record type X that contains an element of type IOUArray (Data.Array.IO) ... will the array be copied if call a function of type X -> X
14:10:14 <applicative> @hoogle [a] -> Int -> [[a]]
14:10:15 <lambdabot> Prelude drop :: Int -> [a] -> [a]
14:10:15 <lambdabot> Data.List drop :: Int -> [a] -> [a]
14:10:15 <lambdabot> Prelude take :: Int -> [a] -> [a]
14:10:26 <applicative> bah
14:12:03 <shachaf> balor: Maybe in Data.List.Split?
14:12:24 <balor> I think I want something like replicateM (splitAt length/n)
14:12:57 <dylex> wyfrn: no. in general nothing is ever copied implicitly.
14:14:39 <applicative> balor, yes, I was just looking at the split package, like shachaf said. It doesn't have anything quite like what you're looking for, but maybe some sound ideas
14:16:42 <wyfrn> dylex: thx
14:28:58 <mm_freak> balor:
14:29:05 <balor> So it takes 2.4 seconds to find the number of "the" strings in War and Peace
14:29:26 <mm_freak> > takeWhile (not . null) . map (take 5) . iterate (drop 5) $ [1..]
14:29:28 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25...
14:29:36 <balor> mm_freak, thanks :)
14:30:00 <mm_freak> :t \n -> takeWhile (not . null) . map (take n) . iterate (drop n)
14:30:01 <lambdabot> forall a. Int -> [a] -> [[a]]
14:30:03 <balor> I guess thats why all the par tutorials use more complex problems like suduku solving
14:31:20 <mm_freak> balor: what's War and Peace?
14:31:30 <applicative> let balor n xs = splitEvery (length xs `div` n + 1) xs in  balor 5 "hello worldly creatures"  is ["hello"," worl","dly c","reatu","res"]
14:33:15 <applicative> mm_freak http://www.gutenberg.org/cache/epub/2600/pg2600.txt  3.5 mb plain text, a bit of writing
14:34:38 <balor> mm_freak, A very long novel when translated into English (I've never read it in Russian)
14:34:52 <mm_freak> shouldn't take a second to find all "the" strings
14:35:25 <balor> It doesn't
14:35:30 <balor> most of the time is setup and gc
14:39:43 <mm_freak> balor: how do you do it?
14:40:18 <balor> mm_freak, http://hpaste.org/53721
14:40:40 <balor> But I'm looking for an easy-to-understand problem that I can map reduce
14:40:58 <balor> Counting occurences of strings in a large array sounded good to me.
14:44:08 <mm_freak> balor: use integer factorization
14:44:29 <balor> mm_freak, thanks
14:44:30 <mm_freak> if prime, be done, if not prime, break into two factors and repeat on the factors
14:44:35 <applicative> balor, import qualified Data.ByteString.Char8 as B ; main = B.interact $  B.pack . show . length . B.findSubstrings (B.pack "the")  or something like that, makes short work of Tolstoi
14:45:18 <mm_freak> applicative: findSubstrings?
14:45:34 <mm_freak> i think that's a nontrivial function and i can't find it in the module
14:45:36 <applicative> yes, is that wrong, I was just looking into it
14:45:58 <applicative> it gave a deprecation warning
14:46:11 <applicative> Deprecated: "findSubstrings is deprecated in favour of breakSubstring."
14:46:15 <mm_freak> also finding "the" words is different from finding "the" substrings
14:46:44 <yitz> @hoogle findSubstrings
14:46:44 <lambdabot> Data.ByteString findSubstrings :: ByteString -> ByteString -> [Int]
14:46:44 <lambdabot> Data.ByteString.Char8 findSubstrings :: ByteString -> ByteString -> [Int]
14:47:18 <yitz> @hoogle breakSubstring
14:47:19 <lambdabot> Data.ByteString breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
14:47:19 <lambdabot> Data.ByteString.Char8 breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
14:47:38 <mm_freak> oh, i was looking in the lazy module
14:48:57 <applicative> good point about words, versus substring.  still, I think we can go over war and peace quite a few times in 2.4 seconds with crude uses of Data.ByteString....
14:49:27 <balor> yeah, it's a dumb example
14:49:50 * balor wonders why more bioinf people don't use Haskell, given it's text chomping prowess
14:50:13 <blackdog> balor: i think there are a few, but perl seems to have a pretty sttrong grip on it
14:50:40 <applicative> perl?  these are men and women of science?
14:50:51 <ddarius> So FORTRAN
14:51:09 <hpc> applicative: it's very easy to write fast string-crunching perl code
14:51:29 * applicative was merely feigning indignation
14:51:37 <hpc> :P
14:51:40 <edwardk> "It is sad that people are reluctant to do the 'right thing', because it will break the code that has been already written, even though it is only a small fraction of the code that will be written."
14:51:49 <fabjan> perl has a lot of libraries for biotech
14:52:00 <edwardk> I'm totally adopting that as my mantra ;)
14:52:13 <rwbarton> where is that quote from?
14:52:24 <fabjan> and the file formats are so weird
14:52:30 <edwardk> Jeremy Shaw said it on google+ just now
14:52:33 <applicative> I don't know edwardk I was just looking at the titanic <> struggles on the libraries list :)
14:52:34 <hpc> !google "even though it is only a small fraction of the code that will be written"
14:52:42 <hpc> @google "even though it is only a small fraction of the code that will be written"
14:52:43 <lambdabot> No Result Found.
14:52:46 <hpc> humbug
14:53:14 * yitz hides behind a tree
14:53:37 <Axman6> yitz == Jeremy Shaw?
14:53:46 <yitz> Axman6: no yitz == iceberg
14:53:47 <rostayob> Jeremy Shaw is stepcut
14:53:50 * applicative thinks, it's okay yitz
14:53:51 <Axman6> ah
14:54:07 <edwardk> rostayob: thanks =)
14:55:23 * hackagebot logic-TPTP 0.3.0.1 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.3.0.1 (KiYungAhn)
14:55:31 <rostayob> edwardk: :)
14:56:02 <rostayob> everyone has google+ now
14:57:26 <shachaf> edwardk: Was he talking about semigroups? :-)
14:58:01 <rostayob> they want to add a semigroup type class?
14:58:37 <balor> rostayob, no, Jeremy Shay == *awesome*
14:58:48 <rostayob> jeremy shaw is cool yes eheh
14:59:10 <rostayob> he helped me a lot in my early haskell days :)
15:00:40 * applicative learned how to do 'ghc --make -O2' from stepcut's blog
15:02:36 <Sgeo|web> kmc: I should be able to use runReaderT to turn my ReaderT (MVar ()) IO () into an IO (), right? So I should be able to use that to get an IO () that I can give to forkIO
15:02:57 <edwardk> shachaf: yes. there was a discussion on a post by clifford beshers on the topic
15:03:08 <Sgeo|web> If I were to do the same trick with StateT, presumably the altered state would be discarded
15:03:27 <Sgeo|web> I'm not sure what would happen with ContT, but it seems, not thinking about it too carefully, that it would type correctly
15:03:43 <edwardk> rostayob: they don't, but we've been debating for a couple of years now about just adding <> as an alias for mappend
15:03:46 <Sgeo|web> But perhaps not have useful behavior
15:04:06 <edwardk> rostayob: the proposal to just standardize my semigroups package didn't even get off the groud
15:04:08 <edwardk> er ground
15:04:09 <rostayob> edwardk: I see, wasn't <> used in pretty?
15:04:21 <rostayob> well Doc is a monoid
15:04:22 <edwardk> rostayob: yes, with a flipped associativity from the one we want
15:04:30 <rostayob> mhm
15:04:36 <edwardk> which is ironic given that <> is by definition associative
15:04:41 <rostayob> so people are resisting?
15:04:46 <edwardk> but the meaning of foo <+> empty <> bar   would change
15:04:55 <edwardk> a bit
15:05:09 <edwardk> i think it has enough momentum to just bull through. or rather i hope it does
15:05:22 <shachaf> edwardk: Ah, back to caring? :-)
15:05:26 <rostayob> it'd be nice to have semigroup, group and monoid type classes i guess
15:05:31 <shachaf> This is why using ++ would solve every problem.
15:05:32 <applicative> > let hah = text "hah" in hah <+> hah <> hah
15:05:33 <lambdabot>   Ambiguous occurrence `<+>'
15:05:33 <lambdabot>  It could refer to either `Control.Arrow.<+>', i...
15:05:39 <applicative> grrrrrr
15:05:44 <edwardk> i also proposed that if that operator is hopelessly encumbered then >< could be used, which would eliminate the nailbiting about pretty
15:05:55 <edwardk> lambdabot: Text.PrettyPrint.HughesPJ
15:06:08 <applicative> no, >< is my all purpose combinator!
15:06:25 <edwardk> >< would slightly improve my life because then I don't have to worry about conflicts from Data.Semigroup
15:06:32 <applicative> something needs to be left as the 'random operator you just defined'
15:06:37 <rostayob> mhm. the change to pretty would break some code but I guess <> is better than `mappend` each time
15:06:56 <ddarius> @google groud
15:06:57 <lambdabot> http://en.wikipedia.org/wiki/Groud
15:06:58 <edwardk> rostayob: you still need to use mappend to _define_ the operator though, which is a bit annoying
15:07:06 <rostayob> just overload ++ :P
15:07:08 <edwardk> but then we use fmap to define <$> all the time so there is precedent =)
15:07:15 * applicative thinks, Groud?
15:07:16 <hpc> @let (x >.< y) = text ">:(" -- :P
15:07:16 <lambdabot>   Parse error in pattern:
15:07:27 <hpc> >:(
15:08:19 <balor> hmm....do not try to compile a file with a 30mb string in it
15:08:19 <ddarius> @let x >.< y = text ">:("
15:08:21 <lambdabot>  Defined.
15:08:27 <rostayob> edwardk: good luck anyway :P
15:08:32 <ddarius> balor: Correct.
15:08:47 <Sgeo|web> ddarius: huh?
15:09:00 <Sgeo|web> > 5 >.< 6
15:09:01 <lambdabot>   >:(
15:09:40 <applicative> ddarius can we express groud-ness in haskell?
15:09:48 <hpc> @remember balor hmm....do not try to compile a file with a 30mb string in it
15:09:48 <lambdabot> Good to know.
15:10:01 <ddarius> applicative: To the extent that we can talk about groups.
15:11:10 <mbernstein> What does <|> denote in haskell?  I see it used fairly often, but searching for the operator is rather difficult
15:11:12 <simon> I wonder why fmap (+ 2) (1,2) == (1,4).
15:11:19 <ddarius> @hoogle (<|>)
15:11:20 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
15:11:20 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
15:11:20 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
15:11:29 <mbernstein> thanks :)
15:11:41 <ddarius> simon: That's the only possibility.
15:11:48 <hpc> simon: use the types
15:11:57 <simon> ddarius, why isn't it (3,4)?
15:12:02 <hpc> @djinn (a -> b) -> (c, a) -> (c, b)
15:12:02 <lambdabot> f a (b, c) = (b, a c)
15:12:04 <copumpkin> simon: look at the types
15:12:20 <copumpkin> ((,) a) is a functor
15:12:20 <dylukes> Is there any existing haskell package for doing sort of a reactor pattern?
15:12:27 <copumpkin> fmap doesn't know anything about that a, so can't add anything to it
15:12:30 <dylukes> edwardk has a mysteriously named reactor package.
15:12:36 <simon> ah.
15:12:37 <simon> neat.
15:12:49 * ddarius makes a lftr package.
15:12:49 <edwardk> dylukes: unrelated
15:12:52 <dylukes> mmk
15:13:05 <dylukes> I'm just wondering how to balance manage listening on a socket with signals and what not
15:13:10 <dylukes> balance managing*
15:13:25 <edwardk> reactor is basically haskell observable events/task parallelism using workstealing deques
15:13:30 <dylukes> preferably without just reverting to the Network.Socket side of things.
15:13:36 <dylukes> And polling.
15:14:07 <hpc> edwardk: with you, nothing is "basically" :P
15:14:07 <ddarius> EGERUNDOVERFLOW
15:15:07 <applicative> simon, in principle fmap could act on either bit of a pair, but it can't act on both, unless the pair type was really data Double a = Double a a
15:15:09 <alpounet_> edwardk, just like in the RTS ?
15:15:33 <edwardk> alpounet_: not quite, because these are IO actions being juggled
15:15:43 <edwardk> but there is a lot of overlap =)
15:15:53 <alpounet_> ok
15:16:15 <alpounet_> what have you used it for by the way ?
15:16:16 <applicative> simon, it acts on the second because of its the first one that gets mentioned in the instance, instance Functor (,) a where ....
15:16:17 <edwardk> the nice thing is that Observable forms a monad, and Observers are contravariant functors
15:16:28 <edwardk> i used it to prototype a bunch of stuff for scalaz
15:16:30 <edwardk> =)
15:16:36 <alpounet_> hah ok
15:16:39 <edwardk> then i put it down because my focus at work shifted
15:18:31 <Sgeo|web> @quickcheck ((a == b) == c) == (a == (b == c))
15:18:31 <lambdabot> Unknown command, try @list
15:18:38 <Sgeo|web> @list
15:18:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:18:47 <mauke> @check ((a == b) == c) == (a == (b == c))
15:18:48 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
15:19:00 <mauke> @check \a b c -> ((a == b) == c) == (a == (b == c))
15:19:00 <lambdabot>   "OK, passed 500 tests."
15:19:02 <acowley> What's the deal with POPL registration?
15:19:06 <edwardk> @check \xs -> xs == reverse xs
15:19:07 <lambdabot>   "OK, passed 500 tests."
15:19:11 <edwardk> yay!
15:19:14 <copumpkin> acowley: it's too POPLar
15:19:29 * copumpkin hides
15:19:30 <edwardk> over POPLated?
15:19:32 <hpc> @check \xs -> xs > -5000
15:19:33 <lambdabot>   "OK, passed 500 tests."
15:19:35 <hpc> yay!
15:19:36 <acowley> copumpkin: I couldn't find any mention of registration on the page
15:19:47 <copumpkin> acowley: underPOPLated then
15:19:48 <Sgeo|web> @check \a b c -> ((a /= b) /= c) == (a /= (b /= c))
15:19:48 <lambdabot>   "OK, passed 500 tests."
15:20:04 <acowley> copumpkin: google revealed to me that in past years they limited registration
15:20:21 <ddarius> You are not one of the chosen.
15:20:25 <acowley> but I really just wanted to see what it cost, and if one needs to register to attend workshops
15:20:27 <DanBurton> Sgeo|web: that would infer a, b, and c to be Bools
15:20:46 <ddarius> acowley: Just crash it.
15:20:50 <acowley> ddarius: is registration really closed? For workshops, too?
15:20:58 <ddarius> acowley: I have no idea.
15:21:10 <acowley> Crashing is definitely an option as I wouldn't be out any travel expenses
15:21:15 <DanBurton> @type \a b c -> ((a /= b) /= c) == (a /= (b /= c))
15:21:15 <lambdabot> Bool -> Bool -> Bool -> Bool
15:22:08 <acowley> my concern is that for the conferences I usually attend paying at the door requires twelve bars of gold while pre-registration is only vaguely extortionate
15:22:47 <ddarius> acowley doesn't understand crashing.
15:24:07 <acowley> I shall endeavour to learn the shady ways of PLers
15:25:43 <dgpratt> I'm considering running linux in a vm in order to play with haskell; any recommendations/co-recommendations on a distro?
15:25:59 <hpc> dgpratt: arch, probably
15:26:00 <ddarius> Why bother with the VM?
15:26:12 <mm_freak> dgpratt: what operating system are you running?
15:26:12 <hpc> it tends to have the most recent stuff in the distro's package manager
15:26:14 <dgpratt> lightweight, but inexperienced-linux-user friendly and haskell-friendly, of course
15:26:25 <hpc> dgpratt: oh, not arch then :P
15:26:27 <dgpratt> mm_freak: W7
15:26:30 <edwardk> turn your pockets inside out and claim to be jus' a po PLer.
15:26:32 <hpc> dgpratt: debian testing is fantastic
15:26:33 <mm_freak> arch is great for haskell development, but not really beginner-friendly
15:26:44 <Sgeo|web> Is there a reason not to do Haskell on Windows?
15:26:51 <edwardk> Sgeo|web: sure its windows
15:26:53 <mm_freak> i know from a friend that fedora includes at least GHC 7
15:26:58 <ddarius> Make sure you don't have gold bars in your pockets.
15:26:59 <acowley> edwardk: I was going to wear a name tag that said ddarius
15:27:00 <dgpratt> hpc: not completely linux ignorant, mind you
15:27:01 <hpc> dgpratt: if you feel like spending a bit of extra effort avoiding the VM entirely, you can try...
15:27:15 <ddarius> acowley: I give you my permission to do that.
15:27:19 <acowley> !
15:27:23 <acowley> wait
15:27:23 <hpc> dgpratt: http://www.ubuntu.com/download/ubuntu/windows-installer
15:27:27 <edwardk> acowley: well you'd likely get away with it, few people know what the reclusive ddarius looks like
15:27:37 <acowley> are you blackballed at POPL or something? This is a trap, isn't it?
15:27:54 <mm_freak> dgpratt: there is the haskell platform for windows
15:28:00 <edwardk> you might have to field a lot of category theory questions though
15:28:05 <dgpratt> hpc: that's a dual boot setup, yes? I've found that to be a bit of a pain
15:28:20 <acowley> That's no problem, it's not my reputation at stake :D
15:28:26 <hpc> dgpratt: it eliminates the partitioning step, which i have found is the biggest pain
15:28:53 <hpc> the ubuntu partition is actually a plain file on the windows partition
15:29:03 <acowley> The difficult part with category theory is that it's hard to make up terminology that sounds as crazy as the real terminology
15:29:07 <dgpratt> hpc: it's the fact that I have to reboot to switch; in practice I'd rarely bother
15:29:12 * ddarius runs the Windows 7 that came with his computer directly off the disk in a VM in the few occasions he needs Windows.
15:29:13 <hpc> ah
15:29:47 <ddarius> acowley: Nah, that's abstract algebra or particularly the parts of set theory that are way out in the weeds.
15:29:47 <byorgey> acowley: just say "oh, that's trivial if you think about it in the right category" to every question
15:30:01 <dgpratt> I may give arch a go if it's lightweight and haskell-friendly
15:30:15 <ddarius> Yes, the magic of category theory is that if you define your category right, everything just falls into place.
15:30:25 <byorgey> acowley: if you are pressed, make vague intimations that the questioner must be really an idiot if they don't realize which category you mean
15:30:33 <acowley> ddarius: I'll write that on my name tag under your name
15:30:34 <mm_freak> dgpratt: its weight depends on you…  i have KDE, firefox, etc.
15:30:49 <mm_freak> so it's not exactly lightweight
15:31:00 <dgpratt> mm_freak: what? no xmonad? :)
15:31:04 <mm_freak> no xmonad
15:31:08 <mm_freak> i have KDE with compiz fusion
15:31:38 <mm_freak> i don't feel obliged to use a window manager just because it was written in haskell =)
15:31:51 <dgpratt> mm_freak: :)
15:31:52 <acowley> byorgey: I can do vague intimations
15:31:54 <ddarius> edwardk: Jon is here for the next month's worth of time.
15:32:05 * applicative feels obliged to use a window manage because it was written in haskell
15:32:11 <mm_freak> dgpratt: but i do use pandoc and darcs a lot
15:32:12 * ddarius uses xmonad because he likes it.
15:32:22 <mm_freak> also i started using hakyll again
15:33:04 <applicative> you have figured out the hakyll arrows, mm_freak ?
15:33:15 <mm_freak> applicative: arrows are my second name =)
15:33:30 <applicative> mm_arrows-freak
15:34:01 <mm_freak> i'm almost sad that you rarely use hakyll compilers as an arrow…  mostly you use them as a category
15:34:14 <edwardk> jon?
15:34:16 <applicative> It occurs to me I will have to study them so I can repair my course website for spring.  It's wrong someone throws arrows at me in a time of need
15:34:28 <acowley> Jon Favreau
15:34:33 * byorgey frequently uses hakyll compilers as an arrow
15:35:17 <mm_freak> applicative: for hakyll you can be fine with understanding Category, which is much simpler than Arrow
15:35:22 <edwardk> the actor who plays happy hogan in iron man?
15:35:23 <applicative> byorgey, is the source of your site public.  oh wait, the diagrams one?
15:35:36 <acowley> edwardk: Yes, he's big in the CT community
15:35:51 * acowley is practicing being a fake CT guru
15:35:54 <dylukes> How should I timeout an accept? :\
15:36:01 <dylukes> :t timeout
15:36:02 <lambdabot> Not in scope: `timeout'
15:36:07 <mm_freak> applicative: from time to time you may need 'arr' (or rather (>>^), (<<^), (^>>) or (^<<)) from Arrow
15:36:09 <dylukes> :t System.Timeout.timeout
15:36:10 <lambdabot> forall a. Int -> IO a -> IO (Maybe a)
15:36:19 <dylukes> is this okay to use :\?
15:36:50 <ddarius> dylukes: Probably not.
15:37:10 <byorgey> applicative: yes
15:37:13 <hpc> dylukes: if you are waiting on a Handle, there's hWaitForInput
15:37:14 <dylukes> ddarius: The docs say its okay for Network.Socket.accept specifically..
15:37:20 <ddarius> edwardk: Dewitt.
15:37:23 <dylukes> hpc: I'm waiting on accepting on a listener socket.
15:37:28 <ddarius> dylukes: Well then, probably.
15:37:29 <byorgey> applicative: http://patch-tag.com/r/byorgey/diagrams-doc
15:37:46 <byorgey> applicative: I'm also currently redoing my personal web site with hakyll
15:37:49 <applicative> byorgey, yes I just found it, thanks.  the site looks good too.
15:37:57 <edwardk> ddarius: ah!
15:40:23 <ddarius> dylukes: I don't know.  It's not making me feel happy that it won't send a killThread that gets received after an accept has accepted but before timeout returns.
15:40:27 <Sgeo|web> Is it morally acceptable to use Network.CGI for simple stuff?
15:40:40 <dylukes> Hm.
15:40:58 <ddarius> Sgeo|web: Why wouldn't it be?
15:41:10 <Sgeo|web> ddarius: "CGI" gives me a weird feeling
15:41:19 <ddarius> Sgeo|web: You should see a doctor about that.
15:41:31 <acowley> That weird feeling is called "appropriate for simple stuff"
15:41:56 <hpc> Sgeo|web: at worst, CGI is "old"
15:42:23 <hpc> Sgeo|web: actually, at worst it's "the wrong tool for the job", but you know what i mean :P
15:47:20 <tomprince> byorgey: Is there any examples of using diagrams for commutative diagrams?
15:47:23 <acowley> :q
15:47:30 <acowley> excuse me
15:50:03 <mm_freak> applicative: i'm right now writing an introduction to arrows to make the netwire library more accessible…  it's not finished yet, but you might still find it useful…  if you're interested, i can give you the link
15:51:09 <mm_freak> it specifically goes into static information like in the hakyll arrow as a motivating example
15:51:16 <RaptorRarr> mm_freak: I wouldn't mind reading it.
15:52:19 <mm_freak> RaptorRarr: see notice
15:52:50 <byorgey> tomprince: not yet
15:53:22 <byorgey> tomprince: but it should work great for that, once we do a bit more work on support for arrows
15:55:40 <tomprince> I've thought about writting a parser for paul taylor's latex diagram package, since I can think in them, and the notation seems close to the actual diagram then most other packages. But not so great for the web, for example.
15:56:54 <dylukes> So...
15:56:59 <dylukes> when this says "should be considered GHC internal"
15:57:00 <dylukes> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Event.html
15:57:06 <dylukes> Does that mean it's okay to use :0?
15:57:23 <acowley> are you inside GHC?
15:57:27 <dylukes> ...No.
15:58:13 <byorgey> tomprince: cool
15:58:30 <acowley> Well, I gather the accepted approach is to use such things in your code for yourself, then, if you want to distribute your project you ask the GHC wizards
15:58:34 <dylukes> acowley: Is there anything you'd recommend for event driven programming?
15:58:46 <byorgey> acowley: only the magical gnomes are in there
15:58:54 <acowley> I thought they were elves
15:58:59 <acowley> I feel like such a heel
15:59:16 <acowley> dylukes: it sounds like mm_freak could advocate netwire
15:59:26 <byorgey> well, the elves still run the place but they outsourced the actual work to gnomes
15:59:33 <dylukes> I should have known. FRP!
16:00:14 <applicative> mm_freak, I just noticed you mentioned a tutorial on arrows and netwire, it might be good to read...
16:00:17 <acowley> dylukes: if you can tolerate something a bit less structured, you can work with streams of monadic actions
16:01:00 <dylukes> I'll play with it.
16:01:09 <iago> Hi, (a question about the enumerator package): is there an easy way (just using the library combinators) to get a 'Data.Enumerator.List.takeWhile'-like enumeratee (instead of an iteratee)? I have an enumerator that supplies "event" values, and I just want to "cut" the enumerator when I find an "quit" event...
16:01:47 <iago> can someone give me a hint please ?
16:01:53 <mm_freak> applicative: see notice
16:02:16 <applicative> ah yes, thanks, will study
16:14:11 <Enigmagic> iago: it could be done with mapAccum... use the 's' parameter to pass a Bool around
16:14:46 <Enigmagic> iago: sorry, concatMapAccum.
16:15:03 <Enigmagic> iago: once your state parameter is false always return an empty list
16:19:31 <gnezdo> I'm sure there's a better way to get seed an rng than (denominator . toRational . utctDayTime) `fmap` getCurrentTime
16:20:38 <RaptorRarr> Doesn't Haskell have an auto-seeded RNG?
16:20:59 <gnezdo> What I really need is a have the system rng seeded with some value and then if I need to re-run this experiment, I can force-seed it to that value
16:21:39 <RaptorRarr> Ahh.
16:21:54 <gnezdo> I dont' really care about proper randomness, just some experiments that don't repeat unless I want to repeat them
16:22:21 <mm_freak> gnezdo: across invocations of your program?
16:22:26 <gnezdo> yes
16:22:36 <RaptorRarr> You can probably write a function to take a Maybe seed value and give you a generator.
16:23:01 <RaptorRarr> Then you can perhaps get a consistent set of randoms or perhaps not.
16:23:02 <mm_freak> gnezdo: see Data.Time.Clock.POSIX
16:23:19 <mm_freak> it gives you seconds since 1970, which you can convert to an Int
16:23:30 <mm_freak> :t round . realToFrac
16:23:31 <lambdabot> forall b a. (Integral b, Real a) => a -> b
16:24:27 <dylex> gnezdo: I do that by just grabbing the current random seed and logging it.  If I want to rerun, I just set the current seed instead.
16:24:49 <gnezdo> dylex: how I do I grab that?
16:25:17 <gnezdo> RandomGen doesn't expose its seed
16:25:42 <dylex> gnezdo: seed <- getStdGen
16:25:54 <gnezdo> Read/Show ?
16:26:11 <RaptorRarr> @hoogle getStdGen
16:26:11 <dylex> gnezdo: there are read/show instances for StdGen, yes.
16:26:11 <lambdabot> System.Random getStdGen :: IO StdGen
16:26:27 <iago> Enigmagic, I see, thanks a lot
16:26:31 <gnezdo> Good call, thanks dylex
16:34:39 <a215> having trouble w/ system update...it doesn't seem to want to let me update cmdargs, hinotify, xmonad, xmonad-contrib...
16:35:05 <byorgey> a215: what do you mean by 'system update' ?
16:35:06 <a215> "ghc-pkg: cannot find package hinotify-0.3.1" // "error: command failed to execute correctly"
16:35:09 <a215> yaourt -Syu
16:36:07 <byorgey> ah. no idea. I use arch but don't use pacman to manage my Haskell installation.
16:36:17 <a215> ok
16:45:27 * hackagebot liblinear-enumerator 0.1.2 - liblinear iteratee.  http://hackage.haskell.org/package/liblinear-enumerator-0.1.2 (NathanHowell)
16:51:04 <Lemmih> Anyone here coming to COPLAS on the 9th?
17:16:50 <QinGW> hi
17:27:48 <bobzhang> is it possible to derive Data, Typeable for GADT?
17:28:07 <bobzhang> like data Exp a where {A :: Int -> Exp Int; B :: Char -> Exp Char}
17:28:34 <Cale> I don't think it is. You can't even derive Show for GADTs, can you?
17:28:40 <hpc> bobzhang: try it out and see?
17:28:51 <bobzhang> hpc: does not work
17:28:53 <hpc> or listen to Cale :P
17:29:19 <bobzhang> hpc: thanks I wish I can :-)
17:29:51 <bobzhang> deriving instance Typeable1 Exp -- still does not wokr
17:31:49 <wavewave> hi.
17:31:50 <ttvd> sorry for a nubish question, is it possible to do something like scheme's set! in haskell?
17:32:08 <wavewave> is mutual dependency of ghc stable?
17:32:15 <wavewave> using .hs-boot
17:32:39 <Axman6> wavewave: it's usually a sign of bad modual design to use it...
17:32:54 <Axman6> ttvd: what does set! do?
17:33:02 <ttvd> mutate value
17:33:08 <ttvd> in environment
17:33:14 <bobzhang> IORef
17:33:15 <Axman6> possible yes, highly discvouraged
17:33:29 <bobzhang> ttvd: IORef
17:33:32 <Axman6> don't use mutation unless you know you have to. haskell is all about purity
17:33:34 <wavewave> Axman6: I know..  I tried hard to avoid it. Now I have to do so at least for the time being.
17:33:35 <Axman6> bobzhang: shush
17:33:48 <ttvd> yah, i just want to checking something, i know it's not a very good idea
17:33:49 <Sgeo|web> ttvd: Depends on context on which you want to use it
17:33:50 <ttvd> thanks
17:34:10 <ttvd> i want to mutate a value in one of the expressions in seq
17:34:39 <ttvd> don't ask why, it's more of a learning thing
17:34:48 <smns> Lemmih, yes, certainly!
17:34:48 <Axman6> if you need to share some data between threads, IORefs can be fantastic. but we rarely use mutation in non-concurrent code in my experience
17:34:56 <Axman6> ttvd: seq?
17:35:02 <Axman6> as in Data.Seq?
17:35:06 <Sgeo|web> Axman6: what do STRef and State count as?
17:35:31 <Axman6> Sgeo|web: State is not mutation at all. ST is one of the fur places where it's a good idea to use mutarion in non-concurrent code
17:35:56 <Axman6> mutation*
17:35:58 <Cale> "ST is for the few places where ..."
17:36:10 <Axman6> exactly
17:36:12 <smns> Lemmih, shoot, I might be in an exam room at that time.
17:36:28 <Sgeo|web> Would it be a bad idea for me to use ST as a newbie if I'm not sure how to make an algorithm functional?
17:36:32 <sal23> is there a way to tell ghci to ignore symbols in BSS when loading object files? I am getting "unknown symbol" error for one of those symbols when loading an object file that has the c code being called by FFI
17:36:37 <Axman6> Sgeo|web: imo yes
17:37:21 <Axman6> Sgeo|web: what's the point of learning haskell if you're just going to resort to imperative methods anyway?
17:37:34 <Sgeo|web> Hmm, I'm not that new
17:37:37 <ttvd> thanks guys.
17:37:41 <hpc> Sgeo|web: understanding how ST keeps mutable values from escaping is very advanced
17:38:00 <Sgeo|web> I understand monads comfortably, if not quite monad transformers
17:38:00 <c_wraith> hpc: you don't need to understand how ST works to understand how to use it, though
17:38:02 <hpc> and not worth the complication for a newbie, even if it was more idiomatic
17:38:25 <hpc> c_wraith: i don't like the idea of teaching a newbie to use a library they don't understand
17:38:25 <Sgeo|web> I wrote a pun back in 2006 iirc
17:38:29 <Sgeo|web> Or, I forgot when I wrote it
17:38:33 <shachaf> Sgeo|web: Sometimes ST is a reasonable way to express things.
17:38:40 <hpc> c_wraith: it tends to lead to "compiler is magic" thinking
17:38:43 <Sgeo|web> hpc: Not sure if I should call myself a "newbie"
17:39:00 <shachaf> Sgeo|web: However, a good use of your time is probably figuring out "how to make an algorithm functional". :-)
17:39:03 <Sgeo|web> I've been looking at and admiring Haskell for quite some time
17:39:06 <hpc> Sgeo|web: ah, you said "newbie" so i was just following the question :P
17:43:38 <smns> what's ST?
17:44:00 <smns> State Transformer?
17:44:28 <magn3ts> Wrote some code to check if first/last element are the same, which works, but it seems to not like doing so with empty lists even though I think I consider that case in my code.
17:44:55 <sal23> smns, state thread: http://www.haskell.org/haskellwiki/Monad/ST
17:44:57 <smns> magn3ts, post some code.
17:45:20 <hpaste> magn3ts pasted “firstLastSame” at http://hpaste.org/53727
17:45:23 <magn3ts> http://hpaste.org/53727
17:47:09 <dylex> magn3ts: think about what happens when there's only one element in your list [[0]]
17:47:27 <magn3ts> dylex same error I'm getting now I'd imagine, last: empty list.
17:47:40 <hpaste> smns annotated “firstLastSame” with “firstLastSame (annotation)” at http://hpaste.org/53727#a53728
17:48:37 <dylex> magn3ts: because it matches x == [0], xs == [], so you're taking "last []"
17:49:17 <magn3ts> dylex, yeah, I'm seeing that now, but I also get that on [[]] as input, which strikes me as strange. I think I need to check xs to ensure it has a length else False.
17:49:45 <smns> magn3ts, any reason why you operate on Floats?
17:50:11 <Rotaerk> maybe he likes contributing to parades
17:50:39 <magn3ts> smns, not really, I understand what you did. You allow any input that can be checked for equality, ("inherits the equality type", if that's an accurate phrasing with regards to haskell)
17:50:48 <magn3ts> Also, what Rotaerk said :)
17:51:44 <smns> magn3ts, yeah, but I suppose you could just work on floats. I guess what's interesting is that you establish a guarantee that the list will have a first and a last element (even though there may only be one element in the list).
17:52:38 <magn3ts> smns, so I am a bit confused about that. Am I "guarantee"ing that via my (x:xs) syntax, or by nature of checking the length of xs?
17:53:53 <smns> magn3ts, by the order of your pattern matches.
17:54:36 <smns> magn3ts, if you first check against the empty list and that match fails, you know it's non-empty, so you don't even need to do x:xs. you could, but then you wouldn't know if xs is empty, and running last [] would be bad.
17:54:55 * magn3ts nods
17:55:20 <magn3ts> I think I understand then. Because on a single element list, the way you perform head/last they would be the same element :)
17:55:33 <magn3ts> which better matches the definition of "is the first/last elem the same" too.
17:55:57 <smns> magn3ts, you could do: firstLastSame (x:xs) | null xs = True ...
17:56:06 <smns> yup
17:56:18 <dylex> magn3ts: or, better: firstLastSame [x] = True
17:56:32 <magn3ts> it was kinda enough to let me take length of a null list. hehe
17:56:45 <magn3ts> dylex is that syntax for single-element-list?
17:57:01 <smns> yes, that's pattern matching a single-element list.
17:57:14 <magn3ts> cool.
17:57:19 <dylex> magn3ts: right, you can pattern match on lists explicitly, so [x,y] matches only lists of length 2.  ([_] is probably better since you don't actually care about the value)
17:57:30 <smns> you could also do firstLastSame [_] = True, since you're essentially not interested in x.
17:57:45 <magn3ts> nifty, nifty.
17:58:23 <smns> erlang gives you warnings if you have variables in your pattern that you don't use in the corresponding function body.
17:58:43 <magn3ts> Go gives you errors. It's rather annoying. Warnings I can understand.
18:07:18 <smns> Go has pattern matching?
18:07:52 <hpc> Go has pattern matching on tuples
18:13:07 <dylukes> hpc: Like python tuple matching?
18:13:21 <dylukes> hpc: (which is just "unpacking", doesn't really do any matching)
18:13:26 <hpc> basically
18:13:33 <dylukes> Does it do actual matching?
18:13:34 <hpc> (if i remember my python right)
18:13:48 <hpc> it's just stuff like
18:13:49 <dylukes> python doesn't allow: x, y, 1.0 = f_returning_three_tuple
18:13:55 <dylukes> x, y, z =... is fine
18:14:00 <hpc> (x, y) = get_point()
18:14:10 <dylukes> its just multiple return. Python's return values are auto-splatted.
18:14:14 <dylukes> (if they're tuples or lists)
18:14:28 <hpc> even perl is more powerful, because you can put 'undef' in the fields you don't want named
18:14:49 <hpc> or get the rest of the list as an element
18:15:10 <hpc> so it's truly like haskell's [] patterns (albeit only one at a time)
18:29:16 <smns> hmm... this is an interesting pattern
18:30:40 <shapr> smns: oh?
18:30:47 <shapr> smns: How so?
18:30:57 <smns> I've got 'foo :: Foo -> SomeMonad Bar' and 'foos :: [Foo] -> SomeMonad [Bar]' and I wrote foos by recursively applying foo.
18:31:34 <smns> but is all I need to do this using higher-order functions an fmap?
18:32:09 <smns> does SomeMonad need to be an instance of Functor?
18:32:32 <wavewave> sounds like mapM
18:32:38 <smns> aha.
18:32:48 <smns> I didn't know. I'll look into it. thanks.
18:33:27 <hpaste> t pasted “t” at http://hpaste.org/53730
18:33:43 <smns> wavewave, yeah, awesome.
18:34:33 <seanhess> https://gist.github.com/1346854 - Is the xml file being read lazily? I want to parse a 2GB xml file without ever loading the whole thing into memory
18:34:38 <hpaste> t pasted “t” at http://hpaste.org/53731
18:35:33 <wavewave> smns: check Control.*  modules from time to time.. it's treasure island.
18:35:50 <kmc> hehe
18:35:53 <smns> wavewave, yup.
18:36:07 <smns> wavewave, I only started using liftM2, LiftM3, etc. yesterday. ;-P
18:36:09 <kmc> if you want to browse all the modules in Platform: http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
18:37:06 <smns> wavewave, a good criterion for success is when every function is a not-too unreadable one-liner.
18:37:10 <Cale> You should always make monads instances of Functor. If nothing else you can simply write  instance Functor MyMonad where fmap = liftM
18:37:44 <smns> Cale, right.
18:41:24 <a215> someone help me with xmonad config?  errors: http://hpaste.org/53730 xmonad.hs: http://hpaste.org/53731
18:41:27 <a215>  : O
18:43:26 <smns> a215, try #xmonad unless you already have and they're not responding.
18:44:27 <a215> bingo
18:46:19 <Cale> a215: 0.8 || ...  <-- this looks really suspicious. || is the boolean or operator. What operation did you intend?
18:47:27 <a215> oh i thought it meant something different in haskell
18:48:23 <a215> i have no idea what it's supposed to do :O
18:48:27 <hpc> a215: lol
18:48:34 <smns> haha
18:48:39 <a215> well
18:48:42 <a215> there's two log hooks
18:48:50 <a215> one for fading inactive windows, the other for dzen
18:49:06 <a215> not sure how they're supposed to mix
18:49:23 <shachaf> dynamicLogWithPP gets an argument "defaultPP { ... }"
18:49:41 <shachaf> You probably want to compose logHooks, which I think is done with mappend or something.
18:50:00 <hpc> @hoogle logHoock
18:50:01 <lambdabot> No results found
18:50:01 <a215> hm
18:50:03 <hpc> @hoogle logHook
18:50:03 <lambdabot> No results found
18:50:08 <hpc> pah
18:50:33 <Cale> a215: According to the documentation, fadeInactiveLogHook :: Rational -> X ()
18:50:39 <hpc> http://hackage.haskell.org/package/xmonad-0.9.1 -- somewhere in there is how to compose log hooks
18:50:49 <a215> ;__________-;
18:50:57 <shachaf> Oh, no, just >>
18:51:40 <shachaf> logHook = do { fadeInactiveLoghook fadeAmount; dynamicLogWithPP defaultPP { blah blah } }
18:51:43 <shachaf> Something like that.
18:51:52 <shachaf> I'm not sure where the 0.8 gets into it.
18:52:27 * shachaf thinks it's somewhat unrealistic to expect people to write xmonad.hs files without knowing Haskell.
18:52:57 <hpc> shachaf: it would be more realistic if xmonad.hs wasn't so complex
18:53:01 <a215> \lol
18:53:04 <a215> that gives me a whole new batch of errors
18:53:22 <a215> couldn't match type X b0 with actual type PP
18:53:48 <smns> shachaf, I wrote my first one by copy-pasting things. it's not until I learned Haskell to some extent two months ago that I rewrote my xmonad.hs. I don't think it's unreasonable because, as long as you understand basic syntax and undo things when type errors occur, putting combinators together is kind of like playing with LEGOs.
18:53:53 <shachaf> I expect that that error means you're doing something wrong.
18:54:13 <shachaf> For example, maybe you're using "defaultPP ..." instead of "dynamicLogWithPP defaultPP ..."
18:54:18 <Cale> a215: Sorry, got pulled away for a second there in the middle of explaining
18:54:20 <shachaf> But it's hard to say, you know.
18:54:42 * a215 acts like he didn't do that by accident
18:54:43 <Cale> shachaf: The 0.8 is presumably the Rational parameter
18:54:59 <shachaf> Cale: Isn't that the fadeAmount?
18:55:14 <Cale> oh, well, probably
18:55:18 <hpaste> asg pasted “asg” at http://hpaste.org/53733
18:55:21 <a215> http://hpaste.org/53733
18:55:23 <a215> now i get that
18:55:47 <shachaf> a215: Your error tells us very little without the actual code that's causing it.
18:55:53 <shachaf> I already gave you my best guess. :-)
18:55:57 <hpaste> asg pasted “asg” at http://hpaste.org/53734
18:56:00 <a215> ^
18:56:23 <shachaf> a215: Maybe you need to fiddle with the indentation.
18:56:32 <a215> oh
18:56:32 <shachaf> Or split it up into two actions.
18:56:38 <a215> umm
18:56:43 <a215> does it just have to be indented to past defaultPP
18:56:45 <a215> after there
18:56:46 <Cale> a215: probably that defaultPP { ... } thing you wrote is supposed to be the parameter to dynamicLogWithPP
18:57:08 <a215> haskell indentation scares me
18:57:12 <a215> worse than python imho
18:57:13 <Cale> a215: dynamicLogWithPP :: PP -> X ()
18:57:22 <a215> wtf is an X ()
18:57:29 <a215> or a PP for that matter
18:57:32 <shachaf> a215: Fortunately for you Haskell indentation is completely optional. :-)
18:57:43 <a215> well it's an error
18:57:44 <shachaf> You can always use braces and semicolons instead of indentation.
18:58:03 <shachaf> A PP is a pretty-printer. An X () is an xmonad action.
18:58:20 <a215> how do i change the indentation ><
18:58:40 <Cale> Okay, an X () is a description of some stuff which can be done (and which may include I/O) and which may read and write Xmonad's state, before producing an empty tuple () as its result
18:58:41 <a215> np: Dr. Octagon - Earth People
18:58:41 <smns> is there a pair x y = (x, y) function?
18:58:52 <shachaf> smns: Yes; it's called "(,)".
18:58:54 <a215> hmm
18:58:56 <shachaf> > (,) 1 2
18:58:57 <lambdabot>   (1,2)
18:59:00 <smns> shachaf, thanks.
18:59:09 <a215> > map sin [1..30]
18:59:10 <lambdabot>   [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.75680249530792...
18:59:25 <wavewave> smns : you may be also interested in uncurry
18:59:35 <wavewave> @t uncurry
18:59:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:59:38 <smns> wavewave, yes, I know that.
18:59:47 <wavewave> > :t uncurry
18:59:48 <lambdabot>   <no location info>: parse error on input `:'
18:59:54 <smns> @t Prelude.uncurry
18:59:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:59:55 <wavewave> :t uncurry
18:59:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:00:05 <Cale> A value of type PP is a record consisting of functions saying how to format bits and pieces of status information (turn them into Strings) for logging.
19:00:38 <Cale> dynamicLogWithPP :: PP -> X ()
19:00:41 <a215> oh
19:00:48 <Cale> Formats the current status using the supplied pretty-printing format, and write it to stdout.
19:00:53 <a215> write
19:00:57 <a215> right*
19:00:58 <a215> so
19:01:02 <a215> indent it five times? lol
19:01:52 <Cale> Well, we have  dynamicLogWithPP (defaultPP { ... your preferences ... }) :: X ()
19:02:23 <Cale> and we have  fadeInactiveLogHook 0.8 :: X ()
19:02:53 <Cale> and to glue them together into a larger X action, we can use do-notation:
19:03:03 <Cale> do fadeInactiveLogHook 0.8 :: X (); dynamicLogWithPP (defaultPP { ... your preferences ... })
19:03:26 <Cale> er, the type annotation is unnecessary there
19:03:32 <Cale> do fadeInactiveLogHook 0.8; dynamicLogWithPP (defaultPP { ... your preferences ... })
19:04:04 <Cale> You can write that without the semicolon, breaking the line there, and lining up "fade" with "dyna"
19:04:13 <a215> xmonad.hs:82:20: parse error on input `{'
19:04:19 <a215> the line where the defaultPP block starts
19:04:57 <a215> do you want me to cut out all the indentation
19:05:18 <Cale> This do-block is itself an expression of type X (), which is hopefully the right type to be a logHook
19:05:47 <a215> is that a yes
19:06:09 * hackagebot angel 0.3 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.3 (JamieTurner)
19:06:10 <Cale> (It is the right type, I checked.)
19:06:12 * hackagebot scalable-server 0.1 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.1 (JamieTurner)
19:06:40 * a215 is even more confused now
19:06:41 <Cale> So, you can just write directly into your config:
19:06:56 <Cale> logHook = do fadeInactiveLogHook 0.8; dynamicLogWithPP (defaultPP { ... your preferences ... })
19:07:23 <a215> with no newlines?
19:07:25 <a215> or indents?
19:07:51 <a215> ???
19:07:52 <Cale> You can newline and indent appropriately.
19:07:54 <Sgeo|web> Is it currently possible to do all I/O with FRP?
19:08:01 <a215> what does that meann
19:08:02 <Cale> Or you can put it all on one line
19:08:09 <a215> ok /me does that
19:08:25 <Cale> All the lines of a do-block should be aligned vertically (start in the same column)
19:08:49 <Cale> So the first non-whitespace character after 'do' needs to line up with the first non-whitespace character of each line of the do-block after that
19:09:11 <Cale> If you want to continue one statement of the do-block to multiple lines, you indent it more than that.
19:09:29 <Cale> Does that make sense?
19:10:00 <a215> xmonad.hs:82:23: parse error on input `{'
19:10:12 <hpaste> dfhdf pasted “gfhdfh” at http://hpaste.org/53735
19:10:18 <a215> ^
19:10:54 <hpaste> Cale annotated “gfhdfh” with “gfhdfh (annotation)” at http://hpaste.org/53735#a53736
19:10:58 <Cale> try that
19:11:33 <Cale> The dynamicLogWithPP ... is all one statement of the do-block, and we want to continue it onto multiple lines
19:11:46 <Cale> So we need to indent the following lines more
19:11:50 <Cale> yeah?
19:11:54 <hpaste> sdgf annotated “gfhdfh” with “gfhdfh (annotation) (annotation)” at http://hpaste.org/53735#a53737
19:11:56 <a215> ^
19:11:58 <a215> that error
19:12:30 <Cale> a215: That error is from somewhere else in your config...
19:12:47 <Cale> logHook            = dynamicLogWithPP $ myLogHook din  -- do you still have this?
19:12:57 <Cale> (that's ill-typed)
19:13:07 <Cale> logHook            = myLogHook din  -- change it to this
19:13:07 <a215> yes
19:13:23 <a215> looks like it works let me double check
19:14:11 <a215> oh yes
19:14:13 <a215> BEAUTIFUL
19:14:17 <a215> look at that transparency
19:14:24 <a215> np: Dr. Octagon - Technical Difficulties
19:14:33 <Cale> dynamicLogWithPP would want a PP value as its parameter, but myLogHook din is an X action
19:14:46 <a215> this would all make more sense to me if i wrote xmonad
19:14:56 <Cale> I don't even use xmonad ;)
19:15:07 <a215> what do you use
19:15:07 <Cale> (but I know how to read Haskell documentation, that helps ;)
19:15:11 <Cale> I use metacity
19:15:15 <a215> ughh
19:15:21 <a215> i wouldn't trade xmonad for anything
19:15:27 <a215> i feel like i'm in the future
19:15:35 <Cale> I can't stand tiling windowmanagers somehow
19:15:41 <a215> i can't stand any other way
19:15:43 <Philippa> you think that's bad? I got asked why I don't use xmonad at Barcamp Nottingham when I was doing a Haskell talk, had to explain I was running windows :p
19:15:47 <Cale> MUST... OVERLAP... WINDOWS...
19:15:57 <a215> you can overlap in xmonad!
19:16:04 <a215> and it does such a sweet job of it too
19:16:14 <a215> you can have a terminal open while you watch a movie in fullscreen
19:16:19 <dxq> nothing wrong with windows
19:16:21 <monochrom> people are so religious about what other people use
19:16:25 <a215> plenty wrong iwth windows haha
19:16:30 <dxq> plenty wrong with every OS
19:16:34 <a215> monochrom: well, once you know the One True Way
19:16:34 <Philippa> mostly I only want overlap for dialogs and the odd thing like calculators where I'm probably punching in data taken from another program. But I run most apps maximised on my laptop anyway
19:16:58 <a215> i've been using win 7 for months on my laptop
19:17:01 <a215> no linux at all
19:17:04 <a215> now i get my computer back...
19:17:06 <Philippa> IME, it's to shoot people who think there is one. Which is why I don't /have/ one
19:17:07 <Cale> a215: Last time I tried it, it was pretty inconvenient. Does it have draggable window borders and titlebars yet?
19:17:08 <a215> xmonad and linux 3 now
19:17:13 <a215> Cale: yes it has both
19:17:17 <a215> take my config and try it
19:17:22 <a215> MouseResizableTile
19:17:30 <a215> no titlebars that i know of sorry
19:17:35 <a215> i'm sure someone made that tho
19:17:46 <Cale> Yeah, I could probably write it myself :P
19:17:53 <a215> i prefer to mod-right click and resize that way
19:17:55 <a215> so fast
19:18:02 <a215> no searching around for the border
19:18:04 <a215> click anywhere!
19:18:27 <Cale> That works in metacity too
19:18:39 <Cale> But I don't really ever think to use it
19:19:24 <a215> i set up linux at work just to use xmonad
19:19:25 <a215> lol
19:19:33 <a215> well and a few other reasons
19:20:50 <monochrom> I found the One True Way. it is to find out and deliberately defy what you want me to do, right in your face, so as to make you feel uncomfortable.
19:23:01 <monochrom> for example, I know people who have problem accepting that someone else uses proportional fonts for irc. so I show them screenshots of me using proportional fonts for irc.
19:23:36 <monochrom> (actually, I showed the screenshot, then afterwards I heard people objecting strongly. strange people.)
19:23:38 <kmc> let's say i'm writing/binding a new regex library for Haskell
19:23:47 <kmc> is there a sane typeclass or other generic interface I should conform to?
19:24:01 <kmc> i really dislike that (=~) business
19:24:12 <a215> > whatDoYouThinkAboutThat lambdabot
19:24:14 <lambdabot>   "i think monochrom's way sucks"
19:24:23 <a215> well there you have it
19:24:25 <a215> right from the bot
19:24:44 <ion> She put it in quotes. She didn’t seem to mean it.
19:24:54 <RaptorRarr> > text "zomg no quotes"
19:24:55 <lambdabot>   zomg no quotes
19:25:02 <a215> hm
19:25:09 <shachaf> kmc: Your function should expose an interface :: RegexLibrary a => a
19:25:18 <a215> > map (\x -> x `mod` 3) [1..10]
19:25:19 <lambdabot>   [1,2,0,1,2,0,1,2,0,1]
19:26:07 <a215> > map (\x -> chr $ x `mod` 3 + 65) [3..10]
19:26:07 <shachaf> kmc: (How is http://hackage.haskell.org/package/regex-compat ?)
19:26:08 <lambdabot>   "ABCABCAB"
19:26:27 <a215> > map (\x -> chr $ x `mod` 3 + 65) [3..30]
19:26:28 <lambdabot>   "ABCABCABCABCABCABCABCABCABCA"
19:26:33 <a215> abra cadabra
19:26:49 <monochrom> that one single (=~) overloads several things such as "is it a match? (Bool)", "what is the first match? (String)", "what are all matches? ([String])", etc. they are fairly easy to conceptually separate. I think if you just split it into 4 or 5 operators, it's good.
19:26:52 <shachaf> Hmm, seems a bit limited.
19:27:54 <a215> > fishLiningUpInARow
19:27:56 <lambdabot>   <=><=><=><=><=><=><=><=><=>
19:28:13 <a215> eh...
19:28:15 <RaptorRarr> (=~): because terse Perl is understandable.
19:29:29 <Sgeo|web> Are there any good FRP tutorials?
19:29:33 <Sgeo|web> I skimmed the Frap one
19:29:49 <magn3ts_> Is there a common pattern for traversing a list and altering elements but tracking the element that you just changed for the next change (if that isn't compelete gibberish)
19:30:17 <shachaf> magn3ts_: mapAccumL?
19:30:25 <shachaf> You might @ty mapAccumL
19:30:30 <shachaf> @ty mapAccumL
19:30:30 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
19:31:08 <shachaf> Oh, but you just want the previous value passed in, not some other accumulator?
19:31:24 <shachaf> magn3ts_: Code is probably a clearer way to specify what you're after than English. :-)
19:31:55 <kmc> yeah, it seems that the one design goal for (=~) was "allow the programmer to think they are writing Perl instead"
19:31:59 <a215> Sgeo|web:  get the source for the FRP quake clone
19:32:00 <magn3ts_> [[1,2],[5,6]] would become [[1,2],[4,4]]  so elements values are curElem-prevElem
19:32:04 <kmc> generally a bad design goal for haskell code
19:32:11 <a215> or i can paste you some basic FRP code i have on here
19:32:17 <a215> somewhere...
19:32:25 <a215> or just look up 3d haskell tetris
19:34:17 <Sgeo|web> Is there a recommended library?
19:34:30 <Sgeo|web> I'm looking at a tutorial for Elerea
19:35:07 <a215> for what in specific
19:35:25 <Sgeo|web> General FRP stuff
19:35:45 <a215> docs are limited... take the tips i gave you
19:35:49 <a215> i've looked into this a lot myself
19:36:38 <magn3ts_> hm, if I process the list backwards it should be too bad.
19:39:49 <Cale> magn3ts_: zip xs (tail xs)?
19:39:54 <Cale> magn3ts_: and then map?
19:40:05 <Cale> Or of course, zipWith f xs (tail xs)
19:40:38 <Cale> Is that what you mean?
19:40:45 <shachaf> Or (zipWith f <*> tail) xs
19:41:31 <magn3ts_> Cale, I can give a better example: [[1,1],[5,5],[9,6]] -> [[1,1],[+4,+4],[+4,+1]] (signs for clarity only)
19:41:54 <RaptorRarr> Or if null xs then [] else zipWith f xs (tail xs)
19:42:00 <magn3ts_> I'm reasoning through it, it seems if I start at the back, I can in-place alter the elements without having to track a "saved" value.
19:42:02 <Cale> Well, if we ignore the first element of your result there...
19:42:18 <shachaf> > zipWith (,) [] (tail []) -- Works fine.
19:42:18 <lambdabot>   []
19:42:25 <RaptorRarr> orly?
19:42:31 <RaptorRarr> Thanks :)
19:42:46 <Axman6> shachaf: it's not guaranteed to work fine though is it?
19:42:55 <Axman6> hmm, maybe it is, due to currying
19:43:06 <Axman6> > zip [] undefined
19:43:07 <Cale> > let xs = [[1,1],[5,5],[9,6]] in zipWith (zipWith subtract) xs (tail xs)
19:43:07 <lambdabot>   []
19:43:08 <lambdabot>   [[4,4],[4,1]]
19:43:53 <shachaf> Axman6: What does it have to do with currying?
19:43:56 <RaptorRarr> > zip undefined []
19:43:57 <lambdabot>   *Exception: Prelude.undefined
19:44:01 <shachaf> @src zipWith
19:44:01 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
19:44:01 <lambdabot> zipWith _ _      _      = []
19:44:16 <Axman6> hmm, right
19:44:28 <Axman6> i was forgetting my definition of zipWith
19:45:09 <shachaf> magn3ts_: There's no such thing as "in-place alter" anything. :-)
19:45:13 <Cale> > let xs = repeat 0 : [[1,1],[5,5],[9,6]] in zipWith (zipWith subtract) xs (tail xs)
19:45:13 <lambdabot>   [[1,1],[4,4],[4,1]]
19:45:15 <shachaf> Anyway, Cale's solution does what you want.
19:45:27 <shachaf> Cale: Hah.
19:45:35 <magn3ts_> yeah, I'm trying to get through it and comprehend all of it :)
19:45:43 * shachaf expects that what you want is actually Cale's first solution.
19:46:49 <Cale> magn3ts_: Well, first of all, zipWith subtract
19:47:29 <Cale> > zipWith subtract [10, 20] [111,222]
19:47:29 <lambdabot>   [101,202]
19:47:39 <Cale> > zipWith subtract [10, 20] [111,222,333]
19:47:40 <lambdabot>   [101,202]
19:47:47 <Cale> > zipWith subtract [10, 20, 300] [111,222,333]
19:47:48 <lambdabot>   [101,202,33]
19:48:29 <Cale> It zips two lists together elementwise, applying the function to corresponding elements.
19:48:37 <Cale> > subtract 10 111
19:48:38 <lambdabot>   101
19:49:17 <Sgeo|web> @faq Can unsafePerformIO obliterate the Earth?
19:49:17 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:20 <Axman6> read subtract x y as 'subtract x from y'
19:49:21 <Cale> Now consider what happens when we zip a list with its own tail
19:49:33 <magn3ts_> mhm, I get that part. I think the repeat 0 gives you [0, 0, ... 0] and concat with the original to offset it to the right to make the subtraction do what I want.
19:49:38 <RaptorRarr> @faq Can Haskell lie?! Evil, evil lies!!
19:49:38 <lambdabot> The answer is: Yes! Haskell can do that.
19:49:46 <Cale> magn3ts_: yeah
19:50:02 <Cale> > repeat 0
19:50:03 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:50:17 <Cale> zipWith will automatically trim that to however many elements are needed
19:50:28 <RaptorRarr> zipWith++
19:51:00 <Cale> > zip [1,2,3] (tail [1,2,3])
19:51:01 <lambdabot>   [(1,2),(2,3)]
19:51:02 <magn3ts_> not so much trimming as simply enumerating as far as it needs to if I understand haskell lists at all :P
19:51:08 <Cale> > zip [1,2,3,4] (tail [1,2,3,4])
19:51:08 <lambdabot>   [(1,2),(2,3),(3,4)]
19:51:13 <Cale> yes
19:51:17 <Cale> That's all I mean :)
19:51:45 <Cale> > zip [0..] "Hello" -- this is a common idiom for pairing the elements of a list with their indices
19:51:46 <lambdabot>   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
19:51:52 <magn3ts_> > zip repeat 0 : [1,2,3,4] (tail [1,2,3,4]
19:51:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:51:59 <magn3ts_> > zip repeat 0 : [1,2,3,4] (tail [1,2,3,4])
19:52:00 <lambdabot>   Couldn't match expected type `[a]'
19:52:00 <lambdabot>         against inferred type `a1 -> [a1]'
19:52:25 <RaptorRarr> > zip (repeat 0 ++ [1,2,3,4]) (tail [1,2,3,4])
19:52:27 <lambdabot>   [(0,2),(0,3),(0,4)]
19:52:41 <Cale> > [c | (n,c) <- zip [1..] "stutter", k <- [1..n]]
19:52:41 <lambdabot>   "sttuuuttttttttteeeeeerrrrrrr"
19:53:06 <byorgey> is there a library on hackage that lets you work with rings like Q[sqrt(2)] ?
19:53:17 <byorgey> or do I have to implement it myself?
19:53:35 <byorgey> actually, I want Q[sqrt(2), sqrt(3)]
19:54:00 <Axman6> > [c | (n,c) <- zip [1..] "stutter", [1..n]]
19:54:00 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:54:01 <lambdabot>         against inferred type ...
19:54:04 <Axman6> :(
19:56:03 <geekosaur> > [c | (n,c) <- zip [1..] "stutter", _ <- [1..n]]
19:56:04 <lambdabot>   "sttuuuttttttttteeeeeerrrrrrr"
19:58:41 <magn3ts_> still not understanding why both zipwith's are needed, seems like something like this could work:
19:58:56 <magn3ts_> zipWith (subtract) xs (repeat 0 ++ xs)
19:59:05 <shachaf> magn3ts_: That's if it was a list of numbers.
19:59:35 <magn3ts_> shachaf, where subtract is my own method :)
19:59:41 <magn3ts_> function*** sorry
19:59:41 <shachaf> repeat 0 ++ xs =~= xs
19:59:48 <shachaf> magn3ts_: What? subtract is a standard name.
19:59:51 <shachaf> > subtract 2 5
19:59:52 <lambdabot>   3
19:59:58 <magn3ts_> shachaf, my bad, poor example.
20:00:07 <magn3ts_> > repeat 0 ++ [2, 3]
20:00:09 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:00:11 <shachaf> Anyway, "repeat 0 ++ xs" is pretty much the same as "repeat 0".
20:00:15 <magn3ts_> > repeat  [2, 3] ++ 0
20:00:16 <lambdabot>   No instance for (GHC.Num.Num [[t]])
20:00:16 <lambdabot>    arising from a use of `e_1230' at <i...
20:00:32 <Axman6> magn3ts_: what do you expect that to do?
20:00:36 <Axman6> :t (++)
20:00:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:00:42 <Axman6> urgh >_<
20:00:48 <Axman6> :t Prelude.(++)
20:00:49 <lambdabot> Not in scope: data constructor `Prelude'
20:00:59 <Axman6> :t (Prelude.++)
20:01:00 <lambdabot> forall a. [a] -> [a] -> [a]
20:01:07 <magn3ts_> Axman6, I was playing with it, and made a dumb mistake on that last line
20:01:13 <Axman6> > 1 ++ 2
20:01:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:01:14 <lambdabot>    `Data.Monoid.Monoid a'
20:01:14 <lambdabot>  ...
20:01:18 <Axman6> > 1 ++ 2 :: Sum Int
20:01:19 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
20:01:19 <lambdabot>    arising fr...
20:01:27 <Axman6> :\
20:01:32 <Axman6> whatevs
20:02:23 <magn3ts_> I do have a conceptual blip though, between ':' for adding to a list and ++ for concat
20:02:33 <magn3ts_> just figured that out too though :P
20:02:58 <magn3ts_> [0,0,0,0,0] : [[1,2],[3,4]]   or [[0,0,0,0,0]] ++ [[1,2],[3,4]]
20:02:59 <magn3ts_> this is fun :)
20:03:06 <shachaf> : is a much more fundamental operation.
20:03:14 <shachaf> That's what lists are actually made of. It's a constructor.
20:03:33 <shachaf> ++ is just a convenient utility.
20:03:35 <shachaf> @src ++
20:03:35 <lambdabot> []     ++ ys = ys
20:03:35 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:03:35 <lambdabot> -- OR
20:03:35 <lambdabot> xs ++ ys = foldr (:) ys xs
20:04:18 <moriramar> I am always surprised by people here making all kinds of list with only standard Haskell functions and a simpler list.
20:04:44 <magn3ts_> is that what haskells all about?
20:05:34 <Axman6> it's it's about being able to make complex things in elegant ways using simple things
20:05:36 <parcs> Axman6: hmm maybe there should be Num instances for Sum and Product
20:05:46 <Axman6> indeed
20:05:51 <shachaf> It's about zygohistomorphic prepromorphisms.
20:05:52 <Axman6> well, actually, maybe not
20:06:15 <Axman6> because, then you'd have (*) for Sum, and (+) for Product... not sure if that's desirable or not
20:06:47 <parcs> yeah i took it back right after i suggested it
20:11:26 <moriramar> shachaf, zygohistomorphic prepromorphisms... what is this? I refered to dictionary but got nothing...
20:11:45 <PiRSquared17> @pl \x -> \y -> x + y
20:11:45 <lambdabot> (+)
20:11:53 <PiRSquared17> @pl \x -> \y -> x + 1
20:11:53 <lambdabot> const . (1 +)
20:12:48 <PiRSquared17> @pl \x -> \y -> \z -> flip x y x z y z x
20:12:49 <lambdabot> flip =<< (flip .) . flip flip id . (ap .) . join . (flip .) . join id
20:14:09 <Axman6> @pl \x y -> x y x y x y
20:14:09 <lambdabot> join . (flip =<< join . join flip)
20:14:50 <parcs> @quote zygohistomorphic
20:14:50 <lambdabot> comonad says: - comonad [~functor@zygohistomorphic-prepromorphism.endofunctor.org] has joined #haskell
20:15:03 <parcs> @quote zygohistomorphic
20:15:03 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
20:15:19 <parcs> moriramar: it's a #haskell meme
20:15:41 <parcs> and also a real thing that ~3 people understand; http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
20:15:58 <PiRSquared17> @pl \x -> \y -> \z -> (flip .) x y z y x
20:15:59 <lambdabot> flip =<< (flip .) . join
20:16:14 <geekosaur> IIRC the source to the library that defines it more or less calls it out as a name made up out of thin air
20:16:45 <moriramar> parcs, ... okay, i give up...
20:16:57 <parcs> that's the right thing to do sometimes
20:17:27 <PiRSquared17> @pl \x -> \y -> \z -> x + (y / z / x)
20:17:27 <lambdabot> ap ((.) . (.) . (+)) (flip (flip . ((/) .) . (/)))
20:18:02 <PiRSquared17> @unpl ap ((.) . (.) . (+)) (flip (flip . ((/) .) . (/)))
20:18:02 <lambdabot> ((\ v b c f -> v + (b c f)) >>= \ o -> (\ h i l -> (i / l) / h) >>= \ n -> return (o n))
20:18:25 <moriramar> parcs, well, that's a hard decision in front of the thirst for knowledge...
20:18:25 <parcs> geekosaur: what library defines it?
20:18:37 <PiRSquared17> @unpl ($).($)
20:18:37 <lambdabot> (\ g b -> g b)
20:19:12 <PiRSquared17> @unpl (.)$(.)
20:19:12 <lambdabot> (\ b c e f -> b c (e f))
20:19:21 <PiRSquared17> S combinator?
20:19:38 <PiRSquared17> no...
20:19:58 <PiRSquared17> @pl \x -> \y -> \z -> x z (y z)
20:19:58 <lambdabot> ap
20:23:51 <PiRSquared17> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
20:23:51 <lambdabot> ap (. join id) (. join id)
20:24:45 <PiRSquared17> @pl \f -> (\x -> x x) (\x -> f (x x))
20:24:45 <lambdabot> join id . (. join id)
20:51:14 * hackagebot hastache 0.2.1 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.2.1 (SergeyLymar)
20:53:54 <shapr> Maybe I'll finally be able to grow a mustache now that I have templates to show me how.
20:56:53 <kfish>     O..O
20:56:53 <kfish>  <mustache/>
20:56:57 <olsner> ooh, it's Mustache Template Haskell
20:57:21 <shapr> olsner: srsly?
20:57:34 <olsner> of course it is
20:57:42 <shapr> Sounds very British
20:58:11 <olsner> not quite as majestic as Template Template Haskell, but a bit more so than plain Template Haskell
20:58:26 <shapr> huh
20:58:52 <magn3ts_> I feel this may be dumb of me still:  ''x ++ [head x]''
21:02:28 <shapr> magn3ts_: eh?
21:02:32 <shapr> magn3ts_: What are you trying to do?
21:03:31 <crc_> so i want to have a plugin interface, so i load modules containing functions that look like this: initState :: PluginState ; run :: input -> State (PluginState output). Now the problem is i want plugins to be able to define their own PluginState, yet at the same time treat the plugins generically. For example have a list of different plugin states. I know what i just said is impossible in haskell. Anyone have ideas for workarounds?
21:04:05 <crc_> a void * would be very nice
21:04:32 <Sgeo|web> Why was Yampa forked?
21:05:00 <parcs> crc_: you may be looking for existential types
21:10:23 <magn3ts_> do I *have* to specify type for a function?
21:10:32 <magn3ts_> I thought I did, but it let me get away with omitting it.
21:10:42 <parcs> for the most part no
21:10:43 <crc_> parcs: thanks this looks interesting. dont know if it will play nicely with haskell plugins though. anyway good reading
21:11:34 <shapr> magn3ts_: Mostly you don't need to specify the type, Haskell can figure it out by itself.
21:11:58 <ion> It’s a good idea to specify the types of top-level definitions for additional correctness verification and documentation.
21:12:25 <magn3ts_> nifty.
21:17:37 <davecarp> 0.
21:18:18 <shapr> davecarp: 1.
21:18:23 <crc_> parcs: thats exactly what i wanted thank you
21:18:39 <parcs> crc_: :P
21:20:29 <magn3ts_> Is there something like List.nubs that I can give a function to check equality?
21:20:53 <geekosaur> Data.List.nubBy
21:20:55 <magn3ts_> nubby
21:20:56 <magn3ts_> :)
21:20:59 <magn3ts_> geekosaur, thanks
21:21:18 * hackagebot hastache 0.2.2 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.2.2 (SergeyLymar)
21:33:07 <magn3ts_> Hm. Getting stumped by this sucka.     No instance for (Num [Float])
21:33:07 <magn3ts_>       arising from the literal `100'
21:33:07 <magn3ts_>     Possible fix: add an instance declaration for (Num [Float])
21:33:20 <shachaf> magn3ts_: An error on its own won't tell us much.
21:33:26 <magn3ts_> oh I'm an idiot.
21:33:27 <shachaf> Probably you're trying to add a list to a list or something.
21:33:41 <magn3ts_> Why trying to compare a list with an float value
21:33:45 <magn3ts_> forgot to access the elem :P
21:35:06 * magn3ts_ is really enjoying haskell
21:37:33 <Axman6> wait until you start getting to the fin stuff ;)
21:37:38 <Axman6> fun*
21:39:51 <doc_who> why doesnt 'putStrLn . show (1 + 1)' work when 'putStrLn . show $ 1 + 1' does?
21:40:30 <ion> > (putStrLn . show) (1 + 1)
21:40:31 <lambdabot>   <IO ()>
21:40:35 <shachaf> doc_who: Because the former is equivalent to putStrLn . (show (1 + 1))
21:40:51 <shachaf> Function application binds more tightly than infix operators.
21:41:05 <Cale> ^^ that is the most important thing to remember about Haskell precedence
21:41:48 <shachaf> There are only two things that bind more tightly than function application. :-)
21:42:02 <doc_who> . and $?
21:42:16 <liyang> Record update and …?
21:42:18 <shachaf> No. Those are operators; see above.
21:42:23 <shachaf> liyang: Record creation.
21:42:32 <shachaf> Those look similar but are actually two different things syntactically.
21:42:59 <liyang> Oh. Point.
21:43:02 <shachaf> > Just {}
21:43:03 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
21:43:03 <shachaf> > (Just) {}
21:43:04 <lambdabot>   <no location info>: Empty record update
21:43:27 <shachaf> Maybe that's not the best example, but you get the point, anyway.
21:43:34 <liyang> The distinction hadn't really crossed my mind.
21:43:34 <kmc> > Endo {}
21:43:35 <lambdabot>   No instance for (GHC.Show.Show (Data.Monoid.Endo a))
21:43:35 <lambdabot>    arising from a use ...
21:43:40 <kmc> > Any {}
21:43:41 <lambdabot>   Any {getAny = *Exception: <interactive>:3:0-5: Missing field in record cons...
21:43:57 <kmc> wait, why is an empty record update not allowed
21:44:02 <kmc> surely x {} ≡ x
21:45:37 <shachaf> It's annoying.
21:46:12 <ion> The record syntax in general is annoying.
21:46:26 <ion> But at least it isn’t as bad as in Erlang. :-P
21:46:30 <shachaf> Maybe because it's something you never want but might accidentally use instead of the (more useful) empty record creation.
21:46:44 <shachaf> Actually, the only place "empty record creation" syntax is useful is in patterns, I think.
21:46:54 <shachaf> So no excuse, really.
21:47:38 <ion> > Nothing {}
21:47:39 <lambdabot>   Nothing
21:47:53 <kmc> that's assuming you don't want to do the thing with undefined fields
21:47:56 <ion> > Nothing {} {}
21:47:57 <lambdabot>   <no location info>: Empty record update
21:48:06 <shachaf> kmc: Well, yes.
21:48:13 <shachaf> But I would consider taht thing unjustified.
21:48:32 <shachaf> Anyway the Report is full of places where they rule out empty special cases.
21:49:23 <shachaf> Like nullary classes/empty data constructors/empty case expressions.
21:49:48 <shachaf> s/constructor/type/
21:50:06 <shachaf> I guess nullary classes are justified in that they don't have MPTCs at all, and empty data types are justified in that the = sign is part of the data declaration syntax.
21:59:59 <kmc> empty case expression, though!
22:00:02 <kmc> should totally be a thing
22:00:53 <shachaf> Yep.
22:01:07 <shachaf> Also case lambdas.
22:02:30 <shk> Hi all
22:03:30 <shk> Where can i find implemetation of <|> from Alternative class type for Maybe ?
22:03:48 <shachaf> Probably in the source of Control.Applicative.
22:03:51 <shachaf> Or Data.Maybe.
22:04:56 <shk> If Applicative is a monoid on applicative functors and <|> has type (Applicative f) => f a -> f a -> f a, then <|> is like mappend behavior, Am i understand correctly?
22:05:35 <shachaf> s/pplicative/lternative/ ?
22:05:58 <shachaf> Anyway, yes, <|> is associative and has "empty" as an identity.
22:07:22 <incluye> > (const . const) <$> (Just 3) <*> (Just 4)
22:07:23 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
22:07:23 <lambdabot>    arising from a use of `...
22:07:26 <incluye> okay
22:07:31 <incluye> > (const . const) <$> (Just 3) <*> (Just 4) <*> (Just 5)
22:07:33 <lambdabot>   Just 3
22:07:46 <incluye> that explains a lot
22:08:37 <shk> shachaf: thank you for your reply, i'm beginner in Haskell developing, can i ask you, maybe haskell has some documetatiof for this situation, i think source it's not handy place,
22:09:01 <shachaf> shk: Well, really, I imagine there's only one reasonable instance.
22:09:24 <shachaf> Why is the source not convenient? I'd think that it's the clearest explanation of what <|> does.
22:10:05 <mzero> isn't <!> equivalent to mplus, not mappend?
22:10:15 <shachaf> shk: http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Control-Applicative.html#line-96
22:10:20 <shk> Haskell has big code base and sometimes search of something can take a long time
22:10:27 <shachaf> mzero: Right, it has a different kind and different behavior from mappend.
22:10:35 <mzero> > Just "abc" <|> Just "def"
22:10:36 <lambdabot>   Just "abc"
22:10:41 <shachaf> mzero: But it also obeys the monoid laws. :-)
22:11:18 <shk> shachaf: yes, thank you
22:11:57 <shachaf> shk: (I got there by searching for "alternative haskell" on Google and then looking at the source. :-) )
22:12:15 <shk> shachaf: :)
22:13:00 <shachaf> shk: ghci will also tell you where the instance is defined.
22:13:57 <mzero> I should publish my big cheat sheet: It charts out what all the major operations of Functor, Applicative, Monad, Alternative, MonadPlus, and Monoid do for each of [a], Maybe a, d -> a, Either e a, and (b,a)
22:15:39 <shachaf> Isn't that Typeclassopedia?
22:15:46 <shachaf> Oh, maybe not given the last few words. :-)
22:17:42 <Sgeo|web> Iteratees vs FRP?
22:18:01 <Axman6> they're not exactly competing concepts
22:18:20 <Sgeo|web> Hmm? Explain?
22:18:25 <Axman6> there's some overlap, but i don't think they're anywhere near competing
22:18:46 <Sgeo|web> I kind of barely understand FRP, and don't understand Iteratees at all
22:18:53 <shachaf> Sgeo|web: So why are you asking?
22:19:03 <Sgeo|web> shachaf: Because I'm curious
22:19:18 <Axman6> iteratees are basically designed for working with streaming data in (hopefully) constant, or at least bounded space. FRP is using functions that react to events (i believe?)
22:19:38 <shachaf> What's better: [something I don't understand] or [something else I don't understand]?
22:19:44 * shachaf demands an answer at once.
22:19:54 <conal> FRP is rooted in semantics, while iteratees is an implementation without a semantics, afaict.
22:19:58 <Axman6> shachaf: well, it depends
22:19:59 <companion_cube> shachaf: _|_
22:20:01 * shachaf speaking with tongue in cheek, of course.
22:20:27 <conal> And FRP (badly named) is about continuous time.
22:20:45 <Axman6> has anyone heard of the language Esterel?
22:20:51 <conal> Axman6: i have.
22:21:06 <companion_cube> Axman6: synchronous language?
22:21:09 <conal> Axman6: deterministic, discrete time, parallel
22:21:36 <Axman6> it's been mentioned a fair bit in our real-time and embedded systems course
22:22:31 <conal> more on FRP at http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631
22:22:34 <Axman6> seems like an interesting idea, all code is designed to react to inputs 'instantly', and you 'just' have to make sure the maximum time anything can take to compute is lower than the sample rate to make sure that appears to be true
22:22:55 <incluye> > some 3 <|> pure []
22:22:56 <lambdabot>   No instance for (GHC.Show.Show (f [a]))
22:22:56 <lambdabot>    arising from a use of `M73410661...
22:23:47 <Axman6> it's very functional, but with some extra stuff
22:23:52 <marvinalone> if i have a function f :: a -> b -> Either String b, and a list [a], what's the best way to get a function g :: [a] -> Either String b? I think there must be some way that combines folds with monads, but I'm pretty fuzzy on that.
22:24:25 <Axman6> marvinalone: you don't want g :: [a] -> Either String [b]?
22:24:53 <marvinalone> Axman6: no, function f essentially modifies b and returns a new b ... or Left "error"
22:25:08 <Axman6> oh right, i missed the b parameter
22:25:26 <Axman6> where do you get your initial b from?
22:25:31 <mzero> shachaf: it is a single chart, -- Typeclassopedia is lovely - but not a quick reference
22:25:48 <marvinalone> Axman6: in this case, it's an empty map
22:26:18 <marvinalone> Axman6: i could imagine it being 0 or 1 or some other neutral value in the general case
22:26:30 <Axman6> :t foldl
22:26:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:26:41 <Sgeo|web> reactive-banana has a way to use an event-based library and use it in an FRP manner. Does Yampa have something similar?
22:27:52 <Axman6> :t \f xs -> foldl (\acc x -> case acc of Left str -> Left Str; Right b -> f x b) (undefined :: String {- testing -}) xs
22:27:53 <lambdabot>     Couldn't match expected type `Either (String -> TextDetails) t'
22:27:53 <lambdabot>            against inferred type `String'
22:27:53 <lambdabot>     In the second argument of `foldl', namely `(undefined :: String)'
22:27:57 <Axman6> o.O
22:27:59 <Axman6> ok then...
22:28:25 <Axman6> :t \f xs -> foldl (\acc x -> case acc of Left str -> Left Str; Right b -> f x b) (Right 1) xs
22:28:26 <lambdabot> forall b t. (Num t) => (b -> t -> Either (String -> TextDetails) t) -> [b] -> Either (String -> TextDetails) t
22:28:34 <Axman6> :t \f xs -> foldl (\acc x -> case acc of Left str -> Left str; Right b -> f x b) (Right 1) xs
22:28:35 <lambdabot> forall b t t1. (Num t1) => (b -> t1 -> Either t t1) -> [b] -> Either t t1
22:28:44 <Axman6> :t \f xs -> foldl (\acc x -> case acc of Left str -> Left (str :: String); Right b -> f x b) (Right 1) xs
22:28:45 <lambdabot> forall b t. (Num t) => (b -> t -> Either String t) -> [b] -> Either String t
22:28:57 <Axman6> marvinalone: how's that?
22:29:11 <marvinalone> Axman6: it'll take me a second to read that :-)
22:29:34 <Axman6> yeah, copy and paste it, and put it on multiple lines. move the lambda out into an aux function if needed
22:29:54 <marvinalone> Axman6: so there is nothing monadic about this, really. the Either monad doesn't help me out here
22:30:06 <Axman6> :t (Right 1 >>= f x)
22:30:08 <lambdabot> forall a b. (SimpleReflect.FromExpr (Either a b), Monad (Either a)) => Either a b
22:30:08 <shachaf> Axman6: You can probably simplify that.
22:30:15 <shachaf> Right.
22:30:16 <Axman6> yeah, i'm about to
22:30:37 <Axman6> :t \f xs -> foldl (\acc x -> acc >>= f x) (Right 1) xs
22:30:38 <lambdabot> forall b b1 a. (Monad (Either a), Num b1) => (b -> b1 -> Either a b1) -> [b] -> Either a b1
22:30:43 <Axman6> hmm
22:30:54 <shachaf> Real programmers foldl' (so I hear).
22:30:54 <Axman6> that constraint looks wrong
22:31:01 <Axman6> this is true
22:31:18 * hackagebot Aurochs 0.1 - Yet another parser generator for C/C++  http://hackage.haskell.org/package/Aurochs-0.1 (XinyuJiang)
22:31:29 <Axman6> :t \f xs -> foldl (\acc x -> acc >>= (f x :: Int -> Either String Int)) (Right 1) xs
22:31:30 <lambdabot>     Overlapping instances for Monad (Either String)
22:31:30 <lambdabot>       arising from a use of `>>=' at <interactive>:1:26-66
22:31:30 <lambdabot>     Matching instances:
22:31:34 <Axman6> :\
22:31:35 <incluye> :t many
22:31:35 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
22:31:43 <incluye> > many $ Just 3
22:31:47 <lambdabot>   mueval-core: Time limit exceeded
22:31:49 <incluye> hm
22:31:51 * Sgeo|web needs to stop skimming
22:31:54 <incluye> I must be misunderstanding something
22:31:59 <Axman6> :t \f xs -> foldl (\acc x -> acc >>= f x) (Right 1) xs :: Either String Int
22:32:00 <lambdabot>     Overlapping instances for Monad (Either String)
22:32:01 <lambdabot>       arising from a use of `>>=' at <interactive>:1:26-36
22:32:01 <lambdabot>     Matching instances:
22:32:04 <incluye> doesn't help that the explanation is "zero or more."
22:32:05 <Sgeo|web> I thought a piece of difficult to read text was just clarifying the easy function I was just reading about
22:32:17 <Axman6> Y U SUCK LAMBDABOT
22:32:17 <Sgeo|web> It was actually describing the function I thought went undescribed
22:32:44 <Axman6> :t \f xs -> (foldl (\acc x -> acc >>= f x) (Right 1) xs :: Either String Int)
22:32:45 <lambdabot>     Overlapping instances for Monad (Either String)
22:32:45 <lambdabot>       arising from a use of `>>=' at <interactive>:1:27-37
22:32:45 <lambdabot>     Matching instances:
22:32:54 <Axman6> Y U OVERLAP!
22:33:29 <Axman6> :t \f xs -> (foldl (\acc x -> (acc :: Either String Int) >>= f x) (Right 1) xs)
22:33:30 <lambdabot>     Overlapping instances for Monad (Either String)
22:33:30 <lambdabot>       arising from a use of `>>=' at <interactive>:1:27-60
22:33:30 <lambdabot>     Matching instances:
22:33:36 <Axman6> :t \f xs -> (foldl (\acc x -> (acc :: Either a Int) >>= f x) (Right 1) xs)
22:33:37 <lambdabot>     Inferred type is less polymorphic than expected
22:33:37 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
22:33:38 <lambdabot>         acc :: Either a Int (bound at <interactive>:1:18)
22:33:43 * Axman6 gives up
22:34:13 <kmc> @remember Axman6 <Axman6> Y U SUCK LAMBDABOT <Axman6> Y U OVERLAP!
22:34:13 <lambdabot> I will remember.
22:34:34 <Axman6> heh
22:35:25 <marvinalone> well, thanks for the effort. i'll see what i can do with that.
22:37:36 <Axman6> marvinalone: i have a feeling it should work with your usecase, but i think something's up with lambdabot
22:38:27 <marvinalone> Axman6: it'll take me a little while to translate it back into my real problem
22:39:31 <Axman6> hmmmmmmmmm, i didn't just reincent foldM did I?
22:39:34 <Axman6> :t foldm
22:39:35 <lambdabot> Not in scope: `foldm'
22:39:36 <Axman6> :t foldM
22:39:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:39:45 <Axman6> i think i did >_<
22:39:48 <Axman6> @src foldM
22:39:48 <lambdabot> foldM _ a []     = return a
22:39:48 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:40:01 <Axman6> or something very close anyway
22:40:42 <Axman6> :t \f xs -> foldl (\acc x -> acc >>= f x) (undefined) xs
22:40:43 <lambdabot> forall b (m :: * -> *) b1. (Monad m) => (b -> b1 -> m b1) -> [b] -> m b1
22:40:59 <Axman6> :t \f ini xs -> foldl (\acc x -> acc >>= f x) ini xs
22:41:00 <lambdabot> forall b (m :: * -> *) b1. (Monad m) => (b -> b1 -> m b1) -> m b1 -> [b] -> m b1
22:42:00 <Axman6> :t \f ini xs -> foldl (\acc x -> acc >>= f x) (return ini) xs
22:42:01 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> a -> m a) -> a -> [b] -> m a
22:45:15 <marvinalone> looks like foldM does exactly what i want
22:46:03 <Axman6> yeah, it's pretty handy, and should also have the early termination mine didn't
22:48:09 <marvinalone> so ... the first argument of foldM is a function that takes the state as its first argument, but that's really inconvenient if i want to use that same function in a >>= chain. is that an oversight, or am i missing something? i'm just asking to solidify my understanding of this. my problem is solved, for now.
22:49:35 <Axman6> i think it's designed to be given the list from a previous monadic computation, if you were to use it that way
22:54:11 <Sgeo|web> :t returnA
22:54:12 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
22:54:56 <Sgeo|web> Is that any different from arr id?
22:55:03 <Axman6> :t arr id
22:55:03 <Sgeo|web> :t arr id
22:55:04 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
22:55:04 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
22:55:10 <Sgeo|web> @src returnA
22:55:11 <lambdabot> returnA = arr id
22:55:12 <Axman6> @src returnA
22:55:12 <lambdabot> returnA = arr id
22:55:17 <Axman6> >_________________<
23:02:32 <GutenTag> Is there a good site for a lot of simple haskell examples I can attempt and check my solutions?  Kind of like javabat for java, perhaps?
23:04:20 <kmc> http://www.haskell.org/haskellwiki/99_Haskell_exercises
23:04:59 <GutenTag> Perfect, kmc, thanks.
23:26:51 <GutenTag> Do these mean the exact same thing: myLast (_:xs) = myLast xs // myLast (x:y) = myLast(y) ?
23:27:26 <shachaf> Those two definitions will have the same effect, yes.
23:27:38 <GutenTag> Does _ have any special meaning?
23:27:41 <shachaf> Yes.
23:27:52 <shachaf> It means to ignore a pattern explicitly.
23:27:58 <GutenTag> Can you give me a term to google?  I don't think _ ... ahh, thanks.
23:28:01 <shachaf> Function application in Haskell is "function argument", by the way, not "function(argument)".
23:28:14 <shachaf> GutenTag: I expect that most introductions will cover it. :-)
23:28:18 <GutenTag> I see.
23:28:27 <Sgeo|web> Hmm, I guess I could make stuff to hook into Yampa's reactimate
23:28:35 <Sgeo|web> Not as easy as reactive-banana
23:28:44 <Sgeo|web> Are there significant advantages to Yampa?
23:28:52 <GutenTag> shachaf: Well, I'm doing (some) of the 99 examples.  Thanks for the tip on "function argument" :)
23:33:50 <kmc> it's often called "wildcard pattern"
23:34:04 <kmc> it's a pattern which matches anything and binds nothing
23:34:19 <shachaf> Any variable name matches anything. :-)
23:34:29 <ddarius> The Report calls it a wildcard pattern.
23:35:06 <kmc> GutenTag, you can accomplish the same effect by binding a variable and then not using it, as in your second example
23:35:36 <kmc> GutenTag, but GHC will warn about unused variables (if you're using the -Wall command line flag, which you always should)
23:35:44 <kmc> and it's clearer to explicitly say you're discarding that value
23:35:54 <shachaf> kmc: I don't think that's necessarily true.
23:36:06 <shachaf> Sometimes the name of a variable makes the definition more readable.
23:36:18 <kmc> yes, it's true
23:36:27 <shachaf> GHC has a warning for "not compiling with -Wall"; sadly, it's not enabled by default.
23:37:03 <ddarius> I believe if the variable starts with _, GHC will not warn about it.
23:37:23 <shachaf> ddarius: Oh, true.
23:37:33 * shachaf withdraws complaint for the most part.
23:42:30 <kmc> how do I include a C++ file in a Cabal project
23:42:39 <kmc> listing it under c-sources seems to work
23:42:42 <kmc> but I worry that it's working by accident
23:45:04 <DaIRC49157> what does the mighttpd article mean about the new ghc event scheduler being single threaded?  we can't write multi-core web servers with forkio?
23:45:43 <GutenTag> So, I have: myButLast (x : y : z)  = myButLast (y:z).  If I just do = myButLast y:z  ... would that try to call MyButLast y  (and then cons that on to z)?  So, the parens in this case are helping with order of operation?
23:46:03 <shachaf> GutenTag: Yep.
23:46:07 <GutenTag> danke. :)
23:46:59 <xteensx> watch the best porn
23:46:59 <xteensx> http://xteensx.info
23:46:59 <xteensx>  ALL FEATURES FOR FREE
23:47:03 <shachaf> DaIRC49157: Saying which article you're referring to might help. :-)
23:47:28 <DaIRC49157> http://themonadreader.files.wordpress.com/2011/10/issue19.pdf
23:47:35 <DaIRC49157>     Mighttpd – a High Performance Web Server in Haskell by Kazu Yamamoto
23:47:52 <DaIRC49157> a very good article :)
23:47:57 <shachaf> Ah.
23:48:30 <shachaf> The "event scheduler" or the IO manager?
23:48:44 <DaIRC49157> don't remember exactly lemme check
23:49:19 <DaIRC49157> Since the new IO manager is single-threaded, Haskell network programs cannot
23:49:19 <DaIRC49157> realize the potential of a multi-core processor even if the +RTS -Nx command line
23:49:21 <DaIRC49157> p9
23:49:23 <DaIRC49157> p. 9
23:49:45 <shachaf> So apparently the new IO manager is single-threaded, yes.
23:49:52 <DaIRC49157> basically he wrote an apache-style preforking server to get around that
23:50:02 <DaIRC49157> but it sounds like a painful limitation
23:50:45 <shachaf> Seems that way.
23:51:01 <shachaf> That doesn't mean your entire program has to be single-threaded, of course.
23:51:03 <kosmikus> I think this may sound worse than it is, in practice.
23:51:18 * hackagebot zoom-cache 0.5.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.5.0.0 (ConradParker)
23:52:56 <DaIRC49157> because the computation intensive stuff can go in pure functions that can be more parallel?
23:53:16 <alpounet_> DaIRC49157, from the paper: "In theory, an application should be able to improve both throughput and latency by distributing its event management load across multiple cores. We already support running many instances of the low-level I/O event manager at once, with each instance managing a disjoint set of files or network connections."
23:53:58 <Sgeo|web> http://netsuperbrain.com/blog/posts/introducing-reactive-events/ is broken
23:54:01 <Sgeo|web> &gt;
23:54:42 <DaIRC49157> alpounet_, yeah, they do that like apache, more or less, iirc
23:54:48 <kmc> afaik, the event manager itself is single-threaded, but it's managing events for many threads
23:54:49 <alpounet_> yes
23:54:55 <DaIRC49157> hmm
23:55:09 <DaIRC49157> ok i should re-read the paper
23:55:12 <kmc> so it matters when the event management load is a significant fraction, i.e. many small events
23:55:35 <shachaf> Right.
23:55:51 <alpounet_> so it'll perform well when your server will have many network connections hanging around
23:56:00 <Sgeo|web> Is Reactive still buggy?
23:56:05 <kmc> so you can definitely write multi-core web servers, but they might not win at microbenchmarks ;)
23:56:39 <shachaf> They might also not win at real benchmarks. It probably depends on the situation.
23:56:46 <kmc> mighttpd explicitly wants to beat nginx at microbenchmarks, so it's a problem for them
23:57:03 <DaIRC49157> i'm thinking about writing an uber-concurrent sshd, so there will be lots of single keystroke events coming in
23:57:37 <Kus> hello. i am learning haskell but can't figure out how  to make my own function which combines 2 strings like this:  (String a, String b) and (String c, String d) -> (String a, String d) http://pastebin.com/fJRYHCaJ
23:57:41 <ddarius> There's only one outstanding call to epoll or whatever at a time in the IO manager.
23:58:34 <DaIRC49157> kus what's the problem?
23:58:34 <shachaf> Kus: That seems fine except that combineList isn't returning an IO action. What do you expect this program to do?
23:58:50 <DaIRC49157> you want to print the result?
23:58:54 <ddarius> If you fork multiple GHC compiled applications, you get multiple simultaneous calls to epoll.
23:59:36 <Eduard_Munteanu> main = print ...
23:59:41 <GutenTag> Hmm.  I'm getting an error for this: "element-at (x:_) 1 = x" // - Syntax error in declaration (unexpected `(')
23:59:41 <Kus> shachaf: it gives a error     Couldn't match expected type `Entry'     \n           against inferred type `(String, String) -> Entry'
