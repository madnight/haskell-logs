00:08:37 <huangyi> @pl \a b -> b*3-a
00:08:37 <lambdabot> flip ((-) . (3 *))
00:27:23 <bwright> Apparently I am the owner of http://lambda.fm now O_O. Should probably do something with it.
00:27:55 <adrake_> haskell-themed talk shows go
00:30:08 <silver> impromptu/overtone live shows!
00:33:38 <bwright> You can't really have a domain like that and not have it being used for talking about FP...
00:34:21 <frerich> As a start, youc ould use it to collect video captures of various FP-related conferences. So it'd basically be a link collection into youtube.
00:34:53 <bwright> frerich: That is not such a bad idea.
00:40:43 <causative> philosophically, what is a type?
00:41:59 <bwright> causative: Classic problem to look at is what Russel did to untyped calculus.
00:42:06 <causative> when a program is compiled so that instead of an Int or a Char you simply have a string of bits, do those bit values still have types?
00:42:15 <bwright> And how that formed the extension of typed lambda calc.
00:45:14 <bwright> causative: Also looking into type inference trees may be useful to help understand haskell better. Deducing the types of an expression is a pretty cool thing.
00:45:49 <Axman6> causative: there are no types at runtime (except those specified by the machine language)
00:46:23 <causative> Axman6, however, a programmer trying to reverse engineer the binary program would deduce types
00:46:47 <bwright> Well I would say that at a machine level your dealing with the encoding of types.
00:47:17 <bwright> It is entirely possible for example to represent Natural numbers with n-fold functions (church encoding)
00:47:49 <bwright> It just happens that the machines we are talking about use a binary encoding to store data. It is a seperate issue to the type.
00:48:57 <causative> is a type purely dependent on what the value is, or may it also depend on how the value was formed?
00:49:54 <thoughtpolice> causative: that's a shakey assumption on some level - good luck doing that with haskell for example (reversing.) if you think vtables are annoying, you're about to enter a world full of indirection and pain. it's easy enough to identify GHC-compiled code, but deciphering results to reconstruct types or a program is going to be vastly more difficult.
00:50:20 <thoughtpolice> C is a different case, and it too has types, only the type system is considerably weaker. there it is more possible to deduce such things, based on register sizes and signed/unsignedness, etc
00:50:49 <mah_b> hi, how can I type a list whose elemnts are all elements of a certain typeclass?
00:51:07 <elliott> mah_b: with existentials. consider whether you really want a typeclass.
00:51:20 <thoughtpolice> causative: dependent types allow a type to depend on a value mentioned in the program, if that's what you're getting at. then you can have functions that say 'this function may only accept natural numbers greater than 5 as a parameter', and the compiler enforces it
00:51:27 <bwright> causative: Ok lets take an example.
00:51:36 <bwright> causative: Does this make sense as an expression: s t
00:52:04 <causative> I thought I recalled reading sometime about a "virtual type" or some similar term but I'm having trouble finding it again
00:52:09 <bwright> to make sense of it s must be a function and t must be a right type for parameter.
00:52:39 <bwright> s :: a => b, t :: a, (s t) :: b
00:52:57 <causative> is a type, theoretically, a set?
00:53:12 <causative> with having a type equivalent to membership in some set?
00:53:49 <elliott> causative: you might want to read into type theory
00:53:59 <elliott> causative: types can be used as the foundation of mathematics just like sets are in set theory
00:54:45 <causative> I have read a book about martin lof's type theory but feel I'm missing the big picture
00:55:09 <elliott> well it's like reading about set theory and asking "is a set, theoretically, a type" :P
00:55:12 <elliott> types are just types
00:55:22 <causative> a set is something I can intuitively understand
00:55:24 <causative> a bag of things
00:55:39 <bwright> causative: τ ::= b | ν | τ ⇒ τ
00:55:46 <elliott> you can imagine an uncountably infinite bag of things, causative?
00:56:18 <causative> well elliott the real numbers do not stretch my imagination too much
00:56:29 <causative> or the set of functions
00:56:39 <causative> on real numbers
00:56:42 <elliott> anyway, you can think of types as bags at the simple, finite level, sure...
00:56:54 <elliott> 2 is {ff,tt}
00:57:05 <causative> there are gigantic sets that I can't intuitively grasp, I'm sure
00:57:56 <causative> I mean yes types have similarities with sets, and having a type is similar to set membership, but is it an exact analogy?
00:58:12 <causative> is there an interpretation of type theory in which types are sets, or do types have some properties sets cannot have?
00:58:56 <bwright> EWD - Radical Novelties comes to mind. Making analogies are generally a poor way of understanding something new.
00:59:09 <Axman6> there's a reason that Agda uses Set for types...
00:59:28 <causative> I can't understand any subject that is purely notation
00:59:38 <elliott> have fun with mathematics then
00:59:44 <causative> I need to have some way to imagine the things I am reading about
00:59:56 <causative> even in the crudest sense
01:00:26 <causative> I find that I usually understand things in one domain by corresponding them (at least roughly) to things in another domain that I already understand
01:01:04 <thoughtpolice> Axman6: they forgot to use unicode for 'Set' and it's too late to go back now...
01:01:26 <bwright> If your really intreseted. Theory of types was introduced by Russel as I mention to deal with contridictions he found in set theory.
01:02:11 <earthy> causative: you might want to read mathematics then
01:02:16 <bwright> It is a pretty interesting read if your interested in it.
01:02:25 <causative> I have a BS in mathematics
01:02:25 <earthy> err... thank you paste buffer
01:02:32 <earthy> causative: http://stuff.mit.edu/afs/sipb/project/ghc/programatica/tools.old/semantics/Overloading/Related/p158-wand.pdf
01:02:49 <mah_b> is epsilon defined somewhere? like numeric_limits in c++
01:03:03 <Axman6> epsilon?
01:03:14 <Axman6> epsilon is just a greek letter
01:03:33 <raichoo> so is lambda :3
01:03:40 <elliott> > generalCategory 'ε'
01:03:42 <lambdabot>   LowercaseLetter
01:04:04 <mah_b> the smallest representable between floating numbers, 1.0 - (next number after 1.0)
01:04:22 <earthy> causative: yes, in a certain sense, types *can* be thought of as sets, but only in a certain sense. :)
01:04:40 <causative> where does the analogy break down?
01:07:05 <earthy> in that the elements are not interchangeable
01:07:56 <causative> what do you mean?
01:08:00 <earthy> that is: a :: A can be thought of as a \in A, but in set theory you might also have a \in B as well, whereas in type theory a :: B is nonsense
01:08:24 <earthy> if you already know a :: A
01:08:39 <elliott> earthy: ...unless A = B
01:08:45 <earthy> elliott: obviously
01:09:05 <causative> every value may inhabit only a single type?
01:09:05 <Saizan> also :: is not even a predicate within the theory
01:09:17 <bwright> earthy: +1 for that paper you linked it is pretty neat.
01:09:25 <causative> what about dependent types
01:09:33 <elliott> causative: yes. true even with a dependent system.
01:09:44 <elliott> Saizan++
01:09:44 <causative> can't 2 both be a member of the type of even numbers, and the type of integers?
01:10:03 <tutmirleiden> this is the neatest online interactive tutorial i have ever seen
01:10:23 <Saizan> causative: nope
01:10:24 <elliott> causative: no, they are different 2s
01:10:34 <elliott> even number 2 probably looks like SS ZZ
01:10:45 <elliott> integer 2 probably looks like Pos (S (S Z))
01:10:49 <elliott> (natural 2 like S (S Z))
01:11:20 <Sgeo> tutmirleiden, this chat is not, strictly speaking, a part of the tutorial
01:11:34 <Sgeo> However, it does link to there, which may make it look like it is
01:11:55 <Saizan> causative: normally you'd have 2 :: Integer and a predicate Even :: Integer -> Set and a proof p :: Even 2
01:11:56 <Sgeo> *learnhaskell does link to here. I assume you used "chat" to get here?
01:12:10 <tutmirleiden> yes, i did
01:12:36 <tutmirleiden> and, of course, i did not assume this is part of the turorial
01:12:50 <elliott> Sgeo: learnhaskel?
01:12:52 <elliott> l
01:13:03 <Sgeo> erm, oops, tryhaskell
01:13:08 * Sgeo had a brain failure
01:13:34 <causative> well what about uncountable sets
01:13:49 <causative> what about irrational number sqrt(2), what would that look like?
01:13:55 * earthy boggles at his own mind... it's truly been some 15 years since I last reasoned about sets and types and the difference...
01:14:04 <earthy> still know the stuff. :)
01:14:19 <elliott> causative: you need a definition of the constructive reals
01:14:32 <Saizan> you should look at computable reals :)
01:14:33 <earthy> causative: that would be encoded as a constructive function of e.g. the decimal expansion.
01:14:34 <Sgeo> But the thing is, tryhaskell does not really give you that much of an introduction. Once you finish it, I might recommend learn you a haskell
01:14:38 <elliott> causative: it could look like a cauchy sequence (N -> Q)
01:14:45 <elliott> causative: (including a proof that it's cauchy)
01:15:35 <GordonFreeman> hello
01:15:49 <tutmirleiden> Sgeo, I wanted to get a feeling of it. Been coding in Scheme and R before
01:15:49 <causative> but when sqrt(2) is given the type of "irrational numbers less than 12" it would have to be a different value still
01:15:55 <Axman6> SURPRISE HEADCRAB!
01:16:51 <elliott> tutmirleiden: http://learnyouahaskell.com/ is a good tutorial to continue with after tryhaskell :)
01:17:08 <Saizan> causative: sure, but why would you do that?
01:17:10 <Axman6> causative: usually looks like a Double =)
01:17:10 <tutmirleiden> thanks mr elliot
01:17:47 <elliott> Axman6: not in real languages :P
01:17:57 <elliott> causative: there is no "sqrt(2)" really
01:18:02 <elliott> causative: you have to define what that means
01:18:07 <elliott> by defining a type, 2, and sqrt
01:18:08 <causative> Saizan, maybe you have a function that is only defined on numbers < 12
01:18:14 <elliott> the fact that you can convert between these types is irrelevant
01:18:54 <Saizan> causative: then you make that function have type "forall (x :: Real). x < 12 -> ..."
01:20:14 <causative> and then you just pass it a Real? what if you pass it 13?
01:20:35 <elliott> you pass it a real and a proof that it's less than 12.
01:20:42 <Saizan> then you won't be able to provide the second argument which will have type 13 < 12
01:21:02 <Saizan> (assuming a sane implementation of (<) :: Real -> Real -> Set)
01:23:13 * Axman6 has a feeling that causative is missing the point of strong types in haskell :\
01:24:28 <Saizan> we haven't been talking about haskell for a while :)
01:24:51 <Axman6> well, that's good then!
01:27:03 <causative> so with dependent types you don't really need to say 2 is Real anyway
01:27:20 <causative> you could just pass a proof of that separately, right?
01:27:31 <elliott> no
01:27:33 <elliott> because what is 2
01:27:43 <elliott> you have to construct 2
01:28:52 <causative> a function that takes a rational Epsilon and outputs a rational number N such that |2 - N| < Epsilon
01:29:40 <causative> Epsilon > 0
01:29:48 <elliott> aren't you just trying to define the reals there
01:30:11 <Saizan> well, 2 has to be something
01:30:14 <c_wraith> depends on the construction you're using for this exercise.  a construction with cauchy sequences would be different from a construction with dedekind cuts would be different from an epsilon-delta construction...
01:31:08 <Saizan> one usually starts with peano naturals to get a feel of how this stuff works
01:31:38 <c_wraith> in that case, it's totally natural to just skip over reals and go all the way to surreals afterwards. :)
01:32:28 <causative> ok so I guess the function would be a Cauchy sequence since I can't define 2 there
01:32:37 <c_wraith> (not that you can construct any interesting surreal numbers in finite space, but you can still use the mechanism)
01:33:52 <steakknife> Is there a standard cabal package dependencies file for projects?  Projects that may not be cabal packages themselves.
01:34:01 <causative> but you could just take a function of that type as a parameter, instead of a Real
01:34:13 <elliott> causative: that _is_ a real
01:34:17 <c_wraith> steakknife: not sully sure what you're asking
01:34:18 <elliott> causative: a real is a function plus a proof it's cauchy
01:34:21 <steakknife> (think Gemfile, pom.xml or package.json)
01:34:45 <c_wraith> steakknife: even things that aren't intended to ever go on hackage tend to be built with cabal
01:34:55 <steakknife> Yeap.
01:34:58 * shachaf return
01:35:06 <shachaf> Is #haskell defining the reals *again*?
01:35:08 <c_wraith> steakknife: you can use "cabal init" to create a cabal file
01:35:25 <c_wraith> shachaf: actually, this time, it's more about *constructing* them.  totally different!
01:35:34 <elliott> shachaf: :D
01:35:35 <steakknife> Setup.lhs, yeah or am I missing something?
01:36:14 <c_wraith> Setup.l?hs is kind of obsolete
01:36:34 <c_wraith> Still used, but usually auto-generated by cabal-install
01:36:50 <shachaf> Saizan: Why does 2 have to be something?
01:36:52 <c_wraith> from the foo.cabal file in the project
01:36:53 <steakknife> So what's the preferred file then?
01:36:59 <GordonFreeman> hello
01:37:02 <shachaf> I take it as my fundamental object. 2 is my only axiom.
01:37:04 <steakknife> Ah Thanks.
01:37:07 <c_wraith> where "foo" i the bame of the directory
01:37:10 <c_wraith> err, *name
01:37:38 <c_wraith> and *is.  I should probably go to sleep, since I clearly can't type anymore
01:37:51 <shachaf> I, Bame.
01:37:58 <causative> elliott, so for a function of type "forall (x :: Real). x < 12 -> ..." how many parameters does it have?
01:38:06 <causative> is x actually 2 parameters
01:38:10 <c_wraith> shachaf: you are?
01:38:12 <causative> and then the proof for x < 12 is a third parameter?
01:38:19 <elliott> causative: uh.
01:38:22 <elliott> causative: do you know Haskell?
01:38:26 <elliott> data Foo = Foo Int Int
01:38:29 <elliott> bar :: Foo -> Int
01:38:32 <elliott> how many parameters does bar take?
01:38:42 <elliott> single values can be composed of multiple other values.
01:39:26 <causative> elliott, so you are saying a Real is simply a wrapper around the cauchy sequence and the proof it's cauchy?
01:39:43 <elliott> yes. that's what i've been saying. repeatedly :P
01:40:08 <causative> so you don't have to pass a Real, you could pass them "unwrapped"
01:40:20 <shachaf> c_wraith: You work at JanRain?
01:40:24 <c_wraith> yes
01:40:38 <c_wraith> though we officially are "Janrain" now. :)
01:40:42 <elliott> causative: sure. but that would be pointless.
01:40:50 <elliott> causative: since the two forms are isomorphic :P
01:41:07 <shachaf> Aha.
01:41:33 <causative> I'm seeking to clarify the nature of a type, how closely it is bound to a value
01:41:47 <causative> what parts are separable
01:41:50 <shachaf> For some reason I'm subscribed to PDXFunc so I've vaguely heard of them.
01:43:17 <c_wraith> oh, yeah, we hosted the last two pdxfunc meetings
01:43:55 <c_wraith> it's an excuse for our engineers to get the company to buy pizza and beer!
01:44:04 <causative> so instead of passing V : T to any function, you could pass V alone and p : T V (a proof that V has type T), right?
01:44:42 <elliott> no
01:44:45 <elliott> like Saizan said
01:44:49 <elliott> (::) is not a predicate
01:45:02 <elliott> to quantify over anything you need its type anyway
01:45:17 <elliott> (T :: Set) -> (V :: T) -> ...
01:45:23 <c_wraith> causative: I missed the beginning of this..  Are you talking about any particular language?  Different languages have different relationships between types and values.
01:45:39 <elliott> i think dependent type theory is the basic grounding :P
01:45:46 <shachaf> I should go to sleep.
01:45:56 <causative> c_wraith, yeah dependent type theory
01:46:19 <elliott> this _is_ #dependenttypetheory after all
01:46:49 <shachaf> elliott: All the cool kids are doing homotopy/directed type theory.
01:47:39 <causative> okay so V is not alone
01:48:07 <causative> V : Set I suppose? and then p : T V ? I'm not sure what you mean by (::) is not a predicate
01:48:36 <elliott> causative: what is T?
01:48:50 <elliott> T : Set, V : Set, p : T V, oops type error!
01:48:52 <elliott> T : Set, T isn't a function
01:48:56 <elliott> T isn't something -> somethingelse
01:49:00 <elliott> you can't apply it
01:49:09 <elliott> ...furthermore, V has type Set, not type T or anything else
01:49:15 <elliott> because you just said so :)
01:49:45 <earthy> causative: to be clearer about what Saizan stating that :: is not a predicate
01:50:16 <earthy> a statement a :: A is a constructed judgement in type theory
01:50:40 <earthy> there *are* no values a that can be considered independent of their types
01:51:53 <causative> okay so I guess what I want to say is, imagine T2 is a predicate where T2 V means the same as V : T previously meant
01:52:13 <elliott> there is no such predicate
01:52:16 <elliott> and you can't construct one
01:52:20 <elliott> and it doesn't make any sense
01:52:25 <elliott> because V already has a type by the time you can talk about it
01:52:41 <causative> so you could separate it into V : Set and then p : T2 V?
01:52:50 <elliott> no.
01:52:54 <earthy> yes and no
01:52:55 <elliott> if V : Set, then V is not of type T!
01:52:57 <elliott> it is of type Set
01:53:00 <elliott> there are no subtypes
01:53:07 <elliott> a value is of one and only one type
01:53:11 <causative> like you separated x : Real and p : x < 12
01:53:18 <earthy> you *could* make judgements V :: Set and p :: T2 V
01:53:29 <earthy> but they would not mean what you think they mean. :)
01:53:45 <earthy> (seem to think they mean)
01:54:28 <causative> what would they mean?
01:54:41 <shachaf> There are no subtypes. There is only Zuul.
01:54:43 <earthy> but to make a judgement p :: T2 V you'd probably need a judgement T2 :: Set -> T3
01:54:50 <shachaf> Zuul = Set\infty; Zuul : Zuul
01:55:12 <causative> xml user interface language?
01:55:23 <elliott> earthy: i don't think there are any nontrivial T2s...
01:55:24 <shachaf> Exactly.
01:55:33 <earthy> elliott: that aside. :)
01:55:43 <earthy> syntactically it's doable :)
01:55:53 <elliott> earthy: i feel like you may be confusing causative more than you are helping :P
01:56:16 <earthy> well, he needs to step away from considering elements and sets
01:56:32 <earthy> and towards considering type judgements and judgement derivations
01:56:36 <leod_> wait.. what?
01:57:41 <earthy> type judgements can be interpreted as set membership, but the two are very much not the same...
01:57:48 <causative> so I guess I'm gathering that the problem with saying V : Set is that you then can't do anything with V?
01:58:00 <earthy> well, you *can*
01:58:11 <earthy> but not in a way that's useful
01:58:24 <causative> it can't be recursed on
01:58:32 * earthy nods
01:59:00 <causative> so instead of Set
01:59:02 <elliott> causative: you can quantify over it
01:59:05 <causative> V : Bitstring
01:59:22 <elliott> oh dear
02:00:19 <causative> does that work? can you then have T2 V where T2 is maybe "V represents an even binary number"?
02:00:30 <causative> and supply V : Bitstring and p : T2 V to functions?
02:00:53 <elliott> yes, if you want to totally throw away all the advantages of the language and pass around really ugly proofs :P
02:00:59 <elliott> but those proofs will probably involve data types
02:01:05 <elliott> because you need induction schemes and stuff
02:01:09 <elliott> and to extract anything useful out of it
02:01:12 <elliott> you'll need... data types
02:08:37 <causative> what other problems are there with the Bitstring + T2 proof combo, compared to just V : T?
02:08:50 <elliott> didn't i list enough? :)
02:09:10 <causative> yes but I'm wondering if maybe there is also some loss of information
02:09:26 <causative> in going from V : T to Bitstring, for some types
02:10:08 <elliott> well... probably. i'm not sure anyone has ever thought about it because it's awful :P
02:10:15 <elliott> i can't answer anyway
02:14:20 <Saizan> shachaf: it still has to be something, even if of a postulated type
02:15:35 <shachaf> Types? There are no types. There is only 2.
02:16:09 <thoughtpolice> what happened to zuul?
02:17:40 <elliott> zuul = 2
02:17:43 <causative> well thanks elliott, Saizan  and all others, I think I've gotten a better handle on this now
02:17:45 <shachaf> What's zuul? There is only 2.
02:18:00 <elliott> What's 2? There is only 3.
02:18:05 <thoughtpolice> elliott: very deep
02:18:17 <causative> what is the sound of 3 hands clapping?
02:18:18 <shachaf> What are birds? We just don't know.
02:18:37 <earthy> we don't need to know to reason about them though
02:19:12 <causative> also thanks earthy
02:19:13 <earthy> it gets tricky though when they hook up with wadlers or meertens's
02:19:51 <shachaf> earthy: Well, we can't really reason about water.
02:25:30 <shachaf> earthy: (Did you see the relevant educational film series?)
02:46:41 * hackagebot happy 1.18.7 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.7 (SimonMarlow)
02:57:28 <spring> How to find out where a library is?  IOW I have an import qualified Single.  Where is Single?
03:00:10 <frerich> Does anybody know how efficient the parsers created by Happy are in comparison to parsec or atto-parsec?
03:00:47 <frerich> I thought writing parsers with parsec was actually quite neat, sometimes almost like writing BNF directly. So I wonder what advantages 'happy' has.
03:01:29 <elliott> none :)
03:01:36 <elliott> but happy predates parsec i believe
03:01:38 <Saizan> spring: ghc-pkg find-module Single
03:03:12 <spring> Thanks Saizan
03:03:52 <earthy> shachaf: what relevant educational film series?
03:04:06 <shachaf> earthy: "Look Around You"
03:04:23 <spring> I get /var/lib/ghc/package.conf.d
03:04:28 <shachaf> @google "look around you" water
03:04:29 <lambdabot> http://www.youtube.com/watch?v=s4vwh4-K_ZQ
03:04:29 <lambdabot> Title: Look Around You - "Water" - YouTube
03:05:25 <spring> ~/.ghc/i386-linux-7.0.4/package.conf.d
03:05:44 <earthy> shachaf: hm. never heard about those
03:06:03 <earthy> don't watch much TV in any case, and haven't had the beeb available for a couple of years
03:06:54 <shachaf> earthy: I've only watched it online.
03:07:07 <earthy> on the stack. :)
03:07:23 <shachaf> A stack? Not a FIFO or something?
03:08:04 <elliott> earthy: Look Around You happened in 2002, anyway.
03:08:07 <earthy> nah. it does allow relative-from-top addressing though
03:08:23 <earthy> elliott: yah... I had *no* TV for a while back then. :)
03:09:48 <shachaf> I don't watch much television. In fact, I don't even own one.
03:10:01 <elliott> shachaf: Area Man, is that you?
03:10:09 <shachaf> elliott: You've found me out.
03:10:20 * shachaf tumbles around Northumberland some more.
03:13:23 <mysticc> @hoogle delay
03:13:23 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
03:13:24 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
03:13:24 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
03:15:18 <mysticc> @hoogle wait
03:15:19 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
03:15:19 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
03:15:19 <lambdabot> Graphics.UI.GLUT.Window Wait :: Cursor
03:35:03 <mysticc> @hoogle finally
03:35:03 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
03:35:03 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
03:35:04 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
03:43:00 <ashaw> Hey all, is anyone here?
03:43:20 <int-e> @bot
03:43:21 <lambdabot> :)
03:43:41 <rostayob> ashaw: yes
03:46:24 <ashaw> Hey i have  anew project that I want to start, and I am thinking of using it as an excuse to lern haskell
03:46:52 <ashaw> however I want to know if it will be even possible to reach my goals in with haskell
03:47:11 <rostayob> @ask Can Haskell fulfill ashaw needs?
03:47:11 <lambdabot> Consider it noted.
03:47:16 <rostayob> ah no
03:47:29 <rostayob> @can Haskell fulfill ashaw needs?
03:47:29 <lambdabot> Maybe you meant: faq map run wn
03:47:32 <rostayob> whatever
03:47:33 <sipa> @faq Can Haskell fulfill rostayob needs?
03:47:34 <lambdabot> The answer is: Yes! Haskell can do that.
03:47:37 <rostayob> yes, that.
03:47:47 <ashaw> Basically, I want to know if it is possible to use Cairo, or an equivelent library
03:47:56 <rostayob> ashaw: it is, and the bindings are good
03:47:56 <elliott> http://hackage.haskell.org/package/cairo
03:48:12 <ashaw> and can one write GUIs for OSX, Windows and LINUX
03:48:17 <elliott> yep
03:48:27 <elliott> cairo is part of gtk2hs, which is a complete gtk wrapper for haskell
03:48:29 <ashaw> in their native gode
03:48:42 <elliott> well, linux doesn't really have a native UI, but yeah :P
03:48:44 <ashaw> So Coca for OSX
03:48:56 <ashaw> and Whatever windows uses
03:49:02 <elliott> well, gtk isn't cocoa
03:49:03 <ashaw> ...
03:49:06 <elliott> there's a wxwidgets binding
03:49:14 <elliott> which uses the native libraries on each platform
03:49:24 <rostayob> ashaw: the gtk bindings are the most pleasant to work with last time i checked
03:49:37 <ashaw> I want something that is elegent for each platform so the user will not know it is haskell underneath
03:49:42 <elliott> wx's bindings are nicer IMO, but I dunno if you could use the cairo bindings with them. probably
03:50:05 <ashaw> Also is there an opengl binding ?
03:50:11 <elliott> ashaw: if you want a truly native experience on each OS, no matter what the language, you need to write your UI for each platform's conventions. failing that, you can settle for good enough, i.e. a wrapper library like wxWidgets which has good haskell bindings
03:50:19 <elliott> http://hackage.haskell.org/package/OpenGL
03:50:33 <elliott> you may find http://hackage.haskell.org/packages/archive/pkg-list.html helpful :P
03:50:35 <rostayob> ashaw: if you have to do 2d graphics i'd also suggest gloss
03:50:44 <rostayob> http://hackage.haskell.org/package/gloss which is really nice
03:51:30 <ashaw> cool, with ipenGL underneath nuce.
03:52:34 <ashaw> elliott, I knwo that however I do not know how welll haskell interfaces with Objective-C
03:53:05 <rostayob> haskell interfaces nicely only with C
03:53:15 <ashaw> Right
03:53:27 <ashaw> can C call haskell code?
03:53:33 <rostayob> yes
03:53:34 <elliott> yes
03:53:39 <elliott> ashaw: not so good. there is a objective-c/cocoa binding HOC
03:53:40 <ashaw> cool
03:53:44 <elliott> but it's quite dormant
03:53:50 <ashaw> I saw that
03:54:01 <elliott> most people do OS X stuff by writing their UI in objc and have it call haskell, i think
03:54:10 <elliott> but if you're writing something crossplatform, wxWidgets isn't bad at all :P
03:54:49 <ashaw> I want cross platform, but with a truely native gui for each platform
03:54:51 <ashaw> ...
03:54:55 <ashaw> much work
03:55:04 <elliott> that'll be much more work in any language
03:55:09 <elliott> i hope you're really patient :P
03:55:10 <ashaw> I know
03:55:26 <ashaw> price of business I suppose
03:55:45 <tuna-fish> ashaw: That is not really actually possible
03:55:54 <ashaw> why?
03:55:59 <ashaw> tuna-fish
03:56:09 <tuna-fish> the only way to do crossplatform with native gui for each platform is to make a separate app for each platform
03:56:18 <rostayob> the nicest experience with cross platform guis for me was Qt
03:56:35 <tuna-fish> Qt is really nice, but it isn't native
03:56:44 <rostayob> no, but it looks great
03:56:58 <tuna-fish> there are actual semantic differences between the ui toolkits of different platforms
03:57:07 <ashaw> I am willing to write some of the code say 1/4 differently for each platform
03:57:09 <elliott> rostayob: shhh, we don't have good qt bindings
03:57:26 <rostayob> elliott: eheh I know, but I understand that
03:57:28 <ashaw> I would not use Qt anyway
03:57:35 <tuna-fish> if you want to ship true native uis for multiple platforms, the only sane way is to separate all the common code into a library
03:57:48 <elliott> tuna-fish: if ashaw's application is mostly heavy computation then the UI will not be much extra work for each platform
03:57:58 <elliott> if ashaw is just writing a "typical GUI application" though then that'll be a complete rewrite sure
03:58:09 <rostayob> elliott: btw, how do they bind to wx? are they wrapping all the C++ in C?
03:58:21 <elliott> rostayob: wx has an official C binding(!)
03:58:29 <rostayob> ah, right, so they go through that
03:58:36 <tuna-fish> elliott: I agree
03:58:37 <rostayob> man mantaining the C binding must be boring.
03:58:46 <elliott> rostayob: i hope it's autogenerated
03:58:47 <tuna-fish> the point is, the gui will be an entire rewrite anyway
03:59:15 <ashaw> I hope to write a PCB editing program
03:59:22 <ashaw> so there is a bit of UI
03:59:28 <tuna-fish> it will be cleaner and simpler to separate out the backend, and start new projects on the platform-sanctioned tools for the frontend
03:59:38 <ashaw> However there is also quite a bit of Computation
03:59:52 <rostayob> elliott: i hope as well
04:00:08 <ashaw> I intend to have a backend thata is fross platform
04:00:23 <ashaw> and then have a facade that is for each platform
04:00:30 <ashaw> as the GUI
04:00:53 <rostayob> yeah that's your best shot if you want a "native" application on each platform
04:00:56 <ashaw> also most of the GUI will be a OpenGL context
04:01:35 <ashaw> How is haskell with multiple threading
04:02:13 <rostayob> ashaw: good
04:02:20 <elliott> excellent
04:02:27 <rostayob> haskell actually has it's own runtime, with lightweight threads
04:02:42 <rostayob> so it's really cheap to spawn threads (if you know erlang it's a similar concept)
04:02:58 <ashaw> Cool
04:02:59 <elliott> haskell's threads actually match the performance of event-based programming when used for IO, and you can have many thousands of threads without a problem
04:03:09 <elliott> plus there's "sparks", which can parallelise pure computation even quicker
04:03:27 <ashaw> Nice.
04:03:49 <elliott> also STM :P
04:03:52 <ashaw> I want to write my code so that it will scale to at least 16 cores/32 threads
04:04:12 <ashaw> Can you run haskell on CUDA ???:)???
04:04:31 <elliott> there are libraries that let you write GPU code in a functional way
04:05:04 <elliott> but no, not "directly"
04:05:13 <mauke> I've written stupid code with 500000 threads
04:05:16 <mauke> works fine
04:06:38 <ashaw> That is sad
04:06:46 <ashaw> but cool
04:06:51 <Axman6> what's sad?
04:06:56 <rostayob> no CUDA
04:07:01 <ashaw> no CUDA for haskel
04:07:03 <Axman6> there's cuda bindings
04:07:12 <elliott> ashaw: you can use CUDA and OpenCL and all that from haskell
04:07:13 <ashaw> Not what i ment
04:07:15 <elliott> at a low level
04:07:16 <Axman6> there's also Accelerate
04:07:23 <elliott> and you can use higher level bindings too
04:07:32 <Axman6> ashaw: CUDA is a specific language, of course you can't write it in haskell
04:07:33 <elliott> that let you write regular-looking data structure operations and run them on the GPU basically
04:07:38 <elliott> ashaw: but you can't just "compile haskell to cuda"
04:07:42 <Axman6> it's like asking can you write C in haskell
04:07:45 <elliott> gpus aren't a magical go-faster bullet, they're a totally different architecture :)
04:08:01 <ashaw> I can understand that
04:08:20 <ashaw> however i will have to write some EM simulation stuff
04:08:23 <Axman6> there's also GPipe for computing things on the GPU
04:09:02 <ashaw> and Array computing with SIMD would be a really good fit there.
04:09:46 <Axman6> that's being worked on
04:10:20 <Axman6> but it will likely take some time, because anything that gets done will need to support the major platforms GHC targets (mainly those with SSE, AVX, AltiVec and NEON)
04:10:54 <ashaw> Yeah, fine for now anyway.
04:11:16 <ashaw> What communication primitives does Haskell have?
04:11:19 <Axman6> check out the work being done with Repa
04:11:22 <ashaw> does it support channels
04:11:25 <Axman6> yes
04:11:26 <elliott> ashaw: yes
04:11:33 <Axman6> :t newChan
04:11:34 <elliott> ashaw: it also has a full, efficient software transactional memory implementation
04:11:35 <lambdabot> Not in scope: `newChan'
04:11:37 <elliott> which itself has channels
04:11:40 <ashaw> cool
04:11:41 <elliott> as well as transactional variables, arrays, etc.
04:11:51 <Axman6> it's basically the only STM implementation that works
04:12:04 <elliott> lol
04:12:06 <elliott> good advertising
04:12:08 <mux> GCC 4.7 added transactional memory facilities, btw
04:12:13 <Axman6> gcc recently added some STM stuff, i'm very sceptical about whether it could actually work
04:12:15 <mux> http://gcc.gnu.org/wiki/TransactionalMemory
04:12:27 <Axman6> MS failed to add it to C#, so why on earth would it work in C?
04:12:48 <elliott> Axman6: i think the key is "The work on this branch has been done as part of the Velox project."
04:12:53 <elliott> i think they do hardware TM stuff
04:12:56 <elliott> or at least that's what the link implied to me
04:13:02 <elliott> although it's mostly fluff
04:13:15 <Axman6> HTM is pretty limited compared to GHC's STM
04:13:18 <elliott> "While the 3-year 36-month VELOX Project has officially ended, your first venture into Transactional Memory  is only beginning."
04:13:26 <qqMuppetpp> Axman6: Rich Hickey might want a word with you ;) -- STM works fairly well in Clojure as well
04:13:28 <elliott> Axman6: presumably that's why they do that hybrid thing
04:13:53 <Axman6> qqMuppetpp: can you print in the middle of a transaction?
04:14:14 <qqMuppetpp> you really shouldn't, no
04:14:19 <mauke> so yes
04:14:26 <elliott> haha
04:14:36 <ashaw> does haskell STM work lock free?
04:14:38 <Axman6> qqMuppetpp: then no, it does not
04:14:49 <elliott> ashaw: yes
04:14:54 <elliott> well, mostly, i dunno if it ever resorts to locks
04:15:15 <qqMuppetpp> Axman6: can you do IO during a tx in haskell?
04:15:18 <Axman6> you can't print in the middle of an STM action, and you never, ever should be allowed to
04:15:24 <rostayob> qqMuppetpp: no
04:15:30 <Axman6> qqMuppetpp: no, that's the whole point of a transaction
04:15:47 <Axman6> if there's some action you cannot rollback, it's not an atomic transaction
04:16:51 <qqMuppetpp> so basically you're spanking the typing dead horse, not complaining about Clojure's stm
04:17:10 <rostayob> qqMuppetpp: ? it's not about types here
04:17:11 <mauke> a good type system is just one way of enforcing that restriction
04:17:21 <mux> it _is_ about types
04:17:28 <elliott> qqMuppetpp: can you cause a segfault in clojure?
04:17:30 <rostayob> haskell does that with types
04:17:36 <mux> and how they allow you to model STM in a satisfactory way
04:17:40 <elliott> qqMuppetpp: if not, is that because of its type system?
04:17:46 <Axman6> i'm saying that if it's possible to produce effects that can be seen outside the transaction before the transaction has been completed, it is not an atomic transaction
04:17:54 <elliott> you're implying that all sorts of safety guarantees are type-related...
04:18:07 <rostayob> mux: Axman6 was just saying that if you can do io in a transaction, then it won't work
04:18:08 <Axman6> qqMuppetpp: types are the whole reason STM works in Haskell, and doesn't work in just about every other language
04:18:16 <mux> rostayob: yes, and he's right
04:18:17 <rostayob> the fact that haskell solves that by tainting IO is another story
04:18:22 <mux> lol
04:18:32 <mux> haskell doesn't solve that by tainting IO
04:18:54 <Axman6> it's not tainted, it's separated
04:19:00 <bwright> the lambda gnomes in ghc solve it.
04:19:02 <mauke> separate but equal
04:19:10 <Axman6> indeed
04:19:43 <rostayob> ok, a lot of people call that a "taint model"
04:20:08 <mauke> what is IO (IO a)? doubletaint?
04:20:22 <rostayob> we mark each io action and you can get the value only in another io action
04:20:49 <rostayob> mauke: i think that taint model describes well IO in haskell, I think I read it for the first time in LYAH
04:20:50 * elliott really hates that view of IO.
04:20:59 <elliott> It promotes the container model of monads, etc.
04:21:13 <rostayob> taint model as a term :P
04:21:18 <mauke> rostayob: I'm reading about top-down operator parsing
04:21:26 <mauke> in javascript
04:21:30 <elliott> I started to get along much better with Haskell after realising that (IO a) was a first-class model of a program; that's how you realis ethat IO is a benefit, not a prison...
04:21:32 <rostayob> yes, here http://learnyouahaskell.com/input-and-output
04:21:44 <mauke> here: http://javascript.crockford.com/tdop/tdop.html
04:21:55 <Axman6> qqMuppetpp: do clojure's transaction compose easily? can you build bigger transactions from smaller parts?
04:22:09 <rostayob> mauke: does that have something to do with haskell IO?
04:22:16 <mauke> rostayob: no, why?
04:22:31 <rostayob> ah. so you just wanted to let me know about top-down operator parsing :P?
04:22:34 <DRMacIver> elliott: How to stop worrying and learn to lov ethe IO monad?
04:22:46 <qqMuppetpp> don't see why you couldn't
04:22:58 <mauke> rostayob: why did you tell me "<rostayob> mauke: i think that taint model describes well IO in haskell, I think I read it for the first time in LYAH"?
04:23:09 <elliott> DRMacIver: Precisely!
04:23:13 <elliott> We should rename IO to Newspeak.
04:23:21 <elliott> doublePlusGood :: a -> Newspeak a
04:23:41 <rostayob> mauke: because you were saying that saying that "tainted IO" is not a good term for IO in haskell
04:23:53 <mauke> was I?
04:23:56 <DRMacIver> rostayob: I think the real problem with the taint model is that an IO a is not "An IO computation that has been run and resulted in a value a", it's "An IO computation that you *could* run and get a value a"
04:24:03 <rostayob> mauke: oh, maybe it was someone else :)
04:24:30 <Axman6> IO is by no means a tainted thing in haskell, imo it's one of the greatest languages for doing IO work
04:24:50 <mauke> Axman6: I think you're completely missing the point
04:24:59 <Axman6> am i?
04:25:05 <DRMacIver> It's an important part of the model that IO a can be run more than once
04:25:13 <rostayob> Axman6: with tainted I don't mean "bad". i mean that IO actions are marked permanently
04:25:40 <mauke> Axman6: yeah, like complaining about "negative correlations" because you think they're actually pretty ok and why is everyone so negative
04:25:56 <rostayob> DRMacIver: yeah but in the end the most characteristic tink about haskellIO is the fact that you can't "escape" IO
04:26:06 <rostayob> and this is what most people complain about as well
04:26:12 <Axman6> mauke: why would you do that, it just makes people unhappy
04:26:18 <mauke> rostayob: s/"escape"/execute/
04:26:25 <rostayob> ok, execute
04:26:27 <fizruk> hi! i'm looking for a library that can build/work with pixel set (i may be wrong with terminology: i mean N-dimension figures defined by set of points). At first I need to build such set given some inequalities and bounds of N-dimension space. thanks in advance!
04:26:35 <Axman6> they should all be anti-happy correlations. at least then there's happy in the title
04:27:15 <rostayob> and it's not just stupid people complaining anyway ( http://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/ )
04:27:27 <rostayob> but that model is a huge advantage when doing STM for example
04:27:45 <elliott> rostayob: ooh, time for another flamewar!
04:27:52 <rostayob> i couldn't resist :(
04:27:59 * elliott doesn't actually know if there've been _IRC_ flamewars over Harper's posts.
04:33:12 <rostayob> elliott: i don't know either, but he certainly doesn't like haskell
04:33:28 <elliott> that much is obvious :P
04:36:41 <Axman6> who?
04:37:15 <fizruk> Harper, i think
04:37:19 <elliott> Axman6: robert harper
04:38:49 <fizruk> is here someone, who has worked with numerical algorithms in haskell?
04:39:45 <DRMacIver> rostayob, elliott: In fairness I tend to agree with his point about what a complete pain in the ass converting between pure and monadic style is. :)
04:39:58 <DRMacIver> There's a reason I reappear in the Haskell community cyclically about once a year.
04:40:37 <elliott> DRMacIver: It's a bit of a wart, but applicative style and idiom brackets lessen the pain, I think.
04:40:54 <elliott> And I don't actually find myself doing that conversion very often. It's something you do to combinators.
04:40:59 <elliott> Most code isn't combinators (although maybe it should be).
04:41:10 <rostayob> DRMacIver: yeah I partly agree as well, but you get used to the separation
04:41:12 <DRMacIver> elliott: Idiom brackets?
04:41:22 <rostayob> in the end, I think I prefer haskell model
04:41:51 <elliott> DRMacIver: (| f a b c |) = f <$> a <*> b <*> c, as per the notation in McBride's original paper introducing Applicatives.
04:41:52 <DRMacIver> rostayob: it's not the separation that's the issue, it's when you get the separation wrong and need to change it.
04:42:01 <elliott> DRMacIver: Implemented by the she preprocessor, hopefully coming to GHC sometime this century.
04:42:14 <rostayob> DRMacIver: I guess. I don't find myself having to change things all the time now
04:42:30 * elliott thinks that "getting the separation wrong" lessens a lot with a deeper sense of Haskell architecture.
04:42:40 <elliott> That sounds like "you get used to it", I know.
04:43:29 <DRMacIver> elliott: I've never really got into using applicatives. I probably hsould. I remain pretty thoroughly skeptical of "You can fix this with MORE TYPES" solutions though. :)
04:43:41 <DRMacIver> elliott: It's not just "wrong", it's also "changing requirements"
04:43:55 <rostayob> DRMacIver: Applicative is really nice. it's not really an addition
04:44:00 <rostayob> if you already have Monad
04:44:08 <rostayob> every Monad is Applicative
04:44:08 <DRMacIver> Example: The thing I'm currently working on I *really* am going to need to start threading random state through it. This is going to be a nuisance.
04:44:52 <elliott> DRMacIver: Well, RNG makes a really nice monad :-)
04:45:23 <elliott> DRMacIver: But I think the situation where you start with a pure computation, and you end up needing to thread something through it -- is usually something you can _tell_ will require /some/ sort of monadic-ish wrapper, and you can plan ahead for that by stubbing it out with Identity.
04:46:05 <DRMacIver> Ah, the "It's not a problem if you anticipate all your requirements in advance" argument. ;)
04:46:12 <elliott> Heh :)
04:46:22 <elliott> At least with Haskell it's easy to slot new requirements into a stack.
04:46:27 <elliott> You just have to anticipate that you'll need a stack.
04:46:34 <DRMacIver> I mean, I do sympathise with that. I probably should have realised this was going to require threading state through this
04:46:43 <elliott> DRMacIver: But yeah, applicatives themselves aren't all /that/ useful -- the applicative combinators are almost universally used with instances of Monad -- but they make writing monadic code just as easy as writing "normal" applicative code, which helps especially with what essentially amount to thin wrappers.
04:46:47 <DRMacIver> But there's always going to be something you forget.
04:47:06 <rostayob> DRMacIver: with monad transformers the stack can grow pretty painlessly
04:47:13 * elliott is willing to pay the price of rewriting things with monadic wrapping sometimes, since it's (a) largely mechanical and (b) a lot better than what some languages throw at you :-)
04:47:23 <rostayob> since you've got type classes for all the monads (MonadState, MonadError, etc)
04:47:27 <rostayob> you don't need to lift the computation
04:48:54 <DRMacIver> Anyway, I understand some of this is a matter of taste.
04:49:27 <rostayob> well composability is a problem with monads
04:49:30 <DRMacIver> But the fact of the matter is that I've used Haskell on and off for about 6 years now and the off always happens because I find much of the process of using it way too irritating :)
04:49:32 <rostayob> apart from taste
04:49:51 <DRMacIver> rostayob: Well the *problems* aren't a matter of taste, it's just how severe you regard them as that is
04:50:19 <rostayob> DRMacIver: ok, let's say that monads are ugly to compose right now
04:51:17 <rostayob> but still it's getting better imho with type classes and fundeps (see mtl)
04:51:44 <mysticc> @hoogle Parser
04:51:44 <lambdabot> Language.Haskell.Parser module Language.Haskell.Parser
04:51:45 <lambdabot> Text.Parsec.ByteString type Parser = Parsec ByteString ()
04:51:45 <lambdabot> Text.Parsec.ByteString.Lazy type Parser = Parsec ByteString ()
04:51:49 <rostayob> you can just write functions that operate on state, or throw errors, in a completely generic way
04:52:16 <DRMacIver> Sure, but "in a completely generic way" is nice and all, but if it's a pain in the ass to do it in a completely specific instance not that comforting. :)
04:52:35 <rostayob> and you'd have to decide what monad stack to use just at the end when you get the result
04:52:43 <rostayob> DRMacIver: that's not true
04:53:40 <DRMacIver> Which bit are you claiming isn't true?
04:53:41 <rostayob> initiating the computation looks exactly the same (runThisT runThatT)
04:53:56 <rostayob> compared to what you have with non-generic code
04:54:16 <rostayob> I don't understand what you mean with "it's a pain in the ass to do it in a completely specific instance"
04:54:31 <mike-burns> There's an `if' in front of that phrase.
04:54:55 <rostayob> yeah but i don't see how the fact that you have type classes describing monads changes the specific case
04:55:37 <mike-burns> But if it did, that would be discomforting.
04:56:10 <rostayob> yeah but DRMacIver thinks it does :)
04:56:14 <fizruk> mike-burns: you can't be untrue :)
04:56:43 <DRMacIver> rostayob: Actually that's not what I said at all. I said the specific case is irritating, you said "But you can do it completely generically!", I said I didn't see how that improved the specific case.
04:57:06 <DRMacIver> To which you replied with "I don't see how it affects the specific case", so we appear to be in vehement agremenet on that subject
04:57:18 <DRMacIver> But I don't think this conversation is going anywhere terribly useful so I suggest we call it to a close now
04:57:49 <rostayob> no no, I think that it makes a big difference in the specific case as well, making it better
04:58:00 <rostayob> you only need to give a type to the monad in one place
04:58:03 <rostayob> and then execute it
04:58:30 <rostayob> so you almost don't have to think about the stack at all
04:58:37 <fizruk> DRMacIver: in my understanding, specific case is generic one with certain instances of typeclasses
04:58:38 <rostayob> when writing code that uses the stack
04:58:56 <rostayob> the "thinking about the stack" part is only in one place
04:59:34 <DRMacIver> Let me rephrase. I don't feel my continued presence in this conversation will be productive, so I'm stopping now. If you want to keep talking about it go right ahead. :)
04:59:48 <rostayob> DRMacIver: ok, I have to go anyway
05:01:14 <fizruk> maybe some people who work with numerical algorithms appeared?
05:02:15 <fizruk> i feel stupid when noone answers me, is that alright?
05:02:31 <rostayob> fizruk: i think that's because no one can help you right now
05:02:33 <qqMuppetpp> fizruk: you're violating etiquette. just ask your question
05:02:47 <qqMuppetpp> don't ask if it's ok to ask
05:02:53 <rostayob> and yeah just asking the question would be more effective...
05:03:14 <fizruk> qqMuppetpp: sorry =(
05:05:53 <qqMuppetpp> i'm sure noone's offended. but you won't get an answer that way
05:19:04 <solirc> Is there an Arbitrary instance for Data.Map somewhere on hackage?
05:19:42 <svet> hi
05:21:38 <rostayob> solirc: fmap fromList arbitrary
05:23:09 <solirc> rostayob: I prefer Map.fromList <$> arbitrary ;)
05:23:39 <rostayob> solirc: well you don't need to import stuff with the fmap version ehe
05:26:08 <hpaste> tmhz pasted “Spiral ” at http://hpaste.org/54395
05:26:13 <tmhz> Hi, I am trying to learn Haskell by working through some of the problems in programmingpraxis.com. One of which is to unfold a spiral data structure. The algorithm seems to be working but I am getting confused by the syntax of new data types.
05:26:55 <tmhz> Could someone please help me with the syntax or point me in the right direction?
05:27:21 <elliott> tmhz: what's the problem exactly?
05:27:22 <opqdonut> tmhz: spiral' = Spiral . spiral
05:27:25 <elliott>     show (Spiral a) = map show a
05:27:37 <elliott> I know this is wrong, because (map show a) won't produce a String
05:27:38 <opqdonut> tmhz: first build the contained [[a]] and then wrap it in the Spiral constructor
05:27:42 <elliott> It'll produce a [String] :)
05:28:00 <opqdonut> just derive the Show instance for now
05:28:02 <elliott> I suggest you remove the show instance and just use "deriving (Show)" after the data line.
05:28:04 <elliott> Yeah.
05:29:01 <tmhz> ok the reason I was trying to implement show was so that the data is on separate lines
05:29:22 <opqdonut> tmhz: do you understand what I mean by "spiral' = Spiral . spiral" ? I mean you should keep the function "spiral :: Integer -> [[Integer]]" and implement "spiral' :: Integer -> Spiral Integer" with it
05:29:23 <elliott> You shouldn't do that with a Show instance; define a separate Spiral -> String function.
05:29:33 <opqdonut> exactly, "drawSpiral" or something
05:29:56 <elliott> drawSpiral (Spiral xs) = lines (map show xs) -- :)
05:29:59 <elliott> erm
05:30:01 <elliott> unlines, sorry
05:30:06 <tmhz> ahh ok
05:30:44 <tmhz> why is it bad to implement Show like that?
05:30:53 <opqdonut> Show should be compatible with Read
05:30:54 <elliott> because show should produce valid Haskell code
05:30:59 <opqdonut> and that
05:31:07 <opqdonut> Show is for serialization, basically
05:31:07 <elliott> that when evaluated produces the object being shown
05:31:18 <elliott> opqdonut: I wouldn't say that... at least, I wouldn't use it for that
05:31:21 <elliott> it's for interactive use :P
05:31:33 <opqdonut> I almost said half-assed serialization
05:31:34 <opqdonut> :)
05:31:35 <elliott> hehe
05:31:41 <tmhz> ok cool
05:33:04 <tmhz> opqdonut: "spiral' = Spiral . spiral"  This is a bit confusing to me. Is that a function composition of a function and a [[Integer]]?
05:33:40 <sipa> what is the type of spiral?
05:34:37 <tmhz> sipa: I would like a generic 2D list
05:36:30 <opqdonut> sipa: It means the same as "spiral n' = Spiral (spiral n)"
05:36:39 <sipa> opqdonut: i know what it means :)
05:36:48 <opqdonut> i.e. take n map it to the [[Integer]] spiral, and then turn this into a Spiral by applying the Spiral constructor
05:37:15 <opqdonut> it might help if you name the constructor differently, e.g. "data Spiral a = SpiralConstructor [[a]]"
05:37:15 <opqdonut> just for starters :)
05:37:24 <opqdonut> then "spiral' = SpiralConstructor . spiral"
05:37:57 <tmhz> opqdonut: Yep I was just thinking that I have confused myself with names
05:38:27 <opqdonut> spiral :: Integer -> [[Integer]], SpiralConstructor :: [[a]] -> Spiral a, spiral' = SpiralConstructor . spiral :: Integer -> Spiral Integer
05:39:18 <tmhz> opqdonut: Thank you, that makes much more sense
05:40:03 <opqdonut> np
05:42:30 <opqdonut> tmhz: also, a reminder: since you only have one constructor with one parameter, you could use newtype instead of data
05:43:45 <tmhz> opqdonut: That is for a type of optimisation isn't it?
05:44:09 <opqdonut> well, yeah. but it also gives you some things like "generalized newtype deriving"
05:44:28 <opqdonut> no harm in using data
05:45:36 <tmhz> Is newtype restricted to both single Constructor and a single argument?
05:45:50 <sipa> yes
05:45:51 <opqdonut> yes
05:45:57 <elliott> maybe
05:45:59 <elliott> (yes)
05:46:00 <sipa> exactly one constructor, with exactly one argument
05:46:13 <opqdonut> newtype means "I'm taking this other type, and wrapping it into a type with a new name"
05:46:36 <opqdonut> which is useful e.g. for implementing different instances of type classes
05:46:46 <opqdonut> or just making your type signatures neater
05:46:58 <tmhz> doesn't "type" do that also
05:47:13 <opqdonut> type doesn't give any protection
05:47:20 <opqdonut> type is just a syntactic renaming
05:47:32 <opqdonut> newtype actually gives a new type that is not equal to the old one (but is isomorphic)
05:47:33 <elliott> and doesn't let you define new instances
05:47:42 <opqdonut> exactly because it is a renaming
05:47:54 <sipa> see type as C's #define, and newtype as C's typedef
05:48:11 <tmhz> ahh ok
05:48:20 <opqdonut> that.... almost works
05:48:37 <opqdonut> typedef is also pretty much a syntactic substitution but that doesn't matter in C
05:48:55 <mauke> what no
05:48:56 <tmhz> is the "data" keyword generally avoided?
05:48:57 <mauke> typedef is type
05:49:00 <mauke> C doesn't have newtype
05:49:15 <sipa> right, maybe newtype == struct with one element
05:49:33 <alexdavey> How do you use the mathematical constant "e" in Haskell, I can't seem to find anything on it...
05:49:37 <opqdonut> sipa: well, data is kinda like struct...
05:49:45 <opqdonut> > exp 1
05:49:46 <lambdabot>   2.718281828459045
05:50:01 <opqdonut> tmhz: no, not really
05:50:06 <sipa> opqdonut: data is a tagged struct, newtype has no tagging
05:50:14 <mux> > sqrt (exp 2)
05:50:15 <lambdabot>   2.718281828459045
05:50:20 <opqdonut> sipa, that's an implementation detail
05:50:28 <sipa> yes and no
05:50:47 <sipa> in haskell there are semantics involved - you can tag an undefined value, and pattern match against the tag without failure
05:50:49 <opqdonut> tmhz: AFAICT, people tend to use newtype when it is possible
05:51:03 <opqdonut> sipa: yeah, the strictness semantics do differ
05:51:19 <alexdavey> opqdounut and mux: Doh, thanks.
05:51:26 <tmhz> cool thanks
05:51:45 <mux> > exp 3 ** (1/3)
05:51:46 <lambdabot>   2.718281828459045
05:52:12 <sipa> > exp 17 ** (1/17)
05:52:13 <lambdabot>   2.718281828459045
05:52:24 <sipa> :t ( exp 17 ** (1/17))
05:52:25 <lambdabot> forall t. (Floating t) => t
05:53:15 <mux> @check \x -> (x::Int) > 0 ==> exp x ** (1/x) == exp 1
05:53:16 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
05:53:16 <lambdabot>    arising from a use of...
05:53:42 <mux> @check \x -> (x::Int) > 0 ==> let x' = fromIntegral x in exp x' ** (1/x') == exp 1
05:53:43 <svet> ;)
05:53:43 <lambdabot>   No instance for (Test.QuickCheck.Testable
05:53:43 <lambdabot>                     (Test.QuickCh...
05:53:45 <tmhz> One more question is there a better solution to this line "[genericTake n xs] ++ spiral' (genericDrop n xs)" using both take and drop seems to be redundant.
05:53:54 <mux> god damn you QuickCheck, why do you hate me so much
05:54:04 <elliott> <tmhz> is the "data" keyword generally avoided?
05:54:08 <elliott> tmhz: no, it's used all the time :)
05:54:18 <elliott> also, splitAt?
05:54:19 <elliott> :t splitAt
05:54:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:55:11 <tmhz> elliot: Thats what I was after thanks
05:56:30 <tmhz> Is it possible to create a list in descending order? using [100..0]
05:56:39 <tmhz> > [100..0]
05:56:39 <lambdabot>   []
05:56:41 <mux> > [10,9..0]
05:56:42 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
05:56:51 * hackagebot HCodecs 0.2.2 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.2.2 (GeorgeGiorgidze)
05:57:00 <tmhz> ahh ok so the step must be explicit
05:57:07 <mux> yeah
05:57:10 <mux> :t enumFromThenTo
05:57:11 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
05:57:17 <tmhz> > [100,80..0]
05:57:17 <lambdabot>   [100,80,60,40,20,0]
05:57:20 <mux> > enumFromThenTo 10 9 0
05:57:20 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
06:07:12 <_Mikey> :t<+>
06:07:14 <_Mikey> :t <+>
06:07:15 <lambdabot> parse error on input `<+>'
06:07:22 <_Mikey> :t +++
06:07:22 <lambdabot> parse error on input `+++'
06:07:34 <_Mikey> :t (+++)
06:07:35 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
06:07:40 <_Mikey> :t (<+>)
06:07:41 <lambdabot>     Ambiguous occurrence `<+>'
06:07:41 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
06:07:41 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
06:08:06 <_Mikey> :t (Control.Arrow.<+>)
06:08:07 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
06:22:38 <_Mikey> :t (++)
06:22:39 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:22:49 <_Mikey> hmm
06:23:11 <mauke> :t (Prelude.++)
06:23:12 <lambdabot> forall a. [a] -> [a] -> [a]
06:29:05 <_Mikey> ahh
06:29:13 <_Mikey> :t(Prelude.++)
06:29:22 <_Mikey> :t (Prelude.++)
06:29:24 <lambdabot> forall a. [a] -> [a] -> [a]
06:37:21 <_Mikey> :t fst
06:37:22 <lambdabot> forall a b. (a, b) -> a
06:37:34 <_Mikey> :info fst
06:37:43 <elliott> @src fst
06:37:44 <lambdabot> fst (x,_) =  x
06:38:11 <_Mikey> ahh cheers!
06:38:13 <mauke> @djinn (a,b) -> a
06:38:14 <lambdabot> f (a, _) = a
06:38:28 <_Mikey> djinn?
06:38:43 <dmwit> cabal-install++
06:38:46 <elliott> it's magic
06:39:08 <_Mikey> hmm
06:39:30 <dmwit> It's not magic, it's a theorem-prover.
06:39:34 <_Mikey> ist there a difference between that and ordinary cabal?
06:39:45 <dmwit> There's a paper that explains how it works in great detail.
06:39:46 <mauke> _Mikey: there is no ordinary cabal
06:40:08 <mauke> there's Cabal (provides a library) and cabal-install (provides a program)
06:40:09 <_Mikey> oh no... I have some sort of cabal.. I installed it once
06:40:13 <_Mikey> no idea whats on here
06:40:17 <elliott> dmwit: A magic theorem prover.
06:40:21 <dmwit> _Mikey: There is a library package called Cabal and an executable named cabal which is provided by the cabal-install package.
06:40:37 * osfameron wonders what magical theorems are
06:40:48 <_Mikey> I have cabal-install then
06:40:49 <hpaste> あ pasted “あ” at http://hpaste.org/54396
06:40:56 <dmwit> _Mikey: You have both, I assure you.
06:40:57 <_Mikey> it helped me build stufd once.
06:41:02 <_Mikey> it helped me build stuff once.
06:41:05 <_Mikey> ahh ok then :)
06:42:18 <FUZxxl> あ : a!
06:42:56 <mauke> ああああああああ
06:43:15 <Botje> isn't that a sign on a mahjong tile or somthing?
06:43:28 <_Mikey> ahh ok then :)
06:43:34 <chra> の しt.
06:43:34 <_Mikey> oops
06:44:06 <mauke> that's not how you japonese
06:44:29 <moriramar> chra, no shit?
06:44:32 <mysticc> this is a code instance from realworldhaskell .. http://paste.pocoo.org/show/511402/ .. can any one explain the line get = lift get ?
06:44:53 <chra> moriramar: Uhm, yeah :P
06:45:31 <mauke> mysticc: what's unclear?
06:45:36 <Botje> mysticc: if you have MaybeT (State Int a), you can only grab the state by doing 'lift get'
06:46:30 <Botje> what that instance says, is that if the monad under MaybeT is a MonadState instance, you can make MaybeT m a MonadState instance as well by lifting the get into it
06:47:50 <mysticc> Botje: Thanks .. now understood
06:48:20 <Botje> mysticc: it saves you from adding an arbitrary number of lifts to your code every time
06:51:06 <hpaste> “_Mikey” pasted “User Defined Type As a Parameter” at http://hpaste.org/54397
06:51:45 <_Mikey> I'm wondering
06:51:49 <mauke> _Mikey: did you mean: data Position = Position Int Int
06:51:59 <mauke> in fact
06:52:17 <mauke> _Mikey: did you mean: data Position = Position{ get_xpos, get_ypos :: Int }
06:52:34 <_Mikey> hmmm
06:52:47 <_Mikey> and then I'd get accessor methods for free
06:53:03 <mysticc> Botje: You mean lift get every time ?
06:53:50 <Botje> mysticc: yes. or worse.
06:53:57 <mysticc> worse ??
06:54:03 <Botje> mysticc: depending on how far 'down' the State is.
06:54:10 <mysticc> oh ...
06:54:43 <elliott> Botje: lift get should always work...
06:54:46 <elliott> if the underlying monad is MonadState
06:54:59 <elliott> i mean unless you have multiple StateTs or whatever
06:55:48 <hpaste> “_Mikey” annotated “User Defined Type As a Parameter” with “User Defined Type As a Parameter (annotation)” at http://hpaste.org/54397#a54398
06:55:50 <mysticc> \help
07:03:38 <Kaidelong> are there any examples of numbers that are not also fields? Quaternions?
07:04:23 <_Mikey> soo many bugs XD
07:05:18 <roconnor> Kaidelong: integers
07:05:41 <Kaidelong> roconner: Oh that's right, you need inverses
07:07:17 <_Mikey> and I'm compiling again :D
07:15:07 <BlankVerse> does anyone have a mirror/copy of this -> http://horna.org.ua/books/All_About_Monads.pdf
07:15:29 <Kaidelong> do lists form a near ring?
07:15:37 <Kaidelong> well lists of monoids
07:15:45 <Kaidelong> not general lists
07:16:26 <Kaidelong> I'm thinking ++ as +, [] as 0, repeat mempty as 1, zipWith mappend as *
07:16:48 <Kaidelong> hmm
07:17:42 <mauke> heh
07:17:46 <mauke> me++
07:17:48 <byorgey> Kaidelong: zipWith mappend does not distribute over (++)
07:17:56 <mauke> BlankVerse: http://mauke.dyndns.org/stuff/haskell/All_About_Monads.pdf
07:18:04 <mauke> and someone should probably mirror it
07:18:11 <Kaidelong> @check let { (*) = zipWith mappend ; unit = repeat mempty ; (+) = (++) } in \a b c -> (a+b)*c == (a*c)+(b*c)
07:18:11 <lambdabot>   Add a type signature
07:18:38 <Kaidelong> @check let { (*) = zipWith mappend ; unit = repeat mempty ; (+) = (++) } in \a b c -> (a+b)*c == (a*c)+(b*c) :: (Monoid m) => [m] -> [m] -> [m] -> Bool
07:18:39 <lambdabot>   Couldn't match expected type `[m] -> [m] -> [m] -> GHC.Bool.Bool'
07:19:06 <Kaidelong> guess I'll have to think about it myself
07:20:08 <Kaidelong> @check let { (*) = zipWith mappend ; unit = repeat mempty ; (+) = (++) } in \a b c -> (a+b)*c == (a*c)+(b*c) :: [Sum] -> [Sum] -> [Sum] -> Bool
07:20:09 <lambdabot>   `Data.Monoid.Sum' is not applied to enough type arguments
07:20:09 <lambdabot>  Expected kind `*...
07:21:13 <byorgey> > let { (*) = zipWith mappend ; unit = repeat mempty ; (+) = (++); a = [Sum 1, Sum 2]; b = [Sum 3]; c = [Sum 4, Sum 5] } in ((a+b)*c, (a*c)+(b*c))
07:21:15 <lambdabot>   ([Sum {getSum = 5},Sum {getSum = 7}],[Sum {getSum = 5},Sum {getSum = 7},Sum...
07:22:22 <Kaidelong> anyway I guess that puts lists down as near-semirings
07:22:37 <Kaidelong> since + isn't commutative and * isn't associative
07:23:17 <byorgey> Kaidelong: no, you need distributivity.
07:23:30 <Kaidelong> oh that was what I was testing too
07:23:48 <Kaidelong> so it just ends up being two different monoids
07:23:56 <byorgey> right.
07:25:46 <dmwit> mauke: Could you mirror it on the Haskell wiki?
07:45:21 <_Mikey> question
07:45:36 <_Mikey> can you do a list comprehension inside a list comprehension
07:45:37 <_Mikey> ^^
07:45:38 <Botje> sure
07:45:43 <_Mikey> okies :)
07:45:50 <Botje> why do you want this, though?
07:46:13 <sipa> > [ [ 2*x | x <- [1..y] ] | y <- [1,2,3] ]
07:46:14 <lambdabot>   [[2],[2,4],[2,4,6]]
07:46:19 <mux> list comprehenception?
07:46:28 <ski> > [[(x,y) | y <- "abc"] | x <- [0,1,2]]
07:46:28 <mux> omg, that was terrible. i'm so sorry.
07:46:29 <lambdabot>   [[(0,'a'),(0,'b'),(0,'c')],[(1,'a'),(1,'b'),(1,'c')],[(2,'a'),(2,'b'),(2,'c...
07:46:36 <BlankVerse> mauke: do you also have the accompaning source files for trying out the examples mentioned in All_About_Monads?
07:46:41 <_Mikey> hmm
07:46:44 <_Mikey> I have a grid
07:46:53 <_Mikey> and it represented as a list of lists
07:48:47 <sipa> mux: haha
07:49:41 <mauke> BlankVerse: I don't know, do you have urls for them?
07:50:21 <BlankVerse> http://horna.org.ua/books/All_About_Monads.pdf , somewhere from its root i guess
07:50:55 <mauke> no, I only have the main pdf from that site
07:55:01 <_Mikey> Botje, Can you see any advantage to having a row type and storing grid squares in a row? and then having a list of rows
07:55:35 <_Mikey> because I'm starting to think it would just be easier to get rid of rows.
07:56:00 <Botje> type Row = [Square]
07:56:03 <Botje> fixed :P
07:56:35 <_Mikey> ahh Rows are defined as that ;)
07:57:00 <_Mikey> but I can't formulate the list comprehension
07:57:04 <_Mikey> let me hpaste
07:57:33 <opqdonut> is there something like Data.Map but with a given range of keys always present
07:57:50 <opqdonut> so kind of like the API of an Array but a tree-based efficient implementation
07:58:17 <mauke> like, a record?
07:58:38 <elliott> opqdonut: using a Map shouldn't hurt that much, should it?
07:59:04 <hpaste> “_Mikey” pasted “Double List Comprehension” at http://hpaste.org/54399
07:59:22 <ClaudiusMaximus> :t (Data.Map.!)
07:59:23 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
08:00:02 <ClaudiusMaximus> > M.empty M.! ()
08:00:03 <lambdabot>   *Exception: Map.find: element not in the map
08:00:33 <opqdonut> elliott: yeah that's what I use now...
08:01:13 <opqdonut> oh, there is a M.!
08:01:32 <_Mikey> Ahh
08:01:36 <_Mikey> I think I've cracked it :D
08:01:44 <_Mikey> <3 LYAH
08:03:04 <ClaudiusMaximus> > 1 + 16^2 + 16^4
08:03:05 <lambdabot>   65793
08:03:27 <ClaudiusMaximus> mm, maybe i should look at not using immediate mode to draw that many quads each frame...
08:07:27 <aleator> I've got a bit of code that looks a bit like this: x = unsafePerformIO (safeFFIcall). Now I'd like to impose a time limit for x. Are there any easy/prepackaged solutions?
08:08:28 <copumpkin> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/System-Timeout.html
08:08:52 <aleator> copumpkin: Excellent! Thank you!
08:11:31 <hiptobecubic> let bools = concat [map ((flip isPrefixOf) x) ["abc", "cba"] | x <- permutations "aaabbbccc"] in sum [1 | x <- bools, x == True]
08:11:43 <hiptobecubic> This seems hideous. is there a better approach?
08:15:28 <hiptobecubic> all strings made from 'aaabbbccc' that have "abc" or "cba" at the front
08:16:44 <Gothmog_> thats the number of unique permutations of "aabbcc" times two
08:18:13 <Gothmog_> so, i think 6! / 2^3
08:21:06 <ClaudiusMaximus> @check (\x -> x == (x == True))
08:21:07 <lambdabot>   "OK, passed 500 tests."
08:21:07 <elliott> <hiptobecubic> let bools = concat [map ((flip isPrefixOf) x) ["abc", "cba"] | x <- permutations "aaabbbccc"] in sum [1 | x <- bools, x == True]
08:21:12 <elliott> hiptobecubic: apart from what Gothmog_ said
08:21:27 <elliott> hiptobecubic: sum [1 | x <- bools, x == True] -> sum [1 | x <- bools, x]
08:21:40 <elliott> hiptobecubic: -> length (filter id x)
08:21:43 <elliott> erm
08:21:44 <elliott> hiptobecubic: -> length (filter id bools)
08:22:00 <elliott> ((flip isPrefixOf) x) -> (`isPrefixOf` x)
08:22:12 <bwright> Wouldn't you only need the permutations of "aabbcc" I mean it appears to be just needless calculation.
08:22:13 <snappy> jjjjj1
08:22:33 <bwright> Why is a prefix test even needed?
08:25:49 <knoc> > all isDigit []
08:25:50 <lambdabot>   True
08:26:09 <dolio> > all (const False) []
08:26:11 <lambdabot>   True
08:26:42 <knoc> hmm ;)
08:26:55 <elliott> perfectly correct
08:28:10 <knoc> so all is True, for an empty list :]
08:29:20 <elliott> knoc: every property holds of members of the empty set
08:29:36 <elliott> every member of the empty set is not equal to itself, for instance
08:30:46 <sipa> > let bla x = error "Meh!" in all bla []
08:30:47 <lambdabot>   True
08:31:17 <knoc> elliott: thats quite amusing ;)
08:32:29 <sipa> "for all x in A p(x) is true" is equal to "there is no x in A for which p(x) is false"
08:33:11 <elliott> sipa: that middle's gettting a little to close to exclusion for my liking
08:33:16 <elliott> s/to close/too close/
08:33:20 <elliott> s/gettting/getting/ :P
08:34:01 <_Mikey> hey guys
08:34:10 <_Mikey> if I derive show
08:34:17 <_Mikey> for a type
08:34:52 <_Mikey> and then I have a list of them and try to show the list it do I need to create a new show instance?
08:34:57 <elliott> no
08:35:02 <elliott> there's an instance
08:35:06 <elliott> instance (Show a) => Show [a]
08:35:07 <_Mikey> I thought not
08:35:08 <sipa> there is an instance Show a => Show [a] predefined
08:35:15 <_Mikey> but I'm getting errors
08:35:16 <ClaudiusMaximus> :t showList
08:35:17 <lambdabot> forall a. (Show a) => [a] -> String -> String
08:35:50 <_Mikey> <interactive>:1:0:
08:35:50 <_Mikey>     No instance for (Show ([Square] -> Square))
08:35:50 <_Mikey>       arising from a use of `print' at <interactive>:1:0-14
08:35:50 <_Mikey>     Possible fix:
08:35:50 <_Mikey>       add an instance declaration for (Show ([Square] -> Square))
08:35:51 <_Mikey>     In a stmt of a 'do' expression: print it
08:36:07 <ClaudiusMaximus> you're trying to show a function
08:36:08 <sipa> _Mikey: you're trying to show a function
08:36:14 <sipa> !hi5 ClaudiusMaximus
08:36:21 <knoc> ^^
08:36:25 <_Mikey> hmm
08:36:33 <sipa> _Mikey: can we see your code?
08:36:37 <_Mikey> sure
08:36:41 <sipa> (if it's long, use hpaste.org)
08:37:16 <hpaste> “_Mikey” pasted “Code” at http://hpaste.org/54401
08:37:37 <_Mikey> its right at the bottom
08:38:02 <_Mikey> I'm getting the head of the list generated from the list comp
08:38:09 <_Mikey> I guess its not evaluated right ^^
08:39:45 <Nibble> The Glorious Glasgow Haskell Compilation System, version 7.0.3
08:39:47 <Nibble> hahaha
08:39:54 <sipa> ?
08:40:02 <Nibble> ghc --version
08:40:06 <Nibble> "The Glorious"
08:40:11 <_Mikey> XD
08:40:13 <Nibble> I am pretty sure that is not part of the name
08:40:16 <rostayob> it is
08:40:27 <Nibble> rostayob: must have been mistaking then
08:40:35 <rostayob> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler
08:40:55 <Nibble> lol
08:40:57 <Nibble> wat
08:41:00 <Nibble> did you just change that
08:41:06 <_Mikey> Sipa: should I throw an eval in? I heard they're bad though.
08:41:19 <rostayob> Nibble: yeah, with two citations lol
08:41:25 <Nibble> rostayob: lol
08:41:36 <Nibble> this needs to be better known
08:41:36 <Tyr42> Hey, I wrote some code: http://hpaste.org/54400
08:41:40 <Tyr42> and I needed a helper
08:41:45 <Tyr42> anyM
08:41:55 <Nibble> Tyr42: ok.
08:42:33 <Tyr42> I think it'd be useful for more things
08:42:45 <Tyr42> I searched on hoogle
08:42:49 <Tyr42> but nothing came up
08:43:15 <Tyr42> I find it hard to believe that no-one's written it before
08:43:19 <hpc> :t fmap any . mapM
08:43:21 <Nibble> Tyr42: I am sorry to be an ass, but what is the question. I do not have the knowledge to answer it.
08:43:21 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
08:43:21 <lambdabot>       Expected type: (a1 -> a -> b) -> [a1] -> a -> Bool
08:43:21 <lambdabot>       Inferred type: (a1 -> a -> b) -> [a1] -> a -> [b]
08:43:27 <hpc> :t fmap any .: mapM
08:43:28 <lambdabot>     Couldn't match expected type `a -> Bool'
08:43:29 <lambdabot>            against inferred type `[b]'
08:43:29 <lambdabot>       Expected type: (a1 -> f b) -> [a1] -> f (a -> Bool)
08:43:30 <Nibble> oh, apparently someone knew what you were going for
08:43:39 <hpc> :t mapM
08:43:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:44:05 <Nibble> anyhoes, Ill get back to hacking my xmonad
08:44:29 <hpc> :t any .: mapM
08:44:31 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
08:44:31 <lambdabot>       Expected type: (a1 -> a -> b) -> [a1] -> a -> Bool
08:44:31 <lambdabot>       Inferred type: (a1 -> a -> b) -> [a1] -> a -> [b]
08:44:45 <Tyr42> sorry, I was just making sure or something before saying something wrong.  Could something like this be added to the monad lib, along with forM and mapM?  What's the process for adding stuff?
08:44:48 <hpc> :t any
08:44:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:44:50 <hpc> :t and
08:44:52 <lambdabot> [Bool] -> Bool
08:44:53 <hpc> oh
08:44:57 <hpc> :t fmap and .: mapM
08:44:59 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => (a -> f Bool) -> [a] -> f Bool
08:44:59 <_Mikey> sipa, eval doesn't work, either
08:45:08 <_Mikey> well I don't think its in the prelude.
08:45:15 <hpc> Tyr42: (.:) = fmap . fmap; anyM = fmap and .: mapM
08:45:42 <Tyr42> ohh, cool
08:46:16 <Tyr42> and allM ?
08:46:38 <hpc> :t fmap or .: mapM
08:46:40 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f) => (a -> f Bool) -> [a] -> f Bool
08:46:49 <Tyr42> ok
08:47:04 <hpc> works with any ([b] -> c) function
08:47:18 <hpc> :t fmap ?f .: mapM
08:47:20 <lambdabot> forall b (f :: * -> *) a b1. (?f::[b1] -> b, Functor f, Monad f) => (a -> f b1) -> [a] -> f b
08:48:02 <Tyr42> alright, I learned something today
08:48:03 <Tyr42> thanks
08:48:24 <ski> hpc : it will execute all the actions, though
08:48:37 <hpaste> “_Mikey” annotated “Code” with “Code (annotation)” at http://hpaste.org/54401#a54402
08:48:49 <hpc> ski: ah, yeah
08:49:13 <hpc> not sure which behavior is needed, or if it matters
08:50:19 <Tyr42> It's for transversing a graph, and that's force O(e^n) time
08:50:25 <Tyr42> so I don't really like that
08:50:28 <hpc> ah
08:50:56 <hpc> there's probably some trick you can do with mfix, but ick
08:51:01 <Tyr42> I still think anyM and allM are natural enough
08:51:03 <hpc> if what you have works, go with it
08:51:07 <Tyr42> when written recursivly
08:51:10 <Tyr42> yes
08:51:28 <Tyr42> I was just quite surprised that nothing like that existed already
08:53:00 <hpc> if you squint a bit, i think you will find that you have bumped up on the reason why short-circuiting is a tricky thing to deal with in languages with side effects
08:53:16 <hpc> (arbitrary short-circuiting, rather)
08:53:43 <Tyr42> we're doing something in class (Scheme) with continuation to do the same thing
08:53:53 <hpc> fun
08:54:06 <Tyr42> but I rather like how clean the haskell code is comparatively
09:36:41 <_Mikey> :t (seq)
09:36:41 <lambdabot> forall a t. a -> t -> t
09:37:18 <GordonFreeman> hellou
09:37:34 <_Mikey> hi
09:38:33 <shapr> hi mike-burns
09:38:40 <shapr> um, _Mikey
09:39:01 <_Mikey> hey
09:42:33 <mike-burns> Also, hi.
09:45:45 <_Mikey> :t kill
09:45:46 <lambdabot> Not in scope: `kill'
10:21:56 * hackagebot hbro 0.7.0.1 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.7.0.1 (koral)
10:24:43 <chadz> anyone have any idea how to force a screen redraw with vty-ui?
10:29:25 <c_wraith> @hackage vty-ui
10:29:25 <lambdabot> http://hackage.haskell.org/package/vty-ui
10:29:42 <c_wraith> I know the author, I can forward your question to him in realtime :)
10:30:09 <chadz> c_wraith: that would be great, but, theres no huge rush... ;)
10:30:27 <c_wraith> well, I asked.  he may answer
10:30:36 <chadz> thanks!
10:31:14 <chadz> vty itself allows for a screen refresh, but, it looks like the Vty context is encapuslated within runUi
10:31:39 <c_wraith> apparently,  schedule $ return ()
10:32:04 <chadz> haha, cute. let me see if that does the trick
10:32:56 <c_wraith> chadz: cygnus is the author, if you have more questions
10:33:03 <cygnus> chadz: pong.
10:33:28 <chadz> cygnus: hey. yah. not sure that worked so well
10:34:00 <cygnus> chadz: you'll need to schedule that action from a separate thread.
10:34:10 <cygnus> (the "force a redraw" thread, if you will)
10:34:35 <cygnus> chadz: what are you doing that requires a forced redraw?
10:35:07 <chadz> launching a process over vty (w3m)
10:35:52 <cygnus> chadz: and there isn't some other event-driven mechanism you can use, such as updating the state of one of your widgets?
10:36:22 <chadz> hmm, tbh i'm not sure. all i have is a single list.
10:36:41 <chadz> any simple way to tickle the list?
10:36:48 <ezyang> Hello #haskell! I find myself in the need of parsing simple commands that look like '/set status=waiting'. Do I want to bust out a parsing library, or just hack up something.
10:37:27 <cygnus> chadz: "tickle"? :)
10:37:29 <_Mikey> hi guys
10:37:34 <_Mikey> quick question
10:37:48 <_Mikey> what the difference between :m someModule
10:37:54 <_Mikey> and :m +someModule
10:38:09 <hpc> :t splitOn
10:38:10 <lambdabot> Not in scope: `splitOn'
10:38:12 <hpc> :t split
10:38:14 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
10:38:20 <hpc> :t breakBy
10:38:21 <chadz> cygnus: haha yah.. as you stated updating the widget (list) state -- would any of the list events other than adding/removal trigger a redraw?
10:38:22 <lambdabot> Not in scope: `breakBy'
10:38:24 <hpc> :t break
10:38:26 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:38:30 <Botje> ezyang: you could get by with regexps.
10:38:34 <hpc> ezyang: something with 'break', perhaps
10:38:43 <ezyang> Oh, I was thinking of slicing and dicing it with break and friends.
10:38:53 <ezyang> One minor complication is that I have Bytestrings, not Strings.
10:39:23 <mike-burns> _Mikey: :m will remove everything but Prelude, :m + will not.
10:39:24 <cygnus> chadz: if by that you mean updating the text of one of the list's element widgets, no.  But to do that, you'd need to have a thread calling "schedule $ setText someTextWidget …" anyway, which *would* force a redraw.
10:39:24 <ezyang> and it turns out it's a lot easier to play fast and loose with strings than bytestrings :^)
10:40:05 <cygnus> chadz: the idea is, your main thread is owned by vty-ui's event loop, and an extra thread talks to w3m and tells vty-ui when changes to the UI should be made.  It does that by calling schedule with an IO action that mutates the UI state.
10:40:09 <chadz> cygnus: alright. ill work on that, but, my threading skills are pretty poor. would you reccomend some little mvar to put/take for triggering the redraw?
10:40:24 <_Mikey> mike-burns, so after using :m I will loose any previous things I've imported
10:40:35 <ezyang> Bah, I guess I'll do it properly. attoparsec's good for bytestrings, right?
10:40:38 <cygnus> chadz: have you taken a look at the demo programs included in the package?
10:40:49 <cygnus> chadz: one of them uses a thread to update a timestamp and a progress bar.
10:41:01 <chadz> cygnus: ill take a look. thanks!
10:41:05 <mike-burns> _Mikey: That's my understanding of it.
10:41:17 <cygnus> chadz: cabal unpack vty-ui && cd src/ && $EDITOR ComplexDemo.hs :)
10:41:17 <chadz> cygnus: and thanks again for the neat package!
10:41:43 <_Mikey> just tested it ;)
10:41:50 <_Mikey> it works exactly as you say
10:41:54 <cygnus> chadz: hope you find it useful.  I'm on github if you want to get in touch.
10:42:01 <_Mikey> that really isn't clear in LYAH cheers.
10:42:46 <_Mikey> @ karma+ mike-burns
10:43:02 <_Mikey> @karma+ mike-burns
10:43:03 <lambdabot> mike-burns's karma raised to 1.
10:59:14 <morel> should "let ... in" work in "[ x | HERE ]" ?
10:59:59 <sipa> yes
11:00:02 <hpc> [x | let x = 5]
11:00:16 <morel> sipa: [ n | let a = 3; b=5 in n<-[a..b]] doesnt work
11:00:20 <morel> [ n | let a = 3; b=5 in n<-[a..b]]
11:00:21 <morel> > [ n | let a = 3; b=5 in n<-[a..b]]
11:00:22 <lambdabot>   <no location info>: Parse error in pattern
11:00:23 <hpc> > [x | let y = 5, x <- repeat y]
11:00:25 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
11:00:35 <hpc> it also does it that way
11:00:37 <kmc> "let" will do something different from "let ... in ..."
11:00:48 <hpc> it'll do it the do-notation way
11:00:51 <kmc> the bare "let" is special in list comprehensions (and 'do' syntax)
11:00:51 <hpc> which is indeed diferent
11:00:59 <hpc> *diff...
11:01:02 <sipa> > [ n | n <- (let {a=3, b=5} in [a..b] ]
11:01:03 <lambdabot>   <no location info>: parse error on input `,'
11:01:05 <kmc> whereas "let .. in .." is an ordinary expression
11:01:07 <sipa> > [ n | n <- (let {a=3; b=5} in [a..b] ]
11:01:08 <lambdabot>   <no location info>: parse error on input `]'
11:01:14 <kmc> an expression in that position in a list comprehension is a Boolean guard
11:01:16 <copumpkin> omg it's kmc
11:01:17 <sipa> > [ n | n <- (let a=3 in [a..b]) ]
11:01:18 <lambdabot>   *Exception: not a number
11:01:20 <kmc> hi copumpkin
11:01:22 <sipa> > [ n | n <- (let a=3 in [a..5]) ]
11:01:23 <lambdabot>   [3,4,5]
11:01:35 <copumpkin> kmc: are you back in beantown?
11:01:35 <sipa> > [ n | n <- let {a=3; b=5} in [a..b] ]
11:01:36 <lambdabot>   [3,4,5]
11:01:40 <kmc> yeah
11:01:45 <sipa> morel: there you go
11:01:58 <morel> ?!
11:01:58 <lambdabot> Maybe you meant: . ? @ v
11:02:11 <morel> lambdabot: nope, thank you
11:02:13 <kmc> it is unfortunate that explanation and examples get interleaved randomly
11:02:20 <_Mikey> XD
11:03:06 <morel> so, let is different from let_in ? okay.
11:03:09 <sipa> morel: the "x <- bla" can be used at the top level in HERE, but not inside arbitrary expressions
11:03:20 <morel> and what's the syntax for "let" ?
11:03:30 <sipa> let var=expr in expr
11:03:33 <kmc> morel, yes.  bare "let" is allowed inside list comprehensions and 'do' only
11:03:39 <sipa> which is on itself again an expression
11:03:44 <kmc> > [ y | x <- [1..5], let y = show x ]
11:03:45 <lambdabot>   ["1","2","3","4","5"]
11:03:51 <sipa> so you can use it on the right hand of a pat<-expr binding
11:04:12 <morel> kmc: perfect. thanks.
11:04:13 <kmc> whereas "let .. in .." is an expression and can be used in any expression context
11:04:16 <morel> sipa: thank you, too.
11:04:24 <morel> ty
11:04:32 <hpc> > [y | x <- [Just 6, Nothing], let (Just y) = x]
11:04:34 <lambdabot>   [6,*Exception: <interactive>:3:33-44: Irrefutable pattern failed for patter...
11:04:43 <sipa> kmc: wow, i didn't know a bare let was allowed in list comprehensions :)
11:04:47 <hpc> huh
11:05:09 <hpc> oh right, let-patterns don't trigger fail
11:05:44 <_Mikey> sipa?
11:06:00 <_Mikey> remember my problem with printing functions
11:06:33 <sipa> sorry, haven't looked into it further
11:06:39 <_Mikey> I think I've fixed it by just adding 0 to it before showing it and it seems to cause something to evaluate
11:06:42 <_Mikey> cause now it shows
11:06:45 <_Mikey> :)
11:06:59 <_Mikey> no worries, I'm just wondering if its "correct"
11:07:09 <_Mikey> but it works for now.
11:07:47 <morel> kmc: actually, i've got something like "[ n | n<-[a..b], let a = 1, let b = 5 ]" but that doesnt work…
11:07:58 <hpc> morel: order matters
11:07:59 <hpaste> “_Mikey” pasted “Working but potentially not correct” at http://hpaste.org/54403
11:08:04 <morel> oops
11:08:06 <hpc> it gets translated to do
11:08:12 <morel> alright
11:08:12 <hpc>   n <- [a..b]
11:08:14 <hpc>   let a = 1
11:08:15 <hpc> ...
11:08:33 <morel> worx!! =)
11:08:53 <_Mikey> :)
11:16:57 * hackagebot git-annex 3.20111122 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20111122 (JoeyHess)
11:34:07 <Kaidelong> there is one thing true about the monoid for (Monoid m) => ZipList m that isn't true of the monoid for [m], which is that it has an element [] for which any operation involving it returns the same element
11:35:16 <Kaidelong> ZipList [] `mappend` _ = ZipList [], and _ `mappend` ZipList [] = ZipList []
11:35:58 <ski> *nod* an annulator
11:35:59 <Kaidelong> that's like zero for multiplication and I think that's what originally set me off on this tangent
11:38:05 <Kaidelong> hmm, thanks for teaching me new terminology ski
11:38:33 <cheater> isn't that what you call a zero
11:39:03 <ski> yes, "zero element" is another common term
11:39:55 <Kaidelong> don't people also call the identity element a zero element though?
11:39:59 <Kaidelong> it sounds confusing
11:41:58 <c_wraith> zero is the additive identity
11:45:43 <Cale> Maybe "annulator" -> "annihilator"?
11:46:10 <c_wraith> haven't I also seen it described as an "absorptive element" or something?
11:46:36 <Cale> "annulator" seems to be the German word for "annihilator"
11:46:56 <ski> Cale : ah, ty
11:47:14 <Clint> you're missing an l in the german
11:50:47 <silver> @seen bos
11:50:48 <preflex>  bos was last seen on #haskell 21 hours, 44 minutes and 6 seconds ago, saying: amazing what a bit of time off will do
11:50:48 <lambdabot> Unknown command, try @list
11:51:04 <bos> ?
11:51:16 <elliott> @seen bos
11:51:17 <preflex>  bos was last seen on #haskell 12 seconds ago, saying: ?
11:51:17 <lambdabot> Unknown command, try @list
11:51:18 <elliott> much better!
11:52:53 <silver> bos, oh sorry, just were discussing with friend how one can create fast programs using combinatrs, he told me I need skills of dons or yours to do so, I just got curious if you hang out in irc :)
11:53:16 <bos> no worries. i mostly lurk.
11:55:07 <Cale> silver: meh, it's not like there are only 3 people in the world who can do it :P
11:56:00 <periodic> It's mostly a case of putting in the time to optimize… and understanding how to optimize haskell.  Right?
11:56:06 <Cale> silver: It can take dedication and hard work to make something *really* fast, but that's true regardless.
11:56:11 <Cale> yeah
11:56:55 <periodic> Haskell makes it easy to toss something together that "works", but then the optimization is a bit opaque.  I still need a lot of practice with optimizing.
11:57:06 <c_wraith> as tibbe likes to point out...  It's hard to understand performance of lazy code, sure.  It's also hard to understand performance of of strict code.
11:57:28 <periodic> yeah, performance is a tricky beast regardless.
11:57:59 <periodic> And 90% of the time it's not worth optimizing.
11:58:10 <periodic> Because it isn't your real bottleneck. :)
11:58:46 <Cale> It's mainly the fact that the evaluation mechanism is *different*, and most people have a lot of experience with analysing the performance of code which is under strict evaluation. I don't think that lazy evaluation really offers *that* much more of a challenge. There's a bit more non-locality to the performance analysis of non-strict code, which does make it a little more difficult.
11:59:06 <Cale> But it's not that big of a deal, especially with good profiling tools.
11:59:31 <kmc> @quote ChrisOkasaki
11:59:31 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
11:59:57 <c_wraith> speaking of optimization...  I wish I could optimize my type signatures without completely destroying performance. :(
12:00:11 <Cale> c_wraith: wat
12:01:17 <c_wraith> Cale: Optimize the type signatures for readability, that is.  I have a bunch of functions that use several multi-parameter type classes.  Always the same set, always related the same way.  Having them all listed just *wrecks* the haddock.
12:01:43 <periodic> Do type aliases not help?
12:01:59 <c_wraith> I've tried a couple different approaches for bundling all the classes together..  An empty class with superclass constraints, and the constraint kinds extension
12:02:07 <c_wraith> Both result in readable type signatures
12:02:19 <c_wraith> but both destroy call-site class specialization
12:02:26 <c_wraith> resulting in like a 30% performance hit
12:03:03 <Cale> c_wraith: ah, that's something we might need a solution to eventually as well
12:03:40 <elliott> cpp! :P
12:04:00 <c_wraith> It seems like it's something that should be reported as a ghc bug, but I haven't been able to reproduce the issue very well in smaller tests.
12:04:13 <Cale> c_wraith: Apparently specialise and rules are pretty broken in the presence of type families too
12:05:22 <parcs_> c_wraith: constraint kinds might help you with that
12:05:36 <c_wraith> parcs_: I tried.  same problem
12:05:47 <c_wraith> parcs_: in fact, I compiled ghc head *just* to test that.
12:06:08 <parcs_> same problem with performance?
12:06:20 <c_wraith> yeah
12:06:49 <parcs_> weird.. type synonyms affecting performance :P
12:06:58 * hackagebot cqrs 0.5.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.5.0 (BardurArantsson)
12:07:14 <parcs_> that probably shouldn't be happening
12:07:28 <c_wraith> parcs_: well, I get the feeling that the mechanism I'm relying on for specialization is fragile
12:07:46 <c_wraith> I'm using GHC 7's INLINEABLE pragma
12:08:15 <c_wraith> which can be used for cross-module call-site type class specialization.
12:11:58 * hackagebot cqrs-example 0.5.0 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.5.0 (BardurArantsson)
12:13:27 <parcs_> c_wraith: maybe try constraint kinds + liberal type synonyms
12:14:26 <poucet> What is the offtopic channel again?
12:16:01 <Kaidelong> poucet: #haskell-blah ?
12:16:12 <poucet> thx
12:25:53 <FUZxxl> Wha sorting algorithms can easily be adapted for non-mutable data-structures?
12:26:36 <periodic> It's tricky because most of them generate a lot of intermediary states, and were designed for sorting arrays.
12:27:16 <periodic> It's not hard to implement merge-, quick-, and heap- sorts, and I believe they'll still run in O(n ln n), but they won't be as fast as their mutable cousins.
12:27:22 <periodic> At least, that's my recollection.
12:27:50 <Cale> On the other hand, they don't ruin your original list while running.
12:27:53 <FUZxxl> yeah
12:28:03 <FUZxxl> How about binary-tree-sort?
12:28:10 <Cale> That works
12:28:24 <FUZxxl> Is it also O(n log n)?
12:28:25 <Cale> The sort in Data.List is a bottom-up mergesort
12:28:28 <Cale> yes
12:28:36 <Cale> (in both cases)
12:28:36 <FUZxxl> okay....
12:28:43 <Cale> Quicksort is actually O(n^2) worst case
12:28:46 <FUZxxl> Do you think a smoothsort could work?
12:28:51 <Cale> only O(n log n) average case
12:28:52 <periodic> I'm pretty sure "toList . foldr (Data.Map.insert) empty" is n ln n.
12:29:02 <periodic> Data.Map.empty that is.
12:29:07 <elliott> periodic: you mean toAscList :)
12:29:10 <elliott> periodic: and uh
12:29:11 <Cale> Set.toList . Set.fromList
12:29:12 <elliott> that's just fromList
12:29:15 <periodic> elliott: er, yeah.
12:29:19 <elliott> but that discards duplicates
12:29:29 <copumpkin> so you really want to keep duplicates
12:29:41 <copumpkin> use a Data.Map a [a]
12:29:58 <Cale> concat . Map.elems . Map.fromListWith (++) . map (:[])
12:30:02 <Cale> something like that
12:30:26 <Cale> Maybe that should be a Set still...
12:31:05 <periodic> FUZxxl: In short, there are many many ways to sort in O(n log n)
12:31:31 <periodic> what type of tree does Data.Map use internally?
12:31:55 <Cale> > let qsort [] = []; qsort (x:xs) = qsort less ++ [x] ++ qsort greater where (less, greater) = partition (<= x) xs in qsort "hello, world!"
12:31:56 <lambdabot>   " !,dehllloorw"
12:32:02 <copumpkin> periodic: a loosely balanced one
12:32:05 <gio1231> Cale: hi
12:32:08 <c_wraith> periodic: something designed specifically for persistent implementations
12:32:13 <Cale> periodic: binary balanced trees
12:32:32 <c_wraith> the rebalancing operations are very lax
12:32:55 <copumpkin> they actually involve floating point calculations
12:32:57 <copumpkin> which is crazy
12:33:04 <Cale> copumpkin: orly?
12:33:11 <copumpkin> yeah, wtf
12:33:25 <copumpkin> get your floats out of my datastructures
12:33:54 <copumpkin> oh maybe it's just Int
12:33:56 <copumpkin> still
12:33:56 <copumpkin> wtf
12:34:03 <FUZxxl> BTW, is there an in-place stable sorting algorithm in O(n log n)?
12:34:24 <Cale> copumpkin: Int makes more sense
12:34:33 <Cale> copumpkin: for recording information about balance
12:35:24 <periodic> Huh, so it uses it's own tree implementation? Interesting.
12:38:45 <simon> FUZxxl, I'd like to know!
12:39:36 <Cale> There's one in O(n (log n)^2) apparently
12:40:03 <morel> should this work? (or does it?)  --   if a == b then let x = 1; y = 2 else let x = 3; y = 4
12:40:05 <Cale> (a stable in-place mergesort)
12:40:14 <FUZxxl> simon: I've read a paper where the author states that no such algorithm exists, but he says he can't prove
12:40:16 <Cale> morel: no
12:40:21 <morel> Cale: y`
12:40:23 <morel> y?
12:40:25 <morel> whyß
12:40:30 <morel> omg, sry
12:40:33 <morel> Cale: why?
12:40:38 <Cale> morel: because your let doesn't have an in
12:40:45 <Cale> let <decls> in <expr>
12:40:50 <simon> FUZxxl, there's Cycle Sort. it says it's not stable, but it sounds "somewhat" stable.
12:40:59 <morel> Cale: but there's a "let" without "in"
12:41:02 <FUZxxl> simon: Cycle sort is O(n²)
12:41:06 <Cale> morel: Inside of do, yes
12:41:22 <simon> FUZxxl, you're right, I misread the table.
12:41:22 <FUZxxl> It's only O(n) if the set of indices is the same as the set of values
12:41:31 <Cale> morel: But not inside of if (even when if is inside of do)
12:41:43 <morel> Cale: hmm
12:41:52 <FUZxxl> Cale: You can have a let inside an if
12:42:00 <Cale> morel: you can write  let x = if a == b then 1 else 3; y = if a == b then 2 else 4
12:42:04 <FUZxxl> if x then let y = z in abc else ...
12:42:12 <Cale> FUZxxl: you can't have let without in inside if
12:42:24 <simon> FUZxxl, sounds to me like it can't be done either, but that's just from looking at mergesort and quicksort.
12:42:29 <FUZxxl> But the binding of y ends at the else
12:42:51 <morel> Cale: ty!
12:42:59 <monochrom> let (x,y) | a==b = (3,4) | otherwise = (0,1)
12:43:11 <FUZxxl> > let a = 3 in if True then let a = 1 in print a else print a
12:43:12 <lambdabot>   <IO ()>
12:43:22 <FUZxxl> > let a = 3 in if True then let a = 1 in a else a
12:43:23 <lambdabot>   1
12:43:32 <FUZxxl> > let a = 3 in if False then let a = 1 in a else a
12:43:33 <lambdabot>   3
12:43:37 <FUZxxl> You see?
12:43:49 <morel> lol
12:43:51 <morel> nice
12:44:20 <FUZxxl> I hate that my code looks so much like pascal...
12:44:26 <FUZxxl> or even basic
12:44:38 <Cale> or: let (x,y) = if a == b then (1,2) else (3,4)
12:44:55 <Cale> (similar to monochrom's answer)
12:46:07 <monochrom> let me run it through ghc -O to see if the tuple gets into the way in reality
12:46:37 <FUZxxl> I'd really like to have a syntax like
12:46:53 <FUZxxl> let | foo -> a = b; c = d
12:46:57 <simon> I'm trying to apply a problem to the scheme of dynamic programming, but I'm not sure exactly how to fit the exponential amount of results into the memoization table if it should be kept two-dimensional.
12:47:05 <FUZxxl>      | bar -> a = e; b = f
12:47:35 <copumpkin> FUZxxl: it'd help if you explained what that does
12:47:38 * morel supports FUZxxl
12:48:26 <morel> is Simon Peyton Jones sometimes inhere?
12:48:36 <copumpkin> no
12:48:38 <FUZxxl> copumpkin: Well, it is supposed to take the first set of bindings if foo and the second set if bar. if neither foo nor bar, the match fails
12:48:39 <Cale> morel: not as far as I know
12:48:51 <Cale> morel: Simon Marlow sometimes is though
12:48:57 <monochrom> darn, the tuple does get into the way
12:48:59 <copumpkin> FUZxxl: why not a case?
12:49:06 * monochrom tries -O2
12:49:25 * morel doesnt know SimonMarlow
12:49:29 <copumpkin> JaffaCake
12:49:47 <morel> oh, yes, i do!
12:49:50 <FUZxxl> copumpkin: Ah case is counter-intuitive for me
12:49:53 <shapr> byorgey: What's the name of your library again? I want to watch for it on hackage..
12:49:54 <FUZxxl> in that place
12:50:12 <monochrom> tuple still there in -O2. oh well, tuple work may be cheaper than testing twice.
12:50:15 <shapr> lambdabot: seen simonpj
12:50:21 <shapr> preflex: seen simonpj
12:50:22 <preflex>  simonpj was last seen on #ghc 3 years, 73 days, 5 hours, 59 minutes and 56 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
12:50:27 <FUZxxl> @seen simonpj
12:50:27 <preflex>  simonpj was last seen on #ghc 3 years, 73 days, 6 hours and 2 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
12:50:27 <lambdabot> Unknown command, try @list
12:50:31 <copumpkin> FUZxxl: I sort of see what you mean, but then you'd need to check that all branches bind the same variables
12:50:32 <FUZxxl> @list
12:50:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:50:53 <FUZxxl> copumpkin: All variables that are not bound are undefined
12:50:59 <FUZxxl> (and yield an error)
12:51:17 <FUZxxl> IMHO that syntax is much more intuitive than a case
12:51:18 <copumpkin> hmm, that seems kind of unhaskelly
12:51:29 <FUZxxl> Well, incomplete patterns exist too
12:51:45 <hpaste> morel pasted “how would you write that?” at http://hpaste.org/54404
12:51:52 <morel> FUZxxl: ↑
12:52:00 * hackagebot elerea 2.5.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.5.0 (GergelyPatai)
12:52:02 * hackagebot dow 0.2.4 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.4 (GergelyPatai)
12:52:07 <copumpkin> FUZxxl: but not names that appear to be unbound
12:52:12 <monochrom> Simon Marlow is sometimes here as JaffaCake
12:52:44 <monochrom> Graham Hutton is somtimes here as grahamhutton. on mailing lists, some people call him Graham Button. :)
12:52:57 <morel> :D
12:53:22 <hpaste> FUZxxl annotated “how would you write that?” with “how would you write that? (annotation)” at http://hpaste.org/54404#a54405
12:53:25 <morel> monochrom: are you a famous haskeller?
12:53:26 <FUZxxl> http://hpaste.org/54404
12:53:42 <FUZxxl> That's how I would do it, given that my suggested syntax existed
12:53:49 <morel> FUZxxl: does that work??
12:53:50 <FUZxxl> morel: I think so...
12:53:52 <FUZxxl> morel: no
12:53:54 <FUZxxl> xD
12:53:58 <FUZxxl> look at that:
12:53:59 <morel> :)
12:54:30 <monochrom> not very famous. just famous for http://www.vex.net/~trebla/haskell/sicp.xhtml , http://www.vex.net/~trebla/haskell/fix.xhtml , and http://www.vex.net/~trebla/haskell/cont-monad.xhtml
12:55:00 <morel> Albert Y. C. Lai
12:55:17 <FUZxxl> That should work
12:55:23 <monochrom> as in, I am not the only one to suggest people to read those, so that's cool
12:55:24 <hpaste> FUZxxl annotated “how would you write that?” with “how would you write that? (annotation)” at http://hpaste.org/54404#a54406
12:55:33 <dylex> morel, FUZxxl: one option would be to split off the rest of the function into f2 a b and do if ... then f2 x y else f2 w v
12:56:18 <FUZxxl> Fame is relative
12:56:31 <FUZxxl> dylex: That would be against DRY
12:56:36 <morel> monochrom: where are you from?
12:56:39 <FUZxxl> I love dry
12:56:42 <morel> DRY?
12:56:47 <Kaidelong> don't repeat yourself
12:56:50 <mauke> do repeat yourself
12:56:56 <FUZxxl> mauke: :c
12:56:58 <morel> ?!
12:56:59 <lambdabot> Maybe you meant: . ? @ v
12:57:00 * hackagebot cqrs-example 0.5.0.1 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.5.0.1 (BardurArantsson)
12:57:12 <FUZxxl> :c is like :( but smaller...
12:57:26 <mauke> ヾ
12:57:32 <dylex> the only part you'd repeat is the one token "f2". that's hardly repetition.
12:58:06 <mike-burns> "DRY" is a very misunderstood principle.
12:58:53 <FUZxxl> dylex: Ah... I missunderstood your idea
12:59:02 <FUZxxl> mauke: What is that? Japanese?
12:59:25 <mike-burns> I just looked at this paste for the first time. What are you actually trying to do?
12:59:33 <Cale> KATAKANA VOICED ITERATION MARK
12:59:37 <FUZxxl> ah...
12:59:42 <mauke> ツ
13:00:06 <Cale> not something you see very often...
13:00:08 <FUZxxl> 囧
13:00:27 <Cale> The hiragana ones are more common.
13:01:58 <Cale> heh, googling it gives mostly unicode art :P
13:02:21 <Cale> http://ja.wikipedia.org/wiki/%E3%81%9A%E3%83%BE%E3%82%84 -- there is this though
13:02:38 <morel> /
13:02:46 <gio1231> Cale: hi
13:02:49 <Cale> hi
13:02:59 <dmos> Is there an ultimate source I can read as to how atomicModifyIORef and MVars are represented at assembly level in a -threaded program?
13:03:22 <c_wraith> they're in the GHC runtime source.
13:03:24 <morel> monochrom: i added you on G+ :]
13:04:02 <monochrom> yikes
13:05:13 <FUZxxl> monochrom: Are you Japanese?
13:05:25 <monochrom> no. Chinese
13:05:29 <FUZxxl> ah...
13:05:34 <monochrom> grew up in Hong Kong
13:05:38 <FUZxxl> ah...
13:06:16 <FUZxxl> Chinese is a nice language, with a nice script
13:06:25 <morel> in hongkong people drive on the left oO
13:06:51 <monochrom> in america people drive on the right Oo  :)
13:06:58 <morel> hehe =)
13:07:24 <FUZxxl> That's nothing.
13:08:06 <kmc> dmos, smartass answer: compile your program and disassemble it :D
13:08:14 <FUZxxl> In Peking it seems that there are no rules at all. The car with that has the loudest horn wins o.O
13:08:16 <dmos> c_wraith: doesn't get me that far. http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/src/GHC-MVar.html
13:08:27 <kmc> dmos, i wrote a blog post recently on some related topics: http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
13:08:29 <dmos> kmc: Hmm. You've got a point there.
13:08:44 <c_wraith> dmos: I said *runtime* source, not "base library" source
13:09:05 <dmos> c_wraith: Ok, then my Google fu is failing, will try again.
13:09:12 <c_wraith> google's not going to find it
13:09:15 <kmc> dmos, the mvar primops are defined in http://hackage.haskell.org/trac/ghc/browser/rts/PrimOps.cmm#L1105
13:09:16 <c_wraith> just browse the ghc source
13:09:48 <kmc> from there it's basically chasing function calls through Cmm and C files in rts/
13:12:01 * hackagebot hakyll 3.2.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.1.0 (JasperVanDerJeugt)
13:12:56 <albertid_> Hi, "cabal install happy" fails because "The program happy is required but it could not be found". Whats happening here? (did cabal update and ~/cabal/bin is in $PATH)
13:13:00 <dmos> kmc, c_wraith: Ok, I'll dig through PrimOps. Thanks
13:24:34 <kmc> i want a simple concurrent job queue; is there a simpler solution than this one? http://hpaste.org/54407
13:25:07 <kmc> i can't use Chan because i want the workers to quit when the queue is empty, not block forever
13:25:19 <kmc> i don't want to use one thread per job, for other reasons
13:26:47 <kmc> i suppose i could use TChan with isEmptyTChan
13:27:30 <dcoutts> kmc: or use a thread per job + a counting semaphore to limit the number of concurrent jobs
13:28:03 <kmc> *nod*
13:28:31 <kmc> it's a bit more complicated in this case, because i'm launching remote jobs by ssh, and want exactly n jobs running on each machine at once
13:28:56 <sshine> isn't (return . f) the same as (liftM f)?
13:29:05 <kmc> so i think one haskell thread per host*n is the simplest design
13:29:36 <kmc> sshine, good catch :)
13:29:58 <kmc> i had 'return' in the cases for 'f', and then factored it out
13:30:11 <sshine> apparently not completely. return . flip :: Monad m => (a -> b -> c) -> m (b -> a -> c) and liftM flip :: Monad m => m (a -> b -> c) -> m (b -> a -> c)
13:30:23 <FUZxxl> I always think that something went wrong when I have to use return in my code
13:30:37 <FUZxxl> (except under some circumstances)
13:31:10 <FUZxxl> :t (return .)
13:31:11 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
13:31:11 <sshine> FUZxxl, yeah, it seems that when I return something that is some function applied to something, I can always use liftM/fmap.
13:31:47 <FUZxxl> @hoogle (a -> b) -> a -> m b
13:31:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:31:49 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:31:49 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:32:14 <alistra> FUZxxl: let a f x = return . f $ x
13:32:22 <codemac> how did I not know you could search hoogle for types
13:32:23 <alistra> @pl let a f x = return . f $ x in a
13:32:24 <lambdabot> (return .)
13:32:54 <alistra> @type let a f x = return . f $ x in a
13:32:55 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1) -> a -> m a1
13:33:01 <alistra> winnin
13:33:02 <alistra> winnin
13:33:03 <alistra> g
13:33:28 <alistra> @type liftM (.)
13:33:29 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a -> f b)
13:33:36 <alistra> meh nope
13:34:17 <kmc> hmm i can use atomicModifyIORef instead
13:44:59 <ybit> http://imgur.com/a/yIUOA
13:45:03 <ybit> through working on the haskell mascot
13:45:18 <ybit> not going to say which image i goofed on and am too lazy to correct atm
13:49:16 <Lemmih> ybit: You accidentally the whole word?
13:51:47 <Funk> Hello?
13:51:50 <copumpkin> ybit: I like them
13:51:52 <copumpkin> Funk: hello
13:51:58 <Funk> yo
13:52:09 <Funk> this is cool
13:52:16 <Lemmih> It totally is.
13:52:27 <copumpkin> Funk: can we help you? :O
13:52:42 <Funk> umm yea, if ye don't mind :)
13:52:53 <copumpkin> ask your question!
13:52:57 <sipa> we do not require animal offerings
13:53:04 <Funk> lol
13:53:05 <copumpkin> sipa: speak for yourself
13:53:27 <sipa> does a copumpkin require an offering of pumpkins?
13:53:46 <sipa> anyway, Funk, we can't help you before you ask a question
13:54:22 <Funk> just doin some exercises, trying to write a function which takes in an array of numbers and spits out the same array but eliminates the duplicates :P I'm still grasping some basics here too
13:54:46 <copumpkin> you probably mean a list :)
13:54:47 <sipa> i presume you mean a list?
13:54:52 <sipa> !hi5 copumpkin
13:54:58 <copumpkin> !lo5 sipa
13:55:41 <Funk> yup sorry, told ya
13:56:21 <Lemmih> Funk: First take your two base cases: [] and (:).
13:56:52 <Lemmih> Funk: The answer for the case of [] is simply [].
13:56:53 <Funk> ok
13:56:57 <gwern> @quote
13:56:58 <lambdabot> <vic_> says: everytime you unsafePerformIO, a C++ programmer spawns
13:57:34 <Lemmih> Funk: For the case of (:), we need to be a bit clever.
13:57:41 <sipa> Funk: what do you need to know about "the rest of the list" to be able to remove duplicates?
13:58:55 <Lemmih> Funk: We could remove all occurrences of the head of the list from the tail of the list. Then a bit of recursion should take care of the rest.
13:59:02 <Funk> umm i dunno, for example it would be a list like ( 1, 2, 2, 3, 4, 4, 5 ) and I'd like to turn it to (1, 2, 3, 4, 5)
13:59:30 <Funk> yea, I just need to do some more reading
14:00:09 <sipa> Funk: (1,2,3) is tuple, not a list
14:00:14 <sipa> [1,2,3] is a list
14:00:24 <Lemmih> > let removeX = filter (/='X') in removeX "HXellXo WoXrlXd."
14:00:25 <lambdabot>   "Hello World."
14:00:50 <sipa> the difference is a) tuples can have elements of different types but b) have their length fixed by their type
14:01:26 <Funk> ah yea, I meant "[]"  (further proving my lack of haskell skillz)
14:17:07 <leoncamel> > version
14:17:08 <lambdabot>   Not in scope: `version'
14:17:30 <leoncamel> > :help
14:17:31 <lambdabot>   <no location info>: parse error on input `:'
14:29:07 <bluej774> Can someone help me out?  I can't figure out the type signature for a State monad whose state is an Array of Int and whose return is a Double.
14:29:32 <mauke> State (Array Int) Double
14:31:11 <mm_freak> State (Array SomeIndexType Int) Double
14:31:19 <bluej774> That one worked.
14:31:39 <bluej774> I didn't realize the Array had to be completely in parens.
14:31:58 <bluej774> Thanks
14:32:32 <bluej774> Does anyone else feel like a State Array is going to be a nightmare to work with?
14:32:49 <c_wraith> it probably will be really inefficient
14:32:50 <mm_freak> bluej774: depends on what you're doing
14:33:15 <bluej774> c_wraith: Should be more efficient for random access than a State [Int]
14:33:32 <mm_freak> bluej774: are you using the array in a read-only fashion?
14:33:33 <Eduard_Munteanu> bluej774: updates are the problem, not access
14:33:33 <c_wraith> bluej774: not if you're updating it very often.
14:33:37 * monochrom agrees with "depends"
14:33:59 <Eduard_Munteanu> If you're just reading from it, then you probably want Reader, not State.
14:34:52 <bluej774> Good point.  I think I may just rewrite the damn function altogether to be recursive instead of doing any monad stuff.
14:35:45 <FUZxxl> goos night
14:40:45 <carpi> Is there any difference between "sum (takeWhile (<10000) (filter odd (map (^2) [1..])))" and "sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])" in terms of run time performance..?
14:41:11 <carpi> im guessing the second version is inefficient?
14:41:35 <shachaf> carpi: Because it computes n^2 twice? You could use "let" to avoid that.
14:41:46 <shachaf> carpi: Instead of making conjectures you should benchmark it and see.
14:41:59 <shachaf> @google criterion haskell
14:41:59 <lambdabot> http://hackage.haskell.org/package/criterion
14:42:00 <lambdabot> Title: HackageDB: criterion-0.5.1.1
14:42:17 <carpi> shachaf: yup.. so it is inefficient.... criterion is the benchmark tool?
14:42:54 <shachaf> carpi: I have no idea if it's inefficient.
14:43:07 <shachaf> criterion is what that link says it is.
14:44:42 <carpi> are there any programs that tell me how i can improve my code?
14:44:52 <Phyx-> carpi: hint?
14:45:16 <carpi> Phyx-: hint ? its a name of a program?
14:45:24 <carpi> or are you asking for a hint?
14:45:25 <Phyx-> carpi: sorry,  hlint
14:45:35 <carpi> ah okie
14:46:28 <Eduard_Munteanu> hlint concerns itself with style mostly, no?
14:47:27 <Phyx-> Eduard_Munteanu: yeah, i didn't read back what the convo was covering :/
15:13:31 <carpi> a while ago a fellow haskeller mentioned another channel by the name no-math or 'nomath' or something similar. Could someone please tell me if they recognize the channel im talking about..?
15:15:04 <ben> Joining #math and checking their topic or chanserv message might be a start
15:15:33 <carpi> ben: thank you. that might work. ill try that -)
15:15:43 <ben> Good luck :)
15:16:33 <stribor> is there way to convert type of Pixbuf into Render()
15:18:16 <carpi> not-math :)
15:21:18 <roconnor> > 49 `choose` 6
15:21:19 <lambdabot>   Not in scope: `choose'
15:23:58 <carpi> while pattern matching in parameters.. are lists the only types of parameters that can be pattern matched?
15:24:03 <roconnor> > product [49,48,47,46,45,44] `div` product [1..6]
15:24:04 <lambdabot>   13983816
15:24:41 <roconnor> > product [49,48,47,46,45,44,43] `div` product [1..7]
15:24:42 <lambdabot>   85900584
15:25:08 <roconnor> > product [49,48,47,46,45,44,43] `div` product [1..7] :: Integer
15:25:09 <lambdabot>   85900584
15:25:25 <carpi> > product [1..3]
15:25:26 <lambdabot>   6
15:26:06 <roconnor> > product [49,48,47,46,45,44,43] `div` (3*product [1..7])
15:26:07 <lambdabot>   28633528
15:30:38 <JoeyA> carpi: You can pattern-match with any data constructor
15:30:53 <JoeyA> > f (a,b,c) = a+b+c in f (1,2,3)
15:30:55 <lambdabot>   <no location info>: parse error on input `='
15:30:59 <JoeyA> > let f (a,b,c) = a+b+c in f (1,2,3)
15:31:00 <lambdabot>   6
15:31:47 <JoeyA> > let f (Just a) (Just b) = Just (a+b); f _ _ = Nothing in (f (Just 3) (Just 5), f (Just 7) Nothing)
15:31:49 <lambdabot>   (Just 8,Nothing)
15:35:59 <hpaste> emph pasted “error” at http://hpaste.org/54410
15:36:17 <emph> Evening evening! Anyone care to explain that error for me? :)
15:37:51 <JoeyA> emph: Can you compile a simple hello world program?  main = putStrLn "Hi"
15:38:03 <emph> Gimme a sec
15:38:04 <JoeyA> It might be a problem with your installation; I don't know.
15:38:22 <photex> hi folks quick question about OpenGL and IORefs, mainly, are IORefs how I would use an accumulation variable for use GLUT callbacks?
15:38:31 <c_wraith> that error message looks a lot like you didn't use --make and you needed it
15:38:31 <photex> like a global perhaps
15:38:34 <rwbarton> emph: use --make
15:38:38 <JoeyA> emph: If that works, try a ByteString version: import Data.ByteString.Char8 as C; main = C.putStrLn $ C.pack "Hi"
15:38:52 <JoeyA> ah
15:38:57 <JoeyA> what they said
15:39:20 <photex> for instance, I need to calculate the delta of the mouse between frames and stuff
15:39:25 <JoeyA> GHC 7 doesn't require the --make parameter.
15:39:37 <emph> JoeyA, thanks! So ghc doesn't link otherwise?
15:39:50 <emph> Or rwbarton I meant, or both! ;)
15:39:54 <JoeyA> I don't know what it does without --make :P
15:40:03 <JoeyA> (I forget)
15:40:33 <emph> Okok, was a while ago I did some Haskell. Knowledge like that has a way of fading away.
15:41:14 <rwbarton> you could explicitly list the libraries you want to link against, but --make is easier
15:46:29 <o1iver> what do I have to do to load a debugged into ghci?
15:46:38 <o1iver> "Cannot find default module for breakpoint."...?
15:47:00 <dmwit> Perhaps you are loading the compiled version of the code (rather than interpreting it)?
15:47:04 <dmwit> Not 100% sure of that, though.
15:47:12 <o1iver> dmwit: I am loading a .hs file
15:47:17 <dmwit> If that's the problem, you can fix it by using the :l * form rather than the :l form.
15:47:20 <dmwit> e.g.
15:47:22 <dmwit> :l *Main.hs
15:47:36 <o1iver> dmwit: actually I am loading the module... :m
15:47:50 <c_wraith> if it's via :m, it's definitely compiled
15:48:05 <c_wraith> because :m only gets modules out of installed packages
15:48:07 <o1iver> c_wraith: ah ok that makes sense, yeah...
15:52:44 <tmhz> anyone know of a function that can make multiple groups like this...   groups 3 "hello world!" -> ["hel", "lo ", "wor", "ld!"]
15:53:48 <c_wraith> @hoogle Int -> [a] -> [[a]]
15:53:49 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:53:49 <lambdabot> Data.List drop :: Int -> [a] -> [a]
15:53:49 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:53:56 <c_wraith> none of those..
15:54:04 <c_wraith> But I'm sure there's something in the split package that does that
15:54:08 <c_wraith> @hackage split
15:54:08 <lambdabot> http://hackage.haskell.org/package/split
15:54:27 <JoeyA> chunksOf (guess)
15:54:35 <c_wraith> splitEvery, actually
15:54:47 <JoeyA> splitEvery
15:54:52 <c_wraith> which is apparently the same as chunk
15:55:23 <tmhz> ahh thankyou
15:58:19 <dibblego> is there a similar mnemonic for Reader/Writer/State in a similar vain as Bananas, Barbed Wire and all that?
15:58:56 <tmhz> Does that split package come standard or do I have to cabal it?
15:59:11 <tmhz> I can't seem to import it
15:59:34 <c_wraith> yes, you'll have to install it
16:00:07 <tmhz> cool thanks
16:00:09 <dmwit> dibblego: I haven't read Bananas, Barbed Wire, and Lenses; can you say what you mean by "mnemonic"?
16:00:28 <dibblego> I just mean cute names for concepts
16:00:40 <kirindave> Writer = Barbed Wire?
16:00:44 <dibblego> rather than Catamorphisms, Anamorphisms and Hylomorphisms
16:00:44 <kirindave> Or perhaps Barb Wire.
16:00:47 <dmwit> Don't think so. =)
16:01:00 <dibblego> I forget which is which, but they mostly denote *morphisms
16:01:30 <mapreduce> Barb Wire, a superhero published by Comics Greatest World.
16:01:35 <dibblego> yeah me neither, so I think I'll just invent one on a lazy weekend day
16:01:49 <mapreduce> There I was expecting to find it was how USians wrote barbed wire.
16:03:00 <kirindave> mapreduce, I think we call it freedom wire
16:03:11 <kirindave> No wait that's razor wire I'm thinking of.
16:03:16 * mapreduce pepper sprays kirindave.
16:03:19 <kirindave> Or, as my dad used to call it, catamorphism wire.
16:26:44 <xhazk> Ive sort of hit a wall in Bash and am looking at other languages to learn for my purposes (still new to all this). Since Im learning Haskell for xmonad I figured Id ask about it first. I have a long pipe shell script, but need different timings for each subprocess, and some to fire only once, without affecting each other. It doesnt seem Bash can do this properly. Is this something I could achieve in Haskell
16:26:46 <xhazk> for a script > Dzen2 pipe?
16:26:49 <xhazk> Sorry, wall of text.
16:28:24 <Axman6> xhazk: can you explain what you're after in a bit more detail?
16:28:29 <adamCS> hey guys, is there anyway I can compare the execution speed of two different haskell functions?
16:28:39 <Axman6> adamCS: see Criterion
16:28:40 <adamCS> (2 different implementations of the one functions)
16:28:49 <adamCS> wow that was quick Axman6:)
16:29:13 <Axman6> it's one of the most amazing libraries out there for benchmarking. it'll give you graphs and everything!
16:29:35 <adamCS> oh cool
16:29:44 <adamCS> my need for it is simple anyway
16:29:48 <adamCS> well, I'll tell you
16:30:01 <adamCS> I'm doing something recursively... generating a list
16:30:18 <xhazk> Axman6: Sure, thanks for asking. The .sh pipes system information to Dzen2 for display. I need it to poll certain data once and drop that sub process (static data like kernel version), and other data to be polled on varying schedules (i.e. cpu usage every 1 second, but mail checking every 15 mins, etc)
16:30:30 <xhazk> So, wondering if haskell would be more suitable
16:30:32 <adamCS> and I want to know if xs++[x] each time is quicker than x:xr and then reverse the resulting list
16:30:48 <c_wraith> adamCS: one of those is O(n), the other is O(n^2)
16:30:49 <adamCS> xs* not xr
16:31:20 <adamCS> yeah but which?:)
16:31:50 <dxq> well, adding to the head of a list is O(1)
16:31:51 <gwern> adamCS: benchmark it with criterion and find out!
16:31:56 <dxq> or do that
16:31:56 <dxq> haha
16:32:05 <dxq> adding to the tail of a list is O(n)
16:32:30 <adamCS> dxq I can't because I need to maintain the order of the (x:xs) parameter
16:32:43 <Axman6> xhazk: sure, sounds like a perfect use for threads in haskell. just make a thread for each task you want to accomplish, and an extra thread that will do the writing to the pipe. use a Chan of String or ByteString and have each thread write its results to the chan. (the reason for the extra thread is so you don't get interleved output from unrelated tasks)
16:32:53 <monochrom> if you think straight, you may stay with (:) and do away with reverse.
16:32:53 <dxq> adamCS: right, but you said xs++[x] or x:xs then reverse
16:33:01 <adamCS> I would have guessed the other one:/
16:33:19 <Axman6> the reverse is much faster than the append version
16:33:32 <xhazk> Axman6: Great, was really hoping to hear something like that. It means I should be able to incorporate right into the xmonad script. Thanks a lot.
16:33:45 <adamCS> yeah I'm removing duplicates from a list
16:33:56 <Axman6> because when using (++), you have to completely traverse the xs list every time you append something
16:33:58 <gwern> personally, this sounds like asking the wrong question
16:34:09 <adamCS> I take the list and pass it into another function with two parameters... the list and the empty list
16:34:12 <gwern> maybe you should use a more related datastructure like Seq or Set or something
16:34:23 <adamCS> and then go through the first list and if it's not already in the second list, stick it into it
16:34:29 <Axman6> > nub [1,2,3,4,5,4,3,2,1,3,4,2,1,1,3,4,7]
16:34:30 <lambdabot>   [1,2,3,4,5,7]
16:34:31 <adamCS> then eventually returns the second list
16:34:44 <ddarius> monochrom: Thinking is for losers.
16:34:51 <adamCS> but I gotta maintain the order of which is in the first list
16:34:53 <gwern> Seq gives you cheap appends and prepends, iirc
16:35:35 <ddarius> "Cheap" asymptotically.
16:35:37 <monochrom> @src nub
16:35:38 <lambdabot> nub = nubBy (==)
16:35:41 <monochrom> @src nubBy
16:35:42 <lambdabot> nubBy eq []             =  []
16:35:42 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:36:07 <gwern> ddarius: sure, but at least you don't have to worry about covering your asymptotes!
16:36:07 <monochrom> that shows you how to avoid both "append" and reverse
16:36:18 <dxq> adamCS: n * n (appending n times)  vs. n + n (prepend n times + reverse)
16:36:26 <monochrom> and that is what I mean by "think straight"
16:37:08 <monochrom> if you prefer to use a helper that works on two lists, that can be arranged too
16:37:09 <adamCS> ok I understand you dxq thanks. but monochrom... what? I've never seen @src before. Doubt I'd be allowed use it
16:37:36 <gwern> adamCS: oh, anyone's allowed to use it. it's for anyone in #haskell
16:37:40 <gwern> lambdabot doesn't discriminate
16:37:46 <gwern> @vixen do you, girl?
16:37:47 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
16:37:49 <Axman6> give it a go!
16:38:04 <dxq> O.o
16:38:04 <adamCS> ha... I mean I can't use something we haven't come to in class yet
16:38:06 <Axman6> ha!
16:38:15 <dxq> adamCS: @src is just a lambdabot command
16:38:49 <adamCS> haven't even heard of lambabot (don't kill me)
16:38:55 <Axman6> adamCS: sure, but does the idea make sense? you first take the first element of the list, and then remove all elements equal to that element from the rest of the list, and then recursively call yourself on the filtered list
16:39:24 <Axman6> adamCS: lambdabot is just our channel bot (it's also in lots of other channels)
16:39:33 <gwern> lambdabot is the crowning achievement of haskell programmers - an IRC bot which sort of works
16:39:35 <Axman6> > 4^2309347
16:39:37 <lambdabot>   272140548618152397108597820318697212575165989050945791621636947518609476819...
16:39:39 <gwern> who says haskell is impractical and academic?!
16:39:41 <adamCS> ok now that you say it like that I can do that
16:39:42 <Phyx-> wow.. lambdabot is racist... :P
16:39:49 <Phyx-> gwern: 99% of the world :P
16:39:54 <adamCS> but I'd have to come to the solution myself you know
16:39:58 <gwern> Phyx-: we're bad influences on her
16:40:05 <Axman6> i doubt 99% of the world has heard of haskell
16:40:18 <sipa> gwern: no, 0.99% of the world says that haskell is impractical and academic
16:40:18 <kmc> yeah, @vixen was removed because it said something offensive.  now we have @nixon
16:40:22 <Phyx-> Axman6: they implicitly fall into the category of thinking it's academic
16:40:24 <adamCS> so a list comprehension nested in another list comprehension is out of the question yeah?
16:40:25 <sipa> the other 99% haven't heard from it
16:40:29 <adamCS> just wondering
16:40:29 <Tyr42> @vixen
16:40:30 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
16:40:30 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
16:41:02 <Phyx-> gwern: aye, it needs some sensitivity training :P
16:41:02 <Axman6> adamCS: i don't think you can implement nub using just a list comprehension
16:41:08 <kmc> apparently casual racism and epic-league political fraud is less offensive than female masturbation
16:41:20 <adamCS> Axman6: ah ok thanks
16:41:26 <gwern> kmc: than what?
16:41:34 * gwern apparently missed an interesting kerfluffle
16:41:40 <kmc> 's why @vixen was removed iirc
16:41:44 <Phyx-> kmc: what makes the female variant so special? :P
16:41:54 <Axman6> hmm, what's the complexity of nub? is it O(n^2)?
16:41:59 <JoeyA> Yes
16:42:00 <sipa> yes
16:42:02 <JoeyA> yes
16:42:06 <Phyx-> no
16:42:12 <Axman6> (as much as that question makes sense in a lazy language)
16:42:15 <Phyx-> <-- goes against the trend
16:42:33 <monochrom> using "append" to implement nub will make it Θ(n^3)
16:42:48 <Phyx-> @nub
16:42:49 <lambdabot> Maybe you meant: bug run
16:42:52 <Phyx-> @src nub
16:42:53 <lambdabot> nub = nubBy (==)
16:43:06 <kmc> Phyx-, less acceptable in traditionally patriarchal societies
16:43:08 <JoeyA> You can write an Ord version of nub by sorting the list, then grouping and picking off the heads.  If you want it lazy like the original nub, you can use Data.Set to keep track of the items that have been encountered.
16:43:15 <Axman6> > let nub = toList . fromList in nub [1,2,5,3,2]
16:43:16 <lambdabot>   Not in scope: `toList'
16:43:20 * kmc is waaaaay off topic
16:43:26 <Axman6> > let nub = Set.toList . Set.fromList in nub [1,2,5,3,2]
16:43:26 <sipa> @let mynub (x:xs) = x : mynub [ y | y <- xs, y /= x ]
16:43:27 <lambdabot>   Not in scope: `Set.toList'Not in scope: `Set.fromList'
16:43:27 <lambdabot>  Defined.
16:43:31 <gwern> Set.toList . Set.fromList is pretty neat, I've always thought
16:43:40 <sipa> > mynum [1,2,3,2,3,4,2,3,4,5]
16:43:41 <lambdabot>   Not in scope: `mynum'
16:43:44 <sipa> > mynub [1,2,3,2,3,4,2,3,4,5]
16:43:46 <lambdabot>   [1,2,3,4,5*Exception: <local>:11:0-47: Non-exhaustive patterns in function ...
16:43:48 <Axman6> gwern: yeah =)
16:43:50 <c_wraith> gwern: that won't work for infinite lists
16:44:09 * kmc likes @vixen and @nixon and thinks both should stay, but would rather lose both than see an implicit endorsement of racism over sexytimes
16:44:12 <gwern> c_wraith: funnily enough, I don't actually process many infinite lists
16:44:13 <c_wraith> for infinite lists you'd want like a scanl
16:44:27 <c_wraith> no, scanl wouldn't work
16:44:27 <Phyx-> hahahha, sexytimes
16:44:29 <Axman6> yeah, depends on your usage whether to use nub or toList . fromList
16:44:32 <gwern> (my lists tend to be finite, of some length or other)
16:44:56 <ddarius> > scanl (+) 0 [0..]
16:44:57 <lambdabot>   [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,25...
16:45:12 <c_wraith> ddarius: scanl doesn't work as a filter.  You really want an accumulating filter
16:45:15 <adamCS> thanks for the help guys... bedtime
16:47:06 <c_wraith> also, nub beats Ord-based implementations if the number of distinct elements in the list is low
16:47:14 * hackagebot system-uuid 2.1.1 - Bindings to system UUID functions.  http://hackage.haskell.org/package/system-uuid-2.1.1 (JasonDusek)
16:47:48 <Phyx-> is hackage broken? the automatic doc generating part
16:48:10 <periodic> Phyx-: automatic?
16:48:30 <gwern> Phyx-: it's on a batch, sure enough time has passed?
16:48:43 <periodic> aah.
16:49:13 <hpaste> “Joey Adams” pasted “My lazy Ord-nub” at http://hpaste.org/54411
16:49:22 <gwern> hackage really should build on upload. more time has been wasted asking 'where's my haddocks' than was ever saved by batching the builds
16:50:15 <Phyx-> gwern: yeah, i get an error that 'haddock >=2.7.2
16:50:16 <Phyx-> '
16:50:19 <Phyx-> is missing
16:50:42 <gwern> Phyx-: oh. that's different, I have no idea what that is
16:51:06 <JoeyA> Has anyone made a Hackage module with an Ord version of nub?  I did see one once, but it assumes the list is sorted already.
16:51:45 <Phyx-> gwern: and i got that after like a week, before that nothing at all
16:55:41 <dylex> JoeyA: seems like there should be a Set function that inserts and tells you whether it was there already :: a -> Set a -> Maybe (Set a) or something -- potentially twice as fast?
16:57:55 <DukeDave> Anyone: "Could not find module `Language.Haskell.TH.Type'"   ?
16:58:01 <DukeDave> Is that some special import?
16:58:11 <DukeDave> I can't find any references on the 'net
16:59:28 <JoeyA> dylex: I could look, but I'm usually disappointed when I look for fancy ways to combine operations like that.
16:59:37 <c_wraith> DukeDave: that lacks a bit of context
17:00:25 <c_wraith> DukeDave: are you installing something that's giving that error message?  running code from some web site?
17:00:46 <jessopher_> ghci? building a package?
17:01:10 <rwbarton> Language.Haskell.TH.Type looks like a type, not a module...
17:01:30 <jessopher_> that would make sense
17:01:52 <DukeDave> It's some code I'm working on
17:01:59 <rwbarton> okay
17:02:03 <DukeDave> And the person who wrote it is afk, I just wondered if it was a known module
17:02:07 <DukeDave> Because I've never heard of it..
17:02:07 <rwbarton> where you see the line "import Language.Haskell.TH.Type", delete it :P
17:02:15 <c_wraith> looks like it's not a module.
17:02:47 <DukeDave> rwbarton: Surprisingly, that works :/
17:03:33 <DukeDave> Oh, no, there it goes...
17:04:33 <DukeDave> Oh, it's: import Language.Haskell.TH.Type (typeOf)
17:04:58 <c_wraith> ...  what?
17:05:04 <c_wraith> that's really confusing
17:05:13 <c_wraith> typeOf is usually from Data.Typeable
17:05:16 * DukeDave wonders if it's some merge fail
17:05:24 <strager> I want something like foldl, but with a state monad.  What do?  Like, foldl (execState . transformMyStuff) initialState [a,b,c] => execState (transformMyStuff c) $ execState (transformMyStuff b) $ execState (transformMyStuff a)
17:05:39 <rwbarton> maybe this is from the newfangled more-typed-TH?
17:05:47 <gwern> ' I've got this Ph.D. languages intern whose a big Haskell fan, and [surprisingly] a big Scheme fan, and an ML fan. [But especially Haskell.] He knows functional programming, he knows type systems. I mean, he's an expert.  He looked at Scala yesterday, and he told me: "I'm finding this rather intimidating."'  http://steve-yegge.blogspot.com/2008/06/rhinos-and-tigers.html <-- I wonder if that was komatsu
17:06:12 <c_wraith> strager: there's foldM
17:06:31 <strager> I think you are my saviour.
17:06:54 <DukeDave> rwbarton: Not sure if joking?
17:07:02 <rwbarton> neither am I
17:07:20 <c_wraith> @hoogle foldM
17:07:20 <rwbarton> in any event, Language.Haskell.TH.Type, if it exists, seems to be something specific to your environment
17:07:20 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:07:20 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
17:07:20 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
17:07:52 <rwbarton> DukeDave: (I was referring to this: http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal)
17:08:26 <rwbarton> (but it was total speculation and I'm not sure that proposal is implemented in any form yet)
17:17:12 <int80_h> I have a two lists of integers. [1,2,3] [4,5,6]. What is an idiomatic way to generate another list [1+4,2+5,3+6]?
17:17:40 <JoeyA> > zipWith (+) [1,2,3] [4,5,6]
17:17:41 <lambdabot>   [5,7,9]
17:17:53 <JoeyA> int80_h: ^
17:17:56 <rwbarton> > zipWith (+) [1,2,3] [4,5,6] :: [Expr]
17:17:58 <lambdabot>   [1 + 4,2 + 5,3 + 6]
17:18:08 <irene-knapp> haha!
17:18:11 <irene-knapp> cute trick
17:19:20 <int80_h> heh
17:19:35 * ddarius finds someone that is a "big Haskell fan" and an "ML fan" more surprising than someone whose a "big Haskell fan" and a "big Scheme fan."
17:20:06 <ddarius> s/whose/who's/
17:21:13 <shachaf> > let f :: Expr -> Bool; f 0 = True; f _ = False in f 0
17:21:14 <lambdabot>   True
17:21:15 <shachaf> > let f :: Expr -> Bool; f 0 = True; f _ = False in f 1
17:21:16 <lambdabot>   False
17:21:20 <shachaf> > let f :: Expr -> Bool; f 0 = True; f _ = False in f (0+0)
17:21:21 <lambdabot>   True
17:21:48 <ion> > (0+0 :: Expr) == 0
17:21:49 <lambdabot>   True
17:21:59 <shachaf> Hm.
17:22:04 <ddarius> shachaf is mystified.
17:22:13 <ion> > (0+x :: Expr) == x
17:22:14 <lambdabot>   False
17:22:15 <rwbarton> > 0+0 :: Expr
17:22:17 <lambdabot>   0 + 0
17:22:25 <ion> > (0+x :: Expr) == 0+x
17:22:26 <lambdabot>   True
17:22:32 <ion> > (0+0+x :: Expr) == 0+x
17:22:33 <lambdabot>   False
17:22:37 <shachaf> I suppose it reduces Exprs when comparing for equality.
17:22:41 <ion> > ((0+0)+x :: Expr) == 0+x
17:22:42 <lambdabot>   False
17:23:22 <sipa> > ((0+0)+x :: Expr) == x
17:23:24 <lambdabot>   False
17:23:37 <sipa> > (0+0)+x :: Expr
17:23:38 <lambdabot>   0 + 0 + x
17:23:48 <ion> > (x+(0+0) :: Expr) == x+0
17:23:48 <xhazk> "They" just want you to think lambdabot is a bot. It's actually a hyper-intelligent enslaved alien locked in cryogenic stasis. "They" are using its brainwaves to power the IRC "bot." It's true... the TV told me so.
17:23:49 <lambdabot>   False
17:24:11 <sipa> xhazk: you shouldn't believe everything the TV tells you
17:24:17 <sipa> that's so 20th century
17:24:23 <shachaf> sipa: The TV told me that. :-(
17:24:24 <rwbarton> I like to read lambdabot's last message as a reply to xhazk.
17:24:26 <sipa> now everything that wikipedia says is true
17:24:34 <shachaf> rwbarton++
17:24:47 <shachaf> Particularly the timing of it.
17:24:48 <sipa> rwbarton: :D
17:24:49 <ddarius> rwbarton: Wasn't it?
17:24:57 <xhazk> that was funny timing
17:30:06 <ddarius> Dutch
17:37:40 <shachaf> Nederlands?
17:39:13 <mapreduce> Holandes
17:42:15 * hackagebot gloss 1.5.2.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.5.2.1 (BenLippmeier)
18:01:00 <tswett> Calling out to C from Haskell has something like a constant and small overhead, right?
18:01:16 <shachaf> Constant as opposed to what?
18:01:49 <tswett> As opposed to depending on... you're right, I can't imagine what it would depend on.
18:01:51 <shachaf> It can be a pretty small overhead, particularly if you don't care about the C code blocking, or about calling back into Haskell from C.
18:02:14 <tswett> Let's say I don't care about calling back into Haskell from the C.  Right now, I'm mostly asking out of curiosity.
18:02:51 <shachaf> The GHC FFI is pretty good as FFIs go, so I'm told.
18:03:12 <tswett> Any idea how big the overhead is?  Something like a hundred nanoseconds, I vaguely remember hearing.
18:03:24 <shachaf> You could benchmark it.
18:03:27 <kmc> you really really really really really should not use 'foreign import unsafe' unless you have a really really really really really good reason
18:03:40 <kmc> i have benchmarked it
18:03:41 <kmc> sec
18:04:34 <kmc> http://hpaste.org/51264
18:05:10 <kmc> see also http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
18:05:19 <ddarius> 12ns is just too damn long for me.
18:05:28 <mike-burns> It's possible.
18:06:03 <shachaf> kmc: Did you hear about how GHC's recompilation checker is going to be getting improvements, by the way?
18:06:08 <tswett> So the safe calls took about 150 nanoseconds on average, and the unsafe calls more like 15?
18:06:09 <kmc> no, what now?
18:06:35 <kmc> scroll down for the results with -threaded
18:06:42 <tswett> Oh.
18:06:49 <kmc> there it's more like 250 vs 12
18:06:57 <tswett> The safe ones were more like 250 on average, and the unsafe ones were still roughly 15.
18:07:02 <kmc> anyway, these are basically constant additive overhead
18:07:11 <tswett> So yeah, 250 nanoseconds for a safe call if you have threading.  Not bad.
18:07:21 <kmc> so if your C function takes even a few μs, it becomes insignificant
18:07:29 <kmc> meanwhile the potential for bugs with 'unsafe' is large
18:08:03 <tswett> It sounds like 'unsafe' is only worth it if your C function is tiny.
18:08:08 <kmc> yeah
18:08:49 <kmc> well, i can contrive some situations where it's otherwise
18:08:58 <kmc> but basically yes
18:09:17 <shachaf> But think of those ~240 ns!
18:10:20 <shachaf> kmc: https://plus.google.com/107890464054636586545/posts/bzkiyuDVz5H
18:11:25 <tswett> Now, the docs say that STM will do some error thingy if you try to do an unsafePerformIO'd action inside an STM transaction.
18:11:25 <kmc> usually end user utility is roughly linear with performance, in a region around what you'd consider a feasible solution
18:11:35 <kmc> but suppose aliens land on earth and demand to know the Ramsey number R(5,5) in one month or they will blow up the planet
18:11:42 <tswett> Does that also apply with foreign functions that have been declared pure?
18:11:43 <kmc> and your code is only just fast enough if you use 'foreign import unsafe'
18:12:20 <mike-burns> Are you a bad enough dude to use 'foreign import unsafe'?
18:12:23 <kmc> tswett, hmm, that's a very good question
18:12:41 <dxq> i think you'll find him to be quite a bad dude.
18:12:52 * kmc used foreign import unsafe once
18:13:03 <tswett> Also, how does calling Haskell from C work?  Do you convert a Haskell function to a C function pointer?
18:13:09 <kmc> you can
18:13:14 <kmc> or you can just use 'foreign export'
18:13:57 <shachaf> foreign expert
18:14:03 * kmc wrote 3 paragraphs about why it was okay to use 'unsafe'
18:14:14 <tswett> I take it 'foreign export' makes the compiler output code that can be linked with nicely.
18:14:23 <kmc> yes
18:14:24 <shachaf> kmc: I didn't see any paragraphs for your void f() {} function!
18:15:14 <ddarius> foreign wrapper
18:15:48 <kmc> tswett, with GHC it will also generate some .c. and .h files
18:16:16 <tswett> Now, to write a bytecode interpreter in Haskell.  I... have no idea what this will look like.
18:16:32 <kmc> what bytecode
18:16:38 <roconnor> kmc: UM
18:17:05 <tswett> Let's see.  There's a stack and a heap, and [B[BSome arbitrary ma[BSome arbitrary made-up bytecode.
18:17:12 <tswett> My irssi is showing, isn't it.
18:17:25 <kmc> is this related to the FFI questions?
18:17:53 <tswett> Only vaguely.  The bytecode interpreter and the FFI stuff might end up in the same application.
18:18:12 <tswett> roconnor: is there a bytecode called UM?
18:18:20 * ddarius would not recommend writing anything beyond a proof-of-concept bytecode interpreter in Haskell.
18:18:30 <roconnor> tswett: yep; it runs on sandstone.
18:18:47 <tswett> Indeed.  But I never write anything beyond a proof-of-concept anything in anything.  }:P
18:19:03 <mike-burns> Is Haskell used for anything besides proof-of-concept?
18:19:07 <kmc> with GHC's 'foreign export' you need to compile that foo_stub.c file into your executable
18:19:30 <barnesville> hi all, I want to write an reverse order function, which takes a list and reverse it. My first version is reverse_order (x:xs) = (reverse_order xs) : x, but the interpreter warns me that the first element of : should be an element. So I change it to reverse_order (x:xs) = (reverse_order xs) ++ [x]
18:19:35 <kmc> the easiest way is to compile the whole project, Haskell and C, with ghc or cabal
18:20:03 <AfC> mike-burns: I wondered that myself at first, but the answer is most emphatically "yes".
18:20:28 <MatrixFrog> barnesville: i think that's correct, though not necessarily that efficient. does it seem to work?
18:20:35 <barnesville> It works fine but I expected something like [1..9] -> [9,[8,[7...]] , why does it work?
18:20:53 <MatrixFrog> because ++ takes two lists
18:20:55 <roconnor> tswett: http://www.boundvariable.org/task.shtml
18:21:05 <roconnor> tswett: http://www.boundvariable.org/um-spec.txt
18:21:09 <kmc> ddarius, why not write a bytecode interpreter in haskell
18:21:10 <MatrixFrog> in fact, [9,[8,...]] isn't a valid expression
18:21:44 <tswett> barnesville: well, because [a,b,c] ++ [d,e,f], for example, is [a,b,c,d,e,f].  The ++ operator combines the lists into one that way.  It doesn't give you [a,b,c,[d,e,f]].
18:21:44 <MatrixFrog> you can either have a list of numbers like [9,8...] or a list of LISTS of numbers like [[9],[8]...]
18:21:54 <mike-burns> > [1,2,3] ++ [4,5,6]
18:21:55 <lambdabot>   [1,2,3,4,5,6]
18:21:59 <MatrixFrog> @src (++)
18:22:00 <lambdabot> []     ++ ys = ys
18:22:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:22:01 <lambdabot> -- OR
18:22:01 <lambdabot> xs ++ ys = foldr (:) ys xs
18:22:27 <barnesville> Oh I see, Thanks!
18:23:05 <MatrixFrog> @info (++)
18:23:05 * MatrixFrog always does the lambdabot commands wrong
18:23:06 <lambdabot> (++)
18:23:26 <Axman6> barnesville: that's a terrible way to implement reverse by the way. it's got O(n^2) complexity. try thinking about what would happen if you started with an empty list, and added elements from your list to the front of it
18:23:34 <shachaf> MatrixFrog: It could be a valid expression.
18:23:51 <Axman6> for Num [a]
18:23:57 <mike-burns> The proper way to implement reverse is: reverse_order = reverse
18:24:09 <mike-burns> Anything else is just learning the language.
18:24:35 <MatrixFrog> @shachaf okaaaay you got me there
18:24:35 <lambdabot> Unknown command, try @list
18:24:46 <mike-burns> This ain't Twitter.
18:24:56 <shachaf> I demand that someone add @shachaf to lambdabot.
18:25:07 <ddarius> kmc: It will likely be really slow unless you spend a lot of time fighting against Haskell.  Haskell also makes the kind of things you'd want to do difficult, e.g. controlling memory layout.  Haskell's a great language for making a program that makes a bytecode interpreter.
18:25:21 <MatrixFrog> for a certain definition of the word "implement" :)
18:25:57 <tswett> ddarius: did you mean to say that to me?
18:26:01 <kmc> okay
18:26:05 <ddarius> tswett: No.
18:26:14 <kmc> i don't know what 'bytecode interpreter' means exactly, it seems to be a fairly vague term
18:26:14 <MatrixFrog> name-colon, not at-name. noted.
18:26:19 * tswett nods.
18:26:28 <kmc> you seem to be interpreting it in a narrow way which implies that performance is a primary concern
18:26:30 <kmc> which is fair enough
18:26:30 <mike-burns> MatrixFrog: You can type part of a name then press TAB.
18:26:56 <mike-burns> If performance wasn't a concern then it'd just be a proof-of-concept.
18:27:08 <MatrixFrog> mike-burns: that depends on my IRC client probably? but in any case it does seem to work with pidgin, thanks!
18:27:15 <kmc> mike-burns, yeah,  that's why nobody writes any software in Perl, PHP, Python, or Ruby
18:27:35 <mike-burns> kmc: Hah, you've caught me in something I say all the time. Touch'e, sir.
18:27:41 <tswett> But yeah, a stack and a heap.  And if you look at the heap wrong, it might spontaneously start executing.  Let's... you know, let's leave out that last feature for now.
18:28:21 <kmc> mike-burns, you seem to have dropped a word, i said 'primary concern', you said 'concern'
18:28:41 <kmc> obviously if performance is not a concern at all, then 'while(1);' is a fine implementation
18:28:48 <kmc> let's ignore such pathological cases
18:28:53 <mike-burns> Let's.
18:28:56 <gwern> @quote pathological
18:28:57 <lambdabot> No quotes match. Are you on drugs?
18:29:00 <gwern> drat
18:29:05 <shachaf> There's always "while(2);".
18:29:10 <kmc> do you really believe that software development is always dominated by performance as opposed to, say, correctness, security, ease and time of development, ease of modification
18:29:30 <kmc> and somehow this has remained the same even though computers have become literally a million times faster and the things we do with them are largely the same?
18:29:33 <mike-burns> kmc: I'm a paid Ruby dev. So obviously I feel that performance doesn't matter.
18:29:39 <Axman6> shachaf: does that have O(2\infty) complexity?
18:29:56 <ddarius> kmc: For most byte code interpreters, you don't really get any of those benefits by using Haskell as opposed to, say, C.
18:30:02 <kmc> ddarius, security?
18:30:19 <kmc> adobe flash is a bytecode interpreter written in C
18:30:26 <ddarius> kmc: You may get security, unless you start fiddling with pointers.
18:30:30 <barnesville> Well I just reading the real world haskell, and it tells me that you should write the code straightfaward, and let the compiler to do the optimization :)
18:30:40 <mike-burns> Yeah!
18:30:55 <kmc> barnesville, "the code" = "an efficient algorithm for your task"
18:31:13 <kmc> GHC isn't smart enough to turn bad algorithms into good ones in general
18:31:42 <mike-burns> Imagine how long compilation would take if it could do that, though.
18:31:51 <kmc> mike-burns, well, GHC is self-hosting, so...
18:32:06 <ddarius> Also, there are plenty of ways to lose security without the worry of buffer overflows, though Haskell is pretty good at avoiding/minimizing many of those.
18:32:09 <shachaf> kmc: That doesn't mean it could make it fast.
18:32:30 <mike-burns> `ghc --make', go away for a week. Bam, performant and type-safe code, for cheap!
18:32:31 <shachaf> Some humans are reasonably good at converting bad algorithms to good algorithms, but it still takes them a long time.
18:32:51 <kmc> more humans are good at converting good algorithms to bad ones
18:33:56 <ddarius> Damn you jQuery.
18:38:39 <kmc> mike-burns, sorry, I'm excessively twitchy about people who elevate performance above all
18:38:54 <mike-burns> Understood, and I'm on your side.
18:39:43 <Peaker> kmc: for some projects performance is the primary concern...
18:39:47 <Peaker> (I'm working on one)
18:40:04 <kmc> Peaker, yes
18:41:07 <kmc> did i say otherwise?
18:43:04 <Peaker> I don't know, I just chimed in at this line :)
18:43:08 <kmc> ok
18:43:51 <kmc> it's a minority of projects which have intense performance requirements
18:45:09 <ddarius> It's not a minority that have performance requirements.
18:45:30 <mike-burns> I demand data on this from either of you.
18:45:53 <kmc> ddarius's statement is obviously true
18:46:01 <kmc> mine would demand data and I don't have any
18:46:29 <kmc> but I will make the related claim that languages which cater to ease of solving problems tend to catch on much quicker than languages which cater to performance
18:47:01 <mike-burns> Languages with killer apps (frameworks, libraries, OS integration) catch on the fastest.
18:47:09 <kmc> there are still few alternatives to C in the high-performance space
18:47:33 <kmc> meanwhile there are tons of high-level dynamic languages which are used through terribly slow interpreters
18:47:48 <ddarius> kmc: Yes, but more languages doesn't mean more catching on.
18:47:52 <kmc> and they are popular and people use them to solve problems of great significance and make billions of dollars
18:48:09 <jessopher_> performance requirements are not the same as performance requirements that compete with c though
18:48:17 <kmc> indeed
18:48:43 <barnesville> another problem about type signature, does my_func :: [a]->[a]->[a] means a function takes two lists as argument and return a list?
18:48:53 <kmc> barnesville, informally, yes
18:49:05 <kmc> formally,  A -> B -> C  means  A -> (B -> C)
18:49:08 <rwbarton> also, the elements of all the lists involved are of the same type
18:49:20 <kmc> so [a] -> ([a] -> [a])  takes a list, and returns a function which takes another list
18:49:32 <kmc> but the syntax encourages you to think of this like it's taking two lists
18:49:36 <Axman6> which returns a list
18:50:04 <ddarius> kmc: The syntax doesn't really encourage that.
18:50:09 <mike-burns> Haskell idiom is myFunc, not my_func . By the way.
18:50:47 <Axman6> and [a] -> [a] -> [a]
18:51:07 * mike-burns grabs some popcorn and gets comfy to watch ddarius and kmc interact.
18:53:15 <jessopher_> and then they fail to deliver!
18:53:49 <mike-burns> Just when it was getting good---a cliffhanger!
18:54:40 <gwern> preflex: seen nomeata
18:54:41 <preflex>  nomeata was last seen on #darcs 3 days, 8 hours, 58 minutes and 16 seconds ago, saying: Heffalump: I thought it was darcs2.
18:56:16 <jessopher_> But yeah, people have performance requirements, but more common than that are people with performance anxieties. Pun both intended and not.
18:56:40 <napping> I hear the original design goal for Fortran was to be at least half as fast as assembly
18:58:43 <theddy> Am I
18:59:47 <theddy> Ooops
19:00:00 <monochrom> Perhaps.
19:00:33 <theddy> Short answer is yes
19:01:34 <theddy> Is it possible to write an instance of Foldable for a datatype that is rank-2 polymorphic?
19:02:07 <theddy> I.e. something like "data T a b = ..."
19:02:33 <theddy> (not sure if thats how to say it)
19:02:46 <shachaf> theddy: Well, it's the wrong kind.
19:02:58 <shachaf> You might be able to make (T a) an instance of Foldable, though.
19:02:58 <dmwit> (rank-2 polymorphic is not the right way to say it)
19:03:01 <PiRSquared17> Hmm... no Xcode
19:03:21 <shachaf> Also, yes, rank-2 polymorphism sounds fancy but means something else. :-)
19:03:23 <PiRSquared17> "gcc not installed"
19:03:51 <barnesville> Thank you, but I still can't get it. myDuplicate result [] = result \n myDuplicate result (x:xs) = myDuplicate ([x]++result++[x]) xs , and the result couldn't be printed. I guess ([x]++result++[x]) makes the argument into tuple, so the result turns to be wrong.
19:04:10 <theddy> shachaf:  Yes, I would ideally like to make it Foldable with respect to a or b
19:04:38 <dmwit> > let myDuplicate result [] = result; myDuplicate result (x:xs) = myDuplicate ([x] ++ result ++ [x]) xs in myDuplicate [1..3]
19:04:39 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
19:04:40 <lambdabot>    arising from a use ...
19:04:41 <rwbarton> > let ...
19:04:43 <lambdabot>   <no location info>: parse error on input `...'
19:04:46 <dmwit> > let myDuplicate result [] = result; myDuplicate result (x:xs) = myDuplicate ([x] ++ result ++ [x]) xs in myDuplicate [] [1..3]
19:04:48 <lambdabot>   [3,2,1,1,2,3]
19:04:53 <dmwit> barnesville: Looks fine to me.
19:05:23 <dmwit> > ap (++) reverse [1..3]
19:05:24 <lambdabot>   [1,2,3,3,2,1]
19:05:47 <dmwit> ap (flip (++)) reverse [1..3]
19:05:50 <rwbarton> probably the problem you had the first time is the same problem barnesville has
19:05:51 <dmwit> > ap (flip (++)) reverse [1..3]
19:05:53 <lambdabot>   [3,2,1,1,2,3]
19:06:04 <dmwit> rwbarton: That's my guess, too.
19:06:13 <rwbarton> barnesville: the result of *what* couldn't be printed?
19:06:39 <PiRSquared17> > @pl \x y z ->  z (f x y) x y f
19:06:40 <lambdabot>   <no location info>: parse error on input `@'
19:06:44 <PiRSquared17> @pl \x y z ->  z (f x y) x y f
19:06:44 <lambdabot> flip flip f . (flip .) . join . (flip .) . (flip =<< ((flip . flip id) .) . f)
19:06:52 <PiRSquared17> @type \x y z ->  z (f x y) x y f
19:06:53 <lambdabot> forall t t1 t2 a t3. (SimpleReflect.FromExpr (t -> t1 -> t2), SimpleReflect.FromExpr a) => t -> t1 -> (t2 -> t -> t1 -> a -> t3) -> t3
19:07:00 <barnesville> like this GHC.Show.Show ([t] -> [t])
19:07:21 <dmwit> barnesville: Yeah, don't forget to apply myDuplicate to *two* arguments. =)
19:07:33 <dmwit> (Since you defined it as a set of equations each taking two arguments.)
19:07:58 <dmwit> For convenience, you might like to define something like
19:07:59 <barnesville> dmwit, you're right
19:08:03 <dmwit> realDuplicate = myDuplicate []
19:08:36 <barnesville> the lambdabot is awesome!
19:08:40 <dmwit> rwbarton++
19:14:57 <Sgeo> Grah, why is there no nice way to get haskell-platform working on Ubuntu?
19:16:07 <Ke> why would someone want haskell platform
19:16:19 <dxq> Ke: to write haskells
19:16:28 <Ke> that's just silly
19:16:45 <dmwit> Sgeo: http://packages.ubuntu.com/search?keywords=haskell-platform <- looks like a pretty nice way
19:17:03 * ddarius wants or-patterns right now.
19:17:20 <Sgeo> dmwit, isn't that out of date or something?
19:17:30 <Sgeo> Or otherwise annoying due to cabal issues?
19:17:44 <ddarius> Though they wouldn't really work for what I want.
19:18:18 <dmwit> 2011.2.0.1 is the latest release, and both oneirec and precise offer it.
19:18:51 <dmwit> And cabal can handle installations that come from your package manager just fine.
19:19:04 <dmwit> So this sounds a bit like FUD.
19:19:20 <Sgeo> Hmm, ok
19:19:41 <Sgeo> But after installing platform, should I avoid using package manager for more stuff?
19:20:13 <Ke> o_O
19:20:15 <Clint> no
19:20:44 <napping> If you want current versions of things you probably want to install packages with cabal
19:22:51 <Clint> the .debs will give you consistent dependencies
20:02:32 <Spaceghost> zfetheItalian: sup brah
20:02:50 <zfetheItalian> Spaceghost, I am the zfe the Italian
20:02:55 <zfetheItalian> And I always keep my injects tight
20:02:58 <zfetheItalian> Zerg macro king
20:03:06 <zfetheItalian> 70 drones at the 8 minute mark
20:03:16 <zfetheItalian> Remaxingon pure ultralisk
20:03:35 <Spaceghost> SC junky.
20:04:17 <dxq> you're no nestea
20:06:08 <zfetheItalian> dxq, nestea's injects are crap man.
20:06:15 <zfetheItalian> 100 energy queen at 13 minutes.
20:06:21 <zfetheItalian> Mechanics aren't exactly nestea's strength
20:06:35 <zfetheItalian> It'smore like he always manges to have exactly the magic number of drones.
20:06:50 <zfetheItalian> And well, he never makes a bad decision it seems
20:06:50 <zfetheItalian> except versus Naniwa
20:07:05 <zfetheItalian> But like, at Providence, 99% of the players who looked scary only looked scary because they were eco cheesing galore.
20:07:08 <irene-knapp> oh
20:07:10 <irene-knapp> Starcraft
20:07:11 <irene-knapp> I was like
20:07:13 <zfetheItalian> Leenock was the only player who looked scary without that.
20:07:13 <irene-knapp> wth is this
20:07:24 <zfetheItalian> Like, Mvp
20:07:29 <zfetheItalian> 3 orbitals on ONE barracks
20:07:32 <zfetheItalian> the fuck is that
20:07:34 * kmc plays terran, lifts up all buildings immediately, flies in circles for duration of game
20:07:38 --- mode: ChanServ set +o copumpkin
20:07:48 <zfetheItalian> Of course you're going to die to a 6gate all in, 4 bunkers, depot wall, doesn't matter if you went such an eco cheese.
20:07:50 --- mode: copumpkin set +b zfetheItalian!*@*
20:07:50 --- kick: zfetheItalian was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
20:07:55 <kmc> no warning?
20:07:56 --- mode: copumpkin set +b *!~anhedonia@unaffiliated/spaceghost
20:07:56 --- kick: Spaceghost was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
20:08:14 <irene-knapp> I love that kick message
20:08:23 <copumpkin> my IRC client is pretentious
20:09:01 <copumpkin> kmc: not when two random people start talking to each other about off-topic things in a channel
20:09:04 <irene-knapp> copumpkin: let us adjourn to -blah and discuss object file stuff
20:09:10 <copumpkin> it's a pretty common trollish thing to do :P
20:09:11 <irene-knapp> yeah, they had both just joined within moments
20:09:13 --- mode: copumpkin set -o copumpkin
20:09:16 <shachaf> copumpkin: Fortunately, so is the desired environment.
20:09:24 <irene-knapp> they clearly knew each other but nobody else knew them
20:09:26 <shachaf> copumpkin: Trollish? I thought that's pretty much what this channel was.
20:09:39 <irene-knapp> and they were talking about freaking Starcraft :)
20:09:48 <shachaf> Cale does that.
20:09:56 <shachaf> Well, I suppose this particular case is a bit suspicious, though.
20:10:22 <kmc> starcraft is a fun game but it would be a lot more fun if it were implemented in haskell
20:10:26 <kmc> there, now i'm on topic
20:10:45 <shachaf> kmc: And supported scriptability instead of micromanagement?
20:10:57 <Eelis> wow, some pretty brutal off-topic banning there! #haskell, you pleasantly surprise me!
20:11:42 <irene-knapp> you're welcome
20:11:46 <napping> shachaf: that's what BWAPI bindings are for
20:11:50 <hmmmm> how would i find the minimum value of a list?
20:12:02 <shachaf> napping: Isn't scripting of any sort not Blizzard-condoned?
20:12:07 <kmc> > minimum [5,2,7]
20:12:07 <shachaf> hmmmm: minimum list
20:12:08 <lambdabot>   2
20:12:08 <copumpkin> Eelis: anytime
20:12:12 <napping> which cabal seems to lack
20:12:14 <thoughtpolice> kmc: totally on topic
20:12:20 <shachaf> I want an actual game that treats micromangement as a bad thing.
20:12:21 <hmmmm> would i be able to do it with foldr/foldl?
20:12:34 <shachaf> hmmmm: Yes, but why? You can use minimum.
20:12:37 <hmmmm> or is that impossible since i'd have to add in that value
20:12:48 <shachaf> You can do anything with foldr.
20:12:50 <napping> shachaf: nah, for the old one. Some people wanted to organize an AI contest and got official support
20:12:59 <hmmmm> how would i compute the minimum of a list then?
20:13:11 <hmmmm> foldr (min) 0 [4,2,5] is always going to be 0
20:13:14 <napping> hmmmm: you need a starting value for fold, so the question is what minimum does on an empty list
20:13:26 <shachaf> hmmmm: What's the minimum of an empty list?
20:13:32 <hmmmm> 0
20:13:37 <shachaf> It is?
20:13:40 <hmmmm> i think so...?
20:13:43 <hmmmm> is it not?
20:13:51 <shachaf> Isn't the minimum value of a list the smallest value that's in the list?
20:13:57 <hmmmm> *** Exception: Prelude.minimum: empty list
20:14:15 <napping> One option is to define your minimum to first match the list to see if it's empty or has a first element, and if it does you can use that as the starting value for a fold
20:14:23 <hmmmm> oh also
20:14:27 --- mode: ChanServ set +o copumpkin
20:14:29 <hmmmm> can i have duplicate elements in a list
20:14:34 <byorgey> hmmmm: you can't implement minimum *directly* with foldr, you need to do a bit of extra work to check for the empty list
20:14:35 --- mode: copumpkin set -bb zfetheItalian!*@* *!~anhedonia@unaffiliated/spaceghost
20:14:37 --- mode: copumpkin set -o copumpkin
20:14:47 <byorgey> hmmmm: try it and see
20:14:49 <hmmmm> yeah, thought so :)..
20:14:52 <hmmmm> hm
20:14:55 <hmmmm> okay, so how do i have a set?
20:15:02 <hmmmm> is there different syntax for a set?
20:15:15 <byorgey> hmmmm: take a look at Data.Set
20:15:18 <hmmmm> ok
20:15:28 <hmmmm> thankx
20:15:32 <byorgey> hmmmm: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Set.html
20:15:55 <hmmmm> i just started learning Haskell about an hour ago but i can tell it's really good :)!
20:16:34 <byorgey> hmmmm: great!  feel free to keep asking questions in here =)
20:18:18 <kmc> haskell looks better after 1 hour of learning than after 100 hours
20:18:34 <Ke> !
20:18:35 * Cale pretends those people weren't kicked for talking about starcraft, but rather kicked for saying stupid things about starcraft.
20:18:37 <Eelis> i have a question about record wild cards and a runtime error that looks compile-time diagnosable: http://codepad.org/JdlwApnz
20:18:52 <kmc> but it looks better still after 10,000 hours
20:18:55 <shachaf> kmc++
20:18:59 <irene-knapp> Cale: really, to me, the egregious nature of the behavior was that they didn't even introduce themselves
20:19:08 <Cale> yeah, that was weird
20:19:10 <kmc> <zfetheItalian> Spaceghost, I am the zfe the Italian
20:19:13 <irene-knapp> Cale: they just came in, sat down on the couch, helped themselves to beers out of our fridge
20:19:15 <kmc> looks like an intro to me
20:19:21 <shachaf> @remember kmc <kmc> haskell looks better after 1 hour of learning than after 100 hours <kmc> but it looks better still after 10,000 hours
20:19:22 <lambdabot> Done.
20:19:23 <kmc> the first few lines from zfe sounded like starcraft rap
20:19:27 <kmc> i tried to make them rhyme
20:19:43 <kmc> in fact I hoped we'd be witness to a starcraft-themed rap battle
20:19:45 <kmc> but it was not to be :/
20:19:52 <kmc> shachaf, you agree?
20:19:54 <irene-knapp> (by the way, who's stocking that fridge?  less beer, more Mike's Hard Lemonade, please.)
20:20:01 <irene-knapp> haha
20:20:03 <irene-knapp> that would have been neat
20:20:05 <Spaceghost> Yes, I want to declare me as innocent.
20:20:08 <zfetheItalian> irene-knapp, I am actually a regular idler here and I know some people here, I just never talk
20:20:14 <zfetheItalian> And I change my nickname roughly every 30 minutes
20:20:18 <kmc> less beer, more Coca Cola bottles filled with rum
20:20:23 <shachaf> kmc: Pretty much.
20:20:26 <Spaceghost> Greet a troll shouldn't something condened by capital punishment.
20:20:27 <irene-knapp> zfetheItalian: oh, you're back.  okay.  well, that's cool.
20:20:39 <shachaf> kmc: Well, I don't think I've done 10,000 hours of Haskell.
20:20:41 <byorgey> irene-knapp: since it is an imaginary fridge, we may suppose without loss of generality that it contains lots of everything.
20:20:48 <irene-knapp> byorgey: haha, okay then
20:20:52 <thoughtpolice> Cale: hahahahaha. i assume you kept up with providence, too :)
20:20:56 <kmc> shachaf, I'm not sure exactly where the low point is.  100 hours seemed like a legit order-of-magnitude estimate
20:20:56 <hmmmm> don't you mean, arbitrary fridge?
20:21:06 <hmmmm> how do i get the nth element from a list?
20:21:07 <shachaf> But people get these weird romantic notions about the language after they just kind of skim a guide, and I tend to find it kind of annoying.
20:21:11 <kmc> hmmmm, (xs !! n)
20:21:14 <hmmmm> ok
20:21:20 <shachaf> At least, some people I've talked to who were learning Haskell.
20:21:24 <kmc> hmmmm,  but you probably don't want to... lists aren't intended for random access
20:21:43 <shachaf> It feels like they're saying completely baseless praise about how wonderful it is rather than anything backed by evidence of some sort.
20:21:46 <kmc> it will traverse one element at a time from the beginning
20:21:48 <Cale> thoughtpolice: to some extent... I've been a little too busy to watch everything.
20:21:49 <hmmmm> ahh
20:21:52 * shachaf is the only one allowed to praise things baselessly.
20:21:53 <hmmmm> that's rather unfortunate
20:22:01 <hmmmm> is there any direct correlation to an array then?
20:22:09 <kmc> shachaf, yeah.  i try not to rain on the parades of enthusiastic beginners, but nudge them gently toward realistic expectations
20:22:11 <byorgey> hmmmm: no, but Haskell does have arrays as well
20:22:16 <kmc> hmmmm, there are other data structures for random access
20:22:19 <kmc> i recommend Data.Sequence
20:22:26 <kmc> arrays are a bit more cumbersome and special purpose
20:22:37 <hmmmm> ok
20:22:46 <kmc> Data.Sequence will handle most use cases of lists or arrays in a natural and efficient way
20:22:59 <byorgey> hmmmm: you miss the random access less than you might think.
20:23:00 <thoughtpolice> Cale: ah, understandable. i've been out of the tourney loop for the past 2 months or so, but i caught up on prov.
20:23:06 <kmc> see also Data.Map and Data.IntMap
20:23:06 <hmmmm> probably
20:23:28 <byorgey> many algorithms that would use an array in another language just iterate over the array in order anyway, in which case a list is perfectly fine
20:23:31 <shachaf> I think people who are knew to a subject have a tendency to parrot the opinions of experts that they trust to other people without really understanding them.
20:23:38 <shachaf> s/knew/new/ :-(
20:23:47 <shachaf> I don't know how that happened. Hmph.
20:24:07 <zfetheItalian> hmmmm, in practice, you almost never want to get the 'nth element of a list', more often than not you want to get them all.
20:24:13 <ddarius> "I don't now how that happened" would have been better.
20:24:23 <irene-knapp> haha
20:24:27 <zfetheItalian> If you want the 'nth element' mot of the time tuples and records are beter suited
20:24:32 <jessopher_> and in that respect, haskell is like pokemon
20:24:47 <kmc> shachaf, not sure if I've done 10,000 hours
20:24:48 <ddarius> id -- get all the elements of a list
20:24:53 <kmc> if so I can claim to be an Expert!
20:25:12 <ddarius> > 10000/365/24
20:25:13 <lambdabot>   1.1415525114155252
20:25:15 <kmc> i definitely had over 1,000 hours active on #haskell as of a while ago
20:25:19 <irene-knapp> Data.Jigglypuff
20:25:23 <shachaf> kmc: Hours doing #haskell are only worth 0.01-0.5 of hours doing Haskell. :-)
20:25:29 <kmc> sadly true
20:25:55 <shachaf> Looking at pre-2011 #haskell logs, I typed about 100,000 words into #haskell.
20:26:02 <kmc> but there are some hours of 'reading what other people say without saying anything' too
20:26:06 <ddarius> If I did ~6 minutes of Haskell every day since I started, I'd have 10,000 hours.
20:26:46 <dxq> zfetheItalian: nestea is in a slump :(
20:27:33 <ddarius> #haskell-blah
20:27:46 <kmc> yeah I am probably not to 10,000 hours yet
20:27:53 <shachaf> ddarius: That's a lot of days.
20:27:56 <kmc> since i only started 5.5 years ago or so
20:28:16 <kmc> that would imply spending 1/3 of waking hours thinking about haskell
20:28:19 <zfetheItalian> dxq, don't seduce me
20:28:28 <kmc> which... might be the case now, but not for the whole time in question
20:28:30 <shachaf> kmc: ...And...?
20:28:32 <zfetheItalian> I am under strict orders to obey.
20:28:34 <shachaf> Hah. OK.
20:28:44 <kmc> i've had Jobs and various Other Hobbies
20:28:56 <Cale> There are probably better channels than this one for talking about SC2. :P
20:29:06 <shachaf> Either my calculations are incorrect or ddarius is much older than I thought.
20:29:26 <thoughtpolice> 'Other Hobbies' => code words for 'i am the fed'
20:29:47 <shachaf> I think kmc was implying something about serotonin.
20:32:37 <ddarius> shachaf: Perhaps I meant 6 minutes an hour.
20:33:13 <shachaf> ddarius: Aha. That makes more sense.
20:38:51 <Eelis> looks like my issue wasn't specific to record wild cards. turns out GHC has some deep-rooted disregard for unnamed fields:  http://codepad.org/OuWsWpwm
20:39:51 <napping> Is it possible to define a syntax including implicit fields?
20:39:54 <irene-knapp> Eelis: hm
20:40:00 <napping> sorry, that was for #agda
20:40:05 <irene-knapp> napping: no, -- oh
20:43:50 <Eelis> irene-knapp: do you think it's a bug or a feature? :)
20:44:16 <irene-knapp> Eelis: I think it's a corner case that I would just never run into :)
20:45:00 <Eelis> right. i guess what i'm really asking is: if i were to file a ticket, do you reckon it will be accepted or rejected? :P
20:45:52 <irene-knapp> I think a posting to haskell-cafe would be the best way to get it discussed
20:46:09 <irene-knapp> and you could then file the ticket if people there seem to regard it as a bug
20:46:30 <irene-knapp> discussion is a lot easier to get than action so that should be your first goal :) and a ticket won't have the same visibility
20:46:41 <Eelis> i'm scared of mailing lists
20:46:59 <irene-knapp> aw :(
20:47:08 <irene-knapp> they only want to love you!  ... forever.
20:47:09 <shachaf> Eelis: Would you ever use "Foo{}" with a non-empty {} if you don't have names?
20:47:34 <shachaf> It seems to me vaguely like that's the only use case.
20:48:04 <napping> That looks pretty odd
20:48:15 <Eelis> shachaf: the way i ran into this issue was that i had a function which had a    f X{..} = X{..}  case which used to work fine when X's fields had names, but which silently broke when i made the fields nameless
20:48:37 <shachaf> Eelis: Ah, matching syntax is a different thing.
20:48:47 <Eelis> it boils down to the case in my latter paste though
20:48:53 <Eelis> it's about diagnosing uninitialized fields
20:48:55 <shachaf> And also that's with the RecordWildCards/RecordFieldNamePunning/whatever extension?
20:48:59 <Eelis> yes
20:49:00 <shachaf> Probably you should post to -cafe.
20:49:05 <Eelis> :(
20:49:18 <shachaf> Eelis: I really don't like posting to mailing lists, and even *I've* posted to -cafe.
20:49:30 <Eelis> do i have to subscribe and everything?
20:49:36 <irene-knapp> yes
20:49:39 <Eelis> bleh
20:49:58 <john_r_watson> code golf anyone?
20:50:00 <hpaste> john_r_watson pasted “replace” at http://hpaste.org/54415
20:50:50 <irene-knapp> john_r_watson: well, you can take out the brackets :D
20:50:54 <john_r_watson> :)
20:50:57 <irene-knapp> or, uh, so hlint informs me hahaha
20:51:45 <john_r_watson> this felt like there should have been a library function given that there's Data.List.lookup
20:52:03 <john_r_watson> but I couldn't find much other than lookup operating on assoc. lists
20:52:31 <hmmmm> hey guys, how would i do what i'm trying to do here? http://pastebin.com/ZX0raKGA
20:52:33 <mauke> The paste ZX0raKGA has been copied to http://hpaste.org/54416
20:52:47 <mike-burns> hmmmm: Use a let.
20:52:58 <hmmmm> okay, and what does let do exactly?
20:53:14 <hmmmm> just defines a variable inside of a pure function?
20:53:29 <mike-burns> It's how you associate variables with values.
20:53:39 <mike-burns> Also, other people are going to tell you to read a tutorial.
20:53:47 <hpaste> dmwit annotated “pastebin.com/ZX0raKGA” with “pastebin.com/ZX0raKGA (annotation)” at http://hpaste.org/54416#a54417
20:53:50 <hmmmm> i am reading one right now
20:53:53 <dmwit> hmmmm: see my annotation
20:53:53 <mike-burns> Oh!
20:53:54 <john_r_watson> let will introduce 'pure' variables in a 'do' form as form
20:54:00 <dmwit> hmmmm: That's how I would "fix" it.
20:54:05 <mike-burns> Keep reading your tutorial!
20:54:23 <hmmmm> could've sworn i tried that, dmwit
20:54:25 <hmmmm> let me try it again...
20:54:38 <dmwit> Oh, yes, I see that has an error, too.
20:54:51 <hpaste> dmwit annotated “pastebin.com/ZX0raKGA” with “pastebin.com/ZX0raKGA (annotation) (annotation)” at http://hpaste.org/54416#a54418
20:54:57 <dmwit> needs more parentheses =)
20:55:47 <hmmmm> now that works
20:56:00 <hmmmm> that was my mistake too when i initially tried that (no parenthesis where they're needed)
20:56:13 <dmwit> Without parentheses, it's trying to do
20:56:20 <dmwit> (putStrLn "Hello World") ++ show z
20:56:24 <hmmmm> now why don't i need let when the variables are outside of a function?
20:56:24 <mike-burns> hmmmm: Try it again without parens to make sure you understand the error message. It's one that comes up often.
20:56:26 <dmwit> ...which doesn't really make sense.
20:56:52 <dmwit> hmmmm: There's just several ways of binding names.
20:57:00 <hmmmm> dunno what type `[a]' is -- does that mean string?
20:57:05 <dmwit> hmmmm: The "where" at the top is like a big "let". =)
20:57:13 <hmmmm> i see
20:57:19 <dmwit> hmmmm: [a] is a list of "a"s.
20:57:28 <dmwit> The "a" is a type variable, so [a] is a polymorphic list.
20:57:35 <mike-burns> hmmmm: It means a list of anything. A String is a list of characters: [Char] .
20:57:49 <hmmmm> ah
20:57:49 <hmmmm> i see
20:58:16 <hmmmm> so it's expecting a list, but it had a type of IO ()
20:58:23 <hmmmm> whatever that is
20:58:28 <dmwit> Right.
20:58:31 <hmmmm> the generality is what makes the errors difficult to interpret
20:58:36 <PiRSquared17> @type map . (.)
20:58:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> [f a] -> [f b]
20:58:44 <hmmmm> well, at least it's better than C++ error messages
20:58:46 <irene-knapp> yeah, actually, we need to work on that
20:59:01 <periodic> I'm a little confused by this.  Is there a function to do something like "Read a => String -> Maybe a"?
20:59:05 <irene-knapp> in most languages, you can learn the syntax by taking a guess and then correcting it based on the compiler's advice
20:59:07 <periodic> Hoogle points me to Network.CGI or something.
20:59:10 <dmwit> :t reads
20:59:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:59:12 <irene-knapp> in Haskell you can't because everything is a type error
20:59:13 <dmwit> periodic: Use that.
20:59:23 <PiRSquared17> @pl \f g xs -> map (f . g) xs
20:59:23 <lambdabot> (map .) . (.)
20:59:31 <periodic> dmwit: Thanks, I'll take a look.
20:59:42 <dmwit> periodic: You can expect that a successful parse will return an empty string in its second component.
20:59:46 <PiRSquared17> @pl \f g xs -> map f (map (g) xs)
20:59:46 <lambdabot> (. map) . (.) . map
20:59:48 <irene-knapp> maybe the solution is to have a diagnostic system that looks for common beginner mistakes and offers supplemental advice, below the actual error
21:00:27 <sshine> PiRSquared17, \f g -> map $ f . g looks nice.
21:01:57 <sshine> @type (.) . (.)
21:01:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:02:05 <mike-burns> irene-knapp: I find the error messages to be the hardest part of every programming language.
21:02:18 <dmwit> I find GHC's error messages quite informative.
21:02:27 <mike-burns> Hey let's not push it here.
21:02:31 <irene-knapp> mike-burns: really?  I don't think so at all
21:02:42 <mike-burns> What do you find harder?
21:02:48 <irene-knapp> dmwit: oh they are!  they're great!  but they were a huge obstacle to me as a beginner, and I'm sure they are to everybody
21:02:59 <irene-knapp> mike-burns: there is no hard part :D
21:03:01 <periodic> dmwit: Huh, I missed that function because in the docs it's type is "ReadS a", which is an alias for that type.  Oops.
21:03:03 <mike-burns> Hah.
21:03:18 <sshine> mike-burns, I find error messages to be hard because you have to learn to read them for every compiler.
21:03:19 <dmwit> periodic: Yes, the ReadS and ShowS things are a bit mysterious.
21:03:38 <dmwit> I think those two type synonyms cause more confusion than enlightenment.
21:03:51 <mike-burns> sshine: Exactly. Like, "oh, that's how this compiler tells me I instead need to do this".
21:03:56 <sshine> mike-burns, I find the process of debugging hard, but not as hard as implementing difficult algorithms.
21:04:14 <mike-burns> sshine: Sure, but that's programming in the large, not specific to learning a new language.
21:04:26 <periodic> dmwit: Why does it return a list of pairs and not just a single pair?  readList already returns a list, so how would it return multiple pairs?
21:05:22 <periodic> says it returns "a list of possible parses"  I guess some things could be ambiguous.
21:06:19 <NemesisD> anyone know if there are any first-rate ORMs/database abstractions that support mysql? i see lots of old stuff in hackage
21:07:02 <dmwit> periodic: Yes, exactly.
21:07:12 <dmwit> periodic: I don't think any of the built-in types ever return a list of length longer than one.
21:07:17 <dmwit> periodic: But they could, in principle.
21:07:23 <napping> NemesisD: I haven't used it myself, but bos made mysql-simple recently
21:07:44 <dmwit> e.g. I wouldn't complain if reads "1e-9" = [(1e-9, ""), (1, "e-9")]
21:07:59 <periodic> dmwit: Yeah, it sounds like bad design to have an ambiguous grammar, particularly when the read class seems to most commonly be used with "read" which returns a single value.
21:08:19 <napping> periodic: I think it's really that it's exposing the "list of successes" used internally in parsing
21:08:20 <shachaf> dmwi: read "123" = [(1,"23"),(12,"3"),(123,"")]?
21:08:34 <periodic> As long as I can rely on laziness to put the greedy parse first and not compute the rest.
21:08:36 <NemesisD> ah. if its bos its probably good. though simple and good abtraction are somtimes mutually exclusive when it comes to db access
21:08:47 <dmwit> shachaf: I wouldn't complain, so long as the greedy result came first.
21:08:53 <napping> I'm not sure it counts as "abstraction"
21:09:08 <napping> what you mean by that
21:09:10 <hmmmm> comparing strings is comparing lists, so i would do something like...  strcmp x = foldl (==) head(x) x ?
21:09:24 <dmwit> hmmmm: Just use (==).
21:09:28 <dmwit> > "hello" == "hello"
21:09:29 <lambdabot>   True
21:09:29 <hmmmm> okay
21:09:32 <dmwit> > "hello" == "hellp"
21:09:33 <lambdabot>   False
21:09:38 <NemesisD> i come from the background of ruby on rails, so i'm more used to using ORMs and avoiding raw SQL query munging at all costs
21:09:56 <shachaf> > ('h':"ellо") == "hello"
21:09:57 <lambdabot>   False
21:10:10 <hmmmm> why is that false
21:10:12 <dmwit> Come on, don't try to confuse the new guy.
21:10:13 <shachaf> Please disregard previous line.
21:10:15 <shachaf> Sorry.
21:10:19 <dmwit> hmmmm: Unicode shenanigans, probably.
21:10:22 <hmmmm> ah
21:10:23 <jessopher_> the o seems to be encoded weird
21:10:31 <dmwit> hmmmm: a lookalike e character, perhaps, or some other similar thing
21:10:32 <hmmmm> > ('h':"ello")
21:10:33 <lambdabot>   "hello"
21:10:38 <shachaf> > ('h':"ello") == "hello"
21:10:39 <hmmmm> > ('h':"ello") == "hello"
21:10:39 <lambdabot>   True
21:10:40 <lambdabot>   True
21:10:46 <dmwit> > "hello"
21:10:47 <hmmmm> ah, nice try
21:10:47 <lambdabot>   "hello"
21:10:56 <dmwit> > ('h':"ellо")
21:10:57 <lambdabot>   "hell\1086"
21:11:00 <dmwit> there we go
21:11:16 <NemesisD> yeah mysql-simple doesn't quite fit my needs
21:11:53 <hmmmm> there's a binding to functions like ioctl, correct?
21:12:07 <mike-burns> NemesisD: I'm coming from a Rails background myself, so if you find a DB access lib that you like please let me know. I still haven't.
21:12:10 <dmwit> I'm sure there is.
21:12:13 <mike-burns> hmmmm: Yes.
21:12:15 <hmmmm> ok
21:12:19 <dmwit> Though I don't know off the top of my head which package provides them.
21:12:28 <dmwit> Take a look on Hackage. (You know where it is?)
21:12:43 <NemesisD> mike-burns: persistent is pretty nice but for whatever reason it seems development on the mysql backend got abandoned
21:12:46 <mike-burns> There's an ioctl package.
21:12:52 <napping> what do you want from an ORM in Haskell?
21:13:08 <mike-burns> NemesisD: Cool, I'll check that out.
21:13:11 <NemesisD> napping: to not munge SQL query strings
21:13:20 <napping> It's not like we've got Objects to map to the Relations
21:13:30 <parcs> munge?
21:13:32 <NemesisD> right, im sort of misappropriating the term
21:13:42 <rwbarton> there are things that are "not raw SQL query munging" that are not "ORMs"
21:13:46 <dmwit> parcs: That's a technical term. =)
21:13:46 <mike-burns> I want a Record/Relation Mapper.
21:13:55 <NemesisD> rwbarton: what are those called. i want one of them
21:14:05 <napping> Parameter substitution seems reasonably safe
21:14:21 <rwbarton> personally I have never used one, but I understand that HaskellDB is such a thing
21:14:43 <napping> or at least a typesafe way of expressing queries
21:15:07 <napping> I hear it work poorly with mysql - it produces things like nested selects which mysql doesn't optimize very well
21:15:37 <NemesisD> the thing that most ORMs get you is being able to specify your datatypes at a hight level: specifying the fields and relations (has many, belongs to, etc) and having the library take care of most of the query generation, joins, etc
21:16:44 <parcs> dmwit: heh, didn't know that
21:17:23 <parcs> you shouldn't be munging sql query strings any more than you would be munging orm combinators
21:17:50 <parcs> but anyway, i digress :P
21:19:11 <mike-burns> I just want convience out of my ORM.
21:19:31 <NemesisD> same
21:19:37 <NemesisD> performance would be nice too
21:19:44 <mike-burns> Sure, I suppose.
21:21:29 <NemesisD> the fact that mysql is falling out of favor probably isn't helping
21:21:52 <NemesisD> persistent is mostly what i need, plus it integrates with yesod, but right now it only supports postgres, sqlite and mongo
21:21:55 <john_r_watson> code golf part deux?
21:22:03 <mike-burns> NemesisD: Switch to postgres!
21:22:25 <jessopher_> or mongo for that matter
21:22:56 <NemesisD> mongo isn't the best choice for everything. this project may use both though
21:23:07 <mike-burns> A MySQL to Mongo switch would be weird. I'd hesitate to claim that the same problem domain can be properly solved with both.
21:23:40 <jessopher_> i just felt like suggesting the less coherent alternative
21:23:47 <NemesisD> i'm wanting to rewrite some code we have in haskell. it performs aggregation across a couple hundred mysql databases
21:23:48 <mike-burns> Heh.
21:23:56 <hpaste> john_r_watson annotated “replace” with “replace (annotation)” at http://hpaste.org/54415#a54419
21:24:03 <napping> do you need to dynamically generate queries?
21:25:08 <mike-burns> Ah good, I was going to suggest using `map' earlier for this code golf, but got distracted.
21:25:30 <NemesisD> I probably don't but part of making this code be maintainable is to have it resemble our existing code as style guidelines. in our current codebase it is considered bad form to just have raw SQL queries amongst your code
21:25:57 <NemesisD> it may sound silly but i'd be taking enough of a leap bringing some haskell code to a mostly ruby shop
21:26:02 <mike-burns> Ah, but it doesn't need to be dynamic.
21:26:55 <NemesisD> not necessarily
21:27:25 <NemesisD> lets just say my enthusiasm for this project is going to diminish if i have to spend all my time working with low-level mysql bindings and writing out queries
21:27:34 <napping> john_r_watson: replace (a,b) l = [(x,if x==a then b else y)|(x,y)<-l]
21:27:56 <napping> I don't see the point of reimplementing a relation model as a library
21:28:13 <mike-burns> The Haskell DB libs are weak, and especially in comparison with Ruby's. Good luck, NemesisD .
21:28:22 <napping> parameters to avoid string escaping make sense, as do things like HaskellDB for type checking
21:29:05 <jessopher_> is it considered bad form to upload known broken code to hackage, even if you qualify it with alpha stability? ;)
21:29:13 <mike-burns> If you have to ask ...
21:29:25 <jessopher_> good point
21:29:56 <NemesisD> i think convenience has a place too. sql injection prevention and type checking are important but i don't know what about haskell's characteristics mean we shouldn't also want to seek a nice, high-level API for db access
21:31:53 <napping> what does a high-level API look like?
21:32:11 <hpaste> napping annotated “replace” with “replace (annotation) (annotation)” at http://hpaste.org/54415#a54420
21:32:24 <john_r_watson> napping: thanks!
21:32:40 <mike-burns> I haven't figured out a good API for a Haskell DB lib.
21:33:43 <NemesisD> mike-burns: i kinda like http://www.yesodweb.com/book/persistent#file335-select-functions-x30
21:34:30 <Ke> are Control.Exception and Typeable and deriving typeable de facto standard beyond ghc?
21:34:31 <mike-burns> Oh that's not bad.
21:34:57 <mike-burns> Impressive that he got OR in the syntax.
21:35:33 <Ke> is there some ranking system for which extensions and builtins are more acceptable than others?
21:35:55 <Ke> +listing
21:36:18 <mike-burns> Yeah, persistent looks nice.
21:37:30 <napping> I seems to be pretty much embedding SQL with haskell-flavored syntax. Is that all you mean by "nice API"?
21:38:51 <mike-burns> It can't be ugly Haskell syntax.
21:39:05 <NemesisD> napping: yep. you may call me superficial if you want
21:39:47 <NemesisD> persistent has the added benefit of being able to swap out backends and only really have to change configuration
21:39:50 <mike-burns> Part of the idea is that the Haskell syntax maps down to the appropriate SQL for the DB, so you can switch from MySQL to Postgres more easily.
21:39:56 <mike-burns> Yeah what he said.
21:40:51 <ddarius> napping: Never overestimate your ability to overestimate.
21:41:19 <ddarius> Dammit, that's not what I wanted.
21:41:26 * ddarius should sleep.
21:53:03 <jessopher_> always overestimate your ability to underestimate... for consistency sake
21:54:58 <wavewave> hi
21:55:24 <jessopher_> hello
21:55:38 <wavewave> hi.
21:56:04 <jessopher_> I should have read your name more carefully
21:56:14 <wavewave> ?
21:56:55 <wavewave> its'  read as weiv weiv
21:57:23 <jessopher_> ah
21:58:06 <wavewave> pretty quiet in thanksgiving mode..
21:58:23 <NemesisD> isn't it a little early for thanksgiving mode?
21:58:39 <wavewave> right. ;-)
21:59:28 <wavewave> is anyone using tablet pc?
22:00:04 <wavewave> not dumbed-down tablet like ipad.
22:00:38 <jessopher_> i have a touchscreen that uses tablet features, but i dont usually use it. Cockroaches end up opening a bunch of spammy stuff when im asleep
22:01:06 <wavewave> I ported xournal to haskell version using gtk2hs ;-D
22:02:16 <wavewave> a notetaking gtk application
22:02:33 <jessopher_> nice, wheres it at?
22:02:42 <jessopher_> (your port)
22:02:46 <wavewave> not a hackage yet.. but you can see
22:03:41 <wavewave> wait a minute.. let me commit things first. ;-P
22:03:53 <jessopher_> alright
22:05:10 <wavewave> https://github.com/wavewave/hxournal
22:05:34 <wavewave> need to be polished much.
22:06:00 <wavewave> but now it can read xoj file and basic handwriting and save
22:06:26 <wavewave> https://github.com/wavewave/xournal-parser
22:06:34 <wavewave> https://github.com/wavewave/xournal-render
22:06:54 <wavewave> they are xoj file parsing and rendering library using cairo.
22:07:30 <wavewave> i implement GUI using coroutine.
22:07:53 <wavewave> pull-style event programming.
22:09:33 <wavewave> tablet pc with wacom tablet is really great.. it's almost like a pen/paper.
22:09:46 <jessopher_> the libraries arent dependencies of the hxournal app are they?
22:10:13 <wavewave> hxournal app depends on the xournal-parser and xournal-render
22:10:29 <kfish> hey wavewave
22:10:32 <kfish> that looks cool :)
22:10:38 <jessopher_> ah ok yeah, i missed that in the cabal file
22:10:41 <wavewave> kfish: thanks.
22:11:10 <wavewave> now my program uses subpixel information from wacom tablet.
22:11:46 <wavewave> but it's more like depending on my own setup, so I need to polish things for more generality..
22:12:01 <wavewave> some time soon, I will announce it as a hackage.
22:12:39 <wavewave> wacom tablet has a great resolution.. usually ten times finer than screen resolution.
22:13:32 <kfish> wavewave, i'm catching up on how gtk hacking is currently done ... is what you're doing with HXournal.GUI.Menu the usual way things are done now?
22:13:38 <wavewave> once one use a tablet with wacom, one cannot use other tablet toy.
22:14:35 <wavewave> kfish: not at all... I developed some of my own way..
22:14:44 <kfish> i've been trying to get things done with glade/gtkbuilder files and glade keeps failing so i'd prefer to just write it in code
22:15:01 <kfish> wavewave, what you have looks reasonably sane / maintainable
22:15:12 <wavewave> kfish: yes. I don't like such additional tool.
22:15:40 <wavewave> just simply use a verbatim quasi quoter for glade xml part.
22:16:02 <wavewave> and load that string using gtk function
22:16:38 <kfish> cool
22:16:47 <kfish> and that's just gtk, not libglade
22:16:59 <wavewave> I do not use any glade thing.
22:17:00 <kfish> i guess it's gtkbuilder format?
22:18:20 <wavewave> kfish: I do not know what the exact name is but I use uiManager kind of thing.
22:18:52 <kfish> cool, seems straightforward ... seems the same as the gtkbuilder file i have, so i can just cut from that
22:19:11 <wavewave> Using Iteratee and Coroutine may be also somewhat interesting.
22:19:30 <kfish> yeah? how are you using those?
22:19:52 <wavewave> You know GUI programming is full of state operation.
22:20:05 <wavewave> need lots of IORef..
22:20:55 <wavewave> Now I wrap IORef thing to State monad transformer over Iteratee over IO.
22:21:24 <wavewave> So inside Iteratee, you can use yield to get the next event.
22:22:07 <kfish> nice
22:22:10 <wavewave> I'm sorry, not yield but await..
22:22:23 <kfish> and you have defined an iteratee from coroutine ...
22:22:26 <wavewave> yield is for generator, await for iteratee
22:22:52 <wavewave> kfish: yes.. so programming style is now pull style..
22:23:19 <wavewave> showing business logic more clearly.
22:23:30 <mjrosenb> can anyone think of a reason that a binding x = foo bar would give a type mismatch, but using (foo bar) in an expression in the repl would work?
22:23:34 <kfish> it would be interesting to generalize that
22:24:34 <wavewave> kfish: I am thinking to refactor a library from it when matured. I think Conal Elliott has done this already though.
22:24:42 <byorgey> mjrosenb: yes. that reason is called the Monomorphism Restriction.
22:24:55 <mjrosenb> byorgey: :(
22:25:03 <byorgey> mjrosenb: just turn it off.
22:25:10 <kmc> the Dreaded Monomorphism Restriction!
22:25:22 <byorgey> mjrosenb: add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your .hs file
22:25:58 <shachaf> There exist other reasons.
22:26:14 <wavewave> kfish: this is my first time using this technique so it's a little messy now, but as my program evolves, I hope that refactorrable part will be more clean.
22:26:43 <jessopher_> dirty code that is sound is better than pretty code that isnt
22:26:50 <shachaf> mjrosenb: Rank-2 types, for instance. :-)
22:27:47 <xil> hi. Can someone explain the syntax of "case () of _"? I get what goes in the parentheses, but what's the underscore?
22:27:58 * mjrosenb thought issues with the monomorphism restriction usualy said "hey, we invoked the monomorphism restriction here, here's how you can make this error go away"
22:28:10 <Cale> xil: _ is a pattern which matches anything without binding any variables
22:28:19 <Cale> xil: () here is the empty tuple
22:28:23 <wavewave> kfish: I think conal elliott's phooey is similar to my approach.
22:28:26 <shachaf> mjrosenb: You mean as a compiler warning? I've never seen that.
22:28:43 <napping> doesn't the warning mention NoMonomorphismRestriction?
22:29:03 <xil> Cale: oh no, that's not what I meant. This is where I got that: http://www.haskell.org/haskellwiki/Case
22:29:30 <Cale> xil: yep, that's what you meant ;)
22:29:33 <xil> Cale: in the parentheses go the thing you're checking. I get that. I also understand the guards. But I don't understand what the underscore is supposed to mean
22:29:42 <wavewave> although I haven't done it as neatly as his.. It's a little unfortunate for me that I cannot use phooey directly for my project.
22:29:47 <Cale> _ is a pattern
22:29:58 <xil> but why is it outside the guards?
22:30:08 <Cale> because patterns always come before guards
22:30:08 <jessopher_> its the pattern the guards are attached to
22:30:44 <Cale> Think about something like:
22:30:53 <Cale> f x | x < 0 = "negative"
22:30:57 <xil> can one of you give me an example that doesn't use () and _? Since those are somewhat meaningless?
22:31:02 <Cale>     | x == 0 = "zero"
22:31:04 <Cale> etc.
22:31:07 <xil> oh okay
22:31:11 <Cale> x is a pattern here
22:31:20 <Cale> and we're attaching the guards to that pattern
22:31:46 <Cale> > case [1,2,3] of (x:xs) -> x; [] -> 0
22:31:47 <lambdabot>   1
22:31:57 <xil> so, for example, I could have "case maybeVar of Just a | a < 5 -> "five""
22:32:03 <xil> or that, yeah
22:32:04 <Cale> > case [1,2,3] of (x:xs) | even x -> x | odd x -> 2*x; [] -> 0
22:32:05 <lambdabot>   2
22:32:13 <xil> okay awesome, thank you
22:32:45 <jessopher_> that looks like some kind of case comprehension
22:32:50 <Cale> I don't know why the wiki page for case doesn't have any discussion of case in general
22:35:36 <xil> it's a bit frustrating. In general I'm a bit frustrated at conditional support in general. If-then-else feels cumbersome and cases feel like they could be slimmed somehow. I understand why there isn't an if function in the Prelude, but I wish there was a way to treat if as though it were a function, so you could still code that way, but just have the compiler know that it's special and not in any modules
22:37:06 <kmc> why isn't there an if function in the Prelude?
22:37:09 * kmc does not understand why
22:37:52 <xil> I read some e-mails on the discussion that cite something about it coming up in too many function searches and gumming up certain other works, but I don't quite understand how the compiler works
22:37:57 <companion_cube> ite true a b = a; ite false a b = b   and you're done with a "if" function
22:38:13 <shachaf> kmc: There are many problems with the Prelude, and that one probably isn't the biggest.
22:38:19 <xil> yes you can always write one yourself, but they left it out of the Prelude for a specific reason
22:38:26 <shachaf> I suppose it's one of the easier ones to add backwards-compatibly, though.
22:38:48 <kmc> beginners overuse 'if' but they also overuse 'length' and 'head'
22:39:00 <kmc> we should have a tool which warns about these
22:39:04 <companion_cube> :D
22:39:06 <kmc> you could call it hlint ;)
22:39:14 <jessopher_> when my cases and if's get to big, I just use patterns and guards in function heads in a where clause. i say just throw them both out
22:39:16 <xil> haha, I forgot about that
22:39:32 <xil> how do people misuse length and head though?
22:39:34 <kmc> it fails though :(
22:39:45 <shachaf> xil: By using them.
22:39:49 <kmc> sum xs = if length xs == 0 then 0 else head xs + sum (tail xs)
22:40:16 <kmc> hlint doesn't object to that, though :/
22:40:16 <xil> that looks horrific
22:40:16 <wavewave> kmc: pretty awesome example. ;-)
22:40:25 <kmc> it is common for beginners to write code like this
22:40:29 <kmc> entirely understandable
22:40:54 <napping> kmc: you need ndm's other project, catch
22:41:00 <kmc> ah yes
22:41:04 * kmc is fond of ndm's many projects
22:41:24 <xil> well I'm still a beginner, and I'd say that I have a LOT to learn still about good coding practices. I don't make those mistakes anymore, but I still make some. I just have no idea how to learn better practices
22:42:11 <shachaf> xil: If you want to become an expert in golfing Fibonacci sequences, stay in #haskell.
22:42:43 <jessopher_> i just code how i like until someone comes along and rubs my nose in it. i call this, the bad puppy method to good programming.
22:42:46 <kmc> or if you want to be come an expert in making lame jokes about monads
22:42:48 <kmc> hehe
22:42:51 <Axman6> > fix ((1:).scanl(+) 1)
22:42:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:42:54 <xil> shachaf: I should. There's no particular reason why I don't hang out in IRC, but I just tend not to I've noticed
22:43:07 <xil> see it's stuff like that
22:43:15 <xil> looks like gibberish
22:43:21 <kmc> we can explain it!
22:43:22 <xil> haha
22:43:26 <xil> I'd love to know
22:43:28 <shachaf> xil: Do you understand fix?
22:43:30 <shachaf> And scanl?
22:43:31 * kmc will explain it!
22:43:34 <Axman6> yeah, that looked like gibberish for me for a long time too
22:43:40 <xil> I know fix is a y-point combinator, but I don't know what combinators do
22:43:42 <kmc> http://www.vex.net/~trebla/haskell/fix.xhtml is a very good document about fix
22:43:46 <xil> no idea what scanl is but I can look that up
22:43:46 <kmc> "y-point combinator" is not a thing
22:43:51 <kmc> Y is one example of a fix-point combinator
22:43:55 <kmc> but it's not well-typed in Haskell
22:44:00 <kmc> 'fix' is a different fix-point combinator
22:44:01 <Axman6> @src fix
22:44:01 <lambdabot> fix f = let x = f x in x
22:44:02 <wavewave> xil: look at source code of standard libraries.. thas's quite helpful to learn pattern.
22:44:03 <xil> fixed-point combinator is what I meant
22:44:27 <kmc> > let fibs = ((1:).scanl(+) 1) fibs in fibs
22:44:28 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:44:57 <kmc> > let fibs = 1 : scanl (+) 1 fibs in fibs
22:44:58 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:45:02 <Axman6> kmc: wow, it looks like you just applied some syntactic substitution to what i wrote before!
22:45:20 <kmc> ...
22:45:35 <kmc> > scanl (+) 1 [1]
22:45:36 <lambdabot>   [1,2]
22:45:36 <Axman6> that was more for xil than you =)
22:45:38 <kmc> > scanl (+) 1 [1,1]
22:45:38 <lambdabot>   [1,2,3]
22:45:40 <kmc> > scanl (+) 1 [1,1,2]
22:45:41 <lambdabot>   [1,2,3,5]
22:45:48 <kmc> > scanl (+) 1 [1,1,2,3]
22:45:49 <lambdabot>   [1,2,3,5,8]
22:45:56 <xil> what gets me about fix is that it looks like it isn't defining a computation, but a property for the function to have
22:46:02 <kmc> basically yes
22:46:33 <kmc> but it can only 'solve' these properties in a limited sense
22:46:58 <xil> the mystery to me is in how fix 'solves' the property
22:47:07 <kmc> recursion
22:47:15 <kmc> fix f = f (fix f)
22:47:18 <xil> for example, what would happen with "fix (\ x -> x+1)"
22:47:33 <kmc> it finds a least fixed point in the domain (i.e. lattice, i.e. partially-ordered set) of partially-defined values
22:47:45 <Axman6> fix = f (fix f) = f (f (fix f)) = f (f (f (fix f))) = ...
22:47:46 <kmc> ⊥ is the least element in that poset
22:48:01 <kmc> so if f ⊥ = ⊥, then fix f = ⊥
22:48:13 <Axman6> > fix f
22:48:13 <kmc> a function f such that f ⊥ = ⊥ is called a strict function
22:48:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:48:14 <lambdabot>    `GHC.Show.Show a'
22:48:14 <lambdabot>      a...
22:48:19 <Axman6> > fix f :: Expr
22:48:20 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
22:48:33 <kmc> \x->x+1 is a tricky case because of type-class overloading
22:48:35 <xil> so fix isn't actually defined as "fix f = let x = f x in x" it's defined as "fix f = f (fix f)"
22:48:42 <kmc> xil, either definition will do
22:48:56 <kmc> with common haskell implementations, the former will be more efficient
22:48:56 <xil> haskell understands the former?
22:49:01 <xil> wow
22:49:04 <kmc> but they are semantically equivalent
22:49:11 <kmc> haskell understands either
22:49:19 <kmc> "let" is recursive in Haskell
22:49:38 <kmc> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
22:49:39 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
22:49:50 <copumpkin> > let ones = 1 : ones in ones
22:49:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:49:59 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:49:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:50:32 <xil> wow
22:50:35 <xil> I had no idea
22:50:49 <kmc> "let" and "where" are recursive, as is the module top-level
22:51:00 <kmc> this is the root source of recursion in Haskell
22:51:09 <kmc> "fix" is a helper function defined using that capability
22:51:13 <kmc> which is more convenient in some cases
22:51:21 <kmc> but you could not implement "fix" without some recursion already being built into the language
22:51:24 <shoerain> So if I'm looking for a smaller haskell channel...
22:51:28 <kmc> (this is a property of typed lambda calculii in general)
22:51:38 <Axman6> shoerain: why would you want that?
22:52:02 <shoerain> easier time to follow conversations and pick up nuggets of information?
22:52:04 <jaredj> shoerain: Ctrl -
22:52:05 <copumpkin> > (,) {}
22:52:06 <lambdabot>   (*Exception: <interactive>:3:0-5: Missing field in record construction
22:52:10 <copumpkin> o.O
22:52:26 <jaredj> oh nm
22:52:38 <Axman6> > case (1,2) of (,) {} -> text "ok"
22:52:39 <lambdabot>   ok
22:52:42 <kmc> shoerain, you can go to #haskell-in-depth
22:52:42 <Axman6> :o
22:52:44 <kmc> nobody ever talks there
22:52:48 <copumpkin> I'd expect that one
22:52:59 <copumpkin> but I didn't realize it'd let you not provide all fields when constructing it
22:53:08 <shoerain> aw, well just wondering.
22:53:19 <kmc> xil, here are various ways to write a fixed-point combinator in haskell: http://okmij.org/ftp/Haskell/Fix.hs
22:53:22 <copumpkin> > Left {}
22:53:23 <lambdabot>   Left *Exception: <interactive>:3:0-6: Missing field in record construction
22:53:34 <kmc> obfuscated ways, perhaps
22:53:34 <Axman6> shoerain: this is by far the best place for that. if it gets to buys, you can go to #haskell-blah
22:53:40 <kmc> not so useful if you just want to know how 'fix' works
22:53:41 <copumpkin> > case Left {} of Left _ -> 5
22:53:42 <lambdabot>   5
22:53:57 <kmc> xil, did you already read http://www.vex.net/~trebla/haskell/fix.xhtml
22:54:40 <xil> kmc: I opened both links. Will read them soon. Right now I'm trying to make sense of "fix ((1:).scanl(+) 1)" from what you've all told me. I looked up scanl and it makes pretty good sense
22:54:44 <kmc> cool
22:55:04 <kmc> > scanl (+) 1 [1..10]
22:55:05 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56]
22:55:09 <Axman6> xil: do you understand the zipWith version of fibs?
22:55:17 <kmc> "scanl (+) 0" gives you the running sums of a list
22:55:30 <xil> Axman6: yeah. I learned Haskell in a classroom environment and we discussed that version
22:55:40 <Axman6> where?
22:55:46 <kmc> > scanl (+) 0 [1..10]
22:55:47 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
22:56:14 <shachaf> > ((,)) {}
22:56:15 <lambdabot>   <no location info>: Empty record update
22:56:24 <shachaf> copumpkin: I like how those are different. :-)
22:56:32 <copumpkin> that's even weirder
22:56:36 <Axman6> o.O
22:56:39 <xil> I went to a small college in Mass. My prof had Programming Languages one year and he chose Haskell; it's a diff language every time
22:56:49 <Axman6> nice
22:56:58 <shachaf> copumpkin: Well, record update and record construction happen to use very similar syntax.
22:57:02 <shachaf> But they're different operations.
22:57:05 <shachaf> Similarly:
22:57:07 <xil> I am VERY glad that he did Haskell that year. Don't know where my life would be without Haskell
22:57:07 <shachaf> > Just {}
22:57:08 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
22:57:09 <shachaf> > (Just) {}
22:57:10 <lambdabot>   <no location info>: Empty record update
22:58:36 <xil> > fix ((1:).scanl(+) 1)
22:58:38 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:58:46 <Sgeo> How is Query a monad in HaskellDB?
22:59:02 <Sgeo> In monads, you can do arbitrary Haskell things, how could you turn that into a single SQL statement?
22:59:33 <byorgey> > scanl (+) 1 undefined
22:59:35 <lambdabot>   [1*Exception: Prelude.undefined
22:59:49 <byorgey> > (1:) . scanl (+) 1 $ undefined
22:59:51 <lambdabot>   [1,1*Exception: Prelude.undefined
23:00:29 <byorgey> > (1:) . scanl (+) 1 $ (1 : 1 : undefined)
23:00:31 <lambdabot>   [1,1,2,3*Exception: Prelude.undefined
23:00:37 <xil> > let fibs = 0:scanl (+) 1 fibs in fibs
23:00:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:03:56 <xil> aha, finally got that version I just gave lambdabot
23:04:34 <Axman6> > let fibs = 0:scanl (+) 1 (take 5 fibs)
23:04:35 <lambdabot>   not an expression: `let fibs = 0:scanl (+) 1 (take 5 fibs)'
23:04:37 <Axman6> > let fibs = 0:scanl (+) 1 (take 5 fibs) in fibs
23:04:38 <lambdabot>   [0,1,1,2,3,5,8]
23:08:59 <xil> AHA. I sort of understand now why the "let x = f x in x" notation works. But doesn't x need to begin as some non-empty quantity?
23:09:07 <kmc> "begin"?
23:09:22 <kmc> > let ones = 1 : ones in ones
23:09:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:09:37 <dmwit> xil: It does begin as some non-empty quantity. It begins as "f x".
23:09:47 <shachaf> xil: fix f is the fixed point of the sequence: undefined, f undefined, f (f undefined), f (f (f undefined)), ...
23:09:59 <shachaf> Note that at the limit, there is no "undefined" left. :-)
23:10:05 <xil> no but I mean, in the ones example, ones begins as the non-empty list [1] and has 1's added recursively
23:10:13 <shachaf> xil: No.
23:10:23 <shachaf> xil: The list [1] is equivalent to the list 1:[]
23:10:29 <shachaf> In fix (1:), there's never a [] anywhere.
23:10:46 <xil> exactly
23:10:46 <Sgeo> Hmm, I'm beginning to see how
23:10:53 <xil> you start out with something tangible
23:10:54 <Sgeo> All the interesting stuff is on Query (Rel r)
23:10:55 <kmc> xil, if «f ⊥ ≡ ⊥» then «fix f ≡ ⊥»
23:10:55 <xil> a 1
23:11:08 <kmc> ⊥ meaning "undefined", infinite loop, exception, etc.
23:11:15 <xil> yeah, hmmm
23:11:24 <shachaf> xil: No, you don't "start with something tangible".
23:11:27 <xil> also, how did you print the bottom character in IRC?
23:11:32 <kmc> perhaps the value of «f ⊥» is what you mean by "start with"
23:11:34 <shachaf> Do you understand let ones = 1 : ones in ones?
23:11:41 <xil> shachaf: yes
23:11:43 <kmc> xil, http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
23:11:53 <_pw_> " class (Monad m) => MonadReader r m | m -> r where ", Can someone tell me what's the meaning of '|' here? Is it guard syntax?
23:11:56 <Axman6> > let seq = 1 : map (+1) seq in seq
23:11:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:12:00 <kmc> _pw_, 'functional dependency'
23:12:12 <xil> kmc: oh...I'll do that another time, haha
23:12:32 <shachaf> xil: let ones = 1 : ones in ones
23:12:34 <kmc> _pw_, means that the type m must determine the type r
23:12:38 <shachaf> let ones = (1:) ones in ones
23:12:41 <Axman6> _pw_: it basically says that for each m used there, there is only one r that can be used
23:12:48 <kmc> _pw_, i.e. you can't have «instance MonadReader M R1» and «instance MonadReader M R2»
23:12:55 <shachaf> fix f = let x = f x in x
23:13:03 <shachaf> fix (1:) = let x = (1:) x in x
23:13:11 <shachaf> xil: Do you see how that works?
23:13:11 <kmc> > let f = (1:) in (f undefined, fix f)
23:13:11 <Axman6> so if you have instance MonadReader Maybe Int, you can then have instance MonadReader Maybe String
23:13:12 <lambdabot>   ([1*Exception: Prelude.undefined
23:13:29 <shachaf> kmc: Nice try.
23:14:01 <kmc> :/
23:14:48 <mike-burns> I have gotta get non-ASCII characters set up on this IRC client.
23:15:13 * kmc does enjoy the non-ASCII characters
23:15:15 <_pw_> kmc: would you provide some documentations detail it?
23:15:16 <xil> shachaf: sort of. What's getting me is that it only works because when you go to examine the 'x' next to (1:) you go to the definition and see the (1:), so you know that 'x' at least begins with a 1, and that it's a list. Then it tacks another 1 on the left and the recursion is trivial after that
23:15:21 <kmc> _pw_, GHC manual / google
23:15:54 <xil> shachaf: but what happens when you don't "start" with something there. Can you give an example where there isn't a starter like the beginning of a list?
23:16:10 <shachaf> xil: What do you mean?
23:16:19 <shachaf> xil: fix won't work if you give it a strict function.
23:16:30 <kmc> <kmc> perhaps the value of «f ⊥» is what you mean by "start with"
23:16:40 <Axman6> > fix (\f x -> if x < 2 then 1 else f (n-1) + f (n - 2)) 4
23:16:43 <lambdabot>   *Exception: stack overflow
23:16:44 <kmc> > let f = (1:) in f undefined
23:16:45 <lambdabot>   [1*Exception: Prelude.undefined
23:16:51 <kmc> note that this is not 'undefined'
23:16:53 <kmc> in particular:
23:16:56 <kmc> > let f = (1:) in head (f undefined)
23:16:57 <lambdabot>   1
23:17:01 <shachaf> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 5
23:17:02 <lambdabot>   120
23:17:07 <shachaf> > (\f n -> if n == 0 then 1 else n * f (n - 1)) undefined 0
23:17:07 <lambdabot>   1
23:17:23 <xil> shachaf: I don't quite know how to explain it. It's like fibs. No matter how you write it you have to put at least a 0: or 1: somewhere. You start the list manually and recursion fills in the rest
23:17:37 <shachaf> xil: Right. All recursion works that way.
23:17:42 <shachaf> Otherwise you'd have _|_.
23:17:56 * copumpkin hands xil corecursion
23:18:26 <xil> but how does Haskell come to _|_ though? It figures out the recursion is non-exhaustive somehow?
23:18:44 <shachaf> xil: Haskell isn't doing anything clever at all.
23:18:49 <shachaf> It's just mindlessly reducing the graph.
23:19:07 <kmc> xil, maybe the reason you can't explain the thing you're pointing at is that it doesn't exist?
23:19:32 <shachaf> xil: You should try evaluating the expression step by step yourself.
23:19:33 <wavewave> You can interprete _|_ as the value is not known at this stage of computation.
23:19:37 <kmc> xil, let me rephrase:  "no matter how you write f, it must be the case that f ⊥ ≠ ⊥"
23:19:46 <xil> kmc: maybe, haha. I understand the math behind a fixed point, but not the computation behind it
23:19:47 <shachaf> xil: fix (\x -> x) is _|_ because it trying to evaluate it, you must first evaluate it.
23:19:53 <kmc> if f ⊥ = ⊥, then fix f = ⊥
23:20:01 <shachaf> xil: "fix" is a very particular fixed point of a function.
23:20:14 <shachaf> A function can have more than one fixed point; "fix" will only find the least-defined one.
23:20:14 <kmc> if f ⊥ ≠ ⊥, then fix f ≠ ⊥, because ⊥ is not a fixed point of f, so it surely isn't the least fixed point
23:20:58 <xil> this is starting to make more sense
23:21:08 <xil> what does "least-defined" mean?
23:21:25 <kmc> there's a partial order of partially-defined values
23:21:34 <kmc> ⊥ < (⊥,⊥) < (2,⊥) < (2,3)
23:21:44 <kmc> likewise  ⊥ < (⊥,⊥) < (⊥,3) < (2,3)
23:21:52 <shachaf> @google ezyang defined
23:21:53 <lambdabot> http://blog.ezyang.com/2011/04/hoopl-dataflow-lattices/
23:21:54 <lambdabot> Title: Hoopl: Dataflow lattices : Inside 233
23:22:03 <kmc> but (2,⊥) and (⊥,3) are incomparable in this partial order
23:22:05 <shachaf> Nope, not that.
23:22:14 <shachaf> @google ezyang defined partial ordering
23:22:16 <lambdabot> http://blog.ezyang.com/2010/12/gin-and-monotonic/
23:22:16 <lambdabot> Title: Gin and monotonic : Inside 233
23:22:18 <kmc> you can say that their greatest lower bound is (⊥,⊥) and the least upper bound is (2,3)
23:22:24 <kmc> http://hackage.haskell.org/package/lub lets you compute these
23:22:34 <shachaf> Closer.
23:22:39 <shachaf> @google ezyang defined hasse
23:22:39 <kmc> lub (2, error "bleh") (error "whee", 3) = (2,3)
23:22:40 <lambdabot> http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
23:22:41 <lambdabot> Title: Hussling Haskell types into Hasse diagrams : Inside 233
23:22:42 <kmc> which is rather magical
23:22:49 <kmc> ezyang and conal have written about this stuff at length
23:22:54 <kmc> the link lambdabot just came up with is a good intro
23:23:04 <xil> kmc: I'm following you so far. I'm a math guy as well as a computers guy so I'm a bit familiar with mathematical logic =]
23:23:12 * shachaf is slightly distrustful of lub.
23:23:25 <shachaf> I guess it's OK.
23:24:37 <xil> so what if the fixed points of my function are 1,2,and 6? What would fix f return?
23:24:54 <kmc> probably ⊥ is also a fixed point of that function
23:25:14 <xil> haha. Suppose that it isn't though. I'm asking because I'm wondering if it's deterministic without knowing the function
23:25:30 <kmc> can you write a function where it isn't :)
23:25:30 <shachaf> xil: Well, what's the value of "f undefined"?
23:25:57 <xil> otherwise I just need to figure out the pattern of the recursion, which I suspect I can get by trying to understand some examples
23:26:14 <shachaf> xil: It's not "least" in the sense of 1 < 2 < 6; those are all incomparable.
23:26:17 <xil> shachaf: I don't know, but let's say it's not undefined?
23:26:26 <xil> ah okay
23:26:36 <shachaf> xil: Well, what *is* it?
23:26:38 <xil> so either of them could be the result, but it would definitely be one of them
23:26:43 <kmc> in standard Haskell, 1, 2, 6 are all equally defined
23:26:44 <xil> whichever comes up first?
23:26:52 <xil> in the recursion I mean
23:27:00 <kmc> if you can answer shachaf's question then we can answer yours
23:27:00 <shachaf> kmc: Well, in standard Haskell there's no knowing about integer literals...
23:27:08 <_pw_> http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes#Functional_dependencies, docs Here details that '|'
23:27:22 <shachaf> xil: I think you're expecting too much magic out of the Haskell evaluator. It's not doing anything clever at all.
23:27:32 <shachaf> (Well, other than all the clever things it does. But those aren't relevant here.)
23:27:44 <xil> I don't have a function in mind, so I can't really answer it. I'm just trying to figure out what "least" really means, and it strictly means in the sense of the partial ordering of definedness then?
23:27:54 <shachaf> xil: Yes.
23:28:19 <xil> oh no, I'm not expecting it, sorry. I'm asking because I want to know what the limit is. I'm cool with the limit it has, just want to understand it so I can understand how to use the function properly =]
23:28:28 <kmc> xil if you really want to know what "least" means, read about http://en.wikipedia.org/wiki/Domain_theory
23:28:50 <shachaf> If f _|_ = 1, then f <anything> = 1, so fix f = 1
23:28:50 <kmc> maybe http://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf
23:29:19 * Sgeo finally knows what LINQ is a monad means
23:29:21 <kmc> i also highly recommend those articles on ezyang and conal's blogs
23:29:29 <xil> shachaf: why would f <anything> = 1?
23:29:45 <kmc> because of monotonicity
23:29:45 <shachaf> xil: Because f isn't examining its argument at all.
23:29:51 <kmc> all Haskell functions are monotonic
23:29:59 <kmc> in the partial order we're talking about
23:30:04 <shachaf> Sgeo: Come back when you know what "jQuery is a monad" means.
23:30:14 <jessopher_> f x = 1
23:30:23 * shachaf sends Sgeo off on an impossible quest.
23:30:27 <kmc> perhaps "jQuery is a monad" means "I just learned Haskell and I'm wanking about how it's better than everything else"
23:30:29 <mike-burns> Hah.
23:30:49 <xil> so I couldn't do "f _|_ = 1; f x = x"?
23:30:49 <shachaf> kmc: That's what I gathered.
23:30:55 <shachaf> xil: No.
23:31:02 <shachaf> xil: That's the thing about _|_.
23:31:03 <xil> bottom doesn't pattern match
23:31:04 <Sgeo> xil, x = x
23:31:05 <shachaf> You can't detect it.
23:31:07 <kmc> (i haven't actually read the article, I don't mean to be a dick towards the author in particular)
23:31:09 <liyang> You can't look at bottoms.
23:31:11 <Sgeo> x is now _|_
23:31:23 <shachaf> Sgeo: ?
23:31:25 <Sgeo> If you could detect it 100% of the time, you'd have solved the halting problem
23:31:46 <shachaf> HALT!
23:31:47 <kmc> turing_lovecraft_theorem ⊥ = False; turing_lovecraft_theorem _ = True
23:31:48 <xil> oh right bottom is basically an error
23:31:48 <shachaf> An audience!
23:31:56 <mike-burns> The employees at Chipotle are never pleased when I explain why what they're making is like a monad.
23:31:58 <kmc> xil, worse, it can be an infinite loop
23:31:59 <xil> something uncomputable
23:32:02 <shachaf> xil: _|_ is a computation that doesn'tr eturn.
23:32:10 <shachaf> Doesn't have a value, rather.
23:32:21 <xil> ah
23:32:28 <jessopher_> f _|_ = 1 == f x = _|_, so it would be more general than the second match anyhow
23:32:30 <kmc> you can write an expression which is ⊥ iff Goldbach's conjecture is true
23:32:40 <jessopher_> or equally as general
23:32:46 <mike-burns> _|_ is a metaphor for life, really.
23:32:52 <jessopher_> lol
23:33:03 <xil> whoops
23:33:56 <kmc> xil, anyway, f is monotonic, and nothing is greater than 1, so if f ⊥ = 1, then f _ = 1
23:34:23 <kmc> i haven't given a proof that computable functions are monotonic in this poset
23:34:27 * kmc thinks about how one would prove it
23:35:07 <xil> kmc: I don't quite see what the "nothing is greater than 1" bit has to do with it, but otherwise I now understand why the implication works
23:35:09 <kmc> anyway informally, it would be very strange if changing 'undefined' to a value made your function produce *less* output
23:35:28 <kmc> well suppose we had a richer type, like lists
23:35:32 <kmc> and you tell me f ⊥ = [1]
23:35:39 <kmc> it could be the case that  f () = [1,2]
23:35:42 <kmc> because [1] < [1,2]
23:35:50 <kmc> er, that's not right
23:35:55 <kmc> and you tell me f ⊥ = 1:⊥
23:36:01 <kmc> now it works
23:36:10 <kmc> 1:⊥  <  1:2:[]
23:36:44 <kmc> > let f x = 1 : (case x of () -> [2]) in f ()
23:36:45 <lambdabot>   [1,2]
23:36:46 <kmc> > let f x = 1 : (case x of () -> [2]) in f undefined
23:36:47 <lambdabot>   [1*Exception: Prelude.undefined
23:37:08 <kmc> ezyang's blog has great diagrams of this stuff
23:37:56 <xil> I'm reading the post about hoopl dataflow lattices now
23:38:13 <shachaf> xil: That post wasn't the one I meant to link to.
23:38:18 <kmc> http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ this is the place to start
23:38:19 <shachaf> @google ezyang hasse
23:38:20 <lambdabot> http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
23:38:20 <lambdabot> Title: Hussling Haskell types into Hasse diagrams : Inside 233
23:38:23 <xil> shachaf: still interesting =], haha
23:38:48 <kmc> http://blog.ezyang.com/2010/12/gin-and-monotonic/ then this one
23:38:50 <xil> reading that now, thank you two =]
23:39:04 <jessopher_> i think you've explained 'least defined' pretty well in any case
23:41:22 <kmc> i'm not sure if the axioms for this relation _<_ are written down anywhere
23:42:20 <xil> I like the word "thunk"
23:42:36 <frerich> I'm really enjoying ezyang's blog. If he collected all his articles (maybe incorporating some improvements suggested in comments) into a book - I'd definately buy it.
23:42:54 <kmc> you have x ≤ x
23:43:05 * Axman6 thinks that a thunk is a somewhat odd word, because it represents something that is yet to be though by the computer, so it hasn't been thunk yet
23:43:08 <Axman6> >_>
23:43:11 <kmc> and you have  C x0 y0 ≤ C x1 y1  if x0 ≤ x1  and y0 ≤ y1
23:43:15 <kmc> for constructor C
23:43:15 <jessopher_> its the sound unevaluated expressions make when you throw them at the wall
23:43:28 <kmc> and the same for constructors of other arity
23:43:38 <kmc> and you have transitivity
23:44:10 <xil> jessopher_: exactly
23:44:57 <jessopher_> (printed a program and taped all the pages together to test this theory)
23:45:04 <Sgeo> May I see an example of GHC's loop detection in lambdabot?
23:45:10 <kmc> tape?  you don't have dot-matrix continuous-feed paper?
23:45:15 <kmc> Sgeo, i don't think it works in the bytecode interpreter
23:45:21 <jessopher_> hah, i wish
23:45:22 <Sgeo> kmc, ah, boo
23:45:41 <kmc> echo 'main = main' > foo.hs && ghc --make foo.hs && ./foo
23:45:49 <shachaf> Sgeo: lambdabot used to do <<loop>>, but no longer.
23:46:14 <kmc> i think it used to not work with -threaded either
23:46:19 <kmc> but these days it does, after a short delay
23:46:28 <kmc> which is probably the garbage collection interval
23:46:36 <shachaf> Does --make do anything these days?
23:46:44 <kmc> shachaf, it's the default in GHC 7
23:46:49 <kmc> you can use it to override a previous flag, iirc
23:47:05 <kmc> with -threaded entering a blackholed thunk can't kill the program immediately, because some other thread might be working on that evaluation
23:47:06 <Sgeo> What was the default in earlier GHCs?
23:47:13 <kmc> crap
23:47:20 <kmc> crap default
23:47:36 <shachaf> The default was --don\'tmake
23:47:46 <shachaf> I think it may have added --complain for most things, too.
23:47:59 <kmc> ghc --produce-baffling-linker-errors
23:48:08 <kmc> that was mostly what it did by default
23:48:30 <kmc> it got to the point where people would join here and i would just say "did you try ghc --make" before they said anything
23:49:45 <shachaf> Those were the days.
23:50:19 <Sgeo> addFlag by -C on the commandline:
23:50:19 <Sgeo>     Warning: The -fvia-C flag will be removed in a future GHC release
23:50:20 <Sgeo> Why?
23:50:57 <shachaf> Sgeo: Because people use the native code generator these days.
23:51:18 <Sgeo> What if I'm curious what the C looks like?
23:51:28 * Sgeo looks at the C for main=main and runs in horror
23:51:47 <kmc> now you see where curiosity gets you
23:51:49 <shachaf> Sgeo: Read kmc's weblog post for that.
23:51:56 <kmc> i have a weblog post about via-C?
23:52:01 <shachaf> kmc: About <<loop>>
23:52:06 <kmc> oh yeah
23:52:08 <shachaf> I assume Sgeo was trying to figure that out.
23:52:12 <shachaf> @google mainisusually black hole
23:52:13 <lambdabot> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
23:52:17 <napping> I think there's some C mode kept for porting
23:52:27 <kmc> Sgeo, GHC can output C in two flavors: "registerized" and "unregisterized"
23:52:33 <kmc> when you build GHC, you decide which flavor it shall produce
23:52:37 <Sgeo> shachaf, saw that
23:53:04 <kmc> the registerized C code runs faster but relies on GCC extensions and a Perl script which post-processes the assembly output of GCC
23:53:07 <napping> These days the LLVM backend is how you get code to go through other peoples optimizer
23:53:12 <kmc> it's not really C code at all
23:53:29 <shachaf> Is the evil mangler still around?
23:53:31 <shachaf> I thought it was removed.
23:53:32 <mike-burns> Hah, forgot about that Perl script.
23:53:38 <kmc> that was removed recently, so the default is to build with no via-C at all
23:53:44 <kmc> but you can still enable the unregisterized via-C
23:54:23 <kmc> the output of unreg'd via-C is still unportable in various ways, but it's more reasonable overall
23:54:28 <kmc> but also about 2x slower
