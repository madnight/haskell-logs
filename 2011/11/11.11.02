00:00:01 <Axman6> @hoogle handle
00:00:01 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
00:00:01 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
00:00:02 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
00:00:28 <kirindave> Axman6, indeed
00:00:50 <kirindave> GHC is upset because e is not fixed.
00:00:52 <Saizan> kirindave: "doesn't work" is quite lacking in information
00:01:10 <kirindave>  Ambiguous type variable `e0' in the constraint: (Exception e0) arising from a use of `handle'
00:01:21 <kirindave> Saizan, I figured it'd be obvious to everyone who looked.
00:01:31 <Axman6> kirindave: yeah you're probably using the top one there. i think you need to use SomeException, but since you're not actually interested in the exception itself, it's difficult to say where the best place to put the type annotation is =)
00:01:37 <Saizan> kirindave: handle (\(SomeException _) -> putStrLn "Fail") (print $ 10 `div` 0) -- this would fix the type
00:01:58 <Axman6> Saizan: oh, that works? i didn't know someException had a constructor...
00:01:59 <Saizan> making you catch all the exceptions
00:02:00 <kirindave> Saizan, ah, that works. :D
00:02:12 <kirindave> Occasionally you just want to fail silently :)
00:02:27 * hackagebot cqrs 0.2.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.2.0 (BardurArantsson)
00:45:51 <Axman6> could Data.Dynamic be used for Erlang style message queues?
00:46:28 <kmc> what are the salient properties of erlang-style message queues?
00:47:15 <Axman6> you can send things of any type, and you pattern match on the values in the queue until you find one that matches what you expect. in haskell, you
00:47:23 <Axman6> you'd use types*
00:47:28 * hackagebot temporary 1.1.2.2 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2.2 (MaxBolingbroke)
00:47:47 <kmc> yeah, you could build that around Dynamic
00:47:56 <kmc> or you can use an existential type, like Exception does
00:48:00 <Axman6> so, you'd have something like: newQueue :: IO Queue, getQueue :: Typeable a => Queue -> IO (Maybe a)
00:48:08 <kmc> i think xmonad also has some dynamically typed messaging
00:48:13 <kmc> yeah
00:48:35 <Axman6> (and of course sendQueue :: Typeable a => Queue -> a -> IO ()
00:48:40 <kmc> and with pattern guards the syntax would be tolerable
00:50:06 <kmc> so getQueue drops a message which doesn't match the type expected by the caller?
00:50:35 <Axman6> well, it traverses the Queue until it finds a message that matches
00:50:47 <Axman6> and removes and returns it
00:51:20 <kmc> seems like it would be easy to accumulate unwanted messages that stick around forever
00:51:28 <Axman6> indeed
00:51:28 <kmc> is the idea that more than one thread is listening on the queue, and they each take things of different types?
00:52:00 <Axman6> what erlang does is garbage collects messages that cannot possibly be received by the thread
00:52:20 <kmc> oh, that will be harder to manage in Haskell
00:52:28 <Axman6> indeed
00:52:33 <Axman6> i
00:52:40 <Axman6> i'm not even convinced it's useful either
00:52:55 <kmc> it sounds odd
00:52:59 <kmc> but maybe it's useful
00:54:00 <Axman6> when you can trivially make an ADT that wraps all the types you expect to receive, make an instance of binary, and just serialise things (assuming you want to send them outside a program)
00:54:16 <qnikst> hello, I have next problem: I want to enumerate Handle and take ByteString messages from it (message is data bettween 0xFE 0xFD bytes)
00:54:34 <Axman6> kmc: i think the only reason they're there in erlang is that it lakcs a type system
00:54:34 <qnikst> can smb advice how can I do it with enumerator package
00:55:23 <gienah> Axman6: remote has erlang like messages
00:56:56 <Axman6> oh, that's just the cloud haskell stuff
00:57:18 <gienah> Axman6: yes: http://www.cl.cam.ac.uk/~jee36/thesis.pdf
00:58:05 <Axman6> i was actually more interested in untyped channels
01:00:43 <Axman6> does anyone else feel that there ought to be a few more Binary classes? I think there should be a standard Binary class, which is generally intended to be derived, and then also classes for things like compact representations of the data
01:00:49 <gienah> Axman6: it seemed to work sending records with remote within the same process, I didn't get that to work sending to other processes though (which would require the serialization stuff to work)
01:01:21 <gienah> Axman6: where by records I mean: http://hackage.haskell.org/package/records
01:08:35 <Saizan> Axman6: gzip the standard one :P
01:09:05 <Axman6> Saizan: heh
01:09:58 <Axman6> when i wrote the TernaryTrees package, i made the binary instance pretty efficient by encoding whether the branches were null or not in the tag byte for each constructor
01:17:14 <_Ray_> Hi. Why is q not an Integer in [m p q (10^7) | p <- (primesToQ 10^7), q <- (primesToQ (div 10^7 p))], when primesToQ :: primesToQ :: (Ord a, Num a, Enum a) => a -> [a]?
01:17:46 <_Ray_> ... precedence of ^. Sigh.
01:20:14 <danr> _Ray_: function application binds stronger than any infix operator
01:32:28 * hackagebot simpleprelude 1.0.1.2 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.1.2 (JeanMarieGaillourdet)
01:38:41 <chrisdone> <kmc> when I make a claim like "foo is fairly common" people keep trying to refute me with single counterexamples
01:38:42 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
01:38:49 <chrisdone> kmc: that's an interesting one :)
01:39:36 <kmc> heh
01:43:42 <chrisdone> kmc: i've complained about the same thing before. seems to happen a lot in presence of point-outers, people feeling the need to point out something. i wonder if there's a name for it. with a name it's easier to dismiss ;)
01:45:17 <chrisdone> kmc: ah, that's why i wanted to speak to you. do you have a kinect then? :D
01:45:50 <kmc> no :/
01:46:02 * chrisdone knows what to get kmc for christmas
01:46:08 <kmc> aww so nice
01:49:06 <Sgeo|web> Can I use arbitrary expressions as operators?
01:49:15 <Sgeo|web> That is, does `liftM2 (+)` make sense?
01:49:32 <kmc> no
01:49:34 <kmc> only names
01:49:44 <Sgeo|web> Oh. So what can I do to get a similar effect?
01:49:50 <chrisdone> sometimes i've wanted that, hehe
01:49:53 <Sgeo|web> Using the liftM2'd (+) as an operator?
01:49:57 <kmc> let f = liftM2 (+)  in  .... `f` ....
01:50:01 <Sgeo|web> :t liftM2 (+)
01:50:02 <chrisdone> Sgeo|web: have to define a local name or operator somewhere
01:50:02 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
01:50:07 <kmc> let (#) = liftM2 (+)  in  .... # ....
01:50:39 <Sgeo|web> And I was just thinking about my realization of how beautiful lifting and <$> and <*> are
01:50:50 <chrisdone> this can be nice x ==~ y where (==~) = (==) `on` map toLower
01:51:21 <Sgeo|web> It's almost like a way to write somepurefunc(someimpurefunc(), someotherimpure()) as easily in Haskell
01:51:34 <Sgeo|web> Except not so nice with operators, beh
01:51:47 <kmc> (+) <$> foo <*> bar
01:52:18 <Sgeo|web> > (+) <$> Just 5 <*> Just 3
01:52:19 <lambdabot>   Just 8
01:52:30 <Sgeo|web> And with pure arguments in the middle, presumably I would just return those
01:52:51 <kmc> this is why the Applicative class has 'pure'
01:53:00 <kmc> but yeah, it's much like 'return'
01:53:13 <Sgeo|web> What fun non-monad Applicatives are there/
01:53:18 <kmc> ZipList
01:53:36 <Sgeo|web> Are all monads Applicative?
01:53:37 <chrisdone> digestive functors
01:53:41 <kmc> Sgeo|web, yes
01:53:49 <chrisdone> (well, they are a monad, but weren't initially)
01:53:50 <kmc> (<*>) = ap; pure = return
01:54:06 <Sgeo|web> ap?
01:54:08 <kmc> Sgeo|web, except sometimes the Applicative instance is missing :/
01:54:12 <kmc> but you can always write it
01:54:13 <kmc> @src ap
01:54:14 <lambdabot> ap = liftM2 id
01:54:17 <kmc> :D
01:54:35 <kmc> @hoogle ap
01:54:36 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
01:54:36 <Sgeo|web> I mean, is ap the monad version of <*>?
01:54:36 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
01:54:36 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
01:54:38 <kmc> yes
01:55:27 <Sgeo|web> So, if I don't want to use the Applicative instance, I would use lift/ap instead of <$>/<*>?
01:55:44 <danr> @type liftM2 ($)
01:55:45 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
01:55:46 <kmc> there's no function 'lift' in this space
01:55:50 <kmc> you'd use fmap and <*>
01:55:57 <kmc> er
01:55:58 <kmc> fmap and ap
01:56:06 <kmc> or liftM and ap
01:56:15 <kmc> it's all a bit of a mess really
01:56:16 <Sgeo|web> Oh, right
01:56:18 <Sgeo|web> :t liftM
01:56:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
01:56:29 <kmc> there's also liftM2, liftM3, etc., exactly analogous to liftA2, liftA3
01:56:38 <chrisdone> i used to use <$> quite a lot but then i found it's a pain in the nads for composing and now mostly use fmap
01:56:46 <erus`> someone should set up a hackage buildbot with cygwin and make the binaries available for windows users
01:56:52 <kmc> you can think of Applicative as the minimal class which supports liftA(n)
01:56:59 <kmc> and Monad adds additional power
01:57:06 <Sgeo|web> I
01:57:17 <Sgeo|web> I'm still thinking through the implications of liftM and ap
01:57:34 <kmc> well, they're the same as the implications of (<$>) and (<*>)
01:57:45 <Sgeo|web> kmc: yes, same implications I'm thinking through
01:58:07 <Sgeo|web> Just, like I said, how they seem to allow easily giving a pure function impure arguments
01:58:09 <kmc> anyway Applicative lets you run a fixed arrangement of computations and combine the results
01:58:13 <kmc> that's what liftA(n) do
01:58:17 <Sgeo|web> (Ok, impure may be the wrong word)
01:58:28 <kmc> Monad lets you run a computation, and use the result to decide what computation to run next
01:58:35 <chrisdone> monad gives the important thing that applicative can't give which is the ability to run parts of the composed value at composition time
01:58:36 <kmc> what's what (>>=) does
01:58:43 <kmc> that's what*
01:58:55 <kmc> so that's the difference
01:59:20 <Sgeo|web> When dealing with IO, is there a preference for <$>/<*> or liftM/ap?
02:00:10 <kmc> don't think so
02:00:18 <kmc> sometimes i'll use fmap just because it's in Prelude
02:00:25 <scalar> tell blackdog Hi Mark
02:00:33 <kmc> but if i'm importing Control.Applicative anyway, i'll use <$>
02:00:42 <kmc> Sgeo|web, so I can write this function for Monad:
02:00:45 <kmc> :t \mb x y -> do { b <- mb; if b then x else y }
02:00:47 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
02:00:51 <kmc> but you can't write it for Applicative
02:00:56 <kmc> you can write something with the right *type*
02:00:56 <scalar> seen blackdog
02:01:04 <kmc> but it will always execute the 'effects' of both branches
02:01:27 <Sgeo|web> kmc: fmap, but what about multiple arguments?
02:01:35 <Sgeo|web> Is there a function in the prelude for that?
02:01:43 <kmc> don't think so
02:01:55 <kmc> you can get ap from Control.Monad, or <*> from Control.Applicative
02:02:03 <kmc> or liftAn/liftMn from eithern
02:02:33 <scalar> preflex: seen blackdog
02:02:33 <preflex>  blackdog was last seen on #haskell 2 hours, 32 minutes and 23 seconds ago, saying: MostAwesomeDude: iteratees are an attempt to get around that in a more principled way
02:02:34 <Sgeo|web> Hmm
02:02:40 <Sgeo|web> Variadic arguments are possible
02:02:49 <kmc> it's harder to come up with an interesting functor which is not applicative
02:02:56 <Sgeo|web> Is there a way to use a similar concept to write a general liftMn?
02:02:58 <kmc> there was a stackoverflow question on this recently
02:03:10 <kmc> variadic arguments aren't really possible
02:03:25 <kmc> you can use type classes to create a family of functions with different arity
02:03:33 <kmc> it's kind of a mess
02:04:05 <kmc> i think your generic liftMn will be even more of a mess, but it might be sorta possible
02:04:11 <kmc> in GHC with the appropriate bells and whistles turned on
02:04:33 <scalar> Not sure of protocol here, but I'd love some help with a noobie question
02:04:46 <kmc> scalar, the protocol is that you ask a question and then we try to answer it :)
02:04:46 <Sgeo|web> The protocol is probably to just ask :)
02:05:54 <scalar> Cool. I'm having some trouble with calculating the length of a vector...
02:06:14 <scalar> The vector is like this:  data Vector = Vector { x :: Int, y :: Int } deriving (Show)
02:06:26 <scalar> ..and the length function is like this...
02:06:35 <scalar> vlength (Vector x y) = sqrt $ x ^ 2 + y ^ 2
02:06:42 <kmc> you can't take the sqrt of an Int
02:06:51 <luite> :t sqrt
02:06:52 <lambdabot> forall a. (Floating a) => a -> a
02:07:00 <kmc> :t \x y -> sqrt $ fromIntegral (x^2 + y^2)
02:07:01 <lambdabot> forall a a1. (Floating a, Integral a1) => a1 -> a1 -> a
02:07:09 <luite> scalar: the argument for sqrt must be an instance of Floating, Int isnt
02:07:16 <kmc> > let f x y = sqrt $ fromIntegral (x^2 + y^2) in f 3 4
02:07:18 <lambdabot>   5.0
02:07:42 <kmc> there are no implicit type conversions in Haskell
02:08:02 <scalar> Ah! OK, that looks good. Many thanks.
02:08:06 <kmc> :)
02:08:22 <kmc> nice username / question combo, by the way
02:09:34 <scalar> *Geometry> :t fromIntegral
02:09:34 <scalar> fromIntegral :: (Num b, Integral a) => a -> b
02:09:58 <scalar> ...so how is it that fromIntegral works when you pass the result to sqrt
02:10:10 <scalar> Does'nt sqrt take a Floating?
02:10:19 <luite> :t fromIntegral
02:10:20 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:10:41 <luite> :info Floating
02:10:42 <Sgeo|web> scalar: fromIntegral is capable of returning a Floating
02:10:53 <scalar> Oh, I see
02:11:05 <luite> scalar: anyway, it means that it can convert any Integral a, to any Num b
02:11:15 <luite> and Floating implies Num
02:11:33 <luite> err, does it?
02:11:33 <luite> probably :p
02:11:36 <scalar> ... and it returns a Float in this case because that's what sqrt needs?
02:11:52 <Sgeo|web> scalar: Float is not the same as Floating
02:11:59 <scalar> Oh, yeah.
02:12:01 <Sgeo|web> Floats are Floating, but Doubles are also Floating
02:12:27 <scalar> So how does fromIntegral know to return a Floating?
02:12:46 <Sgeo|web> Because the type of sqrt requires it
02:13:03 <blackdog> scalar: if it couldn't, you'd get a type error at compile time
02:13:15 <scalar> Cool. I get that now. Thanks.
02:13:31 <vharishankar> I have a conceptual question: how important is it to learn the type system (including defining own types) in progressing with Haskell.
02:13:41 <opqdonut> very
02:13:45 <scalar> Hey blackdog, I have followed your advice after we exchanged emails a little while ago.
02:13:49 <blackdog> it's a neat feature - i don't think you can replicate it (return type polymorphism) in an OO setting
02:14:25 <scalar> I bought Learn You a Haskell and Real World Haskell
02:14:40 <scalar> ... and I joined this IRC channel
02:14:49 <scalar> Thanks for the kickstart
02:14:53 <kmc> blackdog, why not? or what definition of "OO setting" are you using
02:15:04 <taruti> When writing a library with lots of callback does it make more sense to use a record of functions or a class in general?
02:15:14 <kmc> vharishankar, it's important that you learn how to define your own types, once you have reached the point where it is important to learn how to define your own types
02:15:15 <blackdog> scalar: ... ah, you're david pinn. Great!
02:15:26 <kmc> taruti, classes are harder to work with
02:15:28 <opqdonut> taruti: a record of functions (aka "dictionary passing") is pretty standard
02:15:31 <vharishankar> Real World Haskell is good.
02:15:31 <kmc> they're not first-class
02:15:33 <scalar> Yep, that's me.
02:15:38 <opqdonut> and they beat classes in many ways
02:15:42 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
02:15:52 <taruti> ok :)
02:15:53 <kmc> unnecessary use of classes is common in Haskell
02:15:56 <scalar> I'm fiddling around with vector calculus in Haskell
02:16:02 <vharishankar> kmc: does types aid in understanding the more complex stuff?
02:16:06 <kmc> yes
02:16:09 <vharishankar> like monads
02:16:37 <kmc> monads aren't complex
02:16:41 <vharishankar> Reading RWH now. It is filling in the gaps of my self-learning. I'm going back to square one for the moment.
02:16:53 <kmc> monads are simple but abstract
02:16:57 <kmc> that is very different from complex
02:17:16 <blackdog> kmc: it's an argument from personal incredulity :) I can't see how to do it in statically typed OO, anyway. i guess with a dynamic OO system you can just have implicit conversions defined
02:17:27 <vharishankar> kmc: agreed. I couldn't find a simple one-liner to describe the concept though... and I searched a lot.
02:17:44 <opqdonut> kmc, excellent link
02:19:19 <kmc> blackdog, what does a static OO system have that Haskell doesn't?
02:19:27 <kmc> subtyping? funny syntax for the first argument to a function?
02:19:38 <_Ray_> vharishankar, you want to call functions inside a context, and put values in an empty context. A monad lets you do both: You have a join, that given a Context (Context Foo) gives you a Context Foo (meaning, it "merges" the contexts in some way), and a return, which gives you a blank Context for a given value.
02:19:55 <kmc> return-type polymorphism is a natural consequence of unification-based type inference
02:20:11 <kmc> which is compatible with subtyping; see for example OCaml and Scala
02:20:15 <kmc> though there are various quirks
02:20:24 <kmc> Scala's inference doesn't work that well, but it definitely exists
02:20:30 <_Ray_> Subtyping doesn't do too well with Hindley Milner, does it?
02:20:31 <vharishankar> _Ray_: I'll copy your answer and try to figure that out at leisure. Thanks.
02:20:38 <blackdog> kmc: the presence of subtyping seems to imply that you don't get proper global inference
02:20:48 <kmc> in fact I hear they just redid the standard collections library to make extensive use of return-type polymorphism
02:20:54 <blackdog> gah, imply's the wrong word.
02:21:35 <blackdog> i think what i'm getitng at is that rippling effect you get, not only on arguments on the way down, but return values on the way up.
02:22:13 <blackdog> you still get it, of course, but it's less helpful as a design tool if you have to annotate your function types everywhere
02:22:26 <kmc> you're still assuming inference is incompatible with subtyping
02:22:29 <kmc> you haven't explained why
02:22:51 <kmc> the combination is much-studied, and has been used in practical languages
02:23:14 <yitz> vharishankar: have you been following the lively comments about your blog post on reddit? i haven't seen you respond.
02:23:16 <kmc> but I haven't read the literature or used those languages myself
02:23:26 <vharishankar> yitz: I didn't see yet.
02:23:31 <vharishankar> Is it on redditt????
02:23:41 <yitz> vharishankar: http://www.reddit.com/r/haskell/comments/lv84d/why_learning_functional_programming_and_haskell/
02:23:45 <blackdog> kmc: yes, i am. can you point me to a language that combines them? I've looked at Scala and the type annotation on functions disqualifies it for me
02:23:55 <blackdog> i've used Ocaml, but never the object features
02:24:25 <kmc> scala requires annotations on functions?
02:24:32 <blackdog> kmc: yeah
02:24:36 <blackdog> well, on top level funcitons
02:24:44 <kmc> what's special about top-level functions?
02:24:59 <blackdog> not a clue.
02:25:13 <kmc> that sounds like they have inference, and have just decided to enforce as a rule what's common practice in Haskell too
02:25:18 <kmc> anyway I don't know Scala
02:25:27 <vharishankar> yitz: thanks for the link. I'll read and respond if I have anything to say. :-)
02:25:31 <yitz> vharishankar: it is still near the top of the haskell reddit: http://www.reddit.com/r/haskell/
02:25:54 <kmc> derp do i want to read this or not
02:26:21 <vharishankar> yitz: thanks for submitting my article. much appreciated. :-)
02:26:28 <blackdog> kmc: it's a consequence of subtyping, as far as i'm aware
02:26:44 <yitz> vharishankar: my pleasure. it's a big hit!
02:26:44 <blackdog> of their implementation of subtyping, anyway
02:26:47 <blackdog> http://pchiusano.blogspot.com/2011/05/making-most-of-scalas-extremely-limited.html
02:27:12 <vharishankar> yitz: Glad to interest the Haskell community! :-)
02:27:12 <blackdog> kmc: in particular "Type information in Scala flows from function arguments to their results (when the types of a function's arguments are known, that type information will flow into the body of the function), from left to right across argument lists, and from first to last across statements. This is in contrast to a language with full type inference, where (roughly speaking) type information flows unrestricted in all directions"
02:27:43 <kmc> ok
02:27:55 <vharishankar> I found it daunting at first, but this community is very friendly to newcomers.
02:30:40 <kmc> has someone read the reddit thread? are there particularly novel things being said?
02:32:38 <yitz> kmc: continuing the theme of the blog - what points about haskell put off newbies and why, how those compare to what puts off newbies in other languages.
02:33:17 <kmc> such discussions by Haskell experts tend to be highly speculative
02:33:49 <kmc> also people don't agree on what the end goal is, but don't acknowledge this fact
02:33:59 <kmc> leading to a disconnect between the elitists and the evangelists and everyone in between
02:34:06 <yitz> kmc: right. a number of genuine newcomers, besides the blogger, are contributing though. that adds some genuineness.
02:35:05 <Ikarus> the problem for most people with haskell is that it's miles between solving a problem and slapping a newbie proof UI on the resulting code :)
02:35:28 <Ikarus> (atleast that is what I heard from people in class)
02:35:30 <yitz> kmc: it takes effort to keep focused on the newcomers' perspective in order to communicate well
02:35:50 <yitz> kmc: and for newcomers it's useful to hear some different views about what to watch out for
02:36:52 <yitz> kmc: so it's good to have a discussion like that every once in a while (but too much becomes navel meditation after a while)
02:38:02 <yitz> Ikarus: right now the best UI direction is web programming.
02:38:26 <vharishankar> I got disconnected. My apologies if anybody responded to me earlier.
02:38:32 <yitz> Ikarus: which is gradually converging with other kinds of UI, so that's good.
02:39:23 <Ikarus> yitz: even sticking that on a Haskell program is far more effort then in many other languages and less often explained
02:40:03 <yitz> Ikarus: i don't think it's more effort. i believe you that it's less explained as of now.
02:40:19 <Ikarus> well, it seems more effort
02:40:27 <Ikarus> which is as bad  :)
02:41:16 <yitz> Ikarus: it's like the rest of haskell. strong typing is very powerful and actually makes things much easier, but it looks harder at first because it's so different from what you're used to.
02:41:23 <flux> yitz, what do you mean by best direction?
02:42:04 <flux> yitz, for example, I've been pretty impressed by Qt QML, if the purpose is to make a pretty, usable user interface
02:42:05 <yitz> Ikarus: although besides strong typing, the web frameworks are very much based on the frameworks in other popular language and work pretty much the same way.
02:43:07 <Ikarus> yitz: problem is that I actually like haskell enough already to bother learning the rest
02:43:08 <yitz> flux: well just about every platform is moving away from those old style desktop GUI frameworks and moving towards HTML 5.
02:43:29 <flux> yitz, and HTML 5 gives the best user interface?
02:43:40 <yitz> flux: there is some decent support at various times for the GUI frameworks, but it's so much work to keep up with them.
02:44:00 <_Ray_> How could I make my "main" function print a list of things? Something like do [print $ mysum (10^n) | n <- [0..7]], but less dumb :p Should I use something like liftM?
02:44:14 <mroman> "old style"?
02:44:17 <Saizan> mapM_
02:44:19 <vharishankar> yitz: I hope that the traditional desktop remains in style.
02:44:33 <yitz> flux: i don't about best at this time, but it's quite well supported already on most platforms, and getting better, whereas the old approach is officially deprecated to some degree just about everywhere.
02:45:27 <yitz> flux: e.g. windows 8 will use metro as its main ui, with .NET supported as legacy. supposedly.
02:45:29 <damowe> hello, is there any document/page with Haskell coding standards?, for example is there a prohibition on using multiparameter type classes? (thanks in advance)
02:46:12 <kmc> :t mapM_ print
02:46:13 <lambdabot> forall a. (Show a) => [a] -> IO ()
02:46:15 <yitz> flux: apple is emphasizing html 5 more now to create harmony with iOS. etc.
02:46:52 <yitz> flux: apple on mac os x that is
02:47:59 <yitz> vharishankar: it will be around for a long time i think as a legacy platform
02:48:07 <vharishankar> Another small question. I am yet to figure out what <- operator does precise (does it bind a value to a symbol)
02:48:19 <yitz> vharishankar: you can still write and run applications in cobol today
02:48:29 <vharishankar> yitz: traditional desktops are more configurable and flexible.
02:48:44 <vharishankar> From what I've seen the trend is to "Dumb down" everything to the level of a smartphone.
02:49:03 <mroman> I actually don't get the decision to move to HTML 5 for desktop applications.
02:49:12 <yitz> vharishankar: yes it binds a value to a symbol in monadic expressions - do blocks and list comprehensions
02:49:26 <Philonous> vharishankar:  It's not an operator and it doesn't "do" anything, it's syntactic sugar. "a <- foo" get's translated to "foo >>= \a -> ... "
02:49:43 <flux> yitz, isn't the only way to build new widgets in HTML5 to provide your own function to draw it into a canvas?
02:49:51 <flux> yitz, if so, it's already behind QML right there ;)
02:50:04 <yitz> flux: i'm sure that will change
02:50:09 <rotflcopter> hiiiii
02:50:10 <vharishankar> Philonous: Ah, I'm a bit bewildered there, but anyway, let me take it one step at a time. :-)
02:50:11 <rotflcopter> :)
02:50:14 <rotflcopter> im back
02:50:21 <mroman> If in the future, the only application installed in my os is a browser
02:50:22 <flux> yitz, well, I can certainly hope so
02:50:30 <mroman> and everything runs in the browser, whats the difference?
02:50:34 <flux> (because qt's future doesn't seem that bright at least on the mobile side)
02:50:44 <mroman> between everything runs in the browser and everything runs "native".
02:51:03 <Philonous> vharishankar:  Ah, well, as a first approximation it binds the result of the computation on the right side to the name of the left
02:51:30 <rotflcopter> so heres my circle
02:51:32 <rotflcopter> sqr f=f*f;doc r xy=sqrt((sqr(r))-(sqr(xy)));circlefirstoctant r =[ (round xy,round(doc r xy)) | xy <- [1.0,2.0 .. r/sqrt(2)]]
02:51:32 <rotflcopter> mirroroctant [] = []; mirroroctant ((a,b):x) = (b,a):(a,b):(mirroroctant x)
02:51:32 <rotflcopter> firstquadrant r = init (mirroroctant (circlefirstoctant r))
02:51:41 <rotflcopter> afullcircle [] = []; afullcircle ((a,b):x) = (a,b):(a,-b):(-a,-b):(a,-b):(afullcircle x)
02:51:41 <rotflcopter> perfectfullcircle r = (0,round r):(round r,0):(0,round (-r)):(round (-r),0):(afullcircle (firstquadrant r))
02:51:48 <vharishankar> Philonous: thanks. And if it is inside a do block, this has to correspond to the type of the function, right?
02:51:55 <hpaste> rsp2k pasted “add Timestamp” at http://hpaste.org/53434
02:52:00 <yitz> vharishankar: it does do something - as you say, it binds. but it's not a primitive, it binds by being translated into something else by the compiler.
02:52:21 <rotflcopter> rasterized circle
02:52:49 <kmc> rotflcopter, you should put code of more than a few lines on hpaste.org
02:53:01 <vharishankar> yitz: right. So trying to do something like a <- 5 in a main block won't work. But I am yet totally not sure why.
02:53:05 <rotflcopter> i have website too but i was lazy ;<
02:53:20 <mroman> vharishankar: 5 is not (Monad m) => m 5?
02:53:42 <vharishankar> mroman: yes, I am just beginning to understand a little about that.
02:53:43 <yitz> vharishankar: the right-hand side needs to be a value in the type of the monad.
02:53:47 <Philonous> vharishankar:  In "x <- foo" f hast to have type (m a) for the appropriate monad and x has type a.
02:54:04 <rotflcopter> so this should be correct circle without any duplicate entries
02:54:19 <vharishankar> Philonous and yitz - thanks. I guessed so.
02:54:19 <Philonous> vharishankar:  If you want to bind a value to a name without any effects you would write "let a = 5" as a line
02:54:23 <rotflcopter> for r>4
02:54:54 <vharishankar> Philonous, that doesn't work inside a do block, will it?
02:55:08 <Philonous> vharishankar:  Yes it does, just leave out the "in"
02:55:43 <hpaste> “Lev Broido” pasted “Loops in graph” at http://hpaste.org/53435
02:55:47 <kmc> vharishankar, did you get to the bit about <- and 'do' and monads in your tutorial yet?
02:56:10 <vharishankar> kmc: I read the chapter on IO in LYAH.
02:56:35 <kmc> ah ok
02:56:41 <vharishankar> I am guessing I understood imperfectly what "do" is for...
02:56:53 <vharishankar> I read that as "sequential execution" but I might be wrong.
02:56:57 <kmc> did you also see http://www.haskell.org/haskellwiki/Introduction_to_IO
02:57:06 <kmc> vharishankar, in the case of IO it is sequential execution
02:57:26 <kmc> the 'do' syntax is more general and can be used for other types besides IO
02:57:30 <mroman> If I'm correct then
02:57:36 <mroman> do{a <- return 5; b <- return 6; putStrLn.show$a+b}
02:57:40 <mroman> is syntactig sugar for
02:57:48 <mroman> return 5 >>= (\x -> return 6 >>= (\y -> putStrLn.show$x+y))
02:57:54 <vharishankar> kmc: the tutorial says "An action on its own on a line in a do-block will be executed, and a line of the form v <- x will cause the action x to be run, and the result bound to the variable v. "
02:57:57 <kmc> @undo do{a <- return 5; b <- return 6; putStrLn.show$a+b}
02:57:58 <mroman> @type (>>=)
02:57:58 <lambdabot> return 5 >>= \ a -> return 6 >>= \ b -> putStrLn . show $ a + b
02:57:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:58:02 <kmc> vharishankar, yeah
02:58:23 <kmc> vharishankar, except, nothing is really executed in an absolute sense... you're building up a description of IO which could be performed
02:58:34 <kmc> the article I linked explains that, and is short
02:59:00 <vharishankar> kmc: yes, I am reading it again now.
02:59:03 <kmc> the "do" syntax lets you build IO actions out of other IO actions
02:59:11 <mroman> and (>>=) requires a (Monad m) => m a, which is why a <- 5 does not work.
02:59:13 <kmc> the only IO action which gets run is 'main', or one you type at the GHCi prompt
02:59:41 <rotflcopter> heres my AA extension that fails to print integers :(
02:59:43 <vharishankar> kmc: so would you say that functions that have a "do" block are tainted in haskell terms?
02:59:48 <kmc> no no no
02:59:51 <mroman> :D
02:59:51 <rotflcopter> let aa [] i=[];aa [a,b] i = if abs (intdif i) > (1/256) then (if (intdif i)>0 then [[fromIntegral (round a),fromIntegral (round b),1-intdif i],[fromIntegral (round a),fromIntegral (round (b)+1),intdif i]] else [[fromIntegral (round a),fromIntegral (round b),1+intdif i],[fromIntegral (round a),fromIntegral (round (b)-1),-intdif i]]) else [[fromIntegral (round a),fromIntegral (round b),1.0]]
03:00:01 <yitz> vharishankar: a monad specifies an algorithm as a sequence of steps. but the compiler is not forced to "execute" the steps, it translates your algorithm into a pure function and can then do things whichever way it thinks is best.
03:00:13 <mroman> vharishankar: do is just syntactic sugar.
03:00:18 <rotflcopter> let sqr f=f*f;doc r xy=sqrt((sqr(r))-(sqr(xy)));circlefirstoctant r = [aa [fromIntegral (round xy),fromIntegral (round (doc r xy))] (doc r xy) | xy <- [1.0,2.0 .. r/sqrt(2)]]
03:00:19 <mroman> do makes code more readable.
03:00:21 <kmc> i think what yitz said is wrong and confusing
03:00:32 <yitz> vharishankar: in the IO monad that usually does mean "executing" the steps and their side effects in order, though.
03:00:36 <rotflcopter> concat (circlefirstoctant 11)
03:00:37 * ddarius agrees with kmc.
03:00:37 <kmc> vharishankar, you won't understand IO if you think about it as tainted 'impure' functions
03:00:37 <levkin> hi
03:00:49 <vharishankar> kmc: OK.
03:00:49 <Tinned_Tuna> kmc: I think it is probably confusing.
03:00:50 <rotflcopter> someone sees errors?
03:00:51 <yitz> tainted?
03:00:59 <kmc> vharishankar, you're building an imperative program as a first-class value
03:01:04 <kmc> it's an ordinary pure Haskell value like any other
03:01:06 <kmc> it's not "tainted"
03:01:19 <levkin> need help in debug : http://hpaste.org/53435
03:01:21 <rotflcopter>  helping visualization http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
03:01:23 <yitz> kmc: no it is not an imperative program at all. it is a pure function.
03:01:26 <Tinned_Tuna> but a compiler/interpreter/thing can re-order things as it pleases <-> the end result is the same
03:01:46 <kmc> yitz, that's factually incorrect, a value of type (IO T) is not a function of any sort
03:02:04 <Philonous> vharishankar:  No, there is nothing tainted about it. Do is just a nice way to combine values of a certain form, for example actions with side effects (which, in haskell, are first class values that you can pass around, store in a variable or combine on-the-fly)
03:02:04 <Tinned_Tuna> I would say exactly the same thing about C.
03:02:13 <yitz> kmc: a fucntion that returns a value of type IO T is 100% a pure function, first class.
03:02:22 <levkin> I don't get all 'children' of  a node printed -- in test2
03:02:33 <Tinned_Tuna> for example, x=x+1 ; y=y+1; printf("%d, %d\n",x,y); is the same as y=y+1; x=x+1; printf...
03:02:33 <kmc> yitz, yes, but the return value is not a function
03:02:38 <yitz> kmc:  it's very confusing to say otherwise
03:02:41 <vharishankar> Philonous: thanks.
03:02:44 <mroman> IO is actually a type constructor, but it's not exported.
03:02:49 <kmc> yes it is
03:02:52 <kmc> the data constructor is not
03:02:59 <kmc> yitz, you and I each think the other person said the same, wrong thing
03:03:04 <kmc> obviously there is just some miscommunication
03:03:15 <kmc> IO actions are imperative programs
03:03:24 <yitz> kmc: that's why we need vharishankar's blog post :)
03:03:26 <mroman> There is a difference between type and data constructors?
03:03:29 <kmc> functions which return IO actions are functions which return imperative programs
03:03:31 <kmc> mroman, yes
03:03:33 <kmc> data Foo = Bar Int
03:03:37 <vharishankar> I actually read this article: http://lukeplant.me.uk/blog/posts/understanding-monads-via-python-list-comprehensions/
03:03:38 <kmc> Foo is a type constructor, Bar is a data constructor
03:03:39 <augur> anyone know of any research on finding "taxonomies"?
03:03:48 <augur> or "ontologies" or whatever you want to call it
03:03:48 <augur> ?
03:03:57 <mroman> Ok. Wasn't familiar with that terminology.
03:04:07 <vharishankar> Is that a good way to approach the whole topic of monads?
03:04:12 <kmc> probably not
03:04:17 <kmc> why don't you read your haskell tutorial
03:04:18 <mroman> hm.
03:04:21 <kmc> and get to the chapter about monads in LYAH
03:04:22 <yitz> kmc: ok but monadic values are usually not. just IO. so "monad" really has nothing to do with imperativity at all.
03:04:24 <kmc> which is very well-regarded
03:04:34 <kmc> and which, more importantly, comes at the end of a bunch of other chapters about a bunch of other important crap
03:04:37 <kmc> yitz, also agreed
03:04:41 <mroman> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
03:04:47 <kmc> LETS LINK ALL TEH MONAD TUTORIALZ
03:04:48 <augur> monads are great :D
03:04:57 <Tinned_Tuna> I like to think of the IO Monad as a special case (sort-of)
03:05:17 <yitz> augur: thanks. you just wrote a one line monad tutorial.
03:05:17 <mroman> kmc: That wouldn't be possible ;)
03:05:24 <kmc> IO is special because the runtime system has a baked-in interpreter for IO values
03:05:24 <Philonous> It's so special it's not even a monad :>
03:05:25 <augur> yitz: i try!
03:05:29 <vharishankar> kmc: thanks. I guess the temptation is to jump ahead, because "monads" keep coming up frequently :)
03:05:38 <kmc> vharishankar, yes, please ignore the hype
03:05:45 <Tinned_Tuna> Monads are all hype
03:06:00 <augur> yitz: tho i think the best one line monad tutorial is the one aimed at category-theory-familiar programmers: monads are monoids in the category of endofunctors
03:06:02 <augur> :D
03:06:11 <vharishankar> kmc: I'm actually going to familiarize myself with the types...
03:06:12 * yitz likes augur's one-line monad tutorial better than Tinned_Tuna's
03:06:14 <frerich> kmc: Would it be fair to say that IO is no more special than a custom monad which happens to use FFI behind the scenes?
03:06:16 <mroman> but "You Could Have Invented Monads!" is the only monad tutorial I was able to at least partially understand.
03:06:17 <augur> once i really started learning CT that make amazing sense
03:06:29 <mroman> Except the one-liner tutorial: "A monad is a type class."
03:06:44 <kmc> frerich, you couldn't write the interpreter for IO in Haskell unless you already had IO
03:06:52 <vharishankar> kmc: and recursive types...
03:06:57 <Tinned_Tuna> Monads are definitely easier to understand after studying basic groups/semi-groups/monoids. They just appear as another algebraic structure, complete with laws
03:07:02 <kmc> i disagree
03:07:32 <Tinned_Tuna> except I've yet to prove to myself that the monad laws "make sense". They do seem to, but I've yet to read a proof of it :-p
03:07:52 <Tinned_Tuna> kmc: with my statement, or vharishankar's ?
03:07:56 <kmc> with yours
03:07:57 <augur> Tinned_Tuna: the monad laws of course make sense
03:08:10 <augur> they're definitional!
03:08:17 <Tinned_Tuna> augur: I'm not saying they don't, I'm saying I haven't given them a rigorous treatment.
03:08:21 <ddarius> Tinned_Tuna: A proof of what?  They are given by definition.  Basically the only way they could not make sense is if there were no monads.
03:08:22 <mroman> Tinned_Tuna: If you have the background to study semi-groups (whatever that is)
03:08:23 <yitz> augur: to use monads well in practice, you need to get why a container is really the same thing as an algorithm specified as a sequence of steps. if the CT gives you that, then great.
03:08:30 <kmc> frerich, data IO t = PutChar Char (IO t) | GetChar (Char -> IO t) | Return t
03:08:39 <augur> yitz: i dont see why thats the case at all
03:08:39 <kmc> here's an ordinary haskell data type
03:08:52 <yitz> augur: back to CT with you then
03:08:58 <kmc> you can write «instance Monad IO» for it
03:08:59 <Tinned_Tuna> And you can define somethings which are simply contradictory. Definitions can lead to unsound structures.
03:09:04 <augur> no i mean i dont see why you need to think of containers as algorithms
03:09:08 <kmc> and you can implement putChar and getChar
03:09:10 <ddarius> yitz: A monad isn't a container.
03:09:46 <kmc> frerich, but you have no way of going from these descriptions of IO to actually performing IO
03:09:54 <ddarius> Tinned_Tuna: If the definition was contradictory, then it would simply mean there are no monads.
03:10:14 <kmc> conceptually, the runtime system has some code, written not in Haskell, which pattern-matches on such an IO value, and actually performs the IO described
03:10:28 <vharishankar> I'm reminded of the famous Sherlock Holmes dialogue.
03:10:29 <vharishankar> when you have eliminated the impossible, whatever remains, however improbable, must be the truth?
03:10:38 <augur> so does anyone know about taxonomy discovery?
03:10:53 <yitz> ddarius: http://haskell.org/haskellwiki/Monads_as_Containers
03:11:11 <frerich> kmc: Hm, I guess IO is special in that the function which 'executes' the main action is baked into the RTS (unlike, say, the 'maybe' function which 'executes' as well). A custom monad could have a custom 'execute' function of course which uses FFI, but this function itself must be written in Haskell.
03:11:11 <augur> yitz: just because theres a thing on the wiki doesnt make it true
03:11:22 <yitz> augur: Cale wrote it, so it's true
03:11:32 <augur> yitz: cale wrote it for people like you
03:11:46 <ddarius> yitz: I'm aware of that.  It's wrong.  This is evident in the article itself as it continually stretches the meaning of "container."  It only makes any kind of sense if you define "container" as functor.
03:11:47 <yitz> augur: ok.
03:12:00 <Tinned_Tuna> ddarius: there could be something which we would call monads, there would just be some things which were undefined in those "monads". Similarly, if you have a "group", but not all of the laws hold, it's not a group.
03:12:15 <kmc> frerich, how do you write the 'execute' function for IO in Haskell, even with FFI?
03:12:17 <augur> yitz: (a ->) is obviously not a container
03:12:29 <frerich> kmc: Yeah, you can't, that's what I mean.
03:12:34 <kmc> frerich, ah okay :)
03:12:41 <frerich> kmc: For IO, it's impossible AFAICS.
03:13:01 <frerich> (Not a bad thing, just means that IO is kinda special)
03:13:02 <kmc> augur, sure, it's a container whose indices have type a
03:13:19 <augur> kmc: well ok true enough :)
03:13:38 <kmc> but I agree that the "monads are containers" analogy is limited
03:13:40 <kmc> it *is* an analogy
03:13:42 <kmc> it has its use
03:13:47 <kmc> it's better than "burrito"
03:13:49 <kmc> but it's not perfect
03:13:52 <frerich> :-)
03:13:53 <augur> mmm burritos
03:14:01 * augur eats kmc's monads
03:14:20 <kmc> :O
03:14:53 <augur> edwardk: syn
03:15:18 <frerich> After lurking here for some months, it became apparent to me that there's no single useful perspective on monads which actually is correct in all cases, simply because a 'monad' is such a generic concept. I think it's fine to have the 'monad as container' and 'monad as computation' and whatnot perspective. If you digest a few of such articles, a pattern will emerge in your brain.
03:15:32 <augur> frerich: sure there is: Category Theory
03:15:53 <augur> the problem is that people dont want to learn CT just to understand monads in haskell
03:15:54 <kmc> frerich++
03:16:00 <augur> well boo to them!
03:16:21 <kmc> every person who asks "what *are* monads, really?!?" should listen to frerich :)
03:17:00 <augur> i think the catsters videos on monads are pretty nice
03:17:15 <augur> or maybe i just enjoy listening to eugenia lecture
03:24:29 <augur> D:
03:24:29 <augur> kmc: o hai
03:24:29 <augur> AT LEAST IVE STILL GOT YOU
03:24:30 <kmc> hi augur
03:24:30 <augur> kmc: do you know anything about taxonomy discovery?
03:24:54 <kmc> no :(
03:25:28 <augur> :\
03:27:08 --- mode: verne.freenode.net set +o Igloo
03:29:05 <kmc> hmm I wrote the Monad instance for that CPS'd IO i sent to frerich
03:29:05 <kmc> it's a *lot* easier to write 'join' than (>>=)
03:29:06 <yitz> ddarius: to know the CT side of monads is very nice, it's beautiful. but for writing programs in real-life, usually you either think about the monad operations as an abstraction of the kinds of operations you can do on containers, or as a way to specify some kinds of algorithms stepwise, or a combination of the two.
03:29:08 <ddarius> yitz: No.
03:29:08 <Saizan> kmc: how's the type defined?
03:29:09 <kmc> data IO t = PutChar Char (IO t) | GetChar (Char -> IO t) | Return t
03:29:09 <kmc> i first saw this here but I don't remember from whom :/
03:29:17 <yitz> ddarius: if you know enough about them to understand why those two kinds of uses are really the same thing, that's enough to use them in practice in most situations. you're not required to know more theory than that.
03:29:46 <yitz> ddarius: ok you don't. just about everyone else does who writes practical haskell programs.
03:29:47 <ddarius> yitz: They are not the same thing.
03:29:57 <ddarius> yitz: I disagree.
03:30:00 <augur> yitz: i find its nicer to think of them as values-with-certain-assumptions
03:30:05 <kmc> that's quite bold, making a claim about almost all haskell porgarmmers
03:30:07 <yitz> kmc: Cale i think.
03:30:22 <yitz> kmc: yes. quite bold. :)
03:30:31 <augur> yitz: set monads being superpositions of values, reader monads being values under some parameter
03:30:33 <augur> etc
03:31:20 <kmc> I've previously used the GADT "free monad" for IO
03:31:22 <augur> and you just forget the details and think about how these values-with-assumptions should play out, when using the monads
03:31:35 <kmc> it's closer to the point I'm making with it, but you have to know how GADTs work
03:31:39 <ddarius> yitz: If you know enough to understand how monads and burritos are the same thing, that's enough to use them in practice in most situations.  For writing programs in real-life, you usually think in terms of burritos.  Understanding their connection to computation is a nicety.
03:32:14 <yitz> ddarius: i don't know what a burrito is. (is it like a monad?)
03:33:01 <augur> yitz: a burrito is a flour tortilla filled with meat and beans and cheese and rice
03:33:19 <yitz> augur: yes. and those certain-assumptions usually fall into one of those two realms, or a combination
03:33:27 <augur> equipped with certain assumptions about how burritos can be made into megaburritos
03:33:42 <kmc> i hear they have this new 'sushirito' concept
03:33:48 <kmc> it's a sushi roll the size of a burrito
03:34:07 <yitz> sushi meets godzilla
03:34:08 <arcatan> no-one actually uses burritos monadically
03:35:42 <augur> ive occassionally eaten an applicative burrito
03:36:39 <yitz> ddarius: burritos have no (obvious) connection to programming. containers do. so do algoritms specified as steps.
03:37:36 <augur> yitz: i still dont see how youre getting algorithms specified as stepps
03:37:39 <kmc> i should make a bot which joins #haskell once every few hours and asks "so, what's the best way to explain monads"
03:37:49 <kmc> and this will ruin all productivity
03:37:56 <kmc> then my secretly favored language will win
03:37:58 <augur> kmc: i will remember this
03:38:10 <augur> so that when you do this, i can inform the ops who is responsible
03:38:17 <augur> and then you will be banned forever!
03:38:18 <augur> MWAHAHA
03:38:20 <ddarius> yitz: Maybe you just don't understand their connection to programming.
03:38:28 <vharishankar> kmc: will the bot be written in haskell?
03:38:46 <yitz> ddarius: i understand the connection of pizza to programming. is it similar?
03:38:48 <kmc> PHP
03:38:54 <ddarius> yitz: But I'll agree with you, monads are sorting algorithms.  Sorting algorithms certainly have a clear connection to programming.
03:38:55 <Tinned_Tuna> kmc: to avoid detection, it should create random, real-looking nicks.
03:39:08 <augur> ddarius: how are monads sorting algorithms?
03:39:11 <vharishankar> kmc: :-)
03:39:14 <erus`> vharishankar: no python
03:39:24 <Tinned_Tuna> yitz: Algorithms *can* be specified as a series of steps. That doesn't meant that they have to be.
03:39:27 <ddarius> augur: Because sorting algorithms are related to programming.  Therefore monads are them.
03:39:35 <augur> hahaha
03:39:46 <jtannenbaum> be sure to write the python IRC bot from scratch
03:39:53 <jtannenbaum> go to #python and refuse to consider Twisted
03:39:56 <yitz> Tinned_Tuna: certainly. just certain kinds of algorithms are more naturally expressed that way.
03:39:59 <kmc> haha
03:40:08 <jessopher> monads are a series of tubes
03:40:23 <jtannenbaum> try to convince them that "reinventing the wheel is education" applies
03:40:25 <jessopher> inside a burrito
03:40:43 <yitz> jtannenbaum: tell them you're using twisted but things seem to be happening in the wrong order
03:40:58 <Tinned_Tuna> yitz: yes, but it seems that you're arguing that some algorithms can only be expressed as a series of steps; which I disagree with.
03:41:06 <jtannenbaum> monads are just trinads minus dunads
03:41:10 <yitz> Tinned_Tuna: no i'm not saying that at all
03:41:46 <augur> Saizan: ping
03:41:47 <kmc> "In the novel The World Inside by Robert Silverberg, almost a hundred billion humans live in megastructure skyscrapers called monads"
03:41:54 <Saizan> augur: pong?
03:41:55 <Tinned_Tuna> kmc: O.O
03:41:59 <Tinned_Tuna> augur: echo
03:42:15 <augur> Saizan: can i pick your brain on something?
03:42:30 <arcatan> monads are just like mathematical structures!
03:42:34 <jtannenbaum> you've already chosen it
03:42:46 <Saizan> augur: only if you've a clear and short question :)
03:42:50 <augur> :P
03:42:51 <jtannenbaum> a monad is a programmible megastructure
03:42:55 <yitz> Tinned_Tuna: i am saying that there are certain classes of algorithms for which at least one very natural way of specifying them is as a series of steps and for which a monad gives you a way to do that.
03:43:09 <jessopher> arcatan: softdrinks are just like beverages!
03:43:16 <jtannenbaum> it uses foursquare API
03:44:09 <vharishankar> I appreciated all the comments on the reddit link. Thanks for all your thoughts (to all those from #haskell)
03:45:55 --- mode: verne.freenode.net set +o ChanServ
03:46:30 <Tinned_Tuna> yitz: You don't need monads to make functional programs appear to have a series of steps; there's a good chance that if you abstract what you're doing you'll make something similar to monads, but I don't think that's the point of monads.  Moving on, I should really be working. I've been at work for an hour and only created a branch for the new feature...
03:46:53 <yitz> Tinned_Tuna: seconded :)
03:48:13 <yitz> Tinned_Tuna: you don't *need* them. but they are a great way of doing it, with principled axioms and syntax support.
03:49:07 <int-e> Tinned_Tuna: think positive - you've already been productive -- you've created *something*
03:49:54 <yitz> int-e: as a darcs user, i don't think of creating a branch as being productive :)
03:51:40 <mm_freak> what's an easy, portable way to determine the UTCTime of the program's start?
03:52:10 <Tinned_Tuna> I'm using git -- creating a branch is like a fart in the wind.
03:53:33 <Philonous> mm_freak:  main = do start <- getCurrentTime ?
03:54:38 <int-e> yitz: why with darcs you have to copy everything. with git it's pretty much a single 41 bytes file :)
03:55:58 <kmc> with git a branch is like a fart in the wind.  with darcs it's like a fart in an elevator
03:56:05 <yitz> int-e: hard links are less than 41 bytes
03:56:23 <kmc> Tinned_Tuna, think of it this way, every additional line of code needs testing and documentation and will inevitably introduce bugs down the line
03:56:31 <kmc> each line of code is a debt which can only be repaid through pain
03:56:43 <Tinned_Tuna> kmc: I put myself through enough pain as it is.
03:56:49 <kmc> so by failing to write any code in the past hour, you've saved your employer tremendous debt
03:57:09 <kmc> those zero lines of code are more productive than some 1000 line files
03:57:09 <yitz> kmc: in a sequel to The World Inside, someone mentions seq, and the monad collapses.
03:57:13 <kmc> snap
03:57:43 <kmc> > Just undefined `seq` ()
03:57:44 <lambdabot>   ()
03:57:50 <kmc> looks pretty sturdy to me
03:59:25 <Tinned_Tuna> I recently composed myself a list of books to read... it's not short, and I'm not a quick reader of fiction.
03:59:33 <Tinned_Tuna> Makes me both happy and sad.
04:04:08 <jkff> Hi. Is Double <-> CDouble conversion via realToFrac slow? Or does GHC have some kind of built-in rules for that?
04:04:36 <kmc> the "is it slow" question is nicely answered with Criterion
04:04:50 <cheater> execute it 1000 000 000 times and see for yourself
04:04:57 <kmc> no just use criterion
04:05:01 <cheater> why
04:05:14 <kmc> because it does that, for you, and far more correctly than you'll ever care to
04:05:37 <kmc> with real statistics and real knowledge of the measurement overhead etc.
04:05:43 <kmc> it's easier *and* more correct
04:06:21 <cheater> oh so criterion is a code statistics tool
04:06:36 <cheater> good 2 kno
04:06:39 <augur> is it possible to have a data structure for descriptions in which some subset of the inhabitants cannot be identified except by an elsewhere case?
04:07:21 <kmc> cheater, it's a benchmarking tool
04:07:31 * hackagebot hastache 0.2.0 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.2.0 (SergeyLymar)
04:07:46 <yitz> augur: Maybe Description. or data Description = Info ... | Elsewhere
04:08:08 <kmc> http://hackage.haskell.org/package/criterion
04:08:24 <augur> yitz: except you dont _have_ to use an elsewhere case in those situations
04:08:32 <kmc> http://hackage.haskell.org/packages/archive/criterion/0.5.1.0/doc/html/Criterion-Main.html has full examples
04:08:35 <augur> i mean, you can match against Nothing and against Elsewhere
04:08:45 <ClaudiusMaximus> :t uncurry encodeFloat . decodeFloat
04:08:46 <lambdabot> forall a a1. (RealFloat a, RealFloat a1) => a1 -> a
04:09:20 <yitz> augur: you'll get a warning if you forget to handle the Elsewhere case
04:10:00 <cheater> hey kmc
04:10:05 <synonymous> I've got a question about simply typed lambda calculus. If I want to derive a type, do I first attempt do beta reduce the expression as far as possible? It doesn't make much sense to me but:
04:10:06 <synonymous> :t (\a b -> b) (\x -> x)
04:10:06 <cheater> i am working on this tool
04:10:07 <lambdabot> forall t. t -> t
04:10:26 <ClaudiusMaximus> @check (\x -> (uncurry encodeFloat . decodeFloat) x == (realToFrac :: Double -> Float) x)
04:10:27 <lambdabot>   "OK, passed 500 tests."
04:10:32 <cheater> it analyzes the executino time of functions (not in haskell) of a program, in relation to input size
04:10:44 <synonymous> what happens to \a and \x.x in the above example?
04:10:46 <augur> yitz: yes but my point is you can match Elsewhere, and let everything else fall into the elsewhere case
04:10:54 <cheater> i'm trying to catalogize those functions as O(n), explosive algorithms, and fast algorithms
04:11:03 <augur> so its not a situation where you can _only_ capture it by an elsewhere case
04:11:11 <jkff> Okay, I already figured out that it isn't slow :) Just wanted to cheat by asking here first :)
04:11:39 <cheater> i'll be doing this by using the time data vs input size and fitting parametrized functions of the form y = ax+b, y = ax^b + c, and so on
04:11:41 <augur> i suppose if the subset that is only captured by an elsewhere case is itself disjoint...
04:11:46 <cheater> kmc: got any comments?
04:12:47 <kmc> cheater, sounds good
04:13:12 <yitz> augur: if some of the specific pieces of Info might by "elsewhere", wrap each of those in Maybe.
04:13:20 <cheater> do you think it's a valid approach to find something out about the functions that create a bottleneck in my application?
04:13:28 <ddarius> synonymous: You don't need to beta reduce at all.
04:13:30 <augur> yitz: no you're not understand what i mean
04:13:33 <augur> but thats ok
04:13:43 <yitz> augur: ok. :)
04:13:58 <ddarius> synonymous: You don't need to evaluate a program to know its type.  That would largely defeat the purpose.
04:14:56 <augur> ddarius: unless you've got dependent types, in which case you need to partially evaluate sometimes :)
04:15:18 <cheater> oh btw, does anyone know of a good way to programmatically use maxima?
04:15:22 <cheater> preferrably from python ...
04:16:58 <synonymous> ddarius: sure, that's why i said it didn't make sense:) i just wasn't getting the right type sig on paper and was confused. Surely even if you beta reduce, that shouldn't change the type of the expression. Nevermind, I found my mistake. Thanks
04:18:21 <mm_freak> Philonous: i don't have access to 'main'
04:18:26 <mm_freak> it's a library
04:22:49 <_Ray_> If I run my program alone and under Valgrind and get different results, it means my program is doing some bad memory accesses, right?
04:23:42 <_Ray_> (I'm using -rtsopts and +RTS -K4294967295 -RTS to increase the stack to the max possible.)
04:26:03 <kmc> why do you need such a humongous stack?
04:26:30 <Axman6> or valgrind for that matter
04:26:38 <flux> for a moment I thought I was on ##c++ :)
04:27:00 <_Ray_> Well, I was /sure/ my program was correct, but it was giving the wrong results.
04:27:40 * ddarius wonders just how much trouble would result from passing that to a GHC compiled application on a 32-bit OS.
04:27:47 <_Ray_> The size of the stack... I think it's because of the prime list I'm using.
04:28:40 <ddarius> If you need 4GB of stack you either know exactly why you do, or you are doing something horribly wrong.
04:30:32 <hpaste> “_Ray_” pasted “Euler 347” at http://hpaste.org/53437
04:30:59 <_Ray_> I'm "pretty sure" it's primeNA that's using all that memory. I just needed a fast prime sieve.
04:31:09 <matthiasgorgens> _Ray_: You are not supposed to post Project Euler solutions.
04:31:15 <flux> it is indeed quite curious it gives different results under valgrind
04:31:16 <kmc> _Ray_, you were sure your program's correct, but you're not quite sure why it needs 4 GB of stack?
04:31:24 <_Ray_> If it worked, it'd be a problem, matthiasgorgens :p
04:31:34 <_Ray_> kmc, the algorithm works provided the primes I'm generating are primes.
04:31:35 <matthiasgorgens> _Ray_: ok. ;o)
04:31:51 <matthiasgorgens> How can I specify flags for "cabal build" on the command line?
04:32:13 <dcoutts> matthiasgorgens: what flags do you want to specify?
04:32:14 <matthiasgorgens> the documentation just talks about "-f flagname" but that didn't help.
04:32:21 <matthiasgorgens> dcoutts, I want to build an executable.
04:32:29 <matthiasgorgens> so the "executable" flag.
04:32:47 <dcoutts> cabal build will build all the components declared in the .cabal file
04:33:03 <dcoutts> there's no way at the moment to specify just one component to build
04:33:05 <matthiasgorgens> if flag(executable) \n Buildable:       True
04:33:15 <matthiasgorgens> So I need to give that flag.
04:33:24 <dcoutts> configuration flags are given at configure time
04:33:25 <matthiasgorgens> I don't mind if everything else is build as well.
04:33:29 <matthiasgorgens> oh, ok.
04:33:44 <dcoutts> (because they can affect dependencies etc)
04:33:49 <matthiasgorgens> good.  worked.
04:33:54 <matthiasgorgens> Thanks!
04:47:26 <geheimdienst> man, sometimes you randomly stumble into a real jewel on the wiki. this seems to be very well-written, it even has thoughtful section headings http://www.haskell.org/haskellwiki/OOP_vs_type_classes
04:50:01 <cheater> geheimdienst: is it written by oleg
04:53:30 <kalven> let's hope no one writes c++ like that
04:54:11 <cwl> where can I find source||doc for Snap.Iteratee.consume
04:54:31 <cheater> have you asked in the snap channel?
04:54:45 <cheater> the snap devs are usually around, they are quite helpful
04:54:56 <cwl> I find it
04:56:50 <dmwit> What package provides Snap.Iteratee? My usual first place to look for documentation and stuff is Hackage.
04:57:34 <geheimdienst> dmwit: doesn't help much. hayoo finds http://hackage.haskell.org/packages/archive/snap-core/latest/doc/html/Snap-Iteratee.html#v:consume but the doc is minimal and there is no "source" link
04:58:17 <dmwit> That is quite minimal indeed.
04:58:28 <dmwit> However, it does have source inline.
04:58:33 <dmwit> consume = takeWhile (const True)
04:59:03 <dmwit> cwl: ^^
04:59:32 <geheimdienst> i wonder why the source links are present at the top of the page, then about 1/3 in, they go away. i wonder if that's a haddock bug?
05:00:13 <dmwit> Perhaps because the functions are from another module?
05:03:53 <geheimdienst> hm ... i checked Prelude, and it has source links on every function. they point to Data.List and GHC.Read and all over the place
05:04:02 <geheimdienst> apparently haddock in principle can handle that
05:04:14 <dmwit> Maybe it is a bug, then.
05:25:43 <mm_freak> Cale: you have said that time is an addon in your FRP framework…  is it still implicit or do you have to pass time deltas around?
05:27:30 <Cale> mm_freak: Well, we have a way to attach a time to the occurrences of any event, but it's impossible to otherwise get the current time as a behaviour (apart from by doing a hold on some event)
05:27:30 <mm_freak> i see two ways to do it:  either with an ArrowClock class or with explicit delta passing…  i'm not sure, but i seem to like the explicit approach
05:27:43 <mm_freak> hmm, i see
05:27:54 <dylukes> I've wondered this before but,
05:28:13 <dylukes> when we have so many structures that have similar methods (difference, union, lookup, null, full, etc)
05:28:27 <dylukes> why don't we have abstractions (read: a typeclass) so we don't have to deal with import conflicts?
05:28:30 <mm_freak> Cale: so time is not an addon to the whole system, but to events, or is your system built on an event framework?
05:29:24 <mm_freak> dylukes: that question is asked often…  historical reasons i guess, just like the missing relationship between Functor, Applicative and Monad
05:29:45 <dylukes> And why don't we fix this in a large breaking update :\
05:30:04 <Cale> dylukes: Try writing it ;) You might have an easier time now with all the fancy GHC extensions than with Haskell 98 :)
05:30:04 <dylukes> Like say, make Haskell 2012/GHC 8 a big "break", and a chance to get all those changes in.
05:30:04 <mm_freak> dylukes: well, probably because of the "breaking" part ;)
05:30:27 <dylukes> Then just have an extension -XLegacy or something to have the old behavior.
05:30:47 <Cale> But for a lot of them, it's fairly tricky, because the types of things are fairly different, and in the case of things like Set and Map, the type constructors involved have different kinds.
05:30:49 <dylukes> Sort of like the Python 2 -> 3 transition, sometimes you need a breaking update to mitigate generations of accumulated cruft.
05:30:53 <mm_freak> dylukes: also the interfaces are not as easy to standardize than one might think…  for example to combine ByteString and [] under one interface you already need type system extensions
05:31:00 <mm_freak> dylukes: like MPTCs or type families
05:31:13 <mm_freak> than → as
05:31:20 <dylukes> Well yes, but assuming a H12 added MPTC's/TF's to the standard.
05:31:37 <Cale> Some structures are parametrically polymorphic, some aren't, the typeclass constraints required by various structures are different...
05:31:48 <Cale> The type of things like 'insert' changes quite a lot
05:32:02 <dylukes> Couldn't you associate a constrain kind?
05:32:13 <dylukes> constraint*
05:32:27 <Cale> Yeah, though last I checked, GHC 7.4 didn't exist yet ;)
05:32:34 <dylukes> Nope :P.
05:32:35 <mm_freak> i'd be happy with a new hierarchy for Functor, Applicative and Monad…  i don't think that standardized interfaces to listlike structures are that badly necessary
05:32:49 <dylukes> No, they're useful for some things though.
05:32:59 <dylukes> I've seen ListLike reinvented at least 5 times in parser/IO/iteratee libraries.
05:33:33 <mm_freak> right, but that's because haskell library authors seem to like to reinvent things
05:33:39 <mm_freak> there is a listlike library out there
05:33:40 <Cale> dylukes: and even if we can do it, there will doubtless be so much bikeshedding that it'll take forever :P
05:34:04 <dylukes> Cale: Well, I think the solution is actually pretty feasible obvious.
05:34:09 <dylukes> feasible/obvious*
05:34:14 <Cale> oh?
05:34:19 <dylukes> Make a new alternate Prelude package that makes all these changes.
05:34:27 <dylukes> So the bikeshedding and argument can happen in an actual usage context.
05:34:30 <Cale> Which changes would those be exactly?
05:34:35 <mm_freak> Cale: so you can't implement a clock easily in your framework, unless you attach time deltas to an event and accumulate?
05:35:09 <dylukes> Cale: proper monad/applicative/functor hierarchy, fix ord/enum, add listlike, setlike, etc...
05:35:29 <Cale> mm_freak: You make a clock by attaching times to an event on which the clock updates.
05:35:37 <Cale> dylukes: Er, what's wrong with Ord?
05:35:38 <dylukes> Split MonadPlus into MonadPlus/MonadZero/MonadOr.
05:35:45 <dylukes> Cale: just enum, sorry.
05:36:07 <Cale> What's wrong with Enum? It uses Int. I'd like to get rid of that, but otherwise it seems okay.
05:36:17 <mm_freak> Cale: is it very explicit?  where does the time come from?  i'm thinking of a specific clock arrow
05:36:31 <dylukes> Well, that's what I mean. Even those little things.
05:36:41 <dylukes> There's no reason to leave them sitting in a major breaking change.
05:36:42 <mm_freak> right now i have a class for clock arrows, but i'm not entirely happy with its interface
05:37:25 <mm_freak> particularly because you need extra maintainance work around the FRP system…  with explicit time delta passing that work is not necessary…  the work is moved inside the FRP system
05:37:58 <Cale> oh, right
05:38:10 <Cale> Okay, so there's this attaching of times to events
05:38:22 <Cale> and then there's requesting for an event to occur at a given time
05:39:05 <Cale> The latter is semantically quite tricky
05:40:06 <mm_freak> the question is really:  where do you feed time into the system?
05:40:12 <mm_freak> from outside or from inside?
05:40:14 <Cale> Particularly when the time at which you're requesting the event to occur is conceptually something which varies "continuously" -- not really continuously, but you're not allowed to ask when it changes.
05:41:14 <Cale> I'm not 100% certain we've got that bit right
05:41:21 <mm_freak> i see
05:41:49 <mm_freak> i found that the implicit state argument in netwire 1.* stands in the way more often than it helps
05:42:06 <mm_freak> in netwire 2.* i want to make all global state, including time, an addon
05:42:12 <Cale> What I do think is more important is being able to do things like delay an event by a given amount of time.
05:42:27 <hpaste> test pasted “test” at http://hpaste.org/53441
05:42:48 <mm_freak> event delay is really easy in netwire…  just inhibit for the given amount of time
05:45:10 <mm_freak> in version 1.*:  e <- delayEvents -< (4, e')
05:45:15 <mm_freak> delays event e' by four seconds
05:45:32 <mm_freak> in version 2.* this is not implemented yet, because i'm still doing research on how to bring time into the system =)
05:45:48 <mm_freak> in any case it should be similarly simple
05:46:13 <mm_freak> actually you don't need the output e…  you can just work with e'
05:46:51 <Cale> oh?
05:47:36 <mm_freak> you need e only if you are interested in the value of the event
05:47:56 <mm_freak> if e' :: (), you really can totally ignore e' and e
05:49:00 <mm_freak> delayEvents is an inhibitor…  the code following it is not reached, if the delayed event hasn't occurred yet
05:49:28 <Cale> err...
05:50:00 <Cale> Surely you only want to delay the code which depends on the result
05:50:21 <mm_freak> yes
05:50:26 <mm_freak> Wire is an ArrowPlus =)
05:50:28 <Cale> (which would make working with the input quite different)
05:51:04 <mm_freak> w1 <+> w2 tries w1 first…  if it inhibits, w2 is tried
05:51:16 <mm_freak> and zeroArrow is the wire, which always inhibits
05:51:20 <medfly> hi
05:51:30 <Cale> Oh, so that's quite different
05:52:10 <dylukes> What would you guys recommend as the "cleanest" way to take 4 hex digits, and covnert them to a single UTF32 character?
05:53:17 <Cale> dylukes: Would readHex and toEnum work?
05:53:42 <dylukes> I was thinking chr as opposed to toEnum, but something like that
05:53:57 <Cale> yeah, chr is the same
05:54:16 <Cale> (but you have to import Data.Char, while toEnum is in the Prelude)
05:54:50 <dylukes> where is readHex?
05:54:58 <dylukes> @hoogle readHe
05:54:58 <lambdabot> Numeric readHex :: Num a => ReadS a
05:54:58 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
05:55:03 <dylukes> Numeric :\
05:56:09 <fryguybob> > let f cs = head $ read ("\"\\x" ++ cs ++ "\"") :: Char in f "00000071" -- dylukes, not this
05:56:10 <lambdabot>   'q'
05:56:51 <mm_freak> i think i'll go with the ArrowTime approach
05:57:33 <Cale> Our ArrowTime is the one with attachTime, and ArrowDelay has 'at'
05:58:03 <mm_freak> my ArrowTime is more general…  it is a class for the transformed arrow
05:58:08 <Cale> fryguybob: haha, cute
05:58:14 <mm_freak> ArrowTime (>~) => Wire e (>~)
05:58:47 <mm_freak> time :: ArrowTime (>~) => Wire e (>~) a (Time (>~))
05:59:14 <mm_freak> i'm not happy with it because of the explicit maintainance required /around/ the FRP system
05:59:49 <mm_freak> and because of the implicit time delta argument passed around everywhere, but i guess the explicit case wouldn't improve this
06:02:57 <pielgrzym> hi
06:03:32 <pielgrzym> I've got a function: mkComplFunFromList :: [String] -> String -> IO [String]
06:04:07 <pielgrzym> I want to feed it with: getDirectoryContents "/"
06:04:19 <pielgrzym> now getDirectoryContents produces IO[FilePath]
06:04:42 <pielgrzym> so I tried making a string list:  [ x :: String | x <- getDirectoryContents "/"]
06:04:56 <Cale> IO [FilePath] isn't a type of list
06:05:04 <pielgrzym> it's a monad, right?
06:05:10 <Cale> It's the type of an IO action which, when run, will produce a list
06:05:23 <pielgrzym> ah
06:05:33 <pielgrzym> how can I actually run it??
06:06:05 <Cale> You can run it inside another IO action, for example, using do notation, you can write
06:06:14 <Cale> do xs <- getDirectoryContents "/"
06:06:20 <raek_> pielgrzym: you make it a part of main, which is the action that haskell will run
06:06:25 <Cale>    print xs
06:06:50 <pielgrzym> raek_: it's a part of xmonad config - I want the dirs re-read each time I call this function
06:06:58 <pielgrzym> Cale: ah! thank you
06:07:02 <Cale> The do-expression as a whole will itself then be an IO action
06:07:18 <Cale> and the type of that IO action will be the same as the type of the IO action on its last line
06:07:32 <pielgrzym> maybe I'll show the full code, ok?
06:07:35 <Cale> xs here will have type [FilePath] (which is the same as [String])
06:07:46 <pielgrzym> https://gist.github.com/1333586
06:07:58 <pielgrzym> take a peek at last 10 lines
06:08:14 <pielgrzym> I want projDirs to be a list of directories from a given dir
06:08:26 <Cale> yeah, you can't quite do that...
06:08:29 <pielgrzym> the addToInbox is a dummy function for now
06:08:58 <pielgrzym> I want the actuall function to take the given dir name and run a shell script with this dir name (not path) as argument
06:09:02 <Cale> however, since projDirCompletions is supposed to produce an IO action resulting in a list of strings
06:09:13 <Cale> you can construct projDirs inside that action
06:09:40 <Nimatek> pielgrzym: getDirectoryContents "." >>= filterM doesDirectoryExist >>= mapM_ putStrLn
06:10:00 <Nimatek> Do notation is more confusing than piping the output into another IO action with >>= I find.
06:10:15 <kmc> nobody linked http://www.haskell.org/haskellwiki/Introduction_to_IO yet?
06:10:18 <pielgrzym> Nimatek: thanks for solving the 'do not pick the files' problem in one hit :)))
06:10:49 <pielgrzym> the biggest problem with IO is that it requires understanding monads and I'm just too dumb for it I guess :/
06:10:54 <mm_freak> what's better performance-wise when using arrow notation?  a 3-tuple or two nested 2-tuples?
06:10:59 <kmc> pielgrzym, it does not require understanding monads
06:11:01 <kmc> check out the article i linked
06:11:06 <pielgrzym> kmc: ok :)
06:11:09 <Cale> projDirCompletions str = do projDirs <- getDirectoryContents "/home/pielgrzym/work"; mkComplFunFromList projDirs str
06:11:17 <kmc> pielgrzym, IO is one particular example of a monad, and a bad example too :)
06:11:19 <Cale> You don't need to understand monads
06:11:23 <dylukes> 'u'  -> do u <- count 4 hexDigit
06:11:23 <dylukes> >                                        return . Just . toEnum . fst . head . readHex $ u
06:11:24 <lambdabot>   Couldn't match expected type `GHC.Base.String'
06:11:24 <lambdabot>         against inferred typ...
06:11:24 <dylukes> >_>
06:11:29 <kmc> pielgrzym, if you are only doing IO, you do not need to understand the general "monad" abstraction
06:11:43 <pielgrzym> ok, I'll just read the article
06:11:52 <kmc> :)
06:12:10 <pielgrzym> :)
06:12:16 <mm_freak> why is IO a bad monad example?
06:12:26 <mm_freak> i think it's a particularly good one…  simple and easy to understand
06:12:41 <Cale> IO happens to be a monad, but that fact is kinda irrelevant here. (It happens to be why we're allowed to use do-notation, but you don't need to care about that if you don't want to)
06:12:42 <mm_freak> (if you don't go into metaphysics trying to actually define IO)
06:13:17 <Cale> You should think of IO actions as being values which syntactically describe things to be done
06:13:29 <kmc> mm_freak, for people who are new to Haskell, it builds a lot of false intuitions
06:13:40 <kmc> that monads are about side effects, that they're "impure", that they have magical built-in implementations
06:14:09 <kmc> these are arguably true statements about IO, but the fact that IO is a monad is incidental to all of them
06:14:43 <mm_freak> kmc: not a fault of IO, but of most monad tutorials
06:15:20 <kmc> oh?
06:15:55 <geheimdienst> i think the fact that there's a hundred "monad tutorials" only adds to the notion that monads are scary, esoteric things that only experts can understand
06:16:02 <kmc> yeah
06:16:12 <kmc> let's write the 101st monad tutorial to explain this fact!
06:16:32 <stepcut> it's NaMoTuWriMo!
06:16:46 <stepcut> National Monad Tutorial Writers Month!
06:16:56 <geheimdienst> stepcut: every month is namotuwrimo
06:17:25 <kmc> the fact that we spend all day and all night arguing about what monads are and how to teach them probably doesn't help
06:17:31 <int-e> True. If you ask three Haskell programmers about monads, you'll get five explanations :)
06:17:37 <kmc> indeed
06:17:45 <_Ray_> At least one will involve burritos.
06:17:48 <kmc> that's because they are simple but abstract
06:17:50 <mm_freak> many monad tutorials try to approach IO from the inside (mine is not an exception, but i was young)…  you can understand all aspects of IO by looking at its surface only
06:17:51 * Guest88536 deletes his tutorial that explained Monads using Lego
06:17:52 <rotflcopter> hii:)
06:17:59 <kmc> if they were complicated few would try
06:17:59 <rotflcopter> i'd have a question
06:18:09 <kmc> if they were simple and concrete, the explanations would converge
06:18:31 <rotflcopter> seems i must put it up ftp to not flood much ;<
06:18:47 <kmc> ftp?
06:18:51 <pielgrzym> heh, this article indeed clears up a lot!
06:18:54 <pielgrzym> thanks :)))
06:19:19 <geheimdienst> if java's Object class had only 2-3 methods and had a goofy name, Combobuloid or some such, there might be an equal amount of discussion of "what Combobuloids really are"
06:20:07 <kmc> good thing nothing in java has a silly name
06:20:17 <geheimdienst> (Object is the class at the root of the class hierarchy)
06:20:18 <kmc> they use clear terminology like AbstractSingletonProxyFactoryBean
06:20:24 <int-e> We can try and create a toy OO language and spam the net with claims that Object is really a Comboluloid.
06:21:14 <kmc> anyway I've learned you can't win with the names
06:21:16 <geheimdienst> kmc: sure, java also has silly names, but haskell is still the queen of silly names
06:21:34 <geheimdienst> int-e: they're already working on it, it's called category theory i believe ...
06:21:35 <_Ray_> Zygohistomorphic prepromorphism.
06:21:36 <kmc> people complain that Monad is foreign and scary, but they also complain that 'return' is deceptively familiar
06:21:52 <kmc> (and 'class')
06:21:54 <Cale> geheimdienst: There's not enough discussion about what Objects really are?
06:22:41 <byorgey> rotflcopter: hpaste.org
06:22:53 <rotflcopter> ok i dont have the source yet
06:22:59 <rotflcopter> doing that
06:23:16 <rotflcopter> was testing hundreds of lines in ghci
06:23:28 <kmc> the people who say "if we only renamed Monad to WarmFuzzy then everyone would learn Haskell" are just wrong
06:23:45 <kmc> the concepts are legitimately difficult, we shouldn't trivialize that by focusing on naming
06:24:00 <geheimdienst> kmc: both claims seem plausible to me. naming is hard, but i think with some effort, it is possible to find names that are pedestrian (not scary) but not overloaded in misleading ways
06:24:47 <kmc> i think the people who are scared off by 'math names' are not going to stick with the language anyway
06:25:08 <kmc> i think if you want to prove that practical Haskell software can be written by mere mortals, the best way is to do it
06:25:26 <luite_> that sounds like work :(
06:25:42 <kmc> yeah, complaining on IRC is way easier ;)
06:25:52 <luite_> or reddit comments, of course
06:25:56 <geheimdienst> kmc: that's true, but teaching to mortals also plays a role
06:26:09 <kmc> best would be complaining on IRC about reddit
06:26:38 <Saizan> i thought that was the point of #haskell-blah
06:26:38 <byorgey> geheimdienst: the only way to find names which would be pedestrian but not overloaded in misleading ways is to choose names which have nothing to do with what they do.
06:26:54 <rotflcopter> circle.hs:12:44: Parse error: naked expression at top level
06:26:56 <rotflcopter> whats this?
06:27:03 <byorgey> like we could call the Monad methods 'squid' and 'baseball'
06:27:11 <rotflcopter> i cant do main=print (length (perfectfullcircle 11));print (perfectfullcircle 11);
06:27:12 <rotflcopter> ?
06:27:14 <luite_> yeah we'd loose all the descriptiveness of >>= and return ;p
06:27:20 <kmc> if you focus on names then you're focusing on the people who are already way down the list of potential learners
06:27:24 <luite_> lose even
06:27:29 <ceii> rotflcopter, you need the "do" key word to sequence actions
06:27:29 <rotflcopter> i'd like to print length and then data
06:27:33 <kmc> there are enough people who aren't scared off by names, yet have serious difficulty
06:27:38 <kmc> with substantive conceptual things
06:27:41 <kmc> I'd rather help them first
06:27:54 <kmc> then they will tell their scared-by-names peers that Haskell isn't impossible
06:27:57 <ceii> main = do print (...) ; print "blah"
06:28:26 <rotflcopter> thnaks its cool now
06:28:44 <kmc> and on a practical level, there's no way we can actually rename Monad, the best you can do is write the 9000th tutorial along the lines of "ignore what everyone says about monads, you should think of them this way"
06:29:04 <geheimdienst> byorgey: i dunno, suppose "return" was called "pure"? or "wrap" or "enclose", "inject", ...
06:29:38 <kmc> i can immediately come up with a false intuition for each of those
06:29:58 <kmc> "pure"? ah, so monads are 'impure', they're a loophole in the semantics of pure FP, I knew it was a sham
06:30:15 <kmc> "wrap"? cool, so monads are just wrappers on pure values, now how do I get the String out of this IO String
06:30:22 <geheimdienst> kmc: i pretty much agree with what you say, but remember that the beginner can't separate "substantive conceptual difficulties" from naming difficulty
06:30:33 <kmc> that's totally false
06:30:36 <shlevy> geheimidenst: I beg to differ.
06:30:48 <kmc> that's a completely ridiculous thing to say
06:31:15 <dylukes> kmc: I have an idea personally which I will try to implement in my next blog post.
06:31:16 <rotflcopter> so heres what i have done
06:31:19 <rotflcopter> http://matrix.z-labor.com/tmp/ghc/circle.hs
06:31:21 <rotflcopter> for circle
06:31:23 <ceii> return's great, it was chosen not for its meaning but because it's used to make imperative-ish DSLs
06:31:25 <dylukes> Monads Without Words. A ruby-koan inspired monad tutorial.
06:31:25 <geheimdienst> dude, i wasn't claiming they're perfect. they are at least less misleading than "return" which is a keyword in all kinds of languages that does things not much related to haskell's return
06:31:30 <dylukes> with not a single phrase in english.
06:31:31 <kmc> ugh
06:31:37 <shlevy> geheimidienst: I'm a beginner, and even when I read my very first article on Haskell I wasn't scared off by big words
06:31:38 <ceii> I'm all in favor of names that don't actually mean anything
06:31:48 <Drakken> kmc just look at how scared people get by the word "lambda".  They think lambda functions have super-special properties.
06:31:50 <dylukes> mu and eta might actually be better names :P
06:31:51 <ceii> it's easier to tell people to forget about them and get on with the actual idea
06:32:04 <kmc> Drakken, I have not met these people
06:32:04 <copumpkin> cartocklification
06:32:19 <kmc> we talk all day about how awful and stupid "most programmers" are
06:32:22 <kmc> but I don't know anyone like that
06:32:30 <Drakken> kmc that's cuz you hang w/haskellers :)
06:32:39 <copumpkin> no it isn't
06:32:39 <cheater> lambdas are scary
06:32:44 <cheater> there was this movie, silence of the lambdas
06:32:50 * copumpkin slaps cheater 
06:33:02 <shlevy> Seriously? We have to learn new words for every new field we learn, and many times those words have different meanings in contexts we're more used to. This is a fact of life, not a problem with Haskell, and most people deal with it fine
06:33:02 * dylukes slaps cheater.
06:33:54 * kmc slaps all people who do not slap themselves
06:34:24 <geheimdienst> Drakken: i haven't met those people either, but i think their concern is legit. many languages don't call it lambda but func, function () {}, fn, or fun ...
06:34:26 <luite_> ?faq does kmc slap himself?
06:34:26 <lambdabot> The answer is: Yes! Haskell can do that.
06:34:28 <shlevy> When learning thermodynamics, we have to deal with the fact that "disorder"/"entropy" don't mean the same thing they mean in our daily lives, the mean something specific and somewhat different. Who cares?
06:36:11 <Drakken> shlevy I don't see any prob w/disorder, and what does entropy mean IRL?
06:36:14 <kmc> by the way, some people are actually anti-intellectual, and will use 'scary math words' as an excuse to avoid learning something that challenges their existing knowledge
06:36:14 <sopvop> How does "show 1.0" knows to show "1.0", and if I make instance for Float, I get Ambiguous type variable?
06:36:18 <geheimdienst> shlevy: yes yes, but there is still such a thing as ill-chosen confusing terminology, as i'd argue is the case with "return". suppose you went to a factory for excavators and they said "tire" whenever they meant "steering wheel". that's gotta put the wrong idea into the heads of at least a few people
06:36:20 <kmc> and if you take that away, they'll use another excuse
06:36:29 <kmc> I don't think this group is very big, but they are very loud
06:36:34 <Cale> :t 1.0
06:36:34 <lambdabot> forall t. (Fractional t) => t
06:36:38 <kmc> and it's not worth accommodating them
06:36:39 <Cale> :t 1
06:36:39 <lambdabot> forall t. (Num t) => t
06:36:59 <Cale> After numeric defaulting, those will become Double and Integer, respectively
06:37:24 <Cale> But of course, the latter *could* be Double:
06:37:26 <cheater> there are people out there who complain about the silent majority
06:37:28 <Cale> :t 1 :: Double
06:37:29 <lambdabot> Double
06:37:39 <cheater> this group isn't very big, but they are very loud
06:37:44 <Cale> But Integer takes priority
06:38:01 <shlevy> Drakken: Many people have taken entropy into common vernacular to mean roughly the same thing as disorder. And there's a big difference between "messy according to our cognitive standards of order" and "high number of equal-energy states"
06:38:04 <Cale> 1.0 can't be an Integer, because it requires Fractional
06:38:24 <geheimdienst> kmc: there is some truth in that, but i think it cuts both ways. baroque, overcomplicated jargon is also an excuse for teachers too afraid of changing their terminology and too inept (or lazy) to find better ways of explaining
06:38:50 <Cale> sopvop: You can't write an instance of Show for Float because there already is one, but I'm not sure I'm interpreting what you're saying correctly.
06:39:25 <dylukes> kmc: I think just as worrisome is the much larger group of people who reject anything remotely intellectual not because it's intellectual, but because they dogmatically believe intellectualism excludes utility.
06:39:36 <dylukes> i.e, the "utility over everything" types.
06:39:49 <dylukes> Which are not dangerous unless they're vocal.
06:40:32 <cheater> dylukes: your argument does not lead anywhere, please start doing something productive ( :D )
06:40:50 <geheimdienst> byorgey: you're the mastermind behind typeclassopedia, right? do you mind if i copy-paste it into the wiki? i thought recently an html version might occasionally be handy
06:40:56 <sopvop> No, I just want to write class instance for Float without need to ::Float after expression :) Thank you very much for help, I'll just do Doubles
06:41:09 <Cale> sopvop: oh, err
06:41:15 <dylukes> do {u <- count 4 hexDigit; return . Just . toEnum . fst . head . readHex $ u}
06:41:17 <Cale> sopvop: You shouldn't have to do that
06:41:24 <dylukes> I worry this might not be the best way to write this for a tutorial.
06:41:36 <Cale> sopvop: Well...
06:41:38 <Drakken> shlevy at least they're similar ideas.  "lambda" otoh says nothing excpect "OMG it's Latin!"
06:41:42 <dylukes> Eh, oh well. It's nothing too scary.
06:41:43 <byorgey> geheimdienst: no, I don't mind
06:41:57 <byorgey> geheimdienst: though I am working on a second edition which will have an HTML version
06:42:23 <shlevy> Drakken: Ok, unless you know the math then it's a term with a long history. And if you don't... so what? You learn a new word. Also, Greek.
06:42:37 * hackagebot snaplet-hdbc 0.6.3 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.3 (JurrienStutterheim)
06:42:41 <rotflcopter> nahm so
06:42:44 <Spockz> who has a recent wxHaskell program for me so I can test it on Lion?
06:42:45 <rotflcopter> can someone help in
06:42:48 <Cale> sopvop: If you give it any other way to infer what type of thing show is being applied to, then it'll be fine with it. Annotating explicitly is one way.
06:42:49 <rotflcopter> http://matrix.z-labor.com/tmp/ghc/circleAA.hs
06:42:51 <rotflcopter> ?
06:43:06 <geheimdienst> byorgey: oh, great to hear :) so, is publishing imminent?
06:43:09 <rotflcopter> it doesnt want to make me an integer list ;/
06:43:15 <byorgey> geheimdienst: no, not imminent
06:43:18 <Cale> rotflcopter: y u no press enter
06:43:26 <mux> lol
06:43:47 <rotflcopter> ahaha
06:43:52 <rotflcopter> yeah too much programming
06:43:57 <Drakken> shlevy okay, Greek.  Same idea.
06:44:10 <geheimdienst> byorgey: okay then for the meantime, there'd be some value in a wiki version
06:44:17 <Cale> rotflcopter: let me take a minute and clean this up a bit
06:44:22 <byorgey> geheimdienst: sure
06:44:24 <rotflcopter> ok i have time
06:44:25 <rotflcopter> :)
06:44:32 <rotflcopter> and im still learning
06:45:00 <leino> can someone tell me why there is both Text.ParserCombinators.Parsec and Text.Parsec?
06:45:33 <mux> Text.Parsec was introduced with parsec 3 IIRC, anyways, that's just the old and the new API
06:45:36 <sopvop> Cale I just want  something like "polymorphic constructor" for something like EDSL :)
06:46:09 <leino> mux: allright, so I should use Text.Parsec?
06:46:28 <dylukes> leino: No you should use Text.Trifecta :0
06:46:34 <mux> hahaha
06:46:36 <leino> hehe
06:46:39 <leino> is it done?
06:46:47 <mux> leino: unless you'd want to be compatible with older Parsec versions, I guess
06:46:55 <dylukes> ...no it's unstable, but all of the Parsec-ish stuff is done
06:46:57 <edwardk> leino: still working on improving diagnostics and adding functionality
06:47:01 <dylukes> edwardk: ^
06:47:23 <edwardk> but the core of it is built around just ripping open parsec and turning it into something that supports monad transformers
06:48:02 <mux> wasn't there a GSoC to implement ParsecT ?
06:48:08 <leino> edwardk: in what sense doesn't Parsec support monad transformers?
06:48:38 <edwardk> leino: parsec _is_ a monad transformer, but you can't apply WriterT to parsec and get a parser
06:48:45 <edwardk> its the top of the foodchain
06:48:58 <edwardk> which is actually _really_ annoying if you ever want to make, say your own exception type
06:49:02 <edwardk> you're just screwed then
06:49:27 <leino> edwardk: ok, I'll take a closer look at trifecta then :)
06:49:29 <edwardk> i was originally trying to just build trifecta on top of parsec, but i needed more robust error reporting
06:49:42 <leino> I don't like to be screwed by libraries
06:49:56 <pielgrzym> ok, got a fist version working: projDirCompletions str = getDirectoryContents "/home/pielgrzym/work" >>= return . filter (`notElem` [".", ".."]) >>= \lst -> mkComplFunFromList lst str
06:50:10 <pielgrzym> ok, got a fist version working: projDirCompletions str = getDirectoryContents "/home/pielgrzym/work" >>= return . filter (`notElem` [".", ".."]) >>= \lst -> mkComplFunFromList lst str
06:50:12 <ceii> that two-screenfulls module listing on trifecta's hackage is pretty scary
06:50:27 <pielgrzym> :)
06:50:34 <pielgrzym> but!
06:50:45 <edwardk> ceii: i'll admit that is the rough part, but my main goal with trifecta has been to support 'all the crap people build over and over after they have a basic parser'
06:51:03 <edwardk> ceii: and it goes out of its way to provide decent charsets, etc. to support parsing
06:51:12 <pielgrzym> the Control.Monad approach doesn't work because we don't provide full paths (doesDirectoryExist "someproj" instead of "/home/pielgrzym/work/someproj")
06:51:24 <edwardk> so a lot of that stuff is comprised of extra goodies. the core of it is Text.Trifecta.Parser.* for the most part
06:51:34 <edwardk> and the fact that you have access to Text.Trifecta.Diagnostics
06:51:34 <ceii> edwardk, yeah, I don't think that's a problem, but we'll need a tutorial somewhere
06:52:01 <edwardk> ceii: yeah, i'm currently streamlining the Diagnostics portion, then I plan on working up a field guide/tutorial
06:52:17 <hpaste> Cale pasted “First step: let's clean up the layout” at http://hpaste.org/53443
06:52:18 <edwardk> i wanted a fully worked example that carried things through type checking
06:52:39 <Cale> ^^ now it is at least marginally readable
06:53:37 <Cale> I've just added appropriate whitespace.
06:54:58 <ceii> pielgrzym, you mean the filterM doesDirectoryExist part?
06:55:33 <dylukes> @hoogle a -> a -> Double
06:55:33 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:55:33 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
06:55:33 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
06:56:14 <ceii> use filterM (doesDirectoryExist . ("your/working/dir" </>))
06:56:25 <ceii> (</> is from System.FilePath)
06:57:22 <hpaste> Cale annotated “First step: let's clean up the layout” with “Next step: let's make a definition for fromIntegral . round so we don't repeat it so damn much” at http://hpaste.org/53443#a53444
06:57:37 <dylukes> edwardk: What would the cleanest way to combine an ipart/fpart into a single double?
06:57:48 <dylukes> @hoogle Int -> Int -> Double
06:57:49 <lambdabot> Data.Graph.Inductive.Query.SP spLength :: (Graph gr, Real b) => Node -> Node -> gr a b -> b
06:57:49 <lambdabot> Data.Graph.Inductive.Query.MaxFlow maxFlow :: (DynGraph gr, Num b, Ord b) => gr a b -> Node -> Node -> b
06:57:49 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
06:57:55 <Cale> rotflcopter: okay, so now the code is in reasonable shape to start looking at what it's actually doing :)
06:57:57 <edwardk> dylukes: look at the guts ot the floating parser in Token
06:58:09 <dylukes> k, I guess I could keep the stuff as a string
06:58:12 <dylukes> and then read when I return
06:58:12 <dylex> dylukes: encodeFloat ?
06:58:14 <rotflcopter> :)
06:58:15 <rotflcopter> hehe
06:58:26 <Cale> Oh, I recapitalised intDif, but not everywhere
06:58:38 <dylex> dylukes: no wait, I thought you meant base exp, not int, frac
06:58:52 <Cale> We also don't really need a definition for sqr
06:58:57 <Cale> Because ^ exists
06:58:57 <dylukes> mm. encodeFloat a b is a * 2 ^ b
06:59:00 <dylukes> not exactly what I need :p
06:59:00 <edwardk> :t encodeFloat
06:59:01 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
06:59:09 <Cale> sqr f = f^2
06:59:11 <edwardk> yeah
06:59:14 <dylukes> encodeFloat produces mantissa/exponent
06:59:18 <edwardk> that is mantissa/exponent
06:59:24 <dylukes> ^5
07:00:57 <hpaste> dylukes pasted “JSON String” at http://hpaste.org/53445
07:01:01 <edwardk> well, the real way to do it would just be to fromIntegral whole + scaleFloat (fromIntegral frac) (-64)   -- or some such
07:01:06 <edwardk> where -64 = the size of Int
07:01:07 <dylukes> edwardk: I rolled my own string parser :P
07:01:14 <edwardk> kinda figured
07:01:19 <dylukes> how does it look?
07:01:22 <edwardk> since the spec there slightly differs
07:01:25 <erus`> I wanna occupy something so that people stop using html and css.
07:01:35 <erus`> occupy www
07:01:36 <dylukes> I did borrow the Just/Nothing thing from yours.
07:01:44 <edwardk> pretty straight forward
07:01:44 <dylukes> Though it's not necessary in this spec really :\
07:01:55 <edwardk> i just stole mine wholesale from parsec
07:02:07 <dylukes> I need to also difference the control characters,
07:02:25 <rotflcopter> hmm Cale looks neater that way, what editor you recomend?
07:02:34 <rotflcopter> *recommend
07:02:41 <hpaste> dylukes annotated “JSON String” with “JSON String (annotation)” at http://hpaste.org/53445#a53446
07:02:49 <dylukes> g2g now
07:02:58 <Cale> rotflcopter: anything which converts tabs to spaces automatically will do. I tend to use vim/gvim
07:03:09 <Cale> Lots of people also like emacs, and I have used that in the past too
07:03:40 <Cale> But really anything that you're comfortable with and which has a setting to expand tab characters automatically to spaces should do.
07:03:54 <rotflcopter> and syntax highlight?
07:04:03 <Cale> Syntax highlighting is also nice :)
07:04:23 <Cale> (personally I don't see it as totally essential, but it's certainly nice to have)
07:05:59 <massudaw> ls
07:07:07 <erus`> i tried vim
07:07:23 <Cale> cat tried
07:07:26 <erus`> i just use my mouse too much everyday
07:07:54 <Cale> I use my mouse with vim
07:07:58 <Cale> all the time
07:08:10 <Cale> It even works in a terminal window :P
07:08:21 <Cale> I also use the arrow keys
07:08:37 <mm_freak> is there a way to isolate 'arr . const' when using arrow notation?
07:08:56 <Cale> mm_freak: We have a class ArrowConst which generalises const for that purpose
07:09:11 <mm_freak> Cale: but you need a special preprocessor, right?
07:09:25 <Cale> Well, not exactly for that
07:09:58 <Cale> But yes, because otherwise with proc/do syntax, the heavy use of arr everywhere will make it almost impossible to do any additional analysis
07:10:22 <mm_freak> hmm, ok
07:10:29 <mm_freak> is it hard to write such a preprocessor?
07:11:41 <Cale> Depends on how good you want the code to be, and how much of the Haskell syntax you support.
07:12:11 <mm_freak> i see
07:12:23 <mm_freak> so basically you have to write your own desugarer for arrow notation?
07:12:31 <Cale> Yeah, we do :)
07:12:38 <mm_freak> alright
07:12:44 <bartavelle> is there a simple way to find out where an exception originates from ?
07:12:47 <Cale> Maybe not every setting would demand that
07:12:52 <mm_freak> is it a real preprocessor or do you use something like quasiquotes?
07:12:59 <Cale> Real preprocessor
07:13:10 <bartavelle> I tried ghci and :trace, but it is a bit cryptic to me
07:13:13 <Cale> We use GHC's -F
07:13:34 <Cale> bartavelle: Thrown from pure code? It can be tricky.
07:13:44 <bartavelle> yes it's from pure code ...
07:13:56 <bartavelle> I'd just like to have the line where my Map.! fails
07:14:02 <Cale> bartavelle: One of the things which makes it tricky is that the concept of a call stack is meaningless given the way in which GHC evaluates Haskell code.
07:14:12 <mm_freak> Cale: do you think that rewrite rules would apply here?
07:14:35 <Cale> mm_freak: hmmm... as in RULES? I don't know.
07:14:40 <bartavelle> Cale: that's what I supposed from the output of :hist
07:14:47 <rotflcopter> Cale<< whats ghc -F ?
07:15:44 <mike-burns> Enable preprocessor.
07:15:46 <mm_freak> i'll give it a shot
07:15:47 <Cale> rotflcopter: -F turns on pre-processors, which can be added with -pgmF -- you can write source to source translator programs and add them to the front end of GHC like that
07:16:58 <augur> what unifies derivatives of containers and derivations of continuous real functions?
07:17:07 <Cale> bartavelle: How many occurrences of Map.! are in your program?
07:17:46 <bartavelle> just a few, but tracing them all is not helpful, as I'm not sure how to trace AFTER the evaluation of Map.!
07:17:55 <bartavelle> I'm not sure it is in my code
07:17:57 <Cale> bartavelle: You can replace them with  Map.findWithDefault (error "foo line 56")
07:18:07 <bartavelle> ah
07:18:11 <bartavelle> pretty good idea
07:18:21 <bartavelle> will try this right now, thanks
07:18:59 <Cale> It's not good to use !/head/tail/fromJust/etc. unless you're 100% sure that they'll succeed (and even then...)
07:19:11 <pielgrzym> could someone point me into right direction: https://gist.github.com/1333761 - I'm trying to make the openProj function from line 340 to work :)
07:19:32 <bartavelle> Cale, that's the whole problem with bugs, I'm 100% my code works until it doesn't ;)
07:19:38 <yitz> augur: do you mean derivatives of container *types*? those are zippers.
07:19:58 <augur> yes, yitz, derivatives of container types
07:20:22 <Cale> pielgrzym: What is the problem with it?
07:21:33 <pielgrzym> Cale: first there is ambiguity: I need the workspaces from import XMonad.StackSet ( workspaces, tag )
07:21:39 <vharishankar> > and (map (\x -> isDigit x || x == '.') "112.2312")
07:21:40 <lambdabot>   True
07:22:21 <Cale> pielgrzym: If you don't need one from another module which is being imported, you can import Foo hiding (workspaces)
07:22:36 <Cale> pielgrzym: You can also just explicitly qualify the thing
07:22:47 <Abraxas> @pl elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
07:22:47 <lambdabot> elem' = flip foldl False . flip . flip flip True . (if' .) . (==)
07:22:49 <Cale> gets XMonad.StackSet.workspaces
07:22:56 <vharishankar> Is the above a good way or should I use regular expressions?
07:22:59 <pielgrzym> Cale: ah!
07:23:04 <Cale> Or you can import that module with a shorter name to make it easier
07:23:16 <vharishankar> Not that I know how to use regular expressions in Haskell anyway.
07:23:22 <Cale> import XMonad.StackSet as SS
07:23:24 <yitz> vharishankar: i like it your way
07:23:29 <Cale> SS.workspaces
07:23:50 <vharishankar> yitz: the thing is it will return true for period at the end
07:24:01 <vharishankar> > and (map (\x -> isDigit x || x == '.') "112.")
07:24:02 <lambdabot>   True
07:24:14 <Abraxas> what is if'
07:24:17 <yitz> vharishankar: there are packages on hackage. but haskellers often prefer other parsing languages, such as parsec.
07:24:35 <Abraxas> doesn't work in ghci
07:24:35 <Cale> vharishankar: If you're going to use regular expressions, you might as well be using a parser combinator library like Parsec which will give you much more readable and maintainable code, and is also much more flexible in terms of the languages it can parse.
07:24:56 <pielgrzym> Cale: still the workspaces name is ambigous (I'm doing import XMonad.StackSet as SS and later referring to SS.workspaces :/
07:25:10 <Cale> pielgrzym: what is it saying?
07:25:34 <vharishankar> Cale: thanks. I was wondering if it would be better to use just the built-in functions for this simple parsing?
07:25:49 <Cale> vharishankar: I would.
07:25:58 <yitz> Abraxas: if' is something you see in the output of @pl. if' p t e = if p then t else e
07:26:06 <rotflcopter> btw are there any example programs in haskell?
07:26:26 <pielgrzym> Cale: can I just import the workspaces from StackSet under different name? There are more collisions (like focusUp both in XMonad and SS
07:26:32 <rotflcopter> written for demonstration/ learning with comments
07:26:57 <geheimdienst> are there any well-known things that are Functors but not Applicatives? my understanding is there's not many such things
07:26:59 <rotflcopter> like this circle algorithm i posted
07:27:01 <Abraxas> what would that be here: elem' = flip foldl False . flip . flip flip True . (if' .) . (==)
07:27:04 <bartavelle> Cale, the "withdefault" worked perfectly, thanks
07:27:12 <Cale> pielgrzym: Oh, in that case,  import qualified XMonad.StackSet as SS
07:27:23 <fryguybob> rotflcopter: http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls ?
07:27:27 <yitz> @unpl  flip foldl False . flip . flip flip True . (if' .) . (==)
07:27:27 <lambdabot> (\ p -> foldl (\ e f -> if' (p == f) True e) False)
07:27:31 <Cale> pielgrzym: and then you *have* to write SS if you want to refer to the StackSet ones
07:27:51 <Cale> pielgrzym: which should remove all the ambiguities of that sort
07:27:56 <Abraxas> yeah, if pl'd that
07:28:00 <Abraxas> *i
07:28:18 <Cale> bartavelle: great!
07:28:20 <Abraxas> i was looking for something else, though
07:28:33 <Abraxas> thought that might help, but i am way too novice for pointfree
07:28:39 <Abraxas> and it doesn't help
07:28:49 <rotflcopter> thanks i didnt find that before <;
07:28:54 <Cale> Abraxas: That's a terrible example for pointfree
07:28:54 <yitz> Abraxas: if (p == f) then True else e is the same as p == f || e
07:29:10 <Abraxas> basically i just wanted this curried: (\acc x -> if x == y then True else acc)
07:29:24 <augur> so uh..
07:29:27 <Cale> it is curried
07:29:28 <Abraxas> if possible
07:29:36 <Abraxas> i mean without lambda
07:29:41 <augur> derivatives: what unifies them all
07:29:48 <Cale> -> (\acc x -> x == y || acc)
07:29:52 <Abraxas> partially applied, sorry
07:30:04 <mux> @pl \acc x -> if x == y then True else acc
07:30:04 <lambdabot> flip (flip if' True . (y ==))
07:30:11 <mux> ugh.
07:30:43 <Cale> @pl \acc x -> x == y || acc
07:30:44 <lambdabot> flip ((||) . (y ==))
07:30:46 <Abraxas> ah, that's a different result
07:31:05 <mux> Cale: yeah, I expected too much of the @pl analysis :-)
07:31:31 <Abraxas> that's not even what i meant
07:31:47 <Abraxas> i didn't see that it would be different if applied to just that part
07:32:03 <Abraxas> should have been obvious
07:32:19 <Abraxas> to me, i mean
07:32:24 <Abraxas> thx
07:33:27 <Abraxas> (y==) is convention? i saw (==y) more often
07:34:42 <Cale> Abraxas: Well, (==) is symmetric
07:34:45 <vharishankar> Is there a standard way to check if a string is a number? I mean using read results in an exception if it is not a number
07:34:52 <vharishankar> > read "12.12"
07:34:53 <lambdabot>   *Exception: Prelude.read: no parse
07:34:54 <kmc> i think "equals y" sounds better than "y equals", as the English language name of a predicate
07:34:58 <kmc> but whatevs
07:35:08 <geheimdienst> > reads "12"
07:35:09 <lambdabot>   []
07:35:12 <Abraxas> so that's the same function as foldr takes, just flipped
07:35:15 <Cale> Abraxas: The @pl tool doesn't follow any conventions apart from its purely mechanical translation and rewriting of things
07:35:25 <geheimdienst> > reads "12" :: [(Int, a)]
07:35:26 <kmc> vharishankar, http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
07:35:26 <lambdabot>   Couldn't match expected type `a'
07:35:26 <lambdabot>         against inferred type `[GHC.Types....
07:35:30 <geheimdienst> > reads "12" :: [(Int, String)]
07:35:31 <lambdabot>   [(12,"")]
07:35:36 <geheimdienst> > reads "lol" :: [(Int, String)]
07:35:37 <lambdabot>   []
07:35:47 <vharishankar> geheimdienst: thanks.
07:35:55 <Abraxas> ok cale
07:35:57 <geheimdienst> vharishankar: you're welcome
07:35:57 <vharishankar> kmc: I'll read that.
07:36:16 <kmc> basically geheimdienst already showed you :)
07:36:36 <kmc> but it's a short example anyway
07:36:58 <geheimdienst> hm, i wonder why that safeRead function isn't in the standard library ...
07:37:02 <Abraxas> does that mean you can always flip the foldr version and get the foldl?
07:37:23 <Abraxas> if it's symmetric operators
07:37:27 <vharishankar> reads "123.1as" :: [(Double, String)]
07:37:32 <vharishankar> > reads "123.1as" :: [(Double, String)]
07:37:32 <lambdabot>   [(123.1,"as")]
07:38:12 <vharishankar> > reads "123.1as" :: [String]
07:38:14 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:38:14 <lambdabot>         against inferred ty...
07:38:32 <geheimdienst> vharishankar: yeah, it parses the number as far as it can, and gives the unparseable rest back. you might want to check if that string is ""
07:38:33 <kmc> geheimdienst, general lameness
07:38:37 <kmc> http://hackage.haskell.org/package/safe has it
07:38:57 <vharishankar> geheimdienst: thanks.
07:40:31 <vharishankar> > reads "abc23.1as" :: [(Double, String)]
07:40:32 <lambdabot>   []
07:40:35 <ghosting> > reads "123.1as" :: [(Double, String)]
07:40:36 <lambdabot>   [(123.1,"as")]
07:42:21 <ghosting> > reads "133.1as" :: [(String, String)]
07:42:21 <lambdabot>   []
07:43:05 <vharishankar> This might seem silly, but how does one unwrap the result of the reads?
07:43:10 <Abraxas> if you could tell me the syntax to make this work: (\y -> ((||) . (==y))) == (\y -> (flip ((||) . (==y))))
07:43:15 <Abraxas> didn't look it up, yet
07:44:00 <Abraxas> :: after the lambda parameter i thought, but that is no longer supported, it appears
07:44:58 <Abraxas> argh, that's nonsense anyway
07:45:01 <kmc> it's allowed with a GHC extension
07:45:05 <kmc> vharishankar, pattern matching
07:45:06 <Abraxas> foldl and foldr would be missing
07:45:36 <vharishankar> kmc: can it be within the function?
07:45:49 <kmc> which function
07:45:58 <Abraxas> more like this: (\y ys -> foldr ((||) . (==y)) False ys) == (\y ys -> foldl (flip ((||) . (==y))) False ys)
07:46:00 <kmc> you can use "case" to do pattern matching anywhere in an expression
07:46:27 <Abraxas> with the extension, i can write y::Eq and it returns True?
07:47:29 <vharishankar> kmc: I will try to paste a code sample.
07:47:30 <erus`> this programmable pipeline opengl stuff is alot harder :(
07:47:49 <Abraxas> and y::a, ys::[a] would be needed now
07:48:28 <hpaste> Harishankar pasted “Not sure how to parse a number” at http://hpaste.org/53448
07:50:33 <rotflcopter> http://hpaste.org/53443
07:51:04 <rotflcopter> so is it possible to make this store [integer,integer,float] values?
07:51:11 <lpsmith> http://hpaste.org/53449
07:51:29 <lpsmith> does anybody know anything about said bug?
07:54:26 <Abraxas> preflex: karma Abraxas
07:54:26 <preflex>  Abraxas has no karma
07:54:39 <tromp> use Data.Time.Format.formatTime
07:55:09 <dylex> lpsmith: it seems to work on 7.2.1.  Does it only happen with import or :m + as well?
07:55:36 <parcs> rotflcopter: do you mean storing integers and floats in the same list?
07:55:42 <rotflcopter> yes
07:55:49 <Abraxas> preflex: karma lambdabot
07:55:50 <preflex>  lambdabot: 34
07:55:51 <kmc> vharishankar,  get_number st = case safeRead st of Just n -> Token "NUMBER" n; Nothing -> Token "Unrecognized" 0
07:55:58 <parcs> no
07:56:10 <parcs> use Either Integer Float instead
07:56:17 <rotflcopter> hmm so i must use only floats or only integers in a single [] ?
07:56:22 <Abraxas> preflex: karma preflex
07:56:23 <preflex>  preflex: 24
07:56:29 <kmc> rotflcopter, yes, lists contain one type only
07:56:33 <vharishankar> kmc: thanks
07:56:48 <kmc> rotflcopter, otherwise, when you ask for an element, how would you know what type it has?
07:56:49 <Abraxas> is preflex public?
07:56:54 <kmc> this must be known at compile time
07:57:05 <Abraxas> can you see what i'm asking it
07:57:19 <rotflcopter> kmc<< was thinking about giving typecast declaration
07:57:58 <kmc> don't know what that means
07:58:08 <rotflcopter> like apoint :: [int,int,float]
07:58:29 <mux> looks like you want a tuple here and not a list
07:58:47 <kmc> rotflcopter, that's not a type cast, and [Int, Int, Float] is not a valid type
07:58:53 <geheimdienst> > (17, "lolcats")
07:58:54 <lambdabot>   (17,"lolcats")
07:58:56 <mux> there would be a way to store both integers and floats in a list in haskell with GHC extensions, but I don't think you want to do this
07:58:57 <kmc> rotflcopter, it's a type annotation; you're stating to the compiler a fact which must *already* be true
07:58:59 <geheimdienst> > [17, "lolcats"]
07:59:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:59:00 <lambdabot>    arising from the literal ...
07:59:08 <Abraxas> preflex: list
07:59:08 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
07:59:09 <preflex>  ZCode: [zdec, zenc]
07:59:59 <kmc> heterogeneous lists are used in other languages to fake having sum types
08:00:06 <Abraxas> preflex: help nickometer
08:00:06 <preflex>  nickometer NICK - calculate a nick's lameness score
08:00:07 <kmc> sum types being data types with more than one constructor
08:00:28 <Abraxas> preflex: nickometer Abraxas
08:00:29 <preflex>  Abraxas is 0% lame
08:00:34 <rotflcopter> :)
08:00:38 <rotflcopter> haha
08:00:50 <Abraxas> preflex: nickometer rotflcopter
08:00:51 <preflex>  rotflcopter is 0% lame
08:00:59 <rotflcopter> just initialized?
08:01:30 <Abraxas> preflex: nickometer preflex
08:01:30 <preflex>  preflex is 0% lame
08:01:44 <dylex> Abraxas: you can use /msg preflex if you want it to be private
08:02:02 <Abraxas> that makes sense
08:02:37 * hackagebot system-filepath 0.3.3 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.3 (JohnMillikin)
08:02:39 * hackagebot system-filepath 0.4.2 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.2 (JohnMillikin)
08:03:43 <vharishankar> Where is safeRead defined? Hoogle doesn't return any results.
08:03:45 <lpsmith> dylex: not sure,  and I don't think I care at this stage.   Thanks, I didn't have 7.2.1 installed
08:04:09 <lpsmith> But if it's fixed, then I'm not going to report it,  as it may well have already been reported.
08:04:18 <kmc> vharishankar, it was in the link I sent you
08:04:59 <geheimdienst> vharishankar: you have to copy-paste it from the FAQ. alternatively, it is in the package named "safe". (general tip: hayoo searches way more packages than hoogle)
08:05:19 <kmc> in 'safe' it's named 'readMay'
08:05:33 <kmc> i was previously unable to find this with either hoogle or hayoo
08:05:45 <vharishankar> kmc and geheimdienst thanks.
08:06:02 <kmc> vharishankar, anyway, if you read the code for safeRead and understand how it works, you can convert get_number to call 'reads' directly
08:06:24 <vharishankar> kmc: right. I'd prefer to do it on my own to understand it.
08:06:49 <geheimdienst> kmc, as of now, hayoo finds it ... first hit for "readMay" and for "String -> Maybe a"
08:07:32 <Abraxas> oh, i didn't know about hayoo yet...haha
08:07:37 * hackagebot lax 0.1.0.2 - Lax arrows  http://hackage.haskell.org/package/lax-0.1.0.2 (WolfgangJeltsch)
08:08:08 <ratzes> can anybody help me with a relocation R_X86_64_32 error in ghc?
08:08:20 <vharishankar> Fun names: everything starts with a H. :-)
08:08:55 <dylex> ratzes: on linux or mac?  either way, that implies some biarch strangeness.
08:09:08 <ratzes> linux, amd 64
08:09:15 <kmc> biarch strangeness?
08:09:27 <rotflcopter> how to define byte, word, dword, qword types ?
08:09:35 <kmc> rotflcopter, Data.Word
08:09:37 <Abraxas> of course there is haltavista
08:10:16 <kmc> dylex, what do you mean?
08:10:27 <rotflcopter>  maxBound :: Int
08:10:27 <rotflcopter> 9223372036854775807
08:10:27 <dylex> ratzes: do you have 32-bit libraries on the system?  that often implies that you're trying to link 64- and 32-bit libraries together.
08:10:32 <mux> does someone have a link to this paper defining a new strict Core language for GHC? I believe it was from spj
08:10:32 <geheimdienst> kmc: i presume "bi-architecture"
08:10:41 <rotflcopter> so this is because im on 64 bit machine?
08:11:13 <ratzes> dylex: I'm not sure, more specifically i'm getting "/usr/bin/ld: /usr/local/lib/ghc-7.0.3/base-4.3.1.0/libHSbase-4.3.1.0.a(TopHandler__12.o): relocation R_X86_64_32 against `base_GHCziTopHandler_zdLr2haa_closure' can not be used when making a shared object"
08:11:18 <rotflcopter> maxBound :: data.word
08:11:23 <rotflcopter> does not work ;<
08:11:35 <mux> hah, found it
08:11:36 <dylex> ratzes: It could also mean something was not compiled with -fPIC
08:11:36 <kmc> i thought R_X86_64_32 is just the relocation type used for 32-bit fields in x86_64 machine code
08:11:41 <geheimdienst> > maxBound :: Data.Word
08:11:41 <lambdabot>   Not in scope: type constructor or class `Data.Word'
08:11:47 <geheimdienst> > maxBound :: Data.Word8
08:11:48 <lambdabot>   Not in scope: type constructor or class `Data.Word8'
08:11:53 <kmc> many x86_64 instructions take a 32-bit immediate operand, and you might want to relocate one
08:12:25 <kmc> I don't think it implies that you're mixing code between architectures
08:12:28 <dylex> kmc: Yes, that's right.  But in practice I've gotten those errors when things were built either with -m32 or not -fPIC
08:12:41 <rotflcopter> i would like to use Int32 how to do that?
08:12:52 <rotflcopter> and Int8 ?
08:12:56 <ratzes> dylex: would it fix it to recompile base with -rPIC?
08:13:05 <kmc> rotflcopter, import Data.Int
08:13:08 <geheimdienst> rotflcopter: check http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html . it should work if you spell it exactly as "maxBound :: Word" (note capital W)
08:13:31 <dylex> kmc: But you're probably right that it's not necessarily directly related.
08:13:36 <rotflcopter> kk thanks its working now :)
08:13:44 <kmc> dylex, ah, interesting
08:14:01 <HugoDaniel> kmc: i truly digged your post :)
08:14:04 <kmc> thanks
08:14:10 <kmc> (the blackholes one?)
08:14:21 <HugoDaniel> yes
08:14:23 <HugoDaniel> :D
08:14:54 <dylex> ratzes: Perhaps... What are you doing that's trying to link a static library (.a) into a shared library?
08:15:55 <ratzes> dylex: I'm trying to work with Jni (Java), so haskell to c, c to jni. I don't have that much experience with libraries and stuff, so I might be way off
08:16:15 <rotflcopter> but this website is fail
08:16:15 <rotflcopter> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
08:16:24 <rotflcopter> too many 404-s
08:16:38 <kmc> where
08:16:40 <kmc> works for me
08:17:02 <ratzes> dylex: i'm trying to run this: "ghc -optc-fPIC -shared -o libTest.so -optc-O test_JniTest.c Safe_stub.o -I/usr/lib/jvm/java-6-sun-1.6.0.26/include -I/usr/lib/jvm/java-6-sun-1.6.0.26/include/linux"
08:17:37 * hackagebot snappy-iteratee 0.1 - An enumeratee that uses Google's snappy compression library.  http://hackage.haskell.org/package/snappy-iteratee-0.1 (IanDuncan)
08:17:51 <Abraxas> to pick up an earlier question...\x -> foldr ((||).(==x)) is equal to \x -> foldl (flip$(||).(==x)), right?
08:18:16 <dylex> ratzes: have you tried adding -dynamic?
08:18:22 <Abraxas> for symmetric binary operators, can the foldl version always be the foldr version, only flipped?
08:19:07 <dylex> ratzes: and I think ghc knows what to do with -fPIC directly (without -optc)
08:20:09 <ratzes> dylex: ok, i'll give it a try, thanks
08:21:52 <vharishankar> kmc: I used my own unwrap function as in get_value [(a,b)] = a
08:22:18 <copumpkin> edwardk just fixed the monad/applicative hierarchy in library code, without changing the standard library
08:22:20 <vharishankar> to parse the reads
08:22:26 <edwardk> =)
08:22:58 <kmc> vharishankar, and what does it return on the empty list?
08:23:13 <Abraxas> @pl \f -> (\x acc -> f x : acc)
08:23:13 <lambdabot> ((:) .)
08:23:41 <ratzes> dylex: hmm, so when I run "ghc -fPIC -shared -o libTestlib.so -optc-O test_JniTest.c -I/usr/lib/jvm/java-6-sun-1.6.0.26/include -I/usr/lib/jvm/java-6-sun-1.6.0.26/include/linux" without any haskell in the .c, java reads it fine
08:23:53 <vharishankar> kmc: It should return "unrecognized" but the code doesn't compile now.
08:24:10 <ratzes> dylex: when I run with dynamic (same .c, no haskell), it doesn't work
08:24:48 <vharishankar> kmc: no wait. it returns
08:25:09 <vharishankar> I had modified the code partialy and that led to non-compiling
08:25:13 <dylex> ratzes: does it complain about missing libraries or something? -dynamic means to link in external libraries dynamically.
08:25:26 <vharishankar> Now it returns Token "Unrecognized" 0 when I pass an empty string
08:25:27 <Abraxas> @pl map f = foldr (\x acc -> f x : acc) []
08:25:27 <lambdabot> map = flip foldr [] . ((:) .)
08:25:54 <ratzes> dylex: I'm getting "java.lang.UnsatisfiedLinkError: /home/cdurham/workspace/Jni/libTestlib.so: /usr/local/lib/ghc-7.0.3/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.0.3.so: undefined symbol: stg_newByteArrayzh.."
08:26:22 <vharishankar> I'll paste the full code. Any suggestions would be welcome.
08:27:55 <hpaste> Harishankar pasted “Parsing an expression - beginning stages” at http://hpaste.org/53451
08:28:52 <kmc> this 'get_value' function is bad
08:28:56 <kmc> it will crash on most inputs
08:29:00 <kmc> lists of length other than 1
08:29:14 <kmc> this indicates that it's not a general function, you're just using it in that one place
08:29:20 <kmc> you should use 'case' in that place instead
08:29:23 <vharishankar> kmc: thanks
08:29:39 <kmc> or possibly a local function defined with "let" / "where"
08:30:03 <vharishankar> kmc: right. I think that is bad
08:30:04 <kmc> also why do you need "or (map (isDigit) st ++ map (=='.') st)"
08:30:16 <kmc> just pass it to reads
08:30:16 <dylex> ratzes: that is part of the RTS.  maybe you need to explicitly link in libHSrts_something.so... thought I'd expect ghc to do this.
08:30:21 <vharishankar> kmc: ok
08:30:26 <mux> I have just been trolled by SPJ
08:30:36 <kmc> vharishankar, you're not actually checking for failure of 'reads' here
08:30:40 <kmc> it's no better than just using 'read'
08:30:43 <mauke> a smooth criminal
08:30:54 <mux> there's a link to a new Octobor 2011 paper 'Giving Haskell a promotion (with Brent Yorgey, Stepanie Weirich, Julien Cretin, and Dimitrios Vytiniotis).  How to (a) add kind polymorphism and (b) promote data types to become data kinds.'
08:31:00 <kmc> you call reads but then you pass the result to the function get_value, which will crash if 'reads' does not succeed
08:31:04 <mux> but the link points to another page where I can't find the said paper
08:31:12 <dylex> ratzes: normally when you do this, the caller needs to initialize the rts (in code) which should load the library.  see 4.12.3  and 8.2.1.2 in the ghc manual.
08:31:12 <mux> which sounds terribly interesting
08:31:14 <mux> help!
08:31:15 <kmc> vharishankar, see also the hpaste recommendations
08:31:49 <byorgey> mux: you can get it here: http://www.cis.upenn.edu/~byorgey/papers/haskell-promotion.pdf
08:31:53 <kmc> vharishankar, in particular,  (s:[]) is [s],  and ([s] ++ st) is (s:st)
08:32:03 <vharishankar> kmc: right. I will work on those things. I was not satisfied myself with the code.
08:32:13 <ratzes> dylex: Oh, is that hs_init and hs_add_root call you're talking about?
08:32:16 <kmc> vharishankar, also, I doubt this is a very good token type
08:32:20 <dylex> ratzes: exactly
08:32:37 <kmc> vharishankar, using strings as tags like this is bad design
08:32:48 <mux> byorgey: yay, thanks!
08:33:02 <vharishankar> kmc: should I use the algebraic data types then? (Enum)
08:33:25 <kmc> yes except I don't know why you put "(Enum)" at the end of that
08:33:29 <ratzes> dylex: oh, i'll give it a try, thanks
08:33:30 <kmc> only some algebraic types are enumerations
08:33:35 <kmc> the one you use here would not be
08:33:49 <vharishankar> kmc: ok
08:34:12 <vharishankar> kmc: i mean it would be better to store the type as a type itself?
08:34:12 <kmc> vharishankar, i'd go with something like:   data Token = Number Double | Op Operator | Unrecognized;   data Operator = Plus | Minus | Multiply | Divide
08:34:20 <kmc> i don't know what that means
08:34:32 <vharishankar> OK, got confused.
08:34:45 <vharishankar> I understand your point now.
08:34:53 <kmc> :)
08:35:04 <ClockFrog> how do i convert a string like "345 567 2356" to int?
08:35:12 <mauke> which int
08:35:32 <vharishankar> kmc: I thought it might be easier to tackle one concept at a time. That's why I used strings instead.
08:35:46 <vharishankar> I agree with your point about not using strings as tags.
08:36:09 <mux> byorgey: I'm only on first page, but this is f***ing awesome. :-)
08:36:11 <kmc> vharishankar, I think you shouldn't be doing this exercise if you are not already comfortable with basic algebraic data types like that one
08:36:19 <kmc> maybe do something simpler?
08:36:25 <ClockFrog> well Num
08:36:43 <byorgey> mux: thanks =)
08:36:55 <vharishankar> kmc: right. I knew it wasn't quite as easy as I thought it would be.
08:37:06 <byorgey> ClockFrog: I think mauke means, what Int value should "345 567 2356" be converted to?
08:37:12 <mux> byorgey: "In our new system the above example is now valid Haskell!" made my eyes all watery with joy :D
08:37:28 <byorgey> mux: excellent, that's the impression we were going for ;)
08:37:29 <ClockFrog> its a string
08:37:43 <mux> haskell on steroids!
08:37:53 <ClockFrog> i need all of them so i can do operations on the numbers
08:37:56 <_jessopher> its a string that is also not unambiguously integral, there are spaces in it
08:38:03 <mauke> map read . words
08:38:04 <byorgey> ClockFrog: I mean do you want it converted to three separate Int values? or to 3455672356? or...?
08:38:22 <ClockFrog> three separate
08:38:41 <byorgey> ClockFrog: ok, then you want  map read . words  like mauke said
08:38:46 <mux> yo dawg, I heard you like types, and polymorphism, so I added more types to your types
08:39:12 <byorgey> we added types to your types so you can program while you program
08:39:21 <ClockFrog> thanks you =]
08:39:22 <mux> heh
08:39:34 <mux> byorgey: I suppose the 'Succ n thing was inspired by ML's 'a ?
08:39:44 <byorgey> mux: not particularly
08:39:57 <byorgey> mux: it's just the least horrible syntax we could think of
08:40:04 <mux> mmm I don't understand the need for it yet
08:40:13 <byorgey> although I still don't think it's all that great
08:40:47 <mux> oooh, it's a lot more clear when I don't jump on the examples and try to discipline myself to read things in order.
08:41:20 <byorgey> mux: haha, ok =)
08:42:56 <vharishankar> kmc: thanks a lot for those recommendations. Appreciated your feedback and corrections.
08:43:05 <mux> byorgey: I'll read more of it later (I'm at work now) and will make sure to give you my impressions. don't hold your breath though, I expect that most of this paper will be way over my head unfortunately
08:43:27 <kmc> cool :)
08:43:30 <kmc> glad i can help
08:43:50 <vharishankar> I will read the chapter on pattern matching and algebraic data types before I tackle this one
08:44:13 <kmc> cool :)
08:44:52 <byorgey> mux: great
08:45:05 <copumpkin> kmc: for your global lock, would noDuplicate work?
08:45:08 <vharishankar> Bye for now. Must leave now. :-)
08:45:09 <byorgey> mux: no worries, that's why we put all the fun examples and intuition first
08:45:21 <ratzes> dylex: what do i use for args to hs_init without a main function?
08:45:51 <kmc> noDuplicate where?
08:46:53 <dylex> ratzes: no args is fine: *argc = 1, *argv = {"progname"}.  it might even accept NULL for both -- not sure.
08:48:52 <copumpkin> kmc: the secret sauce behind unsafePerformIO
08:49:09 <copumpkin> kmc: and how it's built on top of unsafeDupablePerformIO
08:49:12 <kmc> i know about noDuplicate but I don't understand what you're proposing
08:49:48 <copumpkin> kmc: can that primitive be used for user code, and would it do what you want?
08:50:02 <kmc> i think it's relatively safe to use from user code
08:50:07 <copumpkin> for your global lock, that is
08:50:07 <kmc> but do what I want in which context?
08:50:15 <copumpkin> I saw you had a repo for a global lock
08:50:29 <copumpkin> I guess it's not global
08:50:30 <kmc> oh, you mean that noDuplicate itself would be the lock?
08:50:35 <copumpkin> yeah
08:50:38 <kmc> ah, I see
08:50:39 <copumpkin> but I don't think that'd work
08:50:50 <copumpkin> actually, hmm
08:50:50 <ratzes> dylex: thanks, yeah, that compiled, same link error though
08:50:52 <kmc> seems doubtful, yeah, but I'll think about that more
08:51:27 <dylex> ratzes: and hs_init is getting run before java tries to load the shared library?
08:53:16 <ratzes> dylex: I don't think so, I have a function in c that implements the native java function that calls hs_init inside
08:53:33 <ratzes> dylex: should i be structuring my c files differently?
08:54:44 <dylex> ratzes: maybe... where is that c function?  it can't be in the shared library, because you have to call it before loading the shared library.
08:55:41 <ratzes> dylex: it's in the test_JniTest.c so in the shared library...
08:56:26 <dylex> ratzes: Ah, yeah.  Where is the main entry point for the resulting program?  Is in a main() in C or something in java?
08:57:10 <ratzes> dylex: something in Java
08:57:36 <ClaudiusMaximus> hs_init() in a shared library works fine (when i tried it several years ago..), assuming it gets called before anything else in the library is called
08:59:01 <ratzes> ClaudiusMaximus: From Java, how would I ensure that hs_init is called first?
08:59:07 <dylex> ClaudiusMaximus: From C, you're right, but I suspect java is doing something extra. otherwise I'm not sure where the java.lang.UnsatisfiedLinkError for undefined symbol: stg_newByteArrayzh.. is coming from
09:00:55 <ClaudiusMaximus> maybe you need to link the ghc rts to the shared library?  things in that area have probably changed since i dabbled with it, so i'll shut up henceforth
09:01:56 <dylex> ClaudiusMaximus: that was my first thought too, but it looks like hs_init tries to load it itself, I think
09:02:17 <mdempsky> Not sure if it's relevant here, but shared libraries can have initialization routines that are called as soon as the library is loaded.
09:02:38 * hackagebot text 0.11.1.9 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.9 (BryanOSullivan)
09:02:42 <mux> I was about to mention that too; if indeed hs_init() dlopen() stuff itself, call it from _init() on UNIX systems
09:02:53 <mdempsky> In gcc, you just need to mark them with the __attribute__((constructor)); if you want to be portable, then use a C++ global object with a constructor.
09:03:09 <mux> or just use the _init() and _fini() symbols under UNIX? :-)
09:03:15 <mdempsky> mux: That's deprecated.
09:03:21 <mux> they were made for that very purpose
09:03:25 <mux> mdempsky: by whom? and when?
09:03:34 <mdempsky> http://tldp.org/HOWTO/Program-Library-HOWTO/miscellaneous.html
09:04:03 <mux> mdempsky: I don't see why I should believe that web page
09:04:20 <mux> the linux documentation project? heh.
09:04:30 <mdempsky> dlopen(3) too
09:04:32 <Abraxas> let map f xs = foldl (\g x y -> g (f x : y)) id xs [] in map (*2) [1..4]
09:04:33 <mdempsky> so glibc
09:04:42 <mux> maybe Linux guys decided it was deprecated on their systems, but they're alone
09:04:53 <mux> Linux people are not the authority when it comes to UNIX
09:04:59 <mux> and they should remember that more often, btw
09:05:04 <Abraxas> like foldl to foldr conversion for reverse, converted map from folr to foldl
09:05:32 <Abraxas> is that the shortest?
09:05:51 <Abraxas> basically just changed a few things for reverse in foldr without thinking about it much
09:06:12 <kmc> mux, damn kids get off my lawn!
09:06:19 <Abraxas> i mean, changed it from reverse to get this for map
09:07:34 <mux> kmc: that's the feeling, yeah :-P
09:09:31 <mdempsky> mux: If you want to define your own _init() routine, then you need to avoid linking in crti.o (or equivalent).
09:10:31 <mux> mdempsky: I don't want anything here, but if I wanted an initializator in a shared library, I'd just use _init(). I couldn't care less about the latest ramblings of the GNU/Linux community trying to reinvent stuff all the time (and especially the glibc people, fwiw)
09:10:48 <mdempsky> mux: This is true on OpenBSD too at least, so I don't know what to tell you.
09:10:57 <mux> _init() and _fini() are a de-facto standard that works on a broad variety of UNIX-like systems
09:11:08 <mux> that people decided to break it is not my concern
09:11:26 <mux> I'm actually surprised that OpenBSD would have problems with that too, but whatever, this is off-topic anyways
09:11:42 <kmc> eh "de-facto standard"
09:11:51 <mux> quite a contradiction eh? I know.
09:12:37 <ratzes> So with this issue, would it be an easier solution to not dynamically link and recompile ghc libs with -fPIC to avoid that relocation error?
09:16:47 <Abraxas> @pl (\x acc -> if x > acc then x else acc)
09:16:48 <lambdabot> join . (flip =<< (if' .) . (>))
09:21:22 <Abraxas> if the lambda contains ifs, pointfree is never a good idea, right?
09:21:30 <Abraxas> just playing around
09:22:46 <cheater> yea sounds stupid
09:22:57 <_jessopher> does anyone know where i can find a good description of how ghc seaches the include path IRT heirarchical modules? all my searching leads to very brief description, or broken links
09:23:20 <shachaf> Abraxas: That sort of statement is never correct.
09:24:26 <cheater> shachaf: That sort of statement is never correct.
09:24:54 <cheater> _jessopher: web.archive.org for the broken links maybe?
09:25:10 <_jessopher> worth a shot
09:26:07 <Abraxas> @pl map f xs = foldl (\g x y -> g (f x : y)) id xs []
09:26:08 <lambdabot> map = flip flip [] . flip foldl id . flip ((.) . (.)) . ((:) .)
09:29:58 <Abraxas> what would that look like if only the xs is left out?
09:34:15 <daveo> for a total newb to haskell, could someone recommend a good website/booksite please?
09:34:28 <hepek> learnyouahaskell
09:34:44 <daveo> ah, i've heard of that, thanks
09:35:11 <Phlogistique> daveo: another path is "gentle introduction to haskell", then "write yourself a scheme in 48 hours"
09:35:23 <bscarlet> real world haskell
09:35:27 <kmc> @where lyah
09:35:28 <lambdabot> http://www.learnyouahaskell.com/
09:35:29 <kmc> @where rwh
09:35:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:35:34 * Paks is reading learnyouahaskell right now
09:35:47 <Phlogistique> daveo: (the gentle introduction will teach you haskell, write yourself a scheme will teach you how to use it)
09:36:19 <sirvaliance> daveo: Yes, I am new to haskell as well, http://learnyouahaskell.com/ started reading it last night
09:36:40 <Abraxas> i am reading it right now :D
09:36:46 <bfig> daveo, if you like mathematics you might want to approach this a bit differently... in any case, make a point to rethink about any and every notion you've ever had about what the keywords used mean
09:36:58 <sirvaliance> daveo: Be patient, things start to get really interesting once you get to chapters 2-3
09:37:07 <sirvaliance> daveo: Keep a terminal with ghc open while you read
09:37:19 <daveo> Phlogistique: i will check both out paths
09:37:21 <sirvaliance> s/ghc/ghci
09:37:33 <daveo> sirvaliance: sounds like good advice
09:38:00 <Abraxas> @pl \x _ -> x
09:38:00 <lambdabot> const
09:38:05 <bfig> daveo, a valid approach is understanding lambda calculus/typed lc/system f
09:38:11 <Abraxas> oh lol
09:38:19 <sirvaliance> Phlogistique: "write yourself a scheme in 48 hours" Is that a suggestion or a tutorial/book to read?
09:38:36 <hepek> it's a book
09:38:57 <shlevy> :D
09:39:49 <daveo> bfig: oh that sounds easy, cough-cough
09:39:56 <Abraxas> after lyah, rwh, how does that sound?
09:40:23 <Abraxas> or gentle?
09:40:54 <Abraxas> gentle looks dry
09:40:55 <daveo> rwh + ?
09:41:01 <bfig> daveo, it is really simple, you don't need to understand the full power of untyped lambda calculus, but at least be familiarized with the notion of beta reduction and anonymous functions
09:41:03 <Abraxas> real world haskell
09:41:32 <bfig> daveo, just go ahead and google it. it can be summarized in a couple syntactic substitution rules
09:44:23 * copumpkin coughs: http://stackoverflow.com/questions/7978191/how-to-make-a-type-with-restrictions/7984155#7984155
09:48:49 <kirindave> I'm trying to express "a list of anything that matches this one typeclass"
09:49:20 <kirindave> Since you can't say [MyTypeclass], aren't you supposed to use a newtype to roll over this stuff?
09:51:11 <shachaf> kirindave: You mean a "heterogeneous" list?
09:51:19 <kirindave> shachaf, yes
09:51:29 <kirindave> shachaf, everything is an instance of my typeclass
09:51:32 <shachaf> You could use an existential type.
09:51:41 <shachaf> What's the actual type class, though? Often there are simpler ways.
09:51:53 <kirindave> I'm just writing some plumbing for cmdargs
09:52:08 <kirindave> one sec, I'll gist
09:52:13 <shachaf> E.g. instead of a list of things that have Show, you can use a list of Strings.
09:52:55 <nickname101> What's a library besides System.Random that is able to operate randomly
09:52:58 <kirindave> shachaf, since I am deliberately not trying to constrain this list of modes under anything but my typeclass, I don't think that's doable here
09:53:14 <nickname101> it doesnt have to be with numbers
09:53:20 <nickname101> it can be random result of a IO operation
09:53:26 <kirindave> shachaf, https://gist.github.com/137992655f77e767704c
09:53:27 <shachaf> kirindave: ?
09:53:42 <nickname101> I'm guessing Unsafe mgiht be one
09:53:46 <nickname101> but iam not sure
09:54:03 <kirindave> shachaf, I get a similar error even if I remove the extra type parameter for a.
09:54:55 <kirindave> shachaf, I guess I am confused why this code is a problem.
09:55:05 <nickname101> kirin dave, do you know
09:55:45 <shachaf> kirindave: There are several reasons it's a problem.
09:56:28 <kirindave> shachaf, the goal here is t be able to say runCmd $ cmdArgs modes, where modes is a [Command]
09:56:29 <shachaf> kirindave: You're trying to approximate an existential type, and you can do that, but what's the point of "a list of things with which I can do *nothing* except turn into an IO action" instead of "a list of IO actions"?
09:56:46 <kirindave> shachaf, because they will be used by cmdArgs
09:57:00 <kirindave> shachaf, which wants them to be other things.
09:57:09 <kirindave> So yeah, other constraints will have to be placed.
09:57:23 <shachaf> So there are more constraints than Command a =>?
09:57:34 <kirindave> Actually I think they'd be in Command a
09:57:40 <kirindave> Typeable and Show
09:57:58 <shachaf> Typeable? :-(
09:58:09 <kirindave> shachaf, go argue with cmdArgs
09:58:37 <kirindave> I just want a framework for writing commands to manipulate my chef environment in an extensible way. :D
09:58:51 <kirindave> And I figured this'd be a nice diversion with haskell while I am home sick.
10:00:02 <shachaf> I don't know much about cmdArgs.
10:00:27 <shachaf> But what you're trying to do seems slightly fishy.
10:00:40 <shachaf> @wiki Existential type
10:00:40 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
10:01:02 <shachaf> You can do that, but I'm not sure whether it'll really help you.
10:02:05 <kirindave> shachaf, ugh...
10:02:07 <kirindave> "A newtype constructor cannot have an existential context"
10:02:21 <copumpkin> yeah, because then it'd have to carry a dictionary around
10:02:37 <copumpkin> which is not the same representation as the underlying type
10:02:40 <copumpkin> :/
10:04:46 <kirindave> copumpkin, makes sense.
10:05:08 <kirindave> I guess I thought I could do this with newtype because of that example with the nesting of a list of Enumeratees
10:05:15 <kirindave> It had a sort of similar thing going on
10:05:28 <kirindave> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/92928 (near the bottom)
10:06:08 <copumpkin> ah yeah, it works fine as long as you have no context
10:07:24 <kirindave> Ahh
10:07:28 <kirindave> But now I can't do it
10:07:36 <mdxbhmt> Hey, stm on C# had failed, right?
10:07:37 <kirindave> Because now I am hiding my data in other data.
10:07:55 <kirindave> man is there no way to do cmdArgs without having everything defined statically from one type?
10:08:01 <copumpkin> mdxbhmt: that's the claim, yep
10:08:03 <copumpkin> understandably
10:08:17 <kirindave> If so, that sucks. You can't write extensible command harnesses with that library.
10:08:45 <shachaf> kirindave: ?
10:08:47 <copumpkin> mdxbhmt: lucky for us, those reasons don't apply to haskell's implementation
10:08:51 <mdxbhmt> copumpkin: is there any text about why it did and why haskell didn't? I found this but maybe there something more actual http://enfranchisedmind.com/blog/posts/the-problem-with-stm-your-languages-still-suck/
10:09:14 <copumpkin> mdxbhmt: the reasons haven't changed, but I haven't read that
10:09:16 <kirindave> shachaf, you have to define a single data type for all valid commands, which means it's all gotta be done in one shot in one place.
10:09:33 <kirindave> shachaf, you can't, say, have the type defined across multiple modules.
10:09:50 <copumpkin> mdxbhmt: the reason boils down to the fact that we don't use unrestricted mutable state. C# tried to keep logs on every mutation everywhere, which is impossible, but we typically only create a handful of STM vars and it only needs to keep track of that
10:09:57 <shachaf> Can you give an example of a thing you'd like to do that you can't?
10:10:02 <shachaf> (Not that I'm familiar with cmdArgs.)
10:10:11 <mdxbhmt> copumpkin: everywhere?! that's madness
10:10:13 <copumpkin> mdxbhmt: because of the language's type system, we can isolate accesses to those variables in particular and not have to keep track of STM stuff except where strictly necessary
10:10:16 <kirindave> shachaf, so imagine the cabal-dev executable. It has several commands
10:10:34 <copumpkin> mdxbhmt: they set out to do something impossible, failed, and then everyone cited their paper as the prime example of why STM (the concept as a whole) was flawed
10:10:42 <copumpkin> it's unfortunate that a bad experiment gave the idea a bad name
10:10:43 <kirindave> shachaf, if you use cmdArgs to do that, you need to have all those commands defined as type constructors for a single data type.
10:10:57 <mdxbhmt> i see, that's quite sad
10:11:23 <kirindave> shachaf, so there is one static type that enumerates all your modes. That kinda sucks if you want to keep the command implementations separate.
10:11:36 <mdxbhmt> copumpkin: I showed a teacher STM, he answered "look, MS abandoned it"
10:11:49 <copumpkin> mdxbhmt: yeah, that's precisely the situation I'm sad about
10:11:50 <mdxbhmt> that's why I was searching a good way of explaining it ;p
10:11:51 <copumpkin> lots of people say that
10:12:04 <kirindave> mdxbhmt, it is a bummer.
10:12:08 <shachaf> kirindave: Can you do something in the style of http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ ?
10:12:09 <kirindave> mdxbhmt, but it's out of scope
10:12:21 <copumpkin> mdxbhmt: but the crux of it is that haskell already has the facility to do fine-grained separation of types of state, so we can isolate STM easily
10:12:37 <mdxbhmt> yes, separating IO and STM does the job
10:12:38 <copumpkin> mdxbhmt: other languages are not so equipped and mostly allow unrestricted mutation everywhere
10:12:54 <copumpkin> we can prevent people from launching missiles in rollbackable code
10:13:01 <copumpkin> C# cannot
10:13:04 <Abraxas> foldr (\x _ -> x) [] [1..3]
10:13:14 <Abraxas> error
10:13:24 <copumpkin> "oh shit, the russians were just firing fireworks, call back the missiles"
10:13:25 <kirindave> shachaf, I do not think so
10:13:37 <Abraxas> but: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%5Cx+_+-%3E+x%29+%5B%5D+%5B1%2C2%2C3%5D
10:13:40 <Abraxas> no error?
10:13:48 <kirindave> shachaf, because of the types of cmdArgs, i can't nest my special annotated data objects inside another data object.
10:14:04 <Abraxas> error in ghci, not in stepeval
10:14:15 <mdxbhmt> I can see why C# need to track everything, they need because IO could happen anywhere. With haskell, the only place state is relevant is inside stm
10:14:40 <copumpkin> mdxbhmt: yeah, and even then they can't roll back many forms of IO
10:14:45 <copumpkin> anything that talks to the outside world
10:14:53 <copumpkin> it's going to happen
10:14:59 <Abraxas> is that stepeval too old or just not equivalent to ghci
10:15:05 <kirindave> shachaf, I am not sure who is in the wrong here... is it cmdArgs or haskell or am I mising some elegant way to solve this.
10:15:22 <kirindave> But it seems outright bad that you're restricted to ONE data instance for every possible mode your app could ever take
10:15:25 <Abraxas> i know there is just the prelude, but i thought that doesn't matter here
10:15:34 <kirindave> It's just crazy-unrealistic to couple code that way
10:15:54 <copumpkin> Abraxas: I think stepeval is just not checking types
10:16:00 <copumpkin> the type is bad, but it doesn't matter
10:16:06 <copumpkin> from an evaluation standpoint
10:17:25 <kirindave> is there a more flexible library than cmdargs?
10:17:48 <copumpkin> a lot of people don't like cmdArgs, but I've never looked into arg parsing :/
10:17:55 <copumpkin> so that people don't like it is most of what I know
10:18:37 <kirindave> Seems to me like an all-too-common example of "type safety ahead of best practice"
10:20:37 <daveo> .oart
10:33:08 <adimit> Can someone enlighten me what exactly Data.Function.fix is good for… I also don't understand the implementation: fix f = let x = f x in x — that doesn't seem to do anything, no?
10:33:19 <adimit> it's circular at least…
10:34:44 <Ferdirand> it evaluates to f x, which may evaluate to f (f x), which may evaluate to f (f (f x)), etc
10:35:20 <MostAwesomeDude> adimit: It's the lazy Y combinator. You don't *need* it in Haskell, but it's convenient for expressing certain things occasionally.
10:35:39 <mercury^> > fix (\f n a -> case n of 0 -> a; n -> f (n-1) (n*a)) 10 1
10:35:40 <lambdabot>   3628800
10:36:17 <erus`> > take 5 $ fix (1:)
10:36:18 <lambdabot>   [1,1,1,1,1]
10:37:02 <adimit> so it abstracts over recursion?
10:37:28 <copumpkin> yeah
10:37:40 * hackagebot cqrs 0.2.1 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.2.1 (BardurArantsson)
10:38:03 <adimit> I guess I'll need to play around with it to fully understand it.
10:38:39 <mercury^> I do not find that it abstracts recursion; it implements a naming trick.
10:39:03 <mercury^> Its argument still has to explicitly call an argument (which will be named after itself)
10:39:24 <mercury^> self-reference
10:39:34 <Nimatek> @google you could have reinvented fix
10:41:05 <bfig> if you write it as the y combinator you will abstract recursion :)
10:42:37 <mercury^> Huh? It is already the Y combinator. And as I said, I find that it implements self-reference and does not abstract recursion.
10:43:28 <bfig> what is self reference if not recursion? with a single combinator and a bunch of ifs you can build any recursive function
10:44:19 <yitz> > fix $ (1:) . (1:) . (\xs -> zipWith (+) xs (tail xs)) -- admit: another classic example of fix
10:44:20 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:44:46 <_jessopher> let broken = fix fix
10:45:00 <bfig> > fix fix
10:45:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
10:46:23 <_jessopher> so much for self reference
10:47:40 * hackagebot hierarchical-clustering-diagrams 0.1 - Draw diagrams of dendrograms made by hierarchical-clustering.  http://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.1 (FelipeLessa)
10:47:58 <mrsolo> hi, if i want to write a log parser
10:48:07 <mrsolo> should i use parsec? or something else?
10:48:17 <yitz> > let f g 0 = 1; f g n = n * g (n-1) in fix f 5 -- adimit: an example of the general way to do recursion using fix
10:48:18 <lambdabot>   120
10:49:20 <_jessopher> i would just use readP
10:49:26 <_jessopher> ReadP*
10:50:37 <Abraxas> is fix the same as iterate?
10:50:54 <mercury^> No.
10:50:57 <mercury^> :t iterate
10:50:58 <lambdabot> forall a. (a -> a) -> a -> [a]
10:51:00 <mercury^> :t fix
10:51:01 <lambdabot> forall a. (a -> a) -> a
10:52:35 <mrsolo> _jessopher, thanks  will read up on readP
10:52:38 <adimit> yitz: thanks. I find it difficult to understand what exactly is going on though…
10:52:41 <Abraxas> fixpoint, yeah
10:53:32 <monochrom> my ISP is down, so you cannot find my "you could have re-invented fix" at the moment. but I could send you stuff if you really wanted
10:54:10 <monochrom> in short, fix is just canned recursion
10:55:04 <adimit> monochrom: I got it from the google cache, thanks :-)
10:55:11 <monochrom> nice
10:58:08 <bfig> Abraxas, fix will give you 'a function which passes itself as its first argument'
10:58:50 <monochrom> @bots
10:58:51 <lambdabot> :)
11:02:58 <Abraxas> @unlambda (\acc x -> x : acc)
11:02:59 <lambdabot>   unlambda: Unknown operator '('
11:03:06 <Abraxas> @unlambda \acc x -> x : acc
11:03:06 <lambdabot>   unlambda: Unknown operator '\\'
11:03:47 <byorgey> Abraxas: @unlambda is an interpreter for the esoteric programming language "Unlambda"
11:03:47 <monochrom> unlambda means something else
11:03:59 <byorgey> Abraxas: perhaps you are looking for @pl ?
11:04:00 <Abraxas> yeah :D
11:04:02 <monochrom> so much for self-documenting names
11:04:05 <byorgey> @pl \acc x -> x : acc
11:04:05 <lambdabot> flip (:)
11:04:09 <Abraxas> yes, i was using that earlier
11:04:18 <Abraxas> was wondering if this was the same
11:04:24 <byorgey> ah, fair enough
11:04:45 <byorgey> @free a -> [a] -> [a]
11:04:46 <lambdabot> Extra stuff at end of line
11:04:54 <byorgey> @free forall a. a -> [a] -> [a]
11:04:54 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:05:19 <byorgey> hmm, how does @free work?
11:05:21 <monochrom> perhaps you need to give a name to the function
11:05:33 <byorgey> @free cons :: a -> [a] -> [a]
11:05:34 <lambdabot> $map f . cons x = cons (f x) . $map f
11:05:37 <byorgey> aha
11:06:37 <mux> byorgey: isn't it possible to get rid of those single quotes by adding a keyword after data, such as "data kind ..." just like we have "data family" ?
11:13:08 <byorgey> mux: that would defeat part of the point, which is that you can use a data type as both a type AND a kind
11:13:35 <byorgey> mux: if you had to choose at the time of declaration that would lead to code duplication (like we have currently)
11:13:38 <mux> byorgey: yes I'm aware of that; but I didn't realize this was one of the points of this extension, nor did I see (yet) how this is useful
11:13:46 <mux> hrmmm
11:14:06 <byorgey> well, it's not super useful *yet*
11:14:25 <byorgey> but the direction we're going is to include more "dependent-type-ish" features
11:14:31 <mux> we'd still have less code duplication, right? I mean, without this ability, we can still fix the Typeable wart, can't we?
11:14:48 <byorgey> mux: yes, that's true
11:15:03 <mux> ok, I'm glad I understand at least that much :D
11:19:09 <aristid> byorgey: i hope we'll see nice matrix libraries that make use of these features
11:37:57 <DanBurton> Hello, everybody.
11:42:44 <Philonous> mux: How would the new keyword fix the problem? You still cant distinguish constructors and Types. (Unless you mean data kind Foo = Bar makes a Type with name "Bar" illegal)
11:45:11 * DanBurton wonders why constructors have to be upper-case; they behave like any ol' function
11:45:11 <shachaf> bfig: "a function which pases itself as its first argument"?
11:45:22 * shachaf scrolls down again...
11:45:29 <shachaf> This has been happening too much lately.
11:45:30 <yrlnry> :t fix
11:45:31 <lambdabot> forall a. (a -> a) -> a
11:45:42 <Philonous> DanBurton:  You can't pattern match on functions
11:45:44 <shachaf> DanBurton: You can pattern-match on them.
11:45:50 <DanBurton> ahhh
11:46:09 <bfig> you do fix f = .... and you use f as a function which takes it's first argument itself (fixed)
11:46:59 <bfig> ie, (\f -> somefunction). that f you get passed as a parameter is fix of itself
11:47:00 <shachaf> I understand how fix works, but f isn't taking itself as its first argument -- that would be "f f".
11:47:12 <Philonous> DanBurton:  They could still be lower-case, though.
11:47:13 <shachaf> fix f is f (f (f (f ...
11:47:19 <DanBurton> > let fibrec f 0 = 0; fibrec f 1 = 1; fibrec f n = fibrec f (n-1) + fibrec f (n-2) in map (fix fibrec) [0..5]
11:47:20 <lambdabot>   [0,1,1,2,3,5]
11:47:35 <DanBurton> wait a minute >,<
11:47:40 <DanBurton> I cheated
11:48:34 <DanBurton> > let fibrec f 0 = 0; fibrec f 1 = 1; fibrec f n = f (n-1) + f (n-2) in map (fix fibrec) [0..5]
11:48:35 <lambdabot>   [0,1,1,2,3,5]
11:48:39 <DanBurton> there we go
11:48:57 <DanBurton> wait, now I'm confused why my first version worked
11:49:22 <shachaf> DanBurton: "f" was just being passed around as a dummy argument.
11:49:26 <shachaf> It didn't do nothin'.
11:49:43 <musically_ut> :D
11:50:01 <shachaf> > let fibrec _ 0 = 0; fibrec _ 1 = 1; fibrec _ n = fibrec undefined (n-1) + fibrec undefined (n-2) in map (fix fibrec) [0..5]
11:50:01 <lambdabot>   [0,1,1,2,3,5]
11:52:16 <Philonous> We don't need no double negatives, don't we not?
11:54:15 <yitz> > fix $ (True:) . map not
11:54:17 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
11:54:45 <joe9> i want to source a file in .ghci: http://codepad.org/1XmTHEep . I can do :script <file> at the ghci prompt and it works fine.
11:54:58 <joe9> but, am curious about why that would not work in the .ghci file.
11:55:26 <joe9> :def source readFile might help me.
11:55:30 <joe9> let me try that.
11:56:13 <yrlnry> > fix (map not) . (True:)
11:56:14 <lambdabot>   Couldn't match expected type `a -> b'
11:56:15 <lambdabot>         against inferred type `[GHC.B...
11:56:56 <yrlnry> whoops, didn't get in the $
11:57:10 <yrlnry> > fix $ (map not) . (True:)
11:57:12 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
11:57:39 <yrlnry> that is very interesting.
11:59:45 <yrlnry> I cant think offhand of any Int -> Int functions that can be usefully fixed, because there aren't any Int - Int operations that do anything useful with _|_.
12:01:07 <hpaste> yitz pasted “Useful in .ghci for creating Haskell shell scripts” at http://hpaste.org/53456
12:01:22 <yitz> joe9: ^^
12:01:56 <joe9> yitz, thanks.
12:03:04 <kirindave> yitz, you know what I also found useful in making shell scripts?
12:03:10 <kirindave> And i was sorta surprised didn't exist
12:03:11 <kirindave> http://hpaste.org/53457
12:03:33 <joe9> yitz, i seem to be missing something: http://codepad.org/O8wXIwbF
12:03:34 <kirindave> A lot of shell scripts are expected to fail silently.
12:03:37 <parcs> yrlnry: also very slow :P
12:03:46 <joe9> i can see the functions listed, but cannot access them with :t
12:04:00 <Abraxas> is the person present who helped me two days ago with the concatmap/filter replacing list comprehension thing
12:04:09 <confound> yrlnry: _|__
12:04:35 <Abraxas> this hpaste: http://hpaste.org/53372
12:05:08 <yrlnry> Nonstrict operations on integers are few and far between.
12:05:14 <Abraxas> because it seems this is also working: filter (\(x,y) -> x `mod` y > 0) $ concatMap (\x-> (map (\y -> (x,y))  [1..x] )) [1..100]
12:05:18 <yrlnry> Successor operation is nonstrict, but I can't think of anything useful to do with it.
12:06:07 <yitz> joe9: when it loads the module passed on the ghci command line, that creates a new context and it forgets the let bindings :(
12:06:13 <Abraxas> just got that by accident while trying to use the $-operator to create tuples...ended up not using that at all :D
12:06:23 <joe9> oh, ok. yitz.
12:06:44 <joe9> yitz, is there anything that I can do instead of having to keep repeating the :source commands?
12:06:52 <joe9> for every :r or :l
12:07:15 <yitz> kirindave: i might call it "naively"
12:07:23 <Abraxas> damn, i could just check the logs...no, wavewave is not here =)
12:07:43 <kirindave> yitz, naivety is the mother of optimism, perhaps? :D
12:08:35 <yitz> kirindave: ;)
12:09:37 <yitz> joe9: you can have 2 modules in scope, :r will reload both of them
12:10:41 <JoeyA> Is a TChan guaranteed to act as a FIFO queue?
12:10:54 <yitz> gotta run bye all
12:10:59 <JoeyA> (if there is one producer and one consumer)
12:11:45 <JoeyA> More generally, will a single-threaded producer's writes be read back in the order written? (even if other thread messages are interleaved)
12:14:01 <SegFaultAX|work> I'm having trouble building Haskell platform from source. It says that in order to build the platform I must first have GHC itself installed. When I attempt to build the current version of GHC it fails due to lack of GHC. :/
12:15:32 <SegFaultAX|work> I'm not opposed to installing GHC through my distros package manager, but if I could build it from source that would be ideal.
12:17:01 <c_wraith> SegFaultAX|work: building ghc requires a working ghc.  Bootstrapping it is not currently practical
12:17:21 <SegFaultAX|work> c_wraith: Why is that? Any ideas?
12:17:28 <kirindave> SegFaultAX|work, unless you are on an unsupported platform, it is not so tough a thing
12:17:29 <c_wraith> because ghc is written in haskell
12:17:44 <kirindave> SegFaultAX|work, and many language implementations share this feature.
12:18:01 <SegFaultAX|work> Ah, I understand.
12:18:32 <SegFaultAX|work> So I want to at least be running a 7.x branch of GHC if at all possible. It looks like the latest builds for my distro are from 2010.
12:18:47 <SegFaultAX|work> Is there an active PPA I can install from instead of using apt?
12:19:19 <c_wraith> Just use the binary release.
12:19:21 <SegFaultAX|work> Rather, instead of using whatever version is the in the universe debs.
12:19:49 <c_wraith> http://haskell.org/ghc/download_ghc_7_0_4
12:19:56 <SegFaultAX|work> c_wraith: In other words, use the generic Linux x86_64 ghc to build the Haskell platform?
12:20:00 <c_wraith> yeah
12:20:23 <SegFaultAX|work> c_wraith: Any reason I should be using 704 to build instead of the current edge version?
12:20:24 <Cale> SegFaultAX|work: What I do is just to install the generic linux binary, and then get the tarball of cabal-install from hackage and run the bootstrap.sh script from that
12:20:46 <c_wraith> 7.2 was only intended as a technology release
12:20:53 <Cale> SegFaultAX|work: and then once you have cabal-install, the rest of the Haskell Platform doesn't matter so much, because you can pull it in easily as you need it
12:20:56 <c_wraith> it was never intended as a real release version
12:21:06 <c_wraith> err, intended as a technology preview version
12:21:08 <SegFaultAX|work> c_wraith: Oh, sorry didn't know that.
12:21:16 <Cale> (7.2.1 does have some cool features in it though ;)
12:21:17 <SegFaultAX|work> Cale: That sounds like the path of least resistance for me.
12:21:32 <Cale> (but yeah, 7.0.4 is probably more stable)
12:21:50 <kirindave> A lot of stuff "compiles" for 7.2.1 but breaks at runtime, ime.
12:21:54 <c_wraith> yeah, I do the same.  I haven't installed the haskell platform in a long time
12:21:56 <SegFaultAX|work> Is GHC written entirely in Haskell?
12:22:06 <c_wraith> no, parts of GHC are native code.  Mostly the runtime system
12:22:21 <Cale> kirindave: oh really? That doesn't sound great. I haven't seen much of that yet.
12:22:34 <SegFaultAX|work> c_wraith: So the bare minimum is written in platform independent C or asm, and the rest is pure Haskell?
12:22:55 <SegFaultAX|work> Just enough to bootstrap the vm in other words.
12:22:58 <Cale> Yeah, the RTS is mostly written in C, and the rest is pretty much Haskell
12:23:05 <Cale> There's a perl script too :)
12:23:11 <c_wraith> the perl script is obsolete now!
12:23:12 <c_wraith> yay!
12:23:12 <SegFaultAX|work> Cale: Hah, I saw that.
12:23:14 <c_wraith> :)
12:23:21 <Cale> c_wraith: I thought there was a new one?
12:23:23 <SegFaultAX|work> Why is Python marked as a build-dep for Haskell?
12:23:25 <c_wraith> oh, maybe
12:23:34 <c_wraith> the evil mangler is obsolete, though! :)
12:23:50 <rotflcopter> hi
12:23:55 <Cale> Yeah, the new perl script, whatever it is, is hopefully less evil than the old one ;)
12:24:08 <Cale> SegFaultAX|work: Now that I have no idea
12:24:59 <SegFaultAX|work> I don't suppose any of you use xmonad, do you?
12:26:17 <kirindave> Cale: Try HSH for an easy example
12:26:28 <kirindave> cale: Most of the other cases I run across are more involved
12:26:33 <kirindave> Maybe it was fixed tho
12:27:36 <Cale> SegFaultAX|work: I don't use it, but I tend to be able to help with many problems anyway. :)
12:27:51 <kirindave> SegFaultAX|work, I do
12:28:09 <kirindave> SegFaultAX|work, There is a whole channel on the subject of #xmonad
12:28:11 <SegFaultAX|work> Cale: I was just looking for peoples input. I'm a big fan of awesome, but xmonad looks quite interesting.
12:28:53 <SegFaultAX|work> kirindave: I like the way xmonad looks because it seems to be lowering the entry barrier for new users (of tiling WMs)
12:29:14 <SegFaultAX|work> kirindave: But I'm worried it would be too much of a jump from awesome.
12:29:16 <kirindave> SegFaultAX|work, I think that is Awesome's purview. XMonad is incredibly powerful but asks you to put in time configuring it.
12:29:43 * dcoutts points out that anyone interested in developments in cloud haskell should join the parallel-haskell mailing list
12:29:54 * dcoutts sends out design notes for cloud haskell transport layer
12:30:01 <Cale> If you like tiling window managers, you'll probably like xmonad. Personally they don't really seem to fit into how I want to work with my windows, but that's just me.
12:30:02 <kirindave> dcoutts: where does one do that?
12:30:09 <dcoutts> http://groups.google.com/group/parallel-haskell
12:30:35 <kirindave> Done
12:30:39 <kirindave> Cloud haskell interests me
12:30:51 <kirindave> Are there compiler extensions for it yet?
12:31:03 <dcoutts> kirindave: not yet
12:31:09 <dcoutts> but it works without
12:31:19 <kirindave> Yeah I saw the template haskell syntax.
12:31:21 <dcoutts> just slightly more clunky
12:31:34 <SegFaultAX|work> Cale: That's because you want to work with windows.
12:31:36 * kirindave just read the paper the other day
12:31:38 <Yarou> only tiling wm i've ever used is ratpoison
12:31:40 <SegFaultAX|work> Cale: I don't. :)
12:31:51 <SegFaultAX|work> Yarou: Hell yea, ratpoison.
12:32:00 <kirindave> dcoutts: I'm excited at the prospect of that level of development in haskell. Distributed infrastructure is sort of my whole job these days. :)
12:32:50 <SegFaultAX|work> kirindave: Now we just need a scalable RDBMS/No-sql (I shudder at that term) db written in Haskell.
12:33:08 <dcoutts> kirindave: ah. The cool thing about the cloud haskell thing is that you get to program the whole cluster from the point of view of a single program, rather than ones view always being of writing the code for a single node.
12:33:29 <kirindave> dcoutts: As an erlang veteran that idea is interesting
12:33:33 <kirindave> With erlang you _sorrrta_ do that
12:33:36 <dcoutts> right
12:33:47 <kirindave> But it's more like considering the whole cluster from the perspective of a single tree of processes
12:34:12 <dcoutts> if you're using erlang's networking
12:34:31 <dcoutts> of course people also just write single-node erlang programs that communicate using standard protocols
12:34:36 <dcoutts> like we do in Haskell now
12:34:44 <kirindave> Yep
12:34:52 <kirindave> Erlang's networking is really good.
12:34:58 <kirindave> So no one is really afraid to use it
12:34:59 <dcoutts> but it's not quite the same as directly writing a distributed algorithm
12:35:18 <rotflcopter> i'd have a feature request for ghc, would you do that basic pixel drawing be available in a simple program window without any cabal brainfuck ?
12:35:25 <dcoutts> kirindave: you mean erlang's internal network protocol right
12:35:30 <Cale> rotflcopter: ?
12:35:49 <rotflcopter> (cabal, and extra libs still dont working)
12:35:51 <kirindave> dcoutts: And the protocols that it uses to form clusters, yes.
12:36:05 <rotflcopter> so cannot try out circle routine
12:36:17 <applicative> what platform are you you using, rotflcopter
12:36:25 <rotflcopter> 64 bit linux
12:36:33 <rotflcopter> with too small / partition
12:36:53 <Cale> rotflcopter: http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
12:36:58 <dcoutts> kirindave: sorry, I mean internal as in internally defined, not a standard external network protocol
12:37:07 <kirindave> dcoutts: Ahh.
12:37:07 <Cale> ^^ did you try grabbing that and running the bootstrap.sh script from it?
12:37:13 <rotflcopter> i have a raytracer program that can write in image file with no problem
12:37:33 <rotflcopter> but it is a big thing to ask to draw same in somwe application window
12:38:05 <SegFaultAX|work> Thanks for the input ladies/gents. I'll working on getting the linux binary to build/install cabal.
12:38:13 <SegFaultAX|work> Off to lunch, back later. :)
12:38:36 <dcoutts> kirindave: so a cool thing that we've recently been looking at is control over the transport layer for the clustering
12:38:49 <rotflcopter> Cale<< well i have installed ghc platform, currently its up, and not working because cabal fails to read the config file, so i stopped trying to set it up
12:39:06 <kirindave> dcoutts: Tell me more.
12:39:17 <dcoutts> kirindave: erlang always uses udp (I understand), we're looking at allowing various transports, tcp, MPI etc
12:39:25 <kirindave> Ah
12:39:36 <kirindave> that is interesting
12:39:36 <dcoutts> kirindave: for details see the email I just posted to the parallel-haskell list
12:39:46 <rotflcopter> (used prefix to install because / has not eough free space to hold GHC)
12:39:58 <kirindave> It can be a bit disturbing tho. A lot of work goes into making a transort layer work well with the ebp
12:40:02 <kirindave> Buffer sizes, etc.
12:40:27 <Cale> rotflcopter: um... fails to read which config file?
12:40:43 <rotflcopter> ~/cabal / directories .. settings
12:40:45 <dcoutts> kirindave: according to some HPC people, erlang is no good for HPC because 1. interpreted is too slow, but 2. the udp transport is so baked in that it cannot be realisticly ported to high performance (non-IP) HPC interconnects
12:40:58 <Cale> rotflcopter: I think it shouldn't be an error for ~/.cabal/config to be missing...
12:41:02 <kirindave> dcoutts, yes. Although it is not like it is "SLOW"
12:41:20 <Cale> Though not being able to create it would likely be a problem
12:41:22 <kirindave> dcoutts, The boundary people have Scalatra, which can do like half a million message exchanges a second over udb.
12:41:25 <dcoutts> kirindave: not from my point of view, but according to crazy HPC people it's 100x too slow
12:41:37 <rotflcopter> Cale<< was thinking about writing ghc directories there so cabal caould in theory work
12:41:48 <kirindave> well that's probably more erlang's ebp serializer.
12:41:56 <Cale> rotflcopter: If you install things locally, they go in your home directory
12:42:00 <kirindave> dcoutts, what are these people doing? :D
12:42:09 <Cale> So if you have space left on /home, you should be fine using cabal
12:42:14 <kirindave> Any serialized protocol is gonna be slow, I suspect.
12:42:26 <dcoutts> kirindave: e.g. infiniband being 10x faster (esp latency) than 10 gigabit ethernet, and other new interconnects are 10x faster again, only 10x slower than main memory.
12:42:28 <Cale> (assuming that's how your partitions are set up)
12:42:43 <kirindave> dcoutts, That's  a level of HPC  never touch.
12:42:52 <dcoutts> kirindave: as I say, they're crazy hpc people :-)
12:42:56 <kirindave> I mostly work in the "thousands-to-millions-per-second between dozens of machines"
12:43:15 <rotflcopter> without prefix, programs would go to /usr/local by default on linux, though the cabal config somehow got into my /root/
12:43:17 <kirindave> But I suspect that you'll end up with serialization costs being the real bottleneck
12:43:24 <dcoutts> kirindave: so my task has been to work out a design that accomodates the hpc transports without making the normal ip ones more complicated
12:43:31 <rotflcopter> but no matter, not working
12:43:32 <roconnor> how do I get a random command of type IO Word64?
12:43:38 <Cale> rotflcopter: If you sudo cabal install, that's probably what's happening
12:43:50 <Cale> rotflcopter: You're meant to run the cabal program as your normal user
12:43:51 <applicative> rotflcopter: is there a ~/.cabal/config file?
12:43:54 <rotflcopter> yes i was root when i installed
12:44:08 <Cale> Yeah, don't be root, and I bet it'll work
12:44:13 <roconnor> oh maybe I just didn't import the instance
12:44:35 <rotflcopter> Cale<< it would work, tried to run it as root also.
12:44:47 <kirindave> dcoutts: this mailing list is fantastic.
12:45:03 <dcoutts> kirindave: aye, possibly so, though I guess people who really care will be using big arrays which we can serialise directly without copying
12:45:05 <kirindave> Just read your email about how 7.4 will have traceEvent. YESSSSS is all i can say.
12:45:05 <rotflcopter> was thinking about if ghc is a compiler i install as root
12:45:15 <rotflcopter> am i mistaken something?
12:45:18 <dcoutts> kirindave: oh right, yes :-)
12:45:25 <kirindave> dcoutts: or some sort of shared memory scheme where the array IS the transport layer ;)
12:46:00 <dcoutts> kirindave: mm, it'd at least need a copy
12:46:55 <kirindave> dcoutts: Once cloud haskell has a compiler extension it's going to be pretty impressive tho.
12:47:04 <dcoutts> hope so
12:47:07 * dcoutts disappears
12:47:28 <applicative> rotflocopter, but the obvious things work, you can use ghci, and do ghc --make and e.g. if you do cabal install pony, then can-i-have-a-pony is compiled
12:48:12 <rotflcopter> maybe i could make it work somehow, chroot, reinstall, bindmount, softlinks, but ddiidn't have the motivation to find the reasons yet
12:49:22 <rotflcopter> applicative<< yes basic ghc ghci works, cabal - no
12:49:48 <rotflcopter> and basic does not include graphic display for me
12:50:52 <applicative> rotflcopter: but i wonder if you are just having difficulty getting the gui libraries linked in the right ways?
12:51:20 <rotflcopter> applicative<< i used --prefix to install, this is why cabal failing to find things
12:51:55 <monochrom> "cabal install --global" follows unix convention of /usr/local, sure.
12:51:59 <rotflcopter> it would probably work if i didnt specify --prefix, and would have addidtional 2GB free space on /
12:52:20 <monochrom> the thing is that "cabal install" defaults to "cabal install --user" which goes to $HOME/.cabal
12:52:49 <monochrom> now throw in "sudo" or "su" before it, and you get /root/.cabal
12:52:58 <rotflcopter> yes
12:53:18 <monochrom> so just add --global to restore the unix convention
12:53:22 <rotflcopter> root's home is /root, but would that make cabal not work?
12:53:42 <monochrom> then it works for the user called "root"
12:53:50 <rotflcopter> no it does not
12:53:57 <rotflcopter> it cant find ghc
12:54:07 <rotflcopter> and i dont know whatever
12:54:11 <monochrom> then root's PATH is incomplete
12:54:16 <rotflcopter> no
12:54:23 <rotflcopter> ghc is installed with prefix
12:54:34 <rotflcopter> it is not on /.
12:55:04 <Cale> rotflcopter: That's okay, so long as the ghc program is runnable because it's in your user's PATH (root's PATH in this case)
12:55:08 <rotflcopter> cabal is installed with prefix also.
12:55:45 <rotflcopter> so anyway cabal would dump the downloaded libraries in ~/cabal ?
12:55:52 <Cale> rotflcopter: yes
12:55:57 <Cale> ~/.cabal
12:56:07 <rotflcopter> why not in the install directory?
12:56:11 <rotflcopter> or next to ghc?
12:56:11 <Cale> and it puts the installation info for ghc into ~/.ghc
12:56:38 <Cale> Well, most people find it convenient not to touch the set of global packages installed with ghc
12:57:04 <Cale> and install all additional packages as user, because it's not that uncommon to get into sticky situations with dependencies
12:57:16 <rotflcopter> and im concerned about filling my home directory with debug logs, and libraries
12:57:29 <Cale> and blowing away ~/.ghc is much easier to cope with than reinstalling ghc
12:57:53 <Cale> It's all in hidden files :P
12:57:55 <rotflcopter> but
12:58:12 <rotflcopter> prefix/libraries/cabal would be nicer no?
12:58:22 <rotflcopter> next to ghc libs ?
12:58:27 <yottabit> beep
12:58:48 <Cale> rotflcopter: It's also really convenient not to have to sudo just to install packages
12:58:59 * monochrom is not interested in debates
12:59:10 <rotflcopter> Cale<< actually i'd prefer installing every package to make it offline
12:59:12 <Cale> Especially as installing packages from Hackage may run arbitrary code on your machine
12:59:24 <Cale> (though in practice, they don't)
12:59:36 <monochrom> if you're just looking for someone to agree with your opinion, I know a standard unix program for that.
12:59:59 <Cale> Once you install the packages, you don't need a connection to the Internet to continue using them
13:00:24 <rotflcopter> sure
13:00:29 <rotflcopter> so what does cabal do?
13:00:49 <Cale> cabal downloads, builds, and configures packages
13:01:05 <rotflcopter> and what does it do i cant ?
13:01:19 <Cale> trace dependencies
13:01:30 <Cale> and download, build, and install those
13:01:33 <monochrom> craft up package.conf files correctly
13:01:44 <rotflcopter> aham
13:01:47 <Cale> yeah, and craft package.conf files so ghc knows where everything is
13:01:53 <rotflcopter> isnt that a bash script enough for that?
13:02:09 <Cale> Why use a bash script when you can use a program written in Haskell? :)
13:02:14 <Cale> But seriously, no.
13:02:17 <rotflcopter> aham i see
13:02:23 <rotflcopter> 8MB instead of 8kB :)
13:02:29 <Cale> cabal includes a dependency solver
13:02:29 <rotflcopter> and cannot parse config file
13:02:45 <Cale> Writing even a topological sort in bash would be painful enough
13:02:56 <rotflcopter> there is coreutils btw
13:03:23 <rotflcopter> sort application does well in sorting
13:03:27 <monochrom> why don't you implement what you said and show it
13:03:33 <Cale> Not the kind of sorting we're doing ;)
13:03:39 <monochrom> because you prefer arguing over proving
13:03:55 <Cale> Please just use cabal-install and stop worrying :)
13:04:00 * applicative_ wonders what unix program will agree with his dubious opinions
13:04:14 <monochrom> the program is called "yes"
13:04:44 * applicative_ has found it
13:05:08 <monochrom> it could also be instructed to say "no", if you feel like it
13:05:12 <rotflcopter> what="compiler";sed -nr 's;[ -]*'"$what"':[ ]*([^ ][^ ]*).*;\1;p' ./config
13:05:18 <rotflcopter> sed -nr 's;^[ ]*([a-z,A-Z,0-9][a-z,A-Z,0-9,\-]*[ ]*):[ ]*([^ ][^ ]*).*;--\1="\2";p' ./config
13:05:35 <applicative_> "yes outputs expletive, or, by default, ``y'', forever."
13:05:39 <rotflcopter> well it seems not too difficult to parse the config file using a stream editor/regexp
13:06:33 <rotflcopter> so ghc would like to learn some logic from sed in config file parsing
13:06:42 <applicative_> rotflcopter, I think you would do well to do whatever monochrom, Cale and company do. Then communication about any further difficulties will be much easier.
13:07:19 <monochrom> hmm, what do I do? :)
13:07:31 <Cale> rotflcopter: I use Haskell in my daily job. If there were a better/easier way to do things, I would be recommending that.
13:07:46 <Cale> rotflcopter: What you're suggesting is much messier and harder than what I'm recommending you do.
13:07:56 <Cale> (and way way less maintainable!)
13:08:34 <rotflcopter> Cale<< you don't say its all-right to make a config file parser that counts number of spaces before a menu-element?
13:08:38 <rotflcopter> ;/
13:09:05 <Cale> rotflcopter: I'm saying that using regexes for anything serious is horrid.
13:09:34 <rotflcopter> i use regexps everyday and i like the idea of applying a logic function to any text-stream
13:09:36 * applicative_ thinks, regex bad parser-cominator good
13:09:41 * monochrom believes in "choose your poison" instead
13:09:54 <Cale> rotflcopter: When you learn about parser combinators, that will change ;)
13:10:36 <rotflcopter> Cale<< what kind of task do you do regularly using ghc?
13:10:58 <applicative_> he uses it to warm his cpu
13:11:05 <rotflcopter> :)
13:11:18 <rotflcopter> sure it can do that
13:11:25 <Cale> rotflcopter: We're writing a game (an action RPG called BloodKnight) for iPhones and other mobile devices.
13:11:46 <rotflcopter> hmm
13:11:57 <rotflcopter> and how will a mobil-e-phone run a ghc binary?
13:12:36 <Cale> rotflcopter: We have a custom cross-compiling backend for GHC which we're working on contributing back to GHC.
13:12:56 <ben> Are you in the games business or the compiler business? :3
13:13:25 <rotflcopter> Cale<< and will performance be at least as good as competitive technologies? like java?
13:14:00 <rotflcopter> mobile devices doesnt have much ocmputing power (yet)
13:14:10 <DanBurton> Hm hoogle has failed me. I thought the `maybe` function did this, but I was wrong. (a -> Maybe b) -> a -> b -> b
13:14:28 <applicative_> has anyone used the ConstraintKinds extension in ghc-7.3*
13:14:52 <kosmikus> applicative_: yes, but not much.
13:14:56 <applicative_> @type maybe
13:14:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:15:19 <DanBurton> @let orDefault f a default = case f a of Nothing -> default; Just x -> x
13:15:20 <lambdabot>   TemplateHaskell is not enabled
13:15:27 <DanBurton> -_-
13:15:28 <gentleben> rotflcopter: current generation smart phones are about as powerful as previous generation consoles and have decidedly more memory
13:15:31 <applicative_> kosmikus: I can use it, but does the same branch have the fancier kind system, with * -> Nat -> *
13:15:36 <DanBurton> @let orDefault f a b = case f a of Nothing -> b; Just x -> x
13:15:37 <lambdabot>  Defined.
13:15:56 <kosmikus> applicative_: no. I think that's still in the ghc-kinds branch.
13:16:03 <DanBurton> > orDefault (find (==3)) [1..5] 3
13:16:04 <lambdabot>   3
13:16:10 <DanBurton> > orDefault (find (==3)) [1..2] 3
13:16:12 <lambdabot>   3
13:16:21 <kosmikus> applicative_: which I failed to build a while ago, but I was told yesterday it should be easier now.
13:17:07 <applicative_> kosmikus: yes, that's in theory the one I built yesterday, following the instructions on the ghc wiki or wherever.
13:17:24 <applicative_> copumpkin knows maybe?
13:17:32 <copumpkin> I know nothing!
13:17:34 <copumpkin> what?
13:17:37 <kosmikus> applicative_: oh, so you have the ghc-kinds branch
13:17:48 <kosmikus> applicative_: but it doesn't work?
13:17:55 <copumpkin> you don't need ghc-kinds
13:18:02 <copumpkin> it's just GHC head
13:18:03 <applicative_> kosmikus: in theory I do,  ConstraintKinds works fine.
13:18:07 <Cale> rotflcopter: we think it should. The only question is the extent to which we can abstract things and still compile them to efficient code. We think we can actually build a really nice abstraction and still have things run efficiently (though we've yet to really prove it to the world!)
13:18:07 <copumpkin> for constraintkinds
13:18:10 <copumpkin> I built it a couple of weeks ago
13:18:16 <kosmikus> sure, for constraint kinds
13:18:23 <kosmikus> but applicative_ wants to use promotion
13:18:25 <copumpkin> oh okay
13:18:26 <applicative_> copumpkin: yes, but I really want * -> Nat -> *
13:18:28 <copumpkin> then yeah
13:18:29 <rotflcopter> cool then
13:18:32 <applicative_> i want a promotion!
13:18:45 <kosmikus> applicative_: so what's the problem?
13:18:45 * copumpkin promotes applicative_ 
13:18:53 <rotflcopter> it would be even nicer if it didnt thrash my system at compile time, or at some functions
13:19:05 <Tekmo> I have an optimization question.  I'm trying to compute a distance matrix between 3-D points and I'm trying to see how fast I can get Haskell to go compared to the equivalent C version
13:19:06 <applicative_> kosmikus, ghc rejects my kind!
13:19:17 <rotflcopter> and if it could do realtime-application then it would be ace
13:19:20 <zomg> We don't like your kind here.
13:19:22 <zomg> =)
13:19:28 * applicative_ sulks
13:19:39 <kosmikus> applicative_: perhaps dreixel can help
13:19:40 <DanBurton> @smack applicative_
13:19:41 <lambdabot> I don't perform such side effects on command!
13:19:51 <copumpkin> I was doing some haskell type-level wankery on stackoverflow today
13:19:58 <copumpkin> and it could've benefited from the new kinds
13:20:11 <kosmikus> applicative_: I should first try to build that branch myself
13:20:19 <kosmikus> copumpkin: link?
13:20:20 <Tekmo> I've already identified the bottleneck, which is just filling out the actual matrix with the values, not the computation of the values themselves
13:20:29 <applicative_> i don't consider * -> Nat -> * to be wankery.
13:20:36 <copumpkin> kosmikus: http://stackoverflow.com/questions/7978191/how-to-make-a-type-with-restrictions/7984155#7984155
13:20:39 <copumpkin> applicative_: mine was wankery
13:21:02 <Tekmo> The fastest code I've gotten is within a factor of 3 of C and basically looks like this:
13:21:33 <rotflcopter> a retro question :) will ghc be faster than the old turbo-pascal ?
13:21:34 <DanBurton> Tekmo: hpaste?
13:21:37 <kosmikus> copumpkin: :)
13:21:41 <Tekmo> How do I use hpaste?
13:21:46 <Tekmo> Let me check
13:21:49 <rotflcopter> (in assembly, things were >300 times faster)
13:21:52 <sirvaliance> What would be a good example of small Haskell module where I could look at the code for an example.  Ideally to get a good idea of proper file structure, tests, etc.
13:21:52 <applicative_> if i had * -> Nat -> *  I could have a pretty good refl too.
13:21:54 <DanBurton> http://hpaste.org/new/haskell
13:22:02 <Tekmo> Ok, got it
13:22:05 <copumpkin> applicative_: whatcha doing?
13:22:25 <hpaste> Tekmo pasted “DM” at http://hpaste.org/53459
13:22:50 <Tekmo> dmx is the function that creates the distance matrix
13:22:54 <applicative_> so far, I am using ConstraintKinds only, since I don't know how to jostle it into recognizing my attempted promotions. Is there another flag for that? Or maybe my branch is wrong
13:22:57 <Tekmo> ps is the list of points
13:23:07 <Tekmo> and 'dist' is the distance function
13:23:19 <DanBurton> copumpkin: that looks like some cool type wankery
13:23:23 <jajajajaj> yes
13:23:30 <Tekmo> I already profiled it and the distance function is very fast and dmx takes up most of the computation
13:23:32 <copumpkin> DanBurton: it's pretty standard stuff, but can be fun
13:23:51 <Nioate> what does it mean when I ask ghci to evaluate an expression, but it sits there apparently doing nothing (no processor use, no memory allocation)?
13:24:11 <Tekmo> I've tried various other approaches to fill the matrix
13:24:15 <Tekmo> Such as newArrayList
13:24:22 <copumpkin> applicative_: -XPolyKinds
13:24:32 <applicative_> Niote, a distasteful unproductive loop?
13:24:51 <Nioate> applicative_: it's smart enough to detect that?
13:25:03 <Nioate> and if so, why not produce an error instead of nothing
13:25:31 <DanBurton> Tekmo: I don't know a lot about such things, but have you tried Data.Vector?
13:25:53 <Tekmo> Not yet
13:26:01 <hpc> sirvaliance: take a look at the prelude
13:26:09 <jajajajaj> 582 jv41
13:26:18 <rotflcopter> Cale<< actually i always hated java and still dont support that, nor flash
13:26:18 <sirvaliance> hpc: Thanks, will do :)
13:26:28 <rotflcopter> so go for it
13:26:33 <applicative_> Niote, many empty loops don't take much to keep going.  It cant generally give errors for such cases.  There are a few where it says <<loop>> rather mysteriously.
13:26:51 <mdxbhmt> rotflcopter: The performance change from assembly to C is of 300* ?
13:27:00 <hpc> sirvaliance: most of the stuff there is good code, except for the partial-ness of some list functions and the codesplosion that is 'sort'
13:27:01 <DanBurton> Tekmo: that might make a good StackOverflow question, assuming your deadline is not in the next hour.
13:27:09 <Tekmo> It's not urgent
13:27:12 <rotflcopter> mdxbhmt<< to turbo pascal :)
13:27:19 <rotflcopter> C is fair
13:27:30 <Tekmo> I was just curious why ghc wouldn't optimize the inner loop further
13:28:00 <Tekmo> Do you think it's because Storable Array is using Boxed values?
13:28:06 <rotflcopter> mdxbhmt<< but also C has inline ASM so you can hardcode what you want
13:28:08 <mdxbhmt> rotflcopter: hmmmm, interesting
13:28:10 <DanBurton> That would make sense
13:28:20 <jajajajaj> 712 VG2
13:28:28 <DanBurton> If you are just storing floats, then unboxed mutable arrays ought to be faster
13:28:30 <applicative_> copumpkin: my compiler claims not to recognize {-# LANGUAGE PolyKinds #-}  I know it's lying.
13:28:39 <mdxbhmt> I guess i can use that anytime someones talks about speed
13:28:39 <_jessopher> Nioate: you can use trace to see where its looping
13:29:24 <_jessopher> or where its blocking.. if something more dubious is going on
13:29:46 <gwern> @remember dons Being really mean to your software, and following up when it breaks, makes it a lot better. But you have to be really, really mean.
13:29:46 <lambdabot> Good to know.
13:29:53 <gwern> @flush
13:30:04 <rotflcopter> mdxbhmt<< in 2001 it was spectacular to write an asm putpixel/line/polygon drawing function and rewrite some function to use that instead of builtin :)
13:30:28 <rotflcopter> circles filling screen like random noise
13:30:34 <DanBurton> @quote dons
13:30:35 <lambdabot> dons says: screw 'em. we have the technology.
13:30:54 <mdxbhmt> lol
13:31:41 <rotflcopter> btw i wrote a random function too
13:31:41 <Tekmo> If I go the unboxed array route, how do I serialize it quickly?
13:31:49 <rotflcopter> that uses TSC
13:31:51 <Tekmo> Data.Binary for IOUArray was too slow
13:31:56 <Tekmo> which was the reason I switched to Storable
13:32:08 <rotflcopter> its very fast
13:32:22 <rotflcopter> though pentium+ with TSC
13:32:29 <applicative_> Niote, is your program simple? you should paste it
13:32:45 <DanBurton> IOUArray was too slow? Hm..
13:33:21 <mdxbhmt> TSC?
13:33:33 <Tekmo> The Binary instance turns it into a list
13:33:36 <Tekmo> and then serializes that
13:33:39 <DanBurton> If you really *need* the speed, then hop on the mailing lists, StackOverflow, and /r/haskell. If all else fails, start emailing some developers.
13:33:47 <DanBurton> Tekmo: wow that's horrible =/
13:34:15 <rotflcopter> mdxbhmt<< TimeStampCounter that counts at cpu clock rate
13:34:30 <mdxbhmt> rotflcopter:  hm, i see
13:35:12 <behelit> hi guys. been writing a few smaller haskell-projects. thought i'd try to write a web application for fun. what framework does the community prefer? (or just mix and match?)
13:36:02 <mdxbhmt> Yesod , snap and happy comes to my mind
13:36:26 <ClockFrog> is there a replace sort of function or do i need to do my own?
13:38:05 <rotflcopter> btw
13:38:17 <rotflcopter> the best assembler is flatassembler i think
13:38:43 <erus`> god i wish Javascript was typed
13:39:10 <erus`> is there a nice strongly typed language that targets js?
13:39:21 <_jessopher> haskell :)
13:39:36 <rotflcopter> well browwser could download anything to run actually... like a bash script, ghc program
13:39:42 <erus`> ghcjs didnt work for me last time i tried :(
13:40:06 <behelit> ok, so snap looks good.
13:40:32 <_jessopher> well thats a bummer.
13:41:04 <rotflcopter> nah some music Anastasia vs. Dumonde-Fly to the sky.mp3
13:41:21 <mattp_> erus`: there is clojurescript. what does that count as
13:41:35 <erus`> lisp pain?
13:42:46 <applicative_> ClockFrog, what  do you mean? map is a 'replace' function
13:43:50 <BlankVerse> doesn someone know how to statically link haskell files so that it runs without missing libraries error in another system
13:43:53 <BlankVerse> http://www.haskell.org/haskellwiki/Web/Literature/Static_linking
13:43:55 <BlankVerse> what is the right way to do it if any
13:44:19 <erus`> clojurescript looks quite cool
13:44:40 <erus`> i wish haskell had a nice js compiler. Even a subset of haskell
13:45:13 <rotflcopter> 298 Dec  2  2006 hello.asm
13:45:18 <rotflcopter> 160 Dec  1  2006 hello
13:45:20 <rotflcopter> :)
13:45:27 <steakknife> Likely an apropos q, maybe not: Any go (the game) groups in the sf bay area?
13:45:46 <rotflcopter> elf 32 bit binary
13:45:49 <cicatristeza> can you folks recommend some tutorials for snap? i have read the online docs but they are not exhaustive
13:46:07 <shachaf> steakknife: Yes, there are a few.
13:46:14 <applicative_> > let clockFrog 7 = "ClockFrog"; clockFrog n = show n in map clockFrog [1..10]
13:46:15 <lambdabot>   ["1","2","3","4","5","6","ClockFrog","8","9","10"]
13:46:17 <shachaf> steakknife: There's also a Haskell group. :-)
13:46:52 <arcatan> cicatristeza: i don't know about any tutorials, but if you have specific questions, I suggest you try asking them on #snapframework
13:47:03 <copumpkin> there's usually strong overlap between haskell and go
13:48:21 <_jessopher> erus`: have you tried york?
13:48:21 <DanBurton> copumpkin: erm...what? Haskell and Go?
13:48:23 <rotflcopter> # ./fasm.a fasm.asm
13:48:23 <rotflcopter> flat assembler  version 1.67.15  (16384 kilobytes memory)
13:48:23 <rotflcopter> 4 passes, 0.2 seconds, 70770 bytes.
13:48:29 <rotflcopter> fasm compiling itself ;>
13:50:16 <rferranti> quis custodiet ipso custodes
13:50:50 <applicative_> good question.
13:50:58 * applicative_ has a typechecker
13:51:21 <steakknife> Have to hire more security vendors, have them watch each other. :)
13:51:48 <rferranti> actually if the just watch each other, i'd be fine with that
13:52:34 <roconnor> @seen copumpkin
13:52:34 <preflex>  copumpkin was last seen on #haskell 5 minutes and 31 seconds ago, saying: there's usually strong overlap between haskell and go
13:52:34 <lambdabot> Unknown command, try @list
13:52:41 <copumpkin> ohai roconnor
13:53:28 <steakknife> shachaf: ah, the haskell group.  I've been hoping for another haskell convention.
13:53:34 <rferranti> how can japanese noodles be so hot 30minutes after being cooked
13:53:43 <copumpkin> DanBurton: a lot of haskellers enjoy go, for some reason
13:53:48 <copumpkin> the game
13:53:50 <copumpkin> not the language
13:54:08 <sully> that makes more snese.
13:54:14 <rferranti> copumpkin, tell us the truth, you wrote "the game" for another reason
13:54:16 <DanBurton> copumpkin: go, the game? what's that?
13:54:17 <hpc> copumpkin: because both make no sense to outsiders
13:54:20 * applicative_ likes Haskell, the game, not the language
13:54:22 <steakknife> BayHac
13:54:26 <shachaf> steakknife: BayHac is probably going to be in... ~February?
13:54:37 <DanBurton> @where go
13:54:38 <copumpkin> DanBurton: http://en.wikipedia.org/wiki/Go_(game)
13:54:38 <lambdabot> I know nothing about go.
13:55:17 <erus`> how do i get the euler angle of an x,y vector?
13:55:19 <mdxbhmt> @djinn
13:55:19 <lambdabot> Cannot parse command
13:55:35 <hpc> erus`: learn you a trig for justice!
13:55:42 <Happy0> is there some different way of pattern matchin an empty list in a case statement? i'm getting errors for this:
13:55:42 <Happy0> 	   case newenv of
13:55:43 <Happy0> 	     (x:xs)->  return xs
13:55:43 <Happy0> 		  [] -> return []
13:55:45 <erus`> i managed to do it the otherway round :)
13:56:00 <Cale> Happy0: Your indentation seems off
13:56:00 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
13:56:11 <hpc> Happy0: stop using tabs
13:56:21 <Cale> preflex: thanks for delivering that message a day late, btw
13:56:30 <copumpkin> lol
13:56:33 <mdxbhmt> copumpkin: i was impressed to hear sulivan saying go and haskell have something in common, i started playing go before haskell
13:56:58 <Happy0> hpc, Cale: thanks, but i've tried variations of indentation to make sure that wasn't the case
13:57:03 <Happy0> but i guess it must be indentation
13:57:13 <Happy0> if there's not adifferent way of pattern matching lists in case statements =p
13:57:16 <Cale> Happy0: The ( in (x:xs) should line up with the [ in []
13:57:19 <hpc> case newenv of
13:57:26 <hpc>   (x:xs) -> ...
13:57:29 <hpc>   [] -> ...
13:57:33 <Happy0> thanks :D
13:57:37 <Cale> Happy0: make 100% sure that your editor is configured to replace tab characters with spaces
13:57:51 <steakknife> Found the go clubs, thx.
13:57:57 <Happy0> Cale: yeah, i'm beginning to dislike notepad++ :P
13:58:02 <Cale> Happy0: Because tab characters will not only make you sad, but if you insist on using them, other people will hate you for it
13:58:09 <Cale> I'm pretty sure that Notepad++ has an option
13:58:11 <Happy0> at first i didn't have a monospacing font
13:58:17 <steakknife> bayareago.org
13:58:24 <shachaf> @karma notepad
13:58:24 <Happy0> and now that i do, it doesn't look as though [ is under ( even though it is
13:58:24 <lambdabot> notepad has a karma of 82
13:58:37 <hpc> haha
13:58:44 <Happy0> hahaha
13:58:51 <Cale> lol
13:59:01 <shachaf> steakknife: Ah, there are so many that there's a website dedicated to listing them. :-)
13:59:15 <hpc> (notepad isn't half-bad if you don't use unicode or linux newlines)
13:59:34 <Happy0> ha... well i was using gedit earlier... so err... ;x
13:59:38 <Happy0> at the computer lab
13:59:49 <shachaf> steakknife: Do you go to bahaskell?
13:59:51 <applicative_> @djinn (a -> b ) -> (c -> a) -> (c -> b)
13:59:52 <lambdabot> f a b c = a (b c)
13:59:58 <Happy0> yeah, it's still moaning at me about []... i'll try switching editor
14:00:05 <steakknife> shachaf: thinking about it.
14:00:07 <Happy0> (i know they're lined up fine)
14:01:18 <steakknife> shachaf: EY's kind of a drive / caltrain ride, but i've clients up there is probably should visit.
14:01:25 <DanBurton> copumpkin: coding challenge: write go (the game) in Haskell
14:01:39 <steakknife> s/ is / I /
14:01:53 <Happy0> hpc, Cale: thanks a lot guys, it was a tabbing issue. managed to fix it :)
14:02:17 <Eduard_Munteanu> DanBurton: the AI might be the actual challenge, if that's the plan.
14:02:31 <hpc> Eduard_Munteanu: "might"?
14:02:32 <mdxbhmt> Eduard_Munteanu:  that's a guarantee ;p
14:02:42 <Eduard_Munteanu> Sure :)
14:02:43 <rotflcopter> can we say ASM and GHC are exact opposites?
14:02:52 <rotflcopter> ASM - small size - very close to hardware
14:02:52 <rotflcopter> GHC - HUGE, and LARGE code overhead - purely functional
14:03:24 <shachaf> Can we say that alligators and quaternions are exact opposites?
14:03:44 <Eduard_Munteanu> There are asm instructions with a functional flavor.
14:03:46 <Eduard_Munteanu> Heh.
14:03:48 <shachaf> steakknife: Well, it's right by the Caltrain station. :-)
14:03:54 <hpc> shachaf: one eats mathematicians alive and the other is found in australia?
14:04:21 <hpc> rotflcopter: see: the reduceron (iirc)
14:04:47 <rotflcopter> :)
14:04:48 <shachaf> steakknife: Where in the Bay area are you coming from?
14:05:02 <shachaf> steakknife: There's also Bay Area Categories and Types, which is in Mountain View, I think.
14:06:24 <statusfailed> Hmm, what does deriving(Data) do?
14:06:39 <shachaf> steakknife: Derives Data.
14:06:40 <DanBurton> @google haskell deriving data
14:06:42 <shachaf> It's a type class.
14:06:42 <lambdabot> http://hackage.haskell.org/package/derive
14:06:42 <lambdabot> Title: HackageDB: derive-2.5.4
14:06:51 <statusfailed> shachaf: statusfailed evaded your attack~
14:06:53 * applicative_ thinks ghc is not large enough.
14:07:19 <mdxbhmt> what's the size of c#, for comparision?
14:07:24 <steakknife> shachaf: Mt. View. / Sunnyvale
14:07:34 * shachaf /\~$/ ?
14:07:38 <Cale> statusfailed: Data is a typeclass which allows for generic traversals over lots of different data structures.
14:07:54 <shachaf> steakknife: Ah.
14:08:01 <shachaf> We usually take Caltrain from there. :-)
14:08:10 <statusfailed> Cale: nice one! thanks
14:08:15 <statusfailed> now that's an elevator pitch :D
14:08:50 <Cale> statusfailed: along with a library of standard sorts of generic traversals you may want to do. It's not the prettiest design in existence, but it has the advantage that code to generate instances is built in to GHC, making it pretty easy to use.
14:09:11 <statusfailed> Oh it was just in some example happstack code, wasn't sure what it was for
14:09:25 <statusfailed> good to know tho
14:09:48 * applicative_ thinks, if ghc were so huge it could only fit on some monster supercomputer, we would just have to beg the authorities to use it.  as it is it fits on a stupid netbook just fine
14:10:33 <steakknife> shachaf:  As it is near Caltrain, I'll look that and the other locally.
14:10:48 <monochrom> if you brought ghc into the past through a time machine, but forgot to bring your netbook, you would have to beg the authorities to run it.
14:11:19 <monochrom> which is why I don't want to go back to the past.
14:11:29 <statusfailed> whaaaat
14:11:31 <applicative_> monochrom, yes, but if it only ran on a supercomputer today, i'd just have to wait a few years.
14:12:10 <statusfailed> if you brought your netbook you could make so much money just renting it as a supercomputer
14:12:14 <shachaf> Most computers are supercomputers nowadays.
14:12:31 <monochrom> MLton barely escaped needing a supercomputer when it came out.
14:12:53 <applicative_> they understood what a decent language is worth
14:13:15 <monochrom> oh, but hugs is pretty small and non-demanding
14:14:17 <hpaste> ClaudiusMaximus annotated “DM” with “DM (Repa for Tekmo)” at http://hpaste.org/53459#a53460
14:23:41 <Quantumplation> func h:rest = blah;  Does h:rest match against h:[]?
14:23:54 <byorgey> Quantumplation: yes
14:24:03 <byorgey> Quantumplation: but you need parenthese around h:rest
14:25:23 <rotflcopter> i think im back to ASM programming
14:25:28 <silver_> @type (!!)
14:25:29 <lambdabot> forall a. [a] -> Int -> a
14:25:31 <rotflcopter> and learning Haskell
14:25:44 <silver_> @hoogle [a] -> Integer
14:25:44 <lambdabot> Prelude head :: [a] -> a
14:25:45 <lambdabot> Prelude last :: [a] -> a
14:25:45 <lambdabot> Data.List head :: [a] -> a
14:25:51 <silver_> @hoogle [a] -> Integer -> a
14:25:51 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
14:25:52 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:25:52 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
14:26:16 <applicative_> > > let func [] = 0 ; func (x:xs) = x in func [1..4]
14:26:17 <lambdabot>   <no location info>: parse error on input `>'
14:26:21 <applicative_> > let func [] = 0 ; func (x:xs) = x in func [1..4]
14:26:22 <lambdabot>   1
14:27:44 <SegFaultAX|work> Holy crap, you can search by signature?
14:27:57 <_Mikey> seems so
14:28:03 <SegFaultAX|work> Mind = blown.
14:28:08 <_Mikey> ^^
14:28:46 <SegFaultAX|work> < Just starting on my Haskell journey. (In fact just started building GHC today)
14:28:55 <shachaf> SegFaultAX|work: Why are you building GHC?
14:28:55 <_Mikey> Awesome
14:28:56 <applicative_> @hoogle a -> [a] -> Bool
14:28:56 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
14:28:56 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
14:28:57 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
14:29:08 <Cale> SegFaultAX|work: It's a little weird to build GHC if you're not hacking on it.
14:29:09 <shachaf> You already have a perfectly functional GHC.
14:29:12 <SegFaultAX|work> shachaf: Because I'm a snob. :D I like to run edge versions.
14:29:18 <SegFaultAX|work> Cale: ^
14:29:29 <_Mikey> Seg you rock.. tbh
14:29:36 <shachaf> "edge" as in 7.3.x?
14:29:44 * applicative_ just wanted PolyKinds
14:30:01 <_Mikey> I'm just starting out in Haskell too, been at it for about two weeks.
14:30:15 <SegFaultAX|work> shachaf: Well, stable edge. 7.2.x seems to be a pre-release of some sort based on what Cale et al were telling me earlier.
14:30:22 <_Mikey> using it as the main language in my degree's Final year project
14:30:31 <SegFaultAX|work> shachaf: I'll probably jump back down to 7.0.4, though.
14:30:37 <applicative_> _Mikey good work
14:30:44 <shachaf> > comparе "SegFaultAX|work" "_Mikey"
14:30:46 <lambdabot>   EQ
14:30:58 <applicative_> _Mikey: what are you going to do with it>
14:30:58 <_Mikey> ty, hoping it goes well :)
14:31:11 <_Mikey> simulating an ant colony. ^^
14:31:27 <SegFaultAX|work> shachaf: Was that a very subtle Haskell jab that I'll need to study to understand?
14:31:46 <_Mikey> hopefully I'll be able to expose parallelism left right and center.
14:31:50 <_Mikey> we'll see though.
14:31:55 <DanBurton> Suppose I'm nearly finished with my undergraduate degree. Is there anywhere I can go in order to get a graduate degree by hacking on GHC?
14:32:21 <_Mikey> Oh, I'm sure there's somewhere
14:32:23 <byorgey> DanBurton: Cambridge.
14:32:30 <_Mikey> I'm looking to do post grad stuff.
14:32:33 <byorgey> DanBurton: UPenn.
14:32:37 <applicative_> SegFaultAX|work: the real mystery is the definition of 'compare'
14:32:38 <shachaf> SegFaultAX|work: Not really.
14:32:54 <applicative_> >  comparе 0 1
14:32:55 <lambdabot>   EQ
14:32:59 <byorgey> DanBurton: those are the only places I know of.
14:33:03 <applicative_> > compare 0 1
14:33:04 <lambdabot>   LT
14:33:07 <ion> > compare "comparе" "compare"
14:33:08 <lambdabot>   GT
14:33:11 <SegFaultAX|work> applicative_: I'm looking at it right now.
14:33:31 <SegFaultAX|work> applicative_: I'm not sure I understand how it applies to string types yet though.
14:33:37 <applicative_> >  comparе  ( comparе 0 1) (compare 0 1)
14:33:39 <lambdabot>   EQ
14:33:41 <DanBurton> byorgey: guess I'll look into those, thanks :)
14:33:45 <applicative_> >  compare  ( comparе 0 1) (compare 0 1)
14:33:47 <lambdabot>   GT
14:33:52 <shachaf> SegFaultAX|work: Just ignore the "compare" thing.
14:33:58 <ion> > comparе 42 putStrLn
14:34:00 <lambdabot>   EQ
14:34:13 <applicative_> ion+++
14:34:55 <ion> I like how UTF-8-aware people’s IRC clients are nowadays.
14:34:56 <Cale> ion: lol
14:35:14 <applicative_> has anyone else notice what the result of type hackery is, in the long run?   comparе 42 putStrLn  ...
14:35:32 <Cale> I'm not sure why compare is implemented like that on IO
14:35:38 <applicative_> they can't do stuff that in php what with all that mad typing they impose
14:35:54 <c_wraith> Cale: is it implemented in IO, or just on functions?
14:35:59 <shachaf> Implemented like what?
14:36:02 <monochrom> the long term result of type hackery is dependent types
14:36:07 * applicative_ notes that Cale is taking 42's status as IO () in stride
14:36:15 * shachaf @let comparе _ _ = EQ
14:36:23 <ion> (Actually String → IO ())
14:36:34 <applicative_> indeed
14:37:10 <Quantumplation> what does (!!) return if the index is outside the bounds of the list?
14:37:23 <copumpkin> error
14:37:23 <applicative_> > [1] !! 2
14:37:24 <lambdabot>   *Exception: Prelude.(!!): index too large
14:37:34 <shachaf> Quantumplation: (!!) is evil and avoid it.
14:37:49 <Quantumplation> schachaf: Is there an equivalent [a] -> Int -> Maybe a?
14:37:50 <SegFaultAX|work> shachaf: Sorry, I got distracted. Continue.
14:38:02 <copumpkin> spoon .: (!!)
14:38:03 <shachaf> Also, it would have been simple enough for you to figure out the answer to that question yourself. :-)
14:38:06 <applicative_> Quantumplation: soon you will have a type safe !! with -XPolyKinds
14:38:16 <shachaf> Quantumplation: Not in the standard library, as far as I know.
14:38:19 <copumpkin> applicative_: we will?
14:38:25 <Eduard_Munteanu> @hoogle safeIndex
14:38:25 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
14:38:27 <shachaf> But the platonic function safeIndex certainly exists.
14:38:30 <applicative_> Quantumplation: of course it will take all afternoon to type the index
14:38:37 <Eduard_Munteanu> Bah.
14:38:38 <copumpkin> oh, that thing
14:38:51 <shachaf> SegFaultAX|work: With what?
14:39:31 <mbtez_> what's the best web framework in Haskell?
14:39:37 <mbtez_> generally
14:39:40 <mbtez_> in your opinions
14:39:49 <shachaf> Why do people ask these questions?
14:39:52 <applicative_> they're all good. all of them.
14:40:10 <mbtez_> well i am starting a new project
14:40:10 <shachaf> The best web framework in Haskell is (system "rails").
14:40:17 <mbtez_> shachaf: hm
14:40:23 <applicative_> shachaf--
14:40:27 <shachaf> :-(
14:40:33 <applicative_> shachaf++
14:40:50 <monochrom> all the haskell web programmers are too busy for irc.
14:40:53 <mbtez_> haha
14:41:11 <shachaf> If one of them was the best, why would the other ones exist?
14:41:23 <monochrom> because they are all free
14:41:25 <mbtez_> i'm gonna try snap
14:41:32 <applicative_> mbtez_ I think the leading ones have their own irc channels, #yesod #snapframework etc
14:41:33 <blackdog> mbtez_: it really depends what you're trying to do
14:41:35 <mbtez_> because they are use specific
14:41:38 <mbtez_> usually
14:41:47 <blackdog> yesod tends to be your all-dancing, all-singing solution
14:42:06 <blackdog> snap is more targeted, and more mainline haskell
14:42:14 <Cale> ion: Oh, right, of course
14:42:16 <blackdog> (in the sense that yesod tends to use a lot of template haskell)
14:42:29 <monochrom> in fact, they might still exist even if they were not free. look at windows. why does it exist and has a price tag? despite macos x.
14:43:20 <Cale> ion: But still, the instance of Ord there is kinda silly. Returning EQ all the time is worse than just error "Not implemented" here, I think.
14:43:22 <shachaf> monochrom: Because it's better.
14:43:23 <MostAwesomeDude> Because of the unlearning problem?
14:43:37 <shachaf> Cale: It was a joke "compare" function that's defined as const (const EQ)
14:44:12 <monochrom> in the end it's easiest to just avoid explaining existence.
14:44:29 <applicative_> Cale, the final 'e' in "compare" was from some remote section of the unicode empire
14:45:17 <shachaf> Cyrillic isn't all that remote...
14:46:48 <applicative_> > text "\1077"
14:46:49 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:46:56 <applicative_> grrr
14:48:41 <Cale> applicative_: oic
14:54:30 <SegFaultAX|work> This is the best book chapter title => "Writer? I hardly know her!"
14:54:37 <gwern> can anyone create http://www.haskell.org/haskellwiki/index.php?title=Fast_cash_advance_online&action=edit ?
14:55:20 <monochrom> Fast cash advance online? :)
14:55:39 <ben> I assume it's something like a Fast fourier transform
14:55:48 <Cale> http://www.haskell.org/haskellwiki/Fast_cash_advance_online
14:55:55 <Cale> MAED
14:55:56 <gwern> dammit!
14:56:30 <gwern> Cale: ok try again
14:57:05 <monochrom> I suppose it is an anti-spam measure.
14:57:21 <Cale>     This page has been locked to prevent editing.
14:57:21 <Cale>     This title has been protected from creation by Gwern. The reason given is does the 'create' dialogue matter?.
14:57:26 <gwern> excellent
14:57:32 <monochrom> neato
14:57:49 <gwern> monochrom: as far as I can tell a lot of the spammers seem to be bots working off hardwired page names, so hopefully salting pages will frustrate them
14:58:50 <c_wraith> blah.  ConstraintKinds doesn't solve my problem, either...
15:04:54 <gtirloni> if anyone from Brazil or Portugal wants to participate, there is a Haskell class about to start on stoodos.com
15:10:21 <ben> I wanna step through a json file that's maybe a dozen MB, and since it's mostly a list of relatively small values I feel silly loading it all into memory at once and then inspecting the tree. Is there some streaming parser kind of thing on hackage?
15:11:06 <Clint> ben: aeson?
15:11:13 <ben> Oh, it does that? Cool. Thanks.
15:12:19 <_Mikey> nice shout Clint
15:24:56 <ben> @pl \_ _ x -> x
15:24:56 <lambdabot> const (const id)
15:25:11 <shachaf> Hey, it's c0rn.
15:25:24 <shachaf> copumpkin: Presumably you're related?
15:25:33 <copumpkin> :o
15:28:56 <c0rn> shachaf: hi
15:30:50 <Baughn> Is there by chance documentation on the Green Card directives anywhere? Things such as how I deal with structures?
15:40:26 <_Mikey> so tired.
15:40:38 <_Mikey> need to caffine up -.-
15:43:45 <neillb> Hi, Is there a way to make all instances of one typeclass A an instance of another, B (without making A a subclass of B)?  I've set my problem out here: https://gist.github.com/1335141
15:45:01 <edwardk> neillb: no
15:45:27 <edwardk> neillb: the usual idiom is to make a newtype wrapper like newtype WrappedFoo a = WrappedFoo { unwrapFoo :: a }
15:45:49 <edwardk> and make the instance you'd want sit on that and dispatch it through the newtype wrapper
15:46:22 <edwardk> otherwise you are saying that the only instances of A are B, which isn't what you meant
15:46:31 <edwardk> er instances of A are instances of B
15:47:11 <dylex> neillb: with what you're doing, with UndecidableInstances, you could say instance (Enum a, Bounded a) => Generator a where ...
15:47:23 <neillb> edwardk: Thank you.
15:47:52 <dylex> neillb: But, then it is difficult to usefully specify any other instances, so the class isn't actually doing much for you.
15:49:02 <neillb> dylex: thanks.
15:49:13 <edwardk> dylex: just don't do that
15:50:28 <edwardk> the overlapping instance there are almost never doing what someone actually wants. it typechecks, then maybe it works. and if "Generator" and that instance are not defined in the same module with EVERY specialization that is more specific then you won't dispatch properly
15:51:24 <dylex> right. In that case, the gen2 function alone makes more sense to achive the same thing.
15:51:52 <dylex> neillb: Nothing prevents you from defining Enum and Bounded instances for Item, however, which accomplishes the same thing.
15:54:34 <embwbam> I'm trying to get Data.BSON to serialize to Text.JSON, and I don't really know what I'm doing. I know how to make a data type an instance of JSON per this article http://therning.org/magnus/archives/719
15:55:04 <embwbam> Here's the mongodb package (contains Data.BSON) http://hackage.haskell.org/package/mongoDB
15:55:22 <embwbam> My first try was this: "instance JSON [Field] where ..."
15:55:52 <embwbam> but I get the error https://gist.github.com/1335224
15:56:16 <embwbam> Not that I'll be able to write that instance function at all, but any ideas what I'm doing wrong? Is there a simpler way to do this?
15:59:59 <mm_freak> the haskell amuse-bouche talk is the first youtube result when searching for "coding talk"
16:00:00 <neillb> embwbam: perhaps instance JSON Field where  (I'm a newb though)
16:02:46 <zzo38> Would it even be possible to make Haskell have a bijective function type <-> that you could, in addition to possibly conversion of some reversible esolangs, also be able to prove things such as:   forall a b c n. Not (Either (Maybe (Maybe (Maybe n)) -> Maybe a) (Maybe (Maybe (Maybe n)) -> Maybe b) <-> (Maybe (Maybe (Maybe n)) -> Maybe c))
16:03:13 <hpc> mm_freak: because you're logged in or something, so it specializes the search
16:03:16 <embwbam> neillb: thanks. I'm trying this: putStrLn $ encode $ toJSON ["hello" =: "world"] and now it's asking for an instance for (Data Field)
16:03:42 <embwbam> so instance JSON Field is really close
16:04:37 <zzo38> I tried to request an account but the system administrator but have accidentally broke something even though it worked yesterday. Yesterday it was BSD mail now it is GNU mail and it doesn't work. He just put BSD mail on, yesterday, though!
16:05:02 <hpaste> chrisdone pasted “Mute/unmute volume with Kinect” at http://hpaste.org/53461
16:05:07 <zzo38> It was also GNU mail before yesterday and it didn't work.
16:05:33 <neillb> embwbam: put your code on hpaste / gist, and I can take a look.
16:06:08 <mdxbhmt> hey, anyone here knows about propagators?
16:06:22 <chrisdone> kmc: http://chrisdone.com/kinect-volume.ogv
16:06:34 <chrisdone> copumpkin: ^
16:06:35 <chrisdone> :D
16:07:26 <chrisdone> that's me demonstrating muting/unmuting my volume with my kinect. also demonstrating that mere waving and accidental signals are trivially ignored
16:07:32 <ben> What is the problem called that I can't really use liftIO $ withFile ... if the inner lambda would return a non-IO monadic value?
16:07:51 <hpc> ben: a type error?
16:08:03 <copumpkin> chrisdone: neat!
16:08:05 <ben> Pft
16:08:19 <ben> I'm sure I had read something about this sort of thing :V
16:08:29 <hpc> :t withFile
16:08:30 <lambdabot> Not in scope: `withFile'
16:08:35 <hpc> @hoogle withFile
16:08:36 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
16:08:57 <chrisdone> copumpkin: makes me feel like magneto
16:09:26 <embwbam> neillb: https://gist.github.com/1335261 - Trying to convert Bson to JSON. Error is in the text
16:09:28 <hpc> ben: i doubt there exists a special term for it; it's just "the types don't match"
16:09:40 <ben> I'm ultimately trying to use http-enumerator giving it an iteratee that's built with Data.Enumerator.Binary.iterHandle and a file handle that's closed when http is done
16:09:43 * roconnor solves a problem by writing a function that returns an IO of another function.
16:10:03 * roconnor <3 types
16:10:06 <ben> but I'm not sure where I'd put the withFile. If I put it around the entire http call, I can't conditionally only open the file if the http request returns 200.
16:10:44 <hpc> you realize you can actually just manipulate the handle yourself
16:11:06 <ben> Yeah, but I do not feel really comfortable with that
16:11:17 <timp> In a 'data' definition what are the curly brackets for, are they optional? eg  HtmlTag {                   -- tag with internal markup
16:11:18 <timp>               markupTag      :: String,
16:11:18 <timp>               markupAttrs    :: [HtmlAttr],
16:11:18 <timp>               markupContent  :: Html
16:11:18 <timp>               }
16:11:22 <ben> What if someone throws an exception at the wrong moment?
16:11:54 <shachaf> timp: They're used for record syntax.
16:12:09 <timp> thanks, sorry for paste blurt
16:12:11 <shachaf> (Also, if you have more than a few lines, please @paste them instead of pasting into the channel.)
16:12:24 <shachaf> @google haskell record syntax
16:12:25 <lambdabot> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
16:12:25 <lambdabot> Title: Learn You a Haskell for Great Good! - Making Our Own Types and Typeclasses
16:13:02 <Philonous> ben:  Are you perchance referring to this blog post? http://www.yesodweb.com/blog/2011/08/monad-control
16:13:24 <ben> Seems likely, thanks for the link
16:14:59 <erus`> haskell gets nasty once you get into the ErrorT stuff :(
16:15:38 <hpc> ErrorT can be nice if you let "fail" do its job
16:15:56 <hpc> (i think; i forget if it defines a sane "fail")
16:17:18 <roconnor> people tell me not to use fail and use throwError instead
16:18:31 <Peaker> hpc: isn't a sane "fail" an oxymoron?
16:18:51 <hpc> Peaker: obviously excepting that it's not in MonadFail :P
16:19:20 <mm_freak> hpc: i'm not registered
16:19:32 <erus`> > Just Nothing
16:19:33 <lambdabot>   Just Nothing
16:19:34 <mm_freak> my cookies get cleaned up after closing the browser, which i do fairly often
16:19:37 <shapr> preflex: seen bestaugh
16:19:37 <preflex>  Sorry, I haven't seen bestaugh
16:19:39 <shapr> um
16:19:42 <shapr> preflex: seen beastaugh
16:19:42 <preflex>  beastaugh was last seen on #haskell-blah 91 days, 47 minutes and 33 seconds ago, saying: pretty horrible today, especially on the tube
16:19:45 <shapr> aha
16:19:47 <hpc> mm_freak: oh, that's nifty then
16:20:54 <gwern> > 0.5 * 0.5 * 0.1
16:20:55 <lambdabot>   2.5e-2
16:21:06 <gwern> > (0.5 * 0.5 * 0.1) * 100
16:21:07 <lambdabot>   2.5
16:25:56 <roconnor> gwern: Hi gwern.  I just want to mention that in a book I read that the aging process (defined as increase in probability of death in the next year) stops at around 90ish, so you don't need to worry about that hyper-exponetial growth in probability of death.
16:26:32 <gwern> roconnor: yeah, that seems plausible based on what I've since read. on the other hand, I also read that old age longevity has been improving very slowly, which is not good
16:27:44 <roconnor> gwern: heh.  Well my faith is in quantum immortality :)
16:28:21 <hpc> roconnor: that's a pretty bad bet from where i'm standing ;)
16:28:24 * gwern looks through http://lesswrong.com/user/gwern/submitted/ for the stats on old age
16:28:31 <gwern> hpc: sure, you *would* say that
16:28:41 <roconnor> *l*
16:28:45 <gwern> roconnor: http://lesswrong.com/lw/7jh/living_forever_is_hard_part_2_adult_longevity/
16:28:50 <roconnor> gotta go
16:28:52 <roconnor> BBL
16:29:16 <gwern> roconnor: 'As a result, life extension from age 65 was increased only 6 years over the entire 20th century; from age 75 gains were only 4.2 years, from age 85 only 2.3 years and from age 100 a single year. From age 65 over the most recent 20 years, the gain has been about a year [16].'
16:32:09 <eyu100> is there a non-annoying way to convert ints to floats?  I don't want to turn a simple expression like (a*b*c)/d into ((fromIntegral a) * (fromIntegral b) * (fromIntegral c)) / (fromIntegral d)
16:33:12 <c_wraith> that only needs two fromIntegrals
16:33:22 <c_wraith> assuming the multiplication doesn't overflow
16:35:18 <monochrom> give a shorter name to fromIntegral
16:36:33 <Cale> eyu100: If you're using Integer, it's reasonable to multiply before applying fromIntegral as well.
16:37:05 <shapr> But remember that fromIntegral has limitations
16:37:07 <Cale> (but with Int, you need to worry about how overflow will affect the result)
16:39:19 <Baughn> Instead of individual functions, can I foreign export a static C struct with function pointers?
16:39:44 <monochrom> no
16:40:45 <Baughn> monochrom: Not even a little bit?
16:41:39 <ion> > let (.*) = r (*); (./) = r (/); r f a b = f (realToFrac a) (realToFrac b) in ((5 :: Integer) .* (6 :: Integer) .* (7 :: Integer)) ./ (8 :: Integer)
16:41:40 <lambdabot>   26.25
16:42:42 <monochrom> maybe a runtime C struct
16:42:47 <powerc> Hola
16:43:00 <Baughn> monochrom: It needs to be linkable
16:43:12 <monochrom> then no again
16:43:33 <iago> Hi, I would appreciate any suggestion for the following situation (using concurrency and STM): for each client that I attend I have two threads, one reading 'actions'  from the client handle, and other that reads 'events' from a TChan and then writes them to the client handle... when the first thread receives an action 'PART' it must terminate the client session, so in some way I have to stop the thread that reads events from a TChan.. but I don
16:43:33 <iago> 't know how do this correctly. If I use killThread I could kill the thread while writing to the handle... but I don't know any other solution, because there is no way to perform a non-blocking read in a TChan/Chan
16:44:38 <c_wraith> iago: sure there is.  use orElse
16:44:41 <ion> (What i pasted doesn’t actually work as intended without adding type signatures all around the place.)
16:44:43 <monochrom> you can deduce from Haskell 2010 Chapter 8 that in "foreign export blah :: type" the "type" there is very limited, essentially no user-defined type (save for limited newtypes)
16:45:10 <ion> > let (.*) = r (*); (./) = r (/); r f a b = f (realToFrac a) (realToFrac b) in (0.3 .* 0.3) ./ 8 :: Rational
16:45:11 <lambdabot>   3242591731706757 % 288230376151711744
16:45:22 <c_wraith> iago: no STM reads *actually* block.  They retry instead, and the retry combinator may block.  But if there's an orElse to follow, they go with that instead
16:46:44 <c_wraith> iago: so just have them read from the TChan orElse read from a TMVar.  If they read from the TMVar successfully, shut down gracefully.  Kill by writing to that TMVar
16:46:50 <iago> c_wraith, thanks a lot for the hint, I suppose I can use a TMVar to indicate the thread when it should stop
16:47:19 <iago> read_events_in_tchan `orElse` check_mvar_indicating_I_have_to_stop
16:47:38 <monochrom> non-blocking polling is usually an XY problem
16:48:16 <iago> yep, c_wraith thanks again
16:48:34 <c_wraith> another approach is putting Either values into the Chan-like thing.  Left values mean "shut down", Right values are data
16:48:40 <c_wraith> That's probably cleaner
16:53:16 <monochrom> > 0.3 * 0.3 / 0.8 :: Rational
16:53:16 <lambdabot>   9 % 80
16:57:46 * hackagebot vty 4.7.0.6 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.6 (CoreyOConnor)
17:07:29 <ddarius> There's -always- a way to do a non-blocking version of a blocking operation.  Synchronous events are more powerful than asynchronous ones in a certain sense.
17:08:02 <shachaf> ddarius: In what sense?
17:08:23 <Baughn> In a language without threading, converting between the two isn't all that easy..
17:08:27 <BobMcTarded> what's another way to make random numbers besides System.Random?
17:08:55 <Baughn> BobMcTarded: Any of the various random number libraries on Hackage
17:09:05 <Baughn> Mersenne twister is nice, AES has a cryptographic PRNG, etc.
17:09:18 <ddarius> Baughn: Bah, I was going to add "given concurrency" or "in a concurrent context."  I should know that this place is rife with pedants.
17:10:19 <ddarius> shachaf: Building a synchronous communication given asynchronous ones requires cooperation between the processes.
17:12:03 <Baughn> ddarius: And lacking concurrency you can build concurrency and blocking calls using the continuation-passing transform, but not the other way around. :P
17:12:11 <Baughn> Not that most people would do so, given any choice
17:12:38 <ddarius> Baughn: You can't build pre-emptive concurrency that way.
17:13:11 <ddarius> In a multithreaded context, it would make no sense to not have -any- blocking calls.
17:13:32 <ddarius> It would be like having an event-based system with no way to register for events.
17:13:43 <Baughn> ddarius: Preemptive concurrency, no.
17:15:10 <ddarius> Also I think you meant non-blocking calls.
17:15:19 <ddarius> Nevermind I misreread.
17:16:06 <ddarius> Given concurrency and blocking calls, it's trivial to make non-blocking calls.
17:17:05 <Baughn> Yes. Fat lot of good that does me in javascript. :P
17:17:12 <HugoDaniel> :)
17:17:14 <ddarius> Javascript doesn't have concurrency.
17:17:19 <Younder> why is the comp.lang.haskell newsgroup so lo traffic?
17:17:21 <shachaf> And it's not trivial the other way around?
17:17:23 <Baughn> ddarius: I noticed.
17:17:23 <c_wraith> javascript doesn't have sanity
17:17:26 <ddarius> shachaf: No, it isn't.
17:17:46 * hackagebot smallarray 0.2.2.3 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.2.3 (AntoineLatter)
17:17:47 <HugoDaniel> JavaScript doesn't have funk!
17:17:58 <ddarius> It's doable, but the CPS transform is a global transformation.
17:18:08 <gentleben> but it has Node, feel the power of the Node
17:18:19 <BobMcTarded> there should be less javascripts and more haskells given this current point of time in technology
17:18:30 <c_wraith> Node is funny.  Because it's greatest selling point is just something GHC does behind the scenes. :)
17:18:34 <c_wraith> err, *its
17:18:35 <ddarius> I hate node.js's concept.
17:18:46 <ddarius> c_wraith: Indeed.
17:19:04 <ddarius> c_wraith: It's like advertising that you got rid of all that troublesome automatic memory management.
17:19:04 <gentleben> Node.js has a great concept. It allows the masses to write web services
17:19:06 <mauke> Cale: preflex only delivers messages when you use the 'messages' command
17:19:15 <shachaf> I suppose it depends on what primitives you have for concurrency.
17:19:18 <HugoDaniel> Node < (insert your favorite mambo-jambo here) < Funk
17:19:37 <ddarius> gentleben: Not more than anything else.  Less so than most.
17:19:38 <shachaf> ddarius: What's node.js's concept? "write everything in one thread and using explicit CPS"?
17:20:23 <gentleben> ddarius: Actually I think it does. It takes people who say did python + js and gives them a parallel framework
17:20:40 <gentleben> is it superior tech, no not at all
17:20:48 <ddarius> shachaf: It outlaws all blocking calls.  I.e. everything is event-based, everything that would block takes a call-back.
17:21:10 <shachaf> Right.
17:21:10 <gentleben> but if you take a python service, node makes it easy to scale in js
17:21:18 <ddarius> gentleben: It gives them an event-based framework.  Last I checked, python, at least, already had that.
17:21:36 <gentleben> node can easily use all the cores
17:21:45 <ddarius> gentleben: If your load is compute-intensive, node.js won't scale.
17:21:45 <Nafai> ddarius: Yes, indeed.  A quite mature framework.
17:21:45 <lambdabot> Nafai: You have 1 new message. '/msg lambdabot @messages' to read it.
17:21:50 <gentleben> python is more of a trick
17:21:50 <Cale> mauke: Did I somehow accidentally use the command there?
17:21:51 <luite_> scale a python service in js? wtf I'm really can't keep up with all those webscale techs anymore :p
17:22:12 <shachaf> ddarius: There exist extensions that give you coöperative threads of sort, though.
17:22:18 <gentleben> luite_: obviously you need to port
17:22:21 <shachaf> (Or so I understand.)
17:22:23 <ddarius> luite_: Don't worry.  The less you know about current web "technology" the more qualified you are.
17:22:46 * hackagebot smallstring 0.3.2 - A Unicode text type, optimized for low memory overhead  http://hackage.haskell.org/package/smallstring-0.3.2 (AntoineLatter)
17:23:07 <mauke> Cale: no, preflex will automatically tell you if you have messages and it didn't notify you in the last 24 hours
17:23:07 <gentleben> however if i was building a non-tech company node might be ok from a cost standpoint, since js devs are cheap and plentiful
17:23:10 <Cale> It doesn't matter how much you know. What matters is how excited you are about it.
17:23:12 <Cale> ;)
17:23:15 <mauke> you need 'messages' to read/delete them
17:23:15 <Peaker> cooperative multitasking is much better than preemptive multitasking in a shared-mutable-state environment
17:23:24 <Cale> mauke: ah, okay
17:23:40 <luite_> Cale: but should you be more or less excited to be more qualified?
17:23:41 <Cale> mauke: So it does delay by 24 hours
17:23:52 <ddarius> gentleben: But not Java developers?  Also, people advertising themselves as javascript developers are probably not qualified to be making web servers.
17:23:58 <mauke> if you were referring to the message about a missing lambdabot from yesterday, it did tell you about that
17:24:05 <Peaker> people typically compare node.js to shared-mutable-state preemptive multitasking -- so it definitely wins there..   cooperative threads have advantages and disadvantages over explicit cps
17:24:15 <Cale> okay
17:24:46 <luite_> Peaker: why is it better?
17:24:55 <gentleben> ddarius: eh. its a cost thing. you can build your server and client code in the same language
17:25:33 <biyv> hey
17:25:35 <gentleben> fortunately i don't build web apps, so i don't have those probelems
17:25:38 <biyv> is anyone here?
17:25:41 <gentleben> nope
17:25:48 <biyv> are you GOD>
17:25:49 <biyv> ?
17:25:54 <gentleben> yup
17:26:03 <biyv> tell me how to get rich?
17:26:04 <ddarius> gentleben: There's no real benefit to doing that from a technical perspective in this case, and in practice, you will be using a plethora of languages in any serious coding endeavor.
17:26:14 <Peaker> luite_: because lots of shared mutable state + preemptive multitasking  gives you way too much non-determinism.  Instead of deterministic-by-default, inject-non-determinism when useful (carefully), you get non-deterministic-by-default, inject determinism via critical sections (and get cryptic bugs everywhere else)
17:26:29 <biyv> stop talking shit and get laid
17:26:51 --- mode: ChanServ set +o mauke
17:26:51 --- mode: mauke set +q *!*@gateway/web/freenode/ip.82.161.181.132
17:26:58 <gentleben> ddarius: Node as no technical advantage over any modern web development framework. it has the advantage that there are legions of javascript developers out there
17:26:59 <ddarius> Thanks mauke.
17:27:23 <rotflcopter> hah
17:27:25 <rotflcopter> http://www.youtube.com/watch?v=YX2jmV4g0vc&lc
17:27:27 <rotflcopter> gta5
17:27:41 --- mode: mauke set -o mauke
17:27:45 <hpc> gentleben: i thought it was legions of jquery developers, not javascript :P
17:27:53 <gentleben> hehe maybe
17:28:08 <ddarius> gentleben: Not legions of javascript developers with experience writing web servers in javascript or any language.  There are legions of Java developers with experience writing web servers.  But that wasn't my point.  I wasn't saying that node.js wasn't better than the alternatives, I was saying having your server written in the same language as your client code doesn't really confer a technical benefit.
17:28:13 <gentleben> and if you want to see the dangers of using js to build a service read this: http://blog.meloncard.com/post/12175941935/how-one-missing-var-ruined-our-launch
17:28:23 <Peaker> luite_: the pain of CPS is IMO negligible when compared with the pain of hard-to-reproduce cryptic mutable shared state bugs
17:28:28 <luite_> Peaker: even with cooperative multithreading, you typically have no control over which thread gets scheduled at each yield. and for scaling in smp, you probably want some concurrent "real" threads (like haskell capabilities).
17:28:49 <gentleben> ddarius: the web server itself is in c++ i believe. the apps are written in js
17:29:16 <Peaker> luite_: but there are many orders of magnitude less possible interleavings, and much less reasoning is required to see the validity of the code (e.g: re-entrant at yield points)
17:29:32 <gentleben> whether building apps in js is a good idea…i will leave that to everyone else
17:29:39 <Peaker> luite_: so you gain most of the determinism back and can more easily reason about the interleavings' correctness
17:30:07 <shachaf> ddarius: Is there no benefit at all to sharing code between client and server?
17:30:10 <ddarius> gentleben: Regardless, you're talking over a network cable in network protocols.  Your impedance mismatch is server language <-> network protocol.  The client language is irrelevant.
17:31:09 <gentleben> ddarius: what does the network have to do with anything? the underlying libraries handle that
17:31:47 <luite_> Peaker: hm I don't really buy it, you could get more or less the same result by wrapping all shared state code in large cricital sections and you'd still have the advantage of being able to use blocking stuff or long computations without yielding explicitly
17:32:41 <ddarius> gentleben: The network doesn't.  The network protocol does.  You have some on the wire format such as SOAP.  It will already be pretty language agnostic.  Even if you send Javascript data structures over the wire, you'll still have to serialize and deserialize them in some format.  You'll still need to write those (de)serializers regardless of whether the languages are the same.
17:32:43 <gentleben> IMHO javascript is intrinsically no better or worse than other untyped dynamic languages
17:33:00 <ddarius> gentleben: I never said anything about javascript itself.
17:33:19 <Peaker> luite_: using "large critical sections" is in effect implementing cooperative multitasking on top of preemptive multitasking
17:33:30 <ddarius> gentleben: I agree that there's no big reason not to use javascript compared to, say, python from a purely technical standpoint.
17:34:08 <ddarius> Peaker: Indeed.  The important benefit of cooperative concurrency is that it is much more coarse grained and you have better control over the granularity.
17:34:17 <Peaker> luite_: If you have various different locks, rather than 1, that's not true, but then you get into deadlock business
17:34:28 * djahandarie makes the inevitible passing remark that dynamically-typed languages are not untyped.
17:34:37 <gentleben> ddarius: serialization seems to be trivial issue. most people use json, some xml
17:34:49 <Peaker> djahandarie: Are Either's "Right" and "Left" types?
17:35:09 <gentleben> ddarius: personally i use a minor amount of json to power my yesod charts
17:35:11 <ddarius> gentleben: Indeed.  It's trivial regardless of the language.  That's my point.  I haven't gained anything at all by having my server side language be the same as the client side.
17:35:20 <Peaker> ddarius: Yeah, having very little shared mutable state ala Haskell is a much nicer solution
17:35:30 <luite_> Peaker: "implementing ... on top of" is the wrong way to approach it, it makes it sound like a big deal, but you use some primitives that are already there
17:36:00 <ddarius> djahandarie: Probably means dynamically typed languages are unityped.
17:36:07 <gentleben> ddarius: you personally haven't. neither have I. but many "regular" developers know 1 or 2 languages
17:36:08 <Peaker> luite_: Well, when you do that -- you lose out on important advantages of other ways to implement coop multitasking (e.g: much much cheaper threads)
17:36:26 <ddarius> gentleben: I'm talking about from a technical persective.
17:36:56 <luite_> Peaker: haskell's threads are (almost) preemptive and appear to be cheap enough
17:37:04 <gentleben> ddarius: there is no technical reason for it to exist and in time, like rails, it will be recognized as a blight to humanity
17:37:32 <ddarius> gentleben: Obviously there's potential benefit for reusing skills, though I'd be scared of having a web app developer who doesn't already know javascript, and I'd be scared of hiring someone who bills themselves as solely a javascript developer writing my web apps.
17:38:07 <gentleben> ddarius: you are probably smarter than most people making those decisions
17:38:32 <gentleben> however there are industries where quality/reliability does not matter
17:39:17 <kmc> oh we're bashing "normal developers" now?
17:39:27 <ddarius> gentleben: Maybe, but they are probably better at that.  Also they presumably would be looking for "web application developer" experience not "javascript experience."  Also, if they are using node.js, they are probably do not have some mindless HR department.  They probably don't have an HR department.
17:40:40 <gentleben> ddarius: actually a number of large companies such as google use it, scary right?
17:41:02 <ddarius> gentleben: I doubt Google has a mindless HR department.
17:41:15 <gentleben> what other kind is there?
17:41:16 <ddarius> In this context, to be clear, "mindless" = not technically savvy
17:41:36 <kmc> i hear repeated complaints about google HR and recruiting
17:41:39 <gentleben> actually when i talked to them i thought they were nuts
17:41:52 <djahandarie> Name something Google doesn't use. They even use n-categories.
17:41:54 <monochrom> how nuts?
17:41:58 <ddarius> Well, Google probably has multiple HR departments.
17:42:00 <kmc> but there is such thing as a good HR department
17:42:30 <monochrom> google probably doesn't use fountain pens
17:42:52 <kmc> it's a common fallacy among self-styled Hackers and Real Programmers that the non-technical parts of a company contribute nothing
17:43:03 <gentleben> monochrom: up until recently the team that you worked for didn't interview you. a committee did and if they gave you a hire they put you on a list and a team would pick you up
17:43:05 <monochrom> almost surely doesn't use vinyl records
17:43:18 <kmc> gentleben, oh, they changed that?
17:43:26 <Peaker> luite_: Haskell uses M:N threading, and given user threads can migrate to different real threads, they have all the non-determinism disadvantages of ordinary threads..
17:43:29 <gentleben> kmc: yeah. they called me to tell me about it
17:43:47 <Peaker> (though in Haskell these disadvantages don't matter much due to avoidance of shared mutable state)
17:43:58 <gentleben> kmc: thats actually how i found out and it made a number of other things make more sense
17:44:05 <kmc> heh
17:44:12 <kmc> GHC uses M-N threading
17:44:21 <kmc> the Concurrent Haskell paper / spec does not require it
17:44:30 <kmc> in fact for many years GHC only did N:1 threading
17:44:30 <gentleben> kmc: like why they couldn't tell me what i would be working on. its not that it was secret, they hade no idea
17:44:34 <ddarius> Hugs uses cooperative concurrency.
17:44:42 <kmc> except it would still make a new OS thread for blocking FFI calls
17:44:54 <kmc> but the non-threaded RTS only has one OS thread of Haskell execution
17:45:30 <monochrom> non-threaded RTS has only one OS thread for everything. if FFI blocks, it's a stop-the-world
17:45:44 <kmc> monochrom, only true of foreign import unsafe
17:45:48 <kmc> i'm pretty sure
17:46:01 <monochrom> no, I am the sure one
17:46:04 <kmc> oh no
17:46:32 <ddarius> monochrom: But are you Ms. Pretty Sure?
17:46:53 <monochrom> I'm HMS Defiantly Sure
17:46:55 <shapr> I'm Mr. I Certainly Think So.
17:47:11 <shapr> Or am I Not Really Sure?
17:48:17 <kmc> yeah monochrom is right
17:49:22 <luite_> Peaker: but you're forced to do everything in a single OS thread if you want to have any of those advantages. and I don't really understand why it's apparently possible to use a small shared state with haskell, but not with other languages?
17:49:44 <kmc> luite_, it is possible in other languages, but other people's libraries will work against you
17:50:12 <kmc> the 'revolutionary' thing about Haskell is that most libraries take the idea of a functional API seriously
17:50:13 <Peaker> as well as the languages' idioms
17:50:16 <kmc> not that the language forces it
17:50:19 <ddarius> Mutable state is a temptation that is too hard to resish.
17:50:45 <kmc> in "Haskell on a Shared-Memory Multiprocessor" they talk about "Uni-GHC" which has the behavior I describe
17:50:55 <kmc> but I guess this is the behavior of -threaded on old versions of GHC
17:51:44 <edwardk> @hpaste
17:51:44 <lambdabot> Haskell pastebin: http://hpaste.org/
17:51:47 <gentleben> kmc: I am not sure the developers of most "APIs" should be building APIs
17:52:15 <Peaker> I was toying with implementing filterM with explicit dict passing in Python -- and then I realized that with explicit lack of support for tail-call-optimization, it's not very practical to implement that in Python. I could CPS everything (including the definition of bind itself) but that's way further than one should be willing to go
17:52:17 <hpaste> edwardk pasted “Who Needs Superclass Defaults?” at http://hpaste.org/53466
17:52:19 <gentleben> building coherent APIs is actually a hard problem and I think one of the hard things about coming to haskell
17:52:29 <edwardk> kmc: check the new version, in particular, the last line =)
17:53:08 <kmc> cool!
17:53:26 <edwardk> i got it to bootstrap with only one level of reflection
17:53:38 <edwardk> so now i don't need all the () :=> () :=> …. crap everywhere
17:53:43 <ddarius> Peaker: CPSing makes all calls tail calls which is the opposite of what you'd want, though you could go further and manually trampoline the code, but that doesn't require CPSing.
17:54:25 <edwardk> basically that lets me use applicative sugar using just a monad instance in scope.
17:55:06 <edwardk> and similarly Alternative using just a MonadPlus, but without coercing everything into some horrid WrappedMonad thing
17:55:40 <Peaker> ddarius: Well, I meant actually CPS'ing and then returning what to call rather than calling
17:55:57 <Peaker> ddarius: and then having an outer loop repeatedly call the returned func
17:56:01 <monochrom> is edwardk demonstrating that ContraintKinds supersedes subclassing?
17:56:03 <edwardk> i built another version using TypeFamilies, but it turned out to be 400 characters longer, despite the fact that i could elide all the where ins = Sub Dict stuff by careful defaulting
17:56:14 <Peaker> that looks more like what a compiler would want to write than what a human would want to maintain :)
17:56:36 <edwardk> monochrom: no, i just have a hack that lets me coerce dictionaries to the wrong newtype using unsafeCoerce which is much nicer to reason about this way
17:56:43 <edwardk> you could write this code under the current ghc actually
17:56:49 <Peaker> so it seems implementing monads in Python, even via explicit dict-passing, is not practical at all
17:56:50 <ddarius> Peaker: Yes, that last part is trampolining.  There's no need to CPS to accomplish that.
17:57:10 <Peaker> ddarius: can you show an example of how to do it without CPS?
17:57:56 <luite_> kmc: apparently it's ok to require CPS everywhere, so that everything needs to be built from scratch again, but not to require that libraries behave properly in a concurrent setting?
17:58:16 <luite_> of course the first is new and radical and exciting and all
17:59:10 <hpaste> edwardk annotated “Who Needs Superclass Defaults?” with “Who Needs Superclass Defaults? (using type families, not MPTCs)” at http://hpaste.org/53466#a53467
17:59:40 <edwardk> that version lets me just say: instance Instance (Ord ())
18:00:13 <edwardk> and the tricky class associated type default, and default method implementation avoid most of the where clauses
18:00:31 <ddarius> var step = stepper; while(true) { step = step(); };  stepper() { return stepHelper(1); }; stepHelper(n) { /* do something */; return () => stepHelper(n+1); }
18:00:51 <edwardk> but a.) it is harder to read and b.) the overhead of the ones where I _do_ have to supply the type are sufficiently more verbose that the solution takes more characters than the MPTC version
18:01:31 <edwardk> the ideal version would use MPTCs and a default method definition for ins, but that would require that you could use default foo :: …; foo = …   inside of an MPTC which isn't currently supported.
18:02:39 <Peaker> ddarius: if the untransformed stepper had looped over a list, how would you translate that?
18:03:48 <ddarius> Peaker: You would just pass in a list to stepper and run stepHelper(theList) instead of stepHelper(1).  What about lists would make them at all more difficult to handle?
18:07:47 <Peaker> ddarius: stepHelper needs to call another function for each item on the list, but it can only return one thing to call?
18:08:31 <ddarius> You can return as many things as you want.
18:10:05 <Peaker> ddarius: if I change the trampoline loop there to call more than just one result, you mean?
18:11:46 <ddarius> You wouldn't normally do that and I'm not sure where stepHelper needing to return more than one function comes from.
18:19:47 <ddarius> The general transformation is: f(args) { ...; if(baseCase) return result; else return f(newArgs); } => f(args) { ...; if(baseCase) return Left(result); else return Right(() => f(newArgs)); }; trampoline(g) { step = g; while(true) { switch(g) { case Left(r): return r; case Right(h): step = h; } } }  Any non-tail occurrences of f get replaced with trampoline(f).
18:23:55 <ddarius> Note that the above is exactly what the Resumption (aka Pause) monad does, only in Haskell we don't need the explicit thunking.
18:24:29 * shapr hugs ddarius 
18:24:31 <ddarius> Also, Either a b wouldn't work because the type would be recursive, e.g. data Resumption a = Done a | Step (Resumption a)
18:24:49 <ddarius> shapr: Maybe I should fly south for the winter.
18:25:58 <shachaf> South as in Alabama?
18:26:11 <shapr> ddarius: Sure, come hang out with me.
18:26:50 --- mode: ChanServ set +o mauke
18:26:50 --- mode: mauke set -q *!*@gateway/web/freenode/ip.82.161.181.132
18:27:40 --- mode: mauke set -o mauke
18:27:47 <roconnor> -Wall gives a retarded number of warnings
18:28:01 <ion> for retarded code
18:28:04 <ddarius> roconnor: Stop writing such crummy code.
18:28:19 * ddarius never uses -Wall in any language regularly.
18:28:25 <roconnor> ddarius: which is better 2 ^ 256 or 2 ^ (256 :: Int) ?
18:28:48 <ddarius> 2^(256 :: Integer)
18:29:08 <ddarius> You never know if 256 is out of bounds of an Int!
18:29:09 * kmc uses -Wall in Haskell
18:29:18 <shachaf> ghc -Weffc++
18:29:23 <ddarius> (The scary thing about my statement is that it is potentially true!)
18:29:55 * roconnor rewrites p = 2^(256 ::Integer) - 2^(32::Integer) - 2^(9::Integer) - 2^(8::Integer) - 2^(7::Integer) - 2^(6::Integer) - 2^(4::Integer) - 1
18:29:56 <ion> -Wall ftw. in everything that has it
18:30:06 <roconnor> that is so much easier to read now
18:30:34 <MostAwesomeDude> shapr: I hear you like Twisted.
18:30:41 <ddarius> I wrote 256 :: Integer, not 256::Integer and certainly not 256 ::Integer.
18:30:43 <roconnor> maybe I should redefine (^) to take Integer for the second argument
18:30:48 * shapr stares at MostAwesomeDude balefully
18:30:52 <shapr> MostAwesomeDude: Why do you say this?
18:31:00 <roconnor> ddarius: -Wall doesn't seem to care :D
18:31:04 <ddarius> roconnor: And an arbitrary monoid as the first!
18:31:06 <kmc> yeah if I actually had code like that I would make a local helper
18:31:19 <ion> > foldl1' (-) . map (2^) $ [256, 32, 9, 8, 7, 6, 4, 0]
18:31:19 <MostAwesomeDude> shapr: Because I come from the land of Twisted and wish that networking was roughly as painless in Haskell as it is there.
18:31:20 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007908834671...
18:31:23 * ddarius stares at shapr Calefully.
18:31:25 <Peaker> I use -WarnMeAboutAnythingPossible everywhere -- safety over convenience is much more convenient in the long run
18:31:27 <shapr> ddarius: ha!
18:31:42 <roconnor> ddarius: actually that reminds me that I have a ZModule.hs file that I could use
18:31:46 <shapr> MostAwesomeDude: Twisted isn't particularly painless from my viewpoint.
18:31:55 <roconnor> (*+) :: ZModule m => m -> Integer -> m
18:32:14 <shapr> Last time I dropped by #twisted and tried to discuss ajax with them, I got told to use Twisted anyway, and they got on my nerves.
18:32:17 <shapr> I do like the people though.
18:32:19 <ddarius> Actually, it's (^^) that should take an Integer.  (^) should take a Natural.
18:32:22 <roconnor> actually I have warnings for my implemenation of (*+) that I don't understand.
18:32:28 <shapr> MostAwesomeDude: What sort of networking are you attempting?
18:32:32 <MostAwesomeDude> Ah, I had gotten the impression you were a former Twisted/Divmod guy.
18:32:39 <roconnor> @type (^^)
18:32:39 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:32:48 <MostAwesomeDude> Nothing super-fancy. Wiring up Attoparsec to a socket. I've almost got it working.
18:32:57 <shapr> Cool, I'd like to see what you get!
18:33:01 <ddarius> (Group a, Integral b) => ...
18:33:05 <dylex> I just ran into a server using twisted and wanted to write a haskell client for it.  gave up on that pretty quickly.
18:33:08 <MostAwesomeDude> I was just thinking that it'd be kinda cool if there were a unified, blessed approach in the community.
18:33:10 <Peaker> shapr: that's a great opportunity to troll Haskell back at them :)
18:33:26 <MostAwesomeDude> Peaker: Trufax: Apparently Deferred is a monad. >:3
18:33:31 <shapr> MostAwesomeDude: But yes, every year or so I drop by #twisted and ask about the C++ and Java versions. Twisted did once exist as C++ and Java versions :-)
18:33:38 <Peaker> MostAwesomeDude: it's close to ContT, but it's not quite
18:33:42 <shapr> @quote twisted
18:33:42 <lambdabot> No quotes match.
18:33:44 <shapr> hrm
18:33:56 <shapr> MostAwesomeDude: Well, I appear in the Twisted Quotes
18:34:02 <Peaker> MostAwesomeDude: because instead of (>>=) you mutate the Deferred in-place to add callbacks
18:34:42 <Peaker> MostAwesomeDude: and that actually causes a significant problem in Twisted, where the operation starts before you know whether it'll have any error handlers -- so you don't have any way to handle errors if they happen and someone forgets to chain an error handler
18:34:56 <Peaker> MostAwesomeDude: Twisted is pretty poorly designed from the ground up
18:35:04 <MostAwesomeDude> Peaker: Patches welcome!
18:35:18 <Peaker> MostAwesomeDude: the problem is changing this in Twisted breaks compatibility
18:35:36 <MostAwesomeDude> Peaker: Patches which deprecate old functionality without removing it are also welcome!
18:35:39 <Peaker> MostAwesomeDude: you need operations to start only after you have handlers installed -- that changes the Deferred protocol completely
18:35:50 <MostAwesomeDude> Okay. We could do that.
18:36:32 <Axman6> @quote shapr
18:36:32 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
18:36:52 <Peaker> MostAwesomeDude: I personally lost interest in Twisted after I found out Haskell is actually better than Python for all these things I was using Twisted for :)
18:36:53 <shapr> So true.
18:37:08 <shapr> Yah, I only use Python for job$ these days.
18:37:15 <shapr> That is, I get paid to write Python.
18:37:18 <MostAwesomeDude> Peaker: Okay.
18:37:31 <MostAwesomeDude> I *love* Python. Right now I'm just experimenting to see if Haskell can be practical.
18:37:36 <shapr> I do sometimes write Python to demonstrate to C++ and C programmers that life doesn't have to be difficult.
18:37:53 <Axman6> MostAwesomeDude: of course it can be practical :\
18:38:02 <mauke> oh, is it python rant o'clock again?
18:38:28 <dylex> Do they actually document the twisted wire format anywhere? would it even make sense to write a haskell package that can speak it?
18:38:30 <MostAwesomeDude> I hope not. I'm not in #python and I'm not trying to evangelize or anything.
18:38:34 <mauke> python sucks because it can't diagnose misspelled variables
18:38:47 <kmc> twisted has a wire format?
18:38:48 <ddarius> If only C had the power of assembly language...
18:38:53 <kmc> i thought it was a framework for implementing well-known protocols
18:39:02 <MostAwesomeDude> dylex: Which wire format? PB, AMP, and Foolscap are documented, and the other things Twisted implements are all RFC'd.
18:39:07 <Peaker> MostAwesomeDude: I loved Python too -- until I saw how much nicer things can be done
18:39:15 <dylex> kmc: it seems to support its own protocol that can pass around objects... at least that's how this server works
18:39:23 <Peaker> MostAwesomeDude: I still like Python, it has some nice things about it
18:39:41 <shapr> Python is my favorite language after Haskell :-)
18:39:49 <kmc> anyway a library for easier network programming would be great
18:39:52 <shapr> Not saying I dislike Python, just that I'd rather write Haskell.
18:39:53 <kmc> you should write it MostAwesomeDude :)
18:39:59 <shapr> MostAwesomeDude: Yes please!
18:40:04 <dylex> MostAwesomeDude: oh, um, let's see. twisted.spread.pb
18:40:11 <MostAwesomeDude> kmc, shapr : Sure, gimme a few years to be used to Haskell first. :3
18:40:14 <monochrom> actually, it's python love o'clock
18:40:24 <kmc> we don't need to cover up Haskell library deficiencies by wanking about Python vs Haskell in useless general terms
18:40:25 <Peaker> When your code is simple and executes in no time with 100% coverage, you don't benefit almost at all from type checking. And so it is tempting to ignore the benefits of typing at the beginning of projects, because so many of them start in that state
18:40:58 <MostAwesomeDude> dylex: PB's documented. It's also bonghits; there's a reason (or three) that we don't recommend PB for new code.
18:41:13 <Peaker> After you've scaled up, that's when you need typing, and that's when it's "too late"
18:41:21 <ddarius> My favorite languages (that I've actually done significant work in), in no particular order, are Haskell, C++, and C#.
18:41:46 <Axman6> Haskell and C for me
18:41:59 <kmc> i mean, there are already many network libraries
18:42:01 <Axman6> i'd like to add Ada to that list
18:42:07 <ddarius> Actually, x86 assembly should also be in my list.
18:42:08 <kmc> probably even understanding what the existing ones provide is a daunting task
18:42:11 <dylex> MostAwesomeDude: hrm well, clients in the wild and all... but maybe i'll look into it more carefully. i don't want to write a new client in python.
18:43:05 <MostAwesomeDude> dylex: PB is very *very* unfun because it attempts to put proxies on both sides of the connection and do translucent RPC. Do you have deployed PB right now? :c
18:43:32 <kmc> eg http://hackage.haskell.org/package/network-fancy and http://hackage.haskell.org/package/network-server
18:43:38 <roconnor> What is a quasicrystal?
18:44:04 <ddarius> Clearly you define the simplest protocol that you can for migrating code across the wire, then you can just dynamically add new protocol handlers whenever.
18:44:06 <dylex> MostAwesomeDude: a project I would like to add features to does, yes.
18:44:13 <shapr> roconnor: five fold symmetry!
18:44:16 <ddarius> @google quasicrystal
18:44:17 <lambdabot> http://en.wikipedia.org/wiki/Quasicrystal
18:44:17 <lambdabot> Title: Quasicrystal - Wikipedia, the free encyclopedia
18:44:48 <shapr> roconnor: penrose tiles!
18:45:09 <shapr> They have some interesting connections to superconductors too...
18:45:17 <MostAwesomeDude> dylex: I'm so sorry. We don't have a remuneration program or anything to help compensate those people who have deployed PB in the wild. :c
18:45:26 <roconnor> that's what I thought
18:45:34 <roconnor> but this haskell animations don't really look like that
18:45:37 <MostAwesomeDude> I'll put "PB for Haskell" on my list of things to do sometime in the far future.
18:46:47 <shapr> I worked on PB for Haskell long ago.
18:47:14 <luite_> what's PB?
18:47:33 <MostAwesomeDude> Perspective Broker. An RPC protocol from the early years of Twisted.
18:48:13 <Peaker> there's RPyC which is nice
18:48:20 <luite_> ah
18:49:42 <MostAwesomeDude> There's always XML-RPC or JSON-RPC. I'm assuming there's Haskell flavors of those. I also bet there's a Haskell AMP somewhere out there.
18:49:58 <Peaker> I wrote a transparent Python RPC thingie, unpolished, years ago. Then a friend of mine saw that and reimplemented a polished, documented version (RPyC) and then made a nice website/etc, and now it has quite a few enthusiastic users/followers
18:50:33 <Peaker> People love it -- it makes distributing work on a bunch of network computers really easy, as well as distributed testing frameworks
18:50:56 <shapr> Peaker: How do we do that for Haskell?
18:51:09 <Peaker> shapr: I think CloudHaskell thing is the closest I saw..
18:51:23 <Peaker> shapr: this is the only case I've seen where Python's dynamic nature really makes that kind of thing easy
18:51:28 <Nafai> MostAwesomeDude: PB for Haskell would rock.
18:51:41 <Peaker> It's still possible with static languages, but not as easy to implement
18:51:45 <copumpkin> PB&J
18:51:54 <copumpkin> Perspective Broker & Javascript
18:52:18 <ddarius> copumpkin always comes in with the sophisticated jokes.
18:52:26 * copumpkin bows
18:52:38 <dylex> Generic protocols that are tightly bound to a single language seem like a bad idea...
18:52:48 * hackagebot swish 0.6.3.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.3.0 (DouglasBurke)
18:52:58 <Peaker> with RPyC, you do a remote import -- and use it as if it were local..   disp = connection.modules["pygame"].set_video_mode(..) ; disp.draw_stuff() <-- draws on a remote machine window
18:53:29 <MostAwesomeDude> copumpkin: Actually, twisted.spread has subpackages pb, banana, and jelly. :3
18:53:50 <Peaker> dylex: The RPyC guy's next project is sort of an inter-language RPC thing (Like Apache Thrift, but done better.. he complaing Apache thrift inlines everything and thus generates megabytes of Java code from a small IDL file)
18:54:15 <Peaker> dylex: I think I got him to do have Haskell support too, but I am not sure he eventually got that done
18:56:19 <copumpkin> MostAwesomeDude: nice!
18:56:24 <Peaker> http://agnos.sourceforge.net/ <-- inter-language rpc that should get Haskell support too
18:56:28 <monochrom> ML. Merrill Lynch. :)
18:58:21 <kmc> oh boy another one
18:59:06 <kmc> the great thing about standards
18:59:16 <monochrom> and meanings, too
18:59:39 <kmc> oh no, inlining! megabytes of Java code!
19:00:00 <ben> Are we talking about bloat
19:00:05 <monochrom> who is inlining java code?
19:00:16 <kmc> Peaker, did anyone check that the megabytes of Java code actually matter?
19:00:35 <ben> I wrote a small haskell program that basically does two http requests and throws attoparsec-enumerator/aeson at the result and the binary is 16MB
19:00:44 <ben> I'm really confused by that
19:00:58 <kmc> ben, you pulled in a bunch of libraries, and they're all statically linked
19:02:13 <monochrom> I think ben answered kmc's question on whether megabytes of any code matter.
19:02:38 <ben> Yeah, but I'm amazed that it adds up that fast.
19:02:50 <parcs> ben: stripping the binary will likely half the size
19:02:52 <kmc> anyway, I don't get it.  there are hundreds of serialization and RPC protocols, and it seems that every programmer surveys the field, decides they're all crap, and that s/he'll write a new one and this one won't suck
19:02:54 <Peaker> kmc: it compiled to a huge binary, yes
19:02:59 <ben> Yeah, it dropped the size to 11MB
19:03:02 <Peaker> kmc: and it took a long time to load
19:03:17 <kmc> and inevitably it does
19:03:25 <Peaker> kmc: Also, the guy has good taste, I have no doubt his result is better than what Apache pushed out :)
19:03:39 <kmc> why is this problem so hard, and why are we reinventing the wheel over and over rather than picking a solution and refining it
19:03:52 <ben> My code is 60 lines, but to be fair 16 are import statements for ten or so different packages
19:04:05 <kmc> Thrift started as a course project at Caltech :)
19:04:07 <ben> Clearly it's 1MB per import.
19:04:08 <Peaker> kmc: I don't think that there are that many cross-language RPC's.. and Python didn't have any usable transparent/symmetrical RPC before RPyC
19:04:12 <kmc> and it's been used at Facebook for a long time
19:04:18 <parcs> ben: those 16 imports import lots of other things
19:04:22 <kmc> before being picked up by Apache
19:04:46 <parcs> try compiling with -dynamic and see how many libraries are linked
19:04:55 <monochrom> static linking is why your exe is large. that is all.
19:05:02 <kmc> not that many cross-language RPC's?
19:05:04 <ben> It won't do, because I apparently don't have Data.Vector available dynamically
19:05:08 <kmc> people have been inventing them for decades
19:05:22 <Peaker> kmc: I think the Agnos project greatly improves upon the IDL too
19:05:30 <monochrom> try static-linking gtk+ some day to put things into perspective
19:05:30 <kmc> of course every generation of programmers thinks they're the first to come across this amazing concept
19:05:31 <Peaker> kmc: can you name a few?
19:05:35 <MostAwesomeDude> ProtoBufs, Thrift, JSON, something like a dozen different flavors of XML...
19:05:37 <kmc> and ignores the successes and failures of what came before
19:06:00 <ben> How do I, uh, ask cabal-install to make it so I can link vector dynamically?
19:06:34 <monochrom> let me cabal install --help for you
19:06:35 <kmc> thrift, xml-rpc, json-rpc, soap, corba, sunrpc
19:06:55 <monochrom> cabal install --shared
19:06:56 <Peaker> kmc: CORBA, COM, DCOM, xmlrpc, and others are pretty bad, compared to RPyC, for example
19:07:02 <kmc> yeah I know they're bad
19:07:09 <kmc> you said they didn't exist
19:07:14 <kmc> you're proving my point
19:07:16 <Peaker> kmc: the conclusion "everything out there sucks, I'll write one" may actually be correct... Just because you're paranoid, doesn't mean that they aren't after you
19:07:32 <ben> When I cabal install --help'd it suggested --enable-shared, not --shared, was this a trick
19:07:48 <monochrom> no
19:07:50 <Peaker> it may be true that when most people say this -- they'll end up writing yet another crappy solution, but there may be some people who can say that and do a good job
19:08:54 <kmc> plus there are hundreds of messaging frameworks and serialization formats and network transports
19:10:02 <kmc> like i think the gap between 0MQ and "rpc" is pretty small
19:10:04 <monochrom> sorry, I see my mistake. I mistyped "cabal install --enable-shared" as "cabal install --shared".
19:10:24 <ben> It failed and I had to run it on a dependency apparently. I'm sure I'm getting there eventually. thanks. :)
19:10:30 <kmc> every web app that uses a JSON API over HTTP is implementing an RPC mechanism
19:10:34 <kmc> even if it's not compliant JSON-RPC
19:10:34 <monochrom> henceforth I will answer "cabal install --help" only.
19:10:52 <monochrom> telling people to rtfm is not only more helpful but also more correct
19:11:00 <ben> "it's a flag to cabal install" would have sufficed :(
19:11:03 <Peaker> kmc: yeah, the natural thing is to find a good-enough solution, or if you can't find one, write one
19:11:21 <monochrom> there is also a line in .cabal/config you can set
19:11:54 <parcs> isn't it --enable-library-shared?
19:12:13 <parcs> nope
19:12:14 <monochrom> apparently, no
19:12:14 <ben> Is there a reason that it's off by default apart from conserving space maybe?
19:12:27 <monochrom> few people use shared
19:12:38 <parcs> shared doesn't work with things that use TH
19:13:12 <parcs> only because cabal is too stupid to compile TH things properly in that case
19:13:26 <monochrom> chicken and egg. few people use shared. therefore certain wrinkles are not fixed or mitigated. therefore few people use shared. therefore...
19:13:40 <ddarius> ghc --help is annoying
19:14:15 <monochrom> the biggest wrinkle is how does the exe find out where are the *.so's
19:14:44 <monochrom> the current default is "hardcode absolute paths in the exe"
19:14:51 <kmc> shared is pretty new at all
19:15:00 <kmc> also, a lot of people prefer static, for easy deployment
19:15:12 <monochrom> before you laugh at that, consider the fact that the *.so's are scattered in a million different directories.
19:15:17 <kmc> in C and C++
19:15:18 <kmc> as well
19:15:35 <kmc> also does -shared enable -fPIC?
19:15:40 <monochrom> yes
19:15:43 <kmc> on 32-bit x86, -fPIC has a pretty significant performance penalty
19:16:04 <kmc> and I expect it to be worse with GHC code because register pressure is even higher
19:16:07 <monochrom> no wonder -fPIC is nondefault everywhere I have seen
19:17:54 <monochrom> but yes, the silver lining is that sometimes people come and ask "I'm about to deploy ghc-generated stuff to another computer, what files should I pay attention to?" and we answer "just the exe, static linking" and everyone wins.
19:18:25 <ben> I tried that since I figured, hey, 16mb, probably got batteries included, and I was missing libgmp on the other system ;)
19:21:09 <kmc> just the exe and libc.so and libffi.so and libgmp.so :(
19:23:24 <gienah> and libpng.so if gtk is used
19:25:53 <ben> These version requirements on packages seem tricky
19:32:09 <hpaste> modec pasted “typecheck” at http://hpaste.org/53468
19:32:26 <modec> Hey everyone, I am a little confused on why this "f xs = map -1 xs" typechecks
19:33:40 <gienah> libpng is only an indirect dependency when gtk is used, the direct dependencies of hledger-chart are: libncursesw.so.5,libcairo.so.2,libgmp.so.10,libm.so.6,librt.so.1,libdl.so.2,libpthread.so.0,libc.so.6
19:33:59 <shachaf> @ty let f xs = map -1 xs in f
19:33:59 <lambdabot> forall t a b. (Num [b]) => t -> (a -> b) -> [a] -> [b]
19:34:11 <shachaf> modec: It's parsed as (map - (1 xs))
19:34:33 <shachaf> Maybe you want map (-1) xs? That won't work either, though, because - is a dirty special case in Haskell.
19:34:42 <shachaf> Possibly map (subtract 1) xs. :-)
19:36:02 <modec> thanks so why is this ok? @ty 1 [1,2,3]
19:36:07 <modec> @ty 1 [1,2,3]
19:36:08 <lambdabot> forall t t1. (Num ([t1] -> t), Num t1) => t
19:36:26 <shachaf> "1" can potentially be a function, because integer literals are overloaded.
19:36:39 <Axman6> :t (-?x) 4
19:36:39 <lambdabot> Not in scope: `-?'
19:36:45 <modec> oh i see
19:36:47 <shachaf> @ty 'a' ['a','b','c']
19:36:48 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Char'
19:36:48 <lambdabot>     In the expression: 'a' ['a', 'b', 'c']
19:36:52 <Axman6> :t (-(?x)) 4
19:36:53 <lambdabot> forall t t1. (Num (t1 -> t), ?x::t1 -> t, Num t1) => t
19:36:56 <shachaf> See, it doesn't work with other literals.
19:37:08 <shachaf> Axman6: Stop confusing poor modec.
19:38:01 <modec> yap got it. is this ever useful? Num a where a can be a function type?
19:38:13 <shachaf> modec: Potentially.
19:38:31 <shachaf> In general, if there's no reason to rule it out, why make a special case?
19:38:37 <shachaf> For example, lambdabot has the following overloading:
19:38:52 <shachaf> > exp 5
19:38:53 <lambdabot>   148.4131591025766
19:38:54 <shachaf> > (exp * 2) 5
19:38:54 <lambdabot>   296.8263182051532
19:39:06 <shachaf> > ((*3) + (+1) + 4) 8
19:39:06 <lambdabot>   37
19:39:27 <modec> @ty exp
19:39:28 <lambdabot> forall a. (Floating a) => a -> a
19:39:35 <shachaf> exp x is e^x
19:39:41 <shachaf> Numeric operations are automatically lifted to work on functions.
19:39:53 <modec> i see
19:40:06 <Axman6> in lambdabot
19:40:12 <Axman6> not by default
19:40:23 <shachaf> Right.
19:40:49 <modec> ok i see . thanks! i ll come back if i confuse myself again
19:45:31 <ben> Amazing, now that my program is dynamically linked, the binary is only 61K! 45K stripped!
19:45:41 <ben> In addition it still seems to function
19:46:02 <Axman6> bonus!
19:46:25 <shachaf> preflex: seen bonus
19:46:25 <preflex>  bonus was last seen on #haskell 186 days, 7 hours, 25 minutes and 1 second ago, saying: yeah i think that's better as well
19:46:46 <parcs> ben: now run upx -9 --brute on it
19:47:31 <ben> ldd output has 75 lines, wow :v
19:48:56 <shapr> preflex: seen bonus500
19:48:56 <preflex>  Sorry, I haven't seen bonus500
19:49:02 <shapr> preflex: seen simonpj
19:49:02 <preflex>  simonpj was last seen on #ghc 3 years, 53 days, 11 hours, 47 minutes and 55 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
19:50:38 <ben> I didn't upx did that much. :>
19:50:46 <ben> didn't know*
19:51:33 <parcs> whats its size now?
19:51:54 <monochrom> 45K after strip
19:52:02 <ben> 13k after upx
19:52:20 <copumpkin> 324 bytes after handwriting in assembly
19:52:29 <shachaf> copumpkin++
19:52:51 <ben> hm, apparently calling strip on upx'ed executables is a bad thing
19:52:54 <monochrom> priceless after I format the disk and take a picture of your face
19:54:08 <monochrom> sed is 24 bytes. http://www.gnu.org/fun/jokes/ed.msg.html
19:54:18 <shachaf> You mean ed.
19:54:26 <monochrom> yeah, ed
20:04:08 <wires> roconnor, http://www.perimeterinstitute.ca/index.php?option=com_content&task=view&id=551&Itemid=568&lecture_id=4126 <-- quasicrystals
20:04:31 * roconnor should walk over to the PI and knock on their door
20:05:09 <wires> hehe, you are that close?
20:05:22 <roconnor> I would probably have to drive
20:05:32 <wires> ah :)
20:05:32 <roconnor> it would take hours by foot
20:06:00 <wires> love their (public) lectures
20:08:01 <ben> I understand it is customary to use Either String to report errors if a computation didn't succeed. But if it's IO code and I'm only really there for the sideeffects, should I return IO (Either String ()), IO (Maybe String) or just throw IO exceptions?
20:09:07 <simon> maybe you should structure it so that your logic isn't wrapped in IO.
20:09:28 <kmc> another option is ErrorT String IO
20:09:31 <newsham> but if he's "only really there for the side effect"...
20:09:35 <kmc> but I'd keep it simple and use IO exceptions
20:09:38 <kmc> as a default
20:09:59 <kmc> what are these errors and what action is to be taken on error
20:10:05 <wavewave> hi
20:10:18 <ben> It's mostly going to be printed and then I terminate in either case
20:10:30 <ben> but I gotta catch the http library's exception because I want to delete partially downloaded files
20:10:33 <newsham> error "you botched!"   ;-)
20:10:43 <ben> so I'm not sure whether I should rethrow it when I'm done or what
20:15:18 <parcs> rethrow it or supply your own error message
20:17:31 <roconnor> ben: I've been known to use IO (Error String a),  In fact I wrote this nifty function:
20:18:02 <roconnor> joinIOError :: IO (Either String a) -> IO a
20:18:03 <roconnor> joinIOError x = x >>= toIOError
20:18:11 <roconnor> toIOError :: Either String a -> IO a
20:18:12 <roconnor> toIOError = either (throwError . strMsg) return
20:18:46 <ben> I see
20:18:59 <mkscrg> anybody have good advice on where to learn about gadts and other type-level programming stuff?
20:19:39 <parcs> the haskell wiki is a solid resource
20:19:55 <kmc> ghc manual's example on gadts is good
20:20:54 <mkscrg> thanks, both of you. i'll check those out.
20:22:14 <parcs> by the way, how apt is the analogy gadts are to adts as type annotations are to type inference
20:22:59 <byorgey> parcs: not
20:23:29 <kmc> i haven't heard that one
20:23:44 <copumpkin> hmm
20:23:54 <shachaf> gadts are to adts as gtype annotations are to type annotations
20:24:13 <parcs> byorgey: why?
20:24:13 <copumpkin> gadts primarily add the introduction of context to pattern matching, over what previous constructions gave you
20:24:32 <copumpkin> where that context can be a type equality
20:24:39 <copumpkin> (I'm not sure if those were available before)
20:25:02 <parcs> oh right that too
20:25:07 <byorgey> parcs: for example, you often use type annotations as a "check" on what type you think should be inferred for something.  GADTs do not serve that purpose.
20:26:59 <parcs> compare 'data Foo a where Foo :: Foo Int' and 'data Foo a = Foo'
20:27:39 <byorgey> parcs: yes, I can see where you would come up with your proposed analogy.  but it is really quite different.
20:27:50 <parcs> :(
20:27:53 <parcs> okay
20:28:00 <byorgey> if you have something that could be inferred to have type  Foo a but you give it the type annotation Foo Int, its type is simply Foo Int, end of story.
20:28:48 <byorgey> whereas the GADT with constructor  Foo :: Foo Int  really means  Foo :: (a ~ Int) => Foo a
20:29:04 <byorgey> I mean, there certainly are similarities.  I just don't think it's a useful analogy.
20:29:09 <parcs> well i'm not say gadts are similar to type annotations
20:29:21 <parcs> saying
20:29:22 <byorgey> GADTs are not that hard to understand, there's no need to confuse things with analogies =)
20:29:35 <mkscrg> thoughts on this wiki page: http://www.haskell.org/haskellwiki/GADTs_for_dummies ?
20:29:38 <kmc> aww but we love confusing analogies!
20:29:52 <byorgey> oops, I just said "X is not hard to understand" =P
20:29:54 <mkscrg> useful or not?
20:29:59 <shachaf> GADTs are to analogies as monads are to?
20:30:26 <byorgey> GADTs are a relatively simple concept, there's no need to confuse things with analogies  <--  better
20:30:48 <shachaf> GADTs are simple compared to GGADTs.
20:31:30 <copumpkin> GADTs are like inductive families, minus the dependent types
20:31:31 <copumpkin> duh
20:31:39 <companion_cube> -_-
20:32:06 <monochrom> GADTs are like ADTs
20:32:10 <parcs> gadts were initially pretty confusing to me, but that was because of their special syntax
20:32:25 <copumpkin> their special syntax makes more sense than the original :o
20:32:29 <parcs> yeah
20:32:45 <ben> I keep confusing gadts with type family, presumably because I have used neither. :(
20:32:46 <parcs> now it does, anyway
20:33:51 <byorgey> mkscrg: seems confusing to me
20:34:18 <byorgey> mkscrg: I wouldn't read that as your *first* introduction to GADTs but it might be useful to come back and read it later
20:34:34 <mkscrg> byorgey: ok, just wanted to get a second opinion. the ghc user guide seems more useful
20:34:47 <copumpkin> you could do the generalized algebraic data family
20:34:48 <parcs> why are type families called type families anyway?
20:34:50 <copumpkin> get the best of both worlds
20:34:56 <monochrom> I learned GADT from ghc user guide, too
20:35:18 <monochrom> because mathematicians let to use "family"
20:35:24 <byorgey> mkscrg: yeah, the fundamentals of GADTs are really quite simple.  What can get confusing are the many ways they are used to do tricky things.
20:35:30 <monochrom> s/let/like/
20:36:20 <mkscrg> yeah, i'm starting to see that
20:36:57 <monochrom> suppose you have sets X, Y, Z, and you define function f with f 1 = X, f 2 = Y, f 3 = Z. mathematicians are not content with "f is a function from numbers to sets". they have to call f "an indexed family"
20:37:43 <monochrom> and that is what happened to "type family". it is not cool enough to say "a function from types to types". they have to bring in the word "family".
20:39:43 <parcs> i wish the origin of technical terms was explained more often
20:39:57 <parcs> i think it really helps with understanding
20:41:12 <monochrom> the origin of technical terms are obscure cultural references. you are none the wiser to know.
20:41:38 <monochrom> great historical hilarity, sure.
20:42:59 <parcs> sometimes
20:43:41 <monochrom> for example like how "family" has nothing to do with family, or "function" has nothing to do with function
20:44:42 <monochrom> I read a number theory book that candidly explains: "the Pell equation is so called because it has nothing to do with Pell"
20:45:23 <simon> I looked up the word "thunk", and the etymology is apparently an attempted past tense of "think"
20:45:57 <parcs> well if it doesn't help with understanding it sometimes helps with memorization/serves as a  mnemonic device
20:46:21 <monochrom> it helps you tell more bedtime stories to your kids
20:46:59 <parcs> that too :)
20:47:04 <monochrom> bedtime stories intended to amuse and/or hypnotize, not to convey real information
20:47:50 <monochrom> you have more things to burden your brain with, but not more aids to understand
20:52:54 <mileschet> /j #slack-br
21:04:52 <MostAwesomeDude> How would I make Word8 values, for unit testing? I have functions which take ByteStrings, I understand how to get [Word8] to ByteString, but there's no information in Data.Word's docs about how to make Word8s.
21:05:53 <parcs> :t 5 :: Word8
21:05:54 <lambdabot> Word8
21:06:07 <MostAwesomeDude> Oh, as uints.
21:06:08 <monochrom> the information is non-obvious. since Word8 is an instance of Num, you can use fromIntegral
21:06:17 <MostAwesomeDude> That's a bit cumbersome, I guess, but okay.
21:06:25 <MostAwesomeDude> Thanks!
21:06:25 <kmc> are you using QuickCheck?
21:06:29 <MostAwesomeDude> Yes, I am.
21:06:35 <kmc> there should already be an instance Arbitrary Word8
21:06:38 <monochrom> [5, 6, 7, 0] :: [Word8]  may help
21:06:54 <Axman6> quickcheck != unit testing
21:07:17 <MostAwesomeDude> Close enough. I gather that strict TDD isn't something done often in Haskell.
21:07:30 <kmc> unless the T stands for type ;)
21:07:51 <kmc> it is pretty common to write tests early on in development
21:08:27 <kmc> sometimes I write a reference implementation and then QuickCheck it against the real one
21:09:12 <kmc> you can also easily run tests from ghci, which is useful for confirming intuition about your code
21:10:18 <kfish> MostAwesomeDude, TDD is nothing to do with language, everything to do with programmer discipline/cluefulness/experience
21:10:46 <kfish> in haskell we can build requirements and scaffolding from both types and test cases
21:11:18 <kfish> so if anything there's stricter tools available for tdd than most other languages
21:11:25 <kmc> recognizing that tests are important is different from adherence to strict TDD orthodoxy
21:12:05 * monochrom adheres to lim n->oo TDD(n)
21:12:48 <kfish> yeah, apparently tests have uses beyond tdd
21:12:53 <kfish> also, haskell is agile
21:14:55 <roconnor> Rather than write tests, I design my types and my modules to make the incorrect impossible as much as reasonably possible.
21:16:10 <gentleben> i wish that were possible in the apps i write
21:16:29 <gentleben> i am deep into looking for a race condition
21:16:37 <gentleben> in a very complex threaded app
21:17:13 <roconnor> gentleben: I guess TDD wouldn't help either eh?
21:17:38 <gentleben> roconnor: sometimes, but not in this case
21:17:58 <gentleben> its something related to an IO somewhere
21:18:09 <gentleben> good thing thats the only thing this app does
21:18:29 <kmc> there are serious limits to how much you can prove with Haskell types
21:18:41 <kmc> and past a certain point the code becomes vastly more complicated
21:19:25 <aavogt> and it's hard to interpret what the type errors actually mean
21:19:29 <kmc> which is better, 100 lines of tested code or 500 lines of insane type hackery to 'prove' the code is correct, provided you didn't make a mistake in the 'specification'?
21:19:31 <roconnor> kmc: don't leave the module system out either.  Opaque types are great at proving lots and lots of unpowerful code.
21:19:34 <kmc> *nod*
21:19:34 <gentleben> there are many useful thing they can prove
21:20:08 <roconnor> s/proving/providing
21:20:30 <kmc> there is a point of diminishing returns where you need to switch to a less rigorous methodology like testing
21:20:50 <kmc> and so large practical Haskell systems will combine these approaches
21:20:54 <roconnor> that's probably true
21:20:57 <gentleben> and then there are my favorites, production bugs
21:21:08 <roconnor> I use test cases to help validate my SHA code
21:21:24 <gentleben> haskell just doesn't have good tools
21:21:41 <kmc> for production bugs? no it doesn't
21:22:12 <kmc> that's at the top of my list of needed tool improvements
21:22:17 <gentleben> everyone here will eventually benefit from some work we are going to do this winter
21:22:36 <kmc> also I would like to see a declarative debugger like http://ww2.cs.mu.oz.au/~bjpop/buddha/
21:22:37 <gentleben> actual symbols and callstacks in gdb
21:22:52 <kmc> something which works with modern ghc
21:22:58 <gentleben> no more of this overlapping identifiers in rage apps
21:23:03 <gentleben> *large
21:24:07 <gentleben> although it may end up in lldb, we will see
21:24:19 <deech> Hi all, are there libraries for providing a Haskell program with a REPL? Besides rolling your own I mean.
21:24:38 <kmc> what would the library do
21:25:00 <gentleben> kmc: compiler extensions
21:26:00 <kmc> deech, what would the library do/
21:26:02 <deech> kmc: Provide some of the same functionality of the GHCI repl, inspect the current contents of MVar's and get definitions of functions for example. In the case of a web-app, get a list of urls.
21:26:24 <aavogt> @hackage haskeline
21:26:24 <lambdabot> http://hackage.haskell.org/package/haskeline
21:27:53 <roconnor> what's a production bug?
21:28:14 <deech> aavogt: That looks great. Thanks!
21:29:01 <gentleben> roconnor: a bug that doesn't occur in testing, in my case only under load
21:29:22 <roconnor> since I don't test, I only have production bugs :P
21:30:33 <gentleben> i am sad for you
21:32:27 <roconnor> gentleben: don't be.  I have fewer bugs to fix this way since I don't find them.
21:32:44 <gentleben> lucky you
21:32:48 <Sgeo|web> It's fully possible to implement a Map-like data structure as just a function a -> Maybe b and operations on those, right? It's just efficiency concerns that prevent that?
21:33:17 <roconnor> Sgeo|web: yep
21:33:57 <Sgeo|web> The thought that if I were to do that, then suddenly want to shift to an actually-efficient implementation, my public API would change, kind of weirds me out a bit
21:34:06 <kmc> it doesn't have to
21:34:15 <kmc> through the power of abstract types
21:34:20 <kmc> newtype Map k v = Map (k -> Maybe v)
21:34:50 <kmc> now you just implement the needed API, and don't export the data constructor
21:34:55 <Sgeo|web> But if the first API doesn't use that newtype, just the raw function
21:35:16 <kmc> i'm suggesting you not do that
21:35:22 <kmc> if you have this concern
21:35:44 <Sgeo|web> Hmm, ok
21:36:27 <Sgeo|web> I guess it's similar to how state stuff is wrapped in a newtype?
21:36:48 <Saizan> then it'd be more convenient to use Data.Map.Map from the start, i'd think
21:36:49 <roconnor> right, you need to use abstract data types for stuff that might change.
21:37:04 <kmc> to which state stuff do you refer?
21:37:08 <Sgeo|web> kmc: State
21:37:13 <kmc> the State monad?
21:37:14 <roconnor> Sgeo|web: Actually you need more than just a newtype, you *need* to use the module system to implement abstract data types.
21:37:22 <kmc> i don't think that's why State is a newtype
21:37:29 <kmc> it's a newtype so that you can write a Monad instance for it
21:38:12 <Sgeo|web> I'm not an ML person, but I've heard good things about ML's module system in comparison to Haskell?
21:38:21 <kmc> there's no way to write «instance Monad (λa.  s → (a,s))»
21:38:27 <kmc> it is more powerful, yeah
21:38:38 <roconnor> however Haskell's module system is adequate for this taks
21:38:40 <roconnor> *task
21:38:41 <kmc> Haskell's module system is intended to be simple, and I think it's well-designed given that goal
21:38:53 <kmc> though I propose a few small extensions
21:39:02 <Sgeo|web> roconnor: sure, for this task, but I'm just curious how ML does things
21:39:53 <roconnor> ML's advanced module system is used to solve problems that are, generally, solved by type classes in Haskell.
21:40:18 <kmc> sometimes i use records as fake first-class modules
21:40:34 <kmc> in GHC you can locally open a record but you can't locally open a module
21:40:47 <Sgeo|web> locally open?
21:41:00 <Sgeo|web> Oh, as in, an import embedded within one function?
21:41:03 <Sgeo|web> Or something else?
21:41:06 <kmc> yeah
21:41:18 <kmc> bring the names into scope without qualifiers, locally
21:41:26 <kmc> GHC RecordWildCards extension lets you do this
21:47:27 <embwbam> I am new to haskell. I want to convert BSON (MongoDB's serialized format) to JSON (so I can send it out over http). I am new enough that I'm not even sure where this kind of code belongs. So, two questions:
21:48:04 <embwbam> 1) If I wanted to make Data.Bson.Document an instance of ToJSON (aeson), where does that code belong? In my app code? In one of the libraries as a patch? A 3rd library?
21:48:32 <embwbam> 2) Help me finish this / please tell if there is an easier way: https://gist.github.com/1335802
21:49:38 <embwbam> Both BSON and JSON have generic types, and it seems like I'd have to manually map between all of them. Plus, they use different string representations... yikes! Any suggestions?
21:51:41 <kmc> which string representations?
21:51:41 <shachaf> embwbam: I hear Aeson is a popular JSON library, particularly as far as efficiency is concerned.
21:51:52 <shachaf> Oh, you're using it.
21:52:04 <shachaf> I thought you meant Data.JSON.
21:53:07 <shachaf> Ooh, CompactString.
21:53:24 <shachaf> Isn't that obsolete? Why does BSON use it?
21:55:20 <embwbam> shachaf: no idea... I don't really know what I'm doing anywhere. I got that by playing around with :t and :i
21:55:59 <embwbam> Is this the right approach?
21:56:27 <kmc> i've never heard of this Data.CompactString
21:56:32 <hpaste> mithos28 pasted “Trouble with GADTs” at http://hpaste.org/53470
21:56:42 <shachaf> kmc: I think CompactString was what preceded Data.Text.
21:56:48 <kmc> *nod*
21:56:49 <shachaf> E.g. http://hackage.haskell.org/package/compact-string
21:56:50 <mithos28> I'm having trouble with GADTs can someone help me?
21:57:03 <kmc> but it seems to support multiple encodings internally, which 'text' doesn't
21:57:07 <kmc> mithos28, sure, hpaste your code
21:57:27 <mithos28> kmc: I did right before I asked the question
21:57:41 <kmc> ah i see :)
21:57:51 <shachaf> Hmm.
21:58:00 <kmc> what's the trouble?
21:58:05 <mithos28> the second definition intToNat won't compile
21:58:22 <mithos28> I don't have the type right, but I'm not sure how to express the type
21:58:40 <kmc> i think that has to be an existential type
21:58:46 <kmc> it's not true for all a
21:58:48 <shachaf> mithos28: That's because its type promises that for all a, it returns Nat a.
21:58:51 <kmc> only for some particular a
21:58:55 <shachaf> Whereas it only returns it for one particular -- yes.
21:59:12 <shachaf> By the way, Int -> (forall a. Nat a) is equivalent to forall a. Int -> Nat a
21:59:28 <hpaste> kmc annotated “Trouble with GADTs” with “Trouble with GADTs (annotation)” at http://hpaste.org/53470#a53471
21:59:53 <mithos28> kmc: I have to erase the type?
21:59:56 <shachaf> Doesn't the existential type defeat the purpose?
22:00:08 <kmc> probably defeats the purpose
22:00:13 <kmc> but otherwise intToNat has a dependent type
22:00:17 <shachaf> Right.
22:00:17 <embwbam> Is there a best place to ask for code help? Stack overflow? A mailing list? My wife wants me to turn off the computer and come to bed :)
22:00:18 <kmc> the return type depends on the input value
22:00:25 <kmc> here or stackoverflow
22:00:27 <mithos28> shachaf: no because I should be able to pattern match later
22:00:56 <shachaf> mithos28: Should you?
22:01:26 <mithos28> shachaf: yes. I want to express I have one of the two variants
22:01:39 <embwbam> Any advice before I head over to SO? You guys probably know how I could handle Array in my function... :) My first though was toJSON (Bson.Array xs) = toJSON which is obviously wrong
22:01:52 <embwbam> sorry = toJSON xs
22:02:19 <embwbam> because I want it to hit the instance of [Field] and recurse that way
22:02:21 <shachaf> mithos28: Right, but the existential type would let you do that.
22:02:36 <shachaf> embwbam: You'd probably want to turn it into JsonArray (map toJSON xs), or something like that.
22:02:46 <shachaf> Whatever JsonArray happens to be called.
22:03:00 <mithos28> but I cannot pass a statically determined variant to a function that expects a dynamic one with out first wrapping it
22:03:16 <shachaf> Oh, and Aeson uses a Vector, not a list, so you'll have to convert that too.
22:03:17 <embwbam> shachaf: ah yes, that should work
22:03:25 <rwbarton> mithos28: you can also write something :: Int -> (forall a. Nat a -> r) -> r
22:03:48 <shachaf> Oh, yes.
22:04:00 <mithos28> rwbarton: CPS is nasty
22:04:11 <rwbarton> hard to say out of context
22:04:13 <Axman6> with this new kind polymporphism stuff, how close is haskell to having proper dependant types?
22:04:14 <rwbarton> which we don't have
22:04:32 <kmc> i don't think that's very close Axman6
22:04:36 <kmc> (and it's not Haskell ;P0
22:04:37 <kmc> )
22:05:00 <shachaf> GHC Haskell ⊂ Haskell
22:05:06 <mithos28> rwbarton: if it wasn't, you would write in it all the time
22:05:17 <rwbarton> I find this attitude rather silly
22:05:30 <Eduard_Munteanu> shachaf: isn't that the other way around, actually?
22:05:31 <rwbarton> I don't need existential types all the time...
22:05:54 <rwbarton> ... maybe when I do, it's the easiest way to solve my problem
22:06:02 <rwbarton> that's consistent with me not using it all the time
22:06:05 <Eduard_Munteanu> (if by Haskell you mean standard Haskell)
22:06:11 <mithos28> rwbarton: true
22:06:22 <mithos28> it might be the least bad rout
22:06:22 <mithos28> e
22:07:11 <shachaf> rwbarton: Are you going to Hac Boston?
22:07:56 <Axman6> embwbam: with 'toJSON (Int32 (I32 i)) = T.Number $ I i', you probably just want toJSON (Int32 i) = T.Number (I i) ot (I (fromIntegral i))
22:07:59 <Axman6> or*
22:08:15 <Axman6> you shouldn't be trying to play with the constructors of things like Ints
22:08:20 <rwbarton> shachaf: Possibly? I expect to be in the area at least
22:09:12 <rwbarton> and it is not the same weeked as Mystery Hunt, so sure
22:09:34 <kmc> you should rsvp to edwardk
22:09:41 <edwardk> yes
22:10:10 <embwbam> Axman6: Thanks! The second one worked
22:10:54 <byorgey> Axman6: depends on your point of view.  it's *closer* but still not that close, IMO (re: dependent types)
22:10:58 <shachaf> And add yourself to the attendees page. :-)
22:11:18 <byorgey> Axman6: actually the kind polymorphism itself doesn't get us any closer to dependent types.
22:12:15 <byorgey> Axman6: it's the promotion stuff which one might say does that... but actually, promotion (unlike kind polymorphism and constraint kinds) doesn't confer any new power at all.
22:12:28 <Eduard_Munteanu> (Agda for instance doesn't even have polymorphism)
22:12:29 <Axman6> hmm
22:12:29 <byorgey> it simply makes it a lot easier to do stuff people were already doing anyway.
22:12:42 <Axman6> ah fair enough
22:13:08 <byorgey> but that stuff people were already doing sure has a "dependent-type-ish" sort of flavor to it.
22:13:24 <embwbam> JSON's Array wants something of type Array, which is defined as `type Array = Data.Vector.Vector T.Value` - but I can't figure out how to make one
22:13:36 <shachaf> embwbam: Use a function from Data.Vector.
22:13:39 <shachaf> @hackage vector
22:13:39 <lambdabot> http://hackage.haskell.org/package/vector
22:14:21 <shachaf> http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector.html#g:36
22:15:16 <embwbam> thanks! there it is. fromList
22:18:04 <Saizan> Eduard_Munteanu: polymorphism as a term is not restricted to those languages where it all happens implicitly, mostly because that's the least interesting aspect of it
22:18:25 <Saizan> s/mostly/also/
22:18:39 <Saizan> and the last it is "Hindley-Milner"
22:19:06 <Saizan> System F is "the polymorphic lambda calculus", in fact
22:19:39 <kmc> yeah, Agda has super polymorphism
22:19:44 <kmc> being dependently typed and all
22:19:58 <kmc> it's at the 'far corner' of the lambda cube
22:21:44 <Saizan> so in a sense kind polymorphism brings haskell closer to that corner, even if it doesn't make it more dependently typed (which is just one axis), though type families don't have a direct equivalent on the cube for example
22:22:17 <Eduard_Munteanu> Saizan: hm, but doesn't the lack of (implicit) polymorphism affect parametricity in such languages?
22:22:26 <kmc> (agda has implicit polymorphism too)
22:22:43 <kmc> (because it allows implicit parameters of any type, including Set)
22:22:45 <dolio> The lambda cube doesn't have a kind polymorphism axis.
22:22:55 <dolio> Unless you're talking about bringing the type language to that corner of the cube.
22:23:00 <Eduard_Munteanu> Hypercube!
22:23:03 <Eduard_Munteanu> :P
22:23:07 <kmc> i thought one axis of the cube was "types depending on types" i.e. type functions
22:23:08 <Saizan> Eduard_Munteanu: nope, the important fact is that you can't pattern match on stuff of type Set
22:23:27 <kmc> which are sort of like type families
22:23:42 <Eduard_Munteanu> Oh, hm.
22:23:43 <Saizan> type families pattern match
22:23:51 <dolio> Type families are defined by case analysis.
22:26:03 <Sgeo|web> Is System F something one can program in?
22:26:11 <Sgeo|web> Realistically, I mean
22:26:26 <Sgeo|web> Or Agda?
22:26:31 <Eduard_Munteanu> No such system is, by that measure.
22:26:36 <kmc> the System F bindings for GTK are pretty lousy
22:27:01 <kmc> you can write real programs in Agda
22:27:11 <Eduard_Munteanu> Since, in addition to the actual calculus and type system you need some primitives for e.g. doing IO.
22:27:11 <kmc> you can do IO the same way as in Haskell, and it works via the Haskell FFI
22:27:24 <kmc> there's even a web framework for Agda
22:27:38 <kmc> Sgeo|web, i think your question is too vague, you didn't define "realistic" or "can"
22:27:51 <Saizan> dolio: noone generalized the lambda cube to arbitrary hierarchies of sorts?
22:28:01 <kmc> that would be Pure Type Systems
22:28:01 <Eduard_Munteanu> Agda isn't a barebones calculus, so that's a different situation.
22:28:16 <kmc> Agda has a lot of the nice syntactic sugar from Haskell -- in fact, it goes much further
22:29:35 <Sgeo|web> Does Haskell have advantages over Adga?
22:29:43 <kmc> Sgeo|web, one *can* program in Brainfuck or untyped lambda calculus or C++
22:29:58 <Axman6> ha
22:30:06 <Saizan> Pure Type Systems are a generalization sof the various systems in the cube, but not a generalization of the cube itself
22:30:21 <kmc> Sgeo|web, yes, there are many times more libraries and developers for Haskell
22:30:27 <dolio> Sure they are.
22:30:30 <kmc> Haskell implementations are far more mature
22:31:19 <dolio> The lambda cube is the pure type system framework specialized to two constants * and [], and a few choices for rule permutations.
22:32:19 <Mak> hai
22:32:36 <Mak> can any 1 tel ow to use dis language 2 create apps
22:33:13 <shachaf> Aw. I was about 2 tel.
22:33:13 <Sgeo|web> "In Agda, the distinction between types and values does not exist. Instead, the language you use to manipulate type terms is exactly the same language that you use to manipulate values."
22:33:21 <Sgeo|web> This sounds interesting
22:33:28 <kmc> it is
22:33:43 <kmc> Sgeo|web, did you find www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
22:35:32 <Sgeo|web> kmc: I was looking at learn you an agda on github
22:35:54 <Eduard_Munteanu> I don't think that's ready yet :/   (or is it?)
22:36:12 <kmc> Sgeo|web, ah, is there a viewable version of it?
22:36:18 <Eduard_Munteanu> But anyway, you should be prepared to look at multiple resources.
22:36:24 <kmc> last I checked the site was down, and I could'nt get hakyll to build from source
22:36:45 <kmc> Sgeo|web, the pdf I linked is a good intro to dependent types and why they're interesting, which should be very accessible for someone with a little Haskell experience
22:36:55 <Saizan> dolio: yeah, so the structure goes mostly away since there are no more costraints on the rules
22:36:56 <kmc> it will help to be familiar with GADTs first
22:37:01 <Sgeo|web> https://github.com/liamoc/learn-you-an-agda/blob/master/pages/introduction.md
22:37:04 <Sgeo|web> This ... works
22:37:12 <Sgeo|web> Don't know about the other pages
22:37:45 <kmc> it's missing pictures
22:38:00 <Sgeo|web> "Agda doesn't even have numbers built in"
22:38:06 <kmc> and various of the markup
22:38:07 <Sgeo|web> Surely there's a default library for numbers?
22:38:11 <kmc> there is Sgeo|web
22:38:19 <Sgeo|web> Ok, good
22:38:23 <kmc> http://www.cse.chalmers.se/~nad/listings/lib/Everything.html here, browse the Agda stdlib
22:38:27 <kmc> Sgeo|web, in fact they are sort of built-in
22:38:37 <kmc> conceptually, natural numbers are defined like any other inductive data type
22:38:50 <kmc> data Nat where { Zero :: Nat; Succ :: Nat -> Nat }
22:39:02 <kmc> but there's compiler support for using a more efficient implementation
22:39:06 <Eduard_Munteanu> It does have syntactic sugar that works with inductive naturals.
22:39:24 <kmc> (to my fuzzy understanding)
22:39:49 * Sgeo|web wonders what it would be like to write a game in Agda
22:40:29 <kmc> painful
22:40:38 <Sgeo|web> Darn
22:40:58 <kmc> you need a lot of libraries
22:41:22 <Sgeo|web> Oh, the pain would come from lack of libraries, rather than fundamental language issues?
22:41:22 <Eduard_Munteanu> You can FFI to Haskell or C, and even get something like do-notation to write programs, but it's still painful and not completely explored.
22:41:29 <kmc> probably both Sgeo|web
22:41:36 <kmc> also, you can ask in #agda
22:42:02 <kmc> Sgeo|web, as for the language, writing functions in such a way that things can be proven about them is very tricky
22:42:14 <kmc> you have to know what you want to prove about your function as you're writing it
22:43:12 <kmc> you can write code without proving things about it
22:43:27 <kmc> but then maybe you should use Haskell instead
22:44:24 <kmc> dependent types may be useful for other roles besides proofs
22:44:53 <kmc> they're certainly much simpler than the pile of type system extensions in GHC
22:45:39 <kmc> Sgeo|web, basically, dependent types in a practical programming language is an active research topic
22:45:43 <kmc> Agda is one of the efforts
22:46:03 <Sgeo|web> Hmm, ok
22:46:06 <kmc> so if you were trying to write a game in Agda, I think you'd get roped into doing a lot of PL research
22:46:16 <Eduard_Munteanu> Yeah, I think Agda's stuff seems a bit more coherent (and I'd even say simpler) than what we have in Haskell wrt that stuff.
22:46:48 <kmc> i would definitely say simpler
22:46:54 <Eduard_Munteanu> You can turn off the termination checker, though.
22:47:03 <kmc> dependent types are much simpler
22:47:15 <kmc> in Haskell we have different ways to do things at type and term level
22:47:36 <kmc> and in GHC a bunch of hacks to give the type level some of the power of the term level
22:47:47 <kmc> in Agda they are the same level and you use the same tools for each
22:48:27 <Sgeo|web> Is "types are first-class" an acceptable summary?
22:48:45 <kmc> it's not a complete summary, but it's one of the big ideas
22:48:52 <kmc> why don't you read that pdf i linked
22:49:05 <Sgeo|web> Ok
22:49:50 <Sgeo|web> I guess it goes into more detail then the current state of Learn you an agda?
22:50:18 <kmc> i wouldn't know
22:50:22 <kmc> I have not read LYaA
22:50:30 <kmc> but I think it will go into more detail than asking vague questions in #haskell
22:53:36 <Sgeo|web> Hmm, checking that it terminates (and occasionally complaining even when it does, ofc) isn't really checking efficiency bounds. I think it would be cool if there was a way to do that, but no idea how that would work
22:54:23 <kmc> well in Agda you can prove that your function makes at most n recursive calls
22:54:24 <mzero> any Mac Haskell Platform users out there?
22:54:37 <kmc> in fact this is how you'd prove termination for a complicated recursion scheme
22:54:49 <mzero> I'm going to put a "remove old versions" option in the next installer
22:55:04 <mzero> but I need to understand all the places people might have Haskell stuff stuck on a Mac
22:55:17 <kmc> Sgeo|web, one approach is to pass through a number representing the maximum recursion depth, and return Nothing if the depth is exceeded
22:55:20 <mzero> I've developed this short haskell program for collecting the information
22:55:30 <kmc> this function will always satisfy the termination checker
22:55:36 <mzero> anyone want to help me test it?
22:55:38 <kmc> because it's structural induction on that number
22:55:44 <mzero> https://bitbucket.org/mtnviewmark/haskell-playground/raw/c8049cfc2197/HaskellSysInfo.hs
22:55:47 <kmc> Sgeo|web, and then you can separately prove that the result is never actually Nothing
22:55:58 <kmc> which then allows you to safely unwrap the Maybe
23:49:54 <tsanhwa> hi, I am using enumerator package, how can two enumeratee be combined into an enumeratee ?
23:53:43 <kfish> tsanhwa, how do you want to combine them? ie. what's a concrete thing you want to do?
23:55:51 <tsanhwa> kfish: e.g. combine filter and map in the Data.Enumerator.List
