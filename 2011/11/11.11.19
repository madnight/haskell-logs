00:20:46 <augur> anyone know how to solve recursive equations?
00:20:50 <augur> or know where i can learn?
00:21:09 <shachaf> Recursive equations like x = x?
00:21:12 <augur> no no
00:21:17 <augur> recursive equations for like algorithmic complexity
00:21:54 <shachaf> Ah. With a base case, no doubt. :-(
00:21:59 <augur> yes of course
00:22:02 <shachaf> Presumably an algorithms book.
00:22:14 <shachaf> Is there a specific recursive equation you have in mind?
00:22:20 <hpaste> clsmith pasted “nested monads (mapM)” at http://hpaste.org/54273
00:22:50 <augur> ahh right these are called recurrence equations
00:22:52 <augur> hmm
00:22:57 <augur> shachaf: yes, one specific one indeed!
00:23:20 <augur> ord(1) = 1
00:23:20 <augur> ord(n+1) = 2*ord(n) choose ord(n)
00:23:36 <bxc> anyoen have experience with the various haskell DNS client libraries i see on hackage
00:24:01 * bxc wrote a delegation checker to DNS in bash+dig but some of the behaviour seems nice to write in a list monad
00:24:14 <clsmith> (now that my net is back,) i realised i could get rid of g entirely, and use Data.Traversable.mapM :)
00:26:02 <mauke> (2n)! / (2n!)
00:26:30 <augur> mauke: :o
00:26:32 <augur> for real?
00:26:42 <mauke> what? no
00:26:43 <augur> howd you solve this?
00:26:47 <augur> o
00:26:47 <augur> :(
00:26:48 <mauke> this is a braindump
00:26:53 <augur> darn!
00:27:28 <ryniek> hi all
00:27:31 <mauke> ord(n+1) = (2*ord(n))! / (2 * ord(n)!)
00:27:33 <rick_> is there a way to call quickcheck so that it sets the exit code if tests fail?
00:27:36 <mauke> in expanded form
00:29:09 <augur> http://www.wolframalpha.com/input/?i=g%281%29+%3D+1%2C+g%28n%29+%3D+%28%282*g%28n-1%29%29+choose+g%28n-1%29%29
00:29:10 <augur> :o
00:31:47 <mauke> intuitively I'd say it grows like iterated factorial
00:32:05 <applicative> howdy ryniek
00:33:20 <mauke> at every step you compute (2n)! and cancel the lower n factors and divide by 2
00:33:45 <mauke> so the significant parts should be the upper n+1 .. 2n factors
00:35:37 * hackagebot smallcheck 0.5 - Another lightweight testing library in Haskell.  http://hackage.haskell.org/package/smallcheck-0.5 (RomanCheplyaka)
00:45:07 <KitB> Does anyone know if there is any *current* work being done on functional operating systems? (The most recent I can find is House/LightHouse from 2009)
00:45:40 <blackdog> KitB: depends what you mean by that
00:45:54 <blackdog> the verified l4 project had a haskell model
00:46:42 <blackdog> if you want a full-featured OS for using day to day, not so much
00:46:51 <KitB> I'm doing some coursework on Systems Programming in Functional Languages
00:47:00 <KitB> I just need to write about them
00:47:11 <KitB> (Though I'm thoroughly interested in the topic also)
00:47:49 <blackdog> probably worth looking into lisp machines
00:48:07 <KitB> Of course
00:48:19 <KitB> Got a section called "prehistory" for things like that
00:48:21 <blackdog> heh
00:48:31 <blackdog> does using them to prove stuff about C & asm OSes count?
00:48:33 <KitB> Speaking of which, know any other stuff that was pre-90s?
00:48:39 <KitB> I don't think so :/
00:48:45 <KitB> I don't need all that much
00:48:51 <KitB> This only needs to be a few pages
00:49:18 <KitB> But I'm supposed to tell my OS lecturer (who's been in the industry since it started almost) something he doesn't already know
00:49:39 <blackdog> hrm. HalVM?
00:49:52 <blackdog> i assume you've gone through http://corp.galois.com/systems-software already
00:50:38 <KitB> I've had a look at HalVM and included a section on it
00:50:51 <KitB> hadn't seen that page though
00:50:52 <KitB> thanks
00:51:37 <blackdog> it's a bit tricky - i don't think anyone these days is silly enough to try to write a general purpose OS from the ground up
00:52:00 <blackdog> as soon as you slip in a C driver for a video card or whatever, poof! go all your safety properties
00:52:23 <blackdog> probably wanna focus on verified & special purpose OSes
00:53:14 <blackdog> i remember there was a project at edinburgh a while back to have a language written with different levels in it so that you could prove realtime properties, at least about the lower levels
00:53:22 <blackdog> sorry, i'm reaching now:)
01:06:24 <KitB> blackdog: Who was writing that at Edinburgh?
01:06:31 <KitB> I could probably go out and find this person.
01:25:40 * hackagebot arx 0.0.0 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.0.0 (JasonDusek)
01:34:11 <Yrogirg> Hello! To use arrow syntax proc x -> do , do i need something else than just import Control.Arrow?
01:35:40 * hackagebot arx 0.0.1 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.0.1 (JasonDusek)
01:40:15 <Yrogirg> I've found the answer --- {-# LANGUAGE Arrows #-}
01:51:41 <hiptobecubic> I had a dream about State
01:51:44 <hiptobecubic> i think i get it now.
01:53:26 <KitB> That's usually how it happens
02:15:45 <ryniek> Ttry Haskell tutorial completed. Nice app i say :)
02:16:29 <ryniek> I think i like Haskell ^^
02:31:03 <Eduard_Munteanu> ryniek: you might want to check out LYAH then.
02:31:08 <Eduard_Munteanu> @where lyah
02:31:09 <lambdabot> http://www.learnyouahaskell.com/
02:39:21 <applicative> ryniek, good work
02:40:09 <especially-corn> hello, does emacs have built in haskell syntax highlighter?
02:41:11 <ryniek> Thx, i heard about that. Also http://book.realworldhaskell.org/read/ is worth reading
02:42:04 <applicative> especially-corn: you've seen the haskell-mode material?
02:42:42 <applicative> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
02:44:26 <especially-corn> applicative, i installed haskell-mode and still no syntax highlighter
02:45:15 <applicative> hm, do you have something like (load "~/lib/emacs/haskell-mode/haskell-site-file")  in your .emacs ?
02:45:45 * applicative is weak at emacs+haskell mode, but highlighting isn't his problem
02:46:18 <monad> how do I get more positions after decimal place if I execute a division
02:46:59 <monad> e.g. 1/7 = 0.14285714285714285, how can I enlarge the fractional part
02:47:14 <monad> is there a module?
02:47:40 <ryniek> kthx bye everyone
02:48:53 <especially-corn> applicative, no
02:49:03 <monad> I want to increase the positions after decimal point, e.g. 1/7 shall be evaluated to  0.142857142857142857142857142857142857142857142857142857
02:50:02 <applicative> especially-corn: I don't have anything that could trigger the highlighting except that one line directing to the location of haskell-site-file.el
02:50:08 <jonno> monad: are you doing project euler?
02:50:13 <monad> yes
02:50:15 <monad> :-)
02:50:23 <jonno> there's a better solution to that problem
02:50:30 <jonno> than brute force
02:50:45 <monad> but this MUST be possible
02:50:51 <jonno> and a neat theorem to go with it, read the wikipedia article about cyclic decimals
02:51:30 <jonno> monad: http://en.wikipedia.org/wiki/Cyclic_number
02:51:37 <applicative> monad, wait, how many digits do you want?  i thought this was a formatting problem at first.
02:52:27 <monad> hmmm, how about 30, it doesnt really matter
02:52:38 <monad> it shall be more than standard
02:53:08 <applicative> oh I see, jonno has got to the bottom of it.  Which project euler problem is this?
02:53:27 <monad> 26
02:53:54 <jonno> monad: you won't solve it trying to squeeze more decimal places out
02:54:05 <monad> maybe you are right
02:54:16 <jonno> I tried it that way for a long time
02:54:21 <monad> ok
02:54:48 <monad> but what's the right theorem for determining the decimal places
02:55:16 <monad> perhaps it depends on the number of primes of the divisor
03:06:36 <RaptorRarr> > let rationalDigits x = let n = numerator x; d = denominator x in map snd . iterate (\(r, _) -> let r' = 10*r in (mod r' d, div r' d)) $ (mod n d, div n d) in rationalDigits (1%7)
03:06:38 <lambdabot>   [0,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,...
03:08:30 <RaptorRarr> Now with stopping!
03:08:31 <RaptorRarr> > let rationalDigits x = let n = numerator x; d = denominator x in map snd . takeWhile (/= (0, 0)) . iterate (\(r, _) -> let r' = 10*r in (mod r' d, div r' d)) $ (mod n d, div n d) in rationalDigits (1%8)
03:08:33 <lambdabot>   [0,1,2,5]
03:11:30 <especially-corn> can anyone tell me the way to convert the string args to ints?
03:11:39 <especially-corn> or any numerical form?
03:11:49 <especially-corn> i tried sum <- (read args !! 0) + (read args !! 1) and it doesnt work
03:12:11 <especially-corn> most places i check just tell me you can use the function read to convert user strings like "3.3" into numbers like 3.3 and function show to convert a number into string.
03:12:17 <especially-corn> but it doesn't tell me the syntax of read
03:12:24 <paolino> especially-corn: read $ args !! 0
03:12:53 <paolino> you want (!!) before read
03:13:14 <paolino> read args !! 0 is (read args) !! 0
03:13:24 <Jafet> You want to stop programming by random guessing
03:13:38 <Jafet> After all, it doesn't work.
03:13:48 <especially-corn> paolino, that seams to work and for writing it ?
03:14:18 <especially-corn> like in a string
03:14:26 <especially-corn> i tried (show $ sum)
03:14:59 <paolino> writing to the console ?
03:15:09 <especially-corn> paolino, no, in a program
03:15:13 <especially-corn> file
03:15:50 <paolino> have a look in System.IO module
03:16:26 <especially-corn> look paolino http://paste.ubuntu.com/743143/
03:16:36 <paolino> writeFile "data.txt" . show $ sum -- is one way
03:16:50 <mm_freak> does anyone know something, which is a category, but not an arrow?
03:17:40 <mm_freak> not asking about CT, but about Control.Category and Control.Arrow
03:18:36 <paolino> especially-corn: the '+' is not the operator you need
03:19:01 <especially-corn> paolino, what do i need?
03:19:21 <paolino> you have used the right one in the line below
03:19:26 <paolino> :t read
03:19:27 <lambdabot> forall a. (Read a) => String -> a
03:19:49 <especially-corn> paolino, but below i'm using concatenation
03:19:55 <paolino> well , what sum should be ?
03:19:57 <wunki> is there a way to compile a single .hs file within a cabal-dev enviroment?
03:19:58 <especially-corn> on that line i want to add two integer values
03:20:00 <paolino> a list of ints ?
03:20:08 <especially-corn> paolino, yes
03:20:43 <paolino> so lists are built with (:) and concatenated with (++)
03:20:51 <paolino> :t (:)
03:20:52 <lambdabot> forall a. a -> [a] -> [a]
03:21:01 <paolino> :t (++)
03:21:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
03:21:16 <paolino> :t Data.List.(++)
03:21:17 <lambdabot> Couldn't find qualified module.
03:21:37 <paolino> sgrunt
03:21:55 <paolino> anyway it's (++) :: [a] -> [a] -> [a]
03:22:46 <especially-corn> paolino, that doesnt look too noob friendly
03:22:51 <especially-corn> was i supposed to guess that?
03:23:08 <paolino> so (read $ args !! 0) : (read $ args !! 1) : [] is a way to build your list
03:23:24 <paolino> especially-corn: no, lambdabot is ill
03:23:39 <paolino> use ghci to ask for types
03:23:40 <especially-corn> like list <- (read $ args !! 0) : (read $ args !! 1) : []
03:23:53 <paolino> not quite
03:23:53 <especially-corn> and then list !! 0 + list!! 1?
03:24:09 <paolino> then you have another problem
03:24:33 <paolino> because you have a [Int] not an IO [Int]
03:24:40 <especially-corn> this book i'm reading isn't too good at explaining things, all it did was give me a hello world and as an exercise i'm supposed to add two numbers but it never told me how to do so and there are no answers in it
03:25:09 <paolino> so <- is wrong, you should use let list = (read $ args !! 0) : (read $ args !! 1) : []
03:25:46 <especially-corn> <- is related to IO operations?
03:25:49 <Blkt> good morning everyone
03:25:55 <mm_freak> paolino: lambdabot is not ill…  it's just different
03:25:58 <mm_freak> :t (.)
03:25:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:26:03 <mm_freak> ;)
03:26:16 <paolino> especially-corn: not only, to do notation
03:26:22 <mm_freak> especially-corn: which book is that?
03:26:32 <especially-corn> mm_freak, build a scheme in 48 hours
03:26:53 <paolino> mm_freak: those assumptions just get in the way more than often
03:27:04 <mm_freak> ah yes, it has received some criticism for being not beginner-friendly, but as far as i've seen it didn't claim to be anyway
03:27:16 <mm_freak> especially-corn: check out real world haskell or LYAH
03:28:21 <paolino> especially-corn: and do notation is a special syntax for monadic composition , and IO is a monad instance
03:28:24 <hpaste> applicative pasted “especially” at http://hpaste.org/54274
03:28:47 <applicative> especially-corn: here's some equivalent formulations of your earlier definition^^^
03:28:53 <especially-corn> paolino, why doesnt let sum = (read $ args !! 0) + (read $ args !! 1)  work?
03:28:56 <mm_freak> especially-corn: for now do-notation just allows you to write, "do this, then do that", for IO stuff =)
03:29:15 <mm_freak> and forget the word "monad" for now
03:29:21 <mm_freak> there are no monads…  there is IO
03:30:08 <paolino> let just bind a value to a name
03:30:17 <mm_freak> whenever you read "a monad", replace it by "IO"
03:30:41 <especially-corn> applicative, why did the book recommand putStrLn("Hello, " ++ sum) and you wrote putStrLn $ "Hello, " ++ show sum
03:30:59 <mm_freak> especially-corn: it's the same
03:31:18 <mm_freak> i would have written the parentheses version, but many haskellers try to avoid parentheses
03:31:28 <mm_freak> f $ x = f x
03:31:32 <ddarius> mm_freak: Would you have written it with no space?
03:31:41 <mm_freak> ddarius: i would have added a space after putStrLn
03:31:50 <applicative> in one sum is the number itself, in the other it is the decimal expression, a string. so sum_string = show sum_number
03:32:10 <applicative> especially-corn: forget that, a different problem
03:32:26 <especially-corn> applicative, it seams to work now
03:32:42 <especially-corn> isn't there any way to sum <- something?
03:33:05 <paolino> if something is IO something
03:33:22 <applicative> especially-corn: the $ is just 'applied to', it groups everything to the left together and applies it to everything to the right. A witty use of precedence for 'infix operators'
03:33:24 <especially-corn> but args come from io
03:33:35 <paolino> getArgs is IO
03:33:38 <mm_freak> (str :: String) <- (getStr :: IO String)
03:33:51 <mm_freak> let (str :: String) = (str :: String)
03:34:17 <applicative> especially-corn: yes there is a prelude sum function that takes a list of numbers, and returns their sum.  Here you are two levels away from applying it
03:34:48 <applicative> first getArgs gives you an IO list, but moreover an IO list of strings.
03:35:29 <mm_freak> (args :: [String]) <- (getArgs :: IO [String])
03:35:41 <paolino> don't do any IO for a month is a nice way to learn haskell, also
03:36:14 <mm_freak> don't underestimate the power of IO
03:36:39 <mm_freak> not learning IO is like not learning 80% of haskell for real world applications
03:37:16 <especially-corn> paolino, mm_freak thanks for the help
03:37:23 <especially-corn> i'll look for some more info
03:37:45 <mm_freak> what works for me is to teach the basics of types and IO (so they can write programs), then go faaaaar away from IO and talk about algorithms, then go back to IO explaining the rest
03:38:35 <mm_freak> reason:  not everybody finds it very exciting to write pure algorithms all the time…  and once you get bored, you will not learn it
03:38:51 <mm_freak> so you should always offer the ability to turn the stuff into real programs soon
03:39:43 <especially-corn> why doesn't this work? args <- getLine
03:39:43 <especially-corn>           let sum = (read $ args)
03:39:43 <especially-corn>        	  putStrLn("Hello, " ++ sum)
03:39:58 <paolino> mm_freak: my complaint is to see parametric types around before understanding 'map' signature
03:40:05 <especially-corn> this time args must be any string
03:40:34 <paolino> especially-corn: you must give a type to args
03:41:00 <paolino> ghc cannot guess it's a number
03:41:02 <Eduard_Munteanu> especially-corn: also sum must be a string
03:41:11 <mm_freak> paolino: sure, you can get to that in the second stage =)
03:41:17 <especially-corn> Eduard_Munteanu, yes, sum is a string
03:41:59 <mm_freak> especially-corn: 'read' takes a string
03:42:04 <mm_freak> you give it a list of strings
03:42:17 <mm_freak> (args :: [String]) <- (getArgs :: IO [String])
03:42:29 <especially-corn> ok this book sucks
03:42:34 <especially-corn> theres absolutely nothing in there about this
03:42:38 <mm_freak> this book is not really for beginners
03:42:40 <especially-corn> i'm taking another book
03:42:50 <especially-corn> but it assumes you are a beginner
03:42:50 <mm_freak> again, check out real world haskell or LYAH
03:42:59 <mm_freak> @where LYAH
03:42:59 <lambdabot> http://www.learnyouahaskell.com/
03:43:02 <especially-corn> k, i'll look into that
03:43:03 <mm_freak> @where RWH
03:43:03 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:43:12 <mm_freak> you can read both online
03:43:22 <Eduard_Munteanu> especially-corn: what book is that?
03:43:40 <especially-corn> Eduard_Munteanu, write yourself a scheme in 48 hours
03:44:40 <Eduard_Munteanu> Can you even read such a book and copy the code in 48 hrs? :)
03:45:10 <Eduard_Munteanu> Oh well, I guess 48 hrs of actual work.
03:45:38 <mm_freak> i think i tried that book, too, and failed =)
03:46:18 <ddarius> "The total of 11 bytes is less than the 6 bytes needed by the trampoline."
03:46:37 <timp_> Morning, what is the right way to convert rom Int to Integer (I am using fromIntegral)
03:46:47 <ddarius> That's the right way.
03:46:52 <timp_> thanks
04:03:25 <Eduard_Munteanu> Is there a name for a bunch of 1-1 memory copy operations? A bit like scatter-gather except there's no gather :).
04:04:32 <ddarius> "Scatter" ?
04:04:57 <Eduard_Munteanu> I thought about that, but I wasn't sure. Also scatter-scatter :)
04:06:01 <Eduard_Munteanu> It's basically a bunch of memcpys that are related in some way, and submitted as a single unit, but the affected memory areas are discontiguous.
04:06:07 <Eduard_Munteanu> (on the whole)
04:07:03 * ddarius sees an add for some kind of software, "It's 1AM.  Do you know what your QA team is doing?"
04:07:29 <ddarius> Hopefully, they're sleeping, and at any rate, who the heck needs to know what the QA team is doing at 1AM?
04:09:32 <mm_freak> Eduard_Munteanu: do you literally mean "memory copy operations"?  or just conceptually?
04:10:21 <Eduard_Munteanu> mm_freak: literally... well in this context it's moving data from system memory to the GPU, but it probably doesn't matter.
04:11:00 <ddarius> @google "scatter-scatter"
04:11:01 <lambdabot> http://www.facebook.com/pages/Scatter-Scatter/163692673643023
04:11:01 <lambdabot> Title: Incompatible Browser | Facebook
04:11:05 <mm_freak> Eduard_Munteanu: the question is, is it hardware bound or do you want transactional memory?
04:12:24 <Eduard_Munteanu> mm_freak: I'm thinking the thing I'm searching a name for is just a bunch of memcpys. If an upper layer does synchronization or anything else, that's something else.
04:12:32 <Eduard_Munteanu> (it will do)
04:13:14 <mm_freak> well, STM is not hardwarebound…  you can't use it to copy stuff between main memory and GPU memory
04:13:38 <Eduard_Munteanu> Ah, this isn't really a Haskell-related question, TBH.
04:14:25 <mm_freak> well, STM in general could do this i suppose
04:14:27 <Eduard_Munteanu> The idea is the destination is memory-mapped so the actual mechanism is just a memcpy.
04:14:46 <Eduard_Munteanu> Yeah, I guess so.
04:15:35 <mm_freak> well, doing this in a transactional manner is probably difficult, because the underlying file/whatever could get written before you get a chance to roll back
04:16:26 <Eduard_Munteanu> Ah, in this case the caller is supposed to take care of locking.
04:16:46 <Eduard_Munteanu> (and mapping the buffers into memory etc.)
04:17:00 <mm_freak> you just want locking?  i thought you want transactional behaviour
04:18:01 <ddarius> mm_freak: No, you just assumed that from nowhere.
04:18:16 <Eduard_Munteanu> Nah, I just want a name for an API that allows you to queue a bunch of memcpys then execute it. Like preadv() does for scatter-gather I/O.
04:18:34 <mm_freak> i guess i misinterpreted this: "and submitted as a single unit"
04:18:58 <mm_freak> i now see what you want
04:19:19 <mm_freak> and now "scatter-gather" makes sense, too =)
04:20:14 <mm_freak> would certainly be an interesting thing to implement, but i don't know anything ready-made
04:21:38 <Eduard_Munteanu> Ah, that's alright, I'm writing that myself anyway, I just figured I should ask if there's an established terminology for this sort of stuff.
04:21:54 <mm_freak> Eduard_Munteanu: the point being that it merges neighbouring/overlapping memcpys?
04:23:45 <ddarius> mm_freak likes to overcomplicated things.
04:23:58 <Eduard_Munteanu> mm_freak: it doesn't really need to do anything to those memcpys, it just runs them. E.g. it takes a list of (source, destination, length) and does the copying. Of course, a higher layer would take care of locking and synchronizing before/after in an efficient manner.
04:24:55 <Eduard_Munteanu> The idea is mostly code cleanup rather than fundamental changes.
04:26:32 <Eduard_Munteanu> But the structures/primitive would provide an unified interface even for that higher level API (the one that specifically does memory->GPU transfers).
04:26:34 <mm_freak> ddarius: it just seems natural to me
04:27:51 <mm_freak> Eduard_Munteanu: i guess that sounds like a small Put-like monad
04:28:57 <Eduard_Munteanu> Heh, though I wouldn't name it that way in a C codebase :D
04:31:32 <mm_freak> ah, it's C, ok =)
04:32:14 <mreh> would anyone recommend StdGen for making anti-CSRF tokens?
04:32:54 <mreh> the problem is that an attacker might try to predict the CSRF token of the user they are targeting
04:33:34 <ddarius> If you are going to bother dealing with this, you might as well do it appropriately.
04:33:46 <mreh> would StdGen make it easy to guess the whole token if you got the first character right?
04:34:27 <mm_freak> mreh: StdGen is generally easy to predict
04:34:33 <mm_freak> use the aes-cprng package
04:34:47 <Eduard_Munteanu> Guessability goes inverse to entropy.
04:35:32 <Eduard_Munteanu> If you use a small seed, then the attacker just needs to guess that seed.
04:36:12 <mreh> Eduard_Munteanu: i could seed it from /dev/random
04:36:24 <mm_freak> mreh: aes-cprng provides a simple deterministic interface which, depending on your paranoia, might suffice…  if you want a nondeterministic CSPRNG, you should use the interface provided by the Crypto-API package
04:37:05 <mreh> mm_freak: i'm assuming my attackers wont have large amounts of cryptographic training :)
04:37:12 <mreh> i hope that's not a bad assumption to make for now
04:37:31 <mreh> otherwise i'll invest in TRNG hardware
04:37:39 <mm_freak> seeding it from /dev/random suffices most of the time, even when you expect them to be trained =)
04:37:58 <exFalso> hey guys, do you know if there's a way of "instrumenting" ghci's IO monad with monad transformers?
04:38:17 <mm_freak> exFalso: could you give an example?
04:38:18 <Eduard_Munteanu> mreh: I'm just saying the PRNG won't make guessing more difficult, only more entropy can do that.
04:38:18 <mreh> exFalso: instrumentation code?
04:38:33 <exFalso> for example putting a Reader on top
04:38:48 <exFalso> so you can just say "ask"
04:38:51 <Eduard_Munteanu> (at least in the standard cryptanalytic sense)
04:39:01 <mm_freak> exFalso: if you want to avoid Reader and your environment is application-global, then you can use a global IORef
04:39:08 <mm_freak> not a nice way, but it works
04:39:18 <mreh> i was going to use /dev/urandom, but that's too slow it seems
04:39:33 <mm_freak> exFalso: otherwise i suggest using ReaderT or even simply pass the environment around
04:39:41 <exFalso> i would like to use reader
04:39:46 <Eduard_Munteanu> mreh: urandom is a PRNG already
04:40:00 <exFalso> its just that i dont know how to do it without running the reader everytime i type a command
04:40:05 <mreh> Eduard_Munteanu: seeded from /dev/random right?
04:40:26 <Eduard_Munteanu> Yeah, it just doesn't block when you're out of entropy.
04:40:28 <mm_freak> exFalso: what's the scope of the environment…  should it be available to your entire application?
04:40:40 <mm_freak> exFalso: or do you keep writing runReaderT everywhere?
04:41:00 <mm_freak> exFalso: or is it just GHCi?
04:41:03 <exFalso> no, this is just for ghci that is the interpreter
04:41:10 <Eduard_Munteanu> In contrast, /dev/random gives you just entropy.
04:42:00 <mm_freak> exFalso: i see…  well, you can simplify things by writing convenience functions either in your source code or in GHCi
04:42:06 <mreh> my entropy supplies are fairly low where I am :(
04:42:15 <zzo38> When writing a Haskell program, I got an error message "<interactive>: out of memory"
04:42:31 <exFalso> yes but i was wondering whether there is support for this:)
04:42:49 <mm_freak> exFalso: no, GHCi doesn't know anything about monad transformers =)
04:43:03 <zzo38> This is the program do you know what is wrong with it?   http://sprunge.us/LJeL
04:43:22 <exFalso> because the way i understand it is that a ghci session is a big IO do block
04:43:42 <mm_freak> zzo38: could you make a paste out of the relevant parts?  that's an awful lot to read
04:44:24 <mm_freak> exFalso: more or less
04:44:29 <zzo38> mm_freak: That is difficult because most of the program is used. However, I can tell you, it is the "withDVI" function that causes that error.
04:45:19 <mm_freak> zzo38: does it work when you compile it?  perhaps with -O?
04:45:26 <exFalso> ok i'll go with the helpers, thanks!
04:45:41 <zzo38> mm_freak: I have not tried. I just used GHCi so far.
04:45:50 <zzo38> Maybe I will try that.
04:46:10 <Eduard_Munteanu> zzo38: erm, did you narrow it down a bit?
04:46:11 <mm_freak> zzo38: you might be assuming some optimizations, which the compiler performs, but the interpreter doesn't
04:46:40 <zzo38> I don't know what optimizations there are in Haskell, anyways.
04:46:47 <Eduard_Munteanu> -O pretty much adds correctness, TBH.
04:46:47 <mm_freak> zzo38: a lot =)
04:46:51 <mm_freak> in GHC
04:47:01 <Eduard_Munteanu> @src sum
04:47:01 <lambdabot> sum = foldl (+) 0
04:47:20 <ddarius> Eduard_Munteanu: That's a horrible perspective.
04:47:49 <zzo38> Eduard_Munteanu: All I know is the "withDVI" function results in out of memory. Functions "loadFont" and "typesetSimpleString" (which are not used in "withDVI") work OK.
04:48:16 <zzo38> If it doesn't work without optimization, how can I test it in GHCi?
04:48:42 <Eduard_Munteanu> ddarius: why horrible?
04:49:14 <mm_freak> Eduard_Munteanu: it doesn't really add correctness, but it can improve the asymptotic behaviour of your program
04:49:41 <mm_freak> zzo38: first find out whether and which optimization is responsible
04:49:49 <ddarius> Eduard_Munteanu: Your code should run in reasonable space and time without optimizations.  You definitely should not be relying on optimizations to make up for broken or horribly inefficient code and they usually won't.
04:50:14 <zzo38> ddarius: Yes, that is what it seem to me, how it should be.
04:50:22 <zzo38> mm_freak: OK.
04:50:26 <Eduard_Munteanu> I don't remember, does Prelude define 'sum' like that as well?
04:50:47 <mreh> @src sum
04:50:47 <lambdabot> sum = foldl (+) 0
04:50:47 <Eduard_Munteanu> If so, then it's a correctness issue for Prelude.
04:50:51 <mm_freak> zzo38: /which/ optimization it is can be difficult to answer
04:50:58 <mreh> oh haha
04:51:05 <ddarius> Eduard_Munteanu: Yes, the Prelude is wrong.  There are a lot of such things in the Prelude.
04:51:08 <mreh>  @src just sit in some file somewhere i forgot
04:51:19 <zzo38> mm_freak: Yes, that is what I thought.
04:51:19 <mm_freak> zzo38: but it's mostly fusion, strictness analysis, sharing, etc.
04:51:22 <ddarius> mm_freak: I don't think zzo38 was saying it worked with optimization.
04:51:42 <mreh> sum should definitely be foldl unless you want to obtain partial information from your sum
04:51:53 <mreh> i'm not sure if that's possible with an instance of Num
04:51:57 <ddarius> mreh: It definitely should not be foldl.  It should be foldl'.
04:52:03 <mm_freak> sorry, i'm often thinking five steps ahead =)
04:52:11 <mm_freak> i wonder why i'm so bad at chess
04:52:24 <ddarius> mm_freak: Because you are thinking five steps ahead in a different game.
04:52:26 <mauke> thinking ahead /= jumping to conclusions
04:52:29 <Eduard_Munteanu> Heh.
04:52:36 <mm_freak> =)
04:52:42 <mreh> ddarius: and definitely not foldr
04:53:31 <ddarius> mreh: foldr would be wrong in most cases, but there are times when you'd want a foldr sum.  The times when you'd want a foldl sum are extremely rare.
04:53:49 <zzo38> Is there anything in my program that seems wrong to you?
04:54:11 <mm_freak> zzo38: did you try compiling with optimization?
04:54:13 <mreh> how do you get information out from a foldr sum?
04:54:20 <mreh> the type is a -> a -> a
04:54:35 <mm_freak> mreh: foldr sum can give you information before the sum is calculated
04:54:43 <mm_freak> foldl' can't do that
04:54:57 <mreh> i know that much
04:55:35 <mm_freak> mreh: consider '+' on something that is not necessarily a simple number
04:55:41 <mauke> e.g. Expr
04:55:56 <zzo38> mm_freak: I think I will do so tomorrow. And tell you the result tomorrow. For now I will sleep. OK
04:56:12 <mreh> mm_freak: it's lack of imagination of my part, I can't think of a Num instance that would yield such a value
04:56:19 <mreh> i'm sure I could make one
04:56:32 <mauke> > 1 + 2 :: Expr
04:56:32 <lambdabot>   1 + 2
04:56:47 <mreh> oh
04:56:48 <mauke> > foldr (+) 0 [a,b,c]
04:56:49 <lambdabot>   a + (b + (c + 0))
04:57:36 <Eduard_Munteanu> foldr needs a non-strict folding operation to do that, though.
04:58:03 <mreh> anyway, don't we have sum'?
04:58:15 <Eduard_Munteanu> Not really.
04:58:29 <mm_freak> mreh: as long as your addition is nonstrict in its second argument, foldr makes sense
04:58:29 <Eduard_Munteanu> There's foldl' (+) 0
04:58:40 <mauke> > a + undefined
04:58:40 <mm_freak> it could even perform better than foldl
04:58:41 <lambdabot>   a + *Exception: Prelude.undefined
04:58:55 <mm_freak> foldl → foldl'
04:58:58 <mreh> Prelude.sum is foldl, that sucks
05:00:15 <alistra> Prelude.sum'
05:00:24 <mauke> > deriv (id^2 + id) x
05:00:26 <lambdabot>   1 * x + x * 1 + 1
05:00:34 <mauke> > reduction $ deriv (id^2 + id) x
05:00:35 <lambdabot>   Not in scope: `reduction'
05:00:38 <mauke> :-(
05:00:46 <alistra> > deriv
05:00:47 <lambdabot>   Overlapping instances for GHC.Show.Show
05:00:48 <lambdabot>                              ((Data...
05:00:52 <alistra> @type deriv
05:00:53 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
05:01:06 <alistra> @src Dif
05:01:06 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:01:13 <alistra> @src deriv
05:01:14 <lambdabot> Source not found. You speak an infinite deal of nothing
05:08:15 <savask> Hi, all. In my simple parallelism test (with par function), garbage collection time grows when I increase the number of threads. Is that normal, or I have a "leak" in my program?
05:08:59 <Axman6> garbage collection is more difficult when you have multiple threads
05:10:37 <Axman6> savask: also, if you're using par wrong, you'll be just giving the GC more data to collect, and not gaining any extra parallelism
05:10:55 <savask> What is wrong?
05:11:54 <savask> It looks magic for my not-prepared mind, that when you use more threads, GC must collect more garbage.
05:12:20 <mm_freak> savask: are you using pseq, too?
05:12:25 <savask> Yes.
05:12:33 <mm_freak> could you paste your code?
05:12:52 <hpaste> savask pasted “Levenshtein distance” at http://hpaste.org/54275
05:13:07 <ddarius> savask: Everytime you say par GHC allocates a spark.  That spark needs to be GCed.
05:13:42 <ddarius> par doesn't cause more threads to exist.
05:14:19 <savask> ddarius: A spark? And why it doesn't? Even when I pass -N2 to runtime options?
05:14:38 <mm_freak> savask: you can have 500 sparks distributed over two OS threads
05:15:00 <ddarius> savask: The -N option does add more threads, but par doesn't.
05:15:16 <savask> Okay.
05:16:13 <savask> ddarius: But par shows a good place for parallelization, doesn't it?
05:17:00 <ddarius> savask: It tells GHC to make a spark which GHC may or may not execute in parallel depending on processor availability and the parallelism inherent in the problem.
05:17:41 <ddarius> savask: GC time will go up the larger the live set.
05:18:10 <savask> ddarius: Ah. So a spark is a signal for a desirable parallelization?
05:19:45 <savask> Sparks are freed by GC too?
05:21:01 <savask> Oh, sorry, I was already told about that.
05:21:46 <mm_freak> savask: yes, sparks are sort of an annotation:  this value can be calculated in parallel
05:22:04 <Eduard_Munteanu> It's a hint, in a way.
05:22:24 <savask> Does par make sparks even if I let program to use only one thread?
05:22:36 <savask> *s/to//
05:22:42 <mm_freak> savask: if you compile with -threaded, yes
05:22:49 <savask> Hmm.
05:23:32 <savask> But why GC time grows when I increase threads number? Spark count should be the same as with one thread.
05:23:42 <mm_freak> usually sparks are cheap…  even with many sparks you should see somewhere between 150% and 190% performance with two threads
05:23:56 <mm_freak> but sparks can get expensive, when they contain only very cheap operations
05:24:13 <mm_freak> you wouldn't spark a simple addition, for example
05:24:43 <mm_freak> savask: it might be because GHC-produced executables perform parallel GC
05:25:06 <savask> Aah.
05:25:09 <ddarius> savask: The ultimate number of sparks would be the same, but the rate at which they were allocated would be different.  Also, as I said, you are changing the size of the live set.
05:25:35 <ddarius> There are also cache coherency issues.
05:26:13 <savask> It might be a dumb question, but what is the live set? A number of sparks which were let to create threads?
05:26:30 <ddarius> The amount of memory that is live.
05:26:49 <ddarius> I.e. would not be garbage collected when the garbage collector ran.
05:27:02 <savask> More threads -> more memory used?
05:27:48 <ddarius> Not necessarily, but in most cases more threads means more roots means more things reachable at a time.
05:28:21 <savask> So GC can't collect them?
05:28:25 <ddarius> Correct.
05:29:08 <savask> And them puff - and it collects thing at once, which produces an incrementation of GC time?
05:29:12 <savask> *then
05:29:25 <savask> *things
05:30:08 <ddarius> GC time is usually proportional to either total heap size or the size of the live set.  Also, the less memory that is freed in a GC the more times you will GC, so GCs take longer and happen more often.
05:30:52 <savask> How can I make GC run less often?
05:31:25 <ddarius> First see if it is running more often or just taking longer.  There's a flag you can pass that will cause the executable to output GC statistics (and also spark statistics.)
05:31:29 <Eduard_Munteanu> savask: even if they're collected immediately, in extreme cases it could generate lots of garbage, and lots of work for the GC among other things.
05:32:18 <savask> ddarius: Probably you mean -sstderr
05:32:22 <Eduard_Munteanu> savask: you can tune it, e.g. increase minimum heap size.
05:32:24 <savask> Eduard_Munteanu: They?
05:32:39 <Eduard_Munteanu> The sparks. But generally, any sort of unnecessary garbage you produce.
05:32:45 <savask> Ah.
05:33:23 <Eduard_Munteanu> -s should give you a hint as to how much time the GC wastes (e.g. the productivity)
05:33:23 <savask> I've tried to make my function as strict as I can.
05:33:47 <Eduard_Munteanu> You should probably paste some code if you're looking for optimization advice.
05:33:56 <ddarius> Eduard_Munteanu: He did.
05:34:05 <Eduard_Munteanu> Oops.
05:34:12 <savask> Eduard_Munteanu: http://hpaste.org/54275
05:36:12 <Eduard_Munteanu> First, maybe you could use unboxed arrays.
05:37:13 <ddarius> Eduard_Munteanu: The original question was "why does GC time increase as I increase the number of threads?"
05:37:14 <savask> Hmm, okay, I'll try.
05:38:05 <mike-burns> Does Gtk2Hs support GTK3?
05:38:15 <dcoutts> mike-burns: not yet
05:38:24 <Eduard_Munteanu> Then that 'd i j a1 a2' could use some memoization/sharing I guess.
05:38:26 <ddarius> Will its name change to Gtk3hs?
05:38:32 <dcoutts> but it's probably not a lot of work if you want to have a go
05:38:45 <dcoutts> ddarius: no it's gtk -> hs, gtk2hs
05:39:08 <savask> Eduard_Munteanu: Probably it could, I just wanted to test parallelization on this silly algorithm.
05:39:15 <mike-burns> It would be a lot of work for me, but I'll look into it right now.
05:39:23 <dcoutts> ddarius: but it'll no longer be a pun :-(
05:39:31 <Eduard_Munteanu> Ah.
05:39:36 <mike-burns> dcoutts: Also, thanks a whole bunch for maintaining Gtk2Hs.
05:39:48 <dcoutts> mike-burns: I don't maintain it anymore :-)
05:39:55 <dcoutts> occasionally help out, that's all
05:42:30 <Axman6> savask: a few things to speed up your code. firstly, like Eduard_Munteanu said, unboxed arrays may be faster. also using unsafeIndex instead of (!) avoids unnecessary bounds checking (but you then must make sure you never index outside the bounds of the array). you might also consider passing along an accumulating parameter instead of doing d i (j-1) a1 a2 + 1.
05:43:34 <ddarius> I guess today is the day where people don't listen.
05:43:38 <savask> Axman6: But that will change the algorithm. And my goal is to make a parallelized version of this version.
05:43:58 <Axman6> so, instead you'd use d' n i j a1 a2 | ... where fir = d' (n+1) i (j-1) a1 a2; thd = d' (n+m (a1 ! i) (a2 ! j)) (i-1) (j-1) a1 a2
05:44:04 <Axman6> how will it change the algorithm?
05:44:17 <ddarius> Axman6: [08:56] <savask> Eduard_Munteanu: Probably it could, I just wanted to test parallelization on this silly algorithm
05:45:08 <Axman6> well, he mentioned making the code as strict as he could, and this is a better way to go about it
05:45:27 <RaptorRarr> ddarius: Only today?
05:46:42 <ddarius> RaptorRarr: No, but today has seemed especially bad.
05:46:44 <Axman6> savask: what size strings are you inputting into this code?
05:47:10 <savask> Axman6: My test strings are: whagoodday whaniceweather
05:47:46 <Axman6> you're unlikely to get much speedup at all from such short strings i think
05:48:28 <savask> Bigger strings are processed too long.
05:48:47 <Axman6> and the computations you're trying to parallelise will likely be too small to do much good
05:49:20 <Axman6> savask: as far as how you use par and pseq, you're doing it right though
05:49:23 <savask> Axman6: Why? d is rather expensive function.
05:51:01 <Axman6> how expensive? how long does it take to execute with those strings?
05:52:27 <ddarius> Axman6: d calls itself recursively three times.  There's a lot of overlap, but as written, there is no sharing.
05:52:44 <ique> If I have a type:  data WrapDouble = FirstKind Double | SecondKind Double     How can I make it possible to do math on these? Like (FirstKind 3.2) - (SecondKind 2.1)
05:52:49 <Axman6> savask: also, you don't need to pass around a1 and a2, they could just be defined once in the same let expression as m and n
05:53:27 <Axman6> ique: make an instance for Num WrapDouble
05:56:20 <ique> Axman6: and I'd have to define every combination for all the functions then right?
05:56:56 <Axman6> sure
05:57:03 <ddarius> ique: One way or another you do unless you want partial functions which would be evil.
05:57:21 <ique> Alright, thanks :)
05:58:09 <Axman6> actually, you could define it better if you had a function: foo :: (Double -> Double -> Double) -> WrapDouble -> WrapDouble -> WrapDouble; then most of the instances will be: (+) = wrapDouble (+)
05:58:26 <ddarius> Depends on his semantics.
05:58:48 <Axman6> but it all depends on what you want to happen when you say add (FirstKind x) to (SecondKind y)
05:58:49 <savask> Axman6: ~10 sec. with 2 threads.
05:59:44 <Axman6> takes 2.9 on my machine :\
06:00:01 <savask> A good one :-D
06:01:25 <ique> Axman6: I always want to return FirstKind (x+y) for all operations.. the first kind is a non-fixed value and the second kind is a fixed value, so if you do any operation between any values involving a non-fixed one, it returns a non-fixed one
06:02:19 <Axman6> ique: then the foo unction i mentioned above would work well
06:02:43 <ique> Axman6: i'll try that out then!
06:03:22 <ddarius> ique: Why do you want to do this anyway?
06:04:25 <ique> ddarius: it wasn't my choice from the beginning but the reasoning is that I need to do different calculations based on if this double is a non-fixed value or a fixed value… so later in a function i pattern match which kind it is and do different things
06:05:35 <Axman6> savask: with those inputs, what result are you supposed to get? 10?
06:05:46 <savask> Yes.
06:05:58 <Axman6> ok, good, my conversion did work properly =)
06:06:13 <savask> Oh, what you did?
06:06:22 <Axman6> but, no real speed improvement. moving the arrays out made a small difference
06:07:08 <ddarius> Axman6: I wouldn't expect that to make much of a difference.
06:07:44 <Axman6> no. i was hoping making it semi-almost-but-not-really-at-all tail recursive might help, but no
06:10:00 <ddarius> To make this actually tail recursive, you'd have to "externalize" the fairly significant structure that is implicitly represented on the stack.  Ideally, by flattening it to an array and exploiting dynamic programming.
06:11:49 <Axman6> hmm, not sure how you'd use dynamic programming for this
06:12:14 <Axman6> actually, it might be quite easy with haskell and using Array indexed over i,j
06:12:21 <ddarius> Yes.
06:12:36 <ddarius> Dynamic programming is very easy to do with a lazy array in Haskell.
06:13:03 <hpc> "you could have invented dynamic programming"?
06:13:06 <ddarius> Basically there are three "fingers" pointing into an i by j array accumulating min values.
06:13:18 <savask> By the way, if an array is unboxed, GC won't care about it, right?
06:13:31 <ddarius> savask: Why do you think that?
06:13:57 <savask> Cause I thought that GC cares about "wrapped" values only.
06:14:02 <ddarius> Why?
06:14:43 <Axman6> savask: savask the values in the array won't get GC'd, but the whole array will once it's not visible
06:14:52 <ddarius> GC cares about pointers.  It won't traverse the elements looking for pointers (hopefully) because it knows there aren't any in the data of the unboxed array, but the array still takes memory.
06:14:56 <savask> ddarius: Because you (for my mind) can't evaluate a part of an unboxed array, so you can't free a part of it either.
06:15:08 <ddarius> savask: That's true of all arrays.
06:15:29 <ddarius> But yes, you can't free the elements of an unboxed array because there is nothing to free.
06:16:47 <savask> Hmm, I don't really understand. Are elements of an unboxed array always evaluated?
06:16:54 <ddarius> Yes.
06:17:18 <savask> And they can't be freed too?
06:17:30 <ddarius> There's nothing to free.
06:17:37 <ddarius> Other than the entire array itself.
06:17:39 <savask> Okay, now I see.
06:17:50 <savask> That's logical.
06:18:25 <Axman6> savask: an unboxed array is like a C array. a Haskell array of Ints would be like int ** (an array of int pointers), whereas an unboxed array is just an array of ints
06:18:28 <ddarius> An unboxed array of Ints, say, is a bunch of Ints packed (more or less) contiguously plus some meta-data, e.g. length.  This is just like a C array.
06:18:29 <Axman6> (my C is failing me)
06:18:29 <savask> Hmm, with unboxed arrays GC time is slightly smaller.
06:19:27 <ddarius> savask: It doesn't have to traverse the array looking for pointers, but the arrays are pretty short anyhow, so that's not a big deal and also newer GHCs use card-marking to minimize GC time for arrays.
06:20:12 <ddarius> It also probably minimized the amount of garbage.
06:20:23 <ddarius> and the size of the live set.
06:21:22 <savask> Probably. I think that GC were to free traversed parts of an array, and now it doesn't need to do that.
06:22:50 <ddarius> As long as the array is live, all the elements in it are live, and your arrays are live for pretty much the entire time.
06:23:32 <Axman6> bloody hell, the dynamic programming version is super fast :O
06:23:57 <savask> ddarius: But when it goes deeper, last elements are not needed.
06:24:09 <savask> Or threads doesn't let GC do it's work well?
06:24:19 <Axman6> "0m0.004s" according to time, but that's almost certainly noise
06:24:23 <ddarius> savask: GC approximately liveness by reachability.
06:24:30 <ddarius> s/approximately/approximates/
06:25:05 <ddarius> Axman6: Yes, there is a ton of overlap.  It's like naive fib versus the zipWith fib.
06:25:38 <ddarius> Axman6: You are looking at roughly 3^n to n^2.
06:25:43 <Axman6> yeah
06:26:28 <Axman6> even with the background i have in the theory, it's still always exciting when you rewrite an algorithm and get such a massive speedup
06:26:39 <savask> Well, thanks for help. Threaded version is faster than not-threaded, and now I understand GC a little. Time for dynamic programming :-)
06:29:06 <Axman6> savask: feel free to ask questions about how to use arrays for dynamic programming. it's much more elegant in haskell, because you don't have to explicitly specify the evaluation order, laziness takes care of everything for you
06:30:08 <savask> Yeah, I know. Memorization and so on.
06:31:05 <mreh> memoization == memorization?
06:31:18 <savask> Oh, yes.
06:31:35 <savask> It's easy to misuse these words.
06:31:50 <mreh> i'm genuinely not sure why memorization isn't used
06:32:32 <Axman6> hmm, there should be a function predefined for writing things like this. something with type Ix ix => (ix -> Array ix a -> a) -> ix -> [(ix,a)] -> Array ix a
06:33:00 <ddarius> @wn memoization
06:33:01 <lambdabot> No match for "memoization".
06:33:30 <Axman6> i think that's right. the list is the initial values that are needed to initialise the array, and then the function is called for all undefined elements in the array
06:34:16 <Axman6> the order of those arguments could probably be changed
06:34:37 <ddarius> Axman6: Can't you just discard the list parameter?  Can't the function parameter already do it all?
06:35:29 <Axman6> it could, but i have a feeling that would be more annoying. the function passed could be a lot easier to define
06:35:48 <Axman6> i guess it depends on how much the initialisation is a pain in the arse or not
06:36:04 <Axman6> in this example, it would be fine to just use the function
06:36:30 <ddarius> Axman6: Well, I could implement your version on top of the simpler (and probably faster) version.
06:36:52 <Axman6> yeah
06:37:00 <Axman6> i might give that a go, see how it works
06:43:18 <ddarius> :t dp bnds f = let a = runSTArray (do ma <- newArray_ bnds; mapM_ (writeArray ma . f a) (range bnds); return ma) in a
06:43:19 <lambdabot> parse error on input `='
06:43:33 <Axman6> makeArr :: Ix ix => (Array ix a -> ix -> a) -> (ix,ix) -> Array ix a
06:43:34 <Axman6> makeArr f ix = let arr = array ix $ map (\i -> (i,f arr i)) (range ix) in arr
06:43:38 <ddarius> :t let dp bnds f = let a = runSTArray (do ma <- newArray_ bnds; mapM_ (writeArray ma . f a) (range bnds); return ma) in a in dp
06:43:39 <lambdabot> Not in scope: `runSTArray'
06:43:39 <lambdabot> Not in scope: `newArray_'
06:43:39 <lambdabot> Not in scope: `writeArray'
06:43:45 <ddarius> Bugger you lambdabot.
06:43:59 <Axman6> what's the point of using ST?
06:44:31 <ddarius> Axman6: To avoid having to go through lists, though I'd need to fuse the mapM_ and range.
06:44:35 <Axman6> also, I have a feeling ST isn't lazy enough for that to work. i'd like to be wrong though
06:44:54 <ddarius> An STArray is an array of lazy values.
06:45:17 <ddarius> Admittedly, the let a = runSTArray (... a ...) is probably stretching it.
06:45:26 <Axman6> sure, but is the conversion from an STArray to an Array lazy enough to allow... yeah =)
06:45:34 <ddarius> Only one way to find out.
06:48:01 <Axman6> ah, it feels good to be writing fast haskell again. it's been too long
06:48:32 <Axman6> s/fast// really haven;t had much chance to write haskell for several months :(
06:49:03 <Axman6> i'm considering writing some kind of compiler that uses LLVM. not sure what sort of language to implement though
06:49:15 <savask> ddarius: How is your function used?
06:49:17 <ddarius> dp bnds f = let a = runSTArray (do ma <- newArray_ bnds; mapM_ (\ix -> writeArray ma ix (f a ix)) (range bnds); return ma) in a
06:49:45 <ddarius> dp (0,100) (\fib n -> if n < 2 then 1 else fib!(n-1)+fib!(n-2))
06:49:48 <ddarius> Works fine.
06:50:00 <Axman6> :o i'm quite surprised
06:50:03 <Axman6> how very odd
06:50:06 <cgroza> Hello everyone. I am experimenting with wxHaskell, and I am trying to call infoDialog with no parent window. Is there an equivalent to wxWidgets NULL pointer in this case?
06:50:14 <ddarius> Now fuse the range and use unsafeWriteArray and it should be reasonably fast.
06:50:18 <Axman6> hmm, is it possible that could lead to non-determinism?
06:50:42 <Axman6> hmm, no, since each index only gets written to once
06:50:46 <ddarius> Exactly.
06:51:43 <Axman6> hmm, what would happen if you happened to write to the same location twice when accessing different parts of the array. (not with that code, but recursive code like that)
06:52:18 <ddarius> Axman6: The last one would win.
06:52:42 <ddarius> If I had a mapM_ writeArray . g after that, then I would have an array with g thunks in it rather than f thunks.
06:53:19 <ddarius> The array is fully allocated and populated (with thunks) before any of the element evaluation happens.
06:53:33 <Axman6> sure.
06:53:41 <cgroza> Never mind. I have found it. It is caled objectNull.
06:55:04 <Axman6> but say you wrote some code that created an Array from an STArray, and when reading index 0, a 1 was written to position 0, and when reading index 1, a 2 was written to position 0. then doing arr ! 0, arr ! 1, arr ! 0 might mean the first and third calls could return different results
06:55:09 <Axman6> maybe not
06:55:11 <Axman6> but
06:55:14 <Axman6> hmm
06:55:16 <Axman6> hmm
06:55:55 <Axman6> it feels like the recursive definition somehow allows you to poke a hole in the ST abstraction
06:55:58 <ddarius> Axman6: No writes happen when you evaluate the elements.
06:56:54 <ddarius> To have reading index 1 write to index 0 you'd have to be doing some unsafePerformIO-like stuff.
06:57:55 <Axman6> in that definition yes. but in some other piece of code, maybe you might get values mutating in the array which should be pure
06:58:26 <Axman6> also, that definition assumes the code will work when run in the order returned by range bnds
06:58:56 <Axman6> which won't always be the case. I think my version is a better general solution, even if it is slower (it may not be, not sure)
06:59:16 <Axman6> though I assume that the array function uses lookup
07:00:18 <mm_freak> Axman6: for STArray think of writeArray as writing thunks of unevaluated code…  this is a side effect, but the evaluation, which can happen outside of ST, is not
07:01:14 <mm_freak> for every runSTArray there is an equivalent listArray
07:01:29 <ddarius> Axman6: No it doesn't.
07:01:51 <ddarius> Again, all the writes have happened before -any- element is evaluated.
07:02:00 <ddarius> The element evaluation doesn't depend on the order of the writes.
07:02:24 <Axman6> but what happens when the function being used to produce the elements of the array references the pure Array, and multiple writes occur to the same locations
07:02:48 <ddarius> Axman6: All the writes occur before the pure array is made, so the last write would win.
07:03:43 <Axman6> oh, right, i think i get how it works. i was completely forgetting about thunks (yes, depsite you mentioning them, it's 2AM).
07:03:51 <Axman6> ok, i'm happy now. it all makes senswe
07:03:53 <Axman6> -w
07:03:56 <Jafet> Control.Monad.ST.Concurrent
07:04:02 <mauke> .Fix
07:04:14 <ddarius> At any rate, this is essentially how 'array' is implemented.
07:04:24 <mm_freak> again, there is a listArray variant for every runSTArray
07:04:51 <cgroza> Can I create a lamda that takes no arguments?
07:05:03 <mm_freak> cgroza: that wouldn't be a lambda
07:05:04 <Axman6> that's not a lambda then, it's just a value
07:05:15 <ddarius> mm_freak: Going through lists tends to be one of the biggest bottlenecks in Haskell array code.  It also doesn't really provide much here.
07:05:22 <Axman6> you can create a lambda that ignores its arguments though
07:05:28 <Axman6> \_ -> foo
07:05:32 <cgroza> Thanks
07:05:46 <Jafet> \_ -> is also known as const.
07:05:55 <Axman6> cgroza: that's also called const foo
07:05:57 <Axman6> bleh
07:06:06 <mm_freak> cgroza: what's the purpose?
07:06:31 <cgroza> mm_freak: I want to make the close event in wxHaskell tod o 2 things.
07:06:37 <paolino> ok, I take some definition out of a let and put those in a separate function , but now this function needs impredicatives to compile.
07:06:46 <mm_freak> cgroza: ok, i'm out then
07:06:58 <cgroza> mm_freak: this is what I have now, but the types don't match:     set win [on closing := ((salute >>) . wxcAppExit) ]
07:07:00 <Axman6> savask: how's the generic programming version going?
07:07:17 <mm_freak> cgroza: sorry, no experience with wx
07:07:36 <cgroza> mm_freak: thanks anyway.
07:08:09 <savask> Axman6: Ehm, generic?
07:08:33 <savask> You mean dynamic?
07:08:39 <Axman6> yeah, that one -_-
07:08:45 <savask> Done :-)
07:08:48 <Axman6> like i said to ddarius, it's past 2AM >_<
07:08:49 <mm_freak> ddarius: it's just that listArray reads a lot like an ST loop, when used with sharing
07:09:02 <Axman6> savask: how'd it go? care to share?
07:09:37 <savask> Axman6: Now I try to "go steps of great people" and create a function for easy dynamic programming too.
07:09:47 <Axman6> heh =)
07:09:49 <savask> I can hpaste it if you want.
07:09:52 <Axman6> sure
07:09:57 <Axman6> i'll show you mine too if you like
07:10:03 <paolino> Does this happen because each function is compiled separately  while inside the same let statement the compiler is more able to resolve typechecking ?
07:10:20 <mm_freak> paolino: could you paste?
07:10:25 <savask> Axman6: Of course.
07:10:53 <paolino> mm_freak: I haven't been able to make a simple case of it :-/, though I tried
07:10:56 <cgroza> mm_freak: I made it. I had to create a separate function.
07:11:04 <hpaste> savask pasted “New Levenshtein distance” at http://hpaste.org/54277
07:13:13 <hack_> Need help with your iphone, ipad, ipod touch and apple tx join are IOS chat on irc.silentspark.net #ios ( live view ) - ( http://is.gd/E9KShI )
07:13:50 <hpaste> Axman6 annotated “New Levenshtein distance” with “New Levenshtein distance (annotation)” at http://hpaste.org/54277#a54278
07:14:09 <Axman6> savask: ^^
07:14:21 <savask> Yeah, I'm looking.
07:15:09 <hpaste> paolino pasted “impredicatives vs let” at http://hpaste.org/54279
07:17:05 <paolino> mm_freak: if I use fromSelector instead of the let bindings, I need (forall  c . Routing c , forall c . Routing c) as output type of it
07:17:16 <savask> Axman6: Yours uses that cool function. I'd better put it in my piggy-bank, for good times :-P
07:17:48 <paolino> mm_freak: which needs impredicatives
07:19:56 <paolino> It's not a problem for me to let  them in (impredicatives), but I was wondering why a simple refactoring  is creating such need
07:20:31 <shurikas> there was a command on irc to get function name by it's type, right?
07:20:41 <shurikas> I need [[a]] -> [a]
07:20:51 <paolino> @hoogle [[a]] -> [a]
07:20:51 <lambdabot> Prelude concat :: [[a]] -> [a]
07:20:52 <lambdabot> Data.List concat :: [[a]] -> [a]
07:20:52 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:20:52 <Axman6> @hoogle [[a]] -> [a]
07:20:53 <lambdabot> Prelude concat :: [[a]] -> [a]
07:20:53 <lambdabot> Data.List concat :: [[a]] -> [a]
07:20:53 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:20:55 <shurikas> ah, thanks :D
07:23:00 <Axman6> @hoogle Ix ix => (Array ix a -> ix -> a) -> (ix,ix) -> Array ix a
07:23:00 <lambdabot> No results found
07:23:34 <paolino> Well, I was thinking that I couldn't refactor my code without impredicatives , and they may be gone in the future
07:27:31 <hpaste> paolino annotated “impredicatives vs let” with “impredicatives vs let (annotation)” at http://hpaste.org/54279#a54280
07:30:10 <aristid> Axman6: i think that is too hard for poor hoogle :D
07:30:58 <Axman6> yeah :(
07:30:59 <aristid> paolino: i love how your code mixes italian and english identifiers
07:31:07 <Axman6> I don't think it's defined anywhere though
07:31:32 <aristid> Axman6: what would it do?
07:31:42 <mauke> loeb?
07:31:45 <Axman6> makeArr :: Ix ix => (Array ix a -> ix -> a) -> (ix,ix) -> Array ix a
07:31:46 <Axman6> makeArr f ix = arr where arr = array ix $ map (\i -> (i,f arr i)) (range ix)
07:32:00 <Axman6> needs a better name
07:32:11 <Axman6> might be useful to have in Data.Array or something
07:32:15 <paolino> aristid: I know I shouldn't
07:32:28 <aristid> Axman6: i think that where doesn't bring any advantage, does it?
07:32:51 <aristid> :t \f ix -> array ix $ map (\i -> (i,f arr i)) (range ix)
07:32:53 <lambdabot> forall e a b c (a1 :: * -> * -> *). (Ix a, Arrow a1) => (((b -> c) -> a1 b c) -> a -> e) -> (a, a) -> Array a e
07:32:58 <Axman6> yes, it's needed to that f can use the array that it's being used to define
07:33:05 <Axman6> so that*
07:33:10 <mauke> http://blog.sigfpe.com/2006/12/tying-knots-generically.html
07:33:18 <Axman6> fuck that sentense was horrible
07:33:46 <aristid> Axman6: oh, i did not really see the inner arr at first :D
07:34:01 <Axman6> that's the important bit =)
07:34:10 <aristid> Axman6: i think for Vector there is such a function
07:36:52 <Axman6> aristid: any idea where?
07:38:16 <aristid> @hoogle constructN
07:38:17 <lambdabot> No results found
07:38:44 <aristid> Axman6: http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Generic.html#g:10
07:38:46 <Axman6> constructN :: Int -> (Vector a -> a) -> Vector a
07:39:08 <Axman6> interesting that it doesn't pass in the index as well
07:39:13 <aristid> hmm :)
07:39:33 <aristid> Axman6: maybe the lenght of the passed vector is the index?
07:39:36 <Axman6> oh i guess you'd just get the length of the vector being passed in
07:39:40 <Axman6> heh, yeah
07:46:44 <mm_freak> Axman6: when using the normal boxed Vector, 'generate' is probably better than constructN
07:48:10 <hpaste> ddarius annotated “New Levenshtein distance” with “New Levenshtein distance (annotation) (annotation)” at http://hpaste.org/54277#a54281
07:54:55 <hpaste> applicative annotated “New Levenshtein distance” with “New Levenshtein distance (annotation) (annotation) (annotation)” at http://hpaste.org/54277#a54282
07:56:53 * applicative can't think of anything clever to do with a levenshtein distance calculator.
07:57:08 <shurikas> map (\a -> map (\b -> round $ a ** b) [100]) [100]
07:57:14 <shurikas> this should return the same as 100**100, right?
07:57:39 <shurikas> ohh, without round it does...
07:58:05 <savask> ddarius: Your is 3 times faster than mine o_O
07:58:39 <shurikas> how to print 1.0e200 in a normal form?
07:58:49 <shurikas> like 10000000.......
07:59:34 <ddarius> @hoogle showGFloat
07:59:34 <lambdabot> Numeric showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
08:00:06 <ddarius> There are three or four functions like that in Numeric.  I forget what each does.
08:00:51 <applicative> > showGFloat (Just 22) 1.0e200 ""
08:00:52 <lambdabot>   "1.0000000000000000000000e200"
08:00:55 <shurikas> @hoogle Floating a -> Num a
08:00:56 <lambdabot> Warning: Unknown type Floating
08:00:56 <lambdabot> Prelude id :: a -> a
08:00:57 <lambdabot> Data.Function id :: a -> a
08:01:15 <shurikas> :T 100**100
08:01:25 <shurikas> >T 100**100
08:01:28 <shurikas> ehh...
08:01:52 <Axman6> :t 100*100
08:01:53 <lambdabot> forall t. (Num t) => t
08:01:55 <Axman6> :t 100**100
08:01:56 <lambdabot> forall t. (Floating t) => t
08:06:06 <ddarius> @hoogle unsafeIndex
08:06:07 <lambdabot> Data.Text.Array unsafeIndex :: Array -> Int -> Word16
08:06:07 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
08:06:33 <shurikas> still can't figure it out
08:06:34 <shurikas> :|
08:11:21 <shurikas> http://zvon.org/other/haskell/Outputprelude/RealFloat_c.html
08:11:36 <shurikas> none of these does what I need
08:11:58 <shurikas> I need a sum of digits in a float number
08:12:11 <shurikas> 10**100 should be just 1
08:12:41 <shurikas> Input: floatDigits 22.2
08:12:41 <shurikas> Output: 24
08:12:45 <shurikas> this should return 6 for me
08:12:47 <shurikas> :)
08:13:33 <ddarius> 1) Don't use ZVON, 2) why would you expect any of those to do what you want?, 3) I already suggested to look at the show?Float functions in Numeric.
08:14:11 <shurikas> I have no idea how those work :D
08:14:28 <ddarius> http://haskell.org/onlinereport/numeric.html
08:15:19 <dons> ?yow
08:15:19 <lambdabot> Couldn't find fortune file
08:15:23 <dons> :(
08:15:24 <heatsink> There's a tool for maintaining multiple versions of GHC+Cabal.  Does anyone here remember what it was called?
08:15:35 <copumpkin> omg it's dons
08:15:38 <copumpkin> he's still alive!
08:16:09 <shurikas> ehh....
08:16:14 <dcoutts> hey dons
08:16:15 <shurikas> why can't haskell be a bit easier :/
08:16:18 <mike-burns> heatsink: Is that cabal-dev ?
08:16:22 <dons> hey lads
08:16:37 <mike-burns> shurikas: The infrastructure and tools, or the language?
08:16:41 <dcoutts> dons: btw, I'm fixing some bytestring things in case you want to voice an opinion
08:16:55 <shurikas> infrastructure and tools
08:16:57 <dons> i'm somewhat following the mails
08:17:03 <shurikas> I love the language
08:17:12 <heatsink> Yeah, I think that's what I was looking for.
08:17:15 <dcoutts> dons: the builder stuff you mean, yeah that's pretty good
08:17:34 <mike-burns> shurikas: We need more devs collaborating on building them. It's a people problem.
08:18:03 <dcoutts> dons: my current quandary is how to fix the Char8 I/O functions which broke with the new ghc Handle impl
08:18:08 <shurikas> showFloat      :: (RealFloat a) => a -> ShowS
08:18:12 <shurikas> like what the hell is ShowS?
08:18:18 <shurikas> why can't it take just a RealFLoat?
08:18:26 <mike-burns> That's not a tool problem.
08:18:31 <shurikas> it's infrastructure
08:18:36 <shurikas> libraries
08:18:58 <mike-burns> I was thinking of things like cabal, which is actually pretty good.
08:19:02 <heatsink> I guess I can just install a development GHC with --prefix, and it won't interfere with my existing GHC files?
08:19:24 * heatsink wants to test HEAD
08:19:38 <dcoutts> heatsink: I've got 6 versions of ghc installed, they do not interfere with each other
08:19:47 <heatsink> ok good
08:20:03 <dcoutts> oh, no, 9 versions
08:20:35 <hpc> lol
08:20:37 <dcoutts> heatsink: it's always worked ok, they install ghc-x.y files in bin/
08:20:44 <dcoutts> and the lib files are also versioned
08:21:09 <dcoutts> and the sets of libs installed for each are independent
08:21:19 <dcoutts> use cabal install -w ghc-x.y to select
08:21:28 <heatsink> oh neat
08:21:32 <dcoutts> to select which ghc you're targeting
08:21:35 <ddarius> Considering you need GHC to build GHC, it should allow multiple versions at a time.
08:21:38 <hpaste> ClaudiusMaximus pasted “databased memoization” at http://hpaste.org/54283
08:22:35 <ClaudiusMaximus> anyone care to review that? would it be worth cleaning up / making more robust / putting on hackage?
08:23:07 * dcoutts has clients using ghc-6.10.4 and so has to be able to test that
08:30:39 <hpc> ClaudiusMaximus: only read enough of it to say "neat"; memoSql is kind of ugly, with the huge let block
08:32:38 <ClaudiusMaximus> hpc: well, the alternatives would be to inline it in the return, or pass all the values to separate helper functions..
08:35:05 <ClaudiusMaximus> hpc: thanks for looking :)
08:35:57 <hpc> ima try and neaten it up
08:36:56 <hpc> are you actually using RecDo?
08:40:16 <ClaudiusMaximus> hpc: yes, in the memoSqlR function
08:41:35 <hpc> ah
08:41:38 <ClaudiusMaximus> hpc: couldn't figure out a nice way to memoize recursive functions otherwise...
08:41:42 <hpc> oh i see
08:42:52 <hpc> packages installed, memo.hs typechecks
08:43:03 <ClaudiusMaximus> there's also some undocumented preconditions about k -> IO v always returning the same v for the same k...
08:44:02 <ClaudiusMaximus> which is horrible, really..
08:44:58 <flux> hmh, isn't that how it's suppoed to work?-o
08:45:43 <ClaudiusMaximus> @hoogle randomRIO
08:45:43 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
08:46:06 <hpc> ClaudiusMaximus: that assumption is pretty much required for memoization to make sense at all
08:46:12 <ClaudiusMaximus> hpc: yep..
08:46:24 <flux> claudiusmaximus, is that like a counter example? I don't think it is?
08:47:17 <hpc> ClaudiusMaximus: if you change it to f :: k -> v, and "let v = f k" instead of "v <- f k", you have a nicer memo function
08:47:33 <hpc> i don't think IO actions are what you want to be memoizing anyway
08:47:49 <ClaudiusMaximus> hpc: right, that's what i started with... but then the recursive case is much trickier
08:48:40 <ClaudiusMaximus> i don't think i actually need recursive functions in the project i'm intending to use that with, so, perhaps i should just omit that part
08:50:00 <hpc> i think there's other tricks for memoizing recursive calls like that
08:50:21 <ClaudiusMaximus> can you attach finalizers to arbitrary haskell values?  then i could attach the cleanup action to the memoized function..
08:50:43 <ClaudiusMaximus> @hoogle finalize
08:50:44 <lambdabot> System.Mem.Weak finalize :: Weak v -> IO ()
08:50:44 <lambdabot> Foreign.ForeignPtr finalizeForeignPtr :: ForeignPtr a -> IO ()
08:50:44 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
08:50:51 <ClaudiusMaximus> @hoogle addFinalize
08:50:51 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
08:50:59 <ClaudiusMaximus> hm
08:51:59 <ClaudiusMaximus> gotta do some things afk - later
08:53:38 <hpc> ClaudiusMaximus: there's definitely a way to do recursive memo with fix, i just need to remember how
09:00:56 <Saizan> fix . memo?
09:02:12 <hpc> i think that's it, yeah
09:02:35 <hpc> and yeah, IO is making it complicated
09:03:42 <copumpkin> mfix!
09:04:09 <hpc> :t mfix
09:04:10 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:04:24 <copumpkin> @hoogle fixIO
09:04:24 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
09:13:37 <hpc> ClaudiusMaximus: if you cleanup and then continue using the memo'd function, you segfault ;)
09:14:10 <hpc> memoFib path table = memoSql path table $ \something -> return 0 -- first pass
09:16:02 <Ke> is there a standard way to Storable a tuple
09:16:21 <Ke> I found eg. http://hackage.haskell.org/package/storable-tuple-0.0.2 http://hackage.haskell.org/package/storable-record-0.0.2.4
09:18:17 <ClaudiusMaximus> hpc: well, that's what you get with foreign code..
09:19:00 <hpc> oh, btw: type Memo k v = IO (IO (), k -> IO v)
09:21:37 <hpc> yay fixIO
09:21:40 <hpc> i get it now
09:21:44 <hpc> i think
09:21:48 <hpc> let's see if this works
09:23:02 <hpc> works
09:23:13 <hpc> but fib 100 overflows
09:24:58 <hpc> this is cool
09:28:34 <hpc> http://hpaste.org/54285 -- non-mfix'd fibonacci
09:29:29 <spoonman> hi, im trying to build haskell-platform on slackware 13.37 and im getting an error "Could not find module Data.Generics.Instances" does anyone knows how to solve this?
09:31:25 <ClaudiusMaximus> hpc: interesting :)
09:32:19 <hpc> ClaudiusMaximus: gonna try generalizing that to memoR
09:33:07 <ClaudiusMaximus> hpc: wondering how best to apply this to a whole library of functions, some of which call each other (but without recursion)
09:34:27 <hpc> first try: memoR path table f = fixIO $ \(~(_, rf)) -> do memoSql path table $ f rf
09:34:43 <hpc> er, that with lines
09:36:49 <hpc> hotdamn, it works
09:37:44 <hpaste> hpc pasted “recursive memoization with fixIO” at http://hpaste.org/54287
09:38:40 <ClaudiusMaximus> nice :)
09:38:57 <hpc> the magic is in "f (snd rf)"
09:39:47 <applicative> spoonman: does ghc-pkg list show the syb library anywhere?
09:39:56 <hpc> ClaudiusMaximus: definitely something for hackage
09:40:16 <ClaudiusMaximus> hpc: cool :)
09:41:10 <ClaudiusMaximus> hpc: wondering whether to make it use SQLData and have a wrapper that uses Read/Show (leaving open the choice of using something else for other types)
09:45:54 <hpc> ClaudiusMaximus: i kind of like how you wrote memoSql now, though that might just be because i gave it a very thorough read-through and spent most of yesterday explaining continuations/callbacks in javascript to a friend :P
09:46:01 <hpc> so it looks familiar
09:47:17 <spoonman> applicative: sorry for the delay, but yes it shows syb-0.3.3
09:49:22 <applicative> spoonman: Hm, then ghc is having trouble finding where it is during the build, though it's clear you have it.
09:52:05 <spoonman> applicative: syb is under /usr/lib/ghc-7.0.3/syb-0.3.3
09:55:48 <applicative> spoonman so it is compiled and ready, but something about the build process is keeping it from using it. if you do ghc --version it says it's version 7.0.3?
09:56:04 <spoonman> applicative: yes
10:04:12 <applicative> spoonman, i don't have any wisdom. Are you following monochrom's advice at http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
10:06:58 <spoonman> applicative: thanks for your help, i'll take a look at that page and see what happens
10:10:53 <monochrom> I am uncomfortable with both the path /usr/lib/ghc-7.0.3/syb-0.3.3 and the possibility that syb is already there before you build Haskell Platform. Haskell Platform comes with and builds its own syb. If you have another one present, I wouldn't be surprised of confusions.
10:12:01 <monochrom> Also Haskell Platform build process is such that nothing, absolutely nothing, is copied to /usr/lib or /usr/local/lib or whatever until all building is successful.
10:15:44 <spoonman> monochrom: i already have haskell-syb because i'm using xmonad wm
10:16:25 <monochrom> well then you're in territories that I wouldn't tread
10:16:59 <geheimdienst> monochrom: i assume he just installed xmonad through his distro's package manager, and now wants the platform
10:17:34 <monochrom> perhaps don't build Haskell Platform yourself. cherry-pick moar packages from distro
10:17:34 <spoonman> geheimdienst: yes
10:17:49 <didjoman> Hi there
10:18:36 <syslevel> hi
10:19:14 <applicative> hi didjoman hi syslevel
10:19:17 <geheimdienst> spoonman: monochrom has a point -- you have half the platform already, because of xmonad and its dependencies. i think it's easier if you just install more distro packages as needed, and ignore the platform
10:19:38 <didjoman> I'd like to learn a functionnal language but I don't know what to choose between Haskell and Caml ? Why is Haskell better ?
10:19:58 <applicative> spoonman, the haskell platform is just a collection of 13 or so libraries
10:20:16 <monochrom> Haskell is better because it is lazier and it has operator overloading (called type class here).
10:20:52 <monochrom> Caml is better because it is eagerer and it has a real module system (sig, struct, functor)
10:20:56 <applicative> didjoman I don't think it's our practice to run down ocaml. Learn both.
10:21:42 <geheimdienst> didjoman: i don't know about caml's community, but it'd be difficult to beat this channel. #haskell is second to none in friendliness and helpfulness. (also in modesty.)
10:21:46 <spoonman> applicative: hum, ok, thanks
10:22:00 <didjoman> ok ok, I just wanted to have your opinion s programmers ;D
10:22:32 <monochrom> use a Geiger counter to count background radiation for a minute or something. if the count is odd, learn Haskell; if the count is even, learn Caml. If the multiverse interpretation of quantum mechanics is right, you will be forking yourself to learn both Haskell and Caml. :)
10:22:34 <didjoman> * as programmers
10:22:41 <syslevel> i need syntax coloring for haskell in the nano editor. can someone of you give me a hint where i can find such a nanorc file ?
10:23:10 <Philonous> Why not OchaML. It has answer-type polymorphism!
10:23:36 <hpaste> plat0 pasted “Installing callbacks” at http://hpaste.org/54290
10:23:37 <applicative> syslevel, incredibly I have seen and used such a file. It was very crude and I'm not sure how to find it again....
10:24:02 <Philonous> OchaCaml even
10:24:29 <zzo38> OK, I tried compiling with -O and I get the same error message as before.
10:24:50 <plat0> I'm exploring how to deal with callbacks in Haskell, in particular callbacks that can install other callbacks in their place.  I've run into a "cannot construct infinite type" error, so I wrapped everything in an ADT.  Seems a bit clumsy though.  Is there a better solution: http://hpaste.org/54290
10:24:55 <syslevel> applicative i think i will make it and upload it anywhere
10:25:38 <applicative> @google Syntax highlighting a nano-ban + haskell.nanorc
10:25:39 <lambdabot> http://www.wubutu.com/2011/05/syntax-highlighting-nano-ban.html
10:25:39 <lambdabot> Title: Wubutu: Syntax highlighting a nano-ban + haskell.nanorc
10:26:21 <applicative> syslevel: this isn't the one I used, ^^^ but it does highlight *several important key words"....
10:26:36 <waern> didjoman: OCaml is a bit more practical (no need to learn about monads and stuff like that), but it's also less elegant than Haskell and it doesn't have good support for parallelism
10:26:54 <syslevel> applicative thank you i have not found anything on the internet ..
10:27:06 <monochrom> what is the type of "callback2"? does it even look like "IORef (CBT a) -> a" so that "CBT callback2" makes sense?
10:27:07 <waern> didjoman: if you want parallelism or concurrency you should definitely choose Haskell
10:27:25 <applicative> syslevel I guess this is just a copy of it https://github.com/serialhex/nano-highlight/blob/master/haskell.nanorc
10:27:36 <monochrom> in fact, if callback2 takes 2 parameters, how can it ever have type IORef (CBT a) -> a ?
10:28:10 <plat0> Because a is of type b -> c
10:28:15 <didjoman> ok thank you for your answer waern  ;)
10:28:56 <monochrom> sure, and what should b,c be? keep going. see you are in for an infinite descent.
10:29:32 <zzo38> Compiling with -O and compiling with -O3 results in same error message as when it is interpreted.
10:29:38 <plat0> Yes I know.  That's why I defined CBT.  Just wondering if there's a better way of doing it.
10:30:15 <monochrom> CBT (flip callback2 v) and CBT (flip callback v). think about it.
10:30:30 <zzo38> Tell me if there is something you see wrong with this program which I may have missed:  http://sprunge.us/LJeL
10:30:40 <monochrom> in fact you should re-order the parameters so you can omit "flip"
10:30:43 <plat0> monochrom: I'm not sure what you're saying.
10:31:13 <monochrom> calculate the type of flip callback2 v. does it match IORef (CBT a) -> a better?
10:31:53 <monochrom> also it should be IORef (CBT a) -> IO a
10:31:56 <Veinor> is there a way to statically analyze a haskell file and see what functions refer to other functions?
10:32:05 <plat0> It is IORef (CBT (IORef a -> IO ())) -> IO ()
10:32:23 <TheWickedChicken> Veinor: ivanm has something called sourcegraph I think
10:32:37 <TheWickedChicken> http://hackage.haskell.org/package/SourceGraph
10:32:48 <applicative> didjoman, like I said, you  might try them both, at least to start. You'll probably understand each better. http://blog.ezyang.com/2010/10/ocaml-for-haskellers/
10:32:53 <Veinor> ahh
10:32:58 <Veinor> well if someone's already done it there's no point!
10:33:16 <didjoman> Ok thank you
10:33:17 <TheWickedChicken> I'm sure he'd appreciate feedback and/or patches for things you need
10:34:33 <applicative> TheWickedChicken: you are totally freaking me out
10:34:46 <TheWickedChicken> why?
10:35:18 <codensity> Now I feel safer.
10:36:48 <Philonous> plat0:  You can apply the callbacks before storing them in the IORef, so you don't need to construct isorecursive types. You still need to tie the knot, though: http://hpaste.org/54291
10:37:52 <Philonous> plat0:  (You don't need the type declaration anymore, just forgot to delete it)
10:39:42 <Philonous> plat0:  You could (should?) probably use mfix instead of the construction with undefined
10:40:36 <plat0> Philonous: ok that's nice.
10:40:43 <plat0> Philonous: what do you mean about undefined?
10:41:50 <Philonous> plat0:  In the main function you need to give an initial value to newIORef that you can't construct because you don't have the IORef yet.
10:42:22 <plat0> Ah I see.
10:43:17 <plat0> I suppose "ideally" you'd like to do c <- newIORef (callback c)
10:43:25 <plat0> But that doesn't make sense in monadic notation.
10:44:54 <plat0> Is there a standard way of arranging callbacks in Haskell?
10:44:54 <Philonous> plat0:  Exactly, you want the fixed point of that recursive definition. Luckily you can do that in the IO monad: c <- mfix (\c' -> newIORef (callback c'))
10:45:00 <Philonous> With mfix from Control.Monad.Fix
10:45:11 <plat0> OK Great.
10:45:33 <shachaf> plat0: You can also use the GHC extension DoRec.
10:48:31 <scooty-puff> so i'm trying to use syb/Data.Generics with t a b where a has kind * -> * (b has kind *)
10:48:44 <scooty-puff> i assume i'll need to write my own extQ/mQ, etc.
10:48:57 <scooty-puff> any general advice, short of just go through the source of Aliases?
10:49:37 <TheWickedChicken> :t mfix (newIORef . In)
10:49:39 <lambdabot> Not in scope: `newIORef'
10:49:49 <scooty-puff> :t mkQ
10:49:51 <lambdabot> forall r b a. (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
10:49:52 <scooty-puff> @src mkQ
10:49:52 <lambdabot> Source not found. You untyped fool!
10:50:24 <scooty-puff> :t extQ
10:50:25 <lambdabot> forall a q b. (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
10:53:01 * codensity is always made to feel like an idiot by DoRec
10:53:10 <hpaste> codensity annotated “callbacks” with “callbacks (annotation)” at http://hpaste.org/54291#a54292
10:56:25 <scooty-puff> there a good resource for Data.Generics with higher kinds, weird polymorphism?
10:56:33 <scooty-puff> i.e. T a B
10:56:38 <scooty-puff> (for type var a)
10:57:03 <scooty-puff> or should i just reorder the type vars and use ext1Q?
10:57:42 <scooty-puff> > data T a b = T a b
10:57:43 <lambdabot>   <no location info>: parse error on input `data'
10:57:55 <scooty-puff> lambdabot like ghci, no data declarations?
10:58:21 <scooty-puff> quiet day..
10:59:03 <Philonous> scooty-puff:  Yes, no data declarations in lambdabot, only expressions
10:59:11 <scooty-puff> k, thanks
10:59:39 <hpc> @src Integer
10:59:39 <lambdabot> data Integer = S# Int#
10:59:39 <lambdabot>              | J# Int# ByteArray#
11:00:25 <scooty-puff> :t let q (a, b) = [fromMaybe [] b) in ([] `mkQ` q)
11:00:26 <lambdabot> parse error on input `)'
11:00:37 <scooty-puff> :t let q (a, b) = fromMaybe [] b in ([] `mkQ` q)
11:00:39 <lambdabot>     Ambiguous type variable `t' in the constraint:
11:00:39 <lambdabot>       `Typeable t' arising from a use of `mkQ' at <interactive>:1:34-43
11:00:39 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
11:01:34 <scooty-puff> :t let q (a, b) = [fromMaybe [] b) in everywhere ([] `mkQ` q)
11:01:35 <lambdabot> parse error on input `)'
11:01:46 <scooty-puff> :t everywhere
11:01:47 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
11:02:01 <hpaste> montecarl pasted “morse segfault” at http://hpaste.org/54293
11:02:03 <scooty-puff> :t let q (a, b) = fromMaybe [] b in everything (++) ([] `mkQ` q)
11:02:05 <lambdabot>     Ambiguous type variable `t' in the constraint:
11:02:05 <lambdabot>       `Typeable t' arising from a use of `mkQ' at <interactive>:1:50-59
11:02:05 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
11:02:35 <montecarl> i am learning haskell and I have some very simple code that gives me a segfault when called with any arguments: http://hpaste.org/54293
11:02:59 <montecarl> morse 1 1 1 1  crashes for example
11:03:17 <montecarl> i am running it through ghci by :load morse
11:04:01 <scooty-puff> > let morse d0 alpha r0 r = d0 * (exp ( - 2 * alpha * (r-r0)) - 2 * exp ( - alpha * (r-r0)))
11:04:02 <lambdabot>   not an expression: `let morse d0 alpha r0 r = d0 * (exp ( - 2 * alpha * (r-...
11:04:14 <scooty-puff> > morse d0 alpha r0 r = d0 * (exp ( - 2 * alpha * (r-r0)) - 2 * exp ( - alpha * (r-r0)))
11:04:15 <lambdabot>   <no location info>: parse error on input `='
11:04:24 <Nimatek> > morse d0 alpha r0 r = d0 * (exp ( - 2 * alpha * (r-r0)) - 2 * exp ( - alpha * (r-r0))) in morse 1 1 1 1
11:04:25 <rwbarton> let ... in ...
11:04:25 <lambdabot>   <no location info>: parse error on input `='
11:04:30 <Nimatek> > let morse d0 alpha r0 r = d0 * (exp ( - 2 * alpha * (r-r0)) - 2 * exp ( - alpha * (r-r0))) in morse 1 1 1 1
11:04:31 <lambdabot>   -1.0
11:04:41 <Nimatek> Seems to work.
11:04:43 <montecarl> thats the correct result!
11:04:44 <scooty-puff> what version of ghc?
11:04:44 <dmwit> montecarl: I can't reproduce that here.
11:05:08 <montecarl> 6.10.4
11:05:11 <scooty-puff> :get
11:05:14 <rwbarton> Are you on some wacky platform?
11:05:16 <scooty-puff> :get version
11:05:18 <scooty-puff> meh
11:05:22 <scooty-puff> just guessing..
11:05:23 <montecarl> i installed ghc using macprots
11:05:39 <rwbarton> that's pretty wacky, I guess.
11:06:15 <montecarl> yea if i start ghci and paste the code that was just evaluated by lambdabot it segfaults
11:06:20 <montecarl> okay, so i guess it is just me
11:06:21 <dmwit> Is it possible that GHC is linking against a different library (or version of library) than it's expecting to?
11:06:38 <montecarl> i guess its possible, i might just build ghc 7.2 by hand
11:06:46 <zzo38> I tried compiling and using profiling on my program.
11:07:11 <zzo38> It runs out of memory if there is any text on the page at all. If the page contains only rules, it works.
11:07:42 <codensity> montecarl: The binary haskell platform installer works fine on os x .
11:07:43 <dmwit> text? page? rules?
11:07:47 <rwbarton> montecarl: why not use the binary distribution from http://www.haskell.org/ghc/download_ghc_7_2_2 ?
11:08:04 <montecarl> rwbarton:  i'll do that :)
11:08:22 <codensity> montecarl, it even give morse 1 1 1 1 = -1.0 :)
11:08:32 <zzo38> dmwit: Do you even know my program?
11:08:40 <rwbarton> haha.
11:08:41 <dmwit> No. How should I know your program?
11:09:05 <zzo38> Because I posted it on here before.
11:09:07 <codensity> dmwit he pasted it
11:09:35 <dmwit> I don't see anything in the last half hour or so.
11:09:42 <dmwit> So maybe it's time to paste it again.
11:09:45 <montecarl> codensity: i will try with the binary distribution and report back
11:09:57 <codensity> zzo38 too many semicolons! Are they required by this form of literate haskell?
11:10:11 <dmwit> Literate Haskell does not require semicolons.
11:10:32 <zzo38> codensity: No, it is just the way I like to write the program.
11:10:38 <codensity> montecarl, not that the platform libraries don't come with the ghc-7.2 binary
11:11:15 <zzo38> http://sprunge.us/LJeL
11:11:20 <codensity> montecarl: note, rather.  It may or may not matter, for your purposes.
11:11:31 <montecarl> codensity: thats fine, i don't even know how to use them yet
11:11:44 <montecarl> but thanks for the heads up
11:14:30 <dmwit> transInt = fromIntegral
11:14:47 <dmwit> toEnum $ fromEnum a = transEnum a
11:15:04 <zzo38> It runs out of memory with text on the page even if I load emptyFont instead of the correct one.
11:15:11 <elliott> > transEnum = toEnum . fromEnum;
11:15:11 <elliott> isn't that the definition, dmwit? :p
11:15:12 <lambdabot>   <no location info>: parse error on input `='
11:15:15 <zzo38> dmwit: I know of those things; but I made shortcuts
11:15:19 <dmwit> elliott: Yes, but he doesn't use it. =(
11:15:20 <elliott> oh, i see
11:15:54 * hackagebot vector-space 0.8.0 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.0 (ConalElliott)
11:16:09 <rwbarton> @hoogle transEnum
11:16:09 <lambdabot> No results found
11:16:20 <dmwit> ?hoogle (Enum a, Enum b) => a -> b
11:16:20 <lambdabot> Prelude pred :: Enum a => a -> a
11:16:20 <lambdabot> Prelude succ :: Enum a => a -> a
11:16:20 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:16:27 <rwbarton> I like the looks of that last one.
11:16:32 <dmwit> =)
11:16:35 <elliott> thanks lambdabot
11:16:51 <dmwit> Anyway, transEnum looks like a pretty handy function to have around (if a bit unsafe).
11:17:18 <elliott> fromEnumtegral
11:17:30 <elliott> to follow the naming convention :P
11:17:49 <Ke> should hackage show doc links on upload preview page?
11:17:55 <dmwit> dviUnitsTeX = 25400000 % 473628672 -- lol
11:19:15 <byorgey> Ke: hackage only builds docs in a big batch once every 6 hours or so
11:19:22 <zzo38> dmwit: That isn't in lowest terms but that's OK. TeX uses these terms exactly, while this program will use lowest terms; I tried changing a DVI file manually to lowest terms and it still works OK in any program for reading DVI files that I have used.
11:19:27 <byorgey> Ke: so links to the docs will not show up immediately
11:19:27 <Ke> bungley: so no?
11:19:32 <Ke> ok
11:20:26 <dmwit> oh god
11:20:37 <dmwit> dat PageNumbers fromByteString
11:21:22 <dmwit> You might want to consider using something sane, like the binary library.
11:22:42 <zzo38> O, that's how you do it?
11:23:24 <zzo38> I didn't know that. Thanks for information.
11:23:29 <yitz> > let morse = concatMap m; m ' '="  ";m c|isAsciiUpper d=["._","_...","_._.","__.",".",".._.","__.","....","..",".___","_._","._..","__","_.","___",".__.","__._","._.","...","_",".._","..._",".__","_.._","_.__","__.."]!!(fromEnum d-65)++" "|otherwise=[c]where{d=toUpper c}in morse"In morse"
11:23:30 <lambdabot>   ".. _.   __ ___ ._. ... . "
11:24:39 <zzo38> OK, I think I might have found the problem, it might be the readObj_fntdef function.
11:25:09 <zzo38> Or readObj_fntdef_ or addFont. Is the infinite list generated in addFont wrong?
11:25:12 <dmwit> Do you hate whitespace?
11:25:31 <dmwit> This "use all eighty characters of width starting from column 3" style is amazingly hard to read.
11:25:36 <Fuco> Is there a built in function for Applicative f => [f a] -> f [a]... this works but it's rather fugly: foldr (liftA2 (:)) (pure [])
11:25:37 <zzo38> dmwit: No. This program uses a lot of whitespace.
11:25:54 * hackagebot OpenCLWrappers 0.0.0 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.0.0 (EmilKarlson)
11:25:57 <mauke> :t sequenceA
11:25:59 <rwbarton> @type sequenceA
11:25:59 <lambdabot> Not in scope: `sequenceA'
11:25:59 <lambdabot> Not in scope: `sequenceA'
11:26:00 <elliott> Fuco: traverse?
11:26:01 <elliott> :t traverse
11:26:02 <lambdabot> Not in scope: `traverse'
11:26:08 <mauke> @hoogle sequenceA
11:26:09 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:26:09 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
11:26:10 <elliott> @hoogle Data.Traversable
11:26:10 <lambdabot> Data.Traversable module Data.Traversable
11:26:10 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
11:26:20 <elliott> oh, right, sequenceA
11:26:34 <Fuco> hm, data.traversable :P, ok thanks
11:27:44 <zzo38> I think the problem must be one of the three functions I specified. Setting the second parameter of withDVI to undefined, or anything else I try, still results in out of memory.
11:28:12 <zzo38> And it only does that if the document contains text.
11:32:49 <scooty-puff> is it possible to have a Typeable (t a) for a :: * -> *?
11:34:50 <mauke> > let morse=(>>=m);m ' '="  ";m c=maybe[c]((++" ").(words"._ _... _._. __. . .._. __. .... .. .___ _._ ._.. __ _. ___ .__. __._ ._. ... _ .._ ..._ .__ _.._ _.__ __.."!!))$findIndex(toUpper c==)['A'..'Z']in morse"In morse"
11:34:52 <lambdabot>   ".. _.   __ ___ ._. ... . "
11:35:16 <elliott> ._.
11:35:29 <Fuco> ae :D
11:36:01 <codensity> > let alpha = "._ _... _._. __. . .._. __. .... .. .___ _._ ._.. __ _. ___ .__. __._ ._. ... _ .._ ..._ .__ _.._ _.__ __.."  ; secret_code = zip (words alpha) ['a'..'z']; unmorse = catMaybes . map (`lookup` secret_code) . words in unmorse alpha
11:36:03 <lambdabot>   "abcdefdhijklmnopqrstuvwxyz"
11:36:04 <Fuco> or r... damn morse code
11:36:39 <scooty-puff> so basically, how do you declare some sort of Typeable instance of (* -> *) -> *
11:36:58 <scooty-puff> i have a syntax tree that contains embedded comonads
11:37:02 <codensity> > let alpha = "._ _... _._. __. . .._. __. .... .. .___ _._ ._.. __ _. ___ .__. __._ ._. ... _ .._ ..._ .__ _.._ _.__ __.."  ; secret_code = zip (words alpha) ['a'..'z']; unmorse = catMaybes . map (`lookup` secret_code) . words in unmorse  ".. _.   __ ___ ._. ... . "
11:37:03 <lambdabot>   "inmorse"
11:37:12 <scooty-puff> (the comonads are to annotate the tree with locations, types, etc)
11:37:41 <elliott> scooty-puff: Always use deriving (Typeable).
11:37:43 <scooty-puff> so like Stmt a w = IfThen (w (Expr a w) ) , etc..
11:37:45 * codensity is finding that morse code is just about his speed....
11:37:46 <elliott> Never hand-write an instance.
11:37:55 <scooty-puff> tried that, but complains with:
11:38:02 <scooty-puff> (had to switch to standalone deriving)
11:38:33 <scooty-puff> `T' has arguments of kind other than `*'
11:38:53 <dmwit> scooty-puff: For higher-kinded type constructors, you may need Typeable1, Typeable2, etc.
11:38:58 <scooty-puff> so makes me wonder how possible this is - the compiler makes heavy use of generics, and would prefer to keep it that way
11:39:45 <scooty-puff> problem is, Typeable1 a expects a :: * -> *, Typeable2 a with a :: * -> * -> *, but i need (* -> *) -> *
11:39:48 <zzo38> I think I made another mistake in addFont function, it should be:   \count0=1 \count1=5
11:39:51 <dmwit> Oh, nevermind, TypeableN don't help for higher kinds, only longer kinds.
11:39:53 <dmwit> Yeah, sorry.
11:39:56 <zzo38> Oops that is wrong
11:40:02 <zzo38> Mispasted
11:40:05 <scooty-puff> hmm
11:40:21 <scooty-puff> might investigate other generics libs to see if any more flexble, though i admit this is an odd case
11:41:36 <zzo38> addFont i h n = (take i $ h ++ repeat emptyFont) ++ [n] ++ drop (succ i) h     is probably better. But is this use of "repeat" still wrong? Is there anything else wrong with this function, or the two functions before it? (These are the last three functions in the source file)
11:43:00 <dmwit> That definition looks pretty reasonable to me.
11:43:05 <dino-> Wait, binary strip happens with cabal at install time? Not right after build?
11:43:23 <zzo38> O, I found what must be the mistake!  ((+) <$> readData ha <*> readData ha :: IO Word32)  should be Word8 instead of Word32 that must be the mistake.
11:44:05 <dino-> Which actually makes more sense than the way I assumed it worked. Because you want to possibly debug those (ininstalled, in dist/) binaries, but NOT have that installed with it.
11:46:30 <dmwit> Are there any liftIO laws?
11:46:35 * applicative finally lets it dawn upon him what zzo38 's module is supposed to do
11:46:44 <applicative> zzo38: awesome!
11:47:11 <hpc> dmwit:     liftIO . return = return
11:47:12 <hpc>     liftIO (m >>= f) = liftIO m >>= (liftIO . f)
11:47:13 <dmwit> I would want something like (liftIO . return = return), (liftIO m >>= \v -> liftIO (f v) = liftIO (m >>= f)).
11:47:16 <dmwit> Maybe more?
11:47:25 <hpc> dmwit: lol, those are the laws
11:47:30 <dmwit> Great. =)
11:47:33 <elliott> dmwit: I would suggest liftIO = lift^n for some n, but I know that's not actually true.
11:47:39 <elliott> (Not that (^).)
11:47:50 <elliott> I do wonder if it shouldn't be, though.
11:47:53 <dmwit> elliott: Well, then the question is really "what are the laws for lift". And I think I'd want the same ones.
11:48:01 <elliott> Right.
11:48:16 <elliott> I know at least one package with a liftIO that does not correspond to any number of lifts, but you can still get at IO through lift.
11:48:20 <elliott> (The difference being exception-handling.)
11:48:49 <dmwit> Are these laws well-known enough that people check them when they write MonadIO/MonadTrans instances?
11:48:54 <dmwit> Are they written down online somewhere?
11:49:20 <rwbarton> @type lift
11:49:21 <lambdabot>     Ambiguous occurrence `lift'
11:49:21 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:49:21 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:49:26 <rwbarton> @hoogle lift
11:49:26 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
11:49:26 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
11:49:27 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:49:30 <dmwit> ?type Control.Monad.Trans.lift
11:49:31 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
11:49:54 <elliott> lift is one of those things that usually only has one obvious definition.
11:50:01 <elliott> So I think they're safe to rely on.
11:50:28 <rwbarton> well, at a minimum it should be a monad homomorphism so that   lift . return = return  and  (something more complicated involving lift and join)
11:50:35 <dmwit> I've learned over the last year or two that the obvious definition doesn't always satisfies all the laws you might wish for. =)
11:51:00 * shachaf would like to take this opportunity to express a general complaint about how annoying monad transformers are.
11:51:04 <rwbarton> lift $ do x <- f; g x   ==  do x <- lift f; lift (g x)
11:51:22 <dmwit> I suppose then there's probably a third one that nobody has mentioned yet.
11:51:39 <dmwit> Corresponding to lifting the third monad law.
11:52:02 <dmwit> err... no
11:52:09 <rwbarton> no, it's like a monoid homomorphism just has to preserve the identity and products
11:52:12 <elliott> shachaf: I can always count on you.
11:52:21 <shachaf> elliott: To complain?
11:52:24 <dmwit> rwbarton: right
11:52:28 <elliott> You could say that, yes!
11:54:15 <zzo38> I found some other mistakes in my program too, and now I corrected them, and it works OK now.
11:54:25 <dmwit> \o/
11:55:54 * applicative is trying to figure out how to use zzo38 's module
11:55:55 * hackagebot acid-state 0.5.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.5.2 (DavidHimmelstrup)
11:56:45 <zzo38> applicative: You can't; it doesn't work. I will now post the one that works, so that you can use it.
11:57:07 <zzo38> http://sprunge.us/YURT
11:58:02 <zzo38> Ask a question in case you have any question, please.
12:05:04 <douche> Hello?
12:05:10 <hpaste> tgeeky pasted “cannot construct infinite type” at http://hpaste.org/54294
12:05:39 <douche> I'm writing a c program and I don't have an output file.
12:05:53 <zzo38> applicative: Can you figure it out now? Is this a program you wanted to use? It is not yet complete, but what it has, works. Can you tell me if this program interest you?
12:05:55 <applicative_> zzo38: if i have a tfm file and a string how do I piece them together?
12:05:55 <tgeeky_> can someone point me in a direction w.r.t.
12:05:59 <tgeeky_>  <-- http://hpaste.org/54294
12:06:08 <dmwit> douche: Perhaps ##c would be a better forum for C questions.
12:06:10 <elliott> douche: this channel is about haskell
12:06:11 <zzo38> douche: C program? This channel is for Haskell program.
12:06:13 <tgeeky_> the code is copied from Bird
12:06:31 <douche> CODE:
12:06:34 <douche> #include <stdio.h>
12:06:36 <douche> dang it
12:06:38 <tgeeky_> oh boy
12:06:41 <dmwit> douche: Don't paste here, please.
12:06:46 <zzo38> douche: This channel is for Haskell program.
12:06:51 <douche> Super.
12:06:58 <applicative_> douche: use hpaste, then get on #c
12:07:18 * elliott wonders why douche thought #haskell was a good place to ask that.
12:07:28 <applicative_> zzo38: yes, this is extremely interesting, just trying to figure it out
12:07:36 <shachaf> elliott: Yes, #include seems like a much better channel.
12:07:41 <tgeeky_> well, his name *is* douche.
12:07:59 <elliott> * Topic for #include is: I'd give my right arm to be ambidextrous.
12:08:16 <tgeeky_> haha. I got a rich guffaw from that one.
12:08:16 <companion_cube> <3 the idea of #inculude
12:08:19 <zzo38> applicative_: The function called "loadFont" to load the font (make the FontMag to Left for magnification (1000 = normal), or Right for at size). The function called "typesetSimpleString" will add kern/ligature to the string and make a PageObject of it, including the font.
12:08:21 <companion_cube> #include*
12:08:45 <applicative_> yes, I was that far, then with a page object what can I do
12:09:47 <dmwit> tgeeky_: Well, look at the type of fork. It doesn't take two arguments with the same type.
12:09:57 <dmwit> tgeeky_: But you took two arguments out of a list (hence having the same type) and passed them in.
12:10:21 <tgeeky_> dmwit: fork is supposed to (I think), that is my manual copying of ghci's type
12:10:23 <dr_rotflcopter> HELLO WORLD!
12:10:25 <zzo38> applicative_: Currently not much. I haven't written most of the program yet. You can use objWidth, objHeight, and objDepth, so far. I will add other stuff later, so that you can write a DVI file, and so on.
12:10:33 <elliott> dr_rotflcopter: Sorry, this channel is pure.
12:10:34 <tgeeky_> into the file in order to get it to work
12:10:35 <elliott> No RealWorld for you.
12:10:41 <dmwit> tgeeky_: It's not complaining about fork. It's complaining about your *use* of fork in split.
12:10:48 <dr_rotflcopter> elliott<< pure? :)
12:10:57 <elliott> Yes. Just like Haskell.
12:11:02 * elliott unsafePerformIO (hello world)
12:11:10 <dr_rotflcopter> ;/
12:11:25 <dr_rotflcopter> unsafe outputting a string to screen?
12:11:38 <elliott> No, unsafely greeting the world.
12:11:40 <elliott> It might greet back.
12:11:47 <dr_rotflcopter> ;>
12:12:00 <dr_rotflcopter> aham so you're concerned about smurfs attack
12:12:02 <shachaf> unsafeDupablePerformIO should be called unsafePerformIO
12:12:10 <shachaf> And unsafePerformIO should be called safePerformIO
12:12:15 <shachaf> It's all a matter of perspective.
12:12:45 <dr_rotflcopter> yeah its actually proven to be unsafe to greet the world ;>
12:12:57 <dr_rotflcopter> that results in a ddos at minimum
12:13:12 <dmwit> tgeeky_: (Do you see what I mean, or are you still confused?)
12:13:46 <tgeeky_> dmwit: I am this far: I used (u:v:ts) to extract parts of a list, so u:v *must* be of the same type.
12:14:00 <dmwit> Right.
12:14:14 <dmwit> Then you pass u and v as arguments to fork (in the "else" clause).
12:14:17 <tgeeky_> yes
12:14:22 <dmwit> Which is weird, because fork wants arguments of *different* types.
12:14:34 <dmwit> (...and the two different types are incompatible.)
12:15:06 <dmwit> By the way, you might be able to get a better error message if you write down the type you think "split" ought to have.
12:15:10 <tgeeky_> fork _ _ should result in type (Int, T) <- I think
12:15:21 <dmwit> Yes, but those _ _ are important. =)
12:15:37 <tgeeky_> a and b must both be something numeric if I'm calling max on them
12:15:47 <tgeeky_> and u and v must be things that go into fork
12:15:52 <tgeeky_> capital fork, that is (Y)
12:16:04 <tgeeky_> which is T T
12:16:07 <dmwit> Oh, did you mean to call capital fork?
12:16:11 <dmwit> You called lower-case fork.
12:16:30 <tgeeky_> dmwit: oops, one second, phone
12:17:16 <zzo38> applicative_: I can write more of the program later. If you have any suggestions, you can write them here, and I might consider it.
12:18:45 <tgeeky_> dmwit: ok, back. Here is the page from Bird: http://i.imgur.com/Ru1mu.png
12:19:08 <dmwit> tgeeky_: Yeah, you called the wrong fork. =)
12:19:11 <tgeeky_> the smart constructure should use the real constructor (Y)
12:19:31 <dmwit> You don't want split x (fork u v : ts), you want split x (Y u v : ts).
12:19:38 <tgeeky_> dmwit: nope, not according to this page:
12:19:46 <tgeeky_> the part that *isnt'* highlited in pink
12:19:47 <applicative_> zzo38: hm, I have an IO PageObject at last myPageObject = typesetSimpleString <$>  loadFont (Left 2) myTfmPath <*> pure "hello"
12:19:52 <tgeeky_> is the part that I should be using, but hasn't compiled yet
12:20:21 <tgeeky_> (the original split at the top uses big Fork (Y), but the second one uses the smart constructor)
12:21:03 <mauke> I have no context but the page picture
12:21:12 <mauke> my crystal ball says: `max`
12:21:22 <dmwit> Well, the literal translation of x max fst u is x max fst u, not x `max` fst u.
12:21:25 <dmwit> yeah
12:21:31 <dmwit> What mauke said. =)
12:21:31 <applicative_> zzo38: well I look forward to studying it. it could be really wonderful
12:21:32 <tgeeky_> yeah, that didn't help
12:21:38 <tgeeky_> which is why I infixed it in the first place
12:22:04 <zzo38> applicative_: (Left 2) is very small and probably not what you want unless the original font is very large. (Left 1000) is normal size. Or you can specify a specific size with Right. The page object will probably go in a Page; although currently, those cannot be used much. Later versions will add the necessary functions to do more useful stuff with it.
12:22:22 <tgeeky_> dmwit: http://hpaste.org/54294 <-- there is the code
12:22:28 <tgeeky_> I can post the entire chapter in PDF form
12:22:42 <applicative_> zzo38: yes, I figured.  I can't write a file yet, right?
12:22:43 <mauke> tgeeky_: `max`, not max
12:22:58 <shachaf> sam `n` max
12:23:15 <shachaf> sum `n` max?
12:23:26 <dmwit> tgeeky_: Oh, mauke is suggesting that you should also use `max` in fork.
12:23:26 <zzo38> applicative_: Yes, you are correct. I have not written that part yet.
12:23:32 <dmwit> That sounds plausible.
12:24:01 <dmwit> Yeah, that sounds really, really reasonable.
12:24:10 <tgeeky_> mauke: that did it!
12:24:20 <tgeeky_> that fixed the stupid type that I hand transcriped
12:24:31 <tgeeky_> and now fork is: fork :: (Num t, Ord t) => (t, T) -> (t, T) -> (t, T)
12:24:37 <tgeeky_> which is precisely what I expected in the first place
12:24:40 <applicative_> zzo38: I will study up on dvips and so on...
12:24:43 <tgeeky_> thank you both!
12:25:49 <tgeeky_> and split compiles too!
12:26:31 * tgeeky_ learned that type intuition is slighly better than he expected :o
12:27:09 <parcs> type what?
12:27:22 <tgeeky_> s/that/that my/
12:27:33 <sonoflilit> Hi
12:27:41 <tgeeky_> my intuition about the types of things is better (and when I got that strange type from GHC, I should have known better immediately)
12:27:46 <sonoflilit> Can I export a from a module by a different name?
12:27:58 <applicative_> zzo38: i will try to make a pandocwriter for it... that will be extremely amusing.
12:28:05 <tgeeky_> sonoflilit: you'll have to be more specific, or provide an example.
12:28:21 <sonoflilit> e.g. define a datatype data D = C1 | C2 and export as
12:28:34 <sonoflilit> as if it were data E = E1 | E2
12:28:35 <sonoflilit> ?
12:28:44 <elliott> sonoflilit: No.
12:28:51 <sonoflilit> sorry, keyboard sucks :P
12:28:53 <tgeeky_> the only way to do someting like that is just to use template haskell in the first place?
12:29:16 <tgeeky_> dmwit++
12:29:19 <tgeeky_> muake++
12:29:24 <sonoflilit> elliott: but I could use a "wrapper" module, right? because I can import and rename?
12:29:25 <tgeeky_> mauke++
12:29:26 <tgeeky_> even
12:29:31 <tgeeky_> sonoflilit: you can't rename
12:29:33 <elliott> sonoflilit: You cannot rename.
12:29:38 <sonoflilit> damn
12:29:53 <elliott> (I'm wondering why you'd even want to.)
12:29:55 <tgeeky_> sonoflilit: it's something I really want, too - for making arbitrary changes the published modules
12:30:24 <tgeeky_> elliott: I know why *I* want to -- to be able to rename other people's functions (especially infix functions)
12:30:29 <tgeeky_> without rewriting the module
12:30:31 <sonoflilit> so, here's my problem: I'm upgrading to a new version of Persistent, which is a library with some template Haskell that creates data types automatically from DB names
12:30:33 <shachaf> preflex: karma muake
12:30:33 <preflex>  muake: 1
12:30:46 <elliott> tgeeky_: Well, OK. Doesn't foo = Qual.bar work for that?
12:30:51 <elliott> This is about types and constructors.
12:31:01 <elliott> sonoflilit: Ah. Doesn't it support making custom name mappings?
12:31:02 <sonoflilit> and the new version creates different names, and there's a collision
12:31:06 <elliott> If not, you should report a bug. :)
12:31:29 <zzo38> applicative_: What is a pandocwriter?
12:31:52 <sonoflilit> elliott: not that I know, I'll google but probably not
12:32:49 <applicative_> zzo38: I just meant something like this https://github.com/jgm/pandoc it writes latex , html etc. from a variety of sources
12:33:13 <elliott> sonoflilit: I'd look at the API documentation instead.
12:33:27 <tgeeky_> elliott: probably, but it is tedious to change everyone's code that, say, uses (<>) and make it use something else (say (||)).
12:33:29 <elliott> applicative_: zzo38: (http://johnmacfarlane.net/pandoc/ is probably a better link.)
12:33:38 <sonoflilit> elliott: Seems like it does :-)
12:33:41 <elliott> tgeeky_: fair enough
12:33:44 <elliott> sonoflilit: yay :)
12:33:46 <applicative_> elliott: indeed.
12:34:02 <sonoflilit> thanks :-) this is a much simpler solution than I had in mind
12:34:53 <applicative_> zzo38: i have made crude pdf writers for it via the hpdf library, but the latter has hopeless restrictions
12:36:45 <sonoflilit> except that it isn't working... I'll try to cabal clean, maybe somehting got stuck
12:39:40 <hpaste> scooty-puff pasted “Typeable” at http://hpaste.org/54295
12:51:45 <hnewbie> http://hpaste.org/54296 anyone see what's wrong with this? (three lines of really basic haskell)
12:53:50 <mauke> missing 'return'
12:53:57 <applicative_> hnewbie: the last line will compile if it is putStrLn (subRegex (mkRegex "^~") s home)
12:54:59 <hnewbie> applicative_:
12:55:08 <hnewbie> what if I want to return a string not print it?
12:55:23 <elliott> return $ subRegex (mkRegex "^~") s home
12:55:25 <applicative_> then like mauke said.
12:55:52 <hnewbie> I see thanks guys
12:55:55 * hackagebot memo-sqlite 0.1 - memoize functions using SQLite3 database  http://hackage.haskell.org/package/memo-sqlite-0.1 (ClaudeHeilandAllen)
12:55:58 <ClaudiusMaximus> hpc: ^^
12:55:59 <applicative_> the point is that the last line must be an IO action, but as it was it was a pure string
12:56:35 <elliott> hnewbie: You might want to check out System.FilePath.
12:56:39 <companion_cube> memoizing using a sql database ?!
12:56:42 <elliott> ClaudiusMaximus: Wow :P
12:56:53 <elliott> ClaudiusMaximus: Does that... work?
12:56:53 <hpc> ClaudiusMaximus: :D
12:57:02 <hpc> elliott: it works swimmingly
12:57:24 <elliott> Swimmingly has to be some weird word for terrifying.
12:57:29 <elliott> ClaudiusMaximus: I don't see why the result has to be in IO.
12:57:36 <elliott> The side-effects (mutating a database) are only observable from IO.
12:57:41 <elliott> Oh, because someone else could tamper with the DB.
12:58:02 <elliott> ClaudiusMaximus: I would make it (a -> b) -> a -> IO b, personally.
12:58:13 <kamyzi`e> hello, how would I get pairs from a list: [1,2,3,4,5,6] -> [(1,2),(3,4),(5,6)] ?
12:58:21 <elliott> ClaudiusMaximus: It seems weird to say "(a -> IO b) but it has to be pure", because that kind of benign effect is what unsafePerformIO is for.
12:58:46 <mauke> > ap zip tail [1 .. 6]
12:58:48 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
12:58:54 <mauke> hmm, not quite
12:59:15 <ClaudiusMaximus> elliott: sure, there's more options to explore...
13:00:08 <hpaste> scooty-puff pasted “Typeable (again)” at http://hpaste.org/54297
13:00:22 <applicative> > let kamyzi'e xs = zip xs (tail xs0 in kamyzi'e [1..20]
13:00:23 <lambdabot>   <no location info>: parse error on input `in'
13:00:31 <scooty-puff> mkTyCon3 wasn't available..
13:00:34 <applicative> > let kamyzi'e xs = zip xs (tail xs) in kamyzi'e [1..20]
13:00:35 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
13:00:37 <scooty-puff> :t mkTyCon3
13:00:38 <lambdabot> Not in scope: `mkTyCon3'
13:00:44 <scooty-puff> :load Data.Typeable
13:00:51 <scooty-puff> :m+ Data.Typeable
13:00:54 <scooty-puff> :t mkTyCon3
13:00:55 <lambdabot> Not in scope: `mkTyCon3'
13:02:17 <hpc> elliott: making it memoize functions (a -> b) doesn't work for recursive functions
13:02:45 <elliott> hpc: why not? fib = memo fib' where fib' ... = ... fib (n-1) ...
13:03:12 <hpc> elliott: because fib :: Int -> IO Int
13:03:19 <elliott> Oh, right.
13:03:32 <elliott> That sucks. :(
13:03:39 <ClaudiusMaximus> i didn't really want to litter the whole thing with unsafePerformIO, but you're free to do that...
13:03:41 <elliott> hpc: You can of course do fixMemo.
13:03:54 <elliott> ClaudiusMaximus: It's better than making people litter their code with unsafePerformIO :-)
13:04:14 <ClaudiusMaximus> elliott: maybe 0.2 version could have an Unsafe module,,
13:04:28 <dolio> Is it a pure function?
13:04:55 <elliott> ClaudiusMaximus: I don't think you should expose an unsafe interface.
13:05:04 <elliott> ClaudiusMaximus: But fixMemo :: ((a -> b) -> a -> b) -> a -> IO b is safe.
13:05:11 <elliott> And can't be done with your current interface without unsafePerformIO.
13:05:13 <ClaudiusMaximus> it should be pure assuming a benevelont RealWorld (ie, no one deletes the database underneath you)
13:05:34 <elliott> ClaudiusMaximus: (As in, "safe even if someone messes with the DB".)
13:05:52 <dolio> Can someone delete the database?
13:06:11 <ddarius> dolio: Ye of little faithe.
13:06:12 <ClaudiusMaximus> sure! or fill it with nonsense :)
13:06:30 <dolio> Why are they able to do that?
13:07:39 <elliott> dolio: because OSes aren't perfect
13:07:48 <elliott> and you can't have filesystem closures that nobody else can peek at :)
13:08:17 <shurikas> how can I pattern match a recursive data type?
13:08:35 <shurikas> data List a = Nil | Cons a (List a) deriving (Show)
13:08:56 <dolio> Oh, it's actually a file-backed database.
13:09:33 <ddarius> shurikas: Just do it.
13:09:50 <shurikas> ddarius, (x:xs) doesn't work
13:09:56 <shurikas> and Cons a (List a) neither
13:10:05 <shachaf> shurikas: Where did ":" get into it?
13:10:17 <shachaf> (:) is the constructor for lists. Replace it with your own constructor.
13:10:26 <shurikas> with Cons in this case/
13:10:49 <shachaf> If that's what you want to do.
13:10:53 <shachaf> What are you actually trying to do?
13:11:17 <shurikas> fromList :: List a -> [a]
13:11:17 <shurikas> fromList Cons a (List b) = a : (fromList b)
13:11:20 <shurikas> something like this
13:11:59 <dolio> List isn't a constructor of values.
13:12:28 <shurikas> and I didn't find any documentation on how to pattern match a custom recursive type on internet...
13:12:36 <mzero> shurikas: you've defined Cons as a constructor taking two values
13:12:38 <ddarius> You wrote x:xs not x:[x] for lists, why wouldn't you do the equivalent for your List type?
13:12:42 <mzero> so match it as such
13:12:58 <mzero> fromList (Const a b) = a : fromList b
13:13:13 <ddarius> shurikas: There is no difference between pattern matching a custom type and a standard type, and no difference pattern matching a recursive type and a non-recursive type.
13:13:19 <mzero> In your data declaration (List a) is a type, not a data structure itself
13:14:03 <ddarius> shurikas: (Re)Read the section in whatever book you are reading (or start reading one if you aren't) on pattern matching.
13:14:56 <shurikas> ok, thanks guys
13:14:57 <applicative> kamyzi`e: i just noticed you wanted something different from what mauke and i were thinking
13:16:05 <shachaf> If you want to pattern-match a recursive type, you have to use recursive-type pattern-matching. Fortunately it's indistinguishable from regular pattern-matching.
13:16:33 <shurikas> shachaf, oh man... what should I do then??
13:16:42 <shurikas> like... use regular one?
13:16:45 <applicative> > let twos [] = Nothing; twos [x] = Nothing ; twos (x:y:zs) = Just ((x,y), zs) in unfoldr twos [1..6] -- there must be a better wa, kamyzi`e
13:16:46 <lambdabot>   [(1,2),(3,4),(5,6)]
13:16:46 <shachaf> shurikas: Ignore what I said.
13:16:50 <shurikas> I got it, for god's sake.
13:18:42 <shachaf> > unfoldr (\xs -> case xs of (a:b:ys) -> Just ((a,b),ys); _ -> Nothing) [1..6]
13:18:43 <lambdabot>   [(1,2),(3,4),(5,6)]
13:21:28 <kamyzi`e> thanks, is there an easy way to generalize this for groups other than 2?
13:22:42 <shurikas> hmm this strange thing... if Haskell compiles, it's most likely to work as expected. is it also like that for you?
13:23:05 <elliott> That's a common experience.
13:23:10 <shurikas> ok
13:23:11 <elliott> It isn't universally true, though :P
13:23:23 <shurikas> yeah, I just remembered my experience today a few hours ago
13:23:35 <shurikas> when code compiles and is logically correct, but doesn't work
13:23:56 <shurikas> because of float being formatted as 1.0e200 or something
13:25:10 <mauke> kamyzi`e: not with tuples
13:26:16 <shachaf> elliott: Well-typed programs work by definition.
13:27:45 <kamyzi`e> hmm, I'm probably approaching it the wrong way. I've got a file and I'd like to read every n lines as one group.
13:28:55 <mauke> http://hackage.haskell.org/packages/archive/split/0.1.4.1/doc/html/Data-List-Split.html#v:splitEvery
13:28:57 <applicative> kamyzi`e: you don't want a tuple probably
13:29:06 <applicative> mauke! http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
13:29:24 <yitz> > let groupsOf n = map (take n) . takeWhile (not . null) . iterate (drop n) in groups of 3 [1..10]
13:29:25 <lambdabot>   <no location info>: parse error on input `of'
13:29:31 <yitz> > let groupsOf n = map (take n) . takeWhile (not . null) . iterate (drop n) in groupsOf 3 [1..10]
13:29:32 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
13:31:29 <yitz> kamyzi`e: you'll probably be reading in your data as some kind of text or bytestring. those libraries define chunksOf, which is like groupsOf
13:32:34 <kamyzi`e> yitz: I'm using readFile in addition to lines and working on the file as a list. It feels kinda wrong though
13:33:27 <yitz> kamyzi`e: it's ok to start with. you can combine that with groupsOf, or splitEvery from the split library as mauke suggests
13:33:53 <Sgeo> I heard something about it being a bad idea to install haskell-platform from the distro. Is there any information about this?
13:34:04 <elliott> http://www.vex.net/~trebla/haskell/sicp.xhtml ?
13:34:14 <kamyzi`e> ok, thanks for all the help
13:34:29 <ion> “SICP” is a pun, right? :-D
13:35:20 <sbi> i bet so
13:37:07 * Sgeo surrenders his sanity
13:37:10 <snappy> 1
13:37:41 * shurikas has lost his long ago
13:39:06 <applicative_> > let prechunk n [] = Nothing; prechunk n xs = Just  (take n xs, drop n xs) ; chunk n = unfoldr (prechunk n) in chunk 5 "hello world"
13:39:07 <lambdabot>   ["hello"," worl","d"]
13:42:12 <Sgeo> What's the recommended way to install Haskell Platform then?
13:43:12 <elliott> Sgeo: Through your distro.
13:43:23 <elliott> But if you want to install anything else, best to compile it from source.
13:43:29 <Sgeo> elliott, didn't you once tell me that thats not the recommended way?
13:43:40 <elliott> It's certainly the recommended way, it's just not very useful.
13:43:49 <elliott> Since using it with "cabal install" is not a terribly good idea.
13:45:55 * hackagebot histogram-fill 0.5.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.5.1 (AlexeyKhudyakov)
14:00:45 <siracusa> Anyone knows if pandoc is supposed to accept TeX input as LaTeX input?
14:01:32 <augur> anyone know anything about automatic discovery of predicate definitions?
14:01:36 <augur> especially recursive ones?
14:02:53 <irene-knapp> hm
14:03:04 <irene-knapp> no, I don't, but it sounds cool
14:04:38 <_oz> augur: what do you mean by that?
14:05:19 <augur> _oz: like, suppose you specify that some predicate P holds of some pieces of data
14:05:34 <augur> and you know that P can be defined recursively
14:05:39 <augur> like, say, odd
14:06:16 <augur> are there ways to get a computer to discover the recursive definition, just from inspecting the data
14:06:35 <irene-knapp> hmm
14:06:38 <irene-knapp> interesting idea
14:07:12 <_oz> so you want to give "example"s of the behaviour of your function
14:07:23 <_oz> and you want the definition to be inferred
14:07:27 <augur> sure, thats one way of putting it
14:07:43 <t4nk789> what is the difference between "/0" and let postNum = [0..]!!0; ("/" ++ show postNum) ? the first one works, the second one does not.
14:07:59 <_oz> sth like: odd = { 3 -> True, 5 -> True, 4 -> False }
14:08:09 <mauke> what do you mean by "does not work"?
14:08:14 <_oz> odd(6) = False is to be inferred
14:08:18 <t4nk789> gives an error
14:08:23 <mauke> what error?
14:08:33 <ddarius> @google inductive logic programming
14:08:34 <lambdabot> http://en.wikipedia.org/wiki/Inductive_logic_programming
14:08:34 <t4nk789> Couldn't match expected type `H.AttributeValue'  with actual type `[Char]'
14:08:34 <lambdabot> Title: Inductive logic programming - Wikipedia, the free encyclopedia
14:08:54 <augur> _oz: or better, just give it like
14:09:07 <mauke> t4nk789: oh, are you using OverloadedStrings?
14:09:09 <augur> odd 0 = false, odd (suc 0) = true, odd (suc (suc 0)) = false, ...
14:09:20 <t4nk789> yes
14:09:23 <augur> and let it go
14:09:38 <_oz> i see
14:09:48 <augur> give it a bunch of data points
14:09:51 <monochrom> (++) and show etc. do String only.
14:09:56 <augur> and have it come up with the definition
14:09:59 <augur> odd 0 = false
14:10:11 <augur> odd (suc n) = neg (odd n)
14:10:12 <mauke> t4nk789: what is H?
14:10:21 <_oz> i vaguely remember something similar to this idea
14:10:26 <t4nk789> import qualified Text.Blaze.Html5 as H
14:10:46 <_oz> but that's as far as it goes unfortunately
14:10:48 <augur> _oz: if you think of anything, ping me or hit me with a private message
14:10:55 <_oz> i will
14:11:59 <ddarius> http://www.doc.ic.ac.uk/~shm/progol_mult_example_in.html
14:15:04 <mauke> t4nk789: ok, looks like there's several ways to do this
14:15:20 <mauke> t4nk789: if I'm reading the docs right, you're supposed to use toValue
14:17:10 <t4nk789> thank you, it works
14:20:58 <hpaste> “Mukesh Tiwari” pasted “Num class instance” at http://hpaste.org/54299
14:21:20 <keep_learning> Hello all
14:21:40 <keep_learning> I am trying to make a vector data to instance of Num class but getting error.
14:21:55 <keep_learning> Could some one please tell me what is wrong with this http://hpaste.org/54299
14:22:31 <copumpkin> you don't need a type signature there
14:22:33 <copumpkin> take it out
14:22:51 <copumpkin> also, your definition is kind of wrong, but it won't complain about that
14:24:02 <keep_learning> copumpkin, We don't need to put type signature in instance declaration ?
14:24:20 <ddarius> Yes, that is a strange definition.
14:24:32 <ddarius> keep_learning: You aren't allowed to.
14:24:39 <ddarius> The type signature is already in the class definitino.
14:25:04 <ddarius> The error message is quite proper and accurate in it's statement.
14:25:08 <blackdog> I'm actually kind of shocked by how good that error message is.
14:25:15 <keep_learning> ddarius, copumpkin : thank you
14:25:16 <copumpkin> keep_learning: I don't see why it should be actively disallowed, but that's what the language says
14:25:55 * hackagebot OpenCLWrappers 0.0.0.1 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.0.0.1 (EmilKarlson)
14:26:06 <ddarius> I think the overall benefit from allowing that would be negative.
14:27:59 <ddarius> @pl dp bnds f = let a = runSTArray (newArray_ bnds >>= \ma -> mapM_ (\ix -> writeArray ma ix (f a ix)) (range bnds) >> return ma) in a
14:28:00 <lambdabot> dp = ((fix . (runSTArray .)) .) . ap ((.) . (.) . (>>=) . newArray_) (flip flip return . ((flip . (liftM2 (>>) .)) .) . flip (flip . ((flip . (mapM_ .) . flip (ap . writeArray)) .)) . range)
14:28:21 <ddarius> A little worse than I thought it would be.
14:28:40 <ddarius> @pl dp = let a = runSTArray (newArray_ bnds >>= \ma -> mapM_ (\ix -> writeArray ma ix (f a ix)) (range bnds) >> return ma) in a
14:28:40 <lambdabot> dp = fix (runSTArray . (newArray_ bnds >>=) . (`ap` return) . ((>>) .) . flip flip (range bnds) . (mapM_ .) . flip (ap . writeArray) . f)
14:34:32 <elliott> Beautiful.
14:34:44 <ddarius> It brings a tear to your eye.
14:35:01 <elliott> * hackagebot OpenCLWrappers 0.0.0.1 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.0.0.1 (EmilKarlson)
14:35:02 <Philonous> I wonder whether it wouldn't be a better plan to make Vector an instance of Applicative and then just lift the operations
14:35:04 <elliott> _two_ forks of the same thing?
14:35:45 <ddarius> newtype Vector a = Vector (Ordering -> a)
14:35:59 <ddarius> deriving ( everything )
14:39:55 <zenzike> I'm a little confused: I'm using HUnit to run some tests, using runTestTT: one of my first tests raises a Segmentation fault, and this stops all other tests that come after from being run: is this normal?
14:41:01 <monochrom> segfault is not normal
14:41:32 <zenzike> monochrom: the segfault isn't normal, no, but what I'm finding strange is that HDBC isn't able to do the tests after the broken one
14:41:48 <zenzike> monochrom: (but HDBC is able to provide summary data)
14:41:50 <copumpkin> segfaults aren't really recoverable
14:41:51 <ddarius> "I run some tests, and after the first one my computer explodes and burst into flames, and this stops all other tests that come after from being run: is this normal?
14:41:51 <ddarius> "
14:42:11 <copumpkin> lol
14:42:12 <ddarius> copumpkin: Sure they are.
14:42:23 <copumpkin> you can catch them in a signal handler, but then what?
14:42:37 <copumpkin> when your handler returns, the program exits, so either you longjmp somewhere else
14:42:50 <copumpkin> or you do some serious voodoo using system-specific APIs
14:42:52 <monochrom> then try again. maybe will hit another segfault. worth a try
14:42:52 <zenzike> ddarius: well, I'd image that a test harness would be able to recover: and indeed it does, since summary data is reported.
14:42:55 <elliott> copumpkin: You can use segfaults to do allocation.
14:43:19 <copumpkin> I was actually using segfaults in my MPFR allocator for haskell
14:43:24 <copumpkin> I wouldn't call it pretty
14:43:24 <mauke> copumpkin: I don't think it'll exit
14:43:41 <copumpkin> mauke: hmm, maybe not
14:43:57 <ddarius> Segfaults are just access denied errors.  Admittedly, usually they are the result of some kind of corruption that renders recovery not very likely.
14:44:50 <geheimdienst> zenzike: i agree that it shouldn't just throw its hands up in the air at the first tiny sign of trouble. however in this case, recall that a segfault is severe and unusual, so it is somewhat reasonable that it says "things are so wrong that you first need to fix this segfault"
14:45:01 * monochrom remembers a Star Trek TNG epsiode of getting trapped in a strange time loop, so: travel for a while, get into some accident, segfault^H^H^H^H^H^H^H^H explode, thrown back in time, repeat.
14:45:48 <geheimdienst> monochrom: i can empathize with that a lot. cf. for instance our weekly debates of what a monad "really is"
14:46:01 <zenzike> geheimdienst: hmm. point taken. I just find it odd that HUnit is still able to print summary data about the failed test, and the fact that it coudln't do any more, ie it was able to proceed
14:46:39 <zenzike> err, I should say, able to proceed after the segfault, but not able to proceed testing
14:47:21 <elliott> zenzike: The HUnit developers have probably never even considered that tests might segfault.
14:47:24 <geheimdienst> zenzike: yeah. i don't know hunit specifically, but i'd guess that it forks a second process to run the tests. the process segfaults, and the main process prints the results
14:47:26 <elliott> That's not really a thing that happens a lot in Haskell.
14:47:41 <geheimdienst> (restarting the second process would probably be pointless, as it would likely lead to just the same segfault again)
14:47:43 <zenzike> ie, the last thing it says is: Cases:61 Tried:1 Errors:0 Failures:0 Segmentation fault
14:48:09 <zenzike> hmm okay thanks, I'll start burying deeper :-)
14:48:29 <ddarius> "burrowing"?
14:48:33 <zenzike> /burying/burrowing
14:49:09 <geheimdienst> maybe try to run the test cases without hunit's runner. this should help you determine if it's a bug in hunit, or a bug in your test cases
14:49:23 <zenzike> (though it feels like my protesting about segfaults has been burying myself in this thread! :-)
14:49:39 <zenzike> geheimdienst: thanks, it's definitely a bug in my test case
14:50:00 <zenzike> geheimdienst: I was just surprised that HUnit was only able to partially recover
14:50:25 <zenzike> (I'd have expected full or no recovery ... not something in between!)
14:53:28 <djanatyn> I never realized that we could use ($0) in partial function application
14:53:32 <djanatyn> ermm, ($)
14:55:45 <elliott> ($) is just another operator :)
14:56:06 <mauke> :t flip id 0
14:56:07 <lambdabot> forall a b. (Num a) => (a -> b) -> b
14:57:17 <ddarius> :t (`id`0)
14:57:18 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
14:57:44 <mauke> see? ugly type variables
14:58:39 * ddarius isn't sure what prompted that reply from mauke.
14:59:01 <ion> Hitler.
15:04:30 <dr_rotflcopter> hey ion
15:04:34 <dr_rotflcopter> Your very first kiss was your first kiss goodbye... ooooo you're a lonely guuy ooooo
15:05:02 <homie> lol
15:05:50 <homie> (incf dr_rotflcopter)
15:06:02 --- mode: ChanServ set +o mauke
15:06:03 --- mode: mauke set -b *!*@gateway/web/freenode/ip.71.189.7.58
15:06:53 --- mode: mauke set -o mauke
15:07:52 <elliott> homie: does lambdabot parse lisp? :p
15:08:07 <homie> depends....
15:08:18 <elliott> @karma dr_rotflcopter
15:08:18 <lambdabot> dr_rotflcopter has a karma of 0
15:08:23 <homie> if you give him cookies maybe....
15:08:24 <homie> lol
15:08:30 <dr_rotflcopter> :)
15:08:54 <dr_rotflcopter> whats a karma?
15:09:27 <ddarius> @karma lwall
15:09:27 <lambdabot> lwall has a karma of 530
15:09:29 <homie> that's your associated value in the nirvana state
15:09:35 <homie> lol
15:09:46 <dr_rotflcopter> kool
15:09:55 <dr_rotflcopter> can i change it to valuta ?
15:10:15 <dr_rotflcopter> or i have to sell a soul for it?
15:10:47 <ion> > (length (show (subtract 5 (read "42"))))
15:10:48 <lambdabot>   2
15:14:04 <dr_rotflcopter> i still feel like deriving the general function for intersection area of a square and a circle with every parameter as a variable
15:16:08 <roaldfre> Hi guys, quick question: can I "make a typeclass implement a typeclass"? (ie, I made a typeclass "NumTuple x t" that represents numerical n-tuples (type 't') with elements of type 'x'. I'd like to make that tuple type 't' an instance of show)
15:16:43 <ddarius> dr_rotflcopter: Then do it.  Should take twenty minutes or so.
15:16:49 <dr_rotflcopter> ;<
15:16:59 <dr_rotflcopter> im kindof stucked
15:17:39 <elliott> roaldfre: Your question doesn't make much sense, but you probably can't do what you want.
15:17:48 <dr_rotflcopter> don't have a clue about area intersection deriving of vectorgraphic functions yet
15:17:51 <elliott> roaldfre: You can require that t has a Show instance, though, in the NumTuple definition.
15:17:52 <dr_rotflcopter> ;/
15:18:30 <dr_rotflcopter> ddarius<< any hint?
15:18:33 <homie> type derivation.....
15:18:46 <newsham> rofl: what about the area of a half plane intersected with a circle?
15:21:25 <roaldfre> elliott: the point is, I have all the functions I need in the typeclass itself, so I can define a function 'showTuple' that does the trick. I'll see what adding the requirements for Show t does (can i define the show function in the typeclass itself? will try now)
15:21:42 <elliott> roaldfre: No, but you can provide showTuple, and then the instances becomes as simple as
15:21:48 <elliott> instance Show ... where show = showTuple
15:21:50 <elliott> for each t.
15:22:01 <dr_rotflcopter> newsham<< i have no problem with the intersection of the circle, ... i can even do shortcuts about', but with the square? ... ;/
15:22:08 <roaldfre> is there a way to parametrize thaat 'for each t'?
15:22:24 <dr_rotflcopter> the square contains infinite number of harmonics if you want to write a function
15:22:34 <newsham> rofl: what if you start with a circle and keep lopping off half planes four times?
15:23:50 <bluej774> Is there some type of built-in list function that would take "ijk" and return "jki"?
15:23:55 <roaldfre> elliott: I've tried something like "instance (NumTuple x t) => Show t" but ghc complains about too many variables and undecidable types
15:24:03 <elliott> roaldfre: You can't do that.
15:24:45 <newsham> ?hoogle [a] -> ([a],[a])
15:24:45 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:24:46 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:24:46 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
15:25:07 <roaldfre> hmmh
15:25:19 <bluej774> ?hoogle [a] -> [a]
15:25:20 <lambdabot> Prelude cycle :: [a] -> [a]
15:25:20 <lambdabot> Data.List cycle :: [a] -> [a]
15:25:20 <lambdabot> Prelude init :: [a] -> [a]
15:25:37 <bluej774> :( guess not.
15:25:57 <companion_cube> not built-in, but you can easily write a function  which does
15:26:02 <copumpkin> > (tail . cycle) "ijk"
15:26:04 <lambdabot>   "jkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijkijk...
15:26:13 <ion> > > permutations "ijk" !! 3
15:26:14 <lambdabot>   <no location info>: parse error on input `>'
15:26:18 <ion> > permutations "ijk" !! 3
15:26:19 <lambdabot>   "jki"
15:26:39 <companion_cube> > const "jki" "ijk"
15:26:40 <lambdabot>   "jki"
15:26:43 <companion_cube> \o/
15:26:46 <ion> :-)
15:26:50 <copumpkin> > let f xs = map snd . zip xs . tail . cycle $ xs in f "ijk"
15:26:52 <lambdabot>   "jki"
15:27:09 <bluej774> (tail xs) ++ [head xs]
15:27:12 <bluej774> seems expensive
15:27:30 <ion> And unsafe
15:27:38 <bluej774> Why unsafe?
15:27:41 <companion_cube> well it's linear
15:27:42 <newsham> > let f n = uncurry (++) . (drop n &&& take n) in f 1 "testing"
15:27:44 <lambdabot>   "estingt"
15:27:44 <ion> (Not really that expensive, though.)
15:27:48 <companion_cube> unsafe because you use "head"
15:27:55 <companion_cube> if the list is empty it crashes
15:27:56 <ion> > let xs = [] in tail xs ++ [head xs]
15:27:58 <lambdabot>   *Exception: Prelude.tail: empty list
15:28:01 <bluej774> Okay, true.
15:28:04 <newsham> > let f n = uncurry (++) . (drop n &&& take n) in f 1 ""
15:28:06 <lambdabot>   ""
15:28:13 <elliott> > let f [] = []; f (x:xs) = xs ++ [x] in f "ijk"
15:28:14 <lambdabot>   "jki"
15:28:24 <Sgeo> let f (x:xs) = xs ++ [x]; f [] = [] in f "ijk"
15:28:28 <Sgeo> > let f (x:xs) = xs ++ [x]; f [] = [] in f "ijk"
15:28:30 <lambdabot>   "jki"
15:28:30 <newsham> > let f n = uncurry (++) . (drop n &&& take n) in f 4 "testing"
15:28:31 <Sgeo> Blargh
15:28:32 <lambdabot>   "ingtest"
15:28:34 <bluej774> Nice one, elliot
15:28:51 * Sgeo honestly did not see elliott's first
15:28:55 <bluej774> But just as expensive.
15:29:02 <elliott> bluej774: It's not that expensive.
15:29:07 <elliott> It's about as expensive as (++).
15:29:08 <ion> Has profiling shown it’s too expensive for your purposes?
15:29:11 <elliott> Plus a really, really, really tiny constant factor.
15:29:20 <copumpkin> if you want to append shit, don't use lists
15:29:25 <elliott> Unless a single (xs ++ ys) makes you scream "expensive!", don't worry about it.
15:29:29 <dr_rotflcopter> newsham<< well that'd be cool if the square is inside the circle :)
15:29:34 <bluej774> True enough, copumpkin
15:29:36 <ion> elliott: It seems it does. :-)
15:29:36 <elliott> copumpkin: that's a great recipe for getting a program that's slower because Seq has higher overhead and is strict :)
15:30:20 <copumpkin> elliott: depends what you're doing, obviously
15:30:25 <mauke> > liftA2 (liftA2 (++)) drop take 1 "testing"
15:30:27 <lambdabot>   "estingt"
15:30:31 <mauke> > liftA2 (liftA2 (++)) drop take 1 ""
15:30:32 <roaldfre> related to that NumTuple question: I'm also composing those tuples to make matrices. I'm using a 'Mult' class like here: http://www.haskell.org/haskellwiki/Functional_dependencies to get the multiplications 'unified' for the different cases (I call the operator (.*.) so it doesn't clash with (*) from Prelude)  I'd like to do something similar for sums between tuples and sums between matrices (both with operator (.+.)). The way I see it now is 
15:30:33 <lambdabot>   ""
15:30:39 <elliott> mauke: heh, nice
15:30:39 <roaldfre> (woah, sorry for wall of text)
15:30:42 <companion_cube> elliott: i thought strictness was generally a good thing for performance?
15:30:48 <Sgeo> Is there a smaller than O(n) way to do it?
15:30:48 <ion> > snd . (<*>) zip (cycle . drop 1) $ "testing"
15:30:49 <lambdabot>   Couldn't match expected type `(a, b)'
15:30:49 <lambdabot>         against inferred type `[(a1, ...
15:30:51 <companion_cube> (apart from lazy data structs like finger trees)
15:31:15 <ion> > zipWith snd <*> cycle . drop 1 $ "testing"
15:31:16 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b -> c)
15:31:22 <bluej774> companion_cube, finger trees = gross visual
15:31:41 <Sgeo> @src cycle
15:31:42 <lambdabot> cycle [] = undefined
15:31:42 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:31:44 <elliott> companion_cube: so what you're saying is, you thought strictness was good except when using laziness?
15:31:53 <Sgeo> cycle is just as expensive
15:32:02 <elliott> companion_cube: very true! strictness does indeed help in the cases where laziness doesn't help :)
15:32:27 <ion> > zipWith const =<< cycle . drop 1 $ "testing"
15:32:27 <dr_rotflcopter> newsham<< how about circle cuts a part out from a square? from any direction
15:32:28 <lambdabot>   "estinge"
15:32:40 <ion> eh, crap
15:32:45 <ion> > zipWith const =<< drop 1 . cycle $ "testing"
15:32:46 <lambdabot>   "estingt"
15:33:25 <newsham> rofl: start with the full circle, chop it off by intersecting with a half plane
15:33:33 <newsham> then chop the result off by intersecting with another half plane
15:33:36 <newsham> repeat 2 more times
15:33:58 <dr_rotflcopter> i have problem when the corner gets chopped
15:34:02 <dr_rotflcopter> by the circle ;<
15:34:13 <Sgeo> I assume no one is trying to find a more efficient than O(n) solution to the problem?
15:34:21 <newsham> nothing is getting cut by the circle.. everything is getting cut  by the square's edges
15:34:29 <companion_cube> elliott: I meant, in cases the lazyness is an explicit part of the algorithm :p
15:34:40 <companion_cube> which is not so often
15:34:49 <dr_rotflcopter> newsham<< ok im trying
15:34:49 <newsham> sgeo: x = *p++; p[n] = x; return p;
15:34:53 <elliott> I think it is quite often indeed in idiomatic code :)
15:35:08 <ddarius> companion_cube: There are plenty of times laziness is beneficial for performance even when you aren't relying on it.
15:35:53 <ddarius> Sgeo: There is no better than O(n) algorithm when your input is a string.  You have to at least read in all the input.
15:36:00 <Sgeo> Indeed
15:36:08 <newsham> ddarius: what about my soln above?
15:36:26 <Sgeo> So the ++ solution that elliott and I wrote is possibly clearest? Or are we going for clever now?
15:37:19 <ddarius> Sgeo: The cycle version, though, gives you -all- rotations.
15:37:43 <ion> The zipWith, cycle thing isn’t even clever. :-P Better to do drop n xs ++ take n xs if you want an arbitrary rotation.
15:37:55 <newsham> ion: thats what i did
15:38:00 <ion> Yes.
15:38:03 <ddarius> newsham: Your solution doesn't take a Haskell String.
15:38:07 <mauke> is there a way to eliminate the double liftA2 from my version?
15:38:22 <ddarius> uncurry?
15:38:37 <mauke> huh?
15:39:06 <ddarius> > liftA2 (++) (uncurry drop) (uncurry take) (1, "testing")
15:39:08 <lambdabot>   "estingt"
15:39:16 <mauke> ew
15:39:28 <newsham> ok, now how about rotate 1 in the other direction...
15:40:09 <newsham> "testing" -> "gtestin"
15:40:34 <mauke> > liftA2 (liftA2 (++)) drop take 6 "testing"
15:40:36 <lambdabot>   "gtestin"
15:40:36 <Sgeo> Will only work on finite lists
15:40:38 <elliott> that's slow by necessity
15:40:55 <newsham> rotate left 6 != rotate right 1.
15:41:17 <newsham> no cheating
15:41:50 <Sgeo> How to avoid making it crawl the list twice...
15:41:56 <Sgeo> Both easy solutions I thought of do that
15:42:10 <elliott> You can't.
15:42:14 <elliott> Well.
15:42:19 <elliott> You can, yes.
15:42:25 <mauke> :t join (liftA2 (liftA2 (++)) drop take . mod (-1) . length)
15:42:27 <lambdabot> forall a. [a] -> [a]
15:42:32 <mauke> > join (liftA2 (liftA2 (++)) drop take . mod (-1) . length) "testing"
15:42:34 <lambdabot>   "gtestin"
15:42:36 <shachaf> > (uncurry (flip (++)) . splitAt 6) "testing"
15:42:38 <lambdabot>   "gtestin"
15:42:47 * shachaf tries to figure out context.
15:42:50 <mauke> > join (liftA2 (liftA2 (++)) drop take . mod (2) . length) "testing"
15:42:51 <lambdabot>   "stingte"
15:43:05 <ion> > liftA2 (liftA2 (liftA2 (++)) drop take) (subtract 1 . length) id "testing"
15:43:07 <lambdabot>   "gtestin"
15:43:13 <newsham> ?hoogle (a,b) -> (b,a)
15:43:13 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
15:43:14 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:43:14 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:43:14 <ion> (TBH, I did that just to get a third liftA2.)
15:43:50 <shachaf> *Adding* liftA2s is no great feat.
15:43:57 <bluej774> Holy crap.  I looked away for a few minutes and not only are you guys still talking about my question, you're coming up with ridiculously complex solutions to it.
15:44:01 <ion> shachaf: REALLY?
15:44:09 <shachaf> You can substitute liftA for every (.), too.
15:44:10 <bluej774> (I'm new here. ;-)
15:44:11 <newsham> blue: you dont play golf?
15:44:13 <ddarius> bluej774: We've moved on to a slightly different question.
15:44:22 <ion> This is not golf. :-D
15:44:26 <CakeProphet> > var . unlines $ fix (("ha. ":) . scanl (++) "ha. ") -- spammable exploit you might want to address. kthxbai
15:44:27 <lambdabot>   ha.
15:44:27 <lambdabot>  ha.
15:44:28 <lambdabot>  ha. ha.
15:44:28 <lambdabot>  ha. ha. ha.
15:44:28 <lambdabot>  ha. ha. ha. ha. ha.
15:44:29 <lambdabot>  ha. ha. ha. ha. h...
15:44:39 <bluej774> newsham, usually if I golf, I try to get the code smaller.
15:44:57 <elliott> bluej774: Here in Haskell, we golf to remove points.
15:45:14 <newsham> or remove iterations over a list
15:45:15 <elliott> @pl \xs -> if null xs then [] else tail xs ++ [head xs]
15:45:16 <lambdabot> ap (flip if' [] . null) (liftM2 (++) tail (return . head))
15:45:20 <elliott> bluej774: See? Beautiful.
15:45:26 <hpc> :t var
15:45:28 <lambdabot> forall a. String -> Sym a
15:45:38 <newsham> > text "this is text"
15:45:39 <lambdabot>   this is text
15:46:01 <ddarius> There are a lot of ways to get lambdabot to spew a lot of text.
15:46:07 <ion> @pl \xs null tail head -> if null xs then [] else tail xs ++ [head xs]
15:46:08 <lambdabot> ap (flip . (((.) . (.)) .) . flip flip [] . (if' .) . flip id) (ap (flip . (((.) . (++)) .) . flip id) (flip flip [] . ((:) .) . flip id))
15:46:20 <elliott> bluej774: Perfect golfing from ion there.
15:46:27 <elliott> flip (ap (flip . (((.) . (.)) .) . flip flip [] . (if' .) . flip id) (ap (flip . (((.) . (++)) .) . flip id) (flip flip [] . ((:) .) . flip id))) null tail head
15:46:29 <elliott> The complete solution.
15:46:40 <elliott> :t ap (flip . (((.) . (.)) .) . flip flip [] . (if' .) . flip id) (ap (flip . (((.) . (++)) .) . flip id) (flip flip [] . ((:) .) . flip id))
15:46:41 <ddarius> ion still has (++)
15:46:42 <bluej774> elliott, is that really any less computationally complex?
15:46:44 <lambdabot> Not in scope: `if''
15:46:47 <elliott> bluej774: Heck no.
15:46:53 <elliott> :t let if' a b c = if a then b else c in ap (flip . (((.) . (.)) .) . flip flip [] . (if' .) . flip id) (ap (flip . (((.) . (++)) .) . flip id) (flip flip [] . ((:) .) . flip id))
15:46:54 <lambdabot> forall a a1. a -> (a -> Bool) -> (a -> [a1]) -> (a -> a1) -> [a1]
15:47:01 <bluej774> elliott, didn't think so
15:47:14 <elliott> ddarius: Aww man, we need to monoid that up.
15:47:40 <elliott> @pl \xs null tail head mempty mappend pure -> if xs == mempty then mempty else tail xs `mappend` pure (head xs)
15:47:41 <lambdabot> const . ap ((.) . (.) . flip . (((.) . (.)) .) . join . (if' .) . (==)) (ap (flip . (((.) . flip . ((.) .) . flip id) .) . flip id) ((flip id .) . flip id))
15:47:51 <elliott> :t let if' a b c = if a then b else c in const . ap ((.) . (.) . flip . (((.) . (.)) .) . join . (if' .) . (==)) (ap (flip . (((.) . flip . ((.) .) . flip id) .) . flip id) ((flip id .) . flip id))
15:47:52 <newsham> je m'append
15:47:52 <lambdabot> forall b b1 a a1 b2. (Eq b1) => b1 -> b -> (b1 -> a) -> (b1 -> a1) -> b1 -> (a -> b2 -> b1) -> (a1 -> b2) -> b1
15:47:56 <elliott> That's more like it.
15:48:07 <bluej774> I don't think this is golf.  I think this is a new game called 'aspirin'.  See if you can guess why.
15:48:26 <elliott> So it gets rid of your headache?
15:48:51 <dschoepe> elliott: only if it's pointless enough *scnr*
15:48:51 <bluej774> :-P
15:49:13 <ion> scenery?
15:49:28 <elliott> scorner
15:49:30 <mehitabel> are there good examples on github of people making heavy use of monads, comonads, or other category-theoretic features in real software?
15:49:36 <dschoepe> ion: sorry, could not resist. (I know that pointless-pun has been done to death, but anyways)
15:49:51 <newsham> monads get used all the time
15:49:51 <ddarius> scanr
15:50:10 <ddarius> As do Functors and Applicative functors.
15:50:22 <ddarius> (Of course, all monads are both of those.)
15:51:29 <mehitabel> I know category theory, my background is in math -- I'm just looking for examples, "pudding"
15:52:15 <ddarius> mehitabel: Pretty much any code at all will use monads.
15:52:23 <newsham> applicative functors are used often in making parsers.  monads are used in haskell's imperative code
15:52:39 <ddarius> mehitabel: You may also want to look at Trifecta.
15:53:46 <ddarius> @hackage trifecta
15:53:46 <lambdabot> http://hackage.haskell.org/package/trifecta
15:54:37 <newsham> meh: like a small program:  main = putStr =<< unpackBS . encode . join <$> (mapM readDailys =<< getArgs)
15:55:16 <newsham> using =<< and mapM for moands, using <$> which is for applicative (which is basically just fmap from functor)
15:55:36 <newsham> oh and join from monad
15:56:01 <ddarius> @hackage profunctor
15:56:02 <lambdabot> http://hackage.haskell.org/package/profunctor
15:56:23 <ddarius> Damn pluralisation.
15:56:26 <elliott> mehitabel: You may enjoy http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html.
15:56:48 <elliott> ("comonadic", the title ends.)
15:58:53 <mehitabel> elliott: yes indeed, that's what sent me down the rabbit hole!
15:59:00 <elliott> heh
15:59:39 <elliott> mehitabel: I think a lot of people tend to react badly to "what are some practical uses of [category theoretical concept]" around Haskell parts because it's so often used as a blanket dismissal of the language :P
16:00:39 <companion_cube> why bother with complicated abstractions like monads, when you can enjoy the taste of the sun on your skin?
16:01:19 <elliott> @remember companion_cube why bother with complicated abstractions like monads, when you can enjoy the taste of the sun on your skin?
16:01:19 <lambdabot> I will never forget.
16:01:38 <dr_rotflcopter> newsham<< thanks for hint;> i think im beginning to see the light at the end of the tunnel
16:02:03 <dr_rotflcopter> well at least it willbe a working solution
16:02:40 <dr_rotflcopter> though i really would like a function that needs no looping
16:04:03 <dr_rotflcopter> but i see the square has area enclosed by 4 lines
16:04:27 <dr_rotflcopter> so it cuts out a square outof the plane
16:04:33 <mehitabel> elliott: I'm not on the warpath, I actually really like the language and it fits my brain -- category theory was sort of my first love in mathematics
16:04:47 <elliott> mehitabel: yeah, just a note :-)
16:05:04 <elliott> I think it's a good question to ask, just one that's usually asked with different intent.
16:05:10 <dr_rotflcopter> the max(x,y)=1 makes the brainfuck feeling
16:06:19 <ddarius> mehitabel: How familiar are you with complex analysis?
16:07:19 <ddarius> elliott: I don't think anyone responded poorly.
16:07:44 <elliott> ddarius: I agree, but I think it's quite likely that someone might elsewhere or at different times or whatever.
16:07:55 <mehitabel> ddarius: I've taught it
16:10:00 <ddarius> mehitabel: You don't find complex analysis pretty?
16:13:16 <mehitabel> ddarius: it's beautiful, yes
16:15:49 <ddarius> My list of mathematics I "love" would probably be, in no particular order: category theory, complex analysis, geometric algebra/calculus, and combinatorial species, though these aren't at all separate.
16:19:08 <mehitabel> ddarius: I want to learn comb. species -- I was working with operads a lot for the last couple of years which seems like all the same work without the satisfaction
16:23:04 <dylex> what would you name sortBy and groupBy fst :: [(a,b)] -> [(a,[b])]
16:23:31 <ddarius> sortBy fst and groupBy fst
16:24:41 <dylex> yes, but what would you call it.  I guess it's already Data.List.Rosso1.alistCollect
16:24:42 <shachaf> ddarius: Imaginative.
16:24:46 <azaq23> @type groupBy fst
16:24:47 <lambdabot>     Occurs check: cannot construct the infinite type:
16:24:47 <lambdabot>       a = (a, b) -> Bool
16:24:47 <lambdabot>     Probable cause: `fst' is applied to too many arguments
16:25:17 <Jafet> MultiMap
16:25:17 <dylex> @type groupBy ((==) `on` fst)
16:25:18 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
16:26:05 <dylex> also Swish.Utils.ListHelpers.pairGroup. oh well.
16:50:47 * ddarius huggles data uris.
16:51:34 <shachaf> @context ddarius
16:51:35 <lambdabot> Unknown command, try @list
16:52:58 <sxramano> hello there, i'd like to use submaps (like C-x in emacs) in GTK-app; is it sane to use MVar for saving current submap (if any)?
16:54:06 * ddarius huggle pnm tools.
16:54:44 <ddarius> shachaf: I wanted to add an image to as a signature in GMail, but the web version only allows linking to other images.
17:04:37 <dmwit> sxramano: IORef is probably enough. Everything in the gtk main loop has to run on the same thread anyway.
17:06:39 <ddarius> heist template syntax seems to conflict strongly with usual jquery syntax.
17:09:28 <irene-knapp> gah
17:09:46 <irene-knapp> I did something to the GHC build system that is triggering a build failure due to some sort of DPH thing
17:10:05 <jerry> guys can you use guards inside do statement
17:10:10 <irene-knapp> seems this is a bug that has been plaguing them for a while, but ha been successfully papered over
17:10:30 <shapr> irene-knapp: Now you have a chance to fix it!
17:10:37 <irene-knapp> indeed!  I'm so excited!  haha
17:12:57 <ddarius> jerry: You can use guards on any definition.
17:13:31 * shapr looks guarded
17:15:01 <hpaste> stribor pasted “stribor” at http://hpaste.org/54302
17:15:22 <jerry> ddarius: i did this ^ but it ghci complains my identitation is wrong
17:17:59 <scooty-puff> could someone help me derive Typeable and Data for:
17:18:18 <hpaste> scooty-puff pasted “Derive Data, Typeable” at http://hpaste.org/54303
17:18:38 <scooty-puff> using standalone deriving or regular deriving doesn't seem to quite work
17:18:54 <scooty-puff> (can syb deal with class constraints on the queries?)
17:21:26 <hpaste> stribor pasted “do statement with guards” at http://hpaste.org/54304
17:21:38 <jerry> can you do guards inside do like above ^
17:22:17 <ddarius> jerry: What would that even mean?
17:22:39 <monochrom> not like that
17:22:46 <jerry> ddarius: ?
17:23:15 <jerry> ddarius: i am getting this error ->  parse error on input `|'
17:23:19 <monochrom> > do { Just x | x>0 <- return (Just 10); [x] }
17:23:21 <lambdabot>   <no location info>: parse error on input `|'
17:23:39 <ddarius> Guards are part of definition syntax not pattern syntax.
17:23:48 <ddarius> Well, that's not completely true.
17:23:49 <monochrom> ah alright
17:24:15 <jerry> ddarius: so how do i inside do statement deal with guards or case where i want to have different options
17:24:56 <irene-knapp> ah-HAH!
17:25:02 * irene-knapp discovers ghc/rules/trace.mk
17:26:14 <mauke> > do { Just x <- return (Just 10); guard $ x > 0); [x] }
17:26:15 <lambdabot>   <no location info>: parse error on input `)'
17:26:22 <mauke> > do { Just x <- return (Just 10); guard $ x > 0; [x] }
17:26:23 <lambdabot>   [10]
17:27:29 <ddarius> jerry: case is an expression form, you can use it anywhere an expression is expected.  Expressions are statements.
17:28:28 <ddarius> Guards can be attached to any definition or alternative, and so could be used in a let or a case inside a do-block.
17:29:17 <jerry> ddarius: thank you
17:36:19 <dr_rotflcopter> whaat do you think about
17:36:20 <dr_rotflcopter> a=(x>y)?~0:0;
17:36:27 <dr_rotflcopter> for... value=a&44+a~55
17:36:33 <dr_rotflcopter> instead of ifs in loop ?
17:36:53 <mauke> is that related to haskell in any way?
17:45:24 <dmwit> Is a&44+a~55 even valid?
17:46:58 <mauke> no, it's a syntax error... in C...
17:47:06 <mauke> I may recognize this code.
17:47:07 <Draconx> and also in Haskell.
17:47:23 <elliott> > a&44+a~55
17:47:24 <lambdabot>   Not in scope: `&'Pattern syntax in expression context: ~55
17:47:36 <elliott> > let a&44+a~55 = () in ()
17:47:37 <lambdabot>   <no location info>: Parse error in pattern
17:47:37 <mauke> I think it's from a spoof interview with either stroustrup or kernighan/ritchie
17:48:50 <mauke> hmm, no
17:49:27 <mauke> that particular syntax error was for(;P("\n"),R-;P("|"))for(e=C;e-;P("_"+(*u++/8)%2))P("| "+(*u/4)%2);
17:50:36 <shachaf> mauke: That's invalid syntax? :-(
17:50:42 <mauke> the e-; part
17:50:43 <shachaf> I guess there's the "R-" and "e-".
17:50:53 * shachaf wonders if that was ever valid.
17:52:35 <elliott> shachaf: It's subtracting a semicolon.
17:52:58 <mauke> :-;=;
17:58:43 <bluej774> How can I get an infinite list where every element is a function applied to the previous element, except of course for the first element?
17:58:52 <dmwit> :t iterate
17:58:53 <lambdabot> forall a. (a -> a) -> a -> [a]
17:59:18 <dmwit> Great question, by the way.
17:59:39 <bluej774> Got it.  Thanks
17:59:42 <ddarius> > iterate f x
17:59:43 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
17:59:51 <mauke> @djinn foo f x = x : foo f (f x)
17:59:52 <lambdabot> Cannot parse command
17:59:56 <mauke> @pl foo f x = x : foo f (f x)
17:59:57 <lambdabot> foo = fix ((ap (:) .) . ((.) =<<))
18:00:27 <dmwit> ?pl \f x -> fix (\xs -> x : map f xs)
18:00:28 <lambdabot> (fix .) . flip ((.) . (:)) . map
18:00:32 <dr_rotflcopter> hah
18:00:48 <dr_rotflcopter> value=a&44+(~a)&55
18:00:49 <dr_rotflcopter> ?
18:00:55 <dr_rotflcopter> this should work
18:00:56 <mauke> dr_rotflcopter: hello.
18:00:57 <bluej774> what's the complexity of iterate?
18:01:02 <dr_rotflcopter> hey
18:01:13 <mauke> dr_rotflcopter: is that related to haskell in any way?
18:01:30 <dr_rotflcopter> its programming... ? functional ???
18:01:40 <mauke> is that a "no"?
18:01:53 <bluej774> dysfunctional, maybe.  zing! ;)
18:02:25 <dr_rotflcopter> its a "similar"
18:02:30 <shapr> It looks pretty simple to me.
18:02:39 <mauke> doesn't look anything like haskell
18:02:52 <blackdog> bluej774: linear in the amount of the list you use, plus however much your (a->a) function uses...
18:03:38 <byorgey> blackdog: in particular it really does just apply the function to the previous element to produce the next element each time, it does not recompute f (f (f (f ...  for each new element
18:03:58 <bluej774> byorgey, True.  Memoization really comes in handy here.
18:04:02 <blackdog> byorgey: yes. i hadn't even thought of that implementation :) how perverse
18:04:03 <byorgey> er, s/blackdog/bluej774/
18:04:06 <mauke> it's not memoization
18:04:08 <blackdog> bluej774: it's not memoization
18:04:17 <mauke> I can't believe it's not memoization!
18:04:20 <mauke> @src iterate
18:04:21 <lambdabot> iterate f x =  x : iterate f (f x)
18:04:47 <dr_rotflcopter> value=a and 44 + (not a) and 55
18:04:58 <bluej774> Oh, true.  I was thinking that in my case memoization should make is pretty much linear pretty quickly.
18:05:05 <bluej774> The function I'm using is:
18:05:19 <bluej774> roll (x:xs) = xs ++ [x]
18:05:35 <dr_rotflcopter> mauke<< looks neater ?
18:05:40 <mauke> dr_rotflcopter: no
18:06:03 <bluej774> If the list I give to roll is only 3 elements, after three runs memoization should kick in and make it almost free.
18:06:11 <dmwit> no
18:06:11 <mauke> what memoization?
18:06:13 <dmwit> sadly
18:06:24 <bluej774> dmwit, why not?
18:06:36 <blackdog> bluej774: it's important to differentiate between a function that re-uses previous results and a memoization strategy which remembers all the calls you ever made
18:06:40 <byorgey> Haskell has no built-in memoization
18:06:47 <dmwit> bluej774: Just look at the implementation. =)
18:06:51 <blackdog> if you enter 4+4 at the prompt, the next time you evaluate 4+4, it still has to do the work
18:07:04 <bluej774> WTF?  When did this happen!?
18:07:19 <blackdog> if you'd defined "x=4+4" instead, the first time you evaluate x, it does the work - after that it's free
18:07:48 <byorgey> > let roll (x:xs) = xs ++ [x]; rotations l = cycle . take (length l) . iterate roll $ l in rotations [1,2,3]
18:07:49 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[2,3,1],[3,1,2],[1...
18:07:53 <bluej774> What about the memoization type class?
18:07:57 <blackdog> a language with default memoization would pretty quickly run into space leaks and be shockingly difficult to reason about
18:07:57 <dmwit> bluej774: If you want an infinite list with some free elements, you have to do something more clever.
18:08:01 <dmwit> For example,
18:08:12 <byorgey> bluej774: you can do it that way if you want it to reuse the work after going through the list once ^^^
18:08:22 <dmwit> > let rolls xs = cycle (zipWith (++) (tails xs) (inits xs)) in rolls [1,2,3]
18:08:24 <lambdabot>   [[1,2,3],[2,3,1],[3,1,2],[1,2,3],[1,2,3],[2,3,1],[3,1,2],[1,2,3],[1,2,3],[2...
18:08:35 <dmwit> byorgey: I like my way better. =P
18:08:42 <dmwit> > let rolls xs = cycle (zipWith (++) (tails xs) (inits xs)) in rolls "abc"
18:08:44 <lambdabot>   ["abc","bca","cab","abc","abc","bca","cab","abc","abc","bca","cab","abc","a...
18:08:54 <byorgey> woah.  I like your way better too!
18:09:20 <byorgey> bluej774: what memoization type class?
18:09:25 <bluej774> n/m
18:11:01 <bluej774> So there's no way to memoize roll?
18:11:02 <Draconx> dmwit, yours is repeating the first element at the end of each "group".
18:11:15 <dmwit> Draconx: oh, dang
18:11:31 <mauke> tail 'em
18:11:38 <dmwit> yeah
18:11:49 <dmwit> What should rolls [] do?
18:12:17 <bluej774> Maybe I'm using the wrong terminology.  Won't the use of iterate cause caching of roll after a while?
18:12:23 <mauke> bluej774: no
18:12:28 <dmwit> bluej774: No, iterate does no memoization.
18:12:31 <dmwit> ?src iterate
18:12:32 <lambdabot> iterate f x =  x : iterate f (f x)
18:13:04 <byorgey> bluej774: there are ways to memoize functions.  But in this particular case I think it would be even faster just to compute all the rolls and then use 'cycle' to produce an infinite list if that's what you want.
18:13:29 <tickle`> what is the best pretty-printing library?
18:13:43 <byorgey> tickle`: it depends.  what do you want to pretty-print?
18:13:48 <bluej774> Okay, how would I compute all the rolls regardless of the length of the list passed in?
18:14:00 <mauke> bluej774: see above
18:14:13 <tickle`> byorgey: test suite results
18:14:16 <bluej774> ah
18:14:29 <dmwit> > liftM2 (zipWith (++)) (tail . tails) (tail . inits) "abcd"
18:14:31 <lambdabot>   ["bcda","cdab","dabc","abcd"]
18:14:49 <dmwit> > liftM2 (zipWith (++)) (init . tails) (init . inits) "abcd"
18:14:50 <lambdabot>   ["abcd","bcda","cdab","dabc"]
18:15:07 <byorgey> tickle`: the pretty package (http://hackage.haskell.org/package/pretty) is fairly standard
18:15:27 <mauke> > liftA2 (liftA2 (zipWith (++)) (. tails) (. inits) tail "abcd"
18:15:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:15:43 <mauke> > liftA2 (liftA2 (zipWith (++)) (. tails) (. inits) tail) "abcd"
18:15:44 <lambdabot>   Couldn't match expected type `a -> b -> c'
18:15:44 <lambdabot>         against inferred type `[...
18:15:48 <byorgey> tickle`: but there are other libraries that are better if you want to do things like colored output, 2D layout, or produce a parser + pretty printer at the same time
18:15:50 <tickle`> byorgey: I know. I'm hoping to find a library that's more featureful but still fairly popular
18:15:53 <mauke> my emperor!
18:16:27 <ion> Trifecta uses http://hackage.haskell.org/package/wl-pprint-terminfo for colorized prettyprinting.
18:16:37 <mauke> > liftA2 (liftA2 (zipWith (++))) (. tails) (. inits) tail "abcd"
18:16:39 <lambdabot>   ["bcda","cdab","dabc","abcd"]
18:17:20 <byorgey> tickle`: "more featureful"? what features do you want, in particular?
18:18:03 <tickle`> byorgey: well, I would like a library with ansi color support, but with the ability to easily "turn off" the colors
18:18:04 <mauke> :t join $ zipWith const . iterate (\(x : xs) -> xs ++ [x])
18:18:06 <lambdabot> forall b. [b] -> [[b]]
18:18:21 <mauke> > join (zipWith const . iterate (\(x : xs) -> xs ++ [x])) "abcd"
18:18:23 <lambdabot>   ["abcd","bcda","cdab","dabc"]
18:18:40 <dmwit> mauke: cute
18:18:53 <tickle`> byorgey: by that I mean, I'd like a way to turn the color combinators into "id" easily at run-time, if that makes any sense
18:19:14 <mauke> > join (zipWith const . iterate (liftA2 (++) (drop 1) (take 1))) "abcd"
18:19:16 <lambdabot>   ["abcd","bcda","cdab","dabc"]
18:19:21 <mauke> > join (zipWith const . iterate (liftA2 (++) (drop 1) (take 1))) ""
18:19:21 <byorgey> tickle`: http://hackage.haskell.org/package/ansi-wl-pprint, perhaps?
18:19:23 <lambdabot>   []
18:19:41 <byorgey> tickle`: makes sense, I don't know whether that library supports it
18:20:06 <bluej774> mauke, which of these would you say has the least complexity?
18:20:17 <tickle`> ion / byorgey: I'll look into both of those. thanks
18:20:29 <mauke> bluej774: no idea
18:20:36 <tickle`> byorgey: out of curioisity, what would you have recommended for "2D layout"?
18:20:57 <dmwit> LaTeX ;-)
18:21:08 <dmwit> (I'm kidding of course, he's going to recommend his own boxes library for sure.)
18:21:09 <bluej774> I'd tend to favor liftA2 (zipWith (++)) (init . tails) (init . inits)
18:26:41 <ion> wl-pprint-terminfo has the advantage of being made by edwardk. ;-)
18:37:03 <elliott> ion: You only need to look at the release list to tell :-)
18:39:03 <byorgey> tickle`: yes, I would have suggested http://hackage.haskell.org/package/boxes
18:39:20 <byorgey> it's not very fancy but useful in certain situations.
18:46:23 <tickle`> byorgey: ah, I see
19:04:05 <scooty-puff> any advice for syb with higher kinds?
19:15:26 <Zamarok> Weid problem.. when I click down on one of my page's number input increment/decrement button, the number will keep going up or down until I move the mouse off the button.. even after I mouseup
19:17:01 <dmwit> Can you post a minimal piece of Haskell code we can use to reproduce your problem?
19:17:10 <dmwit> Along with explicit instructions about how to observe it?
19:17:41 <Zamarok> oops, I feel silly.. I sent that to the wrong channel =X
19:34:13 <hpaste> ybit pasted “zipWith'” at http://hpaste.org/54305
19:35:41 <ybit> aha!
19:35:46 <ybit> damn the kindle
19:36:14 <ybit> ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]]
19:36:18 <ybit> that's what i was reading it as
19:36:26 <ybit> with two lines of output
19:36:30 <ybit> [[3,2,2],[3,4,5],[5,4,3]]
19:36:33 <ybit> [[3,4,6],[9,20,30],[10,12,12]]
19:36:43 <ybit> from the example: zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
19:48:16 * Sgeo has no idea what it means that data stores are monads or that MapReduce is a monad
20:05:17 <ion> sgeo: “X is a monad” means “fmap :: (a → b) → X a → X b” and “join :: X (X a) → X a” can be/are implemented. (Or alternatively “bind :: (a → X b) → X a → X b”.)
20:05:49 <Sgeo> ion, How does that apply to data stores?
20:06:15 <ion> Define data store.
20:06:30 <ion> “A hard disk is a monad” doesn’t sound quite right. :-)
20:06:40 <ion> (Because hard disks are hardly burritos.)
20:06:55 <Sgeo> http://www.reddit.com/r/haskell/comments/m0lo6/a_datastore_is_a_monad_transformer/
20:07:30 <Sgeo> Hmm at those comments
20:09:39 <ddarius> ion: You need return as well.
20:09:56 <ion> ddarius: Indeed, i forgot to mention it.
20:10:48 <ion> That seems to define a store as something with “get :: Storable a => s a → a” and “put :: Storable a => a → s a” with the rules that “get . put = id” and “put . get = id”.
20:12:28 <ion> put already has the type of return, so return = put.
20:15:31 <ddarius> put does not have the type of return.
20:22:10 <ion> The paper Sgeo is talking about simplifies a bit by ignoring the constraint and i was going with it.
20:42:10 <elliott> Sgeo: Ignore that paper.
20:42:22 <elliott> Oh, http://www.reddit.com/r/haskell/comments/m0lo6/a_datastore_is_a_monad_transformer/c2x8zrp says exactly what I was going to.
20:42:37 <elliott> (Is it even a paper? It looks like a blog post in the form of a PDF.)
21:17:38 <Sgeo> Suppose I have a double-linked list, and I "modify" (return a new element with pointers etc.) an element on the list. I have to walk through the list and change all the .. links. Shouldn't laziness mean I don't pay a cost of O(n) each time I modify, but a slightly increased time in traversal?
21:18:30 <monochrom> depends on actual details
21:19:57 <byorgey> most likely you will pay a cost of O(n) at some point.  but it may be delayed.
21:20:45 <Sgeo> If I delay that to, say, printing out all the elements, then it ... wouldn't that just be a constant factor?
21:21:14 <ddarius> n+n = 2n
21:21:19 <byorgey> no. delaying work does not magically make it less work.
21:21:34 <Sgeo> But O(2n) = O(n), right?
21:22:24 <ddarius> I don't know why the "but" is there.
21:22:36 <byorgey> well, sure.  if you only modify one element and then print out the whole list, it is O(n). but that has nothing to do with when the re-linking is performed.
21:32:39 <ion> Other data structures might be better suited for something pure that looks like a list you can traverse both ways.
21:34:28 <Axman6> like a list zipper?
21:34:38 <ion> yeah
21:35:45 <elliott> list zippers pay O(n) too :) but amortised O(1) etc.
21:36:12 <Axman6> eh? how do they pay O(n)?
21:36:17 <elliott> Sgeo: consider that by your logic, you can make any algorithm O(1) by just nesting each step in a lazy thunk...
21:36:31 <Axman6> if you modify the element you're inspecti9ng, then it's O(1)
21:36:40 <elliott> Axman6: oh hmm, they only pay O(n) if you want it to be cyclic
21:36:44 <elliott> as in, emulate a cyclic linked list
21:36:45 <elliott> sorry :)
21:36:51 <elliott> (I've done that with list zippers a lot)
21:37:23 <Sgeo> Is there a way to make a zipper out of arbitrary data types? I remember seeing something about it, and derivatives
21:37:46 <Axman6> sure
21:37:46 <ion> Not unsurprisingly, Oleg has something about that. :-)
21:37:56 <Axman6> Sgeo: check the LYAH chapter on zippers
21:38:43 <savask> Sgeo: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types
21:39:01 <elliott> http://okmij.org/ftp/continuations/zipper.html#traversable
21:39:11 <elliott> plus:
21:39:23 <elliott> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip1/ http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip2/ http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WalkZip3/
21:39:27 <elliott> for multi-directional movement
21:39:28 <Axman6> :|
21:39:39 <elliott> Axman6: i don't think the lyah chapter does arbitrary data types
21:39:47 <Axman6> LYAH covers that too, using the example of traversing a filesystem
21:39:52 <elliott> i mean well neither does oleg :)
21:39:58 <elliott> but any traversable
21:39:59 <elliott> Axman6: huh?
21:40:03 <elliott> Axman6: no, lyah derives zippers for specific types
21:40:08 <Axman6> sure
21:40:18 <Axman6> but it shows you how to do it for your own types by doing so
21:40:33 <elliott> giving one example =/= "a way to make a zipper out of arbitrary data types"
21:40:48 <Axman6> fine
21:50:19 * ybit decides to be more pragmatic 
21:51:17 <elliott> ybit: traitor!
21:51:41 <ybit> elliott: :P
22:26:38 <lars9> it seems dons and Neil Mitchell are working for standard chartered bank now, i'm wondering what do they use haskell for
22:27:18 <copumpkin> preflex: seen dons
22:27:18 <preflex>  dons was last seen on #haskell 14 hours, 10 minutes and 40 seconds ago, saying: i'm somewhat following the mails
22:27:36 <copumpkin> lars9: a bunch of stuff I'd expect, because they have lots of other haskellers too
22:28:23 <lars9> copumpkin: cool...
22:28:44 <lars9> copumpkin: hard to imagine though
22:28:48 <mzero> @msg lambdabot msgs
22:28:48 <lambdabot> Not enough privileges
22:29:40 <zzo38> Is people who made Pandoc in this channel?
22:30:10 <copumpkin> zzo38: I don't think so
22:30:19 <copumpkin> I sent him an email though and he responded
22:30:22 <copumpkin> pretty quickly
22:30:51 <mzero> installing pandoc: the quickest way to fill out your local menu of Haskell packages!
22:31:51 <lars9> copumpkin: who else do they have?
22:32:11 <zzo38> I had various idea/suggestion about Pandoc. One is to have an alternative lhs output mode for HTML, where it ensures the generated HTML file is a valid .lhs program, by using <XMP> around the code (or CDATA for XHTML)
22:32:23 <copumpkin> lennart augustsson, ravi nanavati, malcolm wallace, roman leschinskiy, probably others
22:34:49 <zzo38> Other suggestion:  * Input format: MediaWiki, ESC/P, UNIX manual page  * Output format: ESC/P, Plain TeX, pure ASCII (with option for CRLF/LF, form feeds, line wrapping)  * URI schemes: data ftp gopher
22:35:28 <lars9> copumpkin: that's a lot
22:35:56 <zzo38> How well is this idea to you?
22:37:39 <lars9> zzo38: http://johnmacfarlane.net/   the author's homepage
22:39:25 <byorgey> zzo38: those sound great. You should code them up and submit a patch.
22:40:18 <zzo38> Another idea is to have possibility of generating gopher menus.
22:40:46 <ion> Yeah, Gopher is really picking up steam these days.
22:40:49 <zzo38> byorgey: OK I might make module for some of these things and send it.
22:41:29 <zzo38> O, and I forgot one thing: Plain Old Documentation (as Perl uses) as input and output format.
22:41:38 <elliott> wow, pandoc has a ton of dependencies
22:41:51 <elliott> mzero: thanks for the bootstrapping procedure :P
22:41:54 <elliott> pandoc platform
22:41:59 <mzero> heh!
22:42:31 <ion> I wonder if he knows his IRC client advertises itself in quit messages?
22:43:12 <zzo38> And someone might add another dependency they said, after I post the complete dvi-processing package, they might add the DVI output to Pandoc. So, then it will have that dependency too.
22:44:34 <zzo38> If you have Plain TeX output format, then you can just use that to convert to DVI by TeX, like how it already can make PDF by a LaTeX output format. But I think someone said to make it output DVI directly.
22:47:45 <zzo38> Do you think this is the reasonable functions for DVI writing in my library?   createDVI :: FilePath -> Word32 -> Ratio Word32 -> IO DocStat;  shipOut :: Page -> IO DocStat;  finishDVI :: DocStat -> IO ();
22:48:32 <ion> Why IO?
22:48:33 <mzero> Is DocStat carrying around an open FileHandle?
22:48:42 <zzo38> mzero: Yes, that is one of the things it contains.
22:48:55 <mzero> how does shipOut gain access to it?
22:49:27 <Eduard_Munteanu> You could use Writer/WriterT to remove the requirement on IO I guess.
22:49:33 <mzero> shipOut :: DocStat -> Page -> IO DocStat
22:49:36 <zzo38> mzero: It is one of the fields of Page.
22:49:37 <mzero> or perhaps
22:49:43 <mzero> ah
22:50:02 <mzero> Is DVI generation such that you don't / can't do it in memory?
22:50:49 <mzero> why not
22:50:54 <mzero> shipOut :: Page -> IO ()
22:51:11 <mzero> is the DocStat returned by shipOut going to be any different than the one in the Page?
22:51:18 <zzo38> You probably don't want to do it entirely in memory, although it is possible. I could make a separate function for that purpose.
22:51:44 <zzo38> mzero: Yes. Some of the fields in that DocStat will be different.
22:52:33 <mzero> then why is it part of Page? what does a Page represent? the set of drawing operations to be performed?
22:52:52 <mzero> something smells odd about DocStat and Page to me
22:53:56 <zzo38> Page has three fields: pageNumbers (the page number, which can be ten registers), pageObjects (the objects on the page), and pageStat (the DocStat record). It is used when reading DVI files as well as when writing, and the fields of DocStat are accessible externally either way so that you can do stuff with it.
22:54:20 <elliott> Straw poll: Is a function that is referentially transparent only if typeclass laws are respected, and which gives nondeterministic (but not "failing", just unpredictable) results otherwise, pure? That is, would you feel bad about exporting it as a pure function? :) For example, something like sum :: (Monoid a) => [a] -> a which, let's say, has erratic results if the monoid operation isn't associative.
22:54:29 <zzo38> The function for reading DVI file is:  withDVI :: FilePath -> (Word32 -> ByteString -> IO Font) -> s -> (s -> Page -> IO (Maybe (s, t))) -> IO [t];
22:54:48 <elliott> ISTR that older versions of the Haskell Report allowed compilers to assume typeclass laws when compiling. Perhaps even the latest report does.
22:55:23 <zzo38> elliott: If that is the case, there ought to be a way to define your own typeclass laws for class you make up yourself.
22:55:37 <mzero> elliott: if it gives the same answer each time with the same input -- I'm cool with calling it ref. transp.
22:55:51 <elliott> mzero: It does if and only if you aren't naughty by violating typeclass laws.
22:56:07 <Eduard_Munteanu> elliott: how do you get non-deterministic behavior? I guess you need to use some unsafe stuff.
22:56:19 <elliott> Eduard_Munteanu: Under the hood, yes :)
22:56:31 <elliott> I mean...
22:56:42 <elliott> If you write a Typeable instance, you can get unsafeCoerce from Data.Typeable.cast.
22:56:51 <elliott> Most people don't consider Data.Typeable an unsafe module, or cast impure.
22:56:55 <mzero> wait, if I violate the type class laws then it might give "unexpected", "not garunteed correct", or "different on each run" ? which?
22:57:19 <elliott> mzero: last one; the result would essentially be nonsense and could differ on multiple evaluation etc. (but the program wouldn't crash or anything)
22:57:34 <elliott> mzero: but like I said with the Typeable example, an instance that violates the laws can cause a Haskell program to segfault today... :)
22:58:00 <elliott> but of course people want hand-written Typeable instances banned, so it doesn't quite match up with this situation
22:58:03 <mzero> wow- that's, er, interesting --- and no, then I'm not sure I'd call it ref. transp. -- at least not without a big warning in the doc
22:58:27 <ion> Would naming the function unsafeFoo be too bad? :-)
22:58:31 <elliott> ion: yes :)
22:58:47 <elliott> here's a program that uses no unsafe modules and segfaults at runtime:
22:58:52 <Eduard_Munteanu> maybeUnsafeFoo :P
22:59:04 <mzero> You could say "NOTE: This function is pure, but if and only if the instance of Foo strictly obeys the Foo laws"
22:59:21 <elliott> newtype A = A String; instance Typeable A where typeOf _ = typeOf (undefined :: Int); main = let Just (A x) = cast (94 :: Int) :: Maybe A in print x
22:59:48 <elliott> mzero: I would leave a note about it in the documentation, certainly
23:00:27 <zzo38> Yes, you should leave a note in the documentation in case you want to have such a function in your program.
23:00:31 <mzero> is this because there is some form of memoization, and it presumes some algebraic law is valid?
23:01:39 <elliott> mzero: Consider a fold that requires an associative operation, and decides how to cut up the list to parallelise it based on [complicated runtime factors]
23:01:49 <elliott> sorry -- commutative operation
23:01:51 <ion> I guess i’m leaning slightly toward not requiring it to be IO.
23:01:55 <elliott> well, associative too :)
23:02:04 <elliott> (in a typeclass)
23:02:16 <elliott> if you have a typeclass instance that violates the laws, you can observe the order the computation is done in
23:02:31 <elliott> but... you've already violated the laws, so things are gonna break, that's just what happens
23:02:40 <elliott> i'
23:02:51 <elliott> i'm not sure this kind of breakage is vastly worse than the breakage if you e.g. majorly break the monad laws
23:02:54 <mzero> okay - thats exactly the kind of thing I was thinking - sure - I'd call it pure / ref. transp. - but make clear note of the required property. -- after all, most type class instances *do* obey the requisite lawas
23:02:56 <mzero> laws
23:03:02 <elliott> which is "combinators don't make sense and everything goes haywire" :)
23:03:06 <elliott> especially RULES pragmas do this kind of stuff anyway
23:03:12 <elliott> mzero: right
23:03:45 <elliott> really, I think it's quite a shame if you can't optimise runtime properties assuming stated laws about programs, because that's a large part of what's so interesting about FP
23:03:57 <elliott> it's just that these laws are second-class citizens because the typeclasses are defined in the language itself :)
23:06:20 <tomprince> That is what dependent types are for :)
23:06:51 <elliott> yeah, some day :P
23:15:34 <mzero> bah! why is removeDirectoryRecursive defined to follow symlinks?
23:15:40 <mzero> that's absurd!
23:16:13 <elliott> for more destructive power
23:17:18 <mzero> fine - I'll just system out to rm -rf
23:17:50 <elliott> Insufficiently destructive!
23:17:51 <CindyLinz> It's too destructive...
23:17:54 <elliott> What will you do if someone makes a symlink to /?
23:17:59 <elliott> You'll still have files left at the end of it!
23:18:24 <mzero> right - 'cause when you're cleaning old versions of Haskell off your system --- you REALLY want to clean 'em
23:19:45 <elliott> Is it really a good cleaning if there's still something left at the end of it?
23:20:42 <mzero> I suppose I could do the deep-clean if you invoke the utility with the name high-colonic
