00:06:56 <simon> tsanhwa, so... [combine x y | x <- enum1, y <- enum2]?
00:08:39 <tsanhwa> is enumeratee a monad ?
00:08:49 <tsanhwa> I suppose not
00:17:16 <BlankVerse> ld: error in helloWorld(.eh_frame); no .eh_frame_hdr table will be created.
00:17:23 <BlankVerse> ld helloWorld
00:17:43 <BlankVerse> ghc helloWord --make -static
00:17:57 <BlankVerse> helloWorld uses only putStrLn
00:22:29 <kmc> what platform? and could you hpaste the actual code and sequence of commands you're running?
00:34:43 <BlankVerse> linux , is it possible to statically link libgmp.so
00:35:04 <kmc> don't know
00:35:12 <BlankVerse> helloworld.hs -> http://paste.pocoo.org/show/502145/
00:36:22 <yitz> @hpaste
00:36:22 <lambdabot> Haskell pastebin: http://hpaste.org/
00:39:01 <hpaste> blankverse pasted ‚Äúhelloworld.hs‚Äù at http://hpaste.org/53475
00:39:24 <kmc> (you don't need "do" or the parentheses)
00:39:28 <hpaste> blankverse pasted ‚Äúldd helloworld‚Äù at http://hpaste.org/53476
00:40:03 <Saizan> tried -optl-static ?
00:40:08 <BlankVerse> kmc: yeah , that was very old code :P
00:40:19 <BlankVerse> Saizan: yep
00:40:45 <mysticc> Is there something similar to read for Text .. or I have to unpack and then use read
00:41:34 <hpaste> blankverse pasted ‚Äú-optl-static‚Äù at http://hpaste.org/53477
00:41:43 <BlankVerse> Saizan: ^
00:43:10 <Saizan> BlankVerse: both -static and -optl-static?
00:43:31 <BlankVerse> Saizan: similar error
00:45:05 <BlankVerse> i cannot make even a simple hello world executable which is statically linked
00:50:58 <opqdonut> is there an svg generation library for haskell?
00:51:49 <kmc> generate from what?
00:52:10 <kmc> 'diagrams' is a very nice library for drawing vector graphics
00:52:10 <opqdonut> I mean a DSL for outputting svg
00:52:24 <kmc> it can render (through cairo) to svg, png, pdf
00:52:36 <opqdonut> okay, I'll have a look at that
00:52:50 <kmc> if you want to generate specific svg nodes, there might be stuff
00:52:51 <opqdonut> I'm doing some pretty low-level stuff so I'd probably be fine with generating svg by hand
00:52:56 <opqdonut> a la http://www.haskell.org/haskellwiki/TW-Logo-Haskell
00:53:09 <kmc> but you can also use a generic xml library
00:53:42 <opqdonut> of course
00:53:47 <kmc> heh, that's a pretty large program
00:53:52 <opqdonut> indeed
00:54:03 <kmc> outputting xml like this makes me sad:  "<td><embed src=\""++fname++"\" width='"
00:54:19 <opqdonut> me too
00:54:43 <opqdonut> this is pretty much a one-off thing (I need to generate some visualizations for a paper)
00:55:14 <MostAwesomeDude> Is there a better hack to get ord/chr for Word8 than this? vv
00:55:31 <MostAwesomeDude> > toEnum $ fromEnum 'a' :: Data.Bits.Word8
00:55:32 <lambdabot>   Not in scope: type constructor or class `Data.Bits.Word8'
00:55:48 <kmc> yeah, I would use (toEnum . fromEnum)
00:56:04 <MostAwesomeDude> Ugh. Oh well.
00:56:17 <kmc> there are far more characters than Word8 values
00:56:41 <kmc> it's not such a reasonable idea to convert between them
00:57:04 <MostAwesomeDude> This is part of a larger thing; there's a plan.
00:57:50 <kmc> if you have a chunk of binary data in some character encoding, it's best to deal with that at a higher level, like http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/Data-Text-Encoding.html
00:59:11 <MostAwesomeDude> Oh, there *is* a standard one that supports the encoding I want.
00:59:13 <MostAwesomeDude> Thank God.
00:59:45 <kmc> http://hackage.haskell.org/packages/archive/text-icu/0.6.3.4/doc/html/Data-Text-ICU-Convert.html supports basically every encoding ever
00:59:47 <vharishankar> I modified my program to use algebraic data types instead of string.
01:00:26 <MostAwesomeDude> ICU isn't reasonable for this particular app, but Data.Text.Encoding supports what I need. Thanks.
01:00:35 <hpaste> Harishankar pasted ‚ÄúExpression evaluator beginning stages‚Äù at http://hpaste.org/53478
01:00:37 <kmc> why not reasonable?
01:01:17 <kmc> vharishankar, looks much better :)
01:01:25 <kmc> vharishankar, you have "case num of .... where num = ..."
01:01:34 <vharishankar> kmc: thanks.
01:01:35 <kmc> i would just make it "case reads st of ..."
01:01:37 <MostAwesomeDude> Because there's a lot of tiny strings and calling out to C for each one would hurt bad and be really cumbersome.
01:02:03 <vharishankar> kmc: OK
01:02:05 <kmc> vharishankar, you probably do not need the type signature either
01:02:07 <kmc> it will be inferred
01:02:15 <kmc> but you can use a type annotation in any expression
01:02:30 <vharishankar> kmc: thanks. I am using type sigs to make it clear to myself. :-)
01:03:02 <kmc> vharishankar, ah, cool :)
01:03:20 <kmc> MostAwesomeDude, cumbersome? the module I linked will give you a function of type ByteString -> Text
01:03:26 <vharishankar> kmc: algebraic data types are so simple and make it much more readable. :-)
01:03:34 <vharishankar> RWH is pretty good book.
01:04:23 <kmc> MostAwesomeDude, is "calling out to C" a statement about the interface provided by the module, or about its implementation?
01:06:05 <vharishankar> In the code above, I think the first function scan_expression can be simplified, right?
01:06:27 <kmc> how?
01:06:42 <kmc> vharishankar, also, did you consider making another type to identify the operators, instead of using Char?
01:07:02 <vharishankar> kmc: agreed.
01:07:20 <vharishankar> I missed that somehow.
01:07:32 <MostAwesomeDude> kmc: How do I interact with Text compared to [Char]?
01:07:44 <kmc> http://hackage.haskell.org/package/text
01:07:59 <kmc> there's a whole API for manipulating Text values
01:08:03 <kmc> and you can convert them to/from [Char]
01:08:23 <kmc> anyway both Data.Text.Encoding and Data.Text.ICU.Convert will go through Text
01:08:30 <kmc> i don't see how one is more cumbersome than the other
01:08:34 <vharishankar> What is the difference between type and data?
01:08:41 <kmc> (well, there is a specific reason the latter might be more cumbersome, but you haven't mentioned it yet)
01:08:55 <kmc> vharishankar, "type" just declares a synonym, a new name for an existing type
01:09:02 <kmc> "data" creates a new type with new data constructors
01:09:15 <kmc> see also http://haskell.org/haskellwiki/FAQ#What.27s_the_difference_between_type.2C_data.2C_and_newtype.3F
01:09:23 <vharishankar> kmc: Thanks. That makes it clear.
01:12:02 <vharishankar> would it be like data Sym = SymPlus | SymMinus | SymMultiply | SymDivide deriving (Show)
01:12:20 <kmc> MostAwesomeDude, I don't see how "calling out to C" matters.  your entire Haskell program is constantly calling out to C for IO and other system calls, primitive data types and operations, and calls into the GHC runtime system (which is a 50,000 line C library)
01:12:54 <kmc> if the interface is good, it hardly matters to you whether a given function is implemented in C or Haskell (or both, as is frequently the case)
01:14:54 <MostAwesomeDude> kmc: I already implemented it with Data.Text.Encoding.
01:15:36 <kmc> ok, that's cool
01:15:49 <kmc> i'm still confused by your objection to text-icu, but i wont push the issue
01:16:44 <hpaste> Harishankar annotated ‚ÄúExpression evaluator beginning stages‚Äù with ‚ÄúExpression evaluator beginning stages (annotation)‚Äù at http://hpaste.org/53478#a53480
01:17:21 <MostAwesomeDude> My objection was largely that the IO was up-front and difficult to shake off. I whine a lot, apparently.
01:18:20 <kmc> *nod*
01:18:38 <kmc> you have to use IO to get a Converter, but not to use it
01:19:05 <kmc> however there is the thread safety issue
01:19:17 <MostAwesomeDude> That worried me too.
01:19:55 <kmc> there are many solutions, but they will complicate the code a bit
01:22:59 <kmc> so much thread-unsafe C code out there
01:24:28 <kmc> and opinions differ as to how to deal with it in Haskell
01:25:18 <kmc> my view is that Haskell programmers expect safety, and a wrapper should provide it, unless it's explicitly a low-level binding with Ptr all over the place
01:25:55 <kmc> annoyed by wrappers which import C libraries with thread safety issues (or dire security holes!) and neglect to mention this in docs
01:26:07 <blackdog> kmc: isn't the classic pattern to write one low level binding at the c level, and a higher-level one with no FFI that wraps it?
01:26:32 <kmc> yeah, that's the pattern I like
01:26:39 <kmc> they can be one package or two
01:27:03 <kmc> hdis86 has three or four layers
01:44:00 <hpaste> ‚ÄúLev Broido‚Äù pasted ‚ÄúLoops in graph‚Äù at http://hpaste.org/53482
01:53:28 <erus`> anyone know of a haskell dsl that compiles to javascript
01:53:45 <Blkt> good morning everyone
01:55:11 <erus`> javascript is horrible and not type safe
01:55:42 <luite_> haskell itself can compile to javascript
01:56:14 <kmc> javascript is not that bad
01:56:28 <kmc> i would not call it "horrible" compared to some of the popular programming languages
01:56:41 <luite_> javacript gets worse when your project gets bigger
01:57:24 <erus`> luite_: is there an actively developed compiler targeting js?
01:57:36 <luite_> no, but you might start actively developing one ;)
01:58:54 <luite_> I wouldn't expect a haskell javascript dsl to become actually usable, makign a good one would be just as much work as designing a new statically typed language that compiles to js
01:59:41 <luite_> and somehow these projects never stay alive logn enough for that
01:59:55 <erus`> maybe i will try google dart
02:00:00 <erus`> thats typed i think
02:00:26 <luite_> it has optional type annotations
02:00:40 <luite_> but that's about all I know about it :)
02:03:35 <luite_> but personally, unless I had a huge site that couldn't use existing js libraries for some reason, I'd just try to use js, just be disciplined and have lots of tests
02:05:30 <luite_> though perhaps jmacro is useful
02:05:47 <kmc> i thought ghcjs was still being developed
02:06:04 <kmc> dart has static type annotations but they're not enough to rule out run-time type errors
02:07:04 <luite_> kmc: hmm, where's the official repository? I've googled recently and the one I could find didn't have any commits in 2011
02:08:21 <luite_> hmm, looks like it has had 3 commits in 2011 now
02:08:25 <rostayob> dart has a creative type system
02:08:36 <rostayob> and with creative, i mean shit
02:09:24 <kmc> shrug
02:09:28 <kmc> it's not designed to impress PL snobs
02:09:36 <rostayob> eheh I was joking
02:09:42 <rostayob> but it's not really a type system
02:09:54 <kmc> we can argue all day about "what is a type system, really"
02:09:56 <kmc> let's not
02:10:06 <arcatan> http://disnetdev.com/contracts.coffee/ not a type system, but i thought to give this a try
02:10:09 <luite_> hack on ghcjs instead ;)
02:10:22 <rostayob> ok, let's say that i was fooled at the beginning, i thought that types meant what they usually mean
02:10:27 <rostayob> in dart they're just annotations
02:10:28 <kmc> it provides some static guarantees and others at runtime
02:10:55 <luite_> "Eat your heart out, Haskell" ...
02:11:04 <kmc> Haskell can be described the same way, even though it's much further to the "static" side
02:11:37 <rostayob> what are the runtime guarantee of haskell, at the type level?
02:12:29 <mbil> hi folks newbie question here: I have list of train station times [6, 9, 10, 2, 5, 6] (so train arrives at 6am, 9am, etc)
02:12:43 <mbil> the problem I have is that I need to convert the list into [6, 9, 10, 14, 17, 18]
02:12:52 <rostayob> > sort [6, 9, 10, 2, 5, 6]
02:12:53 <lambdabot>   [2,5,6,6,9,10]
02:12:55 <mbil> so the hours are 24 hours
02:13:00 <rostayob> ah. lol
02:13:02 <luite_> rostayob: these are just runtime assertions, not type level, you can do the same in haskell
02:13:28 <rostayob> mbil: so the list is already sorted?
02:13:37 <rostayob> all you need to do is detect when the value decreases
02:13:43 <mbil> I know how to do that in an imperative non-haskell solution with a temp variable. but don't know how to do that in haske
02:13:44 <rostayob> and then add 12 to the rest
02:14:41 <kmc> rostayob, define "at the type level"
02:15:09 <mbil> rostayob right thats how I would do it but I don't know how to split the list up when (and how) I detect the value changes. (I've only gone through the first few chapters of Learn You a Haskell :-) )
02:15:35 <rostayob> mbil: you can do it with a fold, holding the previous time each time
02:16:00 <mbil> ah ok, I'll try that out. Thanks!
02:17:02 <rostayob> mbil: actually it's a bit more complicated, you need to keep the whole list
02:17:04 <rostayob> wait
02:17:15 <mbil> oh
02:17:46 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs) in lessThanNext [1,3,5,7,9,2,4,6,8,0]
02:17:46 <lambdabot>   [True,True,True,True,False,True,True,True,False]
02:19:29 <hpaste> rostayob pasted ‚Äúmbit‚Äù at http://hpaste.org/53483
02:19:36 <erus`> wow dart doesnt run properly in firefox
02:19:41 <erus`> god damnit
02:19:49 <erus`> i wish ghcjs worked on windows
02:20:13 <rostayob> mbil: that's the clearest thing i could write
02:20:18 <luite_> erus`: can't you fix that? :p
02:20:38 <rostayob> kmc: well what do you mean?
02:20:42 <mbil> awesome thanks rostayob, I was pretty close, I had gotten the conditions right, but was errr didn't have the recursive call part. Thanks!
02:20:55 <rostayob> that's why i asked, i didn't understand what you meant
02:20:58 <erus`> luite_: i have no idea where to start. I just get javascript errors
02:21:10 <erus`> no runtime errors or anything
02:21:23 <luite_> that doesn't sound like a windows-specific problem then
02:21:46 <rostayob> mbil: yw
02:22:13 <mbil> rostayob I can probably figure the rest out, but seems like a little bug in there:
02:22:14 <mbil> *Main> mbit [6,8,9,2,4]
02:22:14 <mbil> [6,8,9,16]
02:22:26 <rostayob> oh, i'm dropping an element
02:22:33 <rostayob> it's
02:22:37 <rostayob> map (+12) (y : l)
02:23:02 <mbil> ah right! cool!
02:25:49 <kmc> rostayob, what do I mean? you're the one who said "at the type level".  what did *you* mean?
02:26:02 <rostayob> kmc: oh, you meant some runtime guarantees in genral?
02:26:10 <rostayob> i thought we were talking about types
02:26:18 <mm_freak> edwardk: just a little typo: http://comonad.com/reader/2011/what-constraints-entail-part-1/
02:26:22 <mm_freak> you write "copumkin"
02:26:23 <kmc> what distinguishes types from other static or dynamic guarantees?
02:26:37 * ddarius hopes edwardk is asleep right now.
02:26:40 <luite_> erus`: the code for ghcjs is not that big, but it needs lots of work. if you want to work on it, you should probably start by making some good javascript AST representation and a prettyprinter with lots of tests. the current one generates invalid javascript code
02:26:53 <kmc> rostayob, many things in Haskell are not checked until runtime.  if you start with the axiom "Haskell has a static type system" then of course those properties are not part of the type system
02:26:57 <kmc> but does that really say anything?
02:27:24 <rostayob> kmc: well but in haskell it's very clear what's in the types and what isn't
02:27:33 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); let increasingChunks xs = (map.map) fst . groupBy ((==) `on` snd) $ zip xs (lessThanNext xs ++ [True]) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:27:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:27:48 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); let increasingChunks xs = (map.map) fst . groupBy ((==) `on` snd)) $ zip xs (lessThanNext xs ++ [True]) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:27:48 <lambdabot>   <no location info>: parse error on input `)'
02:27:55 <kmc> rostayob, is it?  is "pure function" part of the type?
02:27:58 <kmc> many say yes, I do not
02:28:16 <kmc> especially if "Haskell" includes the general scope of code people write with GHC
02:28:19 <rostayob> kmc: it is, and that's one of the good thing
02:28:30 <rostayob> *things
02:28:34 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); increasingChunks xs = (map.map) fst . groupBy ((==) `on` snd) $ zip xs (lessThanNext xs ++ [True]) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:28:35 <lambdabot>   [[1,3,5,7],[9],[2,4,6],[8],[0]]
02:28:37 <rostayob> how is impurity not part of the type?
02:28:39 <kmc> in GHC Haskell, if you actually manage to write an impure function, nothing in the type system flags this
02:28:49 <rostayob> you mean unsafePerformIO?
02:28:52 <kmc> yes
02:28:59 <kmc> (or the internals of how IO is implemented in GHC)
02:29:00 <kmc> meanwhile a function of type (A -> IO B) is as pure as any other
02:29:04 <rostayob> that's not haskell
02:29:11 <luite_> erus`: I'd be really interested in the result by the way, but only when it's relatively usable
02:29:18 <kmc> rostayob, unsafePerformIO is in Haskell
02:29:25 <kmc> but its semantics on non-pure actions are undefined
02:29:26 <kmc> so fair enough
02:29:40 <erus`> luite_: i cant be bothered. I need to rebuild ghc and stuff
02:29:41 <kmc> anyway if Haskell only has pure functions, what's the point of saying "the type system tracks pure vs. impure functions"
02:29:45 <rostayob> cmon you're playing dumb here. in haskell, the purity is clear for the type
02:29:54 <rostayob> kmc: in this context we usually mean "non-IO"
02:29:56 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); increasingChunks xs = (map.map) fst . groupBy ((==) `on` snd) $ zip xs (True : lessThanNext xs) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:29:57 <kmc> i might as well say "the fixity resolution system tracks pure vs. impure functions" if there are none of the latter
02:29:57 <lambdabot>   [[1,3,5,7,9],[2],[4,6,8],[0]]
02:30:07 <kmc> is (id :: IO a -> IO a) a pure function?
02:30:11 <luite_> erus`: really? I thought you could just cabal install ghcjs
02:30:20 <rostayob> kmc: but you are right in saying that all functions are pure
02:30:34 <kmc> rostayob, you can't answer questions like that if you have the broken "taint model" of IO
02:30:42 <kmc> it's just an analogy, it has limitations
02:30:47 <rostayob> taint model?
02:30:51 <erus`> luite_: yeah but you need to compile the prelude to js and stuff and that means rebuilding ghc (according to github)
02:31:03 <mbil> yitz shouldn't the list be split up as [[1,3,5,7,9],[2,4,6,8],[0]] ?
02:31:04 <kmc> the idea that a function of type (A -> IO B) is like a function of type (A -> B) but with a "taint tag" saying it does IO
02:31:26 <yitz> mbil: yeah still a little broken
02:31:27 <rostayob> more or less, yes
02:31:51 <rostayob> but this enable great clarity, you can separate various level of... impurity, like ST or STM
02:32:25 <rostayob> i really don't see the disadvantage in a model like that, apart from maybe decreased flexibility
02:33:04 <rostayob> also, you can use unsafePerformIO, but you have to comply to certain rules
02:33:08 <yitz> mbil: groupBy won't work for this
02:33:17 <kmc> the taint model is incomplete, it doesn't even tell you what (IO t) means
02:33:25 <kmc> it suggests that IO actions aren't first class
02:33:36 <rostayob> kmc: what is your model for IO?
02:33:38 <kmc> and it gives you no way to deal with types like IO (IO T) or Int -> (IO a -> IO a)
02:33:53 <kmc> rostayob, a value of type (IO T) is a description of IO which could be performed
02:33:58 <kmc> it's an imperative program as a first-class value
02:34:05 <kmc> functions can manipulate these values, sure
02:34:09 <kmc> but those are still pure functions
02:34:23 <luite_> erus`: hmm, good point, guess it takes some work to make it actually user-friendly. ghc-pkg for ghcjs and cabal support would be useful
02:34:27 <kmc> it's not like an (IO T) is a T which has been tainted by association with the real world
02:34:29 <kmc> there's no T hiding inside
02:34:31 <rostayob> kmc: wait i need to go to uni, i'll be back in half an hour
02:34:34 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); increasingChunks xs = (map.map) fst . map (takeWhile snd) . takeWhile (not.null) . iterate (dropWhile snd . drop 1) $ zip xs (True : lessThanNext xs) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:34:35 <lambdabot>   [[1,3,5,7,9],[],[]]
02:34:39 <kmc> you could execute the action 3 times, and get three different results
02:34:41 <kmc> rostayob, cool, ttyl
02:34:47 <rostayob> later
02:35:43 <yitz> > let lessThanNext xs = zipWith (<) xs (drop 1 xs); increasingChunks xs = (map.map) fst . map (\xs -> take 1 xs ++ takeWhile snd (drop 1 xs)) . takeWhile (not.null) . iterate (dropWhile snd . drop 1) $ zip xs (True : lessThanNext xs) in increasingChunks [1,3,5,7,9,2,4,6,8,0]
02:35:45 <lambdabot>   [[1,3,5,7,9],[2,4,6,8],[0]]
02:36:03 <yitz> ok. seems like there'll be an easier way to do this though. :)
02:36:47 <mbil> yitz: ah that works! though Im afraid my haskell-ese is very rudimentary and I don't grok that all that well. rostayob's solution was pretty much at my level :-)
02:37:21 <yitz> mbil: didn't see it. can you copy it pls?
02:37:44 <mbil> rostayob pasted ‚Äúmbit‚Äù at http://hpaste.org/53483
02:39:27 <yitz> mbil: that seems to be solving a somewhat simpler problem though
02:40:14 <yitz> mbil: you can write increasingChunks with direct recursion too, but it will be a matter of opinion whether that comes out simpler than what I wrote.
02:42:46 <mbil> yitz: yeah my problem was only to transform [6,8,10,1,2] into [6,8,10,13,15] I had learned how to split apart the list with guards but (embarassingly) I was missing the recursive call in rostayob's solution. [again my haskell level is very very basic]
02:43:14 <yitz> mbil: not as basic as it was a few minutes ago
02:43:26 <arcatan> :)
02:43:28 <mbil> heh! yep! I rock now!
02:45:16 <mbil> thanks for your help though :-)
02:51:53 <erus`> im writing a DSL lol
02:51:54 <ClaudiusMaximus> > uncurry (++) . (map snd *** map ((+12) . snd)) . span (uncurry (<)) . (zip `ap` tail) . ((minBound :: Int):) $ [6,8,10,1,2]
02:51:56 <lambdabot>   [6,8,10,13,14]
02:53:15 <FUZxxl> ClaudiusMaximus: What should that do?
02:55:21 <FUZxxl> ClaudiusMaximus: What is that supposed to do?
02:55:22 <ClaudiusMaximus> solve the problem "convert ascending list of times in 12 hour clock to 24 hour clock"
02:55:55 <erus`> how do i get a monad instance for Either again?
02:56:05 <kmc> import Control.Monad.Instances -- ?
02:56:40 <erus`> ah yes thanks
02:59:16 <BlankVerse> anyone help statically link a simple hello world app in haskell?
02:59:19 <erus`> Now should i wrap statement or implement a purely functional DSL
02:59:29 <BlankVerse> main = putStrLn "Hello world"
02:59:53 <BlankVerse> i tried using -static -optlstatic
03:00:07 <BlankVerse> but i get :  undefined reference to `pthread_mutex_unlock'
03:00:09 <BlankVerse> errors
03:00:24 <FUZxxl> ClaudiusMaximus: Well, Haskell is a bit like APL: You can do most things in one line, but it takes a week to figure out how it works afterwards.
03:00:28 <BlankVerse> do i need to manually name the libraries
03:01:14 <FUZxxl> BlankVerse:
03:01:20 <FUZxxl> Windows?
03:01:29 <BlankVerse> FUZxxl: linux
03:01:29 <kmc> BlankVerse, how about -optc-pthread
03:01:31 <kmc> or -optl-pthread
03:02:29 <FUZxxl> -How about -l pthread?
03:03:04 <BlankVerse>  ghc helloWorld.hs --make -static -l pthread
03:03:05 <BlankVerse> target `pthread' is not a module name or a source file
03:03:22 <BlankVerse> ghc helloWorld.hs --make -static -optl-pthread
03:03:27 <BlankVerse> doesnt make it static
03:03:49 <BlankVerse>  ghc helloWorld.hs --make -static -optl-static -optl-pthread gives
03:03:49 <FUZxxl> hm...
03:03:57 <BlankVerse> Linker.c:(.text+0x61c): warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
03:06:50 <kmc> yeah, a bunch of glibc stuff will give you that warning
03:06:58 <kmc> like anything which can be remapped through nsswitch
03:07:01 <kmc> getpwent etc
03:08:27 <BlankVerse> FUZxxl: though i get a warning , it does indeed work
03:09:24 <erus`> I could use dependant types here
03:11:55 <leino> is there a standard way to enumerate all integers, i.e. [0,1,-1,2,-2, ..]?
03:13:01 <yitz> leino: that will eventually work, but it will take you a while
03:13:01 <kmc> > concat $ transpose [[0..],[-1,-2..]]
03:13:02 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
03:13:52 <kmc> > concat [ [x,-x] | x <- [0..] ]
03:13:53 <lambdabot>   [0,0,1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-...
03:13:54 <leino> kmc: that'll do, but I was thinking more like a typeclass for "exhaustive enumeration"
03:14:27 <kmc> http://hackage.haskell.org/package/enumerable
03:15:10 <leino> great, thanks!
03:21:13 <hpaste> erus` pasted ‚Äúwill this work in theory‚Äù at http://hpaste.org/53485
03:23:10 <erus`> is there docs for designing a dsl?
03:24:16 <kmc> erus`, you're using ¬´JSLocal ...¬ª on the right-hand side of <-, which means its type must be monadic, but JSBody is not a type constructor applied to an argument
03:24:21 <kmc> monads all have kind * -> *
03:24:35 <kmc> erus`, probably your monad should be a state monad of some kind
03:24:40 <erus`> ah ok
03:24:52 <kmc> also aren't there like four javascript DSLs on hackage already
03:25:53 <erus`> oh yes
03:26:07 <erus`> Would be nice to see some usage statistics
03:26:12 <erus`> I wonder which is best
03:26:49 <kmc> probably usage of all of them is very low
03:28:19 <luite_> yep that's the main reason that I don't use them :)
03:29:53 <ddarius> kmc: Unlike the usage of my yet-to-be-written one.
03:30:38 <kmc> which is yet-to-be-low?
03:31:18 <yitz> leino, kmc: related to enumerability, the Ranged-sets package has a concept of order types whose ordering is discrete
03:31:29 <yitz> *ordered types
03:32:55 * hackagebot splot 0.2.7 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.7 (EugeneKirpichov)
03:34:39 <yitz> hmm, there is an Enumerable instance for floating point types. while technically you can enumerate them, i'm not sure if that's such a good idea.
03:35:39 <ddarius> > [0.0..]
03:35:40 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
03:39:02 <kmc> map unsafeCoerce ([0..] :: [Word64])
03:47:58 <leino> sorry about the noob question, but is there some bot here which displays hackage documentation for a given function?
03:48:39 <Peaker> @package mtl
03:48:40 <lambdabot> http://hackage.haskell.org/package/mtl
03:48:44 <Peaker> leino: I think this is the closest
03:49:14 <leino> Peaker: oh ok
03:49:41 <Peaker> leino: and there's Hayoo! and Hoogle
03:49:54 <Peaker> http://holumbus.fh-wedel.de/hayoo/hayoo.html and http://www.haskell.org/hoogle/
03:50:17 <leino> @package: rounding
03:50:18 <lambdabot> http://hackage.haskell.org/package/rounding
03:51:40 <leino> I find it curious that the standard round function snaps to an even integer in case of a tie
03:51:46 <kmc> @package incredible_bot_powers
03:51:47 <lambdabot> http://hackage.haskell.org/package/incredible_bot_powers
03:52:03 <leino> hah
03:52:14 <ddarius> @wiki more_bot_powers
03:52:14 <lambdabot> http://www.haskell.org/haskellwiki/more_bot_powers
03:52:33 <kmc> @yhjulwwiefzojcbxybbruweejw
03:52:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
03:52:34 <leino> expected real package, was disappointed...
03:52:46 <kmc> lambdabot has source for a few functions
03:52:47 <kmc> @src map
03:52:48 <lambdabot> map _ []     = []
03:52:48 <lambdabot> map f (x:xs) = f x : map f xs
03:52:56 <leino> @src round
03:52:56 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:52:57 * hackagebot sphinx 0.4.0.5 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0.5 (GregWeber)
03:53:04 <ddarius> map f = foldr ((:) . f) []
03:53:05 <leino> @src floor
03:53:05 <lambdabot> Source not found. :(
03:53:10 <ddarius> Those are methods.
03:53:32 <leino> doh!
03:54:27 <leino> is there a way to get "method instances"? (what is the proper term?)
03:54:42 <leino> like if I wanted to see the implementation of floor for Float
03:54:46 <kmc> :i Float
03:54:53 <kmc> in ghci
03:54:59 <kmc> that will tell you all of its type class instances and what file they were defined in
03:55:13 <kmc> then you find that module on hackage and click the source link
03:55:55 <leino> yeah
03:58:33 <wolong> ú‡^¸/g 37
03:58:37 <wolong> ú‡^¸/g 37
04:00:33 <kmc> o_O
04:01:03 <Spockz> @seen kowey
04:01:03 <preflex>  kowey was last seen on #darcs 1 day, 14 hours, 7 minutes and 55 seconds ago, saying: (the other useful thing is that you may have to stomach a bit of Haskell if you want to do something not covered in the examples)
04:01:04 <lambdabot> Unknown command, try @list
04:01:25 <ddarius> @src Maybe (>>=)
04:01:25 <lambdabot> (Just x) >>= k      = k x
04:01:25 <lambdabot> Nothing  >>= _      = Nothing
04:02:27 <leino> @src Float round
04:02:27 <lambdabot> Source not found. Sorry.
04:02:38 <leino> @src RealFrac round
04:02:38 <lambdabot> Source not found. You speak an infinite deal of nothing
04:06:32 <leino> @src Maybe fmap
04:06:32 <lambdabot> fmap _ Nothing       = Nothing
04:06:32 <lambdabot> fmap f (Just a)      = Just (f a)
04:07:32 <leino> @src RealFrac (round :: Float -> Integer)
04:07:33 <lambdabot> Source not found. Do you think like you type?
04:07:58 * hackagebot sphinx 0.5.0 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.5.0 (GregWeber)
04:09:07 <yitz> leino: you can use floor and ceiling to get other kinds of rounding
04:10:05 <yitz> > (round 2.5, floor 2.5, ceiling 2.5, floor (2.5 + 0.5))
04:10:06 <lambdabot>   (2,2,3,3)
04:10:11 <leino> yitz: yeah, but I am writing QuickCheck properties for floor :)
04:11:19 <leino> yes, I know it might silly to use round then also: it's just for learning purposes
04:11:52 <yitz> leino: ok
04:18:17 <erus`> http://stackoverflow.com/questions/7994054/how-do-i-chain-statements-together-in-a-block-with-hjavascript
04:26:32 <Cale> erus`: You probably just don't want to use toBlock so much?
04:27:17 <Cale> erus`: foldl seems like the right idea
04:30:15 <Cale> erus`: Is the problem that the types of the Stmts that you're chaining together is something other than ()?
04:31:11 <Cale> The only constructor of Stmt which doesn't have type Stmt () is a Return
04:31:45 <Cale> I'm not sure why Return is typed like that, I'm fairly sure that Javascript has no such syntactic rule.
04:32:34 <Cale> But I guess it's an attempt at injecting some level of typing into it.
04:32:51 <Cale> erus`: Are you here?
04:39:42 <Cale> erus`: anyway, you should be able to use something like  block :: [Stmt ()] -> Exp t -> Block t; block xs r = Sequence (foldl Sequence EmptyBlock xs) (Return r)
04:39:46 <Cale> for the most common case
04:54:01 <chris2> hi. anyone have a copy of "Data Types a la Carte" by Wouter Swierstra? all links seem broken
04:56:37 <siracusa> chris2: http://www.cs.ru.nl/~wouters/Publications/DataTypesALaCarte.pdf works here
05:00:29 <antilect> xD
05:01:46 <erus`> Cale, back
05:03:33 <erus`> Cale that works :)
05:06:09 <erus`> but some blocks dont return a value :|
05:06:46 <luite_> hjavascript doesn't look very friendly to use directly
05:06:59 <luite_> maybe as a backend for ghcjs
05:07:19 <erus`> i should write my own
05:07:29 <erus`> i only need a subset of js
05:09:13 <luite_> hmm for most existing libs to be usable from your dsl, you probably need a pretty big subset
05:10:14 <erus`> stupid object model
05:12:03 <erus`> i wish i could just write this in haskell :P
05:12:47 <luite_> what kind of thing is it?
05:12:57 <erus`> im just messing about with webgl
05:13:11 <erus`> http://tm1rbrt.github.com/webgl-game
05:15:10 <luite_> ah I don't have webgl enabled
05:23:56 <khs> Hi, I have a type Qual t = (Mname t), can I pattern match on t? I want to write a function func :: (Qual t) -> String
05:24:30 <chris2> siracusa: thanks!
05:26:09 <ClaudiusMaximus> khs: as type Qual t is a type synonym, you can pattern match on the relevant constructors of Mname t, which probably contain t, so you could use a nested pattern
05:27:27 <ClaudiusMaximus> > case return (fail "oops") of Just (Left str) -> "error: " ++ str ; _ -> "ok"
05:27:28 <lambdabot>   Overlapping instances for GHC.Base.Monad
05:27:28 <lambdabot>                              (Data...
05:43:30 <khs> ClaudiusMaxiumus: t is of types like Dcon -> String, or Tcon -> String, is it possible to match on those?
05:43:52 <hpaste> erus` pasted ‚ÄúCan i embed a variable in statement, so that declareVar can return a new number every time its called?‚Äù at http://hpaste.org/53487
05:45:03 <erus`> or am i being silly
05:46:13 <Axman6> erus`: use a state monad
05:48:42 <hpaste> hpc annotated ‚ÄúCan i embed a variable in statement, so that declareVar can return a new number every time its called?‚Äù with ‚ÄúCan i embed a variable in statement, so that declareVar can return a new number every time its called? (annotation)‚Äù at http://hpaste.org/53487#a53488
05:48:56 <hpc> erus`: http://hpaste.org/53488
05:49:00 <Axman6> erus`: so, you'd have something like State Int Exp as the monad you're working on, and you'd use: next = do {x <- get; put (x+1); return x}
05:49:37 <erus`> ah I see
05:49:46 <hpc> i would use State Exp t
05:50:56 <hpc> i did something similar to generate variable names when i was messing around with generating javascript
05:53:25 <erus`> Ambiguous module name `Control.Monad.State':  it was found in multiple packages: monads-tf-0.1.0.0 mtl-2.0.1.0
05:53:31 <erus`> how do i fix this
05:57:29 <jessopher> i would imagine one of those packages has to be removed
05:57:43 <jessopher> probably not mtl
05:57:53 <luite_> erus`: typically by starting a cabal project :)
05:58:28 <erus`> actually i could define all variables before the statements
05:58:51 <luite_> if you're just experimenting you can import "mtl" Control.Monad.State if you enable the PackageImports extension
05:59:02 <luite_> or you can ghc-pkg hide monads-tf
06:03:06 <jessopher> luite_: what would the cabal project route get you? I'm guess something along the lines of ignoring things that are not explicit dependencies?
06:03:30 <luite_> jessopher: you can specify deps and then use cabal-dev ghci
06:03:39 <jessopher> ah, ok
06:06:31 <erus`> can i construct a list with do?
06:06:42 <jessopher> yeah, lists are monads
06:09:54 <hpc> erus`: the monad instance for lists is trivial to convert to list comprehensions
06:09:58 <erus`> hmm i mean like 1 >> 2 >> 3 >> 4
06:10:01 <hpc> (if that helps you figure out what the instance is)
06:10:37 <Axman6> erus`: that's not how you'd do it (that code would require Num(bers) to be monads)
06:11:20 <hpc> (the monad instance for lists is roughly "functions from multiple inputs to multiple outputs")
06:11:55 <mokus> > runWriter $ do tell [1]; tell [2]; tell [3]; tell [4]
06:11:56 <lambdabot>   ((),[1,2,3,4])
06:12:11 <Axman6> :t execWriter
06:12:11 <lambdabot> forall w a. Writer w a -> w
06:12:14 <jessopher> magical
06:12:21 <hpc> mokus: that's spectacularly slow in larger cases though :P
06:12:56 <mokus> hpc: true, but it comes in handy for making simple DSLs for small stuff
06:12:57 <Axman6> > execWriter $ replicateM 1000 (tell [1])
06:12:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:13:18 <mokus> hpc: and it can be made faster, with tricks like difference lists, when necessary
06:13:21 <hpc> > execWriter $ replicateM 1000000 (tell [1])
06:13:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:13:42 <hpc> indeed
06:13:49 <Axman6> > last . execWriter $ replicateM 10000000 (tell [1])
06:13:54 <lambdabot>   mueval-core: Time limit exceeded
06:13:56 <jessopher> lol
06:14:07 <Axman6> last $ replicate 10000000 1
06:14:12 <Axman6> > last $ replicate 10000000 1
06:14:14 <lambdabot>   1
06:14:33 <hpc> > toDL [1..5]
06:14:34 <lambdabot>   Not in scope: `toDL'
06:15:00 <hpc> > (DL [1..5]) `mappend` (DL [6..10]) $ []
06:15:01 <lambdabot>   Not in scope: data constructor `DL'Not in scope: data constructor `DL'
06:15:01 <Axman6> > toDList [1..5]
06:15:02 <lambdabot>   Not in scope: `toDList'
06:15:04 <erus`> im just trying to hack state into haskell, this is hopeless
06:15:08 <hpc> not in scope it seems
06:15:11 <Axman6> @hoogle DList
06:15:12 <lambdabot> Text.Html dlist :: Html -> Html
06:15:12 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
06:15:12 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
06:15:17 <hpc> erus`: you have to know what kind of state you want first
06:15:20 <Axman6> you suck at case lambdabot
06:15:53 <jessopher> erus`: if all else fails, unsafeIO, and tell no one
06:15:55 <Axman6> erus`: we use state in haskell all the time. or at least pretend to
06:15:59 <hpc> erus`: you can't just say "i want state" and then poof it's there without any effort
06:16:29 <hpc> (well, you probably could, but it's beyond my ability to explain)
06:17:06 <Axman6> unsafePerformIO $ newIORef undefined :: IORef a >_>
06:17:09 <erus`> im thinking about it the wrong way
06:19:07 <Axman6> erus`: what are you actually trying to do, from a high level?
06:19:23 <hpc> better: what do you _want_
06:19:34 <erus`> I wanted to model some javascript code
06:19:43 <erus`> and enforce type safety
06:19:54 <Axman6> and for that you need to generate unique variable names?
06:20:38 <erus`> it would be nicer to have the variable names in haskell rather than strings
06:21:37 <TardedPrsn> can someone put a simple example of arrow usage in lambdabot or send me to a page
06:21:46 <TardedPrsn> i wanna use them
06:22:05 <hpc> erus`: this might help: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=9
06:22:45 <hpc> erus`: scroll down about 2/3 of the page, to where it generates names like
06:22:47 <hpc> z_a
06:23:03 <hpc> ... z_z, z_A... z_Z, z_aa
06:24:00 <hpc> it's not typesafe, but it's a start
06:26:15 <Aleks__> I' m a crazy person in UOY
06:26:39 <erus`> Im just gonna write better javascript
06:26:54 <erus`> i have explored all the alternatives
06:26:58 <luite_> you can use coffeescript to make the syntax prettier
06:27:59 <Aleks__> you can drink coffee to stay awake
06:30:11 <ROsy> I'm a phit gurl calld rosyyyy
06:30:16 <bellend> Hello
06:30:37 <erus`> everything is global :(
06:30:45 <Axman6> @ops
06:30:45 <lambdabot> Maybe you meant: docs oeis pl
06:30:52 <Axman6> @where ops
06:30:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:30:58 <erus`> I might just write this in haskell. Most people turn webgl off anyway
06:30:59 <luite_> erus`: what where?
06:31:29 <copumpkin> Aleks__: no
06:31:49 <Aleks__> too many pumpkin in the club, where do I begin?
06:31:59 --- mode: ChanServ set +q *!*@gateway/web/freenode/ip.144.32.178.193
06:32:17 <erus`> luite_: function() { a = 2 } (); alert(a);
06:32:29 <luite_> try var a = 2
06:36:13 --- mode: ChanServ set -q *!*@gateway/web/freenode/ip.144.32.178.193
06:36:35 <luite_> erus`: it's also good practice to work in a local scope with your scripts
06:36:50 <erus`> i do try too
06:39:28 <KizzaD> Hi Paul
06:39:42 <KizzaD> bye dave
06:40:43 <Axman6> @where ops
06:40:43 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:40:54 <bantersaurus> Hello
06:41:09 <Axman6> sorry do to that again :\ seems there's a flooding from the web client
06:41:20 <KizzaD> Hello bantersaurus, have you brought the banter today?
06:41:36 <bantersaurus> yes, I arrived with a flask in my left hand and banter in my right
06:42:05 --- mode: Igloo set +b *!*@gateway/web/freenode/ip.144.32.178.123
06:42:17 <MattBowen_> hey guys
06:42:33 <bantersaurus> hello
06:42:34 <KizzaD> MattBowen is GAY
06:42:35 <MattBowen_> I just had a wet dream about Benest
06:42:38 --- mode: Igloo set +b *!*@gateway/web/freenode/*
06:42:42 --- kick: KizzaD was kicked by Igloo (KizzaD)
06:42:46 --- kick: MattBowen_ was kicked by Igloo (MattBowen_)
06:42:49 <Axman6> Igloo: might be worth quieting the whole of *!*@gateway/web/freenode/ip.*
06:42:56 <quicksilver> he just did, Axman6
06:42:57 <hpc> they make the university of york proud :P
06:43:01 --- kick: bantersaurus was kicked by Igloo (bantersaurus)
06:43:11 <Axman6> quicksilver: no, he only did it for a certain IP
06:43:20 <quicksilver> Axman6: 13:49 -!- mode/#haskell [+b *!*@gateway/web/freenode/*] by Igloo
06:43:44 --- mode: ChanServ set +o quicksilver
06:43:50 <Axman6> ah, right, i missed that
06:43:51 --- mode: quicksilver set -o quicksilver
06:44:04 <Axman6> anyway, thanks Igloo
06:44:21 <Igloo> np
06:44:58 <mysticc> @hoogle Text -
06:44:58 <lambdabot> Parse error:
06:44:58 <lambdabot>   --count=20 "Text -"
06:44:58 <lambdabot>                   ^
06:45:05 <mysticc> @hoogle Text -> ByteString
06:45:05 <lambdabot> Warning: Unknown type Text
06:45:05 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
06:45:06 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
06:45:19 <mysticc> @hoogle Data.Text.Text -> ByteString
06:45:19 <lambdabot> Parse error:
06:45:20 <lambdabot>   --count=20 "Data.Text.Text -> ByteString"
06:45:20 <lambdabot>                  ^
06:45:27 <Axman6> damn, the hoogle database must be quite old for lambdabot now
06:45:43 <Axman6> it probably hasn't been updated since before Text was released
06:46:05 <mysticc> Axman6: thats very bad
06:46:16 <Axman6> indeed. talk to Cale
06:46:22 <quicksilver> mysticc: http://haskell.org/hoogle/?hoogle=Text+-%3E+ByteString
06:52:45 <Phlogistique> hi there
06:52:56 <Phlogistique> is there a way to import a module with ghc -e?
06:54:13 <Phlogistique> to do something like ghc -e 'import Text.Regex.PCRE; getContents >>= liftIO (=~ "...") >>= putStr' for example
06:54:43 <hpc> Phlogistique: read the man, man
06:54:47 <Phlogistique> (I know about hoe, which is a standalone program which does just that)
06:55:02 <Phlogistique> hpc: I wouldn't have known about -e if I didn't read the man
06:55:11 <Phlogistique> which flag did I miss?
06:57:57 <khs> I have a type Qual t. t is of types like Dcon = String, how can I pattern mach on t in a function like func :: (Qual t) -> String ?
06:58:59 <Axman6> khs: we'd need to know what constructors Qual had
06:59:08 <Axman6> type Qual t = ...?
06:59:37 <mysticc> Is there any image manipulation library written in haskell ... (not any bindings)
07:00:16 <dmwit> devil, and the PNG decoder that was someone's masters thesis
07:00:19 <Axman6> if you can do what you want with Repa there's bindings to DevIL that can be used to read and write images to/from Repa arrays
07:00:20 <khs> type Qual t = (Mname, t)   ... type Mname = Maybe AnMname  ...
07:00:23 <luite_> you can use repa
07:00:48 <dmwit> Never mind, apparently devil is a binding.
07:00:57 <luite_> but I don't think it really contains image processing algorithms, it should be easy to implement a few
07:01:00 <Axman6> but Repa isn't specifically designed for image manipulation
07:01:34 <hpc> Phlogistique: hmm, it might not be possible
07:01:37 <ClaudiusMaximus> there are a few simple ppm writers, but i didn't spot a pure haskell reader on hackage...
07:01:52 <luite_> mysticc: what's the problem with bindings? you don't want dependencies?
07:02:06 <hpc> Phlogistique: you could try piping into ghci
07:03:12 <Phlogistique> hpc: I won't do that, (hoe's still better) but thanks for the idea
07:03:26 <mysticc> luite_: Nothing .. Just wondering ..
07:03:36 <Axman6> khs: foo (m,t) = ...
07:03:51 <dgpratt> I'm trying to better understand some of the stuff I'm reading about the new ConstraintKinds GHC extension...
07:04:19 <dgpratt> ...specifically this declaration:
07:04:37 <dgpratt> data Dict :: Constraint -> * where
07:04:39 <dgpratt>   Dict :: a => Dict a
07:04:56 <Axman6> yeah that confused me too
07:05:22 <dgpratt> now first of all terminology, "Constraint -> *" is the...*kind* of type Dict?
07:05:31 <dgpratt> correct?
07:05:33 <Cale> yeah
07:05:42 <dgpratt> ok
07:05:59 <Cale> Constraint is the kind of typeclass constraints, * is the kind of all the ordinary types which have values in them
07:06:40 <Cale> and so Constraint -> * is a type constructor which takes a constraint context as a parameter
07:06:46 <hpc> so you would construct a Dict with (Dict (Num a))?
07:07:01 <dgpratt> ok, in the second line, Dict represents a...value constructor? data constructor? just want the right term
07:07:17 <Cale> hpc: yeah
07:07:29 <Cale> dgpratt: Either of those are fine, data constructor is more common
07:07:33 <dgpratt> ok
07:07:49 <hpc> "value constructor" is mostly for distinguishing from the type constructor
07:08:04 <hpc> (which is confusingly also Dict, in this example)
07:08:22 <danr> dgpratt: Is that the same thing as writing data Dict (a :: Constraint) = a => Dict a ?
07:08:22 <Cale> Yeah, it might be best for discussion if we rename the data constructor to D
07:08:26 <dgpratt> so in the type of the data constructor Dict, 'a' represents the constraint in the type kind above, yes?
07:08:53 <khs> Axman6: So I can't do something like (Just a, Dcon t) when Dcon is just a type synonym for String. t is used for various type synonyms for string, and i'd like to match on those synonyms
07:08:57 <Cale> danr: I'm not sure that syntax is supported... but it's something like that
07:09:25 <embwbam> I asked last night, but I'd love more help with this - http://stackoverflow.com/questions/7996140/haskell-correct-way-to-map-bson-to-json-where-to-put-code
07:09:32 <Cale> dgpratt: Yeah, because it's used as the parameter to the Dict type constructor, a must refer to a Constraint
07:09:43 <Cale> Let's say  D :: a => Dict a
07:09:54 <hpc> dgpratt: http://hpaste.org/53490
07:10:01 <dgpratt> Cale: ok, I think you just answered my immediate question, but let me make sure...
07:10:15 <Cale> hpc: D doesn't have a value parameter
07:10:24 <hpc> oh
07:10:35 <Cale> numDict :: Num a => Dict (Num a)
07:10:38 <Cale> numDict = D
07:10:39 <danr> Cale: yeah, i think the data Foo a = Show a => Bar a syntax is deprecated
07:10:53 <hpc> annotated
07:11:24 <Cale> danr: The trouble with the Haskell 98 (and older) style syntax of data declarations is that it's not very comfortably extensible beyond what it already does.
07:11:38 <dgpratt> the inference is working backwards here, 'a' is referenced in the type 'Dict a', from the type kind declaration we know that 'a' is a constraint, therefore 'a => ...' makes sense?
07:12:00 <Cale> yeah, well, the fact that a occurs to the left of => also means that it must be a Constraint
07:12:11 <Cale> So you could work from that as well
07:12:20 <dgpratt> Cale: ok, awesome; thanks for the explanation
07:12:56 <Cale> The kind checker will presumably collect up a bunch of *cough* constraints on what the kind of each subexpression is, and then solve them.
07:13:29 <Cale> just like the typechecker does with values
07:14:47 <Cale> continuing the example... we could write a function like...
07:15:00 <Cale> foo :: Dict (Num a) -> a -> a
07:15:03 <dgpratt> actually, one more thing: the Dict data constructor defines no value parameters, right? how is that useful?
07:15:05 <Cale> foo D x = x + x
07:15:13 <Cale> ^^
07:15:43 <Cale> pattern matching on that data constructor magically unpacks the dictionary which was required to create it
07:16:13 <dgpratt> hmm
07:16:30 <danr> Cale: I don't have a recent GHC version to test on, what would foo _ x = x + x do?
07:16:31 <Cale> You can already do this to some extent with GADTs
07:17:01 <Cale> (you just can't do it for all typeclasses at once)
07:17:33 <qnikst> is it possible to make smth like  cons' w . cons'   -- i.e. I want to get function Word8 -> ByteString -> ByteString
07:18:05 <danr> Cale: or rather, would it give a type error or not?
07:18:16 <Cale> danr: it gives a type error for missing instance
07:18:23 <Cale> You have to actually pattern match against D
07:18:50 <Cale> (this is more obvious if we add a second constructor to the Dict type with no constraints)
07:19:11 <Cale> data NumDict a where
07:19:11 <Cale>   D :: Num a => NumDict a
07:19:14 <Cale> foo :: NumDict a -> a -> a
07:19:14 <Cale> foo D x = x + x
07:19:16 <dgpratt> Cale: I understand this is supposed to be a simple example, but in this case, is there a tangible benefit of that type sig over  foo :: (Num a) => a -> a ?
07:19:29 <danr> Cale: Ok, good, that was the behaviour I was expecting
07:19:47 <Cale> ^^ this is already valid in release GHCs... I forget the version which introduced it
07:20:45 <hpc> Cale: 7.2 iirc
07:20:46 <Cale> dgpratt: Sometimes it's handy if you're going to forget the type of something to remember some typeclass dictionaries for its type and hang onto them as data.
07:20:57 <Cale> hpc: Surely 7.0.x had it
07:21:08 <Cale> I forget which of the 6.x series had it
07:21:12 <etpace> Has anyone here installed haskell llvm bindings? I'm using cabal install llvm and get an exitfailure 1 with "No instance for (Applicative (StateT CGMState IO))"
07:21:13 <Cale> 6.0 didn't
07:21:25 <hpc> constraint kinds? those are very new
07:21:32 <dgpratt> Cale: ok, thanks
07:21:32 <Cale> hpc: Not constraint kinds
07:21:41 <Cale> GADTs which can capture typeclass dictionaries
07:21:46 <hpc> oh
07:23:01 <Cale> But yeah, constraint kinds are due for 7.4
07:23:29 * hackagebot cabal-macosx 0.1.2.2 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.1.2.2 (AndyGimblett)
07:23:59 <Cale> etpace: that's very odd
07:24:11 <Cale> etpace: that instance should exist
07:24:54 <Cale> etpace: Maybe it got moved since the bindings were written. Ever since the mtl package got split up, I've been horribly confused about the state of the monad libraries.
07:26:09 <etpace> blah, ok cale
07:26:16 <etpace> maybe its a version mismatch
07:26:26 <Cale> yeah, that seems more likely actually
07:26:50 <Cale> Well... if it weren't for the fact that Applicative is defined in base
07:27:04 <Cale> It seems a little unlikely that you have more than one base package installed :P
07:27:27 <Cale> ghc-pkg list and check for duplicates of anything
07:27:41 <Cale> (also ghc-pkg check, but it won't complain about dupes)
07:31:14 <Cale> http://www.youtube.com/watch?v=QBFtnkb2Erg&feature=BFa&list=PLF5363394606160CE
07:41:05 <yitz> Cale: oh dear it looks like some of these changes are significant. i don't have time to watch the whole video. i hope all this gets written up clearly somewhere.
07:42:44 <opqdonut> *sigh*, xml generation. can somebody give me a pointer to some tutorial? all the libs seem to require tons of wrapping just to get a simple document out
07:43:12 <opqdonut> I've looked at HaXML and Text.XML.Light so far
07:43:55 <hpc> opqdonut: you could try adapting blaze-html
07:43:58 <opqdonut> oh, xmlgen looks nice
07:45:55 <Cale> yitz: There's a tremendous amount of sigificant stuff coming in 7.4
07:46:54 <quicksilver> yitz, Cale with a bit of luck some of it will be written up in HCAR
07:47:00 <quicksilver> isn't HCAR due this month in fact
07:52:11 * frerich watches that youtube link Cale posted, and while the changes in the new GHC seem exciting I can't stop wondering.... did he use Comic Sans MS for that presentation?? :-}
07:52:12 <yitz> opqdonut: xml-enumerator
07:52:35 <Cale> frerich: Simon *always* uses Comic Sans MS
07:52:45 <quicksilver> simon is (a) a comedian (b) an MS employee
07:52:54 <quicksilver> what other choice does he have?
07:53:05 <yitz> quicksilver: is he sans?
07:53:13 <quicksilver> totally insans, sometimes
07:53:20 <quicksilver> but very enthusiastic
07:53:25 <geheimdienst> i hear the next version of ms office will use comic sans in all the UI
07:53:39 <Cale> Comic Serif MS would be "interesting"
07:53:50 <erus`> yeh
07:53:51 <Cale> I think that's pretty much the only way you could make it uglier :)
07:53:52 <habitue> could anyone give me a function with the type StateT (a,b) m a -> StateT b m a ?
07:54:05 <hpc> Cale: comic mono
07:54:38 <mux> related: http://www.flickr.com/photos/doctorow/8238052/
07:55:29 <Cale> habitue: That's not theoretically possible
07:55:51 <habitue> shite, I was afraid of that
07:55:53 <Cale> habitue: You could add new components to the state type which went unused
07:55:56 <Axman6> it's not?
07:56:09 <bscarlet> habitue: how about (mapStateT (liftM (second fst)))
07:56:16 <Cale> But removing components from the state type which may be used by the given computation seems pretty unlikely
07:56:23 <copumpkin> @unmtl StateT (a,b) m a -> StateT b m a
07:56:23 <lambdabot> StateT (a, b) m a -> StateT b m a
07:56:24 <danr> @hoogle mapStateT
07:56:24 <lambdabot> Could not find some databases: default
07:56:25 <lambdabot> Searching in:
07:56:25 <lambdabot>   .
07:56:25 <copumpkin> bah
07:56:26 <hpc> habitue: const undefined
07:56:28 <danr> @hoogle mapState
07:56:28 <lambdabot> Could not find some databases: default
07:56:28 <lambdabot> Searching in:
07:56:28 <lambdabot>   .
07:56:33 <quicksilver> Cale: I think you could feedback the result "a" to provide the missing state component, technically ;)
07:56:44 <copumpkin> yay, lambdabot is fucked
07:56:44 <quicksilver> Cale: however, that is not likely to do anything sensible.
07:57:01 <danr> Oh wait, map state does not change the state type, right
07:57:03 <Cale> oh, I tried updating hoogle
07:57:19 <bscarlet> habitue, danr -> bleah, yeah.
07:57:41 <Cale> ah, I think I need to run 'hoogle data'
07:57:46 <Cale> Just trying that now
07:58:14 <Axman6> let foo :: (s -> (a,s)) -> (s -> t) -> (t ... damn, that's why =)
07:59:29 <copumpkin> @unmtl StateT (a,b) m a
07:59:30 <lambdabot> a -> b -> m (a, a, b)
07:59:32 <copumpkin> @unmtl StateT b m a
07:59:33 <lambdabot> b -> m (a, b)
07:59:38 * frerich just tried to find a talk by Don Stewart, just to see what he is like - and youtub'ing for "don stewart haskell" gives less that flattering hits.
07:59:42 <copumpkin> whoa
07:59:50 <copumpkin> @unmtl is confused
07:59:50 <lambdabot> is confused
07:59:53 <copumpkin> see?
08:00:03 <geheimdienst> @vixen
08:00:03 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
08:00:06 <hpc> yeah, i noticed that
08:00:11 <danr> copumpkin: it's currying
08:00:13 <copumpkin> yeah
08:00:15 <copumpkin> which is odd
08:00:24 <danr> yeah :O
08:00:30 <copumpkin> it's also flattening n-tuples
08:00:37 <opqdonut> yitz: xml-enumerator doesn't seem to have any helpers for succinctly constructing Documents, one has to list out the millions of fields etc.
08:00:58 <copumpkin> or maybe its printer just considers (,) to be right-associative
08:01:30 <Axman6> frerich: there's a few videos of him around
08:02:40 <yitz> opqdonut: if you are constructing it from scratch than yeah you need to build a document.
08:03:06 <opqdonut> yitz: yeah, from scratch. xmlgen seems nice for this.
08:03:08 <yitz> opqdonut: but there aren't millions of fields.
08:03:24 <opqdonut> well still a nontrivial number :)
08:03:29 <copumpkin> preflex: seen sjanssen
08:03:29 <preflex>  sjanssen was last seen on #haskell 203 days, 8 hours, 3 minutes and 19 seconds ago, saying: Athas: no.  The bindings have been written on an as-needed basis, I guess those functions haven't been missed yet
08:03:36 <opqdonut> at least when I look at the parse output for some documents
08:04:00 <Athas> copumpkin: I haven't seen him since either.  He doesn't respond to email.
08:04:16 <copumpkin> dcoutts: wasn't he briefly involved with well-typed?
08:04:43 <yitz> opqdonut: X.Document (X.Prologue [] Nothing []), then after that it's just elements and attributes
08:04:48 <copumpkin> Athas: yeah, people seem to disappear around here :o
08:04:55 <hpc> preflex: seen mmorrow
08:04:55 <preflex>  mmorrow was last seen on #ghc 1 year, 289 days, 12 hours, 14 minutes and 4 seconds ago, saying: * mmorrow is rtfm'ing
08:04:59 <hpc> :D
08:05:16 <hpc> copumpkin: it's the ruby hit-squad
08:06:00 <yitz> really sjanssen also disappeared? that's terrible.
08:13:19 <gwern> lambdabot: @join #lesswrong
08:14:03 <quicksilver> copumpkin: we lost him to mtg I suppose - http://www.mtgdecks.net/decks/view/18335
08:15:13 <tac-tics> <3 Ornithopter
08:15:35 <copumpkin> mmorrow is probably climbing rocks, off the grid, in colorado, if people are curious
08:15:41 <rostayob> is there a way to expand type synonyms?
08:15:52 <rostayob> like expand String -> [Char]
08:15:52 <gwern> quicksilver: a little sad; most people get their life-sucking worthless games out of their system when they're young and otherwise useless
08:15:55 <rostayob> in ghci or something like that
08:16:04 <Axman6> copumpkin: so he's not dead then?
08:16:07 <copumpkin> quicksilver: dammit, we must bring him back
08:16:22 <quicksilver> gwern: nothing which brings pleasure is entirely worthless.
08:16:26 <copumpkin> Axman6: rumor has it that he isn't, but I'm not sure what triggered the whole falling off the face of the earth
08:16:52 <gwern> quicksilver: even on utilitarian terms... look into hyperbolic discounting and TV satisfaction surveys
08:17:09 <copumpkin> Axman6: through some most excellent sleuthing, I tracked down a childhood friend of his and talked to him about it on facebook. He said that none of his friends in the area had really seen him in ages, but that the rumor was that he'd gone off in that direction
08:17:25 <Axman6> well, i prefer him not being dead, so i'll stick to that one.
08:17:57 <Axman6> good work on the sleuthing =)
08:19:02 <copumpkin> hah, in other contexts it might be called stalking, but I was worried
08:19:22 <gwern> copumpkin: 'in that direction' <-- becoming a pro MtG player?
08:19:33 <copumpkin> gwern: I'm talking about mmorrow
08:19:41 <hpaste> Lambdanaut pasted ‚ÄúSeiveofEratosthenes‚Äù at http://hpaste.org/53493
08:19:47 <gwern> oh, the rocking climbs thing
08:20:04 <lambdanaut> Would anyone mind looking at that seive of mine?
08:20:15 <Saizan> nice deck btw
08:20:19 <copumpkin> lol
08:20:26 <lambdanaut> I can't understand why it's so inefficient
08:20:27 <copumpkin> @tell sjanssen nice deck
08:20:28 <lambdabot> Consider it noted.
08:22:07 <qnikst> can smb advice how to optimize: f w = SL.foldl (\acc x -> if (x==0x00) then (\x-> acc (0x00-x) else (acc x.).cons') (cons') w
08:22:09 <qnikst> ?
08:22:26 <qnikst> I want to build Lazy ByteString from another one
08:23:11 <qnikst> problem here that I'm getting not ByteString but Word8 -> ByteString -> ByteString so I have add additional Word8 to get value out
08:23:30 * hackagebot cereal 0.3.4.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.4.0 (TrevorElliott)
08:24:52 <yitz> copumpkin: thanks for that i was also worried about him
08:25:12 <raichoo> any op here that can unban missingfaktor? He seems to be banned for some reason.
08:25:20 <copumpkin> the manual was probably so large he needed to retire to the mountains to read it all
08:25:28 --- mode: ChanServ set +o copumpkin
08:25:38 --- mode: copumpkin set -b *!*@gateway/web/freenode/*
08:25:50 <raichoo> copumpkin: thanks a bunch.
08:25:56 <yitz> glad to see that sjanssen is still around. noticed that he added a few things to his amazon wish list recently too. hope he'll be back soon.
08:26:02 <Cale> qnikst: What does this function actually compute?
08:26:13 --- mode: copumpkin set +b *!*@gateway/web/freenode/ip.144.32.178.*
08:26:20 --- mode: copumpkin set -o copumpkin
08:26:29 <qnikst> it maps bytestring of type (ABC0D) to (ABC(-D))
08:26:49 <qnikst> i.e. delete zero byte and change next byte after zero
08:27:02 <Cale> okay
08:31:44 <Paks> lambdanaut: read this to know why the sieve is ineficient http://www.haskell.org/haskellwiki/Primes#Turner.27s_sieve_-_Trial_division
08:39:24 <rostayob> what does the 'x' in Rep a x stand for http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html ?
08:40:30 <rostayob> in general I have trouble understanding that type class
08:40:43 <parcs> because of constraint kinds, is => sort of like a function arrow?
08:41:40 <portnov> hi all
08:42:17 <portnov> Q: is there any way to rebuild all cabal-installed packages with another options, e.g. -O2 ?
08:45:33 --- mode: ChanServ set +o monochrom
08:45:47 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.144.32.178.123
08:45:57 --- mode: monochrom set -o monochrom
08:47:29 <mysticc> Is there a read for Text
08:47:51 <mysticc> I cant find it in Data.Text ?
08:47:59 <monochrom> yes
08:48:11 <mysticc> monochrom: where ?
08:48:33 <monochrom> hop into ghci, :m + Data.Text, :info Text
08:48:42 <monochrom> "instance Read Text -- Defined in Data.Text"
08:50:50 <mysticc> monochrom: I want read :: Read a => Text -> a ?
08:51:05 <monochrom> then there is none
08:51:19 <mysticc> right now I am using read . unpack
08:52:04 <parcs> http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/Data-Text-Read.html
08:54:46 <rostayob> Saizan: can I ask you something about the Generic typeclass? I don't get Rep is of kind 2. Does the type param stand for the contained inner data?
08:55:18 <Drakken> howdy
08:55:54 <Drakken> Is there a channel for category theory?
08:56:23 <hpc> ##categorytheory iirc
08:56:57 <hpc> possibly #categorytheory
08:57:23 <copumpkin> ##
08:57:34 <hpc> groovy
08:58:14 <Drakken> hpc thanks
08:58:34 <Drakken> copunkin you too
09:18:52 <rostayob> I can't write the signature of 'v': http://hpaste.org/53495
09:20:31 <monochrom> does ghci infer a type for you
09:20:35 <quicksilver> rostayob: Generic a => a -> Var ?
09:20:41 <rostayob> quicksilver: no
09:20:44 <rostayob> it should be
09:20:45 <quicksilver> Var a doesn't make sense, since 'Var' doesn't have a parameter
09:20:54 <rostayob> yes right, but it's not that
09:21:02 <rostayob> if you put the type that ghc infers
09:21:06 <rostayob> it refuses it
09:21:10 <monochrom> what is the type of from?
09:21:15 <rostayob> (v :: (Generic a, Generic a1, Rep a1 ~ Rep a) => a1 -> Var)
09:21:33 <rostayob> monochrom: from is from GHC.Generics
09:21:39 <quicksilver> well, constraints on data  constructors don't really work
09:21:43 <quicksilver> they were just a bug in haskell98/GHC anyway
09:21:56 <quicksilver> rewrite in GADT syntax and you might get something more sensible
09:21:56 <rostayob> quicksilver: that's an existential type
09:22:05 <hpc> v :: (Generic a, Rep a) => a -> Var
09:22:09 <hpc> perhaps?
09:22:13 <quicksilver> yes, it is, but the constraint is in a single constructer
09:22:19 <quicksilver> rather than o the whole type
09:22:26 <quicksilver> I think there are/were bugs in that.
09:22:30 <quicksilver> try the GADT version
09:22:38 <rostayob> hpc: rep is a type family
09:22:48 <hpc> oh
09:22:48 <rostayob> quicksilver: will try, thanks
09:23:04 <rostayob> but there is a bug
09:23:08 <rostayob> in ghc when it type checks that
09:24:58 <rostayob> quicksilver: nope, exact same problem.
09:25:19 <rostayob> ghc infers 'v :: (Generic a, Generic a1, Rep a1 ~ Rep a) => a1 -> Var', which makes no sense to me
09:25:42 <quicksilver> ah yes, that makes sense to me
09:25:50 <quicksilver> Rep is not injective
09:25:59 <quicksilver> so two different types could have the same Rep
09:26:05 <quicksilver> "Rep a Var" doesnt' determine a
09:26:21 <rostayob> yeah rep is just a type synonym
09:26:25 <rostayob> but why is that a problem?
09:28:29 <quicksilver> well because the a in Generic a => might not be the same a as the a you pass in
09:28:36 <quicksilver> it could be a different a which happens to have the same Rep
09:28:42 <quicksilver> hence the a and a1 in the signature
09:29:39 <rostayob> well but why is one 'a1' enough?
09:30:25 <quicksilver> because there are two types
09:30:28 <quicksilver> the a you pass
09:30:43 <quicksilver> and the 'a' hidden in the existential
09:30:43 <rostayob> oh, right.
09:31:04 <rostayob> it's curious that you can't explicitly type that eheh
09:31:15 <quicksilver> if you want to use 'Rep' you need to keep a copy of the actualy type around to recover it later
09:31:25 <quicksilver> when I say a 'copy of' I only mean at the type level
09:31:48 <quicksilver> but something needs to "remember" the type so you can "recover" the right one later
09:33:16 <rostayob> i don't understand.
09:33:25 <rostayob> aj.
09:33:27 <rostayob> yes
09:33:50 <rostayob> no.
09:33:56 <quicksilver> it's a bit like Read
09:34:09 <quicksilver> Read is all very well but it's useless if you don't statically know the type you're expected at the other end
09:34:17 <rostayob> yeah of course
09:34:36 <rostayob> but i don't get why you need two types to remember them or whatever
09:34:45 <quicksilver> unless your *objective* is to translate between two different types which you know will have the same Rep
09:34:59 <quicksilver> but I don't understand the new generics stuff well enough to know if that's a good idea
09:34:59 <rostayob> I mean when you pass a value of type a to 'v', it'll just create the existential with a value of type 'a' inside
09:35:14 <rostayob> quicksilver: I don't either to be honest, i was playing with it
09:35:22 <quicksilver> (presumably (a,b) will have the same Rep as data Pair a b = Pair a b, for example)
09:35:28 <rostayob> quicksilver: no, my objective is not that
09:36:09 <dreixel> quicksilver: it won't, if it's the Rep you get by deriving Generic
09:36:43 <rostayob> well the data is similar but there is some metadata to 'tag' the data
09:36:43 <dreixel> but I don't quite see what rostayob is trying to do here
09:37:10 <dreixel> is it like meta-variable extension?
09:37:25 <rostayob> dreixel: I'm trying to write a generic unification algorithm
09:37:56 <rostayob> so my idea is that Var either holds a fresh variable or some generic data, containing other vars
09:37:59 <rostayob> the thing is that
09:38:46 <rostayob> I'm not sure about the Rep a x type family
09:38:46 <rostayob> what's x?
09:38:46 <rostayob> is it the data contained in the generic representation?
09:39:06 <quicksilver> dreixel: (why not? why isn't it just Rep a :*: Rep b?)
09:39:17 <rostayob> quicksilver: there is some metadata, see the M1 type
09:39:39 <legbrokenrambo> hey guys
09:40:13 <dreixel> quicksilver: no, it has all the metadata around it (datatype/constructor/selector info)
09:40:39 * quicksilver nods
09:40:57 <dreixel> (also, it's not recursive, so no Rep's on the rhs)
09:41:21 <dreixel> rostayob: the `x` is "the" parameter
09:41:40 <dreixel> so, the `a` in `[a]`, and the `b` in `Either a b`
09:41:52 <msieradzki> how do I constrain a in (undefined :: a) to match the same a that I get from Storable a => ? http://hpaste.org/53496
09:42:00 <rostayob> yep, but what does it do in Rep?
09:42:09 <dreixel> it's abstracted over
09:42:14 <quicksilver> msieradzki: using "ScopedTypeVariables"
09:42:15 <rostayob> msieradzki: ScopedTypeVariables
09:42:18 <dreixel> so that you can write functions like map
09:42:27 <quicksilver> msieradzki: http://www.haskell.org/haskellwiki/Scoped_type_variables
09:42:56 <rostayob> msieradzki: basically, enable -XScopedTypeVariable and add a forall a. after the ::
09:43:44 <rostayob> dreixel: I don't get it. The 'x' is the pf' in M1 i c f p, for example
09:43:48 <rostayob> *'p'
09:43:55 <dreixel> yeah, it's passed around everywhere
09:43:58 <dreixel> but only used in Par1
09:44:50 <erus`> does a language need currying for nice monads?
09:44:58 <msieradzki> now I finally know what ScopedTypeVariables is for :)
09:45:00 <dreixel> rostayob: did you see the paper http://dreixel.net/research/pdf/gdmh.pdf ? the syntax changed a bit, but other than that it's explained there in detail
09:45:31 <rostayob> dreixel: no, I will
09:45:46 <rostayob> right now, I still don't get why you need that
09:46:08 <dreixel> only to write functions that abstract over parameters
09:46:21 <dreixel> stuff like what lives in Functor, Traversable, etc
09:46:38 <dreixel> you don't need it for things like show, read, enum, etc
09:46:55 <rostayob> so it's just a phantom type?
09:47:07 <dreixel> eh
09:47:09 <rostayob> (i'm not sure that's the right term)
09:47:16 <dreixel> well...
09:47:21 <dreixel> in Rep it actually is, I think.
09:47:22 <rostayob> i mean is it just a placeholder for whatever you want to use?
09:47:32 <dreixel> no, it just never shows up on the right
09:47:45 <rostayob> or does it correspond to some actual data of that type?
09:47:56 <dreixel> wait, sorry
09:48:24 <dreixel> ah, right
09:48:36 <dreixel> in Rep, the `x` is not used at all
09:48:44 <dreixel> it could also be (), or Int, or anything you'd like.
09:48:49 <dreixel> it only matters in Rep1
09:49:03 <rostayob> oh, ok. so it doesn't matter
09:49:04 <dreixel> because there you are representing a type of kind (at least) * -> *
09:49:10 <rostayob> yes
09:49:24 <rostayob> but why is it present in rep at all? i mean intuitive Rep is of kind *
09:49:29 <dreixel> exactly
09:49:36 <dreixel> but then you would need two generic representations
09:49:40 <rostayob> so why not have it of kind *?
09:49:41 <dreixel> one of kind *, the other of kind * -> *
09:49:46 <rostayob> ah, right.
09:49:50 <dreixel> which means lots of duplication
09:49:50 <rostayob> is to have the same constructors
09:49:53 <rostayob> yes
09:50:00 <dreixel> the paper explains this too
09:50:19 <rostayob> i was frantically looking for the x on the rhs eheh
09:50:26 <rostayob> ok i'll read the paper when i have time
09:50:57 <dreixel> you won't need to read the whole thing, the first part should be enough to give you a better overview
09:53:31 * hackagebot base-unicode-symbols 0.2.2.2 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.2 (RoelVanDijk)
09:55:06 <Tom__> hello
09:55:07 <mkscrg> is it possible to include a data definition within a class definition?
09:56:33 <rostayob> mkscrg: take a look at type families
09:56:43 <rostayob> it's not really what you want
09:56:46 <rostayob> but kind of
09:57:19 <mkscrg> rostayob: thanks, i'll check it out
09:58:12 <rostayob> mkscrg: you're probably better off asking about the problem you want to solve anyway :P
09:58:31 * hackagebot containers-unicode-symbols 0.3.0.5 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.5 (RoelVanDijk)
10:02:38 <rostayob> dreixel: since you are already generating ad-hoc data types for the metadata, wouldn't it be betteer to have a thin wrapper around the generic representation, instead that a type synonym?
10:03:26 <rostayob> so that Rep would be injective
10:03:33 * hackagebot iteratee 0.8.7 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7 (JohnLato)
10:03:35 * hackagebot listlike-instances 0.2.1 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.2.1 (JohnLato)
10:24:51 <rostayob> is it possible to have a case with guards? or anyway, a way to embed pattern guards in monadic code
10:26:31 <ClaudiusMaximus> rostayob: yes; case ... of pattern | guard -> ... | guard -> ... ...
10:26:51 <dreixel> rostayob: if you mean making Rep into a data family (instead of a type family)
10:27:11 <dreixel> the bad thing is that then you can't be generic anymore, because you are basically introducing a new constructor for each representation...
10:27:17 <kowey> rostayob: adding to that, one idiom I sometimes find handy is case () of _ | guard -> ... | guard -> ...
10:27:28 <rostayob> ClaudiusMaximus: coolio, thanks
10:27:51 <rostayob> dreixel: no, a newtype, with a function in the type family to get the generic type representation
10:27:56 <rostayob> Rep a x -> M1 whatever
10:28:15 <rostayob> just to have a 1:1 mapping at the type level between types and representations
10:28:21 <dreixel> rostayob:  I don't see what you mean
10:29:39 <hpaste> rostayob pasted ‚Äúdreixel‚Äù at http://hpaste.org/53498
10:29:53 <dgpratt> what's the state of ODBC on Windows (in Haskell, of course)? Any packages known to work well or not at all?
10:30:41 <rostayob> dreixel: this way the Rep would be unambiguous
10:32:44 <kosmikus> rostayob: I don't see what the extra datatype would give you
10:33:01 <rostayob> kosmikus: the fact that a Rep a x for a certain a would be unique
10:33:38 <rostayob> well, at the type level
10:33:42 <rostayob> unique is not the right word
10:33:45 <kosmikus> rostayob: newtype Gen a x = MkGen (Rep a x)
10:33:52 <kosmikus> you can do that yourself
10:34:09 <kosmikus> no need to clutter the class
10:34:24 <rostayob> yeah but you can't generically wrap/unwrap if you define it yourself
10:34:36 <kosmikus> why not?
10:34:47 <rostayob> oh right
10:34:52 <rostayob> yes you're right, sorry
10:36:22 <kosmikus> no need to apologize :)
10:36:32 <rostayob> well i tend to talk without thinking eheh
10:51:22 <dgpratt> maybe I misunderstand the function and/or purpose of cabal-dev, but it's not working according to my expectation...
10:51:22 <edwardk> mm_freak: fixed
10:51:56 <dgpratt> I thought that I could use it to experiment with a package (or several) that I wasn't ready to 'commit' to yet
10:52:30 <dgpratt> first I did: cabal-dev install some-pkg
10:52:41 <dgpratt> then: cabal-dev ghci
10:53:07 <dgpratt> which resulted in an error: cabal-dev.exe: user error (cabal.exe: No cabal file found...
10:53:57 <dgpratt> am I not understanding what cabal-dev is for or how to use it or other?
11:00:24 <c_wraith> dgpratt: cabal-dev is used for creating and managing sandboxed environments.  But it can't do that ad-hoc.  You need to set up individual sandboxes to work inside
11:01:06 <dgpratt> c_wraith: ok, thanks; any good resource for figuring out how to do that?
11:01:54 <c_wraith> dgpratt: I haven't actually used it.  You'll have to ask elsewhere for that.  Or maybe find some of their announcements that include usage instructions
11:02:06 <dgpratt> c_wraith: ok, thanks
11:15:18 <Boogie> Hello Haskellers
11:16:03 <MostAwesomeDude> I'm not a Haskeller. I just play one on TV.
11:17:10 <c_wraith> you're on tv? cool
11:18:48 <dhun_233> I got a problem with hxt in case of malformatted xml, I want Nothing not error. Any ideas?
11:19:19 <c_wraith> spoon?
11:19:30 <c_wraith> @hackage spoon
11:19:30 <lambdabot> http://hackage.haskell.org/package/spoon
11:19:37 <c_wraith> It's a...  very heavy solution
11:19:41 <c_wraith> but it will work!
11:20:45 <c_wraith> since I know nothing about hxt and the documentation is frightening, I don't know if there's a better solution
11:21:04 <dhun_233> i will try
11:28:35 <Guest11613> testing erc
11:32:57 <dhun_233> its a little bit funny. In germany there is a saying "to give away the spoon", meaning to die. So thanks for the spoon.
11:38:00 <gtirloni> there is no spoon
11:38:22 <homie> use the fork then!
11:38:24 <homie> lol
11:38:53 <sbi> *spork*
11:38:58 <dhun_233> no no forks can cause run conditions, better use a spoon#
11:39:42 <homie> run conditions ? marathon ?
11:39:46 <homie> lol
11:39:50 <EvanR-work> import Utensils.Knife
11:40:19 <EvanR-work> unsafeStabThroughInternet
11:40:47 * homie puts the gum
11:42:25 <Sgeo|web> Is Network.CGI a decent way to write a simple web thing?
11:42:59 <monochrom> yes
11:44:23 <Sgeo|web> class Monad m => MonadIO m where
11:44:28 <Sgeo|web> Why is that defined in there?
11:44:39 <monochrom> no, imported
11:44:45 <Sgeo|web> Oh
11:44:49 <monochrom> imported and re-exported
11:45:16 <geheimdienst> @tell gwern could you put hacboston on the haskell.org front page, events section? thanks -- [[Hac Boston]] January 20 to 22, 2012 in Cambridge, Massachusetts
11:45:17 <lambdabot> Consider it noted.
11:45:43 <shachaf> geheimdienst: Are you going?
11:46:29 <Guest11613> Latest quickcheck can show higher-order couterexamples.  I can get it to work for unary functions but not for functions w more args. Anyone used this undocumented stuff?
11:46:50 <shachaf> Oh, wow, the attendees page certainly grew.
11:46:57 <geheimdienst> shachaf: i guess not :( ... 2 days seems a little short to justify the transpondian flight ...
11:48:14 <shachaf> geheimdienst: Aw.
11:48:34 <shachaf> geheimdienst: I'll take solace in the fact that djahandarie is going.
11:48:35 <geheimdienst> are you?
11:48:45 <luite_> geheimdienst: can't you use that as an excuse to stay a bit longer?
11:48:47 <shachaf> I'm not sure.
11:48:49 <dhun_233> c_wraith, I tried spoon, but it didn't work, it still get error. But I can only use teaspoon
11:49:01 <shachaf> luite_ talks sense.
11:49:19 <dhun_233> getTextContent:: String->Maybe (IO (Maybe String))
11:49:19 <dhun_233> getTextContent z= teaspoon $
11:49:26 <c_wraith> Ah.  That is an unfortunate outcome.  In that case,  I can't really suggest anything useful
11:49:37 <c_wraith> oh, wait
11:49:41 <c_wraith> that doesn't look right.
11:50:13 <c_wraith> neither spoon nor teaspoon can do anything useful with IO actions
11:50:21 <c_wraith> they're only for exceptions from pure code
11:50:33 <dhun_233> but I belive to be in IO by using hxt
11:50:51 <c_wraith> if the IO action is what's throwing the exception, just look at try from Control.Exception
11:51:06 <dhun_233> ok
12:02:47 * DanBurton wonders who runs preflex
12:02:59 <geheimdienst> DanBurton: i believe it's mauke
12:03:03 <shachaf> DanBurton: /whois would answer that. :-)
12:03:21 <DanBurton> yep mauke
12:10:22 <Sgeo|web> "non-portable (uses Control.Monad.State) "
12:10:23 <Sgeo|web> Um
12:10:32 <Sgeo|web> How is Control.Monad.State not portable?
12:11:28 <Sgeo|web> I think the State monad was what made monads click for me. (Monad transformers still have not quited clicked)
12:12:02 <shachaf> Sgeo|web: Probably uses non-H98 classes?
12:12:24 <Sgeo|web> "	non-portable (multi-param classes, functional dependencie"
12:12:25 <Sgeo|web> s
12:12:35 <shachaf> There you go.
12:15:28 <sajkr> @djinn
12:15:28 <lambdabot> Cannot parse command
12:15:42 <Sgeo|web> @djinn a -> b -> c -> c -> b -> a
12:15:42 <lambdabot> f a _ _ _ _ = a
12:15:44 <sajkr> @djinn (a, b) ->
12:15:44 <lambdabot> Cannot parse command
12:16:11 <sajkr> sorry :)
12:16:12 <shachaf> @djinn a -> a -> (a,a)
12:16:13 <lambdabot> f a b = (b, a)
12:16:33 * Sgeo|web is vaguely amused at that order
12:17:01 <Sgeo|web> @djinn (a,a) -> a -> a
12:17:01 <lambdabot> f _ a = a
12:17:20 <Sgeo|web> @djinn ((a,a) -> a) -> a
12:17:20 <lambdabot> -- f cannot be realized.
12:17:26 <MostAwesomeDude> What's @djinn do?
12:17:36 <Sgeo|web> MostAwesomeDude: try to determine a function from a type
12:17:41 <Sgeo|web> I don't know any details
12:18:58 <Phlogistique> is there a hugs equivalent to ghc -e ?
12:19:34 <Cale> Sgeo|web: To understand StateT given that you already understand the implementation of State takes not so many steps:
12:19:46 <Cale> Recall that for State s, we had:
12:20:24 <Cale> x >>= f = State (\s -> let (v,s') = runState x s; (w,s'') = runState (f v) s' in (w,s''))
12:20:30 <Cale> yeah?
12:21:23 <Cale> StateT comes about by looking at what happens if we replace that let with do
12:21:43 <Cale> x >>= f = StateT (\s -> do (v,s') <- runState x s; (w,s'') <- runState (f v) s'; return (w,s''))
12:21:47 <Cale> er
12:21:53 <Cale> x >>= f = StateT (\s -> do (v,s') <- runStateT x s; (w,s'') <- runStateT (f v) s'; return (w,s''))
12:21:57 <Cale> (just adding some T's)
12:22:08 <ezyang> In http://comonad.com/reader/2011/what-constraints-entail-part-1/ what is Edward Kmett attempting to do?
12:22:32 <edwardk> I'm making a framework for talking about the liskov substitutability of constraints
12:22:33 <Cale> So instead of just computing results in a plain way, computing them in some other arbitrary monad.
12:23:04 <ezyang> edwardk: Do you believe that such a principle holds?
12:23:23 <Sgeo|web> WHy does Network.CGI default to  ISO-8859-1 ?
12:23:55 <Sgeo|web> Cale: At least, I understood State at one point >.>
12:24:00 <Sgeo|web> Maybe I should look at this again
12:25:25 <Cale> Latin1 is a pretty common encoding to choose if you restrict yourself to only one byte per character. I believe at the time that Network.CGI was written, the IO library didn't have any support for encoding Char values higher than \255
12:25:40 <simon> Cale, so you can say that State works on some state, and StateT works on some monad with some state?
12:25:47 <edwardk> Constraint Kinds are useful, but you some times get constraints that have the wrong shape. where you have a pair and only need one half, etc.
12:25:47 <edwardk> It does
12:25:47 <edwardk> ~ is too strong an equality for constraints in many ways.
12:25:47 <edwardk> so building a notion :- of entailment lets me build a notion of equivalence :~ where (a,b) :~ (b,a) based on bi-entailment
12:25:48 <edwardk> ezyang: did you see part 2 yet?
12:26:30 <ezyang> Basically, I'm failing to squint enough and suspend my disbelief on the post ^_^
12:27:02 <edwardk> ezyang: basically given entailment, we can compose entailments, right?
12:27:21 <ezyang> Yeah, I totally failed to figure out why constraint kinds lets us encode entailment.
12:27:38 <edwardk> Ok. Lets start there =)
12:28:01 <edwardk> data Dict :: Constraint -> * where Dict :: a => Dict a -- that guy should be pretty obvious
12:28:22 <Cale> Hey, the encoding of entailment there is really cute
12:28:31 <edwardk> all it is is a GADT that when pattern matched on brings whatever constraint 'a' you specified into scope
12:28:36 <edwardk> thanks =)
12:28:46 <edwardk> i was amazed when it worked
12:28:57 <mgccl> so I try to compose two functions, f that takes [Bool]->Bool and map.  so I did z = f . map and it give me error.
12:29:04 <edwardk> so you accept Dict?
12:29:19 <Sgeo|web> Hmm
12:29:28 <ezyang> I'd love a short example.
12:29:31 <mgccl> what I want is something like g z xs = f (map z xs), but it doesn't work if I do g z xs = f . map z xs
12:29:39 <edwardk> Dict :: Dict (Ord Int)
12:29:53 <Sgeo|web> If I do main = runCGI $ redirect "http://example.com" >> output "Hello"
12:30:01 <Cale> mgccl: (f . map z) xs = f (map z xs)
12:30:11 <Sgeo|web> THen the location header would still be output, but Hello would also be output, right?
12:30:29 <edwardk> would be something that captures the dictionary for Ord Int, if you later opened it up somewhere that was expecting an (Ord a) -- you could use the Ord instance for a in that context, even if you didn't have it in the signature somewhere
12:30:42 <Cale> mgccl: So if  g z xs = f (map z xs) = (f . map z) xs, then g z = f . map z
12:30:43 <DasIch> are there any GUI applications being developed in haskell using gtk?
12:31:05 <c_wraith> DasIch: well, there's threadscope
12:31:12 * Baughn wonders how to deal with a Haskell object that will only be pointed to by a foreign-language object
12:31:13 <ezyang> edwardk: OK, I see where the explicit dicts happen.
12:31:30 <edwardk> sweet. now we need to get creative
12:31:32 <acowley> edwardk: your blog posts were heavy reading last night, please try to interleave some lighter fare when posting multi-episode sequences late at night :P
12:31:33 <Baughn> Lessee.. oh, StablePtr.
12:31:39 <edwardk> acowley: =)
12:31:41 <Cale> and if you want to go farther, g z = f . map z = ((f .) . map) z, and so g = (f .) . map
12:31:53 <edwardk> then lets look at entailment
12:32:02 <ezyang> (though I'm not 100% clear how to use it in practice)
12:32:22 <ezyang> For example, writing Dict :: Dict (Ord Int) isn't actually useful...
12:32:27 <ezyang> (is it?)
12:32:27 <edwardk> lets look at something where i occasionally have to capture a dictionary when it is in scope and then use it later
12:32:44 <edwardk> remember you capture the dictionary at that site, but you can _use_ it much later
12:32:45 <mgccl> Cale: thx, I see now, it only takes the first argument.
12:33:03 <edwardk> for instance when folding, you might open the Dict you had when you built the container, to extract entries from your heap in order
12:33:17 <edwardk> even though Foldable doesn't let you put an Ord constraint on your contents
12:33:52 <edwardk> data Heap a = Empty | Heap (TheRealHeap a) (Dict (Ord a))
12:33:57 <ezyang> Yes. But usually you'll have Dict (Ord a) where a is mentioned elsewhere.
12:34:43 * Baughn grumbles about bool being /so/ a valid C type.
12:34:51 <edwardk> instance Foldable Heap where foldMap f (Heap r Dict) =  foldMap' f r           foldMap' :: Ord a => (a -> m) -> TheRealHeap a -> m
12:35:06 <edwardk> opening Dict there brought the Ord instance into scope, allowing you to call foldMap' there
12:35:26 <ezyang> OK, that's great.
12:35:29 <edwardk> then singleton which isn't part of Foldable could be responsible for capturing the dictionary
12:35:53 <edwardk> this is the usual usecase for capturing dictionaries using GADTs
12:36:06 <edwardk> but traditionally you could only capture some _particular_ dictionary type using a GADT
12:36:46 <edwardk> now with constraint kinds you can encapsulate this behavior so you don't have to make data OrdDict a where OrdDict :: Ord a => OrdDict a
12:36:47 <edwardk> etc
12:37:21 <edwardk> when talking about HLIsts for instance, it is occasionally nice to capture  data type that says for every type in the HList some constraint holds
12:37:36 <edwardk> e.g. All Show    or All Read   or All Eq
12:37:54 <edwardk> but traditionally you had to make one such class for every such constraint
12:38:02 <edwardk> now you can work with those polymorphically
12:38:09 <edwardk> next
12:38:22 <edwardk> the ability to construct a dictionary is a function of entailment.
12:38:30 <edwardk> If I know Ord Foo    then I can derive Eq Foo
12:38:37 <edwardk> so logically Ord Foo |- Eq Foo
12:38:45 <edwardk> (a,b) |- a
12:38:52 <copumpkin> hmm
12:38:52 <edwardk> etc.
12:38:52 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
12:39:17 <EvanR-work> Baughn: bool isnt a valid C type, at least, not in any real version of C ;)
12:39:18 <edwardk> copumpkin has some rather well worked out examples of the All constraint
12:39:36 <copumpkin> there are two ways to construct it
12:39:36 <lambdabot> copumpkin: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:39:37 <Baughn> EvanR-work: stdbool.h is, though.
12:39:39 <copumpkin> one slightly more flexible than the other
12:39:43 <edwardk> so what i do next after defining the dictionary data type is capture this notion of entailment
12:39:56 <Baughn> EvanR-work: And because gcc's version consists of "#define bool _Bool", c2hs chokes on it
12:40:22 <edwardk> data (:-) :: Constraint -> Constraint -> * where Sub :: (a => Dict b) -> a :- b
12:40:32 <edwardk> note that this a => is in negative position
12:40:51 <EvanR-work> Baughn: this amount of mechanisms and work surrounding freaking *bool* is ridiculous
12:40:52 <edwardk> Dict :: a => Dict said that opening Dict brought a into scope
12:40:58 <EvanR-work> data Bool = True | False
12:41:10 <Baughn> Actually, you want False | True. :P
12:41:34 <edwardk> Sub :: (a => Dict b) -> a :- b    says that opening Sub brings into scope a computation that when fed a dictionary for a, will give you a Dict b.
12:41:59 <edwardk> so pattern matching on Sub is when you try to pair up that as-yet-possibly-unmet-obligation with an instance of 'a' in scope
12:42:23 <edwardk> (\\) is then how you exploit this.
12:42:40 <Baughn> EvanR-work: And yes, I realize that was proving your point. Still, there's a reason there's so much mechanism to it - it's a rather fundamental machine language thing
12:42:57 <edwardk> (\\) :: a => (b => r) -> (a :- b) -> r; r \\ Sub Dict = r  -- does a LOT of stuff in a very small amount of code
12:43:04 <edwardk> we know a. from the =>
12:43:39 <EvanR-work> Baughn: well c-- seems to handle it pretty nicely
12:43:47 <edwardk> so we use that to pattern match on Sub, opening the (a :- b), bringing into scope a computation a => Dict b, but since we know 'a' we can discharge that obligation.
12:44:05 <edwardk> so now we have a member of Dict b, which we pattern match on, bringing 'b' into scope.
12:44:10 <Baughn> EvanR-work: C's treatment of bool is what I'm having trouble with here.
12:44:18 <acowley> Tangential question: is the "a => (b => r)" syntax new?
12:44:21 <frerich_> hi
12:44:37 <Baughn> acowley: Yeah, think so.
12:44:39 <edwardk> since we know b we can meet the obligation of the computation from (b => r), and so we can just return r
12:44:49 <edwardk> acowley: actually it has worked for a long time
12:44:49 <dylukes> edwardk: Ey, I actually talked to him,
12:45:01 <dylukes> and I'm going to focus in on the stg compiler. He was surprisingly okay with the idea.
12:45:03 <edwardk> dylukes: the teacher?
12:45:05 <dylukes> yeah.
12:45:05 <copumpkin> acowley: you have to be able to do that with other kinds of constraints
12:45:06 <edwardk> good
12:45:14 <copumpkin> acowley: think about implicit parameters or equality constraints
12:45:21 <dylukes> I suggested I might take GHC generated STG, manually transform it slightly, and compile it myself
12:45:30 <acowley> oof, right
12:45:31 <dylukes> to compare.
12:45:32 <edwardk> that is a bigger task than you think
12:45:35 <dylukes> Yeah...
12:45:42 <edwardk> just get a decent intermediate language you understand
12:45:43 <dylukes> Note "suggested"
12:45:49 <dylukes> GHC stg is really scary ^^
12:45:52 <edwardk> yep
12:45:59 <dylukes> "suggested" does not mean "will do" :P
12:46:03 <shachaf> Constraint kinds are weird.
12:46:15 <edwardk> ezyang: still following?
12:46:56 <edwardk> anyways once we have (\\), almost everything we want to do becomes trivial.
12:47:16 <ezyang> ...at times like this I kind of wish we had full dependent types.
12:47:21 <edwardk> i don't
12:47:36 <edwardk> i'd be happy if some day the number of universe levels opened up
12:47:41 <edwardk> but thats about all i want
12:48:05 <ezyang> Still stuck on syntax. Please stand by...
12:48:11 <edwardk> no worries
12:48:53 <dgpratt> actually, I have a syntax question, too, about this: Sub :: (a => Dict b) -> a :- b
12:49:00 <edwardk> dgpratt: shoot
12:49:15 <dgpratt> what is "(a => Dict b)" actually doing here?
12:49:30 <edwardk> consider something simpler for a sec
12:49:32 <copumpkin> it's saying a implies b, as constraints
12:49:42 <dgpratt> edwardk: I should warn you that most of what you talk about is way over my head :)
12:50:00 <edwardk> (Ord a => [a] -> [a])
12:50:44 <dylukes> edwardk: (\\) where? at the type level .__.?
12:50:44 <dgpratt> edwardk: ok, I guess what's bugging me is that usually the 'a' on the left is mentioned on the right, too
12:50:50 <edwardk> most of the time those obligations get discharged, or moved out to prenex position, but it is still possible to _write_ a constraint there
12:51:23 <Cale> dylukes: (\\) from his blog post. It has nothing to do with the usual (\\)
12:51:32 <gwern> preflex: seen roconnor
12:51:33 <lambdabot> gwern: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:51:33 <preflex>  roconnor was last seen on #haskell 15 hours and 12 minutes ago, saying: ML's advanced module system is used to solve problems that are, generally, solved by type classes in Haskell.
12:51:33 <dylukes> Oh. gotcha.
12:51:39 <Cale> (Or, not that I could think of straight away)
12:52:33 <edwardk> dgpratt: what saves is is the process by which that constraint gets unified, it can only be discharged by something else bringing a constraint 'a' into scope
12:52:59 <frerich_> I have a little Haskell design question: in my project (a little game) I have the following way to model a 'turn' by a player: http://hpaste.org/53505 it works, but what's annoying is that considering a Turn to be a list of Actions means that there are many possible sequences of Actions which aren't actuall valid turns. For instance, you may not pick a chip and then play a chip. So I'm wondering how to model a Turn so that only v
12:52:59 <frerich_> sequences of actions are possible.
12:53:30 <frerich_> I was wondering whether I should maybe consider a turn to be a monadic value, internally maintaining a sequence of actions and 'executing' the turn yields a new 'Game'. Does that make sense?
12:53:36 <Cale> frerich_: You might be able to use the type system more
12:53:57 <Cale> At least, if the sequences of actions which are valid turns is reasonably easy to encode at that level
12:54:10 <Cale> But you'll also lose out on the convenience of lists :)
12:54:38 <edwardk> constraints are typechecked by mutual entailment.    when I go to unify forall a b c. (Foo a, Bar b, Baz c) => a -> b -> c   with forall x y z. (Quux x, Quaffle y z) => x -> y -> z i take all the variables that occur in unambiguous position, sort them structurally, then instantiate them with skolem variables
12:54:48 <frerich_> Cale: That would be perfect :-). Unfortunately, the valid sequences are more or less infinite. For instance, you may do 'move chip' zero or more times as long as you play at least one chip, too.
12:55:17 <Cale> frerich_: Can it be modelled by a finite state machine?
12:55:28 <frerich_> Cale: Yes
12:55:47 <edwardk> after that i unify the structure 0 -> 1 -> 2 with 0 -> 1 -> 2, incurring no new unification constraints, and then check to see if (Foo 0, Bar 1, Baz 2)  entails Quux 0         and then if it entails Quaffle 1 2
12:55:53 * dgpratt is horrified to observe the sunlight of edwardk's mind melting the wax holding his mental wings together
12:56:01 <edwardk> if so, then we have subsumption one way
12:56:17 <edwardk> then we check entailment using all of the context we have in the other direction
12:56:17 <Cale> frerich_: Then you can have a mutually recursive set of types (one for each state), or a gadt with a phantom parameter to say which state you're in...
12:56:33 <edwardk> if both sets of constraints mutually entail one another, then we move on
12:56:43 <frerich_> Cale: Hmmm, mutually recursive types, interesting idea!
12:57:00 <frerich_> Cale: I think I saw that idea somewhere already, but I cannot remember where. Do you maybe know something I could hoogle for?
12:57:13 <edwardk> its this entailment relationship that we captured with the kind variable, and basically it gets skolemized and can only be unified with itself
12:57:20 <Cale> umm, I haven't seen a whole lot about it myself
12:57:22 <edwardk> it being the 'a'
12:57:52 <edwardk> and if it wasn't obvious, i was using numbers above for the skolem variables
12:58:06 <Cale> I recall seeing a paper somewhere which used types to enforce the red-black property for a red-black tree, among other things.
12:58:14 <Cale> But I don't remember what it was called
12:58:22 <edwardk> cale: okasaki has something as well
12:58:36 <edwardk> and oleg has a 'stanamically checked' red black tree iirc
12:58:45 <edwardk> or maybe it was AVL
12:58:47 <frerich_> Cale: Maybe this is overkill, but I'm wondering whether it would be practical to use the type system to ensure that a function taking a 'Turn' doesn't have to worry about getting invalid turns, since it's simply impossible to create them.
12:58:55 <dylukes> edwardk: sta-what?
12:59:19 <edwardk> dylukes: thats oleg speak for "statically where possible but dynamically where necessary"
12:59:29 <edwardk> basically he has a typeclass that constant folds away most of the checks
12:59:42 <acowley> I don't think that particular linguistic invention was called for
12:59:45 <dylukes> uh oh
12:59:48 <dylukes> olegspeak is scary :<
12:59:52 <edwardk> acowley: hence the air quotes
13:00:24 <acowley> edwardk: the problem there is that I have to read about 20% of what you say in air quotes :)
13:00:26 <edwardk> ezyang: still hanging in there?
13:00:26 <Cale> frerich_: It may. If you're parsing turns from user input, say, you'll also have to structure your parser so that it couldn't possibly parse an invalid turn too, for example. It's generally not so hard to make it work, but it may or may not be worth the extra trouble.
13:00:32 <edwardk> acowley: hahaha
13:01:13 <frerich_> Cale: Yeah, that's true. Right now, I catch invalid user input (it's as you say, I'm parsing user input) when parsing - but the rest of the code has to assert that the given Turn is valid, which is a little ugly.
13:01:40 <frerich_> Cale: So I was wondering whether I could easily get rid of that. I was thinking of session types maybe.
13:01:49 <frerich_> Cale At least I seem to recall session types could be relevant.
13:02:36 <edwardk> anyways part 2 is the fun part. the Class and (:=>) classes wound up much more elegant in this final draft
13:02:53 <Cale> Maybe, I don't know so much about them
13:03:17 <edwardk> just something about reifying instance Eq a => Eq [a]   as  instance Eq a :=> Eq [a]  makes me happy
13:04:35 <Cale> frerich_: another trick that I've used, if you're going to write an AI to try to find the best play in a given situation, say, and you want to nondeterministically go through a bunch of possibilities and keep track of how they'd affect the game, you can use the StateT GameState [] monad, but wrap up the put operation such that any attempt to make a move which would be invalid will result in mzero.
13:04:38 <DanBurton> Is there an extension that allows defaulting for typeclassses other than Num?
13:04:50 <edwardk> DanBurton: ghc has an extension
13:04:54 <edwardk> DanBurton: but its limited
13:05:10 <edwardk> i think its
13:05:12 <edwardk> ExtendedDefaultRules
13:05:26 <frerich_> Cale: Ah, that sounds a lot like what I was thinking of Maybe (my idea was to use a monad so that invalid actions yield a 'null' value or the like)
13:05:29 <frerich_> Cale: Hmm
13:05:38 <DanBurton> edwardk: cool, I'll look into it
13:06:06 <luite_> I wish it had more configurable defaulting, would've saved me some low level hacking :)
13:06:10 <edwardk> the idea is that instead of just using defaulting for Num, etc. is it extends defaulting to variables that are only constrained by single parameter typeclasses as long as one of those constraints is Num, Show, Eq or Ord
13:06:48 <edwardk> this is enough that I've sometimes snuck "Show" in as an extra superclass of a class where I _really_ wanted defaulting ;)
13:07:34 <DanBurton> :)
13:08:02 <edwardk> i do kind of wish there was an extra class like Defaultable or something which was also in that list but had no members
13:08:12 <DanBurton> how hard would it be to allow for arbitrary defaulting declarations, such as exist for Num? e.g. default (Integer, Double)
13:08:17 <edwardk> http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
13:08:33 <edwardk> its awkward
13:09:05 <DanBurton>  /sigh it seems that most everything useful is awkward to implement
13:09:14 <edwardk> the defaulting rules infect that entailment process i mentioned up above, because once you'd don all your unification, then you have to check to see if any of the still-polymorphic but constrained variables are defaultable
13:09:40 <edwardk> and the you'd have to track what its allowed to be based on the set of default rules you put in scope or something
13:09:46 <edwardk> right now its just a fixed list
13:10:23 <dgpratt> ok, I'm gonna try asking this a different way because I really want to try to understand this...
13:10:56 <dgpratt> supposind the type of "Sub" was declared as "Sub :: Dict b -> a :- b", at what point does the whole scheme break down and why?
13:12:12 <c_wraith> dgpratt: it'd still work, but it would lose a lot of utility in automatic inference
13:13:19 <dgpratt> c_wraith: ok, that helps, thanks
13:13:31 <dgpratt> is the "(a => Dict b)" construction in any way similar to a FunDep?
13:14:03 <c_wraith> No.  FunDeps are about relations in type variables in a multi-parameter typeclass.
13:14:21 <c_wraith> That's just an assertion about two type classes
13:14:36 <Sgeo|web> So I should use ByteString for arbitrary binary data?
13:14:38 <hpaste> paolino pasted ‚ÄúGADTs question‚Äù at http://hpaste.org/53507
13:15:51 <c_wraith> Sgeo|web: yes, bytestring is generally the most appropriate type for arbitrary binary data
13:15:51 <paolino> hello, I was trying this example with GADTs but type inference says f :: C t -> (), is this right ?
13:16:13 <ET_> @pl f x = x *x
13:16:14 <lambdabot> f = join (*)
13:16:24 <edwardk> dgpratt: sorry bout that. got disconnected
13:16:37 <ET_> @run join(*) 2
13:16:37 <copumpkin> paolino: you must be on an old GHC. I think it'll refuse to even infer a type now
13:16:37 <lambdabot>   4
13:16:43 <acowley> I find it mildly disappointing that we need so many INLINE notations. I do understand that overly aggressive inlining can hinder performance, but perhaps GHC could be a tad more aggressive than it currently is.
13:16:57 <sheriff> I have a function that I've written badly - and I'm trying to teach myself Haskell. It is:
13:16:57 <paolino> copumpkin: 7.0.3
13:16:58 <copumpkin> paolino: however, it isn't strictly wrong, either
13:16:59 <^^thief^^> I have "class OrdColl a where‚Ä¶" & "instance OrdColl (List a) where..)" but the compiler keeps telling me List is not in scope - can anyone help?
13:17:00 <sheriff> allTokens x  = fst(nextToken x) : allTokens( snd( nextToken x ) )
13:17:11 <dgpratt> edwardk: np, probably good for me, I can only take this stuff in very small doses :)
13:17:12 <sheriff> I don't want to evaluate nextToken x twice
13:17:21 <sheriff> Can someone tell me the right way to do that?
13:17:40 <edwardk> dgpratt: heh you should have seen the mess that this code was before i simplified it =)
13:17:44 <ET_> @type join
13:17:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:17:56 <acowley> (:) <$> fst <*> (allTokens . snd) $ nextToken
13:18:00 <acowley> or something like that
13:18:08 <paolino> copumpkin: it's wrong because it doesn't detect type errors, or there are other uses for GADTs ?
13:18:13 <mdempsky> sheriff: You could use 'let' or 'where'.
13:18:21 <acowley> err, that last "$" should be a "."
13:18:27 <sheriff> mdempsky: Oooh, ys
13:18:32 <sheriff> I remember 'where'
13:18:34 <copumpkin> paolino: I'm saying the type it inferred isn't wrong
13:18:34 * sheriff does that
13:18:54 <copumpkin> paolino: but there's another more specific type that's more right, in some sense
13:19:06 <acowley> :t \nextToken allTokens -> (:) <$> fst <*> (allTokens . snd) . nextToken
13:19:06 <lambdabot> forall a b a1 b1. ((a, b) -> (a1, b1)) -> (b1 -> [a]) -> (a, b) -> [a]
13:19:29 <acowley> :t \nextToken allTokens -> ((:) <$> fst <*> (allTokens . snd)) . nextToken
13:19:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (b -> [a]) -> f [a]
13:19:47 <acowley> gah, I give up
13:20:02 <paolino> copumpkin: does 7.2.1 infer the right type ?
13:20:35 <paolino> the more right type
13:20:54 <ET_> @t join (*)
13:20:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:21:15 <ET_> @type join(*)
13:21:16 <lambdabot> forall a. (Num a) => a -> a
13:21:16 <applicative_> ^^thief^^ are you meaning the usual list type [2,3,4] or your own List type?
13:21:31 <copumpkin> paolino: it infers the same type, actually
13:21:33 <^^thief^^> applicative_: the usual List type
13:21:37 <copumpkin> paolino: that's correct, though
13:21:53 <^^thief^^> applicative_: I have import Data.List at the top of the file
13:22:06 <Sgeo|web> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/packages/xhtml-3000.2.0.1/doc/html/src/Text-XHtml-Extras.html#gui
13:22:15 <applicative_> then its "instance OrdColl [a] where ...",
13:22:27 <Sgeo|web> Why is the depreciated marker in the source, but no mention of the depreciatedness is to be found in the documentation?
13:22:36 <ET_> @unpl join(*)
13:22:36 <lambdabot> ((*) >>= \ a -> a)
13:23:05 <hpaste> ‚Äú^^thief^^‚Äù pasted ‚ÄúQ5 is where the problem is occurring‚Äù at http://hpaste.org/53508
13:23:11 <edwardk> I was on the way to work the other day when the idea of hacking up that 'applicative' combinator came to me. Originally it was a giant muddle of unsafeCoerces
13:23:12 <dylukes> :t join
13:23:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:23:18 <dylukes> :t join (*)
13:23:19 <lambdabot> forall a. (Num a) => a -> a
13:23:20 <dylukes> que.
13:23:30 <edwardk> > join (*) 5
13:23:31 <lambdabot>   25
13:23:41 <dylukes> @src join
13:23:41 <lambdabot> join x =  x >>= id
13:23:42 <copumpkin> dylukes: let m = (a ->)
13:23:48 <dylukes> oh, dur.
13:23:54 <^^thief^^> applicative_ : ah ok thanks that makes sense
13:25:10 <ET_> @pl  f y x = replicate  (y - (length show x ))' ' ++ show x
13:25:10 <lambdabot> f = (`ap` show) . ((++) .) . flip flip ' ' . (replicate .) . (. length show) . (-)
13:25:12 <edwardk> What other class system infelicities are there? Monoid :- Semigroup,  Monad :- Pointed,   Monad :- Applicative, others?
13:25:12 <DanBurton> :t join `asAppliedTo` (*)
13:25:13 <lambdabot> forall a. (Num a) => (a -> a -> a) -> a -> a
13:25:19 <dgpratt> copumpkin: what's that Monad called, again?
13:25:27 <copumpkin> dgpratt: reader, when wrapped in a newtype
13:25:30 <DanBurton> :t join `asAppliedTo` const
13:25:31 <lambdabot> forall a. (a -> a -> a) -> a -> a
13:25:31 <sheriff> mdempsky: Thanks, I went with: http://nopaste.snit.ch/92437
13:25:35 <edwardk> dgpratt: reader
13:25:40 <dgpratt> copumpkin: ah, thanks
13:25:56 <DanBurton> > let id' = join const in id' 3
13:25:57 <lambdabot>   3
13:26:13 <paolino> copumpkin: http://hpaste.org/edit/53507
13:26:30 <copumpkin> paolino?
13:26:35 <paolino> what about "g f"
13:27:16 <mdempsky> sheriff: You don't need the parentheses (other than the type signature).
13:27:26 <paolino> should it typecheck ?
13:27:41 <sheriff> mdempsky: They make me happy for now :-)
13:27:43 <mdempsky> sheriff: You could also do just "where (token, buffer) = nextToken x".
13:28:01 <sheriff> mdempsky: Ah, that's much better
13:28:18 <dgpratt> copumpkin: before (in answer to my question) you said "it's saying a implies b, as constraints"; does that mean that if we know what is the constraint represented by 'a' then we know the constraint represented by 'b'?
13:29:11 <edwardk> dgpratt: yes
13:29:21 <edwardk> Given Ord a       we know Eq a
13:29:27 <pumpkin> paolino: wrong url?
13:29:29 <edwardk> given     Eq a     we know Eq [a]
13:29:44 <hpaste> paolino annotated ‚ÄúGADTs question‚Äù with ‚ÄúGADTs question (annotation)‚Äù at http://hpaste.org/53507#a53509
13:29:45 <edwardk> the former comes from the class declaration
13:29:52 <edwardk> the latter comes from an instance declaration
13:30:18 <pumpkin> paolino: yeah, what's wrong with that?
13:30:45 <paolino> "g f" should not type check I thought
13:30:51 <dgpratt> edwardk: ok, thanks, I shall ponder this further
13:30:51 <pumpkin> why?
13:30:52 <edwardk> class Class a b where cls :: b :- a       class a :=> b where ins :: a :- b  lets me reify those
13:30:59 <pumpkin> if you want a more specific type signature, give it a more specific signature
13:31:29 <applicative_> ^^thief^^: there are a few other syntactic peculiarities in the 'instance OrdColl [a]...' bit.  You are writing [xs] when you mean xs for example and [x:xs] meaning (x:xs) etcc.
13:31:54 <^^thief^^> applicative_: yep! dealing with those now :)
13:31:55 <pumpkin> paolino: if I define f x y = x + y * 3; g :: (Int -> Int -> Int) -> Int, should I be able to call g f ?
13:32:05 <^^thief^^> or trying to!
13:32:39 <paolino> pumpkin: I think so
13:32:44 <edwardk> we can write data a :- b = Sub (a => Dict b)   instead of the GADTish definition as well
13:33:01 <copumpkin> paolino: it's the same situation. It's inferring a more general type than you want it to, so if you want it to have a more specific type, then give it one
13:33:35 <copumpkin> paolino: GHC always tries to infer the most general type, and doesn't take into account incomplete GADT pattern matching when determining a type
13:34:28 <applicative_> ^^thief^^: also, notice that in the instance definition, you are using a test with '<' , '>' and the like.  But these are not defined for lots of types, so you will need to add a constraint
13:34:55 <paolino> incomplete GADT pattern matching ? can f go with C A and C B ?
13:35:33 <edwardk> i do wish type aliases were expanded in instance and class statements though
13:35:34 <copumpkin> paolino: yes, and it'll just crash if you call it with the wrong one
13:36:04 <edwardk> not sure quite how i'd use it yet
13:36:06 <edwardk> but it'd be awesome
13:36:27 <^^thief^^> applicative_: ah ok so something like (Eq a). cheers for the heads up
13:37:19 <byorgey> edwardk: do you know if ConstraintKinds supports type families which produce constraints?
13:37:31 <copumpkin> byorgey: that's what restricted monads use
13:37:34 <edwardk> my understanding was yes
13:37:40 <edwardk> because of the restricted monad example
13:37:51 <copumpkin> also, one of the All implementations uses that
13:37:56 <byorgey> ah, right
13:38:03 <byorgey> ok, thanks
13:38:04 <edwardk> byorgey: did you see the polished version?
13:38:06 <Sgeo|web> I'm not thinking about this in too much detail, but
13:38:07 <copumpkin> All takes a constraint and a type and produces a constraint
13:38:20 <byorgey> edwardk: in your blog posts you mean?
13:38:24 <edwardk> yeah
13:38:29 <Sgeo|web> Suppose I have a foreign library that's not thread-safe, and thus I want anything actually interacting with it to be in the same thread
13:38:40 <byorgey> haven't had a chance to read those yet
13:38:53 <copumpkin> Sgeo|web: kmc has the solution!
13:38:57 <Sgeo|web> I should be able to make a function that, using Chans, just sends IO stuff over to the main thread, right?
13:38:58 <Sgeo|web> And fork using a function I define, right?
13:38:59 <edwardk> check the applicative combinator at the bottom of the second post, even if you skip the implementation ;)
13:39:19 <Sgeo|web> I'm not even sure how I would go about setting something like that up in a regular imperative language
13:39:26 <Sgeo|web> Am I on the right track though?
13:39:29 <copumpkin> Sgeo|web: why not just have a lock around foreign calls?
13:39:40 <edwardk> its a lot prettier than the version i showed you the other day
13:39:50 <byorgey> edwardk: cool, will do
13:40:21 <Sgeo|web> Um
13:40:42 <Sgeo|web> Because often to do one "action" with this library actually involves several calls to it
13:40:54 <Sgeo|web> I guess I could make a lock around wrapping that issue into one call
13:41:45 <Sgeo|web> There may be other issues involved with wrapping it
13:42:01 <Sgeo|web> Just realized that my Chan idea would make the entire threading thing meaningless, I think, meh
13:42:19 <Sgeo|web> Or not, I'm sure something with ... something could be set up
13:42:26 <copumpkin> Sgeo|web: then you'd need to communicate two ways
13:42:30 <copumpkin> and you'd have to wait for a response
13:42:42 <copumpkin> and that'd effectively be blocking on the one thread that had access to the FFI lib
13:42:52 <copumpkin> so you might as well put a lock on it
13:43:02 <copumpkin> just as beyonc√© said
13:43:26 <copumpkin> especially since your chans for talking to this global middleman would have to be global anyway
13:43:51 <paolino> copumpkin: so pattern matching in 'f' on A and B values is really pattern matching on their types with GADTs ?
13:44:15 <dmwit> All the single threadies, all the single threadies. If you liked sequential semantics, you shoulda put a lock on it.
13:44:17 <edwardk> removed some of the excessively verbose explicit kinds from the posts
13:44:42 <copumpkin> paolino: what you're looking for is for the type to be inferred to C A -> () if you match only on the A, C B -> () if you match only on the B, and C a -> () if you match on both?
13:44:56 <copumpkin> sort of "least upper bound" reasoning
13:45:08 <Sgeo|web> This particular library even with single threading is a pain to get right
13:45:35 <copumpkin> Sgeo|web: oh, the FFI can only be called from a single specific OS thread?
13:45:39 <copumpkin> Sgeo|web: I'd misunderstood
13:45:46 <copumpkin> I thought you meant it can't be called concurrently
13:45:50 <Sgeo|web> copumpkin: I'm... not sure
13:46:17 <Sgeo|web> I mean, concurrently trying to use this thing would probably be a bad idea
13:46:42 <Sgeo|web> But it's easy to get even sequentially using it wrong
13:46:54 <copumpkin> anyway, if it's the other situation, where the FFI lib wants to only get called from a single OS thread, that's more annoying
13:47:09 <copumpkin> then you probably will have to do that Chan stuff
13:47:22 <Sgeo|web> I don't think it's that other situation
13:47:26 <copumpkin> in fact, it seems like a pattern that could be abstracted out into a library (/cc kmc)
13:48:04 <Sgeo|web> But... there's a function, aw_wait(), that gets called and event handlers run "during" it. But calling other functions, if called in synchroneous mode, also call aw_wait()
13:48:11 <Sgeo|web> So things can get bizarre quickly
13:48:20 <copumpkin> is that "aw! wait!"
13:48:53 <Sgeo|web> So event handlers can end up getting run during the execution of an event handler
13:49:30 <edwardk> copumpkin: basically just forkOS and then talk that that dispatching thread through something
13:49:40 <copumpkin> edwardk: yeah, bidirectionally
13:49:50 <copumpkin> kind of annoying and useful for many projects
13:50:16 <copumpkin> seems like a simple library would help remove some of the pain to binding certain dumb C libraries
13:50:19 <Sgeo|web> I guess one way to deal with that would be to disable synchroneous calls
13:50:54 <Sgeo|web> For making callbacks usable in a synchroneous manner, which is preferable, locking, or Cont?
13:51:10 <paolino> copumpkin: when you say crash you mean compile time crash, is it ?
13:51:17 <copumpkin> no, runtime crash
13:52:27 <paolino> like all pattern matching failures
13:52:48 <Philonous> edwardk:  Do I understand correctly that you "evil" combinator allows one to define scoped instanced by defining the instance on a newtype wrapper and "delifting" it?
13:53:03 <copumpkin> paolino: yep
13:53:34 <copumpkin> Philonous: nobody knows what will happen there. See if you can fuck up a Data.Map
13:53:37 <paolino> copumpkin: but it will not compile if f is "C A -> ()"
13:53:48 <copumpkin> paolino: huh?
13:54:07 <copumpkin> f :: C A -> ()
13:54:08 <copumpkin> f A = ()
13:54:10 <copumpkin> that works
13:54:29 <copumpkin> C a -> () also works, and is more general
13:54:33 <copumpkin> C B -> () does not work
13:54:40 <paolino> yes but an expression g f will not typecheck in that case
13:54:50 <copumpkin> oh, sure
13:55:01 <copumpkin> I'm not really sure what you're getting at here
13:55:13 <Sgeo|web> I know I've suggested this before, and got a response before, I don't remember what it was. That other people agree?
13:55:45 <Sgeo|web> There should be an OrdMap that things like complex numbers can be a part of, defining a thing that Maps can use but doesn't represent meaningful comparison
13:55:47 <Sgeo|web> Just consistent
13:56:05 <Philonous> copumpkin:  What do you mean by "duck up a Data.Map"?
13:56:42 <copumpkin> Philonous: if you have a nice, tasty Data.Map that was constructed using one Ord instance
13:56:56 <Philonous> copumpkin:  Oh, I see
13:56:58 <copumpkin> Philonous: and then you use a different Ord instance to insert something into it
13:57:02 <copumpkin> you'll mess up its internal invariants
13:57:06 <copumpkin> they have a function to check the invariants on it
14:00:03 <scooty-puff1> i was trying to define a monad ErrorIO that just wraps IO and defineds Exception e =>MonadError e ErrorIO
14:00:32 <scooty-puff1> so i have two uses of it: parse :: MonadError ParseException m => A -> m B
14:00:43 <scooty-puff1> and name :: MonadError NameException m => B -> m C
14:00:49 <scooty-puff1> i get this error:
14:00:50 <Philonous> Also, you could evaluate part of a thunk with one dictionary and the rest with another, couldn't you?
14:01:28 <scooty-puff1> http://pastebin.com/ACdKtYXa
14:01:31 <mauke> The paste ACdKtYXa has been copied to http://hpaste.org/53510
14:02:04 <paolino> copumpkin: I'm still a bit confused by gadts , so I'm probably getting nowhere , thanks for patience
14:02:19 <Sgeo|web> Did anyone answer my ealier question?
14:02:31 <Sgeo|web> What's the best way to deal with callbacks, locking or ContT?
14:07:02 <scooty-puff1> nevermind on my question, i see its the functional dependencies doing it
14:07:50 <scooty-puff1> O!
14:07:56 <scooty-puff1> i got out of it by adding a type var to ErrorIO
14:08:14 <scooty-puff1> instance Exception e => MonadError e (ErrorIO s) where ...
14:08:24 <scooty-puff1> newtype ErrorIO s a
14:12:42 <Sgeo|web> Hmm
14:13:04 <Sgeo|web> I'm wondering if my thing representing a list of objects that a thread is retrieving would be best represented with a Chan
14:13:06 <Sgeo|web> of those objects
14:13:35 <Sgeo|web> Or are there better streaming interfaces?
14:13:42 * hackagebot Moe 0.1 - A FRP library based on signal functions.  http://hackage.haskell.org/package/Moe-0.1 (XinyuJiang)
14:17:31 <Sgeo|web> Actually, hmm, Chan would be a bad idea because I have a finite number of objects
14:17:41 <Cale> Hm?
14:17:58 <shachaf> Cale: Oh, are you going to Hac Boston?
14:18:30 <Sgeo|web> Cale: I'm musing to myself about wrapping a library, even though I'll probably never actually get around to writing any code
14:18:46 <Cale> One option I've found particularly nice is to take a Chan or MVar or something and split it into readChan c :: IO t and writeChan c :: t -> IO (), or  readMVar v :: IO t and writeMVar v :: t -> IO ()
14:19:33 <copumpkin> Cale: yeah, come to hac boston!
14:19:34 <Cale> and then the read and write ends can be passed to different places in the code to control which code has permission to read and write
14:19:44 <Cale> um... hmm
14:19:51 <edwardk> Philonous: yep
14:19:54 <Cale> hau travel?
14:20:03 <edwardk> Philonous: evil is really evil
14:20:05 <Cale> I think I'd need to get a passport
14:20:05 <copumpkin> Cale: by vehicle of some sort
14:20:08 <Cale> or something
14:20:12 <copumpkin> Cale: can't hurt anyway
14:20:15 <shachaf> @where Cale
14:20:15 <lambdabot> I know nothing about cale.
14:20:17 <Sgeo|web> .....that vaguely reminds me of object-based capabilities
14:20:27 <Cale> I'm in Brantford Ontario
14:20:45 <shachaf> Oh, that's practically close.
14:21:03 <copumpkin> Cale: just hop on a bicycle and ride over
14:21:08 <acowley> I suggest a team of sled dogs
14:21:17 <acowley> Ontario -> Boston in January?
14:21:20 <Sgeo|web> Oh, for. Haskell, a non-OO language, designed without object-based capabilities in mind, would probably be a decent language for object-based capability stuff
14:21:22 <Sgeo|web> I think
14:21:25 * Sgeo|web isn't sure
14:23:20 <Sgeo|web> Cale: is there anything like a Chan except I can signal that the Chan is closed?
14:23:51 <Cale> copumpkin: It's only 871km
14:23:57 <Sgeo|web> And that the equiv of getChanContents for such a thing could in fact be finite
14:24:01 <copumpkin> Cale: 2 days 4 hours by bike
14:24:10 <copumpkin> Cale: peanuts!
14:24:13 <shachaf> You could take the bus.
14:24:24 * shachaf went to Boston by bus once; should be practically the same thing.
14:24:33 <Cale> I have never actually used a bike
14:24:55 <shachaf> Cale: Have you ever left .ca?
14:24:58 <Cale> No
14:25:12 <edwardk> clearly you just need to start with a unicycle
14:25:32 <edwardk> And you need to come to hac boston to fix that ;)
14:25:33 <Cale> I've been to Montreal a couple times, and to Kelowna (B.C.) once
14:25:47 <shachaf> Oh, Kelowna.
14:26:01 <copumpkin> come on guys
14:26:07 <copumpkin> if we coordinate our peer pressure we can get him to come
14:26:09 <edwardk> think of it as a business trip. meet RyanT5000 or something whileyou are here
14:26:21 <Cale> So I've been outside Ontario three times.
14:26:37 <acowley> Cale: copumpkin will make you focaccia
14:26:42 <edwardk> so we need to get you a bike, a car and a passport ;)
14:26:43 <roconnor> gwern: hey
14:26:52 <gwern> ho
14:26:59 <shachaf> Cale: You need to see the world! In particular, Boston.
14:27:02 <shachaf> (Also California.)
14:27:07 <gwern> boston isn't that great
14:27:14 <edwardk> Ask shachaf, boston is the place to be
14:27:15 * gwern loved harvard's cafeteria though
14:27:22 <copumpkin> gwern: do you think anything is that great?
14:27:22 <acowley> Yes, the world is pretty much just Ontario, Boston, and California.
14:27:24 <edwardk> boo gwern, you aren't helping
14:27:28 <gwern> copumpkin: I liked SF a lot
14:27:34 <gwern> copumpkin: bruges was also really nice
14:27:34 <Cale> I could walk to Boston. It would only take me a week and 4 hours, apparently.
14:27:35 <shachaf> edwardk: Actually, California is the place to be these days.
14:27:42 <copumpkin> I like both of those too
14:27:50 <edwardk> i do like san francisco
14:27:51 <gwern> copumpkin: paris would've been nice except for the people
14:28:03 * roconnor prefers vienna
14:28:08 <edwardk> gwern: having lived there for a few months, my experience mirrors yours ;)
14:28:12 <copumpkin> roconnor the wiener
14:28:20 <roconnor> yes
14:28:26 <mee> having just moved from palo alto to cambridge, cambridge is pretty damn nice.
14:28:43 <copumpkin> mee: come to hac boston!
14:28:44 <monochrom> that's how the founding fathers of the US did it. marched for one week to Boston.
14:28:45 <edwardk> cale: sounds good. just make sure to leave before january 13th
14:28:53 <^^thief^^> applicative_: have a sec?
14:29:00 <edwardk> you would definitely one-up ddarius's four state hike
14:29:07 <mee> copumpkin: I hope to, but I might be recovering from shoulder surgery then.
14:29:17 <pandacat> Hey guys! newbie here and considering learning to program. Would haskell be a fine choice for an introduction to programming?
14:29:28 <Cale> pandacat: I think so
14:29:29 <copumpkin> mee: ah, okay, anyway you can probably just show up briefly if you want to meet people :) it'll be in cambridge
14:29:37 <acowley> ddarius is walking through four states to get to Hac Boston?
14:29:43 <Spockz> yes!
14:29:44 <edwardk> pandacat: it isn't a bad choice. it teaches you a lot of good habits
14:29:53 <Spockz> got wxHaskell working on OS X Lion
14:30:11 <shachaf> mee: You mvoed from Palo Alto to Cambridge? :-(
14:30:13 <edwardk> acowley: nah, but he went on an epic walkabout before he enlisted
14:30:14 <roconnor> pandacat: Haskell's error messages are often obtuse :(
14:30:18 <shachaf> mee: Did you ever go to bahaskell while you lived here?
14:30:23 <Cale> pandacat: A lot of resources that you'll find will tend to assume you already know how to program, because not so many people find out about Haskell's existence before learning to program in something else already, but it does make a good first language from what I've seen of those who have learned it first.
14:30:32 <mee> shachaf: nope.. I could never get out of work in time
14:30:37 <edwardk> mee: if nothing else, you should come to boston haskell
14:30:43 <shachaf> mee: Unfortunate.
14:30:50 <Sgeo|web> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028574.html
14:30:51 <mee> edwardk: already did :)  I saw Keegan's talk, but missed the last one
14:30:57 <edwardk> ah
14:31:04 <Sgeo|web> Is this a preferred way to write library functions that take callbacks?
14:31:07 <mee> definitely hoping to make it to more in the future
14:31:07 <edwardk> next one is on the 15th =)
14:31:11 <acowley> pandacat: I think it's a good choice (you are in #haskell, after all), but you should also learn C at some point
14:31:36 <pandacat> I was considering to lean python at depth, then haskell.
14:31:43 <copumpkin> pandacat: don't pollute your mind
14:31:49 <copumpkin> do haskell then python
14:31:51 <blackdog> pandacat: before we start recommending languages, what do you actually want to do?
14:31:55 <copumpkin> python will seem easy by comparison
14:32:09 <acowley> Starting with Haskell is a great option these days
14:32:16 <Sgeo|web> There's more depth to Haskell then Python, I think
14:32:20 <copumpkin> blackdog: no such thing as "the right tool for the job". haskell = http://www.thinkgeek.com/gadgets/tools/8b97/?cpg=wnrss
14:32:25 <blackdog> if you're looking long term, haskell is a good choice. if you want a simple web app online tomorrow, something like ruby on rails or python/django is probably a better choice
14:32:46 <blackdog> copumpkin: i think that's true for a professional programmer.
14:32:51 <pandacat> blackdog, web programming
14:33:01 <pandacat> server side
14:33:09 <blackdog> but the reason rails is popular is because it lets you whack up a site very quickly without knowing much
14:33:29 <blackdog> you pay for it later, but if you have a success, you can afford to pay a more experienced programmer to build it properly
14:33:36 <blackdog> if it's a failure, you let it die
14:34:52 <edwardk> based on copumpkin's link i think he is trying to say 'overengineered' but i'm not sure
14:35:23 <copumpkin> no no, haskell is the right tool for every job
14:35:35 <acowley> I think he's just pointing out that Haskell comes with a tool for removing pebbles from horse hooves
14:35:48 <gwern> oh, I needed that the other day
14:35:52 <acowley> which truly is an underpublicized aspect of the language and ecosystem
14:35:59 <gwern> my demonic horse kept tripping on pebbles during the night
14:36:16 <edwardk> acowley: well, that is a truly indispensable tool when you actually need it ;)
14:36:34 <copumpkin> gwern: I hate it when that happens
14:36:48 <acowley> Intriguingly, experienced haskellers tend to leave the horse alone, but work on a lens which presents a view of pebble-free hooves
14:36:50 <Sgeo|web> copumpkin: Is Haskell the right tool for a codenomic?
14:36:50 <gwern> one cannot frighten the kinderkind on foot
14:36:58 <copumpkin> Sgeo|web: of course
14:37:15 <roconnor> I just wish I could get GHC to compile me a fast SHA implemenation without making the code look worse than C
14:37:48 <blackdog> roconnor: what tricks do you have to pull?
14:38:08 <Sgeo|web> Is Haskell the right tool for ... someone who needs every nanosecond of speed the computer can muster and is willing to have a lot of other people review the code?
14:38:09 <roconnor> I don't know.  My SHA implmenation is dog slow, and that is after speeding it up 100 times
14:38:39 <roconnor> actually now that I think about it, my C code is slow when I'm writing it.
14:38:54 <gwern> roconnor: obviously you should license cryptol from galois and write your sha in that
14:38:56 <blackdog> what's it slow in relation to, then
14:38:57 <blackdog> ?
14:39:11 <gwern> I mean, if sha is worth writing, it's worth spending thousands of dollars on a license for a tool to write it
14:39:32 <Sgeo|web> cryptol?
14:39:37 <roconnor> blackdog: the implemenation found in openssl
14:39:40 <Cale> Sgeo|web: If you're writing something like that, it sounds like you can afford to write a special purpose compiler for the job, and Haskell is a pretty good at compilers
14:39:41 <stepkut> how do I load files that contain things like, #if MIN_VERSION_mtl(2,0,0), into ghci ?
14:40:30 <Cale> stepkut: Does the file have {-# LANGUAGE CPP #-} at the top?
14:40:43 <stepkut> Cale: yup.. twice..
14:40:46 <thoughtpolice> stepkut: you need to have GHC look in the necessary #include paths (don't know where they would be, probably somewhere under ~/.cabal if that's how mtl was installed) and you also need the LANGUAGE CPP pragma
14:40:48 <Cale> hmm
14:41:07 <thoughtpolice> that's about all i can think of off hand. by default GHCi doesn't have any sort of special include paths set up
14:41:09 <stepkut> also did, :set -idist/build/autogen/cabal_macros.h, after running cabal configure..
14:41:43 <shachaf> stepkut: I think -i is just for a directory to search for include files in, not to include a file.
14:41:44 <thoughtpolice> stepkut: if the file does #include "cabal_macros.h", then do -idist/build/autogen - you need to give it the directory for header files, not the file itself
14:42:17 <stepkut> thoughtpolice: the  files doesn't do an #include "cabal_macros.h" unfortunately.. some how that magically happens when cabal runs, but not just ghci
14:42:34 <thoughtpolice> oh, that's rather odd. :|
14:43:27 <stepkut> rather annoying
14:44:07 <seanhess> I'm really new to Haskell, and I'm kind of going crazy with the type system. http://stackoverflow.com/questions/8002304/haskell-ambiguous-type-variable-im-lost -- Any ideas?
14:45:27 <dcoutts> stepkut: you can use -optP-include -optPdist/build/autogen/cabal_macros.h
14:45:45 * dcoutts notes that this is what the upcomming "cabal repl" does
14:45:56 <stepkut> dcoutts: ah. nice. I think I figured that out once
14:46:17 <Sgeo|web> do statements can't end with a <-
14:46:24 <Sgeo|web> I don't know if that's your issue though
14:46:28 <blackdog> seanhess: what the error means is that the compiler can't work out the type - it's underdetermined
14:46:39 <Sgeo|web> Oh, you have the return ()
14:46:42 <seanhess> blackdog: yeah, I know that, but I can't see why
14:46:45 <blackdog> basically, if you use the output in some way, then the compiler can usually work it out
14:46:45 <copumpkin> dcoutts: cabal repl!!!
14:46:46 <copumpkin> yay
14:46:57 <blackdog> if you don't use the output, then it could be anything
14:47:01 <thoughtpolice> seanhess: that's normal. MonadIO is a type for which there can be many instances, IO is one of those. GHC is unable to determine the needed instantiation if it's not used. it's just 'floating in space' kind of
14:47:04 <stepkut> dcoutts: thanks! Added that to my .ghci and all is well again :)
14:47:09 <blackdog> and even though at this point you don't care because it's not a whole program, the compiler does:)
14:47:16 <seanhess> So I'm supposed to leave it ambiguous?
14:47:41 <blackdog> yeah. just use the output somehow
14:47:45 <thoughtpolice> you can have the regular type you have now - the one with the MonadIO constraint. when you use this function, GHC will figure out the appropriate instances. you just have to use it
14:47:50 <shachaf> seanhess: If you don't care about MonadIO, you could just replace all instances of "m" with "IO".
14:47:52 <mkscrg> is it possible to write an arbitrary version of curry that works for any tuple length, using type families?
14:47:56 <seanhess> Here's the real problem: I want to pass that little "db" function around so I can make functions that query the database. I'm not sure how to do that
14:48:16 <seanhess> I thought I'd pass the db function around, but maybe that's a bad idea
14:48:20 <Sgeo|web> seanhess: You could return it
14:48:32 <Sgeo|web> Except it will still be trapped in the monad
14:48:52 <Sgeo|web> Or wait
14:48:54 <deggis> i think i just implemented the fizzbuzz of my life http://hpaste.org/53511 but i'm worried that the line 10 is a common tool i just couldn't find. ideas?
14:48:59 <Sgeo|web> Pass it around to what?
14:49:01 <Cale> seanhess: just do some IO
14:49:12 <Sgeo|web> Within main, or make a function that other functions can call?
14:49:21 <Cale> seanhess: er...
14:49:22 <shachaf> "trapped in the monad" :-(
14:49:41 <Sgeo|web> shachaf: sorry, I'm not a Haskell expert, my way of describing things may be bad
14:49:51 <seanhess> Like this: findStuff db = db $ find (select [] "mycollection") >>= rest
14:50:01 <seanhess> How can I make functions that represent my queries?
14:50:02 <blackdog> deggis: guard p; return v
14:50:16 <Cale> Yeah, if you just use the action that you get back from mdb you'll be fine
14:50:17 <seanhess> without passing around some concept of the database connection?
14:50:40 <Cale> Or else just replace the occurrences of m in mdb's type with IO, and remove the (MonadIO m) => bit
14:50:47 <deggis> blackdog: oh, i'll try that
14:50:50 <blackdog> deggis: blah, i mean guard p >> return v
14:50:53 <blackdog> sorry, not enough coffee
14:50:55 <thoughtpolice> shachaf: you're trapped in the monad! it's like the matrix from what I understand
14:51:09 <seanhess> Cale: yes, replacing MonadIO with IO does work, which then makes the definition make a lot more sense
14:51:25 <rotflcopter> hi
14:51:26 <rotflcopter> :)
14:51:31 <seanhess> Some of the simpler things you guys are mentioning don't make sense to me (too noobish). "Just do some IO" what does that mean?
14:51:40 <seanhess> I mean, I understand "do"
14:51:46 <seanhess> but I thought I was already doing IO :)
14:52:12 <seanhess> Sgeo|web: What do you mean by "You could return it"
14:52:12 <Cale> seanhess: oh, sorry, I was actually a bit off with that one. Should have said "Just use the action you get back as an IO action"
14:52:28 <thoughtpolice> seanhess: you are doing IO. i think what what Cale meant was 'just use the result of your function and use it to do IO'
14:52:29 <seanhess> Cale: excuse my slowness here, The action I get back from what?
14:52:31 <thoughtpolice> ah, yeah
14:52:37 <Philonous> seanhess:  Fix the type of main. Either add a type declaration  (main :: IO ()) or do something that has type "IO a" rather than "MonadIO m => m a"
14:52:37 <Cale> seanhess: because I didn't look carefully enough at first at how your ambiguity was happening
14:52:47 <edwardk> oh, nice. the (:-) data type i'm using for entailment can be made a newtype instead
14:52:52 <Cale> seanhess: from the mdb action
14:53:27 <Cale> mdb takes two strings, and produces an IO action which when run, constructs a function taking an Action m a, and producing an m (Either Failure a)
14:53:34 <seanhess> ok, changing MonadIO => to just plain IO and adding main :: IO () gets rid of the error
14:53:37 <Cale> the problem is that which m to use is ambiguous
14:53:45 <seanhess> oh, ok
14:53:50 <seanhess> so the MonadIO thing is the complication
14:53:54 <Cale> But if you ever used that m (Either Failure a) in an IO context, it wouldn't be ambiguous
14:54:06 <Cale> because the type system would figure out you wanted m = IO
14:54:13 <seanhess> ahhh
14:54:51 <Cale> So, just finish writing the program you want to write, and it'll probably stop being ambiguous somewhere along the way :)
14:55:08 <seanhess> well, I was getting errors trying to pass it around to my little query functions
14:56:01 <seanhess> I don't understand how this example works: https://github.com/TonyGen/mongoDB-haskell/blob/master/doc/Example.hs
14:56:05 <seanhess> it seems cleaner that passing "db" around
14:56:38 <seanhess> but it seems like it magically knows which db to use
14:57:12 <deggis> blackdog: awesome, thank you :)
14:57:20 <Sgeo|web> Huh, I think my callbacks should have been prepared to take arbitrary MonadIOs anyway, even without thinking about ContT
14:57:22 <Philonous> seanhess:  It opens a connection, binds it to "pipe" and passes that arround as a parameter
14:57:44 <Cale> ah, that's because it's using the Action monad
14:57:50 <seanhess> Philonous: none of the functions seem to take a pipe
14:58:05 <Philonous> seanhess:  Oh, yes, wait
14:58:27 <seanhess> Should I just go finish reading Real World Haskell before I start trying to make my code look pretty?
14:58:50 <blackdog> deggis: but of course, you haven't really written the definitive fizzbuzz implementation until you include arrows, type families, iteratees and template haskell ;)
14:58:53 <Cale> which is like the IO monad, except that it threads the database Context along
14:58:54 <Sgeo|web> Is there any harm in using ContT if I don't need it?
14:59:16 <Philonous> seanhess:  The trick is the "Action" part, it carries arround the connection implicitly
14:59:19 <shachaf> Sgeo|web: Yes -- you don't need it.
14:59:30 <seanhess> Cale: that's cool. I guess that explains it.
14:59:32 <deggis> blackdog: true, but i'm getting there some day :)
14:59:45 <Philonous> seanhess:  If you want to understand what's going on I recommend reading about ReaderT, which is the same concept
15:00:03 <deggis> blackdog: today i'm more than happy with this http://hpaste.org/53513
15:00:03 <blackdog> deggis: i kinda love the idea of trotting something like that out in an interview
15:00:09 <seanhess> Philonous: Great! Thanks. I'll just get something working on this, and do some reading so I can understand what's going on
15:00:16 <blackdog> ooh, ooh - do it in the type system with peano numerals!
15:00:27 <seanhess> Thanks guys. This is definitely harder than learning other languages, so I appreciate the support
15:01:03 <Cale> > let fizzbuzz n = fromMaybe (show n) (("fizz" <$ guard (n `mod` 3 == 0)) `mappend` ("buzz" <$ guard (n `mod` 5 == 0))) in map fizzbuzz [10..20]
15:01:04 <lambdabot>   ["buzz","11","fizz","13","14","fizzbuzz","16","17","fizz","19","buzz"]
15:01:49 <Sgeo|web> :t (<$)
15:01:50 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:02:09 <Sgeo|web> Uhh?
15:02:25 <Sgeo|web> oh, it ignores the second argument but not the second argument's context?
15:02:45 <Cale> > "fizz" <$ [1,2,3]
15:02:45 <lambdabot>   ["fizz","fizz","fizz"]
15:03:16 <Philonous> seanhess: Without delving into the details, ReaderT adds a new primitive action "ask" that let's you grab local (sonstant) state, alleviating the need to constantly pass around the same parameter
15:03:27 <Philonous> constant*
15:03:41 <seanhess> that's really cool. I can't wait to understand it :)
15:04:15 <Sgeo|web> (TMI) but reader IS an extra parameter. Directed by M. Night Shyamalan
15:04:21 <Sgeo|web> (I may be inaccurate)
15:04:46 <Cale> v <$ x = fmap (const v) x
15:04:50 <seanhess> If you guys have a little more patience, I have another question --- I made Data.Bson an instance of Data.Aeson.Types.ToJSON.   It makes a lot of sense for the instance declaration to exist, since Bson and Json are so similar, but which library does it belong in? Data.Aeson, Data.MongoDB, or a 3rd library all together?
15:05:25 <deggis> Cale: oh, the Just keywords became redundant when knowing <$, brilliant
15:05:25 <seanhess> (Bson = Binary Json = mongodb's native format)
15:05:56 <Cale> seanhess: Well, do either of those packages depend on the other already? If not, then probably you'd want to go with the third package option.
15:06:41 <seanhess> Cale: They don't and it makes sense for them not to. While it does make sense for Bson to go to Json, there could exist any number of good Json frameworks.
15:06:49 <seanhess> Thanks
15:08:04 <Cale> seanhess: Yeah, if there was a separate Bson library, you could have it bless one of the JSON libraries by writing an instance, but instances have this awkward property that if you import a module, you *have* to accept all the instances from it, and you will also export all the instances you imported.
15:10:26 <hnsz> http://codepad.org/82XD8YMO
15:10:49 <hnsz> I have a problem with the type of the function that is an argument to foldr
15:11:02 <Cale> hnsz: yeah, the f that you wrote has b = [[a]]
15:11:30 <hnsz> What is wrong with it?
15:11:46 <hnsz> You can't have a type variable include another type variable?
15:11:50 <Cale> hnsz: When you write a type signature for a function, you can't provide a type which is more polymorphic than the function you actually wrote
15:12:05 <Cale> hnsz: Your type signature says that f will work for *any* types a and b
15:12:15 <hnsz> Ah
15:12:42 <Cale> You could provide a type signature which is less polymorphic though, if you wanted
15:12:55 <hnsz> So a -> b -> b in foldr gets restrained
15:12:56 <Cale> Like, you could write  f :: Char -> [String] -> [String]
15:13:20 <Cale> (String = [Char])
15:13:43 * hackagebot cqrs 0.3.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.3.0 (BardurArantsson)
15:13:52 <hnsz> Cale: Yes a -> [[a]] -> [[a]] works fine :)
15:14:07 <Cale> yeah, in pretty much any real use of foldr, you'll be constraining the types to something more specific
15:14:13 <Cale> especially b
15:14:25 <hnsz> Thanks. That is kind of obvious now that I think about it :)
15:15:13 <dgpratt> I'm still thinking about edwardk's blog post about constraint kinds...
15:15:51 <acowley> Erk, brain freeze: how can I write "f >=> maybe (return Nothing) g" more nicely?
15:15:55 <dgpratt> at the moment, trying to see how "(a => Dict b)" amounts to 'a' implies 'b'
15:16:10 <dgpratt> context: http://comonad.com/reader/2011/what-constraints-entail-part-1/
15:16:39 <acowley> ?pl \f g -> f >=> maybe (return Nothing) g
15:16:39 <lambdabot> (. maybe (return Nothing)) . (>=>)
15:16:40 <dgpratt> => is still our friendly type constraint construction, right?
15:16:45 <acowley> feh
15:16:49 <acowley> this code is hideous
15:17:21 <dmwit> :t maybe (return Nothing)
15:17:22 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
15:18:00 <blackdog> hey, anyone know what happened to the detailed-1.0 test suite type?
15:18:08 <blackdog> is exitcode-stdio still the only one supported?
15:18:23 <dmwit> :t \f g -> f >=> maybe (return Nothing) g
15:18:23 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m) => (a -> m (Maybe a2)) -> (a2 -> m (Maybe a1)) -> a -> m (Maybe a1)
15:19:01 <dmwit> ?unmtl MaybeT m a
15:19:02 <lambdabot> m (Maybe a)
15:19:33 <dmwit> :t (>=>) :: (a -> MaybeT m b) -> (b -> MaybeT m c) -> (a -> MaybeT m c)
15:19:33 <lambdabot>     Not in scope: type constructor or class `MaybeT'
15:19:34 <lambdabot>     Not in scope: type constructor or class `MaybeT'
15:19:34 <lambdabot>     Not in scope: type constructor or class `MaybeT'
15:19:40 <dmwit> acowley: ?
15:21:48 <dmwit> ?src MaybeT
15:21:48 <lambdabot> Source not found. Sorry.
15:22:05 <ET_> @pl f y x = g x y (show x )
15:22:05 <lambdabot> f = (`ap` show) . flip g
15:25:29 <dmwit> ?pl \f g -> runMaybeT . (MaybeT . f >=> MaybeT . g)
15:25:30 <lambdabot> (line 1, column 33):
15:25:30 <lambdabot> unexpected ">" or "="
15:25:30 <lambdabot> expecting variable, "(", ".", space, operator or ")"
15:25:30 <lambdabot> ambiguous use of a left associative operator
15:26:20 <dmwit> ?pl \f g -> runMaybeT . (MaybeT . f +++ MaybeT . g)
15:26:20 <lambdabot> ((runMaybeT .) .) . (. (MaybeT .)) . (+++) . (MaybeT .)
15:26:31 <ET_> @pl f y x = g y x x
15:26:31 <lambdabot> f = join . g
15:26:34 <dmwit> ?pl \f g -> runMaybeT . ((MaybeT . f) +++ (MaybeT . g))
15:26:35 <lambdabot> ((runMaybeT .) .) . (. (MaybeT .)) . (+++) . (MaybeT .)
15:26:43 <dmwit> gorgeous
15:26:48 * dmwit wipes a tear from his eye
15:27:12 <acowley> That's going in "Why you should learn Haskell!" slides
15:27:24 <dmwit> =)
15:27:58 <ion> :t (+++)
15:27:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
15:28:19 <acowley> I'm really wrestling with pushing the Maybe in and out of the other monad. It feels like it should be really clean.
15:28:19 <dmwit> ion: It's just standing in for (>=>) there, since ?pl doesn't seem to be able to handle (>=>) for some reason.
15:28:43 * hackagebot interpol 0.1.0 - GHC pre-processor to enable variable interpolation in strings  http://hackage.haskell.org/package/interpol-0.1.0 (AlexandruScvortov)
15:28:46 <dmwit> acowley: traverse will push the Maybe in; you should use MaybeT everywhere after that
15:29:02 <acowley> yeah, that makes sense
15:31:00 <acowley> thanks dmwit
15:32:25 <blackdog> can anyone remember the name of that article, something like "how to argue about type systems"?
15:32:31 <blackdog> my google-fu is weak today
15:32:58 <gentleben> blackdog: thats cause it keeps rolling
15:33:22 <blackdog> gentleben: :) straighten out and fly right, dammit
15:33:39 <gentleben> blackdog: hehe, yeah
15:34:28 <dmwit> :t MaybeT . Data.Traversable.sequence
15:34:29 <lambdabot> Not in scope: data constructor `MaybeT'
15:34:41 <dmwit> :t Control.Monad.Trans.Maybe.MaybeT . Data.Traversable.sequence
15:34:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe (m a) -> Control.Monad.Trans.Maybe.MaybeT m a
15:37:01 <hnsz> What is this sorcery!?
15:39:28 <dmwit> ?check \x -> sequence (sequence x) == x
15:39:29 <lambdabot>   "Falsifiable, after 5 tests:\n[[(),(),()],[],[()]]\n"
15:44:17 <incluye_> ?check \x -> x == x + 1
15:44:17 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
15:44:29 <incluye_> should we fix the output there sometime
15:45:52 <Cale> incluye: You mean the \n's?
15:45:58 <incluye> Yes
15:46:01 <Cale> incluye: Might be nice to strip them out, yeah
15:46:18 <incluye> :t [()]
15:46:19 <lambdabot> [()]
15:46:23 <incluye> Nice
15:47:52 <dmwit> let (*) = ()
15:47:57 <dmwit> (*) :: () :: *
15:49:34 <shachaf> dmwit: :: isn't infixr, is it?
15:50:58 <rwbarton> it's whatever == is
15:51:19 <blackdog> deggis: still there? this one tickles me a bit
15:51:35 <blackdog> > (const "f" <$> guard True) :: Maybe String
15:51:36 <lambdabot>   Just "f"
15:53:56 <ET_> @pl f x = x*x
15:53:56 <lambdabot> f = join (*)
15:54:47 <shachaf> > ((*) <*> id) 5
15:54:47 <lambdabot>   25
15:55:15 <shachaf> (<*> id) == join! /me proves all Applicatives are Monads.
15:56:20 <c_wraith> or you've proven that Reader is a really boring monad. :)
15:56:58 <shachaf> c_wraith: Quiet.
15:56:58 <ET_> @pl f g x = g x x
15:56:58 <lambdabot> f = join
15:57:00 <Polarina> Shouldn't this be discussed to #math?
15:57:13 <shachaf> Polarina: Shouldn't what?
15:57:28 <c_wraith> (and, in fact, it is.  everything you can do with Reader as a monad, you can do with Reader as an applicative functor)
15:57:50 <ET_> @pl f g x = g  d x x
15:57:51 <lambdabot> f = join . ($ d)
15:58:09 <ET_> @pl f g x = g  x (d x)
15:58:10 <lambdabot> f = (`ap` d)
15:58:11 <deggis> blackdog: hmm. that and what Cale suggested ( "fizz" <$ guard True ) are nice. i didn't see it at first, but writing Just three times and finally fromJust is not the most beautiful thing ever
15:58:19 <Polarina> shachaf, that all Applicatives are Monads. I sure can make one that ain't a Monad (but I'll sure get in jail for breaking the laws)
15:58:28 <ion> > "f" <$ guard True :: Maybe String  -- blakcdog
15:58:29 <lambdabot>   Just "f"
15:58:32 <ion> +typos
15:58:42 <erus`> can someone make an hour long documentary video on the IO monad please
15:58:49 <ET_> @type `ap`
15:58:50 <lambdabot> parse error on input ``'
15:58:59 <ET_> @type ap
15:59:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:59:06 <shachaf> Polarina: More like #haskell-blah, since that's where we put a lot of things that aren't serious. :-)
15:59:11 <blackdog> deggis: oh, i missed that. haven't used <$...
15:59:14 <shachaf> Polarina: What laws would you be breaking?
15:59:20 <blackdog> :t <$
15:59:20 <lambdabot> parse error on input `<$'
15:59:25 <shachaf> @src <$
15:59:25 <lambdabot> (<$) = (<$>) . const
15:59:26 <blackdog> :t (<$)
15:59:27 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:59:41 <blackdog> ah. ok, that's kinda neat.
16:00:09 <c_wraith> It's really handy for parsers
16:00:11 <deggis> blackdog: i've used it like two times so far, i hope i'll gradually remeber it more often
16:00:20 <c_wraith> it's less useful in other cases.
16:00:29 <c_wraith> > '-' <$ [1..10]
16:00:29 <lambdabot>   "----------"
16:00:30 <Polarina> shachaf, four laws. Identity, composition, homomorphism and the interchange laws. :)
16:00:49 <c_wraith> is that really better than replicate 10 '-' ?
16:01:14 <ion> Well, ¬´a <$ guard b¬ª is an ‚Äúother case‚Äù. :-)
16:01:27 <blackdog> c_wraith: replicate's bound to lists and this one isn't, right?
16:01:32 <dmwit> > const'-'.[1..1[]
16:01:33 <lambdabot>   <no location info>:
16:01:33 <lambdabot>      lexical error in string/character literal at chara...
16:01:37 <dmwit> > const'-'.[1..10]
16:01:38 <lambdabot>   <no location info>:
16:01:38 <lambdabot>      lexical error in string/character literal at chara...
16:01:46 <c_wraith> blackdog: yes indeed.  I'm just saying, for list and maybe, it's not so interesting :)
16:02:27 <c_wraith> blackdog: whereas in parsec or the like, it's *really* handy
16:04:11 <blackdog> c_wraith: so for a parser, you'd use it when you want to see a particular thing, but don't care about its value?
16:04:19 <c_wraith> blackdog: yes
16:06:42 <kalle__> Could anyone help me with prefix tries? :)
16:08:34 <dmwit> kalle__: Don't ask to ask; just ask.
16:09:04 <kalle__> Sure thing
16:09:14 <kalle__> I'm supposed to write a function trieInsert::(String,a)->Trie a->Trie a that takes in a key-value pair and a prefix tree.  It should return the symbol table where the key-value pair is included. If the key already exists the new value should replace the old one.    Example: trieInsert ("abc",10) emptyTrie-> TrieNode Nothing[('a', TrieNode Nothing[('a',TrieNode Nothing[('c',Trie_TrieNode(Just 10)[])])])]
16:09:39 <kalle__> oops, second trienode should be 'b' instead of 'a'
16:09:40 <erus`> what is type application in core?
16:10:56 <dmwit> kalle__: What have you got so far? Show us on hpaste.org.
16:11:04 <dmwit> (Don't paste in-channel.)
16:11:14 <kalle__> I havent started on this one, need some ideas on how to think etc
16:11:41 <shachaf> kalle__: Hah, are you at that Swedish university?
16:11:54 <kalle__> yup >_>
16:12:10 <kalle__> I take it all my classmates been in here? lol
16:12:17 <shachaf> A few.
16:12:42 <shachaf> Anyway, do you understand how tries work?
16:13:02 <kalle__> Yes, kind of. Only got two lectures on haskell though so dont expect me to be a pro :P
16:14:15 <shachaf> Can you describe your algorithm in some non-Haskell way? That might be helpful.
16:14:40 <kalle__> To insert key-values in the trie?
16:14:53 <Cale> kalle__: You should basically proceed by recursion on the String and the Trie that you get -- looking to see if the first character of the string is already in the list at the top of the Trie or not and describing the resulting Trie accordingly
16:15:50 <dmwit> kalle__: (Have you written down a Trie data type yet?
16:16:08 <kalle__> Yes, its data Trie a = TrieNode (Maybe a) [(Char, Trie a)]                     deriving Show
16:17:46 <dmwit> That looks like a good start.
16:20:49 <dainanaki> Quick question, how do I link html output generated by hscolour to the html output generated by haddock?
16:22:22 <co_dh> greeting, anybody successfully using XMonad on Mac OS X ?
16:22:43 <co_dh> I can run XMonad, but don't have Mod key :(
16:23:45 <rwbarton> you can choose which key xmonad uses. try #xmonad
16:24:30 <seanhess> I'm getting a weird type error using miku, the web framework: https://github.com/nfjinjing/miku/blob/master/src/Test/Test.hs << works
16:24:45 <seanhess> If I add an IO action in one of the routes, it fails with this error: https://gist.github.com/1338258
16:25:32 <seanhess> Why does it care what I do within my do block?
16:25:39 <co_dh> #xmonad
16:25:43 <seanhess> Does each line have to have the same type or something?
16:26:13 <shachaf> seanhess: Try using liftIO?
16:26:17 <dainanaki> seanhess: you need to use liftIO
16:26:32 <c_wraith> and all the lines do need to have things in common between their types
16:26:35 <c_wraith> :t (>>)
16:26:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:26:40 <seanhess> ok. That abstractifies an IO action?
16:27:43 * monochrom does not understand what the minus sign is doing there
16:27:43 <RaptorRarr> @type (>>)
16:27:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:29:59 <seanhess> lifeIO is magic
16:30:00 <seanhess> thanks guys
16:30:23 <mdempsky> @type liftIO
16:30:24 <lambdabot>     Ambiguous occurrence `liftIO'
16:30:24 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
16:30:24 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
16:30:40 <mdempsky> @type Control.Monad.Logic.liftIO
16:30:40 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
16:41:51 <stephens2424> Question: is there a way to get the (currently) last evaluated value from an infinite list?
16:42:44 <RaptorRarr> Probably not from within Haskell.
16:42:49 <Cale> stephens2424: there's no way to tell anything about how evaluated something is. An unevaluated expression computing a list and its fully evaluated counterpart are identical
16:43:16 <shachaf> There probably exists an evil way of doing it.
16:43:18 <Cale> Well, unless you start inspecting structures on the heap, which is not portable
16:43:28 <Cale> and will probably break with new GHC releases
16:43:50 <stephens2424> Ok, yeah, sounds like something I want to avoid. Thanks
16:44:15 <luite_> every other package breaks with new GHC releases so I don't think that's a very strong argument ;)
16:44:23 <Cale> luite_: heh
16:44:30 <RaptorRarr> stephens2424: What are you trying to do?
16:45:01 <RaptorRarr> Oh, you could probably use debug printing.
16:45:13 <RaptorRarr> Whenever an element is evaluated, it will debug print that.
16:45:13 <stephens2424> I'm solving Project Euler problems. I need to write an efficient function for testing if a number is prime
16:45:30 <RaptorRarr> Then, just look at the last debug print.
16:45:35 <Cale> How efficient does it need to be? :)
16:45:52 <stephens2424> I mean, more efficient than it is now (which is not very!)
16:45:54 <Cale> There's a nice way to write isPrime by mutual recursion with the infinite list of primes
16:46:21 <shachaf> Cale: Maximally efficient.
16:47:12 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5...] in primes
16:47:13 <lambdabot>   A section must be enclosed in parentheses thus: (5 ...)Not in scope: `...'
16:47:19 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in primes
16:47:20 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:47:41 <stephens2424> Right. If you can somehow refer to the current list of primes, it narrows down the pool of possible divisors by quite a bit. I'm just learning haskell, so figuring out a way to have that happen without triggering an infinite loop
16:49:04 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in isPrime 1000003
16:49:05 <lambdabot>   True
16:54:14 <kalle__> Hmmm, reading alot about it but still stuck -.-
16:54:50 <dmwit> If you can formulate a more specific question, perhaps we can help more.
16:55:18 <kalle__> Well, its the one I asked earlier. About inserting key-value pairs into a trie
16:55:22 <Cale> stephens2424: anyway, the key to it is seeding the list of primes with enough to get started -- just the 2 at the beginning is enough to test for 3's primality (since sqrt 3 <= 2) and enough to test 4 (since sqrt 4 = 2), and then 5 is found to be prime using the primality of 2 and from there it only gets easier.
16:56:02 <stephens2424> I see. that makes sense
16:56:42 <dmwit> kalle__: That's not specific enough. We aren't going to write your homework for you.
16:57:18 <kalle__> I dont want you to write it, I need some help to get started. What to think of, tips etc
16:57:20 <dmwit> We will gladly help you with syntax, compiler errors, the location of good libraries, etc.
16:57:21 <monochrom> actually, you should always be specific, homework or not
16:58:01 <dmwit> kalle__: Cale gave some great tips about half an hour ago. Start by recursing over the string and Trie in tandem.
16:58:19 <mytyfine> Having troubles getting ghc linking on linux: http://pastebin.com/EaEgXm4r
16:58:21 <mauke> The paste EaEgXm4r has been copied to http://hpaste.org/53517
16:58:33 <haskellStudent> hello i ve got a question
16:58:35 <kalle__> Alright, Ill give it a try and come back if Im having problems :)
16:58:50 <haskellStudent> Right (fromList [("gIp","127.0.0.1"),("gMaxPlayers","6"),("gMinPlayers","3"),("gMoney","5000"),("gPort","6969")])
16:59:04 <haskellStudent> how can i get the values knowing the keys
16:59:21 <haskellStudent> ?
16:59:34 <hnsz> haskellStudent findBy i think
16:59:38 <hnsz> with fst
16:59:43 <dmwit> ?hoogle Map k a -> k -> Maybe a
16:59:43 <lambdabot> Data.Map lookup :: Ord k => k -> Map k a -> Maybe a
16:59:43 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
16:59:43 <lambdabot> Data.Map lookupIndex :: Ord k => k -> Map k a -> Maybe Int
16:59:54 <dmwit> haskellStudent: ^^
17:00:03 <haskellStudent> doesn't work
17:00:07 <haskellStudent> try it :(
17:00:10 <dylex> mytyfine: look at ghc-pkg describe integer-gmp -- see if extra-libraries or something looks weird maybe
17:00:20 <dmwit> haskellStudent: Pattern match to deal with the Either-ness of your value.
17:00:22 <Cale> > Right (M.fromList [("gIp","127.0.0.1"),("gMaxPlayers","6"),("gMinPlayers","3"),("gMoney","5000"),("gPort","6969")])
17:00:23 <lambdabot>   Right (fromList [("gIp","127.0.0.1"),("gMaxPlayers","6"),("gMinPlayers","3"...
17:00:43 <Cale> > case Right (M.fromList [("gIp","127.0.0.1"),("gMaxPlayers","6"),("gMinPlayers","3"),("gMoney","5000"),("gPort","6969")]) of Left e -> Nothing; Right m -> lookup "gMaxPlayers" m
17:00:44 <lambdabot>   Couldn't match expected type `[([GHC.Types.Char], b)]'
17:00:44 <lambdabot>         against infe...
17:00:48 <Cale> err
17:00:55 <Cale> > case Right (M.fromList [("gIp","127.0.0.1"),("gMaxPlayers","6"),("gMinPlayers","3"),("gMoney","5000"),("gPort","6969")]) of Left e -> Nothing; Right m -> M.lookup "gMaxPlayers" m
17:00:55 <lambdabot>   Just "6"
17:01:08 <haskellStudent> :O nice
17:01:12 <hnsz> snd (findBy ((==) . fst myKey) list)
17:01:19 <hnsz> :)
17:01:24 <dmwit> hnsz: It's not a list...
17:01:26 <dylex> mytyfine: it probably just says "gmp", which would expect something like /usr/lib/libgmp.so to be there
17:01:36 <haskellStudent> thnx a lot m8!
17:01:38 <dmwit> hnsz: Also, you should just use "lookup" for that.
17:01:40 <dmwit> :t lookup
17:01:40 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:01:51 <hnsz> :findBy
17:01:55 <hnsz> :t findBy
17:01:56 <lambdabot> Not in scope: `findBy'
17:01:59 <Cale> :t find
17:01:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
17:02:00 <hnsz> heh
17:02:00 <mytyfine> dylex:  hmmm, but it's linked into ghc
17:02:03 <monochrom> there is no findBy
17:02:09 <mytyfine> dylex: which is confusing me
17:02:13 <hnsz> Weird that it is in my head :)
17:02:21 <Cale> There is find
17:02:39 <dylex> mytyfine: yes, but where it's failing is loading the integer-gmp package, which separately links to gmp
17:03:08 <mytyfine> dylex:  where's ghc-pkg describe integer-gmp  at?
17:03:28 <dylex> mytyfine: ghc-pkg is a command, should be the same place as ghc.
17:03:29 <dmwit> mytyfine: You just literally type "ghc-pkg describe integer-gmp" on the command line.
17:04:19 <monochrom> does "/usr/lib/libgmp.so" exist? it should.
17:05:12 <monochrom> get ubuntu package libgmp3-dev if necessary
17:05:28 <Phlogistique> is there no search-and-replace functions in Text.Regex?
17:05:58 <Cale> There's search, there's no replace.
17:06:05 <mytyfine> "/usr/lib/libgmp.so" doesn't exist, but "/usr/lib/libgmp.so.3" does
17:06:42 <monochrom> indeed libgmp3-dev is the one that sets up /usr/lib/libgmp.so
17:06:49 <dylex> mytyfine: try ldconfig, or yeah, whatever is appropriate for your distribution
17:07:17 <Phlogistique> Cale: OK, thanks for your answer!
17:07:34 <monochrom> "libgmp.so: cannot open shared object file: No such file or directory" is a strong case of looking for exactly /usr/lib/libgmp.so
17:07:55 <monochrom> since it does not say "libgmp.so.3: cannot open blahblah"
17:08:19 <dylex> libgmp.so is typically just a symlink to the current version
17:08:50 <haskellStudent> :(
17:08:51 <haskellStudent> Couldn't match expected type `IO b0' with actual type `Maybe a0'
17:08:52 <monochrom> "ghc-pkg field integer-gmp extra-libraries" shows you why, but that's what dylex says
17:09:18 <Cale> haskellStudent: You're trying to use a Maybe value as an IO action
17:10:19 <copumpkin> dcoutts: hmm, cabal-install won't build on ghc head for me
17:10:28 <copumpkin> has it just not been updated for the lack of Show/Eq for Num?
17:11:54 <copumpkin> yeah, that appears to be all that's missing
17:13:44 <rfw> hi there, hopefully a quick question -- how can i use the IO and ST monads together?
17:13:51 <mytyfine> dylex: http://pastebin.com/N6xhiAMu
17:13:53 <mauke> The paste N6xhiAMu has been copied to http://hpaste.org/53518
17:14:11 <rfw> for instance, i want to read a character from a file and put it into an STRef
17:14:43 <dmwit> rfw: You'll have to do all your ST actions at once, I'm afraid -- no fair interleaving ST and IO.
17:14:48 <dcoutts> copumpkin: patches gladly accepted
17:15:02 <monochrom> so yes, when loading integer-gmp, it likes to open /usr/lib/libgmp.so. despite ghc itself already opens /usr/lib/libgmp.so.3
17:15:03 <rfw> dmwit: ah okay
17:15:15 <rfw> is there anything like STRefs with te IO monad?
17:15:23 <dcoutts> IORef
17:15:24 <dmwit> There's IORef.
17:15:25 <mytyfine> monochrom: brutal
17:15:40 <copumpkin> dcoutts: it's five characters :) I'll submit it if it's less work than me telling you what to change and where
17:15:43 <rfw> ah okay, thanks
17:15:51 <mytyfine> monochrom: can I fake it out somehow ‚Äî I don't have privs on /usr/lib
17:15:51 <dcoutts> copumpkin: go on then
17:16:17 <rfw> awesome. thanks!
17:16:18 <monochrom> I thought you were on amazon ec2 and you were root
17:16:23 <dylex> mytyfine: You could probably put (symlink) libgmp.so in some other directory and add it to LD_LIBRARY_PATH
17:16:28 <copumpkin> caba-install/Distribution/Client/Tar.hs:746, add a Show a to the context
17:16:37 <copumpkin> that makes it build on the GHC I built a week or two ago
17:16:42 <monochrom> what dylex says
17:16:45 <copumpkin> wow, what's wrong with my typing
17:17:06 <mytyfine> dylex: going to try that
17:17:28 <copumpkin> dcoutts: actually, I lied! it's 7 characters :(
17:17:36 <copumpkin> wait, more
17:17:42 <monochrom> mkdir ~/lib ; ln -s /usr/lib/libgmp.so.3 ~/lib/libgmp.so ; export LD_LIBRARY_PATH=$HOME/lib
17:17:43 <copumpkin> 10 :(
17:17:50 <dcoutts> copumpkin: ok, got it, is that the lot?
17:17:51 <haskellStudent> Couldn't match expected type `IO (Either ParseError Config)'                 with actual type `Either t0 t1'
17:18:07 <dcoutts> -putOct :: Integral a => FieldWidth -> a -> String
17:18:07 <dcoutts> +putOct :: (Show a, Integral a) => FieldWidth -> a -> String
17:18:09 <copumpkin> dcoutts: yep, a few warnings here and there about the deprecated catch, but otherwise it built fine
17:18:10 <dcoutts> copumpkin: ^^ right?
17:18:14 <copumpkin> yep
17:18:17 <dcoutts> ta
17:18:21 <copumpkin> thank you!
17:18:24 * monochrom hasn't needed to muck with LD_LIBRARY_PATH for a long time!
17:18:37 <copumpkin> dcoutts: does cabal-install generate code at some point?
17:18:42 <dgpratt> hey, copumpkin!
17:19:01 <copumpkin> dgpratt: yo
17:19:10 <dcoutts> copumpkin: the "Simple" build system does, yes
17:19:30 <dgpratt> copumpkin: feel up to suffering a fool?
17:19:49 <mytyfine> monochrom:  nice! that got me up! Thanks!
17:19:50 <copumpkin> dcoutts: because I vaguely remember some package I built using -Werror failing in code I didn't recognize, so perhaps the generated code contains a call to Prelude.catch?
17:20:05 <copumpkin> dcoutts: anyway, I'll look into it and will submit a real patch if I find other issues :)
17:20:10 <copumpkin> dgpratt: hah, depends :)
17:20:11 <dcoutts> copumpkin: yes, if you use Cabal-1.10 with ghc-7.2
17:20:24 <dmwit> dgpratt: The usual advice is to just ask your question, rather than asking to ask.
17:20:35 <copumpkin> dgpratt: either way, if I don't, someone else around here will :)
17:20:38 <dcoutts> copumpkin: the deprecated generated code was fixed in Cabal-1.12
17:20:42 <dgpratt> I'm still stuck on "(a => Dict b)"
17:21:09 <copumpkin> dcoutts: ah, okay! is that even in the repository? I just pulled and built cabal and -install, and seem to have 0.11.3 and 1.11.3
17:21:19 <copumpkin> dgpratt: what about it?
17:21:44 <dcoutts> copumpkin: yeah, I bumped it to 1.13 a few days ago, I'd forgotten that'd we'd released 1.12 and so head out to be a later version :-)
17:21:53 <dcoutts> out/ought
17:21:58 <copumpkin> oh
17:22:02 <Phlogistique> a question
17:22:05 <Phlogistique> replace str rx text = before ++ text ++ after where (before, _, after) = str =~ rx
17:22:07 <dgpratt> copumpkin: so glad you asked; I can accept that this means 'a' implies 'b' (right?), but I'd really like to know how/why?
17:22:10 <Phlogistique> yields a type error
17:22:18 <Phlogistique> No instance for (RegexContext Regex [Char] ([Char], t0, [Char]))
17:22:24 <copumpkin> dgpratt: Dict b carries a  context of b deep in its bowels
17:22:29 <Phlogistique> whereas if I tell GHC the type:
17:22:38 <Phlogistique> replace str rx text = before ++ text ++ after where (before, _ , after) = (str =~ rx :: (String, String, String))
17:22:42 <Phlogistique> it works
17:22:48 <dmwit> Phlogistique: Crazy, isn't it?
17:22:57 <copumpkin> dgpratt: ideally, we'd have some way to say (a => b) where a and b are both contexts, but that's not possible, so we wrap the b in the Dict, then write it that way
17:23:01 <dmwit> Phlogistique: Not much to do about it, though, except avoid FlexibleInstances.
17:23:36 <Phlogistique> dmwit: Do you have a link or keywords an explaination about the matter?
17:23:50 <Phlogistique> FlexibleInstances?
17:24:42 <dmwit> Phlogistique: The short answer is that GHC will never make a type *more monomorphic* than it has been inferred to be before it chooses an instance.
17:24:51 <dmwit> If choosing an instance would require it to do that, it reports an error instead.
17:25:21 <monochrom> it doesn't know the type of _ . it needs that type to decide which instance to choose.
17:25:30 <dmwit> right
17:26:13 <dmwit> I think the idea is that adding new instances should never break otherwise correct code.
17:26:17 <monochrom> consider case read "hi" of _ -> "whee"
17:26:53 <monochrom> in fact let me see if this also works my way
17:27:02 <monochrom> > case maxBound of _ -> "whee"
17:27:03 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:27:03 <lambdabot>    `GHC.Enum.Bounded a'
17:27:04 <lambdabot>     ...
17:27:08 <monochrom> \‚à©/
17:27:46 <dmwit> The requested URL /ghc/dist/current/docs/users_guide.pdf/type-extensions.html was not found on this server.
17:27:52 <dmwit> ...uh, that was not the URL I requested.
17:28:50 <monochrom> heh
17:29:45 <monochrom> but this is essentially the regex package doing funky type classes and instances. you can't quite tell a pre-written lib "avoid FlexibleInstance"
17:30:27 <dmwit> indeed not
17:34:54 <dgpratt> so if do something like "...(Eq a) => ...", does the type constraint imply...implication, somehow?
17:35:20 <copumpkin> yeah, "if a is a member of Eq, then ..."
17:35:28 <copumpkin> it's a slightly different kind of implication in haskell
17:35:39 <copumpkin> but it could be modeled as a standard function arrow
17:35:48 <copumpkin> in fact, behind the scenes, it is
17:37:05 <Phlogistique> 01:32:56 < dmwit> I think the idea is that adding new instances should never break otherwise correct <- oh, right, ok
17:42:00 <dgpratt> copumpkin: so is the property that is important (in this case) the fact that there can be only one instance for a given constraint? therefore if we know the constraint, we know the instance?
17:42:21 <copumpkin> nah, that's not crucial
17:42:37 <copumpkin> (a => Dict b) is saying that constraint a implies constraint b
17:42:47 <copumpkin> for some a and b
17:43:05 <JoeyA> I know this is Haskell 101, but: is it safe to define an expression that will fail in some cases, and use it only when I'm sure it's valid?
17:43:07 <hpaste> ‚ÄúIs it safe to trust total laziness?‚Äù pasted ‚ÄúJoey Adams‚Äù at http://hpaste.org/53519
17:43:07 <copumpkin> it's no different from saying that a -> b means a implies b
17:43:20 <scshunt> JoeyA: yes
17:43:24 <JoeyA> Thanks
17:43:26 <dylukes> How can I get GHC to spit out STG output?
17:43:40 <dylukes> I need an idea of how I can differentiate differently sized integer types in my own STG source
17:43:49 <copumpkin> -ddump-stg
17:44:02 <JoeyA> You do it entirely with the # character.
17:44:43 <JoeyA> To me, # just looks like the "experts only" operator.
17:45:18 <dmwit> JoeyA: Define "safe".
17:45:38 <dmwit> Oh, I see.
17:45:48 <dmwit> JoeyA: Why not just use liftM2 (,)?
17:45:51 <dmwit> :t liftM2 (,)
17:45:52 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:45:57 <JoeyA> dmwit: I mean, can I be sure the compiler won't get eager and evaluate fromJust a in the case where isJust ma && isJust mb doesn't hold.
17:46:08 <dmwit> Yes, you can be sure of that.
17:46:17 <dmwit> JoeyA: But this function is very easy to write without relying on that.
17:46:34 <JoeyA> dmwit: Thanks.  My actual function is a little more complex.
17:46:48 <hpaste> dmwit annotated ‚ÄúJoey Adams‚Äù with ‚ÄúJoey Adams (annotation)‚Äù at http://hpaste.org/53519#a53520
17:48:28 <monochrom> nice, pattern matching wins again
18:00:12 <hpaste> edwardk pasted ‚ÄúTHC.Digest for dylukes‚Äù at http://hpaste.org/53521
18:01:21 <hpaste> edwardk pasted ‚ÄúTHC.Con for dylukes‚Äù at http://hpaste.org/53522
18:09:47 <dgpratt> ok, since I can't think of a better question to ask, what is the value of saying constraint 'a' implies constraint 'b'?
18:10:33 <copumpkin> whenever you have a constraint a, you can construct a constraint b
18:11:01 <copumpkin> it's like saying MultipleOfFour(X) implies Even(X)
18:11:14 <copumpkin> if you have a proof that your number is a multiple of four, I can give you a proof that it's even
18:11:21 <copumpkin> (well, assuming you give me your proof)
18:12:51 <edwardk> dgpratt: Ord a :- Eq a  -- so if i can construct an arrow say Foo x y z w :- Ord (x,y,z)       then I can compose those to get Foo x y z w :- Eq a  -- then i can use \\ to do that substitution. when we start putting a lot of these in GADTs or passing around more constraints then i may need to transform one constraint into another, since unification on constraints is done by structural
18:12:51 <edwardk>  equality
18:13:17 <edwardk> (Foo,Bar) ~ (Bar,Foo) doesn't hold but (Foo,Bar) :- (Bar,Foo) does
18:13:32 <edwardk> and vice versa
18:13:45 <edwardk> so you can make a notion of bientailment that gives you a weaker equality
18:14:22 <edwardk> Dict (Ord a, Eq a)   and Dict (Ord a) contain the same amount of information, but aren't structurally equal
18:14:33 <Cale> Sounds like a job for that zany homotopy type theory stuff
18:14:34 <dgpratt> how does one (in this scheme) actually prove Ord a :- Eq a?
18:14:42 <edwardk> cale: yes =)
18:14:51 <edwardk> ordEq :: Ord a :- Eq a
18:14:54 <edwardk> ordEq = Sub Dict
18:14:55 <edwardk> done
18:15:19 <dgpratt> edwardk: I was afraid of that; too simple for me to understand :)
18:15:37 <edwardk> dgpratt: we let the type checker do it basically
18:16:14 <edwardk> Sub says we're going to defer the actual resolution of the Ord a constraint until later, but using it, we ask the type checker to figure out Eq a, which it does for us because class Eq a => Ord a
18:17:15 <edwardk> dgpratt: consider composition of entailment perhaps
18:17:29 <edwardk> (b :- c) -> (a :- b) -> a :- c
18:18:05 <edwardk> trans f g = Sub (Dict \\ f \\ g)
18:18:34 <copumpkin> dgpratt: keep in mind that whenever he writes Sub Dict, GHC is doing a lot of his proving work for him, behind his back
18:19:22 <edwardk> we have infixl 1 \\     so thats (Dict \\ f) \\ g -- so inside of Sub where we're given a, we're using the entailment that a :- b first
18:19:32 <edwardk> that lets us derive b and bring it into scope
18:19:38 <edwardk> then we use b :- c to derive c
18:20:00 <edwardk> then that is the entry we want to put in the dictionary
18:21:08 <Cale> It might be helpful to write out the type of Sub
18:21:21 <Cale> (and to note the type of Dict here)
18:22:27 <dgpratt> I'm gonna try to let this marinate for a bit, thanks for the help guys
18:23:00 <edwardk> data a :- b = Sub (a => Dict b)
18:23:50 * hackagebot tag-stream 0.1.0 - streamlined html tag parser  http://hackage.haskell.org/package/tag-stream-0.1.0 (YiHuang)
18:23:52 * hackagebot hosts-server 0.1.0 - An dns server which is extremely easy to config.  http://hackage.haskell.org/package/hosts-server-0.1.0 (YiHuang)
18:24:45 <edwardk> so just pretend that => is a -> where the compiler is going to figure out how to magic up the left hand side for you using the instances it has around as functions
18:24:55 <edwardk> and where it can read the signature for classes backwards
18:25:59 <edwardk> so given instance Eq a => Eq [a]          the compiler is free to take an Eq a it has lying around and make an Eq [a] in order to pass it as the left hand side of an =>
18:26:11 <edwardk> or part of one
18:26:23 <edwardk> all the entailment stuff does is let me guide the process a bit
18:28:21 <edwardk> this will matter to me a lot more once we start having natural numbers as a kind, because i'm terribly leery about how to deal with those when the compiler isn't smart enough, as one can prove it will necessarily be for some problems
18:32:11 <Phlogistique> I'm surprised there is no (t -> b) -> Either t t -> Either b b
18:32:33 <Phlogistique> maybe using Either tt is a bad idea and I should be using something else?
18:32:48 <Phlogistique> like (t, Bool)
18:33:21 <u__> anyone here doing the Ants AI Challenge in haskell on mac os x?
18:33:33 <copumpkin> Phlogistique: how common is Either t t?
18:33:43 <copumpkin> make it (Bool, t) and then just use fmap :)
18:33:46 <u_> test
18:34:45 <u_> if so, how did you set it up?
18:36:00 <Phlogistique> copumpkin: indeed
18:36:02 <Phlogistique> thanks
18:38:25 <DukeDave> Does anyone here have experience using the AC-Vector modules?
18:44:09 <ddarius> edwardk: What happens if I use your stuff with incoherent instances.
18:44:10 <ddarius> ?
18:44:40 <newsham> there are several lense packages on hackage..  which should I choose?
18:45:27 <dgpratt> in what sense is Dict a dictionary?
18:45:35 <edwardk> then you get an incoherent result. ;)
18:46:00 <edwardk> dgpratt: when opened up i can call any of the methods that were contained _in_ the dictionary
18:46:36 <ddarius> What about the methods contained on the dictionary or beside the dictionary?
18:46:37 <edwardk> ddarius: in particular it is possible when using overlapping instances to get the wider instance in a context where the narrower one would have applied
18:46:45 <dgpratt> edwardk: to me, that makes it sound more like a bag
18:47:08 <edwardk> dgpratt: the name dictionary wasn't made up by me
18:48:24 <edwardk> but basically the dictionary is the record that contains the body of the typeclass and enough information either in the form of the record directly or a process for deriving it for each of the superclasses of that class
18:48:57 * ddarius has no bloody clue what his password is for haskellwiki.
18:50:08 <shachaf> ddarius: Didn't you add yourself to the Hac Boston attendees list?
18:50:20 <shachaf> Oh, looks like edwardk did.
18:50:26 <shachaf> That explains why so many people got added at the same time.
18:50:44 <edwardk> yeah
18:51:09 <edwardk> i went and added most of the folks who i didn't think wanted their presence to be a secret. coz otherwise only a tenth of the attendees would show on the list
18:51:36 <shachaf> edwardk: Are there people who want their presence to be a secret?
18:51:40 <edwardk> perhaps a bit wrongheaded of an approach, next time if we do this i'll put a 'post my name on the wiki' flag or something in the registration
18:52:14 <edwardk> maybe, but if so then maybe they want the fact that it is a secret to be a secret
18:52:41 <Phlogistique> now I understand that I don't understand functors and fmap
18:52:51 <dmwit> Is there an analog to "common knowledge" like "common secret"?
18:53:03 <ddarius> That's what I was thinking.
18:53:09 <shachaf> edwardk: I meant "are there people whom you didn't add to the list because you thought they wanted their presence to be a secret"?
18:53:20 <dmwit> It's a secret, and it's a secret that it's a secret, and it's a secret that it's a secret that it's a secret...
18:53:54 <edwardk> i left off a few people who haven't officially registered but indicated they're coming, and the group of people who signed up after i made that edit
18:53:58 <Phlogistique> say I want (a, b) -> (f a, b)
18:54:04 <ddarius> "You don't know X, and you don't know that you don't know X, ..."
18:54:12 <dmwit> :t first return
18:54:13 <lambdabot> forall b (m :: * -> *) d. (Monad m) => (b, d) -> (m b, d)
18:54:24 <Phlogistique> indeed
18:54:25 <Phlogistique> thanks
18:54:37 <ddarius> :t first pure
18:54:38 <lambdabot> forall b (f :: * -> *) d. (Applicative f) => (b, d) -> (f b, d)
18:54:44 <shachaf> @ty first pure
18:54:45 <lambdabot> forall b (f :: * -> *) d. (Applicative f) => (b, d) -> (f b, d)
18:54:47 <shachaf> Bah.
18:55:13 <dmwit> :t virgin
18:55:13 <lambdabot> forall b d (f :: * -> *). (Applicative f) => (b, d) -> (f b, d)
18:56:07 <dmwit> let virgin touch = first pure touch
19:03:43 <drbean> What is the analog of fst for a 3-tuple?
19:03:57 <monochrom> none. write it yourself.
19:04:32 <JoeyA> > (\(a, b, c) -> a) (1,2,3
19:04:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:04:36 <JoeyA> > (\(a, b, c) -> a) (1,2,3)
19:04:37 <lambdabot>   1
19:05:39 <u_> i usually just nest tuples when i need more than 2
19:05:46 <drbean> I would have used pattern matching.
19:09:35 <edwardk> is there a haskell client for the quantum random bit generator service?
19:10:41 <edwardk> i was joking that i tend to flip coins as to which project i work on that way at least in some universe there is probably a me working on the more interesting one, but it strikes me that it would be nicer to actually have that coin flip hinge on a simpler quantum event
19:11:18 <JoeyA> If there is, I should update my http://hackage.haskell.org/package/randfile package
19:11:37 <shachaf> @remember edwardk <edwardk> is there a haskell client for the quantum random bit generator service? <edwardk> i was joking that i tend to flip coins as to which project i work on that way at least in some universe there is probably a me working on the more interesting one, but it strikes me that it would be nicer to actually have that coin flip hinge on a simpler quantum event
19:11:38 <lambdabot> Nice!
19:12:09 <JoeyA> I use crypto-quality random generation to randomly choose my music.  I was actually finding System.Random to be unsatisfactory to that end.
19:12:31 <edwardk> joeya: i just registered for an account and grabbed the protocol. i may add a package =)
19:12:33 <monochrom> coin flip may in fact not be quantum-nondeterministic, just chaotic
19:12:46 <edwardk> monochrom: exactly
19:12:55 <edwardk> hence why i want some nice quantum event
19:13:08 <shachaf> JoeyA: I hear that the more you pay for you random numbers, the higher-quality music will be chosen for you.
19:13:21 <JoeyA> lol
19:13:54 <monochrom> I would just buy a Geiger counter, then count the number of ticks in the next minute (or 5 minutes or whatever), then mod N to decide which one of N projects
19:14:06 <Nimatek> There is no experimental proof for the many worlds interpretation of qm yet.
19:14:36 <JoeyA> Except for all the dead cats.
19:14:59 <pikhq_> Nimatek: However, there is no experimental proof for *any* interpretation of quantum mechanics yet.
19:15:05 <monochrom> http://ro-che.info/ccc/04.html
19:15:12 <dmwit> I don't think anybody even thinks there's an experiment that could differentiate between any interpretation of quantum mechanics.
19:15:15 <Nimatek> pikhq_: Which is why they're called interpretations, I guess.
19:15:21 <pikhq_> The only thing we can really discuss is what seems more reasonable.
19:15:23 <edwardk> monochrom: reasonable
19:15:33 <dmwit> Not just that there's an experiment that's too hard to do yet, but just that all interpretations make the same predictions.
19:15:52 <Nimatek> monochrom: Lol
19:15:58 <Sgeo|web> Quantum suicide...
19:16:35 <pikhq_> dmwit: Well, Copenhagen interpretation uniquely makes the prediction that there exists greater-than-light-speed phenomenon. :P
19:16:59 <pikhq_> Phenomena as well.
19:20:55 <Sgeo|web> Does it ever make sense for ContT to not be the ... top monad in the monad transformer?
19:21:04 <Sgeo|web> StateT s ContT r whatever?
19:21:22 <dmwit> ?unmtl StateT s Cont a
19:21:22 <lambdabot> err: `Cont (a, s)' is not applied to enough arguments, giving `/\A. (A -> (a, s)) -> (a, s)'
19:21:34 <dmwit> ?unmtl StateT s (Cont r) a
19:21:35 <lambdabot> s -> (a -> s -> r) -> r
19:22:09 <Sgeo|web> ?unmlt Cont r StateT s a
19:22:09 <lambdabot> Maybe you meant: unmtl unpl
19:22:09 <dmwit> ?unmtl ContT r (State s) a
19:22:09 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
19:24:29 <shachaf> Hmm, does @unmtl automatically curry the CPSed function?
19:25:33 <Sgeo|web> @unmlt ContT r IO ()
19:25:33 <lambdabot> Maybe you meant: unmtl unpl
19:25:37 <Sgeo|web> @unmtl ContT r IO ()
19:25:37 <lambdabot> (() -> IO r) -> IO r
19:40:25 <Sgeo|web> http://ro-che.info/ccc/05.html what is the monad represented here?
19:40:44 <Sgeo|web> I've never heard of Except monad
19:42:15 <shachaf> Sgeo|web: Just to be helpful, I put an explanation at the bottom of the page and reloaded your browser. :-)
19:43:22 * Sgeo|web starts reading the comic over for missed stuff like that
19:44:54 <Sgeo|web> :t unsafeSolveHaltingProblem
19:44:55 <lambdabot> Not in scope: `unsafeSolveHaltingProblem'
19:45:19 <Sgeo|web> Why would a hypothetical solveHaltingProblem :: a -> Bool be unsafe?
19:46:04 <shachaf> Well, it's hypothetical.
19:46:22 <byorgey> Sgeo|web: because it would cause a local spacetime anomaly which could make your head explode
19:46:24 <shachaf> If you run a hypothetical function without being hypothetical yourself, the behavior is undefined.
19:46:50 <JoeyA> I think of it as defined :: a -> Bool
19:47:11 <JoeyA> which returns true if the value evaluates to head-normal form, false otherwise.
19:47:36 <roconnor> sipa: I finished refactoring purecoin: darcs get http://r6.ca/Purecoin
19:47:56 <JoeyA> Returning True if it evaluates is easy:
19:48:07 <shachaf> safeSolveHaltingProblem x = x `seq` True
19:48:09 <JoeyA> @let defined !_ = return True
19:48:10 <lambdabot>  Defined.
19:48:15 <JoeyA> > defined
19:48:16 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> m GHC.Bool.Bool)
19:48:16 <lambdabot>    arising f...
19:48:20 <roconnor> sipa: well, maybe not finished, but got to a waypoint
19:48:22 <JoeyA> > defined 1
19:48:22 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Bool.Bool))
19:48:22 <lambdabot>    arising from a use of ...
19:48:26 <dmwit> Why do you think it would be unsafe?
19:48:29 <JoeyA> > True
19:48:30 <lambdabot>   True
19:48:39 <JoeyA> @let defined !_ = True
19:48:39 <lambdabot>  <local>:11:13:
19:48:39 <lambdabot>      Couldn't match expected type `m Bool' against inferred t...
19:48:40 <dmwit> Plenty of CS research starts with the sentence "assume we have a halting oracle"...
19:48:52 <JoeyA> @undef defined
19:50:31 <roconnor> dmwit: in constructive mathematics often the conclusion is that we get a halting oracle.
19:50:36 <JoeyA> Simon Peyton Jones preaches that you shouldn't start a paper like that.  You should start with the motivation and underlying idea before getting to the mumbo-jumbo.
19:50:56 <JoeyA> (google "How to write a great research paper".  He gave a nice talk about that)
19:52:02 <Sgeo|web> JoeyA: The trick is getting it to return false
19:52:13 <JoeyA> right
19:53:02 <JoeyA> The main problem is that exceptions can't be caught in pure code (without unsafePerformIO).
19:53:21 <JoeyA> @faq Can an exception handler detect that a computation will not halt?
19:53:22 <lambdabot> The answer is: Yes! Haskell can do that.
19:53:33 <roconnor> I wish unsafePerfromIO was less well known
19:55:59 <Sgeo|web> @faq Is the statement "This statement is false." true or false?
19:56:00 <lambdabot> The answer is: Yes! Haskell can do that.
19:57:44 <Sgeo|web> @faq Can I write a function f such that f _|_ = 1 but f 1 = _|_
19:57:45 <lambdabot> The answer is: Yes! Haskell can do that.
19:59:34 <siracusa> @faq Can Haskell even do things Haskell can't do?
19:59:34 <lambdabot> The answer is: Yes! Haskell can do that.
20:03:26 <stepkut> roconnor: secretPerformIO ?
20:03:37 <roconnor> :)
20:04:06 <stepkut> roconnor: maybe we can rename unsafePerformIO to installPHP and then no one will want to call it ?
20:04:38 <Sgeo|web> Suppose, hypothetically, I wanted to implement stuff like par in pure Haskell
20:04:46 <Sgeo|web> Would I be forced to use unsafePerformIO?
20:04:56 <Sgeo|web> Or is it not even possible?
20:07:57 <shachaf> Sgeo|web: Yes, I imagine you could implement something roughly similar using unsafePerformIO-ish primitives.
20:08:05 <shachaf> For example, monad-par is implemented that way.
20:08:17 <shachaf> @google monad-par
20:08:18 <lambdabot> http://hackage.haskell.org/package/monad-par
20:08:18 <lambdabot> Title: HackageDB: monad-par-0.1.0.1
20:09:01 <shachaf> @google monad-par filetype:pdf
20:09:01 <lambdabot> http://community.haskell.org/~simonmar/papers/monad-par.pdf
20:09:01 <lambdabot> Title: A Monad for Deterministic Parallelism
20:17:28 <Sgeo|web> The future of mathematics seems to be the end of CCC
20:39:27 <kmc> Sgeo|web, you were asking about global locks and such?
20:41:32 <copumpkin> kmc: he was, I think, but a misunderstanding led discussion of abstracting out another type of annoying foreign library access pattern
20:43:10 <monochrom> f :: a -> Bool  must satisfy (for all x, f x = True) or (for all x, f x = False) or (for all x, f x diverges) to satisfy parametricity.
20:43:32 <copumpkin> Sgeo|web: the end of CCC?
20:43:57 <monochrom> CCC may get updates fairly infrequently
20:44:24 <monochrom> look at all the past publishing dates to estimate the next instalment
20:44:57 <monochrom> @free f :: a -> Bool
20:44:57 <lambdabot> f = f . g
20:45:42 <copumpkin> oh, the comic
20:47:34 <monochrom> arguably, (for all x, f x diverges) semi-solves the halting problem
20:48:06 <byorgey> haha
20:48:12 <kmc> 'k
20:48:20 <monochrom> arguably, (for all x, f x = False) solves the halting problem for suitable inputs and solves the nonhalting-problem for other inputs
20:52:41 --- mode: ChanServ set +o monochrom
20:53:06 --- mode: monochrom set -bb *!*@gateway/web/freenode/ip.144.32.178.* *!*@pool-173-67-166-199.hrbgpa.east.verizon.net
20:53:15 --- mode: monochrom set -o monochrom
20:55:17 <glioros> free porn come to #retarted #retarted #retarted #retarted #retarted #retarted #retarted #retarted #retarted  #retarted #retarted
20:55:46 --- mode: ChanServ set +o monochrom
20:55:50 --- mode: monochrom set +b *!*@95.175.151.192
20:55:51 --- kick: glioros was kicked by monochrom (glioros)
20:56:55 <Sgeo|web> kmc: if I want to write a library where the primitive functions take callbacks and convenience functions that act synchronously, is it better to play with locks and threads or ContT?
20:59:49 <kmc> can you elaborate?
21:00:03 <kmc> best would be a hpaste with some example type signatures
21:03:38 <Sgeo|web> Hold on
21:06:54 <hpaste> Sgeo pasted ‚ÄúSome async function‚Äù at http://hpaste.org/53524
21:08:10 <hpaste> Sgeo annotated ‚ÄúSome async function‚Äù with ‚ÄúSome async function (annotation)‚Äù at http://hpaste.org/53524#a53525
21:08:51 <Sgeo|web> It probably wouldn't be in the IO monad, actually
21:08:55 <Sgeo|web> But some custom monad
21:09:03 <Sgeo|web> Provided by my library, I mena
21:09:05 <Sgeo|web> mean
21:09:13 <Sgeo|web> Well, hmm
21:10:20 <napping> What kind of haskell library do you have in mind with enough state that "synchronous" is a big deal?
21:10:25 <hpaste> Sgeo annotated ‚ÄúSome async function‚Äù with ‚ÄúSome async function (annotation) (more flexible?)‚Äù at http://hpaste.org/53524#a53526
21:10:37 <Sgeo|web> Is that a sensible thing to do?
21:10:45 <Sgeo|web> napping: a wrapper around the ActiveWorlds SDK
21:11:24 <napping> So it is a binding around something pretty imperative. That makes more sense
21:14:04 <napping> Maybe you don't really need to expose either
21:14:28 <napping> ContT is about writing something that looks like straight-line code but has places where things can be delayed
21:15:22 <napping> and can be wrapped easily enough around a callback-based interface - did you see sigfpe's recent blog?
21:16:00 <napping> http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
21:17:28 <yulys> hi everyone! I am a newbie in Haskell so I m just trying the reading of three numbers as inputs and I want to get one output
21:18:02 <simon> yottis_, how is that going?
21:19:00 <yulys> this is my first draft
21:19:03 <yulys> main :: (Num (IO()))
21:19:05 <yulys> main
21:19:07 <yulys>   = do { b / a * c}
21:19:09 <yulys>   where
21:19:11 <yulys>       (a,b,c) = (8,3,15)
21:19:26 <min> yulys: the tutorial <http://www.haskell.org/tutorial/io.html> at haskell.org gives a nice overview of basic input and output in Haskell.
21:19:36 <yulys> but I got error: tipos.hs:1:10:
21:19:38 <yulys>     Class `Num' used as a type
21:19:40 <yulys>     In the type signature for `main': main :: Num (IO ())
21:19:42 <kmc> Sgeo|web, callbacks in arbitrary MonadIO are a real pain
21:19:49 <yulys> ok, thank you so much min!!!
21:20:16 <kmc> Sgeo|web, anyway, I can't tell from the type sigs alone what you're trying to do
21:20:37 <kmc> also, shouldn't the non-sync version return IO () not IO a?
21:21:06 <copumpkin> IO (IO a)
21:21:20 <kmc> generally Haskell APIs don't expose async versions like that
21:21:28 <min> yulys: However - you might want to review Haskell's type system, including type classes, before reading about the I/O. For instance, Num is a type class, not a type, and "do { b / a * c}" is not a well-typed expression.
21:21:30 <kmc> the assumption is that if you want something done asynchronously, you will make a thread
21:21:43 <kmc> (in Haskell, threads are actually a reasonable way to solve problems)
21:21:55 <kmc> if you want the IO (IO a) you'd just use the sync version with 'spawn' or something
21:23:27 <kmc> yulys, this intro is much more often linked:  http://www.haskell.org/haskellwiki/Introduction_to_IO
21:23:56 <kmc> the one min linked uses the word "monad" 11 times in the first five paragraphs
21:24:04 <kmc> you really do not need to understand monads just to do IO
21:24:13 <yulys> kmc: let me see kmc
21:25:03 <yulys> because my first idea was    let
21:25:05 <yulys>         a = 8
21:25:07 <yulys>         b = 3
21:25:09 <yulys>         c = 15
21:25:10 <kmc> don't paste code here
21:25:11 <yulys>       in (b / a * c)
21:25:11 <kmc> use hpaste.org
21:25:20 <yulys> ok
21:27:09 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes‚Äù at http://hpaste.org/53528
21:27:11 <napping> yulys: that looks fine too, except you need something like print to print the expression
21:27:32 <yulys> napping: http://hpaste.org/53528
21:27:59 <yulys> napping: I putted return
21:28:09 <napping> main shouldn't return anything but ()
21:28:19 <napping> if you want to see the number you should put print instead
21:28:26 <napping> (print already returns (), so that's fine)
21:29:54 <kmc> print returns IO (), which is an IO action that produces ()
21:31:10 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes2‚Äù at http://hpaste.org/53529
21:31:17 <shachaf> Is there a word for the the relationship of f to b in "f :: a -> IO b"?
21:31:29 <shachaf> Presumably you say "f returns IO b".
21:31:46 <napping> terminology gets tricky
21:31:53 <napping> maybe mumble something about Kleisli
21:32:04 <shachaf> Though the word returns is abused in a few ways anyway; for instance, it's probably more accurate, in f :: Int -> Int, to say that f x *is* an Int, not that it returns an Int.
21:32:05 <napping> and call it a to b
21:32:31 <shachaf> napping: I'm looking for a correct word for casual IRC use here. :-)
21:32:54 <shachaf> (Which should generalize to any m, hopefully?)
21:33:13 <napping> a to IO b should be fine
21:33:30 <napping> thinking of it as a function from a to (IO b) or an "IO function" from a to b as you like
21:33:46 <shachaf> I guess...
21:33:55 <napping> IO b is short enough you don't need to try to abbreviate it
21:34:06 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes3‚Äù at http://hpaste.org/53530
21:34:15 <shachaf> f :: a -> IO (Maybe b) is an IO:.Maybe function from a to b. :-)
21:34:29 <kmc> i think these "IO functions" are suspect as an analogy
21:34:46 <napping> analogy?
21:34:52 <kmc> yes
21:34:54 <kmc> and yes (f x) certainly is an Int, not "returns an int"
21:35:04 <kmc> but f returns an Int there
21:35:12 <kmc> though then you have to be careful about currying
21:35:32 <shachaf> Right -- f :: Int -> Char -> Bool "returns a Bool" by common usage.
21:35:36 <byorgey> you can make "IO function" precise, not just an analogy, by defining an "m function" (for Monad m) to be an arrow in the Kleisli category for m
21:35:41 <shachaf> (And also "returns a (Char -> Bool)".)
21:35:47 <napping> byorgey unmumbles
21:35:54 <kmc> that makes it a precise analogy :)
21:36:19 <kmc> anyway that's fine as long as all you do with these "IO functions" is compose them in the Kleisli IO category
21:36:19 <shachaf> kmc: I wasn't suggesting it as an analogy so much as a convenient shorthand for people who more or less understand how IO works.
21:36:35 <kmc> but not if you do other things with them, such as applying them
21:36:57 * byorgey will call such functions "IOish"
21:37:15 <GutenTag> I'm trying to write a function that takes a list of integers (at least 2) and returns the minimum sum of each integer.  So, if my list was [1, 3, 5, 2, 7, 1, 2], I would return 3.
21:37:19 <byorgey> which is pronounced like "ee-oish"
21:37:45 <shachaf> GutenTag: Minimum sum of each integer?
21:38:03 <GutenTag> (and I would have compared 4, 8, 7, 9, 8, and 3 to find that minimum)
21:38:12 <shachaf> data Null a = Null allows one to talk about the terribly-useflu Nullish functions. :-)
21:38:13 <napping> sum of pairs, perhaps?
21:38:17 <byorgey> oh, the minimum sum of any two consecutive integer?
21:38:20 <shachaf> Oh, I see.
21:38:20 <byorgey> *integers
21:38:22 <GutenTag> yes, sum of pairs
21:38:39 <kmc> > let f xs = zipWith (+) xs (tail xs) in f [1, 3, 5, 2, 7, 1, 2]
21:38:40 <lambdabot>   [4,8,7,9,8,3]
21:38:41 <byorgey> GutenTag: zipWith and tail are your friends
21:38:45 <Sgeo|web> kmc: but the first asynchronous function is the function actually exposed in C
21:38:50 <mzero> GutenTag: is this an assignment -- or another way of asking: do you want a solution, or help understanding how to find one?
21:39:03 <Sgeo|web> (Well, the Haskell approximation, dealing with pointer nonsense etc)
21:39:06 <kmc> Sgeo|web, ok, so the question is how you go from the first to the second
21:39:08 <shachaf> > minimum . (zipWith (+) <*> tail) $ [1, 3, 5, 2, 7, 1, 2]
21:39:09 <mzero> nevermind, then.... there you have one
21:39:09 <lambdabot>   3
21:39:14 <Sgeo|web> kmc: yes
21:39:21 <GutenTag> mzero: I'm actually studying for an exam.  So while it is academic (obviously) it's not for a grade.
21:39:50 <shachaf> GutenTag: If you're having trouble with the function, you could probably start by writing it as explicit recursion.
21:39:51 <mzero> in that case - look at kmc's solution first --- and the later, after the exam, consider shachaf's
21:40:03 <Sgeo|web> kmc: Would I use Cont or ContT, or would I do locky stuff?
21:40:05 <GutenTag> yes, I think that's good advice mzero :)
21:40:08 <Sgeo|web> Thready, locky stuff
21:40:30 <Sgeo|web> And there's a reason I might want to have it be in MonadIO rather than IO
21:40:37 <kmc> Sgeo|web, I'm still confused by the type of worldAttributeGet
21:40:45 <kmc> it returns (IO a)
21:40:58 <kmc> that IO action doesn't complete until the callback is finished?
21:41:13 <GutenTag> ok, so I see kmc returns a list, how would I then pass it to the minimum function?  I apologize for such basic questions: This was in a course I had last semester, but since I fractured a rib I took an Incomplete.  I have to make up this test and I missed the lectures on Haskell.
21:41:22 <Sgeo|web> kmc: I guess it should be IO ()
21:41:37 <kmc> Sgeo|web, so the callback runs some indeterminate time, perhaps after that (IO ()) has finished
21:41:45 <Sgeo|web> kmc: yes
21:41:56 <shachaf> GutenTag: You might want to read a guide on Haskell and on how functions work, then. :-)
21:41:56 <byorgey> GutenTag: to pass an argument to a function you just put the argument to the right of the function, like  fun arg
21:42:09 <shachaf> To pass a thing to a function you just -- what byorgey said.
21:42:11 <byorgey> GutenTag: you may need parentheses around the argument if it is a compound expression
21:42:20 <byorgey> fun (some stuff [4,5,6] blah)
21:42:20 <shachaf> Sometimes you need parentheses.
21:42:22 <GutenTag> shachaf: I think I would like to know how i might do it with explicit recursion.  I'm a Java developer, so this syntax ...well, it screws with me to say the least, LoL.
21:42:31 <GutenTag> I see byorgey.
21:42:40 <shachaf> GutenTag: It's probably not just the syntax. :-)
21:43:00 <kmc> Sgeo|web, something like:  worldAttributeGetSync attr = do { v <- newEmptyMVar; worldAttributeGet attr (putMVar v); takeMVar v }
21:43:20 <Sgeo|web> kmc: ooh, cool
21:43:25 <kmc> Sgeo|web, now, what extra threading constraints do you have from the C library?
21:43:53 * hackagebot uri-enumerator 0.1.0 - Read and write URIs  http://hackage.haskell.org/package/uri-enumerator-0.1.0 (MichaelSnoyman)
21:43:55 * hackagebot uri-enumerator-file 0.1.0 - uri-enumerator backend for the file scheme  http://hackage.haskell.org/package/uri-enumerator-file-0.1.0 (MichaelSnoyman)
21:43:57 * hackagebot xml-enumerator 0.4.3.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.3.1 (MichaelSnoyman)
21:44:01 <Sgeo|web> kmc: I think it comes down to "don't"
21:44:13 <kmc> not helpful
21:44:21 <Sgeo|web> Some functions don't take arguments "normally"
21:44:34 <Sgeo|web> Instead, you call another function, setting global variables in the library with the values you want
21:44:36 <kmc> don't enter the library concurrently?  or don't enter it concurrently *and* always enter it from the same OS thread?
21:44:36 <Sgeo|web> Then call the function
21:44:38 <kmc> sigh
21:44:42 <shachaf> @ty \async attr -> do { v <- newEmptyMVar; async attr (putMVar v); takeMVar v }
21:44:42 <lambdabot> Not in scope: `newEmptyMVar'
21:44:42 <lambdabot> Not in scope: `putMVar'
21:44:43 <lambdabot> Not in scope: `takeMVar'
21:44:43 <Sgeo|web> kmc: the former
21:44:50 <Sgeo|web> I ... think
21:45:10 <kmc> ok
21:45:23 <kmc> then you do need global state of some kind
21:45:30 <GutenTag> ok, this works:  minimum (let f xs = zipWith (+) xs (tail xs) in f [1, 3, 5, 2, 7, 1, 2])
21:45:47 <kmc> Sgeo|web, a lock, or a single thread which handles all the calls
21:46:10 <kmc> I'd probably go with the lock
21:46:28 <kmc> the latter is useful if your C library also uses thread-local state, and so the Haskell thread must be a bound thread
21:46:29 <shachaf> Hah, you really put minimum around the whole thing. :-)
21:46:30 <GutenTag> But, I would like to work on a recursive solution, too.  I believe that is probably what was taught in the class.  I'm not sure we even covered zipWith.
21:46:47 <GutenTag> shachaf: I did, should I have done something else? LoL
21:47:32 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes4‚Äù at http://hpaste.org/53531
21:47:38 <kmc> Sgeo|web, if you're using a custom monad, you can pass that lock through
21:47:44 <Sgeo|web> kmc: there's also the issue of being unable to write getNearbyAvatars :: IO [Avatar] like I might want because there's no such function in the API I'm wrapping. Instead, just functions to detect when an avatar gets close or leaves. But I guess that's what IO-stored state is for?
21:47:49 <Sgeo|web> Instead of using a State monad
21:48:00 <kmc> maybe
21:48:12 <kmc> this sounds like an awful C library you're wrapping
21:48:33 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes4‚Äù at http://hpaste.org/53532
21:48:59 * hackagebot xml2html 0.0.2 - blaze-html instances for xml-enumerator types  http://hackage.haskell.org/package/xml2html-0.0.2 (MichaelSnoyman)
21:49:01 * hackagebot xml-catalog 0.3.0.1 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.3.0.1 (MichaelSnoyman)
21:49:09 <Sgeo|web> kmc: http://wiki.activeworlds.com/index.php?title=SDK_Sample_Program_1
21:50:18 <kmc> so let me summarize: threading in C sucks, therefore C programmers are now expected to turn their code inside out in event-based style, therefore the libraries are impossible to use from languages where threading doesn't suck
21:51:25 <Sgeo|web> Well, some of these things fundamentally _are_ events
21:51:36 <shachaf> kmc: A reasonably-written event-based library in C isn't that hard to convert to thread use in Haskell, is it?
21:51:39 <Sgeo|web> And not just callbacks
21:52:17 <shachaf> kmc: What interface would you prefer that they expose?
21:52:29 <kirindave> kmc: Would it be better if these libraries bound tightly to pthreads?
21:52:47 <Sgeo|web> I think it's just this SDK that sucks >>>
21:52:48 <kmc> I'm not saying I have a better solution.
21:52:50 <Sgeo|web> *>.>
21:52:56 <kirindave> hah
21:53:01 <kirindave> kmc: Let it all out ,my friend. :)
21:53:04 <Sgeo|web> See aw_int?
21:53:39 <kmc> just pointing out that shit threading + mutable state everywhere has left a legacy of shit which we will be stuck with for a long time
21:53:43 <shachaf> Events aren't all that unreasonable an FFI-ish low-level interface to expose.
21:53:48 <Sgeo|web> Sorry, aw_int_set
21:54:22 <kmc> if threading in C were more reasonable, then libraries with global state everywhere would be less acceptable
21:54:58 <kirindave> kmc: That might be true.
21:55:02 <shachaf> kmc: C doesn't have threads. :-)
21:55:26 <gentleben> kmc: it actually has its origins that are 20 years old, early java has some of the same problems
21:55:29 <kirindave> kmc: Laundry-list programming would probably be prevalent either way. It's just how most people are predisposed to think.
21:55:43 <kmc> i'm not familiar with that term
21:56:07 <kirindave> kmc: loosely ordered lists of tasks with shared state.
21:56:09 <kmc> so this activeworlds API only supports one connection per program?
21:56:26 <kmc> that seems like a problem, even ignoring threads
21:56:45 <napping> shachaf: one thing that might be nice is to expose enough that you could call epoll outside the library
21:56:54 <Sgeo|web> One connection to the universe, multiple bots possible sharing that connection
21:56:55 <Sgeo|web> I think
21:57:11 <shachaf> napping: ?
21:57:17 <Sgeo|web> Wait, no
21:57:21 <kmc> Sgeo|web, well, maybe there's a separate API for that, but here it looks like "set my X position" is global state
21:57:23 <napping> shachaf: for event-based libraries
21:57:37 <napping> shachaf: then you could spill it open and just have GHC wait on everything
21:57:45 <shachaf> napping: Well, I didn't say anything about how you expose the events.
21:57:49 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútypes5‚Äù at http://hpaste.org/53533
21:57:52 <shachaf> Anyway, epoll isn't part of C either. :-)
21:57:58 <Sgeo|web> kmc: That X position is only relevent when an event handler is called or when calling something that sets the position within the world
21:58:11 <kmc> yeah, how are you supposed to use this library with, say, GTK?
21:58:27 <kmc> they both have a world-consuming event loop
21:58:31 <Sgeo|web> Oh, and there's a function for switching between connections
21:58:42 <napping> who is pasting things?
21:58:47 <Sgeo|web> So you switch to one, then do stuff, then switch to the other, etc
21:58:58 <kmc> ughhhh
21:59:03 <GutenTag> let sumPairs(x:y:z) = x + y : sumPairs(y:z) in sumPairs[1, 3, 5, 7] // this begins to build the list I'm looking for, but then gives a patter match failure.  I'm guessing that as soon as I don't have 3 elements in my list, I'm screwed.  I'm not sure how to fix it.
21:59:14 <napping> yulys: are you pasting things as ‚ÄúJulita Inca‚Äù?
21:59:18 <GutenTag> *pattern match failure
21:59:28 <yulys> napping : yes
21:59:29 <shachaf> GutenTag: Give multiple definitions for each thing sumPairs should be called on.
21:59:45 <shachaf> For instance: let f [] = "this"; f (x:y) = "that"
21:59:51 <kmc> let sumPairs [] = []; sumPairs [x] = []; sumPairs (x:y:z) = ...
22:00:02 <GutenTag> Oh.
22:00:06 <GutenTag> like "base cases"
22:00:42 <yulys> I know this is a very simple basic case, but I still have probems
22:00:47 <napping> yulys: Had trouble mapping things back. It looks like you might want to find a good tutorial
22:01:23 <shachaf> GutenTag: That's what it's called, yes.
22:01:31 <napping> chapter 2 of http://learnyouahaskell.com/ seems about right for getting that sort of example
22:01:36 <yulys> the problem is the division, is it OK if I define Int -> Int -> Int -> Float ?
22:01:43 <yulys> ok
22:02:36 <Sgeo|web> The library _does_ have synchronousn functions for some stuff
22:02:48 <napping> no, it's more basic syntax, like the definition line for main needs something after the =, and you probably shouldn't have the f left of the = in tipos at all
22:02:52 <yulys> I have no problem with terminal... it works by terminal... I just want to do it with file and compiling
22:02:53 <Sgeo|web> (Well, they're just what happens when you do a call to a function that has both, and don't give an event handler)
22:03:09 <Sgeo|web> But those call the same function that you call in the event loop
22:03:18 <Sgeo|web> And I feel like using those would just lead to headaches
22:03:45 <kmc> how complicated is the wire protocol for this AW thing
22:04:13 <Sgeo|web> kmc: I don't think people are supposed to look at it
22:04:43 <Sgeo|web> Which isn't to say that people haven't, but
22:05:00 <Sgeo|web> Connections using this SDK are treated differently by the universe than connections via the AW client
22:05:21 <kmc> okay, anyway, I will stop complaining about the library
22:05:32 <kmc> I would pass through a global lock inside the state for your custom monad
22:05:42 <kmc> and make sure you set all of the C library's global state on every operation
22:05:45 <Sgeo|web> Is a custom monad necessary?
22:06:12 <kmc> where are you going to store the lock otherwise?
22:06:18 <Sgeo|web> In IO?
22:06:21 <kmc> where
22:06:45 <Sgeo|web> Hmm, I guess I should use a Reader monad?
22:06:53 <kmc> yeah
22:06:59 <shachaf> kmc: global-variables, of course. :-)
22:07:17 <Sgeo|web> kmc: someone's pinging you in another channel I'm in
22:07:31 <shachaf> Sgeo|web: kmc is in that channel also.
22:07:39 <shachaf> Is unsafePerformIO really broken in GHC 7.0?
22:07:43 <Sgeo|web> I'm aware, but he hasn't said anything
22:07:58 <kmc> in the simplest case you'd have newtype M a = MkM { runM :: ReaderT (MVar ()) IO a }
22:08:35 <kirindave> shachaf, that top-level binding problem?
22:08:38 <kmc> and then your externally visible "run" function allocates a MVar () and calls runM
22:08:42 <GutenTag> This always returns [] :  let sumPairs [] = []; sumPairs(x:y) = []; sumPairs(x:y:z) = x + y : sumPairs(y:z) in sumPairs[1, 3, 5, 7]
22:08:55 <shachaf> kirindave: ?
22:08:56 <kmc> of course calling that externally visible "run" function from multiple threads will be disaster
22:09:09 <GutenTag> I am thinking I need to do something different for sumPairs(x:y) = [].  I tried different thing, but kept getting syntax errors.
22:09:16 <Sgeo|web> What about my getNearbyAvatars function? THat needs its own state, should I store that state in IO?
22:09:25 <kmc> and this is probably useless anyway, because you can't forkIO inside M (unless you provide a construct for that)
22:09:25 <shachaf> GutenTag: sumPair (x:y) matches any list.
22:09:29 <shachaf> Non-empty list, rather.
22:09:36 <kmc> so you're still limited to single-threaded use of the library, and that's still not enforced
22:09:43 <kmc> anyway
22:09:43 <shachaf> You want (x:[]), or [x].
22:09:44 <GutenTag> shachaf: That's what I was thinking, so it "overrides" what I'm trying to do with (x:y:z)
22:09:52 <GutenTag> oh
22:09:54 <kmc> I've come to the conclusion that newtype wrapping IO is a pain in the ass
22:10:02 <kirindave> shachaf, was reading an article about how unsafePerformIO was broken in top level bindings in GHC 7.* when using -threaded
22:10:04 <kirindave> Jut the other day.
22:10:04 <kmc> especially if you need to support callbacks, exception handling, etc
22:10:17 <kmc> yes, you cannot use unsafePerformIO to do this, because of http://hackage.haskell.org/trac/ghc/ticket/5558
22:10:21 <shachaf> kmc: Well, it's not just top-level.
22:10:26 <kmc> yes it is
22:10:29 <shachaf> s/mc/irindave/
22:10:31 <shachaf> It is?
22:10:36 <kmc> yes
22:10:42 <kmc> the problem has to do with the way CAFs are blackholed
22:10:48 <kmc> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
22:10:49 <shachaf> Oh.
22:10:55 <kirindave> ^ amazing article btw
22:10:59 <kmc> thanks
22:11:03 <Sgeo|web> I can't forkIO if I'm using ReaderT?
22:11:06 <Sgeo|web> Beh, why?
22:11:14 <GutenTag> that worked perfectly, shachaf, thanks. :)
22:11:14 <kmc> look at the type of forkIO
22:11:24 <Sgeo|web> :t forkIO
22:11:26 <lambdabot> Not in scope: `forkIO'
22:11:34 <kmc> IO a -> IO ThreadId
22:11:41 <kmc> IO ‚â† ReaderT r IO
22:11:55 <kmc> in this case you can write the appropriate wrapper
22:12:14 <kmc> it doesn't work so well for all monad transformers
22:12:39 <kmc> Sgeo|web, you might want to look at http://hackage.haskell.org/package/monad-control
22:13:11 <DukeDave> Is the a nicer way to apply a function to both 'sides' of a (a,a) pair?
22:13:18 <kirindave> Wait, does it matter, kmc?
22:13:27 <shachaf> @ty join (***)
22:13:28 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:13:28 <DukeDave> Rather than (\f (x,y) -> (f x, f y))
22:13:33 <kmc> :t \f -> f &&& f
22:13:34 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
22:13:40 <shachaf> > join (***) succ (5,3)
22:13:41 <lambdabot>   (6,4)
22:13:43 <kmc> :t join (&&&)
22:13:44 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
22:13:48 <DukeDave> Oh no, this is arrows, isn't it
22:13:48 <kirindave> you can liftIO out of most of the standard transformers, so...
22:13:50 <kmc> hmm (***) is right
22:13:51 <shachaf> "nicer" is arguable.
22:13:54 <kmc> kirindave, wrong direction
22:14:00 <kirindave> oh.
22:14:06 <kmc> try to write forkIO for arbitrary MonadIO
22:14:32 <shachaf> Monad transformers are evil.
22:14:34 <kirindave> I just took nyquil. I suspect the result of such an attempt would be humorous.
22:14:40 <kmc> if you write a reasonable forkIO for ContT IO, you should publish it
22:14:44 <kirindave> shachaf, monad zippers will save us. Unless we need IO.
22:15:01 <shachaf> Presumably callbacks in any other monad have the same problem?
22:15:01 <kmc> -anyway- Sgeo|web, the best solution I have for a truly global lock is https://github.com/kmcallister/global-lock
22:15:29 <kmc> in which we store the MVar in a C global variable
22:17:22 <DukeDave> > succ ^<< (5,3)
22:17:23 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
22:17:23 <lambdabot>    arising from a use of `Control...
22:17:33 <DukeDave> Aw :(
22:20:34 <o-_-o> I have something like this map (\x i -> x * exp  (2 * pi)) xs, now x is the element in xs and i is it's index. Is there anyway to do this ?
22:20:46 <o-_-o> er..
22:20:56 <kmc> :t \f -> zipWith f [0..]
22:20:57 <lambdabot> forall a b c. (Num a, Enum a) => (a -> b -> c) -> [b] -> [c]
22:21:25 <o-_-o> kmc, yes I am doing something like that
22:22:06 <o-_-o> map (\i -> (xs!i) * exp ( 2 * pi * (fromIntegral i)))
22:22:21 <kmc> on an Array?
22:22:24 <o-_-o> But that seems so imperative :-)
22:22:28 <o-_-o> Yes on Data.Vector
22:22:34 <kmc> it's not imperative
22:22:45 <kmc> imperative = sequence of steps to perform, with effects
22:23:09 <kmc> if it makes you feel better, partially apply (xs !), now it's just a function Int -> WhateverElementType
22:23:31 <o-_-o> sorry forgot to complete it, map (\x i -> x * exp  (2 * pi)) enumFromTo 0 ((length xs) - 1)
22:23:49 <o-_-o> That is a direct translation of the Algorithm's for loop.
22:24:00 <o-_-o> kmc, ah
22:24:06 <kmc> it's not a direct translation because you aren't setting any mutable state
22:24:16 <o-_-o> kmc, ah...
22:24:16 <kmc> anyway I wonder if you should convert the vector to a list
22:25:05 <o-_-o> kmc, I want to make it Vector.Unboxed later...for performance.
22:25:15 <kmc> can't you convert that to a list too?
22:25:33 <MostAwesomeDude> Hm. If I'm using Attoparsec, and I want to yield a bunch of results from it in an infinite list, would it be valid to kickstart the parser with an empty string?
22:25:39 <MostAwesomeDude> So that it goes into Partial mode and stays there?
22:25:41 <kmc> i don't mean permanently convert, I mean as part of this function
22:25:50 <o-_-o> kmc, But lists take more space and perform slower, no ?
22:25:55 <o-_-o> kmc, ah
22:26:01 <copumpkin> o-_-o: you can do that just by zipping the index with the vector
22:26:02 <shachaf> MostAwesomeDude: What's the point of using a parser on an empty string?
22:26:38 <kmc> o-_-o, convert vector to list vs. generate list of indices and index the vector for each
22:26:47 <kmc> i don't expect the latter to be faster
22:26:51 <copumpkin> indexed :: Unbox a => Vector a -> Vector (Int, a)
22:26:51 <o-_-o> copumpkin, Yes, thank you.
22:26:54 <kmc> you'll have to try them both and see
22:27:11 <o-_-o> kmc, ah...ok
22:27:21 <kmc> either way you are generating a list of the same length
22:27:32 <kmc> either way 'map' might fuse with the generation of that list
22:27:35 <kmc> but the output is a list anyway
22:27:50 <o-_-o> Trying to do FFT, my first implementation in Haskell was incredibly slow..
22:28:01 <o-_-o> So Second try.
22:28:32 <MostAwesomeDude> shachaf: I want to constantly stream bytes off of a network, and yield parsed packets from that stream. Then, I want to take action according to that stream of packets, one packet at a time, and occasionally send things back at the networkk.
22:28:36 <MostAwesomeDude> *network, even.
22:28:40 <o-_-o> kmc, copumpkin: Thanks for all the help.
23:02:03 <hpaste> ‚ÄúJulita Inca‚Äù pasted ‚Äútype‚Äù at http://hpaste.org/53535
23:02:12 <yulys> guys! I finally got a helpful help from Ivan Lazar Miljenovic n.n it was so simple...http://hpaste.org/53535
23:02:20 <yulys> good night! :)
23:08:40 <huangyi> GC time: 10%, compare to average, is it good or bad?
23:09:24 <Axman6> not great, could be a lot worse
23:10:41 <huangyi> thanks ;-)
23:18:36 <kmc> under 50% is pretty good for Haskell code ;)
23:20:04 <gentleben> if you are running 50% gc something has gone wrong
23:20:49 <kmc> do you speak from experience with Haskell in particular?
23:21:21 <kmc> thing is, time spent in GC ‚â† overhead versus manual memory management
23:21:45 <gentleben> i do
23:21:48 <kmc> allocation in GHC code is very very cheap compared to malloc; garbage collection is where you pay for it
23:22:14 <gentleben> i have spent some time gc tuning
23:22:29 <gentleben> its not nearly as easy as .net or javas
23:22:32 <gentleben> but its doable
23:22:51 <kmc> i've also seen programs where tuning to decrease GC time from 90% to 10% also increased the total run time
23:23:05 <kmc> i should learn more about GC tuning in GHC... what are some good approaches?
23:23:15 <gentleben> that doesn't make sense
23:23:39 <gentleben> often is about adding strictness
23:23:51 <gentleben> getting rid of peoples stupid monads
23:24:17 <gentleben> spending lots of time in the profiler
23:24:27 <kmc> garbage collection can improve locality
23:24:43 <gentleben> and even then there are problems with things like ByteString having no cost center for some allocations
23:25:07 <gentleben> locality of what?
23:25:11 <kmc> memory access
23:25:34 <kmc> this is anyway my speculation as to why increasing the alloc area size could increase total runtime
23:25:35 <gentleben> yeah, especially compacting collectors
23:27:21 <Eduard_Munteanu> GC or allocating from special pools?
23:27:51 <gentleben> i would be interested in a PGO optimized collector
23:28:28 <gentleben> the extra stats should enable it to make better moves
23:28:54 <kmc> *nod*
23:29:16 <kmc> i also really want capability-local garbage collection
23:29:17 <Eduard_Munteanu> I guess a GC using the system allocator (malloc) wouldn't improve locality.
23:29:38 <kmc> there is a GHC branch for it, but I don't think it's merged for 7.4
23:30:10 <gentleben> post nahalem its not as big a perf boost as there is lower men latency
23:30:18 <gentleben> but still important
23:32:11 <kmc> Eduard_Munteanu, I don't follow
23:32:29 <Eduard_Munteanu> Well, the easiest way to improve GC time in some cases is to increase minimum heap size, which may or may not help asymptotically.
23:33:39 <theos> o/
23:33:45 <gentleben> actually using 3 gens instead of 2 can be awesome depending on object lifetime
23:34:06 <Eduard_Munteanu> theos: hi
23:34:15 <theos> :)
23:34:35 <Eduard_Munteanu> kmc: I think locality depends on how you lay out data in memory, rather than automatic vs manual management.
23:35:33 <kmc> mightn't the style of memory management have some effect on how data is laid out in memory?
23:35:53 <gentleben> less that you would think
23:36:13 <Eduard_Munteanu> You can use smarter strategies to allocate memory even when doing it manually, like slab allocators in e.g. Linux.
23:36:26 <kmc> yes
23:36:29 <gentleben> all you are really trying to do is help the prefetcher
23:37:02 <kmc> and the caches?
23:37:22 <gentleben> be definition
23:37:25 <gentleben> *by
23:37:39 <gentleben> as thats what the hardware prefetcher does
23:37:57 <gentleben> tries to fill the cache with what is needed next
23:39:17 <kmc> Eduard_Munteanu, what you've said is "i think locality depends on locality, and not on things which affect locality"
23:39:35 <kmc> you can't refute my claim that GC can help by providing examples of other things which also help
23:40:04 <gentleben> kmc: just because gc's can help doesn't mean they do
23:40:20 <kmc> obviously
23:40:28 <companion_cube> a GC will compact the heap, won'tit?
23:40:39 <kmc> are there other explanations for the phenomenon i observed?
23:40:41 <gentleben> more effective is aligning data structures to cache line size
23:40:57 <kmc> mm
23:41:08 <kmc> is there any cache line alignment in ByteString?
23:41:24 <gentleben> sure, if you do it
23:41:40 <kmc> i know a lazy BS chunk is supposed to be the size of L2 cache
23:41:46 <kmc> but i don't think they're aligned
23:41:57 <kmc> gentleben, how can you do it, other than by working with the internals of bytestring directly
23:42:19 <gentleben> you don't normally need to think to much about it
23:42:45 <gentleben> it will pull cache line sizes from memory
23:42:50 <Eduard_Munteanu> kmc: oh, I thought you were comparing GC against worst case manual memory management, that is, just using the system allocator for every allocation.
23:43:11 <kmc> Eduard_Munteanu, i was
23:43:21 <kmc> i was comparing the default practice in Haskell with the default practice in C
23:43:22 <Eduard_Munteanu> But that's not fair :)
23:43:27 <kmc> seems fair to me
23:43:28 <Eduard_Munteanu> Ah.
23:43:34 <kmc> by "system allocator" you mean malloc?
23:43:43 <Eduard_Munteanu> Yeah.
23:43:50 <kmc> malloc is just a library function, you can tweak its behavior or swap in new ones easily
23:43:57 <gentleben> kmc: swapping the allocator can be a trivial change
23:44:17 <Eduard_Munteanu> I agree in many cases you don't use an alternate allocator.
23:44:18 <gentleben> i have seen a swapped allocation work wonders
23:44:37 <gentleben> tcmalloc especially in server side apps
23:45:08 <kmc> Eduard_Munteanu, but no matter how fancy your malloc implementation is, it can't move live objects to put them closer together
23:45:40 <kmc> because malloc doesn't know where you've stashed away all those pointers
23:45:42 <kmc> it can't change them
23:45:42 <gentleben> kmc: that can be expensive as well
23:45:48 <Eduard_Munteanu> Yeah.
23:45:53 <kmc> whereas exact garbage collectors have to know that
23:46:10 <kmc> so it's really the property of tracking pointers, and not garbage collection per se, that makes dynamically optimizing object layout possible
23:46:15 <Eduard_Munteanu> It can only influence fragmentation wrt future allocations.
23:47:16 <Eduard_Munteanu> Yes, I guess if you used a GC in C without a complete overhaul of the language it still wouldn't make that kind of optimization possible.
23:47:18 <kmc> gentleben, I agree with you that none of these schemes are foolproof, they all have costs, and that it's hard to estimate the costs without trying it
23:47:35 <gentleben> the only way is to profile it
23:47:50 <kmc> Eduard_Munteanu, *nod* like boehm GC
23:48:19 <Eduard_Munteanu> BoehmGC is pretty bad AFAIH, though I'm not sure how the competition fares.
23:54:25 <Eduard_Munteanu> But I wonder if compacting GCs don't rely on compaction to keep fragmentation at bay, rather than as an optimization vs the "least fragmentation by construction" case.
23:56:12 <Eduard_Munteanu> IOW, vs something like a slab allocator which can't rely on compaction so it has to keep things in order at every step.
23:56:37 <gentleben> different strategies
23:57:04 <Eduard_Munteanu> (just like collection frees memory up once in a while rather than immediately following release)
23:57:23 <gentleben> sometimes it doesn't matter
23:58:32 <companion_cube> the problem is only for long living processes
23:58:54 <companion_cube> or processes which allocate at high rate, which i don't think is frequent in C
23:59:12 <gentleben> many c apps are like that
