00:00:03 <marvinalone> shachaf: i could have some weird implementation of Eq, for example
00:00:42 <shachaf> Well, that's not necessarily bad.
00:01:21 <shachaf> You can always say foo x y | x == y = ...
00:04:33 * hackagebot msgpack 0.6.2 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.2 (HideyukiTanaka)
00:05:26 <marvinalone> shachaf: ohh, very sexy. i wish that'd come up when i google for "haskell pattern matching"
00:08:04 <erus`> Is there a nice way to compile binary data into my executable file (and read it)? (nicer than writing out a huge literal byte array)
00:14:14 <frerich> erus`: There are probably easier solutions, but I once wrote a resource compiler for ELF systems (google for 'elfrc'). It can take arbitrary files and transform them directly to ELF object files, which you can then link into your final executable. For haskell, you'd only have to make the defined symbols accessible.
00:14:28 <frerich> erus`: I used this to embed some 60MB files into a statically linked installer.
00:14:58 <frerich> erus`: So *if* ELF-only is okay for now, you may want to try it.
00:15:56 <frerich> Hmm, seems my old homepage on ktown.kde.org was shut down after six years, but some other guy continued maintaining this project at https://github.com/yashi/elfrc
00:21:10 <mm_freak> erus`: another solution would be to link to an object file containing the data
00:21:10 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
00:21:20 <marvinalone> if i have a function that takes two arguments and a tuple that contains the arguments, is there a convenience function that applies the arguments to the function?
00:22:23 <shachaf> @ty uncurry
00:22:24 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:24:37 <marvinalone> thnak you!
00:25:32 <shachaf> @hoogle (a -> b -> c) -> (a,b) -> c
00:25:32 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
00:25:33 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
00:25:33 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
00:25:37 <shachaf> marvinalone: For future reference. :-)
00:26:47 <piccollo> is there a function to delete a whole list?
00:28:12 <frerich> piccollo: Since you cannot 'modify' lists but only return new ones, 'deleting' a list would be just 'deleteList _ = []' no? :-}
00:28:25 <chridi> hi
00:29:09 <chridi> how could i get a dimension of a tow dimensional array?  My idea was sth like:  map (arr !) $ zip [x,x..] [1,.. maxy]
00:29:19 <chridi> i mean a line
00:29:33 * hackagebot msgpack 0.6.3 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.3 (HideyukiTanaka)
00:43:40 <hebz0rl> can i tell ghci to do things step by step? like i have the function sumList (x:xs) = x + sumList xs and want to see what exactly happens (like i just give it a [1] then i would see that he just gives out x) i hope its clear what i mean
00:45:06 <shachaf> hebz0rl: ghci has a debugger, but I'm not sure how helpful it is for that sort of thing.
00:45:36 <hebz0rl> yeah i can do breakpoints by line but not by execution :/
00:46:19 <shachaf> hebz0rl: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi
00:46:29 <shachaf> hebz0rl: E.g. http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+sumList+%5B%5D+%3D+0%3B+sumList+%28x%3Axs%29+%3D+x+%2B+sumList+xs+in+sumList+%5B1%2C2%2C3%5D
00:47:01 <hebz0rl> nice thanks :D any chance i can do that directly in ghci?
00:47:12 <shachaf> hebz0rl: Note that that doesn't evaluate "real Haskell", just an untyped language with a similar syntax.
00:47:19 <hebz0rl> ok
00:47:34 <hebz0rl> this will help thank you
00:47:36 <shachaf> > let sumList [] = 0; sumList (x:xs) = x + sumList xs in sumList [a,b,c,d]
00:47:37 <lambdabot>   a + (b + (c + (d + 0)))
01:01:35 <shachaf> @ty maybe mzero return
01:01:36 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
01:01:40 <shachaf> @hoogle Maybe a -> m a
01:01:40 <lambdabot> Data.Monoid First :: Maybe a -> First a
01:01:41 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
01:01:41 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:07:40 <shachaf> If you have f x y = ... where !_ = x; !_ = y, is there any sort of guarantee on the order x and y would be evaluated?
01:07:55 <shachaf> I suppose the answer is "no" because there are never really guarantees like that.
01:12:41 <int-e> shachaf: it's not supposed to matter. But I guess you could try !_ = x `pseq` y
01:42:18 <alex404> So I'm trying to get rolling defining an arrow that I want to use as just a composition of transformers. I know that I want to combine the functionality of an Automaton with a Writer Arrow, and that theoretically I should be able to just apply the transformers to the (<-) Arrow, and I'm done. but I can't really wrap my head around how exactly to do that.
01:42:37 <alex404> I mean (->) Arrow, btw
02:08:31 <alex404> So I'm trying to get rolling defining an arrow that I want to use as just a composition of transformers. I know that I want to combine the functionality of an Automaton with a Writer Arrow, and that theoretically I should be able to just apply the transformers to the (->) Arrow, and I'm done. but I can't really wrap my head around how exactly to do that.
02:09:35 <mm_freak> alex404: Automaton (StateArrow s (->))
02:10:05 <mm_freak> where:  newtype Automaton (>~) a b = Auto (a >~ (b, Automaton a b))
02:10:25 <mm_freak> and: newtype StateArrow s (>~) a b = StateA ((a, s) >~ (b, s))
02:12:45 <alex404> mm_freak: Okay, I have understand what you're writing, but I'm still not really getting it. Let's say I want to make a type synonym 'type Circuit a b' where the rhs is a combination of writer and automaton. What would that look like?
03:15:50 <mm_freak> alex404: well, as said:  newtype Circuit = Auto (StateArrow MyState (->))
03:16:30 <mm_freak> assuming you want the automaton arrow to be at the highest level, which normally is the most convenient way
03:17:52 <mm_freak> you can also write a combination of the two yourself:  newtype Circuit (>~) a b = Circuit { stepCircuit :: (a, MyState) >~ ((b, MyState), Circuit (>~) a b) }
03:18:14 <mm_freak> if you really just want (->) at the base, then you can leave out the (>~) type variable
03:18:39 <mm_freak> you can also write a combination of the two yourself:  newtype Circuit a b = Circuit { stepCircuit :: a -> MyState -> (b, MyState, Circuit a b) }
03:19:04 <mm_freak> uhm, yeah, scratch the introducing sentence =)
03:20:02 <mm_freak> alex404: one further note:  you should use the underlying state arrow only for global state…  Automaton is a state arrow itself and is usually more powerful at that
03:20:10 <mm_freak> every automaton represents a computation with local state
03:25:39 <ddarius> newtype MAuto m (~>) a b = MAuto { unMAuto :: a ~> m (b, MAuto m (~>) a b) }
03:26:07 <ddarius> Though I guess this is just the Auto applied to KleisliT.
03:32:32 <mm_freak> i wonder why there is no KleisliT in the arrows package
03:33:30 <mm_freak> newtype KleisliT m (>~) a b = KleisliT { runKleisliT :: a >~ m b }
04:15:19 <hiptobecubic> OK
04:15:21 <hiptobecubic> So
04:16:49 <hiptobecubic> Monads are a 'Thing', possibly with some notions of a 'zero Thing' and an 'addition of two Things', for which we define a bunch of computations?
04:17:28 <opqdonut> Monoids are a 'Thing', possibly with some notions of a 'zero Thing' and an 'addition of two  Things'
04:17:48 <opqdonut> Monads are things that can be sequenced somehow (do this and feed the result into that)
04:18:04 <hiptobecubic> opqdonut, but monads can be monoids
04:18:17 <opqdonut> sure, disregard that
04:18:19 <hiptobecubic> and don't all monoids have the zeroThing and addThing ideas?
04:18:27 <opqdonut> yes, that's what I said
04:18:36 <hiptobecubic> you said possibly
04:18:41 <opqdonut> oh, sorry
04:18:53 <hiptobecubic> so what i said was right then
04:18:53 <opqdonut> s/possibly//
04:18:58 <hiptobecubic> assuming the monad is a monoid too i gguess
04:19:02 <opqdonut> (a Monad that is also a Monoid is a MonadPlus)
04:19:09 <hiptobecubic> So if the monad is in monadplus?
04:19:15 <hiptobecubic> yes ok. then i'm not totally lost
04:19:46 <opqdonut> my advice is, just learn how to use monads. your mind will come up with a suitable high-level understanding at some point
04:19:58 <opqdonut> start with Reader, State and Writer (and IO)
04:20:07 <hiptobecubic> i'm trying to learn how to use them, but it's difficult if you don't know what they do
04:20:34 <opqdonut> it's easy to know what a (single, concrete) Monad does
04:20:51 <opqdonut> Reader is for not having to pass a single common argument around
04:21:06 <opqdonut> State is for not having to thread a changing state value around
04:21:16 <hiptobecubic> how is that different
04:21:26 <opqdonut> subtly
04:21:34 <cheater> you don't mutate the reader.
04:21:46 <opqdonut> (except you do sometimes, but in a different way)
04:21:49 <opqdonut> you can pretty much do the same things with Reader and State
04:21:57 <opqdonut> but different things happen naturally with them
04:22:15 <opqdonut> Reader is for top-down (in the call tree) information flow
04:22:22 <opqdonut> State is for execution-order information flow
04:22:52 <hiptobecubic> hm
04:24:28 <ski> compare `f x config = let y = g x config; z = h x y config in i x y z config' with `f x state0 = let (y,state1) = g x state0; (z,state2) = h x y state1 in i x y z state2'
04:25:19 <ski> in the first example, `config' is an environment, which is passed down (and optionally changed in some places) -- this is essentially what `Reader' does
04:26:30 <ski> in the second example, `state0',`state1',`state2' is a state that is threaded through the calls, i.e. passed into a call, then the resulting state is output from that call, and passed into the next call -- this is essentially what `State' does
04:27:35 <opqdonut> the monad variants of those would be "f x = do y <- g x; z <- h x y; i x y z"
04:27:50 <opqdonut> (both of those)
05:02:35 <joesixpack> Hello. When you define a function using more than one pattern, but not with a case expression - just several different definitions of the function on different lines, what can I call each of those lines? in maths with a piecewise functions, I would call them the domains of the function, but that doesn't sound right for haskell?
05:03:44 <Axman6> imo, guards would be the haskell equivalent to a piecewise function. I think those are oftern called function alternatives... but they probably have a better name
05:09:35 <joesixpack> Axman6: function alternatives is probably right, sounds a bit clumsy though
05:10:47 <ski> joesixpack : i sometimes call them "defining equations" of the function, or "function (definition) clauses"
05:11:43 <ski> in short, i'd probably use "clause" or "equation"
05:12:07 <ski> (as in "there seems to be a problem in the last clause/equation of `foo' there ...")
05:19:27 <Botje> yes, 'clauses' is what i'd call them
05:19:45 <mreh> i'm sure I used functions with more than two arguments infix before
05:20:13 <mreh> GHC has a higher precedence for function app
05:20:21 <mreh> than infix function app
05:20:53 <ski>   infix 4 `elem`
05:23:45 <mreh> aw, I'd really like the focus of this combinator I'm using not to be the verb, but its first argument
05:23:59 <mreh> verb == its name
05:25:27 <ski> mreh : but you need three arguments ?
05:26:13 <mreh> ski: I need about 6
05:26:27 <mreh> uncurrying is undesirable
05:28:28 <ski> @let (!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]; (as !!<- i) f = front ++ f a : back where (front,a:back) = genericSplitAt i as
05:28:29 <lambdabot>  Defined.
05:28:41 <ski> > ([[],[0],[1,2],[3,4,5],[6,7,8,9]] !!<- 3) $ \as -> (as !!<- 1) $ \a -> a^2
05:28:43 <lambdabot>   [[],[0],[1,2],[3,16,5],[6,7,8,9]]
05:29:30 <ski> i.e., if your operator is `!!<-', you can do `(foo !!<- bar) baz quux zot mumble', for six arguments
05:30:06 <ski> this might or might not be nice, depending on what you are doing
05:30:59 <mreh> ski, it reads quite nicely
05:38:27 <applicative> @type (!!<-)
05:38:28 <lambdabot> forall a i. (Integral i) => [a] -> i -> (a -> a) -> [a]
05:39:41 <applicative> > let alter xs () i ()  = (xs !!<- i) ; at = () ; with = () in alter [[],[0],[1,2],[3,4,5],[6,7,8,9]] at 3 with (2:)
05:39:43 <lambdabot>   [[],[0],[1,2],[2,3,4,5],[6,7,8,9]]
05:47:08 <alex404> Can anyone look at this code snippet and tell me why I need to make this vacuous ArrowWriter instance declaration? If I don't include the declaration, I get an error saying I need to make a class instance. http://hpaste.org/54157
05:47:35 <alex404> Note: I don't know exactly what I'm doing
05:50:34 <geheimdienst> alex404: i don't know much about arrows, but maybe you have to import some extra module? when i get "missing instance" errors, it's often a reminder i forgot Control.Monad.Instances, for example
05:55:00 <alex404> geheimdienst: Yah, that's a good point. Maybe that's just it... it doesn't look like any instance is provided for what I need... but I still don't understand why I these (write = write, newWriter = newWriter) declarations should do anything.
05:56:48 <geheimdienst> sure, that instance looks silly
06:06:51 <joe9> wow, haskell has close to 838 nicks. that seems to be a lot higher than usual.
06:07:22 <hpc> clearly we have failed at avoiding success
06:07:47 <geheimdienst> joe9: i think it's been around 800 now for some weeks
06:08:15 <joe9> just noticed it when irssi kept scrolling for some time, when starting up.
06:09:25 <geheimdienst> hpc, i don't even know why that slogan irritates me so :) perhaps because "let's make a crappy language" would be a good strategy to "avoid success"
06:09:27 <joe9> good to have more here.. Was it a sudden jump?
06:10:12 <hpc> geheimdienst: except for the overwhelming evidence to the contrary ;)
06:11:03 <joe9> more than what the #c channel has. not a surprise as the #haskell is a lot more friendlier than the #c channel.
06:11:27 <gavino> why is haskell pattern matching nice?
06:13:40 <gwern> geheimdienst: you're not an admin so you can't
06:13:40 <lambdabot> gwern: You have 4 new messages. '/msg lambdabot @messages' to read them.
06:13:45 <gwern> @messages
06:13:46 <lambdabot> geheimdienst said 13d 19h 35m 58s ago: could you put hacboston on the haskell.org front page, events section? thanks -- [[Hac Boston]] January 20 to 22, 2012 in Cambridge, Massachusetts
06:13:46 <lambdabot> geheimdienst said 13d 19h 3m 36s ago: uh, never mind about HacBoston -- i figured out how to put it there :-) sorry for bothering you
06:13:46 <lambdabot> irene-knapp asked 13d 18h 45m 35s ago: I heard you were in charge of the Haskell wiki. Is it possible to change my username from DanKnapp to IreneKnapp? (It's already changed on Hackage, IRC, etc...)
06:13:46 <lambdabot> . If not, is it possible to delete the acccount altogether (I will then make a new one under the new name)? I don't want to leave breadcrumbs for random google-users to learn that I'm transsexual
06:13:46 <lambdabot> and my old name and identity.
06:13:48 <lambdabot> geheimdienst said 16m ago: on the wiki, how can i delete spammy new pages? i know how to revert an edit, but page deletion? i've been doing some work on the wiki lately, checking "recent changes"
06:13:49 <lambdabot> often, so i keep noticing spam. i'd be happy to help.
06:14:14 <hpc> gavino: instead of code like "if(isJust(m)) {print(fromJust(m));}", you have "case m of (Just x) -> print x"
06:14:15 <geheimdienst> gwern: oh dear, sorry ... (messages from 13 days ago!?)
06:14:19 <gwern> already dealt with knapp in email, IIRC. wonder why lambdabot didn't prompt me before
06:14:27 <hpc> gavino: it combines the "this is what it is" and "get what's inside" steps elegantly
06:14:37 --- mode: ChanServ set +o mauke
06:14:37 --- mode: mauke set +b *!*@gateway/web/freenode/ip.71.189.7.58
06:14:43 --- kick: gavino was kicked by mauke (ban evasion)
06:14:52 <hpc> o.O
06:15:13 <geheimdienst> mauke, did you just band the guy who asked about pattern matching?
06:15:14 <hpc> did i just take trollbait?
06:15:19 <geheimdienst> s/band/ban
06:15:33 --- mode: mauke set -o mauke
06:16:08 <mauke> yes
06:16:53 <geheimdienst> mauke: well, what's your reason?
06:16:59 <mauke> ...
06:17:02 <hpc> ban evasion
06:17:11 <hpc> note the kick message ;)
06:20:03 <hpc> wtf, why does lambdabot not PM messages?
06:20:46 <mauke> reciprocal
06:20:49 <Axman6> it tells you to ask for them in pm
06:22:12 <scooty-puff> anyone know a bit about type inference and unification?
06:22:15 <scooty-puff> i was looking at: http://ww2.cs.mu.oz.au/~sulzmann/courses/sem2004-1/cs6202/prog/hmx.lhs
06:22:27 <scooty-puff> and it seemed weird to me the implementation of "apply" for Constraint and TypeScheme
06:22:46 <scooty-puff> type variables are substituted, even if they may exist in the forall.
06:22:58 <geheimdienst> hpc, mauke: could you spell out the reason for me? i don't see kick messages in my client, i checked the logs, it says no more than "ban evasion". in the last 3 days, i can't find anything about that guy's ip, except the one join today
06:23:29 <Axman6> ips change
06:23:39 <mauke> geheimdienst: I refer you to at least $a:republican_devil $a:gavino *!*gschuet*@* $a:azathoth99
06:23:51 <mauke> @protontorpedo
06:23:51 <lambdabot> is it fun to program in haskell?
06:23:53 <mauke> and that
06:23:54 <Botje> oh, azathoth \o/
06:24:03 <mauke> @protontorpedo
06:24:04 <lambdabot> how do we automate ftp file transfers with haskell?
06:24:10 <scooty-puff> @protontorpedo
06:24:11 <lambdabot> paul graham said static typing and ML types fo lisp hurt exploratory progrmaming
06:24:18 <EvanR-wo1k> o_O
06:24:23 <mauke> <gavino> why is haskell pattern matching nice?
06:24:30 <mauke> I see a pattern
06:24:44 <scooty-puff> interesting..
06:25:25 <Axman6> who've you been spamming scooty-puff?
06:25:42 <marienz> sorry, that was idoru being a bit oversensitive
06:25:42 <geheimdienst> Axman6: i know ips change, but the ban did refer to the ip: mauke set +b *!*@gateway/web/freenode/ip.71.189.7.58
06:27:04 * Axman6 -> sleep
06:28:52 <geheimdienst> mauke: i can't find any references to "republican" or "azathoth" or "schuet" in the last days' logs either
06:29:01 <dmwit> Maybe #haskell-ops?
06:29:05 <mauke> geheimdienst: and?
06:29:11 <geheimdienst> mauke: i think "why is haskell pattern matching nice" is a normal beginner-level question. if that is all, i find your behavior casually kick-banning people with no warning much more damaging to the #haskell channel than a guy asking one question
06:29:16 <applicative> what is '@protontorpedo'
06:29:22 <geheimdienst> dmwit: fair enough
06:29:36 <mauke> geheimdienst: ban evasion is insta-kill
06:29:50 <mauke> doesn't matter what he's asking
06:29:59 <hpc> applicative: protontorpedo was a troll so trollish that he manage to upgrade himself from random @quotes to an entire command
06:30:10 <applicative> hah
06:30:18 <mux> geheimdienst: I find your behaviour even more disrupting to the channel right now; you assume mauke is lying & abusive based on channel logs covering a single day?
06:35:46 <geheimdienst> mux: i'm trying to understand mauke's reasoning (trying unsuccessfully so far), and i don't think i claimed he was lying, and i am looking at *several* days of logs (i have mentioned this 2x before)
06:36:07 <mux> geheimdienst: well then, try to understand it in private, thanks
06:36:09 <mauke> geheimdienst: days? try years
06:42:18 <cheater> mux: why are you shutting up geheimdienst? he's asking a valid question. telling people to "try to understand it in private" is divide & conquer, one simple way to carry out any arguments with multiple people without them knowing each other's arguments.
06:45:10 <Eliel> http://www.avaaz.org/en/save_the_internet/
06:45:14 <hpc> cheater: #haskell-ops
06:45:33 <cheater> hpc: oh ok
07:05:55 <EvanR-wo1k> can someone help me with this unix code
07:05:59 <EvanR-wo1k> http://codepad.org/Xf55rofZ
07:06:25 <EvanR-wo1k> the situation is, the script runs periodically and locks a semophore, then unlocks it before ending
07:06:52 <EvanR-wo1k> it very rarely segfaults, and id like to figure out why, but right now i want to know why this signal handler does not succeed in unlocking the lock
07:08:02 <EvanR-wo1k> am i not guaranteed that anything will work in a sigSEGV handler, or am i doing something wrong
07:15:14 <geheimdienst> EvanR-wo1k: does the signal handler run at all --  do you see the strings you printed?
07:15:41 <byorgey> preflex: seen shachaf
07:15:41 <preflex>  shachaf was last seen on #haskell 6 hours, 7 minutes and 55 seconds ago, saying: I suppose the answer is "no" because there are never really guarantees like that.
07:16:19 <EvanR-wo1k> geheimdienst: no
07:16:53 <EvanR-wo1k> just "Segmentation fault"
07:16:56 <EvanR-wo1k> and no other output
07:25:53 <geheimdienst> EvanR-wo1k: i got nothing. try doing "installHandler userDefinedSignal1" and run the thing and do "kill -USR1", see if that whole thing works at all. next try switching back to segv and do "kill -SEGV" ...
07:26:04 <troydm> what's all that WHNF and staff talk ?
07:26:11 <troydm> i don't quite understand
07:26:16 <troydm> can any1 explain me
07:26:33 <troydm> what's Head Normal Form
07:26:42 <troydm> and Weak Head Normal Form
07:27:19 <Cale> A term is in weak head normal form if: 1) it is a lambda abstraction or 2) it consists of a data constructor applied to some terms
07:27:20 <troydm> and how it's related to seq function
07:27:25 <hpc> there's sort of two meanings, one for functions and one for data
07:27:39 <EvanR-wo1k> geheimdienst: ok
07:27:44 <hpc> normal form is a totally evaluated thing
07:27:58 <Cale> A term is in head normal form if 1) it is a lambda abstraction whose body is in head normal form, or 2) it consists of a data constructor applied to some terms
07:28:07 <hpc> languages like agda that are strongly normalizing are able to guarantee that all expressions have a normal form
07:28:22 <mux> Cale: does it make sense to talk about a "leftmost term" here?
07:28:37 <int-e> EvanR-wo1k: I don't think this can work for genuine segfaults -- the RTS will catch the signal and put it on a queue; then the signal handler will return and the program will stop. The Haskell side of it will never be run.
07:28:55 <EvanR-wo1k> int-e: :S
07:29:06 <EvanR-wo1k> i figured as much
07:29:26 <troydm> hmm i don't quite understand but thx anyway
07:30:09 <hpc> troydm: for data, WHNF is pretty much "we know what the constructor is"
07:30:17 <hpc> troydm: and normal form is "we have evaluated it entirely"
07:30:44 <troydm> hpc: hmm so it's basicly question about beaning evaluated or not?
07:30:46 <Cale> WHNF is basically enough to decide how a case expression which matches one data constructor should match
07:30:53 <EvanR-wo1k> int-e: im using several ffi libs, is there any way to rig my program so the next time i segfault, i can inspect something to find out the general area?
07:31:00 <int-e> EvanR-wo1k: sorry ;) I spent some time looking for the responsible code in the RTS, which is spread over System.Posix.Signals (unix package), GHC.Conc.Signals (base) and rts/posix/Signals.c (in particular generic_handler there) in the ghc sources themselves.
07:31:07 <hpc> troydm: HNF is more subtle, but for data it is the same as WHNF
07:31:10 <Cale> troydm: Yeah, WHNF is basically the smallest useful amount that something can be evaluated
07:31:27 <Cale> I wouldn't worry much about HNF because it's not used in practice
07:32:21 <troydm> Cale: i'm just reading about pseq
07:32:33 <hpc> troydm: do you know what seq does?
07:32:44 <troydm> and there is a description
07:32:46 <troydm> As for pseq, it is similar to seq: it evaluates the expression on the left to WHNF before returning the expression on the right
07:32:57 <Cale> troydm: so if we have something like...  map (*2) [0..], and we want to evaluate to WHNF, well, this term is not a lambda, and map is not a data constructor
07:33:06 <Cale> troydm: so we evaluate map:
07:33:08 <Cale> @src map
07:33:09 <lambdabot> map _ []     = []
07:33:09 <lambdabot> map f (x:xs) = f x : map f xs
07:33:25 <int-e> EvanR-wo1k: I'd try running in gdb.
07:33:49 <Cale> In order to decide which of the equations matches, we need to know if the second parameter to map is [] or (x:xs), so we evaluate it to WHNF here:
07:33:55 <mux> Cale: I guess that "leftmost term" is a bit confusing, especially with infix data constructors such as in your example ehre
07:33:56 <Cale> map (*2) (0 : [1..])
07:34:05 <EvanR-wo1k> int-e: its a cron script, and the circumstances of the segfault are rare so i probably cant guess at them
07:34:09 <EvanR-wo1k> external circumstances
07:34:14 <Cale> and then we can match:
07:34:29 <Cale> (*2) 0 : map (*2) [1..]
07:34:42 <Cale> and now the topmost thing in our expression is (:), which is a data constructor
07:34:50 <int-e> EvanR-wo1k: hmm, enable core dumps (ulimit ... should be possible from within the haskell program) and then inspect that with gdb?
07:34:51 <Cale> and so our expression is in WHNF
07:35:03 <EvanR-wo1k> int-e: ulimit, got it
07:35:41 <troydm> Cale: i understand thx
07:35:41 <hpc> troydm: that last line can be written as (:) ((* 2) 0) (map (* 2) [1..]), if it helps you see what "leftmost" means
07:37:30 <troydm> hpc: ok os
07:37:49 <troydm> in map (*2) [1..]
07:37:59 <troydm> leftmost is infinite ?
07:38:08 <troydm> or it's just first occurance of :
07:38:18 <Cale> the leftmost term in that is map
07:38:24 <Cale> I guess
07:38:37 <Cale> Well...
07:38:45 <Cale> It's (map (*2)) [1..]
07:38:59 <Cale> so this is an application of the term map (*2) to [1..]
07:40:08 <Cale> So, you could say that the topmost (or oddly, leftmost) thing in this expression is function application
07:41:21 <Cale> Uh, I guess we want to use leftmost to refer to map here anyway
07:41:46 <Cale> So I guess we'll define the leftmost thing in an application term x y to be the leftmost thing in x
07:42:21 <troydm> Cale: that even more confusing but thx :)
07:42:31 <Cale> heh, yeah, I'm confused :)
07:42:47 <Cale> Just go with my original definition of WHNF, it's correct anyway :)
07:42:53 <hpc> :P
07:43:22 <troydm> so say i have greater and lesser where lesser and greater are some list comprehensions that could be evaluated lazily
07:43:28 <troydm> so if i do
07:43:34 <troydm> greater `pseq` lesser
07:43:54 <troydm> that will make sure that the greater will be evaluated
07:44:00 <Cale> yeah
07:44:01 <troydm> or just return lesser
07:44:13 <byorgey> it will only make sure that greater is evaluated to WHNF.
07:44:23 <Cale> It will ensure that greater is evaluated to WHNF before producing lesser as its result
07:44:31 <byorgey> if greater is a list, this means evaluating it just far enough to find out whether it is [] or a cons.
07:44:37 <byorgey> that is, not very much at all.
07:45:02 <byorgey> it will not evaluate any of the actual elements of the list. it will not evaluate anything beyond the first cons.
07:45:19 <troydm> byorgey: ok that's more understandable
07:45:40 <troydm> so in case of [] the WHNF is [] or cons
07:45:48 <byorgey> right.
07:46:01 <troydm> thx i think i'm starting to understand it
07:46:10 <byorgey> troydm: for any type, WHNF means evaluating it just far enough to find out what the constructor is.
07:46:19 <byorgey> troydm: list has two constructors, [] and (:).
07:46:28 <carpi> Hi. is it possible to write meta programs in haskell? ala.. macros in lisp? please excuse my ignorance if this is supposed to be common knowledge.
07:46:46 <byorgey> carpi: yes, using Template Haskell
07:47:04 <byorgey> carpi: it is not as nice as macros in lisp.  But it is also not needed as often.
07:47:53 <carpi> thanks.. ill look into it )
07:48:33 <Ferdirand> \x -> case x of True -> Just (...); False -> Just (...)
07:48:35 <Ferdirand> is this WHNF ?
07:49:01 <gtirloni> 5/clear
07:49:03 <gtirloni> sorry
07:49:29 <Ferdirand> or rather, can you WHNF this expression without applying the x ?
07:49:38 <byorgey> Ferdirand: any lambda expression is already in WHNF
07:49:43 <byorgey> no matter what is on the RHS
07:50:20 <Ferdirand> well Cale said: 1) it is a lambda abstraction whose body is in head normal form
07:50:50 <byorgey> Ferdirand: that was the definition of "head normal form"
07:51:06 <byorgey> you asked about *weak* head normal form
07:51:12 <Ferdirand> ok, so here is the difference ?
07:51:16 <byorgey> yes
07:51:31 <Cale> Ferdirand: HNF and WHNF are two different things :)
07:51:43 <Cale> Ferdirand: Every lambda term is in WHNF
07:51:51 <hpc> Ferdirand: if all you ever look at is data, the two are the same; it's only in the case of lambda that things get different
07:51:57 <Cale> Ferdirand: in order to be in HNF, a lambda term's body must be in HNF
07:52:37 <hpc> Ferdirand: WHNF lambda: \x -> succ x
07:53:04 <hpc> Ferdirand: HNF lambda: \x -> Just (x + 1) -- the inside is in HNF because it "starts" with a constructor
07:53:55 <byorgey> so by this definition, every term can be reduced to WHNF, but not every term can be reduced to HNF?
07:55:28 <Ferdirand> so, I think my example can be reduced to HNF if the Just is factored out, but as-is it can't ?
07:56:44 <hpc> byorgey: (fix id) can't be reduced to WHNF
07:56:56 <byorgey> Ferdirand: yes, it seems so
07:57:02 <byorgey> hpc: oh, er, right, duh
07:57:27 <hpc> a term that is productive at all is always reducable to WHNF though
07:57:45 <Ferdirand> is that why is WHNF more useful than HNF ?
07:58:07 <byorgey> hpc: right
07:58:31 <hpc> Ferdirand: mostly, i think it's just because HNF only applies to lambdas, and it's rule is quirky enough that we just don't care
07:59:34 <Ferdirand> but HNF tells you that your expression is ready to be matched into a case.. WHNF tells you.. what ?
07:59:35 <hpc> i suppose you could say "HNF is a lambda term that is productive for all input"
07:59:49 <hpc> which is actually really useful
07:59:58 <Cale> Ferdirand: It's because most efficient implementations of functional languages make evaluating inside an unapplied lambda impossible.
08:05:04 <Ferdirand> I was wondering how this interacts with laziness but I see it now, applying is not evaluating the argument so it is fine
08:06:11 <teneen> What does the pragma USE_REPORT_PRELUDE do? and how to know whether it's true in ifdef or not?
08:06:16 <Cale> Perhaps a better example,  (\x -> 1 + 1) is in WHNF, but not in HNF. To put it in HNF, we need to evaluate the 1 + 1 inside the lambda to get (\x -> 2)
08:06:34 <Cale> But that's an impractical thing to do in most implementations.
08:07:13 <Cale> (and basically makes it extra hard to compile functional code to something static while providing little benefit)
08:08:00 <Ferdirand> Cale: hah, that's exactly the example I was thinking about
08:08:06 <Cale> teneen: It's a CPP option which if turned on while compiling base, will cause the Report specification versions of things to be used.
08:08:41 <Cale> teneen: It's not turned on if you just have a normal GHC
08:09:24 <teneen> Cale: I compiled GHC from source, so by default it's not on?
08:09:26 <Cale> teneen: Instead, more carefully optimised versions of things will be used (many of which involve low-level hackery such as unboxed types)
08:10:20 <Cale> Uh, yeah, probably. I don't know. It might compile a version of things with the Report Prelude definitions for testing's sake.
08:10:43 <Cale> But it shouldn't be using them in the base package that gets installed.
08:10:56 <yitz> teneen: i sure hope not
08:11:27 <Cale> It's kinda pointless to compile GHC from source in most cases, btw.
08:11:39 <dafis> teneen: you need to explicitly define USE_REPORT_PRELUDE if you want that
08:12:53 <Cale> Unless you're hacking on it, or on a platform where there doesn't yet exist a binary GHC (which will likely involve hacking on it anyway), there isn't much point in compiling it yourself, because in order to do so, you need an already-working GHC installation.
08:14:21 <Cale> and there are a bunch of nice folks who compile binaries for most of the supported platforms and get them onto the GHC website pretty quickly anyway :)
08:14:21 <teneen> Cale: I see, it actually took a lot of time :)
08:14:27 <Cale> yeah
08:14:34 <opqdonut> is there something like an indexed Writer monad?
08:14:53 <opqdonut> as in, I want to write multiple orthogonal things at once
08:14:56 <teneen> dafis: could you elaborate more?
08:14:57 <troydm> opqdonut: by indexed what do you mean?
08:15:35 <opqdonut> I guess I could just use a suitable product monoid...
08:15:37 <Cale> opqdonut: Writer (Map k v)?
08:15:44 <opqdonut> Cale, right
08:15:54 <opqdonut> yeah, that'll do for now
08:16:19 <yitz> Cale: is the Monoid instance for Map suitable?
08:16:33 <Cale> oh, maybe it's not
08:16:51 <Cale> The one you want is (Monoid v) => Monoid (Map k v)
08:17:06 <yitz> > M.singleton 3 ["foo"] <> M.singleton 3 ["bar"]
08:17:07 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
08:17:07 <lambdabot>         agains...
08:17:11 <Cale> But it looks like the default instance isn't the lifting instance
08:17:12 <yitz> ach
08:17:24 <yitz> > M.singleton 3 ["foo"] `mappend` M.singleton 3 ["bar"]
08:17:25 <lambdabot>   fromList [(3,["foo"])]
08:17:30 <Cale> yeah :P
08:17:38 <Cale> So you'll need to newtype
08:19:23 <dafis> teneen: If you want the implementations given in the report, you have to compile base with the CPP option -DUSE_REPORT_PRELUDE since they're guarded by #ifdef USE_REPORT_PRELUDE or similar
08:19:55 <dafis> teneen: the simplest way is to put that option into base.cabal
08:20:28 <dafis> teneen: but why would you want that?
08:20:59 <teneen> dafis: I see
08:21:13 <teneen> dafis: I don't think I'll need it anyway :)
08:21:25 <dafis> good
08:23:17 <EvanR-wo1k> --debug in ghc will do what?
08:23:37 <EvanR-wo1k> should i use --debug if i expect a segfault, coredump, and reading gdb?
08:25:01 <yitz> opqdonut: did you see what Cale said about needing a newtype?
08:25:17 <opqdonut> yeah, I did
08:25:49 <yitz> opqdonut: ok. we didn't mention your nick, so i wanted to make sure you didn't miss it. that would cause a nasty bug.
08:25:57 <opqdonut> yeah
08:26:06 <opqdonut> I'm also contemplating writing out [X] where X is a sum type
08:26:09 <opqdonut> and then post-processing
08:26:23 <yitz> opqdonut: yep. a bit more work but more clear.
08:26:28 <opqdonut> indeed
08:27:14 <opqdonut> I asked mainly to hear if there was something like this hidden on hackage
08:37:46 <EvanR-wo1k> has any of this been implemented http://ww2.cs.mu.oz.au/~bjpop/papers/ghci-debug.pdf
09:01:43 <dmwit> EvanR-wo1k: yes
09:02:21 <dmwit> EvanR-wo1k: I don't know which exact version is the earliest one with a debugger, but that stuff is definitely available in ghci now.
09:05:29 <EvanR-wo1k> dmwit: interesting
09:12:29 <geheimdienst> do i recall that correctly -- there is some lobbying going on to make Monad a Functor?
09:12:53 <bfig> a monad should be a functor!!!
09:13:34 <rotflcopter> whats a monad?
09:14:03 <EvanR-wo1k> back when i tried to explain to normal people how great haskell is, i would get trolled about how the monad applicative functor stuff is not set up right
09:14:17 <EvanR-wo1k> so if you could close that loophole that would be good
09:14:20 <geheimdienst> so, why Functor and not Applicative?
09:14:55 <aninhumer> Is there like a page of suggested Prelude enhancements somewhere?
09:15:03 <geheimdienst> rotflcopter: one of the typeclasses in the haskell standard library. it defines 3 or 4 handy functions and is used in several places. it's not so impressive really ...
09:15:30 <bfig> it's a fundamental flaw in the mathematical fabric of the language
09:15:42 <aninhumer> I think there are quite a few which are obvious and most people agree with, filling out the typeclass heirarchy being one of them
09:16:30 <EvanR-wo1k> like what pointed
09:17:10 <rotflcopter> btw since haskell is only functional, to implement something like displaying on screen, flipping double buffer, must be imported and written in C right?
09:17:22 <byorgey> no, not pointed
09:17:28 <mellum> So, in ML I can do let x=empty in let x=add x 5 in let x=add x 17 in... but apparently in Haskell this is not possible since it assumes this is some kind of recursive definition. So can this be done without inventing new names?
09:17:48 <byorgey> rotflcopter: no
09:17:49 <EvanR-wo1k> wait wait, that works in haskell
09:18:08 <EvanR-wo1k> lexical scope right
09:18:14 <Saizan> mellum: nope
09:18:22 <bfig> rotflcopter, no, you have IO monad to sequence interactions with the RW
09:18:28 <byorgey> EvanR-wo1k: let x = add x 17  is unlikely to work in Haskell as it does in ML.
09:18:28 <cheater> > let x=2 in let x=3 in let x=4 in x
09:18:29 <lambdabot>   4
09:18:34 <Saizan> mellum: within do-notation you get it though
09:18:47 <teneen> Is it possible to set operator precedence from GHCi?
09:18:52 <mellum> Saizan: Hmmm, are there any downsides to that?
09:18:53 <rotflcopter> ahm, so monad is the lnk between functional part and sequential part?
09:19:01 <aninhumer> What are the actual primitives in IO?
09:19:08 <cheater> mellum: no
09:19:08 <Philonous> rotflcopter:  I think you will hurt your own learning programs if you try to understand haskell (or any language, for that matter) in terms of almost meaningless words like "functional"
09:19:13 <mm_freak> rotflcopter: you're comparing apples and bananas
09:19:16 <Philonous> progress*
09:19:17 <byorgey> mellum: in Haskell, all 'let's are actually 'letrec'
09:19:19 <EvanR-wo1k> > let x = 2 in let x = 2+x in x
09:19:23 <lambdabot>   mueval-core: Time limit exceeded
09:19:23 <cheater> mellum: do notation is standard
09:19:40 <Saizan> mellum: that it works only for monads :) you could use the Identity monad but it'd be somewhat abusive
09:19:49 <mm_freak> rotflcopter: functional programming is a paradigm…  interacting with the real world is a functionality
09:19:52 <geheimdienst> rotflcopter: the type IO is kind of the link between the functional and the imperative (sequential)
09:20:05 <rotflcopter> Philonous<< well you're probably right, i can make functional logic in C
09:20:13 <mm_freak> nothing wrong with doing both at the same time
09:20:16 <mellum> Saizan: I haven't yet learned what a monad is :-) But I'll just try with do.
09:20:24 <mm_freak> mapM_ print something
09:20:36 <Saizan> mellum: heh, better not then
09:20:38 <EvanR-wo1k> geheimdienst: i dont think sequential is what makes it distinct, a list is sequential, monadic combinations of actions are sequential
09:20:38 <aninhumer> I had an idea that there should be a facility for overloading in the specific case that a function is a more general variant of another
09:20:45 <Saizan> mellum: the types are different
09:20:54 <EvanR-wo1k> both are declarative and function
09:20:56 <EvanR-wo1k> al
09:21:22 <teneen> I want to use infixr or infixl in ghci, is it possible?
09:21:29 <mellum> Saizan: Hmmm. Okay, maybe I'll go for x'''' then :-)
09:21:33 <Saizan> mellum: but it'd look like do x <- return empty; x <- return $ add x 5; x <- return $ add x 17; ...
09:21:50 <EvanR-wo1k> mellum: theres no shortage of variable names
09:21:57 <geheimdienst> EvanR-wo1k: yeah, there's other sequential things too, but notably pure functions in haskell to my knowledge don't have this notion of "first do this, then afterwards do that"
09:22:03 <mm_freak> i don't understand why people connect monads to sequencing
09:22:13 <mellum> EvanR-wo1k: it's kinda error prone
09:22:13 <sipa> mm_freak: do notation
09:22:25 <EvanR-wo1k> geheimdienst: you mean in spacetime, well i think we need another word than sequential for that ;)
09:22:27 <ski> mm_freak : `join'
09:22:38 <mm_freak> even IO does no sequencing…  its interpretation (the interpreter/compiler) is where sequencing occurs
09:22:46 <EvanR-wo1k> mellum: not really, you shouldnt have a function bigger than a page imo ;)
09:22:56 <mm_freak> evaluation order is still undefined and perfectly fine, when it goes from right to left
09:23:15 <EvanR-wo1k> i think its weird sequencing has come to mean something IO related
09:23:26 <EvanR-wo1k> it implies an effect now
09:23:27 <cheater> i don't
09:23:43 <EvanR-wo1k> my data is sequenced whether or not it launches missiles
09:23:45 <cheater> the act of sequencing is an interaction with the external world
09:23:48 <Saizan> mellum: let'ing so much stuff is quite unidiomatic too, maybe you have a case where the State monad would be appropriate but i guess that's for later :)
09:23:49 <mm_freak> sequencing is a dependency relation
09:23:57 <cheater> specifically, the real-world wall clock
09:24:10 <EvanR-wo1k> sounds like an eroded jargon
09:24:26 <mm_freak> IO is sequential in the sense that in a >>= b, a is executed before b
09:24:27 <EvanR-wo1k> became 'sequence' which meant all this other stuff in addition to sequences
09:24:52 <EvanR-wo1k> like function in C is not really a function, but could be
09:24:53 <mm_freak> > sequence ["hH", "eE", "lL", "lL", "oO"]
09:24:54 <lambdabot>   ["hello","hellO","helLo","helLO","heLlo","heLlO","heLLo","heLLO","hEllo","h...
09:24:58 <mm_freak> no sequencing there
09:25:27 <mm_freak> just an unfortunate name for a combinator, which in IO performs the actions in a list in sequence
09:25:42 <EvanR-wo1k> the function is called sequence, i am saying its a meaning distinct from english word sequencing or math 'sequence'
09:25:50 <roSievers> Hi I'd like to implement a modular arithmetic type in Haskell.
09:25:51 <roSievers> Is there a way to make the type constructor take an Int and store it for later use?
09:25:56 <cheater> i don't see the difference EvanR-wo1k
09:25:58 <dbelange_> > sequence ["lL1", "oO0", "lL1", "oO0", "lL1"]
09:25:59 <lambdabot>   ["lolol","loloL","lolo1","lolOl","lolOL","lolO1","lol0l","lol0L","lol01","l...
09:26:12 <mm_freak> roSievers: sure, it just doesn't play well with the Num type class
09:26:21 <aristid> :t \f a -> sequence (f a)
09:26:22 <lambdabot> forall t (m :: * -> *) a. (Monad m) => (t -> [m a]) -> t -> m [a]
09:26:35 <aristid> :t \f a -> sequence (fmap f a)
09:26:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [a1]
09:26:38 <roSievers> mm_freak: how do I do it?
09:27:00 <mm_freak> roSievers: it's a simple question, yet doesn't have a straightforward answer
09:27:00 <roSievers> data Modular a = .. would just store the Type, wouldn't it?
09:27:16 <EvanR-wo1k> cheater: sequence just implies an order, not effects. lists are sequential, sets arent
09:27:39 <mm_freak> roSievers: one hacky way to represent modular values is this:  newtype Mod a = Mod (a -> a)
09:27:41 <cheater> but the order is an effect
09:27:43 <cheater> that is the point
09:27:45 <EvanR-wo1k> loool
09:27:46 <EvanR-wo1k> no
09:27:51 <EvanR-wo1k> dont be religious
09:27:56 <cheater> i'm not
09:27:58 <aninhumer> roSievers: I think you'd want to make a constuctor function Int -> Modular, and not export the constructor
09:27:58 <cheater> i'm pragmatic
09:28:13 <mm_freak> roSievers: unfortunately you can't write instances for Eq and Num for that type
09:28:15 <EvanR-wo1k> you can be pragmatic without being intentionally obtuse with language
09:28:27 <aninhumer> mm_freak: why not Eq?
09:28:35 <mm_freak> roSievers: one working solution is using implicit configurations, but if you are a haskell beginner, don't bother with that yet =)
09:28:36 <EvanR-wo1k> the fibonacci sequence is not an effect
09:28:44 <mm_freak> aninhumer: when are two functions equal?
09:28:48 <roSievers> could I do it differently, so that I can implement Num?
09:28:54 <aninhumer> mm_freak: oh for that type
09:29:19 <mm_freak> roSievers: for the type i presented you can actually implement Num…  the problem is that Num is a subclass of Eq, and you can't implement Eq
09:29:23 * roSievers ist a haskell beginer, yes
09:29:29 <ski> mm_freak : the sequencing in `sequence ["hH", "eE", "lL", "lL", "oO"]' is that it selects an element from `"hH"' before it selects an element from `"eE"', &c. -- but yes, the sequencing here isn't related in which order things happen to execute, it's a conceptual sequencing
09:30:02 <mm_freak> roSievers: i called it hacky, because you can use this hack:  instance Integral a => Eq (Mod a) where (==) = undefined
09:30:17 <mm_freak> and you would do something similar for Show
09:30:53 <EvanR-wo1k> cheater: im taking exception with the equation of 'sequence' with IO execution
09:31:02 <roSievers> Could I just make "data Modular = Mod m n" and export only Modular and (Mod n)
09:31:19 <roSievers> Or would I run into troubles when i try to make functions for that
09:31:20 <mm_freak> roSievers: how would you implement fromIntegral for that type?
09:31:47 <roSievers> :-/ I can't?
09:31:56 <mm_freak> roSievers: think about it
09:32:05 <mm_freak> uhm
09:32:09 <mm_freak> fromInteger, not fromIntegral
09:32:21 <mm_freak> fromInteger takes an Integer value and turns it into a modular value
09:32:23 <roSievers> well I wouldn't know the m
09:32:28 <mm_freak> exactly
09:32:39 <roSievers> and I can't guess it correctly either
09:33:01 <mm_freak> one way is to leave holes
09:33:18 <mm_freak> data Mod a = Mod (Maybe a) a
09:33:24 <cheater> EvanR-wo1k: i don't even know what that means. try using less lofty wording.
09:33:24 <mm_freak> but then again you can't implement Eq
09:33:37 <mm_freak> there is no clean way to do this except implicit configurations
09:33:40 <EvanR-wo1k> cheater: nevermind
09:33:50 <cheater> i know that one
09:33:56 <mm_freak> but that method requires advanced type system stuff, so as a beginner, go for other tasks =)
09:34:13 <roSievers> I'll have a look at them anyway
09:34:29 <roSievers> can still give up later : )
09:35:03 <roSievers> thanks for telling me
09:35:09 <mm_freak> roSievers: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
09:35:50 <roSievers> is that actually about Haskell? "Functional Pearl"
09:36:06 <mm_freak> yes
09:36:36 <geheimdienst> roSievers: (note that pearls are items of jewelry, while perl is the programming language)
09:36:51 <mm_freak> the notation may be a bit weird, because they use actual math symbols, but all of them have valid source code representation
09:37:13 <roSievers> yeah, also a search for "haskell" fas quite sucessfull
09:37:36 <mm_freak> roSievers: it's specifically about haskell
09:38:15 <roSievers> gotta take my clothes out of the washer now, bye
09:38:27 <roSievers> my clock just told me to
09:44:01 <SavageSimian> this might sound a little silly but i've searched a couple of online books and googled and i can't find a definition for the 'Just' keyword.
09:44:28 <EvanR-wo1k> its not a keyword
09:44:34 <EvanR-wo1k> @src Maybe
09:44:35 <lambdabot> data Maybe a = Nothing | Just a
09:44:49 <parcs_> did you not google "haskell just"
09:45:02 <parcs_> because the very first result would tell you
09:45:12 <SavageSimian> i googled "haskell just keyword"
09:46:06 <geheimdienst> SavageSimian: for these kinds of things, use hayoo
09:46:08 <geheimdienst> @where hayoo
09:46:09 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:46:55 <SavageSimian> heh. ok, thanks.
09:49:33 <SavageSimian> if Just a returns 'a' why not simply say 'a'?
09:49:51 <Eduard_Munteanu> It doesn't.
09:49:58 <Eduard_Munteanu> :t Just
09:49:59 <lambdabot> forall a. a -> Maybe a
09:50:19 <EvanR-wo1k> > Just 'a'
09:50:20 <lambdabot>   Just 'a'
09:50:25 <EvanR-wo1k> :)
09:50:30 <mm_freak> SavageSimian: never search for "keyword"…  haskell has only a few keywords, which you probably already know
09:51:36 <Nimatek> > Just 2 >>= return . (^2)
09:51:37 <lambdabot>   Just 4
09:51:38 <lambdabot> Nimatek: You have 1 new message. '/msg lambdabot @messages' to read it.
09:51:49 <Nimatek> > Just 2 >>= \_ -> Nothing >>= return . (^2)
09:51:50 <lambdabot>   Nothing
09:52:01 <EvanR-wo1k> > Just 2 <*> (^2)
09:52:02 <lambdabot>   The section `GHC.Real.^ 2' takes one argument,
09:52:02 <lambdabot>  but its type `Data.Maybe.Ma...
09:52:09 <mm_freak> > fmap (^2) (Just 2)
09:52:10 <lambdabot>   Just 4
09:52:18 <EvanR-wo1k> > Just 2 <$> (^2)
09:52:19 <lambdabot>   Couldn't match expected type `a -> b'
09:52:20 <lambdabot>         against inferred type `Data.M...
09:52:22 <EvanR-wo1k> :(
09:52:28 <mm_freak> > Just (^2) <*> Just 2
09:52:29 <lambdabot>   Just 4
09:52:39 <mm_freak> > (^2) <$> Just 2
09:52:39 <Nimatek> > (^2) <$> Just 2
09:52:40 <lambdabot>   Just 4
09:52:40 <lambdabot>   Just 4
09:52:42 <Nimatek> Hehe.
09:52:45 <ski> SavageSimian : you say `Just foo' when there might have been a `Nothing' instead, so the `Just' means that there actually was a result
09:52:45 <mm_freak> =)
09:52:48 <EvanR-wo1k> ok we probably scared him away
09:52:52 <EvanR-wo1k> mission accomplished
09:53:27 <ski> > lookup "a" [("b",28),("a",6),("d",496)]
09:53:28 <lambdabot>   Just 6
09:53:29 <SavageSimian> EvanR-wo1k: yea. i'm outta here!  :)
09:53:33 <ski> > lookup "c" [("b",28),("a",6),("d",496)]
09:53:34 <lambdabot>   Nothing
09:53:34 <SavageSimian> j/k
09:53:39 <ski> SavageSimian : compare those two cases
09:53:41 <mm_freak> :t (.)
09:53:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:53:56 <mm_freak> i'd prefer the Category generalization to be the one in lambdabot
09:54:05 <ski>   lookup :: Eq key => key -> [(key,value)] -> Maybe value
09:54:10 <mm_freak> :t (Control.Category..)
09:54:11 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
09:54:44 * hackagebot lambdiff 0.1 - Diff Viewer  http://hackage.haskell.org/package/lambdiff-0.1 (JamieTurner)
09:54:48 <parcs_> says the arrow fanatic :P
09:55:05 <mm_freak> sure =)
09:55:10 <mm_freak> :t (<<<)
09:55:11 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
09:57:05 <bscarlet> Is there a name for a common ancestor of Control.Arrow and Data.Bifunctor?
09:58:12 <mm_freak> since i know that there are actually useful arrows, which are not monads, i started to like them…  and since i discovered Wire, i love them =)
09:58:53 <bscarlet> mm_freak: got a link to Wire?
09:58:59 <bscarlet> mm_freak: don't know it.
09:59:07 <mm_freak> bscarlet: add Maybe to Automaton and you've got Wire
09:59:30 <mm_freak> newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
09:59:43 <bscarlet> mm_freak: what's Automaton?
09:59:51 <mm_freak> the same without Maybe
09:59:57 <ski> bscarlet : hm, `Difunctor' would be more appropriate, i think
10:00:13 <mm_freak> it's a function, which can ask you to call a different function the next time
10:00:22 <bscarlet> ski: more appropriate than what?
10:00:31 <ski> bscarlet : than `Bifunctor'
10:00:49 <bscarlet> ski: okay. I didn't name it.
10:01:02 <ski> bscarlet : i'm not talking about the naming. i'm talking about the semantics
10:01:29 <ski> bscarlet : a `Bifunctor' is covariant in both arguments, a `Difunctor' is contravariant in the first argument, and covariant in the second argument
10:01:47 <ski> bscarlet : instances of `Arrow' would normally be `Difunctors' if anything
10:02:39 <bscarlet> ski: (googling for necessary background I don't have)
10:03:50 <ski>   class Bifunctor f
10:03:52 <ski>     where
10:03:53 <ski>     bimap :: (a0 -> a1) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
10:03:56 <ski> vs.
10:04:00 <ski>   class Difunctor f
10:04:01 <ski>     where
10:04:10 <ski>     dimap :: (a1 -> a0) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
10:04:16 <ski> bscarlet : do you see the difference ?
10:04:37 <bscarlet> ski: yes. Thinking.
10:05:09 <ski> e.g. you could `instance Difunctor (->)' and `instance Monad m => DiFunctor (Kleisli m)'
10:05:24 <ski> but you couldn't make those into instances of `Bifunctor'
10:06:39 <bscarlet> ski: I don't have the experience to follow you too quickly, but you seem to be going in a different direction than what I was thinking.
10:07:23 <bscarlet> ski: I meant some X a p such that X (->) p => Bifunctor p and X a (,) => Arrow a
10:07:33 <ski> bscarlet : i'm just saying that `Arrow' and `Category' has more in common with `Difunctor' than with `Bifunctor'
10:08:00 <bscarlet> ski: I'm just naively trying to merge the types of first, second, and bimap/(***).
10:08:07 <ski> bscarlet : hm .. `X' is a class here ?
10:08:24 <ski> hm
10:08:45 <ski> oh, ok
10:08:50 <bscarlet> ski: yes. with first :: a b c -> a (p b d) (p c d) and (***) :: a b c -> a b' c' -> a (p b b') (p c c')
10:08:52 <ski> then i misunderstood you
10:09:09 <bscarlet> ski: taught me something anyway :-)
10:09:12 <ski> yes, `(***)' is basically an `bimap'
10:10:05 <bscarlet> ski: I was wondering if there's a name for X.
10:10:55 <shachaf> preflex: seen byorgey
10:10:55 <preflex>  byorgey was last seen on #haskell 51 minutes and 39 seconds ago, saying: mellum: in Haskell, all 'let's are actually 'letrec'
10:11:12 <ski> well, `(***) :: forall a0 b0 a1 b1. ar a0 a1 -> ar b0 b1 -> ar (p a0 b0) (p a1 b1)' means more or less that that `p' is a bifunctor over the category which has `ar' as its morphism type
10:12:16 <shachaf> byorgey: ?
10:12:26 <bscarlet> ski: I clearly need more category theory.
10:12:28 <ski> bscarlet : so, one could maybe say `class Category cat => CategoryBifunctor cat p where (***) :: forall a0 b0 a1 b1. ar a0 a1 -> ar b0 b1 -> ar (p a0 b0) (p a1 b1)', or something like that
10:12:44 <ski> of course, a category can have many bifunctors ..
10:13:01 <ski> (er, s/ar/cat/ in the type)
10:13:58 <bscarlet> ski: thanks. That gives me enough pointers into known places in the stuff I don't know to hang this idea in a well defined place in my mine.
10:14:17 <bscarlet> s/mine/mind/
10:18:21 <bscarlet> ski: aside from MultiParamTypeClass issues, is there an argument that CategoryBifunctor is actually what Bifunctor ought to be?
10:19:18 <ski> yes, to the extent that we want to generalize `(->)' into `ar' where `Arrow ar' or `Category ar' at all
10:22:19 <bscarlet> ski: hmm. I see what you mean, actually. Although I use Control.Arrow.first and second often, it's rarely for Arrows other than (->).
10:34:44 * hackagebot criterion 0.5.1.1 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.1.1 (BryanOSullivan)
10:37:41 <yitz> hey i needed a name for an operator for the Last operation on Maybe
10:37:55 <yitz> i thought of a leet way of doing it: !@$+
10:40:24 <aristid> > Just 1 >> Just 2
10:40:25 <lambdabot>   Just 2
10:40:34 <aristid> yitz: this operation?
10:40:49 <aristid> oh, not quite
10:40:55 <aristid> > Nothing >> Just 2
10:40:56 <lambdabot>   Nothing
10:41:01 <aristid> this should be Just 2, right?
10:41:06 <yitz> aristid: mappend
10:41:13 <yitz> right
10:41:17 <aristid> yitz: yeah, mplus is First iirc
10:41:24 <aristid> > Just 1 `mplus` Just 2
10:41:25 <lambdabot>   Just 1
10:41:27 <yitz> yeah
10:41:59 <aristid> yitz: <&>?
10:42:08 <yitz> > unLast $ Last (Just 1) `mappend` Last (Just 2)
10:42:09 <lambdabot>   Not in scope: `unLast'
10:42:14 <yitz> aww
10:42:43 <ski> > getLast (Last (Just 1) `mappend` Last (Just 2))
10:42:44 <lambdabot>   Just 2
10:42:56 <yitz> oh thanks!
10:44:00 <yitz> > let x <&>? y = getLast $ Last x `mappend` Last y in Just 2 <&>? Just 3
10:44:01 <lambdabot>   Just 3
10:44:26 <aristid> > Just 1 <|> Just 2
10:44:28 <lambdabot>   Just 1
10:44:50 <aristid> yitz: see, you have a at least superficionally reasonable logic behind <&> :)
10:45:20 <aristid> yitz: lol, the ? was not supposed to be part of it
10:45:35 <yitz> aristid: ;)
10:45:44 <newsham> in python "1 and 5 and 7 and 3" -> 3
10:45:53 <aristid> yitz: naming operators in haskell is hard! :)
10:45:58 <newsham> (although "1 and 5 and 0 and 3" -> 0)
10:46:09 <aristid> newsham: so and is more like >>
10:46:19 <bl4ckcomb> hi, can someone tell me how I should use polymorph parameters? I tried with myfunc :: [(Int, v)] -> v, and then myfunc [] = null, but apparently I can't assign null to v...
10:46:23 <newsham> just trying to give some moral support to "<&>"
10:46:33 <newsham> its at least "and like"
10:46:40 <ski> bl4ckcomb : `null' is a function
10:46:47 <ski> bl4ckcomb : what are you trying to do ?
10:46:49 <bl4ckcomb> hi ski :D
10:47:22 <yitz> @leet last
10:47:23 <lambdabot>   TemplateHaskell is not enabled
10:47:35 <bl4ckcomb> ski, well, I'm practicing Haskell with some trivial test cases. one is a 'last' function that should return the value of the last key-value pair (tuple) in a list of such tuples
10:47:41 <yitz> @elite last
10:47:41 <lambdabot> l4z+
10:47:44 <bl4ckcomb> a value can have any type
10:47:49 <yitz> @elite last
10:47:50 <lambdabot> laz+
10:47:52 <yitz> @elite last
10:47:53 <lambdabot> 1As7
10:48:32 <ski> bl4ckcomb : there is no `null'/`NULL' thing in Haskell, like there is in C,C++,Java,C#,&c.
10:48:36 <aristid> @elitewithoutletters last
10:48:36 <lambdabot> Unknown command, try @list
10:48:52 <ski> bl4ckcomb : if you want to say that `myfunc []' is a bad case, call `error' to report an error in that case
10:49:03 <bl4ckcomb> aha
10:49:31 <ski> (bl4ckcomb : it's also possibly to just omit that case, but you'll probably get a nicer error message if you write it yourself)
10:49:46 <newsham> a "nullable" value is represented with Maybe.  ie.  Nothing | Just <val>
10:49:53 <bl4ckcomb> ok, thank you ski
10:50:20 <newsham> so you might want   [(Int,v)] -> Maybe v
10:50:21 <bl4ckcomb> newsham, ok, but an error would probably be more correct in my case, since there would be no result
10:50:34 <ski>   myfunc [] = error "myfunc : empty input"
10:50:35 <bl4ckcomb> oh
10:50:37 <bl4ckcomb> hm
10:50:41 <ski> would be one possibility of using `error'
10:51:04 <ski> calling `error' will probably abort your program (unless you catch it in `IO')
10:51:08 <newsham> you should avoid using "error" unless the programmer really has no business ever calling your api in a certain way
10:51:18 <newsham> even then.. it can be "dangerous"
10:51:24 <ski> if you expect a non-buggy program to call `myfunc' with empty input, use `Maybe' instead
10:51:48 <bl4ckcomb> ok, with Maybe I'm getting Couldn't match type `v' with `Maybe v'
10:52:15 <ski> bl4ckcomb : probably because you haven't inserted `Just' in the non-failing case
10:52:20 <newsham> thats probably because the thing calling your function isnt expecting a "Maybe v"
10:52:25 <newsham> or that :)
10:52:27 <ski> yeah, that too
10:52:52 <newsham> > let f [] = Nothing | f (x:xs) = x in f "testing"
10:52:53 <lambdabot>   <no location info>: parse error on input `|'
10:52:59 <bl4ckcomb> it's a compiling error, so I suppose I'm missing just
10:52:59 <newsham> > let f [] = Nothing ; f (x:xs) = x in f "testing"
10:53:00 <newsham> heh
10:53:00 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
10:53:00 <lambdabot>         against inferred ...
10:53:07 <newsham> > let f [] = Nothing ; f (x:xs) = Just x in f "testing"
10:53:07 <KSkrzet> I have a question regarding IORef's: after atomicModifyIORef will all the other threads see the new value immidiately?
10:53:08 <lambdabot>   Just 't'
10:53:16 <newsham> > let f [] = Nothing ; f (x:xs) = Just x in f ""
10:53:17 <lambdabot>   Nothing
10:53:24 <smoge> why haskell platform was delayed?
10:53:26 <smoge> whats the reason?
10:53:41 <monochrom> yes KSkrzet
10:54:56 <bl4ckcomb> can I use Just for two cases?
10:55:06 <ski> i'm not sure what you mean
10:55:06 <copumpkin> smoge: the fact that GHC 7.2 was a "feature preview" release
10:55:10 <copumpkin> and 7.4 is the real thing
10:55:29 <smoge> hum.. I see
10:55:49 <bl4ckcomb> ski, I'm having [x] = fst x and [_:xs] = last xs
10:56:23 <ski> @type let [x] = fst x in x
10:56:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = [(a, b)]
10:56:25 <lambdabot>       Expected type: [(a, b)]
10:56:25 <lambdabot>       Inferred type: a
10:56:25 <bl4ckcomb> and last :: [(Int, v)] -> Maybe v
10:56:36 <ski> bl4ckcomb : `[x] = fst x' is illtyped
10:56:45 <ski> bl4ckcomb : perhaps you meant to say `myfunc [x] = fst x' ?
10:56:59 <bl4ckcomb> yeah sorry, that's what I meant
10:57:43 <ski> bl4ckcomb : note that `[_:xs]' isn't a pattern which matches a list with at least one element. it's a pattern which matches a list with exactly one element, which must be a list with at least one element
10:58:02 <ski> bl4ckcomb : you possibly meant `_:xs' instead of `[_:xs]'
10:58:17 <hpc> or (_:xs)
10:58:23 <ski> > let foo [_:xs] in foo ["abc","def"]
10:58:24 <lambdabot>   <no location info>: parse error on input `in'
10:58:32 <ski> > let foo [_:xs] = xs in foo ["abc","def"]
10:58:33 <lambdabot>   "*Exception: <interactive>:3:4-18: Non-exhaustive patterns in function foo
10:58:33 <bl4ckcomb> ah ok, so last :: [(Int, v)] -> Maybe v <lf> last [x] = snd x <lf> last (_:xs) = last xs
10:58:38 <ski> > let foo [_:xs] = xs in foo ["abc"]
10:58:40 <lambdabot>   "bc"
10:58:43 <ski> > let foo (_:xs) = xs in foo ["abc"]
10:58:44 <lambdabot>   []
10:58:53 <ski> (hpc : yeah, but it's the same thing :)
10:59:37 <ski> bl4ckcomb : looks ok, except that you're missing a `Just'
10:59:47 <ski> bl4ckcomb : also, you don't handle the empty list
11:00:17 <bl4ckcomb> ski, ah yes, I assumed the maybe just made unmatched patterns result in Nothing
11:00:23 <ski> (bl4ckcomb : btw, instead of `<lf>' you can say `;', which will make it into valid haskell :)
11:00:30 <ski> bl4ckcomb : it doesn't
11:00:33 <bl4ckcomb> ok
11:00:52 <bl4ckcomb> and the Just, how do I know where to put it? since now I have two patterns
11:00:57 <ski> you could add a `last _ = Nothing' to the end, to catch all previous match failures, though
11:01:12 <ski> bl4ckcomb : you put it into the result, not into the pattern
11:01:25 <ski> (because the `Maybe' is in the result type, not in the argument type)
11:03:08 <jem|osx> Hi there, can anyone help me? I'm trying to write a function that would combine either 2 given characters to a string or 2 integers into a list
11:03:11 <jem|osx> is that possible?
11:03:22 <Cale> jem|osx: (\x y -> [x,y])
11:03:47 <ski> > (\x y -> [x,y]) 'h' 'i'
11:03:48 <lambdabot>   "hi"
11:04:00 <ski> > (\x y -> [x,y]) 220 284
11:04:01 <lambdabot>   [220,284]
11:04:02 <bl4ckcomb> ok thanks ski
11:04:08 <ski> thank Cale
11:04:12 <jem|osx> nice thanks ! :D
11:04:31 <_Mikey> Hi all!
11:04:43 <ski> hello there
11:07:59 <jem|osx> so if I write it into a function like a script does that mean I should put it so like
11:08:11 <jem|osx> combine :: Integer -> [Integer]?
11:08:24 <jem|osx> sorry n00b question just learned haskell last week
11:08:26 <Cale> combine :: a -> a -> [a]
11:08:29 <Cale> combine x y = [x,y]
11:08:34 <jem|osx> ah
11:08:39 <Cale> Or:
11:08:45 <Cale> combine = (\x y -> [x,y])
11:08:48 <Cale> which is the same
11:09:11 <jem|osx> ah thanks :D
11:10:04 <jem|osx> so does that mean if I'm playing with more than one datatypes I can just use a on the first line?
11:11:03 <Cale> yeah
11:11:10 <Cale> the 'a' there is a type variable
11:11:21 <jem|osx> ah never thought about it like that
11:11:22 * edwardk is sad
11:11:31 * jem|osx jem|osx is happy
11:11:41 * roconnor tosses edwardk a lambda cookie
11:11:46 <edwardk> type family Constraints t :: Constraint  ; type instance Constraints (p => q) = p can be written but not used
11:11:50 <troydm> does applying length to list make it WHNF to evaluate whole list ?
11:12:01 * edwardk consoles himself with a cookie
11:12:25 <Cale> troydm: evaluating length of a list into WHNF will evaluate the entire spine of the list (the (:)'s and []'s), but none of the elements
11:12:38 <troydm> Cale: thx
11:12:45 <Cale> (unless the elements are needed to determine the spine)
11:12:50 <jem|osx> and if it's x y = [x,y] why doesn't 'h' 'i' output as [h,i]?
11:13:16 <Cale> jem|osx: Well, strings are printed with a special syntax. ['h','i'] and "hi" are the same thing
11:13:28 <Cale> > ['h','i']
11:13:29 <lambdabot>   "hi"
11:13:43 <troydm> Cale: can make and example where elements are needed to determine the spine?
11:13:45 <Cale> > "hi"
11:13:45 <copumpkin> there's a horrible hack in the default typeclasses to make show on [Char] spit out string syntax
11:13:45 <lambdabot>   "hi"
11:13:51 <troydm> Cale: list comprehension?
11:13:51 <jem|osx> lol
11:13:53 <jem|osx> "hi"
11:13:54 <jem|osx> makes sense
11:14:25 <EvanR-wo1k> > "hi" :: ByteString
11:14:26 <lambdabot>   Not in scope: type constructor or class `ByteString'
11:14:33 <EvanR-wo1k> > "hi" :: Text
11:14:34 <lambdabot>   Not in scope: type constructor or class `Text'
11:14:49 <Cale> > let f n = n : if n == 0 then [] else f (n-1) in f 10
11:14:50 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
11:14:51 * EvanR-wo1k throws a tantrum
11:15:10 <Cale> It has to evaluate each element to decide if the list ends or not
11:15:45 <jem|osx> (\x y = [x,y]) 'h' 'i'
11:15:53 <Cale> > (\x y -> [x,y]) 'h' 'i'
11:15:54 <lambdabot>   "hi"
11:16:04 <jem|osx> my bad
11:16:07 <Cale> -> in lambda, rather than =
11:16:18 <jem|osx> (\x y -> [x,y]) 'h' 'i'
11:16:21 <EvanR-wo1k> let cons x y = [x,y] in cons 3 Nothing
11:16:31 <EvanR-wo1k> nvm, different types
11:16:40 <EvanR-wo1k> no lisp ;)
11:16:42 <jem|osx> hm doesn't work
11:16:46 <troydm> Cale: thx i get it
11:17:34 <ski> jem|osx : you forgot to start with `> ', to tell lambdabot that you want here to try to evaluate it
11:17:43 <ski> "no cookie"
11:17:47 <ski> > "cookie"
11:17:48 <lambdabot>   "cookie"
11:18:00 <jem|osx> oh
11:18:02 <ski> (um, s/here/her/)
11:18:06 <jem|osx> > (\x y -> [x,y]) 'h' 'i'
11:18:06 <lambdabot>   "hi"
11:18:12 <jem|osx> neat
11:18:20 <edwardk> copumpkin: the hack isn't _that_ bad
11:19:11 <aristid> :t \xs -> ap xs . return
11:19:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
11:19:38 <aristid> @hoogle m (a -> b) -> a -> m b
11:19:39 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:19:39 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
11:19:39 <ski> @type \f a -> fmap ($ a) f
11:19:39 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:19:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
11:19:57 <ski> @type flip
11:19:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:20:09 <aristid> ski: thanks! :)
11:20:18 <ski> @src flip
11:20:19 <lambdabot> flip f x y = f y x
11:20:26 <aristid> :t flip [toLower, toUpper]
11:20:27 <lambdabot> Char -> [Char]
11:20:32 <ski> in lambdabot, `flip f a = fmap ($ a) f'
11:20:48 <aristid> @src mapM
11:20:49 <lambdabot> mapM f as = sequence (map f as)
11:21:06 <aristid> :t mapM (flip [toLower, toUpper])
11:21:08 <lambdabot> [Char] -> [[Char]]
11:21:15 <aristid> > mapM (flip [toLower, toUpper]) "abc"
11:21:17 <lambdabot>   ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
11:21:22 <aristid> yay!
11:21:29 <danm_> cool
11:21:36 <bluej774> I'm trying to port this to Haskell: http://pastebin.com/ZbCLGUes
11:21:38 <mauke> The paste ZbCLGUes has been copied to http://hpaste.org/54180
11:21:48 <bluej774> This is my attempt: http://pastebin.com/ndrCs4S2
11:21:51 <ski> > mapM (flip [toLower, toUpper]) "o.o"
11:21:51 <mauke> The paste ndrCs4S2 has been copied to http://hpaste.org/54181
11:21:52 <lambdabot>   ["o.o","o.O","o.o","o.O","O.o","O.O","O.o","O.O"]
11:22:11 <hpaste> koral pasted “Clipboard with xlib” at http://hpaste.org/54182
11:22:15 <sp3ctum> ski, awesome
11:22:26 <bluej774> Can anyone tell me what's wrong with my code?  It doesn't yield the same result as the original code.
11:22:51 <aristid> ski: just to show how haskell can not just be used for pointless fibonacci sequences
11:23:26 <ski> s/pointless/pointfree/ :)
11:23:33 <aristid> :D
11:23:42 <aristid> this is pointfree too *yay*
11:24:22 <k0ral> I noticed the Clipboard package is missing the linux implementation, so I gave it a try: http://hpaste.org/54182
11:24:40 <k0ral> this is the "copy" part
11:24:48 * ski cringes at `paramInt',`paramDouble1',&c.
11:24:58 <k0ral> comments welcome (even if this is a very short piece of code)
11:25:08 <bluej774> ski: Yeah, not my code.
11:26:08 * djanatyn tries to write the sieve of eratosthenes
11:26:09 * ski wonders which of `*' and '>>' binds most tightly
11:27:06 <bluej774> I think I tested that part and got the same results in both languages.
11:27:36 <roconnor> > (3 * 4 >> 5) ()
11:27:37 <lambdabot>   5
11:28:18 <roconnor> > (3 * (4 >> 5)) ()
11:28:19 <lambdabot>   15
11:28:28 <roconnor> ski: *
11:30:32 <Botje> bluej774: you call flip with w, not with w'
11:30:59 <bluej774> AH!
11:31:05 <bluej774> Oops!  Nice catch.
11:31:26 <bluej774> I was so distracted with Haskell itself, I forgot where my brain was.
11:32:11 <Botje> you should make lines 8 -- 11 a case too
11:32:24 <ski> bluej774 : the C code divides all the branches with `128.0D', your Haskell code only divides the last branch
11:32:39 <ski> roconnor :)
11:32:51 <bluej774> ski: not true.  Check the def for result.
11:33:17 <d34df00d> Hi!
11:33:30 <d34df00d> Is there something in Hackage for working with sets of intervals (open and closed)?
11:33:43 <ski> bluej774 : ah, you're right, i missed the one in `result'
11:33:56 <ski> (i'd factor out that one outside the whole conditional)
11:33:57 <d34df00d> I'd need to represent domains and codomains of functions in my GA stuff, and I'm too lazy to write that on my own :)
11:36:42 <hpaste> bluej774 pasted “new try” at http://hpaste.org/54183
11:36:51 <Cale> d34df00d: There's http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html
11:37:01 <bluej774> Check out that new code.  Still doesn't work, but it looks nicer.
11:37:08 <Cale> d34df00d: but it doesn't handle different types of endpoints
11:38:19 <bluej774> Any more suggestions?
11:38:27 <Botje> bluej774: w' .&. 0x3 is exactly w''
11:38:50 <bluej774> Yeah.  Forgot to remove that.
11:38:51 <Botje> also, can you check *all* variations of that input parameter?
11:38:57 <Botje> maybe just one branch is broken.
11:39:03 <bluej774> Still doesn't explain why the code isn't working.
11:39:18 <d34df00d> Cale: hm, I've just found http://hackage.haskell.org/packages/archive/intervals/0.2.0.3/doc/html/Numeric-Interval.html
11:41:56 <bluej774> It's not just the one branch.  I've tried several value combos and they all fail.
11:43:00 <hpaste> bluej774 pasted “My latest fail :-(” at http://hpaste.org/54185
11:43:04 <rwbarton> "What moron put an Ord instance requirement on Real!"
11:44:00 <EvanR-wo1k> srsly
11:44:52 <mah_b> bluej774: you are aware of the case fall-through in your java code?
11:45:15 <Cale> bluej774: too many magic constants!
11:45:32 <Cale> bluej774: what is this supposed to do?
11:45:33 <rwbarton> Cale: did you see the original code?
11:45:35 <bluej774> Not my code.  Just reimplementing it in Haskell
11:45:37 <Cale> no
11:45:54 <ski> mah_b : there's a `break' on all but the last `case'
11:45:58 <bluej774> Original: http://pastebin.com/ZbCLGUes
11:45:58 <mauke> The paste ZbCLGUes has been copied to http://hpaste.org/54180
11:45:59 <rwbarton> it's... pretty special
11:46:04 <edwardk> d34df00d: what are you trying to do?
11:46:13 <mah_b> oh, long lines...
11:46:23 <aninhumer> hmm I'd have to say I'm not sure `w'` is better than flip w', but then I think the problem is really the 's
11:46:35 * applicative thinks, "Magic constants??"
11:46:45 <edwardk> d34df00d: intervals is for interval arithmetic, it doesn't have a notion of open or closed endpoints
11:47:14 <bluej774> maybe this makes more sense? http://hpaste.org/54186
11:47:24 <Botje> bluej774: isn't the * 422 >> 8 bit wrong?
11:47:27 <edwardk> d34df00d: and its not as exact as i want because of a lack of usable mpfr bindings
11:47:31 * edwardk nudges copumpkin
11:47:44 * copumpkin unnudges himself and runs away
11:47:50 <Botje> bluej774: in haskell, the shiftR binds tighter than the *, in java it's the other way round
11:47:54 <ski> aninhumer : i don't think the primes are the problem
11:47:55 <bluej774> Botje: Should it be * (422 >> 8)?
11:48:02 <edwardk> he really did run away. he fled his desk after typing that
11:48:26 <applicative> bluej774: hlint is giving you incoherent advice, because you are shadowing the Prelude 'flip'
11:48:45 <bluej774> applicative: Yep, fixed that.
11:49:03 <schell> is there any way to get ghc to not print out tons of "ld: warning: text reloc in _cZh_str to _stg_ap_pppppp_info" warnings when compiling?
11:49:16 <aninhumer> ski: I was just making a subjective comment on code ugliness, not correctness :P
11:49:33 <ski> heh, ok
11:49:45 <dafis> schell: easy, use an older Mac
11:49:54 <schell> ;)
11:49:58 <bluej774> Botje: Should I wrap  (w * 422) or (422 >> 8)?
11:50:28 <dafis> or a newer ghc, has been recently fudged to not print the warnings anymore
11:50:32 * ski refrains from mentioning ..
11:50:47 <schell> cool - so just redownload the platform?
11:51:01 <tibbe> Which package defines the Monoidal type class (*not* Monoid)?
11:51:08 <Botje> bluej774: if you want to emulate the java stuff, you should do w' = (w * 422) `shiftR` 8
11:51:30 <tibbe> edwardk: ^^
11:51:39 <dafis> schell: I think as for now, you'd need HEAD, though perhaps it's already in 7.2.2
11:51:47 <bluej774> THANKS!  That fixed it.
11:51:52 <Botje> yay.
11:52:02 <Botje> now kick whoever used such crappy variable names :)
11:52:04 <copumpkin> tibbe: category-extras had one
11:52:06 <edwardk> tibbe: categories ?
11:52:15 <tibbe> :)
11:52:15 <applicative> Botje++
11:52:17 <tibbe> thanks
11:52:17 <rwbarton> the variable names are not even the biggest problem in the original code
11:52:25 <tibbe> hoogle doesn't know
11:52:29 <edwardk> https://github.com/ekmett/categories/blob/master/Control/Category/Monoidal.hs
11:52:44 <edwardk> that was where i splintered it after whacking category-extras
11:52:52 <d34df00d> edwardk: well, I'd like to store the information that logarithm is defined at (0, +inf), and that sin's codomain is [-1; 1], so that I won't try to construct an expression like (ln (sin x)).
11:52:55 <schell> eh - the platform comes with 7.0.3
11:53:15 <edwardk> d34df00d: you'll need your own interval class for that i'm afraid
11:53:24 <d34df00d> Oh :(
11:53:42 <edwardk> d34df00d: you can only express closed intervals with the one from that package
11:54:22 <edwardk> also its subtly wrong under floating point rounding error, hence the need for mpfr
11:54:27 * edwardk pokes copumpkin again
11:54:53 <d34df00d> edwardk: well, most functions' domains/codomains have borders at "good" points.
11:54:53 * copumpkin unpokes himself and runs away screaming
11:55:01 <d34df00d> So I doubt such problem would arise.
11:55:14 <ski> edwardk : he really screamed ? :)
11:55:14 <edwardk> d34df00d: then feel free to use it =)
11:55:26 <edwardk> nah, it was more of a snicker. NOW he screams
11:56:05 <djanatyn> hmm. how can I use currying to create a function that tests if a number is a multiple of 5? :)
11:56:05 <edwardk> it wasn't a very sincere scream though
11:56:21 <djanatyn> I'm trying to use it with filter and I don't think a lambda is appropriate here
11:56:26 <edwardk> djanatyn: first write it without currying, how does it look?
11:57:04 <djanatyn> multipleOfFive x = if 5 `mod` x == 0 then True else False
11:57:19 <edwardk> :t 5 `mod` x == 0
11:57:20 <lambdabot> Bool
11:57:25 <edwardk> :t \x -> 5 `mod` x == 0
11:57:26 <lambdabot> forall t. (Integral t) => t -> Bool
11:57:28 <d34df00d> Hmmm, how could I better express infinity value then?
11:57:52 <djanatyn> ah, yeah.
11:57:54 <d34df00d> Storing the result of (1/0) seems like a bad idea to me.
11:57:58 <djanatyn> Can I do this with currying?
11:58:00 <byorgey> djanatyn: if foo then True else False should always be replaced with just 'foo'
11:58:06 <edwardk> (==) 0 . mod 5
11:58:14 <dafis> edwardk: x `mod` 5
11:58:14 <djanatyn> oh yeah :D
11:58:29 <djanatyn> I think the lambda is more readable
11:58:30 <ski> djanatyn : `if ... then True else False' can always be simplified to `...'
11:58:33 <edwardk> dafis: good point =)
11:58:47 <djanatyn> ...y'know, maybe I should just use a list comprehension here
11:58:47 <edwardk> (==) 0 . flip mod 5
11:58:56 <edwardk> or (==) 0 . (`mod` 5)
11:59:02 <dafis> ski: if ... == True then True else False
11:59:08 <edwardk> or (== 0) . (`mod` 5)
11:59:11 <edwardk> etc
11:59:13 <Nimatek> > let mul5 = (== 0) . (mod 5) in mul5 10
11:59:14 <ski> or  (0 ==) . (`mod` 5)
11:59:14 <lambdabot>   False
11:59:21 <edwardk> yeah
11:59:42 <ski> dafis : yah, that can be simplified even more :)
11:59:47 <Nimatek> > let mul5 = (== 0) . (`mod` 5) in mul5 10
11:59:48 * hackagebot blaze-textual 0.2.0.5 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.5 (BryanOSullivan)
11:59:48 <lambdabot>   True
12:00:06 <edwardk> personally. i'd just define isDividedBy x y = …   then use filter (isDividedBy 5)
12:00:07 <copumpkin> if (p == True) then if (q == True) then False else True else if (q == False) then False else True
12:00:25 * edwardk makes copumpkin scream again
12:00:39 <djanatyn> okay, sweet
12:01:01 <jem|osx> Is there a way of calculating the factorial of a number by putting all the numbers under it in a list and multiplying them from there?
12:01:07 <edwardk> er isDivisibleBy
12:01:20 <ski> > product [1 .. 5]
12:01:21 <lambdabot>   120
12:01:22 <edwardk> > product [1..10]
12:01:23 <lambdabot>   3628800
12:01:24 <hpc> > let fact n = product [1..n] in fact 5
12:01:25 <lambdabot>   120
12:01:27 <dafis> > product [2 .. 100]
12:01:29 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
12:01:42 <edwardk> dafis: optimizer!
12:01:43 <jem|osx> ah thanks
12:01:55 * ski wins the "first answer" competition
12:01:55 <incluye> > printf "%d" (product [2..100])
12:01:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:01:57 <lambdabot>    `Text.Printf.PrintfType ...
12:02:02 <copumpkin> > join (liftA2 (\p q -> (p, q, if (p == True) then if (q == True) then False else True else if (q == False) then False else True))) [minBound..maxBound]
12:02:03 <dafis> edwardk: I can't help it, it's genetic
12:02:03 <lambdabot>   [(False,False,False),(False,True,True),(True,False,True),(True,True,False)]
12:02:52 <rwbarton> @pl \p q -> if (p == True) then if (q == True) then False else True else if (q == False) then False else True
12:02:52 <copumpkin> @check (\p q -> (p /= q) == (if (p == True) then if (q == True) then False else True else if (q == False) then False else True)))
12:02:52 <lambdabot> (`ap` flip (flip if' False . (False ==)) True) . (. flip (flip if' False . (True ==)) True) . if' . (True ==)
12:02:53 <lambdabot>  Unbalanced parentheses
12:02:58 <copumpkin> @check (\p q -> (p /= q) == (if (p == True) then if (q == True) then False else True else if (q == False) then False else True))
12:02:59 <lambdabot>   "OK, passed 500 tests."
12:03:03 <copumpkin> yay!
12:03:10 <ski> rwbarton : already tried it -- doesn't work
12:03:13 <jem|osx> w00t
12:03:16 <jem|osx> thanks gusy
12:03:21 <jem|osx> guys*
12:03:23 <copumpkin> the power of booleannesssssyness
12:03:31 * ski wonders when `check' got fixed
12:03:39 <aninhumer> > (show $ product [2..99]) ++ "00"
12:03:41 <lambdabot>   "93326215443944152681699238856266700490715968264381621468592963895217599993...
12:03:45 <hpc> > True + False -- does λbot have mod-2 arithmetic?
12:03:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
12:03:46 <lambdabot>    arising from a use of `GHC.N...
12:03:48 <aninhumer> optimised amirite :P
12:03:49 <DukeDave> Gah: reactive-banana-wx-0.4.3.0 depends on cabal-macosx-0.1.2.2 which failed to install.     <---- Anyone  :|
12:03:50 <Cale> okay, implemented dC
12:03:59 <mauke> > True .|. False
12:04:00 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
12:04:00 <lambdabot>    arising from a use of `Da...
12:04:00 <Cale> err
12:04:14 <hpc> mauke: what an unfortunate symbol for an operator
12:04:15 <Cale> Where'd bluej go?
12:04:31 <mauke> hpc: watch me use (.)(.)(.)
12:04:31 <ski> > Any True `mappend` Any False
12:04:33 <lambdabot>   Any {getAny = True}
12:04:33 <dafis> DukeDave: what was the cause of failure
12:04:34 <copumpkin> > toEnum (((+) `on` fromEnum) True True) :: Bool
12:04:34 <ski> > Any True `mappend` Any True
12:04:36 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
12:04:36 <lambdabot>   Any {getAny = True}
12:04:44 <copumpkin> dammit
12:05:02 <EvanR-wo1k> totalRecall = (.)(.)(.)
12:05:11 <incluye> @unpl (.)(.)(.)
12:05:11 <lambdabot> (\ c e f i -> c (e f i))
12:05:16 <mauke> > (.)(.)(.) fromEnum (||) True False
12:05:18 <lambdabot>   1
12:05:35 <DukeDave> dafis: Distribution/MacOSX.hs:44:8:
12:05:35 <DukeDave>     Could not find module `Distribution.MacOSX.AppBuildInfo':
12:05:38 <hpaste> Cale pasted “bluej's terrible terrible mess” at http://hpaste.org/54188
12:05:55 <limansky> Hi all. Could anybody help me with attoparsec?
12:05:55 <DukeDave> I should note that I'm not on OS X
12:06:00 <hpaste> djanatyn pasted “starting on the sieve” at http://hpaste.org/54189
12:06:06 <djanatyn> hmm :\
12:06:08 <mauke> also, (_|_) is "bottom"
12:06:14 <applicative> Cale, you've got a redundant bracket in there
12:06:16 <djanatyn> kinda works
12:06:17 <EvanR-wo1k> haskell is the porn language
12:06:28 <djanatyn> except, I'm not exactly sure what I was doing in the first place
12:06:28 <Cale> applicative: yeah
12:06:42 <Cale> applicative: hah
12:06:48 <dafis> EvanR-wo1k: Haskell's fun, but not that much fun ;)
12:07:14 <Cale> There's a lot worse things about that code than a redundant bracket, but it's a starting point for the translation/simplification process.
12:07:48 <Nimatek> dafis: Haskell is more fun than porn.
12:08:25 <KSkrzet> in what way the 'main' thread is different from others performance wise? I recall reading somewhere that main thread is bad for some kinds of calculations
12:09:22 <applicative> Cale, sorry,  I was just thinking "what makes people write  "-paramDouble3 + paramDouble2 blah blah..."", when I saw hlint's complaint
12:09:47 * hackagebot marionetta 0.1 - A study of marionetta movements.  http://hackage.haskell.org/package/marionetta-0.1 (PaoloVeronelli)
12:10:23 <DukeDave> Oh cute, it's failed here too: http://hackage.haskell.org/packages/archive/cabal-macosx/0.1.2.2/logs/failure/ghc-7.2
12:10:25 <Cale> KSkrzet: uhh...
12:10:40 <DukeDave> ^ Is that significant? Should I be shouting loudly at the maintainer? :)
12:10:47 <KSkrzet> I recall there was something with MVar's etc.
12:10:54 <Cale> KSkrzet: The only difference I'm aware of between the main thread and other threads is that when the main thread finishes, the entire program finishes.
12:10:55 <applicative> DukeDave, I've never managed to install it, not that that proves anything.
12:10:59 <dafis> DukeDave: a glitch in the .cabal, 0.1.2.1 or 0.2 should work, I think
12:11:13 <Cale> KSkrzet: any difference beyond that is likely a bug
12:11:51 <KSkrzet> Cale: wasn't that main was the thread performing all IO? or something like that.
12:12:35 <Cale> KSkrzet: all threads are allowed to perform IO...
12:12:42 <Cale> er, as far as I know
12:13:07 <Cale> and Haskell threads get transferred between worker threads "randomly" anyway
12:13:34 <DukeDave> applicative:  dafis: Yep, previous version is okay..
12:13:39 <DukeDave> (0.1.2.1)
12:14:10 <Cale> unless you use forkOS, which creates a bound thread which you might need for use with foreign libraries that make use of thread-local state
12:14:30 <Cale> forkOS doesn't affect thread scheduling in any way though
12:14:47 <mauke> I thought forkOS'd threads still migrate, they just send foreign calls over to another thread
12:14:59 <Cale> Oh, that's possibly the case too
12:15:08 <copumpkin> yep
12:15:16 <copumpkin> you can actually set thread affinity now
12:18:43 <hpc> but you need to know the number of capabilities to do affinity sanely
12:18:47 <hpc> afaik
12:19:10 <augur> dmwit: meh
12:19:15 <KSkrzet> you can get them
12:19:20 <augur> i was thinking of >>= and figured it wasnt just about infixes
12:19:22 <augur> interesting
12:19:29 <dmwit> =)
12:19:32 <augur> also, agda
12:19:42 <augur> \Sigma X \ x -> y
12:19:45 <dmwit> But, for infix, I think I might agree that foo >>= x -> e looks quite nice.
12:19:46 <augur> is perfectly valid agda
12:20:26 <copumpkin> in agda, you also couldn't use an undelimited ->
12:20:30 <copumpkin> because -> could be a type
12:20:42 <augur> copumpkin: true!
12:20:46 <copumpkin> I've written \x -> x -> Set many times
12:20:56 <augur> ditto
12:21:11 <augur> im curious why agda chose the haskell route of \x -> y instead of the traditional \x.y
12:21:35 <ski> or maybe `\x |-> y'
12:21:38 <copumpkin> because the dot is already hugely ambiguous
12:22:07 <augur> no, |-> would be bad, ski, because mapsto implies that its a function not a lambda term
12:22:26 <augur> i mean, its not totally bad, but they mean different things
12:22:35 <ski> augur : i don't understand the complaint
12:23:18 <ski> if you're talking about "function" as in "morphism in a category", then you could say `\x |-> y' means `\(x |-> y)', where `\' converts from the morphism to the element in the exponential
12:23:18 <hpc> augur: because spaces make for easy parsing
12:23:40 <augur> ski: sure except lambdas are still not morphisms
12:23:46 <dmwit> > (\x->3)5
12:23:47 <lambdabot>   3
12:24:02 <ski> augur : i never claimed they was
12:24:02 <dmwit> hpc: What spaces are you talking about?
12:24:11 <copumpkin> augur: lambdas = function literals
12:24:19 <augur> copumpkin: not mathematical functions
12:24:19 <hpc> dmwit: in agda
12:24:26 <dmwit> aha
12:24:26 <augur> they're "functions" in programming terms
12:24:29 <DukeDave> Cabal people, is there anyway I can use "-package-conf" with a cabal build? :|
12:24:29 <augur> but not mathematical terms
12:24:36 <copumpkin> what breaks in mathematical terms?
12:24:56 <augur> well, im not saying anything "breaks", as such, but that they mean different things
12:25:04 <copumpkin> how do they differ?
12:25:07 <augur> uh
12:25:16 <augur> computations are not mathematical truths?
12:25:22 <dmwit> copumpkin: One is a term and one is a set of pairs. =)
12:25:33 <copumpkin> meh
12:25:40 <ski> dmwit : the term only exists in the meta-language
12:25:44 <augur> (\f.f f) (\f.f f) does not terminate but it can be assigned a perfectly good denotation?
12:25:49 <dmwit> (And defining a mapping from terms to sets of pairs is a tricky endeavor that's easy to get wrong.)
12:26:16 <augur> infact, (\f.f f) can be assigned an infinite number of denotations, even if it's the only function in the domain
12:26:29 <dmwit> Anyway, I'm not sure I understand why that makes |-> a bad syntax. It's just syntax.
12:26:31 <DukeDave> Someone else cares: http://stackoverflow.com/questions/6920967/how-can-one-register-a-package-built-with-cabal-dev
12:26:44 <monochrom> at least "functions" and "programming" terms in #haskell are referentially transparent
12:26:44 <dmwit> It's annoying syntax, but not _bad_.
12:26:47 <augur> dmwit: all im saying is that it implies something that might not be desirable
12:26:49 <copumpkin> augur: are the uncomputable reals invalid?
12:27:15 <augur> copumpkin: im not sure what you mean
12:29:03 <EvanR-wo1k> copumpkin: reals are either computable, or not computable, true/false? ;)
12:31:08 <dmwit> Ummm... false. I'm going to go with false. I think I may have heard that one before, though, so... kind of cheating.
12:32:22 <EvanR-wo1k> is it false
12:33:30 <dmwit> (It was a reference to a popular video game.)
12:33:59 <EvanR-wo1k> yes i got that late, i only played it once, all the way through without sleeping
12:34:34 <copumpkin> I loved the second one
12:34:45 <copumpkin> portal, that is
12:34:57 <dmwit> Yeah, the first portal is kind of lame. Can't even walk through it until there's two.
12:35:23 <copumpkin> lol
12:35:26 <copumpkin> I loved the first one too
12:35:38 <copumpkin> but I know what you mean ;)
12:35:54 <dmwit> Have you done the multiplayer?
12:36:03 <copumpkin> nope
12:36:07 <dmwit> oh gosh
12:36:11 <dmwit> Would you like to?
12:36:15 <EvanR-wo1k> > map length . group . sort . concat $ cake
12:36:16 <dmwit> I've been looking for an unspoiled partner...
12:36:17 <lambdabot>   [162,3,4,4,43,1,1,1,1,1,5,3,1,8,2,1,10,1,2,9,1,91,28,53,50,156,8,30,47,62,7...
12:36:19 <copumpkin> hmm, is it good?
12:36:24 <copumpkin> I'd need to reinstall it
12:36:27 <dmwit> Dunno, I haven't done it. =P
12:36:41 <EvanR-wo1k> i havent either
12:36:48 <EvanR-wo1k> but i dont have a ps3
12:36:53 <copumpkin> dmwit: omg when you come to hac boston we can waste time here playing it locally :D
12:36:54 <DanBurton> #haskell people are the sort that love timey-wimey spacetime portal-y thingies :)
12:36:54 <ski> augur : anyway, `(\f.f f)' isn't well-typed in consistent type systems
12:37:29 <dmwit> copumpkin: omg omg
12:37:33 <EvanR-wo1k> i heard they were going to drop portals from portal2
12:37:37 <copumpkin> dmwit: and by that point I'll have enough free space on my machine to actually reinstall it
12:37:44 <EvanR-wo1k> then decided against it
12:37:58 <DanBurton> EvanR-wo1k: wouldn't be much of a "portal" game without portals -_-
12:38:04 <EvanR-wo1k> ye
12:38:29 * DanBurton highly doubts the narbacular drop team would just throw away all of their hard work on the portal mechanic
12:38:37 <EvanR-wo1k> i got it to glitch out
12:38:51 <EvanR-wo1k> if you notice, your character reaches terminal velocity almost immediately
12:38:54 <EvanR-wo1k> but fluids dont
12:38:57 <EvanR-wo1k> so
12:39:09 <EvanR-wo1k> fluids continue to accelerate forever
12:49:50 * hackagebot base16-bytestring 0.1.1.3 - Fast base16 (hex) encoding and decoding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.3 (BryanOSullivan)
12:54:50 * hackagebot mysql 0.1.1.3 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.1.3 (BryanOSullivan)
12:57:20 <MHD> something has been bugging me for a while: if the type of a class plymorphic call can be determined at compile time, is it optimized?
12:58:49 <mauke> I think so because at that point it's basically just inlining and constant folding </handwave>
12:59:10 <MHD> yeah
12:59:20 <MHD> language design is messing with my head
13:00:27 <rwbarton> I don't think it will always be
13:01:08 <MHD> I am just looking into a way to use the class feature of haskell in an imperative language
13:01:16 <MHD> instead of traditional oo classes
13:01:37 <MHD> and then also using them as interfaces and mixins
13:02:01 <rwbarton> dictionary passing is the simplest translation
13:04:50 * hackagebot mysql-simple 0.2.2.3 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.2.3 (BryanOSullivan)
13:04:52 * hackagebot text-format 0.3.0.6 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.6 (BryanOSullivan)
13:05:33 <dafis> Ah, Bryan has upload day
13:07:50 <Sgeo|web> Why is the plugins package documentation non-functional and build error?
13:08:08 <Sgeo|web> Oh, n/m the documentation thing
13:08:15 <Sgeo|web> Still worried about the build error http://hackage.haskell.org/package/plugins
13:08:26 <Sgeo|web> Oh, that's for 7.2, I guess
13:09:46 <alexdavey> Hi, are there any good point cloud visualisation libraries written in Haskell?
13:13:20 <Sgeo|web> :i Typable
13:13:26 <Sgeo|web> :i Typeable
13:14:16 <cr7> so wat v do
13:14:51 * hackagebot double-conversion 0.2.0.3 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.2.0.3 (BryanOSullivan)
13:14:52 * hackagebot tagsoup 0.12.5 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.5 (NeilMitchell)
13:14:55 * hackagebot resource-pool 0.2.0.3 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.0.3 (BryanOSullivan)
13:14:59 <ski> platzhirsch : ##cs ?
13:16:26 <platzhirsch> ski: exactly, thanks
13:17:42 <roconnor> @where TTFP
13:17:43 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
13:23:31 <_Mikey> hey guys
13:23:41 <_Mikey> I have a question ;/
13:23:53 <mauke> I have answers
13:24:04 <hpc> i have a laptop
13:24:06 <periodic> hopefully they match.
13:24:12 <_Mikey> -.-
13:24:17 <_Mikey> I love you guys
13:24:26 <mauke> my first answer is: because every symlink is also a hard link
13:24:35 <mauke> you better ask the right question now
13:24:38 <_Mikey> I'm attempting to compile some boilerplate code
13:24:43 <_Mikey> 2 seconds
13:24:47 <_Mikey> let me hpaste
13:25:20 <periodic> My answer was going to be 'rm -rf /'
13:25:25 <hpaste> Anon pasted “moduleConflict?” at http://hpaste.org/54198
13:25:36 <_Mikey> :(
13:25:46 <_Mikey> why do you want to clean me out?
13:26:03 <mauke> > 'rm -rf /'
13:26:04 <lambdabot>   <no location info>:
13:26:04 <lambdabot>      lexical error in string/character literal at chara...
13:26:16 <periodic> Solves a lot of problems to just get rid of the source of the problem.
13:26:24 <_Mikey> so ghc says it doens't know which module to grab clear and $= from
13:26:25 <periodic> no compiler = no compiler errors
13:26:32 <hpc> _Mikey: doesn't look wrong so far
13:26:35 <_Mikey> that is true
13:26:53 <RichardBarrell> mauke: awful long glyph you have there, far as single codepoints go. :)
13:27:02 <hpaste> MHD annotated “moduleConflict?” with “moduleConflict? (annotation)” at http://hpaste.org/54198#a54199
13:27:30 <mauke> _Mikey: what's the actual message?
13:27:50 <_Mikey> the actual message
13:28:10 <_Mikey> Ambiguous occurance
13:28:15 <mauke> no
13:28:18 <_Mikey>   Ambiguous occurrence `ColorBuffer'
13:28:18 <_Mikey>     It could refer to either `Graphics.Rendering.OpenGL.ColorBuffer', imported from Graphics.Rendering.OpenGL at openGLtest.hs:1:0-31
13:28:18 <_Mikey>                           or `Graphics.UI.GLUT.ColorBuffer', imported from Graphics.UI.GLUT at openGLtest.hs:2:0-22
13:28:33 <MHD> _Mickey: I annotated your paste
13:28:42 <_Mikey> I saw ;) thank MHD
13:29:05 <MHD> _Mickey: Don't need both glutton and oogle
13:29:13 <_Mikey> so GLUT includes opengl
13:29:18 <MHD> yup
13:29:32 <MHD> if you go look at the documentation for glut it says so too.
13:29:40 <_Mikey> would that code throw ambiguity errors on any machine/
13:29:50 <RichardBarrell> GLUT depends on OpenGL. It's a really small library for starting OpenGL contexts.
13:29:52 <_Mikey> I'd imagine it ould.
13:30:14 <RichardBarrell> If you have working GLUT then by definition you have already made OpenGL work too. :)
13:30:15 <tibbe> What are the import rules for type classes again. If I import a module that imports a module that defines an instance of a type class, is that instance in scope?
13:30:47 <Nimatek> I remember SDL and SFML being vastly superior to GLUT, but don't know about the state of Haskell bindings for them.
13:30:51 <MHD> only if the first module exports the second
13:31:00 <hpc> tibbe: you get instances only from modules you import
13:31:07 <tibbe> right
13:31:07 <_Mikey> I love SDL when I'm getting my C++ on
13:31:08 <hpc> (or that get re-exported/imported)
13:31:16 <MHD> Nimatek: Does SFML allow multiple windows?
13:31:31 <rwbarton> There's no way not to re-export an instance that you import though
13:32:16 <_Mikey> hmm
13:32:18 <rwbarton> this is to ensure coherency of instances
13:32:27 <_Mikey> now I get a bunch of undefined errors
13:32:48 <Nimatek> MHD: I don't know, I haven't used that functionality.
13:32:48 <_Mikey> and by a bunch I'm talking in the region above 9000
13:33:15 <mauke> _Mikey: compiling with --make?
13:33:32 <_Mikey> with ghc filename
13:33:56 <_Mikey> I need to add make tags to compile included modules?
13:34:04 <_Mikey> the make tag*
13:34:30 <rwbarton> --make means "please link my program against the libraries it needs"
13:35:20 <MHD> isn't make the default for ghc 7?
13:35:29 <Nimatek> MHD: But it should: http://www.sfml-dev.org/tutorials/1.2/window-opengl.php
13:36:09 <_Mikey> omg guys
13:36:21 <_Mikey> @karma rwbarton
13:36:22 <lambdabot> rwbarton has a karma of 10
13:36:27 <hpc> --make is the "everything is easy" flag, more or less
13:36:27 <_Mikey> @karma MHD
13:36:28 <lambdabot> MHD has a karma of 0
13:36:36 <byorgey> shachaf: oh, sorry, I was wondering what you meant about the "import renaming" thing in typeclassopedia
13:36:55 <_Mikey> so it probably is bad to abuse it right?
13:37:15 <rwbarton> it?
13:37:20 <rwbarton> do you mean --make?
13:37:25 <_Mikey> it --make
13:37:26 <_Mikey> ues
13:37:28 <_Mikey> yes8
13:37:31 <_Mikey> -.-
13:37:52 <rwbarton> Basically you should always use --make unless you know what you are doing
13:38:05 <_Mikey> ok I'll stick to --make for now
13:38:13 <_Mikey> but I really want to know what I'm doing eventually
13:38:15 <copumpkin> --make isn't necessary with newer versions
13:39:30 <monochrom> eventually you use cabal
13:39:33 <_Mikey> hmm
13:39:48 <_Mikey> copumpkin, I'm running 6.12.1,
13:39:57 <copumpkin> then yeah
13:39:57 <_Mikey> is that bad?
13:40:04 <copumpkin> it's old
13:40:05 <hpc> _Mikey: it's old
13:40:07 <_Mikey> ah
13:40:11 <_Mikey> oooh
13:40:11 <copumpkin> so you still need --make for it
13:40:18 <_Mikey> ok
13:40:21 <hpc> (incidentally, im running the same version)
13:40:38 * _Mikey highfives hpc
13:40:49 <_Mikey> ok I better get back to it.. thanks guys!
13:40:58 <thoughtpolice> is it just me, or has GHC gotten like, a billion times more awesome in the next coming release?
13:41:07 <thoughtpolice> polykinds and constraint kinds!
13:41:10 <hpc> thoughtpolice: it's 100% ghc
13:41:33 <periodic> The rate of change in GHC has been really fast too.
13:41:49 <ski> thoughtpolice : hm, does "polykinds" mean that we now get polymorphic types ?
13:41:49 <periodic> I caught myself using 6.12 on a system the other day and was surprised how many features it didn't have.
13:42:10 <hpc> ski: it means you get kind-polymorphic types ;)
13:42:17 <thoughtpolice> ski: we get polymorphic kinds. so we can say, 'data N = Z | S', and then a vector type can be 'data Vec (sz :: N) ty = ...'
13:42:21 <thoughtpolice> (as a simplistic example)
13:42:29 <ski> hpc : yeah, which is what polymorphic types are
13:42:37 <thoughtpolice> so it effectively lifts data types into the kind level.
13:42:39 <shachaf> byorgey: Oh, I was making a joke about how outdated it was ("import renaming" was removed in Haskell 1.3).
13:42:42 <thoughtpolice> ISTR the original plan being much different
13:42:53 <ski> hpc : i.e. stuff like `Flip :: forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *'
13:42:57 <hpc> ski: you could have meant parametric polymorphism
13:43:23 <monochrom> what?! there was import renaming once upon a time? so I was a moron when I suggested import renaming last year?
13:43:45 <hpc> thoughtpolice: so we get dependent types?
13:43:48 <shachaf> monochrom: import renaming existed but it was removed at the sam time that import qualified was added.
13:43:52 <ski> hpc : and `MkFlip :: forall_kind k0 k1. forall (f :: k1 -> k0 -> *) (a0 :: k0) (a1 :: k1). f a1 a0 -> Flip f a0 a1'
13:43:55 <periodic> oh hey, Kinds are neat.  I tried something similar once with known-depth trees and got discouraged at how complex it became.
13:44:08 <byorgey> shachaf: ohhh, now I get it =)
13:44:29 <thoughtpolice> hpc: squint a little ;)
13:44:40 <ski> thoughtpolice : i don't see how that has anything to do with polymorphism
13:44:45 <shachaf> byorgey: (I have no idea if Typeclassopedia is actually outdated; I was just going along with the theme.)
13:45:06 <byorgey> shachaf: it is somewhat outdated in a few places.
13:45:41 <thoughtpolice> ski: i'm merely referring to it the way it has been described; i presume the implication is that 'kinds are no longer restricted to e.g. *' (there are other kinds already yes but i'm just being simplistic)
13:49:03 <ski> thoughtpolice : anyway, by "polymorphic type" i mean like a type `Flip' with kind `forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *', together with that, one would want kind-polymorphic values, like a constructor `MkFlip' whose type `forall_kind k0 k1. forall (f :: k1 -> k0 -> *) (a0 :: k0) (a1 :: k1). f a1 a0 -> Flip f a0 a1' quantifies over kinds
13:49:35 <hpc> does this mean we are getting sorts in ghc 8? :D
13:50:06 <thoughtpolice> ski: ah ok, that makes more sense.
13:51:57 <ski> thoughtpolice : compare this with a "(type-)polymorphic value" like `[Nothing] :: forall a. [Maybe a]' or `Left False :: forall a. Either Bool a' or `map :: forall a b. (a -> b) -> ([a] -> [b])'
13:53:02 <bscarlet> > 1
13:53:02 <lambdabot>   1
13:53:10 <bscarlet> > fmap (+1) (2,3)
13:53:11 <lambdabot>   (2,4)
13:53:53 <bscarlet> Where's the instance of Functor ((,) a)? My ghc isn't finding it.
13:54:05 <hpc> Control.Monad.Instances?
13:54:16 <bscarlet> Thanks!
13:54:19 <ski> or maybe `Control.Monad.Writer'
13:55:25 <DukeDave> Are there any reactive banana people around?
13:55:53 <bscarlet> I wish the haddock generated list of instances below a class's documentation included source links for the instances.
13:59:52 * hackagebot snappy 0.2.0.1 - Bindings to the Google Snappy library for fast compression/decompression  http://hackage.haskell.org/package/snappy-0.2.0.1 (BryanOSullivan)
13:59:54 * hackagebot HDBC-mysql 0.6.5.1 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.5.1 (BryanOSullivan)
14:02:20 <statusfailed> How do I get lambdabot to evaluate a function?
14:02:20 <chrisdone> what's the word for a list that only contains unique elements/contains no duplicates?
14:02:24 <statusfailed> chrisdone: nub?
14:02:35 <chrisdone> statusfailed: as a predicate
14:03:03 <hpc> > "like this"
14:03:04 <lambdabot>   "like this"
14:03:20 <chrisdone> like
14:03:24 <statusfailed> > "Test"
14:03:24 <lambdabot>   "Test"
14:03:27 <statusfailed> > let .=2 in in let .=.:[x|x<-[.+1..],let .'=takeWhile(\.''->.''*.''<=x).,all(\y->x`mod`y/=0).'] in subtract (ps!!(.*ps!!(ps!!.)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:03:28 <lambdabot>   <no location info>: parse error on input `.='
14:03:31 <statusfailed> aw
14:03:35 <statusfailed> no unicode
14:03:45 <hpc> statusfailed: it can unicode, you just typed it in wrong
14:04:01 <chrisdone> :t let does_this_list_have_duplicates xs = length xs == length (nub xs) in does_this_list_have_duplicates
14:04:02 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:04:05 <hpc> > let π = pi in π * r ** 2 :: Expr
14:04:06 <lambdabot>   pi * r**2
14:04:08 <chrisdone> what's a good name for this?
14:04:34 <statusfailed> hpc: musthave
14:04:35 <rwbarton> all_distinct?
14:04:52 <rwbarton> pairwise_distinct?
14:04:53 <statusfailed> weird, I can't seem to paste unicode in here :(
14:05:11 <chrisdone> i thought a mathy guy would have a good single word for it
14:05:20 <rwbarton> I can't think of one
14:05:22 <hpc> setLike
14:05:25 <chrisdone> rwbarton: i'll go with distinct but
14:05:47 <hpc> and i would implement it as create set, extract from set, compare
14:06:14 <chrisdone> hpc: you mean
14:06:17 <hpc> @hoogle [a] -> Set a
14:06:17 <lambdabot> Data.Set fromDistinctAscList :: [a] -> Set a
14:06:18 <lambdabot> Data.Set fromList :: Ord a => [a] -> Set a
14:06:18 <lambdabot> Data.Set fromAscList :: Eq a => [a] -> Set a
14:06:21 <chrisdone>    distinct xs = length xs == length (nub xs)
14:06:30 <chrisdone>   checkUnique f = validate f (check "should be no duplicate meta keys" distinct)
14:06:30 <chrisdone> vs import Data.Set, fromList, toList?
14:06:52 <hpc> setLike xs = (length xs) == length (toList $ (fromList xs :: Set something))
14:06:58 <statusfailed> Ah, let's try now
14:07:01 <statusfailed> > let λ=2 in in let ρ=λ:[x|x<-[λ+1..],let ρ'=takeWhile(\ρ''->ρ''*ρ''<=x)ρ,all(\y->x`mod`y/=0)ρ'] in subtract (ps!!(λ*ps!!(ps!!λ)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:07:02 <lambdabot>   <no location info>: parse error on input `in'
14:07:05 <_oz> chrisdone: fwiw, there is a well known constraint posting that predicate in constraint programming. and its name is allDifferent.
14:07:08 <statusfailed> >_>
14:07:16 <hpc> or without the type signature, if you aren't importing the universe like λbot
14:07:54 <_oz> chrisdone: http://www.emn.fr/z-info/sdemasse/gccat/Calldifferent.html
14:08:07 <hpc> oh, that's a better name
14:08:52 <chrisdone> i guess that works. technically it's two words so it's cheating. :p but if it's a more standard name, i'll use that
14:09:10 <_oz> it is sort of standard in CP at least
14:10:07 <Cale> > let let' = let in let in in_; in_ let' = let in let' in let' "in"
14:10:08 <lambdabot>   "in"
14:10:26 <statusfailed> > let l=2 in let p=l:[x|x<-[l+1..],let p'=takeWhile(\p''->p''*p''<=x)p,all(\y->x`mod`y/=0)p'] in subtract (p!!(l*p!!(p!!l)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:10:27 <chrisdone> Cale: needs more quine
14:10:28 <lambdabot>   42
14:10:31 <statusfailed> yay
14:11:05 <statusfailed> that was the best waste of time ever
14:11:21 <monochrom> PL/I anyone? :)
14:13:01 <rwbarton> the terminology here is a little tricky because both "pairwise distinct" and "all different" are things you would say about "the elements of the list", not the list itself, if you see what I mean
14:13:38 <hpc> > all different [1, 2, 3, 4, 5]
14:13:40 <lambdabot>   True
14:14:07 <alistra> @src different
14:14:08 <lambdabot> Source not found. Wrong!  You cheating scum!
14:14:14 <hpc> implmentation is an exercise for the reader
14:14:16 <rwbarton> I would never say in English "a distinct list" to mean a list whose elements are distinct; if I really needed to be able to use that construction I'd introduce an adjective for it
14:14:51 <alistra> > different
14:14:52 <lambdabot>   Not in scope: `different'
14:14:55 <blackdog>  rwbarton: non-repeating, something like that
14:15:04 <alistra> > all different [1, 2, 3, 4, 5]
14:15:05 <lambdabot>   Not in scope: `different'
14:15:08 <statusfailed> WITCHCRAFT
14:15:13 <hpc> XD
14:15:16 <_oz> what about: the list satisfies the predicate, allDifferent
14:15:19 <alistra> what
14:15:25 <hpc> (@let different = const True)
14:15:28 <_oz> or should I still say the "elements of the list"
14:15:36 <monochrom> "pairwise distinct" is fine
14:15:52 <rwbarton> well I think that's ok because allDifferent is obviously not an English word
14:16:09 <_oz> fair enough
14:16:12 <rwbarton> so you can define it to be a predicate on lists with the definition "L satisfies allDifferent if all the elements of L are different"
14:16:32 <alistra> > let l = [1,2,3,4,5] in length l == length . nub $ l
14:16:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:16:33 <lambdabot>         against inferred type ...
14:16:49 <hpc> operator precedence strikes again!
14:17:00 <alistra> > let l = [1,2,3,4,5] in length l == (length . nub $ l)
14:17:02 <lambdabot>   True
14:18:19 <statusfailed> @pl let l=2 in let p=l:[x|x<-[l+1..],let p'=takeWhile(\p''->p''*p''<=x)p,all(\y->x`mod`y/=0)p'] in subtract (p!!(l*p!!(p!!l)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:18:20 <lambdabot> (line 1, column 20):
14:18:20 <lambdabot> unexpected "["
14:18:20 <lambdabot> expecting white space or simple term
14:18:32 <hpc> pl doesn't play well with comprehensions
14:18:40 <statusfailed> oh ok~
14:18:47 <statusfailed> it's not like i'm being productive anyhow :D
14:18:54 <Cale> I don't think it knows about let either
14:18:57 <alistra> .> let l=2 in let p=l:[x|x<-[l+1..],let p'=takeWhile(\p''->p''*p''<=x)p,all(\y->x`mod`y/=0)p'] in subtract
14:18:59 <alistra>                         (p!!(l*p!!(p!!l)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:19:09 <alistra> > let l=2 in let p=l:[x|x<-[l+1..],let p'=takeWhile(\p''->p''*p''<=x)p,all(\y->x`mod`y/=0)p'] in subtract  (p!!(l*p!!(p!!l)-1)) $ round.last.takeWhile (\x -> x**x < 1/0) $ [1.0..]
14:19:10 <lambdabot>   42
14:19:29 <mzero> a question about Arrow: Is *** required to be commutative? I'm guessing' no...
14:19:32 <alistra> i don't know why all the source code tools don't share the parser with ghc :P
14:20:00 <MHD> mzero: commutative how?
14:20:14 <bscarlet> mzero: its arguments are different types.
14:20:16 <hpc> f *** g /= g *** f
14:20:26 <mzero> :t (***)
14:20:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:20:39 <mzero> I'm sorry - what I meant was,
14:20:45 <hpc> and (f *** g) >>> h /= h >>> (f *** g)
14:20:50 <mzero> is it well defined that f will be applied before g
14:20:56 <hpc> oh
14:21:07 <hpc> @src Arrow
14:21:08 <lambdabot> class Arrow a where
14:21:08 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:21:08 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:21:08 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:21:08 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:21:10 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:21:12 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:21:15 <hpc> it is not well-defined
14:21:19 <mzero> That is --- is f *** g  required to be   g *** f   but with the tuples (in and out) swapped
14:21:22 <MHD> mzero: it usually is
14:21:23 <rwbarton> it's not commutative in that sense for KleisliArrows
14:21:30 <conntrack> 8===D
14:21:48 <rwbarton> at least not normally, unless your monad is commutative I guess
14:22:01 <mzero> sure, it is for ->   --- I was going to make an instance where it was most definitely wasn't - and was wondering how much of a sin I was committing
14:22:06 <augur> ski: sure, its not well typed, fine, but it still has a trivial denotation
14:22:11 <hpc> mzero: negative sin
14:22:24 <mzero> excellent- than I shall instance away
14:23:07 <rwbarton> You might be committing a minor sin if you choose the order that's not the one the reader expects ;)
14:23:20 <MHD> mzero: f *** g is equivalent to     first f >>> second g     in most cases
14:23:29 <mzero> though I wonder if it should be defined that f *** g is equivalent to first f >>> second g   - and therefore f is "done" first
14:26:16 <Cale> The Kleisli arrow probably shouldn't be an Arrow though
14:26:31 <hpc> i still say it should have stopped at Category
14:26:45 <Cale> I think that Arrow should specify (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
14:26:49 <hpc> and wait for people to actually use that and see what abstractions pop up
14:27:25 <Cale> That naturality law is actually quite important for optimising arrow proc/do notation well.
14:27:39 <Cale> But Arrow also needs to be extended and split up a bunch too :P
14:30:56 <mzero> Cale - that would make the "natural reading order" some what unexpected, no?
14:32:07 <rwbarton> this law comes down to requiring that first f and second g commute with each other
14:32:54 <rwbarton> Which is very natural if you draw those arrow diagrams with wires and boxes
14:34:54 <d34df00d> Huh.
14:35:09 <d34df00d> https://github.com/0xd34df00d/gennl/commit/01370f06b6168d86d5bf68f630936ad022f17aea optimizes the 'rows' operation 10x.
14:47:54 <Younder> In  a problem In RWH I am trying to define a tree without Empty by Maybe. How do I go about this?
14:48:48 <bfig> Younder, what type of things do you have?
14:49:12 <bfig> Younder, what is a tree, in other words
14:50:10 <KitB> Can any of you guys tell me where I can find info about Kinetic?
14:50:16 <KitB> The canonical link is dead
14:50:16 <Younder> bfig, data Tree a = Node a (Tree a) (Tree b)
14:50:26 <KitB> (By canonical I mean the one I find everywhere)
14:50:39 <bfig> Younder, just say it out loud, what is a tree?
14:50:48 <bfig> (the recursive version)
14:51:04 <Younder> bfig, No How do I set a node to Nothing?
14:51:42 <bfig> do you understand how Maybe works?
14:51:59 <Younder> bfig, Node 1 (Node 2 Nothing Nothing) Nothing
14:52:16 <Younder> Whenever I involve Just I get and error
14:52:28 <bfig> how would you add the just?
14:52:40 <Younder> bfig, exactly
14:52:48 <bfig> i mean, do you even know where the just goes?
14:52:59 <bfig> think of the simplest trees. a tree with nothing in it
14:53:14 <bfig> then a tree with a single element (that type checks equivalently)
14:53:22 <monochrom> perhaps data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a))
14:53:26 <EvanR-work> @hoogle (a -> b, a -> c) -> a -> (b, c)
14:53:27 <lambdabot> No results found
14:53:31 <Younder> bfig, Just Node 1 Nothing Nothing
14:53:45 <bfig> Just (...)  maybe?
14:54:38 <bfig> Just (Someothercons Nothing Nothing) Nothing ?
14:54:47 <EvanR-work> help
14:55:49 <bfig> Younder, tell me how it goes
14:55:52 <DukeDave> Has anyone here used cabal configure's "--package-db=" option?
14:56:02 <Younder> bfig, Ok
14:56:11 <bfig> worked?
14:56:16 <monochrom> haskell platform's build script uses that
14:56:30 <DukeDave> It's not picking something up
14:56:41 <DukeDave> Namely, a newer version of a package
14:56:47 <EvanR-work> (a -> b, a -> c) -> a -> (b, c) ?
14:56:56 <DukeDave> Which is used when I do "ghc -package-conf"
14:57:51 <bfig> EvanR-work: \a f1 f2 -> (f1 a,f2 a) ?
14:57:58 <dr_rotflcopter> hi
14:58:19 <mauke> :t flip (join (***) . id)
14:58:20 <lambdabot> forall b c. (b, b) -> (b -> c) -> (c, c)
14:58:25 <bfig> err: \(f1,f2) a -> (f1 a, f2 a)
14:58:40 <EvanR-work> @pl \(f1,f2) a -> (f1 a, f2 a)
14:58:40 <bfig> :t \(f1,f2) a -> (f1 a, f2 a)
14:58:40 <lambdabot> uncurry (liftM2 (,))
14:58:41 <lambdabot> forall t t1 t2. (t -> t1, t -> t2) -> t -> (t1, t2)
14:58:55 <mauke> :t flip (join (***) . flip id)
14:58:56 <lambdabot> forall c a. (a -> c, a -> c) -> a -> (c, c)
14:59:08 <EvanR-work> c = c ?
14:59:23 <monochrom> haskell platform's build script ends up doing this: Setup configure --package-db=x --ghc-pkg-option=--package-conf=x  to work around a bug in Cabal 1.8.0.2
14:59:28 <Younder> bfig, Ok, got it data Tree a = Node a (Maybe (Tree a)) (Maybe (Tree a)
14:59:48 <EvanR-work> :t uncurry
14:59:50 <Younder> bfig, Then it works as expected
14:59:50 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:59:52 <bfig> Younder, how do you get the null tree?
15:00:16 <bfig> (you just described non null trees)
15:00:16 <Younder> bfig, Nothing
15:00:27 <_oz> @djinn (a -> b, a -> c) -> a -> (b, c) -- EvanR-work
15:00:27 <lambdabot> Cannot parse command
15:00:29 <bfig> i mean, Tree = nullTree
15:00:35 <_oz> @djinn (a -> b, a -> c) -> a -> (b, c)
15:00:36 <lambdabot> f (a, b) c = (a c, b c)
15:00:37 <bfig> nt = nullTree
15:00:41 <EvanR-work> > Nothing > Just 0
15:00:42 <lambdabot>   False
15:00:45 <bfig> the tree that has nothing, how do you describe it
15:00:52 <EvanR-work> > Nothing < Just 0
15:00:52 <lambdabot>   True
15:01:27 <bfig> Younder, since a tree is a node of something, you can't have empty trees
15:01:28 <mauke> data Node a = Node a (Tree a) (Tree a); type Tree a = Maybe (Node a)
15:02:25 <bfig> mauke's is the one you want to use
15:02:40 <mauke> I have factored your Maybes
15:02:42 <EvanR-work> if you allow 'nodeless' leaves you can have empty tree
15:02:46 <EvanR-work> maybe
15:02:46 <mauke> pray I don't factor them any further
15:03:02 <bfig> EvanR-work, no, you have the 1 element tree always
15:03:41 <EvanR-work> bah who decided trees have values at their forks
15:04:02 <EvanR-work> fruit is at the ends
15:04:04 <monochrom> I did
15:04:19 * Pseudonym recommends the John Hughes paper on trees, for those who haven't read it.
15:04:28 <DukeDave> monochrom: Thanks for the suggestion, unfortunately it doesn't work :(
15:04:28 <DukeDave> Curiously, when I do another build (after the configure), it doesn't attempt to re-link, although a cabal clean doesn't fix it either :(
15:05:03 <EvanR-work> nothing is always less than just something, is there a way to reverse that
15:05:10 <mauke> data GNode rec a = Node a rec rec; type GTree rec a = Maybe (GNode rec a); type Tree = Fix GTree
15:05:36 <monochrom> newtype wrapper
15:06:18 <EvanR-work> good call, would be confusing to secretly reverse it
15:08:02 <krey_> @djinn
15:08:03 <lambdabot> Cannot parse command
15:09:11 <monochrom> actually, binary search tree decided to have values at forks.
15:09:49 <EvanR-work> would it reduce performance greatly to have values only at the ends
15:09:53 <EvanR-work> seems no
15:09:58 <krey_> can I use djinn here? the aur package doesn't want to install itself :(
15:10:17 <_oz> @djinn (a,b) -> a
15:10:17 <lambdabot> f (a, _) = a
15:10:30 <krey_> cheers
15:11:45 <byorgey> krey_: if you want to use it a bunch you can also msg lambdabot privately
15:12:22 <krey_> @djinn (s -> ((s -> (a->s->r) -> r) -> s -> r) -> r) -> s -> (a->s->r) -> r
15:12:23 <lambdabot> f a b c = a b (\ d e -> d b (\ f _ -> c f e))
15:12:30 <sipa1024> @djinn ((a -> b) -> c) -> a -> b -> c
15:12:30 <lambdabot> f a _ b = a (\ _ -> b)
15:12:54 <byorgey> krey_: whoa
15:13:12 <krey_> byorgey: ;)
15:14:07 <EvanR-work> ByteStrings with length > maxBound
15:14:12 <EvanR-work> impossible?
15:15:17 <edwardk> EvanR-work: strict or lazy?
15:15:43 <etpace> Anyone happen to have harpys tutorials lying about? the website seems to be down for me ( http://uebb.cs.tu-berlin.de/harpy/ )
15:15:44 <krey_> lambdabot, why did you give me a "recursive" function? :D
15:15:57 <edwardk> EvanR-work: Int is 32 bits on 32 bit platforms, 64 on 64 bit platforms, so for strict bytestrings its impossible and for lazy ones the length is always 64 bits
15:16:02 <EvanR-work> edwardk: strict, i dont know the diff
15:16:14 <monochrom> lazy bytestring can easily have huge length
15:16:15 <edwardk> so it is impossible either way
15:16:36 <EvanR-work> i was thinking of 32bits
15:17:00 <EvanR-work> is lazybytestring lazy IO
15:17:14 <krey_> how do you ask djinn for uniqueness?
15:17:32 <edwardk> EvanR-work: well, D.B.length returns a 32 or 64 bit value depending on platform, and D.B.Lazy.length returns a 64 bit value, so in either case you won't overflow
15:17:38 <monochrom> yes, lazy bytestring's readFile etc are lazy
15:17:59 <EvanR-work> funky
15:18:06 <EvanR-work> im scared to use that
15:18:22 <byorgey> krey_: I don't think you can
15:18:33 <rwbarton> or you could produce a very long lazy bytestring with fromChunks and replicate
15:18:40 <rwbarton> or whatever
15:19:56 <EvanR-work> do i want to read the file line by line like in C or read the whole thing into a single bytestring, strict or lazy?
15:20:27 <EvanR-work> could be big
15:20:53 <monochrom> in C, you read "line by line" morally only.
15:21:49 <EvanR-work> chunk by chunk
15:27:59 * Disconnected .
15:39:29 <theddy> @type fmap
15:39:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:40:42 <theddy> Why not... forall a b (f :: * -> *). (Functor f, Functor g) => (a -> b) -> f a -> g b
15:43:00 <alistra> @src functor
15:43:01 <lambdabot> Source not found. Wrong!  You cheating scum!
15:43:04 <alistra> @src Functor
15:43:05 <lambdabot> class  Functor f  where
15:43:05 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:43:24 <alistra> @hoogle (Functor f, Functor g) => (a -> b) -> f a -> g b
15:43:27 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
15:43:27 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
15:43:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
15:43:57 <periodic> so many fmaps!
15:44:20 <periodic> <$> is just a synonym for fmap in Control.Applicative, right?
15:44:38 <periodic> I often find myself pulling in Control.Applicative just for that...
15:44:57 <krey_> @type <$>
15:44:58 <lambdabot> parse error on input `<$>'
15:45:03 <krey_> @type (<$>)
15:45:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:45:07 <theddy> And yet i still need to write fmap myself if i use different functor instances
15:45:35 <alistra> theddy: it's not a fmap then
15:45:48 <krey_> theddy: your question above is kinda weird. why do you want that to be its type?
15:45:50 <alistra> fmap works inside of the container
15:45:59 <theddy> alistra: So the question is... What is it?
15:46:09 <theddy> krey_: A little higher up
15:46:13 <alistra> theddy: you think of the name
15:46:21 <alistra> you've written it
15:46:52 <krey_> theddy: whatnow?
15:47:15 <theddy> krey_:  forall a b (f :: * -> *). (Functor f, Functor g) => (a -> b) -> f a -> g b
15:47:51 <periodic> it would be pretty hard to write a generic function that maps from one functor type to another...
15:48:31 <periodic> That signature doesn't really seem to imply any real behavior to me.
15:48:40 <alistra> would it?
15:48:51 <periodic> you'd want f and g to be the same.
15:48:56 <periodic> which is just fmap.
15:48:57 <periodic> right?
15:49:02 <rwbarton> there won't be any useful functions of that type because g could be e.g. Const Void
15:49:15 <krey_> theddy: I think you'd break one of the important properties of fmap: fmap (f.g) = fmap f . fmap g
15:49:28 <krey_> or maybe not?
15:49:51 <krey_> oh sorry, I meant fmap id = id
15:49:56 <rwbarton> (a -> b) -> f a -> g b looks like a combination of f and g being functors and having a natural transformation from f to g
15:50:37 <krey_> theddy: yes, you'd break both of those properties
15:51:54 <alistra> krey_: it can not break the composition rule
15:52:01 <alistra> but the id surely fails
15:52:22 <krey_> alistra: why not?
15:53:21 <alistra> uh
15:53:44 <alistra> you would have like
15:53:44 <YellowOnion> Is this suppose to happen? http://paste.pocoo.org/show/509483/
15:53:49 <alistra> Functors f,g,h
15:53:57 <alistra> left would f->h
15:54:09 <alistra> and right would be f->g and g->h
15:54:10 <krey_> alistra: oh you want a new functor, ok
15:54:29 <rwbarton> the "identity law" would surely just require f = g so that would be fine
15:54:33 <rwbarton> but anyways, this isn't what fmap is
15:54:34 <alistra> theddy: you can call it halfunctor
15:54:49 <alistra> theddy: you can call it halfmap
15:54:58 <alistra> because it satisfies only half of the laws :D
16:04:48 <aninhumer> alistra: semifunctor?
16:05:13 <aninhumer> works for groups
16:05:15 <alistra> wow it's starting to sound
16:05:21 <alistra> like a real thing
16:11:36 <timp_> How do I output a double quote, without it being escaped?, specifically I am trying to define a dtd declaration as a string constant, when I show or print it the escapes are still there
16:12:19 <alistra> > print '"'
16:12:20 <lambdabot>   <IO ()>
16:12:43 <alistra>  putStr "\""
16:12:46 <alistra> > putStr "\""
16:12:47 <lambdabot>   <IO ()>
16:12:51 <alistra> this ^
16:12:55 <alistra> timp_: ^
16:14:38 <periodic> show will show the quotes as escaped, but the actual string just has bare quotes in it.
16:14:49 <Cale> Remember that print = putStrLn . show, and show is intended to produce an unambiguous string representation of the value, usually suitable as source code directly.
16:15:02 <Cale> So when applied to a String, it quotes the entire string.
16:16:40 <dafis> > show ['\120' .. '\135']
16:16:41 <lambdabot>   "\"xyz{|}~\\DEL\\128\\129\\130\\131\\132\\133\\134\\135\""
16:16:52 <timp_> print '"' prints the single quotes
16:17:12 <dafis> > show ['\120' .. '\135']
16:17:13 <lambdabot>   "\"xyz{|}~\\DEL\\128\\129\\130\\131\\132\\133\\134\\135\""
16:17:23 <dafis> > text ['\120' .. '\135']
16:17:23 <lambdabot>   xyz{|}~
16:19:18 <timp_> putStr looks like it is what I want, thanks
16:58:02 <BMeph> So, is there a "printNoLn" that's the equivalent of (putStr . show)? ;)
16:58:08 <krey_> why does this give me an error: "instance (Monad m) => Monad' m where ..." flexible instances?
16:59:42 <rwbarton> what role does "flexible instances" play in that sentence?
16:59:53 <rwbarton> you need undecidable instances for that declaration
17:00:17 <dafis> krey_: because the language standard says an instance head must contain a type constructor applied to (distinct) type variables
17:00:26 <rwbarton> oh sorry
17:00:48 <krey_> dafis: how am I violating this?
17:01:04 <dafis> krey_: `m' is just a type variable
17:01:07 <sipa1024> your instance head doesn't contain a type constructor
17:01:46 <aninhumer> BMeph: I think print was intended to be a debugging tool rather than a general output tool, if you want (putStr . show) just use that :)
17:02:20 <aninhumer> or define printNoLn yourself
17:02:22 <krey_> so is this illegal too: "instance (Monad m) => Monad (SomethingT m)"? or is there a difference?
17:02:35 <sipa> there you have the constructor SomethingT
17:03:28 <sipa> krey_: know one thing: when searching for applicable instances, haskell only looks at the head; so if you have an instance Monad m => foo m, it will match for each and every type m; the constraint "Monad m" is only enforced later
17:03:49 <aninhumer> BMeph: oh wait, I missed the ;) disregard my serious answer
17:44:24 <augur> anyone know if there are good efficient prolog-like database programs?
17:45:12 <augur> not for computation so much as for data lookup (but possible with lookup involving recursively computed satisfaction)?
17:54:10 <thoughtpolice> preflex: seen kfish
17:54:10 <preflex>  kfish was last seen on #haskell 1 day, 19 hours, 23 minutes and 5 seconds ago, saying: that's what i'm doing: data families and existential wrappers
17:56:59 <kfish> hi thoughtpolice
17:57:47 <thoughtpolice> oh, hi kfish. i was just going to say i was thinking of working on vacuum. per the haskell-pkg-janitors rules, i was going to just upload it, but i figured i'd clear that (i want to clean it up a lot actually)
17:58:01 <kfish> thoughtpolice, sounds great :)
17:58:08 <thoughtpolice> and probably go ahead and use ivan's patch for his graphviz library
17:58:11 <thoughtpolice> amongst other things
17:58:18 <kfish> cool, did you get ivanm's mail about possible directions?
17:58:31 <thoughtpolice> maybe, was it on -cafe? i can search and find it i'm sure
17:58:37 <tibbe_> Is there no way to get bold markup in Haddock docs?
17:58:44 <kfish> no it wasn't on cafe, just cc'd to various people who've done vacuum-related things
17:58:57 <thoughtpolice> oh, no then.
17:59:00 <kfish> tibbe_, just emphasis (italics) i think
17:59:05 <tibbe_> that sucks
17:59:06 <kfish> thoughtpolice, what's your email address?
17:59:16 <kfish> tibbe_, yes
17:59:35 <tibbe_> italics don't work well on the web
17:59:58 <YellowOnion> I'm trying to learn haskell, I have a little python code I want to convert to haskell to help me, could someone give me some pointers to start? here's the python code: http://paste.pocoo.org/show/509530/
18:01:00 <Cale> YellowOnion: that should go reasonably smoothly :) Have you picked out a Haskell tutorial?
18:01:13 <Cale> YellowOnion: Or, have you read much already?
18:01:52 <thoughtpolice> kfish: thanks!
18:01:55 <Cale> YellowOnion: If you don't want to implement your own gcd function, the Haskell Prelude has one already
18:02:02 <Cale> > gcd 12 9
18:02:03 <lambdabot>   3
18:02:37 <kfish> thoughtpolice, also are you in the haskell-pkg-janitors github group, do you want to do it through that or do you want to actually take over maintenance yay?
18:02:53 <YellowOnion> I tried tryhaskell.org but it ended rather early, I also tried one on the meta-tutorial, but it got over my head rather quickly, I've started the learn me a haskell book, but having a couple of problems with divsion
18:03:26 <mike-burns> YellowOnion: You might want a record data structure for the screen. But maybe not.
18:03:37 <aninhumer> For that matter if you import Ratio, the operator (%) does basically what your fuction ratio does
18:03:46 <thoughtpolice> kfish: i've just got a few small things in mind at the moment, but i may get carried away like usual and do more. ;) if i do plan on taking maintenance, i'll let you know when the thought comes :)
18:03:56 <Cale> YellowOnion: sure. There are a couple things you need to be aware of with respect to division. The first is that there are two main types of division: (/) which is used for dividing fractional quantities, and div which is used to do integer division (with mod computing the corresponding remainder)
18:04:11 <thoughtpolice> in particular i think vacuum cairo has some code that helps clean up the output for graphs, which would be nice to have in vacuum itself
18:04:14 <Cale> > 12/5
18:04:15 <lambdabot>   2.4
18:04:20 <Cale> > 12 `div` 5
18:04:21 <lambdabot>   2
18:04:23 <thoughtpolice> (and would of course concern ivan's work)
18:04:26 <Cale> > div 12 5
18:04:26 <aninhumer> > 2 % 6
18:04:27 <lambdabot>   2
18:04:27 <lambdabot>   1 % 3
18:05:05 <thoughtpolice> kfish: ah, i see that's addressed here. :)
18:05:32 <Cale> If you want to convert an integer-like type of number (such as Int, Integer, Word32, etc.) to any type of number at all (including fractional types like Float or Double), then fromIntegral will do that
18:05:43 <YellowOnion> I understand that. python's '/' does integer division, and you have to import some python 3 modules to get floats out of it, or do float(int) before the division
18:06:12 <YellowOnion> I had problems with vars vs direct numbers
18:06:23 <mike-burns> In Haskell?
18:06:51 <Cale> YellowOnion: If you'd like to show us the program you're having trouble with, we might be able to offer more specific help...
18:06:54 <YellowOnion> like a = 1 and b = 2, doing a / b would throw an error, yeah in haskell
18:06:55 <Cale> What kind of problems?
18:06:59 <Cale> oh, okay
18:07:07 <YellowOnion> but 1 / 2 would work
18:07:24 <mike-burns> I've had a problem with types every single time I've used (/), to be honest.
18:07:26 <Cale> That'll be because at the ghci prompt, it has to work out a type for the thing immediately.
18:07:56 <aninhumer> > let a = 1; b = 2 in a / b
18:07:58 <lambdabot>   0.5
18:07:58 <Cale> (ghci is aggressive about defaulting the types of things because it tends to be convenient)
18:08:25 <YellowOnion> yeah I was doing it line by line
18:08:54 <YellowOnion> http://paste.pocoo.org/show/509472/
18:08:54 <Cale> But if you do that in a real program, a and b will be inferred as having fractional types, and will be defaulted to Double if nothing else pins the type down.
18:08:57 <YellowOnion> here's an example
18:09:07 <dolio> > let a = 1 ; b = 2 in (a/b, a^b)
18:09:08 <lambdabot>   (0.5,1)
18:09:20 <Cale> Yeah, things will tend to work more smoothly if you put definitions in a file.
18:09:34 <YellowOnion> ok
18:09:37 <Cale> and use :re in ghci to reload the source whenever you edit it
18:09:52 <Cale> (most people keep a text editor open alongside ghci for their definitions)
18:10:02 <aninhumer> YellowOnion: Yeah the problem is "let a = 1" forces a to have a type immediately, and the default is Integer
18:10:09 <aninhumer> which you can't do (/) on
18:11:06 <aninhumer> in the ghci
18:11:07 <Cale> :set -XNoMonomorphismRestriction -- you could also type this which would solve your problem
18:11:18 <YellowOnion> yeah I noticed if I did, it as ratiow w h = w / gcd w h it worked
18:12:04 <Cale> The monomorphism restriction is a really silly restriction in the standard which makes it so that if something doesn't look like a function (doesn't explicitly take parameters), then it can't be polymorphic
18:12:11 <kfish> thoughtpolice: you're now part of the haskell-pkg-janitors github group
18:12:22 <Cale> and that forces a and b to have type Integer right away
18:12:31 <Cale> rather than the usual inferred type  (Num a) => a
18:12:35 <Cale> (any type of number)
18:12:41 <Cale> (which is sad)
18:12:52 <Cale> ghci> :set -XNoMonomorphismRestriction
18:12:52 <Cale> ghci> let a = 1
18:12:52 <Cale> ghci> let b = 2
18:12:52 <Cale> ghci> a/b
18:12:52 <Cale> 0.5
18:13:11 <Cale> ghci> :t b
18:13:11 <Cale> b :: Num a => a
18:13:31 <thoughtpolice> kfish: ta! i'm reading the email now and digesting it. i'll let you know what i end up thinking/trying out.
18:13:38 <Cale> But this will also mean that a and b, if they were computed in some complicated way, will be recomputed each time they're used
18:14:45 <kfish> thoughtpolice, cool, and it should probably be discussed on -cafe not just private mail
18:14:50 <Cale> (because they have a polymorphic type, and might be used at many different types, and nothing is done to remember the result of the computation for each type you use it at)
18:15:31 <YellowOnion> oh yep
18:15:44 <Cale> In any case, if you pin down the types of things in a full program, it tends not to be a big deal.
18:16:11 <dolio> Clearly implementations should create unique identifiers for each type class instance and memoize the result for each instantiation.
18:16:14 <YellowOnion> I never really liked javascripts flexbility of types and how "4" is the same as 4
18:16:39 <aninhumer> except when it isn't
18:17:40 <Cale> YellowOnion: yeah, this is a different approach, which allows for some polymorphism while making it so that once the types of things are pinned down, they require explicit conversions.
18:18:38 <Cale> You shouldn't ever see anything get magically converted from one type to another during a calculation -- it's always from more general type to more specific, and if you need to use an Integer and Double together, you have to conver.
18:18:40 <YellowOnion> cool, python has something familiar but not so strict, so I'll have to think differently heh
18:18:40 <Cale> convert*
18:19:17 <aninhumer> Also the polymorphic type still has a constraint (in this case, Num) so any operations you're allowed to do on it are well defined
18:19:54 <aninhumer> hmm that's not the best way to say that
18:20:22 <YellowOnion> aninhumer: I get what you mean
18:21:49 <YellowOnion> so the Ratio Module will do what I need in my ratio function?
18:22:42 <aninhumer> YellowOnion: the only thing you need to be aware of is that the result of a % b is a Ratio type
18:23:15 <YellowOnion> cool
18:23:45 <aninhumer> I forget what you were actually doing with it now, but it might make it moderately more complicated
18:24:38 <YellowOnion> curious, what's the modulo function/operator? since some langs use %
18:25:20 <XexonixXexillion> mod
18:26:07 <aninhumer> or `mod` if you want infix
18:26:24 <monochrom> > 5 `mod` 2
18:26:25 <lambdabot>   1
18:27:06 <YellowOnion> aninhumer: http://paste.pocoo.org/show/509530/ this is what I'm doing, just various calculations with screens
18:30:18 <YellowOnion> should I have functions for each value? seems haskell would be good for this
18:30:41 <monochrom> up to you
18:31:15 <mike-burns> You can always refactor later.
18:31:35 <YellowOnion> true
18:31:41 <aninhumer> YellowOnion: Your screen dict seems like it would be best represented as a Haskell record to me
18:31:58 <aninhumer> depending on what you do with it
18:32:25 <mike-burns> I said that too, with the same level of uncertainty!
18:32:35 <mike-burns> I'm glad we're both unclear on this opinion.
18:33:32 <YellowOnion> I mostly just read the values, as is, I was just experimenting on getting a good FOV is some games, Console ports have it way to low, and cause serious headaches in a lot of people
18:36:10 <YellowOnion> so where would I find this record type?
18:36:38 <Cale> YellowOnion: you'd define it, something like:
18:37:27 <Cale> data Screen = Scr { width :: Double, height :: Double, ppmmH :: Double, ... }
18:37:52 <augur> uh
18:37:52 <augur> so
18:38:01 <augur> any efficient prolog-esque DB systems?
18:38:02 <augur> :P
18:38:30 <YellowOnion> Cale: thanks, looks pretty close to a dict
18:39:55 <aninhumer> It's static of course
18:40:24 <augur> anyone?
18:40:25 <augur> no?
18:40:27 <augur> meh?
18:40:35 <augur> surely someone here knows about databases
18:41:48 <deech> Just a general question, are there any good reasons why systems programming (device drivers etc) should not be done in Haskell?
18:42:44 <Eduard_Munteanu> http://programatica.cs.pdx.edu/House/
18:43:22 <Eduard_Munteanu> Well, I don't mean that as the reason :)
18:43:33 <deech> Eduard_Munteanu: Interesting, no update since 2008.
18:43:53 <aninhumer> Haskell has a runtime, which I don't usually associate with systems programming...
18:44:16 <aninhumer> Although, can you get rid of it somehow?
18:44:24 <deech> aninhumer: Maybe I'm wrong but I thought C had a runtime too.
18:44:30 <monochrom> micromanaging memory layout and execution order doesn't seem to fit haskell
18:44:34 <Eduard_Munteanu> aninhumer: you can reimplement your own
18:44:46 <Eduard_Munteanu> But it has to have an RTS.
18:45:23 <Eduard_Munteanu> Also, monochrom put it quite well.
18:45:38 <aninhumer> deech: I'm no expert but afaik C doesn't really have a runtime, unless you count malloc
18:46:12 <DukeDave> @seen apfelmus
18:46:12 <preflex>  apfelmus was last seen on #haskell 135 days, 7 hours, 53 minutes and 28 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
18:46:13 <lambdabot> Unknown command, try @list
18:46:21 <Eduard_Munteanu> Also systems programming is probably more than just the kernel. In other parts of an OS, Haskell might be easier to put to good use.
18:46:22 <DukeDave> Hmm, do not want
18:46:43 <monochrom> someone can come up with a haskell compiler suitable for device drivers. but it hasn't happened yet.
18:47:05 <Eduard_Munteanu> aninhumer: malloc doesn't count, since OS kernels already do their own memory management.
18:48:31 <YellowOnion> 1MB (win32 exec) for a hello-world program seems excessive for a systems programming language
18:49:02 <monochrom> that is how GHC does it, not a must for Haskell
18:49:16 <YellowOnion> oh ok
18:49:32 <Axman6> haskell isn't a systems programming language
18:49:40 <YellowOnion> I noticed the .o is about 3KB
18:49:43 <monochrom> there was a haskell-to-javascript compiler that doesn't cause 1MB of javascript code
18:49:44 <Eduard_Munteanu> YellowOnion: it's because of static linking
18:49:49 <Axman6> it can be used for one, but it's not designed for it
18:49:50 <Pseudonym> Axman6: It depends on the system./
18:50:11 <Pseudonym> Programming languages develop an implicit theory of what they are "for".
18:50:17 <Eduard_Munteanu> If you compile it with -dynamic, and perhaps 'strip' it, it should be a lot smaller.
18:50:58 <gentleben> why do you care about executable size? are you building embedded systems?
18:51:19 * monochrom is still disappointed that people speak like "<language> takes xxx MB and yyy seconds". these days you can't even safely say that about python.
18:51:31 <YellowOnion> people still live with dial up
18:51:51 <gentleben> are they really downloading your haskell code
18:51:59 <Axman6> are you expecting a lot of people to download your app as a binary? I wouldn't
18:52:04 <Eduard_Munteanu> $ ls /usr/bin | wc -l
18:52:06 <Eduard_Munteanu> 3453
18:52:08 <gentleben> or binaries
18:52:21 <Eduard_Munteanu> If all those where 1MiB in size...
18:52:25 <gentleben> my main apps are 40 - 60 MB
18:52:34 <Eduard_Munteanu> 1MiB + actual useful code, I mean.
18:52:36 <gentleben> static linking
18:52:37 <monochrom> I respect the desire to be efficient. I just disrepect the desire to pin it on languages rather than compilers.
18:52:43 <YellowOnion> anyone using windows would apresheate it, I hate setting up any dev enviroment on windows
18:52:55 <Pseudonym> There are advantages to having your process space < 1MB on L4-based operating systems.
18:53:18 <Axman6> Pseudonym: because we're all programming for those =)
18:53:36 <gentleben> Pseudonym: like what? the code pre fetcher on a modern intel chip is going to do a better job
18:54:07 * monochrom has never seen a language definition that says "programs should be run at least as slow as the following standard, and use at least as much memory as the following rule". have you seen one?
18:54:26 <Pseudonym> gentleben: L4 gets around the fact that Intel chips don't have tagged TLBs by using segmentation to multiplex different processes on top of the same address space.
18:54:30 <Eduard_Munteanu> Dunno, I remember the Linux people thought -Os was a good idea until it bit them :)
18:54:43 <Pseudonym> That way, some process switches don't incur a TLB flush.
18:54:47 <deech> YellowOnion: I seem to remember a Stackoverflow answer that brought down the size of "hello world" to about double the size of the equivalent C program.
18:55:04 <YellowOnion> cool
18:55:19 <gentleben> Pseudonym: ah, one of those pesky linux issues
18:55:19 <deech> YellowOnion: I'm looking for it now.
18:55:26 <Pseudonym> No, L4.
18:55:33 <Eduard_Munteanu> I remember less than double.
18:55:40 <Pseudonym> http://en.wikipedia.org/wiki/L4_microkernel_family
18:55:44 <Eduard_Munteanu> Just use -dynamic for ghc, then use 'strip' on it.
18:56:01 <gentleben> Pseudonym: who uses that?
18:56:11 <YellowOnion> we here in NZ have a problem, rediculously expensive bandwidth, if you thought Canada's 20GB + 30c for an extra 1GB was bad
18:56:30 <Pseudonym> Embedded systems, admittedly.
18:56:51 <deech> YellowOnion: e
18:57:03 <gentleben> man, i haven't done anything like that since pocket pc
18:57:10 <gentleben> maybe 10 years
18:57:17 <gentleben> now all clusters
18:57:18 <Pseudonym> But maybe you should too, since L4 has been proven correct.
18:57:49 <Axman6> YellowOnion: how bad is it?
18:58:01 <gentleben> how can you prove something that interacting with hardware correct?
18:58:01 <YellowOnion> ours is anywhere between $1.40 and $2 extra, and we can chose to not pay more, but have our internet slowed to 64kbps/64kbps
18:58:16 <Eduard_Munteanu> Uh...
18:58:18 <Pseudonym> gentleben: Obviously drivers haven't been proven correct.
18:58:21 <Pseudonym> But the kernel has.
18:58:31 <YellowOnion> gentleben: assume hardware is acting properly ;)
18:58:32 * Eduard_Munteanu pays 10EUR/mo, unlimited
18:58:40 <gentleben> i see, so it doesn't matter
18:59:27 <Axman6> YellowOnion: so, just like australia then? quit complaining :\
18:59:31 <Pseudonym> Yes it does, because drivers don't run in the kernel.
18:59:39 <Eduard_Munteanu> Drivers wouldn't matter that much if proper access controls were in place.
18:59:43 <Pseudonym> Even drivers can't subvert the kernel.
18:59:49 <Pseudonym> Modulo hardware bugs.
18:59:58 <gentleben> yeah, those models don't work for perf reasons
19:00:04 <Eduard_Munteanu> I mean, given the right hw support, you could make drivers quite safe.
19:00:13 <Axman6> Pseudonym: L4 hasn't been proven correct, NICTA's seL4 kernel has been, apart from the assembly used to boot it
19:00:14 <gentleben> MS had a research project into this
19:00:30 <Eduard_Munteanu> gentleben: with an IOMMU you can pretty much have userspace drivers.
19:00:45 <gentleben> maybe sans video
19:00:52 <Eduard_Munteanu> Why?
19:00:55 <gentleben> perf
19:00:57 <Pseudonym> http://www.sigops.org/sosp/sosp09/papers/klein-sosp09.pdf <- Interesing paper, BTW.
19:01:15 <deech> YellowOnion: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
19:01:28 <Eduard_Munteanu> Anything more specific than that? What can't you do that otherwise improves performance?
19:01:43 <gentleben> microsoft tried to get the video drivers out of kernel space
19:01:51 <gentleben> context switch
19:02:28 <deech> YellowOnion1: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
19:02:29 <gentleben> actually the reason we run on linux and not windows is that its easier to but arbitrary code in the kernel
19:02:32 <monochrom> 386 or even 286 gave you 4 rings of privileges. kernel was ring 0. the intention was that device drivers would be ring 1. performance concerns (justified or not, I don't know) drove people to go with ring-0 device drivers. that ruined everything.
19:02:47 <Axman6> gentleben: security++ =)
19:02:54 <YellowOnion1> internet drops, and flat mate walks in with Phone cable he just unplugged
19:03:03 <gentleben> it was done so people can play games
19:03:19 <deech> YellowOnion1: Are you on dial-up? :)
19:03:21 <Eduard_Munteanu> gentleben: did they use IOMMUs for e.g. address and interrupt remapping? The driver doesn't really need to context switch to talk to the GPU then.
19:03:30 <YellowOnion1> shitty ADSL2+
19:04:07 <Pseudonym> Eduard_Munteanu: The decision was made 10+ years ago, when hardware was different.
19:04:24 <YellowOnion1> use to have about 1.9MB/s now it's barely breaks 1MB/s after moving
19:04:26 <gwern> the past is a foreign country; they program differently there
19:04:27 <Eduard_Munteanu> Ah, I thought he was talking about recent stuff.
19:04:31 <Pseudonym> Nope.
19:04:33 <gentleben> i don't know the exact reason, for vista originally they moved it out
19:04:50 <gentleben> then they put it back in the kernel when perf didn't work out
19:04:55 <monochrom> 1% of BTers use 99% of the bandwidth. #occupytherouter
19:05:21 <YellowOnion1> past? I live in +12 zone, or according to Windows 7's UTC code +12h and 5mins >.>
19:05:26 <gentleben> MS wanted it out since ATI and NVidia account for most blue screens
19:05:46 <Eduard_Munteanu> gentleben: with hw like that you can, for example, assign a PCI device to a virtual machine.
19:05:49 <Axman6> YellowOnion1: what brand modem/router do you have?
19:05:49 <gwern> YellowOnion1: well, that' moore's law for you
19:05:52 <Eduard_Munteanu> I mean, a real one, no emulation.
19:06:11 <YellowOnion1> DSL 502T with OpenWRT on it
19:06:29 <gentleben> Eduard_Munteanu: and no overhead
19:06:52 <Axman6> YellowOnion1: i would highly recommend a Billion one. bought one yesterday after a week with no ADSL2+ to replace out netgear one, and it's absolutely fantastic. no disconnections, and much better speeds than we ever got before
19:07:00 <YellowOnion1> and a RT-N16 as a ethernet/wireless bridge
19:07:09 <Eduard_Munteanu> I'm not really really sure on the details, but as long as you can remap address space and interrupts, I guess so.
19:07:47 <gentleben> Eduard_Munteanu: somewhere in there memcpy between video and main men starts a context switch
19:07:51 <Eduard_Munteanu> Interrupt delivery might be tricky though.
19:07:51 <Axman6> YellowOnion1: billions have a reputation for being able to get the highest speeds from long cable runs. we're over 3.5KM from the exchange, and getting 3.1Mbps
19:07:53 <gentleben> between kernel and user
19:08:09 <gentleben> that takes too long
19:08:26 <gentleben> its a real shame too
19:09:13 <Eduard_Munteanu> gentleben: you map the card's MMIOs into your driver/VM address space (can be done by the kernel once). The driver/VM issues DMA requests by simply poking the MMIOs.
19:09:28 <hpaste> “Simon Wu” pasted “p12” at http://hpaste.org/54220
19:09:32 <YellowOnion1> I think the house I'm in has a echo problem, /proc/avalanche/avsar_SNRpsds shows a drop out, and then signal raises again all the way up to the top channel
19:09:57 <Eduard_Munteanu> gentleben: on the way back, the IOMMU translates and guarantees the userspace driver can't instruct the card to overwrite, e.g. the kernel
19:09:58 <gentleben> Eduard_Munteanu: if you are interested i will see if I have the email chain. its sitting in a PST somewhere
19:10:28 <YellowOnion1> Axman6: http://paste.pocoo.org/show/509554/
19:10:54 <YellowOnion1> Axman6: line 26-27 cuts out
19:11:00 <gentleben> maybe video drivers don't use the IOMMU thing
19:11:14 <Eduard_Munteanu> One thing I'm not sure of is how you handle interrupts.
19:11:40 <Axman6> YellowOnion1: our line's pretty dodgy, used to get disconnects all the time until we got this billion. it's been connected without problems for 22 hours now
19:12:00 <Eduard_Munteanu> gentleben: currently they don't, not AFAIK. But qemu/kvm already supports PCI passthrough.
19:12:27 <YellowOnion1> I use to have connection for an entire week, and then I think my ISP would force a IP rotation
19:12:28 <Eduard_Munteanu> "they don't" as in I haven't seen such userspace drivers.
19:12:54 <Axman6> YellowOnion1: heh, yeah we used to get that too. right on 168 hours
19:13:07 <gentleben> Eduard_Munteanu: i don't know if it is possible now
19:13:35 <gentleben> Eduard_Munteanu: I will ask next time i talk to the kernel dudes, they are reasonably smart
19:13:37 <Axman6> not sure what happens these days. we haven't been connected for more than two days for well over a year i think =)
19:14:46 <YellowOnion1> Axman6: I was about 5m away from exchange
19:15:10 <gentleben> Eduard_Munteanu: oh course now I deploy onto linux where it seems everything requires rebuilding the kernel
19:15:42 <Eduard_Munteanu> Well, you can build modules out-of-tree.
19:16:06 <Eduard_Munteanu> But people don't usually bother to do that.
19:17:02 <gentleben> i actually don't do it all, one of my coworkers does all that
19:17:49 <YellowOnion1> Vista bought it extreme UMS for video (to the point where it's one of the few things you don't have to restart your computer for now), recent linux versions bought in KMS
19:18:44 <gentleben> yeah, the driver is a split between kernel and user
19:18:57 <gentleben> it can still nuke your box
19:19:44 <YellowOnion1> I think MS didn't want any blame put on them, so they removed any requirements on their part
19:20:08 <gentleben> well they would be blamed if anything went slower
19:20:15 <gentleben> its a rock and a hard place
19:20:34 <Eduard_Munteanu> When it comes to video drivers, they're pretty unsafe anyway.
19:21:12 <gentleben> so many micro optimizations for different apps
19:21:19 <YellowOnion1> well, with the dick up from ATI/AMD's driver department lately (possibly ruining id softwares reputation quite a bit) I wouldn't want any blame either
19:21:39 <Eduard_Munteanu> That's another thing an IOMMU would be nice for... so your GPU can't go crazy all over your mem because the driver didn't check commands properly.
19:21:50 <gentleben> what did they do?
19:22:15 <drhodes> Is there a fancy greek name for all functions of type :: b -> *... -> b  ?  In case that's not clear: a function that takes *at least one* thing of type b, any number of things of any type and returns something of type b ?
19:22:22 <gentleben> our GPU code seems to work ok, i have never had it go nuts
19:22:35 <YellowOnion1> AMD released some pre-release drivers specifically for id's new game rage, it some how included OpenGL drivers OLDER than the current drivers of the stable driver >.>
19:22:51 <gentleben> NICE
19:23:00 <YellowOnion1> causing the game to be completely unplayible
19:23:07 <gentleben> i hope someone got axed
19:23:09 <Eduard_Munteanu> drhodes: there are hungry functions, that take infinitely many arguments
19:23:47 <gentleben> YellowOnion1: seems like there may be a problem in the release process
19:24:17 <Eduard_Munteanu> drhodes: or perhaps you're looking for variadic functions? The ones that take a variable, unlimited number of arguments?
19:24:21 <drhodes> Eduard_Munteanu: ok, though I'm more interested in the b to b part, the middle doesn't matter much
19:24:33 <Eduard_Munteanu> Ah, then I'm not sure.
19:24:38 <YellowOnion1> gentleben: http://www.youtube.com/watch?v=6IY7SAsQrko
19:25:14 <Philippa> make b last and it's just (functions returning) endofunctions on b
19:25:34 <Eduard_Munteanu> Maybe projections?
19:25:58 <Eduard_Munteanu> If that's a polymorphic 'b', and the other arguments don't mention 'b', parametricity pretty much tells you what it is.
19:26:16 <_pw_> Hi, http://www.haskell.org/haskellwiki/Monad , it says "The essence of monad is thus separation of composition timeline from the composed computation's execution timeline, as well as the ability of computation to implicitly carry extra data as pertaining to the computation itself in addition to its one (hence the name) output.", What's meaning by "composition timeline" and "execution timeline" here?
19:26:43 <Eduard_Munteanu> :t fst
19:26:44 <lambdabot> forall a b. (a, b) -> a
19:26:53 <Eduard_Munteanu> :t curry fst
19:26:53 <lambdabot> forall a b. a -> b -> a
19:26:56 <gentleben> YellowOnion1: thats funny. mega texture is pretty awesome
19:27:04 <gentleben> driver epic fail
19:27:50 <YellowOnion1> gentleben: yeah, Textures are awesome, I believe they were ray traced, in house, so the game came with 20GB of textures :-|
19:28:19 <gentleben> YellowOnion1: yeah. the tech is awesome. you watch carmacks talks?
19:28:20 <RichardBarrell> _pw_: you can compose monad actions together with the (>>) and (>>=) operators at any time you like before you actually run those actions.
19:29:05 <Eduard_Munteanu> That sounds a bit more like "the essence of laziness" /
19:29:14 <YellowOnion1> gentleben: don't think so, I saw one where the interviewing was completely out of his league
19:29:24 <RichardBarrell> Eduard_Munteanu: yes, isn't it nice? :)
19:29:33 <Eduard_Munteanu> Heh.
19:29:38 <gentleben> YellowOnion1: if you are invested google is quake con talks
19:29:45 <gentleben> *interested
19:30:02 <gentleben> he just gets up there and talks about tech for a couple of hours
19:30:10 <drhodes> ok yeah it's a morphism :) thanks Eduard_Munteanu, Philippa.
19:30:13 <YellowOnion1> gentleben: http://www.youtube.com/watch?v=d0S2dsuSxHw there's this which is pretty cool as well
19:30:17 <drhodes> I mean endomorphism
19:30:33 <Eduard_Munteanu> YellowOnion1, RichardBarrell: #haskell-blah is usually more suitable to offtopic stuff
19:30:43 <Eduard_Munteanu> Erm...
19:30:50 <Eduard_Munteanu> gentleben
19:30:53 <YellowOnion1> heh, year sorry
19:30:55 <YellowOnion1> yeah*
19:31:09 <Eduard_Munteanu> Nah, I've been doing it myself already.
19:31:32 <gentleben> actually this years talk he discussed why or why not he might like to use haskell
19:32:26 <YellowOnion1> I have a rule, offtopic if nothing is on topic, but I should pay attention to that rule myself
19:32:39 <gentleben> his take was static analysis good, laziness bad for reasoning about perf
19:32:57 <_pw_> RichardBarrell: Is that composition more relevant with laziness?
19:33:10 <NemesisD> anyone in here use aeson?
19:33:19 <Eduard_Munteanu> YellowOnion1: yeah, I guess that's not so bad
19:33:23 <RichardBarrell> Eduard_Munteanu: I don't think that talking about the ability to distinguish between the composition and running of monadic actions is off-topic, yo. ;)
19:33:34 <Eduard_Munteanu> :)
19:35:05 <Cale> _pw_: It's easier to understand this if you're already familiar with a few examples of monads.
19:35:45 <tibbe> I'm trying to clearly describe the strictness properties of the new Data.Map.Strict API. All functions are strict in both key and value arguments and any value that's inserted in the map (e.g. a value resulting in evaluating some higher-order argument, like in 'map') is evaluated to WHNF. Any ideas for a good formulation?
19:36:09 <Cale> _pw_: Have you done much with the IO monad yet? Basically, you write IO actions, and there's a difference between evaluation (the process of reducing expressions to values), and execution of IO actions (the process of carrying out the effects that IO action values describe)
19:36:25 <RichardBarrell> _pw_: I refer you to Cale.
19:36:37 <YellowOnion1> I currently have a 6 core CPU@ 2.8Ghz, most game don't take advantage of this I would be better off with a 4x3.4GHz or something
19:37:09 <YellowOnion1> so concurrent code really needs improvements
19:37:17 <znutar> current CPUs do that semi-automatically though
19:37:33 <Cale> _pw_: So for example,  putStrLn "Hello"  is an action which if executed will print a greeting on the screen, but simply evaluating it will only determine which action this is (which is not really something you can tell is happening so much)
19:37:37 <znutar> ramping clocks on active cores when only a couple are active
19:38:04 <Eduard_Munteanu> It still doesn't make the single active core faster, though.
19:38:25 <YellowOnion1> znutar: I don't trust that feature, I've never seen it been reported via windows or linux's info
19:38:50 <Eduard_Munteanu> Hm, what exactly are you talking about?
19:38:51 <Axman6> Eduard_Munteanu: sure it does
19:38:56 <_pw_> Cale: I have played with Maybe, List, IO, and try to understand the former description about Monad.
19:39:02 <YellowOnion1> CPU bursting
19:39:15 <Axman6> the iN line have turboboost, which will boost a single core's speed if the others aren't in use
19:39:31 <Axman6> (and can boost several cores if others aren't being used much)
19:39:32 <YellowOnion1> using 2 cores of my 6 core is suppose to run at 3.2Ghz instead of 2.8GHz
19:39:33 <Eduard_Munteanu> By boost you mean overclocking?
19:39:52 <Axman6> @google intel core turboboost
19:39:53 <Eduard_Munteanu> Ah.
19:39:55 <lambdabot> http://www.intel.com/content/www/us/en/architecture-and-technology/turbo-boost/turbo-boost-technology.html
19:39:55 <Cale> _pw_: http://www.haskell.org/haskellwiki/Monads_as_computation is my own explanation of why we abstract over the monad operations and what monads are about.
19:39:55 <lambdabot> Title: Intel® Turbo Boost Technology 20
19:40:33 <YellowOnion1> techinically not overclocking since it's working within design parameters
19:41:17 <Eduard_Munteanu> Yeah, that's fair.
19:41:37 <YellowOnion1> plus Windows switches the cores together by the looks, and is overly agressive
19:41:51 <_pw_> Cale: Thanks for your kindly explanation, take IO for example, where is the separation, exactly?
19:42:05 * Cale reads this as "We slow your processor down under normal operation so that we can make purely sequential programs seem not quite as oblivious to available resources as they actually are."
19:42:09 <YellowOnion1> never seen my core run at 800MHz on windows but on linux, it's always on 800MHz
19:42:23 <Eduard_Munteanu> "Windows will take a single thread and run 25% of it on each of four cores instead of putting it all on one core.[citation needed]" -- crap on Wikipedia
19:42:29 <Cale> _pw_: separation between evaluation and execution?
19:42:41 <YellowOnion1> Eduard_Munteanu: yep that happens
19:43:03 <Eduard_Munteanu> That can't happen. :)
19:43:06 <YellowOnion1> no
19:43:09 <_pw_> Cale: yes.
19:43:10 <Eduard_Munteanu> You can move it around, but not split it :)
19:43:11 <Cale> _pw_: Turning expressions for IO actions into IO action values has no user-visible effects. It's just determining what needs to be done without actually doing it.
19:43:16 <Cale> (that's evaluation)
19:43:17 <YellowOnion1> it switches the thread about every 10ms
19:43:18 <NemesisD> i'm looking to write a really fast, bare bones web service that has a few routes it responds to and serves JSON responses. yesood seems like the wrong choice. anyone have a better one?
19:43:34 <Cale> Execution of IO actions has user-visible effects (anything your computer can do, pretty much)
19:43:40 <NemesisD> i do like warp/WAI
19:43:47 <Eduard_Munteanu> YellowOnion1: on purpose? That's pretty bad.
19:44:01 <monochrom> yesod should be a right choice
19:44:40 <Axman6> NemesisD: check out happstack-simple
19:44:42 <NemesisD> monochrom: really? maybe i have the wrong impression. i thought it was more like a web app framework w/ persistence, forms, html rendering, etc
19:44:43 <YellowOnion1> Eduard_Munteanu: yep! serveal games have had problems because of the switching because they stall each switch moving data between each L2 cache
19:44:50 <Eduard_Munteanu> I mean, yes, the kernel should balance the load, but it should keep thread sticked to a core if possible. Switching it around usually has negative effects due to cache issues etc.
19:45:12 <Axman6> NemesisD: http://happstack.blogspot.com/2011/11/ann-happstack-lite-friendly.html
19:45:14 <Cale> _pw_: does that make sense?
19:45:20 <Axman6> uh, happstack-lite =)
19:45:27 * Eduard_Munteanu thinks this is rather unintentional, MS engineers can't be that bad ;)
19:45:28 <wlangstroth> NemesisD: I like Snap, but that doesn't make Yesod or Happstack a "wrong choice"
19:45:30 <monochrom> but perhaps you're saying you can't find a json component for yesod
19:46:29 <YellowOnion1> Eduard_Munteanu: yeah I wish that too, but they can't calculate my time zone correctly with UTC hardware clock.
19:46:40 <Cale> _pw_: The difference is vaguely like the difference between opening a program in a text editor, and actually running it.
19:47:10 <wlangstroth> (in my not-awesome-at-template-haskell opinion)
19:47:52 <NemesisD> i've got the JSON part taken care of with my own stuff using Aeson. i only thought yesod might be a bad choice because my impression of it is that its fairly high level
19:47:56 <_pw_> Cale: Maybe an example makes more sense. for example, getLine >>= putStrLn, getLine and putStrLn are two computations,
19:48:05 <luite> NemesisD: you can use WAI and Warp directly if you need low level and really fast
19:48:12 <NemesisD> whereas this app is going to be a couple of endpoints that all respond by spitting out JSON
19:48:29 <_pw_> Cale: so what's exactly the composition timeline and execution timeline here?
19:48:36 <Cale> _pw_: You can force expressions describing IO actions to be evaluated using seq.   seq (putStrLn "hello") 5   won't print anything on the screen, because it'll just work out which IO action (putStrLn "hello") is, and then discard it, producing the result 5.
19:48:39 <NemesisD> luite: thats what i was thinking. im just not yet sure how painful it will be to operate at that level
19:49:56 <krey_> can someone illustrate the difference between EitherT Writer and WriterT Either? Does the former carry on with the computation that should have failed in order to produce output?
19:50:15 <Cale> _pw_: Or in your example, evaluating getLine >>= putStrLn won't do a heck of a lot (what exactly happens depends on the internal implementation of IO actions, but it basically builds some sort of data structure representing the action of getting a line of text from the user and then printing it out)
19:50:29 <Cale> _pw_: but executing it will make that actually happen.
19:50:41 <monochrom> I wonder if this helps...
19:51:07 <Cale> _pw_: We can manipulate IO actions as first class values, gluing them together in various ways before they're run.
19:51:15 <monochrom> @unmtl EitherT e (Writer w) a
19:51:15 <lambdabot> EitherT e (Writer w) a
19:51:15 <Cale> _pw_: For example, I can write:
19:51:33 <monochrom> hrm? how do I use it?
19:51:33 <Cale> loop 0 x = return ()
19:51:34 <shachaf> _pw_: An IO action is nothing useful without an evaluator for it.
19:51:41 <monochrom> @unmtl StateT s IO a
19:51:41 <lambdabot> s -> IO (a, s)
19:51:51 <shachaf> _pw_: You can think of "foo" :: String as an "action" that prints "foo" to stdout, if your evaluator happens to work that way.
19:51:57 <parcs> monochrom: ErrorT maybe?
19:51:57 <Cale> loop n x = do x; loop (n-1) x
19:52:15 <monochrom> oh, ErrorT is more promising
19:52:27 <monochrom> @unmtl ErrorT e (Writer w) a
19:52:28 <lambdabot> (Either e a, w)
19:52:29 <shachaf> _pw_: Here's one way think of pseudo-IO actions: data IO = Exit | PutChar Char IO | GetChar (Char -> IO)
19:52:51 <shachaf> As you can see, that data-type doesn't "do" anything; it's just a type, and values of that type are completely static values.
19:53:20 <monochrom> (Either e a, w) seems to suggest that whether you run into errors, you get output, it is not lost etc
19:53:21 <shachaf> But you can write, say, a C program that takes a value of that type and "executes" it (occasionally calling back into Haskell).
19:53:23 <krey_> monochrom: i know the types, I'm trying to figure out the usage
19:53:36 <monochrom> @unmtl WriterT w (Error e a)
19:53:36 <lambdabot> err: `WriterT w (Error e a)' is not applied to enough arguments, giving `/\A. Error e a (A, w)'
19:53:42 <monochrom> @unmtl WriterT w (Error e) a
19:53:42 <lambdabot> Error e (a, w)
19:53:52 <monochrom> @unmtl WriterT w (Either e) a
19:53:53 <Eduard_Munteanu> Or "there's no program, just a todo list" ;)
19:53:53 <lambdabot> Either e (a, w)
19:54:15 <monochrom> Either e (a, w) seems to say that if there is an error, the output is throw away
19:54:16 <Cale> anyway, it's possible to now write things like  loop 5 (putStrLn "Hello")
19:54:26 <shachaf> I wonder if my explanation is completely useless unless you understand IO in Haskell anyway. :-)
19:54:40 <NemesisD> yesod's routing is pretty nice. i always shy away from it because the TH black magic scares me
19:54:41 <krey_> monochrom: so when would you use which? can you give me some examples?
19:54:41 <Cale> evaluation will reduce this expression to a single IO action value
19:55:09 <Cale> execution of that IO action will actually print "Hello" five times on the screen
19:55:27 <monochrom> I have never used either. I believe in exceptions.
19:56:29 <gentleben> NemesisD: don't fear it. it is awesome. one of the only things i like in haskell
19:56:55 <krey_> monochrom: what are those?
19:57:12 <monochrom> both of them do not continue with the "computation" when there is an error. but only one of them keeps the output so far.
19:57:28 <gentleben> NemesisD: compile time type checking. code gen. it just works. the core of yesod is probably better than any other generally available web stack
19:58:19 <NemesisD> gentleben: i don't doubt that part. michael snoyman writes consistently stellar libraries
19:58:26 <krey_> monochrom: could i make a monad that continues the computation after the error in order to produce output, but never actually returns a value?
19:58:56 <gentleben> NemesisD: I am just saying, its the only thing I have seen yet that is like, "that is better than other things"
19:59:04 <NemesisD> its just a leap for me. i more or less am comfortable with most of the basic syntax of haskell, heavy templating looks like moonspeak to me
19:59:12 <krey_> monochrom: I appear to have built such a thing...
19:59:22 <shachaf> krey_: Think of a program that prints to stdout and has exceptions.
19:59:31 <shachaf> If it throws an exception, it can't "unprint".
19:59:56 * Eduard_Munteanu can only guess what background gentleben comes from, using phrases like "compile time type checking" :P
20:00:14 * monochrom just says no, that's absurd
20:00:15 <gentleben> NemesisD: hehe. I am not comfortable with most of haskell. but the templating is awesome.
20:00:26 <gentleben> Eduard_Munteanu: c#/f# before that c++
20:00:44 <Eduard_Munteanu> I would've guessed something dynamically typed...
20:00:49 <gentleben> Eduard_Munteanu: but being able to see into the markup is awesome
20:00:50 <NemesisD> my background is ruby. we don't check a damn thing if the syntax parses
20:01:05 <Eduard_Munteanu> :)
20:01:16 <gentleben> Eduard_Munteanu: like in c#/java platforms for web apps the templates are checked at runtime, not compile time
20:01:24 <krey_> monochrom: I've probably broken the monad laws or something... can you take a look?
20:01:42 <Eduard_Munteanu> "Preferably check the target after missiles hit. If it's wrong... say oops"
20:02:08 <monochrom> let's say I use your monad to write code m0 >>= \x -> m1 x.  what I output when in m1 depends on x. which is to say, depends on m0 not crapping out. now you say, m0 craps out, and I can still continue with m1. how? with what value of x?
20:02:24 <gentleben> Eduard_Munteanu: So much dynamic stuff in the world, even in other strongly typed languages
20:02:45 <hpaste> krey_ pasted “strange monad” at http://hpaste.org/54222
20:02:57 <monochrom> I am too lazy to take a look. it's absurd.
20:03:05 <Eduard_Munteanu> gentleben: maybe you should look into dependent types
20:03:09 <gentleben> I just wish template haskell had good docs. I can't build my own templates which i might want to
20:03:14 <monochrom> I have said why it is absurd, so I think I'm done.
20:04:16 <krey_> monochrom: thanks anyway, perhaps someone else will take a look
20:04:28 <gentleben> Eduard_Munteanu: if thats how all this stuff works that is fine. i just like that when i get a yesod app to compile it just works
20:04:45 <monochrom> fair enough, I don't look at your code, so you don't look at my answer.
20:05:05 <RichardBarrell> monochrom: { data HoneyBadger a = HoneyBadger; instance Monad HoneyBadger where { HoneyBadger >> HoneyBadger = HoneyBadger; HoneyBadger >>= _ = HoneyBadger; return _ = HoneyBadger; }
20:05:07 <Eduard_Munteanu> Ah, no, that wasn't the idea.
20:05:24 <RichardBarrell> monochrom: satisfies the monad laws, doesn't give a shit about the values you use inside it. ;)
20:06:26 <Eduard_Munteanu> gentleben: the idea is, in a language with dependent types, you can express more stuff in terms of properties that can be checked statically.
20:06:57 <Eduard_Munteanu> gentleben: a simple example is lists/vectors with statically-known length.
20:07:06 <krey_> monochrom: I did read your answer, but that it can't convince me, since I think I produced something that """works""". I didn't mean to be rude
20:07:33 <gentleben> Eduard_Munteanu: I see. You will have to excuse me. I am not very good at the whole haskell thing. I just used >>= for the first time today
20:07:33 <monochrom> yes RichardBarrell but the question is that the monad has a Writer-equivalent
20:07:35 <Eduard_Munteanu> That's not what TH does though.
20:08:15 <RichardBarrell> monochrom: const [] ? ;)
20:08:18 <gentleben> Eduard_Munteanu: TH can do awesome code gen. Like we have this super cool thing that makes deepest instances
20:08:29 <gentleben> *deepseq
20:09:09 <monochrom> well, the expectation is that while no one cares about return values, the Writer-output should be non-trivial and is faithful to what my code says to write.
20:09:29 <gentleben> I think TH would be better if it was more accessible to more people. My colleague is going to do some in depth tutorials on it next year
20:10:01 <marvinalone> I'm trying to join two Data.Maps with a combining function, but the combining function has the type a -> a-> Maybe a. Is there a way to get a Data.Map.union function that returns Nothing if one of the combining functions returns Nothing?
20:10:23 <monochrom> but then my code says that, at some point, the Writer-output depends on some previous return value, so it is no longer the case that you can give me no return value
20:12:23 <rwbarton> marvinalone: you can use mapMaybe together with unionWith with your a -> a -> Maybe a combining function
20:12:42 <rwbarton> mapMaybe id
20:14:28 <marvinalone> rwbarton: hmm, that might work the way i asked the question, but i oversimplified. really i have some other monad there. what i need is a combining function of type (Monad m) => a -> a -> m a
20:15:48 <rwbarton> oh I misread
20:15:51 <rwbarton> use traverse
20:15:53 <rwbarton> @hoogle traverse
20:15:53 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:15:53 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:15:54 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
20:16:34 <rwbarton> :type traverse id
20:16:54 <rwbarton> :t traverse id
20:16:55 <lambdabot> Not in scope: `traverse'
20:16:59 <rwbarton> :t Data.Traverse.traverse id
20:17:00 <lambdabot> Couldn't find qualified module.
20:17:05 <rwbarton> eugh
20:17:07 <marvinalone> so ... in other words, i use foldM to union those maps entry-for-entry, right?
20:17:08 <rwbarton> :t Data.Traversable.traverse id
20:17:08 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
20:17:43 <rwbarton> use unionWith to make a Map (m b), then apply traverse id to run all the actions and give you an m (Map b)
20:18:03 <rwbarton> @hoogle (Traversable t, Applicative f) => t (f b) -> f (t b)
20:18:04 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
20:18:04 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
20:18:04 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
20:18:19 <rwbarton> sequence = traverse id
20:18:59 <marvinalone> rwbarton: oh, i see. well, here is the problem: for some unfathomable reason, the type of the combining function is a -> a -> a. it can't change the types of the values.
20:19:13 <rwbarton> okay
20:19:16 <marvinalone> i guess i could make them all (m a) beforehand
20:19:24 <rwbarton> Most likely you want to use traverse on the resulting Map then
20:21:43 <Cale> Are you really looking for intersectionWith perhaps?
20:22:33 <Cale> oh, not quite
20:40:54 <tibbe> argh, haddock refuses to recognize $section markup!
20:51:28 <monochrom> eh? it recognizes, but you have to be tricky
20:51:38 <hpaste> Simon annotated “p12” with “p12 (2)” at http://hpaste.org/54220#a54224
20:51:42 <monochrom> let me see what I did
21:16:26 <hpaste> monochrom pasted “haddock section example” at http://hpaste.org/54225
21:16:39 <monochrom> tibbe: does http://hpaste.org/54225 do what you want?
21:17:04 <tibbe> monochrom: yes, I found the problem
21:17:13 <monochrom> ok good
21:17:23 <tibbe> monochrom: any line with a code snippet (with a > prefix) must be preceded by an empty line.
21:17:43 <monochrom> now pay me $100 as per the EULA since you have read it :)
21:19:00 <monochrom> yeah it's paragraph-wise, where paragraph means separated by blank lines
21:38:03 <curious_> hi everyone
21:38:40 <byorgey> hi curious_
21:39:00 <curious_> going through the tutorial, haskell looks like an awesome language
21:40:17 <byorgey> curious_: cool, feel free to ask in here if you have any questions
21:40:25 <byorgey> curious_: which tutorial? Try Haskell?
21:40:33 <curious_> yes
21:40:42 <byorgey> curious_: after you finish that you may want to take a look at LYAH
21:40:44 <byorgey> @where lyah
21:40:44 <lambdabot> http://www.learnyouahaskell.com/
21:40:55 <byorgey> much more comprehensive
21:40:59 <curious_> thanks byorgey i will
22:15:19 <smoge> what's the best way to use darcs from emacs??
22:16:21 <parcs> M-x shell
22:25:00 * hackagebot system-argv0 0.1.1 - Get argv[0] as a FilePath.  http://hackage.haskell.org/package/system-argv0-0.1.1 (JohnMillikin)
22:32:15 <smoge> ahha
22:32:16 <smoge> ok
23:02:15 <Codingtales> Is ghc --make -static app.hs enough to compile an app statically?
23:04:59 <Codingtales> Is ghc --make -static app.hs enough to compile an app statically?
23:06:48 <parcs> Codingtales: you need '-optl static' too
23:06:57 <shachaf> How static do you want it?
23:07:11 <Codingtales> to deploy it onto heroku
23:07:16 <parcs> -static is the default by the way
23:07:45 <parcs> and so is --make, on recent versions of ghc
23:08:16 <Codingtales> I read this yesod blog post www.yesodweb.com/blog/2011/07/haskell-on-heroku
23:08:20 <shachaf> Next version of ghc "app.hs" will be the default too.
23:08:58 <Codingtales> gregwebs tells there that we need the -static flag.
23:09:08 <shachaf> Codingtales: Why don't you try it and see? :-)
23:09:13 <parcs> hopefully ghc will be able to autodeploy apps onto heroku in the near future
23:09:20 <Codingtales> I did compiled and pushed it to miku-heroku.herokuapp.com
23:09:34 <Codingtales> it worked once but it doesn't work anymore :(
23:10:48 <Codingtales> http://miku-heroku.herokuapp.com
23:21:04 <zomg> Codingtales: I expected leeks
23:27:40 <augur> shachaf: surely you know something about databases
23:27:40 <augur> surely
