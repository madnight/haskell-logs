00:01:42 <kmc> Sgeo, you could elaborate on the similarities you see
00:02:32 <Sgeo> Checked exceptions, at least as far as I'm aware, make the possible exceptions thrown a part of the statically known details of the function: Almost like part of the type signature
00:02:42 <Sgeo> Things that call it need to be prepared to deal with it
00:03:12 <Sgeo> Similar to Either l r: Needs to be part of the type signature, callers need to handle it somehow, even if it's just returning another Either
00:03:19 <Sgeo> And having that documented in the type signatur
00:03:20 <Sgeo> e
00:04:18 <kmc> *nod*
00:04:51 <Sgeo> (I should add that I don't know much about Java)
00:05:06 <Sgeo> (Other than that it has checked exceptions, and that checked exceptions are often criticized)
00:05:19 <kmc> unchecked exceptions are also often criticized
00:05:38 <kmc> this is a point in favor of Haskell's approach, where exception systems are libraries which can be swapped out at will
00:05:43 <ddarius> Checked exceptions are often criticized mostly because Java is a crappy language.  If Java wasn't such a crappy language, checked exceptions wouldn't be so painful in it.
00:05:52 <scshunt> ^
00:05:57 <kulin> i hate either
00:05:58 <kulin> so theres that
00:06:10 <kulin> i mean Either
00:06:22 <scshunt> It's no worse than Maybe
00:07:23 <kulin> i also hate Maybe and if statements, infact any branching is hard to make look even passable in code
00:07:37 <kmc> does pattern-matching count as branching?
00:07:44 <kulin> pattern matching isnt so bad
00:07:48 <ddarius> What?
00:07:52 <kmc> 'cause using Maybe with 'if' would usually be Doing It Wrong
00:08:21 <Sgeo> Isn't there a function that's usually used instead of pattern matching?
00:08:24 <Sgeo> :t maybe
00:08:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:08:35 <kmc> i wouldn't say that's 'usually' used
00:08:46 <kmc> Sgeo, in Java if f calls two functions which throw exceptions of two different types, there's an obvious answer for f's exception signature
00:08:47 <kulin> i just think haskell programs are very horizontally intensive, and branching statements make it even harder to have pretty lines of code
00:08:49 <kmc> not so with Either in Haskell
00:08:54 <ddarius> I, personally, almost never case analyze Maybe, but instead use maybe.
00:09:24 <kmc> there are libraries which attempt to fix this
00:09:36 <kmc> kulin, well, using a sane indentation style does help
00:09:51 <kmc> a lot of Haskell code uses imo bad indentation style
00:10:30 <kmc> reallylongfunctionname = do foo
00:10:30 <kmc>                             bar
00:10:41 <kulin> kmc, i just do 4 space before anything but where, and put 'then', 'else', 'Right', 'Left', 'Just', 'Nothing' on their own lines
00:10:51 <kulin> so just having 1 branch, eats up 8 spaces
00:11:05 <Sgeo> kmc, in that case, would it be wrong to have reallylongfunctionname = do on the first line, then foo and bar on the next?
00:11:11 <Sgeo> *next two
00:11:19 <ddarius> Sgeo: No, that's what I do and have always done.
00:11:22 <Sgeo> Ah, ok
00:11:45 <kmc> that's what i do and not just "in that case" but always
00:11:51 <kmc> unless the whole 'do' fits on one line
00:12:08 <kmc> the simple rule is "never let indentation depend on the length of a name"
00:12:33 <ddarius> I put a new line before where and not after, but otherwise, I pretty consistently put a newline after anything that opens a block.
00:13:14 <ddarius> I should be clear that that's only for local definition 'where's not for module/class/GADT ones.
00:14:02 * hackagebot ghc-mod 1.0.2 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.2 (KazuYamamoto)
00:14:20 <kmc> the disadvantage to making exception handling a library problem is that two libraries might not use the same exceptions library
00:14:24 <kmc> and now it's hard to integrate them
00:14:38 <ddarius> kmc: The solution to that is standard libraries.
00:14:56 <kmc> it's already a problem in the Haskell standard libraries
00:15:03 <kmc> there are already three or four ways to handle exceptions
00:15:42 <ddarius> There should be multiple ways to handle exceptions, though certainly there are more ways than there should be.  Mostly because a good solution wasn't standardized early.
00:16:35 <Sgeo> This sounds almost like a criticism of D I keep hearing
00:16:52 <ddarius> Three ways, though, sounds about right.
00:17:18 <kmc> depends which three ;P
00:17:24 <ddarius> True.
00:18:17 <mjrosenb> in parsec, is there anything that is equivalent (or similar) to foldl1 (<|>)
00:18:25 <ddarius> choice ?
00:18:35 <ddarius> Or choose I think is the name.
00:18:40 <kmc> :t Data.Foldable.asum
00:18:40 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
00:18:42 <ddarius> One of those two.
00:19:58 <mjrosenb> ddarius: choice it is; minimally shorter, signifigantly less ugly
00:20:05 <kmc> or msum, if you already have it in scope
00:24:17 * ddarius waits for someone to ask how to shorten a one byte expression.
00:26:33 <mjrosenb> kmc: parsers are in MonadPlus?
00:27:20 <ddarius> Every parser should be an instance of Alternative and therefore an instance of MonadPlus if it is a monadic parser.
00:28:34 <kmc> mjrosenb, yeah, ParsecT has Functor, Monad, MonadPlus, Applicative, Alternative
00:29:19 <mjrosenb> how did they decide if it should be disjunction, or concatenation, discarding a member?
00:29:27 <mjrosenb> i guess the latter isn't really useful
00:29:53 <kmc> MonadPlus and Alternative are usually cast as ways to handle failure and alternatives
00:30:23 <kmc> this is also why msum and mappend differ for Maybe
00:30:29 <kmc> > Just "x" `msum` Just "y"
00:30:29 <lambdabot>   Couldn't match expected type `[m a]'
00:30:30 <lambdabot>         against inferred type `Data.Ma...
00:30:33 <ddarius> Anyone who made a parser library where Alternative/MonadPlus did not correspond to the natural alternation structure of the parser would be shot in the face.
00:31:02 <kmc> err, I mean mplus and mappend
00:31:06 <kmc> > Just "x" `mplus` Just "y"
00:31:07 <lambdabot>   Just "x"
00:31:08 <kmc> > Just "x" `mappend` Just "y"
00:31:09 <lambdabot>   Just "xy"
00:31:40 <kmc> > Just "x" `mplus` Nothing
00:31:41 <lambdabot>   Just "x"
00:31:42 <kmc> > Just "x" `mappend` Nothing
00:31:43 <lambdabot>   Just "x"
00:31:59 <Sgeo> o.O
01:40:24 <sam___> hir
01:40:29 <sam___> hie
01:44:44 <Axman6> hi?
02:07:24 <mjrosenb> Is it recommended that I use a tokenizer with parsec?
02:08:01 <Jafet> You can write the tokenizer in parsec...
02:08:43 <jessopher> but given that parsec isnt infinite lookahead, it might make things a little less cumbersome to have an external lexer
02:09:05 <jessopher> but that depends entirely on the grammar
02:09:06 <mjrosenb> Jafet: i'm concerned about silly things like how intx cannot be parsed as "int x" in C/C++
02:09:35 <Jafet> jessopher: sure it is
02:09:50 <jessopher> is it? must be optional
02:09:52 <Jafet> try implements lookahead
02:10:31 <Jafet> Using monadic style, you can even parse context sensitive grammars
02:10:47 <Jafet> In theory, like C++
02:11:02 * jessopher always makes his own parser combinators
02:11:06 <Jafet> In practice, you'd get an aneurysm
02:12:03 <mjrosenb> Jafet: isn't parsing C++ turing complete?
02:12:18 <Jafet> No, only compiling it.
02:12:39 <Jafet> But you can parse perl with parsec, and the job is turing complete.
02:12:53 <Jafet> You can evaluate anything you want in the parser monad
02:13:19 <Jafet> If you restrict to applicative parsing, then you can only parse context-free grammars
02:13:23 <Jafet> Or something
02:14:12 <mjrosenb> anyhow, I have a functian 'var' that will parse any valid C identifier (and int, because it is kind of hard to not do that), and a parser that will parse "int"
02:14:33 <jessopher> oh right, Jafet, yeah it does, i was thinking about the backtracking
02:14:43 <mjrosenb> is this the wrong way to go about it?
02:15:06 * mjrosenb has written simple recursive descent parser combinators before
02:15:13 <mjrosenb> but neven gotten around to using parsec
02:15:15 <Jafet> mjrosenb: if you want to tokenize the input and parse tokens, do that. If you want to parse the input as a character stream, do that.
02:16:17 <mjrosenb> Jafet: is there a sane way to get what I described above without tokenizing it?
02:16:27 <Jafet> If you want to talk about the ontological differences and similarities between those approaches, we can do that too.
02:16:40 <Jafet> int >> spaces >> var
02:17:29 <Jafet> spaces = (whitespace | comment)+
02:17:40 <jessopher> you can also have var fail if the identifier is a keyword, or have a second pass that checks for that
02:17:58 <Jafet> You can also read a book on designing compilers
02:18:47 <mjrosenb> Jafet: yes, they all say "go write a tokenizer, then write a parser"
02:20:22 <mjrosenb> Jafet: (int >> spaces >> var) still accepts "intx", i'm guessing that spaces can consume 0 characters successfully.
02:21:26 <mjrosenb> jessopher: the issue is not recognizing that "int" shouldn't be a variable, it is recognizing that "intx" is not the same as "int x", but "int(x)" is the same as "int (x)"
02:21:36 <Jafet> Hey, it's not my fault that parsec happens to include a parser named “spaces”.
02:21:42 <mm_freak> is there an easy way to have a common constructor among all type family instances?
02:21:43 <Jafet> I don't even use parsec.
02:22:32 <mm_freak> i have a data family, where all instances are going to need a certain constructor besides adding their own
02:22:43 <sam___> how to write mulyiline codes in tryhaskell
02:22:55 <Jafet> Okay, so “spaces” actually needs to be “wordBoundary”.
02:23:00 <mjrosenb> sam___: multiline?
02:23:04 <jessopher> right, mjrosenb gotcha. just write a whitespace parser that requires it to match a minimum of whitespace
02:23:07 <Jafet> sam: first, download GHC
02:23:11 <sam___> ya
02:23:16 <Jafet> Then use GHC and not tryhaskell
02:23:26 <Eduard_Munteanu> sam___: Haskell Platform, actually
02:23:31 <Eduard_Munteanu> @where platform
02:23:32 <lambdabot> http://hackage.haskell.org/platform/
02:23:41 <Eduard_Munteanu> Not GHC in itself.
02:23:43 <sam___> k
02:23:52 <Ke> if you are using !windows, use a package manager
02:23:52 <Eduard_Munteanu> s/in/by/
02:24:03 * hackagebot scion-browser 0.1.3.3 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.1.3.3 (AlejandroSerrano)
02:25:16 <Jafet> Installing GHC via your package manager teaches you a beneficial lesson. The lesson is don't use your package manager to install GHC.
02:26:28 <Axman6> > let xs = zipWith (\a b -> (show a, b)) xs [1..] in xs
02:26:32 <lambdabot>   mueval-core: Time limit exceeded
02:26:44 <Axman6> :t let xs = zipWith (\a b -> (show a, b)) xs [1..] in xs
02:26:45 <lambdabot> forall b. (Enum b, Num b) => [(String, b)]
02:27:07 <jessopher> you will of course have to have a special case for (), since that should match "int >> many1 spaceChar >> var" anyhow (unless parenthesis is parsed by by var)
02:27:31 <jessopher> shouldn't*
02:28:08 <Eduard_Munteanu> Jafet: works fine for me in Gentoo.
02:28:46 <Eduard_Munteanu> Also I wouldn't recommend installing HP without the package manager system-wide. Locally it might be fine.
02:28:47 <Jafet> This is why gentoo corrupts the mind!
02:31:00 <jessopher> whats broken about it elsewhere?
02:43:37 <zhulikas> @type Map
02:43:38 <lambdabot> Not in scope: data constructor `Map'
02:43:50 <zhulikas> wat
02:44:20 <zhulikas> oh...
02:44:26 <Axman6> Map isn't an exported constructor
02:44:28 <zhulikas> type map
02:44:32 <zhulikas> @type map
02:44:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:44:40 <zhulikas> I am just looking at memoization
02:45:28 <zhulikas> hmm
02:45:33 <zhulikas> that's a powerful feature
02:47:51 <Axman6> eh?
02:48:38 <zhulikas> hmm can't figure out how to apply memoization
02:49:04 <Eduard_Munteanu> It's just a consequence of call-by-need :)
02:49:47 <zhulikas> and an example with memoized_fib uses partial application which I am not comfortable with :|
02:50:45 <zhulikas> oh it's not important
02:51:17 <Eduard_Munteanu> zhulikas: the idea is arranging to compute values in the right order so work doesn't get duplicated
02:52:09 <mm_freak> @hoogle ($!!)
02:52:10 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
02:52:53 <mm_freak> what version of deepseq is that?  i don't have it in 1.1.0.2
02:56:58 <mm_freak> oh, got it…  cabal installed an older version for some reason
02:59:05 * hackagebot scion-browser 0.1.3.4 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.1.3.4 (AlejandroSerrano)
03:01:03 <gienah> mm_freak: I guess the some reason might be related to: http://haskell.1045720.n5.nabble.com/Proposal-Make-NFData-a-fundamental-primitive-type-class-by-making-deepseq-a-GHC-boot-package-td4726462.html
03:03:16 <hpaste> zhulikas pasted “memoization ” at http://hpaste.org/54557
03:03:24 <zhulikas> I think I didn't apply it correctly
03:03:29 <zhulikas> program is still slow
03:03:58 <zhulikas> I thought it's enough just to use map and somehow it magically takes care of everything inside :)
03:04:47 <zhulikas> http://projecteuler.net/problem=254
03:05:38 <McManiaC> hey guys, why does GHC fail to find my iconv library when trying to compile/configure the base library?
03:05:46 <McManiaC> checking for library containing iconv... no
03:05:46 <McManiaC> configure: error: iconv is required on non-Windows platforms
03:05:54 <McManiaC> libiconv and iconv is installed
03:06:35 <McManiaC> (os is freebsd)
03:07:48 <papa_smurf> quick question: is there some kind of null file handle in haskell ? if so in which module do i have to search ?
03:08:24 <McManiaC> does it get confused because the libs lie in /usr/local/lib instead of /lib or /usr/lib/ ?
03:08:48 <mm_freak> gienah: it's just that i installed deepseq through pacman instead of cabal, so i got a somewhat older version
03:09:53 <Axman6> papa_smurf: you could open /dev/null
03:10:26 <papa_smurf> yeah but i rather want a way which would work for non-posix too
03:10:54 <mah_b> zhulikas: you have to pull the list out of the lambda
03:11:37 <papa_smurf> i could wrap it all up in Maybe's but thats a bit ugly
03:11:37 <zhulikas> you mean introduce an intermediate function which does whatever lambda does?
03:12:49 <hpaste> mah_b annotated “memoization ” with “memoization  (annotation)” at http://hpaste.org/54557#a54558
03:13:15 <mah_b> so lst gets computed just once
03:39:10 <mm_freak> about two years ago i was working mainly with MPTCs and fundeps, now i'm working with associated types
03:39:23 <mm_freak> i noticed that i'm typing MUCH more now, especially in type signatures
03:40:13 <mm_freak> i guess fundeps do have some justification, as they allow to express the same thing more concisely
03:41:02 <Axman6> there was some stuff in the SPJ talk on channel9 about fun with type functions (or something), that i thought made more sense with fundeps
03:41:12 <yitz> mm_freak: interesting observation
03:41:31 <yitz> mm_freak: you could write a quasi-quoter for it :)
03:41:58 <mm_freak> well, i think, i'll rather go back to fundeps for associated type synonyms =)
03:42:12 <mm_freak> and i haven't written a class with an associated data/newtype yet
03:42:33 <Axman6> he was using something like GNum a b where type GResult a b :: *; (+) :: a -> b -> GResult a b, which seems to me like it would be better expressed by class GNum a b c | a b -> c where (+) :: a -> b -> c. the types of everything you use from then onwards just need to give the class constraint
03:42:55 <mm_freak> Axman6: you mean type level arithmetic?
03:42:55 <Axman6> (assuming i've understood fundeps)
03:43:11 <Axman6> no, just having a generic (+) that could say add Int and Float
03:43:24 <mm_freak> ah, i see
03:43:55 <mm_freak> that's basically the idea used in the vector-space package
03:44:02 <Axman6> so, you'd have GNum Int Float Float and GNum Float Int Float, and be able to do 1 + 0.5 wherever you wanted
03:44:28 <mm_freak> though vector-space uses associated types for that
03:44:43 <mm_freak> one of the occasions where i really prefer them over fundeps
03:47:09 <mm_freak> Axman6: the idea is much easier to understand for vector spaces…  a vector space is a vector type with an associated scalar type
03:47:20 <mm_freak> and you have addition of two vectors and multiplication of a vector by a scalar
03:47:35 <mm_freak> class VectorSpace v where type Scalar v
03:47:45 <mm_freak> or equivalently:  class VectorSpace s v | v -> s
03:48:13 <mm_freak> in the former case you have:  (*^) :: Scalar v -> v -> v
03:48:24 <mm_freak> in the latter you have:  (*^) :: s -> v -> v
03:49:04 <Axman6> i think i prefer the latter
03:49:24 <Axman6> though, only in that specific case i guess
03:49:42 <Axman6> because it means you're always having to mention that s wven if you never use it
03:50:06 * Axman6 finds fundeps more newb friendly anyway
03:50:56 <mm_freak> i found associated types easier to understand and only understood fundeps after seeing that connection
03:51:14 <mm_freak> i guess that's why i preferred them for a long time
03:51:45 <mm_freak> fundeps are slightly more general though
03:52:12 <Axman6> well, my problem with (*^) :: Scalar v  -> v -> v is that it doesn't tell you at all what Scalar v's type actually is, you have to go and look it up
03:53:08 <Jafet> Well, you shouldn't need to care what it is
03:53:29 <Jafet> Though with mm_freak's VectorSpace you do
03:54:00 <Jafet> It has to be Fractional, at least
03:56:24 <mm_freak> Axman6: you would have to look up 's', too
03:57:03 <mm_freak> Axman6: you have to look either at the class head (fundeps) or at the associated types
03:57:25 <mm_freak> the good thing about Scalar is that it's more descriptive
03:58:08 <mm_freak> for example i have this class in my project:  class ArrowKleisli (>~) where type MonadOf (>~)
03:58:51 <mm_freak> with fundeps it would only be clear, because we usually call monads 'm'…  there is no other indication that it's a monad
03:59:15 <mm_freak> with MonadOf it's clear, and you can still give it a short name like 'm'
03:59:26 <mm_freak> (ArrowKleisli (>~), MonadIO m, MonadOf (>~) ~ m)
03:59:44 <mm_freak> with fundeps it would look like:  (ArrowKleisli m (>~), MonadIO m)
04:04:37 <gabor> lambdabot: help
04:05:09 <gabor> lambdabot: mute?
04:05:17 <gabor> very
04:05:45 <Axman6> that's not how you use lambdabot
04:05:47 <Axman6> @help
04:05:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:06:02 <gabor> thanks!
04:06:37 <gabor> @help
04:06:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:06:50 <Eduard_Munteanu> @list
04:06:51 <hpaste> zhulikas pasted “is this memoization?” at http://hpaste.org/54559
04:06:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:07:52 <zhulikas> I think re' is CAF, so it should be cached
04:07:55 <zhulikas> but still it's not
04:09:16 * hackagebot hoogle 4.2.8 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.8 (NeilMitchell)
04:11:47 <gabor> are bang-pattern bindings possible with _?
04:12:41 <Jafet> > let f !_ = () in f undefined
04:12:42 <lambdabot>   *Exception: Prelude.undefined
04:13:16 <gabor> ok seems to work, thanks!
04:13:55 <co_dh> greeting, I have a few question about T-algebra of Monad.
04:14:06 <co_dh> what's the T-algebra of Maybe Monad?
04:41:31 <carpi> I keep hearing the word "memoize it". could someone please tel lme what it means?
04:41:54 <carpi> in all instance where i saw it..is it possible the author acutally meant to say "memorize it"?
04:42:24 <zhulikas> nope :|
04:42:32 <zhulikas> it's caching of intermediate results
04:42:35 <mah_b> http://en.wikipedia.org/wiki/Memoization
04:42:37 <zhulikas> I am struggling with that atm too
04:44:25 <carpi> mah_b: thanks..atleast now i know what it is - )
04:46:20 <mm_freak> in a class instance, is there any way to bring the type variables from a class function into scope?
04:46:44 <hpc> mm_freak: eh?
04:47:23 <Gothmog_> @pl \i -> (i, f i)
04:47:23 <lambdabot> ap (,) f
04:47:28 <hpc> mm_freak: perhaps you want the scoped type variables extension?
04:47:29 <mm_freak> for example in Monad's return :: a -> m a, is there any way to bring the type variable 'a' into scope?
04:47:40 <hpc> mm_freak: scope where
04:47:41 <hpc> ?
04:47:51 <hpc> inside the function body?
04:47:56 <hpc> that's scoped type variables
04:47:57 <mm_freak> yes
04:48:14 <mm_freak> ScopedTypeVariables still doesn't let me write a type signature for class functions
04:48:30 <mm_freak> so i can't refer to the variables
04:48:56 <mm_freak> an ugly method would be:  return = return' where return' :: …
04:49:00 <hpc> i think it needs an explicit forall
04:49:09 <hpc> :t return
04:49:10 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:49:12 <mm_freak> it seems you don't understand the problem
04:49:16 * hackagebot hlint 1.8.19 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.19 (NeilMitchell)
04:49:19 <mm_freak> i can't even /name/ the variables
04:49:25 <mm_freak> in an instance definition
04:50:55 <hpc> use an explicit forall
04:51:02 <mm_freak> where?
04:51:18 <mm_freak> i CAN'T write a type signature in an instance definition
04:51:23 <hpc> return :: forall a. a -> m a; ...
04:51:39 <hpc> ...
04:51:44 <hpc> ...OHHHHH
04:52:26 <hpc> well that's just a bad syntax...
04:52:27 <mm_freak> my current ugly solution is:  return = return' where return' :: …
04:52:38 <hpc> yeah, i supose that's the best you can do then
04:52:41 <hpc> :/
04:53:03 <mm_freak> thought so, though with ScopedTypeVariables i may be able to write:  (return :: …) … = …
04:53:12 <mm_freak> but i doubt it
04:53:18 <hpc> that could be interesting
04:53:29 <mm_freak> and it's not much nicer anyway
04:54:38 <mm_freak> i'll go with my current solution then
04:56:32 <benmachine> mm_freak: what about return (x :: a)?
04:57:05 <benmachine> (presumably you already know what the m is)
04:57:28 <mm_freak> the 'm' is in scope anyway
04:57:34 <mm_freak> because it's a class variable
04:57:48 <benmachine> sure
04:57:59 <benmachine> so, does return (x :: a) get a into scope?
04:58:19 <mm_freak> yes, but unfortunately Monad was just an example
04:58:21 <McManiaC> why cant I install the Cabal lib with ghc 7.2.2 ?
04:58:30 <McManiaC> Configuring Cabal-1.10.1.0...
04:58:30 <McManiaC> Setup: At least the following dependencies are missing:
04:58:30 <McManiaC> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
04:59:11 <mm_freak> benmachine: i'd basically have to write a full type signature, because there are multiple type variables
04:59:35 <benmachine> mm_freak: well, you'd have to do that anyway, right?
05:00:22 <mm_freak> perhaps it's easier to understand when i post code
05:11:51 <lars`> pandoc does not compile under ghc7.2 ...
05:13:28 <hpaste> d-snp pasted “Let Case” at http://hpaste.org/54560
05:13:55 <d-snp> how does this work? I get an error saying I have incorrect indentation
05:14:04 <d-snp> am I not allowed to use a case in a let?
05:14:40 <mah_b> are you missing an `in'?
05:14:55 <mah_b> whats the context?
05:15:49 <sefb1704> hey.  when i am about to define the contract of a function that takes a list of tuples and returns a tuple that contains 2 lists, what should i write? my version doesnt work flashbangpow :: [a] -> ([a], [a])
05:16:16 <shachaf> sefb1704: If it's a list of tuples, you can use [(a,a)]
05:16:26 <benmachine> d-snp: you should indent the case more than the 'handler'
05:16:28 <shachaf> sefb1704: Even better, [(a,b)]
05:16:36 <d-snp> http://pastie.org/2928208 <-- more context
05:16:57 <carpi> (^) $sum [1..100] 2 "why does that not work?
05:16:58 <d-snp> oh more than the handler?
05:16:59 <d-snp> hmm
05:17:04 <shachaf> d-snp: Well, you're missing an "in".
05:17:08 <benmachine> d-snp: also, keep in mind that your first case branch matches everything
05:17:22 <shachaf> Also what benmachine said.
05:17:26 <benmachine> shachaf: yeah but that's fine if it's in a do-block, for example
05:17:42 <shachaf> benmachine: Only if the last line was less indented, no?
05:17:59 <mah_b> carpi: it parses ((^) (sum [1..100] 2))
05:18:04 <shachaf> I.e. lined up with the "let".
05:18:06 <benmachine> shachaf: oh, right, because the last line is an expression, hm
05:18:10 <benmachine> yeah
05:18:21 <benmachine> d-snp: a little more context would help
05:18:33 <d-snp> hey benmachine why does the first case match everything?
05:18:40 <benmachine> d-snp: because it's a variable
05:18:55 <benmachine> d-snp: case-branches can only be used to test against constructors
05:19:11 <benmachine> (you can tell if something is a constructor because it starts with a capital letter)
05:19:16 * hackagebot daemonize-doublefork 0.1.0 - Start background daemons by double-forking  http://hackage.haskell.org/package/daemonize-doublefork-0.1.0 (AlexandruScvortov)
05:19:25 <benmachine> (or a : in the case of infix constructors)
05:19:29 <carpi> mah_b: how do i make it parse ((^) (sum [1..100]) (2))?
05:19:30 <d-snp> oh
05:19:36 <shachaf> d-snp: "case" won't do arbitrary comparisons of two variables. How would it do that?
05:19:58 <benmachine> d-snp: remember that in something like case list of x:xs -> blah, you create new names 'x' and 'xs' in blah
05:19:59 <d-snp> that's weird? should I use a bunch of if statements then?
05:20:12 <shachaf> Probably not.
05:20:21 <d-snp> I'm a bit confused
05:20:21 <benmachine> d-snp: basically in case list of xs -> blah, you just create a new name xs and assign it to list, in blah
05:20:23 <mah_b> carpi: e.g. (^ 2) $ sum [1..100]
05:20:40 <benmachine> d-snp: a bunch of if statements would do the job, but there are slightly neater ways
05:20:42 <sefb1704> looks like you are busy, i think i will come back laterz
05:20:54 <benmachine> sefb1704: some people answered your question
05:21:10 <shachaf> sefb1704: ?
05:21:28 <shachaf> sefb1704: Did I not answer your question?
05:21:31 <mah_b> sefb1704: maybe look for `unzip'
05:21:57 <benmachine> d-snp: sometimes when I want to check a thing against lots of things, I use 'lookup'
05:21:58 <sefb1704> benmachine: y but sadly this doesnt solve my prob and i had to describe more and write more in chat but you are actually talking about something different and i dont want to confuse you ^^
05:22:08 <carpi> mah_b: thx.. it worke d)
05:22:12 <benmachine> sefb1704: we're usually busy. do it anyway and it might work :)
05:22:16 <shachaf> mah_b: Sure, that's the library function, but I assume sefb1704 is doing this for educational purposes.
05:22:21 <d-snp> lookup?
05:22:53 <d-snp> hmm
05:22:56 <benmachine> d-snp: 'lookup' takes an x and a list of (a,b) and checks the x against each a, returning Just b if they are equal and Nothing otherwise
05:22:58 <d-snp> it takes an array of pairs..
05:23:04 <benmachine> d-snp: so you can do something like
05:23:05 <shachaf> d-snp: lookup is one way. lookup "hello" ["hi" ==> "hmm", "hello" ==> "aha"] === Just "aha"
05:23:17 <shachaf> d-snp: No, a list. :-)
05:23:21 <d-snp> :P
05:23:26 <benmachine> shachaf: you'd need to define (==>) = (,) presumably?
05:23:33 <shachaf> (This is if you define the utility function (==>) = (,).)
05:23:35 <shachaf> benmachine: Yes.
05:23:45 <shachaf> It's useful because I find parentheses annoying.
05:24:05 <d-snp> I still don't get why a case statement wouldn't just work, what use is it if it can only match constructors?
05:24:08 <benmachine> > lookup 7 [(1,"one"),(2,"two"),(3,"skip a few"),(7,"seven")]
05:24:09 <lambdabot>   Just "seven"
05:24:11 <sefb1704> function: flashbangpow x = (helpera x, helperb x). helpera and helperb return lists. still this results in an error when the contract looks like this: flashbangpow :: [(a,b)] -> ([a], [b])
05:24:17 <shachaf> d-snp: Its use is... Matching constructors.
05:24:24 * shachaf is happy to be of help.
05:24:27 <d-snp> :P
05:24:31 <d-snp> thanks shachaf :)
05:24:31 <benmachine> d-snp: matching constructors is a pretty useful thing to do.
05:24:47 <shachaf> d-snp: How do you expect it to match arbitrary variables to each other?
05:24:52 <shachaf> Not using (==), I hope?
05:25:02 <d-snp> well.. I was hoping for == yeah..
05:25:03 <shachaf> "case" is much more fundamental in Haskell than (==).
05:25:23 <benmachine> shachaf: it's all a bit muddied by how case against 0 actually does use ==
05:25:28 <shachaf> (==) is just a function; it has no business in the language syntax.
05:25:32 <shachaf> benmachine: Shh.
05:25:34 <benmachine> :P
05:25:48 <benmachine> you're supposed to pretend that 0 and 1 and 2 are constructors of the Integer type
05:25:56 <benmachine> except that they're also polymorphic which is impossible
05:25:59 <shachaf> And of every other Num type.
05:26:16 <benmachine> anyway!
05:26:20 <shachaf> Anyway.
05:26:26 <benmachine> using case you can match against things like Just or Nothing or : or []
05:26:31 <benmachine> which you are going to want to do a lot
05:26:36 <d-snp> wait.. chunkType is a Num type
05:26:39 <shachaf> (==) has a very different meaning from "case".
05:26:51 <shachaf> You can have two values that are different but are still (==) to each other.
05:26:51 <d-snp> they are defined like payloadChunkType = 1
05:26:56 <sefb1704> ,.-´^`-.,_,.-´^`-.,_,.-´^`-.,_,.-´^`-.,  function: flashbangpow x = (helpera x, helperb x). helpera and helperb return lists. still this results in an error when the contract looks like this: flashbangpow :: [(a,b)] -> ([a], [b]) ,.-´^`-.,_,.-´^`-.,_,.-´^`-.,_,.-´^`-.,
05:27:00 <benmachine> d-snp: sure, but it still doesn't do what you want it to
05:27:06 <shachaf> d-snp: No, that doesn't make a difference.
05:27:37 <d-snp> in the haskell patterns tutorial they match on (0, _) in a case statement
05:27:39 <shachaf> sefb1704: Decorating your question doesn't help. We see it quite well without the decoration. :-)
05:27:45 <d-snp> surely that matches on 0 right?
05:27:50 <shachaf> d-snp: If you pretend 0 is a constructor, it works out.
05:27:54 <sefb1704> shachaf: dammit ^^
05:28:10 <shachaf> sefb1704: However, it's very unclear what you're actually asking.
05:28:29 <sefb1704> shachaf: the contract is wrong
05:28:31 <Jafet> :t map fst &&& map snd
05:28:31 <benmachine> sefb1704: ok first of all, call it a 'type' not a contract, contracts are a little different as ideas
05:28:32 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
05:28:41 <benmachine> sefb1704: secondly, it depends what helpera and helperb do
05:28:51 <mah_b> sefb1704: -^-^-^-^-^-^-^ imho you could shorten the discussion through pasting some code .-.-.-.-.-.-
05:29:07 <sefb1704> mah_b: okey
05:29:08 <shachaf> If an implementation and a type signature disagree, the implementation is always wrong.
05:29:26 <benmachine> shachaf: haha. that's a weird idea if you ask me :P
05:29:51 <hpaste> sefb1704 pasted “Some code” at http://hpaste.org/54561
05:30:13 <benmachine> d-snp: basically, matching against a pattern involving a variable doesn't use what that variable is
05:30:19 <benmachine> d-snp: in fact it doesn't even need that variable to exist
05:30:27 <mah_b> change the [ to ( in the helpers
05:30:44 <shachaf> See? I knew it wasn't the type signature.
05:31:01 <hpaste> mah_b annotated “Some code” with “Some code (annotation)” at http://hpaste.org/54561#a54562
05:31:03 <sefb1704> umm i dont see anything :D
05:31:57 <d-snp> benmachine: I ran this: http://pastie.org/2928251, and it said "vijf"
05:32:00 <benmachine> sefb1704: what mah_b just said
05:32:15 <benmachine> d-snp: right. but 0 and 5 aren't variables
05:32:35 <benmachine> they're... well, pedantically, they're not quite constructors, but case pretends they are
05:32:35 <lukish> Did haskell have fast power function? http://redd.it/mqtk6
05:32:37 <shachaf> d-snp: For the purposes of this discussion, you can pretend that 0 and 5 are constructors.
05:32:46 <shachaf> I.e. data Integer = 0 | 5
05:33:06 <shachaf> (And maybe a couple of other values that I'm forgetting.)
05:33:12 <sefb1704> mah_b: i dont see the difference oO
05:33:12 <benmachine> lukish: what you're looking for is specifically a way to calculate a^b mod m quickly
05:33:23 <benmachine> lukish: the standard library doesn't have one but they're not that hard to write
05:33:32 <mah_b> sefb1704: l 16 + 18, as I said
05:33:34 <benmachine> lukish: the code would be similar to the code for (^)
05:33:57 <benmachine> sefb1704: check the type of brackets
05:33:58 <d-snp> hmm
05:35:02 <d-snp> argh!
05:35:16 <lukish> benmachine: all that I should do is a mix of `iterate' and `mod' ?
05:35:17 <d-snp> you are right.. why does it do that :(
05:35:41 <mah_b> @type (\a -> case a of {[x:xs] -> True; [] -> False})
05:35:42 <lambdabot> forall t. [[t]] -> Bool
05:35:43 <d-snp> if I replace 5 with 'vijf where vijf = 5' then it doesn't work..
05:35:51 <mah_b> @type (\a -> case a of {(x:xs) -> True; [] -> False})
05:35:51 <d-snp> that makes no sense at all
05:35:52 <lambdabot> forall t. [t] -> Bool
05:36:03 <benmachine> d-snp: it does make sense; patterns are different from expressions
05:36:24 <benmachine> d-snp: try case x of 0 -> putStr "blah"; vijf -> print vijf
05:36:58 <benmachine> d-snp: then tell me if you think let vijf = 5 in case x of ... should print something different
05:37:14 <sefb1704> mah_b: with your changes the following error message occurs: Couldn't match expected type `([a], [b])' with actual type `[a0]'
05:37:22 <benmachine> lukish: that will be slow; it's much faster to do it with repeated squaring
05:37:44 <benmachine> lukish: probably won't be *that* slow, but still
05:38:17 <benmachine> lukish: http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/src/GHC-Real.html#^ this is the slightly more complicated but much faster way
05:39:17 <mah_b> sefb1704: just havent seen this. remove line 12, it isnt needed, and should be ([], []) to be of the right type.
05:39:21 <sefb1704> mah_b: okey forget about that i fixed it :)
05:39:36 <sefb1704> mah_b: oh okey
05:40:19 <sefb1704> nice nice nice ..
05:40:49 <sefb1704> so my mistake was basically the type of brackets i used .. i can live with that :)
05:41:29 <lars`> anyone using homebrew in Mac? i edited the 'ghc' formula to install 7.2.4, but now dunno how to restore that formula to default
05:43:37 <sefb1704> thank you benmachine, mah_b and shachaf ♥
05:43:43 <sefb1704> over and out
05:54:41 <adrienhaxaire> hello
05:55:59 <siracusa> Hello adrienhaxaire
05:56:57 <adrienhaxaire> i should take the habbit of hanging out here more often
05:57:12 <adrienhaxaire> even if i am too newbie to really help
05:57:26 <adrienhaxaire> it's always nice
05:57:46 <donri> you should hang here *especially* if you're a newbie :^)
05:57:58 <adrienhaxaire> :)
05:58:49 <irene-knapp> yepyep
06:00:03 <adrienhaxaire> if i am working on an experimental library, should i upload it to hackage only when stable ?
06:00:28 <benmachine> you should upload it to hackage when it might be usable by others
06:00:40 <benmachine> there are lots of experimental/unstable libraries on hackage
06:00:55 <benmachine> but there are also crappy libraries on hackage and you don't want to be one of those :P
06:00:56 <adrienhaxaire> yeah, that's what i thought too
06:01:07 <benmachine> if you just want to show your stuff to people you could put it on github or something
06:01:08 <adrienhaxaire> ha ha ! good point
06:01:22 <adrienhaxaire> it is already on github
06:01:44 <adrienhaxaire> it was more to register it properly
06:01:50 <shachaf> donri: Why especially?
06:01:53 <adrienhaxaire> but it can wait for sure
06:02:09 <adrienhaxaire> why to register it on hackage ?
06:03:29 <d-snp> ah this is just terrible, I can't wrap my mind around how useless it is that haskell doesn't have a switch statement for expressions
06:03:34 <irene-knapp> case
06:03:37 <irene-knapp> it's called case
06:03:40 <d-snp> it's not :(
06:03:50 <irene-knapp> what behavior do you want out of it that you aren't finding?
06:04:04 <shachaf> d-snp: It's perfectly logical. I wouldn't *want* case to do (==).
06:04:13 <d-snp> shachaf, yeah you don't, I do :P
06:04:23 <benmachine> d-snp: haskell doesn't have syntax for it because it's easy to do without syntax
06:04:31 <shachaf> It would be ugly. There are other ways of comparing expressions.
06:04:39 <shachaf> What benmachine said.
06:04:50 <d-snp> by using lookup? which returns a Maybe?
06:04:50 <hpc> d-snp: case () of _ | foo == bar -> ...
06:04:57 <irene-knapp> (==) is not the only equality predicate in existence
06:05:03 <hpc> | thisThingIsTrue -> ...
06:05:03 <d-snp> oh hpc
06:05:12 <d-snp> that's nice :D
06:05:17 <irene-knapp> for example, there's structural equality, and then there's equality based on an identifier field
06:05:17 <hpc> or you can put the guard right in the definition of the thing
06:05:19 <benmachine> d-snp: yeah, so you case-match on the lookup, or use fromMaybe, or write your own helper
06:05:21 <hpc> foo x | x == ...
06:05:30 <shachaf> hpc: That's one of the uglier (syntactically) ways to do it...
06:05:39 <irene-knapp> making special syntax that inferred (==) as the predicate would piss off those of us who understand this
06:05:42 <benmachine> http://haskell.org/haskellwiki/Case this is a terribly-named wiki page but still
06:06:03 <d-snp> shachaf: I haven't found one that's prettier than what hpc just suggested..
06:06:16 <hpc> shachaf: i don't know of a prettier way
06:06:25 <donri> is there much of a point to using a Map for something with less than 100 keys or am i being influenced too much by a python background?
06:06:27 <shachaf> d-snp: You don't think the "lookup" thing is, for instance?
06:06:27 <hpc> shachaf: besides doing a huge guard in conjunction with a where clause
06:06:50 <hpc> donri: there's a point
06:06:56 <shachaf> donri: Well, if you're representing a mapping, a Map is often one good way to do it.
06:07:03 <shachaf> It's not about efficiency so much as about meaning.
06:07:06 <hpc> donri: even if you know it won't hold more than say 100 keys, just the fact that there is a mapping would make it useful
06:07:10 <Peaker> donri: Map conveys your intention and has more useful combinators
06:07:12 <hpc> because someday it might
06:07:12 <donri> yes, i thought for example how it ensures uniqueness of keys?
06:07:36 <benmachine> yeah that's handy too
06:07:38 <Peaker> if we had TMap it would have been even better
06:07:53 <hpc> donri: basically, you use the tool at hand; if there's an obvious mapping between two things, use a map :P
06:08:08 <shachaf> hpc: Or a function.
06:08:14 <shachaf> Functions are good at mapping things to other things.
06:08:15 <hpc> or a function, i was just about to say lol
06:08:31 <donri> how about using a Text type for just short sentences? :P
06:08:32 <irene-knapp> a Map is not a hash table
06:08:47 <irene-knapp> so the space-efficiency concerns that you're used to with them in Python and Perl do not apply
06:08:58 <irene-knapp> if that's the motivation between your saying "about 100 keys"
06:09:08 <shachaf> donri: The benefits of using Text diminish for smaller strings.
06:09:12 <hpc> haskell maps are still really fast, but not in the same way that perl hashes are
06:09:18 <irene-knapp> yeah
06:09:19 <donri> i was thinking speed, between Map and [(k,v)]
06:09:20 <shachaf> irene-knapp: I assumed the motivation was "linear-time lookup isn't that bad".
06:09:27 <donri> and Prelude.lookup vs Map.lookup
06:09:29 <irene-knapp> shachaf: ah, hm
06:09:40 <irene-knapp> that's possible too
06:09:58 <hpc> donri: when you use associative lists, you find yourself rewriting a lot of Map functions, in my experience
06:10:03 <shachaf> Anyway, a potential implementation for Map is [(k,v)]
06:10:18 <shachaf> Even if Map was implemented that way you'd still want to use the Map type for a mapping.
06:10:30 <benmachine> you can use Text for short sentences, probably
06:12:41 <Jafet> donri: "I think, therefore I am right"
06:12:49 <Jafet> @hackage criterion
06:12:49 <lambdabot> http://hackage.haskell.org/package/criterion
06:12:50 <irene-knapp> Jafet: "You don't, therefore you aren't"? :D
06:13:47 <shachaf> There's still room for a Haskell benchmarking library called something along the lines of "hench".
06:13:52 <irene-knapp> haha
06:13:55 <donri> shachaf: you mean, because Map is still a more specific type? but doesn't that argument hold true for String vs Text too then?
06:13:56 <irene-knapp> quite so
06:16:08 <benmachine> donri: yes. using Text is only a problem because String APIs tend to be richer
06:16:16 <benmachine> otherwise there's nothing wrong with it
06:16:40 <shachaf> The String/Text situation is a bit weird.
06:17:08 <Jafet> Isn't String isomorphic to Text?
06:17:41 <Jafet> Disregarding bums
06:17:50 <shachaf> Through (pack,unpack)?
06:18:01 <irene-knapp> oh, you mean byte-order marks
06:18:10 <donri> the same is true for Map with fromList, toList
06:18:15 <irene-knapp> they're isomorphic, but they have different performance characteristics in both space and time
06:18:17 <shachaf> donri: Not really.
06:18:23 <Jafet> donri: no. Consider [(1,2), (1,3)].
06:18:24 <irene-knapp> since String is a linked list of characters
06:18:25 <shachaf> toList . fromList =/= id
06:18:30 <donri> oh, because the map conversion is "lossy"
06:18:51 <shachaf> donri: Well, that's kind of important when you're talking about isomorphism. :-)
06:18:58 <donri> :D
06:19:14 <shachaf> is-o-morphism
06:19:35 <Jafet> In fact, toList.fromList is not even identity for [(2,()), (1,())].
06:19:48 <donri> because ordering?
06:19:52 <lukish> benmachine: http://www.reddit.com/r/haskell/comments/mqtk6/fast_power_function/c3345eg
06:20:03 <lukish> It works fast
06:20:08 <lukish> Thanks for advices
06:20:08 <lukish> !
06:20:12 <irene-knapp> yes, because ordering
06:20:24 <benmachine> lukish: :)
06:20:35 <benmachine> lukish: incidentally, div (pow-1) 2 is the same as div pow 2 when pow is odd
06:20:37 <shachaf> It even looks fast.
06:20:38 <benmachine> because div rounds down
06:20:42 <shachaf> It has "fast" right in its name.
06:20:52 <benmachine> shachaf: :D
06:21:21 <carpi> could someone please tell me how to make ths work.. ? "read "c" :: Char
06:21:40 <shachaf> carpi: Step 1: Have a balanced number of quotation marks.
06:21:46 <donri> read "'c'" :: Char
06:21:46 <irene-knapp> > read 'c' :: Char
06:21:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:21:48 <lambdabot>         against inferred ty...
06:22:02 <irene-knapp> > read "'c'" :: Char
06:22:02 <lambdabot>   'c'
06:22:02 <irene-knapp> there we go
06:22:12 <irene-knapp> the "read" function is for parsing Haskell-esque syntax
06:22:19 <irene-knapp> it's not really for arbitrary input
06:22:26 <donri> well, depends on the Read instance ;)
06:22:30 <irene-knapp> if you want character-by-character input, use !!
06:22:31 <irene-knapp> well, yes
06:22:46 <shachaf> donri: No, the "read" function is for parsing Haskell-esque syntax.
06:22:51 <shachaf> It's one of the Read laws.
06:22:59 <carpi> ah.. thanks. how simple.. thanks - )
06:23:08 <irene-knapp> I was more relying on the fuzziness of -esque
06:23:19 <shachaf> You need to prove it for every Read instance before it's considered valid.
06:23:33 <donri> i thought it was just supposed to be the inverse of show
06:23:34 <lukish> benmachine: it is the same, but that looks safer I think
06:23:40 <lukish> Not the big deal, actually
06:23:47 <donri> but then not all Show instances hold all information
06:23:51 <donri> e.g. Data.Dynamic
06:23:54 <benmachine> lukish: no, not a big deal, just pointing it out :)
06:23:59 <lukish> Ok
06:24:13 <irene-knapp> "Sure, this syntax uses balanced Japanese brackets encoded in a modified SJIS that uses EBCDIC for the first codepage, but it's LIKE Haskell!"
06:24:14 <shachaf> donri: What if something isn't even an instance of Show?
06:24:16 <shachaf> What then?
06:24:20 <donri> in deed
06:24:27 * shachaf to sleep.
06:24:46 <benmachine> shachaf: Read doesn't have laws
06:24:50 <benmachine> it has friendly suggestion
06:24:52 <benmachine> s
06:24:57 <shachaf> benmachine: Except for that one law.
06:26:46 <Jafet> foreign import ccall "mpz_powm"
06:26:56 <Jafet> Fast power function.
06:26:59 <irene-knapp> heh
06:28:41 <shachaf> Is a power function like a power set?
06:28:43 <irene-knapp> no.
06:29:15 <Jafet> It's an event where politicians get together.
06:30:06 <shachaf> type Power T = T -> Bool
06:30:30 * irene-knapp blinks
06:30:35 <irene-knapp> wait, what?
06:31:27 <shachaf> What?
06:31:55 <irene-knapp> I don't understand that definition, possibly because I am missing some basic knowledge that I should have.  could you explain it? :D
06:31:58 <irene-knapp> I mean I understand what it's saying
06:32:02 <irene-knapp> but not why that name makes sense
06:32:28 <Eduard_Munteanu> Probably in the sense of Power T ~ 2^T
06:32:34 <irene-knapp> oh, hm
06:32:38 <irene-knapp> right, I see
06:33:01 <Jafet> power = map (flip elem) $ subsequences [minBound..]
06:33:05 <irene-knapp> heh!
06:33:05 <Peaker> what's a quick&easy way to show doubles while discarding very low/insignificant digits?
06:33:15 <Peaker> (inaccuracies be damned)
06:33:39 <Jafet> > text $ printf "%f" pi
06:33:40 <lambdabot>   3.141592653589793
06:33:45 <Jafet> > text $ printf "%.6f" pi
06:33:46 <lambdabot>   3.141593
06:33:53 <Jafet> > text $ printf "%.6f" (pi*10^9)
06:33:54 <lambdabot>   3141592653.589793
06:34:00 <Peaker> thanks, was hoping for type-safer than printf :)
06:34:07 <irene-knapp> oh, doubles
06:34:10 <irene-knapp> like double-precision
06:34:12 <irene-knapp> right
06:34:14 <irene-knapp> I misread
06:34:23 <Jafet> printg :: Double -> String; printg = printf "..."
06:34:29 <Jafet> Perfectly type-safe
06:34:29 <irene-knapp> @hoogle Double -> String
06:34:29 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
06:34:30 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:34:30 <lambdabot> Prelude show :: Show a => a -> String
06:34:30 <shachaf> Jafet: Are you some kind of constructionist?
06:34:36 <irene-knapp> @hoogle Double -> a -> String
06:34:37 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:34:37 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
06:34:37 <lambdabot> Language.Haskell.Pretty prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String
06:34:46 <irene-knapp> @hoogle a -> Double -> String
06:34:46 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:34:46 <lambdabot> Language.Haskell.Pretty prettyPrintWithMode :: Pretty a => PPHsMode -> a -> String
06:34:46 <lambdabot> Network.HTTP.Auth withAuthority :: Authority -> Request ty -> String
06:34:48 <irene-knapp> hmm
06:34:51 <irene-knapp> none of those looks right
06:34:55 <irene-knapp> I would check under Numeric
06:34:56 <Gracenotes> I really don't like scientific notation
06:35:02 <Gracenotes> for printing doubles, at least
06:35:12 * irene-knapp nods
06:35:13 <Eduard_Munteanu> You could always multiply by 10^n, floor and go back.
06:35:15 <Gracenotes> I would prefer 30 zeroes in a row :/
06:35:18 * shachaf is seeing double all over the screen.
06:35:24 <irene-knapp> cute
06:35:26 <shachaf> Maybe I should actually go to sleep.
06:35:28 <irene-knapp> heh yes
06:35:29 <Jafet> shachaf: assuredly not. Try applying power to Nat.
06:35:30 <irene-knapp> indeed
06:35:59 <tijn> hi, how do I convert [Char] to String in:
06:36:00 <tijn> src/Main.hs:55:58:
06:36:00 <tijn>     Couldn't match expected type `Map.Map [Char] Integer'
06:36:00 <tijn>                 with actual type `String -> Map.Map String Integer'
06:36:00 <tijn>     In the second argument of `secureReadFileMap', namely `features'
06:36:00 <tijn>     In the expression: secureReadFileMap featFileNL features
06:36:01 <tijn>     In an equation for `featNL':
06:36:04 <tijn>         featNL = secureReadFileMap featFileNL features
06:36:10 <shachaf> Jafet: I'm happy to hear that.
06:36:16 <tijn> I thought it was the same...
06:36:20 <shachaf> tijn: You convert [Char] to String by doing nothing.
06:36:24 <shachaf> It is indeed the same.
06:36:25 <irene-knapp> hah
06:36:27 <tijn> why do I get the error?
06:36:31 <Gracenotes> also, Numeric has showFFloat
06:36:39 <Eduard_Munteanu> tijn: use a pastebin
06:36:43 <irene-knapp> secureReadFileMap is missing a parameter
06:36:43 <shachaf> tijn: "Map.Map String Integer" isn't the same as "String -> Map.Map String Integer"
06:36:51 <irene-knapp> you want to give it a String immediately before the Map
06:36:54 <shachaf> tijn: Also, yes, don't paste more than a couple of lines directly into the channel, please.
06:36:54 <tijn> o yes, I see, I'm missing an argument
06:37:02 <tijn> ok will do
06:37:06 <benmachine> Peaker: concat [x,".",y] where (x,y) = divMod (floor (x * 1000)) 1000 -- I silly
06:37:07 <Eduard_Munteanu> @where hpaste
06:37:08 <tijn> or not do :-)
06:37:08 <lambdabot> http://hpaste.org/
06:37:30 <benmachine> Peaker: alternatively, see if Numeric's showEFloat etc. do what you want
06:37:35 <Gracenotes> Peaker: ooh, actually
06:37:41 <irene-knapp> benmachine: oddly enough, that's roughly what GHC's parser does for Rationals
06:37:43 <Gracenotes> showFFloat Nothing (10**(-30)) "" -> "0.000000000000000000000000000001"
06:37:57 <irene-knapp> benmachine: I know this because that was how my can't-build-GHC problems manifested
06:38:08 <benmachine> irene-knapp: huh, weird
06:38:10 <irene-knapp> yeah
06:38:18 <Gracenotes> also has showHex, which is nice
06:38:34 <Gracenotes> :t showIntAtBase
06:38:35 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
06:38:41 <Gracenotes> that one's a mess
06:39:11 <shachaf> > uncurry (++) . second (take 5) . break (=='.') . show $ (pi :: Double)
06:39:13 <lambdabot>   "3.1415"
06:39:28 <shachaf> Beautiful, eh?
06:39:52 <irene-knapp> heh
06:39:54 <Gracenotes> what have you done!?
06:40:04 <shachaf> Paritcularly how it'll work with "scientific notation".
06:40:15 <Eduard_Munteanu> > (/ 100) . fromIntegral . floor . (* 100) $ pi
06:40:17 <lambdabot>   3.14
06:41:17 <Jafet> > uncurry (++) . second (take 5) . break (=='.') . show $ 3.14e100
06:41:19 <lambdabot>   "3.14e1"
06:42:38 <Jafet> > uncurry (++) . second (uncurry (++) . first (take 5) . break (`elem`"eE")) . break (=='.') . show $ 3.1415926e100
06:42:40 <lambdabot>   "3.1415e100"
06:42:48 <Jafet> Now your turn, shachaf. Correctly implement rounding.
06:43:00 <Eduard_Munteanu> Heh.
06:43:04 <irene-knapp> hahaha
06:43:24 <irene-knapp> > gcd 3141592653589793238 1000000000000000000 :: Integer
06:43:25 <lambdabot>   2
06:43:27 <Eduard_Munteanu> > (/ 10000) . fromIntegral . round . (* 10000) $ pi   -- :P
06:43:29 <lambdabot>   3.1416
06:43:32 <irene-knapp> > gcd (3141592653589793238 * 1) (1 * 1000000000000000000) :: Integer
06:43:33 <lambdabot>   2
06:43:39 <irene-knapp> yeah, it works on lambdabot :(
06:43:43 <irene-knapp> but NOT on my system :(
06:43:46 <irene-knapp> I get 0 for the second one
06:44:19 <Eduard_Munteanu> Yeah zero is the best divisor :P
06:44:19 <irene-knapp> the reason is that the rule that's supposed to turn * into a primop call doesn't fire
06:44:34 <mellum_> I want to check if two IntSets intersect. Is there something more clever than null (intersection a b)? It seems like that might be inefficient
06:45:00 <irene-knapp> (well, there are two problems.  there's ALSO a bug in the implementation of small-Integer gcd, which was masked by the fact that the constant folder prevents that codepath from executing)
06:45:03 <Jafet> mellum: IntSet is quite lazy
06:45:10 <irene-knapp> (but I don't care about that one because it affects everyone, not just me)
06:45:45 <irene-knapp> anywa, the rule doesn't fire because the DFunUnfolding never translates the generic version of * into the specific one for the Num Integer instance
06:45:53 <mellum_> Jafet: Hmm. Okay, I'll do it like that then
06:45:57 <irene-knapp> because it isn't recorded in the identifier in the Core
06:46:00 <papa_smurf> which haskell compilers do support MultiParamTypeClasses and FlexibleInstances ?
06:46:05 <irene-knapp> so now I'm trying to figure out why that would be
06:46:18 <shachaf> Jafet: <Peaker> what's a quick&easy way to show doubles while discarding very low/insignificant digits? <Peaker> (inaccuracies be damned)
06:46:22 <Eduard_Munteanu> There was a list of extensions somewhere, on the GHC wiki IIRC
06:46:23 <irene-knapp> papa_smurf: you want to use GHC unless you're doing something experimental
06:46:27 <shachaf> I consider my work complete.
06:46:39 <Jafet> Work? I was playing!
06:47:03 <Phyx-> papa_smurf: where's smurfette?
06:47:16 <dschoepe> papa_smurf: Hugs also supports them, I think
06:47:19 <shachaf> Jafet: Yes, with fire.
06:47:40 <papa_smurf> irene-knapp: i am useing ghc, just if Hugs etc. support that too
06:47:54 <papa_smurf> *just wondered
06:47:59 <irene-knapp> papa_smurf: okay, just wanted to save you the trouble of learning that the other implementations don't advance as quickly
06:49:02 <papa_smurf> Phyx-: in my bed of course ;)
06:49:40 <irene-knapp> ewwww isn't she like your daughter!
06:50:11 <Phyx-> papa_smurf: that's just wrong
06:50:27 <jerry_> can we do if then else statements insoide do notation
06:50:33 <irene-knapp> jerry_: yes but the syntax is different
06:50:44 <jerry_> irene-knapp: can you show me example pls
06:50:56 <Jafet> There are no if-then-else statements, only if-then-else expressions
06:51:00 <papa_smurf> dschoepe: thanks for the answer
06:51:11 <irene-knapp> oh sorry, right, syntax is the same :)
06:51:13 <irene-knapp> but fiddly :)
06:51:25 <irene-knapp> > do { if 1 < 2 ; then putStrLn "Reality holds." ; else putStrLn "The end times have come!" }
06:51:26 <lambdabot>   <no location info>: parse error on input `;'
06:51:40 <irene-knapp> hmm
06:51:52 <irene-knapp> > do { if 1 < 2 then putStrLn "Reality holds." else putStrLn "The end times have come!" }
06:51:53 <lambdabot>   <IO ()>
06:51:57 <irene-knapp> but that's not very helpful
06:52:20 <irene-knapp> basically the rule is that the if-then-else expression should, as a whole, have the same type as a single line of the "do" would
06:52:32 <irene-knapp> which means both the "then" and "else" clauses have to be actions in the same monad as the "do"
06:52:51 <jerry_> irene-knapp: yes i know..just wanted to see if syntax is exactly the same as if not inside "do"
06:52:52 <irene-knapp> they can either be single statements or like "do ..." themselves
06:52:56 <irene-knapp> yes, it's the same
06:53:01 <irene-knapp> unlike "let" which is different
06:53:04 <papa_smurf> does that lambdabot behave like ghci and reacts on posts starting wiht ">" ?
06:53:05 <irene-knapp> (similar, but different)
06:53:11 <Jafet> Basically if-then-else expressions suck even more as statements as they usually do. Use when, unless, and guard
06:53:15 <jerry_> irene-knapp: thanks a lot
06:53:19 <irene-knapp> papa_smurf: yes
06:53:22 <Jafet> :t when
06:53:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
06:53:29 <Eduard_Munteanu> papa_smurf: yeah, though it doesn't take ghci commands per se
06:53:31 <Eduard_Munteanu> @list
06:53:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:53:57 <papa_smurf> irene-knapp: wow thats cooool
06:54:00 <irene-knapp> yeah, it is
06:54:44 <papa_smurf> Eduard_Munteanu: thanks
06:55:16 <Eduard_Munteanu> (> and :t are aliases for @run and @type respectively)
07:04:04 <tijn> can somebody direct me to a library or webpage where reading and wrinting to and from files is explained in depth? I find myself creating new specialized functions for different type (such as maps, strings, lists of xyz's etc)
07:04:21 <carpi> could someone please recommend me a haskell library that allows me to concurrently run the same function on different arguments? i have 4 cores and it would be nice to be able to use all 4 cores
07:05:29 <Peaker> yay, implemented a toy multiplication via fft :-)
07:05:38 <Peaker> Signal processing is fun :)
07:05:42 <irene-knapp> haha cool
07:08:25 <hpaste> Peaker pasted “FFT, convolution, and multiplication” at http://hpaste.org/54566
07:08:37 <Peaker> The pure-fft package on hackage is wrong... I wasted some time on it long ago
07:08:48 <irene-knapp> yeah, I wrote my own fft, heh
07:08:58 <Peaker> can I see yours?
07:09:01 <irene-knapp> sure
07:09:02 <irene-knapp> one sec
07:09:08 <irene-knapp> it's longer than yours :)
07:09:14 <irene-knapp> and it uses mutable arrays internally
07:09:20 <applicative> carpi, hm, these are 'pure' functions, not io actions?
07:09:58 <Peaker> irene-knapp: Mine is for pedagogical reasons, not performance
07:10:02 * irene-knapp nods
07:10:05 <irene-knapp> fair
07:10:11 <Eduard_Munteanu> Mmm... you can just use FFTW, can't beat that.
07:10:25 <hpaste> irene-knapp pasted “Fourier.hs” at http://hpaste.org/54568
07:10:28 <carpi> applicative: yes. only pure functions. only the final result needs to be printed on screen
07:10:31 <irene-knapp> there you go
07:11:06 <irene-knapp> this "input/output bundle" concept is to allow the same code to be used for forward and reverse
07:11:19 <irene-knapp> as you can see, the "bundle" thingy isn't exported
07:11:42 <Peaker> irene-knapp: why are you forward/inverse fft implementations not sharing code?
07:11:45 <irene-knapp> the two functions at the top are the drivers that handle windowing and the like
07:11:46 <irene-knapp> they are
07:11:55 <applicative> carpi, the crudest way is Control.Parallel, using par and pseq.
07:11:58 <irene-knapp> the function discreteFourierTransformHelper is the shared part
07:12:08 <irene-knapp> and, as you can see, is about half the file
07:12:38 <carpi> applicative: by crude you mean.. the least efficient way?
07:12:50 <Peaker> irene-knapp: that's a lot of code :)
07:12:53 <irene-knapp> yes :)
07:12:57 <irene-knapp> it works, too :)
07:13:22 <Peaker> irene-knapp: why not fftw as Eduard_Munteanu asked?
07:13:38 <irene-knapp> it was annoying as hell to write because I didn't initially even really understand what a Fourier transform did, and none of the sources I could find explained it without stupid-Greek-letters notations
07:14:00 <irene-knapp> oh, that's a C package?
07:14:05 <irene-knapp> mm
07:14:09 <applicative> carpi,  no, there are lots of libraries attempting to make it smooth, that's all.  They use Control.Parallel, but export more complex structures.
07:14:13 <irene-knapp> I don't like dependencies?  I had free time?
07:14:16 <Peaker> irene-knapp: yeah -- it took me a long time to understand why DFT works, and then a bit more time to understand why FFT does DFT
07:14:20 * irene-knapp nods
07:14:28 <irene-knapp> that part I get
07:14:31 <Peaker> But it's so simple -- maybe I should write an FFT tutorial :)
07:14:36 <Peaker> DFT/FFT tutorial
07:14:37 <Eduard_Munteanu> φωυριηρ :P
07:14:44 <irene-knapp> you probably should!  just make sure it provides sufficient detail to implement from
07:14:53 <Peaker> I explained it to a smart friend and he understood very quickly
07:14:57 <irene-knapp> covering details like how you choose a windowing function and what properties your window and overlap have to satisfy
07:15:09 <applicative> carpi, this StackOverflow thing brings out some of the main things. http://stackoverflow.com/questions/1798996/multicore-programming-in-haskell-control-parallel
07:15:12 <irene-knapp> that was a specific point that confused me for ages
07:15:24 <Peaker> irene-knapp: I'm talking about more basic things.. like: Why does multiplying by various-speed rotating complex numbers is helpful
07:15:33 <carpi> applicative: ah akay.. thank you for link.. i will take a look at it.
07:15:36 <irene-knapp> and also, I was working with augur and at first he didn't believe me when I told him that you don't do a sliding window of interval one
07:15:52 <applicative> carpi: note the link to the slides by dons on that page. There used to be some simple illustrative code around associated with it, I can't seem to find it.
07:15:57 <irene-knapp> and that each x-coordinate in the frequency-domain representation corresponds to an entire window's worth of data
07:16:02 <irene-knapp> in the time-domain representation
07:16:18 <irene-knapp> because he had only had it covered from a "what does this do for me" perspective, which left out those implementation details
07:16:35 <irene-knapp> yeah, hmmm, the complex-number view is okay
07:16:40 <applicative> carpi, the stack overflow question arose from the writer's putting too fine a grain on the parallelism, this is one of the things advanced libraries try to make easily adjustable
07:16:43 <Peaker> irene-knapp: yeah -- it is really made clear if you just show what DFT does to complex numbers rotating at "whole" frequencies (on their own, first)
07:16:59 <irene-knapp> yeah, indeed.  well someone in here linked a visualization thingy some months back...
07:17:11 <irene-knapp> showing exactly that
07:17:21 <irene-knapp> (it wasn't interactive, just static diagrams, and more conceptual than accurate, but.)
07:17:40 <Peaker> irene-knapp: the visualization thingie didn't help me.. my view is, I think, simpler:  You just rotate counter-clockwise at various speeds, and see where your rotation cancelled out the original signal's rotation. When they cancel out -- the output sum is not 0
07:17:48 <irene-knapp> well, okay
07:17:50 <applicative> carpi, make sure to compile, ghci will not parallelize.  you compile with the flag -threaded
07:17:51 <irene-knapp> anyway the other thing is
07:17:58 <irene-knapp> you're talking about explaining WHY it works
07:18:05 <irene-knapp> which is honestly... nice to know, but not that important
07:18:22 <Eduard_Munteanu> http://hackage.haskell.org/package/fft   -- Bindings to the FFTW library.
07:18:33 <carpi> applicative: thanx for the pointers.. i hope it helps me to parallize some of the stuff im doing )
07:18:37 <Eduard_Munteanu> And yeah, it's C, IIRC. And a known-good implementation.
07:18:41 <irene-knapp> HOW it works is also inadequately explained, which is odd given the importance of the algorithm
07:18:48 <irene-knapp> Eduard_Munteanu: yes, certainly.  but but but!  dependencies!
07:19:34 <hpaste> Peaker pasted “Why FFT does DFT” at http://hpaste.org/54569
07:20:01 <Peaker> irene-knapp: the WHY interested me much more :)
07:20:12 <irene-knapp> Peaker: okay, but those of us implementing it... :)
07:20:25 <Peaker> irene-knapp: once you figure out the why, the how becomes easy :)
07:20:36 <irene-knapp> heh
07:20:38 <irene-knapp> noooo it doesn't
07:20:41 <irene-knapp> there are a LOT of details
07:20:44 <Peaker> (though I think the majority of students that learn this stuff only learn the how)
07:20:56 <irene-knapp> I seriously doubt they learn the how, haha
07:21:02 <irene-knapp> I think they learn "this is how to invoke it in matlab"
07:21:27 <irene-knapp> and even with THAT I saw the same FAQs come up repeatedly when I was googling
07:22:03 <irene-knapp> what I was doing was actually Fourier /synthesis/, right
07:22:18 <irene-knapp> generating a spectrogram from whole cloth and doing an inverse discrete transform to produce a waveform
07:22:34 <irene-knapp> I had to figure out the properties the spectrogram has to satisfy entirely on my own
07:22:35 <Peaker> I find my explanation so simple, though :)  Sum of rotating complex = 0.  Multiplication of complex numbers sums up their rotations.  If you multiply a rotating vector with a rotating vector -- it will yield non-zero only if the rotations cancel out.  By multiplying and then summing with various rotation speeds, DFT gives you the non-zero element for the correct speed/frequency
07:22:38 <irene-knapp> nobody EVER explains the mirroring thing
07:22:58 <papa_smurf> OH NO! gargamel attacks the village! i gotta go!
07:23:03 <irene-knapp> Wikipedia alludes to it but doesn't explain that you don't just reflect the numbers, you also take their complex conjugates
07:23:04 <tijn> can somebody direct me to a library or webpage where reading and wrinting to and from files is explained in depth? I find myself creating new specialized functions for different type (such as maps, strings, lists of xyz's etc)
07:23:10 <irene-knapp> haha, okay smurf
07:23:26 <irene-knapp> Peaker: your explanation is simple and elegant but does not help with my problems :)
07:23:52 <Peaker> irene-knapp: your problems seem with higher-level stuff than FFT/DFT :)
07:24:12 <irene-knapp> Peaker: well, mm, but it required full understanding of the DFT
07:24:47 <siasia> hi there
07:25:03 <applicative> tijn, hm, not sure how to answer. there are different 'readFile' functions for e.g. String, ByteString and Text. Often other structures will have String -> Blah functions, etc.
07:25:25 <siasia> is it correct that Functor ((->) e) is just a plain compose?
07:25:41 <shachaf> siasia: fmap = (.) for ((->) e), yes.
07:25:56 <shachaf> siasia: In fact, in lambdabot, (.) is defined to be fmap.
07:26:08 <shachaf> > ((+1) . (*3)) 5
07:26:09 <lambdabot>   16
07:26:13 <shachaf> > (+1) . [1,2,3]
07:26:15 <lambdabot>   [2,3,4]
07:26:26 <siasia> ok then
07:26:41 <siasia> actually I'm reading this http://haskell.org/haskellwiki/Typeclassopedia
07:26:48 <applicative> > fmap even ord $ 'b'
07:26:49 <lambdabot>   True
07:27:27 <applicative> siasia: good work!
07:27:30 <siasia> also there is an exercise 5 for functors asking if a composition of two functors is also a functor
07:28:08 <siasia> and Maybe [a] looks like a functor
07:28:31 <siasia> I don't get what's the reason for this exercise
07:28:40 <shachaf> siasia: Can you prove it using the Functor laws?
07:28:50 <applicative> siasia, yes, to solve the problem you should do a newtype "newtype MaybeList a = MaybeList (Maybe [a]) or else solve it more generally
07:29:01 <shachaf> siasia: The reason for the exercise is to give you a good understanding of how Functors work. :-)
07:29:18 <shachaf> applicative: It'll probably be easier if you do it more generally. :-)
07:29:24 * applicative was thinking the solution resided in defining fmap for the composed functor, or rather type constructor
07:29:25 <FUZxxl> @where Typeclassopedia
07:29:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:29:34 <FUZxxl> @where J
07:29:34 <lambdabot> The J Programming language: http://www.jsoftware.com
07:30:25 <siasia> What does compositon means in this context?
07:30:45 <Peaker> siasia: same as function composition
07:30:52 <mm_freak> siasia: think of functions:  function composition means: f . g
07:31:04 <applicative> siasia, to do the problem inside Haskell you need to introduce a newtype, eg. Comp f g a = Comp (f (g a))
07:31:07 <mm_freak> functor composition means (pseudo-code):  F . G
07:31:10 <shachaf> (f . g) x = f (g x)
07:31:17 <shachaf> (F . G) x = F (G x) :-)
07:31:24 <Peaker> If you treat a functor (e.g: Maybe), like a function, you can compose it with other functors (e.g: [])  and get ComposedFunctor x = Maybe ([] x)
07:31:49 <applicative> siasia: so you write a type definition like Comp or whatever, then define fmap for it, all you get to use is fmap from f and g
07:31:50 <Peaker> With conal's TypeCompose library, the type (:.) means composition, so you actually get  F :. G
07:32:08 <tijn> applicative, I know about readList, etc, but I still have problems because it ghc tells me to add a signature type. If I type: let a = readList "filexyz"           then it works, but when I do that in a do statements it complains
07:32:13 <siasia> uhu, that's what I was thinking about
07:32:15 <applicative> siasia: as Peaker points out this has been done, I think many times in received libs.
07:32:56 <siasia> This exercise is a bit misleading since laws are going after the exercise :)
07:33:12 <siasia> Anyway thanks folks
07:33:18 <applicative> tijn, this is because it can't tell the result type?  the same will arise with read "x", no?  we need to tell it what to read it as
07:33:47 <shachaf> siasia: Oh, well, without the laws it's even easier -- you just need to make it type-check. :-)
07:34:11 <shachaf> siasia: If you have any comments while reading Typeclassopedia, I'm sure byorgey would appreciate them -- he's working on a new version, I hear.
07:34:28 <tijn> applicative, how do I give it the type?
07:34:35 <applicative> siasia, yes, just try writing what I did, and doing 'instance (Functor f, Functor g) => Functor (Comp f g) where fmap f ... = ..
07:35:16 <applicative> tijn, what is the type of 'readList', or is that what the compiler is rejecting?
07:36:08 <applicative> siasia: basically, making a good definition for fmap there is giving the proof
07:36:08 <tijn> the type is [String]
07:36:54 <applicative> tijn, readList looked like a function from a file name to an IO (blah), no?
07:37:45 <tijn> applicative, readList :: Read a => ReadS [a]
07:38:17 <applicative> tijn, hm, there is already a Read instance like that though, are you overruling it?
07:38:42 <shachaf> tijn: Why are you even using readList yourself manually?
07:38:58 <shachaf> Isn't it usually an implementation-detail sort of thing?
07:39:27 <tijn> applicative, no I'm just trying to use the standard functions, because I got stuck trying to create functions myself. I just would like some standard functions for reading and writing lists and maps to and from files
07:40:08 <shachaf> tijn: Turning a list into a string and writing a string to a file are two separate operations.
07:40:13 <shachaf> Are you trying to combine them?
07:40:16 <applicative> tijn, you need function to and from String
07:40:53 <applicative> tijn, or else functions to and from ByteString or whatever
07:43:00 <tijn> but is there no standard funtion that eats a list ad writes it to a file (btw I can do this so that is not the problem) but especially the other way around? Even my function loadList :: (Read a) => FilePath -> IO [a]   doesn't work because ghc states that I have an ambiguous type variable
07:43:21 <applicative> tijn, of course if the type in question has a show instance and a read instane, there is the expedient of using "writeFile "abc" (show x)" and "readFile "abc" (read x)"
07:43:42 <applicative> tijn: that was inept, the second one
07:43:56 <applicative> fmap read (readFile "abc")
07:44:07 <shachaf> tijn: Why would you want a standard function to do that?
07:44:23 <tijn> applicative, I am doing that :-)     Should I then really create another loadList function just for loading a list of string?
07:44:40 <applicative> tijn, the crude standard function is writeFile x . show
07:44:58 <tijn> applicative, because I can't get it to work because of "type ambiguities"...
07:45:01 <applicative> tijn, to write to standard output rather than a file, it's: print
07:45:18 <benmachine> tijn: type ambiguities can be resolved by annotating
07:45:19 <applicative> tijn, does that arise with reading only though?
07:45:29 <tijn> only with reading
07:45:46 <siasia> instance (Functor a, Functor b) => Functor (a b) where
07:45:51 <benmachine> tijn: something like fmap (read :: String -> [Int]) (readFile "myFile.txt")
07:45:55 <siasia> getting back to that
07:46:00 <applicative> @type \file -> fmap read readFile
07:46:02 <lambdabot>     Couldn't match expected type `[Char]'
07:46:02 <lambdabot>            against inferred type `IO String'
07:46:02 <lambdabot>       Expected type: FilePath -> String
07:46:08 <applicative> @type \file -> fmap read (readFile file)
07:46:10 <lambdabot> forall a. (Read a) => FilePath -> IO a
07:46:14 <benmachine> siasia: that's not correct syntax
07:46:19 <applicative> tijn, there ^^^
07:46:19 <shachaf> siasia: You're probably not going to want to write that exact line.
07:46:28 <shachaf> benmachine: Well, it's a kind error, not a syntax error. :-)
07:46:29 <benmachine> siasia: well, it sort of it, but it's a kind mistmatch
07:46:32 <benmachine> yes
07:46:37 <benmachine> exactly what shachaf just said
07:46:48 <siasia> benmachine, do you understand what I'm trying to achieve?
07:46:52 <tijn> applicative, I'll try it and see what happens...
07:47:02 <shachaf> siasia: Do *you* understand what you're trying to achieve? :-)
07:47:22 <applicative> shachaf: solving the problem and understand it will be one thing in this case
07:47:26 <applicative> understanding it
07:47:32 <siasia> shachaf, I am. I want to compose this two functors :)
07:47:36 <benmachine> siasia: I can guess, but look at the signature for fmap
07:47:40 <shachaf> siasia: What does that mean?
07:47:42 <benmachine> fmap :: (a -> b) -> f a -> f b
07:48:00 <benmachine> if we say f = (a b) as you do, we get fmap :: (c -> d) -> a b c -> a b d
07:48:07 <benmachine> can you see why that is not what you want?
07:48:28 <shachaf> "compose" is a word. Is your goal "understand what is commonly meant by the word 'compose'"? Is it "translate this thing, which is my current understanding of the word 'compose', to Haskell"?
07:48:35 <siasia> Is there a possibility to do such abstract class composition?
07:48:36 <shachaf> Those are two completely different things to want to do.
07:49:00 <benmachine> it doesn't make sense to compose classes, but you can compose types
07:49:11 <shachaf> siasia: (a b) has a specific meaning which is distinct from the composition of a and b.
07:49:11 <applicative> siasia, the only class in view here is class Functor f where fmap :: (a -> b) -> f a -> f b
07:49:16 <benmachine> but it takes more effort than just writing them next to each other :)
07:49:17 <shachaf> Names, it's the application of a to b.
07:50:08 <applicative> siasia, you need to define a symbol to represent the composed function, just as you need to define (.)  f g x = f (g x)
07:50:54 <d-snp> is an MVar always wrapped in an IO?
07:50:57 <applicative> siasia: so it should be 'newtype ComposedFunctor f g a= ComposedFunctor (f (g a)) or something fancier with operators and :
07:51:30 <d-snp> I want to do like: MkMyType (newMVar Map.empty)
07:51:37 <shachaf> d-snp: What does that mean?
07:51:51 <d-snp> but it complains it is of type IO(MVar) instead of just MVar
07:52:10 <shachaf> newMVar :: a -> IO (MVar a), yes.
07:52:42 <applicative> that should be coherent, d-snp, you will be wrapping an IO thing inside , why not newMVar (MkMyType (Map.empty)
07:53:56 <d-snp> I don't want the entire state in an mvar
07:54:16 <d-snp> I'll think about it harder :P
07:54:20 * hackagebot xmonad-extras 0.10.1 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.10.1 (DanielSchoepe)
07:54:48 * applicative approves of wacky dependencies
07:55:23 <shachaf> d-snp: Creating an MVar is an IO action. How could it be otherwise?
07:56:51 <applicative> d-snp, I think our friends would need to know more to see what structure might reduce the weight of IO and MVar and so on
07:57:16 <illissius> let's say I installed some packages to a custom prefix... how the heck do I get runghc Setup.hs configure to see them? --extra-lib-dirs=$PREFIX/lib doesn't do it.
07:57:26 <def-lkb> d-snp: maybe you just want to wrap the MVar, using something like "fmap MkMyType . newMVar"
07:58:46 <Saizan> illissius: the custom prefix doesn't matter, the package db does
07:59:00 <Saizan> illissius: maybe you just need --user ? otherwise --package-conf=
07:59:32 <Saizan> --extra-lib-dirs= is for C stuff
08:01:03 <illissius> Saizan: ah, ok. installing the packages --global fixed it, though maybe --user would have as well.
08:01:43 <mm_freak> shachaf: actually creating an MVar doesn't seem to be an impure operation to me
08:02:17 <d-snp> I had something like: data SCTP = MkSCTP { connections :: MVar (Map.Map Word32 Channel) }, but I think it should be { connections :: IO(MVar ..)} then?
08:02:31 <Saizan> d-snp: nope
08:02:57 <d-snp> not? so how do I get the mvar in there without the IO() around it?
08:02:57 <shachaf> mm_freak: What type are you thinking of for newMVar?
08:03:31 <shachaf> d-snp: By first acquiring an MVar somewhere else, and then putting it inside.
08:03:38 <mm_freak> shachaf: MVar a
08:03:41 <tijn> I'll ask again: How do I get variable  x , of type x :: IO String   , read from a file which was written as  [String]  ,   back into my program as [String]?
08:03:42 <mm_freak> well
08:03:44 <mm_freak> a -> MVar a
08:04:35 <applicative> d-snap why not just connections ::  Map.Map Word32 Channel  then when you come to your IO process, you have an MVar SCTP to keep track, or whatever
08:04:36 <monochrom> illissius: you should see my http://www.vex.net/~trebla/haskell/sicp.xhtml for many many facts you should not need to know
08:05:01 <shachaf> mm_freak: And if you write to one of [newMVar 5, newMVar 5], does the other one change?
08:05:06 * shachaf is probably not understanding.
08:05:27 <illissius> monochrom: thanks!
08:05:28 <mm_freak> shachaf: hmm, good point
08:05:36 <applicative> tijn, readStringList :: String -> IO [String]; readStringList file = fmap read (readFile file )
08:05:44 <d-snp> applicative: because SCTP has a bunch of other state too, which I don't all want to access through the same mvar
08:05:53 <Saizan> d-snp: e.g.:  do v <- newMVar (Map.empty); return (MkSCTP v)
08:06:14 <d-snp> oh thanks Saizan
08:06:43 <keep_learning> hello all , I have two folders  'src' and 'test' and i am trying to load a file  from 'test' folder which import file from 'src'.
08:07:02 <keep_learning> but i am getting error from ghci
08:07:27 <applicative> d-snp, this is what def-lkb said above, I mean, same as Saizan
08:07:48 <d-snp> it is? hmm :P
08:08:00 <d-snp> well thanks guys, I don't know why I keep forgetting this kind of syntax :P
08:08:02 <hpaste> keep_learning pasted “error in module loading” at http://hpaste.org/54570
08:08:14 <applicative> d-snp, yeah, def-lkb used fmap instead of bind and return
08:08:18 <d-snp> hm
08:08:26 <applicative> d-snp unless i'm confused which frequently happens
08:09:01 <keep_learning> some one please
08:09:08 <applicative> @type \f x -> do { y <- x ; return (f y)}
08:09:10 <lambdabot> forall (m :: * -> *) t b. (Monad m) => (t -> b) -> m t -> m b
08:09:22 <applicative> @type \f x -> fmap f x
08:09:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:09:36 <Saizan> keep_learning: :set -isrc
08:09:38 <tijn> applicative, thanx, this indeed works, but it is still an IO and how, for example, can I print the list?
08:09:50 <def-lkb> d-snp: the whole point is that creating the MVar is an action, and has to be executed in IO, but after you can use the result in a pure way (well, not accessing its content though)
08:10:05 <keep_learning> Saizan, thank you
08:10:28 <applicative> keep_learning: start ghci in the outer directory test, so it sees Snowfall
08:11:15 <applicative> keep_learning: sorry, that's not it, is there a module named
08:11:46 <applicative> Spatial.hs in the Snowfall directory, named, internally, module Snowfall.Spatial?
08:11:49 <keep_learning> applicative,  Saizan's solution is working
08:11:52 <hpaste> siasia pasted “Functor composition” at http://hpaste.org/54571
08:12:16 <applicative> keep_learning: i see, he answered while I was studying, he's too clever
08:12:21 <keep_learning> applicative, Snowfall.Spatial in src/Snowfall/Spatial.hs
08:12:30 <siasia> do you think this is a correct proof that functor composition is a functor?
08:12:32 <keep_learning> applicative, thank you for time :)
08:12:38 <applicative> yeah,
08:13:54 <Saizan> siasia: you are only showing that the composition of Maybe and [] is a functor, and you still miss a proof of the functor laws
08:14:09 <rwbarton> siasia: you're also missing a case in your code, which is too complicated
08:14:37 <siasia> with an empty list?
08:14:48 <siasia> or an id?
08:15:53 <rwbarton> yes, empty list
08:16:00 <applicative> tijn, newReversedFile :: FilePath -> FilePath -> IO () ; newReversedFile file1 file2 = readStringList file2 >>= writeFile file2 . show . reverse
08:17:17 <siasia> rwbarton, oops, looks like I was relying on fmap to solve this prob for me
08:17:50 <rwbarton> siasia: and in fact, you should have been relying on fmap to solve all of your problems!
08:17:56 <applicative> siasia, you would have to rely on fmap for the more general case, but not in this one
08:19:02 <siasia> fmap (fmap (*2)) $ Just [1,2,3]
08:19:18 <applicative> >  fmap (fmap (*2)) $ Just [1,2,3]
08:19:19 <siasia> is it what I should do in general case?
08:19:19 <lambdabot>   Just [2,4,6]
08:19:44 <rwbarton> ("Should" as in it will make your code simpler and more obviously correct, it is not necessary for correctness of course)
08:19:46 <applicative> siasia: you have the main idea now....
08:20:06 <siasia> instance Functor Comp where
08:20:06 <siasia>     fmap g (Comp a) = Comp $ fmap (fmap g) a
08:20:42 <tensorpudding> > fmap (*2) <$> Just [1,2,3]
08:20:43 <lambdabot>   Just [2,4,6]
08:21:20 <rwbarton> siasia: yes
08:21:28 <tensorpudding> we need ffmap
08:21:37 <tensorpudding> or is it fmmap?
08:21:44 <applicative> siasia, thats now you need to prove the rule about fmap id and about fmap (f.g)
08:22:44 <opqdonut> tensorpudding: what would the type be?
08:23:17 <opqdonut> (Functor f, Functor g) => (a->b) -> f (g a) -> f (g b) ?
08:23:44 <tensorpudding> yes
08:24:17 <tijn> applicative, I really appreciate what you' doing for me, but I still don't get it. How do I get the first element out of the list that I saved, for example?
08:24:41 <mellum_> Is there something like (.), but swapped like g (f x)?
08:24:52 <opqdonut> flip (.)
08:24:57 <opqdonut> aka (>>>)
08:24:59 <applicative> tijn: fmap head (readStringListFile x)  to put it crudely
08:25:02 <opqdonut> :t (>>>)
08:25:03 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:25:12 <opqdonut> (that's a tad generic, I know, but it works)
08:25:20 <mellum_> okay, thanks
08:25:25 <opqdonut> > (+1) >>> (*3) $ 1
08:25:26 <lambdabot>   6
08:26:22 <applicative> tijn: or equivalently, firstItemFile x = do {wholelist<-  readStringListFile x; return (head wholelist)} or whatever
08:27:30 <applicative> tijn:  there is an overabundance of ways of writing this sort of thing e.g. head <$> (readStringListFile x) etc.
08:29:22 <applicative> tijn, if you are storing a list of items in a file, the really simple ordinary thing to do is writeFile x (unlines (map show xs) and readFile x >>= return . map read . lines
08:29:31 <applicative> tijn: or something like that
08:30:39 <applicative> tijn,, but the way you have it now, the file when you look at it will have the haskell name of a haskell value with square brackets and commas
08:35:48 <tijn> applicative, I still can't read a list of items and do something...
08:37:26 <applicative> tijn is it a type error?
08:38:29 <rwbarton> isn't there a standard introduction to IO to point people to?
08:39:00 <applicative> rwbarton: i think there is an overabundance of them
08:39:42 <tijn> applicative, it is an 'ambiguous type variable a0 in the constraint: (Read a0)
08:40:13 <applicative> tijn, exactly, it doesn't know what the list you stored is a list of
08:41:27 <applicative> if you want to read it as a [Int] you need to tell it.similarly if you want to read it as a [Integer], not that these will "look" the same
08:41:43 <applicative> note that these will look the same, rather
08:43:57 <Cale> rwbarton: there's my little intro :)
08:44:05 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:44:46 <tijn> applicative, in ghci I can do: let a  =  loadList "q.txt" :: IO String
08:45:22 <applicative> tijn, right now do:  b <- a
08:46:02 <applicative> tijn, which is equivalent to just doing: b <- loadList "q.txt"
08:46:31 <applicative> tijn, then do:  b
08:47:25 <tijn> that almost works (no complaints) except that b is empty although the file exist with the text: "[\"qqq\"]"
08:47:42 <rwbarton> what's loadList?
08:47:50 <applicative> tijn this must be a problem with loadList
08:49:35 <tijn> applicative,     loadList f = do x <- readFile f ; return (read x)
08:49:53 <tijn> loadList :: (Read a) => FilePath -> IO [a]
08:51:07 <rwbarton> The file has those outer double quotes in it?
08:51:18 <rwbarton> so it's 11 bytes total, plus maybe a newline?
08:51:52 <tijn> rwbarton, is that a problem? I saved it with : save x f = writeFile f (show x)
08:52:05 <rwbarton> no that's good
08:52:34 <Saizan> unless you did something like save (show ["qqq"]) "q.txt"
08:53:55 <rwbarton> anyways, b shouldn't be empty then, you should get an exception instead...
08:54:07 <Cale> Are you sure that you don't get  "*** Exception: Prelude.read: no parse
08:54:41 <rwbarton> @where IO
08:54:42 <lambdabot> Raphael Finkel's language with continuations as fundamental structure, described in chapter 2 of his book `APLD', implementation `Amalthea'
08:54:58 <rwbarton> @where introduction
08:54:58 <lambdabot> I know nothing about introduction.
08:55:19 <tijn> Saizan, that's what I did and now my problem is solved! applicative, rwbartonand Saizan ::  thnx a lot for helping me out!  Have a nice Sunday! :-)
08:56:14 <applicative> tijn, oh good.
08:58:08 <EarlGray> ей, маковод
08:58:27 <EarlGray> sorry, wrong tab
09:01:05 <Saizan> tijn: cheers :)
09:05:17 <d-snp> Making stuff work. Getting it done!
09:18:11 <ddarius> co_dh: A T-algebra is an F-algebra that has to satisfy certain laws.  For Maybe, those laws imply that every Maybe T-algebra is of the form fromMaybe x.
09:23:09 * illissius observes that with superclass equality constraints, you can convert from TF-using classes to FD-ish ones: class (MonadStateTF m, s ~ StateType m) => MonadStateFDish s m; instance (MonadStateTF m, s ~ StateType m) => MonadStateFDish s m
09:28:58 <Eelis> how do i get a collection of objects indexed by two different (ordered) attributes (so that i can do logarithmic operations using either key)? in C++ i'd do this with Boost.MultiIndex. what's the Haskell way to do it?
09:31:58 <monochrom> two maps
09:32:27 <Eelis> hmm
09:32:29 <ddarius> @hackage ixset
09:32:29 <lambdabot> http://hackage.haskell.org/package/ixset
09:32:39 <Eelis> ah, very nice!
09:32:41 <Eelis> thanks ddarius
09:35:15 <rostayob> Eelis: ixset works by re-creating indexes when going one level down
09:35:40 <mellum_> Can I somehow count the number of times a function is called? Without having to pass around a variable for that in all calling places
09:35:52 <leino> I am having some trouble doing 'ghci -package wx'... when loading wxcore, I get errors that libstdc++.so is not found
09:36:01 <rostayob> mellum_: increment an IORef in the function? but that would force you to make it IO
09:36:24 <rostayob> (or unsafePerformIO, if you're debugging)
09:37:04 <mellum_> rostayob: what are the downsides of making it IO?
09:37:28 <rostayob> mellum_: the type will be IO something, then you won't be able to use the function in pure code
09:37:41 <rostayob> mellum_: do you know how IO works in haskell?
09:38:06 <mellum_> rostayob: only roughly
09:38:37 <alex404> So I'm trying to use StreamArrows in a program I'm writing, but I'm confused about a certain type signature. The signature of runStream is: runStream :: ArrowLoop a => StreamArrow a (e,b) c -> a (e,Stream b) (Stream c)
09:38:39 <rostayob> mellum_: well you might want to read up on it and then look at IO references (IORef)
09:38:44 <alex404> My question is, what is the e doing there?
09:38:51 <mellum_> rostayob: okay, thanks
09:38:55 <alex404> Why can't I just run the stream on an actual stream
09:39:06 <alex404> as opposed to some pair
09:40:15 <hpaste> aavogt pasted “stack overflow using this num instance” at http://hpaste.org/54574
09:40:48 <aavogt> when I change some other code using this instance to just use Double, there are no problems
09:42:43 <rostayob> aavogt: i haven't even read your code, but the problem might be that if you have polymorphic values you might be calculating them multiple times, while with a monomorphic types it'll be calculated once
09:44:39 <ddarius> alex404: That's probably some kind of optional environment.  For a = (->) it's unnecessary (if I'm guessing right) but for other arrows it may be desirable.  You can just have it be () if you don't need it.
09:44:46 <rostayob> aavogt: so if you have foo :: Num a => a, that value gets desugared in a function that computes the value each time based on the type inferred
09:44:55 * aavogt doesn't see how that leads to stack overflows
09:45:15 <rostayob> aavogt: well, you're doing more computation
09:45:20 <Saizan> aavogt: M.singleton isn't strict in its first argument, for example
09:45:30 <alex404> ddarius: Right. That makes sense. cheers.
09:45:39 <aavogt> my current guess is that my + - etc are not strict enough
09:46:52 <rostayob> aavogt: anyway that's just a random thought when you said that it worked with Double only :P
09:47:12 <Saizan> aavogt: s/foldl/foldl'/ in lnvnn probably would help
09:47:37 <Saizan> @wiki StackOverflow
09:47:38 <lambdabot> http://www.haskell.org/haskellwiki/StackOverflow
09:48:33 <dmos> cabal-dev ghci question: was anyone able to get a ghci running which has test-suite dependencies in scope?
09:51:06 <ddarius> I suspect unionsWith and unionWithKey are also less than ideal, though that isn't your fault.
09:51:56 <ddarius> > M.unionsWith (+) $ replicate 10000 [M.singleton 1]
09:51:56 <lambdabot>   Couldn't match expected type `Data.Map.Map k a'
09:51:57 <lambdabot>         against inferred ty...
09:52:04 <ddarius> :t M.unionsWith
09:52:05 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [M.Map k a] -> M.Map k a
09:52:24 <ddarius> :t M.singleton
09:52:25 <lambdabot> forall k a. k -> a -> M.Map k a
09:52:33 <ddarius> > M.unionsWith (+) $ replicate 10000 [M.singleton 'a' 1]
09:52:34 <lambdabot>   Couldn't match expected type `Data.Map.Map k a'
09:52:35 <lambdabot>         against inferred ty...
09:53:06 <carpi> could someone please explain to me what is happening with this line over here .. "parFib n | n < cutoff = fib". I saw it in some sample code on SO and I've never seen such pattern matching in haskell before..
09:53:23 <mux> > M.unionsWith (+) $ replicate 10000 (M.singleton 'a' 1)
09:53:24 <lambdabot>   fromList [('a',10000)]
09:53:37 <ddarius> carpi: Read an introduction to Haskell and you will see such things and many others.
09:53:45 <ddarius> > M.unionsWith (+) $ replicate 100000 (M.singleton 'a' 1)
09:53:46 <lambdabot>   fromList [('a',100000)]
09:54:02 <ddarius> > M.unionsWith (+) $ replicate 1000000 (M.singleton 'a' 1)
09:54:04 <lambdabot>   fromList [('a',*Exception: stack overflow
09:54:14 <ddarius> Just need enough mojo.
09:55:34 <byorgey> carpi: it is called a 'guard'.  It means 'if n < cutoff then parFib n evaluates to fib.'
09:55:50 <_Mikey> yess
09:56:03 <aavogt> > foldr (M.insertWith (+)) M.empty $ replicate 1000000 (M.singleton 'a' 1)
09:56:03 <lambdabot>   Occurs check: cannot construct the infinite type:
09:56:04 <lambdabot>    b = Data.Map.Map a b -...
09:56:16 <aavogt> > foldr (flip $ M.insertWith (+)) M.empty $ replicate 1000000 (M.singleton 'a' 1)
09:56:17 <lambdabot>   Occurs check: cannot construct the infinite type:
09:56:17 <lambdabot>    k = Data.Map.Map k a -...
09:56:43 <carpi> byorgey: I understand its a guard.. but i saw that piece of code in the same line along with the definition of the function. I always thought guards are supposed to be on a seperate line?
09:57:02 <byorgey> carpi: they often are, but that's just a stylistic choice
09:57:03 <aavogt> > foldr (uncurry $ M.insertWith (+)) M.empty $ replicate 1000000 (M.singleton 'a' 1)
09:57:04 <lambdabot>   Couldn't match expected type `(a, b)'
09:57:04 <lambdabot>         against inferred type `Data.M...
09:57:16 <_Mikey> aren't the |'s in list comprehensions basically guards
09:57:16 <deggis> dmos: i'm not sure if this solves your current problem right away, but i've had struggles with cabal-dev before knowing that you can use regular ghci like 'ghci -package-conf ./cabal-dev/packages....conf'
09:57:29 * ddarius rarely starts guards on a separate line.
09:57:34 <aavogt> > foldr (uncurry $ M.insertWith (+)) M.empty $ replicate 1000000 ('a', 1)
09:57:36 <lambdabot>   fromList *Exception: stack overflow
09:57:36 <ddarius> _Mikey: No.
09:57:51 <_Mikey> ahh snap
09:57:54 <byorgey> _Mikey: not really, although list comprehensions may include guards
09:57:59 <dmos> deggis: I think that's exactly what I was looking for. Will try. Thanks
09:59:07 <carpi> byorgey: thanks for the clarification.  )
10:01:31 <deggis> dmos & cabal-dev users: great :) that way it's possible to pass --extra-lib-dirs= -flags to ghci. with cabal-dev i wasn't able to use ghci in many projects, which wasn't nice
10:02:32 <dmos> deggis: but what the -package-conf doesn't solve is automatically loading the packages, no?
10:04:44 <ddarius> @google Common patterns for metric and ordered fixed point theorems
10:04:46 <lambdabot> http://tcs.uj.edu.pl/~pqw/waszkificsfinal.pdf
10:04:46 <lambdabot> Title: Common patterns for metric and ordered fixed point theorems
10:04:49 <deggis> uhh, i think i misread you question. i don't think that does that. is it possible to write your imports to a module and load that?
10:06:47 <hpaste> aavogt annotated “stack overflow using this num instance” with “stack overflow using this num instance (annotation)” at http://hpaste.org/54574#a54575
10:07:11 <aavogt> Saizan, ddarius here's everything. I think I followed your suggestions but the problem still exists
10:08:27 <ddarius> aavogt: That doesn't fix the problem.  unionsWith is already defined with (essentially) foldl'.  The problem is that unionsWith doesn't force the -elements- of the map so you get a map with thunks.
10:08:53 <ddarius> I'm pretty sure the same holds for unionWithKey
10:10:06 <ddarius> There should be a unionsWith' and co. but there isn't.
10:10:07 <dmos> deggis: Hmm, not sure yet. But it seems to work, although ghci now loads the packages lazy (as ghci in it's original configuration does). I guess that's workable.
10:10:52 <dmos> deggis: I will have to experiment a bit more to figure out whether it's sufficiently integrated now for easy development, but the -package-conf flag seems to have been the missing piece.
10:10:56 <benmachine> I think there are some proposals to provide a stricter Data.Map interface
10:11:36 <Eelis> hm, suppose i have  s :: Set a  and  x :: a, and i want to find the smallest element in s bigger than x (if one exists). how would i do that? in C++ i can use set<a>::lower_bound but i can't find an equivalent function for Data.Set
10:12:01 <mrakan> What's the most efficient way to reach middle element of a list, using a recursive function that traverses the list only once?
10:12:34 <benmachine> Eelis: findMin doesn't do what you want?
10:12:41 <mrakan> (So, we don't know the list length ahead of time. We get a list and must determine its middle element.)
10:12:44 <benmachine> oh wait
10:12:46 <benmachine> hm
10:12:51 <mrakan> The list is also sorted.
10:12:53 <ddarius> mrakan: You can run two pointers and stop when the faster one reaches the end of the list, but this seems silly.
10:12:58 <Eelis> benmachine: findMin just finds the minimal element. it doesn't take a bound argument
10:13:11 <benmachine> Eelis: yeah, I see what you mean now
10:13:16 <ddarius> mrakan: The list being sorted is irrelevant unless you what something like the average value.
10:13:28 <benmachine> Eelis: 'split'>
10:13:29 <benmachine> er
10:13:31 <benmachine> Eelis: 'split'?
10:13:32 <deggis> dmos: okay. hopefully you find usable setup
10:13:46 <mrakan> ddarius: The function itself actually returns the median of a list, but yes, for my question it's irrelevant, you're right.
10:14:10 <benmachine> probably splitMember
10:14:16 <Eelis> benmachine: ah, that looks good, if possibly not as efficient (because it means i then have to do findMin on snd of the result)
10:14:26 <mrakan> ddarius: Actually, the pointers might be a good bet? Thanks for the thought.
10:14:27 <benmachine> Eelis: why would that be inefficient?
10:14:37 <Eelis> benmachine: because it means another tree traversal
10:14:42 <benmachine> oh, I guess so
10:14:45 <aavogt> ddarius: is there a way to write this unionsWith'?
10:14:48 <benmachine> the tree isn't going to be that deep though
10:15:02 <Eelis> benmachine: still, doing it once instead of twice would be nicer :)
10:15:06 <benmachine> true
10:15:23 <benmachine> sometimes I think it would be nice if containers exposed internals
10:15:46 <ddarius> Probably not an efficient way.  You can always force the elements after each unionWith but that will be painful if the Map is large.  If the Map is small, then that's probably fine enough.
10:16:05 <Eelis> maybe i can try to implement lower_bound (and upper_bound) natively and run a benchmark to see if it makes any difference with split&findMin.
10:16:13 <aavogt> forcing something like  M.fold seq () m?
10:16:29 <ddarius> You could also flatten the others and use insertWith' which I think exists.
10:16:49 <ddarius> aavogt: Something like that.
10:17:08 <Eelis> i'm surprised findMin is logarithmic though. in C++, set<T>::begin is constant
10:18:35 <aavogt> hmm, maybe seq isn't enough to force enough of the data NV though
10:19:04 <aavogt> oops, that's not what's in those maps
10:20:38 <Botje> Eelis: "the header cell is maintained with links not only to the root but also to the leftmost node of the tree, to enable constant time begin()"
10:20:46 <Botje> (from bits/stl_tree.h) :)
10:21:39 <Eelis> Botje: oh, you misunderstood. i'm not surprised that set<T>::begin is constant. i'm surprised findMin isn't
10:22:28 <Botje> maybe they want to avoid sharing issues?
10:22:50 <Eelis> dunno :)
10:23:03 <Botje> i can't remember the last time I did set.findMin() though :P
10:23:25 <Eelis> no findMin is a Haskell function
10:23:27 <Eelis> Data.Set.findMin
10:23:41 <Botje> yes, that's what i meant
10:23:45 <Eelis> oh ok :)
10:23:50 <Botje> in haskell or in another languge
10:23:52 <Botje> *language
10:24:59 <ddarius> Eelis: Doing so would slow every operation down and if you want a priority queue there are better data types to use.
10:25:29 <Eelis> ddarius: hm, is the former a Haskell issue? or are you saying that it's the same in C++'s std::set?
10:26:57 <Eelis> and no, i don't want a priority queue :)
10:27:00 <ddarius> Eelis: It's aggravated by purity and persistence, but I'm pretty sure it's also true in C++, just to such a minor extent that it is still worthwhile to do.
10:27:10 <Eelis> that's quite a claim
10:27:19 * benmachine wonders if a Set zipper would be interesting here
10:28:03 <Eelis> benmachine: yeah, the more i think about it, the more i think something like that would be very useful
10:30:21 <ddarius> Eelis: I don't see how that is "quite a claim."  It can't take more time for C++ to do less.
10:31:10 <Eelis> ddarius: it's quite a claim to say that every operation on std::set is slowed down just to facilitate constant time begin().
10:31:55 <bd_> it's easier in C++ because C++ can easily support backpointers to parent nodes (and mutate to update the in place)
10:31:58 <ddarius> I didn't say that.  I said every operation (though it would be only almost every operation) would be slowed down for Data.Set.
10:32:13 <Eelis> ddarius: yes, and then i asked if the same would be true for std::set, and you said it would
10:32:19 <bd_> just having a pointer to the first node in haskell isn't very useful, since you'd need to traverse the tree to actually mutate that or delete it
10:33:45 <benmachine> Eelis: certainly at least std::set spends some memory making that fast
10:34:05 <ddarius> Eelis: That said, again, it's not much of a claim to say that doing more takes more time to do more.  It has to maintain that pointer.  When you insert, it has to make sure that you aren't inserting the new minimum and if you are it has to update that pointer, unless it's just a cell that gets overwritten in place and the min node is always the same.
10:34:30 <Eelis> benmachine: sure, /some/ operations will be slower, and indeed, there is likely memory overhead. but that's quite a long shot from saying std::set as a whole is slowed down
10:35:19 <Eelis> ddarius: simple key lookup, arguably the most important operation on sets, is in all likelihood completely unaffected.
10:35:25 <ddarius> Probably, yes.
10:40:55 <Eelis> basically, what i need to do is: find the first key in the set that is greater than some given key, and then do some local erases and inserts around that position. in C++ this is very easy because lower_bound gives me an iterator which makes it very easy to do efficient erasures/inserts around the position denoted by that iterator
10:41:08 <Eelis> but Data.Set has no notion of iterators
10:41:40 <Eelis> so yeah, i need to look into Set zippers
10:42:19 <benmachine> Eelis: you could just do it and only worry about iterators if you notice performance problems
10:42:30 <Eelis> i already am :)
10:42:41 <benmachine> okay fair enough
10:45:20 <ddarius> Eelis: It might make sense to think about this in a more global way.
11:12:08 <e98> been trying time and time again and wondering how haskell-mode users indent their code
11:12:33 <e98> tried to turn of all indenting and fall back to manual, but that also didn't work
11:13:03 <e98> it seems haskell is hard to indent with elisp regex matching, and there are attempts to use haskell for that
11:15:26 <e98> for the moment I will resort to using vim for .hs as it has no indenter at all. I can't be the only one wanting to use emacs for .hs
11:16:23 <cgroza> e98: What problem do you have with emacs?
11:16:26 <e98> chris' haskell-emacs is unfinished and the nested-move functions don't seem to be available even though the hs-move-nested.el is (require)'ed
11:17:15 <e98> cgroza: all 3 indenters fail to not indent where it's not supposed to and mis-indent
11:17:28 <e98> cgroza: failed to disable indenters with a custom hook
11:17:31 <cgroza> e98: weird. I have no problems.
11:17:57 <cgroza> e98: it happens when you ident many lines at once?
11:18:33 <dmos> interruptible stream computations: Are there any other libraries besides the three iteratee implementations and the monad-coroutine I should look at? Any must see papers or other resources?
11:18:41 <e98> cgroza: also, yes, but even the case where I finished a function definition and create a blank line it indents with 8 or more spaces
11:19:16 <e98> cgroza: I hopped here to resolve the issues thinking there must be haskell-mode users
11:19:46 <e98> cgroza: which indenter have you enabled?
11:19:52 <cgroza> e98: I have those problems too.
11:20:12 <cgroza> e98: I don't know. Never looked closer at haskell-mode. Just added the hook
11:20:39 <e98> cgroza: which one?
11:21:33 <cgroza> e98: I think it's `haskell-indentation.el'.
11:21:51 <lukish> (***) arrow use one function to tuple. Is there 2 function analog&
11:21:52 <lukish> ?
11:22:24 <dagolitos> same dissatisfaction with indenting with emacs here (haven't searched very far though)
11:23:13 <e98> cgroza: have you disabled indenters or are you using one? confused
11:24:55 <dmwit> lukish: (***) takes two functions, and applies them to the two parts of a tuple.
11:24:55 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
11:25:14 <dmwit> lukish: (&&&) takes one function, and applies each of them to a single value, returning the tuple of results.
11:25:17 <dmwit> ?messages
11:25:17 <lambdabot> dschoepe asked 20h 56m 8s ago: It seems that the Eval stuff in xmonad-extras works with the new hint. Should I upload 0.10.1 that re-enables with_hint for newer GHCs?
11:25:47 <dmwit> lukish: (What is the type of the function you want?)
11:25:52 <ddarius> They both take two functions, hence being binary operators (?)
11:26:05 <dschoepe> dmwit: As you can see, I didn't bother to wait for your answer :)
11:26:12 <dmwit> Yeah, I'm not sure I understand the question.
11:26:14 <dmwit> dschoepe: yep =)
11:26:25 <dmwit> dschoepe: (I'll double-check it anyway, I'm installing 7.2 later for unrelated reasons.)
11:27:28 <dmwit> s/(&&&) takes one function/(&&&) takes two functions and one value/
11:27:34 <dmwit> ddarius: Thanks.
11:31:37 <hpc> dmwit: or more theoretically usefully, takes two functions and produces a function
11:31:49 <hpc> s/function/arrow/ if you eat fancy cheese
11:31:51 <hpc> :P
11:33:08 <ddarius> Fancy cheese is nice.
11:41:58 <aristid> true.
11:45:50 <leino> hello people. I have a question about ghci and loading packages.
11:46:34 <dmwit> Hello leino. I have an anwser about ghci and loading packages.
11:46:55 <leino> when I run 'ghci -package wx' I get an error from one of the packages (wxcore), it says it cannot find libstdc++.so
11:47:08 <leino> sorry I was thinking too long about how to formulate it
11:47:22 <alistra> leino: distro?
11:47:31 <leino> debian wheezy (testing)
11:47:34 <saati> leino: install libstdc++
11:47:38 <leino> I did
11:47:38 <Botje> -dev
11:47:43 <leino> yep
11:47:49 <leino> I can run c++ apps fine
11:47:58 <alistra> locate libstdc++
11:48:06 <leino> yes, I have it in 4 different places
11:48:08 <alistra> it's not run, it's compile with standard lib
11:48:13 <Botje> leino: have you tried running ldconfig?
11:48:13 <leino> the problem is on the haskell end I think
11:48:16 <Botje> that occasionally works.
11:48:17 <leino> wxcore is a cabal package
11:48:40 <leino> Botje: you mean just running 'ldconfig' without arguments? if so then yes
11:48:41 <lukish> How could this be rewrited?
11:48:42 <lukish> (\x -> (x, toRoman . fromRoman $ x))
11:48:50 <lukish> With arrows
11:48:54 <Botje> @pl (\x -> (x, toRoman . fromRoman $ x))
11:48:54 <lambdabot> ap (,) (toRoman . fromRoman)
11:49:08 <dmwit> lukish: id &&& (toRoman . fromRoman)
11:49:43 <leino> I mostly want some details on what is happening when ghci loads  wxcore
11:50:00 <leino> I tried 'ghci -package wx -v' (v for verbose)
11:50:00 <lukish> Great!
11:50:07 <lukish> dmwit: thanx
11:50:07 <alistra> @type toRoman
11:50:08 <lambdabot> Not in scope: `toRoman'
11:50:11 <Botje> leino: can you run ldd on the wxcore library?
11:50:28 <leino> I only found .a and .o files
11:50:49 <leino> I mean, in my ~/.cabal/...
11:51:05 <leino> and when I ran ldd on these it protested
11:52:16 <leino> ./.cabal/lib/wxcore-0.12.1.7/ghc-7.0.4/HSwxcore-0.12.1.7.o
11:52:22 <leino> is what I tried on, for instance
11:53:37 <leino> doing ldd on the above file yields "not a dynamic executable"
11:55:29 <Botje> i'm compiling wx here too
11:55:33 <Botje> let's see if it works here
11:55:45 <leino> ok
11:55:56 <leino> Botje: do you have debian?
11:56:22 <Botje> leino: I run ubuntu 11.10
11:56:26 <leino> http://haskell.org/haskellwiki/WxHaskell/Building
11:56:29 <Botje> and I get the exact same error as you :]
11:56:45 <leino> darn
11:57:04 <leino> and you have libstdc++.so, of course?
11:57:27 <Botje> not in a ldconfig-friendly place
11:57:33 <leino> same here
11:58:00 <leino> meaning it doesnt get included in my /etc/ld.so.conf
11:58:22 <Botje> well, normally you compile with g++, which (I guess) looks there by default
11:59:28 <leino> I asked over at #debian as well, but it seems cabal-specific
12:00:26 <leino> I still don't understand how to troubleshoot dynamic library stuff, even after having solved a number of problems like this
12:03:49 <Luke> anyone know how to encode an Int to Text type?
12:03:57 <dmwit> :t show
12:03:58 <lambdabot> forall a. (Show a) => a -> String
12:05:05 <ion> :t Data.Text.pack . show
12:05:06 <lambdabot> forall a. (Show a) => a -> Data.Text.Internal.Text
12:05:07 <Botje> leino: strangely enough, ghc --make works fine.
12:05:12 <Botje> leino: have you tried that instead of ghci?
12:05:31 <leino> Botje: added a line to /etc/ld.conf.so and ran ldconfig: it works!
12:05:46 <leino> meaning I get a different error
12:06:04 <Botje> heh. :)
12:06:16 <leino> unknown symbol `__dso_handle'
12:06:24 <leino> ...to be more precise
12:06:28 <Luke> ion: thanks
12:06:29 <Botje> I would use ghc --make, if that works
12:07:16 <Botje> no clue, sorry.
12:07:41 <leino> ghc --make works
12:07:48 <ion> :t Data.Text.singleton . Data.Char.chr
12:07:49 <lambdabot> Int -> Data.Text.Internal.Text
12:08:43 <leino> Botje: runhaskell hello.hs fails with the same error message
12:13:42 <tijn> is there a strict version of readFile, so that the handle is being closed with 100% certainty and the file is read in total?
12:13:52 <Botje> leino: runhaskell is just ghci with bells on :)
12:14:06 <Botje> tijn: you could use strict bytestrings.
12:14:12 <tijn> I have problems :openFile: resource busy (file is locked)
12:14:30 <dmwit> ?hackage strict tijn: Check out System.IO.Strict.readFile.
12:14:31 <lambdabot> http://hackage.haskell.org/package/strict tijn: Check out System.IO.Strict.readFile.
12:14:37 <tijn> Botje, I would like to inspect my files and I took kind of great pain to keep them readable
12:14:38 <monochrom> on hackage there is a strict i/o lib for strict readFile
12:14:55 <tijn> thnx! I will look at it
12:15:11 <Botje> tijn: [Char] kind of sucks if you want to slurp in big files.
12:15:38 <monochrom> actually the strict bytestring lib also provides strict readFile. more memory-efficient
12:16:01 <Botje> yes
12:17:05 <tijn> Botje, yes, but while building I want to manually inspect files, then I'll go optimize it for speed
12:17:39 <Botje> tijn: bytestrings are just a more compact representation of your files
12:18:18 <Botje> you don't change the files themselves, just the way haskell stores them in memory
12:18:49 <Sebasti0n> Hey there, anybody here who has experience in writing xml picklers for hxt? I can't figure out how to write a pickler for a data type with multiple constructors as it has no input parameter to I can't do any pattern matching. The type signature for a pickler is: xpickle :: (XmlPickler a) => PU a
12:19:33 <dmwit> Sebasti0n: Check what classes PU implements. MonadReader is probably one of them.
12:19:38 <dmwit> :t asks
12:19:40 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
12:20:11 <Botje> Sebasti0n: this PU thing contains three functions
12:20:25 <Botje> among which a pickleTree :: a -> t
12:20:55 <monochrom> appPickle :: (a, St) -> St  there is your input parameter (a, St)
12:22:06 <Sebasti0n> cool, thanks
12:23:26 <monochrom> twinkle twinkle little star, pickle pickle ex em el
12:23:54 <alex404> So I've got some compiled libraries that I'm trying to test with a script that I load into ghci. When I run the method, I eventually get this: Loading package bayes-0.4 ... linking ... <interactive>: /usr/local/lib/bayes-0.4/ghc-7.0.4/HSbayes-0.4.o: unknown symbol `__stginit_bayeszm0zi4_BayesziUtil_'
12:24:06 <alex404> Anyone know what that's about?
12:24:17 <Clint> symbol resolution
12:24:57 <ddarius> monochrom: Never have children.
12:26:07 <vhd> Hi, I had some code I wrote using Leksah IDE which worked with GHCi, tried the same code today and it is throwing errors (same pc, same setup).
12:26:15 <vhd> says False and Nothing are out of scope
12:26:21 <vhd> any ideas where I went wrong?
12:27:21 <statusfailed> Anybody know of a good tutorial on Enumerator IO?
12:27:26 <statusfailed> Iteratee IO*
12:27:43 <luite> alex404: add the Bayes.Util module to exposed-modules or other-modules
12:27:46 <statusfailed> I mean for the Data.Enumerator package though
12:28:12 <alex404> luite: Oops. Cheers.
12:28:59 <monochrom> http://www.yesodweb.com/blog/2010/09/enumerators-tutorial-part-1 seems to be the enumerator tutorial
12:29:25 <dmwit> vhd: Sounds like you accidentally enabled NoImplicitPrelude or some such thing.
12:29:25 <monochrom> or like that page says, go straight to the yesod book :)
12:29:33 <dmwit> vhd: Or perhaps started importing the Prelude qualified.
12:29:50 <leino> Botje: ok so you can make the first error go away as I said above, the next error appears less easy to solve: http://haskell.1045720.n5.nabble.com/Unknown-symbol-dso-handle-with-Template-Haskell-and-wxHaskell-td3318375.html .  I will give up now, since 'ghc --make' works. Thanks for your help!
12:30:29 <vhd> dmwit: how would I reset it?
12:30:37 <dmwit> vhd: How did you set it?
12:30:53 <dmwit> <- only a Haskell "expert", not a Leksah expert
12:31:01 <vhd> I dont remember fiddling with anything other than writing code + use ghci
12:31:07 <jhussein> I have been trying to do something really simple with happstack / acid-state for over 5 hours but I just cant get it, can somebody walk me through an uber simple example of getting a post oout of the database?
12:31:15 <vhd> :/ but I will fiddle now
12:31:18 <dmwit> vhd: Well, paste a complete file to hpaste.org that exhibits the problem.
12:31:25 <statusfailed> monochrom: oh, so it is
12:31:26 <statusfailed> cheers
12:31:36 <dmwit> vhd: And show the exact ghci incantation that we should try to see the same problem.
12:31:42 <jhussein> I tried to use -> https://github.com/aslatter/blog - however its using an older version of acid-stae
12:31:58 <dmwit> vhd: Also, be sure to check ~/.ghci if it exists.
12:32:40 <monochrom> you need a filesystem that records its full history
12:33:13 <vhd> dmwit: ok, I fixed it. I had changed the code after all, but I dont know why it complained about False and Nothing.
12:33:20 <vhd> Seems to be ok now.
12:33:53 <dmwit> monochrom: Some kind of system that tracks versioning and lets us look back at what we'd done in the past?
12:34:11 <dmwit> Writing that could sounds like it could get impossibly darc and murky.
12:35:12 <hydo> you'd be a complete git to start something like that without a set plan.
12:35:25 <monochrom> filesystem changes are boringly linear. darcs is overkill. think RCS or even RCS's predecessor. in fact, think VMS
12:35:28 <dmwit> Yes, it would be a truly subversive project.
12:35:57 <Eduard_Munteanu> Wasn't there a FUSE-based gitfs?
12:36:21 <hydo> And remember not to think that adding more programmers will increase the ... force... per .... programmer.  DAMNIT... I guess I'm done.
12:36:35 <Eduard_Munteanu> Also, btrfs is a tiny bit like version control, if snapshots count for anything.
12:36:35 <dmwit> =P
12:36:47 <monochrom> I don't understand why all of you are thinking darcs git mercurial subversion. for christ's sake, there is no branching.
12:36:59 <hydo> brtfs sounds nice - what little I know about it.
12:37:15 <dmwit> If there's a system that can handle even branching, why not use it, even when there's no branching?
12:37:43 <monochrom> because like you said "impossibly darc and murky"
12:37:44 <hydo> Eduard_Munteanu: Yes, there was. I remember playing with it a while back.
12:37:45 <Eduard_Munteanu> monochrom: there are no patches/commits, but there are branches if you squint hard enough at copy on write snapshots.
12:38:02 <hydo> heh
12:38:08 <dmwit> Using darcs/git/mercurial/svn/etc. is quite simple when there's no branching involved.
12:38:36 <monochrom> well then explain why you said "impossibly darc and murky"
12:38:42 <dmwit> To make a pun.
12:38:44 <hpaste> Sebasti0n pasted “XmlPickler” at http://hpaste.org/54579
12:38:49 <monochrom> darn you!
12:38:50 <Sebasti0n> I can't seem to figure out how to handle multiple constructors.
12:38:54 <dmwit> monochrom: =)
12:39:02 <Eduard_Munteanu> dmwit: mm... how about "everything is a branch"? :)
12:39:05 <Eduard_Munteanu> (in Git)
12:39:13 <Sebasti0n> There is an example pickler i wrote, but how to I handle a second constructor?
12:39:58 <hydo> Eduard_Munteanu: there's also in that vein, the git code in gitit.
12:40:07 <irene-knapp> Sebasti0n: why is xpFunction a class method instead of standalone?
12:40:11 <dmwit> Eduard_Munteanu: How about it?
12:40:13 <hydo> err, the wiki project.... called gitit, I'm almost sure.
12:40:19 <irene-knapp> it looks like all you need in the class are fromTuple and toTuple
12:40:46 <irene-knapp> anyway, for multiple constructors you would have to add fromTuple and toTuple methods for each
12:40:55 <Eduard_Munteanu> dmwit: well, branching might make a difference in SVN, but in Git it's pretty easy to use.
12:40:58 <irene-knapp> for example, toTuple (OtherKindOfCluster ...) = ...
12:41:05 <irene-knapp> you just write that definition right below the other definition
12:41:18 <dmwit> Eduard_Munteanu: We're discussing a scenario where there is no branching. So the ease or difficulty of branching is immaterial.
12:41:21 <Eduard_Munteanu> Darcs is a bit awkward in that respect.
12:41:23 <irene-knapp> of course, you have to have enough information in the tuple such that fromTuple can tell which constructor to use
12:41:24 <Eduard_Munteanu> Ah.
12:41:39 <irene-knapp> for example, you could store the name of the constructor as a first item of the tuple:
12:41:51 <irene-knapp> toTuple (Cluster ...) = ("Cluster", ...)
12:42:07 <irene-knapp> fromTuple ("cluster", ...) = Cluster ...
12:42:31 <irene-knapp> of course this bumps into a problem
12:42:45 <irene-knapp> which is that a tuple has the number and types of its items fixed
12:42:49 <irene-knapp> as part of its own type
12:42:58 <Sebasti0n> yeah
12:43:36 <irene-knapp> what you /probably/ want as your intermediate value
12:43:51 <irene-knapp> is something like [(String, Atom)]
12:43:57 <Sebasti0n> monochrom said something earlier: appPickle :: (a, St) -> St  there is your input parameter (a, St)
12:44:04 <irene-knapp> list of key-value pairs, where Atom is a type you define that can have any of the primitive types you need in it
12:44:07 <Sebasti0n> as appPickle is a function of PU
12:44:16 <Sebasti0n> but I can't figure out how to make use of that
12:44:37 <monochrom> oh, sorry, I see how it doesn't help
12:44:50 <monochrom> no, wait, it helps
12:45:22 <monochrom> but it is not obvious, and I have to go
12:45:41 <irene-knapp> I'm not sure I see it either, sorry :) I wouldn't worry about it; it looks like an insight for a subproblem that you haven't gotten to yet
12:47:39 <Sebasti0n> hmm, this shouldn't be so complicated
12:47:51 <irene-knapp> indeed it shouldn't
12:48:44 <irene-knapp> like I said, the root of the difficulty is that you've decided the intermediate value is a tuple
12:48:53 <irene-knapp> you don't want it to be a tuple, you want it to be an association list
12:49:15 <irene-knapp> because, for example, with an association list, you can account for the fact that different constructors have different numbers of elements
12:51:25 <Sebasti0n> I see if I can figure it out, thanks
12:51:30 <irene-knapp> okay
12:57:11 <lukish> How can I cast Int to Double?
12:57:15 <lukish> Or convert.
12:57:31 <tijn> what is the all-encompassing type for Int, Double etc in a type signature?
12:57:43 <aninhumer> Hmm, the typeclassopedia on the haskell wiki links to a page explaining why Pointed was dropped, but that page has nothing on it
12:58:12 <lukish> Especially I get value from ... -> Int function and need to divide it to some number
12:58:12 <dmwit> ?hoogle Int -> Double
12:58:13 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:58:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:58:13 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
12:58:17 <dmwit> ick
12:58:20 <dmwit> :t fromIntegral
12:58:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:58:26 <dmwit> lukish:
12:58:46 <dmwit> tijn: You might like the Num class.
12:58:51 <dmwit> (It's not a type, though.)
12:59:11 <jhussein> could somebody please help me super quick with acid-state? I have a type of Blog which is an IntMap that contains Post's
12:59:14 <lukish> Works, ok
12:59:29 <jhussein> how exactly do I retrieve posts in a usable format? (I'm new to haskell)
13:00:02 <tijn> yes, but I would like to use it in a type signature, as in: fun :: Int -> String     ,    but then as in:    fun :: UberType  -> String
13:00:16 <dmwit> fun :: Num a => a -> String
13:00:22 <benmachine> jhussein: can we see some of your existing code?
13:00:33 <dmwit> or perhaps
13:00:37 <dmwit> fun :: Show a => a -> String
13:00:39 <tijn> dmwit, Thnx!
13:00:42 <dmwit> depending on what you're doing with it.
13:00:51 <benmachine> jhussein: see hpaste.org
13:00:54 <hpaste> jhussein pasted “Blog” at http://hpaste.org/54580
13:00:57 <dmwit> tijn: If you just write the code (and don't write a type signature), the compiler should infer such types for you. Try it and see!
13:00:57 <benmachine> oh
13:01:02 <benmachine> way ahead of me evidently :)
13:01:29 <jhussein> benmachine: I am trying to follow https://github.com/aslatter/blog
13:01:32 <dmwit> tijn: (Be sure to turn off the monomorphism restriction, though. Include "{-# LANGUAGE NoMonomorphismRestriction #-}" at the top of your file.
13:01:40 <jhussein> but its using an older version of everything, and some other weird stuff
13:01:59 <lukish> How can I round to seven decimal places in the form 0.abcdefg?
13:02:19 <benmachine> lukish: do you want a string, or do you want the number
13:02:49 <dmwit> > printf "%0.7f" 11.123456789
13:02:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:02:50 <lambdabot>    `Text.Printf.PrintfType ...
13:02:52 <dmwit> > printf "%0.7f" 11.123456789 :: String
13:02:53 <lambdabot>   "11.1234568"
13:03:09 <dmwit> > round (11.123456789 * 1e7)
13:03:10 <lambdabot>   111234568
13:03:31 <dmwit> :t showCReal
13:03:32 <lambdabot> Int -> CReal -> String
13:03:39 <dmwit> > showCReal 7 11.123456789
13:03:40 <lambdabot>   "11.1234568"
13:04:02 <Cale> http://i.qkme.me/35cwq6.jpg lol
13:04:20 <benmachine> jhussein: so doesn't 'get' fetch you posts?
13:04:32 <tijn> dmwit, I know that but I have some function that sometimes eats a double and sometimes an int but perhaps that is asking too much at the moment for me ;-)
13:04:44 <benmachine> Cale: hah
13:04:46 <jhussein> benmachine: Do I use the acid-state's "query", or do i use get?
13:05:08 <benmachine> jhussein: I don't know the ins and outs of either, but I don't see why you can't use get
13:05:57 <jhussein> so when you get back a Query Blog (Maybe Post)
13:06:01 <jhussein> how do i get just the post?
13:06:07 <lukish> benmachine: string
13:06:10 <lukish> Or IO()
13:07:05 <benmachine> lukish: try the Numeric module, showFFloat, showEFloat, showGFloat
13:07:18 <benmachine> (corresponding to %e, %f, %g printf formats
13:07:19 <benmachine> )
13:08:30 <lukish> ?hoogle GHC.Prim.Any -> String
13:08:30 <lambdabot> Parse error:
13:08:31 <lambdabot>   GHC.Prim.Any -> String
13:08:31 <lambdabot>      ^
13:08:39 <lukish> ?hoogle Any -> String
13:08:40 <lambdabot> Prelude show :: Show a => a -> String
13:08:40 <lambdabot> Text.Show show :: Show a => a -> String
13:08:40 <lambdabot> Test.QuickCheck.Text showErr :: Show a => a -> String
13:09:05 <benmachine> jhussein: I suspect what you have to do depends on how you use Acid
13:09:24 <jhussein> damnit im so confused, been stuck for a pretty long time
13:09:26 <benmachine> jhussein: but be aware that Query is a monad, so you might not *need* to get the Post out
13:10:43 <benmachine> okay, you will probably need to use get /and/ query
13:11:09 <lukish> Well, printf is quiet good, but can it be showed?
13:11:33 <lukish> Or converted to string.
13:12:01 <benmachine> lukish: I didn't say use printf
13:12:07 <irene-knapp> OKAY!  I can reproduce the failure to apply all dictionary-function unwinding rewrite rules on another platform!
13:12:14 <benmachine> I only used it to tell you what showFFloat does
13:12:15 <benmachine> use those
13:12:15 <irene-knapp> I can't reproduce the incorrect-GCD behavior
13:12:34 <irene-knapp> but that's to be expected, actually
13:12:56 <ick> if i have a function f.e int -> int and i want to print the output of the function using IO(), how do i do that?
13:13:01 <irene-knapp> since the other platform I tried is quite different numerically
13:13:11 <benmachine> ick: what inputs do you want to use?
13:13:27 <ick> what do you mean what inputs?
13:13:50 <irene-knapp> icK: it's a function from integers to integers.  it doesn't have any output until you give it an input.
13:14:03 <irene-knapp> you say you want to print the output; what input do you want that output to be based on?
13:14:42 <ick> the input the function is called with?
13:14:53 <benmachine> ick: so you want a function that looks like Int -> IO ()?
13:15:10 <irene-knapp> you made it sound like you wanted to print some sort of description of how the function behaves
13:16:09 <ick> hmm no i want the side effect of a call to a function be that it prints
13:16:17 <irene-knapp> then yes, what you want is actually
13:16:21 <irene-knapp> :: Int -> IO Int
13:16:29 <irene-knapp> but then you can't call it purely, of course
13:16:35 <irene-knapp> because it's in IO
13:16:46 <irene-knapp> the function body would look like
13:17:13 <irene-knapp> superSecretEncryption input = do { output <- input * 2 ; putStrLn $ show output ; return output }
13:17:24 <lukish> benmachine: it's hard to understand what's for all the arguments in showFFloat
13:17:51 <benmachine> lukish: the Maybe Int is precision, the a is the thing you want printed
13:17:57 <benmachine> for the list argument, just give it an empty list
13:17:58 <benmachine> er
13:17:59 <benmachine> string
13:18:18 <irene-knapp> ick: alternatively, you could keep superSecretEncryption's type as Int -> Int, which makes it impossible for it to have side-effects (such as printing anything)
13:18:21 <dmwit> Don't worry, an empty list is an empty string, too.
13:18:36 <irene-knapp> ick: and then make the CALLER of superSecretEncryption be in IO and do the printing
13:18:43 <irene-knapp> in that case you would have
13:18:52 <irene-knapp> superSecretEncryption input = input * 2
13:18:52 <benmachine> irene-knapp: wait, your function is wrong
13:18:57 <benmachine> because input * 2 isn't IO
13:19:09 <irene-knapp> benmachine: er, good call.  you are deputized to fix that :)
13:19:09 <lukish> > showFFloat Just 7 11.123456789 ""
13:19:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
13:19:11 <lambdabot>         again...
13:19:22 <benmachine> superSecretEncryption input = do { let output = input * 2 ; putStrLn $ show output ; return output }
13:19:27 <benmachine> lukish: (Just 7)
13:19:35 <lukish> > showFFloat (Just 7) 11.123456789 ""
13:19:36 <lambdabot>   "11.1234568"
13:19:37 <benmachine> lukish: otherwise you are giving two arguments, Just, and 7
13:19:41 <lukish> Nice
13:19:56 <irene-knapp> main = do { ... ; let output = superSecretEncryption input ; putStrLn $ show output ; ... }
13:20:16 <irene-knapp> see, and I thought you were going to nitpick and claim that multiplying by two isn't very good encryption :)
13:20:59 <irene-knapp> ick: does that all make sense?
13:21:02 <ick> is a do statement specific to IO? i couldnt have an Int -> Int that did do { printMe (n+1) ; return n+1 } ?
13:21:15 <benmachine> irene-knapp: well, hash collisions are infrequent when your hash function is (*2), so it's good from that perspective
13:21:20 <irene-knapp> ick: well, the do statement is for monads, and IO is a monad, but you don't need to understand monads to use it
13:21:29 <irene-knapp> ick: so yes, you can't have an Int -> Int that uses do
13:21:45 <rwbarton> You can't have an Int -> Int that prints, either
13:22:10 <irene-knapp> ick: by the way, if you're new to do-syntax, I should explain that the { ... } is actually not the preferred way to write it, but it's how I typed things out because it let me put everything on one line
13:22:41 <irene-knapp> ick: you can actually just leave out the '{' and '}', put a newline right after the "do", and change all the ';'s to newlines
13:23:11 <irene-knapp> ick: although you have to make sure that each statement (line item of the do block) is its own line, indented the same amount as the others, and that amount has to be greater than the amount that the do itself is indented.  heh.
13:23:26 <irene-knapp> and yes, as rwbarton said, no function that's Int -> Int without IO in it can print output
13:24:11 <ick> can i pass the result to an Int -> IO Int and still return the int in the first function?
13:26:59 <benmachine> ick: a function that is type Int -> Int can't do any IO inside it, ever
13:27:06 <ick> hmm ok
13:27:23 <benmachine> ick: so if you have an Int -> IO Int, you can only call it in functions that return IO Something
13:27:58 <ick> my problem arises because i have a functin, lets say int -> int because we have been doing, that only prints in certain cases
13:28:06 <ick> like lets say the output is bigger than 10
13:28:14 <ick> it prints and returns the result
13:28:19 <ick> else it just returns the result
13:28:24 <benmachine> ick: so make it Int -> IO Int
13:34:10 <ick> so what am i misunderstanding in this function then: http://pastebin.com/J1NCmya6
13:34:12 <mauke> The paste J1NCmya6 has been copied to http://hpaste.org/54581
13:34:48 <dmwit> ick: otherwise = return y
13:34:59 <dmwit> ick: Also, you might like the "when" function.
13:35:16 <dmwit> f x = when (y > 10) (print y); return y where y = x + 1
13:35:32 <dmwit> Also, you probably do not need the "import IO()" line.
13:35:58 <ick> ah, thanks
13:40:29 <ick> dmwit: what if the functionn is Int -> Boolean f.e but we want to output an Int?
13:40:43 <ick> surely IO Boolean isnt right here
13:42:16 <ion> Define “to output”.
13:42:34 <ick> use print(x) like the function i pasted
13:43:18 <ion> Integer → IO Bool means a function that takes an integer and returns an IO action which can do arbitrary IO stuff and which results in a boolean.
13:43:27 <ick> lets say, bigger than 10 print 10 and return true else return false
13:43:48 <ick> hmm
13:43:54 <dmwit> ick: Int -> IO Bool is, indeed, right here.
13:43:59 <ick> i see
13:44:20 <irene-knapp> the "IO" part of the type says it can do anything it wants, that is allowed by IO (which is anything)
13:44:28 <irene-knapp> the "Bool" part of the type says what its actual result is
13:45:30 <carpi> > (/) (sum [1,2,3]) (fromIntegral (length [1,2,3]))
13:45:31 <lambdabot>   2.0
13:45:56 <carpi> > (/) (sum [1,2,3]) (length [1,2,3])
13:45:56 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:45:57 <lambdabot>    arising from a use o...
13:46:02 <irene-knapp> > let it = [1,2,3] in (/) (sum it) (fromIntegral $ length it)
13:46:03 <lambdabot>   2.0
13:46:11 <DrSyzygy> ick: A valid Int -> Boolean can do the following seqeuence of actions: 1. request input from the user. 2. print all given input back out to the user. 3. return true if the value initially given was >10.
13:46:13 <dmwit> > (/) (sum [1,2,3]) (genericLength [1,2,3])
13:46:14 <lambdabot>   2.0
13:46:29 <irene-knapp> > let it = [1,2,3] :: [Int] in (/) (sum it) (length it)
13:46:30 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:46:30 <lambdabot>    arising from a use o...
13:46:30 <dmwit> > sum [1,2,3] / genericLength [1,2,3] -- why so many parens?
13:46:31 <lambdabot>   2.0
13:46:34 <ick> you mean IO Boolean DrSyzygy ?
13:46:39 <irene-knapp> > let it = [1,2,3] :: [Rational] in (/) (sum it) (length it)
13:46:40 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
13:46:41 <lambdabot>         against inferred t...
13:46:52 <carpi> what i don't understand is "(/) (sum x) (fromIntegral (length x))" works on lamdadot but not on my computer..
13:46:52 <irene-knapp> > let it = [1,2,3] :: [Int] in div (sum it) (length it)
13:46:53 <lambdabot>   2
13:46:58 <DrSyzygy> ick: A less unnatural example would be to print out all but the <given int> first of the characters read from stdin and then return True if an even number of characters were printed (or so).
13:47:30 <irene-knapp> carpi: I would guess that the defaulting rules (what type numbers are when their type can't be inferred from context) are different
13:47:34 <irene-knapp> carpi: as to why that would be, I don't know
13:47:58 <irene-knapp> remember that (/) is the real-number version of the operation, so only types in Fractional can do it
13:48:22 <irene-knapp> if you wanted a whole-number output, you could use div, but it looks like you probably did mean (/)
13:49:08 <carpi> im surprised there is no function like "toFractional" in the prelude. Not that it is necessary.. but if they have functions like "toEnum", "toInteger" and "toRational" .
13:49:18 <carpi> im guessing "toRational" is akin
13:49:29 <irene-knapp> carpi: well, but Enum, Integer, and Rational are /types/, see
13:49:34 <irene-knapp> Fractional is a /typeclass/
13:49:43 <irene-knapp> that is, there is more than one type that satisfies it
13:49:48 <irene-knapp> (for example, Rational and Double both do)
13:50:10 <carpi> ah shite.. thanks for pointing that out. another slap in the face
13:50:13 <irene-knapp> np
13:50:30 <carpi> is it possible to distinguish a Type class from the name of a type just be looking?
13:50:33 <DrSyzygy> #haskell, always ready to give you that well needed slap in the face. ;-)
13:50:45 <irene-knapp> not from the name alone, but you can tell by where it appears
13:50:55 <irene-knapp> you will never see a type signature like foo :: Fractional
13:51:02 <irene-knapp> because there is no type Fractional and the thing after the :: is a type, right
13:51:09 <irene-knapp> instead you will see foo :: (Fractional a) => a
13:51:19 <irene-knapp> (Fractional a) => is called a type context
13:51:38 <irene-knapp> it specifies things which must be true abou the types following it; in this case, it says that the type variable a has an instance of Fractional defined for it
13:51:39 <carpi> irene-knapp: so a typeclass will always appear in a signature before "=>"
13:51:44 <irene-knapp> then the type itself is just "a"
13:51:47 <irene-knapp> yes, indeed so
13:52:53 <carpi> irene-knapp: ofcourse..sometimes within brackets and sometimes without..because I've seen signatures like "f :: Num a => [a] -> a"
13:53:04 <irene-knapp> well, yes
13:53:10 <irene-knapp> the parentheses are optional in most cases
13:53:18 <irene-knapp> you know what the signature you just gave me means, right?
13:54:00 <irene-knapp> I would read it "the type of f is function from list of "a"s to a single "a", where "a" is some type in Num"
13:54:08 <carpi> irene-knapp: i think so. xD. A list of 'a's which are instances of type belonging to Num?
13:54:20 <irene-knapp> well, you stopped reading at the -> :)
13:54:34 <irene-knapp> you're correct if it didn't say -> a at the end
13:55:17 <carpi> ... returning an 'a' which is an instance of type class Num. : )
13:55:21 <irene-knapp> yes.
13:55:39 <jhussein> So I am trying to learn acid-state from their most recent examples, after you get a database variable, I am putting it inside an AppState data type
13:55:41 <irene-knapp> in fact it also stipulates that the "a" that's returned and the "a" that's the elements of the list passed in are the same type
13:55:52 <jhussein> how do I retrieve that variable from somewhere further down inside a function?
13:55:53 <irene-knapp> if they could be different types, the signature would be
13:56:01 <irene-knapp> :: Num a, Num b => [a] -> b
13:56:03 <carpi> [a]->b
13:56:05 <irene-knapp> yep
13:56:16 <irene-knapp> jhussein: not sure, haven't used it, sorry
13:56:57 <carpi> irene-knapp: wouldn't it be ":: Num a, <something else> b => [a] -> b"?
13:57:40 <irene-knapp> oh, well, if that's what you intend, then yes
13:57:51 <irene-knapp> I was thinking they were both Num instances, but not necessarily the same as each other
13:59:39 <carpi> irene-knapp: ah okay.. as in 'a' could be an Int and 'b' could be Integer
13:59:42 <irene-knapp> yes
13:59:52 <carpi> but not the same..
14:00:02 <carpi> or could be
14:00:11 <irene-knapp> they /could/ be the same, it just can't be assumed
14:00:14 <irene-knapp> :t fromIntegral . length
14:00:15 <lambdabot> forall b a. (Num b) => [a] -> b
14:00:36 <ion> :t genericLength
14:00:37 <lambdabot> forall b i. (Num i) => [b] -> i
14:01:02 <irene-knapp> :t (\in -> div (fromIntegral $ sum in) (fromIntegral $ length in))
14:01:03 <lambdabot> parse error on input `in'
14:01:16 <irene-knapp> oh, right, reserved word :)
14:01:21 <irene-knapp> :t (\input -> div (fromIntegral $ sum input) (fromIntegral $ length input))
14:01:22 <lambdabot> forall a b. (Integral a, Integral b) => [a] -> b
14:02:09 <ion> Hmm. What would break if length was replaced with genericLength? Wouldn’t type inference handle the change for most preexisting code?
14:02:30 <irene-knapp> ion: I've always wonered
14:02:32 <irene-knapp> *wondered
14:02:37 <irene-knapp> it seems like it would be a good idea, doesn't it?
14:04:01 <carpi> > :t genericLength
14:04:02 <lambdabot>   <no location info>: parse error on input `:'
14:04:18 <carpi> > :t length
14:04:19 <lambdabot>   <no location info>: parse error on input `:'
14:04:31 <carpi> >:type length
14:04:48 <ion> @type (genericLength, length)
14:04:49 <lambdabot> forall b i a. (Num i) => ([b] -> i, [a] -> Int)
14:05:16 <carpi> @type length
14:05:17 <lambdabot> forall a. [a] -> Int
14:05:32 <carpi> just testing .. sry
14:05:41 <shachaf> ion: genericLength is a foldr rather than a foldl.
14:05:56 <irene-knapp> np
14:06:05 <irene-knapp> shachaf: OH!  is it really?  .... why?
14:06:21 <shachaf> irene-knapp: Otherwise things like the lazy natural genericLength trick wouldn't work.
14:06:35 <shachaf> @src genericLength
14:06:35 <lambdabot> genericLength []    = 0
14:06:36 <lambdabot> genericLength (_:l) = 1 + genericLength l
14:06:37 <irene-knapp> wait, what?
14:06:53 <irene-knapp> there's a context where you want to get the length of something but you don't want to actually evaluate it?
14:07:01 <shachaf> You know, where you say (genericLength l :: Nat) > 5 and it only checks five elements.
14:07:05 <irene-knapp> oh, hmmmm
14:07:07 <irene-knapp> nice trick!
14:07:18 <irene-knapp> except Nat isn't a type, is it? O_o is it new?
14:07:26 <irene-knapp> :k Nat
14:07:27 <lambdabot> Not in scope: type constructor or class `Nat'
14:07:36 <shachaf> Not in the standard library.
14:07:40 <irene-knapp> right, okay
14:07:47 <irene-knapp> > (genericLength [1, 2, 3, undefined]) > 0
14:07:48 <lambdabot>   True
14:07:51 <irene-knapp> > (genericLength [1, 2, 3, undefined]) > 3
14:07:52 <lambdabot>   True
14:07:54 <irene-knapp> > (genericLength [1, 2, 3, undefined]) > 4
14:07:55 <lambdabot>   False
14:08:10 <shachaf> > (genericLength (1:2:3:undefined)) > 0
14:08:11 <lambdabot>   *Exception: Prelude.undefined
14:08:17 <irene-knapp> > (genericLength ([1, 2, 3] ++ undefined)) > 4
14:08:19 <lambdabot>   *Exception: Prelude.undefined
14:08:20 <irene-knapp> > (genericLength ([1, 2, 3] ++ undefined)) > 3
14:08:21 <lambdabot>   *Exception: Prelude.undefined
14:08:23 <irene-knapp> > (genericLength ([1, 2, 3] ++ undefined)) >
14:08:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:08:25 <irene-knapp> > (genericLength ([1, 2, 3] ++ undefined)) > 2
14:08:26 <lambdabot>   *Exception: Prelude.undefined
14:08:30 <irene-knapp> > (genericLength ([1, 2, 3] ++ undefined) :: Int) > 2
14:08:32 <lambdabot>   *Exception: Prelude.undefined
14:08:50 <irene-knapp> so this is a trick that no existing code relies on, since it only works for the not-yet-merged Nat type :)
14:08:56 <shachaf> Cale  should add a Nat type to lambdabot.
14:09:08 <irene-knapp> hmm
14:09:17 <irene-knapp> the trick though
14:09:18 <irene-knapp> seems to me
14:09:20 <shachaf> irene-knapp: Nat doesn't need to be in the standard library for people to rely on this trick.
14:09:22 <irene-knapp> like it relies on a RULE, doesn't it?
14:09:36 <shachaf> ?
14:10:02 <irene-knapp> I don't understand what definition of genericLength and Nat could make it work
14:10:10 <irene-knapp> without some rewriting going on
14:10:17 <shachaf> data Nat = Z | S Nat
14:10:35 <irene-knapp> yes, I know
14:10:38 <shachaf> Nat is just like a list [a]
14:10:44 <irene-knapp> hmm
14:10:47 <irene-knapp> oh, wait, I see it now
14:10:54 <irene-knapp> + on Nat is lazy instead of strict
14:10:56 <shachaf> ">" walks through the "lists" in parallel until it sees a []
14:11:10 <irene-knapp> oh, hmmm, not what I just said
14:13:10 <benmachine> shachaf: I'm inclined to think that lazy + is rare enough that genericLength should be spine-strict
14:13:27 <irene-knapp> > data Nat = Z | S Nat ; instance Num Nat where { (>) Z _ = False ; (>) (S _) Z = True ; (>) (S restA) (S restB) = (>) restA restB ; 5 :: Nat > 4 :: Nat }
14:13:27 <lambdabot>   <no location info>: parse error on input `data'
14:13:31 <irene-knapp> bah!
14:13:38 <irene-knapp> I was afraid of that :D
14:13:41 <shachaf> benmachine: I certainly think that a strict genericLength should be in the standard library.
14:14:00 <benmachine> irene-knapp: expression context, sry :P
14:14:08 <benmachine> hmm
14:14:20 <irene-knapp> benmachine: I know :( why are you the one who's sorry?  are you responsible for lambdabot? :)
14:14:23 <ion> genericLength has a RULE for → Int and → Integer where it uses the non-exported strictGenericLength. :-)
14:14:24 <benmachine> :t In (Const ())
14:14:26 <lambdabot> Mu (Const ())
14:14:29 <shachaf> benmachine: On the other hand, in practice, fromInteger . length is probably good enough. :-)
14:14:34 <benmachine> wait no that's not what I want
14:14:51 <benmachine> shachaf: what if my list is 3 trillion items long? :(
14:14:54 <shachaf> benmachine: In Nothign?
14:15:06 <shachaf> benmachine: The the result will be the same either way.
14:15:13 <benmachine> shachaf: yeah, that sounds more like it
14:15:26 <benmachine> shachaf: it... might not be!
14:15:45 <benmachine> I bet I could write an expression such that length xs *eventually* gives a negative answer
14:16:08 <shachaf> benmachine: "eventually" as in "theoretically eventually" or "actually eventually"?
14:16:48 <benmachine> shachaf: well, pessimistically, it processes one list item a second, then it'll be done in... less than a century?
14:17:08 <benmachine> (given that 32-bit time is 68 years long, I don't remember if that's signed)
14:17:23 <irene-knapp> > length [] {-# RULES "irene-breaks-things" forall a . length a = (-1) ; #-}
14:17:24 <lambdabot>   <no location info>: parse error on input `{-# RULES'
14:17:27 <irene-knapp> awwwwww!
14:17:34 <irene-knapp> that would rock
14:17:37 <benmachine> hah
14:17:39 <irene-knapp> if it could do that
14:17:51 <shachaf> benmachine: Ah, I was thinking of a 64-bit machine.
14:18:03 <benmachine> shachaf: well, stop doing that
14:18:20 * shachaf continues thinking about 64-bit machines.
14:18:22 <shachaf> Sorry.
14:18:35 <benmachine> >:[
14:18:57 <shachaf> > (:[{- HELP! -}])
14:18:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
14:18:58 <lambdabot>    arising from a use of...
14:19:07 <shachaf> @quote eat.a.comment
14:19:07 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
14:19:24 * benmachine constructs a five-bit machine just to annoy shachaf 
14:19:40 * shachaf is fine with that as long as 5 = 64.
14:19:56 <shachaf> If you want, you can use any machine you like, as long as Int is 64 bits.
14:20:05 <irene-knapp> wait, why didn't it return anything for shachaf's example?
14:20:08 <irene-knapp> > (:[])
14:20:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
14:20:10 <lambdabot>    arising from a use of...
14:20:15 <irene-knapp> >:[
14:20:18 <irene-knapp> oh
14:20:19 <irene-knapp> no space
14:20:20 * shachaf hopes his point has come acorss, though.
14:20:21 <irene-knapp> okay
14:21:01 * _Mikey things shachaf's points always come across
14:21:09 <_Mikey> s/things/thinks
14:22:16 <_Mikey> heyy XD
14:22:17 <michaelbaker> I'm off. Thanks again chreekat.
14:29:03 <tsou> some cabal installations try to use a c compiler and check to see if it "works"..  this is all tested under /tmp by default..  Is there a way to change this?
14:29:25 <irene-knapp> probably, but I'm not sure
14:29:30 <sipa> symlink/bindmount /tmp elsewhere? :p
14:32:23 <tsou> sipa: ahem, i suppose there is (and if not there should be.. no?) something like.. --tempdir ?
14:32:32 <tsou> actually there is not, but i meant if there is some other way to customize this
14:32:46 <sipa> sorry, don't know the answer
14:33:14 <sipa> but why do you want to change it?
14:33:41 <ion> benmachine:
14:33:46 <ion> % time ghc -e ':m + Data.List' -e 'length . genericReplicate ((fromIntegral (maxBound :: Int) :: Integer) + 1) $ ()'
14:33:49 <ion> -2147483648
14:33:52 <ion> ghc -e ':m + Data.List' -e   763.92s user 15.78s system 85% cpu 15:08.98 total
14:34:05 <benmachine> ion: :D
14:34:15 <benmachine> /significantly/ less than 68 years then
14:36:24 <carpi> @type do
14:36:32 <carpi> > @type do
14:36:40 <carpi> or maybe do is not a type
14:36:44 <donri> "do" is syntax
14:36:59 <donri> and @type is for values, not types :)
14:37:25 <shachaf> And lambdabot isn't here.
14:38:03 <tsou> sipa: cause on some machines i have /tmp mounted noexec bydefault, and it's annoying that cabal is only convinced that the compiler works by executing a freshly-made binary
14:38:09 <carpi> i downloaded a simply calculator from hackage.. to learn from its source code.. . I see it has a main. But what is this.. "main :: IO ()"?
14:38:17 <carpi> main returns an empty tuple?
14:38:31 <donri> no, it is an IO value
14:38:38 <Botje> main is an IO action that eventually returns a unit value.
14:38:40 <carpi> oh i mean "unit" not empty tuple sory
14:38:42 <sipa> carpi: it returns an action that - apart from its side effects - produces a unit value
14:38:57 <Botje> however, the IO part is probably more important than its return value :)
14:39:05 <shachaf> carpi: What would you want it to return? Int?
14:39:13 <benmachine> tsou: probably it can be fixed with a --configure-option, but I don't know which one I'm afraid
14:39:21 <ion> main is an IO action that results in (). I’d rather say “main is” that “main returns” since it’s not a function.
14:39:25 <shachaf> main's type is actually IO a.
14:39:36 <sipa> shachaf: really? :o
14:39:45 <shachaf> exists a. IO a?
14:40:23 <carpi> it just that it looks strange to me.. because i've been reading "lear you a haskell" and all the functions ive seen have been like "f :: <type> -> <type>" or some variation
14:40:33 <tsou> benmachine: none of them looks promising ;)
14:40:35 <carpi> so haskell has functions and actions
14:40:39 <donri> carpi: but main is not a function
14:40:47 <ion> carpi: Indeed, that’s very important to realize.
14:41:09 <sipa> especially don't think that everything is a function :)
14:41:22 <ion> Functions are pure, referentially transparent. IO actions can launch the missiles.
14:41:26 <carpi> functions or pure... actions are dirty.. or rather they contaminate everything they touch..?
14:41:35 <carpi> s/or/are
14:42:07 <donri> carpi: if you do "x = 5", is x a function? main is like x here, defined in the top-level and holding a value of the IO type rather than a number type
14:42:18 <gwern> hm. the base package now uses git. I don't know how to contribute a doc change :(
14:42:19 <shachaf> ion: Well, the RTS can launch missiles when it encounters IO action.
14:42:26 <ion> shachaf: yeah
14:42:29 <irene-knapp> gwern: yes that irritates me too :(
14:42:32 <shachaf> The actions themselves are "pure". :-)
14:42:44 <ion> “IO actions can upon execution launch the missiles.”
14:42:58 <ion> not evaluation
14:43:11 <carpi> donri: isn't x a fucntion in "x = 5" or rather an expression of a function?
14:43:26 <sipa> expressions of type IO a evaluate to values of type IO a
14:43:33 <carpi> and main .. because of its side effects cannot be a function..
14:43:34 <rwbarton> x isn't a function. x is 5.
14:43:35 <sipa> when executed, they produce something of type a
14:43:44 <carpi> oah im wrong
14:43:53 <sipa> carpi: read on
14:43:56 <shachaf> rwbarton: x is maybe a function.
14:44:01 <shachaf> > 5 3
14:44:01 <sipa> in LYAH :)
14:44:10 <donri> carpi: = is for binding values to names, and nothing specific to functions. similarly, functions are not special either, they're values too.
14:44:15 <ion> > " -> " `isInfixOf` (show . typeOf $ let x = 5 in x)
14:44:18 <unsafePerformIO> compiling with "ghc --make Main.hs" and running gives "Main: <<loop>>". I do not understand what this means and what is wrong. Any ideas?
14:44:19 <rwbarton> shachaf: I am all too aware of this. :P
14:44:24 <benmachine> shachaf: shh
14:44:32 <sipa> unsafePerformIO: paste your code somewhere
14:44:43 <benmachine> unsafePerformIO: that message means GHC detected your code looping forever
14:44:48 <benmachine> and threw an exception
14:44:55 <unsafePerformIO> sipa: it is too long.
14:44:58 <rwbarton> unsafePerformIO: for example, you might get that message if you wrote   main = print x where x = x + 1
14:45:05 <ion> That’s what she… No, resist! resist!
14:45:15 <unsafePerformIO> benmachine: runtime detection?
14:45:23 <shachaf> unsafePerformIO: <<loop>> means you have a simple form of infinite recursion where in order to evaluate a value, you must first evaluate that value.
14:45:25 <carpi> donri: even functions that take arguments are values?
14:45:35 <sipa> carpi: yes
14:45:44 <benmachine> unsafePerformIO: yes
14:45:56 <sipa> carpi: and every function in haskell takes exactly one argument
14:46:03 <donri> carpi: all functions take (exactly one) argument
14:46:06 <shachaf> unsafePerformIO: When GHC starts evaluating a value, it "marks" it, sort of, so that if it encounters that in the course of evaluating the value, it can tell that it'll never finish.
14:46:07 <carpi> cos of curring
14:46:11 <sipa> indeed
14:46:18 <shachaf> Consider it to be a friendlier form of non-termination. :-)
14:46:28 <irene-knapp>  oh
14:46:31 <irene-knapp> his NICK is unsafePerformIO
14:46:36 <sipa> @faq can haskell do infinite loops in five seconds?
14:46:41 <carpi> i have to admit.. currying is fantastic..
14:46:43 <sipa> no lambdabot :(
14:46:43 <unsafePerformIO> ok. I see that there is some inline bug in ghc-6.12.1, could this be the failure, or is this detected at compile time?
14:46:45 <ion> Why no, it can’t!
14:46:53 <irene-knapp> haha
14:46:59 <donri> yes, it was rather scary when my irc client said "unsafePerformIO has joined the room"
14:47:04 <benmachine> unsafePerformIO: that's very vague, which bug do you mean
14:47:09 <shachaf> unsafePerformIO: This is a runtime error (which is why it happens when you run the program).
14:47:15 * sipa executes unsafePerformIO 
14:47:15 <ion> Your IRC client says “room”?
14:47:19 <shachaf> unsafePerformIO: Probalby best to @paste it somewhere and see.
14:47:20 <sipa> oh no, what did i do? :o
14:48:18 <unsafePerformIO> the code is too long to paste.
14:48:37 <sipa> unsafePerformIO: is it over a thousand lines?
14:48:44 <ion> IT’S OVER NINE THOUSAND
14:48:55 <tromp> no way!
14:48:56 <papa_smurf> WHAT NINE THOUSAND ?!
14:49:10 <papa_smurf> THERES NO WAY THAT CAN BE RIGHT !
14:49:40 <shachaf> unsafePerformIO: There exist bugs in GHC but I would be more inclined to guess a bug in your code than in GHC until shown otherwise.
14:49:46 <unsafePerformIO> here is the inline-bug I was thinking about: http://www.haskell.org/ghc/docs/6.12-latest/html/users_guide/bugs.html#bugs-ghc
14:49:51 <erus`> lol look at me do memes guiz!
14:50:02 <donri> canhas meme
14:50:11 <donri> (meta)
14:50:25 <rwbarton> unsafePerformIO: you can tell you have not encountered that bug if the compiler terminates
14:50:43 <rwbarton> which it did, since you were able to run your program and have it print "<<loop>>"
14:51:01 <carpi> @type printLn
14:51:11 <carpi> @type print
14:51:17 <ddarius> "My users complained about an infinite loop, did the compiler loop when I built the code?"
14:51:23 <donri> needs moar lambdabot
14:51:24 <carpi> lambdanaut_: why you no talk to me !!
14:51:30 <unsafePerformIO> rwbarton: good. that was exactly my idea of the question
14:51:32 <shachaf> unsafePerformIO: That bug looks completely unrelated.
14:51:42 <donri> and lambdanaut /= lambdabot
14:51:46 <shachaf> The compilation is clearly terminating since you're running the program.
14:51:52 <carpi> ah shite.. i meant lamdobot
14:52:00 <carpi> i mean lambdabot
14:52:13 <carpi> > @type printLn
14:52:18 <donri> it's not here at the moment
14:52:27 <carpi> oh its offline?
14:52:37 <donri> in deed
14:52:40 <donri> but you can use :t in ghci
14:52:50 <shachaf> carpi: Yes. Also: "> blah blah" is for evaluating expressions; "@type blah blah" is for figuring out types.
14:52:53 <tsou> ok, cabal-install respects the TMPDIR variable, just in case anyone was interested :P  (still, a --option seems a better idea)
14:52:53 <unsafePerformIO> rwbarton, shachaf: but when searching on google after ghc and loop, there was a problem from a inline rule in Control.Arrow, causing <<loop>>.
14:53:12 <shachaf> "> :t blah" and "> @type blah" are errors.
14:53:19 <papa_smurf> is it generally considered bad style to use a lot of language extensions ? (in my case there are 4)
14:53:21 <unsafePerformIO> so, maybe it could cause the problem?
14:53:23 <rwbarton> unsafePerformIO: Okay.
14:53:36 <shachaf> unsafePerformIO: Or maybe you just have a loop.
14:53:42 <unsafePerformIO> :)
14:53:43 <ddarius> unsafePerformIO: As shachaf said, it is vastly more likely that your code is incorrect than that you just happen to be hitting on this error.  Are you using Control.Arrow?
14:53:45 <shachaf> papa_smurf: 4 is a lot?
14:53:47 <rwbarton> We already told you the cause of the problem, this "<<loop>>" is not some mysterious, non-understood thing.
14:53:48 <carpi> donri: i know but when i do :t printLn in GHCi it does not autocomplete leading me to believe that it is not in scope
14:54:01 <donri> carpi: you probably mean putStrLn
14:54:36 <carpi> donri: i wish you sent that to me as pm. now im super embarrassed
14:54:40 <unsafePerformIO> but there is some mysterious things going on in my code...
14:54:40 <shachaf> rwbarton: Really? There are some astrophysicists that would like to talk to you.
14:54:44 <papa_smurf> shachaf: well for me at least.. up until just now i tried to use themas less as possible (but some of them are so damn cool)
14:54:44 <carpi> im glad lamdabot is not here though :P
14:54:58 <donri> carpi: why embarrased
14:55:05 <ddarius> unsafePerformIO: Probably not.
14:55:18 <unsafePerformIO> and it is definitely non-understood (for the moment)
14:55:43 <carpi> donri: just kidding. )
14:55:45 <benmachine> unsafePerformIO: that is an exception, so you can catch it from IO code, if that helps you track it down
14:55:54 <shachaf> unsafePerformIO: If you like, you can pretend that every time you see "<<loop>>" your program actually just doesn't terminate.
14:56:07 <benmachine> (but I wouldn't advise trying to catch it in general, fix the bug instead)
14:56:11 <rwbarton> It's unfortunate that the google results for ghc <<loop>> are not more helpful, though this is presumably because google ignores punctuation like <<>>
14:56:28 <unsafePerformIO> schachaf: I know.
14:57:07 <ion> Did you paste the code already?
14:57:44 <ddarius> Mood ring?
14:58:26 <lambdanaut_> carpi: what?
14:58:54 <carpi> lambdanaut_: so sorry. i meant to sent that message to lambdabot..
14:59:00 <lambdanaut_> carpi: Sorry. I was out grabbing pizza
14:59:02 <lambdanaut_> oh lol
14:59:11 <brinchj> is there a faster way to search through the cabal package names than cabal list ?
14:59:16 <ddarius> lambdanaut_ has just been so distant and cold recently.
14:59:27 <carpi> lol
14:59:33 <lambdanaut_> )': so sry
14:59:52 <Saizan> brinchj: the hackage website
15:00:03 <carpi> good night folks. tis bed time this side of the world
15:00:12 <Saizan> brinchj: hoogle and hayoo, also
15:00:17 <brinchj> Saizan, yeah well, no cli tool?
15:00:25 <brinchj> what's hayoo?
15:00:40 <Saizan> @where hayoo
15:00:54 <unsafePerformIO> I only see <<loop>> when compiled with "ghc --make Main.hs", never with "ghci Main.hs". Doesn't ghci throw the exception NonTerminating?
15:00:59 <Saizan> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:01:05 <shachaf> unsafePerformIO: Nope, ghci doesn't do it.
15:01:07 <brinchj> gonna check it out
15:01:13 <shachaf> You shouldn't rely on <<loop>>.
15:01:22 <ddarius> GHCi doesn't do blackholing.
15:02:08 <ddarius> Turn on the warning for shadowed variables, and I suspect that will point you right at the problem if you aren't intentionally trying to do knot tying things.
15:02:18 <ion> GHCi only does brownholing.
15:02:18 <unsafePerformIO> I don't rely on <<loop>>, but I try to understand my problem
15:02:19 <brinchj> do anyone know why cabal list is so slow in the first place?
15:05:54 <Peaker_> brinchj: my guess is the usual: People tend to be smart about in-memory data structures and dumb about in-disk data structures. So anything requiring a disk query is going to do way too much work
15:06:12 <Peaker_> (compatibility/simplicity trumps all concerns in on-disk formats, which IMO is a mistake)
15:08:53 <brinchj> Peaker_, but the index is only like 3000 entries..
15:09:04 <brinchj> Peaker_, the names could fit in ram
15:09:30 <brinchj> Peaker_, but your probably right
15:14:58 <Sgeo> @src (++)
15:15:10 <Sgeo> o.O
15:15:32 <mauke> preflex: seen lambdabot
15:15:32 <preflex>  lambdabot was last seen on #haskell 55 minutes and 23 seconds ago, saying:    arising from a use of...
15:23:50 <aristid> ^
15:24:13 <ddarius> >
15:25:08 <unsafePerformIO> rwbarton, shachaf, others: I found my problem :) I used the same names for variables on the left and right side in a "let" constructs. I wanted overshadowing, but got recursiveness. The idea of an inline-bug, come after a similar problem and solution found on google.
15:40:14 <adi12> hello :) can someone tell me how to capture a keypress from a gnome terminal (bash) in haskell please? I've searched on the internet and couldn't find something helpful.
15:41:10 <donri> adi12: curses, perhaps?
15:41:12 <kk`> adi12, you could find and use a binding to the curses library.
15:41:15 <mauke> getChar?
15:41:33 <ion> do hSetBuffering stdin NoBuffering; getChar
15:41:41 <benmachine> there is an hscurses
15:41:51 <akilll> ciao
15:42:02 <adi12> thank you :) I will try these things
15:42:11 <akilll> !list
15:42:43 <mauke> akilll: how did you get here?
15:42:46 <gio123> mauke: you are rude!
15:42:54 --- mode: ChanServ set +o mauke
15:42:54 --- mode: mauke set +b *!*@gateway/web/freenode/ip.193.137.156.144
15:42:58 --- kick: gio123 was kicked by mauke (begone)
15:43:40 <kk`> Looks like etiquette went completely out the window...
15:43:48 --- mode: mauke set -o mauke
15:44:18 <akilll> i don't now
15:44:38 <akilll> can i have a list?
15:44:43 <mauke> list of what?
15:44:49 <akilll> film
15:44:53 <benmachine> mauke: man, do you ban people just for calling you rude, or is something else afoot
15:45:04 <mauke> akilll: are there several people like you in italy?
15:45:08 <ion> benmachine: Yes, on the other channel.
15:45:15 <benmachine> ion: oh I see
15:45:16 <benmachine> okay
15:45:17 <irene-knapp> haha
15:45:17 <donri> akilll: this is not a dcc channel
15:45:27 <irene-knapp> gio123 was being annoying, yes, I can vouch
15:45:37 <mauke> because I've seen the whole *.it hostmask, "ciao", "!list" thing happen more than once
15:45:59 <Phyx-> lol, he's still pming me
15:45:59 <Phyx-> :/
15:46:07 <irene-knapp> see, I pretended I couldn't see his PMs
15:46:13 <donri> !list is used for piracy over irc via dcc bots
15:46:17 <irene-knapp> but yeah, he babbled on about nonsense in broken English until two people got frustrated and left the channel
15:46:21 <irene-knapp> then he asked why they left
15:46:27 <ion> mauke: Yeah, it’s curious how there seems to be a pattern like that. I don’t have a racist agenda, that just seems to be statistics. :-P
15:46:32 <mauke> benmachine: no, for being rude (telling people to "fuckk off"), then insulting my mother and sister, then complaining about rude people
15:46:34 <irene-knapp> and when it was explained that they didn't care for his company, he cursed at them
15:46:44 <benmachine> mauke: oh right, that sounds legitimate
15:46:47 <benmachine> continue
15:47:06 <irene-knapp> also, he's the one for whom we invented the "confluence rule"
15:47:10 <irene-knapp> ("confluence is off-topic")
15:47:10 <Quadrescence> the principle question is: can one insult another's sister without knowledge of them
15:47:22 <benmachine> Quadrescence: inaccurately, yes
15:47:33 <ion> The wiki software?
15:47:33 <irene-knapp> Quadrescence: You could have used the female pronoun there, since the gender of the sister is known :D
15:47:47 <irene-knapp> ion: nobody knows what he meant by it, but it seemed to be something mathematical which he couldn't explain
15:47:51 <Phyx-> lol, I lol'ed at how shapr left though
15:47:52 <mauke> ion: it's usually on mozilla/#firefox, though
15:48:07 <mauke> where it's common enough they have a bot that autokickbans for !list
15:48:19 <benmachine> irene-knapp: there are some sisters who prefer use of indeterminate pronouns, I'd hazard
15:48:32 <benmachine> (I don't know what they'd make of the term 'sister', but that's another story)
15:48:45 <irene-knapp> benmachine: wellll, there are definitely /people/ who prefer indeterminate pronouns, but they usually prefer nongendered words altogether
15:49:07 <irene-knapp> although if I were specifically informed that someone liked to be called "sister" but not "her", I would respect that, I don't think it's a common enough case to worry about preemptively
15:49:11 <u_> confluence is when terms in a rewriting system always reduce to the same thing regardless of what order you apply rewrites in
15:49:18 <Quadrescence> irene-knapp: are you telling me that:  sister : Female, and that my sentence resulted with Person t => t, and that we can resolve t to be Sister with hindley milner?
15:49:27 <benmachine> irene-knapp: but it's also not worth worrying the other way, I reckon :P
15:49:32 <irene-knapp> u_: well, sure, there are plenty of things he /could/ have meant
15:49:41 --- mode: ChanServ set +o mauke
15:49:42 --- mode: mauke set +b gio123!*@*
15:49:45 <irene-knapp> benmachine: I really don't like singular "they" though :) but yes, I was mostly being silly
15:50:00 <irene-knapp> Quadrescence: I wasn't telling you that in so many words, but that is nonetheless a correct explanation!
15:50:25 <benmachine> irene-knapp: http://www.qwantz.com/index.php?comic=2080
15:50:32 --- mode: mauke set -o mauke
15:50:32 <shapr> benmachine: gio123 returns every few months and starts talking like @keal
15:50:40 <benmachine> shapr: 'k
15:50:59 <shapr> In my opinion, there is no signal in his noise.
15:51:02 <irene-knapp> the thing is, yes, "they" has been used in the singular for a long time
15:51:11 <shapr> @keal
15:51:14 <irene-knapp> shapr: so malls couldn't track his shopping habits?
15:51:22 <shapr> irene-knapp: I don't think they'd want to do so.
15:51:23 <irene-knapp> but it has also been regarded as incorrect for most of that time
15:51:27 <irene-knapp> shapr: fair!
15:51:30 <ion> https://www.google.com/search?q=%22shklim%22+%22shkler%22+%22shklee%22
15:51:44 <irene-knapp> and besides, age alone is not what determines whether a usage should be resigned-to
15:52:23 <benmachine> irene-knapp: it's not /currently/ regarded as incorrect by e.g. the OED
15:52:31 <irene-knapp> benmachine: also irrelevant to me :D
15:52:33 <benmachine> (but anyway this is off-topic, so I will object no further)
15:52:38 <irene-knapp> haha okay
15:53:10 <Quadrescence> benmachine: add types to your sentences and it will be on topic
15:53:44 <Quadrescence> things of type   Topical t, Sentence t => t   are valid things to say
15:54:01 * benmachine unsafeCoerces all his ramblings
15:54:35 <Quadrescence> benmachine: classic mistake!
15:55:05 <benmachine> (did my part message show up? the joke doesn't work if my part message didn't show up)
15:55:11 <irene-knapp> haha
15:55:13 <irene-knapp> yes it did!
15:55:30 <benmachine> k, just checking >_>
15:56:44 <Quadrescence> (>_>) :: Emotion t => t -> Person -> t
15:57:16 <irene-knapp> heh
15:57:27 <irene-knapp> I'm not sure you want Emotion to be a typeclass
15:57:43 <irene-knapp> that implies that each possible emotion potentially has rich structure
15:58:17 <Quadrescence> irene-knapp: are you saying Love doesn't have rich structure distinct from, say, Aroused?
15:58:25 <irene-knapp> hmm
15:58:26 <irene-knapp> fair!
15:58:30 <Quadrescence> ;)
16:05:15 <dufflebunk> Does anyone have any examples of uses of Enum?
16:05:25 <mauke> > [1 .. 10]
16:05:36 <mauke>  [1,2,3,4,5,6,7,8,9,10]
16:05:44 <tauntaun> dufflebunk: fromEnum will let you convert a Char to an Int.
16:05:53 <tauntaun> (fwiw)
16:05:54 <benmachine> yeah, the Enum class underlies the whole .. syntax in lists
16:06:00 <dufflebunk> for data types
16:06:20 <mauke> Integer and Char are data types
16:06:38 <benmachine> data Day = Sunday | Monday | ... deriving Enum
16:06:43 <benmachine> week = [Sunday ..]
16:06:45 <benmachine> sorted
16:07:05 <ion> > (toEnum . fromEnum :: Float -> Rational) 42.5
16:07:18 <mauke> heresy, everyone knows the week starts with monday
16:07:19 <dufflebunk> So it's just a matter of derivinf enum, then you can use [x .. y] and you get the constructors?
16:07:32 <mauke> [minBound .. maxBound]
16:07:54 <mauke> ion:  42%1
16:07:58 <NemesisD> i'm tyring to define an instance of NFData from DeepSeq. for data Foo = Foo Int String, is this the correct definition: instance NFData Foo where rnf (Foo !a !b) = ()   ?
16:08:29 <ddarius> That should work.=
16:08:59 <liyang> Not for the String part.
16:09:45 <NemesisD> oh, well luckily in my actual code the type is more like Foo Int Double Double
16:10:42 <liyang> You'll need rnf (Foo !a b) = rnf b, but I'd probably write rnf (Foo a b) = rnf a `seq` rnf b
16:10:43 <ion> I suppose a generic definition would be something like rnf (Foo a b) = rnf a `seq` rnf b `seq` ()
16:10:52 <ion> Whoops, redundant `seq` ()
16:12:10 <ion> data … deriving (NFData), anyone? :-P
16:13:51 <ion> Another way to put it would be a `deepseq` b `deepseq` ()
16:14:19 <irene-knapp> no, that doesn't work for some reason
16:14:28 <irene-knapp> I tried it and it didn't terminate or something like that
16:14:33 <irene-knapp> I never quite figured out why
16:14:55 <ion> huh
16:14:59 <irene-knapp> yeah, it was weird
16:20:03 <irene-knapp> OH HEY
16:20:10 <irene-knapp> this ISN'T a GMP bug, it's a GHC bug!
16:20:41 <irene-knapp> GMP's low-level gcd function is documented to only work on inputs where the second, smaller number is odd
16:21:21 <benmachine> :O
16:21:25 <irene-knapp> we don't ensure that before calling it
16:21:29 <irene-knapp> okay, hmmm
16:21:34 <benmachine> that's weird
16:21:43 <benmachine> what if you want to find the gcd of even things
16:21:53 * ddarius makes a GCD that only works if the second, smaller number is coprime.
16:21:53 <irene-knapp> yes, indeed
16:21:57 <mauke> divide by 2
16:22:02 <benmachine> ddarius: hahah
16:22:45 <irene-knapp> but yeah, the thing is that I get different behavior when this is called from Haskell (it returns 0) and when it's called from C (it loops forever)
16:22:48 <irene-knapp> hmmm
16:22:53 * irene-knapp looks at the wrapper function inside integer-gmp again
16:24:52 <benmachine> irene-knapp: have you considered using integer-simple, ooi?
16:26:30 <irene-knapp> benmachine: well, I mean, that MIGHT solve my immediate problem, but actually I've uncovered evidence that an important optimization has been broken on all architectures for months and nobody noticed
16:27:00 <irene-knapp> the optimization masks this GCD bug on configurations where it still works
16:27:18 <benmachine> irene-knapp: sure, but it's always nice to have a working system with which to compare your broken one :P
16:27:32 <irene-knapp> well, but no, it won't work even if I do that
16:27:48 <irene-knapp> it fails a whole bunch of different tests, not just Integer-related ones
16:28:02 <benmachine> ...what are you even doing
16:28:12 <irene-knapp> nothing bad, I swear :D
16:28:21 <irene-knapp> just trying to build the freaking GHC HEAD on Lion, haha
16:28:34 <irene-knapp> there are two build-slaves running OS X but nobody seems to know whether they're Lion or not
16:28:39 <irene-knapp> (although one is 64-bit and one is 32-bit)
16:29:02 <irene-knapp> so it's quite possible that we're completely broken on Lion and just don't know it.  equally, it's possible that my machine has a duplicate library or a bad system library or some crap.
16:29:17 <akilll> ciao
16:42:52 --- mode: ChanServ set +o mauke
16:42:53 --- mode: mauke set -b *!*@gateway/web/freenode/ip.193.137.156.144
16:43:43 --- mode: mauke set -o mauke
16:45:23 <ddarius> irene-knapp: Just format the hard drive are reinstall.
16:46:17 <irene-knapp> ddarius: yeah, uh, no :)
16:47:48 <Jafet> Buy another Lion!
16:48:00 <irene-knapp> mm
16:48:03 <irene-knapp> not enthused about that either
16:52:18 --- mode: ChanServ set +o mauke
16:52:19 --- mode: mauke set +b *!*@gateway/web/freenode/ip.193.137.156.185
16:52:19 <ddarius> Buy a real lion and go of and have adventures and forget all this programming droll.
16:52:25 --- kick: asassasdw was kicked by mauke (ban evasion)
16:52:33 <irene-knapp> heh
16:52:35 <irene-knapp> that's an option
16:53:07 <Phyx-> ddarius: I think you can get one from mike tyson
16:53:15 --- mode: mauke set -o mauke
16:55:23 <Igloo> irene-knapp: Can you file a ticket with info about the odd argument thing please?
16:56:22 <irene-knapp> Igloo: oh, sure!  I was trying to reproduce the misbehavior from a C wrapper to make sure I wasn't insane, because I can't tell after staring at this twisty code for three weekends running, but yeah, I can file a ticket :)
17:12:03 <compactsubset> Hello; I have a question about Haddock (version 2.9.4). When I give it a module which exports some functions, I don't have to give type signatures for those functions; it uses GHC to infer the types and includes them in the doc. However, if I have it document everything, either by giving an empty export list or using --ignore-all-exports, it does *not* do that. In fact, it only documents functions for which I've given explicit types in the program.
17:12:54 <irene-knapp> compactsubset: interesting observation.  what's the question?  would you like it to not do that? :)
17:13:14 <compactsubset> :) I would like it to give types in both situations.
17:13:22 <irene-knapp> hmm
17:13:27 <irene-knapp> @hackage haddock
17:13:32 <irene-knapp> oh, no bot
17:13:44 <irene-knapp> ah hmm
17:13:49 <irene-knapp> http://hackage.haskell.org/package/haddock lists the maintainer
17:13:51 <compactsubset> It seems like a bug; the information is available in both cases.
17:14:05 <irene-knapp> I'm not aware that David Waern comes in here (and Simon Marlow's time is precious :) )
17:14:19 <irene-knapp> so I would email about it.  if you feel industrious you could dig into the haddock source and fix it and enclose a patch :)
17:14:53 <compactsubset> Yes, I'll bug him eventually; I just thought I'd check here first.
17:14:56 <irene-knapp> okay
17:15:19 <compactsubset> :) Yes, if all else fails I'll fix it myself.
17:15:24 <compactsubset> Thanks anyway!
17:15:39 <irene-knapp> okay! :)
17:16:05 <Saizan> it might just be  UI choice
17:24:50 <Phyx-> speaking of UI choices
17:25:47 <Phyx-> what are those _mini.htm files haddock generates
17:26:11 <thesus> Hey there, I'm pretty new to haskell and have a IMHO advanced problem. In the moment I have some functions passing a [[Int]] as state in the State.Monad around. I'd like to use STUArray for the [[Int]] as its elements change a lot, but I run into trouble splitting my code into separate functions, as I also have to keep (ST s (STUArray s (Int,Int) Int)
17:26:31 <thesus> any pointers to some tutorials?
17:26:55 <developernotes> I'm trying to get a better understanding of point free notation, can someone explain why this http://pastie.org/2931046 works, while this http://pastie.org/2931048 does not?
17:27:45 <ion> f $ x = f x, therefore length $ [1..10] = length [1..10]
17:28:00 <thesus> the problem is mostly that I try to use State.modify (f) where f takes a STUArray (Int,Int) Int and returns a (ST s (STUArray s (Int,Int) Int))
17:28:09 <ion> f . g = \x -> f (g x), therefore length . [1..10] = \x -> length ([1..10] x)
17:28:47 <Saizan> thesus: it doesn't really make much sense to use the State monad with a STUArray as state, since such an array is already mutable
17:28:50 <dmwit> thesus: You really shouldn't mix State and ST.
17:29:00 <Saizan> thesus: you've to work in the (ST s) monad
17:29:03 <developernotes> ion: got it - thanks!
17:29:25 <dmwit> developernotes: It's a bit odd to make a paste whose contents is shorter than its URL...
17:29:46 <ion> An arbitrary expression with (.) and ($) that does work is: length . show $ [1..10]
17:30:06 <ion> Expanding the $: (length . show) ([1..10])
17:30:10 <developernotes> dmwit: fair enough, just trying to keep code from littering the conversation.  :-)
17:30:17 <thesus> Saizan, dwwit: so you would suggest to only return a tuple from the functions? something like (ST s (STUArray ...), value)
17:30:18 <ion> Expanding the (.): (\x -> length (show x)) [1..10]
17:30:27 <ion> Expanding the lambda: length (show [1..10])
17:30:35 <dmwit> thesus: I would suggest you only return an ST action from the functions.
17:30:36 <Phyx-> alternatively, you could have put both in one pastie :P
17:30:55 <dmwit> ST s theTypeOfValueYouWantYourAlgorithmToFinallyProduce
17:31:16 <thesus> dmwit: ok, but where is the array then? Sorry, this really confuses me a lot
17:31:30 <dmwit> thesus: It's wrapped up in a closure.
17:31:46 <dmwit> thesus: Here's an example using an STRef (but STArrays are used similarly):
17:32:08 <dmwit> do { ref <- newSTRef; writeSTRef ref 0; writeSTRef ref 1; v <- readSTRef ref; return v }
17:32:10 <developernotes> ion: that was helpful - much appreciated!
17:32:57 <Phyx-> @pl map (\x -> guard (not $ null x) >> (return $ Outs (length x) (snd $ head x) (map fst x)))
17:32:59 <benmachine> thesus: maybe you could use ReaderT (STUArray s (Int,Int) Int) (ST s) a
17:33:05 <Phyx-> oops, where's botty
17:33:26 <thesus> dmwit: so the s in ST s theTypeOfValueYouWantYourAlgorithmToFinallyProduce keeps the full array?
17:34:16 <dmwit> thesus: The s in ST s blah is abstract. You never observe what it gets monomorphed to.
17:35:14 <dmwit> thesus: The question "What is the 's' in 'ST s'?" is orthogonal to the question "How do I use the ST monad?".
17:35:28 <Sgeo> :t newSTRef
17:35:49 <Sgeo> dmwit, I think you need a starting value for newSTRef, don't you?
17:35:57 <dmwit> Yes, probably.
17:37:05 <thesus> dmwit: this is what I thought. So ok, what you are saying is, that I should keep an STUArray in a function and do all the other crap within functions of this function that have access to the array .. (?)
17:37:38 <thesus> "within functions of this function" == "within functions defined in the scope of this function"
17:37:48 <dmwit> Yes, exactly.
17:38:44 <thesus> Thank you , this helps a lot. Though the code won't be very readable I'm afraid ...
17:38:55 <dmwit> We can help you improve readability, once you have something working.
17:39:01 <dmwit> If you like. =)
17:39:35 <benmachine> thesus: also my ReaderT idea
17:39:46 <benmachine> would work
17:40:08 <benmachine> the key is to realise that a value of type STUArray s ix a isn't really an array, it's more a reference to an array
17:40:10 <thesus> benmachine: I'll have some reading to do before that, I'm afraid
17:40:20 <benmachine> so unlike everything else in haskell, you don't actually have to return it to modify it
17:40:42 <benmachine> thesus: well, the non-transformers approach would be just writing functions MyArray -> ST s a
17:40:48 <thesus> dmwit: would be great :)
17:40:48 <benmachine> and then passing your array to them
17:40:57 <benmachine> ReaderT is just a way to make that convenient
17:45:57 <thesus> benmachine: What I know about Reader is that it allows you to pass additional paramters to functions, right?
17:46:15 <scooty-puff> is it possible to use syb, where the queries or transforms have additional type class contraints other than Typeable or Data?
17:46:41 <thesus> benmachine: ReaderT adds an additional context so that ReaderT  n m k -> n -> mk
17:46:55 <jessopher> speaking of CapitalSomethingT's, anyone know of a good intro to monad transformers?
17:47:14 <benmachine> thesus: ReaderT r m a is a newtype over r -> m a
17:47:35 <thesus> benmachine: this would mean that for the given  ReaderT (STUArray s (Int,Int) Int) (ST s) a, we could produce a (ST s a) ... hmmm, interesting
17:48:18 <thesus> banmachine: ok, I'll play with that
17:48:26 <thesus> thank you for your help, greatly appreciated
17:48:35 * ddarius endeavors to call benmachine banmachine from now on.
17:48:48 <benmachine> thesus: you could also define a function (ST s a -> ReaderT r (ST s) a) which might be helpful
17:49:02 <benmachine> (it's like liftIO but with ST instead)
17:49:14 <thesus> benmachine: ah, I see
17:49:31 <benmachine> actually I think that's just 'lift' with a specific type
17:49:33 <benmachine> but whatever
17:50:12 <benmachine> ddarius: I get called 'benchmachine' a lot for some reason
17:50:27 <benmachine> (also, my alternative nick is beanmachine)
17:53:38 <jessopher> what about a crappy introduction to monad transformers?
17:56:36 <mike-burns> jessopher: http://haskell.org/haskellwiki/Typeclassopedia#Monad_transformers - is a crappy introduction but a fantastic non-introduction. It's also part of the document I'm re-reading now.
17:58:05 <byorgey> needs a bit of updating but I hope to get to that soon
17:58:24 * jessopher has a look-see
17:58:30 <benmachine> haha I found this while I was looking http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
17:58:36 <mike-burns> Hah.
17:59:41 <benmachine> unfortunately (or possibly not) most of the links are dead
18:01:22 <erider> what is the difference between type and data when declaring a new type? -> Newbie question
18:01:49 <jessopher> type is just an alias for another type, data is a brand new type with its own constructors
18:03:19 <jessopher> type Foo = Bar, all bars are foos, and all foos are bars, data Foo = Bar. there are no bars, but Foo is a datum of type Foo
18:03:28 <donri> type String = [Char] can be used interchangeably with [Char]; data String = String [Char], can not
18:03:33 <jessopher> er bar
18:03:52 * Jafet foos jessopher with a bar.
18:03:54 <mauke> 'data' creates a new type; 'type' creates a new name for an existing type
18:04:09 * jessopher bows out
18:04:16 <erider> ah ok
18:04:37 <erider> thanks
18:04:42 <mike-burns> (Lesson hopefully learned: don't use "foo" and "bar" when you can use concrete examples!)
18:05:24 <jessopher> i think a small amount of headscratching is worth the ultimate goal of understanding
18:06:49 <jessopher> and explanation.
18:08:26 <irene-knapp> I do think the String/[Char] example is much clearer, and precisely because it's concrete
18:08:59 <irene-knapp> using placeholders forces the reader to keep their meanings in his head, which is fine when it's the only source of confusion and it's a reasonably capable reader...
18:09:26 <dmwit> It's doing something!
18:09:34 <irene-knapp> dmwit: what is?
18:09:50 <dmwit> my computer =)
18:09:56 <irene-knapp> great!  what is it doing?
18:10:49 <dmwit> Updating my GPS. Kind of off-topic... but I spent all day getting it to do it and had to gloat to *some*body. =P
18:11:16 <irene-knapp> ah, gotcha
18:11:19 <irene-knapp> yeah, I know the feeling!
18:11:27 <irene-knapp> you should reciprocate by going to read my bug report
18:11:30 <irene-knapp> http://hackage.haskell.org/trac/ghc/ticket/5663
18:11:45 <jessopher> i definitely think any explanation is clearer than my crappy one. I FooBar'd it in the first sentence
18:11:53 <irene-knapp> haha
18:12:09 <mauke> oh god underlinens
18:12:09 <irene-knapp> in particular read the long paragraph about 2/3 of the way down and FEEL MY PAIN
18:12:18 <irene-knapp> oops, bad formatting :/
18:12:21 <erider> either way I think I got it now thanks
18:12:23 <dmwit> second input must be odd
18:12:25 <dmwit> O_o
18:12:26 <ion> I wish i had a satellite system.
18:12:29 <irene-knapp> yeah I know, right dmwit!
18:12:43 <ion> A satellite would be one of the coolest places on which to run an IRC client.
18:12:58 <Jafet> That's what you deserve for using gmp internals.
18:12:58 <irene-knapp> that would be neat, yes.  although the latency would suck.
18:13:07 <irene-knapp> Jafet: but I didn't use them!  integer-gmp did :)
18:13:10 <ion> The coolness is pretty much a function of distance from Earth.
18:13:25 <irene-knapp> ion: hmmm
18:13:27 <Jafet> ion: put a satellite at the lagrange point opposite earth
18:14:12 <Jafet> irene-knapp: and you used GHC, which used integer-gmp!
18:14:19 <dmwit> "It comes up on my system when attempting to build the GHC haddocks, trying to compute a Rational approximation of pi."
18:14:22 <dmwit> oh god
18:14:30 <irene-knapp> yep.
18:15:35 <ion> pi % 1
18:16:09 <dmwit> irene-knapp: If I trigger the bug, what should I expect to happen?
18:16:21 <dmwit> (ghci just prints 2 here when I try the example gcd invocation)
18:16:28 <ion> Apart from the missiles being launched?
18:16:39 <irene-knapp> you should expect it to return 0
18:16:50 <irene-knapp> (if it happens in the construction of a Rational, it throws a div-by-zero exception)
18:17:05 <irene-knapp> try gcdInteger (3141592653589793238 * 1) (1 * 1000000000000000000)
18:17:34 <irene-knapp> the multiplications are only necessary when compiling; when interpreting, you should be able to get it with gcdInteger 3141592653589793238 1000000000000000000
18:18:07 <irene-knapp> gcdInteger is in GHC.Integer.GMP.Internals
18:18:47 <dmwit> I still get 2.
18:18:52 <irene-knapp> hmm
18:18:55 <irene-knapp> 64-bit system?
18:19:00 <dmwit> Perhaps it's already fixed in 7.3.20111114?
18:19:02 <dmwit> Yes, 64-bit.
18:19:18 <irene-knapp> I last pulled about eight hours ago
18:19:19 <irene-knapp> so I don't think so
18:19:23 <dmwit> okay =P
18:19:25 <irene-knapp> try this for me
18:19:45 <irene-knapp> I'm going to give you a short file through hpaste, along with the compilation flags for it; tell me what output it gives
18:19:52 <dmwit> alright
18:21:34 <hpaste> irene-knapp pasted “Try!” at http://hpaste.org/54585
18:22:34 <dmwit> um
18:22:40 <dmwit> Should that create some new files ore something?
18:23:06 <irene-knapp> no - the rule-dumping happens to stderr
18:23:11 <irene-knapp> (or stdout?  dunno)
18:23:12 <dmwit> ./test still prints 2, and the compilation stage itself only prints two lines (compiling, then linking).
18:23:24 <scooty-puff> if i wrap something in a data type containing an existential, and unwrap it in the same scope, will the compiler know the underlying type vars match up?
18:23:26 <irene-knapp> yeah, that's what I see too - no output
18:23:37 <irene-knapp> I dug deep in and confirmed that yes, the rules were NOT firing and therefore were not being printed
18:23:45 <dmwit> Oh, okay. =P
18:23:55 <dmwit> But, yeah, I'm getting 2 as the output of the program that's produced.
18:23:59 <irene-knapp> as I say, I believe the dictionary-functions-not-unfolded-across-modules issue applies to all architectures
18:24:06 <irene-knapp> which is separate from the gcd one but can mask it
18:24:06 <irene-knapp> hmmm
18:24:20 <Jafet> What is your gmp version?
18:24:21 <dmwit> (and I'm using libgmp-5.0.2, just like you)
18:24:25 <irene-knapp> 5.0.2
18:24:32 <parcs> scooty-puff: the same scope?
18:24:39 <Jafet> I think my system's still on gmp 3...
18:24:41 <dmwit> sorghum:~/programming% clyde -Qi gmp
18:24:44 <dmwit> Version        : 5.0.2-3
18:24:56 <irene-knapp> oh, you're not using in-tree gmp and I am, hmmmm
18:26:12 <irene-knapp> dmwit: what about "#I gcdInt# 0x2B992DDFA23249D6# 0xDE0B6B3A7640000#"?
18:26:23 <dmwit> What should I import?
18:26:23 <scooty-puff> parcs, i.e.: i am trying to hide a type var, HasLocation a => Stmt a to instead be Stmt SomeHasLocation, perform some syb generic operation, then unwrap back to HasLocation a => Stmt a, for the same "a"
18:26:25 <irene-knapp> (you'll need to import GHC.Types, GHC.Integer.GMP.Prim)
18:26:28 <irene-knapp> (possibly others)
18:26:31 <dmwit> (I assume -XMagicHash, too?)
18:26:36 <irene-knapp> (oh, and yes, -XMagicHash)
18:26:55 <ion> (Me, too)
18:27:04 <scooty-puff> (i have been having trouble creating a transform HasLocation => Stmt a -> Stmt a using mkT, etc.)
18:27:08 <irene-knapp> ion: are you testing too?  thanks!
18:27:22 <Jafet> (yeah, pass that magic hash)
18:27:27 <irene-knapp> heh, cool
18:27:31 <irene-knapp> er
18:27:32 <dmwit> irene-knapp: I get an error. When I switch #I to I#, I still get an error...
18:27:34 <irene-knapp> in my above command line
18:27:38 <irene-knapp> yes, it should be I# not #I
18:27:44 <irene-knapp> okay, what's the error?
18:27:45 <dmwit> More parens, around the gcd invocation, maybe?
18:27:49 <irene-knapp> oh, yes, oops :D
18:27:55 <dmwit> Okay, it prints 2.
18:28:00 <irene-knapp> I made that mistake like five times in my own testing, I dunno why I made it here too
18:28:03 <irene-knapp> wow, go figure!
18:28:08 <irene-knapp> what OS?  just for the record
18:28:13 <ion> Well, i did try it, but got a “Could not find module `GHC.Integer.GMP.Prim'”. I’m a bit busy with a DB-class exercise, so i didn’t look further.
18:28:18 <irene-knapp> ah, yes, okay
18:28:18 <dmwit> sorghum:~% uname -a
18:28:18 <dmwit> Linux sorghum 3.1.2-1-ARCH #1 SMP PREEMPT Tue Nov 22 09:17:56 CET 2011 x86_64 Intel(R) Core(TM)2 Quad CPU Q6600 @ 2.40GHz GenuineIntel GNU/Linux
18:28:28 <irene-knapp> hmmmm okay
18:28:41 <irene-knapp> similar CPU to mine
18:28:49 <irene-knapp> what does sorghum mean? :)
18:28:57 <dmwit> It's a kind of grass.
18:28:57 <ion> hostname
18:29:02 <irene-knapp> ah, cool
18:29:02 <dmwit> All my computers are named after grasses. =)
18:29:08 <irene-knapp> yes, I know, but I meant what was the name scheme
18:29:13 <irene-knapp> hehe interesting, what's the rationale?
18:29:13 <ion> sorry :-)
18:29:19 <tickle`> sorry to interrupt! is there a more lightweight way than printf to show a Double with only 3 digits after the decimal point?
18:29:29 <dmwit> I picked "buckwheat" on a whim, and then had to make a naming scheme that fit that. =P
18:29:31 <irene-knapp> tickle: yes, I think it's in Numeric or something?
18:29:33 <mauke> preflex: seen Cale
18:29:33 <preflex>  Cale was last seen on #haskell 5 hours, 25 minutes and 38 seconds ago, saying: http://i.qkme.me/35cwq6.jpg lol
18:29:35 <irene-knapp> haha okay!  cool
18:29:44 <mauke> tickle`: showFFloat?
18:29:52 <ion> I don’t think the problem with printf is the weight.
18:30:02 <Cale> tickle`: showFFloat
18:30:12 <tickle`> thanks!
18:30:16 <irene-knapp> gcc actually typechecks printf at compile-time.... sometimes
18:30:21 <ion> Mine are named after Pan Sonic songs.
18:30:22 <irene-knapp> so it's not inherently type-unsafe, haha
18:30:28 <dmwit> irene-knapp: Anyway, wow -- looks like you went quite deep into GHC internals.
18:30:30 <irene-knapp> but it has its problems, yes
18:30:33 <dmwit> I feel for you!
18:30:36 <irene-knapp> dmwit: yes, no kidding :/ thanks!
18:30:48 <irene-knapp> now I have to come up with a new theory for why it doesn't manifest for you!
18:30:50 <mauke> Cale: do you know where lambdabot has gone?
18:31:05 <irene-knapp> but at least the rules breakage is portable!  haha
18:31:35 <scooty-puff> meh, unsafeCoerce it is
18:31:53 <ion> irene-knapp: I suppose you could write a QuickCheck property to track down the issue. :-)
18:32:28 <irene-knapp> ion: whoa!  haha, that might at least bring some fun back into this
18:32:36 <irene-knapp> I'd have to learn QuickCheck though :)
18:32:47 <ion> Learning it is highly recommended.
18:32:58 <irene-knapp> yeah, I know it's a good concept
18:33:12 <irene-knapp> the automatic reduction of randomly-generated tests is really impressive
18:33:29 <irene-knapp> I just haven't had a good reason yet :)
18:35:56 <am17> hi
18:42:58 <NemesisD> anyone know whaat the deal is with aeson-native? its a separate package from aeson and no information on how it differs from aeson
18:43:47 <ddarius> It's a package put there to ensnare the overly curious.
18:47:01 <manjunaths> Is it possible to get access to the intermediate llvm byte-code in ghc ?
18:47:04 <manjunaths> f so how ?
18:47:09 <manjunaths> s/f/if
18:47:50 <ddarius> manjunaths: Check the GHC options, there should be one that will cause the bitcode file to stick around.
19:00:24 * ddarius thinks the movie "Seven Pounds" has music by Gustavo Santaolalla...
19:01:44 <gienah> NemesisD: aeson-native is a temporary hack that will very soon be deprecated and killed when the next version of yesod is released
19:02:24 <NemesisD> oh
19:03:02 <gienah> NemesisD: so of course the replacement is aeson. A nit though is bos made FastSet private, so snap had to copy paste FastSet for a future snap release
19:06:18 <deech> Hi all, Are there any examples on Hackage of creating Haskell bindings to C++ libraries?
19:06:49 <gienah> deech: wxWidgets, Qt (but Qt is not on hackage)
19:07:05 <Jafet> Mostly to C++ libraries that already have C bindings
19:07:08 <Jafet> And thus are C libraries
19:08:41 <deech> gienah: I'll check out wxWidgets then. I was hoping for a smaller example.
19:08:48 <gienah> deech: https://github.com/bos/double-conversion
19:10:15 <deech> gienah: Awesome, that guy can do everything.
19:12:58 <jessopher> is it safe to just remove your local .cabal directory if some library starts breaking stuff? I would assume since they are locally installed, ghc's awareness of local packages is also local, and probably in there as well.
19:13:51 <dropdrive> jessopher: There's a ~/.ghc directory as well...don't know what's in there...
19:13:51 <dmwit> You should also remove your .ghc directory if you do.
19:14:04 <Jafet> Perhaps you should just unregister the broken libraries.
19:14:05 <dmwit> Specifically, the package database in .ghc.
19:14:05 <jessopher> ah, alright
19:14:51 <irene-knapp> you might want to save ~/.cabal/config
19:14:53 <irene-knapp> as it has stuff
19:15:00 <Jafet> That double-conversion library also used a C interface to the library
19:17:01 <deech> Jafet: Yes, and it doesn't seem to wrap any of the class creation code. But its a good small example for me.
19:17:51 <Jafet> That's because the FFI currently only supports C
19:21:14 <jessopher> irene-knapp: good idea
19:22:00 <jessopher> is that not something that cabal will regenerate if absent?
19:22:50 <_pw_> Jafet: Do you mean C/C++ when you refer to C
19:23:56 <Jafet> What's C/C++?
19:24:40 <shachaf> Cale: Is lambdabot actually dead or is this just the result of some long-running netsplit or something?
19:25:03 <Cale> shachaf: I'll check
19:25:10 <ion> It’s equivalent to (C/C); C++ (as opposed to C/++C which is equivalent to ++C; (C/C)).
19:25:19 <Cale> actually dead
19:25:21 <shachaf> Jafet: It's a programming language (or, rather, an abbreviation for the language C/C++/COBOL).
19:25:48 <ion> > welcome
19:25:54 <lambdabot>   Not in scope: `welcome'
19:26:28 <shachaf> > tervetuloa
19:26:36 <lambdabot>   Not in scope: `tervetuloa'
19:27:06 <Jafet> @quote hello
19:27:14 <lambdabot> z0MB13 says: who can say hello to me as a md5 or decipher what kind of technique can be used to remove the password
19:27:26 <shachaf> @quote C/C++
19:27:34 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
19:27:43 <shachaf> @quote kmc C/C++
19:27:50 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
19:28:00 <ion> /Rexx
19:28:11 <irene-knapp> hahaha
19:28:18 <irene-knapp> that last one is good
19:28:40 <irene-knapp> jessopher: Cabal will regenerate its config file, but you'll lose any customizations you've made to it if it does
19:29:56 <jessopher> well that fine with me, if i cant build my stuff with a clean global install, then ive done something wrong anyhow
19:30:02 <irene-knapp> fair enough
19:34:26 * hackagebot highlighting-kate 0.3.1 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.3.1 (JohnMacFarlane)
19:43:48 <tim> ?
19:47:40 <shachaf> tim: I agree.
19:51:20 <tim> shachaf, it would appear that typing ? does not yield my irc client's help window.  Sorry.  :)
19:59:27 * hackagebot clientsession 0.7.3.5 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.3.5 (MichaelSnoyman)
19:59:29 * hackagebot web-encodings 0.3.0.8 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.8 (MichaelSnoyman)
20:21:43 <NemesisD> whats the "correct" way to make a lazy bytestring strict?
20:22:19 <shachaf> NemesisD: To turn it into a strict ByteString, you mean?
20:22:20 <NemesisD> concat . toChunks ?
20:22:24 <NemesisD> yes
20:22:36 <mauke> yes
20:50:58 --- mode: ChanServ set +o mauke
20:50:58 --- mode: mauke set -b+b *!*@gateway/web/freenode/ip.193.137.156.185 *!*@gateway/web/freenode/ip.193.137.156.*
20:51:48 --- mode: mauke set -o mauke
21:27:00 <scooty-puff> how horrible is it to take SomeConstraint a => MyStuff a
21:27:01 <scooty-puff> and turn it into
21:27:09 <scooty-puff> MyStuff SomeConstraint
21:27:36 <scooty-puff> err, MyConstraint a => MyStuff a to MyStuff SomeMyConstraint
21:27:47 <shachaf> You mean using an existential type?
21:27:57 <shachaf> Those are very different types.
21:28:09 <scooty-puff> yep, and to convert to it using the SomeMyConstraint, and back using Unsafe.Coerce.unsafeCoerce
21:28:25 <scooty-puff> problem is, i want to generically operate on HasLocation a => Stmt a
21:28:45 <scooty-puff> but i can't specify the constraint properly for the Data.Generics stuff
21:28:52 <shachaf> unsafeCoerce? :-(
21:29:07 <scooty-puff> yeah, its safe in this case i think (hpaste coming)
21:29:49 <hpaste> scooty-puff pasted “Good use of unsafeCoerce?” at http://hpaste.org/54587
21:30:20 <scooty-puff> renameM has type [Stmt a] -> m [Stmt a]
21:30:41 <shachaf> scooty-puff: What's the type of fromSomeHasLocation?
21:30:44 <Sgeo> :t tail
21:30:44 <scooty-puff> err, HasLocation a, various monad stuff m => [Stmt a] -> m [Stmt a]
21:30:44 <lambdabot> forall a. [a] -> [a]
21:30:51 <shachaf> That looks to me like the sort of thing you *really* want an explicit type signature on.
21:31:06 <scooty-puff> fromSomeHasLocation :: forall a. SomeHasLocation -> a
21:31:08 * shachaf can't quite tell what you're trying to do, but doubts that unsafeCoerce is the right answer.
21:31:40 <scooty-puff> the other option could be to add Typeable a to forall a. (HasLocation a, Typeable a) => SomeLocation a
21:31:46 <scooty-puff> so i can atleast do a checked cast
21:32:03 <Sgeo> take 5 $ zipWith (^) [2..] [0..]
21:32:08 <Sgeo> > take 5 $ zipWith (^) [2..] [0..]
21:32:08 <lambdabot>   [1,3,16,125,1296]
21:33:58 <rwbarton> SomeHasLocation is an existential type?
21:34:04 <scooty-puff> correct
21:34:20 <rwbarton> what would happen if renameM returned some SomeHasLocations that weren't of the type you expected
21:34:21 <scooty-puff> if there is another solution, i would definitely prefer that
21:34:26 <rwbarton> (rhetorical question)
21:34:26 <scooty-puff> bad stuff
21:34:37 <rwbarton> can't you use, like, type variables?
21:34:42 <scooty-puff> its all in the module, and changing such that the inner a is Typeable
21:34:42 <scooty-puff> i was
21:34:44 <scooty-puff> its Stmt a
21:34:53 <scooty-puff> but i need HasLocation a => Stmt a
21:34:58 <rwbarton> I mean in renameM.
21:35:08 <scooty-puff> and mkQ, extQ, ext1Q doesn't really work well with them..
21:35:15 <scooty-puff> (or i haven't figured out how to make them work anyways)
21:35:23 <scooty-puff> renameM's type is:
21:36:25 <scooty-puff> (MonadState S m, MonadWriter Message m, Data a) => a -> m a
21:36:58 <scooty-puff> (i had been explicit before - renameStmt, renameExpr, etc., but there are only a few expr's, stmt's i care about)
21:36:59 <scooty-puff> (var decls, fun decls, etc.)
21:37:48 <scooty-puff> (the type var "a" is a way to annotate each node of the syntax tree)
21:39:51 <rwbarton> what's wrong with just removing lines 6 and 9 of your paste?
21:40:14 <rwbarton> probably I can't understand that without knowing what renameM actually does
21:41:09 <rwbarton> is renameM looking for these SomeHasLocation constructors specifically?
21:41:41 <scooty-puff> sort of - let me post part of renameM
21:42:47 <scooty-puff> transformStmt can't have a constraint (outside of Typeable or Data) as far as i can tell
21:42:58 <hpaste> scooty-puff annotated “Good use of unsafeCoerce?” with “Good use of unsafeCoerce? (annotation)” at http://hpaste.org/54587#a54588
21:43:40 <scooty-puff> everywhereThisScopeM has same type as everywhereM
21:44:07 <scooty-puff> (the code isn't complete - missing FunDeclS, etc.)
21:44:31 <scooty-puff> (but it compiles as shown, though needs additional surrounding code, etc.)
21:45:51 <rwbarton> is that the only use of renameM?
21:46:06 <rwbarton> how about moving its definition into rename and using a scoped type variable to specify the type of transformStmt?
21:46:55 <scooty-puff> how do you do that? an explicit forall on the outermost scope, followed by ... on transformStmt?
21:47:52 <rwbarton> yeah, add "forall a." after "rename :: " and then just use a in the type of transformStmt, I think that should work
21:48:42 <scooty-puff> ok, thanks!
21:48:42 <rwbarton> though I'm vaguely uncomfortable about this
21:49:20 <scooty-puff> ok, may be time for bed, but will try out tomorrow
21:53:28 <hpaste> scooty-puff annotated “Good use of unsafeCoerce?” with “Good use of unsafeCoerce? (annotation) (annotation)” at http://hpaste.org/54587#a54590
21:53:36 <scooty-puff> is that about what you mean?
21:54:08 <rwbarton> you're not actually using line 10 are you?
21:54:15 <rwbarton> otherwise, I think yes
21:54:24 <scooty-puff> ok
21:55:03 <scooty-puff> it looks like it instantiating fresh type vars
21:55:14 <scooty-puff> has types m1, a1, etc.
21:55:23 <scooty-puff> do i need a special LANGUAGE pragma
21:55:24 <scooty-puff> ?
21:55:27 <rwbarton> yes
21:55:30 <rwbarton> ScopedTypeVariables
21:55:33 <scooty-puff> k
21:56:02 <scooty-puff> thanks, that did it
21:56:03 <scooty-puff> perfect
21:56:07 <scooty-puff> now to test, but it looks good
21:57:05 <prem_> hi
22:00:25 <NenaMala> HELLO
22:30:07 <ezyang> Is there a cute way to alloca four memory locations?
22:32:41 <ddarius> (,,,) <*> alloca <*> alloca <*> alloca <*> alloca (or liftM4/liftA4) ?
22:32:56 <ddarius> change the first <*> to a <$>.
22:33:27 <kfish> and change each <*> to print "nyan!"
22:34:03 <ezyang> whoo.
22:34:38 <ezyang> It's not obvious to me that this works.
22:35:22 <darkf> so someone explain to me why I want to use Haskell for a fairly complex program that requires I/O work? Why does Haskell restrict you to doing I/O from main? what is this magic?
22:35:22 <jessopher> well you never specified correct, only cute
22:35:39 <ezyang> Because alloca is a two arg fun.
22:35:51 <ddarius> ezyang: The "alloca"s were placeholders.
22:36:05 <ddarius> However, if you do want to pass the same thing to all of them, you can do it this way.
22:36:32 <c_wraith> darkf: why does C restrict you to programs named main?
22:36:55 <jessopher> darkf: and im not sure you should be asking us why you want to do something
22:36:58 <darkf> c_wraith: it does not, it only suggests that your program include a procedure to be called on entry
22:37:06 <ezyang> darkf: Haskell's a great imperative language.
22:37:11 <darkf> no it's a terrible one
22:37:18 <c_wraith> darkf: how do you think that's different from haskell?
22:37:21 <darkf> you can't even change variables
22:37:32 <ezyang> :t (,) <$> alloca <*> alloca
22:37:33 <lambdabot> Not in scope: `alloca'
22:37:33 <lambdabot> Not in scope: `alloca'
22:37:51 <c_wraith> ezyang: you could use allocaArray, maybe?
22:37:58 <blackdog> darkf: that's not true. you just have to annotate that you're changing variables. you can write haskell that looks like C if you want to.
22:38:18 <darkf> blackdog: show me some haskell that looks like C, then.
22:38:25 <blackdog> hell, just look at the shootout
22:38:25 <ddarius> Hah.
22:38:26 <ezyang> c_wraith: Each one has a different type
22:38:46 <ezyang> Actually, four of them are garbage pointers that I'm ignoring, but need to have around.
22:39:12 <c_wraith> ezyang: oh, well, that certainly messes it up.  I'm not aware of a simple pattern for composing multiple functions of that sort
22:39:22 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
22:39:29 <darkf> alright let's start with a better question
22:39:44 <darkf> Why would someone choose Haskell over a multi-paradigm language such as OCaml?
22:39:48 <ddarius> Haskell that looks like C ^
22:40:01 <c_wraith> darkf: are you jon harrop?
22:40:09 <ezyang> Yeah, so we want something like: ((a -> b) -> b) -> ((a2 -> b) -> b) -> (a1 -> a2 -> b) -> b
22:40:10 <ddarius> darkf: There is no reason.  In fact, C++ is even more multiparadigm, so I recommend it over O'Caml.
22:40:24 <darkf> c_wraith: no. are you a haskell lover?
22:40:30 <c_wraith> assembly is every-paradigm.  obviously.  you should use it.
22:40:50 <darkf> i do
22:40:55 <c_wraith> ezyang: It's not even clear to me if that can be generalized
22:40:56 <darkf> and i enjoy it more than haskell
22:41:02 <ddarius> darkf: Then you're set.  Carry on.
22:41:08 <ezyang> c_wraith: Yeah :^/
22:41:28 <darkf> but ocaml is also better than haskell
22:41:31 <darkf> why do you guys use haskell
22:41:36 <rwbarton> it's <*> for Cont b, isn't it
22:41:44 <kfish> yeah, ocaml is a cool language too
22:41:47 <augur> does haskell still allow the weird inference stuff that was mentioned in Type Inference Considered Harmful?
22:41:48 <jessopher>  because every troll has a bridge
22:41:48 <ddarius> darkf: Why do people use O'Caml, assembly is better.
22:42:25 <darkf> ddarius: because some people like type safety and less verbosity
22:42:33 <darkf> haskell is ugly though
22:42:44 <ezyang> rwbarton: Is it?
22:42:46 <augur> darkf: haskell is beautiful!
22:42:56 <ezyang> :t (<*>)
22:42:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:43:00 <jessopher> why do people use computers at all, I would rather write my programs in water in hydraulic gates
22:43:02 <ezyang> :t Cont
22:43:03 <lambdabot> Not in scope: data constructor `Cont'
22:43:03 <rwbarton> well, with a (un)curry thrown in perhaps
22:43:04 <ddarius> Assembly languages are the most type safe languages in existence.
22:43:08 <darkf> augur: lies!
22:43:17 <ddarius> jessopher: That would be cool.
22:43:18 <augur> darkf: i bet you like girls too
22:43:20 <augur> clearly you're insane
22:43:23 <ezyang> rwbarton: I don't think so...
22:43:24 <rwbarton> oh sorry, not (<*>), the other Applicative basis function that doesn't exist
22:43:26 <darkf> ehehe :3
22:43:30 <rwbarton> f a -> f b -> f (a, b)
22:43:31 <kfish> jessopher, i'm a fan of any computer you can drink
22:43:35 <ezyang> Ah.
22:43:39 <rwbarton> really more fundamental imo
22:43:43 <ezyang> @hoogle f a -> f b -> f (a, b)
22:43:43 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
22:43:43 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
22:43:43 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
22:43:47 <augur> dakrone: and if you dont like girls, come over and i'll make you like haskell
22:43:50 <jessopher> see, its even more pragmatic, you can drink it
22:43:53 <ddarius> :t liftA2 (,)
22:43:54 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
22:44:07 <darkf> see haskell is ugly
22:44:21 <c_wraith> any solution involving curry and uncurry should really be considered failing.
22:44:43 <rwbarton> well aren't you about to write a lambda as the last argument anyways?
22:44:46 <ezyang> OK, so let's see...
22:44:58 <augur> darkf: thats forgeous, what are you talking about
22:45:01 <augur> it makes perfect sense
22:45:04 <ddarius> ezyang: You can do hacks and make a variadic alloca so you can just do galloca $ \a b c d -> ...
22:45:22 <ezyang> Ah yes, the standard variadic trick. I guess that works
22:45:24 <rwbarton> @type alloca
22:45:24 <lambdabot> Not in scope: `alloca'
22:45:29 <rwbarton> @hoogle alloca
22:45:29 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
22:45:29 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:45:29 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:45:37 <augur> darkf: would you prefer generics?!
22:45:39 <rwbarton> are tuples not Storable if their components are?
22:45:59 <darkf> augur: spoilers: typeclasses are generics
22:46:06 <ddarius> rwbarton: That gives you one pointer to a tuple, not four pointers.
22:46:20 <augur> darkf: type classes are more interfaces, but i meant the syntax of it
22:46:24 <Nisstyre> darkf: type classes were invented before generics
22:46:25 <rwbarton> oh I see
22:46:27 <ezyang> darn! It seemed very close :%)
22:46:32 <darkf> Nisstyre: no u
22:47:05 <rwbarton> why are people talking to this person? Is this some in-joke I am missing?
22:47:16 <darkf> why are you talking to yourself
22:47:19 <jessopher> boredom i think
22:47:22 <jessopher> on both accounts
22:47:28 <augur> darkf: liftA2 (,) would have the type   F<Pair<A,B>> <A,B,F>(F<A>, F<B>) where F : Applicative
22:47:31 <Jafet> rwbarton: Cale effect
22:47:37 <augur> thats the closest i can imagine, and its not possible even then
22:48:18 <Cale> wat
22:48:32 <Cale> me effect?
22:48:36 <augur> Cale: angkor
22:48:46 <darkf> Cale: dick affect
22:48:51 <ddarius> augur: There are other wats.
22:48:55 <ezyang> Stay classy #haskell, stay classy.
22:49:00 <Cale> whoa whoa whoa
22:49:13 <augur> ddarius: some ethiopian foods are wots
22:49:22 <ezyang> OK, so I guess this is some weird polymorphism over variable contexts?
22:49:34 <ezyang> Not really...
22:50:43 <ddarius> ezyang: Think up a good solution for capturing the pattern in un/curryN and you will be set, I believe.
23:05:35 <hpaste> mauke pasted “galloca.hs” at http://hpaste.org/54591
23:07:20 <ezyang> nyerrr :^)
23:10:52 <mauke> http://codepad.org/SQl24iBa - now with "tests"
23:11:01 <mauke> i.e. it compiles; ship it
23:11:36 <Sgeo> GAlloca?
23:11:59 <mauke> the g stands for vararg
23:14:31 * hackagebot rex 0.3.1 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.3.1 (MichaelSloan)
23:35:50 <sordina2> Does anyone know how to get around the 'getAddrInfo: does not exist (error 10093)' error that comes up in httpEnumerator in windows when using simpleHTTP?
23:39:31 * hackagebot mime-mail 0.4 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.4 (MichaelSnoyman)
23:44:32 * hackagebot mime-mail-ses 0.0.0.4 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0.4 (MichaelSnoyman)
23:45:17 <ning> hello world haskell
