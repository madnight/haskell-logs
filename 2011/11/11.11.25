00:16:58 <augur> i just had the most amazing experience ever
00:17:00 <augur> i listened to satnam singh give a talk
00:17:50 <thoughtpolice> augur: what'd he talk about?
00:18:06 <augur> logic circuit design in a haskell edsl
00:18:10 <augur> but thats not what it was amazing
00:18:15 <augur> its because hes from glasgow
00:18:58 <augur> i didnt expect kevin bridges to be teaching me something about functional programming
00:20:10 <augur> because thats basically what it was
00:21:44 <thoughtpolice> lol
00:23:49 <flux> augur, so that would be writing haskell code that generates vhdl/system c/verilog?
00:24:38 <matthiasgorgens> Hi.  Are views fit for public consumptions?  The wiki page on views doesn't seem to tell which incantation you need to use to enable them with ghc.
00:25:16 <augur> flux: something like that.
00:25:39 <derrida> Could someone tell me, how do I compile a binary from some hs code for a 32-bit architecture from my 64-bit arch machine (linux)?
00:25:47 <flux> augur, well, did it appear like an effective approach?-)
00:25:53 <augur> dunno!
00:25:57 <augur> i got lost in his accent :p
00:26:00 <augur> no it looked cool
00:26:25 <flux> vhdl itself is quite nice already, but I guess it could be quite a bit less verbose
00:29:22 <thoughtpolice> matthiasgorgens: hi, what do you refer to when you say 'view'? can you link to the wiki page?
00:30:14 <thoughtpolice> derrida: GHC unfortunately does not have an equivalent of gcc's '-m32' flag or whatnot. a 64bit GHC can only generate 64bit code. but if you have appropriate 32bit libraries on your machine, you can install a 32bit version of ghc (perhaps somewhere special, like ~/ghc32) and then use that
00:30:49 <thoughtpolice> i.e. you need 2 installed versions, one 32bit and one 64bit. cross compilation support is not really there at the moment, unfortunately
00:31:16 <matthiasgorgens> thoughtpolice: I meant view patterns.
00:31:30 <matthiasgorgens> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
00:31:39 <thoughtpolice> matthiasgorgens: oh. well yes they've been in GHC for a while now
00:31:48 <thoughtpolice> you can enable them by giving GHC the option '-XViewPatterns'
00:31:52 <matthiasgorgens> thanks!
00:31:58 <thoughtpolice> or you can put the following line in your .hs file:
00:32:04 <thoughtpolice> {-# LANGUAGE ViewPatterns #-}
00:32:08 <derrida> thoughtpolice: thank you.
00:32:10 <thoughtpolice> (at the top)
00:32:14 <thoughtpolice> derrida: np
00:34:19 <Eduard_Munteanu> I wonder how GHC gets ported to other platforms.
00:34:42 <Eduard_Munteanu> It seems to me true cross-compiling would help there.
00:34:55 <thoughtpolice> it's not a fun process
00:35:18 <thoughtpolice> and roughly boils down to 'happens on an ad hoc, needs to happen basis'
00:35:49 <thoughtpolice> Igloo has removed a TON of the #ifdef-ery in the compiler recently however, which is the first step on the road to making GHC a better cross compiler
00:36:19 <augur> why is polymorphic recursion naughty?
00:36:24 <Blkt> good morning everyone
00:36:29 <matthiasgorgens> thoughtpolice: Thanks.  Yes, I now about the language pragma.  I just wasn't smart enough to just try and see if the extension is just named `ViewPatterns".  I was somehow thinking about the name "views" only.
00:37:47 <thoughtpolice> matthiasgorgens: ah, np
00:37:59 <augur> oh type checking is undecidable
00:38:00 <augur> i see
00:38:16 <DevHC^> what's the first GHC version supporting hs-boot files?
00:40:30 <fr4nk> hi there :)
00:40:40 <fr4nk> i am using ghci with prelude
00:40:54 <thoughtpolice> DevHC^: a very old one, it's been supported at least as far back as I can remember doing haskell (ghc 6.4/6.6, which was released like 5+ years ago)
00:41:08 <fr4nk> i am having a script which uses "isLower" from the Char Module
00:41:21 <geekosaur> Data.Char these days
00:41:28 <fr4nk> but if i want to load the script, it says 'isLower' not in scope
00:41:37 <fr4nk> but on cmd using isLower is no Problem
00:41:59 <fr4nk> how i can use 'isLower' in Script COntext?
00:42:08 <geekosaur> see above
00:43:00 <fr4nk> :m Data.Char
00:43:06 <fr4nk> :l script.hs
00:43:10 <fr4nk> not in scope
00:43:11 <geekosaur> technically theChar module shouldn;t work unless you've specified haskell98 mode
00:43:56 <fr4nk> how i specify haskel98 mode? o.O
00:44:00 <nejucomo> Is there no way to define new types in ghci?
00:44:00 <thoughtpolice> fr4nk: you need to say 'import Data.Char' inside script.hs. if you want to make the module available in ghci, you need to say ':m+ Data.Char' - or alternatively say 'import Data.Char'
00:44:12 <geekosaur> you need to use + there, I think, or the :m will get wiped
00:44:27 <thoughtpolice> nejucomo: not with any released GHC and it's known this is a large limitation. GHC 7.4 will allow you to do so however
00:44:34 <thoughtpolice> and is slated to be released pretty soon
00:44:41 <nejucomo> Nice.
00:45:02 <thoughtpolice> and it also comes with about a million other awesome features, but yes the better REPL is a big improvement :)
00:45:09 <nejucomo> Ok, a more direct question:  I have a value of a type that has no Show instance.  Is there any quick hack to display the value?
00:45:53 <thoughtpolice> nejucomo: if there's no direct reason it can't have a Show instance, and it was just omitted, you can use the standalone deriving module to derive a Show instance outside of the place it was defined
00:46:44 <thoughtpolice> er, it's not a module, sorry. it's a language extension :)
00:47:01 <zhulikas> @hoogle IO [Char] -> IO ()
00:47:02 <lambdabot> Prelude putStr :: String -> IO ()
00:47:02 <lambdabot> System.IO putStr :: String -> IO ()
00:47:02 <lambdabot> Prelude putStrLn :: String -> IO ()
00:47:20 <thoughtpolice> e.g. if you have a 'data Foo = Bar | Baz deriving Eq' somewhere (i.e. no 'Show' instance,) you can say 'deriving instance Foo Show' somewhere completely different, and it will magically create an instance for you, which you can then use.
00:47:47 <geekosaur> if you want to force haskell98 mode I think it's :set -Xhaskell98
00:47:54 <thoughtpolice> if the Show was not just omitted but isn't automatically derived for a reason, you'll have to write your own instance i'm afraid
00:49:01 <Eduard_Munteanu> The reason for that could only be some things that datatype references don't have Show instances, I guess.
00:49:29 <fr4nk> thoughtpolice: i get an error "parse error on input `import' " :/
00:49:39 <Eduard_Munteanu> You could provide even dummy instance for those.
00:49:43 <Eduard_Munteanu> *instances
00:50:21 <nejucomo> thoughtpolice: Thanks, but I assume "deriving instance Foo Show" won't work in ghci.
00:50:29 <geekosaur> where are you putting that?  (if it's at the ghci prompt, then your ghc installation is old and you need to use :m +...)
00:50:46 <nejucomo> Also, in this case, there's no reason Foo isn't showable, because it's members are all Bools.
00:51:06 <lianjiao> anyone knonws how to load a FFI in *.o in GHCi?
00:51:51 <thoughtpolice> fr4nk: where is the import? did you give it in GHCi, or is it in the script.hs file yourself?
00:52:22 <fr4nk> it is in the script file
00:52:23 <thoughtpolice> nejucomo: ah yes it won't. you'll have to wait for that. you can of course pull a quick stop gap measure by just having a simple .hs file with only that deriving clause in it, and then loading that and using it
00:52:36 <thoughtpolice> fr4nk: ok, can you paste your code on http://hpaste.org so we can look?
00:52:41 <fr4nk> on command line i can use :m+ Char an it loads the module and isLower is available
00:52:42 <thoughtpolice> much easier than grasping at straws
00:52:52 <lianjiao> thoughtpolice: I want to load a .hs in GHCi, but this file use a FFI
00:53:22 <lianjiao> thoughtpolice: sorry, sent wrongly
00:53:26 <nejucomo> thoughtpolice: I just wrote a showFoo function for now in ghci.
00:53:29 <hpaste> Fr4nk pasted “import fails” at http://hpaste.org/54481
00:53:37 <fr4nk> http://hpaste.org/54481
00:53:38 <fr4nk> :)
00:53:46 <thoughtpolice> nejucomo: ah ok
00:54:07 <DevHC^> oh look
00:54:10 <DevHC^> GHC sp4m:
00:54:11 <DevHC^> SpecConstr
00:54:11 <DevHC^>     Function `f{v aKLA} [lid]'
00:54:11 <DevHC^>       has six call patterns, but the limit is 3
00:54:11 <DevHC^>     Use -fspec-constr-count=n to set the bound
00:54:11 <DevHC^>     Use -dppr-debug to see specialisations
00:54:18 <DevHC^> uhm, wtfbbq?
00:54:28 <fr4nk> main problem is still that isLower not exists in script context :-/
00:54:48 <c_wraith> @hoogle isLower
00:54:49 <lambdabot> Data.Char isLower :: Char -> Bool
00:54:53 <thoughtpolice> fr4nk: hm, seems to work fine here! i can load that file just dandy. can you paste the whole context of the error, e.g. the ghci session/terminal output
00:54:55 <c_wraith> do you have Data.Char imported?
00:55:13 <c_wraith> oh, wait, you're loading in ghci?
00:55:19 <thoughtpolice> DevHC^: it's a known (annoying) issue that was presumably left in a release as a mistake. it is fixed as of recent versions
00:55:20 <c_wraith> are you loading compiled code, instead of interpreting?
00:55:23 <c_wraith> that would do it
00:55:31 <hpaste> Fr4nk pasted “import fails” at http://hpaste.org/54482
00:55:39 <hpaste> zhulikas pasted “y u work” at http://hpaste.org/54483
00:55:45 <zhulikas> somebody please explain me why
00:56:11 <c_wraith> fr4nk: why is it saying the problem is on line 191?
00:56:11 <zhulikas> why can I return IO () if function type is IO [Char]
00:56:25 <c_wraith> fr4nk: all imports must be at the top of amodule
00:56:59 <DevHC^> zhulikas: u r misunderstanding what "return" means
00:57:05 <fr4nk> my script is a collection of some code
00:57:14 <zhulikas> return is a -> IO a, isn't it?
00:57:18 <c_wraith> fr4nk: you can't just concatentate haskell source files
00:57:27 <zhulikas> @hoogle return
00:57:28 <lambdabot> Prelude return :: Monad m => a -> m a
00:57:28 <fr4nk> zomfg
00:57:29 <lambdabot> Control.Monad return :: Monad m => a -> m a
00:57:29 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
00:57:37 <DevHC^> return does not mean to stop the "function execution" and yield a value for ur function
00:57:44 <fr4nk> importing the module at the top of the files solves the problem
00:57:46 <c_wraith> DevHC^: that's not the problem
00:57:59 <fr4nk> thx everybody!! :) .)
00:58:03 <nejucomo> I don't understand this error when attempting to load a module in ghci: http://codepad.org/sLqLlpTM
00:58:09 <DevHC^> w8 wat
00:58:15 <thoughtpolice> zhulikas: when you say 'return "test" :: IO [Char]' the annotation refers to the entire expression, if that's what you mean
00:58:19 <DevHC^> c_wraith: misread D:
00:58:26 <zhulikas> thoughtpolice, that's just to make things clear
00:58:33 <nejucomo> Does this mean I don't have "base" installed, or do I need to pass the -package flag when I start ghci?
00:58:34 <zhulikas> as I understand, return "test" is a function result
00:58:38 <c_wraith> zhulikas: it works because that desugars to main = putStrLn "y u work" >> return "test"
00:58:44 <c_wraith> :t (>>)
00:58:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
00:59:01 <c_wraith> as you can see, it doesn't care what the value of a is, there
00:59:08 <c_wraith> so it's fine if a is ()
00:59:46 <zhulikas> also how can some lines be printed if my function didn't return yet?
00:59:58 <zhulikas> if last statement in my function is a call to same function
01:00:01 <geekosaur> that is laziness
01:00:24 <zhulikas> I thought function is executed only in main
01:00:33 <zhulikas> and until then it's values are just combined
01:00:50 <c_wraith> zhulikas: be more precise.  in haskell, functions aren't executed.  functions are evaluated.  IO actions are executed.
01:00:50 <zhulikas> but it seems that with "do" I can write stuff whenever I want and keep executing my function afterwards
01:01:10 <thoughtpolice> nejucomo: base is always installed. that error is a rather unfortunate consequence of some strangeness resulting from GHC evolving to fit the haskell 2010 standard (if i remember correctly.) you can just say '-package haskell2010' at the moment to make it work
01:01:21 <thoughtpolice> nejucomo: alternatively, inside GHCi you can say ':set -package haskell2010'
01:01:25 <geekosaur> nejucomo:  the real problem is you, like many other people, misspelled "marshal" (one l)
01:01:25 <thoughtpolice> (so you don't lose your working context)
01:01:43 <thoughtpolice> oh, geekosaur is right
01:01:48 <thoughtpolice> carry on, forget my silliness above
01:01:49 <zhulikas> geekosaur, so you say because of laziness my function goes to "main" more than one time?
01:01:55 <nejucomo> thoughtpolice: Thanks!  Not restarting ghci saves a lot of headache.
01:02:07 <zhulikas> it goes each time I want to putStrLn and then goes when I return function result?
01:02:08 * thoughtpolice shakes head
01:02:19 <geekosaur> why it says that particular message is because there are two "near misses", one in "base" which is kinda the language HEAD and one in "haskell2010" which is a specific language standard
01:02:32 <nejucomo> geekosaur: Thanks even more.  ;-)
01:02:39 <Eduard_Munteanu> zhulikas: main isn't special in anyway
01:02:52 <c_wraith> zhulikas: no.  you're creating an IO action that says "first print this, then return that".  when that IO action is *executed*, it does those things in that order.
01:02:52 <Eduard_Munteanu> Just that it's the program entry point.
01:03:06 <thoughtpolice> on that note, it is wonderful that GHC gives you recommendations on misspelled identifiers these days
01:03:27 <geekosaur> zhulikas, putStrLn is a side effect; it doesn't pass something back to main to be printed
01:03:41 <zhulikas> wat
01:03:57 <zhulikas> so it has nothing to do with a function result?
01:04:01 <zhulikas> damn, I don't get it
01:04:05 <geekosaur> that's much of the point of IO; since IO is a side effect it needs to be isolated from pure code
01:05:09 <nejucomo> heh...
01:05:14 <zhulikas> hmm
01:05:22 <geekosaur> main is not an IO action because things need to be returned from it to be output, but because it is being flagged as side-effect-ful
01:05:42 <nejucomo> Um...  If I do:  { ptr <- malloc 42; free ptr } I get a type error.
01:05:47 <Eduard_Munteanu> zhulikas: one way you can think of this is, instead, the runtime executes the action 'main' whatever it happens to be. If main calls some other function in IO, that function doesn't simply pass stuff back or anything. But 'main' will reference that action.
01:05:57 <geekosaur> (interestingly, you seem to be thinking in terms of pre-monadic I/O as used in very early Haskell)
01:06:13 <shachaf> nejucomo: What do you expect to get, given the type of malloc?
01:06:29 <erus`> main returns an IO action... i thought...
01:06:49 <Eduard_Munteanu> main is an IO action :)
01:06:52 <shachaf> erus`: No, main doesn't return anything. It *is* an IO action.
01:07:12 <DevHC^> shachaf: which return () :P
01:07:16 <DevHC^> +s
01:07:19 <nejucomo> Oh, no, I confused it's type because I actually did: { let ptr = malloc 42; free ptr; }
01:07:47 <shachaf> DevHC^: Not really. At least, this is a completely different sense of the word "return" from the normal one.
01:07:54 <thoughtpolice> shachaf!
01:07:55 <Eduard_Munteanu> That's like falling through the end brace of a 'void' C function.
01:07:58 <nejucomo> (and every time I asked ghci to show it to me, it implicitly allocated another buffer... ! )
01:07:59 <shachaf> nejucomo: OK, but it still won't work.
01:08:01 <DevHC^> shachaf: the n word is retarded
01:08:03 <shachaf> thoughtpolice!
01:08:04 <zhulikas> so by side-effects you mean that those are not executed in main?
01:08:14 <thoughtpolice> shachaf: once again the exclamation points line up
01:08:21 <shachaf> It's an omen.
01:08:25 <nejucomo> schachaf: It *appears* to have worked, no type error.
01:08:40 <shachaf> nejucomo: do { x <- malloc 42; free x }?
01:08:48 <Eduard_Munteanu> zhulikas: what do you mean by 'executed in main'? IO actions are executed by the runtime.
01:08:50 <geekosaur> no, they happen *immediately*.  putStrLn does output immediately and produces () as a result
01:08:55 <shachaf> nejucomo: The normal "malloc" doesn't get an argument.
01:08:56 <zhulikas> <geekosaur> zhulikas, putStrLn is a side effect; it doesn't pass something back to main to be printed
01:09:11 <zhulikas> this is nearest to something I could understand
01:09:17 <erus`> as soon as my codebase reaches 300 lines of haskell i have to refactor and start again. I will never finish a project :(
01:09:41 <nejucomo> Sorry again, I'm transcribing ghci lines into irc and mistakenly mangling them (I'm sleepy).
01:09:56 <zhulikas> so putStrLn is passed somewhere else?
01:09:57 <nejucomo> I meant:  "ptr <- mallocBytes 42\nfree ptr"
01:09:58 <zhulikas> where?
01:10:08 <shachaf> nejucomo: Ah. Sure, that'll work.
01:10:11 <Eduard_Munteanu> zhulikas: think your program is a todo list for the runtime. It says 'do main'. Now 'main' could itself be 'do putStrLn and some other stuff' etc.
01:10:36 <zhulikas> no, I think of main as "Do just this."
01:10:50 <zhulikas> like main = result
01:10:52 <zhulikas> that's it
01:10:58 <zhulikas> if it was pure functional
01:11:08 <geekosaur> but it's *not* pure, it's in IO]
01:11:11 <shachaf> zhulikas: What?
01:11:11 <Eduard_Munteanu> Hm, what do you mean?
01:11:12 <nejucomo> zhulikas: I'm not certain, but I expect the side effect gets executed each time the expression is evaluated.
01:11:35 <Eduard_Munteanu> Pure functional means there's a clear-cut separation between side effects and pure computations, not that the former are impossible.
01:11:38 <zhulikas> nejucomo, I would like someone to confirm what you say
01:11:45 <geekosaur> that's what the IO designation means, it is impure and does things that are not part of the visible state (in this case, producing output)
01:12:23 <flux> well, you could implement everything IO does with an impure runtime, and IO could be a pure continuation-based action-generation framework?
01:12:25 <Eduard_Munteanu> nejucomo: nope.
01:12:38 <zhulikas> damn :D
01:12:43 <Eduard_Munteanu> Execution is totally separated from evaluation.
01:12:56 <flux> so if IO happens somehow in an impure fashion, it is due to optimizations, but it doesn't affect reasoning
01:13:08 <geekosaur> (more to the point, IO arranegs for plumbing that insures that IO actions occur in the order you specify instead of when the runtime decides it needs that value at some point)
01:14:00 <jessopher> its an expression of a computation. you express the computation in haskell, a magical IO fair compute it
01:14:20 <jessopher> no need for haskell existentialism, its a fairy
01:14:33 * shachaf pulls out good ol' data IO = PutChar Char IO | GetChar (Char -> IO) | Exit
01:14:55 <geekosaur> go back to Miranda's [Request] -> [Response]? :)
01:14:57 <Eduard_Munteanu> Yeah, go ahead.
01:15:00 <shachaf> That's the reasonable way to figure out what IO is (to the extent anyone can do that).
01:15:13 <shachaf> geekosaur: [Response] -> [Request], rather.
01:15:18 <geekosaur> hm, right
01:15:26 <shachaf> geekosaur: And the two are equivalent but the one I mentioned is rather easier to reason about.
01:15:30 <geekosaur> always invert those, they make my head hurt
01:15:34 <geekosaur> yes
01:15:49 <shachaf> geekosaur: It depends on your perspective. The Haskell program is making the Requests. :-)
01:16:00 <geekosaur> (every time you get overwhelmed by monads, remember that IO is an *improvement* over how it used to be done!)
01:16:29 <shachaf> geekosaur: IO in Haskell isn't fundamentally a monad or anything. It's just made that way as a convenience.
01:16:32 <nejucomo> When specifically do IO side-effects occur in GHC compiled programs?
01:16:38 <shachaf> @google site:r6.ca monad io
01:16:39 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
01:16:39 <lambdabot> Title: I/O is not a monad
01:16:56 <shachaf> nejucomo: What sort of answer are you expecting for that question?
01:17:14 <shachaf> When the program starts, the RTS executes the IO action "main".
01:17:26 <shachaf> In the course of executing this action, it might need to execute other IO actions.
01:18:59 <thoughtpolice> nejucomo: the RTS starts by executing main, which is an IO action. because everything is lazy in haskell, things are evaluated when needed. IO really enforces data dependencies, and thus sequentialization, between separate actions. when you say main = do { putStrLn "hi"; getLine } there is an implicit dependency between the putStrLn and the getLine, to make sure they happen in order
01:19:16 <shachaf> thoughtpolice: It doesn't really have to do with laziness, does it?
01:19:23 <shachaf> You could make it work just as well in a strict language.
01:19:50 <geekosaur> it's more that because laziness exists, some means needs to exist to *defeat* laziness for I/O to behave sensibly
01:20:06 <shachaf> geekosaur: That's not completely true either.
01:20:35 <shachaf> Functions (as opposed to procedures, i.e., referentially transparent, with no side effects) are a nice thing to have independent of laziness.
01:21:23 <Eduard_Munteanu> Even in a strict language you'd have some sort of notion of dependencies, in case you want to optimize and, e.g. reorder various things.
01:21:32 <thoughtpolice> shachaf: oh sure, you can have a pure, strict language which uses monads for I/O-ish stuff (like ur.) the laziness tidbit i suppose was more of a side note to drive the overall point
01:22:01 <shachaf> thoughtpolice: The idea of separating execution from evaluation is much more general than monads.
01:22:39 <shachaf> You can look at foo :: String as a program where "executing" it means "printing it out to stdout".
01:22:42 <lianjiao> how to load plain object files in the GHCi interactive command line?
01:23:01 <shachaf> And then have main :: String, and that would be a perfectly valid "pure language that supports output".
01:23:41 <shachaf> A more expressive "pure language that supports only output" would be main :: [Action]; data Action = Stdout String | Stderr String | Exit ExitCode | DrawPixel Pos Color | ...
01:23:56 <nejucomo> thoughtpolice: So I understand how Monad is used to enforce data dependencies and sequencing requirements...
01:23:59 <shachaf> And so on.
01:24:25 <shachaf> "Monad" is just used for convenience, as mentioned in roconnor's post.
01:24:37 <nejucomo> I suppose my question is, if I write main = putStrLn "foo", what does the stack look like when write is called.
01:24:49 * thoughtpolice will read that post when he isn't incredibly sleepy
01:24:57 <shachaf> nejucomo: The GHC "stack" is very different from stacks in most other languages.
01:25:04 <DevHC^> what if i have {-# LANGUAGE Safe #-} as the first line of the program, and the rest from an untrusted source? is that secure? or can the untrusted source whoop me in the ass with something like {-# LANGUAGE NoSafe #-}?
01:25:10 <nejucomo> shachaf: I also understand a bit of this.
01:25:16 <silver> nejucomo, stack? reduction graph?
01:25:19 <shachaf> nejucomo: You should read about the general evaluation model for Haskell programs to understand that properly.
01:26:12 <nejucomo> Hrm...  My question is not about general evaluation, it's specifically about side effects.  Which part of graph reduction results in a system call to do IO?
01:26:32 <shachaf> nejucomo: The RTS when it encounters an IO value.
01:26:48 * nejucomo opens the rts source code in emacs.
01:26:50 <thoughtpolice> as far as simon has explained it, there really isn't a fundamental difference between GHC's runtime stack and say, the C stack, actually. the stack in GHC is just set up so you can identify pointers to the heap without ambiguity, etc
01:26:58 <shachaf> nejucomo: Or are you talking about GHC's specific (# RealWord, a #) implementation?
01:27:07 <jessopher> DevHC^: that would be less safe than Safe not even being an extension, so i hope not
01:27:11 <thoughtpolice> but that's about as far as the simliarities go, because the evaluation model is different of course
01:27:43 <thoughtpolice> (simon explained this somewhere on either reddit or SO, if i remember correctly)
01:27:44 <shachaf> thoughtpolice: Well, there *is* a stack, yes, but you can't expect to find the same sort of thing on it.
01:28:09 <Eduard_Munteanu> Mm, I don't think you can add LANGUAGE pragmas anywhere but at the top of your program, no? IIRC.
01:28:54 <thoughtpolice> Eduard_Munteanu: you can, but GHC reparses the whole file when it encounters a LANGUAGE pragma
01:29:33 <nejucomo> shachaf: I'm interested in GHC's specific implementation.
01:29:56 <DevHC^> ...soooo?
01:30:02 <jessopher> i think its a non-issue. Safe in the 'assumed' safe module holds for its extent, even if some dependency disables or simply omits the extension
01:30:03 <nejucomo> It sounds like I need to read about graph reduction more.  So far I've not read anything about graph reduction that mentions side effects.
01:30:38 <shachaf> thoughtpolice: Can you have a pragma which is written in such a way that upon reparsing, it won't be encountered as a pragma anymore? :-)
01:31:22 <geekosaur> so, in GHC, IO is (ST RealWorld#), a state monad with some type trickery to protect the state from being arbitrarily accessed.  this state is sort of a baton passed between I/O actions to force a data dependency between them so they happen in the proper order
01:32:36 <shachaf> nejucomo: Well, in general (not in GHC's specific implementation), graph reduction has nothing to do with side effects in itself. That's the job of the RTS when it executes an IO action, not of whatever is doing evaluation.
01:32:41 <DevHC^> uhm, can anyone with access to a GHC 7.2.1 compiler test this? :>
01:32:45 <nejucomo> For example, I read this a while ago, but I don't recall any mention of how IO side-effects occur during graph reduction: https://en.wikibooks.org/wiki/Haskell/Graph_reduction
01:33:29 <shachaf> nejucomo: In general we treat that abstractly as the job of the RTS.
01:33:41 <shachaf> It has nothing to do with evaluating a value, conceptually.
01:34:35 <geekosaur> DevHC^, I think there's a known pathological case, namely LANGUAGE CPP
01:34:44 <geekosaur> you can go digging in GHC's Trac :)
01:34:53 <nejucomo> shachaf: Ok.  What's the relationship between the RTS and evaluation?  Is the RTS the ultimate consumer of evaluation?
01:35:42 <pierrc> as far as i concern, atomic function of IO monad are nodes in the graph, the side effect is carried out when the node is reached
01:35:59 <shachaf> The RTS does a lot of things. Among them is evaluating values and also executing IO actions.
01:36:18 <shachaf> But once again I'm giving a general conceptual answer, not a "how GHC does it" answer. :-)
01:36:27 <thoughtpolice> DevHC^: a module compiled in Safe mode is only valid if its imports all come from trustworthy/safe packages AND the packages it imports are marked trusted. if you are compiling arbitrary code in 'Safe' mode, that code can't import anything you haven't trusted anyway. so you basically can't turn the safety off from there
01:36:29 <shachaf> You'll probably have to read GHC sources/documentation for that.
01:36:32 <thoughtpolice> shachaf: good question!
01:37:01 <pierrc> the book "Implementation of functional programming " could help a lot
01:37:02 <shachaf> Huh, in ghc-prim/GHC/Types.hs: "data [] a = [] | a : [a] deriving Generic"
01:37:31 <shachaf> nejucomo: The STG paper might be a good one to read.
01:37:45 <shachaf> @google spineless tagless g-machine pdf
01:37:47 <lambdabot> http://www.ncc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
01:37:47 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
01:37:53 <thoughtpolice> safety is enforced with a notion of trust at the module/package level for SH. the design of makes it so an arbitrary - potentially untrusted - module cannot turn safety off
01:38:04 <frerich> There was a non-proprietary (but unfinished) reimplementation of Shake somewhere, does anybody remember the URL?
01:38:07 <thoughtpolice> NB: the design of safe haskell is changing a lot in 7.4.1. consider it a work in progress
01:38:10 <shachaf> frerich: openshake?
01:38:17 <thoughtpolice> frerich: https://github.com/batterseapower/openshake
01:38:25 <frerich> Ah, right! Openshake, d'oh!
01:39:08 <nejucomo> shachaf: Ah, excellent.  I had that on my to-find reading list, but after a quick search hadn't found it.
01:39:25 <pierrc> starting with G-machine with a spine, rather than spineless, can be easier
01:39:45 <nejucomo> pierrc: Your answer sounds closer to what I was expecting.
01:40:38 <pierrc> I read a few chapter of "implementation of functional programming languages", it illustrate how to do graph reducation
01:40:49 <pierrc> with G-machine with a spine
01:41:06 <jessopher> from the documentation, safe haskell is a concerted effort to stop people from practicing magic
01:41:32 <pierrc> sadly, I know nothing about spineless tagless G-machine...
01:43:40 <DevHC^> thoughtpolice: wat? so CAN arbitrary text mangle with {-# LANGUAGE Safe #-}?
01:46:32 <lpsmith> Ok,  an IOException records all kinds of extra data,  but there doesn't seem to be any sane way to capture that data.
01:47:21 <thoughtpolice> DevHC^: no, my point is that an arbitrary module you compile can't turn the safety off, if it's specified to be compiled in Safe mode. if it could, how could safe haskell work at all?
01:47:57 <DevHC^> the question is: does {-# LANGUAGE Safe #-} forcefully specify Safe mode?
01:48:06 <jessopher> yes
01:48:07 <thoughtpolice> if some module could just say "no, forget that, i'll be as unsafe as i want", what would be the point in the first place? there may be pathological cases concerning CPP as someone mentioned
01:48:11 <thoughtpolice> DevHC^: yes
01:48:17 <DevHC^> (the examples in the GHC documentation all contain "module X where" as the 2nd line)
01:49:28 <thoughtpolice> that's because generally like i said it's meant to be enforced at the granularity of packages and modules themselves. the idea is you take an entire untrusted module. sure, you can splice things into it - but you can't turn the safety off *within that module*
01:49:33 <DevHC^> can one write {-# LANGUAGE EmptyDataDecls #-} {-# LANGUAGE NoEmptyDataDecls #-} ?
01:49:37 <lpsmith> like,  I want to use System.Posix.getFileStatus and do something special if the file doesn't exist.   But how can I distinguish an IOException that was raised because the file doesn't exist,  or it was raised because I don't have permissions,  for example?
01:50:08 <jessopher> the module itself is assumed not to contain pragmas in it later that would remove the Safe extension
01:50:51 <thoughtpolice> again if you could turn safety off within the *untrusted module being compiled* then the whole notion of safe haskell would be broken - because any untrusted module you compiled in safe mode could say "just trust me, bro!"
01:51:05 <jessopher> if you cant even trust the importing module, no amount of safety will save you
01:51:44 <shachaf> {-# LANGAUGE BroTrust #-}
01:51:51 <jessopher> lol
01:52:05 <thoughtpolice> yes, hence the 2-stage process of needing to trust the package entirely and the need for the modules that any unsafe things import to be either trustworty, or safe itself
01:52:19 <jessopher> {-# LANGUAGE NoShootFoot #-}
01:52:43 <fr4nk> hi there :) me again :D
01:53:18 <DevHC^> thoughtpolice: that's not what Safe Haskell is about, according to the documentation
01:53:54 <fr4nk> can i pipe a txt file into a function as a parameter? myfunc < my.txt ?
01:53:57 <DevHC^> safe haskell is about systematically ensuring that unsafe things be safe, provided that they compile successfully with the Safe extension
01:54:10 <fr4nk> using ghci with prelude
01:54:34 <DevHC^> fr4nk: readFile "trollme.txt" >>= putStr . myFunc
01:56:44 <thoughtpolice> DevHC^: ok, how is that in conflict with what i said? the point is that untrusted modules you compile can't turn the Safe mode off themselves during compilation. allowing that would be broken. furthermore there is a notion of package trust because otherwise any module could just say its Trustworthy despite what it does, and that's basically the same thing
01:57:22 <thoughtpolice> because then a module compiled under -XSafe can just import the thing which said it's Trustworthy, and do whatever it wants. the package exposing that trustworthy module must also be trusted
01:59:30 <jessopher> when did haskell modules become so dishonest? all this in-fighting
01:59:55 <DevHC^> meh, whatever
01:59:59 <thoughtpolice> the TL;DR is that 1) yes, -XSafe forces it to be compiled in safe mode, so all imported modules must A) be from trusted packages and B) be Trustworthy or Safe themselves. 2) no, a package compiled under -XSafe *cannot* turn that off
02:00:03 <DevHC^> to be concrete, i have these:
02:00:38 <thoughtpolice> s/a package compiled under/a module compiled under/
02:00:41 <DevHC^> W.hs: {-# LANGUAGE Safe #-} <insert_untrusted_content_here>
02:01:13 <DevHC^> W.hs-boot: certain exports from W.hs, written by me, not an untrusted source
02:01:32 <DevHC^> H.hs: my other stuff, can be included by W.hs
02:01:46 <DevHC^> is that safe?
02:01:52 <DevHC^> secure, i mean
02:01:57 <jessopher> safe doesnt state safety, it invokes the requirement to verify safety
02:02:20 <jessopher> so if the module lies to you, it doesnt compile
02:02:55 <DevHC^> and let's say that by definition Prelude is safe, and nothing else is. in ghc-pkg, Prelude is a trusted package, and nothing else is.
02:03:12 <jessopher> ok
02:03:53 <DevHC^> or is it the "base" package or whatever..
02:05:06 <DevHC^> compilation: ghc --make -O2 -no-hs-main -fPIC -shared H.hs W.hs -o LoadMe.so
02:06:49 <DevHC^> question1: can W.hs use unsafePerformIO that H.hs executes? (ie., can W.hs use {-# LANGUAGE NoSafe #-} ; x = unsafePerformIO $ ...?)
02:07:32 <DevHC^> question2: can W.hs export functions via FFI, potentially creating linking issues or some sort of symbol-clash attacks?
02:07:54 * geekosaur just realized what bugged him about the 7.2.2 release, "all packages are trusted by default" --- one would think that GHC.IO.Unsafe should be *un*trusted by default...
02:08:23 <thoughtpolice> geekosaur: even if the package is trusted, the module must also be marked Trustworthy. GHC.IO.Unsafe is likely not marked Trustworthy, so Safe things cannot import it
02:08:42 <thoughtpolice> the package trust note is the important bit there
02:09:45 <geekosaur> "All packages are now trusted by default. If you wish to make use
02:09:46 <geekosaur>   of Safe Haskell, you will need to manually untrust packages that
02:09:49 <geekosaur>   you do not wish to trust."
02:10:02 <geekosaur> argh, that didn't paste as I intended...
02:10:28 <thoughtpolice> DevHC^: Q1: no. first off there is no 'NoSafe' pragma, because allowing it in an untrusted module would of course be broken by design. H.hs can use unsafePerformIO, provided it is trustworthy. but W.hs cannot. as for Q2, Safe Haskell restricts all FFI declarations to use IO, if i remember correctly (so you can't sneak a side effect into a pure function.) i am not sure about exports
02:10:29 <geekosaur> quoted from http://www.haskell.org/pipermail/glasgow-haskell-users/2011-November/021227.html
02:11:15 <thoughtpolice> geekosaur: yes, but if GHC.IO.Unsafe is not Trustworthy, then a Safe program cannot important. the 2 step process here is the important part. so the question is then: is GHC.IO.Unsafe marked as Trustworthy? i suspect not
02:11:22 <thoughtpolice> s/important/import it/
02:11:39 <thoughtpolice> you have to trust the package *and* the module has to either be Safe, or Trustworthy. that's the crucial bit
02:11:42 <thoughtpolice> it can't be one or the other
02:13:50 <dafis> geekosaur: having everything untrusted by default means almost nothing builds out of the box, in particular not GHC
02:15:02 <thoughtpolice> if it was one or the other, the design of SH would be broken like i said: if you whole-sale trust a package with no further questions, then you can just import System.IO.Unsafe. if you just blindly trust modules, then a module can lie and say it's Trustworthy and that's exposed to potentially unsafe code, when it's really a lie
02:16:06 <thoughtpolice> and reviewing that last sentence, it is clear i need to go to sleep. so i must bow out
02:16:24 <jessopher> lol
02:17:32 <ski> geekosaur : `putStrLn s' isn't side-effectful, it's just plain effectful (no "side")
02:18:07 <jessopher> the wording should be changed to Moral Haskell, and you should beable to mark modules heretics and devote
02:18:23 <ski> (and it's effectful in the same way that `StateT (\s -> Just (42,s+1))' and `[1,2,3]' are effectful)
02:18:25 * dafis is always a heretic
02:18:45 <jessopher> Holy Haskell even
02:19:03 <thoughtpolice> more like Bro Haskell, where you need to have BroTrust
02:19:18 <jessopher> yeah, that seems more pc
02:19:29 <thoughtpolice> but ok, for real this time. /me --away
02:19:36 <dafis> night
02:19:50 <rtharper> @src concatMap
02:19:50 <lambdabot> concatMap f = foldr ((++) . f) []
02:21:28 <dafis> DevHC^: multiple personalities?
02:22:01 <jessopher> Judgemental Haskell {-# LANGUAGE Innocent #-} {-# LANGUAGE Filth #-}
02:23:13 <DevHC_> dafis: uhm no?
02:24:03 <geekosaur> ski: can you let go of the pedantic lambda calculus long enough to answer the original question?  you just led right back to "so where does putStrLn send the output?" with no possible answer because that can't be represented in the world you evoked
02:24:05 <jessopher> but that extension wouldnt enforce any kind of safety, it would just filter swear words, and help you to dissociate your modules from other modules that do
02:24:43 <DevHC_> {-# LANGUAGE NoTroll #-} -- note: XTroll is enabled by default
02:24:48 <ski> geekosaur : sorry, i missed the question
02:25:22 <jessopher> yeah i think im getting carried away
02:26:07 <ski> geekosaur : the system interprets your `putStrLn s' action -- i suppose you can compare this with your processor interpreting the machine code -- you have to start somewhere
02:26:21 <geekosaur> zhulikas at 09:17 UTC ff.
02:26:57 <geekosaur> he was either using the pre-monadic I/O model or got tied up in the world where actions not representable inside the program don't exist
02:27:09 <geekosaur> (or she)
02:28:28 <ski> geekosaur : my point re "side-effect" vs. "effect" is that a "side-effect" is something that a computation does that's not declared in the interface/type. because there the type of `getLine' e.g. is `IO String' instead of `String', it's not a side-effect, since it's part of the returned value (i.e. the action)
02:28:54 <geekosaur> but my network is now failing every 60 seconds or so, so I'm bowing out :(
02:29:33 <geekosaur> <ski> (and it's effectful in the same way that `StateT (\s -> Just (42,s+1))' and `[1,2,3]' are effectful)
02:29:50 <ski> yes ?
02:29:58 <geekosaur> leaves no room for putStrLn's effect, we're back to "so where does it go?"  those effects are *inside* the program...
02:30:24 <geekosaur> putStrLn's effect is *outside*
02:30:25 <ski> who passes the state `s' to `StateT (\s -> Just (42,s+1))' ?
02:30:40 <ski> if we go back to a simpler I/O model we get
02:30:46 <ski>   main :: String -> String
02:31:05 <ski> `main' being a function from `stdin' to `stdout'
02:31:14 <ski> who provides the `stdin' to the program ?
02:31:23 <ski> where does the result go ?
02:31:49 <zhulikas> :)
02:32:01 <augur> ski: what did you think?
02:33:08 <augur> obviously its still incomplete in some areas
02:33:11 <augur> especially in the last section
02:34:15 <ski> augur : i'm some pages in, and starting to get sleepy (not due to the paper, though :)
02:34:26 <augur> :p
02:35:15 <zhulikas> so IO is like stdin stdout?
02:35:47 <zhulikas> I'll try finding some articles online on side-effects
02:35:55 <zhulikas> and get back afterwards if still will have questions
02:36:32 <ski> yes, you can think of it (to a first approximation) as a transformer from stdin to stdout (together with some value)
02:37:03 <ski> well, the first refinement of the above is
02:37:19 <zhulikas> and that would explain why it is called 'side'
02:37:20 <ski>   main :: [Response] -> [Request]
02:37:38 <ski> well, it's not *side*-effects, here
02:38:40 <ski> it's side-effects if we had `getLine :: String' (or maybe `getLine :: () -> String') that whenever it was evaluated (or called) secretly did some I/O
02:39:18 <augur> ski: i still want your opinion tho!
02:39:19 <augur> :p
02:39:24 <ski> in that case, `let x = getLine () in (x,x)' wouldn't be the same as `(getLine (),getLine ())', which is bad, since then equational reasoning doesn't work
02:41:14 <ski> but, because we have `getLine :: IO ()', there is no problem with `do x <- getLine; return (x,x)' (i.e. `getLine >>= (\x -> return (x,x))') being different from `do x0 <- getLine; x1 <- getLine; return (x0,x1)' (i.e. `getLine >>= (\x0 -> getLine >>= (\x1 -> return (x0,x1)))')
02:41:45 <ski> (the former would represent an I/O computation that reads one line, the latter would represent one that reads two lines)
02:43:10 <ski> also, there's no problem with `let x = getLine in (x,x)' vs. `(getLine,getLine)' -- these two *are* equal (they are the same pair of unexecuted action values) -- and this is because `getLine' doesn't have a *side*-effect anymore, it doesn't do any effect when *evaluated*
02:43:30 * ski doesn't know whether this makes any sense to zhulikas
03:48:20 * hackagebot OpenCL 1.0.2.4 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.2.4 (LuisCabellos)
03:48:38 <statusfailed> What's the diff between liftM and fmap other than one's on monads and the other on functors?
03:49:12 <jessopher> @src liftM
03:49:13 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:49:20 <jessopher> @src fmap
03:49:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:49:29 <jessopher> doh
03:50:06 <geekosaur> no difference
03:51:10 <statusfailed> oh ok
03:51:12 <statusfailed> coolbeans
03:51:35 <geekosaur> (and fmap doesn't show up there because it's part of the Functor class, so you need to name an instance)
03:51:53 <jessopher> that makes sense
04:18:49 <Jafet> :t liftM `asTypeOf` fmap
04:18:50 <lambdabot> forall a1 r (m :: * -> *). (Monad m, Functor m) => (a1 -> r) -> m a1 -> m r
04:22:27 <leod> :t asTypeOf
04:22:28 <lambdabot> forall a. a -> a -> a
04:22:40 <leod> @src asTypeOf
04:22:41 <lambdabot> asTypeOf = const
04:35:06 <ion> Is this right for showing parentheses correctly? (It *seems* to be.) instancec Show Foo where showsPrec n foo = showParen (n > 10) $ showString "Foo " . showsPrec 11 (someField foo)
04:40:40 <jpcooper> hello
04:41:02 <jpcooper> I seem to remember an implementation of the S combinator in some class. Does anyone have any suggestions as to where it is?
04:42:19 <jpcooper> that is, a function of type (a -> b -> c) -> (a -> b) -> c
04:42:55 <flux> @hoogle (a -> b -> c) -> (a -> b) -> c
04:42:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:42:55 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:42:56 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:42:58 <erus`> what does it do?
04:43:32 <jpcooper> aah yes Applicative for ((->) a)
04:45:03 <jpcooper> S f g x = f x (g x)
04:46:09 <jpcooper> erus`: http://coder.bsimmons.name/blog/2011/01/do-applicative-functors-generalize-the-s-k-combinators/
04:53:23 * hackagebot atto-lisp 0.2.1 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.2.1 (ThomasSchilling)
04:59:49 <KitB> invalid heap profile option "-hT"?
05:03:23 <HugoDaniel> is there anyway to specify in my module that it should be loaded with -fcontext-stack=40 ?
05:03:55 <KitB> {-# OPTIONS_GHC ... #-}
05:03:58 <KitB> ?
05:06:34 <HugoDaniel> yes yes
05:06:36 <HugoDaniel> thanks :D
05:07:11 <KitB> No problem
05:09:55 <KitB> Does anyone know what happened to the -hT option?
05:15:47 <Beerdude26> Hi, I have a question concerning creating a cabal package
05:16:24 <Beerdude26> When I try to do 'runhaskell Setup build', I get Setup: can't find source for Perms\Check in ., dist\build\autogen
05:16:35 <etpace> hmm.. I'm trying to build an expression parser (using buildExpressionparser http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Expr.html) - But I'd like my binops to have "whitespace" for function applications (like haskell). I can put function application as bottom precedence and the parser works, but then application has the wrong precedence, any idas how to build it correctly?
05:16:43 <Beerdude26> But the relevant code seems to be in the correct in the correct position
05:16:48 <Beerdude26> woops
05:17:10 <Beerdude26> That should have been "But the relevant code seems to be in the correct position", of course.
05:45:10 <zenzike> does anybody have ghc-mod configured for emacs? I'm trying to use it, but I keep getting "ghc-mod not found". I'm fairly new to emacs, but I *think* it should be in the load-path
06:28:32 * hackagebot reactive-banana-wx 0.4.3.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.3.1 (HeinrichApfelmus)
06:54:10 <Faucelme> Hi, I have a question about "let...in" expressions. Sometimes I see thay they appear without the "..in..". Can the "in" be omitted in every case?
06:54:21 <ski> no
06:54:39 <Faucelme> In which cases can the "in" be omitted?
06:54:49 <ski> they can only be ommitted, when occuring as commands/clauses is `do'-blocks, and in list comprehensions
06:55:11 <ski> (also, they can be omitted in GHCi, but that's not the language, proper)
06:55:47 <statusfailed> why is there a forM_ but no forM?
06:55:55 <ski> @undo do let {x = 2; f y = x + y * z}; more x f
06:55:56 <Faucelme> Ah, I understand, thanks.
06:55:56 <lambdabot> let { x = 2; f y = x + y * z} in more x f
06:55:58 <statusfailed> I take that back...
06:56:14 <ski> @undo do let {x = 2; f y = x + y * z}; y <- bar f x; more x y
06:56:14 <lambdabot> let { x = 2; f y = x + y * z} in bar f x >>= \ y -> more x y
06:56:30 <ski> @undo [more x y | let {x = 2; f y = x + y * z},  y <- bar f x]
06:56:31 <lambdabot> let { x = 2; f y = x + y * z} in concatMap (\ y -> [more x y]) bar f x
07:00:52 <savask> Hello. I've read that if you import a module and use only some functions from it, others still get linked. Why? Is there a special reason for that?
07:08:43 <adastra> where can i find info about how Int is defined?
07:09:25 <Lycurgus> haskel98 specs?
07:09:39 <Lycurgus> ghc sources?
07:09:46 <Lycurgus> prelude?
07:10:43 <carpi> Thankx -= )
07:10:57 * benmachine waves
07:12:15 <byorgey> carpi: what do you mean by "how Int is defined"?
07:12:25 <byorgey> what do you want to know about Int?  Or are you just curious?
07:12:50 <byorgey> hiya benmachine
07:14:50 <carpi> byorgey: im curious because in "Learn you a haskell" in the chapter about types and type classes.. they give an example of how the bool type is defined. And then they give an example of how the Int type is defined. But it also mentions that when definied a type you should mentioned all possible values the type can have. For bool its only True or False .. so I was wondering how Int for example would have been defined in Haskell.. whether they specified all 4 
07:16:54 <byorgey> carpi: ah, excellent question.  No, the Int type is somewhat magical.
07:17:04 <benmachine> carpi: I think your message got cut off there?
07:17:06 <carpi> i know its silly to think they would have specified all 4 billions values.. but curious none the less )
07:17:10 <benmachine> I only got "whether they specified all 4"
07:17:31 <int-e> @hoogle uncurry3
07:17:31 <lambdabot> No results found
07:17:35 <carpi> oh .. "whether they specified all 4 billion values or did it in some other way"
07:17:37 <byorgey> carpi: you can see the definition here: http://hackage.haskell.org/packages/archive/ghc-prim/0.2.0.0/doc/html/src/GHC-Types.html#Int
07:17:40 <Saizan> savask: depends on how the object files got built, making each function into its own object file takes much more time when linking your program later, so it's done only for the core libs by default iirc
07:17:45 <byorgey> carpi: it's defined as  Int = I# Int#
07:17:58 <byorgey> carpi: and Int# is just a special built-in machine-sized int value
07:18:58 <savask> Saizan: Ah. So it's possible to force such kind of optimization?
07:19:11 <byorgey> carpi: in other words, Bool could (in theory) be defined in a library, but Int has to have special compiler support.
07:20:14 <Saizan> savask: yeah, with --enable-split-objs when you build the modules
07:20:29 <savask> Saizan: Thanks.
07:20:38 <carpi> so some of the basic datatype still need to be defined outside haskell's own type system?
07:20:45 <savask> byorgey: Why "has"? Maybe Int can be defined as a list of Bools, or something like that.
07:20:53 <byorgey> carpi: right.
07:21:25 <byorgey> savask: well, yes, good point.  I suppose I should say "if you want reasonable performance, Int has to have special compiler support".
07:22:11 <byorgey> carpi: Integer, Float, Double, and Char are also special.
07:22:12 * benmachine appears to be reading the haddock for recursion-schemes
07:22:22 <byorgey> benmachine: fun =)
07:23:02 <benmachine> where is the function that does exactly the thing I want to do :(
07:23:06 <benmachine> why aren't there more functions like that
07:23:30 <carpi> byorgey: and i suppose arrays as well..yes?
07:24:05 <carpi> because last night i was thinking that it would be impossible to implement some data structures inside haskells type system
07:24:06 <byorgey> carpi: yes
07:25:14 <byorgey> carpi: well, actually, I think arrays in particular do not have special compiler support, but their implementation uses special things provided by the compiler
07:25:33 * benmachine decides ana (\x -> case divMod x 10 of _ | x == 0 -> Nil; (q,r) -> Cons r q) is what he needs, and goes about trying to pointfree it
07:25:54 <benmachine> (although the guard-on-wildcard-pattern is silly enough to be slightly cute :P
07:43:20 <benmachine> oh man, hylo isn't what I want at all, and I should've known that from the type
07:43:22 * benmachine silly
07:44:17 <etpace> hmm.. I'm trying to build an expression parser (using buildExpressionparser http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Expr.html) - But I'd like my binops to have "whitespace" for function applications (like haskell). I can put function application as bottom precedence and the parser works, but then application has the wrong precedence, any idas how to build it correctly?
07:51:19 <carpi> why does this code work "makelist = 1:makelist". After all makelist is not a list and using the (:) function to prepend 1 to makelist should be wrong since makelist is not a list
07:51:42 <carpi> and (:) needs a list as its 2nd argument
07:51:50 <ClaudiusMaximus> :t (:)
07:51:51 <lambdabot> forall a. a -> [a] -> [a]
07:52:09 <geheimdienst> carpi: try to work out what the type of makelist is
07:53:03 <carpi> it is [Integer] as expected..but i wonder how?
07:53:20 <benmachine> carpi: makelist looks like a list to me
07:53:48 <benmachine> carpi: anything which is x:y is a list, regardless of what x and y are
07:53:52 <byorgey> carpi: why do you say that "makelist is not a list"?
07:53:57 <benmachine> (a list or a type error :) )
07:54:15 <geheimdienst> right. so on the right-hand side of the "=" sign, you have 1:makelist. that's a 1 being prepended to an [Integer]
07:54:39 <geheimdienst> ... so from the type standpoint, it works out
07:54:46 <carpi> byorgey: because no where in the code is there a refrence to makeList being a type [Integer]
07:55:36 <benmachine> carpi: haskell frequently works out types for you, when there are enough clues
07:56:07 <benmachine> (although it's usual to write some types down explicitly, even when they could be worked out... this helps prevent errors and provides some documentation)
07:56:41 <roconnor> @type curry
07:56:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:57:15 <Saizan> also, that's a recursive definition, if that wasn't clear
07:57:17 <mike-burns> (:) takes an `a' and a list of `a'. Here you gave it 1 for the `a', thus implying that `a' is an `Integer', and `makelist' as the list of `a', thus implying that `makelist' is a list of Integer.
08:01:46 <carpi>  i think this is whats happening .. "1:(1:(1:(1:(1:" ad infinitum. and the whole operation would break down if makeList was ever to resolve into something that isn't a list..
08:02:16 <benmachine> carpi: that's a pretty good idea, but it's simpler than that
08:02:18 <geheimdienst> carpi: yes, pretty much. it's an infinite list
08:03:03 <benmachine> carpi: you can also see it as a list that contains itself
08:03:23 <benmachine> this is easier to draw with arrows and stuff :P
08:03:27 <carpi> but since makeList never resolves.. and since the return type of every nested (:) is a list.. the function happily chugs along..
08:03:30 <mike-burns> > let ones = 1:ones in take 5 ones
08:03:31 <lambdabot>   [1,1,1,1,1]
08:03:49 <carpi> i don't know if that is correct.. but atleast that theory helps to explain this particular case
08:04:23 <benmachine> carpi: it's good enough as an understanding.
08:04:34 <carpi> benmachine: could you please tell me what you meant when you said "it is much simpler than that"?
08:04:46 <benmachine> carpi: well, I don't know if the way I look at it actually *is* simpler
08:04:49 <benmachine> but it seems simpler to me
08:05:25 <benmachine> the way I look at it, there's only one : containing two things, but one of those things is the : itself
08:05:30 <benmachine> so it's not so much an infinite list as a circular one
08:07:17 <byorgey> carpi: "makelist never resolves" -- doesn't sound right to me.
08:07:42 <byorgey> carpi: I think you are confusing type inference and evaluation.  they are separate.  type inference/type checking happens first.
08:07:50 <byorgey> if everything type checks then it can be evaluated.
08:08:16 <byorgey> in the case of   makelist = 1 : makelist  ,  first type inference figures out that  makelist :: [Integer]
08:08:56 <byorgey> that has nothing to do with evaluation
08:10:39 <carpi> and it infers makeList to be [Integer] from the function signature of (:)..tak?
08:11:18 <byorgey> carpi: right.  (:) :: a -> [a] -> [a], and the first argument to (:) has type Integer, therefore  a = Integer, so the second argument to (:) must have type [Integer]
08:13:19 <etpace> http://hpaste.org/54496 <-- Im trying to parse simple haskell expressions (arithmetic and function application) but my parser for application doesnt really work, any ideas?
08:19:04 <int-e> etpace: "doesn't really work" is not informative. are you sure that 'symbol " "' does what you want?
08:20:21 <etpace> I'm not too sure on that int-e, Ideally, "f 6" Would Parse as "App f 6", which would seem that I want some whitespace inbetween, which is symbol " "?
08:22:04 <mauke> I'm pretty sure it's not symbol " "
08:22:20 <mauke> isn't symbol s = string s <* whitespace?
08:22:27 <int-e> How is 'symbol' defined? The one I see in Parsec has the wrong type.
08:22:42 <int-e> @hoogle symbol
08:22:43 <lambdabot> Text.Read.Lex Symbol :: String -> Lexeme
08:22:43 <lambdabot> Text.Read Symbol :: String -> Lexeme
08:22:43 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
08:22:43 <etpace> hmm, thats true.. it would strip away the whitespace
08:23:02 <etpace> Ideally, i'd want a whitespace that fails on absence of whitespace
08:23:16 <mauke> why?
08:23:37 <mauke> > (sqrt)2
08:23:38 <lambdabot>   1.4142135623730951
08:23:50 <etpace> hmm
08:23:51 <mauke> > length[]
08:23:52 <lambdabot>   0
08:25:16 <ehuber> hello, sorry to interrupt whatever discussion on going on here :D  im a haskell noob, and as my first project im trying to port an irc bot i wrote in python to haskell. but! im stuck on how to use select() in my program .. apparently there should be a util module containing an hSelect function, but im having trouble finding it with cabal .. anyone have experience with nonblocking io in haskell?
08:25:32 <etpace> What is it that I am looking for then?
08:25:41 <etpace> Try to parse two terms?
08:26:15 <donri> ehuber: do you need it to be non-blocking?
08:26:31 <mauke> ehuber: I'm not aware of a select module
08:26:31 <ehuber> donri: one of the actions that my bot needs to do, is every 10 seconds say 'hello' or something of that nature
08:26:39 <Saizan> ehuber: the standard library is so that you should rather use blocking io and threads
08:26:40 <mauke> ehuber: how about threads?
08:26:41 <ehuber> so i need to be able to timeout.
08:27:03 <ehuber> hm, but that might complicate the program
08:27:23 <ehuber> like, suppose that i need a datastructure to be accessible to both threads. well i guess id better read up :)  thanks for confirming
08:27:46 <donri> there's lots of stuff for that in haskell
08:27:55 <mike-burns> @hoogle hSelect
08:27:56 <lambdabot> No results found
08:29:03 <mah_b> though there's epoll
08:29:12 <mike-burns> ehuber: Do any of the existing Haskell IRC bot libraries help?
08:29:22 <etpace> mauke: I'm unsure what im looking for them, term `chainl1` (return App) parses "f 6 + 7" as (f 6) 7 (even though the + chainl1 causes our app chainl1
08:29:41 <ehuber> ill admit that i havent read up on lambdabot. i was hoping to put this together from the ground up. already i have it making a socket and connecting :D
08:30:00 <mauke> etpace: I don't know what chainl1 does
08:30:07 <donri> here's a simple irc bothttps://github.com/chrisdone/hog/blob/master/src/Main.hs
08:30:13 <donri> https://github.com/chrisdone/hog/blob/master/src/Main.hs
08:30:15 <mike-burns> ehuber: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot - might help too.
08:30:19 <etpace> its for left recursive parsers mauke, it applys the parser on the right 1 or more times
08:30:52 <etpace> I attempted my solution by extending the example at http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html
08:31:35 <Saizan> ehuber: do not use lambdabot as an example :P
08:31:35 <geheimdienst> ehuber: i believe the normal thing to do in haskell is to use forkIO to make a "thread". but it's very lightweight, you could make thousands of threads with no difficulty. internally, the lightweight threads are transmogrified into select or poll or whatever
08:31:49 <donri> as for thread sharing maybe http://www.haskell.org/haskellwiki/Simple_STM_example
08:32:31 <mike-burns> And some of the IRC packages: http://haskell.org/hoogle/?hoogle=irc
08:32:51 <donri> yep, that's what the github code uses i linked
08:33:08 <ehuber> thanks all ! im looking into forkio and the other things mentioned.
08:37:49 <ehuber> incidentally.. i would just be using hWaitForInput , but from the docs, it's not clear when it starts blocking -- when there's a single character to be read? when there's an entire line?
08:38:02 <ehuber> *ends blocking
08:38:20 <benmachine> ehuber: I always think it's a bit weird to use hWaitForInput personally :P
08:38:37 <benmachine> but I think it's a character - but a whole unicode character, if you're in text mode
08:38:38 <ehuber> okay :D
08:39:24 <benmachine> that's my vague memory
08:39:25 <geheimdienst> ehuber: i'd expect it to wait for one char (text mode) or one byte (binary). i'd expect hGetLine and that kind of thing to wait for an entire line
08:39:26 <benmachine> I may be wrong
08:39:55 <benmachine> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/System-IO.html "Note that hWaitForInput waits until one or more full characters are available, which means that it needs to do decoding, and hence may fail with a decoding error."
08:40:12 <benmachine> ehuber: hackage docs are the best
08:40:16 <benmachine> sometimes.
08:41:00 <mike-burns> Once in a while.
08:42:32 <hpaste> geheimdienst pasted “bind-and-join-exercise” at http://hpaste.org/54497
08:42:35 <geheimdienst> ^^ is this really correct? so far i don't believe it
08:43:17 <scshunt> win 12
08:43:33 <geheimdienst> (modulo that it could be done more pointlessly and stuff)
08:56:18 <dafis> geheimdienst: it is correct
08:58:00 <geheimdienst> wow, i feel so badass now. i didn't need to twiddle anything, except for forgetting the Functor constraint (which i think is minor). otherwise, the very first time i gave it to ghc, it compiled
08:58:12 <geheimdienst> can i my badge now? the one with "I understand monads" on it?
08:58:27 <cheater> no
08:58:41 <cheater> i'm in a bad mood come tomorrow
08:58:43 <cheater> :p
08:59:16 <geheimdienst> cheater: you're just jealous because you lost your badge on that drinking binge
08:59:38 <cheater> can't lose it, my badge is sewn to my left buttock
09:09:55 <CIS> Hi, anyone here from Strathclyde university?
09:12:09 <ehuber> that's kind of a strange thing to ask :D
09:12:24 <djahandarie> Not really :P
09:12:40 <djahandarie> Considering that someone probably is
09:17:30 <CIS> not really lol, we're all learning haskell at the moment and were told to come onto this website to get a tutorial for it :D
09:19:19 <geheimdienst> CIS, if you're looking for an introductory text about haskell, try LYAH
09:19:22 <geheimdienst> @where lyah
09:19:22 <lambdabot> http://www.learnyouahaskell.com/
09:19:51 <CIS> Thanks, i'll give it a go, i'm on this IRC channel through a website called tryhaskell.org
09:20:03 <CIS> http://www.tryhaskell.org
09:20:12 <EvilMachine> I think nothing beats this: http://book.realworldhaskell.org/read/
09:20:18 <_kit_> http://book.realworldhaskell.org/read/ is also a good introductory read.
09:20:28 <_kit_> er.. um.. what EvilMachine said.
09:20:38 <EvilMachine> :D
09:21:02 <CIS> I'm not really use to using interpreters, usually coding in object orientated or structured, interpreters are new to me :P
09:21:26 <geheimdienst> i thought RWH was aimed more at the intermediate level. but if you can swallow it as a beginner, sure, go for it
09:21:30 <mike-burns> Did you mean to use "Java" in that sentence somewhere?
09:21:57 <CIS> Yeah i'm a Java programmer
09:21:59 <mauke> CIS: ?!
09:22:01 <EvilMachine> CIS: what does object orientation have to do with if it’s compiled or interpreted? ^^
09:22:18 <djahandarie> Object disorientation.
09:22:20 <mike-burns> He meant "Java" when he said "object oriented".
09:22:24 <CIS> lmao
09:22:32 <CIS> I'm being totally slated here ^_^
09:22:32 <EvilMachine> CIS: Well, haskel can be interpreted, compiled and i think there’s a byte-code way too. :)
09:22:41 <mauke> and what does "structured" mean?
09:22:56 <mike-burns> I'm guessing C. CIS?
09:23:12 <EvilMachine> CIS: don’t worry. i think we pride ourselves on being a bit nicer than most channels in here. (and i hope you don't make me a liar, guys. ;)
09:23:26 <mike-burns> We're also one of the most pedantic groups.
09:23:28 <donri> isn't "structured" a term denoting the use of functions and such rather than plain goto? :P
09:23:38 <byorgey> s/a bit/much/
09:23:40 <EvilMachine> mike-burns: but in a nice way, interestingly. :)
09:23:41 <CIS> lol, well i'm learning to use languages right now that are mainly interpreted, like haskell, lisp, python etc, I've been use to using C# C++, Visual Basic etc, so all other languages i've used run off compilers and not interpreters :)
09:23:43 <djahandarie> HOW DARE YOU MENTION OTHER LANGUAGES IN HERE, FOOL!
09:23:46 <mauke> "structured" basically means not writing in assembler code
09:24:01 * djahandarie kicks open the door
09:24:01 <donri> CIS: haskell is not "mainly interpreted"
09:24:06 <mauke> CIS: "interpreted" is not a language property
09:24:11 <mauke> CIS: haskell and lisp are not interpreted
09:24:15 <mike-burns> Python is bytecode, much of the time.
09:24:23 <mauke> CIS: C# and Visual Basic are interpreted
09:24:25 <geheimdienst> mauke: what's ghci then?
09:24:39 <ehuber> i have another (simpler?) question.. i have a case statement of which one branch does an IO action, (and so the other naturally must also). however i dont actually want to print or read anything in the other branch. is there some value IO () that 'does nothing' ?
09:24:40 <mauke> geheimdienst: a development tool. no one uses it to actually run programs
09:24:42 <mike-burns> geheimdienst: You mainly do Haskell through ghci?
09:24:53 <mike-burns> ehuber: return ()
09:25:00 <ehuber> ah, of course. thanks :D
09:25:15 <mux> people should just stop talking about languages in terms of whether they are interpreted or compiled, it doesn't make much sense
09:25:31 <EvilMachine> ehuber: could you use a Either (IO something) somethingelse?
09:25:35 <carpi> should pattern matching always be done inside parentheses?.. as in (x:xs)?
09:25:37 <mike-burns> In addition to being pedantic, we as a group know more programming languages and more about their implementation than most other channels, too.
09:25:43 <mauke> carpi: no
09:25:53 <djahandarie> WE ARE ALSO SUPERIOR IN INTELLECT
09:25:59 <mike-burns> carpi: No. The parens are for precedence, just like anywhere else.
09:26:00 <mux> mike-burns: also, we clearly are the most humble coders around!
09:26:01 <geheimdienst> mike-burns, djahandarie: we are also among the most humble people
09:26:08 <mux> hah.
09:26:09 <ehuber> you guys are pedantic but very helpful .. so 'big ups' :D
09:26:10 <mike-burns> Haha.
09:26:13 <CIS> is it not so that some pieces of code are better put through an interpreter rather than a compiler and vice versa?
09:26:18 <carpi> mauke: so i can do x:xs without the parenthesis? what about _:xs?
09:26:18 <EvilMachine> djahandarie: Unless the Dunning-Kruger effect hits us too. ;)
09:26:22 <donri> carpi: pattern matching happens on value constructors, in this case the (:) list cons
09:26:33 <cheater> carpi: yes.
09:26:36 <mauke> CIS: no
09:26:49 * cheater was hoping he'd try and see the error
09:26:58 <geheimdienst> mux: i think it is slightly useful to say "interpreted" for "write and run" and "compiled" for "write, compile, then run". so i think it's more of a user interface difference really
09:27:11 <mike-burns> I'm not suggesting that we're better because we know more languages. It probably just makes us more cranky.
09:27:16 <_kit_> CIS, I think your confused on the difference between a REPL and interpreted vs compiled. you can stick a repl on C (it'd be ugly but I'm sure it'd been done).
09:27:26 <EvilMachine> CIS: Hmm, i think an interpreter would only be better, if you’d need self-modifying code.
09:27:32 <donri> perhaps you could argue a difference between a language that makes eval() possible or not, but even a compiled binary could include an "interpreter"
09:27:36 <mike-burns> When I was a Perl programmer we found a way to make a C REPL.
09:27:41 <mike-burns> It was ugly.
09:27:53 <mauke> there are C interpreters
09:27:54 <_kit_> tiny c and a compile in each loop ?
09:28:01 <ehuber> your compiler could just embed the program as text with the interpreter code
09:28:02 <danm_> it's a long way to the top, if you wanna haskell
09:28:04 <mux> geheimdienst: the problem is that the line between the two is very blurry, and many languages could be both interpreted and compiled. It's just not really relevant technically speaking, when you're interested about implementation of interpreters/compilers.
09:28:28 <EvilMachine> mike-burns: Perl and C? Ugly?? Never! ;)
09:28:34 <mike-burns> So we've gathered that this is CIS's first time using a REPL.
09:28:47 <mike-burns> EvilMachine: Hah!
09:29:02 <ehuber> C is beautiful, it's like the latin of computer professionals
09:29:29 <mike-burns> There was a Perl package to allow you to write in Latin.
09:29:35 <EvilMachine> ehuber: you are aware that original latin was written with no punctuation at all, and hence only made sense when read out aloud? ^^
09:29:48 <ehuber> XD
09:29:59 <carpi> thx
09:30:02 <mauke> EvilMachine: how does that follow?
09:30:20 <ehuber> well if you read it aloud you have to interpret it some way
09:30:23 <mauke> standard latin puts the verb at the end of a sentence
09:30:28 <danm_> because punctuation aids in interpretation
09:30:35 <mauke> so you know where each part ends
09:30:49 <mike-burns> Like FORTH.
09:31:01 <EvilMachine> mauke: well, apparently when the reader read the text, the listener could make sense of it. something like that. anyway, my ex told me that. (she studied history and latin)
09:31:16 <donri> lojban does away with punctuation as such ;)
09:31:33 <donri> or rather, it makes punctuation explicit as grammatical particles
09:31:43 <EvilMachine> icaniwriteicodeiwithoutianyipunctuation
09:31:49 <ehuber> punctuation is just an ambiguous way of doing flush()
09:31:51 * EvilMachine has invented Apple iCode!
09:31:55 <EvilMachine> :P
09:31:59 * EvilMachine now is ashamed of himself
09:32:12 <CIS> * lol
09:32:13 <donri> well, it does look similar to objective-c
09:32:19 <CIS> I love this channel already :D
09:32:27 <mike-burns> CIS: /me to do an action.
09:32:32 <CIS> How do i change my name ?
09:32:38 <mike-burns> CIS: /nick
09:32:43 <donri> you type /nick bla
09:32:45 <CIS> I've not used mIRC in yeears!
09:32:53 <EvilMachine> CIS: /help → all you need :)
09:33:04 <donri> note that he's on the freenode webchat in a frame on tryhaskell
09:33:12 <EvilMachine> ah
09:33:13 <roconnor> Is there a function that does \f g (x,y) -> f x `mappend` g y ?
09:33:35 <roconnor> @type  \f g (x,y) -> f x `mappend` g y
09:33:36 <lambdabot> forall t t1 a. (Monoid a) => (t -> a) -> (t1 -> a) -> (t, t1) -> a
09:33:36 <EvilMachine> now there is. :D
09:33:52 <mauke> :t (uncurry .) . liftA2 mappend
09:33:53 <lambdabot> forall a b c. (Monoid c) => (a -> b -> c) -> (a -> b -> c) -> (a, b) -> c
09:34:43 <mauke> no, I'm thinking sideways again
09:34:57 <roconnor> :t (uncurry .) . liftA mappend
09:34:58 <lambdabot> forall b c (f :: * -> *). (Applicative f, Monoid c) => f (b -> c) -> f ((b -> c, b) -> c)
09:35:43 <FruitHaskell> haha :D
09:35:46 <roconnor> basically I need to come up a name for this combnator
09:35:47 <FruitHaskell> Clever  eh :)
09:35:47 <byorgey> @pl \f g (x,y) -> f x `mappend` g y
09:35:48 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . mappend) .)
09:36:07 <geheimdienst> roconnor: perhaps something involving uncurry, mappend, and (***)
09:36:10 <djahandarie> @pl \f g x y -> f x `mappend` g y
09:36:10 <lambdabot> flip . (((.) . mappend) .)
09:37:56 <roconnor> @type (uncurry mappend .) . (***)
09:37:57 <lambdabot>     No instance for (Arrow (,))
09:37:57 <lambdabot>       arising from a use of `***' at <interactive>:1:22-26
09:37:57 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:38:22 <roconnor> @type ((uncurry mappend) .) . (***)
09:38:23 <lambdabot>     No instance for (Arrow (,))
09:38:23 <lambdabot>       arising from a use of `***' at <interactive>:1:24-28
09:38:23 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
09:38:34 * hackagebot access-time 0.1.0.1 - Cross-platform support for retrieving file access times  http://hackage.haskell.org/package/access-time-0.1.0.1 (MaxBolingbroke)
09:38:53 <byorgey> roconnor: needs moar (.)
09:39:06 <byorgey> @type ((uncurry mappend .) .) . (***)
09:39:06 <mauke> :t ((uncurry mappend .) .) . (***)
09:39:07 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, Functor (a1 (b, b')), Arrow a1) => a1 b a -> a1 b' a -> a1 (b, b') a
09:39:07 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, Functor (a1 (b, b')), Arrow a1) => a1 b a -> a1 b' a -> a1 (b, b') a
09:39:17 <FUZxxl> my eyes
09:39:34 <mauke> :t fmap (fmap (fmap (uncurry mappend))) (***)
09:39:35 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, Functor (a1 (b, b')), Arrow a1) => a1 b a -> a1 b' a -> a1 (b, b') a
09:39:43 <roconnor> I need a name !
09:39:47 <roconnor> from category theory
09:39:59 <geheimdienst> combobuloid
09:40:02 <djahandarie> Haha
09:40:38 <geheimdienst> roconnor: just mash together some impressive-sounding latin and greek syllables
09:41:02 <roconnor> geheimdienst: actually I need an infix operator
09:41:10 <roconnor> maybe f *+* g
09:41:18 <byorgey> oh, an infix operator from category theory?
09:41:32 <roconnor> well, n-fix would be even better
09:41:45 <roconnor> since this is kinda associativeish
09:42:08 <djahandarie> @type uncurry mappend .:: (***)
09:42:09 <roconnor> but infix would be fine
09:42:09 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, Arrow a1, Functor (a1 (b, b'))) => a1 b a -> a1 b' a -> a1 (b, b') a
09:42:59 * byorgey likes f *+* g
09:43:00 <hpaste> geheimdienst pasted “stereo” at http://hpaste.org/54498
09:43:29 <geheimdienst> i actually wrote this a while ago. kinda like &&&, but has variants for more arguments. i still think it could be handy in general ...
09:45:26 <geheimdienst> ... uh wait, you wanted 2 different args. mine is for the same args twice :-)
09:48:03 <ezyang> Is it well known that peekByteOff isn't very type safe?
09:48:25 <Ololo> :t let { foo (x:y:_) = x == y; foo [_] = foo []; foo [] = False } in foo
09:48:26 <lambdabot> forall a. (Eq a) => [a] -> Bool
09:49:19 <Ololo> :t let { foo :: (Eq a) => [a] -> Bool; foo (x:y:_) = x == y; foo [_] = foo []; foo [] = False } in foo
09:49:20 <lambdabot> forall a. (Eq a) => [a] -> Bool
09:49:35 <roconnor> or maybe f *<>* g ... what did we settle on for the infix symbol for mappend?
09:49:48 <byorgey> roconnor: yeah, <>
09:50:14 <FruitHaskell> Weeeeee! I do love haskell
09:50:26 <benmachine> ezyang: how could it be type-safe?
09:50:56 <byorgey> FruitHaskell: =)
09:51:18 <ezyang> benmachine: Well, hsc2hs generates peekByteOffs, and to an untrained eye you might think {#peek SomeStruct, field #} would know how big the field is.
09:51:39 <ezyang> I guess the real moral of the story here is that hsc2hs is an untyped disaster to happen.
09:52:57 <geheimdienst> ezyang: oh you meant it's type-unsafe on the c side of things. i thought it does figure out the offsets of the struct fields correctly?
09:53:26 <ezyang> It does figure out the offsets correctly, but if you pass a bad type to pokeByteOff, you might read too much / too little.
09:53:42 <ezyang> I feel like {#poke} should explicitly add a type annotation.
09:54:53 <Ololo> Hi, guys. One russian blogger've asked a very tricky question: why the hell http://codepad.org/wGjfB0Pb doesn't work
09:55:34 <Ololo> What's the problem with typing function with pattern matching? Haskell report doesn't tell a thing
09:55:49 <mauke> Ololo: line 3 looks wrong
09:55:56 <ezyang> Ololo: It looks like the problem is the recursive call to foo.
09:56:05 <FudgeSickle> Can anyone recommend a good library for parsing a wikipedia page?
09:56:12 <mauke> 'foo []' doesn't know which [a] it's supposed to be
09:56:14 <ezyang> Try replacing that with False
09:56:33 <Ololo> Without explicit typing it works ok
09:56:35 <ezyang> in other news...
09:57:03 * ezyang complains about the lack of non-curl http libraries that support cookies 
09:57:12 <Ololo> Also, this type is really a type of `foo`
09:57:38 <ezyang> It is certainly sometimes the case that an explicit type can make the typecheckers job harder.
09:57:43 <geheimdienst> FudgeSickle: i'd expect it to be easiest if you grab the xml variant of the wikipedia page and go from there
09:57:49 <mauke> Ololo: yeah, that's curious
09:58:05 <mauke> I wonder why it compiles without a signature
09:58:28 <FudgeSickle> geheimdienst, Ah, I didn't realise there was one, I suppose the question would be what's the best xml parser then?
09:59:55 <TheRubberyTurk> ezyang: The HTTP libraries should support reading and setting headers.
10:00:03 <Ololo> ezyang: but this is a totally Haskell 98 code. either typechecker is wrong or there're some unobvious rules, which let it fail
10:00:28 <ezyang> TheRubberyTurk: Ah! But the problem is that HTTP doesn't support SSL.
10:00:39 <eyebloom> When you are reading through a paper and you see a type defined using the upside down "A" meaning For All, how do you translate that to haskell syntax? Such as for example:   type Hoas = ∀exp. UntypedLambda exp ⇒ exp
10:00:59 <mauke> Ololo: I'd say the failure is right (and obvious)
10:01:10 <mauke> I don't understand why it typechecks without a signature
10:01:33 <ezyang> eyebloom: You can just omit it.
10:01:48 <Ololo> mauke: all I can say is "wow".
10:02:24 <mauke> eyebloom: 'forall'
10:03:05 <eyebloom> mauke: not sure forall works in a type expression.
10:03:13 <mauke> eyebloom: where else would it?
10:03:46 <eyebloom> mauke: in a higher order function over a set of data.
10:03:52 <mauke> wat
10:04:05 * ezyang has been writing too much Coq. Foralls everywhere for free! 
10:04:25 <geheimdienst> eyebloom: check out this, it has some example uses of forall, especially section 2 http://haskell.org/haskellwiki/Existential_type
10:04:37 <TheRubberyTurk> ezyang: I wasn't referring to the HTTP package specifically, but, at any rate, your question was about cookies not SSL.
10:05:37 <ezyang> TheRubberyTurk: Yeah, sorry, I forgot about that constraint.
10:05:42 <ezyang> I need cookies AND ssl.
10:06:23 <eyebloom> So the consensus is that you can just omit it: the two expressions:
10:06:40 <eyebloom> type Hoas = forall exp. UntypedLambda exp ⇒ exp
10:06:52 <eyebloom> and type Hoas = UntypedLambda exp ⇒ exp
10:06:57 <eyebloom> are not the same?
10:07:02 <Saizan> does the second typecheck?
10:07:03 <mauke> "consensus"?
10:07:14 <eyebloom> majority.
10:07:20 <mauke> it's just something ezyang said and I think is wrong
10:07:23 <TheRubberyTurk> The second doesn't even declare exp.
10:07:24 <mauke> how is that a majority
10:08:07 <ezyang> Well, you have to change the left side to data Hoas exp = UntypedLambda (exp -> exp)
10:08:10 <ddarius> ezyang: What's a non-curl HTTP package that supports SSL.
10:08:20 <ezyang> ddarius: http-enumerator
10:08:32 <eyebloom> That last arrow is a =>
10:08:34 <ddarius> ezyang: And that library doesn't let you set headers?
10:08:37 <eyebloom> not a ->
10:08:44 <ddarius> ezyang: That is a totally different expression
10:08:45 <Saizan> ezyang: that's quite not what the original type was
10:08:53 <ezyang> Hmm, I'm misparsing.
10:09:04 <dafis> Ololo: http://stackoverflow.com/questions/8270548/effects-of-monomorphism-restriction-on-type-class-constraints/8271286#8271286
10:09:08 <ezyang> OK, in that case, pay no attention to my comments :^)
10:09:27 <ezyang> ddarius: Nope. I think it might be easiest for me to patch http-enumerator to let me do that, but *shivers*
10:09:38 <eyebloom> Well let's start over... when would you use forall in a type or data expression?
10:09:55 <ddarius> eyebloom: When you want universal quantification.
10:11:17 <eyebloom> when would you want universal quantification.
10:11:18 <irene-knapp> > gcd (3141592653589793238 * 1) (1 * 1000000000000000000) :: Integer
10:11:19 <lambdabot>   2
10:11:21 <irene-knapp> huh
10:11:56 <ezyang> eyebloom: One usually instance is when you need a higher-rank type.
10:12:30 <Ololo> dafis: funny part is that topic starter at SO and one who asked this question in LJ is the same man )
10:12:50 <dafis> Ololo: so when did he ask on LJ?
10:13:24 <geheimdienst> o hai irene :) any news on that haddock/div-by-zero bug we talked about a few days ago? it was kind of fascinating
10:13:43 <irene-knapp> hihi geheimdienst
10:13:45 <irene-knapp> yeah, sorta
10:13:59 <irene-knapp> it's a persistent problem with integer-gmp on my system (and only on my system :( )
10:14:07 <ezyang> eyebloom: One particular case it comes in handy is when you're simulating existential types.
10:14:21 <irene-knapp> I thought it might be due to a stale copy of libgmp that had somehow survived my purge, but I got rid of it, did a maintainer-clean, and still no joy
10:14:40 <irene-knapp> the latest thing I've discovered is this:
10:14:40 <cheater> irene-knapp: try md5sums.
10:14:42 <cheater> er
10:14:44 <cheater> debsums
10:14:47 <irene-knapp> cheater: on what?
10:14:52 <cheater> on everything.
10:14:56 <irene-knapp> gcdInteger 3141592653589793238 1000000000000000000 -- returns 2
10:15:01 <Saizan> eyebloom: given type Hoas = forall exp. UntypedLambda exp ⇒ exp, a value (x :: Hoas) can be used at multiple different types as long as they are an instance of UntypedLambda
10:15:02 <eyebloom> what is the difference between an existential type and a polytype?
10:15:06 <irene-knapp> gcdInteger (3141592653589793238 * 1) (1 * 1000000000000000000) -- returns 0
10:15:10 <cheater> sounds like you have binary corruption.
10:15:26 <geheimdienst> irene-knapp: holy cow :-o
10:15:30 <irene-knapp> cheater: even if so, I'm not sure how taking md5s at random with nothing to compare them to is going to help
10:15:42 <ezyang> Whelp, I just posted a ticket. http://hackage.haskell.org/trac/ghc/ticket/5659
10:15:48 <cheater> i corrected myself, and said debsums
10:15:49 <Saizan> eyebloom: in the same was as (1 :: forall a. Num a => a) can be used both as an Integer and Double and many other types
10:15:50 <cheater> look it up
10:15:53 <irene-knapp> I'm on a Mac
10:15:58 <cheater> oh
10:16:00 <cheater> i'm sorry.
10:16:02 <Saizan> eyebloom: s/same was/same way/
10:16:03 <irene-knapp> hush
10:16:22 <geheimdienst> irene-knapp: can you reproduce it on another system?
10:16:36 <irene-knapp> geheimdienst: not sure.  I don't have access to another copy of Lion with the latest XCode
10:16:48 <irene-knapp> (so no, for now)
10:17:07 <irene-knapp> my latest strategy is, I modified integer-gmp to export its constructors, right, so that I can poke at them from a tiny test program
10:17:21 <irene-knapp> I want to see the binary representations of all the integers involved
10:17:36 <Jeanne-Kamikaze> can someone help me with this ? http://pastebin.com/9eGtWJRP
10:17:37 <mauke> The paste 9eGtWJRP has been copied to http://hpaste.org/54499
10:17:46 <irene-knapp> so far I've determined that all four are using S# (the "small" thing that just wraps an Int#) rather than J# (the "large" one)
10:18:03 <dafis> irene-knapp: integer-gmp does export the constructors, what did you modify?
10:18:04 <irene-knapp> I'm currently figuring out how to print an Int#, which of course doesn't have a Show instance
10:18:15 <mauke> Jeanne-Kamikaze: which version of ghc?
10:18:27 <ezyang> Jeanne-Kamikaze: What is your terminal encoding?
10:18:29 <irene-knapp> dafis: no, I don't believe it does?  what I modified was changing GHC.Integer.Type to be on the visible modules list
10:18:29 <Jeanne-Kamikaze> 7.0.3 windows haskell platform latest
10:18:38 <mauke> oh, windows
10:18:39 <Jeanne-Kamikaze> I don't know ?
10:18:42 <Jeanne-Kamikaze> it works on linux
10:18:48 <dafis> irene-knapp: GHC.Integer.GMP.Internals
10:18:49 <ezyang> mm Windows.
10:18:52 * irene-knapp didn't actually check whether they were re-exported elsewhere... does that now so she can feel stupid :)
10:18:59 <mauke> don't know how input encoding works on windows
10:19:16 <geheimdienst> Jeanne-Kamikaze: i'm guessing windows sends things in another encoding (cp1252 or whatever), while haskell expects utf-8
10:19:17 <irene-knapp> oh hey so it does!
10:19:21 <irene-knapp> silly me :/
10:19:32 <Jeanne-Kamikaze> damn
10:19:38 <irene-knapp> well that was a waste of a clean-and-build cycle, haha
10:20:00 <mauke> no, it is in utf-8 but ghci "decodes" it as latin-1
10:20:05 <irene-knapp> dafis: I don't believe we've met before, are you one of the maintainers of integer-gmp? :D
10:20:07 <Jeanne-Kamikaze> geheimdienst, it also fails when reading from a file
10:20:15 <Jeanne-Kamikaze> I used getLine there for showcase
10:20:37 <Jeanne-Kamikaze> but fmap f $ readFile "somefile.txt" does the same thing
10:20:39 <dafis> irene-knapp: No, I'm just hacking around in the numeric bits every now and then
10:20:44 <mauke> how does locale/encoding work on windows?
10:20:44 <irene-knapp> ahhh okay, cool cool
10:22:28 <Saizan> you could hSetEncoding to override whatever locale you have
10:23:01 <irene-knapp> okay hmmmmm
10:23:02 <irene-knapp> this is weird
10:23:15 <irene-knapp> let me hpaste
10:23:52 <hpaste> irene-knapp pasted “Weird!” at http://hpaste.org/54500
10:24:27 <irene-knapp> can I somehow get at the actual bits of the Int#?
10:24:41 <irene-knapp> instead of going through the Show instance?
10:25:02 <irene-knapp> I have a theory that somehow it's holding two values which are distinct internally but represent the same thing
10:25:21 <irene-knapp> although since it's just a 2s-complement integer, I'm not sure how that's possible
10:26:25 <dafis> irene-knapp: reproducible behaviour?
10:26:34 <irene-knapp> dafis: every single time but only on my machine so far
10:26:51 <dafis> irene-knapp: can you show' the results?
10:26:59 <irene-knapp> oh, sure
10:27:29 <irene-knapp> S#2 and S# 0, respectively
10:28:05 <dafis> irene-knapp: that's your modified integer-gmp, right?
10:28:12 <irene-knapp> wel, yes
10:28:30 <irene-knapp> I could revert it and rebuild, but the misbehavior has been quite resilient to my changes
10:28:34 <irene-knapp> and that would take like an hour
10:28:46 <dafis> irene-knapp: and the modification was adding the type to the export list in GHC.Integer.Type and nothing else?
10:28:53 <geheimdienst> irene-knapp: this behavior is definitely fascinating, but maybe a reboot would be in order :) check this interesting story http://blogs.oracle.com/ksplice/entry/attack_of_the_cosmic_rays1
10:29:06 <irene-knapp> actually the modification was adding GHC.Integer.TYpe to the list of exported modules, and nothing else
10:29:19 <irene-knapp> (it already has a null export list, which means export everything, as you probably know)
10:29:28 <irene-knapp> geheimdienst: whoa haha
10:29:36 <irene-knapp> but but but, uptime is 39 days :D
10:29:43 <dafis> irene-knapp: I didn't I walways use Internals :)
10:29:51 <irene-knapp> dafis: yeah, I see :)
10:29:55 <dafis> s/wal/al/
10:30:06 <irene-knapp> yeah, hold on, I'll reboot (you won't see me disconnect, since this connection is on a remote host running screen)
10:31:17 <dafis> irene-knapp: which GHC, by the way?
10:34:58 <geheimdienst> dafis: iirc she's using some overly new unreleased compiled-from-source version
10:35:14 <dafis> geheimdienst: aka HEAD?
10:35:23 <geheimdienst> yes, or something like it
10:35:40 <dafis> thx
10:37:29 <irene-knapp> back, trying stuff now
10:37:32 <irene-knapp> yes, it's HEAD
10:37:53 <irene-knapp> been having this problem persistently for about two months, heh, and finally made time to deal with it :/
10:38:25 <irene-knapp> so if it's a bug that only affects HEAD, it's not one that's brand-new
10:39:31 <dafis> irene-knapp: Prelude GHC.Integer.GMP.Internals> gcdInteger (3141592653589793238 * 1) (1 * 1000000000000000000)
10:39:31 <dafis> 2
10:39:38 <dafis> today's HEAD
10:40:10 <dafis> irene-knapp: which gmp version are you using?
10:40:51 <irene-knapp> yeah - I'm certain this is somehow a misconfiguration on my machine
10:41:23 <dafis> irene-knapp: but the "somehow" is quite interesting
10:41:45 <dafis> I can't see how that may come
10:41:49 <geheimdienst> a "misconfiguration" that shows itself in a one-bit difference in computation results ... :-o
10:42:05 <irene-knapp> I have carefully expunged all prebuilt GMPs on the machine and am using the
10:42:17 <dafis> geheimdienst: I suspect rather a shifted read
10:42:41 <dafis> ... in-tree gmp
10:44:31 <irene-knapp> yes, thank you
10:44:37 <irene-knapp> which appears to be 5.0.2
10:44:42 <irene-knapp> sorry, network blipped for a moment
10:44:48 <irene-knapp> and as you say, the "somehow" is fascinating
10:45:53 <irene-knapp> I did try this with both (originally) the GHC 7.0.3 binary that I had gotten off the official site when it was current, and (eventually, and all my recent attempts) the 7.2.2 one from the same source
10:45:58 <irene-knapp> (as the host)
10:46:29 <irene-knapp> since I'm not the one who built either of those, I don't think they could be the source of the problem, haha
10:46:33 <dafis> irene-knapp: those had the same bug, with system gmps?
10:47:00 <irene-knapp> well, I don't believe they were using the system GMP, but there was one installed in /usr/local originally
10:47:08 <irene-knapp> Lion doesn't bundle a GMP
10:47:15 <dafis> that's what I meant with system
10:47:21 <irene-knapp> but GHC is afaik statically linked, including a copy of GMP
10:47:48 <irene-knapp> (that's why we patch it to use our allocator and not conflict with a user copy of GMP, so that users writing hybrid Haskell-C apps can use their own GMP from the C half)
10:48:05 <Philonous> Is it possible to promote a value-indexed type to the kind level?
10:48:10 * irene-knapp blinks
10:48:15 <irene-knapp> I don't think so? :)
10:48:34 * hackagebot histogram-fill 0.5.1.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.5.1.1 (AlexeyKhudyakov)
10:48:41 <byorgey> Philonous: not yet
10:49:03 <Philonous> byorgey:  Ah, bummer. Not that I needed it.
10:49:07 <dafis> irene-knapp: as far as I know, gmp is linked dynamically
10:49:39 <Philonous> byorgey:  Does that mean it will come, eventually?
10:49:43 <byorgey> Philonous: it might.
10:49:44 <irene-knapp> dafis: I'm not sure how that could be - in that case I shouldn't be able to run either of these host GHCs at all right now, unless they're finding a gmp somewhere that I don't know about
10:49:53 <irene-knapp> dafis: but let me inspect the load commands in them to be sure
10:50:11 <albertid> Hi, I'm looking for a function like iterate, but that I can give an array of functions: [f,g,...] so that it is [x, f x, g (f x), ....], could this be solved with applicative functors?
10:50:21 <geheimdienst> irene-knapp: is endianness ruled out already? it's kind of a wild idea, but what if that "2" that fails to show up is in fact some combination of endianness mixup, overflow, and two's complement whatever. specifically i think it's possible that there's code of the sort "#if PLATFORM == MAC ... assume big-endian ... #else ... assume little-endian ..." which was true at some point, but isn't anymore
10:50:25 <Philonous> byorgey:  Oh, and I haven't tried it, but I'd assume GADTs are a no-no, too?
10:50:33 <geheimdienst> ... hm, maybe a little too wild, that idea ... :)
10:50:49 <irene-knapp> geheimdienst: it's not ruled out.  that could be a thing.  but it doesn't seem hugely likely :)
10:51:01 <dafis> irene-knapp: when I accidentally ran a binary compiled on the other box, it complained it could not find libgmp.so.3
10:51:09 <Rotaerk> albertid, so you want a fold, where it returns a list of each intermediate value, rather than just the final value
10:51:13 <irene-knapp> dafis: what OS?
10:51:25 <albertid> Rotaerk, thats correct
10:51:37 <byorgey> Philonous: yep, that would require kind equality constraints which are not supported
10:52:20 <dafis> irene-knapp: linux, old openSuSE 11.3, new 11.4 (with libgmp.so.10)
10:52:36 <Rotaerk> albertid, I just did this in hoogle:  (a->b->a)->a->[b]->[a]
10:52:37 <irene-knapp> yeah, hmm, I suspect that's different depending on platform
10:52:40 <Rotaerk> and it turned up scanl
10:52:42 <Rotaerk> would that work?
10:52:43 <geheimdienst> irene-knapp: true, it's very unlikely, but on the other hand the whole behavior you're seeing is very unlikely :)
10:53:01 <dafis> geheimdienst: understatement
10:53:04 <irene-knapp> yeah, very true hahaha
10:53:25 <albertid> Rotaerk, thanks for the pointer, I will try it
10:53:34 <dafis> irene-knapp: anyway, please file a bug on trac
10:53:42 <monochrom> every programming language evolves into a dependently-typed lisp :)
10:53:57 <irene-knapp> okay so I'm looking at /Library/Frameworks/GHC.framework/Versions/7.2.2-x86_64/usr/lib/ghc-7.2.2/integer-gmp-0.3.0.0/libHSinteger-gmp-0.3.0.0.a
10:54:02 <Philonous> byorgey:  OK, thanks.
10:54:05 <irene-knapp> dafis: oh I will, don't worry!  but hopefully I'll have a patch first lol
10:55:15 <irene-knapp> so otool tells me that this archive contains a ton of .o files with names that don't look like they came from Haskell things
10:55:19 <illissius> humm
10:55:20 <irene-knapp> including ie gcd.o
10:55:31 <irene-knapp> so it looks to me very much like GMP is statically included in it
10:56:01 <irene-knapp> which would make sense because I can't think where on my system it could be finding a copy of GMP, if not there
10:56:11 <irene-knapp> (note that this probably violates the LGPL!)
10:56:54 <dmos> cabal-dev & test-suites & ghci: I can't seem to figure out how to run cabal-dev ghci with a test-suite dependency configuration. Any ideas?
10:57:21 <dafis> irene-knapp: if it's built with the in-tree gmp, it may well be statically linked, but I'm not au courant with the build system, Igloo would know
10:57:24 <irene-knapp> (I see from ./libraries/integer-gmp/LICENSE that we are attempting to place integer-gmp under BSD3, but that means we can't distribute this copy of it which is statically linked with GMP, since GMP is LGPL)
10:57:28 <irene-knapp> fair enough
10:57:52 <irene-knapp> Igloo is one of the Europers though, he won't be around to poke about this until Monday, and I really kinda don't want to come on IRC from work anyway :)
10:58:22 <irene-knapp> anyway, I've convinced myself it's statically linked in this way
10:58:40 <irene-knapp> which is "good" in that it means it's one less thing that could be weird about my system!
10:58:41 <dafis> irene-knapp: Igloo also works on week-ends
10:58:46 <irene-knapp> oh?  cool hehe
10:59:50 <geheimdienst> i thought the americans are difficult to reach on account of their turkey festival? i thought europe currently was in a state that passes for normal
10:59:59 <irene-knapp> he seems to be here now haha
11:00:03 <irene-knapp> geheimdienst: that's true haha
11:00:12 <irene-knapp> I'm summarizing the problem in #ghc now for his benefit
11:04:33 <irene-knapp> okay, there, I did that
11:04:34 <irene-knapp> now
11:04:38 <irene-knapp> I just realized while I was writing that
11:04:50 <irene-knapp> with the S# constructor, GMP isn't even being called by integer-gmp!
11:05:06 <irene-knapp> it defers to gcdInt!
11:05:25 <irene-knapp> (line 252 of libraries/integer-gmp/GHC/Integer/Type.lhs)
11:05:29 <clsmith> is there a single symbol for "a ==> ¬b" (a implies not b), or do i have to invent something like =/> ?
11:05:39 <dafis> irene-knapp: which, iirc, is another call to gmp
11:05:45 <irene-knapp> possibly, let me check
11:06:20 <irene-knapp> hmmm gcdInt is defined right below that but just defers to gcdInt# after sanitizing the inputs
11:06:34 <dafis> irene-knapp: GHC.Integer.GMP.Prim, line 122
11:06:47 <irene-knapp> yes, I'm there
11:07:01 <irene-knapp> that's actually not a GMP call, it's a prim from cbits
11:07:09 <irene-knapp> you can tell by the calling convention :)
11:07:14 <irene-knapp> lemme see here...
11:07:54 <irene-knapp> here we go.  line 391 of libraries/integer-gmp/cbits/gmp-wrappers.cmm
11:08:06 <dafis> irene-knapp: hmm, I don't find anything like that in cbits
11:08:49 <irene-knapp> you don't?  the line should read "integer_cmm_gcdIntzh
11:08:51 <irene-knapp> "?
11:08:55 <dafis> (r) = foreign "C" __gmpn_gcd_1(mp_tmp_w "ptr", 1, R2) []
11:09:21 <dafis> calls gmp, as far as I can tell
11:10:15 <irene-knapp> hmmmmmm
11:12:31 <irene-knapp> one sec, talking to Igloo again
11:15:51 * illissius wonders how edwardk managed to upload a package using unrecognized extensions to hackage
11:21:43 <parcs> what package?
11:22:28 <parcs> and i don't think hackage cares what you upload, for the most part
11:24:26 <irene-knapp> gahhhhhh nooooo it went awayyyyyyy!  now I can't reproduce at all :(
11:25:43 <dafis> irene-knapp: did it manifest after the reboot?
11:26:07 <irene-knapp> yes
11:26:42 <Jeanne-Kamikaze> in what package is Data.ByteString.Search ?
11:27:06 <dafis> Jeanne-Kamikaze: stringsearch
11:27:18 <dafis> @hackage stringsearch
11:27:19 <lambdabot> http://hackage.haskell.org/package/stringsearch
11:27:21 <Jeanne-Kamikaze> how can you tell ?
11:27:32 <dafis> Jeanne-Kamikaze: I'm the maintainer
11:27:37 <Jeanne-Kamikaze> ok xD
11:27:42 <mike-burns> Hah.
11:27:45 <_kit_> lol.
11:27:50 <mike-burns> @hoogle Data.ByteString.Search
11:27:50 <lambdabot> package binary-search
11:27:50 <lambdabot> package infinite-search
11:27:50 <lambdabot> package local-search
11:28:36 <mike-burns> Jeanne-Kamikaze: To answer the "how can you tell" question, sometimes http://haskell.org/hoogle/?hoogle=Data.ByteString.Search gives useful results.
11:28:48 <mike-burns> However this time there are a whole slew of results.
11:29:05 <Jeanne-Kamikaze> ah ok, thanks
11:29:13 <Jeanne-Kamikaze> I was looking in the actual page
11:30:26 <dafis> mike-burns: but all three are wrong, none of those packages has the module
11:30:51 <mike-burns> Hilarious, isn't it?
11:31:26 <mike-burns> So I don't know how he can tell which package it's in, aside from asking in #haskell and hoping the maintainer gives an answer.
11:32:34 <fryguybob> hayoo can give good results for packages:   http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:Data.ByteString.Search
11:33:22 <mike-burns> Ah, good call.
11:33:44 <mike-burns> I always forget about Hayoo because, as demonstrated above, you can't link to it properly and the UI is too ... exciting.
11:35:26 <fryguybob> hehe, yeah.
11:36:21 <fryguybob> I think this works for linking:  http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Data.ByteString.Search
11:40:58 * steakknife is looking for notes on the Galois talk at a Bay Area Haskell event 2010 discussing Domain Specific Operating Systems.
11:49:46 <clsmith> @pf (\x y -> x == y || y == x)
11:49:47 <lambdabot> Maybe you meant: bf pl
11:49:51 <clsmith> @pl (\x y -> x == y || y == x)
11:49:52 <lambdabot> ap (ap . ((||) .) . (==)) (==)
12:01:36 <gbacon> I hoped Data.List.subsequences would be strict subsequences, but it's more like subsets
12:01:57 <gbacon> is what I'm after as simple as tails . inits?
12:02:48 <dafis> gbacon: perhaps tails . tail . inits
12:03:08 <dafis> > tails $ inits [1,2]
12:03:10 <lambdabot>   [[[],[1],[1,2]],[[1],[1,2]],[[1,2]],[]]
12:03:19 <dafis> > tails . tail $ inits [1,2]
12:03:21 <lambdabot>   [[[1],[1,2]],[[1,2]],[]]
12:03:42 <dafis> > map tails . tail $ inits [1,2]
12:03:44 <lambdabot>   [[[1],[]],[[1,2],[2],[]]]
12:04:03 <gbacon> > scanr $ tails [1,2,3]
12:04:04 <lambdabot>   Couldn't match expected type `a -> b -> b'
12:04:04 <lambdabot>         against inferred type `[...
12:04:10 <dafis> > map (init . tails) $ inits [1,2]
12:04:12 <lambdabot>   [[],[[1]],[[1,2],[2]]]
12:04:12 <gbacon> > scanr (:) tails [1,2,3]
12:04:13 <lambdabot>   Couldn't match expected type `[a]'
12:04:14 <lambdabot>         against inferred type `[a1] -> [...
12:04:25 <gbacon> > scanr (:) $ tails [1,2,3]
12:04:26 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [[[t]]])
12:04:26 <lambdabot>    arising from ...
12:04:56 <gbacon> > scanr (:) [] $ tails [1,2,3]
12:04:57 <lambdabot>   [[[1,2,3],[2,3],[3],[]],[[2,3],[3],[]],[[3],[]],[[]],[]]
12:06:02 <derrida> I'm having trouble to get a binary compiled that will run a target system. my local machine is x86_64 but i downloaded the i386 version of ghc at the suggestion of a kind fellow in here last night. I recompiled using the 32 bit version and I still get the same "error" returned: "-bash: ./knapsack: cannot execute binary file". Anyone know why this might be happening?
12:06:14 <derrida> (target is i386)
12:06:44 <cheater> > inits [1, 2, 3]
12:06:45 <lambdabot>   [[],[1],[1,2],[1,2,3]]
12:06:51 <cheater> > tails [1, 2, 3]
12:06:52 <lambdabot>   [[1,2,3],[2,3],[3],[]]
12:07:27 <cheater> :t scanr
12:07:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
12:08:30 <cheater> > scanr (:) [] $ [[1], [2, 3], [4]]
12:08:31 <lambdabot>   [[[1],[2,3],[4]],[[2,3],[4]],[[4]],[]]
12:08:41 <gbacon> > concat $ map init $ tails [1,2,3]
12:08:42 <lambdabot>   [1,2,2*Exception: Prelude.init: empty list
12:08:46 <Eduard_Munteanu> derrida: what does   file ./knapsack   say?
12:08:52 <Eduard_Munteanu> Also, permissions.
12:09:13 <gbacon> > concat $ map inits $ tails [1,2,3]
12:09:14 <lambdabot>   [[],[1],[1,2],[1,2,3],[],[2],[2,3],[],[3],[]]
12:09:54 <gbacon> that's from "Calculating Functional Programs" by Gibbons (1997)
12:10:24 <derrida> ls
12:10:28 <gbacon> but it has cubic complexity
12:10:33 * derrida is embarassed.
12:11:06 <derrida> Eduard_Munteanu: interesting, they are both ELF 64-bit
12:11:34 <Eduard_Munteanu> derrida: maybe you didn't pass -fforce-recomp and GHC skipped recompiling?
12:12:06 <Eduard_Munteanu> Make sure you're using the right GHC as well.
12:14:27 <derrida> Eduard_Munteanu: hm, it looks like i must have not been using the right one before, using the "right" one is producing a slew of assembler messages: "Error: invalid instruction suffix for `push'"
12:15:10 <Eduard_Munteanu> Hm... I guess it's using the 64-bit toolchain.
12:16:23 <Eduard_Munteanu> derrida: what GHC version is that?
12:16:28 <derrida> 7.0.2
12:17:56 <Eduard_Munteanu> derrida: can you try adding -opta--32 to the cmdline?
12:18:33 <derrida> (7.0.3 sorry)
12:19:03 <derrida> it didn't like that --32 "gcc: error: unrecognized option ‘--32’"
12:19:18 <Eduard_Munteanu> Going through gcc, hm...
12:19:28 <Eduard_Munteanu> derrida: use -optc-m32 then
12:20:48 <hpaste> derrida pasted “ghc output” at http://hpaste.org/54504
12:23:44 <Eduard_Munteanu> derrida: hm, I think the linker also needs that... add -optl-m32 as well. And make sure those libs are reachable from LD_LIBRARY_PATH
12:23:57 <Eduard_Munteanu> (or add -optl-L paths)
12:24:00 <derrida> they should be
12:26:23 <Eduard_Munteanu> Ah, I guess they are, then just add that option.
12:27:33 <derrida> hmm, i get the slew of assembler messages again
12:29:39 <Eduard_Munteanu> derrida: oh.. right... try this: -optc-m32 -opta-m32 -optl-m32
12:29:50 <Eduard_Munteanu> It's calling gcc as the assembler I guess.
12:30:05 <dylex> derrida: what does ghc --info show for Target platform?
12:30:43 <derrida> dylex: I can't install ghc on the target due to disk quota/permissions
12:31:14 <dylex> derrida: yes, I understand, but with the ghc you're using to build, run ghc --info
12:31:15 <Eduard_Munteanu> He's using a 32bit GHC on a 64bit system to "cross-compile".
12:31:19 <derrida> Eduard_Munteanu: wooh, that worked
12:31:48 <Eduard_Munteanu> I wonder if GHC isn't supposed to detect that by itself.
12:32:58 <dylex> Eduard_Munteanu: I just wanted to make sure.  I wouldn't expect building 32-bit assembly with a 64-bit assembler to give you invalid suffix errors.
12:33:36 <Eduard_Munteanu> dylex: I don't think there's a pushw on 64bit for instance
12:35:02 <Eduard_Munteanu> I mean, doing stuff like   push %eax
12:35:03 <derrida> so strange, i upload the binary and run on the target system and now it just says -bash: "./knapsack32: No such file or directory"
12:35:16 <Eduard_Munteanu> derrida: permissions?
12:35:24 <dylex> derrida: what does ldd ./knapsack32 show?
12:35:38 <derrida> they look right to me, "-rwxr-xr-x"
12:36:01 <derrida> dylex: hm: /usr/bin/ldd: line 117: ./knapsack32: No such file or directory
12:36:48 <dylex> derrida: what about on the build machine? probably that means the right linker (version) isn't there (ld-*.so)
12:37:10 <Eduard_Munteanu> Hm...
12:37:33 <Eduard_Munteanu> GHC should link dynamically to system libs. Maybe there's no ld.so but a ld.so.x?
12:38:45 <hpaste> derrida pasted “ldd output” at http://hpaste.org/54505
12:39:08 <derrida> nothing jumping out at me
12:39:30 <Eduard_Munteanu> Ah, so it works.
12:39:35 <dylex> derrida: do all those files exist on the target?
12:39:37 <derrida> that's from the base system
12:40:02 <Eduard_Munteanu> /lib32 on a 32bit system?
12:40:09 <derrida> unlikely
12:40:14 <Eduard_Munteanu> Ah.
12:40:37 <dylex> Ideally that /lib32 path shouldn't be hard-coded, but it may be.
12:41:06 <Eduard_Munteanu> Bah, probably an -rpath
12:44:11 <Eduard_Munteanu> derrida: try /lib/ld-linux.so.* --inhibit-rpath /lib32/ld-linux.so.2 ./knapsack32    or some variation on that (replace '*' with the actual so number in /lib)
12:44:59 <Eduard_Munteanu> Presumably you can't make a symlink on that system, that might've been easier.
12:45:45 <derrida> unfortunately, i have very limited permissions on the target
12:49:03 <derrida> Eduard_Munteanu: well, on the local system that runs fine
12:49:22 <Eduard_Munteanu> I meant on the target.
12:49:33 <derrida> ;)
12:50:33 <derrida> ./knapsack32: /lib/tls/i686/cmov/libc.so.6: version `GLIBC_2.9' not found (required by ./knapsack32)
12:51:02 <dylex> yeah, sounds like you have an older libc version on the target.
12:51:24 <derrida> the target is definitely running old stuff :\
12:52:06 <parcs> try fully statically compilining the executable with -optl-static
12:52:19 <hpaste> “Theo Belaire” pasted “Graph transversal” at http://hpaste.org/54506
12:53:04 <Eduard_Munteanu> Yeah, I guess that might do.
12:54:58 <Eduard_Munteanu> (you might want to 'strip' the resulting executable if you think it's too large)
12:56:26 <hpaste> derrida annotated “ghc output” with “ghc output (annotation)” at http://hpaste.org/54504#a54507
12:57:22 <derrida> btw, /home/ian/zz is not me :)
12:59:36 <Eduard_Munteanu> derrida: hm, try adding -optl-lpthread
12:59:46 <Eduard_Munteanu> Erm,no
13:00:26 <Eduard_Munteanu> Add both -optc and -optl like above, I'm not sure :)
13:00:33 <Eduard_Munteanu> Can't hurt :)
13:00:45 <Eduard_Munteanu> Might also do to supply -optc-static for GCC.
13:00:50 <uniquenick> can anyone help me figure out a yesod/warp/network issue?  I realize its not really #haskell material, but #yesod is pretty dead
13:01:30 <alistra> do remote haskell jobs exist? :D
13:01:44 <alistra> i can't seem to find normal haskell jobs :P
13:02:47 <int-e> "normal"?
13:02:57 <alistra> not remote
13:04:12 <Eduard_Munteanu> Working from home, you mean?
13:04:17 <alistra> yes
13:04:28 <alistra> remote = working from home
13:04:34 <alistra> normal = not working from home
13:04:38 <Eduard_Munteanu> Hm, I'd kinda like working like that, though not now.
13:05:06 <alistra> i like working from the office but now i have university to finish :p
13:05:33 <Cale> This isn't exactly a Haskell question as such, but what do Windows users usually do about cmd.exe's awkward default choice of text encoding?
13:05:35 <adamCS> hey guys. My lecturer asked for a problem sheet to be solved all using accumulators. Just wondering is an accumulator always a number? Can it be a list I keep adding to and then return?
13:06:01 <alistra> adamCS: it can be a list
13:06:20 <Eduard_Munteanu> Cale: I remember simply sanitizing console output so it wouldn't crash :(
13:06:28 <Eduard_Munteanu> I don't know if that's been fixed.
13:06:28 <alistra> adamCS: you use accumulators so your calls are tail
13:06:45 <alistra> you know what a tail call is adamCS?
13:07:01 <Eduard_Munteanu> (or if there's a better way)
13:07:20 <Cale> (A friend of mine is getting a default System.IO.localeEncoding of CP437 unless we run chcp 65001 by hand before starting ghci or the compiled program)
13:07:34 <fryguybob> Cale: As far as I know there isn't a good answer.
13:08:50 <adamCS> alistra: I'm assuming you mean I recurse through xs of (x:xs)?
13:09:15 <alistra> not really
13:09:46 <alistra> i mean if you call your function recursively in your function, then you don't do anything with the returned value, just return it back
13:09:49 <alistra> for example
13:10:01 <alistra> fact n = n*fact(n-1)
13:10:19 <alistra> isn't tail, because you multiply the recursive call by n
13:10:32 <alistra> with an accumulator you should do it like this:
13:10:32 <adamCS> oh ok
13:10:44 <alistra> fact n acc = fact (n-1) (acc*n)
13:10:56 <alistra> fact 0 acc = acc
13:11:20 <alistra> adamCS: we do such wizardry, so the compiler can optimize the code and change it into a while loop
13:11:32 <adamCS> oh ok
13:11:39 <adamCS> I haven't fully understood it then
13:11:44 <adamCS> think I've did a mix of both
13:11:47 <mike-burns> But in general, and especially relevant to your question: an accumulator is nothing magical, and it can be anything you need it to be.
13:11:50 <alistra> (or longjump from the deepest recursed part to the beginning and return the answer)
13:12:11 <mike-burns> It's simply a value that you pass along, accumulating, until you're done. Then you produce it.
13:12:21 <alistra> so you don't have to do all those n return statements
13:12:27 <alistra> you can just jump to the first return
13:13:09 <alistra> http://en.wikipedia.org/wiki/Tail_call
13:13:41 <mike-burns> Tail calls have little to do with recursion, mind you. Recursive functions are just one of many places where tail calls are helpful.
13:14:08 <hpaste> adamCS pasted “accumulator?” at http://hpaste.org/54509
13:14:20 <adamCS> alistra: just pasted what I had
13:15:58 <mike-burns> Does your lecturer expect these to be tail calls?
13:16:02 <adamCS> sorry I pasted the wrong thing...
13:16:52 <adamCS> wait no I didn't... sorry I've had a lot of versions of this function.
13:17:18 <Eduard_Munteanu> Cale: maybe Cygwin or mingw/msys might give you a better environment?
13:17:37 <Eduard_Munteanu> I haven't tried that myself though
13:17:40 <adamCS> mike-burns: he just says "use the concept of accumulators"
13:18:21 <Cale> Eduard_Munteanu: that's an interesting idea
13:19:15 <adamCS> alistra: did you see the paste? I think I was trying to do accumulators as you described them but I was performing another calculation on the return on the call
13:19:44 <hpaste> alistra pasted “ftfy” at http://hpaste.org/54510
13:21:45 <alistra> your teacher can moan that you exponentiate each time
13:21:48 <alistra> but meh
13:21:56 <adamCS> alistra: hmm I thought it would have been like cheating if I used ^
13:22:04 <adamCS> alistra: yeah exactly haha
13:22:10 <alistra> you can have another accumulator for the value, and just multiply it
13:23:04 <adamCS> alistra: or "head acc"?
13:23:04 <ddarius> > let power n = iterate (n*) 1 in power 3
13:23:05 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
13:23:25 <ddarius> Doing this with an accumulator at all is a bad approach...
13:24:25 <adamCS> ddarius: Doesn't feel natural. But I guess he's just trying to teach us stuff. He asks us to use an accumulator to generate the fibonacci sequence too... does that make sense?
13:24:44 <hpaste> alistra pasted “i should get paid for this stuff” at http://hpaste.org/54511
13:24:45 <ddarius> adamCS: It depends.
13:26:32 <adamCS> alistra: we didn't use $ yet so can't do that. I wish I could take your last one but get the last elem of acc in an efficient fashion
13:26:54 <dschoepe> adamCS: $ is just shorthand so you need less parens
13:27:03 <dschoepe> It's the same as reverse (valacc : acc)
13:27:22 <adamCS> alistra: ok ya
13:28:20 <hpaste> alistra pasted “and fibo” at http://hpaste.org/54512
13:28:20 <adamCS> alistra: am I right in saying that this needs an extra accumulator just because it's more efficient than getting the last elem of the list accumulator?
13:28:21 <rwbarton> Without $ adamCS cannot pay you.
13:28:56 <dschoepe> > let (€) f x = f x in (+1) € 5
13:29:05 <lambdabot>   6
13:29:29 <alistra> adamCS: you're not right, the head would be more efficient
13:29:31 <alistra> but is ugly :P
13:29:34 <ddarius> In this case you can use an "accumulator" and make a non-tail recursive solution that will be more efficient, more flexible, and simpler than the ones being suggested.
13:30:25 <alistra> real men do fibo like this let f = 1:1:zipWith (+) f (tail f)
13:30:29 <adamCS> alistra: so you're saying I could take the head each time and then reverse the whole lot on the top level?
13:30:34 <alistra> let f = 1:1:zipWith (+) f (tail f) in take 5 f
13:30:38 <alistra> > let f = 1:1:zipWith (+) f (tail f) in take 5 f
13:30:39 <lambdabot>   [1,1,2,3,5]
13:30:43 <alistra> > let f = 1:1:zipWith (+) f (tail f) in take 15 f
13:30:44 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
13:30:50 <adamCS> alistra: I dont think he intended us to have 2 accumulators
13:31:24 <alistra> so change each valacc to (head acc)
13:31:31 <alistra> and head has problems with being partial
13:31:39 <adamCS> ddarius: how do you mean?
13:31:41 <alistra> so it would be nicer if you'd pattern match
13:31:56 <adamCS> ddarius: I'm not looking for a full solution really
13:32:20 <adamCS> alistra: ya ok
13:33:40 <adamCS> alistra: in this example http://hpaste.org/54510 if I do "acc :1" instead of "1:acc" for count==0 how would I know when to reverse it?
13:33:43 <ddarius> adamCS: Well, one thing is that it's simpler just to produce all powers and then select how many you want, and, relatedly, you can have it produce results incrementally rather than having to wait until all values are calculated.
13:34:15 <alistra> adamCS: you can't do acc : 1
13:34:27 <alistra> because acc :: [Int] and 1 : Int
13:34:39 <alistra> and (:) :: a -> [a] -> [a]
13:34:49 <alistra> you would have to
13:34:49 <adamCS> alistra: I think I meant acc:[1]
13:34:56 <alistra> acc ++ [1]
13:35:01 <alistra> but it sucks badly
13:35:16 <adamCS> alistra: what's wrong with acc:[1]?
13:35:16 <alistra> because to add something to the end of the list you have to traverse it
13:35:17 <ddarius> > let power n = powerAcc 1 where powerAcc !acc = acc:powerAcc (n*acc)
13:35:18 <lambdabot>   not an expression: `let power n = powerAcc 1 where powerAcc !acc = acc:powe...
13:35:22 <ddarius> > let power n = powerAcc 1 where powerAcc !acc = acc:powerAcc (n*acc) in power 3
13:35:23 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
13:35:32 <adamCS> ddarius: hmm thinking about that still
13:35:32 <alistra> > [2,3,4]:1
13:35:33 <lambdabot>   No instance for (GHC.Num.Num [[t]])
13:35:34 <lambdabot>    arising from a use of `e_12341' at <...
13:35:36 <alistra> > [2,3,4]:[1]
13:35:38 <lambdabot>   No instance for (GHC.Num.Num [t])
13:35:38 <lambdabot>    arising from a use of `e_12341' at <in...
13:35:41 <alistra> > [2,3,4]++[1]
13:35:43 <lambdabot>   [2,3,4,1]
13:36:02 <adamCS> alistra: ugh forgot acc was a list
13:36:31 <ddarius> That definition was basically iterate inlined (made a bit stricter.)
13:36:56 <alistra> not sure though if what's the deal with iterating over the list lazily
13:37:18 <adamCS> ddarius: so can I "just to produce all powers" in a list using accumulators and select how many of that list I want?
13:38:01 <ddarius> adamCS: That would be the idiomatic way to do it in Haskell.  It's easy to modify the solution I provided to count down and stop when finished, but the counting down code takes up more space than the rest of the code.
13:39:03 <ddarius> Whereas, I can separate those concerns using lazy evaluation: power cnt n = take cnt (iterate (n*) 1)
13:40:08 <adamCS> ddarius: can't find your accumulator example
13:47:31 <hpaste> “Theo Belaire” annotated “Graph transversal” with “Graph transversal (annotation)” at http://hpaste.org/54506#a54513
13:56:01 <KitB> @hoogle Int -> [a] -> [a]
13:56:02 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:56:02 <lambdabot> Data.List drop :: Int -> [a] -> [a]
13:56:02 <lambdabot> Prelude take :: Int -> [a] -> [a]
14:06:54 <shurikas> ghc.exe: libcairo-script-interpreter-2: The specified procedure could not be found.
14:07:02 <shurikas> this is when trying to make a gtk2hs simple app
14:07:15 <shurikas> when enabling GHCi debugger
14:08:23 <homovitruvius> hi guys, is there anything that allow Emacs to jump to the definition of Haskell functions (in the standard prelude or cabal installed)? I can get type signatures, but I'd find the implementation useful while learning.
14:09:15 <ddarius> The source may not be available for such packages, but you could use normal tagging systems.
14:09:25 <ddarius> @google hasktag
14:09:28 <lambdabot> http://hackage.haskell.org/package/hasktags
14:09:28 <lambdabot> Title: HackageDB: hasktags-0.68.1
14:11:28 <roconnor> aww, OCaml has Ropes.
14:11:46 * roconnor wonders if anyone completed that bytestring "rope" idea using fingertrees
14:12:10 <ddarius> Yes, there is also data-ropes and, I believe, some others.
14:12:51 <homovitruvius> I was hoping in something that would know about the installed prelude and was able to get into cabal's tarfiles as well, but I can survive with tags
14:14:11 <Sgeo> http://hackage.haskell.org/package/gtk build failure?
14:14:16 <Sgeo> Any working things these days?
14:14:24 <ddarius> homovitruvius: The installed version of the Prelude is a binary usually.
14:15:08 <KitB> pattern matching against a record in a do block with <- ?
14:15:13 <ddarius> homovitruvius: You can very likely do something to have the tag files made every time you cabal install a package.
14:15:16 <KitB> Is it done?
14:15:22 <ddarius> Sure.
14:15:34 <KitB> Is there something I need to do to make it work?
14:15:35 <carpi> recommended editor for writing haskell code?
14:15:39 <ddarius> KitB: No.
14:15:48 <KitB> Huh, perhaps I spelled something wrong
14:15:50 <ddarius> carpi: The one you are familiar with.
14:16:14 <homovitruvius> ddarius: yep, I'll setup my own scripts to create a TAGS file from the stadard libs + cabal. Thanks.
14:16:37 <carpi> ddarius: the one im familiar with is hampering my productivity. No syntax highlighting...nothing
14:16:55 <ddarius> carpi: Are you using notepad?
14:17:11 <derrida> Eduard_Munteanu: so, i'm still struggling to get this to compile properly. I've now installed a 32-bit chroot which I can compile from and be sure of no 64bit path shenanigans. I compiled and went to run and discovered that the target has an older version of gmp (gmp 4.x) instead of my system which uses gmp5. compiling with -optc-static doesn't help and -optl-static fails to compile,
14:17:33 <carpi> ddarius: Leafpad . very rudimentary light weight text editor
14:18:13 <carpi> ddarius: opens faster than xterminal. thats how light it is.. and thus almost useless
14:20:17 <NemesisD> say I've got a function longerThan3 :: [a] -> Bool, is the proper way to define this to have a recursive counter so as not to force traversal of the list with "length" ?
14:21:42 <roconnor> NemesisD: or just a pattern match
14:22:02 <NemesisD> roconnor: the  3 in practice might actually be 300
14:22:08 <roconnor> longerThanThree (_:_:_:_) = True    | otherwise False
14:22:24 <roconnor> oh okay
14:22:39 <roconnor> longerThan300 = null (take 300)
14:22:50 <roconnor> (+/- 1)
14:22:52 <ddarius> NemesisD: That would work.  If you wanted a compact solution you could just use length (take n xs) == n
14:22:54 <roconnor> er
14:22:57 <roconnor> I mean drop
14:23:05 <roconnor> longerThan300 = not (null (drop 300))
14:23:08 <roconnor> something like that
14:23:12 <ddarius> Really, though, this sounds like a stupid function(s) to make.
14:23:22 <doserj> or genericLength with Peano Naturals
14:23:38 <doserj> (lazy Nats)
14:23:44 <roconnor> NemesisD: booleans are somewhat bad to use
14:23:49 <NemesisD> whys that
14:23:52 <roconnor> except for bit twiddling
14:23:55 <ddarius> What roconnor said.
14:24:16 <roconnor> NemesisD: mostly because case analysis on booleans don't refine anything
14:24:31 <roconnor> NemesisD: compare this with case analysis on lists that bring different variables into scope
14:24:32 <ddarius> NemesisD: It's much better to return something that "proves" that whatever you're checking holds, than to return a boolean that indicates it, but may become out of sync.
14:24:53 <roconnor> NemesisD: What-his-name has a nice blog post on the subject ... Robert Harper?
14:25:23 <roconnor> NemesisD: basically it is better to write a function (often isomorphism) from YourData -> Either BadBit GoodBit
14:25:30 <roconnor> or more generally
14:25:30 <ddarius> NemesisD: The latter leads to stupidity like if not (null xs) then head xs else ... where you have to use an unsafe function that assumes a condition that you check separately leading to possible errors in larger functions or with maintenance.
14:25:38 <roconnor> YourData -> Either ABit BBit
14:25:43 <ddarius> roconnor: Yes, Bob Harper has a decent blog post about this.
14:26:21 <NemesisD> this is more ofr filtering
14:26:29 <Cale> ddarius: Hehe, the extreme example of that is using type equalities and unsafeCoerce
14:26:38 <NemesisD> its a business logic level boolean
14:26:58 <NemesisD> i'm doing price averaging and if the data does not match some minimum criteria, it is thrown out and not calculated
14:26:58 <ddarius> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
14:27:40 <roconnor> > map (not . null  . drop 300) . map replicate . [299, 300, 301]
14:27:41 <lambdabot>   Couldn't match expected type `[a]'
14:27:41 <lambdabot>         against inferred type `a1 -> [a1]'
14:27:49 <roconnor> > map (not . null  . drop 300) . map (flip replicate ()). [299, 300, 301]
14:27:50 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
14:27:50 <lambdabot>    arising from the literal `...
14:27:53 <Cale> (which can actually be an extremely useful tactic for making externally-typesafe libraries)
14:27:56 <ddarius> NemesisD: So you have InputData -> Maybe GoodData.
14:28:33 <roconnor> > map (not . null  . drop 300) . map (flip replicate ()) $ [299, 300, 301]
14:28:35 <lambdabot>   [False,False,True]
14:28:48 <roconnor> > map (null  . drop 300) . map (flip replicate ()) $ [299, 300, 301]
14:28:49 <lambdabot>   [True,True,False]
14:28:59 <NemesisD> [Prices] -> [Results] and Price -> Maybe Result
14:29:13 <ddarius> Even if this was some check that you wanted to display to the user, there are probably a bunch of others and the user would probably want more than a bit of information from your analyses.
14:29:23 <roconnor> Acutally I've been finding (Maybe ()) is often a good replacement for Bool
14:29:37 <ddarius> NemesisD: I recommend looking at the referenced blog post as well.
14:29:38 <Cale> We have some nice heterogeneous graphs in our new FRP implementation which involve a fair amount of GADT type witnesses and under-the-covers use of Any.
14:29:55 <doserj> and Either NoResult Result is a good replacement for Maybe Result :)
14:30:05 <NemesisD> reading it now
14:30:35 <ddarius> doserj: Either ReasonForFailure Result
14:30:46 <doserj> that's even better, yes
14:31:02 <NemesisD> the issue here is that the reason is not exceptional and does not need to be logged for this application
14:31:02 <roconnor> Though in pratice: Either String Result
14:31:14 <NemesisD> it will probably be inserting a null value in a db
14:31:24 <roconnor> NemesisD: the thing is that using Either lets the user of the function decide if the error message is worth keeping or not.
14:31:28 <NemesisD> erm the lack of a reason is not exceptional*
14:31:43 <roconnor> NemesisD: though people here often say that if there is only one way a function can fail to use Maybe
14:31:49 <Cale> If there's only one possible reason for failure, the use of Either is excessive though
14:31:53 <roconnor> I'm not entirely sure I'm convinced yet though
14:31:53 <Cale> (possibly)
14:32:07 <rwbarton> this sounds like a good argument taken way too far
14:32:12 <rwbarton> :t filter
14:32:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:32:20 <rwbarton> am I not supposed to use this
14:32:22 <Cale> filter is pretty useful :)
14:32:25 <rwbarton> right
14:32:30 <NemesisD> yeah this bit is a pure function, the data either qualifies to have statistics to  run on it or it does not
14:32:48 <ddarius> rwbarton: catMaybes . map (something producing maybes)
14:33:12 <Cale> Use the smallest type which satisfies your need for representing things. Bool is often exactly what is required.
14:33:14 <roconnor> @hoogle [a] -> Either [a] [a]
14:33:15 <lambdabot> No results found
14:33:26 <roconnor> @hoogle [a] -> Either [b] [c]
14:33:26 <lambdabot> No results found
14:33:30 <roconnor> @hoogle partition
14:33:31 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
14:33:31 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
14:33:31 <lambdabot> Data.Text partition :: (Char -> Bool) -> Text -> (Text, Text)
14:33:37 <roconnor> ah
14:34:01 <roconnor> rwbarton: in theory you are supposed to use partitionEithers, ... but I don't think anyone actually does
14:34:20 <roconnor> rwbarton: (well a combination of map and partitionEithers)
14:34:24 <ddarius> gPartition :: (a -> b) -> [a] -> Map b [a]
14:34:35 <Eduard_Munteanu> The use of Bool is problematic in theorem provers.
14:34:43 <rwbarton> I don't really believe in "supposed to use".
14:34:53 <ddarius> The use of Bool is problematic in programs.
14:34:55 <roconnor> rwbarton: neither does anyone else. :)
14:35:02 <Cale> roconnor: This is similar to how unfoldr is almost never used because it's often more convenient to write things in terms of iterate/takeWhile/map
14:35:10 <roconnor> oh?
14:35:17 * roconnor uses unfoldr quite a bit
14:35:21 <Eduard_Munteanu> Yeah, but arguably in programs you can find a way around it.
14:35:29 <illissius> unfoldr is almost never used because it's weird.
14:35:42 <Cale> Well, it's good when you already have a Maybe-tuple-producing thing.
14:35:43 <rwbarton> Anyways, sorry to come back to this point but I think when the question is "how do I write a function that checks whether a list of at least 3, I shouldn't use length should I?" then discouraging the asker from using Bools and talking about theorem provers is not really helpful.
14:35:49 <ddarius> Cale: I don't think I've ever not used unfoldr because I could use that combination instead.  I may not have used unfoldr when all I need is iterate.
14:35:50 <illissius> and people don't learn how to use it
14:35:59 <roconnor> rwbarton: use (null . drop 3)
14:36:07 * illissius is everyone
14:36:49 <ddarius> rwbarton: No one said anything about theorem provers until very recently, and the question is a stereotypical example of a bad case for booleans, and several solutions were provided.
14:37:05 <Eduard_Munteanu> Oh, maybe... I just made that point because Bool can be a showstopper there.
14:37:32 <derrida> So, I'm trying to compile a binary that will run on a target system. The target system has libgmp.so.3 while my local system is using gmp5 with libgmp.so.10, is there something I can do to get the program to link using libgmp.so.3 instead? (I have gmp4, libgmp.so.3 installed for compatibility). ldd <binary> on the system shows 1 not found entry: libgmp.so.10 => not found
14:38:04 <Eduard_Munteanu> And somehow I think this isn't limited particularly to Bool.
14:38:09 <derrida> (ldd output is from the target system)
14:38:10 <ddarius> rwbarton: In this case, I doubt the discussion was "not helpful."  NemesisD got multiple solutions and a chance to consider perspective.
14:38:22 <Eduard_Munteanu> There probably are lots of other types that don't give enough information.
14:38:42 <wavewave> hi.
14:38:56 <ddarius> Eduard_Munteanu: It isn't.  You should try to return values that "can't be wrong" rather than structures that are right "only if..."
14:38:56 <wavewave> is there any standard implementation of alternating list on hackage?
14:39:28 <wavewave> list of type a and type b in an alternating way
14:39:39 <wavewave> a b a b a b
14:40:27 <wavewave> though it is not difficult to implement by myself. do not want to reinvent the wheel.
14:40:44 <ddarius> rwbarton: What I find not helpful are people requiring the asker to provide evidence of a performance problem before offering any advice on how to write better performing code.
14:40:50 <Cale> wavewave: Why not [(a,b)]?
14:41:03 <illissius> ...it's nice how if you search for something relating to html, google will match every damn url and return amazingly useful results.
14:41:08 <rwbarton> ddarius: agreed
14:41:22 * illissius would've thought they'd have figured this out by now
14:41:27 <roconnor> Cale: no odd length lists?
14:41:37 <Cale> roconnor: oh, I suppose :P
14:41:40 <wavewave> Cale: yeah. that's the simplest implementation.
14:41:52 <ddarius> (Either a b, [(a,b)])
14:41:54 <Cale> wavewave: Are odd-length lists a concern for you?
14:42:17 <Cale> Or does every a need to have a corresponding b anyway?
14:42:20 <wavewave> Cale: yes.. number of a and number of b can be different by one.
14:42:31 <wavewave> also b can start..
14:42:37 <Cale> wavewave: okay, what are you actually using this for? :)
14:42:48 <roconnor> ddarius: BTW, I tried defining non-empty lists as data NEList a = NECons a (NEList a) | NENil a and it seems really really akward to use.
14:42:57 <wavewave> Cale: :-)
14:42:57 <Cale> roconnor: it is
14:43:03 <ddarius> type NonEmptyList a = (a, [a])
14:43:04 <roconnor> ddarius: I haven't tried (a,[a]) yet, but I imagine it will be easier
14:43:11 <roconnor> I'm quite surprised
14:43:23 <wavewave> Cale: this is an intermediate structure of some gui program.
14:43:30 <ddarius> roconnor: You lose all of the standard/semi-standard list processing functions.
14:43:46 <wavewave> Cale: there is a big structure and now I do some kind of hit test.
14:43:55 <ddarius> Though some can be recovered from Traversable, etc. instances.
14:43:59 <roconnor> ddarius: well, making it an instance of Foldable and Traversable helps alot
14:44:34 <roconnor> I think it is worth the price in order to get "proof" that lists are non-empty at points in my program
14:44:55 <wavewave> Cale: to be efficient, I wanna do some preliminary bounding box hit test first... and put those element hitted aside from others which is not hitted.
14:45:17 <Cale> okay...
14:45:22 <wavewave> Cale: but still want to preserve order of the whole structure.
14:45:49 <wavewave> Cale: I know how to implement this, but just want to know whether I can reduce my effort ;-)
14:46:30 <Cale> I don't know of an alternating list library, and probably what you're doing warrants the use of a custom datatype for expressing what's going on a bit more clearly anyway.
14:46:47 <ddarius> roconnor: Well, if the libraries were more geared to it, I think you'd find it easier than the current situation overall.
14:46:52 <Cale> You might just be able to get away with [Either a b]
14:46:54 <derrida> Eduard_Munteanu: wooh! i managed to trick it! :D it's working. I just deleted the existing libgmp.so symlink and made a new one to the proper lib.
14:47:04 <wavewave> Cale: yeah. I had better make my own data type.
14:47:06 <Cale> unless the alternation is really essential
14:47:27 <wavewave> Cale: probably this is useful for other purposes.
14:47:33 <derrida> Eduard_Munteanu: dylex: parcs: thank you guys for all the help. I really appreciate it.
14:47:56 <wavewave> Cale: if you are interested, the source code I am writing is online.
14:48:24 <wavewave> Cale: http://www.github.com/wavewave/hxournal
14:48:42 <wavewave> haskell clone of xournal program (pen notetaking program)
14:48:56 <wavewave> the core part is pretty done now
14:50:13 <kfish> hi wavewave!
14:50:29 <wavewave> kfish: hi!
14:51:20 <dropdrive> Wow, I can't imagine writing xournal in haskell...
14:51:24 <wavewave> haskell is very good in GUI programming.
14:51:36 <wavewave> dropdrive: hi, are you a user of xournal?
14:51:56 <wavewave> dropdrive: hxournal is almost as fast as xournal (written in c)
14:51:57 <dropdrive> wavewave: No, but I've seen people use it.
14:52:05 <dropdrive> wavewave: Did you write xournal too?
14:52:21 <wavewave> I know ezyang is a xournal user, too.
14:52:29 <wavewave> wavewave: I contributed to it before.
14:52:37 <wavewave> s/wavewave/dropdrive
14:52:54 <wavewave> I made a lasso selection tool for that.
14:53:23 <wavewave> but the original author stopped maintaining it and my contribution became still a patch.
14:53:47 <wavewave> on my computer, I use the lasso selection tool very productively.
14:53:48 <dropdrive> wavewave: How do LOC compare between yours and the C version?
14:53:49 <Cale> xournal looks like an extremely simple drawing app... I sure hope it's not hard to write in Haskell :)
14:54:05 <wavewave> Cale: indeed. it's very easy.
14:54:30 <wavewave> dropdrive: I didn't count it yet.. still in development so comparison is not fair ;-P
14:55:18 <wavewave> dropdrive: but I can guess loc can be 3-4 times smaller than c version finally
14:55:27 <dropdrive> Don't you have to worry about the GUI, keeping track of the pages, interacting with the stylus...
14:55:54 <wavewave> dropdrive: I use coroutine. pull-style GUI programming
14:56:16 <wavewave> that makes GUI programming like parser programming.
14:56:23 <wavewave> using iteratee.
14:56:42 <wavewave> it's much cleaner in seeing business logic.
14:56:46 <dropdrive> wavewave: I see, any good links?
14:57:15 <wavewave> conal elliott's Phooey library is similar to my approach.
14:57:34 <wavewave> but his library is using wxHaskell, and I had to use gtk2hs
14:57:40 <wavewave> to use stylus info.
14:58:27 <wavewave> coroutine GUI programming is between ordinary push style GUI programming and functional reactive programming.
15:03:32 <mm_freak> isn't there an optimized unzip operation for Data.Map?
15:04:13 <mm_freak> i'd like to turn 'Map k (a, b)' into 'Map k a' and 'Map k b'
15:04:19 <mm_freak> efficiently that is
15:08:04 <dylex> mm_freak: probably just map fst &&& map snd is good enough
15:09:07 <Jafet> mm_freak: toAscList?
15:09:33 <mm_freak> Jafet: i need Map, not []
15:09:39 <mm_freak> dylex: i'll go with that
15:09:42 <Jafet> Then unzip and fromAscList
15:10:21 <Jafet> @type M.map
15:10:23 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
15:10:47 <mm_freak> Jafet: again, i need Map, not []
15:10:51 <mm_freak> no lists involved
15:11:23 <Jafet> Ok, I see
15:16:19 <roconnor> wavewave: conal's GtkTV uses gtk2hs
15:30:18 <roconnor> containers appear to form a semiring
15:30:26 <roconnor> possibly a kleene algebra
15:31:10 <vav> is there some lib fn around already that does
15:31:13 <vav> let foo s v = s : [v] in \x y -> concat $ zipWith foo x y
15:31:52 <roconnor> vav: not really since foo is a unusual function
15:32:05 <vav> make sense
15:32:06 <roconnor> oh wait
15:32:10 <roconnor> I see what you are doing now
15:32:31 <roconnor> vav: how about concat (transpose [x,y]) ?
15:32:47 <rwbarton> I think that's slightly different if x is longer than y
15:33:24 <roconnor> > let foo s v = s : [v] in concat $ zipWith foo [1,2,3] [4,5]
15:33:24 <lambdabot>   [1,4,2,5]
15:33:42 <roconnor> > concat (transpose [[1,2,3],[4,5]])
15:33:43 <lambdabot>   [1,4,2,5,3]
15:33:55 <roconnor> rwbarton: good point
15:34:21 <vav> in this application they'll be of same length. they'll actually be in a let or where.
15:34:33 <vav> probably clearer to just use a one off
15:34:51 <roconnor> vav: I don't think you will find this function since there are various ways of handling unequal lists
15:35:03 <roconnor> so it is important that a user create the one they want
15:35:25 <vav> yeah, makes sense. Like "where is the split list function?" :-)
15:36:10 <alistra> @pl \x -> [x]
15:36:11 <lambdabot> return
15:36:16 <alistra> way to go
15:36:53 <vav> (join .) . zipWith ((. return) . (:))
15:37:04 <vav> that's a lot clearer. :/
15:38:30 <wavewave> roconnor: thanks for notifying me of GtkTV.
15:38:34 <ddarius> @hackage split
15:38:34 <lambdabot> http://hackage.haskell.org/package/split
15:38:51 <roconnor> in fact, containers probably from a plethory
15:39:00 <roconnor> wavewave: let me know if you get it to work
15:39:55 <hpaste> wavewave pasted “alternating list” at http://hpaste.org/54515
15:40:10 <wavewave> my version of alternating list..
15:40:20 <wavewave> I use GADTs for ensuring alternation.
15:41:09 <rwbarton> those constructors have the same type
15:48:15 <roconnor> Cale: do you happen to know what a phethory without negation is called?
15:48:51 <wavewave> roconnor : you are right.. BACons is completely unnecessary.
15:50:30 <roconnor> what is BACons?
15:51:11 <hpaste> wavewave annotated “alternating list” with “alternating list (annotation)” at http://hpaste.org/54515#a54516
15:51:50 <wavewave> roconnor : oh, I am sorry... I was answering to rwbarton
15:52:58 <tswett> Given a read function and a write function, is it easy to turn them into a Handle?
15:53:28 <magicman> wavewave: You don't even need GADTs for that.
15:53:46 <wavewave> magicman: yeah.. I realize that now :-P
15:54:19 <wavewave> good to post it here. :-P
15:54:23 <ddarius> wavewave: Note that this isn't actually using GADTs in any way.  data AlterList a b = Cons a (AlterList b a) | Nil
15:54:54 <ddarius> There is an extension to allow GADT syntax for non-GADT data types without allowing the full power of GADTs if desired.
15:55:27 <wavewave> ddarius: I know it.. Thank you anyway.
15:55:52 <JoeyA> tswett: Take a look at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Handle-Types.html#Handle  .  Doesn't look simple, though.
15:56:11 <tswett> Yeah.  I know that there's a complicated way to do it.  }:)
15:56:14 <JoeyA> The network package does it somehow, I think.
15:57:55 <tswett> \handle_@Handle__{..} -> do
15:58:03 <tswett> Yeah, that totally looks like it isn't magic.
15:58:23 <JoeyA> Is it possible to export a record selector such that it cannot be used to alter a record?  By alter, I mean e.g. foo {fooMember = 5}
15:59:03 <irene-knapp> no
15:59:22 <irene-knapp> you could export a function by the same name as the selector (from a different module)
15:59:45 <irene-knapp> but I don't think it's really a great idea
16:00:43 <JoeyA> thanks
16:01:36 <ddarius> If you are exporting the constructor, then it doesn't really matter whether or not you are exporting the fields.
16:02:21 <ddarius> (Well I guess you could construct a case where it matters.)
16:02:28 <JoeyA> ddarius: You can produce a value of the type without a constructor.
16:02:39 <JoeyA> e.g. defaultConfig {configSize = 1000}
16:18:20 <erider> is (x:xs) a representation of a list with two elements?
16:18:29 <cgroza> erider: no.
16:18:58 <erider> what does it mean
16:19:08 <JoeyA> > 1 : []
16:19:09 <lambdabot>   [1]
16:19:15 <JoeyA> > 1 : (2 : (3 : []))
16:19:17 <lambdabot>   [1,2,3]
16:19:27 <Ulfalizer> erider: it's the list you get by inserting x at the front of the list xs.
16:19:42 <Ulfalizer> e.g., 1 : [2, 3] = [1, 2, 3]
16:20:06 <erider> so x is first and xs is rest?
16:20:06 <cgroza> Ulfalizer: that depends. In a pattern match, you x would be associated with the head of that list.
16:20:37 <Ulfalizer> cgroza: yeah, depends on context
16:20:45 <JoeyA> erider: Yes
16:20:53 <kniu_> say I got two lists of Doubles
16:21:12 <kniu_> what is a simple way to calculate the mutual information between them/
16:21:14 <erider> ok thanks
16:21:18 <kniu_> ?
16:22:04 <JoeyA> kniu_: What do you mean?  Could you give us an example?
16:22:13 <JoeyA> @let a = [1.0, 2.0, 3.0]
16:22:15 <lambdabot>  Defined.
16:22:28 <JoeyA> @let b = [4.0, 5.0]
16:22:29 <lambdabot>  Defined.
16:22:39 <kniu_> well
16:23:08 <kniu_> I guess this is not really a haskell question
16:23:36 <cgroza> kniu_: do you have the algorithm?
16:23:45 <zzattack> how can i easily find all tuple combinations of items in two lists? e.g. with  [a,b] [1,2] it should result in [(a,1), (a,2), (b,1), (b,2)]
16:23:51 <kniu_> only the formula given in a wikipedia article
16:23:54 <kniu_> http://en.wikipedia.org/wiki/Mutual_information
16:24:21 <JoeyA> I smell list comprehensions.
16:24:45 <cgroza> zzattack: something like:
16:25:07 <twanvl> > let xs = ['a','b']; ys = [1,2] in   [(x,y) | x<-xs, y<-ys]
16:25:08 <lambdabot>   [('a',1),('a',2),('b',1),('b',2)]
16:25:11 <kniu_> > concatMap (\c -> map (c, ) [1, 2]) ['a', 'b']
16:25:12 <lambdabot>   Illegal tuple section: use -XTupleSections
16:25:26 <kniu_> > concatMap (\c -> map (\i -> (c, i)) [1, 2]) ['a', 'b']
16:25:27 <lambdabot>   [('a',1),('a',2),('b',1),('b',2)]
16:25:37 <zzattack> thank you cgroza
16:25:55 <cgroza> zzattack: no no.
16:26:03 <cgroza> zzattack: someone was faster than me :D.
16:26:17 <twanvl> kniu_: what do the doubles in the list represent? Probabilities?
16:26:29 <JoeyA> > let as = [1.0, 2.0, 3.0]; bs = [4.0, 5.0]; p = undefined; p2 = undefined in sum [p2 x y * log (p2 x y / (p x  * p y))]
16:26:31 <lambdabot>   *Exception: Prelude.undefined
16:26:36 <kniu_> twanvl, they're just values
16:26:39 <zzattack> ah yes, well, you showed the syntax, i didn't know you could draw from multiple sets like that
16:26:55 <kniu_> which is one source of confusion for me
16:27:16 <kniu_> to be able to get probabilities just out of corresponding values seems impossible
16:27:25 <twanvl> kniu_: I think mutual information is defined for sets, multisets and probability distributions
16:27:29 <irene-knapp> okay, so I'm looking at some GHC core stuff
16:27:36 <irene-knapp>     [Built in rule for base:GHC.Num.*{v r6}: "Class op *"]
16:27:44 <alistra> > return 4
16:27:44 <irene-knapp> what does the {v r6} mean?
16:27:46 <lambdabot>   No instance for (GHC.Show.Show (m t))
16:27:46 <lambdabot>    arising from a use of `M2562437066...
16:27:51 <alistra> > return 4 :: [Int]
16:27:51 <twanvl> does the order matter?
16:27:52 <lambdabot>   [4]
16:28:27 <kniu_> twanvl, yes
16:28:33 <kniu_> the two lists have the same number of elements
16:28:34 <seinfeld> guys i have function that returns type "Maybe Int"...lets call this function "function1::Int->Maybe Int"............................i want to apply result of function 1 to another number...like this.........100 + (result of function1)......i am confused on how to do that
16:28:40 <kniu_> and the elements themselves correspond to each other
16:28:42 <kniu_> so it's like
16:28:51 <kniu_> more a list of tuples of doubles
16:29:50 <JoeyA> seinfeld: A straightforward approach would be to use a case statement to break the Maybe
16:29:53 <twanvl> do the values have any meaning, for the purpose of mutual info?
16:29:55 <JoeyA> case function1 123 of
16:30:02 <JoeyA>    Just n -> ...
16:30:11 <twanvl> I.e. if you replaced all 1s by 2s should the answer be the same?
16:30:20 <twanvl> (assuming there are no other 2s)
16:30:26 <JoeyA>    Nothing -> error "yada yada yada"
16:30:42 <seinfeld> JoeyA: reason i ask is because i have another function that takes Int....so i would like to pass result of function1 to that function
16:31:20 <geheimdienst> > zipWith (\x y -> x * y) [1..5] [2..4] -- kniu_: possibly you are looking for zipWith?
16:31:21 <lambdabot>   [2,6,12]
16:31:23 <JoeyA> seinfeld: Then you'll have to figure out what to do if function1 returns Nothing.
16:31:36 <JoeyA> Is that an error condition, or will the combined function simply return Nothing?
16:31:44 <geheimdienst> ... um that was a little silly because the list lengths didn't match, but you get the idea
16:32:08 <seinfeld> JoeyA:ok how do i pass this result assuming that function is not returning nothing..later ill figure that out
16:32:26 <seinfeld> JoeyA: lets assume it will always have "Just Int"
16:32:53 <JoeyA> seinfeld: Use pattern matching to break up the return value, then pass it to the function.
16:33:10 <JoeyA> seinfeld: Or just use the fromJust function.
16:33:14 <JoeyA> @hoogle fromJust
16:33:15 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:33:25 <seinfeld> JoeyA: sweet...thank you
16:37:10 <kniu_> twanvl, thing is
16:37:11 <kniu_> I don't know
16:37:17 <kniu_> it's all very strange
16:37:41 <kniu_> according to the wikipedia article I have to integrate over the values since they're discrete
16:37:42 <twanvl> so you just have these two strange lists of doubles?
16:37:49 <kniu_> twanvl, yes
16:38:08 <kniu_> two lists of continuous random variables
16:38:26 <twanvl> of instanciations of them, I assume?
16:38:40 <kniu_> yes
16:39:24 <twanvl> something like two times (mapM sample rvs)?
16:40:00 <twanvl> or one list per random variable?
16:40:36 <kniu_> one list per random variable
16:41:19 <twanvl> are they continuous? because in that case it becomes really hard
16:41:32 <kniu_> they are indeed continuous
16:41:42 <rwbarton> but you have a list of samples, right
16:41:50 <rwbarton> so your measurement is not continuous
16:42:12 <twanvl> I think to calculate mutual information you need to know/estimate the full distribution
16:42:46 <rwbarton> let me see if I have this right, there are some random variables (of unknown distribution) X and Y and you have a list of samples of their values and you want to estimate the mutual information?
16:42:51 <rwbarton> or are you doing something else
16:43:21 <twanvl> you would need to use something like kernel density estimation, or approximate it with a histogram
16:43:26 <kniu_> that's exactly what I'm doing, I think
16:43:29 <hpaste> irene-knapp pasted “Why is this rule not being applied?” at http://hpaste.org/54517
16:43:38 * hackagebot iteratee 0.8.7.3 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.3 (JohnLato)
16:43:45 <kniu_> kernel density estimation?
16:43:54 <irene-knapp> so - this built-in rule is supposed to translate GHC.Num.* into a primop call, right
16:44:05 <irene-knapp> it's not being applied, though
16:44:27 <irene-knapp> (the line noise that comprises most of that paste is the GHC-core syntax of the expression it's not being applied to)
16:44:46 <rwbarton> right, here is an example of a problem you will have, suppose X and Y are actually independent uniform random variables from the interval [0,1]
16:44:59 <twanvl> kniu_: that is essentially smoothing the samples into a continuous probability distribution
16:45:22 <twanvl> if you just want to know whether the RVs are the same, there are simpler things you could do
16:45:30 <kniu_> hm
16:45:32 <kniu_> well
16:45:39 <kniu_> I generated those random numbers myself
16:45:48 <kniu_> so I should know their distribution, right?
16:45:59 <rwbarton> in your samples, all the measurements will (almost surely) be different, so the mutual information will be large, but the real mutual information is 0
16:46:19 <twanvl> it depends on how you generated them
16:46:42 <erider> can someone translate this to me "filter :: (a -> Bool) -> [a] -> [a]"
16:46:49 <twanvl> do you have a simple distribution? or some very complicated, non-parametric thing?
16:46:58 <kniu_> one of them is uniform [0, 2*pi] and the other is
16:46:59 <kniu_> uh
16:47:16 <kniu_> sqrt(uniform [0, 1])
16:47:33 <hpaste> john_r_watson pasted “toString” at http://hpaste.org/54518
16:47:33 <rwbarton> you make it sound like they are independent
16:47:37 <irene-knapp> erider: filter is a function that takes two parameters; its first parameter is a function from some type given by the caller, which we will call a, to a boolean; its second parameter is a list of this same type a; and its return value is another list of this same type a
16:47:41 <erider> so I know it returns a list
16:47:41 <kniu_> rwbarton, no
16:47:49 <kniu_> those are not the X and Y
16:47:52 <twanvl> erider: 'filter' is a function that takes a predicate (which is a function from a to booleans), and a list of a, and then returns a list of a
16:47:53 <kniu_> those are X
16:47:58 <kniu_> the Y, I don't know the distribution of
16:48:09 <kniu_> because the Y comes from a monte carlo integrator
16:48:17 <irene-knapp> erider: that's waht it says.  what it DOES is, the list it returns is all the elements of the list you pass it for which the function applied to that item evalutes to True
16:48:19 <hpaste> john_r_watson annotated “toString” with “toString (annotation)” at http://hpaste.org/54518#a54519
16:48:30 <erider> twanvl: thanks
16:48:32 <john_r_watson> Any newb help?
16:48:45 <john_r_watson> I'm trying to call show for anything other than String
16:48:53 <kniu_> so basically, X and Y are a uniform random number and something completely unknown entirely
16:49:00 <jmcarthur> > show 5
16:49:00 <john_r_watson> both versions I've tried fail
16:49:01 <lambdabot>   "5"
16:49:02 <jmcarthur> > show True
16:49:03 <lambdabot>   "True"
16:49:06 <john_r_watson> show "blah"
16:49:11 <john_r_watson> > show "blah"
16:49:11 <lambdabot>   "\"blah\""
16:49:19 <Cale> roconnor: I don't but I can see why you'd want a name for that. Call it a semiplethory and I don't think people will mind :P
16:49:26 <john_r_watson> I want that to be blah rather than "blah"
16:49:27 <jmcarthur> john_r_watson: is that not the behavior you expect?
16:49:30 <jmcarthur> ah
16:49:55 <jmcarthur> john_r_watson: sounds like you are wanting to *output* the string, not show it (which creates a string representation of whatever you are showing rather than outputting it)
16:50:06 <jmcarthur> john_r_watson: try this:   putStrLn "blah"
16:50:19 <jmcarthur> i'm guessing this is in ghci
16:50:48 <twanvl> kniu_: then I think histograms or kernel density estimation is your best bet.
16:50:49 <john_r_watson> jmcarthur: close.  So I am in fact ultimatetly printing things, but I'm trying to pass multiple types into functions that do the printing.
16:50:58 <john_r_watson> jmcarthur: and I'd like to re-use said functions
16:51:10 <kniu_> twanvl, okay thanks
16:51:19 <jmcarthur> john_r_watson: i see. you want the fact that strings are Strings to be hidden
16:51:20 <john_r_watson> jmcarthur: blindly calling "show" on srings yielded the gratuitous '"' and I'm trying to strip them
16:51:28 <john_r_watson> jmcarthur: roughly. yes
16:51:30 <twanvl> what you could do is use KDE to estimate the probability distribution of Y, and sample that at many points, and then calculate the probability of X at those same points
16:51:40 <twanvl> I believe the statistics library has functions for this
16:51:41 <irene-knapp> > read $ show $ read $ show $ read $ show 4
16:51:42 <lambdabot>   *Exception: Prelude.read: no parse
16:51:46 <irene-knapp> > read $ show $ read $ show $ read $ show 4 :: Int
16:51:47 <lambdabot>   *Exception: Prelude.read: no parse
16:52:00 <rwbarton> > read $ show $ read $ show $ read $ show ()
16:52:01 <lambdabot>   ()
16:52:03 <twanvl> do you really need the mutual information though?
16:52:03 <irene-knapp> > read $ show $ read $ show $ read $ show 4 :: [(Int, String)]
16:52:04 <lambdabot>   *Exception: Prelude.read: no parse
16:52:06 <irene-knapp> hm
16:52:07 <irene-knapp> anyway
16:52:18 <john_r_watson> > show $ read "test"
16:52:19 <lambdabot>   "*Exception: Prelude.read: no parse
16:52:19 <jmcarthur> john_r_watson: Show is typically used for debugging types of things. if you are wanting to do some sort of pretty printing / human-readable things then show is possibly the wrong choice
16:52:28 <kniu_> twanvl, yes
16:52:33 <kniu_> or, at least, some sort of correlation
16:52:43 <irene-knapp> > show $ read "\"test\""
16:52:44 <lambdabot>   "*Exception: Prelude.read: no parse
16:52:51 <irene-knapp> > show $ (read "\"test\"" :: String)
16:52:52 <kniu_> something that tells me whether or not Y depends on X at all
16:52:52 <lambdabot>   "\"test\""
16:52:57 <erider> what does the $ do?
16:53:05 <irene-knapp> confuses beginners :)
16:53:06 <kniu_> ($) is apply
16:53:35 <irene-knapp> we like to put it in as a subtle reminder that we make more money than you do :D
16:53:36 <jmcarthur> john_r_watson: maybe you actually want a different type class, where most types are defined as  pretty = show  , but String's instance might be just  pretty = id
16:53:53 <john_r_watson> jmcarthur: that is precisely what I want
16:54:01 <john_r_watson> jmcarthur: and I'm attempting to do that
16:54:05 <john_r_watson> jmcarthur: http://hpaste.org/54518
16:54:09 <john_r_watson> jmcarthur: but failing miserably
16:54:18 <erider> so $ cons on to the head of a list and applied itself to its args?
16:54:33 <irene-knapp> yeah, essentailly.  I mean, it's not actually a list, this isn't Lisp
16:54:34 <john_r_watson> > read $ show "test"
16:54:34 <lambdabot>   *Exception: Prelude.read: no parse
16:54:38 <rwbarton> @src ($)
16:54:39 <lambdabot> f $ x = f x
16:54:50 <irene-knapp> I think of it as saying "everything from here to the end of the line is in parentheses"
16:54:53 <twanvl> kniu_: now that I think about it, how can Y depend on X?
16:54:55 <jmcarthur> :t read $ show "test"
16:54:56 <lambdabot> forall a. (Read a) => a
16:54:58 <kniu_> > read $ show "\"test\""
16:54:59 <lambdabot>   *Exception: Prelude.read: no parse
16:55:01 <kniu_> hm
16:55:06 <twanvl> aren't they sampled independently?
16:55:07 <kniu_> twanvl, what do you mean?
16:55:08 <jmcarthur> (i think it's inferring type ())
16:55:10 <kniu_> twanvl, no
16:55:21 <kniu_> one of them is directly from a PRNG
16:55:24 <jmcarthur> > read $ show "test" :: String
16:55:25 <lambdabot>   "test"
16:55:26 <geheimdienst> erider: $ lets you cut down on the number of parens. you use it basically by replacing the "(" with $, and then you can leave off the ")"
16:55:59 <kniu_> the other one is the output of a complex function that takes the PRN as an input
16:56:04 <irene-knapp> however, it only works if the stuff before it is a complete function; that is, you can't do foo ++ $ bar baz biff
16:56:16 <irene-knapp> (but you can do foo $ bar baz biff)
16:56:27 <kniu_> full disclosure: it's a monte carlo path tracer
16:56:30 <john_r_watson> so when I tried the default implementation as pretty = show, the intance for String overlapped since it was also a Show
16:56:49 <john_r_watson> I thought the "specificity rule" (I just made that up) would come into play here somehow
16:56:54 <kniu_> I'm shooting rays
16:57:26 <rwbarton> kniu_, and the "complex function" is itself nondeterministic I gather
16:57:32 <rwbarton> depends on other random numbers
16:57:33 <irene-knapp> john_r_watson: nope - the reason we don't have a rule of that nature is that then the meaning of your code could change depending on which modules are imported
16:57:41 <twanvl> maybe you should just look at the correlation?
16:57:42 <kniu_> rwbarton, yes
16:57:46 <irene-knapp> john_r_watson: well, more than it already does
16:58:00 <jmcarthur> john_r_watson: i would define an instance for each type i care about
16:58:18 <irene-knapp> john_r_watson: there is an extension OverlappingInstances which allows this, but it's poor style because it leads you into dark dangerous paths
16:58:20 <john_r_watson> irene-knapp: :(
16:58:30 <erider> so why is it useful with read and show
16:59:05 <irene-knapp> erider: well, the $ has nothing to do with read and show specifically; I just didn't want to write > read (show (read (show (read (show (read (show "foo")))))))
16:59:23 <irene-knapp> erider: because that would be quite verbose and I'd get the number of close-parens wrong, because it's been too long since I've done Lisp :)
16:59:41 <erider> ah ok
16:59:50 <irene-knapp> erider: ironically, I actually got the number of close-parens RIGHT just now, which is probably the most embarrassing thing I could have done :D
17:00:58 <erider> ;)
17:01:07 <irene-knapp> yeah hehe
17:01:33 <kniu_> twanvl, how do i calculate the correlation, though?
17:01:36 <kniu_> is that simpler?
17:01:52 <kniu_> hell, I thought mutual information IS correlation
17:02:07 <twanvl> http://en.wikipedia.org/wiki/Pearson_product-moment_correlation_coefficient
17:03:01 <kniu_> twanvl, the variables aren't linear, though
17:03:17 <kniu_> the output of the rendering equation varies wildly depending on the scene
17:03:20 <rwbarton> kniu_, two variables having nonzero correlation is a stronger condition, for example if E(Y|X=x) is a constant function of x then the correlation will be 0 but the mutual information need not be
17:03:34 <twanvl> you could take the ranks, to make it linear
17:03:46 <kniu_> the ranks?
17:04:06 <twanvl> the position the values would get in a sorted list
17:04:14 <rwbarton> I would suggest picking a bunch of sample values of X and making histograms for the distributions of Y at those X values and visually compare them to see whether they are similar :)
17:04:20 <twanvl> that might or might not help
17:04:31 <kniu_> hm
17:04:39 <kniu_> sorting and trying to see a correlation
17:04:46 <kniu_> that might actually work
17:04:54 <twanvl> Have you looked at a plot of X vs Y values?
17:05:11 <kniu_> twanvl, it's kind of hard to plot things from Haskell
17:05:32 <rwbarton> the gnuplot package is quite easy to use
17:06:25 <rwbarton> on linux at least
17:06:50 <twanvl> or you can always export the data and plot with some other program
17:10:48 <vhd> Hello, how does one go about doing pattern matching on records?
17:11:14 <vhd> http://en.wikibooks.org/wiki/Haskell/Pattern_matching
17:11:21 <vhd> ^ only briefly covers it
17:11:26 <kniu_> vhd, ghc let's you do punning
17:11:32 <kniu_> like,
17:12:04 <kniu_> f (Foo {field0 = x, field1 = y, field2}) = ...
17:12:16 <kniu_> might have to enable some extensions, though
17:12:23 <vhd> yes that seems to work
17:12:32 <vhd> but I want to match the x and y
17:12:38 <vhd> rather than just capture them
17:12:38 <kniu_> what do you mean
17:12:52 <vhd> I mean, I want to match "True" to x
17:12:58 <vhd> rather than it be variable
17:13:01 <kniu_> f (Foo {field0 = Bar _, field1 = Baz _ _, field2}) = ... ?
17:13:07 <kniu_> should work
17:13:35 <vhd> hmm the second does not work for me. GHCi complains.
17:13:47 <kniu_> what does it say?
17:13:56 <vhd> hold on
17:14:34 <vhd> kniu: parse error on input `='
17:14:44 <vhd> = being the first "="
17:15:02 <vhd> Bar is not a constructor, it is a variable
17:15:15 <vhd> and therefore is why you cannot pattern match
17:15:27 <vhd> or so it seems.
17:15:30 <kniu_> I did not know of this limitation
17:15:44 <kniu_> hpaste your code
17:15:50 <vhd> uh
17:15:57 <vhd> ok no laughing
17:16:23 <kniu_> I cannot guarantee that.
17:16:26 <geheimdienst> vhd: he meant "Bar" as an example. you could have, for example "f (Foo { field0 = Just x })", if you had a record of type Foo with a field0 that is a Maybe
17:16:28 <kniu_> I am a jolly man.
17:17:17 <twanvl> > let  f (Dual {getDual = True}) = x  in  f (Dual {getDual = True})  --example, Dual is just a record type
17:17:18 <rwbarton> Why would it report a parse error on the = when the previous version that worked was identical up through and including that =?
17:17:18 <lambdabot>   x
17:17:54 <vhd> http://pastebin.com/2VEUa8kD please ignore the contents of the promote function as it will change if I can get what I want with pattern matching
17:17:55 <vhd> http://pastebin.com/2VEUa8kD
17:17:55 <mauke> The paste 2VEUa8kD has been copied to http://hpaste.org/54520
17:17:56 <mauke> The paste 2VEUa8kD has been copied to http://hpaste.org/54521
17:18:11 <kniu_> you spelled "Piece" wrong
17:18:20 <vhd> not surprised :I
17:18:21 <rwbarton> getType=x False
17:18:26 <rwbarton> what's this supposed to mean
17:18:28 <vhd> yeah that is what I want
17:18:38 <kniu_> yeah that doen't make any sense
17:18:55 <kniu_> (x False) is not a pattern
17:19:01 <vhd> why not?
17:19:22 <kniu_> because it violates the syntactic rules of the language?
17:19:32 <kniu_> patterns are either
17:19:36 <vhd> yes, yes it doesn’t it.
17:19:41 <kniu_> someVariable
17:19:42 <vhd> does*
17:19:45 <kniu_> or
17:19:59 <kniu_> Foo <variables ...>
17:20:03 <geheimdienst> vhd, you can either match like this "getType=False", or you can match to bind the content of getType to x, like this "getType=x"
17:20:04 <kniu_> well
17:20:09 <kniu_> Foo <patterns ...>
17:20:19 <kniu_> OR
17:20:27 <kniu_> you can be fancy and write
17:20:32 <kniu_> getType = x@False
17:20:39 <vhd> yeah I was using getType=x atm
17:21:01 <vhd> but x is of type Type
17:21:01 <rwbarton> I think he wants 'x' to match something like 'Bishop' so that the getType field would have value 'Bishop False'
17:21:04 <geheimdienst> kniu_: why would you ever want to do that? you already matched that it's False
17:21:10 <kniu_> geheimdienst, hell I don't know
17:21:11 <vhd> which is not Bool
17:21:21 <kniu_> I'm just trying to guess at what vhd is doing
17:21:34 <vhd> rwbarton: yes that is what I am trying
17:21:44 <kniu_> oh
17:22:02 <kniu_> wait, what
17:22:05 <rwbarton> in general the assumption is that fields of distinct constructors are unrelated, though
17:22:08 <kniu_> still doesn't make any sense
17:23:28 <vhd> rwbarton: what do you mean? Would it not matter if a constructor had a bool parameter or not?
17:25:11 <irene-knapp> :k IO
17:25:12 <lambdabot> * -> *
17:26:00 <rwbarton> vhd: if I have data X = A Bool | B Bool, the default assumption is that the Bool fields of A and B don't necessarily have "the same meaning"
17:26:24 <geheimdienst> vhd: if by "getType=x False" you're attempting to match things like "Maybe Bool" or "IO Bool", i don't think that's possible in normal haskell. it would probably require advanced experimental witchcraft, and even then ...
17:27:34 <rwbarton> vhd: if they do have the same meaning, I might write data X = X Y Bool, data Y = A | B
17:27:36 <vhd> rwbarton: oh I think it makes sense. Haskell will not treat them the same as it needs a constructor to pattern match to?
17:28:18 <rwbarton> each field is "scoped" to the constructor that it belongs to
17:28:34 <vhd> I see
17:28:39 * hackagebot fixhs 0.1.1 - FIX (co)parser  http://hackage.haskell.org/package/fixhs-0.1.1 (ArvinMoezzi)
17:29:06 <rwbarton> there's no way in Haskell with data X = A Bool | B Bool to refer to "the Bool field" without matching on A and B separately (or using generics or TH or other fancy stuff)
17:29:11 <vhd> I had this setup before " I might write data X = X Y Bool, data Y = A | B"
17:29:16 <rwbarton> because the fields are really different
17:29:17 <vhd> but thought could do it this way instead
17:29:35 <rwbarton> you can, but you will have to write separate pattern matches on Silver, Horse, etc.
17:30:07 <vhd> :/
17:31:20 <vhd> haha at least got a spelling error fixed :D
17:41:07 <krey_> hi, what's the clever way of checking whether all elements in a list are equal?
17:41:53 <kniu_> krey_, how clever?
17:42:33 <kniu_> > and (zipWith (==) [1, 2, 3] [1, 2, 3])
17:42:34 <lambdabot>   True
17:42:39 <kniu_> > and (zipWith (==) [1, 2, 3] [1, 2, 4])
17:42:40 <lambdabot>   False
17:42:44 <krey_> kniu_: wow
17:42:53 <geheimdienst> > and $ zipWith (==) <*> tail $ [1,1,1,1]
17:42:53 <lambdabot>   True
17:42:56 <geheimdienst> > and $ zipWith (==) <*> tail $ [1,1,1,7]
17:42:57 <lambdabot>   False
17:43:22 <geheimdienst> ... but i'm just messing with you :) i don't think <*> is necessary or even much helpful
17:43:59 <krey_> geheimdienst: yeah, I was thinking, so applicative something, but why?
17:45:05 <krey_> kniu_: your solution is definitely better than mine, thanks
17:45:24 <kniu_> why, what'd you write?
17:46:18 <krey_> errr, nothing really, but I was about to use monads :D
17:46:35 <kniu_> something something two problems
17:47:07 <chra> > (==1) . length $ group [1,1,1,1]
17:47:09 <lambdabot>   True
17:47:17 <krey_> ?
17:47:26 <shachaf> chra: length :-(
17:47:40 <shachaf> null . drop 1, please.
17:47:46 <kniu_> :t null
17:47:47 <lambdabot> forall a. [a] -> Bool
17:47:55 <kniu_> oh right
17:47:59 <geheimdienst> krey_: yes, applicative is where it's defined, but here f <*> g is just a thing that takes an argument, feeds it into g, then feeds g's result and the original argument into f. check out the diagram here, that's what made it clear for me http://heh.fi/haskell/functors/
17:48:22 <chra> > null . drop 1 $ group []
17:48:23 <shachaf> @ty and .: zipWith (==)
17:48:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:48:24 <lambdabot>   True
17:48:26 <kniu_> the extent of how I use <*> is
17:48:41 <kniu_> pure_function <$> monadic_stuff <*> monadic_stuff <*> ...
17:48:45 <shachaf> chra: So it's also more correct, as it happens. :-)
17:48:59 <chra> What do you know.
17:49:36 <shachaf> @ty ((and .: zipWith (==)) <*> tail)
17:49:37 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:50:03 <shachaf> > ap(and.:zipWith)tail[1,1,1]
17:50:04 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
17:50:05 <lambdabot>         against inferred typ...
17:50:23 <shachaf> > ap(and.:zipWith(==))tail[1,1,1]
17:50:25 <lambdabot>   True
17:50:26 <shachaf> > ap(and.:zipWith(==))tail[1,1,2]
17:50:27 <lambdabot>   False
17:50:28 <kniu_> :t (.:)
17:50:29 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
17:50:37 <shachaf> (.:) = (.).(.)
17:50:43 <kniu_> that's oddly specific
17:51:23 <irene-knapp> @google oddly specific
17:51:24 <lambdabot> http://failblog.org/tag/oddly-specific/
17:51:24 <lambdabot> Title: oddly specific - EPIC FAIL Funny Videos and Epic Fail Funny Pictures
17:51:29 <shachaf> kniu_: What do you mean?
17:51:59 * krey_ really wishes he weren't too tired to understand wth geheimdienst did...
17:52:17 <kniu_> shachaf, seems like a rarely used combinator
17:52:31 <shachaf> kniu_: It's like composition but with two arguments.
17:52:37 <shachaf> \f g x y -> f (g x y)
17:52:46 <kniu_> exactly
17:53:02 <geheimdienst> shachaf: that's the first clear explanation of .: that i've ever heard
17:53:06 <kniu_> you'd think the use case is too general to have a combinator for it
17:53:11 <shachaf> kniu_: Really? I want that operator all the time.
17:54:59 <shachaf> geheimdienst: Now just think of how clear it would be in a concatenative language!
17:55:09 <kniu_> I meant "too specific"
17:55:20 <kniu_> of course you'd want a combinator for something that's "too general"
17:55:25 <shachaf> kniu_: Well, it's not in the Prelude.
17:55:34 <shachaf> Caleskell added it because it's useful for @pl golfing, or something, I guess.
17:55:47 <shachaf> Any time you see (f .) . g, it's because someone's missing that combinator.
17:55:48 <kniu_> I like Caleskell
17:55:55 <kniu_> I like having (.) as fmap
17:56:04 <kniu_> and having ($) be left associative
17:57:24 <shachaf> kniu_: You don't like (.) = (Control.Category..)?
17:57:43 * ski invented `.:' a long time ago ..
17:57:57 <rwbarton> shachaf++ everyone else is crazy!
17:58:05 <geheimdienst> ski: i invented .: before it was mainstream to invent .:
17:58:12 <kniu_> wait
17:58:14 <kniu_> what is
17:58:15 <shachaf> rwbarton: I agree, but what are we talking about specifically?
17:58:20 <kniu_> :t (Control.Category..)
17:58:21 <rwbarton> (.) = (Control.Category..)
17:58:21 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
17:58:28 <kniu_> wow that's even better
17:58:30 <shachaf> Oh. Yes.
17:58:44 <shachaf> On the other hand I can see the rationale behind wanting a short name for fmap.
17:58:46 <ski> @type let (.) = (Prelude..); (.:) = (.) . (.) in (.:)  -- the original type for it
17:58:47 <lambdabot> forall b c a a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:59:16 <shachaf> @type \f g x y -> f (g x y) -- A shorter way of typing it.
17:59:17 <lambdabot> forall t t1 t2 t3. (t2 -> t3) -> (t -> t1 -> t2) -> t -> t1 -> t3
17:59:30 <shachaf> GHC should really not do the t t1 t2 t3 thing.
17:59:56 <kniu_> you want to go back to the old a b c a0 ...?
18:00:00 <ski> geheimdienst : i don't claim i'm the first one who invented it, only saying i made up the name `.:'
18:00:21 <shachaf> kniu_: I want it to invent a brand new letter for each type variable.
18:00:40 <shachaf> If you have more than 26 variables, well, that's your problem at that point. But until then I don't want to see numbers.
18:01:46 <ski> @type zipWith :: (a -> a' -> a'') -> ([a] -> [a'] -> [a''])
18:01:46 <geheimdienst> krey_: the idea is to compare each element in the list with the element after it. "zipWith (==) <*> tail $ [1,1,1,7]" is "(zipWith (==)) <*> tail $ [1,1,1,7]". what <*> does is it gives the list to tail (cutting off the first element), then gives to (zipWith (==)) both the original 4-element list and the 3-element result of tail. at that point it's "zipWith (==) [1,1,1,7] [1,1,7]"
18:01:47 <lambdabot> forall a a' a''. (a -> a' -> a'') -> [a] -> [a'] -> [a'']
18:01:57 <geheimdienst> ski: don't worry, i'm just kidding
18:02:23 <ski> (in Miranda it would have been `zipWith :: (* -> ** -> ***) -> ([*] -> [**] -> [***])')
18:04:52 <tickle`> I want a type-level ($). is there such a thing?
18:05:15 <ski> polymorphic or monomorphic ?
18:05:17 <shachaf> tickle`: You can define it.
18:05:22 <shachaf> type a :$ b = a b
18:06:12 <ski> you can define a monomorphic one as `type Apply f a = f a', or `newtype Apply f a = MkApply {unApply :: f a}', giving the monomorphic kind signature `Apply :: (* -> *) -> * -> *'
18:06:39 <tickle`> shachaf: can I specify the fixity of infix type synonyms?
18:06:53 <ski> tickle` : yes, use the usual `infix',`infixl',`infixr'
18:07:25 <tickle`> hm, okay. :$ is a bit longer than $, but it'll do
18:07:30 <ski> (yes, you can't have different fixities for value-level and type-level operators)
18:07:41 <drvitek> Why can't I write newtype (Ord a) => Graph a = Map a (Set a)?
18:07:41 <drvitek> I'm aware that I can do this with data instead of newtype; I'm just curious as to why newtype forbids it.
18:07:41 <drvitek> I get an error of the form, "The constructor of a newtype must have exactly one field."
18:07:57 <shachaf> drvitek: There are a couple of things wrong there.
18:08:08 <ski> drvitek : even if you use it with `data', it's next to useless
18:08:15 <shachaf> drvitek: One is that a newtype must have a constructor. I.e. newtype Graph a = Graph (Map a (Set a))
18:08:31 <shachaf> drvitek: The other is that you shouldn't have constraints on newtypes. They accomplish absolutely nothing.
18:08:45 <shachaf> You should put constraints on functions that use the newtypes.
18:08:57 <rwbarton> drvitek: when you had 'data', you were defining a type Graph a with a constructor named Map
18:09:09 <rwbarton> which had a field of type a, and another field of type Set a
18:09:12 <drvitek> Oh, I see.
18:09:21 <ski> drvitek : or, you can use GADT syntax, and put constraints on data constructors, if you really want to -- but in many cases there's not much use
18:09:21 <shachaf> Oh, wait.
18:09:41 <shachaf> I misread your actual question.
18:10:00 <shachaf> What that definition is doing is defining a constructor called Map that has two fields -- yes, what other people are saying.
18:10:22 <shachaf> You can't do that with newtype because newtype is "just" like a type synonym, except that it's type-checked.
18:11:03 <kniu_> I want the type level and the value level to have identical syntax
18:11:21 <ski> drvitek : it might be nice if one could restrict `Graph' to only apply to types that are in `Ord'. but that's not what adding the constraint on `data' (which is next to useless) does, and it's not what the GADT thing does either
18:11:34 <drvitek> That makes sense.  And this would be a silent error until I try and actually use Map elsewhere in the file, at which point Haskell wouldn't be able to resolve the ambiguity between my Map and the imported Data.Map, correct?
18:12:06 <drvitek> "this" being replacing newtype with data in my example.
18:12:08 <rwbarton> for example, yes
18:12:15 <ski> drvitek : probably not, since your `Map' is a value, while `Data.Map.Map' is a type
18:12:26 <rwbarton> oh right
18:12:33 <ski> drvitek : values and types have identifiers in disjoint namespaces
18:12:44 <rwbarton> More likely when you try to use or construct a value of type Graph somehow you'll get confused.
18:12:54 <drvitek> I think that was already the case.
18:13:08 <rwbarton> Okay, you'll get confused and the compiler will tell you about it :)
18:13:46 * ski . o O ( `-fmore-confusing-errors' )
18:14:35 <irene-knapp> hahaha
18:14:46 <drvitek> Alright, thanks very much.
18:15:00 <ski> drvitek : in any case, the idea about wanting to make sure `a' in `Graph a' is always in `Ord' isn't necessarily bad, but can't really be done in current Haskell
18:15:48 <ski> (drvitek : and in case you haven't seen GADTs yet, you can ignore that part for now)
18:36:55 <NemesisD> anyone user Control.Parallel.Strategies?
18:37:27 <Cale> sure
18:37:47 <NemesisD> i'm trying to map a function over Data.Map (which is Traversable) in parallel. i'm having a hard time reasoning whether i should be using rseq or rdeepseq, as those seem to be the options
18:38:28 <Cale> that depends on how deeply you want to evaluate the results of the function in parallel
18:38:40 <Cale> What is the type of the function in question?
18:40:16 <NemesisD> parFun :: Map Int String -> Map Int String; parFun m = (withStrategy $ parTraversible rseq) $ M.map somerandomfunction m
18:40:41 <NemesisD> erm wait
18:41:45 <NemesisD> the type sigature is more like parFun :: Map Int [SomeRecordType] -> Map Int (Double, Double)   if we're being specific
18:43:22 <NemesisD> so the part that should be parallelized is the computation, as it is potentially costly, i just don't have a good understanding of what that means in terms of evaluation strategies
18:43:55 <Cale> So, your function is String -> String?
18:44:28 <Cale> Use rdeepseq if you want those Strings to be fully evaluated in parallel
18:44:43 <Cale> Otherwise, it'll only do enough computation to determine the first character of each String
18:46:04 * ski finds `deepseq' and its ilk repulsive in a similar way as SYB
18:46:38 <ddarius> For par-like stuff, deepSeq isn't as bad, but otherwise I agree.
18:46:58 <NemesisD> Cale: sorry, i was trying to oversimplify for the question. my function is :: [SomeRecordType] -> (Double, Double)
18:46:59 * ddarius pokes dolie.
18:47:09 <ddarius> s/dolie/doliol
18:47:16 <ddarius> Crap.
18:47:17 <ddarius> dolio
18:47:21 <NemesisD> if it matters, my function does not need *every* field of the record and only extracts what it needs. is deepseq still the way to go?
18:47:35 <ddarius> NemesisD: The issue is the result.
18:47:47 <NemesisD> ?
18:47:53 <Cale> NemesisD: okay, if you only use rseq, then it will do enough evaluation to determine that each pair is indeed a pair (in order to reduce it to the form (x,y) where x and y are expressions)
18:48:01 <ddarius> You want both those Doubles forced, presumably.  rdeepseq will do what you want.  A more specific seqPair would make ski feel better.
18:48:14 * ski grins
18:48:30 <ddarius> seqPair p@(!x,!y) = p
18:48:50 <ddarius> Well it wouldn't return p.
18:53:42 <NemesisD> ohh i've never understood it that way, that it is actually forcing the evaluation of the result
18:54:02 <NemesisD> why wouldn't it return p?
18:56:35 <roconnor> @type (|||)
18:56:36 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:57:01 <roconnor> what is the typical Categorical notation for (f ||| g) ?
18:57:30 <ski> roconnor : `[f , g]', or
18:57:31 <roconnor> @type either
18:57:32 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:57:37 <ski>    f
18:57:38 <ski>   {
18:57:40 <ski>    g
18:58:03 <dolio> ddarius: Eh?
18:58:10 <roconnor> ski: thanks
18:58:16 <ski> (with a slightly longer `{', maybe with a matching `}' -- also `[' and `]' an be used instead there)
18:58:29 <roconnor> I'm going with the 1-D notation
18:59:45 <ski> if you have `<[f0 , g0] , [f1 , g1]>' which is `[<f0 , f1> , <g0 , g1>]', you can write it like a matrix, and if coproduct is product, you can do matrix multiplication
18:59:56 <ddarius> dolio: I have my Modernist Cuisine books back.
19:00:17 <dolio> Yeah, I got your message, actually. I was heading out of town though.
19:00:18 <dolio> Sorry.
19:00:19 <ski> (though, iirc, you'll get the transpose of the conventional matrixsyntax)
19:00:33 <ddarius> dolio: I figured.
19:01:16 <ddarius> ski: I've never seen [ used like I believe you intend { to be used.
19:03:40 * hackagebot arx 0.0.2 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.0.2 (JasonDusek)
19:08:22 <hpaste> Stephens2424 pasted “isWithinArray” at http://hpaste.org/54523
19:08:28 <ski> ddarius : i've seen it, but always with a matching `]'
19:08:38 <stephens2424> I'm having trouble with the following function. It works when I paste it into ghci, but not when I load the file
19:08:55 <ddarius> I could see someone displaying them as a column vector in very particular cases.
19:09:17 <shachaf> stephens2424: In what way does it not work?
19:09:24 <shachaf> ski has a quotation for that, I believe.
19:09:31 <ski> yes, this when thinking about them as column vectors, and matrices
19:09:57 <stephens2424> shachaf: ghci gives the following errors:
19:09:57 <stephens2424> TriangleArray.hs:35:33:
19:09:57 <stephens2424>     Couldn't match expected type `(Int, Int)' with actual type `Int'
19:09:57 <stephens2424>     Expected type: Coords
19:09:57 <stephens2424>       Actual type: Int
19:09:57 <stephens2424>     In the second argument of `(<=)', namely `s'
19:09:57 <stephens2424>     In the first argument of `(&&)', namely `(a <= s)'
19:10:01 <ski> otherwise the `{' notation, and more commonly `[f , g]' is what i've seen
19:10:14 <ski> shachaf : i do ?
19:10:35 <shachaf> ski: About "doesn't work". Maybe it wasn't you?
19:10:44 * ski has no idea
19:10:45 <ddarius> @quote doesn't.work
19:10:46 <lambdabot> mwc says: XML is like violence. If it doesn't work, use more.
19:10:57 <ski> (might have been, but i've no recollection about it)
19:11:04 <Cale> :t inRange
19:11:05 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
19:11:17 <ddarius> :t inRange . bounds
19:11:18 <lambdabot> forall a e. (Ix a) => Array a e -> a -> Bool
19:11:33 <ski> stephens2424 : normally, you write larger definitions in a source file, and load that (using e.g. `:r' to reload, after changing)
19:11:56 <stephens2424> ski: yeah, that's what I was doing and when it gave me that error
19:12:00 <ski> stephens2424 : if you really want to, you can make that definition in GHCi
19:12:27 <ski> stephens2424 : like `let isWithinArray :: Array (Coords,Coords) (Maybe Int) -> Coords -> Bool; isWithinArray arr (s,t) = (a <= s) && (s <= x) && (b <= t) && (t <= y) where where ((a,b),(x,y)) = bounds arr' (all on one (logical) line)
19:12:39 <stephens2424> ski: yeah, and I tried that just to see if it would work, and for some reason, it did
19:13:04 <ski> (you can probably also use `:{' and `:}' instead, for multi-line definition, but you still need to use `let' first, and you need to align correctly)
19:13:15 <shachaf> stephens2424: It sounds like the error isn't where you think it is.
19:13:16 <ddarius> Soon you shouldn't.
19:13:58 <shachaf> ddarius: Shouldn't need to use let?
19:15:19 <ski> stephens2424 : hum, actually, are you sure you entered the type signature, when you inserted it into the interactor ?
19:15:38 <stephens2424> No, I don't think I put in that part
19:15:46 <shachaf> stephens2424: What type did ghci infer?
19:15:47 <ski> that's why it worked, then
19:16:10 <ski> stephens2424 : the type signature is inconsistent with the actual code. that's what the error is about
19:16:53 <stephens2424> when I remove the type signature from the file, it says the function is not in scope
19:17:10 <ski> stephens2424 : note that each of `a',`b',`x',`y' is of type `Coords', while the whole of `(s,t)' is of type `Coords', which makes `s' and `t' into `Int', assuming `type Coords = (Int,Int)'
19:17:26 <ski> stephens2424 : i.e., this is if we're going by the type signature
19:18:22 <ski> stephens2424 : now note that you're comparing e.g. `a' (of type `Coords') and `s' (of type `Int') using `<=', which insists that they have the same type, which they haven't -- hence the error
19:18:29 <Cale> stephens2424: it shouldn't... make sure there are no .o files hanging around
19:18:52 <ddarius> My phone has so much character.
19:18:55 <irene-knapp> heh
19:18:56 <irene-knapp> hm
19:19:46 <ski> stephens2424 : btw, it *might* be that you intended `Array Coords (Maybe Int)' instead of `Array (Coords,Coords) (Maybe Int)' -- if so, that would fix the type error
19:20:28 <ski> stephens2424 : an array of type `Array Coords (Maybe Int)' is one whose elements are indexed by `Coords' values (which consists of two `Int's, i think)
19:20:44 <stephens2424> ski: are you certain? I don't see why `a', `b', `x', and `y' shouldn't be of type Int
19:20:57 <ski> stephens2424 : while an array of type `Array (Coords,Coords) (Maybe Int)' is one whose elements are indexed by `(Coords,Coords)' (so, *four* `Int's)
19:21:03 <ski> @type bounds
19:21:05 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
19:21:10 <irene-knapp> okay, wait, I think I get what's happening here
19:21:35 <ski> since you have said `Array (Coords,Coords) (Maybe Int)', `i' here is `(Coords,Coords)', so the result is of type `((Coords,Coords),(Coords,Coords))'
19:21:38 <irene-knapp> no, never mind
19:21:48 <irene-knapp> the primOpRules, defined in PrelRules.lhs, only act on primops.  I knew that already, it's not helpful :/
19:22:01 <ski> in `((a,b),(x,y)) = bounds arr', the result is matched with `((a,b),(x,y))', so all of `a',`b',`x',`y' get type `Coords'
19:22:19 <ski> stephens2424 : clear ?
19:23:23 <irene-knapp> hahaha wth, there's a module GHC.Magic which defines a single function, "inline", which ... inlines its argument ><
19:23:26 <irene-knapp> who thought that was good design ><
19:23:34 <stephens2424> not really, because I thought the array bounds is a tuple (i,i)
19:24:03 <stephens2424> so then it would only return (Coords,Coords)
19:24:09 <rwbarton> 'Array i t' means an array whose indices are of type i
19:24:11 <ski> stephens2424 : yes, it's a 2-tuple, containing the lower bound (of type `(Coords,Coords)') and the upper bound (of type `(Coords,Coords)')
19:24:49 <rwbarton> so if arr :: Array i t then bounds arr :: (i, i)
19:24:55 <ski> stephens2424 : they get type `(Coords,Coords)', because you've said that your array indices should have type `(Coords,Coords)' -- if you wanted them to have type `Coords', you should have said `Array Coords (Maybe Int)', not `Array (Coords,Coords) (Maybe Int)'
19:25:16 * ddarius proposes that all introductions to Haskell begin with introductions to Prolog.
19:25:20 <irene-knapp> heh
19:25:31 <stephens2424> ski: oh I see, ok, yeah
19:25:37 * ski applauds ddarius bold suggestion
19:26:19 <stephens2424> ski: I got confused because some functions working on arrays do take (i,i) for their bounds. perhaps just when you define it
19:27:00 <stephens2424> anyway, thanks, problem solved
19:27:21 <ski> stephens2424 : *nod*. it's not hard to confuse that your `Coords' is `(Int,Int)' with that some operations want or yield pairs of `Coords'
19:27:26 <ddarius> stephens2424: As Cale and I suggested, your function can be replaced with inRange . bounds
19:27:52 <ski> @type inRange
19:27:53 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
19:28:58 <stephens2424> oh neat, that's even better
19:29:29 <ddarius> Programming: The Art of Being Pedantic
19:29:34 <rwbarton> > inRange ((0,0),(9,9)) (0,23)
19:29:35 <lambdabot>   False
19:29:59 <rwbarton> > listArray ((0,0),(9,9)) (repeat 'x') ! (0,23)
19:30:00 <lambdabot>   *Exception: Error in array index
19:30:24 <rwbarton> oh I thought it didn't check that properly
19:30:29 <rwbarton> What am I thinking of?
19:30:51 <erider> is there a different with creating a function with this style "  let var = expression in body "
19:30:57 * ski . o O ( C ? )
19:30:59 <ddarius> > inRange ((0,0),(9,9)) (23,0)
19:31:00 <lambdabot>   False
19:31:01 <rwbarton> heh, no
19:31:12 <rwbarton> @src Ix
19:31:13 <lambdabot> class (Ord a) => Ix a where
19:31:13 <lambdabot>     range           :: (a,a) -> [a]
19:31:14 <lambdabot>     index           :: (a,a) -> a -> Int
19:31:14 <lambdabot>     inRange         :: (a,a) -> a -> Bool
19:31:14 <lambdabot>     rangeSize       :: (a,a) -> Int
19:31:15 <ski> erider : versus what ?
19:31:23 <ddarius> > listArray ((0,0),(9,9)) (repeat 'x') ! (23, 0)
19:31:23 <lambdabot>   *Exception: Error in array index
19:31:31 <rwbarton> > index ((0,0),(9,9)) (0,23)
19:31:33 <lambdabot>   *Exception: Error in array index
19:31:44 <erider> versus no let or in
19:31:56 <ddarius> There was a bug in GHC or the Report where it wouldn't do the actual bounds checking until flattening to an Int.
19:32:06 <erider> foo n = n * n
19:32:12 <ski> erider : if `let var = expression in body' is allowed in a context, then you can't elide the `let'
19:32:44 <ski> erider : `foo n = n * n' is a declaration. `let foo n = n * n in ..foo..' is an expression
19:33:08 <ski> expressions go in some places in the program, declarations go in other places
19:33:35 <ddarius> It was actually kind of nice because you could index a 2-dimensional array as a 1-dimensional array if you wanted.
19:33:39 <erider> hmm
19:33:42 <rwbarton> ah yes. Seems that inRange always checked properly, but (!) was fixed between 6.10.1 and 6.12.1
19:35:27 <ski> erider : only in a few circumstances can you use the `let foo n = n * n' form, those being : (a) as a list comprehension clause; (b) as a command in a `do'-block -- there's also (c) in GHCi (which can be seen as an instance of (b)), but that's not a proper part of the language
19:36:06 <erider> ah ok
19:36:28 <ski> > [foo x | x <- [0 .. 9] , let {foo n = n * n} , even n]
19:36:30 <lambdabot>   []
19:36:32 <rwbarton> (He means without a following "... in ...", in case that wasn't clear)
19:36:41 <ski> > [foo x | x <- [0 .. 9] , let {foo n = n * n} , even x]  -- er
19:36:42 <lambdabot>   [0,4,16,36,64]
19:36:45 <erider> so use it sparingly
19:37:08 <ski> > do x <- [0 .. 9]; let {foo n = n * n}; guard (even x); return (foo x)
19:37:10 <lambdabot>   [0,4,16,36,64]
19:37:43 <ski> erider : well, use it when it makes sense (and, obviously, when it's allowed)
19:37:49 <ddarius> erg: Use it as much as you want.
19:43:00 <roconnor> which is better for isomorphic: ≈ or ≅ ?
19:43:31 <dolio> The latter is typically used, I think.
19:43:42 <roconnor> even in category theory?
19:44:02 <dolio> Yes, I think so.
19:44:06 <monochrom> the former isn't for ismorphism. more usually approximation.
19:44:25 <ddarius> The latter is almost universally used in category theory.
19:44:34 <dolio> If you ask someone doing geometry, though, they might disagree.
19:44:41 <dolio> Or maybe they wouldn't.
19:45:33 <ddarius> dolio: Why do you say they would disagree, or are you referring to monochrom's comment?
19:45:57 <Cale> I've seen ≈ for "is congruent to"
19:45:57 <dolio> Because ≅ is used for congruence, isn't it?
19:46:10 <ddarius> dolio: Yes, which is an isomorphism.
19:46:19 <dolio> Yeah, I was thinking that.
19:50:20 <ddarius> Being a mountain knot guy and having the last name "Mariner" is not ideal.
20:05:27 <lpsmith> Ok, I'm having problems installing ghc-6.12.3 on centos
20:05:49 <lpsmith> Well, it's installed,  but it can't find libgmp.so
20:05:58 <irene-knapp> okay, so
20:06:02 <irene-knapp> ls /usr/lib/*gmp*
20:06:08 <lpsmith> So I set up a symbolic link from libgmp.so to libgmp.so.3
20:06:13 <lpsmith> and ran ldconfig
20:06:18 <irene-knapp> ah
20:06:30 <lpsmith> but it's still not working
20:06:34 <lpsmith> and I'm a little puzzled
20:06:42 <irene-knapp> you realize, by the way, that GMP is up to 5.0.2
20:06:57 <lpsmith> Yeah, CentOS is archaic
20:06:59 <irene-knapp> okay
20:07:12 <irene-knapp> well, you could hpaste your config.log
20:07:22 <lpsmith> software has to be like,  at least 5 years old before they move it into the distro :-P
20:07:25 <irene-knapp> you know that you have to re-run ./configure from the GHC root dir after changing dependencies, right?
20:07:46 <irene-knapp> (make distclean probably isn't necessary though)
20:09:16 <lpsmith> Well, I installed the binary distro
20:09:21 <irene-knapp> oh
20:09:25 <irene-knapp> hmmmm
20:09:35 <lpsmith> I don't have a ghc compiler for this centos
20:09:36 <irene-knapp> do this
20:10:06 <lpsmith> But I have this problem on Ubuntu too,  and the symbolic link has always done the trick
20:10:32 <irene-knapp> one sec, looking something up for you
20:11:40 <Sgeo> Is what I wrote in the comment http://mikehadlow.blogspot.com/2011/02/monads-in-c-7-turning-our-parser-into.html sensible?
20:11:53 <irene-knapp> okay so while I do that, find your GHC binary (not the shell-script wrapper)
20:13:29 <lpsmith> yeah I know where that is already :)
20:13:35 <irene-knapp> okay, good
20:14:03 <monochrom> oh yikes, you're going to hex-edit the exe
20:14:10 <irene-knapp> no, haha
20:14:13 <irene-knapp> I'm just going to objdump it haha
20:14:17 <irene-knapp> to find out its load commands
20:14:24 <monochrom> (which was what people did to quiet readline complaints!)
20:14:30 <irene-knapp> hahaha!
20:14:31 <irene-knapp> I see
20:15:57 <irene-knapp> okay so
20:16:02 <irene-knapp> objdump -p /path/to/real/gmp
20:16:05 <irene-knapp> and hpaste the output
20:16:31 <lpsmith> real ghc you mean?
20:16:37 <lpsmith> funny,  I thought I knew where that is
20:16:55 <lpsmith> but I can't seem to find it
20:16:59 <irene-knapp> which ghc
20:17:04 <irene-knapp> cat `which ghc`
20:17:08 <irene-knapp> yes, I mean real ghc, sorry
20:17:26 <lpsmith> yeah I know,  I read the shell script to find the executable
20:17:50 <irene-knapp> yes, it should say exedir = blah blah blah, near the top
20:18:41 <lpsmith> right,  /usr/local/hs/ghc-6.12.3/lib/ghc-6.12.3/
20:18:49 <lpsmith> but there isn't a ghc-stage2 in that directory
20:19:41 <lpsmith> which confuses me greatly
20:20:27 <lpsmith> oh nevermind
20:20:30 <lpsmith> ok
20:20:50 <irene-knapp> it should be just ghc
20:20:52 <irene-knapp> not ghc-stage2
20:21:46 <lpsmith> http://hpaste.org/54525
20:21:48 <lpsmith> right
20:21:59 <lpsmith> I didn't read enough of the script
20:23:07 <irene-knapp> hmm
20:23:58 <irene-knapp> okay so, yeah, it wants libgmp.so.3
20:23:59 <irene-knapp> hmm
20:24:23 <lpsmith> which I have,  but I try to start ghci and it complains about libgmp.so
20:25:39 <irene-knapp> try $ objdump -p /usr/lib/libgmp.so.3
20:25:42 <irene-knapp> and hpaste that for me too
20:25:45 <irene-knapp> I bet the soname is wrong
20:27:30 <lpsmith> http://hpaste.org/54527
20:27:53 <lpsmith> oh duh
20:28:00 <lpsmith> this is a 64-bit system
20:28:07 <irene-knapp> oh!
20:28:07 <irene-knapp> yeah
20:28:08 <lpsmith> (and a 64-bit ghc)
20:28:15 <lpsmith> that library is 32 bit
20:28:17 <lpsmith> heh
20:28:20 <irene-knapp> good
20:28:26 <lpsmith> well,  but...
20:28:26 <irene-knapp> well, now you know how to fix it, I assume
20:28:31 <monochrom> that's a fun one :)
20:28:36 <irene-knapp> btw, you should get yourself GHC 7.2.2
20:28:37 <irene-knapp> it's out
20:28:56 <lpsmith> but there is /usr/lib64/libgmp.so.3
20:29:03 <irene-knapp> hmmm
20:29:38 <lpsmith> (my experience with CentOS/RHEL is limited.   I've been a Debian user since 2000 or so)
20:30:16 <irene-knapp> objdump -f /usr/lib64/libgmp.so.3
20:30:22 <irene-knapp> and also, I wonder why it's not finding that
20:30:32 <irene-knapp> perhaps it uses LIBPATH or something?
20:30:39 <irene-knapp> but this might be better asked in a CentOS forum?
20:31:19 <lpsmith> http://hpaste.org/54528
20:31:24 <lpsmith> yeah,  that might be
20:31:25 <lpsmith> thanks
20:33:39 <irene-knapp> np
20:33:54 <accel> does there exist any atrocity that lets me use haskell with java libraries?
20:33:59 <irene-knapp> no, haha
20:34:04 <irene-knapp> and you are wrong for even asking
20:35:05 <lpsmith> there was, once upon a time
20:35:14 <irene-knapp> no, you're thinking of javascript
20:35:15 <irene-knapp> I hope
20:35:18 <lpsmith> No, Java
20:35:29 <irene-knapp> wow, nasty
20:36:10 <lpsmith> Ok,  I added a link for libgmp.so in the /usr/lib64 directory and I'm good to go now
20:36:13 <irene-knapp> okay, so seriously, I'm in like week three of this freaking GHC-build bug
20:36:18 <irene-knapp> and I'm ready for it to just work now
20:36:19 <irene-knapp> ah, good!
20:36:40 <irene-knapp> it's actually deeper than a build bug - when I ran validate I found that a lot of things were totally not working
20:37:45 <lpsmith> yeah,  Haskell Haven used some kind of java interop for it's 2-d renderer,   but I never managed to get that working on my system
20:37:53 <lpsmith> I forget what it was called
20:38:10 <irene-knapp> hm, weird
20:38:12 <irene-knapp> interesJNI?
20:38:16 <irene-knapp> *JNI?
20:38:38 <lpsmith> I'm not sure if it was an in-process ffi or not
20:40:16 <lpsmith> irene-knapp, that doesn't sound right
20:40:47 <irene-knapp> hmm
20:40:49 <irene-knapp> okay
20:40:59 <lpsmith> GCJNI
20:41:00 <lpsmith> that's it
20:41:21 <irene-knapp> ah, interesting
20:43:07 <lpsmith> and yes, it appears to be an in-process ffi
20:45:20 <lpsmith> Sgeo, that comment makes sense to me
20:46:49 <Sgeo> lpsmith, thanks
20:46:58 <lpsmith> np
20:47:26 <ddarius> Sgeo: The Linq (i.e. monadic) syntax by itself would only allow sequential composition, so that it is pretty clear that other combinators would be necessary.
20:47:58 <ddarius> A more pointed response to one of the other repliers, would be that monadic parsers are not restricted to be context-free.
20:47:59 <lpsmith> ddarius, thanks.   I should learn linq at some point
20:48:11 <lpsmith> heh
20:48:21 <Sgeo> ddarius, I don't know much about parsing, other than what little I know of Parsec
20:49:25 <lpsmith> Does Mono support LINQ by now out of curiousity?
20:51:11 <ddarius> Sgeo: Okay, then just write: var r = from as in "a".Find().Many() let n = as.Length from bs in "b".Find().Count(n) from cs in "c".Find().Count(n) select { as, bs, cs }
20:51:19 <lpsmith> ಠ_ಠ  http://www.ibm.com/developerworks/linux/library/l-shared/index.html
20:51:25 <ddarius> I'm making up the combinators Many and Count.
20:51:44 <Sgeo> ddarius, I don't know if the commentors will even ever see this
20:54:14 <augur> what other sorts of computational complexity are there other than space and time complexity?
20:54:25 <irene-knapp> development complexity :)
20:54:30 <ddarius> augur: You can make up any kind you want.
20:54:33 <augur> i know of these things called arithmetic hierarchies, etc. but i dont know if those constitute distinct kinds of complexity
20:54:37 <ddarius> E.g. how many disk accesses.
20:54:46 <Sgeo> ddarius, I think they'd be more interested in the combination of <|> and try
20:55:08 <irene-knapp> like for example, quicksort is O(n*lg n) in time, but O(three bananas) in developer brainpower required to invent it the first time
20:55:15 <augur> ddarius: ahh, so, for turing machines tho, are there any other nice, well defined classes? or ones that are _important_?
20:55:21 <augur> irene-knapp: O(three bananas) lol
20:55:25 <irene-knapp> yep
20:56:00 <shachaf> irene-knapp: O(three bananas) is obviously the same thing O(banana).
20:56:07 <irene-knapp> (I can't take credit for the basic gag of measuring brainpower in bananas, sadly, I took it from the famous HACMEM :) )
20:56:08 <augur> one of erik demaines friends as a kid said once
20:56:16 <augur> "i know how to spell banana i just dont know when to stop"
20:56:19 <augur> lolololol
20:56:26 <irene-knapp> haha yeah
20:57:22 <irene-knapp> well, see, if you use a Markov chain of bigrams, right
20:58:19 <Sgeo> ddarius, would it be possible to write Many and Count such that they do backtracking?
20:58:34 <irene-knapp> sorry, trigrams
20:58:39 <irene-knapp> and there's no other instance of "ana" in your source text
20:58:44 <irene-knapp> then you really don't know when to stop
21:00:23 <irene-knapp> but anyway, "three bananas" is a special notation, right
21:00:33 <irene-knapp> like aleph-null and aleph-one are unrelated numbers
21:00:43 <irene-knapp> it's like, shorthand for banana cubed
21:01:05 <irene-knapp> yes it's a horrible notation, but you can't cancel the d in dy/dx, either
21:09:56 <Cale> irene-knapp: well, they're not totally unrelated...
21:10:25 <irene-knapp> Cale: well, yes
21:12:41 <Sgeo> ddarius, I'm not going to post that. I don't know whether it's possible to make backtracking Many() and Count()
21:13:21 <Cale> They're the smallest and second smallest infinite cardinalities respectively :)
21:13:29 <irene-knapp> haha true true
21:14:23 <dufflebunk> I'll be writing a program to search around in a binary file format. I plan to use Data.Binary to help with the parsing, so I need to use ByteStrings. But I also have to seek around the file which requires calls directly to the Handles. In most cases, I won't know how much data I need to read so I was figuring on using lazy bytestrings and hGetContents. Is there a better way? Would this approach cause problems (given bytest
21:14:23 <dufflebunk> ring might buffer stuff from before the handle seek)?
21:14:34 <ddarius> Sgeo: Sure it is.
21:15:24 <Sgeo> ddarius, would bind need to be rewritten from what's used in the posts?
21:17:23 <Cale> dufflebunk: hGetContents and seek together is kinda weird... it might work, but it might just be insane :P Doing stuff with a handle that you've given to hGetContents (including closing it), is generally "dangerous".
21:17:41 <Cale> dufflebunk: but you could probably seek before the hGetContents
21:18:06 <ddarius> Sgeo: The issue is how choice is handled not how bind is handled.
21:18:31 <rwbarton> dufflebunk: I don't know whether this is a good solution in your case, but I did something similar by just mmap'ing the whole file into memory.
21:18:36 <Sgeo> ddarius, are you sure you don't want to post a comment?
21:21:32 <dufflebunk> Cale, the idea would be that I seek, then get the contents. But doing this seems strange and non-haskellish
21:22:13 <dufflebunk> rwbarton, using the bytestring-mmap package?
21:22:26 <rwbarton> Yes
21:22:39 <ddarius> When you execute hGetContents on a handle, that handle enters a semi-closed state.
21:23:01 <rwbarton> then you can effectively "seek" with Data.ByteString.drop
21:23:21 <rwbarton> and take, and pass whatever part of the file you're interested in to Data.Binary
21:24:44 <dufflebunk> rwbarton, what about going backwards? I'll be bouncing all over the file.
21:25:29 <dufflebunk> ddarius, oh, once it's semi-closed I can't hSetPosn anymore, can I?
21:25:30 <rwbarton> that's fine too, just hang on to the original bytestring
21:26:17 <dufflebunk> rwbarton, Ah, yes!
21:26:19 <ddarius> dufflebunk: Mem-mapping the file means that memory offsets and file offsets are the same.  You only read in what you actually touch (modulo page size.)
21:26:55 <dufflebunk> although I'm not too crazy about the function name unsafeMMapFile
21:27:18 <ddarius> The issues are presumably comparable to hGetContents.
21:27:30 <ddarius> Well, lazy hGetContents.
21:27:37 <dufflebunk> I would think so too.
21:27:57 <rwbarton> well, it's a bit worse, even after you've read the whole file, it can still change out from under you later
21:27:59 <ddarius> Well, it is a bit worse because hGetContents won't read from the file twice.
21:28:50 <rwbarton> in general though, if you are subject to that kind of race condition (someone modifying the file while you are running), you are also probably going to have a race condition in which someone modifies while you read it with hGetContents
21:29:44 <dufflebunk> Yeah, I'm not worried about this, these are read only files.
21:30:06 <dufflebunk> it's just the function name starting with "unsafe" freaks me out a little.
21:30:17 <irene-knapp> it's supposed to haha
21:30:41 <ddarius> Call lazy hGetContents, unsafeHGetContents, then everything in copacetic.
21:31:34 <Sgeo> ddarius, maybe you should post a comment?
21:31:46 <ddarius> Sgeo: Why?
21:32:28 <Sgeo> Because I'm still uncertain what exactly you want me to post. I'm uncertain whether they'd need to change their bind, or put more data into the type that they're using
21:32:38 <Sgeo> "The internals of the monadic parser might need to be different though."
21:34:06 <Sgeo> ddarius, should I say that?
21:34:19 <dufflebunk> The docs mention stuff about the GC needing some manual calls to reduce memory use. But doesn't explain why the problems with an mmapped bytestring would be any worse than a lazy hGetContents.
21:34:34 <dufflebunk> Is it worse, or just more thoroughly documented?
21:35:31 <ddarius> Sgeo: The only purpose of that example is to demonstrate that monadic parsers are readily capable of parsing context-sensitive grammars, though really the first replier's biggest mistake is thinking that the particular approach described in this series of blog post is "the" notion of monadic parser.
21:37:22 <ddarius> dufflebunk: It doesn't say that they are necessary, just that they may reduce memory footprint.
21:37:41 <ddarius> Basically, no memory is going to be released until the finalizers run.
21:38:21 <Sgeo> Posted
21:38:42 <ddarius> This should happen when a garbage collection notices that the file is garbage, but may happen later.
21:39:24 <dufflebunk> ddarius, so it's no different than anything else, right?
21:39:45 <ddarius> More or less.
21:40:18 <ddarius> Note that to memory-map a file, you need to allocate enough address space for the entire file.
21:46:18 <pramod> hi folks! i have a quick question. In the data.integer.presburger module, what does the (Integer :| Term) operation mean?
21:46:26 <pramod> link to the docs are over here: http://hackage.haskell.org/packages/archive/presburger/0.4/doc/html/Data-Integer-Presburger-HOAS.html
21:46:48 <ddarius> dufflebunk: The documentation for System.IO.Posix.MMap.Lazy gives more detail about the issues with memory pressure.
21:47:12 <c_wraith> pramod: infix operators that start with : are data constructors
21:47:26 <c_wraith> pramod: Or type constructors, as in that case
21:48:01 <pramod> oh I see. is it creating a term out of an integer?
21:48:03 <ddarius> pramod: My guess is that in represents that a "constant" integer divides a term.
21:48:27 <pramod> ddaris: I think that makes sense. thanks!
21:57:00 <dufflebunk> henh, "The result is that finalizers run less often than you might expect"   well, since I have no expectations I guess I won't be disappointed.
22:01:35 <JoeyA> I'm struggling with writing concurrent applications in Haskell cleanly.  I usually end up with a giant "loop" or "worker" function, as opposed to several well-divided components.  What's a good concurrent application to look at whose implementation is well-organized?
22:02:12 <Sgeo> Can all C# LINQ providers be turned into Haskell monads?
22:02:29 <JoeyA> I do separate concerns of communication, working with the database, etc., but it's a big mess when I tie it all together.
22:02:33 <Sgeo> I know Haskell monad -> C# LINQ thingy is possible, since there's a mechanical way to turn bind and return into a selectmany
22:03:17 <JoeyA> Sgeo: I don't know much about C# or LINQ, but I think you need more generality than the Monad class.
22:03:24 <JoeyA> For example, consider this list comprehension:
22:03:39 <JoeyA> > [(a,b) | a <- [1..5], b <- [1..5], a < b]
22:03:41 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
22:03:57 <JoeyA> The a <- [1..5], b <- [1..5] parts are actions in the List monad.
22:04:14 <Sgeo> JoeyA, sounds like MonadZero?
22:04:15 <JoeyA> However, a < b is a guard, which goes beyond the definition of Monad
22:04:18 <JoeyA> Right
22:04:24 <JoeyA> In this case, I think it's MonadPlus
22:04:26 <JoeyA> not sure
22:04:29 <JoeyA> @hoogle guard
22:04:30 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
22:04:30 <lambdabot> Language.Haskell.TH.Syntax data Guard
22:04:30 <lambdabot> Language.Haskell.TH data Guard
22:04:35 <Sgeo> Hm
22:04:50 <JoeyA> > do { a <- [1..5]; b <- [1..5]; guard (a < b); return (a,b) }
22:04:52 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
22:04:57 <Sgeo> I think you'd need to implement Where to get where in LINQ
22:05:23 <Sgeo> But given an arbitrary SelectMany, can you mechanically determine return and bind?
22:06:08 <ski> JoeyA : well, `MonadZero' is sufficient for `guard'
22:06:46 <ski> Sgeo : `Where' does ?
22:07:52 <Sgeo> Um, I think the equivalent of the type in Haskell would be
22:08:28 <Sgeo> (Monad m) => m a -> (a -> Bool) -> m a
22:09:04 <JoeyA> @type filter
22:09:06 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:09:11 <JoeyA> @type mfilter
22:09:13 <lambdabot> Not in scope: `mfilter'
22:09:20 <Sgeo> @hoogle (Monad m) => m a -> (a -> Bool) -> m a
22:09:21 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
22:09:21 <lambdabot> Test.QuickCheck.Gen suchThat :: Gen a -> (a -> Bool) -> Gen a
22:09:21 <lambdabot> Test.QuickCheck suchThat :: Gen a -> (a -> Bool) -> Gen a
22:09:36 <Sgeo> @src mfilter
22:09:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:09:43 <Sgeo> @src Control.Monad.mfilter
22:09:44 <lambdabot> Source not found. You untyped fool!
22:09:48 <JoeyA> > mfilter (<3) [1..5]
22:09:50 <lambdabot>   Not in scope: `mfilter'
22:10:41 <ski> hm, `selectMany :: forall a b c. m a -> (a -> m b) -> (a -> b -> c) -> m c', and i think the only sensible implementation of that is `selectMany ma amb abc = ma >>= \a -> amb a >>= \b -> return (abc a b)' (which is the same as `selectMany ma amb abc = ma >>= \a -> liftM (abc a) (amb) a' (or `fmap' instead of `ligtM', if you prefer))
22:11:36 <Sgeo> Supposing you have a selectMany though. Can you write return and (>>=) from it?
22:12:10 <ski> @type \p ma -> ma >>= \a -> guard (p a) >> return a
22:12:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> m a -> m a
22:12:43 <ski> @type (=<<) . (\p a -> guard (p a) >> return a)
22:12:44 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
22:12:58 <ddarius> Sgeo: Yes.
22:13:06 <Sgeo> Ah, ok
22:13:23 <byorgey> Sgeo: well, m >>= f = selectMany m f (flip const)
22:13:34 <ski> @type let selectMany :: forall a b c. m a -> (a -> m b) -> (a -> b -> c) -> m c; selectMany ma amb abc = ma >>= \a -> liftM (abc a) (amb) a in \ma amb -> selectMany ma amb (\_ b -> b)
22:13:36 <lambdabot> Not in scope: type variable `m'
22:13:36 <lambdabot> Not in scope: type variable `m'
22:13:36 <lambdabot> Not in scope: type variable `m'
22:13:40 <ddarius> Well, you can't write return from it without return.
22:13:46 <ski> @type let selectMany :: Monad m => m a -> (a -> m b) -> (a -> b -> c) -> m c; selectMany ma amb abc = ma >>= \a -> liftM (abc a) (amb) a in \ma amb -> selectMany ma amb (\_ b -> b)
22:13:48 <lambdabot>     Occurs check: cannot construct the infinite type: c = m c
22:13:48 <lambdabot>     When generalising the type(s) for `selectMany'
22:13:48 <lambdabot>     In the expression:
22:13:55 * ski sighs
22:14:35 <ddarius> But (the Linq form of) SelectMany is only an analog to bind, and there's another overload of SelectMany that corresponds directly to bind.
22:14:50 <ski> @type let selectMany :: Monad m => m a -> (a -> m b) -> (a -> b -> c) -> m c; selectMany ma amb abc = ma >>= \a -> liftM (abc a) (amb a) in \ma amb -> selectMany ma amb (\_ b -> b)
22:14:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:14:56 <ddarius> Sgeo: In that blog post, return is ToParser.
22:15:24 <Sgeo> ddarius, that's all well and good, but if you can't write return from SelectMany, then there are some LINQ providers that are not monads
22:16:10 <Sgeo> Or, can be
22:16:18 <Sgeo> Not sure what that would look like though
22:16:23 <ddarius> I'm pretty sure Linq providers need to provide much more than SelectMany, but, yes, there are probably possible implementations that wouldn't correspond to monads.
22:18:10 <ddarius> Of course, SelectMany doesn't have any "laws" so you can simply make an implementation of SelectMany that fails to be a monad because it isn't "associative."
22:47:15 <accel> is there any symbolic math or math typesetting program in haskell?
23:00:07 <drbean> I would like ghc not to say "In the first argument of `Const', namely" if Const only has one argument.
23:19:56 <shachaf> drbean: Why? Is it really worth special-casing?
23:20:03 <shachaf> Anyway, feel free to submit a patch. :-)
