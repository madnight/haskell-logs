00:28:33 <Blkt> good morning everyone
00:37:05 <koala_man> is there something like 4clojure.com for haskell? something with interactive haskell exercises?
00:37:38 <asante> tryhaskell.org
00:37:40 <shachaf> koala_man: There's tryhaskell.org
00:37:50 <shachaf> It's not really the same thing, though.
00:37:54 <asante> some simple getting-startet
00:38:00 <shachaf> koala_man: Feel free to make one!
00:40:28 <asante> koala_man: http://www.spoj.pl/ also supports haskell solutions.
00:40:32 <koala_man> neat. is there any way to get more than a 40*7 size console?
00:41:21 <asante> but that sphere online thing is more like a coding-challenge-site
00:41:53 <ddarius> One could do the 4clojure exercises in Haskell.
00:41:55 <test_man> hah, IRC integration
00:43:53 <shachaf> ddarius: But you wouldn't accumulate valuable 4clojure.com points!
00:43:58 <erus`> is there a ghc command to reload the current module?
00:44:14 <shachaf> Will 4cloje for food.
00:44:19 <shachaf> erus`: :reload
00:44:19 <asante> :r
00:44:23 <shachaf> See also :help
00:44:27 <mythmon> :r looks like an emoticon...
00:44:36 <ddarius> shachaf: Simply write a Haskell interpreter in Clojure to start.
00:44:44 <asante> mythmon, ;)
00:44:50 <mythmon> asante: weird, so does that!
00:46:37 <asante> someone read "learn you a haskell for great good"? startet with the first chapters online and it looks goot
00:46:41 <asante> *good
00:47:00 <asante> but are there some tasks in there?
00:47:19 <shachaf> asante: Several people in here recommend it.
00:48:55 <asante> ya, i realy like the style.. but i would miss exercises if there are none..
00:49:33 <shachaf> asante: Reïmplement the Prelude.
00:49:44 <donri> @where 99problems
00:49:45 <lambdabot> I know nothing about 99problems.
00:49:49 <donri> :(
00:51:25 <asante> shachaf, ok. good idea
00:51:36 * shachaf isn't sure whether it's a good idea or not.
00:51:45 <shachaf> But it'll probably teach you something.
00:51:57 <asante> ya, i'll think about it
00:52:54 <deggis> i'm hoping some matrix package in hackage implements correlation matrix calculation. any ideas where i could find it?
00:52:55 <mgsloan> got 99 problems, but a switch aint one?
00:53:32 <min> i don't know: reimplementing standard modules is like learning latin rote. first with dictionary, grammar and style guide, then one less, until everything is memorized. it's certainly effective.
00:53:43 <donri> i've got 99 problems and regex will solve them all
00:54:04 <donri> regex represented with an xml dialect, of course
00:54:21 <donri> in turn parsed with regex
00:55:05 <min> parsing xml with regex represented with an xml gives me nightmares.
00:57:16 <fragamus> /Users/michaelgough/matrix/takeone
00:57:21 <fragamus> cat /Users/michaelgough/matrix/Route.kml >> /Users/michaelgough/matrix/results
00:57:21 <fragamus> rm  /Users/michaelgough/matrix/Route.kml
00:57:24 <fragamus> /Users/michaelgough/matrix/takeone
00:57:28 <fragamus> /Users/michaelgough/matrix/takeone
00:57:34 <fragamus> cat /Users/michaelgough/matrix/Route.kml >> /Users/michaelgough/matrix/results
00:57:34 <fragamus> rm  /Users/michaelgough/matrix/Route.kml
00:57:37 <fragamus> /Users/michaelgough/matrix/takeone
00:57:41 <fragamus> /Users/michaelgough/matrix/takeone
00:57:45 <opqdonut> errr
00:57:52 <fragamus> /Users/michaelgough/matrix/takeone
00:57:57 <fragamus> /Users/michaelgough/matrix/takeone
00:58:04 <fragamus> /Users/michaelgough/matrix/takeone
00:58:07 <opqdonut> please stop
00:58:08 <fragamus> /Users/michaelgough/matrix/takeone
00:58:10 <shachaf> @where ops
00:58:10 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:59:02 <fragamus> /Users/michaelgough/matrix/takeone
00:59:06 <fragamus> /Users/michaelgough/matrix/takeone
00:59:14 <fragamus> /Users/michaelgough/matrix/takeone
00:59:18 <fragamus> /Users/michaelgough/matrix/takeone
00:59:32 <Maxdamantus> @tell fragamus to stop
00:59:32 <lambdabot> Consider it noted.
00:59:39 <fragamus> /Users/michaelgough/matrix/takeone
00:59:40 <lambdabot> fragamus: You have 1 new message. '/msg lambdabot @messages' to read it.
00:59:43 <fragamus> /Users/michaelgough/matrix/takeone
00:59:45 <Maxdamantus> Oh god.
00:59:49 <elliott> /Users/michaelgough/matrix/takeone!
00:59:50 <Maxdamantus> Ah, not bad.
00:59:52 <elliott> can i join in too?
00:59:52 <mrmist> fragamus: Knock it off
00:59:53 <fragamus> /Users/michaelgough/matrix/takeone
01:00:14 <Philonous> mrmist:  Probably his irc client acting up.
01:00:16 <elliott> deggis: hmatrix?
01:00:39 <mrmist> Philonous: Looks like he fixed it by quiting :)
01:00:59 <donri> symptom of a broken user interface, if you can mispaste like this
01:01:01 <opqdonut> recovering from a huge mispaste is not easy
01:02:45 <donri> preventing it in the future however, is. just don't use crappy clients like irssi et al. *not trolling*
01:03:16 <shachaf> donri: irssi wouldn't do that.
01:03:24 <donri> sure it would, it's paste protection is broken
01:03:28 <donri> its*
01:03:35 <shachaf> It's always worked for me.
01:04:02 <donri> well, i only ever see mishaps like this from users of terminal-based clients
01:04:41 <nazgjunk> It often doesn't work when you're on a *slightly* laggy ssh line
01:05:29 <donri> yea, i think the terminal has no concept of "receiving a paste" as such, rather the keystrokes are simulated directly
01:05:47 <erus`> http://www.wikihow.com/Inverse-a-3X3-Matrix im stuck on the last step. where does 'coffmt' come into this?
01:05:58 <donri> graphics in the terminal is a silly hack
01:06:09 <shachaf> Computers are silly hacks.
01:06:16 <donri> :)
01:07:26 <deggis> elliott: didn't find it there, but at least hmatrix-gsl-stats offers correlation of two vectors
01:19:27 <erus`> matrix-adj = transpose ∘ cofactors ∘ minors ∘ transpose      is that correct?
01:23:27 <frerich> erus`: Regarding the "backslash in string should not be rendered as lambda" issue with unicode-haskell.vim you pointed out a few days earlier: yes, agreed. I just didn't know how to tell that I'm inside a string in vimscript. My vim-fu is not strong enough. :-}
01:26:41 <erus`> the inverse of identity should be identity right
01:26:46 <erus`> mine is wrong :*(
01:27:38 <erus`> fixed, yey for silly typos
01:28:56 <erus`> o man it works
01:29:13 <erus`> this is the most hardcore math i have ever done
01:30:04 <erus`> frerich: did you patch it yet?
01:30:23 <frerich> erus`: Patch this particular problem, you mean?
01:30:33 <erus`> yes
01:31:06 <frerich> erus`: No, I didn't. As I said, my vim-fu is not strong enough to detect whether I'm currently in a string or not (read: whether a backslash should be a lambda or not). :-}
01:31:36 <erus`> ok maybe i will have a look later and submit a pull request or something if i can figure it out
01:31:53 <frerich> erus`: That would be pretty cool.
01:35:25 <jpcooper> hello
01:36:27 <Starfire> frerich: If vim
01:36:27 <jpcooper> I'm trying to do cabal install --reinstall -p text (0.11.1.5), but I'm getting an ExitFailure 9 error. The problem is that even with -v2, there is no extra error information. Does anyone have a suggestion?
01:36:52 <Starfire> frerich: If vim's syntax highlighting produces a good enough result for you, you could use the synID() function or similar to detect whether you're in a string or not.
01:52:57 <donri> http://www.vim.org/scripts/script.php?script_id=3200 this one gets it right btw
01:56:55 <earthy> BTW, may I suggest that if people want the haskell syntax highlighter for vim updated in the vim distribution, just tell me
01:57:05 <earthy> easily arranged. :)
01:57:57 <ion> donri: How about if you’re using a table-like code layout?
01:58:04 <donri> earthy: I use http://www.vim.org/scripts/script.php?script_id=3034
01:58:17 <ion> foo  -> bar
01:58:20 <ion> baz  !! quux
01:58:38 <ion> If -> is replaced by →, are bar and quux still in the same column?
01:59:00 <dhun_233> hello I am trying to proof   fmap f x = pure f <*> x can anybody give me some hints
01:59:03 <earthy> donri: is it good enough to push on to all haskell users?
01:59:12 <donri> probably not. but at least with conceal you get the actual text if the cursor is on that line
01:59:40 <ion> @type fmap
01:59:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:59:48 <earthy> I'll have a look at it
01:59:52 <ion> @type \f -> (<*>) pure f
01:59:53 <lambdabot> forall b a. (b -> a) -> b -> b
01:59:59 <ion> @type \f -> (<*>) (pure f)
02:00:01 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
02:00:19 <donri> earthy: that i can't tell, but in particular it doesn't barf on quasiquotes
02:00:39 <earthy> donri: yeah, the haskell syntax highlighter in the vim distribution is... old. :)
02:00:51 <dhun_233> the point is that there are four law for applicative and it says that the equation for fmap follows from them
02:01:10 <earthy> and was not perfect but mostly good enough at that time
02:01:13 <donri> although it treats all qq's as "don't highlight", but the plain one should still highlight as haskell
02:01:32 <donri> aka. [| ohai i'm a haskell expression |]
02:01:41 * earthy nods
02:02:19 <donri> still, better than having [randomQQ| |] highlight as haskell
02:02:59 <min> i thought that fmap f x = pure f `ap` x /wasn't/ derivable. rather, that it is a condition of being an instance of applicative. interesting.
02:04:10 <earthy> donri: yeah, as I stated, it's mostly good enough. :)
02:04:24 <earthy> (haven't looked at it in 3 years, I see)
02:04:31 <donri> heh
02:04:51 <_oz> dhun_233, min: this was being discussed yesterday as well. someone said the proof follows from parametricity.
02:05:20 <dhun_233> what does parametricity mean?
02:06:18 <earthy> anyway, it's also about time to add a compiler file for ghc to vim
02:06:19 <earthy> methinks
02:06:45 <earthy> possibly a smarter indenter
02:07:53 <dhun_233> have you got a log of yesterdays discussion I can look at?
02:08:04 <_oz> dhun_233: i am not the best person to describe. apparently wadler's free theorems paper discusses this in detail.
02:08:38 <_oz> everything you say is logged mate: http://tunes.org/~nef/logs/haskell
02:08:53 <_oz> big brother :P
02:09:20 <min> dhun_233: interesting. i'd be intersted in seeing the proof, because i'm drawing a blank.
02:10:15 <_oz> dhun_233, min: see discussion around 11:28 at http://tunes.org/~nef/logs/haskell/11.11.13
02:10:26 <_oz> for the one I was referring to.
02:11:20 <donri> earthy: maybe also https://github.com/dag/hlint
02:16:33 <dhun_233> I looked at the log, so I will have to read the paper first, and then try again
02:16:37 <frerich> donri: Thanks for pointing out http://www.vim.org/scripts/script.php?script_id=3200 ! Didn't try it yet, but it looks much nicer than what I wrote myself. I wasn't aware of the 'conceal' feature. Maybe I'll abadon my own stuff in favor of that. :-)
02:16:55 <dhun_233> what I found out for now is that is holds for id
02:17:13 <dhun_233> and if it holds for f and g it also holds for f . g
02:18:07 <dhun_233> that follows directly from the functor laws, but thats the end of my approach so far
02:29:20 <earthy> donri: good point.
02:33:19 <ddarius> dhun_233: What are the four laws you are using?
02:38:00 <dhun_233> http://www.haskell.org/haskellwiki/Category_theory/Functor
02:38:21 <dhun_233> axioms 2 and 3
02:38:48 <dhun_233> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Applicative.html
02:38:57 <dhun_233> some of the first 4 laws
02:42:07 <dhun_233> ddarius, what I remember for a talk a little bit, is that you can build functional programming for a few basic functions
02:42:28 <dhun_233> so possible you can proof it by proofing it for the basic function
02:42:54 <dhun_233> I think the basic functions were const id (.) but I am not sure
02:43:13 <dhun_233> furthermore I can't proof nor find a counterexample for const
02:44:41 <ddarius> dhun_233: The laws in Control.Applicative say nothing about fmap and thus you will not be able to derive the identity from them.
02:44:50 <elliott> dhun_233: S and K are turing complete (as an untyped language language)
02:45:01 <elliott> = (->)'s (<*>) and const
02:45:08 <elliott> const id (.) is definitely not TC.
02:46:59 <dhun_233> I also saw that fmap is not mentioned in the Control.Applicative laws, and thats why I started to look at it in more detail
02:50:38 <dhun_233> elliott thanks, that now I at least know the right article http://en.wikipedia.org/wiki/SKI_combinator_calculus
02:53:31 <elliott> dhun_233: np
02:57:57 <ddarius> If you want to show that fmapCandidate f x = pure f <*> x satisfies the Functor laws, the first one is the first law listed in Control.Applicative, the second one states: pure (f . g) <*> x =? pure f <*> (pure g <*> x).  Going backwards-like, pure (f . g) <*> x = (pure (f .) <*> pure g) <*> x = (pure (.) <*> pure f <*> pure g) <*> x = (pure f <*> (pure g <*> x))
03:00:35 <Saizan> there's only one function that satisfies the Functor laws, so if your candidate does it's the same function as the one chosen to make the instance
03:01:49 <ddarius> Saizan: I'm not sure that that is generally true, though I'm pretty certain it is true for regular types.
03:02:40 <ddarius> In a different context, the applicative laws can be applied to arbitrary categories where it certainly does not need to be the case.
03:06:09 <dhun_233> why is there only one function that satisfies the functor laws
03:06:38 <Saizan> it's true if the relation you build for F in the statement of the abstraction theorem is equivalent to equality when applied to the identity relation for the argument type
03:07:26 <Saizan> so yeah, it's not going to hold for functors and applicatives in general
03:08:02 <dhun_233> well I still didn't understand what you sayd, is there something I could read first
03:09:22 <Saizan> that same wadler's paper :)
03:09:54 <dhun_233> so I will first of all read that, and than I will come back if I still don't see
03:14:02 <erus`> can i tell ghci to look for modules in a certain dir?
03:21:31 <cheater> hi
03:21:34 <cheater> if i have a type
03:21:57 <cheater> and i partition it into subtypes, e.g. i take btree and partition it into btrees of depth 0, 1, etc
03:22:16 <cheater> and i prove Q(b_n) for all n, where b_n is a btree of depth n
03:22:29 <cheater> then have i proven Q(b) where b is the type btree?
03:23:21 <bxc> yes
03:23:41 <byorgey> cheater: not in Haskell; that doesn't take into account infinite btrees
03:23:45 <ddarius> cheater: No.
03:23:51 <ddarius> For the reason byorgey said.
03:23:56 <byorgey> but if you only care about inductive/finite btrees then yes
03:24:10 <bxc> oh yes infinity
03:24:48 <ddarius> E.g. "length terminates on lists of length n for n = 0, 1, etc." is true (obviously) but "length terminates on all lists" is false.
03:26:12 <ddarius> Also, you have to cover the cases of partially defined values.
03:26:49 <ddarius> But technically, that should have been covered in your inductive cases.
03:26:59 <bxc> ddarius: though you didn't "partition it into subtypes" because you didn't partition it in that statement - so cheater's partition statement is missing a case
03:27:14 <bxc> (the infinite case)
03:28:34 <asante> no starch press has this offer for free ebooks with printed ones. when i buy "learn you a haskell.." do i get a code in the book for downloading the ebook version?
03:28:49 <sadgur> nah
03:28:54 <sadgur> it gives you a download link asante
03:29:08 <sadgur> on the no starch press website
03:29:11 <Baughn> Would there be any trouble integrating Haskell and Python, i.e. with haskell as a python extension module?
03:29:42 <asante> sadgur, and the link is printed in the book? so i'll get that when buy via amazon, too?
03:30:17 <asante> cause buying it at the no starch press-site would make 15$ shippment..
03:30:36 <sadgur> asante: No, what i got was a confirmation of the order then a link also by e-mail
03:30:46 <sadgur> asante: afaik it is not in the book
03:31:30 <nazgjunk> It is not in the book, no
03:31:30 <asante> what a pitty..
03:31:34 <asante> thanks
03:31:53 <sadgur> give me one sec asante
03:32:04 <sadgur> might have a solution
03:33:45 <sadgur> asante: ah no thought i had a voucher code for the site but it's expired nvm
03:34:16 <asante> sadgur, but, thanks anyway!
03:35:16 <sadgur> no worries
03:35:28 <erus`> is Floating a real?
03:36:13 <erus`> i guess not
03:41:39 <sjoerd_visscher> did anybody notice yet that Hackage is not building packages the last few days?
03:44:29 <byorgey> sjoerd_visscher: yes, I have noticed that too
03:48:07 <sjoerd_visscher> Any idea if somebody is working on that?
03:51:35 <cheater> byorgey/ddarius: i'm talking about theory in general, i guess haskell is a good example though
03:52:27 <cheater> byorgey: can i inductively reason about btrees?
03:52:37 <byorgey> cheater: well, in general, it depends on the semantics you have for your data types.
03:52:41 <cheater> going from finite btrees to infinite btrees?
03:53:10 <Saizan> ddarius, dhun_233: here's how it looks in agda for what it's worth http://code.haskell.org/~Saizan/Functor.agda
03:53:59 <byorgey> cheater: if you want to reason about infinite btrees you have to use coinduction.
03:54:25 <cheater> what is that?
03:54:28 <byorgey> cheater: you can inductively reason about all finite btrees.
03:54:38 <byorgey> cheater: why, the categorical dual of induction, of course ;)
03:55:17 <byorgey> cheater: more seriously, I don't have time to explain it at the moment
03:55:37 <byorgey> but I can explain later, or you can try googling for a reference
04:01:57 <dgpratt> hey byorgey, do you still have a picture of the Maine coast as your desktop background? :)
04:05:24 <pchiusano> what is the difference between lazy StateT and strict StateT?
04:07:01 <Saizan> one matches strictly on the tuple constructor in (>>=)
04:07:51 <pchiusano> matches strictly… meaning it determines it is a tuple, but does not evaluate the elements of the tuple?
04:08:10 <Saizan> right
04:08:11 <pchiusano> or does it force the elements of the tuple also
04:08:17 <Saizan> nope
04:08:38 <pchiusano> so the lazy version does not even determine that it is a tuple yet
04:09:06 <pchiusano> until one of the elements of the tuple is referenced
04:09:11 <pchiusano> ?
04:09:14 <Saizan> yeah, it uses let instead of case
04:09:31 <pchiusano> ok thanks :)
04:09:33 <Saizan> let (x,y) = .. in .. rather than case .. of (x,y) -> ..
04:12:40 <pchiusano> makes sense
04:13:43 <cheater> byorgey: thanks, i'm reading up on coinduction
04:14:53 <ski> cheater : you might try Bart Jacobs "A Tutorial on (Co)Algebras and (Co)Induction" at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf>
04:21:11 <erus`> @hoogle (a->a) -> a -> Int
04:21:12 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
04:21:12 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
04:21:12 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:21:26 <erus`> @hoogle (a->a) -> a -> Integer -> a
04:21:27 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
04:21:27 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
04:21:27 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
04:22:22 <erus`> is there a fix with a limit?
04:23:41 <ski> @type \n f -> (`genericIndex` n) . iterate f
04:23:43 <lambdabot> forall b a. (Integral a) => a -> (b -> b) -> b -> b
04:24:36 <cheater> hey i was reading conor mcbride's paper on holes and contexts, and in there he says that a btree can be represented as the "unique leaf and two btrees", which he denotes as btree = 1 + btree^2. i don't see this construction. how does this work?
04:24:52 <cheater> he also says that a ternary tree can be represented as ttree = 1 + ttree^3
04:27:25 <ski>   data BTree0 = Tip
04:27:27 <ski>               | Branch BTree0 BTree0
04:27:30 <ski>   data BTree1 = Tip
04:27:38 <ski>               | Branch (BTree1,BTree1)
04:27:54 <erus`> if i keep multiplying a matrix by another will it lose orthogonality ?
04:28:04 <ski>   data BTree2 = Tip ()
04:28:08 <ski>               | Branch (BTree2,BTree2)
04:28:35 <ski>   data BTree3 = Node (Either () (BTree3,BTree3))
04:29:13 <DRMacIver> Hm. Any suggested workarounds for the fact that criterion doesn't work with the latest version of statistics?
04:29:17 <ski> cheater : so a binary tree `BTree' here is basically `Either () (BTree,BTree)', which McBride writes as `1 + BTree * BTree', or `1 + BTree^2'
04:30:27 <ski> `1' representing the set/type of one element, and `BTree * BTree' (which is `(BTree,BTree)' in Haskell syntax) representing the cartesian product of `BTree' with itself
04:36:07 <_Mikey> hello people!
04:36:22 <ski> hello yourself
04:36:29 <_Mikey> how are things?
04:37:03 * ski is looking at a coalgebra and coinduction tutorial
04:37:24 <_Mikey> nice..
04:37:36 * _Mikey is trying to get my head around parameterized types
04:37:42 <ski> ok
04:37:51 <ski> any specific example you're pondering ?
04:38:07 <erus`> can i have a strict forall ?
04:38:15 <ski> erus` : huh ?
04:38:23 <_Mikey> well I'm really wondering. what exactly they're good for
04:38:24 <erus`> go :: (a -> a) -> !a -> Integer -> a
04:38:35 <_Mikey> minus the nulling thing with Maybe
04:38:36 <cheater> ski: is the + in 1 + Btree^2 actually the disjoint sum |_| ?
04:38:42 <ski> cheater : eys
04:38:47 <ski> s/eys/yes/
04:38:53 <ski> _Mikey : well, consider the case of lists
04:39:07 <_Mikey> it Maybe empty
04:39:12 <_Mikey> it Maybe not.
04:39:18 <ski> _Mikey : it would be quite tiring if every time you need a list with a new kind of element, you would have to define a new data type
04:39:25 <ski> like :
04:39:44 <_Mikey> hmm
04:39:56 <ski>   data IntList = IntNil
04:39:57 <ski>                | IntCons Int IntList
04:40:06 <ski>   data StringList = StringNil
04:40:16 <ski>                   | StringCons String StringList
04:40:18 <ski>   &c.
04:40:29 <ski> also, it doesn't stop there, one'd also need
04:40:37 <cheater> ski: that was really well explained, thanks!
04:40:39 <ski>   lengthIntList :: IntList -> Int
04:40:56 <ski>   lengthIntList  IntNil        = 0
04:40:58 <cheater> btw, another question: finite lists are data whereas infinite lists are codata, yes?
04:41:04 <_Mikey> so we're sthmm
04:41:04 <erus`> > let go f a 0 = a; go f a n = go f (f a) (n - 1) in go (+ 1) 0 5
04:41:05 <lambdabot>   5
04:41:13 <ski>   lengthIntList (IntCons _ ns) = 1 + lengthIntList ns
04:41:14 <_Mikey> we're still haven't to create for each type
04:41:20 <erus`> can i add a seq in there somewhere to make it strict?
04:41:20 <_Mikey> and it still seems parameterized
04:41:24 <ski>   lengthStringList :: StringList -> Int
04:41:26 <ski>   ...
04:41:29 <erus`> well make a strict
04:41:47 <ski> cheater : yes
04:42:02 <sipa> _Mikey: a parametrized type would be:
04:42:07 <sipa>  data List a= Nil
04:42:25 <sipa>             | Const a (List a)
04:42:36 <ski> s/Const/Cons/ :)
04:42:46 <_Mikey> ;)
04:42:50 <sipa> yeah
04:42:59 <ski> and then you can define
04:43:05 <ski>   lengthList :: List a -> Int
04:43:16 <sipa> which works for evere a
04:43:17 <ski> once and for all possible element types `a'
04:43:19 <sipa> every
04:43:21 <_Mikey> ok
04:43:29 <_Mikey> but thats already taken care of by List
04:43:34 <_Mikey> I mean, thats in the language.
04:43:43 <ski> yes, lists are predefined
04:43:47 <ski> lists are just an example
04:43:51 <_Mikey> ok
04:43:55 <sipa> the language provides special syntactic sugar for lists
04:43:58 <ski> you might want to define your own datatype
04:44:06 <_Mikey> hmmm
04:44:08 <sipa> but they are a parametrized data type like eveyr other
04:44:09 <ski> and sometimes you'd run into the same problems as with lists above
04:44:17 <_Mikey> so ..
04:44:21 <_Mikey> if I wished
04:44:23 <ski> so you need to be able to define parameterized data types yourselves
04:44:28 <_Mikey> I could make a tuple type
04:44:34 <_Mikey> which took doubles and floats?
04:44:50 <sipa> type DoubleFloatTuple = (Double, Float)
04:45:21 <_Mikey>             | (Float,Double)
04:45:31 <_Mikey>                   | (Float, Float)
04:45:40 <_Mikey>                |(Double,Double)
04:45:41 <_Mikey> ?
04:45:50 <sipa> no
04:45:55 <_Mikey> oh..
04:46:09 <_Mikey> we're missing value constructors?
04:46:14 <_Mikey> or is it just plain wrong.
04:46:16 <int-e> _Mikey: you need constructors. right.
04:46:17 <sipa> indeed
04:46:21 <ski> _Mikey : well, with parameterized data types, the type parameter can be replaced by any type whatsoever
04:46:38 <ski> _Mikey : if you're only going to use it with `Float' or `Double', that's fine
04:46:40 <applicative> type DFTuple = DF Double Float | FD Float Double | FF Float Float | DD Double Double
04:46:52 <int-e> data DoubleFloatTuple = DD Double Double | DF Double Float | FD Float Double | FF Float Float  will work, but is of questionable value.
04:47:05 <_Mikey> yea
04:47:09 <_Mikey> this is the thing
04:47:10 <applicative> sorry that should be 'data DFTuple'
04:47:20 <_Mikey> I think I get what I can do with them now
04:47:23 <_Mikey> but..
04:47:23 <ski> cheater : did you give the Jacobs paper a look ?
04:47:25 <_Mikey> they're use.
04:47:31 <_Mikey> oh?
04:47:36 <_Mikey> which paper?
04:47:48 <_Mikey> ahh that wasn't for me :p
04:47:57 <ski> hehe
04:48:25 <ski> _Mikey : you can take a look at it if you want as well. but i suspect you're not ready to appreciate it yet :)
04:48:44 <_Mikey> possibly
04:49:04 <_Mikey> I do like a good few pages of confusing a4 paper though
04:49:10 <ski> hehe
04:49:26 <_Mikey> would I be right in saying,
04:49:59 <_Mikey> parameterized type allow us to make the strong type system in haskell less strong.
04:50:04 <_Mikey> types*
04:50:07 <ski> the paper is "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf>, in case you'd want to glance at it :)
04:50:18 <ski> _Mikey : no
04:50:25 <_Mikey> cool!
04:50:47 <ski> parameteried types allows us to make the type system (and thus the code using it) more flexible, but still as strong
04:51:09 <sipa> it allows generalizations without compromising the type system
04:51:43 <_Mikey> ok
04:51:52 <ski> in dynamically typed languages, you don't *need* an (explicit) concept of parameterized data types (though it's still useful), since you can write the code anyway (and it'll possibly error out in case you're doing something wrong)
04:52:11 <ski> so, in dynamically typed languages, you have this flexibility already
04:52:34 <_Mikey> HMmm
04:52:49 <ski> what parameterized types in a statically typed language gives you is the flexibility, *without* losing the static type checking
04:52:53 <_Mikey> Haskell will catch any type errors at compile time
04:52:57 <_Mikey> so
04:53:05 <_Mikey> I think I get why it stays strong.
04:53:08 <hpc> you can weaken the type system with data declarations, though, if you abuse them
04:53:30 <hpc> data DF = D Double | F Float -- now you don't know if a DF is a double or a float, until you try it at runtime
04:53:55 <_Mikey> its what I thought.
04:54:02 <applicative> why would you call that weakening the type system?
04:54:24 * _Mikey is so confused
04:54:42 <hpc> applicative: because at the logical extreme, you define an ubertype and get a dynamic language
04:54:56 <ski> _Mikey : at each point in the code, it knows the element type of your lists (e.g.). even if it doesn't know the exact element type that will be used, it knows that the element type is `a', for some unknown type variable `a', and it checks that you don't mix up `a's with `b's (which might be different), and that you don't try to use an `a' as an `Int' (or vice versa), which would be unsafe
04:54:57 <applicative> the ultimate sum type
04:55:49 * ski wonders where defining an ultimate product type would get us
04:56:00 <applicative> ()
04:56:13 <ski> no, that's the wrong direction
04:56:27 <applicative> grrrr
04:56:29 <ski> (using the same argument, the ultimate sum type is `Void')
04:56:32 <hpc> ski: nowhere useful, i would guess
04:56:39 <applicative> it has one for each type
04:56:47 <_Mikey> hmm
04:56:55 <ski> _Mikey : what are you confused about ?
04:57:12 <_Mikey> say type variable a
04:57:20 <hpc> ski: i expect it would be a lot like C unions
04:57:20 <_Mikey> is doubles and floats
04:57:35 <_Mikey> and type variable be is strings and floats
04:57:53 <_Mikey> I guess my example isn't of much practical use
04:57:53 <_Mikey> but
04:58:07 <_Mikey> haskell won't mix up my a's and b's
04:58:07 <applicative> if I define
04:58:13 <_Mikey> but I can still use b wrongly
04:58:17 <hpc> _Mikey: are you going through a tutorial?
04:58:25 <_Mikey> by trying to devide a potential string
04:58:30 <applicative> data Foo a b = B b | A a | AB a b
04:58:31 <ski> (it's good to discuss simple contrived examples, to get a grip of a concept, in a simpler setting)
04:58:35 <_Mikey> going through real world haskell
04:58:56 <applicative> in that a and b can be absolutely anything, not just Float and Double, or whatever
04:58:57 <_Mikey> I'm glad you think so ski ;)
04:59:11 <rostayob> I'm looking for a data structure on hackage that permitx me to query for all the elements that have some prefix
04:59:17 <rostayob> a radix tree or a ternary search tree basically
04:59:20 <rostayob> but I can't find any
04:59:47 * applicative recommends (,) and fst to rostayob 
04:59:56 <ski> _Mikey : yeah, Haskell won't check that you only use `String' or `Float' for `a'
04:59:59 <rostayob> applicative: mhm?
05:00:25 <applicative> rostayob: I was just trying to get a clearer picture of what you meant
05:00:30 <ski> (well, you can do some tricks with type classes)
05:00:55 * ski wonders why ternary
05:01:08 <rostayob> ski: TST work well with these things
05:01:19 <ski> why ?
05:01:29 * applicative now sees the second bit about radix trees etc
05:01:30 <rostayob> because they perform well with a lot of elements with shared prefixes
05:01:40 <rostayob> http://en.wikipedia.org/wiki/Ternary_search_tree
05:03:17 <luite> is there a standard exponentiation operator that works with rational exponents?
05:03:30 <hpc> :t (^^)
05:03:32 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
05:03:36 <hpc> :t (^)
05:03:37 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
05:03:38 <ski> rostayob : ty, i see
05:03:44 <hpc> :t (**)
05:03:45 <luite> yeah I've tried those :p
05:03:45 <lambdabot> forall a. (Floating a) => a -> a -> a
05:03:52 <hpc> that's annoying
05:03:53 <ski> > 2 ** (1/3)
05:03:54 <lambdabot>   1.2599210498948732
05:04:15 <luite> ski: guess the type of (1/3) there ;p
05:04:22 <_Mikey> Aha!
05:04:23 <ski> `Double' :)
05:04:43 <_Mikey> I think I understand how parameter types can be usefull
05:04:53 <ski> luite : what type did you expect ?
05:04:53 <maurer> Hey, is HP up to ghc7 yet?
05:05:07 <luite> I want something that works for Ratinal
05:05:08 <_Mikey> in the example Tree
05:05:10 <luite> Rational
05:05:13 <ski> (s/parameter types/parameterized types/)
05:05:23 <luite> but I guess I'll make my own
05:05:27 <ski> luite : rational exponents only ?
05:05:32 <_Mikey> a value can be Nill or a  have branges ect.
05:05:35 <_Mikey> although
05:05:37 <ski> luite : what should the base and result type be ?
05:05:37 <hpc> _Mikey: there's two good LYAH chapters (3, 8) that you could try reading too
05:05:41 <hpc> http://learnyouahaskell.com/chapters
05:05:51 <_Mikey> I have a vague feeling that tree is a predefined data type
05:05:58 <_Mikey> so yet again I don't have to define it
05:06:05 <_Mikey> hpc, I'll check it out
05:06:08 <luite> ski: at least something that works without converting to Double
05:06:14 <luite> ski: Fractional
05:06:17 <ski> _Mikey : no, there's many variants of trees. usually you define the one you want
05:06:27 <maurer> Oh, found the current version.
05:07:00 <applicative> maurer: yes
05:07:09 <ski> _Mikey : though, there is one sortof general purpose `data Tree a = Node a [Tree a]', in `Data.Tree' -- but often you want something more specific, or different
05:07:15 <maurer> Is there a place to look at HP dev in general? I'm wondering what lies open between us and 7.2.x support
05:07:38 <applicative> maurer, I don't think the libraries are all in shape for 7.2... yet, but 7.0.x for some time
05:07:49 <ski> (_Mikey : e.g., in a sense, a list is a special kind of tree)
05:08:18 <maurer> applicative: Yeah, I just checked, and the current HP ships matched with 7.0.2
05:08:28 <_Mikey> hmm
05:08:40 <maurer> I'm wondering because I've got a friend who is new to Haskell from ML, but one of the things he may want to play with is -XDeriveGeneric
05:08:42 <_Mikey> splay trees red black trees ect..
05:08:43 <_Mikey> ok
05:08:51 <ski> luite : i'm wondering what concrete type you want to represent the result of `2' raised to the power of `1/3' in
05:09:13 <_Mikey> reading LYAH's chapter 8
05:09:28 <_Mikey> seems to be answering my question I think
05:09:32 <RaptorRarr> Is it presumably possible to make a module that has a bunch of rewrite rules that changes a program to print its source code after other optimizations like list fusion and so on?
05:10:07 <luite> ski: yeah that's a tricky question ;p
05:10:23 <ski> (:
05:11:13 <applicative> maurer, on the mailing list I notice a Thanksgiving release was mentioned for a new platform
05:11:28 <maurer> applicative: So there's no central thing like the GHC trac?
05:11:34 * maurer was hoping for an HP trac or similar
05:11:48 <ski> luite : i suppose maybe you could work in rings or fields where e.g. all third roots exists
05:11:49 <applicative> theres a trac and a mailing list
05:13:13 <applicative> http://projects.haskell.org/pipermail/haskell-platform/ is the list, though I think discussion occurs on all the lists.
05:14:37 <maurer> Thanks
05:15:19 * ski . o O ( "Mauer Palast" )
05:16:12 <maurer> ?
05:18:07 <applicative> maurer, did you see the trac, http://trac.haskell.org/haskell-platform/ as might be predicted
05:19:01 <ski> maurer : sorry, just a random association
05:19:25 <applicative> maurer, the idea of the Platform at the outset was that it would appear some months after new ghc's.  Somehow peoples' patience cant take this, so they always think it's late.
05:20:46 <maurer> applicative: Yeah, I found it.
05:21:09 <maurer> applicative: So, I'm fine with this, which is why I kind of have my own bastardized version of the platform, which I may have him use
05:21:47 <maurer> (e.g. just use the new ghc, use cabal to get and install packages, when that fails, patch them, add a .1 to the end of the revision numbers, put in a local cabal repo)
05:21:56 <maurer> errr, local hackage repo
05:23:51 <_Mikey> hey guys
05:23:57 <_Mikey> I'm off for some lunch
05:24:04 <applicative> maurer my impression is that a lot of the labor is getting everything tuned to windows and os x. so for example that it works on all platforms is a constraint on a candidate library
05:26:42 <deggis> is there any quick fix to local package repo, that has two groups of libraries depending on same version of a lib (in this case mwc-random-0.10.0.1), but both group require different hashes?
05:26:44 <maurer> applicative: I understand that it is hard to do multiplatform stuff
05:26:55 <maurer> applicative: This is why I described my version as "bastardized"
05:27:11 <maurer> It doesn't even work "only on Linux"
05:27:32 <maurer> It's in fact only tested on three machines :P
05:27:43 <maurer> All of which are the same architecture, and very similar configurations
05:28:10 <luite> ski: hmm, I can't find an algebraic numbers package anywhere so I'll try CReal first
05:28:50 <troydm> ok i have this
05:28:52 <troydm> http://hpaste.org/54015
05:28:54 <troydm> it works
05:29:08 <Baughn> @hayoo (a -> m b) -> m c -> m b
05:29:08 <lambdabot> Unknown command, try @list
05:29:18 <troydm> but i'm interested is there a better (monadic) way to do this ?
05:29:26 <ski> Baughn ?
05:29:42 <Baughn> ski: Well, I was looking for..
05:29:45 <Baughn> <<, I suppose
05:29:46 <DRMacIver> So I'm trying to install profiling libraries for criterion. The process for installing profiling libraries on cabal appears to be "run cabal install. Wait for it to build everything and then fail because you haven't installed profiling for a dependency. Attempt to install profiling libraries for that dependency and try again"
05:29:56 <DRMacIver> Please tell me I'm missing something
05:30:25 <Baughn> DRMacIver: Yes. The proper process is 'delete ~/.ghc. Reinstall everything.'
05:30:27 <dcoutts> DRMacIver: sorry, that's just the way it is atm, because ghc/ghc-pkg/cabal do not track profiled libs separately from vanilla
05:30:52 <maurer> Baughn: Even that is insufficient if you use system/distro managed libs in addition to your own.
05:31:01 <DRMacIver> Baughn, dcoutts: Ugh.Ok. Thanks.
05:31:08 <DRMacIver> Actually deleting ~/.ghc is a good idea
05:31:37 <DRMacIver> maurer: Yeah, I've already dealt with the distro managed case though
05:31:39 <dcoutts> DRMacIver: you can select to always build prof libs in your ~/.cabal/config
05:31:51 <DRMacIver> dcoutts: Ah, thanks. Good to know
05:32:08 <maurer> DRMacIver: There are a number of other useful settings in there (like generating dox)
05:32:41 <hpaste> “Joel Kaartinen (Eliel)” annotated “is there a better way to do this?” with “is there a better way to do this? (annotation)” at http://hpaste.org/54015#a54016
05:32:52 <maurer> (also split objs, which is really nice if you are depending on a lot of things)
05:32:55 <bxc> man packaging sucks
05:32:58 <bxc> (not just in haskell)
05:33:07 <Eliel> troydm: I annotated it, take a look. Would this be nicer?
05:33:30 <DRMacIver> bxc: Gotta say, while I agree with the sentiment in general, I find cabal quite atypically bad.
05:33:48 <troydm> Eliel: ok thx
05:34:20 <hpaste> “Joel Kaartinen (Eliel)” annotated “is there a better way to do this?” with “is there a better way to do this? (annotation) (annotation)” at http://hpaste.org/54015#a54017
05:34:22 <dcoutts> DRMacIver: it's a combination of hard problems and lots of work with little available developer time, ie the typical problem
05:34:27 <luite> hm thoos CReals are slow
05:34:31 <troydm> Eliel: but is there a way to do something like (many (noneOf "\n") <|> return Nothing) or something like that
05:34:34 <DRMacIver> though some of that is because it's solving harder problems than the examples I'm comparing it to or because a great deal more work went into the specific packages to build them
05:34:37 <dcoutts> DRMacIver: however, we are working on it
05:34:45 <bxc> DRMacIver: I think its pretty good - nothing is gonna beat debian+apt but they put a lot of effort into packaging
05:34:51 <troydm> Eliel: instead of doing let value and if
05:35:11 <dcoutts> bxc: in some ways we're solving a harder problem
05:35:14 <maurer> Honestly, I think the biggest issue with using cabal isnt' even cabal's fault.
05:35:16 <maurer> *isn't
05:35:24 <maurer> (Namely ghc --make is not parallel)
05:35:27 <DRMacIver> bxc: Yeah, but for example rubygems is dramatically less painful (if you ignore the broken semantics of ruby that make rubygems a nightmare *after* installation time)
05:35:30 <Eliel> troydm: I haven't used parsec enough to know for sure but I don't know of a way.
05:35:49 <DRMacIver> But it's definitely solving an easier problem due to not having to compile things.
05:35:51 <troydm> Eliel: ok thx
05:36:03 <dcoutts> maurer: I disagree, I think cabal should have a proper build system, it's not good enough to rely on ghc --make
05:36:24 <Eliel> troydm: but as for readability, the modification I made should improve it quite a bit.
05:36:25 <maurer> DRMacIver: For example, dynamically typed languages are dramatically less painful (if you ignore the broken behavior that might occur at runtime, after load time)
05:36:46 <DRMacIver> maurer: I'm not sure that's a fair analogy :)
05:37:04 <maurer> DRMacIver: Both are checked metadata describing the payload
05:37:07 <Eliel> troydm: you could also define such a helper function yourself... I'll make one more annotation
05:37:12 <maurer> Rubygems does not check the metadata as carefully.
05:37:20 <Philippa> torydm: Just `liftM` many (noneOf "zn") <|> return Nothing ?
05:37:36 <Philippa> troydm, even
05:39:32 <DRMacIver> maurer: Not really. The brokenness isn't a failure to check metadata so much as a failing of the language semantics themselves. It's pretty rare that a failure is due to a failure to install properly.
05:40:07 <maurer> Hm? Who says that data in the language themselves isn't involved?
05:40:20 <maurer> .hi files are totally involved when cabal builds a package
05:40:27 <DRMacIver> ok, then I have no idea what your point is. I'm going to go back to coding instead of talking past eachother. :)
05:40:30 <maurer> OK :P
05:41:57 <maurer> dcoutts: I mean, that's a possibility too. I mostly am suggesting that however we bulid things, we should make it possible to use separate compilation without handcoding makefiles
05:42:19 <dcoutts> maurer: you mean parallel compilation
05:42:28 <dcoutts> rather than separate
05:42:57 <troydm> Philippa: ok let me think about it
05:43:29 <maurer> dcoutts: Well, yes and no - the way you get parallel compilation is via the use of separate compilation
05:43:56 <hpaste> “Joel Kaartinen (Eliel)” annotated “is there a better way to do this?” with “is there a better way to do this? (annotation) (annotation) (annotation)” at http://hpaste.org/54015#a54018
05:44:09 <dcoutts> maurer: we do have separate compilation, just not parallel.
05:44:24 <maurer> dcoutts: I mean, we can do parallel too - we just need to write a Makefile first :P
05:44:33 <maurer> (which uses the separate compilation)
05:44:52 <dcoutts> well, makefiles are not the only way obviously
05:44:56 <dcoutts> we can do it properly
05:45:00 <maurer> Yeah
05:45:02 <dcoutts> but it's a harder problem than it looks
05:45:11 * dcoutts has spent some time thinking about it
05:45:13 <maurer> dcoutts: Have you looked at OMake?
05:45:21 <dcoutts> what approach do it take?
05:45:54 <dcoutts> the usual "solution" in the make replacements is just to use a more flexible language
05:46:03 <dcoutts> but that doesn't solve all of make's problems
05:46:22 <maurer> It kind of does that, but its language is expressive enough to let it do things like automatically resolve ocaml dependencies within a source directory
05:46:39 <maurer> Which means that defining an ocaml project is usually only a few lines if you use it.
05:46:54 <Eliel> Philippa: doesn't that give Just [] when the next character is \n and never actually give Nothing?
05:47:25 <dcoutts> maurer: from what I can see, most of these are quite unprincipled, though I'm not claiming they don't work
05:47:38 <maurer> dcoutts: I wouldn't say it's as principled as cabal.
05:47:51 <dcoutts> heh, cabal's build system is currently also totally unprincipled
05:47:53 <Eliel> troydm: also, Maybe is somewhat useless with lists as they duplicate each other's functionality a bit. empty list is kind of equivalent to Nothing.
05:48:01 <dcoutts> maurer: e.g. they mostly do not properly track or enforce dependencies
05:48:49 <dcoutts> and that's sometimes made worse by using a flexible language, there are deps all over the place
05:51:14 <Philippa> Eliel: yeah, use many1 instead
05:51:53 <Philippa> [] will do as well unless you've got another reason to fit the Maybe type, sure
05:55:23 <RaptorRarr> It looks like you can't use rewrite rules to transform a program into a program that prints the source of the original program.
05:58:37 <hpaste> applicative annotated “is there a better way to do this?” with “is there a better way to do this? (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/54015#a54019
05:59:38 <applicative> troydm: heres a few more abitrary reformulations.  ^^^
06:00:23 <troydm> applicative: thx
06:07:22 <applicative> troydm: I'm not sure there can really much point to the justString function, though there's nothing wrong with it
06:07:41 <applicative> troydm the information you are recording with Nothing and Just is already available in the returned string, as of the forms [] or (x:xs)
06:09:00 <troydm> applicative: so i can just use String instead of Maybe String ?
06:10:03 <applicative> troydm: It depends what you are going to do next, I think you should leave it as it is, then after you write more, see if it was an unnecessary complication
06:10:19 <troydm> applicative: ok i see
06:11:22 <applicative> troydm, if you have ghc-7.2 this might make a handsome use of the MonadComprehension extension.
06:13:27 <applicative> troydm then it'd be [(name, value ) | name <- manyTill anyChar (char '='), value <- manyTill anyChar newline)] leaving out the justString complication
06:20:02 <yacoby> Uh, probably a stupid question but how do I compare IO Bool and Bool?
06:20:34 <Ferdirand> @type (>>= (==))
06:20:35 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
06:20:57 <dgpratt> @where faq
06:20:57 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
06:20:59 <Ferdirand> huh ?
06:21:07 <Yacoby> Ferdirand: Many thanks
06:23:22 <dgpratt> Yacoby: if you get stuck, check out section 5.10 of the FAQ
06:24:52 <Ferdirand> @pl \x y -> x >>= (== y)
06:24:52 <lambdabot> (. (==)) . (>>=)
06:25:08 <Ferdirand> @pl \y x -> x >>= (== y)
06:25:09 <lambdabot> (=<<) . (==)
06:25:22 <Ferdirand> ah, of course
06:26:34 <Veinor> @t (=<<) . (==)
06:26:35 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:26:40 <Veinor> @type (=<<) . (==)
06:26:41 <lambdabot>     Couldn't match expected type `m b' against inferred type `Bool'
06:26:43 <lambdabot>       Expected type: a -> a -> m b
06:26:43 <lambdabot>       Inferred type: a -> a -> Bool
06:27:09 <sipa> @thx lambdabot
06:27:09 <lambdabot> you are welcome
06:27:23 <sipa> @thx sipa
06:27:23 <lambdabot> you are welcome
06:29:06 <Ferdirand> @type liftM . (==)
06:29:07 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => a1 -> m a1 -> m Bool
06:42:33 * hackagebot netwire 2.0.0 - Generic automaton arrow transformer and useful tools  http://hackage.haskell.org/package/netwire-2.0.0 (ErtugrulSoeylemez)
06:49:23 <Tinned_Tuna> I hate Java.
06:49:38 <hvr> Tinned_Tuna: and?
06:49:51 <rostayob> Tinned_Tuna: there's worse
06:49:59 <Tinned_Tuna> hvr: I just want to let my frustration out, I'm ill, tired and cranky :-p
06:50:07 <hvr> Tinned_Tuna: ok :-)
06:50:12 <Tinned_Tuna> rostayob: true, but I'm not using them :-P
06:50:16 <Philippa> spend a few months working in VB1, you'll beg for Java again
06:50:26 <rostayob> or C++ for what concerns me
06:50:58 <Tinned_Tuna> and there's building work outside my office window. Begone, giant flashing JCB
07:10:58 <Tim> anyone here? :)
07:13:35 <pokoko222> hey dudes i am in last college year, recommend me some cool topics I could work on as final work, functional programming related
07:13:50 <pokoko222> i might do a simple functional programming language and learn some category theory along the way
07:15:26 <fasta> Is there something to count files matching a particular pattern in a particular directory?
07:16:12 <simon> a quick search gave me System.Directory.Tree
07:16:22 <fasta> The code would be getContents >>= liftM (filter (matchesPattern "*.foo")) or something like that.
07:16:43 <Tim> can somebody link me a haskell guide (up2date)?
07:17:58 <osfameron> @where lyah
07:17:59 <lambdabot> http://www.learnyouahaskell.com/
07:18:02 <osfameron> Tim: ^^
07:18:18 <Tim> thank you! :)
07:20:09 <fasta> simon: I think that API is terrible.
07:20:33 <fasta> simon: did you happen to write it?
07:21:25 <simon> fasta, no ;)
07:21:40 <simon> fasta, it seems neat that you can traverse the structure, though.
07:21:40 <fasta> Ah, RWH contains it.
07:22:06 <fasta> simon: yes, but the author seems to lack taste.
07:22:56 <mndrix> I uploaded a package to hackage 3 days ago. it has not been built yet. is this typical? http://hackage.haskell.org/packages/archive/network-bitcoin/0.1.0/
07:23:27 <hpaste> “Ertugrul Söylemez” pasted “Netwire 2.0.0 demo” at http://hpaste.org/54025
07:23:50 <simon> fasta, so you want something that resembles the find command more?
07:23:58 <fasta> simon: yes
07:24:20 <fasta> simon: I didn't actually read your whole comment ;)
07:24:51 <fasta> simon: I already found exactly what I needed. I just try to not write the boring code over and over again.
07:25:22 <simon> fasta, what did you find?
07:25:46 <fasta> simon: http://rosettacode.org/wiki/Walk_a_directory/Non-recursively#Haskell
07:30:41 <KitB> Are n+k patterns disabled by default now?
07:30:51 <int-e> yes
07:30:57 <KitB> Flag to re-enable?
07:31:10 <KitB> (I've been given some old code and cba to go through removing them)
07:31:13 <int-e> NPlusKPatterns
07:31:19 <KitB> Cool, thanks
07:31:33 <int-e> (-X or LANGUAGE pragma, as usual)
07:31:53 <KitB> Indeed
07:35:04 <osfameron> oh, this is cute, http://blog.ezyang.com/2011/11/how-to-read-haskell/
07:36:58 <yrlnry> "Ignore everything you see after ::"
07:37:00 <yrlnry> heh.
07:39:44 <mm_freak> i usually read /only/ the part after ::
07:40:13 <int-e> "Return. Line-noise."
07:40:20 <tac-tics> I read that part between the ::'s
07:40:46 <int-e> love the wrong python code for dot.
07:41:15 <tac-tics> yup
07:41:24 <mm_freak> parcs: netwire 2.0.0 is out =)
07:42:44 <osfameron> it's interesting how to skim haskell code as a non-haskeller will have a different strategy
07:43:00 <osfameron> I'm unsure about the advice to ignore the type too, but it may well be valid
07:43:43 <osfameron> (any extra "weight" is more likely to confuse you, and type declarations can include things like typeclass constraints and so on)
07:43:53 <int-e> I like the article. Of course I tend to look at types first, but they really take some time getting used to.
07:44:09 <tac-tics> I think that blog article was a monad tutorial in disguise
07:44:32 <int-e> Well, if it's just about IO it's not a monad tutorial.
07:44:33 <frigga1> Simple types are probably useful to non-haskellers, but anything involving types with kinds other than * are probably good to ignore.
07:45:41 <int-e> @type fmap
07:45:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:46:37 <osfameron> yeah, that's a good example
07:51:03 <fasta> int-e: what are you currently using Haskell for?
07:52:10 <int-e> not much. most coding recently has been in ocaml :/
07:53:08 <PiRSquared17> @pl \x -> x a
07:53:08 <lambdabot> ($ a)
07:53:29 <PiRSquared17> @pl \x -> a x a x a
07:53:29 <lambdabot> flip (join (flip a a)) a
08:00:05 <rostayob> PiRSquared17: wait... what's the type of a?
08:00:38 <PiRSquared17> In which?
08:00:41 <rostayob> the second
08:00:49 <PiRSquared17> @type \x -> a x a x a
08:00:50 <lambdabot>     Couldn't match expected type `t1 -> Expr -> t1 -> Expr -> t'
08:00:50 <lambdabot>            against inferred type `Expr'
08:00:50 <lambdabot>     In the expression: a x a x a
08:00:59 <PiRSquared17> impossible...
08:01:01 <rostayob> @ type \x a -> a x a x a
08:01:04 <rostayob> @type \x a -> a x a x a
08:01:05 <lambdabot>     Occurs check: cannot construct the infinite type:
08:01:06 <lambdabot>       t = t1 -> t -> t1 -> t -> t2
08:01:06 <lambdabot>     Probable cause: `a' is applied to too many arguments
08:01:23 <PiRSquared17> \x -> \a -> a x a x a
08:01:23 <_oz> @type \x a -> a `x` a `x` a
08:01:25 <lambdabot> forall t. (t -> t -> t) -> t -> t
08:01:33 <PiRSquared17> @type \x -> \a -> a x a x a
08:01:34 <lambdabot>     Occurs check: cannot construct the infinite type:
08:01:34 <lambdabot>       t = t1 -> t -> t1 -> t -> t2
08:01:34 <lambdabot>     Probable cause: `a' is applied to too many arguments
08:01:43 <rostayob> _oz: well, that's something different.
08:01:57 <_oz> rostayob: I know, I thought maybe that was what he meant
08:02:09 <_oz> it is obviously different
08:02:11 <PiRSquared17> No... not infix
08:02:38 <luite> is it possible to make lhs2tex generate code that can be included with \input? I don't mind if I have to add some \usepackage manually
08:02:38 <PiRSquared17> I was wondering if that was possible, and @pl made me think it was
08:03:15 <PiRSquared17> Probable cause: `a' is applied to too many arguments ? Now there is a limit on currying?
08:03:18 <rostayob> PiRSquared17: pl applies some replacement rules
08:03:23 <kosmikus> luite: lhs2tex FAQ, should be explained in the user guide.
08:03:35 <rostayob> no it's just that that would be an infinite type, try to type it manually
08:03:49 <rostayob> @type \x a -> a x a
08:03:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
08:03:50 <lambdabot>     Probable cause: `a' is applied to too many arguments
08:03:50 <lambdabot>     In the expression: a x a
08:03:55 <fasta> int-e: in which problem domain?
08:04:10 <rostayob> if x is type a, then a is type "a -> a", but then you're applying to a again
08:04:14 <PiRSquared17> @type \a -> a a
08:04:15 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:04:15 <lambdabot>     Probable cause: `a' is applied to too many arguments
08:04:15 <lambdabot>     In the expression: a a
08:04:21 <rostayob> PiRSquared17: precisely
08:04:24 <luite> kosmikus: can't find it in the pdf that comes with the package, and the people.cs.uu.nl server with the package and some docs seems to be down
08:04:37 <fasta> PiRSquared17: you can have 'infinite types', btw, but then you need to build data structures.
08:04:51 <fasta> PiRSquared17: in OCaml they are a compile time switch.
08:05:04 <fasta> PiRSquared17: and likely, if you don't know that you want them, you made a user error.
08:05:05 <rostayob> like Fix a = Roll (Fix a -> a)
08:05:14 <rostayob> or something like that
08:05:35 <fasta> Yes, something like that.
08:05:57 <rostayob> Fix f = In (f (Fix f)) is actually useful
08:06:04 <fasta> I only used them with complicated monad transformer return types.
08:06:25 <fasta> So, I wanted to change the computation while it was running basically.
08:07:07 <fasta> But that has been the only occasion I needed them, the NoMonoPatternBinds are used more often.
08:07:27 <fasta> rostayob: I don't like that trick, because it is a trick.
08:07:44 <rostayob> fasta: not really. see "Data types a la carte"
08:07:54 <fasta> rostayob: I read the paper two times.
08:08:07 <rostayob> well.. that's pretty useful imo
08:08:12 <fasta> rostayob: I can only apply it mechanically.
08:08:15 <rostayob> also, the paper about the unification
08:08:37 <fasta> rostayob: I don't want to think about those constructors when programming.
08:08:46 <rostayob> fasta: well after you started you won't think about it
08:09:01 <fasta> rostayob: so, if they are so useful, just build a domain specific language for building such extensible structures.
08:09:19 <fasta> It is an implementation technique as far as I am concerned.
08:09:31 <rostayob> what isn't an implementation technique?
08:09:35 <rostayob> i'm not sure i get your point
08:09:50 <gavri> I'd like to remove all the haskell packages on my system (both system and  user specific) and start over. is there an easy way to do that?
08:10:07 <rostayob> gavri: delete .cabal and .ghc
08:10:09 <fasta> rostayob: a zipper is for example an actual data structure which can be implemented in multiple ways.
08:10:14 <bxc> rm -rfv /
08:10:19 <fasta> rostayob: lenses have questionable value.
08:10:22 <rostayob> fasta: oh, in that sense.
08:10:30 <rostayob> ok, it's an useful implementation technique then.
08:10:41 <rostayob> to do various things
08:10:46 <Baughn> So I managed to reduce CPU usage of this (embarassingly parallel, really) program by 30% by increasing CPU usage by 400%.
08:10:49 <rostayob> (not only those extensible data types)
08:10:54 <fasta> rostayob: yes, but not something someone should write in a book about Haskell for 'beginners'.
08:10:57 <Baughn> Productivity vs. GC time is an atrocious 20%
08:11:02 <rostayob> fasta: no.
08:11:20 <gavri> rostayob: both from my home directory? what about the libraries installed for all users?
08:11:21 <fasta> Baughn: is that a new record?
08:11:29 <rostayob> gavri: that depends really.
08:11:34 <Baughn> fasta: Just about, yes.
08:11:37 <rostayob> how did you install them in the first place?
08:12:06 <Baughn> At this point, I may need to reconsider the option of dropping a grand piano on my computer.
08:12:15 <gavri> rostayob: I'm on ubuntu 11.10. I installed the haskell-platform package and them may have used cabal to install a few packages
08:12:38 <rostayob> gavri: then uninstall the local one and then apt-get remove whatever
08:15:52 <kosmikus> luite: in the PDF, last page, first FAQ
08:16:15 <kosmikus> luite: (and the second)
08:18:01 <gavri> rostayob: that worked. thanks! finally got the statistics library installed
08:18:53 <rostayob> gavri: yw
08:19:22 <paolino> Baughn: maybe you need a new kind of GC, separate refuse collection
08:20:24 <fasta> Not having any GC is a solution too, of course.
08:20:27 <paolino> also to collect your computer after grand piano bombing
08:21:13 <maharba> hi there
08:21:46 <maharba> I'm a little frustrated running tryhaskell examples in ghci
08:22:24 <maharba> a simple sort [2,8,3]
08:22:31 <maharba> gives the next error
08:22:33 * hackagebot netwire 2.0.1 - Generic automaton arrow transformer and useful tools  http://hackage.haskell.org/package/netwire-2.0.1 (ErtugrulSoeylemez)
08:22:45 <maharba> <interactive>:1:1: Not in scope: `sort'
08:23:00 <paolino> maharba: import Data.List
08:23:17 <maharba> how can I run this simple code line in ghci
08:23:25 <erus`> frec :: (a → a) → !a → Integer → a           is this not allowed?
08:23:38 <maharba> ok I'll try thanks
08:24:00 <paolino> in ghci you ca use ":m + Data.List"
08:24:27 <fasta> paolino: you can also use import Data.List
08:24:51 <paolino> fasta: is there any difference ?
08:25:05 <fasta> paolino: in behaviour, no.
08:27:47 <Baughn> paolino: If the compiler would realize that it can allocate all this stuff on the stack, that'd be swell
08:29:28 <paolino> Baughn, I didn't know ghc was pushing and popping program data on the stack
08:29:57 <Baughn> paolino: It doesn't /usually/, but it can happen
08:30:17 <etpace> im learning about template instantiation/graph reduction to compile a simple functional language, and one of the rules detailed (as a state transition) is: (addr:stack) h(addr |-> App a1 a2) ==> (a1 : addr : stack) h
08:30:29 <etpace> Is this correct? I'm thinking it should be (a1 : a2 : stack) instead?
08:30:31 <paolino> Baughn: not thunks, I guess
08:30:40 <Baughn> Not thunks.
08:34:56 <etpace> Having something like: id x = x, then a stack as: App (#id) (#1) should reduce to (#id:#1:[]) rather than (#id:App #id #1:[]) surely..
08:36:20 <rwbarton> It still needs to compute the result of the function application afterwards...
08:37:20 <etpace> But the rule for supercombinator transition is evaluting the body of the sc, with the n stack items above it, bound to the n aguments
08:37:39 <rwbarton> sorry, I have no idea what your context is, just trying to guess what things mean
08:37:46 <rwbarton> But your example 'id' seems highly atypical
08:37:49 <etpace> having App would have x |-> App #id #1
08:38:33 <etpace> sorry, I'm working through simonpj book ( http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ ) and unable to grok the definition in chapter 2
08:38:54 <etpace> what do you mean that the example is atypical?
08:39:15 <rwbarton> well you can't really distinguish evaluating 'id x' from evaluating 'x', since they are equal!
08:39:31 <rwbarton> and that seems to be the difference you are trying to draw
08:40:25 <etpace> hmm, I think the difference Im trying to draw is what is "bound" as x when evaluating foo
08:40:31 <etpace> I mean id*
08:40:47 <etpace> If we take the n addresses for n arguments, it would be bound to the "App" node
08:40:53 <etpace> rather than the address to our constant 1
08:46:08 <rwbarton> etpace, oh I see why you are confused
08:46:16 <rwbarton> or at least, I am also confused now
08:48:00 <etpace> hmm i'll keep going
08:48:20 <etpace> and assume its a typo, ive sent an email asking, hopefully i'll read something that will end the confusion
08:49:12 <bblum> any Language.C experts around? i'm trying to grok the CDecl/CDeclr/CDerivedDeclr structure, and having a hard time imagining how you would represent e.g. a function pointer to a function that returns a function pointer
08:49:54 <rwbarton> etpace, the confusion is resolved by the function getargs on page 59, I think
08:50:34 <rwbarton> the stack consists of all the function applications  f, f a1, ..., f a1 .. an,  and getargs extracts those arguments a1 .. an
08:51:16 <etpace> aha
08:53:31 <rwbarton> I think display (2.2) is still wrong, though, it doesn't take into account that the stack nodes are applications rather than arguments
08:54:13 <etpace> If getargs is defined to always take the RHS of NAp, putting the rhs on the stack itself should be the same
08:54:18 <etpace> I think?
08:56:06 <rwbarton> I think that would work here but traditionally the stack would consist of function applications I suppose
08:56:32 <etpace> ah, thanks for clearing that up
08:58:00 <DRMacIver> What's the recommended way to automatically generate Data.Binary instances? (Or should I be using something other than Data.Binary?)
08:58:19 <copumpkin> omg a DRMacIver
08:58:20 <byorgey> dgpratt: uh, yes, why do you ask? (and how dud you know?)
08:58:43 <DRMacIver> copumpkin: It happens sometimes. :)
08:58:52 <copumpkin> DRMacIver: I think http://hackage.haskell.org/package/derive does it
08:58:54 <copumpkin> or http://hackage.haskell.org/package/binary-derive
08:59:02 <copumpkin> there are several things that claim to do it on hackage
08:59:21 <DRMacIver> copumpkin: Yes, the fact that there are several things is why I asked what the recommended one was :)
08:59:29 <copumpkin> I've used derive before
08:59:43 <DRMacIver> My experience tends to suggest that when there are N ways of doing something at least N - 2 of them are broken.
08:59:44 <copumpkin> byorgey: lol
09:00:27 <DRMacIver> copumpkin: Yeah, I was leaning towards derive. I think I've used it in the past.
09:00:34 <DRMacIver> (long long ago when I last wore the Haskell hair shirt)
09:00:48 <copumpkin> I'm sure the shirt still fits
09:01:00 <DRMacIver> and still itches just as much :)
09:01:33 <copumpkin> tsk tsk
09:01:49 <wlangstroth> am I too far gone if it itches when I'm *not* wearing that shirt?
09:02:01 <copumpkin> that's the situation I'm in
09:02:13 <copumpkin> well, scala isn't terrible, but it's still more itchy
09:02:32 <geheimdienst> same here, i can't stand python or shell or perl anymore
09:02:33 <accel> you know what scala can do that haskell can't?
09:02:38 <accel> provide a decent GUI on osx
09:02:39 <copumpkin> subtyping
09:02:45 * DRMacIver doesn't do Scala either these days.
09:02:47 <copumpkin> scala doesn't have a GUI, and nor does haskell
09:02:52 <dylex> bblum: something like CDeclr "f" [CPtrDeclr [], CFunDeclr [], CPtrDeclr [], CFunDeclr []] (pointer to function returning pointer to function returning int)?
09:03:03 <accel> sure scala has a GUI
09:03:08 <accel> it's called the java gui libraries
09:03:14 <accel> haskell has what, glut + opengl?
09:03:22 <copumpkin> gtk?
09:03:27 <copumpkin> not calling it decent
09:03:29 <copumpkin> but it's something
09:03:38 <copumpkin> java's GUIs don't feel native either
09:03:42 <zmv> true.
09:03:44 <accel> actually what confuses me most is that
09:03:46 <bblum> dylex: hmm, that looks about right
09:03:49 <accel> don't guis map well to functional programming
09:03:53 <accel> like frp
09:03:59 <accel> so why are there no good gui bindings?
09:04:08 <cheater> haskell has Vty!!!
09:04:10 <copumpkin> accel: because nobody has made them yet
09:04:13 <copumpkin> accel: you be the first
09:04:26 <cheater> copumpkin has a point
09:04:34 <accel> copumpkin: I contribute first line of code
09:04:35 <dylex> bblum: the documentation is not very well formatted -- the source is clearer
09:04:42 <accel> -- this is a haskell gui library
09:04:42 <bblum> dylex: oh, where can i find the source?
09:04:44 <accel> copumpkin: you next
09:04:50 <copumpkin> accel: you seem to be the one who wants them
09:04:53 <copumpkin> make them
09:04:57 <copumpkin> :)
09:05:04 <dylex> bblum: http://hackage.haskell.org/packages/archive/language-c/0.4.2/doc/html/src/Language-C-Syntax-AST.html
09:05:09 <tensorpudding> there is haskell's gtk bindings but they're not very inviting to the novice
09:05:12 <bblum> thanks! :)
09:05:17 <dino-> Huh, seeing a problem where I'm getting a linker warning Could not find module, but it's been installed for a long time and has also been in the build-depends for a long time.
09:05:22 <tensorpudding> and what version of gtk are they binding nowadays?
09:05:28 <tensorpudding> probably not gtk 3
09:05:32 <DRMacIver> accel: Even if FRP is a good way to develop GUIs (I think the jury may well be out on this one) it's not like existing GUI toolkits do.
09:05:32 <dino-> No idea what could have changed to make this happen.
09:05:37 <bxc> dino-: did you just turn on profiling?
09:05:43 <dino-> bxc: no
09:05:55 <dino-> I did nothing except clean and rebuild a project that didn't do this last week
09:05:57 <DRMacIver> And developing GUI toolkits is a sufficiently large chunk of work that you don't really want to do it if you don't have to
09:06:11 <accel> hmm
09:06:13 <accel> good call
09:06:43 <bxc> dino-: i think i've also seen that when i've upgraded a dependency that has removed a previously present mdule (maybe that happened with Data.Random recently?)
09:07:16 <dylex> bblum: you could also use the parser to see what it comes up with for known C source
09:07:42 <dino-> bxc: But the module in question here is System.Directory
09:07:58 <bblum> dylex: I would like to... but the pretty-printer prints it as source, not showing the data constructors :\
09:08:52 <dylex> bblum: You should be able to use show instead of pretty, I think to get the constructors
09:09:06 <bblum> the docs don't say that it derives show
09:09:57 <fasta> DRMacIver: you are a Scala user, right?
09:10:01 <dylex> bblum: at least some levels do it looks like. but I haven't tried.
09:10:24 <parcs> how the heck is gtk2hs 90k lines of code
09:10:45 <fasta> parcs: why wouldn't it be?
09:11:09 <DRMacIver> fasta: Not for a long time.
09:11:10 <fasta> parcs: it is generated code for a large part, AFAIK.
09:11:15 <DRMacIver> But no one seems to have realised this. :)
09:11:42 <fasta> DRMacIver: what's your langue du jour?
09:11:50 <parcs> cloc reports 4.7 loc
09:11:51 <dino-> fasta: I'm writing in Scala for my job.
09:12:03 <fasta> dino-: is that because you chose to use it?
09:12:07 <parcs> i think the author meant gtk is 90k loc..
09:12:25 <dino-> fasta: Kind of, yeah. They came looking for the Scala exp. Wanting to get rid of Java, replace with Scala.
09:13:08 <fasta> dino-: exp is experience/expert?
09:13:31 <DRMacIver> fasta: I don't really have a good answer for that. Most of my code is work related right now, which is ruby (sigh). I'm trying to replace that with python at home. Clay when I can get around to it / find the motivation. C occasionally.
09:13:34 <dino-> fasta: experience. Been using it maybe 18 months now. Started with an Android app in Scala.
09:13:59 <fasta> dino-: does Scale come with an interactive shell?
09:14:04 <fasta> Scala*
09:14:06 <dino-> fasta: Yes it does
09:14:09 <DRMacIver> I suppose du jour it's Haskell, but that's only because I'm using it for something specific and I expect to drop it again at the end of that :)
09:14:16 <dmwit> parcs: Is cloc counting .hsc files?
09:14:40 <dmwit> parcs: wc shows 154k lines in all files.
09:14:49 <parcs> probably not then
09:14:53 <dino-> Now at this job, the sticking point is they're fixated on the Java VM. Although I think we could do all that we're doing better with Haskell. It's all data processing, much of it parallelized.
09:14:56 <parcs> dang
09:15:09 <fasta> dino-: that was my next question.
09:15:54 <accel> hm
09:15:57 <accel> is there something like haskell
09:16:00 <accel> but runs on the jvm?
09:16:06 <bxc> i was wondering about why people get jvm fetish the other day
09:16:13 <bxc> accel: scala?
09:16:22 <accel> because of teh liraries
09:17:01 <DRMacIver> accel: See, the libraries seem to be one of the strongest recommendations against the JVM for me. :)
09:17:28 <shapr[> I dunno, I think the JVM has other things that make me not want to use it. Like Oracle!
09:17:37 <DRMacIver> The VM itself has some nice points (as well as some not nice ones)
09:17:37 <fasta> DRMacIver: what do you have against ygraph?
09:17:42 <c_wraith> yeah...  I was always under the impression there were a lot of good java libraries out there, until I started trying to use them.  It was a shock to find out how bad most were.
09:18:06 <DRMacIver> fasta: Specifically? Nothing. I don't know it.
09:18:24 <DRMacIver> fasta: Based on prejudices: It's a Java library, therefore it's probably rubbish, and it's a graph library, therefore it's probably rubbish
09:18:34 <dino-> The way Oracle is handling Java now, I kind of feel like the Scala people should get busy not depending on it in the future.
09:18:44 <fasta> I think the actual language is not that important. It's the people that use it. The JVM is not a bad machine.
09:18:50 <wlangstroth> java developers are fungible - the language/vm isn't really the big deal
09:18:59 <wlangstroth> fasta: you were ... fasta
09:19:14 <dmwit> ba-dum TISH
09:19:17 <fasta> With something like PHP you have already lost before the starting line.
09:19:17 <dino-> fasta: My uninformed opinion is that the JVM is maybe too OO down deep inside. Or maybe too class-oriented.
09:19:39 <zomg> fasta: why is that?
09:19:48 <dino-> But I guess they kind of hide this from you even more in Clojure.
09:19:48 <wlangstroth> dino-: if it weren't OO, that would be weird
09:20:17 <bxc> wlangstroth: i can buy the 'java developers are fungible' argument except that scala programmers are scala prorammers, not java programmers
09:20:33 <c_wraith> wlangstroth: I think his point is that the jvm is basically an abstraction built to implement java, and supporting anything that's really different is hard
09:20:42 <dino-> wlangstroth: I don't have much use for OO. I write all of my scala in statics. No methods. Treat non-static classes as structs only.
09:20:52 <wlangstroth> bxc: sure, and if all your scala developers go surfing, you can still plug in some java
09:20:59 <DRMacIver> The JVM isn't all that good at idiomatic Java either.
09:21:08 <dino-> The only place this breaks down is Actors, where you have to inherit.
09:21:33 <DRMacIver> It handles megamorphic code pretty poorly, which tends to be an issue for things with lots of listeners, etc.
09:21:41 <jhance> There's idiomatic java?
09:21:49 <fasta> jhance: yes, there is.
09:21:51 <wlangstroth> dino-: preaching to the choir
09:22:01 <DRMacIver> jhance: Of course.
09:22:13 <dino-> wlangstroth: So, that it's still forcing me to write code in some class is weird, to me.
09:22:19 <fasta> Most people that know a functional language are not impressed with idiomatic Java, though.
09:22:25 <tensorpudding> the jvm might have some issues for non-java languages, but not enough that there's a lack of non-java jvm languages
09:22:51 <bxc> wlangstroth: yeah i don't beleive that fungible-class developers can switch into reading scala enough to plug shtuff into it
09:22:52 <fasta> There are also multiple jvms.
09:22:52 <tensorpudding> most people who know a more modern OO language aren't impressed with Java either
09:23:06 <wlangstroth> dino-, c_wraith: it's possible the original implementers didn't imagine it being used for anything else, but I don't know
09:23:06 <bxc> wlangstroth: but i have no empirical evidence
09:23:09 <fasta> tensorpudding: Io? ;)
09:23:51 <wlangstroth> tensorpudding: you mean like Smalltalk?
09:24:07 <ludus_sl> Suppose that we have a function f :: a -> a and that f has a local function (defined with a where clause) f' :: a -> a. Is there a way to specify that the a's of f and f' represent the same type?? If I don't declare the type of f', it works, but I really, really love to know the types of my functions
09:24:29 <fasta> wlangstroth: Smalltalk is older.
09:24:43 <fasta> wlangstroth: but still a better and more original idea than Java.
09:24:44 <wlangstroth> fasta: should I have used a ":)"?
09:24:46 <dino-> I feel like the Scala is trying to be everything to everyone. It's got candy for the OO crowd (mixins, case classes to reduce boilerplate) and it's got serious FP features for that crowd (case classes again to simulate ADTs, lambdas, closures, immutability)
09:25:08 <DRMacIver> ludus_sl: You want lexically scoped type variables
09:25:20 <DRMacIver> ludus_sl: It's a language extension
09:25:23 <tensorpudding> i'm currently a big fan of clojure
09:25:44 <DRMacIver> ludus_sl: http://haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
09:25:46 <ludus_sl> DRCMaclver; Yes, that I mean :)
09:25:48 <josiah14> I have a quick question
09:25:57 <wlangstroth> tensorpudding: the haskell influence is strong in clojure
09:26:09 <tensorpudding> in places, sure
09:26:39 <DRMacIver> ludus_sl: so yeah, just turn on the extension and add a forall a. at the outermost function and everything'll work
09:26:54 <josiah14> I'm trying to do some more complicated things now in Haskell, and I've figured out my own definition for the fibbionacci sequence and computing various arrays of geometric figures.  I'm stumped on this problem I got last week in an interview, though.
09:27:05 <josiah14> I completed the interview question in C#
09:27:15 <DRMacIver> (This is in the category of language extensions which I always turn on as soon as I remember)
09:27:17 <josiah14> but on the plane ride home, I tried to do it in HAskell and had trouble
09:27:34 <ludus_sl> DRMaclver: Oh, man, that's exactly what I needed. Thank you a lot, I will try it right now. Thank you a lot :)
09:27:36 * hackagebot vhd 0.2 - Provides functions to inspect and manipulate virtual hard disk (VHD) files.  http://hackage.haskell.org/package/vhd-0.2 (JonathanKnowles)
09:28:47 <josiah14> I need a simple haskell definition for a function that takes an array of integers [1..17] and prints "foo" for multiples of 5, "bar" for multiples of 7, "foobar" for multiples of 5 and 7, and a string representation of the number itself otherwise.  I want the result to return as a [String]
09:29:02 <dmwit> ?wiki fizzbuzz
09:29:02 <lambdabot> http://www.haskell.org/haskellwiki/fizzbuzz
09:29:07 <jhance> josiah14: Use `mapM_`
09:29:18 <dmwit> mapM_ is not appropriate here.
09:29:28 <jhance> dmwit: He says he wants to print
09:29:36 <glguy> dmwit: no, this is *completely different*, 5/7, not 3/5 ;-)
09:29:39 <dmwit> He also says he wants the result as a [String].
09:29:43 <josiah14> I think I'm not thinking quite right about Haskell yet in how it handles predicates and list comprehensions in a function definition, so I just need to see an example.
09:29:55 <jhance> dmwit: Oh, that's contradictory. Whatever, I guess mapM without the _
09:29:58 <dmwit> josiah14: I linked you to a *very similar* example.
09:30:04 <tensorpudding> i find it hard to believe that people could really have trouble writing fizzbuzz
09:30:08 <dmwit> jhance: No, just plain map without the M or _.
09:30:15 <dmwit> jhance: ghci will take care of printing for him. ;-)
09:30:15 <jhance> dmwit: He wants to print too!
09:30:25 <dmwit> jhance: I really, really doubt he was as precise as you are thinking he was.
09:30:42 <josiah14> dmwit: wheres the link?
09:30:47 <dmwit> ?wiki fizzbuzz
09:30:48 <lambdabot> http://www.haskell.org/haskellwiki/fizzbuzz
09:30:49 <bxc> tensorpudding: i've interviewed people who couldn't
09:30:54 <bxc> tensorpudding: its kinda awkward
09:31:13 <josiah14> well, I really just want a result [String].  I can always print out that result later
09:31:18 <Philippa> yeah. If you've not been introduced to recursion or induction well then it's actually surprisingly easy for people to trip over it
09:31:24 <tensorpudding> i'd have trouble writing fizzbuzz in haskell if i didn't know haskell
09:31:39 <Philippa> for the rest of us, the problem's not writing a fizzbuzz framework first :p
09:31:52 <tensorpudding> you can do fizzbuzz without having to know recursion
09:31:53 <DRMacIver> bxc: Out of curiousity how did you handle that? I'm not very good at "Sorry, continuing on with this interview would be a waste of both of our time"
09:32:09 <josiah14> lambdabot: HEy, that works!  thanks fizzbuzz!
09:32:16 <tensorpudding> it's not a complex if/else statement in java
09:32:30 <Philippa> (showing off that you can handle a general rule framework isn't always a good thing if it's not what you were asked for!)
09:32:30 <dmwit> josiah14: ...
09:32:31 <fasta> bxc: did the person claim to know the language in which you asked her/him to write something?
09:32:35 <dmwit> josiah14: lambdabot... is a bot.
09:32:59 <dmwit> ?botsnack
09:33:00 <lambdabot> :)
09:33:07 <josiah14> well, either way, my screen says the fizzbuzz example came from him
09:33:11 <josiah14> dmwit, are you a mod?
09:33:31 <jhance> josiah14: lambdabot is a bot that queries with whatever you type in
09:33:51 --- mode: ChanServ set +o dmwit
09:34:03 <dmwit> Wow!
09:34:05 <dmwit> I am now.
09:34:07 <dmwit> =D
09:34:27 * dmwit basks in his power
09:34:43 <shlevy> Any good books/papers (preferably available in a Kindle-consumable format) for learning theory and practice of type systems, especially dependent types?
09:34:50 <josiah14> haha
09:34:51 <josiah14> alright
09:34:58 <josiah14> yah, I dont come here often for answers
09:35:00 <shapr> shlevy: Types and Programming Languages is a good book on that subject.
09:35:11 <josiah14> I didnt know such bots were hanging around here
09:35:18 <Philippa> though it doesn't cover dependent types. The sequel's got a chapter on them
09:35:30 <fasta> josiah14: some are fairly advanced, like me.
09:35:32 <Philippa> Coq'Art has some value too
09:35:37 <osfameron> TaPL isn't on kindle though
09:35:46 <osfameron> which is a shame, as it's far too heavy to carry around...
09:35:58 <Philippa> there's not so much available to read on Kindle though - such stuff tends to be LaTeXed and there's no good way to convert to Kindle
09:35:59 <dmwit> josiah14: Anyway, yeah, my message "?wiki fizzbuzz" was a command telling lambdabot to link you to the wiki page on fizzbuzz...
09:36:16 <josiah14> yah, it works
09:36:37 <monochrom> @wiki doesnotexist
09:36:38 <lambdabot> http://www.haskell.org/haskellwiki/doesnotexist
09:36:41 <monochrom> hehe
09:36:43 <josiah14> exact replica of my problem, except different numbers
09:37:16 <josiah14> its so much nicer in haskell!
09:37:17 <DRMacIver> Philippa, shlevy: Also the kindle doesn't handle non-ascii stuff very well
09:37:24 <shlevy> Philippa: This book begs to differ http://www.amazon.com/Publishing-Kindle-eBooks-Using-ebook/dp/B005EC3LXW
09:37:32 <shlevy> Philippa: But I have no idea how true it is :)
09:37:44 <josiah14> in C# i couldnt get it down to less than 7 lines with the printing
09:37:50 <josiah14> or soemwhere about there
09:38:20 <dmwit> I think StackOverflow has made me too willing to give out complete answers (even to obvious homework problems).
09:38:23 <shlevy> So if I get through Types and Programming Languages, will I need a whole other book to really grok dependent types or will I have enough foundation to just use wiki articles?
09:38:36 <dmwit> Let's see, how do I...
09:38:58 <fasta> Is anyone familiar with Pandoc?
09:39:14 <dmwit> Haha, I'm an op, but not authorized to deop myself? wut
09:39:25 <josiah14> well, to put your mind at ease, dmwit, I'm not doing this for a class.  I'm really just having trouble picking up the thinking patterns I need to follow for haskell, yet
09:39:25 <shlevy> :)
09:39:32 <monochrom> long round-trip time on forums means yes you have to give fairly complete answer, can't quite socratic your way through it
09:39:38 <dmwit> josiah14: great =)
09:39:38 <byorgey> fasta: I'm somewhat familiar with it
09:39:48 <josiah14> I need to read a lot more haskell code and finish the "Learn you a Haskell For great Good" book
09:39:54 <fasta> For example, does it actually support full LaTeX as input format with tons of extensions?
09:39:55 <DRMacIver> dmwit: really? Does /deop dmwit not work?
09:40:00 --- mode: dmwit set -o dmwit
09:40:01 <DRMacIver> I didn't know IRC permissions allowed for that...
09:40:22 <fasta> byorgey: I can imagine that it only contains some finite description of what LaTeX is and not an actual interpreter.
09:40:22 <dmwit> I was trying /msg ChanServ deop #haskell dmwit
09:40:28 --- mode: ChanServ set +o dmwit
09:40:41 <dmwit> lol
09:40:46 <fasta> byorgey: it seems rather hard to convert LaTeX source to e.g. HTML in that case.
09:40:48 <monochrom> otoh you could give more than complete answer - you could give the complete derivation from problem to solution including all thought processes and all steps.
09:40:51 <byorgey> fasta: it does not contain a LaTeX interpreter, no.
09:40:58 <byorgey> fasta: it only works for some subset of LaTeX.
09:40:58 <fasta> byorgey: which raises the question as to what it does do.
09:40:59 <dmwit> Well, thanks to whoever that was, I guess. =)
09:41:05 * shapr snickers
09:41:16 <fasta> byorgey: ok, so then it is basically useless for me,
09:41:18 <fasta> .
09:41:34 <fasta> The interface with a 'ParserState' also seems rather questionable.
09:41:36 <monochrom> so for example, instead of just answering "\x -> x  has type a->a", you could show the complete inference steps
09:42:12 <josiah14> Is Leksah a good source to read as a learning resource for picking up haskell
09:42:13 <monochrom> or instead of showing just the final code, you could do the whole Richard Bird thing
09:42:24 <fasta> josiah14: probably not.
09:42:24 <dgpratt> byorgey: I was looking over your xmonad.hs yesterday :)
09:42:31 <byorgey> dgpratt: ahhh =)
09:42:42 <josiah14> what would you suggest I read, fasta?
09:42:46 <fasta> josiah14: to learn you need isolated ortogonal code with simple goals.
09:43:11 <monochrom> education should not mean that you must always hide the answer.
09:43:13 <byorgey> dgpratt: I was thinking maybe you saw a video of a talk I gave where my desktop background was visible on the projector for a short time, or something =)
09:43:17 <fasta> josiah14: Programming in Haskell or The Haskell school of expression or ....
09:43:46 <dmwit> josiah14: Read the xmonad source! There's a few files with nasty interfaces to X, but the rest is quite pure and beautiful.
09:43:50 <fasta> josiah14: I recommend actual published books because they shield you from garbage, mostly.
09:43:51 <dgpratt> byorgey: not sure I could ID it on sight; maybe if it was in Acadia...
09:44:04 <fasta> josiah14: xmonad makes more sense when you are not a newbie anymore.
09:44:08 <josiah14> okay, so I'm not going to gain much by spending some time reading actual source code along side my books?
09:44:24 <byorgey> dgpratt: yeah, I was going to be really impressed that you knew it was Maine
09:44:27 <fasta> josiah14: different people learn in different ways.
09:44:33 * monochrom is not convinced that actual published books have a lower proportion of garbage
09:44:49 <john_r_watson> OK, did the State Monad move somewhere?  Can't find it in Control.Monad.State (when :m + ...) in GHCI
09:44:50 <shapr> josiah14: Yah, I think Real World Haskell is a good way to learn the language, plus it's free online.
09:44:51 <dgpratt> byorgey: shoulda not told you how I knew :)
09:44:58 <fasta> monochrom: I'd say 90% of the published books stink, so perhaps you are right ;)
09:45:01 <shapr> john_r_watson: It's in an ALTERED STATE!
09:45:04 * shapr cackles
09:45:09 <john_r_watson> shapr: ><
09:45:10 <josiah14> great
09:45:12 <josiah14> ill check that out
09:45:32 <shapr> @index State
09:45:33 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
09:45:33 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
09:45:39 <byorgey> dgpratt: hehe =)
09:45:42 <DRMacIver> monochrom: though they perhaps serve as a good way to increase one's confidence as to whether a particular piece of information is garbage.
09:45:42 <shapr> john_r_watson: Looks like it's still there
09:45:43 <john_r_watson> shapr: index - marvelous
09:45:46 <josiah14> I figure if I become proficient in Haskell, learning other functional programming languages should be easier
09:45:46 <dmwit> john_r_watson: Control.Monad.State should do. What's the exact error message?
09:46:03 <josiah14> Thanks for the help, all
09:46:09 <john_r_watson> dmwit: weird...:m + Control.Monad.State
09:46:09 <john_r_watson>  
09:46:09 <john_r_watson> <no location info>:
09:46:09 <john_r_watson>     Could not find module `Control.Monad.State':
09:46:12 <john_r_watson>       it is not a module in the current program, or in any known package.
09:46:21 <dmwit> john_r_watson: Perhaps you should install the "mtl" package.
09:46:21 <john_r_watson> sorry about that paste... should have consolidated
09:46:33 <monochrom> no, if you don't have a lower proportion of garbage, how do you raise any confidence?
09:46:53 <john_r_watson> dmwit: did this use to come w/ the Haskell platform?
09:46:56 <monochrom> if you say, peer-reviewed, sure, that is better, and so far the best known
09:47:04 <john_r_watson> dmwit: I dont' recall havnig to go do that, but sounds good - thanks for that
09:47:05 <shapr> I'm a peer!
09:47:14 <john_r_watson> dmwit++
09:47:23 <john_r_watson> shapr++
09:47:38 <dmwit> The HP doesn't include mtl?
09:47:44 <monochrom> the HP includes mtl
09:48:16 <dmwit> I therefore conclude that john_r_watson doesn't have the Haskell Platform installed (at least for whatever version of GHC he's using).
09:48:31 <john_r_watson> dmwit: likely
09:48:57 <john_r_watson> dmwit: just did apt-get install... and it's doing stuff - must have only done ghc
09:49:04 <DRMacIver> monochrom: Because you have stronger evidence about whether a specific piece of information is garbage once you've acquired evidence regarding other contents in the book.
09:49:15 <DRMacIver> monochrom: It's a bayes rule thing :)
09:52:36 * hackagebot copilot-core 0.2.1 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-0.2.1 (LeePike)
09:52:38 * hackagebot copilot-c99 0.2.1 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.2.1 (LeePike)
09:54:35 <applicative> fasta the idea of 'full latex' is meaningless, surely, it is just a gigantic heap of macros.
09:55:47 <fasta> applicative: a true LaTeX to HTML converter would hire a graphics designer company which would have a LaTeX expert and a HTML + CSS expert to create exactly the same document.
09:56:01 <fasta> applicative: Pandoc simply provides types that don't make sense.
09:56:03 <}ElectrowolF{> print screen?
09:56:08 <dmwit> applicative: "full TeX" is not meaningless
09:56:16 <dmwit> applicative: (And quite complicated, actually.)
09:56:24 <applicative> dmwit, *that* I agree with
09:56:33 <fasta> applicative: naturally, you are free to write an AI to do that process.
09:56:38 --- mode: ChanServ set -o dmwit
09:56:47 <applicative> i don't get it what is your complain?
09:56:54 <applicative> complaint, rather
09:57:05 <fasta> applicative: you are the one who continues an old conversation.
09:57:08 <applicative> the types, what's wrong with them
09:57:37 <fasta> applicative: the ParserState type seems to be used for multiple input types.
09:57:44 * applicative has no idea what to make of that
09:57:49 <fasta> applicative: it is just very unHaskelly in that regard.
09:58:01 <applicative> fasta, yes.
09:58:24 <fasta> applicative: also it provides types like "LaTeX" instead of "SubsetOfLatex".
09:58:26 <applicative> fasta, it is a record, if you look at what it records, you'll see why
09:58:42 <fasta> applicative: I saw the record, and I would never have designed it like that.
09:58:43 <applicative> latex 1984 is a subset of latex 2011
09:58:53 <applicative> there fore they were lying then or now?
09:59:18 <fasta> applicative: details.
09:59:47 <dmwit> Are you two absolutely certain you're arguing about the same thing?
10:00:02 <fasta> It is a wonderfully worthless discussion.
10:00:20 <applicative> pandoc generates and parses documents with a specific structured declared in Text.Pandoc.Definition
10:00:56 <applicative> only what corresponds to this in 'latex' land is represented, because all and only what is contained in that type is represented
10:01:40 <fasta> applicative: but in LaTeX there are tons of different table libraries.
10:01:47 <fasta> applicative: I doubt it supports all of them.
10:02:04 <applicative> the same structure appears in markdown and html pandoc's markdown doesn't contain every markdown curlicue that has been proposed, but only its own. and likewise its html doesn't include everything
10:02:32 <applicative> fasta, indeed not, it supports only very primitive tables, because only they are represented in its type
10:02:41 <fasta> applicative: the notion of having a LaTeX input format is just silly.
10:02:59 <fasta> applicative: unless you have a non-trivial program behind it, which pandoc is not.
10:03:10 <applicative> fasta, why? why any sillier than a markdown input format
10:03:34 <fasta> applicative: markdown is fairly inexpressive, AFAIK.
10:03:44 <applicative> you can write latex in order to write html with pandoc if you like.
10:03:54 <fasta> Also, I consider markdown to be a mistake too.
10:04:07 <fasta> Almost all the formats that Pandoc 'supports' are a mistake.
10:04:17 <fasta> Most of them don't even have a proper grammar.
10:04:36 <fasta> As such, the program does 'whatever people wants it does'.
10:04:52 <applicative> markdown has a grammar, thanks to pandoc inter alia
10:05:05 <fasta> applicative: ok, so that changed. Great.
10:05:27 <fasta> Is it complete too?
10:05:53 <applicative> the type pandoc uses doesn't include many things you might want, there is a constant struggle over its content.
10:06:35 <dmwit> I thought each markdown implementation invented its own grammar.
10:06:51 * applicative is finding it a little unreal someone just walked into his office needing pandoc assistance....
10:06:57 <dmwit> Saying "there is a grammar" to mean "there are many grammars" is not just unhelpful, it's deceitful.
10:07:06 <fasta> Right
10:07:21 <fasta> Also, if someone needs help with a program like pandoc, it means pandoc stinks.
10:07:25 <applicative> dmwit, most dont have an express grammar.
10:08:10 <applicative> fasta, it is interaction with latex that is the problem, as usual.
10:08:27 <fasta> applicative: latex also needs a modern replacement :)
10:08:40 <applicative> ok lets write it
10:08:54 <fasta> applicative: do a kickstarter project?
10:08:54 * applicative must go despite this interest of this topic
10:09:53 <Feuerbach> there was one (I think it was called ant), and it was even scripted in something Haskell-like. And written in OCaml
10:11:26 <fasta> Feuerbach: I know. What happened to it?
10:11:55 <fasta> Feuerbach: I think TeXMacs is a better idea.
10:11:59 <_Mikey> data NiceTry
10:12:12 <_Mikey> data NiceTry a = NiceTry
10:12:15 <_Mikey> data NiceTry a = NiceTry
10:12:36 <_Mikey>     | Nothing
10:12:48 <_Mikey> -.-
10:13:12 <dmwit> _Mikey: How about using hpaste.org?
10:13:26 <_Mikey> oh
10:15:25 <hpaste> “_Mikey” pasted “newMaybeJustNothingType” at http://hpaste.org/54028
10:15:42 <_Mikey> oh
10:15:43 <_Mikey> cool
10:16:09 <_Mikey> that isn't vaild haskell is it?
10:16:28 <dmwit> Looks like valid Haskell to me.
10:16:37 <_Mikey> hmm
10:16:47 <_Mikey> but it when I :l it
10:16:49 <dmwit> You'll have to be careful to disambiguate the new "Just" from the old "Just".
10:16:56 <dmwit> For example, by importing the Prelude qualified.
10:17:08 <_Mikey> how does one do that?
10:17:17 <dmwit> "import qualified Prelude"
10:17:20 <dmwit> or perhaps
10:17:24 <dmwit> "import qualified Prelude as P"
10:17:30 <_Mikey> and that will override default Prelude?
10:17:39 <dmwit> Then "Just" will be your new Just, and "Prelude.Just" or "P.Just" will be the old one.
10:17:44 <dmwit> No, no overrides.
10:17:51 <dmwit> Everything is still as it was in the Prelude.
10:17:57 <dmwit> The names for things in the Prelude are just longer. =)
10:18:07 <_Mikey> I see
10:18:12 <dmwit> In Haskell, you don't get do-overs. No mutation.
10:18:22 <_Mikey> so if I wanted to use something like
10:18:24 <_Mikey> fst
10:18:31 <_Mikey> I have to do P.fst ?
10:18:34 <dmwit> Yes.
10:18:38 <dmwit> You can get around that, too. =)
10:18:43 <dmwit> You can add an additional line like
10:18:44 <_Mikey> oooh!
10:18:50 <dmwit> "import Prelude hiding (Just)"
10:19:11 <dmwit> And then all the usual Prelude names (except Just) will be available without qualifiers.
10:19:11 <_Mikey> ok, this is quite insightful
10:19:30 <_Mikey> I'm looking at a function..
10:20:07 <hpaste> “_Mikey” annotated “newMaybeJustNothingType” with “newMaybeJustNothingType (annotation)” at http://hpaste.org/54028#a54029
10:20:47 <_Mikey> its returning nothing when the balance will go lower than the reserve
10:20:58 <_Mikey> its from the realworldhaskell book
10:21:11 <_Mikey> however I'm thinking..
10:21:28 <_Mikey> what if I want to use Nothing to catch something else
10:21:53 <_Mikey> can I make my own sort of maybeNothingJust types to sort of send messages around?
10:22:19 <dmwit> Absolutely. There's nothing magical about Maybe; it's just a definition in a library that happens to be useful sometimes.
10:22:31 <dmwit> Making new data types is super cheap in Haskell, and strongly recommended.
10:23:16 <dino-> So, what should I do if I have basically broken my entire ghc installation by forcing a reinst of it via my distro's packaging?
10:23:19 <_Mikey> cool.
10:23:28 <_Mikey> cheers dmwit!
10:23:31 <dino-> Hunt down all of the dirs in /usr/share/lib and similar and destroy?
10:24:22 <dmwit> Did the reinstallation reinstall a different version, or an updated one?
10:24:28 <shlevy> dino-: Use a better package manager :P
10:24:30 <fasta> dino-: implement a tool to make sure it doesn't happen again, please :)
10:24:36 <FUZxxl> @kind Maybe Either
10:24:37 <lambdabot>     `Either' is not applied to enough type arguments
10:24:37 <lambdabot>     The first argument of `Maybe' should have kind `*',
10:24:37 <lambdabot>     but `Either' has kind `* -> * -> *'
10:24:38 <fasta> shlevy: something like... Nix?
10:24:40 <dino-> dmwit: Same versions of nearly everything, but those hex sigs don't match.
10:24:46 <shlevy> fasta: Hey, what a great idea!
10:24:53 <dmwit> dino-: Okay, so you also reinstalled libraries, then?
10:24:53 <dino-> So things that I installed with cabal-install are borken now.
10:24:55 <fasta> shlevy: yeah!
10:25:10 <dschoepe> dino-: This might be worth a try: http://hackage.haskell.org/package/ghc-pkg-autofix
10:25:14 <dmwit> dino-: Do you cabal-install locally or globally?
10:25:18 <dino-> dmwit: Yeah, this is where I need to manually clear out /usr/lib/...
10:25:22 <dino-> dmwit: globally
10:25:34 <dmwit> dino-: Why not try "cabal install --reinstall world"?
10:26:02 <dino-> dmwit: oo, I didn't know about that
10:26:17 <dino-> nice
10:26:29 <DRMacIver> Any recommendations on optimizing buildIndex in https://github.com/DRMacIver/haskell-nearest-neighbour/blob/master/Algorithms/MetricSearch/VantageTree.hs ?
10:26:57 <dino-> dschoepe: Cool, I'll look at that as well.
10:27:07 <DRMacIver> I suspect the answer is "use a better algorithm", which I know I need to do, as most of the time is spent in distance calculation, I just wanted to check I wasn't missing something obvious
10:27:08 <dino-> Glad I came asking, didn't know about these things
10:27:15 <dcoutts> dmwit, dino-: there's a good chance it will not work, but if it does then all's good
10:27:18 <solidsnack> DRMacIver: Is the problem calls? Memory?
10:27:41 <shlevy> Grmbl. Are there any ways around the lack of scoped record accessors that won't make me feel dirtily hackish?
10:28:12 <DRMacIver> solidsnack: Runtime at the moment. Profiling suggests that most of it is spent in distances, which is why I suspect the main thing to do is improve the algorithm.
10:28:26 <dmwit> shlevy: Put each conflicting record in a separate module. It's the only way for now.
10:28:45 <shlevy> dmwit: And to get around the problem of mutually-referential imports?
10:28:47 <dmwit> You can also manually namespace by prefixing fields with a type-specific prefix.
10:28:48 <dschoepe> shlevy: I think a cleaner solution than most (not necessarily that clean at all) is to prefix them with foo_.
10:28:54 <dmwit> shlevy: google hs-boot
10:29:38 <dmwit> dschoepe: That takes the namespacing control out of the hands of clients. But yes, it's the most viable other choice.
10:30:00 <hpaste> DRMacIver pasted “Profiled output from criterion” at http://hpaste.org/54030
10:30:33 <DRMacIver> (the bits inside "bt" are the important ones)
10:30:45 <shlevy> dmwit: Ah, thanks. Didn't realize mutually-referential imports were included in H98
10:31:16 <dmwit> shlevy: Yeah. And for this reason almost no compiler actually supports H98. =)
10:32:00 <dschoepe> dmwit: ... or we could all switch to Agda where that thing is handled in a better way :)
10:32:13 <letrec> :t ($!)
10:32:14 <lambdabot> forall a b. (a -> b) -> a -> b
10:32:20 <dmwit> Yeah. =)
10:32:27 <dmwit> Many things are handled less well, though. =/
10:33:52 <troydm> does haskell have global program variables? let's say i've parsed config that had one option and i would like to access that option across all my program
10:33:53 <troydm> ?
10:34:00 <dschoepe> dmwit: Hm, I didn't notice any obvious drawbacks besides a less developed ecosystem. Could you give me an example?
10:34:00 <dmwit> NO.
10:34:16 <dmwit> Compilation speed, final executable speed?
10:35:09 <dschoepe> troydm: They can be emulated with unsafePerformIO and IORefs, but I think that is a Bad Thing™ :)
10:35:34 <troydm> dschoepe: what's not the best way?
10:35:35 <letrec> My understanding is that (f $! a) forces evaluation of (f a). Correct? Assuming it is, what's happening if I write g a b = a+b and then something like (g $! 5) ?
10:35:52 <dschoepe> troydm: http://hackage.haskell.org/package/reflection -- this solves it in a really cool way, but I haven't tried to use it yet
10:36:03 <c_wraith> letrec: (f $! a) forces the evaluation of a when f is evaluated.  that's not the same thing.
10:36:24 <dmwit> troydm: Why not use the Reader monad instead?
10:36:38 <dschoepe> dmwit: Ah, okay, but those are implementation details, not something wrong with the language, I think.
10:36:40 <c_wraith> letrec: more specifically, it just forces the evaluation of a before the evaluation of (f $! a) finishes...
10:36:43 <dmwit> It's clean, it's composable, it's easy to understand (in the theory sense of "easy to understand")...
10:37:01 <c_wraith> troydm: why would you want a function that depended on some state that didn't explicitly say it depended on that state?
10:37:01 <monochrom> > case (undefined $! undefined, True) of (_, True) -> "success"
10:37:03 <lambdabot>   "success"
10:37:13 <dschoepe> dmwit: That forces you to rewrite things monadically though.
10:37:19 <monochrom> nothing forces undefined $! undefined
10:37:33 <dmwit> dschoepe: Only the things that weren't "pure" to begin with.
10:37:44 <_Mikey> who posted that profile thing?
10:37:50 <_Mikey> it looks awesome.
10:37:58 <dino-> Well, this all didn't work with the cabal world
10:38:12 <dmwit> Here we go!
10:38:15 <dino-> Lots of broken packages, including ghc-7.0.3 !
10:38:18 <dmwit> troydm: Have a look at http://lukepalmer.wordpress.com/2011/05/20/the-whole-program-fallacy/
10:38:22 <letrec> c_wraith: oh, ok, I got the difference.. Thx
10:38:36 <dino-> Maybe I had just better remove it all by hand.
10:39:13 <dschoepe> dmwit: The situation I tend to encounter is that I passed parameters like configurations around explicitly and want to change that due to additional parameters. Rewriting that to use Reader isn't very pleasant IMO.
10:39:31 <dmwit> Agreed.
10:41:44 <troydm> dmwit: thx
10:43:27 <tsousa> http://dpaste.com/656362/ in this code what is newGen?
10:44:05 <dmwit> tsousa: It's a variable defined by the let binding.
10:44:21 <dmwit> tsousa: "random" takes a generator and returns something pseudorandom + an updated generator
10:44:25 <c_wraith> yay manual state threading.
10:44:45 <dmwit> Yeah, this would be much nicer with MonadRandom. =)
10:45:02 <c_wraith> I wish MonadRandom had a rank-2 backdoor, still.
10:45:18 <dmwit> sounds kinky
10:45:29 <tsousa> dmwit, yes but in the second coin what is the value that newGen has?
10:45:56 <dmwit> tsousa: There's no mutation, so I'm not sure I understand the question.
10:46:07 <dmwit> newGen has the value that random returned from the first call. It always has that value.
10:46:13 <dmwit> No matter where it's used.
10:46:56 <tsousa> dmwit, so basicaly random gen is the seed?
10:48:03 <c_wraith> dmwit: I just want to have a function with this type:  (MonadRandom m, Random a) => (forall g. RandomGen g => g -> (a, g)) -> m a
10:48:12 <dmwit> No, gen is the seed. random is a function that accepts a seed.
10:49:00 <tsousa> dmwit, yes
10:49:49 <tsousa> dmwit, then the second one uses the first seed and the third one uses the second seed right?
10:50:13 <dmwit> c_wraith: Oh, okay. Do you have a lot of MonadRandom instances that aren't RandT's?
10:50:15 <DRMacIver> Hmm. I am extremely suspicious of the speedup I got by changing the definition of distance from if x > y then x - y else y - x to abs(y - x).
10:50:30 <DRMacIver> (It's by like two orders of magnitude)
10:50:34 <shlevy> @src abs
10:50:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:50:39 <c_wraith> dmwit: The only time I've ever actually used MonadRandom... yes.
10:50:43 <dmwit> tsousa: right
10:51:10 <dmwit> c_wraith: Seems like a patch you could write and send upstream. =)
10:51:31 <c_wraith> dmwit: not sure Cale would take it, since it would involve adding a rank-2 type to the type class
10:51:50 <dmwit> Make it depend on a flag that defaults to True. Also, Cale is not the maintainer.
10:51:54 <shlevy> DRMacIver: For Int, we have abs n  = if n `geInt` 0 then n else negateInt n
10:51:54 <c_wraith> isn't he?
10:52:04 <Cale> I'm the original author
10:52:07 <shlevy> DRMacIver: Which... seems the same.
10:52:12 <dmwit> yes, I know that
10:52:16 <c_wraith> ah.  ok, you were probably the maintainer last time I looked
10:52:21 <shlevy> DRMacIver: Ah, the >= might be faster than the > ?
10:52:21 <Cale> But I let anyone do anything they want with that code.
10:52:31 <Cale> I didn't even put it on hackage myself
10:52:39 <c_wraith> oh.
10:52:46 <Cale> Someone else did, I don't remember.
10:52:47 <c_wraith> well, then, I just totally misread things. :)
10:52:52 <DRMacIver> shlevy: this was for doubles.
10:53:01 <Cale> I originally just stuck the code on the (old) Haskell wiki.
10:53:07 <Cale> as an example
10:53:18 <Cale> and it's been growing without me since then :)
10:53:25 <dmwit> Hackage actually lists a lot of people. Cale as author, Eric Kidd as maintainer, and Chris Done as most recent uploader.
10:53:27 <DRMacIver> shlevy: Also I wouldn't be surprised if that implementation was a lie and GHC actually used something better behind the scenes.
10:53:47 <_Mikey> o.o
10:53:51 <dmwit> I would never have guessed there could be a package with three different answers to those three questions. =P
10:54:07 <c_wraith> Maybe I should just upload a new version then.  Why not? :)
10:54:44 <dmwit> Hm. For packages with a maintainer, it's probably a good idea to check with the maintainer before uploading a new version.
10:55:24 <c_wraith> Given what I know of chrisdone, he probably didn't upload a new version unless he couldn't contact the listed maintainer
10:55:42 <dmwit> Or he could contact the maintainer and the maintainer gave the go-ahead...
10:55:45 <c_wraith> that too
10:56:18 <RaptorRarr> Rewrite rules have to preserve the type of the expression *shakes claw*
10:59:27 <dmwit> WHY would you want to write a rewrite rule that changes the type of an expression?
10:59:33 <dmwit> I can not imagine that ending well.
10:59:41 <dino-> Huh, reinstalling my Haskell stuff ran into maybe a circular dep. text requires test-framework which requires text
10:59:44 <dino-> Can't install either of them
10:59:50 <dino-> (with cabal install)
10:59:52 <RaptorRarr> dmwit: I wanted to make rewrite rules to produce source code.
11:00:00 <c_wraith> RaptorRarr: the most general possible type of the expression, or the least-general possible type of the expression?
11:00:13 <DukeDave> So, I've just pulled in some changes, I have a conflict, and I *think* it is because a patch I pulled in deleted a file in which I made a change; how would I check this hypothesis?
11:00:28 <dmwit> c_wraith: In the rewrite rule, you specify what type it must start/end at.
11:00:29 <c_wraith> dino-: that wouldn't surprise me at all.
11:00:51 <c_wraith> dmwit: I guess I just don't know that much about that optimization phase.
11:02:03 <DukeDave> When I 'annotate' a patch I can see a hunk which deletes every line in a file, but no mention of deleting the file?
11:02:46 <wlangstroth> DukeDave: maybe ask in #darcs?
11:03:24 <DukeDave> wlangstroth: Ha, fail, thanks for pointing that out :)
11:04:04 <dino-> Anybody know how I can get around this?
11:04:23 <dino-> Can't install either text or test-framework, they both complain that the other is required first.
11:04:33 <shapr> dino-: install both at the same time?
11:05:01 <dylex> c_wraith: if you do add that to MonadRandom, I wonder if it makes sense to make it the only class function.  Also, the function is not strictly necessary because of the MonadState instance.
11:05:04 <dino-> shapr: Doesn't work. But thank you
11:05:07 <RaptorRarr> Is there a way to get GHC to give you the Haskell (not Core) version of your source code after it's been optimized?
11:05:13 <shapr> dino-: What's the error if you try to install both at the same time?
11:05:22 <dmwit> dylex: No, it does not make sense to make that the only class function.
11:05:25 <c_wraith> dylex: nah, the other class functions are convenient shortcuts
11:05:27 <RaptorRarr> (sorry if that's a repeat, wasn't sure if it transmitted)
11:05:33 <c_wraith> dylex: though they could have a default implementation in terms of it
11:05:48 <dylex> c_wraith: Right, that's more what I mean, not getting rid of them.
11:05:54 <c_wraith> good point about the MonadState instance, though
11:06:04 <dmwit> dylex: Also, what MonadState instance?
11:06:13 <DukeDave> dino-: This? http://www.haskell.org/cabal/FAQ.html#internal-error-invalid-install-plan
11:06:25 <dylex> dmwit: (MonadState s m, RandomGen g) => MonadState s (RandT g m)
11:06:33 <c_wraith> Oh.
11:06:34 <dmwit> dylex: The MonadState instance for RandT doesn't give you access to the generator. That's the whole point of RandT.
11:06:36 <c_wraith> that's not useful
11:06:59 <dylex> Oh, I misread that.  Yeah.
11:07:07 <c_wraith> The whole point for making it a rank-2 type is preventing leaking the generator
11:07:07 <dino-> shapr: regardless of order I get this: text-0.11.1.9 failed during the configure step. The exception was:
11:07:10 <dino-> ExitFailure 1
11:07:46 <dino-> DukeDave: Nah, it's a configuration failure
11:08:00 <shapr> dino-: Sounds like you're missing a -dev lib to me
11:08:02 <DukeDave> dino-: Oh dear :(
11:08:12 <dmwit> dino-: Bootstrap yourself with old versions, then COMPLAIN to the text and test-framework maintainers.
11:08:25 <_oz> RaptorRarr: afaik no. optimisations are performed on core.
11:08:26 <dino-> shapr: Weird, this stuff was all here a couple of months ago.
11:08:36 <dino-> Guess one of these things has a newer native lib dep, could be.
11:09:54 <dino-> Maybe I should stop doing everything --global too. I could have picked last night's entire .ghc dir backup if that was the case.
11:16:47 <paolino> @src lefts
11:16:48 <lambdabot> Source not found. Take a stress pill and think things over.
11:16:50 <dino-> It's working this way: install text-0.11.0.0 first, then test-framework, then test-framework-hunit and test-framework-quickcheck2 (both manually), and then text (head version) on top of all that. wow!
11:17:29 <paolino> lefts   ∷  [Either a b] → [a]
11:17:29 <paolino> lefts x = [a | Left a ←  x]
11:18:09 <dino-> Oh I spoke too soon.
11:18:27 <paolino> mh, list comprehension is doing something there ?
11:18:53 <RaptorRarr> > [a | Left a <- [Left 1, Right 2]]
11:18:54 <lambdabot>   [1]
11:19:38 <paolino> <- is filtering
11:20:29 <dino-> Well, this is awful.
11:20:30 <RaptorRarr> I've got to remember that. It makes it easy to avoid getting the nontotal function error.
11:22:25 <egroid> http://pastebin.com/W0GubyMq whats wrong with this code?
11:22:27 <mauke> The paste W0GubyMq has been copied to http://hpaste.org/54033
11:23:37 <paolino> egroid: dosn't it compile ?
11:23:55 <egroid> it does
11:24:06 <egroid> paolino: but it doesnt work when fed with data
11:24:47 <egroid> oh wait
11:25:00 <paolino> first clause seems wrong
11:26:19 <RaptorRarr> It doesn't handle the empty list
11:26:48 <egroid> true
11:28:16 <paolino> it's ok
11:29:23 <egroid> paolino: yea o.O
11:29:37 <egroid> thx
11:29:39 <egroid> anyways
11:41:21 <scooty-puff1> is it possible to have ghc only warn about missing type signatures on exported functions?
11:41:45 <dmwit> I don't think so.
11:42:05 <byorgey> sounds like a sensible option though.
11:42:56 <scooty-puff1> i have not yet hacked on ghc at all - were i to provide a patch, is it pretty straightforward as to who it needs to be sent to (and would it be accepted for consideration?)?
11:43:20 <byorgey> scooty-puff1: yes, and yes
11:43:27 <scooty-puff1> k, thanks
11:43:31 <byorgey> scooty-puff1: you just make a ticket on the GHC bug tracker and attach your patch
11:43:57 <shachaf> I wish warnings were "standardized" like language extensions.
11:44:26 <shachaf> So instead of {-# OPTIONS_GHC -fno-warn-blah -fwarn-something #-} you could say {-# WARN NoBlah, Something #-}
11:46:15 <scooty-puff1> do warnings change much (new ones, new analyses, etc.)?  my only concern is if it would slow down change, but it hasn't seemed to impede haskell at all
11:46:28 <scooty-puff1> (in terms of language extensions)
11:46:50 <shachaf> Well, the "standardized" LANGUAGE pragmas aren't even all that standard.
11:47:04 <Saizan> how so?
11:47:20 <shachaf> Saizan: Do they ask anyone before adding a new one to GHC?
11:48:46 <Saizan> well, no, but they end up being specified as part of haskell'
11:49:11 <shachaf> Well, some of them, eventually, yes.
11:49:40 <shachaf> LANGUAGE pragma identifiers are way too long.
11:50:03 <shachaf> At least they gave up an abbreviated it for GADTs, but not for MPTCs, say.
11:53:44 <c_wraith> GeneralizedAlgebraicDataTypes would have been such a good extension name, too
11:54:07 <shachaf> SpecializedAlgebraicDataTypes
11:55:42 <edwardk> standardized warnings would be strange
11:55:50 <edwardk> not necessarily a bad idea, just strange
11:56:11 <shachaf> Really I just don't like -f flags.
11:56:48 <shachaf> I suppose many warnings are be very compiler-specific in their behavior.
11:57:42 <edwardk> I always thought starting a flag with -f was rather redundant ;)
12:03:00 <endojelly> what's currently favored for (simple) SQL database access? postgresql in my current case
12:03:19 <endojelly> HDBC?
12:04:10 <c_wraith> HDBC is certainly simple.
12:05:18 <dmwit> edwardk: -f is Hungarian notation. The flags that start with "f" are booleans.
12:05:30 <dmwit> So there are -ffoo and -fno-foo.
12:05:46 <edwardk> dmwit: i'm familiar, it just amuses =)
12:05:56 <shapr> ghc -fu ?
12:06:02 <egroid> :D
12:06:03 <endojelly> I'm just looking at the description of HaskellDB
12:06:04 <endojelly> sounds nice
12:06:05 <alistra> -fuuuuuuuuuuuuuuuuuuuuu
12:06:09 <dmwit> Now, if we could design a typed shell, it would make sense to stop using -f... =)
12:06:17 <endojelly> type safe query expression and all
12:06:21 <endojelly> maybe I'll gibe it a try
12:06:46 <geheimdienst> in the typeclassopedia, they say "Pointed*" with the asterisk indicating that it's from category-extras, not from base. they don't do that for e.g. Comonad. anyone know why?
12:07:11 <edwardk> because Comonad is less controversial and more useful ;)
12:07:26 <aristid> geheimdienst: Comonad is available outside category-extras
12:07:26 <endojelly> would you recommend HaskellDB?
12:07:36 <edwardk> as is pointed
12:07:45 <edwardk> 'comonad' and 'pointed' respectively
12:07:54 <shachaf> geheimdienst: Probably an oversight.
12:07:54 <endojelly> thing is, I really don't have much time, so I'd rather not play around for 3 hours and discover that it doesn't work for me
12:07:56 <geheimdienst> aristid: but not in base
12:07:56 <aristid> edwardk: stop destroying my story with facts
12:08:18 <geheimdienst> shachaf: ok, that's what i figured
12:08:30 <shachaf> Let's all make byorgey write Typeclassopedia 2: Revenge of the Monad
12:08:46 <sm> endojelly: have you looked at persistent ?
12:09:04 <Eduard_Munteanu> The Monad: Reloaded
12:09:10 <sm> HDBC and persistent are probably the quickest to start with and best supported
12:09:27 <sm> haskelldb is a more than 3hr investment IMHO
12:09:30 <geheimdienst> shachaf: no let's not :) that would obsolete the typeclassopedia web version that i'm putting on the wiki
12:09:46 <shachaf> geheimdienst: byorgey is planning to do it anyway.
12:10:06 <endojelly> sm, no?
12:10:11 <dmwit> "Let's not make things better, I haven't put enough lipstick on the worse version yet."
12:10:34 <geheimdienst> shachaf: yeah i know, but he said typeclassopedia 2.0 is not imminent
12:10:51 <geheimdienst> dmwit: *shrug* you don't have to read typeclassopedia if you don't like it
12:11:01 <dmwit> I like it a lot.
12:11:07 <endojelly> ok, the student paper about HaskellDB looks very good, but, yeah, I think I'll save that for when I have time
12:11:10 <dmwit> I just thought your attitude of "don't make a better version" weird.
12:11:39 <sm> endojelly: if you do pursue HaskellDB, see chrisdone's recent blog post about it on planet haskell
12:11:55 <endojelly> sm, thanks I will...
12:11:57 <geheimdienst> that was tongue-in-cheek, as indicated by the ":)" i put in there ...
12:12:13 <endojelly> sm, so, then the question I guess is: why persistence over HDBC?
12:12:19 <DanBurton> @remember dmwit Let's not make things better, I haven't put enough lipstick on the worse version yet.
12:12:20 <lambdabot> Done.
12:21:09 <dmwit> I like this "get reading fluency but not writing fluency" style of Haskell crash course.
12:22:40 <yrlnry> It's important if you are a maintenance programmer in a large bureaucratic organization and you have to interface to some Haskell module in the payroll code.
12:22:57 <dmwit> hahaha
12:23:08 <dmwit> gotta hate that legacy Haskell code
12:23:08 <yrlnry> :D
12:23:56 <wlangstroth> where is this legacy payroll Haskell code? I smell money.
12:25:31 <byorgey> and some poor sysadmin is stuck getting Gofer to build in order to compile the payroll system
12:31:00 <wlangstroth> This sounds like legend. COBOL or MUMPS, I would believe
12:32:09 <shachaf> It sounds to me more like a joke than like a legend.
12:33:38 <asante> how can i use gentoos portage version of cabal? i merged it but can't find the executable
12:33:59 <shachaf> asante: Maybe you need to install "cabal-install"?
12:34:11 <shachaf> They're two different things, although cabal-install's executable is called "cabal".
12:37:00 <asante> shachaf: ok, that should work
12:44:58 <sm> endojelly: if your needs are very simple, I suspect persistent is higher-level and you'll have less code/boilerplate
12:47:05 <sm> I think both are actively used, developed, and documented. HDBC's home has moved somewhere unknown though
12:47:36 <wlangstroth> on the topic of persistence, has anyone played with acid-state?
12:51:01 <rostayob> wlangstroth: i have. it's great
12:53:15 <wlangstroth> rostayob: I'm pretty impressed myself, although it's only with a hobby project, so I haven't really put it through the ringer
12:53:46 <rostayob> wlangstroth: it's great at what it does, but it's not good for everything
12:53:51 <rostayob> but i think it's really need
12:53:53 <rostayob> *neat
12:54:44 <byorgey> refactoring Haskell = AWESOME  \o/
12:55:07 <wlangstroth> byorgey: true
12:56:55 <pcavs>  /clear
12:57:11 <tswett> wlangstroth: acid-state the Haskell package?
12:57:48 <Sgeo|web> @unmtl MaybeT WriterT [String[ a
12:57:48 <lambdabot> err: Parse error
12:57:52 <wlangstroth> tswett: yeah, the re-written happstack-state
12:57:56 * tswett nods.
12:58:04 <Sgeo|web> @unmtl MaybeT WriterT [String] a
12:58:05 <lambdabot> err: `WriterT (Maybe [String]) a' is not applied to enough arguments, giving `/\A. a (A, Maybe [String])'
12:58:16 <Sgeo|web> @unmtl MaybeT (WriterT [String]) a
12:58:16 <lambdabot> err: `WriterT [String] (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a (A, [String])'
12:58:49 <Sgeo|web> @mtl WriterT [String] (Maybe a)
12:58:50 <lambdabot> Maybe you meant: ft map msg pl unmtl url
12:59:05 <wlangstroth> rostayob: have you found any serious problems using acid-state? (re: "not good for everything")
12:59:22 <Sgeo|web> @unmtl WriterT String (Maybe a)
12:59:23 <lambdabot> err: `WriterT String (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a (A, String)'
12:59:32 <Sgeo|web> @unmtl WriterT [String] (Maybe a)
12:59:32 <lambdabot> err: `WriterT [String] (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a (A, [String])'
12:59:58 * Sgeo|web seems to be utterly clueless
13:00:09 <Sgeo|web> But, I want the log to survive even if the end result is Nothing
13:01:10 <byorgey> @unmtl WriterT String Maybe a
13:01:10 <lambdabot> Maybe (a, String)
13:01:22 <byorgey> @unmtl MaybeT (Writer String) a
13:01:22 <lambdabot> (Maybe a, String)
13:01:31 <Sgeo|web> There we go, ty
13:01:36 <byorgey> np
13:01:44 * Sgeo|web still needs to figure out how to work out which order transformers go
13:01:58 <byorgey> it's a bit unintuitive
13:02:12 <dmwit> I always use ?unmtl to figure it out, too.
13:02:29 <dmwit> I don't see a reason to find another way to do it.
13:03:05 <byorgey> on a very hadwavy intuitive lever you can remember that "the effects of inner monads override the effects of outer monads"
13:03:07 <tswett> Does FooT (BarT Baz) a always come out to Baz (Bar (Foo a))?
13:03:09 <byorgey> *level
13:03:14 <Sgeo|web> It's confusing to guess like that and have a bot tell you the answer
13:03:41 <byorgey> tswett: essentially, yes
13:03:49 <dmwit> ?unmtl ContT r Maybe a
13:03:49 <lambdabot> (a -> Maybe r) -> Maybe r
13:04:12 <dmwit> That one doesn't seem to.
13:04:29 <tswett> ?unmtl MaybeT (ContT r) a
13:04:29 <dmwit> ?unmtl Cont (Maybe r) a
13:04:30 <lambdabot> err: `ContT r (Maybe a)' is not applied to enough arguments, giving `/\A. (A -> Maybe a r) -> Maybe a r'
13:04:30 <lambdabot> (a -> Maybe r) -> Maybe r
13:04:39 <tswett> ?unmtl MaybeT (Cont r) a
13:04:40 <lambdabot> (Maybe a -> r) -> r
13:04:42 <Sgeo|web> The nontransformer is where the thing is stored, I gues
13:05:47 <tswett> So out of ContT c (State s) and StateT s (Cont c)... I don't know what it would mean for state to override continuation, but I can imagine what it would mean for continuation to override state.  So I would guess that in the second monad, continuations contain state, and calling them restores the state to that, whereas in the first monad, continations don't contain state, and calling them leaves the state along.
13:05:54 <tswett> Leaves it alone, rather.
13:06:40 <tswett> Now, about alwaysSucceeds in the STM package.  Does it just add an invariant that sticks around forever, leaving you with perpetual overhead?
13:07:23 <Sgeo|web> @unmlt ConT c (State s) a
13:07:23 <lambdabot> Maybe you meant: unmtl unpl
13:07:29 <Sgeo|web> @unmtl ConT c (State s) a
13:07:30 <BlankVerse> how to remove packages from cabal-dev?
13:07:30 <lambdabot> ConT c (State s) a
13:07:43 <Sgeo|web> lambdabot: You're a genius!
13:07:57 <tswett> @unmtl ContT c (State s) a
13:07:57 <lambdabot> (a -> s -> (c, s)) -> s -> (c, s)
13:07:59 <Sgeo|web> @unmtl ContT c (State s) a
13:08:00 <lambdabot> (a -> s -> (c, s)) -> s -> (c, s)
13:08:20 <RaptorRarr> @mtl (a -> s -> (c, s)) -> s -> (c, s)
13:08:20 <lambdabot> Maybe you meant: ft map msg pl unmtl url
13:08:20 <Sgeo|web> @unmtl StateT s (Cont c) a
13:08:20 <lambdabot> s -> (a -> s -> c) -> c
13:09:20 <tgeeky_> wavewave: -> pm, physics question? :)
13:11:11 <dmwit> tswett: Yes.
13:30:57 <prototrout> .
13:35:44 <erus`> is there opengl es wrapper in haskell?
13:38:10 <bblum> in Language.C.Syntax.AST, why is there a separate field for [CAttr] in the both the CDeclr and in CFunDeclr? it seems like they are redundant
13:58:06 * hackagebot network-bitcoin 0.1.1 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.1 (MichaelHendricks)
13:58:41 <dmwit> eeeexcellent
13:59:41 <erus`> can i get ghci style autocomplete in vim?
13:59:45 <erus`> that would be awesome
14:00:15 <DanBurton> I'm sure it can be done
14:00:22 <DanBurton> the question is, has someone done it yet?
14:00:55 <erus`> what is the answer?
14:01:10 <DanBurton> quite possibly
14:01:19 <erus`> good enough for me :)
14:01:21 <Cale> The answer is probably no.
14:01:38 <Cale> Well, at least, I haven't heard of such a thing
14:01:42 <erus`> i probably has a load of unix bash files required to install it anyway
14:02:29 <Cale> oh, actually
14:02:31 <Cale> I'm wrong
14:02:38 <Cale> I *have* heard of such a thing
14:02:48 <Cale> http://projects.haskell.org/haskellmode-vim/screencasts.html
14:02:54 <Cale> http://projects.haskell.org/haskellmode-vim/
14:14:43 <copumpkin> type Amount = Fixed Satoshi
14:14:45 <copumpkin> mndrix++
14:15:28 <monochrom> what is satoshi?
14:15:45 <copumpkin> the smallest unit of bitcoin
14:15:53 <copumpkin> also, the creator's (pseudo)nym
14:16:43 <rwbarton> I should port the Bitcoin mining algorithm to postscript and run it on the printers on campus.
14:16:48 <rwbarton> Then I'd be printing money!
14:17:19 <copumpkin> hah, yep
14:17:31 <copumpkin> might not print very much money though :)
14:18:23 <roconnor> Presbyterian families?
14:19:25 <copumpkin> roconnor: what about them?
14:19:47 <roconnor> apperently they are Petersson-Synek trees
14:21:59 <incluye> I've defined a datatype: data Expr = Sum Expr Expr | Diff Expr Expr ... Constant Float
14:22:15 <incluye> is there any way to make the Sum, Diff etc. constructors take a Float and automagically convert it to a Constant Float
14:22:33 <roconnor> what's a Constant Float?
14:22:53 <incluye> uh
14:22:58 <c_wraith> well, you can make Expr an instance of Num
14:23:20 <c_wraith> And then define fromInteger to create a Constant
14:23:22 <incluye> roconnor: you know...data declarations
14:23:31 <dmwit> class ExprLike a where sum :: a -> a -> Expr; instance ExprLike Float where sum a b = Sum (Constant a) (Constant b)
14:23:33 <incluye> oh okay that is an idea
14:23:37 <roconnor> oh wait
14:23:37 <roconnor> incluye: never mind
14:23:41 <c_wraith> and while you're at it, you can implement the rest of what's necessary in Num in terms of Expr, too
14:23:42 <roconnor> I was reading "Constant" as a functor
14:23:49 <incluye> no i'm not that smart
14:24:08 <c_wraith> (+) = Sum, etc
14:24:18 <roconnor> incluye: you can make smart constructors that do that
14:24:57 <roconnor> or maybe just regular run of the mill functions that do that
14:28:08 * hackagebot scalable-server 0.2.1 - Library for writing fast/scalable TCP-based services  http://hackage.haskell.org/package/scalable-server-0.2.1 (JamieTurner)
14:38:01 <stepcut> Let's say I have module B which re-exports types and functions from module A. Is there some way to get haddock to show the documentation for the re-exported types and functions in the docs for module B?
14:39:11 <stepcut> instead of not-home, I want pretend-home..
14:39:59 <tgeeky_> isn't that not-home on A, and something else on B?
14:40:20 <stepcut> well A really is the home in the this case
14:40:28 <stepcut> but it's a split family, so they have a second home
14:40:55 <stepcut> maybe this should work already, except that the modules are in different packages.
14:42:35 <stepcut> yeah.. that might be my problem
14:42:53 <tgeeky_> if the links are just broken, then that might be the case
14:45:43 <stepcut> the documentation for the re-exported modules is completely missing
14:46:06 <Mitsu> Oh I love trolls.
14:46:06 <Mitsu> <@joosa> how do you say float in java? just 1.5f?
14:46:06 <Mitsu> <@Gliptic> FloatFactoryFactory.getInstance(FloatFactoryFactory.defaultInstanceDescriptionString).getFactory(Locale.getLocale("en-US")).createBuilder().setString("1.5").getResult()
14:46:08 <stepcut> but I am actually looking at the haddock output now and it complains that it could not find .haddock files
14:46:13 <tgeeky_> did you import them qualified or something like that?
14:46:16 <stepcut> so I am fixing that and seeing what happens
14:46:31 <KitB> Mitsu: Brilliant.
14:49:31 <tgeeky_> where else would you get your floats, other than from a float factory?
14:50:28 <Mitsu> you type 1.5f.... lol
14:50:37 <tgeeky_> no, this is enterprise work!
14:50:42 <tgeeky_> things must be made in factories
14:50:45 <tgeeky_> hehe
14:50:54 <c_wraith> what if 1.5 is represented by some other glyphs in the current locale?
14:51:04 <c_wraith> You need to code defensively around situations like that!
14:51:17 <tgeeky_> then you need an InternationalShippingCompany to get floats from their Factories!
14:51:44 <tgeeky_> c_wraith: haskell probably has the most sophisticated numeric representation around
14:51:46 * companion_cube wonders if EmployeeStrike is also produced in a Factory in the java world
14:52:01 <tgeeky_> (ie, in numerals)
14:52:17 <c_wraith> tgeeky_: I did just recommend to someone that he make his Expr class an instance of Num, just so he could use literals with it.
14:52:29 <tgeeky_> yep
14:52:33 <tgeeky_> that and/or REPR
14:52:56 <tgeeky_> it's pretty powerful, though I think there is still another generalization waiting to be done on that front
14:53:09 * hackagebot verilog 0.0.1 - A Verilog parser.  http://hackage.haskell.org/package/verilog-0.0.1 (TomHawkins)
14:56:46 <dufflebunk> How to convert from a CDouble to a Double? fromRational?
14:57:48 <c_wraith> yeah, that's the best way.  (there are rewrite rules to optimize it well)
15:00:08 <mm_freak> does anyone have an idea how to send cookies with http-enumerator?
15:00:45 <dufflebunk> nope, CDouble isn't a Fractional
15:01:09 <rostayob> wow, warp is fast.
15:01:11 <mm_freak> dufflebunk: it is
15:01:29 <mm_freak> dufflebunk: and you convert with realToFrac
15:01:37 <mm_freak> > realToFrac (3 :: CDouble) :: Double
15:01:38 <lambdabot>   Not in scope: type constructor or class `CDouble'
15:01:48 <mm_freak> > realToFrac (3 :: Foreign.C.Types.CDouble) :: Double
15:01:49 <lambdabot>   Not in scope: type constructor or class `Foreign.C.Types.CDouble'
15:01:52 <Draconx> however, realToFrac can lose information.
15:02:41 <mm_freak> only if the target type has a lower precision
15:02:51 <mm_freak> it goes through Rational
15:03:07 <Draconx> Rational cannot represent all possible values of Double or CDouble.
15:03:09 <dufflebunk> mm_freak, you'r right, it is.
15:03:09 <mm_freak> though it might lose information for types, which support irrational numbers like CReal
15:03:43 <mm_freak> Draconx: ah, i see what you mean
15:03:55 <mm_freak> it can't convert NaN
15:04:05 <hpc> @src Double
15:04:05 <lambdabot> data Double = D# Double#
15:04:06 <Draconx> nor negative zeros, nor infinities.
15:04:14 <hpc> @src CDouble
15:04:14 <dufflebunk> I'm not worried about losing a little precision (<1E-8). And I'm not worried about non-numbers
15:04:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:04:47 <mm_freak> Draconx: it does convert infinities
15:04:53 <Draconx> mm_freak, only by accident.
15:05:13 <Draconx> mm_freak, it just happens to convert a double infinity to a rational number that overflows when converted back to double.
15:05:23 <mm_freak> indeed
15:05:32 <Draconx> mm_freak, but this breaks when converting to a type with greater range.
15:05:48 <mm_freak> ok, so i guess the correct way is to convert via RealFloat
15:06:00 <mm_freak> but that's tedious
15:07:28 <mm_freak> ah no, even RealFloat doesn't work
15:08:09 <mm_freak> at least not with decodeFloat alone…  you really need all of isNaN, isInfinite, isThis, isThat, …
15:08:15 <Draconx> if you don't care about preserving the identities of NaNs, it can be done with tedious case analysis...
15:18:09 <sipa> :t decodeFloat
15:18:10 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
15:31:18 <roconnor> isNaN x = x /= x
15:32:46 <dmwit> darcs send -o /dev/null # there must be a better way to tell what patches still haven't been applied upstream
15:34:21 <slack1256> dmwit: still is pretty straightforward.
15:34:26 <roconnor> my livejournal account is now all in dutch
15:34:55 <geheimdienst> dmwit: darcswatch maybe?
15:35:05 <dibblego> is there a Comonad instance for Data.Tree.Zipper.TreeLoc about somewhere?
15:35:10 <fryguybob> > let isNaN = join (/=) in isNaN (0.0 / 0.0)
15:35:11 <lambdabot>   True
15:35:25 <roconnor> as
15:35:29 <roconnor> ah Wijzig taal:
15:35:31 <roconnor> perfect
15:35:40 <dmwit> geheimdienst: I keep forgetting about darcswatch. What a great tool.
15:36:47 <roconnor> dibblego: what would extract return?
15:37:03 <roconnor> dibblego: I don't think it is quite a comonad
15:37:09 <dibblego> the current focus of course
15:37:12 <dibblego> sure it is
15:37:50 <roconnor> ah
15:37:56 <roconnor> a Tree is always non-empty
15:38:03 <dibblego> yeah
15:38:37 <dmwit> Doesn't seem to track gtk2hs, though. =/
15:39:35 <roconnor> dibblego: doesn't even have a Functor instance yet :(
15:39:47 <dibblego> boo
15:44:16 <dmwit> gtk2hs could probably drop 20% in weight just by using c2hs instead of bundling a modified copy
15:48:57 <ddarius> @yow
15:48:58 <lambdabot> Couldn't find fortune file
15:56:19 <kniu> I was thinking
15:56:31 <kniu> to make "imperative" style programming in Haskell more idiomatic
15:56:51 <kniu> why don't we have Num instances for (Num a => IORef a)
15:56:59 <kniu> or similar?
15:57:34 <dibblego> Num?
15:57:45 <kniu> I guess it's kind of a stupid idea
15:57:45 <dibblego> idiomatic?
15:57:54 <kniu> you know
15:58:15 <dibblego> @type liftM2 (+)\
15:58:16 <dibblego> @type liftM2 (+)
15:58:20 <lambdabot> parse error on input `\'
15:58:21 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
15:58:31 <kniu> well
15:58:32 <hpc> kniu: you can't write a pure function of the right type
15:58:51 <hpc> or rather, you can't implement a function of the type it wants (which doesn't contain IO)
15:58:59 <kniu> hm
15:59:19 <acowley> We could parameterize all our base classes by an ambient monad. I'm sure that wouldn't break much existing code!
15:59:22 <kniu> even if we don't use the Num class from prelude?
15:59:34 <ddarius> @hackage BASIC
15:59:34 <lambdabot> http://hackage.haskell.org/package/BASIC
16:00:02 <shachaf> kniu: What would that Num instance do?
16:00:26 * shachaf wonders what sort of function :: IORef Int -> IORef Int -> IORef Int kniu wants.
16:00:33 <kniu> more like
16:00:42 <kniu> IORef Int -> IORef Int -> IO Int
16:00:44 <kniu> or something
16:00:56 <kniu> -> IO (IORef Int)
16:00:57 <kniu> maybe
16:01:13 <PiRSquared17> @type let L = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r) in L L L L L L L L L L L L L L L L L L L L L L L L L L
16:01:14 <lambdabot> Not in scope: data constructor `L'
16:01:14 <lambdabot> Not in scope: data constructor `L'
16:01:14 <lambdabot> Not in scope: data constructor `L'
16:01:22 <shachaf> OK, and what would *that* function do?
16:01:34 <PiRSquared17> Some fixed point combinators, such as this one (constructed by Jan Willem Klop) are useful chiefly for amusement:
16:01:35 <shachaf> Never minding that that's not (+)'s type
16:01:35 <kniu> class Num a m | a -> m where {(+) : a -> a -> m a; ...}
16:01:36 <PiRSquared17> Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L)
16:01:37 <PiRSquared17> where:
16:01:39 <PiRSquared17> L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
16:02:07 <PiRSquared17> @type let L = \a b c d e f g h i j k l m n o p q s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r) in L L L L L L L L L L L L L L L L L L L L L L L L L L
16:02:08 <lambdabot> Not in scope: data constructor `L'
16:02:08 <lambdabot> Not in scope: data constructor `L'
16:02:08 <lambdabot> Not in scope: data constructor `L'
16:02:21 <shachaf> PiRSquared17: You can experiment with this sort of thing in /msg with lambdabot. :-)
16:02:21 <hpc> PiRSquared17: case matters
16:02:37 <hpc> also do it in PM or ghci ;)
16:02:39 <acowley> kniu: the idea has come up on cafe a couple times, I think, but I don't think it got a very enthusiastic response
16:03:02 <kniu> oh
16:03:26 <acowley> I guess the concern is that having all the pure cases parameterized by Identity might lead to some surprisingly deficient defaults
16:03:38 <kniu> deficient defaults?
16:04:08 * shachaf isn't sure what kniu/acowley is talking about.
16:04:17 <acowley> I meant that the extra parameterization might leak into naive uses of things that were meant to be pure
16:04:17 <shachaf> Are you thinking of IO Int -> IO Int -> IO Int?
16:04:22 <shachaf> That's yet another different case.
16:05:12 <kniu> no
16:05:23 <kniu> IORef Int -> IORef Int -> IO (IORef Int)
16:05:44 <kniu> trying to turn Haskell into C++
16:05:45 <shachaf> kniu: And what's that IORef that it returns? Is it a brand new IORef?
16:05:48 <hpc> kniu: that wouldn't be (+)
16:06:02 <kniu> yes, I do realize that that's not (+)
16:06:10 <kniu> a brand new IORef, yes
16:06:13 <kniu> I think
16:06:21 <shachaf> What's the point?
16:06:41 <PiRSquared17> shachaf: maybe it's point-free
16:06:44 <kniu> (+) <$> readIORef x <*> readIORef y
16:06:45 <kniu> versus
16:06:48 <kniu> x + y
16:07:10 <shachaf> liftM2 (+) `on` readIORef
16:07:20 <smoge>  is there a funcion to work with partitioning a integer?
16:07:21 <kniu> :t liftM2 (+) `on` readIORef
16:07:23 <lambdabot> Not in scope: `readIORef'
16:07:26 <smoge> module I mean
16:07:28 <shachaf> This is sounding like a bad idea. You shouldn't use IORefs if you don't actually need them.
16:07:29 <kniu> hm
16:08:18 <Axman6> kniu: why on earth would you want that? o.O
16:09:04 <acowley> Axman6: folks love overloading syntax
16:11:05 <kniu> Axman6, having C as a DSEL in Haskell, for shits and giggles.
16:11:28 <Tekmo> Does Haskell have a way to do database-like programming within Haskell?  By that I mean constructing tuples, doing joins, selections, etc., without relying on an external RDBMS.
16:13:35 <shapr> Tekmo: Yes, HAppS has something like that.
16:13:55 <Tekmo> Actually, I just found something at http://www.haskell.org/haskellwiki/Relational_algebra
16:14:53 <rostayob> @pl \x y -> compare (fst x) (fst y)
16:14:53 <lambdabot> (. fst) . compare . fst
16:15:02 <shachaf> compare `on` fst
16:15:06 <rostayob> oh, comparing
16:15:08 <shachaf> comparing fst
16:15:10 <rostayob> yes
16:26:01 <tswett> Sounds like alwaysSucceeds is not necessarily the best way to do invariants, if you have a lot of them.
16:26:36 <acowley> alwaysSucceeds sounds like a great invariant
16:28:06 <roconnor> return True -- always Succeeds
16:29:27 <acowley> Axiom Certified : forall a, alwaysSucceeds a.
16:31:05 <edwardk> hrmm, i can't seem to find the style of least common ancestor search i'm using in my cursory literature search
16:33:07 <acowley> you mean like with a partial ordering? Some sort of bastardized co-infimum?
16:33:29 <acowley> or do you mean the least-common ancestor in a frequentist sense?
16:33:30 <copumpkin> co-infimum? that's my cousin
16:33:38 <monochrom> hahahaha
16:34:10 <edwardk> i have revisions, revisions have a series of parent revisions, given two revisions when i need to compute a merge, I need their least common ancestor for 3 way merge purposes
16:34:42 <acowley> oh, what about the Wave protocol?
16:35:16 <edwardk> the 'no operational transform thing'?
16:35:55 <edwardk> the merges actually have to exist because this is code doing it, not a human
16:36:08 <edwardk> these are 3 way merge functions the user supplied when he identified versioned variables in his code
16:36:21 <edwardk> anyways by i can't mean to find it, i have one, it works
16:36:28 <edwardk> i just can't seem to find it anywhere in literature
16:36:55 <edwardk> the wikipedia page says O(n) in the height of the tree is the common online case, but I'm online with O(log n) in the height of the tree
16:37:21 <edwardk> but admittedly i need to use a bit of a strange structure
16:37:59 <acowley> edwardk: Yeah, this is what I was thinking of http://www.waveprotocol.org/whitepapers/operational-transform
16:38:20 <acowley> I can't remember the details, but I thought they might have a similar need
16:38:51 <edwardk> their operational transform is a bit nicer to think about with mine because they have endusers as arbiters ;)
16:39:04 <acowley> end users are usually the source of problems
16:39:31 <acowley> edwardk: you've just invented PSBKAC (Problem Solved Between Keyboard and Chair)
16:39:35 <edwardk> well, what i mean is they only ever have to munge text in and tombstone nodes, and if the text looks ugly a human fixes the problems
16:39:42 <edwardk> hah
16:39:42 <monochrom> hahaha
16:40:32 <edwardk> what i'm doing now is basically storing the path to the root for the current node as a skew binary random access list, a node id, and a length of the path
16:40:55 <JoeyA> Error occurred: please correct the following function and click continue: head :: [a] -> a; head (x:_) = x; head [] = error "Prelude.head"
16:41:26 <edwardk> then to check two paths against one another, i trim the random access lists down to the lesser lengths, and then search the random access list spine for where the node ids start agreeing
16:41:46 <acowley> so you can walk the lists in parallel
16:41:49 <edwardk> once i have two agreed upon node ids in the spine, i just walk down the preceding complete tree
16:41:50 <acowley> but you're storing the paths explicitly?
16:42:00 <edwardk> i store the paths explicitly but compressed
16:42:35 <edwardk> but such that consing onto them is still O(1) even though i can walk walk the spine in O(log n)
16:43:14 <edwardk> so when i go to assign the next node id for the child i pull it from my magic globally fresh variable supply, and cons the new id onto the id of my parent
16:43:34 <edwardk> then i use the paths as the ids for LCA comparison purposes later
16:43:58 <edwardk> the actions per node during construction are O(1) and the actions during comparison are O(log n)
16:44:57 <edwardk> there is a similar sparse O(log n) query but O(n log n) preprocessing time algorithm for RMQ/LCA http://community.topcoder.com/tc?module=Static&d1=tutorials&d2=lowestCommonAncestor#Another easy solution in O(N logN, O(logN)       but the preprocessing is a bit worse than O(1) ;)
16:46:50 <edwardk> if i could take the ancestor tree construction off line i could go O(n) preprocess O(1) query time, shaving a log factor, but i think that is the price i pay for a.) purity and b.) online access
16:47:25 <edwardk> i just wish i could find something on this general approach in literature
16:47:31 <edwardk> so i would know whether i should blog it ;)
16:48:54 <slack1256> i want to know more haskell programs. apart from haskell develoment tools (written in haskell), what programs do you use?
16:49:37 <edwardk> vi =)
16:49:39 <slack1256> things like pandoc that i didn't know would do
16:50:04 <zmv> cat :P
16:50:15 <edwardk> grep, grep is also important =)
16:50:41 <slack1256> (written in haskell guys >.> )
16:51:14 <c_wraith> Pretty much all the haskell programs I use that aren't build tools are the things I'm writing.
16:51:29 <mm_freak> slack1256: hakyll
16:51:49 <slack1256> hakyll, is that the static site generator right?
16:51:56 <mm_freak> yes
16:52:07 * stepcut uses xmonad
16:52:44 <slack1256> hakyll should get more publicity.
16:53:02 * stepcut uses lambdabot
16:53:21 <mm_freak> i also use darcs a lot, not only for haskell projects
16:53:36 <stepcut> oh yeah. I forgot about that one :)
16:53:59 <stepcut> not because I don't use darcs pretty much everyday.. I just forgot to think of it as a Haskell app
16:54:41 <mm_freak> other than that pretty much all haskell programs i use are my own
16:56:54 * dylex uses ginsu, which he didn&apos;t write but now maintains.
16:59:31 <Mitsu> I. Hate. Trig.
16:59:48 <Shin-LaC> can anybody find recent performance results for Haskell STM?
17:00:02 <Shin-LaC> I've seen this, but it's from 2006: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/lock-free-flops06.pdf
17:00:22 <copumpkin> Shin-LaC: benchmark it yourself
17:00:31 <copumpkin> benchmarking in haskell is trivial using criterion
17:01:47 <acowley> Mitsu: Trig Palin?
17:01:58 <mm_freak> Shin-LaC: also STM performance depends a lot on the application
17:02:14 <acowley> that's an odd rivalry to have
17:03:00 <Shin-LaC> unfortunately, my problem is not "I need to know how STM would impact my application's performance"
17:03:07 <Shin-LaC> there is no application
17:03:23 <mm_freak> Shin-LaC: i'm using STM a lot
17:03:58 <mm_freak> it's very well production-ready and really isn't far off from non-STM performance
17:04:35 <Shin-LaC> I need to make a small presentation about STM
17:05:06 <acowley> Shin-LaC: study the bank accounts example from SPJ. It has all the ingredients distilled down to a minimal case study.
17:05:18 <mm_freak> i'd recommend to keep performance talk to a minimum and point out that it is production ready, but depends a lot on the application design
17:05:49 <Shin-LaC> acowley: I think I'd like to implement that with locks and compare the performance
17:05:52 <mm_freak> also i think the bank accounts example is a bad example for STM…  nobody writes a bank account software with STM
17:06:20 <shachaf> mm_freak: That doesn't mean it's a bad example to illustrate composability.
17:06:22 <Shin-LaC> this article is very critical of STM: http://delivery.acm.org/10.1145/1460000/1454466/p46-cascaval.pdf?ip=131.193.55.243&acc=OPEN&CFID=68470692&CFTOKEN=53639637&__acm__=1321235909_9947383874608688e38a2268cc9b0fc2
17:06:24 * B|V|eph has no issues with trig, but never took it in a class.
17:06:29 <stepcut> mm_freak: Cobol doesn't have STM ?
17:06:34 <acowley> mm_freak: effectively nobody writes any kind of software. You can rename the "bank accounts" "user lockers" if it makes you happier.
17:06:37 <Shin-LaC> it shows abysmal results with using STM with C
17:07:03 <Shin-LaC> basically it highlights two kinds of problems
17:07:08 <Shin-LaC> 1) performance problems
17:07:11 <Shin-LaC> 2) leaky abstraction
17:07:15 <Shin-LaC> haskell solves 2)
17:07:24 <Shin-LaC> that's why I'd like to talk about haskell, in fact
17:07:40 <mm_freak> unfortunately the bank accounts demo only displays some trivial STM functionality, while not giving credit to what /else/ STM can do
17:07:41 <Shin-LaC> but I'd like to be able to say something about 1)
17:08:03 <Shin-LaC> mm_freak: I need a small example, though
17:08:12 * hackagebot happstack-server 6.3.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.3.1 (JeremyShaw)
17:08:14 * hackagebot happstack-lite 6.0.0 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-6.0.0 (JeremyShaw)
17:08:14 <Shin-LaC> can you suggest a better one that is still small?
17:08:16 * hackagebot happstack-lite 6.0.1 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-6.0.1 (JeremyShaw)
17:08:19 <acowley> Part of the problem with doing a comparison is that part of the point in STM is that you get it right the first time. If you've got an optimally designed implementation using locks, you're unlikely to beat it.
17:08:21 <mm_freak> Shin-LaC: you can use bank accounts to introduce people to the concept of atomicity
17:08:28 <acowley> mm_freak: I disagree
17:08:32 <acowley> mm_freak: it shows off composition
17:08:33 <ddarius> Shin-LaC: The fact that Haskell is pure means the amount of mutable state that needs to be kept track of is minimal and explicit.
17:08:43 <acowley> which is the important step from just having atomicity
17:08:55 <Shin-LaC> ddarius: yes, that's one point I want to raise
17:09:15 <Shin-LaC> acowley: I'm also going to highlight composition
17:09:22 <mm_freak> acowley: composition in the sense of (>>) or (<|>)?
17:09:29 <acowley> mm_freak: >>
17:09:36 <mm_freak> yes, atomicity
17:09:50 <BMeph> Shin-LaC: Would the Santa problem be too trivial? ;)
17:09:54 <mm_freak> IMO one of the real virtues of STM is (<|>)
17:09:56 <acowley> when you just have (withdraw >> deposit), the audience will say that grabbing the locks in a mandated order isn't that hard
17:10:03 <ddarius> mm_freak: Yes.
17:10:09 <Shin-LaC> BMeph: the Santa problem is nice too!
17:10:16 <acowley> but when you add nesting of transactional actions, you can run into issues
17:10:30 <mm_freak> if you don't present (<|>) (aka 'orElse') you've effectively hidden 90% of STM's usefulness
17:10:50 <mm_freak> just my opinion
17:10:52 <acowley> STM Hyperbole
17:11:01 <Shin-LaC> I guess I could do the santa example, which shows orelse too
17:11:14 <Shin-LaC> it's much larger than the bank account example, though
17:12:00 <ddarius> I would definitely have an example that demonstrates orElse, even if I think 90% is a bit high.
17:12:03 <acowley> Shin-LaC: code that branches within an atomic block can also make manual lock management a pain, and inefficient
17:12:34 <mm_freak> you don't need overly complicated examples to demonstrate orElse
17:13:30 <mm_freak> here is a very simple application of it:  (Nothing <$ (readTVar quitVar >>= check)) <|> (Just <$> readTMVar nextMessage)
17:14:01 <Shin-LaC> I should probably mention that I'm a beginner with Haskell
17:14:12 <ddarius> orElse gives you select.
17:14:13 <Shin-LaC> I'm kind of picking it up for the purpose of this presentation
17:14:41 <mm_freak> Shin-LaC: you have a concurrent thread, which handles messages/events sent from other threads…  different kinds of events
17:14:58 <mm_freak> Shin-LaC: in my example there is one variable for quitting and another for the next message
17:15:31 <Shin-LaC> I'll hoogle the various parts
17:16:00 <acowley> Shin-LaC: paste it into a file and write supporting code until it works :)
17:16:14 <acowley> Shin-LaC: it's a really neat example and doesn't take much infrastructure
17:16:30 <mm_freak> despite its simplicity it's extraordinarily complicated to implement without STM in general…  you basically end up having either multiple listener threads or a giant data type for all the various messages
17:16:30 <Shin-LaC> acowley: you mean mm_freak's example?
17:16:30 --- mode: ChanServ set +o copumpkin
17:16:30 <acowley> Shin-LaC: Yeah
17:16:37 --- mode: copumpkin set +b *!~stenobot2@c-76-17-84-218.hsd1.ga.comcast.net
17:16:40 --- mode: copumpkin set -o copumpkin
17:16:52 <Shin-LaC> ok
17:17:16 <ddarius> mm_freak: It's actually impossible to implement with only local changes, but with a built-in 'select' function, it would be trivial.
17:18:13 <mm_freak> ddarius: then you have STM builtin…  note that the first transaction can fail by predicate, and 'select' needs to remember which variable was used
17:18:25 <mm_freak> that 'select' would just be 'atomically'
17:19:08 <ddarius> mm_freak: You might need a fancier select a la the things in CML, but CML is certainly not STM.
17:19:17 <Shin-LaC> hum, I don't understand <$
17:19:33 <mm_freak> Shin-LaC: fmap . const
17:19:33 <ddarius> (<*) = fmap . const
17:19:39 <ddarius> (This was probably not too helpful.)
17:19:49 <mm_freak> > 5 <$ Just 3
17:19:50 <lambdabot>   Just 5
17:20:00 <mm_freak> > fmap (const 5) (Just 3)
17:20:01 <lambdabot>   Just 5
17:20:08 <PiRSquared17> @type (<*)
17:20:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:20:28 <Shin-LaC> ooh, I get it
17:20:31 <mm_freak> (<*) is not the same as (<$)
17:20:44 <mm_freak> > Just 3 <* Just 5
17:20:45 <lambdabot>   Just 3
17:20:55 <PiRSquared17> @type (<$)
17:20:56 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
17:20:59 <mm_freak> performs the effects of both from left to right, but results in the left
17:21:07 <mm_freak> > Just 3 <* Nothing
17:21:08 <lambdabot>   Nothing
17:21:47 <RaptorRarr> > Just ice
17:21:53 <lambdabot>   Just ice
17:22:04 <PiRSquared17> @type ice
17:22:05 <lambdabot> Doc
17:22:29 <RaptorRarr> > text "ice"
17:22:30 <lambdabot>   ice
17:22:31 <Shin-LaC> > Nothing <$ Just 5
17:22:32 <lambdabot>   Just Nothing
17:22:51 <rostayob> what's a nice way to test programs that rely on weak pointers?
17:22:55 <mm_freak> Shin-LaC: the value to the left of <$ is pure
17:22:56 <rostayob> not really a haskell question
17:23:06 <RaptorRarr> rostayob: Test what about them?
17:23:30 <jimots> I'd like to use GHC to generate a portable executable.
17:23:39 <jimots> I can use the LLVM backend and get some .ll files
17:23:45 <rostayob> RaptorRarr: well I want to know how the application performs when the memory fills up
17:24:05 <ddarius> rostayob: You can set the maximum heap size.
17:24:09 <jimots> but I'm not sure how to link them to make portable llvm-interpretable portable files
17:24:14 <rostayob> ddarius: right, thansk.
17:24:15 <jimots> or if that is even possible
17:24:15 <rostayob> *thanks
17:24:35 <RaptorRarr> Points to some thanks.
17:24:37 <RaptorRarr> In C.
17:24:49 <RaptorRarr> Weakly, like joke.
17:27:24 <jimots> Alternately, I could redistribute code generated using -via-C
17:27:25 <rostayob> wait, what I'm looking for is a soft pointer
17:27:27 <rostayob> not a weak one
17:27:35 <Shin-LaC> ok, hoogle for <|> says "An associative binary operation"
17:27:36 <rostayob> one that gets garbage collected on memory demands
17:27:46 <Shin-LaC> that's not very helpful to me
17:28:04 <simon> I'm implementing this algorithm for determining the nicest-looking margin for monospace within a boundary (e.g. [72;78] characters).
17:28:10 <jimots> but I'm not sure how portable that is - I noted it #includes a file with a name like "Stg.h"
17:28:35 <solidsnack> jimots: I wonder if .ll files from GHC would really be portable. The code would have calls to different functions for async IO, for examples, on different platforms.
17:28:51 <jimots> I thought about compiling to Java bytecode (maybe using Frege)
17:28:55 <simon> so far I've just done the bruteforce approach, but I'd like to add memoization, and I thought it'd be neat to store a table within a monad. is this generally a good way to write memoized algorithms?
17:28:57 <jimots> solidsnack: good point
17:29:13 <c_wraith> Shin-LaC: the full documentation for the Alternative type class might be more useful to you.  did you try clicking on the docs link from hoogle?
17:29:16 <mm_freak> Shin-LaC: (<|>) is from the Alternative type class…  the description you have read is the best one can give
17:29:54 <mm_freak> because (<|>) is really just a monoidic associative binary composition operation…  the case of STM it's the same as orElse
17:30:07 <Shin-LaC> c_wraith: I don't see a docs link
17:30:09 <solidsnack> simon: This doesn't really sound like memoization.
17:30:14 <acowley`> simon: sure, or you could do it purely by defining the full memoization table up-front and letting laziness fill it in as needed.
17:30:18 <mm_freak> in other functors it may have very different meanings
17:30:28 <solidsnack> simon: What acowley` said.
17:30:39 <Shin-LaC> mm_freak: I see
17:30:48 <jimots> I suppose I could port my code to F# and distribute compiled bytecode for CLI
17:30:56 <mm_freak> Shin-LaC: (<|>) usually implements some form of choice/selection
17:31:12 <mm_freak> Shin-LaC: for example in Maybe it selects the first Just-value
17:31:16 <mm_freak> > Just 3 <|> Just 4
17:31:17 <lambdabot>   Just 3
17:31:21 <mm_freak> > Nothing <|> Just 4
17:31:22 <lambdabot>   Just 4
17:31:36 <mm_freak> in STM it selects the first successful transaction
17:31:44 <simon> > [1,2,3] <|> [4,5,6]
17:31:45 <c_wraith> Shin-LaC: the green words under the search results are documentation links.  Though it turns out Alternative is not especially well-documented.
17:31:46 <lambdabot>   [1,2,3,4,5,6]
17:32:17 <solidsnack> jimots: You could cross-compile, put each file in a compressed tarball with the platform name, then cat the tarball to the end of a shell script that calls tar on $0 to get the platform specific binary.
17:32:46 <solidsnack> This would be a "fat UNIX binary", haha.
17:32:49 <Shin-LaC> ah, thanks
17:32:49 <jimots> solidsnack: I could. I haven't cross compiled on ghc before. have you?
17:32:58 <simon> solidsnack, memoization in the sense that the score of a partial result might be so bad that the score of a complete result beats it, so I can throw it away early.
17:32:59 <solidsnack> jimots: I think it is impossible, actually.
17:33:13 <solidsnack> simon: I see.
17:33:23 <solidsnack> jimots: Have to run VMs, maybe.
17:34:01 <solidsnack> It's too bad really; but on the other hand, it's something great about Haskell that compiles to native code.
17:34:05 <simon> solidsnack, I recall from algorithms lectures that this is a linear programming problem, but being somewhat lazy, I'm just going to solve it with what I remember from dynamic programming. :)
17:34:12 <Shin-LaC> mm_freak: so the first part takes the read on the quit variable and makes an STM action that does the read as a side effect, but returns Nothing?
17:34:21 <simon> s/lazy/incompetent/
17:34:40 <rostayob> mhm it seems that haskell has no soft pointers :(
17:35:19 <simon> rostayob, I cut myself on a -> once, so now I'm wearing gloves.
17:35:53 <rostayob> simon: on an arrow type?
17:36:24 <rostayob> no but really, they would be useful
17:36:54 <aavogt> rostayob: perhaps lazy IO (ie. unsafeInterleaveIO) has the same effect
17:37:03 <Eduard_Munteanu> simon: maybe you need to polish it to a nice →   :)
17:37:25 <rostayob> aavogt: how would that be?
17:38:38 <rostayob> if there are no soft pointers, is there another way to have something GC'ed when we run out of memory?
17:40:15 <ski> rostayob : "soft pointers" ?
17:40:42 <rostayob> ski: like Weak pointers, but with no key, just a value that gets GCed when the memory is filling up
17:40:49 <rostayob> http://download.oracle.com/javase/1.4.2/docs/api/java/lang/ref/SoftReference.html
17:40:54 <rostayob> because JAVA ROCKS
17:41:08 <Shin-LaC> mm_freak: ok, I understood it
17:41:11 <Shin-LaC> with some help
17:41:18 <Shin-LaC> well, lots of help
17:41:19 <zmv> rostayob: lol
17:41:29 <rostayob> :)
17:41:36 <aavogt> that seems to be different from the definition here http://answers.yahoo.com/question/index?qid=20070901020554AA7lQuo
17:42:25 <Eduard_Munteanu> That sounds a bit like Linux's transcendent memory.
17:42:44 <rostayob> aavogt: yeah i didn't mean that, i meant soft pointer as in java soft reference
17:42:55 <Eduard_Munteanu> Some storage space, which may or may not be there in the future.
17:43:22 <aavogt> where that definition would seem to happen if your allocation and assignments IO happened lazily (when the resulting value is forced)
17:43:57 <rostayob> aavogt: yeah i get what you meant now
17:45:04 <aavogt> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-Weak.html
17:45:24 <rostayob> aavogt: that has different semantics
17:45:30 <monochrom> rostayob: I'm wondering if mkWeakPtr :: k -> Maybe (IO ()) -> IO (Weak k)  accomplishes what you want
17:45:48 <rostayob> monochrom: yes I was wondering the same
17:45:54 <rostayob> but even if
17:46:00 <rostayob> it would be GC'ed soon
17:46:04 <rostayob> which I don't want
17:46:30 <monochrom> you are sure of that?
17:46:55 <rostayob> well yes, after the key dies the value dies as well to the GC
17:46:55 <dmwit> !!!
17:47:07 <dmwit> :i Num
17:47:10 <dmwit> class Num a where
17:47:35 <monochrom> have you tested that?
17:48:00 <rostayob> monochrom: well that's not easy to test. but I have no reason to believe otherwise reading that page
17:48:19 <rostayob> unless there is a way to force garbage collection
17:48:22 <rostayob> but i don't think so
17:50:38 <mm_freak> Shin-LaC: another useful pattern is:  join . atomically
17:51:27 <mm_freak> there the first successful transaction decides how to proceed
17:52:14 <mauke> oh, it's predereferenced
17:53:12 <Shin-LaC> mauke: what is?
17:53:29 <rostayob> mah, I think I'll go to bed. If only Haskell could have all Java's marvelous features
17:53:33 <mauke> the join . atomically thing
17:53:49 <rostayob> too bad I have to write Haskell at work
17:53:50 <Shin-LaC> I don't understand it either
17:54:03 <Shin-LaC> join discards repeated applications of the same monad?
17:54:13 <mauke> instead of giving you some value you can use to determine what to do next, it gives you the next action directly
17:54:20 <mauke> ... and also executes it in the same transaction
17:54:29 <dmwit> no
17:54:39 <dmwit> It executes it after the transaction has completed.
17:54:41 <mm_freak> mauke: not in the transaction
17:54:51 <mauke> oh, right
17:55:07 <mauke> not atomically . join
17:55:30 <ezyang> Yo #haskell. Are >=> and <=< the only real fish operators?
17:55:54 <c_wraith> what other types would fish have?
17:56:01 <mm_freak> ezyang: =>> (comonad), >==> (enumerator)
17:56:10 <ezyang> I want to call =<< and >>= fish operators too.
17:56:28 <hpc> U+2fc2 (12226): KANGXI RADICAL FISH [⿂]
17:56:31 <ezyang> But I coudl see people yelling at me for bieng inaccurate...
17:56:32 <monochrom> squid operators
17:57:14 <mm_freak> (-=>) and (>=-) from yampa/animas/netwire
17:57:35 <ezyang> fireworks!
17:57:41 <Shin-LaC> give me an example of how you would use join . atomically
17:57:41 <kfish> (><>) and (<><) from iteratee
17:57:46 <mm_freak> (>>^), (^>>), (<<^), (^<<), all sorts of bizarre fish
17:57:54 <Nisstyre> ezyang: redefine them as :) and :(
17:58:05 <Shin-LaC> I hope there is no (^_^)
17:58:27 <monochrom> (^_^) is a syntax error, don't worry. ^_^
17:58:28 <c_wraith> Shin-LaC: nope.  _ is an identifier character, but ^ is an operator character.
17:58:39 <c_wraith> hmm
17:58:45 <ezyang> With Unicode, the operator opportunities are endless.
17:58:51 <mauke> ^.^
17:58:53 <mm_freak> Shin-LaC: (myQuitAction <$ (readTVar quitVar >>= check)) <|> (myHandler <$> readTMVar msgVar)
17:59:00 <monochrom> yes, ^.^ will work!
17:59:03 <mm_freak> myQuitAction :: IO X
17:59:09 <mm_freak> myHandler :: Message -> IO X
17:59:12 <Nisstyre> you could use some unicode characters
17:59:31 <mm_freak> join . atomically $ thatTransactionAbove
17:59:51 <ski> @type join . GHC.Conc.atomically
17:59:52 <lambdabot> forall a. GHC.Conc.STM (IO a) -> IO a
18:00:14 <Mitsu> lol trying to learn haskell from knowing as3 java and C#
18:00:17 <Mitsu> such a pain
18:00:28 <Nisstyre> Mitsu: I came from only knowing python
18:00:32 <mm_freak> Mitsu: actually C# might help to some extent
18:00:40 <monochrom> @quote monochrom unlearn
18:00:40 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
18:00:44 <Mitsu> lol I tried python before, didn't like it
18:00:54 <Nisstyre> Mitsu: it can be silly sometimes yes
18:01:03 <Nisstyre> like the ridiculous aversion to reduce
18:01:04 <mm_freak> also AS3 might help, because at least it uses some functional stuff
18:01:17 <Nisstyre> they removed reduce from the main language in 3.x
18:01:32 <mm_freak> Nisstyre: so they finally did?
18:01:37 <Nisstyre> mm_freak: yes, in 3.x
18:01:42 <mm_freak> ok, then python is dead to me
18:01:46 <Nisstyre> it's in functional module now
18:02:00 <mm_freak> ah, so it'S still in the main distribution?
18:02:02 <Nisstyre> yeah
18:02:02 <Mitsu> the only thing I really ever used python for was various xchat scripts
18:02:03 <Mitsu> lol
18:02:14 <mm_freak> ok, then i'm fine =)
18:02:17 <Nisstyre> mm_freak: it needs unfoldr though
18:02:19 <Shin-LaC> mm_freak so… join . atomically strips one level of atomically, and the <|> gives you atomically myQuitAction or atomically myhandler, so the result is myQuitAction or myHandler? wait, no, that can't be right
18:02:41 <mm_freak> Nisstyre: it needs so much more to appeal to me…  starting with a real type system
18:02:53 <Nisstyre> mm_freak: you would probably like ruby more
18:02:59 <Nisstyre> since it has stuff to offer, like anonymous blocks
18:03:05 <mm_freak> (in my world type systems start to be "real" when they're static)
18:03:15 <mauke> Shin-LaC: myQuitAction yes, myHandle is actually a function that returns the action to take (given a message)
18:03:16 <Nisstyre> mm_freak: python is at least strongly typed
18:03:33 <mm_freak> i still need to run the program to find the type errors
18:03:46 <mauke> mm_freak: and typos :-)
18:03:49 <Nisstyre> well, I read that GVR regrets making python dynamic
18:03:56 <mm_freak> yeah
18:04:09 <Shin-LaC> mauke: ah, so the reuslt from <|> would be "atomically myQuitAction" and "atomically atomically whateverMyHandleReturns"?
18:04:26 <Shin-LaC> and the join give you "atomically myQuitAction" or "atomically whateverMYHandleRetursn"?
18:04:26 <mm_freak> python would actually be a fine language, if its type system were static
18:04:54 <mm_freak> Shin-LaC: no, read the type signature
18:05:00 <mm_freak> STM (IO a)
18:05:10 <mm_freak> it's a transaction, which results in an IO action
18:05:15 <mm_freak> it's just its result
18:05:20 <mauke> Shin-LaC: no, there's no 'atomically' in myHandler
18:05:22 <mm_freak> join :: IO (IO a) -> IO a
18:05:32 <mauke> not all IOs are made from STM
18:05:39 <mm_freak> that one takes the result from the transaction and embeds it into the current action
18:05:56 <mm_freak> so:  the transaction decides what IO action to run
18:06:02 <mm_freak> and join then runs it /after/ the transaction
18:06:43 <mauke> let me tell you a tale of 'join'
18:06:55 <mauke> well, not really join, it's about IO (IO a)
18:07:03 <mm_freak> atomically:  STM (IO a) -> IO (IO a)
18:07:09 <mm_freak> join:  IO (IO a) -> IO a
18:07:15 <Shin-LaC> aah
18:07:21 <mauke> one time I wanted to replicate a C API in Haskell
18:07:21 <Shin-LaC> mm_freak: I see!
18:07:43 <mauke> it had functions to register/unregister functions for events
18:08:03 <mauke> well, register :: (Event -> IO ()) -> IO () is easy
18:08:04 <Shin-LaC> mm_freak: but what would be the problem with not using join?
18:08:14 <Shin-LaC> oh wait
18:08:19 <mm_freak> Shin-LaC: then you would just have a value of type IO a
18:08:24 <mauke> but unregistering is impossible. the C API simply compared function pointers
18:08:27 <Shin-LaC> I see
18:08:51 <mauke> so I thought about making register return a magic cookie that could be passed to unregister
18:09:11 <mauke> register :: (Event -> IO ()) -> IO HandlerID
18:09:13 <mm_freak> Shin-LaC: 'join' basically does this:  join cc = do c <- cc; c
18:09:19 <mauke> unregister :: HandlerID -> IO ()
18:09:44 <mauke> but then I noticed that all you can do with a HandlerID is passing it to unregister
18:10:12 <mauke> so I "predereferenced" it, turning register into (Event -> IO ()) -> IO (IO ())
18:10:25 <mauke> so register effectively returns the unregister action
18:10:29 <dmwit> ...and then you lost all C customers.
18:10:45 <dmwit> Which didn't bother you at all, I'm sure.
18:11:00 <mauke> and then I never actually wrote the code
18:11:24 <sal23> how do you convert byte to signed int? this one gives me 250 instead of -6:
18:11:28 <sal23> >  (Prelude.fromIntegral $ Data.ByteString.head $ Data.ByteString.pack [0xfa]) :: Data.Int.Int32
18:11:29 <lambdabot>   Not in scope: `Data.ByteString.head'Not in scope: `Data.ByteString.pack'
18:11:49 <mm_freak> mauke: withHandler :: (Event -> IO ()) -> IO a -> IO a
18:11:51 <mauke> but register f = do { x <- registerOld f; return (unregisterOld x) } is neat
18:12:01 <mauke> mm_freak: no, bad
18:12:32 <mm_freak> sal23: select Int to be the target type
18:12:51 <mm_freak> > fromIntegral (250 :: Word8) :: Int
18:12:51 <sal23> mm_freak, same output
18:12:52 <lambdabot>   250
18:13:08 <rwbarton> > fromIntegral (fromIntegral (250 :: Word8) :: Int8) :: Int
18:13:09 <lambdabot>   -6
18:13:11 <mm_freak> or do you want to turn it into a signed byte first?
18:13:22 <mauke> > 250 ::Int8
18:13:23 <lambdabot>   -6
18:13:24 <sal23> signed byte first
18:13:31 <mm_freak> mauke: why?
18:13:48 <mauke> mm_freak: because that automatically unregisters your handlers
18:13:59 <mm_freak> yeah, that's the idea
18:14:03 <mauke> bad idea
18:14:25 <mm_freak> withHandlerPool :: (Pool -> IO a) -> IO a
18:14:30 <mm_freak> better?
18:14:34 <mauke> what's that?
18:14:48 <mm_freak> register :: Pool -> (Event -> IO ()) -> IO ()
18:14:57 <mm_freak> a region for event handlers
18:15:04 <mauke> oh, yeah
18:15:22 <mm_freak> or, well, use FRP =)
18:15:31 <mauke> I don't know FRP
18:15:41 <mauke> does it actually work now?
18:16:05 <mm_freak> mauke: i have just released netwire 2.0.0 yesterday, which i use in production
18:16:14 <mm_freak> also Cale is using FRP in production
18:16:20 <mm_freak> we both use AFRP btw
18:17:27 <mauke> where can I read more?
18:17:53 <mm_freak> here is a demo:  http://hpaste.org/54025
18:18:02 <sal23> mm_freak, Int8 did the trick. thanks for help
18:18:32 <mm_freak> here is the -cafe ANN: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/93860
18:21:08 <mm_freak> mauke: and AFRP in its most basic form is simply the automaton arrow
18:21:26 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
18:21:53 <mauke> what's an arrow?
18:22:11 <RaptorRarr> It's a pointer.
18:22:18 <mm_freak> mauke: Control.Arrow?
18:22:31 <dmwit> Arrows are generalizations of functions.
18:22:46 <dmwit> Where monads embody side-effecting values, arrows embody side-effecting functions.
18:22:53 <mm_freak> mauke: it's a composition interface, which is between applicative functors and monads
18:23:20 <mm_freak> less powerful than monads, but can express more control concepts (the automaton arrow is not a monad)
18:30:55 <mm_freak> mauke: i'm slightly surprised that you haven't heard of them yet
18:31:19 <mm_freak> there is even a complicated syntactic extension in GHC for them (-XArrows)
18:32:09 <mm_freak> i'm using arrows for a long time now and i'm still not sure whether i've fully understood arrow notation =)
18:32:47 <bfig> @pf
18:32:47 <lambdabot> Maybe you meant: bf pl
18:33:06 <bfig> @pl \f g x -> f(g x) x
18:33:06 <lambdabot> flip flip id . liftM2
18:35:30 <dmwit> Wikipedia is an amazing math reference work, provided you already know everything there is to know about math.
18:36:30 <dmwit> mm_freak: One of the things on my todo list is to read Wadler's "New Notation for Arrows" paper again and see if that helps me make sense of GHC's syntax.
18:36:51 <dmwit> err
18:36:59 <dmwit> s/New Notation for Arrows/The Arrow Calculus/
18:39:32 <mm_freak> dmwit: if you want to understand arrow notation, better read the GHC manual (section 7)
18:39:45 <mm_freak> some subsection of that that is
18:40:43 <dmwit> I once suggested that somebody should write a quasiquoter for Wadler's syntax, and the person who I suggested it to scoffed and said that's what GHC's syntax already was.
18:44:03 <mm_freak> GHC's syntax is slightly different
18:44:20 <mm_freak> that's why you should read the manual instead of the paper
18:48:50 <mike-burns> How very practical.
18:58:14 * hackagebot network-bitcoin 0.1.2 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.2 (MichaelHendricks)
19:03:14 * hackagebot happstack 6.0.4 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.4 (JeremyShaw)
19:08:16 * hackagebot happstack-hsp 6.2.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.2 (JeremyShaw)
19:08:18 * hackagebot happstack-heist 6.0.4 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.4 (JeremyShaw)
19:08:20 * hackagebot happstack-hamlet 6.2.1 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.2.1 (JeremyShaw)
19:08:22 * hackagebot happstack-plugins 6.1.1 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.1.1 (JeremyShaw)
19:08:24 * hackagebot happstack-hstringtemplate 6.0.2 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.2 (JeremyShaw)
19:17:50 <mysticc> @hoogle warpDebug
19:17:50 <lambdabot> No results found
19:22:21 <Guest99347> hello all, I could use some help with a problem I have for class. I have to write a function using map to generate the even numbers up to n
19:22:38 <Axman6> just using map?
19:22:45 <Guest99347> yes
19:22:53 <Axman6> what inputs and outputs do you expect for your function?
19:22:55 <shapr> Guest99347: Have you used map before?
19:23:08 <Guest99347> no i have not
19:23:17 <Axman6> > map (+1) [1..10]
19:23:18 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:23:25 <Axman6> > map (^4) [1..10]
19:23:27 <lambdabot>   [1,16,81,256,625,1296,2401,4096,6561,10000]
19:23:36 <Guest99347> although i got the results that I wanted using list comprehensions
19:24:11 <Guest99347> even1 n = {x|x<- [2..n], even x]
19:24:27 <Axman6> well, you can't do that with map easily
19:24:30 <c_wraith> oh.  that's filter, rather than map
19:24:31 <Guest99347> im having trouble creating  a function using map
19:24:35 <Mitsu> > [ x*2 | x <- [1..10]]
19:24:36 <c_wraith> > filter even [2..]
19:24:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:24:37 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:24:44 <Axman6> but... you could use map if you produce the numbers up tp n/2
19:24:47 <Axman6> to*
19:25:13 <Axman6> > let f n = map (*2) [1..n `div` 2]
19:25:14 <lambdabot>   not an expression: `let f n = map (*2) [1..n `div` 2]'
19:25:18 <Axman6> > let f n = map (*2) [1..n `div` 2] in f 10
19:25:19 <lambdabot>   [2,4,6,8,10]
19:25:32 <Guest99347> ahh
19:25:42 <Axman6> there are other ways to do that
19:26:09 <Axman6> > let f n = map id [2,4..n] in f 10 -- >_>
19:26:09 <Nisstyre> taking advantage of the fact that if you multiply a number by 2 it will always be even right?
19:26:10 <lambdabot>   [2,4,6,8,10]
19:26:18 <Guest99347> yea
19:26:56 <Guest99347> thank you i appreciate it!
19:27:59 <shachaf> > (\n -> [2,4..n]) 20
19:28:00 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:28:08 <shachaf> I guess someone just said that.
19:28:35 <djanatyn> is there a name for an empty tuple type?
19:28:45 <shapr> unit?
19:28:47 <djanatyn> is it called nil or something? or do people just call it "empty tuple type"?
19:28:55 <djanatyn> Hmm, maybe that's what it's called
19:28:58 <byorgey> djanatyn: it is usually called "unit" or "the unit type"
19:29:00 <djanatyn> > :t ()
19:29:01 <lambdabot>   <no location info>: parse error on input `:'
19:29:10 <byorgey> :t ()
19:29:11 <lambdabot> ()
19:29:11 <djanatyn> ah, okay, cool
19:29:34 <djanatyn> thanks. empty tuples are kind of mysterious!
19:29:43 <haldean> :i ()
19:29:51 <haldean> Doesn't work with lambdabot, I guess
19:30:02 <byorgey> djanatyn: what is mysterious about it?
19:30:06 <haldean> In GHCI it says it's defined in GHC.Unit, which provides futher evidence
19:30:07 <djanatyn> I know that they get used for IO a lot, when you just want to return an indication that you made a side-effect happen or something
19:30:11 <byorgey> () is a type with one value, ()
19:30:16 <djanatyn> byorgey: well, it's just kind of...there.
19:30:24 <byorgey> hence a value of type () is like a value with no information
19:30:39 <djanatyn> I dunno. It reminds me a lot of nil in lisp
19:30:45 <shachaf> djanatyn: If you want, you can use data Unit = Unit
19:30:47 <djanatyn> except empty lists are of type [a]
19:30:58 <shachaf> "nil" in Common Lisp does a lot of things.
19:31:01 <byorgey> djanatyn: well, lisp uses nil for many purposes
19:31:03 <djanatyn> Yeah.
19:31:10 <djanatyn> so, this is just for...nothingness? :)
19:31:10 <byorgey> djanatyn: one of which is the same as () in Haskell.
19:31:25 <djanatyn> Cool, yeah.
19:31:33 <shachaf> djanatyn: It's a little bit like "void" in C.
19:31:40 * shachaf isn't sure whether that's a good analogy, though.
19:32:58 <mike-burns> It's used similarly, usually.
19:33:31 <dylex> :t void
19:33:32 <lambdabot> Not in scope: `void'
19:33:34 <shachaf> You can't have a variable of type void, though, or pass it as an argument to a function.
19:33:41 <shachaf> Also, "Void" in Haskell is a very different type. :-)
19:33:55 <dylex> :t Control.Monad.void
19:33:56 <lambdabot> Not in scope: `Control.Monad.void'
19:34:18 <dylex> @hoogle void
19:34:18 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
19:34:18 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
19:34:19 <lambdabot> package void
19:35:07 <mike-burns> Is the `void' function useful?
19:35:38 <dylex> mike-burns: It's just like a (void) cast in C: I really don't care about this (usually IO monad) result
19:36:10 <mike-burns> Oh, yeah; if you have a function that produces IO (), and you have some IO a. Fair enough.
19:36:27 <mike-burns> Er, you know what I mean.
19:36:40 <mike-burns> 'Cause I know what you mean.
19:36:42 * Axman6 is so glad to see some serious thought being put into SIMD in GHC
20:09:51 <Guest53994> hi, I am new to Haskell and was wondering if someone could help me with a question?
20:11:04 <Guest53994> I need to write the functions second and third that when applied to a list will return the second and third elements of the lsit using pattern matching
20:11:31 <Guest53994> so that second [5,6,7,8] returns 6
20:11:43 <mike-burns> Can you write the function `first', analogously?
20:11:56 <brence> in Data.List, splitAt is defined as splitAt n xs =  (take n xs, drop n xs). This definition traverses the list twice, why have such an implementation in a built-in library ?!
20:12:11 <ddarius> brence: That definition is better than you think.
20:12:31 <brence> ddarius: how?
20:12:37 <Guest53994> I know how to using the prelude but not so much writing my own function
20:12:39 <ddarius> Also, Data.List is not a "built-in" library.  It wasn't even a standard library until very recently.
20:13:25 <mike-burns> Guest53994: What should these functions do on the empty list?
20:13:43 <mike-burns> Also, do you know how to use pattern matching?
20:13:52 <Guest53994> return an empty list i suppose
20:13:59 <brence> ddarius: but still the "take" and "drop" functions each has to traverse the list separately
20:14:09 <Guest53994> we just went over it in class today, but im still a little iffy on it
20:14:47 <dibblego> this is not a nice function to give to a noob as an exercise
20:14:58 <Guest53994> haha,
20:14:59 <mike-burns> Agreed.
20:15:02 <ddarius> Define splitAt that doesn't traverse the list twice.
20:15:15 <Guest53994> well i'd appreciate any help
20:15:43 <dmwit> brence: The specification uses take and drop; the implementation does not.
20:16:12 <mike-burns> Guest53994: http://hpaste.org/54045 - this is an example of pattern matching using the (:) constructor.
20:16:46 <dmwit> brence: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#splitAt <- see the #else /* hack away */ section
20:16:49 <brence> dmwit: http://goo.gl/s5QPM
20:17:12 <dibblego> splitAt :: Int -> [a] -> ListZipper a
20:17:22 <Guest53994> so that adds takes x and adds it to the sum of the xs?
20:17:22 <dmwit> brence: As I mentioned: see the #else /* hack away */ section.
20:18:45 <dibblego> Guest2917: you cannot return an empty list given the empty list if you wish to return a integer given [5, 6, 7, 8]
20:18:50 <mike-burns> Guest53994: The first line matches on the empty list, []. It defines the value there to be 0.
20:19:13 <Guest53994> right
20:19:16 <brence> dmwit: I can't relate the hack-away section to the splitAt function
20:19:17 <ddarius> dibblego: instance Num [()] where fromInteger = flip genericReplicate ()
20:19:24 <dmwit> dibblego: Bah. This is obviously not supposed to be a total function. Just tell him the distinction and help him move on with his life.
20:19:30 <ddarius> brence: Read harder.  Also, answer my question.
20:19:48 <dmwit> brence: Read farther.
20:19:53 <mike-burns> dmwit: It's a homework question. Do we give answers away in here now? I thought everyone but me was in academia.
20:19:57 <dmwit> brence: If you haven't reached #endif, you haven't read far enough yet.
20:20:17 <dmwit> I never suggested that we give him the answer.
20:20:24 <Guest53994> i want to understand it not be given the answer
20:20:32 <mike-burns> Guest53994: The second part, (x:xs) splits the list into the head, x, and the tail, xs. This is because (:) is the list constructor, like: 1:[2,3] will construct the list [1,2,3].
20:20:42 <mike-burns> Likewise, 1:2:[3] will construct [1,2,3].
20:20:43 <dmwit> Guest53994: There's a value, "undefined", which has any type. You can use it for functions which are obviously supposed to error out in certain cases.
20:20:54 <dmwit> Guest53994: It's not recommended in production code, that's all.
20:21:07 <Guest53994> got it
20:21:20 <Mitsu> well now I finally know what (x:xs) means.
20:21:21 <Mitsu> :3
20:21:36 * ddarius is pretty sure the majority of the people here are not in "academia" even if you count undergraduates as academics.
20:22:01 <Mitsu> what?
20:22:05 <dolio> You shouldn't need undefined to write these second and third functions.
20:22:07 <companion_cube> academics is postgraduate ?
20:22:19 <brence> dmwit,ddarius: ok I got it now thanks
20:22:32 <dmwit> dolio: Uh, I think second :: [a] -> a, a pretty dangerous type. Not 100% sure of that, though, I suppose.
20:22:39 <dmwit> ?quote sprynge
20:22:39 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
20:22:46 <brence> dmwit: what does the #ifdef USE_REPORT_PRELUDE pragma do?
20:22:47 <mike-burns> I'm not sure what else to say, Guest53994 .
20:22:49 <dolio> dmwit: How dangerous it is is irrelevant.
20:23:07 <dolio> I don't need undefined to write fromJust.
20:23:08 <ddarius> brence: It's a CPP statement.
20:23:09 <mike-burns> I'd prefer second :: [a] -> Maybe a .
20:23:12 <Guest53994> no, this is good. thank you! i can figure it from here
20:23:14 <shachaf> ddarius: "in academia" naturally means "have academic interests", and Haskell is obviously a pure academic interest.
20:23:18 <dmwit> dolio: Relying on an incomplete pattern match is just hiding the undefined.
20:23:45 <dolio> Relying on an incomplete pattern match doesn't require knowing about undefined.
20:23:51 <dmwit> brence: It's a C pre-processor command. It allows the person compiling to choose between two codebases.
20:24:18 <brence> ddarius,dmwit: so how can I know which definiton is used when?
20:24:35 <dmwit> brence: Assume the more efficient one is used unless you have  agood reason to believe otherwise.
20:24:55 <dmwit> brence: If you are uncertain which is more efficient, download the GHC source code and take a look at the Makefiles.
20:25:08 <dolio> The inefficient one is used when the library is compiled with USE_REPORT_PRELUDE defined.
20:25:11 <ddarius> brence, dmwit: Since they are not semantically identical, you can actually tell them apart.
20:25:26 <ddarius> Technically, the not USE_REPORT_PRELUDE one is buggy.
20:25:42 <dmwit> Neat! Give me a chance to see if I can figure out how.
20:26:22 <dmwit> aha
20:26:42 <dmwit> > head . fst . splitAt 3 $ (1:2:undefined)
20:26:44 <lambdabot>   1
20:26:57 <dmwit> hm
20:27:43 <dmwit> > take 0 undefined
20:27:44 <lambdabot>   []
20:28:46 <parcs_> splitAt# _  xs@[]  = (xs, xs) ??
20:28:51 <brence> dolio,dmwit,ddarius: is USE_REPORT_PRELUDE specified in the package source ? cabal files?
20:29:04 <ddarius> @google CPP
20:29:06 <lambdabot> https://www.cpp.com/
20:29:11 <dmwit> brence: In the Makefiles, I would assume.
20:29:11 <ddarius> This should be interesting.
20:29:17 <ddarius> @google C preprocessor
20:29:18 <lambdabot> http://en.wikipedia.org/wiki/C_preprocessor
20:29:18 <lambdabot> Title: C preprocessor - Wikipedia, the free encyclopedia
20:29:35 <dmwit> brence: (Hence my earlier advice to look in the Makefiles. ;-)
20:30:11 <dmwit> Okay, I give up.
20:30:21 <dmwit> How can we distinguish this efficient implementation from the specification?
20:30:42 <dmwit> parcs_: It's just a stupid Haskell trick.
20:30:43 <ddarius> > splitAt undefined "abc" `seq` ()
20:30:44 <lambdabot>   *Exception: Prelude.undefined
20:30:53 <dmwit> aha
20:30:54 <dmwit> cute
20:31:07 <ddarius> > let splitAt n xs = (take n xs, drop n xs) in splitAt undefined "abc" `seq` ()
20:31:08 <lambdabot>   ()
20:31:14 <brence> dmwit: but I don't find Makefiles in packages downloaded from hackage
20:31:23 <ddarius> dmwit: There's more to it than that, though that's the simplest example.
20:31:34 <dmwit> brence: ...which is why I prefaced my advice with "download the GHC source". ;-)
20:31:59 <ddarius> brence: It would be in whatever built the Data.List library.  Read about CPP.
20:32:42 <ddarius> > splitAt 10000000 (repeat 'a')
20:32:43 <lambdabot>   ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:32:44 <dolio> What else is there?
20:33:03 <brence> ddarius: so it depends on the compiler, it cannot be used in external packages?
20:33:21 <dolio> > snd $ splitAt 100000000 (repeat 'a')
20:33:25 <lambdabot>   mueval-core: Time limit exceeded
20:33:26 <dmwit> CPP can be used in external packages.
20:33:55 <dmwit> But base isn't really meant to be built on its own.
20:35:51 <parcs_> dmwit: what exactly is the trick?
20:36:22 <ddarius> dolio: Well it's saved by an irrefutable match, so the other thing I was thinking about is not an issue, though it does suggest that it probably isn't much more efficient than the take/drop version.
20:36:28 <dmwit> parcs_: There's not much to understand. If the list is empty, it returns two empty lists.
20:36:53 <dmwit> parcs_: The stupid part of the trick is that it's sometimes possible to get a tiny bit of extra sharing by returning a single variable twice rather than returning two separate values.
20:37:05 <ddarius> dmwit: All [] are shared.
20:37:08 <dmwit> parcs_: It's especially stupid here because in Haskell, all []'s are the exact same pointer.
20:37:12 <dmwit> s/Haskell/GHC/
20:37:22 <dmwit> ddarius: yep
20:37:36 <dmwit> It's not a terrible habit to be in, though.
20:37:46 <SgeoN1> What habit?
20:37:47 <ddarius> I don't know if that line actually makes a difference, or if it is just some historical artifact.
20:37:53 <dmwit> Also, I wouldn't be surprised if that were not the case at the time that particular line was first written. =P
20:38:01 <SgeoN1> What line?
20:38:10 <dmwit> SgeoN1: The habit of being aware of sharing and exploiting it wherever possible.
20:38:19 <parcs_> dmwit: yeah that's what i was confused about (the latter part). i remember reading that all []s are shared
20:38:22 <ddarius> dmwit: Sometimes you want to break sharing.
20:38:26 <dmwit> SgeoN1: The line splitAt# _  xs@[]  = (xs, xs)
20:38:54 <ddarius> That function definition probably hasn't been touched in a -long- time.
20:38:58 <dmwit> SgeoN1: From here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#splitAt
20:39:02 <ddarius> I doubt the explicit unboxing is required any longer.
20:39:47 <dolio> Yeah, I'd be pretty surprised.
20:40:14 <parcs_> are all zero-argument constructors shared?
20:40:19 <dolio> Yes.
20:43:09 <ddarius> To be clear, all instances of a particular nullary constructor are shared.  Different nullary constructors within a type or in different types are not identified.
20:43:15 * hackagebot ascii 0.0.4 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.4 (MichaelSnoyman)
20:43:38 <ddarius> Or am I wrong ...
20:43:47 <dolio> GHC goes through some effort to make sure that only one copy of various small characters are ever in memory, too, as I recall.
20:43:56 <monochrom> you are right
20:44:21 <dolio> Maybe some other such types, too, I'm not sure.
20:45:05 <monochrom> I know you may be thinking that "but unsafeCoerce Nothing equals []". but that works just because of pointer tagging and examining lower bits only. the higher bits of the pointers are still different
20:45:13 <parcs_> i plan on reading the STG paper tomorrow. is there a follow-up paper or something similar i should read afterwards?
20:46:17 <parcs_> the paper is like 18 years old :P
20:46:41 <mike-burns> Legal!
20:47:03 <monochrom> ones, the paper can drink alcohol and cast votes
20:47:15 <dolio> I don't think people expect that to work because the pointers are the same.
20:47:17 <monochrom> and run for presidency too
20:47:49 <ddarius> monochrom: Yeah, I think I'm right too, but I'm not sure that GHC really relies on them being different.
20:47:59 <dmwit> ddarius: Well, to be ultra-careful, it's not quite right. [] :: [Int] and [] :: [()] are identified.
20:48:01 <parcs_> you have to be 35 to run for presidency (in the us)
20:48:19 <dolio> They expect it to work because the Nothing and [] are implemented approximately the same way.
20:49:09 <ddarius> It worked before pointer tagging was implemented, so pointer tagging is relevant but not crucial.
20:49:25 <ddarius> This can be verified by testing on types that have more constructors.
20:49:33 <blackdog> hrm. why is interact so lazy?
20:49:37 <dolio> I'm not really up on all the things that can actually go wrong with using the implementation of [] as a Maybe.
20:49:57 <blackdog> i would have thought you'd get a response after each line
20:50:15 <dolio> I think there's something for other types at least, though.
20:50:27 <parcs_> blackdog: hehe, i thought the same
20:50:36 <dolio> Such that unsafeCoerce :: Int -> Word isn't recommended and the like.
20:50:43 <dolio> Nor is Int# -> Word#
20:50:44 <parcs_> then ddarius made fun of me
20:51:01 <ddarius> parcs_: I did?  I mean it does sound like me, but I don't recall it.
20:51:14 <ddarius> So many nicks, so many people to make fun of.
20:51:43 <dmwit> blackdog: If your program can produce output after every line, you will get output after every line.
20:51:49 <blackdog> parcs_: is there a reason for that implementation?
20:51:54 <blackdog> dmwit: i don't think that's true
20:52:07 <blackdog> try "main = interact reverse"
20:52:19 <dmwit> interact reverse cannot make output after every line.
20:52:20 <blackdog> i wonder if it's a line buffering thing
20:52:30 <dmwit> Perhaps you meant main = interact (unlines . map reverse . lines)
20:52:31 <monochrom> interact (unlines . map (show . length) . lines)  worksforme
20:52:35 <ddarius> The first character of that would be the last character of the input.  Of the -entire- input.
20:52:45 <ddarius> I.e. ^D (or ^Z for Windows folk)
20:52:52 <parcs_> blackdog: it's more general i guess
20:52:58 <monochrom> yeah, reverse is too strict
20:53:06 <dmwit> It's not a line buffering thing.
20:53:12 <blackdog> ah, i thought the whole point was for interact to be line oriented
20:53:22 <blackdog> gah, you're right.
20:53:23 <mike-burns> I wish.
20:53:25 <ddarius> blackdog: Why?
20:53:36 <blackdog> ddarius: because i didn't check the type:)
20:53:58 <ddarius> blackdog: I guess that's the right answer.
20:54:11 <mike-burns> Does the line-oriented function you want exist?
20:54:26 <parcs_> my reasoning is that stdin is line-buffered by default so in a hand-wavy fashion interact should work line by line
20:54:28 <ddarius> :t interact . (unlines .) . (. lines)
20:54:28 <dmwit> interactLines f = interact (unlines . map f . lines)
20:54:29 <lambdabot> ([String] -> [String]) -> IO ()
20:54:39 <ddarius> :t interact . (unlines .) . (. lines) . map
20:54:40 <lambdabot> (String -> String) -> IO ()
20:55:11 <parcs_> and interact implies user _interaction_
20:55:20 <parcs_> not piping and stuff
20:55:31 <mike-burns> Naming is hard.
20:55:38 <parcs_> it's not really interaction when it happens once
20:55:39 <ddarius> I interact with programs that take less than a line of input at a time.
20:56:05 <monochrom> interaction between monkey robots is still interaction
20:56:49 <mike-burns> Oh good, a semantic argument.
20:56:51 <mike-burns> Goodnight.
20:57:29 * ddarius punches parcs_ in the face, but does it only once so it is not an interaction.
20:58:06 <parcs_> @dict interaction
20:58:07 <lambdabot> Supported dictionary-lookup commands:
20:58:07 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:58:07 <lambdabot> Use "dict-help [cmd...]" for more.
20:58:39 <parcs_> i guess it is interaction :( "Mutual or reciprocal action or influence"
20:59:00 <parcs_> @remember mike-burns Oh good, a semantic argument. Goodnight.
20:59:01 <lambdabot> Done.
20:59:25 <monochrom> afterall, physicists talk about quark interactions all the time.
20:59:28 <blackdog> mike-burns: as far as i can tell, it doesn't. tried the one ddarius posted, but it's just as lazy.
20:59:30 <ddarius> Those Formalists with their anti-semantic comments.
21:00:28 <blackdog> ended up with "interact' f = (TIO.getLine >>= \x -> TIO.putStrLn $ f x) >> interact' f"
21:02:02 <ddarius> Great googly-moogly.  At least do, getLine >>= putStrLn . f
21:02:18 <jdavis> Is it reasonable to try to use Haskell for algorithms with strict upper-bounds on the memory consumption? I'm interested in being able to write algorithms that have very limited failure cases, so I would like to allocate the memory up-front to avoid allocation failures.
21:02:25 <dmwit> blackdog: Did you try mine?
21:03:00 <dmwit> Oh, mine is the same. Never mind.
21:03:05 <blackdog> dmwit: it didn't have the right type
21:03:13 <ddarius> jdavis: You -could- do that, but it would be extremely difficult.  Not really an answer to your question, but you can specify the maximum heap size and so guarantee no more than a certain memory usage.
21:03:22 * dmwit blinks
21:03:34 <dmwit> :t \f -> interact (unlines . map f . lines)
21:03:35 <lambdabot> (String -> String) -> IO ()
21:03:48 <ddarius> jdavis: It's very hard to write Haskell programs that don't allocate.
21:04:02 <dmwit> blackdog: Anyway, what exactly do you mean by "it's just as lazy"? Isn't "lazy" exactly what you want for this?
21:04:13 <dmwit> "strict" would mean it waited until all of the input was available before doing anything.
21:04:28 <jdavis> ddarius: ok, I think that mostly answers my question. But what's that about the maximum heap size?
21:04:42 <ddarius> blackdog: Your life will be simpler if you do it the way you are doing it.
21:04:57 <blackdog> dmwit: i want it evaluated line by line. using ddarius's solution, if i type in a line, i get no output until i send EOF
21:05:05 <blackdog> ddarius: yes, you're probably right
21:05:12 <dmwit> blackdog: That sounds bad. Let me try to reproduce that problem.
21:05:59 <dmwit> blackdog: I do not see that behavior here. How are you running your program?
21:06:06 <ddarius> jdavis: Well, it's not a Haskell feature but a GHC feature, but there are RTS options you can passed to GHC compiled executables to set GC parameters including the maximum heap size.
21:06:25 <dmwit> (My entire source is: interactLines f = interact (unlines . map f . lines); main = interactLines reverse)
21:06:53 <jdavis> ddarius: what happens when that limit is reached? and can it be applied to, say, an object file rather than the entire executable?
21:08:14 <ddarius> jdavis: Then you GC.  If you still don't have space after GCing, you fail with an out of memory exception.  There is only one garbage collector per executable.  The garbage collector is in the RTS.
21:08:32 <jdavis> Oh, ok.
21:08:58 <jdavis> Can that exception be caught?
21:09:54 <ddarius> jdavis: I believe you technically can, but you'd have a really hard time handling it in most cases.
21:10:48 * Axman6 suggests a new function: killALLTheOtherThreads, which should only be used when catching the out of memory exception
21:11:11 <jdavis> I don't actually need the entire program to be that strict. Mainly, I want to: (a) have a fixed number of buffers to do some work in; and (b) have some "slop" space for normal program flow, with an upper bound so that I can catch runaway leaks, etc.
21:11:13 <ddarius> Axman6: That doesn't help, unless the out of memory exception gets thrown to a special thread.
21:11:42 <Axman6> ddarius: it gets thrown to all the threads, and then one of the threads wins at killing all the others
21:11:59 <ddarius> Axman6: Yes, but that doesn't help in a single threaded program.
21:12:26 <jdavis> ddarius: and then, if there was a space leak, I could abort that computation. But I might need some slop to actually do the abort, so you're right, that might be tricky.
21:12:27 <Axman6> then you call deallocateALLTheMemory =)
21:13:12 <ddarius> In general, it is pretty difficult to handle out of memory exceptions in any language.
21:13:24 <Axman6> better to avoid them
21:13:26 <monochrom> "GHC currently does not throw HeapOverflow exceptions." http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Control-Exception.html#v:HeapOverflow  sorry to rain on your parade
21:13:33 * Axman6 starts the NoHEAP movement
21:14:08 <ddarius> With default settings, I don't think GHC ever runs out of memory.
21:14:41 <Axman6> hmm, i swear i've run out of memory before. i've written some pretty terrible programs before
21:15:26 * Axman6 reasks his question from #ghc
21:15:31 <Axman6> does GHC run the GC if nothing has been allocated on the heap since the last GC run?
21:15:50 <Axman6> from my testing, it seems that it does not
21:16:21 <ddarius> I think there may be some exceptions, but the GC is only run on heap checks.
21:17:21 <monochrom> and heap checks are statically coded in the generated code right before each allocation instruction
21:17:32 <blackdog> dmwit: ah, i found the problem
21:17:50 <blackdog> dmwit: i'm using Data.Text.IO.interact
21:17:53 <jdavis> Axman6: how do you avoid out of memory exceptions? Are there hooks to know how much is allocated?
21:18:13 <Axman6> jdavis: it's not easy in haskell
21:18:17 <jdavis> Axman6: or maybe an "almost-out-of-memory exception" ;)
21:18:41 <hpaste> blackdog pasted “Data.Text behaviour” at http://hpaste.org/54046
21:19:02 <blackdog> dmwit: so the base interact acts differently to the one in Data.Text.IO
21:19:09 <dmwit> Oh, interesting.
21:19:12 * dmwit tries
21:19:42 <monochrom> prove that your program uses bounded memory, by knowing how lazy evaluation uses (and does not use) memory. my http://www.vex.net/~trebla/haskell/lazy.xhtml is a start.
21:20:11 <jdavis> To step back a minute, I guess what I'm really looking for is a way to organize my code so that certain sections are immune from most kinds of errors -- that is, don't do IO, don't allocate unlimited amounts of memory, etc. -- and if the computation is unable to complete, then I want to just abort it.
21:20:48 <jdavis> Or perhaps save some in-progress work and do it later.
21:20:51 <monochrom> for example you can prove that the last case study "co-routines" uses bounded memory and the case study before it "average" uses unbounded memory
21:20:58 <blackdog> jdavis: perhaps look at mu-eval in lambdabot?
21:21:15 <blackdog> although that's dynamic rather than static
21:21:40 <jdavis> blackdog: I'll take a look
21:21:41 <ddarius> monochrom: You'd have to know all the optimizations the compiler performs as well.  Also some GC details and other RTS facets will be relevant.
21:23:04 <ddarius> jdavis: I'm pretty sure mu-eval forks another process, and, if that isn't too heavy-weight, that really is the right solution.
21:23:37 <dmwit> baldo: You're right; Text looks a bit stricter than String.
21:23:41 <dmwit> uh
21:23:47 <dmwit> blackdog: I meant that for you.
21:23:52 <blackdog> yeah, i figured:)
21:24:07 * dmwit makes a note: blackdog responds to baldo
21:24:47 <monochrom> I disagree. optimizations don't change asymptotic memory usage. prove that your program uses Θ(1) memory. then use testing to find out that it is 200MB in practice. now you know the bound.
21:25:18 <dmwit> blackdog: Why not switch to Data.Text.Lazy and Data.Text.Lazy.IO?
21:25:18 <augur> dylex: ping
21:25:30 <dylex> augur: hello
21:25:41 <jdavis> ddarius: yeah, perhaps you're right.
21:25:44 <blackdog> dmwit: gorgeous. thanks.
21:25:44 <augur> dylex: i made some changes to my abstract. can i get your opinion?
21:25:47 <ddarius> monochrom: Optimizations can and have changed asymptotic memory usage.
21:25:49 <dmwit> blackdog: When I switch the imports to be the Lazy ones, interactLines behaves the way I expect.
21:25:53 <dylex> augur: sure!
21:25:53 <augur> im not sure how i should conclude it, but
21:26:10 <monochrom> not to be point of changing Θ(1) to Θ(n).
21:26:43 <augur> dylex: http://wellnowwhat.net/linguistics/GLOW%20Abstract.pdf
21:26:44 <ddarius> monochrom: A little bit of full laziness can cause that.
21:27:20 <blackdog> dmwit: yes, that has the behaviour i want
21:27:40 <dmwit> \o/
21:27:52 <dylex> augur: "proposes for"?
21:28:11 <ddarius> monochrom: You could use a conservative enough model such that that statement is true, but it would be too conservative.
21:28:17 <augur> dylex: woops :)
21:28:36 <monochrom> I only know that it happens in a corner case, and it is fragile, and I myself posted that example, and tiny changes such as changing the data types or changing seq to pseq fixes it.
21:29:11 <augur> dylex: i should probably read through it myself :D
21:29:40 <dylex> augur: perhaps. "in typical by"?
21:29:50 <augur> yeah yeah :P
21:30:57 <augur> these are all partial edits
21:31:06 <augur> like, i went to change it, but forgot halfway through what i was doing
21:31:07 <augur> lol
21:31:27 <ddarius> I agree that it is very rare that GHC's optimizations lead to an asymptotically larger memory usage, but you certainly can't prove that your program uses constant memory, say, without understanding the consequences of the optimizations applied to your program.  Also, if you do soundly calculate the memory usage, you will likely be overly conservative if you don't take into considerations certain aspects of the RTS, suc
21:31:27 <ddarius> h as selector thunks.
21:33:40 <ddarius> Ultimately, the Report gives no basis at all for estimating memory usage, so you have to know what you particular implementation does.
21:34:09 <ddarius> Mostly pretending that it is a simply call-by-need lambda calculus will put you into the ballpark.
21:35:13 <codemac> gienah: just a heads up, I got cabal-dev installed successfully after removing ALL of macports haskell stuff, and installing haskell platform
21:36:55 <codemac> also, is there a way to make cabal installed regex-pcre look in /opt/local/include?
21:39:00 <ion> cale: Yay, your withCStringArray0 and nest are useful. :-)
21:42:38 <Cale> ion: cool :)
21:42:50 <Cale> ion: did you see the Cont implementation of nest?
21:45:57 <ddarius> The response to security vulnerability 4 on http://www.yesodweb.com/page/about seems nonsensical to me.
21:47:28 <mm_freak> ddarius: remember register_globals from PHP?
21:47:59 <ddarius> I avoid PHP as much as possible.
21:48:31 <mm_freak> in essence yesod will never let you bring a variable into scope, which isn't part of the form
21:49:37 <ddarius> So?  If I have databaseid as a parameter to my form, it's in scope.
21:50:15 <SgeoN1> With reactive-banana, how could I, say, introduce a 5 second delay to something?
21:50:39 <ion> cale: Yeah, that one.
21:51:11 <mm_freak> ddarius: correct…  the point is:  it's up to you, the programmer
21:51:20 <ddarius> mm_freak: From your comment, I assume that you just mean that the bullet point means that Yesod doesn't do something braindead.
21:51:36 <mm_freak> ddarius: it's really just taking "never use register_globals" to its max
21:51:59 <ddarius> By not using PHP?  I can accomplish that in C#.
21:52:37 <mm_freak> PHP is the only language i know that has been such retarded in history (and is still retarded today)
21:53:40 <parcs_> SgeoN1: to what?
21:54:36 <SgeoN1> Parcs, say, I'm writing a game. I want pulses to flash somewhere 5 seconds after the player clicks on somethig
21:54:40 <mm_freak> in any case in yesod you don't have a large array of parameters…  the data for a form is akquired through the form runner, and that one will only give you data that you explicitly asked for
21:59:38 <parcs_> SgeoN1: by using something like this: http://paste.pocoo.org/show/508058/
22:00:37 <parcs_> basically you are creating a custom handler that emits a () every n seconds
22:02:29 <parcs_> it is really ugly but i don't think that there is a better way
22:02:44 <marvinalone> So I have a list [a], and a function f :: a -> Either String b. I'm looking for a nice way to write a function g :: (a -> Either String b) -> b -> Either String b that will return Left foo if (f a) returns Left foo for any of the a's, and Right b otherwise.
22:03:17 <marvinalone> i have do mapM f as; return b;, but that doesn't seem very elegant.
22:03:29 <mm_freak> the type doesn't make sense to me
22:03:38 <marvinalone> mm_freak: which one?
22:03:47 <mm_freak> the one of 'g'
22:04:15 <SgeoN1> parcs, would finding another library be a better orbworse wat?
22:04:26 <pchiusano> is there anything like Data.Binary, but as a monad transformer?
22:04:28 <mm_freak> seems to me that the 'b' in the middle should be an 'a'
22:04:36 <mm_freak> and then g is just id
22:04:36 <pchiusano> i need to track some state while serializing and deserializing
22:05:19 <marvinalone> mm_freak: the b in the middle is just there so it can return something if none of the (f a)s return Left foo. I think it could even be a c.
22:05:27 <mm_freak> marvinalone: if you want to apply such a function to a list, then mapM is really the way to go
22:05:42 <mm_freak> or foldM
22:05:47 <mm_freak> :t foldM
22:05:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:06:03 <Codingtales> https://github.com/mwotton/heroku_haskell_demo no longer runs on Heroku. Did anyone face this problem?
22:06:08 <parcs_> SgeoN1: yes, there exist better, more complete frp implementations
22:06:24 <marvinalone> mm_freak: i couldn't figure out a version of foldM that would do what i want
22:06:29 <parcs_> take a look at 'netwire'
22:06:46 <SgeoN1> parcs, any advantages to using reactive-banana then?
22:06:54 <mm_freak> marvinalone: note: Either String is the monad for computations, which may raise an exception of type String
22:07:20 <mm_freak> parcs_: netwire 2 is out =)
22:07:21 <parcs_> SgeoN1: it is simple
22:07:51 <ddarius> pchiusano: Why wouldn't you monad transform the Get monad?
22:07:52 <mm_freak> completely written from scratch
22:07:52 <parcs_> mm_freak: is it not on hackage?
22:08:02 <mm_freak> parcs_: sure it is
22:08:12 <parcs_> oh!
22:08:18 <mm_freak> parcs_: http://hackage.haskell.org/package/netwire
22:08:19 <parcs_> awesome!
22:08:40 <SgeoN1> The documentation says it assumes that I'm familiar with Yampa
22:08:53 <pchiusano> ddarius: well, the signature of put is that I have to return a Put
22:08:54 <parcs_> my browser cache was stale :)
22:09:00 <pchiusano> not an m Put
22:09:05 <mm_freak> parcs_: you may want to read its release notes: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/93860
22:09:15 <SgeoN1> I have vague memories, but that's it
22:09:30 <mm_freak> SgeoN1: the wiki documentation is really about netwire 1.2
22:09:32 <pchiusano> so how does monad tranforming put help me
22:09:47 <mm_freak> we'll have to completely rewrite the netwire wiki page for netwire 2
22:09:53 <SgeoN1> Hmm, there's a section for those not familiar with Yampa
22:09:53 <parcs_> hmm, i totally missed the release announcement on -cafe..
22:10:00 <SgeoN1> ...noh
22:10:04 <SgeoN1> *oh
22:10:15 <SgeoN1> Will I learn anything by reading the current page?
22:10:22 <mm_freak> SgeoN1: yes, the concept
22:10:31 <ion> Dunno if this is the best solution, but as my fork-and-exec code in Haskell had a race condition where some other Haskell could do stuff between the fork and the exec hanging the entire thing, i implemented the fork-and-exec part in C and call it with FFI (and this is where Cale’s withCStringArray0 was helpful). https://github.com/ion1/mchost/commit/e65ae6282a8c604f82bc3610feafd298cbde3a99
22:10:59 <mm_freak> SgeoN1: and here is a demo: http://hpaste.org/54025
22:11:08 <mm_freak> that one is for netwire 2
22:12:08 <SgeoN1> I vaguely understand that Kleisli is for turning monads into arrows...
22:12:54 <ddarius> :t lift put
22:12:55 <lambdabot>     Ambiguous occurrence `lift'
22:12:55 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
22:12:55 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
22:13:16 <ddarius> :t Control.Monad.Trans.lift . put
22:13:19 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *) s. (Control.Monad.Error.MonadTrans t, MonadState s m) => s -> t m ()
22:14:12 <ddarius> Wrong put, but don't use the Binary class's put.
22:14:40 <parcs_> hah! your example causes ghci to die with the 'impossible' happened
22:14:49 <parcs_> mm_freak ^
22:15:27 <mm_freak> huh? which version?
22:15:33 <parcs_> 7.0.3
22:15:41 <parcs_> i think it's due to the use of banana brackets
22:16:02 <mm_freak> strange…  perhaps you should file a bug report…  it works for me on 7.0.3
22:17:00 <mm_freak> SgeoN1: newtype Kleisli m a b = Kleisli (a -> m b)
22:17:16 <mm_freak> runKleisli :: Kleisli m a b -> a -> m b
22:17:18 <mm_freak> that's it
22:17:42 <parcs_> strange..
22:17:55 <mm_freak> parcs_: but compiling works?
22:17:56 <Codingtales> Anyone, please, I am trying to get Haskell running on Heroku, https://github.com/mwotton/heroku_haskell_demo is not working
22:18:04 <parcs_> mm_freak: yeah
22:18:35 <xil> hi. I'm looking for a function like "split" from Data.List.Utils. But it looks like that import is old. All I can find is splitAt, in Data.List, but that doesn't do the same thing
22:21:11 <byorgey> @hackage split
22:21:11 <lambdabot> http://hackage.haskell.org/package/split
22:21:24 <byorgey> xil: try that
22:21:37 <Codingtales> Can we just run heroku run ./app ?
22:22:11 <Codingtales> Even that needs app to be pushed to the server. Heroku rejects the push outright, due to an "unrecognized error"
22:22:23 <byorgey> oh wow, I was just refactoring a program and it suddenly stopped working, and after a bit of fiddling I determined that replacing (b1 + b2 + b3) with (sum [b1,b2,b3]) caused the incorrect output
22:22:55 <byorgey> after boggling for a minute I finally realized that I had mistyped   fromInteger n = ... fromInteger 2 ...
22:23:06 <byorgey> so sum's base case was calling  fromInteger 0...
22:23:15 * hackagebot digestive-functors-happstack 0.1.1.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.1.1 (JasperVanDerJeugt)
22:23:20 <byorgey> no idea how that 2 got in there
22:23:49 <xil> byorgey: ah that's perfect, thanks =]
22:27:52 <SgeoN1> Byorgey, what were you doing redefining fromInte... oh, for your own Number instance for somehing?
22:28:00 <SgeoN1> Num
22:28:09 <byorgey> SgeoN1: yes, it was in a Num instance
22:33:15 * hackagebot vty-ui 1.3.1 - An interactive terminal user interface library  for Vty  http://hackage.haskell.org/package/vty-ui-1.3.1 (JonathanDaugherty)
22:34:13 <mm_freak> parcs_: do you like the new concept?
22:47:22 <SgeoN1> Should I assume that wires aren't in arrowapply?
22:48:20 <letrec> :t liftIO
22:48:21 <lambdabot>     Ambiguous occurrence `liftIO'
22:48:21 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
22:48:21 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
22:48:31 <letrec> :t liftM
22:48:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:48:59 <letrec> :t Control.Monad.Logic.liftIO
22:49:00 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
22:50:42 <codemac> hm, anyone know what it means if I'm doing "cabal-dev init" and it exits halfway through with "cabal-dev/lib/ghc-7.0.3/MonadCatchIO-transformers-0.2.2.3: does not exist" ?
22:53:33 <codemac> shouldn't it be cabal-dev/lib/MonadCatchIO-transformers-0.2.2.3/ghc-7.0.3 ?
22:58:53 <mm_freak> SgeoN1: if they were ArrowApply, we wouldn't need arrows in the first place =)
22:59:06 <mm_freak> Wire is not a monad
23:01:07 <RaptorRarr> > let nubr = foldr (\x ps -> if elem x ps then ps else x:ps) [] in (nub [1, 2, 3, 2, 4, 2], nubr [1, 2, 3, 2, 4, 2])
23:01:08 <lambdabot>   ([1,2,3,4],[1,3,4,2])
23:03:47 <SgeoN1> Why does AerowApply exist?
23:03:57 <SgeoN1> ArrowApply
23:05:50 <byorgey> > let nubr = reverse . nub . reverse in (nub [1, 2, 3, 2, 4, 2], nubr [1, 2, 3, 2, 4, 2])
23:05:52 <lambdabot>   ([1,2,3,4],[1,3,4,2])
23:07:01 <RaptorRarr> SgeoN1: For the app function.
23:09:15 <shachaf> Is there an O(n log n) nub that doesn't lose ordering somewhere?
23:09:42 <dmwit> Set.toList . Set.fromList, maybe?
23:09:58 <dmwit> map head . group . sort -- also feasible
23:10:00 <shachaf> dmwit: Right, except for the "doesn't lose ordering" bit. :-)
23:10:06 <byorgey> I doubt that guarantees to preserve the order, although it may in practice
23:10:13 <RaptorRarr> You could probably form a binary search tree from the list.
23:10:22 <shachaf> byorgey: I think Set.toList just gives you an ascending list.
23:10:37 <byorgey> shachaf: ah, yeah, I think you're right
23:10:37 <dmwit> I'm pretty sure sort is stable (though it may not guaranteed to be so).
23:10:41 <dmwit> Not as confident in the Set one.
23:10:58 <dmwit> ...oh
23:11:00 <shachaf> dmwit: It doesn't matter much whether the sort is stable.
23:11:01 <dmwit> Now I understand.
23:11:04 <dmwit> I'm a total idiot.
23:11:12 <dmwit> Let's see...
23:11:27 <dmwit> :t foldl'
23:11:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:11:36 <byorgey> you could make the list into a Set and then filter by membership
23:11:46 <byorgey> er, something like that
23:12:05 <byorgey> I mean accumulate a Set as you go along
23:12:05 <shachaf> byorgey: Yes, I suppose that would be O(n log n).
23:12:07 <dmwit> :t foldr
23:12:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:12:41 <shachaf> Does it exist in any library anywhere? :-)
23:12:53 <byorgey> probably, but not that I know of =)
23:13:14 <dmwit> Don't know of a place, but it seems totally feasible.
23:13:39 <byorgey> shachaf: you should make one =)
23:13:57 <byorgey> stable-fast-nub
23:14:30 <dmwit> :t let f [] acc = []; f (x:xs) acc | x `Set.elem` acc = f xs acc | otherwise = x : f xs (Set.insert x acc) in f
23:14:31 <lambdabot> Couldn't find qualified module.
23:14:41 <dmwit> :t let f [] acc = []; f (x:xs) acc | x `S.elem` acc = f xs acc | otherwise = x : f xs (S.insert x acc) in f
23:14:42 <lambdabot> Couldn't find qualified module.
23:14:58 <dmwit> How is Data.Set qualified in lambdabot?
23:15:11 <shachaf> > S.empty
23:15:12 <lambdabot>   fromList []
23:15:26 <byorgey> dmwit: for some odd reason it's S.member
23:15:31 <dmwit> oh
23:15:39 <dmwit> :t let f [] acc = []; f (x:xs) acc | x `S.member` acc = f xs acc | otherwise = x : f xs (S.insert x acc) in f
23:15:40 <lambdabot> forall a. (Ord a) => [a] -> S.Set a -> [a]
23:18:38 <dmwit> :t foldr
23:18:39 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:19:51 <RaptorRarr> > let nubs = f S.empty where f _ [] = []; f set (x:xs) = if S.member x set then f set xs else x:f (S.insert x set) xs in nubs [1, 2, 3, 4, 2, 5]
23:19:52 <lambdabot>   [1,2,3,4,5]
23:20:09 <dmwit> :t foldr (\x (v, acc) -> (if x `S.member` acc then x:v else v, S.insert x acc)) S.empty
23:20:10 <lambdabot>     Couldn't match expected type `([a], S.Set a)'
23:20:10 <lambdabot>            against inferred type `S.Set a1'
23:20:10 <lambdabot>     In the second argument of `foldr', namely `S.empty'
23:20:22 <dmwit> :t foldr (\x (v, acc) -> (if x `S.member` acc then x:v else v, S.insert x acc)) ([], S.empty)
23:20:23 <lambdabot> forall a. (Ord a) => [a] -> ([a], S.Set a)
23:20:43 <dmwit> > foldr (\x (v, acc) -> (if x `S.member` acc then x:v else v, S.insert x acc)) ([], S.empty) [1,2,3,4,2,5]
23:20:44 <lambdabot>   ([2],fromList [1,2,3,4,5])
23:20:54 <dmwit> Not quite what I was hoping for. =P
23:21:13 <dmwit> > foldr (\x (v, acc) -> (if x `S.member` acc then v else x:v, S.insert x acc)) ([], S.empty) [1,2,3,4,2,5]
23:21:14 <byorgey> you got your then/else switched I think
23:21:15 <lambdabot>   ([1,3,4,2,5],fromList [1,2,3,4,5])
23:21:26 <byorgey> that's more like it =)
23:21:47 <dmwit> > foldr (\x (v, acc) -> (if x `S.member` acc then v else x:v, S.insert x acc)) ([], S.empty) (1:2:3:undefined)
23:21:48 <lambdabot>   *Exception: Prelude.undefined
23:21:55 <dmwit> Not lazy enough. =/
23:22:03 <RaptorRarr> > let nubs = f S.empty where f _ [] = []; f set (x:xs) = if S.member x set then f set xs else x:f (S.insert x set) xs in nubs (1:2:3:undefined)
23:22:05 <lambdabot>   [1,2,3*Exception: Prelude.undefined
23:22:07 <byorgey> boo =(
23:22:33 <shachaf> byorgey: See, why write it myself when #haskell can write it for me?
23:22:38 <dmwit> > foldr (\x ~(v, acc) -> (if x `S.member` acc then v else x:v, S.insert x acc)) ([], S.empty) (1:2:3:undefined)
23:22:39 <RaptorRarr> I think you can't get a lazy right version.
23:22:39 <lambdabot>   (*Exception: Prelude.undefined
23:22:48 <byorgey> dmwit: the problem is that you check against the accumulated set from the *rest* of the list, instead of carrying the set forwards
23:22:58 <RaptorRarr> Since you have to wait, for each value, to see if it'll come later.
23:23:02 <dmwit> RaptorRarr: What? The explicit recursion one I wrote above should be both lazy and right. As is yours.
23:23:22 <dmwit> byorgey: Yeah, I'm trying to wrap my head around how to fix that now.
23:23:26 <RaptorRarr> No, I mean, like [2, 1, 2] -> [1, 2] (the rightmost 2 is preserved)
23:23:38 <byorgey> dmwit: you can use mapAccumR, perhaps
23:23:42 <RaptorRarr> For that to work, it has to hold off producing output until the whole list is processed.
23:23:46 <dmwit> Is it possible that this is a place for foldl??
23:23:52 <dmwit> Oh, mapAccumR sounds promising.
23:23:54 <dmwit> :t mapAccumR
23:23:55 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:24:03 <dmwit> What a gorgeous type.
23:24:05 <shachaf> mapAccumR is a map, sadly, not a filter.
23:24:09 <RaptorRarr> Otherwise, there might, for any entry, be a future element of the list that matches, so it shouldn't be in the output.
23:24:20 <byorgey> dmwit: foldl would definitely not give you something lazy
23:24:22 <shachaf> dmwit: I'm impressed at the Haskeller that used three whole letters for an identifier.
23:24:41 <dmwit> shachaf: Eh, what's a little concat at the end. =)
23:24:43 <byorgey> RaptorRarr: no, as soon as you see an element you can produce it as long as you haven't seen it before.
23:24:57 <byorgey> RaptorRarr: you just have to make sure not to produce any copies you see later.
23:25:21 <RaptorRarr> byorgey: Ahh, that's what I'd mean by a left-oriented nub. You produce each leftmost incidence of identical elements.
23:25:44 <byorgey> RaptorRarr: oh, I see what you were saying now.  Yes, I agree if you want a rightmost-preserving version you can't do it lazily.
23:25:44 <RaptorRarr> Not sure what the technical term for that would be.
23:25:58 <shachaf> I want a middlemost nub.
23:25:59 <RaptorRarr> Ahh, that works :)
23:26:02 <RaptorRarr> Haha
23:26:12 <RaptorRarr> The median nub.
23:26:25 <RaptorRarr> Let's see.
23:26:28 <dmwit> > concat . snd . mapAccumR (\set x -> (S.insert x set, [x | x `S.member` set])) S.empty $ [2,3,2,5,4]
23:26:30 <lambdabot>   [2]
23:26:49 <dmwit> :t S.notMember
23:26:50 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
23:26:58 <dmwit> > concat . snd . mapAccumR (\set x -> (S.insert x set, [x | x `S.notMember` set])) S.empty $ [2,3,2,5,4]
23:27:00 <lambdabot>   [3,2,5,4]
23:27:17 <dmwit> That's not quite what I expected.
23:27:29 <dmwit> And looks suspiciously unlazy.
23:27:40 <dmwit> > concat . snd . mapAccumR (\set x -> (S.insert x set, [x | x `S.notMember` set])) S.empty $ (1:undefined)
23:27:41 <lambdabot>   *Exception: Prelude.undefined
23:27:48 <shachaf> One of you should put this on the wiki or something when you're done.
23:28:10 <dmwit> shachaf: Oh, if I were to write this in a library, the very first explicitly recursive one I wrote would be the one I left in the library.
23:28:18 <dmwit> Nothing like nice, readable code for making libraries maintainable.
23:28:34 <dmwit> It's properly lazy, it's easy to understand, and it's right. =)
23:28:51 <shachaf> dmwit: Sure.
23:30:08 <dmwit> > let f' acc [] = []; f' acc (x:xs) | x `S.member` acc = f' acc xs | otherwise = x : f' (S.insert x acc) xs; f = f' S.empty in f [2,3,2,4,5]
23:30:09 <lambdabot>   [2,3,4,5]
23:30:19 <dmwit> > let f' acc [] = []; f' acc (x:xs) | x `S.member` acc = f' acc xs | otherwise = x : f' (S.insert x acc) xs; f = f' S.empty in f (1:2:1:undefined)
23:30:20 <lambdabot>   [1,2*Exception: Prelude.undefined
23:32:07 <mm_freak> SgeoN1: ArrowApply's existence is still justified for arrows that are actually monads
23:32:28 <dmwit> It's a shame Data.Set doesn't have an insert' :: Ord a => a -> Set a -> Maybe (Set a) that only returns a new set when something changed.
23:32:31 <mm_freak> arrow transformers take arrows as arguments, not monads…  ArrowApply is another way to say:  "i want a monad here"
23:33:01 <mm_freak> dmwit: for performance reasons?
23:33:14 <dmwit> Yes. It combines a membership check and an insert in one.
23:33:43 <mm_freak> well, check the size, if you really want performance
23:33:53 <dmwit> Cute.
23:33:56 <mm_freak> i guess that's faster anyway
23:34:34 <dmwit> Yes, that's very cute.
23:35:03 <copumpkin> sadly that doesn't work for IntSet
23:35:10 <dmwit> Still, insert is forced to rebuild the spine down to the inserted element with that approach.
23:35:43 <mm_freak> copumpkin: i have yet to see a comparison, where IntMap/IntSet are faster
23:35:55 <mm_freak> the idea is neat, but in practice, it doesn't really pay off
23:35:59 <copumpkin> mm_freak: than Map Int?
23:36:02 <copumpkin> wait, what?
23:36:03 <mm_freak> yes
23:36:11 <copumpkin> throw it into criterion
23:36:22 <copumpkin> it's fairly easy to measure how much faster they are
23:36:39 <copumpkin> it was quite noticeable with some graph stuff I was doing last year
23:36:46 <copumpkin> not sure where you've found they're slower o.O
23:36:49 <mm_freak> in my benchmarks they have been equally fast for somewhat filled maps/sets
23:37:02 * copumpkin shrugs
23:37:04 <mm_freak> for small maps/sets the generic variants were faster
23:37:22 <mm_freak> note that IntMap and IntSet need a fixed 64 branches for every query
23:37:32 <mm_freak> on modern platforms that is
23:38:57 <RaptorRarr> > let equating f x y = f x == f y; medianNub = map snd . sortBy (comparing fst) . map (\xs -> let len = length xs in xs !! div len 2) . groupBy (equating snd) . sortBy (comparing snd) . zip [0..] in medianNub [1,2,4,2,5,3,2]
23:38:59 <lambdabot>   [1,4,2,5,3]
23:39:05 <RaptorRarr> There you go, shachaf.
23:39:29 <copumpkin> mm_freak: no it isn't
23:39:42 <RaptorRarr> I suppose that's not quite median.
23:39:43 <RaptorRarr> Hmm.
23:40:02 <DanBurton> :t on
23:40:03 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:40:28 <dmwit> Oh, I do like the annotate, nub, and sort approach.
23:40:35 <DanBurton> :t (`on` (==))
23:40:36 <lambdabot> forall c a. (Eq a) => ((a -> Bool) -> (a -> Bool) -> c) -> a -> a -> c
23:40:45 <dmwit> :t ((==) `on`)
23:40:46 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
23:40:54 <dmwit> :t on (==)
23:40:55 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
23:41:00 <DanBurton> yes that
23:41:18 <shachaf> I wish there was a genericLength that used foldl instead of foldr.
23:41:54 <DanBurton> equating = on (==)
23:42:24 <DanBurton> shachaf: why foldl?
23:42:31 <shachaf> DanBurton: Fine, foldl'
23:44:44 <copumpkin> mm_freak: take http://www.johantibell.com/files/hiw-2011.pdf for example. Even with the hashing overhead (where a normal Ord comparison on ByteStrings can terminate in no time due to lexicographic ordering) it's quite a bit faster than Map
23:44:56 <copumpkin> mm_freak: I'd be curious to see where it's slower/equal cause that almost feels like a bug in IntMap
23:45:01 <copumpkin> ...unless you're using IntMap.size
23:45:14 <copumpkin> (which is linear on IntMap and constant on Map)
23:45:46 <DanBurton> @src comparing
23:45:46 <lambdabot> Source not found. Sorry.
23:45:48 <RaptorRarr> @pl (\x _ -> x + 1)
23:45:49 <lambdabot> const . (1 +)
23:45:56 <copumpkin> mm_freak: I don't have any of my own numbers around, but my graph code using them was significantly faster than Map Int, too
23:46:29 <RaptorRarr> > let lengthPlz = foldl' (const . (+1)) 0 in lengthPlz [1..10]
23:46:31 <lambdabot>   10
23:48:16 <copumpkin> anyway, bedtime
23:48:31 <edwardk> yes, you need to be awake for livecoding tomorrow
23:49:19 <byorgey> is copumpkin going to create some techno with Agda?
23:49:31 <copumpkin> lol no
23:49:51 <byorgey> awww
23:50:20 <copumpkin> oh I guess livecoding has a music connotation that I was not aware of
23:50:24 <edwardk> his tastes tend to be more classical. it should be a very soothing night
23:50:50 <edwardk> fortunately there is a keyboard he can use in the room
23:58:18 <codemac> is there a way to get something in your Build-Depends list in cabal to be built with special options? I'm tired of manually installing regex-pcre on the mac with --extra-lib-dir=
