00:00:08 <kmc> it doesn't go much into CoC but it's needed prereq if you don't already know that stuff
00:00:13 <edwardk> http://comonad.com/reader/2008/kan-extensions/ and its followups talk about the general concept that gave rise to it
00:00:21 <kmc> it does have chapters on each of the axes of the lambda cube
00:00:29 <earthy> I had seen those
00:00:38 <earthy> (not quite grasped them yet though)
00:00:43 <sanjoyd> I've worked through some of Object Oriented Programming Languages, and have a good idea of System F.
00:00:55 <sanjoyd> I'll have a look at TaPL, thanks. :)
00:02:07 <earthy> *ah*! I'v read the paper by Janis Voigtländer... now I see
00:02:20 <c_wraith> edwardk: how's Codensity IORef working out? :)
00:02:33 <edwardk> c_wraith: works great
00:02:50 <edwardk> c_wraith: CoYoneda IORef is actually even useful
00:03:34 <edwardk> http://hackage.haskell.org/packages/archive/kan-extensions/2.0.2/doc/html/Data-Functor-Yoneda-Contravariant.html
00:04:57 <edwardk> gives you something where you have an IORef that contains some value of some type b, and an action of (b -> a)  -- so you've taken an IORef and removed the ability to write to it (since you don't know what b is) and give you only the 'read' portion of it, but let you fmap to change what you'll read out when you use it
00:05:23 * ddarius should troll through the OOP literature again.
00:09:30 <Cale> Of course, that's pretty close to what readIORef does
00:10:42 <Cale> (if you don't actually execute the resulting action yet)
00:11:21 <edwardk> sure
00:12:01 <edwardk> but you can pass these out to processes and they can run it later. you could of course encapsulate an IO action that holds onto the IORef for you
00:12:20 <c_wraith> well, that's exactly what Cale meant, I think.
00:12:22 <edwardk> but then you wouldn't be able to do anything else that you could do with an IORef
00:13:03 <edwardk> which is more or less just use Typeable1 to see that yup. you have an IORef ;)
00:13:18 <xteensx> http://xteensx.info/    http://xteensx.info/    http://xteensx.info/    FREE PORN
00:16:07 <magn3ts> haha
00:16:12 * DanBurton wonders when the spammers will learn to spam #haskell with FREE THEOREMS
00:16:16 <magn3ts> how spams a probably crummy porn site on haskell?
00:16:25 * magn3ts can't even type who.
00:18:39 <c_wraith> well.  there are 800 people in here
00:18:53 <c_wraith> that makes it one of the largest channels on this network
00:19:01 <magn3ts> really?
00:19:57 <magn3ts> Wow. I vastly over estimated the number of people in other rooms I idle in
00:20:15 <kmc> looks like it's #6 at the moment
00:20:30 <c_wraith> tied with #python
00:20:32 <kmc> tied with #python for biggest language channel
00:20:33 <kmc> hehe
00:20:42 <kmc> unless you consider jquery to be a language
00:26:03 <erus`> how do I declare a 'type' of a tuple of 2 Nums ?
00:26:14 <erus`> type V2 = Num a => (a, a)
00:26:18 <erus`> didnt work
00:26:48 <c_wraith> erus`: you can't do that short of the ConstraintKinds extension...  which is likely to be in ghc 7.4
00:26:58 <yitz> erus`: just use a tuple. put the Num constraint in your function types.
00:27:25 <erus`> ah man
00:35:51 <erus`> can i do this? instance Num (Double, Double, Double) where
00:35:58 <c_wraith> yes
00:36:16 <c_wraith> though it will need FlexibleInstances
00:37:35 <shachaf> And you may not want to.
00:37:39 <kmc> you should probably create a new type instead
00:37:57 <kmc> type R = Double; data R3 = R3 R R R; instance Num R where ...
00:38:13 <shachaf> For instance.
00:38:29 <shachaf> That R would be a newtype if only newtypes were more convenient. :-(
00:38:38 <kmc> better to define your own types and their meaning
00:38:48 <kmc> rather than dictating the meaning of the single global (,,) type
00:39:46 <DanBurton> instance (Num n, Num m, Num l) => Num (n,m,l) where ... -- mwahaha
00:40:39 <erus`> how do i do this? data V3 = Num a => V3 a a a
00:41:05 <kmc> well that syntax doesn't work
00:41:09 <kmc> so what you mean by it is undefined
00:41:23 <kmc> so maybe you should explain what you want instead
00:41:28 <edwardk> erus`: basically what you are trying to do is a bad idea
00:41:41 <edwardk> erus`: put the constraints on the use sites, not the data type
00:42:10 <edwardk> instance Num a => Monoid (V3 a)
00:42:13 <erus`> i wanna create a vector 3d type that can use any Num for its coords
00:42:27 <kmc> then create a vector 3d type which can use any type at all
00:42:29 <edwardk> data V3 = V3 a a a   -- can hold anything for its coords
00:42:42 <kmc> and constrain it at the use sites
00:42:43 <edwardk> then put the constraints on the instances and methods you use to manipulate it
00:42:48 <erus`> kmc but i need to use (+, -, *)
00:43:03 <edwardk> addV3 :: Num a => V3 a -> V3 a -> V3 a
00:43:05 <kmc> so you'll have:  dotProduct :: (Num a) => V3 a -> V3 a -> a
00:43:09 <c_wraith> edwardk: put a type variable in the type, or it's not too useful. :)
00:43:12 <DanBurton> erus`: it's not recommended, but you *can* do it by moving the constraint farther left. data Num n => V3 n = V3 n n n
00:43:20 <edwardk> c_wraith: heh
00:43:26 <edwardk> DanBurton: its been removed from the language
00:43:32 <edwardk> DanBurton: so i don't recommend it =)
00:43:36 <DanBurton> edwardk: since when?
00:43:36 <c_wraith> erus`: what DanBurton recommends isn't recommended because it's worse than useless :)
00:43:39 <c_wraith> 7.2
00:43:56 <erus`> ok i will move the constraints to the functions
00:43:59 <DanBurton> ghc 7.2? what about the haskell report? was it ever in that?
00:44:02 <c_wraith> and seriously, worse than useless
00:44:06 <kmc> it's not recommended and it won't do what you want erus`
00:44:12 <edwardk> it was in the report, but its absolutely useless
00:44:14 <DanBurton> doesn't Data.Set use it or something?
00:44:27 <kmc> if you really *really* want this in GHC, you can use a GADT
00:44:33 <shachaf> erus`: When you said "data V3 = V3 a a a", did you mean for V3 to take "a" as a parameter?
00:44:35 <edwardk> http://www.haskell.org/pipermail/haskell/2011-January/022497.html
00:44:46 <kmc> data V3 a where { V3 :: (Num a) => a -> a -> a -> V3 a }
00:44:54 <kmc> that will do roughly what you want
00:45:02 <edwardk> there was a quiet Haskell 2011 addendum that introduced the removal of data type contexts
00:45:02 <kmc> but it's probably not worth it
00:45:05 <erus`> but thats a bad idea?
00:45:06 <edwardk> but no report
00:45:13 <edwardk> erus`: correct
00:45:16 <kmc> erus`, stick to simplicity
00:45:22 <kmc> especially if you're new to the language
00:45:33 <luite_> DanBurton: it has the constraints at the use sites
00:45:37 <luite_> @type Data.Set.fromList
00:45:37 <lambdabot> forall a. (Ord a) => [a] -> S.Set a
00:45:42 <luite_> @type Data.Set.singleton
00:45:43 <lambdabot> forall a. a -> S.Set a
00:45:47 <kmc> :t S.singleton (id :: Int -> Int)
00:45:48 <lambdabot> S.Set (Int -> Int)
00:45:49 <edwardk> erus`: you'll find life is much better when you can see at the use sites what the constraints are, because you aren't carrying around a bunch of irrelevant crap you aren't using
00:45:59 <edwardk> it gives you stronger parametricity guarantees, etc.
00:46:20 <kmc> > S.size (S.singleton (id :: Int -> Int))
00:46:21 <lambdabot>   1
00:46:38 <edwardk> DanBurton: the two use cases that were in the prelude were Complex and Ratio
00:47:00 <edwardk> both had useless constraints preventing you from putting values in the constructor that weren't RealFloats or Integral respectively
00:47:01 <DanBurton> @info Set
00:47:01 <lambdabot> Set
00:47:06 <DanBurton> boo
00:47:09 * hackagebot zoom-cache 0.6.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.6.0.0 (ConradParker)
00:47:10 * hackagebot zoom-cache-pcm 0.1.1.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.1.1.0 (ConradParker)
00:47:14 <kmc> i heard the feature was added for the Eval class in Haskell ≤1.4
00:47:22 <edwardk> kmc: yeah
00:47:32 <kmc> you'd be required to put an Eval constraint on any variable used at a strict field
00:47:33 <edwardk> back then you needed it to talk about ! patterns
00:47:47 <ddarius> No Gaussian Integers for you.
00:47:53 <kmc> data Eval t => StrictPair t = StrictPair !t !t
00:47:59 <edwardk> but since then its just sat around as a way to force a proof obligation to use the constructor, but it doesn't give you a dictionary, ever.
00:48:04 <edwardk> ddarius: exactly
00:48:28 <edwardk> gaussian integers are precisely why it used to piss me off. even if i made my own numeric types i couldn't reuse the complex number type
00:48:42 <shachaf> Why not?
00:49:19 <edwardk> shachaf: data RealFloat a => Complex a = !a :+ !a
00:49:45 <edwardk> which is silly because you wind up with constraints like
00:49:47 <shachaf> Oh, they had that constraint?
00:49:48 <edwardk> Read a => Read (Complex a)
00:50:01 <edwardk> but you couldn't put any thing that wasn't also RealFloat a in there in the first place
00:50:02 <edwardk> yes
00:50:07 <ddarius> @src Complex
00:50:08 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
00:50:20 <edwardk> now it is mercifully absent
00:50:21 <edwardk> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Complex.html
00:51:07 <edwardk> now it just needs Functor, Foldable, Traversable, etc instances ;)
00:51:25 <edwardk> though one might argue against them given the ! annotations
00:51:32 <ddarius> Not a Semigroupoid instance?
00:51:45 <edwardk> only one type arg =)
00:51:49 <DanBurton> @where nodatatypecontexts
00:51:49 <lambdabot> I know nothing about nodatatypecontexts.
00:52:05 <DanBurton> @where+ nodatatypecontexts http://www.haskell.org/pipermail/haskell/2011-January/022497.html
00:52:05 <lambdabot> Nice!
00:52:09 <ddarius> Doesn't Semigroupoid take * -> * ?
00:52:12 * hackagebot zoom-cache-sndfile 0.1.1.0 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.1.1.0 (ConradParker)
00:52:25 <edwardk> http://hackage.haskell.org/packages/archive/functor-apply/0.10.5/doc/html/src/Data-Semigroupoid.html
00:52:27 <hpaste> erus` pasted “can i make an instance for every type in Num?” at http://hpaste.org/53783
00:52:32 <edwardk> * -> * -> *
00:52:42 <edwardk> its arrowish
00:53:10 <edwardk> maybe you're thinking Apply, Bind, Extend, etc?
00:53:28 <DanBurton> erus`: what?
00:54:12 <erus`> i have todo "instance Num (V3 Double)" instance Num (V3 Int)"  etc
00:54:19 <kmc> erus`, instance (Num a) => Num (V3 a) where ...
00:54:25 <DanBurton> ^
00:54:45 <edwardk> erus`: note; instance Num a => Num (V3 a) is a bit tricky. you can get + and - just fine, and even abs and signum, but * is tricky
00:54:50 <kmc> this is actually the way it's supposed to work in standard Haskell
00:55:05 <DanBurton> The disadvantage being, you cant do instance Num V3 b where ... for any non-num b and expect it to work, afaik
00:55:09 <edwardk> since what do you want the multiplication of vectors to yield?
00:55:14 <kmc> whereas (V3 Double) requires FlexibleInstances
00:56:05 <erus`> the abs of a vector is its magnitude right?
00:56:22 <DanBurton> depends
00:56:23 <kmc> :t abs
00:56:24 <lambdabot> forall a. (Num a) => a -> a
00:56:27 <kmc> not gonna work
00:56:32 <DanBurton> you'll have to return a vector type
00:56:37 <edwardk> erus`: the norm of it would be, but Num's abs and signum aren't a norm
00:56:46 <DanBurton> s/return/produce
00:56:46 <frerich> This is probably a frequently asked question, so feel free to yell at me for my inability to google stuff but - how do you people deal with two (different) records having the same field name (say, "data X = X { a :: Int }" and "data Y = Y { a :: Int }"? Do you actually rename them, or move them into separate modules, or something else?
00:57:26 <kmc> erus`, you should consider defining your own operators instead of trying to use Num
00:57:49 <DanBurton> freirich: it depends. One way is to merge them in the same type: (say, "data Z = X {a :: Int} | Y {a :: Int }")
00:58:16 <kmc> bbl
00:58:28 <edwardk> if you want a full Num you need to embrace * as pointwise multiplication, then you can have abs and signum by elementwise abs and elementwise signum
00:58:37 <DanBurton> freirich: another way is with typeclasses
00:58:52 <edwardk> and the abs a * signum a = a law that Num puts on us is satisfied
00:59:09 <ion> I’d expect a Num instance for a vector or matrix type to implement elementwise operations between equally-sized values and non-Num operators to implement stuff like dot products and matrix inversion.
00:59:40 <edwardk> frerich: class HasA t where a :: t -> Int
00:59:54 <edwardk> instance HasA X where a (X i) = i
00:59:56 <frerich> DanBurton: To be honest, I also considered typeclasses. But one of the things I learned is that when I want a typeclass, Iusually don't. I just didn't realize why, yet. ;-)
01:00:01 <edwardk> instance HasA Y where a (Y i) = i
01:00:08 <edwardk> then you can use 'a' for either
01:00:41 <edwardk> here you're just using a class for sugar, which is somewhat dubious, but doable.
01:00:50 <ddarius> class IsA a b ...
01:01:11 * DanBurton wonders if you can use lenses on typeclass functions. Surely you can...right?
01:01:16 <edwardk> yes
01:01:26 <edwardk> you can also make lenses be the typeclass members
01:01:38 <DanBurton> true point
01:01:51 <DanBurton> which is better in general?
01:02:09 <edwardk> my usual idiom is to make a typeclass that describes how to get a class HasFoo t where foo :: t :-> Foo
01:02:24 <edwardk> then I make composed lenses for all of Foo's members that precompose that arrow
01:02:27 <edwardk> that way you get a bunch of
01:02:39 <edwardk> fooMember :: HasFoo t => t -> FooMember
01:03:09 <edwardk> then with instance HasFoo Foo where foo = id
01:03:34 <edwardk> you can use its members just like you usually would, but you can also access it when you make Foo part of a larger state, etc.
01:03:49 <DanBurton> oohhh nice
01:04:00 <edwardk> This way I can make a 'HasDiagnosticState' class, one for HasLocaleState, etc.
01:04:13 <edwardk> and just work with the composite state object and a handful of instances
01:04:29 <edwardk> and all the deep member accesses just work
01:05:13 <edwardk> i've been debating about adding support to data-lens-template to automatically generate said class and said composed accessors
01:05:15 <ddarius> Kissimmee, FL
01:05:58 <hpaste> erus` pasted “What is wrong?” at http://hpaste.org/53784
01:06:46 <ddarius> a /= b
01:07:28 <edwardk> len :: Floating a => V3 a -> a
01:07:39 <edwardk> you want the result type to be the same type as that of the elements of the vector
01:07:57 <Cale> frerich: I vote for just renaming them. Usually I'll invent a mnemonic prefix of a couple characters or so for the fields of a given record type if they'd otherwise seem too generic.
01:08:02 <edwardk> otherwise you need to use some kinda fromIntegral or realFrac, method to convert
01:08:10 <erus`> edwardk: ah
01:08:11 <edwardk> which is probably not what you want
01:08:15 <DanBurton> "needs more fromIntegral"
01:08:16 <erus`> why not
01:08:21 <edwardk> Floating a implies Num a
01:08:23 <ddarius> Why would you?
01:08:36 <edwardk> which was part of how i simplified your type
01:08:37 <erus`> because the vector doesnt need to be a Fractional
01:08:42 <erus`> it could be an Integer
01:08:54 <edwardk> erus`: correct. but you can convert it to one that is
01:09:00 <edwardk> using Functor
01:09:07 <edwardk> which we can add an instance of momentarily
01:09:25 <edwardk> instance Functor V3 where fmap f (V3 a b c) = V3 (f a) (f b) (f c)
01:09:38 <edwardk> :t fromIntegral
01:09:39 <lambdabot> forall a b. (Integral a, Num b) => a -> b
01:09:43 <edwardk> :t fmap fromIntegral
01:09:44 <lambdabot> forall a b (f :: * -> *). (Integral a, Num b, Functor f) => f a -> f b
01:09:57 <edwardk> :t from realFrac
01:09:57 <erus`> ah this gets ugly :)
01:09:58 <lambdabot> Not in scope: `from'
01:09:59 <lambdabot> Not in scope: `realFrac'
01:10:18 <edwardk> actually it gets quite elegant, because you'll find this idiom works over almost EVERYTHING =P =)
01:10:19 * ddarius would recommend quadrance rather than magnitude if you are not going to be using real numbers.
01:10:24 <edwardk> yes
01:10:42 <edwardk> quadrance :: Num a => V3 a -> a
01:11:14 <edwardk> quadrance (V3 a b c) = a*a + b*b + c*c  -- its usually 'normSq' or some nonsence in c libs
01:11:33 <edwardk> nonsense
01:13:27 <ddarius> 何sense
01:15:41 <hpaste> o-_-o pasted “max function for Data.Vector” at http://hpaste.org/53785
01:16:06 <o-_-o> dft: ./Data/Vector/Generic.hs:244 ((!)): index out of bounds (4096,4096)
01:16:16 <o-_-o> This fails with this error, anyone know why ?
01:16:40 <o-_-o> Why does the above max function fail for Data.Vector ?
01:17:54 <hpaste> DanBurton annotated “What is wrong?” with “My thoughts, untested” at http://hpaste.org/53784#a53786
01:18:19 <quicksilver> o-_-o: well if you call it on an empty vector it's going to call DV.tail on the empty vector
01:18:28 <Lemmih> o-_-o: How abut using DV.foldl1'?
01:18:36 <quicksilver> for vectors of size >=1 it looks OK to me
01:19:02 * ddarius would want a less specific fold.
01:19:19 <edwardk> :t foldMap
01:19:20 <lambdabot> Not in scope: `foldMap'
01:19:24 <edwardk> :t Data.Foldable.foldMap
01:19:26 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
01:19:52 <erus`> can i add multiple instances
01:20:03 <edwardk> erus`: such as?
01:20:13 <erus`> for example i might wanna multiply a matrix by a matrix or a matrix by a vector
01:20:34 <edwardk> erus`: for those things you typically wind up with different classes, note that
01:20:34 <o-_-o> Lemmih: I don't know how to write max with foldl, that would be next project *sigh*
01:20:36 <edwardk> :t (*)
01:20:37 <lambdabot> forall a. (Num a) => a -> a -> a
01:20:50 <edwardk> is set up so it only takes the same type on either side
01:20:53 <ddarius> @src maximum
01:20:53 <lambdabot> maximum [] = undefined
01:20:53 <lambdabot> maximum xs = foldl1 max xs
01:20:57 <ddarius> ...
01:21:03 <erus`> ah i see
01:21:06 <DanBurton> erus`: if you *really* want to do that, then make vectors and matrices be two different constructors of the same type
01:21:09 <shachaf> DanBurton: Why not Applicative?
01:21:17 <DanBurton> erus`: I wouldn't recommend that, though
01:21:18 <ddarius> DanBurton: That would be evil.
01:21:21 <DanBurton> shachaf: too lazy
01:21:23 <shachaf> DanBurton: Also, your thoughts use tabs? :-(
01:21:26 <edwardk> DanBurton: you keep suggesting this, but its a terrible idea
01:21:29 <o-_-o> The funny thing is that the above function works fine in the interactive ghci
01:21:35 <o-_-o> ddarius: hmmm
01:21:43 <shachaf> DanBurton: But not too lazy to write out liftA2 yourself? :-)
01:21:44 <DanBurton> my thoughts kept some of the tabs that were already there :P
01:21:56 <DanBurton> shachaf: it was straightforward :P lol
01:22:18 <ddarius> However, if you made an arbitrary tensor type, you could perhaps force your way all the way through back into goodness.
01:22:41 <edwardk> erus`: i tend to represent vectors as functors or traversables that hold values, and matrices as containers of containers. subject to shape constraints of some sort
01:22:45 * ddarius recommends Ralf Hinze's recent paper on Applicative.
01:22:46 <DanBurton> shachaf: how would you write <*> for that data type?
01:23:11 <ddarius> (<*>) = liftA2 ($)
01:23:13 <edwardk> erus`: my 'ad' package uses this extensively to deal with automatic differentiation of values in arbitrary user-supplied shapes
01:23:16 <shachaf> V3 x0 y0 z0 <*> V3 x1 y1 z1 = V3 (x0 x1) (y0 y1) (z0 z1) -- ?
01:23:27 <shachaf> Or in terms of liftV2, yes.
01:23:41 <edwardk> DanBurton: its a fixed length vector, so the ziplist applicative and diagonal monad apply
01:24:02 <DanBurton> edwardk: diagonal monad apply?
01:24:06 <DanBurton> what's that?
01:24:25 <edwardk> the diagonal monad applies to the type
01:24:37 <shachaf> The diagonal monad is like ZipList but extended to Monad for fixed-length lists?
01:24:44 <edwardk> given data V a = V { x,y,z:: a}
01:25:01 <ddarius> "Functional Pearl: The Bird Tree"
01:25:20 <edwardk> V a b c >>= f = V (x (f a)) (y (f b)) (z (f c))
01:25:25 <edwardk> return a = V a a a
01:25:50 <edwardk> basically you use the function to build an entire vector and throw away everything but the entry that matches up with you
01:26:09 <edwardk> if you think about it its the same monad as (->) e    for some 3-valued type e
01:26:30 <DanBurton> ah I see
01:26:30 <edwardk> data XYZ = X|Y|Z   -- then XYZ -> a    is isomorphic to V a
01:26:40 <edwardk> so its just the reader monad in disguise
01:26:49 <edwardk> but memoized through through ADT
01:27:02 <Blkt> good morning everyone
01:28:20 <ddarius> Hinze hides his papers.
01:28:21 <edwardk> in general you can abstract away the particular vectors and containers you're working with though
01:28:30 <ddarius> @google "Lifting Operators and Laws"
01:28:33 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
01:28:33 <lambdabot> Title: Lifting Operators and Laws
01:29:20 <edwardk> jacobian :: (Traversable f, Functor g, Num a) => (forall s. Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (f a) -- takes a user specified function from a f full of as to a g full of as
01:29:21 <ddarius> What edwardk is rying to say is it is representable.
01:29:31 <edwardk> that too
01:29:44 <edwardk> but what i was going to here is traversable and functor
01:30:00 <ddarius> I'm a little behind.
01:31:29 <ddarius> A*A*A = A^1 * A^1 * A^1 = A^(1+1+1)
01:32:38 <edwardk> in general i've found that parameterizing your shapes on traversable/functor yields nicer APIs than tying it to some particular vector type, etc.
01:33:06 <edwardk> its a shame i can't get complex numbers to work out properly for that api, at least with nicely complex derivatives
01:35:37 * ddarius feeds research papers to coworkers.
01:35:55 <shachaf> ddarius has coworkers?
01:36:52 <ddarius> edwardk: Do you have any suggestions for a good introduction to Fourier analysis for someone who only knows enough linear algebra to do 3D graphics?
01:37:12 <edwardk> let me check my shelf for the book title
01:37:53 <ddarius> I guess any good recommendations for a good introduction to linear algebra would probably also be prudent.
01:39:55 <edwardk> the only fourier analysis book i sill have is folland.
01:40:03 <edwardk> 'fourier analysis and its applications'
01:40:09 <edwardk> not sure i'd recommend it at that level
01:40:25 <edwardk> if they are willing to take a detour through wavelets i might have some recommendations
01:40:48 <ddarius> Wavelets wouldn't hurt.
01:40:59 * ddarius doesn't think he's every had a gyro with onions...
01:41:28 <shachaf> I don't think onion are generally use in the manufacture of gyroscopes.
01:41:43 <edwardk> trying to find the book, it was the second or third i'd read on wavelets and was written by a non-mathematician
01:42:14 <ddarius> edwardk: How recent is it?
01:42:16 <ddarius> Roughly.
01:42:31 <edwardk> ;the world according to wavelets by barbara burke hubbard
01:42:31 <hpaste> erus` pasted “More type error fun” at http://hpaste.org/53787
01:42:39 <edwardk> 97-98
01:42:42 <erus`> could someone look at that please? :)
01:43:03 * ddarius finds the push-pull formalization of wavelets more intuitive.  It's also more general, easier to implement, and faster.
01:43:17 <edwardk> it gives a solid introduction to haar wavelets which are of course trivial, but goes into continuous wavelets, daubechies, etc
01:43:17 <shachaf> erus`: (1 / whatever) won't return an Integral.
01:43:22 <shachaf> So don't fromIntegral it. :-)
01:43:32 <ddarius> erus`: Don't use (***) for scaling.
01:43:44 <edwardk> but its also a good introduction to the whole heisenberg uncertainty/nyquist rate issues
01:43:55 <edwardk> so if he's got no intution for the domain it'll help give him some
01:44:23 <erus`> without from Integral i get two errors
01:44:26 <ddarius> edwardk: It's Mo, but think applications to image/video compression.
01:44:30 <edwardk> ah
01:44:41 <erus`> Could not deduce (Fractional a) arising from a use of `/' and Could not deduce (Floating a) arising from a use of `len'
01:44:54 <edwardk> then for mo, definitely start with that, plus you can tell him i used to use the haar wavelet stuff for texture compression
01:44:55 <edwardk> ;)
01:45:28 <ddarius> Want to trade?  I'll give you your books, then you'll give me your books, then I'll give your books away.
01:45:42 <edwardk> hah
01:45:55 <edwardk> i don't know if i have the wavelet one here
01:46:04 <Jafet> erus: try to differentiate between errors that are introduced by adding code, and errors that are revealed by removing code
01:46:08 <edwardk> i have folland though
01:46:26 <Jafet> s/adding/removing/
01:46:31 <edwardk> thats pretty dense for mo though
01:47:09 * hackagebot scion-browser 0.1.3.1 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.1.3.1 (AlejandroSerrano)
01:47:13 <edwardk> now that i have an audience in mind let me go skim
01:47:29 <ddarius> Any good linear algebra book would be useful.
01:48:47 <opqdonut> is there a nice way to cabal build with profiling?
01:49:04 <quicksilver> yes.
01:49:16 <shachaf> opqdonut: cabal configure with profiling.
01:49:21 <edwardk> okay. i apparently lied. i have a bunch more fourier books i was just on the wrong shelf
01:49:26 <shachaf> opqdonut: Alternatively, add "with profiling" to your cabalrc.
01:49:35 <shachaf> Then all packages will use profiling.
01:49:38 <quicksilver> --enable-executable-profilng or --enable-library-profiling resp
01:49:48 <quicksilver> or add it to your config file indeed
01:50:50 <edwardk> http://press.princeton.edu/titles/7562.html
01:51:07 <opqdonut> okay, but I still need to do the -p --reinstall dance with all my libraries...
01:51:14 <quicksilver> yes
01:51:16 <opqdonut> with manual dependency resolution...
01:51:36 <quicksilver> yes
01:51:40 <opqdonut> oh well
01:51:58 <edwardk> thats the first volume we used at eastern on the topic. i also have a fluffier boundary value problems book that is probably better for this audience
01:51:58 <edwardk> i have a couple of random linear algebra text books you can loan him as well
01:53:29 <edwardk> neither of the linear algebra ones is all THAT great, but meh, its linear algebra, he has some intuition there
01:53:46 <ddarius> It's hard to find an excellent linear algebra book.
01:55:48 <edwardk> one approach might be to feed him beutelspacher and rosenbaum, which is a book on projective geometry, which goes through and proves that all projective geometries can be worked with via linear algebra, but only after it goes through and gives you the geometric interpretation of everything
01:56:24 <edwardk> i'd be loathe to lose the book though, its a cheap soft cover, but i've bought replacements for it 4 times now
01:57:27 * ddarius should check if he still has a copy of Stranger in a Strange Land or whether he'll need to buy that yet again.
01:57:57 <ddarius> Projective Geometry from foundations to applications ?
01:58:17 <edwardk> thats the one
01:58:31 <edwardk> not sure why but the presentation of that stuck with me
01:59:12 <edwardk> wow its not so much a cheap softcover these days
01:59:38 <edwardk> i think i bought the last 3 copies for $19 or so each now its $60-120
02:00:58 <edwardk> another way to get him out of 3+1 dimensions is to hand him something that needs more freedom, like nurbs
02:01:28 <edwardk> iirc http://www.amazon.com/NURBS-Book-Monographs-Visual-Communication/dp/3540615458 was good for that sort of thing
02:02:00 <edwardk> or http://www.amazon.com/Nurbs-Projective-Geometry-Practical-Use/dp/1568810849/ref=pd_sim_b_5
02:03:05 <edwardk> and you never know when you'll be sitting in front of the technical director from toy story 1 and 2 explaining nurbs slicing to a guy
02:03:24 <edwardk> (happened to me at gsoc)
02:07:03 <HugoDaniel> :D
02:07:12 <HugoDaniel> i like nurbs, i have this book i used to read a lot
02:07:35 <HugoDaniel> yes, its that one, the monographs in visual communication
02:07:45 <edwardk> lemme guess, back when rhino was coming on the scene? =)
02:07:53 <HugoDaniel> eheh
02:08:25 <HugoDaniel> no, i just like nurbs
02:08:28 <edwardk> fair nuff
02:08:36 <HugoDaniel> it makes more sense to me than just triangles everywhere
02:08:47 <HugoDaniel> so i bought that book and read it and took notes and all
02:08:52 <HugoDaniel> even tried to implement some of it in haskell
02:08:55 <edwardk> they were really challenging for me when i was getting started with them because the math was at the time right at the limit of what i could do
02:09:34 <HugoDaniel> :)
02:09:59 <sgronblo> Does Haskell's Maybe monad implement the "Maybe pattern"?
02:10:02 <edwardk> then i got better, which is why i think they make a nice intro to thinking about homogeneous coordinate systems
02:10:16 <edwardk> we have patterns now? thats it. i'm out
02:10:28 <sgronblo> specifically as shown on this page http://code.google.com/p/tokland/wiki/RubyIdioms
02:11:06 <edwardk> oh, thats just the role of >>=
02:11:10 <edwardk> so yes
02:11:20 <sgronblo> to me this doesn't seem to really do the same thing as haskell's maybe
02:11:39 <edwardk> well, the idea is you chain computation in the monad that way
02:11:54 <ddarius> "This book is complete, but there is too many math formula."
02:12:09 <edwardk> lookup i m >>= \a -> lookup j m >>= \b -> ...
02:12:28 <edwardk> is chaining like in that example there, if one fails the overall result is Nothing
02:12:29 <sgronblo> or is the fact that you can use pattern matching to make sure you handle Nothings to a function just a bonus?
02:12:36 <edwardk> its a bonus
02:12:45 <edwardk> you can check for nil by comparison in ruby too =)
02:13:06 <sgronblo> yeah but you have to remember to do it manually
02:13:08 <_Vi> pointfree gives if' function. Hoogle can't find it. What is it?
02:13:11 <edwardk> yeah
02:13:14 <shachaf> @src if'
02:13:14 <lambdabot> Source not found. It can only be attributed to human error.
02:13:21 <shachaf> if' x y z = if x then y else z
02:13:26 <sgronblo> there's no compiler that tells you've forgotten to dealwith that case
02:13:33 <edwardk> if' b t e | b = t   | otherwise = e
02:13:45 <HugoDaniel> :D
02:13:53 <edwardk> or if' True t _ = t; if' False _ e = e
02:13:55 <_Vi> "Not in scope: `if''"
02:14:05 <ddarius> if' b t e = [t,e]!!fromEnum b
02:14:14 <shachaf> _Vi: We just provided three^H^H^H^H^Hfour definitions of it. :-)
02:14:22 <ion> ^W
02:14:36 <shachaf> Although the type that will be inferred for ddarius's definition makes me nervous.
02:14:39 <_Vi> So, "pointfree" can give things that are not standard.
02:14:56 <edwardk> shachaf: but don't you want to be able to use if then else from ordering?
02:14:56 <shachaf> _Vi: Well, it needs to be able to match on booleans somehow.
02:14:59 <ion> I want «bool :: a -> a -> Bool -> a» like «maybe» and «either».
02:14:59 <quicksilver> _Vi: if' is the only example that springs to mind.
02:15:12 <quicksilver> just because there isn't anything to pointfree Bools in the standard lib
02:15:39 <shachaf> _Vi: @pl isn't a magic box. It's just a thing that does things.
02:15:42 <edwardk> @hpaste
02:15:43 <lambdabot> Haskell pastebin: http://hpaste.org/
02:15:45 * shachaf is clearly too tired to form sentences.
02:15:57 <hpaste> edwardk pasted “IfThenElse” at http://hpaste.org/53789
02:16:00 <edwardk> for shachaf
02:16:06 <ddarius> Magic boxes are things that don't do things, or non-things that do things.
02:16:09 <edwardk> thats how one should define if'
02:16:20 <_Vi> If the code generated by "pointfree" does not compile does it mean some bug or it may be by design?
02:16:39 <quicksilver> pointfree is full of bugs
02:16:43 <edwardk> _Vi: @pl does somethings that aren't correct
02:16:48 <quicksilver> it doesn't have a haskell parser
02:16:51 <erus`_> how can i: Integral -> Floating ?
02:16:54 <quicksilver> so it mis-parses some constructs
02:16:58 <quicksilver> erus`_: fromIntegral
02:16:59 <edwardk> :t fromIntegral
02:17:00 <lambdabot> forall a b. (Integral a, Num b) => a -> b
02:17:26 <ddarius>  @pl does a lot of crazy crap.
02:17:42 <edwardk> :t read . show
02:17:44 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
02:17:46 <edwardk> =)
02:17:55 * edwardk hides
02:18:04 <shachaf> edwardk: What's "iff"?
02:18:54 <edwardk> shachaf: ah that is the implementation inside of the Symantics stuff below
02:19:12 * shachaf ought to get a GHC that supports this Constraint thing.
02:19:14 <edwardk>   iff   :: t Bool -> t a -> t a -> t a
02:19:42 <shachaf> edwardk: Isn't there a "()" Constraint, by the way, instead of using Trivial?
02:19:55 <edwardk> that requires that i make the constraint take the extra argument
02:20:04 <edwardk> which means that there becomes contexts in which i can't dispatch
02:20:14 <shachaf> Oh, I see.
02:20:23 <shachaf> It's Trivial a, not just Trivial.
02:20:30 <edwardk> i want the * -> Constraint to be know regardless of a
02:20:32 <shachaf> Which I suppose is the point.
02:20:40 <edwardk> to be known
02:20:40 <edwardk> yeah
02:20:50 <ddarius> data BetterBool :: * -> * -> * -> * where TTrue :: BetterBool a b a; FFalse :: BetterBool a b b
02:20:52 <edwardk> i actually went and made it Constraint for a while
02:21:29 <edwardk> why * -> * -> * -> * rather than something polymorphic?
02:21:54 <edwardk> think of the Functors!
02:22:08 <ET_> @pl let cm f = concat . map f
02:22:08 <lambdabot> (line 1, column 26):
02:22:08 <lambdabot> unexpected end of input
02:22:09 <lambdabot> expecting variable, "(", ".", "`", "!!", operator, ";" or "in"
02:22:21 <shachaf> @pl cm f = concat . map f
02:22:21 <lambdabot> cm = (=<<)
02:22:21 <ET_> @pl let cm f = concat . (map f)
02:22:21 <lambdabot> (line 1, column 28):
02:22:22 <lambdabot> unexpected end of input
02:22:22 <lambdabot> expecting variable, "(", ".", "`", "!!", operator, ";" or "in"
02:22:39 <_Vi> @pl fib = \x -> if x < 2 then 1 else (fib (x-1)) + (fib (x-2)) -- Can it work?
02:22:40 <lambdabot> fib = fix (ap (flip if' 1 . (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
02:22:40 <shachaf> ...Well.
02:23:15 <gimme> @pl f x = x
02:23:16 <lambdabot> f = id
02:23:56 <ddarius> @pl \x -> x x
02:23:56 <lambdabot> join id
02:24:12 <shachaf> @pl join id (join id)
02:24:12 <lambdabot> join id (join id)
02:24:23 <shachaf> @pl (\x -> x x) (\x -> x x)
02:24:24 <quicksilver> _Vi: looks fine to me.
02:24:26 <lambdabot> ap id id (ap id id)
02:24:26 <lambdabot> optimization suspended, use @pl-resume to continue.
02:24:27 <shachaf> Silly @pl.
02:24:32 <ion> @pl-resume
02:24:39 <lambdabot> ap id id (ap id id)
02:24:39 <lambdabot> optimization suspended, use @pl-resume to continue.
02:24:46 <ion> @pl-resume
02:24:50 <Saizan> ion: don't
02:24:55 <shachaf> ion: I think we kind of know where it goes from here.
02:24:58 <lambdabot> ap id id (ap id id)
02:24:58 <lambdabot> optimization suspended, use @pl-resume to continue.
02:25:11 <Saizan> @pl id
02:25:11 <lambdabot> id
02:25:23 <ddarius> @pl-resume
02:25:23 <lambdabot> pointless: sorry, nothing to resume.
02:25:57 <shachaf> @pl (\e -> e е) (\e -> е e)
02:25:57 <lambdabot> е е
02:26:11 <Saizan>  @pl'ing some non-terminating stuff like that used to be a good way to kill lambdabot, should be fixed now but i wouldn't try to stress it
02:26:29 <_Vi> quicksilver, But fails to work ("No instance for (Monad...") even if I specify the type of "fib".
02:26:43 <quicksilver> >  let if' b t e = if b then t else e; fib = fix (ap (flip if' 1 . (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2)) in fib 10
02:26:44 <ddarius> It'd probably be more stressful if the term actually grew.
02:26:45 <lambdabot>   89
02:26:57 <quicksilver> _Vi: you need Control.Monad.Instances for the monad instance for (->)
02:27:43 <_Vi> quicksilver, Oh, now works. So, "No instance for" usually means "You missed an import", doesn't it?
02:28:11 <shachaf> _Vi: Or it means that there's actually no instance. Or that you have a type error.
02:28:17 <shachaf> Actually it always means the latter.
02:28:19 <DaIRC49157> how much mem do i need to install haskell platform (x86-32) and use it reasonably tolerably?
02:28:43 <_Vi> shachaf, How to use Hoogle to check what to import when I see this message? What to search for?
02:28:48 <_Vi> s/this/such/
02:28:50 <shachaf> If you're amnesiac, you'll probably run into trouble.
02:29:06 <shachaf> _Vi: I don't know what would have found it in that particular case.
02:29:16 <quicksilver> _Vi: best way to find that one was to ask here.
02:29:19 <quicksilver> but it's a rare case.
02:29:28 <quicksilver> in general instances are defined by their types and this doesn't happen.
02:29:40 <quicksilver> The Control.Monad.Instances cases are unusual.
02:30:02 <ddarius> DaIRC49157: It's just a bunch of libraries and the compiler.
02:30:02 <_Vi> BTW is there comprehensive list of imports that satisfy things that "pointfree" generates?
02:30:58 <DaIRC49157> ddarius, yes, i'm asking basiclly if i can run ghc and related stuff in a 128mb machine or if i have to cross compile
02:31:00 <quicksilver> no, _Vi
02:32:00 <quicksilver> _Vi: IIRC, Control.Monad.Fix and Control.Monad.Instances is all.
02:32:25 <dmwit> > 1263 / 64
02:32:26 <lambdabot>   19.734375
02:33:54 <quicksilver> DaIRC49157: doubt you'll be able to compile much in 128MB
02:33:59 <quicksilver> small programs possibly.
02:34:09 <quicksilver> I know I've compiled stuff in a 256M VM though.
02:34:20 <quicksilver> admittedly with an older ghc
02:34:55 <DaIRC49157> hmm thanks
02:36:07 <_Vi> Why when "cabal install" compiles things it occupies memory increasingly (until OOM) unless restarted. Is it a memory leak?
02:36:54 <ddarius> I used to use GHC on a computer with 64MB of RAM.
02:37:57 <DaIRC49157> hmm, is there a reasonable procedure for cross compiling and installing necessary libs etc on target box?
02:38:18 <quicksilver> DaIRC49157: I'd be inclined to use some distro's binary packaging
02:38:28 <quicksilver> since they've got all those problems sorted.
02:38:41 <ddarius> DaIRC49157: If you actually have to cross compile, then you are probably pretty screwed.  If you have roughly the same OS and architecture, then just compile them and copy the files.
02:42:09 * hackagebot splot 0.2.8 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.8 (EugeneKirpichov)
02:45:24 <DaIRC49157> thanks, sorry, yeah i do plan to install binaries, what i meant was if i want to compile and run my own program (foo.hs say) what do i need on the target machine?
02:45:34 <DaIRC49157> just make staticly liked binaries, or install .so's or what?
02:46:06 <quicksilver> the standard setup under linux is to statically link everything except libc and libgmp
02:46:18 <quicksilver> so you need to be using roughly the same version of the same OS on the target machine
02:46:25 <quicksilver> so that the libc and libgmp versions match
02:46:28 <DaIRC49157> hmm thanks.   yeah i can arrange that
02:46:30 <DaIRC49157> target is a vps
02:54:16 <interglacial> hi, is it possible to create functions that can be used as infix operators without having to use the backticks?
02:54:41 <dmwit> For sure.
02:54:42 <yitz> interglacial: yes, define them as operators
02:54:50 <dmwit> You use them all the time, like + and * and >>
02:55:12 <yitz> interglacial: use only operator characters in the name
02:55:25 <interglacial> ah ok thanks!
02:55:46 <DaIRC49157> > let (a <> b) = a**2 + b**2 in 3 <> 4
02:55:47 <lambdabot>   <no location info>: Parse error in pattern
02:56:05 <yitz> DaIRC49157: without the parens
02:56:06 <DaIRC49157> > let (a <*> b) = a**2 + b**2 in 3 <*> 4
02:56:06 <lambdabot>   <no location info>: Parse error in pattern
02:56:12 <DaIRC49157> > let a <*> b = a**2 + b**2 in 3 <*> 4
02:56:13 <lambdabot>   25.0
02:56:26 <DaIRC49157> yx
02:56:29 <DaIRC49157> tx
02:56:49 <interglacial> thanks, i was just using standard lowercase characters for the name, will try that
02:57:20 <yitz> > let x !&$%*+ y = x ^ y in 3 !&$%*+ 7
02:57:21 <lambdabot>   2187
03:08:49 <erus`> Double is an Integral right?
03:09:26 <ion> …
03:09:26 <Saizan> nope.
03:09:46 <mysticc> erus`: check :i Integral in ghci
03:09:57 <Saizan> you can convert an Integral to Double using fromIntegral
03:10:31 <ion> Also :i Double. (Double is Traversable right?)
03:11:19 <mysticc> ion: Traversable ??
03:12:39 <erus`> i need a Num -> Floating
03:12:47 <ion> :t realToFrac
03:12:48 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
03:13:20 <quicksilver> erus`: fromIntegral and realToFrac are the only "lossless" conversion functions you ever need.
03:13:29 <mysticc> :t fromIntegral
03:13:30 <lambdabot> forall a b. (Integral a, Num b) => a -> b
03:13:41 <quicksilver> round/ceil/floor are the lossy ones (into integral types)
03:14:03 <quicksilver> (realToFrac is technically not lossless but it has a different feel at least)
03:14:22 <ion> > (realToFrac :: Float -> Rational) . (realToFrac :: Rational -> Float) $ (1/3)
03:14:23 <lambdabot>   11184811 % 33554432
03:22:28 <erus`> good old Reals :)
03:26:36 <Tinned_Tuna> > (1/3) :: Rational
03:26:37 <lambdabot>   1 % 3
03:26:45 <Tinned_Tuna> > ((1/3)*3) :: Rational
03:26:46 <lambdabot>   1 % 1
03:26:48 <Tinned_Tuna> \o/
03:26:58 <Tinned_Tuna> you learn something new everyday.
03:32:22 <trez> any standard function doing this f 123456 == [1,2,3,4,5,6] ?
03:32:24 <kstt> does anyone have an exemple of using http-enumerator with SSL and certificate verification ? This part of the API isn't much documented, and I can't figure how to use it just from the types.
03:33:41 <dmwit> > show 123456 -- trez
03:33:42 <lambdabot>   "123456"
03:36:07 <kstt> > map digitToInt $ show 123456
03:36:07 <lambdabot>   [1,2,3,4,5,6]
03:36:42 <kstt> (haskell just rocks ...)
03:37:03 <trez> kstt: dmwit: thanks :)
03:37:14 <Tinned_Tuna> > digitToInt '1'
03:37:15 <lambdabot>   1
03:39:23 <quicksilver> that's rather an icky way to do it though
03:40:11 <lunaris> Does anyone know of an alternative to Happy that will provide an expected tokens list on a parse error?
03:40:19 <lunaris> (Or a way to make Happy produce such a list)
03:40:39 <Saizan> parsec
03:40:42 <lunaris> I'm aware that Frown once did this, but finding any trace of it is difficult.
03:41:16 <lunaris> Saizan: I should clarify: I want an LALR(k) parser largely generated from a grammar, rather than building a recursive descent one myself.
03:42:05 <quicksilver> > reverse . unfoldr (\b -> if b == 0 then Nothing else let (q,r) = divMod b 10 in Just (r,q)) $ 123456
03:42:07 <lambdabot>   [1,2,3,4,5,6]
03:42:07 <ion> > unfoldr (\a -> swap (a `divMod` 10) <$ guard (a /= 0)) 123456
03:42:08 <lambdabot>   Not in scope: `swap'
03:42:46 <ion> > let swap = snd &&& fst in reverse . unfoldr (\a -> swap (a `divMod` 10) <$ guard (a /= 0)) $ 123456
03:42:47 <lambdabot>   [1,2,3,4,5,6]
03:46:39 <erus`> why are first class modules useful?
03:47:49 <quicksilver> they're not.
03:47:51 <quicksilver> next?
03:48:13 <flux> if haskell doesn't have them, they are not useful?-)
03:50:08 <quicksilver> well I think people often argue for them as if they are *incredibly* important and that is somehow self-evident, without actually giving strong arguments for their desirability
03:50:26 <quicksilver> "ML has them and look you can you can this cool trick" isn't really an argument for something being important.
03:50:51 <quicksilver> you can do plenty of powerful abstractions with the tools that haskell already has, after all
03:51:03 <quicksilver> but, I don't doubt they have value - I just rarely see the case well made.
03:51:36 <erus`> vim or emacs
03:51:44 <erus`> which should i learn
03:52:00 <Axman6> yes
03:52:26 <erus`> you cant answer a 'which' with a boolean
03:52:28 <quicksilver> if you have the ask, then the answer will be no use to you.
03:52:41 <erus`> which has the best haskell mode?
03:53:34 <frerich> erus`: Both are reasonably sophisticated and there are plenty of smart people out there who use either. So it's up to your personal preference. The real bottle neck will be your brain, not the editor (at least not when deciding between those two), I fear.
03:53:46 <luite_> you should learn emacs and then write me a better haskell mode ;p
03:54:29 <erus`> emacs does have agda mode. Thats a bonus
03:54:58 * frerich is disappointed of himself for even bother to answer
03:55:19 <quicksilver> emacs was designed up front to be programmable (whatever flaws its system may have), vim feels to me like programmability was an after thought. I want a programmable editor.
03:56:25 <int-e> teco?
03:57:52 <gienah> teco on a pdp-11 green terminal did seem like a step up on punched cards
04:09:40 <yitz> gienah: i knew someone who was faster on teco than anyone i've ever seen on vim or emacs
04:10:33 <rostayob> isn't teco the incredible old editor?
04:10:36 <rostayob> *incredibly
04:10:47 <gienah> yitz: I knew someone who was super fast on vi, rostayob: yes
04:11:05 <rostayob> wow, how long ago was that?
04:12:01 <gienah> I think teco was from the 60s, but it was inflicted on use poor students in the early 80s (after the punched cards)
04:13:19 <rostayob> i'm reading the wikipedia now. i find it hard to believe that you can be faster on that
04:13:22 <gienah> after that one of the lecturers figured we were spoilt, so set us an assignment on a pdp-8 with no terminal, just a row of switches with leds, and a book on machine code
04:13:23 <rostayob> *wiki page
04:14:19 <rostayob> "It has been observed that a TECO command sequence more closely resembles transmission line noise than readable text[4]. One of the more entertaining games to play with TECO is to type your name in as a command line and try to guess what it does. Just about any possible typing error while talking with TECO will probably destroy your program, or even worse-- introduce subtle and mysterious bugs in a
04:14:22 <rostayob> once working subroutine."
04:15:51 <gienah> rostayob: yeah we used to print it out on a line printer every once in a while so you could type in an old version if you made a typo :-)
04:16:12 <ion> *Still* a better version control system than CVS.
04:16:13 <ion> *zing*
04:16:21 <rostayob> aha
04:18:20 <yitz> rostayob: no the teco gurus never had those problems. i think they had one-character macros that made backups and rotated them, or something
04:25:36 <rostayob> mah
04:33:48 <troydm> help ppl http://hpaste.org/53792
04:34:56 <wyfrn> hi all ... is there any way to load a lot of module in ghci with a simple command ... something like :m + XMonad*
04:35:29 <quicksilver> troydm: when pasted code with a compile error, you must paste the error too
04:35:44 <dmwit> wyfrn: You can list the modules you want to import in a file and load that file.
04:37:14 <quicksilver> troydm: your main problem is defining solveRpn point-free but still naming the parameter s.
04:37:26 <quicksilver> troydm: then your secondary problem is that not all 'Num's support (/)
04:37:55 <troydm> quicksilver: ok i've removed second problem for now
04:38:02 <quicksilver> troydm: after those two fixes it works
04:38:11 <troydm> quicksilver: but what do you mean by point-free ?
04:38:27 <quicksilver> troydm: http://hpaste.org/53792
04:38:40 <troydm> quicksilver: oh 1 sec
04:38:42 <quicksilver> "head . foldl rpn [] . words" <- point free, doesn't mention "s"
04:38:50 <quicksilver> see my fixed version on your paste
04:38:52 <mike-burns> Ironic name, really.
04:38:59 <troydm> quicksilver: thx worked
04:39:05 <quicksilver> in a way.
04:39:07 <quicksilver> s is the point.
04:40:11 <wyfrn> dmwit: ahh .. good idea
04:41:31 <troydm> quicksilver: what if i do this http://hpaste.org/53795
04:42:11 <troydm> it says couldn't dedouce (Num String) arising from use of rpn
04:42:27 <dmwit> Yeah, you're calling read . head, but the list is built with arithmetic.
04:42:42 <dmwit> So. You know. Mix those two in a pot and what do you get?
04:43:07 <troydm> ohh yeah
04:43:12 <troydm> my bad
04:43:17 <troydm> dmwit: thank you
04:43:51 * dmwit doffs his hat
04:52:25 <troydm> is fun that appends element to the end of the list in standart Prelude?
04:52:32 <troydm> or i should import Data.List ?
04:52:43 <quicksilver> (++) is in the prelude
04:52:55 <Jafet> Stand art
04:53:03 <troydm> ohh yeah i confused it with append
04:53:13 <quicksilver> > [1,2,3,4,5] ++ [6]
04:53:14 <lambdabot>   [1,2,3,4,5,6]
04:53:24 <quicksilver> however, the way you ask the question is almost like importing Data.List is a bad thing
04:53:27 <quicksilver> it isn't :)
04:53:47 <Jafet> Appending to a list is a bad thing
04:54:46 <Jafet> Use Data.Sequence
04:56:12 <troydm> hmm I'll look throught Data.Sequence but for now ++
04:56:38 <Jafet> mike-burns: you can simply replace all the dots with `fmap`
05:00:06 <opqdonut> i'm outputting numbers with "show"
05:00:14 <opqdonut> however that seems to be my bottleneck
05:00:38 <opqdonut> there probably is a faster specialized function somewhere
05:02:32 <Eliel> opqdonut: the problem is propably that show is creating a string when a ByteString would be faster.
05:02:56 <iboB> hey can i time the execution of a function with ghci?
05:03:32 <opqdonut> Eliel: right
05:04:08 <quicksilver> opqdonut: try the bytestring-show package on hackage
05:04:26 <opqdonut> quicksilver: thanks
05:04:40 <hpc> iboB: :set +s
05:05:25 <iboB> thank you hpc
05:06:02 <iboB> so i want to write a function that generates fibonacci numbers: fibonacci n = (fibonacci (n-1)) + (fibonacci (n-2))
05:06:10 <iboB> can i store the values already calculcated?
05:06:35 <iboB> in mathematica i'd do something like f[n_] := f[n] = f[n-1] + f[n-2]
05:07:37 <iboB> otherwise fibonacci 20+ takes seconds, to traverse the recursion tree
05:09:17 <int-e> > fix ((0:) . scanl (+) 1)
05:09:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:09:47 <iboB> er what now?
05:09:48 <iboB> :)
05:11:10 <int-e> > let fibs = map fib' [0..]; fib n = fibs !! n; fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib n in fib 30
05:11:14 <lambdabot>   mueval-core: Time limit exceeded
05:11:27 <int-e> err
05:11:37 <Nimatek> > let fibs = 0 : scanl (+) 1 fibs in fibs
05:11:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:11:41 <int-e> > let fibs = map fib' [0..]; fib n = fibs !! n; fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2) in fib 30
05:11:42 <lambdabot>   832040
05:12:23 <iboB> thank you int-e
05:12:40 <int-e> iboB: basically it's using the fact that fib_n = fib_n-2 + fib_n-3 + ... + fib_0 + 1.
05:12:46 <int-e> (the scanl version)
05:13:05 <iboB> so i can't add new patterns in runtime?
05:13:38 <int-e> what do you mean?
05:14:06 <absence> are there functional languages with manual memory management?
05:14:08 <hpc> iboB: you mean you want to be able to change the definition of a function?
05:14:19 <iboB> int-e the way i showed with the mathematica example
05:14:54 <HugoDaniel> is there a 64bit version of the haskell platform for windows ?
05:15:20 <HugoDaniel> i need it to access the 64bit odbc driver :(
05:15:49 <iboB> hpc i don't *want* anything :) i'm just learning haskell and i'm trying to see what (and how) it works :)
05:16:26 <HugoDaniel> :(
05:17:02 <int-e> iboB: In what sense is that adding new patterns at runtime?
05:17:06 <hpc> iboB: ah; all values in haskell (almost) are immutable
05:17:21 <hpc> the ones that are mutable make it very explicit
05:17:39 <int-e> iboB: or perhaps, what do you mean by pattern?
05:17:49 <hpc> lke IORef, ForeignPointer, STRef, MVar, ...
05:17:59 <iboB> int-e, well f 1 = 3 is a pattern right?
05:18:26 <iboB> in the same sence in mathematica f[1] = 3 is a pattern
05:18:31 <int-e> it's a binding. the '1' is a pattern
05:18:41 <iboB> int-e yes. ok :)
05:18:47 <hpc> technically, it's a guard
05:18:52 <hpc> f x | x == 1 = 3
05:19:10 <int-e> hpc: no, it's a pattern. the guard is an intermediate desugared version
05:19:11 <hpc> (matching on numeric literals is syntax sugar)
05:19:21 <iboB> so in mathematica i could write f[n_] := f[n] = f[n-1], and this will add a new binding for every n that's been calculated
05:19:46 <iboB> or run the recursion each time f is called with just f[n_] := f[n-1]
05:19:59 <quicksilver> hpc: since you're being pedantic, IORef, ForeignPointer, STRef and MVar are not mutable, either :) They are immutable and referentially transparent values that act as the "names" of mutable cells ;)
05:20:07 <int-e> iboB: you can't do that in haskell -- you'll have to find some representation for such definitions and process them yourself.
05:20:29 <iboB> int-e, yes, i got that. thank you :)
05:22:29 <erus`> ok i got vim setup nicely. How can i get it to render "->" as a right arrow and "==" as a triple horizontal line and stuff?
05:23:32 <frerich> erus`: https://github.com/frerich/unicode-haskell
05:23:48 <quicksilver> our very own frerich has....
05:23:56 <quicksilver> (beaten me to pasting that URL :P)
05:24:09 <frerich> :-)
05:26:23 <int-e> > let linrec xs ys = let rs = xs ++ map (sum . zipWith (*) ys) (tails rs) in rs in linrec [0,1] [1,1]
05:26:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:39:26 <hpaste> yogsototh pasted “Stack overflow” at http://hpaste.org/53798
05:39:59 <Phlogistique> frerich: for some reason I installed pathogen and your script and haskell files still display the same
05:40:43 <erus`> frerich: do i have to turn bundles on or something
05:41:12 <jaspervdj> copumpkin: I sort of figured out where you can hook into pandoc.
05:41:44 <erus`> ok ignore that
05:42:04 <frerich> Phlogistique : Did you enable file type plugins (and UTF-8)?
05:42:28 <iboB> is there a *better* way of selecting elements besides [x | x<-list, condition]
05:42:36 <frerich> Phlogistique : We should probably take this into a /query, it's a bit offtopic here.
05:42:49 <frerich> iboB: The 'filter' function
05:42:56 <iboB> frerich thank you
05:43:05 <quicksilver> filter is not necessarily "better"
05:43:06 <dmwit> yogsototh: probably easy to fix by writing lencollatz' l n = l `seq` lencollatz' (l+1) (collatz n)
05:43:09 <quicksilver> but it's good to know it exists.
05:43:44 <yitz> > let fib = fst . fib'; fib' 0 = (0,1); fib' n | even n = (a*(2*b-a), a*a+b*b) | otherwise = (a*a+b*b, b*(2*a+b)) where {(a,b) = fib' $ n `div` 2} in fib 30 -- iboB, int-e this is O(log n)
05:43:46 <lambdabot>   832040
05:43:46 <quicksilver> list comprehension is probably best thought of as just being sugar for the normal functions concatMap, map, concat and filter in various permutations
05:43:47 <dmwit> yogsototh: Probably also need something like that in maximalIndex
05:44:26 <dmwit> concatMap and guard
05:45:05 <cheater> hi
05:45:24 <yitz> hi cheater
05:45:33 <cheater> is there any way to so to speak swap data structures in haskell?
05:45:49 <quicksilver> dmwit: yes but I don't think the "most efficient desugaring" matters - the idea is just to think of list comprehensions as being a neat syntax for things which can equally be done with standard functions.
05:45:49 <yitz> ?
05:45:56 <cheater> say [(a, b)] -> ([a], [b])
05:45:57 <quicksilver> wasn't particularly trying to select a minimal set.
05:46:04 <HugoDaniel> is there any interact function that works with Data.Text ?
05:46:11 <cheater> or take a pair of trees and make it a tree of pairs
05:46:14 <rtharper> cheater unzip?
05:46:15 <rtharper> :t unzip
05:46:16 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
05:46:17 <dmwit> ?hoogle [(a,b)] -> ([a],[b])
05:46:18 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
05:46:18 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
05:46:23 <cheater> rtharper: i'm looking for something more general
05:46:24 <quicksilver> cheater: in general sequenceA
05:46:28 <quicksilver> or traverse
05:46:32 <cheater> :t sequenceA
05:46:33 <lambdabot> Not in scope: `sequenceA'
05:46:36 <cheater> :t sequence
05:46:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:46:44 <yitz> @hoogle sequenceA
05:46:44 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:46:45 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
05:46:47 <dmwit> :t Data.Traversable.sequence
05:46:47 <rtharper> cheater: yes, something that is Foldable
05:46:47 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
05:46:49 <rtharper> or a monad
05:46:50 <rtharper> lol
05:46:52 <rtharper> as they have shown
05:47:14 <cheater> nice
05:47:21 <cheater> that's exactly what i needed (i think)
05:47:33 <yitz> @hoogle traverse
05:47:34 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
05:47:34 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
05:47:34 <lambdabot> Control.Parallel.Strategies parTraverse :: Traversable t => Strategy a -> Strategy (t a)
05:47:43 <quicksilver> cheater: the [(a,a)] -> ([a],[a]) is an example of that scheme for an obvious Traversable instance for (a,a)
05:47:48 <quicksilver> that instance is not in the standard lib though.
05:47:58 <quicksilver> [(a,b)] -> ([a],[b]) is actually *not* an instance.
05:47:59 <cheater> quicksilver: could this work f or [(a, b)] too?
05:48:03 <cheater> aha
05:48:06 <yogsototh> dmwit: thanks, I wanted to know why it appears haskell didn't optimized "maximalIndex" as tail recursive?
05:48:07 <cheater> that's funny
05:48:11 <cheater> but i understand
05:48:25 <rtharper> :t maximalIndex
05:48:26 <lambdabot> Not in scope: `maximalIndex'
05:48:27 <dmwit> yogsototh: Tail recursive is less useful as a concept in lazy languages.
05:48:32 <dmwit> rtharper: See his hpaste.
05:48:35 <rtharper> kk
05:49:26 <dmwit> yogsototh: More to the point, the stack that's overflowing isn't the stack you think is overflowing.
05:50:38 <dmwit> yogsototh: Some very similar questions on SO:
05:50:43 <dmwit> http://stackoverflow.com/questions/7534489/how-to-avoid-stack-overflow-in-haskell
05:52:19 <dmwit> http://stackoverflow.com/questions/8031319/haskell-memoization-stack-overflow
05:54:39 <yogsototh> dmwit: Thank you very much!
06:02:11 <yitz> how to avoid stack overflow in haskell: stick with reddit
06:10:13 <erus`> oh yeah :) sexy unicode characters
06:10:31 <erus`> i feel like lambda should be a different color though
06:10:36 <erus`> maybe even -> too
06:13:09 <tana_> hi
06:13:44 <reynir> hi tana_
06:14:19 <tana_> Hm I'm learning Haskell and i have a problem
06:14:54 <cheater> what is the problem that you are experiencing tana_ ?
06:15:04 <sipa> would you consider enlightening us as to what exactly is the problem, who knows - maybe we can help?
06:15:32 <tana_> The first problem is, that my english is bad and i hope that you don't laugh about me :)
06:15:44 <tana_> I'm from Germany
06:15:54 <tana_> I will try to explain my problem
06:17:33 <frerich> tana_: I'm german, too - unfortunately, I'm not terribly good at Haskell though. If all else fails, you could /query me in german.
06:18:51 <tana_> i think that's easier :D
06:19:09 <frerich> For you, yes :-}
06:19:59 <ecuageo> I'm trying to install my first haskell package - hmatrix - and it fails saying that it can't find the gsl library. I can include the library when compiling a c program, but cabal can't seem to pick it up. How do I specify the ld library path?
06:20:41 <frerich> erus`: If you have any suggestions for improvements to the installation (instructions), let me know. Or, just edit the file directly on github and send me a pull request.
06:22:03 <erus`> frerich: nah its fine when you read it properly. I always rush through trying to read one in 10 words
06:22:29 <Phillemann> Challenge: I have a list [a,b,c,d,...] and want to create a list of adjacent pairs: [(a,b),(c,d),...] with as less code as possible (excluding any necessary imports).
06:22:40 <Phillemann> I thought about zipping, but I'd have to delete every second element.
06:24:45 <_Vi> What is difference between fmap and map for lists?
06:24:52 <quicksilver> > let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in map (\[a,b] -> (a,b)) . groupsOf 2 $ [1,2,3,4,5,6,7,8]
06:24:53 <lambdabot>   [(1,2),(3,4),(5,6),(7,8)]
06:24:57 <quicksilver> Phillemann: ^^ that's how I'd do it.
06:25:04 <quicksilver> _Vi: there is none.
06:25:06 <dylex> > let f (a:b:l) = (a,b):f l ; f _ = [] in f [1,2,3,4,5,6,7,8]
06:25:07 <lambdabot>   [(1,2),(3,4),(5,6),(7,8)]
06:25:29 <Phillemann> Hmmm, that's pretty long. But it's not a common task, so...
06:25:31 <_Vi> quicksilver, Should I use "map" when it is a list (avoiding "fmap")?
06:25:40 <quicksilver> _Vi: matter of taste.
06:25:49 <_Vi> quicksilver, Extra entities?
06:26:01 <quicksilver> Phillemann: but groupsOf is independently useful and I often have it lying around anyway.
06:26:15 <quicksilver> _Vi: what?
06:26:57 <_Vi> Is "map" an extra entity in presence of "fmap"? Or, for example, "fmap" uses "map" inside or there are cases when "fmap" does not work...
06:27:18 <_Vi> (or fmap slower than map, for example)
06:27:33 <byorgey> no, for lists fmap and map are exactly the same
06:27:34 <quicksilver> there are no cases in which it doesn't work.
06:27:38 <quicksilver> I already told you they were the same.
06:27:59 <quicksilver> as for, is it slower? Well that would depend on your compiler technically.
06:28:12 <quicksilver> But doing a bit of inlining is pretty much required to be any kind of useful haskell compiler
06:28:17 <quicksilver> so they will be the same in GHC.
06:28:26 <dylex> Phillemann: well, mine's shorter and doesn't require any imports.  there is such a thing as over-reliance on libraries.
06:28:53 <quicksilver> dylex: what imports does mine require?
06:28:58 <quicksilver> AFAIK it's all in the prelude.
06:29:53 <dylex> quicksilver: I guess I should say, any other functions at all.
06:30:16 <quicksilver> dylex: I don't think there is any such thing as "over-reliance on functions provided by the Prelude"
06:30:29 <Phillemann> dylex: Ahhh, I overread that. Great
06:31:03 <Phillemann> I'm doing this for a "write something in 140 characters or less", so it's not supposed to be as elegant as possible :D
06:31:13 <dylex> quicksilver: well, I bet you'd find that mine is faster.
06:32:13 * hackagebot splot 0.2.9 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.9 (EugeneKirpichov)
06:32:16 * hackagebot tpdb 0.1 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.1 (JohannesWaldmann)
06:32:26 <dylex> quicksilver: chaining together lots of functions to do something quite simple. though I do appreciate the generalizability of yours.
06:32:44 <dudko> hi. I'm trying to understand, why curry id :: a -> b -> (a,b). From curry definition is clear, that (curry :: ((a,b) -> c) -> a -> b -> c; id :: d -> d) ((a,b) -> c) -> = d -> d => (a,b) = c. And here I'm stucked.
06:34:30 <dudko> any help, would be welcome.
06:34:53 <copumpkin> the id function, of type d -> d, goes in the (a,b) -> c spot
06:35:01 <copumpkin> which means that d -> d and (a,b) -> c must unify
06:35:07 <copumpkin> which means that the domain and codomain must be equal
06:35:17 <copumpkin> which means that c must equal (a, b)
06:35:25 <copumpkin> so you go substitute that back into the resulting type
06:35:31 <copumpkin> and you get a -> b -> (a, b)
06:37:51 <dudko> copumpkin: thanks:)
06:37:51 <absentia> n/win shirnk 3
07:06:10 <ecuageo> Anybody have any luck running hmatrix library on Mac
07:14:17 <riba_> i want to get a list which contains the lengths of the subslists of the initial list. the method i use to get the initial list works, but as soon as i put a "map (\x -> genericLength x) INITIALLIST" into it, i get an error i can't decipher
07:14:30 <troydm> i'm reading Learn Yourself Haskell about Applicative Functors and don't quite get it
07:14:35 <riba_> Instance of Num [Index] required for definition of [function]
07:14:46 <troydm> is it popular
07:15:06 <byorgey> riba_: can you paste your entire code, along with the error, on hpaste.org?
07:15:11 <chra> ecuageo: works for me on Gentoo, at least. Try cabal install package --extra-lib-dirs=PATH
07:15:11 <troydm> are there any other tutorials that explain it
07:15:22 <byorgey> troydm: yes, applicative functors are used quite a bit
07:15:40 <byorgey> troydm: you could try reading the Typeclassopedia
07:15:45 <byorgey> @where typeclassopedia
07:15:45 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:15:46 * tac-tics still doesn't believe that app. functors are all that useful
07:16:36 <byorgey> tac-tics: you can believe whatever you like ;)
07:16:41 <troydm> byorgey: thx
07:16:52 <tac-tics> byorgey: And I plan to be damn well vocal about it ;D
07:17:18 <tac-tics> Monads are nice because they got that syntax that makes miracles happen.
07:17:24 <hpaste> riba_ pasted “:/” at http://hpaste.org/53799
07:17:26 <tac-tics> Otherwise, I'd be suspicious of them too :)
07:17:38 <riba_> byorgey: http://hpaste.org/53799
07:17:59 <troydm> note: and the scary thing
07:18:01 <troydm> is that they worked! Anyway, I think those people must actually be robots
07:18:03 <troydm> because there’s no way anyone could come up with that in two seconds off the
07:18:07 <troydm> from typopedia
07:18:08 <troydm> LOL
07:18:26 <ecuageo> chra: thanks for responding, I've tried that with no success
07:18:40 <_Mikey> :(
07:19:40 <riba_> you'll see i'm a beginner, but i'm not responsible for all the strange names, they were required
07:20:25 <riba_> the biggest problem is i don't know what the error message is trying to tell me
07:21:16 <riba_> when i remove the part where i map "genericLenght" on my list, it works just fine, but then it tells me the function needs an instance of Num?
07:21:35 <byorgey> troydm: =)
07:21:52 <fryguybob> riba_: "the function" being?
07:22:20 <riba_> http://hpaste.org/53799 , the error message is the comment at the bottom
07:22:21 <fryguybob> riba_: bigrams?
07:22:24 <byorgey> riba_: well, if you map genericLength over the list, you need to change the type of bigrams
07:22:28 <riba_> yes
07:22:52 <byorgey> riba_: it no longer returns a list of lists of Index, it now returns a list of Ints
07:22:55 <riba_> um
07:23:14 <byorgey> riba_: or is it supposed to return [[Index]], and you can't change that?
07:23:32 <riba_> no, that i can change
07:25:08 <riba_> oh, thanks
07:25:38 <riba_> it's not what i wanted to do with the function, but at least now i now that part of it works
07:26:19 <Isthan> Anyone willing to help with a type error on line 3? http://snipt.org/wqj7
07:26:25 <riba_> i had [[Index]], it has to be [Index]. still, the error message seems pretty strange to me, i'm convinced they look different
07:26:31 <riba_> at least i was
07:27:16 <fryguybob> @type genericLength
07:27:17 <lambdabot> forall b i. (Num i) => [b] -> i
07:27:44 <byorgey> riba_: the error is because genericLength can return any type which is an instance of Num
07:27:59 <byorgey> riba_: but for the type you gave to work, genericLength would have to return [Index]
07:28:10 <byorgey> so in theory if there were a Num instance for [Index] it would work
07:28:14 <byorgey> but there is no such instance
07:28:50 <fryguybob> @type genericLength [] :: [Int]
07:28:51 <lambdabot>     No instance for (Num [Int])
07:28:51 <lambdabot>       arising from a use of `genericLength' at <interactive>:1:0-15
07:28:51 <lambdabot>     Possible fix: add an instance declaration for (Num [Int])
07:29:13 <Isthan> Anyone willing to help with a type error on line 3? http://snipt.org/wqj7
07:29:38 <byorgey> Isthan: what's the error?
07:29:58 <Isthan> Couldn't match expected type `Float'
07:29:58 <Isthan>            against inferred type `[Float]'
07:30:17 <Isthan> in the function call for elapsedTime
07:31:08 <riba_> it's clear to me what the error was, i was just too confused by the error message
07:31:12 <riba_> thanks for helping me :D
07:31:19 <rwbarton> elapsedTime returns a [Float] but you're using it as though it returns a Float
07:32:50 <Isthan> I was trying to add the return of elapsedTime to the recursive call for runtimeList
07:33:01 <Isthan> hence why it returns [Float]
07:33:10 <Isthan> but I dont see how i'm 'using it as Float' though
07:33:22 <rwbarton> you wrote    something : somethingElse   as the return value of runtimeList
07:33:30 <rwbarton> which is supposed to have type [Float]
07:33:39 <Isthan> oooooh
07:33:42 <Isthan> yes :)
07:34:17 <Isthan> I'm trying to return a single dimensional list of just times inbetween two waypoints which are represented by those floats
07:34:57 <byorgey> preflex: seen dcoutts
07:34:57 <preflex>  dcoutts was last seen on #haskell 1 day, 21 hours, 35 minutes and 11 seconds ago, saying: Phyx-: the lols?
07:36:14 <dcoutts__> byorgey: hia
07:36:14 <Isthan> rwbarton: so the problem is with the return type for runtimeList?
07:36:29 <Isthan> rwbarton: and not the way that i'm calling elapsedTime?
07:36:50 <rwbarton> it's just in the way you are trying to build the result of runtimeList
07:37:09 <rwbarton> something : somethingElse  means "a list where the first element is something, and the rest of the list is somethingElse"
07:37:43 <Isthan> I thought I was building something like [Float]:[Float,Float,Float...]
07:37:54 <byorgey> hi dcoutts__ , just wondering whether you saw my patches for 'cabal init'
07:38:08 <byorgey> if the answer is 'yes but I'm busy' then no worries
07:38:11 <dcoutts__> byorgey: actually I'm not sure I did
07:38:22 <dcoutts__> byorgey: did you send them to the list or to me directly?
07:38:23 <rwbarton> Isthan: you're taking a list of Floats and trying to stick a [Float] as the new first element
07:38:26 <byorgey> dcoutts__: I sent them to cabal-devel@
07:38:35 * dcoutts__ has a look
07:39:07 <Isthan> So I could change the return of elapsedTime to return Float
07:39:12 <rwbarton> right
07:39:13 <dcoutts__> byorgey: ah, found them, ok, thanks
07:39:20 <Isthan> and then say [ elapsed time( ... ) ]
07:39:21 <Isthan> right?
07:39:24 <byorgey> dcoutts__: great, thanks
07:39:24 <rwbarton> no
07:39:28 <rwbarton> don't change anything else!
07:39:31 <Isthan> :)
07:39:49 <Isthan> Oh I see why
07:39:54 <rwbarton> You seem to still be confused about (:), it is not concatenation of lists
07:40:08 <rwbarton> > 1 : [2,3,4]
07:40:09 <lambdabot>   [1,2,3,4]
07:40:11 <Isthan> That was indeed my misunderstanding
07:40:13 <Isthan> yep!
07:40:20 <rwbarton> ok, great
07:40:30 <Isthan> thanks a million! compile joy
07:40:37 <byorgey> > [1] ++ [2,3,4]  -- on the other hand
07:40:39 <lambdabot>   [1,2,3,4]
07:40:51 <Isthan> oooh thats why I was confused, used that method earlier
07:41:03 <Isthan> that helps quite a bit
07:41:26 <rwbarton> in this case it makes more sense to use (:) though, since you only want to put one element on the front anyways
07:41:30 <Isthan> thats why I was trying to do something like [ elapsedTime (...) ]
07:41:35 <Isthan> yes
07:42:50 <Isthan> Thank you, good people of #haskell, you have won the day
07:43:56 <byorgey> \o/
07:45:31 <riba_> i have a list [(Integer, String)] and want to use takeWhile on it, so that i only get the results which are not 0
07:45:59 <kmc> :t takeWhile ((/= 0) . fst)
07:46:00 <lambdabot> forall a b. (Num a) => [(a, b)] -> [(a, b)]
07:46:01 <riba_> takeWhile (fst list /= 0) list does not work
07:46:11 <kmc> that would be:  takeWhile (\xs -> fst xs /= 0)
07:46:28 <Isthan> can you apply filter onto the list?
07:46:41 <kmc> filter and takeWhile can be used in the same circumstances
07:46:48 <kmc> the difference is that takeWhile stops at the first False element
07:46:53 <Isthan> ah
07:46:55 <kmc> :t filter
07:46:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:46:57 <kmc> :t takeWhile
07:46:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:47:16 <riba_> thanks a lot
07:47:17 <kmc> > filter (<5) [1..]
07:47:21 <lambdabot>   mueval-core: Time limit exceeded
07:47:22 <kmc> > takeWhile (<5) [1..]
07:47:23 <lambdabot>   [1,2,3,4]
07:47:59 <riba_> ...i think i'm going to write the rest of the program in java :D
07:48:17 <riba_> i have to decipher a text, as you may have guessed
07:48:41 <riba_> now i'm done with the analysis, and i already can substitute
07:49:06 <riba_> but i have no idea how to make sure i don't overwrite prior substitutions
07:49:15 <rotflcopter> hey-ho
07:51:07 <yitz> riba_: what do you need to substitute?
07:51:55 <riba_> characters
07:52:45 <riba_> i already wrote a method to substitute all occurences of the specified character in a string
07:53:22 <riba_> but as i said, i don't know how to make sure i don't overwrite a character i already changed
07:54:19 <kmc> wouldn't you do that by processing the characters in order?
07:54:28 <kmc> i would build the substitution in a (Map Char Char)
07:54:31 <kmc> from Data.Map
07:55:16 <riba_> yes, i would, that's the problem :D
07:55:46 <riba_> i didn't use maps yet, maybe i will be able to work with it... thanks for the hint
07:55:51 <riba_> but now i need a break first
07:55:54 <kmc> then you can apply it over a string with   map (\x -> fromMaybe (error "unknown char") $ M.lookup x mySubstitution)
07:56:00 <kmc> well you don't need to use Data.Map really
07:56:07 <kmc> but the 'map' function on lists will be very helpful
07:56:15 <kmc> :t map :: (Char -> Char) -> (String -> String)
07:56:16 <lambdabot> (Char -> Char) -> String -> String
07:56:26 <kmc> that's how you apply a substitution to each character of a string
07:56:30 <kmc> > map succ "like this"
07:56:31 <lambdabot>   "mjlf!uijt"
07:57:30 <riba_> i fail to see how that would not overwrite already substituted characters :/
07:57:49 <riba_> oh
07:57:51 <riba_> i'm stupid
07:58:06 <kmc> i fail to see why you think it would :)
07:58:11 <kmc> @src map
07:58:12 <lambdabot> map _ []     = []
07:58:12 <lambdabot> map f (x:xs) = f x : map f xs
07:58:26 <DukeDave> riba_: Don't worry, Haskell is designed to make you look stupid :)
07:58:30 <kmc> i mean just from the type, you cannot tell that it won't
07:58:38 <kmc> but map is the 'most natural' function of that type
07:58:43 <kmc> (in a very precise sense actually)
07:58:59 <kmc> so it applies the function exactly once to each place where it could
07:59:06 <hpaste> ibob pasted “rev” at http://hpaste.org/53800
07:59:16 <kmc> the more general type is:   map :: (a -> b) -> ([a] -> [b])
07:59:19 <cheater> what is the precise sense of "most natural"
07:59:25 <kmc> from that type you can actually tell that it will apply only once
07:59:41 <kmc> because once we've converted a to b, we don't know how to do anything else with it
08:00:04 <sajkr> hello fellow haskellers.
08:00:05 <kmc> cheater, 'map' is the unique function satisfying the Functor laws for []
08:00:08 <paolino> is there a Zip class somewhere , with method zipWith ?
08:00:40 <iboB> haha :) so... yeah consing is faster than ++, that means that in the paste myReverse is faster than myReverse', right?
08:00:45 <riba_> kmc: but how does it know it
08:00:57 <kmc> ?
08:00:59 <iboB> i mean this paste: http://hpaste.org/53800
08:01:16 <riba_> ...'s still of the type b when I use the next substitution?
08:01:33 <kmc> i don't understand the question
08:02:09 <riba_> that's probably because i don't really understand how that's supposed to work
08:02:21 <paolino> @hoogle zipWith
08:02:21 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:02:21 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
08:02:21 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:02:24 <cheater> kmc: k
08:02:29 <kmc> riba_, the most direct way to know that 'map' does what you want is to read the code
08:02:30 <kmc> @src map
08:02:31 <lambdabot> map _ []     = []
08:02:31 <lambdabot> map f (x:xs) = f x : map f xs
08:02:35 <riba_> i know map as: "do something with each object of a list"
08:02:37 <kmc> do you understand all that syntax?
08:02:52 <kmc> riba_, Haskell isn't really about doing and objects. it's about being and values
08:02:53 <cheater> kmc: what other versions of "most natural" are ther other than "satisfies Functor laws"?
08:02:59 <cheater> *there
08:03:02 <sajkr> i'm trying to write a type for finite naturals. i have Zero and Succ on the type level, and i want Fin n (with zero and succ constructors) to represent naturals not larger than n (which is of course encoded as a type).
08:03:54 <riba_> in my understanding, i just put to words what that code means
08:03:59 <sajkr> i'm pretty sure i've seen this somewhere, but i can't remember where.
08:04:40 <kmc> riba_, well 'f' can't really "do" anything
08:04:40 <rwbarton> it will look something like   data Fin n where Zero :: Fin x; Succ :: Fin x -> Fin (Succ x)
08:05:00 <kmc> it just takes a list element and produces another list element
08:05:13 <kmc> it can't muck with the other parts of the list, or 'overwrite' anything, or print a message to your screen
08:06:12 <sajkr> rwbarton: thanks.
08:06:37 <kmc> riba_, and the elements of the list aren't "objects" in the traditional OOP sense.  they aren't bundles of changing state and functions
08:07:04 <kmc> they're just values, like the number 3.  in maths you never declare that the number 3 has become the number 4
08:07:10 * sajkr facepalmed at himself.
08:07:21 <kmc> > map succ [1,2,3]
08:07:22 <lambdabot>   [2,3,4]
08:07:29 <kmc> i'm not asking each element of the list to change itself to a number one greater
08:07:38 <riba_> kmc, i just don't know how to express myself in english that well, that's why i said "object". i remembered the word "item" the next time
08:07:48 <kmc> i'm just producing a new list which is defined from the old one in a certain relationship
08:08:01 <iboB> > foldl (\lst elem -> elem:lst) [] [1..5]
08:08:03 <lambdabot>   [5,4,3,2,1]
08:08:54 <riba_> kmc: but i have only one substitution at the beginning, so wouldn't it look all the same to "map"?
08:09:19 <yitz> @type \f x y -> f <$> x <*> y
08:09:20 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
08:09:27 <kmc> riba_, i don't understand the question
08:09:33 <kmc> you have a function of type (Char -> Char), right?
08:09:45 <kmc> and you want to apply this function to every Char in a String, and get the new String formed thus
08:09:49 <yitz> paolino: is that what you wanted? ^^
08:10:13 <paolino> yitz, I think so
08:10:23 <riba_> sorry, i'm probably just tired. now i don't see how i didn't see that
08:10:32 <yitz> @type liftA
08:10:33 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
08:10:34 <troydm> byorgey: thx after reading your typopedia about Aplicative i think started to understand it a little
08:10:35 <kmc> it's okay :)
08:10:38 <riba_> thanks for the patience :D
08:10:57 <riba_> i definitely need a break now
08:11:25 <paolino> yitz, in the type
08:11:48 <paolino> has it the same meaning as zipWith ?
08:12:57 <paolino> > (+) <$> [1..10] <*> [1..10]
08:12:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
08:13:36 <paolino> no
08:15:02 <paolino> > zipWith (+)  [1..10] [1..10]
08:15:03 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:15:34 <tac-tics> Is there an infix version of that kind of thing?
08:15:49 <tac-tics> hmm probably not
08:16:44 <yitz> paolino: no you're right. same type, but not the same function.
08:17:44 <paolino> @type Node
08:17:45 <lambdabot> forall a. a -> Forest a -> Tree a
08:18:54 <paolino> > (+) <$>  Node 1 [Node 2 [],Node 3 []] <*> Node 1 [Node 2 [], Node 3 []]
08:18:55 <lambdabot>   Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []},Node...
08:19:06 <byorgey> troydm: great!
08:19:35 <byorgey> troydm: and don't worry, it's one of those things you have to see several times and read about from different perspectives before you really feel like you get it
08:20:30 <paolino> yitz: I was thinking there is a good reason for class Zip not being somewhere near the prelude
08:20:35 <byorgey> > (+) <$> ZipList [1..10] <*> ZipList [1..10] -- paolino
08:20:36 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
08:20:36 <lambdabot>    arising ...
08:20:42 <byorgey> > getZipList $ (+) <$> ZipList [1..10] <*> ZipList [1..10] -- paolino
08:20:43 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:21:15 <paolino> @hoogle ZipTree
08:21:16 <lambdabot> No results found
08:22:06 <byorgey> paolino: that isn't defined anywhere as far as I know, but it's not hard and makes a perfectly good Applicative instance
08:22:36 <byorgey> paolino: many data types have both an "all possible combinations" and a "zippy" Applicative instance
08:22:54 <byorgey> but in general the zippy ones do not correspond to Monad instances
08:24:01 <Saizan> depending on the exact tree type you might not have a "nil" value to use where the structures don't match
08:25:26 <paolino> Saizan: but having same shape structure is not a problem resolvable with type system
08:26:07 <sajkr> rwbarton: i have pred :: Fin (Succ n) -> Fin n, but it must handle Zero :: Fin m, since the type checker has no problem unifying m with Succ n. can i avoid this?
08:26:31 <byorgey> paolino: sure it is!
08:26:35 * paolino skating on thin ice :-w
08:26:55 <byorgey> paolino: you just have an extra type index recording the shape at the type level =)
08:27:21 <rwbarton> sajkr: well 0 is a valid input, it's of type Fin (Succ n)
08:27:35 <paolino> byorgey: one type of each shape ?
08:28:10 <byorgey> paolino: well, that would only work if you have a finite number of shapes
08:28:15 <copumpkin> sajkr: yeah, you can't write that
08:28:27 <copumpkin> sajkr: you can write Fin (Succ (Succ n)) -> Fin (Succ n)
08:28:30 <copumpkin> :P
08:28:30 <byorgey> paolino: In general you can encode inductive structures as types just as easily as you can as values
08:28:38 <byorgey> paolino: e.g.  data Zero; data Succ n
08:29:27 <rwbarton> what is pred 0 supposed to be?
08:29:33 <copumpkin> 0
08:29:45 <copumpkin> clamping pred!
08:29:45 <rwbarton> then you can just write pred Zero = Zero
08:29:52 <paolino> byorgey: interesting, how encode a Data.Tree like that ?
08:29:53 <copumpkin> only if you use the type I wrote
08:29:55 <rwbarton> his Fin n is <= n
08:29:58 <copumpkin> oh
08:30:02 <copumpkin> then he can :P
08:30:09 <copumpkin> not sure why you'd want <= n
08:30:33 <paolino> byorgey, encode the shape
08:31:02 <byorgey> paolino: data Node cs; data NilC; data Sibling t cs
08:31:08 <sajkr> copumpkin: let's say that i want to ensure my de Bruijn indices don't exceed the number of enclosing abstractions.
08:31:32 <copumpkin> sajkr: yeah, that's a usual use for it, but then you typically still have < instead of <=
08:31:47 <byorgey> paolino: e.g.  Node (Sibling (Node NilC) (Sibling (Node NilC) NilC))  is a tree with a root and two children
08:31:48 <copumpkin> currently your Fin n has n + 1 total inhabitants
08:32:04 <Saizan> i.e. Zero :: Fin (Succ n) is the usual rather than Zero :: Fin n
08:32:21 <copumpkin> Fin 0 traditionally contains no elements
08:32:29 <copumpkin> because Fin n represents the type with n elements
08:32:44 <sajkr> i see.
08:35:26 <sajkr> copumpkin, rwbarton: so my problem is that n is never Zero, it only gets "unrolled" to Succ m.
08:36:15 <edwardk> copumpkin got pulled away from the computer for a sec
08:36:18 <paolino> byorgey: so instance Zip (Node cs) (Node cs) is going to recurse on instances some way that I cannot foresee now ?
08:36:20 <sajkr> what if i add another type parameter, so that Zero :: Fin Zero n?
08:36:37 <tac-tics> Fin Zero n?
08:36:48 <byorgey> paolino: just a minute, I'm typing it up =)
08:37:26 <sajkr> tac-tics: Succ :: Fin n m -> Fin (Succ n) (Succ m)
08:37:55 <Kus> Hello, I found a qsort code in haskell (http://c2.com/cgi/wiki?QuickSortInHaskell) and i want to modify it for a tuple (a,b,c) to sort by b. How do i get b for the comparing part?
08:38:01 <sajkr> so i can restrict pred to Fin (Succ n) (Succ m) -> Fin n m
08:38:35 <paolino> kus : \(_,x,_) -> x
08:40:36 <paolino> byorgey: in some way monads have bent the applicative choices away from zippy
08:40:43 <Kus> paolino:  for example?     mid   = [y | y <- xs\(_,x,_), y== \(_,x_) ]
08:41:16 <sajkr> it seems to work. yaaaaay!
08:41:47 <sajkr> although i'm probably just splitting hairs.
08:41:54 <paolino> kus: let snd3 (_,x,_) = x in ....
08:42:36 <troydm> why doesn't this work (+1) <$> Maybe 1 ?
08:42:46 <troydm> Not in scope: data constructor `Maybe'
08:42:55 <paolino> it's Just 1
08:42:57 <troydm> yups
08:42:58 <hpaste> byorgey pasted “Shape-indexed trees with zip” at http://hpaste.org/53801
08:43:03 <troydm> sorry
08:43:18 <troydm> my mistake
08:43:41 <ExFalso> Does anyone know what this means?:
08:43:43 <ExFalso>  cabal: dependencies conflict: DiplomacyCommon-0.1 requires parsec ==3.1.2
08:43:45 <ExFalso> however
08:43:47 <ExFalso> parsec-3.1.2 was excluded because DiplomacyCommon-0.1 requires parsec
08:43:49 <ExFalso> ==2.1.0.1
08:43:55 <byorgey> paolino: see that paste.  Note how 'forestZip' does not have to deal with the cases where one side is Nil and the other is Sibling, because it is ruled out by the types
08:47:09 <ExFalso> ^anyone? i tried "any" and hardcoding the version, no success
08:47:59 <paolino> byorgey: very instructive , thanks
08:56:33 <monochrom> ExFalso: I want to see the output of "ghc-pkg list -v" and "ghc -v"
08:57:23 <ExFalso> :monochrom i think it started working after removing .ghc and .cabal and reinstalling everything
08:57:35 <monochrom> yes, that too
08:58:24 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml tells you many ways of getting it to happen again in the future
08:58:45 <ExFalso> thanks i'll chack that out
08:59:45 <monochrom> Diplomacy is a cunning game.
09:00:11 <hpaste> mmos1127 pasted “strict IO” at http://hpaste.org/53802
09:01:21 <hpaste> mmos1127 annotated “strict IO” with “strict IO (annotation)” at http://hpaste.org/53802#a53803
09:02:02 <hpaste> mmos1127 annotated “strict IO” with “strict IO” at http://hpaste.org/53802#a53804
09:03:14 <Phyx-> you could be jobless
09:04:05 <Phyx-> export
09:04:08 <Phyx-> make
09:04:16 <PiRSquared17> @pl \x -> \y -> y (fix x) y
09:04:17 <lambdabot> join . flip id . fix
09:05:09 <Kus> paolino: what is snd3?
09:05:38 <paolino> a function to extract the second element of a triple
09:05:45 <Kus> not i scope it says
09:06:08 <Kus> so i should define it myself?
09:06:15 <paolino> I don't think it's somewhere, yes
09:06:41 <paolino> @hoogle (a,b,c) -> b
09:06:41 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
09:06:41 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
09:07:08 <paolino> maybe Data.Tuple has it
09:07:47 <Kus> ok will try import Data.Tuple
09:11:16 <paolino> Kus, imo if you have a triple, or it's a pair with a pair and you access it with unreadable compositions of fst and snd or you miss a datatype containing the 3 elements.
09:11:38 <Kus> paolino: i just implemented it myself
09:11:54 <paolino> and use datatype selectors. Ok
09:12:24 * hackagebot safe 0.3.1 - Library for safe (pattern match free) functions  http://hackage.haskell.org/package/safe-0.3.1 (NeilMitchell)
09:19:30 <t3nsor> i built lambdabot and managed to get it to connect to my server but it won't join any channels
09:19:34 <mmos1127> somewhat beginnerish question about strict IO queston here: http://hpaste.org/53802 (look at the last annotation)
09:19:35 <t3nsor> has anyone else had th is problem
09:21:21 <copumpkin> skaar: what?
09:21:27 <copumpkin> skaar: you want to prevent it from being zero?
09:23:22 <mm_freak> ArrowChoice is more expressive than Category+Applicative, right?
09:25:17 <mm_freak> mmos1127: yes, switching to strict ByteStrings will most likely solve your problem
09:25:39 <mm_freak> mmos1127: the problem with lazy I/O is that you rely on the garbage collector to close files for you
09:26:21 <jhance> or use Data.Enumerator and the like for strict IO which is becoming really popular since strict bytestrings can't handle a huge load
09:26:33 <mm_freak> jhance: mmos1127 is a beginner
09:26:50 <mm_freak> also Data.Enumerator will use strict bytestrings under the hood
09:26:56 <parcs> copumpkin: should your spoon library handle RecConErrors, RecSelErrors, RecUpdErrors and NoMethodErrors? they seem 'purish' to me
09:27:21 <mm_freak> parcs: i'll release netwire 2.0.0 today
09:27:25 <mm_freak> =)
09:27:48 <jhance> mm_freak: Yes but if you just use strict bytestring IO there's a limit on the size of strict ByteString... I think. So if you want large files you need lazy or enumerator-based IO. But I missed half the conversation (just joined in #haskell)
09:28:24 <parcs> mm_freak: cool!
09:29:07 <mm_freak> jhance: mmos1127's problem right now is that handles are kept open for too long…  specifically stated he's a beginner, i'd really just go with strict bytestring I/O for now
09:29:13 <mm_freak> so that the program works
09:29:43 <mm_freak> enumerator I/O is really not for beginners
09:30:51 <monochrom> strict bytestring is  worth a try. only potential problem is too much memory
09:33:24 <mm_freak> i can never have too much memory
09:33:57 <copumpkin> parcs: sure, feel free to update it :) I probably won't get to it for a while
09:34:01 <mmos1127> jhance: I don't think the problem is the size of the files. They are a few megabytes.
09:35:01 <mmos1127> is the strict bytestring module just Data.ByteString?
09:35:13 <monochrom> yes
09:35:44 * monochrom should call it eager bytestring
09:36:24 * copumpkin cracks his whip
09:36:37 <jhance> I always felt it was odd that when laziness (well, nonstrict) is the default for mostly everything in haskell, the "default" bytestring is Strict in that you don't have to do Data.ByteString.Strict
09:37:02 <Shammah> Is there a way to have postfix function notation in Haskell?
09:37:11 <mmos1127> what is the equivalent of "lines" in ByteStrings?
09:37:14 <Shammah> e.g: let (!) = factorial    ->   5!
09:37:30 <monochrom> GHC can do postfix. but not Haskell.
09:37:45 <monochrom> as in, not standard Haskell
09:37:49 <Shammah> hmm
09:37:55 <mmos1127> something like groupBy (not . (== '\n') ) ??
09:38:13 <Shammah> But GHCi can?
09:38:43 <stepkut> is there someway to get PackageImports to import two different versions of the same package. Or do I have to rename the package and rebuild it. I want to do, import qualified "package-1.0" Foo.Bar as Old ; import "package-1.1" Foo.Bar as New
09:39:06 <stepkut> that works if I rebuild package as package-old
09:39:10 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
09:39:26 <Shammah> Thank you, monochrom
09:41:52 <monochrom> Data.ByteString.Char8.lines is your lines
09:45:41 <gtirloni> has anyone successfully used Hat recently with GHC 7.x?
09:46:50 <c_wraith> I think Hat bitrotted well before GHC 7 was released
09:48:06 <gtirloni> ok. i was asking before i spend the next week trying to build it :)
09:48:08 <gtirloni> thx
09:59:49 <gwern> hat was bitrotten with the 6.x series too
10:02:01 <hiptobecubic> Is anyone here from UU in the netherlands? I am planning on taking 'advanced functional programming' there, which is focused on Haskell, and I'm curious about opinions on it.
10:06:21 <c_wraith> hiptobecubic: I know nothing about the program, but I've used uu-parsinglib (part of their haskell compiler) and emailed its maintainer a couple times.  It's a good piece of software, and the maintainer (I think one of the professors there) is a nice guy in email. :)
10:06:46 <SavageSimian> i'm new to haskell and i'm trying to figure out monads. i'm not quite sure how to read the following type:  fmap :: (a -> b) -> (W a -> W b)
10:07:12 <shachaf> SavageSimian: You should probably not worry about monads for a while.
10:07:16 <shachaf> @where faq
10:07:16 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:07:19 <mm_freak> SavageSimian: try to replace the W by something concrete
10:07:24 <mm_freak> like Maybe
10:07:40 <mm_freak> fmap :: (a -> b) -> Maybe a -> Maybe b
10:07:56 <shachaf> SavageSimian: http://www.haskell.org/haskellwiki/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
10:08:18 <norter> sup
10:08:50 <norter> uhi]
10:08:56 <norter> hello[
10:09:08 <norter> hello theor
10:09:31 <SavageSimian> (a -> b) means a function that takes an 'a' and returns a 'b' ?
10:09:45 <shachaf> SavageSimian: Right, where a and b are type variables.
10:09:51 <byorgey> hi norter
10:09:58 <shachaf> SavageSimian: Do you understand the function "map" :: (a -> b) -> [a] -> [b]
10:09:59 <shachaf> ?
10:10:20 <norter> hi byor
10:11:31 <SavageSimian> ok. so we can call (a -> b) 'f' right? if so, the function f takes a list 'a' and returns a list 'b'
10:11:45 <mauke> no
10:12:09 <mm_freak> SavageSimian: i think you should learn the language basics first
10:12:31 <mm_freak> SavageSimian: functors are a simple concept, once you have the basics
10:12:57 <norter> '(a -> b)' may mean lots of things |:
10:13:12 <SavageSimian> like what?
10:13:37 <mauke> a function from a to b
10:13:40 <mm_freak> it means one precise thing?
10:13:40 <c_wraith> really?  I thought it was "a function, no restrictions on its argument or results types"
10:13:58 <mm_freak> in fact there aren't even many functions of that type
10:14:03 <SavageSimian> i read that as a function that takes an argument type 'a' and returns a type 'b'
10:14:06 <mm_freak> i'm counting two
10:14:24 <mm_freak> SavageSimian: you read correctly, just add that a and b are type variables, i.e. can be anything
10:14:27 <mauke> ⊥ and const ⊥?
10:14:38 <c_wraith> mm_freak: well, that depends on context.  You're assuming the forall binders are applied only to that function
10:15:24 <shachaf> mm_freak: You're taking the type out of context.
10:15:26 <SavageSimian> wraith i think you're talking about a deeper level of understanding. i just want to know the basic idea for now.
10:15:52 <c_wraith> SavageSimian: indeed, my comment is unrelated to your question...  Just mm_freak's comment
10:16:26 <shachaf> SavageSimian: What introduction to Haskell are you using to learn?
10:17:15 <mm_freak> c_wraith: i think the type variables are free here
10:17:17 <SavageSimian> right now i'm working thru wikibooks.org/Haskell/Understanding_monads
10:17:22 <mm_freak> we are still in the fmap context
10:17:42 <mm_freak> SavageSimian: i recommend a real book:  http://learnyouahaskell.com/
10:17:45 <mm_freak> you can read it online
10:18:03 <SavageSimian> the 'fmap' example was from something else.
10:18:12 <shachaf> SavageSimian: You're probably best off forgetting about monads for now.
10:18:15 <sjindel> IMO Real world haskell is the most helpful online book
10:18:35 <mm_freak> SavageSimian: as you see the chapter on what you are trying to learn right now is chapter 11
10:18:48 <c_wraith> mm_freak: in the fmap context, they foralls are at a level where each type variable is mentioned multiple times, so that (a -> b) can have any implementation whose type *unifies* with (a -> b).  That's a lot different than just having a function with the fully-polymorphic type (a -> b)
10:19:05 <SavageSimian> i read a few pages of learn you haskell now. i felt that it was maybe a bit too gentle an introduction...
10:19:45 <shachaf> SavageSimian: If you want a less gentle introduction to Haskell, try _A Gentle Introduction to Haskell_
10:19:54 <shachaf> @where tutorial
10:19:54 <lambdabot> http://www.haskell.org/tutorial/
10:19:55 <mm_freak> c_wraith: all types a and b unify with a -> b in the fmap context…  that's an inherent feature of the Functor interface
10:19:57 <c_wraith> SavageSimian: Ah, so the problem is that you think haskell is hard and are treating it as such.  go with the introduction that doesn't make it seem hard.  Then it will proceed to be not hard. :)
10:21:12 <SavageSimian> the problem is that if i have to read 11 chapters before i get to anything interesting i'm going to fall asleep and never make it...
10:21:34 <c_wraith> SavageSimian: well, with the questions you're asking, there'll be things in chapter 3 that are new to you
10:21:41 <c_wraith> if not earlier
10:21:50 <shachaf> SavageSimian: There are plenty of interesting and tricky things to learn in earlier chapters.
10:21:52 <c_wraith> also, quit thinking about monads.  they're *just not important*
10:23:10 <SavageSimian> monads are the next chapter in wikibooks. since i'm reading it sequentially, i'm assuming that necessary prerequisites have been covered and i'm just missing something.
10:23:29 <shachaf> You've read the entire wikibook up to chapter 11?
10:23:55 <shachaf> Either the wikibook has big holes or you haven't understood it very well.
10:24:01 <c_wraith> learning to understand type signatures - that's important.
10:24:08 <c_wraith> and that's what your initial question was about
10:24:22 <SavageSimian> i don't know what chapter it is... but it's the next page in the book...
10:24:32 <c_wraith> don't assume that the wikibook is any good at all
10:25:10 <c_wraith> if you are having trouble with type signatures, you're far from ready to understand higher-kinded type classes.
10:25:55 <gtirloni> the FAQ is quite funny in naming the monad chapter as "The M-word".. I'll be using that :)
10:26:20 <c_wraith> monads just aren't important.  Sad that so many people make such a big deal out of them.
10:26:50 <SavageSimian> i'm not really assuming anything. i'm just reading the next page which happens to be on monads. as to type signatures, i know the basics. i'm simply trying to figure out why there are enclosing parenthesis around (a -> b) if it simply means f a -> b where 'a' and 'b' can be any type...
10:27:11 <c_wraith> then you really don't know the basics.
10:27:16 <c_wraith> @type map
10:27:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:27:50 <SavageSimian> ok you're right. i don't have the brain power to understand haskell... thanks for your help.
10:28:12 <c_wraith> I'm not saying that at all
10:28:17 <gtirloni> if there weren't parenthesis that type declaration would mean map accepts 3 arguments.. and returns [b]..
10:28:18 <mm_freak> SavageSimian: are you learning haskell for production or are you looking for brain teasers?
10:28:21 <c_wraith> I'm just saying you skipped an important bit
10:28:32 <c_wraith> and you should go back and make sure you get it.
10:28:36 <c_wraith> because it really is important
10:28:46 <mm_freak> SavageSimian: because if you want brain teasers i suggest trying to solve the Project Euler problems using haskell
10:29:13 <mm_freak> they start easy, but become gradually more difficult
10:29:21 <SavageSimian> i'm looking at haskell as a learning tool to help me understand the methodology behind functional programming.
10:29:41 <c_wraith> SavageSimian: haskell is built from a *lot* of simple parts..  But it quickly starts synthesizing those parts together in ways that become complicated.
10:29:59 <c_wraith> SavageSimian: if you don't understand each simple part thoroughly, you won't be able to follow the synthesis.
10:30:17 <c_wraith> SavageSimian: it doesn't mean you're not smart, it just means there's something you missed
10:30:29 <mm_freak> also you can learn haskell as a functional language and still feel completely lost in, say, scheme
10:30:31 <c_wraith> SavageSimian: believe me, it's easy to miss these things. :)
10:30:40 <SavageSimian> and i am trying to identify what it is that i missed.
10:30:51 <SavageSimian> so far that hasn't happened.
10:30:52 <c_wraith> Ok..  My answer is "type signatures"
10:31:05 <mm_freak> SavageSimian: the type system altogether, start with writing and understanding type signatures
10:31:48 <mauke> SavageSimian: precedence
10:31:57 <mauke> SavageSimian: (a -> b) -> c is not the same as a -> (b -> c)
10:32:20 <mm_freak> i think SavageSimian got that, though i'm not sure
10:32:33 <gtirloni> i know the feeling.. you've been programming in imperative languages for years and switching from one to another is easy as quickly checking a book and not bothering much with exercises. i'm finding that with haskell/FP i've to go back to the basics of learning and actually do all that stuff.. otherwise i keep getting lost while trying to read other people's code
10:32:45 <SavageSimian> yes mauke. i understand that. but is (a -> b) a function?
10:32:57 <mauke> SavageSimian: well, the type of a function. but yes
10:33:22 <sjindel> A function from type a to type b
10:33:34 <SavageSimian> ok. so the function (a -> b) takes an argument 'c' right?
10:33:42 <mauke> what does that mean?
10:33:45 <mm_freak> SavageSimian: (a -> b) is not a function
10:34:02 <mm_freak> it's the /type/ for functions, which take an argument of type 'a' and produce a result of type 'b'
10:34:11 <SavageSimian> i'm getting conflicting answers...
10:34:14 <kirindave> I know this is a long shot but...
10:34:20 <mauke> SavageSimian: not really
10:34:25 <kirindave> Has anyone written haskell bindings for the opscode chef restful api?
10:34:27 <mauke> SavageSimian: Int is not a number
10:34:40 <SavageSimian> i know that. and i know what a type is.
10:34:48 <kirindave> It's not a huge amount of work to write one, but it's tedious because the api's underlying structure is primarily documented by the ruby code that calls it. :\
10:35:09 <mm_freak> SavageSimian: now extend that
10:35:17 <mauke> SavageSimian: I think that's all mm_freak is saying
10:35:28 <mm_freak> just like Int is not a number, but the type for numbers
10:35:29 <SavageSimian> Int is a type, Integer is a different type, String is a type...
10:35:41 <mm_freak> Int -> Int is the /type/ for a function that takes an Int and produces an Int
10:35:48 <mm_freak> with "an Int" i mean a value of type Int
10:35:56 <mauke> :-)
10:36:05 <SavageSimian> got that already.
10:36:18 <mm_freak> good, now ask yourself, where did your 'c' come from? ;)
10:36:21 <SavageSimian> and in the above 'a' is a generic type.
10:36:48 <SavageSimian> the 'c' came from mauke's example above.
10:36:49 * monochrom doesn't know where 'c' suddenly comes from either
10:36:49 <mm_freak> SavageSimian: in haskell we call them polymorphic, not generic…  "generic" is an entirely different concept
10:37:13 <mauke> SavageSimian: oh?
10:37:17 <ET_> @ pl (&) f g x = (f x) && (g x)
10:37:36 <ET_> @pl (&) f g x = (f x) && (g x)
10:37:36 <lambdabot> (line 1, column 11):
10:37:36 <lambdabot> unexpected "="
10:37:36 <lambdabot> expecting variable, "(", operator or end of input
10:37:43 <byorgey> ET_: liftA2 (&&)
10:37:49 <SavageSimian> ok. polymorphic. the idea is that a of a function that takes multiple types.
10:37:54 <mauke> SavageSimian: then let's talk about speng :: (a -> b) -> c and glorp :: a -> (b -> c)
10:37:54 <monochrom> then the answer is no, whatever function we're talking about doesn't take 'c' as argument
10:37:58 <byorgey> > liftA2 (&&) f g x
10:37:58 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Bool.Bool)
10:37:58 <lambdabot>    arising from a us...
10:38:03 <daavidb> is : (cons) a function in haskell?
10:38:10 <mauke> daavidb: yes
10:38:12 <mm_freak> SavageSimian: now look at the 'map' function:  map :: (a -> b) -> [a] -> [b]
10:38:22 <byorgey> daavidb: yes, and more specifically, it is a data constructor
10:38:42 <mm_freak> SavageSimian: all that is saying is that the two 'a' types are equal and the two 'b' types are equal
10:38:54 <mm_freak> it takes a function, which takes a value of type 'a' and produces a value of type 'b'
10:38:59 <mm_freak> it takes a list of values of type 'a'
10:39:05 <mm_freak> and produces a list of values of type 'b'
10:39:13 <daavidb> byorgey: what sets a data constructor apart from a function that just returns data? like +?
10:39:38 <byorgey> daavidb: every data type is defined as being built out of a set of data constructors
10:39:47 <monochrom> data constructor can participate in pattern matching. other functions cannot
10:39:58 <mauke> daavidb: you can use them in patterns
10:39:58 <mm_freak> SavageSimian: you have abstracted the source and destination type away…  but you still have a fixed data structure, the list
10:39:59 <byorgey> daavidb: in the case of (:), lists are defined as being built from [] and (:)
10:40:06 <SavageSimian> i think that's pretty much what i said at the beginning except that i didn't specify 'a' and 'b' as types...
10:40:16 <mm_freak> SavageSimian: abstracting that data structure away you get a functor
10:40:32 <mm_freak> that generalizes map to fmap:  fmap :: Functor f => (a -> b) -> f a -> f b
10:40:38 <mauke> SavageSimian: I said "no" to you at one point when you said 'a' and 'b' were lists
10:41:15 <SavageSimian> [] lists right?
10:41:32 <mauke> you accidentally a verb there
10:41:38 <mm_freak> [] is the type constructor for lists (and also, when treated as a value, the empty list)
10:41:47 <SavageSimian> [a] means a list containing 'a'
10:41:57 <mm_freak> yes, values of type 'A'
10:42:00 <mm_freak> 'a'
10:42:04 <monochrom> it seems "lists" is the verb
10:42:18 <mauke> but how do you list wrong?
10:42:20 <copumpkin> I didn't realize lists was an intransitive verb
10:42:32 <drhodes> not wrong, left
10:42:32 * copumpkin considers
10:42:42 <rwbarton> actually it is
10:42:48 <rwbarton> at the risk of being terribly off-topic
10:42:52 <mm_freak> c'mon guys…  we're not #math =)
10:42:53 <jessopher> every noun is an intransitive in modern english
10:43:08 <mauke> stop preposterousing
10:43:09 <copumpkin> you accidentally
10:43:13 <c_wraith> copumpkin: lists is an intransitive verb with the meaning "tilting to one side", usually applied to boats. :)
10:43:23 <copumpkin> c_wraith: well yeah, but not in that use :P
10:44:01 <copumpkin> weird, it also means something else
10:44:05 <copumpkin> "want"
10:44:14 <c_wraith> oh, yes, it does
10:44:14 <copumpkin> I'd never come across that usage :)
10:44:18 <SavageSimian> therefore (a -> b) -> [a] -> [b] is a function taking type 'a' as an argument and returning type 'b'. this 'thing' of type 'b' then takes an argument type [a] and returns a type [b]
10:44:24 <copumpkin> [] wants, indeed
10:44:26 <c_wraith> the only time I see that use is in the word "listlessly"
10:44:28 <monochrom> every noun is a verb in ancient chinese. confucius said he wived his daughter to a student
10:44:29 <copumpkin> it wants a *
10:44:32 <mauke> SavageSimian: no
10:44:42 <copumpkin> monochrom: shi shi shi shi shi shi shi shi shi shi
10:44:46 <mauke> SavageSimian: you're somehow reading this backwards
10:44:46 <jessopher> monochrom: lol
10:45:23 <mauke> SavageSimian: to a first approximation, in X1 -> X2 -> X3 -> ... -> Z, the X1, X2, X3, ... are arguments, and the Z is the result
10:45:40 <mauke> SavageSimian: so map takes two arguments ((a -> b) and [a]) and returns [b]
10:45:46 <mm_freak> SavageSimian: well, though your exact wording is wrong, i think your thought pattern is on the right way
10:46:01 <SavageSimian> mauke: ok. i get that.
10:46:37 <mm_freak> map takes two arguments, one of type a -> b and one of type [a]
10:46:45 <mm_freak> notice the parentheses around a -> b
10:46:54 <SavageSimian> i was looking at (a -> b) as the function being called and not an argument.
10:47:08 <mm_freak> it is an argument, and that argument is a function
10:47:09 <mauke> yeah, it doesn't work like that
10:47:12 <jessopher> high order dysfunction
10:47:26 <SavageSimian> ok. that's pretty much all i needed to know.
10:47:37 <mm_freak> SavageSimian: functions can take functions as arguments and produce functions as results…  that's what "higher order" is about
10:47:44 <daavidb> [1,2,3,4] !! 2 => [2,3,4] !! 1 => [3,4] !! 0 => 3. Correct reduction right?
10:48:01 <mauke> daavidb: depends on how you define !!
10:48:08 <SavageSimian> thanks mauke.
10:48:10 <mauke> but probably yes
10:48:37 <mm_freak> in fact every multi-argument function in haskell is in fact a single-argument higher order function
10:48:54 <daavidb> that i am aware of
10:49:00 <SavageSimian> yes. got that.
10:49:26 <SavageSimian> and i was reading (a -> b) as a higher order function.
10:49:47 <mm_freak> you can't say anything about the order of a -> b
10:50:01 <mm_freak> but if 'a' and 'b' are not function types, then a -> b is first order
10:50:01 <mauke> a -> b itself is first order ... well, if you squint
10:50:02 <Eduard_Munteanu> A -> B -> C -> D   ==    A -> (B -> (C -> D))
10:50:09 <daavidb> continuing the discussion from yesterday, i still don't see why the momoized fibonacci thing from http://www.haskell.org/haskellwiki/Memoization works. it seems to me that !! should cause the program to "forget" the older values in the list when it removes the head.
10:50:10 <mm_freak> however, 'map' is higher order
10:50:31 <mm_freak> SavageSimian: you have a higher order function, whenever you have parentheses in the type signature, which you can't remove
10:50:40 <mauke> daavidb: which one?
10:50:51 <daavidb> memoized
10:50:54 <daavidb> memoized_fib
10:51:18 <monochrom> daavidb: see my http://www.vex.net/~trebla/haskell/lazy.xhtml for why some data is forgotten after use and some are perpetuated
10:51:35 <zeiris> Suppose I'd like to parse a Python-like, indentation sensitive language. What library should I use?
10:51:36 <SavageSimian> what i was doing was reading (a -> b) as f (a -> b)
10:51:53 <SavageSimian> that would make f (a -> b) higher order right?
10:51:55 <monochrom> the final two case studies "average" and then "co-routines" if you want to skip
10:52:27 <byorgey> daavidb: the evaluation of *a particular call* to memoized_fib will indeed forget the older values.
10:52:40 * monochrom is not very consistent with "data is" and "data are"
10:52:44 <SavageSimian> if you remove the parenthesis it turns into a simple function f a -> b
10:52:48 <mauke> monochrom: I don't understand memoized_fib either
10:52:55 <byorgey> daavidb: however, the definition of memoized_fib itself still refers to the entire list
10:53:03 <mauke> monochrom: doesn't it construct a new (map fib [0 ..]) for each call to memoized_fib?
10:53:15 <jessopher> zeiris: anything parser combinator library that is a state monad would work. You have some part of the state represent indentation level
10:53:24 <mauke> SavageSimian: you've completely lost me. what notation is that?
10:53:25 <Eduard_Munteanu> SavageSimian: I'm not sure what you mean by 'f' there
10:53:41 <Mitsu> mmm haskell went from downloading at 150mb/s to 37mb/s ._.
10:54:22 <Mitsu> kb*
10:54:23 <Mitsu> not mb xD
10:54:35 <SavageSimian> Eduard: i was reading (a -> b) as f a -> b meaning a function that takes a type 'a' and returns a type 'b'
10:54:50 <mauke> SavageSimian: it is, but why is there an 'f' in there?
10:55:23 <SavageSimian> i was thinking that the parenthesis implied a function.
10:55:25 <Eduard_Munteanu> "takes a type" might be confusing.
10:55:28 <copumpkin> jaspervdj: I'm supposed to remind you :) also, I looked at pandoc's highlighting stuff and it's not pluggable in the least :(
10:55:35 <SavageSimian> () = f
10:55:45 <copumpkin> it's super hardcoded to assume highlighting-kate :(
10:55:57 <td123> is the factorial function defined anywhere in the haskell standard library?
10:55:59 <mauke> SavageSimian: no, -> means function
10:55:59 <jessopher> zebris: or, you could decorate your ast with indentation level's. the requirements are the same as keeping track of position in the source file
10:56:00 <Eduard_Munteanu> It rather takes *values* of a given type, and returns other values.
10:56:08 <byorgey> td123: no
10:56:10 <mauke> SavageSimian: f does not mean function
10:56:13 <Eduard_Munteanu> Ah, no, () isn't application or anything like that.
10:56:16 <td123> byorgey: any reason?
10:56:27 <byorgey> td123: because it's super easy to write yourself
10:56:33 <byorgey> > product [1..100]
10:56:34 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:56:42 <td123> byorgey: so are most of the functions :P
10:56:50 <mauke> td123: you never need factorial
10:56:58 <byorgey> td123: true, but most of the functions in the Prelude are general-purpose
10:57:05 <byorgey> td123: factorial is fairly specialized
10:57:09 <monochrom> factorial and fibonacci are not define in the standard library
10:57:13 <td123> ok, thanks
10:57:24 <SavageSimian> mauke i was grouping (a -> b) and calling it by an arbitrary name 'f'
10:57:30 <monochrom> perhaps because they are homework
10:57:46 <jessopher> there should be a standard homework prelude
10:57:49 <monochrom> but I prefer to believe that it is because they are useless
10:57:50 <td123> monochrom: that's just ridiculous :P
10:57:59 <byorgey> jessopher: hehe
10:58:00 <jaspervdj> copumpkin: But you can edit the pandoc tree
10:58:07 <mauke> SavageSimian: hmm, f :: a -> b would work better for that
10:58:11 <jaspervdj> copumpkin: And map a chunk of code to some literal HTML
10:58:45 <SavageSimian> mauke: yes, i see that now. i was simply misreading the type signature.
10:58:54 <copumpkin> jaspervdj: ah, I see what you mean
10:58:55 <monochrom> like how if you start a haskell tutorial with fibonacci, people say it shows how useless haskell is
10:58:57 <mauke> SavageSimian: then you can say things like: I've got map :: (a -> b) -> [a] -> [b], so in map f xs we have f :: a -> b and xs :: [a] ...
10:59:18 <monochrom> then to your horror, the official python tutorial starts with fibonacci, too
11:00:11 <jessopher> i think it say more about people who say things than programming languages
11:00:28 <tvynr> So I'm a Haskell newbie and I'm having some difficulty with the toolchain.  Suppose I have a function whose body is a fairly complex expxression.  How might I determine the type of an arbitrary subexpression?
11:00:34 <Eduard_Munteanu> SavageSimian: literally speaking, 'f' in a type signature would "contain" stuff in 'a -> b', but not just that
11:00:45 <monochrom> I actually agree that fibonacci is useless boring and uninteresting and there are better examples for tutorials, but I still don't understand why the official python tutorial, of all tutorials, bother with fibonacci
11:00:50 <Eduard_Munteanu> :t id
11:00:51 <lambdabot> forall a. a -> a
11:01:02 <Eduard_Munteanu> :t id id
11:01:02 <lambdabot> forall a. a -> a
11:01:36 <mauke> tvynr: hmm, seems hard in general
11:01:42 <HaskellElephant> monochrom: I guess the author wanted to show off pythons sleak loop syntax...
11:01:54 <monochrom> yes jessopher, I am saying all these as reflections on the people behind
11:02:27 <SavageSimian> off topic: is there an easy way to put nics at the beginning of a reply in mIRC?
11:02:43 <jessopher> type part of the nick and hit tab
11:02:56 <SavageSimian> jessopher: ah ty.
11:02:59 <mauke> (tab completion)++
11:03:02 <HaskellElephant> And the there is pythons multiple variable assignment thingy wich also shows in a fibonacci...
11:03:14 <mm_freak> tvynr: i'd like that too, from time to time…  it's probably better to infer yourself and write the type signatures
11:03:15 <mauke> but watch out, IIRC mIRC completes in alphabetical order instead of last-spoken
11:03:22 <yitz> monochrom: instead factorial, we should provide the more general gamma function on the complex numbers.
11:03:25 <Botje> wow, mirc still exists?
11:03:38 <gtirloni> i'm a bit confused while reading the definition of seq in Prelude.hs.  "seq _ y = y" .. it's supposed to evaluate the first arg and return y.. however, wouldn't the use of "_" tell the compiler to actually ignore it (as in, not evaluate)?  i'm studying strict/lazyness/foldl'
11:03:48 <monochrom> mirc has bitrotted and no longer builds with GHC 7
11:04:12 <SavageSimian> mauke: yea. i figure i'll just type enough characters to eliminate ambiguity.
11:04:13 <mauke> gtirloni: that's not the actual source
11:04:19 * monochrom wonders how to compute gamma
11:04:21 <mauke> gtirloni: seq is built into the compiler (and magic)
11:04:46 <gtirloni> mauke: ah, just saw the "#ifdef __HADDOCK__" ...makes sense.
11:04:53 * monochrom types "monochrom" then tab to obtain the ": "
11:04:59 <HaskellElephant> mauke: Well more magic then any other function compiled with GHC atleast :)
11:05:02 <jessopher> parts of the prelude are 'filled out' by haddock just for clarity
11:05:22 <gtirloni> i was hoping to see seq and deepseq side by side
11:05:35 <monochrom> deeqseq calls seq, seq is primitive
11:05:38 <mauke> @src seq
11:05:38 <lambdabot> Source not found. That's something I cannot allow to happen.
11:05:46 * mauke ponders
11:05:55 <Eduard_Munteanu> Also, deepseq doesn't magically work on all datatypes.
11:06:07 <mauke> seq x y = const y $! x
11:06:17 <Eduard_Munteanu> You need to provide suitable definitions.
11:06:21 <Shammah> Hey, just a humble student here doing a tiny experiment, and I'm being left with a couple of questions: http://pastebin.com/ndt27PZB
11:06:23 <mauke> The paste ndt27PZB has been copied to http://hpaste.org/53805
11:07:23 <mauke> in functional programming you still write how to compute stuff
11:07:23 <paolino> @src deepseq
11:07:23 <lambdabot> Source not found. Wrong!  You cheating scum!
11:08:10 <monochrom> functional programming is not an excuse to write dumb algorithms
11:08:20 <Shammah> but basically the formula is the same, isn't it?
11:08:34 <mauke> it's completely different
11:08:45 <Shammah> hmm
11:09:14 <monochrom> here are two formulas. 0. sum (replicate 1000000 0).
11:09:29 <monochrom> they are "basically" the "same" formula, aren't they?
11:09:34 <Shammah> Hmm, I guess you're right
11:09:45 <monochrom> so why is the second one taking a lot of time?
11:09:48 <mauke> > let nPr n r = product [n - r + 1 .. n] in nPr 100000 50000
11:09:51 <lambdabot>   mueval-core: Time limit exceeded
11:09:58 <mauke> > let nPr n r = product [n - r + 1 .. n] in nPr 10000 5000
11:09:59 <lambdabot>   673100917215889240466781150550139922690827536331907288335323873456994993221...
11:10:38 <erus`> can i peek from an MVar while another thread has get'd it?
11:10:42 <mauke> > let product = foldl' (*) 1; nPr n r = product [n - r + 1 .. n] in nPr 100000 50000
11:10:43 <lambdabot>   843728408995482843708427164018884478482205242860891299538737906312980617669...
11:10:51 <mauke> erus`: no
11:11:06 <erus`> i need something that only locks for writes
11:11:21 <tvynr> mauke, mm_freak: Most disappointing.  The lack of the ability to get the type of an arbitrary subexpression is really screwing with my development process.  :-P  Thanks for confirming that this is apparently hard, tho.
11:11:34 <mauke> erus`: TVar?
11:12:00 <ion> Are there reasons to prefer MVar, Chan over TMVar, TChan in some situations?
11:12:17 <mauke> tvynr: you could try slapping (... :: ()) on it, then look at the error message
11:12:32 <yitz> Shammah: in principle, a compiler could be smart enough to do the algebra and optimize both of those to the same object code. in fact, we know that ghc doesn't.
11:12:33 <paolino> tvynr: add a false signature
11:12:41 <paolino> too late
11:12:41 <erus`> mauke: i cant lock :|
11:12:56 <Shammah> that's a shame, hehe
11:12:57 <mauke> erus`: huh?
11:12:59 <erus`> ok i need something i can lock, but can also peek
11:13:06 <mauke> erus`: lock how?
11:13:11 <yitz> Shammah: the haskell standard says nothing about how a compiler does things. only about what the value should be.
11:13:29 <erus`> lock so while one thread has get'd it another will wait
11:13:37 <erus`> until the first put's it
11:13:57 <mauke> erus`: what operations do you need?
11:14:06 <erus`> get set and peek
11:14:16 <ion> What will you do with peek?
11:14:20 <mauke> erus`: then what is put?
11:14:28 <erus`> put is set
11:14:33 <monochrom> haha, "meaningful" names again
11:14:56 <monochrom> but you should say something about why both get and peek
11:15:09 <mauke> erus`: do gets block each other?
11:15:13 <erus`> yes
11:15:34 <monochrom> or I should just ignore. not worth the effort
11:16:00 <erus`> monochrom: if a thread only needs to read a value not update it. it doesnt need to wait
11:16:25 <ion> Why does a thread need to read a lock value (without unlocking)?
11:16:29 <erus`> for example in a highly concurrent web server
11:16:48 <erus`> read the current user count
11:16:50 <erus`> or something
11:17:04 <mauke> erus`: well, that would be just a TVar
11:17:20 <monochrom> "get" and "peek" both mean to me "read but no update, no need to wait".
11:17:24 <mauke> what do you need the lock for?
11:17:58 <erus`> mauke: so that if two threads were to increment the value at the same time it wouldnt only increment once
11:18:12 <mauke> why would only increment once?
11:18:19 <ion> @hoogle atomically
11:18:20 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
11:18:20 <lambdabot> GHC.Conc atomically :: STM a -> IO a
11:18:20 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
11:18:31 <erus`> because they both read the value at the same time, then they both wrote value + 1
11:18:32 <mauke> atomically $ do { n <- get v; put v (n + 1) }
11:18:41 <monochrom> yeah, STM TVar will increment twice correctly
11:18:42 <mauke> erus`: atomically
11:18:53 <Runar> acumenically
11:19:34 <tvynr> mauke, paolino: I did that, actually; I slapped "::()" on an expression that contained a list of integers.  The error message that was produced was... less than helpful.  (http://pastie.org/2837831)
11:19:38 <ion> Another great example of a XY problem.
11:19:58 <gtirloni> xy?
11:20:07 <monochrom> or if you like MVar, use modifyMVar to incremenet, readMVar to read without update
11:20:17 <paolino> tvynr: x is a Int
11:20:27 <monochrom> the XY problem: http://www.perlmonks.org/index.pl?node_id=542341
11:20:31 <ion> http://mywiki.wooledge.org/XyProblem
11:20:38 <paolino> or a Num a => a
11:20:51 <mauke> tvynr: hmm. and if you use 'a' instead of '()'?
11:21:23 <mauke> tvynr: and your expression isn't a list of integers, it's a single number
11:21:28 <tvynr> paolino: Of course.  This is just a representative example.  :)  The problem is that the error message doesn't tell me what type/constraints the subexpression ought to have.
11:21:29 <gtirloni> ion, monochrom: thx. understood, didn't know it was called "xy".
11:21:37 <ion> modifyMVar documentation: This function is only atomic if there are no other producers for this MVar.
11:21:41 <monochrom> I didn't know until last month
11:21:47 <tvynr> mauke: Is "::" lower precedence than "$"?
11:21:52 <mauke> tvynr: yes
11:22:03 <monochrom> yes ion that's easily satisfied
11:22:06 <mauke> <mauke> tvynr: you could try slapping (... :: ()) on it, then look at the error message
11:22:15 <Eduard_Munteanu> tvynr: the :: doesn't apply to the list
11:23:00 <tvynr> mauke, Eduard_Munteanu: That results in something a bit more usable, yes -- "Couldn't match expected type `()' with actual type `[b0]'" ... sadly, it doesn't tell me what the constraints on b0 should be
11:23:17 <mauke> tvynr: change () to [b0] and try again :-)
11:23:24 <monochrom> not because you have the discipline to stick to modifyMVar in all code, but because you use abstractions and hide the MVar in the first place
11:24:06 <tvynr> mauke: Wow.  "No instance for (Num b0)".  That's a lot closer... just wish this wasn't such a manual process.  :-P
11:27:38 <monochrom> how about http://pastie.org/2837872 ?
11:27:55 <monochrom> damn sorry, typo there, need correction
11:28:19 <monochrom> corrected in-place
11:28:22 <lpsmith> hmm, is there a way with HUnit to maintain state across tests?
11:29:22 <lpsmith> I suppose I could make fewer,  bigger, longer tests
11:34:51 * earthy boggles at the concept of maintaining state
11:35:53 <jessopher> state is a thing to be thrown out on a whim, without hesitation, HUnit enforces this invariant
11:46:52 <mmos1127> I messed up. A few months ago I installed the Haskell Platform. I used an older version, back to early 2010, but I don't know how to find out the exact version I used. Then just now, when I was interested in using Data.ByteString, I used cabal to install "bytestring". But I think that was already in the platform. I'm also using "binary" and when I got a bunch of errors that seemed to be compatibility
11:46:52 <mmos1127> problems, I "cabal install binary". Now I'm getting a link error: "I found a duplicate definition for symbol" How can I restore things?
11:47:42 <monochrom> go into ~/.ghc , erase some things
11:49:15 <reynir> is cabal good?
11:49:26 <applicative> cabal is good
11:50:38 <mmos1127> monochrom: I'm on Windows XP and I can't find a .ghc (looked in Documents and Settings, and also in %HOME%
11:51:36 <monochrom> windows is /windows/Users/?/AppData/Roaming/ghc/
11:51:53 <applicative> mmos1127 wait, the problem might be that bytestring comes with the Haskell lplatform.  It should have been planted in the global chunk of the system.
11:52:01 <monochrom> hrm, XP? then I forgot. OME%/AppData/Roaming/ghc/ ?
11:52:45 <monochrom> hrm, xchat ate my percent
11:52:51 <mmos1127> applicative: definitely bytestring comes with the platform. I was using it before I did "cabal install bytestring"
11:52:53 <monochrom> %HOME%/AppData/Roaming/ghc/ ?
11:52:55 <applicative> mmos1127: try ghc-pkg.exe and the assorted subcommands
11:53:11 <mm_freak> is there a reason why it's MonadFix and not FunctorFix?
11:53:16 <mm_freak> history again?
11:53:20 <applicative> ghc-pkg list should  mention the places where files are registered or whatever the word is
11:53:46 <reynir> I tried once to use cabal on debian stable
11:53:52 <aninhumer> Perhaps it's been suggested before, but perhaps Haskell should have some means to indicate equivalent functions in other modules which can be safely overloaded?
11:54:11 <Mitsu> mmm does anyone think they have time on their hands to introduce me into haskell?
11:54:16 <reynir> lol
11:54:17 <mm_freak> aninhumer: what would that look like?
11:54:20 <roconnor> does anyone know the story for mutually recursive data types and inital algebras?
11:54:22 <applicative> mm_freak, well you want to use it in monad land for recursive do and so on....
11:54:34 <mm_freak> Mitsu: do you have difficulties with the online introductions?
11:54:34 <mauke> Mitsu: do you have ghci?
11:54:44 <mmos1127> applicative: yes ghc-pkg gave me the directory where it appears all the stuff I have installed explicitly live
11:54:45 <Mitsu> mm_freak I do :)
11:54:46 <applicative> Mitsu its all we ever do
11:55:02 <aninhumer> mm_freak: well I'm not sure about syntax, but for example fmap could be called map and safely overload Prelude.map
11:55:07 <Mitsu> mauke I do
11:55:08 <aninhumer> I think
11:55:09 <mmos1127> applicative: so what do I do? "unregister"?
11:55:25 <mm_freak> Mitsu: i think most of us are willing to help you with specific problems, but a full, general introduction is out of scope of this channel
11:55:38 <Mitsu> That's fine, I'll just look up documentation
11:55:52 <mauke> preflex: ? lyah
11:55:52 <elliott> Mitsu: have you tried learn you a haskell? it's really good :
11:55:52 <preflex>  http://learnyouahaskell.com/
11:55:52 <elliott> :p
11:55:53 <applicative> mmos1127:  I'm not sure why a bad bytestring installed by cabal install should matter, do you see it in the first 'global' bunch of (platform) packages, or in the second bunch?
11:55:56 <Mitsu> I'm used to working with an ide with C#, java, ect so I'm like owut right now d:
11:55:57 <zeiris> What library should I use to write the parser for an indentation-aware programming language?
11:55:58 <aninhumer> Obviously you can just import hiding, but in some cases automatic overloading would be safe and convenient
11:56:04 <mm_freak> aninhumer: how would the compiler determine /implementations/ to be equivalent?
11:56:23 <mmos1127> applicative: I see an earlier bytestring in the first bunch, and a later bytestring in the second
11:56:31 <mm_freak> aninhumer: particularly in the fmap case, where fmap doesn't even have a definition
11:56:59 <applicative> okay, then do ghc-pkg unregister bytestring-XXX for the second version, which should be the one you installed.
11:57:12 <mm_freak> Mitsu: i can recommend two books, both of which can be read online for free:  real world haskell (RWH) and learn you a haskell for great good (LYAH)
11:57:15 <monochrom> you do not know that bytestring is the only duplicate package
11:57:15 <aninhumer> mm_freak: My suggestion is that the coder can assert them to be equivalent
11:57:36 <mm_freak> Mitsu: http://book.realworldhaskell.org/, http://learnyouahaskell.com/
11:57:37 <aninhumer> and the burden of rigorous proof falls to them
11:57:38 <monochrom> in fact duplicate packages come in whole groups
11:57:58 <mm_freak> Mitsu: one difference with haskell and what you are used to is that there isn't "the one" IDE
11:57:59 <Mitsu> will look at, thanks :3
11:58:08 <applicative> monochrom, yes. I was thinking we could unproblematically clarify the situation this way
11:58:14 <mm_freak> Mitsu: most haskell programmers use vim or emacs, some use leksah and eclipse
11:58:35 <monochrom> if you have not seen the verbatim output of "ghc-pkg list -v" you clarify absolutely zilch
11:58:41 <Mitsu> I have eclipse so yeah
11:58:53 <Mitsu> didn't know you could program haskell with it although I really don't know anything about haskell :3
11:58:56 <mm_freak> Mitsu: then you might be interested in EclipseFP
11:59:05 <applicative> monochrom: there are many more actions ahead of us
11:59:37 <mmos1127> applicative: worked! well now I'm getting another runtime error but I think that's my programs fault
12:00:16 <Mitsu> ohi jared
12:00:24 <aninhumer> an example syntax would be module AbstractFoo (foo) overloads (Foo.foo) where
12:00:24 <mm_freak> Mitsu: http://eclipsefp.github.com/
12:00:44 <applicative> if you open ghci and 'import Data.ByteString.Char8' then type something random, e.g. pack "hello", it looks okay?
12:00:50 <jhance> Mitsu: Hmm? You talking to me or someone else?
12:00:54 <Mitsu> You lol
12:01:02 <Mitsu> <--greg
12:01:20 <jhance> Oh hi I guess.
12:01:23 <Mitsu> lol
12:01:33 <aninhumer> or more concretely module Functor (...map...) overloads (Prelude.map) ?
12:01:47 <mmos1127> applicative++
12:01:55 <daavidb> so i guess when meomoized_fib from http://www.haskell.org/haskellwiki/Memoization is read it must somehow also look into the definition of fib and see that fib refers back to memoized_fib? Otherwise it wouldn't "remember" the list as it computes it, and it wouldn't be memoized? But doesn't that contradict lazyness? To compute fib 0 it never has to look at the part of fib that refers to memoized_fib, so it seems to me it should com
12:02:20 <mauke> daavidb: yeah, I don't understand it either
12:03:32 <elliott> mauke: hmm? it looks like regular thunk-based memoisation to me
12:03:46 <aninhumer> It would provide a means to avoid unnecessary namespace crowding, and indeed memorisation, when some functions are just more abstract versions of others that only exist to give a simple type
12:04:03 <mauke> elliott: doesn't it construct a new (map fib [0 ..]) for each call to memoized_fib?
12:04:05 <aninhumer> I suppose it's an alternative to the "basic/advanced Prelude" idea
12:04:09 <elliott> mauke: no, it's not a lambda
12:04:22 <elliott> mauke: the top level thing looks like (map foo [0..] !!), the let clause is just obscuring it
12:04:29 <mauke> d'oh
12:04:30 <mauke> yes, of course
12:04:44 <elliott> unfortunately, I doubt this is the difficulty daavidb is having :)
12:04:55 <jhance> it's just list of thunks that evaluate and when the thunks evaluate you get the memoization since the thunks don't have to reevaluate
12:05:10 <jhance> I don't see how that contradicts laziness; rather, it uses it to its effect
12:05:27 <applicative> it's pretty obscure that memofib
12:05:59 <jhance> Let's just agree to use zipWith (+) :)
12:07:12 <elliott> applicative: jhance: it's more general than the zipWith one since you can use it on anything with integral range
12:07:18 <elliott> although you probably still don't want to use a list :P
12:07:23 <jhance> elliott: Yes, I know ;)
12:07:48 <jhance> elliott: Simply pointing out that memoization should be a last result if something more elegant doesn't fit the problem
12:07:52 <elliott> Yeah
12:07:52 <monochrom> jhance: here it is crucial to stick to one single copy of "map fib [0..]", and part of the question is whether it is actually done
12:08:37 <monochrom> and my http://www.vex.net/~trebla/haskell/scanl.xhtml has a better fib
12:10:25 * applicative prefers the human calculated fibonaccis http://hackage.haskell.org/package/gutenberg-fibonaccis
12:10:55 <elliott> applicative: that package still exists??
12:11:02 <elliott> without a deprecated notice? :P
12:11:16 <jhance> applicative: That's a terrible package; O(n) retrieval for a constant table of fibs?
12:11:19 <applicative> wasn't it deprecated before it was written
12:11:26 <monochrom> holy sacred god
12:11:27 <elliott> jhance: you just don't understand the _beauty_
12:11:47 <jhance> At least use an array or vector!
12:12:02 <Mitsu> rofl
12:12:08 <elliott> the best part is definitely lastFib
12:12:17 <applicative> its sublime
12:12:18 <elliott> if Gutenberg find any more fibonacci numbers, your code will keep working
12:12:28 <daavidb> so the "map fib [0....]" is the thunk?
12:12:37 <daavidb> or turns into a thunk
12:12:46 <jhance> It also tends to iterate the list twice
12:13:03 <applicative> package update, older dependencies may break on new lastFib
12:13:06 <jhance> because nthFib does a length check on the list which requires it to traverse the entire list ;)
12:14:28 <applicative> it is classified under "math" and "numerical"
12:14:54 * applicative proposes the 'some nice integers' package, with a few of his favorites.  
12:15:38 <elliott> jhance: that's amazing
12:16:16 <luite> jhance: the list size is fixed, so it's all O(1)
12:16:45 * monochrom proposes that the nice integers package contains all integers on OEIS
12:17:10 <shachaf> monochrom: Not *all* of them.
12:17:16 <shachaf> 3 is most emphatically not a nice integer.
12:17:40 <monochrom> 3 is very nice. smallest odd positive prime
12:18:07 <shachaf> 5 is not nice at all.
12:18:08 <applicative> 17 is good. 19 is very good.
12:18:13 <leoncamel> Hey, is there anybody else who got *concurrency* work well on *Mac* ?
12:18:22 <parcs> > let fibs = 0 : zipWith (+) fibs (tail fibs) in fibs !! 999
12:18:25 <monochrom> why all the *s?
12:18:25 <lambdabot>   mueval-core: Time limit exceeded
12:18:53 <elliott> I realise Enum is basically lawless, but is it OK to rely on pred == toEnum . subtract 1 . fromEnum and similarly for succ?
12:19:00 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999
12:19:01 <lambdabot>   268638100244853593861467272021429239676166093189869523401231759976179817002...
12:19:03 <monochrom> but I haven't heard concurrency worked any worse on mac
12:19:04 <applicative> gutenberg fibonaccis, it only takes 2.5 minutes to compile, and you get all 1001 of them.
12:19:11 <elliott> > toEnum (3.4 :: Float)
12:19:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:19:12 <lambdabot>         against inferred type ...
12:19:12 <elliott> erm
12:19:14 <elliott> > fromEnum (3.4 :: Float)
12:19:15 <lambdabot>   3
12:19:17 <elliott> >_<
12:19:18 <jhance> take 10 $ fibs = 0 : 1: zipWith (+) fibs (tail fibs)
12:19:22 <elliott> > succ (3.4 :: Float)
12:19:23 <lambdabot>   4.4
12:19:24 <jhance> ahh forgot carot whatever.
12:19:34 <parcs> oh rite
12:19:40 <Cale> elliott: I'd say that's pretty reasonable. I would avoid building that assumption into a compiler, but for most instances you'll be fine.
12:19:43 <parcs> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999
12:19:44 <lambdabot>   268638100244853593861467272021429239676166093189869523401231759976179817002...
12:19:47 <leoncamel> I build my program with "-rtsopts -thread", can I can NOT make all cores work here.
12:19:50 <elliott> Cale: Just not floats :)
12:19:52 <applicative> leoncamel, what are you trying to do?  "import Control.Concurrent" or something particular.
12:20:03 <elliott> leoncamel: it's -threaded not -thread
12:20:08 <applicative> -threaded you mean? leoncamel
12:20:11 <Cale> elliott: Yeah, all the derived instances should satisfy that, I think.
12:20:17 <leoncamel> applicative: sure, I did import the concurrent module.
12:20:25 <elliott> Cale: Right, thanks. I'm mostly interested in non-float numerical types.
12:20:27 <monochrom> -threaded
12:20:31 <elliott> So... integers, I guess :P
12:20:32 <leoncamel> applicative: sure, -threadded.
12:21:03 <applicative> well, now we need to make sure it has something to thread, so to say.
12:21:06 <jhance> don't you have to... you know... do stuff like forkIO for it to concurrency? Not just import Control.Concurrent
12:21:11 <shachaf> If you want three threads maybe you need to use -threaddded.
12:21:25 <leoncamel> shachaf: joking ?
12:21:30 <shachaf> Yes, sorry.
12:21:31 * monochrom wants -breaded
12:21:47 <jhance> I forget can GHC optimize by making computations parallel without use of explicit par?
12:21:52 <monochrom> ghc --make -breaded haddock.hs
12:21:59 <shachaf> jhance: That's not concurrency.
12:22:03 <mauke> -bearded
12:22:15 <jhance> shachaf: Obviously; that's why I specificied "parallel"
12:22:19 <leoncamel> applicative: I checked "ghc --info"<, it show ("Support SMP","YES")
12:22:27 <monochrom> ghc --make -breaded haddock.hs -fried chips
12:22:28 <zeiris> Can you do indentation-aware parsing with trifecta? If not, how easy is it to hack in?
12:22:30 <shachaf> jhance: Wait, you're not leoncamel.
12:22:48 <shachaf> jhance: No, GHC doesn't insert automatic parallelism annotations or anything of that sort (as far as I know).
12:22:52 <applicative> leoncamel: if you are worried whether it works, try a random module like the victorious http://shootout.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1
12:23:05 <monochrom> you need explicit par or forkIO
12:23:24 <leoncamel> monochrom: sure, I use forkIO
12:23:28 <monochrom> and then at run time you need "myexe +RTS -N 4" or something
12:23:49 <leoncamel> monochrom: yes, I did add "+RTS -N4" options.
12:24:24 <jhance> leoncamel: Are you forking enough to create 4 threads?
12:24:48 <jhance> leoncamel: Or only forking, say, once, and then only 2 cores would be doing anything
12:24:56 <monochrom> anyway there are more than enough people here on Mac and no one observed a problem
12:25:46 <jhance> why don't you post code so we can see if it uses all cores on other OS's
12:25:48 <jhance> in order to isolate issue
12:26:08 <leoncamel> jhance: Oh, you mean it will only employee two cores, not fully 4 cores ?
12:26:28 <mauke> leoncamel: if you only have 2 threads ...
12:26:35 <jhance> leoncamel: Well if you only use forkIO once, you have 2 threads
12:26:46 <jhance> 2 threads run on 2 or less cores, not more than 2
12:28:36 <leoncamel> jhance: sure, I use " replicateM nThreads (forkIO (myFunc))" here.
12:28:50 <shachaf> You probably want replicateM_.
12:28:50 <jhance> leoncamel: Where nThreads >= 4?
12:29:05 <shachaf> Why don't you @paste your code rather than small snippets of it?
12:29:13 <shachaf> People might be able to say more that way.
12:29:23 <leoncamel> jhance: I am also sure, I pass nThreads==4.
12:29:37 <jhance> leoncamel: gist.github.com or pastebin.com or whatever please
12:29:46 <jhance> It'd help to see the whole module
12:31:15 <shachaf> jhance: Or there's hpaste.org.
12:31:17 <monochrom> we need a contest on the duration of time from question start to actual code. number of characters instead of duration of time is nice, too
12:31:26 <copumpkin> jaspervdj: still around?
12:31:51 <jaspervdj> copumpkin: Yes
12:32:28 <copumpkin> jaspervdj: jgm got back to me about adding it to pandoc, and it seems like I'd need to introduce an intermediate step to calling pandoc. How painful would that be in hakyll? he sent me this: http://pastie.org/private/avbwv2ncogsz7fw7yuqnq
12:34:28 <jaspervdj> copumpkin: Hakyll has support for plugging in an intermediate (Pandoc -> Pandoc), so (Block -> Block) is certainly possible as well
12:34:40 <jaspervdj> copumpkin: Afk, be back in 5 minutes!
12:34:49 <copumpkin> jaspervdj: excellent! I'll work on that Block -> Block function then :D
12:35:04 <copumpkin> jaspervdj: what about Block -> IO Block? :)
12:36:43 <jaspervdj> copumpkin: Also possible, but slightly harder to plug in
12:36:52 <shachaf> copumpkin: What do you think unsafePerformIO is for?
12:37:00 <leoncamel> jaspervdj: for the example : http://shootout.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1, it seems "-N4" are more slowly than "-N1" ? why ? Is it right?
12:37:24 <copumpkin> jaspervdj: alright, I'll work on it :)
12:37:44 <copumpkin> shachaf: it's almost entirely referentially transparent, but not quite
12:38:03 <jaspervdj> copumpkin: Once you have this Block -> IO Block, you can poke me, I guess
12:38:22 <mah_b> @hoogle powerset
12:38:22 <shachaf> leoncamel: That's probably because GHC kind of cheats when everything is on one thread.
12:38:22 <lambdabot> No results found
12:38:26 <shachaf> That benchmark is just silly.
12:38:37 <copumpkin> jaspervdj: cool, thanks again!
12:38:42 <jaspervdj> leoncamel: what shachaf said
12:38:50 <mah_b> is there a powerset function somewhere? If not, is there a elegant way to compute it?
12:38:59 <jaspervdj> copumpkin: I'm off for some longboarding now ;-)
12:39:03 <copumpkin> :t filterM (const [False, True])
12:39:04 <lambdabot> forall a. [a] -> [[a]]
12:39:06 <copumpkin> jaspervdj: enjoy!
12:39:11 <copumpkin> mah_b: that's it, up there, on lists
12:39:18 <copumpkin> > filterM (const [False, True]) [1..3]
12:39:19 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:39:47 <shachaf> > filterM (const [True,False]) [1..3]
12:39:48 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:40:06 <copumpkin> depends how positive your outlook on life is
12:40:12 <copumpkin> do you start by saying no, or by saying yes?
12:40:38 * copumpkin is a very negative person
12:40:41 <mah_b> :t filterM
12:40:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:41:06 <mah_b> copumpkin: thx
12:41:39 <shachaf> > let fM _ [] = return []; fM p (x:xs) = do { flg <- p x; ys <- fM p xs; return (if flg then x:ys else ys) } in fM (const [False,True]) [1,2,3] -- Control.Monad definition.
12:41:39 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:41:43 <shachaf> > let fM _ [] = return []; fM p (x:xs) = do { ys <- fM p xs; flg <- p x; return (if flg then x:ys else ys) } in fM (const [False,True]) [1,2,3] -- Much nicer.
12:41:44 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:41:53 <shachaf> See, now *that's* an ordering.
12:41:54 <leoncamel> shachaf: OK. Thanks.
12:42:33 * siracusa multiplies copumpkin by -1
12:42:51 <copumpkin> siracusa: luckily, I'm minBound :: Int
12:42:54 * shachaf quickly takes the square root of copumpkin.
12:43:08 <shachaf> Wait, that didn't work.
12:43:09 <copumpkin> > -1 * (minBound :: Int)
12:43:10 <lambdabot>   -9223372036854775808
12:43:15 <shachaf> Oh.
12:43:28 <shachaf> I guess the square root of an Int is a type error...
12:43:31 * shachaf foiled again
12:44:14 <siracusa> > minBound :: Int
12:44:15 <lambdabot>   -9223372036854775808
12:44:59 <djanatyn> :D :D :D
12:45:08 <djanatyn> I just went to the library and was browsing the shelves
12:45:21 <djanatyn> and I found a copy of "Learn You a Haskell for Great Good!"
12:45:35 <shachaf> > minBоund :: Integer
12:45:37 <lambdabot>   -99999999999999999999999999999999999999
12:45:37 <shachaf> Oh.
12:45:41 <djanatyn> I picked it up immediately. I've been messing around with lisp for a while, but this surprise makes me want to get involved in haskell
12:45:43 <shachaf> I guess that's the smallest integer.
12:46:22 <applicative> leoncamel: here is a fancy ack calculator using Control.Parallel and some fanciness I found on my machine http://hpaste.org/53810 it responds very favorably to -N2
12:46:50 <byorgey> djanatyn: awesome =)
12:47:00 <applicative> djanatyn: it's a great book
12:47:08 <byorgey> djanatyn: you have come to the right place!
12:47:39 <shachaf> #haskell: The Right Place.
12:47:46 <byorgey> (tm)
12:48:34 <edwardk> zeiris; there is a Layout parser transformer that provides you with haskell-style layout
12:48:52 <edwardk> zeiris: just use the 'laidout' combinator and pass it the parser you want to use for statements
12:49:27 <edwardk> zeiris: and it tweak the whitespace parser so that it doesn't treat outdents as 'whitespace'
12:51:43 <djanatyn> applicative: yeah
12:51:56 <djanatyn> I've read it online but I really enjoy reading books on the bus
12:52:08 <djanatyn> I usually read on the bus and then re-read more in depth when I get home
12:53:08 <applicative> djanatyn, well our friends here can help with any problems
12:54:11 * applicative specializes in type error statements, since he generates so many.
12:54:21 <monochrom> including the halting problem. just last night we had a volunteer oracle
12:54:59 <djanatyn> :)
12:55:02 <applicative> djanatyn, our friends can't help with the halting problem
12:55:13 <shachaf> @let willItHalt !_ = True
12:55:14 <lambdabot>  Defined.
12:55:55 <applicative> > let willItHalt !_ = True in willItHalt 3
12:55:55 <lambdabot>   True
12:56:02 <aristid> > willItHalt (fix id)
12:56:06 <lambdabot>   mueval-core: Time limit exceeded
12:56:08 <applicative> oh no!
12:56:13 <aristid> shachaf: didn't return False!
12:56:30 * aristid files a bug request
12:56:40 <mauke> > let willItHalt _ = True in willItHalt (fix id)
12:56:41 <lambdabot>   True
12:56:43 <mauke> problem solved
12:56:49 <shachaf> aristid: It would have if you'd given it more time.
12:57:00 <applicative> mauke is *real* Haskeller
12:57:17 <brisingr> define "real"
12:57:27 <Aune> not rational
12:57:40 <applicative> mauke but I think the function should be: will_I_halt, not, will_it_halt
12:57:56 <mauke> haltp
12:58:00 <shachaf> aristid: Is a bug request the opposite of a bug report?
12:58:13 <brisingr> Will I halt? Tell you tomorrow.
12:58:21 * applicative is trying to remember excellent ghc bugs he misses
12:58:28 <aristid> @let will_I_halt = fix id
12:58:29 <lambdabot>  Defined.
12:58:39 <mauke> will_I_am
12:58:51 <aristid> mauke: grammar bug
12:59:09 * applicative files a feature report
12:59:57 <aristid> {bug request, feature report} are just the dual of {bug report, feature request}
13:00:14 <brisingr> Bug #13577: Lambdabot is so damn stupid. RESOLVED: WONTFIX: Actually a feature
13:00:33 <shachaf> applicative: Like the bug where it deletes your source file if it doesn't type-check?
13:00:42 <aristid> shachaf: OOOOOOOOOOOOOOOOOOOOLD
13:00:46 * shachaf requests more bugs like that.
13:01:33 <applicative> that one sounded wonderful.
13:01:59 * applicative remembers somewhere simon p j saying 'the users, they were very understanding ...'
13:03:18 <aristid> applicative: combined with a good version control system, it was just a method of quality control
13:03:46 <applicative> yes
13:04:02 <brisingr> wait, it was actually a feature?
13:04:29 <mauke> preflex: quote . sensible
13:04:30 <preflex>  <augustss> ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
13:04:45 <applicative> bad file, no type check
13:05:23 <applicative> I would prefer a version where I get two chances before it deletes
13:06:38 <aristid> .oO(a file system that only lets you save files that typecheck)
13:07:04 <Phyx-> aristid: wouldn't you not be able to save any work in progress then?
13:07:23 <monochrom> put all incomplete work in string literals. type-checks.
13:07:25 <aristid> Phyx-: you can use undefined to stub out code that doesn't work
13:07:27 * applicative notices a brazilian  #haskell-br 
13:08:24 <Phyx-> lol
13:38:07 <DukeDave> <please_dont_shoot_me>Should this line work?  {-# OPTIONS_GHC -fno-warn-orphans #-}  </please_dont_shoot_me>
13:38:36 <DukeDave> I still get a: Warning: orphan instance
13:38:45 <elliott> It's for your own good!!!!
13:41:09 <DukeDave> elliott :(
13:41:58 <dmwit> DukeDave: Yes.
13:50:20 <jhance> aren't orphan instances acceptable in a package specifically for that instance though? Why would we shoot him? What if that's what he is doing with the orphans
13:50:54 <dmwit> Don't get in the way of my righteous zealotry.
13:52:19 <timp> I am struggling to use http://hpaste.org/ (I get no highlighting) see http://hpaste.org/53820
13:53:48 <dmwit> looks highlighted to me
13:54:43 <byorgey> it's highlighted but the highlight colors are very subtle.
13:54:56 <byorgey> depending on your monitor settings you may not notice.
13:55:12 <jhance> timp: Gists ;) I think they highlight
13:55:49 <jhance> timp: Nevermind they don't
13:56:04 <elliott> jhance: Yes they do... but they're not as nice as hpaste :)
13:56:27 <jhance> elliott: Oh I guess I have to name the file with a .hs ending :\
13:56:49 <elliott> jhance: I believe there's a language dropdown too.
13:57:29 <jhance> elliott: No, there's not
13:57:41 <elliott> jhance: There is, I'm looking at it on gist.github.com right now.
13:57:54 <jhance> elliot: Maybe its just not on "edit" then
13:58:19 <jhance> elliott: Yeah, its not under edit
13:58:26 <elliott> Heh.
13:59:24 <timp> OK, so maybe it is working as expected
14:08:35 <djanatyn> woo, checked out LYAH
14:12:03 <bovinespirit> \part
14:16:48 <lpsmith> wow, #haskell has been quiet today
14:17:16 <lpsmith> or the last couple of hours, at least
14:18:38 <jhance> Yep
14:18:54 <copumpkin> lpsmith: sssh, I'm hunting bunny wabbits
14:19:13 <lpsmith> heh
14:20:58 <Anonymous_> Hi all! Sorry for my English - i am only learning it.
14:21:22 <Anonymous_> Is here someone?
14:21:41 <shachaf> About 800 people.
14:21:47 <mauke> 859
14:22:01 <Anonymous_> ))) Maybe there all sleeping or something...
14:22:06 <zeiris> Just tried trifecta --> oh my GAWD look at those BEAUTIFUL error messages :OOOO
14:22:14 <edwardk> =)
14:22:32 <ion> :-)
14:22:36 <shachaf> edwardk: Do you have an automatic highlight on "trifecta"?
14:22:38 <edwardk> you can make them nicer with manual spans and fixits
14:22:43 <edwardk> shachaf: yes
14:22:51 <shachaf> Ah.
14:22:56 <shachaf> Not that psychic, then.
14:23:02 <zeiris> I'll get around to that eventually, I hope, but for now even a crude attempt looks :D
14:23:24 <edwardk> zeiris: <?> also helps a lot to get nicer diagnostic messages about what was expected
14:23:29 <edwardk> happy to hear =)
14:24:41 <edwardk> shachaf: i tend to highlight whatever projects i have going on that are being actively used
14:24:49 --- mode: ChanServ set +o copumpkin
14:24:55 --- mode: copumpkin set -o copumpkin
14:24:56 <copumpkin> whoops
14:25:01 <edwardk> shachaf: i used to have more but copumpkin kept spamming me ;)
14:25:31 <copumpkin> hey, dolio started it
14:25:32 <copumpkin> dolio
14:25:33 <copumpkin> dolio
14:25:47 <edwardk> what is worse is dolio is away from his computer, and its sitting next to me.
14:25:50 <shachaf> dolio is another one of edwardk's projects?
14:25:54 <edwardk> yes
14:26:03 <c_wraith> so mentioning dolio spams edwardk?
14:26:10 <copumpkin> no, mentioning dolio spams dolio
14:26:20 <monochrom> hahahahaha
14:26:26 * shachaf has an irssi hilight on "shachaf".
14:26:45 <shachaf> Because otherwise it doesn't highlight it unless it's right at the beginning of a message.
14:26:49 <shachaf> Stupid irssi.
14:27:12 <SpaceAviator> howdy people
14:27:25 <shachaf> SpaceAviator: Good evening.
14:27:52 <SpaceAviator> shachaf: how goes it?
14:27:58 <monochrom> get me straight on this: edwardk created dolio. dolio submitted oleg's delimited continuation to hackage. is that right?
14:28:18 <edwardk> i didn't create him. just dragged him out of ohio
14:28:30 <monochrom> ok, that's better
14:28:39 <shachaf> dohio
14:28:39 <edwardk> effectively the same thing
14:28:58 <edwardk> =)
14:29:38 <SpaceAviator> I am new to Haskell and excited to start :)
14:29:56 <SpaceAviator> I know a little bit of python - any suggestions before I begin my haskell journey?
14:29:58 <byorgey> SpaceAviator: well, you have come to the right place!
14:30:10 <c_wraith> SpaceAviator: keep an open mind, ask lots of questions
14:30:20 <copumpkin> SpaceAviator: DO NOT TRY MONADS
14:30:29 * byorgey presents SpaceAviator with a golden lambda, mounted on a little granite stand
14:30:30 <copumpkin> or rather, do not set out to understand them
14:30:32 <mauke> heh
14:30:38 <SpaceAviator> This might be an ignorant question but how is Haskell compared to Python?
14:30:47 * SpaceAviator bows down and accepts the present from byorgey
14:30:57 <byorgey> it's much more Haskellish
14:30:59 <c_wraith> haskell is...  rather unlike python.
14:31:04 <copumpkin> yeah, unpythonic to the max
14:31:11 <copumpkin> also, according to guido, haskell isn't functional
14:31:19 <mauke> wat
14:31:27 <dibblego> copumpkin: ?
14:31:30 <copumpkin> because in a true functional language, you can't implement functions like fold, they have to be primitives
14:31:32 <copumpkin> I shit you not
14:31:36 <byorgey> hahahaha
14:31:37 <Greenz0ne> If data constructors are functions, why do we write "data Vec = Vec Int Int" instead of "data Vec = Vec -> Int -> Int"?
14:31:37 <dibblego> you shit me
14:31:48 <mauke> copumpkin: [citation needed]
14:31:59 <shachaf> Greenz0ne: In GADT syntax you write: data Vec where Vec :: Int -> Int -> Vec
14:32:03 <byorgey> Greenz0ne: you can actually write  data Vec where  Vec :: Int -> Int -> Vec
14:32:15 <byorgey> shachaf: 1, byorgey: 0
14:32:25 <SpaceAviator> how do I scrape HTML with haskell? Thats what I have been doing with python lately and just wanteed a quick look
14:32:31 <edwardk> this is the problem with electing your benevolent dictators for life
14:32:46 <Greenz0ne> Oh, okay, Thanks :D
14:32:55 <shachaf> Greenz0ne: What you wrote doesn't seem to make much sense, though. A function that takes a Vec and an Int and returns an Int?
14:32:56 <c_wraith> SpaceAviator: same way as in python, really.  use existing http libraries for fetching, and existing tag soup libraries for parsing. :)
14:32:58 <Greenz0ne> Also I swapped the return type, hehe
14:33:01 <copumpkin> mauke: trying to find it again
14:33:02 <shachaf> Ah. OK.
14:33:07 <byorgey> @hackage tagsoup
14:33:07 <lambdabot> http://hackage.haskell.org/package/tagsoup
14:33:11 <Greenz0ne> Yeh my bad lol
14:33:16 <byorgey> SpaceAviator: ^^^ for example
14:33:17 <shachaf> Greenz0ne: Anyway, yes, the data declaration syntax is a bit weird.
14:33:25 <monochrom> do not translate python to haskell.
14:33:30 <shachaf> Greenz0ne: Keep in mind that you have some types, like data Either a b = Left a | Right b
14:33:36 <SpaceAviator> thanks byorgey!
14:33:46 <ocharles> Finally read the kind polymorphism paper. Wow. Kinda a big deal!
14:33:50 <copumpkin> mauke: http://books.google.com/books?id=yB1WwURwBUQC&pg=PA26&lpg=PA26&dq=%22Python+probably+has+the+reputation+of+supporting+functional+programming+based+on+the+inclusion+of+lambda%22&source=bl&ots=-CQEbEskcC&sig=BhMvQcuwoFnajnRFMXhvWM-5ey8&hl=en&ei=CwK7TrD1EPPKiAKShbS5DA&sa=X&oi=book_result&ct=result&resnum=1&ved=0CB4Q6AEwAA#v=onepage&q=%22Python%20probably%20has%20the%20reputation%20of%20supporting%20functional%20programming%20based%20on%20th
14:33:50 <copumpkin> sion%20of%20lambda%22&f=false
14:34:00 <copumpkin> mauke: here's the easier citation, http://www.reddit.com/r/haskell/comments/lxoo0/guido_van_rossums_criterion_for_when_a_language/
14:34:06 <ion> edwardk: Btw, if my code is not utterly stupid (a bit of cargo cult programming there since i didn’t bother to study the specifics of Pretty or the iteratee-level internals of Trifecta), perhaps you’ll find parse and parseE appropriate for inclusion in Trifecta. https://github.com/ion1/mchost/blob/master/MCHost/MCMessages.hs#L81
14:34:14 * dibblego prepares to be not shitted
14:34:16 <ocharles> byorgey: still look like ghc-kinds will be ready by the end of '11?
14:34:24 <mauke> coshit
14:34:33 <byorgey> ocharles: yep, I think so
14:34:41 <byorgey> looks like they will be in 7.4
14:34:53 <edwardk> ion: sounds good. i've added them to my 'to-patch' list
14:34:57 <Greenz0ne> Alright then, thank you :D
14:35:07 <ocharles> so cool. probably be the first reason I've had to build from head :)
14:35:14 <byorgey> hehe =)
14:35:23 <byorgey> ocharles: there's ConstraintKinds too =D
14:35:36 <ocharles> byorgey: yea, but this goes way above and beyond that :)
14:35:43 <shachaf> Hmm, "Functional languages are all about doing as much as possible at compile time".
14:35:43 <c_wraith> byorgey: ooh, if I pull, will it be in HEAD?
14:35:46 <shachaf> I didn't know that.
14:35:57 <edwardk> ConstraintKinds and polymorphic kinds together conspire to make some awesome code
14:36:01 <byorgey> c_wraith: I don't think the promotion + kind polymorphism stuff has been merged into HEAD yet
14:36:21 <c_wraith> ah.  sadness
14:36:21 <byorgey> c_wraith: check the commit logs, I guess
14:36:28 <edwardk> byorgey: merge! merge! merge! merge! =)
14:36:40 <ocharles> byorgey: oh, while you're here - the only thing that I got a little lost in the paper was the type level functor stuff. I kinda got it, but I just wondered if you knew of any (accessible :P) motivation
14:36:46 <mauke> copumpkin: you can't write foldl in a few lines of C! do you realize what this means?!
14:36:47 <ocharles> the IFunctor stuff
14:36:48 <monochrom> @quote monochrom synergy
14:36:49 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
14:36:55 <SpaceAviator> byorgey: that looks ... weird. I guess it will make sense soon.
14:36:59 <copumpkin> mauke: holy shit
14:37:14 <edwardk> ocharles: i have two of them in my recent posts on subtyping constraints
14:37:30 <byorgey> SpaceAviator: what looks weird?
14:37:34 <SpaceAviator> just the code
14:37:34 <ion> Our company is about burritos.
14:37:37 <c_wraith> so..  conal was right when he told us C is a purely functional language?
14:37:44 <ocharles> edwardk: hmm, you're posts aren't yet quite in the accessible domain for me :) but I will add them to the reading list!
14:37:51 <ocharles> actually, those are already on the list
14:37:54 <ocharles> roll on free time...
14:38:01 <byorgey> ocharles: did you look at Conor McBride's paper "Kleisli Arrows of Outrageous Fortune"?
14:38:07 <ocharles> byorgey: I haven't heard of that one
14:38:13 <edwardk> byorgey: did you get a chance to look at them yet?
14:38:20 * ocharles hunts that one down
14:38:31 <byorgey> ocharles: that's where we got IFunctor from; although I don't know if it really counts as "accessible" =)
14:38:40 <ocharles> hehe
14:38:43 <byorgey> edwardk: yeah! great stuff.
14:38:56 <byorgey> SpaceAviator: yeah, you'll get used to it =)
14:39:19 <edwardk> https://github.com/ekmett/constraints/blob/master/Data/Constraint/Forall.hs is something i have yet to write up
14:39:31 <dibblego> copumpkin: thanks for the giggles :)
14:39:47 <edwardk> but lets me build constraints like (forall a. Monoid (m a)) => … m Int -> … m String
14:39:48 <Anonymous_> \quit
14:40:00 <copumpkin> dibblego: any time!
14:40:09 <mauke> Anonymous_: / is not \
14:40:31 <edwardk> byorgey: not sure how i'd do that trick polymorphically though
14:40:38 <edwardk> er kind polymorphically
14:40:42 <ion> C:\quit
14:40:44 <byorgey> edwardk: type Forall (p :: * -> Constraint) = (p A, p B)  -- why do you need both p A and p B?
14:41:05 <edwardk> byorgey: lest someone make an MPTC to sidestep me
14:41:09 <lpsmith> hmm... so I think I want to generate some code from some sgml documentation
14:41:15 <byorgey> edwardk: having quantified constraints (even if it's a hack) is super cool =)
14:41:21 <lpsmith> eyeballing it it looks awefully close to xml
14:41:29 <byorgey> edwardk: ?
14:41:30 <edwardk> class Foo a p     instance Foo a (p a)
14:41:32 <lpsmith> the one thing i see is a lot of </> ending tags
14:41:44 * lpsmith wonders of HXT will mind
14:42:00 <edwardk> under certain circumstances you can inspect the skolem variables if i'm not careful because you can match structurally on a constraint
14:42:17 <byorgey> ah
14:42:18 <edwardk> the two makes it that require serious oleggery ;)
14:42:25 <byorgey> hehe =)
14:42:29 <edwardk> er makes it so that requires
14:42:37 <c_wraith> skolem escapes are a serious issue.  Right?
14:42:40 <byorgey> "fool me once, shame on you, fool me twice, shame on me"?
14:42:59 <edwardk> if i blog this i may steal that =)
14:43:00 <byorgey> c_wraith: these are not real skolem variables
14:43:06 <byorgey> edwardk: be my guest =)
14:43:20 <c_wraith> byorgey: well.  It was more a reference to the classical golem
14:43:28 <byorgey> c_wraith: oh, hehe =)
14:43:49 <byorgey> yes, skolem does sound like some sort of creature in a fantasy roleplaying game
14:44:00 <byorgey> "You are in a dim cave with a sandy floor. There is a skolem here."
14:44:09 <edwardk> Skolems are killing everyone in the town!
14:44:13 <c_wraith> "I cast magic missile"
14:44:20 <c_wraith> that's a safe answer for all monsters, right?
14:44:32 <byorgey> "The skolem erupts in a blossom of flame."
14:44:41 <ocharles> "It's super effective."
14:44:48 <byorgey> "The skolem seems to have dropped something."
14:45:02 <XexonixXexillion> "You find 15 gold pieces"
14:45:07 <c_wraith> not a type error?
14:45:32 * edwardk 's estimation of ocharles 's age downgrades, then rebounds back upwards due to it being a reddit meme
14:45:38 <monochrom> "you find 15 type errors"
14:45:54 <ocharles> edwardk: 22 to take the fun away :P
14:45:55 <dolio> Skolems are immune to magic. Everyone knows this.
14:46:10 <edwardk> dolio: hahaha
14:46:52 <c_wraith> This is like the Knights Of The Dinner Table encounter with the deadly Pagoda.
14:46:52 <edwardk> are they? i thought no two skolems were alike =)
14:47:09 <edwardk> gives the dm a lot of power to customize them
14:47:12 <mm_freak> "You die trying to infer the undecidable skolem."
14:47:35 <mm_freak> what's a skolem anyway?
14:47:42 <ocharles> and people say functional programmers are no fun.
14:47:43 * byorgey goes back to generating semiregular tiling diagrams
14:47:53 <ocharles> my point exactly
14:47:55 <ocharles> :P
14:48:09 <edwardk> skolems have been known to cause ghc developer brains to explode, be careful.
14:48:58 <mm_freak> why can't you make anything about arrows sound professional?
14:49:00 <mauke> c_wraith: http://mauke.dyndns.org/stuff/img/lol,internet/you-have-angered-the-gazebo.jpg
14:49:07 <c_wraith> oh, it was gazebo?
14:49:09 <mm_freak> "what arrows?  like the one on the street sign?"
14:49:12 <c_wraith> In any case
14:49:13 <mauke> mm_freak: http://en.wikipedia.org/wiki/Skolem_normal_form
14:49:18 <c_wraith> It was a terrific issue
14:51:03 <aninhumer> mm_freak: you can say that about a lot of things though "pointer? you mean like the dog?"
14:51:17 <c_wraith> setters are dogs, too
14:51:38 <lpsmith> mm_freak, skolem constants are kind of like a special kind of "fresh variable" you can use to eliminate existential statements.
14:51:50 <mm_freak> aninhumer: well, not about monads, unless your peer has seen the pythagorean monad
14:52:21 <Abraxas> i probably can't explain this very well without posting several hpastes, but...suppose you have: newtype MessageParser a = MP {unMP :: String -> Either String (a,String)} and want to write a function errorMsg :: String -> MessageParser a...where do you get that a from?
14:52:31 <mm_freak> lpsmith: that doesn't really help, but then mauke's wikipedia page tells me that it's over my head anyway =)
14:52:36 * aninhumer starts a company called Mon and has really notable advertisments
14:52:53 <aninhumer> "have you seen the Mon-Ads?"
14:53:04 <lpsmith> mm_freak, have you ever studied natural deduction style propositional proofs?
14:53:09 <mm_freak> Abraxas: in general you would just leave it polymorphic
14:53:12 <mm_freak> Abraxas: for any a
14:53:23 <mm_freak> lpsmith: no
14:53:51 <Abraxas> i can write this: errorMsg msg = MP(\inp -> case inp of {""   -> Left msg; (x:xs) -> Right (x::Char, xs))
14:53:55 <Abraxas> probably wrong syntax
14:54:00 <mm_freak> aninhumer: translating anything about arrows into german makes particularly funny statements:  "Mein Pfeil funktioniert nicht!"
14:54:10 <Abraxas> just tried to put it in one line, not to mess up the chat
14:54:16 <aninhumer> Hmm, is there a list somewhere of libraries that could do with cleanup?
14:54:37 <Abraxas> that's errorMsg :: String -> MessageParser Char
14:54:50 <mm_freak> Abraxas: what should your errorMsg do?
14:55:14 <Abraxas> display an error message for a failed parse
14:55:41 <mm_freak> Abraxas: then perhaps you want a different type:  errorMsg :: String -> MessageParser a -> MessageParser a
14:55:57 <Abraxas> type is fixed
14:56:45 <mm_freak> Abraxas: the fixed type doesn't really make sense to me, because /what/ is going to fail?  errorMsg is a parser itself and is not related to other parsers
14:56:58 <mm_freak> either it is an always-failing parser:  errorMsg = Left
14:57:19 <mm_freak> uhm…
14:57:37 <mm_freak> errorMsg str = MP $ const (Left str)
14:57:47 <Abraxas> it's used for this: expect :: String -> MessageParser a -> MessageParser a     expect s p = p ||| errorMsg ("expected " ++ s ++ " here")
14:58:07 <zeiris> Does typing "foo\tbar" in GHCI put an actual tab between them, or "\\t"?
14:58:19 <edwardk> mm_freak: when i say 'forall a. p a'  -- one way to check that is to make up a completely new A that nobody has seen before and instantiate a to A and check the predicate
14:58:32 <mm_freak> Abraxas: ok, now i'm totally confused…  are you writing an arrowized parser?
14:59:07 <Abraxas> beats me, it's a prereq for something that's coming up
14:59:25 <mm_freak> Abraxas: what is (|||)?
14:59:36 <edwardk> mm_freak: or in haskell when trying to check that f :: forall a. [a] -> [a]   can be instantiated to [Int] -> Int]  you usually just do unification , finding the substitution for a ~ Int and call it a day. but when you want to do higher rank unification that doesn't work
14:59:45 <Abraxas> oh sorry, it's an OR parser combinator
15:00:07 <mm_freak> Abraxas: then errorMsg is just the always-failing parser
15:00:24 <Abraxas> that's failure = MP (\inp -> Left "")
15:01:02 <mm_freak> Abraxas: what's Left's argument?
15:01:14 <edwardk> there winds up cases where you want to check that forall a. [a] -> [a]     and forall b. [b] -> [b] are the exact same type, so make up a completely type nobody has ever seen before, and instantiate both a and b to that type, then check that they are the same
15:01:18 <mm_freak> the error message or the rest of the input?
15:01:35 <mm_freak> edwardk: thanks for explaining that, but really, i'm happy that i understand forall somewhat =)
15:01:57 <Abraxas> Left is the error
15:02:27 <edwardk> this gets even more messy once you have more than one variable being quantified, because what order do you skolemize? forall a b. a -> b  and forall c d. d -> c  should unify
15:02:40 <Abraxas> errorMsg is going to replace failure
15:02:48 <mm_freak> edwardk: i'm the living proof that you can use advanced haskell without understanding any formal logic =)
15:03:25 <mm_freak> Abraxas: then IMO errorMsg is just the always-failing parser
15:04:00 <mm_freak> Abraxas: (|||) is responsible for trying the first parser…  when it fails, it discards the error message and tries the second parser
15:04:13 <mm_freak> Abraxas: since the second parser always fails, it only functions to set a different error message
15:04:34 <Abraxas> might be
15:05:09 <mm_freak> another approach is to use errorMsg itself in a combinator fashion:  errorMsg :: String -> MessageParser a -> MessageParser a
15:05:20 <mm_freak> it then corresponds to (<?>) in, for example, parsec
15:05:28 <Abraxas> but then it should receive an Either?
15:05:31 <Abraxas> not a string
15:05:36 <mm_freak> no, why?
15:05:56 <mm_freak> the parser that always fails:  MP (const (Left "my error message"))
15:06:00 <Abraxas> the first parser fails and produces an Either that is given to errorMsg
15:06:16 <mm_freak> you don't need to do that
15:06:28 <mm_freak> your logic is encoded in (|||), not in errorMsg
15:07:02 <mm_freak> MP f ||| MP g = MP $ \inp -> case f inp of Left _ -> g inp; Right x -> Right x
15:08:23 <Abraxas> never thought about that, i'll try
15:08:35 <Abraxas> puzzled me how to get the freaking char parsed with that type def
15:09:36 <Abraxas> yes, that was the def for ||| =)
15:09:53 <mm_freak> Abraxas: makes sense
15:14:16 <Abraxas> well, i could be doing something wrong, but it's not doing what it's supposed to
15:15:28 <Abraxas> *** Exception: invalid input   instead of  *** Exception: expected at least one further symbol here   with
15:15:42 <Abraxas> test7 = parse (p3 :: MessageParser (String,String)) "abcdef"
15:15:50 <Abraxas> p3 = liftP (,) (many1 lower) (expect "at least one further symbol" (many1 lower))
15:17:04 <Abraxas> calling test7
15:18:13 <hpaste> Abraxas pasted “ParserLike” at http://hpaste.org/53825
15:19:59 <Abraxas> p3 "abcdef"
15:20:02 <Abraxas> oops
15:24:40 <int80_h> what's the best way to re-install everything from scratch? I've entered into dependency hell
15:29:50 <monochrom> erase a directory under .ghc
15:30:30 <jhance> int80_h: Use a good linux distro.
15:30:42 <zomg> format C:
15:30:44 <zomg> ;>
15:30:56 <Mitsu> lolz
15:31:06 <jhance> Whats a C:
15:31:08 <jhance> :P
15:31:41 <zomg> I wonder if there are actually people who understand computers but don't know of format
15:32:06 <zomg> I mean there can be knowledgeable programmers etc. who haven't used linux
15:32:06 <companion_cube> jhance: "C:" are like burritos
15:32:29 <companion_cube> you can put a lot of things inside, but it's hard to extract them intact afterwards
15:32:33 <jhance> zomg: I don't know of format
15:32:33 <monochrom> Turing understood computers but didn't know of format
15:32:35 <c_wraith> ...  what?  "Unacceptable argument type in foreign declaration: CInt"
15:32:43 <c_wraith> I'm...  confused
15:32:53 <monochrom> yes a recent GHC hiccup
15:33:02 <zomg> jhance: interesting =) Never used windows much?
15:33:02 <jhance> c_wraith: Err? Yeah that is confusing
15:33:03 <c_wraith> oh, right, I'm building with head
15:33:12 <c_wraith> I should use a released version of ghc
15:33:15 <c_wraith> that would probably do better
15:33:26 <monochrom> no, not recent hiccup. a long time hiccup that gets a recent half-fix
15:33:40 <c_wraith> ...  I should be using 7.2 anyway, not 7.3
15:34:28 <jhance> zomg: No I stay away from Window's Command Line when I use it. I am only knowledgable of Linux's unix shell not that dos-like thing that runs really slow
15:34:31 <mm_freak> int80_h: rm -rf ~/.ghc;  mv ~/.cabal/world ~/.cabal/world~
15:34:37 <mm_freak> cat ~/.cabal/world~
15:34:38 <int80_h> is "let foo = "bar" :: ByteString" the right way to make a ByteString from a String?
15:34:40 <mm_freak> install what you need
15:34:55 <int80_h> mm_freak: I was able to dodge that bullet. Whew.
15:35:00 <jhance> int80_h: If you have -XOverloadedStrings
15:35:01 <zomg> jhance: I see, consider yourself lucky then I guess :D
15:35:12 <mm_freak> int80_h: i do that on a regular basis…  about every week
15:35:21 <mm_freak> so i wouldn't call that "dodging" =)
15:35:22 <mike-burns> How do I get a Hackage username? I see on the Web site that I should email some dude, so I did last night (EST), but I still don't have a username. What's next?
15:35:32 <jhance> int80_h: The other way is to use Data.ByteString.Char8 but if you are using [Char] to make a ByteString you are doing it wrong. Consider using Data.Text because Data.ByteString.Char8 does not support Unicode
15:35:39 <mm_freak> mike-burns: be patient
15:35:49 <int80_h> mm_freak: no I mean I was able to re-install a package from the source directory and that fixed things.
15:35:55 <jhance> mike-burns: Odd, I got mine within 2 minutes
15:35:55 <stepcut> mike-burns: trying sending money via paypal?
15:36:21 <mm_freak> mike-burns: if you don't get an answer for two days, ask again
15:36:27 <Abraxas> mm_freak: thanks for trying to help me with this =)
15:36:41 * mike-burns continues to wait.
15:36:48 <int80_h> the Mail type wants a ByteString though
15:36:55 <mm_freak> Abraxas: sure, you're welcome
15:37:01 <jhance> int80_h: Then use Data.ByteString.Char8.pack I guess
15:37:07 <jhance> int80_h: Or -XOverloadedStrings
15:37:08 <int80_h> ah!
15:37:33 <dmwit> Don't use pack.
15:37:40 <dmwit> ?hackage encoding
15:37:40 <lambdabot> http://hackage.haskell.org/package/encoding
15:37:48 <int80_h> how do I set OverloadedStrings in ghci?
15:37:51 <Abraxas> but i don't even get how yours turns out to be type correct
15:37:57 <Abraxas> :t (\msg -> const (Left msg))
15:37:58 <lambdabot> forall a b b1. a -> b1 -> Either a b
15:37:58 <jhance> oh interesting
15:38:05 <jhance> int80_h: ghci -XOverloadedStrings
15:38:05 <byorgey> int80_h: :set -XOverloadedStrings
15:38:32 <int80_h> dmwit: I should use encoding then?
15:38:37 <dmwit> yes
15:38:40 <Abraxas> i don't even know what my question is
15:38:44 <jhance> dmwit: does the Mail type not expect a Char8-based ByteString?
15:38:52 <dmwit> Future you will hate today you if you don't.
15:38:59 <Abraxas> what happens to the second argument of const, i guess
15:39:09 <dmwit> jhance: Assuming the Mail type is for storing email, the encoding of the body of the email is specified by the email's headers.
15:39:27 <dmwit> jhance: Hard to say more without looking at the specific library that int80_h is trying to use, though.
15:39:32 <int80_h> dmwit: It is not clear at all how to make a ByteString using encoding
15:39:36 <Abraxas> is const partially applied, i don't see how
15:39:53 <int80_h> I'm using Network.Mail.Mime
15:39:59 <byorgey> Abraxas: yes, it is partially applied
15:40:08 <dmwit> int80_h: encodeLazyByteString :: Encoding enc => enc -> String -> ByteString
15:40:23 <byorgey> Abraxas: const x  is a function which takes one argument, ignores it, and returns x
15:40:24 <dmwit> int80_h: or encodeStrictByteString, of course.
15:41:04 <dmwit> http://hackage.haskell.org/packages/archive/encoding/0.6.6/doc/html/Data-Encoding.html#v:encodeLazyByteString
15:41:21 <int80_h> dmwit: Could you get me to the docs specifically for that function? I don't know what an enc is, for example
15:41:27 <PiRSquared17> @pl \x -> \y -> \z -> x z (y z)
15:41:27 <lambdabot> ap
15:41:37 <int80_h> encodeLazyByteString I mean
15:41:37 <jhance> int80_h: an Enc is something like Utf8
15:41:44 <dmwit> int80_h: Scroll up a bit in the link I sent for a list of Encoding instances.
15:41:51 <PiRSquared17> @pl \x -> x ap const
15:41:52 <lambdabot> flip ($ ap) const
15:41:54 <Abraxas> it's obvious that it should be like this, but i can't write "const 3", why does it work here
15:41:55 <dmwit> int80_h: e.g. UTF8 :: UTF8, and instance Encoding UTF8
15:42:20 <dmwit> int80_h: So "encodeLazyByteString UTF8 :: String -> ByteString"
15:42:28 <jhance> int80_h: encodeLazyByteString Utf8
15:42:31 <int80_h> It expects Char8 I believe. I don't know really
15:42:33 <kamgoo> WWW.KAMGOO.COM Free Webchat with pictures, games, chat rooms, profiles. Meet people from around the world. WWW.KAMGOO.COM
15:42:33 <byorgey> Abraxas: what do you mean, you can't write 'const 3'?
15:42:34 <dmwit> jhance: more caps
15:42:36 <PiRSquared17> @eval iota = \x -> x ap const
15:42:41 <byorgey> @type const 3
15:42:42 <lambdabot> forall t b. (Num t) => b -> t
15:42:51 <jhance> dmwit: Sorry, never used this library, I always use Text
15:42:56 <PiRSquared17> @type iota
15:42:56 <lambdabot> Not in scope: `iota'
15:42:57 <dmwit> int80_h: ByteString.Char8 exports the same type as ByteString, only the functions have different types.
15:43:06 <jhance> int80_h: Your other option would be to use Data.Text and use encodeUtf8 :: Text -> ByteSTring
15:43:16 <Peaker> @where ops
15:43:16 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:43:20 <PiRSquared17> @pl (\x -> x ap const)(\x -> x ap const)
15:43:20 <lambdabot> id
15:43:27 <int80_h> I guess if the constructor wants a ByteString, that's all I ned to know
15:43:27 <dibblego> sup?
15:43:30 <Abraxas> in ghci i mean
15:43:39 <Peaker> dibblego: kamgoo above spams & leaves, maybe ban?
15:43:40 <byorgey> Abraxas: if you write 'const 3' by itself at the ghci prompt you will get an error, but that's because it's a function
15:43:47 --- mode: ChanServ set +o dibblego
15:43:49 <monochrom> the spammer has left. I wonder if it's useful to ban anything for now
15:43:55 <byorgey> Abraxas: there is no Show instance for functions
15:43:55 <jhance> int80_h: So you would use: T.encodeUtf8 . T.pack :: String -> ByteString. I think it would be subject to fusion too
15:44:01 <dibblego> if it happens again
15:44:22 <monochrom> > const 3
15:44:23 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
15:44:23 <lambdabot>    arising from a use of `...
15:44:24 <dmwit> jhance: Going to UTF-8 via UTF-16 seems like a weird thing to do.
15:44:31 <monochrom> works just as badly here
15:45:00 <PiRSquared17> @type u
15:45:01 <lambdabot> Expr
15:45:05 <Abraxas> ok, it's delayed to the show of the other function
15:45:10 <PiRSquared17> @eval u
15:45:14 <jhance> dmwit: Yes, that's true. However utf16 with Text encoding has TERRIBLE performance so if you want to use Text on the other end...
15:45:26 <PiRSquared17> @type
15:45:27 <lambdabot> <no location info>: not an expression: `'
15:45:28 <monochrom> nothing interesting to be printed about functions anyway
15:45:30 <PiRSquared17> @type U
15:45:31 <lambdabot> Not in scope: data constructor `U'
15:45:57 <dmwit> jhance: Can you finish that sentence? I don't really know what point you're trying to make yet.
15:45:57 <PiRSquared17> @type uU
15:45:58 <lambdabot> Not in scope: `uU'
15:46:15 <PiRSquared17> @pl z
15:46:16 <lambdabot> z
15:46:18 <PiRSquared17> @pl z
15:46:18 <lambdabot> z
15:46:40 <PiRSquared17> @pl z (z (z z)) where z = (\x -> x ap const)
15:46:41 <lambdabot> (line 1, column 21):
15:46:41 <lambdabot> unexpected "="
15:46:41 <lambdabot> expecting variable, "(", operator or end of input
15:47:36 <jhance> dmwit: I'm just saying if you are encoding to a bytestring, you probably want to decode that bytestring at some point in time, right? So going via text isn't that bad of a route if you are going to decode it for consistency to Text. I'm just saying that Text isn't entirely out of the picture
15:47:38 <PiRSquared17> @pl (\x -> x ap const)((\x -> x ap const)((\x -> x ap const)(\x -> x ap const)))
15:47:38 <lambdabot> const
15:47:53 <PiRSquared17> !! iotas -> K
15:47:57 <Abraxas> makes it hard to check the types for the particular function, but i won't explain that, too many outside definitions :D
15:48:02 <jhance> dmwit: The problem is Text has terrible performance for decoding/encoding anything except Utf8
15:48:32 <jhance> dmwit: Bryan said he only applied some optimization to Ut8 that he didn't bother with for the others because Utf8 is alot more used. Its an order of magnitude faster
15:48:39 <monochrom> you can find types with :type. try :type const 3
15:49:07 <Abraxas> sorry, that's not what i meant
15:49:16 <monochrom> aw
15:49:33 <Abraxas> it was about this
15:49:34 <Abraxas> :t (\msg -> MP(const (Left msg)))
15:49:35 <lambdabot> Not in scope: data constructor `MP'
15:49:39 <Abraxas> won't work
15:49:59 <monochrom> doesn't work in your ghci with your modules loaded?
15:49:59 <Abraxas> but this should be of type String -> MessageParser a
15:50:12 <Abraxas> yes it works, but obv not here, i mean =)
15:50:30 <monochrom> cool, so it works, case closed?
15:50:45 <hpaste> amtal pasted “Data discarding parser combinator” at http://hpaste.org/53826
15:50:46 <Abraxas> checked types for the components, but never got how it came up with that type
15:50:50 <Abraxas> cause i don't get const :D
15:50:58 <PiRSquared17> const x y = x
15:51:01 <Abraxas> let's consider it closed :D
15:51:02 <PiRSquared17> easy!
15:51:19 <amtal> What am I doing wrong with this parser? http://hpaste.org/53826#line15
15:51:23 <Abraxas> haha yes
15:51:37 <monochrom> if I knew the type of MP, I could show you
15:52:04 <monochrom> but const :: x -> y -> x  if it helps
15:52:13 <Abraxas> alright
15:52:16 <Abraxas> newtype MessageParser a = MP {unMP :: String -> Either String (a,String)}
15:52:29 <Abraxas> well ok, not that much, i guess
15:52:42 <PiRSquared17> const is just K from SK combinator calc.
15:53:01 <PiRSquared17> *+lazy evaluation where that applies
15:53:01 <monochrom> ok, at the beginning, I don't know the type of msg, but let's call it X, and solve for X soon. msg :: X
15:53:24 <Abraxas> yeah, i know, but i guess i don't understand how the partial evaluation of const can be used, pir
15:53:27 <monochrom> so Left msg :: Either X Y. I don't know Y, waiting to be solved, too
15:53:39 <Abraxas> msg:String
15:54:23 <monochrom> const :: A -> B -> A  with A,B again unknowns to be solved
15:54:24 <Abraxas> Left is the error
15:54:36 <PiRSquared17> Just wondering, what do you (haskell programmers) think of Standard ML?
15:54:43 <Abraxas> sorry, i said before i didn't want to pot the entire example =)
15:54:48 <Abraxas> *post
15:54:56 <Abraxas> i know how confusing that gets
15:55:22 <monochrom> ah, but I have to get const (Left msg) to make sense. this forces A = Either X Y.
15:55:43 <Nimatek> PiRSquared17: Andrew Ng is great at teaching and the course is structured pretty well.
15:55:44 <monochrom> alright, at this stage, const (Left msg) :: B -> Either X Y
15:56:08 <monochrom> perhaps you just needed to be told "A -> B -> A" is the same as "A -> (B -> A)"
15:56:58 <hpaste> coolface pasted “trolololo” at http://hpaste.org/53827
15:56:59 <monochrom> next I have MP :: String -> Either String (a,String)
15:58:14 <monochrom> no, sorry, MP :: (String -> Either String (a,String)) -> MessageParser a
15:58:45 <Abraxas> :t (\msg -> const (Left msg))
15:58:45 <lambdabot> forall a b b1. a -> b1 -> Either a b
15:58:57 <Abraxas> :t (\msg -> Left msg)
15:58:58 <lambdabot> forall a b. a -> Either a b
15:59:08 <monochrom> but ah, I'm doing MP(const (Left msg)). in order for that to make sense, we are forced String -> Either String (a,String) = B -> Either X Y
15:59:24 <monochrom> so B=String, X=String, Y=(a,String)
15:59:26 <Abraxas> if Either is (a->b), i see it, i guess
16:00:03 <Abraxas> but Either is a constructor
16:00:09 <Abraxas> that's nonsense
16:00:18 <jerry> is there way to simulate while loop in haskell
16:00:58 <PiRSquared17> recursion
16:01:36 <tsuraan> so haskell98 and base both provide prelude now, which is making things break (namely, ConfigFile).  What do I need to do to hide one of the exposed Preludes?
16:01:37 <jessopher> :t while
16:01:38 <lambdabot> Not in scope: `while'
16:01:40 <jhance> jerry: Recursion is the answer to any looping
16:01:55 <dylukes> i just set default-language: haskell2010
16:01:55 <jhance> jerry: Whether it is implicit or explicit
16:01:58 <PiRSquared17> And foldl or map may fit your need'
16:01:59 <monochrom> so we have solved everything. msg::String, Left msg :: Either String (a,String), const (Left msg) :: String -> Either String (a,String), MP(const (Left msg)) :: MessageParser a
16:02:02 <dylukes> and add base 4.4.0.0 to my required packages
16:02:03 <c_wraith> tsuraan: you can't, if you're using cabal, without changing whatever package depends on both
16:02:08 <Abraxas> the MP-wrapping somehow turns the a->b1->Either.. into String->Either
16:02:12 <PiRSquared17> @type map
16:02:12 <jerry> jhance: yeah i was hoping it can be done without it):....ah well:)
16:02:12 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:02:13 <jhance> Try to avoid recursion if you can fold' or map or filter
16:02:19 <jessopher> while :: Bool -> IO a -> IO ()
16:02:21 <PiRSquared17> @type mapM_
16:02:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:02:23 <jhance> jerry: What are you doing in this "while loop"
16:02:31 <monochrom> and so (\msg -> MP(const (Left msg))) :: String -> MessageParser a
16:02:38 <jerry> while (something is true) do this
16:02:38 <tsuraan> c_wraith: is there some global mask I can do to prevent haskell98-2 from ever being installed?
16:02:42 <monochrom> have you been reading?
16:02:50 <jessopher> or IO Bool maybe
16:02:55 <PiRSquared17> jerry: /what/ is true?
16:03:06 <monochrom> but no matter, I have to go now. you can continue pretending I said nothing
16:03:11 <Mitsu> @type mamM_ print [1..2]
16:03:12 <lambdabot> Not in scope: `mamM_'
16:03:14 <Mitsu> oops
16:03:14 <jhance> jerry: But what are you doing in that
16:03:18 <Abraxas> i am trying =)
16:03:20 <Mitsu> @type mamP_ print [1..2]
16:03:20 <lambdabot> Not in scope: `mamP_'
16:03:23 <Abraxas> sorry
16:03:27 <Mitsu> lol typos..
16:03:30 <jessopher> haha
16:03:30 <Mitsu> \shrugs\
16:03:41 <jerry> jhance: while (soe function returns true)
16:03:56 <Mitsu> I don't even know how lambdabot works anyway let alone haskell so why I'm trying that idk :3
16:04:00 <jhance> jerry: But what STUFF are you doing INSIDE THE LOOP
16:04:02 <PiRSquared17> function of whay, jeery?
16:04:07 <PiRSquared17> *what
16:04:09 <dlmalloc> Can anyone tell me why "import Data.List" give me the error "<no location info>: module `List' is a package module" ? :m List works fine in ghci.
16:04:13 <mm_freak> Mitsu: mapM_?
16:04:22 <jerry> jhance: i will keep executing function as many time as condition is true
16:04:31 <jessopher> jerry, the problem with that, is that a haskell expression that returns true will always return true
16:04:32 <jhance> jerry: The function will always return True
16:04:35 <Abraxas> :t (\msg -> const (Left msg))
16:04:36 <lambdabot> forall a b b1. a -> b1 -> Either a b
16:04:45 <jhance> unless it is monadic
16:04:46 <jerry> so i weill get result of function  then i will check if true...then i will feed result back to the function
16:04:46 <Mitsu> mm_freak yes lol, I just kept typing it incorrectly that's all
16:04:49 <Abraxas> what is they syntax to say msg::String
16:04:53 <Nimatek> jerry: You can execute actions, not functions.
16:05:04 <mauke> Abraxas: msg::String
16:05:11 <jhance> jerry: Could you give us code in another language and we could help you translate to well-written haskell?
16:05:15 <jerry> Nimatek: cant function return True or False
16:05:16 <Abraxas> i mean in the :t up there
16:05:23 <jerry> jhance: give me sec
16:05:25 <jhance> Nimatek: Functions are pure
16:05:48 <mm_freak> Nimatek: you can't execute actions, you can only combine them
16:05:53 <Nimatek> mm_freak: :)
16:06:02 <mauke> :t (\msg -> const (Left (msg::String)))
16:06:03 <lambdabot> forall b b1. String -> b1 -> Either String b
16:06:03 <Abraxas> i angered monochrom =(
16:06:41 <Abraxas> ok i only tried to put it in the lambda...
16:06:44 <PiRSquared17> @type fix . const
16:06:45 <lambdabot> forall a. a -> a
16:06:55 <PiRSquared17> @pl fix . const
16:06:55 <lambdabot> id
16:07:35 <Abraxas> that's how it used to be, right? says, "no longer supported"
16:07:51 <jessopher> while boolComp comp = do { cond <- boolComp; if cond then do { comp; while boolComp comp } else return () } i think this is probably close to what you want jerry
16:08:01 <Abraxas> someone told me you can use a flag to have it work the old way
16:08:29 <shachaf> jerry: What are you trying to do?
16:08:48 <jerry> shachaf: well i have function1 that can return boolean
16:08:50 <Abraxas> why is it b and b1 in there?
16:08:54 <PiRSquared17> foldl/r/' might work
16:08:59 <Abraxas> instead of a and b
16:09:21 <shachaf> jerry: And what are you trying to do?
16:09:22 <jerry> so i say while (function1 == True){ keep executing function2}
16:09:36 <shachaf> A function is never equal to a boolean.
16:09:38 <Mitsu> > mapM_ print [1..2]
16:09:38 <lambdabot>   <IO ()>
16:09:49 <Mitsu> mapM_ print [1..2]
16:09:53 <Mitsu> ._.
16:09:57 * Mitsu stares at jhance
16:10:08 <PiRSquared17> @pl \x -> x*x
16:10:08 <lambdabot> join (*)
16:10:09 <jessopher> but that isnt conditional, it always prints 1 and 2
16:10:10 <jerry> well i am new to haskell and i wrote few function...as far as i know function can have some return type right?
16:10:19 <jerry> so it can return True or False....can it not?
16:10:30 <jhance> no IO in the lambdabot tsk tsk
16:10:46 <shachaf> jerry: A function can return True or False when applied to an argument. But if you say "f == True", that means that f is a boolean, not a function.
16:10:56 <jerry> shachaf: yes of course
16:10:59 <PiRSquared17> > map (join (*)) [0,1,..16]
16:10:59 <lambdabot>   <no location info>: parse error on input `..'
16:11:00 <jerry> i meant something like this
16:11:03 <PiRSquared17> > map (join (*)) [0,1,...16]
16:11:04 <lambdabot>   A section must be enclosed in parentheses thus: (... 16)Not in scope: `...'
16:11:06 <Pseudonym> > mapM_ (:[]) [1..2]
16:11:07 <lambdabot>   [()]
16:11:11 <jerry> function1 :: Arg1->Arg2->Bool
16:11:23 <mm_freak> PiRSquared17: [0, 1 ... 16]
16:11:29 <shachaf> jerry: What are you actually trying to do?
16:11:30 <mm_freak> you've got one comma too much
16:11:43 <PiRSquared17> > map (join (*)) [0, 1...16]
16:11:43 <Pseudonym> mm_freak: You've not one . too much.
16:11:44 <lambdabot>   Not in scope: `...'
16:11:48 <Pseudonym> > [0,1..16]
16:11:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
16:11:50 <Cale> jerry: also, you should never actually have to write x == True, because that's the same thing as x
16:11:55 <mm_freak> Pseudonym: lol true
16:12:02 <jerry> shachaf: i have function1 that have result type True or False
16:12:04 <shachaf> Cale: There is of course that.
16:12:12 <PiRSquared17> > map (join (*)) [0..16]
16:12:13 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256]
16:12:18 <mm_freak> PiRSquared17: btw, [0,1 .. 16] = [0..16]
16:12:24 <PiRSquared17> I know
16:12:33 <shachaf> jerry: You've said that before. Where is this function being defined? What's its type? What are you trying to do that involves using such a function?
16:12:34 <jerry> so i want to do this while (function1 result is equal to true){keep doing something }
16:12:34 <mm_freak> at least usually
16:12:44 <PiRSquared17> I just forgot the .. syntax a little
16:12:51 <Cale> jerry: What do you mean by "doing something"?
16:12:59 <jhance> jerry: Function result is always true or always false
16:13:01 <Cale> jerry: why would the function's result change?
16:13:06 <shapr> wheee
16:13:09 <mauke> jerry: as long as you call a function with the same arguments, it will return the same result
16:13:19 <Abraxas> ok sorry to monochrom, i was reading, but could not follow, need to go now, thanks!
16:13:24 <jerry> Cale: doing something == execute function....take result of that function and feed it back to that function
16:13:27 <PiRSquared17> jerry: the predicate is a -> Bool.  What is a?
16:13:30 <Abraxas> or
16:13:39 <Nimatek> jerry: Replace the function1 and something with a precise description of your specific problem, please.
16:13:40 <Cale> okay, so you want a list of the iterates of a function
16:13:43 <PiRSquared17> @type const True
16:13:44 <lambdabot> forall b. b -> Bool
16:13:47 <Abraxas> monochrom: sorry! will read later, tyvm!
16:13:49 <mm_freak> jerry: in haskell a function is a function in the mathematical sense…  it's not a procedure/action
16:13:53 <Cale> > iterate (*2) 1
16:13:54 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:14:05 <Pseudonym> Cale: Actually, I can think of one situation where you might want to say x == True.
16:14:17 <jerry> Cale: something like that..i am not worry about that part...that i can do....i just want to figure out the way to keep doing it until something is true
16:14:17 <Pseudonym> It might avoid defaulting on x.
16:14:18 <mauke> Pseudonym: can you replace it by x :: Bool?
16:14:23 <Pseudonym> mauke: Yes, probably.
16:14:23 <Cale> Pseudonym: a type signature would do in that case ;)
16:14:26 <jessopher> it sounds like we are all the rainman, explaining something to our older brother
16:14:28 <shachaf> Pseudonym: That's why we need :: sections. :-)
16:14:40 <PiRSquared17> > filter (=0) [-10..10]
16:14:40 <lambdabot>   <no location info>: parse error on input `='
16:14:42 <Cale> jerry: takeWhile
16:14:45 <PiRSquared17> > filter (==0) [-10..10]
16:14:45 <lambdabot>   [0]
16:14:49 <Nimatek> jerry: The difference when coming from imperative programming is that you might not need to 'do something until true' in fact.
16:14:53 <Pseudonym> :t read . (==True) . show
16:14:54 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Bool'
16:14:54 <lambdabot>     In the first argument of `(.)', namely `(== True)'
16:14:54 <lambdabot>     In the second argument of `(.)', namely `(== True) . show'
16:14:57 <Nimatek> jerry: Unless you're actually doing IO.
16:14:57 <Cale> > takeWhile (< 10000) (iterate (*2) 1)
16:14:58 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192]
16:15:02 <jerry> Nimatek: no Io
16:15:05 <Pseudonym> :t (==True) . read . show
16:15:06 <lambdabot> forall a. (Show a) => a -> Bool
16:15:10 <shachaf> jerry: Haskell isn't really about doing things.
16:15:10 <Pseudonym> :t (==True) . read . show . (==True)
16:15:11 <lambdabot> Bool -> Bool
16:15:12 <Pseudonym> Or something.
16:15:29 <jessopher> they dont call it lazy for nothin
16:15:33 <Nimatek> jerry: Then you don't need that while(x) do y structure.
16:15:41 <Pseudonym> Especially since that pipe could also be replaced by id (modulo bottom).
16:15:46 <mm_freak> jerry: you don't write loops in haskell in the same sense as in most other programming languages…  haskell is a pure language
16:15:51 <Cale> You write lists
16:15:52 <jerry> Nimatek: what do i need?
16:16:06 <Cale> Lists should be your first replacement for loops :)
16:16:08 <Pseudonym> Or other structural recursion patterns.
16:16:16 <shachaf> > let loop infinite = infinite loop; infinite loop = loop infinite in infinite loop
16:16:17 <lambdabot>   Occurs check: cannot construct the infinite type:
16:16:17 <lambdabot>    t = (t -> t1) -> t1Occ...
16:16:22 <shachaf> Bah.
16:16:22 <Nimatek> jerry: You need to tell us the problem precisely, so we can give you a feel how to go about it in haskell by providing an example solution
16:16:32 <jhance> jerry: What resource are you using to learn?
16:16:41 <shachaf> jerry: In other words: What are you actually trying to do? :-)
16:16:44 <mm_freak> jerry: you need an idea of the fundamental difference between haskell and other languages…  i suggest reading one of the online books
16:16:45 <PiRSquared17> > filter (const False) [0,1..]
16:16:48 <jerry> real world haskell
16:16:49 <lambdabot>   mueval-core: Time limit exceeded
16:16:52 <Cale> jerry: Did you see my example with takeWhile?
16:16:57 <Pseudonym> jerry: Iteration in Haskell is done by recursion, but you often don't have to write the recursion explicitly.
16:17:02 <Pseudonym> Under the covers it's recursion.
16:17:04 <jerry> Cale:doing it right now
16:17:06 <PiRSquared17> > filter (const False) [0,1..]
16:17:10 <lambdabot>   mueval-core: Time limit exceeded
16:17:18 <PiRSquared17> > filter (const True) [0,1..]
16:17:19 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:17:24 <jhance> jerry: Did you skip chapters of RWH because you thought you knew what you were doing?
16:17:43 <jerry> jhance: some of them yes :)
16:17:48 <jhance> jerry: Read them ;)
16:17:59 <ptrf> pardon me for a possible stupid question, but assume I have type myState = State Int and some function forward that just advances to the next int, returning (). how do I call that forward n times before doing s <- get to get the new?
16:18:23 <mauke> replicateM_ n forward
16:18:23 <mm_freak> ptrf: replicateM_
16:18:32 <ptrf> <3
16:18:43 <PiRSquared17> > let f x = 0 in f 8
16:18:44 <lambdabot>   0
16:18:54 <shachaf> replicateM_ is such a nicer name than silly ones like "times".
16:18:57 <Cale> ptrf: Of course, you can't actually name a type myState, because it doesn't start with an uppercase letter ;)
16:19:04 <smns> where's stderr defined?
16:19:08 <PiRSquared17> @type iterate
16:19:08 <lambdabot> forall a. (a -> a) -> a -> [a]
16:19:09 <smns> ah, IO
16:19:12 <Cale> smns: System.IO
16:19:26 <mm_freak> shachaf: i'm sensing irony
16:19:33 <shachaf> GHC.IO.Handle.FD
16:19:43 <shachaf> mm_freak: Maybe a small amount.
16:20:08 <mm_freak> shachaf: replicateM 3 "01"
16:20:11 <PiRSquared17> Iterated function notation builtin?
16:20:14 <shachaf> I can see the reasoning and/or etymology behind replicateM_, but...
16:20:27 <jophish> Yo yo yo!
16:20:32 <mm_freak> shachaf: i you could have "times" restricted to IO
16:20:35 <PiRSquared17> i.e., f^n x = f(f(f(...x))) <- n fs
16:20:39 -shachaf(~shachaf@204.109.63.130)-  ["000","001","010","011","100","101","110","111"]
16:20:39 <jophish> Is there anywhere where I can find a definition of take?
16:20:39 <mm_freak> but in general i think replicateM is fine
16:20:55 <shachaf> Er. That was just my automatic bot reflexes.
16:20:56 <Pseudonym> ptrf: This is a useful job for mapM_.
16:20:57 <mm_freak> PiRSquared17: iterate
16:20:58 <jessopher> times :: IO [Time]
16:20:59 <Pseudonym> :t mapM_
16:21:00 <Cale> jophish: In the Report's specification
16:21:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:21:09 <PiRSquared17> @type iterate
16:21:09 <lambdabot> forall a. (a -> a) -> a -> [a]
16:21:11 <Pseudonym> mapM_ (const advance) [1..n]
16:21:11 <Cale> http://haskell.org/onlinereport/standard-prelude.html
16:21:16 <Nimatek> @src take
16:21:16 <lambdabot> take n _      | n <= 0 =  []
16:21:16 <lambdabot> take _ []              =  []
16:21:17 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:21:20 <ptrf> Cale: i know. it was a quick made up example :)
16:21:28 <Pseudonym> If advance :: State Int ()
16:21:29 <mm_freak> > iterate (*2) 1
16:21:30 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:21:36 <Pseudonym> However.
16:21:36 <mm_freak> > iterate f x
16:21:36 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
16:21:38 <ptrf> Pseudonym: yes, indeed. actually, I'm going with mapM_ instead
16:21:40 <Cale> http://haskell.org/onlinereport/standard-prelude.html#$vtake
16:21:52 <PiRSquared17> mm_freak: finite iteration?
16:21:53 <ptrf> i didnt know that Control.Monad had all those nice functions
16:22:00 <mm_freak> PiRSquared17: infinite
16:22:02 <shachaf> Just wait until you see Control.Monad.Loops
16:22:03 <ptrf> as in I didn't see them
16:22:07 <PiRSquared17> mm_freak:
16:22:07 <Pseudonym> State does provide an operator for arbitrarily modifying the state.
16:22:11 <mm_freak> PiRSquared17: use takeWhile/take for finite iteration
16:22:18 <jophish> thanks Cale!
16:22:20 <int80_h> where can I find the cabal-dev subdirectory?
16:22:24 <Pseudonym> @hoogle (a -> b) -> State a c -> State b c
16:22:25 <lambdabot> Control.Monad.Trans.State.Lazy withState :: (s -> s) -> State s a -> State s a
16:22:25 <lambdabot> Control.Monad.Trans.State.Strict withState :: (s -> s) -> State s a -> State s a
16:22:25 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
16:22:30 <PiRSquared17> so take n (iterate ...)
16:22:44 <Pseudonym> Hrm.
16:22:48 <Cale> jophish: Those implementations aren't quite the same as the real ones, but they're equivalent.
16:22:53 <Pseudonym> That works, but it's not quite what you want.
16:23:02 <Pseudonym> @hoogle (a -> a) -> State a ()
16:23:02 <lambdabot> Control.Monad.Trans.State.Lazy withState :: (s -> s) -> State s a -> State s a
16:23:02 <lambdabot> Control.Monad.Trans.State.Strict withState :: (s -> s) -> State s a -> State s a
16:23:02 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
16:23:11 <jophish> Cale: I'm trying to prove things in haskell, these should probably be fine?
16:23:17 <Cale> jophish: Yeah
16:23:20 <mm_freak> > takeWhile (not . null) . map (take 3) . iterate (drop 3) $ [1..20]
16:23:21 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
16:23:23 <mm_freak> @ PiRSquared17
16:23:27 <jophish> or might these not be great for that, they may be optimised in strange ways
16:23:39 <Pseudonym> :t modify
16:23:40 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
16:23:42 <Pseudonym> That's it.
16:23:45 <Cale> jophish: These are specifications and are written for clarity rather than performance.
16:23:48 <Pseudonym> modify (+n)
16:23:50 <Pseudonym> That'll do the trick.
16:23:57 <jophish> ah alright
16:23:59 <Cale> jophish: The real implementations use a bunch of low-level trickery
16:24:00 <Pseudonym> :t \n -> modify (+n)
16:24:01 <lambdabot> forall a (m :: * -> *). (Num a, MonadState a m) => a -> m ()
16:24:05 <jophish> that's just what I want!
16:24:06 <jophish> thanks
16:24:17 <PiRSquared17> > foldr (+) 0 (take 10 (iterate (/2) 2))
16:24:18 <lambdabot>   3.99609375
16:24:22 <PiRSquared17> > foldr (+) 0 (take 10 (iterate (/2) 1))
16:24:23 <lambdabot>   1.998046875
16:24:27 <PiRSquared17> > foldr (+) 0 (take 100 (iterate (/2) 1))
16:24:28 <lambdabot>   2.0
16:24:39 <PiRSquared17> > foldr (+) 0 ((iterate (/2) 1))
16:24:40 <lambdabot>   *Exception: stack overflow
16:25:09 <PiRSquared17> > foldr (*) 1 ((iterate (/2) 1))
16:25:10 <lambdabot>   *Exception: stack overflow
16:25:14 <PiRSquared17> > foldr (*) 1 (take 100 (iterate (/2) 1))
16:25:15 <lambdabot>   0.0
16:25:43 <Cale> (*) is strict in both its arguments
16:25:48 <Pseudonym> > foldl (+) 0 ((iterate (/2) 1)
16:25:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:25:55 <Pseudonym> > foldl (+) 0 ((iterate (/2) 1))
16:25:55 <PiRSquared17> > foldr (+) 0 ((iterate (/2) 1))
16:26:00 <lambdabot>   mueval-core: Time limit exceeded
16:26:00 <lambdabot>   mueval: ExitFailure 1
16:26:00 <lambdabot>  mueval-core: Time limit exceeded
16:26:06 <Pseudonym> lambdabot contention!
16:26:06 <PiRSquared17> > foldr (+) 0 (take 100 (iterate (/2) 1))
16:26:10 <lambdabot>   2.0
16:26:11 <Cale> (as is (+))
16:26:33 <monochrom> (&&) and (||) are more worthy for your experiments
16:26:45 <monochrom> > foldr (&&) False (repeat True)
16:26:49 <lambdabot>   mueval-core: Time limit exceeded
16:27:07 <monochrom> I erred
16:27:12 <monochrom> > foldr (&&) False (repeat False)
16:27:13 <lambdabot>   False
16:27:25 <PiRSquared17> @type (^)
16:27:26 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
16:27:27 <PiRSquared17> @type (**)
16:27:28 <lambdabot> forall a. (Floating a) => a -> a -> a
16:27:31 <Cale> > sum [1/n^2 | n <- [1..1000]]
16:27:31 <lambdabot>   1.6439345666815615
16:27:38 <Cale> > pi^2/6
16:27:40 <lambdabot>   1.6449340668482264
16:28:22 <Pseudonym> > map fromRational $ scanl (+) 0 [ 1 % n^2 | n <- [1..1000] ]
16:28:23 <lambdabot>   [0.0,1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.49...
16:28:25 <shachaf> > (compare `on` (take 4 . show)) (sum [1/n^2 | n <- [1..1000]]) (pi^2/6)
16:28:27 <lambdabot>   EQ
16:28:30 <Pseudonym> > map fromRational $ scanl (+) 0 [ 1 % n^2 | n <- [1..] ]
16:28:30 <lambdabot>   [0.0,1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.49...
16:28:42 <Pseudonym> > map fromRational . drop 1000 $ scanl (+) 0 [ 1 % n^2 | n <- [1..] ]
16:28:44 <lambdabot>   [1.64393456668156,1.6439355646845557,1.643936560696524,1.6439375547234163,1...
16:29:28 <Pseudonym> Unfortunately, summing from left to right gives numerical inaccuracy.
16:30:56 --- mode: dibblego set -o dibblego
16:31:37 <PiRSquared17> sum (map (\x -> 1/(x^2)) [1..100])
16:31:52 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..100])
16:31:53 <lambdabot>   1.6349839001848923
16:32:05 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..500])
16:32:06 <lambdabot>   1.642936065514894
16:32:12 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..900])
16:32:13 <lambdabot>   1.6438235727924435
16:32:18 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..1000])
16:32:19 <lambdabot>   1.6439345666815615
16:32:22 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..10000])
16:32:23 <lambdabot>   1.6448340718480652
16:32:29 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..100000])
16:32:30 <lambdabot>   1.6449240668982423
16:32:36 <PiRSquared17> > sum (map (\x -> 1/(x^2)) [1..10000000])
16:33:03 <PiRSquared17> ...
16:33:18 <lambdabot>   thread killed
16:33:27 <PiRSquared17> > sum (map (\x -> 1/(x^3)) [1..1000])
16:33:30 <lambdabot>   mueval-core: Time limit exceeded
16:33:35 <PiRSquared17> > sum (map (\x -> 1/(x^3)) [1..100])
16:33:37 <lambdabot>   1.2020074006596781
16:33:49 <PiRSquared17> Apéry's constant
16:34:00 <PiRSquared17> > sum (map (\x -> 1/(x^4)) [1..100])
16:34:01 <lambdabot>   1.0823229053444727
16:35:48 <ion> It works in private, too.
16:37:07 <Pseudonym> > let f = zipWith (\x y -> (x+y)/2) =<< tail in map ((*4).fromRational.head) . iterate f $ scanl (+) 0 [ (-1)^n % (2*n+1) | n <- [0..] ]
16:37:08 <lambdabot>   [0.0,2.0,2.6666666666666665,2.933333333333333,3.0476190476190474,3.09841269...
16:37:19 <slack1256> parsec 3 example are missing. anybody here has a good example code of parsec 3?
16:37:23 <Pseudonym> > let f = zipWith (\x y -> (x+y)/2) =<< tail in map ((*4).fromRational.(!!10)) . iterate f $ scanl (+) 0 [ (-1)^n % (2*n+1) | n <- [0..] ]
16:37:24 <lambdabot>   [3.0418396189294024,3.1370777141674973,3.1412185009169797,3.141549763856938...
16:37:29 <slack1256> something as a vcalendar file or anything?
16:38:33 <Pseudonym> > iterate (\x -> x - sin x) 3
16:38:34 <lambdabot>   [3.0,2.8588799919401326,2.5799183451281067,2.0473143260077302,1.15871686812...
16:38:42 <Pseudonym> > iterate (\x -> x + sin x) 3
16:38:43 <lambdabot>   [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.141592653589...
16:38:44 <Pseudonym> That's it.
16:38:55 <Pseudonym> All hail HAKMEM.
16:38:58 <PiRSquared17> > (:+ 1 0)
16:38:59 <lambdabot>   Overlapping instances for GHC.Show.Show
16:38:59 <lambdabot>                              (a -> ...
16:39:13 <PiRSquared17> > (1 :+ 0)
16:39:14 <lambdabot>   1.0 :+ 0.0
16:40:02 <PiRSquared17> > (iterate (\x -> x^2 + (1 :+ 0)) 0) !! 10
16:40:03 <lambdabot>   3.7918623102659254e90 :+ 0.0
16:40:12 <PiRSquared17> > (iterate (\x -> x^2 + (0 :+ 1)) 0) !! 10
16:40:12 <lambdabot>   (-1.0) :+ 1.0
16:40:16 <PiRSquared17> > (iterate (\x -> x^2 + (0 :+ 1)) 0) !! 100
16:40:18 <lambdabot>   (-1.0) :+ 1.0
16:41:09 <PiRSquared17> > (iterate (\x -> x^2 + (-0.75 :+ 0)) 0) !! 1000
16:41:10 <lambdabot>   Precedence parsing error
16:41:10 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
16:41:25 <PiRSquared17> > (iterate (\x -> x^2 + ((-0.75) :+ 0)) 0) !! 1000
16:41:26 <lambdabot>   (-0.4775238977180735) :+ 0.0
16:41:35 <incluye> > map (\x -> (1 + 1/x)**x) [0,10..]
16:41:35 <lambdabot>   [1.0,2.5937424601000023,2.653297705144422,2.6743187758703026,2.685063838389...
16:41:51 <hpaste> qwrji0j0qiwejioijqwe pasted “eqw[opq” at http://hpaste.org/53829
16:42:08 <PiRSquared17> > map (const 0) [0..]
16:42:09 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:42:13 <Cale> lol tabs
16:42:47 <hpaste> Cale annotated “eqw[opq” with “eqw[opq (annotation)” at http://hpaste.org/53829#a53830
16:42:56 <incluye> > (const.const) <$> [3] <*> [4] <*> [5]
16:42:57 <lambdabot>   [3]
16:43:00 <monochrom> hpaste is the endorsed way to find out what your code really looks like
16:43:14 <monochrom> do not trust your editor
16:43:29 <hpaste> qwrji0j0qiwejioijqwe pasted “eqw[opq” at http://hpaste.org/53832
16:43:37 <hpaste> qwrji0j0qiwejioijqwe pasted “eqw[opq” at http://hpaste.org/53833
16:44:31 <Cale> At least this qwrji0j0qiwejioijqwe person is very consistent about his name.
16:44:37 <KitB> Sorry about him
16:44:40 <KitB> Fresher
16:44:49 <KitB> Doesn't realise it's posting to a channel
16:44:59 <PiRSquared17> > map (\k->sum (map (\x -> 1/(x^k)) [1..100])) [0..]
16:45:00 <lambdabot>   [100.0,5.187377517639621,1.6349839001848923,1.2020074006596781,1.0823229053...
16:45:50 <slack1256> how do i know which are the most used libraries in hackage?
16:45:58 <PiRSquared17> > map (sum . flip map [1..100] . ((1 /) .) . flip (^)) [0..]
16:45:59 <lambdabot>   [100.0,5.187377517639621,1.6349839001848923,1.2020074006596781,1.0823229053...
16:45:59 <slack1256> there is some funcionality i'm missing?
16:47:06 <Cale> slack1256: Don Stewart put together some stats on that a while back
16:47:13 <qwrji0j0qiwejioi> aww
16:47:41 <Cale> I'm not sure where they've gone or if there's anything more recent. You can probably Google for them though.
16:47:43 <PiRSquared17> > let zeta = (sum . flip map [1..1000] . ((1 /) .) . flip (^)) in zeta 5
16:47:44 <lambdabot>   1.0369277551431222
16:48:06 <Cale> http://donsbot.wordpress.com/2010/06/30/popular-haskell-packages-q2-2010-report/
16:48:45 <elliott> i think there are a lot more than 2182 packages nowadays
16:48:50 <monochrom> "base remains the most unpopular package ever"
16:49:54 <PiRSquared17> > let zeta = (sum . flip map [1..1000] . ((1 /) .) . flip (^)) in zeta -2
16:49:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a1)
16:49:55 <lambdabot>    arising from a use of ...
16:49:59 <PiRSquared17> > let zeta = (sum . flip map [1..1000] . ((1 /) .) . flip (^)) in zeta (-2)
16:50:01 <lambdabot>   *Exception: Negative exponent
16:50:21 <PiRSquared17> negative exponent looks like it would be valid
16:50:28 <PiRSquared17> > let zeta = (sum . flip map [1..1000] . ((1 /) .) . flip (**)) in zeta (-2)
16:50:30 <lambdabot>   3.338335e8
16:51:31 <slack1256> Cale: but as a blogpost or directly in hackage?
16:51:40 <Cale> slack1256: as a blog post
16:53:21 <slack1256> Cale: thank i will look at it right now.
16:53:34 <Cale> slack1256: It's pretty unsurprising :P
16:54:14 <Cale> Most of those are popular basically because they're dependencies of most other things
16:54:31 <ion> > let newton = liftA2 newton' unDif deriv; newton' f df = iterateWhile (\a b -> abs (b-a) > 1e-14) (\x -> x - f x / df x); iterateWhile pred f = fix (\go x -> let x' = f x in if pred x x' then go x' else x') in newton ((1+) . cos) 3 :: Double
16:54:33 <lambdabot>   3.14159265109478
16:54:52 <djanatyn> Is the title of LYAH a haskell joke?
16:55:07 <djanatyn> Like, is there some hidden deeper meaning, or is it just silly?
16:55:19 <Cale> djanatyn: no, just lolcatty
16:56:05 <djanatyn> ah, okay.
16:58:56 <yitz> > (!! 10) . scanl1 (+) . map (recip . fromIntegral) $ scanl (*) 1 [1..]
16:58:58 <lambdabot>   2.7182818011463845
16:59:32 <Itkovian> Anybody an idea if there's any DPH implementation out there that uses the Cell's SPEs?
17:00:12 <smns> ion, that approximation becomes imprecise at the 9th decimal digit.
17:00:13 <Itkovian> There was Warp Speed Haskell, using a GPU
17:01:45 <byorgey> I think of the title of LYAH as being more AllYourBase-y than lolcatty
17:05:19 <Cale> byorgey: That's true, it is.
17:06:26 <byorgey> maybe there should be a sequel named "I lerned U a Haskul... but I eated it"
17:11:39 <monochrom> my lolcat ate my haskell
17:12:07 <ion> lolskell
17:12:57 <monochrom> curryosity kills the haskell. sheafification brings it back. or something.
17:15:04 <sjindel> Is an uninstall feature in the pipeline for cabal?
17:15:22 <shachaf> sjindel: Not really, as far as I know.
17:15:40 <sjindel> shachaf: Is there not much demand for it?
17:15:50 <shachaf> There are complications.
17:16:00 <sjindel> What complications other than file tracking?
17:16:18 <shachaf> I don't recall exactly. Ask dcoutts or someone who knows what they're talking about.
17:16:28 <mizu_no_oto> import qualified Data.ByteString as B
17:16:57 <mizu_no_oto> instances = map (filter (not . isStopword)) . B.words . (B.splitAt ",") $ text
17:17:00 <shachaf> import qualifier B for Data.ByteString
17:17:17 <mizu_no_oto> For some reason, GHC is complaining that B.words isn't in scope
17:17:26 <shachaf> mizu_no_oto: That's because it's not.
17:17:38 <shachaf> "words" is a thing you do on text, not on a collection of bytes.
17:17:54 <shachaf> If you want to treat a collection of bytes as ASCII text, you can use Data.ByteString.Char8.
17:18:02 <shachaf> But are you sure you don't want Data.Text?
17:18:10 <mizu_no_oto> >_<
17:18:12 <ian_mi> sequence of bytes, really
17:18:43 <shachaf> Ordered collection.
17:19:25 <monochrom> @hoogle words
17:19:27 <lambdabot> Prelude words :: String -> [String]
17:19:27 <lambdabot> Data.List words :: String -> [String]
17:19:27 <lambdabot> Data.String words :: String -> [String]
17:19:41 <monochrom> ah, wouldn't have helped
17:20:05 <shachaf> @hoogle+
17:20:05 <lambdabot> Data.ByteString.Char8 words :: ByteString -> [ByteString]
17:20:06 <lambdabot> Data.ByteString.Lazy.Char8 words :: ByteString -> [ByteString]
17:20:06 <lambdabot> Data.Text words :: Text -> [Text]
17:20:13 <shachaf> Or would it?
17:20:16 <monochrom> oh!
17:20:22 <mizu_no_oto> Perhaps I do want data.text.  Essentially, I need to do the apriori algorithm to find frequent associations of words in a big paragraph
17:20:55 <ian_mi> surely bytestrings are well-ordered
17:21:09 <monochrom> every set is well-ordered
17:21:21 <ian_mi> not by every order
17:21:33 <ddarius> monochrom: I don't agree.
17:22:08 <ian_mi> it's called the axiom of choice because it's optional
17:22:56 <mizu_no_oto> What would be the difference in using Data.ByteString.Char8 vs Data.Text?
17:22:58 <shachaf> @quote to.other.axioms
17:22:58 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
17:23:11 <shachaf> "The axiom gets its name not because mathematicians prefer it to other axioms."
17:23:29 <shachaf> mizu_no_oto: One is for strings of bytes, the other is for strings of characters.
17:23:36 <shachaf> Characters are not necessarily ASCII.
17:23:47 <jophish_> Yo!
17:23:50 <ddarius> monochrom: I'm willing to accept your axiom of choice in exchange for denying the axiom of infinity.
17:24:00 <byorgey> hi jophish_
17:24:06 <jophish_> Is there any better way of passing arguments to a list comprehension than this: (\xs acc -> [ x:y | x <- xs, y <- acc ] )
17:24:15 <jophish_> hi byorgey
17:24:37 <mizu_no_oto> So does Data.ByteString.Char8 assume ascii?
17:24:46 <ian_mi> liftM2 (:) xs acc
17:24:48 <shachaf> @ty (\xs acc -> [ x:y | x <- xs, y <- acc ] )
17:24:49 <lambdabot> forall t. [t] -> [[t]] -> [[t]]
17:24:54 <shachaf> Yes, what ian_mi said.
17:24:55 <elliott> mizu_no_oto: ByteStrings contain octets (Word8s, unsigned 8-bit integers).
17:25:02 <elliott> mizu_no_oto: Char8 just lets you treat these as ASCII strings.
17:25:08 <byorgey> noooo use liftA2!!
17:25:10 <elliott> If you want Unicode -- which you do -- you want Data.Text.
17:25:21 <elliott> You can easily decode ByteStrings containing, e.g. UTF-8 data, into Texts.
17:25:32 <shachaf> If you want speed -- which you don't -- you want Data.ByteString.
17:25:34 <mizu_no_oto> Thanks, Conal
17:25:42 * shachaf FUD
17:25:47 <elliott> I'm not conal :-P
17:25:55 * elliott must be /such/ a disappointment.
17:25:58 <shachaf> conal is Conal.
17:26:03 <mizu_no_oto> Ah
17:26:05 <shachaf> Only perl can parse Perl.
17:26:10 <jophish_> ian_mi: ah, that looks great, but for this particular sheet, we've been instructed to use a list comprehension
17:26:11 <ian_mi> byorgey: not until Applicative is a superclass of Monad!
17:26:12 <mizu_no_oto> So there's a lot of us about, then
17:26:14 <elliott> One day I'll be Conal. One day.
17:26:18 <mizu_no_oto> ^_^
17:26:32 <shachaf> elliott: Does that happen to all elliotts as they grow older and more advanced?
17:26:36 <mizu_no_oto> I'm also an Elliot
17:26:42 <mizu_no_oto> I think so, yeah
17:26:42 <elliott> shachaf: Yes.
17:26:44 <elliott> But not Elliots.
17:26:48 <mizu_no_oto> Damn
17:26:48 <elliott> Only Elliotts.
17:26:48 <ion> [ x | x <- liftA2 (:) xs acc ]
17:26:53 <conal> byorgey: thx for the help deprecating liftM2 etc
17:26:54 <mizu_no_oto> :(
17:27:06 <byorgey> conal: you're welcome =)
17:27:11 <jophish_> ion: hahahahaha
17:27:32 <ian_mi> I don't like having to switch syntax when I move to arbitrary Monads
17:27:47 <conal> byorgey: btw, i gave a glowing recommendation of your Typeclassopedia to the budding Haskellers at work today.
17:27:50 <ddarius> ian_mi: So don't.
17:27:53 <byorgey> ian_mi: arbitrary Monads should also be Applicative.
17:28:01 <dylukes> Is there actually a constructor for Int in the GHC libs anywhere?
17:28:05 <dylukes> i.e data Int = Int Int#
17:28:08 <byorgey> conal: thanks =D
17:28:12 <shachaf> byorgey: Right, but you have to write a constraint.
17:28:13 <dylukes> or something similar? I want to rebox a value.
17:28:15 <shachaf> @src Int
17:28:15 <lambdabot> data Int = I# Int#
17:28:19 <jophish_> I can't see lift anywhere in the standard prelude
17:28:20 <conal> byorgey: and quickly reread most of it in the process. great stuff!
17:28:21 <byorgey> shachaf: for now.
17:28:28 <dylukes>     Not in scope: data constructor `I#'
17:28:30 <dylukes> Where is it?
17:28:34 <dylukes> GHC.Prim doesn't seem to have it.
17:28:34 <shachaf> byorgey: Right. That's why ian_mi said that, presumably.
17:28:56 <elliott> GHC.Num.
17:28:57 <elliott> IIRC.
17:29:02 <ddarius> :i I#
17:29:03 <dylukes> GHC.Exts has it.
17:29:04 <dylukes> :\
17:29:05 <ion> Yeah, Typeclassopedia is great.
17:29:09 <dylukes> Agreed.
17:29:13 <elliott> dylukes: You shouldn't import GHC.Prim anyway.
17:29:16 <elliott> You're meant to import GHC.Exts.
17:29:20 <dylukes> mmk
17:29:30 <shachaf> GHC.Types
17:29:36 <shachaf> But, yes, GHC.Exts is probably better.
17:29:44 <shachaf> Wait, maybe not.
17:29:58 <elliott> I think GHC.Exts is the only "guaranteed" interface.
17:30:06 <elliott> For the things it exports.
17:30:16 <byorgey> thanks all.  due to your encouragement I think I am going to get off my butt and actually work on the 2nd edition this week
17:30:18 <shachaf> dylukes: What are you doing reboxing values anyway?
17:30:49 <shachaf> byorgey++
17:30:50 <dylukes> shachaf: Oh I'm just looking at how it looks.
17:31:01 <dylukes> :P
17:31:18 <ion> byorgey: Yay
17:31:21 <conal> byorgey: i like this bit from the intro: "There are two keys to an expert Haskell hacker’s wisdom: 1. Understand the types. 2. Gain a deep intuition for each type class and its relationship to other type classes, backed up by familiarity with many examples." right on!
17:32:42 <dylukes> On another note, this is how my STG currently looks syntactically.
17:32:43 <dylukes> https://gist.github.com/1353830
17:32:44 <dylukes> Any thoughts?
17:32:52 <conal> byorgey: that familiarity is what led me to the whole "denotational design with type class morphisms" trip. which is now central to my design process.
17:33:17 <dylukes> excuse my lisp style indenting.
17:34:03 <byorgey> conal: yeah... I guess deep familiarity often leads in unexpected directions. =)
17:35:52 <conal> byorgey: indeed. it (semantic TCM) started out as code poetry. purely for aesthetics.
17:38:00 <dgpratt> ["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", >>
17:38:02 <dgpratt>     shachaf │ dylukes: What are you doing reboxing values   │@ChanServ
17:38:04 <dgpratt>             │ anyway?                                       │@Igloo
17:38:06 <dgpratt>     shachaf │ byorgey++                                     │ [mth]
17:38:08 <dgpratt>     dylukes │ shachaf: Oh I'm just looking at how it looks. │ [mth]_
17:38:10 <dgpratt>     dylukes │ :P                                            │ _1amzave
17:38:12 <dgpratt>         ion │ byorgey: Yay                                  │ __class__
17:38:14 <dgpratt>       conal │ byorgey: i like this bit from the intro:      │ __main__
17:38:15 <ddarius> Someone kick dgpratt
17:38:16 <dgpratt>             │ "There are two keys to an expert Haskell      │ __yhvh__
17:38:16 <dylukes> Oh look it's this again.
17:38:18 <dgpratt>             │ hacker’s wisdom: 1. Understand the types. 2.  │ _habnabit
17:38:20 <dgpratt>             │ Gain a deep intuition for each type class and │ _jesse_
17:38:22 <dgpratt>             │ its relationship to other type classes,       │ _kit_
17:38:24 <dgpratt>             │ backed up by familiarity with many examples." │ _mpu
17:38:26 <dgpratt>             │ right on!                                     │ _Vi
17:38:27 <shachaf> @where ops
17:38:27 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
17:38:28 <dgpratt>         ◀▬▬ │ jsgf_ (~jeremy@173-13-150-22-sfba.hfc.comcast │ `0660
17:38:30 <dgpratt>             │ business.net) has quit (Ping timeout: 252     │ a11235
17:38:32 <dgpratt>             │ seconds)                                      │ A1kmm
17:38:34 <dgpratt>         ▬▬▶ │ neliel__ (~Sar@bny93-1-87-91-56-204.dsl.sta.a │ aartamonau
17:38:36 <dgpratt>             │ bo.bbox.fr) has joined #haskell               │ aavogt
17:38:36 --- mode: ChanServ set +o dibblego
17:38:38 <dgpratt>         ◀▬▬ │ bytbox (~s@129.2.129.226) has quit (Quit:     │ abbe
17:38:39 --- kick: dgpratt was kicked by dibblego (dgpratt)
17:38:45 * conal always forgets how to op.
17:38:52 <dylukes> dibblego: *salutes*
17:38:55 <shachaf> dibblego++
17:38:56 --- mode: ChanServ set +o shapr
17:39:00 <Isthan> Can I not define a list of floats this way?
17:39:02 <Isthan> alt = [100.0, 1000.0, 10000.0] :: Float
17:39:06 <shapr> dibblego: beat me to it
17:39:08 --- mode: dibblego set -o dibblego
17:39:12 <ddarius> shapr's ban hammer has grown rusty.
17:39:17 <shapr> Clearly that was an accidental mispaste.
17:39:24 <ddarius> shapr: Indeed.\\
17:39:25 <shachaf> Isthan: No. The type of a list of Floats is [Float]
17:39:53 <dylukes> hngh
17:40:08 <dylukes> GHC's dumped stg's eta reduction is getting bothersome :P
17:40:09 <Isthan> so I would write alt = [...] : [Float]
17:40:10 <Isthan> ?
17:40:10 <dented42> @pl \x -> [1..x]
17:40:10 <lambdabot> enumFromTo 1
17:40:11 <byorgey> Isthan: the listt itself is fine
17:40:19 <byorgey> Isthan: right
17:40:26 <Isthan> er ::
17:40:33 <Isthan> thanks.
17:40:40 <dylukes> data MyInt = MI# Int# becomes Test.MI# = \r [eta_B1] Test.MI# [eta_B1];
17:40:52 <dylukes> the eta transformations are a bit confuddling.
17:40:56 <dented42> @pl \x -> foldl (*) 1 [2..x]
17:40:56 <lambdabot> foldl (*) 1 . enumFromTo 2
17:40:56 <dgpratt> massive apologies for the flood
17:41:17 <dibblego> dgpratt: np, be careful :)
17:41:23 <shachaf> dgpratt: I hope the massive apologies fit on one line, despite their size. :-)
17:41:40 <dgpratt> shachaf: lol
17:41:55 <dylukes> So, if type constructors are just reentrant (non-updatable) functions,
17:42:08 <dgpratt> not too familiar with this IRC client (obviously)
17:42:10 <dylukes> how are they distinguished in code generation?
17:42:19 <dylukes> (i.e, for pattern matching)
17:42:44 <ddarius> dylukes: Write a pattern match and see.
17:42:51 <dylukes> :D
17:42:54 <dylukes> touche
17:43:18 <ddarius> That said, a one constructor type doesn't really need to do anything special.
17:43:38 <Mitsu> wait did I just see someone get deopped of a kb? o.o
17:44:04 <ddarius> Mitsu: No.
17:44:17 <dylukes> hm, nullary ones like Nil get
17:44:20 <dylukes> Test.Nil = NO_CCS Test.Nil! [];
17:44:28 <dylukes> Why the exclamation mark on Nil :\
17:44:51 <shachaf> Exclamation marks show you that GHC is talkin' business.
17:44:57 <elliott> dylukes: it's a strict nil!
17:45:04 <dylukes> egads.
17:45:11 <dylukes> Oh.
17:45:17 <shachaf> It's a potent nil.
17:45:19 <elliott> (Maybe that actually means "strict in all arguments", which is vacuously true here.)
17:45:19 <dylukes> GHC is inserting the error calls statically :0
17:45:22 <elliott> (Just guessing.)
17:45:22 <dylukes> That makes a lot more sense.
17:45:46 <dylukes> https://gist.github.com/1353830
17:46:15 <dylukes> I have no idea what the wild_sdf there is :<
17:46:40 <copumpkin> suddenly, a wild sdf appears
17:46:50 <dylukes> This might be a bit #-blah
17:47:06 <dylukes> As shachaf so ardently pointed out, STG is not haskell.
17:47:22 <shachaf> #-blah isn't just the channel for "everything that isn't Haskell", you know.
17:47:41 <shachaf> Anyway that looks like a Haskell-related question to me.
17:48:05 <hpaste> gregounoob annotated “eqw[opq” with “Y U NO WORK  (annotation)” at http://hpaste.org/53829#a53838
17:51:35 <smns> with LaTeX'es listings, it's kind of random what gets highlighted. what do people use?
17:51:35 <mizu_no_oto> Is there anything like Data.Set that counts the number of times you try to put a specific item into it?
17:52:02 <mizu_no_oto> that is to say, every time you put, say, "a" into it it increments the count for "a"
17:52:16 <smns> mizu_no_oto, sounds like you want a MultiSet.
17:52:33 <conal> mizu_no_oto: Data.Map with the right insertWith call
17:52:47 <conal> mizu_no_oto: i.e., a simple wrapper around Data.Map
17:53:02 <mizu_no_oto> Thanks a lot!
17:53:03 <ddarius> Set = a -> Bool, Bag = a -> Natural
17:53:13 <ddarius> @hackage multiset
17:53:13 <lambdabot> http://hackage.haskell.org/package/multiset
17:53:27 <shachaf> Map = a -> b
17:53:38 <shachaf> MultiMap = a -> Set b = a -> b -> Bool?
17:53:48 <ddarius> a -> Maybe b
17:53:56 <shachaf> So I guess that's just saying that a MultiMap is a relation.
17:54:05 <shachaf> Er, yes. I meant a total Map, of course. :-)
17:54:17 <conal> oh! the multiset package is exactly that Map wrapper.
17:55:00 <conal> Thanks, Twan!
17:56:33 <shachaf> Thanks, Twan! Thwan!
17:59:49 <Peaker> conal: hey, does TMap have a working semantic model for enumerating keys (similarly to Map.keys)?  It seems in TMap's semantic model, the Map notion of keys is ill-defined
18:00:22 <conal> Peaker: right. undefined. i haven't thought about trying to extend it.
18:00:57 <conal> Peaker: i don't know whether/where lack of keys is a problem.
18:01:23 <ddarius> For TMap "keys" would just be the domain of the mapping.
18:01:47 <ddarius> It doesn't really make all that much sense for that particular type.
18:02:48 <conal> ddarius: that's my sense also. 'keys' is the domain, and TMap is total.
18:02:49 <Peaker> Well, I guess in cases that need keys, they'd typically want something like: TMap KeyType (Maybe ValueType) in practice, and want some sort of list of domain points for which the value is a Just
18:03:05 <hpaste> Sgeo pasted “Is this a premature optimization?” at http://hpaste.org/53840
18:03:19 * Sgeo|web points to his paste and asks ?
18:03:24 * conal toodles off to dinner. later, all.
18:03:30 <Sgeo|web> Bye conal
18:03:35 <Peaker> bon apetit
18:03:46 <conal> :)
18:04:12 <copumpkin> Sgeo|web: throw criterion at it :)
18:04:19 <Sgeo|web> criterion?
18:04:51 <jhance> Sgeo|web: Its a benchmarking library
18:05:09 <jhance> Sgeo|web: It draws pretty graphs for you.
18:05:19 <Sgeo|web> In general, should I worry about the sort of thing presented?
18:05:42 <HardBoiledSoup> if you like techno you should watch this livestream http://www.justin.tv/epic_unicorn#/w/2043943904
18:06:33 <wyfrn> does anybody use xmonad in a dual head setup and the MagicFocus layout modifier?
18:08:49 <fryguybob> Sgeo|web: I don't see how those two would be different.  The `a` isn't going to be evaluated any sooner in the second one.
18:10:53 <shachaf> If you're worried about sharing the a, then possibly. I.e. let foo = f' x y in (foo u, foo v)
18:11:07 <shachaf> But it's a trade-off with other things, of course.
18:16:04 <shachaf> Sgeo|web: What's wrong with "f x y = lengthy (lengthy x y)"?
18:16:41 <Sgeo|web> shachaf: nothing, except my lack of careful thought and my desire to make the two similar
18:17:16 <Sgeo|web> shachaf: Yeah, I was thinking about sharing the a
18:17:28 <shachaf> I mean, doesn't that do the sharing that you wanted?
18:17:45 <Sgeo|web> shachaf: Yes, but does it work for f?
18:18:10 <Sgeo|web> ...I just realized that my code makes .. oh, wait, it should type
18:18:26 <Sgeo|web> Just returns a partially-applied function anyway
18:18:39 <shachaf> Anyway, yes, this is premature optimization.
18:18:50 <shachaf> First you should figure out what's going on.
18:20:12 * Sgeo|web wishes there was a language that let you be correct about space and time complexity the way Haskell lets you be correct about types
18:22:03 <Sgeo|web> I wonder if you could do something like that in a language with dependent types
18:23:13 <Sgeo|web> Are there any loops in Haskell that aren't ultimately encoded with recursion?
18:23:38 <shachaf> Depends on how broad your definition of "recursion" is.
18:23:44 <dylex> and "ultimately"
18:23:47 <shachaf> In general, no, not really.
18:24:07 <Sgeo|web> Hmm, example of when not?
18:24:18 <dylex> but "ultimately" (assembly level) most of the recursion should go away.
18:24:29 <shachaf> dylex: The assembly level isn't part of Haskell.
18:24:50 <shachaf> Well, for example, there's the IORef thing ddarius mentioned recently.
18:24:56 <Sgeo|web> I mean at the point of what library functions that don't rely on other library functions for the loop ultimately do
18:24:59 <byorgey> Sgeo|web: I have seen work on type systems that let you reason about time/space complexity.
18:25:04 <Sgeo|web> byorgey: ooh
18:25:10 <byorgey> Sgeo|web: I don't know if you could do it with just a generic dependent type system
18:25:10 <dylex> shachaf: that's fair, but would you say, e.g., a list comprehesions is recursion in "haskell"?  it still depends on the level of description.
18:25:34 <shachaf> dylex: The list type is recursive, anyway. :-)
18:25:49 <Peaker> I think there's inherent tension between simplicity of operational and simplicity of denotational semantics.. and a type system heavily depends on the simplicity of semantics
18:26:00 <Sgeo|web> byorgey: I'm curious whether such a thing would be feasible as an extension to Haskell, or if it requires a more expressive type system
18:26:19 <Sgeo|web> Well, extension to Haskell could add its own things to the type system, right?
18:26:22 <Peaker> (at least assuming you're aiming for desirable operational semantics)
18:26:29 <byorgey> Sgeo|web: I don't really know enough about it to say.
18:26:57 <byorgey> Sgeo|web: it would certainly require a more expressive type system, but yes, of course an extension to Haskell could extend the type system
18:26:58 <shachaf> Sgeo|web: It would be quite the extension.
18:27:16 <shachaf> For instance, it would require totality, of course.
18:41:30 <tlorenz> saw this cool talk on infoQ http://www.infoq.com/presentations/Running-a-Startup-on-Haskell
18:42:07 <tlorenz> made me hope that at some point haskell will be used more often at least on the server side
18:46:33 <Sgeo|web> Does cabal upgrade upgrade GHC?
18:47:24 <Sgeo|web> Ooh, does cabal init mean I don't need to learn how to write .cabal files?
18:49:32 <yitz> Sgeo|web: cabal upgrade is deprecated, don't use it
18:49:50 <Sgeo|web> o.O
18:49:56 <Sgeo|web> yitz: So what do I use instead?
18:50:29 <yitz> Sgeo|web: cabal init gives you a template cabal file, with useful comments, and some possibly correct values for some of the fields. then you edit it.
18:50:44 <Sgeo|web> The --help said it was interactive
18:50:44 <yitz> Sgeo|web: use cabal install
18:52:13 <zeiris> tlorenz: has said startup proven itself? I remember a similar set of slides from that company providing "a new way to share data on the web" or something.
18:52:27 <yitz> Sgeo|web: upgrade follows dependencies and upgrades things you don't want to upgrade.
18:52:41 <zeiris> I guess startups fail for reasons unrelated to language choice, but I still don't feel comfortable using them as a test.
18:53:26 <yitz> Sgeo|web: i think now if you run it you get a message saying "don't do this", you can only get it to work if you include an option that says "i know what i'm doing, do it anyway".
18:53:43 <tlorenz> @zeiris, well, they are in the beta phase right now, but according to the speaker their server is super fast and scales well
18:53:43 <lambdabot> Unknown command, try @list
18:54:40 <Sgeo|web> yitz: There are things I don't want to upgrade?
18:55:38 <yitz> Sgeo|web: yes. basically, the packages that come with GHC should be left alone, otherwise GHC won't work right
18:55:54 <yitz> Sgeo|web: you can install other versions of them though. so use install, not upgrade.
18:57:16 <Sgeo|web> yitz: In general, if I have a package that relies on a newer version of package P, and another package that relies on an older version of package P, can both coexist?
18:57:21 <zeiris> tlockney: yay :)
19:04:35 <Sgeo|web> cabal init is asking me questions
19:05:43 <zeiris> Don't tell it your password or personal information.
19:05:53 <zeiris> It may be a hacker or fed in disguise.
19:05:54 <Sgeo|web> lol
19:05:57 <Sgeo|web> It did ask for my name
19:07:02 <kmc> Sgeo|web, shachaf dependent types don't require totality
19:07:41 <Sgeo|web> Oh, but there's stuff in there that I still need to fill in
19:11:54 <shachaf> kmc: I didn't say they do.
19:12:36 <shachaf> kmc: I said that if a language has asymptotic runtime guarantees, then it would certainly have totality guarantees.
19:17:18 <monochrom> what would an asymptotic runtime guarantee say?
19:17:18 <kmc> ah, I missed some context
19:18:07 <monochrom> at the level of "(x+y) take O(n) time"? at the level of "all loops take O(n) time"?
19:18:27 <shachaf> I don't know.
19:19:56 <AtnNn> help purple
19:20:50 * jessopher helps purple
19:20:58 <Isthan> I have two lists [a,b,c,d] and [x,y,z,w].  I want to find if 100 lies between a and x.  Can I write a guard stating: |100.0 `elem` [a..x]   ?
19:21:30 <jessopher> sure
19:21:33 <mauke> no
19:21:36 <jessopher> no?
19:21:38 <jessopher> oh
19:21:47 <Isthan> with my example?
19:22:01 <mauke> inRange (a, x) 100
19:22:03 <mauke> maybe
19:22:25 <Isthan> > inRange (1, 200) 100
19:22:26 <lambdabot>   True
19:22:29 <Isthan> like that?
19:22:33 <monochrom> (a<=100 && 100<=x) || (x<=100 && 100<=a)
19:22:43 <AtnNn> > 100 `elem` [90.5 .. 110]
19:22:44 <lambdabot>   False
19:23:20 <Isthan> lambdabot likes the inrange suggestion
19:23:30 <Isthan> is that how  you all feel I should proceede?
19:23:36 <monochrom> not sure why you want to do 2*(x-a) comparisons when 4 would do
19:23:36 <siracusa> @src inRange
19:23:37 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:24:37 <Isthan> the reason is that I need to see whether [a,b,c,d] [x,y,z,w] crosses 100, but is then less than 1000
19:24:55 <Isthan> just trying to avoid making a predicate with like 5 logical ands
19:25:07 <Isthan> or maybe not 5 but...
19:25:10 <monochrom> 2 && and 1 ||
19:25:44 <monochrom> but even if I used 10 &&s. so you're saying 10 &&s can be saved by 100 comparions
19:26:23 <Isthan> where do you get 100 comparisons?
19:26:34 <monochrom> 2*(x-a) comparisons
19:27:07 <Isthan> well your point is valid, but performance is zero concern (its a homework with diabolical last part...)
19:27:13 <monochrom> [a..x] takes x-a comparisons. then 100 `elem` that takes another x-a comparisons
19:27:29 <Isthan> using inRange
19:27:31 <shachaf> And also won't work with Floats.
19:27:32 <Isthan> not elem
19:27:47 <monochrom> @type inRange
19:27:48 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
19:28:00 <shachaf> Isthan: Anyway, you don't have to write blah a x && blah b y && so on explicitly.
19:28:03 <monochrom> bears an unecessary assumption
19:28:19 <shachaf> Computers were invented so you wouldn't have to do that.
19:28:30 <Isthan> let me better explain the situation
19:28:50 <Sgeo|web> :t and
19:28:51 <lambdabot> [Bool] -> Bool
19:29:12 <Isthan> these lists of floats represent waypoints, and I just need to provide some logic that will determine whether a pair of waypoints crosses a "point of interest"
19:29:46 <Isthan> so if from waypoint A to waypoint B the object reaches/crosses 100 altitude, I need to perform an action
19:29:53 <Isthan> when it crosses 1000, another action
19:29:58 <Isthan> same for 10,000
19:30:19 <monochrom> still (a<=100 && 100<=x) || (x<=100 && 100<=a)
19:30:37 <Isthan> help me to understand the <= notation
19:30:45 <monochrom> less-than-or-equal to
19:30:47 <Isthan> oh nm
19:30:49 <Isthan> :)
19:30:52 <mauke> ≤
19:31:06 <Sgeo|web> between a x b = a <= x && x <= b
19:31:45 <Sgeo|web> Might be a bit silly to write that for a quick comparison like that though
19:32:10 <Isthan> between:: Float->Float->Float->Bool
19:32:11 <Isthan> ?
19:32:23 <mauke> no
19:32:27 <monochrom> also it's my pleasure to report that inRange is unavailable for Float and Double
19:32:27 <Sgeo|web> Isthan: do you know typeclasses?
19:32:38 <mauke> :t let between a x b = a <= x && x <= b in between
19:32:39 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
19:32:47 <Isthan> sgeo|web: I dont
19:33:20 <Sgeo|web> Isthan: In the syntax you see for the type, (Ord a) => means that a can be any type that supports comparisions like <= > < etc.
19:33:27 <byorgey> Float->Float->Float->Bool is a perfectly good type for that function.
19:33:33 <Sgeo|web> So, when you use it, the proper type will be filled in for a
19:33:36 <monochrom> if you're just using it for Float, sure you can call it Float for now. it is more general, but you don't have to care
19:33:36 <byorgey> just not the most general one.
19:33:39 <Isthan> right, Ord means the elements can be ordered
19:34:36 <Isthan> oh, yea I used floats as inputs because thats all my program has to deal with
19:34:49 <Sgeo|web> > let betweenOp x a b = a <= x && x <= b in 5 `betweenOp` 3 $ 7
19:34:50 <lambdabot>   True
19:35:35 <Sgeo|web> Yay, I understand the stupid trick for 3-argument operators
19:35:52 <Sgeo|web> Well, not really a trick, I guess
19:36:00 <Isthan> its just tricky :)
19:36:41 <Isthan> I still have a slight wrinkle
19:36:58 <mauke> > inRange 5 (3, 7)
19:36:58 <lambdabot>   False
19:37:18 <Sgeo|web> Hmm, that wouldn't work well with || between betweenOp calls
19:37:25 <Sgeo|web> Due to $'s precedence
19:37:36 <Isthan> I mentioned that I need to perform an action at an altitude crossing 100, then also another action when crossing altitude 1000
19:38:07 <monochrom> > inRange (3,7) 5
19:38:08 <lambdabot>   True
19:38:22 <ion> > 5 :: ((Integer, Integer), (Integer, Integer))
19:38:23 <lambdabot>   ((5,5),(5,5))
19:38:27 <ion> k
19:39:08 <monochrom> what you get for gratuitous Num instances left right and centre
19:39:42 <Sgeo|web> > (id + id) 0
19:39:42 <lambdabot>   0
19:39:46 <Sgeo|web> > (id + id) 5
19:39:47 <lambdabot>   10
19:39:59 <Sgeo|web> > (id - id) == 0
19:40:00 <lambdabot>   *Exception: (==): No overloading for function
19:40:07 <monochrom> instance Num (StateT s IO a) is coming soon
19:40:21 <lpsmith> I'm finding a large number of broken documentation links on hackage
19:40:33 <ion> Well, that instance would be trivial. :-)
19:40:49 <ion> Whoops, it didn’t have Num a => …
19:41:04 <mauke> all Applicatives can be Nums
19:41:09 <mauke> modulo modulandis
19:41:11 <monochrom> ok how about instance Num (ContT r (StateT s (ConT r' IO)) a)
19:41:53 <jmcarthur> would have to cheat on the Eq and Show stuff
19:42:13 <ion> as the present evil instances already do.
19:42:57 <Sgeo|web> Two ContTs?
19:43:18 <jmcarthur> @unmtl ContT r (StateT s (ConT r' IO)) a
19:43:18 <lambdabot> (a -> s -> ConT r' IO (r, s)) -> s -> ConT r' IO (r, s)
19:43:27 <jmcarthur> @unmtl ContT r (StateT s (ContT r' IO)) a
19:43:27 <lambdabot> (a -> s -> (r -> s -> IO r') -> IO r') -> s -> (r -> s -> IO r') -> IO r'
19:43:41 <shachaf> ConT, the transformer for the famous Con monad.
19:43:59 <Sgeo|web> LamE
19:44:00 <jmcarthur> con is a fake!
19:45:44 * Sgeo|web starts calling everyone LamE
19:46:05 <lpsmith> http://hpaste.org/53844
19:46:33 <lpsmith> I mean, if I'm finding three broken links on two unrelated packages,  surely there are more
19:46:40 <Pseudonym> http://spl.smugmug.com/Humor/Lambdacats/catt/960526154_fqpKB-O-1.jpg
19:47:05 <lpsmith> I think there might be more I've noticed,  but I'm not sure what they are.
19:50:33 <monochrom> yes there are more. strange error. not limited to recent packages. http://hackage.haskell.org/packages/archive/tagsoup/0.12.3/doc/html/Text-HTML-Download.html not found either but that's in August
19:51:34 <petekaz> Back in monad reader 13, there was a review of RWH, and there was this comment: As the book was written for GHC 6.8.3, the 'old' way of exception handling is used.  What is the 'new' way?
19:51:48 <byorgey> lpsmith: strange indeed.
19:52:03 <shachaf> petekaz: Control.Exception probably has documentation for that.
19:53:01 <byorgey> Download at least is only conditionally included in the exports which I thought might explain it, But the missing modules in hexpat are just regular exports.
19:54:29 <petekaz> okay. I just wasn't sure if, as I start my journey down the RWH book, if I should ignore everything on exception handling if it had all changed.
19:55:16 <ion> Control.Exception’s haddock documentation is rather good.
19:55:47 <monochrom> the "new" way is more flexible. you can define your own exception type. thanks to Data.Dynamic etc
19:56:04 <petekaz> I'll read that after I finish that chapter in RWH. Thank you for the pointers.
19:56:52 <monochrom> true, the main ideas of "try" "bracket" "finally" are still there
19:57:52 <petekaz> good to know. thank you.
20:00:25 <jessopher> is there some simple tool to parse haskell source and spit it back out with uniform indentation and line endings?
20:00:48 <monochrom> no
20:01:07 <jessopher> well thats a shame
20:01:21 <jessopher> is there a complicated one?
20:01:40 <monochrom> not yet, but doable because "complicated" is allowed
20:01:55 <shachaf> Yes, absolutely.
20:02:13 <parcs> what about haskell-src-exts?
20:02:17 <shachaf> However, people will probably get pretty offended if you call them that.
20:02:23 <parcs> it has a parser with a pretty printer
20:02:36 <monochrom> namely, there are approximately a hundred different meanings to "uniform indentation" and so an indentation tool must solicit user input. lots of user input
20:03:12 <monochrom> if your source code has 100 lines, the tool will have to ask up to 200 questions
20:03:20 <monochrom> I wouldn't call that a simple tool.
20:03:38 <ion> Source code file formats should be independent of rendering.
20:03:50 <ion> Layout should happen in runtime based on the properties of the display device.
20:04:01 <monochrom> tonight ion plays my advocate :)
20:05:05 <monochrom> I suppose haskell-src-exts may work, FSVO "uniform"
20:05:48 <jessopher> any version of uniform would work, other than just putting it all on one line and using curly braces
20:06:29 <shapr> monochrom: It's like sitting on a military outfit. Sometimes you get uniform indentation.
20:06:39 <byorgey> hehehe
20:06:42 <augur> whats a good notation to mean "with a partial order", "with a total order", and "with no order"?
20:06:52 <augur> (not in haskell, just in general :P)
20:07:20 <byorgey> augur: can you give more context?
20:07:22 <monochrom> on second thought, since haskell-src-exts's grammar tree stores original source locations, I doubt that its pretty-printer re-indents at all
20:07:40 <kmc> it can reindent
20:07:45 <kmc> that's how 'groom' and those other packages work
20:07:50 <shachaf> I like pretty-printing comments as empty strings.
20:08:00 <parcs> its pretty printer seems quite intricate actually
20:08:12 <kmc> jessopher, i think someone posted a stackoverflow answer a while back
20:08:19 <kmc> with a small script using haskell-src-exts to do what you want
20:08:22 <augur> byorgey: well, for example, suppose you want to talk about a type system where function types have arguments that are totally ordered (like normal), partially ordered, or unordered
20:08:23 <jessopher> i will hunt it down
20:08:42 <augur> byorgey: so you might want to indicate that you're talking about the partially-ordered system
20:08:58 <kmc> http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
20:09:01 <augur> as opposed to the normal, totally ordered one
20:09:46 <monochrom> hmm yeah haskell-src-exts will lose your laborously written comments and haddocks
20:10:07 <augur> so maybe you use T to mean the normal type system, but you subscript it with something to indicate partial ordering (just like you subscript F when talking about different versions of system F)
20:10:18 <jessopher> you are my hero kmc
20:11:06 <kmc> :)
20:11:30 <monochrom> hrm? where does it store comments?
20:12:29 <monochrom> ah, no wonder, as a separate thing in a return tuple
20:12:48 <augur> byorgey: does that make sense?
20:14:13 <jessopher> ill just write my comments as haskell expressions
20:14:28 <kmc> flip const "comment here" (2+2)
20:14:43 <byorgey> augur: oh, I see.  Well, generally speaking you often see \leq used for total orders and \sqsubseteq for partial orders
20:14:50 <byorgey> augur: so maybe you could subscript T with those?
20:15:14 <kmc> is there any way to make web links in Haddock / cabal docs, where the link text is not the url?
20:15:50 <augur> byorgey: aha!
20:15:51 <augur> ok :)
20:17:19 <byorgey> kmc: I don't think there is, sadly =(
20:17:53 <augur> byorgey: another one: suppose you have a wonky system where arguments are the "unsaturated" things, in some sense
20:18:17 <augur> that is, the "functions" just have the capacity to satisfy arguments, and arguments do the deciding about what they need to combine with
20:18:37 <augur> if T is the normal way, do you think coT is a good name for this wonky version?
20:18:48 <fragamus> is there some nice clean terse code to walk a directory tree recursively
20:19:10 <fragamus> haskell code even
20:20:17 <byorgey> augur: maybe, I don't know
20:21:50 <Sgeo|web> Does lazy-by-default really provide enough amazing benefits to outweigh difficulties in understanding space and time complexity?
20:23:26 <kmc> Sgeo|web, I think the jury is still out on that
20:23:27 <shachaf> It sure would be nice if there existed a programming language that was strict.
20:23:30 <ion> YMMV.
20:23:34 <monochrom> it's subjective
20:24:24 <kmc> Sgeo|web, many of us are of the opinion that non-strict is the better default, that optional strictness works better than optional non-strictness
20:24:38 <kmc> obviously if you ask #haskell then you get some selection bias
20:24:51 <kmc> a lot of people here also code in Scala and you can ask them about Scala's approach
20:25:09 <kmc> which is strict by default, with built-in language support for non-strict
20:25:55 <kmc> as an aside, you can't implement lazy evaluation in a strict language of pure functions without extra language support
20:26:15 <kmc> because lazy evaluation involves mutation behind the scenes
20:26:19 <shachaf> But you can implement non-strictness.
20:26:23 <kmc> sure
20:26:38 <kmc> you can implement something which is denotationally equivalent to lazy evaluation but is exponentially slower :)
20:27:06 * shachaf will use "exponentially" to mean the opposite of "denotationally" from now on.
20:27:11 <kmc> oh noes
20:27:35 <ion> detonationally
20:27:38 <Isthan> Can anyone give suggestions on how I may be able to recursively examine a [[Float]] where the [Float] lists represent waypoints?  Here is code/explaination: http://snipt.org/wqj7
20:27:52 <shachaf> Pervasive laziness is pretty nice in ways that I imagine optional laziness wouldn't be.
20:28:16 <shachaf> The way that the line between data structures and control structures becomes blurred, for instance.
20:28:19 <Sgeo|web> How do you implement strict evaluation in a lazy language of pure functions without language support? Or does seq not count as language support?
20:28:37 <kmc> the only thing special about 'seq' is that it's so polymorphic
20:29:02 <kmc> you can write seq yourself if you specialize the first type to some algebraic data type
20:29:03 <shachaf> seq will morph any poly you throw at it.
20:29:07 <kmc> seq True x = x; seq False x = x
20:29:17 <shachaf> Not for functions, though.
20:29:23 <Sgeo|web> huh
20:29:24 <kmc> right
20:29:32 <shachaf> You know, every time someone says that about seq, someone else says "not for functions".
20:29:37 <copumpkin> shachaf: apply it!
20:29:42 <shachaf> We have dialogues dozens of lines long that are entirely cached.
20:29:49 <shachaf> We should just give them numbers, like in that one joke.
20:29:50 <monochrom> detonational semantics and more: http://www.mail-archive.com/haskell-cafe@haskell.org/msg86241.html
20:30:16 <kmc> Sgeo|web, but you can't exactly implement strict eval in a non-strict language without library support
20:30:21 <kmc> er language support
20:30:39 <kmc> there's no Haskell expression e such that «let x = e in ()» will cause e to be evaluated
20:30:48 <kmc> seq or no
20:31:04 <kmc> all the added strictness in Haskell is relative:  "if you force x, also force y"
20:31:29 <shachaf> Is there no word for "if you force x, you also force y"?
20:31:37 <shachaf> An operational (almost) counterpart of strict, I mean.
20:31:50 <kmc> Sgeo|web, but conversely, the lazy thunks you can make in a strict impure language don't look the same as other values either
20:31:56 <kmc> you have to explicitly force them
20:31:59 <monochrom> perhaps "y is strict wrt x"
20:32:13 <shachaf> f x = undefined is strict wrt x
20:32:27 <Sgeo|web> kmc: It's not possible to make a language where you don't have to explicitely force lazy thunks, yet things are strict by default? That doesn't make sense to me
20:32:47 <kmc> no, you can do it
20:32:54 <kmc> scala works that way iirc
20:33:00 <kmc> i meant the ones you get without special language support
20:33:01 <ion> shachaf: You mean in joke #59?
20:33:18 <monochrom> err, it's the other way round, "if you force f x, it forces x" is "f is strict", and so "if you force x, it forces y" is "x is strict wrt y"
20:33:40 <shachaf> ion: Ha! Yes, that one.
20:33:43 <monochrom> which is unsatisfactory wording so I withdraw it
20:37:49 <Isthan> Is anyone willing to give suggestions on how I may be able to recursively examine a [[Float]] where the [Float] lists represent waypoints?  Detailed explaination: http://snipt.org/wqj7
20:41:48 <parcs> Isthan: you shouldn't be representing waypoints with [Float]
20:42:03 <parcs> use (Float, Float, Float, Float) or your own data type
20:42:49 <Isthan> I do understand that since its ordered, it should be in a touple, but unfortunately it is the input that I have
20:42:55 <monochrom> there is something about the teacher dictates so
20:43:01 <Isthan> :(
20:43:36 <monochrom> there is something about Learn You A Haskell By Dropping That Course
20:43:51 <Isthan> lol
20:44:00 <Isthan> Learn You a Haskell is a great book.
20:44:06 <Isthan> I wish BONUS was in the channel :)
20:44:28 <parcs> preflex: seen BONUS
20:44:28 <preflex>  BONUS was last seen on #haskell 193 days, 9 hours, 26 minutes and 54 seconds ago, saying: yeah i think that's better as well
20:45:00 <Isthan> that is a powerful bot indeed
20:45:07 <Sgeo|web> You could make a function that translates between them
20:45:08 <Sgeo|web> >.>
20:45:26 <Isthan> between touples and lists?
20:45:27 <shachaf> parcs: BONUS is online on another IRC network.
20:45:42 <ion> isthan: You can always convert to tuples first.
20:45:50 <parcs> why not on freenode? :(
20:45:55 <Isthan> what does that grant me, though?
20:46:08 <ion> Dunno, just skimmed the discussion.
20:46:12 <Isthan> oh :)
20:46:45 <Isthan> the problem is, if i have a waypoint A and waypoint B, I have to detect all of the interesting intersections in order, and do so recursively
20:47:33 <Isthan> presuming I can find the "nearest" point to the starting point, I would want to recurse with the nearest point and waypoint B
20:48:50 * Sgeo|web realizes he can't quite see how to do the conversion without explicit recursion >.>
20:48:55 * Sgeo|web feels lame
20:49:38 <Zamarok> I'm looking for a function that will produce all of the unique pairs of items in a list.. anyone know of somewhere I could maybe read about that?
20:50:05 <Zamarok> a simple task with for loops.. a bit more difficult in Haskell
20:50:52 <ion> > let xs = [0,1,2] in [ (a,b) | a <- xs, b <- xs, a /= b ]
20:50:53 <lambdabot>   [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
20:51:05 <ion> whoops, misread your question.
20:51:06 <Isthan> yea!
20:51:10 <Isthan> list comprehension
20:51:26 <joo> > let bum = bum in bum
20:51:30 <lambdabot>   mueval-core: Time limit exceeded
20:52:19 <Zamarok> ion: yea.. close.. half of that list lol. For my purposes, (a, b) == (b, a), so should be counted as a duplicate
20:52:34 <ion> Bbl, phone call.
20:52:45 <jessopher> let bum = rich in rich bum where rich bum = bum
20:53:31 <byorgey> > let xs = [1,2,3] in zipWith (,) xs (tails xs)
20:53:32 <lambdabot>   [(1,[1,2,3]),(2,[2,3]),(3,[3])]
20:53:54 <joo> > [(a,b) | a<-[0..2], b<-[0..a-1]]
20:53:55 <lambdabot>   [(1,0),(2,0),(2,1)]
20:54:08 <byorgey> > let xs = [1,2,3] in zipWith (map . (,)) xs (tails xs)
20:54:10 <lambdabot>   [[(1,1),(1,2),(1,3)],[(2,2),(2,3)],[(3,3)]]
20:54:25 <byorgey> > let xs = [1,2,3] in concat $ zipWith (map . (,)) xs (tails xs)
20:54:27 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
20:54:29 <byorgey> there we go
20:54:38 <byorgey> Zamarok: ^^^
20:54:49 <Zamarok> (2,2) is not a pair :P
20:54:50 <Zamarok> close
20:54:59 <byorgey> oh, you don't want self-pairings, ok
20:55:01 <dylex> > let xs = [0,1,2,3] in [ (a,b) | a <- xs, b <- xs, a > b ] -- if you can assume Ord a
20:55:02 <lambdabot>   [(1,0),(2,0),(2,1),(3,0),(3,1),(3,2)]
20:55:06 <Zamarok> unique items.. sorry, I should have specified
20:55:12 <Zamarok> unique items and unique pairs
20:55:14 <byorgey> > let xs = [1,2,3] in concat $ zipWith (map . (,)) xs (tail $ tails xs)
20:55:15 <lambdabot>   [(1,2),(1,3),(2,3)]
20:55:19 <byorgey> easy
20:55:19 <Zamarok> yes!
20:55:48 <Zamarok> thanks. I'll put it to good use
20:55:54 <byorgey> for sufficiently large values of 'easy' ;)
20:56:06 <Isthan> how does "in" work with your expression?
20:56:27 <byorgey> Isthan: let ... in ...  is special syntax
20:56:33 <Zamarok> Implementing one of Euler's formulas for "amicable pairs".. this is a small part of the proof
20:56:45 <byorgey> Isthan: the part after 'let' creates local variable bindings which can be used in the expression after 'in'
20:56:54 <byorgey> > let a = 4 in a + 3
20:56:55 <lambdabot>   7
20:57:01 <Isthan> ooooh
20:57:53 <joo> I prefer
20:57:58 * edwardk waves hello.
20:57:59 <joo> > a + 3 where a = 4
20:58:00 <lambdabot>   <no location info>: parse error on input `where'
20:58:06 <joo> ...
20:58:10 <joo> Or maybe I don't
20:58:26 <augur> is there a way to do multiple matches with a single clause
20:58:27 <augur> like
20:58:33 <byorgey> joo: 'where' only goes with declarations, not expressions
20:58:37 <augur> case x of { A, B -> foo ; C -> bar }
20:58:38 <augur> ?
20:58:39 <byorgey> hi edwardk
20:59:02 <joo> Fine, I am revealed as an idiot. That was quicker than usual.
20:59:29 <byorgey> joo: hardly. "not knowing something" /= "idiot".
20:59:36 <parcs> augur: not directly
20:59:36 <monochrom> no, you have to write A->foo and then B->foo
20:59:58 <augur> wasnt there a suggestion for a modification to haskell or ghc to allow this?
21:00:07 <joo> byorgey, but I didn't just not know something, I assumed something that I didn't have evidence for.
21:00:42 <monochrom> without checking, I think it's safe to say "yes"
21:03:09 <ion> > case x of { A foo, B bar -> foo; C baz -> baz }  -- whoops\
21:03:10 <lambdabot>   <no location info>: parse error on input `,'
21:04:13 <ion> (I don’t know why i added “>”. A reflex.)
21:13:46 <shlevy> I need to represent a 96-bit UUID as a Haskell type. Should I use String, [Word8], Integer, or something like (Word64, Word32) ?
21:14:56 <ion> At least not String, it’s not text.
21:15:10 <shlevy> Hmm, there's http://hackage.haskell.org/packages/archive/crypto-api/0.2.1/doc/html/Data-LargeWord.html
21:15:27 <shlevy> Uses my last choice
21:15:31 <parcs> shlevy: http://hackage.haskell.org/packages/archive/largeword/1.0.1/doc/html/Data-LargeWord.html
21:16:27 <shlevy> Hmm, do I use that one or the crypt oone?
21:17:04 <mauke> I'd probably use a ByteString
21:17:33 <parcs> shlevy: the 'largeword' one out of the two
21:17:54 <shlevy> mauke: ByteString isn't much better than String, is it? Conceptually that is, this is not a performance-critical app
21:17:55 <parcs> it's what the latest crypto-api uses, apparently
21:18:02 <shlevy> Ah, I see
21:18:34 <mauke> shlevy: I think it is
21:18:46 <mauke> String is a list of unicode characters
21:18:50 <ion> ByteStrings represent arbitrary octets, Strings represent text.
21:18:52 <mauke> ByteString is just a blob of data
21:19:23 <shlevy> mauke: Except I don't care about character-by-character or anything like that. All that matters is "Is this blob the same as this other blob"
21:19:34 <parcs> in that case use Integers
21:19:36 <shlevy> mauke: But I see why it's better than String
21:19:43 <ion> Wrt. the semantics ByteString is much better, but it’s still not fixed-width.
21:20:05 <shlevy> Word96 is what I want
21:20:17 <ion> Yes, that seems very fitting.
21:32:29 <GutenTag> what is the '.' (dot) operator called?  What should I google to learn more about it?  Example: sum . map(\x -> 1)
21:33:01 <byorgey> GutenTag: it is function composition
21:33:01 <mauke> google? nothing
21:33:06 <JoeyA> GutenTag: Composition
21:33:09 <byorgey> (f . g) x = f (g x)
21:33:37 <byorgey> sum . map (\x -> 1)  is the function which first maps (\x -> 1) over a list, then sums the result.
21:34:16 <edwardk> GutenTag: function composition and it is nigh ungoogleable
21:35:11 <Guest37298> i call it dot
21:35:17 <JoeyA> I was taught the f ∘ g notation in grade school, twice.  Both times, I thought it was illogical.
21:35:29 <parcs> @google haskell dot operator
21:35:30 <lambdabot> http://stackoverflow.com/questions/631284/dot-operator-in-haskell-need-more-explanation
21:35:30 <lambdabot> Title: syntax - Dot Operator in Haskell: need more explanation - Stack Overflow
21:35:31 <JoeyA> I thought we all used f(g(x)) because Isaac Newton won the calculus wars.
21:35:40 <Guest37298> but dont try to pronounce haskell code
21:35:51 * mauke is now known as modem
21:36:45 <jessopher> @src length
21:36:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:36:51 <JoeyA> I read =<< as the "plug into" operator.
21:36:55 <jessopher> @src len
21:36:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:36:59 <jessopher> oy
21:37:03 <monochrom> eff composition gee types eh function see
21:37:13 <JoeyA> writeIORef ref . (+1) =<< readIORef ref
21:37:14 <monochrom> (that's f . g :: a -> c for you)
21:37:30 <elliott> monochrom: you just sound like a confused canadian
21:37:38 <mauke> f∘g∷a→c
21:37:48 <GutenTag> thank you :)
21:37:53 <shachaf> f *grunt* g *grunt* a *grunt* c
21:37:55 <monochrom> precisely
21:38:11 <shachaf> Those are all pronounced differently, of course.
21:38:13 <JoeyA> "f of g bleh"
21:38:27 <Guest37298> f(g(
21:38:36 <JoeyA> "f of g is a function that takes a value of type a, and yields a value of type c"
21:38:38 <mauke> F RING OPERATOR G PROPORTION A RIGHTWARDS ARROW C
21:38:44 <elliott> f compose g *vomits profusely*
21:38:56 <parcs> f dot g is ok
21:39:06 <dibblego> elliott: scala
21:39:10 <elliott> ::a->c is a tricky word
21:39:15 <shachaf> "fog"
21:39:16 <Cale> f following g
21:39:17 <JoeyA> f of g is easier to say :-)
21:39:21 <JoeyA> shachaf: +1
21:39:26 <Cale> Is another option
21:39:34 <dibblego> I use (f ∘ g) from scala
21:39:36 <Guest37298> f . g
21:39:38 <Guest37298> sorted
21:39:39 <mauke> double-colon
21:39:54 <parcs> elliott: that can be inferred :
21:39:56 <parcs> P
21:39:56 <elliott> mauke: *paamayim neukodatiym
21:40:02 <elliott> or whatever it is
21:40:31 <mauke> paamayim nekudotayim
21:40:32 <shachaf> elliott: פעמיים נקודתיים
21:40:44 <tsanhwa> hi, how can I constrain bytestring length with type system, in other words, make a new type that is essentially a bytestring type, but its length is validated at compile-time by compiler
21:40:57 <elliott> shachaf: Yes. That's how you pronounce ::.
21:40:58 <Guest37298> tsanhwa: how about an array
21:41:06 <Guest37298> nvm
21:41:11 <tsanhwa> Guest37298: I want a fixed length
21:41:20 <Guest37298> well arrays have fixed length
21:41:24 <Guest37298> but its not in the type
21:41:33 <elliott> tsanhwa: can't without an array library designed for it
21:41:34 <JoeyA> tsanhwa: Find a programming language with dependent types.
21:41:45 <elliott> and those are painful to use generally
21:41:49 <elliott> sorry.
21:42:12 <tsanhwa> I remmeber there is some trick when defining new datatype
21:42:46 <elliott> you cannot do what you want without lots of type-level hackery
21:43:03 <GutenTag> Hmm.  Professor Moore once gave his opinion on the use of the word 'dot' versus 'composition' that was compelling...but I can't recall what it was.
21:43:11 <mauke> template<size_t N> data Array a = a[N]
21:43:11 <parcs> tsanhwa: yes, for length-indexed vectors
21:43:23 <ion> When i hear “f of g” i think “f g”.
21:43:31 <ion> sin of x
21:43:40 <ion> length of "o hai"
21:43:42 <parcs> it's usually said f of g of x
21:43:44 <Guest37298> "f of g of"
21:43:53 <Guest37298> f(g(
21:43:59 <mauke> foff geoff
21:44:02 <tsanhwa> parcs: is it vector package?
21:44:04 <GutenTag> or maybe it was f of g versus something else.  Hrm.
21:44:04 <shachaf> You can pronounce "f."g as "lambda x f of g of x"
21:44:11 <elliott> tsanhwa: no
21:44:11 <parcs> tsanhwa: no
21:44:20 <Guest37298> tsanhwa: no
21:44:22 <elliott> tsanhwa: you really don't want this, trust me :)
21:44:26 <elliott> i mean
21:44:29 <shachaf> "!!" is pronounced "not not"
21:44:31 <elliott> you want it
21:44:34 <shachaf> "::" is pronounced "colon colon"
21:44:40 <parcs> tsanhwa: you can't do what you want conveniently
21:44:41 <shachaf> ">>=" is pronounced "bind bind equals"
21:44:47 <elliott> but we can't offer it in the form you want
21:44:47 <jessopher> i just read it backwards and sub '.' for 'to'
21:45:09 <ion> shachaf: Paamayim nekudotayim
21:45:17 <jessopher> or have someone else do it for me
21:45:21 <tsanhwa> elliott: ok, let me think about it again :)
21:45:26 <shachaf> ion: פעמיים נקודתיים
21:45:33 <monochrom> professor monochrom once gave a compelling reason to use neither "dot" nor "composition", but some people religiously refused it. anyway, it's what mauke alluded to with the nick "modem". you are not a modem, not your job to read code aloud.
21:45:59 <mauke> Parse error: syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM
21:46:22 <jessopher> I am sure some company somewhere employs people to read code aloud
21:46:29 <shachaf> Which nick "modem"?
21:46:35 <elliott> tsanhwa: you could define a type for e.g. length 10 strings by just using a newtype over ByteString and not exposing length-changing  operations
21:46:45 <shachaf> Oh, it wasn't an actual nick change.
21:46:45 <elliott> but that probably isn't enough
21:46:49 <monochrom> * mauke is now known as modem  a while ago
21:46:59 <shachaf> mauke wouldn't lose points on idlerpg for trivialities like these.
21:47:03 <monochrom> ah, right, hehe
21:47:37 <smns> mauke, that's supposed to be a joke, right?
21:47:47 <mauke> smns: actual PHP error message
21:47:51 * monochrom forgot that he has configured nick changes to display as "α x is now known as y"
21:48:04 <smns> mauke, yes, but I think their naming convention must be deliberately humourous.
21:48:08 <mauke> no
21:48:28 <shachaf> α mauke is now known as ekuam β
21:48:32 <mauke> their error messages expose internal token names, and :: is called T_PAAMAYIM_NEKUDOTAYIM
21:48:45 <mauke> JEWS DID PHP
21:49:01 <smns> mauke, I understand. but why would you call a token that. you might as well call it POKEMON.
21:49:02 <elliott> smns: the developers of php3 decided to expose their native language in that token name. for some reason.
21:49:11 <elliott> smns: it means double-colon
21:49:16 <mauke> smns: oh, you don't speak hebrew?
21:49:21 <monochrom> what does paamayim nekudotayim mean?
21:49:23 <min> tsanhwa: doesn't oleg have a paper on static array bounds checking in haskell? there's also some discussion of length indexed vectors on the haskell mailing list.
21:49:26 <smns> is it hebrew? I thought it was indian.
21:49:28 <parcs> double colon or something
21:51:00 <ybit> anyone want to walk me through lambda calculus?
21:51:21 <shlevy> \x -> x
21:51:26 <jessopher> ha
21:51:31 <shachaf> > intercalate " /\\ " "lambda calculus"
21:51:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
21:51:32 <lambdabot>         against inferred ty...
21:51:43 <ybit> The free variables of a term are those variables not bound by a lambda abstraction. That is, the free variables of x are just x; the free variables of λx.t are the free variables of t, with x removed, and the free variables of ts are the union of the free variables of t and s.
21:52:20 <monochrom> yes, for example (\x -> y x)  y is a free variable, and that's all
21:52:21 <ybit> ts represents an application
21:52:23 <parcs> ybit: i think you just walked yourself
21:52:39 <ybit> but where are these variables?
21:52:46 <mauke> what do you mean by "where"?
21:52:55 <jessopher> in america!
21:52:57 <Sgeo|web> Is there ever a good reason to use undefined? I'm under the impression that error is preferred.
21:53:00 <monochrom> the expectation is an even outer scope has to provide y
21:53:16 <ybit> i can see that y is the free variable in \x.y
21:53:40 <ybit> i don't see any variables in the application ts
21:53:41 <monochrom> failing that, you just have to keep y around
21:53:53 <mauke> ybit: why do you have to see them?
21:54:00 <monochrom> do you see any variable in "(\x -> x) (\z -> z)"?
21:54:10 <ybit> point taken
21:54:11 <JoeyA> Sgeo|web: I've used undefined to specify a type when invoking a typeclass function.  I'll post an example.
21:54:28 <ybit> moving on, i have a few more Qs
21:55:10 <elliott> Sgeo|web: undefined is useful because people dont use Data.Tagged, like JoeyA is saying
21:55:15 <Sgeo|web> > error "I AM ANYTHING AND EVERYTHING! MUAHAHA"
21:55:15 <lambdabot>   *Exception: I AM ANYTHING AND EVERYTHING! MUAHAHA
21:55:18 <ybit> (λx.t)[x := r] = λx.t;
21:55:23 <Sgeo|web> Data.Tagged?
21:55:47 <elliott> see tagged package
21:55:54 <elliott> also Data.Proxy
21:56:26 <Sgeo|web> Is Kmett some kind of god?
21:56:30 <ybit> that statement says that you substitute r for the free variable x in of t, how does that equal λx.t
21:56:37 <Sgeo|web> It's just I've seen that name before
21:56:38 <ybit> also how would you say λx.t in english?
21:56:49 <monochrom> no free variable x in λx.t
21:57:02 <elliott> Sgeo|web: yeah edwardk is actually god
21:57:11 <elliott> you blew his cover, grats
21:57:13 <elliott> :P
21:57:13 <ybit> sorry, i said the wrong thing
21:57:20 <ybit> t is the free variable here
21:57:27 * Sgeo|web still didn't have his question answered
21:57:33 <monochrom> still no free variable x in λx.t
21:57:49 <Sgeo|web> If one package needs an old version of a package P, and another package needs an incompatible version, can they coexist?
21:57:57 <elliott> not with cabal
21:57:59 <ybit> oops
21:58:05 <Sgeo|web> ...darn
21:58:05 <ybit> wrong again, i was right the first time
21:58:07 <ybit> the free variables of λx.t are the free variables of t
21:58:10 <elliott> see cabal-dev
21:58:16 <ybit> straight from wikipedia
21:58:18 <elliott> for a partial solution
21:58:36 <elliott> Sgeo|web: but the real solution is not to use broken outdated libraries.
21:58:44 <monochrom> no, the free variables of t with x removed. you said it yourself earlier
21:59:02 <ybit> what's going on here exactly? (λx.t)[x := r] = λx.t
21:59:07 <min> the free variables of λx.t are FV(t) - {x} and (λx.t)[x/t] = λx.t using capture-avoiding substitutions.
21:59:11 * Sgeo|web forgot what PLaneT does
21:59:12 <EvanR> dont use broken libraries
21:59:25 <EvanR> outdated might mean 'doesnt need to be fixed anymore'
21:59:29 <Sgeo|web> EvanR: But then, I can never use libraries I write myself!
21:59:29 <ybit> monochrom: that was a paste from wikipedia if i said it
21:59:30 <Sgeo|web> Erm
21:59:51 <elliott> EvanR: its broken if everyone depends on a newer incompatible version of a dep
21:59:53 <monochrom> I recommend reading what you paste
22:00:02 * ybit reads what he pasted
22:00:05 <elliott> broken by way of being outdated
22:00:06 <EvanR> elliott: i reject such fascism
22:00:19 <ybit> the free variables of λx.t are the free variables of t
22:00:32 <monochrom> it is no fair that you shovel it into my face and have me read it, and you don't read it
22:00:44 <ybit> i've read it four times now
22:00:55 <ybit> i wouldn't do that
22:01:03 <min> how can the free variables of λx.t be the free variables of t? if x is a free variable of t, then x is bound in λx.t.
22:01:27 <monochrom> cool. the free variables of t with x removed. so, no free x in (λx.t). so, "replace free x by whatever" is a no-op
22:01:32 <Sgeo|web> Would you still end up using undefined with Data.Tagged?
22:01:34 <ybit> that's from wikipedia min
22:01:42 <elliott> Sgeo|web: no
22:01:54 <mauke> <ybit> The free variables of a term are those variables not bound by a lambda abstraction. That is, the free variables of x are just x; the free variables of λx.t are the free  variables of t, with x removed
22:02:02 <Sgeo|web> mytag = Tagged {unTag = undefined :: Int }
22:02:15 <elliott> what
22:02:21 <hpaste> “Joey Adams” pasted “Using an explicitly-typed undefined to select a type class instance” at http://hpaste.org/53845
22:02:21 <Sgeo|web> Maybe I'm missing the point
22:02:24 <elliott> yep
22:02:34 <Sgeo|web> For some reason, I was hoping tags were something you don't retrieve values from
22:02:45 <elliott> sizeOf :: a -> Int
22:02:45 <JoeyA> Sgeo|web: There's an (incomplete) example of how I've used undefined in a program.
22:02:46 <Sgeo|web> s/hoping/thinking/
22:02:54 <elliott> sizeOf :: Tagged a Int
22:03:25 <elliott> former requires undefined to call generically (as typeclass function)
22:03:26 <Guest62842> getting a non exhaustive pattern error at this function when running.  not sure how to fix it with 3 args http://snipt.org/zOh1
22:03:30 <elliott> latter doesn't
22:03:36 <Mertis> there fixed my nick
22:04:01 <dibblego> Guest12731: you're missing the [] case
22:04:03 * hackagebot copilot-core 0.2 - An intermediate representation for Copilot.  http://hackage.haskell.org/package/copilot-core-0.2 (LeePike)
22:04:05 * hackagebot copilot-language 0.1 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-language-0.1 (LeePike)
22:04:07 * hackagebot copilot-c99 0.1 - A compiler for Copilot targeting C99.  http://hackage.haskell.org/package/copilot-c99-0.1 (LeePike)
22:04:11 <mauke> Mertis: try compiling with warnings; it will tell you about missing cases
22:04:19 <ybit> hmm, sorry, i overlooked x removed. i mentally cut it out thinking it was part of the explanation of the application ts
22:04:36 <Mertis> mauke: how do i compile with warnings with ghc
22:04:45 <dibblego> -Wall
22:04:46 <mauke> Mertis: ghc -Wall
22:04:49 <Mertis> ty
22:08:22 <monochrom> just don't mentally cut out anything I say
22:08:26 <min> wikipedia is probably not a good source for learning about λ-calculus. there are several introductions online of varying difficulty that explain the basic concepts better.
22:09:03 * hackagebot copilot-sbv 0.1 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-0.1 (LeePike)
22:10:35 * monochrom carefully reads several times what correspondents say, and feels that his effort and care is not reciprocated
22:11:18 <ion> monochrom said “just mentally cut out anything I say”, thus i cut out “don’t”.
22:12:00 * monochrom should next time begin by asking "do you agree to carefully read what I'll say, before I start answering?"
22:14:05 * hackagebot copilot-cbmc 0.1 - .  http://hackage.haskell.org/package/copilot-cbmc-0.1 (LeePike)
22:14:07 * hackagebot copilot-cbmc 0.11 - Copilot interface to a C model-checker.  http://hackage.haskell.org/package/copilot-cbmc-0.11 (LeePike)
22:14:21 <elliott> fast releases
22:14:39 <elliott> version G64 expected in ten days
22:14:51 <elliott> or maybe version 0.11111111...
22:15:18 <ion> It seems he couldn’t keep up the release rate.
22:18:26 <edwardk>  /msg Sgeo|web yes, i'm the god of too many projects and insufficient free time, but don't tell anyone -- i'm only supposed to be on the down low. ;)
22:19:04 * hackagebot copilot-libraries 0.1 - A Haskell-embedded DSL for monitoring hard real-time  distributed systems.  http://hackage.haskell.org/package/copilot-libraries-0.1 (LeePike)
22:19:06 * hackagebot copilot 2.0 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.0 (LeePike)
22:19:18 <Isthan> Anyone help with a simple type error? http://snipt.org/wqj7 (error line 9)
22:19:39 <Isthan>     Couldn't match expected type `[Float]'
22:19:39 <Isthan>            against inferred type `Float'
22:19:39 <Isthan>     In the second argument of `take', namely `x'
22:21:20 <ian_mi> I would say your problem is that
22:21:25 <ian_mi> In the second argument of `take', namely `x'
22:21:38 <ian_mi> Couldn't match expected type `[Float]' against inferred type `Float'
22:22:13 <Sgeo|web> Hold on
22:22:17 <Isthan> must both you and the compiler mock my inexperience at haskell?
22:22:23 <Sgeo|web> Isthan: hold on
22:22:42 <mauke> Isthan: x is a Float
22:22:47 <mauke> Isthan: you can't take 2 out of it
22:22:53 <ian_mi> not mocking, I just can't say it any better
22:22:55 <Sgeo|web> Isthan: x is an element
22:22:55 <rwbarton> your stripLatLongs function is strange in several ways
22:23:09 <Sgeo|web> Lists look like: element:list
22:23:26 <Sgeo|web> So when you pattern match against (x:xs), the x is not itself a list
22:23:37 <Isthan> oh, right
22:23:48 <Isthan> I was trying to keep that straight
22:23:57 <Isthan> rwbarton: why strange?
22:24:25 <rwbarton> well the type is wrong, and the base case is probably wrong, and you're using (++) to prepend a single element, and the whole thing is probably just a map in the first place
22:24:37 <rwbarton> also, you have extra parentheses everywhere
22:24:58 <Isthan> yeah, because someone got me on the whole (function param param) and now i'm scared to do otherwise...
22:25:08 <mauke> stop being scared
22:25:16 <copumpkin> the compiler is your friend
22:25:22 <copumpkin> if it gives you an error, it's because it loves you
22:25:24 <copumpkin> and wants you to learn
22:25:25 <Sgeo|web> Isthan: space for function application is tighter than any operator
22:25:31 <Sgeo|web> f x `myop` g y
22:25:32 <copumpkin> not because it wants you to feel dumb
22:25:40 <Sgeo|web> Will always do (f x) `myop` g y
22:25:45 <Sgeo|web> Will always do (f x) `myop` (g y)
22:25:55 <kmc> s/do/be/ ;)
22:26:43 <Isthan> all i'm trying to accomplish with those two functions is take the first two elements of a 2-d list and tack on an element from a parallel 1-d list
22:26:44 <ian_mi> has always been and will forever be
22:27:14 <Isthan> I was thinking about using zip, but i'm not sure if its the right situation
22:27:34 <copumpkin> wow, building highlighting-kate is death
22:27:38 <copumpkin> I can see why pandoc has a flag for it
22:27:47 <Sgeo|web> Pattern matching with [a,b,c,d] makes me a little queasy, although it's not wrong
22:27:55 <kmc> copumpkin, you can use that new parallel cabal-install wrapper
22:27:58 <Isthan> alternatives?
22:28:03 <kmc> or ghc -M
22:28:47 <copumpkin> kmc: no, it ate up all my memory
22:28:51 <kmc> ouch
22:28:52 <Sgeo|web> Isthan: um, well, as in, I feel more comfortable with a:b:c:d:[], but [a,b,c,d] is probably better. I'm not the most experienced Haskeller. I think the "correct" solution is to use a data type that stores 4 elements.
22:28:59 <copumpkin> because the autogenerated code has huge constants in it
22:29:02 <copumpkin> and ghc loves those
22:29:47 <Isthan> Yeah.  My professor just showed us datatypes today (this homework i'm doing was assigned more than a week ago)
22:29:53 <elliott> [a,b,c,d] is better
22:30:17 <EvanR> (a b c d)
22:30:22 <EvanR> \o/?
22:30:37 * Sgeo|web slaps EvanR
22:30:37 <kmc> this is why dynamically typed languages will always be popular... when the compiler tells you exactly where the error is, it's interpreted as "mocking"
22:30:46 <Sgeo|web> Unless you can pattern match on funct... oh, derp
22:31:11 <Sgeo|web> But, uh, yeah that's still useles
22:31:36 <Sgeo|web> kmc: It's clearly better to find errors by repeatedly running the code!
22:31:52 <Sgeo|web> THen watching it crash due to type issues only occasionally!
22:32:04 <min> or writing everything in the IO monad and peppering your code with print statements
22:32:14 <ian_mi> if I wanted to know about errors I'd be stepping through my code in a debugger
22:32:27 <EvanR> what is the real name for vector graphics? because vector is a stupid term for it
22:32:47 <EvanR> spline graphics?
22:32:57 <copumpkin> gah
22:33:00 <kmc> vector graphics
22:33:01 <copumpkin> it froze
22:33:09 <copumpkin> so I had to kill it and now have to rebuild all the fucking languages again
22:33:15 * EvanR cratches head
22:33:18 <kmc> if i wanted to know about errors i'd spend all day writing trivial unit tests
22:33:34 <ian_mi> what's wrong with vectors?
22:33:41 <EvanR> it has nothing to do with vectors
22:34:00 <ian_mi> what does? is this a package or vector graphics in general?
22:34:06 <kmc> min, just use Debug.Trace for that
22:34:07 <EvanR> general
22:34:45 <kmc> tools for debugging Haskell code are, in fact, pretty terrible
22:34:56 <smns> isn't 'foo x >>= bar' equivalent to 'liftM bar $ foo x'?
22:35:06 <kmc> no
22:35:15 <kmc> proof: you can write the latter for Applicative, but not the former
22:35:25 <kmc> @type \foo bar -> foo >>= bar
22:35:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:35:29 <kmc> @type \foo bar -> liftM bar foo
22:35:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
22:35:48 <kmc> in fact you can write the latter for arbitrary Functor
22:35:57 <ian_mi> oh, like SVG, I thought you meant openGL or something
22:36:07 <min> kmc, i know; i was kidding.
22:37:18 <kmc> the problem is that "writing buggy code" and "debugging that code" both feel like getting work done
22:37:23 <kmc> we sum them psychologically
22:37:42 <kmc> in a way that doesn't apply to "writing code which fails to compile" and "fixing it so it will compile"
22:38:15 <kmc> writing assertions and unit tests to check types also feels like getting work done, and increases your lines / day metric
22:38:22 <EvanR> the real reason people are afraid of compiled systems is that they usually dont help you as much as haskell
22:38:33 <EvanR> c and c++ will both compile and be completely braindamaged
22:38:39 <EvanR> and java
22:39:01 <kmc> EvanR, i don't dispute your "real reason" but I have another which I think is a bit less obvious :)
22:39:15 <EvanR> so might as well be braindamaged and easily use a stupid data structure like php arrays
22:39:24 <min> after spending hours debugging prolog, then discovering the error was a missing wildcard in a tuple field buried deep inside  a utility function, i am eternally grateful for haskell.
22:39:52 <kmc> "write buggy code for 1 hour, chase bugs for 1 hour" feels more productive than "stare at empty screen feeling dumb for 55 minutes, write correct code in 5 minutes"
22:39:53 <applicative> > let double x = x ++ x in ["hello","world"] >>= double
22:39:54 <lambdabot>   "hellohelloworldworld"
22:40:09 <applicative> let double x = x ++ x in mapM double ["hello","world"]
22:40:12 <applicative> > let double x = x ++ x in mapM double ["hello","world"]
22:40:13 <lambdabot>   ["hw","ho","hr","hl","hd","hw","ho","hr","hl","hd","ew","eo","er","el","ed"...
22:40:20 <EvanR> kmc: more typing == more work done
22:40:27 <copumpkin> > sequence ["hello", "world"]
22:40:28 <lambdabot>   ["hw","ho","hr","hl","hd","ew","eo","er","el","ed","lw","lo","lr","ll","ld"...
22:40:32 <kmc> that's what i learned from sloccount :D
22:40:35 <EvanR> thats how c++ won the language wars back in the 90s
22:40:38 <applicative> smns, ^^^ does this show the difference ?
22:41:06 <EvanR> and how html is preferably edited directly
22:41:33 <EvanR> if youll notice how long it takes to make a webpage with in-browser debug tools, then you go spend 2 hours on the html file
22:41:40 <EvanR> more work done!
22:42:02 <Sgeo|web> kmc: I think I know how that feels
22:42:13 <ian_mi> I've spent days rewriting a hundred lines or so
22:42:15 <Sgeo|web> I definitely feel productive when I'm debugging, running, debugging, etc.
22:42:24 <Sgeo|web> (Say, in C#)
22:42:34 <EvanR> Sgeo|web: well i feel retarded
22:45:09 <raspy> hi, I have a question
22:45:42 <applicative> raspy: do ask.
22:45:56 <Isthan> I have changed the code from my previous problem.  Still having issues on line 5 in constructing stripLatLongs return with y
22:45:57 <Isthan> http://snipt.org/wqj7
22:46:38 <raspy> isn't an expression like "id id" impredicative, since it requires instantiating the type variable of the first "id" with the polymorphic type of the second "id"?
22:47:25 <Sgeo|web> :t id id
22:47:25 <lambdabot> forall a. a -> a
22:47:42 <Sgeo|web> > id id 5
22:47:42 <lambdabot>   5
22:47:56 <shachaf> @let badger = id
22:47:57 <lambdabot>  Defined.
22:48:48 <raspy> and if "id id" works, then I would think this would work:
22:48:53 <raspy> :t id :: (forall a. a -> a) -> (forall z. z -> z)
22:48:54 <lambdabot> forall z. (forall a. a -> a) -> z -> z
22:49:00 <Sgeo|web> Isthan: I see the problem
22:49:02 <raspy> er
22:49:05 <copumpkin> raspy: it did
22:49:07 <Sgeo|web> I think we may have been mistaken about something
22:49:13 <raspy> id :: (forall a. a -> a) -> (forall z. z -> z)
22:49:16 <raspy> >id :: (forall a. a -> a) -> (forall z. z -> z)
22:49:22 <raspy> > id :: (forall a. a -> a) -> (forall z. z -> z)
22:49:23 <lambdabot>   Overlapping instances for GHC.Show.Show
22:49:23 <lambdabot>                              ((fora...
22:49:26 <Sgeo|web> No, I don't see the problem, n/m
22:49:32 <Isthan> :/
22:49:32 <Sgeo|web> Isthan: What error are you getting
22:49:35 <Isthan> sec
22:49:37 <copumpkin> Isthan: you can't show a function
22:49:42 <copumpkin> raspy, I mean
22:49:50 <Isthan>     Couldn't match expected type `Float'
22:49:50 <Isthan>            against inferred type `[Float]'
22:49:50 <Isthan>     In the expression: (stripLatLongs x) ++ [y]
22:49:54 <elliott> copumpkin: you can
22:50:03 <copumpkin> elliott: not in lambdabot, right now
22:50:04 <ion> > do id $ do id $ do id $ do id $ do id $ do id $ do id $ do id $ do id $ do id $ do id $ 42
22:50:05 <lambdabot>   42
22:50:05 <copumpkin> and not in general
22:50:09 <elliott> copumpkin: note how the error is overlspping instances :P
22:50:11 <copumpkin> in a meaningful manner
22:50:16 <elliott> not missing
22:50:18 <copumpkin> elliott: yes, which means you can't do it
22:50:22 <ion> > do id `id` do id `id` do id `id` do id `id` do id `id` do id `id` do id `id` 42
22:50:22 <raspy> http://hpaste.org/53846
22:50:23 <lambdabot>   42
22:50:24 <Sgeo|web> Lambdabot? Meaningful?
22:50:26 <Sgeo|web> HAHAHAHAHAHA
22:50:29 <elliott> you can do it in two ways!
22:50:35 <applicative> > let idd :: (a -> a) -> (a -> a) ; idd = id in idd id 3
22:50:36 <lambdabot>   3
22:50:41 <copumpkin> elliott: you can't tell it which, so you can't do it at all
22:50:50 <Sgeo|web> Isthan: oh, sorry, hold on
22:50:52 <ion> let iddqd = …
22:51:06 * EvanR goes god mode
22:51:09 <elliott> copumpkin: A regrettable flaw of Haskell ;-)
22:51:22 <applicative> raspy I think in "id id 3" the first is specialize more or less like idd above ^^^, no?
22:51:23 <copumpkin> elliott: a regrettable flaw in languages that do allow it
22:51:24 * EvanR beserk punches the cyberdemon to death
22:51:25 <shachaf> In ((id :: forall a. a -> a) (id :: forall z. z -> z)) (5 :: Int), can't it instantiate the (id id) to (Int -> Int) first, and then apply the first id to the second, concretely?
22:51:39 <Isthan> sgeo|web: the error output was actually
22:51:40 <applicative> @type flip id
22:51:40 <Isthan>     Couldn't match expected type `[Float]'
22:51:40 <Isthan>            against inferred type `Float'
22:51:40 <Isthan>     In the expression: y
22:51:40 <Isthan>     In the second argument of `(:)', namely `[y]'
22:51:40 <Isthan>     In the expression: (stripLatLongs x) : [y]
22:51:41 <lambdabot> forall a b. a -> (a -> b) -> b
22:51:51 <elliott> copumpkin: I mean the lack of instance disambiguation :P
22:51:58 <copumpkin> elliott: yeah, me too
22:52:02 <applicative> raspy note the type of flip id, this also specializes if to something that can be flipped
22:52:03 <Isthan> I was experimenting with (:) and (++)
22:52:04 <ion> @type id `asTypeIn` \f -> f id 42
22:52:05 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
22:52:11 <Sgeo|web> Isthan: y is a Float
22:52:12 <ion> @type id `asTypeIn` \f -> id f 42
22:52:13 <lambdabot> forall a. (Num a) => a -> a
22:52:16 <elliott> copumpkin: I'm not technically serious.
22:52:16 <Sgeo|web> Since it was the head of a [Float]
22:52:19 <applicative> raspy: specializes id to something that can be flipped
22:52:25 <Sgeo|web> [y] is thus a [Float]
22:52:32 <copumpkin> elliott: I am artistically dead serious
22:52:40 <Sgeo|web> I think I may be slow today
22:52:47 <Isthan> Yeah, i had intended to take something that looks like [a,b] and add [y] to it
22:52:50 <raspy> applicative: so why doesn't the ascribed version work?
22:52:58 * copumpkin drinks some fizzy water
22:53:18 <Sgeo|web> Isthan: somelist:somelistsametype makes no sense
22:53:31 <raspy> > (id :: (forall a. a -> a) -> (forall foo. foo -> foo)) id
22:53:32 <lambdabot>   Overlapping instances for GHC.Show.Show (foo -> foo)
22:53:32 <lambdabot>    arising from a use ...
22:53:35 <Sgeo|web> You're doing a [Float]:[Float]
22:53:36 <shachaf> Sgeo|web: That's what Mu was invented for.
22:53:48 <shachaf> Or maybe Cofree. Or something.
22:54:02 <raspy> hm, it seems like lambdabot doesn't have a problem with that even though my ghc does... maybe this has been fixed
22:54:08 <elliott> raspy: its a show error
22:54:10 <copumpkin> ghc is now using 2.17 GB of my memory
22:54:13 <Isthan> sgeo|web: Should I be using (++) ?
22:54:15 <DevHC_> why doesn't the following work?
22:54:15 <DevHC_> openFile "troll.txt" ReadMode >>= \h -> mkTextEncoding "UTF-8" >>= hSetEncoding h >> hPutStr h (map chr [0..0x10FFFF]) >> hClose h
22:54:19 <copumpkin> fuck highlighting-kate
22:54:20 <elliott> what do you expect it to print raspy
22:54:33 <Isthan> there must be something fundimental i'm overlooking with this
22:54:35 <shachaf> copumpkin: Are you still compiling pandoc?
22:54:40 <raspy> elliott: the fact that it's giving a show error and not a type error tells me it's "working"
22:54:51 <elliott> oh, right
22:54:52 <copumpkin> shachaf: yeah, it froze before so I had to restart from scratch
22:55:03 <raspy> elliott: in my ghc it gives a type error (see my hpaste)
22:55:04 <shachaf> copumpkin: Compiling pandoc didn't take me so much memory...
22:55:05 <copumpkin> well, I already compiled pandoc
22:55:15 <copumpkin> but I compiled it without -fhighlighting
22:55:21 <Sgeo|web> Isthan: I'm not sure. But do you see why it won't compile as-is?
22:55:23 <copumpkin> it really shouldn't be a flag
22:55:25 <shachaf> Compiling pandoc with -fhighlighting didn't take me so much memory...
22:55:34 <shachaf> copumpkin: When it takes GHC take 2.xGB RAM?
22:55:38 <copumpkin> shachaf: you on a 64-bit build of GHC?
22:55:43 <Sgeo|web> Whenever you have x:xs or something similar, x is always a single element, and xs is always a list of that type of element
22:55:43 <shachaf> Yes.
22:55:52 <copumpkin> shachaf: for .Perl, .Python, .Ruby
22:55:58 <copumpkin> on highlighting-kate
22:56:33 <copumpkin> shachaf: I dunno, maybe it's GHC 7.3's fault
22:56:38 <Isthan> sgeo|web: I believe i'm okay on that concept, I thought thats why since y is a float, I could add it to a [Float] by saying [y]
22:56:39 <shachaf> Probably.
22:56:42 <shachaf> Try GHC 7.0.
22:56:43 <copumpkin> but these source file are huge and ghc is known to hate large source
22:56:45 <copumpkin> no
22:56:52 <copumpkin> I use features in 7.3
22:56:56 <shachaf> For pandoc?
22:57:06 <copumpkin> no, for other projects I'm working on
22:57:09 <shachaf> Oh, you're using pandoc as a library?
22:57:13 <copumpkin> yeah
22:57:14 <applicative> raspy, I am thinking about it, I think something like your signature would require RankNTypes or something, no?
22:57:15 <Sgeo|web> Isthan: [y] does make it a [Float] with a single element
22:57:17 <Isthan> sgeo|web: is [Float]:[y] incorrect?
22:57:26 <Sgeo|web> Isthan: Yes, [Float]:[y] is incorrect
22:57:28 <raspy> applicative: it does indeed, and I have that enabled
22:57:29 <shachaf> It's not even incorrect.
22:57:40 <Sgeo|web> shachaf: yeah yeah, I know what Isthan mans
22:57:41 <Sgeo|web> means
22:57:50 <shachaf> Isthan: What are you trying to do?
22:58:09 <raspy> applicative: try it in your ghci
22:58:24 <Sgeo|web> Isthan: And since your (stripLatLongs x) is a [Float], it's incorrect
22:58:27 <raspy> I'm using GHC 7.0.2
22:58:34 <Isthan> I'm trying to take a 2d list [[Float]] with elements like [a,b,c,d], use ONLY [a,b], and then tack on [y] from a list [Float]
22:59:01 <shachaf> raspy: Try what?
22:59:35 <raspy> shachaf: this: id :: (forall a. a -> a) -> (forall z. z -> z)
22:59:56 <copumpkin> raspy: it works in here, in lambdabot
23:00:00 <copumpkin> you did it earlier
23:00:03 <raspy> copumpkin: I can see that :)
23:00:12 <copumpkin> raspy: you need to turn on RankNTypes
23:00:14 <elliott> lambdabot is 6.12
23:00:18 <raspy> copumpkin: they're on
23:00:34 <copumpkin> what's the type error?
23:00:37 <rwbarton> turn them on to the max
23:00:43 <raspy> copumpkin: http://hpaste.org/53846
23:00:43 <copumpkin> lol
23:00:48 <Isthan> sgeo|web: if [Float] looks like [a,b], would [a,b]:[y] not be valid?
23:00:49 <Sgeo|web> Isthan: ++ can append two lists, but try to avoid it
23:00:50 <shachaf> RankNPlusKTypes
23:01:08 <elliott> don't avoid (++).
23:01:17 <elliott> its usually fine.
23:01:19 <dxq> why would you acoid it
23:01:22 <dxq> avoid, rather
23:01:34 * Sgeo|web was thinking due to rewalking the list etc
23:01:40 <dxq> ah
23:01:42 <Isthan> I'm still getting a type error when using ++ though
23:02:15 <Sgeo|web> Isthan: Rephrase your question about [a,b]?
23:02:17 <hpaste> applicative annotated “Zuh?” with “Zuh? (annotation)” at http://hpaste.org/53846#a53847
23:02:18 <Isthan> I'm using http://snipt.org/wqj7
23:02:21 <Isthan> okay
23:02:39 <Isthan> From what I understand, stripLatLong will return something that looks like [a,b]
23:02:47 <Sgeo|web> Isthan: Why is it surrounded by []?
23:02:48 <Isthan> i'm just trying to append [y] to [a,b]
23:02:58 <ion> > [a,b] ++ [y]
23:03:00 <lambdabot>   [a,b,y]
23:03:03 <copumpkin> raspy: that does seem kind of odd
23:03:05 <Isthan> yes!
23:03:10 <Sgeo|web> n/m
23:03:12 <Isthan> but i'm getting a type error...
23:03:16 <copumpkin> not sure if it has something to do with the impredicativity issues
23:03:19 <rwbarton> that part is ok now, you have exactly the same error again though
23:03:21 <raspy> if lambdabot is actually using an older version, I guess this is a regression
23:03:44 <raspy> copumpkin: with -XImpredicativeTypes it's no difference, FWIW
23:03:50 <Isthan> Error i'm getting is     Couldn't match expected type `Float'
23:03:50 <Isthan>            against inferred type `[Float]'
23:03:50 <Isthan>     In the expression: (stripLatLongs x) ++ [y]
23:03:51 <elliott> shachaf: show raspy the runST parens
23:03:55 <applicative> raspy, I think the really get id to take a completely polymorphic thing as argument, you need to wrap it.
23:03:59 <copumpkin> raspy: the behavior of IMpredicativeTypes has changed a lot
23:04:04 <elliott> so they can see just how great lambdabot ghcs
23:04:05 <shachaf> elliott: Why don't you show raspy the runST parens?
23:04:11 <elliott> rank n types are :P
23:04:16 <Isthan> line 5 of the URL code
23:04:17 <elliott> shachaf: i forgot it :(
23:04:25 <Sgeo|web> Isthan: Your new stripLatLongs takes a [Float]
23:04:36 <Isthan> oh yes
23:04:36 <Sgeo|web> ...and n/m
23:04:52 <applicative> raspy, but of course a wrapped completely polymorphic thing is a completely specialized thing
23:05:36 <raspy> applicative: I don't need to wrap "id id" for it to work...
23:05:49 <Sgeo|web> Isthan: why the []
23:05:52 <applicative> raspy, yes but id id is simpler than you are making it out to be
23:05:52 <shachaf> @where+ runST <elliott> > (id runST) (return 5) <lambdabot>  5 <elliott> > id runST (return 5) <lambdabot>   Couldn't match expected type `m t' <lambdabot>         against inferred type `forall s. GHC.ST.ST s a'
23:05:52 <lambdabot> Done.
23:06:08 <Isthan> because y is a single Float
23:06:11 <Sgeo|web> Around the (stripLatLongs x )++[y] I mean
23:06:13 <Isthan> ooooh
23:06:17 <Isthan> maybe I dont need that...
23:06:36 <Sgeo|web> Isthan: think about it
23:06:39 <Sgeo|web> What is the type of (stripLatLongs x )++[y] ?
23:06:41 <applicative> raspy, I think if you think how " id id 'a'" works it is pretty straightforward
23:06:44 <shachaf> elliott: There.
23:06:53 <elliott> shyay
23:06:58 <elliott> shachaf: yay
23:07:00 <applicative> @type \f -> id f 'a'
23:07:01 <lambdabot> forall t. (Char -> t) -> t
23:07:06 <Isthan> I thought it was going to be [Float]?
23:07:13 <Sgeo|web> Yes
23:07:17 <Isthan> would look like [a,b,y]
23:07:18 <raspy> applicative: in the expression "id id", what type do you suppose the first "id" is being instantiated at?
23:07:19 <Sgeo|web> Now what does surrounding it with [] do?
23:07:32 <Isthan> make it 2 dimensional to be built with my recursive call?
23:07:43 <Sgeo|web> Isthan: but it's on the element side of a :
23:07:47 <Isthan> recursive call returns [[Float]]?
23:07:49 <applicative> raspy: forall a . (a -> a )-> a -> a
23:07:50 <Isthan> oooh
23:07:54 <Isthan> so append there as well?
23:07:57 <Sgeo|web> So it needs to be the type of element, not the type of the list
23:07:58 <rwbarton> Isthan: you've forgotten what (:) does (for the third time :P)
23:07:59 <Sgeo|web> Isthan: No
23:08:26 <raspy> applicative: you mean "forall a. (forall b. b -> b) -> a -> a" ?
23:08:34 <Sgeo|web> Isthan: x:xs means that x MUST BE some type call it a, and xs MUST BE some [a]
23:08:36 <applicative> raspy, no
23:08:48 <Sgeo|web> Pretending that this is legal notation, it's not:
23:08:54 <Sgeo|web> a : [a] for all a
23:08:58 <Sgeo|web> where a is a type
23:09:11 <Isthan> > 1:[2]
23:09:12 <lambdabot>   [1,2]
23:09:13 <shachaf> Sgeo|web: There's enough type-value confusion already without that. :-(
23:09:14 <Sgeo|web> Isthan: make sense?
23:09:19 <Isthan> yes
23:09:27 <Isthan> Thanks for your patience :)
23:09:35 <rwbarton> how about just writing the truth, (:) :: a -> [a] -> [a]
23:09:45 <elliott> rwbarton++
23:09:57 <Isthan> ^^
23:09:58 <raspy> applicative: if it had the type you're suggesting, I would have to decide on the instantiation of 'a' before I could apply id to itself, no?
23:10:12 <kmc> but it's a #haskell tradition to invent weird analogies instead!
23:10:13 <shachaf> Should be backwards.
23:10:22 <shachaf> (::) : a -> [a] -> [a]
23:10:31 <kmc> shachaf, gb2ocaml
23:10:41 <Sgeo|web> rwbarton: I wasn't entirely sure that Isthan would grasp the translation between prefix and operator usage
23:10:52 <kmc> Sgeo|web, then you should explain that
23:10:52 <elliott> a -> a [] -> a []
23:10:56 <elliott> ocaml!
23:11:02 <rwbarton> yes, a fair point
23:11:04 <kmc> 'a -> 'a list -> 'a list
23:11:43 <shachaf> α -> α list -> α list
23:11:48 <shachaf> α * α list -> α list ?
23:11:53 <kmc> stating the truth and explaining the notation etc. is often faster than inventing a new analogy, explaining the notation you made up on the spot, and the patching up all the ways your analogy fails to model the real world
23:12:08 <applicative> raspy, i don't see this, in a logic book you would first do 'universal instantiation' from forall a . a -> a to x -> x, substitute (y -> y) for x, then regeneralize
23:12:18 <copumpkin> a list constructor is like a bottle of soda
23:12:23 * shachaf likes that phrase there, "the real world"
23:12:27 <copumpkin> you see, the head is like the bubbles
23:12:30 <copumpkin> the tail is like the bottle
23:12:36 <copumpkin> and let me tell you how they relate
23:12:46 <copumpkin> once upon a time
23:12:54 <Isthan> I understood (:) :: a-> [a] -> [a] to be a function with two parameters, a and [a] returning [a]
23:12:54 <copumpkin> there was a sweet princess who really liked soda
23:12:55 <shachaf> Wait, but [] is also a burrito.
23:13:00 <Sgeo|web> And the glass is like the shielding of a nuclear waste container
23:13:03 <kmc> and now we're off again
23:13:06 * shachaf doesn't want to know how those analogies combine.
23:13:18 <elliott> [] is like a mouth.
23:13:18 <Sgeo|web> Isthan: yes
23:13:19 <shachaf> Isthan: That's what it is.
23:13:32 <elliott> of wisdom.
23:13:33 <shachaf> Isthan: Except it's a special function, called a constructor.
23:13:37 * copumpkin goes to sleep
23:13:39 <jessopher> in my programming language, operators are all unary, and the infix kind are all high order
23:13:41 <Isthan> I was also trying to redeem myself with the : operator by using lat:long:[] in stripLatLong function :)
23:14:00 <Isthan> can you also write `:` inline?
23:14:02 <raspy> applicative: hrm, maybe so...
23:14:10 <shachaf> Isthan: You mean with the backticks?
23:14:14 <shachaf> You don't need that; it's already inline.
23:14:14 <Isthan> right
23:14:17 * Sgeo|web doesn't think so, but it's easy to check
23:14:20 <Sgeo|web> :t `:`
23:14:20 <shachaf> s/line/fix/
23:14:21 <lambdabot> parse error on input ``'
23:14:23 <raspy> applicative: so maybe application simplifies the problem
23:14:28 <Sgeo|web> But yeah, that's useless
23:14:33 <raspy> applicative: but wouldn't you agree that the type ascription should work?
23:14:43 <raspy> applicative: and as you can see, it *does* work with lambdabot
23:14:44 <kmc> > (:) 1 [2,3]  -- Isthan
23:14:45 <lambdabot>   [1,2,3]
23:14:51 <raspy> but not my newer GHC
23:14:58 <kmc> Isthan, to use an infix operator as an ordinary function, surround its name in parentheses
23:15:07 <Sgeo|web> Wait, my test was idiotic
23:15:11 <kmc> Isthan, this also works in any other situation where you need to name an infix operator without applying it
23:15:17 <kmc> Isthan, like a module import/export list
23:15:23 <Isthan> oh I see
23:16:00 <raspy> > :t id :: (forall a. a -> a) -> (forall z. z -> z)
23:16:00 <lambdabot>   <no location info>: parse error on input `:'
23:16:12 <Isthan> Here is the code segment, now compilable: http://snipt.org/wqj7
23:16:12 <raspy> :t id :: (forall a. a -> a) -> (forall z. z -> z)
23:16:13 <lambdabot> forall z. (forall a. a -> a) -> z -> z
23:16:24 <Sgeo|web> Does anyone actually use the data SomeKeyword = SomeKeyword trick for forced keywords in functions?
23:16:40 <raspy> :t (id :: (forall a. a -> a) -> (forall z. z -> z)) id
23:16:41 <lambdabot> forall z. z -> z
23:16:42 <Sgeo|web> I saw something like that in a Template Haskell tutorial
23:16:52 <elliott> Sgeo|web: sounds silly
23:16:54 <applicative> raspy: in ghci this works let idd ::  (forall a. a -> a) -> (forall z. z -> z); idd = undefined
23:16:56 <elliott> never seen it myself
23:17:19 <raspy> applicative: well of course that works :P
23:17:27 <Sgeo|web> elliott: It reminds me a little of Smalltalk
23:17:38 <raspy> applicative: I should be able to give "id" that type
23:17:40 <applicative> raspy, but I dont think I can get id to specialize that way
23:17:53 <Isthan> How can I go about debugging non-exhaustive patterns? ;)
23:18:03 <elliott> -Wall
23:18:27 <Axman6> Isthan: compile with -Wall, and ghc will tell you what patterns are not matched
23:18:29 <applicative> raspy: I think without wrapping you won't be able to get ghc to take these foralls as seriously as you want it to
23:18:30 <Sgeo|web> :t LamE
23:18:31 <lambdabot> Not in scope: data constructor `LamE'
23:18:44 <Sgeo|web> :t Language.Haskell.TH.LamE
23:18:45 <lambdabot> [Language.Haskell.TH.Syntax.Pat] -> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp
23:18:47 <applicative> raspy, but the system keeps changing
23:18:50 <shachaf> Hmm, I just came across Miranda's abstype.
23:18:51 <Isthan> so like ghc source.hs -o -Wall source.out ?
23:19:06 <Sgeo|web> Isthan: the source.out should be right after the -o
23:19:06 <shachaf> Is there an equivalent in Haskell? I vaguely recall reading something about a Hugs extension that may have been similar.
23:19:07 <elliott> -Wall before -o
23:19:18 <applicative> raspy: I think what you want is an impredicative type, but basically those have been junked
23:19:22 <raspy> applicative: apparently it once took them more seriously than it does now
23:19:23 <Isthan> source.hs -Wall -o source.out ?
23:19:36 <applicative> raspy yes, that's what copumpkin was saying above
23:19:44 <elliott> shachaf: hmm, what's that do?
23:19:51 <elliott> Isthan: yes
23:19:53 <applicative> raspy, but i still think what it does with id id makes perfect sense
23:20:31 <raspy> applicative: I agree, "id id" should work, and so should the ascription I gave
23:20:50 <Isthan> When I attempted to compile with that, gave "compile not neccesary" type warning, also no love when running program
23:20:55 <applicative> raspy I think you would need a new id, not the one in the Prelude
23:21:01 <elliott> Isthan: rm source.out
23:21:06 <Isthan> ty
23:21:15 <shachaf> elliott: Third slide from the end in https://docs.google.com/viewer?url=www.hpc.unm.edu/~download/abqlispscheme/archives/2009-11-15-Dan.Vasicek-MirandaIntro/MirandaIntro.pptx
23:21:15 <Sgeo|web> elliott: Isn't there a force-recompile option?
23:21:25 <shachaf> -fdelete-my-source
23:21:27 <shachaf> Wait, no.
23:21:28 <elliott> Sgeo|web: sure.
23:21:37 <raspy> applicative: it won't work with anything of that type (forall a. a -> a)
23:21:41 <rwbarton> -fforce-recomp iirc
23:21:49 <applicative> raspy right
23:21:54 <raspy> applicative: the problem is with trying to instantiate a type variable at a polymorphic type using an ascription
23:22:14 <raspy> applicative: so yeah, impredicativity
23:22:28 <Isthan> So uh, I used rm on the source.out and still after recompile command says compile not necessary warning
23:22:35 <applicative> raspy this is because -- i think this is right -- the ghc treats the second forall in (forall a . a -> a ) -> (forall . a -> a) as having wide scope despite your attempt to make it do otherwisse
23:22:52 <raspy> applicative: yes, it floats the second forall out to the left
23:22:59 <elliott> Isthan: windows?
23:23:10 <elliott> oh hmm
23:23:16 <elliott> rm source.hi source.o
23:23:21 <applicative> raspy right, it makes sense in any given case, but I confess it's hard to see how the whole system can hang together :)
23:23:28 <Sgeo|web> Or -fforce-recomp might be easier really
23:23:29 <raspy> applicative: but that shouldn't cause it to fail, afaict
23:23:53 <Isthan> ounix, but just found source.o hiding
23:24:06 <raspy> applicative: the purpose of the floating is to have as many reasonable conversions between isomorphic types as possible
23:24:18 <Isthan> now blast of text to decipher from -Wall :)
23:25:28 <raspy> I'll download GHC 7.2.1 to see if by some miracle it's been fixed :)
23:25:28 <Mertis> oh hai
23:25:39 <Sgeo|web> Isthan: you realize that matching against a list having 4 elements but not against other possible lists is probably a warning?
23:26:59 <applicative> raspy yes
23:27:40 <Isthan> I expect the list of floats to always have 4 elements...but now i'm seeing your point :)
23:28:16 <Mertis> we are guaranteed and input where the lists have 4 elements
23:28:37 <Sgeo|web> Yes. You're expecting it, but Haskell still will warn you about the fact that your code will crash if it doesn't have 4 elements
23:28:44 <Isthan> yea but at points we will want 3 element lists
23:28:49 <Isthan> like for output
23:28:51 <Mertis> the output
23:29:17 <raspy> :t id :: ((forall a. a) -> b) -> ((forall x. x) -> y)
23:29:18 <lambdabot>     Couldn't match expected type `y' against inferred type `b'
23:29:18 <lambdabot>       `y' is a rigid type variable bound by
23:29:18 <lambdabot>           an expression type signature at <interactive>:1:48
23:29:22 <Mertis> Isthan: done for the night i think
23:29:49 <raspy> :t id :: ((forall a. a) -> b) -> ((forall x. x) -> b)
23:29:50 <lambdabot> forall b. ((forall a. a) -> b) -> (forall x. x) -> b
23:30:02 <raspy> aha, that's interesting
23:30:11 <raspy> that signature works in my current ghc
23:30:26 <raspy> so the fact that it can't float that second forall out prevents it from screwing up!
23:30:29 <Isthan> Yes, -Wall shows me these warnings.  I was hoping it would give me insight into my non-exhaustive patterns when i'm trying to put everything together
23:30:42 <Sgeo|web> Isthan: What sort of insight do you mean?
23:30:47 <Mertis> i was having some non exhaustive errors
23:30:51 <Mertis> was apain to fix
23:30:54 <Mertis> took a while
23:31:02 <Sgeo|web> Isthan: If you want meaningful errors when your assumptions are violated, provide cases for those alternatives:
23:31:19 <Sgeo|web> Just have them = error "Oops, got a <4 element list" or something
23:31:33 <Isthan> ok
23:31:46 * Sgeo|web is not sure if his recommendation is useful
23:31:46 <Isthan> its probably a case i'm not accounting for though...i'll have to think about it
23:31:50 <shachaf> Sgeo|web: That's kind of evil.
23:32:00 <shachaf> You want tuples or some concrete data types, not lists.
23:32:12 <Sgeo|web> shachaf: Isthan has repeatedly rejected concrete data types and tuples
23:32:23 <shachaf> Isthan: Is that true?
23:32:24 <Sgeo|web> But yes, shachaf is correct
23:33:48 <elliott> shachaf: it's not under Isthan's controlb
23:33:50 <elliott> control
23:33:53 <elliott> it's a crappy assignment
23:33:58 <shachaf> Oh.
23:34:08 <Isthan> Yeah, but I appreciate your suggestions
23:34:11 <shachaf> Well, convert the 4-list to a custom data type, do your operations on it, then convert it back.
23:34:12 <Isthan> :D
23:34:26 <shachaf> Civil disobedience, man!
23:34:45 <elliott> That's what I would do.
23:35:02 <shachaf> Consider it to be "parsing" and "emitting".
23:36:46 <Isthan> No I remember
23:37:11 <Isthan> Yea and you are crazed
23:37:16 <DevHC_> again, how do i store a String in a file using a standard encoding like UTF-8, or some other encoding, for portability?
23:37:29 <Isthan> lol, I think I figured a few good things out while talkin to IRC people
23:37:47 <elliott> DevHC_: putStr? You might want to look at Data.Text.
23:38:07 <applicative> @type let  xxx :: ((forall a. a) -> b) -> ((forall x. x) -> b) ; xxx = undefined in xxx
23:38:08 <lambdabot> forall b. ((forall a. a) -> b) -> (forall x. x) -> b
23:38:18 <DevHC_> uhm putStr has a potential to yield the famous invalid character sequence error?
23:38:19 <applicative>  @type let  yyy :: (b-> (forall a. a) ) -> (b -> (forall x. x) )  ; yyy = undefined in yyy
23:38:30 <elliott> shachaf: Wow, Miranda is still developed?
23:38:31 <applicative> raspy that sort of isolates it, no? ^^^
23:38:39 <elliott> DevHC_: Sounds like you have invalid Unicode?
23:38:48 <applicative> @type let  yyy :: (b-> (forall a. a) ) -> (b -> (forall x. x) )  ; yyy = undefined in yyy
23:38:49 <lambdabot> forall b x. (b -> forall a. a) -> b -> x
23:38:52 <applicative> @type let  xxx :: ((forall a. a) -> b) -> ((forall x. x) -> b) ; xxx = undefined in xxx
23:38:53 <lambdabot> forall b. ((forall a. a) -> b) -> (forall x. x) -> b
23:39:01 <applicative> i meant ^^^ these
23:39:07 <DevHC_> elliott: what's "invalid Unicode"?
23:39:35 <raspy> applicative: what do you mean by "isolates"?
23:39:37 <elliott> DevHC_: Not all lists of codepoints between [minBound..maxBound::Char] are valid Unicode strings.
23:39:41 <DevHC_> i want to store a String in a file in an environment-independent way
23:39:57 <elliott> Okay. Set encoding on the handle then putStr?
23:40:22 <elliott> DevHC_: hSetEncoding h utf8
23:40:22 <applicative> raspy, isolates ghc's perverse behavior, which depends on the location of the quantifier
23:40:24 <elliott> putStr h str
23:40:31 <raspy> applicative: ah, yes :)
23:40:31 <elliott> s/p/hP/
23:40:37 <DevHC_> <DevHC_> why doesn't the following work?
23:40:37 <DevHC_> <DevHC_> openFile "troll.txt" ReadMode >>= \h -> mkTextEncoding "UTF-8" >>= hSetEncoding h >> hPutStr h (map chr [0..0x10FFFF]) >> hClose h
23:40:57 <DevHC_> Not in scope: `utf8'
23:41:02 <shachaf> DevHC_: There you go.
23:41:06 <elliott> DevHC_: "doesn't work" isn't a problem description.
23:41:16 <shachaf> I like it when people answer their own questions like that.
23:41:17 <elliott> DevHC_: utf8 is here: http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/System-IO.html#g:24 but maybe your GHC is too old.
23:41:41 <raspy> applicative: given that *that* typechecks in my GHC, but if there is a forall above the result type it fails, this definitely looks like a bug
23:41:50 <DevHC_> elliott: mkTextEncoding "UTF-8" only allows code points up to 0xD7FF D:
23:41:51 <elliott> DevHC_: Anyway, don't do map chr [0..0x10FFFF].
23:41:54 <elliott> That'll include a lot of non-codepoints.
23:42:08 <DevHC_> wtf is a "non-codepoint"?
23:42:21 <Sgeo|web> DevHC_: there are some ... numbers, that are used in UTF-16
23:42:36 <elliott> DevHC_: Not all values in Char range are assigned codepoints.
23:42:40 <shachaf> UTF-42 is the only true UTF.
23:42:41 <Sgeo|web> To help represent characters that need more than 16 bits to be identified
23:42:45 <elliott> If you still don't understand, read the Unicode standard.
23:42:48 <DevHC_> UTF-8 is an encoding, ie., it stores a list of integers using a stream of octets
23:42:48 <shachaf> s/4/3/, if you feel like it.
23:42:54 <elliott> DevHC_: You are incorrect.
23:42:59 <DevHC_> ORLY
23:43:00 <elliott> It stores Unicode strings.
23:43:07 <DevHC_> UTF-8 is an encoding
23:43:10 <DevHC_> Unicode is a character set
23:43:17 <elliott> Yes, it is. Are you going to keep repeating yourself without trying to understand?
23:43:24 <applicative> raspy: 'forall above the result type'
23:43:27 <Sgeo|web> DevHC_: What he's saying is wrong is calling it a list of integers, I think
23:43:33 <shachaf> DevHC_: UTF-8 is an encoding that stores alist of Unicode code points using a list of octets.
23:43:59 <raspy> applicative: meaning, a forall on the right side of an arrow
23:44:12 <elliott> DevHC_: http://www.fileformat.info/info/unicode/char/d7ff/index.htm
23:44:13 <DevHC_> shachaf: replace Unicode code points with integers in [0..0x10FFFF] ?
23:44:16 <elliott> DevHC_: "U+D7FF is not a valid unicode character."
23:44:25 <elliott> That's why you can't print U+D7FF.
23:44:30 <elliott> It's _not_ _a_ _codepoint_.
23:44:32 <Isthan> > "Thanks":[" and "," good "," night"]
23:44:33 <lambdabot>   ["Thanks"," and "," good "," night"]
23:44:34 <Sgeo|web> DevHC_: some of those integers are not valid Unicode points
23:45:06 <XexonixXexillion> DevHC_: There are gaps in the unicode code points to allow new things to be added in later revisions
23:45:19 <shachaf> XexonixXexillion: I don't think those things will ever be code points.
23:45:22 <Sgeo|web> XexonixXexillion: and there are gaps for UTF-16's purposes
23:45:51 <elliott> I think U+D7FF is one of the surrogate things, so it's never going to be a codepoint.
23:45:51 <DevHC_> so let's say that set of Unicode points is not an interval
23:46:08 <DevHC_> still, why wouldn't UTF-8 allow u to store all points in the interval?
23:46:22 <raspy> applicative: if you draw the type as a tree with arrows being the branching points, foralls occurring above the types they quantify...
23:46:23 <Sgeo|web> DevHC_: Why should it? It's not legal Unicode
23:46:31 <elliott> DevHC_: Let's put it this way:
23:46:36 <Sgeo|web> But some things do allow you to store it, for security purposes, iirc
23:46:50 <elliott> DevHC_: If you have a value of type String containing Chars that are not valid codepoints, your program is wrong. You have made a mistake. There is an error. You have a bug.
23:46:54 <applicative> raspy yes, but the rule ghc is following treats 'right of the arrow' and 'left of the arrow' differently , according as we are right or left of the arrow, to put it, uh, crudely
23:47:03 <elliott> DevHC_: Therefore, don't expect things to work. The solution is to not do that. String is for representing Unicode strings.
23:47:08 <Sgeo|web> elliott: What about arbitrary user data?
23:47:25 <raspy> applicative: exactly, and I think that's the source of this bug
23:47:26 <DevHC_> Sgeo|web: because UTF-8 is an encoding, not a character set. UTF-8 could be used to store any other character set, or even no character set, just a list of (bounded) integers
23:47:42 <elliott> Sgeo|web: You should be validating that, obviously. Actually you should just use Text at all.
23:47:44 <elliott> DevHC_: You are incorrect.
23:47:45 <Sgeo|web> elliott: Saying you have a bug just because a String happens to store maliciously crafted data sounds wrong to me
23:47:48 <applicative> raspy  it's not a bug, it's a theory!
23:47:48 <elliott> DevHC_: UTF-8 is a Unicode encoding.
23:47:59 <shlevy> Is there a good type for representing a namespaced type (e.g. "com.apple.product-type.tool", "com.apple.product-type.library.static")?
23:48:00 <elliott> DevHC_: UTF - UCS Transformation Format.
23:48:11 <elliott> DevHC_: UCS - Universal Character Set, which is Unicode.
23:48:21 <DevHC_> then why does't chr scream instead?
23:48:25 <shachaf> UCS -- UTF Character -- oh. :-(
23:48:27 <DevHC_> wouldn't that be unsafeChr?
23:48:42 <elliott> It probably should. I'm surprised it doesn't.
23:48:51 <elliott> But maintaining a list of unassigned codepoints would kinda suck for GHC.
23:48:58 <elliott> There's a bunch of irregular ranges of unassigned codepoints.
23:49:06 <DevHC_> D:
23:49:35 <elliott> But since your program is guaranteed to completely screw up Unicode unless you know what you're doing, maybe we should leave it in to force people to learn. (I don't actually believe this.)
23:49:43 <shlevy> Hm, I suppose if there's some sort of type for representing Haskell modules?
23:50:21 <raspy> applicative: call it a theory if you like, but it's a smaller theory than it used to be, with no good reason I can see
23:50:38 <raspy> applicative: and it's quite counterintuitive
23:50:59 <DevHC_> elliott: GHC already maintains a set of illegal code points, that's why putStr fails
23:51:07 <elliott> DevHC_: No. GHC uses iconv.
23:51:12 <DevHC_> D:
23:51:14 <elliott> Or, I don't know what it does on Windows.
23:51:17 <elliott> But it uses iconv on Unix.
23:51:28 <elliott> DevHC_: I believe Data.Text handles invalid codepoints fully, btw.
23:51:29 <shachaf> What's putStr failing on?
23:51:38 <elliott> i.e. doesn't allow Text values to contain them.
23:51:42 <elliott> shachaf: Strings with non-codepoints.
23:51:52 <shachaf> Such as?
23:52:39 <DevHC_> Prelude Data.Text System.IO Data.Char> writeFile "trollme.txt" [chr 0x10FFFF]
23:52:40 <DevHC_> *** Exception: trollme.txt: commitBuffer: invalid argument (Illegal byte sequence)
23:52:58 <elliott> DevHC_: Do you think U+10FFFF is a codepoint?
23:53:08 <elliott> http://www.fileformat.info/info/unicode/char/10ffff/index.htm
23:53:11 <DevHC_> no, i was just answering shachaf
23:53:11 <shachaf> Doesn't fail for me.
23:53:14 <Sgeo|web> What was the illegal one?
23:53:19 <DevHC_> TWAT?
23:53:27 <Sgeo|web> Erm, not the illegal one
23:53:29 <Sgeo|web> The replacement one
23:53:36 <elliott> I don't know. TWAT? indeed.
23:53:58 <XexonixXexillion> it doesn't fail for me either. I get some gibberish, but no error
23:54:08 <Sgeo|web> FFFD
23:54:14 <elliott> DevHC_: ghc --version, anyway?
23:54:18 <applicative> raspy, have you seen e.g. this, http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html where he complains of the change
23:54:22 <elliott> DevHC_ is probably on 6.12 like a caveman.
23:54:27 <DevHC_> 7.0.3
23:54:31 <elliott> Darn.
23:54:33 <DevHC_> FAIL
23:54:36 <elliott> Downgrade to make my assumptions correct, please.
23:54:44 <DevHC_> no u
23:54:44 <Sgeo|web> >.>
23:55:26 <raspy> applicative: no, I have not... I'll take a look
23:57:25 <DevHC_> shachaf: openFile "troll.txt" WriteMode >>= \h -> mkTextEncoding "UTF-8" >>= hSetEncoding h >> hPutStr h ([chr 0xDC7B]) >> hClose h
23:57:46 <applicative> raspy it is the new typechecker, it broke uses like the one you were imagining.  there is a 4000 page paper explaining it somewhere ....
23:57:51 <shachaf> DevHC_: Doesn't fail for me.
23:57:55 <DevHC_> WAT?
23:58:04 <shachaf> Well, I mean, it outputs invalid UTF-8.
23:58:08 <shachaf> Does that count as failing?
23:58:15 <DevHC_> no
23:58:26 <elliott> DevHC_: Don't expect predictable behaviour for this.
23:58:29 <DevHC_> shachaf: u mean it outputs invalid Unicode, not UTF-8
23:58:31 <elliott> It's Bad and you shouldn't be doing it.
23:58:35 <elliott> No, it's invalid UTF-8.
23:58:37 <shachaf> ghc -XUnpredictableTypes
23:58:40 <elliott> Because it doesn't encode a Unicode string.
23:59:08 <DevHC_> DEFINITION: UTF-8 is a methof of storing a list of integers in [0..0x10FFFF] with a list of octets
23:59:21 <kmc> > seq ('\xD800' :: Char) ()
23:59:21 <lambdabot>   ()
23:59:27 <kmc> i consider this a bug in GHC
23:59:32 <elliott> DevHC_: Your definition is wrong.
23:59:33 <shachaf> Ooh, you can make things true by putting DEFINITION in front of them?
23:59:42 <DevHC_> elliott: no, your definition is wrong.
23:59:44 <elliott> DEFINITION: Haskell is untyped.
23:59:46 <elliott> > 9 + 'a'
23:59:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
23:59:46 <lambdabot>    arising from the literal `9...
23:59:50 <elliott> WHY IS GHC BROKEN?!
23:59:57 <shachaf> elliott: You and kmc both.
