00:04:29 <ski> <http://hackage.haskell.org/trac/ghc/wiki/PolymorphicKinds>
00:08:58 <c_wraith> oh.
00:09:07 <c_wraith> I didn't know about that proposal
00:09:14 <c_wraith> it got subsumed into the larger project
00:10:06 <c_wraith> The one about promoting types to kinds and values to types
00:10:12 <c_wraith> which is apparently due in 7.4
00:40:05 * hackagebot hlint 1.8.20 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.20 (NeilMitchell)
00:43:36 <jessopher> @hoogle (Num a) => a -> Int
00:43:36 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
00:43:36 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
00:43:36 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
00:46:26 <Jafet> jessopher: what
00:46:49 <jessopher> eh?
00:46:57 <c_wraith> jessopher: that's not really generically possible.  What do you actually want?  fromIntegral?  round?  floor?  ceiling?
00:47:13 <jessopher> fromNum
00:47:15 <jessopher> lol
00:47:20 <Jafet> Well, it is possible. (const n)
00:47:34 <c_wraith> not enough structure in Num.
00:47:43 <Jafet> I guess jessopher's imagination is pretty small
00:47:50 <c_wraith> There are num instances for matrixes.  How do you collapse a matrix to a single Int?
00:48:03 <Jafet> There are num instances for functions
00:48:12 <c_wraith> What type do you *actually* have?
00:48:30 <c_wraith> the 4 functions I listed are generally the ones you want.
00:48:41 <jessopher> whatever type an int literal is
00:48:53 <c_wraith> literals are polymorphic
00:48:58 <jessopher> precisely
00:48:59 <Jafet> :t 0
00:48:59 <c_wraith> You'll have to be more specific
00:49:00 <lambdabot> forall t. (Num t) => t
00:49:07 <c_wraith> But what you *probably* want is fromIntegral
00:49:16 <jessopher> alright
00:49:31 <c_wraith> :t fromIntegral
00:49:32 <lambdabot> forall a b. (Integral a, Num b) => a -> b
00:49:48 <jessopher> not at all then
00:50:16 <c_wraith> then you've confused me, because what you're saying doesn't really make sense
00:50:38 <c_wraith> You realize Int *is* an instance of Num?
00:50:40 <jessopher> im trying to From a Num to Int, not from an Integral to a Num
00:50:50 <c_wraith> Num and Int aren't comparable
00:50:54 <c_wraith> > 5 :: Int
00:50:55 <lambdabot>   5
00:51:02 <c_wraith> > 5 :: Num
00:51:03 <lambdabot>   Class `GHC.Num.Num' used as a type
00:51:09 <ujm> @hoogle [a] -> [a]
00:51:09 <lambdabot> Prelude cycle :: [a] -> [a]
00:51:09 <lambdabot> Data.List cycle :: [a] -> [a]
00:51:09 <lambdabot> Prelude init :: [a] -> [a]
00:51:10 <c_wraith> Num is a class.  Int is a type
00:51:25 <c_wraith> Something can be both.
00:51:43 <ujm> why didn't lambdabot also include sort just then?
00:51:44 <jessopher> right, however, when someone passes a polymorphic Int literal to my function, it doesnt close on the Int instance, and short circuiting the logic im trying to have it use
00:51:53 <jessopher> or Num literal
00:51:58 <jessopher> or whatever it actually is
00:52:07 <jessopher> :t 5
00:52:08 <lambdabot> forall t. (Num t) => t
00:52:13 <jessopher> num then
00:52:15 <c_wraith> the monomorphism restriction generally prevents literals from being polymorphic
00:52:26 <c_wraith> and when it doesn't, unification usually does
00:53:01 <c_wraith> :t let x = 5 in x
00:53:01 <lambdabot> forall t. (Num t) => t
00:53:20 <c_wraith> hmm.  lambdabot appears to not have monomorphic lets
00:53:25 <jessopher> you cant really trust lambdabot on that one
00:53:31 <jessopher> no he doesnt
00:53:48 <c_wraith> in any case, you're probably asking the wrong question
00:53:56 <c_wraith> What's the type signature of the function you're trying to write?
00:54:09 <jessopher> probably, i wasnt really intending to ask a question, I just needed to use hoogle
00:54:20 <dmwit> ujm: It only gives a few results.
00:54:24 <dmwit> ?hoogle+
00:54:24 <lambdabot> Data.List init :: [a] -> [a]
00:54:24 <lambdabot> Prelude reverse :: [a] -> [a]
00:54:24 <lambdabot> Data.List reverse :: [a] -> [a]
00:54:36 <jessopher> toVal :: Typable a => a -> Val
00:54:41 <jessopher> Typeable*
00:54:45 <dmwit> ujm: sort probably comes quite late in the results (because its type doesn't match as exactly as the others).
00:54:59 <ujm> ah okay
00:55:49 <Jafet> @hoogle (Ord a) => [a] -> [a]
00:55:49 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
00:55:49 <lambdabot> Data.Graph.Inductive.Internal.Heap heapsort :: Ord a => [a] -> [a]
00:55:49 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
00:55:51 <c_wraith> well.  toVal will *never* be passed a polymorphic argument
00:56:04 <c_wraith> the Typeable restriction means that it will always be monomorphic.
00:56:05 <dmwit> jessopher: If you haven't yet even nailed the difference between classes and types, you are almost certainly going to use all things Typeable incorrectly.
00:56:48 <c_wraith> > typeOf Nothing
00:56:49 <lambdabot>   Ambiguous type variable `a' in the constraint:
00:56:49 <lambdabot>    `Data.Typeable.Typeable a...
00:57:11 <c_wraith> Nothing is polymorphic, so it can't be the argument to typeOf
00:57:19 <jessopher> makes sense
00:57:21 <dmwit> jessopher: Let me try saying that again, but in a more positive way this time instead: it would be worth your time to help us understand what you're trying to do, so that we can give you good advice.
00:57:54 <c_wraith> (unless, of course, you make it monomorphic)
00:58:04 <c_wraith> > typeof (Nothing :: Just String)
00:58:04 <lambdabot>   Not in scope: `typeof'Not in scope: type constructor or class `Just'
00:58:12 <c_wraith> > typeOf (Nothing :: Just String)
00:58:13 <lambdabot>   Not in scope: type constructor or class `Just'
00:58:16 <c_wraith> err
00:58:20 <c_wraith> > typeOf (Nothing :: Maybe String)
00:58:21 <lambdabot>   Maybe [Char]
00:58:23 <c_wraith> ok, too late for me
00:58:34 <jessopher> again, i wasnt seeking advice, i just wanted to use hoogle, this is all just a tangent of that usage. I am content smacking my head on the wall
00:58:52 <c_wraith> well, you're smacking your head on the wall because you have a bunch of concepts mixed up.
00:59:14 <jessopher> yeah, i think thats a fair assesment
01:00:18 <dmwit> Why smack your head against the wall when you could smack other people's heads against the wall?
01:00:19 <nohonor> hi guys
01:00:23 <dmwit> Hi, nohonor!
01:00:59 <jessopher> dmwit: lol, courtesy, stubbornness
01:01:02 <nohonor> any ideas why "get_num ((k,depth):lst) last = k*(depth-last) + get_num lst depth" wouldn't work
01:01:29 <nohonor> i get a pattern error
01:01:41 <dmwit> nohonor: What should "get_num [] 0" do?
01:01:46 <c_wraith> nohonor: you didn't tell it what to do if the list is empty.
01:01:51 <c_wraith> also, dmwit is faster than me
01:02:24 * nohonor facepalms
01:02:58 <jessopher> i think most of the confusion was from testing this stuff with GHCI, rather than in compiled code
01:03:13 <nohonor> i guess it's true what they say about sleep deprivation ... thanks :-)
01:09:42 <jessopher> an explanation of what I am trying to do, is have the value type of my interpreter (named Val, which has a constructor of type Dynamic -> Val)) have the conversion functions toVal and fromVal, that go to and from instances of Typeable. I want anything that can be cast to an Int to use a specific constructor, and everything else without a concrete constructor to use the Extern :: Dynamic -> Val constructor
01:10:28 <dmwit> Define "cast".
01:11:05 <jessopher> the cast :: Typeable a, Typeable b => a -> b
01:11:20 <jessopher> function in Data.Typeable
01:11:29 <dmwit> cast doesn't have that type.
01:11:44 <dmwit> And cast always returns Nothing when a and b aren't equal.
01:11:51 <dmwit> So only Int can be "cast" to Int.
01:11:55 <causative> are there "alternative" or highly simplified type theories, I'm thinking maybe where both values and types are just vectors?
01:12:10 <dmwit> If that's really what you meant by "cast", why bother with Typeable?
01:12:52 <causative> not necessarily with the full power of type theory but with values and types
01:12:59 <causative> and some kind of map defined from values to types
01:13:18 <causative> in a simplified euclidean setting
01:13:19 <dmwit> What's a vector?
01:13:22 <dmwit> ah
01:13:46 <dmwit> I've never heard of such a thing.
01:16:27 <dmwit> I don't see why you couldn't try to write a type system like that yourself, of course.
01:16:58 <dmwit> I'm not sure I would have any idea how to do it, though. I'd already be stuck on trying to write down the type of, say, the + operation.
01:17:29 <causative> or maybe not just vectors, maybe some other geometric object
01:17:29 <jessopher> no that isnt really what i meant i guess. I guess i mean that I want Integrals to be converted to int, if possible, so they use the Number constructor of my type when they can
01:17:48 <causative> like maybe values could be points, and types could be paths, or something
01:18:16 <dmwit> :t toInteger -- jessopher
01:18:16 <lambdabot> forall a. (Integral a) => a -> Integer
01:18:53 <causative> the + operation wouldn't necessarily be a "value" in this
01:19:01 <causative> unless you find some way to correspond it to a geometric object
01:19:02 <jessopher> @hoogle Integer -> Maybe Int
01:19:02 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
01:19:03 <lambdabot> Data.Generics.Schemes gfindtype :: (Data x, Typeable y) => x -> Maybe y
01:19:03 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
01:19:15 <jessopher> lol
01:19:19 <dmwit> causative: It would help a lot if you could give a tad more intuition or motivation. Why do you want a type system like that? What would the type system be trying to guarantee?
01:19:58 <dmwit> :t inRange (toInteger (minBound :: Int), toInteger (maxBound :: Int))
01:19:59 <lambdabot> Integer -> Bool
01:20:05 <dmwit> jessopher: ?
01:20:30 <dmwit> jessopher: But why would you use Int instead of Integer?
01:21:05 <causative> dmwit, the idea is that types and values could both vary continuously instead of being discrete strings
01:21:15 <quicksilver> if jessopher is already using dynamic then he just needs a list of cases.
01:21:23 <jessopher> the ball is already in play, all this haskell <-> mylanguage business was not an issue when i make the type
01:22:13 <jessopher> adding a constructor is no problem, but changing the constructor for numbers is a monolithic amount of refactoring
01:22:46 <quicksilver> you can `mplus` bunch of dynApplys
01:23:34 <quicksilver> well maybe that's fiddly because it comes out as dynamic.
01:23:37 <dmwit> causative: Right, but why do you want them to vary continuously?
01:23:45 <quicksilver> anyhow you just need one case per int-like-type you want to special case
01:24:11 <jessopher> quicksilver: thats probably what i will end up doing
01:25:41 <causative> dmwit, I only have a shadow of an idea, but there are a lot of ways to "attack" continuous things, you can use calculus or numeric simulation
01:26:10 <causative> finite element analysis
01:28:06 <quicksilver> jessopher: that's the only thing you can do.
01:28:19 <quicksilver> jessopher: Dynamic only permits one-type-at-a-time approachs
01:28:24 <quicksilver> although you can build them up, obviously.
01:31:25 <causative> like maybe, correspond expressions to points, and evaluating an expression could be drawing the longest possible path from the expression that satisfies certain constraints
01:34:17 <causative> typing would involve a function that assigns a value (the type) to each point (expression)
01:34:32 <causative> and the type function would have to be constant along any evaluation path for a point
01:36:57 <hpaste> jessopher pasted “conversions between Val and (Tyeable a) => a” at http://hpaste.org/54641
01:37:11 <mm_freak> Seq in containers 0.4.0.0 is a Monad, but not an Applicative…  this must be a bad joke
01:37:32 <mm_freak> we really have to fix that damn class hierarchy
01:38:33 <causative> the type function would also have to satisfy certain constraints based on what the types are
01:39:27 <causative> like if A : B, and B : C, and we have a type constraint saying A : B and B : C then A + B : D, the type function must assign type D to A + B
01:39:37 <causative> where + is simply vector addition
01:40:24 <causative> or I should have said A : B and C : D -> A + C: E, didn't mean to re-use B
01:42:30 <quicksilver> jessopher: yes, toDyn and fromDynamic are polymorphic
01:42:38 <quicksilver> it's just you can't pass a polymorphic value o them
01:42:40 <quicksilver> not quite the same
01:42:49 <jessopher> yeah i understand
01:43:07 <jessopher> i cant think of an instance when that would happen in practice anyhow for my application
01:43:31 <jessopher> or when it would make sense for my application
01:43:55 <jessopher> I always want to get a value of a concrete type back
01:44:01 <quicksilver> then you're fine
01:44:07 * jessopher nods
01:44:07 <quicksilver> as far as I am following
01:45:28 <jessopher> the dynamics werent so much an issue as closing on an Int for values passed into toVal, that were like Ints, but not actually Ints
01:46:19 <jessopher> but I think I am just going to refactor to a better type for the Number constructor
02:01:07 <leino> I am having some trouble with GLUT: when I run a glut program from within ghci and then close the window, ghci also exits. I expected that when I closed the window, I would come back to the ghci prompt. is this behaviour intentional?
02:01:16 <mroman> Is there something like MVars which supports multiple puts?
02:01:37 <mroman> Like a stack.
02:02:35 <benmachine> mroman: FIFO or FILO?
02:03:19 <Axman6> mroman: Chans?
02:03:59 <mroman> Chans should work.
02:04:19 <mroman> benmachine: FIFO.
02:04:31 <benmachine> yeah, Chan
02:04:51 <mroman> Thx.
02:08:02 <carpi> is there a difference between the "data" and "newtype" keywords?
02:08:10 <benmachine> carpi: yes
02:08:20 <benmachine> usually 'data' will do
02:08:27 <mroman> Oh. Chans are based on MVar.
02:08:43 <carpi> benmachine: when would there be a need to use newtype?
02:08:57 <benmachine> carpi: http://haskell.org/haskellwiki/Newtype I wrote this which tries to explain it but I've had people tell me it isn't very good :P
02:09:35 <mroman> What's the usecase of dupChan?
02:09:54 <mroman> Why should I use dupChan instead of passing the initial chan?
02:10:25 <mroman> Except I wan't the function I pass the dupChan to not worrying about what's already in the chan.
02:10:40 <mroman> *want
02:11:31 <benmachine> mroman: I think the idea of dupChan is that writing to it sends output to both chans, but reading from it only consumes from one?
02:12:09 <benmachine> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/Control-Concurrent-Chan.html "data written to either channel from then on will be available from both"
02:13:37 <carpi> thanks for link..its not as bad as you think it is : )
02:13:37 <mroman> The documentation only specifies:
02:13:46 <mroman> the duplicate channel begins empty, but data written to either channel from then on will be available from both.
02:14:17 <mroman> Reading only from one... wouldn't that result in the work being done twice?
02:14:37 <benmachine> mroman: the work?
02:14:57 <mroman> If you process the data read from the chan.
02:15:15 <Axman6> mroman: if you just share a Chan, the each item in the channel will only be read once
02:15:28 <mroman> Yes.
02:15:29 <benmachine> mroman: well, yes, unless it's not the same work
02:15:36 <mroman> But if it's a duplicate?
02:15:40 <benmachine> mroman: suppose you wanted to handle key presses but also log them
02:15:44 <Axman6> if you use dupChan, then each duplicated chan will contain the data. it's useful to broadcast data to many threads
02:15:48 <benmachine> you could dupChan and then give one to the logger and one to the handler
02:16:03 <benmachine> that's a fairly contrived example but you can see the idea, right
02:16:08 <Axman6> benmachine: hey, that's a cool usecase i hadn't thought of
02:16:41 <mroman> benmachine: Ic.
02:17:02 <Axman6> mroman: it's like making a pipe with many outputs, and reading for any output won't affect the others
02:18:21 * Axman6 -> sleep
02:25:11 <carpi> could someone please give me a hint as to how I may implement the "sieve of erotosthenes" for getting primes in a given range? Just a hint.. no answers please..
02:25:42 <Renze> Hi all!
02:26:14 <ocharles> carpi: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes ? :)
02:26:20 <ocharles> Depends how much of a hint you want
02:26:24 <carpi> yea
02:26:31 <carpi> ocharles: this is what ive done so far
02:27:27 <carpi> ocharles: basically you start by eliminating all multiples of 2 and then 3 and soo on.. but there is no operation for crossing out an element in a list..
02:27:36 <carpi> though there is one for deleting
02:27:43 <carpi> some how i feel like i sound silly
02:28:37 <ukl> dear #haskell, using FreeBSD 8.2, I find ghc unbearably slow on a almost-still-quite-decent computer, probably because it's swapping like mad.  Is this in any way FreeBSD-related or just the way GHC is?
02:29:14 <ukl> it doesn't matter if it's the snap init example app or (at the moment) xmonad-contrib, compiling anything takes ages.
02:30:18 <ukl> (the computer has 1gb RAM, btw)
02:30:27 <Renze> I've got a question about which datastructure I should choose: it has a max length of 1100, I need to get/add/remove as fast as possible; in a 5:1:1 ratio approximately. It needs to have fixed indices, so FingerTrees/sequences aren't an option I assume. I looked at DiffArray, but read somewhere that they weren't as fast as they looked like (actually around the same speed as Array, didn't say anything about memory, but I think that wasn
02:31:09 <Renze> Of course, I could write something myself, but I don't think I can create something with the same quality as released packages
02:31:42 <luite> what are fixed indices?
02:32:46 <Renze> If at one point an element is at index x, at any other point in time it is at index x as well
02:35:24 <luite> right, I'd trie IntMap first
02:35:46 <luite> perhaps some of those HAMT things if you have keys that arent Int
02:36:20 <luite> not sure which one is best and which ghc version you need to make it perform well
02:37:25 <Renze> stupid me, maps are the place to be of course... thanks!
02:38:33 <luite> it's still a boxed structure of course, if you really need maximum performance at all costs, you might need to switch to some unboxed ST array thing
02:40:08 * hackagebot compdata 0.5 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.5 (PatrickBahr)
02:41:21 <carpi> what is the difference between boxed and unboxed?
02:41:21 <Renze> Thanks, I'll first try this and see the results :)
02:42:27 <luite> carpi: an unboxed value is just that, a value, it can't be an unevaluated thunk or undefined
02:43:11 <carpi> luite: and a boxed valued needs to be unboxed before it can be used in an expression?
02:44:36 <luite> carpi: no, but the box usually adds a level of indirection. with unboxed arrays you have performance benefits because the values are actually in contiguous memory, and the unboxed container implicitly adds strictness
03:15:49 <CasperVector> @help
03:15:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:16:14 <CasperVector> @help map
03:16:14 <lambdabot> map. #haskell user map
03:22:34 <carpi> in recursion, are the expression in a where clause evaluated everytime or only the first time?
03:24:47 <Sebasti0n> As it is a new function call they should be evaluated every time
03:25:16 <carpi> thanx
03:25:45 <Sebasti0n> If they do not change throughout the recursive calls you could pass them along as parameters
03:54:43 <ukl> nearly 2 hrs for 'cabal install xmonad-contrib' (intel core2, 1.66 ghz, 1gb memory, freebsd).  Is something broken here or is this to be expected?
03:55:03 <dcoutts> doesn't sound healthy
03:55:31 <ukl> it's swapping like mad, but I don't know how to diagnose the problem
03:55:51 <mm_freak> what's a fast way to get a precise clock?  it doesn't have to reflect system time, just real time
03:55:59 <dcoutts> ukl: is it linking?
03:56:10 <mm_freak> a clock starting at 0 at program start would totally suffice
03:56:52 <ukl> dcoutts: at the beginning it's pretty fast, after some time it creeps almost to halt while "compiling x of n..."
03:57:41 <dcoutts> ukl: ah, ghc taking lots of memory
03:57:49 <ukl> well, actually, I don't know if this "Compiling" step includes some linking...
03:58:00 <ukl> dcoutts: yes
03:58:28 <dcoutts> mm_freak: Data.Time.getCurrentTime ?
03:59:59 <dcoutts> mm_freak: mean anything specific by "fast" ?
04:01:06 <mm_freak> dcoutts: getCurrentTime is my main bottleneck now
04:01:21 <mm_freak> i get around 70k FPS with it and around 300k FPS without it
04:01:35 <mm_freak> i need something like SDL's getTicks
04:01:53 <mm_freak> but i'd prefer not to depend on the whole SDL for a single action
04:02:00 <dcoutts> the rts uses gettimeofday for the event logging
04:03:27 <mm_freak> hmm
04:03:36 <dcoutts> mm_freak: hmm, getCurrentTime is also using gettimeofday apparently
04:04:00 <mm_freak> well, i'm using getPOSIXTime, because i need the current time as a single number in seconds
04:04:28 <mm_freak> the offset is really not important…  i just need a clock
04:04:50 <quicksilver> do you really need to check the clock 300,000 times per second?
04:05:08 <mm_freak> quicksilver: yes…  i need precise time deltas
04:05:15 <dcoutts> mm_freak: then perhaps your limitation really is the C gettimeofday
04:05:23 <mm_freak> not sure
04:05:25 <dcoutts> mm_freak: the speed of that varies between platforms
04:05:29 <mm_freak> /getting/ the time isn't actually expensive
04:05:31 <quicksilver> or, to phrase the question another way - you may get you loop running at 70k FPS but that is presumably the "empty main loop"
04:05:36 <Eduard_Munteanu> gettimeofday is rather expensive IIRC
04:05:44 <dcoutts> on recent linux gettimeofday can be quite cheap
04:05:45 <quicksilver> do you really expect real programs to run at 70 kHz?
04:05:46 <mm_freak> having getCurrentTime in the action doesn't slow it down much
04:05:51 <mm_freak> but actually /using/ the time value does
04:05:58 <dcoutts> but it depends on the hardware
04:06:08 <mm_freak> so i guess the representation of NominalDiffTime is slow
04:06:26 <dcoutts> if the stars are aligned then linux can make gettimeofday into a fully user-space op
04:07:03 <quicksilver> because (1/70kHz - 1/300kHz) is 11 us
04:07:21 <quicksilver> you can't do much in 11us
04:07:27 <mux> if you're running FreeBSD, there are also specific _FAST clock ids to use with clock_gettime() that are faster because they don't perform a full timecounter query
04:07:35 <mux> which is expensive
04:11:02 <dcoutts> mm_freak: almost all the Data.Time representations are slow because they all use Integer
04:11:03 <dcoutts> :-(
04:11:21 <dcoutts> slow and large, and not unpackable or unboxable
04:11:48 <mm_freak> hmm
04:11:58 <mm_freak> well, i'm converting NominalDiffTime to Double for my purpose
04:12:04 <dcoutts> e.g. the Fixed types like Pico are a great idea, except we ought to be able to say 'pico in a Int64'
04:12:17 <mm_freak> isn't there a library with some equivalent to SDL's getTicks?
04:12:33 <mm_freak> because that one is lightning-fast
04:12:44 <dcoutts> see what it's calling underneath
04:13:06 <dcoutts> perhaps it's just avoiding using gettimeofday
04:13:40 <dcoutts> mm_freak: have you checked in C how many gettimeofday calls you can do per second ?
04:14:35 <quicksilver> SDL_GetTicks calls clock_gettime(CLOCK_MONOTONIC, &now); if available
04:14:40 <quicksilver> falls back to gettimeofday if not.
04:14:51 <Eduard_Munteanu> Presumably you want to use high resolution timers, like the HPET.
04:14:56 <mm_freak> dcoutts: as said, i don't think that gettimeofday() is the problem
04:15:02 <Eduard_Munteanu> Not sure how you do that in Haskell though.
04:15:10 <quicksilver> in sdl 1.3, at least, which I have to hand.
04:15:13 <mm_freak> as said, just having getCurrentTime in the action does not slow it down much
04:15:35 <quicksilver> then write your own direct FFI import of getimeofday?
04:15:47 <quicksilver> unsafe
04:16:02 <dcoutts> mm_freak: copy the Data/Time/Clock/CTimeval.hs from the time package
04:16:03 <Eduard_Munteanu> Or if this isn't a SMP system, the TSC could be safe.
04:16:09 <mm_freak> hmm…  that will raise a much worse class of problems:  portability =/
04:16:45 <Eduard_Munteanu> (even on SMP I guess it's safe if you stick the process/thread to a particular CPU)
04:17:07 <dcoutts> mm_freak: I'd be extremely surprised if doing one Integer addition and division was the problem here
04:17:22 <dcoutts> and that's all that getPOSIXTime is doing over the raw C ffi binding
04:17:35 <mm_freak> dcoutts: the realToFrac kills it
04:18:11 <dcoutts> getPOSIXTime isn't using realToFrac
04:18:19 <mm_freak> yes, but i am
04:18:36 <dcoutts> ok, then try without :-)
04:19:06 <mm_freak> i'll try…  so i'm going to define a VectorSpace instance for NominalDiffTime
04:19:17 <mm_freak> feels kind of odd though =)
04:20:00 <Eduard_Munteanu> mm_freak: why are you doing this? If it's profiling, surely there are better ways.
04:22:32 <mm_freak> Eduard_Munteanu: it's not profiling
04:22:36 <mm_freak> it's FRP
04:23:06 <mm_freak> ok, next problem:  there is no Data.Vector.Unboxed.Unbox instance for NominalDiffTime =/
04:23:22 <quicksilver> being Integer-based it's not unboxable
04:23:30 <Eduard_Munteanu> I see... perhaps you just need a monotonic time source, rather than something accurate?
04:23:33 <mm_freak> i think for now i'll just live with realToFrac
04:23:41 <mm_freak> Eduard_Munteanu: it has to be accurate
04:24:06 <mm_freak> monotonic and accurate, but not necessarily reflecting any real world clock
04:24:19 <mm_freak> i'll see what other options are there
04:24:29 <Eduard_Munteanu> That makes FRP sound rather expensive.
04:25:29 * Eduard_Munteanu thought FRP was about maintaining the illusion of (continuous) time.
04:31:27 <mm_freak> Eduard_Munteanu: it's AFRP, for which time is just an addon
04:31:42 <mm_freak> AFRP is about data dependencies between changing systems
04:36:11 <mm_freak> Eduard_Munteanu: right now my AFRP library gets well about 300k FPS, even with time
04:37:41 <mm_freak> but adding an FPS measurement to the system slows it down to about 60k-70k…  the measurement itself is an average function, which is fast, when you apply it to random noise, but slow when you apply it to time as Double
04:38:44 <mm_freak> in other words, the same code used with getRandom from MonadRandom gives me the 300k FPS, while used with fmap realToFrac getPOSIXTime gives me 70k FPS
04:39:45 <Eduard_Munteanu> mm_freak: what do you do with   'fmap realToFrac  getPOSIXTime
04:39:46 <Eduard_Munteanu> ?
04:40:35 <Eduard_Munteanu> I mean, do you display it, store it somewhere... ?
04:41:14 <mm_freak> Eduard_Munteanu: i differentiate time (which is just subtraction) to dt, and then i basically do:  recip . avg $ dt
04:41:33 <mm_freak> i display the average at the end, but that's certainly not the bottleneck
04:41:40 <Eduard_Munteanu> I see.
04:41:43 <mm_freak> it's only displayed at every 1000th frame
04:42:19 <Eduard_Munteanu> One thing I'm unsure of is whether FPS count has any significance or not here.
04:42:55 <Eduard_Munteanu> Have you tried doing real work while measuring FPS? Does it make things slower?
04:48:49 <eviltwin_> I'm currently using haskell for a compiler project at uni with alex/happy for the lexer/parser. Currently I'm using the posn wrapper for Alex and I'm wondering what benefits the monad wrapper would actually get for me?
04:49:44 <quicksilver> mm_freak: so what you're saying is that adding an FPS counter costs 11us per cycle; to me that doesn't seem terribly
04:50:00 <eviltwin_> (I realise it means I can carry around an arbitrary state of my choosing... I'm just wondering what sort of things one would want to do with this state... I don't really see any examples anywhere)
04:52:23 <dmos> tinkering with multiple GHCs: linux generic binary ./configure punts with failing to load libgmp.so.3 (I have libgmp.so -> so.10). Is there hope to get that going, or do I have build from the source tarball?
04:52:53 <quicksilver> you could try just making that as a symlink
04:52:56 <quicksilver> might be binary compatible
04:53:08 <quicksilver> or see if your distro has 'libgmp3' packages
04:53:20 <HugoDaniel> hi
04:57:49 <dmos> quicksilver: ok, build running, lets see how far this goes. Thanks
04:58:08 <dmos> quicksilver: with the symlink version...
05:00:18 * hackagebot billeksah-services 1.0.0 - Leksah library  http://hackage.haskell.org/package/billeksah-services-1.0.0 (JuergenNicklischFranken)
05:02:25 <luite> billeksah? ugh, what's next? snigulpleksah ?
05:05:18 * hackagebot billeksah-pane 1.0.0 - Leksah library  http://hackage.haskell.org/package/billeksah-pane-1.0.0 (JuergenNicklischFranken)
05:05:20 * hackagebot billeksah-main 1.0.0 - Leksah plugin base  http://hackage.haskell.org/package/billeksah-main-1.0.0 (JuergenNicklischFranken)
05:05:22 * hackagebot billeksah-forms 1.0.0 - Leksah library  http://hackage.haskell.org/package/billeksah-forms-1.0.0 (JuergenNicklischFranken)
05:10:24 * hackagebot billeksah-main-static 1.0.0 - Leksah plugin base  http://hackage.haskell.org/package/billeksah-main-static-1.0.0 (JuergenNicklischFranken)
05:18:05 <ClaudiusMaximus> oh my, integer-simple really is slow (60x slower than integer-gmp :-/)
05:21:20 <byorgey> hmm, nice to see Leksah is still being worked on
05:25:47 <carpi> how would you go about replacing every other element in a list with .. say 0. For example if I say "makeZ 2 [3,4,5,6,7]" it should return [3,0,5,0,7]
05:27:49 <byorgey> what is the argument '2' for?
05:28:09 <carpi> every second element in the list must be replaced with 0
05:28:49 <byorgey> > let makeZ n = zipWith ($) (cycle (replicate (n-1) id ++ [const 0])) in makeZ 2 [3,4,5,6,7]
05:28:51 <lambdabot>   [3,0,5,0,7]
05:29:02 <byorgey> > let makeZ n = zipWith ($) (cycle (replicate (n-1) id ++ [const 0])) in makeZ 5 [1..20]
05:29:03 <lambdabot>   [1,2,3,4,0,6,7,8,9,0,11,12,13,14,0,16,17,18,19,0]
05:29:46 <carpi> what is the "$"?
05:29:54 <carpi> ah the function maker
05:29:55 <byorgey> function application
05:29:57 <byorgey> f $ x = f x
05:30:27 <byorgey> I make a list of functions that looks like  [id, const 0, id, const 0, ...]  and then apply them elementwise to the list of numbers
05:30:50 <byorgey> > zipWith ($) [f,g,h] [a,b,c]
05:30:51 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:30:51 <lambdabot>    `GHC.Show.Show b'
05:30:51 <lambdabot>      a...
05:31:04 <byorgey> > zipWith ($) [f,g,h] [a,b,c] :: [Expr]
05:31:04 <lambdabot>   [f a,g b,h c]
05:31:38 <Sebasti0n> that is a pretty cool approach byorgey
05:32:15 <carpi> and if you had to use recursion would it look similar?
05:32:45 <cheater> can someone fill in the blank? recursion is iteration modulo ______.
05:33:00 <cheater> fusion? inlining?
05:33:37 <byorgey> carpi: no, if I had to use recursion I'd just maintain a counter as I walked through the list, and build up a new list by outputting either 0 or each element depending on the counter
05:34:06 <byorgey> cheater: that doesn't really make sense.
05:34:52 <carpi> byorgey: but how do you maintain a counter? there is no state. would you use some kind of fold?
05:35:10 <cheater> byorgey: become more creative.
05:35:21 * hackagebot xss-sanitize 0.3.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.1 (GregWeber)
05:35:24 <Eduard_Munteanu> fooWithoutState = fooWithState initialState
05:35:35 <byorgey> carpi: the counter would be one of the arguments to my recursive function.  you can 'maintain state' by passing a different argument every time you recurse.
05:36:33 <byorgey> carpi: using a fold would be difficult, since you have to keep track of the counter from left -> right but build up the new list from right <- left
05:36:34 <Eduard_Munteanu> cheater: recursion doesn't necessarily inhibit fusion or inlining
05:36:57 <hpaste> Carpi pasted “Sad story” at http://hpaste.org/54645
05:37:05 <carpi> there you go ^
05:37:13 <carpi> i've been trying to make that work for the past 3 hours
05:37:15 <carpi> no luck
05:37:21 <byorgey> you'd need a bidirectional fold, as in http://thread.gmane.org/gmane.comp.lang.haskell.cafe/83874/focus=84535
05:37:23 <carpi> i feel like i almost got it..
05:37:25 <carpi> but not
05:41:10 <byorgey> carpi: a few quick observations: (1) you call makeZero recursively on the output of oneZero, which is certainly wrong: you have already processed the output of oneZero, no need to process it again
05:41:54 <Eduard_Munteanu> > let f xs = map (\(x,i) -> if even i then 0 else x) $ zip xs [1..] in f [1,2,3,4]
05:41:55 <lambdabot>   [1,0,3,0]
05:42:23 <silasdavis> What is the underlying type of the list monad, theoretically speaking. Is it for integers for example all subsets of the integers?
05:42:25 <Eduard_Munteanu> It should be rather easy to turn that into a recursive-looking function.
05:42:31 <byorgey> (2) if oneZero gets called onthe empty list it will crash
05:42:55 <carpi> byorgey: that function doesn't work at the moment.. its wip
05:43:08 <byorgey> silasdavis: all lists of integers.
05:43:16 <carpi> byorgey: infact.. if i run it right now..it never stops evaluating
05:43:29 <byorgey> carpi: yes, that's because of observation (1)
05:43:41 <Eduard_Munteanu> silasdavis: what do you mean by "underlying type"?
05:43:49 <carpi> Eduard_Munteanu: i don't want even values to be 0.
05:44:11 <byorgey> carpi: Eduard_Munteanu is checking whether the *index* is zero, not the values
05:44:14 <carpi> if makezero 3 [1..10] then every 3rd element should be 0
05:44:17 <byorgey> er, whether the index is even
05:44:45 <silasdavis> Eduard_Munteanu: a monad has a type constructor that takes an element from an underlying type to a monad type
05:44:45 <Eduard_Munteanu> > let f xs = map (\(x,i) -> if even i then 0 else x) $ zip xs [1..] in f [10,10,10,10]
05:44:45 <lambdabot>   [10,0,10,0]
05:45:03 <carpi> byorgey: and will oneZero get called on the empty list? cos there is a pattern match for an empty before using oneZero
05:45:11 <silasdavis> I am trying to understand whether the underlying type is from outside haskell in our metalanguage, or whether it is a haskell type
05:45:19 <Eduard_Munteanu> silasdavis: right... it takes a to [a]
05:45:37 <silasdavis> if the latter does the list monad type constructor just take a list to a list
05:45:44 <silasdavis> Eduard_Munteanu: that's the unit function isn't it?
05:45:54 <benmachine> silasdavis: from that description it sounds like by "an underlying type" you mean "any underlying type"
05:46:01 <silasdavis> the type constructor must take any 'list' to a 'monad list'
05:46:07 <Eduard_Munteanu> silasdavis: that's the type of the unit, yeah
05:46:17 <benmachine> no, it takes any 'thing' to a 'list of thing'
05:46:35 <benmachine> since list is a monad, the list-of-thing is what you are calling a a monad type
05:46:40 <benmachine> but that's not common terminology
05:46:53 <benmachine> or not common phrasing, at least
05:47:30 <hpaste> Sebasti0n pasted “makeNum” at http://hpaste.org/54646
05:47:56 <Sebasti0n> carpi: There is one way of doing it recursively
05:48:35 <silasdavis> I see that both the 'list' and 'list monad' types which I am trying to draw a distinction between are parameterised by another type which their elements take, but this element type is not the same as the 'underlying type' of the monad (just looking at monad defintion)
05:49:08 <cheater> Eduard_Munteanu: i realize, i'm just thinking, iteration and TC recursion are so similar that they must be exactly the same if you don't look at some specific property which distinguishes the one from the other. so i wonder what that is.
05:49:19 <byorgey> silasdavis: what definition are you looking at?
05:49:45 <byorgey> silasdavis: I am not familiar with this terminology.
05:50:23 <silasdavis> http://en.wikipedia.org/wiki/Monad_(functional_programming)
05:50:55 <silasdavis> sorry that does identify the unit function as acting on the underlying type
05:51:44 <silasdavis> but if the underlying type as used there is, say, integer, then the type constructor definitioin can't be right
05:51:57 <silasdavis> since it would not allow us to create all lists
05:52:11 <byorgey> silasdavis: why is that?
05:52:36 <silasdavis> because it would only take a single integer as its argument
05:52:56 <silasdavis> oh, but then we could join them I suppose
05:52:58 <byorgey> silasdavis: no, a *type* constructor takes a *type* as an argument
05:53:17 <byorgey> so the type constructor [] takes a type 'a' as an argument and produces the type [a]
05:53:23 <byorgey> a could be Integer
05:53:29 <silasdavis> ah
05:53:40 <silasdavis> silly me, that makes sense, thank you!
05:54:33 <byorgey> glad to help =)
05:56:01 <Eduard_Munteanu> cheater: well, you can always turn recursion into iteration.
05:56:59 <Eduard_Munteanu> Even non-tail-recursive cases, if you simulate a stack.
05:57:46 <cheater> Eduard_Munteanu: i realize
05:57:59 <cheater> Eduard_Munteanu: i am asking what the name of the specific difference between the two is
05:59:45 <Eduard_Munteanu> I'm not sure there is a fundamental difference, aside from the way you encode it.
06:01:00 <cheater> the encoding is the difference
06:01:07 <cheater> but you can't just say "encoding"
06:01:16 <cheater> that's not precise enough
06:15:13 <byorgey> cheater: iteration is recursion, modulo an inappropriate obsession with low-level operational semantics
06:15:57 <cheater> byorgey: lol
06:17:56 <carpi> netsplit/
06:17:56 <carpi> ?
06:20:56 <wlangstroth> byorgey: is that yours, or are you quoting?
06:35:12 <JuanDaugherty> in any case sounds like a classic haskell perspective to quote
06:35:36 <merijn> Classic theoretical CS perspective
06:36:45 <mkscrg> is it possible to use to forall declarations in a single datatype? like: data PlotSeries = forall a. forall b. PlotSeries [(a,b)]
06:36:57 <mkscrg> *two
06:37:26 <benmachine> mkscrg: equivalent to data PlotSeries = forall a b. PlotSeries [(a,b)] I think
06:37:34 <benmachine> (i.e. sure, why not)
06:38:48 <jessopher> @hoogle Float -> Rational
06:38:48 <lambdabot> Prelude toRational :: Real a => a -> Rational
06:38:48 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
06:38:48 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
06:40:09 <mkscrg> benmachine: thanks, that's makes too much sense :)
06:40:09 <jessopher> > toRational pi
06:40:10 <lambdabot>   884279719003555 % 281474976710656
06:40:14 <jessopher> lul
06:41:14 <luite> everyone knows it should be 22%7!
06:41:47 <dakrone> can someone point me to an explaination of the (!!) function? I was reading the wiki about memoization and I don't understand its use in (map fib [0 ..] !!)
06:42:16 <luite> > [1,9,3,4] !! 0
06:42:17 <lambdabot>   1
06:42:18 <luite> > [1,9,3,4] !! 1
06:42:19 <lambdabot>   9
06:42:21 <luite> etc :p
06:42:25 <jessopher> > toRational ((22/7) :: Double)
06:42:26 <lambdabot>   7077085128725065 % 2251799813685248
06:42:38 <dakrone> it's just a 'get' or 'nth' type thing?
06:42:41 <koala_man> yes
06:42:42 <luite> dakrone: yes
06:42:42 <jessopher> so many pies
06:43:15 <dakrone> how would it work in the (map ...) then? I understand mapping fib over an infinite seq of numbers, but why add the !!?
06:43:31 <luite> dakrone: you make a list of all fibs, and then use !! to get the right one
06:43:51 <dakrone> oh, so it's currying then so it produces a new fn that takes an index?
06:44:06 <age> Hello.
06:44:40 <luite> dakrone: oh right, that does look a bit more confusing than necessary :)
06:45:00 <hpaste> age pasted “cocktail sort” at http://hpaste.org/54649
06:45:07 <dakrone> would (!! (map fibs [0..])) be another way to write that correctly?
06:45:50 <age> Can someone please look at the above paste and give me a hint on where it has "Non-exhaustive patterns" ?
06:46:45 <merijn> Doesn't the error show line numbers?
06:46:52 <age> All of them.
06:47:04 <age> As in, lines 1-18.
06:47:23 <danr> > toRational (pi :: Double)
06:47:23 <lambdabot>   884279719003555 % 281474976710656
06:47:32 <danr> nice! ^^ Pi as a rational
06:47:49 <DukeDave> danr: Lol, I didn't know about that
06:47:55 <merijn> age: Oh, duh. swappingpass
06:48:32 <age> merijn, I tested that function separately and it works as expected, producing a list
06:48:34 <jessopher> double precision pi anyhow... I need arbitrary precision floats
06:48:36 <merijn> age: Last argument: "(a:b:l)", doesn't match lists of one or zero element
06:49:04 <age> merijn, (a:[]) ?
06:49:21 <danr> [] /= b:l
06:49:31 <jessopher> I want my irrational constants to == bottom
06:49:35 <merijn> agolsme: non-exhaustive patterns doesn't mean "doesn't work". It means "function is only defined for certain inputs and will crash (well, throw an exception) when it is given an input which doesn't match the given patterns"
06:49:38 <merijn> err
06:49:44 <merijn> s/agolsme/age/
06:49:53 <age> I see
06:50:13 <merijn> age: So if you call swappingPass with [] or [1] it will throw an exception
06:51:06 <merijn> age: Oh, wait. I see you had a:[], so that just means you are missing the empty list
06:51:32 <jessopher> > 1 % 0
06:51:33 <lambdabot>   *Exception: Ratio.%: zero denominator
06:52:18 <carpi> line continuation character is "\"?
06:52:22 <age> merijn, Fixed that, same error
06:53:08 <hpaste> age pasted “revised shakerost” at http://hpaste.org/54651
06:53:23 <merijn> Can you pastebin the error too?
06:54:31 <hpaste> age pasted “the error” at http://hpaste.org/54652
06:55:44 <age> Hmm, adding 'otherwise' gets me an unchanged list
06:55:45 <carpi> is it possible to continue an expression in the next line?
06:56:05 <carpi> in python yu would have to add "\".. is there something like that in haskell?
06:56:11 <jessopher> carpi: yes, usually if its indented more than the previous line, its considered a continuation
06:57:21 <jessopher> carpi: i think \ is just for string literal continuation in haskell
06:57:57 <merijn> age: Hmm, I don't really know off the top of my head and I don't really have time to look at it further
06:57:59 <jessopher> but it might be more general
06:58:28 <carpi> jessopher: im trying to give a name to a 150 digit number..
06:58:40 <carpi> like ... let x = 234232323..........
06:58:53 <jessopher> well if its not in a do block, the indentation doesnt have to be greater, it can be equal
06:59:01 <age> merijn, Thanks for the empty list hint anyway.
06:59:29 <carpi> jessopher: does each line need to be indended? the indendation veers to the right
07:00:08 <merijn> age: The non-exhaustive pattern match means that somewhere a list value is possible which is not accounted for by your patterns. So I'd recommend double checking all recursion to see whether you might be forgetting a case somewhere until someone here has time to help
07:00:18 <jessopher> carpi: if you are using indentation, then you should use indentation. otherwise your code wont compile
07:01:03 <jessopher> you can however bracket notation, and not worry about it
07:01:12 <jessopher> use^
07:01:18 <hpaste> carpi pasted “indendation” at http://hpaste.org/54653
07:01:26 <carpi> jessopher: ^ is that correct?
07:01:37 <jessopher> lol no
07:02:10 <jessopher> let { x = foo; etc }
07:02:23 <jessopher> in
07:03:31 <age> Is there something like empty function?
07:03:54 <age> I want a variable to sometimes contain `not` and sometimes do nothing
07:03:56 <jessopher> carpi: its not necessary to use the semicolon if its just one binding though
07:04:07 <Saizan> age: id
07:04:49 <age> Saizan, thanks
07:05:20 <benmachine> "empty function" usually means something else, but id does what you want
07:05:29 * hackagebot yesod 0.9.3.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.3.3 (MichaelSnoyman)
07:05:47 <hpaste> carpi pasted “indendation” at http://hpaste.org/54654
07:06:01 <carpi> ?
07:06:06 <jessopher> that should work
07:06:26 <carpi> :( nope..
07:06:29 <carpi> parse error
07:06:29 <jessopher> but im no compiler
07:06:35 <jessopher> try the brackets
07:06:40 <jessopher> sec
07:07:13 <hpaste> jessopher annotated “indendation” with “indendation (annotation)” at http://hpaste.org/54654#a54655
07:07:14 <hpaste> jessopher annotated “indendation” with “indendation (annotation)” at http://hpaste.org/54654#a54656
07:08:30 <carpi> hmm.. for some reason.. thats not working : (
07:09:45 <dblhelix> carpi: I don't think there is a way to split integer literal over several lines
07:11:43 <dakrone> could someone point me in the right direction regarding this error? http://p.draines.com/1322580655736abe0f1c0.txt
07:11:47 <dakrone> I thought I had the types right
07:12:20 <hpc> round (fromIntegral maxNum / 2)
07:12:35 <hpc> maxNum :: Integral a => a, from the type of euler3
07:12:37 <dblhelix> dakrone: you're using (/) to divide integrals, while it only works for fractionals
07:12:38 <hpc> :t round
07:12:38 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:12:47 <hpc> :t (/)
07:12:48 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:12:58 <hpc> (/) expects something of type Fractional a => a
07:13:08 <dakrone> oh, okay, that makes sense, thanks hpc & dblhelix
07:13:09 <dblhelix> :t div
07:13:10 <lambdabot> forall a. (Integral a) => a -> a -> a
07:13:21 <hpc> or use div haha
07:13:23 <dblhelix> dakrone: use div instead
07:14:55 <dakrone> okay, div works much easier
07:18:33 <Sebasti0n> Question: When I have a main thread which spawns a certain number of threads which are supposed to run forever do I still create a global list of child threads to keep the main thread running or is there another approach?
07:18:55 <KitB> Can anyone tell me how to use "\r" effectively?
07:20:34 <KitB> (Or equivalent)
07:20:49 <_oz> Hi! I find one thing very annoying and wanted to how others deal with it. I
07:20:49 <_oz> tend to use where clauses for "private" function definitions, private to the
07:20:49 <_oz> function they belong to. But it doesn't work for functions with more than one
07:20:50 <_oz> equation (or does it?)
07:21:03 <_oz> (oops, sorry for the line breaks)
07:21:23 <_oz> for example, i want to define foobar in a where clause in the following:
07:21:24 <_oz> f (Foo x) = foobar x >>= baz; f (Bar x y) = foobar x >>= foobar y >>= baz
07:21:35 <hpc> KitB: same way you use '\013' effectively
07:22:03 <sipa> _oz: should work fine
07:22:11 <sipa> _oz: just make sure all equations are indented identically
07:22:17 <sipa> like:
07:22:26 <sipa> bla x = foo x
07:22:35 <sipa>   where foo 0 =
07:22:40 <hpc> _oz: functions in the 'where' clause can have multiple patterns, but the whole 'where' clause only applies to one pattern of the top function
07:22:42 <sipa>         foo 1 = ...
07:23:29 <KitB> hpc: I mean is there a way to clear the line
07:23:38 <_oz> hpc: yes, and that's what annoys me :)
07:23:52 <_oz> what do people do in this case, give up and define the function at the top level?
07:24:23 <hpc> _oz: that, or do foo = foo' where ...
07:24:30 <hpc> and define foo' in the where clause
07:25:06 <hpc> _oz: generally, i only use where clauses if they close over the arguments to the top function
07:25:17 <hpc> ie: foo = bar where bar = True -- i wouldn't do this
07:25:34 <hpc> foo x = bar where bar = x / 2 -- i would do stuff like this, though not in such a trivial case
07:26:35 <_oz> hpc: too bad. do you happen to know what actually stops where from "applying" to every equiation?
07:26:54 <_oz> i mean, if you want it to apply to only one equation, you already have let .. in ..
07:27:07 <hpc> _oz: the difference is that 'where' works across guards
07:27:22 <hpc> _oz: so you can have foo x | ... = ...; | ... = ... where ...
07:27:32 <hpc> and have all that extra stuff in scope for both guards
07:27:40 <_oz> yes. and that surprises me even more.
07:27:44 <_oz> maybe it is just me.
07:27:48 <hpc> it is a bit odd
07:28:51 <_oz> I don't see any reason why it doesn't work across equations
07:29:07 <_oz> anyway, I'll just define my helper functions at the top level and not export them
07:29:09 <_oz> cheers.
07:29:45 <hpaste> “_riba” pasted “trees...” at http://hpaste.org/54658
07:29:47 <hpc> _oz: it's a side-effect of how things get desugared, i think
07:30:05 <_riba> I have no idea what to do :/
07:30:10 <hpc> foo True = x; foo False = y; translates to foo x = case x of True -> x; False -> y
07:30:35 <_riba> I have to map "Func" on each node
07:30:44 <hpc> 'where' clauses can reference the inside of the pattern matches in those 'case' statements
07:31:02 <hpc> so they would have to be inside each and every case
07:31:19 <hpc> so i suppose that's the reason
07:31:23 <_oz> hpc: not really
07:31:29 <hpc> er, bad example
07:31:40 <_oz> the compiler can do what you suggested
07:31:42 <hpc> foo (Just x) = bar where bar = x; foo Nothing = Nothing
07:31:52 <_oz> (I mean foo = foo' business)
07:32:02 <_riba> if I add another pair of parentheses around map, it tells me I need [LTree] and not [LTree] -> [LTree]
07:32:09 <age> Whee
07:32:21 <age> I've implemented cocktail sort, it seems
07:32:32 <_riba> but map doesn't return a function, so I don't know how to fix it
07:32:33 <_oz> what about, foo x' = let bar = x in case x' of Just x -> ...
07:32:45 <_oz> oops, x isn't in scope
07:32:49 <_oz> i see.
07:34:31 <hpc> designing language syntax is definitely a tricky business
07:34:55 <hpc> i personally have a lot of minor annoyances with haskell that i don't know how i would fix
07:35:22 <sipa> let's do away with the whole purity business, shall we?
07:35:30 <_oz> I suppose if people get annoyed enough, they go ahead an implement things like SHE.
07:35:42 <Sebasti0n> where do I find the later function used here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#g:12 ?
07:37:24 <hpc> Sebasti0n: um... wow that's annoying
07:37:36 <hpc> nothing on hoogle or on a google "site:haskell.org" search
07:37:53 <Sebasti0n> I tried hayoo
07:38:14 <hpc> later appears to be of type IO () -> IO ()
07:39:59 <Sebasti0n> later appears quite often on pages so it is heard to find the function
07:48:21 <ddarius> There is no later function.
07:48:30 <bscarlet> Okay, so I've got me an infinite <<loop>>.
07:48:59 <bscarlet> What's a good way to figure out _exactly_ where?
07:49:14 <ddarius> Add -Wall and look for shadowed variables.
07:49:55 <bscarlet> ddarius: It's not something simple like that - I've gotten too clever w/ recursive do notation.
07:50:45 <ddarius> Then you can do the -xc thing and maybe that will help or maybe the debugger will help, but you'll probably just have to think through it.
07:50:45 <bscarlet> I'm trying to disentangle my monads to see where an actual dependency crept in despite there being no need for one.
07:50:59 <Sebasti0n> ddarius: yeah, I figured it out.
07:51:04 <bscarlet> What's "the -xc thing"?
07:53:59 <ddarius> @google site:haskell.org/ghc "-xc"
07:54:01 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/runtime-control.html
07:54:01 <lambdabot> Title: 4.16.�Running a compiled program
07:54:43 <bscarlet> I tried http://www.haskell.org/haskellwiki/Debugging#Infinite_loops, but as the trace had no repeated locations I didn't see how to figure out where the loop was.
07:56:05 <bscarlet> ddarius: thanks. That's the kind of tool I was hoping for.
07:56:25 <Plobzik> hi
08:14:31 <balphas> how do I link to a library using ghc whose name doesn't start with lib
08:14:47 <balphas> ghc -lfoo doesn't work because it assumes foo is actually called libfoo
08:17:48 <copumpkin> I hate that convention, and I don't know
08:17:48 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:18:11 <quicksilver> balphas: full filename I think
08:18:28 <quicksilver> balphas: simply ghc foo.a or ghc foo.so
08:18:31 <quicksilver> no -l
08:18:41 <quicksilver> -l means "add lib, look in standard directories"
08:18:53 <quicksilver> you can always do gcc /usr/lib/libc.so instead
08:18:59 <quicksilver> and I think ghc is like gcc here
08:19:38 <Botje> you can pass arbitrary options to ld with -optl
08:25:50 <bscarlet> Are code locations for profiling, coverage, and debugging all different?
08:25:58 <bscarlet> (in GHC)
08:27:29 <tnks> There's a blog post that I was pointed to porting functional ideas to C# that's been bothering me:  http://arlobelshee.com/post/mock-free-example-part-3-fixing-untestable-code-sequences
08:27:41 <tnks> I was wondering if I could bounce ideas here about some of my complaints.
08:27:58 <balphas> quicksilver: thanks
08:28:09 <tnks> naming, I feel the idea that sequencing is a monad is a superfluous argument if all we're going to do is accumulate a homogenous list.
08:28:22 <tnks> it almost feels like "monad" name-dropping.
08:28:39 <tnks> but I'm happy for someone to enlighten me about a deeper essence.
08:30:24 <balphas> quicksilver: running otool -L on the generated executable yields the wrong path after linking it like this (im on OS X)
08:30:42 <quicksilver> that doesn't surprise me very much
08:30:46 <quicksilver> you can edit those paths though
08:32:21 <quicksilver> balphas: install_name_tool -change /opt/local/lib/libpng14.14.dylib @executable_path/../Frameworks/libpng14.14.dylib YourApp.app/Contents/MacOS/YourApp
08:32:31 <quicksilver> balphas: (copied from a makefil recipe for a port I maintain)
08:32:59 <balphas> quicksilver: looks like theres a ghc option (dylib-install-name) maybe I can use that
08:33:46 <quicksilver> maybe :)
08:33:54 <balphas> hmm no doesnt look like it works :D
08:45:10 <hpaste> tsuraan pasted “ghc 7.0.4 compile error” at http://hpaste.org/54660
08:45:23 <tsuraan_> can anybody decypher the compiler error that I'm getting?
08:45:42 <tsuraan_> It's in code that has been compiling fine for months, and I don't know what's changed
08:46:25 <tsuraan_> as far as I can tell, the difference may just be that llvm's version got bumped?  does that make any sense?
08:49:10 <tsuraan_> yeah, looks like my system bumped llvm from 2.8 to 2.9, and now ghc can't build stuff very well.  it doesn't always fail though, just on that one file from what I can tell
08:49:59 <Jaak> did you upgrade ghc aswell?
08:50:21 <tsuraan_> ghc's version stayed at 7.0.4, but it was built against the newer version of llvm
08:50:39 <tsuraan_> I have a nightly build bot that makes a full OS image from source every night :-/
08:50:41 <osfameron> how do you 'add' two Data.Map x Int ?
08:50:43 <Jaak> might still need to rebuild your packages against newer ghc
08:50:49 <Jaak> "newer"
08:52:02 <geheimdienst> osfameron: check out the section "combine": http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/Data-Map.html
08:52:14 <tsuraan_> that version of ghc was built and installed before any haskell packages were installed
08:52:37 <tsuraan_> so it was a totally fresh image, and it first built llvm-2.9, and then ghc-7.0.4, and then a bunch of haskell deps, all of which built fine
08:52:45 <tsuraan_> and then most of my haskell code also built fine
08:53:00 <tsuraan_> and then this one file is giving me really strange errors
08:53:13 <tsuraan_> and I haven't pasted in that file, which isn't so useful
08:53:19 <osfameron> geheimdienst: aha, so unionWith (+)
08:53:53 <geheimdienst> osfameron: yeah, that's a possibility. depending on what you need of course :-)
08:53:55 <Jaak> i see
08:54:13 <hpaste> tsuraan pasted “code that gets above compiler error” at http://hpaste.org/54661
08:54:22 <tsuraan_> so that's a pretty dull peice of code
08:54:43 <tsuraan_> heh.  I like the linting process :)
08:55:41 <osfameron> geheimdienst: heh, TMTOWTDI is alive and well in Haskell!
08:55:52 <osfameron> but yeah, I think that's what I want, thanks
08:55:56 <geheimdienst> tsuraan_: have you tried cabal clean?
08:56:08 <tsuraan_> yeah, a couple of times :)
08:56:09 <tnks> is it possible in Haskell to have data of type:  [a => M b, b => M c, c => M d, ... ]
08:56:23 <tnks> I'm not as hip to all the extension tricks out there.
08:56:33 <copumpkin> tnks: you can with a custom GADT, but you wouldn't get the list syntax
08:56:34 <geheimdienst> tsuraan_: just checking :) i mean, it has to be some kind of library version mismatch ...
08:56:36 <mauke> tnks: that doesn't look like a type
08:57:08 <tsuraan_> well it's weird, because the things it says it can't resolve are the functions in that file itself
08:57:17 <tsuraan_> I think
08:57:19 <tnks> copumpkin: cool, just checking.
08:57:19 <byorgey> tnks: see http://hackage.haskell.org/package/thrist
08:57:31 <byorgey> in particular http://hackage.haskell.org/packages/archive/thrist/0.2.1/doc/html/Data-Thrist-Monad.html
08:57:50 <tsuraan_> it seems very upset about NetworkziProtocolziLengthPrefix_fromPrefixed1_srt
08:57:55 <copumpkin> tnks: but unless you put some additional constraints on the functions in the list, the only thing you can ever do with them is fold them into a single function
08:57:55 <tnks> are GADTs a compiler extension?
08:58:08 <copumpkin> yeah
08:58:08 <tsuraan_> which is one of the two functions dexported by that module
08:58:10 <copumpkin> -XGADTs
08:58:17 <copumpkin> you can probably get by with just existential types here
08:58:55 <byorgey> yeah, existential quantification is enough
08:58:59 <tnks> copumpkin: this is all in response to a blog post that got me worked up a little:  http://arlobelshee.com/post/mock-free-example-part-3-fixing-untestable-code-sequences
08:59:44 <tnks> I am trying to build an argument that the concept of a monad is superfluous to aggregation.
09:00:10 <byorgey> tnks: all concepts are superfluous.  just inline definitions everywhere.
09:00:25 <Jaak> tsuraan_: what happens if you try to build that file with ghc manually?
09:00:43 <copumpkin> tnks: I agree, all you need here is a category :)
09:00:51 <copumpkin> in this case, it's the kleisli category
09:01:12 <byorgey> but a kleisli category is built from a monad.
09:01:27 <geheimdienst> copumpkin: thanks, i'm sure that makes it a great deal simpler to a c# guy or whatever
09:01:33 <geheimdienst> ;)
09:02:07 <Jaak> <- off
09:02:15 <tsuraan_> jaak: it seems to work fine
09:02:27 <byorgey> tnks: looks to me like that blog post is essentially using a Writer monad
09:02:50 <tsuraan_> oh, nope
09:02:56 <byorgey> or rather, it looks like they're using a State monad, but if all they're doing is aggregating results, then a Writer monad would be sufficient
09:03:18 <geheimdienst> tnks: that post is long :-/ so you're essentially saying that what that guy's doing could be accomplished by simply putting a lot of lambdas in a list? or a lot of IO actions
09:03:35 <hpaste> tsuraan pasted “manual compile with ghc 7.0.4” at http://hpaste.org/54662
09:03:48 <byorgey> my point earlier was that everything done with monads could be accomplished without monads; so what?
09:03:50 <tsuraan_> so now it complains about addPrefix and fromPrefix
09:04:11 <tsuraan_> works fine if I don't do "-fllvm"
09:04:27 <tsuraan_> does anybody have ghc 7.0.4 working with llvm 2.9?
09:05:04 <tsuraan_> except that it's working for everything else...
09:05:11 <tsuraan_> so probably something I'm doing wrong
09:05:38 <tnks> byorgey: I'm trying to exclude issomorphisms to a monad from the discussion.
09:05:51 <tnks> my point is to understand the structure of the computation, not the name.
09:06:07 <Sebasti0n> Question: When a thread reads something out of a channel, transforms the data and writes it into another channel. Will that action be carried out by the thread or will it be carried out once someone reads the data from the output channel?
09:06:22 <mauke> depends on how you do it
09:06:27 <byorgey> tnks: ok. It looks to me like the structure of the computation is "run a bunch of actions in sequence, and along the way accumulate some outputs from the actions"
09:06:46 <byorgey> tnks: do you agree?
09:07:26 <hpaste> Sebasti0n pasted “Channel” at http://hpaste.org/54663
09:07:29 <geheimdienst> that sounds as if you could do it as a fold
09:07:54 <Sebasti0n> mauke: that is how I implemented it
09:07:58 <mauke> Sebasti0n: yeah, that looks like a thunk to me
09:08:04 <byorgey> geheimdienst: yes, you could.
09:08:11 <mauke> Sebasti0n: could be simplified a bit with 'forever'
09:08:14 <tnks> byorgey: there's a few other constraints worth calling out.  The actions have a specific dependency chaining on the prior action.
09:08:19 <erasereraser> hey guys i got a test in functional programming right now is it cool if i just type in the questions and you guys give me the answers???
09:08:26 <byorgey> tnks: ah, ok.
09:08:27 <danm_> haha
09:08:27 <NemesisD> hi all. i'm trying to compile a binary for a production server. unfortunately my linux kernel is at 3.X theirs is in the 2s, so anything i compile on my system and run on there has linking problems not being able to find the right files
09:08:30 <tnks> which affects the generality of the accumulation.
09:08:31 <mauke> erasereraser: don't ask to ask!
09:08:32 <erasereraser> i didnt study
09:08:48 <tnks> byorgey: which is part of why I'm driving for not jumping to a monad pre-emptively.
09:08:48 <byorgey> erasereraser: sure!  we will probably give you completely wrong answers though
09:08:56 <mauke> erasereraser: you may or may not get correct answers
09:09:13 <NemesisD> they are running CentOS or some other such garbage whose newest GHC is 6.10.4, is there any way i can cross-compile on my system for theirs or allow more flexible linnking?
09:09:21 <Sebasti0n> mauke: what do you mean by thunk?
09:09:44 <mauke> http://en.wikipedia.org/wiki/Thunk_(functional_programming)
09:09:47 <NemesisD> i'd prefer for my project to compile under GHC 7.x if at all possible and i don't really like the idea of compiling code on a production server
09:09:50 <erasereraser> I need to implement a binary search in haskell
09:09:52 <byorgey> tnks: I really don't understand your argument. "actions with dependencies on prior actions" sounds exactly like a monad to me.
09:09:56 <c_wraith> NemesisD: that's a tough problem, because CentOS runs even a different version of libc.
09:10:02 <erasereraser> its pretty tricky
09:10:12 <mauke> erasereraser: on what?
09:10:17 <erasereraser> in haskell
09:10:18 <NemesisD> c_wraith: yeah that was their argument for not wanting to upgrade GHC, it would bone all the other packages on the system
09:10:21 <mauke> erasereraser: on what?
09:10:25 <geheimdienst> NemesisD: not sure, but i guess the path of least pain would be to use the same compiler and library versions as on the server. there is ways of having multiple ghc versions around
09:10:27 <erasereraser> a list
09:10:30 <Sebasti0n> ahh, sorry, I didn't know the word and my dictionary didn't enlighten me
09:10:30 <erasereraser> or array
09:10:31 <mauke> erasereraser: that makes no sense
09:10:35 <mauke> erasereraser: that makes more sense
09:10:36 <Sgeo> Is there a reason Network.Browser uses a monad?
09:10:56 <monochrom> why cross-compile? use a virtual machine to run a similar CentOS and compile there, then deploy to the real machine
09:10:58 <c_wraith> NemesisD: You're probably "best" off setting up a CentOS vm/system with the same version of the OS, then building GHC 7 from source (using whatever ghc it has).
09:11:09 <NemesisD> lol you guys got that out before i could finish typing
09:11:19 <tnks> byorgey: yeah, that part of the argument has less traction.
09:11:37 <NemesisD> now i just have to install centos D:
09:11:39 <byorgey> binarySearch p [] = error "not found"; binarySearch p (x:y:rest) | p y = x | otherwise = binarySearch (not . p) rest  -- lots of binary in this search
09:11:42 <tnks> his end reduction is [a => a], which he then folds across.
09:12:43 <tnks> byorgey: is (=>) a monad?  I thought it was only an applicative.
09:12:44 <erasereraser> hey guys come and join #lawrencetech
09:12:54 <erasereraser> its a functional programming channel
09:12:59 <erasereraser> and everyones an op
09:13:05 <byorgey> tnks: what is (=>) ?
09:13:19 <sipa> tnks: you mean (->) ?
09:13:21 <monochrom> you should have a test machine that mirrors the production machine anyway. a virtual machine is somewhat adequate for that.
09:13:40 <tnks> sipa: sorry, you're right, mincing syntax.
09:13:43 <ddarius> For very small values of adequate.
09:13:58 <mauke> tnks: (->) is neither. (->) e is both
09:14:12 <monochrom> well yeah, but it is the minimum one should do
09:14:20 <hpc> (forall e. (->) e), to be pedantic :P
09:16:29 <monochrom> the ideal is to get an exact replica, telling accounting that it's for "spare parts": http://queue.acm.org/detail.cfm?id=2031677
09:18:17 <erasereraser> thanks for all the help guys
09:18:26 <erasereraser> that binary search really did the trick
09:18:31 <erasereraser> im gonna ace this test
09:19:08 <Sebasti0n> mauke: so do I need deepseq to force evaluation? reducing it to whnf would not help would it?
09:19:24 <tnks> mauke: byorgey: got to jet, but I'll try to formulate my thoughts in a paste bin, maybe.
09:19:37 <tnks> later.
09:19:43 <tnks> thanks for some clarifications.
09:20:15 <byorgey> I can't tell if erasereraser was serious or not.
09:22:02 <Sebasti0n> or to someone else: Is it correct to use deepseq in this function? http://hpaste.org/54663
09:23:58 <mauke> RanDominate: hey
09:23:58 <carpi> is it true that values definied in a where clause are only visible within a particular pattern match?
09:24:10 <monochrom> yes
09:24:34 <carpi> thx
09:38:40 <thoughtpolice> https://github.com/ghc/testsuite/commit/dfdb979305d5ebb7b28fcabce06d9095d81d34da
09:38:46 <thoughtpolice> 'currentCallStack' whaaaaaaa
09:39:33 <ion> woot
09:39:40 <geheimdienst> thoughtpolice: simon said he did something about call stacks just some hours ago https://plus.google.com/107890464054636586545/posts/YJzAAxw28N7
09:40:00 <thoughtpolice> that's what i get for not checking G+ more often
09:40:17 <Sgeo> > (+3) < (+4)
09:40:18 <lambdabot>   *Exception: (==): No overloading for function
09:40:32 <monochrom> no function comparison for you
09:40:42 <Sgeo> Why does (->) have an Ord instance, and why does it use (==)'s error message?
09:41:05 <geheimdienst> > () < ()
09:41:06 <lambdabot>   False
09:41:31 <monochrom> some vector library makes (->) a Num instance. but Num requires Ord, whether you like it or not.
09:41:48 <mauke> since when?
09:41:57 <Sgeo> @src Num
09:41:57 <lambdabot> class  (Eq a, Show a) => Num a  where
09:41:57 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:41:57 <lambdabot>     negate, abs, signum     :: a -> a
09:41:57 <lambdabot>     fromInteger             :: Integer -> a
09:42:02 <monochrom> oh, sorry
09:42:11 <geheimdienst> monochrom: i think that's a caleskell issue
09:42:22 <mauke> geheimdienst: what does that mean?
09:43:19 <monochrom> no, Cale would not do that, judging from his opinion on Num etc
09:43:28 <geheimdienst> mauke: i thought that works only because of lambdabot funkiness
09:44:00 <mauke> geheimdienst: how is a vector library "lambdabot funkiness"?
09:44:02 <geheimdienst> but really, what do i know ...
09:44:39 <monochrom> no, a vector library just wants (->) to be Num. I don't know who wants Ord.
09:44:48 <fryguybob> @instances Ord
09:44:48 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:44:50 <fryguybob> @instances-importing Data.NumInstances Ord
09:44:51 <lambdabot> (), (a -> b), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:46:23 <byorgey> since Ord is supposed to be a total order, I don't know of a sensible Ord instance for functions
09:46:56 <hpc> since you can't inspect functions, i can't think of any way you could write ANY Ord instance
09:48:06 <Saizan> compare _ _ = EQ is one :)
09:48:23 <byorgey> Saizan: touche
09:48:26 <hpc> :P
09:48:34 <Saizan> not a total order though
09:48:42 <fryguybob> http://hackage.haskell.org/packages/archive/NumInstances/1.0/doc/html/src/Data-NumInstances.html
09:48:48 <byorgey> compare _ _ = EQ  is a total order
09:48:58 <roconnor> Saizan: it is if you define f == g = True
09:49:13 <geheimdienst> we hold these truths to be self-evident that all functions are created equal ...
09:49:30 <byorgey> hpc: well, you can define a partial order on functions by  f <= g iff forall x. f x <= g x
09:49:43 <byorgey> hpc: which is actually computable if the domain is finite and enumerable
09:49:57 <Saizan> roconnor: ah, yeah
09:49:59 <roconnor> byorgey: or better, if the domain is compact
09:50:04 <byorgey> ooooh
09:50:29 <byorgey> roconnor: as I was writing that sentence I wondered if you could pull some trick like that =)
09:50:31 <hpc> and sometimes computable if you do freaky tricks a-la "seemingly impossible functional programs"
09:50:31 <roconnor> byorgey: er I guess I don't know that for sure
09:50:33 <roconnor> I think so
09:50:44 <byorgey> oh. well, OK =)
09:51:06 <roconnor> I'm used to correcting that for discussions of Eq
09:51:09 <roconnor> not for Ord
09:51:15 <roconnor> but I think the result stands
09:51:34 <ddarius> According to synthetic topology, compactness is just what you need to calculate forall.
09:52:03 <roconnor> and overtness is just what you need to calculate exists
09:52:07 <roconnor> ... whatever overtness means
09:52:15 <fryguybob> > map (min (*2) (/2)) [1,-1]
09:52:16 <Sgeo> > max (+2) (+3) 5
09:52:16 <lambdabot>   [0.5,-2.0]
09:52:16 <lambdabot>   8
09:54:03 <roconnor> > deriv (min (*2) (/2)) (-1)
09:54:04 <lambdabot>   2.0
09:54:09 <roconnor> > deriv (min (*2) (/2)) (1)
09:54:09 <lambdabot>   0.5
09:54:28 * roconnor doesn't dare try at 0
09:54:31 <Sgeo> :t deriv
09:54:31 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
09:54:42 <Sgeo> Dif?
09:54:56 <Sgeo> deriv (abs) 0
09:54:58 <roconnor> Sgeo: it is a local ring
09:55:01 <Sgeo> >deriv (abs) 0
09:55:12 <Sgeo> ...
09:55:13 <roconnor> > deriv abs 0
09:55:14 <lambdabot>   0
09:55:19 <roconnor> > signum 0
09:55:19 <lambdabot>   0
09:55:25 <hpc> heh
09:55:33 <roconnor> > deriv abs x
09:55:34 <lambdabot>   signum x * 1
09:58:23 <hpaste> nwf pasted “HOAS encoding of closed finally-tagless interpreters?” at http://hpaste.org/54665
09:58:43 <nwf> Is there a type-theory wizard who can help me with what I'm sure is a misguided attempt? :)
09:59:18 <sipa> @quote sipa
09:59:18 <lambdabot> sipa says: asking for experts before asking your questions prevents non-experts who know the answer as well from answering
09:59:57 <nwf> Er, I didn't mean to ask-to-ask; I had hoped that the hpaste title carried enough of the question.
10:00:39 <nwf> In any case, I am trying to write the "closed interpreter" from Oleg's finally-tagless work using a HOAS embedding.
10:01:30 <nwf> It's not going well.  I think I understand why I can't write the equation for HOAS lambdas, but I would either like confirmation that it isn't possible or for somebody to illuminate me. :)
10:03:08 <danr> > deriv (x * x * x)
10:03:09 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
10:03:09 <lambdabot>                        ...
10:03:21 <danr> > deriv (x * x * x) x
10:03:22 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
10:03:22 <lambdabot>                        ...
10:03:47 <copumpkin> > deriv (\x -> x * x * x) x
10:03:48 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
10:03:49 <danr> > deriv (\x -> x * x * x) x
10:03:50 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
10:03:54 <danr> copumpkin: ^^ thanks
10:03:57 <copumpkin> :)
10:04:01 -ujihisa(~ujihisa@s66-183-19-128.bc.hsia.telus.net)- import Data.Number.Dif (deriv)
10:04:01 -ujihisa(~ujihisa@s66-183-19-128.bc.hsia.telus.net)- main = print $ deriv (min (*2) (/2)) (-1)
10:04:11 -ujihisa(~ujihisa@s66-183-19-128.bc.hsia.telus.net)-     No instance for (Ord
10:04:11 -ujihisa(~ujihisa@s66-183-19-128.bc.hsia.telus.net)-                        (Data.Number.Dif.Dif a0 -> Data.Number.Dif.Dif a0))
10:04:11 -ujihisa(~ujihisa@s66-183-19-128.bc.hsia.telus.net)-       arising from a use of `min'
10:04:13 <ujihisa> hmm...
10:04:17 <NemesisD> anyone know how i can found out what versions of glibc different versions of GHC require?
10:04:41 <NemesisD> my deploy environment has glibc 2.5 and i've been told that does not jive with ghc 7
10:07:05 <NemesisD> all the download pages for GHC just say they aren't sure what the minimum libc version is :/
10:10:01 <Saizan> nwf: maybe if you make HOAS take another type parameter for variables you can then make it work, i.e. class HOAS repr v where hv :: v a -> repr a; ha :: repr (a -> b) -> repr a -> repr b; hl :: (v a -> repr b) -> repr (a -> b)
10:10:42 * hackagebot tagsoup-parsec 0.0.8 - Tokenizes Tag, so [ Tag ] can be used as parser input.  http://hackage.haskell.org/package/tagsoup-parsec-0.0.8 (OzgunAtaman)
10:10:44 * hackagebot shpider 0.2.1.1 - Web automation library in Haskell.  http://hackage.haskell.org/package/shpider-0.2.1.1 (OzgunAtaman)
10:15:54 <nwf> Saizan: Intriguing!  It type checks... let's see if it actually works.
10:16:45 <Saizan> how does the code look now?
10:16:55 <EvanR-work> i run cabal install cabal-install, then cabal update says theres a new version out, install it
10:17:04 <EvanR-work> because its not installing into the system wide cabal?
10:18:29 <hpaste> nwf pasted “Stab two at HOAS, on a suggestion of Saizan” at http://hpaste.org/54666
10:18:31 <nwf> Saizan: Well, while it typechecks, I can't write things like "CHL $ hl id" since it can't deduce (correctly) that "v ~ repr".
10:19:39 <Saizan> nwf: you'd have to write CHL $ hl hv
10:19:51 <nwf> hv?
10:19:59 <nwf> Ah, I missed that in your suggestion.
10:21:26 <EvanR-work> cabal: cannot configure network-bytestring-0.1.3.4. It requires network
10:21:28 <EvanR-work> >=2.2.1.1 && <2.3
10:21:30 <EvanR-work> :(
10:22:22 <copumpkin> yay
10:22:33 <c_wraith> network 2.3 included the functionality from network-bytestring
10:22:51 <c_wraith> it really doesn't make sense to build network-bytestring against later versions of network
10:22:54 <EvanR-work> im trying to install package dns on an old haskell installation
10:23:06 <EvanR-work> and its barfing
10:24:28 <EvanR-work> is there a way to update the system-wide ghc stuff?
10:25:24 <hpc> EvanR-work: cabal update as root?
10:25:40 <EvanR-work> i tried sudo
10:25:44 <nwf> EvanR-work: What distribution are you running?
10:25:50 <EvanR-work> failbuntu
10:26:09 <nwf> Heh!  Are the packages in the apt repos too stale?
10:26:24 <EvanR-work> when this was installed, there were no haskell packages in apt
10:26:41 <hpc> EvanR-work: then you should probably reinstall ubuntu lol
10:26:43 <nwf> You might try transitioning to them?
10:26:50 <EvanR-work> >_<
10:27:12 <hpc> EvanR-work: afaik, your version is totally out of the support window
10:27:15 <hpc> if it's that old
10:27:25 <monochrom> please don't hold it against ubuntu. few linux distros provide good haskell packages at all
10:27:31 <EvanR-work> so what do i do, deleted ghc, then apt-get something?
10:27:42 <EvanR-work> monochrom: im find with just haskell platform
10:28:04 <monochrom> but what do you already have and what do you want to change? please be exact.
10:28:29 <EvanR-work> ghc-6.12.1
10:28:32 <EvanR-work> Cabal-1.8.0.2
10:28:38 <EvanR-work> i just want to install dns
10:28:40 <monochrom> obtained from where?
10:28:51 <EvanR-work> probably from haskell platform over a year ago
10:29:15 <monochrom> no, I mean as in from ubuntu's "universe" or from someone's PPA or... ?
10:29:23 <EvanR-work> neither
10:29:26 <monochrom> you see why it's ambiguous
10:29:37 <EvanR-work> its not from anything as far as i know
10:29:43 <EvanR-work> haskell platform
10:30:20 <gavri> is there a way to use hoogle or anything else to search for functions based on implementation? for example, "(not . null)" or "\xs -> length xs == 1"
10:31:25 <monochrom> must you stick with ghc-6.12.1?
10:31:27 <hpc> gavri: doubt it
10:31:36 <EvanR-work> monochrom: no
10:31:56 <EvanR-work> ill upgrade the whole haskell thing if necessary
10:32:31 <monochrom> yeah, get ghc-7.0.4.
10:32:35 <Sebasti0n> Does anybody know why the latest deepseq version does not include an intmap instance?
10:32:53 <monochrom> not from ubuntu, of course. from "nowhere", the way you put it.
10:33:16 * monochrom still doesn't believe in "from nowhere"
10:34:57 <NemesisD> does anyone use ghc-parmake? is it any good?
10:35:31 <gavri> does anyone know of any functions in the standard libraries that are implementations of "(not . null)" or "\xs -> length xs == 1"?
10:35:33 <EvanR-work> monochrom: from google haskell platform
10:35:44 <EvanR-work> alright, so im going to reinstall haskell
10:36:26 <monochrom> and of course depending on where you got the old ghc and what's in PATH and how you install the new ghc etc etc, even after you install new ghc, when you enter "ghc" at the command line it may still refer to the old one.
10:36:43 <monochrom> and so "don't know, don't care" will not exactly work
10:36:53 <EvanR-work> yeah im going to have to eliminate the current installation
10:36:55 <monochrom> and yes, being a sysadmin is not trivial
10:37:17 <sefb1704> Hello :)
10:37:51 <ddarius> Sysadmins don't normally deal with installing development tools.
10:38:11 <EvanR-work> monochrom: it wont refer to the wrong ghc because i will rm /usr/bin/ghc ;)
10:38:23 <EvanR-work> drag and drop into the trash
10:38:26 <gwern> @quote
10:38:26 <lambdabot> AlanPerlis says: We will never run out of things to program as long as there is a single program around.
10:39:10 <monochrom> "/usr/bin/ghc" suggests a high probability that you got it from ubuntu or someone's PPA
10:39:50 <EvanR-work> the guy who installed it doesnt work here anymore
10:39:50 <hpaste> sefb1704 pasted “small problem” at http://hpaste.org/54667
10:40:39 <ddarius> EvanR-work: Should have just stuck with Java.
10:40:49 <EvanR-work> lol.
10:41:00 <EvanR-work> we did, *points at PHP5*
10:41:14 <ddarius> Last I checked, PHP was not Java.
10:41:35 <EvanR-work> yeah, its java now
10:41:58 <ddarius> Luckily that doesn't really change much for me.  I dislike PHP and Java.
10:42:05 * monochrom regrets getting into this.
10:42:08 <EvanR-work> lol
10:42:41 <EvanR-work> if i remember correctly ubuntu doesnt have a package search command or a package list
10:43:10 <ddarius> Ubuntu uses apt.
10:43:21 <EvanR-work> does apt have a package search now?
10:43:35 <ddarius> Hell if I know.  I always use Synaptic which does.
10:43:37 <Sebasti0n> sefb1704: look at take and drop, those will help
10:43:38 <EvanR-work> lol
10:43:40 <EvanR-work> yeah
10:43:55 * EvanR-work proceeds to x11 ssh synaptic
10:43:56 <monochrom> aptitude, synaptic, dpkg-query
10:44:22 <Botje> sefb1704: you called stride with only one parameter.
10:44:34 <Botje> sefb1704: also, you will not get there like that.
10:44:52 <Botje> sefb1704: because xy is not being updated in the list comprehension, as I guess you think it is
10:45:37 <EvanR-work> ah aptitude
10:47:38 <EvanR-work> ghc6 is installed
10:48:04 <sefb1704> Botje: okey damn. let me look at this for some minuetes maybe i get the solution
10:51:52 <sefb1704> hm
10:52:12 <EvanR-work> i removed ghc6 stuff from ubuntu
10:52:18 <EvanR-work> now what
10:53:07 <lukish> @pointless reverse
10:53:07 <lambdabot> reverse
10:53:33 <EvanR-work> reverse . reverse is pointless!
10:53:37 <sefb1704> Sebasti0n: my new try: stride n xs = [x:[] | x <- [0..n], drop x xs] ++ stride xs  -- gives an error about dismatch of bool and [a0] ?? where is the bool ? :D
10:53:57 <Botje> in the 'drop x xs' part.
10:54:00 <ddarius> reverse . reverse <= id
10:54:20 <EvanR-work> error no Ord instance for a -> a
10:54:38 <Botje> sefb1704: a list comprehension is probably not the way to go.
10:55:00 <sefb1704> Botje: ok. but i think this is the task.. ok new try : stride n xs = [x:[] | a <- [0..n], x <- (drop a xs)] ++ stride xs
10:55:42 <sefb1704> Botje: sorry for overusing "ok" ^^
10:56:13 <hpc> sefb1704: not enough arguments to the recursive call
10:56:20 <hpc> "stride n xs" vs "stride xs"
10:56:35 <sefb1704> hpc: ow. okey i got this! :D
10:57:23 <EvanR-work> ubuntu 10.04... checks to see the animal for that
10:57:26 <sefb1704> noo endless loop
10:58:11 <EvanR-work> lucid lynx, no haskell platform or ghc7
10:58:34 <Botje> sefb1704: what did you expect? you're using calling stride using the exact same arguments
10:58:58 <sefb1704> Botje: but why isnt pattern matching stopping this?
10:59:06 <sefb1704> > stride _ [] = [] > stride n xs = [x:[] | a <- [0..n], x <- (drop a xs)] ++ stride n xs
10:59:07 <lambdabot>   <no location info>: parse error on input `='
11:00:01 <lukish> How can I write f :: Integer -> Integer, when f 123 == 321. Without convert to chars ('digitToInt . show' or smth)?
11:01:19 <hpc> > let f 123 = 321 in f 123
11:01:20 <lambdabot>   321
11:01:45 <jessopher> is there any way to write two instances, for the same class that take the form instance Const1 a => Class a ... instance Const2 => Class a ... GHC says they are 'duplicate instances'
11:01:54 <EvanR-work> its just like bitreversal, only digits
11:02:14 <monochrom> I don't know why you don't want to go through Chars. it's the easiest way. read. reverse . show
11:02:37 <EvanR-work> yeah, the idea of the function is based on the place value notation anyway
11:03:31 <sefb1704> stride n xs = [x:[] | a <- [0..n], x <- (drop a xs)] ++ stride n (drop n xs)
11:03:50 <jessopher> the heads are identical, but I know that there is no overlap in the constraints (even if its possible)
11:04:18 <mike-burns> lukish: Divide by 10 a bunch.
11:05:10 <jessopher> ... and I have tried applying all instance extensions
11:05:34 <ddarius> jessopher: Type classes are open.
11:05:58 <parcs_> > let f n m  | n == 0 = m | otherwise = f (n `div` 10) (n `mod` 10 + 10 * m); g = (`f` 0) in g 123
11:05:58 <lambdabot>   321
11:06:12 <jessopher> ddarius: i dont understand
11:07:34 <roconnor> A function A -> B gives rise to a natural transformation forall a. (B -> a) -> (A -> a) right?
11:07:47 <roconnor> ... Actually I guess that is pretty obvious now that I write it down.
11:08:02 <hpc> yes
11:08:13 <ddarius> :t flip (.)
11:08:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
11:08:14 <hpc> g h = h . f, for given f
11:08:21 <roconnor> this is part of the Yondea lemma?
11:08:42 <ddarius> It's the Yoneda embedding.
11:08:47 <ddarius> (One of them.)
11:08:54 <ddarius> But it's just the hom-functor partially applied.
11:08:56 * roconnor finds it annoying that the natural transformation goes backwards
11:09:39 <ddarius> There's a covariant version.
11:09:53 * jessopher thinks maybe that meant to try type class extensions
11:10:29 <ddarius> jessopher: It means the implementation can't assume that there aren't instances.
11:11:11 <sefb1704> Botje: [x:ys | a <- [0..n], x <- (xs !! a)] where ys= [] why cant i compile this? from my point of view this should totally do what i want
11:11:43 <monochrom> what is xs?
11:11:46 <EvanR-work> looks like i dont need haskell platform, ghc7 comes with everything i need
11:12:04 <ddarius> EvanR-work: Few people need the Haskell Platform.
11:12:08 <ddarius> The Haskell Platform isn't about needs.
11:12:27 <EvanR-work> i thought it was a faster way to install haskell and cabal
11:12:31 <hpaste> sefb1704 pasted “my problem” at http://hpaste.org/54668
11:12:39 <ddarius> EvanR-work: It is just a list of libraries.
11:12:57 <EvanR-work> cabal has always come with ghc binary package?
11:13:23 <ddarius> EvanR-work: No.  cabal-install doesn't come with GHC.
11:13:47 <EvanR-work> oh, but it comes with haskell platform
11:13:48 <ddarius> But I also doubt your DNS package needs OpenGL.
11:14:24 <sefb1704> monochrom: i pasted my code
11:14:26 <companion_cube> if you just take ghc, do you have network and threads ?
11:14:32 <monochrom> s/x <- (xs !! a)/let x = xs !! a/
11:14:35 <jessopher> ddarius: ok, understood
11:14:39 <sefb1704> monochrom: i forgot this line:  stride _ [] = []
11:15:08 <EvanR-work> companion_cube: it doesnt come with network
11:15:31 <monochrom> ghc doesn't come with network but has threads
11:15:42 <companion_cube> ok
11:15:44 <mike-burns> HP is pretty nice for generally hacking on Haskell.
11:15:44 <sefb1704> monochrom: uff .. is this / a lambda to declare a new function?
11:15:49 <mike-burns> Or with Haskell.
11:15:54 <mike-burns> Or under Haskell.
11:16:12 <EvanR-work> based out of haskell
11:16:13 <monochrom> no, I mean replace x <- (xs !! a) by let x = xs !! a
11:16:21 <ddarius> All you do is install cabal-install manually (if it isn't already installed) then cabal install whatever it is you want to install and that will pull only what you need, rather than half a gig of stuff you don't need.
11:16:23 <hpc> sefb1704: s/something/somethingelse/ is a regex
11:16:56 <hpc> just a silly programming notation that found its way into regular talk
11:17:12 <EvanR-work> dns-0.3.1 failed during the building phase. The exception was: ExitFailure 1 :(
11:17:22 <sefb1704> hpc: ok thanks / thank you :)
11:17:33 <EvanR-work> sefb1704: (its not actually a regex ;)
11:17:49 <hpc> EvanR-work: perl regex, then :P
11:17:56 <EvanR-work> you mean sed?
11:18:05 <hpc> or that
11:18:05 <EvanR-work> er, ed? ;)
11:18:06 <ddarius> hpc: The regex is what goes between the first //.
11:18:14 <hpc> quiet, you
11:18:25 <ddarius> It's a substitution.  I suspect that is where the 's' comes from.
11:19:13 <EvanR-work> Network/DNS/StateBinary.hs:86:1: Type synonym `Parser' should have 1 argument, but has been given none
11:19:14 <sefb1704> oh my god im dying. a <- [0..n], let x = xs !! a gives me an error: out of bounds. when i change it to a <- [0..n-1], let x = xs !! a there is still the error !!!
11:19:20 <EvanR-work> so dns is not worky ?
11:19:54 <EvanR-work> uhg i just installed it
11:19:57 <EvanR-work> on another machine
11:20:28 <roconnor> sefb1704: clearly n isn't the length of xs, or maybe some other operation is out of bounds
11:20:34 <hpc> sefb1704: take a look at concat, map, and concatMap
11:20:41 <hpc> sefb1704: then try starting again with your problem
11:20:42 <ddarius> This is why you don't use (!!) (among other reasons.)
11:20:59 <roconnor> oh there is an hpaste
11:21:49 <sefb1704> hpc: okey i google those words
11:22:08 <hpc> sefb1704: http://haskell.org/hoogle/
11:22:19 <roconnor> haskell would probably be better off if head, tail and (!!) were not in the prelude
11:22:36 <hpaste> Gavri pasted “cabal install postgresql” at http://hpaste.org/54669
11:22:52 <gavri> any idea why I get an ExitFailure there?
11:22:53 <jessopher> what seems to be useful about HP to me, is windows deployment. I know a lot of things wont just build out of the box without manually satisfying non-hackage dependencies
11:22:54 <ddarius> Haskell would be better off if a lot of the functions in the standard libraries just didn't exist.
11:23:14 <hpc> just get rid of the partial functions, i think
11:23:20 <roconnor> and if main had type IO Void
11:23:36 <monochrom> indeed, get rid of (/)
11:23:39 <ddarius> roconnor: That would be annoying.
11:23:40 <Saizan> gavri: PostgreSQL.hsc:12:22: fatal error: libpq-fe.h: No such file or directory
11:23:43 <hpc> monochrom: :P
11:24:15 <c_wraith> when will base get non-broken filepath handling, anyway?
11:24:16 * roconnor demands proper termination of programs!
11:24:25 <dolio> You need to give an exit code.
11:24:29 <hpc> it would be fun to have a type family for division
11:24:33 <gavri> Saizan: what does that mean?
11:24:46 <unlink> While we're at it, why don't we add f ... g = \x y -> f (g x y) to the standard library.
11:24:59 <hpc> class Div a where type b; (/) :: a -> a -> b
11:25:16 <sefb1704> hpc: i think i dont need concat in here and map .. im not sure
11:25:26 <Saizan> gavri: that you haven't installed the C postgresql lib on your system and/or its headers, i think
11:25:50 <gavri> Saizan: doh! thanks
11:25:51 <hpc> sefb1704: if you are using a list comprehension, you can definitely replace parts of it with concat/map/concatMap
11:25:56 <sefb1704> hpc: example of what my code is supposed to to: stride 2 "abc" : ["ab", "c"]
11:26:11 <hpc> ah
11:26:18 <gavri> forgot I was on a new machine
11:26:39 <hpc> > let stride n xs = [take n xs, drop n xs] in stride 2 "abc"
11:26:40 <lambdabot>   ["ab","c"]
11:26:40 <sefb1704> hpc: one more example: stride 6 "abc" : ["abc"]
11:26:46 <hpc> > let stride n xs = [take n xs, drop n xs] in stride 6 "abc"
11:26:47 <lambdabot>   ["abc",""]
11:26:56 <hpc> :t take
11:26:57 <lambdabot> forall a. Int -> [a] -> [a]
11:27:46 <monochrom> > break 6 "123456789"
11:27:46 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
11:27:46 <lambdabot>    arising from the literal `6'...
11:27:57 <hpc> :t break
11:27:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:27:58 <monochrom> @type span
11:27:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:28:14 <monochrom> > splitAt 6 "123456789"
11:28:14 <lambdabot>   ("123456","789")
11:28:21 <monochrom> write a recursion over splitAt
11:28:36 <EvanR-work> k dns doesnt work with latest attoparsec
11:28:38 <ddarius> :t groupBy
11:28:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:28:43 <sefb1704> hpc: *** im totally not getting why [take n xs, drop n xs] is already the solution
11:28:46 <EvanR-work> and the deps dont know it
11:28:58 <EvanR-work> i install a few versions ago of attoparsec and it works
11:29:01 <jessopher> let stride n xs = filter(\= []) [take n xs, drop n xs] in stride 6 "abc"
11:29:07 <jessopher> doh
11:29:45 <sefb1704> :'(
11:29:58 <jessopher> > let stride n xs = filter(\= []) [take n xs, drop n xs] in stride 6 "abc"
11:29:59 <lambdabot>   Not in scope: `\='
11:30:09 <roconnor> > let stride n l = takeWhile (not . null) unfoldr (Just . splitAt n) in stride 6 "abc"
11:30:10 <jessopher> well whatever
11:30:10 <lambdabot>   Couldn't match expected type `[[a]]'
11:30:10 <lambdabot>         against inferred type `(b -> D...
11:30:16 <roconnor> > let stride n l = takeWhile (not . null) $ unfoldr (Just . splitAt n) in stride 6 "abc"
11:30:17 <lambdabot>   Couldn't match expected type `[[a]]'
11:30:17 <lambdabot>         against inferred type `[a1] ->...
11:30:27 <ddarius> > let f n = map (map snd) . groupBy ((==)`on`fst) . zip (cycle (replicate n True ++ replicate n False)) in f 2 "abcde"
11:30:29 <lambdabot>   ["ab","cd","e"]
11:30:29 <roconnor> > let stride n = takeWhile (not . null) . unfoldr (Just . splitAt n) in stride 6 "abc"
11:30:30 <lambdabot>   ["abc"]
11:30:48 <roconnor> > let stride n = takeWhile (not . null) . unfoldr (Just . splitAt n) in stride 2 "abcde"
11:30:50 <lambdabot>   ["ab","cd","e"]
11:31:13 <roconnor> @pl \n -> takeWhile (not . null) . unfoldr (Just . splitAt n)
11:31:13 <lambdabot> (takeWhile (not . null) .) . unfoldr . (Just .) . splitAt
11:31:16 * ddarius is aiming for Rube Goldberg.
11:32:15 <jessopher> > let stride n xs = noemptys [take n xs, drop n xs] in stride 6 "abc" where { noemptys [] = []; noemptys ([]:xs) = xs; noemptys (x:xs) = x : (noemptys xs) }
11:32:16 <lambdabot>   <no location info>: parse error on input `where'
11:32:21 <roconnor> > let stride n = takeWhile (not . null) . unfoldr (Just . splitAt n) in stride 0 "abcde"
11:32:23 <lambdabot>   []
11:32:52 <monochrom> move your "where" before "in"
11:32:52 <roconnor> sefb1704: what do you want stride 0 "abc" to do?
11:33:21 <jessopher> segfault
11:33:33 <roconnor> format your hard disk!
11:33:35 <sefb1704> im not sure its not in the examples and not described in the task.. but in the lessons we didnt even have takewhile etc yet ..
11:33:51 <roconnor> sefb1704: better not use my code then
11:33:53 <sefb1704> okey new idea
11:34:00 <sefb1704> > stride _ [] = [] > stride n xs = [[x] | x <- (take n xs)] ++ stride n (drop n xs) >                  where ys = []
11:34:01 <lambdabot>   <no location info>: parse error on input `='
11:34:13 <jessopher> monochrom: yeah, my sleep to not ration is getting dangerously close to NaN
11:34:49 <sefb1704> exept for the error of not being able to compile it this should work fine :)
11:34:51 <jessopher> ratio too
11:35:07 <ddarius> jessopher is an intuitionist.
11:35:26 <sefb1704> LOL
11:35:29 <sefb1704> awesome
11:35:32 <sefb1704> i finally got this
11:35:37 <sefb1704> bahahaha
11:35:46 <monochrom> stride n xs = take n xs : stride n (drop n xs)
11:36:48 <sefb1704> monochrom: okey im thinking about this ..
11:36:54 <monochrom> not sure why first you reinvented take with a type error, then second you used take but wrapped it in a list comprehension just so as to unwrap it, and with a type error again
11:37:30 <monochrom> i.e., why an approach so complicated it has no obvious errors
11:38:28 * jessopher should intuit some [z]
11:38:38 <sefb1704> monochrom: dont ask for logic, im a newbie and dont know what to do, but i get your point ^^
11:38:53 * roconnor thinks stride ought to return a list of non-empty lists.
11:39:25 <roconnor> I wish Conor taught functional programming; without dependent types, all functional programming seems half-hearted.
11:41:57 <monochrom> the type "non-empty list" calling the type "list" half-hearted
11:43:15 <monochrom> if you were truly not half-hearted, you would not settle with "non-empty list" either. you would demand full specification of exactly what's in the list, what length and what items at what positions. full formal specification.
11:45:16 <EvanR-work> then you need a parser to convert the primitive stonage list into a formal list ;)
11:46:47 <jessopher> lists seem like they would have been pretty useful to people who didnt know how to count
11:48:05 <hpaste> mizu_no_oto pasted “pcap” at http://hpaste.org/54671
11:48:09 <mizu_no_oto> I'm getting a result I think is interesting from some simple code with pcap.  AFAIK, the packet should begin with some alpha-numeric identifier, like "B601".  Instead, I'm getting that the packet starts with something like "E��f;	��x�%6G��<��7�B601".  What's going on here?
11:49:24 <monochrom> eh? B601 appears at the end?
11:49:53 <mizu_no_oto> The entire packet is something like "E��f;	��x�%6G��<��7�B6014KR4101F300080140014248 26480000013 26475000015 26470000005 26465000006 26460000013011057 26495000004 26500000049 26505000019 26510000025 265150000500199500010001000200030006013290001002400060007000809000188�"
11:50:02 <mizu_no_oto> It just appears in the middle
11:50:22 <jessopher> well theres a header
11:50:36 <jessopher> possibly
11:50:38 <mizu_no_oto> What's the best way to drop the header?
11:51:20 <jessopher> parse it, several parts of it indicate length for the header of each frame
11:51:50 <jessopher> otherwise you dont want a raw packet
11:53:04 <mizu_no_oto> Is there  good library I should look into for that?
11:54:21 <jessopher> it would depend on what part of the packet you want to be the payload, and what protocols are involved. If you just want the TCP payload, use TCP sockets
11:57:06 <mizu_no_oto> You can see what the code looks like at the moment: http://hpaste.org/54671
11:57:32 <mizu_no_oto> and I just care about the bits at certain locations
11:58:19 <mizu_no_oto> they're all just numbers
12:00:18 <jessopher> is there a pattern to the alpha-numeric starting point that you know of?
12:00:43 <mizu_no_oto> yeah
12:00:54 <mizu_no_oto> e.g. "B6034"
12:01:42 <Eliel> is it possible to define a function that takes a dataconstructor and a value of the same type and return true if the value given was created with that constructor. False otherwise.
12:02:30 <ddarius> Yes.
12:02:41 <jessopher> mizu_no_oto: well an example doesnt say anything about the pattern. if its always B digit digit digit digt, then thats easy enough to match
12:03:34 <Eliel> ddarius: how would you define such a function?
12:04:31 <Eliel> ddarius: or more importantly, is it perhaps defined already?
12:04:33 <mizu_no_oto> There's only a few things, and they're all B digit digit digit
12:04:56 <mizu_no_oto> Should I look at parsec or something?
12:04:59 <c_wraith> Eliel: I can't even figure out how type said function.
12:05:03 <ddarius> > let f x y = getConstr x == getConstr y in f (Just undefined) Nothing
12:05:04 <lambdabot>   Not in scope: `getConstr'Not in scope: `getConstr'
12:05:10 <ddarius> @hoogle getConstr
12:05:10 <lambdabot> No results found
12:05:18 <ddarius> @hoogle constr
12:05:18 <lambdabot> Data.Data data Constr
12:05:18 <lambdabot> Data.Data constrFields :: Constr -> [String]
12:05:18 <lambdabot> Data.Data constrFixity :: Constr -> Fixity
12:05:25 <ddarius> @hoogle toConstr
12:05:25 <lambdabot> Data.Data toConstr :: Data a => a -> Constr
12:05:33 <c_wraith> ddarius: that's not the same thing.
12:05:38 <ddarius> > let f x y = toConstr x == toConstr y in f (Just undefined) Nothing
12:05:39 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:05:39 <lambdabot>    `Data.Data.Data a'
12:05:39 <lambdabot>      a...
12:05:42 <jessopher> foo ("B":n1:n2:n3:rest) | and $ map digit [n1,n2,n3] = rest; foo (x:xs) = foo xs
12:05:48 <c_wraith> ddarius: that has x and y having the same type, which is not what Eliel asked about
12:05:57 <ddarius> c_wraith: Eliel's question is rather underspecified.
12:05:58 <jessopher> or similar
12:06:15 <ddarius> c_wraith: "a dataconstructor and a value of the same type"
12:06:55 <c_wraith> it's fully specified if you say "a value of the type the data constructor is for"
12:07:08 <c_wraith> however, it doesn't type
12:07:09 <ddarius> c_wraith: That's not the issue.
12:07:40 <ddarius> There are other ways in which it's underspecified, and that isn't really one of them.
12:08:23 <ddarius> Though arguably the constructor should be, e.g. Just, which has a different type from Nothing taking what Eliel said precisely and literally.
12:08:44 <c_wraith> ddarius: which is exactly why I say the function can't be typed
12:09:09 <ddarius> c_wraith: It could probably still be done, it would just be trickier.
12:09:11 <mauke> String -> a -> Bool
12:09:27 <c_wraith> well, it would involve typeclasses.
12:09:29 <mauke> (Data a) => String -> a -> Bool
12:09:32 <ddarius> c_wraith: Yes.
12:09:41 <rwbarton> Data a is already a type class...
12:09:51 <c_wraith> and at that point, you might as well make the type class what you actually want to do, rather than how you think you want to do it.
12:12:39 <Eliel> ddarius: basically, suppose I have: data Node = A Int Int | B String String | C Double Double and I want to do: filter (isA C)
12:13:15 <mauke> Eliel: what would the type of isA be?
12:13:24 <ddarius> Simply write isA.
12:13:42 <causative> there are really 3 kinds of expressions - types, values, and definitions for types
12:13:54 <ddarius> Better yet, write getA (A x y) = Just (x,y); getA _ = Nothing
12:14:00 <causative> not just types and values
12:14:48 <hpaste> jessopher annotated “pcap” with “pcap (annotation)” at http://hpaste.org/54671#a54672
12:15:25 <Eliel> umm... I think I managed to name that in a way that causes misunderstanding of it's purpose. The A in isA is not supposed to refer to the constructor A but rather "isA C" is supposed to read like "is a C"
12:15:46 <mauke> Eliel: what would the type of isA be?
12:16:56 <rwbarton> you could also write [ x | x@C {} <- xs ] for "filter (isA C) xs"
12:16:59 <Eliel> mauke: isA :: (a -> b) -> b -> Bool ?
12:17:19 <c_wraith> Eliel: that only works for one-arg data constructors
12:17:20 <mauke> Eliel: that wouldn't work in your case
12:17:34 <mauke> Eliel: b = Double -> Node
12:18:04 <mauke> rwbarton: yes, that's why I used it
12:18:52 <mauke> make that (Data a) => Constr -> a -> Bool
12:20:04 <mauke> @pl \c x -> c == toConstr x
12:20:04 <lambdabot> (. toConstr) . (==)
12:25:02 <Eliel> mauke: trying to evaluate ((. toConstr) . (==)) Just Nothing in ghci results in a type error.
12:25:54 <Eliel> same for the lambda form.
12:26:07 <lukish> @pointfree (\(x,y) -> x == y)
12:26:07 <lambdabot> Unknown command, try @list
12:26:16 <lukish> @pl (\(x,y) -> x == y)
12:26:16 <lambdabot> uncurry (==)
12:26:22 <lukish> Lol
12:29:23 <lukish> How can I find number of elements equal to n in list? f 1 [1,2,3,1,4,1] == 3?
12:29:36 <lukish> Length . filter is long, I think.
12:29:52 <mauke> Eliel: let isa c x = c == toConstr x
12:29:57 <mauke> Eliel: isa (toConstr (Just ())) (Nothing :: Maybe String)
12:30:14 <mauke> @hoogle [a] -> a -> Int
12:30:15 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:30:15 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
12:30:15 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:30:20 <alistra> @pl length . filter (=5)
12:30:20 <lambdabot> (line 1, column 18):
12:30:20 <lambdabot> unexpected "="
12:30:20 <lambdabot> expecting lambda abstraction or expression
12:30:27 <alistra> @unpl length . filter (=5)
12:30:27 <lambdabot>  Parse error at "=5)" (column 18)
12:30:34 <alistra> @unpl (length . filter (=5))
12:30:34 <lambdabot>  Parse error at "=5))" (column 19)
12:30:44 <mauke> alistra: you are now failing manually
12:31:06 <alistra> @unpl (length . filter (==5))
12:31:06 <lambdabot> (\ d -> length (filter (\ a -> a == 5) d))
12:31:50 <jessopher> > let f n xs = filter (== n) xs in f 2 [1,2,3,2,5]
12:31:50 <lambdabot>   [2,2]
12:31:57 <jessopher> ah
12:32:05 <alistra> @hoogle count
12:32:06 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
12:32:06 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
12:32:06 <lambdabot> Data.ByteString.Lazy.Char8 count :: Char -> ByteString -> Int64
12:32:09 <jessopher> > let f n xs = length $ filter (== n) xs in f 2 [1,2,3,2,5]
12:32:09 <lambdabot>   2
12:32:24 <lukish> length . filter
12:32:27 <lukish> GREAT
12:32:33 <mauke> lukish: length/filter is probably the best way
12:32:43 <alistra> @hoogle Eq a => [a] -> a -> Int
12:32:44 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
12:32:44 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
12:32:44 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:32:49 <lukish> Why should I pass through the list 2 times
12:33:22 <mauke> why do you think you're doing two passes?
12:33:30 <alistra> lazy is crazy
12:33:34 <alistra> the rule of thumb
12:33:42 <EvanR-work> doing half as much work, twice!
12:34:01 <jessopher> @pl (\n xs -> length $ filter (== n) xs)
12:34:02 <lambdabot> (length .) . filter . (==)
12:34:02 <alistra> @hoogle Eq a => [a] -> a -> Integer
12:34:02 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
12:34:02 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:34:02 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:34:05 <lukish> mauke: filter is 1 passing, length is another
12:34:09 <mauke> lukish: no
12:34:09 <lukish> Am I wrong?
12:34:25 <mauke> first off, "normal" lazy evaluation means the passes are interleaved
12:34:50 <mauke> second, I'd expect list fusion to kick in here
12:35:09 <alistra> of course ghc --make -O
12:35:13 <alistra> or it didn't happen
12:35:15 <xenocryst> ls
12:35:19 <xenocryst> whoops! Wrong window
12:35:29 <hpc> [sudo] password for xenocryst:
12:35:33 <jessopher> ./ ../
12:35:45 <alistra> xenocryst: Desktop Porn my_first_gay_experience.txt
12:35:54 <jessopher> ha
12:35:57 <hpc> lol
12:36:11 <xenocryst> :)
12:36:18 * jessopher wonders if its an asciidoc novel
12:36:33 <alistra> more my_first_gay_experience.txt
12:36:52 <alistra> dear diary, today i've met the most wonderful boy at school
12:36:53 <alistra> --More--(1%)
12:36:58 <hpc> alistra: tail -f :P
12:37:03 <lukish> I don't get how it could be optimized in one list passing/
12:37:12 <wires> reset ^C ^C ^C exit exit exit
12:37:14 <alistra> hpc: is it happening right now?
12:37:35 <alistra> hpc: i lold when i found out that there is a tailf program
12:37:42 <pantouffe> hello everyone, is there any good mathematica graphs library in Haskell? could you name some pls .
12:38:05 <wires> pantouffe, what do you mean, mathematica?
12:38:07 <cheater> pantouffe: there's matplotlib for python.
12:38:12 <cheater> wires: mathematical.
12:38:13 <alistra> lukish: the life will find a way
12:38:18 <alistra> s/life/ghc optimizer/
12:38:25 <wires> cheater, ah :) indeed
12:38:27 <hpc> ooh, tailf is cool
12:38:44 <pantouffe> mathemtical graphs, to avoid that someone could understand graphing libraries (like plotting)
12:38:50 <hpc> (the part about it not poking the file again and again)
12:39:16 <wires> tailf <- what about mounting with noatime?
12:39:28 <wires> does that have same effect? guess not..
12:40:04 <hpc> wires: the lack of accesses lets the hard drive spin down, too
12:40:41 <lukish> @pl (\x -> mod x 5 == 1))
12:40:41 <lambdabot> (line 1, column 21):
12:40:41 <lambdabot> unexpected ")"
12:40:41 <lambdabot> expecting variable, "(", operator or end of input
12:40:45 <wires> right
12:40:47 <lukish> @pl (\x -> mod x 5 == 1)
12:40:47 <lambdabot> (1 ==) . flip mod 5
12:42:34 <absence> http://hpaste.org/54674 <- this is a shot at solving a problem where five person lives in different floors of a building, and there are various constraints of who can live near each other, etc. i'm still new at haskell and wonder if there are more concise/elegant ways to express a solution. i've looked into the Maybe monad, All monoid, and non-deterministic computation using the list monad, but they only complicate (maybe i'm using them wrong). any 
12:43:48 <lohengreen> look on the reason of my kick on #gentoo
12:45:03 <lohengreen> look on the reason of my kick on #gentoo
12:47:05 <jessopher> @pl (\n xs -> (counter 0 $ filter (== n) xs) where { counter i [] = i; counter i (x:xs) = counter (succ i) xs } )
12:47:05 <lambdabot> (line 1, column 48):
12:47:05 <lambdabot> unexpected "{"
12:47:05 <lambdabot> expecting variable, "(", operator or ")"
12:48:14 <ddarius> absence: When you have a search space larger than 120 elements other approaches may be more necessary.
12:49:25 <ddarius> Also if you have more data dependencies (though that can probably be made into just a larger search space.)
12:51:33 <absence> ddarius: meaning it's fine as it is, but if there was a lot more data, you'd use other less concise methods to make it efficient?
12:51:50 <petrus> yes
12:52:13 <carpi> can someone please tell me what are all those ".hi" files being created when I compile a haskell program using ghc?
12:52:22 <carpi> are they some sort of intermediate files?
12:52:23 <blackdog> carpi:  haskell-interface
12:52:32 <blackdog> contains type information
12:52:34 <absence> petrus, ddarius: right, thanks :)
12:52:47 <carpi> blackdog: so that is not exactly required while the program is being run?
12:52:57 <jessopher> @pl (\n xs -> let counter n xs = if xs == [] then n else counter (n+1) (tail xs) in (counter 0 $ filter (== n) xs))
12:52:58 <lambdabot> flip flip (fix (const . ap (if' =<< ([] ==)) . (`ap` tail) . (. (1 +)))) . (flip ($ 0) .) . filter . (==)
12:53:11 <jessopher> lol
12:53:29 <jessopher> so elegant
12:53:35 <alistra> so succinct
12:53:40 <alistra> so succint
12:53:51 <blackdog> carpi: nah, it's just for compilation
12:54:00 <alistra> inct*
12:54:03 <dblhelix> jessopher: so.. unreadable? ;-)
12:54:06 <blackdog> you shouldn't need anything but the eventual binary
12:54:25 <jessopher> i dont need no points
12:54:32 <saati> i would be afraid of using something like that, it might summon cthulhu
12:54:47 <carpi> blackdog: thanks for the clarification )
12:54:56 <dblhelix> saati: lol
12:54:58 <petrus> ciao!
12:55:15 <jessopher> im not even sure what monad is being used in there
12:55:30 <mauke> (e ->)
12:55:37 <jessopher> haha
12:55:42 <dblhelix> jessopher: probably the reader monad
12:55:57 <dblhelix> jessopher: instance Monad ((->) a)
12:56:06 <dblhelix> mauke: ah, indeed
12:56:37 <jessopher> :t if'
12:56:37 <lambdabot> Not in scope: `if''
12:59:05 <jessopher> i think that is beyond pointless, and in the realm of point deficient
13:00:02 <carpi> is it proper terminology to call a function an action if it is impure? or are there different terms for impure functions?
13:00:19 <mauke> all functions are pure
13:00:20 <DanBurton> carpi: sort of yes, the former
13:00:21 <ddarius> There aren't impure functions.
13:00:24 <mauke> actions aren't functions
13:00:54 <ClaudiusMaximus> edwardk: i finally got around to trying 'precision' today, as you warned me some time ago it crashes merrily with ghc-7.0.4 - would it be worth my while trying a newer ghc?  i can live with hmpfr and slooooow integers otherwise...
13:01:11 <monochrom> f :: X -> IO Y is a function. f x :: IO Y is an action
13:01:12 <DanBurton> when you have something like IO Int, you call that an IO "action" that produces an int
13:01:53 <shachaf> mauke: Unless they're in (r ->).
13:02:19 <jessopher> y <- f -< x is an action
13:03:03 <ciaranm> an action is where you have a set and a group and they do stuff nicely together
13:03:12 <monochrom> haha
13:03:24 <ddarius> ciaranm: An action is a monoid homomorphism into an endofunction monoid.
13:03:47 * jessopher doesnt think he has ever done that
13:05:53 <Grahack> ddarius: those actions you talk about make me want to stay inactive as much as possible
13:06:55 <ciaranm> Grahack: those are just regular group actions rephrased so only the cool kids can understand them
13:07:49 <ddarius> Monoid actions.
13:08:15 <ddarius> Monoid actions are the bread and butter of large chunks of CS.
13:08:21 <shachaf> An action is anything that you define as an action.
13:08:36 <Grahack> when I was a cool kid, I liked doing some actions with my group of friends (sorry)
13:08:44 <shachaf> For example, a String is an IO action if your interpretation of a String is "print it to stdout".
13:09:16 <mauke> shachaf: that sounds like false
13:10:13 <shachaf> mauke: False as in not true, or as in the language?
13:10:20 <mauke> the latter
13:12:43 <carpi> is there a difference between "f :: IO String" and "f :: IO -> String"?
13:12:56 <jessopher> yes
13:12:57 <shachaf> Yes.
13:13:06 <rwbarton> the latter doesn't make any sense
13:13:07 <carpi> I understnad that the first one performs an action & returns a string
13:13:12 <shachaf> The latter is nonsensical, for one.
13:13:33 <shachaf> carpi: No, the first one declares f as an action that, when executed, gives you a String
13:13:40 <shachaf> It doesn't return anything, because it's not a function.
13:13:57 <rwbarton> more precisely, "IO -> String" is a kind error
13:14:01 <shachaf> (People will sometimes say "it's an IO action that return a String", but that's just a convenient shorthand.)
13:14:50 <FUZxxl> shachaf: Wouldn't you usually remove that arrow? IO String
13:15:28 <mauke> what?
13:15:30 <carpi> and suppose i had something like "f :: a -> IO String".. then i suppose this would be a function .. yes?
13:15:42 <jessopher> usually, you would never put it there in the first place, if you want things to typecheck
13:15:53 <carpi> a fucntion that takes an a and performs an actions that gives a string?
13:16:08 <periodic> you could think of "IO a" being an action.  So something of type "IO a" *is* an action that returns a string.
13:16:15 <EvanR-work> takes a and returns an io action
13:16:48 <periodic> Anyone have any good tips for debugging and figuring out template haskell other than -ddump-splices?
13:17:13 <ciaranm> a -> IO String would have to be a constant function, wouldn't it?
13:17:15 <ddarius> runQ x >>= print
13:17:26 <FUZxxl> periodic: sarcasm $ Don't use TH?
13:17:29 <periodic> -ddump-splices is still showing some stuff that doesn't make total sense to me.  Probably partially because the class it's creating an instance of has some datas as part of it.
13:17:35 <EvanR-work> ciaranm: just use a case typeof x of ;)
13:17:45 <periodic> FUZxxl: Figuring out someone else's TH. :P
13:18:02 <edwardk> ClaudiusMaximus: precision won't really work until i can get copumpkin to figure out the magic way to hook the gc to stop the crashing
13:18:14 <FUZxxl> ciaranm: Not really. You could do evil stuff like reallyUnsfaePtrEquality#
13:18:22 <edwardk> ClaudiusMaximus: i'll try to pin him down when he gets back from florida and make it happen ;)
13:18:39 <ClaudiusMaximus> edwardk: ok cool - anything i can do to help?
13:18:42 <ciaranm> FUZxxl: i live in the nice world where that doesn't exist. and where there's no seq.
13:18:44 <periodic> So, you can make a "data" declaration be inside a class?  What exactly does that do?
13:19:33 <edwardk> ClaudiusMaximus: btw- you _can_ use precision on any ghc version, the problem is the constant cache. so any reference to pi will cause you to crash on the next gc
13:19:39 <FUZxxl> ciaranm: Well, the action you return must be constant. That doesn't mean that the String you get upon execution is
13:19:51 <edwardk> and theoretically some of the mpfr calls may also use such constants
13:19:56 <byorgey> ugh, dist/build/tmp-14939/src/Text/Pandoc/Writers/MediaWiki.hs: hClose: hardware fault (Input/output error)
13:19:59 <FUZxxl> s/must/should
13:20:03 <byorgey> anyone ever seen an error like that?
13:20:21 <edwardk> ClaudiusMaximus: you can probably use it with no crashes if you use integer-simple or don't access anything that uses the constant-cache
13:20:31 <FUZxxl> byorgey: Can you run a fschk on your hdd?
13:20:34 <edwardk> but i haven't gotten around to finishing it since the crashing was such a big deal
13:20:35 <periodic> oh, it's Type Families.
13:20:46 <FUZxxl> hardware fault seems to be somewhat like a broken HDD or FS
13:21:12 <ClaudiusMaximus> edwardk: with integer-gmp i got crashes with "4" in ghci (it'd print the value then segfault)
13:21:20 <byorgey> FUZxxl: maybe... but everything else is working fine, this only happens when I try to install pandoc
13:21:26 <rwbarton> byorgey: check dmesg output if you're on linux?
13:21:31 <byorgey> FUZxxl: anyway, I'm not root on this machine
13:21:47 <FUZxxl> byorgey: hm... that's strange. Do you have any logs?
13:22:04 <edwardk> oh yeah, 'show' also runs afoul of the memory allocation issue ;)
13:22:11 <FUZxxl> Such as, which file was accessed when the hClosed caused a hardware fault.
13:22:37 <byorgey> FUZxxl: only things I see in dmesg are from the firewall and some error about nvidia drivers
13:22:46 <FUZxxl> A damage to your HDD may only affect a small area on th platter's surface
13:22:53 <edwardk> the issue we have is that when you run code under ghci it doesn't run the c++ initializers for what it links in
13:22:54 <FUZxxl> byorgey: As usual...
13:23:01 <mauke> carpi: nothing performs actions
13:23:06 <byorgey> FUZxxl: yes, I suppose that's true
13:23:25 <edwardk> so the hook we rely on when using ghc directly to change out ghc's garbage collector hooks so that they ignore the constant cache doesn't get run from ghci
13:23:36 <FUZxxl> byorgey: Get your admin to run a SMART check and an fsck
13:23:44 <byorgey> FUZxxl: ok
13:23:56 <ClaudiusMaximus> edwardk: multiple fun! - i think i'll stick with hmpfr and 60x slower integers for now, but when you need testers i'll be willing (and hopefully not too busy)
13:24:06 <FUZxxl> hmpf?!?
13:24:13 <rwbarton> byorgey: what stage of the install do you get that error?
13:24:16 <FUZxxl> Isn't that an interjection?
13:24:17 <byorgey> FUZxxl: wait a minute, this is all NFS-mounted anyway =(
13:24:26 <FUZxxl> byorgey: Can you try again on another disk?
13:24:34 <FUZxxl> (USB-disk or ramdisk?)
13:24:38 <byorgey> rwbarton: at the very end, when it's trying to copy files to their final destinations
13:24:40 <FUZxxl> tmp is likely to be a ramdisk
13:24:46 <monochrom> or on the same disk but use another copy of the files
13:25:04 <FUZxxl> monochrom: That might be sufficient, too
13:25:12 <FUZxxl> byorgey: Did you tried changing the loglevel?
13:25:16 <rwbarton> and final destintion = ~byorgey/.ghc/... which is on NFS?
13:25:22 <byorgey> rwbarton: yes
13:25:36 <monochrom> check for disk full and/or disk quota
13:25:39 <byorgey> FUZxxl: I will try that next
13:25:52 <byorgey> monochrom: yeah, I've had trouble with that before, so I already checked
13:26:28 <byorgey> oh, wait a minute, hmm, that could be it
13:26:39 <DukeDave> Can anyone give me a good reason why:
13:26:39 <DukeDave> > read "foo" :: String
13:26:40 <lambdabot>   "*Exception: Prelude.read: no parse
13:26:40 <byorgey> I might not have checked the right thing
13:26:47 <nexion> can a TChan have multiple writers and multiple readers?
13:26:58 <ddarius> foo is not formatted as a String.
13:26:59 <byorgey> DukeDave: foo is not a string.  "foo" is a string.
13:27:08 <byorgey> > read "\"foo\"" :: String
13:27:08 <lambdabot>   "foo"
13:27:11 <ddarius> nexion: Yes.
13:27:12 <DukeDave> ha
13:27:20 <DukeDave> You are wise!
13:27:56 <nexion> what happens if there are multiple readers? will it process the reads in FCFS order?
13:28:01 <DukeDave> Hmm, do I enforce that all strings are stored with "s, just to make a type signature cleaner :|
13:28:25 <ddarius> nexion: Yes, but arguably you don't know what that order is so...
13:28:43 <monochrom> every message goes to at most one reader
13:28:55 <nexion> thanks :)
13:30:57 <EvanR-work> > read "\"\\\"o_O\\\"\"" :: String
13:30:57 <lambdabot>   "\"o_O\""
13:31:20 <EvanR-work> > read (read "\"\\\"o_O\\\"\"" :: String) :: String
13:31:21 <lambdabot>   "o_O"
13:31:30 <EvanR-work> :t fix read
13:31:31 <lambdabot> String
13:31:35 <EvanR-work> o_O
13:31:45 <monochrom> :fix show
13:31:52 <monochrom> :t fix show
13:31:53 <lambdabot> String
13:32:01 * jessopher isnt sure who is issuing the commands anymore
13:32:51 <jessopher> > it
13:32:52 <lambdabot>   Not in scope: `it'
13:36:41 <FUZxxl> > fix show
13:36:42 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:36:46 <FUZxxl> hehe
13:36:55 <mauke> escapism
13:37:51 <d-snp> if I would want to execute an IO() returning function 2 times, and put the result into a list, how should I do that?
13:38:16 <rwbarton> the result ()?
13:38:35 <d-snp> I can't do values <- map [0..3] randomIO -- right?
13:38:49 <d-snp> IO(a) I mean
13:38:53 <rwbarton> IO a
13:38:59 <d-snp> IO a :P
13:38:59 <rwbarton> you can use replicateM
13:39:07 <rwbarton> @type replicateM
13:39:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:39:19 <d-snp> hmm
13:39:43 <d-snp> would it become values <- replicateM 4 randomIO then?
13:40:00 <rwbarton> @type randomIO
13:40:01 <lambdabot> forall a. (Random a) => IO a
13:40:02 <rwbarton> yes
13:40:06 <d-snp> ok cool
13:40:13 <d-snp> is that in prelude?
13:40:23 <d-snp> nvm, jfgi :P
13:41:29 <shachaf> d-snp: You might not want to do that with randomIO, though.
13:42:42 <shachaf> There are other ways of using random numbers that don't require executing IO actions all the time.
13:44:13 <d-snp> shachaf: really?
13:44:28 <mauke> d-snp: http://www.haskell.org/hoogle/
13:44:30 <d-snp> how can getting a random number not be an IO action?
13:44:40 <mauke> d-snp: specify a seed manually
13:44:54 <mauke> d-snp: or execute an IO action once that gives you an infinite list of randoms
13:45:00 <d-snp> hmm
13:45:01 <Jafet> It could be a Random action
13:45:09 <d-snp> but this is actually the seed
13:45:13 <d-snp> for a series of encryptions
13:45:14 <EvanR-work> it could be a very large list
13:45:47 <jessopher> i think infinite implies a certain kind of largeness
13:45:50 * hackagebot fuzzytime 0.7.5.1 - A 'ten past six' style clock  http://hackage.haskell.org/package/fuzzytime-0.7.5.1 (KamilStachowski)
13:46:13 <EvanR-work> jessopher: currently haskell only supports infinite computable lists ;)
13:46:46 <EvanR-work> but really random isnt computable!
13:46:49 <DevHC_> > plural (Noun "") ""
13:46:50 <lambdabot>   Not in scope: `plural'Not in scope: data constructor `Noun'
13:46:55 <DevHC_> DOS U SPEKS ENGRISH?
13:47:01 <jessopher> for certain kinds of random
13:47:14 <jessopher> specifically, the random kinds
13:47:42 <jessopher> but those arent very practical
13:47:44 <Jafet> I prefer non-random random numbers
13:48:07 <jessopher> then the world of random number generation is your oyster
13:48:10 <EvanR-work> i endulge in purely random numbers
13:48:20 <EvanR-work> thats how hardcore i am
13:48:48 * DanBurton doesn't believe in randomness
13:48:56 <DanBurton> everything is seeded :P
13:49:15 <d-snp> data IpAddress = NS.HostAddress | NS.HostAddress6 <-- that's not legal, is there some way to do that?
13:49:15 <EvanR-work> then who seeded god?
13:49:18 * jessopher is more certain of the easterbunny than randomness
13:49:20 <sipa> we need a kind (IO *), so you can have function whose type is randomly generated at run time
13:49:28 <Jafet> forall s. IO s
13:49:31 <d-snp> (NS is a qualified name)
13:49:40 <wlangstroth> EvanR-work: turtles ... all the way down
13:49:44 <jessopher> EvanR: god Sr.
13:49:44 <EvanR-work> lol
13:49:50 <EvanR-work> fix god
13:49:51 <DanBurton> ...a function whose *type* is random? What can you do with a function when you don't even know its type???
13:49:56 <Jafet> d-snp: module NS where data IpAddress = HostAddress | HostAddress6
13:50:06 <d-snp> oh
13:50:10 <rwbarton> most likely d-snp is missing the constructor names?
13:50:10 <d-snp> thanks
13:50:22 <rwbarton> since "HostAddress" is not an IP address
13:50:24 <d-snp> and then use NS.IpAddress everywhere right?
13:50:52 <Jafet> d-snp: encryption without IO http://hpaste.org/54680
13:51:18 <Jafet> Hm, perhaps that's not the best version
13:51:41 <rwbarton> Jafet: that's the encrypted version of the program right?
13:52:01 <monochrom> haha
13:52:25 <tsuraan> I'm trying to install amelie, which requires two packages (stepeval and pgsql-simple) that aren't on hackage.  I could install them by hand, but when I do that they always bring in versions of libraries that are too new for amelie, so then I have to go masking out new versions of packages until I have a set of dependencies that amelie can build with.
13:52:26 <d-snp> lol
13:52:45 <d-snp> hmm, module in the middle of a file isn't allowed.. :P
13:52:48 <tsuraan> is there some way to just tell cabal that the sources for two of amelie's deps are in a certain location, so cabal can bring them in as though there were on hackage?
13:53:21 <EvanR-work> encryption monad
13:53:29 <Jafet> http://hpaste.org/54681
13:55:09 <Jafet> rwbarton: that's the irc edition
13:59:51 <DevHC_> > showHex 1337 ""
13:59:51 <lambdabot>   "539"
13:59:59 <DevHC_> where the fuck is showHex defined? D:
14:00:10 <mauke> @index showHex
14:00:10 <lambdabot> Numeric
14:00:10 <ddarius> @hoogle showHex
14:00:11 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
14:00:30 <DevHC_> LIES !
14:01:06 <DevHC_> nah
14:06:06 <Axman6> :t showIntAtBase
14:06:07 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
14:07:11 <Axman6> > showIntAtBase 2 ((['0'..'9']++['A'..})!!) 1337 ""
14:07:12 <lambdabot>   <no location info>: parse error on input `}'
14:07:18 <Axman6> > showIntAtBase 2 ((['0'..'9']++['A'..])!!) 1337 ""
14:07:19 <lambdabot>   "10100111001"
14:07:26 <d-snp> could I somehow do something like this: data IpAddress = HostAddress | HostAddress6
14:07:33 <Axman6> > showIntAtBase 32 ((['0'..'9']++['A'..])!!) 1337 ""
14:07:34 <lambdabot>   "19P"
14:07:51 <d-snp> the line compiles, but when I try to use it it says it encountered actual type HostAddress when it expected IpAddress.
14:08:14 <Axman6> d-snp: are you using HostName as a type or a value?
14:08:22 <ocharles> I have a root directory with "src" and "tests" directories. How would I start ghci so that it can see modules in both directories?
14:08:23 <d-snp> a type
14:08:32 <Axman6> foo :: HostNAme -> bar won't compile because Hostname is a type
14:08:35 <Axman6> uh, a value*
14:08:38 <ocharles> I tried running ghci -isrc -itests, but :m + Test.Foo doesn't find the module correctly
14:08:42 <ocharles> (assume Test.Foo does exist)
14:08:48 <Axman6> d-snp: the type of HostNAme is IpAddress
14:09:19 <d-snp> eh it's HostAddress btw, but the type of HostName apparently is not IpAddress
14:09:39 <monochrom> do you know what "data X = Y | Z" means?
14:09:42 <Axman6> well, it is, you've defined it to be
14:09:50 <jessopher> how are you using it d-snp
14:11:14 <Axman6> d-snp: data Foo = Bar | Baz says that the type Foo has the values Bar and Baz. so Bar and Baz have type Foo
14:11:19 <d-snp> http://pastie.org/2941160
14:11:57 <monochrom> "type"?!
14:12:12 <d-snp> argh sorry experiment
14:12:22 <Axman6> yeah that doesn't make any sense. it should be data
14:12:37 <Axman6> I assume you didn't define NS.SockAddr?
14:12:46 <monochrom> you completely screw up what "data X = Y | Z" means
14:12:59 <jessopher> and what type is capable of
14:13:07 <d-snp> http://pastie.org/2941167
14:13:52 <Axman6> d-snp: go look at the definition for NS.SockAddr and you'll see that what the types of the things inside the constructor are
14:13:55 <hpaste> monochrom pasted “the meaning of data” at http://hpaste.org/54682
14:13:57 <jessopher> i think you want data IpAddress = HA HostAddress | H6 HostAddress6, or some variant
14:14:42 <d-snp> HA, H6?
14:14:57 <jessopher> those are the constructors
14:15:02 <d-snp> ohh
14:15:10 <jessopher> you cant have data types without constructors
14:15:13 <d-snp> but they are aliases
14:15:22 <Axman6> no, they're not
14:15:26 <jessopher> you cant do OR aliases
14:15:29 <d-snp> for Word32, and (Word32, Word32, Word32, Word32]
14:15:30 <d-snp> )
14:15:35 <d-snp> right?
14:15:42 <monochrom> no such thing
14:15:45 <jessopher> not relevant
14:15:45 <Axman6> d-snp: if that's what you want them to mean, you have to say that
14:15:56 <Axman6> which I don't think you can
14:16:17 <d-snp> type HostAddress = Word32 <-- this means Word32 is the constructor right?
14:16:23 <monochrom> no
14:16:28 <Axman6> anyway, i think what you're trying to do is return two different things with different types, but try and make your program believe that's ok?
14:16:42 <d-snp> yes..
14:16:56 <d-snp> is that silly?
14:17:40 <Axman6> somewhat
14:17:43 <monochrom> not silly in dependent types or utterly untyped
14:17:54 <jessopher> its not haskell, either way
14:17:58 <d-snp> hmm
14:18:05 <d-snp> how inconvenient :(
14:18:32 <Axman6> but, the way you do it is with something like what jessopher said earlier: data IpAddress = HA HostAddress | H6 HastAddress6
14:18:58 <Axman6> d-snp: not at all, it makes sure your program is well typed, and makes you write programs that don't crash
14:18:59 <monochrom> and also my http://hpaste.org/54682
14:20:21 <d-snp> made it into this: http://pastie.org/2941204
14:20:33 <d-snp> this will do I guess :P
14:20:44 <d-snp> thanks guys
14:21:14 <d-snp> ah it's exactly what monochrom suggested, thanks :)
14:23:33 <d-snp> the algebraic types make extracting the value so cumbersome
14:24:05 <Axman6> eh? just use pattern amtching o.O
14:24:15 <jessopher> cumbers make more sense with a static type system though
14:24:50 <olsner> d-snp: you could use _ instead of flow and scope since you don't use their values
14:24:59 <olsner> several characters shorter :P
14:25:11 <EvanR-work> d-snp: why do you want to extract the value ;)
14:25:13 <jessopher> save you some cumbers
14:25:32 <EvanR-work> use the value as is, like maybe and fromMaybe
14:25:57 <EvanR-work> and either
14:26:37 <jessopher> type IpAddress = Dynamic
14:26:52 <monochrom> dynamic IP? that's a pun
14:26:59 <jessopher> lel
14:27:50 <monochrom> anyway yeah I don't understand what's so inconvenient and cumbersome and extracting the value.
14:28:00 <monochrom> extract the value for what purpose?
14:29:04 <hpaste> d-snp pasted “Ord” at http://hpaste.org/54683
14:29:20 <d-snp> why does the value need to implement Ord too?
14:29:36 <jessopher> because you are doing it wrong
14:29:45 <monochrom> presumably you have an IP address and it could be v4 or v6? presumably v4 and v6 require somewhat different handling even though analogous? I mean for Christ's sake they don't even have the same number of bits.
14:29:48 <Axman6> we'd need to see youe code to tell you
14:31:35 <monochrom> so why is the distinction between the data constructors IPv4 and IPv6 inconvenient and cumbersome? I would say they help! you do a pattern-match, if it's IPv4 then you know the right functions to call, if it's IPv6 then you know the right functions to call. how could that hurt?
14:32:35 <Axman6> d-snp: you have to remember that IPv4 addresses and IPv6 addresses are completely different things. there's no way you could substitute one for the other
14:34:01 <monochrom> Map wants keys to be Ord, yes
14:34:18 <monochrom> data IpAddress = ... deriving Ord
14:34:35 <monochrom> but there is nothing you can do about the Chan part.
14:35:07 <d-snp> no.. but Data.Map says the value doesn't have to be Ord
14:35:17 <d-snp> ehm
14:35:18 <d-snp> hm
14:35:23 <d-snp> mmaybe I made a syntax error
14:40:41 <jessopher> the keys atleast have to be ordinal, and if you are doing ordinal comparison of the maps, then everything has to be ordinal
14:42:19 <d-snp> http://pastie.org/2941310 <--
14:42:27 <d-snp> I'm not doing an ordinal comparison
14:42:32 <d-snp> I don't get why it has to be ordinal..
14:43:24 <monochrom> Map.lookup channels
14:44:02 <monochrom> that makes channels a key
14:44:21 <d-snp> argh
14:44:26 <d-snp> it goes from k to channels..
14:44:34 <d-snp> man that's so counterintuitive :(
14:45:07 <monochrom> Map.lookup destination channels
14:45:38 <dmwit> It's intuitive to me.
14:45:51 <dmwit> From which I conclude that "intuitive" is a meaningless term.
14:45:52 <blackdog> d-snp: it's a bit of a weird one. usually the order's to support currying, but you'd think that you're much more likely to look up a variety of keys in a single map than you are to look up the same key in a bunch of maps.
14:47:09 <blackdog> dmwit: the pattern imperative programmers are used to would be the [] notation, so dict[key]
14:47:11 <ocharles> It's also the same order as Prelude.lookup
14:47:35 <d-snp> I'm totally in the ask everything in this channel mode.. apparently I'm messing up in the case too, it says it doesn't return ()
14:48:39 <d-snp> or rather it does, but it expects IO(a0).., why would it do that :P
14:49:19 <jessopher> d-snp: you didnt pass writeChan the channel
14:49:37 <monochrom> withMVar (instances stack) (maybe (return ()) (\c -> writeChan c message) Map.lookup destination)
14:49:42 <d-snp> oh lol
14:49:45 <d-snp> man I'm so sloppy
14:49:55 <monochrom> if you write like that, you are really thankful for the current order of parameters of Map.lookup
14:49:59 <d-snp> I'll stop bugging you now, it's all my sloppiness
14:50:10 <monochrom> in fact now you also regret the current order of parameters of writeChan.
14:50:51 <monochrom> anyway Map.lookup insert delete etc have exactly the right order of parameters when I combine them with modifyMVar etc
14:51:00 <ddarius> dmwit: That is so 3.
14:51:29 <d-snp> woah monochrom, I'm not worthy of such oneliners yet I think :P
14:51:41 <dmwit> 3?
14:51:42 <d-snp> this is my first haskell application, I'm already in too deep
14:51:58 <ddarius> dmwit: You heard me.
14:56:22 <d-snp> lol, for some reason I totally don't get the . composition, everytime I use it I do it wrong and replace it with $ or braces..
14:56:33 <jessopher> d-snp: haskells learning curve is pretty much straight up, if you compare your approach to haskell to wiley coyote, you have the batsuit and the rocket skates on right now, and you are at the edge of a cliff.
14:56:48 <d-snp> :P
14:57:09 <d-snp> well, I have learned basic functional programming at university
14:57:23 <d-snp> which was taught in a miranda clone
14:57:38 <ddarius> Haskell?
14:57:38 <d-snp> but it's still a lot to learn
14:57:46 <jessopher> well then maybe just the rocket skates
14:57:46 <d-snp> a miranda clone other than haskell ;)
14:57:58 <d-snp> it had stream based io instead of monadic :)
14:58:09 <ddarius> So did Haskell.
14:58:46 <d-snp> yeah, I'm writing a report about stream based i/o in haskell actually :P
14:58:55 <d-snp> all this code is part of it..
14:58:57 <chrisdone> added Context in IRC link on pastes associated with a channel logged by tunes.org. more to add later for expanding the logs shown, but it's a good start
14:58:57 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:03:43 <shurikas> how to combine case with guard?
15:03:53 <shurikas> where guard comes after case
15:04:46 <monochrom> > case 5 of x | x/=5 -> "no" | x==5 -> "yes"
15:04:47 <lambdabot>   "yes"
15:05:07 <shurikas> ohh
15:05:08 <shurikas> thank you
15:05:25 <monochrom> > case Just 5 of Nothing -> "nothing" ; Just x | x/=5 -> "no" | x==5 -> "yes"
15:05:26 <lambdabot>   "yes"
15:05:32 <d-snp> jay it compiles again!
15:06:29 <hpaste> Sebasti0n pasted “Mvar Problem” at http://hpaste.org/54684
15:06:51 <ddarius> Who's Jay?
15:07:13 <monochrom> jay is a happy person
15:07:40 <chrisdone> likeso http://hpaste.org/irc/haskell/2011-11-29/15-07-13/54684
15:08:02 <Sebasti0n> I have a problem with an MVar, once the iC channel is empty and the flag signals the end of the preceeding filter the mvar clu is empty
15:08:31 <Sebasti0n> It should not be empty as I (for now) reinsert the s I take out
15:08:39 <Sebasti0n> can anybody spot the error?
15:09:59 <Sebasti0n> when I run the program with two cores the mvar isn't empty at the end
15:10:50 <Axman6> Sebasti0n: don't use isEmptyMVar, it's not safe to use (it may be full when you call it, but the MVar may be empty when you try to read from it right afterwards)
15:11:31 <c_wraith> isEmptyMVar will also deadlock if another thread is blocked in takeMVar
15:11:41 <c_wraith> really, it shouldn't exist
15:11:42 <Axman6> really?
15:11:57 <Axman6> yeah,. it should have warned you when you compiled the code
15:12:42 <Axman6> if you need the functionality, use with tryTakeMVar (i think that's what it's called, the one that returns Maybe) or use STM
15:12:42 <c_wraith> tryTakeMVar is the correct approach
15:13:32 <Axman6> hmm, it's not poossible to implement MVars using IVars without busy waiting is it?
15:13:39 <Axman6> possible*
15:13:51 <Sebasti0n> the mvar is only accessed by one thread as long as the thread is running
15:14:13 <Axman6> Sebasti0n: still, as general advice, don't use it
15:14:20 <Sebasti0n> ok
15:14:36 <c_wraith> tryTakeMVar is a better solution anyway
15:14:43 <Axman6> yeah
15:17:27 <Sebasti0n> Maybe my whole approach is wrong. I have a producer and consumer thread but i want the consumer to stop once the consumer has pushed everything in the connecting channel and has quit. so i check an mvar flag to signal the end of the producer and let the consumer stop after a final check for more data in the input channel. is that ok to do or do you guys have a better way?
15:18:23 <Axman6> just use a Chan of Maybe a, and stop once you read a Nothing value
15:19:39 <Sebasti0n> that is actually much better
15:20:31 <Sebasti0n> I came up with the mvar approach as my main thread keeps a list of mvars of all subthread in order to know when they are done
15:21:52 <Sebasti0n> thanx for your help though!
15:22:20 <monochrom> with STM you have a multiplexing option too
15:25:11 <Sebasti0n> I haven't looked at stms yet as what I have are not really transactions
15:25:59 <Sebasti0n> but I will have a look and see if I can put them to use in my scenario
15:26:12 <tnks> is there a canonical example of an applicative functor that isn't a monad?
15:26:56 <tnks> or rather can't have a monad constructed around it.
15:29:51 <dmwit> tnks: ZipList
15:29:53 <hpc> tnks: ZipList
15:30:06 <tnks> dmwit: hpc: thanks.
15:30:25 <tnks> it helps to have something concrete.
15:35:19 <conal> Does anyone know where the Functor instance for (->) a is (what module to import)?
15:35:29 <dmwit> Control.Monad.Instances
15:35:33 <mauke> Data.Function?
15:35:52 <conal> dmwit: that's it. thx!
15:38:08 <skeletro3> ciaoo
15:38:19 <skeletro3> :list
15:38:31 <mauke> this isn't mozilla/#firefox
15:43:28 <nexion> is it possible to get ghc to warn about incomplete pattern matching? currently I get a runtime error: Main.hs: user error (Pattern match failure in do expression at Main.hs:39:3-43)
15:43:36 <Axman6> nexion: use -Wall
15:43:41 <nexion> I am
15:43:45 <nexion> but with "runhaskell"
15:43:58 <nexion> is it different with invoking ghc?
15:43:59 <Axman6> it should tell you about any incomplete pattern matches
15:44:11 <Axman6> not sure if that works with renhaskell. try just compiling the program
15:45:24 <nexion> hm.. it didn't work; I got unrelated "Defined but not used" warnings, but nothing about pattern matching
15:45:42 <nexion> $ ./Main
15:45:42 <nexion> Starting...
15:45:42 <nexion> Initializing listener socket on port 28750
15:45:42 <nexion> Main: user error (Pattern match failure in do expression at Main.hs:39:3-43)
15:45:43 <Axman6> where is the pattern match failure happening in your code?
15:46:04 <mauke> ooh, "in do expression"
15:46:26 <nexion> I created a data type NewConnectionChanMessage with 2 constructors
15:46:30 <mauke> why are you using a refutable pattern in an IO do block?
15:46:36 <nexion> NewConnection and SomethingElse (to test)
15:46:59 <Axman6> ah, i missed that. good catch mauke
15:47:08 <Kaidelong> I need a good library for drawing pixels on a screen, in real time
15:47:14 <Kaidelong> doesn't have to be cross platform
15:47:19 <nexion> I'm new btw
15:47:25 <nexion> what's a refutable pattern?
15:47:29 <Kaidelong> would prefer not to have to install Qt
15:47:30 <mauke> a pattern that can fail
15:47:42 <Kaidelong> or get anything involving wx to compile
15:47:42 <Axman6> True <- return False would be an example
15:47:59 <Axman6> Kaidelong: HOpenGL?
15:48:00 <nexion> ah.. I'm doing that on purpose to see if ghc can be told to warn about pattern match failures at compile time
15:48:13 <Axman6> it can in function definitions
15:48:13 <mauke> nexion: it can, but in this case there's no way for you to fix it
15:48:17 <Axman6> and case statements
15:48:25 <nexion> ah
15:48:27 <Kaidelong> Axman6: That's what I said but the guy rightly pointed out that this is probably overkill
15:48:28 <mauke> because you can't add a second pattern anyway
15:48:35 <nexion> this is inside a do block, on this line:
15:48:36 <nexion>   NewConnection clientSocket clientSockAddr <- atomically $ readTChan newConnectionChan
15:48:41 <nexion> so I'm not offering it any other options
15:48:45 <nexion> but 1 other is possible
15:48:49 <mauke> yeah
15:48:53 <Kaidelong> he just wants to look at something update in a window
15:48:57 <Kaidelong> on windows
15:49:02 <mauke> my guess would be the compiler thinks you know what you're doing since you're not using 'case'
15:49:23 <Axman6> just use conn <- readChan ...; case conn of NewConnection ... -> ; SomethingElse -> ...
15:49:37 <edwardk> preflex: xseen cmccann
15:49:37 <preflex>  cmccann was last seen on freenode/#haskell 69 days, 20 hours, 26 minutes and 26 seconds ago, saying: yes, I expect that terms common in OO were chosen deliberately in order to confuse newcomers as much as possible
15:49:40 <Kaidelong> oh he has decided on FunGEn apparently
15:49:43 <Kaidelong> nevermind
15:49:57 <Kaidelong> that seems like overkill too to me but if he is good with it
15:50:16 <ddarius> edwardk: Whatever happened with Casey?
15:50:41 <edwardk> ddarius: was just trying to figure that out
15:50:54 <edwardk> matt wanted me to follow up with him
15:52:49 <Kaidelong> and now he says he's fine just using HOpenGL
15:52:50 <nexion> yup, it warns about non-exhaustive pattern matching if I use case
15:54:48 <int80_h> I'm looking for a higher order function(s) that will generate a list, given a list and an Int.
15:55:15 <mauke> const
15:55:40 <Axman6> technically not higher order in that context...
15:55:51 <ddarius> Technically it is.
15:56:06 <shachaf> ddarius: Even if it takes a tuple?
15:56:12 <int80_h> :t const
15:56:13 <lambdabot> forall a b. a -> b -> a
15:56:22 <Axman6> how? it's not taking another function as an argument
15:57:36 <int80_h> I don't see how const fits
15:57:50 <shachaf> > const [] 5
15:57:51 <lambdabot>   []
15:57:59 <ddarius> Axman6: The typical definition of a higher order function is one that takes other functions as arguments -or returns a function.-
15:58:11 <nexion> sorry, got d/c
15:58:15 <shachaf> int80_h: mauke was subtly hinting at how your function is underspecified.
15:58:28 <nexion> my last was:
15:58:30 <nexion> <nexion> yup, it warns about non-exhaustive pattern matching if I use case
15:58:30 <nexion> <nexion> so it just doesn't perform this check if it's directly inside do-notation?
15:58:39 <mauke> nexion: apparently
15:58:50 <Axman6> ddarius: yeah? i'd never heard the latter part of the definition before
15:58:54 <mauke> nexion: because there's no way you can specify multiple patterns in do anyway
15:59:02 <ddarius> http://en.wikipedia.org/wiki/Higher-order_function
15:59:35 <Axman6> without using case*
15:59:49 <shachaf> Also, do pattern matches fail with "fail", not with _|_.
16:00:49 <int80_h> shachaf : I want something like iterate, but with a type function like (a -> a) -> a -> [a] -> [a]
16:00:57 <Axman6> pat <- foo gets turned into foo >>= \x -> case x of pat -> ... _ fail "pattern match failure...")?
16:01:10 <Axman6> int80_h: and what does it do?
16:01:14 <int80_h> iterate is close, but I need to work over a list, using the Int as a counter
16:01:46 <shachaf> You still haven't explained what the function does.
16:01:57 <int80_h> I mean (a -> a) -> a -> [a] -> [[a]]
16:02:04 <mauke> int80_h: that doesn't contain Int
16:02:04 <shachaf> You should give an example: f (...) ... ... = ...
16:02:24 <ddarius> edwardk: I can return your books today if you have a minute.
16:02:27 <int80_h> okay so what I start with is a [(x,Bool)]
16:03:17 <int80_h> I need a way to make a sublist, defined the following way.
16:03:34 <shachaf> int80_h: There's still no Int involved.
16:04:09 <ddarius> Wikipedia even lists const as an example of a higher-order function.
16:04:22 <int80_h> I look at each Bool, and if it is True, I mark it False. If it's False I look for the next True. I do this three times. That's the sublist. I iterate through until I have a list of lists.
16:04:48 <int80_h> the Int will tell me how many sublists I need to make
16:05:03 <mauke> "mark"?
16:05:06 <mauke> also, what sublist?
16:05:25 <int80_h> (a -> a) -> a -> [a] -> [[a]]
16:05:29 <int80_h> [[a]]
16:05:47 <mauke> still no Int there
16:05:52 <mauke> still no explanation of what the thing does
16:05:57 <int80_h> oops!
16:06:07 <int80_h> (a -> a) -> Int -> [a] -> [[a]]
16:06:39 <mauke> foo succ 3 "aac" == ?
16:07:08 <int80_h> hold on I'm thinking this out
16:07:13 <shachaf> a -> a -> [[a]] -> [a -> a] -> (Int,Bool,Double) -> (a,([a],[a]))
16:09:18 <ddarius> shachaf: I use that function every day.
16:14:29 <_Mikey> Good night Happy Haskellers!
16:15:17 <ion> Nothing for sad haskellers?
16:15:54 <hpaste> int80_h pasted “iteration problem” at http://hpaste.org/54690
16:16:19 <int80_h> okay. I've mentioned the actual types I'm using.
16:18:22 <mauke> how do you end up with a list of lists?
16:18:46 <mauke> because the first part is just map (\(d, _) -> (d, Unavailable))
16:19:19 <int80_h> mauke: somehow I thought I needed to end up with a list of lists, and I would flatten that out. I don't require one.
16:19:52 <int80_h> I mean, I thought by virtue of doing what I needed to do, I would end up creating a list of lists that would need to be flattened out.
16:20:04 <mauke> well, what do you need to do?
16:21:07 <monochrom> [(day1, Available), (day2, Unavailable), (day3, Available)] -> [[(day1, Unavailable), (day2, Unavailable), (day3, Unavailable)] ?
16:21:28 <monochrom> oops, typo, s/[[/[/
16:21:59 <Kaidelong> if someone ever asks what I did today
16:22:02 <Kaidelong> point them to gloss
16:22:12 <int80_h> mauke, for each [1 .. x] I nned to mark three successive Availabilitys as Unavailable, skipping over any previiously Availables marked as Unavailable.
16:22:13 <Kaidelong> it is a good library for drawing pixels to a screen in a simple way
16:22:53 <int80_h> so if I had [Available,Unavailable,Unavailable,Available,Available]
16:23:21 <int80_h> I would need to change that to [Unavailable,Unavailable,Unavailable,Unavailable,Unavailable]
16:24:47 <int80_h> mauke" and that would just decrement the counter by 1. I would need to do that x -1 more times.
16:25:03 <int80_h> which suggests I would be building a list of lists.
16:25:47 <Cale> Kaidelong: have you been working on it? :)
16:26:06 <Kaidelong> Cale: No, is it one of your libraries?
16:26:09 <wayne[mobile]> it seems like there aren't many
16:26:21 <Cale> no, but it's one of my favourites too :)
16:27:21 * Axman6 learnst Haskell using the precursor to Gloss at ANU
16:28:10 <int80_h> I can work this out using explicit recursion, and do it properly when it's working.
16:28:10 <Axman6> learnt*
16:37:08 <luite> I still hope for a proper gloss-web that runs totally client-side with ghcjs :)
16:40:23 <luite> (since that would make wolfgang lambda more awesomer)
16:41:08 <shachaf> luite: Will it get to be Wolfgang Mu? Or is that even more awesomer than ghcjs?
16:41:40 <luite> shachaf: no I dropped the lambda part from the name actually
16:44:19 <luite> shachaf: http://hdiff.luite.com/tmp/fp-mockup.png
16:45:15 <shachaf> luite: Looks pretty neat, whatever it'll turn out to be. :-)
16:45:46 <luite> yeah that page doesn't really show, the other screenshots show a little more
16:46:23 * shachaf remembers the early demo.
16:46:56 <luite> yeah the idea is still more or less the same, except everything is different :p
16:47:46 <shachaf> luite: Hence my previous statement.
16:48:09 <ion> ghcjs, huh? Interesting.
16:48:32 <thoughtpolice> ion: there's a branch on github that has it directly integrated into ghc. pretty cool, wonder if it'll ever get mainlined
16:48:41 <luite> ion: please work on it and hae something that can compile gloss and diagrams by februari ;p
16:48:52 * Eduard_Munteanu was a bit wtflol when he saw Agda's JS compiler backend :)
16:49:03 <thoughtpolice> Eduard_Munteanu: agda is ready for webscale
16:49:08 <thoughtpolice> JS is webscale, after all
16:49:10 <Eduard_Munteanu> Indeed :)
16:49:11 <luite> node.agda
16:49:29 <ion> Do threads work?
16:49:46 <russellw> Agda compiling to JavaScript? That I wasn't expecting! What are they doing about representation of numbers?
16:49:49 <thoughtpolice> ion: https://github.com/the-real-blackh/ghc
16:50:03 <russellw> Given that JavaScript only does floating-point natively, which I wouldn't have thought suitable for Agda?
16:50:06 <thoughtpolice> also check out some of hamish's work https://github.com/hamishmack
16:50:07 <Eduard_Munteanu> I'm not sure, I haven't tried it.
16:50:32 <luite> chrisdone is also doing some work on ghcjs
16:50:43 <luite> dunno how serious his fork is
16:50:57 <Eduard_Munteanu> russellw: the same argument would go for any other compiler that translates to JS.
16:51:00 <shachaf> russellw: I think JavaScript guarantees that integers up to 32 bits behave like integers? Or something along those lines.
16:51:06 * shachaf doesn't recall, actually.
16:51:17 <periodic> Is there a function that is like "tails" but is "heads"?
16:51:27 <Draconx> periodic, inits
16:51:32 <Eduard_Munteanu> (mind typechecking has nothing to do with it)
16:51:53 <periodic> Draconx: thanks.
16:52:10 <russellw> Eduard_Munteanu, indeed it would, though not all languages would care, because as shachaf observes, small integers - up to about fifty-three bits - are handled exactly. For some languages, that suffices
16:52:25 <ion> Is there a demo of (a recent) ghcjs somewhere online?
16:53:07 <ddarius> heads = id
16:53:24 <shachaf> Hah.
16:53:42 <ion> heads = flip tails
16:54:03 <shachaf> Oddly enough, head (tails x) = x
16:55:06 <tsuraan> @last chrisdone
16:55:06 <lambdabot> No module "chrisdone" loaded
16:55:11 <tsuraan> @seen chrisdone
16:55:11 <preflex>  chrisdone was last seen on #haskell 1 hour, 47 minutes and 34 seconds ago, saying: likeso http://hpaste.org/irc/haskell/2011-11-29/15-07-13/54684
16:55:11 <lambdabot> Unknown command, try @list
16:56:27 <shachaf> @check \xs -> (catMaybes . map listToMaybe . tails) xs == (xs::[Int])
16:56:27 <lambdabot>   "OK, passed 500 tests."
16:58:11 <shachaf> @check \xs -> (tails >=> maybeToList . listToMaybe) xs == (xs::[Int])
16:58:12 <lambdabot>   "OK, passed 500 tests."
17:01:00 <ion> @check \xs -> (take 1 <=< tails) xs == (xs :: [Int])
17:01:01 <lambdabot>   "OK, passed 500 tests."
17:01:36 <shachaf> Oh, er, there is that.
17:02:02 <ion> > (take 3 <=< tails) "foobarbazquux"
17:02:03 <lambdabot>   "foooobobabararbrbabazazqzququuuuxuxx"
17:02:47 <int> hello, can anyone recommend a good article on how to call foreign functions from the R programming language?
17:03:22 <shachaf> int: #r probably can.
17:03:45 <Cale> Augh, now I'm receiving junk mail intended for UWaterloo employees. WTF.
17:04:07 <shachaf> Cale: It's a hint from UWaterloo.
17:06:14 <Cale> It's a hint that they're clingy as fuck. A while back they called me up and asked me if I'd like to randomly gift them some money. Imagine if your car dealership called you up a few years after you bought a car and asked if you could give them some more money so that they could make better cars for other people. Ugh.
17:07:06 <c_wraith> Cale: You mean my dealership shouldn't be doing that?
17:07:28 <Cale> c_wraith: lol, is it?
17:08:01 <Axman6> Cale: my dad gets letters from Cambridge every year asking the same thing. it's a bit rich asking a retired man for money
17:08:06 <c_wraith> Well, sort of.  They keep saying they'd love to buy my car back (they don't say for how little) and how much I'd love to buy a new car.
17:08:44 <Cale> Yeah, they're not even offering me anything in exchange though.
17:09:23 <Cale> They're just like "We'd like to build this new building, and we're wondering if you'd be interested in making a monetary gift to the university."
17:10:07 <shachaf> Cale: I expect that it's effective, if they keep doing it.
17:10:09 <luite> your degree might get more valuable if people know that you went to that university with that awesome building
17:10:17 <Cale> After wasting my time for a while by asking questions about how my life has been going.
17:10:59 <c_wraith> almost like they care about you.
17:11:01 <c_wraith> what liars.
17:11:12 <nexion> is it generally recommended to use socketToHandle and treat sockets as handles?
17:11:42 <Cale> They also constantly send me these catalogues full of insultingly stupid courses. "HEY DERPY! U NOT KNOW HAU USE MICROSOFT WORDS? WE SHOW U HAU DO!"
17:11:42 <tomprince> Cale: I haven't tried it, but you can probably ask them to stop.
17:11:52 <mlb-> I'm reading through learnyouahaskell.com -- is there an alternate explanation for "newtype"? I'm just not getting it at the moment
17:12:17 <tomprince> (I get them from my undergrad school, while still being a grad student :) )
17:12:17 <Cale> Yeah, I need to either do that or tell them that I've moved to the Northwest Territories.
17:12:19 <shachaf> mlb-: It's like a type synonym, except that it has a different type.
17:12:33 <c_wraith> mlb-: newtype just creates a new type that wraps an existing one.
17:12:38 <shachaf> mlb-: It gets compiled to the exact same thing; it's just different for type-checking purposes.
17:12:43 <shachaf> Well, "just".
17:13:23 <mlb-> ah, like having a duplicate version of Char or something, but not to be confused with Char?
17:13:29 <c_wraith> yep
17:13:42 <shachaf> It's pretty similar to "data" with restrictions and a different strictness behavior.
17:14:15 <luite> so pretty different actually ;p
17:14:26 <mlb-> I see, so it's used for Monad instance types so something else can't accidently slip in there?
17:14:55 <mlb-> e.g., not just /any/ 2-tuple, but a specific one?
17:15:07 <mauke> YES! thanks, mlb-++
17:15:18 <mlb-> what?
17:15:29 <mauke> you said /any/ and it was italicized
17:15:29 <c_wraith> mlb-: also, newtypes can have different instances than the original type had
17:15:36 <mauke> that means my patch is working
17:15:59 <shachaf> mauke: What does your patch do?
17:16:01 <luite> hehe /does that mean that this is all italicalized/ ?
17:16:05 <mauke> luite: yes
17:16:21 <mauke> shachaf: italicizes words like /this/
17:16:33 <shachaf> Aw. I thought it was some clever substitution whenever someone said "Monad".
17:17:20 <c_wraith> "Cute Fuzzy Thing"
17:17:43 <irene-knapp> hah, yes, that was a hilarious site
17:17:54 <irene-knapp> so, wait
17:18:23 <Axman6> mauke: /what/happens/when/you/get/a/file/path?
17:18:27 <irene-knapp> ... ahhh never mind.  was going to try to work up an example that mixed toothpick-italics and regexps :)
17:18:35 <irene-knapp> possibly a regexp for detecting toothpick-italics :)
17:18:51 <mauke> Axman6: nothing
17:18:59 <irene-knapp> see, humans do semantic filtering
17:19:13 <irene-knapp> we're aware of all the likely interpretations and choose the one that actually makes sense
17:19:42 <mauke> that's exactly the wrong approach for debugging
17:20:17 <irene-knapp> mauke: haha true
17:27:14 <mlb-> c_wraith: wait, so if I used "type" and went off to create some instances in other classes, then the base of the "type" I created would apply as well?
17:27:41 <c_wraith> mlb-: yes.  type doesn't create new types.  It just creates aliases for the same types
17:27:59 <mlb-> ah, I guess that makes sense,
17:27:59 <luite> mlb-: you even have to enable a language extension if you want to do that
17:28:05 <luite> (TypeSynonymInstances)
17:28:35 <mlb-> I'll play with interfaces later, I'm still working my mind about monads
17:29:04 <c_wraith> monads are less important than you think.  don't bother.
17:29:48 <mlb-> I'm interested in the State monad, mainly,
17:29:58 <mauke> @unmtl State s a
17:29:58 <lambdabot> s -> (a, s)
17:30:31 <mlb-> in general though, monads appear to be a fairly common abstraction to run into
17:33:41 <c_wraith> sure.  but being a common abstraction means that it's a pretty general thing.  It doesn't actually *mean* much, except that you can use common control-flow patterns.
17:58:01 <nilu> hello
17:58:07 <Axman6> 'lo
17:59:09 <nilu> how r u Axman6?
17:59:54 <Axman6> fine. do you have a question about Haskell?
18:00:01 <nilu> yes i do
18:00:09 <Axman6> ask away then
18:00:17 <nilu> I'm new to haskell
18:00:30 <nilu> what are the main features of the haskell?
18:00:43 <tmhz> Hi, is it possible to create a new data type that is a restricted subset of Integer that only contains the number [1..9] for instance. instead of doing something like this data Entry = Unknown | One | Two | Three | Four | Five | Six | Seven | Eight | Nine
18:00:43 <tmhz>     deriving (Read, Show, Eq, Enum, Ord)
18:00:52 <dmwit> nilu: Take a look at haskell.org.
18:01:04 <dmwit> It's a wiki with lots of information about Haskell, including a "getting started" section with some propoganda.
18:01:07 <Axman6> tmhz: I wish it were :(
18:01:27 <dmwit> ?wiki smart constructor
18:01:27 <lambdabot> http://www.haskell.org/haskellwiki/smart_constructor
18:01:35 <dmwit> tmhz: See that page.
18:02:00 <nilu> I did go through some of them
18:02:06 <Axman6> Ada has a nice feature for specifying numeric types. you can define types that have values in any arbitrary range, as well as mod types
18:02:39 <Axman6> type Random_State is mod 2**32;
18:02:45 <tmhz> axmna6: Yeh that is what I was wishing for. I'll have a look at dmwits page. Thanks
18:03:10 <nilu> I'm not sure on mod types
18:04:01 <Axman6> nilu:they don;t exist in Haskell. in Ada, they mean that, in the previous example, the number after 2^32-1 is 0.
18:04:14 <tromp> tmhz:i do somrthing like that in my haskell go rules; see bottom of http://www.cwi.nl/~tromp/go/Go.hs, datatype XCoord
18:04:45 <Axman6> so type Small_Thing is mod 3 => 0,1,2,0,1,2,0...
18:06:50 <nilu> Actually I'm suppose to do presentation on Haskell. What are the points that i should not forget?
18:07:13 <Axman6> nilu: tell us what you know about Haskell
18:07:51 <nilu> its a pure functional language
18:08:04 <Axman6> do you know what that means?
18:08:32 <tmhz> tromp: That is exactly what I was after, thank you!
18:08:54 <nilu> frankly speaking no
18:09:05 <nilu> pure made me confused
18:09:40 <nilu> the word pure made it confusing to me
18:09:47 <shapr> your variables don't vary!
18:10:15 <dmwit> ?quote back.*away
18:10:15 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
18:10:23 <Axman6> pure means that functions don't have side effects. you can't print things inside a function, you can't mutate memory, you can't access files or do network IO. what this means is that the outputs of your functions rely only on the inouts you give to your function
18:10:24 <irene-knapp> ?quote back*away
18:10:24 <lambdabot> No quotes match. Where did you learn to type?
18:10:31 <irene-knapp> ?quote away
18:10:31 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
18:10:31 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
18:10:40 <dmwit> perfect
18:10:43 <irene-knapp> oh hey, that looks like the one you wanted :D
18:11:18 <irene-knapp> we don't actually solve that problem, haha
18:11:28 <irene-knapp> you can easily lose track of rebindings
18:11:29 <shachaf> @google "why learn haskell"
18:11:29 <lambdabot> http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf
18:11:29 <lambdabot> Title: Why learn Haskell?
18:11:36 <dropdrive> Hi...is there a way to parse a .hs file in Haskell?  E.g. find the names of all variables, and on which line it was defined.
18:11:56 <dmwit> dropdrive: Yes, use the GHC API, Template Haskell, or Language.Haskell.
18:12:04 <shachaf> @faq is there a way to parse a .hs file in Haskell?
18:12:04 <lambdabot> The answer is: Yes! Haskell can do that.
18:12:05 <irene-knapp> or haskell-src-exts
18:12:09 <dmwit> Depending on what exactly you intend to do, each of those will be appropriate at different times.
18:12:28 <dropdrive> Whoa, how do I choose?
18:13:13 <dmwit> Do you intend to generate code? Use Template Haskell. Do you intend to execute code at runtime? Use the GHC API. Do you intend to munge code to produce statistics? Use Language.Haskell.
18:13:18 <dropdrive> Anyway, my next question is, how might I take GHC and use it to spit out all the types of variables defined in a .hs file?
18:13:42 <dmwit> That sounds like a perfect use-case for the GHC API to me.
18:14:02 <irene-knapp> note that if you really mean all the EXPORTED variables defined in it
18:14:15 <irene-knapp> you might want to get the information out of the .hi file instead (you can read that with the GHC API, too)
18:14:37 <Axman6> irene-knapp: did you used to go by a different nick?
18:14:43 <irene-knapp> Axman6: yes
18:14:56 <Axman6> what was it?
18:15:06 <irene-knapp> dankna
18:15:36 <Axman6> ah ha. thanks. i was confused because you seem to know so much yet seemed so new
18:15:42 <irene-knapp> Axman6: np hehe :D
18:15:53 <Axman6> why the change?
18:16:08 <irene-knapp> cause of I'm a girl, and Dan is a boy's name
18:16:16 <Eelis> what's a popular package for semirings?
18:16:18 <mauke> .oO( runtime typecasting )
18:16:25 <irene-knapp> mauke: hahahah!
18:16:31 <irene-knapp> that's priceless, I have to use that
18:16:33 <dropdrive> dmwit: Thanks.  I see a bunch of stuff like TypeCheckedModule, etc. etc.
18:16:42 <mauke> irene-knapp: it's from audrey tang
18:16:53 <irene-knapp> ah neat :)
18:17:19 <shachaf> Eelis: "algebra"?
18:18:07 <dmwit> numeric-prelude probably has something for semirings in it, too.
18:18:32 <Axman6> i'm sure edwardk has written something too
18:18:34 <Eelis> shachaf: thanks, looks good
18:18:38 <Axman6> because he's written everything
18:18:42 <nilu> why is haskell called lazy function?
18:18:52 <dmwit> Axman6: algebra *is* the edwardk thing
18:19:20 <monochrom> because most interpreters and compilers use lazy evaluation.
18:19:34 <nilu> what does that mean?
18:19:45 <nilu> lazy evaluation means?
18:19:52 <ion> lmgtfy
18:19:58 <monochrom> for example:
18:20:06 <monochrom> > const True (1/0)
18:20:09 <lambdabot>   mueval-core: Time limit exceeded
18:20:10 <dmwit> ?wiki lazy evaluation
18:20:10 <lambdabot> http://www.haskell.org/haskellwiki/lazy_evaluation
18:20:14 <monochrom> > const True (1/0)
18:20:15 <dmwit> nilu: Take a look there.
18:20:16 <Axman6> nilu: here lazinerss means that nothing is computed until it's needed. in languages like C, you have to compute a value before you can poass it to a function. in haskell, you give it something that may not be evaluated yet, and if it's never needed, it won't be evaluated, saving some computation
18:20:16 <lambdabot>   True
18:20:18 <shapr> nilu: Only one side of an if statement gets executed, thus the code is lazily evaluated.
18:20:39 <shapr> If languages were perfectly strict, all branches would get executed.
18:20:46 <monochrom> the 1/0 there doesn't hurt because lazy evaluation says certain subexpressions can be skipped
18:20:52 <monochrom> another example:
18:20:54 <mauke> > 1/0
18:20:55 <lambdabot>   Infinity
18:21:01 <monochrom> > take 5 (repeat 'x')
18:21:02 <lambdabot>   "xxxxx"
18:21:09 <Axman6> nilu: && in C i9s an example of a lazy computation. if the first srgument to && is false, then thr second one isn't evaluated
18:21:29 <mauke> fingers on home row plz
18:21:32 <Axman6> is*, argument*, the* -_-
18:21:37 <Axman6> yeah -_-
18:21:41 <shapr> nilu: I want to know which class assigned you Haskell
18:21:45 <monochrom> repeat 'x' is an infinite list, but lazy evaluation says don't bother finishing the whole infinite list before do take 5. certain jobs can be skipped
18:21:58 <Sgeo> I used to hunt-and-peck for so long that I now know-and-peck
18:22:20 <monochrom> > const True (div 1 0)
18:22:22 <lambdabot>   True
18:22:43 <Sgeo> > div 1 0
18:22:44 <lambdabot>   *Exception: divide by zero
18:22:54 <nilu> shapr:we just had to do a presentation on one language n i choose haskell
18:23:30 <Axman6> nilu: laziness allows us to make programs clearer, but doing things like producing lasts that if they were evanuated fully would be infinitely long, but we only compute as much of the list as needed
18:23:52 <Axman6> s/but/by
18:24:06 <monochrom> and s/lasts/lists/
18:24:21 <Axman6> uh, yeah
18:24:34 * Axman6 should stop typing. not used to this keyboard
18:24:52 <nilu> thanks that make sense.
18:25:31 <Sgeo> @hoogle ands
18:25:31 <lambdabot> Data.Graph.Inductive.Graphviz Landscape :: Orient
18:25:31 <lambdabot> package randsolid
18:27:18 <ion> > let zeros = 0:zeros in zeros
18:27:19 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:27:30 <ion> Values can refer to themselves like so because of laziness.
18:27:51 <ion> > let nats = 0 : map (+1) nats in nats
18:27:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:28:16 <vrook> There doesn't seem to be an analogue to lisp's "flet". I can make a local function, but it doesn't seem to accept guards. Is this true?
18:28:26 <mauke> no
18:28:27 <monochrom> and the computer prints the list at all because it starts printing before finishing the whole list. that's also due to lazy evaluation.
18:28:43 <Axman6> vrook: you can define functions using let just fine
18:29:00 <tromp> haskell is also good at fixing error
18:29:18 <nilu> how?
18:29:24 <tromp> > fix error
18:29:25 <monochrom> > let {x | 5==4 = 'x' | otherwise = 'y' } in x
18:29:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:29:26 <lambdabot>   'y'
18:29:54 <vrook> oh, braces. thanks.
18:29:54 <tromp> (just a silly joke)
18:30:19 <tromp> but fix is useful for compuing fix points, e.g.
18:30:24 <mauke> > let x | 5==4 = 'x' | otherwise = 'y' in x
18:30:25 <Axman6> you shouldn't need to use braces
18:30:25 <lambdabot>   'y'
18:30:25 <tromp> >fix ('a':)
18:30:27 <mauke> what braces?
18:30:30 <monochrom> > let {x=y where y | 5==4 = 'x' | otherwise = 'y'} in x
18:30:31 <lambdabot>   'y'
18:30:40 <monochrom> my braces
18:30:44 <mauke> > let x=y where y | 5==4 = 'x' | otherwise = 'y' in x
18:30:45 <lambdabot>   'y'
18:30:45 <ion> > fix ((0:) . map (+1))
18:30:52 <lambdabot>   mueval: ExitFailure 1
18:30:52 <lambdabot>  mueval-core: Time limit exceeded
18:31:27 <tromp> > fix ( map (+1) . (0:))
18:31:31 <lambdabot>   mueval-core: Time limit exceeded
18:31:32 <monochrom> in the absence of knowing the layout rules, braces are a good substitute.
18:31:57 <ion> > fix ((0:) . map (+1))
18:32:01 <lambdabot>   mueval-core: Time limit exceeded
18:32:02 <mauke> > let {x=y where {y | 5==4 = 'x' | otherwise = 'y'}} in x
18:32:03 <lambdabot>   'y'
18:33:20 <nilu> Can someone tell me which is latest version of Haskell?
18:33:38 <ion> 2010
18:33:57 <monochrom> Haskell 2010 is the latest version of Haskell. http://www.haskell.org/onlinereport/haskell2010/
18:34:18 <nilu> thanks
18:40:43 <Sgeo> I don't quite grok some and many
18:41:59 <Axman6> @hoogle some
18:41:59 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
18:41:59 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
18:41:59 <lambdabot> Control.Exception SomeException :: e -> SomeException
18:42:01 <Axman6> @hoogle many
18:42:01 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
18:42:01 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
18:42:01 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
18:42:45 <Sgeo> :t (*>)
18:42:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
18:42:46 <monochrom> they are not interested for most Applicatives. but you should consider Parsec, which is an Applicative and has interesting and useful some and many
18:43:02 <Sgeo> :t ($>)
18:43:03 <lambdabot> Not in scope: `$>'
18:43:17 <Sgeo> :t (Data.Functor.$>)
18:43:17 <lambdabot> Not in scope: `Data.Functor.$>'
18:43:28 <monochrom> I think STM has interesting some and many, too
18:44:12 <Sgeo> > optional [1]
18:44:13 <lambdabot>   [Just 1,Nothing]
18:44:16 <monochrom> "interesting" means "terminating"
18:44:18 <Sgeo> > optional [2]
18:44:19 <lambdabot>   [Just 2,Nothing]
18:44:28 <Sgeo> > optional []
18:44:29 <lambdabot>   [Nothing]
18:44:38 <Sgeo> :t optional
18:44:38 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
18:44:50 <Sgeo> I don't get this
18:44:59 <dmwit> > optional [1..5]
18:45:00 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Nothing]
18:45:00 <Axman6> > optional (Just 1)
18:45:01 <lambdabot>   Just (Just 1)
18:45:09 <c_wraith> optional mostly makes sense for parsers
18:45:10 <dmwit> ?src optional
18:45:10 <lambdabot> optional v = Just <$> v <|> pure Nothing
18:45:24 <dmwit> ah
18:45:35 <Sgeo> Wait, which way's the precedence?
18:45:40 <Sgeo> :t (<|>)
18:45:41 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
18:45:47 <dmwit> (Just <$> v) <|> (pure Nothing) -- this way
18:46:04 <Axman6> hmm, is <|> ++ for lists? o.O
18:46:10 <dmwit> sure it is
18:46:21 <Axman6> >  [1,2,3] <|> [4,5,6]
18:46:22 <lambdabot>   [1,2,3,4,5,6]
18:46:28 <Axman6> seems so o.O
18:47:09 <Sgeo> I think I see how optional list makes sense
18:48:11 <Sgeo> The view of lists as indeterminate computations... makes a computation of potentially several values into one that could either be one of those values or have no value
18:48:39 <monochrom> nondeterministic. not quite indeterminate.
18:48:44 <Sgeo> Ah
18:49:46 <vrook> OK I've narrowed down my problem with local guards to this: https://gist.github.com/1407813
18:50:33 <vrook> I haven't a coherent theory in my head about whitespace
18:51:22 <Cale> vrook: Things which are siblings line up vertically. Things which are part of something else start in a deeper colum
18:51:23 <Cale> n
18:51:23 <vrook> nevermind, i just found http://en.wikibooks.org/wiki/Haskell/Indentation
18:51:33 <vrook> ok thanks
18:52:18 <monochrom> oh, right, don't put | right under d
18:52:22 <dmwit> vrook: The pipes must be indented more deeply than the thing being bound.
18:52:46 <dmwit> In this particular case, less deeply is probably also okay.
18:52:47 <vrook> is there a definitive style on where "in" should go?
18:52:48 <Cale> So yeah, the guards are part of the definition of dir' and so must start in a deeper column
18:53:03 <Cale> vrook: either directly under let or indented one more space
18:53:10 <Axman6> vrook: personally i'd use where for that definition
18:53:41 <vrook> But if you were using let, would you put the "in" there?
18:53:49 <Cale> vrook: what you have is sensible
18:54:00 <Cale> vrook: it'd also be okay one more space over
18:54:13 <Cale> let ...
18:54:15 <Cale>  in ...
18:54:18 <Cale> ^^ like that
18:54:25 <vrook> well I'm following what emacs says
18:54:38 <dobblego> is there a ghc option to turn off warning for unused definitions?
18:55:36 <monochrom> I never got that warning. I just don't use -Wall or whatever
18:55:51 <dobblego> furry nuts
18:56:11 <dobblego> documentation seems to suggest -fwarn-unused-binds but when I use it, I still get the warning
18:56:24 <dmwit> -fno-warn-unused-binds
18:56:41 <dobblego> haha I forget the no-
18:56:46 <dobblego> ta
18:56:54 <dylex> dobblego: you can also suppress it by naming the identifier (or referencing it from something named) with a leading underscore
18:57:12 <dobblego> right, but I don't want to here, because it's part of a teaching exercise
19:00:07 <phoenixsun> What are some good books for machine learning in haskell or otherwise that I will teach me to actually write sentiment analysis code?
19:02:44 <AfC> sentient code?
19:03:17 <phoenixsun> well no that sounds like the code is very much self awaree
19:03:34 <phoenixsun> I just meant stuff like categorization, machine learning
19:03:56 <phoenixsun> reading large data from say twitter and making assumptions
19:03:58 <vrook> would you call "case () of _ | ..." an idiom or a hack?
19:04:04 <dmwit> yes
19:04:26 <vrook> seems like a "cond" construct would be nice there.
19:04:46 <dmwit> :t snd . head . filter fst
19:04:47 <lambdabot> forall b. [(Bool, b)] -> b
19:04:57 <dmwit> ?let cond = snd . head . filter fst
19:05:00 <lambdabot>  Defined.
19:05:19 <shachaf> @let (==>) = (,)
19:05:19 <lambdabot>  Defined.
19:05:23 <dmwit> > cond [(even 3, "weird"), (odd 3, "not as weird"), (otherwise, "very, very weird")]
19:05:24 <vrook> well then you don't have the nice |
19:05:26 <lambdabot>   mueval-core: Time limit exceeded
19:05:41 <dmwit> Can we get that time limit bumped up or something?
19:05:43 <dmwit> > cond [(even 3, "weird"), (odd 3, "not as weird"), (otherwise, "very, very weird")]
19:05:44 <lambdabot>   "not as weird"
19:05:45 <shachaf> > cond [even 3 ==> "weird", odd 3 ==> "not as weird", otherwise ==> "very, very weird"]
19:05:46 <dobblego> @type fromJust . lookup True
19:05:46 <lambdabot> forall a. [(Bool, a)] -> a
19:05:47 <lambdabot>   "not as weird"
19:06:24 <rwbarton> you can use msum + guard + >>
19:06:34 <rwbarton> though the guard is a bit wordy I suppose
19:06:35 <Axman6> find ALL the ways!
19:07:14 <rwbarton> maybe comprehension!
19:07:32 <Sgeo> :t cond
19:07:33 <lambdabot> forall b. [(Bool, b)] -> b
19:07:33 <vrook> I suspect people would still use "case () of _ | ..." because the syntax is nicer
19:08:03 <Axman6> what do you need to use that for at all?
19:08:15 <rwbarton> you can also write something like "x where x | ..."
19:08:20 <Sgeo> I had a thing where having the argument implicly passed to the conditions would have been nice
19:08:23 <Axman6> yeah
19:08:41 <dobblego> @type Reader
19:08:42 <lambdabot> Not in scope: data constructor `Reader'
19:08:52 <dmwit> :k Reader
19:08:53 <lambdabot> * -> * -> *
19:09:00 <dobblego> @type ReaderT
19:09:01 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
19:09:50 <Sgeo> I wanted cond :: [(a -> Bool),b] -> a -> b
19:10:24 <dmwit> :t find
19:10:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:10:43 <Sgeo> @djinn [(a -> Bool,b)] -> a -> b
19:10:44 <lambdabot> Error: Undefined type []
19:10:52 <dobblego> such a function is destined to be unsafe
19:10:54 <dmwit> :t \xs a -> fromJust (find (($a) . fst) xs)
19:10:54 <lambdabot> forall a b. [(a -> Bool, b)] -> a -> (a -> Bool, b)
19:11:14 <dmwit> :t \xs a -> snd . fromJust . find (($a) . fst) $ xs
19:11:15 <lambdabot> forall b a. [(a -> Bool, b)] -> a -> b
19:11:17 <Sgeo> @djinn [(a -> Bool,b)] -> a -> Maybe b
19:11:17 <lambdabot> Error: Undefined type []
19:11:32 <rwbarton> > fromMaybe "really weird" $ flip runReaderT 3 $ [ "weird" | even ] `mappend` [ "less weird" | odd ]
19:11:33 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
19:11:33 <lambdabot>         against inferred type ...
19:11:47 <rwbarton> > [ 3 | True ]  :: Maybe Int
19:11:48 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
19:11:48 <lambdabot>         again...
19:11:49 <rwbarton> oh
19:11:59 <rwbarton> Doesn't that exist now?
19:12:06 <Axman6> not in lambdabot
19:12:10 <dmwit> Probably as an extension.
19:12:31 <dmwit> Good luck :set -XMonadComprehensions or whatever in lambdabot. =P
19:12:49 <rwbarton> "hey Caaaaaale"
19:12:56 <rwbarton> Who runs lambdabot nowadays anyways?
19:13:09 <Axman6> Cale does
19:13:14 <Sgeo> Monad comprehensions?
19:13:17 <shachaf> On lispy's machine, I think.
19:13:19 <dobblego> 2
19:13:25 <dobblego> @type \a -> fmap snd . find (\(k, _) -> k a)
19:13:26 <lambdabot> forall t b. t -> [(t -> Bool, b)] -> Maybe b
19:14:45 <monochrom> lambdabot is still at 6.12.3
19:15:11 <Cale> @unmtl ContT r (State s) a
19:15:12 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
19:15:31 <Cale> is it?
19:15:34 <rwbarton> Anyways what I wrote doesn't seem to have been very close to working.
19:16:18 <shachaf> > listToMaybe [3 | True]
19:16:18 <lambdabot>   Just 3
19:16:22 <Cale> oh, yes it is :)
19:18:01 <Cale> @unmtl ContT r (Reader s) a
19:18:01 <lambdabot> (a -> s -> r) -> s -> r
19:21:31 * Sgeo is trouble finding info on monad comprehensions
19:21:31 <Sgeo> :/
19:22:14 <Zarathu> ($) :: (a -> b) -> a -> b
19:22:27 <Zarathu> Super noobie question--can someone explain that type declaration?
19:22:44 <Zarathu> I don't understand why a and b are the same as in the first parameter.
19:23:02 <shachaf> Zarathu: That's how type signatures work.
19:23:09 <shachaf> There's an implicit forall after the ::.
19:23:19 <shachaf> ($) :: forall a b. (a -> b) -> a -> b
19:24:08 <Axman6> Zarathu: it says that ($) takes a function that takes a's and produces b's, and an a and produces a b
19:24:10 <vrook> data KType = K1 | K2 | K3 -- what is the Haskell way to define something like this for KN terms, short of Template Haskell?
19:24:41 <Cale> Zarathu: Well, it takes a function from a's to b's, and a value of type a, and produces a value of type b
19:24:43 <Zarathu> Axman6: Wow, thanks. That makes perfect sense.
19:24:53 <Zarathu> I don't know why I didn't see that before. Probably lack of sleep.
19:24:55 <Cale> oh, Axman6 already said that :)
19:24:58 <Axman6> bam!
19:25:03 <shachaf> Zarathu: Alternatively, it says that ($) takes a function that takes an "a" and produces a "b", and returns a function that takes an "a" and produces a "b".
19:25:04 <Axman6> out-Cale'd
19:25:04 <Zarathu> :)
19:25:17 * shachaf missed the "Super noobie question" part.
19:25:38 <Cale> Zarathu: also it's worth noting that ($) = id, but with a specialised type
19:25:42 <Zarathu> It's cool. I'm half-way through the learn you a haskell book.
19:25:54 <Cale> Where id x = x
19:26:28 <Zarathu> Oh, interesting.
19:26:46 <Zarathu> Identity function with a type.
19:26:49 <Zarathu> Thanks!
19:27:15 <shachaf> ...That's not how you IRC.
19:27:29 <Cale> IRC fail
19:27:30 <Axman6> yeah...
19:27:34 <shachaf> You have to stay in the channel and slowly spend more and more of your waking hours staring at text scroll by.
19:27:53 <shachaf> Eventually you spend 30 hours a day doing nothing but reading messages.
19:32:04 <Sgeo> <kallisti> > deriv (\x -> (+3) * x) (+4)
19:32:09 <Sgeo> > deriv (\x -> (+3) * x) (+4)
19:32:09 <lambdabot>   Couldn't match expected type `a -> a'
19:32:09 <lambdabot>         against inferred type `Data.N...
19:40:42 <vrook> Hm I was missing paredit when writing haskell, so I turned on paredit mode and it works! My emacs mode is now "Haskell Paredit" and it seems pretty cool.
19:41:21 <monochrom> what does paredit do?
19:41:50 <vrook> It lets you deal with parens/brackets in a structured way
19:42:05 <monochrom> ah, I should try that some time
19:42:06 <vrook> I can kill a tuple with one key binding, and paste it somewhere else
19:42:54 <vrook> it's impossible to get unbalanced parens with paredit, in prinicple
19:43:16 <blackdog> i've tried and failed to get into it - find it very hard to understand the movement commands
19:44:15 <vrook> Well lots of things have a learning curve but turn out to be worth it
19:44:23 <monochrom> I just worry that if I write "\"(" it confuses paredit's balancer
19:44:56 <monochrom> in fact also {- ) -}
19:44:59 <vrook> nah, paredit is smart enough to handle that
19:45:01 <blackdog> vrook: also, i don't use all that many parentheses :) if it understood $, maybe..
19:45:20 <vrook> If you are inside quotes and you hit quote, it escapes the quote for you
19:45:40 <vrook> mismatched parens inside a string are ignored
19:46:57 <vrook> What is {- ) -} for?
19:47:00 <vrook> that's hard to google
19:47:04 <monochrom> comment
19:47:35 <vrook> oh you just mean mismatched parens inside a comment?
19:48:13 <vrook> Wouldn't that be invalid English syntax?
19:48:18 <monochrom> probably yes probably no. how about this example:
19:48:21 <vrook> (or whatever language)
19:48:31 <monochrom> > 5 * (2 + {- ) -} 3)
19:48:32 <lambdabot>   25
19:48:50 <monochrom> that's totally valid haskell. will paredit think it is invalid?
19:49:17 <vrook> Right, it's invalid in paredit because the paren is not inside quotes
19:49:25 <vrook> but really that is a major stretch
19:49:29 <monochrom> well that blows
19:49:37 <vrook> ?
19:49:44 <monochrom> > 5 * (2 + {- :-) -} 3)
19:49:45 <lambdabot>   25
19:49:51 <vrook> Do you write comments with mismatched parens often?
19:49:55 <monochrom> that is not so far fetched
19:50:20 <monochrom> do you write :-) in comments?
19:50:26 <vrook> blah, I'd say it's a bonus that paredit is verifying comment
19:51:15 <rwbarton> you just need to balance your :-) with (-:
19:51:32 <vrook> well I'm certainly willing to sacrifice smileys for faster editing. Or write balanced simileys (~ :-)
19:51:41 <dmwit> toupee smiley
19:51:54 <monochrom> who knows, how about matching parentheses in comments but split into two comments? {- ( -} ... {- ) -}? I have some use of those.
19:53:43 <vrook> 80s superman smiley (~ :-)
19:53:45 <monochrom> for example I had 5 * ( 2 + 3 ) and now I want to comment out the parentheses
19:54:41 <vrook> monochrom: it's fine if you comment them out because it's still balanced
19:55:44 <vrook> one of the nice features is lifting/splicing. For instance if you put the cursor on the "+" in your expression and hit M-S, the two parens disappear
19:55:55 <vrook> that's a sexp lift
19:56:11 <ddarius> shachaf: Hey, some of use take a break from those 30 hours and spend 8 doing some good old fashion, honest staring at text.
19:58:03 * Cale comes back and is totally lost about what people are discussing
19:58:40 <monochrom> well I'm still sorry to say that forcing parenthesis balancing in comments is tautamount to outlawing homosexuality. like our late Canadian prime minister said, "the state has no business in the bedroom". well my comments are my bedroom, what's paredit's business in there? don't you impose a law of "it must be a pair of opposite things" on me.
19:58:51 <Cale> oh, I see
19:59:36 <vrook> monochrom: it's just an artifact of paredit not recognizing haskell comments. I'm sure that's easy to fix. You can have unbalanced parens in lisp comments.
19:59:51 <vrook> this is the first time i tried paredit + haskell mode
20:00:11 <vrook> in fact the fix is a one-liner
20:00:26 <vrook> edit the comment regex
20:00:34 <ion> > {- note that {- nested comments must be -} balanced -} 42
20:00:35 <lambdabot>   42
20:00:40 <dmwit> Parsing is hard, let's use regexes.
20:00:47 <monochrom> well you should have said that right at the beginning. rather than defending it with "invalid English" nonsense
20:01:32 * dmwit notes that regexes are insufficient for recognizing Haskell comments
20:01:38 <vrook> And I was responding to "give me smileys or give me death"
20:01:48 <Axman6> dmwit: i was going to say...
20:02:10 <dmwit> Not that any library that calls itself a regex library actually does regexes.
20:02:24 <dmwit> s/does regexes/only does regexes/
20:03:04 <bd_> dmwit: http://code.google.com/p/re2/ this one does.
20:03:28 <dmwit> neat
20:04:04 <vrook> when I said regex I was referring to "--" comments. Regexes aren't used to parse pair-delimited comments, of course.
20:04:50 <Axman6> " RE2 uses automata theory to guarantee that regular expression searches run in time linear in the size of the input." is that possible?
20:04:57 <bd_> yes.
20:05:11 <dmwit> Yes.
20:05:11 <bd_> but only if it's really truly a regular expression, and not a turing machine in regex clothing
20:05:38 <dmwit> Note that this sentence does *not* make any claim about the dependence of runtime on the *regex*.
20:05:42 <dmwit> Only on the string it's searching in.
20:05:58 <Axman6> hmm
20:06:00 <bd_> indeed, the preprocessing tends to be somewhat involved.
20:06:49 <bd_> Axman6: it works because regular expressions are isomorphic to finite state automatons
20:07:04 <bd_> so you build the FSM corresponding to the regex, and just take one edge transition per input character
20:07:33 <Axman6> yeah, i forgetting about how you translate a NFA into a DFA
20:07:41 <Axman6> which would make it linear
20:08:01 <dmwit> The nodes in the DFA are subsets of the nodes in the NFA.
20:08:09 <dmwit> That's basically the entire translation in one sentence; the rest is details.
20:08:35 <Axman6> i was forgetting*
20:08:44 <dmwit> ah
20:08:57 <bd_> note that this implies that the translation from NFA to DFA could require O(2^n) nodes, worst case :)
20:09:05 <monochrom> the DFA can be expoentially as large as the NFA
20:09:17 <bd_> but that's okay, because n is independent of input size, and in practice regexes don't explode like that very often
20:09:48 <monochrom> so, after 10 minutes of building the DFA, you enjoy the linear time efficiency for 1 minute.
20:10:16 * Axman6 assumes we're forgetting about real world hardware for a minute
20:10:25 <bd_> monochrom: re2 was originally designed for google code search, where the DFA is built once, then run over potentially gigabytes of search text, IIRC
20:10:55 <dmwit> The DFA can (and often should) be built lazily.
20:11:26 <dmwit> I suppose everyone here has seen http://swtch.com/~rsc/regexp/regexp1.html
20:11:49 <bd_> dmwit: but then you can't do Hopcroft's algorithm on it :)
20:12:37 <dmwit> Is that minimization?
20:12:41 <bd_> yes
20:12:49 <dmwit> True.
20:16:43 <vrook> is there some secret google experiment where I can do a google search with a regex?
20:17:10 <vrook> this is the feature missing from my life
20:17:45 <vrook> nevermind, most likely not possible
20:18:25 <dmwit> Yeah, I don't think so.
20:18:27 <Axman6> hmm, i think i wrote a small haskell library that implemented tompson NFA's
20:18:38 <bd_> vrook: http://google.com/codesearch unfortunately it'll be shut down in january :(
20:18:38 <dmwit> I can't even imagine how you would start making an index for regex-based search.
20:18:44 <teneen> what's the time complexity of: f = last . reverse
20:18:45 <Axman6> i implemented some regex thing anyway
20:18:59 <nexion> if I do: case words line of (cmd: _) -> ..., will the application of words break up the entire line, or will it stop after the first?
20:19:09 <Axman6> teneen: O(n)
20:19:29 <Axman6> head is O(1)
20:19:51 <teneen> Axman6: I see
20:20:06 <Axman6> > words "this is a sensense\nsplit over several\nlines"
20:20:07 <lambdabot>   ["this","is","a","sensense","split","over","several","lines"]
20:20:21 <ion> > fix ("sen" ++) ++ "se"
20:20:23 <lambdabot>   "sensensensensensensensensensensensensensensensensensensensensensensensense...
20:20:34 <teneen> Axman6: It's not possible to ignore the unevaluated thunk and directly pattern match against the [x] case  in f ?
20:20:41 <dmwit> > head (words ("stops " ++ undefined))
20:20:42 <lambdabot>   "stops"
20:20:49 <Axman6> > (lines >=> words) "this is a sensense\nsplit over several\nlines"
20:20:49 <dmwit> nexion: good ol' laziness, eh?
20:20:49 <lambdabot>   ["this","is","a","sensense","split","over","several","lines"]
20:21:42 <nexion> yeah
20:22:00 <nexion> (cmd : _) -> is the same as "head" behind the scenes, right?
20:22:11 <Axman6> teneen: no, such an optimisation would be quite difficult to implement. the compiler would have to recognise that both list traversals are unneeded. and for infinite lists, head xs /= last (reverse xs)
20:22:12 <byorgey> yep
20:22:14 <ion> but safer
20:22:29 <Axman6> nexion: sort of
20:22:31 <monochrom> both last and reverse are coded to specifically not ignore things
20:23:24 <teneen> Axman6: got it, thanks :)
20:29:03 <xrl> I'm reading from a socket and it's giving me an empty string... this is making my putStrLn go crazy. How should I do a conditional print? case with "" as the noop?
20:29:49 <Axman6> printing an empty string should work fine
20:30:19 <byorgey> maybePutStrLn s | null s = return () | otherwise = putStrLn s
20:32:48 <xrl> Axman6: go crazy as in too many unwanted prints :)
20:34:36 <dmwit> maybePutStrLn "" = return (); maybePutStrLn s = putStrLn s -- seems fine, too, as you suggested
20:35:31 <dmwit> maybePutStrLn s = putStr (s ++ ['\n' | s /= ""]) -- too clever for its own good
20:36:00 <teneen> I'm curious to know why does "last . reverse $ [1..]" eats up all memory. Why is it not garbage-collected?
20:36:18 <teneen> even when compiled with optimisations
20:36:42 <dmwit> last prevents its argument from being garbage-collected
20:37:06 <Axman6> because nothing can be garbage collected, since you need to build the entire list for reverse to return
20:37:24 <dmwit> That's not precisely true. It's the interaction of last and reverse that's preventing garbage collection.
20:37:37 <dmwit> I expect head . reverse $ [1..] would be a tight loop with plenty of collection.
20:37:52 <Axman6> > head . reverse $ [1..]
20:37:54 <rwbarton> @src reverse
20:37:54 <lambdabot> reverse = foldl (flip (:)) []
20:37:59 <Axman6> i don't believe that's true
20:38:15 <lambdabot>   thread killed
20:38:20 <Axman6> since you're basically keep references to everything in the list in the list itself
20:38:41 <Axman6> hmm, actually head . reverse could be optimised nicely
20:39:52 <dmwit> By my testing, it is true.
20:39:55 <teneen> head . reverse also eats up all memory
20:40:00 <vrook> I assume ghc has optimization passes which could look for things like head . reverse? In lisp it's a simple compiler macro.
20:40:35 <Axman6> vrook: we tend to not implement such specific optimisations in the compiler
20:40:40 <dmwit> Yes, you could write a rewrite rule for it if you thought it was important.
20:40:51 <teneen> It's because reverse is strict isn't it?
20:40:58 <dmwit> Nonsense. List fusion is exactly a collection of such specific optimizations.
20:41:01 <Axman6> there _might_ be a rule, but it's unlikely. people just shouldn't be silly enough to write such things ;)
20:41:37 <Axman6> dmwit: that was my point, there's no specific optimisation for head . reverse, but there is list fusion, which is much more general
20:41:55 <vrook> Axman6: hm that's interesting. Because in Lisp things like that can be important because people don't write code -- sometimes code writes code.
20:42:04 <ddarius> List fusion is implemented via rewrite rules, which I would not consider as "in the compiler."
20:42:13 <xrl> what's wrong with my guarded print function here? it still spits out a lot fo "" lines https://github.com/xrl/zmqhs/blob/master/test/recv/RecvOneFrame.hs
20:42:17 <Axman6> is it?
20:42:22 <xrl> line 45
20:42:23 <dmwit> Yes, it is.
20:43:25 <Axman6> xrl: do the strings you're printing have newlines at the end of them?
20:43:36 <ddarius> Rewrite rules should very much be treated like library specific optimizations, but one should endeavor to be sound with them.
20:43:54 <Axman6> because putStrLn adds a newline after printing the string
20:44:14 <xrl> Axman6: yes, they have new lines as expected
20:44:32 <Axman6> then use putStr to stop printing extre newlines
20:44:38 <Axman6> extra*
20:45:35 <xrl> hmm, I'm trying to avoid print when it's an empty string
20:46:09 * hackagebot wai-handler-snap 0.1.1 - Web Application Interface handler using snap-server. (deprecated)  http://hackage.haskell.org/package/wai-handler-snap-0.1.1 (MichaelSnoyman)
20:48:23 <dmwit> xrl: Perhaps rather than matching "", you should test whether it's only whitespace.
20:48:33 <dmwit> ?hoogle white
20:48:33 <lambdabot> Text.Html white :: String
20:48:34 <lambdabot> Text.XHtml.Transitional white :: String
20:48:34 <lambdabot> Text.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
20:48:44 <ddarius> @hoogle isWhitespace
20:48:44 <lambdabot> No results found
20:48:52 <ddarius> @hoogle isWhite
20:48:52 <lambdabot> No results found
20:48:59 <Axman6> @hoogle isSpace
20:48:59 <lambdabot> Data.Char isSpace :: Char -> Bool
20:49:06 <ddarius> I always screw that one up.
20:49:06 <dmwit> > all isSpace "\n \t"
20:49:10 <lambdabot>   mueval-core: Time limit exceeded
20:49:11 <dmwit> > all isSpace "\n \t"
20:49:14 <lambdabot>   True
20:49:24 <Axman6> maybePrint s | all isSpace s = return () | otherwise = putStrLn s
20:49:57 <dmwit> or perhaps you want
20:50:34 <dmwit> maybePrint "" = return (); maybePrint s = putStrLn s; trim = dropWhile isSpace . reverse . dropWhile isSpace . reverse
20:50:44 <dmwit> Then use maybePrint . trim instead of just maybePrint.
20:52:54 <xrl> hmm, I think the empty string might be from a socket close
20:53:08 <vrook> Most of my functions have a StdGen argument and return a StdGen. Is there some way to abstract this? Is Control.Monad.Random is for that?
20:53:19 <dmwit> yes
20:53:47 <vrook> k thanks
20:56:09 * hackagebot control-monad-failure-mtl 0.7.1 - A class for monads which can fail with an error for mtl 1 (deprecated)  http://hackage.haskell.org/package/control-monad-failure-mtl-0.7.1 (MichaelSnoyman)
20:56:11 * hackagebot hack-handler-simpleserver 0.2.1 - A simplistic HTTP server handler for Hack. (deprecated)  http://hackage.haskell.org/package/hack-handler-simpleserver-0.2.1 (MichaelSnoyman)
20:56:13 * hackagebot wai-frontend-monadcgi 0.0.1 - Allows programs written against MonadCGI to run with any WAI handler.  http://hackage.haskell.org/package/wai-frontend-monadcgi-0.0.1 (MichaelSnoyman)
20:59:04 <mgccl> I feel there is a need of a algorithm book build upon Haskell.
20:59:23 <blackdog> mgccl: there's okasaki (although that's generic functional)
20:59:56 <blackdog> (and more data structures than algorithms, now i think about it for more than half a second:)
21:00:32 <mgccl> for example I see no book about graph algorithms in Haskell...
21:00:59 <shapr> I also like Rabhi & Lapalme's Function Algorithms book.
21:01:03 <shapr> Functional*
21:01:21 <Axman6> yeah I'd love to see more about algorithms and data structures in Haskell
21:02:06 <mgccl> and there is Pearls of Functional Algorithm Design by Bird.
21:02:27 <monochrom> there are several Haskell algorithm books
21:02:36 <mgccl> those are the only 3 books that I know of that talk about functional algorithm/data structures
21:03:12 <monochrom> isn't 3 quite enough?
21:03:38 <xrl> how do I act upon null bytestring in a case statement? http://hpaste.org/54691 doesn't like B.null
21:04:31 <monochrom> perhaps use if-then-else instead
21:04:40 <Axman6> if B.null bs then putStrLn "empty" else callback bs
21:04:50 <monochrom> you don't have bytestring's constructors, so you can't pattern-match
21:05:11 <ion> If you want more alternatives than if-then-else provides, case … of bs | BS.null bs -> …
21:05:23 <Axman6> yeah, remember that case is (basically) just for pattern matching on constructors
21:05:37 <monochrom> you could use view patterns, where B.null is the view function
21:06:09 * hackagebot wai-frontend-monadcgi 0.0.2 - Allows programs written against MonadCGI to run with any WAI handler. (deprecated)  http://hackage.haskell.org/package/wai-frontend-monadcgi-0.0.2 (MichaelSnoyman)
21:06:30 <xrl> so I can't do pattern matching on ByteString?
21:06:42 <Axman6> zomg, i don't remember ever seeing this much rain where I love
21:06:45 <monochrom> right, can't
21:06:48 <Axman6> it's been bucketing down all day
21:06:54 <xrl> I think I tried using B.null because thats' how you do guards in erlang ;)
21:07:14 <Axman6> but it's not how you do pattern matching in erlang is it?
21:07:15 <luite> don't love in the rain for too long, you'll get a cold
21:07:19 <monochrom> sure you can use guards
21:07:33 <Axman6> heh
21:09:02 <platzhirsch> I am looking for a term: I don't mean permutation, but permutation + every combination with 1..n elements left out of the set
21:09:35 <xrl> yeah, I can't keep 'em straight sometimes!
21:10:29 <Axman6> > filterM (const [True,False]) "abcd"
21:10:30 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
21:11:00 <Axman6> platzhirsch: that? I think it's called subsets somewhere... i'm probably wrong though
21:12:39 <platzhirsch> Axman6: yes :)
21:12:52 <Axman6> it's not the powerset is it?
21:13:07 <Axman6> i think it might be
21:13:18 <rwbarton> If you pretend lists are sets then it is.
21:13:23 <shapr> Axman6: yes, it's the powerset
21:13:26 <xrl> so the if/else is working... but how should I do the logic for "if data, print it AND recurse. if no data close socket (and go away)"?
21:13:28 <platzhirsch> Axman6: so I guess the permutation of all subsets
21:13:29 * Axman6 wins!
21:13:35 <shapr> Axman6: That computation has an elegant shape.
21:13:44 <shapr> That's one my favorites!
21:13:52 <Axman6> indeed =)
21:14:00 <Axman6> xrl: i'd use bracket
21:14:04 <Axman6> @hoogle bracket
21:14:05 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:14:05 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:14:06 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:15:21 <Axman6> the first IO action is used to acquire a resource, the second closes it, no matter what, and the third will actually use the resource. if an exception is thrown, the resource is guaranteed to be closed, and the exception rethrown
21:15:57 <Axman6> which is basically what you've asked for, plus a bit (you just need a recursive function that exits once it's done with the socket)
21:16:05 <Axman6> @src withFile
21:16:05 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
21:16:10 <vrook> I wonder why type signatures can't be partially specified? I'd like to say foo :: a -> [a] and have "(Eq a) =>" or "(Num a) =>" be inferred.
21:16:38 <Axman6> vrook: because if you need Eq or Num, then that type is wrong! =)
21:16:54 <Axman6> it says the function is more generic than it actually is
21:16:55 <vrook> Axman6: but if I leave out the signature, it's generated fine.
21:17:00 <Axman6> sure
21:17:30 <Axman6> if you specify a signature, it has to either be what the compiler infers, or be more specific/restricted
21:17:59 <vrook> well I don't mean "foo :: a -> [a]" to be literally true. I'd have to note somehow that it's a partially specified type.
21:18:25 <vrook> In other words, I put a constraint on the type inferred. If it's violated, I want to know.
21:18:37 <Axman6> but it's a fully specified type
21:18:59 <vrook> I know, that's why I said it's not literally true. I'd have to note somehow that it's a partially specified type.
21:19:15 <Axman6> -- foo :: a -> [a] :P
21:19:20 <rwbarton> partial type signatures are a topic that comes up pretty often. There are some tricks you can use to emulate them
21:19:29 <rwbarton> http://okmij.org/ftp/Haskell/partial-signatures.lhs
21:19:40 <vrook> like foo :: (SomethingInferred a) a -> [a]
21:19:43 <vrook> oops
21:19:46 <vrook> like foo :: (SomethingInferred a) => a -> [a]
21:20:15 <vrook> rwbarton: cool thanks
21:41:51 <augur> edwardk: hey
21:45:10 <xrl> Any tips on removing the double if/else around line 45? https://github.com/xrl/zmqhs/blob/master/test/recv/RecvOneFrame.hs
21:46:03 <xrl> hmm, I might be looking at this wrong :)
21:47:00 <xrl> I think it's a syntax thing... I want to print and recurse in the else
21:51:41 <edwardk> heya augur
21:52:24 <augur> edwardk: a friend was asking "why monads"
21:52:40 <augur> edwardk: specifically stuff like, why this monad or that
21:52:44 <augur> or when to use monads
21:52:57 <augur> i tried to give him an answer, but he didnt seem satisfied. he was specifically looking at monadic parsing, too
21:53:42 <edwardk> monads for parsing are just convenient. you can use the sugar that you use for everything else
21:54:04 <augur> thats pretty much what i said
21:54:12 <augur> i also mentioned that some monads make things nice and efficient
21:54:26 <edwardk> nothing keeps you from building a completely non-monadic API around a bunch of bad type synonyms, but why go out of your way to make it so you need to learn a new set of abstractions to use your library?
21:54:40 <augur> but i also mentioned that whether you use the monads or not, the monadic properties are there, just not necessarily in a nice efficient way
21:54:48 <augur> im fairly certain thats correct, but im not sure if it is
21:55:14 <edwardk> depends. i can design a parser that isn't and can't be monadic.
21:55:32 <ddarius> edwardk: Want your books?
21:55:40 <edwardk> and it can do some interesting things, but the question is whether or not the extra benefits are worth the interface pain
21:55:54 <augur> edwardk: right no, i just meant that if you opt not to use monads explicitly, and you dont design it in an obviously monad-like way, but still use, say, non-determinism with backtracking
21:56:08 <augur> you're sort of still using list-monadic properties, just not explicitly
21:56:10 <edwardk> ddarius: at some point, though amy and i have both more or less turned in for the night
21:56:19 <ddarius> augur: Cale hits it on the head.  The reason for monads is libraries that operate over arbitrary monads.
21:56:31 <augur> ddarius: yeah :)
21:57:09 <edwardk> i use monads because the moment i discover something is a monad i can usually abstract out some core property of it, make it a monad transformer, and then all of a sudden I get a toolbox, not one tool.
21:57:40 <augur> also, edwardk, do you know of any projects (of any sort!) that aim to encode "theories" and such into a machine readable format?
21:57:44 <edwardk> but even before then, yeah, you get access to everything that can be defined using just the monad/monadplus/applicative/etc APIs as you pick up those bits of functionality
21:57:59 <augur> a friend and i are building a database for linguistics papers, and i'm strongly pushing for encoding as much information about the paper's content as possible
21:58:19 <edwardk> augur: jacques carette has one that he is very actively working on
21:58:20 <augur> including things like what the theoretical account of some phenomenon is, and what the reasoning in the paper is
21:58:51 <augur> ill check out his stuff thanks
21:59:03 <edwardk> i don't know what if any of it is released
21:59:35 <augur> im just looking for ideas about markup and so forth
21:59:50 <ddarius> One notable thing about parsing, is that most of the parsing "combinators," e.g. what is in Text.Parsec.Combinators, can be defined generically for any Alternative.
22:00:01 <edwardk> i keep playing with a design for a (nearly) algebraic theory preprocessor for agda, but i haven't gone much past the 'it would be nice if…' stage ;)
22:00:12 <augur> because like, there are a lot of ideas about how to account for various phenomena, and im not sure really what sorts of things are nice to have marked up
22:00:18 <augur> so im looking for existing examples of such things
22:00:51 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.49.1/doc/html/Text-Trifecta-Parser-Combinators.html implements what ddarius just mentioned
22:01:07 <augur> hmm ok
22:01:09 * hackagebot yesod-examples 0.9.0 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.9.0 (MichaelSnoyman)
22:01:51 <edwardk> many, sepBy, sepEndBy, between, etc. all seem very parsery but require nothing parser specific
22:01:56 <augur> i dont want it to be too formal tho. like, i dont want people to have to provide their theories in MLTT, rght
22:02:12 <edwardk> then i probably can't help much. =)
22:02:15 <augur> :p
22:02:19 <augur> i mean, thats the long term goal!
22:02:24 <edwardk> i tend to veer toward the formal side
22:02:42 <augur> get everyone to use dependent types
22:02:42 <augur> but most existing papers dont
22:02:51 <augur> so i just want a way to represent theories in a fairly neutral way
22:02:58 <edwardk> so you're saying you'd rather be part of the problem than the cure ;)
22:03:08 <augur> haha well
22:03:13 <augur> depends on what you mean
22:03:18 <augur> existing literature is what it is, right
22:03:35 <augur> so i cant force a definition on stuff
22:03:39 <augur> that would be intellectually dishonest
22:03:44 <augur> because then it'd be _my_ interpretation
22:04:31 <edwardk> yes, but this way you can write dozens of papers explaining and motivating your interpretation and contrasting it with others.
22:04:39 <augur> but like, i just mean things like... take the coordinate structure constraint, which in transformational theories is stated something like, "non-ATB movement out of coordinated phrases is bad"
22:04:55 <augur> edwardk: no no my point is not to provide new interpretations
22:05:00 <edwardk> *nods*
22:05:10 <augur> but goal is to make existing literature machine readable
22:05:20 <augur> so that you, the linguist, can go and look at what people have proposed
22:05:53 <augur> and also so you can search existing proposals for similarities, or for particular operations, or whatever
22:06:09 * hackagebot persistent 0.6.4.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.4.1 (MichaelSnoyman)
22:06:11 * hackagebot persistent-postgresql 0.6.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.6.1.1 (MichaelSnoyman)
22:06:22 <augur> so like, maybe you search for all theories that employ ATB movement in one way or another
22:06:57 <augur> so you get the CSC-defined-as-above as one such theory, and also you get some ATB-based non-constituent coordination theories, etc.
22:07:05 <edwardk> just make sure you get enough structure in there that you can say something meaningful or you wind up with something nigh-useless like GOLD, which focused on just providing labels without any real attempt at relating them coherently
22:07:38 <edwardk> i should actually look to see if they every really got anywhere with that
22:08:53 <augur> im looking at some of these papers on GOLD
22:08:58 <augur> they dont really say much..
22:09:08 <edwardk> yep
22:09:51 <augur> it just seems to be a gloss ontology
22:11:01 <augur> which i suppose is useful, but not what i really want
22:11:10 <augur> i mean, such a thing is good, but
22:11:13 <edwardk> pretty much, their main focus when putting it together was 'getting the time zones right' which was a big analogy that got trotted out and used over and over
22:11:48 <augur> yeah. annotating data in a conventional way
22:11:55 <xrl> how can I compress this code? http://hpaste.org/54692
22:12:02 <ddarius> xrl: gzip
22:12:08 <xrl> :)
22:12:21 <augur> which i might adopt, in some way. really, i want conventional ways of representing _ideas_, not just facts
22:12:26 <ddarius> xrl: Look up when/unless.
22:12:36 <xrl> ddarius: thanks
22:12:41 <edwardk> where they kept going back to analogizing over how train travel had been revolutionized by the creation of time zones, which eliminated the problems where each railway company was using different clocks based on their home cities true noon or some such
22:12:48 <ddarius> xrl: And don't repeat yourself.
22:13:01 <edwardk> so they were more concerned with putting names 'in the right ballpark' than with building an ontology you could reason in
22:13:15 <xrl> ddarius: I try not to
22:13:38 <ddarius> xrl: Try harder.
22:14:37 <augur> edwardk: would you find such a tool useful? a repository of linguistic _ideas_, not just facts?
22:14:57 <augur> edwardk: things like analyses of particular sentences/phenomena, representations of accounts, etc.?
22:15:07 <edwardk> not sure. no idea how i'd query it, and if it would be refined enough to actually state something useful
22:16:02 <augur> edwardk: well, part of the question is how would you like to query it :)
22:16:23 <edwardk> dunno. thats really the problem
22:16:57 <augur> well how would _you_ use it! :P
22:17:45 <edwardk> i wouldn't. you're the linguist. ;)
22:17:52 <augur> :P
22:18:01 <edwardk> i'm just some jerk on the internet who makes fun of them
22:18:17 <augur> :)
22:23:24 <augur> i suppose what we would need to have is a collection of examples of different kinds of theoretical proposals, to really get a sense of what kinds of representations would be useful
22:28:19 <augur> edwardk: i think this DB might be the first of its kind, if we can get it up and running..
22:28:26 <augur> which is exciting
22:28:36 <edwardk> good luck
22:28:43 <augur> :p
22:28:47 <edwardk> i say that in all seriousness actually
22:29:51 <edwardk> now that i've gotten skyrim out of my system i need to get back to playing with the version control monad =)
22:30:01 <augur> unrelatedly, have you read anything on MCFGs or tree transducers for displacement?
22:30:17 <edwardk> not that i can place offhand
22:30:22 <shachaf> edwardk: So *that's* why you've been absent from IRC.
22:30:30 <edwardk> haha
22:30:55 <augur> im reading a paper by Graf thats really interesting. its about computing comparison sets from trees, and it uses tree transducers
22:30:56 <edwardk> that, spending some time with my wife, etc.
22:31:05 <augur> and its fascinating how its going this displacement stuff
22:31:27 <edwardk> *nods*
22:31:44 <companion_cube> does anyone have an advice on a simple way to send commands to some haskell script (which is going to run in background)?
22:31:49 <augur> like, the bottom up transduces work by annotating trees with "state" nodes, and then pushing state nodes up to the top
22:32:10 <edwardk> the transducer stuff is more familiar to me from bioinformatics, but *nods*
22:32:41 <augur> so something like "who did john see" starts out as you'd expect: "john saw who", and then the "who" node transduces as q_wh(t), "saw" transduces as q*(saw)
22:33:09 <augur> and then you have vp(q*(saw), q_wh(t)) --> q_wh(vp(saw, t))
22:33:16 <edwardk> companion_cube: you could always have it stream in input from a named pipe or a file and just feed it new content by writing to the other hand of the pipe or to the file
22:33:16 <augur> so the q_wh propagates upwards
22:33:20 <augur> until you have something like
22:34:10 <augur> q_wh(c(x,y)) -> q*(cp(who, c(x,y)))
22:34:32 <companion_cube> edwardk: why not, if creating a named pipe is easy enough (especially in cases the pipe file may already exist)
22:35:04 <hpaste> z annotated “How to compress?” with “How to compress? (annotation)” at http://hpaste.org/54692#a54694
22:36:43 <edwardk> z's paste reminds me i need to dust off that old range compressor of mine and make a monad for feeding it
22:37:07 <edwardk> i was thinking about it and then… skyrim
22:37:30 <augur> edwardk: i dont get skyrim :(
22:37:34 <augur> its totally not my kind of game
22:38:03 <augur> afaict, it basically can be summarized as... find stuff, kill thing, repeat
22:38:08 <edwardk> augur: *shrug* i just needed something to repurpose a bunch of neurons for a while to get me out of a rut. so a week of mindless dragon bashing was just what the doctor ordered
22:38:16 <Jafet> Good. Then you'll have about 100 more hours in your life
22:39:17 <shachaf> Jafet: And about *1000* fewer utils!
22:40:28 <edwardk> i just wish the completionist in me would let me play through things with cheat codes, suck the marrow out of the plot and toss it to the wayside that much faster
22:40:48 <augur> edwardk: lol. well, skyrim is not a game for completionists, surely
22:40:51 <augur> since its infinite :)
22:40:56 <edwardk> augur: i'm guessing you never got nethack either? =)
22:41:05 <augur> never even looked at nethack, actually
22:41:08 <augur> im not really a game person
22:41:28 <augur> the only game i play on a semi-regular basis these days is wipeout and halflife
22:41:37 <augur> admitedly, those are pretty simple too
22:41:42 <augur> halflife has a nice milieu tho
22:42:13 <edwardk> nethack is one of those games that you learn to love or hate because it directly tramples on modern video game sensibilities. instead of making it impossible to get into unwinnable situations, getting into them is a large part of the game
22:42:28 <zeiris> Nethack starts crossing into a sandbox story generator, more than a typical game.
22:42:31 <edwardk> another game that i loved like that was 'star control 2'.
22:42:31 <augur> i really enjoy urban environments, and a sense of ominous threads that engender paranoia
22:44:05 <edwardk> i like puzzle games, chess, go, etc. but its hard to find good puzzle games that don't 'cheat'. Cheat in the sense that they expect you to click around the room mindlessly for a half hour to inflate your play time, or guess some magic word, etc.
22:44:05 <xrl> ddarius: just the tip I needed, thanks again. I'll spend some more time digging through the control monads
22:44:36 * Jafet steals no tea from edwardk.
22:45:09 <shachaf> Jafet: I'm not quite sure that edwardk possesses common sense.
22:45:34 <edwardk> common sense is vastly overrated and far less common than one would expect ;)
22:45:36 <xrl> edwardk: machinarium has a minimum of cheating... still a little tho
22:46:13 <edwardk> machinarium did require a lot of 'clicking mindlessly around the room' though
22:47:34 <edwardk> i tend to prefer things closer to the manufactoria end of the spectrum
22:47:38 <xrl> edwardk: I thought the puzzles were pretty clever on the whole. better than mashing around disc world
22:47:44 <edwardk> http://pleasingfungus.com/#!/Manufactoria
22:47:52 <edwardk> xrl: it was one of the better examples of its breed
22:50:45 <edwardk> braid was another good example of a game that i didn't feel wasted my time. it only lasted a few hours but they were fun hours
22:50:48 <ddarius> Star Control 2 was just a lovable game.
22:51:34 <edwardk> the crushing inevitability of defeat in SC2 when you realize that all along you've been 'playing the wrong game' is just amazing
22:51:40 <shachaf> edwardk: Clearly you didn't collect all the stars. :-)
22:51:52 <edwardk> shachaf: i did, second play through =)
22:52:01 <edwardk> that 2 hour one is a pain in the butt
22:52:25 * ddarius doesn't know why his :hover selector is not working.
22:52:26 <shachaf> edwardk: That's the one I was thinking of, yes.
22:52:31 <edwardk> that and i didn't figure out the irreversible trick on my first playthrough
22:53:59 <edwardk> for those who are wondering about the game, SC2 was re-released as open source a decade or so ago: http://sc2.sourceforge.net/
22:54:58 <shachaf> Machinarium was quite a nice game, in its particular way, but it was *full* of hunt-the-pixel.
22:56:00 <Jafet> Most point-and-click games suffer from hunt-the-pixel.
22:56:10 <shachaf> Yep.
22:56:26 * shachaf tries to recall whether the Neverhood had a hunt-the-pixel problem.
22:56:54 <shachaf> I think it just had an "uninteresting puzzles" problem. Well, some of the puzzles, anyway.
22:56:57 <edwardk> cogs was another example of a very short game that i didn't feel wasted my time
22:57:04 <shachaf> Still a great game, but not so much because of the puzzles. :-)
22:57:08 <Jafet> It's kind of like saying that shooter games suffer from unnecessary violence--you just accept that it's true, and rate them on other merits
22:58:08 <edwardk> similarly portal, portal 2. its possible to make a good puzzle game without padding out the clock with pixel hunts. =/
22:58:25 <augur> oh man portal
22:58:29 <augur> portal is so good
22:58:50 <shachaf> edwardk: Portal 2 had a lot of contrived puzzles.
22:59:18 <shachaf> Including pseudo-pixel-hunts like "there's a 1x1 white square on the other side of the map; find it".
22:59:35 <edwardk> shachaf: just buy a higher resolution monitor ;)
23:00:49 <platzhirsch> If you have k mappings: a_1 -> { ... } a_2 -> { ... }, ..., a_k -> {...} and you want to consider all combinations of the a in which they choose one element, how do you express this? In other words, what is the term for this?
23:01:15 <platzhirsch> in an imperative language, I would build k for-loops, but this is not possible
23:01:28 <edwardk> platzhirsch: why not?
23:01:39 <Jafet> @faq can you build k for-loops in Haskell?
23:01:39 <lambdabot> The answer is: Yes! Haskell can do that.
23:01:44 <platzhirsch> edwardk: well, of course it is possible
23:02:06 <platzhirsch> I am just looking for the right term which describes this problem
23:02:23 <Jafet> > sequence [[1,2,3], [4,5,6], [7,8,9]]
23:02:24 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
23:02:40 <platzhirsch> well, actually n-for loops gets me some results on Google :P
23:02:48 <Jafet> There are multiple ways to look at a problem, so we can't tell you what you think your viewpoint is
23:03:06 <platzhirsch> Jafet: pointing me out sequence will help a lot :)
23:03:13 <Jafet> sequence uses the nondeterminism property of the list monad
23:03:27 <edwardk> platzhirsch: you can use other equivalent approaches as well
23:03:35 <Jafet> And not the "k for-loops" viewpoint
23:03:39 <edwardk> > (,) <$> [1,2,3] <*> [4,5,6]
23:03:40 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:03:59 <lukish> @pl  (\x -> map snd $ sort $  zip x [1..(length x)])
23:03:59 <lambdabot> map snd . sort . ap zip (enumFromTo 1 . length)
23:04:08 <platzhirsch> > (,) <$> [1,2] <*> [1,6]
23:04:09 <lambdabot>   [(1,1),(1,6),(2,1),(2,6)]
23:04:58 <edwardk> > liftA2 (,) [1,2] [1,4]
23:04:59 <lambdabot>   [(1,1),(1,4),(2,1),(2,4)]
23:05:18 <platzhirsch> the only problem is, I have to express it in an imperative language :P
23:05:26 <edwardk> why? =)
23:05:27 <shachaf> @@ @run @run (\n -> var $ "liftM" ++ show n ++ " (" ++ replicate (n-1) ',' ++ ") " ++ concat (replicate n "[1,2,3] ")) 5
23:05:30 <lambdabot>   [(1,1,1,1,1),(1,1,1,1,2),(1,1,1,1,3),(1,1,1,2,1),(1,1,1,2,2),(1,1,1,2,3),(1...
23:05:57 <platzhirsch> edwardk: it isn't I am just tired
23:06:00 <platzhirsch> meh
23:06:28 <edwardk> shachaf++
23:06:50 <edwardk> heya samy
23:07:07 <augur> oh, edwardk
23:07:19 <platzhirsch> > (,) <$> [1,2] <*> [1,6] <*> [3,5]
23:07:20 <lambdabot>   Couldn't match expected type `a -> b'
23:07:20 <lambdabot>         against inferred type `(a1, a...
23:07:21 <lukish> > map snd . sort . ap zip (enumFromTo 1 . length) [1..3]
23:07:22 <lambdabot>   Couldn't match expected type `[(a, b)]'
23:07:22 <lambdabot>         against inferred type `(a1,...
23:07:25 <augur> do you know anything about learning definitions for propositions/relations?
23:07:37 <edwardk> > (,,) <$> [1,2] <*> [1,6] <*> [3,5]
23:07:37 <lambdabot>   [(1,1,3),(1,1,5),(1,6,3),(1,6,5),(2,1,3),(2,1,5),(2,6,3),(2,6,5)]
23:07:43 <augur> or perhaps another way of putting that is, "curve fitting" for non-numerican data?
23:07:47 <augur> .. non-numerical
23:08:05 <jessopher> huhu numerican
23:08:16 <edwardk> a fair bit
23:08:24 <augur> edwardk: do tell!
23:08:35 <edwardk> though you probably will have to grab me when i'm less bleary eyed
23:08:36 <shachaf> You have thirty seconds, edwardk; tell us everything.
23:08:57 <augur> edwardk: well, i just need some topic names, or people, or paper names
23:09:00 <edwardk> start with something like weka
23:09:06 <augur> oh no thats not what i mean
23:09:42 <augur> what im looking for is something that will discover a non-probabilistic "best fit" definition
23:10:10 <edwardk> a good reference for non-numerical regression-like techniques is julian faraway's books on regression modeling in r
23:10:13 <edwardk> they keep changing titles
23:10:14 <edwardk> one sec
23:10:21 <augur> so like, you give it some trees or whatever, and say that a predicate P holds of them, and it tries to find a definition for P (possibly recursive in some way) that holds for as many trees as possible
23:10:37 <edwardk> *nods*
23:10:46 <KirinDave> Man, this is a fascinating discussion
23:10:49 <KirinDave> http://www.azulsystems.com/blog/cliff/2008-05-27-clojure-stms-vs-locks
23:11:10 <augur> edwardk: ive heard of statistical relational learning, which im looking into
23:11:15 <edwardk> look for something like IgorII
23:11:17 <augur> but im curious if theres any other stuff
23:11:36 <augur> "inductive program synthesis"
23:11:36 <augur> ok
23:11:43 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.180.2245
23:11:47 <KirinDave> But it really strikes me when they bring up Clojure's STM doesn't compose. It's such a stark contrast to Haskell's STM, where composition is ludicrously good.
23:11:59 <augur> edwardk: cool. ill take a look :)
23:12:00 <augur> thanks
23:12:19 <augur> my goal is to have something in my linguistics toolkit that linguists can use sort of like physicists use curve fitting, you know?
23:12:48 <edwardk> augur: and btw- you can speed up that approach about an order of magnitude better than what they do in that paper. i did so a year or so back for some metabolomics researchers
23:13:10 <edwardk> *nods*
23:14:05 <augur> edwardk: what about predicate/relation discovery? do you know of any techniques for looking at non-numerical data and _positing_ the existence of something?
23:14:23 <edwardk> the problem is defining the search space.
23:14:35 <ibid> any lun maintainers here?
23:14:39 <edwardk> that takes almost as much domain knowledge as positing it yourself sometimes ;)
23:14:46 <edwardk> ever read koza?
23:14:46 <augur> hmm
23:14:50 <augur> no whosat
23:15:15 <edwardk> http://www.amazon.com/Genetic-Programming-Computers-Selection-Adaptive/dp/0262111705
23:15:29 <vrook> Is there a haskell counterpart to lisp's "constantly"?  constantly x = \_ -> x
23:15:58 <augur> edwardk: ill check it out. the cover is beautiful, which suggests nothing but makes me want to read it anyway
23:15:59 <augur> :D
23:16:05 <augur> vrook: yes, const.
23:16:09 <augur> vrook: const x _ = x
23:16:12 <edwardk> that whole book is about how to define GAs and GPs given suitable fitness functions that search through large problem spaces
23:17:01 <vrook> augur: ah, thanks. i need better googling skills it would seem.
23:17:20 <vrook> though google is fucked up with a blue bar now
23:17:31 <edwardk> augur: anyways those two papers should give you at least the right frame of reference for the problem
23:17:47 <edwardk> well paper and book
23:18:48 <edwardk> beyond that you'll do a lot of fishing. starting with something like russell and norvig just to get your head around the space might not be a bad investment
23:19:17 <edwardk> http://www.amazon.com/Artificial-Intelligence-Modern-Approach-3rd/dp/0136042597/ref=sr_1_1?s=books&ie=UTF8&qid=1322638740&sr=1-1 i think the copy i have is a version or two behind that. i don't recognize the garish cover, but its the right content
23:19:26 <mroman> Seems like the mingw/gcc deployed with the win-haskell-plattform has no support for sockets?
23:19:52 <mroman> hsql-postgresql does not build due to netdb.h missing.
23:20:09 <augur> edwardk: my long term goal is to do something like figure out a way to automate as much of the linguistic theorizing process as possible
23:20:48 <augur> edwardk: which has interesting problems, because the theories depend on what you think the structures are
23:20:54 <augur> both on a small scale
23:20:59 <edwardk> its a laudable goal. i'm just too cynical to think it can be done. ;)
23:21:01 <augur> so within a research program what the structures are
23:21:09 <augur> and on a large scale, between research programs
23:21:41 <mroman> anybody got hsql-postgresql working on windows?
23:23:38 <edwardk> once you start talking about systems that can reason about multiple mutually contradictory "microtheories" you start looking at systems like Lenat's Cyc. (He was my AI advisor's advisor.)
23:24:10 <augur> i dont want mutual contradiction
23:24:12 <edwardk> but then you need to go off and play with paraconsistent logics, etc.
23:24:30 <augur> i just mean different levels of reasoning
23:25:14 <augur> like, if you think that trees are a substantive thing, then you analysis of a phenomenon depends on what you think the trees for such and such sentence is
23:25:52 <augur> so theres two "dimensions" of variation -- the structure of the sentence, and the theory that operates over such structures
23:27:36 <augur> but theres also a more macroscopic dimension: what _sorts_ of structures are relevant -- trees? dependencies? no structure at all (like in cg's)? higher-order graphs (like in APG)?
23:28:28 <augur> and even within a tree-oriented theory, for instance, you have non-tree based "structure"
23:28:58 <augur> actually that might be the right approach -- think of everything, even tree structure, as the same sort of thing -- relations over whatevers
23:29:34 <augur> and if trees arent actually relevant, you should be able to continue to modify your theory to ignore the tree structures
23:30:03 <augur> hmm
23:31:01 <vrook> Is there a way to write this as a single map?   map g $ map (f 9) [1 .. 4]
23:31:24 <vrook> I want to compose with a partial left over
23:31:27 <cwl> @src fix
23:31:27 <lambdabot> fix f = let x = f x in x
23:31:31 <ion> map (g . f 9) [1 .. 4]
23:32:12 <augur> vrook: for any functions f, g, its true that   map f . map g == map (f . g)
23:32:32 <augur> and i believe this is provable by equational reasoning in haskell!
23:32:44 <vrook> hm interesting, thanks. I was thinking that (g . f) 9 was the only valid construct
23:33:02 <cwl> fix (\x -> x*x)
23:33:11 <cwl> > fix (\x -> x*x)
23:33:15 <lambdabot>   mueval-core: Time limit exceeded
23:33:31 <cwl> > fix (\x -> x*x)
23:33:34 <lambdabot>   mueval-core: Time limit exceeded
23:36:20 <cwl> > fix (const "hello")
23:36:20 <lambdabot>   "hello"
23:37:34 <augur> cwl: what are you trying to do
23:39:40 <cwl> augur: want to know how fix works
23:39:50 <augur> cwl: it works like you see!
23:40:18 <augur> ignore the let statement for a moment and pretend we have this definition
23:40:21 <augur> fix' f = f (fix' f)
23:40:33 <cwl> it applies f infinitely
23:40:35 <augur> the let exists for efficiency reasons, i think
23:40:41 <augur> yes, it applies f infinitely!
23:40:54 <augur> for any f, fix' f = f (f (f (f ...)))
23:40:55 <cwl> how it know when to stop
23:41:00 <augur> cwl: well it doesnt!
23:41:04 <augur> but haskell is lazy
23:41:08 <augur> so it only evaluates things if it needs do
23:41:11 <augur> needs to*
23:41:14 <vrook> Is there some variation of fix (\x -> x*x) which produces [1]?
23:41:15 <augur> so consider const "hello"
23:41:33 <augur> fix (const "hello") = const "hello" (const "hello" (const "hello" ...))
23:41:39 <augur> but look at the definition of const
23:41:41 <augur> const x _ = x
23:41:47 <augur> the second argument is _never_ needed
23:41:54 <augur> so haskell will never look at it
23:42:14 <augur> so when you evaluate   fix (const "hello")   one step, you get   const "hello (fix (const "hello"))
23:42:46 <augur> and thats as far as haskell goes in evaluating the infinite stack of const "hello"'s
23:42:52 <augur> because thats as far as haskell _needs_ to go
23:43:13 <augur> once it gets to   const "hello" (fix (const "hello"))   haskell evaluates that, and the definition says return the first thing
23:43:15 <augur> ignore the second thing
23:43:18 <augur> so it returns "hello"
23:43:26 <cwl> const "hello" is easy to understand
23:43:35 <augur> now with   fix (\x -> x*x)
23:43:39 <cwl> but others like \x -> x*x
23:43:41 <augur> just expand it!
23:43:42 <cwl> ok
23:43:53 <shachaf> augur: Those parentheses there after the "..." are silly.
23:44:01 <augur> shachaf: hush :P
23:44:12 <augur> cwl:   fix (\x -> x*x)   =>   (fix (\x -> x*x)) * (fix (\x -> x*x))
23:44:20 <augur> so now haskell has to evaluate the multiplication
23:44:27 <vrook> How do we get haskell to tell us that [1] is the answer to fix (\x -> x*x) ?
23:44:29 <augur> but how does haskell do that? well, it evaluates the arguments
23:44:49 <augur> cwl: so...   (fix (\x -> x*x)) * (fix (\x -> x*x))   =>   ((fix (\x -> x*x)) * (fix (\x -> x*x))) * ((fix (\x -> x*x)) * (fix (\x -> x*x)))
23:44:59 <augur> and it just keeps expanding
23:45:11 <augur> because there's never a point where the evaluation can just ignore something
23:45:16 <augur> so it never just stops
23:45:19 <shachaf> vrook: [1] *isn't* the answer to fix (\x -> x*x).
23:45:21 <augur> vrook: 1 _isnt_ the answer!
23:45:44 <cwl> but 1 is the fix point of \x -> x*x
23:45:45 <shachaf> vrook: fix always gives you the least fixed point, where "least" is in terms of definedness.
23:45:51 <augur> vrook: perhaps what you mean is how do we discover that 1 is _a_ fixed point of that function
23:45:56 <augur> but thats not what fix does
23:45:59 <shachaf> cwl: But it's not the least fixed point. The least fixed point is _|_, i.e., an infinite loop.
23:46:08 <augur> cwl: also, 0 is a fixed point of  \x -> x*x too
23:46:10 <shachaf> Because (undefined * undefined) == undefined
23:46:12 <vrook> yes, i mean metaphorically the answer to the fix equation
23:46:13 <applicative> cwl, so is 0, so is _|_ which is the answer youre getting
23:46:21 <augur> vrook: computations are not metaphorical :)
23:46:35 <vrook> but irc conversations can be
23:46:42 <cwl> what is _|_
23:46:44 <shachaf> vrook: "fix" is well-defined and not metaphorical at all.
23:46:49 <applicative> undefined
23:46:49 <shachaf> @wiki Bottom
23:46:50 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
23:46:50 <augur> cwl: _|_ is "undefined", basically
23:46:57 <shachaf> Sort of.
23:46:59 <vrook> it's one of those "you know what I mean" things
23:47:01 <augur> sort of, yeah.
23:47:08 <augur> vrook: well, you asked about haskell. so..
23:47:31 <vrook> but indeed you knew what i meant
23:47:44 <shachaf> vrook: *We* know what you mean, but the function doesn't, because it gives you the least fixed point.
23:47:47 <augur> i knew you meant haskell!
23:48:03 <augur> the question of how to find a fixed point is a mathematical issue
23:48:04 <vrook> so how do we get haskell to give us [1]?
23:48:08 <shachaf> vrook: And I'm pretty sure that in general figuring out the fixed point of a function is undecidable.
23:48:15 <shachaf> vrook: const [1]
23:48:22 <augur> vrook: you cant get haskell to give you 1 using fix
23:48:24 <cwl> what is *least* fixed point
23:48:28 <applicative> > take 1 (fix (1:))
23:48:29 <lambdabot>   [1]
23:48:42 <augur> cwl: that depends on what the domain of the function is
23:48:57 <augur> cwl: if the domain of the function is the natural numbers, the least fixed point of \x -> x*x is 0
23:49:00 <cwl> undefined is the least?
23:49:28 <applicative> yes it is the secret sauce introduced into ever type
23:49:29 <augur> cwl: but if your domain is omega-CPOs (which i think is what haskell uses), then the least fixed point is _|_
23:49:31 <applicative> every type
23:49:54 <applicative> @type undefined
23:49:54 <lambdabot> forall a. a
23:50:00 <vrook> I was thinking a list comprehension could somehow produce [1], but then I realized that I was confusing a mathematical set notation with list comprehension.
23:50:02 <ddarius> Haskell doesn't specify a semantics.
23:50:18 <augur> ddarius: sure. fair enough.
23:50:35 <augur> any semantics sufficiently capable of handling non-termination in the relevant way :p
23:50:40 <augur> one of which is omega-CPOs, i think.
23:50:42 <vrook> { x = x*x | x in R } is {1}
23:50:47 <augur> will give you the bottom value
23:50:51 <augur> vrook: no its not
23:51:12 <applicative> > filter (\x -> x == x * x) [0..]
23:51:15 <lambdabot>   mueval-core: Time limit exceeded
23:51:18 <augur> also, thats a different problem than what you asked for, vrook
23:51:27 <applicative> > filter (\x -> x == x * x) [0..20]
23:51:28 <lambdabot>   [0,1]
23:51:36 <augur> vrook: {x | x = x*x, x in R } = {0, 1}
23:52:04 <cwl> [ x = x*x | x <- [0..] ]
23:52:09 <cwl> > [ x = x*x | x <- [0..] ]
23:52:10 <lambdabot>   <no location info>: parse error on input `='
23:52:29 <applicative> > [ x == x*x | x <- [0..20] ]
23:52:29 <lambdabot>   [True,True,False,False,False,False,False,False,False,False,False,False,Fals...
23:52:29 <cwl> [ x | x = x*x, x <- [0..] ]
23:52:31 <Sgeo> I think I found a way to encode at-most in the type
23:52:33 <augur> > take 10 [x | x <- [0..], x == x*x]
23:52:35 <Sgeo> Can at-least be encoded?
23:52:35 <vrook> augur: right, I was sloppy. Believe it or not I got an A in topology.
23:52:37 <lambdabot>   mueval-core: Time limit exceeded
23:52:43 <augur> hm
23:52:47 <augur> > take 2 [x | x <- [0..], x == x*x]
23:52:47 <lambdabot>   [0,1]
23:53:06 <cwl> :O
23:53:06 <Jafet> I'm not actually sure what to tell people like vrook, who ascribe mythical qualities to computers.
23:53:06 <augur> theres only 2, so it makes sense i guess that it'd choke at 10
23:53:07 <augur> but
23:53:23 <ddarius> Sgeo: The type level (with -fundecidable-instances) is Turing-complete, and pretty computationally powerful even without undecidable instances.
23:54:19 <Sgeo> I don't think I'm quite doing type-level computation
23:54:19 <augur> vrook: haskell isnt going to be able to give you the answer you looking for by using fix, or anything like that
23:54:23 <Sgeo> Since values are involved
23:54:39 <augur> vrook: what you want is something that can actually do fixed point proofs. fix doesnt do such a thing
23:54:54 <augur> all fix does is compute the least fixed point
23:54:59 <ddarius> Sgeo: Type classes connect types and values.
23:55:13 <Sgeo> And I wasn't using type classes
23:55:17 <augur> using your haskell compiler's semantics to do so.
23:55:25 <ddarius> In particular, it computes the least fixed point in the information order.
23:56:08 <Sgeo> What I'm thinking is that [[[()]]] means at-most 2 in the type, since [], [[]], and [[[]]] (0, 1, and 2) can fit into that type, but [[[[]]]] (3) can't
23:56:35 <ddarius> Sgeo: And what about [[],[]]?
23:57:26 <Sgeo> ddarius, well, I guess that is treated the same as [[]], but the reason I'm using lists and not maybe is because they're easier to type >.>
23:58:11 <ddarius> Sgeo: Treated the same as [[]] by what?  And how is that any different than saying all multiples of 2 are treated the same?
23:58:23 <ddarius> (all multiples of 2 for an Integer, say)
23:58:35 <Sgeo> By the type, whether or not it fits the tye
23:58:36 <Sgeo> type
23:59:23 <Jafet> vrook: http://blog.ezyang.com/2010/12/how-i-learned-to-stop-worrying-and-love-the-bottom/
23:59:33 <ddarius> Sgeo: How is this any different from Integer, other than being completely unintuitive and extremely inefficient?
