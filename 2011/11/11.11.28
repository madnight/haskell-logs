00:41:54 <accel_> does haskell have something like maxima? i.e. something that can do basica symbolic algebra + taylor series + simple derivations
00:42:21 <xrl> anyone know why https://github.com/xrl/zmqhs/blob/master/test/recv/RecvOneFrame.hs wouldn't work with https://github.com/xrl/zmqhs/blob/master/test/c/oneframe/oneframe.c ? it's a server which isn't receiving and I think it's my use of the TCP stack
00:49:47 <xrl> oh, using telnet shows that my haskell code is working :)
00:53:44 <xrl> ahem, totally my fault. got it working :)
00:56:24 <gienah> xrl: looked like it should use System.ZMQ.bind to me
00:58:20 <xrl> gienah: I'm writing a pure zmq library. but I'll take it under advisement! :)
00:58:52 <gienah> xrl: ok, cool
01:14:39 <mm_freak> i'd like to link to a webpage/blog that explains well why imperative programming experience will make it more difficult to learn haskell…  does anyone know one?
01:29:31 <erus`> my intelligent comments on reddit get about 2 upvotes. My retarded ones get 100
01:30:05 <lukish> erus`: same stuff on stackoverflow
01:31:30 <User314> hey does anyone here know C?
01:31:41 <erus`> meee
01:31:49 <User314> hows it going?
01:32:02 <erus`> you need help?
01:32:05 <User314> yeah
01:32:14 <User314> i have been stuck on this problem for hours
01:32:20 <User314> it may seem simple to you
01:32:25 <User314> im a begineer
01:33:53 <erus`> ask away
01:33:54 <User314> ok heres the problem: http://pastebin.com/0ZDw4UqU
01:33:56 <mauke> The paste 0ZDw4UqU has been copied to http://hpaste.org/54593
01:34:23 <erus`> User314: line 16 you need return false
01:34:46 <erus`> or just put return (ch >= '0' && ch <= '9');
01:35:13 <User314> yeah i tried doing that
01:35:16 <User314> but down in the program
01:35:18 <blackdog> User314: in the spirit of teaching a man to fish: what does the compiler say when you try to compile it?
01:35:34 <User314> Warning comparison between pointer and integer
01:35:48 <User314> im trying to see if the user entered a number or a letter
01:35:59 <User314> i cant seem to get it work
01:36:03 <User314> its driving me crazy
01:36:03 <erus`> User314: if (isDigit(ch) == true )
01:36:14 <erus`> :)
01:36:29 <User314> ahhh there we go
01:36:30 <User314> thanks man
01:36:33 <User314> how did u know that
01:36:41 <User314> ujust saved my life
01:36:42 <blackdog> User314: pro tip: compile with -Wall and fix everything
01:36:43 <erus`> hardcore nerd skills
01:36:56 <User314> lool nerds ftw
01:37:08 <User314> what is -Wall
01:37:10 <User314> illl try that out
01:37:12 <User314> im a noob at this
01:37:52 <User314> erus, what subject is that
01:38:23 <User314> how come i needed the (ch)
01:38:39 <erus`> because you compare the result of the function with true
01:38:39 <blackdog> User314: it means "tell me about all the things that seem sketchy to you, even if it wouldn't stop you compiling my program"
01:39:39 <erus`> isDigit is a function. isDigit(ch) evaluates to a boolean
01:40:01 <erus`> User314: can you write code in haskell?
01:40:19 <User314> no, but i am planning to soon once i got comfortrable with c
01:40:41 <User314> ahh ok i understand
01:40:43 <User314> but now
01:40:47 <User314> even if i type a letter
01:40:59 <User314> my printf is saying its a digit
01:41:43 <User314> Nevermind
01:41:52 <User314> i forgot to make my else statement different
01:41:53 <User314> lol
01:50:08 <Blkt> good morning everyone
01:52:57 <User314> morning
01:53:13 <User314> How would i make a lower case to a upper case letter in C ?
01:53:28 <cheater> ask in ##c
01:53:35 <User314> i need a invitation
01:53:40 <User314> right??
01:53:54 <cheater> no you just need to register with nickserv
01:54:07 <User314> ohh
01:54:17 <User314> im new to this stuff
01:54:22 <User314> does it say the instructions
01:54:24 <User314> when i enter
01:54:30 <cheater>  /msg nickserv help
01:54:53 <User314> k thanks
02:00:50 <erus`> are they as nasty in #C as in #C++
02:08:57 <Jafet> They're not nasty; their niceness is just distributed over more people
02:11:24 <jessopher> and diluted by a sea of pendantic hubris
02:12:14 <jessopher> thats what happens when you are a christian and your compiler is a lion
02:13:04 <jessopher> im not sure who the romans are in this analogy, maybe your boss
02:27:38 <mm_freak> @remember <Jafet> They're not nasty; their niceness is just distributed over more people
02:27:38 <lambdabot> Good to know.
02:28:29 <lukish> How can I get [(1,2),(3,2)] from [1,3,1,3] ?
02:28:49 <Jafet> f [1,3,1,3] = [(1,2),(3,2)]
02:29:00 <blackdog> Jafet: just waiting for that one...
02:29:10 <blackdog> lukish: more seriously, try sorting it then grouping it
02:29:11 <Jafet> It's obligatory
02:29:32 <blackdog> then you should be able to see the last step yourself
02:29:33 <lukish> It's O(n^3)
02:29:43 <blackdog> no it isn't.
02:29:56 <lukish> sorting is O(n^2)
02:30:00 <blackdog> sorting is n log n, grouping is n.
02:30:11 <Jafet> Heh
02:30:12 <blackdog> and they're repeated, not multiplied
02:32:19 <lukish> > map ((&&&) head length) $ group $ sort [1,3,1,3]
02:32:19 <lukish> [(1,2),(3,2)]
02:32:20 <lambdabot>   [(1,2),(3,2)]
02:33:46 <thetrav> the haskell platform has GHC 6 or higher included in it right?
02:33:53 <sipa> yes
02:34:01 <thetrav> cool, thanks
02:55:44 <mm_freak> is 'listen' supposed to add the output to the global writer log, too?
02:55:58 <mm_freak> or are you supposed to use 'tell' for that?
02:57:55 <mm_freak> ok, supposedly it still adds the output to the global log
03:03:47 <erus`> @hoogle (&&&)
03:03:47 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
03:17:25 <Axman6> hmm, there's no extension for running an arbitrary program on some haskell source before passing it to ghc is there? seems like it could be useful to have a language pragma, that would let people write their own preprocessors. (seems this could be more ellegant than TH)
03:18:22 <cheater> sounds like a plan
03:19:32 <Jafet> Uh, you can probably do that in cabal
03:20:22 <Axman6> probably, but it seems like an odd place to put it to me. we've got the CPP pragma, why not PREPROCESS "progname"
03:21:14 <ion> {-# PREPROCESS "tac" #-}
03:30:17 <cheater> um
03:30:27 <cheater> i think it shouldn't be any shell command
03:30:39 <cheater> if you want to interact with the system the place for that is in the cabal file, most certainly
03:31:08 <cheater> i would suggest such a thing as {-# PREPROCESS #-} to only support modules etc
03:35:30 <Eduard_Munteanu> Dreaming of using M4 as a preprocessor instead of CPP, eh? :P
03:37:51 <ClaudiusMaximus> cheater: ~$ ghc -F -pgmF echo dummy.hs
03:37:51 <ClaudiusMaximus> dummy.hs dummy.hs /tmp/ghc23685_0/ghc23685_0.hspp
03:37:51 <ClaudiusMaximus> /tmp/ghc23685_0/ghc23685_0.hspp: openBinaryFile: does not exist (No such file or directory)
03:38:05 <rostayob> Axman6: you can
03:38:48 <cheater> ClaudiusMaximus: ?
03:38:57 <ClaudiusMaximus> oh, didn't read up far enough
03:39:37 <rostayob> Axman6: on GHC, you can use the -pgmF flag
03:39:38 * hackagebot blaze-html-contrib 0.1 - Some contributions to add handy things to blaze html.  http://hackage.haskell.org/package/blaze-html-contrib-0.1 (ChrisDone)
03:39:40 * hackagebot blaze-html-contrib 0.1.1 - Some contributions to add handy things to blaze html.  http://hackage.haskell.org/package/blaze-html-contrib-0.1.1 (ChrisDone)
03:39:51 <rostayob> so you can put {-# OPTIONS_GHC -F -pgmFwhatever #-} at the top of files
03:40:11 <ClaudiusMaximus> rostayob: aha, just tested that
03:40:24 <ClaudiusMaximus> :)
03:40:37 <rostayob> that's how HSP works btw
03:40:50 <rostayob> but it's ugly
04:00:23 <Phyx-> Axman6: ghc supports custom preprocessors, which it'll on your files before anything else
04:00:56 <raimohanska> Hi guys! Is there a thing like "cabal repl" that would start GHCI with the dependencies defined in my .cabal file?
04:05:09 <Phyx-> Axman6: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html section 4.11.4
04:09:45 <donri> raimohanska: cabal-dev ghci
04:10:26 <augur> aristid: ping
04:11:01 <raimohanska> donri, thank's I'll check that out.
04:12:36 <raimohanska> works perfectly. saved my day. thank you!
04:44:03 <lukish> How can I do something like that?
04:44:04 <lukish> λ> splits [1..3]
04:44:04 <lukish> [[[1,2,3]],[[1,2],[3]],[[1],[2,3]],[[1],[2],[3]]]
04:45:38 <Jafet> With a spoonful of sugar
04:48:13 <Jafet> And a recursive function
04:56:38 <lukish> Are there some point free analog for []?
04:56:55 <lukish> > (\x -> [x]) $ 3
04:56:56 <lambdabot>   [3]
04:57:54 <lukish> ?hoogle a -> [a]
04:57:54 <lambdabot> Prelude repeat :: a -> [a]
04:57:54 <lambdabot> Data.List repeat :: a -> [a]
04:57:54 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
04:58:25 <jessopher> > return 3 :: [Int]
04:58:26 <lambdabot>   [3]
04:58:36 <jessopher> idk
04:59:04 <hpc> @pl \x -> [x]
04:59:04 <lambdabot> return
04:59:16 <hpc> or (:[])
04:59:23 <Jafet> [x] = x:[]
04:59:37 <lukish> ((flip (:)) []) $ 3
04:59:41 <lukish> > ((flip (:)) []) $ 3
04:59:42 <lambdabot>   [3]
05:00:03 <sipa> > (:[]) 3
05:00:04 <lambdabot>   [3]
05:00:12 <Gottflood> Ar.
05:03:22 <Gottflood> Ok.
05:04:01 <Eduard_Munteanu> :t pure
05:04:02 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
05:04:28 <Eduard_Munteanu> > pure 5 :: [Int]
05:04:29 <lambdabot>   [5]
05:05:18 <benmachine> :t S.toList . S.singleton
05:05:19 <lambdabot> forall a. a -> [a]
05:05:22 <benmachine> :P
05:05:41 <benmachine> :t maybeToList . Just
05:05:42 <lambdabot> forall a. a -> [a]
05:05:49 <Eduard_Munteanu> Heh.
05:06:32 <Philonous__> @type point
05:06:33 <lambdabot> Not in scope: `point'
05:06:38 <Philonous__> Lame
05:06:45 <benmachine> who even cares about point
05:07:04 <Eduard_Munteanu> What's that for, Pointed?
05:07:11 <Philonous__> pointed functors
05:08:07 <benmachine> pointed functors by themselves are one of the least interesting structures :P
05:08:29 <benmachine> I think I've only ever seen about one application of them
05:08:46 <benmachine> and it was in combination with a bunch of other contexts
05:10:17 <Jafet> We should have pointed arrows
05:10:18 <Philonous__> @type pure 5 `mappend` pure 7
05:10:19 <lambdabot> forall t (f :: * -> *). (Num t, Applicative f, Monoid (f t)) => f t
05:10:44 <Philonous__> I don't really see why this should be applicative. It reduces generality
05:11:51 <benmachine> Philonous__: firstly, I'm not convinced it does so in practical situations (in that, you'd need to point me at a type that was pointed but not applicative and useful)
05:12:01 <benmachine> Philonous__: secondly, that's only any good because you've also got a monoid structure
05:12:14 <benmachine> pointed monoids I could perhaps get along with
05:12:28 <benmachine> but actually if you've got a monoid you've already got an empty, so fmap will give you a free point
05:12:37 <benmachine> actually it might not, never mind
05:12:53 <benmachine> it will allow you to write a function of the right type but it might not be an interesting one
05:12:59 <Philonous__> benmachine:  Yes, but than we have pointed this and pointed that and we failed to abstract the common pattern.
05:13:09 <benmachine> Philonous__: because the common pattern isn't *useful*
05:13:19 <benmachine> well
05:13:20 <benmachine> okay
05:13:35 <benmachine> I can see an argument for Pointed as a subclass of both PointedMonoid and Applicative in theory
05:13:48 <benmachine> but I'm yet to be convinced of the applicability of it
05:14:28 <Eduard_Munteanu> I guess the question is whether there are useful functors which aren't pointed, rather, no?
05:15:19 <benmachine> Eduard_Munteanu: yeah. I'm not sure there are
05:15:27 <Philonous__> Eduard_Munteanu:  Even if there where none I would say that it is still useful to say that we are not interested in the applicative-ness of the structure here. It is a promise not to use <*>.
05:15:55 <Eduard_Munteanu> I see.
05:15:56 <Philonous__> Philonous__:  And isn't that what types are all about, restricting what you can do?
05:16:14 <Philonous__> Oops
05:16:17 <Eduard_Munteanu> :)
05:17:21 <benmachine> ...
05:17:40 <KvDUZBKRvd> IRC-WAR!!!!!!!!!!!!!
05:17:40 <CyuYYVPcSn> IRC-WAR!!!!!!!!!!!!!
05:17:40 <ZgBwnrpNEb> IRC-WAR!!!!!!!!!!!!!
05:17:40 <euVLomxenG> IRC-WAR!!!!!!!!!!!!!
05:17:40 <vRZJDSWzOT> IRC-WAR!!!!!!!!!!!!!
05:17:40 <tUozdbwNdG> IRC-WAR!!!!!!!!!!!!!
05:17:40 <YkeMllKStS> IRC-WAR!!!!!!!!!!!!!
05:17:40 <JqWYpcgsJN> IRC-WAR!!!!!!!!!!!!!
05:17:40 <QuCFCamTUH> IRC-WAR!!!!!!!!!!!!!
05:17:40 <XTuCwSLrMw> IRC-WAR!!!!!!!!!!!!!
05:17:40 <Dj_Dexter> IRC-WAR!!!!!!!!!!!!!
05:17:40 <HfGoUAKiff> IRC-WAR!!!!!!!!!!!!!
05:17:40 <ozcowWCooN> IRC-WAR!!!!!!!!!!!!!
05:17:40 <CacnwpqjqM> IRC-WAR!!!!!!!!!!!!!
05:17:40 <poon> IRC-WAR!!!!!!!!!!!!!
05:17:40 <ozzilee> IRC-WAR!!!!!!!!!!!!!
05:17:40 <CukRazCIGu> IRC-WAR!!!!!!!!!!!!!
05:17:40 <zupkyEmuFl> IRC-WAR!!!!!!!!!!!!!
05:17:40 <xErcRcAqCD> IRC-WAR!!!!!!!!!!!!!
05:17:40 <XNylbvEccr> IRC-WAR!!!!!!!!!!!!!
05:17:51 <wqDhYbmhVi> IRC-WAR!!!!!!!!!!!!!
05:17:51 <ZQzyzUtvKt> IRC-WAR!!!!!!!!!!!!!
05:17:51 <ZQzyzUtvKt> IRC-WAR!!!!!!!!!!!!!
05:17:51 <ZQzyzUtvKt> IRC-WAR!!!!!!!!!!!!!
05:17:51 <JaQdWhXhjY> IRC-WAR!!!!!!!!!!!!!
05:17:52 <pDAJfiEzlx> IRC-WAR!!!!!!!!!!!!!
05:17:52 <gdott9> IRC-WAR!!!!!!!!!!!!!
05:17:52 <fMZRhcgCyM> IRC-WAR!!!!!!!!!!!!!
05:17:52 <mvcNulgQVf> IRC-WAR!!!!!!!!!!!!!
05:17:52 <eetHiyzVle> IRC-WAR!!!!!!!!!!!!!
05:17:52 <ouELPVlbAZ> IRC-WAR!!!!!!!!!!!!!
05:17:52 <Guest61351> IRC-WAR!!!!!!!!!!!!!
05:17:52 <Nonnac> IRC-WAR!!!!!!!!!!!!!
05:17:52 <yEiikBPdDk> IRC-WAR!!!!!!!!!!!!!
05:17:52 <JWcbDhkfJf> IRC-WAR!!!!!!!!!!!!!
05:17:52 <whPDEZvuDP> IRC-WAR!!!!!!!!!!!!!
05:17:52 <htJqwTbzXV> IRC-WAR!!!!!!!!!!!!!
05:17:53 <mPsvydojtU> IRC-WAR!!!!!!!!!!!!!
05:17:53 <fpfxTgDFkK> IRC-WAR!!!!!!!!!!!!!
05:17:53 <Dony-> IRC-WAR!!!!!!!!!!!!!
05:17:57 <Botje> a war generally has two sides fighting.
05:18:03 -maniLbIfFX(~WsbrRtPFP@static-200-71-19-38.telmex.net.uy)- IRC-WAR!!!!!!!!!!!!!
05:18:03 -qXDovfBQbz(~FiYgmRxJa@static-200-71-19-38.telmex.net.uy)- IRC-WAR!!!!!!!!!!!!!
05:18:03 -otfdxmpEGK(~pwxnlBmXi@187-032-229-130.static.ctbctelecom.com.br)- IRC-WAR!!!!!!!!!!!!!
05:18:03 -GMTzmqgeDf(~WJbmOVNOg@118.96.136.50)- IRC-WAR!!!!!!!!!!!!!
05:18:03 -fKzlBRWhDW(~VpBRWwchh@118.96.136.50)- IRC-WAR!!!!!!!!!!!!!
05:18:04 <iRWFzOpNnu> IRC-WAR!!!!!!!!!!!!!
05:18:04 -iRWFzOpNnu(~mCeqkUelB@201.86.51.50)- IRC-WAR!!!!!!!!!!!!!
05:18:04 <xskfcWtDrT> IRC-WAR!!!!!!!!!!!!!
05:18:04 <xskfcWtDrT> IRC-WAR!!!!!!!!!!!!!
05:18:04 <xskfcWtDrT> IRC-WAR!!!!!!!!!!!!!
05:18:04 <xskfcWtDrT> IRC-WAR!!!!!!!!!!!!!
05:18:04 <xskfcWtDrT> IRC-WAR!!!!!!!!!!!!!
05:18:04 -KWGJUqMRxU(~jLBZkrMMj@183.63.33.235)- IRC-WAR!!!!!!!!!!!!!
05:18:04 -FZiJCxFIwp(~gCMqBMEwl@118.96.149.153)- IRC-WAR!!!!!!!!!!!!!
05:18:04 <tGpEajWQWw> IRC-WAR!!!!!!!!!!!!!
05:18:04 -zImage(~QxoWkSZMk@183.63.33.241)- IRC-WAR!!!!!!!!!!!!!
05:18:05 -rzOxgNDbXn(~ITpPtvAYR@190.92.46.114)- IRC-WAR!!!!!!!!!!!!!
05:18:05 -nnYCENlouQ(~OUsJlKuxz@12.186.220.130)- IRC-WAR!!!!!!!!!!!!!
05:18:05 -pZQWKJLYkJ(~KbdIMKEQb@12.104.222.17)- IRC-WAR!!!!!!!!!!!!!
05:18:05 -DECHMmgyur(~CrCirUdeI@12.104.222.17)- IRC-WAR!!!!!!!!!!!!!
05:18:09 --- mode: tomaw set +r
05:18:15 -ZMehZMvjFR(~oaSJlkXQu@mail.carrier.com.lb)- IRC-WAR!!!!!!!!!!!!!
05:18:16 <NkksdNxeYO> IRC-WAR!!!!!!!!!!!!!
05:18:16 -riKgkCoPtF(~szXsCIKFv@218.108.53.170)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -SaJtRiEmAt(~BRbDXoqBw@fl-67-76-134-15.sta.embarqhsd.net)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -yYvVNJfceI(~PnadqQhOw@fl-67-76-134-15.sta.embarqhsd.net)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -RPSVOsdpZO(~XMAJGYdbg@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -knyDBdituG(~NHGkDssgD@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -WdkbJVdAAW(~rMmieWTiM@mail.spudnik.com)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -orICXghLhu(~cRMkclpQM@fl-67-76-134-15.sta.embarqhsd.net)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -wtjrZZORzV(~UmFPvrnID@mail.spudnik.com)- IRC-WAR!!!!!!!!!!!!!
05:18:16 -wgaWzugvyK(~KpqWvLwjo@fl-67-76-134-15.sta.embarqhsd.net)- IRC-WAR!!!!!!!!!!!!!
05:18:17 -hstende(~jartza@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:17 -gnuvince(~liranuna@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:17 -forneus(~ondrejk@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:17 -OhscNeVwZU(~PORRNtSmm@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:17 -bgfOijchJN(~vVkDcxbkH@146.219.19.160)- IRC-WAR!!!!!!!!!!!!!
05:18:27 -wYilRPGLFV(~VAfOpcgoH@177.84.80.253)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -TKpaTASyZq(~FNsRaTtez@118-168-80-98.dynamic.hinet.net)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -zpEVGWqIPf(~JbZIXlSjb@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -arCzcwpmhg(~SHxlgEFSc@118-168-80-98.dynamic.hinet.net)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -fEUoORBmvP(~qVklBfSzF@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -dvmBoJHvjO(~XQErCwKSm@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -LXhpxSwoRS(~UoIrkwshe@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -vnYxBdOVaH(~AXRSLmqeX@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -HYzulDzUEZ(~ZdAacPZRH@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -aGjNFJzAUB(~dagPcoVUP@mail.hasjrat.co.id)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -jXzLuGpLHg(~dtXrEoCXV@athedsl-377936.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -pjLlbgeWVF(~kovHuOFjk@athedsl-377936.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -gvoDjzqhso(~nemVdzoTY@athedsl-377936.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -CYVFiZuJIl(~XVvHJrLxa@athedsl-377936.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:28 -UtGaeKvXik(~iBiXQWcrO@athedsl-377936.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:29 -MmwQtqfyAi(~rteyRSLWT@athedsl-389825.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:29 -YBjOJSPHXn(~RfqBVjAIL@athedsl-389825.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:29 -HsgvuQZggO(~DxUHeXDbl@athedsl-389825.home.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:29 -s34n(~wib@82.116.220.253)- IRC-WAR!!!!!!!!!!!!!
05:18:29 -Guest24908(~alexer@82.116.220.253)- IRC-WAR!!!!!!!!!!!!!
05:18:36 <Nimatek> heh
05:18:40 -lvZnievsZJ(~BGMpgqPuV@200.7.201.166)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -FLUWhpRNCB(~jgyxLvNMM@200.7.201.166)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -UsMmEJfmvA(~QlaPZgDvZ@200.7.201.166)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -YkCUVkliCj(~EyowCRxRd@200.7.201.166)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -DCulaGYjwZ(~KLqwygkGj@201.202.29.194)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -ujTxGXynRK(~ipIpyRWmg@201.202.29.194)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -fTpPfDQnbT(~eQeNgRjIU@201.202.29.194)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -DSbChzJujj(~GtlfbQQWI@200.69.100.118)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -qDBxxFRSgD(~PmTxFQzzA@201.202.29.194)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -rLMAkLPIjP(~mLPzzZVBT@201.202.29.194)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -tobias-_(~dxy@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -sXOwDCuMMN(~BuQUmxpBL@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -sfKEqUNcGL(~Tcsdxieoe@78.111.133.8)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -co_XL_PS_smtante(~kartoon@78.111.133.8)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -o_portista17(~FtYfZOUEr@78.111.133.8)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -TibshoOT(~Sieg@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -uozsbUfVPq(~omCSVDFBQ@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -VqBlLOdXbg(~vFSAnlCJk@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -nanzpXEKBw(~zekcrwHHA@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:40 -dtaxeZSpEW(~EEYUjfvRG@plogos.static.otenet.gr)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -VwpNrQRNxc(~OuRcGqklu@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -fnJsGkrzuv(~YXxSRJeMl@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -QEbwzpzith(~dYldhiNff@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -GlKEaObExI(~SlEgfhhBh@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -DrVBtlWmfJ(~LANEEbsAg@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -XzqBkXGoKs(~QEnsvFGcr@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -dgDLrTbhmg(~aKOSwoQKt@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -SNdgGyZtbF(~uaLVWanAy@177.16.78.176)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -iSnfdCZGoN(~jwYGXHCzt@177.16.78.176)- IRC-WAR!!!!!!!!!!!!!
05:18:52 -uOcGWdGenl(~nwMIsvDTZ@177.16.78.176)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -R_Rios(~freehood4@64.76.51.210)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -lnAAuGUKkF(~CRYwNPLqT@64.76.51.210)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -FMryjTwPHA(~avZEGKhJI@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -jasta(~myself.sp@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -UkasAhTWiY(~nwmkgAsms@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -thLczJUuOw(~fzVblwbbI@64.76.51.210)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -Stalafin(~G-Brain@41.219.180.202)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -cqeWOzvUQH(~RCiEFdzto@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -nkfFXbDZGQ(~WTpMESJuo@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:18:53 -lLTHuNJIqJ(~zjwKaPyFO@200.122.173.129)- IRC-WAR!!!!!!!!!!!!!
05:19:04 <Philonous__> @where ops
05:19:04 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:19:04 -yWwnIwgrtB(~uaThoDuUL@118.96.53.223)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -yWwnIwgrtB(~uaThoDuUL@118.96.53.223)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -DuTYMVuSxQ(~dyuGodLTq@200.68.116.65)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -TvrLpFCHEq(~fUmUpsWgf@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -dSbUZklgCt(~YQOkRPpgk@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -jNxqaCTjYW(~AqtugAaoT@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -eKStoJAEIL(~alFgHfiCg@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -JiApcqmUWw(~yOsDKVIJi@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -DSIRcEWIHI(~EhOarDQqD@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:04 -mGodssshIx(~DfXYKAGGD@203.141.148.176.static.zoot.jp)- IRC-WAR!!!!!!!!!!!!!
05:19:05 -HoPeLeSs(~xeVbMYcpb@183.63.33.234)- IRC-WAR!!!!!!!!!!!!!
05:19:08 -steven_t(~Tim@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -grqDxhYhjS(~VmIxuNoLy@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -RaaqjwwaHe(~MGGXLhdwz@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -dHEJSvpHHR(~SBFabXVJC@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -PeKqnIDaax(~XywvjQoFY@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -NFQKgftPhu(~VWgEmgLOR@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -lSytRaVcST(~rRbvhyrFO@46.148.32.25)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -mrGwyffUrK(~gbEvexRkd@mail.monitorsa.co.za)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -vNIJOvRucd(~RPfBDWaHK@mail.monitorkzn.co.za)- IRC-WAR!!!!!!!!!!!!!
05:19:09 -pCABJWnspS(~YtkmPzmxW@mail.monitorkzn.co.za)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -GEKAWxOuDh(~aqMqYvvSS@121.14.251.2)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -GEKAWxOuDh(~aqMqYvvSS@121.14.251.2)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -GEKAWxOuDh(~aqMqYvvSS@121.14.251.2)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -GEKAWxOuDh(~aqMqYvvSS@121.14.251.2)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -kHbohRHErY(~krEOLzPZs@121.14.251.11)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -pNXTSFTtHp(~qAYZfkAGO@121.14.251.11)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -dBZcDXJMKn(~FbORnxjqD@121.14.251.11)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -oQZASahRHH(~kIhUtXwjx@121.14.251.11)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -jVKpyVnLDe(~WDuyIMqSH@rtr1.vicceo.schools.net.au)- IRC-WAR!!!!!!!!!!!!!
05:19:16 -BgRhhyqrdE(~ropTUVSSt@rtr1.vicceo.schools.net.au)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -PWZsQavQRD(~wwkgDKFxy@186.195.17.3)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -XolbSoDlPE(~wNpzSiyYq@186.195.17.3)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -hblXIeTMsa(~KzoNTIxLb@186.195.17.3)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -marcel01(~aherttua@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -sgrace_work(~pjmhbXtiU@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -wWLeOdCQyk(~dGwGxPKhG@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -YCnkxEQmPs(~PDIMFSPwL@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -DhorKQbZSZ(~YbqbQZYUE@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -FDRDPATsbj(~KCzCcGQPK@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:21 -GSgsuvVumx(~xurPxUPLR@178.173.128.24)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -MFEmsRAnks(~MXVORrmVa@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -ymiisLAVOZ(~PwwzSnBfC@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -dWEdDYnLWz(~IutqjvLIT@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -xjYCXSMjKe(~jNHexFLGA@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -aYXxIhvXoD(~EOYGhdjRe@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -ZsITAhnHJG(~QKZnLUAJM@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -YBlWBORHqx(~lVDjdfxig@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -DAeVmJdhxb(~umVsdatoM@61.66.101.130)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -KZgfOKRfkA(~TBJWNxuxb@219.223.7.2)- IRC-WAR!!!!!!!!!!!!!
05:19:28 -oTfDPNICbm(~LARXGUnUJ@219.223.7.2)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -tyDFFQnobP(~lrzeKRdYZ@119.6.85.67)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -IJXJDPGGJk(~GmXxlMqFv@119.6.85.75)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -alate(~frangiz@183.63.33.224)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -fTOwBnKELF(~ZTLuSqBBA@183.63.33.224)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -liWvrpKetl(~DUZFtcxKv@183.63.33.224)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -sktptjhZSx(~oyRvpCwuO@118.112.185.68)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -oTRwzasMCw(~YclIJCXfv@110.4.82.40)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -OQSLtIeicU(~TFSdBEuCO@110.4.82.40)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -XTcchYvGmr(~yMbTiYWcu@110.4.82.40)- IRC-WAR!!!!!!!!!!!!!
05:19:33 -Guest54295(~kinxton@110.4.82.40)- IRC-WAR!!!!!!!!!!!!!
05:19:46 <flux> partying like in 1995?
05:19:47 --- mode: tomaw set +mzoo idoru tomaw
05:20:01 --- mode: kloeri set +o kloeri
05:20:06 <kloeri> something like that
05:21:48 --- mode: ChanServ set +o quicksilver
05:21:54 --- mode: quicksilver set -mz
05:21:59 <quicksilver> I guess we're OK for now
05:22:13 <benmachine> okay cool
05:22:19 <benmachine> where were we, pointed functors
05:22:22 <benmachine> soooo lame
05:22:23 <Eduard_Munteanu> :)
05:22:27 <Phyx-> lool
05:22:35 * Phyx- purges his logs
05:22:44 * Eduard_Munteanu wonders about the logs as well
05:22:47 <quicksilver> now that's a euphemism I've not heard before
05:23:05 <Philonous__> benmachine:  I don't even like the functor superclass constraint for pointed
05:23:10 <alex404> So I'm trying to use a writerArrow to log some stuff in my arrows (as one might expect). Within the arrow, I use 'lift write', and everything type checks. But when I run my arrow, the returned writer output is always empty. Is there any obvious reason why this might be?
05:23:40 <endojelly> alex404, what monoid do you use?
05:23:54 <benmachine> Philonous__: but if you have no structure on your point then you don't really learn anything about a type by being told it's a pointed functor
05:24:03 <benmachine> Philonous__: for example, how could you possibly define any laws?
05:24:04 <alex404> endojelly: A custom one that I defined. It's just a record of lists.
05:24:19 <benmachine> (this actually goes for the pointed monoid as well)
05:24:20 <endojelly> alex404, and you have checked that it works, yes?
05:25:00 <lukish> test
05:25:03 <alex404> endojelly: Well, that's what I'm trying to do. I guess I should try and run a simplest test though
05:25:19 <endojelly> alex404, yes do that... also one where you're sure it's going to be evaluated
05:25:25 --- mode: tomaw set -roo tomaw idoru
05:25:58 <alex404> endojelly: I think that's my problem though. How do I make sure it's being evaluated? I'm pretty sure there's something simple conceptually that I'm not getting.
05:26:24 <endojelly> alex404, ah. I thought you used that as part of something already complicated
05:26:47 <endojelly> alex404, you could paste the code...
05:27:33 <alex404> endojelly: Well, write now it is within something complicated. Let me write up a simplest case for sanity checking, and if I still get the problem, I'll paste it.
05:28:08 <endojelly> alex404, cool
05:28:35 <endojelly> alex404, I have to admit I haven't done anything with arrows yet, but maybe that's a good opportunity to jump in ;)
05:29:11 --- mode: quicksilver set -o quicksilver
05:29:40 * hackagebot cabal-src 0.1 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.1 (MichaelSnoyman)
05:31:47 <alex404> endojelly: It's not too bad, there's some nice tutorials :)
05:32:23 <raimohanska> I'm wondering how to make "cabal test" command work with some of my projects. For me, it always fails with an unexplained "Test suite tests: FAIL". To make it easy to help me, I created a simple demo at https://github.com/raimohanska/cabaltest
05:33:01 <raimohanska> It says that it logs the test into a certain file, but that file doesn't have any extra information either
05:34:10 <endojelly> alex404, I really should read them. I remember, a long while ago, I wanted to do something rather simple with tuples, and I somehow remembered that this *might* have been an application for arrows. but I just briefly looked into them, and for the simple stuff I was trying to do I very quickly said "uh, nope, I'll do it by hand, thanks" %)
05:34:21 <endojelly> but since them I found them rather intriguing
05:34:40 * hackagebot shakespeare-css 0.10.3 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.3 (MichaelSnoyman)
05:34:42 * hackagebot shakespeare-js 0.10.3 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.10.3 (MichaelSnoyman)
05:35:04 <Philonous__> benmachine:  Ah, I think I see what you mean. You can't decide what a sensible semantics for point is before you know in what context you use it. After all, point x =  [] would be perfectly reasonable if we know is the type (and it even agrees with the Functor instance)
05:35:19 <Philonous__> all we know*
05:37:04 <Waldteufel> ohai folks :)
05:37:09 <Waldteufel> ← just learning haskell
05:37:46 <alex404> endojelly: Yah, it's definitely dependent on how abstract you want to be. If all you want to do is thread some simple state through something the first time, understanding the state monad is definitely a time investment. But it all pays off :) And like monads, once you get arrows, they're very simple, and they come with some nice do notation too.
05:38:49 <endojelly> alex404, yeah, sounds exactly like it was with monads. by now I miss them in other languages %)
05:39:44 * hackagebot shakespeare-text 0.10.3 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.10.3 (MichaelSnoyman)
05:39:46 * hackagebot wai 0.4.3 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.4.3 (MichaelSnoyman)
05:39:48 * hackagebot wai-app-static 0.3.5 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.5 (MichaelSnoyman)
05:39:50 * hackagebot wai-extra 0.4.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.5 (MichaelSnoyman)
05:39:52 * hackagebot wai-handler-devel 0.4.4 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.4 (MichaelSnoyman)
05:40:47 <hpaste> Sebasti0n pasted “State Monad” at http://hpaste.org/54595
05:41:08 <endojelly> alex404, do you have a good link right now?
05:41:10 <Sebasti0n> hey there. I have a function returning a stateful result. I now need it to also be within the IO monad so I made use of StateT. But I can't figure out how to transform my function to work with StateT instead of State.
05:41:44 <alex404> endojelly: As in an arrow tutorial or the problem I'm working on?
05:41:50 <endojelly> alex404, arrow tutorial
05:42:12 <Botje> Sebasti0n: normally nothing should change.
05:42:38 <Botje> StateT s IO a is an instance of MonadState
05:42:50 <alex404> endojelly: So this is a really simple introduction that's worth running through but doesn't really show you how to do anything really powerful on arrows: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
05:43:29 <alex404> endojelly: This is a really good followup, which shows you how to do some very powerful things: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
05:43:41 <Sebasti0n> I read about that, so I do not need to pass anything to the state monad as the stack of monads will know to which monad the state needs to be passed, right?
05:44:04 --- mode: kloeri set -o kloeri
05:44:33 <Botje> what do you mean by 'pass anything' ?
05:44:54 * hackagebot wai-handler-fastcgi 0.4.2 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.4.2 (MichaelSnoyman)
05:44:54 <Botje> you still need to do runStateT stateT_code some_state
05:44:56 * hackagebot wai-handler-launch 0.0.4 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-0.0.4 (MichaelSnoyman)
05:44:58 * hackagebot wai-test 0.1.3 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.3 (MichaelSnoyman)
05:45:00 * hackagebot wai-websockets 0.5.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-0.5.0 (MichaelSnoyman)
05:45:02 * hackagebot warp 0.4.6 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.6 (MichaelSnoyman)
05:46:20 <Sebasti0n> What I understood from the texts I read you usually have to explicitly to liftIO or lift if you want to pass it to the IO or other monad stacked within the monad transformer
05:47:24 <Sebasti0n> but that is not actually my problem. My probelm is turning the function here (http://hpaste.org/54595) into a StateT function
05:49:19 <endojelly> alex404, that... actually seems surprisingly simple so far
05:50:03 <endojelly> I wonder why my mind blew up back then. I will probably remember after having read a bit more ;)
05:50:04 * hackagebot warp-static 0.2.2 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.2.2 (MichaelSnoyman)
05:50:06 * hackagebot yesod 0.9.3.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.3.2 (MichaelSnoyman)
05:50:08 * hackagebot yesod-auth 0.7.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.6 (MichaelSnoyman)
05:50:09 <alex404> endojelly: One thing to understand is that arrows are actually mathematically more general than monads, which means in some sense they are simpler and have less structure.
05:50:10 * hackagebot yesod-core 0.9.3.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.3.4 (MichaelSnoyman)
05:50:12 * hackagebot yesod-default 0.4.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-0.4.1 (MichaelSnoyman)
05:50:42 <tomprince> There is a quote somewhere about monads being hard because they are so simple.
05:52:42 <cheater> they are hard because you can never find a good chipotle
05:53:38 <endojelly> There is a quote somewhere about chipotle being hard to find because it's everywhere.
05:54:45 <Sebasti0n> Botje: Can you point me in the right direction?
05:55:13 <endojelly> ooh, the parser thing is neat. I think I can guess what they're getting at
05:55:14 * hackagebot yesod-form 0.3.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.4 (MichaelSnoyman)
05:55:16 * hackagebot yesod-json 0.2.2 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.2.2 (MichaelSnoyman)
05:55:18 * hackagebot yesod-newsfeed 0.3.2 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.3.2 (MichaelSnoyman)
05:55:20 * hackagebot yesod-persistent 0.2.2 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.2.2 (MichaelSnoyman)
05:55:22 * hackagebot yesod-sitemap 0.2.2 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.2.2 (MichaelSnoyman)
06:00:24 * hackagebot yesod-static 0.3.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.2 (MichaelSnoyman)
06:07:06 <cwb> Been trying to create a state-like monad that I can run with different state types without changing the rest of the code; thought I'd be able to use GADTs and type-classes, but I can't seem to satisfy the typesystem. Any thoughts on how to approach this?
06:07:55 <mauke> why not State?
06:09:40 <OceanSpray> indeed, why not?
06:10:21 <cwb> I'll need IO in there, but why not StateT? Because I couldn't figure out how to parameterise it with a state belonging to a typeclass. Am I missing something obvious?
06:10:41 <russellw> Hi, what's the recommended way to create a dictionary/map in Haskell?
06:10:50 <OceanSpray> cwb, it might help to hpaste some code
06:10:57 <koala_man> russellw: Data.Map
06:11:13 <mauke> types don't belong to classes
06:16:52 <hpaste> russellw pasted “map” at http://hpaste.org/54596
06:17:35 <russellw> Okay, found a tutorial on maps at http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Introduction#Finite_Maps and trying something based on that, but doesn't seem to work, what am I doing wrong?
06:18:01 <OceanSpray> russellw,
06:18:27 <OceanSpray> > fromList [("a", 1)] :: Data.Map
06:18:28 <lambdabot>   Not in scope: type constructor or class `Data.Map'
06:18:33 <OceanSpray> oh dang
06:18:45 <OceanSpray> well
06:19:12 <OceanSpray> your problem is that ["a", 1] tries to construct a list of two elements: a string and a number
06:19:38 <OceanSpray> (which, by the way, isn't allowed since a list's elements have to have the same type)
06:19:54 <russellw> ah! Yes of course, it has to be a list containing a single tuple, right?
06:19:54 <OceanSpray> whereas you want something like [("a", 1)]
06:19:56 <OceanSpray> yes
06:21:43 <mauke> > M.fromList [("a", 1)]
06:21:43 <lambdabot>   fromList [("a",1)]
06:21:57 <mauke> > M.singleton "a" 1
06:21:57 <lambdabot>   fromList [("a",1)]
06:24:04 <hpaste> cwb pasted “StateT with typeclassed state” at http://hpaste.org/54597
06:24:31 <mauke> how is line 5 valid?
06:24:46 <cwb> OceanSpray: Ok, I sketched rougly what I'm after (but the code doesn't work, because line 5 is invalid).
06:25:00 <cwb> mauke: Yeah, that's the problem.
06:25:18 <OceanSpray> just
06:25:30 <mauke> so remove line 5
06:25:33 <mauke> problem solved
06:25:35 <benmachine> why not just program :: Memory a => StateT a IO b
06:25:39 <OceanSpray> yeah that
06:26:05 <russellw> Suppose you create a map of lists to whatever, and an infinite list gets added as a key. Attempting to look up that key will cause an infinite loop, naturally enough...
06:26:26 <russellw> Is there a way to detect or handle this scenario? Or is it just "well don't do that then"?
06:26:36 <mauke> you can't detect nontermination
06:26:49 <benmachine> russellw: there's no way to detect that a given list is infinite
06:26:59 <benmachine> although there are ways to detect if it is finite :P
06:27:10 <russellw> right :) fair enough
06:27:19 <benmachine> russellw: however, a lookup with a finite key will always terminate
06:27:34 <OceanSpray> well
06:27:55 <OceanSpray> he could define an always terminating instance of Ord for that specific list type
06:28:06 <benmachine> so you can have an infinite key pointing at something, there's just not much point as you can never retrieve the corresponding value
06:28:08 <OceanSpray> (==) doesn't HAVE to inspect every element
06:28:31 <OceanSpray> use OverlappingInstances and FlexibleInstances
06:28:38 <benmachine> OceanSpray: okay, but I think it would be forced to compare unequal (even finite) lists as equal
06:28:46 <benmachine> oh goodness, don't use OverlappingInstances
06:28:47 <benmachine> ewwww
06:28:50 <benmachine> use newtypes :)
06:30:55 <OceanSpray> pfft
06:31:07 <cwb> benmachine, OceanSpray: Excellent, thanks! That works well. Had set my mind of removing any mention of a in the program type signatures, but I can live with that.
06:40:03 <EvanR-work> i determined that my program is segfaulting when using adns bindings to send a query
06:40:44 <alex404> Might anyone know why, despite the fact the 'write' command in this arrow doesn't actually append anything to my monoid?: http://hpaste.org/54598
06:41:04 <EvanR-work> core dumped disassemble fails while computing the arguments to adns__query_send, and specifically when moving some shit to rsp
06:59:11 <EvanR-work> dns library seems legit
06:59:15 * EvanR-work scraps adns
07:04:15 <augur> anyone do real, theoretical science, not just CS?
07:06:14 <Eduard_Munteanu> augur: you know that could easily be misinterpreted ;)
07:06:20 <augur> Eduard_Munteanu: :)
07:06:52 <augur> i mean a form of science that builds theories about observed phenomena, not just conceptual phenomena
07:07:26 <EvanR-work> cs is observed!
07:07:58 <EvanR-work> computer:cs :: telescope:astronomy
07:08:11 <russellw> augur, you're better off just asking the question you would ask such a person, were one present, and seeing if anybody answers :)
07:08:13 <augur> EvanR-work: lol
07:08:23 <augur> russellw: well ok
07:08:39 <sipa> what is currently called computer science is often quite far from what dijkstra meant in his quote, i believe
07:09:22 <EvanR-work> sipa: lol... isnt what currently called cs is really computer administration
07:09:23 <augur> to all people who can answer this question: do you know of any projects that outline ways to share new accounts of phenomena in some machine-usable way?
07:09:37 <xxx_man> augur: are you looking for someone from TCS?
07:09:52 <sipa> EvanR-work: that's ICT
07:09:54 <augur> xxx_man: i have no idea what that means
07:10:19 <xxx_man> theoretical computer science
07:10:32 <russellw> augur, the wording of your question is a bit vague, but I know astronomy and gene sequencing, just to take two examples off the top of my head, have been making available, and using, machine readable data archives in a big way
07:10:36 <augur> xxx_man: then no. im looking for someone in theoretic non-computer science :)
07:10:39 <russellw> Or the protein databank for another example
07:10:47 <EvanR-work> sipa: lol ICT? /me writes down yet another alphabet soup to describe the same exactly thing, IT, MIS, etc
07:10:49 <augur> russellw: yes, im not concerned about data archives tho
07:10:50 <EvanR-work> ISDS
07:11:00 <augur> russellw: im curious about machine-readable _models_
07:11:03 <russellw> augur, then I don't understand your question, can you rephrase?
07:11:55 <augur> so as an example from my field, linguistics, we syntacticians work a lot to provide accounts of phenomena that show up in natural language -- how does raising word, why is this sort of sentence bad, etc.
07:12:34 <russellw> Any simulation code is a machine-readable model, is that what you mean? - Or for linguistics, there are open-source natural language parsers
07:12:37 <augur> each of those things has a number of different accounts, and itd be nice to be able to have those accounts available in a way that lets them be explored
07:12:45 <augur> *sigh*
07:12:56 <xxx_man> augur: grammar
07:12:56 <augur> you're completely off in the wrong end of things
07:13:21 <russellw> Fair enough, maybe somebody else will understand what you are asking well enough to answer your question :)
07:14:07 <aninhumer> augur: what kind of operations would you want to do with the data?
07:14:25 <augur> from a physics perspective this might mean something like having a variety of grand unified theories detailed online, both with formulae fully available, and also with the different aspects of the theory written up
07:14:56 <augur> so that, for instance, theories with similar structures are obviously similar
07:15:47 <augur> aninhumer: well, it depends on the nature of the theories, but you might be able to search for the situations where an account of this or that phenomena involves this or that mathematical structure, or whatever
07:15:50 <augur> i dont know
07:16:16 <augur> im just looking for anything that provides a structured overview of different accounts of phenomena in a machine readable fashion
07:16:23 <augur> maybe not even machine readable but hypertextual at the least
07:17:06 <PhilRod_> augur: I saw a cool thing from, I think it was Cornell, where they did something along those lines in their robotics group
07:17:58 <PhilRod_> augur: (they made it robotics by having a camera observe a double pendulum, but the nontrivial part was that it deduced an equation to describe the pendulum based on those measurements)
07:18:23 <augur> right, but..
07:18:30 <augur> i mean thats cool
07:18:34 <augur> but not what im talking about...
07:18:42 <aninhumer> augur: I suspect any kind of structure in such things would be very domain specific and not really practical to build a general mechanism for
07:18:54 <augur> aninhumer: im not looking for general mechanisms!
07:18:59 <augur> im just looking for examples of such things
07:19:28 <Eduard_Munteanu> augur: something like a statement of, say GUT, in Coq or Agda?
07:19:51 <augur> Eduard_Munteanu: not necessarily so formally
07:20:29 <augur> just sufficiently marked up to be able to ask, for instance, for the varieties of a GUT that involves this or that algebraic structure, or whatever
07:20:37 <augur> or something like that
07:20:38 <Eduard_Munteanu> A straightforward statement (one that's not necessarily easy to do proofs with) might be more tractable I guess.
07:20:46 <Eduard_Munteanu> Ah.
07:20:49 <augur> semantically marked up theory
07:21:01 <benmachine> I sometimes wish someone would draw up a hierarchy of dependencies in mathematical proofs
07:21:11 <benmachine> so this result follows from that one, implies the other one
07:21:11 <Eduard_Munteanu> benmachine: I wonder about that as well
07:21:25 <benmachine> has these alternative proofs using these results
07:21:29 <cheater> benmachine: yeah, it's fairly interesting
07:21:30 <Eduard_Munteanu> IIRC there were some efforts in that direction.
07:21:31 <augur> Eduard_Munteanu: in linguistics, for instance, transformational theories employ displacement operations, where bits of a tree are moved around
07:21:32 <cheater> imo
07:21:58 <PhilRod_> benmachine: do you mean something like metamath?
07:22:02 <augur> Eduard_Munteanu: so itd be useful to be able to ask for all accounts of phenomena that employ operations that look like so and so
07:22:32 <benmachine> PhilRod_: yeah I was actually looking for something linkable from there :P
07:22:38 <augur> movement out of this or that place, or with this or that destination, or whatever
07:22:41 <benmachine> PhilRod_: but it's not really dip-in-able enough for me
07:23:18 <augur> Eduard_Munteanu: or maybe if this is astrophysics, i dont know, all models of phenomena that employ this or that equation
07:23:21 <augur> or whatever
07:24:22 <Eduard_Munteanu> Hm, that seems tough to pull off even if you have the data in a suitable format.
07:24:49 <augur> Eduard_Munteanu: im sure. this is why im looking for models :)
07:25:04 <augur> Eduard_Munteanu: im designing a database/encyclopedia with that sort of structure
07:25:14 <Eduard_Munteanu> Interesting.
07:25:17 <augur> and im going through a paper as an example of what i want to put into this database
07:25:36 <augur> its interesting, because it poses some peculiar challenges
07:25:48 <User235> Hi, http://i1196.photobucket.com/albums/aa420/classicfps/Untitled.png  (C Language)
07:25:51 <augur> what should be represented, how to represent these highly structured things
07:26:11 <augur> and importantly, how to represent the _ideas_, not just the examples
07:26:19 <User235> can anyone guide me on how do do this begineer question : http://i1196.photobucket.com/albums/aa420/classicfps/Untitled.png
07:26:20 <augur> or should the ideas even be represented
07:26:29 <benmachine> User235: this is not a C channel
07:26:38 <User235> i know im in a hurry
07:26:43 <User235> i have to be in school in 1 hour
07:26:54 <User235> if u can just help me out
07:27:00 <User235> it would be great
07:27:11 <mauke> User235: why not try a C channel?
07:27:20 <User235> cause i got to register for it
07:27:23 <User235> and i dont have time :(
07:27:55 <mauke> yeah, because spending 2 minutes registering an account would be too hard
07:28:00 <benmachine> registration is fast
07:28:09 <User235> lol k how do u do it
07:28:21 <User235> does it say the syntax
07:28:22 <Eduard_Munteanu> User235: /msg nickserv help
07:28:28 <User235> ok
07:28:29 <User235> thanks
07:29:32 <aninhumer> Not sure why someone would come here as their 2nd option for C help...
07:30:25 <Eduard_Munteanu> Maybe #haskell has a good reputation :)
07:30:40 <benmachine> it's possible
07:30:42 <daimrod> ghc looks like gcc
07:30:51 <benmachine> I rather suspect we're just high up on google searches for programming
07:31:10 <rainman85> Hello, I need some help in the right direction, I am new at Haskell and I have googled already, however I can't seem to find out how to use this synonym type: type DomsPlayer = Hand->DomBoard->Player->Scores->(Dom,End)
07:31:15 <rainman85> Any ideas?
07:31:27 <Eduard_Munteanu> @google programming freenode
07:31:27 <lambdabot> http://twkm.freeshell.org/c.html
07:31:28 <lambdabot> Title: ##C on freenode
07:31:54 <benmachine> rainman85: why do you want to use it
07:32:17 <rainman85> Because a function expects an argument of that type
07:32:17 <benmachine> rainman85: I mean, you can just put it in a type and it should work
07:32:19 <benmachine> oh
07:32:21 <benmachine> ah
07:32:22 <Eduard_Munteanu> Damn that looks like C++ indented like that :)
07:32:23 <benmachine> an argument
07:32:41 <benmachine> the problem is not the type synonym
07:32:54 <benmachine> just replace the type synonym with its contents in parentheses and you'll be fine
07:33:19 <benmachine> I suspect the problem is you're trying to use a function that is shaped like (a -> b) -> c and those can be confusing to people new at FP
07:33:32 <benmachine> you're passing a function to a function
07:33:58 <rainman85> I mean this is a synonym type.. not a function. How would I pass it to that function? That's where I am stuck at
07:33:59 <rainman85> :)
07:34:33 <rainman85> I have: p = DomsPlayer([] InitBoard P2 (0, 0))
07:34:39 <rainman85> and I need to pass p to that function
07:34:52 <benmachine> that doesn't look right
07:35:02 <rainman85> I know, it doesn't work either
07:35:20 <benmachine> hmm
07:35:22 <Eduard_Munteanu> rainman85: that type synonym doesn't take arguments
07:35:28 <rainman85> So, how is right then?
07:35:30 <aninhumer> rainman85: DomsPlayer is a type, not a function
07:35:34 <benmachine> you appear to be using DomsPlayer as a value constructor
07:35:38 <benmachine> but it isn't one
07:35:40 <rainman85> yes
07:35:51 <rainman85> I know, but I dont know how to use it otherwise
07:35:55 <benmachine> if you want a value of type DomsPlayer, you want a function
07:36:01 <aninhumer> rainman85: I think you want a data constructor
07:36:18 <rainman85> @benmachine: a function like?
07:36:18 <lambdabot> Unknown command, try @list
07:36:19 <benmachine> something like p hand board player scores = (dom,end) where dom = [...], end = [...]
07:36:24 <benmachine> rainman85: fill in the [...]s
07:36:32 <Eduard_Munteanu> rainman85: foo :: DomsPlayer; foo a b c d (e, f) = ...
07:36:35 <benmachine> then p :: DomsPlayer
07:36:44 <Eduard_Munteanu> Erm.
07:36:58 <Eduard_Munteanu> Drop the e, f part
07:37:13 <rainman85> I see
07:37:16 <rainman85> let me try..
07:37:35 <aninhumer> rainman85, is what you want: data DomsPlayer = DomsPlayer Hand DomBoard Player Scores (Dom, End) ?
07:37:57 <rainman85> no, aninhumer, I dont want a new data type
07:38:21 <rainman85> DomsPlayer comes with some third party code and it is defined as a type synonym, that would mess things up
07:39:02 <benmachine> rainman85: type synonyms aren't a big deal, you can just expand them from the definition and then pretend they don't exist
07:39:34 <aninhumer> rainman85: if you want to use something of that type, you will have to make a function
07:39:58 <rainman85> I'm working on it right now..
07:40:11 <aninhumer> It's possible whatever third party code you're using will create such a function for you, but that depends
07:41:29 <rainman85> aninhumer: you are right, there are such functions..
07:41:38 <rainman85> I hadn't even noticed them
07:41:44 <rainman85> that makes things easier
07:46:52 <TheMute> I'm starting to learn haskell from this site: http://learnyouahaskell.com/introduction and down by the picture of the moon it is talking about how haskell does lazy computations. In it's example is it saying that with the 3 doubleMe calls that haskell will only iterate over the list a single time doing all the * 2 operations one after another on each element or have I missunderstood that?
07:47:32 <TheMute> Or is it saying that it doesn't iterate over the list at all and only computes each element of the list as it is needed?
07:49:19 <aninhumer> TheMute: both, kind of
07:49:29 <kakos> TheMute: The latter, I believe.  If you ask for the first element of doubleMe(doubleMe(doubleMe(xs))), it'll only evaluate the first element of xs because that's all that is needed
07:50:08 <Philonous> TheMute:  The result will be a "thunk" i.e. a promise to compute the elements when you really care for them
07:50:32 <TheMute> Well now that is pretty neat. What kind of overhead is there with this appraoch of storing steps and not the results of the steps?
07:50:37 <Jaak> > map (10 `div`) [2,0,0,0] !! 0
07:50:38 <lambdabot>   5
07:51:20 <aninhumer> TheMute: if I understand correctly, the compiler does a good job of spotting when there's no point being lazy
07:52:50 <kakos> TheMute: It can be expensive.  You can experience a sort of stack overflow if you end up generating too many thunks.
07:52:55 <carpi> when defining new types, do the value constructors always have to start with a capital letter? for instance is "data Days = mon | tue" valid? I get an error in GHCi, but im not sure if the error is because of not using Caps for the starting letters of the value constructors..
07:53:10 <dmwit> carpi: Yes, capitals are required.
07:53:18 <rwbarton> it is because they're not capitalized.  mon and tue are type variables there
07:53:20 <kakos> TheMute: http://www.haskell.org/haskellwiki/Stack_overflow  Has a bit of information on that
07:53:21 <dmwit> carpi: Infix constructors must start with a :
07:53:37 <kakos> TheMute: However, most of the time, it's fine.
07:53:41 <aninhumer> TheMute: it can sometimes be important to force certain things to be computed "strictly" (i.e. non-lazily) to maintain performance
07:54:01 <Philonous> TheMute:  There is some computation overhead, obviously, the real problem is that a thunk might hold on to some data it needs to produce it's value later and so that data can't be garbage collected.
07:54:16 <carpi> dmwit: but capital letters are reserved only for types..not for values right?
07:54:17 <rwbarton> (Well actually you can't put a type variable there anyways, so hmm.)
07:54:26 <dmwit> TheMute: Writing idiomatic code and turning on optimizations typically produces programs that run at about half speed compared to idiomatic, optimized C.
07:54:45 <dmwit> TheMute: When performance matters, it's almost always possible to get within a few percent of C.
07:54:51 <carpi> and if mon and tue are simply values then why do they need to be capitalized?
07:54:57 <dmwit> In some unusual cases, Haskell can outperform C.
07:55:07 <rwbarton> carpi: Case is significant at both the value and type levels.
07:55:21 <mauke> carpi: no, Uppercase words are constants, lowercase words are variables
07:55:23 <rwbarton> Capitalized values are data constructors; they can be pattern matched on.
07:55:37 <aninhumer> carpi: they're not values, they're constructors
07:55:41 <dmwit> carpi: Capitalization is required so that I can tell whether the syntax "f x y = ..." is supposed to match constructors x and y or bind new variables x and y to entire values.
07:56:16 <dmwit> "f x y = ..." always binds new variables x and y; "f X Y = ..." always matches constructors X and Y.
07:56:37 <aninhumer> carpi: so in your case you might want a function: f Tue = (..tuesday stuff..)
07:58:07 <aninhumer> carpi: whereas: f tue = (..tuesday stuff..) would bind whatever value you applied it to to a value called "tue"
07:58:52 <aninhumer> and then compute (..tuesday stuff..) regardless of whether that value was Tuesday
07:59:09 <TheMute> philonous aninjumer: kakos dmwit: Thanks for the info. This is definitely looking veyr neat
07:59:15 <carpi> I think i partially understand.. so f (Tue) pattern matches and "f tue" binds to tue whatever 'f' is called with?
07:59:30 <rwbarton> Yes.
07:59:55 <rwbarton> And that works because of the rule that constructors are always capitalized.
08:00:32 <kakos> TheMute: Be careful.  Once you learn Haskell, you'll cry at how primitive other languages are.
08:00:44 <rainman85> I am still stuck at the issue I had before, the functions for DomsPlayer exist, however I do not yet know how to pass the return value of that function to the other function
08:00:58 <carpi> but isn't that why we put pattern matches in parenthesis? ... to differentiate between pattern matchin and function application?
08:00:59 <rwbarton> Otherwise, you could break a definition of a function by bringing a new constructor into scope.  (Imagine I write data Evil = x, for instance.)
08:01:07 <rwbarton> carpi: We don't put pattern matches in parentheses.
08:01:17 <carpi> rwbarton: (x:xs)?
08:01:25 <rwbarton> those parentheses are required for grouping
08:01:39 <aninhumer> rwbarton: you have to for constructors taking arguments I think
08:01:44 <rwbarton> f (x:xs) not (f x):xs
08:02:02 <rwbarton> aninhumer: yes, unless you use record syntax.
08:02:25 <benmachine> it's perfectly legitimate to write case [1,2] of x:xs -> x
08:02:25 <rwbarton> But you don't have to write f (Tue), and most people don't.
08:02:46 <dmwit> > let Just 3 `foo` Just 4 = 6 in foo (Just 3) (Just 4) -- pattern matches don't always go in parentheses, carpi
08:02:47 <lambdabot>   6
08:02:47 <rwbarton> @src maybe
08:02:47 <lambdabot> maybe n _ Nothing  = n
08:02:47 <lambdabot> maybe _ f (Just x) = f x
08:02:50 <TheMute> Kakos: I can't wait! I kinda sort somewhat learned F# a couple months back and it made my 2K line skype chat bot into 400 lines and gained a lot more feature. I figure if I actually learn funcitonal concepts correctly this time around I should be able to do some realy fancy things!
08:03:02 <aninhumer> rainman85: do you have a link to the documentation for the code you're working with?
08:03:50 <benmachine> rainman85: you just... do it :P can we see your code?
08:03:52 <carpi> rwbarton:thansk for the clarification
08:04:12 <rainman85> yes anihumer and benmachine
08:04:17 <rainman85> let me get the pastebin..
08:05:52 <aninhumer> TheMute: be careful, or you might accidentally end up with a very powerful and composable skype chatbot framework that doesn't actually do anything :P
08:06:46 <hpaste> rainman85 pasted “Synonym Type Issue” at http://hpaste.org/54600
08:07:54 <aninhumer> TheMute: or a new semantic computation model that would be really good for writing chatbots in, if only people understood it :P
08:08:46 <TheMute> aninhumer: One can only hope! At the very least I will be able to custimze xmonad to my liking.
08:08:47 <rainman85> I cant figure how to modify the code now that I pasted it, I see I have forgotten something
08:09:19 <aninhumer> rainman85: annotate
08:09:43 <dmwit> rainman85: The parentheses after randomPlayer on line 8 look a bit suspicious.
08:09:51 <dmwit> rainman85: You probably should just remove them.
08:09:55 <hpaste> rainman85 annotated “Synonym Type Issue” with “Synonym Type Issue (annotation)” at http://hpaste.org/54600#a54601
08:10:53 <hpaste> rainman85 annotated “Synonym Type Issue” with “Synonym Type Issue (annotation)” at http://hpaste.org/54600#a54602
08:11:18 <rainman85> the domsMatch function is the function which expects a synonym type
08:11:53 <benmachine> actually the braces in line 8 look suspicious too
08:12:01 <aninhumer> rainman85: I suspect your problem might be related to using mkStdGen, which is IO
08:12:21 <aninhumer> oh unless, playDomsGames expects that
08:12:30 <benmachine> aninhumer: mkStdGen isn't IO
08:12:36 <benmachine> newStdGen and getStdGen are
08:12:44 <kakos> TheMute: Well, Haskell is an excellent way to learn functional concepts because it takes some rather painful contortions to do something in Haskell without using functional concepts.
08:12:52 <aninhumer> benmachine: oh I see
08:13:05 <benmachine> aninhumer: mkStdGen is where you supply the ssed yourself
08:13:08 <benmachine> *seed
08:13:16 <aninhumer> yeah
08:13:38 <benmachine> rainman85: anyway, as dmwit pointed out, line 8 looks wrong
08:13:51 <rainman85> Yes
08:13:55 <benmachine> rainman85: if you write f(x y), this is actually f applied to one argument, namely x applied to y
08:13:57 <rainman85> working on fixing that..
08:14:05 <benmachine> f x y is f applied to x and y
08:14:25 <rainman85> ah
08:14:26 <rainman85> I see
08:14:40 * hackagebot graph-rewriting-gl 0.6.7 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.7 (JanRochel)
08:14:42 * hackagebot graph-rewriting-lambdascope 0.4.10 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.10 (JanRochel)
08:15:50 <jgeralnik> Is there any reason why ZipList doesn't derive Show?
08:16:00 <benmachine> jgeralnik: that annoys me too
08:16:19 <hpaste> rainman85 annotated “Synonym Type Issue” with “Synonym Type Issue (annotation)” at http://hpaste.org/54600#a54603
08:16:32 <rainman85> I tried fixing that, but somehow there is something wrong with those lines
08:16:50 <rainman85> the interpreter throws a "parse error on input `0'" error
08:16:59 <rainman85> right where the tuples are
08:18:42 <mauke> {0, 0} isn't a tuple
08:18:45 <aninhumer> rainman85: the curly brackets aren't tuples
08:18:45 <mauke> it's a syntax error
08:19:34 <aninhumer> rainman85: is Scores just (Int,Int)?
08:19:54 <rainman85> Yes
08:19:56 <rainman85> anihumber
08:20:01 <rainman85> sorry guys, I am blind...
08:21:03 <byorgey> "that's no tuple... that's a space station!"
08:21:15 <rainman85> okay, I fixed that, and I still get an interpreter error, I dont know if I should paste it here
08:21:37 <rainman85> It just says that p1 and p2 arent of type DomsPlayer
08:22:07 <aninhumer> rthey are of type (Dom,End)
08:22:13 <aninhumer>  rainman85 ^
08:22:30 <rainman85> Yes
08:22:51 <lep-delete> hey i have this code(http://hpaste.org/54604) and for me it seems like a good fit for the state monad (?).  But i don't know how to actually do that.
08:22:53 <rainman85> Any idea how I should go about passing them as DomsPlayer?
08:23:29 <rwbarton> rainman85: this is still rather vague
08:23:31 <rainman85> Should I just pass the function hsdPlayer with its arguments as an argument for domsMatch
08:23:32 <rainman85> ?
08:23:33 <aninhumer> rainman85: DomsPlayer is the type of the function hsdPlayer
08:23:35 <rwbarton> what line is the error on
08:24:01 <aninhumer> rainman85: I'd try that
08:24:06 <rainman85> line 11
08:24:13 <Eduard_Munteanu> lep-delete: you probably shouldn't have that 'min' in the instance
08:24:31 <rwbarton> oh sorry, I wasn't scrolled down all the way
08:24:53 <Eduard_Munteanu> Erm... what does it do... minimum?
08:24:56 <rainman85> aninhumber: that doesnt change things
08:25:16 <rwbarton> it looks like it should just be   p1 = hsdPlayer   p2 = hsdPlayer
08:25:18 <lep-delete> Minimize. Like make long names to short
08:25:33 <lep-delete> but i need to keep track of allready present names
08:25:53 <Eduard_Munteanu> lep-delete: I'm not sure why you expose the state parameter in the instance. 'min' should probably call a helper
08:25:57 <rainman85> oh
08:25:57 <rainman85> wow
08:25:59 <benmachine> lep-delete: problem is you can't actually use the s in your functions
08:26:02 <rainman85> rwbarton: that did it
08:26:06 <benmachine> lep-delete: because you don't know anything about its type
08:26:19 <benmachine> lep-delete: all you can do is return it unmodified, without inspecting it
08:26:20 <rwbarton> rainman85: now... do you have any idea why? ;)
08:26:31 <aninhumer> rainman85: yeah, the function playDomsGames takes two player functions
08:26:34 <rainman85> I think I do
08:26:37 <aninhumer> of type DomsPlayer
08:26:47 <aninhumer> (and some other stuff)
08:27:10 <byorgey> lep-delete: I don't think you want to make a new type class for that.  If you want to use the State monad I'd just use a function of type  m -> State s m
08:27:10 <rainman85> You are awesome, many many thanks for helping me out!
08:27:39 <lep-delete> uhm, maybe i made a mistake posting this. think of s as a fixed type. something like Map String String.
08:28:06 <benmachine> lep-delete: ah, in that case yes, the State monad might suit you
08:28:14 <benmachine> as byorgey said
08:28:30 <benmachine> s -> m -> (m,s) is the same as m -> State s m
08:28:49 <benmachine> and actually is also the same as s -> State m s, btyg >_>
08:29:11 <benmachine> you might not *need* the state monad though, it depends how you use that result tuple
08:29:13 <byorgey> heh =)
08:29:22 <rwbarton> from lines 6-8 we can see that we want m -> State s m though
08:29:29 <byorgey> those two formulations let you do entirely different things using monad machinery, though
08:29:40 * hackagebot hackport 0.2.14 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.2.14 (SergeiTrofimovich)
08:29:43 <benmachine> rwbarton: I guess so
08:30:08 <lep-delete> i'll post something bigger :). i guessed it seems like something state monad was good for, but i dont actually know
08:30:35 <rwbarton> so let's say you have a function f :: m -> State s m
08:30:47 <rwbarton> and now you want a function :: [m] -> State s [m]
08:30:57 <rwbarton> the monad machinery will give you that function
08:31:46 <byorgey> (in particular using mapM)
08:32:58 <lukish> How can I rewrite that?
08:33:04 <lukish> sew [a1,a2,a3,a4,a5,a6,a7,a8] = [1,a1,2,a2,3,a3,4,a4,5,a5,6,a6,7,a7,8,a8,9,0,0]
08:33:27 <benmachine> lukish: going to need more specification
08:33:31 <benmachine> what's sew []?
08:34:11 <Eduard_Munteanu> :t intercalate
08:34:11 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:34:22 <Eduard_Munteanu> :t intersperse
08:34:22 <lambdabot> forall a. a -> [a] -> [a]
08:34:40 * hackagebot packdeps 0.0.3 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.0.3 (MichaelSnoyman)
08:34:54 <Eduard_Munteanu> > intersperse 0 [1,2,3,4,5]
08:34:54 <lambdabot>   [1,0,2,0,3,0,4,0,5]
08:35:00 <ion> > concat . zipWith (\a b -> [a,b]) [1..] $ "o hai"
08:35:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:35:01 <lambdabot>    arising from the literal `1...
08:35:06 <byorgey> I don't think intercalate or intersperse help much
08:35:19 <ion> > concat . zipWith (\a b -> [a,b]) [1..] $ [a,b,c,d,x,y,z]
08:35:21 <lambdabot>   [1,a,2,b,3,c,4,d,5,x,6,y,7,z]
08:35:24 <Eduard_Munteanu> Erm, yeah, I misread.
08:35:29 <rwbarton> ion: Stupid types.
08:35:37 <ion> > (++ [0,0]) . concat . zipWith (\a b -> [a,b]) [1..] $ [a,b,c,d,x,y,z]
08:35:39 <lambdabot>   [1,a,2,b,3,c,4,d,5,x,6,y,7,z,0,0]
08:35:50 <mauke> > concatMap (\(a,b) -> [a,b]) $ zip [1 ..] [a,b,c,d]
08:35:50 <lambdabot>   [1,a,2,b,3,c,4,d]
08:35:51 <rwbarton> You can also use concat + transpose, but I'm not sure it's better.
08:36:07 <lukish> benmachine: something like zip two lists
08:36:16 <benmachine> lukish: where do the zeroes come from
08:36:26 <FUZxxl> Does somebody over here knows J?
08:36:26 <ski> @wiki Introduction to IO
08:36:26 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:36:27 <Eduard_Munteanu> @pl \(a,b) -> [a,b]
08:36:27 <lambdabot> uncurry ((. return) . (:))
08:37:01 <lukish> benmachine: I can ++ them later
08:37:10 * ski only now realizes rwbarton asked about that one day ago
08:37:10 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
08:37:18 <ski> @messages
08:37:18 <lambdabot> maltem said 1d 1h 41m 25s ago: Btw, I am still perplexed that while SDG uses intuitionistic logic, it is entirely non-constructive (from the internal viewpoint) in that differentials are posited by
08:37:18 <lambdabot> axioms, and not at all constructed
08:37:55 <lukish> ski: are you ski from ##prolog channel?
08:38:02 <ski> of course :)
08:38:10 <lukish> Cool, nice to meet you again!
08:38:27 <rwbarton> ski: actually it wasn't me but someone else, but yeah it did come up.
08:38:28 <byorgey> there is only one ski, and he does not share power
08:38:32 <ion> ski: Are you ski from ##wintersports channel?
08:38:43 <ski> ion : Mu
08:39:23 <ski> rwbarton : yeah i know, i just meant you where looking for a quick way to reference it
08:39:33 <rwbarton> oh
08:39:49 <rwbarton> I thought you were talking about concat + transpose, but now I see you mean introduction to IO.
08:39:59 <rwbarton> ah, @wiki.
08:40:15 <ski> @wiki This page doesn't exist
08:40:15 <lambdabot> http://www.haskell.org/haskellwiki/This_page_doesn't_exist
08:41:17 <lep-delete> here is how i use it http://hpaste.org/54604 (second annotation)
08:41:49 <lep-delete> i left out some cases but i hope it is clear
08:42:54 <lep-delete> and for example my minimizeE is the same as, was it evalState
08:44:40 * hackagebot http-enumerator 0.7.1.5 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.5 (MichaelSnoyman)
08:44:42 * hackagebot wai-extra 0.4.5.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.5.1 (MichaelSnoyman)
08:44:44 * hackagebot mime-mail-ses 0.0.0.5 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0.5 (MichaelSnoyman)
08:44:46 * hackagebot warp 0.4.6.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.6.1 (MichaelSnoyman)
08:44:48 * hackagebot http-wget 0.6.2.1 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.2.1 (MichaelSnoyman)
08:45:02 <lukish> > uncurry ((. return) . (:)) (1,2)
08:45:03 <lambdabot>   [1,2]
08:45:24 <ski> lep-delete : i have no idea what you'er doing, but are you sure you want to reuse  m'  resp.  m  in `instance Minimize VarDecl' resp. `instance Minimize Statement' ?
08:45:30 <lukish> :t (. return)
08:45:31 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
08:45:54 <lukish> What is really going on in (. return) ?
08:46:02 <ion> @unpl (. return)
08:46:02 <lambdabot> (\ a d -> a (return d))
08:46:04 <ski> lep-delete : in case noone has said it yet, it looks like what you're doing it really `State NameMap'
08:46:07 <ion> @unpl (. return) . (:)
08:46:07 <lambdabot> (\ d g -> ((:)) d (return g))
08:46:33 <lep-delete> yeah i know. i just don't know how to actually translate it to State NameMap
08:48:05 <ski> lukish : `(. return)' is `\f -> f . return', so assume we pass `x :: a' as input to `f . return', the `return' will yield `m a' (assuming `Monad m'), which is passed to `f', which returns something, call it `b', so `f :: m a -> b' and `(\f -> f . return) :: (m a -> b) -> (a -> b)'
08:48:27 <ski> @unmtl State NameMap a
08:48:27 <lambdabot> NameMap -> (a, NameMap)
08:48:46 <lukish> Oh, lord
08:49:43 <ion> Hopefully nobody actually uses that. ;-)
08:49:48 <ski> lep-delete : so, first we change `min :: NameMap -> m -> (m, NameMap)' into `min :: m -> NameMap -> (m, NameMap)', from which it's s short step to `m -> State NameMap m'
08:50:13 <lep-delete> the type is not the problem, i think. i struggle implementing the list-instance of my minimize type-class
08:51:02 <ski> lep-delete : the instance for lists in the first paste looks ok
08:51:35 <lep-delete> the current version works, but without the State type
08:51:56 <ski> using `State NameMap' it could be written like `min = mapM min'
08:52:32 <lep-delete> hmm, i'll try that
08:52:40 <ski> .. but maybe you want an explicit recursive version first, to understand it better ?
08:53:01 <lep-delete> would be nice :)
08:53:45 <ski> let's look at `min s [] = ([], s)'
08:54:19 <ski> first, flipping the argument order (as noted in types above), we get `min [] s = ([],s)'
08:54:31 <lep-delete> that's putting [] in to default context, so return [] ?
08:54:33 <ski> which we can write like `min [] = \s -> ([],s)'
08:54:40 * hackagebot http-wget 0.6.2.2 - Provide a simple HTTP client interface by wrapping the wget  command line tool.  http://hackage.haskell.org/package/http-wget-0.6.2.2 (MichaelSnoyman)
08:54:42 * hackagebot cookie 0.3.0.2 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.3.0.2 (MichaelSnoyman)
08:54:45 * hackagebot data-object 0.3.1.8 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.8 (MichaelSnoyman)
08:54:45 <ski> yes, this is the case when the list is empty
08:54:47 * hackagebot wai-test 0.1.3.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.3.1 (MichaelSnoyman)
08:54:49 * hackagebot wai-websockets 0.5.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-0.5.0.1 (MichaelSnoyman)
08:55:16 <ski> anyway, now we need to recall the definition of `State'
08:55:34 <ski>   newtype State s a = State {runState :: s -> (a,s)}
08:56:29 <ski> so, using this, we change `min [] = \s -> ([],s)' into `min [] = State (\s -> ([],s))', when changing the type signature from `min :: [m] -> NameMap -> ([m],NameMap)' into `min :: [m] -> State NameMap [m]'
08:57:00 <ski> operationally, we've doing nothing at all, we're just hiding the function `\s -> ([],s)' here inside the `State' thing
08:57:42 <ski> and now, it just so happens that `return a = State (\s -> (a,s))' in the `State s' case, so we can further rewrite this into `min [] = return []'
08:57:53 <ski> lep-delete : are you following ?
08:57:56 <lep-delete> ye, i think i got this case sometime
08:58:07 <lep-delete> the other case is the hard one for me :p
08:58:17 <ski> yeah, let's look at that one noew
08:59:08 <lep-delete> (x', s') <- ? minimize x ?
08:59:16 <ski> we have `min s (x:xs) = let (x1, s1) = min s x; (x2, s2) = min s1 xs in (x1:x2, s2)'
08:59:34 <ski> after argument reordering, and moving the `s' argument into a lambda, we get
08:59:51 * hackagebot yesod-auth 0.7.6.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.6.1 (MichaelSnoyman)
08:59:54 <ski>   min (x:xs) = \s -> let (x1, s1) = min x s; (x2, s2) = min xs s1 in (x1:x2, s2)'
09:01:05 <lep-delete> sounds reasonable
09:01:24 <lep-delete> same could be done for x2, s2 i guess
09:02:54 <ski> now, we need to know how `(>>=)' works in `State s', namely `ma >>= k = State (\s0 -> let (a,s1) = runState f s0 in runState (k a) s1)'
09:03:34 <ski> the `runState' only unwraps the `State' data constructors, so we can more or less ignore those, when reading this
09:04:03 <ski> i.e. we can think of this as essentialyl saying `ma >>= k = \s0 -> let (a,s1) = f s0 in k a s1'
09:04:32 <ski> hm, actually the `f' here is meant to be `ma' (editing error), sorry
09:05:10 <ski> so, this waits for a starting state `s0', passes it to `ma', matching the result with `(a,s1)', a result and a new state
09:05:37 <ski> then it passes the result `a' to `k', to get a new `State s'-action, which wants a new state, so we pass `s1' to it
09:06:17 <lukish> How can I rewrite it in faster way?
09:06:17 <lukish> primeSets :: [Int] -> Int
09:06:18 <lukish> primeSets = length . filter (all isPrime) . map (map listToNum) . splits
09:06:18 <ski> this will return `(b,s2)', i.e. the result of the second operation, and the final state, which is what we want `(>>=)' to return here as well, so we don't need to write this
09:06:46 <rwbarton> is there a package on hackage that implements a Num instance for modular arithmetic using the implicit configuration trick?
09:06:53 <ski> (though if we want to, we *could* write `ma >>= k = State (\s0 -> let (a,s1) = runState ma s0; (b,s2) = runState (k a) s1 in (b,s2))'
09:08:01 <ski> lep-delete : anyway, the essential point is that in your `min (x:xs) = \s -> let (x1, s1) = min x s; (x2, s2) = min xs s1 in (x1:x2, s2)', you're threading the state into and out of each operation, using each state once
09:08:50 <ski> lep-delete : so, either one can now jump directly to the result (possibly checking that it's correct by unfolding the definition of `(>>=)' in the result), or one can step-by-step refine this into the final result
09:09:00 <ski> lep-delete : which would you prefer ?
09:09:18 <ski> (or maybe i've already managed to confuse you)
09:10:19 <lep-delete> hmm, i have to think about it
09:10:41 <ski> lep-delete : hum (noticing your "(x', s') <- ? minimize x ?") -- not quite, the point of using the state monad is to *hide* the passing of the states altogether, you still have  s'  in that piece of code
09:11:19 <lep-delete> so just: x' <- minimize x
09:11:34 <ski> lep-delete : *nod*, no hurry. (do tell if you want me to continue the rewriting of the code)
09:11:39 <ski> yeah, that sounds ok
09:11:46 <lep-delete> and: xs' <- minimize xs
09:11:48 <ski> yes
09:11:51 <lep-delete> the state is passed along
09:11:56 <lep-delete> so, no need to extract
09:12:00 <ski> indeed
09:12:15 <lep-delete> and finally: return $ x':xs'
09:12:33 <ski> yeah, (though i'd use brackets instead of `$', here)
09:13:09 <ski> @src mapM
09:13:09 <lambdabot> mapM f as = sequence (map f as)
09:13:18 <ski> hmpf
09:14:18 <lep-delete> now i understand how mapM would actually work with State. it's kinda like a fold
09:14:41 * hackagebot happstack-hsp 6.2.3 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.3 (JeremyShaw)
09:15:13 <ski>   mapM f [    ] = do return [    ]
09:15:18 <ski>   mapM f (a:as) = do b  <-      f a
09:15:22 <ski>                      bs <- mapM f as
09:15:24 <ski>                      return (b:bs)
09:15:38 <ski> this is the basic recursive structure of your code
09:15:48 <ski> (and that is why you could write it using `mapM')
09:15:53 <rainman85> I also have another question, how do I get the user input from the command line working? That's what I have so far.
09:15:54 <hpaste> rainman85 pasted “Fixing user input” at http://hpaste.org/54607
09:15:57 <ski> lep-delete : ^
09:16:04 <ski> @type mapAccumL
09:16:05 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
09:16:21 <ski> lep-delete : it's more like `mapAccumL' than `foldl', actually :)
09:17:12 <rwbarton> rainman85: that looks pretty OK, what is the error? (I forget the type of domsMatch)
09:18:08 <hpaste> rainman85 annotated “Fixing user input” with “Fixing user input (annotation)” at http://hpaste.org/54607#a54608
09:18:15 <rainman85> I added the error
09:18:31 <rwbarton> probably you wanted to print the result of the call to domsMatch
09:18:51 <rainman85> domsmatch returns an (Int,Int)
09:19:01 <rainman85> no, not really, just the trace
09:19:08 <rainman85> which is output by it
09:19:11 <rwbarton> the...what?
09:19:21 <rainman85> the trace output
09:19:27 <rainman85> debug trace output..
09:19:35 <rwbarton> trace as in Debug.trace?
09:19:41 * hackagebot dingo-core 0.0.3.4 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3.4 (BardurArantsson)
09:19:41 <lep-delete> Big thanks btw! :)
09:19:42 <rainman85> yes
09:19:45 <rwbarton> ugh
09:19:59 <ski> lep-delete : yw
09:20:10 <dmwit> do { input <- getLine; let n = read input; foo } = do { n <- readLn; foo }
09:20:20 <dmwit> provided foo does not refer to "input", as it doesn't here
09:20:22 <dmwit> :t readLn
09:20:23 <lambdabot> forall a. (Read a) => IO a
09:20:52 <dmwit> rainman85: domsMatch does *not*, in fact, return the trace output.
09:21:00 <rainman85> no, it does not
09:21:05 <dmwit> rainman85: But it should.
09:21:14 <dmwit> Debug.Trace is not meant for use, except when debugging.
09:21:35 <dmwit> If you are in fact interested in the output that you're handing off to trace, then you should not use trace.
09:21:38 <ion> λ> do let { n = read "40foo" }; putStrLn "o hai"; print (n :: Integer)
09:21:40 <ion> λ> do n <- readIO "40foo"; putStrLn "o hai"; print (n :: Integer)
09:21:43 <ion> Not quite the same.
09:22:10 * dmwit nods at ion
09:22:12 <ski> ion : hehe, was just about to say the same thing
09:22:34 <rainman85> I am confused. All I want to do is to be able to read an input line, parse it as an integer, and pass that integer to some function
09:22:43 <rwbarton> rainman85: that part is working fine
09:22:54 <rwbarton> you need to do something with the result of the function, though
09:22:57 <rainman85> However the interpreter is still complaining
09:23:01 <rwbarton> something = an IO action, like printing it
09:23:02 <dmwit> rainman85: You are claiming you want to do more. You are claiming you want to have access to the strings produced in that function. Is that claim not correct?
09:23:03 <ski> `readLn' and `readIO' will error out directly, if there's a parse error, while `read' will only do so when the result is demanded
09:23:08 <rainman85> ah, I see
09:23:38 <rainman85> How do I print the result of the function then?
09:24:05 <rwbarton> print (domsMatch hsdPlayer hsdPlayer n 10)
09:24:23 <johnthejohn> What is the preferable tutorial for learning Haskell? Learn you Haskell for Great Good? Real World Haskell?
09:24:33 <ion> LYAH first, RWH second.
09:24:34 <keep_learning> rainman85,  putStrLn $ show . function
09:24:37 <ion> The Typeclassopedia at some point.
09:24:41 * hackagebot dingo-widgets 0.0.3.4 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.0.3.4 (BardurArantsson)
09:24:44 <rainman85> that worked fine..
09:25:01 <keep_learning> rainman85, rwbarton already answered
09:25:11 <rainman85> Thank you again.. I really have to read about monads, have been avoiding them for so long
09:25:20 <johnthejohn> ion: Thanks.
09:27:03 <ski> keep_learning : hehe, rather `putStrLn (show <expression>)' or `putStrLn . show . <function>', if you want that
09:27:15 <rwbarton> rainman85: You can continue to put them off by remembering the rules for do block in IO: each line in the do block has to be an expression of type IO a, for some a; or of the form x <- act where act has type IO a (and then x has type a); or a let binding.
09:27:39 <dmwit> print = putStrLn . show
09:28:00 <dmwit> ?google io for people who just don't care sigfpe
09:28:01 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
09:28:01 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
09:28:12 <ski> except the last one has to be an expression of type `IO a' for some type `a', and the whole `do'-expression will then get type `IO a'
09:29:41 * hackagebot dingo-example 0.0.3.4 - Dingo Example  http://hackage.haskell.org/package/dingo-example-0.0.3.4 (BardurArantsson)
09:34:43 * hackagebot dingo-core 0.0.3.5 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3.5 (BardurArantsson)
09:34:45 * hackagebot containers-benchmark 1.1.0.0 - Extensive benchmark suite for containers package.  http://hackage.haskell.org/package/containers-benchmark-1.1.0.0 (MilanStraka)
09:40:24 <EvanR-work> dingo is also the name of a php framework
09:44:41 * hackagebot hebrew-time 0.1.0.2 - Hebrew dates and prayer times.  http://hackage.haskell.org/package/hebrew-time-0.1.0.2 (MichaelSnoyman)
09:44:43 * hackagebot wai-app-static 0.3.5.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.5.1 (MichaelSnoyman)
09:44:45 * hackagebot wai-handler-devel 0.4.4.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.4.1 (MichaelSnoyman)
09:44:55 <carpi> I am trying to come to grips with haskells type system and so far this is what I've understood "Typeclass > Type > Values"..
09:45:02 <carpi> please tell me if i got that wrong?
09:45:26 <carpi> or in other words.. values have types, types belong to type classes..
09:45:38 <c_wraith> not quite right.
09:45:42 <shachaf> carpi: No, it's a very different sort of relationship.
09:45:43 <carpi> ah shite.. knew it
09:45:46 <mauke> Kinds > Types > Values
09:45:55 <mauke> typeclasses are ... hmm
09:45:59 <c_wraith> classes are predicates on types
09:46:57 <c_wraith> the difference is that each value has exactly one type, and each type has exactly one kind.  But a type can be an instance of any number of classes
09:47:44 <c_wraith> and in fact, instances can be added anywhere
09:47:51 <carpi> what do you mean by kind? for example if i asked you what is the kind of Int.. could you please tell me.. what would you say?
09:47:56 <c_wraith> *
09:48:00 <c_wraith> @kind Int
09:48:01 <lambdabot> *
09:48:03 <c_wraith> @kind Maybe
09:48:04 <lambdabot> * -> *
09:48:08 <c_wraith> @kind Maybe Double
09:48:09 <lambdabot> *
09:48:30 <c_wraith> @kind []
09:48:30 <lambdabot> * -> *
09:48:39 <c_wraith> @kind [Int]
09:48:40 <lambdabot> *
09:48:48 <dmwit> Huh. I could have sworn I had seen a module on Hackage for modular arithmetic, but now I can't see it for the life of me.
09:48:53 <c_wraith> there are, of course, more complicated kinds..
09:48:55 <dmwit> There must be one, though, right?
09:48:59 <c_wraith> @kind RWST
09:49:00 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:49:01 <rwbarton> same here
09:49:46 <carpi> c_wraith: another way of saying RWST has soo many type parameters before it becomes a concrete type?
09:49:47 * hackagebot gps 0.8.4 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8.4 (ThomasDuBuisson)
09:49:54 <c_wraith> carpi: exactly
09:50:02 <c_wraith> carpi: you can only have values of types with the kind *
09:50:14 <c_wraith> @kind (->)
09:50:15 <lambdabot> ?? -> ? -> *
09:50:25 <carpi> in other words values can only be made from concrete types
09:50:29 <c_wraith> nevermind exactly what the ?? and ? mean.  they're special :)
09:51:05 <carpi> c_wraith: could you please tell me what they mean? just curious
09:51:51 <c_wraith> I might get them wrong, but IIRC:  ?? is the kind of unboxed primitives and lifted values.  ? is the kind of both of the previous, and unboxed tuples
09:52:04 <c_wraith> They're essentially implementation details inside GHC
09:52:49 <c_wraith> Err, yes, that was slightly wring.  ?? is the kind of unboxed *types*
09:53:03 <c_wraith> an instance of such a type is Int#
09:53:17 <carpi> c_wraith: that flew over my head faster than an sr-71.. but if i had to simplify.. with regards to "values" the possible questions you can ask is "what type of value is it?"
09:53:30 <carpi> c_wraith: with regards to types you could ask "what kind of type is it"
09:53:42 <carpi> am i going in the right direction?
09:53:50 <c_wraith> carpi: yes, exactly.  and like I said, don't worry about ? and ??, they're GHC implementation details.
09:54:43 <dmwit> Some people use the word "type" for things of kind *, and "type constructor" for things whose kind have an -> in them.
09:55:16 <carpi> c_wraith: maybe im wrong but it seems like the kind of a type answers only one question.. "is it concrete or not?"
09:55:28 <carpi> is that an error in oversimplification?
09:55:45 <c_wraith> carpi: well, not even "concrete", as I'm not sure what you mean by that.  It doesn't mean monomorphic, for instance.
09:55:50 <FUZxxl> Hello, I have a question on thunk implementation.
09:55:51 <c_wraith> @kind Maybe a
09:55:52 <lambdabot> Not in scope: type variable `a'
09:55:58 <c_wraith> @kind forall a. Maybe a
09:55:59 <lambdabot> *
09:56:01 <EvanR-work> we need if then else for kinds!
09:56:15 <roconnor> > '\x21'
09:56:16 <lambdabot>   '!'
09:56:18 <c_wraith> that's a polymorphic type with kind *
09:56:36 <roconnor> > '\x1d7d9'
09:56:36 <rwbarton> from context I think "concrete" is supposed to mean "the sort of type that has values"
09:56:37 <lambdabot>   '\120793'
09:56:45 <FUZxxl> A thunk basically is a sum-type of a value and a function creating it.
09:56:51 <c_wraith> Having a kind * just means "enough type arguments have been applied to the type constructor"
09:56:52 <roconnor> > maxBound :: Char
09:56:53 <lambdabot>   '\1114111'
09:57:13 <FUZxxl> Would it be possible to implement thunks by making the thunk a piece of code one can jump into?
09:57:15 <roconnor> > 0x10ffff
09:57:15 <carpi> rwbarton: on "learn you a haskell"... concrete is a type that values can have
09:57:15 <lambdabot>   1114111
09:57:24 <FUZxxl> (similar to GHC trampolines?)
09:57:25 <rwbarton> okay
09:57:33 <joeyh> renameFile throws an exception described as "UnsupportedOperation" when trying to rename across devices, but I can't find a way to distinguish this from other exceptions. There's no isUnsupportedOperation. help
09:57:35 <c_wraith> in that case, kind * is the same as concrete, yes
09:57:43 <c_wraith> But there are important kinds other than *
09:57:50 <c_wraith> @src Functor
09:57:50 <lambdabot> class  Functor f  where
09:57:50 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:57:51 <rwbarton> but the answer is no, if a type is not "concrete" then the kind also tells you what sort of type arguments you need to feed it in order to get a concrete type
09:58:02 <rwbarton> e.g. the RWST example from before
09:58:04 <carpi> you mean there are kinds other than concrete?
09:58:14 <c_wraith> look at the source of Functor, there
09:58:22 <c_wraith> Look at how the type variable f is used
09:58:31 <c_wraith> you see that it is given another type variable as an argument
09:58:34 <rwbarton> if there weren't kinds other than concrete why would we have a kind system?
09:58:42 <rwbarton> @kind Maybe
09:58:43 <lambdabot> * -> *
09:58:44 <c_wraith> from the context, you can determine that the type of f must be * -> *
09:58:58 <rwbarton> is a type constructor that needs one argument, a type of kind * (concrete type) to produce a concrete type
09:59:00 <c_wraith> and, given that, you know something about types that can be made into instances of Functor
09:59:15 <rwbarton> @kind RWST
09:59:16 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:59:19 <rwbarton> is more complicated
10:00:19 <aristid> RWST is only complicated because it combines three things in one (which apparently improves performance)
10:00:37 <c_wraith> yeah, look at edwardk types for *really* crazy kinds :)
10:00:50 <carpi> so there are only 2 kinds.. types that concrete are one kind and types that are not concrete the other kind. ?
10:01:01 <edwardk> c_wraith: hah
10:01:01 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:01:01 <rwbarton> no
10:01:10 <rwbarton> that's exactly the point I was trying to make
10:01:10 <c_wraith> no, there are many.  * ->* is different from * -> * -> *
10:01:19 <c_wraith> @kind Maybe
10:01:20 <lambdabot> * -> *
10:01:22 <c_wraith> @kind Either
10:01:23 <lambdabot> * -> * -> *
10:01:30 <c_wraith> @kind Either Int
10:01:31 <lambdabot> * -> *
10:01:33 <c_wraith> @kind Either Int String
10:01:34 <lambdabot> *
10:01:48 <parcs> edwardk: have you done any cool things with the PolyKinds extension yet, as you have with the ConstraintKinds extension?
10:01:55 <carpi> c_wraith: yes its true there are many.. but the difference is only in the number of type parameters required to make that type concrete..
10:02:05 <c_wraith> carpi, not necessarily.
10:02:08 <c_wraith> @kind StateT
10:02:09 <lambdabot> * -> (* -> *) -> * -> *
10:02:09 <carpi> Maybe needs 1 type parameter to be concrete
10:02:15 <edwardk> parcs: yes, but i haven't been able to test it yet
10:02:17 <aristid> and soon there will be even more kinds
10:02:18 <carpi> Either needs 2 type parameter to be concrete
10:02:24 <rwbarton> right
10:02:30 <rwbarton> and the kind system is what keeps track of this
10:02:34 <c_wraith> carpi: that needs three type arguments, but the second one needs the kind * -> *, where the others need the kind *
10:02:48 <carpi> @kind Int
10:02:48 <lambdabot> *
10:02:55 <carpi> @kind Maybe
10:02:55 <lambdabot> * -> *
10:02:55 <freiksenet> say I have type class A and type class B and all instances of B are instances of B, but instances of A don't have to be instance of B. How can I provide default implementation of class A for all instances of B?
10:03:11 <freiksenet> uh. all instances of B are instances of A*
10:03:33 <carpi> @kind Either
10:03:34 <lambdabot> * -> * -> *
10:03:36 <edwardk> parcs: mostly it is an amplification of the constraint kinds code
10:03:54 <c_wraith> freiksenet: that's a kind of dangerous thing to want, as it can result in greatly overlapping instances, which is bad for figuring out exactly what code will do
10:03:55 <edwardk> parcs: letting me talk about categories of constraints more fluidly, by using a single category class, etc.
10:04:17 <c_wraith> @kind State
10:04:18 <lambdabot> * -> * -> *
10:04:19 <parcs> edwardk: do you plan on writing about it?
10:04:20 <edwardk> parcs: and product and sum categories, smaller categories, limits, colimits, etc.
10:04:21 <c_wraith> hmm.
10:04:26 <c_wraith> I need something really trivial
10:04:29 <c_wraith> @kind ListT
10:04:30 <lambdabot> Not in scope: type constructor or class `ListT'
10:04:32 <c_wraith> bah.
10:04:33 <edwardk> parcs: when i have a compiler that i can use that implements them, sure
10:04:36 <freiksenet> c_wraith: so what is a good way to do that then?
10:04:45 <freiksenet> I mean without what i said above
10:04:59 <edwardk> parcs: i'd already implemented all this stuff in scala, so porting it to haskell is a lot of fun
10:05:15 <parcs> edwardk: ghc HEAD implements them as of like last week :)
10:05:19 <edwardk> there i used subtyping as a proxy for the kind magic
10:05:42 <parcs> er, implements PolyKinds
10:06:11 <rwbarton> What's that new GHC extension with default instances?
10:06:25 <c_wraith> freiksenet: the best way is to re-architect so you don't want that, sadly.
10:06:37 <c_wraith> rwbarton: the generics stuff?
10:07:21 <edwardk> 'DefaultSignatures' iirc
10:07:24 <rwbarton> no, I'm thinking of either http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances or http://www.haskell.org/haskellwiki/Superclass_defaults but I'm not sure whether either is what was actually implemented
10:07:29 <edwardk> but i don't have it in front of me
10:07:33 <c_wraith> carpi: consider the kind of Foo, where Foo is defined as newtype Foo f = Foo (f Int)
10:08:07 <c_wraith> carpi: Obviously, Foo only takes one type argument, but supplying it with Int won't work.
10:08:23 <edwardk> default signatures has nothing to do with Generics except for the fact that Generics makes a pretty reasonable way to provide many default signatures
10:08:52 <edwardk> i'm really looking forward to adding default signatures to Foldable that use Traversable, etc.
10:09:05 <edwardk> but its going to seriously muck up package dependencies =(
10:09:13 <c_wraith> carpi: so the kind of Foo there has to be (* -> *) -> *
10:09:16 <edwardk> because they run the 'wrong way'
10:09:31 <c_wraith> carpi: which is very different from * -> *
10:09:43 <c_wraith> carpi: even though both take one type argument
10:10:10 <carpi> dixie: c_wraith and ofcourse in Foo f, f is type parameter which is also a function?
10:10:19 <carpi> shite.. that was meant for c_wraith
10:10:37 <rwbarton> so if I take Functor/Monad I might write   class Functor f where fmap :: (a -> b) -> f a -> f b; default fmap :: (Monad f) => (a -> b) -> f a -> f b; fmap = liftM   ?
10:11:13 <rwbarton> and now if I want to define a Monad instance for some new type M I just have to write "instance Functor M" with no body?
10:12:32 <rwbarton> this syntax strikes me as a little odd
10:12:47 <sipa> carpi: it's a type function
10:14:31 <carpi> sipa: a function that returns a value of a certain type?
10:14:41 * hackagebot acid-state 0.6.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.6.1 (DavidHimmelstrup)
10:14:58 <sipa> carpi: no, a function from types to types
10:15:05 <sipa> like IO
10:15:35 <sipa> IO takes as argument another type (for example Int), and "evaluates" to the type IO Int
10:17:05 <Cale> rwbarton: Seems reasonable to me :)
10:17:18 <Cale> rwbarton: It's also what you currently usually do to define instances of Exception
10:18:50 <rwbarton> could I write default fmap :: (a -> b) -> [a] -> [b] and then it would only apply when I wrote instance Functor []?
10:20:15 <rwbarton> It just seems like you're repeating yourself by giving the whole type again when the only use case I can see is to add a context.  Indeed, the GHC user manual has a typo in its example
10:23:25 <rwbarton> I'm not saying the extension is bad or anything, just I wouldn't put it up there with ConstraintKinds as a candidate for GHC Extension of the Year. :)
10:27:34 <Eelis> hm, my program depends on packages A and B, where A depends on parsec-2 and B depends on parsec-3. when configuring my program i get a warning saying "This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure". what do i do?
10:28:06 <Eelis> (A = irc, B = network)
10:28:59 <c_wraith> Eelis: reinstall your package set from scratch.  Or at least, that's what I do in that situation.  Also, I never use the global package db.
10:29:09 <Eelis> hmm
10:29:22 <Eelis> ok, i'll try..
10:29:34 <monochrom> no, irc genuinely asks for build-depends:   base == 4.*, parsec == 2.1.*
10:29:42 <c_wraith> oh.
10:29:45 <c_wraith> that won't fix it, then
10:29:49 <Eelis> oh
10:30:21 <c_wraith> in that case, I'd cabal unpack IRC, and make it work with parsec 3, however is necessary :)
10:30:41 <Eelis> the weird thing is that i only got this problem right after i did "cabal install darcs"
10:30:52 <Eelis> before, my program worked fine (with irc and network)
10:31:02 <Ornedan_> Which might have pulled in a more recent version of network?
10:31:08 <Eelis> sounds plausible
10:31:33 <Eelis> or maybe i did actually get the warning before and ignored it. though i doubt it
10:32:00 <monochrom> you could ignore the warning and see if it works out (depends on case-by-case details). you could modify irc to depend on parsec 3.
10:32:18 <Ornedan> Depending on whether parsec api has changed much between the major versions, you might even be able to get away with just editing irc to depend on parsed 3
10:32:20 <Eelis> yeah, i'll try the former first, and the latter second
10:32:31 <Eelis> thanks everybody
10:32:56 <Ornedan> I think I've read irc package source a while ago and it didn't seem to do anything particularly complex
10:34:42 * hackagebot hepevt 0.1 - HEPEVT parser and writer  http://hackage.haskell.org/package/hepevt-0.1 (ScottLawrence)
10:35:14 <Ornedan> Could someone give me help with optimising this: http://hpaste.org/54610
10:36:12 <Ornedan> My pixel data is in the STUArray. The colour values actually fit in a Word8, but I use Word16 so the painting code doesn't need use fromIntegral (which helped a bit)
10:36:39 <Ornedan> Profiling says about 3/4ths of the runtime of that function is spent in readArray
10:37:18 <Ornedan> Profiling also says there's a lot of allocation happening due to those readArray calls, but I'm not sure why?
10:38:03 <c_wraith> Ornedan: try using reads and writes that aren't bounds-checked?
10:39:03 <c_wraith> Ornedan: also, an unpacked array means that the values being stored in it will actually be Word16#.  the allocation comes when wrapping them as Word16 values.  If that's happening, it means something isn't optimizing properly in your loop.
10:40:09 <Ornedan> c_wraith: Should I be using other compiler flags besides -O?
10:40:20 <c_wraith> try -O2
10:40:41 <Ornedan> Also, added profiler output to the hpaste
10:41:36 <Ornedan> Non-bounds-checked reads/writes? There's no mention of such in Data.Array.MArray documentation, where should I look?
10:43:16 <c_wraith> Ornedan: you are correct.  hmm.  seems I'm thinking of Data.Vector's interface.  Which may suit you better, actually.  It's a lot easier to get good performance out of
10:47:37 <Eduard_Munteanu> GHC has functions for unsafe indexing into an array.
10:47:50 <Eduard_Munteanu> GHC.Array IIRC.
10:48:27 <c_wraith> ah, sneakily hidden
10:51:26 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/GHC-Arr.html#v%3AunsafeReadSTArray
10:52:04 <Eduard_Munteanu> For some reason newer base versions don't have docs for GHC.Arr on hackage.
11:01:50 <Phantom_Hoover> Anyone know of an implementation of Ulman's algorithm in Haskell?
11:03:28 <roconnor> @hoogle lowercase
11:03:28 <lambdabot> Data.Char LowercaseLetter :: GeneralCategory
11:03:37 <roconnor> @hoogle lower
11:03:37 <lambdabot> Data.Char LowercaseLetter :: GeneralCategory
11:03:37 <lambdabot> Text.Parsec.Char lower :: Stream s m Char => ParsecT s u m Char
11:03:37 <lambdabot> Text.ParserCombinators.Parsec.Char lower :: Stream s m Char => ParsecT s u m Char
11:04:09 <hpaste> “/dev/humancontroller” pasted “OMFGWTFBBQH$X?” at http://hpaste.org/54612
11:04:30 <roconnor> > isLower '��
11:04:31 <lambdabot>   <no location info>:
11:04:31 <lambdabot>      lexical error in string/character literal at chara...
11:05:06 <roconnor> > isLower '\x1d538'
11:05:07 <lambdabot>   False
11:05:17 <roconnor> > isLower '\x1d552'
11:05:17 <lambdabot>   True
11:05:40 <roconnor> > isLower '\x1d545'
11:05:40 <lambdabot>   False
11:06:13 <Ornedan> -O2 doesn't seem to help with the allocation. Rewrote it a bit: http://hpaste.org/54610
11:07:59 <DevHC_> so does this look like a GHC bug?
11:08:45 <copumpkin> DevHC_: did you ask a question before that?
11:08:58 <copumpkin> I just saw you join the channel and ask if something looked like a GHC bug
11:09:33 <DevHC_> <hpaste> /dev/humancontroller pasted OMFGWTFBBQH$X? at http://hpaste.org/54612
11:16:19 <leoncamel> What exactly is bottom (_|_) ?
11:17:50 <shachaf> leoncamel: It represents a computation that doesn't terminate.
11:18:10 <shachaf> leoncamel: Any expression that evaluates a _|_ value is itself _|_.
11:18:40 <shachaf> An example of a _|_ value is "let x = x in x".
11:19:37 <shachaf> For convenience, Haskell provides some things which are treated as _|_ but raise an exception instead of looping. They're equivalent to _|_ from your code's perspective.
11:19:53 * shachaf assumes someone has typed all this up more clearly and put it somewhere.
11:20:12 <shachaf> @wiki Bottom
11:20:12 <lambdabot> http://www.haskell.org/haskellwiki/Bottom
11:20:18 <sipa> another is: last [1..]
11:20:26 <sipa> and yet another is: error "blah"
11:20:28 <hpaste> “^^thief^^” pasted “Trying to combine state & IO monads” at http://hpaste.org/54615
11:20:52 <^^thief^^> any help would be appreciated - problem explained in the comment at the top of the paste
11:21:00 <EvanR-work> a '_|_ value' ;)
11:21:10 <EvanR-work> is that like number infinity
11:21:41 <leoncamel> I am reading this : http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects . It mentioned, "A lifted type is one that contains bottom (_|_)".
11:21:52 <shachaf> ^^thief^^: let m = getMsg just means that m is equal to getMsg.
11:22:06 <shachaf> So you're doing "lift $ putStrLn getMsg". That's probably not what you want.
11:22:14 <shachaf> (In particular you probably want m <- getMsg.)
11:22:45 <^^thief^^> shachaf: awesome it worked!
11:22:57 <^^thief^^> haha sometimes you look all over for an answer and its that simple
11:23:05 <^^thief^^> is the approach in general a correct one?
11:23:39 <DevHC_> is the following _|_? mapM_ (\k -> print $ take k [1..]) [1..]
11:24:11 <shachaf> DevHC_: Nope.
11:24:38 <shachaf> > (mapM_ (\k -> print $ take k [1..]) [1..]) `seq` True
11:24:38 <lambdabot>   True
11:24:41 <DevHC_> yet is stack overflows :P
11:24:41 <shachaf> > undefined `seq` True
11:24:42 <lambdabot>   *Exception: Prelude.undefined
11:24:48 <DevHC_> yet it*
11:24:52 <shachaf> DevHC_: It's an IO action.
11:25:24 <DevHC_> oh ok so print (error "trol") isn't bottom
11:25:33 <^^thief^^> shachaf: just so I'm clear on what that problem was: let m = getMsg was assigning the function getMsg to m whereas m <- getMsg was actually evaluating getMsg - is that correct?
11:25:52 <shachaf> ^^thief^^: "assigning" is probably a misleading word.
11:26:14 <^^thief^^> but thats the general gist?
11:26:34 <mauke> so is "function"
11:26:46 <shachaf> mauke: True.
11:26:47 <DevHC_> no, function is 1337
11:26:49 <EvanR-work> and evaluate
11:26:57 <shachaf> Yes.
11:26:57 <DevHC_> 0-argument functions, anyone?
11:27:04 <DevHC_> or nested comments?
11:27:07 <shachaf> DevHC_: No.
11:27:17 <EvanR-work> -1 argument functions
11:27:29 <shachaf> -2-homotopy-types
11:27:36 <DevHC_> define (-1)-argument functions
11:27:58 <benmachine> DevHC_: print (error "trol") sometimes isn't even an error
11:28:10 <benmachine> if your Show instance is super-lazy
11:29:00 <benmachine> putStrLn (error "trol") will throw an error if you execute it, but is still not _|_
11:29:29 <DevHC_> btw benmachine
11:29:36 <DevHC_> trem haskell scripting is almost ready
11:29:56 <benmachine> almost?
11:29:59 <DevHC_> almost.
11:30:07 <EvanR-work> almost, euphemism for 'not' ;)
11:30:07 <DevHC_> if it weren't for GHC bugs :P
11:30:15 <dubuisst> preflex: seen dons
11:30:16 <preflex>  dons was last seen on #haskell 9 days, 3 hours, 18 minutes and 15 seconds ago, saying: i'm somewhat following the mails
11:30:19 <benmachine> my stance of "I'll believe it when I have the code" continues to apply
11:32:45 <tommd> @tell dons the download-curl builddeps are bady out of date.  If it's alright with you, I'll upload a new package.
11:32:45 <lambdabot> Consider it noted.
11:34:27 <c_wraith> tommd: you still use download-curl?  I thought segfault issues moved people away from it.
11:35:20 <tommd> c_wraith somethings I use use somethings that use download-curl ;-)
11:35:41 <hpaste> “/dev/humanconTROLLER” pasted “Tremulous Haskell scripting teaser” at http://hpaste.org/54616
11:35:49 <EvanR-work> haskell editors should be fitted with 'hardcore' mode, if your program ever segfaults, it deletes all your code and all associated libraries from your machine, and all online sources
11:35:59 <DevHC_> benmachine: http://hpaste.org/54616 :P
11:36:26 <c_wraith> EvanR-work: that'd make developing native bindings painful.  it should only be enabled for *users* of native bindings
11:36:47 <tommd> c_wraith: What is the goto-replacement package? download?
11:36:58 <c_wraith> http-enumerator
11:37:14 <c_wraith> not an exact fit
11:39:25 <tommd> Works for me.
11:39:39 <Vaerros> DevHC_: so you're a tremulous dev?
11:40:06 <Ornedan> c_wraith: You recommended vectors instead of STArray. Would the equivalent vector operations be in Data.Vector.Unboxed.Mutable, read and write functions?
11:40:16 <benmachine> Vaerros: not an "official" one
11:40:24 <benmachine> but he writes code, yes
11:41:10 <Vaerros> I love that game -- used to play it all the time
11:41:24 <benmachine> likewise
11:41:41 <benmachine> well, I kind of don't have time for it nowadays
11:41:44 <c_wraith> Ornedan: those look like the right ones, yes
11:42:16 <DevHC_> Vaerros: PROBLEM?
11:42:20 <shadyp\> hey guys I'm having trouble modeling requirements of an implementation. suppose I wan't some "instance" of a problem to implement certain functions. it feels nice to have a class that specifies the required functions (like an interface), but that requires a data type to model, which leads to problems when certain functions doesn't require that data type as a parameter. another option is to go with functions embedded like records but then I can't sp
11:42:28 <Vaerros> DevHC_: just commenting
11:42:38 <DevHC_> yes i am, with an appropriate definition of dev
11:43:01 <benmachine> appropriate/inaccurate :P
11:43:55 <EvanR-work> tremulous in written in haskell now?
11:44:12 <benmachine> no, DevHC_ claims he will be able to script it in haskell though
11:44:27 <EvanR-work> lol haskell scripting
11:44:40 <benmachine> what's wrong with haskell scripting :P
11:45:01 <EvanR-work> its not agile enough
11:45:10 <benmachine> you are wrong
11:45:13 <benmachine> well
11:45:22 <benmachine> it's subjective, but imo haskell is friggin' agile
11:45:34 <DevHC_> define agile
11:45:35 <benmachine> I've written haskell scripts
11:45:42 <mapreduce> @quote agile
11:45:42 <lambdabot> Cale says: I should write a program which automatically mods down any article containing the word "Agile"
11:45:43 <EvanR-work> im joking
11:46:15 <DevHC_> it's more pleasant to code in than that piece of shit C code
11:48:49 <shurikas> question to people who use leksah: is there a way to see how much time my program take to execute?
11:53:24 <Cale> shurikas: I don't know about leksah, but GHC has pretty extensive profiling tools
11:54:20 <tommd> What would you want, ideally?  Automatic, real time complexity analysis of the function your have hilighted?
11:57:22 <benmachine> a general algorithm to verify if the function I have highlighted terminates, please
11:57:36 <shadyp\> are there any connections between complexity analysis and haskell (specific to haskell), like all the talk about category theory?
11:57:45 * benmachine promises not to then edit this algorithm in leksah
11:57:55 <shachaf> benmachine: const True
11:58:12 <benmachine> shachaf: :< touché
12:04:43 * hackagebot attoparsec-iteratee 0.4.0 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.4.0 (JohnLato)
12:06:31 <EvanR-work> 'blazing-fast'
12:07:01 <EvanR-work> is that more or less fast than ninja fast
12:07:16 <donri> bazinga
12:07:30 <EvanR-work> remarks like this should have year number attached for reference
12:07:52 <EvanR-work> remember PC with 'turbo' button which increased your clock speed to 166MHz
12:30:58 <kakos> EvanR-work: I remember those.  They were used so you could play games that relied on processor frequency.  So, you'd intentionally slow it down
12:31:42 <sbi> best part is it was a "slow down button" but it was labeled as turbo
12:31:43 <sbi> =)
12:32:33 <EvanR-work> lol
12:39:44 * hackagebot fuzzytime 0.7.5 - A 'ten past six' style clock  http://hackage.haskell.org/package/fuzzytime-0.7.5 (KamilStachowski)
12:47:25 <tsou> Hello..  I'm trying to use writeFile to write some "unicode" characters on a file and I get this error:  commitBuffer: invalid argument (Illegal byte sequence)
12:47:31 <tsou> any ideas on how to fight this?
12:47:42 <c_wraith> tsou: what version of ghc?
12:47:55 <tsou> 7.0.4
12:48:14 <c_wraith> what os?
12:48:28 <tsou> openbsd
12:48:44 <c_wraith> ooh.  interesting
12:49:18 <tsou> aha.  i'd call it "annoying" too :P
12:49:20 <c_wraith> what is your locale set to?
12:49:39 <c_wraith> ghc attempts to use your locale settings, by default, for character encoding
12:49:48 <c_wraith> at least, after 6.12, it does.
12:50:00 <c_wraith> you can also set the encoding explicitly on a handle, if you desire
12:50:12 <c_wraith> http://hackage.haskell.org/packages/archive/base/4.4.1.0/doc/html/System-IO.html#v:hSetEncoding
12:50:13 <tsou> locale and openbsd don't like each other very much, last time I checked, but maybe i'm wrong now, it's been quite a while
12:50:19 <tsou> what variable do you have in mind?
12:50:22 <copumpkin> tsou: are you treating String as a byte buffer perhaps?
12:50:27 <copumpkin> or as a sequence of unicode code points?
12:51:22 <tsou> it's just a one-liner: main = writeFile "hello.txt" "αρχίδια"
12:52:00 <copumpkin> hmm
12:52:14 <tsou> c_wraith: my LANG is set to en_US.utf8, which seems to work well with other apps that read this variable.. is there any other variable that i should set?
12:52:26 <c_wraith> I'm not sure which ghc actually looks at.
12:52:33 <tsou> aha
12:52:55 <c_wraith> can you try a slightly more verbose version that explicitly sets the encoding?
12:53:23 <rwbarton> try LC_ALL=en_US.utf8 just for good luck?
12:53:57 <tsou> rwbarton: same
12:54:04 <Eelis> how do some people manage to write entire Haskell programs without ever writing type declarations for toplevel functions and not go crazy? this truly baffles me..
12:54:05 <tsou> c_wraith: i'll try, with hSetEncoding you mean?
12:54:09 <c_wraith> yes
12:54:44 * hackagebot clientsession 0.7.3.6 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.3.6 (MichaelSnoyman)
12:54:57 <Philonous> Eelis:  Ever tried python?
12:55:07 <Eelis> Philonous: only for throwaway scripts
12:55:27 <c_wraith> meh.  my sufficiently large python programs sprouted comments that pretended to be type signatures.
12:55:35 <NemesisD> hi all. trying to install cabal-dev, cabal complains that Data.Map is a member of a hidden package containers. Using GHC 6.10, what can be done?
12:56:04 <freiksenet> I have several static text files. Is it possible to ask haskell to read them once on compile time and then store inside executable?
12:57:22 <c_wraith> freiksenet: yes, you can do that with template haskell.
12:58:15 <freiksenet> c_wraith: ok tnx, I'll take a look.
12:58:31 <parcs> NemesisD: get a newer version of ghc? :P
12:58:33 <dgpratt> copumpkin: I took your advice (well, I think it was your advice)...
12:58:47 <dgpratt> ...now the proud owner of TaPL
12:58:53 <copumpkin> I do give very good advice
12:58:59 <lukish> How can I simplify that tho (***) uses?
12:59:00 <lukish> (***) last2 head2 . join (***) numToList $ (1234,3456)
12:59:01 <copumpkin> but in this case, I'm not sure it was me
12:59:11 <c_wraith> freiksenet: it might be a bit overwhelming.  TH is rather heavy.  It's worth looking to see if any existing projects on hackage do it already
12:59:12 <NemesisD> parcs: i don't want to unless i have to. i have to compile this binary in a production environment so that will require bugging my host. plus theyre using CentOS so i'm thinking ghc7 probably isn't even in stable yet
12:59:17 <NemesisD> any alternative?
13:00:13 <ocharles> Anyone happen to have an example of digest authentication with http-enumerator or HTTP?
13:00:18 <ocharles> I can't figure either of them out :(
13:00:27 <c_wraith> freiksenet: http://hackage.haskell.org/package/file-embed seems to be what you're looking for
13:01:03 <mike-burns> Not sure if any Haskell HTTP lib supports auth. Or anything else you want to use.
13:01:13 <ocharles> https://github.com/haskell/HTTP/blob/master/test/httpTests.hs#L163aha!
13:01:23 <ocharles> not sure why I didn't look there first
13:01:24 <tsou> c_wraith: same error (I think).. i'll paste my source cause I'm pretty sure i'm doing something stupid..
13:02:29 <hpaste> tsou pasted “unicode woes on openbsd, ghc 7.0.4” at http://hpaste.org/54619
13:02:40 <DevHC^> is there such a thing as an hs-boot-boot file?
13:03:07 <freiksenet> c_wraith: if I also parse it inside a constant, will GHC fold it on compile time?
13:03:42 <c_wraith> freiksenet: no, parsing it will be done at runtime, unless you do get into the hairy details of template haskell yourself :)
13:04:16 <freiksenet> so eg x = 1 + 1 will also happen on runtime and haskell wouldn't be able to fold it?
13:04:36 <c_wraith> depends on what optimizations are enabled.  that one might be evaluated at compile time.
13:05:05 <c_wraith> but in general, constants that consist of applying functions to constants aren't evaluated at compile time.
13:05:32 <c_wraith> In fact, that's what CAF objects are, if you ever end up wondering when doing heap profiling.
13:05:42 <rwbarton> tsou: setting the encoding of stdout isn't going to help
13:06:16 <tsou> rwbarton: oh, i have to use /dev/stdout intead of hello.txt to check it
13:06:18 <tsou> right?
13:06:19 <c_wraith> freiksenet: in fact, it's possible to have recursive constants in haskell, so anything that evaluates them at compile time is a non-general optimization.
13:06:30 <rwbarton> yeah
13:06:34 <rwbarton> or you could use putStr :)
13:06:54 <freiksenet> okay, I see.
13:06:55 <rwbarton> not sure actually whether /dev/stdout would be the same
13:07:04 <freiksenet> c_wraith: thanks!
13:08:03 <Philonous> freiksenet:  http://hpaste.org/54620 as a bsic inspiration
13:08:10 <tsou> rwbarton: putStrLn works like that.. what do i need to set to utf8 in order for writeFile to use it?
13:08:40 <Philonous> freiksenet:  foo will be a string literal containing whatever was inside the file
13:09:31 <freiksenet> aha, so I can actually run any code inside that? so it's similar to lisp macros?
13:09:32 <rwbarton> tsou: you'll need to write your own writeFile
13:09:41 <rwbarton> based on the normal writeFile source I would suggest
13:09:42 <freiksenet> inside $() I mean
13:10:01 <rwbarton> writeFile f txt = withFile f WriteMode (\ hdl -> hSetEncoding hdl utf8 >> hPutStr hdl txt)
13:10:20 <Philonous> freiksenet:  Similar, yes, but you can only refer to imported names \
13:10:48 <tsou> rwbarton: hmm I actually need this to work, cause another program is using it, so I think this goes too far
13:10:52 <rwbarton> oh
13:11:01 <freiksenet> Philonous: what does that mean? I can't use function I defined inside file?
13:11:10 <freiksenet> or you mean I can't refer to free variables?
13:11:10 <tsou> i thought there would be some kind of easy way to configure how writefile behaves by defailt
13:11:18 <rwbarton> well there is on other OSes...
13:11:25 <c_wraith> freiksenet: yes, that's what it means.  You need at least two files if you're writing and using template haskell splices
13:11:26 <tsou> :(
13:11:27 <Philonous> freiksenet:  Yes, if you want to use a function you have to define it in another module and import it
13:11:43 <rwbarton> do you mean from inside Haskell? what part of the program can you modify exactly?
13:11:52 <tsou> but, shouldn't this only amount to reading a specific env var?
13:11:58 <freiksenet> great, thanks!
13:12:52 <rwbarton> on linux it calls setlocale to get the locale
13:13:27 <tsou> oh, so it's more than just reading a variable.. :|
13:16:24 <tsou> damn, frustrating that i have to choose between unicode and openbsd
13:16:36 <silver_> lol
13:16:41 <tsou> rwbarton: i guess what you suggested makes more sense.. to create a custom writeFile that uses the correct encoding..
13:16:50 <eyebloom> What does it mean that a function has type *->* ?
13:17:00 <mike-burns> That looks like a kind.
13:17:09 <c_wraith> tsou: you have a valid bug here, I believe.  Report it.  maybe BSD support will be better in the future.
13:17:29 <eyebloom> What's the difference between type and kind?
13:17:35 <roconnor> I don't understand the problem that cabal-src is solving
13:17:51 <tsou> c_wraith: this looks like a bug of what, though.. ghc?
13:17:54 <c_wraith> eyebloom: types describe values.  kinds describe types
13:18:02 <c_wraith> tsou: yes, it sounds like a ghc bug
13:18:23 <hpaste> wires pasted “cabal install cabal-dev fail, wut?” at http://hpaste.org/54621
13:18:24 <rwbarton> it may instead be a BSD bug :P
13:18:25 <eyebloom> So kinds only occur in typeclasses?
13:18:48 <wires> Hi i'm having troubles installing cabal-dev... any thoughtS? (see paste ^^)
13:19:04 <mike-burns> eyebloom: Kinds are signatures for constructors.
13:19:08 <mike-burns> (Roughly.)
13:19:24 <c_wraith> eyebloom: no, kinds appear everywhere type constructors appear.  They're just specified explicitly most often in classes.
13:20:00 <eyebloom> Ok thanks I'll look those up.
13:20:18 <accel> is there a project building something like mathematica on top of haskell?
13:21:02 <luite> nope, never heard of anything like that
13:21:03 <silver_> there bindings to mathematica in haskell
13:21:33 <wires> accel, not your question, but there is something like that for clojure
13:21:53 <wires> http://clojuratica.weebly.com/
13:22:53 <wires> oh and this lambda wiki thing... what was that again
13:23:15 <wires> http://www.reddit.com/r/haskell/comments/hf8l4/wolfgang_a_wolfram_alpha_clone_in_haskell_under/
13:23:30 <DevHC^> fuck this buggy ghc
13:23:44 <luite> wires: yeah I'm still working on that
13:24:13 <DevHC^> what does "export main:H RIO" mean in the J module's --show-iface output?
13:24:30 <wires> luite, I thought it was pretty cool
13:24:31 <DevHC^> does that mean that i should be able to do "import J (RIO)"?
13:24:37 <accel> luite: can I get a preview?
13:24:49 <accel> luite: the reddit link links to a page that says preview over
13:26:26 <wires> anyone have any idea what cabal is failing again? --> http://hpaste.org/54621
13:26:50 <luite> accel: not yet, there is no publicly accessible version at the moment, I hope to launch early 2012 with a limited functionality version (which means that most of the wiki functionality will work, but lots of extra's like a pastebin with haskell eval and showcase etc won't be ready yet)
13:27:10 <wires> luite, why did you take it offline?
13:27:33 <luite> wires: I wasn't terribly confident about the security of that version
13:27:33 <accel> luite: is this goign to be commercial or open source?
13:27:39 <luite> accel: open source, BSD
13:27:52 <accel> is it on github?
13:27:52 <wires> ah :)
13:28:00 <luite> accel: not yet, will upload code when launched
13:28:39 <luite> wires: the preview used hint, and what you could do was similar to what lambdabot allows
13:28:51 <luite> wires: with the new one, you can run any code, including IO
13:29:01 <accel> wait wait
13:29:06 <accel> is the UI web based or native?
13:29:13 <luite> wires: and you can upload data files, or images, to the wiki, and open those
13:29:24 <copumpkin> HOLY SHIT: http://www.scottaaronson.com/blog/?p=839
13:29:42 <luite> accel: web. at first it's going to be just a wiki, hosted service, but later a local install is planned, with wai-webkit
13:30:28 <DukeDave> Can anyone suggest why, when trying to cabal-dev install something, which uses another library (which is also written by myself), I obtain:
13:30:28 <DukeDave> "Failed to load interface for..", and "here are files missing in the...", errors
13:30:41 <wires> copumpkin <-- holy shit
13:30:41 <luite> wires: the problem with hint was that it was impossible to uche a larger number of packages
13:31:08 <DukeDave> The interface it's missing isn't exported by the included library, incidentally
13:31:36 <luite> wires: I want to install lots of things from hackage for people to use, like diagrams, repa, graphviz, you name it. but linking those dynamically to eval some expression takes a lot of time
13:31:43 <luite> wires: so I had to rewrite it completely
13:32:54 <DevHC^> copumpkin: ROFL
13:33:18 <luite> some screenshots of recent development versions http://hdiff.luite.com/tmp/
13:35:25 <wires> luite, that is cool, happy to see it progressing!
13:35:49 <angstrom> > (
13:35:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:36:37 <copumpkin> luite: what is that? it looks nice
13:36:57 <wires> luite, you should either push the source somewhere or setup a twitter account such that we can follow the progress
13:39:25 <luite> wires: hehe I don't twitter :p I want to have a working, public, version before I push the source, because I'd like to have one main wiki to try and build some community of people making pages
13:39:29 <dolio> Isn't that Wolfgang Lambda?
13:39:37 <luite> maybe I'm wrong in delaying the release of the source, dunno :)
13:40:07 <luite> copumpkin: basically a wiki where every page is a haskell (.lhs + markdown) module, with interactive editing and evaluation, with graphics etc
13:40:19 <copumpkin> luite: interesting
13:40:24 <luite> dolio: yep, although I've dropped the Lambda part from the name now
13:41:09 <luite> I've mailed the haskell.org committee to see if they want to give me the wolfgang.haskell.org subdomain for it
13:42:09 <luite> copumpkin: every page has a module name, Wolfgang.Page1 would be w.h.o/wiki/Page1, and since pages are module, you can just import Wolfgang.Page2 for example
13:42:17 <accel> when will the haskell platform ppl get their acts togeter
13:42:23 <accel> and produce a haskell platform for osx lion?
13:42:46 <copumpkin> luite: cool, I see. Do you see this as a hosted site that people will edit, or something that people can deploy?
13:43:31 <accel> why is it called wolfgang?
13:43:34 <luite> copumpkin: first a hosted site, security is kind of tricky, everythign runs on a specially configured virtual machine with SELinux now, with 50 restricted user accounts for the evaluation
13:43:34 <accel> is it your last name?
13:43:39 <accel> or is it a play on wolfram?
13:43:42 <luite> yes
13:43:43 <luite> the latter
13:43:47 <accel> ah
13:43:51 <accel> why not wolf-l1-cache then?
13:43:52 <luite> Wolfgang|Lambda used to be the name
13:43:55 <accel> or wolf-ssd
13:44:58 <luite> copumpkin: since it allows IO code, opening files and stuff, it has to rely on the operating system for security. I'm not sure yet how to make a deployable version, perhaps a complete vm disk image even
13:45:18 <luite> oh and it uses sphinx and postgresql
13:45:23 <luite> really not install-friendly :)
13:45:24 <copumpkin> oh, I just meant a cabal package containing most of the good bits
13:45:28 <copumpkin> ah ok
13:46:38 <accel> copumpkin: hey; I think for once, our interest are aligned
13:46:40 <luite> the hosted version is the easiest to do, and I already have a server for it, so I'll do that first
13:46:45 <accel> convince luite to release code :-)
13:47:08 <lukish> How can I get list elements from i to j? f 3 5 [1..10] == [3,4,5]
13:47:26 <accel> some combo of head, tail, drop, and take
13:47:42 <accel> or even zip + filer
13:47:45 <accel> err, zip + filter
13:47:47 <luite> accel: the quality of the code is really sub-par though, but I'll improve that later
13:48:20 <DukeDave> Solution to my own question: You need "other-modules:" (see: http://en.wikibooks.org/wiki/Haskell/Packaging#Internal_modules)
13:48:43 <aavogt> > takeWhile (<= 5) . dropWhile (< 3) $ [ 1 .. 10 ]
13:48:44 <lambdabot>   [3,4,5]
13:48:55 <accel> @quote accel
13:48:55 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
13:49:01 <accel> @quote accel
13:49:01 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
13:49:15 <luite> Wolfgang is a relatively common name in germany though, and there are some haskellers with that name :p so i f the committee has a problem with it, I'll change it (or host it hunder my own domain)
13:49:34 <aavogt> > map ([ 1 .. 10 ] !!) [2 .. 4]
13:49:35 <lambdabot>   [3,4,5]
13:49:50 <jaj> wolfgang, the walk of the wolf
13:52:18 <gwern> preflex: seen nomeata
13:52:18 <preflex>  nomeata was last seen on #darcs 9 days, 3 hours, 59 minutes and 1 second ago, saying: Heffalump: I thought it was darcs2.
13:52:27 <accel> name it mozart
13:52:56 <benmachine> aavogt: that looks quadratic :P
13:53:06 <aavogt> yep, not that it matters
13:53:34 <benmachine> > let sublist k n = drop (k-1) . take n in sublist 3 5 [1 .. 10]
13:53:35 <lambdabot>   [3,4,5]
13:54:33 <luite> accel: nah
13:55:49 <wires> luite, regarding "Wolfgang lambda" I would be particularly interested to run a local version with storage in a git repo..
13:56:28 <wires> such that I can write stuff on my laptop when I'm traveling and then push to another machine to publish it
13:56:36 <luite> wires: hehe yes I was afraid of that ;p an older version used a git repo as storage but I've changed that to postgresql+sphinx later
13:56:56 <copumpkin> the sphinxter
13:57:11 <wires> oh, damn :)
13:57:20 <wires> what about abstracting the persistence layer?
13:57:50 <luite> it's already partially abstracted, but there are some things that don't really map well to git
13:58:13 <wires> probably..
13:58:55 <wires> well, what about having the canonical files in git and pre-process them into a sqlite db?
13:59:03 <luite> for example in the wiki you can lock a page, or give users access. those attributes are not for a page revision, but for the page itself
13:59:05 <wires> that gives you a no hassle single user install
13:59:08 <accel> alright; I have reduced my problem ot the following:
13:59:12 <accel> is there any dvi viewer bindings for haskell?
13:59:16 <accel> like, say, xdvi?
14:01:36 <luite> wires: yeah that's certainly a possibility, for later though. the current version really uses SQL and sphinx for lots of queries, things like viewing recent activity of users, recently modified pages
14:02:05 <luite> it would be possible to store the pages in git and those things in sqlite
14:02:14 <wires> luite, yes. first things first.
14:02:15 <luite> but it's more work :)
14:02:37 <wires> anyway, cool project
14:02:52 <luite> wires: the wiki already has user dirs by the way, by default only the owner can edit them (or see them if you don't make a page public), you can give other people access
14:03:25 <luite> still hosted, but you can have your own pages. I hope that will be useful for things like weblogs
14:08:58 <carpi> if i had a class that declares some functions then any type that is an instance of that class must implement those functions.. yes? Did i understand correctly?
14:09:29 <Botje> yes. you can give default implementations in the class definition, however.
14:10:01 <kmc> even if you haven't given a default, failing to implement one of these functions is only a warning at compile time
14:10:07 <kmc> attempting to use the function will crash at runtime
14:10:21 <copumpkin> omg kmc is back
14:10:36 <kmc> hi copumpkin
14:12:03 <benmachine> I always thought that was one of the sillier parts of haskell
14:12:12 <carpi> thanks..
14:12:14 <benmachine> filling in unimplemented methods with bottoms
14:12:32 <benmachine> would it kill you to just write method = defaultMethod for each one?
14:12:58 <benmachine> I mean it would prevent some backward-compatible changes, but I reckon that's a solvable problem
14:13:00 <carpi> when we say that a type is an instance of a certain typeclass then is it implicitly understood that the "type" exhibits certain behaviours?
14:13:05 <benmachine> (and incompletely solved by the current state)
14:13:13 <aditya> Is there an example of the Haskell-ObjC binding (HOC) being used for a released project? Has anyone here worked with HOC?
14:13:26 <kmc> carpi, for some definition of "behaviors" yes
14:13:40 <carpi> kmc: could you please elaborate?
14:13:47 <acowley> I think that wording is dangerous
14:13:52 <kmc> i can't
14:13:58 <copumpkin> benmachine: hey, what about unfilled record fields?
14:14:02 <copumpkin> > (,) {}
14:14:03 <lambdabot>   (*Exception: <interactive>:3:0-5: Missing field in record construction
14:14:04 <carpi> are you saying the type need not exhibit every behaviour prescribed by the typeclass?
14:14:10 <acowley> Types as we define them can be instances of some typeclasses in multiple ways
14:14:11 <wires> aditya, doesn't the haskell platform installer use those?
14:14:17 <benmachine> copumpkin: them too, probably
14:14:17 <copumpkin> > Left {}
14:14:18 <lambdabot>   Left *Exception: <interactive>:3:0-6: Missing field in record construction
14:14:37 <benmachine> carpi: well, you have to trust the person who instances the class to provide valid definitions that obey the laws
14:14:47 * hackagebot type-unary 0.1.9 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.9 (ConalElliott)
14:15:16 <kmc> carpi, I don't know what you mean by the word "behaviours"
14:15:17 <wires> luite, well, looking forward to seeing it online!
14:15:35 <aditya> wires: It does? Do you mean for the Mac installer?
14:16:14 <acowley> It is not really helpful to say "The type Int is a Monoid." Instead, a typeclass instance is a collection of implementations along with a type. This is literally what we have in Haskell, but also what you might write when doing pen and paper math.
14:16:17 <wires> I thought so..?
14:17:02 <aditya> wires: Hmmm ... That's a good point. I hadn't thought of that. If you know of any other Haskell apps that are written for the Mac, let me know. Thanks for the tip!
14:17:31 <carpi> kmc: the property of a group of entities to exhibit similar charecteristics. like for instance.. the ability of values that belong to types that are instances of Eq to be compared..
14:18:41 <photex_> hi folks
14:18:50 <aditya> photex_: Hi.
14:18:55 <photex_> I'm having a difficult time with matrices in the OpenGL binding
14:18:59 <wires> aditya, except that I think it's not true what I said. must have confused it with another thing...
14:19:03 <photex_> I'm not sure it's because I can't read haddock docs
14:19:10 <photex_> or it's just something not documented well at all
14:19:12 <photex_> haha
14:19:18 <aditya> wires: Oh, ok, thanks for checking.
14:19:27 <kmc> carpi, I think what you are asking is not well-defined enough to be true or false.  for any type class I can invent a notional "behavior" represented by that type class.  in some cases it might strain your intuitive idea of what a "behavior" is
14:19:36 <acowley> photex_: what problem are you having?
14:19:38 <photex_> for the most part it seems to revolve around IO
14:19:55 <photex_> I'm trying to accumulate view transformations
14:20:07 <photex_> to implement an arcball interaction
14:20:36 <photex_> so my state stores an: IORef (IO (GLmatrix GLdouble))
14:20:53 <photex_> because that's what newMatrix creates
14:20:54 <acowley> Too many IOs
14:20:57 <carpi> i need more study
14:21:20 <wires> aditya, np
14:21:54 <photex_> acowley: what's the best way to initialize a field like that then?
14:22:03 <photex_> just use <- get (matrix ...)
14:22:04 <photex_> ?
14:22:48 <acowley> photex_: Something like, newMatrix foo bar >>= newIORef
14:24:01 <photex_> hrm, ok, man, I feel like I keep almost getting a handle on some of this
14:24:02 <photex_> haha
14:24:37 <c_wraith> photex_: do you really want that type, though?  You want to store an action that creates a matrix, rather than the result of creating a matrix?
14:24:55 <acowley> c_wraith: that's what we were just working through
14:24:59 <c_wraith> ok
14:25:19 <photex_> in C land I'd just move around a double[16]
14:25:28 <photex_> and in Haskell land, I'm still figuring that stuff out
14:25:29 <photex_> haha
14:25:42 <c_wraith> yeah, sounds like you want just the matrix, not the IO action that creates it.
14:25:52 <kmc> photex_, an IO Matrix is not a matrix; it's a program which, if executed, would produce a matrix
14:26:06 <acowley> You'll get there, you just need to gain a better intuition for what the types are telling you
14:26:13 <kmc> indeed executing it more than once could produce different matrices
14:26:30 <kmc> so I think you want IORef (GLmatrix GLdouble)
14:27:28 <photex_> kmc: correct
14:27:44 <photex_> I want to store the modelview matrix each frame
14:28:19 <photex_> rather, I want to load the identity matrix, apply my current transform, multiply by the stored matrix, then store the result
14:28:41 <photex_> but I'm still working out how to store the matrix
14:29:51 <Jacco> I've got a question about the use of, for instance, IORef
14:30:14 <Jacco> suppose you have this matrix, and you create a new matrix which is the "updated" version of the previous one
14:30:18 <acowley> You can do this using the classic OpenGL matrix machinery, or you could separate your matrix manipulations using a linear algebra library and then write a small interface to bridge the gap back to OpenGL.
14:30:22 <c_wraith> photex_: part of me wonders if you even really need an IORef for what you're doing.
14:30:53 <Jacco> when "updating" a value in IO, you are actually just creating a new value (because everything is immutable, right?)
14:30:55 <c_wraith> and, good grief.  Are you two taking the same class or something?
14:31:05 <c_wraith> No, IORefs are mutable cells.
14:31:12 <acowley> Jacco: we have mutable cells in Haskell
14:31:18 <Jacco> ok then
14:31:21 <photex_> my understanding of an IORef is largely how I share state between callbacks
14:31:21 <Jacco> but under the hood
14:31:32 <Jacco> are they just using immutable data and smart garbage collection?
14:31:41 <c_wraith> Jacco: no.
14:31:48 <Jacco> ok then
14:31:50 <c_wraith> Jacco: when we say mutable, we mean it
14:31:55 <Jacco> :)
14:32:39 <c_wraith> photex_: oh, yeah, across callbacks you might need a system like that.
14:32:41 <acowley> Once you writeIORef, you never go back!
14:32:43 <kmc> Jacco, the value itself is immutable
14:32:48 <kmc> values are immutable by definition
14:32:58 * byorgey doesn't know what everyone is talking about.  IORefs still store immutable values.
14:33:00 <kmc> but the reference cell isn't a value
14:33:06 <byorgey> the reference itself is mutable but the values stored in it is not.
14:33:08 <kmc> it's a box that holds different values from time to time
14:33:25 <kmc> similarly in IO you can also change the contents of a file on disk
14:33:36 <kmc> if you've previously read a String from that file, the String doesn't magically change
14:33:47 <kmc> but if you read the file again, you will get a different String
14:33:56 <Jacco> and it is the fact that it is encapsulated by the IO construct, that is considered as
14:33:58 <Jacco> "pure"
14:34:03 <Jacco> am I correct?
14:34:05 <kmc> no
14:34:09 <kmc> just... abandon that whole line of thought
14:34:50 <kmc> don't worry about what's "pure"
14:34:52 <acowley> byorgey: I don't know that viewing a double* as immutable reflects the intended usage of the pointer here
14:35:02 <kmc> the amount of time that gets wasted on that word...
14:35:07 <kmc> have you seen http://www.haskell.org/haskellwiki/Introduction_to_IO ?
14:35:36 <copumpkin> the only thing that pure describes is the state of my innocent mind
14:35:40 <byorgey> acowley: well, if you're storing a simple unboxed value then the distinction isn't important, I agree
14:35:41 <acowley> In fact, the OpenGL library is a pretty nasty way to learn about IO in Haskell.
14:35:44 <Jacco> well, the fact is, I'm quite interested in the haskell language, but I really want to understand the core mechanism, and also have a good idea about the refferential transparancy
14:36:08 <byorgey> acowley: but if you are storing say a binary tree in an IORef, updating it still requires O(log n) time to rebuild the tree, etc.
14:36:09 <acowley> copumpkin represents all that is pure about Haskell
14:36:34 <copumpkin> oh I certainly do
14:36:41 <acowley> byorgey: Yes but we are for some reason involved in porting grotty C pointer munging to Haskell atm :/
14:39:35 <photex_> ok, so this is illuminating... to a point
14:39:36 <photex_> lol
14:40:11 <photex_> I certainly need to build a guide to the docs and type representation
14:40:21 <photex_> but I'm figuring it'll come about with practice
14:40:55 <acowley> photex_: try to follow a haskell tutorial like LYAH to learn about monads and IO separate from OpenGL nuts and bolts. The connections to C confuse the issue.
14:41:15 <photex_> the program I'm working on is visualizing GPX route files because I need something big to bite on
14:41:21 <photex_> otherwise I never really dig in and learn
14:41:43 <photex_> I am referring to the books, but yeah, OpenGL might have been a complicated place to start
14:41:59 <photex_> but once the primary interaction is in place, I can go back to some other fun things
14:42:01 <acowley> That's a good plan, but you should use that goal to motivate building your foundations rather than an excuse to skip them.
14:42:50 <kmc> what have you already done in Haskell, photex_?
14:43:00 <acowley> OpenGL isn't so much complicated as it is just hard to make look like idiomatic Haskell.
14:43:12 <freiksenet> mm, I wonder what am I doing wrong and why I can't just use those strings there %)
14:43:14 <freiksenet> https://gist.github.com/2a38069cb7a31a1a564b
14:43:26 <kmc> working with OpenGL is a good way to practice imperative programming in Haskell
14:43:28 <photex_> I've used OpenGL from C/C++ and Python for a while
14:43:47 <kmc> which is an important skill, but not where you want to start learning the language
14:43:48 <Megaladapis> hii
14:44:12 <photex_> The plan was to quickly bang out the view of some data
14:44:18 <Megaladapis> que pasa
14:44:23 <photex_> then explore haskell
14:44:28 <photex_> for processing that data
14:44:45 <kmc> you're not going to "quickly bang out" anything if you are just starting to learn
14:44:58 <photex_> haha
14:45:02 <danm_> that's not what she said..
14:45:03 <kmc> why not write the visualization in Python, and process data in Haskell
14:45:24 <photex_> I could
14:45:29 <photex_> but I'm stubborn
14:45:31 <photex_> and slow
14:45:56 <photex_> this is just for fun etx
14:45:57 <photex_> etc
14:46:54 <photex_> in any case, getting the app skeleton up and running, including incorrect arcball and route drawing
14:47:05 <photex_> took about two days instead of an afternoon
14:47:16 <photex_> not bad, plus I got a great feel for the cabal workflow
14:47:25 <photex_> and the Emacs haskell universe
14:47:35 <photex_> so it's not like I'm not learning *anything*
14:47:36 <photex_> :)
14:47:58 <photex_> my problem is understanding the breadcrumbs when I get stuck
14:48:19 <photex_> I haven't found a single example of typical mouse interaction in haskell
14:49:15 <acowley> I don't think there is a "typical mouse interaction in haskell"
14:49:45 <acowley> You're kind of starting out in one of the weaker areas of the ecosystem.
14:50:30 <kmc> neither Haskell nor OpenGL specifies a way to do mouse interaction
14:50:37 <acowley> For GLUT or GLFW-b, stashing mouse coordinates in a TVar or IORef is a reasonable first whack.
14:50:46 <acowley> In fact, that's what I usually do.
14:52:01 <photex_> well, in general there isn't a lot of really current examples about mouse interaction in OpenGL
14:52:05 <photex_> for any language
14:52:23 <photex_> it's like this slowly accumulated body of hacks that you have in your head
14:53:36 <dmwit> mice are for wimps, make 'em learn an interface that uses only the F1-F12 keys
14:53:48 <kmc> get a spaceball
14:54:25 <dmwit> F1-F6 for motion, F7-F12 for rotation
14:55:02 <ddarius> 12 keys!  Such luxury!
14:55:42 <benmachine> you only need [],.-+<> right
14:56:00 <dmwit> Hell, you only need ()X
14:56:29 <dmwit> Only X if you've got a way to input trees instead of strings. ;-)
14:58:35 <byorgey> sure you do, encode the tree structure in the timing of your X presses
14:59:25 <acowley> morse code UI?
14:59:57 <dmwit> It doesn't get much more intuitive than that.
15:00:47 <byorgey> morse code is for wimps.  I assumed dmwit was referring to the X combinator.
15:01:25 <ddarius> But which X combinator?
15:01:42 <byorgey> pick your favorite one-combinator basis.
15:02:01 <byorgey> the one I know is X = \x. (x S) K
15:02:48 <hpc> @pl \x -> (x ap) const
15:02:48 <lambdabot> flip ($ ap) const
15:03:23 <hpc> :t \x -> (x ap) const
15:03:24 <lambdabot> forall (m :: * -> *) a b t a1 b1. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
15:03:33 <hpc> eeeew
15:04:37 <Nisstyre> is there a more generic version of unfoldr?
15:04:42 <Nisstyre> like fmap
15:04:56 <Nisstyre> or do I have to create it?
15:05:00 <byorgey> :t \x -> (x (\f g x -> f x (g x))) const
15:05:00 <lambdabot> forall t t1 t2 t3 a b. (((t -> t1 -> t2) -> (t -> t1) -> t -> t2) -> (a -> b -> a) -> t3) -> t3
15:05:06 <acowley> I'll send an ...---... to my Haskell app. I hope that someone gets my value in an IORef.
15:06:34 <byorgey> Nisstyre: http://hackage.haskell.org/packages/archive/recursion-schemes/2.0/doc/html/Data-Functor-Foldable.html#g:6
15:07:03 <byorgey> Nisstyre: the 'ana' method there may be what you're looking for
15:07:07 <dmwit> ?djinn (((a -> b -> c) -> (a -> b) -> (a -> c)) -> (d -> e -> d) -> c) -> c
15:07:07 <byorgey> but it may also be overkill
15:07:07 <lambdabot> f a = a (\ b c d -> b d (c d)) (\ e _ -> e)
15:07:11 <ddarius> :t let unfold = In . fmap (unfold f) . f in unfold
15:07:12 <lambdabot>     Couldn't match expected type `a -> Mu f'
15:07:12 <lambdabot>            against inferred type `Mu f'
15:07:12 <lambdabot>     Probable cause: `.' is applied to too many arguments
15:07:23 <ddarius> :t let unfold f = In . fmap (unfold f) . f in unfold
15:07:24 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
15:07:27 <byorgey> dmwit: nice
15:08:25 <dmwit> The disconnect between the (d -> e -> d) argument and the (as, bs, and cs) argument is a bit mysterious.
15:11:27 <ddarius> :t let fold f = f . fmap (fold f) . out
15:11:27 <lambdabot> <no location info>:
15:11:27 <lambdabot>     not an expression: `let fold f = f . fmap (fold f) . out'
15:11:29 <ddarius> :t let fold f = f . fmap (fold f) . out in fold
15:11:30 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
15:13:49 <Nisstyre> byorgey: thanks
15:26:51 <Cathy> Hey guys
15:27:00 <Axman6> 'lo
15:27:18 <Cathy> I'm new to haskell, hoping someone can help me out!
15:27:29 <Axman6> ask away
15:28:23 <Cathy> So basically. I'm trying to implement a breadth first search from one point to another on a grid.
15:28:31 <Cathy> Each point is a tuple
15:28:40 <Cathy> representing the row & column of the point
15:28:49 <Cathy> how would i do this efficiently?
15:29:58 <hpc> do you want to find shortest path, or just the existence of one?
15:30:31 <hpc> if just the existence of one, you could take advantage of laziness, i think
15:30:37 <hpc> and do something like
15:30:40 <Cathy> Just any path - does not have to be the shortest
15:30:44 <hpc> ah, groovy
15:30:52 <hpc> so something like... ima just pastebin it
15:31:02 <Axman6> what sort of grid are you talking about?
15:31:58 <Cathy> just like a list of points for example: (0,1) (0,2) ....etc
15:32:21 <Cathy> and i'm looking for a path from (X1, Y1) to (X2, Y2) using BFS
15:33:29 <hpc> Cathy: http://hpaste.org/54624
15:33:51 <hpc> Cathy: that's some very rough, probably-wrong pseudocode that i think will do the trick
15:33:52 <Axman6> BFS will find you the shortest path right?
15:34:07 <hpc> Axman6: it will find you a shortest path assuming an unweighted graph, yeah
15:34:30 <Axman6> yeah
15:34:31 <hpc> because it's a degenerate case of dijstras
15:35:08 <Axman6> can anyone do something about znutar and a11235? :(
15:35:34 <benmachine> Cathy: I'd think recursively; suppose I know the solution for every square except the current one, how would I extend it to one which works at the current one?
15:36:34 <Axman6> @where ops
15:36:34 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:36:36 --- mode: ChanServ set +o Axman6
15:36:43 <Axman6> :o
15:36:44 <hpc> lol
15:36:54 <benmachine> hah
15:37:02 --- mode: ChanServ set +o monochrom
15:37:03 <Axman6> bah
15:37:10 <statusfailed> haha
15:37:13 --- mode: monochrom set +b *!*@unaffiliated/a11235
15:37:21 --- mode: ChanServ set +o mauke
15:37:21 --- mode: mauke set +b znutar!*@*
15:37:29 --- mode: monochrom set +b *!*@ip35.69-162-158.static.steadfast.net
15:37:38 <Cathy> thanks hpc , I still don't know how to begin in haskell, though
15:37:50 <Axman6> hmm, i wonder why my bans weren't going through
15:38:11 --- mode: mauke set -o mauke
15:38:19 <hpc> Cathy: i probably won't be able to help with that; too tired tonight and i don't know graph algorithms well enough to give a lucid explanation
15:38:19 <monochrom> because it was a fake "ChanServ gives channel operator status to Axman6", i.e., a /me not a /mode
15:38:29 <hpc> *explanation of how to get started
15:38:38 <mauke> monochrom: -!- .mode ChanServ #haskell [+o Axman6]
15:38:51 <mauke> not a /me
15:38:56 <monochrom> hrm
15:39:07 <Axman6> yeah, i have ops, my client says so
15:39:17 <hpc> i see you have ops
15:39:29 <Phyx-> I can confirm he has ops
15:39:36 <monochrom> my bad
15:39:40 <shapr> I can confirm that I gave him ops :-P
15:39:46 <Axman6> heh
15:40:52 <benmachine> it's not like ChanServ can even do /me >_>
15:41:20 <benmachine> Cathy: did my comment get lost amongst the quit flood
15:41:41 <hpc> 18:55 < benmachine> Cathy: I'd think recursively; suppose I know the solution for every square except the current one, how would I extend it to one which works at the current one?
15:42:22 <Cathy> @ben: yeah I want to do it recursively though I'm just a beginner in haskell so i dont really know where to start
15:42:22 <lambdabot> Unknown command, try @list
15:43:58 <Axman6> Cathy: i'd start by putting all the points you know about in a Set. then you can easily check for membership for any point (this is simple enough, inport Data.Set, and use fromList <points as a list>
15:44:16 <benmachine> Cathy: well, first of all, come up with the type for your function, if you haven't already
15:44:57 <benmachine> Cathy: think about how you will represent your paths, and your grid
15:45:33 <Axman6> then, it would likely be useful to write a function that finds all the possible adjacent points for a given point (so adjcents (x,y) = [(x-1,y-1),(x-1,y),(x-1,y+1)...)
15:46:17 <bytter> does anyonw know how to fix the haskell-platform for Lion?
15:46:35 <Axman6> then you just a need a function that takes a list of current points you're interested (this will initially be just a list with a single point, your start point)
15:46:41 <Axman6> bytter: see the topic
15:47:23 <bytter> Axman6: *facepalm*
15:48:07 <Axman6> and in each recursive call, you just need to pass in the list of points you're interested in, the  set of possible points, and possibly the set of points you've visited so far (you use this to make sure that you're not going in circles)
15:48:11 <benmachine> .t
15:48:22 * benmachine didn't say that
15:48:49 <benmachine> Axman6: I think making sure you're not going in circles is an optimisation
15:49:01 <benmachine> assuming there /is/ a solution
15:49:38 <Axman6> well, i think my way will tell you if there is a solutaion or not
15:49:43 <Axman6> solution*
15:49:58 <Jafet> Yeah, it optimizes your algorithm to run in finite time
15:50:02 <benmachine> :P
15:50:07 <Axman6> ha
15:50:09 * Axman6 wins
15:50:56 <Axman6> this is fairly close to an assignment i had last year, but it was finding graph widths using supercomputers (width isn't the right word, can't remember what it is now...)
15:51:31 <dmwit> diameter, probably
15:51:34 <Axman6> though, this only needs to find aone path, for that assignment I had to find the all pairs shortest paths, and find the maximum
15:51:38 <Axman6> yeah, diameter
15:51:51 <Cathy> would i be able to use some kind of queue to help me implement this?
15:52:42 <Axman6> Cathy: i'm not sure that's the best way to do it in haskell. it's possible, but other solutions are more natural
15:52:45 <benmachine> Cathy: I don't think you'll *need* anything other than ordinary lists
15:52:55 <benmachine> stick to simple and then worry about other ways of doing it later :)
15:53:23 <benmachine> it's a good idea to write an "obviously correct" algorithm in the simplest way possible before doing anything more exotic
15:53:29 <Jafet> Tie the right knot, then use a list as a queue
15:54:08 * Axman6 doesn't want to think about how to tie that knot
15:54:31 <Cathy> thanks benmachine & Axman6! im going to try it out now...
15:54:45 <Cathy> hopefully it works out
15:55:50 <Axman6> Cathy: feel free to ask more questions. it's one of those things that's pretty easy to trip yourself up on if you don't have a clear idea before you start
15:56:11 <benmachine> yeah I still think you should work out all the types first and then talk to us about them before you do the implementation
15:56:26 <benmachine> and by us I mean Axman6 because it's like twenty past midnight and I have lectures tomorrow
15:56:36 <Axman6> heh, i'm at work!
15:56:48 <benmachine> fiiine :P
15:57:06 <Jacco> ehm, I've got a beginners question about point free style
15:57:13 <mike-burns> Ask it!
15:57:16 <Axman6> benmachine: so, that means no sleep for you!
15:57:18 <keep_learning> Cathy, you can also use Data.Seq as queue.
15:57:48 <benmachine> :(
15:58:05 <benmachine> hey, I never installed GHC 7.2.2
15:58:08 <shachaf> Jacco: What you should do is first ask whether you can ask about asking the question. If someone says you're allowed to, *then* you should ask whether to ask it.
15:58:14 <shachaf> Or you could just ask. :-)
15:58:34 <benmachine> shachaf: in fairness he didn't ask whether he could ask the question or not
15:58:37 <benmachine> he just said he had one
15:58:47 <mike-burns> He was giving some context, I assume.
15:58:47 <Axman6> Jacco: what shachaf means is: first rule of IRC: don't ask to ask, just ask :)
15:58:48 <shachaf> benmachine: It's true. Maybe the goal was just to inform us of the existence of the question.
15:58:53 <mike-burns> Or maybe just announcing.
15:58:55 <shachaf> Maybe to make us envious.
15:58:59 <Jacco> hehe ok
15:59:02 <Jacco> I'm defining an smaller than operator for lists (just as an exercise), (<<<) :: Ord a => [a] -> [a] -> Bool
15:59:04 <Cathy> Ok I might try using Data.Seq after I attempt the list-based implementation first , but thanks!
15:59:14 <Axman6> i wish i had a beginners haskell question :(
15:59:16 * Axman6 jealous
15:59:17 <Jacco> this is my idea right now, xs <<< ys = and $ zipWith (<=) xs ys
15:59:22 <Jacco> works fine
15:59:30 <shachaf> @pl xs <<< ys = and $ zipWith (<=) xs ys
15:59:31 <lambdabot> (line 1, column 11):
15:59:31 <lambdabot> unexpected "="
15:59:31 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:59:38 <shachaf> @pl foo xs ys = and $ zipWith (<=) xs ys
15:59:38 <lambdabot> foo = (and .) . zipWith (<=)
15:59:45 <mike-burns> Oh man, that is a poorly-named function for so many obscure, esoteric reasons.
15:59:54 * hackagebot iteratee 0.8.7.4 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.7.4 (JohnLato)
15:59:55 <shachaf> mike-burns is correct.
15:59:56 <Jafet> :t (<<<)
15:59:57 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
16:00:05 <Jacco> :o
16:00:07 <mike-burns> Heh, see?
16:00:17 <benmachine> Jacco: I'd be careful about what happens when the lists aren't the same length, but okay
16:00:24 <Axman6> Jacco: use that name anyway, you're not likely to run into Control.Category any time soon
16:00:29 <mike-burns> Right.
16:00:31 <keep_learning> Cathy, see if this helps https://github.com/bjin/fancy-walks/blob/master/snippets/BFS.hs
16:00:35 <shachaf> Axman6: Because of people like you!
16:00:40 <Jacco> ok
16:00:42 <shachaf> Control.Category is perfectly natural.
16:00:44 <Jacco> so, (<<<) xs = and . zipWith (<=) xs is better
16:00:51 <Axman6> yeah man, down with categories
16:00:56 <shachaf> Jacco: Is it?
16:00:58 <Axman6> what have they ever done for us?
16:01:01 <shachaf> Jacco: I think the two-arguemnt version is fine.
16:01:02 <benmachine> Jacco: well, it's more pointfree, that's not necessarily better :)
16:01:05 <Axman6> If maths ain't broke, don't fix it!
16:01:16 <Jacco> ok, correction, it looks better
16:01:18 <shachaf> xs <<< ys = and (zipWith (<=) xs ys) -- Looks fine to me.
16:01:26 <Axman6> Jacco: i disagree
16:01:29 <benmachine> Jacco: okay, so it looks better to you
16:01:34 <benmachine> Jacco: what was your question? :P
16:01:46 <Jacco> almost :P
16:01:48 <Axman6> pointfree style makes your code lose a lot of useful information, for others that have you maintain it, and future you
16:02:06 <benmachine> Axman6: it doesn't /always/
16:02:07 <Axman6> s/you/to
16:02:12 <Jacco> I've seen lambda bot breaking it down, but basicly, what I thought it could be was
16:02:13 <Jacco> (<<<) = and . zipWith (<=)
16:02:18 <Axman6> no, not always, but a lot of the time
16:02:18 <Jacco> which is wrong
16:02:31 <benmachine> Jacco: aha. the key is the use of the infix operator .
16:02:31 <Saizan> or just reduces noise so that you no longer have to maintain it
16:02:33 <mike-burns> I bet that one needs parens.
16:02:40 <Axman6> :t (and .) . zipWith (<=)
16:02:41 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
16:03:11 <benmachine> Jacco: the problem is that 'and . zipWith (<=) xs' can be also written '(.) and (zipWith (<=) xs)' – agreed?
16:03:12 <mike-burns> If the only thing I need to do to write code I never have to maintain is point-free style then I'm sold!
16:03:38 <Jacco> yes, benmachine, agreed
16:03:39 <hpaste> “/dev/humanconTROLLER” pasted “COOKIE BOUNTY” at http://hpaste.org/54625
16:03:43 <shachaf> Jacco: It can't be that, but you can use the two-argument composition operator.
16:03:50 <shachaf> @ty and .: zipWith (<=)
16:03:51 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
16:03:56 <shachaf> However, that one isn't in the standard library.
16:03:58 <mike-burns> :t (.:)
16:03:59 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:04:07 <dmwit> \xs -> and . zipWith (<=) xs = \xs -> (.) and (zipWith (<=) xs) = \xs -> (.) and . zipWith (<=) $ xs = (.) and . zipWith (<=) = (and .) . zipWith (<=)
16:04:08 <mike-burns> @hoogle (.:)
16:04:08 <lambdabot> No results found
16:04:10 <benmachine> Jacco: okay, now we can get rid of the xs
16:04:19 <Axman6> :t and .: zipWith (<=)
16:04:19 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
16:04:23 <benmachine> Jacco: but only by doing '(.) and . zipWith (<=)'
16:04:29 <DevHC^> i hand out a cookie to the first one to get http://hpaste.org/54625 compiled (without taking out the needed parts)
16:04:32 <benmachine> Jacco: now we can't easily put the (.) back in the middle
16:05:12 <Saizan> mike-burns: the last it referred to noise :P
16:05:14 <Jafet> DevHC: it's not valid haskell
16:05:15 <dmwit> DevHC^: Have you looked up "hs-boot" on Google?
16:05:39 <benmachine> Jacco: basically, using infix operators screws up your intuition about how to pointfree code
16:05:50 <DevHC^> dmwit: i'm handing out a cookie to the one who gets hs-boot working, which i suspect is impossible with GHC
16:05:51 <benmachine> Jacco: write stuff in prefix form first
16:05:55 <Jafet> You'll probably be told something along the lines of T is not a type
16:06:00 <Axman6> module M doesn't implement T... so how can it export it?
16:06:03 <DevHC^> btw only a GHC solution is acceptable
16:06:09 <Jacco> ok, thanks, I will try that first then
16:06:24 <DevHC^> oops
16:06:30 <dmwit> Only GHC implements hs-boot files. Why would you expect it to be impossible?
16:06:49 <hpaste> “/dev/humanconTROLLER” annotated “COOKIE BOUNTY” with “COOKIE BOUNTY (annotation)” at http://hpaste.org/54625#a54626
16:06:53 <DevHC^> fixed
16:07:08 <DevHC^> dmwit: because i've tried miserably for hours
16:07:26 <DevHC^> i've even tried cross-linking bogus modules
16:07:29 <benmachine> Jacco: the rule you're trying to apply is turning 'f x = g x' into 'f = g', but you've got something like 'f x = g . h x', and the functino being applied isn't g or g . h, it's actually (.)
16:07:41 <DevHC^> but u'd probably have to try to see what GHC fails at...
16:08:22 <russellw> Is 'let' in Haskell considered to be syntax sugar for lambda application the way it is in Lisp?
16:08:44 <benmachine> russellw: I don't know lisp, but let is not quite the same as lambda
16:09:00 <benmachine> russellw: let bindings can be polymorphic, I believe
16:09:44 <mike-burns> Oh, russellw might be right.
16:09:44 <russellw> hmm. Would that not also be true if you rewrote the let binding into a lambda application?
16:09:48 <mike-burns> Though I don't remember this now.
16:09:55 <benmachine> > let x = 0 in x + floor x
16:09:56 <lambdabot>   0
16:10:05 <benmachine> > (\x -> x + floor x) 0
16:10:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:10:05 <lambdabot>    `GHC.Real.Integral a'
16:10:05 <lambdabot>   ...
16:10:13 <mike-burns> Ah, OK.
16:10:23 <benmachine> russellw: try to give a type to that lambda term, it doesn't work
16:10:23 <russellw> oh
16:10:32 <russellw> Interesting!
16:10:36 <mike-burns> :t (\x -> x + floor x)
16:10:37 <lambdabot> forall a. (RealFrac a, Integral a) => a -> a
16:10:44 <Jafet> russellw: usually, we consider lambda application to be syntactic sugar for let-binding. By we I mean GHC.
16:10:52 <benmachine> mike-burns: okay fine, but those constraints aren't simultaneously satisfiable :P
16:11:04 <DevHC^> is anyone trying?
16:11:16 <Saizan> Jafet: that's not quite accurate either
16:11:28 <bytter> can cabal install lambdabot with GHC 7.2?
16:11:31 <Jafet> Yes, it isn't
16:11:54 <russellw> Jafet, how does that work? I mean, I can see how it works in the case where you apply a lambda immediately, but what about the more common case where it's passed as a parameter or something before being applied?
16:11:58 <dmwit> DevHC^: Okay, I have got it compiled. I will make a paste.
16:12:29 <Jafet> (\x -> y) is (let f :: monomorphic type; f x = y in f)
16:12:33 <DevHC^> WAT
16:12:53 <hpaste> dmwit pasted “recursive imports” at http://hpaste.org/54627
16:12:54 <benmachine> DevHC^: man, you know international shipping on cookies is kinda pricy, right?
16:12:58 <ehuber> hey, so I was reading about WAI last night, and I saw a bunch of web frameworks (yesod, happs, hyena, ..). However, I was wondering if there is a mod_wai or something of that nature, so that I can use Apache as my backend, then do whatever I want with the Env object in haskell (in the way that mod_wsgi serves for modern python webapps). is there something like mod_wai in the works?
16:13:04 <Jafet> let is a lot more general than lambda-expressions
16:13:08 <dmwit> DevHC^: cookie please
16:13:08 <DevHC^> benmachine: not really
16:13:28 <russellw> Jafet, ah, curiouser and curiouser :) thanks!
16:13:28 <Jafet> benmachine: google gives me one every day!
16:13:34 <benmachine> Jafet: >_>
16:13:39 <dmwit> DevHC^: compile with "ghc --make Main"
16:13:56 <benmachine> russellw: a slightly better example than my previous, let x = [] in ('a' : x, () : x)
16:13:58 <Jafet> benmachine: well, it's cheaper because they have a huge CDN (cookie delivery network)
16:14:11 <benmachine> :t (\x -> ('a' : x, () : x) [])
16:14:12 <lambdabot>     Couldn't match expected type `()' against inferred type `Char'
16:14:12 <lambdabot>       Expected type: [()]
16:14:12 <lambdabot>       Inferred type: [Char]
16:14:39 <benmachine> ooh, even better
16:14:42 <benmachine> > let x = [] in x : x
16:14:43 <lambdabot>   [[]]
16:15:18 <Jafet> > 0 0 (0 0 0) (0 0) 0
16:15:18 <lambdabot>   0
16:15:26 <russellw> Is there a reason why typing of lambda is less liberal than typing of let?
16:15:30 <benmachine> Jafet: troublemaker :P
16:15:44 <benmachine> russellw: well, what type would you give the expression (\x -> x : x)?
16:15:56 <Axman6> > (cos ^2) 0
16:15:57 <lambdabot>   1.0
16:16:00 <benmachine> russellw: that sort of question doesn't even arise with let, so it's allowed to be more liberal
16:16:07 <dmwit> russellw: Yes, inference is harder if you allow the more liberal rule.
16:16:10 <Axman6> > (cos^2 + sin^2) x
16:16:11 <lambdabot>   cos x * cos x + sin x * sin x
16:16:12 <dmwit> (for lambda)
16:16:24 <DevHC^> dmwit: ok, seems like i narrowed down the case too much without testing; stay tuned for a more difficult task :P
16:16:53 <benmachine> I seem to have six versions of GHC installed
16:16:58 <russellw> Okay fair enough
16:17:00 <benmachine> maybe it's about time I made that seven
16:17:56 <Jafet> Seven HEADs
16:17:56 <DevHC^> benmachine: GHC v1.0, GHC v2.0, etc.? :P
16:18:19 <benmachine> DevHC^: unfortunately not; 6.12.3; 7.0.x for x = [1 .. 4], and 7.2.1
16:18:28 <benmachine> evidently I <3 point releases
16:19:03 <Saizan> you could not have let's and look for places where lambdas are applied directly to some expression, but that'd be just ugly
16:19:20 <russellw>  that's true, it would
16:19:34 <benmachine> you *could* have monomorphic lets
16:19:42 <benmachine> but I think that would be irritating
16:19:44 <Jafet> We *will* have monomorphic lets!
16:19:54 <benmachine> Jafet: pfft. I don't think it ever caught on
16:20:07 <benmachine> although I may be making this up
16:20:47 <Jafet> In 7.4, I think
16:20:50 <dmwit> I thought future GHC's were doing monomorphic lets to make GADT type inference better.
16:20:59 <benmachine> there's MonoLocalBinds
16:21:42 <benmachine> supported since at least 6.12.3
16:22:00 <Jafet> It's going to become the default
16:22:14 <benmachine> I think it already did? but I just turned it off again >_>
16:22:22 * benmachine forgets the details
16:23:05 <Jafet> If it's already been on, I haven't noticed
16:23:30 * Jafet bows in shame for lack of polymorphism
16:24:23 <Saizan> it's implied by GADTs
16:24:24 <ddarius> I believe the case is that if you use GADTs or some other extensions, MonoLocalBinds will be on as well.
16:25:13 <ddarius> It's unlikely that it will be on by default as long as Haskell 2010 is the current standard.
16:25:37 <benmachine> oh right
16:25:39 <benmachine> that makes sense
16:33:26 <xil> hi. I need a bit of help with time in Haskell. I have an event loop and every cycle of the loop I need to check how long it's been since I've called a specific function. I saw UTCTime which looks like it might be reasonable, but the only way to compare two UTCTimes returns a NominalDiffTime, and it doesn't look like you can do anything with that, so how do I know if the difference is what I'm looking for?
16:35:41 <periodic> I have previously done calculations with getCPUTime
16:35:44 <Axman6> I think you can use fromRational or something to turn it into a Double representing the number of seconds (and fractions of a second)
16:35:55 <periodic> from System.CPUTime
16:36:03 <Axman6> @hoogle NominalDiffTime
16:36:04 <lambdabot> Data.Time.Clock data NominalDiffTime
16:36:11 <periodic> I believe it works with just plain doubles.
16:36:39 <periodic> but there's scaling factor, and I don't remember how to find it properly
16:37:03 <dmwit> xil: As with the other types in the time library, all the magic happens in the instances.
16:37:15 <c_wraith> NominalDIffTime is an instance of Num, with all that entails.
16:37:19 --- mode: ChanServ set +o mauke
16:37:20 --- mode: mauke set -b znutar!*@*
16:38:04 <c_wraith> I'm not sure what else you need, actually.
16:38:10 --- mode: mauke set -o mauke
16:38:20 <dmwit> Depends what he wants to do with it, I suppose.
16:38:55 <xil> ah okay, I didn't really look at the instances. So how would I use those facts to figure out if a NominalDiffTime is greater than 1 minute?
16:39:06 <xil> just myndt > 60?
16:39:09 <c_wraith> yeah
16:39:28 <dmwit> probably 60e12 or something like that
16:39:38 <c_wraith> no, NominalDiffTime is in seconds
16:39:49 <dmwit> Oh. What's the one that's in picoseconds?
16:39:58 <xil> it has a precision of picoseconds
16:40:21 <xil> I didn't realize the instances had that kind of power. That is pretty awesome, thank you =]
16:40:33 <xil> seems obvious now that you've said it though, haha
16:40:42 <c_wraith> it's so simple, it's easy to miss :)
16:42:54 <xil> what confused me is that it doesn't say what NominalDiffTime is. The declaration in the docs is just "data NominalDiffTime". So I didn't realize I could just use numbers with it because it could have some important constructors or something. Looking at the source didn't clear it up at all
16:44:41 <acowley> The docs say "Conversion functions will treat it as seconds." which holds the key, though I tripped on this back in the day, too.
16:45:35 <xil> yeah when I read that I thought "conversion functions" meant the ones for working with it, not the general ones like toRational, etc.
16:45:58 <acowley> I agree it's too vague
16:46:19 <xil> but understandable =]. I appreciate the help. This channel is awesome
16:46:54 <DevHC^> dmwit: ah i see. u must put {-# SOURCE #-} in Main.hs, and create a hs-boot file for the other source file. try that !
16:48:00 <DevHC^> (or i can define another pair of a-data-type-and-a-value and have their positions switched compared to the current layout)
16:54:40 --- mode: monochrom set -b *!*@ip35.69-162-158.static.steadfast.net
16:54:54 --- mode: monochrom set -b *!*@unaffiliated/a11235
16:55:03 <dmwit> DevHC^: Tricky, but I still compiled it.
16:55:05 --- mode: monochrom set -o monochrom
16:55:06 <dmwit> will paste
16:58:47 <DevHC^> H$X
17:00:08 <dmwit> sorry, my connection dropped for a few minutes there
17:01:27 <hpaste> dmwit pasted “needs more hs-boot” at http://hpaste.org/54628
17:01:51 <dmwit> DevHC^: ^_^
17:05:07 <DevHC^> WAT
17:05:08 <DevHC^> Plug.hs-boot:2:23: Can't find ./Main.hs-boot
17:05:28 <DevHC^> w8 lemme make 100% sure
17:18:33 <dmwit> Could somebody who has a ghc-7.0 installation lying around tell me what version of base they have?
17:19:10 <sipa> Glasgow Haskell Compiler, Version 7.0.3, for Haskell 98, stage 2 booted by GHC version 7.0.3
17:19:20 <sipa> Uwired-in package base mapped to base-4.3.1.0-91c3839608ff4d3ec95f734c5ae4f31c
17:19:42 <dmwit> thanks
17:26:57 <DevHC^> dmwit: ah ok, looks good. i see where i was failing: i was importing data T from another module, and had a "data T" line in Main.hs-boot instead of importing T
17:27:10 * DevHC^ hands dmwit a cookie
17:27:20 <DevHC^> benmachine: too easy.  :trollface:
17:29:57 * dmwit noms
17:38:17 <Luke> what IDE do you guys use?
17:40:18 <c_wraith> IDE?
17:40:25 <companion_cube> many people here just use an editor
17:40:27 <c_wraith> I just program, man.
17:40:46 <c_wraith> fancy do-everything "environments" usually get in the way
17:40:52 <Saizan> butterflies!
17:41:07 <mike-burns> I use the gvim IDE.
17:41:17 <c_wraith> I assure you, M-x butterflies gets in the way.
17:42:07 <Saizan> well, some support for interactive programming like you have in proof assistants would be nice
17:42:23 <mike-burns> Hold on Saizan , we're still making fun of IDEs.
17:42:47 <Axman6> Luke: My optinion is that Haskell has such a high signal to noise ratio that an IDE isn't that necessary. the only thing you might want is name completion and package completion. as long as your editor can do decent indentation, you'll be fine
17:42:55 <hpc> an interactive programming tool /= an IDE, imo
17:42:56 <kmc> i just program, fancy types get in the way
17:43:20 <kmc> don't agree about signal-to-noise ration
17:43:25 <kmc> Haskell can have a lot of boilerplate
17:43:29 <mike-burns> Is an interactive programming tool different from ghci?
17:43:40 <Saizan> yep
17:43:43 <mike-burns> Haskell has the most boilerplate of any language I use, indeed.
17:43:52 <Axman6> kmc: mentally, i was comparing it to java
17:44:15 <Luke> I'm using emacs and it's just crap for basic stuff like quickly loading the current file in the interpreter etc
17:44:34 <kmc> if you think an IDE for Haskell would be useless, then you probably have not used agda-mode
17:44:54 <mike-burns> I haven't, so can you tell me about it?
17:45:02 <kmc> you can put ? anywhere in your code
17:45:06 <kmc> and it will tell you the type of what should go there
17:45:10 <kmc> as well as the types of all the things in scope
17:45:16 <mendez> emacs confuses the vimmmer
17:45:29 <mike-burns> Doesn't haskell.vim do something like that?
17:45:29 <companion_cube> type inference in the editor would be great, indeed
17:46:00 <kmc> if you're viewing Agda as a proof assistant, then this tells you the proof goal and the current assumptions
17:46:01 <mendez> mike-burns: it's indentation is pretty awful
17:46:07 <kmc> but it's just as useful in a programming context
17:46:36 <kmc> i know there are projects which do this for Haskell, or try to; i mean to refute Axman6's claim that "the only thing you might want is name completion and package completion"
17:46:47 <kmc> and yeah Haskell has less boilerplate than Java
17:46:53 <monochrom> I use emacs and sometimes eclipse
17:47:00 <kmc> and yeah programming in Haskell is more pleasant than stabbing yourself in the groin with scissors
17:47:04 <kmc> should we be proud of this fact?
17:47:11 <mike-burns> Yeah we can stop now.
17:47:16 <mike-burns> No more advancements.
17:47:21 <mike-burns> Better than Java: check.
17:47:45 <Luke> I just want emacs haskell-mode to work better I suppose
17:48:03 <Luke> C-l doesn't ever seem to do what I want
17:48:06 <Luke> (work)
17:48:13 <monochrom> emacs haskell-mode worksforme
17:48:19 <Luke> C-c C-l that is
17:48:38 <Luke> monochrom: do you put your src in a src folder?
17:48:50 <Saizan> :cd src
17:48:50 <monochrom> ah it defaults to hugs. I had to add something to .emacs to force ghci
17:49:02 <monochrom> (setq haskell-program-name "ghci")
17:49:23 <Luke> nah that works
17:49:34 <Luke> ghci always complains it can't find my files
17:49:57 <Luke> it's not changing into the src dir
17:50:16 <monochrom> I put my *.hs files pretty much anywhere I like. no matter where I put my files, haskell-mode either tells ghci the absolute path or :cd correctly
17:50:50 <Luke> hmm - not sure what the problem is
17:50:56 <Luke> i'm just getting sick of litthe problems like this
17:51:08 <monochrom> yeah, worksforme, no problem here
17:51:28 <monochrom> and yeah, me too getting sick of all the little problems other people have but I can't reproduce
17:52:20 <kmc> Luke, to answer your question, I use vim and ghci in separate windows
17:52:34 <kmc> with syntax highlighting and indentation in vim, but nothing fancier than that
17:53:32 <kmc> i use this setup for basically all software development and i'm pretty happy with it
17:54:01 <kmc> but if the state of fancier haskell modes were better, i'd be happy to use one
17:54:14 <monochrom> I often load up ~/tmp/h.hs and C-c C-l. and then I load up ~/projects/monoload/drive.hs and C-c C-l. and switch back and forth. works.
17:54:57 * hackagebot wai-app-file-cgi 0.4.0 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.4.0 (KazuYamamoto)
17:55:46 <Saizan> monochrom: with drive.hs importing other modules within ~/projects/monoload/ ?
17:56:02 <monochrom> if I load up ~/projects/monoload/Whee/Internal.hs and its first line is "module Whee.Internal where", C-c C-l will :cd to ~/projects/monoload before loading, which is what ghci likes
17:56:20 <monochrom> yes, drive.hs imports stuff there
17:56:36 <Luke> I think the problem is it thinks src on the file hierarchy is a package
17:56:43 <Luke> instead of a top level folder
17:56:53 <Saizan> Luke: version of your haskell-mode?
17:57:18 <Luke> 2.7.0
17:57:24 <Luke> i tried the latest - same deal
17:57:41 <monochrom> 2.8.0 here
17:58:40 <Saizan> i guess you are either getting the module headers wrong or doing something funny with your source hierarchies
17:59:57 * hackagebot mighttpd2 2.4.0 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.4.0 (KazuYamamoto)
18:00:49 <Luke> just confirmed - same problem with 2.8.0
18:01:23 <monochrom> I just tried ~/tmp/noway/src/Whee/Internal.hs , still works, as in, :cd ~/tmp/noway/src which is still correct so far
18:04:06 <Luke> still no go. :cds into the wrong dir
18:04:52 <lambdanaut> What do you guys call your "random dohickey.hs" file. The one in the project that has random utility functions that don't quite fit in anywhere?
18:05:04 <mike-burns> Private.hs
18:05:16 <Jafet> Prelude.hs
18:05:21 <mike-burns> Hah!
18:05:24 <lambdanaut> lol
18:05:43 <lambdanaut> Why private.hs?
18:05:58 <mike-burns> It's functions that are private to my API but clearly useful.
18:06:16 <mike-burns> I don't consider a project 1.0 until the file is emptied into other projects on Hackage.
18:06:18 <lambdanaut> ooooo
18:06:30 <kmc> i usually have Types.hs and possibly Util.hs
18:06:36 <byorgey> heh, I was about to say something similar =)
18:06:37 <Cale> Prelude or Misc or Util are common
18:06:38 <kmc> but the former might be public
18:07:01 <Axman6> Yesod calls it Import.hs. it provides all the common imports and gives you as place to put random utility functions
18:07:09 <lambdanaut> Ok, I've always just gone with Util.hs. I guess it's common
18:07:22 <Cale> Control.Data.Miscellaneous.Utility
18:07:33 <Jafet> I've never actually seen Prelude.hs
18:07:33 <kmc> Data.Data.Data.Data.Data
18:08:09 <kmc> usually if i collect imports into a single top-level module, it'll be named after the library itself
18:08:17 <periodic> lambdabot: Internal.hs for a lot of internal stuff I dont' expose in the API.
18:08:24 <monochrom> http://www.vex.net/~trebla/tmp/haskell-emacs.png
18:09:06 <periodic> but if you're making them public...
18:12:46 <Luke> monochrom: I believe you yours works - i just want to know how to fix mine =D
18:18:40 <irene-knapp> see I strongly try to avoid a "Util" module
18:18:43 <irene-knapp> it's always ill-defined
18:18:54 <irene-knapp> it tends to contain, like, one function to change the cat litter and another to juice an orange
18:19:02 <ddarius> That's the point.
18:19:04 <mike-burns> Yeah! Put them in their place!
18:19:09 <irene-knapp> haha
18:19:10 <monochrom> where do you put them?
18:19:17 <mike-burns> Separate packages.
18:19:48 <Jafet> Util/SanitiseLitter.hs
18:19:49 <irene-knapp> well, if I have to, I make a package for kittymorphic refreshings and another for citrus compression
18:19:51 <monochrom> so, one package to change the cat litter and another package to juice an orange?
18:19:55 <byorgey> new package: hoange-juicer-0.1
18:20:07 <irene-knapp> ie. some ridiculously abstract package such that it's defined so broadly I can at least conceive of reusing it someday
18:20:18 <irene-knapp> but I'm talking about modules, not packages, haha
18:20:42 * ddarius asserts that all modules should have at most one declaration.
18:20:45 <irene-knapp> haha
18:21:08 <byorgey> kittehmorphisms iz fur foldin dateh typs
18:21:14 <mike-burns> Like, I made the timing-convenience package because I had these utility functions that I thought might be useful for others.
18:21:26 * irene-knapp nods
18:21:37 <irene-knapp> well, if it's not tied to your specific project, that of course is an option
18:23:49 <irene-knapp> wait I know!
18:24:06 <irene-knapp> when in doubt, group utility functions by the last phoneme of their name!
18:24:21 <irene-knapp> so kitty litter could get grouped with pinch hitter, right
18:24:29 <irene-knapp> and orange could get grouped with... oh wait :D
18:25:25 <byorgey> oarnge juicer could get grouped with transducer
18:25:32 <irene-knapp> haha okay then
18:25:52 <byorgey> gah, that's the second time I've misspelled 'orange' =P
18:25:58 <irene-knapp> yes, it is
18:26:15 <irene-knapp> your first one was so bizarre I actually looked it up in case it was a foreign spelling or a genus or something
18:26:21 <monochrom> hahahaha orange transducer
18:26:22 <byorgey> hehe
18:26:29 <irene-knapp> :D
18:29:16 <byorgey> irene-knapp: well, I was trying to write 'horange', poking fun at all the packages which prefix the letter 'h' to the name of whatever it is
18:29:58 <irene-knapp> ah, yes, haha
18:30:04 <irene-knapp> that would have been cute :D
18:31:03 <byorgey> sigh, too bad I screwed it up.  That will teach me to proofread!
18:31:39 <irene-knapp> haha
18:31:41 <irene-knapp> yepyep
18:36:33 <adi12> hi can someone help me with haddock? I try to generate a very simple documentation for a file just like the online documentation says and it fails on me :(
18:36:58 <mike-burns> What's the error?
18:37:02 <dmwit> adi12: Put some code on hpaste.org and show us the error.
18:40:00 <adi12> i have some simple functions with top level annotations (all have the type signature), i run "haddock -h -o doc app.hs" and it outputs "haddock coverage for app.hs:     1/2  50% Warning: Main: could not find link destinations for:  GHC.Types.IO
18:40:19 <adi12> i run ubuntu and have haskell-platform installed
18:40:51 <adi12> in the folder doc, there are html files generate but only the main function appears in module Main, the rest do not
18:42:10 <adi12> tried searching the net, but found nothing..
18:43:18 <Luke> http://hpaste.org/54631 I'm trying to make a test for my snap-hdbc code. can someone help me resolve this error?
18:47:36 <dmwit> Luke: Did you mean just getConnSrc = gets connSrc?
18:47:58 <monochrom> the warning is harmless
18:47:58 <dmwit> adi12: Do you have a type signature for all the functions you're documenting? Have you got the haddock-comment syntax correct?
18:48:18 <dmwit> adi12: It's really, really hard to guess what's wrong without seeing your source, so I again request that you put some code up on hpaste.org.
18:48:23 <monochrom> the warning is harmless. all it means is "no hyperlink to IO for you"
18:49:15 <dmwit> I see you do say you have type signatures. I'm a bad reader.
18:49:20 <adi12> I'll try to have a close look at the syntax, if not then I'll strip the unimportant potions and put some code
18:49:36 <monochrom> there is a flag to regain hyperlink to IO (and String, and Bool... generally things from other libs). but it's very complicated. cabal knows the right flag, though, so "cabal haddock" can do it.
18:50:05 <Luke> dmwit: http://hpaste.org/54631 check out the last annotation
18:51:10 <monochrom> also you have to list all modules you want haddock for. app.hs alone is not enough. app.hs alone means you want app.hs alone processed. no, no automatic importing.
18:51:51 <monochrom> that last part is pretty clear in the haddock manual
18:52:25 <monochrom> "cabal haddock" takes care of that part, too
18:53:00 <dmwit> Luke: Don't know much about the HasHdbc class (never used hdbc), but going by the type error alone I'd say the fix is to use gets (return . connSrc)
18:53:17 <_ralts> @pl \x y -> sqrt (x ^ 2 + y ^ 2)
18:53:17 <lambdabot> (sqrt .) . (. (^ 2)) . (+) . (^ 2)
18:54:00 <Luke> dmwit: good call - thanks
18:54:19 <Luke> that was it
18:54:24 <Luke> nicely done
18:55:05 <_ralts> @t (sqrt .) . ((+) <$> join (*) <*> join (*))
18:55:05 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:55:12 <_ralts> @type (sqrt .) . ((+) <$> join (*) <*> join (*))
18:55:13 <lambdabot> forall a (f :: * -> *). (Floating a, Functor f, Num (f a)) => f a -> f a
18:56:14 <dmwit> :t (+) <$> (^2) <*> (^2)
18:56:15 <lambdabot> forall a. (Num a) => a -> a
18:56:24 <dmwit> yeah
18:56:30 <dmwit> :t (+) `on` (^2)
18:56:31 <lambdabot> forall a. (Num a) => a -> a -> a
18:56:52 <dmwit> :t (sqrt .) . ((+) `on` (^2))
18:56:52 <lambdabot> forall a. (Floating a) => a -> a -> a
18:57:00 <monochrom>  :t ruby `on` rail :)
18:57:03 <dmwit> :t (sqrt .) . (+) `on` (^2) -- need parens?
18:57:04 <lambdabot> forall a. (Floating a) => a -> a -> a
18:57:12 <_ralts> Forgot about on :)
18:57:35 <monochrom> haskell `on` golfing :)
18:59:50 <adi12> I managed to figure out the problem with haddock.. It was my fault of course, I did not export some functions :)
19:06:09 <_ralts> Just wondering, if <*> is the S combinator and <$> is B, then what is =<<?
19:06:29 <dolio> =<< is flipped S.
19:06:40 <dolio> Or do I have that backwards?
19:06:46 <dolio> @type (=<<)
19:06:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:07:09 <dolio> @type (<*>)
19:07:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:07:30 <hpaste> Luke pasted “HDBC Snap” at http://hpaste.org/54635
19:08:06 <dolio> I guess it's flip composed with S.
19:08:13 <Luke> dmwit: how do I go from the Test monad to the HDBC monad?
19:08:22 <Luke> in that example
19:08:50 <parcs> :t [flip (=<<), (<*>)]
19:08:50 <lambdabot>     Occurs check: cannot construct the infinite type:
19:08:50 <lambdabot>       a = (a -> b1) -> b
19:08:50 <lambdabot>     Probable cause: `<*>' is applied to too many arguments
19:08:51 <dmwit> Read the documentation for Test, I guess?
19:08:52 <dmwit> I dunno.
19:09:08 <parcs> :t [flip . (=<<), (<*>)]
19:09:08 <lambdabot>     Occurs check: cannot construct the infinite type: a = a1 -> a
19:09:08 <lambdabot>     Probable cause: `<*>' is applied to too few arguments
19:09:09 <lambdabot>     In the expression: (<*>)
19:09:15 <parcs> =(
19:09:17 <dmwit> Is there a reason to believe you can go from Test to the HDBC monad?
19:09:42 <dolio> (=<<) f g x = f (g x) x
19:10:33 <parcs> :t [flip .: (=<<), (<*>)]
19:10:34 <lambdabot> forall b a. [(a -> a -> a -> b) -> (a -> a) -> a -> a -> b]
19:10:36 <parcs> yay
19:10:54 <dolio> That doesn't really look right.
19:11:05 <dolio> It's actually composed on the wrong side.
19:11:16 <dolio> :t [(=<<) . flip, (<*>)]
19:11:17 <lambdabot> forall a (m :: * -> *) b. (Monad m, Applicative m) => [m (a -> b) -> m a -> m b]
19:11:26 <dolio> :t flip
19:11:27 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
19:11:28 <dolio> Heh.
19:12:25 <parcs> no i think i'm right for once =P
19:13:12 <parcs> wait no i'm not
19:13:24 <byorgey> hahaha
19:13:25 <parcs> the function should have 2 arguments, not 2
19:13:56 <parcs> s/2$/3
19:15:51 <parcs> :t [flip .: (=<<) . flip, (<*>)]
19:15:52 <lambdabot> forall a b a1. [(a -> a1 -> a -> b) -> (a -> a1) -> a -> a -> b]
19:19:29 <Luke> dmwit: no - maybe I'm just not thinking about it correctly
19:20:15 <dolio> @type let s f g x = f x (g x) in s
19:20:15 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
19:22:22 <parcs> > map (($ 1) . ($ show) . ($ (,))) [(=<<) . flip, (<*>)]
19:22:24 <lambdabot>   [(1,"1"),(1,"1")]
19:25:24 <parcs> dolio: yeah, i follow now. thanks
19:28:38 <_ralts> I've got it now!
19:29:39 <_ralts> :t let compose' = (.) . (.) in compose' join fmap
19:29:40 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
19:31:33 <Axman6> :t (.) (.) (.)
19:31:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:31:37 <Axman6> :t (.) . (.)
19:31:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:31:59 <shachaf> _ralts: In lambdabot it's called (.:).
19:32:06 * shachaf is amused by how Axman6 is still an op.
19:33:00 <_ralts> shachaf: Thanks!
19:34:04 <Axman6> shachaf: i wonder if it'll stick :o
19:34:20 <Axman6> I have a feeling someone will unop me soon enough
19:36:22 <NemesisD> man i'm highly confused. trying to install a package which only needs base. cabal complains "ghc-7.0.3 requires containers == 0.4.1.0 however containers-0.4.1.0 was excluded because ghc-7.0.3 requires containers == 0.4.0.0"
19:36:25 <NemesisD> huh?
19:37:25 <monochrom> short answer: you have too many packages installed, they are in conflict. long answer: my http://www.vex.net/~trebla/haskell/sicp.xhtml
19:38:06 <NemesisD> i'm using cabal dev. is the solution to uninstall all the containers?
19:38:35 <monochrom> only uninstall user's containers. don't uninstall global's containers
19:38:47 <tgeeky> uninstall all the things
19:39:03 <NemesisD> i find myself having to commit cabal suicide far more than i'd like these days
19:39:20 <monochrom> or scratch everything in your cabal-dev sandbox and start your sandbox again
19:39:27 <tgeeky> if you're in that situation, at least beta test ghc-parmake
19:39:34 <dmwit> monochrom: bookmarked
19:39:35 <tgeeky> so you can be annoyed, in parallel
19:39:38 <parcs> NemesisD: first step is to install cabal-dev, second step is to delete ~/.ghc
19:39:50 <NemesisD> parcs: not sure if being facetious
19:39:56 <NemesisD> or if i spelled that correctly
19:40:27 <monochrom> well, see my url for what's inside ~/.ghc
19:41:45 <NemesisD> well i killed my local ~/.ghc arch directory
19:41:56 <dmwit> #pigeon is the relevant bit, I suppose
19:42:01 <parcs> NemesisD: installing cabal-dev also installs many libraries that may or may not conflict with cabal-dev sandboxes
19:42:56 <NemesisD> i don't know where this 0.4.0.0 nonsense is coming from or why ghc requires both
19:43:25 <NemesisD> the last thing i want to think about when developing is how to unfsck the package system and yet it always comes to that
19:43:27 <monochrom> 0.4.0.0 is not nonsense. it comes with ghc. 0.4.1.0 is the nonsense.
19:44:08 <monochrom> 0.4.0.0 comes with ghc 7.0.3. can't be nonsense.
19:44:09 <ddarius> Axman6: As long as you don't do anything wrong, no one is going to bother.
19:44:21 <amindfv> dmwit: that link is worth its weight in gold
19:44:21 <dmwit> NemesisD: monochrom's link has an absolutely crystal-clear explanation of that error message. You really should read it.
19:44:43 <dmwit> monochrom++ because I 100% agree with amindfv
19:44:56 <ddarius> How much does a link weigh?
19:45:40 <amindfv> ddarius: 1 Million USD / (price of gold by weight)
19:45:50 <amindfv> in this case
19:46:04 <NemesisD> that got me past it, now it complains that some package requires ghc -any and that there is no available version of ghc that satisifies -any
19:47:20 <parcs> what version of cabal-install are you using?
19:47:22 <monochrom> what do "ghc-pkg list -v" and "ghc -v" say? paste.
19:47:32 <NemesisD> 0.9
19:47:41 <NemesisD> that was for cabal-install
19:49:56 <hpaste> NemesisD pasted “ghc -v” at http://hpaste.org/54636
19:53:35 <monochrom> "ghc-7.0.3 (ghc-7.0.3-b42d175c6258f6ba16e77aedc3614947)" is right there. the problem is something else
19:54:35 <NemesisD> oh i should have done   that with cabal-dev ghc-pkg list -v shouldn't i
19:54:56 <NemesisD> since i'm getting the error when installin something with cabal-dev
19:54:57 <monochrom> I don't know. I don't know cabal-dev.
19:55:26 <monochrom> perhaps "cabal-dev ghc -v" too if that makes sense
19:55:38 <NemesisD> oh cool all the packages are broken
19:56:02 <NemesisD> it gives me a list of 2 dozen or so broken packages
19:56:04 <monochrom> you really should clear out at least something in your sandbox
19:56:11 <NemesisD> ill nuke it
19:56:18 <NemesisD> ii gotta run now anyways
19:56:26 <NemesisD> thanks for your help guys
20:00:26 <tgeeky> conal: are you here?
20:01:02 <tgeeky> oops, nevermind.
20:03:45 <_ralts> wow... S + K is Turing complete, right?
20:04:01 <_ralts> K is pure and S is <*>
20:04:06 <Axman6> yes
20:04:08 <monochrom> plus application
20:04:13 <_ralts> Pure and <*> form an applicative functor!
20:04:35 <_ralts> omigosh
20:04:59 <Porpado> why haskell
20:05:10 <Axman6> hmm, isn't K const?
20:05:15 <endojelly> Porpado, why ice cream
20:05:15 <monochrom> yes
20:05:18 <Axman6> Porpado: why C? why Java?
20:05:25 <monochrom> why answer
20:05:34 <monochrom> don't answer to answer. just don't answer.
20:08:31 <_ralts> Axman6: In the ((->) r) instance, pure = return = const
20:10:17 <Axman6> hmm, right
20:11:35 <_ralts> now I'm confused
20:11:42 <ddarius> _ralts: S and K are Turing complete if you don't have types.
20:12:30 <_ralts> What do you mean?
20:12:31 <Axman6> yeah, you can write things like the Y combinator using SK, but it won't typecheck in Haskell
20:13:07 <_ralts> Ah, I see
20:13:33 <Axman6> (well, you can translate the Y combinator to SK using simple rules, but I don't think it's "the Y combinator" if it's not the usual lambda calculus version)
20:14:06 <keep_learning> when we write something like " instance Fractional a => Num (D a)  where definition " , it means 'a' belongs to fractional typeclass and 'D a' belong to Num type class. Am i correct ?
20:14:33 <_ralts> Looks like it
20:14:41 <monochrom> not "and". "implies".
20:15:49 <_ralts> If "a" is a instance of Fractional, then "D a" is an instance of Num
20:16:10 <keep_learning> so can't we write something like " instance ( Fractional a , Num a ) => Num ( D a ) where ... " ?
20:16:18 <Axman6> yep
20:16:20 <monochrom> yes, can
20:16:20 <byorgey> Actually, it means something more like " 'D a' is an instance of Num, and a had better be an instance of Fractional OR ELSE"
20:16:28 <Axman6> though, i think Fractional impoies Num
20:16:44 <Axman6> implies*
20:16:48 <dmwit> byorgey++
20:16:56 <Axman6> @src Fractional
20:16:56 <lambdabot> class  (Num a) => Fractional a  where
20:16:57 <lambdabot>     (/)             :: a -> a -> a
20:16:57 <lambdabot>     recip           :: a -> a
20:16:57 <lambdabot>     fromRational    :: Rational -> a
20:19:16 <keep_learning>  @src Num
20:19:31 <Axman6> @src Num
20:19:31 <lambdabot> class  (Eq a, Show a) => Num a  where
20:19:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:19:31 <lambdabot>     negate, abs, signum     :: a -> a
20:19:31 <lambdabot>     fromInteger             :: Integer -> a
20:25:03 * hackagebot attoparsec-enumerator 0.2.0.5 - Pass input from an enumerator to an Attoparsec parser.  http://hackage.haskell.org/package/attoparsec-enumerator-0.2.0.5 (JohnMillikin)
20:25:05 * hackagebot attoparsec-enumerator 0.3 - Pass input from an enumerator to an Attoparsec parser.  http://hackage.haskell.org/package/attoparsec-enumerator-0.3 (JohnMillikin)
20:40:41 <Munksgaard> Hey, i'm working my way through learnyouahaskell, and i am trying to understand how monads translate into do notation. I'm pretty sure i get the basic idea, as described in chapter 12, but chapter 13 introduces the "tell" function, and i can't figure out how to translate the do notation involving that function. Every time i try i get errors because tell returns the dummy value (). Is there some kind of magic going on in the do notation when you use te
20:40:58 <ddarius> No.
20:41:00 <tgeeky> no
20:41:05 <tgeeky> the translation is probably listed in the GHC manual
20:41:11 <tgeeky> but if not, it's somewhere
20:41:36 <tgeeky> you could also see the monad comrehension translation (which is in the manual) to see similar neat tricks
20:41:43 <Axman6> do {a <- x; b} => x >>= (\a -> b), do {a; b{ => a >> b
20:41:59 <Axman6> }}
20:42:01 <Axman6> >_>
20:42:03 <ddarius> tgeeky: The Report completely defines the translation.
20:43:08 <_ralts> tell blablabla >> return (a*b)
20:43:14 <_ralts> Use >> to discard the value of tell
20:44:01 <monochrom> which is the same as tell blablabla >>= \_ -> return (a*b)
20:46:03 <Munksgaard> Hm, i thought i tried that monochrom, but obviously not, because that works :)
20:46:25 <Munksgaard> Thanks guys, that makes sense.
20:48:10 * JoeyA watches ghc and cc1 compete for memory usage while compiling frag
20:48:18 <JoeyA> cc1 is at 1.1g, ghc is at 466m
20:49:01 <dmwit> Wow, does frag still build?
20:49:07 <dmwit> I would definitely have expected it to bitrot by now.
20:49:13 <JoeyA> dmwit: That's what I'm about to find out :P
20:49:24 <monochrom> why does it use cc1?
20:49:24 <JoeyA> Linking...
20:49:32 <JoeyA> Failed.
20:49:35 <monochrom> oh, linking is the killer :)
20:49:43 <JoeyA> undefined references to glut
20:49:54 <dmwit> Do you have libglut(-dev) installed?
20:50:31 <dmwit> Hm, Data.Map.Map's read instance isn't as robust as I might hope.
20:53:11 <dmwit> or... hm
20:53:16 <dmwit> Maybe there is some other bug.
20:56:18 <thoughtpolice> kfish: huzzah! i've refactored a bit of ivan's work into its own package and added some front matter material for vacuum. i've even got a simple little github site for it. :) i suppose since i'll be taking over maintainership you can remove the haskell-pkg-janitors version of vacuum.
20:56:54 <thoughtpolice> i'll probably be sending an email to dons & co to see if they're OK with the changes i'm making, and if i can also take over vacuum-cairo. you'll be CC'd but i speculate you likely have few objections :)
20:57:01 <kfish> thoughtpolice, awesome :)
20:57:15 <kfish> yeah i have no objections of course
20:57:18 <thoughtpolice> it'll also probably go out to -cafe, since i'm not sure who all out there is using it
20:57:23 <kfish> just happy to have got the ball rolling
20:57:27 <kfish> yeah, please mail -cafe
20:58:16 <dmwit> I used vacuum-cairo once because it was the most convenient way to throw a few tree diagrams on the projector.
20:58:29 <dmwit> Haven't touched it since.
20:58:42 <kfish> dmwit, with haskell as your tree-diagram dsl?
20:58:45 <thoughtpolice> kfish: it's unfortunate matt's original repository is no longer available. :( i'd like to be able to give credit in my AUTHORS file to all the people who've added patches, but i doubt we'll ever be able to track them down. :(
20:58:51 <dmwit> It's simultaneously awesome and pretty niche.
20:58:53 <dmwit> kfish: yeah =)
20:59:12 <kfish> thoughtpolice, yeah :(
20:59:27 <kfish> thoughtpolice, will you resurrect the examples web page etc?
20:59:30 <thoughtpolice> it also effectively prevents any possible relicensing, especially since matt is MIA (i'm personally fine with LGPL, but I like licensing under BSD3/MIT myself)
20:59:36 <thoughtpolice> kfish: yes, there will be a gallery of examples
21:00:03 * hackagebot css-text 0.1.1 - CSS parser and renderer.  http://hackage.haskell.org/package/css-text-0.1.1 (MichaelSnoyman)
21:00:05 * hackagebot http-enumerator 0.7.1.6 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.6 (MichaelSnoyman)
21:00:07 * hackagebot xml-enumerator 0.4.4 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.4 (MichaelSnoyman)
21:00:30 <thoughtpolice> kfish: and there will be a new webpage that hopefully won't go down... as long as github is around, that is
21:00:39 <kfish> heh
21:01:04 * jessopher mirrors on google code just-in-case
21:01:25 <dmwit> argh
21:01:36 <dmwit> dmenu switched to outputting '\n's at the end
21:01:44 <thoughtpolice> they do support git now, don't they.
21:01:50 <jessopher> yerp
21:01:56 <thoughtpolice> i also have a bitbucket mirror just in case, like with most of my projects ;)
21:06:40 <Guest79947> i seem to be getting a segmentation fault using monadic code (through various monad type classes, though it does not know IO is involved)
21:06:54 <Guest79947> (IO is involved)
21:07:06 <Guest79947> is valgrind much help in these cases?
21:07:51 <thoughtpolice> not really. GDB is probably more helpful - if you're crashing somewhere in C code, for example, a library or the RTS, it can help you. but GHC-generated-code is an entirely different matter, as it uses a different stack, calling conventions, etc
21:08:06 <JoeyA> What's the best way to convert between floating types?  Both realToFrac and fromRational . toRational work.  http://haskell.org/haskellwiki/Converting_numbers suggests float2Double and double2Float, but these aren't general-purpose.  I'm interested in Float <-> GLfloat conversion.
21:08:10 <thoughtpolice> it would be helpful to see the code in question, if possible
21:08:28 <kfish> Guest79947, if you think a particular system call is being called wrongly or something, valgrind (or strace) might help
21:08:49 <Guest79947> ok, let me mess with narrowing down where its occuring
21:35:03 * hackagebot attoparsec 0.10.0.3 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.0.3 (BryanOSullivan)
21:37:54 <xil> hi. What's the config file where I can set my prompt for ghci? And can I just put ":set prompt <myprompt>" into it like typing it in an interpreter?
21:38:35 <Guest79947> interesting..
21:38:38 <ddarius> .ghci ?
21:38:50 <Guest79947> it looks sort of like it was from happy's generated code (the seg fault earlier)
21:39:05 <xil> ddarius: I don't understand. You mean ~/.ghci/?
21:39:06 <Guest79947> it was letting me treat [W A] as [A] for some defined W and A
21:39:11 <xil> and if so, what's the config filename?
21:39:49 <byorgey> xil: no, the config file is ~/.ghci
21:40:17 <xil> byorgey: oh I see. Any way I can make it ~/.config/ghci?
21:42:32 <byorgey> xil: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
21:42:49 <_ralts> xil: symlinks :)
21:42:58 <xil> byorgey: thank you =], and thanks ddarius =]
21:43:02 <shachaf> _ralts: Hard links. :-)
21:43:20 <xil> well the idea would be to not have a file in ~/, to reduce clutter
21:43:23 <xil> but it's okay if I have to
21:44:37 <_ralts> Yeah, everything except GHCi seems to use .config now
21:45:04 <shachaf> Really? I can think of very few programs I use that use .config.
21:45:27 <_ralts> s/everything/everything in GNOME/
21:45:40 <xil> _ralts: there are about as many things in .config as there are in ~/ for me
21:45:50 <rwbarton> GHCi, the GNOME Haskell Compiler interpreter
21:47:01 <_ralts> I don't get the joke
21:47:16 <rwbarton> "everything in GNOME except GHCi"?
21:48:03 <rwbarton> On my system it looks like big fancy applications with GUIs tend to use .config and normal UNIX programs don't
21:48:56 <Elbar> SCO will sue you soon ;)
21:49:24 <_ralts> Whoops
21:49:24 <jessopher> lol
21:49:42 <_ralts> s/except/which does not include/
21:50:29 <xil> doesn't the G stand for Glaskow, or Glasgow, or something like that?
21:50:43 <jessopher> nope, GNOME
21:50:56 <xil> haha
21:51:24 <jessopher> it either glaskgow(sp) or Glorious
21:51:28 <kmc> gnome haskell compiler, written in Vala
21:51:33 <JoeyA> lol
21:51:46 <kmc> yeah joking aside, GHC stands for Glasgow Haskell Compiler
21:52:00 <kmc> and is often the Glorious Glasgow Haskell Compiler, but you never see GGHC
21:52:00 <_ralts> I wish it was so it would have better support for GIR
21:52:35 <shachaf> You also rarely see GGHCS.
21:53:16 <JoeyA> What does GIR stand for?
21:53:19 <JoeyA> Generalized Inductive Recursion?
21:53:39 <JoeyA> GNU Intermediate Representation?
21:53:49 <shachaf> Global Interpreter Rock.
21:53:54 <JoeyA> lol
21:53:55 <irene-knapp> gender identity rock
21:54:19 <_ralts> It's one of those things everyone seems to be working on, but noone really finishes
21:54:22 <_ralts> Like JVM support
21:54:43 <irene-knapp> we have zero use for JVM support, really
21:55:04 <Cale> but... I want to write Minecraft mods in Haskell!
21:55:20 <irene-knapp> what we actually need, right, is a low-level virtual machine, like LLVM's, suitable for use as an intermediate representation - but using a typed assembly language
21:55:29 <JoeyA> https://www.google.com/search?q=%22global+interpreter+rock%22&nfpr=1 <- no hits!
21:56:10 <JoeyA> (nfpr=1 disables that annoying "searching instead for 'zombie pr0n'")
21:56:11 <AfC> Putting dot files in .config/whatever is a freedesktop / XDG thing
21:56:22 <irene-knapp> JoeyA: whoa!  thanks
21:56:32 <irene-knapp> JoeyA: that's even better than btnI=z ("I'm feeling lucky")
21:57:13 <irene-knapp> http://en.wikipedia.org/wiki/List_of_Invader_Zim_characters#GIR
21:58:05 <AfC> In the GNOME context, GIR is "g_introspection[ repository]", with descriptions of types and functions from GTK and other GNOME libraries, so that dynamic libraries can get symbols at runtime.
21:58:13 <irene-knapp> hmmmm
21:58:30 <kmc> irene-knapp, zero use for JVM support?
21:58:33 <irene-knapp> AfC: but GHC is, um, you know, not remotely related to the GNOME project, right
21:58:34 <AfC> s/dynamic libraries/dynamic languages like Python and JS/
21:59:00 <AfC> irene-knapp: {shrug} People were mentioning GNOME above. And it's relevant to gtkhs.
21:59:00 <irene-knapp> AfC: and our object model is not compatible with the Smalltalk one that every other language uses - it would be almost as bad as an ORM (in a different way though)
21:59:07 <irene-knapp> AfC: hmmm, I gues
21:59:09 <irene-knapp> *guess
21:59:11 <irene-knapp> gtkhs is a point
21:59:23 <irene-knapp> kmc: well, not zero - but it's not worth the effort to us
21:59:29 <kmc> who's "us" here
21:59:35 <jessopher> the man
21:59:38 <AfC> and meanwhile, yes, our .ghci should be moving into .config/ghci/ . Pretty soon distros will start patching it to do that  I expect.
21:59:38 <irene-knapp> people interested in broadening the use of Haskell, I guess
21:59:47 <kmc> then i think you're wrong
21:59:51 <irene-knapp> the JVM is a horrible way to deploy new work
21:59:51 <kmc> care to share your reasoning?
21:59:56 <irene-knapp> its value is in the legacy code that exists for it
22:00:03 * hackagebot cabal-src 0.2 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2 (MichaelSnoyman)
22:00:08 <kmc> why is the JVM so horrible
22:00:19 <irene-knapp> for that, it would be better to do, like, a JVM-to-STG translator or something
22:00:21 <kmc> isn't Oracle JVM a mature, sophisticated just-in-time compiler for a reasonable (if flawed) virtual machine?
22:00:24 <tensorpudding> gtkhs is not that good as i understand it
22:00:30 <irene-knapp> it's not a reasonable VM.  have you seen its details?
22:00:49 <irene-knapp> it's very hard to write a language in it that doeesn't have the Smalltalk object model, since objects are primitives...
22:01:01 <irene-knapp> you also can't do anything but a traditional top-down stack
22:01:02 <kmc> sure
22:01:06 <irene-knapp> so no continuations or closures or fun stuff
22:01:09 <kmc> i'm not saying it's perfect, or even that it's a good fit for Haskell
22:01:15 <kmc> but it does provide value even for "new work"
22:01:17 <kmc> a lot of value
22:01:23 <irene-knapp> mm
22:01:26 <kmc> compared to the rinkydink interpreters most new languages use
22:01:31 <irene-knapp> okay, granted
22:01:39 <irene-knapp> of course, those rinkydink interpreters bootstrap in 100ms
22:01:47 <tensorpudding> the languages available on the jvm are pretty varied
22:01:48 <kmc> i think good JVM interop for Haskell would be useful, even if it's not running Haskell code on the JVM
22:01:49 <irene-knapp> the JVM takes 30s on my MBP
22:01:59 <tensorpudding> the JVM startup is rather low
22:02:01 <tensorpudding> slow*
22:02:04 <kmc> many applications do not care about startup time
22:02:13 <kmc> if you're out to prove that JVM sucks, I'm sure you can find some reasons
22:02:15 <AfC> especially server-side
22:02:15 <irene-knapp> yes, certainly, for example server processes
22:02:23 <irene-knapp> I'm really not out to prove that the JVM is horrible
22:02:26 <tensorpudding> scala and clojure are not unimpressive languages
22:02:30 <kmc> haha
22:02:35 <kmc> this is #haskell, you can't say they're "impressive"
22:02:36 <irene-knapp> I'm just stating my position that it's not a sufficiently valuable thing for us to support
22:02:39 <kmc> only "not unimpressive"
22:02:45 <_ralts> tensorpudding: That's not the JVM, it's the huge Java standard library
22:02:45 <kmc> irene-knapp, that's totally crazy
22:02:52 <irene-knapp> howso?
22:02:54 <Axman6> kmc: they're not haskell, so yes :P
22:02:57 <kmc> there are huge numbers of developers who will never touch anything that doesn't work on JVM
22:03:09 <kmc> if your goal really is "broadening the use of Haskell" then it's an obvious target
22:03:15 <tensorpudding> i'm not saying haskell should target the jvm
22:03:20 <tensorpudding> i think that'd be a bit odd
22:03:23 <irene-knapp> yes, but
22:03:25 <kmc> sigh
22:03:35 <irene-knapp> okay, so, um, I guess I stated it wrong
22:03:36 <kmc> sometimes i have a real problem dealing with the insular, ideological nature of the Haskell community
22:03:48 <irene-knapp> broadening the use of Haskell is not necessarily even the right goal
22:03:49 <tensorpudding> is java library interop something that people particularly want with haskell?
22:04:01 <irene-knapp> especially not at the expense of catering to people who aren't willing to try anything new
22:04:06 <irene-knapp> because if we start catering to those people
22:04:10 <kmc> tensorpudding, people keep talking about it, and implementing 80% solutions, and then abandoning them
22:04:13 <irene-knapp> we give up our ability to do interesting things
22:04:15 <Axman6> tensorpudding: no thank you
22:04:16 <kmc> irene-knapp, no
22:04:17 <kmc> gah
22:04:18 <kmc> no
22:04:18 <kmc> no
22:04:19 <kmc> no
22:04:29 <irene-knapp> you seem rather upset
22:04:31 <kmc> yes
22:04:33 <jessopher> lol
22:04:43 <Axman6> no!
22:04:43 <irene-knapp> by the way
22:04:50 <kmc> companies stuck on JVM are not necessarily "unwilling to try anything new"
22:04:52 <irene-knapp> I really don't think I'm a particularly good spokeswoman for the Haskell community
22:04:58 <kmc> many of them are trying clojure, scala, groovy, etc.
22:05:01 <kmc> they can't try Haskell
22:05:08 <irene-knapp> I really don't have any special connections that make everyone else do what I say :)
22:05:09 <kmc> a project which allows them to would have value towards that goal
22:05:10 <kmc> that is all
22:05:21 <tensorpudding> there's java ports of many languages
22:05:25 <tensorpudding> jruby, jython
22:05:27 <irene-knapp> if I'm being insular and ideological, it's entirely ME doing it, not "the Haskell community" doing it
22:05:47 <irene-knapp> (and if "ideological" is supposed to insult me, think again - I take that as a compliment)
22:05:57 <tensorpudding> well
22:05:58 <AfC> tensorpudding: one could go from Java through JNI to C and then invoke Haskell from there, but I don't know that that's such a good idea as an approach to interoperation
22:06:02 <kmc> having an ideology is good but letting it distort your picture of reality is bad
22:06:08 <kmc> anyway i was not talking about you in particular irene-knapp
22:06:09 <tensorpudding> you are restricted on what you can do in jython, aren't you?
22:06:21 <tensorpudding> no c extensions, since those only work on cpython
22:06:23 <irene-knapp> anyway, yes, I suppose there are businesses stuck on the JVM, although I really would like to hear the explanation of why it's zomg IMPOSSIBLE for them to leave it
22:06:46 * ddarius agrees with irene-knapp's latest statement and finds kmc's statement a bit odd after stating that there are developers that won't touch anything that doesn't work on JVM.
22:06:47 <irene-knapp> I mean, okay, so they have half a million lines of Java code that they need to interoperate with, right
22:06:54 <jessopher> irene: insular ideology
22:06:55 <tensorpudding> would it not be the same with hypothetical java haskell and the C FFI
22:06:58 <_ralts> Because CEOs aren't usually taught computer science
22:07:08 <AfC> irene-knapp: if that's their installed base, their developer pool, where their business logic is, and what their systems management infrastructure supports, then they aren't going *anywhere*
22:07:30 <tensorpudding> also there's the fact that there's no credible alternative to ghc
22:07:35 <irene-knapp> so um, write a damn JVM-to-something-else translator, it's really not that much work ><
22:07:40 <kmc> only half a million?
22:07:46 <kmc> irene-knapp, oh, is yours on github?
22:07:56 <irene-knapp> it's not that much work compared to what they make it out ot be
22:08:31 <Axman6> The JVM is well understood, and that's something that makes a lot of people want to use it. the devil you know n' all
22:08:34 <kmc> maybe these problems turn out to be hard once you actually try to solve them
22:08:44 <kmc> or maybe everyone but us are idiots
22:08:46 <AfC> http://www.haskell.org/haskellwiki/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET_or_on_the_JVM.3F is probably a bit old, but talks about some of the engineering issues
22:08:51 <irene-knapp> look, Google did a Java source to JavaScript compiler
22:09:04 <irene-knapp> yes, it's a monstrosity
22:09:12 <tensorpudding> people don't always choose their platform for technical merits
22:09:14 <_ralts> But JavaScript expressiveness > Java expressiveness
22:09:29 <ddarius> There have been multiple things to talk to and/or compile to Java/the JVM from Haskell throughout the years.
22:09:43 <irene-knapp> ralts: um, yeah, and any other VM or physical architecture besides the JVM is also > Java expressiveness
22:09:48 <tensorpudding> i mean, if you're making an app for a given system, you might not have a choice at all
22:10:07 <irene-knapp> tensorpudding: yes, I realize that there are platforms on which the only third-party apps allowed are JVM
22:10:11 <kfish> hi alang
22:10:11 <tensorpudding> if you hate the iOS app platform, you can't really make your iOS app on some other platform
22:10:20 <tensorpudding> you either use their tools or none at all
22:10:34 <ddarius> I'm pretty sure the main reason there isn't a usable JVM bridge, is because no one really cares.  They've been made and they bitrot.
22:10:35 <irene-knapp> tensorpudding: but I strongly question the business model of any company which just absolutely freaking NEEDS to target those platforms or it can't do business
22:10:57 <irene-knapp> I mean, if they've built their entire damn business around the fact that they're the only ones Nokia or whoever will allow to write stuff that runs on their hardware
22:11:02 <tensorpudding> you don't tend to create things unless they have an immediate use to you
22:11:08 <AfC> tensorpudding: it's gotta be at least half the reason Scala is popular. At first glance you'd ask why you [still] want to be on the JVM, but if that's where your business logic is, then Scala gives you a great bridge without having to reimplement all the tedious stuff.
22:11:08 <Axman6> kfish: a new Tsuru employee?
22:11:33 <jessopher> (nokia by the way, has a very flexible development platform for their devices)
22:11:39 <irene-knapp> what are they going to do when a) Nokia goes bankrupt and their hardware is no longer available, b) Nokia licenses somebody else to do it, c) Nokia decides they want a thousand times the licensing fees they have hitherto asked
22:11:52 <kfish> Axman6, yeah, alex is hax0ring with us when he 's not doing quantum category theory and stuff
22:12:05 <irene-knapp> d) their former users all buy iPhones and they have no ability to develop in anything but Java, so they can't write software that runs on those
22:12:24 <irene-knapp> okay, I don't actually know anything bad about Nokia :) say LG then
22:12:48 <tensorpudding> you'll always have to rewrite your app for the iPhone, because the iPhone development environment is unique
22:12:50 <irene-knapp> I totally believe that there are companies that THINK they are tied to the JVM and that their entire fortune depends on it
22:13:12 <irene-knapp> I just don't believe that these companies are in any way connected to the real universe, or going to be in business five years from now
22:13:22 <tensorpudding> if they feel they need to target the iPhone they're going to use the iPhone SDK tools
22:13:37 <tensorpudding> they're not going to turn down that market just because it's not using java
22:13:44 <irene-knapp> tensorpudding: but kmc stipulated that they have an institutional inability to do that
22:13:55 <irene-knapp> tensorpudding: I wasn't the one who introduced that constraint, so ask him to justify it, not me
22:14:27 <irene-knapp> oh, kmc ragequit and didn't see my response :(
22:14:30 <irene-knapp> oh well :(
22:14:41 <kmc> you're willfully disconnected from reality
22:15:09 <irene-knapp> <irene-knapp> I totally believe that there are companies that THINK they are tied to the JVM and that their entire fortune depends upon it
22:15:13 <kmc> furthermore you exhibit the classic nerd fallacy of "i know how X would be done in theory, therefore it is trivial and every company should be doing it even though it's secondary to their business goals"
22:15:20 <Axman6> kfish: what is this i don't even
22:15:22 <kmc> like your JVM to STG compiler
22:15:26 <kmc> it would be really cool if that existed
22:15:27 <irene-knapp> <irene-knapp> I just don't believe that these companies are in any way connected to the real universe, or are going to be in business five years from now
22:15:33 <kmc> with good performance
22:15:38 <kmc> with support for all the Java people use in the real world
22:15:42 <jessopher> well either way, the people who make that decision arent writing the software, so they don't have the same value system as the developers do. I doubt anyone at that level really cares about java this or haskell that, they just dont want to pull a rug out from under their own feet
22:15:45 <kmc> but it's going to be HARD
22:15:49 <irene-knapp> yes, look, but by your own stipulation it's NOT secondary to their business goals
22:15:55 <irene-knapp> if they are wedded to the JVM, they NEED TO GET OFF IT
22:16:01 <kmc> why?
22:16:02 <irene-knapp> for the same reason that a cocaine addict NEEDS TO QUIT
22:16:08 <kmc> JVM will be around for a long long long time
22:16:09 <irene-knapp> it's not sustainable!
22:16:11 <kmc> COBOL is still around
22:16:15 <kmc> what makes you think it's unsustainable?
22:16:29 <irene-knapp> COBOL is an excellent point.  let me look something up real quick.
22:16:30 <_ralts> kmc: second
22:16:37 <_ralts> It's bad, but it works
22:16:38 <zzo38> What should a function be called:   BarrierT f b m t -> BarrierT (f, b -> BarrierT f b m t) (BarrierT f b m t) m t     and      Barrier f b t -> Barrier (f, b -> Barrier f b t) (Barrier f b t) t
22:16:40 <kmc> JVM is supported by the second largest software company on the planet
22:16:45 <_ralts> Just like Windows
22:16:53 <kmc> zzo38, f
22:16:58 <kmc> i'm not saying it's beautiful but it's a pretty solid bet that it will continue to exist
22:17:05 <zzo38> I mean, making up this function having these types what should their names be? I need some suggestion help
22:17:06 <kmc> irene-knapp, you've given no argument to the contrary
22:17:06 <_ralts> And it gets less bad as time goes on
22:17:10 <Axman6> people should think twice before dissing COBOL. it's used a hell of a lot more than you might think
22:17:13 <irene-knapp> http://swz.salary.com/salarywizard/layoutscripts/swzl_selectjob.aspx?hdSearchByOption=0&hdLocationOption=1&hdKeyword=COBOL&hdJobCategory=&hdZipCode=Enter+Zip+Code&hdStateMetro=&hdNarrowDesc=&geometrocode=&txtKeyword=COBOL&txtZipCode=
22:17:16 <ddarius> kmc: Sun was a large software company.
22:17:26 <irene-knapp> I can only assume that any surviving COBOL developer are making $300k/yr
22:17:43 <irene-knapp> nobody can afford to maintain a legacy COBOL system.  yes, people try to.
22:18:08 <irene-knapp> (I have far less against COBOL on its technical merits than I do against Java, actually)
22:18:20 <irene-knapp> (but from the perspective of "is it possible to hire people to work on it?" the answer is UM NO)
22:18:21 <_ralts> zzo38: sorry, we're debating too much to answer :)
22:18:22 <zzo38> kmc: f?
22:18:22 <kmc> are we arguing about Java or JVM?
22:18:26 <irene-knapp> both
22:18:32 <irene-knapp> but mostly the JVM I guess
22:18:40 <kmc> i'm pretty sick of this argument
22:18:50 <keep_learning> :k (->)
22:18:50 <kmc> you mock me for "ragequit" but I think there is no other healthy response
22:18:50 <lambdabot> ?? -> ? -> *
22:18:50 <Axman6> zzo38: "quite complicated" :P
22:18:57 <irene-knapp> I wasn't mocking you
22:19:00 <kmc> this has all been hashed out 1000 times before
22:19:06 <kmc> nobody gives a shit what #haskell thinks of Java
22:19:12 <kmc> or how blind the denizens of #haskell are to the real world
22:19:13 <zzo38> _ralts: O, sorry. Try later if you have any answer
22:19:14 <_ralts> zzo38: what does it do?
22:19:15 <irene-knapp> I am not #haskell
22:19:16 <kmc> it does not matter at all
22:19:19 <irene-knapp> and I am offended by the way
22:19:35 <irene-knapp> look, I agree that Java is an important technology to the real world.  I'm even willing to stipulate that the JVM is the same.
22:19:43 <_ralts> zzo38: We should be the ones apologizing, not you :)
22:19:48 <irene-knapp> that does not mean that it is intelligent for a company to build its business on the JVM.
22:20:10 <zzo38> _ralts: Yes, you should be apologizing too, please
22:20:17 <irene-knapp> regarding the Java language, right now it's popular and easy to hire people for.  C++ was the same ten years ago.
22:20:36 <keep_learning> why the kind of (->) is  ?? -> ? -> * . Should not it be *->* -> * ?
22:20:36 <irene-knapp> mainstream languages are nothing but fads and it's just plain stupid to assume they're going to be around forever
22:20:40 <tensorpudding> it's what people know, what companies are already using
22:20:42 <Axman6> imo, the JVM is an amazingly impressive piece of softeware. Java may be a pretty trerrible language (though it isn't hard to get things done with it, and that's not something to scoff at)
22:20:49 <kmc> keep_learning, those kinds are a GHC extension
22:20:53 <kmc> to deal with unboxed types
22:21:03 <kmc> Haskell kinds are made of * and (->)
22:21:06 <kmc> GHC adds several more
22:21:07 <Axman6> hmm, that sentense didn't really work...
22:21:10 <kmc> # is the kind of unboxed values
22:21:14 <tensorpudding> i think every language that was once mainstream still has a huge legacy market
22:21:17 <kmc> (#) is the kind of unboxed tuples (which aren't really values)
22:21:19 <irene-knapp> regarding the JVM, yes, one of the largest and least-loved software companies on the planet is desperately trying to save it
22:21:23 <tensorpudding> Java, C++, C, COBOL
22:21:24 <kmc> ?? means * or #
22:21:24 <lambdabot>  means * or #
22:21:29 <kmc> ? means * or # or (#)
22:21:36 <zzo38> _ralts: To understand what it does, first, do you know the generator functions in JavaScript (I think it is similar in Python)? There is the function:    yield :: f -> Barrier f b b;     So the type of values yielded is called the front type and the back type is like in JavaScript { var b = yield f; } then b is of the back type and f is of the front type
22:21:37 <irene-knapp> mind, they haven't come up with anything new or interesting for it in most of a decade
22:21:51 <kmc> keep_learning, so a function can take a boxed or unboxed value, and can return a boxed or unboxed value or an unboxed tuple
22:21:54 <tensorpudding> of course most COBOL still around is massively outdated
22:22:05 <kmc> keep_learning, and function types themselves are boxed
22:22:13 <ddarius> kmc: I don't understand why -you- care so much what people in #haskell say about the JVM.  Why don't you just ignore such things when they come up?
22:22:14 <Axman6> irene-knapp: what,m Google?
22:22:17 <kmc> could you please take the complaining about Java, COBOL, etc. somewhere else?
22:22:21 <kmc> ddarius, a fair point
22:22:22 <irene-knapp> Axman6: um, Oracle
22:22:28 <keep_learning> kmc, thank you
22:22:38 <irene-knapp> kmc: YOU brought this subject up!  let me finish re-summarizing my point and I'll stop
22:22:55 <zzo38> So, the function of the types I have asked the suggestion, it would convert the front value to pass the continuation and the back value must be passed the continuation.
22:22:56 <jessopher> wah wah wah
22:23:01 <irene-knapp> but investing in COBOL infrastructure in 2011 would be a mark of utter insanity
22:23:08 <zzo38> Is it understand now?
22:23:17 <irene-knapp> yes, everybody has legacy systems.  yes, legacy systems will be around for a very long time.
22:23:34 <irene-knapp> and the cost of working with those legacy systems goes up as an exponential function of years passing.
22:23:35 <kmc> ddarius, partially because I have opinions about these things too, so I have to spend willpower not to get drawn into pointless arguments
22:24:00 <irene-knapp> making one's legacy systems larger and more complicated is an unsound business strategy and no company can succeed by doing it.
22:24:05 <irene-knapp> okay, I'm done
22:25:20 <kfish> zzo38, hi!
22:25:33 <jessopher> rinkydink interpreters... (pops out his monacle and leaves the room)
22:55:03 * hackagebot containers-deepseq 0.1 - Provide orphan NFData instances for containers as needed.  http://hackage.haskell.org/package/containers-deepseq-0.1 (MichaelSnoyman)
23:17:20 <davidt_> Hi all. So if I compile and run the expression 'fix (\x -> 5 + x)', ghc will detect the infinite loop and throw an exception, all of which I understand. However If I run the expression in GHCi it loops forever, which I don't understand. I would think even if the blackhole loop detection was disabled, at some point GHCi should crash as I believe there should be continuous thunk creation so continuous heap allocation...
23:21:01 <dolio> How would that create thunks continuously?
23:21:04 <Cale> davidt_: It's fallen into a grey hole. The threaded runtime unfortunately can't be certain that another thread isn't evaluating the thunk, and so just waits.
23:21:41 <Cale> IIRC, if you compile with -threaded, you should see the same thing
23:22:56 <Cale> hmm
23:23:03 <Cale> actually, maybe I'm wrong
23:23:38 <Cale> I'm fairly sure it's related to that, but compiling with -threaded, it still correctly detects the blackhole.
23:23:46 <Cale> I'm not sure
23:23:57 <Cale> why that is
23:24:17 <shachaf> I don't think ghci does black hole detection.
23:25:32 <jessopher> I can seem to find anything anywhere about manually writing instances for Typeable. From the Data.Typeable haddock, its not clear to me even how to come to a TypeRep for my type
23:25:38 <jessopher> can't
23:26:22 <jessopher> Q) how you do that?
23:27:06 <c_wraith> you use mkTyCon and then use whatever function applies TyCons to arguments in order to create a typerep
23:27:10 <Cale> You shouldn't really even be allowed to write instances of Typeable... but there are lots of functions for constructing TypeReps in Data.Typeable
23:27:42 <c_wraith> Cale: It'd be nice if GHC could actually derive Typeable for all types.
23:28:38 <Cale> You'd use mkTyCon and mkTyConApp, I think
23:29:23 <c_wraith> personally, I'd *love* to derive Typeable.  But when GHC just errors out, you have to go other directions...
23:29:52 <Cale> That's true :P
23:30:26 <Cale> I haven't seen many cases where it can't derive it, but I can imagine some which might be tricky.
23:30:57 <Cale> Does StandaloneDeriving help much?
23:31:27 <jessopher> i still dont totally get it, I have an idea of how it works, but I would have to see an example
23:32:13 <c_wraith> Cale: no.  when it fails, it's because of the fact that it can't derive Typeable for type constructors whose arguments have an arrow in them
23:32:30 <c_wraith> Cale: which makes no sense to me, since there's still only one correct way to represent them
23:32:33 <jessopher> in my head i see this as everything casts to string, and then from string to whatever based on their typeable instance
23:33:14 <jessopher> which is probably wrong
23:40:03 * hackagebot asn1-data 0.6.1.1 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.6.1.1 (VincentHanquez)
23:41:15 <c_wraith> it's...  kinda close.  Typeable is ugly inside.
23:41:16 <c_wraith> it's actually going to change in an upcoming version of ghc to be less ugly inside, but not any safer to write manual instances for
23:42:10 <jessopher> well then i'll take this to mean I probably shouldnt, and I'll just let GHC derive one
23:42:30 <c_wraith> yeah..  doing it wrong can result in GHC segfaulting.  It's a dangerous class
23:42:39 <c_wraith> err, not ghc, whatever program you wrote
23:42:46 <jessopher> gotcha
23:52:18 <ski> c_wraith : you mean deriving `Typable' for stuff like `StateT', e.g. ?
23:52:28 <c_wraith> yes
23:53:20 <ski> c_wraith : well, for `*', there's `Typable'; for `* -> *', there's `Typable1'; for `* -> * -> *', there's `Typable2', &c.
23:53:41 <ski> for `(* -> *) -> *', i think there's nothing standard
23:53:52 <c_wraith> that's still just Typeable1
23:54:22 <ski> no, `Typable1' takes a type of kind `* -> *' as argument
23:54:34 <ski> `Typable1' isn't polymorphic
23:55:32 <c_wraith> oh, hmm.  ok, so you can't create a Typeable1 instance for it.  But you can certainly still create a Typeable instance for it when applied to enough type arguments
23:56:41 <ski> yeah .. `instance (Typable s,Typable1 m) => Typable1 (StateT s m)' ought to work, i think
23:56:53 <c_wraith> indeed.
23:57:07 <c_wraith> you can certainly write an instance like that manually
23:57:34 <c_wraith> but GHC can't derive it, even though it's mechanical
23:58:02 <ski> i assume you tested `StandaloneDeriving' which Cale suggested ?
23:59:03 <c_wraith> I did not, but I don't see it work with the error message it gives.
23:59:05 <ski> we'd really want to generalize all these classes somehow to `Typable :: forall k. k -> Constraint' or something like that
23:59:29 <c_wraith> I think you need the Polykinds extension to properly generalize it
23:59:42 <c_wraith> but hey!  that will exist soon!
