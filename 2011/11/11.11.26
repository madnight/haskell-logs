00:25:54 <ulfdoz> llh
00:53:42 * hackagebot hakyll 3.2.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.3.0 (JasperVanDerJeugt)
01:21:23 <m3ga> @hoogle umask
01:21:23 <lambdabot> No results found
01:21:27 <m3ga> hmm
01:25:27 <m3ga> @hoogle setFileCreationMask
01:25:27 <lambdabot> System.Posix.Files setFileCreationMask :: FileMode -> IO FileMode
01:27:48 <qwer123> :t function shows the definition of a function with its sets .... How to show the exact definition of that function??
01:27:49 <lambdabot> parse error on input `of'
01:28:21 <shachaf> qwer123: What?
01:28:37 <shachaf> Sets?
01:28:50 <shachaf> ghci won't show you the source of a function, if that's what you're asking for.
01:29:00 <qwer123> so like :t sin maybe would give sin: R-R. What I want is :X sin with result: sin x =
01:29:57 <Tarrasch> Have anyone made a hackage-version of FAL or something similar? FAL is the simple reactive library constructed in the book HSOE. I could not find anything on hackage, but I can't believe it does not exist.
01:30:55 <Jafet> qwer: if there is a definition, you can find it linked from the haddock documentation.
01:31:14 <Cale> You can :info sin
01:31:57 <Cale> which will show you the relevant part of its definition in the Floating class
01:32:37 <Cale> Since it's a class method, the implementation at each instance will be different (and quite boring for Float and Double, since it's a primitive)
01:33:11 <Jafet> It's just FFI, right?
01:33:26 <qwer123> Jafet: Cale: Which website to look up for source documentation of e.g. sin ?
01:33:53 <Jafet> sin is a member of Floating, so its definition depends on its type.
01:34:11 <Cale> qwer123: which sin?
01:34:40 <qwer123> sin(x), cos(x), tan(x)
01:34:53 <Cale> qwer123: but for which concrete type?
01:35:01 <Cale> qwer123: sin is a polymorphic function
01:35:09 <qwer123> Cale: e.g. sin: R->R
01:35:13 <Cale> It's defined by the Floating class
01:35:17 <Cale> in the Prelude
01:35:39 <Jafet> @instances Floating
01:35:40 <lambdabot> Double, Float
01:35:40 <Cale> http://haskell.org/onlinereport/standard-prelude.html is a nicely readable sample implementation of the Prelude
01:35:59 <Jafet> There's a sin::Float->Float, sin::Double->Double, sin::CReal->CReal...
01:36:01 <Cale> (also Complex, though apparently that's not imported by @instances)
01:36:14 <Jafet> Clearly, they have different definitions
01:36:15 <Cale> sin :: Complex Double -> Complex Double
01:36:50 <Cale> There's a sinDouble# primop in GHC
01:36:56 <Cale> which the Double instance uses
01:38:24 <qwer123> Any online source documentation?
01:38:31 <qwer123> of all haskell sources ?
01:38:44 * shachaf wonders whether qwer123 ~ qwe1234
01:39:06 <Jafet> You're asking if they're homeomorphic?
01:39:09 <c_wraith> everything on hackage has the source available.  html-colorized, even, for the most part
01:39:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html there's source documentation linked from here, for the basic libraries
01:40:05 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/src/GHC-Float.html#Floating
01:41:02 <Cale> instance  Floating Float  where
01:41:02 <Cale>       ...
01:41:02 <Cale>     sin x               =  sinFloat x
01:41:23 <Jafet> libc all the way down
01:41:54 <Cale> sinFloat    (F# x) = F# (sinFloat# x)
01:42:11 <Cale> sinFloat# is the GHC primop which acts on unboxed floating point numbers
01:42:17 <c_wraith> how fast is the libc implementation of the trig functions, these days?  Is it variable?
01:42:28 <Jafet> Eh, which libc?
01:42:33 <Cale> If you want to go deeper, we need to look at the compiler source
01:42:34 <c_wraith> let's say glibc
01:42:40 <Jafet> Which glibc!?
01:42:46 <c_wraith> the one on my machine! :)
01:43:11 <Jafet> You could benchmark it
01:43:27 <Jafet> At these time scales, though, you'd have to use Criterion
01:43:56 <Jafet> (Yeah, use a haskell library with ghc to benchmark libc)
01:44:17 <c_wraith> criterion isn't especially useful here.
01:44:39 <Jafet> You get the variance
01:45:04 <c_wraith> Yeah, but I won't have any clue if that variance comes from the implementation or from system noise.
01:46:38 <c_wraith> what I really would want to do is test with several hundred double values, looking for statistically significant different timings between them.
01:46:46 <c_wraith> and criterion really isn't built for that.
01:47:01 <c_wraith> I mean, the data gathering portion is fine, but the reporting is not
01:47:52 <Cale> following the GHC source code down a bit, it seems the floatSin primop actually makes it all the way to the code generator unscathed, and in the case of x86...
01:48:31 <Cale> We have genCCall32 handling a case... MO_F64_Sin  -> actuallyInlineFloatOp (\s -> GSIN s l1 l2) FF64 args
01:49:13 <Cale>         actuallyInlineFloatOp instr size [CmmHinted x _]
01:49:13 <Cale>               = do res <- trivialUFCode size (instr size) x
01:49:13 <Cale>                    any <- anyReg res
01:49:13 <Cale>                    return (any (getRegisterReg False (CmmLocal r)))
01:51:27 <Cale> So... it looks like it ends up compiling directly to an X86 instruction.
01:52:16 <Jafet> Oh, cool
01:52:19 <Cale> hmm
01:52:24 <Cale> Well, I have to look moar
01:52:35 <Jafet> That's plausible
01:52:38 <c_wraith> that appears to be Cmm instructions
01:52:49 <Cale> -- if you ever add a new FP insn to the fake x86 FP insn set,
01:52:50 <Cale> -- you must update this too
01:52:50 <Cale> is_G_instr :: Instr -> Bool
01:53:09 <Cale> It's calling these instructions "fake" so it'd be interesting to find out what it's actually doing with them.
01:53:16 <Jafet> The libc probably uses the same x86 instruction anyway
01:53:58 <Cale> Well, one way to find out is just to look at the generated assembly :P
01:57:30 <Cale> yep, it generates an fsin instruction directly
01:57:36 <Cale> eventually
01:58:08 <c_wraith> gah.  ghc-core shows it emitting "call sin"
01:58:11 <shachaf> Cale: It does?
01:58:15 <shachaf> I got a "call sin" too.
01:58:21 <Cale> er, hmm
01:58:57 <Eduard_Munteanu> gcc might provide builtins and inline them anyway.
01:59:25 <Cale> cale@ender:~$ ghc -O2 -ddump-asm sine.hs | grep call
01:59:25 <Cale> 	call newCAF
01:59:25 <Cale> 	call isDoubleNegativeZero
01:59:25 <Cale> Linking sine ...
01:59:33 <Cale> cale@ender:~$ ghc -O2 -ddump-asm sine.hs | grep fsin
01:59:33 <Cale> fld %st(0); fsin
01:59:34 <Cale> 	fsin
01:59:34 <Cale> Linking sine ...
02:00:21 <qwer123> "let" can only be used in ghci?
02:00:22 <shachaf> Cale: ghc-core will do that for you, by the way. :-)
02:00:30 <c_wraith> Cale: what version of ghc?
02:00:39 <shachaf> qwer123: No, it can be used in any Haskell program.
02:00:48 <Cale> 7.2.1
02:00:48 <c_wraith> $ ghc -O2 -ddump-asm trig.hs | grep call
02:00:48 <c_wraith> 	call newCAF
02:00:48 <c_wraith> 	call sin
02:00:56 * shachaf is using 7.0.
02:01:22 <c_wraith> ah, this is on 6.12.3
02:01:37 <Cale> qwer123: it shows up in a few places in Haskell's syntax, but GHC admits it as part of its own syntax
02:01:39 <c_wraith> ...  Yes, I have 6.12 through 7.3 installed.
02:01:54 <Cale> qwer123: er, GHCi rather
02:03:15 <Cale> There are a few places: There are let expressions:  let <decls> in <expr>  is an expression form.  let <decls>  is also a valid statement in a do-expression, and also allowed inside a list comprehension
02:03:37 <Cale> The ghci let syntax mimics the inside of a do-block
02:03:57 <Cale> along with other things, for instance, in ghci, you can write  x <- getLine
02:04:10 <Cale> and it will execute getLine immediately, binding the result to x
02:05:25 <Cale> ghci basically makes it appear as if you're writing the inside of a do-block which is currently running, to some extent. It has lots of other commands too, and it'll automatically apply 'print' to expressions which aren't IO actions, and it'll automatically print the result of IO actions separately.
02:06:21 <Cale> qwer123: does that make it any clearer?
02:07:10 <Cale> So when you're writing a Haskell source file, you don't have to write let before your function declarations -- the Haskell source format isn't the same stuff as you'd type into ghci.
02:07:20 <Cale> (though there are obviously similarities)
02:24:02 <gwern> @wn punt
02:24:03 <lambdabot> *** "punt" wn "WordNet (r) 2.0"
02:24:04 <lambdabot> punt
02:24:04 <lambdabot>      n 1: formerly the basic unit of money in Ireland; equal to 100
02:24:04 <lambdabot>           pence [syn: {Irish pound}, {Irish punt}, {pound}]
02:24:04 <lambdabot>      2: an open flat-bottomed boat used in shallow waters and
02:24:05 <lambdabot> [11 @more lines]
02:24:07 <gwern> @more
02:24:08 <lambdabot>         propelled by a long pole
02:24:09 <lambdabot>      3: (football) a kick in which the football is dropped from the
02:24:11 <lambdabot>         hands and kicked before it touches the ground; "the punt
02:24:13 <lambdabot>         traveled 50 yards"; "punting is an important part of the
02:24:15 <lambdabot>         game" [syn: {punting}]
02:24:18 <lambdabot> [6 @more lines]
02:24:19 <gwern> @more
02:24:20 <lambdabot>      v 1: kick the ball
02:24:21 <lambdabot>      2: propel with a pole; "pole barges on the river"; "We went
02:24:23 <lambdabot>         punting in Cambridge" [syn: {pole}]
02:24:25 <lambdabot>      3: place a bet on; "Which horse are you backing?"; "I'm betting
02:24:27 <lambdabot>         on the new horse" [syn: {bet on}, {back}, {gage}, {stake},
02:24:29 <lambdabot>          {game}]
02:24:51 <gwern> huh. didn't realize the use 'punt' as in 'pass the buck' was apparently so obscure
02:29:46 <qwer123> Cale: ty much ;)
02:31:08 <hvr> since when does GHC have an interactive mode?
02:31:39 <gmzlj> hvr: ghci
02:31:40 <lars9> @hoogle iterStream
02:31:41 <lambdabot> No results found
02:31:52 <hvr> gmzlj: exactly; which GHC version was the first one to have it?
02:31:58 <Cale> gwern: OED has that sense, labelled N. Amer. colloq.
02:32:18 <gwern> Cale: fair enough, as I am indigenous to N. Amer. and was using it colloq.
02:32:27 <Cale>  4. N. Amer. colloq.  a. intr. To give up, back out; to defer or avoid taking action or responsibility, to ëpass the buckí.  b. trans. To avoid, defer, or give up on. Also: to pass responsibility for (something) to.
02:32:49 <Cale> lol, and one of the example quotes...
02:32:53 <Cale> 1983    G. Steele et al. Hacker's Dict. 106   Let's punt the movie tonight.
02:33:13 <gwern> just one of the many ways the jargon file has contaminated my mind
02:34:31 <Cale> hvr: wow, for at least as long as I've been using it...
02:35:11 <Cale> I wonder if there was ever *not* a ghci
02:36:03 <Cale> oh, perhaps
02:37:02 <Cale> ah, apparently that was added in version 5.00, April 2001
02:37:30 <Cale> which was around the time that I started learning Haskell -- I never used 4.x
02:39:20 <Cale> I figured that out by going here: http://haskell.org/ghc/download and clicking on the documentation and release notes for the old versions :)
02:39:39 <Jafet> What was ghci-5.00 like, anyway?
02:41:07 <Jafet> Hm, it's nearly identical to the current ghci.
02:41:20 <Cale> hmm... similar to what we have now, but with no debugger
02:41:52 <Jafet> Who uses the debugger?
02:41:54 <Cale> and it didn't annoyingly print the results of IO actions all the time :)
02:42:56 <Cale> oh, and all your bindings were lost every time you reloaded anything
02:43:13 <Jafet> Has that ever changed?
02:43:32 <Sgeo> If I want a type that sort of acts like flags, is it acceptable to make a type synonym of Bits, or are there more preferred ways?
02:44:05 <Cale> oh, hah, I thought I heard something about that changing, but I guess not.
02:44:37 <Cale> Sgeo: Bits is a type?
02:44:46 <Sgeo> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/haskell2010-1.0.0.0/Data-Bits.html
02:44:53 <Sgeo> Oh, wait, that's a typeclass, hmm
02:44:59 <Cale> Right :)
02:45:16 <Cale> It has Integer as an instance
02:45:18 <Jafet> [Flag]
02:45:41 <Jafet> :t (union, intersect, (\\))
02:45:42 <Sgeo> I wouldn't particularly want to manually define the instance
02:45:42 <lambdabot> forall a a1 a2. (Eq a, Eq a1, Eq a2) => ([a] -> [a] -> [a], [a1] -> [a1] -> [a1], [a2] -> [a2] -> [a2])
02:45:49 <Sgeo> Flag?
02:46:02 <Sgeo> Oh, as in, I'd define a type Flag?
02:46:07 <Cale> Sgeo: Presumably Flag is your own type, enumerating the possible flags
02:46:40 <Sgeo> Ah
02:46:53 <Jafet> Most libraries seem to use [Flag].
02:47:06 <Sgeo> Hmm, no way to guarantee that there are no uniques, although I guess there isn't a real problem with that if it does happen
02:47:14 <Cale> [Flag] is convenient. You could, if you were really pedantic, use Set Flag
02:47:53 <Jafet> They're homeomorphic anyway
02:49:15 <Cale> Since you're probably going to iterate over the flags which are set somewhere along the line in order to handle each of them, using a list from the outset is not a terrible plan.
02:50:09 <augur> i dont remember if anyone ever responded
02:50:17 <augur> but
02:50:33 <Cale> If on the other hand, you're going to be checking to see if flags are set more than you are iterating over them, probably a list isn't quite the right thing
02:50:38 <augur> is there a ADT-equivalent/combinatorial-equivalent of curve fitting?
02:51:01 <Cale> augur: I have no idea what such a thing would look like
02:51:08 <augur> Cale: neither do i! :)
02:51:47 <Jafet> This is mathematics! Stop trying to visualize it!
02:52:20 <augur> Cale: i suppose in general, curve fitting for reals is something like fit : [(Real,Real)] -> (Real,Real) -> Bool
02:52:21 <Sgeo> I'm curious what Jafet meant by homeomorphic
02:52:31 <augur> or fit : [(Real,Real)] -> Real -> Real
02:53:00 <augur> i think the former is more general tho
02:53:11 <Cale> Sgeo: Probably homotopic would be a better analogy ;)
02:53:23 <augur> so maybe for more general types, it would be   fit : [a] -> a -> Bool
02:53:29 <augur> i think that would be it, Cale
02:53:43 <Sgeo> I'm interested in math, but don't know much outside what I learned in school
02:53:54 <Sgeo> Or in books I read a very long time ago
02:54:08 <augur> give some set of a's, construct a predicate that can predict that set to be True
02:54:17 <Cale> Sgeo: the idea being that one deforms into the other in some way
02:54:48 <augur> im guessing you'd also want to say something like, the [a] set is representative of some subspace of the space of a's
02:55:12 <augur> like, normal curve fitting is over some contiguous bit of your X axis, and all over the Y axis
02:55:28 <Cale> augur: That sounds more like clustering than curve fitting...
02:55:31 <augur> if you're reqling with functions anyway
02:55:47 <augur> well, but curve fitting is just a clustering problem of some sort
02:56:01 <Jafet> Oh, homeomorphisms are bijective?
02:56:08 <augur> i mean, with curve fittng you're trying to find a function, of course
02:56:16 <Jafet> Alas, my weltanschauung
02:56:17 <augur> but functions are just special relations
02:56:42 <augur> also, Cale, the goal is to find a single "cluster", not multiple ones
02:56:53 <augur> you just want to be able to have holes in the middle :)
02:57:18 <augur> thats my analogy
02:59:43 <Cale> If you were asking for a combinatorial interpretation for the Lagrange interpolating polynomial, say, I might have a better shot at it (though I don't know one off hand, there's obviously-algebraic stuff going on there)
02:59:54 <augur> ya
03:00:26 <augur> no im just trying to think of ways to do some sort of automatic (approximate) model discovery on non-numerical data
03:01:22 <augur> so basically the idea being that you have some trees of some sort, and you know this set has such and such a property, and this set doesnt, whats a way of capturing this
03:01:24 <Cale> Usually the combinatorial interpretations of things come out of the details of the algebra involved, rather than from any actual analytic properties -- even though there's often lots of mimickry of analysis going on.
03:01:48 <Cale> Well...
03:01:58 <Cale> in that case, you might just want to define some sort of metric
03:02:21 <Cale> let's see...
03:02:36 <augur> irene-knapp and i have been thinking about this and the best we could come up with so far is to do some sort of search of the boolean predicates that could hold over structures of the relevant shapes
03:03:34 <lars9> I want to write a simple TCP server, which network IO lib is preferred?
03:03:36 <augur> and to look for the ones that fit all of the known data, and then assign some sort of complexity cost to them so you can determine the "best" ones
03:04:45 <Cale> Define the distance between two tree nodes to be 0 if they are labelled the same, and 1 if they are labelled differently. Define the distance between two trees to be the distance between their root nodes, plus half the sum of the distances between corresponding children.
03:06:32 <Cale> That ought to turn the set of labelled trees into a metric space, and you can measure distances that way :)  Is it the right way? I have no idea, I don't know what your application is :)
03:07:07 <augur> Cale: well, one way to look at it would be "discovering" prolog definitions :p
03:07:17 <augur> that could be a description of the task
03:07:27 <augur> anyway, ill be off for a few hours. afk
03:07:44 <Cale> lars9: "Network", or "Network.Socket" if you need more detail
03:08:02 <Cale> augur: sounds horribly ill-defined ;)
03:08:24 <Cale> http://hackage.haskell.org/package/network
03:09:21 <Cale> @seen tibbe
03:09:21 <preflex>  tibbe was last seen on #ghc 7 days, 15 hours and 22 minutes ago, saying: or I have psychic powers
03:09:21 <lambdabot> Unknown command, try @list
03:10:10 <lars9> Cale: thanks
03:13:35 <brinchj> are there any plans on using an index in Cabal to make cabal list faster?
03:13:50 <lars9> do you find men(thunk) leak hard to debug when programming in haskell?
03:14:46 <brinchj> lars9, if i find thunk leaks hard to locate? definitely
03:17:04 <lars9> it feels like debugging mem leak in C for me
03:21:07 <brinchj> lars9, except in C i can roll out valgrind and have that thing locate them..
03:21:14 <Cale> lars9: They can be tricky, but I think space leaks in any language can be tricky. Use the profiler a lot. GHC has lots of profiling tools, including ones which can make pretty graphs of who is responsible for allocating and retaining memory.
03:22:22 <lars9> Cale: yeah, but the profiling tools' granularity is too big...
03:22:54 <Cale> Usually if I get it down to a particular function, I can look at that and think about how it would evaluate and find the problem.
03:23:02 <lars9> not good for server applications, which needs to run for months
03:25:05 <gregor3005> hi, whats the best way to test the equality of two created data types ?
03:25:11 <gregor3005> eg: data LTree = LNode Integer [LTree] deriving Show
03:25:13 <Cale> Well, there are obvious things you can do to limit the problem in cases like that, like using data structures with strict fields, to ensure that you never store unevaluated expressions in them.
03:25:42 <Cale> gregor3005: use  deriving (Eq, Show) and you'll be able to use == like with anything else
03:26:05 <gregor3005> perfect
03:26:17 <gregor3005> thanks
03:26:33 <Cale> You can also derive Ord to get an ordering
03:27:05 <sbi> You can also derive Cookies
03:27:25 <sbi> :O~
03:27:46 <Cale> (It just gives you the "lexicographic" ordering, considering earlier constructors in the definition to be less than later ones, and then when the constructors match, comparing each of the fields in turn, and the first which doesn't match provides the result.
03:27:48 <Cale> )
03:30:31 <clsmith> hey all. i have a type which would make perfect sense as a Foldable, except that its kind is *, not *->*. i've had a similar situation with monads etc. is there a way to get around this, or failing that, an alternative i could use?
03:31:22 <Cale> Just provide a function turning it into a list of a specific type?
03:31:57 <clsmith> hmm, i suppose that could work
03:32:16 <Jafet> This is a sign from the heavens. You must generalize it.
03:32:16 <Cale> That's all Foldable really is :P
03:33:38 <Jafet> I wonder which type classes will be revamped after Constraint.
03:35:38 <clsmith> Constraint?
03:36:19 <Jafet> @where constraintkind
03:36:20 <lambdabot> I know nothing about constraintkind.
03:36:21 <Jafet> @where constraintkinds
03:36:22 <lambdabot> I know nothing about constraintkinds.
03:36:40 <Jafet> http://blog.omega-prime.co.uk/?p=127
03:36:58 <clsmith> cool, thanks
03:37:42 <Jafet> Well, most likely none of them actually will be. But there will be endless talk about some
03:51:12 <Sgeo> Is there an equivalent of F#'s async workflow for Haskell?
04:07:09 <hiptobecubic> Are monadic functions continuation based functions?
04:11:22 <hpaste> Sebasti0n pasted ‚ÄúAmbiguous Type Variable‚Äù at http://hpaste.org/54530
04:13:14 <Sebasti0n> Hey there, when I try to use that function I get an ambiguous type variable error. Why is it a problem that the compiler can't derive a type? It does not need to know the exact type it only needs to make sure it does not change throughout the program. Or am I missing something?
04:14:52 <Phyx-> it needs to make sure that a and b are actually instances of the classes you declared, so it needs to find evidence of this. what's the type of loadFromXMLFile and Payload?
04:17:52 <hpaste> Sebasti0n pasted ‚ÄúloadFromXmlFile‚Äù at http://hpaste.org/54531
04:18:44 <hpaste> Se pasted ‚ÄúPayload‚Äù at http://hpaste.org/54532
04:19:37 <Sebasti0n> I want the functions to be able to operate on any type which is an instance of ID, Txt and XmlPickler
04:20:43 <Cale> Can you give the exact text of the error message?
04:20:51 <Phyx-> yeah, was just about to ask
04:21:16 <Phyx-> I'm guessing it'll be about the a
04:22:09 <hpaste> Sebasti0n pasted ‚ÄúError Message‚Äù at http://hpaste.org/54533
04:23:08 <Sebasti0n> the error occurs in a do statement where i just do p <- extractFilter "test"
04:23:32 <Cale> right, that's closer to where the error is
04:23:40 <Cale> Sebasti0n: what's the type of p?
04:23:43 <Phyx-> -.-
04:23:58 * Phyx- was wrong and shuts up
04:24:47 <Sebasti0n> well, p should have the type that is the result of extractFilter
04:25:06 <Cale> but extractFilter is polymorphic
04:25:16 <Sebasti0n> yes
04:25:19 <Cale> and p can't have a polymorphic type because it's bound by a lambda
04:25:52 <Cale> More specifically, the problem is about the message in your Payload
04:26:15 <Cale> er, no
04:26:22 <Cale> actually it's the type of the other part
04:27:25 <Sebasti0n> but how can I achieve my goal then?
04:27:35 <Cale> In order to know what implementations of class methods to use, the compiler eventually needs to know what type b satisfies the constraints Txt b, Iden.ID b, and XmlPickler b
04:27:55 <Cale> So you need to say somewhere what type it is that you really intend
04:28:06 <Cale> Or else use p in a way which makes that type unambiguous
04:28:39 <Phyx-> I'm still confused how the compiler knows to satisfy the Real and Fractional constraints
04:28:56 <Phyx-> are those on IVector or something?
04:29:21 <Cale> Phyx-: Probably numeric defaulting
04:30:12 <Cale> So that Nothing becomes a Maybe Integer
04:30:20 <Phyx-> AH
04:30:40 <Cale> but yeah, otherwise that would be ambiguous too
04:31:01 <Cale> (probably, unless p gets used in a way that makes it not ambiguous)
04:31:14 <Cale> Unfortunately, we can't look at the whole program to tell :P
04:31:20 <Phyx-> heheeh
04:31:43 <Sebasti0n> well, I just started with the function in which extractFilter is used
04:32:40 <Sebasti0n> so the ambiguty will probably be eliminated later on
04:32:56 <Sebasti0n> but my goal was actually to not care about the type of the message at all
04:33:07 <Sebasti0n> as long as it satisfies the type classes
04:33:18 <Cale> Well, exactly what parser to use depends on the type of p
04:33:18 <lars9> i want to load an image into a pixel array, manipulate the pixels and write to another image, which lib is preferred?
04:33:37 <Cale> So it has to know which type p has in order to know which value p is.
04:34:33 <Cale> and we can't say "oh, just leave it dependent on the eventual choice of a type", because whenever you have a variable bound by a lambda, it's basically not allowed to have any foralls in its type.
04:34:51 <Cale> (this p is secretly bound by a lambda)
04:35:24 <Cale> lars9: Nothing in particular. Whatever does the job for you. :)
04:35:43 <Sebasti0n> what do you mean by bound by a lambda?
04:36:11 <Jafet> @undo do { p <- foo; bar p; }
04:36:12 <lambdabot> foo >>= \ p -> bar p
04:36:20 <Cale> ^^
04:36:35 <Cale> (\p -> ...) -- this is the construction which brings p into scope
04:36:43 <Cale> Consider something like...
04:37:02 <Cale> > (\f -> (f [1,2,3], f "Hello")) length
04:37:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
04:37:03 <lambdabot>    arising from the literal `1...
04:37:35 <Cale> if f was allowed to have type  forall a. [a] -> Int,  then this program would be fine
04:37:36 <Sebasti0n> ahh, ok
04:37:39 <Cale> but it's not
04:37:47 <Cale> that a has to be some specific a
04:37:59 <Cale> (even if it's a type variable from some outer scope)
04:38:19 <Cale> The lambda isn't allowed to use its parameter at more than one type
04:39:29 <Cale> It is actually possible to make this typecheck anyway, using higher rank types, but it requires explicit type signatures
04:40:02 <etpace> http://hpaste.org/54534 <-- I'm trying to build an expression parser similar to haskell syntax, with space being function application, unfortunately my attempt doesnt really work (term in this example is akin to Var <|> Int), any ideas?
04:40:17 <Cale> > ((\f -> (f [1,2,3], f "Hello")) :: (forall a. [a] -> Int) -> (Int, Int)) length
04:40:18 <lambdabot>   (3,5)
04:40:44 <Cale> (but you really probably don't want that... you just want to say what the heck p is :)
04:41:03 <lars9> > ((\f -> (f [1,2,3], f "Hello"))::forall a . ([a] -> Int) ->(Int, Int)) length
04:41:04 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
04:41:05 <lambdabot>    arising from the literal `1...
04:41:15 <lars9> > ((\f -> (f [1,2,3], f "Hello"))::(forall a . [a] -> Int) ->(Int, Int)) length
04:41:17 <lambdabot>   (3,5)
04:41:26 <etpace> things like "f + 5" parse to just (f 5)
04:42:04 <Phyx-> \(f::forall a. [a] -> Int) ->  (f [1,2,3], f "Hello"))
04:42:08 <Phyx-> > \(f::forall a. [a] -> Int) ->  (f [1,2,3], f "Hello"))
04:42:08 <lambdabot>   <no location info>: parse error on input `)'
04:42:15 <Phyx-> > \(f::forall a. [a] -> Int) ->  (f [1,2,3], f "Hello")
04:42:16 <lambdabot>   Overlapping instances for GHC.Show.Show
04:42:16 <lambdabot>                              ((fora...
04:42:39 <Phyx-> wth
04:42:43 <Cale> etpace: umm... what's the definition of mkArith?
04:42:55 <Cale> oh, it's here
04:43:05 <Sebasti0n> Cale: thank you for the effort.
04:43:29 <Phyx-> oh duh
04:43:39 <Cale> Phyx-: you didn't apply it, and lambdabot unfortunately imports more than one instance of Show for functions :P
04:43:41 <Phyx-> > (\(f::forall a. [a] -> Int) ->  (f [1,2,3], f "Hello")) length
04:43:41 <lambdabot>   (3,5)
04:43:42 <Sebasti0n> Cale: I'll see if I can figure something out otherwise I'll come back
04:43:47 <Phyx-> Cale: yeah, hahaha, i need to go eat
04:44:37 <etpace> Cale: term also recursively calls parens expr as well
04:45:32 <lars9> there is a pragma to remove mono morphic restriction
04:45:39 <Cale> etpace: well, that's really weird
04:46:01 <Cale> lars9: Yeah, that's a different restriction than the one we've been talking about though
04:48:13 <Phyx-> has anyone else notice ghc's helpful suggestions when you misspel a function name these days?
04:48:25 <Phyx-> I was pleasently surprised. or was it there before 7.2
04:48:57 <Cale> The monomorphism restriction is a silly and annoying restriction that says if your definition doesn't have any explicit function arguments (even if it is a function), then any type variables which are constrained by a typeclass can't be generalised -- that is, it's not allowed to be typeclass polymorphic
04:49:16 <lars9> > (\(f::for a . a -> a) -> (f 1, f 'c')) id
04:49:17 <lambdabot>   <no location info>:
04:49:18 <lambdabot>      Illegal symbol '.' in type
04:49:18 <lambdabot>      Perhaps you intend...
04:49:30 <lars9> > (\(f::for a. a -> a) -> (f 1, f 'c')) id
04:49:30 <Cale> This is because some people expect that things which look like definitions of constants should only ever be evaluated once, regardless of their type
04:49:31 <lambdabot>   <no location info>:
04:49:31 <lambdabot>      Illegal symbol '.' in type
04:49:31 <lambdabot>      Perhaps you intend...
04:49:58 <Sebasti0n> Cale: I fixed the error by giving the function an explicit type: extractFilter :: (Real a, Fractional a) => FilePath -> IO [Payload (IVector a) Article]
04:50:34 <Cale> Oh, I should say, a prerequisite to this is not having an explicit type signature, in addition to not having explicit function arguments
04:50:43 <Phyx-> lars9: don't you mean "forall" ?
04:50:46 <Cale> Sebasti0n: that'd do it :)
04:50:57 <Sebasti0n> But now I can only have a payload with articles, but I want to use all types that satisfy the txt, Id, and xmlpickler constraints.
04:51:13 <Sebasti0n> that must be possible somehow?
04:51:16 <Cale> Sebasti0n: well, you can write:
04:51:24 <lars9> Phyx-: yeh thanks
04:52:01 <Cale> extractArticle :: (Real a, Fractional a) => FilePath -> IO [Payload (IVector a) Article]; extractArticle = extractFilter
04:52:12 <Cale> and then use that
04:52:31 <Cale> Or you can just write the type where you use extractFilter
04:53:19 <Cale> p <- extractFilter file :: IO [Payload (IVector Double) Article]
04:53:42 <Sebasti0n> yeah, I thought of that too
04:54:40 <Sebasti0n> maybe it is not a valid comparison because of the stronger type system but thinking in java terms i could define an interface and not worry about the implementation why can't it work like this here?
04:54:56 <Cale> Sebasti0n: It does work like that
04:55:16 <Cale> Sebasti0n: What you're doing is like never declaring the actual implementation to use anywhere in your program
04:55:47 <Sebasti0n> yeah ok, I can see that
04:55:52 <Cale> Sebasti0n: Usually Java will complain at you if you try to use new on an interface, doesn't it?
04:56:07 <Sebasti0n> :)
04:57:48 <Sebasti0n> ok, then I'll try something else
04:58:02 <Cale> Haskell just lets you get away with a little more, in that you'll probably eventually be able to remove that explicit type signature, once you start using p in some way that lets the compiler infer that there are meant to be Article values in there
04:58:40 <Cale> If it can't work out which type of values are in there, it doesn't know what pickler it's meant to use, and so it can't possibly do any work to parse anything out of your file.
04:58:50 * hackagebot zeromq-haskell 0.8 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.8 (ToralfWittner)
04:59:35 <Cale> I recommend just pinning it with an explicit type signature where you use it for now, and removing that later once you actually do something with the articles you parsed
04:59:46 <Sebasti0n> ok
04:59:50 <Phyx-> hmmm need to optimise the algorithm that tracks comments.. I'm creating way to many intermediate strings
05:00:12 <Cale> Phyx-: Try just using Data.Text instead perhaps?
05:01:10 <Sebasti0n> I gave something else a try. I added an explicit signature to loadXmlFile so it loads a list of articles, but I kept the constrained type variable in the function that calls and returns the result of the loadxml file
05:01:19 <Phyx-> Cale: oh I track that part in C#, the ghc lexers don't like unclosed or unopened comments :/
05:02:04 <hpaste> Sebasti0n pasted ‚ÄúError‚Äù at http://hpaste.org/54535
05:02:39 <Cale> Sebasti0n: of course, if you constrain the type of loadXmlFile there, then the function you're writing won't be as polymorphic as you say it is
05:03:05 <Cale> Sebasti0n: just constrain extractFilter where you use it
05:03:09 <Sebasti0n> ok
05:03:15 <Sebasti0n> thanks for all the help
05:04:08 <Cale> "`b' is a rigid type variable" means that b is a type variable which occurs in a programmer-supplied type signature, and so can't ever be replaced with anything specific
05:04:50 <Cale> The compiler worked out that b had to be equal to Article, from the implementation you gave it
05:04:58 <Cale> (because of the other type signature you added)
05:05:25 <Cale> So it was able to show that your function wasn't as polymorphic as claimed.
05:05:59 <Sebasti0n> yeah, that makes sense
06:30:28 <zhulikas> result :: (Ord a) => [[a]] -> a
06:30:40 <zhulikas> how can I include also Num in here?
06:30:41 <zhulikas> Num a
06:30:55 <zhulikas> oh, sorry
06:30:59 <zhulikas> (Ord a, Num a)
06:33:27 <maltem> Cool, I just discovered Martin-Lˆf's notes on type theory, and I never imagined they would be such an interesting read
06:38:03 <ziman> @pl \s t a -> f a s t
06:38:03 <lambdabot> flip . flip f
06:41:32 <Eduard_Munteanu> maltem: hm? Are those online anywhere?
06:42:26 <maltem> Eduard_Munteanu, Wikipedia led me to http://intuitionistic.files.wordpress.com/2010/07/martin-lof-tt.pdf
06:44:19 <maltem> (file is huge because it is apparently a color scanÖ)
06:44:43 <Eduard_Munteanu> Thanks.
07:22:32 <erider> > unwords $ intersperse "(" ["foo", "bar"]
07:22:33 <lambdabot>   "foo ( bar"
07:23:59 <Phyx-> d(+_+)b
07:27:18 <nejucomo> I often seem to want this, but haven't found it via hoogle:  (fromIntegral . toInteger) :: (Integral i, Num n) => i -> n
07:28:07 <rwbarton> @type fromIntegral
07:28:09 <lambdabot> forall a b. (Integral a, Num b) => a -> b
07:28:21 <nejucomo> doh!  I knew I was missing something.
07:28:54 <rwbarton> Hoogle should be able to find it too...
07:29:00 <rwbarton> @hoogle (Integral i, Num n) => i -> n
07:29:01 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:29:01 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
07:29:01 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
07:29:25 <nejucomo> It's the first hit on hoogle and I kept misreading that as :: Num n => Integer -> n
07:37:47 <zhulikas> @src sort
07:37:47 <lambdabot> sort = sortBy compare
07:37:52 <zhulikas> :D
07:37:58 <zhulikas> @src sortBy
07:37:58 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:38:12 <zhulikas> I love the simplicity
07:38:50 <lars9> @src insertBy
07:38:51 <lambdabot> insertBy _   x [] = [x]
07:38:52 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
07:38:52 <lambdabot>                                  GT -> y : insertBy cmp x ys'
07:38:52 <lambdabot>                                  _  -> x : ys
07:39:05 <lars9> oh no
07:39:17 <lars9> this is not List.sort
07:39:25 <rwbarton> This is not the real source of course
07:39:29 <lars9> Data.List.sort uses merge sort
07:40:34 <singpoly1a> I'm getting openBinaryFile: does not exist (No such file or directory) when I try to open "Makefile", but when I do (getDirectoryContents ".") it shows "Makefile" as being there ...
07:41:28 <rwbarton> could it be a broken symbolic link?
07:42:56 <singpoly1a> rwbarton: I can cat the file normally from the shell
07:43:26 <zhulikas> in list ['a'..'z'] how can I find out an index of 'g' ?
07:44:12 <zhulikas> all what comes in mind is length ['a'..'g']
07:44:31 <singpoly1a> rwbarton: oh, wait, I think I've found it...
07:44:36 <fryguybob> > elemIndex 'g' ['a'..'z']
07:44:37 <lambdabot>   Just 6
07:45:14 <erider> > putStrLn $ "(" ++ unwords (map show ["foo", "bar"]) ++ ")"
07:45:16 <lambdabot>   <IO ()>
07:45:19 <lars9> @src elem
07:45:19 <lambdabot> elem x    =  any (== x)
07:45:24 <lars9> @src elemIndex
07:45:24 <lambdabot> elemIndex x     = findIndex (x==)
07:45:33 <zhulikas> thanks
07:45:59 <singpoly1a> yeah, ok.  I'm dumb.  was passing the data in wrong
08:44:39 <parcs> anyone know how one can annotate a type variable with the kind Constraint?
08:45:20 <parcs> the obvious `class Foo (a :: Constraint)` does not work
08:45:40 <parcs> i get Not in scope: type constructor or class `Constraint'
08:46:38 <Minoru> class (Constraint a) => Foo a where ...
08:47:18 <rwbarton> parcs: that's a weird error
08:47:22 <rwbarton> do you have KindSignatures on?
08:48:02 <parcs> rwbarton: yep
08:49:46 <dafis> parcs: {-# LANGUAGE ConstraintKinds #-} ?
08:50:38 <parcs> dafis: yes
08:50:40 <parcs> if i do class Foo a where foo :: a => () then it works
08:51:28 <parcs> i think the problem has to do with the recent PolyKinds extension. the occurence checker is looking for the data type 'Constraint'
08:51:40 <rwbarton> can you write something like  data X (a :: Constraint) = X?
08:51:45 <rwbarton> probably the same problem?
08:51:56 <rwbarton> ah, that seems likely
08:52:44 <parcs> yeah, creating the data type Constraint gives Illegal kind: `Constraint' Perhaps you intended to use -XPolyKinds
09:03:48 <parcs> what is up with the quotation marks around Constraint?
09:04:17 <parcs> grave accent then apostrophe?
09:05:00 <rwbarton> they're TeX-style open and close quotes
09:09:02 <ion> One would think software could use grammatically correct quotation in 2011. :-)
09:09:21 <ion> But as for the kluges, i find 'foo' much better than `foo'
09:10:47 <nazgjunk> ion: quite
09:11:38 <ski> maltem,Eduard_Munteanu : yeah, his concept of "category" there is interesting (no direct connect to CT)
09:11:44 <ski> also e.g. the proof of the Axiom of Choice (cf. "Intensional vs Extensional Choice" by roconnor at <http://r6.ca/blog/20050604T143800Z.html>)
09:13:07 <Eduard_Munteanu> Interesting.
09:13:50 <ski> (well, the proof itself is pretty trivial, what is interesting is that it is provable here, as opposed to in e.g. more traditional intuitionistic systems, where it has to be taken as an axiom (or not))
09:17:28 <juturna> can this be done within the typesystem? I want to do something like: instance Either Int (TVar a) where; put (Left id) = put id; put (Right tvar) = readTVar tvar >>= \v -> put (numericIdentifierOf v)
09:17:28 <ski> maltem,Eduard_Munteanu : you should also take a look at "Programming in Martin-Lˆf's Type Theory - An Introduction" by Bengt Nordstrˆm,Kent Petersson,Jan M. Smith in 1990 at <http://intuitionistic.files.wordpress.com/2010/07/nordstrom-et-al-programming.pdf>, if for nothing else then for the explanation of their concept of "arity" (which could alternatively be called "syntactic types" or "meta-types")
09:17:52 <juturna> instance Binary (Either Int (TVar a)) is what I meant
09:18:15 <Eduard_Munteanu> Yeah, I've been looking for some resources on MLTT, thanks.
09:19:02 <ski> there's also an "Another introduction to Martin-Lˆf's Intuitionistic Type" by S. Valentini in 1996 at <http://intuitionistic.files.wordpress.com/2010/07/valentini-introduction.pdf>, but i haven't read that one
09:25:19 <ski> Eduard_Munteanu : btw, in case you want to look a little at SDG (Synthetic Differnential Geometry, it's about another way to do derivatives and more, using "infinitesimals" in a sense), which i mentioned the other day, you can look at Anders Kock's book "Synthetic Differential Geometry" from 1981 which can be reached at <http://home.imf.au.dk/kock/>
09:26:06 <Eduard_Munteanu> ski: is that the stuff with differential forms, outer products etc.?
09:26:19 <ski> (John Baez talks a little about SDG in his "This Week's Finds in Mathematical Physics 200" at <http://math.ucr.edu/home/baez/week200.html>, but that doesn't show the infinitesimals directly (since it's CT pointless))
09:27:06 <ski> Eduard_Munteanu : the basic idea is to consider the subset of reals `{ x : |R | x^2 = 0 }', this is the object of (first-order) differentials, and we call it `D'
09:27:50 <ski> because equality on reals isn't decidable, we can't prove constructively that this set only contains `0', and this is the start of lots of fun :)
09:28:10 <Eduard_Munteanu> Oh, hm.
09:28:15 <ski> basically, we think of `D' as an infinitesimal piece/environment of the real line, around zero
09:28:43 <ski> now, let's say `f : |R -> |R' is a differentiable function
09:29:30 <ski> then if we map `f' over every element of the subset `D' of `|R', this doesn't just give the point that zero maps to, it also gives the *slope*
09:29:50 <Eduard_Munteanu> (So using a constructive logic, you can't prove x^2 = 0 has a unique real solution? Interesting.)
09:30:16 <ski> we need one basic axiom to make all this fall through
09:30:31 <ski> namely, consider the function defined as
09:30:56 <ski>   lin : |R^2 -> (D -> |R)
09:31:19 <ski>   lin (a,b) = (d |-> a + b*d)
09:32:09 <ddarius> A simple case of microlinearity.
09:32:24 <ski> given the two coefficients, we get a linear function, that maps the infinitesimal `D' piece of `|R' into an infinitesimal piece of a linear function
09:32:52 <ddarius> Er what ski is about to say is a case of microlinearity.
09:32:57 <Eduard_Munteanu> Is that some sort of directional differential?
09:33:23 <ski> the point is, the slope of this linear function is `b'
09:33:35 <ddarius> And we know this by construction.
09:34:12 <Eduard_Munteanu> I see.
09:34:14 <ski> we think of `D' as a just large enough infinitesimal piece of `|R' so that we get a slope, but no second order derivative
09:34:17 <ski> anyway
09:34:29 <ski> the axioms is : `f' is an isomorphism
09:34:38 <ddarius> s/f/lin/
09:34:42 <ski> er, yes
09:34:44 <ski> so
09:34:57 <ski>   f^-1 : (D -> |R) -> |R^2
09:35:07 <ski> is (per axiom) computable
09:35:15 <ski> argh
09:35:18 <ski>   lin^-1 : (D -> |R) -> |R^2
09:35:21 <Eduard_Munteanu> Yeah, I get it :)
09:36:11 <ski> using this definition, given any `f : |R -> |R' here, we can construct `D f' to satisfy
09:36:51 <ski>   forall (x : |R),(d : D). f (x + d) = f x + d * D f x
09:37:29 <ski> and we can then derive the common differentiation rules for product, composition, &c.
09:37:51 <ski> we can also prove a useful cancellation law
09:38:06 <ski> let's say we know `d * a = d * b', where `d : D' and `a,b : |R'
09:38:16 <ski> we'd like to conclude `a = b'
09:38:19 <ddarius> (This axiom is also a special case of the Kock-Lawvere axiom.)
09:38:30 <ski> but in case `d' is zero, this would be invalid
09:38:47 <ski> but we can get something which is in almost as good
09:38:50 <ski> we can prove
09:38:52 <Eduard_Munteanu> Mm, why?
09:39:00 <ddarius> 0*2=0*3
09:39:14 <Eduard_Munteanu> Erm, yeah, nevermind I was looking at it the wrong way.
09:39:20 <ski> Eduard_Munteanu : assume `d = 0', then `d * a = d * b' for all `a',`b', e.g. when `a = 0' and `b = 1'
09:39:25 <ski> anyway
09:39:44 <ski>   forall a,b : |R. (forall d : D. d * a = d * b) => a = b
09:40:05 <ski> so, if we know `d * a = d * b' for *every* `d', it's fine to cancel
09:40:17 <Eduard_Munteanu> Ah.
09:40:20 <ski> note that the only element of `D' we can actually *construct* is zero :)
09:40:47 <ski> still, knowing `d * a = d * b' holds for *every* `d' is more information that it only holding when `d = 0'
09:41:29 <ski> anyway, let's say we have
09:41:43 <ski>   forall x : |R. f x = g x * h x
09:41:50 <ski> and we want to compute `D f'
09:42:07 <ski> we start from knowing
09:42:20 <ski>   forall (x : |R),(d : D). f (x + d) = f x + d * D f x
09:42:39 <ski> pick arbitrary `x' and `d', so
09:42:44 <ski>      f x + d * D f x
09:42:52 <ski>   =  f (x + d)
09:43:07 <ski>   =  g (x + d) * h (x + d)
09:43:10 <ski> so far, so good
09:43:14 <ski> we also know
09:43:23 <ski>   forall (x : |R),(d : D). g (x + d) = g x + d * D g x
09:43:29 <ski>   forall (x : |R),(d : D). h (x + d) = h x + d * D h x
09:43:43 <ski> so, instantiating those with `x' and `d', we continue
09:43:48 <Eduard_Munteanu> Ah.
09:44:01 <ski>   =  (g x + d * D g x) * (h x + d * D h x)
09:44:22 <zhulikas> did anyone solve Project Euler problem nr 17?
09:44:28 <zhulikas> I don't see a mistake in my code for it :|
09:44:43 <ski>   =  (g x * h x) + d * (D g x * h x + g x * D h x) + d^2 * (D g x * D h x)
09:44:46 <ski> but !
09:44:54 <hpaste> zhulikas pasted ‚Äúwrong result‚Äù at http://hpaste.org/54538
09:44:58 <Eduard_Munteanu> d^2 = 0?
09:45:04 <zhulikas> http://projecteuler.net/problem=17
09:45:14 <ski> since `d' is an element of `D', which is defined as `{ x : |R | x^2 = 0 }', so we know `d^2 = 0'
09:45:17 <ski> yes, so
09:45:29 <ski>   =  (g x * h x) + d * (D g x * h x + g x * D h x)
09:45:32 <Eduard_Munteanu> Ah, hm, now the x^2 = 0 requirement makes sense.
09:45:35 <ski>   =  f x + d * (D g x * h x + g x * D h x)
09:45:43 <ddarius> Eduard_Munteanu: Look up the algebra of dual numbers.
09:45:49 <ski> so, summarizing this transitivity chain, we have proved here
09:45:57 * Eduard_Munteanu will
09:46:04 <ski>   f x + d * D f x  =  f x + d * (D g x * h x + g x * D h x)
09:46:15 <ski> now, we cancel the `f x' parts
09:46:22 <ski>   d * D f x  =  d * (D g x * h x + g x * D h x)
09:46:46 <ski> now, we take a step back, realizing `d' was arbitrary (universal introduction) so
09:46:59 <ski>   forall d : D.  d * D f x  =  d * (D g x * h x + g x * D h x)
09:47:11 <ski> and therefore, by the handy cancellation law a bit above
09:47:18 <ski>   D f x  =  D g x * h x + g x * D h x
09:47:21 <ski> and we're done
09:47:26 <Eduard_Munteanu> Yeah.
09:48:16 <Eduard_Munteanu> ski: I wonder, is there a connection between x^2 in `{ x : |R | x^2 = 0 }' and the 2-norm?
09:48:22 <ski> Eduard_Munteanu : anyway, the beginning of Kock's book isn't that hard to understand, so do take a look at that
09:48:39 <Eduard_Munteanu> I will, thanks.
09:48:53 <ddarius> The beginning is quite easy to understand, and then it gets abruptly much harder.
09:49:15 <monochrom> hi, I need haskell homework help.
09:49:19 <monochrom> oops, wrong channel.
09:49:29 <Eduard_Munteanu> Subtle :)
09:50:39 <ddarius> This should be implementable in Haskell.  Certainly, the algebra of dual numbers is trivial to implement in Haskell.
09:51:22 <c_wraith> zhulikas: found your problem
09:51:24 <c_wraith> *Main> processInt 100
09:51:24 <c_wraith> "onehundredand"
09:51:25 <Saizan> sigfpe did so at the type level too, iirc
09:51:41 <zhulikas> ohhh
09:51:42 <zhulikas> thank you
09:51:45 <ddarius> Possibly for differentiating data types.
09:51:50 * Eduard_Munteanu asked because he wondered whether that might go as { (x, y) : |R^2 | x^2 + y^2 = 0 } for a D in R^2
09:51:59 <ddarius> Eduard_Munteanu: That is one of them.
09:54:17 <Eduard_Munteanu> Also IIRC from the other analysis stuff, d /\ d canceled as well.
09:54:39 <Eduard_Munteanu> (if that's a proper connection)
09:54:46 <ski> Eduard_Munteanu : there's probably some connection to such forms, but i'm not very familiar with them
09:54:46 <ddarius> d is not a differential form, it's just a "number."
09:54:49 <KitB> If I have [(a, a, m b)], how can I make this m [(a,a,b)] ?
09:54:54 <KitB> (in some easy way)
09:55:09 <rwbarton> the "dx" from analysis is a function on D
09:55:19 <ski> (yes, `d' in SDG is "just" a "number")
09:56:18 <ski> ddarius : "This" being a type like `Dif a' or ?
09:56:40 <Eduard_Munteanu> Yeah, IIRC, df(x) : R^n -> R.
09:57:23 <ddarius> Eduard_Munteanu: df(x) is, in particular, a (multi)linear function into R.
09:58:07 <ddarius> ski: A type for which a suitably broad (but possibly not complete) version of the Kock-Lawvere axiom holds.
09:58:23 <ski> ok
09:59:08 * ski wants to figure out some sense of things like `d x^3 / d x^2'
10:00:26 <Eduard_Munteanu> The differential of x^3 over the differential of x^2?
10:00:35 <ski> yeah :)
10:00:47 <rwbarton> how about http://en.wikipedia.org/wiki/K%C3%A4hler_differential
10:00:50 <ddarius> KitB: mapM
10:01:37 <ski> i think in general, in `d y / d x', if `x' doesn't functionally determine `y', you need to know both the value of `x' and the value of `y' (such that the requisite relation holds) to be able to compute `d y / d x'
10:02:14 <Eduard_Munteanu> Wouldn't that be, for x : R, (3 x^2 dx)  /  (2 x dx) = 3x/2   ? Or are you looking for some interpretation?
10:03:41 <Eduard_Munteanu> Actually... I'm not 100% that simplification of dx / dx flies.
10:03:43 <ski> i think in general, using Leibniz notation like this, the expression doesn't stand for a unique value (barring we do something like fixing `y' as well, above)
10:03:48 <Eduard_Munteanu> *100% sure
10:05:50 <ddarius> Eduard_Munteanu: http://geocalc.clas.asu.edu/pdf/DIF_FORM.pdf
10:06:00 <ski> so i'm pondering using a theory of "multi-valued expressions" to handle this
10:06:20 <ski> (i have some ideas for how to make that useful, but i'm not sure they work, yet)
10:06:48 <ehuber> hello once again. has anyone had luck in using any of the available SSL libraries to wrap a socket?
10:07:24 <ehuber> i am using hsOpenSSL, but got a very cryptic "user error" and the program crashed ("user error" is not mentioned anywhere in the hsOpenSSL source)
10:11:42 <monochrom> the "user error" message could also be caused by a call to userError
10:12:30 <rwbarton> ski: i'd say that dy/dx makes sense as a function on the (smooth 1-dimensional) variety on which x and y are functions, at least where dx does not vanish of course
10:12:46 <ski> Eduard_Munteanu : there's also some kind of concept of boundary of a manifold, such that `d (X * Y) = d X * Y + X * d Y', where `*' is a "cartesian product", and `+' is union
10:13:43 <ehuber> no such call in the module source, unfortunately. i think i might just use stunnel :<
10:14:03 <ski> (and `d (d X) = 0', the empty manifold)
10:15:28 <ski> rwbarton : ok. i need to understand that too, but i sounds like something more indirect than what i'm after
10:15:49 <Eduard_Munteanu> Interesting. That'd beginning to sound a bit CT-ish considering how it's abusing notions of product and addition (coproduct), notationally :)
10:16:42 <ski> (i have no problem understanding `d ..x.. / d x', or even `d y / d x', if `y' is a variable, dependent on the ("independent") variable `x')
10:16:48 <rwbarton> this synthetic geometry is very similar to what you can do with scheme theory (in the end, it is essentially the same)
10:18:07 <ski> (basically, the former means `D (x |-> ..x..) x', and the latter means `D (x |-> y) x', where `y' implicitly depends on `x' -- *dynamic scope* (cf. implicit parameters in GHC))
10:20:26 <ddarius> That the boundary of the boundary is the empty manifold is why d /\ d = 0.
10:20:49 <maltem> ski (I'm a little late to answer): Thanks for the links - actually SDG is what got me really interested in intuitionistic logic :)
10:21:03 <ski> hehe
10:22:12 <hpaste> dufflebunk pasted ‚ÄúByteString type mismatch‚Äù at http://hpaste.org/54539
10:22:31 <dufflebunk> rwbarton, when you used mmap did you run into the above problem?
10:23:04 <rwbarton> dufflebunk: oh, you actually don't want the lazy module in bytestring-mmap
10:23:14 * Eduard_Munteanu idly wonders if a general p-norm would make sense in that definition of D. Presumably for p > 2, weird stuff like (fg)' /= f'g + fg' happens.
10:23:21 <dufflebunk> I'm trying to use the general Data.ByteString functions, but mmap unsafeMMapFile returns a Data.ByteString.Lazy.Internal.ByteString
10:23:38 <monochrom> well yeah, there are two ByteString's
10:23:41 <rwbarton> just import System.IO.Posix.MMap, that will mmap the whole file
10:24:07 <ddarius> Eduard_Munteanu: There are many, many Ds.
10:24:08 <rwbarton> unless the file is too large to fit in your address space
10:24:41 <ddarius> If you assert d^3 = 0, you will not get the product rule because you are now letting first and second derivatives exist.
10:24:53 <Eduard_Munteanu> TBH, just now I see how the 2-norm is so fundamental.
10:25:21 <Eduard_Munteanu> (well, in math)
10:25:44 <rwbarton> This isn't really about the 2-norm
10:25:50 * ddarius agrees.
10:26:18 <rwbarton> after all, in one dimension, we only have one norm up to rescaling, but there are many "D"'s -- { x | x^n = 0 } for all n >= 1 are different things.
10:26:19 <Eduard_Munteanu> Oh, alright, I thought d^2 = 0 is a way to say norm_2(d) = 0.
10:26:41 <Eduard_Munteanu> (which would kinda make sense for D)
10:26:49 <ddarius> Eduard_Munteanu: The "infinitesimal circle" that you described above, is one 2-dimensional D, but not the most fundamental or "smallest."
10:26:56 <ddarius> Eduard_Munteanu: For example, it says nothing about xy.
10:27:53 <Eduard_Munteanu> (Actually, same thing for n-dimensional, but 2-norm, I guess)
10:30:14 <dufflebunk> rwbarton, Unfortunately, it seems that Data.Binary expects a lazy bytestring
10:31:06 <rwbarton> you can convert the strict bytestring to a lazy one to pass it to binary
10:31:32 <rwbarton> import qualified Data.ByteString.Lazy as BL;   BL.fromChunks [s]  --- iirc
10:31:54 <dufflebunk> Yeah, that'll work thanks for the pointer
10:31:58 <rwbarton> Or, I think the cereal package has an identical API to binary except it works on strict bytestrings
10:32:15 <monochrom> is there a reason not to use Data.ByteString.Lazy and System.IO.Posix.MMap.Lazy ?
10:32:39 <rwbarton> you can't do constant-time seeks on a lazy bytestring
10:33:04 <rwbarton> I'm having a pretty hard time coming up with a use for System.IO.Posix.MMap.Lazy actually...
10:33:41 <rwbarton> perhaps it saves a copy over reading the file normally
10:35:07 * dufflebunk goes for breakfast
10:35:18 <Eduard_Munteanu> What's lazy about a mmap? Or is this about something that sits on top the mmap()?
10:35:23 <rwbarton> it sits on top
10:35:30 <Eduard_Munteanu> (Erm, or should I say, what's not lazy about it.)
10:36:07 <rwbarton> but somewhat awkwardly imo.  It builds a lazy bytestring whose chunks are mmap'ed chunks of the file, and the spine is itself lazy via unsafeInterleaveIO
10:36:36 <ddarius> The docs say the spine is strict.
10:36:45 <Eduard_Munteanu> Looks like one would want something like an array if they mmap.
10:36:46 <rwbarton> oh
10:37:05 <rwbarton> aha, yes it is
10:37:11 <rwbarton> I misremembered
10:37:32 <ddarius> Eduard_Munteanu: That's what the strict ByteString interface provides which is the one System.IO.Posix.MMap exports.
10:37:59 <Eduard_Munteanu> Oh, right, I guess it's one big chunk, no?
10:40:08 <Eduard_Munteanu> Then I guess a lazy mmap lets you figure page boundaries. Dunno, maybe that's one reason.
10:42:54 <Eduard_Munteanu> (e.g. if may prefer to work with pages you already touched)
10:43:08 <Eduard_Munteanu> s/if/you/
10:44:11 <xni> WINDOW
10:44:39 * ddarius is not sure what Eduard_Munteanu is envisioning as bytestrings are immutable.
10:45:51 <carpi> are there any documentaries about functional languages.. not instructional..but more like expounding on the wonders of functional programming and the benefits it brings?
10:46:05 <ddarius> @where whyfp
10:46:05 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
10:46:42 <Eduard_Munteanu> ddarius: I'm not sure how exactly it helps, but it should be the same thing if you read 1 or 1000 bytes of the same page, as far as disk I/O is concerned, for example. Assuming PAGE_SIZE = 4096
10:49:48 <Eelis> i just read about Safe Haskell in the GHC manual. is this envisioned to become a big thing in Haskell?
10:50:18 <Eelis> where everybody tries to get as much of their code marked "Safe" and/or "Trustworthy"
10:50:21 <ddarius> Eelis: I doubt most people are envisioning anything about it one way or the other.
10:51:00 <Eelis> but surely whoever designed and implemented it must have had some ideas about intended use
10:52:31 <ddarius> I believe the intended use is things like mueval which need to be able to execute arbitrary Haskell and also some auditing applications.
10:53:18 <Eelis> so for a regular library, there's not much value added by using Safe Haskell?
10:53:55 <ddarius> Eelis: There is an entire section on intended uses on the SafeHaskell page.
10:54:23 <Eelis> sure, but that doesn't really capture the community inertia that this scheme has
10:54:59 <ddarius> Eelis: It's the person who's building (or really running) the executable that really cares.
10:55:18 <ddarius> And even then, they only care if they are getting "untrusted" code.
10:56:04 <ddarius> Eelis: Nothing will need to be done to most typical Haskell code for it to successfully compile with -XSafe and its the person using your library that would be doing it.
10:56:37 <Eelis> wouldn't that require changing the library and reinstalling it with cabal?
10:57:16 <ddarius> No.
10:57:27 <Eelis> oh, interesting
10:58:05 <Eelis> but if the library has already been compiled and installed without -XSafe (since that's the default), the object files don't have the flag that says "this module is safe", do they?
10:58:14 <Eelis> so you'd need to recompile
10:58:15 <Eelis> and reinstall
10:58:27 <alistra> hey is there some way to print a record nicely (each level deeper is indented more) when using deriving Show?
11:01:56 <ddarius> Eelis: Firstly, GHC will infer safety, whether or not you compile with -XSafe.  Also, the check is a compile-time check; the object files should be otherwise identical.
11:02:41 <Eelis> ah, i didn't know about the infer part! so -XSafe is really only about making sure you get errors if you accidentally write unsafe code?
11:02:42 <ddarius> And, at any rate, you wouldn't need to modify the library's code unless it turned out it wasn't safe.
11:03:19 <Eelis> the Safe Haskell section in the manual never mentions inference :/
11:03:34 <ddarius> Eelis: That's one application, but it's about untrusted code.  I can maliciously give you unsafe code.
11:03:42 <ddarius> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell
11:04:15 <Eelis> ah, that mentions the inference, good
11:04:26 <Eelis> thanks
11:05:09 <Eelis> i guess i should get used to not relying on the GHC manual to figure out how GHC features work
11:05:39 <zhulikas> is there a function which takes a number and returns a list of it's digits?
11:05:45 <zhulikas> 123 -> [1,2,3]
11:06:44 <ddarius> Eelis: The GHC manual describes how things work for that version of GHC and only for the stuff they've committed to at that point.
11:07:11 <ddarius> > map digitToInt . show $ 123
11:07:13 <lambdabot>   [1,2,3]
11:07:42 <Eelis> ddarius: well, in this case the GHC manual apparently does /not/ describe how all the things work that are implemented in the version of GHC
11:08:04 <ddarius> Eelis: Try reading my entire sentence.
11:08:20 <Eelis> or are you trying to say that the wiki documents unofficial features?
11:08:32 <ddarius> That wiki page is the GHC developer's wiki.
11:08:50 <Eelis> heh, this is such a mess
11:13:58 <Igloo> Note that the Safe Haskell design has changed between 7.2 and 7.3
11:20:27 <dafis> Igloo: How, if at all, can I build a GHC with the in-tree gmp while I have a libgmp in /usr/lib64?
11:22:23 <irene-knapp> ah hi dafis
11:22:45 <dafis> hi irene-knapp, any news?
11:22:46 <irene-knapp> well, I think you can mess with the autoconf layer somehow
11:22:58 <irene-knapp> yeah, I actually found a related misbehavior that doesn't involve GMP at all!
11:23:10 <irene-knapp> putStrLn $ show (2 * 5 :: Int)
11:23:23 <irene-knapp> there is a built-in rule that's supposed to replace GHC.Num.* with a primop, right
11:23:26 <irene-knapp> but it doesn't fire
11:23:31 <cgroza> @type (*>)
11:23:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
11:23:34 <irene-knapp> therefore the constant folding also doesn't fire
11:23:41 <dafis> irene-knapp: tried that, the in-tree gmp was built, but the linker tries to use the /usr/lib64 one
11:23:46 <irene-knapp> hmmmm okay, weird
11:25:26 <Igloo> dafis: that's not designed to be possible
11:26:07 <dafis> Igloo: is it designed to be impossible?
11:26:14 <irene-knapp> haha hm
11:26:30 <irene-knapp> well, I don't think you'll reproduce my failures that way, really
11:26:44 <irene-knapp> now that I know (from the example I gave above, and from the testsuite output) that it's not just a GMP problem
11:26:56 <dafis> irene-knapp: I didn't expect to, really, but I was curious
11:26:58 <irene-knapp> it's gotta be some sort of Lion or gcc problem or something
11:26:59 * irene-knapp nods
11:27:54 <irene-knapp> dafis I do appreciate your help thus far, and I'm going to continue informing you of my progress if that's okay, as it gives me someplace to vent haha
11:27:58 <irene-knapp> :
11:27:58 <irene-knapp> dafis:
11:28:21 <dafis> irene-knapp: sure, keep me up to date
11:28:23 <Igloo> dafis: Well, it's certainly possible if you're willing to alter the build system  :-)
11:28:23 <irene-knapp> okay :)
11:28:31 <Igloo> I have no idea how easy it would be
11:28:49 <dafis> Too uneasy for this weekend, anyway
11:33:02 <irene-knapp> Igloo: got a moment?  here's my testsuite failures (on stage1), any idea which of these is the most crucial to investigate?
11:33:06 <irene-knapp> http://hpaste.org/54514
11:36:28 <irene-knapp> ooh, linker assertion failure!
11:36:32 <irene-knapp> from driver/5313
11:41:06 <dafis> irene-knapp: the bad exit code from arith013 might be interesting too
11:41:24 <irene-knapp> hmm
11:41:32 <roconnor> Cale: I'm not sure how much you are into dependent type theory but here is my semi-plethory operations on containers: http://r6research.livejournal.com/25428.html
11:41:43 <irene-knapp> well, the exit code of that one is 99, there's no text on stdout or stderr
11:42:00 <dafis> irene-knapp: cd testsuite; make TEST=arith013
11:42:05 <irene-knapp> ah okay
11:43:54 <irene-knapp> hm, it's taking some time to run
11:44:16 <dafis> irene-knapp: that doesn't clean up afterwards, so you can inspect arith013.comp.stderr etc in tests/numeric/should_run
11:44:21 <irene-knapp> ah, gotcha, cool
11:44:33 <Igloo> exit code 99 means it timed out, so probably an infinite loop
11:45:00 <Igloo> Re which tests, the smaller the better, generally. Also, you'll want to ignore any that use TH or ghci
11:45:12 <irene-knapp> hmmm yes
11:45:19 <FUZxxl> Does anyone knows J over here?
11:45:55 <FUZxxl> Or is there a J channel on freenode?
11:46:15 <irene-knapp> I've never even heard of J.  Is that one of those numeric-processing languages?
11:46:38 <irene-knapp> http://www.google.com/search?q=j+language+freenode
11:47:02 <dafis> irene-knapp: it's APL with ASCII symbols
11:47:06 <irene-knapp> ah okay haha
11:47:11 <dafis> (not really)
11:47:37 <FUZxxl> dafis: I try to learn J
11:47:56 <dafis> FUZxxl: good luck
11:48:10 <FUZxxl> But I always get headache after 30 minutes of staring at the tutorial...
11:48:13 <FUZxxl> Is that normal?
11:48:23 <dafis> FUZxxl: 30 minutes is long
11:48:35 <dafis> I never made it past 15
11:48:39 <DanBurton> J has been described to me as an explosion at the emoticon factory
11:48:46 <FUZxxl> I wanted to try APL in the first place, but I failed to find an implementation that's both free and available for Linux
11:48:54 <dafis> DanBurton: that's apt
11:48:54 <FUZxxl> ?!?
11:48:59 <FUZxxl> Well, J is simple...
11:49:11 <FUZxxl> +/%# is the average of a list
11:49:19 <DanBurton> ...wat
11:49:31 <FUZxxl> # is the number of elements in a list
11:49:39 <FUZxxl> + is add
11:49:49 <FUZxxl>  / is fold with
11:49:56 <FUZxxl> so +/ is sum
11:49:59 <FUZxxl> % is division
11:50:24 <FUZxxl> +/%# is as if one would apply the S combinator
11:50:28 <FUZxxl> So basically
11:50:33 <irene-knapp> of course, this depends on hidden precedence rules to work properly
11:50:34 <FUZxxl> (in Haskell syntax)
11:50:49 <FUZxxl> \x -> sum x / length x
11:51:02 <FUZxxl> irene-knapp: Yes. J has none
11:51:14 <FUZxxl> Evaluation takes place from right to left
11:51:24 <irene-knapp> that can't be true - it knows to treat it as (+ / %) $ and not + (/ % #)
11:51:49 <FUZxxl> The first thing is # -  a function
11:51:58 <FUZxxl> the second one is %, another one.
11:52:05 <FUZxxl> So it's an infix application
11:52:11 <FUZxxl> (+/) % (#)
11:52:37 <irene-knapp> yes, I see that.  except it's actually more like \a -> ((+/) a) % (# a)
11:52:49 <FUZxxl> yeah...
11:52:53 <irene-knapp> I don't think these rules are as consistent and complete as you think they are
11:52:54 <FUZxxl> That's the magic behind
11:53:19 <FUZxxl> I don't know yet...
11:53:43 <FUZxxl> I have to take some pills and continue with the tutorial...
11:53:46 <irene-knapp> also the fold is either fold1 (so it won't work on empty lists) or implicitly has a 0 because it special-cases for when + is its operator
11:54:02 <irene-knapp> either way, what do you do if that turns out not to be what you want in a given situation?
11:54:18 <rwbarton> can I write my own functions like / in J?
11:54:31 <irene-knapp> I only know what you've told me about this language, and I already can tell you there is zero reason to learn it, haha
11:54:51 <dafis> irene-knapp: it's absolutely amazing for code golf
11:55:02 <irene-knapp> haha I'm sure it is!
11:55:29 <FUZxxl> dafis: That was my initial reason, too
11:55:31 <dafis> it is, however more unreadable than bad perl
11:55:47 <irene-knapp> really?  because Perl can, like, base64-encode portions of the code :)
11:56:22 <FUZxxl> irene-knapp: AFAIK it has system, but I have yet to understand it.
11:56:29 <irene-knapp> heh, okay
11:56:42 <FUZxxl> And there are no special cases.
11:56:50 <irene-knapp> I'm not really understanding why you want to learn this language
11:57:17 <FUZxxl> But the syntax is confusing and each symbol is overloaded usually about three times (with completely unrelated stuff)
11:57:34 <FUZxxl> +. is the logical or
11:58:03 <FUZxxl> if used with numbers different from 0 and 1, it is the gcd function instead
11:58:15 <rwbarton> not lcm?
11:58:23 <DanBurton> irene-knapp: why else would you learn a programming language? fun!
11:58:24 <rwbarton> that would at least make a little sense
11:58:34 <carpi> could someone please tell me the use of the function "id"? what use could it possibly have if it returns whatever it is given?
11:58:39 <irene-knapp> DanBurton: haha, yes, yes, but geeze!
11:58:45 <rwbarton> carpi: you can pass it to other functions
11:58:46 <irene-knapp> carpi: for passing to higher-order functions
11:59:00 <FUZxxl> rwbarton: Well, lcm is *. (logical and)
11:59:11 <rwbarton> that is... backwards in my world
11:59:14 <carpi> rwbarton: you mean during fucntion composition for example?
11:59:23 <DanBurton> @src join
11:59:24 <lambdabot> join x =  x >>= id
11:59:26 <FUZxxl> carpi yes
11:59:27 <rwbarton> here's an example
11:59:39 <rwbarton> > length $ filter id [True, True, False, True] -- count the number of Trues
11:59:41 <lambdabot>   3
11:59:46 <FUZxxl> carpi: You can also use it, if you don't need certain functionality.
11:59:49 <parcs> > length `id` [1..5]
11:59:49 <lambdabot>   5
12:00:11 <FUZxxl> ($) is just id
12:00:16 <parcs> :t const id
12:00:17 <lambdabot> forall a b. b -> a -> a
12:00:26 <DanBurton> the utility of "id" is similar to the utlility of the Identity monad
12:00:35 <DanBurton> but for functions
12:00:54 <FUZxxl> irene-knapp: J is perfect for golf. /:~ is sorting
12:00:57 <rwbarton> FUZxxl: so is +. the application of . to +, or is it lexed as a single token somehow
12:01:27 <FUZxxl> rwbarton: +. is one token (If you have J installed, type ;: 'expression' to see what the parser sees)
12:01:31 <DanBurton> @where J
12:01:31 <lambdabot> I know nothing about j.
12:01:41 <DanBurton> @google j programming language
12:01:42 <carpi> DanBurton: if im grappling with the "function" called id .. it is unlikely i would know about the Identity monad. but thanks
12:01:43 <lambdabot> http://www.jsoftware.com/
12:01:43 <lambdabot> Title: J Home
12:01:45 <FUZxxl> http://www.jsoftware.com
12:01:55 <FUZxxl> It's FLOSS
12:01:59 <carpi> thx.. now i think i got it.. ill try an example
12:02:00 <FUZxxl> (GPL3)
12:02:08 <DanBurton> carpi: yes I suppose. But you will know soon enough >xD
12:02:36 <FUZxxl> Basically, symbols are all single tokens except . and :
12:02:38 <carpi> DanBurton: hope so. : ) just started a week ago. been having mindgasms ever since :)
12:02:41 <FUZxxl> they can augment other tokens
12:02:48 <DanBurton> @where+ J The J Programming language: http://www.jsoftware.com
12:02:48 <lambdabot> It is forever etched in my memory.
12:02:52 <FUZxxl> yielding completely unrelated verbs
12:03:02 <FUZxxl> @where J
12:03:03 <lambdabot> The J Programming language: http://www.jsoftware.com
12:03:30 <FUZxxl> carpi: If you reached enlightment in Haskell, try J or APL next
12:04:00 <DanBurton> I wonder, does there exist a Haskell implementation of J?
12:04:09 <JoeyA> What's an efficient to generate a value such that a == b will return true only if a and b were created with the same call to some action?  I'm thinking of doing: x <- newIORef ()
12:04:09 <FUZxxl> I don't know.
12:04:16 <FUZxxl> Would be a funny project though
12:04:19 <carpi> FUZxxl: why? are they better than haskell? at this point I really want haskell to be better than everything else..
12:04:38 <DanBurton> wouldn't be too hard I would imagine. Lots of J operations seem to translate straight into Haskell
12:04:40 <irene-knapp> JoeyA: I always just use a field that holds a global counter
12:04:42 <FUZxxl> carpi: Different paradigm and equally mind-convoluting
12:05:01 <JoeyA> irene-knapp: Then you have to set up the global counter somewhere :(
12:05:03 <FUZxxl> DanBurton: Haskell is functional, J is what I call "tensor-based"
12:05:04 <irene-knapp> true
12:05:17 <carpi> FUZxxl: but can they be used to write proper full blow applications like we can in haskel?
12:05:20 <FUZxxl> JoeyA: Stable names, anyone?
12:05:25 <DanBurton> maybe we could create a J-to-Haskell translation layer so that J code could be compiled and optimized with GHC
12:05:27 <FUZxxl> carpi: Yes.
12:05:38 <FUZxxl> DanBurton: J is interpreted.
12:05:55 <FUZxxl> It's difficult to compile as it has not that much of a type system.
12:06:18 <DanBurton> one could simply use type inference and infer the most polymorphic types, no?
12:06:21 <FUZxxl> J knows basically only basic values (such as FP, int, bool, char) and tensors of them
12:06:35 <FUZxxl> DanBurton: Difficult...
12:06:49 <FUZxxl> I am new to J, too
12:07:00 <FUZxxl> You should really read there introduction.
12:07:08 <FUZxxl> http://www.jsoftware.com/help/primer/contents.htm
12:07:16 <FUZxxl> You should really read their introduction.
12:07:31 <FUZxxl> DanBurton: Do you know APL?
12:07:51 <FUZxxl> BTW, it seems that there is a .deb of a recent J
12:07:53 <DanBurton> nope
12:07:56 <osaunders> Does anyone know if there‚Äôs an existing library that provides an indexed set?
12:08:02 <DanBurton> I don't know APL, should I?
12:08:07 <tgeeky> osaunders: yes
12:08:14 <tgeeky> HiggsSet does multiple indexes of a set
12:08:15 <rwbarton> Did they really need to format this document with one sentence per html page?
12:08:47 <FUZxxl> DanBurton: APL is the predecessor of J. It's a language from the eighties
12:08:57 <tgeeky> osaunders: there surely is at least one (single-) indexed set
12:09:07 <FUZxxl> It has an own character set, as bandwidth was a matter that time
12:09:41 <rwbarton> J seems to be full of entirely the wrong sort of "cleverness" for my taste
12:09:57 <rwbarton> but, to each his own I suppose
12:10:15 <FUZxxl> http://ngn.github.com/apl/web/index.html
12:10:27 <DanBurton> on a very vaguely related note, I've been wondering: are there any "learn scala" books that target people with significant Haskell experience?
12:10:29 <FUZxxl> rwbarton: J is interesting...
12:10:35 <osaunders> tgeeky: HiggsSet didn‚Äôt inspire me with confidence because the author spells indices wrong repeatedly in the synopsis but I‚Äôll take a look, thanks
12:10:53 <FUZxxl> DanBurton: People with significant knowledge in Haskell tend to consider Scala as a bad dream, I think
12:11:15 <tgeeky> osaunders: it may be that English isn't his/her first language or something
12:11:25 <osaunders> tgeeky: Yeah, probably
12:11:51 <FUZxxl> (link above: Javascript APL implementation)
12:11:59 <tgeeky> osaunders: thinking about it, I'll bet the indexed set is IxSet
12:12:12 <tgeeky> (or IntSet)
12:12:39 <DanBurton> FUZxxl: That's what I thought, but lately I've started getting the hang of some of Scala's collection libraries and ridiculous type annotations, and I'm thinking it's not so bad now
12:13:09 <FUZxxl> :D
12:13:30 <rwbarton> "The 3 indicates that you are defining a verb and the 0 indicates that the definition is in the subsequent input lines."
12:13:39 <rwbarton> has anyone created a version of J where you don't have to deal with this nonsense?
12:13:43 <FUZxxl> rwbarton: You can also type verb define instead
12:13:45 <igstan> DanBurton: there's also this https://github.com/jrwest/learn_you_a_scalaz
12:14:17 <rwbarton> that doesn't help me too much when I'm trying to read about J
12:14:28 <FUZxxl> You define using =.
12:14:29 <rwbarton> rather than write a program in it
12:14:54 <FUZxxl> For instance, avg=.+/%# would define an average function
12:15:02 <osaunders> tgeeky: Yeah
12:15:27 <FUZxxl> x : y defines y of type x
12:15:43 <FUZxxl> 0 as y indicates that the definition follows on th next lines
12:15:51 <FUZxxl> 3 is the type of a verb
12:15:56 <rwbarton> surely if there were interesting ideas in J someone would have gotten around to presenting them in a humane way :P
12:15:57 <FUZxxl> rwbarton: Any questions?
12:16:05 <rwbarton> personally I can't be bothered to wade throug this
12:16:10 <FUZxxl> What's so difficult about
12:16:16 <osaunders> rwbarton: That‚Äôs not true, there are interesting ideas in J
12:16:16 <FUZxxl> average =. define verb
12:16:39 <FUZxxl> length =. #x
12:16:42 <rwbarton> osaunders: think of it as a paper with interesting ideas but written horribly
12:16:47 <FUZxxl> sum =. +/ x
12:17:00 <FUZxxl> sum % length
12:17:00 <FUZxxl> )
12:17:01 <rwbarton> people are not going to put in the effort to read it
12:17:26 <FUZxxl> rwbarton: J is similar to APL and Perl a write-only language
12:17:40 <FUZxxl> "Write once, get headache reading it"
12:17:58 <DanBurton> (insert Haskell preachiness here)
12:18:09 * byorgey had fun learning J once upon a time.
12:18:11 <parcs> DanBurton: at least that would be on topic
12:18:19 <DanBurton> parcs: =)
12:18:25 <FUZxxl> byorgey: Do you still remember
12:18:29 <FUZxxl> parcs: xD
12:18:33 <skchrko> DanBurton, Scala by Example, maybe. It is written by Odersky and is distributed for free. But some moments may still be unclear from it.
12:18:35 <FUZxxl> any of that J?
12:18:37 <osaunders> rwbarton: It‚Äôs not written that horribly though
12:18:41 <byorgey> FUZxxl: not really
12:18:43 <osaunders> It‚Äôs just very terse
12:18:52 <JoeyA> I imagine a language like J would be useful if I needed to calculate something quickly, but didn't care much about reusing the program.
12:18:55 <byorgey> FUZxxl: it would probably come back pretty quickly though
12:18:57 <osaunders> It‚Äôs no different, in that sense, to mathematical notation
12:19:01 <ddarius> J is actually pretty readable once you get used to it.  But it is very easy to get unused to it again.
12:19:09 <rwbarton> mathematicians don't write '3' to mean 'function' or whatever.
12:19:16 <ddarius> J is a rather fun language to learn.
12:19:16 * osaunders agrees with ddarius 
12:19:20 <FUZxxl> ddarius: Same for APL, although their notation is more mnemnoric
12:19:25 <DanBurton> ddarius: that seems to be true of basically any proramming language
12:19:34 <DanBurton> at least the "readable once you get used to it" part
12:20:03 <FUZxxl> Look: In APL, ‚äñ rotates over the first axis, ‚åΩ over the secons
12:20:19 <FUZxxl> In J it's <list of axis> |.
12:20:24 <ijt> Quick question about using Persistent in Yesod...
12:20:27 <ddarius> At any rate, the rules for parsing J are very simple except for one minor caveat.
12:20:28 <FUZxxl> |. rotates over all axis
12:20:36 <FUZxxl> ddarius: Which?
12:20:44 <FUZxxl> ijt: Don't ask, ask!
12:20:57 <rwbarton> Even the heading of this documentation ">>  <<  Ndx  Usr  Pri  JfC  LJ  Phr  Dic  Rel  Voc  !:  wd  Help  Primer" is full of the kind of "cleverness" which I find so distasteful
12:21:00 <osaunders> rwbarton: It‚Äôs not really our job to convince you to be interested in something you‚Äôre not interested in. But I‚Äôd suggest the fact we‚Äôre even still talking about it suggests a part of you feels like you‚Äôre missing something. You can only respond in one of two ways: forget about it, or look at it deeper. It‚Äôs up to you which.
12:21:11 <ijt> I'm trying to get the count like this: num <- runDB $ count [UrlImageUrl !=. ""]
12:21:12 <rwbarton> hey, I have nothing at stake here
12:21:14 <ddarius> rwbarton: None of that is "cleverness."
12:21:19 <ijt> But it always comes back as 0.
12:21:28 <FUZxxl> ijt: hm...
12:21:34 <ijt> ... even though there are plenty of rows.
12:21:37 <FUZxxl> I don't know yesod
12:22:05 <ijt> Apparently I don't either.
12:22:05 <parcs> ijt: #yesod might be more helpful
12:22:10 <ijt> Ah, thank you.
12:22:21 <ddarius> rwbarton: And there is tons of craziness in the J "standard library" that, independent of the language itself, makes it not very usable for general application development.
12:22:25 <ddarius> (in my opinion)
12:22:37 <ddarius> Most of it is fairly easily surmountable though.
12:23:06 <FUZxxl> ddarius: What do you consider the "standard library"?
12:23:31 <rwbarton> osaunders: Why can't I wish someone who already understood whatever the interesting bits in J are would come up with a language that doesn't use '+.' for gcd and 'Ndx' for index? That seems totally natural to me.
12:23:58 <ddarius> FUZxxl: The symbols defined in the J vocabulary.
12:24:03 <FUZxxl> yeah...
12:24:12 <FUZxxl> They are pretty meaningfull actually.
12:24:25 <FUZxxl> What part of their vocabulary is strange for you?
12:24:30 <ddarius> rwbarton: A lot of times there is a hidden unity to the choices J makes, but there are definitely completely arbitrary things.
12:24:45 <ddarius> FUZxxl: How 'bout how you define a (non tacit) verb.
12:24:55 <FUZxxl> f =. verb define
12:24:58 <FUZxxl> ...
12:24:58 <tgeeky> anyone know if there is a tool which will just insert the type annotations that ghci would give you, into a source file?
12:24:58 <FUZxxl> )
12:25:03 <FUZxxl> Any problem?
12:25:18 * DanBurton demands a new lambdabot extension: J interpreter
12:25:24 <ddarius> DanBurton: Make it.
12:25:35 <osaunders> rwbarton: I think part of the philosophy behind J is that it‚Äôs OK to reuse symbols. I agree that might have its problems but it is also possible that other parts of its design make that work a lot nicer in practice than you might initially anticipate. But I can‚Äôt tell about specifics because I don‚Äôt know J very well. I only know that it‚Äôs quite clever and mysterious because I read about it for a day or so once.
12:25:40 <FUZxxl> ddarius: x and y are the formal parameters, : on a line on it's own is the separator between monad and dyadic definition
12:26:35 * FUZxxl thinks that lambdabot is slowly growing as powerful as emacs, except for the lacking edit capabilities
12:26:42 <dixie> Is J some simplified Java?
12:26:55 <FUZxxl> dixie: Completely unrelated. J++ is, though
12:28:11 <rwbarton> btw does one of those abbrevations I pasted earlier stand for "reference manual"? I think I would have a much easier time understanding that
12:28:34 <ddarius> FUZxxl: The definition in the primer uses 3 : 0
12:29:13 * DanBurton wonders why the J people decided to use the terms "monadic" and "dyadic" instead of "unary" and "binary"
12:29:15 <ddarius> Similar things for reading from files and such.  As I said, it is easily surmountable.
12:30:05 <FUZxxl> DanBurton: They have this "language analogy".
12:30:12 <FUZxxl> A function is called verb, a value is a noun
12:30:18 <FUZxxl> a statement is a sentence
12:30:19 <FUZxxl> and so on
12:30:28 <FUZxxl> they even have gerunds and adverbs
12:30:40 <irene-knapp> yes, fine, but "monadic" and "dyadic" are not terms from linguistics
12:30:49 <DanBurton> ^
12:30:54 <FUZxxl> irene-knapp: Hm... I don't know
12:32:13 * DanBurton laughs at definition #2 at http://en.wiktionary.org/wiki/monad
12:33:11 <FUZxxl> Well, that's a pretty good definition
12:33:22 <carpi> why is it that I can do [1..10] but not [LT..GT] even though Int and Ordering types are part of the (Ord) type class?
12:33:48 <rwbarton> because LT.. is treated as a qualified operator
12:33:52 * hackagebot http-types 0.6.7 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.7 (AristidBreitkreuz)
12:33:53 <rwbarton> try [LT .. GT]
12:34:33 <carpi> rwbarton: yes that works...but could you please tell me what you meant by "qualified operator"?
12:34:46 <DanBurton> carpi: someone just asked that on StackOverflow recntly :)
12:34:48 <rwbarton> the . infix operator from the LT module
12:34:59 <rwbarton> :t (.)
12:35:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:35:04 <rwbarton> :t (Prelude..)
12:35:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:35:39 <ddarius> Also, the Ord type class is completely irrelevant to the [x .. y] syntax.
12:35:40 <FUZxxl> IMHO it was a wrong decision to make . the namespace separator
12:35:48 <FUZxxl> #, ~ or @ would be better
12:36:10 <DanBurton> http://stackoverflow.com/questions/8261345/why-haskell-range-need-spaces-when-using-lt-gt/
12:36:23 <FUZxxl> So, something like State@Monad@Control
12:36:27 <carpi> DanBurton: Thanks. I was just getting to it : )
12:36:28 <irene-knapp> yuck ><
12:39:23 <DanBurton> yes, like others said, `[Foo .. Bar]` syntax is based on Enum, not Ord
12:41:53 <dafis> FUZxxl: that's ugly
12:42:56 <FUZxxl> dafis: Or maybe Control~Monad~State
12:43:22 <dafis> better, but I still prefer Control.Monad.State.Strict
12:43:41 <FUZxxl> Me too (The module, not the naming convention
12:43:51 <dafis> me both
12:46:38 <osaunders> ;'\
12:49:40 <FUZxxl> :)
12:50:21 <FUZxxl> osaunders: Your quote is unmatched. This is not valid J ;)
12:50:38 <FUZxxl> But even if it was, folding a : is quite pointless
12:50:44 <osaunders> FUZxxl: That was an accident I was trying to wake my screen up
12:51:04 <FUZxxl> :)
12:52:28 * FUZxxl is trying veni, vidi, vicci in VVVVVV and is thus a little bit unresponsive...
12:59:29 * FUZxxl succeeded after 200 deaths
12:59:56 <irene-knapp> FUZxxl: now play QWOP or IWBTG
12:59:59 <irene-knapp> (your choice)
13:01:01 <irene-knapp> (I would not normally wish either of those games on anybody, but you inflicted J on me! :D)
13:02:58 <FUZxxl> irene-knapp: Do you know VVVVVV?
13:03:07 <irene-knapp> no
13:03:09 <irene-knapp> only ^^^^^^
13:03:15 <FUZxxl> :)
13:03:21 <FUZxxl> It's really worth playing
13:03:25 <irene-knapp> heh, okay
13:03:29 <irene-knapp> not now, I'm tracking this bug :)
13:04:26 <FUZxxl> Which bug?
13:04:38 * homie winks
13:04:39 <irene-knapp> the one where I can't compile GHC HEAD :(
13:10:02 <irene-knapp> gahhhh
13:10:12 <irene-knapp> CoreSubst.exprIsConApp_maybe is NOT a simple function
13:10:17 <irene-knapp> and it appears to be the heart of my problem
13:11:14 * shapr bops cheerfully
13:13:02 <Philonous_> FUZxxl:  Go for dwarf fortress! That game will keep you busy for a decade or two
13:15:06 <donri> what's the syntax with @ in pattern matching called?
13:16:22 <dafis> as-pattern
13:16:35 <donri> thanks
13:17:09 <mizu_no_oto> If I'm looking into FRP, what's a good library to learn?  Yampa, reactive-banana, or something else?
13:20:19 <Philonous_> mizu_no_oto:  The last yampa release is 3 years old, reactive banana is still actively developed. But afaik none of them are really "production ready"
13:22:50 <mizu_no_oto> k
13:23:16 <mizu_no_oto> Also, are there any good papers I should read other than conal's push-pull FRP paper?
13:24:14 <mizu_no_oto> Also, how do you generally handle stateful or IO behaviours?
13:26:24 <jmcarthur> what do you mean by stateful or IO behaviors?
13:26:41 <jmcarthur> in some sense, behaviors capture the idea of state by themselves
13:28:40 <FUZxxl> Philonous_: What exactly is dwarf fortress
13:28:41 <mizu_no_oto> Well, I can see how you could do something like a dot rotating around in a circle in a pure way, easily:  dotPos time = (cos t, sin t)
13:29:00 <mizu_no_oto> But how would you do something based off of user input?
13:29:20 <mizu_no_oto> say, based off of the movement of a mouse, or a key press
13:29:22 <carpi> haskell uses stuff like #ifdef and #ifndef?
13:29:33 <carpi> the source seems to be using it..
13:29:57 <irene-knapp> only with the CPP extension
13:30:24 <irene-knapp> it's actually a very unfortunate situation because our syntax isn't exactly C's, so using the system-provided cpp doesn't always work
13:30:41 <irene-knapp> in particular Template Haskell has a syntax with a single ' by itself, which cpp reads as the start of a character literal
13:30:49 <mizu_no_oto> I suppose if your time type had the current state bundled along with the time, it could work.
13:30:56 <irene-knapp> we really need a Haskell-aware textual preprocessor
13:31:06 <shapr> Exists, sort of
13:31:08 <shapr> Several of them
13:31:14 <irene-knapp> (hscpp is a) not Haskell-aware, and b) not suitable for use in GHC because it's GPL)
13:31:22 <shapr> oh, text processor, I misread
13:31:24 <irene-knapp> yeah
13:31:37 <FUZxxl> @src guard
13:31:37 <lambdabot> guard True  =  return ()
13:31:38 <lambdabot> guard False =  mzero
13:31:42 <FUZxxl> @src when
13:31:42 <lambdabot> when p s = if p then s else return ()
13:31:45 <irene-knapp> that said, if I had ever finished that cross-compilation work
13:32:00 <irene-knapp> a major step towards it would have been eliminating some of the most probematic uses of the preprocessor in GHC
13:32:23 <irene-knapp> we have, for example, for each native backend processor architecture, a set of modules with matching exports, right
13:32:31 <irene-knapp> and we use #ifdef around the import statements
13:32:37 <irene-knapp> to determine which one to bring in
13:32:59 <irene-knapp> which is really a nasty hack but also eliminates a lot of plumbing
13:33:21 <shachaf> What are you cross-compiling to?
13:33:27 <irene-knapp> I'm not, righ tnow
13:33:35 <irene-knapp> but what I was trying to work on a couple months ago
13:33:57 <irene-knapp> was making GHC able to compile to any of the architectures it knows, from any of them, without a special build of it designed to do just that one combination
13:34:01 <Philonous_> FUZxxl:  A tile-based (think nethack) building/strategy game about a bunch of crazy dwarfes.
13:34:56 <jmcarthur> mizu_no_oto: typically use input is modelled by other behaviors and event, such as mousePosition :: Behavior Coords, or mouseClicks :: Event (Direction, MouseButton)
13:34:59 <jmcarthur> *user input
13:35:12 <irene-knapp> I did a lot of the plumbing for it, but (for good reasons) was told the approach I was using wasn't really ideal and could I please do it over again, heh
13:35:22 <irene-knapp> kinda got disheartened and never got back to it
13:35:40 <jmcarthur> mizu_no_oto: most FRP libraries give you low level hooks for creating such things, but you are intended to treat that functionality kind of like you would treat the FFI
13:37:10 <irene-knapp> unfortunately the first step of it turned out to have to be quite a large monolithic patch, adding an Architecture parameter to every single instance of the Outputable class, everywhere
13:37:51 <irene-knapp> (because of situations like Darwin where we want to eventually produce multiple outputs from a single run (32-bit and 64-bit), it couldn't go in static flags)
13:38:22 <FUZxxl> Philonous_: Okay.....
13:38:30 * irene-knapp was actually rather startled and upset to discover that the details of how things are pretty-printed are crucial to making GHC work at all :(
13:38:50 <irene-knapp> because, for example, the pretty-printer is used to pass things to system-provided assemblers and such
13:39:03 <FUZxxl> yeah...
13:39:34 <FUZxxl> I especially dislike the fact, that mangling is needed for the former C and the LLVM backend
13:39:37 <carpi> I imported the Data.Bits library. But I don't know how to create a Bits value .. ? I tried "B.Bits 3".. but it says "not in scope: data constructor"
13:39:49 <irene-knapp> well, we can't really avoid having to deal with name-mangling
13:39:50 <jmcarthur> carpi: Bits is a type class
13:39:53 <irene-knapp> since the platform ABIs require it
13:40:03 <jmcarthur> carpi: you use types that are instances of that class. for example, Int, Integer, Word, etc.
13:41:14 <carpi> ah.. so how may i use the Data.Bits data constructor? i just simply do "Data.Bits.xor 3 4"?
13:41:26 <jmcarthur> there is no constructor
13:41:27 <irene-knapp> Data.Bits is a module name - not a data constructor
13:41:36 <jmcarthur> you basically do what you just said though
13:41:47 <FUZxxl> carpi: The functions from  Data.Bits work on most numeric types
13:41:50 <irene-knapp> if you have imported Data.Bits unqualified (which is the default), you don't need to write Data.Bits.xor, you can just write xor
13:42:00 <FUZxxl> Except Bool (That confuses me)
13:42:08 <jmcarthur> > xor 4 5
13:42:09 <FUZxxl> For instance:
13:42:09 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:42:10 <lambdabot>    `Data.Bits.Bits a'
13:42:10 <lambdabot>      a...
13:42:13 <jmcarthur> > xor 4 5 :: Int
13:42:14 <lambdabot>   1
13:42:18 <irene-knapp> Bool is not a numeric type!!!
13:42:33 <FUZxxl> irene-knapp: Well, it's often useful to model it as a 1 bit type
13:42:35 <jmcarthur> the issue is the Num constraint
13:42:39 <carpi> ah yes eureka.. it works : )
13:42:40 <irene-knapp> okay, but it's not a number
13:42:49 <FUZxxl> jmcarthur: What's the problem?
13:42:56 <ddarius> One could easily make Bool an instance of Num.
13:42:57 <jmcarthur> FUZxxl: Bool is not an instance of Num
13:43:20 <jmcarthur> one could argue the same for any Enum i think
13:43:37 <FUZxxl> (+) is xor, (*) is and, h, negate is id and abs is id, too. signum is also id.
13:43:42 <ddarius> jmcarthur: Z/2 is a field.
13:43:45 <jmcarthur> yes
13:43:46 <FUZxxl> fromInteger is just off
13:43:48 <irene-knapp> okay, yes, we see that this mapping sorta-kinda exists
13:43:50 <FUZxxl> *odd
13:44:06 <FUZxxl> I actually used that mapping in one of my programs
13:44:07 <irene-knapp> we aren't arguing that point.  but it's a bad idea.
13:44:21 <FUZxxl> It's really nice to model certain SAT problems as linear equation systems over Z2
13:44:21 <ddarius> fromInteger would be fromInteger n = (n `mod` 2) == 0
13:44:28 <jmcarthur> a one-bit number certainly makes no less sense than a 32-bit or 64-bit number ;)
13:44:42 <ddarius> It makes more sense.
13:44:43 <irene-knapp> yeah, but I wouldn't call the one-bit-number type Bool
13:44:43 <FUZxxl> ddarius: No. Consistent would be odd
13:44:45 <irene-knapp> I would call it Word1
13:44:59 <FUZxxl> irene-knapp: type Word1 = Bool
13:45:02 <FUZxxl> Are you happy now?
13:45:03 <irene-knapp> ugh, no
13:45:05 <ddarius> FUZxxl: Yes, I mixed 0 and 1.
13:45:05 <irene-knapp> no I'm not!
13:45:15 <jmcarthur> why the distinction between Bool and Word1? why need they be considered different things?
13:45:32 <ddarius> We don't want to confuse C programmers.
13:45:35 <irene-knapp> because it isn't quite the identical problem to C where any numeric value is a boolean for the purpose of language constructs,
13:45:42 <irene-knapp> but I'm sure there's SOME related problem
13:45:45 <FUZxxl> jmcarthur: It would make a lot of things easier if Bool was a numeric type
13:46:00 <irene-knapp> one sec, cats want food
13:46:16 <jmcarthur> FUZxxl: i'm making no argument to the contrary
13:46:23 <Botje> programmer-driven automatic conversion a la scala would maybe be nice
13:46:38 <FUZxxl> Botje: In what way?
13:46:39 <irene-knapp> I think I'm the only one who was foolish enough to actually express disagreement with FUZxxl :)
13:46:48 <irene-knapp> but somebody has to or he'll think his ideas make sense! :)
13:46:55 <FUZxxl> irene-knapp: Disagreement is seldom foolish
13:46:59 <Botje> FUZxxl: in scala you can say "if you need to transform type A to type B, here's how"
13:47:02 <jmcarthur> can't go letting somebody have hopes and dreams
13:47:05 <ddarius> It makes sense to have a separate 1-bit type distinct from Bool.
13:47:14 <FUZxxl> Botje: It would certainly break type inference
13:47:26 <FUZxxl> ddarius: Yeah..
13:47:32 <FUZxxl> Maybe I am going to make a library Word1
13:47:43 <FUZxxl> I could even make an unboxed edition
13:47:47 <FUZxxl> Word1#
13:47:48 <ddarius> Don't forget to make Int1
13:47:53 <jmcarthur> o_O
13:47:54 <Sgeo> How can someone make their own unboxed type?
13:48:12 <FUZxxl> Sgeo: I could just use Int# and define my own operations on it
13:48:17 <Sgeo> Ah
13:48:37 <irene-knapp> well, it was foolish in that now I have to actually defend my statements which is going to take a long time and involve a lot of explanation ><
13:48:43 <FUZxxl> ddarius: Yeah... there is a difference:
13:48:50 <FUZxxl> Int1 has 0 and 1,
13:48:50 <erider> foo :: (String -> String) -> String -> String 'can I read this as: foo takes a function that take two string arguments, that returns a string?
13:48:53 <FUZxxl> Word1 has 0 and -1
13:48:58 <irene-knapp> hahaha Int1 :D
13:49:03 <FUZxxl> erider: no.
13:49:03 <jmcarthur> you mean the other way around, surely?
13:49:04 <rwbarton> other way around
13:49:05 <dafis> FUZxxl: other way round
13:49:16 <FUZxxl> Oh yes
13:49:25 <FUZxxl> erider: -> is left associative
13:49:35 <Sgeo> FUZxxl, erm, you mean right?
13:49:35 <ddarius> It's right associative.
13:49:49 <FUZxxl> ah shit..
13:49:56 <FUZxxl> I always confuse that
13:50:00 <dafis> FUZxxl: been up early?
13:50:05 <jmcarthur> now that we have this PolyKinds thing coming up it's about time we make these types:   Int :: Nat -> *; Word :: Nat -> *
13:50:06 <FUZxxl> No... too late
13:50:12 <FUZxxl> It 23 at Berlin now
13:50:15 * ddarius doesn't want to drive in a city where FUZxxl is driving.
13:50:48 * FUZxxl can't drive so ddarius can calm down
13:50:51 <dafis> ddarius: he's probably only confusing the words, not the directions
13:50:58 <FUZxxl> erider: Still here?
13:50:59 <erider> FUZxxl: so that is not how I read that
13:51:05 <jmcarthur> FUZxxl: just because you can't doesn't mean you don't
13:51:08 <ddarius> FUZxxl: I'm also nowhere near Berlin.
13:51:33 <FUZxxl> erider: It's a function taking a function that takes a String and gives a String and a String and gives a String
13:51:34 <ddarius> jmcarthur: It would mean that, but he probably did not mean "can't" literally.
13:51:53 <FUZxxl> ddarius: I am a student, I have no license
13:52:01 <ddarius> It's a function from functions of String to String to functions of String to String.
13:52:13 <FUZxxl> ddarius: That's another way to see that.
13:52:14 <ddarius> FUZxxl: I'm pretty sure you are physically capable of driving.
13:52:22 <FUZxxl> Thank's to Sch√∂nfinkel and Curry
13:52:23 <erider> FUZxxl: so that is not currying involved in (String -> String)
13:52:35 <erider> there is ..
13:52:53 <ddarius> Currying is what curry does.
13:53:09 <FUZxxl> erider: Well, as a rule of thumb, only the argument at top-level (if all redundant paranthesis are removed) count when it comes to currying
13:53:31 <shachaf> It's also what Sch√∂nfinkel did.
13:53:44 <erider> hmm
13:54:25 <FUZxxl> In your case, the actual arguments are of type (String -> String) and String
13:54:38 <FUZxxl> you have two arguments, if you apply all
13:55:05 <FUZxxl> From a functional POV, you could also say that you have only one argument but you return a function
13:55:33 * FUZxxl wonders whether J supports currying...
13:57:19 <erider> interesting
13:57:45 <DanBurton> Well does J support first-class functions?
13:57:50 <Jafet> :t curry
13:57:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:58:08 <Jafet> That type signature makes more sense if you've ever used ML.
13:58:52 <FUZxxl> DanBurton: Dunno... I am sure you can abuse the fact that functions are values.
13:59:23 <McManiaC> hey guys, this package doesnt seem to be able to lookup all the installed and required packages: http://hpaste.org/54543
13:59:25 <ddarius> Being able to implement curry and uncurry is equivalent to fully supporting higher order functions.
13:59:26 <McManiaC> any ideas?
14:00:00 <ddarius> McManiaC: Do cabal configure.
14:00:20 <ddarius> with a -v 3 or some such
14:00:34 <McManiaC> ddarius: well, if cabal wouldnt break pretty much all other packages, that depend on those libraries, I'd do that
14:00:48 <McManiaC> oh
14:00:49 <ddarius> cabal configure doesn't install anything.
14:01:16 <irene-knapp> er, you're running the same codebase - that Setup.hs just invokes Cabal through the library instead of the command-line client
14:01:29 <McManiaC> ddarius: yeah, nvm
14:01:30 <McManiaC> ^^
14:02:15 <dafis> McManiaC: missing stuff in user db?
14:02:23 <ddarius> irene-knapp: The Cabal library does not depend on the cabal-install tool or the codebase used by the cabal-install at all.
14:02:39 <irene-knapp> right, it's the other way around
14:02:43 <McManiaC> dafis: like what?
14:02:46 <irene-knapp> but the cabal-install tool is quite thin
14:02:56 <ddarius> irene-knapp: No it isn't.
14:03:03 <ddarius> Some parts are.
14:03:05 <dafis> McManiaC: runghc ./Setup defaults to global install and doesn't use the user db
14:03:10 <irene-knapp> well... I mean, yeah, it has those parts which deal with downloading packages, Hackage, and all that
14:03:21 <dafis> McManiaC: try runghc ./Setup --user
14:03:42 <Cale> I wonder if more of cabal-install would be usefully absorbed into the cabal library.
14:03:55 <irene-knapp> wellll the issue is dependencies
14:04:01 <irene-knapp> Cabal the library is required to build GHC
14:04:03 <ddarius> Cale: I'm sure some parts could be and have been, but other parts never will be.
14:04:03 <Cale> oh, right, yeah
14:04:21 <McManiaC> dafis: hmmm it seems to depend on multiple versions of deepseq
14:04:39 <ddarius> The Cabal library is just a standard interface for tools to talk to Haskell implementations about packages.
14:04:51 <McManiaC> http://hpaste.org/54544
14:05:48 <irene-knapp> that's not really true - the Cabal library also implements the .cabal file format, all the configuration stuff
14:05:59 <irene-knapp> shelling out to gcc when necessary
14:06:01 <dafis> McManiaC: does anything already depend on aeson?
14:06:18 <McManiaC> dafis: what do you mean?
14:06:25 <dafis> sorry, you're trying to install that
14:07:33 <dafis> McManiaC: unpack aeson, edit the .cabal (bump version) and install
14:07:34 <Cale> There seem to be certain packages which are always involved in these sorts of conflicts, and deepseq is one of them.
14:08:21 <dafis> McManiaC: that may fail because there have been changes to deepseq, though
14:08:28 <McManiaC> dafis: well, theres probably a reason why they require deepseq < 1.2
14:08:30 <ddarius> irene-knapp: How to install a package is information about packages.  The point is Cabal is supposed to be enough of an interface so that tools can be made that are implementation agnostic for package management, such as cabal-install.
14:08:46 <Sgeo> :t runST
14:08:47 <lambdabot> forall a. (forall s. ST s a) -> a
14:09:02 <ddarius> Every implementation would have its own implementation of (parts of) the Cabal library.
14:09:03 <irene-knapp> ddarius: hmm.  okay.  but it's a lot more than just a compatibility layer.  it has a lot of build-system knowledge.
14:09:19 <dafis> McManiaC: maybe, maybe not
14:09:28 <ddarius> It's not a compatibility layer at all.
14:09:36 <Cale> cabal-install-as-a-library? :)
14:09:41 <irene-knapp> heh
14:10:40 <Sgeo> ...I think I just impressed someone with the ST monad...
14:10:47 <Saizan> the proposed name is hackage-client :)
14:11:12 <irene-knapp> decent name :)
14:12:03 <Cale> Sgeo: The trick that the ST monad uses is really impressive. You can pull the same trick in other libraries to wrap unsafe things up in a safe package.
14:12:43 <Sgeo> I have no idea if the trick is what impressed them or not. They were asking about how it's so bad that they can't have local mutation
14:12:54 <shachaf> Cale: Impressive in a kind of awkward way.
14:12:58 <ddarius> For strict ST, you could pull off a similar trick in a dynamically typed language with reasonable overhead, but for lazy ST it gets trickier.
14:13:05 <Jafet> Which trick?
14:13:11 <Jafet> ST is trickily tricky.
14:13:18 <Cale> ddarius: orly?
14:13:22 <dafis> McManiaC: a quick scan of the source revealed no reson why it wouldn't work with deepseq-1.2
14:14:02 <Cale> ddarius: In a dynamically typed language, it seems like the trick I'm talking about would be meaningless :P
14:14:09 <Ornedan> Is it possible to yield a lazy list out of an ST action? Like http://hpaste.org/54545 , except one where I can use the generated values as they are done
14:14:30 <FUZxxl> What is an endofunctor?
14:14:50 <dafis> FUZxxl: a functor from a category to itself
14:14:58 <ddarius> Cale: It would be checked at run-time, but it certainly wouldn't be meaningless.  You can still want to guarantee referential transparency in a dynamically typed language.
14:15:27 <FUZxxl> dafis: Can you explain this in terms of Haskell'ish types?
14:15:48 <ddarius> FUZxxl: No, but it can be explained in terms of Haskell kinds.
14:16:08 <dafis> ddarius for the rescue
14:16:21 <FUZxxl> ddarius: Can you show me?
14:16:26 <McManiaC> dafis: some missing instances
14:16:27 <Saizan> Ornedan: you could use unsafeInterleaveST if you really want
14:16:43 <dafis> McManiaC: Data.Map/Set?
14:16:50 <Saizan> or just the Lazy version of ST i guess?
14:16:56 <ddarius> f :: * -> * is an endofunctor (if it is a functor) on *.  f :: (* -> *) -> * is not an endofunctor.
14:17:19 <FUZxxl> ah okay.
14:17:27 <ddarius> Of course, the endo- prefix is used in other things, such as endofunctions.  An endofunction is a just a function with the same domain and codomain.
14:17:43 <McManiaC> dafis: yup I think
14:17:48 <FUZxxl> And how can a monad be a monoid in the category of endofunctors?
14:17:51 <ddarius> Generally, F is a categorical functor if it is a functor C -> C for some category C.
14:18:07 <FUZxxl> Ah
14:18:17 <Saizan> +endo?
14:18:18 <ddarius> FUZxxl: It's a monoid object because it certainly isn't a monoid in the set-oriented abstract algebra sense.
14:18:30 <ddarius> Saizan: Yes.
14:18:31 <Cale> FUZxxl: That's using a more generalised definition of the word "monoid"
14:18:51 <FUZxxl> urgh... and that is?
14:18:56 <Cale> Where a normal monoid is a monoid in the category of sets
14:18:57 <Ornedan> Saizan: What are the downsides of the lazy version of ST?
14:19:01 <Cale> Well, it takes some setup...
14:19:09 <Cale> How much category theory do you know?
14:19:32 <Cale> http://en.wikipedia.org/wiki/Monoidal_category -- first of all, we need something called a monoidal category
14:19:39 <Jafet> Ornedan: you just get all the downsides of laziness
14:20:11 <Cale> Basically, this is a category with an extra operation on its objects which acts like a monoid operation (up to coherent isomorphisms)
14:20:42 <Cale> So, in the case of Hask, we can make it a monoidal category (roughly) where the monoid operation on types is (,)
14:20:42 <FUZxxl> Cale: Not much.... I have no CS degree
14:21:04 <Cale> and in the category of sets, Cartesian product is the monoidal operation
14:21:16 <FUZxxl> ah....
14:21:17 <Cale> (with a one-element set as the unit)
14:21:20 <FUZxxl> That makes sense
14:21:23 <ddarius> FUZxxl: A CS degree wouldn't help much.
14:21:40 <rwbarton> Usually there are many choices of monoidal structure on a given category
14:21:47 <Cale> In a category of endofunctors (and natural transformations between them), we have another monoidal operation -- composition
14:21:51 <FUZxxl> ddarius: I tried to point out that most of my knowledge originates from listening other peoples on #haskell
14:22:18 <FUZxxl> Cale: okay...
14:22:25 <FUZxxl> That's kind of clear.
14:22:33 <Cale> http://en.wikipedia.org/wiki/Monoid_object -- now in any monoidal category, we can define what it is to be a monoid object
14:22:33 <ddarius> FUZxxl: That's probably more useful than the vast majority of CS degrees in this particular case.
14:22:57 <dafis> McManiaC: you can try to add the instances to Data.Aeson.Types, but I'm not convinced that's the best way
14:23:01 <Cale> Let's re-examine what it means to be a monoid in Set
14:23:07 <Cale> We have a set M
14:23:14 <Cale> and an operation multiplication M x M -> M
14:23:18 <FUZxxl> Well, now I know what a monoid is and what an endofunctor is.
14:23:29 <FUZxxl> ah okay... I listen
14:23:59 <Cale> and a unit, which is usually thought of as an element of M, but since we're doing category theory, we don't want to talk about elements, we'll let 1 be a one-element set, and say that the unit is a function 1 -> M
14:24:31 <Cale> and these have to satisfy some laws (look at the diagrams on the wikipedia page for those)
14:24:38 <Cale> Basically, associativity, and left/right unit
14:24:38 <FUZxxl> I saw them.
14:24:42 <FUZxxl> yes
14:25:31 <Cale> So, now if we replace the underlying monoidal category with the category of endofunctors on a fixed category C, with composition as the monoidal operation on objects, and the identity functor as its unit
14:25:49 <Cale> Our monoid object becomes a functor M
14:25:53 <Cale> C -> C of course
14:26:06 <Cale> with a natural transformation  M . M -> M
14:26:20 <Cale> (which in Haskell becomes a polymorphic function M (M a) -> M a)
14:26:26 <FUZxxl> ah...√∂
14:26:29 <Cale> and a natural transformation 1 -> M
14:26:40 <Cale> (which in Haskell becomes a polymorphic function a -> M a)
14:26:45 <FUZxxl> That natural transformation... is it join?
14:26:47 <Cale> yes
14:26:52 <FUZxxl> okay....
14:26:53 <Cale> the first one is
14:26:57 <FUZxxl> Now that makes it clear
14:27:12 <Cale> and those have to satisfy perfectly analogous laws
14:27:12 <ddarius> @quote lax.functor
14:27:12 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
14:27:31 <Jafet> @quote dolio monad
14:27:31 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
14:27:59 <FUZxxl> hehe
14:28:17 <ddarius> There is a more general notion of monad where you are in an arbitrary bicategory, rather than the 2-category Cat.
14:28:45 <ddarius> This is necessary, for example, to show that closure operators are monads.
14:28:47 <FUZxxl> Is that still a Monad in the Haskellish sense, then? I guess not...
14:28:57 <Cale> ddarius: er, what?
14:29:23 <FUZxxl> ddarius: Cale: Sorry for asking strange questions... It's hard to follow, but I try harder
14:29:29 <Cale> Closure operators are just ordinary monads on preorder categories
14:29:58 <ddarius> FUZxxl: Monads in Haskell are monads on a particular category.
14:30:04 <FUZxxl> yes
14:30:42 <Cale> The more generalised definition of monads in a 2-category will still apply to Haskell, but again as a special case.
14:30:56 <FUZxxl> yes.
14:31:07 * FUZxxl tries to grok that
14:31:24 <Cale> Well, we haven't said anything more about that definition than that it exists
14:31:33 <FUZxxl> Hell... Where can I get a good introduction into Category theory?
14:32:03 <Cale> Well... I like Awodey's book as an intro, and you're probably already ready to watch the Catsters' videos on YouTube
14:32:13 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
14:32:23 <FUZxxl> Cale: of course. It's just a definition. The sum type would be an implementation
14:32:23 <Cale> http://www.youtube.com/user/TheCatsters
14:32:38 <Cale> er, http://www.youtube.com/user/TheCatsters/videos
14:33:00 <FUZxxl> Cale: The first one was right
14:33:31 <Cale> Yeah, but it seemed to take me to a feed page which was blank because they haven't posted anything in a while
14:33:49 <Sgeo> :t (forM, forM_, whileM, whileM_)
14:33:50 <lambdabot> Not in scope: `whileM'
14:33:50 <lambdabot> Not in scope: `whileM_'
14:34:31 <Cale> FUZxxl: anyway, A 2-category generalises the idea of a category like Cat where there are a second kind of arrows between parallel arrows
14:34:47 <FUZxxl> wha
14:34:51 <FUZxxl> okay....
14:35:34 <Sgeo> @hoogle (Monad m) => m Bool -> m a -> m ()
14:35:35 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:35:35 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
14:35:35 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
14:35:43 <Sgeo> @hoogle (Monad m) => m Bool -> m () -> m ()
14:35:43 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
14:35:44 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
14:35:44 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:35:51 <Cale> Cat has objects (0-cells) as categories, arrows (1-cells) which are functors between those categories, and a secondary kind of arrow (2-cell) between arrows which go between the same two objects, natural transformations
14:35:51 <dropdrive> Cale: What's an example of a manifestation of a 2-category in Haskell?
14:36:18 <Sgeo> :t (forM, forM_)
14:36:19 <lambdabot> forall a (m :: * -> *) b a1 (m1 :: * -> *) b1. (Monad m, Monad m1) => ([a] -> (a -> m b) -> m [b], [a1] -> (a1 -> m1 b1) -> m1 ())
14:36:40 <Cale> dropdrive: hrm, haven't seen many
14:37:12 <Sgeo> lambdabot isn't responding to me when I do things in private message
14:37:13 <Sgeo> :(
14:37:29 <ddarius> Sgeo: lambdabot doesn't respond to :t in private messages, use @type.
14:37:31 <rwbarton> the kind system is a bit like a 2-category
14:37:33 <FUZxxl> Sgeo: lambdabot clearly discriminates you
14:37:40 <Cale> There are some aspects of "Arrow" libraries which start to look 2-categorical, but really they can mostly be explained with (symmetric or braided) monoidal categories
14:37:42 <rwbarton> if you squint a bunch
14:38:13 <FUZxxl> Cale: Can you make up an example?
14:39:12 <dropdrive> Cale: So I asked this a while ago... suppose all functions with type [a -> b] -> a -> [b].  I claim there is a "distinguished" one, but I'm unable to make that statement concrete.  Help?
14:39:25 <dropdrive> s/suppose/consider/
14:39:48 <ddarius> dropdrive: All "distinguished" means is that there is one that is (arbitrarily) picked out and named.
14:40:11 <FUZxxl> dropdrive: I don't understand your question. Do you ask, whether it's possible to have two such functions that are not extensionally equivalent?
14:40:13 <McManiaC> dafis: hacked the aeson package, hopefully doesnt break anything and my NFData definition is decent enough
14:40:17 <McManiaC> ^^
14:40:32 <dropdrive> ddarius: Fine then, there's one that's the "obvious" implementation.
14:40:37 <dropdrive> FUZxxl: No idea what that means.
14:40:41 <Cale> I think he's looking for a universal property which \fs x -> map ($ x) fs  satisfies and other functions don't
14:41:03 <dropdrive> ddarius: For example, the "obvious" one is universal, but it's not the only one
14:41:03 <mauke> :t sequence :: [a -> b] -> a -> [b]
14:41:04 <lambdabot> forall a b. [a -> b] -> a -> [b]
14:41:09 <Cale> or indeed, sequence
14:41:20 <FUZxxl> dropdrive: f and g are extensionally equivalent iff for all a f a = g a
14:41:26 <ddarius> dropdrive: Define universal and you will probably be done.
14:41:33 <Cale> from one side, sequence has the property that any other function of this type can be obtained by post-composition with sequence
14:41:54 <Cale> But there are more functions like that
14:41:57 <dropdrive> ddarius: My definition of universal is that all functions with that type factor through the universal one.
14:42:05 <dropdrive> Cale: Yes, so I want something like "laziest"
14:42:08 <mauke> @free dropdrive :: [a -> b] -> a -> [b]
14:42:09 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => $map g . dropdrive xs = dropdrive ys . f
14:42:18 <dropdrive> Cale: But I have no idea how to say that rigorously.
14:42:47 <ddarius> dropdrive: So you are saying that if f has that type, and u is this universal function then f = u . g (or alternatively f = g . u)
14:42:52 <dropdrive> mauke: I don't even... what...?
14:42:54 <Cale> Using @free is cheating ;)
14:43:00 <dropdrive> ddarius: Yes, but it's not unique.
14:43:13 <michaelbaker> I wrote a set of files that I want to be able to include as a library in a Yesod project. Is there a way to specify a dependency in the Yesod project's .cabal file and say that I want it to be fetched from a github url when I run cabal install?
14:43:14 <mauke> dropdrive: you are now free
14:43:19 <ddarius> dropdrive: So?
14:43:44 <FUZxxl> @help free
14:43:44 <lambdabot> free <ident>. Generate theorems for free
14:43:55 <mauke> @free id
14:43:55 <lambdabot> f . id = id . f
14:44:05 <FUZxxl> @free join
14:44:06 <lambdabot> Expected variable or '.'
14:44:07 <KitB> @hoogle deepseq
14:44:08 <lambdabot> Control.DeepSeq module Control.DeepSeq
14:44:08 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
14:44:08 <lambdabot> package deepseq
14:44:13 <dropdrive> ddarius: So...I'm trying to identify a property that that selects the one that I'm thinking of.
14:44:22 <FUZxxl> @free join :: Monad m => m (m a) -> m a
14:44:22 <lambdabot> Extra stuff at end of line
14:44:25 <zhulikas> [(head $ chain c, length $ chain c) | c <- [1..1000000]]
14:44:30 <zhulikas> chain :: Int -> [Int]
14:44:36 <ddarius> dropdrive: P(f) ‚â° (f = u)
14:44:37 <FUZxxl> @free join :: m (m a) -> m a
14:44:38 <zhulikas> will "chain c" be evaluated only once?
14:44:38 <lambdabot> Extra stuff at end of line
14:44:38 <ddarius> There you go.
14:44:49 <zhulikas> once per c
14:45:09 <mauke> zhulikas: probably no
14:45:14 <zhulikas> hmm
14:45:39 <dropdrive> ddarius: What is P(f)?
14:45:51 <ddarius> The property that you are looking for.
14:45:54 <dafis> zhulikas: possible if you compile with optimisations
14:45:58 <ddarius> Well P is.
14:46:31 <zhulikas> dafis, I read somewhere that once function is evaluated, it's value is stored in a memory and then such function is called again, instead of evaluating it's value is given
14:46:38 <zhulikas> I don't remember how was it called though
14:46:43 <zhulikas> let me go over the bookmarks in browser
14:46:51 <dropdrive> ddarius: Well the rest I don't understand either, so I can't tell if you've being helpful or an ass.
14:47:06 <dafis> zhulikas: memoisation, but that's not done by the compiler, you have to do it yourself
14:47:12 <zhulikas> yes!
14:47:46 <zhulikas> hmm
14:47:48 <ddarius> dropdrive: What makes you think there -is- some compelling property that uniquely picks out the function you are thinking of?
14:47:48 <zhulikas> is it hard?
14:47:54 * zhulikas still a noob
14:48:18 <rwbarton> zhulikas: you can introduce sharing yourself with let
14:48:24 <zhulikas> yeah...
14:48:27 <zhulikas> I'll do that
14:48:32 <zhulikas> and read about memoisation afterwards
14:48:47 <rwbarton> also head $ chain c might be a very cheap computation, depending on what "chain" is
14:48:53 * hackagebot bluetile 0.6 - full-featured tiling for the GNOME desktop environment  http://hackage.haskell.org/package/bluetile-0.6 (JanVornberger)
14:48:54 <dropdrive> ddarius: That's what I was asking, and all I get is, "the property is the property that it's equal to what I'm thinking of" -- is that a yes or a no?
14:49:06 <zhulikas> http://projecteuler.net/problem=14
14:49:10 <zhulikas> this is chain
14:49:21 <rwbarton> that doesn't sound like a place where I am going to see a haskell function
14:49:32 <zhulikas> hehe
14:49:33 <zhulikas> sorry :}
14:49:46 <dafis> zhulikas: are you on a 32-bit or a 64-bit system?
14:49:52 <zhulikas> 64
14:49:58 <zhulikas> but not sure whether haskell is x64
14:50:04 <dafis> okay, then Int will work
14:50:07 <rwbarton> is head $ chain c just c?
14:50:20 <dafis> zhulikas: what's maxBound :: Int for you?
14:50:39 <zhulikas> rwbarton, it is :D
14:50:52 <FUZxxl> good night.
14:50:54 <tomprince> zhulikas: What happens is that any given expression is only evaluated once, but it isn't evaluated until needed. The sharking rwbarton was referring to is, if you let an expresiion, it can be used in more than one place, but it will only be computed once (or not all)
14:51:10 <donri> byorgey: ooh typeclassopedia on haskellwiki, really cool stuff
14:51:12 <zhulikas> dafis, 2147483647
14:51:27 <dafis> zhulikas: then you need Int64 or Integer
14:51:39 <zhulikas> why?
14:51:49 <dafis> zhulikas: Int overflow
14:51:58 * FUZxxl 's mind is too convoluted. He needs some sleep
14:52:00 <Sgeo> *sigh*
14:52:09 <osaunders> If I have ¬´Map String Int¬ª and ¬´Map Int String¬ª where String tends to be long. Would GHC likely optimize so String was only stored in memory once?
14:52:11 <zhulikas> dafis, would it throw an error indicating overflow?
14:52:24 <Sgeo> Just saw someone commenting on Haskell under the impression that to print to the console for debugging involves dragging in the IO monad everywhere
14:52:31 <dafis> zhulikas: no, it would just enter a loop
14:52:35 <ddarius> osaunders: No.
14:52:40 <zhulikas> ahh. That's what happened :D
14:52:46 <zhulikas> thanks
14:53:15 <osaunders> ddarius: OK, thanks, that‚Äôs what I thought
14:55:00 <zhulikas> >maxBound::Int
14:55:06 <zhulikas> > maxBound::Int
14:55:07 <lambdabot>   9223372036854775807
14:55:17 <zhulikas> I need that :o
14:55:28 <dafis> zhulikas: Windows?
14:55:36 <zhulikas> sadly yesh :(
14:55:49 <dafis> zhulikas: not anytime soon, then :(
14:56:00 <zhulikas> I didn't even succeed installing gtk2hs on it
14:56:18 <zhulikas> and did it with no problems on VM (debian x64)
14:56:31 <_Mikey> :)
14:57:06 <zhulikas> and Leksah on windows doesn't have normal autocomplete :D
14:58:43 <McManiaC> dafis: solution was: deepseq >= 1.2, containers >= 0.4.2.0
14:58:49 <McManiaC> as dep for aeson
14:59:08 <zhulikas> ok, solved it
15:01:08 <dafis> McManiaC: installing a second version of containers is not recommended
15:02:14 <McManiaC> dafis: hm :S
15:02:58 <yitz> dafis: i think the problem is with installing another copy of the same version of a library. why not install an additional version?
15:03:00 <erus`> > 0xFFFFFFFF
15:03:00 <lambdabot>   4294967295
15:04:21 <dafis> yitz: containers is a boot package, if you have another version of it, stuff using that can't use any boot package depending on containers, likely diamond-dependency
15:04:31 <yitz> Sego nope
15:04:55 <yitz> dafis: not that i know of. i have additional versions of a number of boot libraries, no problems
15:04:55 <alistra> > 0777
15:04:57 <lambdabot>   777
15:05:20 <yitz> dafis: but you definitely do not want to reinstall the same version as the one that came with ghc
15:14:10 <hpaste> ‚ÄúMukesh Tiwari‚Äù pasted ‚ÄúInfinite list of IO‚Äù at http://hpaste.org/54547
15:14:23 <keep_learning> hello every one
15:14:53 <keep_learning> i am trying to get an infinite list of IO but getting error http://hpaste.org/54547
15:15:05 <keep_learning> could some one please tell me what is wrong with code ?
15:15:22 <mauke> why an infinite list of IO if every element is the same?
15:16:18 <keep_learning> mauke, i did not get you. Its random list of coordinates.
15:16:26 <mauke> no, it's not
15:16:29 <mauke> it's a list of IO actions
15:16:49 <rwbarton> well it's not really anything at the moment
15:17:33 <keep_learning> rwbarton, if i am trying to return only IO ((Double , Double ) , (Double )) then its working fine
15:18:05 <keep_learning> rwbarton, so how can i translate it into list.
15:18:23 <rwbarton> well I doubt you want to execute an infinite number of IO actions here
15:18:24 <Tyr42> replicateM
15:19:11 <rwbarton> if you know in advance how many coordinates you will want then replicateM is good, yes
15:19:34 <keep_learning> rwbarton, oh , IO actions are not lazy ?
15:19:44 <keep_learning> Tyr42, thank you
15:20:37 <rwbarton> keep_learning: right, otherwise it would be quite tricky to make sure your IO is actually executed in the order you expect!
15:21:07 <Tyr42> yes, it's got to pass the "World" from one IO action to the next
15:21:21 <keep_learning> rwbarton, thank you
15:21:35 <Tyr42> so if it had to do an infinite number of things before printing the result, it would not ever print the result
15:23:01 <d-snp> hey guys, I need to maintain a list of Channels, that has to be indexed with a unique identifier, like a hash table (dictionary)
15:23:11 <d-snp> what datatype would be most suitable?
15:23:22 <d-snp> I see there's Data.HashSet
15:23:46 <m3ga> d-snp: also Data.Map and maybe even Data.IntMap
15:23:46 <d-snp> but also Data.HashTable..
15:23:51 <d-snp> hmm
15:24:34 <m3ga> Data.Map/IntMap are purely functional. Data.HashTable is mutable.
15:24:42 <d-snp> hmm
15:25:40 <m3ga> iteratees anyone? is there any such thing as a bi-directional iteratee/enumerator?
15:28:23 <ddarius> @hackage coroutine
15:28:23 <lambdabot> http://hackage.haskell.org/package/coroutine
15:29:09 <ddarius> @hackage monad-coroutine
15:29:10 <lambdabot> http://hackage.haskell.org/package/monad-coroutine
15:29:28 <ddarius> m3ga: I recommend reading Mario's Monad Reader article as well.
15:29:45 <m3ga> ddarius: any idea which issue?
15:29:48 <d-snp> is there a good reason to choose the mutable hashtable?
15:30:12 <d-snp> *for choosing
15:30:26 <m3ga> d-snp: use the mutable one if you are constantly updating. use the immutable one if you build the map and then use it.
15:31:16 <d-snp> hmm
15:31:25 <ddarius> m3ga: The latest one.
15:31:25 <m3ga> ddarius: issue 19. thanks
15:31:30 <m3ga> :-)
15:32:27 <Cale> d-snp: Data.HashTable might be better now than it was last I looked at it, but historically, it's had really bad performance.
15:33:07 <Cale> d-snp: The unordered-containers package has some nice hashing structures which are pretty close to drop-in replacements for Data.Map/Data.Set
15:33:20 <Cale> (but you need Hashable instances for the keys, obviously)
15:34:58 <d-snp> so how I'm intending to use it: my stack loops listening for incoming connections, when it has one, it sets up a channel for it, with some other stuff and puts it in its state record
15:35:23 <d-snp> and then whenever it receives new data it will look up to which channel the data belongs, and dispatch it to the appropriate channel
15:35:54 <ddarius> Via pigworker and LtU: http://arxiv.org/abs/0905.4063
15:35:58 <Cale> d-snp: Have you tried just using Data.Map to start with?
15:36:25 <d-snp> no, I just came here asking what the regular datastructure was for dealing for this and was surprised a mutable one was recommended
15:36:30 <ion> d-snp: I haven‚Äôt read the discussion, but why not have a thread per connection?
15:36:55 <d-snp> ion: I do have a thread per connection, that's why I need an array of channels
15:37:03 <d-snp> eh, a map of channels
15:37:07 <ion> Sorry, i read too hastily.
15:38:14 <lcfrs> hi, can someone point to an elegant way to calculate the distance between numbers in a list? for e.g. [1, 10, 15, 12] -> [9, 5, -3].
15:38:16 <d-snp> (it multiplexes multiple connections over one socket)
15:38:22 <ddarius> Er that paper was via neelk not pigworker.
15:38:49 <yitz> lcfrs: do you have an inelegant way?
15:38:56 <ddarius> > ap(zipWith(-)tail)[1,10,15,12]
15:38:57 <lambdabot>   Ambiguous occurrence `-'
15:38:57 <lambdabot>  It could refer to either `L.-', defined at <local...
15:39:05 <ddarius> > ap(zipWith(Prelude.-)tail)[1,10,15,12]
15:39:06 <lambdabot>   Couldn't match expected type `[a]'
15:39:06 <lambdabot>         against inferred type `[a1] -> [...
15:39:19 <ddarius> > ap(zipWith(Prelude.-))tail[1,10,15,12]
15:39:19 <lambdabot>   [-9,-5,3]
15:39:27 <mauke> @undefine
15:39:31 <ddarius> > ap(zipWith subtract)tail[1,10,15,12]
15:39:32 <lambdabot>   [9,5,-3]
15:40:04 <ddarius> (zipWith(-)=<<tail)[1,10,15,12]
15:40:07 <lcfrs> yitz: yes, something imperative and not in haskell
15:40:08 <ddarius> > (zipWith(-)=<<tail)[1,10,15,12]
15:40:09 <lambdabot>   [9,5,-3]
15:40:21 <lcfrs> ddarius: much thanks!
15:40:23 <yitz> > (zipWith subtract <*> tail) [1,10,15,12]
15:40:24 <lambdabot>   [9,5,-3]
15:40:57 <ddarius> > (zipWith(-)=<<tail)[]
15:40:58 <lambdabot>   *Exception: Prelude.tail: empty list
15:41:02 <ddarius> > ap(zipWith subtract)tail[]
15:41:03 <lambdabot>   []
15:41:10 <ddarius> Slight difference.
15:41:22 <lcfrs> noted
15:41:39 <lcfrs> yitz, i like the <*> use. thank you too.
15:41:44 <parcs> d-snp: just use Data.Map for now
15:42:08 <ddarius> @quote zip.ap
15:42:08 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:43:04 <ion> Too bad ap is different from <*>
15:43:51 <yitz> ion: aren't Applicative instances required to make them the same?
15:44:31 <rwbarton> I certainly require them to be the same
15:50:08 <shapr> o hai Apocalisp
15:50:19 * shapr bops cheerfully
15:50:41 <ddarius> This is a fairly good LtU thread: http://lambda-the-ultimate.org/node/4402
15:50:46 <Apocalisp> Hej med dig, shapr
15:50:57 <shapr> god morgon!
15:51:09 <ion> What is this demon language
15:51:26 <Apocalisp> G√≥√∞an og blessa√∞an helv√≠tis daginn
15:54:33 <zhulikas> [[1,2,3],[1,2,3]] -> [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:54:36 <zhulikas> how to do something like that
15:54:52 <Jafet> > sequence [[1,2,3],[1,2,3]]
15:54:53 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
15:54:56 <zhulikas> ahh sequence
15:54:57 <zhulikas> damn it
15:55:18 <Jafet> Those inscrutable monads
15:56:55 <ion> > replicateM 4 "op" !! 9
15:56:56 <lambdabot>   "poop"
15:57:05 <yitz> GoogleTranslate "G√≥√∞an og blessa√∞an helv√≠tis daginn" = "Hello and good day damn day"
15:58:36 <ddarius> Poop being 1001 in binary.
15:58:41 <yitz> (Icelandic)
16:02:05 <DevHC> allow me to quote someone who has actually read that learnyouahaskell thing
16:02:07 <DevHC> <someone> wtf retarded illustrations in the book
16:02:07 <DevHC> <someone> example: http://s3.amazonaws.com/lyah/kermit.png
16:02:07 <DevHC> <someone> the most "suitable" illustration for list comprehensions
16:03:15 <ion> haha
16:06:19 <hiptobecubic> DevHC, i felt like the illustrations really solidified my understanding.
16:06:42 <shapr> Apocalisp: Dude, Iceland is crazy.
16:06:55 <Apocalisp> have you been?
16:07:02 <shapr> Nah, only to Sweden and Finland.
16:07:17 <Apocalisp> I have been to neither
16:08:54 <Apocalisp> shapr: Coming to Hac Boston?
16:09:24 <shapr> No, I wish. I'll be attending my classes instead.
16:09:39 <shapr> I wish I could attend...
16:11:31 <DevHC> hiptobecubic: troll much?
16:12:37 <hiptobecubic> DevHC, no.
16:13:57 <melan> Hi
16:16:28 <melan> What are the major GUI-libraries for Haskell?
16:16:54 <monochrom> gtk2hs is one
16:17:43 <melan> and wxhaskell also?
16:17:45 <Jafet> The one?
16:18:22 <monochrom> no, not the one, just one of many
16:18:34 <Jafet> fsvo major
16:28:31 <lars9> how to filter out the 'has joined' 'has quit' msgs?
16:29:01 <monochrom> depends on IRC software
16:29:58 <lars9> irssi?
16:30:06 <parcs> lars9: webchat has an option for thtt
16:30:20 <ion> /help ignore
16:30:27 <monochrom> I don't know irssi. but I heard it's along the line of /ignore
16:30:27 <lars9> parcs: thanks
16:31:52 <lars9> yeah webchat supports it.
16:32:42 <lars9> i found this course very good, stanford cs240h: http://www.scs.stanford.edu/11au-cs240h/notes/
16:32:58 <alistra> still no new lectures lars9
16:32:59 <alistra> :|
16:33:27 <lars9> alistra: should be close to final
16:33:54 <lars9> so... and what else can they teach after lib level optimization ...
16:35:03 <alistra> lol
16:35:06 <alistra> it's not like
16:35:17 <alistra> all the time something immediately depends on the one before
16:35:33 <lars9> and this is missing: 8. Monoids and finger trees; was it ever online?
16:36:08 <alistra> don't think so
16:36:37 <hpaste> irene-knapp pasted ‚ÄúBuiltin rule "Class op *": does not match‚Äù at http://hpaste.org/54550
16:36:45 <irene-knapp> so yeah
16:36:52 <irene-knapp> wth :(
16:36:54 <irene-knapp> why is that not matching :(
16:39:05 <lars9> where is src code?
16:43:54 * hackagebot type-booleans 0.1 - Type-level booleans via type-families  http://hackage.haskell.org/package/type-booleans-0.1 (NicolasFrisby)
16:43:56 * hackagebot type-spine 0.1 - A spine-view on types  http://hackage.haskell.org/package/type-spine-0.1 (NicolasFrisby)
16:43:58 * hackagebot tagged-th 0.1 - QuasiQuoter and Template Haskell splices for creating proxies at higher-kinds  http://hackage.haskell.org/package/tagged-th-0.1 (NicolasFrisby)
16:45:29 <augur> byorgey: i think it might be good to update the typeclassopedia's pointed section to give an aside on why its a pointed functor
16:45:33 <augur> (at least the wiki version)
16:45:42 <augur> and why "pointed" makes sense as a thing to call it
16:45:47 <augur> since usually its sets that are pointed
16:46:45 <augur> since monoids arent monoidal in the same way that pointeds are pointed
16:46:56 <augur> pointeds are pointed in the same way monads are monoidal
16:47:46 <augur> well, monoid isnt a functor class, so yeah
16:47:48 <augur> but you get the point :p
16:48:02 <alistra> cool story bro
16:48:22 <augur> alistra: imma fuck you up
16:58:55 * hackagebot type-digits 0.1 - /Arbitrary/ type-level digits  http://hackage.haskell.org/package/type-digits-0.1 (NicolasFrisby)
17:00:03 <photex> hi folks, quick question (as always)
17:00:14 <photex> I'm trying to use a function that expects a GLdouble
17:00:31 <photex> but my state data type uses a Double everywhere else
17:00:39 <photex> the program can't compile because of this
17:00:49 <photex> and I'm not sure how to cast types
17:00:52 <photex> or convert types
17:01:07 <silver> @hoogle Double -> GLdouble
17:01:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:01:08 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
17:01:08 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
17:01:54 <photex> ok, is that the typical way to bridge values from purely functional into random IO functions?
17:02:59 <ion> print (length "foo"). print returns an IO action, length is pure.
17:03:55 * hackagebot type-cereal 0.1 - Type-level serialization of type constructors  http://hackage.haskell.org/package/type-cereal-0.1 (NicolasFrisby)
17:04:26 <jmcarthur> photex: try realToFrac
17:04:30 <jmcarthur> :t realToFrac
17:04:31 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
17:05:02 <photex> it's already a Double
17:05:17 <jmcarthur> realToFrac works both ways
17:05:25 <photex> rotate :: MatrixComponent c => c -> Vector3 c -> IO ()
17:05:30 <photex> where
17:05:48 <photex> MatrixComponent only has a type defined for GLfloat and GLdouble
17:06:20 <photex> examples on the wiki don't seem to doing anything different than I am
17:06:34 <photex> other than I'm using record syntax to define my state
17:06:46 <jmcarthur> not sure why anything you just said makes realToFrac not work
17:07:02 <photex> realToFrac gives me the same error
17:07:07 <jmcarthur> what error
17:07:28 <photex> rotate (realToFrac ra) $ Vector3 rx ry 0
17:07:30 <photex> No instance for (MatrixComponent Double)
17:07:30 <photex>       arising from a use of `rotate'
17:07:30 <photex>     Possible fix:
17:07:30 <photex>       add an instance declaration for (MatrixComponent Double)
17:07:31 <photex>     In the expression: rotate (realToFrac ra)
17:07:31 <photex>     In the expression: rotate (realToFrac ra) $ Vector3 rx ry 0
17:07:50 <jmcarthur> what if you try this?    rotate (realToFrac ra :: GLdouble) $ Vector3 rx ry 0
17:08:25 <jmcarthur> type inference can't use type class constraint to infer types, so it makes sense that in this case you have to be more explicit
17:08:43 <jmcarthur> (i think it's defaulting to Double unless you are more explicit)
17:08:57 * hackagebot type-ord 0.1 - Type-level comparison operator  http://hackage.haskell.org/package/type-ord-0.1 (NicolasFrisby)
17:09:00 * hackagebot type-digits 0.1.0.1 - Arbitrary-base type-level digits  http://hackage.haskell.org/package/type-digits-0.1.0.1 (NicolasFrisby)
17:09:01 * hackagebot type-ord-spine-cereal 0.1 - Generic type-level comparison of types  http://hackage.haskell.org/package/type-ord-spine-cereal-0.1 (NicolasFrisby)
17:09:08 <photex> ok, that works, but man
17:09:10 <photex> so ugly
17:09:16 <photex> I'm clearly doing things wrong
17:09:19 <photex> if it's come to this!
17:09:21 <photex> :)
17:10:03 <jmcarthur> ideally you would convert from Double to GLdouble on the way from your game logic to your rendering code. your rendering code would then only be passing GLdouble around, then
17:10:22 <jmcarthur> so you wouldn't be using realToFrac in the middle of OpenGL stuff
17:11:27 <cgroza> @kind Maybe
17:11:28 <lambdabot> * -> *
17:11:47 <Peaker> @sort *
17:11:47 <lambdabot> Maybe you meant: more part src
17:12:58 <photex> ok cool, thanks for the help jmcarthur
17:13:56 * hackagebot yoko 0.1 - generic programming with disbanded constructors  http://hackage.haskell.org/package/yoko-0.1 (NicolasFrisby)
17:26:09 <etpace> Is there a way to force a value of a Unique type to have a certain prefix when pretty printed?
17:27:24 <aavogt> etpace: using show?
17:28:46 <etpace> yeah
17:28:58 <etpace> newTagUnique seems to be what I want!
17:29:01 <etpace> nvm
17:31:04 <OptikJai> Anyone here with any VB.Net experience, can you PM me really quick? The VB channel is dead at the moment and need help with a crucial but really simple problem.
17:35:49 <Peaker> OptikJai: this is not the right channel for that.. people here probably resent VB :) You can try StackOverflow
17:41:04 <Jafet> You can try bothering twenty other channels
17:41:07 <ddarius> VB.Net is basically C# with VB syntax.  VB syntax sucks, but C#'s semantics are okay.
17:41:18 <Jafet> I'm sure someone in one of those channels will help you
17:48:30 <byorgey> augur: I am going to replace the Pointed section anyway
17:54:40 * ddarius recommends deleting the Pointed section.
17:56:52 <ddarius> "Any pair of sets linked by an arbitrary relation [..] is sufficient to define the topological notions of open and of closed subset, and to show that they are the direct outcome of geometrical symmetries and of logical dualities."
17:57:19 <ddarius> "Moreover, pointfree (or formal) topology is seen to have its roots on notions which are symmetric to the usual (pointwise) ones."
17:58:56 * hackagebot highlighting-kate 0.3 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.3 (JohnMacFarlane)
18:45:56 <ddarius> biunivocally
18:56:07 <lars`> @hoogle Reduce
18:56:07 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Convolution Reduce :: ConvolutionBorderMode
18:56:07 <lambdabot> Test.QuickCheck.Property reduceRose :: Rose Result -> IO (Rose Result)
18:56:07 <lambdabot> package reducers
18:56:25 <lars`> @hoogle (>-)
18:56:25 <lambdabot> No results found
18:56:31 <lars`> @hoogle >-
18:56:32 <lambdabot> No results found
18:59:58 <lars`> what is the Reduce class used in http://scienceblogs.com/goodmath/2010/04/finger_trees_done_right_i_hope.php ?
19:45:42 <Sgeo> Hmm
19:46:07 <Sgeo> I wonder if there's a language where potential non-termination is tracked similar to how side-effects are tracked in Haskell
19:47:37 <Jafet> You can extend a total language with a magical non-termination type
19:48:24 <dbelange_> Is a total language one where every program terminates?
19:48:47 <Sgeo> dbelange_, I believe so
19:48:57 <eyebloom> Can anyone explain why the type of the S combinator sComb x y z = x z ( y z ) is ( a -> b -> c) -> (a -> b) -> a -> c
19:49:11 <mauke> well, what else could it be?
19:49:39 <eyebloom> Just having trouble deducing it for myself.
19:50:02 <eyebloom> Working my way through R. Hindley.
19:50:32 <gwern> mauke: maybe it'd be something perverse, like every type has a default value (is a monoid?) and after a timeout, every function returns the default
19:50:40 <mauke> sComb = \x -> \y -> \z -> x z (y z)
19:51:10 <mauke> we can immediately see that sComb takes three arguments and returns some value. sComb :: a -> b -> c -> d
19:51:21 <gwern> (that would be so weird. I wonder what you would use such a timeout-enforced totality for)
19:51:27 <mauke> x :: a; y :: b; z :: c; x z (y z) :: d
19:51:35 <Jafet> gwern: an irc bot
19:51:42 <eyebloom> got all that...
19:51:45 <Jafet> (duh!)
19:51:58 <mauke> y is applied to z
19:52:04 <mauke> so y must be a function
19:52:12 <erider> whew all day hacking haskell "mind bending stuff" but the language rocks! good night all
19:52:13 <gwern> Jafet: heh. yes, that should've been obvious - every function input to mueval has the default value "error: mueval killed etc"
19:52:14 <eyebloom> what is the type of yz
19:52:24 <mauke> b = c -> e
19:52:41 <mauke> I'm simply inventing a new type variable e
19:52:50 <eyebloom> ok
19:53:02 <mauke> then x is called with z and the result of (y z)
19:53:19 <mauke> x :: a = c -> e -> d
19:53:37 <mauke> (d is not a new variable, it's the result type of sComb)
19:53:45 <eyebloom> got that
19:54:16 * ddarius rewards mauke with some premium synthetic oil.
19:54:23 <mauke> so, substituting in sComb :: a -> b -> c -> d, we get sComb :: (c -> e -> d) -> (c -> e) -> c -> d
19:54:42 <irene-knapp> okay, so!
19:54:53 <mauke> and that's the final type (modulo renaming)
19:55:07 <irene-knapp> I have identified something that is actually clearly wrong about the Core produced by my broken build of GHC
19:55:20 <irene-knapp> dictionary-function unfoldings are not stored in identifiers where they can be found
19:55:32 <irene-knapp> unfortunately I have no idea how they're supposed to make their way there ><
19:55:44 <eyebloom> right but doesn't that imply that c = a?
19:55:53 <mauke> eyebloom: no, why?
19:56:36 <mauke> unless you mean c[my_code] = a[original_type]
19:57:36 <eyebloom> Ok, I guess the confusion comes from thinking that the types of the parameters x y z have anything to do with the type-scheme of the function.
19:58:02 <mauke> what's a type-scheme?
19:58:16 <eyebloom> It's Hindley
19:58:29 <eyebloom> 's way of describing a complex type.
19:59:03 <mauke> well, in f = \x -> y, you have f :: a -> b with x :: a and y :: b
19:59:36 <eyebloom> Got that.
19:59:56 <byorgey> a type-scheme is what we would call a polymorphic type, but limited to prenex polymorphism (i.e. no higher-rank polymorphism)
20:00:34 <mauke> so yeah, the parameter types appear in the function type before the arrow
20:00:36 <eyebloom> Isn't sComb a->b->c -> to something you
20:00:41 <eyebloom> are calling d
20:01:17 <eyebloom> but in the polymorphic type statement a and b aren't present any more.
20:01:21 * ddarius sees if his Prolog comment is in his statement history.
20:01:49 <ddarius> Damn, I talk too much.
20:02:04 <eyebloom> and that's the confusing part.
20:02:05 <mauke> I don't know how this works formally, but during type derivation I don't have "normal" type variables
20:02:36 <mauke> I have temporary variables that may spring into existence at any point and may be refined later
20:02:37 <ddarius> They existentially bound (at the meta level,) typically called flexible or unification variables.
20:02:37 <eyebloom> what do you mean by normal?
20:02:41 * gwern has oft regretted his speech, but never ddarius's silence
20:02:56 <mauke> like in a haskell type such as map :: (a -> b) -> [a] -> [b]
20:03:11 <mauke> these type variables represent polymorphism
20:03:47 <mauke> but during type checking a variable 'a' may collapse to a concrete type such as Int or () or whatever
20:03:48 <eyebloom> I guess the part I'm struggling with is if the individual types of x y z are still present in the signature of sComb
20:04:05 <mauke> they are
20:04:17 <mauke> x :: c -> e -> d
20:04:22 <mauke> y :: c -> e
20:04:26 <mauke> z :: c
20:04:34 <ddarius> [23:12] <mauke> x :: a = c -> e -> d
20:04:42 <mauke> sComb :: (c -> e -> d) -> (c -> e) -> c -> d
20:04:53 <eyebloom> ah
20:04:58 <eyebloom> bingo
20:05:15 <eyebloom> thanks thats very helpful.
20:06:29 <CheatEngine> where is functor of the rs server org
20:06:52 <mauke> parse error
20:07:21 <ddarius> "Syntax error" is more retro.
20:07:42 <mauke> ?
20:08:58 * hackagebot clientsession 0.7.3.4 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.3.4 (MichaelSnoyman)
20:11:44 <phoenixsun> Is the Noir framework truely workable solution for web development of is it more experimental atm?
20:12:39 <phoenixsun> the Ocsigen framework I meant to say
20:15:01 <Axman6> never heard of either...
20:25:03 <Sgeo> @hoogle (Monad m) => Int -> m a -> m [a]
20:25:04 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
20:25:04 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
20:25:04 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
20:25:13 <Sgeo> @hoogle (Monad m) => Int -> m a -> m ()
20:25:13 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
20:25:14 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
20:25:14 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
20:26:49 <confab> so a few hours back there was a breif dip into some category theory while explaining endofunctors
20:27:03 <confab> it made me realize i dont have the math necessary to fully understand haskell
20:27:21 <confab> so what is a good basis for haskell?
20:27:31 <confab> like what are topics to learn
20:27:34 <mauke> wait, you have to understand that stuff to understand haskell?
20:27:41 <confab> well no
20:27:42 <mauke> why did nobody tell me
20:28:02 <Sgeo> confab, you don't need to understand the math to understand Haskell, unless you go back in time to become one of Haskell''s designers
20:28:08 <Sgeo> But the math is probably interesting.
20:28:16 <Axman6> confab: i know FA category theory, and i program haskell just fine
20:28:17 <confab> but to have a better understanding of what goes on, or why things are
20:28:40 <ddarius> Sgeo: Most of the designers of Haskell would not describe themselves as mathematicians by any stretch.
20:31:52 <Axman6> confab: knowing CT is certainly not necessary to use haskell proficiently. i've been using it for going on 4 years now, and i know very little CT
20:32:35 <confab> that's reassuring i guess
20:33:06 <ddarius> I'm pretty sure Simon Marlow and Simon Peyton Jones know not much CT.
20:33:25 <Axman6> and they're two of the main authors of GHC
20:34:14 <Axman6> there are people like edwardk who are big into CT (i think?) , and he does lots of interesting (undocumented) stuff using it
20:34:17 <confab> maybe i was just awed by Cale's explanation then
20:35:15 <Cale> confab: I have a degree in mathematics, so that's my excuse :P
20:35:28 <Cale> But yeah, you don't really need to understand any of that
20:35:42 <GordonFreeman> hellou
20:38:18 <confab> Cale: that's both reassuring and disheartening to hear
20:39:42 <ddarius> I don't have a degree in mathematics, and I could quite definitely have explained what Cale explained earlier.
20:40:31 <Cale> confab: You may want to understand it eventually, and it's not really that hard to learn. It can be useful to know category theory from the perspective of having a library of good abstractions in your head for working with things. I could have started from a more foundational point, and it would have taken probably 30 minutes longer :)
20:41:05 <Cale> (but really, you'd probably want to give yourself a bit more time than that for ideas to sink in)
20:41:37 <Cale> You might be interested in Awodey's book which I linked at the time
20:42:15 <byorgey> confab: here's a good very basic starting place: http://en.wikibooks.org/wiki/Haskell/Category_theory
20:42:16 <Cale> It doesn't assume much at all in getting you started
20:48:45 <Sgeo> @src replicateM_
20:48:45 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
20:50:40 <confab> byorgey: thanks for the link
20:50:52 <confab> Cale: i missed the book link, but i'll google it
20:51:15 <Cale> confab: http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
20:52:45 <Sgeo> I seem to have sent some F# person on a wild goose chase looking for the "control monad" by accident
20:53:27 <confab> Cale: cool thanks
20:55:21 <Sgeo> @mtl WriterT [String] Maybe Int
20:55:21 <lambdabot> Maybe you meant: ft map msg pl unmtl url
20:55:26 <Sgeo> @unmtl WriterT [String] Maybe Int
20:55:27 <lambdabot> Maybe (Int, [String])
20:55:34 <confab> hope you dont mind if i peruse that folder/site
21:04:48 <confab> oh wow spivak calculus
21:08:55 <phoenixsun> Axman6: my research shows that Ocsigen is the only web framework available for Haskell
21:09:14 <mauke> haha
21:09:37 <phoenixsun> http://en.wikipedia.org/wiki/Ocsigen
21:10:09 <mauke> that doesn't even mention haskell
21:10:53 <phoenixsun> mauke: Sorry I made a mistake there Haskell has Happstack
21:11:07 <phoenixsun> and SNAP
21:11:40 <mauke> and yesod
21:11:55 <phoenixsun> and a few others...but are any of them being using comercially in a environment where scaling might be an issue?
21:13:11 <c_wraith> yes
21:13:33 <c_wraith> turns out scaling the web server is purely horizontal, no matter what language it's in
21:15:42 <phoenixsun> c_wraith: Thats good because I wanted to really get into a functional programming language but if I could also use it for web development it would be the full package
21:15:58 <c_wraith> that's what my company's using haskell for
21:17:06 <phoenixsun> The another benefit is that I know its has features to lend it to semantic analysis and other NLP stuff which is what I am working on
21:18:28 <Axman6> win 20
21:18:31 <Axman6> whoops
21:18:42 <c_wraith> you have lots of windows
21:19:08 <mauke> "lots"? call me when you're in triple digits
21:20:49 <dufflebunk> pfft, real men just have one. Emacs.
21:21:26 <zeiris> xmonad you mean
21:21:31 <Jafet> emacs isn't a window
21:21:42 <Jafet> It's a way of life, or something
21:21:46 <mauke> http://www.youtube.com/watch?v=HU2ftCitvyQ
21:23:21 * dufflebunk notes that ubuntu 11.10's Unity doesn't play nicely with xmonad 
21:25:58 <c_wraith> people still use ubuntu?  I thought everyone had moved to mint
21:27:10 <dufflebunk> I haven't... yet. I'm hoping I suddently realize what's so great about Unity.
21:27:28 <dufflebunk> So far it has just been annoying the crap out of me.
21:28:01 * monochrom uses ubuntu and unity just fine
21:28:24 <Axman6> does anyone here use yesod? #yesod seems to be next to useless for getting anything answered
21:29:15 <dbelange_> Cale: Stop asking me to donate to wikipedia
21:29:18 * ddarius uses an old version of Ubuntu and has never even heard of mint.
21:29:23 <dbelange_> Cale: the answer is no
21:29:45 <Axman6> o.O
21:29:52 <ddarius> Axman6: It makes sense.
21:30:26 <Cale> c_wraith: I'm still on Ubuntu, but I'm planning to switch to Debian.
21:30:46 <c_wraith> technically, I'm still using ubuntu, but only pre-unity versions
21:31:45 <Axman6> ddarius: what does, that no one can answer any of my questions?
21:31:47 <morolin> c_wraith: I've been using Unity on one of my computers.... probably going to switch to Mint soon.
21:32:10 * monochrom prefers unity
21:32:36 <morolin> monochrom: really?  You're the first I've met.
21:38:23 <ddarius> Axman6: I was responding to "o.O".
21:38:42 <Axman6> ddarius: oh, the o.O was to dbelange_'s comments
21:38:51 * ddarius doesn't see Unity having any impact whatsoever on him other than being another piece of software I will uninstall when upgrading.
21:38:53 <ddarius> Axman6: I know.
21:39:46 <moriramar> I just thought here is #ubuntu....
21:41:09 <ddarius> Axman6: Did you actually ask a question in #yesod, or did you just ask if someone in #yesod used Yesod?
21:41:43 <Axman6> i did ask a pretty specific question, yes
21:42:03 <Axman6> it's about the fourth question in as many days that has gone unanswered
21:48:11 <ddarius> If you discard equality, you can't identify {s‚ààS|P(s)} with {f(i)|i‚ààI} where f : I -> S as notions of subsets of S.
21:57:40 <ddarius> One consequence of this is while the former P ‚àà Pow(S) behaves as usual and in particular for relations we have the isomorphism R ‚àà Pow(S√óT) ‚âÖ S ‚Üí Pow(T) and R is completely symmetric in S and T, these two isomorphic views split into two notions for (f,I) ‚àà Fam(S).  Namely, (r,I) ‚àà Fam(S√óT), i.e. r is a span, or (r,I) : S ‚Üí Fam(T) in which case we get an asymmetric transition structure.
22:13:33 <DevHC> awesome message :P:
22:13:34 <DevHC>     Identifier `defaultAddonState' has conflicting definitions in the module and its hs-boot file
22:13:34 <DevHC>     Main module: defaultAddonState :: AddonState
22:13:34 <DevHC>     Boot file:   defaultAddonState :: AddonState
22:18:10 <DevHC> so uhm
22:18:38 <DevHC> why can't i have "data AddonState" in X.hs-boot, and have "type AddonState = ()" in X.hs ?
22:19:37 <DevHC> meh, why even require hs-boot files... so basically nvm
22:34:22 <wavewave> hs-boot is required when you have mutually dependentmodules
22:35:23 <wavewave> DevHC: http://www.haskell.org/haskellwiki/Mutually_recursive_modules
22:36:10 <wavewave> hs-boot should not have a definition..
22:37:34 <DevHC> wavewave: u urself don't know what u've just said
22:38:19 <wavewave> DevHC: hmm.. I am reading the manual..
22:38:36 <wavewave> DevHC: there are special rules for hs-boot file.
22:38:53 <DevHC> -special
22:39:13 <wavewave> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
22:39:25 <wavewave> hs-boot file is a subset of haskell
22:39:36 <DevHC> the hs-boot stuff is GHC-specific, and can be defined by GHC-d00ds in any way, we shouldn't call the rules "special"
22:39:55 <DevHC> hs-boot is NOT a subset of Haskell
22:39:57 <wavewave> whatever.
22:40:19 <wavewave> I just read a sentence in the manual.
22:40:46 <wavewave> you may be able to solve the problem from the guide.
22:40:49 <DevHC> i am using mutually recursive modules, and an untrusted source will provide an X.hs files that i will (automatically) use
22:41:06 <DevHC> X.hs must define a type: AddonState
22:41:10 <NemesisD> hi all. i think i may be standing on the precipice of dependency hell but i'm not sure
22:41:20 <DevHC> i feel like i should allow using either or the following:
22:41:30 <DevHC> data AddonState = MyAddonState ...
22:41:36 <DevHC> type AddonState = Integer
22:41:39 <DevHC> etc.
22:41:46 <NemesisD> cmdrgs-0.9-..... unusable due to missing or recursive dependencies: template-haskell-2.5.0.0-....
22:42:16 <NemesisD> i've tried reinstalling template-haskell  and the same thing happens
22:42:41 <wavewave> DevHC: did you see the link I sent/
22:42:41 <gienah> NemesisD: reinstalling template-haskell seems a bit rash
22:42:57 <DevHC> not really
22:43:08 <NemesisD> what is the appropriate response
22:43:08 <wavewave> data XXX should not have right hand side in hs-boot file.
22:43:12 <DevHC> (which one of thw TWO links btw)
22:43:19 <wavewave> type XX = dkd is okay
22:43:26 <wavewave> user's guide .
22:43:59 <DevHC> yes. so?
22:44:19 <gienah> NemesisD: I wonder which pkg wants template-haskell-2.5.0.0, I though cmdargs-0.9 would install fine, maybe its one of its dependencies that wants it
22:44:51 <wavewave> DevHC : I inform you of relevant info. That's it.
22:44:58 <DevHC> not really
22:45:05 <DevHC> let me explain
22:45:11 <wavewave> what was your question?
22:45:16 <DevHC> we have 2 modules:
22:45:44 <wavewave> hs-boot file is  a kind of interface information file.
22:46:01 <wavewave> without value definition.
22:46:04 <NemesisD> i guess ill just try using cabal-dev
22:46:16 <NemesisD> wish it didn't take up so much space
22:46:25 <wavewave> or you can exchange interface with 'type'
22:46:36 <gienah> NemesisD: I guess, although I don't really get it as cmdargs-0.9 does not list template-haskell as a dependency
22:47:28 <gienah> NemesisD: oh its optional: if flag(quotation) build-depends: template-haskell
22:47:32 <DevHC> H.hs: module H (f) where ; import X (AddonState) ; f :: AddonState -> IO () ; f = ...
22:48:34 <DevHC> X.hs-boot: module X (AddonState) where ; import H ; data AddonState
22:48:50 <DevHC> X.hs: <insert what U want here>
22:49:14 <DevHC> suppose that u want this setup to work with ur following definition of AddonState:
22:49:19 <DevHC> type AddonState = Integer
22:49:24 <DevHC> then u're in deeeeeeeeep shit
22:49:45 <DevHC> (and u don't have access to X.hs-boot !)
22:50:57 <wavewave> DevHC: hmm you want to have data AddOnState in X.hs-boot and type AddOnState in X.hs ?
22:51:14 <wavewave> DevHC: sounds not consistent to me
22:51:41 <DevHC> more precisely: i want to have the following semi-haskellish-bootish thing in X.hs-boot:
22:51:44 <wavewave> hs-boot file must have the same info as hs file
22:51:56 <DevHC> data_or_type_or_newtype_or_whatever AddonState
22:52:19 <DevHC> and allow U to use either one of the following in X.hs, for ur preference:
22:52:28 <DevHC> data AddonState = MyAddonStateData ...
22:52:33 <wavewave> I aww.
22:52:34 <DevHC> type AddonState = ...
22:52:36 <DevHC> etc.
22:52:36 <wavewave> I see
22:53:39 <ddarius> DevHC: Why don't you just break the cycle the other way?
22:53:40 <wavewave> how about using typeclass?
22:54:43 <DevHC> ddarius: name the "other way", if it's less cumbersome
22:55:01 <DevHC> wavewave: wat? typeclass AddonState = ...?
22:55:39 <wavewave> f :: (AddOnStateClass c) => c -> ...
22:55:50 <ddarius> DevHC: At this point you don't have something that works, so cumbersomeness is not an issue.
22:56:28 <ddarius> The other way would be to make a H.hs-boot file.
22:56:34 <DevHC> ddarius: i have everything working
22:56:44 <DevHC> ddarius: with the exception of allowing "type AddonState = ..."
22:56:45 <ddarius> Then what's the problem?
22:56:46 <wavewave> C.hs has AddonstateClass and
22:56:49 <DevHC> wavewave: no no no, that would be WRONG in this use case:
22:56:54 <ddarius> Then you don't have something that works.
22:57:33 <wavewave> H.hs depends on C.hs, X.hs depends on C.hs but not depends on H.hs
22:57:34 <DevHC> f a = newStablePtr a >>= poke global_memory
22:57:49 <DevHC> g = peek global_memory a >>= peek
22:58:11 <DevHC> here f and g must have corresponding types
22:58:26 <DevHC> ie., f :: AddonState -> IO (), and g :: IO AddonState
22:59:06 <DevHC> and definitely not: f :: (AddonStateClass c) => c -> IO () ; g :: (AddonStateClass c) => IO c
22:59:17 <DevHC> ddarius: WRONG
23:00:14 <DevHC> ddarius: what i have works very well... but it would be neat for some very very very very special cases where one would want to use "type AddonState = Integer" instead of "data AddonState = AS Integer"
23:00:40 <wavewave> f ::  (Ptrable a, AddonStateClass a) => a -> IO ()  :-P
23:00:43 <wavewave> joke.
23:01:38 <wavewave> in fact not a true joke.
23:01:52 <wavewave> anyway.. probably you don't prefer it.
23:02:03 <DevHC> "it"?
23:02:45 <wavewave> ah. just   class Ptrable a where newStablePtr_ :: IO (Ptr a) blahblah
23:03:35 <wavewave> then f :: (Ptrable a , AddonStateClass a ) = a -> IO ()
23:03:37 <DevHC> wavewave: unfortunately i don't want to allow access to pointers, only to 2 storage spaces
23:03:48 <DevHC> 1 global variable of type GlobalAddonState
23:03:50 <wavewave> f a=  newStablePtr_ a >>= ...
23:05:16 <DevHC> one AddonState for every "entity" which spawns (at most ~1024 entities), and that state starts out as (defaultAddonState :: AddonState), can be read/modified by specifying an entity number, and the addon state automatically vanishes with the entity with
23:06:15 <DevHC> wavewave: no such thing as newStablePtr_ btw
23:08:22 <wavewave> anyway, typeclass can be a solution for similar recursive dependency problems.. hope that you find a nice solution.
23:08:52 <gienah> I try to patch HsOpenSSL to compile with ghc 6.12.3, I'm not sure if this fixes it or breaks it: https://github.com/gentoo-haskell/gentoo-haskell/blob/e6e8d42783e3ea74fbdeccf7cc373bcb64af472d/dev-haskell/hsopenssl/files/HsOpenSSL-0.10.1.2-ghc-6.12.patch
23:28:59 * hackagebot delta-h 0.0.1 - Online entropy-based model of lexical category acquisition.  http://hackage.haskell.org/package/delta-h-0.0.1 (GrzegorzChrupala)
23:30:13 <ursthegiz> hello, I must admit, I have some difficulties in Cabal on windows with FFI, question: is it a problem, to have two msvcrt loaded (objdump -p <exe> | grep dll shows msvcrt two times)?
23:31:16 <xil> hi. I thought that tuples of enumerable types like (Int,Int) were also enumerable, but I'm finding now that they aren't? I tried "[(0,0)..(3,3)] :: [(Int,Int)]" in  the interpreter just to test it and I'm getting a complaint about enumerability
23:31:58 <augur> byorgey: http://haskell.org/haskellwiki/Why_not_Pointed%3F
23:32:04 <augur> Why not Zoidberg?
23:32:13 <augur> Pointed is the Zoidberg of functors
23:32:59 <kulin> Anyone in here have experience with gtk2hs actions & accelerators? My understanding is that an action is simply a tagged struct containing an function with type IO () and that an accelerator is a hotkey that can be assigned to an action. All of the gtk+ documentation I read has examples using accelerator groups but I find the same types not fully wrapped in gtk2hs. Am I going down the wrong path and are there any examples of gtk2hs 
23:34:08 <ddarius> xil: There is not an Enum instance for pairs in the standard library.
23:34:46 <xil> ddarius: I see. I can just use list composition then. Thanks though =]
23:43:40 <ddarius> > range ((0,0), (3,3))
23:43:41 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
23:50:24 <Sgeo> Is it just my imagination, or are there some similarities between the Error monad and checked exceptions in Java?
23:52:22 <ddarius> There are similarities.  There are also differences.
