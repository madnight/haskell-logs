00:00:28 <Sgeo> ddarius, because the type can say that it will accept values of at most a certain value... and now I'm thinking that that's not actually that useful
00:00:39 <Sgeo> Because any given [] can only have one type
00:01:08 <Sgeo> Might as well use type-level peanos I guess
00:01:53 <Jafet> Make sure they're in tune
00:02:24 <shachaf> Sgeo: You're talking about types like Maybe (Maybe (Maybe ())), which is inhabited by Nothing, Just Nothing, Just (Just Nothing), and Just (Just (Just ()))?
00:02:41 <Sgeo> shachaf, yes
00:03:47 <shachaf> You might as well use data Num = Zero | One | Two | Three
00:07:25 <augur> i prefer Fin :)
00:07:37 <augur> but then, this is #haskell not #agda or #epigram
00:08:03 <augur> SHE can do it!
00:08:46 <ion> data Num = Zero | One | Two | Many
00:09:45 <augur> ion: Piraha Haskell?
00:10:02 <augur> PiraHãskell
00:16:13 <applicative> data Piralist a = None | One a | Two a a | Many a a [a]
00:17:14 * applicative thinks hes seen pirahalists defined before
00:18:16 <jpcooper> hello
00:18:42 <Jafet> That looks like a fingertree node
00:18:55 <Jafet> I guess that's where fingertrees come from, people counting on their fingers
00:19:48 <jpcooper> I have compiled a programme with -rtsopts -prof and inside it there are two pragmas "{-# SCC "X" #-} and "{-# "Y" #-}". I run the programme with +RTS -hc, and when I look at the profile I see two graphs, one named "(234)Main.CAF" and the other named "(236)Y/Main.CAF". Why should the X not show?
00:20:15 <drdetroit> occupy la is live- police are moving in RIGHT NOW - in white suits - THOUSANDS - live- in 7 minutes they start action -  tune in http://www.ustream.tv/occupyoakland
00:20:25 <drdetroit> this is history here
00:21:07 <Jafet> jpcooper: perhaps there are no samples collected for X
00:21:59 <jpcooper> Jafet: I'll paste my code
00:22:07 <augur> drdetroit: get out.
00:22:23 <Jafet> augur: thatsracist.gif
00:22:30 <hpaste> jpcooper pasted “profiling issues” at http://hpaste.org/54697
00:22:41 <dskippy> Does anyone know how to sleep in Windows? I can't cabal install posix-timer, which is where Google has told me to get System.Posix.sleep
00:22:45 <augur> im totally racist against spammers
00:23:59 <jpcooper> Jafet: any ideas?
00:24:13 <Jafet> None
00:24:37 <ukl> hello.  I just stumbled upon a problem using DBus.Client.Simple under FreeBSD (to connect taffybar and xmonad), whenever I call, in an X session that has eval dbus-launch'ed, connectSession (e.g. via ghci), I get a vanished resource error -- just like the person who hpasted this: http://hpaste.org/steps/51047
00:24:49 <Jafet> Woah, hpaste links irc context.
00:25:04 <ukl> so, is this person around (and has she or he found a way around)?
00:25:17 <Jafet> Now I'll praise chrisdone here, for posterity.
00:26:29 <Jafet> jpcooper: I'm not sure how cost-centres are interpreted in do-blocks. What if you move them after $?
00:28:21 <merl_> gtk2hs on mac. Having problems.  Used the wiki suggestion: brew for installing the base stuff, then cabal.  gtk-test works. But cabal install gtk gives warnings: ld: warning: in /usr/local/Cellar/gtk+/2.24.6/lib/libgtk-x11-2.0.dylib, file was built for unsupported file format which is not the architecture being linked (i386)
00:29:02 <jpcooper> Jafet: I'll try that
00:30:24 <jpcooper> same problem
00:32:22 <nabeshin_> anyone around?
00:32:30 <applicative> merl_ you have 32 bit ghc, 64 bit gtk libraries, no? maybe homebrews gtk+.rb has a 32 bit switch, I can't remember
00:33:17 <applicative> merl_ or '--universal', like macports; homebrew has it too, but i don't know how systematic it is
00:33:57 <nabeshin_> let's say I have a function whose signature is String -> String. Whenever this function is called, i want to print some message to stderr. how can I do this without changing the function's signature to String -> String IO?
00:34:32 <merl_> Ah. Can't mix'n'match. What's my best strategy? Try and reinstall libraries to 32 bit I guess.
00:34:54 <dskippy> nabeshin_: It's not possible, mostly. However there are some ways to sort of do what you want.
00:34:55 <applicative> if it is just for debugging there is trace
00:35:01 <dskippy> nabeshin_: You could use the trace library.
00:35:15 <dskippy> nabeshin_: You could also use UnsafeIO
00:35:17 <Jafet> @quote oasis
00:35:18 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
00:35:26 <applicative> Jafet: you beat me
00:35:34 <dskippy> nabeshin_: Neither of these are recommended for production code. But if you're looking to print debug, they are great.
00:37:17 <dskippy> nabeshin_: But if you actually want something that prints and returns a string, in actual permanent code, then any Haskell programmer will tell you you should want the type to be "String -> IO String" since that's what's happening in the function.
00:38:11 <nabeshin_> looks like trace will work for me. thanks!
00:38:42 <Jafet> Sometimes it is not enough. I once had unsafePerformIO . unsafeSTToIO . unsafeFreeze
00:39:33 <dskippy> I will occasionally use unsafe IO for more complicated print debugging than I can do with trace, but it's rare.
00:49:08 <Jafet> jpcooper: WFM
00:49:23 <Jafet> I assume you meant -hcX,Y -p
00:51:12 <Jafet> Well, which is the same thing as -p
00:52:03 <jpcooper> Jafet: I've been trying that without -p and it hasn't been outputting a .hp file
00:52:08 <merl_> 64bit Haskell platform for mac install fails with no useful info. :(
00:52:37 <Jafet> Of course it wouldn't.
00:53:04 <dskippy> Does anyone know how to do a sleep in Windows GHC? Or more generally, create an infinite loop that is not CPU bound and allows the CPU to do other things while my condition is not met?
00:53:17 <Jafet> @hoogle threadDelay
00:53:17 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
00:53:17 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
00:53:17 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
00:53:23 <Jafet> Is but one way
00:53:28 <jpcooper> Jafet: why shouldn't it?
00:53:42 <Jafet> -p means profile. No -p, no profile
00:53:42 <dskippy> Jafet: Thanks. Reading about that now.
00:53:59 <d34df00d> Hi!
00:54:19 <Jafet> Hmm, you're actually making a heap profile. Still, I don't think it's any different.
00:54:24 <jpcooper> Jafet: with -p along with -hcX,Y a hp file isn't output either
00:54:24 <d34df00d> I need to store a small array of function identifiers and lookup the corresponding functions quite often.
00:54:53 <mauke> what's a function identifier?
00:54:54 <d34df00d> I once used an association list like `binaryOps = [ (Plus, (+)), (Minus, (-)), (Mul, (*)), (Div, (/)), (Pow, (**)) ]`
00:55:17 <d34df00d> mauke: one of constructors of a data type, basically.
00:55:26 <d34df00d> But that's slow and stupid, since the list is static.
00:55:54 <d34df00d> So I rewrote it as a function `binaryOps :: Floating a => BinaryFunc -> a -> a -> a`
00:56:02 <napping> Why do you need to use identifiers?
00:56:30 <d34df00d> napping: hm. Let me look up :)
00:56:38 <d34df00d> I haven't touched that code for a couple of weeks so forgot a bit.
00:57:01 <merl_> solution: extra uninstall of the 32 bit version needed in order to install 64 bit: http://projects.haskell.org/pipermail/haskell-platform/2011-June/001600.html
00:57:12 <napping> I could start suggsting things, but if you have a good reason to be looking things up from an identifier over and over again they might not be very good suggestions
00:58:15 <napping> but now that I think a bit more, a function using a case statement should always win over the association list
00:59:05 <d34df00d> napping: well, I've done something like that.
00:59:16 <d34df00d> With pattern matching instead of case statement.
00:59:39 <mauke> pattern matching *is* case
01:00:19 <d34df00d> Yes, I just meant I've expressed the same thing a bit differently :)
01:00:21 <napping> You can get warnings if you have left out or repeated some,
01:01:07 <d34df00d> So, this actually makes things much better — that binaryOps stuff used to take 20% of CPU and 50% of allocations.
01:01:33 <d34df00d> Now it takes relatively the same amount of CPU, quite less allocs, and the primary function using it is also considerably faster.
01:01:49 <napping> I guess it's some kind of interpreter or evaluator?
01:01:53 <d34df00d> Yep.
01:02:06 <d34df00d> Well, this is all for representing mathematical expressions as trees, for applying genetic algorithms over it.
01:02:20 <d34df00d> Symbolic regression, that kind of thing :)
01:03:01 <napping> Ah, I guess that's a good reason for not trying to compile the programs
01:03:22 <d34df00d> So, I need to keep something in the nodes of my trees to represent the functions used. I'd also like to be able to parse hand-written expressions into trees, and that's the reason I chose to use identifiers instead of the functions themselves.
01:03:52 <napping> If you need to evaluate a function several times or have something like loops, it might help to look up the functions once
01:06:48 <d34df00d> Hmm, I could surely use `data ExprTree a = NUn (a -> a) (ExprTree a)` instead of `data ExprTree a = NUn UnaryFunc (ExprTree a)`, right?
01:07:52 <d34df00d> Oh... Rather not. I need my trees to be instances of Ord and Eq, particularly, and hand-writing the instances for different functions seems like a bad idea to me.
01:09:02 <Jafet> data UnaryFunc a = UF String (a -> a); unaryFunc s = UF s (lookup s)
01:11:16 <d34df00d> Jafet: hm, why it's better?
01:11:38 <d34df00d> Plain pattern-matching uses no lookups at all, so seems like compiler could optimize it better.
01:11:59 <d34df00d> Ah, and seems like I forgot to ask my question :)
01:12:24 <d34df00d> Why do functions evalTree and binaryOps still are #1 and #2 cost centres, though they now looke like this:
01:13:16 <d34df00d> http://dpaste.com/663744/
01:15:06 <napping> why wouldn't they be?
01:15:13 <napping> are you doing anything else that might be expensive?
01:15:23 <napping> The total runtime should go down, though
01:16:59 <d34df00d> Yes it does, but I'm still a bit confused by the number of allocations. 33% for the binaryOps function.
01:18:00 <d34df00d> I'm also having a function that calculates jacobian of the expression represented as tree, taking the corresponding number of partial derivatives, and I expected it to be quite costy, though it takes only 4-5%.
01:18:52 <d34df00d> And I also have quite a lot of operations with matrices, since I use Levenberg-Marquardt algorithm for optimizing the constants in my trees, but, for example, matrix multiplication takes only 10-12%.
01:20:25 <quicksilver> you're using -auto-all for your profiling?
01:20:29 <napping> Still, don't you evaluate the expression many more times than you do the other stuff?
01:20:57 <napping> The allocation is surprising - are you building without -O?
01:21:01 <quicksilver> CCs everywhere inhibit some optimisations. Without profiling and with optimisation I'd expect 'binaryOps' to get online and do no allocation.
01:21:08 <d34df00d> quicksilver: yes.
01:21:32 <quicksilver> it's not a problem, but just be aware that profiling makes things slower and generally increases allocation by defeating optimisation.
01:21:33 <d34df00d> napping: nope, I do -O2, though quicksilver is right, I'm using -auto-all for profiling.
01:21:51 <napping> The Floating => may leave dictionary passing
01:22:01 <d34df00d> napping: hmmm, why?
01:22:10 <quicksilver> napping: unless its inlined, which it would be without profiling I will guess.
01:22:15 <napping> because that's how Floating => compiles
01:22:42 <napping> the question is whether you have a call site that specializes it, and whether it can be inlined enough to optimize away
01:23:22 <d34df00d> I generally work with Doubles anyway, so can I forcefully specialize it, for example?
01:23:55 <aadrake> exit
01:24:06 <napping> Yeah, even just with a SPECIALIZE pragma
01:26:11 <d34df00d> I guess I couldn't go without Floating a => thing, since otherwise the compiler complains to (**), for example.
01:26:19 <d34df00d> And a couple of other bindings.
01:26:32 <d34df00d> s/bindings/equations/
01:26:35 <jpcooper> Jafet: so I think there was a problem with 7.0.2, as I've installed 7.2.2 and now all is well
01:27:09 <Jafet> I'm on 7.0.3
01:32:36 <d34df00d> Hm, without specializing evalTree it works better.
01:33:13 <napping> why can't you specialize to Double?
01:33:35 <d34df00d> Just did it, ran it, and it works considerably slower, and evalTree takes twice much CPU time in profiling report.
01:33:50 <d34df00d> Ran two times to try to eliminate random factors.
01:34:09 <quicksilver> don't test performance with profiling on.
01:34:20 <quicksilver> test performance with profiling off; put profiling on to identify hotspots.
01:34:48 <quicksilver> profiling changes program behaviour quite substantially but hopefully doesn't re-order your hotspots too badly ;)
01:37:22 <d34df00d> Ok, thanks, I'd run it without profiling a few more times.
01:47:59 <hpaste> o1iver pasted “io monad scoping” at http://hpaste.org/54698
01:48:49 <o1iver> hey. I was wondering if someone could explain something about "scoping" in the monad world to me. In the above pasted example, how come the las expression still has access to the value of "first"?
01:49:05 <o1iver> s/las/last
01:49:20 <Waldteufel> o1iver: maybe it becomes more clear if you add parentheses
01:49:35 <ukl> Is there any way to have a trace from an exception?  e.g., I have a programm that exits with "Main2: <socket: 3>: hPutBuf: resource vanished (Broken pipe)" and I'd like to find out more about this hPutBuf to find the bug/problem
01:49:47 <o1iver> Waldteufel: so its because it is "kind-off" computed in reverse?
01:50:24 <Jafet> Monads have nothing to do with scoping
01:50:29 <hpaste> Waldteufel annotated “io monad scoping” with “io monad scoping (annotation)” at http://hpaste.org/54698#a54699
01:51:07 <o1iver> Jafet: I just called it that for lack of a better word
01:51:09 <Jafet> > (\x -> \y -> x + y) 2 2
01:51:09 <lambdabot>   4
01:51:18 <Waldteufel> o1iver: it's not really computed. think of IO as a data type for a description of a computation
01:52:24 <Waldteufel> so for example main :: IO () means main is a _constant_ computation
01:52:24 <o1iver> Waldteufel: yeah, I think I get that part...
01:52:48 * Jafet reaches for the popcorn
01:52:56 <o1iver> Waldteufel: I was just unsure about where the first/last values are "saved" :-)
01:53:19 <Waldteufel> hmm… they are not really saved
01:53:35 <Jafet> They are stored somewhere as long as the program refers to them.
01:53:38 <o1iver> Waldteufel: yeah I must say choosing the right words is hard here :-p
01:53:46 <o1iver> Jafet: thats what I mean
01:53:50 <Waldteufel> well obviously they are saved at runtime somewhere in memory
01:54:17 <Waldteufel> but it's like defining f(x) = 2*x^2 in math and asking where the x is saved
01:54:42 <o1iver> Waldteufel: yes true
01:54:43 <Jafet> It's a relevant question when computing f(x).
01:55:34 <Waldteufel> o1iver: essentially you have been right. the whole thing is evaluated from left to right to yield a computation
01:55:53 <o1iver> So the last putStrLn chunk gets incrementally completed (first insert last, then first, the putStr)?
01:56:01 <DevHC> what's r linux distribution with decent GHC versions?
01:56:04 <Jafet> That is incorrect. Nothing is evaluated until it is required.
01:56:13 <DevHC> (ie., 7.2.2 if possible something)
01:56:16 <Waldteufel> >.<
01:56:22 <DevHC> what r*
01:56:55 <o1iver> Jafet: yes, but thats what I mean... I think of it as pulling... Because bind must "unwarp" itself
01:57:09 <Jafet> I was correcting Waldteufel.
01:57:10 <c_wraith> DevHC: I believe arch has the best support for ghc and hackage, but I'm not sure even it will use the 7.2 series.  the 7.2 series was never intended for production use
01:57:15 <sepp2k> o1iver: The only thing that matters here (as far as your original question is concerned) is that when you do (\x -> whatever), x can be used until the closing parentheses. And when you do "\x -> foo >>= \y -> bar" that gets parenthesized as "(\x -> foo >>= (\y -> bar))", so you can use x in bar, because that's how far the function goes.
01:57:28 <Waldteufel> Jafet: touché, it wasn't a good analogy :/
01:57:42 <Jafet> It wasn't an analogy to begin with
01:58:02 <o1iver> sepp2k: ha...I am an idiot, that is exactly what was missing, sure... I was looking at it too hard :-p
01:58:44 <o1iver> thanks Waldteufel Jafet sepp2k
01:59:54 <gienah> DevHC: the gentoo haskell overlay has ghc 7.2.2 (and 7.0.4, 6.12.3)
02:00:36 <DevHC> what about centos?
02:01:54 <gienah> DevHC: http://justhaskell.org/2011/10/25/enterprise-linux-for-haskell/
02:17:45 <absence> trying to familiarise myself with monoids. is there a better way to reimplement the and function than "and' = getAll . mconcat . fmap All"?
02:19:05 <ion> > ala All foldMap [True, True, True, False, True]
02:19:05 <lambdabot>   Not in scope: `foldMap'
02:19:10 <ion> > ala All Data.Foldable.foldMap [True, True, True, False, True]
02:19:11 <lambdabot>   False
02:19:38 <Axman6> @instances Monoid
02:19:38 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:19:48 <Axman6> huh, i'd never seen All and Any
02:19:53 <Axman6> what's Dual?
02:20:29 <ion> > getDual (Dual "foo" `mappend` Dual "bar")
02:20:29 <lambdabot>   "barfoo"
02:20:57 <Axman6> :t Dual "hello"
02:20:58 <lambdabot> Dual [Char]
02:21:03 <Axman6> :t Dual
02:21:04 <lambdabot> forall a. a -> Dual a
02:21:18 <Axman6> hmm. does a have to be a monoid?
02:21:39 <alistra> Endo?
02:21:46 <chra> instance Monoid a => Monoid (Dual a) -- Yes.
02:21:52 <alistra> in your Endo!
02:22:14 <Axman6> ok, excellent
02:22:30 <Axman6> so, how does Dual differ from the standard Monoid instance for a then?
02:22:38 <chra> -- | The dual of a monoid, obtained by swapping the arguments of 'mappend'.
02:22:45 <chra> Dual x `mappend` Dual y = Dual (y `mappend` x)
02:22:49 <ion> a doesn’t have to be monoid unless you want to use one of the monoid functions on the Dual value.
02:23:00 <Axman6> ah, how odd
02:23:08 <Axman6> i didn't see the order was swapped
02:25:14 <absence> ion: what's ala?
02:25:26 <ocharles> Does anyone know what the status of the detailed test-suite for cabal is?
02:25:32 <ion> @hackage newtype
02:25:32 <lambdabot> http://hackage.haskell.org/package/newtype
02:25:33 <ocharles> has it made it into darcs?
02:25:34 <ion> absence: ↑
02:26:13 <alistra> @hoogle Dual
02:26:13 <lambdabot> Data.Monoid Dual :: a -> Dual a
02:26:13 <lambdabot> Data.Monoid newtype Dual a
02:26:13 <lambdabot> Data.Monoid getDual :: Dual a -> a
02:27:50 <alistra> > msum $ map Endo ["hate", "gonna ", "haters "]
02:27:50 <lambdabot>   Couldn't match expected type `a -> a'
02:27:51 <lambdabot>         against inferred type `[GHC.T...
02:27:59 <alistra> > msum $ map Dual ["hate", "gonna ", "haters "]
02:28:00 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Dual)
02:28:00 <lambdabot>    arising from ...
02:28:20 <alistra> > msum  [Dual "hate", Dual "gonna ", Dual "haters "]
02:28:20 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Dual)
02:28:20 <lambdabot>    arising from ...
02:28:42 <ion> mconcat?
02:28:47 <alistra> > mconcat  [Dual "hate", Dual "gonna ", Dual "haters "]
02:28:47 <lambdabot>   Dual {getDual = "haters gonna hate"}
02:28:54 <alistra> ion++ thanks lol
02:28:57 <absence> ion: ah, thanks. so before newtype, getAll/mconcat/fmap was the way?
02:29:01 <alistra> monad plus has a zero
02:29:25 <alistra> > msum [] :: Int
02:29:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:29:26 <lambdabot>         against inferred type ...
02:29:29 <alistra> > msum []
02:29:29 <lambdabot>   No instance for (GHC.Show.Show (m a))
02:29:29 <lambdabot>    arising from a use of `M1631326974...
02:29:37 <alistra> > (msum [])  :: Int
02:29:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:29:38 <lambdabot>         against inferred type ...
02:29:41 <alistra> > (msum [])  :: Integer
02:29:41 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
02:29:41 <lambdabot>         against inf...
02:29:46 <alistra> ah whatever
02:30:07 <ion> absence: Newtype just provides a more convenient interface for operations under newtypes such as All where you don’t need to unpack values out of them manually.
02:31:35 <absence> ion: yes i understand, what i meant is that there aren't any other ways than newtype to improve the and' i pasted?
02:33:50 <ion> absence: mconcat only handles lists, so the “fmap” is always just “map”. If you want to be generic, keep the fmap but replace “mconcat” with “fold” from Data.Foldable. You can also replace “fold . fmap f” with “foldMap f”. And “getAll . foldMap All” is the same as “ala All foldMap”.
02:39:18 <carpi> in a do block i always have to do "let x = 3" and I can't do "x = 3".. like I would do in a normal function?
02:40:14 <ion> You can’t have just “x = 3” in the definition of a “normal” value either.
02:40:33 <carpi> in ghci you can't.. its true..
02:40:33 <Jaak> you can in global scope
02:41:03 <Jaak> but yes, in do block you need to use let
02:41:27 <absence> ion: there are lots of weird characters in what you type, but i managed to pick "getAll . foldMap All" out of it, which is cleaner. thanks :)
02:41:31 <Jaak> or x <- return 3 which is bad style
02:42:28 <ion> absence: If you see the quotation marks incorrectly, your IRC client may need configuring. It’s unusual for an IRC client not to support UTF-8 by default nowadays, though.
02:45:17 <carpi> is there any way to get the type of a value at runtime?
02:45:22 <carpi> i suppose there wouldn't be
02:45:42 <ion> Why do you need it?
02:46:41 <carpi> ion: i don't. Just curious. Because I reasoned that in a language like Haskell you wouldn't need that sort of information at runtime. It's redundant.. But I am not sure If i am correct..
02:47:05 <absence> ion: ah, switched the terminal to utf-8 and now there's suddenly more text that was gobbled up earlier :D great
02:47:39 <ion> > (show . typeOf) 42
02:47:40 <lambdabot>   "Integer"
02:47:41 <Jaak> i think you can do that with Data.Typeable
02:47:42 <absence> (that is, the invalid formatting somehow swallowed parts of your answer. makes more sense now)
02:48:27 <carpi> so its possible.. but is there a situation where that kind of information might be required?
02:48:27 <ion> typeOf already knows the type in compile time. Its result value can be inlined, so if you use (show . typeOf), the compiled code may very well just contain the string constant "Integer" or whatever.
02:48:29 <Jaak> > typeOf 1
02:48:29 <lambdabot>   Integer
02:48:56 <plat0> Yes, I am wondering how typeOf can ever help you.
02:49:13 <ion> Serializing values for sending over the network.
02:52:02 <carpi> ah yes.. otherwise the receiving end of the network wouldn't know what they are getting
02:52:32 <Axman6> plat0: it can be used in conjunction with Dynamic/Any to avoid the type system basically, for those times when you know something is safe, but you can't quite get the compiler to believe you
02:52:47 <int-e> plat0: it's not necessarily known at compile time; a function Typeable a => a -> something can be compiled without knowing what concrete type a will have
02:53:16 <Axman6> @hoogle dynamic
02:53:16 <lambdabot> Data.Dynamic module Data.Dynamic
02:53:16 <lambdabot> Data.Dynamic data Dynamic
02:53:16 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects DynamicCopy :: BufferUsage
02:53:20 <plat0> Axman6: interesting, I would like to see some examples of this.
02:53:24 <Axman6> @hoogle toDynamic
02:53:24 <lambdabot> No results found
02:53:27 <Axman6> :\
02:53:31 <Axman6> @hoogle toDyn
02:53:31 <lambdabot> Data.Dynamic toDyn :: Typeable a => a -> Dynamic
02:53:38 <plat0> Ah
02:53:58 <Axman6> :t fromDyn
02:53:59 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
02:54:19 <plat0> int-e: Once you actually apply a function Typeable a => a -> something to a value you know what concrete type it has, surely?
02:54:27 <int-e> plat0: but the real use of the Typeable class is to be able to put things in a container (data Box where Box :: Typeable a => a -> Box -- same as Dynamic) and still be able to tell whether two of them have the same type (that's what Dynamic does)
02:54:44 <int-e> plat0: yes but a program may be using an unbounded number of types at runtime.
02:54:54 <ocharles> Is it possible to use type classes in a newtype definition? I'm trying to derive a quick monad like: newtype Changes a = Changes { changeActions :: HasDatabase m => m a }
02:55:57 <ion> > (fromDynamic . toDyn) (42 :: Integer) :: Maybe Integer
02:55:58 <lambdabot>   Just 42
02:56:00 <ion> > (fromDynamic . toDyn) (42 :: Integer) :: Maybe String
02:56:01 <lambdabot>   Nothing
02:56:05 <ocharles> (oh, and deriving (Monad))
02:56:58 <plat0> int-e: an unbounded number, hmm, like "deepen 0 _ = whatever; deepen n l = deepen (n-1) [l]", or did you mean something more sophisticated?
02:57:02 <int-e> plat0: (for example, a function of type  a -> ...  may call itself recursively with an argument of type [a])
02:57:08 <ocharles> With -XRankNTypes I get "Can't make a derived instance of `Monad Changes'"
02:57:17 <plat0> int-e: OK so I think we had the same idea!
02:57:33 <ion> > (map (`fromDyn` 0) &&& map (`fromDyn` "")) [ toDyn 42, toDyn "o hai" ]
02:57:33 <lambdabot>   ([42,0],["","o hai"])
02:58:01 <plat0> :t (&&&)
02:58:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:58:12 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
02:58:12 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
02:58:20 <Axman6> :t (map (`fromDyn` 0) &&& map (`fromDyn` ""))
02:58:21 <lambdabot> forall t. (Num t, Typeable t) => [Dynamic] -> ([t], [[Char]])
02:59:09 <int-e> plat0: no, that's what I mean. There are practical examples of this, too, e.g., Data.Sequence, which defined FingerTree a with one case containing a FingerTree (Node a) subtree.
03:00:13 <carpi> in ghci the prompt say "*Main>". could someone please tell me what "*" means? Does it mean all the definitions from Main are available?
03:00:37 <alex404> So I've got a pretty cool program going where I'm using Arrows to define circuits on Data.Streams, but my Garbage Collector usage is like 80% of the program, and it's clear that as the stream is being processed, the state of the Circuit at each step isn't being deallocated. I don't know how to force it to deallocate though... does anyone have any tips?
03:01:18 <plat0> :a FingerTree
03:01:46 <plat0> int-e: I can't find fingertree on hoogle
03:01:56 <plat0> Not in Data.Sequence anyway
03:03:36 <int-e> plat0: it's an implementation detail. http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/src/Data-Sequence.html#FingerTree
03:04:34 <int-e> (hmm, I should've linked to the 0.4.2.0 version, but the datatype is the same there)
03:06:13 <int-e> plat0: a related, simpler, self-contained example is this encoding of perfectly balanced binary trees with labels at the leafs:  data Tree a = Leaf a | Nest (Tree (a, a))
03:07:08 <plat0> int-e: FingerTree looks like a fun datastructure.
03:07:31 <int-e> and then there's the whole family of type-level arithmetic libraries, which also work with unbounded numbers of types.
03:07:58 <plat0> Ah yes, well they're designed to do funny things with types!
03:08:11 <plat0> The FingerTree and balanced tree examples are great
03:08:16 <plat0> because they are very simple.
03:11:35 <plat0> I like the balanced tree example.  I'm imagining the data definition meaning something like the tree is built by unfolding it double repeatedly.
03:12:19 <si14> hi, guys. is there any example of O(n) suffix tree construction with Haskell?
03:21:39 * jessopher just discovered highlighting-kate
03:31:15 * hackagebot Interpolation 0.2.6.0 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-0.2.6.0 (VilleTirronen)
03:59:32 <carpi> when we see something like "foo :: IO String".. how do we define it? foo is an IO action that gives String as result ?
04:00:01 <sipa> yes
04:00:29 <jessopher> carpi: one possible definition might be foo = return "foo"
04:01:05 <carpi> foo is an action that performs IO and gives a result that has type String
04:01:09 <carpi> i think both mean the same
04:01:17 * hackagebot websockets 0.4.0.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.4.0.1 (JasperVanDerJeugt)
04:01:41 <carpi> jessopher: i should have said "describe" instead of "define". My apologies
04:06:17 * hackagebot transformers-base 0.4 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.4 (MikhailVorozhtsov)
04:08:37 <jessopher> carpi: you can completely ignore that its IO and IO does anything at all. It would be a name that refers to data of type IO a, where IO a could be something like data IO a = Get | Put a | Return a or something similar, and you just use monadic do notation to compose a value of that type
04:09:40 <jessopher> carpi: the easiest way to think about it is to not consider it anything magical that has special properties that other types do not posess
04:10:39 <jessopher> carpi: substitute IO a, for Maybe a, and think about it in terms of something simple like a maybe value
04:11:53 <carpi> I think that sort of mindset would be useful initially while learning. but i would prefer to know the difference between applying a function and performing an action..
04:12:16 <sipa> carpi: from within haskell, you never ever perform an action
04:12:25 <sipa> you build up values of type IO a
04:12:29 <sipa> you combine them
04:12:33 <sipa> you bind them together
04:12:45 <sipa> you apply "normal functions" to them
04:12:49 <sipa> but you don't execute them
04:13:12 <sipa> all you do is build up a description of an (imperative) action that will be done at some point - but not by you
04:13:50 <sipa> main evaluates to this action you want to see performed
04:16:00 <carpi>  and finally these actions are sent to the runtime system outside haskell to be executed or something similar
04:16:16 <jessopher> right
04:16:43 <jessopher> its as if you are just writing a program in a language the runtime system understands
04:17:11 <sipa> you could probably see something of type IO a as a piece of C code that returns something of type a
04:17:28 <carpi> ah. that makes more sense
04:24:48 <jessopher> you could definitely implement it that way. You write pure functions that generate an AST for an effectful program, and have the entry point for your pure program be main :: EffectfulAst
04:27:42 <absence> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html <- i get an error about data constructor Cont not being in scope. has the module changed?
04:28:12 <ion> Change Cont to cont.
04:28:56 <ion> Cont is now a type alias to ContT r Identity, and cont is a constructor for the appropriate value.
04:29:24 <absence> ah, that did the trick. thanks
04:32:03 <carpi> I think i came up with a perfect anology. "Subway :: Money -> Cook Tuna". you use subway as a function and give it money to make it perform an action which is "cook" over which you have no control off. And when the cooking is done you get the result of all that cooking..tuna. In otherwords, subway gives you what you want without you having no control over the cooking process even though you're the one come up with those cooking instructions in a d
04:32:18 <carpi> i have a feeling thats not good
04:35:31 <erus`> errr
04:35:35 <mm_freak> carpi: are you going to write a monad tutorial?
04:35:50 <erus`> mm_freak: the question is when, not if
04:35:56 <Varakh> hi. if ve type Graph a = [(a,[a])] and i have a vertex set from this graph in the form: [(a,a)]. how do i convert this vertex set to a graph again?
04:36:01 <carpi> mm_freak: nope.. why do you ask?
04:36:07 <mm_freak> if yes, please read this beforehand:  http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
04:36:10 <mm_freak> =)
04:36:12 <ukl> Has anybody experienced problems using hPutBuf/hGetPuf on FreeBSD?
04:36:41 <ion> Monad is like a burr^Wtuna sandwich?
04:36:59 <Varakh> any idea? ;/
04:38:44 <erus`> i remember when everyone used to write tutorials with car analogies...
04:38:44 <mm_freak> Varakh: only vertices don't make a graph…  how exactly should the graph be built?
04:39:08 <Varakh> Graph a = [(a,[a])]
04:39:19 <Varakh> Adjacency list
04:39:20 <Varakh> =P
04:39:26 <mm_freak> Varakh: ah, you have pairs of vertices
04:39:38 <Varakh> i said that above ^^
04:39:48 <patrek> is it possible to alter a definition , for example a function f = 2, using Template Haskell? or TH just generates AST inplace?
04:40:10 <int-e> Graph a = [(a,[a])]  vs.  Graph a = [(a,a)]
04:40:11 <Varakh> vertices are [(a,a)] and now i want to create the Graph from the vertices set
04:40:49 <mm_freak> Varakh: well, that's an expensive operation for graphs based on lists…  at least you will need a constraint on a
04:40:51 <Varakh> u dont get it int-e? Graph is [a,[a]] and vertices set is [(a,a)]
04:40:52 <mm_freak> like Eq a
04:41:11 <int-e> > groupBy ((==) `on` fst) . sortBy (compare `on` fst) $ [(1,2),(2,3),(1,5),(3,1)]
04:41:12 <lambdabot>   [[(1,2),(1,5)],[(2,3)],[(3,1)]]
04:41:35 <Varakh> mm_freak: i got that
04:41:45 <sipa> carpi: people tend to want to write a monad tutorial once they "get" it :)
04:41:48 <int-e> > map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (compare `on` fst) $ [(1,2),(2,3),(1,5),(3,1)]
04:41:48 <mm_freak> Varakh: you can base your building algorithm around a simple operation:  insert :: Eq k => k -> a -> [(k, a)] -> [(k, a)]
04:41:50 <lambdabot>   [(1,[2,5]),(2,[3]),(3,[1])]
04:42:12 <mm_freak> Varakh: a better solution would be to use a Map for that
04:42:18 <Varakh> ok
04:42:24 <mm_freak> use Set for vertex pairs and Map for a graph
04:42:45 <Varakh> ok thanks
04:42:48 <Varakh> i'll try
04:43:02 <carpi> sipa: i don't think i got it.. yet. the analogy above was just an attempt to get it
04:43:22 <mm_freak> Varakh: your final graph type would look like this:  type Graph a = Map a (Set a)
04:43:26 <Varakh> int-e: what does &&& mean? :>
04:43:36 <mm_freak> then you basically just work with Map.insert and Set.union
04:43:42 <mm_freak> or rather Map.insertWith
04:44:02 <int-e> Varakh: as I used it, it has type (a -> b) -> (a -> c) -> (a -> (b, c))
04:44:23 <int-e> Varakh: i.e. it applies two functions to the same argument and combines the two results in a pair.
04:44:30 <int-e> @type (&&&)
04:44:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:44:32 <geheimdienst> > (succ &&& pred) 42 -- Varakh: it does two functions on the same argument and gives back a tuple with the results
04:44:32 <mm_freak> Map.insertWith Set.union v1 (Set.singleton v2) :: Ord a => Graph a -> Graph a
04:44:33 <lambdabot>   (43,41)
04:44:33 <lambdabot> geheimdienst: You have 1 new message. '/msg lambdabot @messages' to read it.
04:44:37 <mm_freak> inserts an edge to the graph
04:44:57 <int-e> Varakh: the general type is a bit scary, admittedly :)
04:45:06 <Varakh> ok thanks
04:45:17 <mm_freak> i don't find it scary
04:45:39 <int-e> well, it would be more readable if a was replaced by an infix ~>.
04:45:42 <mm_freak> for functions:  (a -> b) -> (a -> c) -> (a -> (b, c))
04:46:01 <mm_freak> for general arrows:  Arrow (>~) => (a >~ b) -> (a >~ b) -> (a >~ (b, c))
04:46:11 <mm_freak> it's just the prefix notation that makes it look scary =)
04:46:25 <int-e> Arrow (~>) => (a ~> b) -> (a ~> c) -> (a ~> (b, c))  would be far more readable indeed
04:46:35 <ukl> I'd like to run tests for System.IO, a part of base -- is this possible?  (using ghc 7.2.2, 'cabal unpack base' gets me base-3-*)  (Do such tests exist?)
04:48:39 <mm_freak> Varakh: in any case, i really recommend using a Map of Sets for a graph
04:48:59 <mm_freak> gives you many useful operations and also a lot more speed
04:49:22 <carpi> mm_freak: thanks for the link. that was a good read )
04:49:32 <Varakh> mm_freak: ye i know
04:49:48 <Varakh> what do i have to import for &&& ? :o
04:49:55 <mm_freak> Control.Arrow
04:49:57 <Varakh> never heard of that in ma class ;o
04:50:05 <mm_freak> carpi: you're welcome =)
04:50:46 <mm_freak> Varakh: Control.Arrow contains some useful functions in the function arrow
04:50:53 <patrek> anyway to modify (not adding) the code by template haskell?
04:50:53 <Varakh> is there any way to do this without groupBy etc and with the help of list comprehension?
04:51:08 <mm_freak> > map (second succ) (zip [1..10] [3,5 ..])
04:51:09 <lambdabot>   [(1,4),(2,6),(3,8),(4,10),(5,12),(6,14),(7,16),(8,18),(9,20),(10,22)]
04:54:05 <geheimdienst> mm_freak: if you think it's no big deal that the notation is a little unfortunate, then it should be no big deal that in java you write (2 *) as something like: (new Runnable() { void run(int x) { return 2 * x; }})
04:54:22 <geheimdienst> ;)
04:57:35 <Jeanne-Kamikaze> is there a regex version of bytestring replace ? I want to replace a sequence like %3F to its character equivalent, in this case ?, but folding the string is extermely slow
04:58:14 <geheimdienst> Jeanne-Kamikaze: i think the web-encodings package has functions for that. but i'm not sure how fast they are
04:58:45 <Jeanne-Kamikaze> will check it out thanks
05:00:19 <hpaste> “Ertugrul Söylemez” pasted “Graphs based on Map and Set” at http://hpaste.org/54704
05:00:28 <mm_freak> Varakh: see the paste for my solution
05:00:57 <mm_freak> geheimdienst: huh?
05:01:35 <geheimdienst> mm_freak: never mind ... i meant about the "a b c" vs. "b ~> c" issue.
05:05:50 <jessopher> carpi: yeah i dunno that the sandwhich analogy is sound
05:07:58 <jessopher> carpi: itd be more like cashier :: Money -> InstructionsForCook, and the end result is your sandwhich... which is alluded to in the instructions... but nobody eats the instructions
05:08:13 <Philonous_> carpi:  I found it very helpful to think of IO action as perl programs. You might have a way of combining them textually, but without a perl interpreter they are really just line noise.
05:10:10 <jessopher> capri: if you reduce it down to a moral, the moral of haskell is dont eat the instructions
05:10:39 <carpi> haha.. the perl analogy is also helpful
05:11:44 <jessopher> i wish haskell did make sandwhiches though
05:12:25 <int-e> use more intimidation https://www.xkcd.com/149/
05:12:34 <Jeanne-Kamikaze> geheimdienst, I split the big bytestring into many smaller ones by splitting at ' ', then folded those and merged back the results; it's insta fast
05:12:39 <ion> @vixen Make me a sandwich.
05:12:39 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
05:12:45 <jessopher> int-e: ha
05:12:49 <Philonous_> carpi: Btw. that's why we don't need macros (that much). Because haskell already _is_ the meta-language
05:13:41 <carpi> you mean you can write programs that write other programs
05:14:09 <Philonous_> carpi:  That's how it goes. You write haskell programs that write IO-programs.
05:15:25 <jessopher> dont get too wrapped up in what is 'actually
05:15:28 <jessopher> agh
05:16:43 <jessopher> dont get too wrapped up in what is 'actually' going on, a good fiction of whats going on is just as useful*
05:19:48 <hpaste> aram pasted “xmonad.hs” at http://hpaste.org/54705
05:19:52 <hpaste> aram pasted “error” at http://hpaste.org/54706
05:23:20 <Varakh> int-e: your way is awesome with that graph problem, buti tried it my way and im stuck. i want to make something like [[(a,a)]] and so i have something like [ [(a,b),(a,c),(a,d)], [(b,a),(b,e)] ] and with that list i want to create the graph, so run through inner lists and add all snd's to graph list. but i dont know how to get the  [[(a,a)]] list if i've and input of type [(a,a)].
05:24:11 <Varakh> and i dont like to import functions from control.arrow or data.function ^^
05:26:19 <JuanDaugherty> anybody know if HP is likely to slip again?
05:27:10 <mm_freak> Varakh: have you seen the paste?
05:27:35 * JuanDaugherty presume's so after checking and findind that ghc 7.4 isn't out.
05:27:40 <Varakh> no
05:27:44 <Varakh> closed mirc, sry
05:27:53 <JuanDaugherty> *presumes
05:28:34 <JuanDaugherty> *finding
05:28:38 <mm_freak> Varakh: http://hpaste.org/54704
05:29:14 <Varakh> mm_freak: i want to do this with my type
05:29:24 <mm_freak> ok
05:30:05 <mm_freak> don't worry about importing Control.Arrow though…  it's quite common
05:30:14 <mm_freak> even though most people only use the function arrow =)
05:30:32 <Varakh> task was to make a graph symmetric, i did that with expanding vertices set. that was 1 min coding and thinking. now, converting vertices to a graph is driving me mad :X
05:31:25 <mm_freak> Varakh: you really just need a union function for lists and an insertWith resembling the one from Data.Map
05:31:31 <mm_freak> then it's really just insertWith union
05:31:58 <Varakh> there must be another way to do it
05:32:00 <mm_freak> see the paste again…  our types are equivalent in some sense…  you just abuse lists to express the same thing =)
05:32:20 <Varakh> i dont do that, teacher is doing that :P
05:32:52 <mm_freak> i don't see another way…  this is probably the simplest way to do it
05:33:08 <Varakh> it would be easy if a have a list of lists of tuples. so seperate all tuples where fst is the same in one list
05:33:10 <mm_freak> int-e's solution does the same thing, but deals with the peculiarities of lists along its way
05:33:58 <mm_freak> and it does so in a single composition, whereas i have splitted it into two functions
05:34:23 <mm_freak> you can actually make this very easy by assuming that your lists are ordered all the time
05:35:16 <int-e> note: in fact sorting may be inefficient if there are comparatively few nodes and many edges or duplicate edges (a problem that my solution does not even try to deal with).
05:36:23 * hackagebot DSH 0.7.7 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7.7 (GeorgeGiorgidze)
05:36:48 <mm_freak> Varakh: tell your teacher that he's teaching your class how to do things the wrong way in haskell ;)
05:37:28 <mm_freak> abusing lists is one of the reasons why some things seem so complicated in haskell
05:43:30 <Varakh> ok
05:43:46 <Varakh> but back to the question ^^ is it possible that i can create lists of lists of tuples?
05:44:04 <Varakh> if yes: how :o
05:44:27 <Varakh> i want to have all (a,b) in one list where a is the same value
05:44:38 <quicksilver> > [[(1,2)]]
05:44:39 <lambdabot>   [[(1,2)]]
05:44:44 <quicksilver> a list of lists of tuples!
05:45:19 <Varakh> ... :P
05:45:32 <Varakh> i have [(a,a)] and want this [[(a,a)]]
05:45:35 <quicksilver> > groupBy ((==)`on`fst) . sort $ [(1,2),(2,3),(1,4),(3,5),(3,1)]
05:45:37 <lambdabot>   [[(1,2),(1,4)],[(2,3)],[(3,1),(3,5)]]
05:45:43 <ion> > (:[]) [(a,a)]
05:45:44 <lambdabot>   [[(a,a)]]
05:45:57 <Varakh> without importing these things :p
05:46:24 * hackagebot BiobaseInfernal 0.6.0.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.6.0.0 (ChristianHoener)
05:46:46 <quicksilver> Varakh: that's an absurd requirement.
05:46:54 <Varakh> :>
05:46:55 <Botje> Varakh: Data.List is pretty common
05:47:00 <quicksilver> Varakh: you are free to look up the source for those things and see how they work.
05:47:11 <quicksilver> but the answer to "is it possible" is clearly "yes"
05:47:20 <quicksilver> so, what is your next question?
05:47:24 <Botje> Varakh: but if you want to do it by yourself, walk the list while keeping a set of 'seen tuples'
05:54:15 <hpaste> adamCS pasted “Can I use foldl here?” at http://hpaste.org/54709
05:54:26 <adamCS> Have a look at that paste guys
05:55:09 <carpi> whats the use of const?
05:55:35 <adamCS> carpi: you talking to me?
05:56:02 <carpi> oh sorry..nope. but if you know the answer let me know : )
05:56:04 <Botje> adamCS: am I correct in saying that that function counts the number of times where item i is equal to item i+1 ?
05:56:16 <Botje> carpi: it comes in handy occasionally.
05:56:28 <Botje> carpi: generally in updating functions, where you want to ignore the given value
05:57:13 <adamCS> Botje: em. Well runcount = runcountacc 0 .... so runcount "aaabbbbcccccde" => 5
05:57:45 <carpi> so that is why it gives back the only the first argument given to it..
05:58:09 <adamCS> Botje: so it counts the number of blocks of consecutive equal items in a list
05:59:10 <Botje> adamCS: oh. then it's just length . group :]
05:59:40 <sipa> Botje: no, length x - length (group x)
05:59:47 <adamCS> Botje: thanks but it's for an assignment. I have it correct. That's what I'm going to submit. But I'm curious can I use foldl to do it?
06:00:02 <sipa> adamCS: sure
06:00:08 <sipa> but it's not trivial
06:00:25 <adamCS> sipa: you mean it's needlessly complicated?
06:00:32 <sipa> the state you're carrying will contain both the number of consecutives seen so far, and the previous item
06:00:41 <sipa> :t foldl
06:00:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:01:00 <adamCS> obviously now I mean I want to use an accumulator and foldl
06:01:28 <alex404> Does anyone know if GHC is capable of optimizing Streams from the Data.Stream package in the same way as it does lists? I'm getting allocation problems, and can't seem to get around it.
06:01:44 <Botje> snd $ foldl (\(prev, count) el -> if prev /= el then (el, count+1) else (el, count)) (head xs, 0) xs
06:01:46 <adamCS> sipa: not following you
06:01:49 <Botje> something like that.
06:02:10 <sipa> @let countseq (l:ls) = first $ foldl (\(n,p) x -> if p==x then n+1 else n) (0,l) ls
06:02:10 <lambdabot>  <local>:4:58:
06:02:10 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t,...
06:02:12 <adamCS> Botje: what's snd?
06:02:27 <sipa> :t snd
06:02:28 <lambdabot> forall a b. (a, b) -> b
06:02:36 <sipa> adamCS: does that type signature say enough?
06:03:03 <adamCS> sipa: it just returns the second/last param?
06:03:09 <sipa> yes
06:03:17 <sipa> @let countseq (l:ls) = fst $ foldl (\(n,p) x -> if p==x then n+1 else n) (0,l) ls
06:03:17 <lambdabot>  <local>:4:56:
06:03:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t,...
06:03:25 <adamCS> okay. Let me study those now...:)
06:03:42 <sipa> @let countseq (l:ls) = fst $ foldl (\(n,p) x -> if p==x then (x,n+1) else (x,n)) (0,l) ls
06:03:42 <lambdabot>  Defined.
06:03:52 <sipa> > countseq [1,2,2,3,3,4]
06:03:54 <lambdabot>   4
06:04:09 <adamCS> nice
06:04:10 <sipa> hmm
06:04:26 <sipa> @reset
06:04:26 <lambdabot> Unknown command, try @list
06:04:30 <sipa> @forget
06:04:30 <lambdabot> Incorrect arguments to quote
06:04:33 <sipa> @forget countseq
06:04:33 <lambdabot> Incorrect arguments to quote
06:04:46 <sipa> @let countseq2 (l:ls) = snd $ foldl (\(n,p) x -> if p==x then (x,n+1) else (x,n)) (0,l) ls
06:04:47 <lambdabot>  Defined.
06:04:52 <sipa> > countseq2 [1,2,2,3,3,4]
06:04:53 <lambdabot>   3
06:05:00 <sipa> :(
06:05:17 <sipa> @let countseq3 (l:ls) = snd $ foldl (\(n,p) x -> if p==x then (x,n+1) else (x,n)) (l,0) ls
06:05:17 <lambdabot>  Defined.
06:05:21 <sipa> > countseq3 [1,2,2,3,3,4]
06:05:22 <lambdabot>   3
06:05:26 <adamCS> countseq2 "aaabbbcdde"
06:05:35 <adamCS> > countseq3 "aaabbbcdde"
06:05:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:05:38 <lambdabot>    arising from a use of `L.co...
06:05:45 <sipa> bah
06:07:03 <adamCS> Botje: btw your implementation returns 1 too little
06:07:35 <adamCS> @let countseqBotje (x:xs) = snd $ foldl (\(prev, count) el -> if prev /= el then (el, count+1) else (el, count)) (head xs, 0) xs
06:07:36 <lambdabot>  Defined.
06:07:55 <sipa> that counts the number of transactions between elements
06:07:55 <adamCS> > countseqBotje "aaa"
06:07:57 <lambdabot>   0
06:07:59 <hpaste> “Ertugrul Söylemez” pasted “Graphs based on lists” at http://hpaste.org/54710
06:08:08 <mm_freak> Varakh: http://hpaste.org/54710
06:08:19 <mm_freak> an emulation of Map and Set using lists
06:08:34 <mm_freak> note: assumes the lists to be ordered all the time
06:08:53 <Botje> adamCS: uh, correct. start with 1 then :]
06:08:55 <adamCS> @let countseqBotje2 (x:xs) = 1 + countseqBotje
06:08:56 <lambdabot>  Defined.
06:09:02 <Botje> instead of 0
06:09:08 <adamCS> > countseqBotje2 "aaa"
06:09:09 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> b1)
06:09:09 <lambdabot>    arising from a use o...
06:10:31 <mm_freak> Varakh: there you go…  a solution with no imports at all and not even that ugly, but still kind of stupid for not just using Map and Set =)
06:10:59 <mm_freak> i find myself using the M.insertWith S.union pattern all the time
06:21:59 <EvanR-work> whats the best random package?
06:23:32 <EvanR-work> i.e. mysql-simple is the best mysql package, time is the best time package ;)
06:23:45 <EvanR-work> seems like a pattern that one package is just way better than the others
06:26:10 <gwern> (oy vey was that a lot of spam on the wiki)
06:31:10 <mysticc_> what is the meaning of type such as abc :: !Int
06:31:28 <mauke> the ! is a strictness annotation
06:32:42 <mm_freak> EvanR-work: there is none
06:32:49 <EvanR-work> :(
06:32:55 <mm_freak> EvanR-work: there are different random packages for different purposes
06:33:09 <mm_freak> i like the aes-cprng package though
06:33:12 <sipa> the best strategy is to pick one at random
06:33:18 <EvanR-work> lol
06:33:24 <mm_freak> fast and has both a Crypto-API and a System.Random interface
06:33:30 <Philonous_> sipa:  Yes, but which algorithm to use for that choice...
06:33:41 <mm_freak> sipa: chicken/egg problem
06:33:53 <mm_freak> sipa: what random package do you use to pick a random package?
06:33:53 <EvanR-work> a while back i heard rumors 'do NOT use haskell for crypto' is that still the case?
06:34:02 <mm_freak> EvanR-work: it was never the case
06:34:05 <sipa> mm_freak: not until we have first-class packages :)
06:34:08 <EvanR-work> ok
06:34:17 <mm_freak> EvanR-work: the case was:  do NOT use StdGen for cryptographic purposes =)
06:34:22 <mm_freak> and that's still true
06:34:29 <EvanR-work> that makes sense, but thats not what im talking about
06:35:07 <EvanR-work> something about the timing of the runtime couldnt be controlled tightly enough to prevent some sort of attack based on the delays in the output
06:35:10 <mm_freak> sipa: well, with a circuit delay and lazy evaluation you can probably come to a conclusion here =)
06:35:14 <mysticc_> mauke: So if I give (abc (f a)) .. where (f a :: Int) then it will be evaluated immediately when abc is called ?
06:35:17 <mm_freak> sipa: you'll need ArrowLoop though =P
06:35:32 <Philonous_> I wonder what difference the choice of language is supposed to make when you implement the protocols correctly (or incorrectly)
06:35:48 <mauke> mysticc_: that looks like a type error. you said abc is an Int
06:35:54 <mm_freak> EvanR-work: side channel attacks, yes…  but most of the useful crypto libraries actually use C
06:36:20 <EvanR-work> ok... ;)
06:36:44 <mm_freak> mysticc_: if you have an !Int field, it just means:  whenever the constructor is evaluated, that field is also evaluated (to weak-head normal form)
06:36:57 <mysticc_> oh thanks
06:37:19 <mysticc_> although I dont understand the think inside brackets :)
06:37:47 <mm_freak> mysticc_: data EitherSL e a = Left !e | Right a
06:37:51 <Philonous_> mm_freak:  Is that valid outside the declaration of data types?
06:38:02 <mm_freak> as soon as you know it's a Left, you also know the constructor of the 'e'
06:38:19 <mm_freak> Philonous_: outside that it's not a strictness annotation
06:39:00 <EvanR-work> without the !, will it still be strict, sometimes
06:39:17 <mm_freak> with 'data' no
06:39:18 <EvanR-work> seems like A Int | B Char should be strict regardless
06:39:28 <mm_freak> why?
06:39:32 <mm_freak> A undefined
06:39:47 <EvanR-work> undefined o_O
06:39:51 <Philonous_> mm_freak:  Ah, but that seems like a rather unlucky choice of notation, because the strictness is not really part of the type
06:39:53 <mm_freak> you can still find out it's A…  with !Int you couldn't
06:40:10 <EvanR-work> interesting
06:40:15 <EvanR-work> if it werent for undefined!
06:40:32 <mm_freak> Philonous_: what do you mean?
06:40:35 <Philonous_> EvanR-work:  Strictness is defined in terms of undefined
06:41:00 <EvanR-work> probably more relevant than undefined is an expression which will never evaluate to something
06:41:01 <Philonous_> EvanR-work:  i.e. f is strict iff f _|_ = _|_
06:41:02 <mm_freak> Philonous_: or rather:  how else would you make strict fields?
06:41:30 <mm_freak> EvanR-work: replace 'undefined' by an endless loop of your choice
06:41:40 <EvanR-work> yeah
06:41:49 <EvanR-work> if it werent for endless loops!
06:41:59 <mm_freak> EvanR-work: the thing is:  given A x, where x is a very expensive expression, you could find out it's an A without ever evaluating that expression
06:42:03 <Philonous_> mm_freak:  I think the bang should go before the field name. But of course that doesn't make sense outside record syntax. So, never mind, scratch that remark.
06:42:05 <mm_freak> if A is strict, then you can't
06:42:51 <EvanR-work> with newtype is different?
06:43:05 <mm_freak> no, newtype is almost like an always-strict data
06:43:22 <Philonous_> EvanR-work:  newtype is special because it doesn't have any runtime representation whatsoever
06:43:26 <mm_freak> the difference is: you always know the constructor, so you can pattern-match against the constructor without causing evaluation of the argument
06:43:33 <EvanR-work> intereting
06:43:36 <EvanR-work> +s
06:43:46 <EvanR-work> so many tricky bits in haskell
06:44:15 <sipa> once you get close to the metal...
06:46:33 <mm_freak> Philonous_: then you would have two different notations anyway…  the current variant is more consistent, because not every type is a record type
06:48:57 <mm_freak> question about mfix with concurrency
06:49:09 <mm_freak> rec tid <- forkIO (… tid…)
06:49:52 <mm_freak> this is a race condition, because the child thread may start running before the parent thread has produced a thread id
06:50:09 <quicksilver> it will just block
06:50:11 <mm_freak> is there a way to prevent this without using MVar?
06:50:13 <traviscline> is it possible to do a readLn in a where clause? (newbie, sorry)
06:50:17 <hpaste> testfile pasted “korte” at http://hpaste.org/54712
06:50:18 <quicksilver> shouldn't be harmful
06:50:22 <quicksilver> AFAIK
06:50:24 <mm_freak> quicksilver: it <<loop>>s for me
06:50:29 <danr> mm_freak: really?
06:50:30 <quicksilver> really? interesting.
06:50:44 <EvanR-work> traviscline: yep
06:51:05 <quicksilver> why not just use forkIO ( do tid <- myThreadId; .... tid ... ) ?
06:51:07 <quicksilver> ;)
06:51:20 <danr> tid <- tid `seq` forkIO (... tid ...)
06:51:28 <danr> haha
06:51:34 <danr> that seriously won't work, will it?
06:51:55 <mm_freak> danr, quicksilver: mfix (\tid -> forkIO (print tid))
06:51:59 <mm_freak> seems to work always
06:52:14 <mm_freak> whereas: mfix (\tid -> forkIO (print tid) >>= return)
06:52:21 <mm_freak> sometimes <<loop>>s
06:52:43 <Philonous_> danr:  It will! But notice that the tid on the left side of the <- is in a new scope
06:52:53 <mm_freak> quicksilver: sure, that works
06:52:58 <Philonous_> danr:  So it will shadow the one on the right
06:53:04 <mm_freak> i'm just curious about how mfix works with concurrency
06:53:07 <Philonous_> danr:  It's not recursive
06:53:15 <mm_freak> i seem to be observing a race condition
06:53:16 <danr> Philonous_: oh interesting
06:53:44 <danr> Philonous_: can you get the same <<loop>> behaviour as mm_freak then?
06:53:49 <mm_freak> danr: that won't work i guess
06:54:00 <traviscline> EvanR-work: I get a "parse error on input `<-'" with a "where x <- readLn"
06:54:04 <quicksilver> mm_freak: it is curious, I agree. It's more to do with how the IO instance of MonadFix interacts with non-determinism though.
06:54:26 <quicksilver> mm_freak: it's not *specifically* about concurrency, and it's not *generally* about mfix - each MonadFix instance is unique.
06:54:40 <mm_freak> danr: that always <<loop>>s
06:54:56 <mm_freak> quicksilver: true
06:55:08 <EvanR-work> traviscline: you mean where foo = readLn ;)
06:55:38 <EvanR-work> somewhere else you can do x <- foo
06:55:40 <traviscline> gah
06:55:49 <mm_freak> quicksilver: i haven't encountered a case where i need this anyway, but i would have expected this to be thread-safe
06:56:02 <traviscline> EvanR-work: i wanted to do something like https://gist.github.com/609c6dd4a8aa4909c73b
06:56:10 <Philonous_> danr:  mm_freak got a loop because fixIO throws a non-termination exception as a manual black-hole
06:56:21 <hpaste> testfile pasted “korte” at http://hpaste.org/54713
06:56:35 <mm_freak> Philonous_: i don't see how that can work at all
06:56:44 <quicksilver> mm_freak: yeah I would have expected it to just block and then (in your example) wake up when the value was available
06:56:46 <mm_freak> Philonous_: you make the forkIO action dependent on the thread id
06:56:49 <quicksilver> mm_freak: but evidently I was wrong :)
06:57:03 <mm_freak> so you ask for a thread id without giving the opportunity to make one
06:57:23 <Philonous_> mm_freak:  It's tha magic of (lazy) IO-refs. You put _|_ into it, pass it to the function and afterwards put the result of the function into the Ref
06:57:43 <EvanR-work> traviscline: you need to write something which will desugar eventually to readLn >>= \x -> ... x == 10 ...
06:57:55 <EvanR-work> otherwise you can use x
06:57:58 <EvanR-work> cant
06:58:00 <traviscline> ok
06:58:01 <traviscline> thanks
06:58:07 <EvanR-work> where only consists of = definitions
06:58:14 <EvanR-work> not <-, <- is only in do notation
06:58:20 <mm_freak> Philonous_: i don't see how that can work at all with the 'seq' in there, regardless of the semantics of fixIO
06:58:23 <traviscline> gotcha
06:58:34 <traviscline> gotcha
06:59:24 <mm_freak> Philonous_: i would translate the example to:  mfix (\tid -> tid `seq` forkIO (print tid))
06:59:50 <mm_freak> i don't see how mfix can work on /any/ strict function
06:59:51 <Philonous_> mm_freak:  Oh, that would throw notermination
07:00:19 <Philonous_> mm_freak:  It can't of course. I just misunderstood what you where saying
07:00:26 <mm_freak> ah, ok
07:00:56 <mm_freak> it probably can for:  data UnitMonad a = Unit
07:00:57 <mm_freak> =)
07:01:07 <mm_freak> mfix _ = Unit
07:09:14 <aadrake> Question:  I'm trying to learn Haskell and so want to use it in some projects I'm already working on.  Currently I need to parse a pretty large JSON file (8GB, 3 million lines) and I'm wondering if anyone has recommendations on which method would be best.  I read that Text.JSON is slow, but that was old information.
07:09:27 <EvanR-work> Aeson
07:09:30 <aadrake> P.S. - I would like to convert it to CSV
07:11:14 <aadrake> EvanR-work: I'll look into it, thank you.
07:12:23 <EvanR-work> and search for a csv encoder package
07:12:39 <EvanR-work> then smush them together like peanut butter and jelly
07:13:15 <luite> hm, I don't think Aeson has a streaming parser, but you can probably borrow its outer parser (attoparsec) to write your own, using the one from Aeson to parse each line to a Value
07:13:25 <aadrake> EvanR-work: It will be an interesting exercise in smushing as my Haskell knowledge is still minimal.
07:13:53 <luite> but it will require some iteratee-like things, so not terribly simple
07:14:17 <aadrake> luite: Hmm.  Maybe this project (in Haskell) will have to wait for another time then.
07:15:04 <mm_freak> aadrake: it would be a good starting project, if it weren't 8 GB
07:15:12 <mysticc_> @unpl (a+b)
07:15:13 <lambdabot> (a + b)
07:15:17 <mysticc_> @pl (a+b)
07:15:17 <lambdabot> a + b
07:15:36 <mysticc_> how to get point free form in lambdabot ?
07:15:51 <mauke> with @pl
07:15:51 <_oz> @pl \ a b -> a + b
07:15:52 <lambdabot> (+)
07:15:52 <mysticc_> @pl (\a b -> a+b)
07:15:52 <lambdabot> (+)
07:15:55 <aadrake> mm_freak: Indeed, it's the 8GB part that makes it troublesome.  I can't do that in memory, so it change things a little.
07:16:13 <EvanR-work> 'bah, memory is cheap now'
07:16:26 <mysticc_> @pl (\a b -> sum $ zipWith (\c d -> (c-d)^2) a b)
07:16:26 <lambdabot> (sum .) . zipWith (flip flip 2 . ((^) .) . (-))
07:16:29 <luite> aadrake: maybe you can use some language you're more familiar with to split it up into multiple JSON objects first, one for every line?
07:16:33 <mm_freak> aadrake: well, you may turn it into an exercise for using attoparsec in stream fashion
07:16:45 <mm_freak> aadrake: you don't need iteratees for that, just plain attoparsec
07:17:00 <aadrake> EvanR-work: I work with fairly large datasets, so even though memory is cheap it isn't possible to load everything into memory on my laptop.
07:17:01 <Philonous_> mm_freak:  Btw. it's trivial to re-implement fixIO with MVars instead of IORefs, that would make it thread safe. But I doubt that's worth it
07:17:03 <luite> aadrake: and then revisit it later if you feel comfortable enough with haskell :)
07:17:40 <aadrake> luite: Splitting it up is definitely an option.
07:17:42 <mysticc_> _oz: whats the meaning of  (sum .) .  in this pl form : (sum .) . zipWith (flip flip 2 . ((^) .) . (-))
07:17:51 <Kaidelong> EvanR-work: Who said that?
07:18:08 <EvanR-work> Kaidelong: every gamer / java programmer on this network
07:18:19 <Kaidelong> =/
07:18:20 <Philonous_> Kaidelong:  The memory vendors
07:18:42 <Kaidelong> Well using lots of memory is still going to bite even if the physical memory was free because of all the IO you need to do
07:19:07 <EvanR-work> sip your ideal turing machine koolaid
07:19:43 <Philonous_> Kaidelong:  Not necessarily, you need to transport the whole data in and out of memory anyway, it's just the order that changes
07:20:10 <Philonous_> Kaidelong:  Unless you can keep in all in cache
07:20:23 <EvanR-work> 8G cache \o/
07:21:05 <mm_freak> Philonous_: yeah, MVars are quite slow compared to IORefs
07:21:31 <mm_freak> Philonous_: also passing the thread id to a just created thread is probably the only use case
07:21:42 <mm_freak> but it shows that even immutable data is not 100% thread-safe
07:22:17 <mm_freak> this is an edge case where it actually fails
07:22:39 <Philonous_> mm_freak:  Well, we are using a mutable memory cell for that trick, anyway. It shows that unsafeInterleaveIO is not threadsafe
07:23:00 <mm_freak> Philonous_: fixIO uses unsafeInterleaveIO?
07:23:11 <mm_freak> i think it's related to the concurrency
07:23:24 <danr> mysticc_: (sum .) . f is \x y -> sum (f x y)
07:23:39 <Philonous_> mm_freak:  Sure, how else would you get the value out of the IORef?
07:23:40 <mysticc_> danr: Yeah , thanks
07:23:43 <EvanR-work> so Control.Exception is using ghc-only haskell extensions?
07:23:55 <mm_freak> Philonous_: ah, yes
07:23:58 <mm_freak> ok, that explains it
07:25:18 <EvanR-work> forall e . Exception e => SomeException e
07:25:48 <EvanR-work> existentials?
07:28:36 <alistra> @pl \x y w -> (x y) (w x)
07:28:36 <lambdabot> liftM2 flip ((.) .) (flip id)
07:28:46 <mm_freak> EvanR-work: and Typeable
07:29:10 <EvanR-work> oh Typeable isnt standard?
07:29:27 <mm_freak> though i would have preferred a data family-based extensible exceptions system
07:47:57 <EvanR-work> looks like bracket could simplify my exception handling regime
07:50:10 <matthiasgorgens> What's an easy way to read a hexadecimal number from a bytestring?
07:50:42 <EvanR-work> attoparsec?
07:50:50 <matthiasgorgens> I tried \bs -> read ("0x" ++ unpack bs), but then unpack bs gives you a [Word8], not a [Char].
07:51:03 <matthiasgorgens> Attoparsec seems overkill, when read is available, or is it not?
07:51:23 <EvanR-work> if you want that, then use Data.ByteString.Char8
07:51:39 <EvanR-work> unpack :: ByteString -> [Char]
07:51:48 <luite> matthiasgorgens: there is a bytestring-base16 package
07:51:48 <tromp> :t unpack
07:51:49 <lambdabot> forall n o. (Newtype n o) => n -> o
07:52:20 <luite> oh, the other way around, base16-bytestring
07:52:46 <matthiasgorgens> Thanks.
07:55:15 <Patinho`Busy> hi all
07:56:16 <luite> matthiasgorgens: oh wait, I think I understood you wrong. I thought you had a bytestring that you wanted to read as a hexadecimal number (like is often done with hashes)
07:56:48 <EvanR-work> me too
07:56:50 <matthiasgorgens> luite, I want a function with the type: ByteString -> Int
07:56:51 <matthiasgorgens> or so.
07:56:56 <matthiasgorgens> Integer is also fine.
07:57:15 <EvanR-work> matthiasgorgens: what you originally wrote will work if you use unpack from the Char8 module
07:57:17 <matthiasgorgens> and it should work like \s -> read ("0x" ++ s) for strings does.
07:57:31 <matthiasgorgens> EvanR-work: even if the bytestring itself is from the other module?
07:57:32 <matthiasgorgens> ok.
07:57:36 <EvanR-work> matthiasgorgens: yes
07:57:42 <matthiasgorgens> excellent.
07:57:57 <EvanR-work> its a different unpack, not a different bytestring
07:59:14 <ClaudiusMaximus> cd
07:59:18 <ClaudiusMaximus> oops..
07:59:23 <luite> EvanR-work: err I thought a C8 was a different ByteString
07:59:35 <EvanR-work> why would it
08:01:50 <EvanR-work> hmmm
08:02:32 <mm_freak> luite: they are the same, just reexported from an internal module
08:02:38 <luite> yeah I realize
08:03:31 <luite> it doesn't really make sense to make a difference... wonder why I didn't notice this earlier
08:04:19 <luite> apparently I don't often have to deal with Char and binary data in the same bytestring :)
08:04:19 <mm_freak> probably because you haven't needed functions from both modules
08:04:46 <EvanR-work> under normal conditions youd decode part of it with Data.ByteString.UTF8
08:04:58 <EvanR-work> but hes got simpler bytes
08:05:06 <luite> I usually use Data.Text.Encoding for decoding stuff
08:05:37 <EvanR-work> interesting
08:05:57 <EvanR-work> who in their right mind uses anything but utf8 ;)
08:06:12 <mm_freak> there are reasons to prefer other encodings
08:06:16 <mm_freak> like efficiency
08:06:30 <mm_freak> UTF-8 needs a lot of branches for non-latin languages
08:06:31 <mauke> what's more efficient than utf-8?
08:06:44 <EvanR-work> utf16, if its japanese
08:06:50 <mauke> for what operations?
08:07:02 <mm_freak> mauke: finding a character
08:07:08 <mm_freak> counting characters
08:07:12 <mauke> how so?
08:07:21 <EvanR-work> storage space
08:07:23 <mm_freak> as said, UTF-8 needs many branches
08:07:29 <mm_freak> up to four, i think
08:07:42 <mauke> finding a character is plain substring search
08:07:44 <EvanR-work> a 4 byte utf8 is gonna be rare
08:07:46 <mm_freak> UTF-16 needs up to one and much more rarely
08:08:07 <mm_freak> mauke: with UTF-16 it can be a simple REPNZ SCASW in x86 assembly
08:08:36 <mm_freak> or something equivalent for counters instead of null bytes
08:09:11 <mm_freak> substring search is comparably expensive
08:10:34 <mm_freak> EvanR-work: the UTF-8 standard allows up to five branches, but IIRC there are no real world characters that need that
08:10:40 <EvanR-work> 6
08:10:43 <matthiasgorgens> EvanR-work: Thanks, worked.
08:10:50 <EvanR-work> i think
08:10:52 <mm_freak> EvanR-work: five branches = six bytes
08:11:41 <mauke> the UTF-8 standard only allows 4 bytes
08:11:44 <mauke> so 3 branches?
08:12:25 <mm_freak> 6 bytes, mauke
08:12:28 <mauke> no, 4
08:13:54 <mauke> hmm, couldn't you use the REPNZ SCASW trick for UTF-8?
08:14:24 <mauke> you need additional checks in the 3-byte case
08:14:26 <mm_freak> mauke: four bytes is unicode, but UTF-8 as an encoding allows up to six
08:14:39 <mauke> UTF-8 is a UTF
08:14:40 <mauke> 4 bytes
08:14:48 <mm_freak> you can use REPNZ SCASB for UTF-8, but only if the character you're looking for is ASCII
08:15:00 <mauke> and SCASW if it's 2 bytes
08:15:04 <mm_freak> with UTF-16 you have many international characters, too
08:15:13 <mauke> and SCASW + an extra check if it's 3 bytes
08:15:30 <mauke> and SCASD if it's 4 bytes
08:15:30 <mm_freak> you can't add anything to a REP* loop
08:15:40 <mauke> what
08:15:58 <mm_freak> REP* only loops the following instruction
08:16:05 <mauke> I use SCASW for a "heuristic" search, i.e. one with false positives
08:16:25 <mauke> after a hit I check if it's actually the character I'm looking for. if not, I restart the REP
08:16:44 <mm_freak> are you sure you are using REP*?  not LOOP?
08:16:51 <dschoepe> mm_freak: With scasb you could get false positives though.
08:16:55 <mauke> dschoepe: how?
08:17:14 <mm_freak> dschoepe: UTF-8 prevents that
08:17:25 <mauke> mm_freak: pretty sure, given that I've just read up on SCAS and REP
08:17:35 <dschoepe> mauke: So it can't be the second byte of "larger" character?
08:17:43 <dschoepe> *of a
08:17:43 <mauke> dschoepe: of course not, it's UTF-8
08:17:50 <mauke> ASCII compatible, remember?
08:18:17 <mm_freak> mauke: perhaps REP has been improved since my x86 assembly time…  but when i was using it, it could only loop the following instruction
08:18:26 <mm_freak> so you couldn't add any additional tests
08:18:32 <EvanR-work> heh removed
08:18:44 <dschoepe> mauke: Oh, right
08:19:45 <mauke> mm_freak: did you read what I said?
08:20:37 <mm_freak> mauke: oh, yes…  now i see, but that's basically what i was talking about
08:20:42 <mm_freak> it adds additional branches
08:20:55 <mauke> yes, in the uncommon case
08:21:10 <EvanR-work> utf32, nuff said
08:21:29 <mm_freak> well, i guess for most purposes UTF-8 is fast enough
08:21:30 <mauke> in fact, I'd expect false positives to be very rare
08:21:46 <mm_freak> mostly you don't actually care about the encoding anyway, when it comes to high throughput
08:33:00 <hpaste> bwq pasted “graph” at http://hpaste.org/54718
08:33:15 <bwq> yeah
08:33:26 <bwq> so i'm having trouble getting that function to work but i've got no clue what's wrong
08:36:26 <tsuraan_> @seen chrisdone
08:36:26 <lambdabot> Unknown command, try @list
08:36:26 <preflex>  chrisdone was last seen on #haskell 17 hours, 29 minutes and 10 seconds ago, saying: likeso http://hpaste.org/irc/haskell/2011-11-29/15-07-13/54684
08:46:31 * hackagebot simpleirc 0.2.1 - Simple IRC Library  http://hackage.haskell.org/package/simpleirc-0.2.1 (DominikPicheta)
08:49:38 <ukl> hello.  Using gtk2hs's mainloop, can my program still read from stdin via getLine?
08:49:59 <ukl> (I'm trying to find out what's wrong with my attempt to do so...)
08:53:00 <dcoutts> ukl: yes, but note that mainGUI is a blocking call.
08:54:04 <ukl> dcoutts: ah, ok.  thanks.  Uhm, what do I need to do to deal with that?
08:54:13 <angstrom> > tail >>= zipWith (-) $ [1,3,5,1,3,5]
08:54:13 <lambdabot>   [2,2,-4,2,2]
08:54:33 <angstrom> ^ I can't figure out how this is working :\
08:55:09 <bwq> 5-3 = 2
08:55:15 <bwq> 3 - 1 = 2
08:55:19 <bwq> 1 - 5 = -4
08:55:20 <bwq> etc
08:55:46 <angstrom> yeah.. I meant the bind-part
08:55:50 <ukl> I've got to read up on blocking calls - in which way does mainGUI block, will 'forkIO $ forever $ do_sth =<< getLine' get past it?  (it's an OS thread, right?)
08:56:45 <angstrom> shouldn't `tail >>= zipWith (-)' be equivalent to `concat (map (zipWith (-)) tail)'?
09:01:47 <EvanR-work> @hoogle IO a -> IO ()
09:01:47 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:01:47 <lambdabot> Control.Exception.Base block :: IO a -> IO a
09:01:47 <lambdabot> Control.Exception block :: IO a -> IO a
09:02:12 <EvanR-work> :t void
09:02:13 <lambdabot> Not in scope: `void'
09:02:35 <EvanR-work> :manualfor void ;)
09:03:10 <carpi> f :: a -> IO String .. is 'f' an action or a functin?
09:03:22 <EvanR-work> functions
09:03:37 <carpi> and what about f :: IO String ?
09:03:45 <EvanR-work> an IO action
09:03:56 <carpi> thxx for the clarification )
09:04:27 <EvanR-work> f :: a -> IO String means f has to be a constant ;)
09:04:44 <carpi> constant?
09:04:49 <EvanR-work> returns a constant
09:04:53 <EvanR-work> the a dont matter
09:05:22 <carpi> f is a string ultimately. thats what u mean yea?
09:05:30 <EvanR-work> no f is not a string
09:05:33 <carpi> nope
09:06:11 <carpi> f takes a and then the IO action give f a String
09:06:22 <EvanR-work> eh no
09:06:55 <EvanR-work> f x will not cause a string to appear
09:07:38 <Eduard_Munteanu> carpi: he meant your function has to be a constant function, because 'a' is any type.
09:07:45 <EvanR-work> yeah
09:07:54 <Eduard_Munteanu> You can't do different things depending on that value.
09:07:59 <EvanR-work> and f will never 'get a string'
09:08:53 <geheimdienst> EvanR-work: i think void is in Control.Monad
09:09:02 <carpi> so f takes a and simply performs an IO action.
09:09:04 <carpi> thats all
09:09:06 <carpi> yea?
09:09:12 <EvanR-work> no it doesnt
09:09:19 <EvanR-work> it does not perform any action
09:09:20 <rwbarton> f takes a value of type a and returns an IO action
09:09:30 <carpi> could you please tell me how i can describe it ?
09:09:36 <EvanR-work> see rwbarton
09:10:13 <EvanR-work> geheimdienst: excellent
09:10:21 <carpi> so the IO action is not yet performed?
09:10:26 <EvanR-work> correct
09:10:28 <angstrom> aaah. that computation isn't happening in the list monad..
09:10:42 <carpi> and when it is performed it will give you a String?
09:10:58 <EvanR-work> yeah
09:11:52 <xplat> does anyone know a library that implements an EDSL based on a substructural type theory?
09:12:33 <xplat> like linear/uniqueness types, affine logic, bunched implications?
09:13:01 <copumpkin> not me :/
09:25:25 <carpi> in ghci if i do something like "print 3" it prints '3'. But the type of print is "a -> IO ()". if according to that signature if print merely returns an IO action, then why is it executing that IO action?
09:26:09 <carpi> or maybe my understand is so convoluted that the question makes no sense.. : (
09:26:22 <carpi> s/understand/understanding
09:26:57 <sipa> carpi: it deals with IO action specially
09:27:19 <sipa> it does not just print the resulting IO action, but effectively executes it
09:27:42 <rwbarton> ghci will do one of two things with your input
09:27:46 <EvanR-work> ghci REPL acts different from haskell normal code
09:27:53 <rwbarton> if it is of type IO a for some a, it will execute the action and then print the result
09:27:58 <geheimdienst> > print 42
09:27:59 <lambdabot>   <IO ()>
09:28:00 <rwbarton> otherwise, it will just print the value you entered
09:28:08 <carpi> EvanR-work: i was hoping that was the answer )
09:28:38 <carpi> lamdadot seems to do the rgiht thing
09:28:50 <EvanR-work> > readLn
09:28:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:28:51 <lambdabot>    `GHC.Read.Read a'
09:28:51 <lambdabot>      a...
09:28:59 <EvanR-work> > getChar
09:29:00 <lambdabot>   <IO Char>
09:29:16 <rwbarton> oh, and ghci doesn't print the result if it is of type (), I guess
09:29:40 <carpi> so print really just returns an IO action. GHCi executues
09:29:46 <EvanR-work> > unsafePerformIO getChar
09:29:47 <lambdabot>   Not in scope: `unsafePerformIO'
09:36:50 <xplat> in soviet russia^W^Wghci source code, IO action executes REPL!
10:04:40 <roconnor> oh, I missed as discussion about IO!
10:14:08 <mm_freak> why is (.) nonstrict?
10:14:33 <lukish> @pl (\x -> 2 * x * (div (x-1) 2))
10:14:33 <lambdabot> liftM2 (*) (2 *) (flip div 2 . subtract 1)
10:14:42 <lukish> Ohwow
10:14:44 <mm_freak> for functions that is…  or equivalently:  what's the WHNF for a function?
10:15:43 <Saizan> you don't have to answer that to tell if it's strict or not
10:16:23 <Saizan> > (undefined . undefined) `seq` ()
10:16:24 <lambdabot>   Ambiguous type variable `f' in the constraint:
10:16:24 <lambdabot>    `GHC.Base.Functor f'
10:16:24 <lambdabot>     ...
10:16:41 <Saizan> > (undefined . (undefined :: Int -> Int)) `seq` ()
10:16:42 <lambdabot>   ()
10:17:49 <parcs_> > (undefined Prelude.. undefined) undefined `seq` ()
10:17:49 <lambdabot>   Not in scope: `Prelude..'
10:17:59 <parcs_> > (undefined P.. undefined) undefined `seq` ()
10:18:00 <lambdabot>   *Exception: Prelude.undefined
10:18:45 <dmos> Could someone shed some light on FRP with/vs Arrows? Especially on the practical tradeoffs between the approaches.
10:20:30 * EvanR-work searches for an smtp lib that uses bytestring
10:20:44 <KitB> How do I do modulus on floating values?
10:20:50 <rwbarton> :t mod'
10:20:51 <lambdabot> forall a. (Real a) => a -> a -> a
10:20:57 <KitB> Thanks
10:21:16 <KitB> @hoogle mod'
10:21:16 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
10:21:16 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
10:23:59 <vrook> Is there an idiomatic way to specify an n-tuple type? Like data NTuple length = NTuple (Int, Int, Int) -- use length somehow
10:24:30 <rwbarton> what would you do with that?
10:24:32 <rwbarton> not really
10:24:36 <vrook> There's FixedList http://hackage.haskell.org/packages/archive/fixed-list/0.1.5/doc/html/Data-FixedList.html
10:24:37 <rwbarton> unless you want to use GADTs
10:24:56 <vrook> rwbarton: either fixed list or fixed tuple, doesn't matter to me
10:25:17 <vrook> you don't see an advantage of specifying a fixed-size list as a constraint?
10:25:31 <rwbarton> sure I do but how would it actually work?
10:25:39 <vrook> hey that's my question
10:25:48 <rwbarton> ok then no :P
10:26:30 <mm_freak> EvanR-work: ismtp uses ByteString, but currently it won't compile, because it depends indirectly on the 'dns' library, which has changed its API and i haven't had time to update yet
10:26:43 <rwbarton> there should be an example of size-indexed lists with GADTs somewhere...
10:26:48 <EvanR-work> im using 'dns' right now
10:26:58 <EvanR-work> and it wont compile with latest attoparsec ;)
10:27:05 <EvanR-work> \o/
10:27:25 <EvanR-work> im looking at HaskellNet
10:27:59 <mm_freak> EvanR-work: problem is the 'dnscache' library, which ismtp uses…  i couldn't update it to the new 'dns' API yet
10:28:46 <EvanR-work> seems like smtp is simple enough to hack together yourself for whatever the particular purpose is
10:28:59 <EvanR-work> returning to the time when men were men and wrote their own drivers
10:29:00 <mm_freak> EvanR-work: no need to…  just use the parsers from ismtp
10:29:06 <EvanR-work> im not parsing
10:29:09 <EvanR-work> sending
10:29:16 <EvanR-work> spam, etc
10:29:31 <mm_freak> you need to parse the responses
10:29:37 <mm_freak> don't you?
10:29:52 <rwbarton> vrook: you can do   data Z ; data Succ n ; data List n a where { Nil :: List Z a; Cons :: a -> List n a -> List (Succ n) a }
10:29:55 <EvanR-work> currently smtpclient is doing it
10:30:08 <EvanR-work> not that exchanges responses are very informative
10:30:55 <mm_freak> a classic SMTP client needs only the response codes for most stuff
10:31:13 <EvanR-work> but im pretty sure that smtpclient will fail miserably the minute they send a medium sized attachment
10:31:17 <rwbarton> vrook: then  List (Succ (Succ (Succ Z))) a  is a list of three values of type a
10:31:20 <mm_freak> and for ESMTP the rest has a standardized format
10:32:13 <mm_freak> well, feel free to take the ESMTP code out of ismtp and remove the MX resolving stuff
10:32:17 <mm_freak> it should compile fine
10:32:35 <rwbarton> vrook: however I hesitate to call it "idiomatic" since as far as I know people don't use this much in practice
10:32:40 <mm_freak> it's really only the DNS-related part, which fails to compile
10:32:55 <rwbarton> currently, maybe that will change soon with GHC 7.4
10:33:03 <EvanR-work> mm_freak: what are you using dns cache for?
10:33:30 <mm_freak> EvanR-work: i used ismtp for bulk mailings with many overlapping domains…  dnscache takes care of caching MX servers
10:34:07 <mm_freak> so i could really just say:  "send this email from this address to this address" and ismtp took care of the rest
10:34:07 <EvanR-work> im using a file with history of all mx lookups i did
10:34:39 <mm_freak> dnscache uses an internal Map and also comes with a 'massdns' command line utility, so no need for a file =)
10:35:13 <EvanR-work> yeah i use a map, but its stored in a file to survive restarts
10:35:30 <EvanR-work> i think theres a better way
10:35:37 <mm_freak> the idea was to use acid-state with it
10:35:42 <mm_freak> but i never implemented that
10:35:53 <vrook> rwbarton: thanks. it makes we wonder why metaprogramming seems shunned in haskell. There's the entire GADT extension just to work around a metaprogramming one-liner.
10:36:03 <rwbarton> what?
10:36:06 <vrook> in this case, anyway
10:36:10 <vrook> is what I mean
10:36:13 <EvanR-work> i want to run a separate process for each mass mail job, but the 'requirement' is to throttle globally per domain
10:36:17 <rwbarton> what problem would you solve with metaprogramming
10:36:17 <mm_freak> vrook: huh?
10:36:34 <EvanR-work> so separate programs might have a hard time cooperating to honor the limits
10:36:36 <mm_freak> vrook: i can't confirm that for i am using GADTs for lots of stuff totally unrelated to metaprogramming
10:36:57 <mm_freak> EvanR-work: yeah, i had the same requirement
10:37:06 <mm_freak> EvanR-work: but the corresponding project is nonpublic
10:37:11 <mm_freak> only the SMTP library is public
10:37:18 <EvanR-work> mine too! imagine that
10:37:32 <rwbarton> if you really want to be able to type "3" instead of "(a, a, a)" there is TH for that, but I would seriously question why you think that is a useful thing to do
10:37:33 <mm_freak> i can only give you some hints as to how i did it
10:37:43 <EvanR-work> uh, its patented?
10:37:54 <mm_freak> EvanR-work: what?
10:38:04 <EvanR-work> i dont understand why you have to be limited to hints
10:38:20 <mm_freak> because i'm bound by contracts
10:38:46 <EvanR-work> not really interested in source code, but you cant even talk about it?
10:38:56 <mm_freak> that's what i meant with "hints" =)
10:39:01 <EvanR-work> heh
10:39:10 <vrook> rwbarton: if it were clear and simple to add the constraint of fixed length tuple or list, wouldn't you use it?
10:39:14 <EvanR-work> sounds about the same as the rest of the stuff on this channel then
10:39:18 * EvanR-work goes to lunch
10:39:38 <mm_freak> it's not that complicated actually…  the backbone of the whole project was a postgresql database and the rate-limiting itself wasn't even implemented in haskell
10:39:45 <rwbarton> this sounds like a trap question.
10:39:57 <rwbarton> why do *you* want to use it? maybe we can figure out the best Haskell solution for your case.
10:40:04 <mm_freak> i had a stored procedure, which returned only mail addresses, which i can feed right now
10:40:32 <vrook> rwbarton: you can't imagine a use for a fixed-length tuple/list?
10:40:39 <rwbarton> lol what is this
10:40:49 <rwbarton> (a, a, a) is a fixed-length tuple/list
10:40:53 <geheimdienst> vrook: not entirely sure what you mean, but tuples are always constrained in their length and the types inside. you can't put a 3-tuple into a function that expects a 2-tuple or something like that. this is different from lists, which have variable length
10:40:53 <rwbarton> so Haskell has those
10:42:05 <periodic> Tuples are actually something I sometimes wish for in other languages.  Many OO languages don't seem to support tuples natively, so you go through some weird tricks to return multiple values and assign into local variables in the calling scope.
10:42:26 <vrook> rwbarton: yes, since that three a's are easy to type. But what about N a's?
10:42:41 <rwbarton> what is N?
10:43:02 <vrook> an integer read at compile-time
10:43:19 <rwbarton> okay let's just say N=1000, is that ok?
10:43:27 <vrook> sure
10:43:30 <mm_freak> EvanR-work: in haskell i just had a pool of threads, each waiting for a mail job…  the number of those threads was the upper concurrency limit…  the threads themselves reported back to the database, which in turn marked the MX server group as available again…  but a timestamp would make sure that MX servers are only returned to the program, when they haven't been used for ...
10:43:36 <rwbarton> what am I going to do with a 1000-element tuple?
10:43:36 <mm_freak> ... a certain amount of time
10:43:39 <mm_freak> that's how i did local rate limiting
10:43:47 <rwbarton> unpack it into 1000 local variables?
10:43:57 <vrook> rwbarton: or list, I said it didn't matter
10:44:11 <rwbarton> fine
10:44:16 <rwbarton> why do I care that it has 1000 elements?
10:44:21 <geheimdienst> vrook: in practice, most tuples are 2-tuples. some are 3-tuples. 4 and higher are rare. this is a fundamental difference between tuples and lists
10:44:21 <vrook> what are you going to do with a constraint? Nothing, except enforce the constraint.
10:44:28 <vrook> prove correctness
10:44:44 <rwbarton> okay, the GADT solution allows you to do that sometimes.
10:44:50 <vrook> geheimdienst: whatever, lists then -- I've said it doesn't matter
10:45:02 <rainman85> Hi everyone, I have one quick question: I have an anonymous function which I pass to the map function. The anonymous function returns a tuple if a certain condition is met, otherwise it should return nothing. However I can't get to figure out the return value for the nothing part. Any ideas?
10:45:40 <mm_freak> rainman85: haskell does not have a "nothing" value, but it has a Maybe type
10:45:47 <mm_freak> f :: Int -> Maybe Int
10:45:53 <rwbarton> metaprogramming to generate a (a,a,a,a,...,a) type is just useless though, what am I going to do with that?
10:46:19 <vrook> rwbarton: prove correctness
10:46:36 <rainman85> It is an anonymous function, so it doesnt have a declaration (signature)
10:46:45 <rwbarton> but the only thing I can do with tuples is construct and deconstruct them... so when I use them I already have to write down 1000 things
10:46:50 <roconnor> rainman85: what is your anonymous function?
10:47:03 <Botje> rainman85: it still has types.
10:47:03 <shapr[> I have an autonomous function.
10:47:09 <rainman85> map (\(a, o, _) -> if o == P2 then a) t1
10:47:17 <Botje> rainman85: you could return Just (tup,le) when you have something and Nothing when you have nothing
10:47:20 <rwbarton> so it doesn't really save me very much to be able to represent the type concisely
10:47:25 <rainman85> This one should generate a list of tuples..
10:47:32 <Botje> rainman85: and then use catMaybes to select only the tuples
10:47:35 <rwbarton> and I can just define it once via a type synonym
10:47:52 <mm_freak> vrook: perhaps you would be interested in the HList package
10:47:57 <roconnor> rainman85: try (\(a,o,_) -> when (o == P2) (return a))
10:48:16 <mm_freak> @hackage HList
10:48:16 <lambdabot> http://hackage.haskell.org/package/HList
10:48:23 <roconnor> rainman85: and replace map by concatMap
10:48:50 <carpi> would it be appropriate to assume that an action .. is a body of code that is impure?
10:48:57 <mm_freak> vrook: using tuples for static length guarantees is not the way to go…  HList is the way to go
10:49:01 <rwbarton> if you want to do something like write down an explicit FFT algorithm for a sequence of length 1024, then sure, metaprogramming can be good for that, but writing down the 1024-tuple type is a really small part of that
10:49:02 <roconnor> rainman85: wait did I get that right?
10:49:10 <roconnor> @type (\(a,o,_) -> when (o == P2) (return a))
10:49:10 <lambdabot> Not in scope: data constructor `P2'
10:49:17 <roconnor> @type (\(a,o,_) -> when (o == o) (return a))
10:49:18 <lambdabot> forall t t1 (m :: * -> *). (Eq t, Monad m) => ((), t, t1) -> m ()
10:49:19 <Botje> carpi: only for the IO monad.
10:49:33 <roconnor> @type when
10:49:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:49:44 <mm_freak> but most people don't go that far, because it doesn't play well with real world applications…  if you want to prove things like that, consider using a language like agda or idris
10:49:47 <roconnor> rainman85: crap that isn't right
10:50:00 <carpi> thanx
10:50:00 <vrook> for fuck sake, i don't care about tuples. Only enforcing correctness.
10:50:24 <rainman85> No it isnt.
10:50:25 <rwbarton> why don't you just give example code of the kind of thing you have in mind?
10:50:29 <vrook> tuples is just the roundabout way
10:50:52 <mm_freak> vrook: no need for harsh language…  again, look into HList, it might be just what you need
10:51:03 <mm_freak> it has static length guaratees along with many other features
10:51:12 <xplat> EvanR-work: SMTP, ironic name notwithstanding, is one of the hardest protocols on the net to implement
10:51:18 <rainman85> This worked though: map (\(a, o, _) -> if o == P2 then Just(a) else Nothing) t1
10:51:24 <rainman85> however i have to remove the maybes
10:51:26 <mm_freak> xplat: huh?  why?
10:51:33 <roconnor> rainman85: [a | (a, o, _) <- t1, o == P2]
10:51:50 <roconnor> rainman85: that is probably the clearest way to write that
10:51:52 <jessopher> this wouldnt make any sense would it : newtype (C a) => T a = T a; instance Monad T where ... ?
10:51:56 <mm_freak> xplat: the parser was slightly annoying to implement because of the multi-line stuff, but in general it was very easy compared to protocols like HTTP or IRC
10:52:00 <xplat> loads of extensions, conventions, undocumented weirdness, etc, much of which is a side effect of spam filtering
10:52:05 <roconnor> rainman85: acutally
10:52:10 <roconnor> rainman85: [a | (a, P2, _) <- t1]
10:52:15 <roconnor> is even shorter
10:52:19 <mm_freak> xplat: implementing ESMTP you can ignore most extensions and implement only what you need
10:52:26 <rainman85> wow
10:52:31 <mm_freak> actually you can ignore all extensions
10:52:34 <rainman85> that worked, however id like to understand what that is
10:52:40 <mm_freak> they are all optional
10:52:42 <vrook> rwbarton: I'm not sure where the miscommunication lies. You agreed that it may be useful to prove correctness. Now you are asking me why I want to do that.
10:52:57 <vrook> The answer is to prove correctness.
10:53:22 <roconnor> rainman85: it says to draw all the elements from t1, but only keep the ones that match the pattern (a, P2, _)  and then make a list of those a's.
10:53:59 <cobra-the-joker> Hey there every one ... i have a minor problem here .... i have some file besides the haskell file in the same directory ... when i call it with its name only ; it doesnt find it ... it only work when i call it with its absolute path ... any suggestions ?
10:54:06 <rainman85> oh i see
10:54:08 <rainman85> Cute
10:54:28 <roconnor> rainman85: map (\(a, o, _) -> if o == P2 then Just(a) else Nothing) t1 is good
10:54:39 <mm_freak> cobra-the-joker: try to prepend "./"
10:54:40 <roconnor> rainman85: just follow it with catMaybes
10:54:44 <roconnor> @type catMaybes
10:54:45 <lambdabot> forall a. [Maybe a] -> [a]
10:54:57 <mm_freak> cobra-the-joker: i'm assuming you have a unix/linux workstation there
10:55:12 <cobra-the-joker> mm_freak, yep ... and ./ dont work
10:55:14 <rainman85> I liked your way better
10:55:20 <rainman85> plus it would be good to learn
10:55:21 <rainman85> :)
10:55:27 <roconnor> rainman85: ya, my way is good for this specific example
10:55:35 <mm_freak> rainman85: list comprehensions can be cute, but are also not very composable
10:55:58 <roconnor> rainman85: but it is a little less adaptable to other situations
10:56:00 <mm_freak> using higher order functions is the way to go in general
10:56:24 <mm_freak> cobra-the-joker: if you have a file "test" in the current directory, you can run it by writing:  ./test
10:57:11 <mm_freak> unix/linux don't require the full path, but they require a path by default, because otherwise the paths in the PATH environment variable are searched for a program with the given name
10:57:16 <roconnor> mm_freak, rainman85: on the plus side, my way doesn't rely on an Eq instance :D
10:57:17 <mm_freak> and that one doesn't include "." by default
10:57:20 <rainman85> Yes, I understand.
10:57:33 <roconnor> mm_freak, rainman85: because there is no use of (==)
10:57:38 <cobra-the-joker> mm_freak, yes
10:57:44 <rainman85> But as long as it works in this scenario, i should be safe I hope
10:58:00 <mm_freak> roconnor: you can do that with higher order functions, too ;)
10:58:04 <mm_freak> it's just pattern matching
10:59:34 <mm_freak> but anyway, i think the nicest method is:  concatMap (\(a, o, _) -> guard (o == P2) >> [a])
11:00:23 <mm_freak> i don't like the list comprehension variant, because it relies on 'fail'
11:00:48 <roconnor> mm_freak: no more that yours does in theory
11:01:08 <roconnor> @src guard
11:01:08 <lambdabot> guard True  =  return ()
11:01:08 <lambdabot> guard False =  mzero
11:01:11 <mm_freak> roconnor: mine relies on mzero
11:01:18 <roconnor> oh ya
11:01:27 <mm_freak> so it uses the MonadPlus instance, which has a cleaner 'fail' =)
11:01:32 <roconnor> mm_freak: let's pretend we are using Haskell 1.4
11:01:47 * hackagebot aeson 0.3.2.13 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.13 (BryanOSullivan)
11:01:51 * roconnor thinks we should start a movement to revert back to Haskell 1.4
11:02:04 <mm_freak> what did we have there?
11:02:31 <roconnor> mm_freak: patterns in do statments had a MonadPlus-like constraint IIRC
11:02:56 <mm_freak> well, sometimes i'd love to see something like that for arrow notation
11:03:06 <mm_freak> using ArrowZero for example
11:03:12 <mm_freak> but it just fails with an exception =/
11:03:37 <xplat> mm_freak: oh, if you're only implementing the client side it's not as bad as HTTP
11:04:00 <roconnor> mm_freak: ya patterns in do statments had a MonadZero constraint
11:04:04 <xplat> although i still wouldn't call it 'simple' anymore
11:04:10 <mm_freak> xplat: server side isn't much worse, because you don't need to provide any extensions
11:04:26 <roconnor> mm_freak: see 3.14 of http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/exps.html
11:04:29 <mm_freak> xplat: so you can have a working library and later add extensions on demand
11:04:43 <mm_freak> roconnor: i wonder why that changed
11:04:52 <roconnor> I'd like to know
11:05:28 <mm_freak> and i really wonder why they removed MonadZero at all
11:05:41 <xplat> but the problem with SMTP is it's less a matter of 'oops it didn't work'
11:06:06 <xplat> and more a matter of 'this won't work for some clients/some destination addresses'
11:06:25 <roconnor> mm_freak: 3.14 is exactly how I'd like to see do notation redefined as
11:06:30 <xplat> and in the latter case 'and this is increasing rapidly with time as my server gets put on blacklists'
11:06:40 <rwbarton> incidentally there was a recent libraries@ discussion which touched on this subject of MonadPlus & do
11:06:45 <mm_freak> xplat: a standards-conforming SMTP client needs to assume that the server doesn't understand EHLO, so there is only classic SMTP
11:06:48 * hackagebot aeson 0.3.2.14 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.14 (BryanOSullivan)
11:06:48 <cobra-the-joker> mm_freak, that was because the terminal i loaded the haskell file in wasn't open at the same directory
11:06:50 * hackagebot hashtables 1.0.1.0 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.0 (GregoryCollins)
11:07:38 <roconnor> mm_freak: it is, however, a type-directed translation.  I don't know if the Haskell '98 translation is type-directed.
11:07:42 <mm_freak> rwbarton: i think a MonadPlus constraint would be too much…  i'd rather like to see MonadZero come back
11:07:59 <mm_freak> or rather throw the current broken class hierarchy altogether and start from scratch
11:08:01 <rwbarton> oh, sorry, yeah it was actually MonadZero/MonadFail
11:08:18 <xplat> like, accepting local mail is easy because you can talk the client down to the level you want to use, and clients usually respect that, yes
11:08:24 <RomyEatsDrupal> hi.. Romy here… anyone located in New York City, by the way?  I would appreciate meeting up for Haskell.
11:08:54 <xplat> although some people have their clients set to reject a server that doesn't use SSL, you can talk the actual users into turning it off, and other MTAs don't care
11:09:20 <rwbarton> This Haskell 1.4 "failure-free" notion does look pretty sensible.
11:09:51 <xplat> but if your MTA allows proxying by default other people's MTAs will stop speaking to it
11:10:23 <nexion> I seem to be getting the same 'unique' identifier using idFromSupply from Data.Unique.Id when trying it in ghci.. what could be the reason?
11:10:25 <mm_freak> xplat: all that doesn't automatically put you on blacklists
11:10:35 <hiptobecubic> whatami :: [a] -> [a] -> [a];   whatami [1,3,5] [2,4,6] == [1,2,3,4,5,6]
11:11:01 <xplat> no, you can be okay for weeks, until a spammer figures out that you are an open proxy
11:11:12 <nexion> supply <- initIdSupply 'C'; idFromSupply supply... always returns C0
11:11:25 <mm_freak> xplat: also SSL with SMTP is kind of like a bad joke…  the whole infrastructure of mail exchangers is entirely in plaintext, there isn't even authentication
11:11:35 <hiptobecubic> hoogle isn't helping me
11:11:43 <xplat> hysteresis like that doesn't make things easier
11:11:44 <mm_freak> xplat: then you shouldn't be an open proxy…  that's not related to SMTP
11:11:56 <JuanDaugherty> hey parcs_
11:12:18 <parcs_> hello JuanDaugherty
11:12:46 <JuanDaugherty> did you say the other day that HP 2011.4 was waitin on ghc 7.4?
11:13:17 <mm_freak> hiptobecubic: whatami = liftA2 ((S.toList .) . S.union) S.fromList S.fromList
11:13:39 <mm_freak> hiptobecubic: incidentally i pasted a list version of that today
11:13:52 <rwbarton> how about sort . concat
11:13:58 <mm_freak> hiptobecubic: http://hpaste.org/54710
11:14:01 <mm_freak> see 'union'
11:14:03 <rwbarton> or rather whatami x y = sort (x ++ y)
11:14:13 <mm_freak> rwbarton: slow
11:14:14 <rwbarton> anyways that wasn't what I guessed he meant
11:14:19 <rwbarton> ?
11:14:30 <mm_freak> but safer
11:14:31 <rwbarton> both are n log n
11:14:40 <xplat> mm_freak: if you want your MTA to be a mail delivery agent for your users, you must either implement some kind of authentication (and that usually means several kinds if your users use more than one MUA) or host-based auth (inflexible), or else you're an open proxy
11:14:41 <rwbarton> did you want fromAscList?
11:14:50 <rwbarton> or whatever it's called
11:14:52 <parcs_> JuanDaugherty, that's what i've read
11:15:00 <hiptobecubic> doesn't have to be sorted
11:15:09 <mm_freak> xplat: yes, and all clients understand LOGIN
11:15:13 <donri> what is an efficient list-like type for "append to end" and "read last"? plain list?
11:15:16 <hiptobecubic> just "zip" the lists up and concat the tuples into one big list
11:15:23 <mm_freak> xplat: as said, you can extend on demand
11:15:32 <JuanDaugherty> parcs_, just was a little surprised when I saw 7.4 didn't even seem to be announced, scheduled
11:15:55 <mm_freak> you can have a working SMTP implementation quickly and then add extensions as you need them
11:16:00 <rwbarton> donri: that sounds like you're using a list but you're calling the "front" the "end" instead?
11:16:18 <mm_freak> rwbarton: my variant assumes already sorted lists
11:16:26 <mm_freak> it's O(n+m)
11:16:29 <donri> rwbarton: ah, so i should use a list but from the other end
11:16:35 <donri> (specifically, it's for a revision log)
11:17:03 <rwbarton> mm_freak: I think you should check the documentation for S.fromList.
11:17:09 <mm_freak> hiptobecubic: concat . zipWith (\x y -> [x,y])
11:17:21 <hiptobecubic> i'm surprised this isn't in the standard library
11:17:44 <rwbarton> Or are you saying that it is O(n) when the list is sorted but O(n log n) in general?
11:17:46 <mm_freak> rwbarton: or you should read everything i write and not stop at some key spot =)
11:17:59 <rwbarton> At what spot do you think I stopped reading?
11:18:23 <mm_freak> rwbarton: <mm_freak> hiptobecubic: incidentally i pasted a list version of that today
11:18:32 <mm_freak> followed by an hpaste URL
11:18:41 <parcs_> JuanDaugherty, 7.4 has been branched last week.. i'm not sure but there will probably be a release before the end of the year
11:18:57 <JuanDaugherty> ah
11:19:25 <mm_freak> hiptobecubic: actually that's a type error…  rather:  (concat .) . zipWith (\x y -> [x, y])
11:19:26 <rwbarton> Oh, sorry, I did not understand which "my version" you were referring to.
11:19:32 <parcs_> it's going to be quite a release: http://www.reddit.com/r/haskell/comments/mm68o/ghc_74_branched_whats_in_for_christmas/
11:19:55 <rwbarton> Particularly as you suggested my version was "slow" before you gave a link to what turned out to be your version
11:20:03 <mm_freak> hiptobecubic: haskell makes it so easy to write these things that it feels to people like every kind of list transformation you could think of should be in the base library =)
11:20:06 <EvanR-work> am i gonna have to reinstall ghc again ._.
11:20:49 <mm_freak> rwbarton: well, it is slow
11:20:59 <hiptobecubic> mm_freak, sure, but this doesn't seem that obscure of a function
11:21:04 <rwbarton> As is liftA2 ((S.toList .) . S.union) S.fromList S.fromList.
11:21:08 <hiptobecubic> mm_freak, "alternate" or something
11:21:33 <mm_freak> rwbarton: [] is slow here, unless you assume the list to be presorted
11:21:42 <mm_freak> S.union is fast
11:21:45 <xplat> promotion of data types to kinds?  cool
11:21:55 <xplat> still no TypeNats though?
11:22:34 <rwbarton> S.fromList is not fast, though, as far as I can tell, though it could be fast on sorted data while still being correct on unsorted data, and that seems like a reasonable design goal.
11:22:42 <xplat> i mean, you could use data Nat = Z | S Nat as a kind, but you'd miss out on all that nifty constraint solving
11:22:43 <mm_freak> hiptobecubic: i don't see so much use for it to justify adding it to the base library…  it's very simple to write anyway
11:23:23 <hiptobecubic> mm_freak, so is head
11:23:49 <EvanR-work> hiptobecubic: this function doesnt look very generally useful
11:24:20 <mm_freak> hiptobecubic: the point is, if you were to add every sometimes-useful, easily-constructed snippet to Data.List, it would grow 100 times its current size
11:24:38 <EvanR-work> and would cause a namespace nightmare
11:24:43 <mm_freak> i think the selection of list functions in Data.List is fine, because you can construct most other stuff easily out of it
11:24:49 <EvanR-work> cant use 'discombobulate' anymore1
11:25:07 <xplat> > let head = foldr const $ error "no head for the headless" in head [3,4]
11:25:08 <lambdabot>   3
11:25:49 <hiptobecubic> it's not useful? you've never needed to take one from each of a list in turn?
11:26:06 <mm_freak> "not useful"?
11:26:08 <EvanR-work> you mean zip together two lists
11:26:18 <hiptobecubic> but then you get tuples
11:26:26 <mm_freak> i never said "not useful"
11:26:28 <EvanR-work> i did
11:26:42 <mm_freak> hiptobecubic: no, i never do that
11:27:07 <hiptobecubic> mm_freak, maybe you would if it were in the library :D
11:27:14 <EvanR-work> 'use it because its there!'
11:27:18 <EvanR-work> now were php!
11:27:28 <mm_freak> no, i wouldn't…  'sort' is there, too, and still i don't use it ;)
11:27:39 <hiptobecubic> you never have to sort anything?
11:27:40 <mm_freak> reason is:  i don't use [] for streams
11:27:51 <mm_freak> and i don't use [] for sorting stuff
11:28:00 <hiptobecubic> mm_freak, what's your method then?
11:28:30 <mm_freak> depends on the application…  can be a stream arrow, a stream comonad, an iteratee or even a thread listening on an MVar
11:29:04 <EvanR-work> sorting a stream makes sense?
11:29:17 <mm_freak> that was related to streams, not to sorting
11:29:24 <mm_freak> for sorting, Vector is a good choice
11:29:35 <hiptobecubic> we were talking about how you never use sort and you said you don't use [] for streams for some reason
11:30:05 <mm_freak> hiptobecubic: no, i was talking about the missing 'alternate' thing you wondered about
11:30:35 <mm_freak> <hiptobecubic> mm_freak, what's your method then? ⇐ you didn't specify what you were referring to =)
11:30:51 <mm_freak> for sorting definitely Vector
11:31:00 <mm_freak> the vector-algorithms package to be exact
11:31:27 <mm_freak> but yeah, i don't sort often, because Map and Set are already sorted =)
11:31:48 * hackagebot cqrs 0.6.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.6.0 (BardurArantsson)
11:31:50 * hackagebot cqrs-sqlite3 0.6.0 - SQLite3 backend for the cqrs package.  http://hackage.haskell.org/package/cqrs-sqlite3-0.6.0 (BardurArantsson)
11:35:00 <EvanR-work> so to take 100 'any' elements from a Set, (take 100 . toList) s ?
11:35:07 <EvanR-work> or should i use toAscList
11:36:04 <rwbarton> toList and toAscList are actually the same anyways
11:36:22 <EvanR-work> will i be able to efficiently subtract them from the set?
11:36:52 * hackagebot cqrs-example 0.6.0 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.6.0 (BardurArantsson)
11:37:04 <copumpkin> EvanR-work: more or less
11:37:10 <copumpkin> EvanR-work: you can split the set on the last element you receive
11:37:17 <copumpkin> and take the upper half of the split
11:37:41 <EvanR-work> wow
11:38:04 <EvanR-work> but it will only work if im guaranteed to get an ascending list
11:38:08 <mm_freak> EvanR-work: if you need a list in the end, then take n . toList is fine
11:38:15 <copumpkin> yeah, which you are, especially if you use toAscList
11:38:28 <EvanR-work> mm_freak: 100 as a set would be fine
11:38:40 <copumpkin> I'd do
11:39:01 <copumpkin> S.split myset (S.toAscList myset !! 100)
11:39:09 <copumpkin> then the left half is your 100
11:39:12 <copumpkin> and the other is the rest
11:39:22 <copumpkin> there might be something in the middle which you need to account for
11:39:28 <copumpkin> my web browsing is locked down so I can't check the docs
11:39:47 <EvanR-work> is !! 100 a dumb move?
11:39:52 <copumpkin> nope
11:39:58 <mm_freak> note, S.split will drop the element given
11:40:05 <mm_freak> you'll want splitMember
11:40:19 <copumpkin> actually, it is
11:40:25 <copumpkin> but not because of !!
11:40:48 <mm_freak> also there is no (!!) for Set, as far as i see in containers-0.4.0
11:40:49 <copumpkin> it doesn't need to be linear in the number, but I can't think of a way at getting at the size of your subtrees in the Set API
11:40:54 <copumpkin> mm_freak: that was on list
11:41:00 <rwbarton> there should be one though
11:41:02 <mm_freak> oh, wait
11:41:24 <mm_freak> then this should be besser:  fromDistinctAscList . take 100 . toAscList
11:41:26 <rwbarton> I mean there ought to be one, since the data structure knows how large the subtrees are
11:41:35 <mm_freak> besser → better
11:41:52 <copumpkin> mm_freak: not if he wants the "rest" too
11:41:54 <copumpkin> which he said
11:42:15 <mm_freak> then i'd go with list splitAt instead
11:42:18 <EvanR-work> split a set into 100 'any' and the rest
11:42:21 <mm_freak> with two fromDistinctAscList
11:42:22 <copumpkin> it can be done in O(log(n))
11:42:37 <copumpkin> not sure why you'd want to go through the list at all
11:42:44 <mm_freak> (fromDistinctAscList *** fromDistinctAscList) . splitAt n . toAscList
11:42:45 <EvanR-work> i wouldnt, in principle
11:42:52 <EvanR-work> but for loops only work on lists ;)
11:42:55 <mm_freak> copumpkin: because (!!) goes through the list anyway
11:43:03 <copumpkin> mm_freak: yeah, and I was saying that approach sucked :P
11:43:07 <rwbarton> what about the other n-100 elements
11:43:10 <mm_freak> hehe
11:43:18 <mm_freak> there is no good way to do it, as it seems
11:43:25 <copumpkin> mm_freak: even with my approach with !!
11:43:29 <copumpkin> it'd be more efficient than that
11:43:37 <copumpkin> since yours is O(n) for n = total size
11:43:44 <mm_freak> there might be a somewhat clean soluting using minView/maxView
11:43:47 <copumpkin> mine is O(100) or whatever number he asks for at !!
11:43:55 <rwbarton> O(100+log(n))
11:43:58 <copumpkin> yep
11:44:09 <rwbarton> minView is probably O(100*log(n))
11:44:11 <copumpkin> O(14351)
11:44:11 <mm_freak> using S.union together with S.minView
11:44:46 <mm_freak> although that makes it O(n * (log n)^2)
11:44:51 <mm_freak> no
11:44:55 <rwbarton> ideally you should be doing the whole thing in O(log n)
11:44:59 <mm_freak> although that makes it O(n * 2 * log n)
11:45:11 <mm_freak> right, but i'm not sure that's possible at all
11:45:13 <rwbarton> but you can't with the Set API, though you should be able to
11:45:14 <copumpkin> this sounds like it needs a libraries proposal :P
11:45:35 <EvanR-work> bwahahaha
11:45:36 <copumpkin> in fact, I'd like Set to embrace its orderedness
11:45:36 <rwbarton> yes
11:45:38 <mm_freak> hehe yeah
11:45:43 <copumpkin> providing a lookup by index
11:45:49 <copumpkin> we like to pretend it doesn't have an order
11:45:56 <donri> ixset?
11:45:56 <mm_freak> well, Map has index operations
11:45:59 <copumpkin> but we can't construct one without an order
11:46:02 <mm_freak> should be possible for Set as well
11:46:14 <EvanR-work> i want an unordered set
11:46:14 <copumpkin> donri: I just mean Int
11:46:20 <copumpkin> a -> Bool
11:46:21 <copumpkin> have fun
11:46:35 <EvanR-work> Eq set ;)
11:46:43 <rwbarton> oh wow Map does have that, yeah
11:46:51 <rwbarton> @hoogle elemAt
11:46:51 <lambdabot> Data.Map elemAt :: Int -> Map k a -> (k, a)
11:46:57 <copumpkin> ah
11:47:02 <copumpkin> that'll make the set proposal easier though
11:47:08 <xplat> so just use Map a () instead of Set a
11:47:39 <EvanR-work> you can split a map?
11:47:45 <copumpkin> yeah
11:48:04 <EvanR-work> heh seems like set is just a degenerate map ;)
11:48:23 <copumpkin> yep
11:48:28 <donri> isn't Map implemented in terms of Set?
11:48:39 <copumpkin> not that I know of
11:48:45 <copumpkin> but they're both using very similar structures under the hood
11:48:46 <EvanR-work> wouldnt work, set doesnt have enough stuff
11:48:54 <hiptobecubic> mm_freak, so why are you using vectors all the time? Speed problems?
11:48:55 <donri> or was it the other way around
11:49:00 <xplat> i haven't looked at the source, but usually it's the other way around or a common tree type, if anything
11:49:21 <copumpkin> I think there's just lots of code duplication
11:49:30 <copumpkin> but I've only looked at the Map source
11:49:56 <mm_freak> EvanR-work: i think the Ord instance is only used for efficiency, because without Ord most operations will be O(n)
11:50:09 <xplat> lists in haskell make a better control structure than data structure, usually
11:50:11 <EvanR-work> mm_freak: right, unless !
11:50:34 <mm_freak> hiptobecubic: not all the time
11:50:42 <EvanR-work> a -> Bool, this is the future
11:50:44 <mm_freak> hiptobecubic: my most common data structure is Map
11:52:41 <mm_freak> hiptobecubic: i seldomly use lists…  most of my list uses is related to the base library API (mapM, mconcat, etc.)
11:54:19 <EvanR-work> String ;)
11:54:45 <mm_freak> not that often actually
11:55:17 <luite> I usually use strings in small applications. all large web frameworks expect you to use Text instead
11:57:37 <lukish> @pl print . fst . head . dropWhile (\x -> snd x < (10^10)) . map (\(n,p) -> (n, (2 * p * n)) )
11:57:37 <lambdabot> print . fst . head . dropWhile ((< 10 ^ 10) . snd) . map (uncurry (liftM2 (.) (,) ((. (2 *)) . (*))))
12:01:48 * hackagebot http-enumerator 0.7.1.7 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.7 (MichaelSnoyman)
12:02:25 <dmos> What is the recommended way to model synchronous discrete dataflow in Haskell? Arrows, FRP, something else?
12:02:50 <xplat> possibly comonads for that
12:03:06 <conal> or even simply lists
12:03:44 <dmos> comonads? Is there an example/paper somewhere which would point me in the correct direction?
12:03:50 <conal> or simpler yet, maybe streams
12:04:27 <dmos> Streams in a similar way as defined for iteratees (which I also looked at).
12:04:28 <conal> dmos: http://lambda-the-ultimate.org/node/988
12:05:54 <dmos> conal: ok, thanks, will read that (actually read it some time ago, but my Haskell-fu has hopefully improved since then).
12:05:54 <conal> dmos: i think iteratees are more about implementation than semantics/clarity. if you try streams first, you might get a clearer picture of what you want.
12:06:07 <conal> dmos: yeah. it's not intro stuff.
12:06:24 <conal> @hackage stream
12:06:24 <lambdabot> http://hackage.haskell.org/package/stream
12:06:53 <conal> dmos: that comonadic dataflow paper is probably more abstract than you really need.
12:07:02 <Melvar> For fun, I decided to write a vector space typeclass. It ended up being a vector space typeclass along with typeclasses of many more general structures.
12:07:13 <dmos> OK, I'll check.
12:08:23 <dmos> conal: but then you'd advise that FRP isn't really the right direction to investigate in, since (I assume) it's mainly concerned with modeling time and continuous functions over it (if I understood correctly).
12:09:43 <conal> dmos: or i'd suggest re-examining your reasons for wanting discrete time, considering whether it's natural or habitual.
12:10:27 <conal> dmos: functional programming is so much about composability, which discreteness and finiteness thwart.
12:10:43 <conal> and ditto for semantic clarity/simplicity
12:11:08 <dmos> conal: it's natural, because I receive a continuous stream of events. There's actually a field which concerns itself with it (although I don't think it's research) which is called event stream processing. It's applications seem to be fairly close to what I need.
12:11:23 <dmos> (single stream of events)
12:12:17 <conal> dmos: possibly natural, possibly still habitual. i wonder why your input is discrete. maybe it's a representation imposed on you by someone else's implementation decision.
12:12:41 <conal> dmos: for instance, in GUIs, mouse motion is presented discretely by the OS but is naturally continuous
12:12:57 <conal> dmos: similarly, pictures often come in finite & discrete, but unnaturally so.
12:13:00 <EvanR-work> real numbers have a problem with semantic clarity ;)
12:13:21 <conal> in both cases, you can reconstruct better approximations to the original natural signals.
12:13:33 <conal> to improve both simplicity & accuracy
12:14:04 <dmos> conal: they are transaction acknowledgements, therefore I'd say they are naturally discrete.
12:14:14 <conal> dmos: what kinds of transactions?
12:14:43 <hpaste> qgel pasted “works” at http://hpaste.org/54729
12:15:04 <dmos> conal: business transactions. Think stock trades if you will.
12:15:16 <conal> dmos: i'm poking only because people are often unaware of their habits/assumptions.
12:15:22 <hpaste> qgel pasted “doesn't work” at http://hpaste.org/54730
12:15:31 <FUZxxl> Nice question: http://stackoverflow.com/q/8332392/417501
12:15:42 <conal> dmos: ah. hm. might indeed be naturally discrete.
12:15:49 <FUZxxl> It's always funny to see how far you can coerce Haskell's type system
12:15:56 <FUZxxl> to do strange things
12:15:57 <Botje> qgel: correct. what did you expect the 'doesn't work' case would do?
12:16:00 <dmos> conal: agreed, and I can understand that it's often assumed to be discrete when it's in fact not.
12:16:20 <hpaste> qgel pasted “order” at http://hpaste.org/54731
12:16:48 * hackagebot heist 0.6.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.6.1 (DougBeardsley)
12:16:55 <Axman6> FUZxxl: should be a bit easier in 7.4
12:16:57 <conal> dmos: yeah. especially among programmers. they're are equally programmees.
12:17:01 <qgel> oh i did not realize it would paste this to the channel right away, sorry for the spam :(
12:17:19 <conal> "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
12:17:25 <dmos> conal: the kind of representation that I'm thinking of is some sort of automaton which steps ahead on each event it receives, and it looks like the Event part of FRP and/or arrows are fairly close (and as mentioned I'll have to investigate comonads and streams).
12:17:53 <EvanR-work> conal: im having a real problem getting my overlords to allow me to throw out our tools
12:17:57 <EvanR-work> which suck
12:18:03 <qgel> Botje: I'm completely new to haskell, I don't understand why one works and the other doesnt. Shoudlnt the combined pattern be the same regardless of the order?
12:18:09 <conal> dmos: yeah. Automaton may well be a better fit for you than FRP.
12:18:16 <Botje> qgel: the variable xs also matches the empty list []
12:18:17 <dmos> conal: 'programmees', interesting idea, and true.
12:18:34 <FUZxxl> Axman6: What is new in 7.4?
12:18:45 <Botje> > case (1:[]) of (x:xs) -> xs
12:18:46 <lambdabot>   []
12:19:17 <qgel> Botje: So it doesnt in the first case because that pattern is already "taken" ?
12:19:38 <Botje> yes. haskell matches patterns from the top down
12:20:17 <qgel> Botje: Thank you, I think I understand now :)
12:20:27 <dmos> conal: ok, so then FRP is probably out (or at least reduced). Thanks, that has already reduced my mental load a bit. The main difficulty is to understand under what conditions to apply what tool from the toolbox.
12:20:58 <cheater> dmos: what did you want to use frp for?
12:21:21 <dmos> "What is the recommended way to model synchronous discrete dataflow in Haskell? Arrows, FRP, something else?"
12:21:31 <dmos> cheater: ^^
12:21:54 <cheater> is that a stochastic model?
12:21:57 <dmos> cheater: and comonads as well as Streams have been mentioned to be worth looking into, which is now on the list.
12:22:06 <cheater> are you trying to observe something in networking theory?
12:22:43 <conal> dmos: that question might do with some improvement. i think of dataflow an an implementation technique, so i wouldn't expect to want to model it in haskell.
12:23:12 <conal> dmos: but rather reflect on what semantics it is _one_ implementation of.
12:23:44 <dmos> cheater: it's event stream processing of discrete business transaction events. I'm not entirely sure whether a stochastic model is part of it.
12:24:20 <Melvar> How do people usually make typeclasses for multiplicatively written groups and additively written groups so one type can have different instances for each?
12:24:27 <conal> dmos: see http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631#1030631 if you haven't already.
12:25:03 <cheater> dmos: where does said event stream come from?
12:25:06 <dmos> conal: yes, saw that one.
12:25:50 <dmos> cheater: from a central transaction broker. If you think stock trades, it's fairly similar.
12:25:59 <cheater> is it over udp etc?
12:26:09 <cheater> do you have to react in a specific amount of time (soft realtime)?
12:27:10 <dmos> cheater: udp and tcp (there will be more than one broker in the future). soft realtime not yet spec'd but preferred as it's latency sensitive.
12:29:46 <cheater> dmos: normally with event sources you'd use reactive programming
12:30:04 <dmos> cheater: re. your question earlier: it is a stochastic model in the sense of that it's purely driven from the outside.
12:30:31 <alpounet> Melvar, generally people use newtype to allow this
12:30:35 <cheater> but for soft realtime you don't want to, because reactive programming can explode out of your allowable period
12:30:59 <lukish> @pl (\x -> x `mod` (10^10))
12:31:00 <lambdabot> (`mod` (10 ^ 10))
12:31:02 <cheater> what you instead want is a DSP based model.
12:31:04 <EvanR-work> use an interrupt handler!
12:31:13 <cheater> those can react with a latency of microseconds.
12:31:50 <cheater> however, you need to be creative and see some interesting things that i wouldn't be able to explain over irc in one sentence :)
12:33:15 <dmos> cheater: DSP based model: ok, but now we're talking hardware, yes? Or would you still implement that in software on a standard OS?
12:33:37 <cheater> no we're talking software
12:33:46 <dmos> cheater: and, yes, IRC does have it's limitations.
12:33:48 <cheater> DSP does not mean "motorola 56xxx"
12:34:20 <cheater> i know one guy who brought those to the market :) but i wouldn't suggest those anywhere near a financial model lol
12:36:30 <dmos> cheater: Well if possible I'd really like to stay in Haskell, as the productivity increase is hard to regain on a hardware level. And implementing financial models on hardware doesn't sound like too much fun (although with a FPGA it could be).
12:36:39 <cheater> you'd need to think in terms of things like non-linearities, wave shapers, low pass filters, etc
12:36:48 <cheater> then you can get amazing response times
12:36:53 <cheater> you can do this in any language you want.
12:36:59 <cheater> haskell is good too.
12:37:07 <EvanR-work> i dont see how dsp makes your response time lower
12:37:26 <cheater> dsp is a method of writing models
12:37:32 <EvanR-work> not that dmos is even talking about response time
12:37:44 <cheater> which is geared exactly towards streams of data
12:37:48 <cheater> this data can be anything
12:38:06 <EvanR-work> and what does this have to do with lower response time?
12:38:16 <dmos> cheater: do you have some information/examples/papers where I could see more of such a DSP based approach (preferably in Haskell).
12:39:02 <cheater> http://www.dsprelated.com/dspbooks/filters/
12:39:23 <EvanR-work> >_>
12:40:01 <dmos> EvanR-work: :)
12:41:42 <dmos> cheater: Ok, running with the DSP idea, do you have an idea how to best translate this into Haskell, without resorting to having permanently import all of the FFI? Are there suitable abstractions in Haskell to implement that?
12:43:18 <cheater> this approach is language-agnostic
12:43:46 <cheater> you can do this in anything from assembler (happens quite often) to agda
12:43:58 <cheater> more reading: https://ccrma.stanford.edu/~jos/pubs.html
12:44:50 <EvanR-work> not every stream processing question is going to have dsp as the answe
12:45:06 <carpi> are name defined in a do block availble outside it?
12:45:19 <EvanR-work> no
12:46:26 <cheater> of course not
12:46:31 <cheater> but it's one place to look for things
12:46:44 <cheater> being at least familiar with the topics is inevitable
12:46:50 <cheater> obviously dmos has never heard of any of that
12:48:14 <dmos> cheater: true that you can implement it in any language, but I have seen eg. functional programming in a very OO-ish language, and the experience was jarring. So the question is, how to best express a DSP style approach in Haskell. Since DSP algorithms as (as far as I know) also written in Lucid, Lustre, and co I'd be interested how to have similar language constructs in Haskell.
12:48:36 <EvanR-work> http://hackage.haskell.org/package/dsp ;)
12:48:55 <EvanR-work> there you go
12:49:11 <EvanR-work> get your chebyshevs out
12:49:20 <dmos> EvanR-work: heh, didn't see that one. Thanks.
12:53:38 <Melvar> alpounet: I was asking about the typeclass level. I want to have a typeclass for groups, and a typeclass for abelian groups based on it, with a different set of symbols, with the possibility of having an Abelian instance different from the Group instance.
12:54:50 <EvanR-work> Melvar: http://hackage.haskell.org/package/algebra-2.0.4
12:54:53 <EvanR-work> \o/
12:55:11 <EvanR-work> get your involutive semirings out
12:57:42 <EvanR-work> question, how do make an IO action execute once per minute
12:57:57 <EvanR-work> not exactly on the minute is ok, but drift is not
12:58:02 <saml> what's difference between parallel and non-parallel? synchronous and asynchronous?  are they essentially the same?
12:58:03 <EvanR-work> thats the challenge
12:58:19 <saml> EvanR-work, does it have to be exactly 60 minutes?
12:58:36 <saml> do { f; sleep 60; recurse; }  ?
12:58:42 <EvanR-work> that will drift
12:58:43 <copumpkin> that would drift
12:58:51 <saml> what does drift mean?
12:58:56 <copumpkin> if f takes 30 seconds
12:59:02 <EvanR-work> wait a long time and divide total time by total triggers
12:59:14 <dmos> EvanR-work: Going back to your remark that not stream processing question needs a DSP style answer, do you have by any chance a suggestion for discrete event stream processing in Haskell, and how to model them?
12:59:16 <EvanR-work> if its not almost exactly 1 per minute, then BRRR wrong
12:59:21 <saml> if f takes more than 60 seconds, what do you want to do?
12:59:31 <dmos> Current tech portfolio: arrows, comonads, Streams, some other form of automata, and the DSP approach discussed before. Out: FRP
12:59:44 <saml> do you want 1 minute gap between f's?
12:59:48 <EvanR-work> dmos: yeah look at automaton and streams
12:59:55 <Botje> EvanR-work: synchronize with an MVar?
13:00:15 <EvanR-work> and who is writing to the mvar
13:00:16 <oghamb> Hi, #haskell! I need a function that's like zipWith, except it makes a square. Like, two lists of 4 elements make a list of 16 elements. Is there one?
13:00:23 <copumpkin> EvanR-work: keep track of next time you should run, subtract current time after f from then, sleep that long
13:00:30 <copumpkin> if f took too long, the sleep will be 0 or negative
13:00:33 <copumpkin> so you "catch" up
13:00:47 <copumpkin> or a Chan might be easiest
13:00:52 <Botje> oghamb: liftM2
13:00:52 <copumpkin> oh wait, no
13:01:02 <Botje> or liftA2, i guess
13:01:05 <saml> oghamb, scan?
13:01:08 <copumpkin> EvanR-work: can you run those things concurrently?
13:01:20 <saml> scanl
13:01:32 <EvanR-work> copumpkin: it should be almost instant, the effect, no where near the period
13:01:38 <saml> oh it sounds like matrix?
13:01:45 <oghamb> yeah, like a matrix.
13:01:48 <copumpkin> EvanR-work: actually that's probably the best way, without dealing with subtracting time at all
13:01:53 <oghamb> I've heard of liftM2 but not liftA2
13:01:53 <kmc> > liftM2 (,) "abc" "xyz"  -- oghamb
13:01:54 <lambdabot>   [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c'...
13:01:56 <applicative> > liftM2 (*) [1..4] [10,20,30,40]
13:01:57 <lambdabot>   [10,20,30,40,20,40,60,80,30,60,90,120,40,80,120,160]
13:02:00 <EvanR-work> copumpkin: what is?
13:02:07 <saml> oghamb, can you give me example?  [1,2,3,4] `f` [1,2,3,4]  ==> ???
13:02:15 <oghamb> Oh, thanks!
13:02:29 <copumpkin> EvanR-work: loopy a = do forkIO a; threadDelay 60; loopy a
13:02:40 <oghamb> saml: [(1,1), (1,2), (1,3), (1,4), (2,1), etc]
13:02:43 <EvanR-work> copumpkin: right, but thats going to drift
13:02:45 <applicative> > [x * y | x <- [1..4] , y <- [10,20,30,40]]
13:02:46 <lambdabot>   [10,20,30,40,20,40,60,80,30,60,90,120,40,80,120,160]
13:02:50 <copumpkin> EvanR-work: why?
13:02:54 <EvanR-work> er
13:03:12 <copumpkin> oh, the forkIO time?
13:03:18 <saml> liftM2 sounds about right
13:03:20 <applicative> > [(x,y) | x <- [1..4] , y <- [10,20,30,40]]
13:03:21 <lambdabot>   [(1,10),(1,20),(1,30),(1,40),(2,10),(2,20),(2,30),(2,40),(3,10),(3,20),(3,3...
13:03:26 <EvanR-work> copumpkin: wtf is a
13:03:34 <copumpkin> EvanR-work: the IO action you want to run every 60 seconds
13:03:41 <EvanR-work> ok
13:03:51 <saml> what if a takes longer than 60?
13:03:53 <EvanR-work> its gonna drift, thats the same as saml's suggestion
13:04:00 <copumpkin> EvanR-work: you mean due to forkIO time?
13:04:05 <oghamb> Thanks, everybody
13:04:16 <saml> what do you expect if a takes more than 60 seconds?
13:04:18 <copumpkin> that's negligible, but you can avoid it with the subtraction
13:04:24 <copumpkin> saml: mine will just run them concurrently
13:04:39 <copumpkin> if you don't want that, you can make a choking action using kmc's library
13:04:41 <saml> do you want something like cron that executes  a  on 0 sec, 60 sec, 120 sec, ... but skip if a hasn't finished running?
13:04:48 <EvanR-work> saml: it does not matter
13:05:00 <EvanR-work> let it start another long ass effect
13:05:08 <EvanR-work> my effect will be istant
13:05:16 <saml> so, eventually, your system could be loaded
13:05:26 <saml> if  a takes a long time to finish.
13:05:32 <saml> let's say a takes 3 months to finish.
13:05:37 <EvanR-work> >_>
13:05:47 <copumpkin> saml: that really isn't his point here
13:05:47 <EvanR-work> and a user could give you a csv file with size 194 terrabytes
13:06:00 <saml> if i re-index my database,  it'll take 3 months :(
13:06:27 <EvanR-work> imagine that a is in the class of effects such as launch missiles
13:06:40 <saml> yah write robust code
13:06:41 <xplat> so then you only need to run it once
13:06:41 <EvanR-work> and missiles launch in zero seconds
13:06:53 <EvanR-work> no, you have infinite ammo
13:07:18 <xplat> you can't keep launching the missiles after you blow up
13:07:35 <EvanR-work> the missiles dont blow me up
13:07:38 <copumpkin> EvanR-work: so you're going to have to sleep for now - next timestep each time
13:07:52 <xplat> that's what the other guy's missiles are for
13:08:29 <saml> write robust code so that making a small change could affect the rest of the system.
13:08:32 <EvanR-work> copumpkin: alright. so i guess the answer is sleep for 'a while', calculate how many effects should have occured based on current time and last time, then do them all, repeat
13:09:01 <xplat> in america you blow up soviet russia, in soviet russia, soviet russia blows up YOU
13:09:03 <saml> what is a ?
13:09:08 <saml> could you give me example of a?
13:09:15 <copumpkin> why are you counting how many effects should have occurred, unless your action will take a long time?
13:09:16 <EvanR-work> saml: the unknown IO action which is irrelevant
13:09:18 <saml> you might want to approach this timed execution of a differently
13:09:28 <EvanR-work> copumpkin: for theoretical water proof?
13:09:33 <saml> i'm sensing it is verymuch relevant.
13:09:35 <EvanR-work> 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0  1 0 0 0 0
13:09:44 <copumpkin> EvanR-work: with forkIO it shouldn't be relevant unless you have a very high frequency
13:09:47 <saml> you abstracted out your problem.. and that abstraction became irrelevant
13:09:52 <xplat> copumpkin: in case somebody suspends the missile laptop
13:10:02 <copumpkin> saml: what are you sensing this from?
13:10:02 <EvanR-work> saml: when?
13:10:05 <cheater> i have a binary code on my hard drive
13:10:12 <saml> that's usually my experience...
13:10:15 <xplat> and you're behind by 40 rounds of icbm launches
13:10:20 <cheater> if you run it through the malbolge interpreter it prints a dick
13:10:30 <EvanR-work> right, you need to catch up if things bog down
13:10:35 <EvanR-work> which probably wont happen but you never know
13:11:07 <xplat> cheater: doesn't everything do that if you run it through the malbolge interpreter?
13:11:08 <EvanR-work> you dont want bog down to permanently shift your 'periodic test' by 9 minutes
13:11:46 <saml> i'm just saying that this sounds like XY Problem
13:11:46 <EvanR-work> copumpkin: i still dont understand why you are forkIOing
13:12:12 <saml> http://mywiki.wooledge.org/XyProblem
13:12:13 <copumpkin> EvanR-work: so you make the runtime of your action negligible from the runner thread's perspective
13:12:25 <EvanR-work> the action completes immediately
13:12:26 <copumpkin> saml: or he's just trying to design a useful library function
13:12:37 <copumpkin> EvanR-work: yeah, but I thought you wanted it water-tight :P
13:13:08 <EvanR-work> forkIOing will magically make it have zero delay?
13:13:15 <copumpkin> close to 0, yeah
13:13:18 <saml> and he wasn't clear about the behavoir of the library function
13:13:20 <EvanR-work> weird
13:13:25 <EvanR-work> this is not a library function
13:13:33 <copumpkin> EvanR-work: it'll just tell another thread to do it
13:13:41 <jessopher> this XY problem seems very topical for #haskell
13:14:39 <jessopher> or typical, or on topic, not like an ointment or anything
13:14:46 <EvanR-work> saml: so when you are presented with a question on a math test, you question the fundamental basis of all society and fail? ;)
13:15:21 <copumpkin> haskell programmers tend to write reusable library functions a lot more than people would in other languages
13:15:23 <saml> no.. i just wasn't sure what you want to do.. let me read the log
13:16:13 <saml> "question, how do make an IO action execute once per minute. not exactly on the minute is ok, but drift is not"
13:16:17 <EvanR-work> after waiting a very long time t, you want to ensure that n / t is almost exactly R
13:16:17 <saml> now it's clear
13:16:37 <saml> you have a timer that sends message every minute.  listener of the message forkIO
13:16:47 <EvanR-work> yeah how do you make that timer
13:17:02 <saml> haskell doesn't have timer or scheduler?
13:17:15 <cheater> that depends on what level of certainty you want
13:17:41 <EvanR-work> the best i can ask for is for it to happen correctly according to the computer clock, so im ignoring drift in the computer clock
13:18:04 <roconnor> saml: I don't get how rsync helps RikusW
13:18:08 <saml> maybe you have to poll for timestamp
13:18:22 <EvanR-work> thats a solution i proposed earlier
13:18:29 <EvanR-work> and ive used that before in C
13:18:35 <EvanR-work> sucks ;)
13:18:42 <saml> i wonder how cron is implemented
13:18:54 <EvanR-work> cron is a magic primitive!
13:19:07 <EvanR-work> actually cron is very sophisticated, read the paper ;)
13:19:08 <cheater> easiest: make a loop with a persistent variable called "t", then on first iteration make it execute your trigger and set t to the time it is at now. then, on each iteration, make it execute the trigger as many times as there have been whole seconds since the time t; before those executions are made, update the variable t to now.
13:19:15 <FUZxxl> saml: RTFSC (read the fine source code)
13:19:28 <EvanR-work> cheater: right
13:20:53 <saml> tick n msg listener = do { sleep n; send msg listener; tick;}
13:21:07 <EvanR-work> that will drift ;)
13:21:10 <saml> i don't know how to implement sleep,  send
13:21:13 <EvanR-work> were bouncing off the walls
13:21:15 <saml> no, send is immediate
13:21:30 <EvanR-work> sleep will not be exact on any multitasking OS
13:21:54 <saml> so complicated. that's why i asked why you want this.
13:22:09 <EvanR-work> to reproduce the behavior of cron
13:22:12 <saml> but having cron like library in haskell could be useful
13:22:46 <saml> can it only work on linux?
13:23:08 <EvanR-work> it used to work perfectly on dos, just loop exactly N cycles ;)
13:23:18 <EvanR-work> multiply by clock rate
13:24:25 <dmos> EvanR-work: clock @hackage
13:24:31 <dmos> http://hackage.haskell.org/package/clock
13:24:35 <EvanR-work> i saw that
13:25:05 <EvanR-work> if i want to check the time, i just use time
13:25:18 <EvanR-work> which is the only solution so far
13:27:10 <saml> http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#beat-entries
13:27:39 <gwern> a cron thing would be a good excuse to wank around with FRP
13:27:39 <EvanR-work> celery? really?
13:28:06 <saml> implement in haskell!
13:28:53 <EvanR-work> frp eh
13:29:37 <saml> http://hackage.haskell.org/package/bla
13:29:56 <EvanR-work> wth
13:35:21 <saml> http://hackage.haskell.org/packages/archive/uni-util/latest/doc/html/Util-Thread.html#v:every
13:35:46 * EvanR-work reads
13:35:52 <EvanR-work> every d c = forever (after d c)
13:35:55 <EvanR-work> after d c = do {delay d; c}
13:36:08 <saml> so,  c should pass message
13:36:08 <EvanR-work> delay d = threadDelay d
13:36:19 <saml> how do you pass messages between threads in haskell?
13:36:19 <EvanR-work> this is just drifting implementation
13:36:26 <EvanR-work> with MVars
13:36:32 * saml reads on MVars
13:38:44 <kmc> saml, with Chan
13:38:46 <xplat> EvanR-work: put your task in your cron table?
13:39:18 <kmc> saml, http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Control-Concurrent-Chan.html
13:39:36 <EvanR-work> xplat: yep
13:40:01 <EvanR-work> @can haskell do it
13:40:01 <lambdabot> Maybe you meant: faq map run wn
13:40:06 <EvanR-work> no
13:40:07 <EvanR-work> ;)
13:41:50 <EvanR-work> i guess a good interface would be, a thread which writes to a chan periodically
13:43:51 <xplat> 'X-Y problem' is a rather unmemorable name
13:43:59 <xplat> i suggest 'shaving the wrong yak'
13:44:09 <geheimdienst> captioning the wrong cat
13:44:35 <Nisstyre> is there a prelude function for doing trig functions in degrees?
13:44:51 <Nisstyre> scratch that I'll just look
13:44:57 <Nisstyre> I'm guessing there isn't though
13:45:06 <geheimdienst> ... but yeah, "xy problem" seems a little silly and generic
13:45:07 <kmc> yeah, its name is (* (pi / 180))
13:45:19 <Nisstyre> kmc: well yeah
13:45:37 <gwern> oops
13:45:49 <EvanR-work> a whole new lib for trig in degrees?
13:45:58 * gwern learns '@connect' does not do what he thinks it does. the right command must've been '@join'.
13:46:29 <donri> I take it @connect, disconnects?
13:46:56 <donri> maybe you need @part to join
13:47:38 <gwern> donri: I think the parameter to @connet gets interpreted either as one of the named configs including the network, or as the IRC network itself. obviously '#lesswrong' is neither
13:47:56 <KirinDave> So does haskell 7.2 build cleanly on osx now?
13:49:09 <kmc> ghc 7.2?
13:49:27 <KirinDave> 7.2.1 that is
13:49:35 <KirinDave> And does cabal-install head build cleanly as well?
13:49:46 <KirinDave> last time I tried to build-from-scratch 7.2.1 it failed hard for me.
13:49:55 <KirinDave> With all sorts of exciting linker errors.
13:57:16 <hpaste> saml pasted “cron” at http://hpaste.org/54732
13:57:41 <saml> haskell is so hard
13:57:46 <saml> good night
13:57:51 <saml> let me know of your solution
14:06:30 <deggis> uhh, what error is <<loop>>?
14:06:55 <shachaf> deggis: An infinite loop.
14:07:16 <hpc> deggis: more specifically, a /detectable/ infinite loop
14:07:18 <shachaf> deggis: In order to evaluate some thunk, you must first evaluate that thunk.
14:07:29 <hpc> which is a vanishingly small subset of real-world infinite loops
14:08:26 <shachaf> Not all infinite loops are of this form, but GHC can be friendly and tell you when it happens to find one.
14:08:32 <donri> Also, isn't "infinite loop" a little vague, in that many infinite loops are actually useful?
14:08:33 <shachaf> Don't rely on that behavior.
14:08:41 <blackdog> is it for compiled code only? I notice "let z=z; z"  just hangs?
14:08:51 <shachaf> donri: Not _|_s.
14:09:01 <donri> i don't know what that means
14:09:53 <hpc> donri: constructively infinite expressions are generally not considered "infinite loops"
14:09:58 <hpc> afaik
14:10:05 <kniu> why is the haskell platform so out of date?
14:10:29 <donri> so perhaps "infinite expression" is more accurate/specific?
14:10:37 <shachaf> donri: Not really.
14:10:57 <shachaf> _|_ is more accurate/specific. :-)
14:11:03 <donri> i don't know what that means
14:11:05 <shachaf> Denotationally, anyway.
14:11:16 <blackdog> hm. how do you actually get <<loop>> ? I can't get that behaviour
14:11:33 <hpc> donri: it's an ASCII picture of "bottom", which is basically haskell's undefined
14:11:35 <shachaf> blackdog: ghci doesn't do it.
14:11:41 <hpc> plus all the things that don't produce values ever
14:11:43 <shachaf> @wiki Bottom
14:12:05 <hpc> donri: bottom is distinct from expressions that are productive, but have no normal form
14:12:07 <shachaf> Cale; lambdabot;
14:12:09 <hpc> such as [1..]
14:12:17 <donri> sounds gay
14:12:18 <Waldteufel> donri: i would rather call the "useful kind of infinite loops" by another name, like "recursive monad composition" or something
14:12:19 <blackdog> shachaf: i can't provoke it in compiled code either.
14:12:23 <donri> personally i'm a top
14:12:25 <kmc> an infinite loop of evaluation is not useful.  an infinite loop of execution might be
14:12:46 <kmc> whether monads are involved is irrelevant
14:13:02 <donri> yea, that's the distinction i was after
14:13:03 <kmc> blackdog, write "main = main" and compile and run it with GHC
14:13:24 <shachaf> blackdog: Try -O2?
14:13:42 <shachaf> Doesn't happen for me without -O2.
14:13:48 <Sgeo> I want to make a Haskell library to help easily write code in another language
14:14:00 <Sgeo> Something like LSLScript (LSLExpr a)
14:14:01 <kmc> with ghc -threaded, there will be a slight delay before <<loop>>
14:14:25 <Sgeo> Where LSLExpr a is a string representing LSL code, and LSLScript is a monad to keep track of state such as variables
14:14:29 <shachaf> What's the delay?
14:14:47 <kmc> shachaf, garbage collection interval, i think.  entering a blackholed thunk doesn't kill the program with threaded rts
14:14:59 <Sgeo> Thing is, suppose I have two LSLExpr a's, and want to put a ; between them
14:15:00 <kmc> it puts the current thread onto a waitqueue
14:15:05 <blackdog> kmc: ah, there we go. i had main trying to print out a self-defined variable, and it doesn't catch it without -O2
14:15:06 <shachaf> That's reasonable.
14:15:14 <shachaf> How does it work at all with the threaded RTS?
14:15:18 <Sgeo> Should I just make up some operator for that, or is there a way to use the monad to make it easier?
14:15:31 <Sgeo> Or maybe I should forget about manual semicolons
14:15:52 <kmc> shachaf, the garbage collector can detect blackholes with no update frame, or something like that
14:15:56 <shachaf> Sgeo: You could use commas instead of semicolons or something.
14:16:10 <Sgeo> Hmm
14:16:26 <Waldteufel> don't you have to parse the string anyway? why not put the semicolon in there?
14:16:29 <kmc> similarly if you block on a MVar which is not reachable from elsewhere, the GC will find out and will kill your deadlocked thread
14:16:29 <deggis> shachaf, hpc: ok, thanks. there's some great bug just waiting to see the dayl.. night, any minute now
14:16:46 <Sgeo> Waldteufel, I'm not going to parse the string, just combine them
14:16:50 <kmc> (rather, send it an async exception)
14:16:59 <shachaf> kmc: Will it put the current thread on the waitqueue even if it's already on that queue?
14:17:51 <kmc> shachaf, how would that happen?
14:18:06 <kmc> if the thread is on the wq then it's not running
14:18:13 <shachaf> Oh. Right. Never mind.
14:19:02 <kmc> also, blackholes are not created immediately
14:19:09 <kmc> but only when the thread next invokes threadPaused()
14:19:52 <shachaf> So presumably there would be no runnable thread after the main thread goes onto the wait queue.
14:30:42 <shapr> yay Haskell!
14:30:50 <Axman6> \o/
14:30:57 <shapr> Axman6: Written anything nifty recently?
14:31:03 <Axman6> nope :(
14:31:22 <Axman6> i'm hoping to be able to work some haskell into this scholarship i'm doing, but it's not likely
14:31:50 <shapr> Ooh, tell me about your scholarship?
14:31:56 * hackagebot arx 0.0.3 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.0.3 (JasonDusek)
14:33:12 <Axman6> i'm at the CSIRO, Australia's leading research institution, and one of the world's top ranked too doing research into power usage of supercomputers
14:33:54 <shapr> CSIRO also did all the work for SMIL
14:34:07 <xplat> leisure suit larry script?
14:34:11 <Axman6> getting to play with a multimillion dollar GPU cluster hopefully =)
14:34:19 <Axman6> SMIL?
14:36:25 <shapr> Synchronized Multimedia something Language .. the precursor to HTML5 video
14:37:01 <Axman6> ah, interesting
14:37:53 <xplat> integration
14:39:26 <xplat> (is the I in SMIL)
14:40:18 <shapr> Lots of awesome stuff came out of CSIRO
14:40:24 <shapr> And several well known Haskellers
14:40:26 <Axman6> yeah, like wifi :P
14:40:53 <Axman6> yeah, kfish, who I worked with at Tsuru was at CSIRO
14:44:50 <mkscrg> haskell concurrency question: i'm looking for something akin to a unidirectional pipe between two threads. is this an established abstraction?
14:45:20 <hpc> mkscrg: as in, from one thread to the other, but not in the opposite direction?
14:45:23 <hpc> mkscrg: look at Chan
14:45:41 <mkscrg> hpc: yes, that. i'll check out Chan
14:45:52 <Saizan> a pipe is more like a bounded Chan though, which isn't in the stdlib but shouldn't be hard to make
14:45:54 <Axman6> it would be simple enough to make your own version using a Chan
14:46:45 <hpc> mkscrg: if you wanted it in both directions, i think i would suggest either an MVar, or two Chans
14:47:12 <Axman6> newPipe :: IO (In a, Out a), putPipe :: In a -> a -> IO (), getPipe :: Out a -> IO a amd In and Out are just simple newtypes
14:48:37 <mkscrg> hpc: yeah, i have an implementation using MVar [], but the writer thread blocks when the reader is reading/clearing the list. seems unncessary
14:48:48 <mkscrg> Axman6: where does that exist/
14:48:49 <mkscrg> ?
14:49:04 <Axman6> it doesn;t, i just made it. it's trivial to make though
14:51:47 <mkscrg> Axman6: i get that the types are simple, but how would you implement it? MVars have the problem i just mentioned to hpc
14:52:02 <Axman6> using a Chan
14:52:22 <mkscrg> ah, right. agreed
14:52:39 <Axman6> newPipe = newChan >>= \x -> return (In x, Out x);
14:52:45 <hpc> ^
14:52:54 <Axman6> the newtypes are kjust there to stop you writing to the read end
14:53:03 <hpc> internally it's the same chan though
14:53:28 <Axman6> (where you've prefiously defined newtype In a = In (Chan a) and newtype Out a = Out (Chan a)
14:53:37 <Axman6> previously*
14:53:56 <mkscrg> yeah, i follow
14:54:19 <mkscrg> are Chans the standard solution when MVars aren't general enough?
14:54:43 <Axman6> chans are the general solution when you need a concurrent channel :P
14:55:32 <Axman6> MVars are better used as a locking primitive really. if you need semi-asynchronous communication between threads, Chans are better
14:57:52 <Sgeo> What happens when you need a finite-duration concurrent channel?
14:58:05 <Axman6> finite-duration?
14:58:24 <Sgeo> As in, it should be possible to block, waiting for all the items to come in
14:59:06 <Axman6> well, a chan is endless, so there's no notion of "all". how would you know you've got all the items?
14:59:17 <Axman6> you could use a Chan of Maybe a too
15:00:00 <ft_> what am I supposed to do if I want my Iteratee to only return the input send by a Enumerator ?
15:00:29 <hpc> Axman6: or if you were being really silly, data Elem a b = (a, MVar b)
15:00:42 <hpc> Axman6: and use Mu (Elem Foo)
15:00:52 <Axman6> heh
15:01:04 <Axman6> that's not far off from the definition of chan right?
15:01:32 <hpc> Axman6: Chan is way different; i don't think you can get a queue out of that Mu type
15:01:36 <hpc> not easily at least
15:01:54 <Axman6> ah, well Chan just keeps track of the end i think
15:01:58 <rwbarton> that's basically a Chan, with a Chan you keep track of both ends
15:02:17 <hpc> rwbarton: orly? cool
15:02:22 <shachaf> hpc: Are you just using Mu instead of direct recursion for the novelty of it?
15:02:29 <hpc> shachaf: yes :P
15:02:32 <rwbarton> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Concurrent-Chan.html#Chan check those ~10 lines
15:02:48 <shachaf> Recursion is passé in #haskell.
15:02:51 <hpc> shachaf: and also so you can't get the second element until you have gotten the first
15:03:07 <shachaf> hpc: ?
15:03:23 <hpc> as opposed to something like MVar [a], or similar
15:03:38 <hpc> or.. im being dumb
15:03:51 <kmc> i've used IORef (Seq a) as a channel like that
15:03:52 <shachaf> I meant as opposed to data Elem b = Elem (Elem b) (MVar b)
15:03:59 <kmc> you can also use Chan (Maybe a)  with Nothing to signal the end
15:03:59 <hpc> yeah, i could have done data Elem a = Ele... that
15:04:10 <hpc> but im silly
15:06:58 * hackagebot biostockholm 0.1.0.1 - Reading and writing Stockholm files (multiple sequence alignment, used by Rfam and Infernal).  http://hackage.haskell.org/package/biostockholm-0.1.0.1 (FelipeLessa)
15:09:30 <Kaidelong> http://hackage.haskell.org/packages/archive/gloss/1.5.2.1/doc/html/Graphics-Gloss-Interface-Game.html
15:09:35 <Kaidelong> I don't like this type very much
15:09:45 <Kaidelong> wouldn't it make more sense to do something like
15:10:20 <Kaidelong> ... -> world -> (SomeTimeType -> world -> Picture) -> (Event -> world -> world)
15:11:20 <hpc> Kaidelong: perhaps put 'world' at the end, so you end up with an endomorphism, and all the wacky hijinks that enables
15:11:23 <Axman6> you can easily calculate that if you keep track of the elapsed time in your world
15:11:49 <hpc> ... -> that first thing -> the second thing -> (world -> world)
15:12:12 <Axman6> there's some of the type missing in his example
15:12:13 <Kaidelong> well hpc it does end in ... -> IO () but now that you mention it
15:12:45 <Axman6> :t Endo
15:13:06 <Axman6> lambdabot! where are you!
15:13:20 <ocharles> Kaidelong: heh, interesting, I'm just having a play with graphics in Haskell myself too, and that's almost exactly the same model as what I'm playing with :)
15:13:21 <hpc> preflex: seen lambdabot
15:13:21 <preflex>  lambdabot was last seen on #haskell 1 hour, 33 minutes and 22 seconds ago, saying: Maybe you meant: faq map run wn
15:13:28 <hpc> preflex: seen cale
15:13:28 <preflex>  cale was last seen on #haskell 19 hours, 15 minutes and 3 seconds ago, saying: oh, I see
15:14:26 <ocharles> before I head to bed, can anyone suggest a good starting point for reading about arrows?
15:14:43 <Kaidelong> look at the typeclass
15:14:44 <hpc> ocharles: start with Category first
15:15:21 <hpc> ocharles: it is simpler and once you get your head around what it does, Arrow should be more obvious
15:15:39 <ocharles> ok, that sounds good to me
15:17:04 <ocharles> Kaidelong: looking at the type class does not really help you gain intuition
15:17:13 <ocharles> not for me anyway
15:17:36 <ocharles> the typeclassopedia was great for that because it showed how all the various type classes played together. In fact, I'm sure arrows in there but I just skimmed it
15:17:38 <Kaidelong> ocharles: true. Well arrows are categories with extra stuff for working with pairs
15:17:47 <aavogt> does anybody know how you'd write code that looks like it's calculating a single value but in fact is calculating a series of values so that you can get what the distribution of those variables is?
15:17:57 <ocharles> Kaidelong: Arrows are more than that :)
15:17:58 <Kaidelong> and categories are things with id and .
15:18:08 <Kaidelong> oh and arrows provide an arrow constructor
15:18:15 <hpc> ocharles: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8 -- assumes you are un-newbish with Monad
15:18:15 <copumpkin> aavogt: U NEED MOANAD
15:18:16 <Kaidelong> that turns any a -> b into an arrow of a to b
15:18:18 <aavogt> you can kind of get this if you write code monadically
15:18:18 <hpc> ocharles: might help
15:18:19 <aavogt> yes
15:18:49 <copumpkin> or just applicative for most things
15:18:59 <aavogt> copumpkin: but is that really necessary? It doesn't matter to me what order the random seed gets passed around
15:19:08 <ocharles> hpc: I think I'm above newbish but below wizard with monads (can usually manage to combine them with transformers, have a reasonable understanding of how they work)
15:19:27 <copumpkin> aavogt: so applicative
15:19:36 <ocharles> hpc: this looks great, I think I'll go with this for bed time reading
15:19:36 <ocharles> thanks!
15:20:07 <aavogt> say if I could decide beforehand how many samples will be needed, the + - / etc can have the liftA2 etc already pre-applied
15:20:21 <aavogt> (or maybe the number of samples can be decided afterwards... )
15:21:13 <aavogt> copumpkin: would you know some way to thread the information backwards about which randoms have more effect on results?
15:21:24 <hpc> @remember copumpkin U NEED MOANAD
15:21:29 <hpc> D:
15:21:46 <aavogt> so then when sampling it could somehow emphasize those ones if the final variability is desired
15:22:10 <aavogt> or emphasize the variables which have less impact on the final result if I'm looking for the impact of specific random variables
15:22:14 <Waldteufel> hpc: MOAR MOANADS? ;)
15:22:30 <hpc> aavogt: try coding it as just craptons of functions; see how far you get until you get bored, then look for patterns
15:22:46 <sipa> i think we can move to calling "monad transformers" "MOARNADS"
15:22:49 <hpc> these things generally have a way of showing themselves
15:23:26 <aavogt> hpc: that's too much parameter passing
15:23:44 * aavogt will drown in function arguments
15:24:05 <sipa> use a reader monad to pass them around
15:24:22 <hpc> sipa: and so it starts... :P
15:25:31 <aavogt> sipa: they are all different
15:26:06 <aavogt> and if I use   Reader (Map RandomVariable Double), there's no compile-time checking
15:26:28 <sipa> use a record type?
15:26:31 <aavogt> and if I use  Reader containing a HList...
15:26:34 <sipa> as state
15:27:02 <aavogt> actually the problem is that I'd like to be able to specify things like:
15:27:20 <xil> is there a way to divide Ints without having to go through explicit conversions?
15:27:27 <sipa> div?
15:27:28 <aavogt> r = 8.314 ± 0.0005
15:27:33 <hpc> :t div
15:27:40 <Axman6> > div 123 45 :: Int
15:27:42 <hpc> D: -- it is div you want
15:27:45 <Axman6> lambdabot!
15:27:58 <Axman6> div :: Integral a => a -> a -> a
15:28:02 <xil> aha, thank you
15:28:08 <xil> do you know where it's defined? Prelude?
15:28:13 <Axman6> yes
15:28:13 <xil> I noticed lambdabot is out
15:28:42 <xil> why didn't they just define the instance Fractional Int?
15:28:54 <aavogt> then from there be able to get the results of say    (r - r) being exactly 0 since all the samples are 0
15:29:01 <Axman6> because Ints aren't fractional
15:29:06 <Axman6> they have no fractional part
15:29:51 <aavogt> you get odd things like (1 `div` 3) * (3 `div` 1) == 0
15:30:09 <aavogt> which are probably just as confusing if div was called /
15:30:26 <xil> oh right, you need certain rules to apply for Fractional to be usable
15:30:48 <aavogt> the rules are whatever somebody said
15:31:07 <xil> right, it's just an agreement
15:31:18 <xil> but we like them how they are and they don't apply to Integrals
15:31:23 <hpc> the numeric classes have very wibbly-wobbly laws
15:31:34 <aavogt> you can define instance Fractional Int
15:31:59 <xil> div is fine for what I need
15:32:15 <xil> okay back to coding. Thanks for the info =]
15:32:43 <ddarius> quot may be better, performance-wise.
15:33:36 <xil> ddarius: quot might be more what I need in fact
15:33:45 <xil> still working on the math for this thing
15:34:32 <ddarius> It's unlikely that quot is what you want from a semantics perspective.  It just might not a difference in your semantics.
15:35:46 <xil> it is unlikely, yeah, but I'm doing some stuff with polar coordinates and I wouldn't be surprised if I need truncation toward zero rather than negative infinity
15:36:14 <shachaf> It might well not a difference. But what if it a difference? It's probably best to think about exactly the difference it.
15:37:04 <xil> well I need to work out the precise math for this. Still working on what I'm calculating. Once I know I'll be able to see whether I care which way it truncates
15:37:29 <ddarius> shachaf: There are conservative checks that can guarantee that it won't, such as you are only using positive numbers.
15:56:13 <DukeDave> Is the a convenient way to export a record's functions but not constructors?
15:56:23 <DukeDave> *Is there a
16:03:27 <hpc> DukeDave: not really
16:03:34 <hpc> not that i know of, at least
16:03:56 * ddarius sees if GHC 7.2.2 solves his woes.
16:05:00 * DukeDave was hoping for something like 'hiding' on an export list
16:05:38 <HugoDaniel> i was hoping for a 64bit windows version
16:06:13 <HugoDaniel> until then, im stuck with java for certain tasks
16:09:41 <Eduard_Munteanu> HugoDaniel: mind 32bit apps should run fine on 64bit Windows.
16:10:05 <hpc> a 32-bit GHC could probably compile 64-bit programs
16:10:20 <hpc> at least, it isn't impossible
16:10:27 <Eduard_Munteanu> Hm, oh.
16:10:53 <Eduard_Munteanu> Maybe, I was going to say 64-bit GHC can't compile 32-bit apps.
16:11:27 <Eduard_Munteanu> Basically this is cross-compiling in some form or another.
16:12:16 <HugoDaniel> i cant get hdbc to work with odbc in 64bit windows :/
16:13:53 <hpc> HugoDaniel: trying to use mysql or oracle?
16:14:52 <hpc> (i probably can't help, just getting boilerplate questions out of the way)
16:17:47 <roconnor> @type (|||)
16:17:48 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
16:17:57 <roconnor> what's the name of (|||) ?
16:18:11 <hpc> roconnor: either
16:18:14 <hpc> :t either
16:18:16 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:18:25 <roconnor> ah
16:18:31 <hpc> at least, is what i would call it
16:21:41 <roconnor> wk
16:21:44 <roconnor> works for me
16:27:00 <periodic> I just learned that all my bang patterns weren't doing as much good as I'd hoped because I wasn't unpacking...
16:27:16 <kmc> yeah, they only force to weak head-normal form
16:27:22 <kmc> i like RWH's example here
16:27:22 <periodic> Right, which does help sometimes.
16:27:35 <periodic> particularly with memory from built-up thunks.
16:30:21 <HugoDaniel> hpc: i need localhost access to a sqlserver 2008r2
16:41:21 <dmwit> So, what's the standard workaround for bringing type variables into scope (with ScopedTypeVariables on) in instance declarations?
16:41:53 <dmwit> I wanted to write, e.g., instance Functor Foo where fmap :: forall a b. (a -> b) -> Foo a -> Foo b, but that's not good syntax, apparently.
16:42:00 * hackagebot barrier-monad 0.1 - Implementation of barrier monad, can use custom front/back type  http://hackage.haskell.org/package/barrier-monad-0.1 (AaronBlack)
16:42:01 * hackagebot barrier-monad 0.1.0.1 - Implementation of barrier monad, can use custom front/back type  http://hackage.haskell.org/package/barrier-monad-0.1.0.1 (AaronBlack)
16:42:32 <Axman6> are type sigs allowed in instance declarations?
16:42:37 <dmwit> No.
16:43:12 <hpc> someone else was having trouble with that a few days ago
16:43:22 * Eduard_Munteanu wonders about  fmap = \x f -> ... :: ...
16:43:33 <kmc> dmwit, write a fmapFoo function with the correct type, and then «instance Functor Foo where fmap = fmapFoo»
16:43:41 <dmwit> ah, cute
16:43:46 <kmc> but i think there are other ways
16:44:00 <kmc> instance Functor Foo where { fmap (f :: a -> b) x = ... }
16:44:24 <hpc> fmap = fmap' where fmap' :: ...
16:45:01 <dmwit> fmap (f :: a -> b) x = ... looks pretty good for this case, though it's not as obvious how to generalize that for other cases.
16:45:11 <dmwit> Just put a type signature on each binding, I guess.
16:45:38 <dmwit> Okay, thanks for the suggestions.
16:56:30 <Veinor> are there any libraries for dealing with units that aren't known at compile time?
16:56:53 <Veinor> dimensional is compile-checked, which seems like it'd make making a calculator hard if not impossible
16:57:31 <shapr> Veinor: template haskell?
16:58:02 <Veinor> shapr: the program i'm trying to write is a unit-aware calculator
16:58:12 <Veinor> something like wolfram alpha, only better
16:58:41 <Eelis> lol
16:59:22 <Veinor> (where by 'better' i mean 'you can have state)
16:59:28 <shapr> Veinor: Just saying that Template Haskell would let you get compile time at runtime.
17:00:36 <Veinor> meaning?
17:00:56 <Veinor> i'm not sure i follow how, i guess
17:01:38 <shapr> Veinor: I haven't used dimensional, but if it is compile-time only, you can get compile-time at runtime by using Template Haskell.
17:03:19 <Veinor> hmm
17:03:36 <aavogt> Veinor: dimensional can work in ghci
17:03:48 <wyfrn> is there a reason why String has no Typeable instance?
17:04:09 <aavogt> > typeOf "hi"
17:04:10 <lambdabot>   [Char]
17:04:27 <kmc> technically it is [] and Char which have Typeable instances
17:05:35 <wyfrn> i just read http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html ... and there is no instance for Lists also
17:05:46 <aavogt> there's a Typeable1 or something like that
17:06:05 <Peaker> kind-polymorphism...
17:06:09 <wyfrn> oh ... sure ... wrong kind
17:06:10 <Peaker> Could resolve that silliness :)
17:06:32 <aavogt> the reason for those extra classes is because flexible instances (I think) is not an extension they want to use
17:06:58 <aavogt> or maybe there's some other reason there's no instance Typeable a => Typeable [a]
17:07:32 <Peaker> aavogt: I think it's because a class's type variable has a monomorphic kind
17:07:36 <Veinor> aavogt: true
17:07:49 <Peaker> or can a class type variable/instance be a polymorphic kind?
17:07:55 <Veinor> basically, i'm trying to figure out how to implement 'readDimensional'
17:07:57 <hpc> Peaker: sure
17:08:08 <hpc> instance Monad ((->) e) where ...
17:08:19 <aavogt> Peaker: that doesn't stop    instance Typeable a => Typeable [a]
17:09:09 <Peaker> hpc: that's a monomorphic kind (*->*)
17:09:28 <hpc> oh, missed "kind"
17:09:41 <aavogt> in the end people apply functions to things that have kind *
17:10:31 <Veinor> because a dimensional value has type Unit d a
17:10:39 <Peaker> in the end, transistors emit charge particles from one end to the other :)
17:10:42 <aavogt> Veinor: oh that's not going to work
17:10:44 <shachaf> What if these are actually Miranda-style asterisks?
17:10:45 <shachaf> Const :: * -> ** -> *
17:10:52 <Veinor> aavogt: yeah
17:11:09 <Veinor> dimensional would be useful for a program that works with units internally, but it doesn't work here
17:11:24 <parcs_> kind polymorphism solves the TypeableX problem but creates another problem
17:13:10 <aavogt> this still doesn't address why you'd want   instance Typeable1 [], when you can just write instance Typeable a => Typeable [a]
17:13:52 <Peaker> parcs_: what other problem?
17:14:18 <parcs_> typeOf becomes :: Proxy a -> TypeRep instead of :: a -> TypeRep.. now you can't directly use typeOf on a value whose TypeRep you'd want known
17:14:23 <Veinor> i could use caldims, but i can't figure out how
17:14:41 <Veinor> looks like i have an excuse to write my own unit library!
17:15:01 <parcs_> so you have to create helper functions of type 'a -> Proxy a', 'f a -> Proxy f', etc.. which is exactly what the current TypeableX classes do
17:15:03 <aavogt> Veinor: you could hide the types in dimensional with -XExistentialQuantification or -XRank2Types
17:15:07 <wyfrn> does anybody know if John Goerzen is sometimes around in #haskell ?
17:15:15 <shapr> wyfrn: Yes, he is here now I think.
17:15:18 <Axman6> aavogt: isn't that what Typeable1 is for?
17:15:34 <wyfrn> shapr: do you know his nick?
17:15:51 <shapr> wyfrn: He usually goes by CosmicRay, but he appears to be away, see CosmicRa`
17:16:02 * Axman6 may have missed the point of the conversation
17:16:05 <wyfrn> shapr: tahnk you
17:16:08 * aavogt too
17:16:13 <shapr> wyfrn: Do you have a specific question?
17:17:28 <aavogt> Axman6: it doesn't seem to be like monad transformers where auto-lifting (like all those:  instance MonadState s m => MonadState s (ReaderT r m))  means you need tons of instances
17:18:49 <Veinor> aavogt: so... something like data Unital a = Unit d a
17:19:16 <wyfrn> shapr: i just wonder if his HSH project is dead ... actually i try to make some improvements and maybe this will pose some questions
17:20:10 <shapr> wyfrn: https://github.com/jgoerzen/hsh
17:20:54 <shapr> wyfrn: Looks like it's somewhat active. If you have a github account you can fork the most recent source, make your own changes and make a pull request.
17:21:36 <aavogt> Veinor: yes. But I'm not sure if things get simplified sensibly done like that
17:22:07 <Veinor> hmm.
17:22:07 <Peaker> I hate the transformers' auto-lifters...
17:22:39 <wyfrn> shapr: ahh didn't know about the github project ... i just knew the sources on hackage
17:22:39 <aavogt> Veinor: in any case, errors you get with dimensional are terrible
17:22:44 <Peaker> I think the underlying assumption that the capability of the monad is all that's needed to address it is all wrong.. Who says I have just one Writer in my stack?
17:22:46 <Veinor> yeah.
17:22:53 <shapr> wyfrn: I'm glad I can help!
17:22:58 <Veinor> the thing this is ultimately going to be is a web thing
17:23:16 <Veinor> so you go to unitary.com or whatever and you get a prompt
17:23:28 <aavogt> so even if you manage to get it done at runtime (say re-interpreting some file the user inputs line-by-line)
17:23:32 <Veinor> type in '5 meters * 2 second / 3', it does AJAX, you get back '3.33333 m/s'
17:25:26 <aavogt> if you try to have it do say:   '5 metres / 2 second + 2 second'
17:25:35 <aavogt> that will be a very long error message using dimensional
17:26:20 <hpc> aavogt: wtf, how does it parse?
17:26:38 <hpc> the second example i can understand if operator precedence takes effect
17:26:44 <hpc> but the first is just downright bamboozling
17:26:49 <Veinor> hpc: ?
17:27:02 <aavogt> hpc: (5m / 2s) + 2 s
17:27:11 <aavogt> which is messing up units
17:27:29 <Veinor> basically, dimensional is only useful as a guard against fucking up during programming
17:27:32 <Veinor> it seems like
17:27:41 <aavogt> one thing I notice about using dimensions that are checked is that you have to re-write things sometimes, ex http://en.wikipedia.org/wiki/Levich_equation
17:27:53 <hpc> aavogt: so the units bind more loosely than all the operators
17:27:55 <hpc> fun
17:28:10 <aavogt> more tightly
17:28:19 <hpc> aavogt: ah, that space there threw me
17:28:25 <hpc> aavogt: mostly i was asking about the first one
17:28:35 <hpc> 5m*2s/4
17:28:57 <aavogt> so often people write out dimensionless groups to some power as the components of that group to some power
17:29:01 <Veinor> (in dimensional, it's 5 *~ meter / 2 *~ second + 2 *~ second)
17:29:35 <aavogt> and dimensional doesn't handle fractional powers (though the cgs module apparently does, but that adds a class which will make the error messages even worse)
17:29:49 <Veinor> yeah
17:30:56 <Veinor> the basic design that i'm going to do is that a unit represents exponents of time, length, mass, current, temperature, luminosity, and amount of substance
17:31:14 <Veinor> so a coulomb is a current*second, and a farad is... whatever
17:54:42 <Gabriel_> hello can someone solve this entire problem set for me, thanks in advance: http://www.cs.bu.edu/faculty/kfoury/UNI-Teaching/CS320-Fall11/Homework/HW07.problems.pdf
17:55:10 <Axman6> sure, we'll get right on that!
17:55:16 <Gabriel_> thanks bro
17:55:56 <irene-knapp> haha
17:56:05 <Axman6> Have you paid your monthly subscription to #haskell?
17:56:15 <Gabriel_> oh shi---
17:56:22 <luite> do we need to solve the extra credit problems?
17:56:24 <Gabriel_> nah
17:56:33 <irene-knapp> hey, by the way, my monthly check from #haskell was late this month, was there a problem or something?
17:56:52 <Gabriel_> where do i mail this check
17:56:53 <geheimdienst> Gabriel_: you probably won't find anybody to do your homework for you. however, if you made a credible effort and are really stuck, feel free to ask specific questions in here (include the code you have so far)
17:56:58 <KirinDave> Gabriel_: extra points for having us also do the previous assignment.
17:57:09 <Gabriel_> ^ LOL
17:57:16 <Gabriel_> i hate cs.bu
17:57:28 <Axman6> I'm pretty sure this set of problems is almost exactly what I had to do for an assignment this semester
17:57:32 <KirinDave> Gabriel_: It says it assumes we have assignment 6 done.
17:57:40 <KirinDave> I got that
17:57:42 <tromp> hey, i have some good friends at cs.bu
17:57:46 <KirinDave> Oh wait that one assumes assignment 5.
17:57:47 <shapr> Yah, me too!
17:57:48 <KirinDave> trololo
17:57:52 <KirinDave> "Please take my final"
17:57:56 <tromp> hi, Shae!
17:57:57 <Gabriel_> oh i'm sure ur friends are cool tromp
17:58:00 <irene-knapp> it's actually a good problem set haha
17:58:04 <irene-knapp> I'm glad there's a uni teaching this material
17:58:12 <Axman6> where is bu?
17:58:12 <Gabriel_> it's a good problem set? news to me
17:58:24 <Gabriel_> too bad i don't know haskell
17:58:33 <Axman6> maybe you should have learnt it
17:58:43 <tromp> where is boston?
17:58:43 <Axman6> it's not that difficult
17:58:58 <shapr> Boston University, I know several people there.
17:58:58 <Axman6> tromp: i didn't know what bu stood for
18:00:34 <tromp> what's more fun than implementing lambda calculus interpreters?
18:00:42 <tromp> i'm jealous:)
18:00:43 <Axman6> yeah man
18:00:59 <Axman6> we had to implement a lambda calculus to SK conversion tool
18:01:05 <Gabriel_> haha
18:01:48 <shapr> Gabriel_: Haskell is pretty nifty, have you tried reading the Real World Haskell book? It's free online!
18:02:18 <Gabriel_> oh i appreciate the niftyness of haskell, i just wish it was taught better here
18:02:22 <Axman6> there's learnyouahaskell.com which has also been made into a book, and it's free online
18:02:33 <tromp> who's teaching it?
18:02:52 <Gabriel_> um prof kfoury
18:02:55 <shapr> Looks like kfoury
18:03:04 <Gabriel_> GET OUT OF MY HEAD
18:03:10 <Axman6> Gabriel_: how about instead of a) complaining about the teaching and b) attempting top get others involved in your academic dishonesty, you put in the effort learning something by yourself?
18:03:19 <shapr> Gabriel_: Your head needs more Haskell :-P
18:03:58 <shapr> I'm trying to remember where I went drinking with my BU friends around there... somewhere down the Green line.
18:04:20 <tromp> i recently wrote a lambda calculus interpreter in perl
18:05:13 <irene-knapp> I recently wrote half of a pure subset of PHP, to make PHP more bearable, haha
18:05:15 <tromp> it was fun watching it interpret a bainfuck interpreter in lambda calculus, struggling to print hello world
18:05:23 <irene-knapp> but I was told not to use it because of the performance overhead.  oh well! :D
18:05:45 <shapr> Gabriel_: Do you have any specific questions about Haskell?
18:06:17 <shapr> Gabriel_: C'mon, you have TWO DAYS to do this!
18:06:42 <Gabriel_> so for srs, i'm on 1b where i modify the evaluate function, and I'm supposed to have it evaluate lambda things
18:07:03 <irene-knapp> heh, lambda "things"
18:07:15 <Axman6> do you know anything about lambda calculus?
18:07:32 <Gabriel_> and it's constructed like ev1 :: [(String, Val)] -> Exp -> Error Val
18:07:48 <Axman6> what's Error Val defined as?
18:08:34 <shapr> Gabriel_: What do you think needs to happen?
18:08:37 <Gabriel_> just S (something) ;              data Error a = S a
18:09:15 <Gabriel_> well i think it's supposed to return the final value
18:09:27 <shapr> So, how would you start doing that?
18:10:45 <nexion> if I had a loop that listened on a tchan for commands/queries, some of which required a response (such as a lookup), would creating a use-once tchan for the response be efficient, or is there a better way to collect responses?
18:12:50 <irene-knapp> nexion: I'm not clear on what your control structure is exactly.  How are you planning to let the listener thread know where to write to?  I guess you mean have the command thread create a tchan just for that request and include it in the request structure?
18:13:22 <nexion> correct
18:13:26 <monochrom> mvar can do one-off responses, too.
18:13:37 <nexion> or mvar, yeah
18:13:46 <nexion> is this a good model or am I on the wrong track?
18:14:13 <monochrom> I think it's nice
18:15:17 <irene-knapp> it seems fine to me
18:15:33 <irene-knapp> if it turns out that a tchan is hugely expensive to create, you might have to rethink it
18:15:43 <irene-knapp> but I wouldn't assume that in the absence of measurements showing it
18:16:02 <monochrom> data Command = DontAnswer { job :: IO () } | AnswerMe { param :: String, putyouranswerhere :: MVar String }
18:16:29 * Eduard_Munteanu thinks it'd be fun if merijn turned out to be teaching at cs.bu, that student in particular.
18:16:41 <irene-knapp> my intuition would be that an MVar is more expensive because it needs a mutex instead of just a read-write lock, but I dunno
18:17:32 <monochrom> the commander does: do { v <- newEmptyMVar; writeChan c AnswerMe{param="now!", putyouranswerhere=v}; x <- takeMVar v ... }
18:17:39 <Gabriel_> lol that would be fun
18:17:47 <nexion> what would you guys do? I basically need a map (key-value) that can do lookups and modifications
18:17:49 <Eduard_Munteanu> It wouldn't be that unlikely to meet teachers in here.
18:17:59 <nexion> and let's suppose performance is highly important
18:18:06 <nexion> but not the point where I'd want to shard it
18:18:48 <nexion> and this map would need to be accessed from many places
18:18:52 <irene-knapp> nexion: it really depends on the access pattern... I mean you could put the whole map in an MVar
18:19:11 <monochrom> I use one MVar or even one IORef to point to the map.
18:19:21 <nexion> I'm making a multi-threaded ircd as my first haskell project, to learn the language
18:19:33 <irene-knapp> that's cool.
18:19:41 <nexion> so this map would allow looking up users by their nickname
18:19:49 <irene-knapp> I assume you have written multithreaded network applications in other languages?
18:19:50 <nexion> and getting that user's tchan to interact with them
18:19:51 <ddarius> I guess that's better than another IRC bot.
18:19:59 <monochrom> hahaha
18:19:59 <nexion> yeah, I've done quite a bit o that
18:20:02 <irene-knapp> good :)
18:20:03 <nexion> of*
18:20:21 <irene-knapp> hmm
18:20:31 <irene-knapp> why is it one tchan per user exactly?
18:21:05 <irene-knapp> I would make the per-user structure be an mvar with the socket in it, I think
18:21:07 <Gabriel_> problem is i'm not sure what [(String, Val)] is... meh it's hard to ask since there's a lot of definitions involved
18:21:08 <nexion> for the user's tchan, I've got the following messages: DataReceived line, SendLineToClient line, Disconnect (so far)
18:21:17 <nexion> so there are 2 loops for every user
18:21:23 <nexion> one listens on the socket, the other listens on the tchan
18:21:30 <nexion> the socket loop sends messages to the tchan
18:21:42 <nexion> but anything in the app that has the user's tchan will be able to write messages to the user
18:21:44 <irene-knapp> yeah, okay, hmm.  well you clearly need the one that listens on the socket,
18:22:05 <irene-knapp> but I'm not totally sure what the tchan one is for.  forkIO is cheap - just spawn a new thread for each send.
18:22:14 <u_> monochrom: me too
18:22:38 <irene-knapp> (the new thread needs to take the user's mvar of course, so that no other thread can be writing at the same time)
18:22:50 <nexion> the user's chan loop would also keep some of the user's state
18:22:58 <Axman6> Gabriel_: it's likely to be a lookup table. when you encounter a variable, you look to see if there's a definition in the list for that variable in the table, and if there is, you can replace the variable with what it is defined as
18:23:03 <u_> wait
18:23:05 <u_> nevermind
18:23:11 <u_> wrong window confusion again..
18:23:20 <monochrom> heh
18:24:09 <geheimdienst> Gabriel_: [(String, Val)] is a list of tuples, each tuple containing one String and one Val (whatever that is). [] stands for list, () stands for tuple
18:25:03 <geheimdienst> > [("lol", 42), ("cat", 37), ("abc", 10)] -- example value that has type [(String, Int)]
18:25:04 <lambdabot>   [("lol",42),("cat",37),("abc",10)]
18:26:38 <Gabriel_> ohhhh ok that makes more sense
18:27:16 <nexion> irene-knapp, I've posted the code at http://hpaste.org/54736 -- it should make it clear how my two loops work
18:27:42 <nexion> though I should probably do forkIO for sends
18:28:10 <irene-knapp> looking, although I think your explanation was clear
18:28:11 <Gabriel_> so the second argument Exp is like data Exp = Lam String Exp
18:28:21 <Axman6> Gabriel_: so, i'd assume, that when you get (App (Lam str x) y), you'd then evaluate y, then evaluate x, but make sure that str maps to the evlauated y when you evaluate x
18:28:30 <nexion> and I think I see what you mean about the mvar
18:28:44 <nexion> this is to avoid multiple writers on the same socket at once, right?
18:29:02 <irene-knapp> right
18:29:04 <irene-knapp> okay, so
18:29:18 <irene-knapp> I don't understand why you're putting reads and writes both in clientChanLoop
18:29:36 <irene-knapp> they can happen simultaneously without anything going wrong, so you should allow them to
18:30:02 <Axman6> you _might_ want to serialise writes, but reads shouldn't be a problem right?
18:30:17 <irene-knapp> oh you do want to serialize writes
18:30:34 <irene-knapp> and reads have to be in their own thread anyway because that's the Haskell way to do input from multiple sources
18:30:44 <Gabriel_> how does "case ... of" syntax work ?
18:30:58 <Axman6> Gabriel_: it's for pattern matching:
18:31:18 <irene-knapp> so reads are already serialized by the nature of the fact that there's only one thread that ever reads any given client socket, and no additional effort is necessary
18:31:19 <Axman6> > case of Just 7 of Just x -> show x; Nothing -> "Oh no :("
18:31:21 <lambdabot>   <no location info>: parse error on input `of'
18:31:23 <mauke> Gabriel_: case EXPR of { PATTERN1 -> EXPR1 ; PATTERN2 -> EXPR2 ; ... }
18:31:29 <Axman6> > case Just 7 of Just x -> show x; Nothing -> "Oh no :("
18:31:30 <lambdabot>   "7"
18:31:40 <Axman6> > case Nothing of Just x -> show x; Nothing -> "Oh no :("
18:31:41 <lambdabot>   "Oh no :("
18:32:03 <Axman6> Gabriel_: do you understand how pattern matching works in function definitions?
18:32:08 <nexion> one thread for reads, the other for processing events on the chan (currently)
18:32:13 <nexion> would you recommend a dedicated one for writes?
18:32:49 <irene-knapp> somebody should explain the { ... ; ... ; ... } notation and that it's just an alternative for the separate-lines-and-indentation syntax
18:33:00 <irene-knapp> really, we should have a way to make the bot spit out that explanation
18:33:04 <donri> > let it = "be" in case _ of "emergency" -> "run for yer lives"
18:33:04 <lambdabot>   Pattern syntax in expression context: _
18:33:08 <irene-knapp> nexion: well there are multiple valid ways to do this,
18:33:49 <nexion> I see the value in a dedicated write thread
18:33:59 <irene-knapp> but I personally would have each client have just one persistent thread, doing reads in a loop.  (you really don't need to check for more data until you've processed the message, because clients send relatively slowly, and the buffer will never get big)
18:34:16 <irene-knapp> so the thread that reads the line would also be the thread that processes it
18:34:17 <nexion> not having to synchronize writes with mvar is a plus, since tchan takes care of it
18:34:35 <irene-knapp> well, I mean, the synchronization is happening /anyway/ :)
18:34:44 <Axman6> nexion: what are you actually trying to do?
18:35:00 <irene-knapp> MVar and TChan both have potential contention and therefore potentially significant delays
18:35:17 <Gabriel_> ok my friend figured it out, i'm just supposed add the new string,val to the lookup table
18:35:36 <irene-knapp> it's just a question of which leads to the more convenient control structure
18:36:24 <nexion> Axman6, I'm trying to decide how to best structure the code for reading from/writing to a client's socket and be able to handle other events sent from other parts of the app
18:36:49 <nexion> in a way that performs best and is most logical
18:37:07 <irene-knapp> Axman6: if you missed it, he's writing an IRC server
18:37:17 <nexion> for fun/to learn haskell
18:38:30 <nexion> if I have a single loop for each client, it'd need to block until one of two events happen: incoming event from somewhere in the app & hGetLine return
18:38:33 <VHD> hi there, in a scenario such as "take 1 (function x y)" lets say (function x y) returns a list (not a stream). How would GHC do this? Would it fully evaluate (function x y) or would it bt lazy and treat it like a stream?
18:38:51 <VHD> be*
18:38:59 <Axman6> VHD: what's special about a stream?
18:39:04 <nexion> and I'd also need to synchronize writes
18:39:12 <irene-knapp> nexion: no, no, see!  the single loop doesn't need to care that incoming events from somewhere else in the app are happening!
18:39:19 <Axman6> why do you need to synchronise writes nexion?
18:39:20 <irene-knapp> nexion: the "somewhere else" can handle those itself!
18:39:21 <VHD> Axman6, nothing that I know of, which makes me think it does it lazy style.
18:39:31 <irene-knapp> nexion: the single loop ONLY does hGetLine
18:39:32 <VHD> but just wanted to make sure.
18:39:32 <Eduard_Munteanu> "stream" also means infinite list
18:39:46 <nexion> oh I see
18:39:49 <Axman6> VHD: well, lists arer lazy in haskell. as soon as a sinple result is available, then take 1 will return immediately
18:39:53 <Eduard_Munteanu> But it's not really the case here.
18:40:03 <Axman6> > take 1 [1..]
18:40:04 <lambdabot>   [1]
18:40:07 <Axman6> > [1..]
18:40:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:40:55 <VHD> ok
18:40:58 <Eduard_Munteanu> VHD: it only evaluates as needed
18:41:16 <VHD> so I need not worry about wasted cycles if I use take
18:41:22 <Axman6> not at all
18:41:31 <VHD> sweet
18:41:46 <Axman6> laziness means that only as much work that needs to be done to get the answer will ever be computed
18:42:45 <Eduard_Munteanu> Perhaps except going through a few layers of indirections, the thunks.
18:43:20 <mkscrg> question on tail call optimization: i get the basic idea that a function will be TCO'd if its result is the result of a call to itself. so then this function will not be TCO'd, right:   go ch xs = maybeReadChan ch >>= maybe (return xs) (go ch . (:xs))
18:43:45 <mkscrg> go :: Chan a -> [a]
18:43:45 <Axman6> mkscrg: no
18:43:57 <Axman6> also, that typ[e is wrong
18:44:02 <Axman6> type*
18:44:05 <mkscrg> oops
18:44:06 <mkscrg> type
18:44:39 <mkscrg> Chan a -> [a] -> m [a]
18:44:42 <mkscrg> *typo
18:44:50 <Axman6> I think you can probably make it tail recursive without too much effort
18:45:49 <nexion> Axman6, getting back to your question about synchronizing writes -- what happens if two threads do hPutStrLn on the same handle at the same time (for a network socket)?
18:46:24 <Axman6> nexion: depends on a lot of things. why do you need to have more than one thread writing to a single socket in an IRC server?
18:47:06 <nexion> if I was to use a model where I forkIO for every write, that'd be the case
18:47:34 <Axman6> eh?
18:47:40 <Axman6> your architecture seems quite odd
18:47:50 <nexion> it came up in the discussion
18:47:50 <jmcarthur> with laziness tail recursion is a little more subtle
18:47:57 <nexion> it's not what I'm actually doing
18:48:21 <nexion> I'll just do separate threads for read and write for now
18:48:58 <Axman6> the way i'd design it is: have a Chan that you use dupChan for each client that connects. You have two threads for each client, one to read messages form the client and write to the chared Chan, and one to write the messages it's recieved from the shared Chan
18:50:08 <nexion> so every line received from the user gets sent to the shared chan with a user identifier
18:50:18 <nexion> and is processed in a common place
18:51:16 <Axman6> well, each writing thread then just reads the value, anbd writes it to its own client
18:53:09 <hpaste> Axman6 pasted “tail recursive thing for mkscrg” at http://hpaste.org/54737
19:11:32 <VHD> silly question, but ++ will always evaluate the left argument first? so take 1 1:3:4:]
19:11:46 <VHD> woops that isnt all the question
19:12:25 <dmwit> No, but (++) will always evaluate the entire spine of the left argument before it starts touching the right argument.
19:12:27 <VHD> so take 1 1:3:4:[] should be same as take 1 1:[] ++ 2:3:4:[]
19:12:46 <VHD> in terms of cost
19:12:46 <monochrom> yes
19:12:49 <dmwit> Yes, if you parenthesize that abit more.
19:13:08 <dmwit> take 1 (1:3:4:[]) = take 1 (1:[] ++ (2:3:4:[]))
19:13:10 <monochrom> twice the cost actually, but marred by asymptotics
19:13:20 <dmwit> > 1:[] ++ 2:3:4:[] -- ?
19:13:21 <lambdabot>   [1,2,3,4]
19:13:24 <dmwit> okay
19:13:42 <VHD> monochrom, twice the cost?
19:14:00 <VHD> because it will build 1:[] then go through it again with ++?
19:14:14 <monochrom> some extra work of expanding the definition of (++)
19:14:43 <VHD> I see.
19:15:26 <dmwit> The cost is pretty negligible unless you're doing it in a loop.
19:15:40 <VHD> ok then I should be fine
19:16:37 <monochrom> a step of (x:blah)++y -> x:(blah++y) before further processing by take or head
19:17:04 <monochrom> whereas 1:[] is already ready for take or head
19:18:52 <mike-burns> Given the choice of (:) or (++), go with (:) .
19:26:13 <nexion> how can I create an empty map inside a do and assign it a name? I've imported Data.Map qualified as Map
19:26:24 <nexion> nickToClientChanMap <- Map.empty?
19:26:37 <mike-burns> let nickToClientChanMap = Map.empty
19:26:42 <irene-knapp> it's not a monadic function (since maps are immutable)
19:26:49 <irene-knapp> so yeah, what mike-burns said
19:27:12 <mike-burns> But your question and answer indicate that you need to re-read what `do' ... does.
19:27:32 <mike-burns> Well you don't need to, but it can't hurt.
19:27:49 <nexion> it's the same as >> for each line, yeah?
19:27:58 <mike-burns> (>>=)
19:28:14 <mike-burns> Also that's an insane oversimplification.
19:29:51 <mike-burns> do { x <- y; return (x + 1) }    is similar to    y >>= \x -> return (x+1)
19:30:11 <nexion> is it -> or >>?
19:30:12 <mike-burns> The    <-    syntax uses the (>>=) function, so make sure you understand its types.
19:30:23 <mike-burns> Neither!
19:30:30 <ddarius> @undo do x <- y; return (x + 1)
19:30:31 <lambdabot> y >>= \ x -> return (x + 1)
19:30:46 <nexion> oh!
19:31:13 <nexion> ok
19:31:22 <nexion> I'll read up on it
19:31:23 <mike-burns> So you want a `let'.
19:37:22 <nexion> in: let nickToClientChanMap = Map.empty, where empty is of type Map k a, how does it determine k and a types?
19:37:35 <nexion> I'm guessing it figures them out based on where I pass it
19:37:53 <nexion> in this case to clientManagerLoop :: TChan ClientManagerChanMessage -> (Map.Map String (TChan ClientChanMessage)) -> IO ()
19:37:54 <nexion> right?
19:53:04 <Jafet> nexion: yes
19:54:48 <nexion> ty
19:58:21 <eddde> hello, is it possible to generate an executable with a compiler written in Haskell?
19:58:37 <monochrom> yes
19:59:17 <eddde> I'm trying to do a compiler for my language using Haskell, Parsec was a good tool to use, but now I would like to generate an executable from my language. Which tools can I use for that?
20:00:00 <ddarius> The easiest thing to do would be to output some other language and then use its compiler, e.g. Haskell or C.
20:00:14 <irene-knapp> that's what Agda does for example, I think
20:00:17 <bd_> or LLVM
20:00:38 <monochrom> shouldn't need any tool. just emit the right bytes.
20:00:52 <bd_> _need_? no. _want_? yes. :)
20:00:54 <irene-knapp> the hardest thing to do would be to implement your own ELF, Mach-O, and COFF generators and linkers, and your own x86, x86-64, and ARM assemblers.
20:01:07 <bd_> irene-knapp: also codegen
20:01:22 <irene-knapp> well, you can't avoid codegen to /some/ target, even if that target is LLVM
20:01:36 <bd_> sure. but some targets are easier than others
20:01:42 <bd_> eg with llvm you don't need to do register allocation
20:01:43 <irene-knapp> certainly
20:01:49 <irene-knapp> yeah, it's a great design
20:02:10 <eddde> I was told that if someone would like to achieve that in C#.NET it would be needed to use "Reflection". But what would be the Haskell approach to that?
20:02:39 <eddde> llvm?
20:02:40 <irene-knapp> (wtf does Reflection have to do with it, haha)
20:02:45 <irene-knapp> @google LLVM
20:02:46 <lambdabot> http://llvm.org/
20:02:47 <lambdabot> Title: The LLVM Compiler Infrastructure Project
20:02:49 <monochrom> what? compilers have long existed and done fine without reflection. just emit the right bytes.
20:02:57 <bd_> irene-knapp: reflection would be how you load generated .NET bytecode
20:02:57 <irene-knapp> LLVM is a library to make compilers simpler
20:03:08 <bd_> you don't need it for an offline compiler, but if you want to compile on the fly it's necessary
20:03:09 <irene-knapp> bd_: that's a separate problem - that's running as a JIT
20:03:18 <bd_> irene-knapp: JIT, or a compiling interpreter
20:03:26 <irene-knapp> bd_: right, okay, I see.  but he didn't put that in the problem statement that he gave to us.  maybe it was what he wanted, but if so he didn't say so. :)
20:03:51 <eddde> monochrom, sorry but what does it mean to "emit the right bytes"?
20:04:07 <monochrom> unix has been loading generated code with reflection since 1970
20:04:10 <monochrom> err
20:04:13 <monochrom> unix has been loading generated code without reflection since 1970
20:05:07 <monochrom> emit the right bytes means if you know x86 machine code for example, you write the compiler to emit x86 machine code.
20:05:30 <monochrom> if you don't know any machine code, you are not ready for writing a compiler
20:05:51 <irene-knapp> eddde: I was about to say what monochrom just did, so I'll second it.
20:06:02 <irene-knapp> compilers are really a topic that if you don't already know how, you cannot expect anyone to help you!
20:06:44 <bd_> monochrom: unless you can target your compiler to C or something
20:06:53 <monochrom> of course you can say you don't want to do x86, you want to do 680x0 instead or llvm instead or jvm instead or whatever.
20:07:36 <eddde> it is for school, my classmates decided to use .NET and I prefered the Haskell approach, know when it comes to generate executables is where it seems to be problem.
20:07:50 <irene-knapp> eddde: how many semesters do you have for this project?
20:07:52 <eddde> llvm looks good, btw
20:07:57 <monochrom> then learn .net's machine code
20:08:01 <eddde> irene-knapp, 1
20:08:50 <irene-knapp> eddde: is it a group project or an individual one?
20:08:56 <eddde> irene-knapp, individual
20:09:41 <irene-knapp> eddde: okay.  I won't advise you to definitely drop the course, then, but be prepared to work very hard for the entire semester and, when it's over, be only 10% done with the project.
20:10:02 <irene-knapp> eddde: but everyone else will be in the same boat (although your architecture choice will maybe make you get not quite as far as them)
20:10:15 <irene-knapp> eddde: so the grades will be curved and your GPA won't be dragged down TOO much
20:10:47 <irene-knapp> eddde: you may or may not learn anything that makes the experience worthwhile, either about compilers or about life :)
20:10:57 <irene-knapp> eddde: I can't judge whether you will or not, which is why I cannot advise you
20:11:01 <eddde> I remember to have read the blog from AlephNull Plex for "let's build a compiler" and it was using assembly language iirc
20:11:10 * irene-knapp shrugs
20:11:18 <irene-knapp> tutorials on compiler design oversimplify it drastically
20:11:29 <eddde> that's what you mean that it is important to know before building it?
20:11:33 <irene-knapp> yes
20:12:04 <ddarius> If you want to generate machine code, you need to know machine code.  If you are not (directly) generating machine code, you don't need to know it (but it still helps in general.)
20:12:04 <irene-knapp> GHC, for example, is an enormous program, but even in that we don't do our own assembler; we use the system-provided one
20:12:12 <irene-knapp> (although doing so causes us no end of compatibility nightmares)
20:12:20 <ddarius> irene-knapp: Not really.
20:12:33 <irene-knapp> ddarius: welllll, it doesn't break too often anymore, but read that code sometime!
20:12:41 <irene-knapp> ddarius: I did, when I was trying to remove the #ifdefs.  NOT pretty.
20:13:12 <irene-knapp> the pretty-printer needs to know how the platform ABI does name-mangling, but nothing passes in that information, so it's determined at GHC-build time and communicated via the C preprocessor
20:13:27 <irene-knapp> there are like ten different codepaths depending on what architecture you're targeting
20:13:44 <eddde> perhaps I should use OOP, I wonder why classmates tell C# is easier to do it in that language
20:13:51 <irene-knapp> just for one example of ugly issues caused by relying on the system assembler
20:13:52 <ddarius> You'd need to know how the platform ABI does name-mangling even if you weren't using a system assembler.
20:13:56 <irene-knapp> hmmmm
20:13:59 <irene-knapp> yeah, oops haha
20:14:16 <irene-knapp> right, what I was thinking was more that it wouldn't be the pretty-printer that was doing it, right
20:14:16 <eddde> ddarius, ah yeah, not directly generating code seems a good approach
20:14:19 <irene-knapp> it would be a lower layer
20:14:35 <monochrom> you are welcome to use Java or C# or Haskell or Prolog or Excel for that matter. does not change the problem that you have no idea what machine code looks like.
20:14:55 <irene-knapp> but really that's not the fault of the assembler, it's GHC's fault for using the pretty-printer for like ten different things
20:16:10 <irene-knapp> Funny that you mention Excel.  Did you know that the Excel team at Microsoft actually wrote their own C compiler just for it?
20:16:26 <monochrom> oh, how come?
20:16:29 <irene-knapp> They require extremely predictable performance with regard to numeric operations.
20:17:07 <monochrom> that may or may not help, actually
20:17:09 <irene-knapp> Using Visual Studio as other teams at Microsoft do, they were too vulnerable to things changing unexpectedly in new versions.
20:17:37 <irene-knapp> Yeah, heh.  Well, it must have turned out to help, because I read that it's been that way since the beginning and still is the case.
20:18:28 <ddarius> irene-knapp: That may just mean they never reevaluated the decision.
20:18:36 <monochrom> it sounds like they only need to pin down one compiler version
20:18:39 <irene-knapp> ddarius: hmmmm, well, yeah, I mean, it's Microsoft
20:19:35 <monochrom> and yeah, I know far more boring reasons of adopting a tool than "it is the most suitable tool"
20:19:52 <irene-knapp> haha yes
20:21:05 <monochrom> most of the time the real reason is "at first I thought X was broken and Y was better, so I switched to Y; some time later I found out it was PEBKAC; but then after the problem was solved, it turns out that X and Y were both adequate. well Y doesn't hurt, so no point going back to X"
20:21:31 <irene-knapp> hahaha
20:21:32 <irene-knapp> yes
20:23:23 <monochrom> it is definitely how I choose my wifi channel
20:23:32 <irene-knapp> hahaha
20:23:38 <irene-knapp> see
20:23:43 <irene-knapp> I make it a point when that happens
20:23:57 <irene-knapp> to set the damn thing back to "automatic" when I figure it out
20:24:07 <irene-knapp> I did go through that process with my wifi channel though :)
20:24:41 <luite> all my wifi channels are equally slow :(
20:24:45 <irene-knapp> yeah
20:24:48 <luite> guess I need a better access point
20:24:58 <irene-knapp> you need a 5GHz-band one
20:25:00 <irene-knapp> they are great
20:25:08 <byorgey> preflex: seen Cale
20:25:09 <preflex>  Cale was last seen on #haskell 1 day, 26 minutes and 51 seconds ago, saying: oh, I see
20:25:20 <irene-knapp> not least because they cost more, so the bulk of people, seeing that, don't buy them and are therefore not occupying those frequencies :D
20:25:22 <luite> I have an airport express set at 5GHz, but its range is terrible, can't receive it from here
20:25:26 <irene-knapp> ah okay
20:25:27 <irene-knapp> hmm
20:25:30 <Cale> hi byorgey
20:25:43 <mauke> preflex: seen byorgey
20:25:44 <preflex>  byorgey was last seen on #haskell 35 seconds ago, saying: preflex: seen Cale
20:25:51 <byorgey> hi Cale, I was sondering how to start lambdabot with the right options to it connects to IRC
20:26:03 <byorgey> I have it built, when I run it it just says 'initializing plugins' and then does nothing
20:26:11 <byorgey> *wondering
20:26:28 <Cale> byorgey: you construct an rc file which has commands to connect, one sec
20:26:34 <monochrom> there is actually SUIF. you give it an intermediate representation, and it emits machine code. probably like LLVM.
20:27:24 <Cale> My online.rc starts with:   irc-connect freenode irc.freenode.net 6667 lambdabot Lambda_Robots:_100%_Loyal
20:27:24 <Cale> rc passwd.rc
20:27:49 <byorgey> Cale: right, I made one of those, how do I tell lambdabot to look at it?
20:27:51 <Cale> and passwd.rc has   msg freenode:nickserv identify <lambdabot's password>
20:28:05 <Cale> ~/bin/lambdabot -e 'rc /home/cale/.lambdabot/online.rc'
20:28:26 <byorgey> oh, I think I see what happened
20:28:49 <byorgey> I commented out 'OfflineRC' because I don't have readline and I thought "I don't need offline mode"
20:28:59 <byorgey> but it looks like OfflineRC is what does rc file handling as well
20:29:37 <monochrom> it is a bit misleading to say "if you use SUIF or LLVM you don't need to know machine code". the problem is you then need to know SUIF code or LLVM code, which is not so much less work than knowing machine code, if you know nothing.
20:29:46 <irene-knapp> haha, yes
20:29:50 <irene-knapp> but he left the channel
20:30:17 <irene-knapp> see that's my problem with today's CS curricula
20:30:44 <irene-knapp> most CS departments can't agree on an overall structure, so they just let each professor teach whatever area he specializes in
20:30:55 <irene-knapp> as a result, it's impossible to ever do a project that lasts more than one semester
20:31:03 <irene-knapp> and MOST software projects NEED at least a year if not four!
20:31:17 <irene-knapp> note that humanities have this figured out
20:31:27 <irene-knapp> and frequently do have multiple-semester sequences where you're building on your previous work
20:32:14 <irene-knapp> I mean, really, a compiler from scratch, with not even a recommendation from the professor on what infrastructure to use, in four months?  wtf?
20:33:17 <pikhq_> irene-knapp: That isn't *impossible*, but it's complete pain, agony, and sorrow if you have to do it the way I bet the professor expects.
20:33:22 <irene-knapp> when I took Aho's course in language design, again, most of the teams failed horribly,
20:33:23 <pikhq_> i.e. C, Lex, YACC.
20:33:28 <irene-knapp> yes, indeed
20:33:44 <irene-knapp> ... but at least he was responsible about it and TOLD people before they started that their ideas were too big
20:33:47 <irene-knapp> and he didn't expect a code generator
20:33:59 <irene-knapp> it was really a parsers course, heh
20:34:04 <irene-knapp> just /called/ a compilers course
20:34:20 <pikhq_> Alas. Parsing's just a part of compilation.
20:34:27 <irene-knapp> yep
20:34:28 <pikhq_> Arguably the least interesting one.
20:34:35 <irene-knapp> I dunno, it can be interesting, but yeah
20:35:08 <VHD> with (||) I take it the left branch will get evaluated first?
20:35:20 <ddarius> VHD: Yes.
20:35:25 <byorgey> works now, thanks Cale!
20:35:30 <VHD> thank you ddarius
20:35:40 <monochrom> I think we did ok in the compiler course I took. (I did very well of course. I mean other classmates did ok.) but yes the key was that the instructor taught us everything and dictated everything.
20:35:48 * irene-knapp nods
20:57:02 <dmwit> Lambda_Robots:_100%_Loyal -- wut
20:57:20 <luite> that has been the ident for lambdabot for a long time :)
21:29:02 <GordonFreeman> haskell could be extended to use AMD-s latest 'invention' the CPU with multiple stream processors integrated in the form of GPU ;)
21:29:17 <GordonFreeman> functional language has great future in parallel programming of those
21:31:01 <Axman6> in theory yes
21:37:04 * hackagebot type-unary 0.1.10 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.10 (ConalElliott)
21:37:06 * hackagebot aeson 0.4.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.4.0.0 (BryanOSullivan)
21:39:39 <Axman6> anyone played with the pure language??
21:39:46 <Axman6> -?
21:48:24 <dskippy> Anyone know why I might be getting "cabal: data is not in tar format" when I try to run cabal update?
21:49:47 <byorgey> dskippy: try running  cabal update -v3  and see if it gives you any more information
21:50:04 <dskippy> I did that already :) That's the only help I found on Google.
21:50:12 <dskippy> I didn't get much.
21:50:28 <dskippy> Shows where the non-tar file is put.
21:50:54 <ddarius> dskippy: What is the non-tar file?
21:52:12 <dskippy> Some 2k binary file
21:53:16 <byorgey> dskippy: are you on Windows, Mac, or Linux?
21:53:25 <dskippy> Windows.
21:53:39 <dskippy> This works fine on my Linux machne. Trying to set this up on my work machine.
21:54:01 <dskippy> I also don't really know Windows very well at all. Just putting that out there :)
21:54:07 <dskippy> I wish I had the file command.
21:54:27 <byorgey> hehe, I was going to suggest 'file' but then realized you might be on Windows...
21:54:41 <Sgeo> I love how someone in another channel, in about 6 lines of code, replicated a feature of Python and Javascript, and did it far better than those languages
21:55:00 <dskippy> Oh, most frustrating thing ever: How do you rename a windows file to have a new extention?
21:55:04 <dskippy> ARG!
21:55:29 <dskippy> I know this is not a Windows channel. But I just realized one of the files I got from cabal is HTML
21:55:33 <monochrom> in a command prompt. or first change some options of the file explorer
21:55:36 <dskippy> So I'm going to open it in Firefox.
21:56:20 <monochrom> the option is something about "show file extensions". after it shows file extensions, you can change them, IIRC
21:56:40 <dskippy> Yeah I used to know where that option is.
21:56:43 <dskippy> Not anymore.
21:56:59 <strager> Folder Options
21:57:03 <strager> I'd use cmd though
21:57:04 * hackagebot type-unary 0.1.11 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.11 (ConalElliott)
21:57:20 <strager> You can't make dot files using Explorer =\
21:58:17 <dskippy> The HTML file I got is a "session timedout" message.
21:59:26 <monochrom> perhaps problems with dns-resolving or connecting or windows-firewall
22:00:14 <dskippy> Could be.
22:00:26 <dskippy> I am on a company network which might be doing odd things.
22:01:22 <dskippy> But the network never blocks websites or anything. My company isn't like that. But I think it's still potentially likely that the firewall is not playing nicely with cabal in some way
22:01:38 <mbetter> I get that at work too
22:01:51 <dskippy> Hm. Perhaps I'll try when I get home then.
22:01:54 <monochrom> cabal just uses the http port to get to hackage. should be ok with most firewalls (I mean most sysadmin's config of firewalls) but some sysadmins wants you to go through a proxy
22:01:56 <dskippy> Thanks for the help guys.
22:09:53 <DukeDave> I'm have far too much trouble with this: Drop last element in list (i.e. init) except if null then [] and if x:[] then x
22:13:37 <byorgey> DukeDave: just handle the two special cases with pattern-matches, then use init in the fall-through case
22:14:01 <byorgey> however, 'if x:[] then x' does not have the same type as init
22:14:14 <byorgey> unless you meant 'if x:[] then x:[]'
22:14:24 <DukeDave> byorgey: That's what I'm doing, I had hoped for something a little nicer :(
22:14:28 <DukeDave> Ah, yes, sorry
22:14:51 <DukeDave> Where nicer = one line
22:15:49 <byorgey> init' [] = []; init' [x] = [x]; init' xs = init xs  -- one line =P
22:16:02 <rwbarton> It doesn't seem to me like a terribly nice thing to want
22:16:49 <byorgey> yeah, I was going to say something similar.  if you want a nicer version, it probably means you should rethink whatever you're doing so it all works out more nicely
22:17:04 * hackagebot type-unary 0.1.12 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.1.12 (ConalElliott)
22:17:06 * hackagebot zoom-cache 0.8.1.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.8.1.0 (ConradParker)
22:17:08 * hackagebot arx 0.0.4 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.0.4 (JasonDusek)
22:17:10 * hackagebot scope 0.5.0.0 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.5.0.0 (ConradParker)
22:17:14 <byorgey> e.g. perhaps use a different data structure, or organize your algorithm differently
22:18:31 <DukeDave> rwbarton: byorgey: This is my 'problem': I want to shorten strings to n chars or less, but not break up a word..
22:18:48 <DukeDave> So I was using this: unwords . init . words . take 20
22:19:16 <DukeDave> Which fits my previous definition of 'nicer'
22:19:47 <byorgey> DukeDave: but using the version of init that you described would needlessly get rid of the last word even if it's complete
22:20:13 <DukeDave> Erm, just make 20 = 21 :)
22:20:26 <byorgey> ehhh
22:20:55 <DukeDave> > unwords . init . words . take 10 $ "two words"
22:20:57 <lambdabot>   "two"
22:21:06 <DukeDave> > unwords . init . words . take 11 $ "two words"
22:21:08 <lambdabot>   "two"
22:21:28 <DukeDave> Oh I see, yes, yes it would..
22:21:50 <DukeDave> This used to work :|
22:22:54 <byorgey> I was thinking something along the lines of: break into words, pair each word with its length, do 'scanl' to build up the accumulated text and length, then do 'takeWhile' and 'last'...
22:23:02 <byorgey> I don't know if that's really any better
22:23:27 <byorgey> doing scanl with (++) is a bad idea
22:24:19 <DukeDave> Bah, it's late, I'm going for:
22:24:19 <DukeDave> > (\str ->take 5 str ++ "..") "Why long string?"
22:24:21 <lambdabot>   "Why l.."
22:24:28 <DukeDave> :)
22:27:03 <ddarius> > (\str -> take 5 str ++ "..") "abcde"
22:27:05 <lambdabot>   "abcde.."
22:27:57 <DukeDave> ddarius: Heh, yeah, I also realised that :)
22:28:52 <rwbarton> People who end text with .. drive me crazy
22:31:33 <kfish> m3ga, https://plus.google.com/101555949501667191720/posts/P3Z8Gyp5nGt
22:32:01 <DukeDave> rwbarton: Sorry..
22:32:39 <rwbarton> :)
22:33:07 <DukeDave> rwbarton: Does it drive you crazy because it's supposed to be "...", ala: http://en.wikipedia.org/wiki/Ellipsis
22:39:14 <rwbarton> Well he left, but yet.
22:39:17 <rwbarton> *yes.
22:40:57 <shachaf> rwbarton: Also two exclamation marks or two question marks.
22:42:14 <rwbarton> Hmm, maybe I should try reading .. as an especially emphatic neutral sentence end marker.
22:45:35 <cwl> I want a function (-5) perform like (+5),
22:45:53 <cwl> how to write it short
22:46:09 <cwl> shoter than flip (-) 5
22:46:21 <cwl> > flip (-) 5 2
22:46:23 <lambdabot>   -3
22:47:02 <kfish> it's shorter if you remove the spaces: (flip(-)5)
22:47:33 <shachaf> > (subtract 5) 8
22:47:34 <lambdabot>   3
22:47:38 <shachaf> > (-5+) 8
22:47:39 <lambdabot>   3
22:47:47 <cwl> @src substract
22:47:47 <lambdabot> Source not found.
22:48:07 <cwl> @src subtract
22:48:08 <lambdabot> subtract x y = y - x
22:48:22 <cwl> good
22:48:28 <cwl> that is it
22:52:04 * hackagebot HTTP 4000.2.0 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.0 (GaneshSittampalam)
23:11:20 <deggis> i just wrote one yesterday as (+(-5)), what a beauty
23:29:10 <rainman85> Hi, I would need a list function which applies a predicate to every two elements of the list and return certain elements from that list which satisfy the predicate. Something like a filter function, but which works with two elements at the same time instead of one
23:29:27 <rainman85> Anyone has any idea?
23:32:04 * hackagebot yoko 0.2 - generic programming with disbanded constructors  http://hackage.haskell.org/package/yoko-0.2 (NicolasFrisby)
23:32:06 * hackagebot HTTP 4000.2.1 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.1 (GaneshSittampalam)
23:39:55 <Cale> rainman85: zip the list with its own tail and use filter on that?
23:50:08 <ezyang> 'evenin #haskell
23:51:52 <ezyang> I guess everyone is asleep ^_^
23:59:44 <jgreene> I'm attempting to read in a large file and insert the records into a database, but I'm running into memory issues
