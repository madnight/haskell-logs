00:14:03 <Jaxan> > let twice f x = f (f x) in twice (\f -> (\m -> m . f m) . f) twice (+ 1) 0
00:14:04 <lambdabot>   42
00:16:28 <FUZxxl> omgwtf
00:16:46 <mauke> > let twice f x = f (f x) in twice (\f -> (\m -> m . f m) . f) twice (+ 1) 0 :: Expr
00:16:47 <lambdabot>   0 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +...
00:17:52 <mauke> :t (.) =<< (ap (.))
00:17:53 <lambdabot> forall a. ((a -> a) -> a -> a) -> (a -> a) -> a -> a
00:18:38 <mauke> :t let twice = join (.) in twice ((.) =<< (ap (.))) twice succ 0
00:18:39 <lambdabot> forall a. (Enum a, Num a) => a
00:18:46 <mauke> > let twice = join (.) in twice ((.) =<< (ap (.))) twice succ 0
00:18:47 <lambdabot>   42
00:18:52 <Jaxan> nice
00:19:09 <shachaf> > let twice f x= f (f x) in twice Just True
00:19:10 <lambdabot>   Occurs check: cannot construct the infinite type:
00:19:10 <lambdabot>    t = Data.Maybe.Maybe t
00:19:13 <shachaf> :-(
00:32:10 <tmhz> G'day, what are `Infinity' and `NaN', are they data types or some type of internally defined thing?
00:32:14 <tmhz> > 1/0
00:32:15 <lambdabot>   Infinity
00:32:25 <tmhz> > let x = Infinity
00:32:26 <lambdabot>   not an expression: `let x = Infinity'
00:32:40 <mauke> no
00:32:42 <tmhz> > let x = NaN
00:32:43 <lambdabot>   not an expression: `let x = NaN'
00:42:08 <ion> tmhz: They’re what “show” returns for certain floats.
00:42:28 <mauke> tmhz: excuse me wtf r u doin
00:43:42 <tmhz> mauke: sorry mate what did I do?
00:45:02 <mauke> tmhz: sent me 6 time requests and 1 version request
00:45:45 <tigger_> I'm trying to build a parser for this string "[Section1]" with parsec. I am trying the following code: http://codepad.org/u1QHxDCT. It doesn't seem to work. Does anyone have any ideas what I could be doing wrong?
00:46:35 <tmhz> mauke: sorry im not sure how that happened, im new to irc. I think I better go read how to use this thing
00:47:12 <mauke> tigger_: how does it fail?
00:47:53 <tigger_> http://codepad.org/Go4CxNRg
00:47:59 <tigger_> also this code fails with a similar error
00:48:13 <tigger_> char '[' *> char ']'
00:48:30 <tigger_> or doesn't fail
00:48:33 <tigger_> just doesn't type check
00:49:50 <Cale> tmhz: Infinity and NaN are floating point values
00:51:11 <tmhz> Cale: but I can't assign to them. so as ion said I think i must be a string representation.
00:52:21 <Cale> tmhz: Oh, sure "Infinity" and "NaN" are how two particular floating point values show up when printed. They're not Haskell definitions.
00:52:24 <min> this is probably a dumb question, but why is infinity a floating point value? i thought floating point numbers were intended to be a representation of the reals over a countable set.
00:52:39 <mauke> you thought wrong
00:52:57 <tmhz> Cale: Cool thanks mate.
00:52:59 <min> evidently
00:53:02 <Cale> min: http://en.wikipedia.org/wiki/IEEE_754-2008
00:53:06 <Cale> is why
00:53:31 <mgsloan> Infinity / NaN constructors would be kinda cool.  It'd be fully embracing the idea that data Int = ... -2 | -1 | 0 | 1 | 2 ...
00:53:59 <mgsloan> (except in this case for the Float equivalent data structure)
00:54:23 <mgsloan> then again the integer literals are (Num a => a)
00:54:31 <mgsloan> so nevermind
00:54:39 <tmhz> > let x = read "Infinity" :: Float
00:54:40 <lambdabot>   not an expression: `let x = read "Infinity" :: Float'
00:54:54 <mgsloan> > read "Infinity" :: Float
00:54:56 <lambdabot>   Infinity
00:55:27 <Cale> You have to finish the let/in if you want to use let expressions
00:55:47 <Cale> > let x = read "Infinity" :: Float in x/x
00:55:47 <lambdabot>   NaN
00:55:48 <tmhz> ahh ok
00:55:55 <Cale> > let x = read "Infinity" :: Float in -x
00:55:56 <lambdabot>   -Infinity
00:59:11 <mm_freak> what language features would have to be added to haskell to allow to unify Monoid, Alternative and ArrowPlus under one class?
00:59:15 <mauke> where is tigger_
00:59:42 <mm_freak> they seem to be very similar to each other, differing only in kinds
01:00:01 <shachaf> mm_freak: Well, the MonadPlus Maybe instance is quite different from the Monoid Maybe instance. For instance.
01:01:17 <etpace> Anyone happen to have harpys tutorials lying about? the website seems to be down for me ( http://uebb.cs.tu-berlin.de/harpy/ )
01:04:10 <min> cale: skimming the wikipedia page, i didn't think wrong; i just didn't understand the role of infinity in floating point computations.
01:04:45 <tigger_> hmmm, any one have an idea why this pretty simple line of code won't load: http://codepaste.dev7studios.com/item/hgshkhnnq
01:08:00 <mauke> tigger_: it works with a type signature
01:08:05 <mauke> therefore, DMR
01:08:21 <tigger_> mauke: DMR?
01:08:37 <mauke> the dreaded monomorphism restriction
01:08:57 <mauke> solution: add a type signature or add {-# LANGUAGE NoMonomorphismRestriction #-}
01:09:09 <tigger_> mauke: okay, ill google that. thanks
01:09:29 <mm_freak> shachaf: just hypothetically
01:10:04 <mm_freak> if you were to provide a generic Monoid class, which accounts for all three classes, what type system features would you need, which haskell lacks?
01:10:08 * hackagebot marionetta 0.1.0.1 - A study of marionetta movements.  http://hackage.haskell.org/package/marionetta-0.1.0.1 (PaoloVeronelli)
01:10:25 <mm_freak> does it even make sense (disregarding that you might want to have different functionality for the different classes)?
01:13:57 <min> haskell doesn't lack and type system features necessary to wrap several classes into a single class. to actually express an algebraic structure, though, haskell would require dependent types.
01:14:15 <shachaf> mm_freak: I don't think unifying Monoid and MonadPlus makes that much sense in anything similar to Haskell.
01:15:25 <Sgeo|web> Could OverlappingInstances be used to write the ST monad in pure code without unsafePerformIO?
01:16:07 <Sgeo|web> Hmm, OverlappingInstances might not be needed
01:16:37 <mauke> I think you only need unsafeCoerce
01:17:18 <Sgeo|web> Without unsafeCoerce
01:17:54 * Sgeo|web is basically thinking of using nested pairs of tuples as a data store
01:22:10 <Sgeo|web> Hmm, I don't think it would be possible to get useful data out of it, but I'm not sure
01:28:26 <jaspervdj> preflex: seen chrisdone
01:28:26 <preflex>  chrisdone was last seen on #haskell 11 hours, 18 minutes and 14 seconds ago, saying: Cale: needs more quine
01:31:33 <Sgeo|web> Night
01:33:05 <mm_freak> min: you can't unify Monoid, Alternative and ArrowPlus in haskell…  it fails already because of the differing kinds
01:33:19 <frerich> Is there a nice book which goes beyond RWH/LYAH and talks about stuff like Arrows ?
01:33:21 <mm_freak> shachaf: sure, i wouldn't do it either
01:33:35 <mm_freak> i really just want to know what the type system feature is called, which i would need for that
01:34:02 <mm_freak> basically you have:  a -> a -> a, m a -> m a -> m a and a b c -> a b c -> a b c
01:34:33 <mm_freak> it seems to me that (just technically!) a slightly more powerful type system can express a single function, which unifies with all three
01:35:10 <mm_freak> frerich: not a single one, unfortunately
01:35:27 <mm_freak> frerich: you have many papers/tutorials concentrating on a specific feature
01:36:17 <mm_freak> for arrows you may want to read an unfinished tutorial i'm writing right now…  if you're interested, i can /notice you the URL
01:38:08 <frerich> mm_freak: That would be much appreciated
02:20:40 <hiptobecubic> dmwit, eventually i found this one to be 'the most helpful':  http://john.bitsurge.net/public/Monads_as_Wrappers.txt      It came from some site where the text was all screwed and encoded wrong, so i reformatted it and uploaded it.
02:26:36 <shachaf> hiptobecubic: Ugh, that's one of the famous wrong analogies.
02:27:00 <hiptobecubic> shachaf, well he does comment at the bottom that it's wrong
02:27:13 <hiptobecubic> shachaf, although it seems quite similar to the allaboutmonads one
02:27:33 <shachaf> Most monads aren't containers in almost any reasonable sense of the word "container".
02:28:23 <shachaf> By the way, something's messed up with your encoding.
02:30:24 <mauke> space stations and astronauts? fuck this
02:32:46 <Botje> screw monad tutorials, just look at the types
02:32:46 <shachaf> mauke is clearly a proponent of nuclear waste containers.
02:35:35 <shachaf> http://en.wikibooks.org/w/index.php?title=Haskell/Understanding_monads&oldid=933545
02:35:49 <shachaf> "Exercises: Write a tutorial explaining how monads work. You might find inspiration in the tutorials listed on the Haskell meta-tutorial. Try to find a new audience for your tutorial, or a new way of explaining things."
02:36:16 <mm_freak> one problem of most monad tutorials (including mine) is that they don't really specify what problems monads solve
02:36:45 <mm_freak> there is one specific problem they solve:  composing side-effecting values
02:37:09 <mm_freak> where getting a value involves performing a side effect, not necessarily an impure one, but a side effect
02:37:10 <shachaf> "monads" as a general thing don't solve anything other than abstracting some useful operators.
02:37:35 <shachaf> Individual instances of the Monad class do solve useful problems. They'd do that even if they weren't in the Monad class.
02:37:49 <mm_freak> i think you can interpret everything as effects
02:38:15 <shachaf> The way to get people to appreciate the Monad class is to first get them to appreciate individual instances of it without saying the M-word, and then point out the similarities between them.
02:38:19 <hiptobecubic> mauke, no spacestations and astronauts and spacesuits and tickets?
02:39:01 <mauke> @quote duqicnk
02:39:02 <lambdabot> No quotes match. I am sorry.
02:39:10 <mauke> preflex: quote duqicnk
02:39:10 <preflex>  <duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
02:39:50 <hiptobecubic> sure, i can see that
02:40:00 <shachaf> @quote dons spaces
02:40:01 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
02:40:01 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
03:03:35 <hpaste> “Simon Wu” annotated “p12” with “p12 (3)” at http://hpaste.org/54220#a54229
03:07:46 <hpaste> “Simon Wu” annotated “p12” with “p12 (4)” at http://hpaste.org/54220#a54230
03:10:28 <mm_freak> when using split or splitLookup from Data.Map, what's the complexity, if the delimiter is smaller than the minimum key or larger than the maximum key?
03:10:41 <mm_freak> like you have keys 4, 5, 6 and split at key 2
03:32:52 <Saizan> still log n it seems, it rebuilds the path from the root to the smallest key
03:36:16 <mm_freak> alright, thanks
04:00:35 <hiptobecubic> the latest ghc doesn't have a lot of the same modules that 7.0 series had it seems. Are we no longer in 'haskell98' world?
04:07:47 <Melvar> Is there something like zipWith with state/carry in the standard library?
04:11:43 <gienah> hiptobecubic: haskell98 is so last millenium. at least haskell2010 is in the same century :-)
04:12:07 <hiptobecubic> gienah, sure, but it's breaking my xmonad :D
04:12:26 <ClaudiusMaximus> :t \s0 f xs ys -> foldr f s0 (zip xs ys)
04:12:27 <lambdabot> forall b a b1. b -> ((a, b1) -> b -> b) -> [a] -> [b1] -> b
04:12:53 <hiptobecubic> ahhh i see. i have to rebuild everything with new compiler for cabal to handle it properly
04:13:23 <dcoutts> hiptobecubic: try cabal install world --dry-run
04:13:53 <hiptobecubic> dcoutts, installing xmonad/xmonad-contrib at the moment. what is 'world' ? all packages?
04:14:07 <dcoutts> all packages you installed previously
04:15:12 <ClaudiusMaximus> :t runState
04:15:14 <lambdabot> forall s a. State s a -> s -> (a, s)
04:17:47 <hiptobecubic> dcoutts, ah ok, thanks.
04:18:35 <gienah> hiptobecubic: I just built both xmonad and xmonad-contrib from darcs with ghc 7.2.2
04:18:57 <ClaudiusMaximus> > let adder (a, b) = do{ c <- get ; let s = a + b + c ; put (s `div` 2) ; return (s `mod` 2) } in runState (mapM adder ([0,0,1,0,1,0] `zip` [0,1,1,1,1,0])) 0
04:18:58 <lambdabot>   <no location info>: parse error on input `;'
04:18:59 <hiptobecubic> gienah, me too. i didn't realize that changing ghc meant reinstalling everything with cabal
04:19:18 <ClaudiusMaximus> > let adder (a, b) = do{ c <- get ; let { s = a + b + c } ; put (s `div` 2) ; return (s `mod` 2) } in runState (mapM adder ([0,0,1,0,1,0] `zip` [0,1,1,1,1,0])) 0
04:19:19 <lambdabot>   ([0,1,0,0,1,1],0)
04:19:26 <gienah> hiptobecubic: ok, great :-)
04:23:42 <Melvar> ClaudiusMaximus: Okay, I guess.
04:25:08 <statusfailed> Err, dumb question: how should I achieve "foldWhile" ?
04:25:15 <ClaudiusMaximus> @hoogle (a -> b -> c -> (d, c)) -> [a] -> [b] -> c -> ([d], c)
04:25:15 <lambdabot> No results found
04:26:03 <Melvar> @hoogle (c -> a -> b -> (c,d)) -> c -> [a] -> [b] -> (c,[d])
04:26:04 <lambdabot> No results found
04:27:02 <carpi> Hi. Could someone please tell me if there is a way to get information about a certain function right on the command line on GHCi?
04:27:09 <statusfailed> carpi: :i or :t
04:27:13 <statusfailed> ?
04:27:25 <statusfailed> :t foldl
04:27:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:27:42 <ClaudiusMaximus> Melvar: i think there's no ready made combinator, it does seem quite specialized - but you can always make your own
04:27:50 <Melvar> ClaudiusMaximus: I did.
04:27:55 <ClaudiusMaximus> Melvar: cool
04:29:09 <carpi> statusfailed: but that only gives a description of its arguments and return types. it does not tell me what the function actually does...
04:30:00 <carpi> for example :i head tells me in which module head is defined and also its return type and arguments. But no information about what it does.. which is "returns first element in a sequence(list)"
04:30:21 <ClaudiusMaximus> carpi: http://haskell.org/haskellwiki/GHC/GHCi#Package_and_documentation_lookup might be of interest
04:31:24 <statusfailed> carpi: oh I see... that would be useful ^^
04:33:02 <AfC> Is there a more appropriate way of taking an Int and turning it into a string than `printf "%d"`?
04:33:45 <int-e> show
04:33:55 <hpaste> guest pasted “happstack-lite” at http://hpaste.org/54232
04:34:16 <int-e> > show (123 :: Int)
04:34:17 <lambdabot>   "123"
04:39:10 <hpaste> guest pasted “prasec” at http://hpaste.org/54233
04:39:35 <Guest27544> http://hpaste.org/54232  http://hpaste.org/54233  but mtl is already installed
04:39:45 <Guest27544> how can I get this to work?
04:40:18 <AfC> int-e: well, I tried that. And I was getting errors. I tried again. And now I'm not.
04:40:19 <AfC> I blame the phase of the moon
04:40:25 <carpi> ClaudiusMaximus: Thanks. = )
04:40:26 <AfC> int-e: thanks
04:40:51 <AfC> [complication, I'm in bytestring land, so I had to do pack $ show i]
04:51:09 <davorb> anyone here familiar with haskore?
04:51:39 <davorb> i'm having some issues figuring out which packages to import.
04:51:42 <davorb> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.1113
04:51:49 <davorb> doesn't seem to be all that up to date :P
04:54:14 <weirdo> hello, haskellites
04:54:22 <weirdo> how do you do serialization without tag bits?
04:54:28 <weirdo> or casting
04:54:42 <weirdo> is there some GHC builtin stuff?
04:54:55 <weirdo> i'm asking because F# has broken/nonexistent serialization and i'm curious
04:56:00 <davorb> weirdo: i'm sort of a haskell newb, but doesn't Real World Haskell talk about serialization in one of the JSON-related chapters?
04:56:09 <weirdo> i see
04:56:13 <weirdo> i only read parts of LYAH
04:56:42 <int-e> We could name lambdabot Tom ... Then the lamb Da could be joined by the bot Tom. (The only difficulty is that lambdabot is generally accepted to be female.)
04:57:14 <osfameron> she could be a tomboy
04:58:18 <ion> > show (Just ["Serialization!"])
04:58:19 <lambdabot>   "Just [\"Serialization!\"]"
04:59:03 <davorb> weirdo: yeah, the way ion wrote it. and then there's equivalent stuff for parsing
04:59:18 <weirdo> fun
04:59:39 <weirdo> and F# only has hacks...
05:00:08 <ion> There’s also this for instance.
05:00:11 <ion> @hackage cereal
05:00:11 <lambdabot> http://hackage.haskell.org/package/cereal
05:00:19 <davorb> anyway is there a way to import all "subpackages" automatically. let's say that I have Haskore, Haskore.Melody, Haskore.Blabla and so on. Is there anything equivalent to "import Haskore.*"?
05:00:44 <hpc> davorb: generally, "import Haskore" will have everything you need
05:01:04 <davorb> hpc: for some reason it doesn't even have ":+:"
05:01:22 <weirdo> holy cow. i wonder how he did it without tag bits...
05:01:25 <hpc> davorb: ah, then you'll have to bite the bullet there and import everything you need
05:01:34 <ion> What are tag bits?
05:02:17 <weirdo> ion, lowest bits of every pointer that signify the type of an expression, letting one to cast it toward a more specific type with safety
05:02:30 <weirdo> s/expression/datum
05:03:26 <ion> Just for serializing Haskell values in Haskell, you don’t need to know what the system does under the hood.
05:03:42 <weirdo> typeclasses?
05:04:02 <hpc> weirdo: that part you will want to know, but he means what machine code gets generated, stuff like that
05:04:06 <hpc> :P
05:04:14 <weirdo> ok
05:04:45 <hpc> although, once you get to "why is the show instance for strings different from regular lists", you will want to gouge your eyes out :D
05:04:56 <ion> GHC uses pointer tagging indeed, but you don’t need to care about it.
05:05:17 <weirdo> it does?
05:05:22 <weirdo> crap
05:05:36 <davorb> is there any place I can find actual documentation of the haskore library, sort of like I can find for the prelude? i can't even find a place taht lists all of the functions... :/
05:05:36 <ion> huh?
05:05:39 <weirdo> i wonder if it can fit a double in a register then
05:05:48 <weirdo> lisp has a problem with that
05:06:11 <weirdo> and uses some hairy tricks to avoid boxing
05:06:13 <weirdo> all the time
05:06:24 <hpc> weirdo: why do you need to know such a specific detail? profile your code, see what's slow and what isn't, then decide if it's something you can improve on your own
05:07:02 <weirdo> hpc, i'm a bit interested in compilers, perhaps not to assembly, but still
05:07:08 <hpc> ah
05:07:34 <hpc> GHC does unboxing sometimes as part of its optimization pass
05:08:22 <davorb> aah, nm. looks like my haskore installation was borked, that's all..
05:09:30 <weirdo> thanks for the chat, guys. need to go read/fix that f# code. nothing beats programming during a depressive episode :|
05:11:02 <hpc> weirdo: http://hackage.haskell.org/trac/ghc/wiki/Commentary -- bookmark this; there's some really cool articles there
05:12:07 <weirdo> wish haskell was strict
05:12:25 <weirdo> and didn't have that many infix operators that make it look like perl
05:12:45 <rostayob> would a language extension where kinds are like Kind k ::= Type | Name | k -> k be decidable?
05:12:53 <hpc> weirdo: it's very much stricter than perl; for one, parsing is decidable
05:12:56 <rostayob> kind of like in Ur/Web
05:13:22 <weirdo> hpc, its evaluation isn't
05:13:28 <rostayob> that would enable nice records
05:13:45 <weirdo> there's some strict haskell dialect in before-alpha stage
05:13:53 <hpc> ah
05:14:21 <hpc> weirdo: there's already lots of strict haskell-like languages (see: ML)
05:14:25 <weirdo> it always gives me problems how to express stuff like an euler seed
05:14:37 <hpc> or rather, haskell is a lazy ML-like language :P
05:14:37 <weirdo> hpc, i'm using F# which is just nominal-unification ML
05:14:52 <weirdo> but ML looks like a wall of poetry
05:15:05 <weirdo> or just text
05:15:47 <hpc> a lot of haskell features are based on the assumption of laziness; strict haskell i imagine would not behave very much like lazy haskell at all
05:18:27 <mroman> Strict haskell would break a lot of code ;)
05:19:43 <hpc> mroman: once more with even less exaggeration :P
05:22:01 <mroman> hpc: Code using infinite lists for example.
05:22:18 <mroman> @ zip [1,2,1,2] [1..]
05:23:22 <mroman> > zip [1,2,1,2] [1..]
05:23:23 <lambdabot>   [(1,1),(2,2),(1,3),(2,4)]
05:23:41 <mroman> > zip [1..12] (cycle$[1..3])
05:23:42 <lambdabot>   [(1,1),(2,2),(3,3),(4,1),(5,2),(6,3),(7,1),(8,2),(9,3),(10,1),(11,2),(12,3)]
05:23:46 <mroman> things like that.
05:24:38 <mroman> > take 10 $ fix ((:0).scanl(+)1)
05:24:39 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
05:24:50 <mroman> > take 10 $ fix ((0:).scanl(+)1)
05:24:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:25:36 <mroman> That wouldn't really work without laziness.
05:30:05 <mm_freak> i don't think that any of my programs would run with a strict-by-default haskell
05:31:00 <mm_freak> strict haskell breaks mfix and loop, which would be fatal for me
05:32:31 <hpc> it breaks some forms of infinite monadic actions too
05:34:31 <mm_freak> it already breaks this:  take 10 [1..]
06:14:13 <mm_freak> what exactly does 'seq' force in a Map?
06:14:47 <roconnor> IIRC Data.Map's structure is entirely strict
06:14:47 <mux> @src Map
06:14:47 <lambdabot> Source not found. My mind is going. I can feel it.
06:14:59 <mux> I thought it was only spine-strict ?
06:15:01 <alistra> Data.Map?
06:15:05 <roconnor> so seq would force everything except the content
06:15:26 <roconnor> I think
06:18:43 <copumpkin> > M.size (M.fromList [('m':'o':'o':undefined, 5), ('b':'a':'a':undefined, 4)])
06:18:44 <lambdabot>   2
06:19:09 <mokus> yes, i've been through that code fairly recently and it is spine-strict and lazy in th elements
06:19:26 <copumpkin> it's as strict on the keys as the Ord instance is
06:19:51 <copumpkin> > M.size (M.fromList [('m':'o':'o':undefined, 5), ('m':'o':'o':'n':undefined, 4)])
06:19:52 <lambdabot>   *Exception: Prelude.undefined
06:20:28 <int-e> > M.size (M.fromList [(undefined :: String, 5)])
06:20:30 <lambdabot>   *Exception: Prelude.undefined
06:20:38 <mokus> data Map k a = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
06:20:57 <copumpkin> being strict in k doesn't mean you force the entire key
06:21:08 <mokus> right, but it does always force to WHNF
06:21:13 <copumpkin> yep
06:21:15 <mokus> even if the Ord is totally lazy
06:21:39 <mokus> which is admittedly pretty much never the case ;)
06:22:03 <int-e> > M.size (M.fromList [('m':'o':'o':undefined, 5), ('m':'o':'r':'n':undefined, 4)]) -- that's the other side of copumpkin's point
06:22:03 <lambdabot>   2
06:45:58 <Philonous> Why do people keep saying that there are "values trapped in monads". That makes as much sense as saying that the directory content is trapped in ls
06:47:29 <mike-burns> Use rm to get it out!
06:47:48 <alistra> it's because you can't easily and safely get file contents as a string
06:47:53 <alistra> not IO  String
06:50:32 <dschoepe> alistra: If one subscribes to Philonous' analogy: You can't get the file contents in Haskell, only an action that, when executed, will read the file. :)
06:50:50 <dschoepe> (ignoring unsafePerformIO)
06:50:57 <alistra> > safely
06:50:58 <lambdabot>   Not in scope: `safely'
06:51:33 <alistra> so the string value is trapped in IO monad
06:51:43 <alistra> because you can't get it or make something from it
06:51:48 <alistra> outside of the IO monad
06:52:27 <Philonous> alistra:  No, there is no string value. That's the point. There is only a promise to produce one. Eventually. Possibly not.
06:52:30 <dschoepe> One might say that you never have a String value, only an `IO String' value.
06:52:41 <sipa> you can only say "right, but when you *do* have the string value, don't give it to me, but i'll tell you in advance what to do with it"
06:53:34 <frerich> Isn't the net effect of your two views basically the same - you can't get a raw String from an IO String?
06:53:57 <alistra> therefore IT'S TRAPPED
06:54:00 * frerich doesn't understand why you're even discussing this.
06:54:00 <o1iver> alistra: have a look at another monad to understand this. Once you understand what runState does for the State Monad, this will become obvious. The problem I had with IO when I started learning haskell was the fact that as opposed to other monads GHC calls runIO (or whatever it's called) for you...
06:54:32 <alistra> o1iver: i know how it works
06:54:48 <alistra> Philonous asked, why do people call it trapping
06:54:54 <alistra> i'm answering
06:54:54 <o1iver> alistra: oh ok, sorry
06:55:09 <o1iver> alistra: I just read the last few msgs...
06:55:16 <alistra> naughty
06:55:21 <aninhumer> There are a million intuitive explanations of Monads and they are all wrong in some way
06:56:02 <o1iver> aninhumer: I think "computational context" is the only thing that gets it right (although that is certainl ynot intuitive)
06:56:19 <Volis> preparing for an informatics olympiad. There'll be lots of informatics puzzles, we'll be supposed to do on paper. Book recommendations?
06:56:26 <Philonous> alistra:  The point is, there is no string value there to begin with, that's why you can't get it out and it doesn't make sense to say that this non-existing value is "trapped" because it's just not there.
06:56:58 <aninhumer> I think they're still useful, they just need to be qualified
06:57:03 <alistra> the value of type string exist in the right side of >>=
06:57:07 <Volis> Papers from the archives of the olympiad if anyone wants to see it, http://www.iarcs.org.in/inoi/2010/zio2010/zio2010-qpaper.pdf
06:57:16 <rs46> Is there an obvious way to convert a String to Word32 ?
06:57:39 <Philonous> alistra:  On the right side of the (>>=) is a function
06:57:54 <alistra> yeah
06:57:57 <alistra> and inside of that
06:58:22 <sipa> alistra: so, you give a function that tells what you *will* do with the string once you have it
06:58:26 <alistra> people wouldn't invent the do notation, if they thought like you Philonous
06:59:03 <Philonous> alistra:  I'm beginning to think that the do-notations is a mistake because it makes you think that there are values trapped in monads that you can pry out by applying <-
06:59:30 <alistra> the whole point of monads
06:59:46 <alistra> is that you can use it like you had sting values
07:00:04 <alistra> and don't have to watch out for border cases like file not existing
07:00:10 <alistra> because the monad does that for you
07:00:11 <Philonous> Yes, but you wouldn't pretend you had them when they where actually there
07:00:33 <Philonous> wouldn't have to pretend*
07:01:22 <alistra> also saying that IO String doesn't have a string is like saying that
07:01:29 <alistra> [String] doesn't have a string
07:01:37 <mokus> [] doesn't
07:01:41 <alistra> i know
07:02:04 <alistra> but sometimes it does, and we care for those cases, because the underlying monad definition cares about the rest
07:03:27 <Philonous> Again, saying IO String contains a String is like saying ls contains my directory listings. It's just absurd
07:03:42 <alistra> it's a bad analogy
07:03:46 <Philonous> No it's not
07:03:49 <sipa> it's a very good analogy
07:04:01 <alistra> IO String is a type, ls is a function
07:04:07 <mokus> i'd say "ls contains my directory listings" is more like "getLine contains a line of user input"
07:04:18 <alistra> this ^
07:04:30 <Philonous> OK, you are right. Saying a value of this type contains a String is like saying ls contains my directory listings
07:04:40 <Nimatek> One positive thing the do notation does, is syntax-sugaring away the stacked lambdas.
07:05:10 <Nimatek> Which can end up looking a bit ugly.
07:05:33 <alistra> yeah
07:05:36 <Nimatek> But other than that, it's not a good model to think in, I find.
07:05:37 <alistra> and the monad notation
07:05:51 <alistra> sugars away checking if the input exist
07:06:02 <sipa> ?
07:06:04 <alistra> so the whole program flow you model (if you're already using monads)
07:06:11 <tomprince> a monad may not contain values, but if you can treat often treat it as if it does ... hence the analogy
07:06:13 <alistra> is under assumption, that you'll get that string
07:10:55 <aninhumer> I think it's perfectly valid to talk about the potential of a string as if it was concrete
07:11:50 <aninhumer> we should be careful to qualify that for beginners, but it is a useful thought model
07:13:50 <EvanR-work> the documentation says
07:14:03 <EvanR-work> 'This fold is not strict. The stream consumer is responsible for forcing the evaluation of its result to avoid space leaks.'
07:14:15 <EvanR-work> what exactly does it mean
07:15:18 <EvanR-work> what exactly does the stream consumer need to do
07:16:18 <jkramer> Ahoy
07:16:28 <jkramer> The date/time types of haskell are troubling me
07:16:38 <EvanR-work> they shouldnt, they are awesome
07:16:43 <jkramer> How do I convert a NominalDiffTime to an Integer (seconds)
07:16:45 <jkramer> ?
07:17:10 <EvanR-work> fromIntegral
07:17:15 <jkramer> I figure that they're already (pico)seconds inside
07:17:25 <EvanR-work> er... its not Integral
07:18:01 <jkramer> Yup, I already thought of that :)
07:18:17 <Philonous_> floor . toRational
07:18:27 <Philonous_> At least that's how I did it
07:18:34 <EvanR-work> you dont need toRational
07:18:42 <alistra> @src NominalDiffTime
07:18:42 <EvanR-work> its an instance of RealFrac
07:18:42 <lambdabot> Source not found. That's something I cannot allow to happen.
07:18:52 <alistra> @src RealFrac
07:18:53 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
07:18:53 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
07:18:53 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
07:18:56 <EvanR-work> floor :: Integral b => a -> b
07:19:08 <EvanR-work> floor :: NominalDiffTime -> Integer
07:19:15 <EvanR-work> jkramer: floor ;)
07:19:19 <alistra> (round v) :: Integer
07:19:36 <alistra> jkramer: ^
07:19:36 <Philonous_> EvanR-work:  Indeed. Thanks.
07:21:30 <EvanR-work> if you wanted 'number of picoseconds' then you need RealToFrac and some stuff
07:21:53 <jkramer> Seems weird to me but works :)
07:21:54 <EvanR-work> er
07:21:54 <jkramer> Thanks
07:22:04 <EvanR-work> multiply by 10^12, then floor ;)
07:22:27 <EvanR-work> 10**12
07:22:40 <mokus> 1e12
07:23:50 <EvanR-work> jkramer: the idea is that its some sort of number already, with properties similar to Double, so you use the same library functions
07:24:00 <EvanR-work> not necessarily 'number of picoseconds inside'
07:25:06 <jkramer> EvanR-work: Yeah, would be nice to a properly named function in Data.Time for such a common task though :)
07:25:10 <jkramer> *have
07:25:21 <EvanR-work> how is this common
07:25:38 <EvanR-work> if you want number of seconds, then just use floor
07:25:42 <saml> hello. i want to build a server/machine that is dedicated for image processing .   is there a job queue for haskell?
07:26:00 <EvanR-work> just like all the other 'common' uses of floor
07:26:15 <saml> by image processing, i mean it'll execute  N imagemagick processes concurrently at all times.
07:27:23 <cheater> why would you want haskell for that
07:27:54 <saml> what should i use? i have freedom
07:27:55 <EvanR-work> > 1/0
07:27:55 <saml> erlang?
07:27:56 <lambdabot>   Infinity
07:28:06 <ClaudiusMaximus> imagemagick already uses openmp for parallelism, afaik
07:28:10 <EvanR-work> > toRational (1/0)
07:28:11 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
07:28:12 <saml> haskell was initial choice for publicity
07:28:20 <cheater> haskell for publicity
07:28:22 <cheater> lol
07:28:58 <int-e> > 2^1024 -- shorter ;)
07:28:59 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
07:29:18 <EvanR-work> infinity starts with the digit 1
07:30:10 <int-e> > toRational (0/0) < toRational (-1/0)
07:30:11 <lambdabot>   True
07:30:48 <EvanR-work> > read "NaN" :: Double
07:30:49 <lambdabot>   NaN
07:30:55 <cheater> NaNCat
07:30:56 <EvanR-work> > toRational (read "NaN" :: Double)
07:30:58 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
07:32:21 <EvanR-work> jkramer: btw this often happens with the documentation, under each data type theres a list of instances, in this case there lay your answer, happens a lot
07:32:48 <EvanR-work> it doesnt relist all the useful stuff the instances implement
07:33:08 <EvanR-work> notably pay attention to Functor
07:33:36 <int-e> > toRational (-0/0) == 3*2^1023 ... fun I didn't know that -0/0 gives a different NaN than 0/0
07:33:37 <lambdabot>   Not in scope: data constructor `I'Not in scope: `didn't'Not in scope: `know...
07:34:06 <EvanR-work> a different NaN o_O
07:35:35 <int-e> EvanR-work: well there are 2^53-2 bit representations for an IEEE 754 (binary) double :)
07:35:44 <int-e> for NaN, that is.
07:36:06 <EvanR-work> is that so
07:36:14 <EvanR-work> the 11 bit part has a code for NaN
07:36:21 <EvanR-work> and the rest can carry 53bit payload
07:36:30 <EvanR-work> amazing no one has used this for bullshit yet
07:36:44 <int-e> well, almost -- if the payload is 0 or -0 then you get infinity :)
07:37:23 <EvanR-work> out of band NaN channels!
07:38:34 <jkramer> EvanR-work: Yeah, I was focusing on Num too much I guess
07:38:45 <jkramer> Seemed most natural to me, wanting to get an Integer
07:39:04 <EvanR-work> complex numbers are Num
07:39:31 <EvanR-work> so not necessarily Integral
07:46:57 <cheater> saml: anyways, you'd probably use fabric or capistrano or puppet
07:48:57 <saml> what's fabric? it's ahrd to google
07:49:18 <saml> isn't it deployment tool?
07:50:22 * hackagebot buildwrapper 0.2.1 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.2.1 (JeanPhilippeMoresmau)
07:54:55 <ClaudiusMaximus> what's the best midi file writing library? from a cursory glance, 'midi' seems full of T, 'zmidi-core' seems full of Word8, 'HCodecs' seems light on docs (but then the types are enough docs i guess)
07:56:07 <sipa> T?
07:57:04 <ClaudiusMaximus> sipa: yes.  module A where data T ; module B where data T ; etc etc etc
07:57:26 <ClaudiusMaximus> sipa: end result, T -> T -> T -> T in the haddocks as it doesn't show qualifications
07:59:03 <EvanR-work> uhg
07:59:06 <EvanR-work> annoying
07:59:29 <dmwit> There's the alsa library.
07:59:39 <dmwit> Dunno how good it is, but if you hate the others, maybe it's worth a glance.
07:59:55 <EvanR-work> alsa will encode midi files? o_O
08:00:14 <dmwit> ...maybe not.
08:00:26 <dmwit> I read your question too quickly.
08:00:52 <EvanR-work> it does have a giant data regime to represent midi events
08:01:05 <EvanR-work> the C lib
08:06:24 <ClaudiusMaximus> i think i'll go with HCodecs and see how fed up i get
08:37:14 <rs46> Is there an obvious way to convert a String to Word32, and back again ?
08:37:38 <sipa> you mean parsing and formatting?
08:39:32 <rs46> sipa: yes, I think
08:39:48 <sipa> > read "123" :: Word32
08:39:49 <lambdabot>   123
08:39:58 <sipa> > show (123 :: Word32)
08:39:59 <lambdabot>   "123"
08:40:11 <rs46> oops
08:40:13 <rs46> :-)
08:40:21 <geheimdienst> > map (fromIntegral . ord) "lolcats" :: [Word32]
08:40:23 <lambdabot>   [108,111,108,99,97,116,115]
08:40:39 <geheimdienst> chr is the reverse of ord
08:40:53 <geheimdienst> fromIntegral is the general-purpose conversion function
08:48:19 <frigga1> In the declaration "data Foo = Bar Int", what's the accepted terminology?  Foo is called a type constructor and Bar is called a data constructor, correct?
08:48:58 <aninhumer> frigga1: I think in that example Foo is just a type
08:50:33 <aninhumer> frigga1: If it was "data Foo a = Bar a" then Foo is a type constructor (I think)
08:52:45 <c_wraith> the Typeable interface doesn't differentiate between a no-arg type constructor and a type constructor that takes args..  But that isn't compelling
08:53:39 <c_wraith> The general pattern is right, though.  Type constructors and data constructors are the terminology for each of those.
08:57:54 <frigga1> aninhumer, c_wraith: Ok, thanks.
09:03:21 <EvanR-work> i may or may not be incrementally understanding the meaning of Applicative style
09:04:55 <EvanR-work> <$> <*>
09:05:14 <Veinor> does Data.Text use rabin-karp?
09:06:57 <EvanR-work> aeson seems really great, i think its the only time ive ever seen a json be actually validated before use
09:07:25 <EvanR-work> in js i partially validate data while im using it, crash immediately, but it sucks
09:08:14 <Veinor> oh, it's apparently something vaguely related to Boyer-Moore?
09:10:21 <Veinor> is there a splitBy such that splitBy (== "/") "1/2/3" = [1,2,3]?
09:10:35 <Veinor> or am i going to have to write it myself
09:10:54 <EvanR-work> you want it to autodecode numbers?
09:10:59 <Veinor> er
09:11:09 <Veinor> splitBy (== "/") "1/2/3" = ["1", "2", "3"]
09:11:12 <Veinor> i can map read myself
09:11:21 <EvanR-work> warning unsafe!
09:11:30 <shachaf> Veinor: Data.List.Split
09:12:01 <Veinor> EvanR-work: it's part of a webscraper, if that changes i'm basically screwed
09:12:04 <shachaf> Veinor: Isn't Rabin-Karp kind of specialized to use as a default substring search?
09:12:15 <Veinor> shachaf: Data.List.Split looks great, thanks
09:12:27 <EvanR-work> Veinor: then you really want robust parsing
09:12:56 <Veinor> how? if he changes the format of the website, there's no way to automagically figure out how he changed it
09:13:04 <rwbarton> if you're writing a web scraper then you want the simplest thing that will work now
09:13:25 <rwbarton> since it's a waste of time to try to guess how the format will change in the future, yeah
09:13:25 <EvanR-work> Veinor: well its going to crash and burn
09:13:33 <EvanR-work> not what i was saying
09:13:50 <Veinor> yeah, it'll crash and burn. but i can fix it :v
09:13:55 <EvanR-work> a more informative error message would be better than 'read failed'
09:14:05 <EvanR-work> 'read failed, somewhere'
09:14:41 <Veinor> i mean, i'll get a line number won't i?
09:15:01 <EvanR-work> > read "B" :: Int
09:15:02 <lambdabot>   *Exception: Prelude.read: no parse
09:15:11 <EvanR-work> maybe
09:15:31 <Veinor> no, apparently I don't.
09:16:55 <Veinor> so what would you suggest?
09:16:58 <rwbarton> Maybe by the time the format changes, GHC will have added support for giving stack traces on such exceptions. :P
09:17:11 <EvanR-work> do whatever works
09:17:24 <EvanR-work> its not like the web is supposed to actually work anyway ;)
09:22:32 <smeltzek> hi -- i am a novice haskell programmer and have a design problem. i am working on an embedded DSL which does some drawing on a GTK widget and needs to handle mouse event callbacks
09:22:51 <smeltzek> i have this working, but how do i tie the callbacks to individual parts of the drawing without introducing a global variable?
09:23:21 <EvanR-work> you can pass relevant reference to the callbacks
09:23:47 <shachaf> smeltzek: Pass a lambda that has something relating to the drawing in its scope?
09:24:28 <smeltzek> how would i go about that? i am currently just using the callbacks built in to gtk2hs which don't offer that functionality
09:24:45 <shachaf> smeltzek: How can they not offer that functionality?
09:25:12 <EvanR-work> im sure they
09:25:13 <EvanR-work> do
09:25:54 <shachaf> smeltzek: Looking up how Gtk2hs works, it seems that you say something like "on widget event ioaction".
09:26:50 <shachaf> smeltzek: So your IO action can presumably refer to anything in its scope, e.g., "on drawing mouseMove (updateDrawing drawing myVariableHere)"
09:27:27 <smeltzek> ah, okay. i think i understand now. so when I register the callback I ask it to pass the drawing to the function it calls
09:27:40 <EvanR-work> or use closure
09:27:48 <shachaf> smeltzek: "ask it to"?
09:28:18 <shachaf> You just pass it a callback that does whatever you want. This can include any variable in scope.
09:28:27 <smeltzek> perhaps i'm anthropomorphisizing my compiler a bit much
09:28:33 <smeltzek> okay, thanks all, i will give this a try
09:32:34 <wayne[mobile]> hi.
09:32:46 <shachaf> Ah, ask the compiler, not ask the Gtk callback-calling function.
09:32:51 <wayne[mobile]> i notcied that 4 == 3.999999999999999 results in a True
09:32:54 <wayne[mobile]> *noticed
09:33:03 <shachaf> wayne[mobile]: It's true!
09:33:08 <Veinor> welcome to floating point error!
09:33:09 <shachaf> Such is the way of IEEE floats.
09:33:17 <wayne[mobile]> what kind of floats does haskell use?
09:33:21 <wayne[mobile]> 754?
09:33:33 <wayne[mobile]> also, what size?
09:33:35 <EvanR-work> > 3.9999999999999999999999999999
09:33:36 <lambdabot>   4.0
09:33:36 <shachaf> > 4 == (3.999999999999999 :: Rational)
09:33:37 <carpi> Hi. I have become obsessed with haskell. Can someone please teach me? Over skype perhaps? Not for free ofcourse. Name your price per hour. Im no joking. I can pay to your account before you start teaching if that helps with the trust... Saturdays and Sundays are good for me.
09:33:37 <lambdabot>   False
09:33:52 <saati> wayne[mobile]: what your machine supports, and size depends on wether you use Float or Double
09:33:56 <mm_freak> > takeWhile (/= 1) [0, 0.1 ..]
09:33:57 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
09:34:08 <mm_freak> > drop 100 $ takeWhile (/= 1) [0, 0.1 ..]
09:34:09 <lambdabot>   []
09:34:17 <mm_freak> huh? wow
09:34:18 <EvanR-work> lol
09:34:23 <mm_freak> > drop 100 $ takeWhile (/= 1) [0 :: Float, 0.1 ..]
09:34:24 <lambdabot>   [10.000028,10.100028,10.200028,10.300029,10.400029,10.50003,10.60003,10.700...
09:34:27 <mm_freak> there we go
09:34:49 <wayne[mobile]> saati: do you have any idea what it would default to if i were to just use floating numbers in the prompt?
09:34:54 <EvanR-work> missing the stop sign
09:35:10 <EvanR-work> :t 3.14
09:35:12 <lambdabot> forall t. (Fractional t) => t
09:35:13 <saati> wayne[mobile]: try :t
09:35:23 <saati> but most likely Double
09:35:28 <saati> that should be 64 bits
09:35:35 <EvanR-work> :t let x = 3.14 in x
09:35:35 <wayne[mobile]> Fraction t?
09:35:36 <lambdabot> forall t. (Fractional t) => t
09:35:36 <mm_freak> wayne[mobile]: the RealFloat class gives you all that information
09:35:48 <mm_freak> > floatRadix (0 :: Double)
09:35:48 <lambdabot>   2
09:35:53 <wayne[mobile]> thank you, i'll look into the docs for that.
09:36:02 <mm_freak> > floatDigits (0 :: Double)
09:36:03 <lambdabot>   53
09:36:05 <mm_freak> etc.
09:36:11 <shachaf> > typeOf 8.2
09:36:12 <lambdabot>   Double
09:36:13 <EvanR-work> bah who uses floats
09:36:24 <EvanR-work> :t typeOf
09:36:25 <lambdabot> forall a. (Typeable a) => a -> TypeRep
09:36:28 <mm_freak> EvanR-work: who doesn't?  and what would be better?  and why?
09:36:45 <EvanR-work> mm_freak: no!
09:37:52 <EvanR-work> actually i would prefer unbounded deicmal fixed point set at 10^-9, for some stuff
09:38:23 <mm_freak> float is better than fixed point…  what you really want is a radix-10 float type
09:38:39 <EvanR-work> no
09:38:41 <EvanR-work> i really dont
09:38:47 <EvanR-work> for the reasons above
09:39:04 <mm_freak> there is nothing fixed point can do, what float can't, and fixed point will lose more precision
09:39:15 <EvanR-work> no
09:39:38 <EvanR-work> are you trolling
09:39:46 <mm_freak> no, i'm not, i'm serious
09:39:49 <EvanR-work> lol
09:40:05 <EvanR-work> i do not need 10^-183 dollars in my account
09:40:21 <EvanR-work> which will mysterious be lost next time i accumulate it
09:40:34 <mm_freak> you also don't want to lose them…  you would be throwing away information, just because your format can't represent it
09:40:45 <mm_freak> in that case you lose money, even though only a small amount
09:40:47 <EvanR-work> no i just wouldnt have anyone end up with that much in the first place
09:41:21 <Cale> Fixed point addition and multiplication are associative.
09:41:25 <EvanR-work> plus someone with 892703497820893792580374928739487209834 dollars wont lose anything because his mantissa is too big
09:41:40 <mm_freak> Cale: ok, good point
09:41:55 <Cale> I don't want the amount of money in my bank account to depend on the way in which transactions are associated :)
09:41:59 <mm_freak> EvanR-work: you can have a floating point type with infinite mantissa size
09:42:04 <shachaf> EvanR-work: No one should be storing dollars as any kind of floating point.
09:42:14 <wlangstroth> my mantissa is way to big to worry about this
09:42:14 <EvanR-work> shachaf: why are you tell me that
09:42:15 <shachaf> s/floating //
09:42:57 <saml> hey,  how can I do multithread? I have 6 cores and I want to spawn 6 threads to maximize cpu utilization
09:43:03 <EvanR-work> forkIO
09:43:05 <mm_freak> also nobody will exhaust a 256 bits float type…  we don't have enough atoms in the known universe to print enough banknotes =)
09:43:14 <saml> do I just use forkIO   and specify +Rsome parameter during runtime?
09:43:29 <mm_freak> any way…  you can well have a floating point type, for which (+) and (*) are associative
09:43:40 <saml> or should I do  if numOfRecursion < 6 then forkIO else nothing ?
09:43:45 <mm_freak> saml: depends…  what do you want to use the cores for?
09:43:52 <EvanR-work> mm_freak: now it sounds like you want floating for floatings sake, for everything
09:43:54 <saml> i'm trying to use hsmagick
09:44:16 <mm_freak> saml: then you would rather want something like Control.Parallel or the monad-par package
09:44:32 <saml> what's the difference?
09:44:41 <mm_freak> EvanR-work: no, i'm just saying that float is more powerful =)
09:45:04 <mm_freak> saml: the difference is that you can write pure code…  though if the library is impure, you can just as well work with forkIO
09:45:04 <EvanR-work> ive come to reject anything described as powerful, because it tends to blow up in my face
09:45:19 <wlangstroth> EvanR-work: A-men
09:45:38 <EvanR-work> software shouldnt be powerful, it should be correct and obvious
09:45:41 <mm_freak> saml: also don't worry too much about how many threads to launch…  if you have more haskell threads than OS threads, your threads will be distributed (usually evenly) by the run-time system for you
09:45:48 <mm_freak> saml: just make sure you have /enough/ threads
09:46:44 <mm_freak> EvanR-work: "powerful" in the "more general" sense, in this case
09:46:56 <EvanR-work> good powerful?
09:47:05 <EvanR-work> anyway
09:47:12 <EvanR-work> i said 'in some cases'
09:47:47 <mm_freak> i also say that arrows are more powerful than monads, but then i'm, as parcs_ said, an arrow fanatic =)
09:48:16 <EvanR-work> microsoft word is more powerful than notepad!
09:48:40 <wlangstroth> mm_freak: where does the enthusiasm for arrows come from? (I haven't tried using them yet)
09:48:50 <mm_freak> forall editor. emacs is more powerful than editor
09:49:01 <mm_freak> forall editor. emacs is at least as powerful as editor
09:49:13 <mm_freak> wlangstroth: AFRP
09:49:20 <EvanR-work> was about to say, is emacs more powerful than itself
09:49:30 <mm_freak> hehe
09:50:23 <wlangstroth> mm_freak: aramid fiber reinforced polymer?
09:50:28 <nazgjunk> emacs is a lisp interpreter, not an editor ;)
09:51:02 <mm_freak> wlangstroth: sorry, arrowized functional reactive programming
09:51:53 <mm_freak> apropos arrows
09:51:56 <EvanR-work> why is it called Arrow
09:52:10 <mbtez_> can someone answer a question for me
09:52:19 <mm_freak> i found that StateArrow is faster than ReaderArrow, even if you never modify the state
09:52:55 <mm_freak> mbtez_: yes, there, it's answered ;)
09:54:12 <mbtez_> can you describe an imperative loop-style program as feeding the state into the runtime functions recursively
09:54:17 <mbtez_> err
09:54:20 <mbtez_> in haskell
09:54:26 <mm_freak> EvanR-work: good question…  Arrow is a better name for Category…  and then rename Arrow to ArrowWithSideChannels
09:54:29 <mbtez_> the comparative.. implementation of that
09:54:56 <mm_freak> mbtez_: that doesn't make much sense to me…  could you rephrase?
09:55:03 <mbtez_> umm
09:55:03 <DrBigData> Hey guys, I am curious if anyone can offer any suggestions. I am hiring haskell programmers for my company in NYC and I am looking for the best way to reach the community at large.
09:55:21 <mbtez_> is haskell just a machine to loop over state and apply functions according to it
09:55:27 <mbtez_> in a recursive structure
09:55:35 <mbtez_> when you uh
09:55:45 <mbtez_> what's the word
09:55:50 <mm_freak> mbtez_: do you understand functional style?
09:55:51 <mbtez_> use functional reactive programming
09:55:56 <mbtez_> i'd like to think so
09:56:05 <mm_freak> wait, FRP is something entirely different
09:56:09 <mbtez_> well i know
09:56:10 <EvanR-work> are you trying to incorporate io side effects into your model?
09:56:15 <mbtez_> model?
09:56:42 <EvanR-work> yes youre trying to come up with a nonstandard model for haskell ;)
09:56:45 <mm_freak> mbtez_: FRP is a paradigm for programming systems, which change over time
09:56:49 <wayne[mobile]> after i finish this tutorial, http://learnyouahaskell.com , what libraries should i look into to make useful applications?
09:56:54 <mbtez_> yes i get that
09:57:01 <mbtez_> FRP programs are a subset of haskell programs
09:57:12 <mm_freak> well, not if you're me
09:57:17 <mm_freak> i think, i solve everything with FRP =)
09:57:22 <wayne[mobile]> i'm looking for a UI framework like qt
09:57:30 <Nimatek> DrBigData: I guess this IRC reaches a big part of the community.
09:57:30 <EvanR-work> wayne[mobile]: sorry to hear that
09:57:32 <mbtez_> i guess what i'm trying to figure out
09:57:43 <mm_freak> wayne[mobile]: while we're at it, you might want to look into the reactive-banana library
09:57:44 <mbtez_> is how you would go about building a desktop application in haskell... like a video game
09:57:52 <mm_freak> i think it's still fairly experimental, but you can write programs with it
09:58:06 <mbtez_> with a video game you can either choose what to do relative to time, or measure things by frame output
09:58:10 <EvanR-work> lol reactive-banana? o_O
09:58:13 <mbtez_> w/o frameskipping
09:58:19 <mbtez_> i'm trying to think how you would do that in haskell
09:58:23 <mm_freak> DrBigData: most companies post at least to the haskell-cafe
09:58:30 <mm_freak> DrBigData: and perhaps to the general haskell mailing list
09:58:39 <mbtez_> hopengl is confusing
09:58:47 <mm_freak> DrBigData: also check out the haskellers.org homepage
09:58:47 <EvanR-work> mbtez_: i use the basic game loop (that almost no one really understands) in haskell and it works fine
09:58:55 <mbtez_> which one is that
09:59:11 <mbtez_> can you send me any code?
09:59:28 <EvanR-work> http://evanr.infinitymotel.net/misc/loops.html
09:59:36 <mm_freak> mbtez_: first question is:  do you want to use FRP or rather use the classic game loop?
09:59:42 <EvanR-work> but thats in pseudo c
09:59:48 <mbtez_> that it is
09:59:57 <vegard1992> hello everybody
09:59:59 <mm_freak> the game loop is the imperative approach
10:00:00 <mbtez_> umm
10:00:11 <EvanR-work> its imperative, but only the top level needs to be
10:00:13 <mm_freak> classic FRP is the most declarative approach and arrowized FRP is something inbetween
10:00:27 * mbtez_ reads
10:00:32 <mm_freak> with classic FRP meaning:  using behaviours and events
10:00:36 <vegard1992> i have a question why this code doenst work:
10:00:40 <EvanR-work> you could think of the 'demo' part of the game, the time based part, as an unfolding on your game state
10:00:43 <vegard1992> let fibs(a,b)=fibs(b,a+b)
10:00:50 <vegard1992> let fib n = take n (fibs(0,1):[])
10:00:56 <vegard1992> ?
10:01:07 <mbtez_> 'demo'???
10:01:08 <mm_freak> vegard1992: your first function will recurse forever without producing
10:01:37 <mbtez_> so i would want to use the framerate cap one i guess
10:01:49 <mm_freak> vegard1992: what is fibs (0, 1)?  it's fibs (1, 1).  then what is fibs (1, 1)?  it's fibs (1, 2)
10:01:53 <mm_freak> it will never come to a conclusion
10:01:57 <EvanR-work> mbtez_: frames is the worst place to start thinking about this
10:02:08 <vegard1992> but the tutorial im using says
10:02:20 <mbtez_> well i don't want to produce something with lag issues
10:02:24 <vegard1992> that its ok
10:02:28 <vegard1992> to do recursive like that
10:02:28 <mbtez_> but i want to push the limits of how much it can render
10:02:30 <mauke> vegard1992: no, it doesn't
10:02:41 <EvanR-work> mbtez_: if you think of your game as a sequence of steps, then your graphics just a selection of renderings of each step, maybe all of them, but you could skip some
10:02:50 <mm_freak> EvanR-work: you still use imperative game loops?
10:02:55 <vegard1992> hm
10:02:57 <EvanR-work> 'still' ?
10:03:02 <mbtez_> you mean it should be multithreaded?
10:03:06 <mm_freak> EvanR-work: even frag uses FRP
10:03:07 <EvanR-work> mbtez_: no
10:03:11 <mm_freak> and it's just a demo =)
10:03:21 <mauke> > let fibs a b = a : fibs b (a+b) in fibs 0 1
10:03:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:03:28 <mm_freak> when using a game loop, you could just as well use C++
10:03:30 <mbtez_> i just want to see soem code :P
10:03:39 <mbtez_> mmaybe i should start my piecing apart that quake clone
10:03:44 <EvanR-work> mm_freak: if i wanted to drive myself to commit suicide yes
10:03:45 <newsham> mmfreak: then you wouldnt be using the greatest imperative language
10:03:53 <vegard1992> i dont understand what im doing wrong :S
10:04:07 <mauke> vegard1992: never returning a value
10:04:09 <mm_freak> newsham: sure, but at least you wouldn't have to reinvent OOP in haskell =)
10:04:16 <newsham> vegard: you wrote a function which never produces a result
10:04:24 <vegard1992> hm oh
10:04:24 <EvanR-work> mbtez_: well you need to figure out what model you want to use, and theres no obvious right answer to this
10:04:30 <mm_freak> imperative style and OOP are probably the worst ways to do a game…  and everybody does that
10:04:34 <EvanR-work> though mm_freak will have you believe its the holy grail
10:04:36 <EvanR-work> FRP
10:04:46 <mbtez_> mm_freak: the problem is encapsulating all the OBJECTS in your game ;)
10:04:57 <mbtez_> that's why it seems so appropriate
10:04:59 <vegard1992> so in addition to the recursive call to my function, i want to have something concrete?
10:05:00 <shachaf> mauke: "The Innovative Haskell Tutorial, section 1. Welcome to Haskell! Haskell is a great language, because it lets you do recursive liek this: let fibs(a,b)=fibs(b,a+b); let fib n = take n (fibs(0,1):[]). Section 2: Now join #haskell on Freenode and ask for help."
10:05:05 <newsham> frp seems like it would be a great way to specify a game.   i wonder if it would actually be a great way to implement a game :)
10:05:05 <mm_freak> mbtez_: i have no "objects" in the OOP sense
10:05:13 <mm_freak> mbtez_: i have signal transformers
10:05:16 <wayne[mobile]> so how is haskell utilized in industry? called from other programs?
10:05:16 <mbtez_> if you have a video game
10:05:19 <mbtez_> there are objects in its world
10:05:20 <EvanR-work> mbtez_: its not really appropriate, oop really merges a bunch of really inappropriate things together and gives it one label
10:05:22 <mbtez_> you gotta represent them somehow
10:05:33 <mm_freak> mbtez_: sure, OOP is one way to do it
10:05:38 <EvanR-work> you can call everything object, doesnt make it a good way to think of anything
10:05:48 <newsham> vegard: if your function is recursing, it has to make some sort of progress.. ie. it has to have a "base case" that stops the recursion.
10:05:50 <mbtez_> how is it done in haskell
10:05:52 <Cale> vegard1992: Let's see what we can discover using your definition. If fibs (a,b) = fibs (b,a+b), then  fibs (0,1) = fibs (1,0+1) = fibs (0+1,1+(0+1)) = fibs (1+(0+1),(0+1)+(1+(0+1)))... hmmm
10:05:56 <EvanR-work> mbtez_: there is no one way to do it
10:06:04 <mbtez_> what is a good way ;)
10:06:23 <EvanR-work> good question!
10:06:38 <Cale> wayne[mobile]: http://www.haskell.org/haskellwiki/Haskell_in_industry
10:06:44 <mbtez_> as long as i have good performance i could go any way with this
10:06:51 <wlangstroth> wayne[mobile]: haskell compiles to binary, so it can run on lots of target platforms on its own
10:06:54 <mm_freak> mbtez_: well, as EvanR-work noted snidely, i would use FRP
10:07:05 <mm_freak> and yes, i believe it to be the holy grail
10:07:15 <vegard1992> so how i say go until you have reached fibonacci n and return?
10:07:21 <mbtez_> ah
10:07:25 <Cale> wayne[mobile]: Also, I don't see Scribd on that page, but they do everything with Haskell.
10:07:27 <mm_freak> it has a learning curve though, so if you're a beginner, go with imperative style
10:07:29 <mbtez_> well that was my mindset when i came in here
10:07:31 <newsham> vegard: perhaps you are confusing your definition with the one that mauke provided above.. which works quite a bit differently.
10:07:33 <mbtez_> but i'm still not 100% sure how it works
10:07:34 <shachaf> Cale: They do?
10:07:44 <Cale> shachaf: Apparently :)
10:07:51 <EvanR-work> heh, FRP is the holy grail, now i will learn wtf it is
10:07:51 <mm_freak> mbtez_: "it" is a set of concepts from which to choose
10:08:06 <mbtez_> do you use the reactive module
10:08:10 <mbtez_> package
10:08:48 <mm_freak> mbtez_: mainly there are monadic and arrowized FRP…  the monadic approach is very declarative…  the AFRP approach is less declarative, but i find it easier to write real applications in it
10:09:00 <Cale> vegard1992: Well, it might work better if fibs was producing a list
10:09:02 <mbtez_> arrowized huh
10:09:15 <edwardk> EvanR-work: like the holy grail it may not exactly work as advertised ;)
10:09:18 <kurenai> hello! trying to learn how to do OpenGL in haskell i found strange operator which meaning is mystery to me. it looks like "$=!". google was of no help. what does it mean?
10:09:22 <EvanR-work> edwardk: lol
10:09:27 <Cale> vegard1992: like  fibs a b = a : fibs b (a+b)
10:09:33 <mbtez_> lol everyone is going hopengl today
10:09:38 <mbtez_> i watched kurenai too kurenai
10:09:42 <kurenai> it's great!
10:09:46 <mm_freak> mbtez_: note sure about reactive, but it seems obsolete to me…  if you want to try the monadic approach, look into elerea and reactive-banana
10:09:49 <mbtez_> nice channel
10:10:18 <mm_freak> kurenai: do you mean ($=)?
10:10:23 <kurenai> i really want to animate this colorful cubes :)
10:10:31 <Cale> $=! is like $= but strict
10:10:33 <mbtez_> we all do
10:10:40 <Cale> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html -- it's documented here
10:10:46 <kurenai> there's string "angle $=! a + 0.1" in tutorial code
10:10:55 <vegard1992> right
10:10:56 <Cale> which is a module re-exported by http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.2/doc/html/Graphics-Rendering-OpenGL-GL.html
10:11:05 <vegard1992> but what if i dont want list? because its consuming some memory
10:11:13 <EvanR-work> color is so web1.0, go with monochrome
10:11:13 <mm_freak> kurenai: yes, opengl has a number of variables, and ($=) is the way to set them
10:11:16 <vegard1992> can i do this?
10:11:31 <kurenai> and angle is state fariable
10:11:37 <mm_freak> or ($=!) for that matter
10:11:48 <kurenai> but what exclamation means?
10:11:54 <pesco> given that there are a number of cryptographic libraries for haskell nowadays... is there a standard way to make sure secrets are not swapped to disk? i.e. some form of mlock()?
10:11:54 <kurenai> in this case
10:12:10 <mm_freak> kurenai: it's strict
10:12:22 <Cale> vegard1992: Well, the list is infinite and only the part of it that you're looking at is ever in memory, but sure, we can do it without a list.
10:12:30 <kurenai> oh. ok. thak you.
10:12:38 <kurenai> thank
10:12:50 <Cale> vegard1992: fib 0 (a,b) = a; fib n (a,b) = fib (n-1) (b,a+b)
10:13:11 <newsham> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2) n fib 5
10:13:12 <lambdabot>   not an expression: `let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - ...
10:13:27 <newsham> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n - 2) in fib 5
10:13:29 <lambdabot>   5
10:13:33 <Cale> or perhaps better to reorder the arguments like  fib (a,b) 0 = a; fib (a,b) n = fib (b,a+b) (n-1)
10:13:43 <mbtez_> crap..reactive banana, what was the other one?
10:13:55 <Cale> that way the usual fib can be obtained by partial application of this fib to (0,1)
10:14:04 <mm_freak> mbtez_: elerea
10:14:15 <mm_freak> when i was using the monadic approach, i liked elerea most
10:14:23 <mm_freak> but it has a discrete time model, which you might not like
10:14:30 <Cale> > let lucas (a,b) 0 = a; lucas (a,b) n = lucas (b,a+b) (n-1); fib = lucas (0,1) in fib 10
10:14:31 <lambdabot>   55
10:15:08 <mbtez_> where do i find example hopengl/elerea code ?
10:15:18 <mm_freak> probably nowhere =)
10:16:00 <kurenai> but please write one, when you'll figure it out
10:16:16 <newsham> where does the name "lucas" come from?
10:16:25 <int-e> lucas sequences
10:16:30 <newsham> danke
10:16:35 <mbtez_> http://www.etymonline.com/index.php?allowed_in_frame=0&search=lucas&searchmode=none
10:16:43 <mm_freak> kurenai: i don't think i'll be going back to monadic FRP any time soon
10:17:10 <vegard1992> ok thank you :-) i will look at it
10:17:33 <vegard1992> functional programming is much different from normal, difficult  getting into
10:17:37 <newsham> vega: notice how cale's definition has a way for the recursion to stop.. when the second argument reaches zero it returns "a" immediately
10:17:37 <vegard1992> but very exciting
10:18:31 <vegard1992> im a little confused to be honest
10:18:49 <vegard1992> i need time to digest it
10:18:57 <vegard1992> :D
10:19:36 <Cale> vegard1992: If you think this is confusing wait until you see:
10:19:43 <Cale> > fix ((0:) . scanl (+) 1)
10:19:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:19:50 <Cale> ;)
10:22:40 <int-e> > scanl (*) 1 [1..]
10:22:41 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:22:50 <newsham> nice
10:23:03 <geheimdienst> > scanl1 (*) [1..]
10:23:04 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
10:23:06 <newsham> (the fix fib)
10:23:09 <geheimdienst> saves one space :)
10:23:40 <int-e> geheimdienst: different sequence though.  and technically, no space is required at all: scanl(*)1[1..] parses perfectly fine.
10:23:46 <int-e> to the computer, that is
10:25:04 <wlangstroth> Cale: that's pretty good - it took me a second to get to the "oh, right" moment.
10:25:39 <int-e> > map length ["(scanl(*)1[1..]!!)","product.enumFromTo 1"]
10:25:40 <lambdabot>   [18,20]
10:26:00 <Cale> wlangstroth: :)
10:26:18 <Cale> and of course there's this one:
10:26:31 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
10:26:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:27:30 <Cale> > let fibs = 0 : 1 : (zipWith (+) <*> tail) fibs in fibs
10:27:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:27:32 <geheimdienst> we could of course "improve" that with fix ...
10:27:39 <Eliel> could someone explain this fix function for me? I looked at it but couldn't figure it out.
10:27:42 <Cale> > let fibs = (0 :) . (1 :) . (zipWith (+) <*> tail) $ fibs in fibs
10:27:44 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:27:54 <Cale> > let fibs = fix ((0 :) . (1 :) . (zipWith (+) <*> tail)) in fibs
10:27:56 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:28:28 <Cale> Eliel: Well,  fix f = x where x = f x
10:28:38 <int-e> > fix error -- Sometimes Haskell really won't do what I want.
10:28:39 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:28:54 <Cale> Eliel: or:  fix f = let x = f x in x, just to rewrite the same thing
10:29:06 <Eliel> Cale: still makes no sense.
10:29:06 <Cale> Eliel: So, if we do something like...
10:29:07 <newsham> ?let fac_ recurse n = if n == 0 then 1 else n * recurse (n - 1)
10:29:09 <lambdabot>  Defined.
10:29:25 <newsham> > (fac_ . fac_ . fac_ . fac_ . undefined) 3
10:29:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:29:26 <lambdabot>    arising from a use of `...
10:29:28 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
10:29:29 <lambdabot>   3628800
10:29:40 <Cale> Let's evaluate this by hand
10:29:49 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
10:30:01 <Cale> -> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
10:30:08 <int-e> Oh, Cale-bot is running at full power today. :)
10:30:18 <Cale> -> let x = (\n -> if n == 0 then 1 else n * x (n-1)) in x
10:30:29 <Cale> or, just rewriting the syntax a bit...
10:30:36 <Cale> -> let x n = if n == 0 then 1 else n * x (n-1) in x
10:30:43 <Cale> which is the usual factorial function
10:30:52 <Cale> yes?
10:31:01 <vegard1992> dear god
10:31:22 <vegard1992> lol
10:31:44 <geheimdienst> alternatively, i found this easier to understand (i.e. possible to understand): fix f = f (fix f)
10:31:45 <Eliel> I can kind of follow that but it still makes no sense what it's useful for.
10:31:49 <newsham> > fac_ (fac_ (fac_ (fac_ undefined))) 3
10:31:50 <Cale> So if we give fix a lambda, it will tie the definition up in a bow for us as if that parameter were a name for a recursive definition
10:31:50 <lambdabot>   6
10:31:55 <geheimdienst> this explains it well: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
10:32:07 <Cale> Eliel: It's a primitive in terms of which all other recursion can be defined
10:32:23 <int-e> geheimdienst: but of course that would lose the sharing (although a clever compiler might recover it)
10:32:26 <newsham> eliel: fix abstracts out the notion of recursion.
10:32:36 <Cale> Eliel: Some compilers will implement all recursion by converting it into usage of fix, and then implement fix separately.
10:33:09 <Cale> > fix (1:)
10:33:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:33:14 <newsham> so you can do things like say "recursively keep doing (1:)"  with a simple expression
10:33:33 <Cale> fix is named such because it finds the "least defined fixed point" of a function that you give it
10:33:43 <newsham> another thing it could be useful for -- if you factor out the recursion from your function, you can replace the recursion, ie to do tracing or memoization or other things like that
10:33:46 <Cale> That is, it finds a value x for which x = f x
10:33:52 <geheimdienst> int-e: possibly so, but the current issue is that people want to understand fix at all, not that people have a solid understanding of it and want to debate fine detail of sharing and whatnot
10:33:57 <Eliel> geheimdienst: thank you, that link explains it nicely :)
10:34:09 <geheimdienst> eliel: you're welcome
10:34:15 <int-e> geheimdienst: fair enough. :)
10:34:20 <geheimdienst> :)
10:34:40 <Eliel> Cale: thank you also :)
10:34:42 <newsham> > fac_ (fac_ (fac_ (fac_ undefined))) 5
10:34:44 <lambdabot>   *Exception: Prelude.undefined
10:34:52 <newsham> > fac_ (fac_ (fac_ (fac_ (fac_ (fac_ undefined))))) 5
10:34:54 <lambdabot>   120
10:34:58 <Cale> newsham: that's a good point
10:34:59 <vegard1992> so what does "!!" mean?(without quotation marks)
10:35:10 <Cale> vegard1992: It's list indexing
10:35:13 <newsham> > "this is a string" !! 3
10:35:14 <lambdabot>   's'
10:35:14 <geheimdienst> > [1..10] !! 4
10:35:15 <lambdabot>   5
10:35:17 <Cale> xs !! n is the nth element of xs
10:35:26 <vegard1992> ahh
10:35:45 <Cale> But be somewhat careful about using that one too much. xs !! n takes O(n) steps to reduce.
10:36:03 <Cale> If you're using !! a lot, lists are probably not the right datastructure.
10:36:14 <geheimdienst> vegard1992: btw, it's customary to write x for "one thing out of a list" and xs for "a list"
10:36:38 <vegard1992> hm alright
10:36:39 <sunfun> good evening
10:36:39 <newsham> where "xs" is read as a plural of x
10:36:56 <Cale> xs is the plural of x ;)
10:36:57 <vegard1992> okay
10:37:36 <geheimdienst> > (\(x:xs) -> x : " / " ++ xs) "lolcats"
10:37:38 <lambdabot>   "l / olcats"
10:37:42 <newsham> cale: although INXS is not the plural of INX
10:37:55 <mm_freak> > fix (([0,1] ++) . liftA2 (zipWith (+)) id tail)
10:37:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:37:57 <Cale> newsham: are you sure it isn't?
10:38:38 <sm> ghc-pkg-supercleaner! nice :)
10:39:22 <geheimdienst> mm_freak: no lykes id. uze moar <*>
10:39:30 <geheimdienst> > ((==) <*> reverse) "radar"
10:39:31 <lambdabot>   True
10:40:21 <mm_freak> what's wrong with id?
10:40:27 <aristid> geheimdienst: applicat has spoken
10:41:18 <mm_freak> > fix (([0,1] ++) . (zipWith (+) <*> tail))
10:41:19 <geheimdienst> mm_freak, i'm just kidding :) i just like to point out that id can often be replaced by <*>
10:41:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:41:24 <mm_freak> there you go
10:41:50 <mm_freak> ok, just that i find the liftA2 variant easier to understand =)
10:42:10 <geheimdienst> yeah, we've gone from "needs 3 years of studying haskell" to "needs 5 years". i'm satisfied
10:42:20 <mm_freak> hehe
10:44:09 <newsham> > fix it
10:44:10 <lambdabot>   not broken
10:44:24 <geheimdienst> > fix id
10:44:28 <lambdabot>   mueval-core: Time limit exceeded
10:47:34 <sunfun> i have to implement the graph type, is it correct to use something like ([Node],[Edges])? Using this structure, i have found a way to make the Dept First Search only by removing edges, marking visited nodes and using a stack for the adjacent nodes. Is there a simple way to do it?
10:48:06 <sunfun> because the input always grow in each step... or not?
10:49:19 <vegard1992> haskell is pretty cool :D
10:49:31 <vegard1992> let fact n = (take n (f(n,n))) !! n-1
10:49:38 <vegard1992> oops
10:49:40 <newsham> excellent, vegard has taken the bait...
10:49:44 <vegard1992> let f(n,c)=n:f(n*(c-1),c-1)
10:49:50 <vegard1992> let fact n = (take n (f(n,n))) !! (n-1)
10:49:59 <geheimdienst> vegard1992: if you start with "> ", lambdabot will listen
10:50:09 <geheimdienst> (also available in private windows)
10:50:16 <hpc> /query lambdabot
10:50:22 <Cale> vegard1992: btw, it's a little bit unusual to use tuples so much as parameters to functions in Haskell. You can just separate the parameters by whitespace
10:50:39 <sunfun> > t: head
10:50:41 <vegard1992> ok
10:50:41 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
10:50:41 <lambdabot>         against inferre...
10:50:43 <hpc> > let twoparams x y = x + y in twoparams 5 15
10:50:44 <lambdabot>   20
10:50:46 <newsham> > f a b c = a + 2 * b + c*c in f 1 2 3
10:50:47 <lambdabot>   <no location info>: parse error on input `='
10:50:50 <Cale> vegard1992: (but you may need to put parens around individual parameters)
10:50:52 <vegard1992> i just got some weird errors earlier
10:50:54 <newsham> > let f a b c = a + 2 * b + c*c in f 1 2 3
10:50:54 <vegard1992> :0
10:50:56 <lambdabot>   14
10:51:14 <saati> what is fix good for?
10:51:17 <vegard1992> like i cant say
10:51:27 <geheimdienst> saati: baffling newbies
10:51:30 <vegard1992> let fib a b = a:fib(b a+b)
10:51:42 <vegard1992> can i say
10:51:50 <vegard1992> let fib a b = a:fib(b,a+b)
10:51:51 <hpc> saati: suppose you have a lambda
10:51:56 <vegard1992> ?
10:52:02 <krey_> hi, how can I make a "type" an instance of monad (as opposed to a data)?
10:52:06 <hpc> saati: you don't want to give it a name, for whatever sylistic reason, but it really needs to be recursive
10:52:15 <hpc> saati: but it can't recurse without knowing its own name
10:52:56 <hpc> saati: in the expression "fix $ \f -> ...", 'f' is the same thing as "fix $ \f -> ..."
10:53:11 <hpc> saati: so you kind of just got a name for your function
10:53:18 <geheimdienst> saati: seriously, i think anything you can do with fix you can also do in other ways. it's just that sometimes you can write it slightly shorter or "cleverer" with fix
10:53:36 <saati> @src fix
10:53:36 <lambdabot> fix f = let x = f x in x
10:53:37 <hpc> saati: this example is highly contrived
10:54:09 <geheimdienst> saati: check this, i find it clearer http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
10:54:40 <fryguybob> krey_: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeSynonymInstances ?
10:55:41 <vegard1992> ok got it now
10:55:49 <vegard1992> let fibs a b = a:fibs b (a+b)
10:55:50 <vegard1992> :-)
10:55:51 <newsham> ?let f recurse n = if n == 0 then 1 else n * recurse (n - 1)
10:55:57 <lambdabot>  Defined.
10:56:05 <newsham> > f undefined 0
10:56:06 <lambdabot>   Ambiguous occurrence `f'
10:56:06 <lambdabot>  It could refer to either `L.f', defined at <local...
10:56:11 <newsham> oopz
10:56:13 <newsham> ?undefine
10:56:27 <geheimdienst> krey_: could you give us a concrete example of what you want to do? i suspect you're looking for "Eq a => SomeMonad a"
10:56:40 <geheimdienst> (because "SomeMonad Eq" doesn't work)
10:57:31 <saati> hpc, geheimdienst thanks, i have to think more about this and it might make some sense
10:57:40 <ion> > (1,2) * (3,4)
10:57:41 <lambdabot>   (3,8)
10:57:45 <ion> What defined that instance again?
10:58:09 <Cale> vector-space
10:58:12 <ion> Thanks
10:58:43 <geheimdienst> ... maybe we should make some kind of hoogle for instances ...
10:59:18 <krey_> geheimdienst, fryguybob: type State st a = st -> (a, st) ... instance Monad State st ...
11:01:39 <ion> You can’t make instances out of type synonyms. Use a newtype: newtype State st a = State (st -> (a, st)). Also, the syntax is instance Monad (State st).
11:06:46 <krey_> ion: but why? I don't want to keep boxing and unboxing ;(
11:07:25 <hpc> krey_: newtypes are identical to their insides at runtime
11:07:43 <hpc> krey_: 'newtype' is just a strongly typed 'type' keyword, more or less
11:08:22 <krey_> hpc: my problem is more of a syntactical nature. i literally don't want to type the words runState and State
11:08:28 <hpc> ah
11:09:01 <fryguybob> @hackage newtype
11:09:01 <lambdabot> http://hackage.haskell.org/package/newtype
11:09:06 <fryguybob> krey_: This might help some.
11:09:44 <newsham> krey: you could make your own "bind" and "return" that arent related to the monad class.
11:09:54 <newsham> that are only applicable to your type decl
11:11:19 <Veinor> what's the best library for doing search-type stuff?
11:11:49 <copumpkin> libgoogle
11:12:45 <krey_> fryguybob: this looks interesting, but I can't seem to understand. F a = st -> (a, st) is a perfectly well-defined functor. why won't haskell let me define it on arrows :(
11:12:50 <Veinor> i have a bunch of chatlogs i want to be able to search, including the ability to both do exact word match and nearby
11:12:56 <Veinor> maybe i should use sphinx
11:13:08 <c_wraith> solr?  lucene?
11:13:15 <copumpkin> Veinor: chrisdone was doing some stuff with searching IRC logs in haskell a while back
11:13:20 <copumpkin> you should ping him when he reappears
11:13:25 <copumpkin> preflex: seen chrisdone
11:13:25 <preflex>  chrisdone was last seen on #haskell 21 hours, 3 minutes and 26 seconds ago, saying: Cale: needs more quine
11:14:37 <rwbarton> krey_: there are good reasons for this which are somewhat tiresome to repeat every time the question comes up. But basically the problem is the type of fmap is (a -> b) -> f a -> f b, and you want to use it at a type (a -> b) -> (s -> (a, s)) -> (s -> (b, s)), and those types do not even unify.
11:14:54 <rwbarton> since (s -> (b, s)) is not of the form f b
11:15:11 <copumpkin> it could be if we allowed arbitrary functions for f
11:15:21 <copumpkin> but then the typechecker would not be able to figure out the function for you
11:15:28 <rwbarton> right, so it'd be useless
11:15:29 <Veinor> it looks like what i want is sphinx
11:15:43 <rwbarton> except in very contrived situations
11:15:51 <copumpkin> sphinxter
11:16:00 <rwbarton> or if you had to specify f explicitly--which is essentially what the status quo does via State/runState
11:16:09 <copumpkin> yeah
11:16:14 <Veinor> or something similar; i think writing my own text earching solution in haskell is a bad idea
11:16:20 <hpaste> “Mukesh Tiwari” pasted “Learning Haskell Class” at http://hpaste.org/54243
11:16:55 <keep_learning> hello all
11:17:26 <krey_> rwbarton, copumpkin: so we are giving up nice functors for type inference? I don't understand
11:17:27 <keep_learning> Could some one please tell me what is wrong with code http://hpaste.org/54243
11:17:43 <copumpkin> krey_: not just type inference, but unification
11:18:17 <copumpkin> but yeah, the type system can't do the impossible :P
11:18:22 <rwbarton> giving up type inference is tantamount to giving up "nice functors"
11:18:49 <krey_> copumpkin: unification is when you're checking if two types are the same?
11:19:08 <newsham> klearn: you have called two differnt things "Circle" and you're bringing them both into the same scope without any qualification.
11:19:14 <newsham> perhaps you want "import qualified"?
11:19:18 <newsham> to differentiate the two?
11:19:25 <hpc> krey_: unification is finding the "intersection" of two types, if that makes sense
11:19:43 <hpc> krey_: unifying (Int, b) with (a, String) would yield (Int, String)
11:20:15 <rwbarton> together with the assignments {left hand side b = String, right hand side a = Int}
11:20:26 <hpc> yeah, plus that
11:20:34 <shachaf> Unifying (Int,b) with (a,String) would yield the result "Yes."
11:20:36 <keep_learning> newsham, thank you
11:20:43 <rwbarton> which could be relevant to instance selection
11:20:54 <copumpkin> there are fancier cases
11:21:04 <krey_> hpc, rwbarton: so how does explicit boxing/unboxing aid unification?
11:21:13 <copumpkin> things like (Int, b) and (x, x) yielding (Int, Int) and x = b = Int
11:21:35 <rwbarton> something of the form 'f b' can only unify with the application of a (possibly partially applied) constructor to a type
11:21:43 <copumpkin> krey_: say I have Maybe (Maybe (Maybe Int)) and need to unify it with f (g Int)
11:21:52 <keep_learning> newsham, you mean some thing like this import qualified C.D ( Circle(..) )  as D
11:21:58 <hpc> krey_: not sure how unification comes into it, but instance selection becomes basically impossible
11:22:09 <copumpkin> krey_: what's the solution there?
11:22:21 <krey_> copumpkin: well could be 2 things
11:22:28 <krey_> is that the problem?
11:22:30 <copumpkin> why just two?
11:22:34 <monochrom> oh, we're running into higher-order unification?
11:22:37 <hpc> krey_: the functor instance for (st -> (a, st)) is totally different from the functor instance for plain old functions
11:22:40 <newsham> keeP right.
11:22:43 <krey_> copumpkin: right!
11:22:49 <newsham> then you can do   D.Circle when you want D's circle
11:22:56 <newsham> and just Circle when you want the locally defined one
11:23:06 <newsham> (alternately you could call them slightly differen things to start with)
11:23:12 <copumpkin> krey_: for some cases of that problem, there might be arbitrarily many possible solutions. You're searching for functions from types to types, and searching functions is tricky :)
11:23:35 <rwbarton> for example another "solution" is f _ = Maybe (Maybe (Maybe Int)) and g _ = anything
11:23:41 <hpc> fmap f (statevalue) = \state -> let (v, st') = statevalue state in (f v, st')
11:23:47 <rwbarton> those f and g are functors too
11:23:50 <hpc> fmap f (function) = f . function
11:23:56 <krey_> copumpkin: I see. so we box things up so that the typechecker/compiler knows which instance to use?
11:24:21 <copumpkin> krey_: yeah, so it can avoid even having to think about higher-order unification (what that's called)
11:24:29 <copumpkin> you're not allowed to write type functions
11:24:35 <EvanR-work> Sum and Product monoid instance
11:24:38 <copumpkin> at least, not in an unrestricted manner
11:24:48 <jtaborda> checking tryhaskell.org tutorial
11:25:02 <copumpkin> EvanR-work: um, First and Last monoid instance!
11:25:35 <rwbarton> and this is why you can't write   instance Functor (/\a -> st -> (a, st))  or anything like it (where /\ is supposed to denote type-level lambda)
11:25:37 <EvanR-work> i want Maybe Ord instance that puts Nothing above everything
11:25:52 <copumpkin> EvanR-work: there's a Down newtype
11:25:57 <krey_> copumpkin, rwbarton: makes sense, thank you
11:26:11 <EvanR-work> Down eh
11:26:21 <rwbarton> Down (Maybe (Down Whatever))
11:26:23 <rwbarton> ugh
11:26:28 <copumpkin> not sure who export sit
11:26:32 <copumpkin> it looks like it's in GHC.Exts
11:26:38 <hpc> rwbarton: only need Down on the outside
11:26:40 * krey_ is off to do some newtyping...
11:26:40 <rwbarton> @hoogle Dual
11:26:41 <lambdabot> Data.Monoid Dual :: a -> Dual a
11:26:41 <lambdabot> Data.Monoid newtype Dual a
11:26:41 <lambdabot> Data.Monoid getDual :: Dual a -> a
11:26:41 <shachaf> Yes, I think it's GHC.Exts.
11:26:44 <EvanR-work> just Down (Maybe X) would be enough
11:26:48 <shachaf> Part of ComprehensiveComprehensions.
11:26:57 <rwbarton> oh that's not the one
11:27:01 <hpc> rwbarton: unless you want the inside double-reverse-ordered
11:27:07 <copumpkin> shachaf: I was wondering if it was anywhere more standard
11:27:09 <rwbarton> which I imagined you would
11:27:19 <rwbarton> @hoogle Op
11:27:19 <shachaf> @ty GHC.Exts.Down . fmap GHC.Exts.Down
11:27:19 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
11:27:20 <lambdabot> GHC.IO.Handle.FD openBinaryFile :: FilePath -> IOMode -> IO Handle
11:27:20 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
11:27:20 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> GHC.Exts.Down (f (GHC.Exts.Down a))
11:27:34 <shachaf> copumpkin: Not as far as I know.
11:27:46 <copumpkin> someone should propose sticking it into Data.Ord
11:28:05 <rwbarton> possibly easier solution: data BigMaybe a = Just' a | Nothing' deriving Ord
11:28:30 <EvanR-work> copumpkin: how about sticking it into Data.Ord
11:28:38 <rwbarton> er, that BigMaybe name doesn't make as much sense as I thought it would...
11:28:42 <copumpkin> EvanR-work: you contradicting me? :P
11:28:43 <rwbarton> BigNothingMaybe
11:28:48 <copumpkin> [02:42:29 PM] <copumpkin> someone should propose sticking it into Data.Ord
11:28:58 <EvanR-work> i just did
11:29:17 <copumpkin> ah okay
11:29:19 <hpc> data Cheese a = Swiss a | Mozzarella
11:29:30 <hpc> because holes, get it? lololol
11:29:46 <EvanR-work> o_O
11:29:49 <rwbarton> sadly, I do get it.
11:30:02 * hpc hates himself now
11:31:12 <EvanR-work> only now?
11:31:26 <hpc> :P
11:32:04 <hpaste> “Mukesh Tiwari” annotated “Learning Haskell Class” with “Learning Haskell Class (annotation)” at http://hpaste.org/54243#a54244
11:32:06 <shachaf> hpc: Are you going to construct a cheese zipper?
11:32:32 <hpc> shachaf: no, but i will write the cheese burrito
11:32:35 <hpc> er, monad
11:32:41 <keep_learning> newsham, i am still getting error.
11:33:01 <keep_learning> newsham, I tried to import but looks like i am missing something
11:33:26 <EvanR-work> see what happens if you name stuff normal words like arrow and zipper, no one questions it
11:33:27 <newsham> you're importing it twice, once qualified and once unqualified
11:33:33 <EvanR-work> no 'what is an arrow, really'
11:33:45 <newsham> the unqualified import is giving you problems
11:33:58 <EvanR-work> no burrito tutorials
11:36:04 <mm_freak> there seems to be only one common metaphor for arrows
11:36:15 <mm_freak> the machine/conveyor stuff
11:36:26 <mm_freak> and i didn't find it helpful at all
11:36:36 <wlangstroth> mm_freak: astronaut burrito factories?
11:37:12 <EvanR-work> now that i finally 'get' monads (as of two years ago), what are uniqueness types, fettuccini alfredo?
11:37:43 <hpaste> “Mukesh Tiwari” annotated “Learning Haskell Class” with “Learning Haskell Class (annotation) (annotation)” at http://hpaste.org/54243#a54246
11:37:46 <EvanR-work> i still dont get those ;)
11:37:53 <wlangstroth> the analogues actually confused me more than just using monads
11:37:55 <shachaf> EvanR-work: Uniqueness types and monads don't really have much to do with each other.
11:38:18 <EvanR-work> shachaf: so im on the right track, its like the relationship between burritos and pasta
11:38:41 <wlangstroth> EvanR-work: I'm thinking salad
11:39:04 <keep_learning> newsham, when i commented the --import C.D ( Circle(..) , first , second , radius ) then how to import functions and value constructor from D
11:39:33 <mm_freak> EvanR-work: also uniqueness types aren't really relevant to haskell
11:40:10 <newsham> klearning: you can import those qualified if you wish, or you can just let the import import everything
11:40:43 <EvanR-work> mm_freak: neither is lisp, scala, java, and whatever else we discuss here
11:41:00 <EvanR-work> besides i was joking
11:41:59 <mm_freak> EvanR-work: actually those are more relevant =)
11:42:05 <EvanR-work> yeah, right
11:42:15 <keep_learning> newsham, Could you please change the code which compiles
11:43:09 <slack1256> guys could you follow me in this reasoning?
11:43:22 <newsham> "import qualified C.D (Circle(..) , first , second , radius) as D" ?
11:43:22 <slack1256> supose we have fab :: Int -> Int
11:43:31 <newsham> or merely "import qualified C.D as D" ?
11:43:47 <shachaf> newsham: Is there much point in using both "qualified" and an import list?
11:43:58 <newsham> shachaf: he's got a local Circle
11:44:05 <newsham> and he wants to import Circle from C.D as well
11:44:11 <slack1256> does "(map fab [12,15,11,2]) !! 3" compute fab 12 and fab 15?
11:44:13 <shachaf> I think you need two import lines for that.
11:44:20 <slack1256> or just express them and never compute them?
11:44:21 <shachaf> slack1256: Nope.
11:44:22 <newsham> shachaf: http://hpaste.org/54243#a54244
11:44:53 <shachaf> Well, it *could* start computing them if it felt like it, I guess.
11:45:00 <shachaf> But generally it doesn't.
11:45:08 <EvanR-work> > (map id [undefined, undefined, 11, 2]) !! 3
11:45:09 <lambdabot>   2
11:45:10 <slack1256> shachaf, that what i thought, but http://haskell.org/haskellwiki/Memoization
11:45:29 <newsham> klearning: is there a reason you're defining the same names in a data type in one module and in a class in another module?
11:45:30 <slack1256> but says otherwise, specially the example with the "worst fibonnacci algorithm"
11:45:48 <parcs_> does lambdabot have a newtype in scope?
11:45:49 <monochrom> > map id [undefined, undefined, undefined, 0] !! 3
11:45:50 <lambdabot>   0
11:46:06 <shachaf> slack1256: The phrase "worst fibonacci algorithm" doesn't appear anywhere on the page.
11:46:27 <slack1256> try "slow_fib"
11:46:30 <parcs_> oh right, Mu
11:46:36 <keep_learning> newsham, no  , nothing special
11:47:18 <parcs_> > case undefined of In _ -> 0
11:47:19 <lambdabot>   0
11:47:26 <shachaf> slack1256: The page doesn't seem to be saying anything of the sort.
11:47:32 <slack1256> let fab n = case n of {0 -> 0; 1 -> 1; _ -> fab (n-2) + fab (n-1)}
11:47:40 <keep_learning> newsham, just trying to learn
11:47:43 <slack1256> > fab 5
11:47:44 <lambdabot>   Not in scope: `fab'
11:48:12 <monochrom> slack1256, "(map fab [12,15,11,2]) !! 3" is vastly different from setting xs to [0, 1, xs!!0 + xs!!1, xs!!1 + xs!!2, xs!!2 + xs!!3] !! 3
11:48:32 <shachaf> slack1256: Note that if "fab 11" is defined in terms of (thatList !! 3) if fab is defined in terms of thatList.
11:48:38 <monochrom> err, setting xs to [0, 1, xs!!0 + xs!!1, xs!!1 + xs!!2, xs!!2 + xs!!3] and then asking for xs!!3
11:50:04 <keep_learning> newsham, import qualified C.D ( Circle(..) , first , second , radius )  as D  also getting error
11:50:04 <monochrom> evaluating xs!!3 clearly causes evaluating xs!!1+xs!!2 clearly causes evaluating...
11:50:32 <newsham> http://hpaste.org/edit/54243
11:50:38 <newsham> thats working for me
11:51:00 <EvanR-work> > fix error
11:51:01 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:51:56 <keep_learning> newsham, you are not getting any error ?
11:52:44 <newsham> it worked for me with my own made up version of C/D.hs (which you didnt provide)
11:53:01 <copumpkin> > fix show
11:53:02 <newsham> (what i put in the hpaste works for me)
11:53:03 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:53:05 <newsham> > fix it
11:53:07 <lambdabot>   Not in scope: `it'
11:53:14 <newsham> ?let it _ = text "not broken"
11:53:15 <lambdabot>  Defined.
11:53:15 <EvanR-work> > fix break
11:53:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:53:19 <newsham> > fix it
11:53:23 <lambdabot>   mueval-core: Time limit exceeded
11:53:37 <EvanR-work> > fix fix
11:53:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
11:53:50 <newsham> > fix it
11:53:53 <lambdabot>   not broken
11:54:36 <EvanR-work> when is haskell getting support for infinite types
11:54:54 <keep_learning> newsham, i did not get you " it worked for me with my own made up version of C/D.hs (which you didnt provide) "
11:54:56 <byorgey> EvanR-work: it already has support for infinite types.  or do you mean equirecursive types?
11:55:08 <keep_learning> newsham, i have src folder in which
11:55:14 <EvanR-work> it just said it cant construct them
11:55:22 <EvanR-work> doesnt sound very supported
11:55:43 <keep_learning> newsham, there is folder name C and file name C.hs
11:56:04 <keep_learning> newsham, and inside C folder i have file D.hs
11:56:23 <keep_learning> and i am trying to load C.hs
11:56:26 <byorgey> EvanR-work: it can't construct them directly.  But e.g.  [a] === Either () (a,[a]) === Either () (a, Either () (a, [a])) === ...
11:56:30 <newsham> klearning: i made up my own C/D.hs and I took your C.hs and modified it and loaded it into ghci without error.  the C.hs I used is at http://hpaste.org/edit/54243
11:56:32 <byorgey> EvanR-work: where === denotes isomorphism
11:57:10 <slack1256> @let fab n = case n of {0 -> 0; 1 -> 1; n -> fab (n-2) + fab (n-1)}
11:57:11 <lambdabot>  <local>:2:0:
11:57:11 <lambdabot>      Warning: Pattern match(es) are overlapped
11:57:11 <lambdabot>               In...
11:57:38 <slack1256> @let fab n = case n of {0 -> 0; 1 -> 1; _ -> fab (n-2) + fab (n-1)}
11:57:39 <lambdabot>  <local>:2:0:
11:57:39 <lambdabot>      Warning: Pattern match(es) are overlapped
11:57:39 <lambdabot>               In...
11:57:44 <byorgey> EvanR-work: you can make a type satisfying a = [a] (as long as you are willing to replace = with isomorphism) like so:  data Foo a = Foo [Foo a]
11:58:25 <slack1256> > fab 5
11:58:27 <lambdabot>   5
11:58:30 <byorgey> the constructor Foo witnesses the isomorphism.
11:58:34 <keep_learning> newsham, can you post your C.hs and D.hs , sorry for this many question but i am trying to figure out this
11:58:51 <keep_learning> newsham, but could not succeed .
11:58:58 <rwbarton> as I understand it it would be easy to remove the restriction forbidding equirecursive types, but in practice it would have a bigger cost through delaying type errors or making type errors harder to understand than the gain from actually using equirecursive types.
12:00:26 <slack1256> shachaf: okay this is what i don't understand, why is "(map fab [1..] !!) 40" faster than "fab 40" when haskell shouldnt evaluate [1..39]
12:00:44 <shachaf> slack1256: Because fab 40 is defined in terms of previous elements of that list.
12:00:55 <slack1256> but those element aren't evaluated
12:01:01 <shachaf> Sure they are.
12:01:04 <shachaf> "fab 40" evaluates them.
12:01:19 <slack1256> but just when the list gets to fab 40
12:01:22 <byorgey> rwbarton: oh, interesting.
12:01:23 <slack1256> before that it doesn't
12:02:01 <shachaf> slack1256: When you try to evaluate the thunk at position 40 of that list, it, in turn, evaluates the thunks at positions 39 and 38.
12:02:33 <newsham> i posted my C.hs
12:02:52 <newsham> i gave you the url twice.. were you not able to see the file?
12:02:56 <edwardk> we have officially reached capacity for hac boston. now we're shooting for more space
12:03:20 <newsham> hmm.. lemme try pasting it again
12:03:24 <slack1256> shachaf: oh, then (!!) n force the elements in [1..n] to get n
12:03:31 <shachaf> slack1256: No.
12:03:36 <edwardk> soon there will be multiple rooms of haskell hacking goodness!
12:03:38 <keep_learning> newsham, i was getting my code C.hs in that url
12:03:39 <edwardk> muahaha
12:03:49 <shachaf> The definition of "fab 40" is "list !! 38 + list !! 39"
12:03:51 * slack1256 scratch head
12:04:06 <shachaf> So when you try to evaluate "fab 40", *then* it indexes into the list and evaluates those.
12:04:08 <newsham> http://hpaste.org/54248
12:04:17 <newsham> klearnign: sorry about that
12:04:53 <slack1256> but fab only referece to itself ( a function which takes a Int) not to a list
12:05:43 <keep_learning> newsham, thank you , i really appreciate your help.
12:05:53 <newsham> np
12:07:24 <keep_learning> newsham, one more thing.
12:07:44 <keep_learning> newsham, when i am enabling the type signature in instance then its getting error
12:08:22 <newsham> you already gave it a type signature when you defined the class
12:08:42 <keep_learning> newsham, so no need to give it in instance ?
12:09:00 <newsham> yah, it already knows what it is by filling in "i" with "D.Circle"
12:09:29 <keep_learning> newsham, thanks again :)
12:10:15 <EvanR-work> slack1256: i think he was talking about a scenario where fab was not so simple
12:12:23 <mizu_no_oto> Why isn't Data.Set a Functor?
12:13:09 <mizu_no_oto> I can't imagine that it would violate id == fmap id, so does it violate  fmap (f . g)  ==  fmap f . fmap g?
12:13:13 <EvanR-work> something about the Ord constraint?
12:13:32 <rwbarton> right, the type of fmap is too general
12:13:43 <byorgey> mizu_no_oto: it's not that it violates any constraints, you simply can't write it
12:14:22 <byorgey> since fmap requires you to be able to change 'Set a' into 'Set b' for *any* type b, but you can only construct Sets over types with an instance of Ord
12:14:29 <slack1256> evanR-work: yeah, maybe.
12:14:35 <mizu_no_oto> Ah
12:14:51 <copumpkin> you could construct a functor if you were willing to assume that you only fmapped order-preserving functions over it
12:15:02 <byorgey> mizu_no_oto: also, fun fact, if an implementation of fmap satisfies  id == fmap id, then it automatically also satisfies  fmap (f . g) == fmap f . fmap g
12:15:20 <slack1256> shachaf: thanks anyways :).
12:15:38 <shachaf> slack1256: ?
12:15:43 <shachaf> slack1256: "fab" *does* reference a list.
12:15:50 <shachaf> Because it's defined in terms of indexing into a list.
12:15:59 <slack1256> > fab 5
12:16:00 <mizu_no_oto> So that holds true in general?  Only things with constructors that don't force the arguments to be of a certain typeclass can be functors?
12:16:01 <lambdabot>   5
12:16:11 <slack1256> no list, just recursive call of fab
12:16:12 <newsham> would be nice if things like "ord" could tag along for the ride with things like "fmap"
12:16:33 <byorgey> newsham: and they can, now that we have Constraint Kinds
12:16:43 <byorgey> if you define the Functor class with an associated constraint
12:16:44 <newsham> i have not heard of such things.. neat.
12:16:45 <shachaf> byorgey: I don't like RFunctor etc.
12:16:59 <shachaf> newsham: http://blog.omega-prime.co.uk/?p=127
12:17:02 <newsham> so you can abstract over constraints now?
12:17:06 <byorgey> newsham: yep
12:17:19 <shachaf> newsham: Coming to a GHC 7.4 near you.
12:17:47 <newsham> will there be an accompanying cleanup of functor/categor/arrow/monad/applicative?
12:18:01 <byorgey> newsham: eventually, I hope
12:18:04 <byorgey> but not right away
12:18:09 <newsham> nifty
12:18:17 <mizu_no_oto> Also, do you guys think that a decent description of the essence of fmap is "it lifts a function into the domain of the functor"?
12:18:20 <shachaf> Accompanying cleanup of what kind?
12:18:39 <newsham> so can you add in more constraints?
12:18:42 <shachaf> I don't know if RFunctor should replace Functor. I'm suspicious of it.
12:18:53 <byorgey> mizu_no_oto: sure
12:19:03 <rwbarton> properly speaking the "domain of the functor" should be Hask
12:19:06 <rwbarton> or *
12:19:16 <mizu_no_oto> And is there any simple example of a type that cannot be a functor because there's no way to satisfy the functor laws?
12:19:18 <shachaf> Without a constraint you have some guarantees about fmap's behavior. With a constraint it can potentially do anything at all.
12:19:41 <copumpkin> mizu_no_oto: newtype Pred a = Pred (a -> Bool)
12:19:45 <shachaf> mizu_no_oto: "Foo a", where newtype Foo a b = Foo (b -> a)
12:19:52 <shachaf> Or that. :-)
12:19:59 <copumpkin> Pred = Foo Bool
12:20:03 <shachaf> Yep.
12:20:17 <byorgey> rwbarton: I don't think mizu_no_oto was using "domain" in that technical sense.
12:21:22 <newsham> no functor for Not? :)
12:21:30 <shachaf> Not?
12:21:36 <shachaf> Not a = a -> Void?
12:21:55 <copumpkin> no, but there's a functor for NotNot
12:22:10 <newsham> shachaf: or similar.   forall b . a -> b
12:22:25 <EvanR-work> NotNot
12:22:28 <EvanR-work> whos there?
12:22:30 <dmwit> cofmap :: (a -> b) -> Not b -> Not a
12:22:43 <shachaf> coughmap
12:22:51 <EvanR-work> coughmap who
12:23:04 <newsham> ?djinn Not (Not (Not a)) -> Not (Not a)
12:23:05 <lambdabot> -- f cannot be realized.
12:23:16 <shachaf> @djinn Not (Not (Not a)) -> Not a
12:23:16 <dmwit> ?djinn Not (Not (Not a)) -> Not a
12:23:17 <lambdabot> f a b = void (a (\ c -> c b))
12:23:17 <lambdabot> f a b = void (a (\ c -> c b))
12:23:46 <shachaf> @djinn-add type (a :. b) x = a (b x)
12:23:46 <lambdabot> Cannot parse command
12:24:09 <dmwit> ?djinn-add data (a :. b) x = O (a (b x))
12:24:09 <lambdabot> Cannot parse command
12:24:23 <dmwit> ?djinn-add data O a b x = O (a (b x))
12:24:32 <dmwit> shachaf: Okay, what comes next?
12:25:00 <shachaf> dmwit: I just wanted a nicer infix syntax for Not (Not (Not x))...
12:25:18 <dmwit> O
12:25:20 <newsham> Not `O` Not `O` Not
12:25:22 <copumpkin> ?djinn-add data Thrice f x = f (f (f x))
12:25:23 <lambdabot> Cannot parse command
12:25:29 <EvanR-work> infix sucks
12:25:39 <dmwit> copumpkin: Needs a constructor. =)
12:25:43 <shachaf> @djinn-add data Thrice f x = Thrice (f (f (f x)))
12:25:59 <shachaf> @djinn Thrice Not x -> Not x
12:25:59 <lambdabot> Interrupted (IntMap.find: key 2 is not an element of the map)
12:26:01 <dmwit> ?djinn Thrice Not x -> Not x
12:26:02 <lambdabot> Interrupted (IntMap.find: key 2 is not an element of the map)
12:26:09 <dmwit> whoopsh
12:26:10 <newsham> you broksed it
12:26:15 <newsham> nasty hobbitses
12:26:33 <EvanR-work> its leaking, quick plug the hole
12:31:39 <EvanR-work> i dont understand this, hGetContents :: Handle -> IO ByteString "As with hGet, the string representation in the file is assumed to be ISO-8859-1."
12:31:57 <EvanR-work> why does the encoding matter, wont it get the raw bytes
12:33:05 <dmwit> EvanR-work: I don't get it either. Maybe that's from a time when people were abusing ByteString as a representation of text.
12:33:24 <EvanR-work> hGet also doesnt mention that
12:33:30 <EvanR-work> maybe its stale docs
12:34:13 <rwbarton> is that the documentation from Data.ByteString.Char8?
12:34:17 <newsham> evanr: is that for Char8?
12:34:21 <newsham> cause for Char8 it matters
12:34:25 <EvanR-work> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html
12:34:51 <rwbarton> well that is a little odd
12:35:47 <EvanR-work> copy pasta from System.IO
12:35:52 <EvanR-work> ;)
12:37:00 <roconnor> edwardk: today I learned that a container is a dependent sum of napierian conatiners (a.k.a representable functors) i.e. a container is of the from \X : Type . Sigma s : S. P s -> X; and that every strictly positive functor is isomorphic to some container.
12:37:37 <edwardk> sounds reasonable
12:38:15 <copumpkin> indexed containers! http://www.ioc.ee/~tarmo/tsem08/morris-slides.pdf
12:38:20 <roconnor> edwardk: to represent a inductive type, you take it's strictly postive functor, put it into container form, and use the two pieces to for a W-type, W s: S. P s.
12:38:36 <roconnor> *to form
12:38:49 <edwardk> roconnor: ah, guess that answers your question from the other day then
12:38:55 <roconnor> yep
12:39:27 <roconnor> so W-types are related to conainers, but not directly to napierian containers
12:39:40 <edwardk> *nods*
12:50:17 <KitB> Has anyone actually written a kernel module in haskell?
12:50:25 <KitB> Or is it just *possible* to do so?
12:50:41 <EvanR-work> gc in the kernel!
12:50:58 <KitB> http://haskell.org/haskellwiki/Kernel_Modules
13:04:04 <smoge> could someone point to a implementation code of cellular automata and l-systems?
13:05:11 <gtirloni> wow!
13:08:14 <smoge> ?
13:51:06 <dmwit> <3 GHC's verbose errors
13:55:58 <shachaf> dmwit: Just try boost sometime!
13:56:18 <pshrmn> Is there a way to avoid using ``pack "str" '' each time you want to use constant text?
13:57:29 <shachaf> pshrmn: Yes -- -XOverloadedStrings
13:57:44 <geheimdienst> pshrmn: i think you're looking for the OverloadedStrings extension. you just need to import the instances (i'm sure there are some for Text) and ghc automatically does the right thing with any "blah"
13:58:16 <pshrmn> schacha: thanks
14:02:54 <augur> what the hell happened
14:03:01 <augur> why did this place die at 4pm est?
14:03:02 <augur> :|
14:06:34 <edwardk> i do wish that defaulting worked better with overloaded strings, etc.
14:07:41 <monochrom> -XGeneralizedDefaulting
14:07:57 <edwardk> i wonder if it would be beneficial to add a new "class Defaultable t" to the list of single parameter type classes that ghc treats as special in its extended defaulting rules
14:10:57 * geheimdienst once made an "s ~ String => IsString (IO s)", an "s ~ String => IsString ([String] -> IO s)", and two more instances like it. when you screwed up with all four imported, error messages were ... difficult to figure out
14:11:18 <edwardk> hah
14:14:00 <geheimdienst> as i recall ghc's messages were like "you didn't do enough on this line", referring to 3 lines down from the actual place of screwup
14:14:02 <monochrom> {-# LANGUAGE GeneralizedDefaulting #-}  default Monad (IO, ContT r IO, LogicT IO)
14:15:49 <raspy_> > let x = (id :: forall a. a -> a) in let (y :: forall a. a -> a) = x in y
14:15:50 <lambdabot>   Inferred type is less polymorphic than expected
14:15:50 <lambdabot>    Quantified type variable...
14:17:15 <lispy> That particular error message always got to me
14:17:15 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:17:43 <lispy> edwardk: re: hopengl requests, bring 'em on :)
14:17:59 <lispy> edwardk: what do you use it for these days? (or wish you could use it for)
14:18:17 <edwardk> lispy: i stopped using it because i couldn't easily work around the performance hit ;)
14:18:23 <raspy_> > let (x :: forall a. a -> a) = id in x
14:18:24 <lambdabot>   Inferred type is less polymorphic than expected
14:18:24 <lambdabot>    Quantified type variable...
14:18:44 <raspy_> zuh?
14:18:57 <lispy> edwardk: the one you created a bug report for already?
14:18:59 <edwardk> i do a fair bit of work on realtime bidirectional pathtracing/metropolis light transport, but thats done through directcompute and cuda at present
14:19:02 <edwardk> yeah
14:19:32 <lispy> edwardk: oh, we should collaborate at some point.  I've been teaching myself about that stuff, with the goal of writing a simulation in opencl
14:19:34 <edwardk> the other issue is the fact that the hopengl shader api is completely useless
14:20:09 <edwardk> i think i mentioned it to the mailing list
14:20:54 <edwardk> the main problem i have with the way it manages shaders is that it tries to magically juggle a list of them behind the scenes. if you have a lot of shaders and make up new ones one at a time, that API changesthe asymptotics if your code!
14:21:03 <lispy> edwardk: yeah hopengl (as contrasted with opengl-raw) seems to be a very lacking
14:21:50 <_Mikey> OMG
14:21:51 <_Mikey> OMG
14:21:51 <_Mikey> OMG
14:21:54 <_Mikey> Guys!!!
14:21:57 <_Mikey> it compiles
14:22:22 <augur> edwardk: you know anything about existing databases?
14:22:33 <lispy> edwardk: I doubt I'll be hacking on those bindings much this month, but I may get some time in December
14:22:53 <edwardk> lispy: one of my current projects is a little distributed GPGPU DSL through opencl/cuda. i've been debating about adding opengl shader support, but the execution model would be a huge step backwards
14:22:56 <lispy> edwardk: So I really appreciate the bug reports.  It helps me understand what others need (instead of just what I want)
14:22:58 <edwardk> augur: you could say that
14:23:31 <edwardk> _Mikey: gratz =)
14:23:39 <_Mikey> Thanks man!
14:23:45 <augur> edwardk: are there any good, efficient logic databases?
14:23:47 <_Mikey> very simple stuff
14:23:50 <lispy> edwardk: I'm shooting for a fixed time release cycle until I deem things stable again.
14:24:06 <edwardk> augur: depends on your needs. you might look at something like bddbddb or logicblox
14:24:11 <_Mikey> but I think I now grasp basic self defined types and accessor functions :)
14:24:12 <augur> k
14:24:13 <lispy> Like, maybe releases every 3 or 6 months?
14:24:15 <edwardk> augur: but in general think datalog
14:24:43 <edwardk> lispy: sounds good. another thing that'd be nice is making sure the opencl bindings and the opengl bindings are compatible
14:24:57 <edwardk> that is probably the biggest thing you could do for me to keep hopengl and its ilk relevant to me ;)
14:25:06 <lispy> edwardk: oh boy.  You mean all 5 opencl bindings, none of which work correctly standalone :)
14:25:34 <raspy_> does anyone have any idea about this bizzarity?
14:25:36 <lispy> edwardk: Yeah, there are platform specific api functions to allow opengl/opencl interop.  Those have no bindings yet :(
14:25:37 <edwardk> i've yet to pick one or replace it with my own. ;)
14:25:38 <raspy_> > let (x :: forall a. a -> a) = id in x
14:25:39 <lambdabot>   Inferred type is less polymorphic than expected
14:25:40 <lambdabot>    Quantified type variable...
14:25:48 <EvanR-work> if the program crashes some time after writing to a handle, will the file end up missing that data?
14:25:57 <EvanR-work> possibly?
14:25:58 <edwardk> all my opencl/cuda/etc work thus far as been off in c++
14:26:13 <lispy> just a sec, I have to go
14:26:42 <edwardk> lispy: in addition to platform specific the core opencl api specifies some interop machinery
14:26:48 <_Mikey> :o
14:26:55 <_Mikey> I want to do cuda in Haskell
14:28:19 <jaapweel> I wrote a multithreaded program that keeps taking up exactly 100% CPU, according to top, even though the box has 16 cores. Is there something that prevents the GHC runtime from using multiple cores?
14:28:56 <EvanR-work> jaapweel: you have to specify how many cpus to use on the command line when you run the program
14:29:13 <jaapweel> EvanR-work: Thanks, that would do it.
14:29:34 <Saizan> jaapweel: compiled with -threaded ?
14:29:38 <geheimdienst> jaapweel: i think the option you need is +RTS -N
14:29:42 <augur> edwardk: hmm.. datalog seems to dislike complex terms for arguments. this isnt so hot -- linguistics has trees :(
14:29:46 <augur> but maybe thats ok
14:29:48 <jaapweel> No, the threads are manually started with forkIO
14:29:55 <jaapweel> I thought -threaded was for "auto-threading" unthreaded code.
14:30:10 <EvanR-work> no way
14:30:26 <EvanR-work> what do you think this is, star trek
14:30:49 <jaapweel> There were papers about that some time ago.
14:31:04 <Saizan> jaapweel: nope, -threaded links in the threaded runtime, which is needed to use multiple OS threads for concurrency
14:31:14 <jaapweel> If you have a complex computation that's fully fnuctional, you can ship parts of it off to several cores, and it can be done automatically since there's no cooordination.
14:31:23 <jaapweel> But that's not what -threaded does, apparently, and my mystery is thus solved.
14:31:29 <jaapweel> Thanks all.
14:31:56 <parcs_> jaapweel: i think you're talking about automatic parallelism
14:32:13 <parcs_> there is a distinction between concurrency and parallelism
14:32:22 <EvanR-work> there does need to be coordination if the answers are gonna be used
14:33:01 <jaapweel> Anyhow, I figured out I need to pass -threaded to the compiler and +RTS -N8 to the program and it does what I want!
14:33:47 <parcs_> jaapweel: are you not using ghc 7.x?
14:34:02 <jaapweel> Doesn't look like it.
14:34:07 <jaapweel> 6.12.1, it says
14:35:26 <hpaste> Mikey pasted “AntsInSpace” at http://hpaste.org/54253
14:35:26 <Saizan> ghc doesn't offer a way to automatically parallelize even pure code, but there are a few fairly lightweight ways
14:35:33 <jaapweel> I see.
14:35:36 <_Mikey> guys
14:35:45 <edwardk> augur: raw datalog does. but there are datalog derivatives that allow for sets, lists, etc.
14:35:46 <_Mikey> ich habe ein Frage
14:35:53 <_Mikey> I have a question
14:36:02 <alistra> english plz
14:36:15 <edwardk> augur: in particular look at the work joe hellerstein has been doing on daedalus and bloom
14:36:19 <_Mikey> if I have an ant
14:36:26 <_Mikey> as a type
14:36:39 <_Mikey> and I've bound values to a instance of this type
14:36:50 <_Mikey> but I now want to move the ant
14:37:04 <_Mikey> in Haskell would this require a whole new ant?
14:37:30 <alistra> yes, haskell has immutable data structures
14:37:37 <alistra> but it can be optimized out i presume
14:37:42 <alistra> when you compile it
14:37:43 <rwbarton> just like if you have a number like 3, and you want to add 1, you need a whole new number (4)
14:37:59 <_Mikey> hmm
14:38:01 <EvanR-work> no, 3.value += 1
14:38:12 <EvanR-work> 4
14:38:18 <_Mikey> that makes sense I guess
14:38:41 <_Mikey> I sort of guess this was going to be the case
14:38:49 <_Mikey> it just feels like the code will be huge
14:38:59 <_Mikey> if I'm creating new things all the time.
14:39:12 <EvanR-work> luckily you dont have to malloc everywhere
14:39:44 <alistra> _Mikey: there's a trick with immutable structures
14:39:47 <alistra> you can share them
14:40:02 <alistra> when you have a list with alternative begginings, you can share the tail
14:40:21 <alistra> if you have a list with alternative last element, you have to copy everything :(
14:40:44 <EvanR-work> ByteStrings dont suffer from that! \o/
14:41:02 <EvanR-work> shares the middles
14:41:26 <geheimdienst> _Mikey: from glancing at your code, i'd recommend you focus more on the functions. haskell is a functional language after all. don't start by thinking too much about what data structures you need
14:41:46 <geheimdienst> start by writing some functions and then afterwards see what data structures you need to support them
14:42:06 <EvanR-work> er the type of a function looks like A -> B so you need to know mainly the A and B >_>
14:42:11 <SgeoN1> Are pattern guards usable for the same sort of things that view patterns are?
14:42:26 <alistra> moveUp (Location x y) = Location x (y+1) -> moveUp (Location x y) = Location { y = y + 1 }
14:42:31 <alistra> you can do it like that :P
14:45:11 * SgeoN1 vaguely laughs at y = y + 1
14:45:30 <alistra> now
14:45:41 <_Mikey> geheimdienst, I intend to ;) thanks.
14:45:43 <alistra> i'm not sure if it only works in pattern matching
14:46:21 <_Mikey> my code is hilarious :(
14:47:25 <monochrom> one more way: moveUp loc = loc{y = y loc + 1}
14:47:26 <SgeoN1> Mikey, I wasn't laughing at you
14:47:32 <jaapweel> Another question (sorry to interrupt hilarity): in which version of GHC was the new "IO manager using epoll/kqueue/poll" introduced, roughly?
14:47:34 <_Mikey> I knoww ;)
14:47:41 <shachaf> jaapweel: 7, I think.
14:47:57 <SgeoN1> Just at the y = y + 1 which is an example of something that Haskell doesn't do.
14:47:57 <monochrom> one more way: moveUp loc{y=y0} = loc{y = y0 + 1}
14:48:06 <SgeoN1> In LYAH
14:48:11 <_Mikey> monochrom, I'm so lost on that last ecample
14:48:28 <jaapweel> shachaf: thanks, that's very useful
14:48:29 <monochrom> oops, sorry, my last way is wrong
14:48:36 <alistra>  moveUp loc{y=y} = loc{y = y + 1}
14:48:38 <monochrom> moveUp loc@Location{y=y0} = loc{y = y0 + 1}
14:48:41 <alistra> probably would work
14:48:56 <alistra> hmm
14:49:07 <geheimdienst> _Mikey: "somerecord { field = 42 }" is the record update syntax. it means "give me a new record, same type and values as somerecord, but with field set to 42 instead"
14:49:09 <_Mikey> Wow..
14:49:13 <monochrom> may still need some parenthese i.e. may need to be loc@(Location@{y=y0}) but I bet no need
14:49:25 <monochrom> no, not same type
14:49:28 <_Mikey> ahh ok
14:50:04 <_Mikey> it makes a bit more sense now ;)
14:50:31 <shachaf> Huh, @ is another thing that binds more tightly than application!
14:50:38 <_Mikey> Do I need to worry about deleting old ants?
14:50:42 <shachaf> > let f x@y = (x,y) in f 1
14:50:43 <lambdabot>   (1,1)
14:50:49 <_Mikey> Don't want to fill my rams with ants.. ;/
14:50:53 <monochrom> all of the above ways have the same runtime cost, so feel free to use whichever you like
14:51:05 <alistra> _Mikey: garbage collectore
14:51:07 <alistra> _Mikey: garbage collectors
14:51:12 <alistra> worry about that
14:51:23 <_Mikey> simple as?
14:51:35 <_Mikey> no need to optimize anything?
14:51:40 <alistra> hahaha
14:51:43 <alistra> not really
14:51:48 <lispy> edwardk: I bought a book to help me learn opencl.  The examples it gives of opengl/opencl interop all start with a "what platform are you on?  Okay, call this function..."  The interop functions in the actual api seem to be mostly about locking.  Does that match your understanding?
14:52:06 <monochrom> data R a = R{item::a};  f r = r{item = ()}   is valid
14:52:19 <alistra> http://www.scs.stanford.edu/11au-cs240h/notes/perf.html _Mikey
14:52:22 <alistra> :P
14:52:35 <_Mikey> cheers ;)
14:52:53 <monochrom> not only valid, but also type-infers to f :: R a -> R ()
14:53:35 <edwardk> lispy: i mean the standard interop calls like clCreateFromGLBuffer clCreateFromGLTexture, clGetGLObjectInfo, etc.
14:54:00 <lispy> ah
14:54:08 <_Mikey> are QuickCheck tests written in Haskell?
14:54:12 <edwardk> lispy: those are set up to move content from GL and ensure it doesn't get disposed of while cl is using it
14:54:24 <lispy> So before those you have to tell your OS that you intend to allow sharing
14:54:44 <alistra> _Mikey: yes
14:55:24 <edwardk> creating the shared context is the messy part, yes =)
14:55:25 <_Mikey> alistra, and do all compiled programs go through this Core stage?
14:55:32 * hackagebot monad-supply 0.1 - Stateful supply monad.  http://hackage.haskell.org/package/monad-supply-0.1 (GeoffHulette)
14:56:04 <alistra> _Mikey: in ghc yes, in hugs i don't know
14:56:18 <_Mikey> wow
14:56:19 <_Mikey> ok
14:56:22 <alistra> it's like llvm for clang :P
14:56:28 <_Mikey> Thats a really cool link.
14:56:33 <alistra> or whatever it name is in gcc
14:56:41 <alistra> _Mikey: go a level higher
14:56:47 <nwf> Can anybody tell me why the HList package's apply is complaining about "No instance" for things for which there are clearly instances? :)
14:56:48 <alistra> all the stanford lectures
14:56:54 <_Mikey> so it might seem grossy inefficient
14:56:58 <_Mikey> but its optimized out
14:57:15 <monochrom> for practical reasons, you can bet every compiler and every interpreter has its own intermediate language.
14:57:20 <nwf> In particular, given "instance [overlap ok] H.Apply (x -> y) x y" I would expect "H.apply id 3" to work, but it does not: "No instance for (H.Apply (a1 -> a1) a0 r0)"
14:57:21 <alistra> _Mikey: if you want performance, remember to compile haskell, not run in ghci
14:57:21 <_Mikey> there are Haskell Sanford lectures?
14:57:22 <_Mikey> O.o
14:57:39 <alistra> yes, lol
14:57:44 <_Mikey> cool
14:57:47 <_Mikey> ok
14:57:53 <alistra> 00:07:06    alistra> http://www.scs.stanford.edu/11au-cs240h/notes/perf.html _Mikey
14:57:58 <alistra> //www.scs.stanford.edu/11
14:57:59 <_Mikey> cheerts!
14:58:03 <alistra> stanford
14:58:04 <_Mikey> cheers!
14:58:28 <dmwit> nwf: Because x = x, but a1 /= a0 (and it can't (won't) try guessing that a1 = a0).
14:59:04 <rwbarton> there might have been another instance with H.Apply (x -> y) x Char or whatever
14:59:16 <nwf> dmwit: So essentially only monomorphic types are permitted?
14:59:21 <rwbarton> though hmm
14:59:36 <dmwit> nwf: No, polymorphic types are permitted, but they must be at least as monomorphic as the instance declaration.
14:59:49 <rwbarton> I bet if you write "H.apply id (3 :: Int) :: Int" then it will work
15:00:01 <dmwit> nwf: If you give a type signature, like (H.apply :: (x -> y) -> x -> y) id 3, it should probably work.
15:00:04 <nwf> rwbarton: Yeah, but if you leave off either it odesn't work.
15:00:39 <dmwit> > (id :: a -> a) 3
15:00:39 <lambdabot>   3
15:00:56 <nwf> "(H.apply :: (x -> y) -> x -> y) (id) 3" does indeed work.
15:01:11 <_Mikey> @karma alistra
15:01:11 <lambdabot> alistra has a karma of 1
15:01:20 <nwf> What stops the unification of type vars here?
15:01:33 <_Mikey> standford seem to have soo cool stuff on Haskell :)
15:01:47 <_Mikey> stanford*
15:02:05 <dmwit> nwf: Nothing. What stops is the choice of instances.
15:02:48 <nwf> I'm confused; No instance means it's rejected all of them -- if there were several, shouldn't I get an ambiguity warning?
15:03:01 <dmwit> No.
15:03:02 <hpaste> int80_h pasted “What's wrong with my recursive list construction?” at http://hpaste.org/54254
15:03:08 <dmwit> nwf: You've got the phases all interleaved.
15:03:26 <dmwit> nwf: Ambiguity is a property of the set of instances, not of the particular type you're trying to choose an instance for.
15:03:51 <rwbarton> let's write 't' for the type of H.apply id 3
15:04:12 <alistra> _Mikey: karma+ or something if you want to increase it xD
15:04:22 <_Mikey> ooh
15:04:25 <rwbarton> then we need a type t so that there are instances H.Apply (a -> a) Int t and Show t (because we entered it at the ghci prompt)
15:04:31 <rwbarton> for some a
15:04:37 <_Mikey> @karma+ alistra
15:04:38 <lambdabot> alistra's karma raised to 2.
15:04:39 <rwbarton> how would I pick t?
15:05:22 <rwbarton> (and I'm simplifying slightly, actually 3 :: Num b => b so we need to solve H.Apply (a -> a) b t, Num b, Show t for a, b, t)
15:06:41 <nwf> Well, since "H.Apply (x -> y) x y" is the only instance that stands a prayer of unifying (and introducing any generalization of that is going to lead to ambiguity in the set of instances), I would expect it to be used.
15:06:48 <rwbarton> but it needn't be the only instance
15:07:19 <nwf> I suppose there could be an "H.Apply f Int String" instance which would overlap...
15:07:36 <nwf> Well, sorry, "H.Apply f Int Int" in this case.
15:07:55 <nwf> I suppose I want habit's closed classes.
15:07:59 <dmwit> nwf: There can be non-overlapping instances that also "match" in the sense you're using, though. That's the point.
15:08:49 <dmwit> For example, the instance H.Apply (Int -> Int) Int [Int] doesn't overlap (it doesn't apply anywhere that the (x -> y) x y instance applies).
15:08:55 <dmwit> But it could also be used here.
15:09:01 <rwbarton> I think the reason you get the "No instance for ..." message is that ghc sees that it can never determine t from these constraints, so it hopes that it can pick instances which are polymorphic in t
15:09:19 <dmwit> In other words: you can't choose an instance that is more monomorphic than what you currently know about your type.
15:09:43 <dmwit> Because if you do, some schmuck is going to come along later and add another instance that screws you over.
15:10:34 * hackagebot xmonad 0.10 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.10 (AdamVogt)
15:10:42 <shachaf> xmonad 0.10?
15:10:45 <nwf> ! :D
15:10:52 <nwf> dmwit, rwbarton: Thanks, got it.
15:11:27 <shachaf> aavogt: What happen?
15:12:04 <aavogt> what's with cabal asking for my username/password?
15:12:22 <aavogt> I have those things in my ~/.cabal/config... it didn't used to do that
15:12:48 <aavogt> shachaf: uh read here http://www.haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.9
15:13:39 <shachaf> aavogt: Are you the maintainer of xmonad now?
15:14:08 <shachaf> I guess dons/sjanssen/jcreigh(?) are pretty much gone.
15:14:08 <aavogt> yes. for some time now
15:15:34 * hackagebot xmonad-contrib 0.10 - Third party extensions for xmonad  http://hackage.haskell.org/package/xmonad-contrib-0.10 (AdamVogt)
15:16:29 <aavogt> shachaf: http://article.gmane.org/gmane.comp.lang.haskell.xmonad/10649
15:17:39 <shachaf> aavogt++ # xmonad
15:21:12 <aavogt> is there a channel for cabal-install?
15:24:25 <edwardk> aavogt: yeah i believe its called /msg dcoutts  =)
15:25:39 <aavogt> edwardk: do you know what I have to change in my ~/.cabal/config so it doesn't prompt for my username and password (which are in that file)
15:26:01 <edwardk> hackage-username and hackage-password
15:26:06 <edwardk> (not username and password)
15:32:28 <Axman6> aavogt: there's #hackage too
15:33:36 <aavogt> I think my problem is resolved. I don't expect to need upload other things too soon
15:33:59 <Veinor> that reminds me
15:34:05 <Veinor> when is hackage doc generation going to be fixed?
15:34:59 * ddarius pokes copumpkin.
15:35:55 <parcs_> edwardk: trifecta seems to have dependency issues: cabal: cannot configure adjunctions-2.0.4. It requires representable-functors ==2.1 \n representable-functors-2.1 was excluded because kan-extensions-2.0.2 requires representable-functors ==2.0.*
15:36:19 <dmwit> I have unix-2.5.0.0 installed. cabal configure --constraint unix==2.5.0.0 finishes successfully. Why does cabal install --dry-run say it wants to install unix-2.3.2.0 (new version)?
15:36:34 <edwardk> parcs: ah the current trifecta doesn't build with the most recent kan-extensions, i'll patch and upload
15:36:34 <dmwit> Does this mean cabal-install is concluding that unix-2.3.2.0 is a newer version than unix-2.5.0.0?
15:36:49 <parcs_> edwardk: great :)
15:36:57 <edwardk> actually kan-extensions 2.0.4 should work
15:37:04 <edwardk> you probably already have 2.0.2 installed
15:37:27 <edwardk> but i'll bump the existing trifecta's dependency to keep that from being a problem
15:38:41 <parcs_> i'm actually using cabal-dev in a clean environment
15:38:42 <edwardk> ah there is also a deepseq version number change
15:38:55 <edwardk> that was probably what forced the old version to install
15:39:43 <edwardk> ack, fixing that leads to a messier dependency hell
15:39:48 <edwardk> i'll untangle it
15:41:12 <edwardk> ah blech parallel can't install with deepseq 1.2
15:41:35 <edwardk> which leads to fighting. i'll need to relax the requirement in kan-extensions i think
15:42:26 <edwardk> er odd. coz that doesn't use deepseq directly
15:43:26 <geheimdienst> dmwit: the unix package is not hidden or broken or something? try redoing it with -v3 and paste the result maybe
15:44:49 <augur> edwardk: okies
15:45:06 <augur> actually, edwardk, you might be interested in this
15:45:08 <edwardk> its the version bound on parallel which is bracketing the bound on deepseq
15:45:11 <hpaste> dmwit pasted “cabal install --dry-run -v3” at http://hpaste.org/54255
15:45:29 <dmwit> Attention hpaste maintainer: there really needs to be a "plain text" choice for "Language".
15:45:29 <augur> me and a friend are seriously considering starting a project to construct a large linguistics database
15:46:16 <geheimdienst> dmwit: i think that's chrisdone, @tell him
15:46:37 <dmwit> ?ask chrisdone Can we get a "Language: plain text" choice on hpaste.org?
15:46:38 <lambdabot> Consider it noted.
15:47:31 <dmwit> It looks like cabal-install didn't even reject unix-2.5.0.0: it didn't even consider it long enough to reject it!
15:47:43 <edwardk> _parcs: okay, uploading a new reducers and a couple other packages to fix the dependency on parallel
15:48:25 <geheimdienst> what does this mean: selecting darcs-2.7.3 (source) and discarding filepath-1.0, hashed-storage-0.3, 0.3.1, [whole bunch of stuff ...] unix-2.5.0.0,
15:48:34 <geheimdienst> why is it "discarding" that?
15:49:08 <dmwit> I don't know. =(
15:49:31 <dmwit> I've got the damn thing built and installed now, so the pursuit is a tiny bit academic. But it is definitely a weird situation.
15:50:31 <geheimdienst> maybe that darcs-2.7.3 version has a dependency that says unix <= 2.4 or something?
15:50:34 * hackagebot reducers 0.1.7 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.7 (EdwardKmett)
15:50:48 <dmwit> geheimdienst: No, it says unix < 2.6
15:50:57 <geheimdienst> bizarre
15:51:07 <dmwit> geheimdienst: (...and as I mentioned above, it successfully configures when I add --constraint unix==2.5.0.0)
15:51:17 <geheimdienst> right
15:51:35 <edwardk> parcs: have it building locally. one sec.
15:51:36 <dmwit> Yeah, it's weird.
15:51:41 <dmwit> dcoutts: Is it a bug? =)
15:51:43 <geheimdienst> i was just confused by why it decides to "discard" all that
15:52:37 <edwardk> parcs: try pulling now
15:52:38 <geheimdienst> could darcs 2.7.3 depend on package X, which has a constraint for unix to be < 2.5? that still wouldn't explain why it configures successfully, but ...
15:53:17 <dmwit> I ended up building most of the dependencies by hand (since most of them needed some changes to build under GHC 7.3), and all of them selected unix-2.5.0.0 on their own.
15:55:34 * hackagebot trifecta 0.49 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.49 (EdwardKmett)
16:01:22 <parcs_> cabal: cannot configure trifecta-0.49. It requires kan-extensions >=2.0.4 && <2.1 \n There is no available version of kan-extensions that satisfies >=2.0.4 && <2.1
16:01:39 <edwardk> hrmm checking
16:01:55 <edwardk> bah
16:04:09 <edwardk> pull 0.49.1 =/
16:04:46 <edwardk> i didn't release 2.0.4 because it violated the PVP
16:04:52 <edwardk> i shipped it as 2.1
16:04:57 <edwardk> and forgot
16:05:38 <edwardk> (it wasn't a minor update since it added instances)
16:06:51 <parcs_> ok, no dependency errors now
16:06:57 <edwardk> yay!
16:07:08 <edwardk> now to backport all those fixes into my development branch
16:07:08 <parcs_> hopefully no compile errors either :)
16:07:11 <edwardk> hah
16:07:48 <mikeplus64> this is a silly question: how do I make a "Maybe String" (the output of "getEnv "foobar"") just "String" (for outputting it)
16:07:50 <mikeplus64> ?
16:08:27 <shachaf> mikeplus64: Pattern-match on it.
16:08:39 <shachaf> case maybeString of Nothing -> ...; Just s -> ...
16:08:47 <mikeplus64> ok
16:09:00 <edwardk> case myMaybeString of Just s -> s; Nothing -> "Oh crap!"
16:09:07 <edwardk> :t maybe
16:09:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:09:13 <edwardk> you might also use that
16:09:15 <edwardk> or
16:09:17 <edwardk> :t fromMaybe
16:09:18 <lambdabot> forall a. a -> Maybe a -> a
16:09:20 <c0w> ddarius: still haven't done it :P going down to tampa next week so will probably just get one there instead
16:09:23 <mikeplus64> thanks
16:09:23 <edwardk> which is in Data.Maybe
16:09:53 <geheimdienst> mikeplus64: if you just quickly want to print a Maybe you can also use "print (Just 42)"
16:10:17 <mikeplus64> geheimdienst: oh, cool
16:10:34 * hackagebot trifecta 0.49.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.49.1 (EdwardKmett)
16:11:21 <ddarius> copumpkin: I was just going to ask if you wanted to go to a Greek restaurant near Davis Square.
16:12:09 <copumpkin> ddarius: I'd like to, but I'm kinda busy tonight. Are you free on sunday?
16:12:44 <stribor> i have function that return type is Render()......is there any return value i can give it just so i can compile my program without errors as i am not ready to work on that particular function
16:13:44 <rwbarton> stribor: undefined
16:14:22 <stribor> rwbarton: where can i look up this type..like docs?
16:15:11 <rwbarton> I don't understand.
16:15:14 <ddarius> copumpkin: Sort of.
16:15:39 <augur> drwho: hello, sexy
16:16:05 <copumpkin> preflex: seen drwho
16:16:06 <preflex>  drwho was last seen on ##javascript 138 days, 15 hours, 7 minutes and 2 seconds ago, saying: ok thanks
16:16:10 <geheimdienst> stribor: with the "undefined" trick i guess you just have to ask #haskell, i don't think any docs spell that out
16:16:22 <drwho> wat
16:16:47 <augur> drwho: :|
16:16:50 <copumpkin> http://en.wikipedia.org/wiki/File:Angkor_Wat.jpg
16:16:57 <augur> you dont deserve the username "drwho"
16:17:04 <augur> copumpkin: i prefer angkor thom, myself
16:17:09 <stribor> geheimdienst: i meant where can i look type Render()
16:17:16 <copumpkin> augur: yeah, but ah well
16:17:19 <copumpkin> he didn't say thom, did he
16:17:25 <augur> copumpkin: irrelevant
16:17:27 <copumpkin> yorke
16:17:33 <Axman6> stribor: we have no idea, did tou define it?
16:18:05 <rwbarton> like, why do you think your function should have type Render (), is that from some module you imported or what
16:18:15 <rwbarton> in that case, check the documentation for the module in question?
16:18:22 <stribor> rwbarton: OK...THANKS
16:18:27 <geheimdienst> stribor: check hackage for the package you are using. random example: here are all the module docs that the darcs package gives you http://hackage.haskell.org/package/darcs
16:18:28 <rwbarton> :/
16:18:30 <stribor> rwbarton: sorry for caps...lol
16:18:42 <geheimdienst> stribor: if you have no idea where a type or function is coming from, use hayoo
16:18:45 <geheimdienst> @where hayoo
16:18:45 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:18:47 <stribor> rwbarton: i had caps on by mistake:)
16:18:49 <drwho> wat
16:19:03 <drwho> lol javascript
16:25:14 <parcs_> why does 'cabal-dev ghci' require a .cabal file?
16:25:46 <parcs_> what else does it do other than 'ghci -package-conf cabal-dev/packages-*.conf/' ?
16:28:01 <ybit> http://hpaste.org/54257
16:28:16 <ybit> i'm a little confused about the (a -> a) part
16:29:55 <ybit> anyone willing to walk me through this?
16:31:18 <ybit> what's the proper way of readding applyTwice :: (a -> a) -> a -> a?
16:31:23 <ybit> in english por favor :)
16:31:24 <geheimdienst> ybit: (a -> a) means a function that takes an 'a' and gives an 'a'
16:31:47 <Saizan> the first argument of applyTwice is a functin that takes an argument of type 'a' and whose result is of type 'a'
16:31:52 <geheimdienst> so in total, applyTwice takes such a function, and an 'a', and in the end gives you an 'a'
16:32:00 <shachaf> applyTwice :: forall a f. (forall b. b -> f b) -> a -> f (f a)
16:32:14 <geheimdienst> shachaf: thanks for clarifying
16:32:28 <Saizan> the second argument is of type 'a', and the result will be of type 'a' as well
16:32:31 <shachaf> geheimdienst: Happy to be of service.
16:32:41 <geheimdienst> shachaf: i bet
16:32:49 <augur> shachaf: now make it dependent
16:32:57 <shachaf> geheimdienst: This is a subtle complaint that you can't use the same applyTwice function for both of them.
16:33:51 <ybit> Saizan: when you say the second argument is of type 'a' you are referring to ...) -> a correct?
16:34:21 <augur> applyTwice : forall {A : Set} {P : A -> Set} -> ((x : A) -> P x) -> (x : A) -> P (P x)
16:34:23 <augur> i think?
16:34:57 <ddarius> You can be more dependent than that.
16:35:02 <augur> ddarius: :o
16:35:15 <ybit> Saizan: correcto?
16:35:37 <Saizan> ybit: yeah, the one between _ _ here: (a -> a) -> _a_ -> a
16:35:41 <ybit> yes yes
16:35:42 <hpaste> rikola pasted “Why does adding the Integral constraint kill this function's performance?” at http://hpaste.org/54259
16:35:43 <augur> ddarius: how how :D
16:35:44 <ybit> okay
16:35:50 <ybit> i'm reading it correctly then
16:35:52 <copumpkin> augur: that won't typecheck
16:35:57 <augur> copumpkin: :(
16:36:00 <ddarius> augur: Ask copumpkin, I'm going to go get Greek food.
16:36:01 <ybit> shachaf: your response is confusing and i just ignored it
16:36:06 <augur> copumpkin: oh, right, of course
16:36:09 <augur> P : A -> Set
16:36:11 <augur> P x : Set
16:36:13 <rikola> I pasted the above. Can anyone tell me why the Integral constraint has such a result?
16:36:13 <augur> right
16:36:21 <copumpkin> ddarius: :O
16:36:40 <ybit> shachaf: i would like to learn what you wrote but i want to finish lyah in the next couple of days
16:36:46 <ybit> so... back to reading!
16:36:55 <augur> no it'd be something like
16:37:16 <augur> forall {A : Set} {P : A -> Set} -> (f : (x : A) -> P x) -> (x : A) -> P (f x)
16:38:12 <copumpkin> nope
16:38:16 <augur> what nope
16:38:17 <augur> :|
16:38:27 <augur> f x : P x, f (f x) : P (f x)
16:38:53 <copumpkin> you can't apply P to a value of type P x
16:38:56 * ybit logged back in to ask.. how did you guys immediately know it was a function by looking at the type declaration?
16:39:08 <augur> copumpkin: P : A -> set, x : A
16:39:28 <augur> oh right
16:39:28 <augur> again
16:39:29 <augur> hmm
16:39:49 <ybit> anyone please?
16:39:58 <Saizan> ybit: when you have A -> B is the type of functions from A to B
16:40:45 <ybit> Saizan: hmm
16:40:58 <ybit> you know automatically when you see an arrow?
16:41:09 <Saizan> yep
16:41:14 <ybit> awesome
16:41:17 <ybit> thanks again
16:41:24 * ybit goes back to reading
16:41:38 <Saizan> (->) is right associative btw
16:46:44 <rikola> Does anyone know why adding an Integral constraint destroys the performance of function that sums the elements of a list using an accumulator? Example: http://hpaste.org/54259
16:48:42 <Saizan> don't know, but you should add some strictness annotations for that accumulator
16:49:11 <parcs_> man, hlint is so smart :)
16:50:13 <Saizan> it should say "or better foldl'" :) even if that changes the semantics
16:51:39 <ybit> eh, sorry, i'm getting confused
16:51:46 <ybit> back to applyTwic
16:53:27 <ybit> (a -> a) is a function that takes a value called "a" and returns another value "a". this is then used as a parameter for another function which returns "a" and then finally (the last -> a) this value is used as a paramenter to return another value of type "a"
16:53:31 <ybit> is this correct?
16:53:47 <ybit> in total, three input parameters
16:53:54 <Saizan> nope
16:53:57 <ybit> okay
16:54:02 <ybit> i figured it was
16:54:08 <ybit> where am i wrong?
16:54:13 <ybit> the beginning i'm assuming
16:56:25 <augur> weirddd
16:56:38 <ybit> eh?
16:56:44 <augur> hamblin semantics is just the applicative List/Set monad
16:56:54 <augur> hamblin application is just <*>
16:57:12 <augur> sorry, just the applicative functor
16:57:17 <augur> the monad component is irrelevant
16:57:30 <augur> but Shan's extension is some perverse mix of monadic and applicative behavior
16:58:28 <augur> hamblinApp :: [a -> b] -> [a] -> [b]
16:58:28 <augur> hamblinApp fs xs = [f x | f <- fs, x <- xs]
16:58:45 <ybit> somebody want to PM Me so i don't get on everyone's nerves about this?
16:58:53 <augur> shanApp :: [a -> [b]] -> [a] -> [b]
16:58:53 <augur> shanApp fs xs = [y | f <- fs, x <- xs, y <- f x]
17:14:36 <mike-burns> ybit: You're not on anyone's nerves. Your questions are basically the whole point of this channel.
17:14:46 <mike-burns> Is someone PMing you? Otherwise I'll try to explain.
17:15:50 <augur> mike-burns: i am :)
17:16:08 <mike-burns> Cool, carry on.
17:31:04 <elliott> How can I use Control.Category in GHCi? I can't "import Prelude hiding ..."; it works but the conflicts aren't resolved.
17:35:11 <dr_rotflcopter> hi
17:36:10 <shachaf> elliott: let (.) = (Control.Category..)?
17:36:51 <elliott> shachaf: Works, with an explicit type signature. Kind of ugly :/
17:38:01 <shachaf> elliott: Why do you need an explicit type signature?
17:38:06 <elliott> shachaf: Monomorphism restriction.
17:38:15 <shachaf> :set -XNoMonomorphismRestriction
17:38:22 <elliott> Well, yes.
17:38:29 <shachaf> And more than "kind of" ugly.
17:38:41 <shachaf> (Also, (.) x = (Control.Category..) x)
17:38:55 * shachaf will go to great lengths not to type out type signatures.
17:40:15 <chra> elliott: My approach was to create a package My.Prelude which reexports all wanted functions and have :m - Prelude, :m + My.Prelude in .ghci.
17:40:35 <elliott> chra: Mm.
17:40:49 <shachaf> chra: You can :m - Prelude?
17:40:50 <elliott> Oh, I wonder if :m - Prelude wouldn't let me do the proper partial import.
17:40:51 <shachaf> Aha!
17:40:54 <elliott> Right.
17:41:01 <shachaf> :m - Prelude\nimpor Prelude hiding ((.))\nworks.
17:42:30 <stribor> i am trying to rotate image using this function -> pixbufFlipHorizontally :: Pixbuf -> IO PixbufSource
17:43:41 <stribor> actually this is function i am trying to use -> pixbufRotateSimple :: Pixbuf -> PixbufRotation -> IO Pixbuf
17:43:54 <stribor> how do i convert this result type to jst Pixbuf
17:46:06 <mike-burns> What do you want to do with the Pixbuf after you, er, convert it?
17:46:26 <mike-burns> stribor: ^
17:47:40 <stribor> mike-burns: i have one image.....i want to rotate it and save it to list....at the end my list will contain original image and rotated image
17:48:46 <stribor> mike-burns: this call -> pixbufRotateSimple pic PixbufRotateUpsidedown(pic is image of type Pixbuf) would be perfect
17:49:04 <stribor> mike-burns: if return type is just Pixbuf rather then IO Pixbuf
17:49:06 <mike-burns> Like: pixbufRotateSimple p r >>= \p' -> return $ [p,p']
17:49:27 <mike-burns> Oh I don't need the ($) there.
17:49:49 <stribor> mike-burns: yeah  but id like to use my exmaple because i came up with it:)
17:50:08 <mike-burns> My example would give you an   IO [Pixbuf]
17:50:38 <stribor> mike-burns: i have to givbe this result to another function which accepts only [Pixbuf]
17:51:04 <mike-burns> Like: pixbufRotateSimple p r >>= \p' -> return $ anotherFunction [p,p']
17:51:08 <mike-burns> Like that?
17:51:37 <stribor> mike-burns: how do i use this function ->pixbufRotateSimple pic PixbufRotateUpsidedown
17:51:49 <rwbarton> BTW, it's possible that pixbufRotateSimple rotates the image in place...
17:51:49 <stribor> mike-burns: only problem with my function is that return type doesnt match
17:52:01 <rwbarton> stribor: read an introduction to IO
17:52:21 <stribor> rwbarton: i read it IO is kind of like container...you cant change the type
17:52:58 <shachaf> stribor: IO isn't a container.
17:53:07 <mike-burns> More like a burrito.
17:53:22 <rwbarton> My suggestion stands
17:53:37 <rwbarton> learn how to do things like read an integer and then print double that integer.
17:53:43 <shachaf> stribor: getLine :: IO String "contains" a String in the same way that /bin/ls "contains" a list of files.
17:53:58 <stribor> shachaf: ok.....
17:54:22 <mike-burns> That's the second time I've sen that analogy today. It's starting to grow on me.
17:54:38 <shachaf> mike-burns: Really? There's someone else who uses it?
17:55:12 <shachaf> "Monads as Geese Laying Golden Eggs"
17:55:28 <mike-burns> 10AM EST, Philonous said it.
17:56:48 <shachaf> Aha!
17:56:50 <shachaf> Excellent.
18:01:38 <elliott> shachaf: I use /bin/ls as a filesystem.
18:01:46 <elliott> I just patch in new files when I need 'em;
18:03:30 <dmwit> I'm confused again.
18:03:53 <dmwit> cabal install reports success, but ghc-pkg reports no library was installed as a result.
18:04:10 <dmwit> The "Library" section of the cabal file is protected by a conditional flag, but that flag defaults to being on.
18:05:03 <dmwit> ...can flags be turned off by the dependency checker?
18:05:12 <dmwit> That would explain both the previous behavior *and* this behavior...
18:05:18 <dmwit> I think that's what must be happening.
18:08:18 <shachaf> elliott: Fine, /bin/ls = return [...]
18:08:37 <elliott> shachaf: See, it's got a list in it!
18:08:45 <shachaf> There you go.
18:08:55 <shachaf> And you can use kmc's mutable variables hack when you feel like modifying it.
18:10:32 <elliott> shachaf: Which hack's that? global-variables?
18:11:36 <shachaf> elliott: No, the thing where he actually modified the values.
18:11:48 <elliott> shachaf: Oh, /that/ thing.
18:11:51 <elliott> I had almost forgotten. :(
18:16:16 <shachaf> Here: http://hpaste.org/52266
18:21:29 <photex> Hi folks, I thought that I was going to be attempting something easy
18:21:34 <photex> by exploring xml processing
18:21:58 <photex> but I'm apparently in need of some illumination
18:22:07 <photex> regarding IO (Maybe Element)
18:22:21 <mike-burns> Maybe paste some code?
18:22:28 <mike-burns> I dunno. How can we help?
18:22:46 <photex> let result = parseXMLDoc <$> readFile filename
18:22:50 <photex> (in ghci)
18:23:09 <photex> findChild "workflow" result
18:23:15 <photex> or
18:23:17 <photex> strContent result
18:23:19 <photex> etc
18:23:31 <photex> file == "test.xml"
18:23:35 <mike-burns> :t parseXMLDoc
18:23:36 <lambdabot> Not in scope: `parseXMLDoc'
18:23:48 <mike-burns> What's that parseXMLDoc function do?
18:23:51 <photex> which is just "<workflow><process name="test"/></workflow>
18:23:59 <photex> it's part of Text.XML.Light
18:24:31 <photex> which I understood to be the sort of foundation vanilla XML package
18:24:48 <mike-burns> Ah: parseXMLDoc :: String -> Maybe Element
18:25:38 <photex> my assumption is that IO refers to the fact that this was read from a file
18:25:49 <mike-burns> Yeah the <$> will do that.
18:26:23 <mike-burns> You could do like  xmlString <- readFile filename  then deal with xmlString in ghci.
18:26:40 <geheimdienst> kind of :) ... <$> in conjunction with readFile put the IO there
18:26:47 <sam8> Hi, I am trying to make a newtype and make an instance of monad but I am having trouble
18:26:51 <geheimdienst> :t readFile -- you can also see that from this type
18:26:52 <lambdabot> FilePath -> IO String
18:26:57 <sam8> newtype (Integral a) => Zq a = Zq a deriving (Show, Eq)
18:27:05 <sam8> instance Monad Zq where
18:27:10 <sam8> return x = Zq x
18:27:16 <sam8> Zq a >>= f = (f a)
18:27:17 <mike-burns> Oh use hpaste.
18:27:22 <photex> ok, so it's not considered bad form to use a temporary variable?
18:27:24 <shachaf> sam: You shouldn't have constraints on newtypes.
18:27:43 <geheimdienst> photex: no, not at all
18:27:44 <sam8> ya I was thinking...
18:27:46 <mike-burns> photex: If it helps you build the app, go for it.
18:27:55 <shachaf> geheimdienst: Traitor!
18:28:01 <sam8> how can I restrict a to be only integral?
18:28:05 <photex> ok cool
18:28:18 <mike-burns> And if you're playing around in ghci, so anything you want.
18:28:26 <mike-burns> No one will know.
18:28:40 <geheimdienst> shachaf: what, am i going to be expelled from the Noble Club of Writers of Damn Confusing Codings?
18:28:47 <sam8> http://hpaste.org/54262
18:28:47 <shachaf> sam8: Put the signatures on functions that use it.
18:28:52 <shachaf> geheimdienst: Also known as #haskell.
18:28:57 <mike-burns> Hah.
18:28:57 <geheimdienst> :D
18:29:11 <photex> hrm
18:29:20 <photex> still says IO (Maybe Element)
18:30:24 <photex> ok, well TIL that just getting text from a file was not the solved problem I thought it was
18:30:35 <photex> I'm going to go back and read up on this
18:30:48 <mike-burns> It's solved, just different.
18:31:03 <photex> sorry, I meant, solved in terms of "I understand"
18:31:04 <photex> haha
18:31:07 <mike-burns> Hah, yes.
18:31:22 <photex> thanks
18:31:23 <photex> cheers
18:31:27 <elliott> photex: You can't escape from IO, if that's what you mean.
18:31:31 <elliott> Sheesh.
18:31:38 <mike-burns> You can't escape!
18:32:05 <elliott> sam8: To generalise what shachaf said: You shouldn't use data-type contexts at all.
18:32:12 <elliott> They never do what you want and they've been removed from the report.
18:32:21 <sam8> I see...
18:32:31 <sam8> I tried to change it to this2026 can you take a look? I get an error
18:32:33 <sam8> http://hpaste.org/54263
18:32:44 <elliott> The error is just what it says.
18:32:55 <elliott> Zq wants two types; (Zq a q) wants none; Monad wants a type that wants one types.
18:33:00 <elliott> s/one types/one type/
18:33:06 <elliott> Which (Zq a q) ain't.
18:33:22 <elliott> (Zq a) is, but you're not going to be able to make that a Monad instance, because you'd need q -> Zq a q.
18:34:42 <elliott> sam8: It would probably be best to tell us what you're actually trying to do.
18:35:44 <sam8> Well, I wanted to make a Zq type that represents a number ring
18:36:15 <sam8> so its like regular Integral
18:36:20 <sam8> but it has a mod attached to the type
18:36:38 <sam8> for instance, I wanted to have Int mod 5
18:36:39 <elliott> That will require type-level naturals, I think.
18:36:40 <sam8> or something
18:36:43 <elliott> Which don't exist.
18:36:51 <elliott> You can fake them -- but the code is really painful type-hackery. (You really don't want this.)
18:36:53 <shachaf> elliott: They don't?
18:36:59 <elliott> They're coming into GHC 7.4 or so, though.
18:37:03 <elliott> Don't quote me on that version, it might be 7.6.
18:37:26 <elliott> shachaf: Well, you can't say "5" :-)
18:37:43 <elliott> sam8: So yeah, sorry, you probably don't really want to do that.
18:39:05 <sam8> just one minute
18:39:08 <shachaf> elliott: Don't you mean version Point (S (S (S (S (S (S (S Z))))))) (S (S (S (S (S (S Z))))))?
18:39:33 <elliott> shachaf: Yes, naturally.
18:39:40 <sam8> this is sort of what our research team has..
18:39:41 <sam8> http://hpaste.org/54264
18:39:50 <sam8> but all of us aren't that familiar with haskell so...
18:40:12 <sam8> I'm not sure if this is the best way to represent a ring...
18:41:30 <elliott> Well...
18:41:31 <elliott> data Z
18:41:32 <elliott> data S n
18:42:03 <elliott> instance IntegralAsType Z where value _ = 0; instance IntegralAsType n => IntegralAsType (S n) where value _ = value (undefined :: n) -- requires ScopedTypeVariables
18:42:27 <elliott> You probably want (Zq q a) if you want a monad instance, not the other way around.
18:42:28 <sam8> yes I actually have that...
18:42:34 <sam8> I forgot to put it in hpaste
18:42:43 <elliott> sam8: So you don't want T5 and T8 as separate things.
18:42:47 <elliott> type T5 = S (S (S (S (S Z too many )s
18:43:07 <elliott> sam8: (BTW, I suggest "value :: (Integral b) => Tagged a b" (from the tagged package) to avoid that ugly abuse of undefined...)
18:43:38 <sam8> so what does S(S(S(S Z too many )s mean?
18:44:30 <elliott> type T5 = S (S (S (S (S Z)))))
18:44:34 <elliott> I didn't want to type out all those )s. :)
18:45:46 <sam8> so what does S mean?
18:45:53 <mike-burns> Successor.
18:46:09 <elliott> sam8: consult your nearest guide to peano arithmetic :)
18:46:44 <mike-burns> Z, oddly enough, is short for "zebra".
18:47:25 <shachaf> (S Z) stands for "Zebra the Second"
18:47:29 <shachaf> And so on.
18:47:43 <elliott> Fun fact: Peano was a zebra.
18:48:40 <shachaf> In Peano's original constructor, an N was used. S (S N) and so on. If you use a "Z" it actually indicates that you're using imaginary numbers.
18:48:50 <shachaf> s/or/ion/
18:49:00 <sam8> then do you guyz have any suggestions as how to define rings as types?
18:50:38 <DanBurton> sam8: what, exactly, is a "ring"?
18:51:05 * DanBurton braces himself for a troll answer from shachaf >.>
18:51:15 <elliott> DanBurton: Um... http://en.wikipedia.org/wiki/Ring_(mathematics)?
18:51:21 <shachaf> DanBurton: You know, a ring. An algebraic structure.
18:51:32 <Axman6> DanBurton: well braced
18:51:44 <sam8> ya so if I have a ring of mod 5
18:51:59 <sam8> then if I do 3 + 4
18:52:07 <sam8> then the type automatically makes it 2
18:53:12 <elliott> sam8: Anyway, it's not "defining rings", but I gave you a suggestion (use type-level Peano naturals).
18:53:34 <c_wraith> So, you want rings mod n to be a type including n in the type?   That requires some trickery.
18:53:55 <sam8> ya basically...
18:54:13 <elliott> Is there anything wrong with my suggestion?
18:54:53 <sam8> no.. I'm just reading about that right now because I'm unfamiliar with it
18:55:10 <hpaste> pixbuf pasted “stribor” at http://hpaste.org/54265
18:55:28 <sam8> but the way I have right now is slow?
18:55:33 <sam8> is that the problem?
18:55:34 <stribor> can someone help me with this function....^
18:55:54 <elliott> sam8: No, it just isn't very general.
18:56:06 <elliott> And the type arguments are the wrong way around for a Monad.
18:56:22 <mike-burns> stribor: Beyond the suggestion on the bottom of that page?
18:56:36 <elliott> stribor: The type is wrong.
18:56:40 <elliott> stribor: It should be IO [Pixbuf].
18:57:01 <elliott> stribor: Additionally, "scanl" does not return a value of type (IO a), so you should use
18:57:04 <elliott> let myList = scanl ...
18:57:04 <elliott> not
18:57:07 <elliott> myList <- scanl ...
18:57:14 <elliott> Or you could just do
18:57:15 <shachaf> elliott: No, the value is wrong. It should be [].
18:57:16 <elliott> return $ scanl ...
18:57:18 <elliott> Directly.
18:57:33 <elliott> shachaf: -- shachaf "not a troll" shachaf
18:57:37 <stribor> elliott: i know but my my return type has to be [Pixbig]
18:57:49 <elliott> stribor: It can't be.
18:57:53 <elliott> stribor: Haskell is a pure language.
18:58:15 <elliott> stribor: You can still use it from within main, though:
18:58:16 <shachaf> elliott: :-(
18:58:26 <elliott> main = do pixbufs <- myFunction; ... use pixbufs ...
18:58:26 <Nimatek> Except for the function that cannot be named.
18:58:29 <stribor> elliott: has to be main function?
18:58:40 <mike-burns> Can be any function.
18:58:42 <elliott> stribor: Hm? No. I was just giving an example program.
18:58:55 <elliott> stribor: Aso, "loadPixbufs" is a better name than "myFunction". :-)
18:58:56 <elliott> So you can do
18:58:58 <elliott> pixbufs <- loadPixbufs
18:59:02 <elliott> in "main" or any other IO action
18:59:07 <elliott> and pass those pixbufs elsewhere.
18:59:13 <stribor> elliott: i know but i am getting error  Couldn't match expected type `IO Pixbuf'            against inferred type `[Pixbuf]'
18:59:17 <stribor> which is what we said
18:59:25 <elliott> stribor: Did you make the corrections?
18:59:31 <elliott> stribor: The problem is that you're using scanl wrong.
18:59:31 <stribor> my question is how can i get my function to compile
18:59:35 <elliott> I told you how.
18:59:36 <stribor> elliott: il paste again
18:59:42 <elliott> Don't, I know what your code is.
18:59:49 <mike-burns> No paste it!
18:59:55 <elliott> You have to fix the binding of scanl, like I said: <elliott> stribor: Additionally, "scanl" does not return a value of type (IO a), so you should use  <elliott> let myList = scanl ...
19:00:00 <elliott> And change the type to "IO [Pixbuf]".
19:00:02 <mike-burns> Lots of IO questions tonight.
19:00:05 <elliott> Then it will compile, unless there is some other error.
19:00:08 <hpaste> stribor pasted “something” at http://hpaste.org/54266
19:00:13 <shachaf> mike-burns: And not a single /bin/ls question. :-(
19:00:21 <mike-burns> Oh that again.
19:00:30 <elliott> stribor: Like I said: the type must be "IO [PixBuf]". Correct the type declaration.
19:00:46 <shachaf> Someone ought to write Monads as Geese.
19:00:49 <mike-burns> shachaf: do you prefer the ls flag -x or -C ?
19:00:52 <dmwit> byorgey: ping
19:00:54 <shachaf> Rather, Monads as Goose Constructors.
19:01:00 <stribor> elliott: i know that...i wanted to see if i can get arround it......it would be easy just to change return type of function..lol
19:01:07 <elliott> stribor: You can't.
19:01:10 <mike-burns> You can't get around it.
19:01:20 <elliott> Nimatek: Don't you dare.
19:01:25 <PiRSquared17> > fix (+1)
19:01:27 <Nimatek> elliott: :p
19:01:28 <mike-burns> That's the whole point of IO.
19:01:28 <lambdabot>   mueval-core: Time limit exceeded
19:01:34 <PiRSquared17> > fix (*1)
19:01:37 <lambdabot>   mueval-core: Time limit exceeded
19:01:38 <mike-burns> It's like the Terminator.
19:01:55 <stribor> elliott: ok thank hyou
19:02:09 <PiRSquared17> > fix (const 324242424)
19:02:10 <lambdabot>   324242424
19:02:17 * mike-burns starts working on "IO is like The Terminator".
19:02:24 <dmwit> PiRSquared17: The least fixpoint of any strict function is bottom.
19:02:34 <elliott> Monads are like black holes, you can't get out of them.
19:02:38 <dmwit> (The definition of "strict" is "bottom is a fixpoint".)
19:02:43 <elliott> Also they're massive and suck you in.
19:02:47 <elliott> And rip apart anything that goes into them.
19:02:48 <Nimatek> Once you go IO, you never go back!
19:03:03 <elliott> But if you have a function from a value to a black hole containing another value, you can bind it to the black hole and it'll transmutate.
19:03:05 <stribor> Nimatek: LOL..nice
19:03:11 <elliott> (This result due to Einstein.)
19:03:20 <shachaf> elliott: Monads as BLACKHOLEs?
19:03:26 <dmwit> (...and the ordering is defined to put bottom at the bottom. Hence the name. ;-)
19:03:33 <elliott> Also if you have a black hole containing another black hole, then I'm impressed, but you can merge them together.
19:03:53 <mike-burns> And for some reason you can make the blackhole fail.
19:03:57 <Nimatek> I think monadic analogy humour does not have a positive effect on people trying to learn them.
19:03:58 <PiRSquared17> @type fix . const -- forall a. a  ?
19:03:59 <lambdabot> forall a. a -> a
19:04:05 <elliott> mike-burns: Which crashes the universe in most black holes.
19:04:06 <PiRSquared17> id
19:04:12 <PiRSquared17> @pl fix . const
19:04:13 <lambdabot> id
19:04:18 <elliott> Nimatek: Neither does unsafeMumbleMumble on people trying to learn IO :)
19:04:25 <elliott> So, someone tell me how comonads are like white holes.
19:04:33 <Nimatek> Haha.
19:04:39 <PiRSquared17> @pl fix . fix
19:04:39 <lambdabot> fix . fix
19:04:46 <PiRSquared17> @type fix . fix
19:04:47 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
19:05:12 <PiRSquared17> @type fix . fix . const
19:05:13 <lambdabot> forall a. (a -> a) -> a
19:05:26 <dmwit> fix . fix . const = fix . (fix . const) = fix . id = fix
19:05:39 <stribor> elliott: this gives errors too
19:05:52 <shachaf> @ty fmap fix return
19:05:53 <lambdabot> forall a. a -> a
19:05:59 <shachaf> @ty fmap return fix -- Also useful.
19:05:59 <elliott> stribor: hpaste
19:06:00 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> a) -> m a
19:06:26 <stribor> elliott: http://hpaste.org/54267
19:06:36 <elliott> stribor: What error?
19:06:44 <elliott> It might be related to the fact that you have a space before "myFunction =".
19:07:12 <stribor> Example.hs:36:34:     Couldn't match expected type `Pixbuf'            against inferred type `IO Pixbuf'     In the first argument of `scanl', namely `pixbufRotateSimple'     In the second argument of `($)', namely         `scanl            pixbufRotateSimple            image            [PixbufRotateNone, PixbufRotateCounterclockwise,             PixbufRotateUpsidedown, PixbufRotateClockwise]'     In the expression:           return
19:07:26 <elliott> stribor: Oh. What is the type of pixbufRotateSimple?
19:07:58 <stribor> elliott: IOPixbuf
19:08:09 <mike-burns> Also, I'm sorta surprised at the scanl. I didn't there there was more than one use for it.
19:08:13 <elliott> stribor: No, it's not. I can tell it isn't from that typedef.
19:08:14 <elliott> Erm.
19:08:16 <elliott> stribor: No, it's not. I can tell it isn't from that type error.
19:08:17 <mike-burns> And I forgot the one use.
19:08:22 <elliott> What's the full type of pixbufRotateSimple?
19:08:33 <mike-burns> :t pixbufRotateSimple
19:08:33 <stribor>     gtk  pixbufRotateSimple :: Pixbuf -> PixbufRotation -> IO Pixbuf
19:08:33 <lambdabot> Not in scope: `pixbufRotateSimple'
19:08:57 <elliott> stribor: Okay. You need some kind of scanlM.
19:09:03 <elliott> But there isn't one in the standard libraries.
19:09:10 <elliott> stribor: Are you sure you don't want mapM?
19:09:20 <elliott> mapM (pixbufRotateSimple image) [[PixbufRotateNone, PixbufRotateCounterclockwise,             PixbufRotateUpsidedown, PixbufRotateClockwise]
19:09:21 <stribor> elliott: ill look into the type for mapM
19:09:21 <elliott> (without the return)
19:09:29 <stribor> elliott: let me try that
19:11:26 <stribor> elliott: yeah that worked
19:11:30 <stribor> elliott: tx
19:11:30 <mike-burns> Before IO was a monad, what jokes did we tell?
19:11:45 <elliott> stribor: no problem
19:11:59 <elliott> mike-burns: Continuation-based IO tutorial jokes?
19:12:11 <mike-burns> That's what I feared.
19:12:48 <mike-burns> IO continuations are like burritos.
19:13:34 <mike-burns> Oh snap, someone owns the haskell.io domain.
19:21:49 <hpaste> hargettp pasted “Why do I have an ambiguous type variable?” at http://hpaste.org/54268
19:23:30 <dmwit> hargettp: That first "return" in "tell" is a bit suspicious.
19:23:34 <dmwit> What are you trying to do there?
19:23:46 <dmwit> (Whatever it is, you almost certainly aren't doing it.)
19:25:04 <hargettp> dmwit: i didn't expect the result of the liftM line to be wrapped in IO...so was expecting return would do that for me
19:25:36 <dmwit> hargettp: What that line is *actually* doing is creating a monadic action... and then immediately tossing it out the window.
19:25:44 <dmwit> It never gets executed, in case you were hoping it would be.
19:25:50 <hargettp> dmwit: joy
19:26:06 <dmwit> Anyway, the error the compiler is telling you about is something else. What you wrote is a bug, but type checks. =P
19:26:12 <dmwit> So, the real problem is this:
19:26:17 <dmwit> members is return-type polymorphic.
19:26:25 <dmwit> So everywhere you use it, you must specify what type to return.
19:26:33 <hargettp> dmwit: ugh...really
19:26:34 <hargettp> ?
19:26:37 <dmwit> Yes, really.
19:27:02 <dmwit> If one of the two types (c or m) actually tells everything you need to know, you might like associated types.
19:27:04 <hargettp> dmwit: ruins the polymorphsim it would seem...is there a better way to go, to avoid such a thing?
19:27:34 <dmwit> For example, if you can always tell what m is given the type c, then you can do something like this:
19:28:02 <dmwit> class Chamber c where type Member c; members :: c -> [Member c]
19:28:08 <dmwit> etc.
19:28:12 <dmwit> ?wiki associated types
19:28:13 <lambdabot> http://www.haskell.org/haskellwiki/associated_types
19:28:29 <dmwit> hm
19:28:32 <dmwit> ?wiki type families
19:28:32 <lambdabot> http://www.haskell.org/haskellwiki/type_families
19:28:56 <hargettp> dmit: I had thought of using those, but had hoped to use a typeclass for member as well...although I confess the purpose I had in mind for it may not justify a whole typeclass by itself...
19:28:59 <dmwit> Without knowing a bit more about what you're trying to design, it's a bit tough to tell if that's a good idea, though. =P
19:29:04 <hargettp> :)
19:29:30 <dmwit> Are you sure you need a type class at all?
19:29:31 <hargettp> dmwit: I think you gave me the clue....writing members the way I did, I have to specify the type everywhere...and using a typeclass isn't enough :(
19:29:52 <hargettp> dmwit: for Member, no; but I was hoping not to have to decide right away
19:30:08 <hargettp> was going to wait until I understand how complex it needed to be before demoting it
19:30:08 <dmwit> Why don't you try writing the whole thing without type classes at all?
19:30:16 <dmwit> That sounds backwards to me.
19:30:27 <hargettp> dmwit: I come from a C++ world...giving up my objects and interfaces is hard :)
19:30:45 <hargettp> dmit: and I liked the interface qualities of typeclasses :)
19:30:47 <dmwit> You need not give up objects and interfaces. Type classes are not the only way to organize code.
19:31:01 <hargettp> dmit: i hear ya
19:31:03 <dmwit> "data" provides objects; module boundaries provide interfaces.
19:32:17 <dmwit> Type classes are only for times when you have a single name that you wish had multiple *different* implementations (at different types).
19:32:19 <hargettp> dmwit: i wonder if my flaw was defining members as a function that returned an array...perhaps it should have been a function that took ANOTHEr function as an arg, with the implication that it basically map'd over the members
19:32:31 <hargettp> dmwit: *returned a list,sry
19:32:51 <hargettp> dmwit: I do want multiple implementations...hence the typeclassing :)
19:33:53 <dmwit> I don't (yet) believe you.
19:34:01 <hargettp> :)
19:34:02 <dmwit> (Because I don't think you have even one implementation yet.)
19:34:18 <hargettp> dmwit: I do not...or at leasts, I did not include in the paste
19:35:06 <hargettp> dmwit: return type polymorphism...I suppose I should have realized that might be trouble, since it can be in other languages...any good guidance in the haskell world about it?
19:35:30 <mike-burns> Premature abstraction. Not that Haskell devs don't do that too.
19:35:40 <hargettp> :)
19:35:49 <dmwit> Use return-type polymorphic functions in contexts that restrict the return type a lot, or give them explicit type signatures.
19:35:58 <dmwit> Not much more guidance than that is really necessary.
19:36:08 <hargettp> dmwit: heh, in other words: don't use it here :)
19:36:28 <elliott> hargettp: You almost certainly don't want a typeclass here.
19:36:36 * elliott should define a macro to type that out for him.
19:38:54 <hargettp> :)
19:38:58 <dmwit> It's really unfortunate that the word "class" has such different meanings to mathematicians and to working programmers.
19:39:02 <hargettp> thx for the coaching...much appreciated
19:39:10 <jamiely> what's the easiest way to generate all permutations of a list?
19:39:18 <dmwit> If it weren't for that, perhaps fewer people would come from other languages and immediately start writing a dozen classes.
19:39:28 <dmwit> jamiely: import Data.List and use permutations
19:39:31 <jamiely> thx
19:39:31 <hargettp> dmwit: i really wanted the typeclass for its resemblance to an interface...or perhaps a mixin, in other languages....:)
19:40:00 <dmwit> Yes, I know. But that's not what a class is.
19:41:00 <hargettp> :)
19:42:01 * byorgey makes lambda-chip cookies for everyone
19:42:10 <dmwit> yum!
19:43:19 <dmwit> byorgey: I worked out what was weird with cabal and darcs.
19:43:19 <elliott> @botsnack
19:43:20 <lambdabot> :)
19:43:21 * DanBurton wonders what the occasion is
19:43:37 <byorgey> DanBurton: Friday
19:43:37 <elliott> it's haskell christmas. it happens in november because we avoid success at all costs
19:43:42 <byorgey> dmwit: oh? what was it?
19:43:42 <dmwit> Turns out that dependency conflicts can affect which flags are on (without reporting it in -v3).
19:43:45 <DanBurton> byorgey: :)
19:44:02 <byorgey> dmwit: hah! wow, that's a new one to me
19:44:08 <dmwit> There were two executables and one library being built, each with separate dependency lists, and protected by different flags.
19:44:11 * DanBurton proclaims Friday to be "Hindley-Milner day"
19:44:27 <byorgey> TGIHMD
19:45:01 <dmwit> The dependency lists weren't quite the same... and I wasn't explicitly asking for all the flags to be on. So cabal turned some of them off. =)
19:45:20 <byorgey> hehe, I see
19:45:30 <int-e> wth is tgi?
19:45:34 <byorgey> that's... rather helpful of it
19:45:42 <dmwit> int-e: Thank Goodness It's
19:46:03 <byorgey> int-e: "TGIF" is a common (American?) acronym meaning "Thank Goodness/God It's Friday"
19:46:07 <int-e> thanks
19:46:31 <dmwit> I still can't build it. GHC reports a kind error, and I sort of agree that the kinds look a bit off.
19:46:38 <dmwit> But that's not cabal's fault. =P
19:46:51 <byorgey> heh, I hope not
19:47:06 <dmwit> Well, it's not as obvious as you might think.
19:47:19 <dmwit> It also uses CPP, and the CPP #define's are not the same between all three artifacts.
19:49:03 <acowley> (How) can I use an instance of ArrowApply like an applicative? I want to write f <$> a <*> b, but all I've got are arrows.
19:49:20 <dmwit> ?src ArrowApply
19:49:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:50:54 <acowley> instances of the class provide a value app :: a (a b c, b) c
19:51:13 <byorgey> acowley: I think the Applicative instance is missing
19:51:21 <acowley> but I can't fight my way out of this paper bag
19:51:25 <byorgey> acowley: but there's an ArrowMonad wrapper that gives you a Monad instance
19:51:41 <acowley> ah!
19:51:44 <elliott> Presumably you could define your own Applicative.
19:51:55 <byorgey> acowley: so you can define  instance ArrowApply a => Applicative (ArrowMonad a) where  pure = return ; (<*>) = ap
19:52:21 <byorgey> acowley: then you get to wrap things of type  (a () b) in an ArrowMonad wrapper
19:52:39 <acowley> why does that type looks so strange to me?
19:53:05 <elliott> Is (() ~> a) better?
19:53:15 <elliott> It's (() -> m a).
19:53:54 <acowley> elliott: oh, yes, thank you!
19:54:11 <acowley> I keep parsing it as an infix application of () :/
19:54:25 <byorgey> that would explain why it looks strange to you =)
19:54:25 <monochrom> haha
19:55:14 <acowley> my parser needs work when it comes to arrows
19:55:31 <acowley> I've been using them a lot on a project, but I'm still swimming against the current
19:57:20 <augur> english speakers, is this an ok sentence: John will talk with Susan on Monday and will with Michael on Tuesday
19:57:36 <acowley> I'd use a comma
19:57:45 <augur> ok, but otherwise its ok?
19:58:02 <dmwit> "John will talk with Susan on Monday and with Michael on Tuesday."
19:58:02 <dmwit> or
19:58:05 <acowley> well, I can read it but I wouldn't say it
19:58:12 <Draconx> no, it's a run on, and adding a comma would result in a comma splice.  There's no verb in the second clause.
19:58:13 <dmwit> "John will talk with Susan on Monday, and will talk with Michael on Tuesday."
19:58:16 <augur> does it sound good
19:58:23 <rwbarton> it sounds rather bad to me
19:58:23 <copumpkin> he's a mad linguist! he's trying to figure out what people find accetpable
19:58:27 <augur> thats the question
19:58:30 <acowley> I would say what dmwit first suggested
19:58:32 <dmwit> augur: No, it doesn't sound good.
19:58:35 <augur> ok
19:59:05 <shachaf> augur hates it when people present corrected versions of his sentences.
19:59:08 <acowley> although I apparently accept comma splices demonstrating a distinct deficiency in verbage.
19:59:13 <augur> shachaf: :)
19:59:33 <augur> presenting a corrected version doesnt help
19:59:34 <copumpkin> he wants a
19:59:38 <elliott> augur is implementing English in Haskell.
19:59:42 <copumpkin> (s : Sentence) -> Dec (Sucks s)
19:59:49 <acowley> hahahaha
19:59:56 <dmwit> \s. True
20:00:12 <elliott> dmwit: Bool ~/~ Dec (Sucks s)
20:00:15 <augur> elliott: no no thats van Eijck and Unger
20:00:17 <dmwit> \s. s == readFile "Tale of Two Cities.txt"
20:00:20 <copumpkin> dmwit: you're going to need a proof of that
20:00:49 <elliott> A Tale of Two Cities is widely recognised to consist of a single sentence.
20:00:49 <augur> elliott: or at least semantics of English
20:00:55 <augur> and possible other languages
20:01:01 <augur> http://www.amazon.com/Computational-Semantics-Functional-Programming-Eijck/dp/0521760305
20:01:14 <dmwit> It is, admittedly, a somewhat longish sentence.
20:01:47 <elliott> With a lot of full stops.
20:02:13 <dmwit> It's carefully disguised Morse code.
20:02:50 * dmwit double-checks that Tale of Two Cities came after Morse code was invented
20:02:51 <acowley> Hidden message: There is actually only one city.
20:03:29 <dmwit> huh
20:03:38 <dmwit> TIL that a remote teletype predated Morse code
20:04:41 <dmwit> Kind of makes you wonder why Morse bothered to invent his code.
20:05:05 <augur> dmwit: did you know that morse's original design was a teletype machine?
20:05:20 <augur> but his co-designer insisted on making it a single-button machine
20:05:52 <augur> in principle, we could've had the internet in the late 1800s if teletype had become commonplace
20:05:54 <acowley> His co-designer was trying to keep costs down
20:06:05 <augur> acowley: probably true.
20:06:12 <dmwit> augur: Yeah, that's what I just discovered from Wikipedia. Kind of crazy.
20:06:23 <augur> ive been tempted, since highschool, to build an electromechanical storage and retrieval system
20:06:29 <acowley> That "discussion" must have been amazing to come to the compromise of 1 button.
20:06:37 <acowley> They were hipster Steve Jobs
20:07:14 <augur> that would read in electrical signals and then do some routing to load a punch tape
20:07:33 <augur> and then read it out to the requester
20:07:58 <augur> im pretty sure it would be doable with 1850s or 1860s electrical technology
20:08:08 <augur> could you imagine if we had done this back then?
20:08:46 <augur> the greeks had the technology to build steam engines but never thought to because of rampant slave labor making it unnecessary
20:09:43 <augur> they probably even knew they could do it. they used hydraulics all over the place, and know that steam could be used to impart motion to spin things
20:09:49 <mike-burns> If they had done this back then, this conversation we're having right now would have happened 100 years earlier instead.
20:10:02 <augur> im sure some of them, probably Heron, realized that he could stick a steam pipe into a piston
20:10:32 <monochrom> in fact, if they had done this back then, we would probably be speaking in Greek now
20:10:48 <mike-burns> Lambdas all over the place.
20:10:54 <byorgey> and people 100 years from now are going to wonder why we didn't invent frobjulating hypotransducers
20:10:59 <augur> in fact, if we were in greece, we would probably be speaking in Greek now
20:11:03 <byorgey> we had all the right pieces!
20:11:07 <dmwit> byorgey: Because we have such cheap oil.
20:11:14 <byorgey> probably.
20:11:41 <acowley> There *are* lambdas all here, so maybe the Greeks did invent the steam engine after all, and we're 100 years earlier than we think.
20:11:59 <augur> acowley: you're thinking of valis
20:12:59 <acowley> Actually, I was thinking of gyros (the food)
20:17:06 <PiRSquared17> @type const . const $ const
20:17:07 <lambdabot> forall b b1 a b2. b -> b1 -> a -> b2 -> a
20:17:50 <shachaf> @ty fmap const const const
20:17:51 <lambdabot> forall b b1 a b2. b -> b1 -> a -> b2 -> a
20:18:27 <dylukes> mike-burns: nah, we'd probably still have been set back by the dark ages.
20:18:44 <mike-burns> The great equalizer.
20:18:57 <dylukes> unless the industrial revolution happened in the 6th century BC.
20:19:04 <dylukes> Well, steam power at least.
20:19:15 <dylukes> Jesus was born on a blimp.
20:20:06 <dylukes> mike-burns: btw, Heron DID make a steam engine.
20:20:37 <mike-burns> Noted.
20:20:45 <acowley> so we are in the future
20:21:00 <acowley> and I get a gyro
20:21:05 <mike-burns> Everyone wins!
20:21:08 <dylukes> http://en.wikipedia.org/wiki/File:Aeolipile_illustration.JPG
20:21:10 <dylukes> this thing.
20:22:16 <dylukes> Of course most of his stuff was burned with Alexandria. :\ Sucks.
20:22:29 <byorgey> why is the description in Finnish and Turkish?
20:23:08 <hpaste> ybit pasted “zipWidth” at http://hpaste.org/54269
20:23:21 <jessopher> how do you profile when using cabal to build? I know you can do ./Setup.lhs configure --enable-executable-profiling, but then when i try to ./myexecutable +RTS -p it complains about -rtsopts not being used.
20:23:37 <jessopher> for haskell (:P)
20:23:40 <jessopher> err ghcv
20:29:48 <elliott> jessopher: --ghc-options="-rtsopts -prof -auto-all"
20:29:49 <elliott> sad but true
20:31:07 <jessopher> well if it works. Kind of a bummer though since it warns of -prof in ghc-options. There is no right answer
20:31:53 <elliott> It does?
20:33:12 <jessopher> it does for me, it says use --enable-executable-profiling instead, which doesnt include -rtsopts, so the executables wont output a profiling report
20:38:32 <acowley> Well, I still can't write my applicative style arrow code
20:38:53 <acowley> I will tuck my tail between my legs, write arr9 tomorrow, and never look at this module again
20:39:13 <jessopher> elliot: nevermind, I think its just because I was using 'cabal install' before and where i put the executable after building with profiling wasnt in my path, so it was using the old executable
20:39:42 <elliott> jessopher: heh, ok
20:47:41 <smoge> Hello
20:47:44 <smoge> Is there such a thing as a "Tree Comprehension" ?
20:48:40 <elliott> Well, if your tree is a monad...
20:48:44 <elliott> Then you could use monad comprehensions.
20:49:01 <acowley> I think I shall use the word "arrow" to mean "the opposite of sweet spot" from now on.
20:49:16 <smoge> could you sketch ot point out a monad comprehension?
20:49:34 <elliott> smoge: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html
20:49:40 <elliott> Search for /Monad comrephensions/.
20:49:52 <elliott> Sorry, *comprehensions.
20:50:00 <elliott> smoge: Needs GHC 7.2 or above.
20:50:03 <newsham> ?google comprehending monads
20:50:05 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.68.812&rep=rep1&type=pdf
20:50:05 <lambdabot> Title: Comprehending Monads
20:50:15 <mauke> how do you 'join' a tree?
20:50:19 <byorgey> smoge: if your tree is defined by  data Tree a = Leaf a | Node (Tree a) (Tree a), then you can make it a monad
20:50:39 <smoge> hum, very interesting
20:50:50 <elliott> mauke: depends on the type of tree :)
20:50:58 <smoge> I will need to install ghc 7.2 then
20:51:04 <byorgey> instance Monad Tree where return = Leaf; Leaf a >>= f = f a; Node t1 t2 >>= f = Node (t1 >>= f) (t2 >>= f)
20:51:04 <elliott> mauke: http://hackage.haskell.org/packages/archive/containers/0.4.2.0/doc/html/src/Data-Tree.html#Tree
20:51:07 <elliott> Data.Tree.Tree is a monad
20:51:18 <elliott> smoge: might be worth waiting until it's stable
20:51:24 <elliott> smoge: you can just use do notation in the mean time
20:51:27 <elliott> the translation is very simple
20:52:13 <mauke> elliott: that looks like it doesn't work
20:52:17 <smoge> I will have to study this
20:52:19 <smoge> elliott: thanks
20:52:23 <elliott> smoge: np
20:52:31 <elliott> mauke: report a bug? seems fine to me
20:52:31 <mauke> elliott: ah, no. my assumptions are broken
20:52:43 <elliott> what assumptions? :p
20:52:53 <mauke> data Tree a = Leaf | Node a (Tree a) (Tree a)
20:53:08 <mauke> vs. data Tree a = Node a [Tree a]
20:53:10 <elliott> right.
20:53:12 <byorgey> mauke: that one is trickier
20:53:13 <elliott> there are many trees :P
20:53:29 <newsham> hard to see the forest for the trees
20:54:30 <byorgey> mauke: see http://article.gmane.org/gmane.comp.lang.haskell.cafe/91287
20:57:07 <mauke> ah, interesting
20:58:28 <mauke> join (Node x l r) = graft (join l) (join r) x
21:02:09 <mauke> ok, so Tree1 takes the embedded tree as the new structure, then replaces all stumps by the (recursively processed) original subtrees
21:02:28 <byorgey> right
21:02:55 <mauke> Tree2 overlays the new and (processed) original subtrees, merging them with some "mappend"
21:03:01 <byorgey> yes
21:05:17 <acowley> byorgey: I couldn't see how to use ArrowMonad if all I've got is an "a b c"
21:05:49 <byorgey> acowley: well, first you've got to precompose it with an  a () b  in order to get an  a () c
21:06:24 <byorgey> which may or may not be possible depending on what you're doing.
21:07:13 <byorgey> acowley: are you allowed to show me the code?
21:07:15 <acowley> so if I have an x :: a b c, then I'd do constA >>> x >>^ ArrowMonad
21:07:15 <acowley> ?
21:07:23 <acowley> Oh, sure
21:07:36 <acowley> I actually just pulled this out as an exercise to try to improve some real code
21:07:57 <byorgey> something like that, yes
21:08:05 <PiRSquared17> @type \x -> const fix . const id
21:08:06 <lambdabot> forall t a b. t -> b -> (a -> a) -> a
21:08:31 <acowley> I just want to write something like, foo :: Arrow a => a b c -> a b d -> a b e -> (c -> d -> e -> f) -> a b f
21:08:46 <acowley> where "Arrow" may be somewhat fancier than Arrow
21:08:59 <byorgey> ah, I see
21:09:07 <elliott> you can do that, can't you? with arr
21:09:09 <acowley> Using ArrowList, one can write foo a b c d = a &&& b &&& c >>^ arr3 d
21:09:11 <elliott> i may be wrong though
21:09:17 <byorgey> I think perhaps the notation mm_freak was telling me about the other day might help.
21:09:32 <acowley> but that approach doesn't scale very well as it requires a hideous stack of arrX functions
21:09:56 <acowley> elliott: I had hoped so
21:09:58 <Axman6> :t arr3
21:09:59 <lambdabot> Not in scope: `arr3'
21:10:01 <byorgey> acowley: let me find it, just a sec
21:10:01 <Axman6> :\
21:10:15 <acowley> Axman6: It's in Control.Monad.ArrowList from hxt
21:10:28 <elliott> acowley: with arrows the secret is to tuple everything :P
21:10:31 <Axman6> arr3 :: Arrow arr => (a -> b -> c -> d) -> arr a (arr b (arr c d))?
21:11:08 <acowley> elliott: you're not kidding! But then we're back in direct analogy to zipWithN
21:11:26 <elliott> acowley: my solution to this pain is to avoid arros
21:11:27 <elliott> arrows
21:11:47 <acowley> Axman6: arr3 f = arr (\ ~(x1, ~(x2, x3)) -> f x1 x2 x3)
21:12:16 <shachaf> @arr3
21:12:17 <lambdabot> Yo ho ho, and a bottle of rum!
21:12:36 <acowley> elliott: That is my usual solution, too. But I always feel guilty about it, so I'm using hxt for this project. It provides some moments of joy interspersed among the misery :(
21:12:52 <byorgey> acowley: yes, there's this funny (| ... |) notation you can use which may do exactly what you want
21:13:02 <acowley> is that from SHE?
21:13:06 <byorgey> acowley: see http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html, although it isn't explained very well there
21:13:09 <elliott> No, it's a different thing for arrow notation.
21:13:11 <byorgey> acowley: no, it's in GHC!
21:13:14 <elliott> acowley: I haven't really felt restricted by avoiding arrows myself
21:13:34 <byorgey> acowley: you may have to read Paterson's paper, http://www.soi.city.ac.uk/~ross/papers/notation.html
21:15:53 <byorgey> acowley: hmm, I can't make heads or tails of it =(
21:15:57 <acowley> elliott: I agree, and this may be the last time I give arrows a serious go :/
21:16:05 <byorgey> acowley: you should ask mm_freak when he's around
21:16:16 <acowley> byorgey: I had been looking at those references earlier today, but I don't get the (| |) stuff
21:16:21 <acowley> byorgey: okay, will do
21:16:25 <byorgey> me neither
21:19:41 <miyako> I'm looking for a library to do weighted directed graphs, I found FGL- are there any others I should look at?
21:29:01 <acowley> miyako: FGL is a great place to start.
21:31:25 <miyako> acowley: I spent some time reading the fgl source, as well as the paper on inductive graphs, but I haven't really been able to fully understand it yet, I thought looking at a different implementation might help
21:31:53 <NemesisD> hi all. i'm trying to install yesod and it complains that http-enumerator seems to require a newer version of tls, yet yesod doesn't require http-enumerator
21:31:57 <acowley> miyako: one way of getting familiar with the design landscape is to try using something as straightforward as Map n [(n,Float)]
21:32:14 <NemesisD> is the solution to use cabal-dev i think it is, to isolate cabal dependencies per project?
21:32:14 <acowley> where n is your node type, and has an Ord instance
21:33:07 <acowley> NemesisD: if just installing yesod warns about http-enumerator, then it must be one of its transitive dependencies
21:34:18 <NemesisD> acowley: shoot. is there anything that can be done? hackage says it builds on 7.2
21:34:40 <miyako> I think the problem is I'm torn, on the one hand I need a working graph implementation to solve the problem I really need to solve, but I want to spend a lot of time researching different ways of making functional graphs
21:36:19 <acowley> NemesisD: well, do try cabal-dev!
21:37:38 <acowley> NemesisD: I don't know how cabal-dev will deal with a populated user package collection, but, worst case, you have to wipe out your user installs and use cabal-dev to install yesod on top of an empty database which will hopefully pull in compatible things
21:38:21 <NemesisD> well  it seems to be compiling *something*
21:38:28 <NemesisD> since its yesod i'm sure it will be done in half an hour :P
21:39:18 <acowley> miyako: I really enjoyed the FGL paper. It usually feels like there are as many graph representations out there (not so much in Haskell, but in programming in general) as there are problems that can be solved with graphs.
21:40:04 <acowley> miyako: All that said, if you read the FGL paper and think about it, I think you will have covered a useful chunk of the terrain.
21:40:14 <monochrom> go with FGL to get things done. it's likely good enough. do some research on the side.
21:40:34 <miyako> acowley: yeah, I've done a lot of work with graphs in C, and I did implement a DAWG in haskell a while ago, but looking back at my old code (I was much newer to haskell at the time) left me hating it and wanting something better
21:41:10 <acowley> miyako: Yeah, and I think that's a great place to be in to appreicate the FGL paper.
21:42:19 <miyako> acowley: yeah, I appreciated the paper, and really like the ideas, but looking at the code left me wondering why some things were implemented the way they were, I suspect primarily for performance
21:43:31 <miyako> I know in my implementation the complexity of all of my algorithms was approximately O(stupid)
21:44:56 <acowley> miyako: we call that O(prototype) in polite company
21:45:21 <miyako> acowley: I like that better :)
21:48:28 <parcs_> is hackage down for anyone else?
21:49:36 <miyako> well, thanks for the help all, I think I'll spend some time familiarizing myself with using fgl and then use it for my program then get around to writing my own graph implementation later when I have time
21:50:33 <acowley> parcs_: I think it's okay for me
21:50:35 <byorgey> parcs_: a bit slow perhaps, but it loads OK for me
21:51:17 <parcs_> hmm seems to be ok now. there was like a 3-minute period where i was receiving no response
22:15:33 <NemesisD> ooh god what a clusterF this is installing yesod with cabal-dev
22:20:48 <acowley> Yeah, installing the big web libraries is pretty hairy. I really hope we can find a way out of the current dependency version mess. I had been under the impression that cabal-dev basically makes things work, even if it is a bit brute force-ish.
22:24:21 <NemesisD> i pretty much spent the past few days reading the yesod book and now i can't do a damn thing with it
22:24:55 <acowley> I just wrote a line of code that begins "fmap (map (map...", so I'm going to bed
22:25:01 <acowley> NemesisD: what happened with the cabal-dev install?
22:25:07 <NemesisD> it is entirely likely i'm using cabal dev wrong. that  one blows up trying to install text, complaining that it could not find module Data.Text.Lazy and that there are files missing in the text package
22:25:59 <shachaf> acowley: You're right, "fmap (fmap (fmap..." is much better. You'll be refreshed enough to write proper Haskelly code tomorrow. :-)
22:26:18 <parcs_> "Load average: 390.53 111.42 39.06"
22:26:36 <dmwit> parcs_: O_o
22:26:48 <parcs_> thanks to +RTS -N1000
22:26:49 <acowley> NemesisD: That stinks. If it's not too painful, you might consider moving aside your ~/.cabal directory and starting over from scratch with cabal-dev.
22:27:16 <parcs_> i'm tempted to try -N10000
22:27:40 <NemesisD> acowley: i thought the point of cabal-dev was that it was supposed to operate without ~/.cabal
22:27:44 <acowley> shachaf: yes, I have an anachronistic tendency to use map when given a list and fmap for everything else
22:28:08 <acowley> NemesisD: I've not used it, but that is my understanding, too. I'm just wondering if having a ~/.cabal can interfere with it.
22:29:34 <NemesisD> well now its choking and talking about missing files  in parsec instead of text
22:29:51 <NemesisD> i wish i could say REINSTALL ALL OF THE THINGS until i get my yesod
22:29:57 <acowley> NemesisD: that kind of talk is usually enough to convince me to nuke everything
22:30:45 <acowley> And don't half-ass it, we're talking scorched earth here: pull your hard drive and throw it out the window.
22:31:29 <mauke> > delete 3 [1,3,2,3]
22:31:30 <lambdabot>   [1,2,3]
22:36:52 <mauke> overlap n xs = max 0 $ sum (map succ xs) + maximum xs - 1 - n
22:37:01 <mauke> still stuck, though :-/
22:40:19 <NemesisD> guh fml. i don't know how i can nuke cabal any harder
22:44:49 <tsaad> is anyone familar with the haskell snap framework?
22:45:33 <shachaf> tsaad: #snapframework is.
23:01:37 <clsmith> is it possible to ask ghci the type of a symbol in a let or where?
23:01:55 <shachaf> Not really.
23:04:02 <clsmith> :(
23:04:28 <DanBurton> it is possible to ask #haskell, though (via hpaste)
23:07:19 <clsmith> lol :) alright, one minute...
23:07:50 <NemesisD> anyone have experience with cabal-dev? im not sure how i'm supposed to use binaries installed with it
23:08:20 <NemesisD> i guess i can just do cabal-dev/bin/whatevr
23:09:33 <hpaste> clsmith pasted “nested monads” at http://hpaste.org/54272
23:10:00 <clsmith> so, i'm trying to (1) work out the type of g, and (2) derive fmap for Abst
23:10:14 <clsmith> can anyone help? :p
23:12:27 <augur> anyone speak french natively?
23:14:13 <companion_cube> augur: ask your question
23:14:15 <mauke> g <: (Monad m') => Maybe a' -> m' (Maybe b')
23:15:07 <mauke> ouch, nested data
23:16:04 <mauke> I don't understand how Abst works
23:16:14 <applicative> augur, you know about #haskell-fr ?
23:16:22 <clsmith> i'm modelling abstractions (de bruijn indices) using types
23:16:44 <clsmith> it's really interesting but it makes my mind cry :/
23:17:37 <mauke> why does Var contain an 'a'?
23:17:55 <clsmith> so because an abstraction lifts everything up one index, it has (Maybe a), which nest so that the Var a is of the correct variable index
23:18:42 <augur> applicative: :O
23:20:18 <clsmith> there's a paper by bird & paterson which explains it but in terms of mapB, mapP, and mapN or something. which just confuses me. so i'm trying to do it monadically
23:23:12 <mauke> Abst (Abst (Appl (Var (Just Nothing)) (Var Nothing)))
23:24:29 <clsmith> yeah, exactly
23:24:40 <mauke> fmap f (Abst x) = Abst (fmap (fmap f) x)
23:25:18 <clsmith> that's the ticket! couldn't work out what fmaps i needed :) thanks
23:26:02 <clsmith> any idea what the type of g is?
23:27:01 <mauke> the 'return' in line 20 should be Just
23:28:10 <clsmith> and on 19 i guess i'll make return Var. i think i was just being fancy and then got myself confused
23:28:26 <mauke> no, that 'return' is fine
23:28:33 <mauke> it refers to the Monad we're in
23:28:46 <clsmith> yeah, i guess
23:29:35 <mauke> g :: Maybe _a -> Term (Maybe _b)
23:30:09 <mauke> _a, _b external variables bound by (>>=)'s signature
23:34:33 <clsmith> is there a reason why i can't seem to annotate it with that type?
23:34:52 <mauke> you don't have a signature for >>=
23:34:53 <clsmith> also, i think i'll use liftM for simplicity of type
23:34:56 <mauke> and you need an extension
23:35:10 <mauke> liftM? where?
23:35:24 <clsmith> g (Just x) = liftM Just (f x)
23:36:26 <mauke> ah, right
23:36:30 <mauke> ScopedTypeVariables
23:45:37 * hackagebot cblrepo 0.4.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.4.0 (MagnusTherning)
