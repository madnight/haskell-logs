00:27:59 <Sgeo|chromcrash> Are HList-based keyword-argumented functions at all common?
00:28:11 <shachaf> I've never seen one used.
00:33:16 <Sgeo|chromcrash> Would it be preferred to make a function take a list of a certain datatype that represents possible options?
00:33:22 <Sgeo|chromcrash> Or is HList acceptable>?
00:34:19 <djanatyn> hmm, so the type for return is "return :: Monad m => a -> m a
00:34:44 <djanatyn> did it used to be "return :: a -> IO a"?
00:34:52 <djanatyn> or is that the same thing, maybe?
00:34:55 <shachaf> Sgeo|chromcrash: HList is kind of weird.
00:35:02 <shachaf> djanatyn: I doubt it. Maybe in the really early days.
00:35:15 <shachaf> a -> IO a unifies with Monad m => a -> m a.
00:35:25 <shachaf> Sgeo|chromcrash: As a dependency for your package, I mean.
00:35:34 <djanatyn> that's how SPJ described return's type as the latter in his paper, "Beautiful Concurrency"
00:35:40 <Sgeo|chromcrash> djanatyn: a -> IO a is a specialization of Monad m => a -> m a
00:35:47 <djanatyn> and I just checked it in ghci and it wasn't the same
00:35:48 <djanatyn> ah, okay
00:36:13 <Sgeo|chromcrash> That Monad m means that m is a ... not sure the right word, but it can take anything that is of the Monad class
00:36:16 <Sgeo|chromcrash> Which includes IO
00:36:30 <djanatyn> maybe I should read more and come back to this later
00:36:50 <shachaf> djanatyn: You should understand type classes, yes.
00:37:02 <shachaf> djanatyn: For now you can pretend that return :: a -> IO a, if you really need to use it.
00:52:14 <Sgeo|chromcrash> Why does no one ever mention that you can set RTS options at compile-time?
00:53:50 <shachaf> Why does no one ever mention that Kazakhstan is bigger than Greenland?
00:54:51 <zygoloid> it's mostly uninhabited, though
00:55:57 <shachaf> "mostly uninhabited" isn't good enough for Curry-Howard.
01:13:11 <hpaste> Gavri pasted “cabal install statistics” at http://hpaste.org/53955
01:13:31 <gavri> anyone know what I should do to fix this?
01:14:52 <shachaf> gavri: You should probably figure out why deepseq-1.1.0.2 was selected instead.
01:15:20 <gavri> shachaf: is there an alternative to cabal. something hacky that works?
01:15:35 <shachaf> An alternative to cabal?
01:15:49 <shachaf> Does "cabal" mean Cabal or cabal-install?
01:15:56 <gavri> Cabal
01:16:17 <gavri> I'd just like to use that library. could I just copy it over to my directory and load it or something?
01:16:56 <gavri> I typically manage to get 1 in 5 haskell libraries installed through cabal. and this is over the last few months, with ubuntu 11.04 and ubuntu 11.10
01:17:21 <shachaf> Odd; it hardly every doesn't work for me.
01:17:25 <gavri> hoping I could stay away from cabal for a while. I just want to explore a few haskell libraries
01:17:27 <shachaf> s/ry/r/
01:18:32 <gavri> I haven't really tried to fix things. I've usually tried to reinstall the haskell-platform package
01:18:50 <gavri> which wasn't working at all with 11.04 for months, btw
01:19:03 <Veinor> gavri: cabal install containers-0.3.0.0
01:19:19 * shachaf just installs GHC (and haskell-platform) directly instead of using the Ubuntu packages.
01:19:28 <Veinor> also, yeah, what shachaf said
01:19:45 <shachaf> What Veinor said.
01:20:26 <gavri> cabal install containers-0.3.0.0 didn't help is this case. same error with "cabal install statistics"
01:20:40 <Sgeo|chromcrash> "If you're feeling really paranoid, the -dcore-lint option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC's sanity, not yours.)  "
01:20:47 <gavri> have to rush out for a bit. sorry about bringing this up and just leaving. I'll be back in an hour
01:20:47 <Veinor> what, really? weird
02:09:57 <Peaker> gavri: did you get help with your cabal install issues?
02:10:49 <Peaker> I have a bunch of techniques I use to trick cabal-install into doing the sensible thing.. usually involving finding whose package conforms to the PvP thereby destroying all chances of success :) And then deleting its upper constraints, then usually all is good
02:11:12 <Peaker> (most packages conform to the PvP and that tends to break things when new packages are available)
02:21:21 <Sgeo|chromcrash> PvP?
02:21:51 <Sgeo|chromcrash> Oh
02:33:00 <Sgeo|chromcrash> Are there monads other than IO which have no transformer version?
02:35:54 <Saizan> ST, STM
02:37:15 <bxc> writing code like this:
02:37:16 <bxc>     return $! (sf `seq` mean `seq` dev `seq` (sf, MkParticipantScore mean dev))
02:37:34 <limansky> Hi all. Could anybody help me with Data.Binary.Get? I'm going to write parser for one binary format. It's not clear for me how to handle errors properly.
02:37:38 <bxc> because i want to force those three expressions in the return tuple, which massively decreases memory use
02:37:51 <bxc> is that the right style? (for some definition of "right") ?
02:39:20 <Veinor> i think the answer is to write f !sf !mean !dev = (sf, MkParticipantScore mean dev) and then return $! f sf mean dev
02:39:23 <Veinor> or something
02:39:35 <ddarius> bxc: Usually you want evaluate.
02:40:05 <ddarius> limansky: Binary doesn't really have a good means for handling errors.  You may want attoparsec.
02:40:55 <ddarius> Alternatively, I hear cereal handles errors slightly better.
02:41:22 <limansky> ddarius: thanks, I'll take a look on it.
02:45:25 <bxc> ddarius: what do you mean evaluate?
02:45:46 <bxc> Veinor: yeah that looks nice - i only just discovered about !arguments to functions
02:46:33 <ddarius> :t evaluate
02:46:34 <lambdabot> Not in scope: `evaluate'
02:46:39 <ddarius> @hoogle evaluate
02:46:39 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
02:46:40 <lambdabot> Control.Exception evaluate :: a -> IO a
02:46:40 <lambdabot> Control.OldException evaluate :: a -> IO a
02:47:34 <ddarius> If it's not IO, though, then it isn't really relevant.
02:47:44 <bxc> it is in IO
02:48:38 <ddarius> Admittedly, evaluate is more about having exceptions occur at the right time.
02:49:27 <bxc> docs says that only goes to WHNF though
02:49:33 <bxc> which is not enough for the example above I think?
02:49:45 <ddarius> bxc: It would only replace the 'return $!' part.
02:49:46 <bxc> (it will leave the mean and dev thunks as thunks?)
02:49:49 <bxc> right
02:50:15 <bxc> or something like DeepSeq I suppose?
02:50:40 <ddarius> Don't use DeepSeq.  The code you have is reasonable, though perhaps switching to a strict pair type would make sense.
03:00:18 <mah_b> hi, how can I disable the monomorphism restriction in ghci?
03:00:43 <Jafet> :s -XNoMonomorphismRestriction
03:01:18 <Jafet> Or echo ':s -XNoMonomorphismRestriction' >> ~/.ghci
03:11:13 <gavri> Peaker: PvP?
03:12:05 <gavri> Veinor: yeah, "cabal install containers-0.3.0.0" didn't help. I get the same error when I try "cabal install statistics" :(
03:13:35 <bxc> if I say (in an IO monad) let l = unsafePerformIO a then does the evaluation of a get deferred until someone tries to actually read the value l?
03:14:26 <bxc> (the context is that I have a list of files that is used 0, 1 or 2 times depending on the user's chosen mode for my code, and I want to cache the result of reading the file list if its used twice, but not list at all if its never used)
03:18:09 <kstt> concurrency question : let's say I'm writing a cannonical multi-clients server, which 'accept' on a listening socket, then forkIO the accepted connection to the client handler. That's beautiful programing, by the way. Now lets say that my server must be gracefully reloaded, which implies that it must stop listening on the incoming socket. I'm having trouble at exressing that "(conn, _) <- accept sock" must give up on an external even
03:18:09 <kstt> (the event would probably be a MVar () being filled).
03:18:59 <_oz> bxc: is this not a valid use case for unsafeInterleaveIO instead?
03:19:45 <_oz> you say "l <- unsafeInterleaveIO a" and a won't be run if someone doesn't try to read the value l.
03:22:22 <bxc> _oz: yes thats pretty much what I want, i think
03:49:39 <vanessa> http://b39b5112.whackyvidz.com
03:50:09 <Veinor> that seems like a safe and reasonable link to click on!
03:56:07 <Peaker> gavri: the Package Version Policy, which I think is a big mistake -- along with cabal preferring to reinstall the earth and refuse to build 90% of the time -- rather than succeed 90% of the time, at the price of getting rare build errors
03:57:01 <Peaker> the whole approach causes older-than-newest packages to be installed alongside the newest ones, and butterfly effects (reinstalling same package, same version, because of different dep. version, which overwrites the older install and breaks all reverse-dependencies)
03:57:02 <gavri> Peaker: so what do you typically do when a package fails to build?
03:57:16 <Peaker> gavri: remove the conservative version constraints that make it fail
03:57:24 <Peaker> gavri: but first, need to discover what those are
03:57:30 <Peaker> gavri: I can walk you through it if you want
03:57:43 <gavri> Peaker: cool, thanks
03:58:23 <gavri> Peaker: I'm stuck here http://hpaste.org/53955
03:58:37 <Peaker> gavri: try: cabal install statistics --constraint="deepseq >= 1.2"
03:59:16 <Peaker> gavri: also you can add -v to your install commands
03:59:58 <Peaker> gavri: what error do you get from that?
04:00:06 <Peaker> gavri: (preferably with -v too)
04:00:17 <gavri> http://hpaste.org/53957
04:00:23 <gavri> Peaker: ^^
04:01:59 <Peaker> hmm.. where did he disappear to?
04:02:48 <gavri> Peaker: I hope I didn't miss anything. I had to reconnect
04:03:09 <Peaker> gavri: try to "cabal unpack deepseq" (it will extract into deepseq in your cwd)
04:03:47 <gavri> $cabal unpack deepseq
04:03:47 <gavri> Downloading deepseq-1.2.0.1...
04:03:47 <gavri> Unpacking to deepseq-1.2.0.1/
04:03:48 <sipa> roconnor: you're right, the high bit is just a sign, it's not 2's complement
04:04:21 <Peaker> gavri: whoops, I meant unpack monad-par
04:04:43 <Peaker> gavri: then edit the .cabal file in there
04:05:23 <Peaker> gavri: change the version field of monad-par from 0.1.0.1 to 0.1.0.1.1 (so cabal uses your version and ignores the one in the repos), and change the line "deepseq >= 1.1 && < 1.2," to "deepseq >= 1.1"
04:05:39 <Peaker> gavri: then use "cabal install" when inside the monad-par extracted dir
04:06:20 <Peaker> gavri: you with me?
04:08:23 <hpaste> Gavri pasted “cabal install” at http://hpaste.org/53958
04:08:52 <gavri> Peaker: yeah, I have an ExitFailure now. this is how my cabal installs usually fail, btw
04:09:05 <gavri> so, progress I guess? :P
04:09:38 <Peaker> gavri: hmm... What does  "ghc-pkg check" say?
04:10:36 <hpaste> Gavri pasted “ghc-pkg check” at http://hpaste.org/53959
04:10:48 <gavri> Peaker: ^^
04:11:21 <Peaker> gavri: did you manually mess with the files in ~/.cabal ?
04:12:12 <Peaker> gavri: you can try: "ghc-pkg unregister <pkg>" for <pkg> in each of the broken packages in the bottom of that list
04:12:13 <gavri> Peaker: I deleted the .cabal directory an hour or so ago and reinstalled haskell-platform,  but I've been getting ExitFailures (which I guess is a generic error) for a long time
04:12:39 <gavri> Peaker: I don't mind cleaning out everything and starting from scratch
04:12:41 <Peaker> gavri: any idea how those files would be missing? I've never seen that error before
04:12:43 <gavri> is that possible?
04:12:54 <Peaker> gavri: yeah, do you have a system-wide install of Haskell/ghc, or just a home-dir-based one?
04:13:29 <gavri> I installed the haskell-platform package, but my cabal installs are usually run without sudo. I don't know what the consequences of either of those are
04:16:13 <AfC> gavri: if you run
04:16:18 <AfC> $ ghc-pkg list
04:16:42 <AfC> gavri: you'll find out what you're getting from system packages and what you're getting from local user packages
04:17:47 <hpaste> Gavri pasted “ghc-pkg list” at http://hpaste.org/53960
04:18:37 <gavri> AfC: ^^
04:18:38 <Peaker> gavri: basically, you have "global" packages (e.g: in /var/lib/ghc-*) and "user" packages (~/.cabal)
04:18:59 <Peaker> gavri: and it's generally considered a bad idea to "shadow" global packages with user copies of those same packages (esp. of same version)
04:19:19 <gavri> Peaker: should I be running cabal install with sudo then?
04:19:46 <Peaker> gavri: no -- just make sure you don't let global package be reinstalled as user packages -- when they do, it's typically because some lower dependency of them is constrained to be a lower version
04:20:15 <Peaker> gavri: then you can tell which lower package by using "cabal install --dry-run -v <pkg that caused it>" and see why it chose to reinstall the system package
04:20:39 <Peaker> gavri: then you can use:   cabal install --constraint="lower == <version currently installed and used by the system package>"
04:20:59 <gavri> I have to head out right now. sorry about this, I probably should have been asking these questions when I had freed up a block of time
04:21:06 <Peaker> gavri: then cabal will tell you which package has the stupid constraint causing the problems, you can go "cabal unpack" that, and increase the version number slightly and remove the conservative constraint
04:21:22 <Peaker> gavri: ok, when you return try this sequence of "tricks" - it always works for me
04:21:25 <gavri> I'll be back in a couple of hours. thanks for all the help, Peaker et al
04:21:29 <gavri> Peaker: thanks
04:25:24 <kstt> I can't find a way to convert a Char literal to a Word8, for bytestrings
04:25:43 <kstt> I could pack a singleton and call head on it, but ... pfiu ...
04:26:36 <ion> @type ord
04:26:37 <lambdabot> Char -> Int
04:26:46 <ion> @type fromIntegral . ord
04:26:47 <lambdabot> forall b. (Num b) => Char -> b
04:29:27 <yitz> kstt: a Char is a Unicode character. to make it bytes, you have to encode it. which encoding do you want?
04:29:52 <yitz> kstt: the types being different is intentional - it's giving you that message
04:30:49 <kstt> that's great, but I'm ok with the ByteString.Char8 assumption that the char represent a Word8
04:30:52 <yitz> kstt: if you are certain that this Unicode character happens to be an ASCII character, use ion's hack to encode.
04:31:06 <kstt> I'll use it, thanks for the notice
04:31:14 <kstt> again, it's a literal
04:31:44 <yitz> kstt: oh then use Char8.pack
04:32:03 <troydm> ok ppl look at this
04:32:05 <troydm> http://hpaste.org/53961
04:32:34 <troydm> now how do i write maxFromWriter function that would give me maximum number from Writer [Int] list
04:33:09 <troydm> cause what i have now is that foldr1 max w  where w is always []
04:36:05 <yitz> troydm: you don't want to use runWriter inside something whose return type is Writer.
04:36:34 <yitz> troydm: runWriter is used the other way around, for feeding in a Writer
04:37:14 <yitz> troydm: and getting the result of its calculation with a given initial state
04:37:24 <troydm> yitz: can you rewrite my example?
04:37:54 <_oz> troydm: can i ask, what do you actually want to do?
04:38:06 <yitz> troydm: what have you read about the Writer monad so far?
04:38:56 <troydm> well i've read something but i don't quite get it
04:39:19 <troydm> i want to get max value from inside Writer [Int
04:39:57 <_oz> troydm: in that case, i think thinking about the type of that function might help
04:40:21 <ion> λ> let tellMP = tell . MaxPriority . Just in runWriter (tellMP 2 *> tellMP 1 *> tellMP 4 *> tellMP 3 *> return "foo" :: Writer (MaxPriority Integer) String)
04:40:24 <ion> ("foo",MaxPriority {getMaxPriority = Just 4})
04:40:29 <_oz> what about, maxFromWriter :: Writer [Int] a -> Int
04:40:47 <ion> Just use a monoid that computes the maximum.
04:41:03 <troydm> _oz: hmm, so feeding it monad of writer and then getting result
04:41:09 <ion> http://hackage.haskell.org/packages/archive/monoids/0.2.0.4/doc/html/Data-Monoid-Ord.html
04:42:00 <yitz> troydm: Writer is "write-only" state. it records things as you go along during a calculation. you can't read what you've written during the calculation.
04:42:18 <alistra> > λx -> x
04:42:19 <lambdabot>   <no location info>: parse error on input `->'
04:42:24 <troydm> yitz: but how do i use that record later?
04:42:26 <alistra> > λx. x
04:42:27 <lambdabot>   Not in scope: `
04:42:33 <alistra> > λx.x
04:42:34 <lambdabot>   Not in scope: `
04:42:40 <alistra> > (λx.x) 5
04:42:41 <lambdabot>   Not in scope: `
04:42:42 <ion> You get it from runWriter in the end.
04:42:47 <troydm> yitz: ohh i kind a get it
04:43:13 <yitz> troydm: once you have the entire Writer built that you want to use, you apply runWriter to get the result of the calculation, plus whatever was recorded along the way.
04:43:18 <troydm> also What's the difference between State and Writer monads?
04:43:24 <ion> If you want the maximum and not the full list, use a maximum monoid and not the list monoid.
04:43:44 <opqdonut> troydm: in Writer the "state" doesn't influence the computation
04:43:50 <opqdonut> it's output-only
04:44:21 <troydm> opqdonut: if i rewrite this example to use State
04:44:24 <opqdonut> so it's mostly for building some thing (e.g. a string) in pieces
04:44:39 <troydm> opqdonut: than i might get intermediate values from state during computation?
04:44:40 <_oz> ion: what if he wants not only the maximum but also other things from the list?
04:44:44 <opqdonut> troydm: right
04:44:48 <yitz> troydm: right, like ion says, if you really don't want to remember all of the values, just take the maximum as you go along by using a maximum monoid as the type you are recording instead of a list.
04:45:29 <ion> oz: Then use the (,) monoid instance.
04:45:35 <troydm> whole monoid programming staff takes time to get used to, i'm getting confused along the way
04:45:56 <_oz> ion: I see.
04:48:14 <ion> λ> let tellMP = tell . liftA2 (,) pure (MaxPriority . Just) in runWriter (tellMP 2 *> tellMP 1 *> tellMP 4 *> tellMP 3 *> pure "foo" :: Writer ([Integer], MaxPriority Integer) String)
04:48:18 <ion> ("foo",([2,1,4,3],MaxPriority {getMaxPriority = Just 4}))
04:49:50 <yitz> ion: is λ your local λ-bot?
04:50:08 <ion> Yes, a.k.a. ghci
04:50:41 <yitz> ion: ah so :set prompt "λ>"
04:50:56 <yitz> cute
04:51:00 <ion> yeah
04:52:00 <yitz> ion: i should change the font that urxvt is using by default. otherwise that would be too ugly for me.
04:54:18 <Veinor> i should hack on my .ghci
04:56:14 <yitz> Veinor: to start with, :set -XNoMomomorphismRestriction
04:59:16 <troydm> http://hpaste.org/53962
04:59:32 <troydm> what does `Writer' is applied to too many type arguments
04:59:34 <troydm> mean?
05:00:10 <_oz> troydm: that it was applied to too many type arguments
05:00:18 <_oz> 3 instead of 2 in this case
05:00:45 <troydm> should i write: Writer (Max Int) Int instead?
05:01:11 <_oz> troydm: yes
05:01:17 <Veinor> troydm: what is Max in this case?
05:01:34 <troydm> Max monoid from Data.Monoid.Ord
05:01:43 <Veinor> ahh
05:01:49 <_oz> troydm: you import it from Data.Monoid.Ord, you can check it from there
05:06:44 <hpaste> “Tom van der Zanden” pasted “segmentation fault/access violation” at http://hpaste.org/53963
05:07:11 <TomvdZ> I was wondering if anyone could help me on that piece of code. It's not behaving as expected and warning me of a sementation fault/access violation
05:09:43 <ddarius> TomvdZ: Use forkOS in guiPoker and see if that helps.
05:11:48 <TomvdZ> Thanks! That worked.
05:12:14 <TomvdZ> So why did it work? Does forkIO create a thread and forkOS a process?
05:12:28 <opqdonut> forkIO creates a "green" thread
05:12:34 <opqdonut> and forkOS creates a real actual thread
05:12:35 <kk`> forkOS creates an OS thread
05:16:33 --- mode: verne.freenode.net set +o Igloo
05:16:34 --- mode: verne.freenode.net set +o ChanServ
05:21:06 <ddarius> TomvdZ: forkOS doesn't create another process, that would break even more, forkOS behaves just like forkIO except that all FFI calls will happen in the same OS thread.
05:21:41 <ddarius> However, what you should really be doing is making sure all GTK interactions happen in the same thread.
05:23:47 <TomvdZ> So the preferred approach would be to create a timer in the GUI that polls the server for new messages?
05:28:54 <troydm> what does title@(_:_) in matching means/
05:28:56 <troydm> ?
05:29:55 <ClaudiusMaximus> > case "foo" of a@(b:c) -> (a, b, c)
05:29:56 <lambdabot>   ("foo",'f',"oo")
05:30:28 <ziman> the name before the @-sign becomes an alias for the whole pattern; "title@(_:_)" means "match a nonempty list and call it 'title'"
05:31:06 <troydm> ok thx ppl
05:31:11 <peikos> hello all
05:31:46 <ddarius> TomvdZ: No, just ship any GTK interactions that need to happen back to the thread that started GTK.
05:33:15 <ClaudiusMaximus> TomvdZ: http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-General-General.html#v:postGUISync might be useful
05:35:38 --- mode: verne.freenode.net set +o Igloo
05:41:20 <peikos> say I have a function f id (Container _ ids] :: id -> (Container id) -> (Container id), where Container id = for all id. Eq id => Container [Int] [id] — how can I use `elem` on id and ids without ghc telling me it can't deduce id ~ id1? I would like to tell the compiler id must be equal to id1, how can I do this?
05:42:17 <Saizan> remove "forall id." from the definition of Container
05:44:07 <peikos> thanks, miraculously my code must have stopped needing forall during my experimentations.. this makes everything a lot easier, thanks
05:49:46 <Saizan> you might also consider removing the Eq id => part and having that just as a constraint on functions that need it
05:56:27 <hpaste> paolino pasted “impredicatives in the way” at http://hpaste.org/53966
05:58:35 <paolino> hello, I have this piece of code which compiles well. Now I would like to store a list of Selectors Tree b at iselectors field, but I don't know if it's a [forall b. Selector Tree b] or forall b . [Selector Tree b]
05:59:27 <paolino> and, anyway I do I cannot make it  compile , the ricentra function
06:01:36 <paolino> to me the forall b . [Selector Tree b] is correct because I will use them with map on a specific b.
06:04:10 <paolino> but if I try "isels' = map (moveSelector ifig (forw . irev)) isels", ghci complains
06:04:11 <paolino> Expected type: [forall b1. Selector Tree b1]
06:04:11 <paolino>       Actual type: [Selector Tree b0]
06:04:11 <paolino>     In the second argument of `map', namely `isels'
06:06:18 <Saizan> what the type of moveSelector?
06:06:24 <Saizan> *what's
06:09:09 <iboB> what's the best way to remove the n-th element from a list?
06:09:24 <paolino> splitAt
06:09:34 <paolino> and (++)
06:10:03 <iboB> thanks paolino
06:10:16 <paolino> Saizan: moveSelector ∷ (Functor t, Foldable t, Traversable t, Zip t)
06:10:16 <paolino>     ⇒ t a → (forall a . t a → t a) → (forall b . Selector t b)  →  Selector t b
06:10:27 <ion> > uncurry (++) . second (drop 1) . splitAt 5 $ [0..10]
06:10:29 <lambdabot>   [0,1,2,3,4,6,7,8,9,10]
06:10:47 <ddarius> iboB: That's not an efficient operation for long lists, so if it is something you are going to be doing a lot, you might want to consider a different data structure.
06:11:13 <iboB> well the lists i'm talking about are very short, so it'll do
06:11:22 <iboB> thanks
06:13:33 <paolino> Saizan: Do I need to give a signature to map ?
06:14:21 <Saizan> paolino: nope. you'd have to write a conversion function :: forall b. [Selector t b] -> [forall b. Selector t b] to apply to isels
06:14:33 <Saizan> err
06:14:48 <paolino> the other way around
06:14:52 <Saizan> (forall b. [Selector t b]) -> [forall b. Selector t b] <- i mean this
06:16:23 <paolino> mh, but that would produce a [forall b. Selector t b] after mapping ?
06:18:13 <ddarius> Saizan: That would be an atrocious function.
06:19:14 <Saizan> it loses information but it's not that bad, mostly because of parametricity
06:19:39 <Saizan> well, actually, i'm not sure about the losing part
06:20:37 <ddarius> It doesn't lose information, it's much easier to go the other way.
06:21:08 <Saizan> yeah
06:21:10 <ddarius> But take the perspective of explicit type lambdas and think about how you'd have to implement that to achieve the type promised by the output.
06:21:21 <ddarius> It's doable, but it ain't pretty.
06:22:03 <Saizan> yup, you apply it to something, check if it's empty, otherwise compose with head, recurse
06:23:47 <paolino> Saizan, it's a new map ?
06:24:19 <ddarius> Saizan: But when you recurse you need to apply it to another type, and traverse to the corresponding element.
06:24:48 <Saizan> ddarius: compose with tail?
06:25:05 <Saizan> but yeah, i guess you wouldn't manage any sharing
06:26:41 <Saizan> anyhow unless we do this we'd have to look inside moveSelector to tell if it really needs the higher rank (forall b . Selector t b) argument
06:27:06 <ddarius> I'm fairly suspicious of all these types to be frank.
06:27:12 <Saizan> yeah
06:28:17 <ddarius> f ss = zipWith (\i _ -> /\b. ss @ b !! i) [0..] (ss @ ())
06:28:51 <Saizan> paolino: sticking with [forall b. Selector t b] as the type of the iselectors field looks like the best of the two options
06:29:11 <paolino> but it complains the other way around
06:29:41 <PiRSquared17> @pl ($) (^)
06:29:41 <lambdabot> (^)
06:30:00 <paolino>    Expected type: [forall b. Selector Tree b]
06:30:00 <paolino>       Actual type: [Selector Tree b0]
06:30:00 <paolino>     In the second argument of `IFigura', namely `isels''
06:30:00 <paolino>     In the expression: IFigura ifig' isels' backw
06:30:31 <Saizan> paolino: try with forall b. Selector t b as the return type of moveSelector (hoping ghc won't float that upwards)
06:31:08 <ddarius> f ss = g (ss @ ()) ss where g [] _ = []; g (_:ss') ss = (/\b. head (ss @ b)) : g ss' (tail . ss)
06:31:43 <paolino> Saizan: nothing changed
06:31:50 <ddarius> Saizan: That's logically equivalent to the current type.
06:32:05 <Saizan> ddarius: i know
06:32:28 <ddarius> It would be a bug if GHC treated those types differently.
06:33:00 <paolino> I see if I can avoid the rank2 in moveSelector
06:33:00 <hpaste> TimP pasted “Type problem” at http://hpaste.org/53967
06:33:05 <Saizan> ddarius: there's lots of stuff like this going on with impredicativity
06:33:45 <PiRSquared17> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in take 100 fibs
06:33:46 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:34:13 <timp> I can't figure out why the actual type I am getting is not the desired one in http://hpaste.org/53967
06:35:31 <ddarius> timp: The code you pasted shouldn't even type check.
06:35:50 <ddarius> I think you mispasted it.
06:36:19 <timp> I have not posted the whole, ie the definition of sequ
06:36:33 <ddarius> You haven't pasted the whole definition of consume.
06:36:55 <ddarius> You probably think you did, but you didn't.
06:37:07 <PiRSquared17> > let fibs = 0: 0 : 1 : (zipWith (+) fibs (zipWith (+) (tail fibs) (tail (tail fibs)))) in take 100 fibs
06:37:08 <lambdabot>   [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890...
06:37:09 <timp> ddarius, sorry, you areright
06:37:56 <sipa> > let fibs = fix $ (0:) . scanl (+) 1 in take 10 fibs
06:37:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
06:38:09 <ddarius> At any rate, I'm pretty sure the missing code is passing a call to consume to the second argument of conj.  Since both calls would return a 'c', but the first argument is a 'b' that means b ~ c.
06:38:16 <hpaste> TimP pasted “Type problem” at http://hpaste.org/53968
06:40:25 <timp> ddarius, thanks, sometimes you just need to make a fool of yourself in public for the penny to drop
06:41:38 <ddarius> conj (consume f conj (consume f conj deflt l) r) should have the right type, but it won't be as parallel.
06:41:51 <ddarius> Er get rid of the leading conj.
06:43:40 <hpaste> paolino pasted “rank2 and lists” at http://hpaste.org/53969
06:44:44 <paolino> Saizan, ddarius: I pasted also moveSelector implementation, because I didn't manage to avoid the rank-2
06:45:06 <ddarius> If you flip the last two arguments you get: consume _ _ Empty = id; consume f conj (Single x) = conj (f x); consume f conj (Cat l r) = consume f conj r . consume f conj l
06:45:13 <ddarius> Which is nicely homomorphic.
06:46:01 <timp> yes, nice,
06:47:11 <Saizan> paolino: use Selector t Bool instead
06:48:04 <ddarius> (== True) = id
06:48:09 <paolino> saizan: but how I make it back to Selector t b
06:48:51 <Saizan> paolino: mkSelector manages to do that just fine by looking at its type signature
06:51:50 <Veinor> ddarius: is that actually true in the presence of various bottom-likes?
06:52:19 <ddarius> Yes.
06:52:29 <ddarius> They are both strict.
06:52:50 <sipa> (undefined == true)  =  id undefined  = undefined
06:53:02 <sipa> right?
06:55:13 <paolino> Saizan: thanks, I must figure out why it works, but it does
06:55:32 <incluye> @pl \a b -> concat $ intersperse b a
06:55:32 <lambdabot> (join .) . flip intersperse
06:55:43 <incluye> @pl \a b -> concat $ intersperse a b
06:55:43 <lambdabot> (join .) . intersperse
06:55:47 <incluye> huh
06:56:12 <ddarius> intercalate
06:56:25 <incluye> oh okay
06:57:52 <jerry> does function "sepBy1" returns separator string or it doesnt
06:58:24 <paolino> @hoogle sepBy1
06:58:24 <lambdabot> Text.ParserCombinators.ReadP sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
06:58:24 <lambdabot> Text.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
06:58:24 <lambdabot> Text.ParserCombinators.Parsec.Combinator sepBy1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m sep -> ParsecT s u m [a]
06:59:32 <byorgey> jerry: no
06:59:49 <jerry> byorgey: ok thank you
07:01:51 * ddarius considers making a linear algebra introduction for people with a computer graphics background but aiming at things like Fourier analysis.
07:07:00 <mysticc> @pl \a -> [a]
07:07:00 <lambdabot> return
07:07:11 <mysticc> @pl \a -> [a,a]
07:07:12 <lambdabot> ap (:) return
07:07:16 <mysticc> @pl \a -> [a,a,a]
07:07:16 <lambdabot> ap (:) (ap (:) return)
07:07:36 <mysticc> @hoogle ap
07:07:37 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:07:37 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:07:37 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
07:07:43 <jpcooper> hello
07:08:02 <mysticc> jpcooper: hey
07:08:18 <jpcooper> I'm trying to do cabal install --reinstall -p text on Arch Linux with Haskell 7.0.3. I'm getting an ExitFailure 9, though. Does anyone have a suggestion to solve this?
07:08:34 <jpcooper> that is, GHC 7.0.3
07:10:56 <mysticc> jpcooper: paste the whole error .. maybe someone will help then
07:11:15 <mysticc> jpcooper: paste it and send the link
07:13:58 <jpcooper> mysticc: there's not much to see, really: http://hpaste.org/53970
07:16:21 <mysticc> jpcooper: Dont know man .. wait for somebody else ..
07:17:53 <dgpratt> this question relates to xmonad, but it's really more of a Haskell question: instead of setting the 'keys' member of an Xmonad record, I would like to 'union' something with the original value of 'keys'
07:17:56 <geheimdienst> jpcooper: retry it with cabal switched to moar verbose (-v2)
07:18:35 <dgpratt> but the type of 'keys' is:  type of 'keys' is:
07:19:42 <dgpratt> hold on a sec whilst I figure out how to paste in weechat :(
07:20:16 <jpcooper> okay
07:20:17 <geheimdienst> dgpratt: try this module http://hackage.haskell.org/packages/archive/xmonad-contrib/0.8/doc/html/XMonad-Util-EZConfig.html . also click the "Source" link and have a look how they implemented it
07:20:44 <geheimdienst> it uses the function 'union' from Data.Map
07:21:14 <dgpratt> geheimdienst: I tried union also, but I didn't compose it right
07:21:42 <dgpratt> keys is actually a function from...something to a Map
07:22:17 <dgpratt> so I did: keys = (\c -> M.union (myKeys c) (keys c))
07:22:39 <ClaudiusMaximus> guessing, something like   \r -> r{ keys = keys r `M.union` ... }
07:24:15 <geheimdienst> dgpratt: looks like the right approach, except that "keys" is an accessor of a record :) i.e. "keys c" will give you the record field -- which is, as you said, a function from something to a map
07:24:36 <dgpratt> geheimdienst: oh, duh
07:25:04 <dgpratt> how do I reference the current value of 'keys'?
07:27:32 <dgpratt> maybe I figured it out...
07:28:14 <dgpratt> this compiles: keys = (\c -> M.union (myKeys c) (keys defaultConfig c))
07:30:32 <dgpratt> I guess I gotta switch back to XChat; weechat is to hard-core for me; can't even figure out how to #@$% paste!
07:32:18 <dgpratt> geheimdienst: anyways, thanks for the help; I'll probably use that EZConfig stuff, but I wanted to understand what the original issue was
07:33:12 <geheimdienst> dgpratt: you're welcome
07:34:46 <ClaudiusMaximus> dgpratt: terminal paste is usually shift-insert or middle-mouse-button, though it can be hit/miss which clipboard gets used
07:36:18 <confound> that's X in general, not just terminals
07:36:34 <dgpratt> ClaudiusMaximus: should it be possible to Ctrl+C from somewhere else (e.g. a browser) and Shift+Ins into a terminal window?
07:37:24 <ClaudiusMaximus> if it's X11, normally you mark text with mouse, then paste into terminal - ctrl-c is often a separate toolkit-specific clipboard
07:37:30 <confound> that's the "it can be hit/miss which clipboard gets used" part. you might want to be running autocutsel
07:37:46 <dgpratt> confound: I'll google that, thanks
07:38:51 <confound> the tl;dr is "autocutsel -fork; autocutsel -fork -selection PRIMARY" in some startup script; or add "autocutsel" and "autocutsel -selection PRIMARY" to your gnome sessino, or whatever.
07:39:13 <confound> reading autocutsel's overview is still good though
07:39:24 <dgpratt> confound: ok, thanks
07:42:10 <ocharles> Hm. Is it possible to write a type class with an associated type synonym that takes a variable not mentioned in the type class? Such as: class Foo a where type Bar a :: (* -> *) -> *, and then later instance Foo Whatever where type Bar Whatever e = e Int ?
07:42:45 <ocharles> That at the moment fails because "e" is not mentioned in the original type family, but I can't put "e" in the type family either
07:48:09 <jpcooper> geheimdienst: there was no difference in the error given
07:50:08 <cvic_> I'm trying to install DSH and cabal keeps giving me "cabal: dependencies conflict: base-3.0.3.2 requires syb ==0.1.0.2 however syb-0.1.0.2 was excluded because syb-0.3.3 was selected instead"
07:50:38 <cvic_> And the same when I try to install via cabal the json package
07:51:30 <cvic_> Glasgow Haskell Compiler, Version 6.12.3, Ubuntu 11.11
07:51:40 <cvic_> *11.04
07:51:57 <rwbarton> ocharles: you can do it with a associated data type
07:52:16 <rwbarton> so most likely it is intentional that you cannot do it with an associated type synonym
07:53:41 <ocharles> Hrm, can't see how to do what I want with a associated data family though
07:53:54 <ocharles> Time to read Associated Types with Class I think and get more of an understanding of this stuff
07:56:33 <rwbarton> I guess the issue is Bar Whatever becomes something like a partially applied type synonym
07:56:52 <cvic_> Hm, managed to install syb manually...
08:00:18 <cvic_> Hmm, learned something new today: cabal sdist, cabal configure, cabal build
08:00:20 <cvic_> Cool
08:05:27 <cvic_> cabal can be frustrating sometimes...
08:06:22 <cvic_> Configuring DSH-0.7.6...
08:06:23 <cvic_> Warning: This package indirectly depends on multiple versions of the same
08:06:24 <cvic_> package. This is highly likely to cause a compile failure.
08:06:32 <cvic_> Great.
08:07:52 <ClaudiusMaximus> cvic_: maybe try adding a --constraint to the cabal command, but i don't know if it'd work at all
08:08:47 <cvic_> I think DSH is just broken.
08:09:18 <cvic_> Either that or I just don't know how to work with cabal. And I've tried various methods
08:10:19 <ddarius> I doubt DSH is broken.  The dependencies probably changed out from under it.
08:10:50 <ddarius> Also, depending on multiple versions of a package is only a problem if the types from the different versions interact.
08:11:35 <cvic_> So...
08:11:39 <cvic_> package json-0.5 requires mtl-1.1.0.2
08:11:39 <cvic_> package convertible-1.0.11.0 requires mtl-2.0.1.0
08:11:53 <cvic_> How can I solve this?
08:12:12 <cvic_> |Install both mtl versions?
08:13:13 <zeiris> I don't know, but is it possible to pick a version of json and convertible that matches the mtl dependency?
08:13:21 <rwbarton> does json-0.5 really require mtl-1.1.0.2?
08:13:39 <zeiris> Does anyone actually test the minimum and maximum versions they set in their .cabal files?
08:13:39 <rwbarton> http://hackage.haskell.org/package/json-0.5 indicates that it doesn't care about the version
08:13:46 <cvic_> That's good
08:15:30 <hpaste> chrisdone pasted “endless build errors” at http://hpaste.org/53972
08:15:42 <chrisdone> anyone else had trouble installing the encoding package on GHC 7.*?
08:16:51 <chrisdone> “/tmp/encoding-0.6.612853/encoding-0.6.6/dist/setup/setup: 4: Syntax error: ";" unexpected”
08:18:08 <hpaste> cvic_ pasted “DSH” at http://hpaste.org/53973
08:18:16 <cvic_> I don't get it.
08:18:22 <cvic_> All those dependencies are installed
08:18:30 <cvic_> But I can't build DSH.
08:19:29 <Saizan> you installed them by editing their .cabal file?
08:20:17 <cvic_> I installed them with cabal.
08:20:23 <chrisdone> cvic_: ghc-pkg list FerryCore returns a result?
08:20:28 <cvic_> One sec
08:20:52 <cvic_> Yes.
08:21:09 <cvic_> Also, cabal info FerryCore
08:21:18 <cvic_> returns the package info. It's installed
08:21:18 <chrisdone> no idea then, cabal works in mysterious ways
08:21:21 <applicative> cvic_ I just 'cabal install dsh' to see, it worked fine, so it isn't that the .cabal files are intrinsically contradictory
08:21:24 <cvic_> Yeah...
08:21:25 <chrisdone> -v3 might help debugging
08:21:29 <cvic_> Ok
08:22:44 <hpaste> cvic_ annotated “DSH” with “DSH (annotation)” at http://hpaste.org/53973#a53975
08:22:58 <cvic_> syb problems
08:23:17 <cvic_>     Latest version available: 0.3.3
08:23:17 <cvic_>     Latest version installed: 0.1.0.2
08:23:56 <c_wraith> wow.  what version of ghc are you using?
08:24:09 <cvic_>  ghc -v
08:24:09 <cvic_> Glasgow Haskell Compiler, Version 6.12.3, for Haskell 98, stage 2 booted by GHC version 6.12.3
08:24:19 * cvic_ doesn't understand what's wrong 
08:25:10 <c_wraith> conflicting versions between something already installed, and something new it wants to install.
08:25:27 <c_wraith> cabal isn't especially good at handling that situation.
08:25:45 <cvic_> I see. And it doesn't have the remove option
08:26:03 <luite> it doesn't need to remove packages, since you can have multiple versions installed
08:26:17 <cvic_> Can I force install the newer version?
08:26:36 <c_wraith> if you're willing to reinstall a bunch of stuff, removing ~/.ghc is the quickest solution
08:26:42 <applicative> cvic_ I noticed you are using a ghc with two versions of base 3 and 4.
08:26:57 <cvic_> Hm, that can be a problem too
08:27:18 <applicative> I mean, it's from the days when we used both, in principle it shouldn[t be a problem,
08:27:27 <ddarius> I don't think json-0.5 builds on 6.12.3
08:27:55 <applicative> ddarius: it seems to be demanding a high syb and thus base 4 in any case
08:28:17 <cvic_> "I noticed you are using a ghc with two versions of base 3 and 4."
08:28:20 <chrisdone> can anyone with ghc 7.0.4 try installing encoding please? if you get “Syntax error: ";" unexpected”, at least I know it's a general problem
08:28:21 <cvic_> where can I see this?
08:28:52 <ddarius> applicative: Yes, which is why it doesn't build on 6.12.3
08:29:17 <ddarius> If you try to install DSH-0.7.4 it may work.
08:29:34 <chrisdone> `cabal install encoding-0.6.6`
08:29:55 <applicative> ddarius, i wasn't disagreeing of cousre
08:31:50 <applicative> chrisdone: I unpacked encoding, it has a dist directory in it, strangely
08:32:20 <cvic_> ddarius: indeed. Passed the cabal configure stage
08:32:35 <cvic_> But cabal buidl gives me Loading package Pathfinder-0.5.9 ... linking ... ghc: unable to load package `Pathfinder-0.5.9'
08:32:41 <cvic_> So, back to downgrading
08:33:06 <cvic_> Ah, wait. I already have Pathfinder-0.5.9
08:33:07 <cvic_> Great
08:33:29 <applicative> chrisdone, I cant get it to work, but it doesn't seem to be a semicolon.
08:33:57 <chrisdone> chris@cn-done:~$ curl http://hackage.haskell.org/packages/archive/encoding/0.6.3/encoding-0.6.3.tar.gz > x.tar.gz; tar xf x.tar.gz; cd encoding*; ls  => Control  Data  encoding.cabal  NEWS  Setup.hs  System  system_encoding.c  system_encoding.h  tests
08:34:20 <ddarius> cvic_: Just add a constraint for each package to match the lowest versions for 0.7.4.
08:34:48 <chrisdone> applicative: hum
08:35:08 <cvic_> ddarius: ok
08:35:11 <cvic_> And one more dilemma
08:35:59 <chrisdone> applicative: i unpacked 0.6.6, trying installing after removing the dist/
08:36:13 <hpaste> cvic_ pasted “cabal configure versus runhaskell Setup.hs configure” at http://hpaste.org/53976
08:36:24 <cvic_> What's the difference
08:36:54 <ddarius> The Setup.hs doesn't do any dependency chasing.
08:36:56 <dmwit> cvic_: cabal configure uses --user by default; Setup.hs uses --global by default.
08:37:09 <cvic_> I see
08:38:00 <applicative> chrisdone, when I do "cabal configure" it begins to compile.  Then there is a pile of type errors.
08:38:28 <dmwit> ddarius: cabal configure doesn't do any dependency chasing, either.
08:38:45 <dmwit> Only cabal install does that.
08:39:27 <chrisdone> applicative: me too
08:39:51 <applicative> Does fancy TH incite 'cabal configure' to begin building the thing, in order to configure it?  I'm out of my depth somehow ...
08:39:56 <Cale> .__.   match_co baling out  base:GHC.Float.T:RealFloat{tc rB1}  (Sym  (main:Math.Geometry.VectorSpace.TFCo:R:ComponentFloat{tc rFd}))
08:39:58 <chrisdone> Couldn't match expected type `Text.XML.HaXml.Types.QName'  with actual type `[Char]'   and variations of it 50 times
08:40:10 <applicative> chrisdone: yes that's my error(s)
08:40:17 <Cale> Getting RULES to fire can be tricky
08:44:15 <monochrom> . o O ( if a rule doesn't fire, you fire it XD )
08:44:28 <Cale> Are RULES supposed to work at all in the presence of type families?
08:45:14 <geheimdienst> "sir this is a family establishment. i have to ask you to leave, you and your unruly RULES"
08:45:14 <ddarius> Cale: Ask on #ghc?
08:47:59 <wieczyk> Can I load shared library from ghci shell? The ":set -lxyz" does not work.
08:48:18 <ddarius> {-# RULES "2=3" 2 = 3 #-}
08:50:35 * ddarius considers using RULES as a metaprogramming system.
09:00:34 <cvic_> I wonder how these guys run HSH...  http://dbwiscam.informatik.uni-tuebingen.de/trydsh/
09:00:44 <cvic_> *DSH
09:01:50 <wavewave> hi
09:03:52 <hpaste> Cale pasted “Problematic specialisation” at http://hpaste.org/53979
09:07:03 <hpaste> Cale annotated “Problematic specialisation” with “Problematic specialisation (annotation)” at http://hpaste.org/53979#a53980
09:07:50 <rotflcopter> hi, can someone tell a usable form of the square's function? max(x^2,y^2) = 1 ?
09:08:08 <rotflcopter> like (x^2>=y^2)*x^2+(x^2<y^2)*y^2 = 1 == max(x2,y2) = 1 ?
09:10:10 <hpaste> Cale pasted “RULES doesn't seem to help” at http://hpaste.org/53981
09:10:46 <hpaste> Cale annotated “RULES doesn't seem to help” with “RULES doesn't seem to help (annotation)” at http://hpaste.org/53981#a53982
09:11:23 <Cale> rotflcopter: Sorry, can you say what you're trying to do in English?
09:11:48 <Cale> (because I really do not understand what your symbols are intended to mean...)
09:12:10 <rotflcopter> Cale<< http://en.wikipedia.org/wiki/Square_(geometry)
09:12:19 <rotflcopter> it would be a function of a square
09:14:18 <Cale> You mean an equation defining a square? The solutions (x,y) to max(x^2,y^2) = 1 form a square.
09:14:29 <Cale> max(x^2,y^2) = 1 is not a function.
09:14:53 <rotflcopter> Cale<< yes i see, i dont like tha max() either, can it be eliminated ?
09:14:57 <rotflcopter> like
09:15:04 <rotflcopter> (x^2>=y^2)*x^2+(x^2<y^2)*y^2 = 1
09:15:18 <Cale> Okay, I have no idea what that's supposed to mean
09:15:31 <Cale> You seem to be mixing relation symbols in with other stuff.
09:15:37 <sadger> @src max
09:15:38 <lambdabot> max x y = if x <= y then y else x
09:15:51 <yrlnry> He wants to describe the set of points in the plane that form a figure of a square, but he doesn't want to use the max() operator.
09:15:55 <rotflcopter> i ws thinking about (x>y) is boolean 1 or 0
09:15:58 <Cale> x^2 >= y^2 isn't a number, so I don't know what it means to multiply it by x^2
09:16:16 <Cale> hmm
09:16:42 <ClaudiusMaximus> maybe use a parameterized form?  let square t | 0 <= t && t < 0.25 = (1, 8 * t - 1) | 0.25 <= t && t < 0.5 = ...
09:17:00 <yrlnry> This is a common misconception among mathematical beginners, that a formula is somehow only legitimate if it involves certain elementary functions, like polynomials, but not if it is defined piecewise, or involves max(), or other such components.
09:17:52 <tomprince> Well using Bool -> Int given by True |-> 1 and False |-> 0
09:17:54 <rotflcopter> ok i'd like to get union area of a circle, and a square
09:18:32 <rotflcopter> so was thinking about blending the 2 functions and done...
09:19:18 <pedro3005> Cale, that got me thinking: "hm, maybe we could define a field where elements are equations.. then easily we have multiplication (by scalars too) and other things as well.. and then, we can solve equations on equations"
09:19:18 <pedro3005> there's an inception joke somewhere
09:19:18 <pedro3005> but the concept is interesting
09:19:48 <Cale> The solution set to max(x^2,y^2) = 1 has measure 0 in the plane, so it contributes nothing to the area. However, max(x^2,y^2) < 1 has area 4.
09:19:52 <yrlnry> pedro3005:  Any equation a = b can be written as a-b = 0, and then you can deal pretty well with the a-b part by itself, I would guess.
09:20:07 <rotflcopter> :)
09:20:22 <rotflcopter> actually im doing some functional math in C
09:20:35 <hpaste> ddarius pasted “Krivine's abstract machine” at http://hpaste.org/53983
09:21:17 <Cale> ddarius: Would you like to help me get my RULES working? ;)
09:21:19 <pedro3005> yrlnry, the equations would be of the form (a = b) * x = (c = d)
09:21:29 <ddarius> Cale: Only if they are Turing complete.
09:21:46 <Cale> All I'm trying to do is to get some code to specialise :P
09:21:59 <rotflcopter> pedro3005<< yeah tha'd be the functional form of an if
09:22:09 * hackagebot timeplot 0.3.11 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.11 (EugeneKirpichov)
09:22:14 <roconnor> sipa: I don't suppose you'd be interested in editing the wiki to state how negative numbers are represented.
09:22:14 <Cale> The typeclass polymorphism is useful because we have a handful of cases, but it also kills performance of this code.
09:22:23 <roconnor> oops
09:22:57 <Cale> (the code I pasted is a heavily simplified version of the situation)
09:24:17 <Cale> Maybe I should try switching to an MPTC :P
09:24:22 <Cale> a*
09:24:36 <Cale> no, an* :)
09:27:04 <ddarius> What is the correct thing to do in that situation?
09:27:32 <Cale> Specialisation is also going to be fairly important for us in general, so if RULES and type families don't currently mix, I may have to actually learn something about GHC's internals
09:28:29 <Cale> That, or write some sort of preprocessor to specialise the code manually, which would be pretty ugly to have to do.
09:29:13 <rotflcopter> so you like the concept of not having if too :)
09:31:03 <RaptorRarr> I wish Haskell had the ability to let programmers write their own optimizations.
09:31:24 <RaptorRarr> Like to take the AST or whatever and specialize or do a new kind of fusion or whatever.
09:31:29 <rotflcopter> well it would be an advantage in parallel processing not having branches
09:32:04 <ddarius> RaptorRarr: You can.
09:32:11 <RaptorRarr> But to do it for just one file, perhaps, without altering the compiler.
09:32:28 <RaptorRarr> Well, you can write simple replacement rules.
09:32:57 <ddarius> Cale: Probably an incompleteness in the RULES engine.  You should go in and fix it, and also change "baling" to "bailing."
09:33:31 <RaptorRarr> Like "if you get something in exactly the form reverse . drop 5 . reverse, instead use \xs -> map snd . zip (drop 5 xs) $ xs"
09:34:21 <RaptorRarr> But that's not what I mean. I mean like with full pattern matching and ability to generate lots of code and so on.
09:34:38 <dmwit> Yeah, that particular example looks just like a rewrite rule.
09:34:39 <RaptorRarr> And to use the full power of Haskell to replace things.
09:34:53 <RaptorRarr> Instead of just a predetermined replacement form.
09:34:57 <dmwit> If you don't have a motivating example, figuring out a good solution is going to be hard...
09:35:08 <ddarius> RaptorRarr: You can use TH.  Also, rewrite rules are Turing complete.
09:35:28 <RaptorRarr> Well, like let's say I thought up list fusion or something.
09:35:43 <ddarius> List fusion is done with rewrite rules.
09:36:00 <RaptorRarr> Ahh.
09:36:27 <RaptorRarr> Where are those stored?
09:36:28 <dmwit> Rewrite rules seem to be a better solution than you're giving them credit for. =)
09:36:56 <RaptorRarr> They may be. If they're actually Turing complete, they're much more powerful than I thought they were.
09:37:14 <rotflcopter>  Cale The solution set to max(x^2,y^2) = 1 has measure 0 in the plane, so it contributes nothing to the area. However, max(x^2,y^2) < 1 has area 4. < yah i was thinking about that ;)
09:37:15 <ddarius> I demonstrated that they were Turing complete in the paste I just pasted.
09:38:00 <dmwit> cool
09:38:14 <RaptorRarr> Do they have any insane, Oleg-quality examples of doing arithmetic with rewrite rules or whatever?
09:38:15 <RaptorRarr> Oh, missed the paste.
09:38:19 <ddarius> (This was well known anyway.)
09:38:24 <Cale> match_co :: RuleEnv -> RuleSubst -> Coercion -> Coercion -> Maybe RuleSubst
09:38:24 <Cale> match_co renv subst (CoVarCo cv) co = match_var renv subst cv (Coercion co)
09:38:24 <Cale> match_co _ _ co1 _ = pprTrace "match_co baling out" (ppr co1) Nothing
09:38:48 <Cale> ^^ the entirety of that function, which is uncommented ;___;
09:39:12 <Cale> I'll have to learn how this all is supposed to work :P
09:39:20 <ddarius> You'll want to talk to Simon Peyton Jones.
09:50:04 <dufflebunk> Can anyone point me to docs on how to track down space leaks?
09:51:17 <dmwit> ?wiki memory leak
09:51:17 <lambdabot> http://www.haskell.org/haskellwiki/memory_leak
09:51:29 <dufflebunk> Thank you dmwit
09:52:24 <RaptorRarr> ddarius: Thanks for that paste :)
09:52:41 <RaptorRarr> Does anyone perchance have a link to the rewrite rules that implement list fusion?
09:53:24 <dmwit> RaptorRarr: I don't have a link, but the first place I'd look would be in the GHC source, in the libraries. Particularly Data.List seems like a good first place to look.
09:53:33 <RaptorRarr> OK, thanks.
09:53:47 <alpounet> dufflebunk, you have space profiling
09:54:22 <alpounet> dufflebunk, http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/prof-heap.html
09:54:46 <mah_b> hi, is there a function to 'flip' a Map, ie Map a b -> Map b a?
09:55:24 <dmwit> mah_b: No, but there's a package on hackage for bidirectional maps.
09:55:39 <dmwit> ?hackage bimap
09:55:39 <lambdabot> http://hackage.haskell.org/package/bimap
09:55:45 <mah_b> dmwit: thanks, I'll look at it
09:57:07 <dmwit> I really like this documentation feature which says which version a particular function appeared/last changed.
09:57:25 <dmwit> I wonder if we could find a way to automate something like that.
09:57:51 <geheimdienst> dmwit++
10:02:38 <alpounet> dmwit, maybe using http://hdiff.luite.com/
10:03:12 <RaptorRarr> Ahh, found some: http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#line-52
10:03:12 <Feuerbach> mah_b: something like "fromList . map swap . toList" will do the trick, but you have to understand that it'll be O(n log n)
10:04:22 <alpounet> doesn't sound like a good idea
10:04:32 <alpounet> e.g if you have two keys with the same value
10:05:17 <Feuerbach> alpounet: depends on what you need, of course
10:05:31 <mah_b> Feuerbach: i really dont care much about complexity because my input set is rather small. thabk you for this elegant solution.
10:08:35 <Feuerbach> alpounet, mah_b: e.g. there's fromListWith which combines values corresponding to the same key (or, in this case, combines keys corresponding to the same value)
10:09:54 <alpounet> yeah
10:16:25 <dmwit> alpounet: Oh, man, that name. I was hoping for much, much more than what that actually does.
10:16:46 <dmwit> I thought it would be a Haskell-specific diff, but it's just plain old Unix diff wrapped up in a web interface.
10:16:58 <alpounet> yup
10:17:12 <alpounet> then... sorry i guess :P
10:21:30 <smoge> hi, could someone point to a example code of a markov chain process ?
10:21:42 <smoge> a simple 1st order markov chain
10:28:08 <paolino> @hoogle assert
10:28:09 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
10:28:09 <lambdabot> Control.Exception assert :: Bool -> a -> a
10:28:09 <lambdabot> Control.OldException assert :: Bool -> a -> a
10:29:39 <smoge> ??
10:30:59 <galagala> is there a command like sml's "as" command for haskell?
10:31:14 <roconnor> I just wrote a replicateMreverse function; is there some nice simple pointfree definition?
10:31:53 <Cale> galagala: what does that do?
10:31:55 <roconnor> maybe I should call it reverseReplicateM
10:32:27 <roconnor> @hoogle asTypeOf
10:32:27 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:32:30 <alpounet> galagala, you mean giving a name to a pattern ?
10:32:32 <roconnor> galagala: ^^ maybe
10:32:33 <alpounet> like :
10:32:37 <galagala> Cale, you would fx write x as y::ys
10:32:41 * roconnor doesn't know what as does in ML
10:32:51 <roconnor> oh
10:32:59 <roconnor> f x@(y:ys) = ...
10:33:01 <Cale> > f x@(y:ys) = (x,y,ys)
10:33:02 <alpounet> yeah
10:33:02 <lambdabot>   <no location info>: parse error on input `='
10:33:04 <galagala> alpounet, yes!
10:33:08 <Cale> > let f x@(y:ys) = (x,y,ys) in f [1,2,3]
10:33:09 <lambdabot>   ([1,2,3],1,[2,3])
10:33:13 <alpounet> galagala, then see what roconnor and Cale wrote
10:33:15 <galagala> oh okay cool
10:33:18 <alpounet> that's @ in Haskell
10:33:38 <galagala> thanks!
10:35:13 <PiRSquared17> Just like in ML :: is cons and : is type, Haskell's :: is type, : is cons.
10:36:30 <dmwit> roconnor: Are you just going to leave us guessing about your non-pointfree implementation?
10:36:35 <galagala> yeah, that toke some getting used to
10:37:53 <roconnor> oh, it is the obvious thing:
10:38:02 <roconnor>   reverseReplicateM n cmd = go n []
10:38:03 <roconnor>     where
10:38:05 <roconnor>      go 0 l = return l
10:38:06 <roconnor>      go n l | 0 < n = do { i <- cmd; go (n-1) (i:l) }
10:38:24 <roconnor> I think it might be some sort of forM loop
10:38:26 <dmwit> ?src replicateM
10:38:27 <lambdabot> replicateM n x = sequence (replicate n x)
10:38:33 <daudi> how can i use heskel
10:39:02 <dmwit> daudi: Install the Haskell platform, then follow along with one of the excellent online tutorials.
10:39:08 <dmwit> There are links from the front page of haskell.org
10:39:16 <roconnor> dmwit: oh, well I could write reverseReplicateM n cmd = map reverse (replicateM n cmd) ... but I want something more efficent.
10:39:56 <roconnor> s/map/fmap
10:40:08 * dmwit nods agreement
10:40:35 <dmwit> Is it a priori obvious that reversing at the end is less efficient?
10:40:41 <conal> fmap.fmap.fmap
10:41:02 <roconnor> dmwit: oh
10:41:04 <Saizan> if you return stuff in reverse order anyway you can do it with an accumulator
10:41:18 <roconnor> dmwit: maybe not; I had it in my head that reverse was O(n^2)
10:41:22 <roconnor> but that is not true
10:41:59 <roconnor> dmwit: maybe it doesn't make a difference; I'm just shuffling stuff around.
10:42:07 <Saizan> which is going to use O(1) stack instead of O(n) for quite a lot of monads
10:43:17 <daudi> if i donload haskell for linux can it work with ubuntu?
10:43:28 <dmwit> ?faq if i donload haskell for linux can it work with ubuntu?
10:43:29 <lambdabot> The answer is: Yes! Haskell can do that.
10:46:04 <aristid> it works very well with ubuntu, in fact.
10:47:34 <hpc> you usually want to get the haskell platform from apt
10:47:43 <hpc> sudo apt-get install haskell-platform
10:48:08 <aristid> i prefer installing just ghc and using cabal for the rest *shrug*
10:48:19 <aristid> *just ghc and cabal
10:48:37 <hpc> the platform is less effort when starting out though
10:51:30 <roconnor> @hoogle MonadPlus
10:51:30 <lambdabot> Control.Monad class Monad m => MonadPlus m
10:57:19 <roconnor> @hoogle genericSplitAt
10:57:20 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
10:58:16 <ocharles> Bah, the "Associated Type Synomyms" paper suggests `class C a where type S a (k :: * -> *) :: *` is valid, but it's not
11:05:40 <hpaste> kush pasted “xmonad.hs” at http://hpaste.org/53987
11:06:58 * dufflebunk wishes there were official binaries of ghc for redhat 5
11:10:22 <ocharles> Further reading suggests it just doesn't work atm - http://hackage.haskell.org/trac/ghc/ticket/3714
11:13:47 <dhun_233> why does any applicative functor fulfill: fmap f x = pure f <*> x    ?
11:14:10 <dhun_233> thats strange because fmap is not in the four axioms
11:14:24 <c_wraith> dhun_233: fmap f x = pure f <*> x
11:14:34 <c_wraith> it's just a shorter way of saying the same thing
11:14:34 <dhun_233> yes
11:15:04 <dhun_233> well any applicative functor has to be a functor so it must have fmap
11:15:16 <c_wraith> right.
11:15:26 <c_wraith> So it's just a restriction on the implementation of <*>
11:15:45 <c_wraith> it must be implemented in a way that makes that true, for a definition of fmap that follows the functor laws
11:16:13 <dhun_233> no I read that you can not get it wrong even if you try
11:16:28 <c_wraith> that might be provable.  give it a shot.  :)
11:16:40 <c_wraith> (if it is provable, it's only if you ignore bottoms)
11:17:08 <dhun_233> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
11:17:28 <dhun_233> it says: As a consequence of these laws, the Functor instance for f will satisfy
11:17:32 <dhun_233> ..
11:18:05 <dhun_233> so what is strange to me, is that fmap is in the equation but not in the laws
11:18:38 <c_wraith> well, as you point out, it's a requirement for the implementation, anyway.  I think that's why it's listed as a note, not a law, actually.
11:19:13 <dhun_233> To me the website says, that you can proof it from the four laws
11:19:23 <c_wraith> yes
11:20:08 <dhun_233> can I find the proof somewhere or is it worth trying myself, am just a physicist
11:21:55 <dufflebunk> In the cabal config, if you set library-profiling: True, will it install both the profiling and non-profiling versions?
11:21:57 <c_wraith> I bet you can get it yourself
11:22:03 <c_wraith> dufflebunk: yes
11:22:09 * hackagebot sbv 0.9.22 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.22 (LeventErkok)
11:22:16 <dufflebunk> c_wraith, thanks
11:22:35 <dhun_233> ok I will try
11:22:43 <c_wraith> dhun_233: I bet it's not too hard, given parametricity.  Though Wadler's paper on free theorems might give you some pointers, if you want to look at it.
11:22:56 <yitz> oh well left
11:23:27 <yitz> c_wraith: you can't prove that from the other laws; you can prove it for specific instances.
11:23:45 <yitz> c_wraith: hope he understood that
11:23:50 <c_wraith> yitz: really?  Interesting..  The docs certainly do imply you can prove it
11:25:41 <yitz> hmm it does imply that. doesn't really seem to make sense though. you just need to define each instance so that it will be true.
11:25:46 <dufflebunk> hmm, how do I install the profiling version of base? cabal refuses (cabal install --reinstall base) , claiming it's impossible. I had to compile ghc by hand, is there some option there to build the base w/ profiling?
11:26:14 <yitz> how could it possible be a consequence? as dhun_233 pointed out, the functor instance isn't even mentioned in the other laws.
11:26:35 <c_wraith> yitz: I think you have to prove it from the functor laws...  somehow
11:27:01 <c_wraith> dufflebunk: if they aren't installed already, that would imply you installed ghc from a package manager.  you'll need to find the package that contains the profiling libs for ghc
11:27:24 <c_wraith> dufflebunk: (the pre-compiled binary distributions of ghc come with the profiling version of base)
11:27:31 <dufflebunk> c_wraith, I had to build ghc from source.
11:27:44 <c_wraith> dufflebunk: ooh.  that's a complicated case then.  I don't know the answer there.
11:28:00 <Saizan> yitz: parametricity is magic like that
11:28:04 * dufflebunk really wishes there were official binaries of ghc for redhat 5
11:28:13 <yitz> magic?
11:28:25 <c_wraith> dufflebunk: did the generic precompiled linux binary not work on rh5?
11:29:04 <Saizan> yitz: i mean that it's powerful enough to prove that, roconnor should have the proof somewhere on his blog iirc
11:29:32 <dufflebunk> c_wraith, No, the libc is too old.
11:29:33 <yitz> Saizan: what exactly do you mean by parametricity then?
11:29:48 <roconnor> yitz: you can use parametricy to prove that there is at most one functor instance
11:30:05 <Saizan> yitz: the same as in wadler's free theorems
11:30:11 <dufflebunk> I had to build ghc 6.12 from source with some generic ghc, then use that to build 7.0.3
11:30:25 <c_wraith> dufflebunk: ah.  that is unfortunate.  I recently built ghc from source to play with unreleased features.  I seem to remember there being a config file that gave lots of options over how to build it.  Maybe one of those included "build profiling libraries"?
11:30:29 <roconnor> @free <$>
11:30:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:30:36 <roconnor> @type <$>
11:30:37 <lambdabot> parse error on input `<$>'
11:30:43 <roconnor> @free (<$>)
11:30:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:30:48 <roconnor> @type (<$>)
11:30:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:31:04 <roconnor> @free (<$>) :: (a -> b) -> f a -> f b
11:31:05 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:31:09 <roconnor> :/
11:31:11 <c_wraith> name it fmap
11:31:13 <c_wraith> it will like that more
11:31:16 <ski> @free fmap :: (a -> b) -> f a -> f b
11:31:17 <lambdabot> Extra stuff at end of line
11:31:23 <dufflebunk> c_wraith, if there are, they aren't listed in ./configure --help
11:31:24 <yitz> ahh, i see. what they mean is that if it satisfies the applicative laws, then you can define a functor instance that way and it will satisfy the functor laws
11:31:36 <roconnor> @free fmap :: (a -> b) -> F a -> F b
11:31:36 <PiRSquared17> @free a
11:31:37 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
11:31:38 <lambdabot> a = a
11:31:43 <PiRSquared17> @free a b
11:31:43 <lambdabot> Extra stuff at end of line
11:31:52 <PiRSquared17> @free a -> b
11:31:52 <lambdabot> Extra stuff at end of line
11:31:53 <yitz> ok well that certainly makes sense. that's not what the docs seem to say though.
11:31:54 <c_wraith> yitz: and there's only one functor instance that satisfies the functor laws, so it must be the same as any correct implementation of fmap
11:31:54 <PiRSquared17> @free \a -> b
11:31:55 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:32:07 <c_wraith> yitz: though perhaps not, operationally
11:33:22 <c_wraith> in fact, that's probably why there's f <$> x = fmap f x in the libs, rather than not having the operator at all
11:33:52 <Saizan> yitz: not only it will satisfy the functor laws, it'll be the same as any instance of functor that might already be there for the type, because there can be only one
11:34:10 <roconnor> c_wraith: the nice thing about <$> is that once you define Applicative you can write instance Functor F where fmap = <$>
11:34:40 <Saizan> <$> is just a synonym for fmap, it's not defined with pure and <*> :)
11:34:42 <ski> (same holds for `ap',`Monad' and `Applicative')
11:34:45 <yitz> what is the definition of "parametricity"?
11:34:48 <Saizan> ?type (<$>)
11:34:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:35:54 <dufflebunk> c_wraith, do the default ghc make builds libHSbase-4.3.1.0_p.a, I'm guessing that's the profiling version. But make install doesn't install it. Perhaps there's a special target to install profiling libs.
11:40:00 <ocharles> Is it possible to define an identity function at the level and pass it around? I tried "type TId a = a", but this is fairly useless because you can't partially apply a type synonym
11:43:06 <ocharles> Ohhh, http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/data-type-extensions.html it looks like LiberalTypeSynonyms could pull it off
11:45:16 <hpaste> kush_ pasted “xmonad.hs” at http://hpaste.org/53988
11:48:42 <ocharles> Grr, but it doesn't work with type families
11:49:28 <bgamari> Seriously, are there any plans to fix the package versioning in cabal? For the third time in three weeks I need to clear my package repository
11:49:53 <bgamari> It seems like cabal is very close to getting it right, but package versioning is pretty rough
11:50:29 <bgamari> There should at least be a convenient way to rebuild all packages dependent on an upgraded package
11:53:06 <bgamari> Is there any way to at least get a list of packages depending on a given package?
11:53:33 <alpounet> yes
11:53:55 <alpounet> bgamari, http://revdeps.hackage.haskell.org/~roel/cgi-bin/hackage-scripts/revdeps/haskell2010-1.1.0.0
11:54:05 <bgamari> alpounet: Thanks!
11:54:10 <alpounet> just replace haskell2010-1.1.0.0 by the package you want
11:55:24 <bgamari> Right, I was hoping for a script however
11:55:44 <bgamari> manually looking up reverse dependencies and rebuilding doesn't sound like very much fun
11:56:49 <alpounet> bgamari, then I'd ask the (apparent) author, Roel van Dijk
11:59:20 <dylex> bgamari: can't you just use ghc-pkg, e.g, ghc-pkg dot?
11:59:39 <hpaste> kush pasted “kjsdf” at http://hpaste.org/53989
12:00:25 <hpaste> kush pasted “conkyrc” at http://hpaste.org/53990
12:00:35 <bgamari> dylex: I was just looking at ghc-pkg dump's output
12:00:45 <bgamari> dylex: Could easily script something around this
12:00:51 <bgamari> I'm just surprised it hasn't been done before
12:01:02 <bgamari> I must have remarkably poor luck with cabal
12:01:24 <bgamari> Is the API used by ghc-pkg exposed in the GHC api?
12:02:34 <luite> Loading package hmatrix-0.12.0.1 ... can't load .so/.DLL for: libgsl.dylib (dlopen(libgsl.dylib, 9): image not found)   <- what to do about this? libgsl.dylib is in /opt/local/lib (macports), I'm pretty sure that other libs in this path have always worked
12:03:03 <dylex> bgamari: Yes, in Cabal, Distribution.PackageDescription etc
12:04:10 <bgamari> dylex: I don't believe ghc-pkg uses cabal
12:04:34 <bgamari> dylex: I think cabal passes an InstalledPackageInfo to ghc-pkg
12:04:38 <bgamari> which then registers it
12:04:47 <bgamari> but this is independent of cabal's database
12:04:50 <bgamari> correct me if I'm rong
12:04:51 <dylex> bgamari: Cabal not cabal-install
12:04:51 <bgamari> wrong*
12:05:21 <bgamari> dylex: http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-InstalledPackageInfo.html
12:05:51 <bgamari> dylex: That module has no way to access the package database
12:06:00 <bgamari> I think that because it's ghc-pkg that maintains that database
12:06:05 <dylex> bgamari: Cabal is the package that contains all the Distribution modules.  cabal-install is what you probably think of as cabal, the command-line interface.
12:06:15 <luite> ok found it, had to add /opt/local/lib to LD_LIBRARY_PATH
12:06:19 <bgamari> dylex: Right
12:06:35 <bgamari> dylex: But I think ghc maintains the list of installed modules
12:06:46 <bgamari> Ahh, right. I perhaps should have specified that I only care about installed modules
12:07:02 <bgamari> It might be http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/Packages.html that I'm looking for
12:08:48 <bgamari> Judging by the ghc-pkg source, accessing this database isn't easy
12:08:59 <bgamari> It's probably easier just to parse the output of ghc-pkg dump
12:10:04 <dylex> bgamari: i see.  yes, ghc-pkg provides a thin layer to the installed package database.  Anyway, ghc-pkg dot | grep doesn't seem so hard.
12:10:47 <bgamari> agreed
12:10:51 <bgamari> Thanks!
12:11:29 <dhun_233> c_wraith I could show, that if f and g fulfill it, there composition also does, and that it holds for the identity, but does this help?
12:11:42 <dhun_233> their
12:13:25 <dhun_233> so maybe someone else can help me, I am trying to show that   fmap f x = pure f <*> x
12:15:13 <bgamari> Now if only there was some way to expunge the old packages to be sure that nothing tries to load them
12:15:58 <mah_b> hi, is there a compiler option that makes ghc place the *.hi files in a different directory than the source directory? (similar to -odir)
12:16:55 <AtnNn> mah_b: -hidir
12:17:44 <mah_b> AtnNn: ok, sounds somewhat logical, thanks ^^
12:29:28 <mithos28> do haskell arrays have know performance problems?
12:31:02 <Saizan> depends on which you're using and what you expect, immutable vs. mutable, boxed vs. unboxed, ..
12:31:13 <mithos28> mutable, boxed
12:31:45 <Saizan> in older ghc's there was a problem with GC but that's been fixed
12:31:54 <mithos28> I'm expecting close to c but am getting an order of magnitude off
12:32:37 <mithos28> so was wondering if 2d indices could lead to a problem
12:32:57 <mithos28> and if switching to vector would help
12:33:48 <ClaudiusMaximus> > let a = listArray ((1,1),(5,5)) (replicate 25 "magic") in a ! (42,7) -- bounds checking might take up some of the time
12:33:50 <lambdabot>   "*Exception: Error in array index
12:33:56 <ALaunus> Does Haskell have an equivalent way of doing what Slot (http://reference.wolfram.com/mathematica/ref/Slot.html) does in Mathematica?
12:33:57 <int-e> I've had bad performance with 2d indices (and the Ix class in general); bounds checking also hurts.
12:34:54 <mithos28> ok, so I'll try vector and removing bounds checking
12:35:07 <mithos28> thanks for the help
12:35:46 <byorgey> ALaunus: yes, for example, instead of  f[#1, #2]  you would write  \x y -> f x y
12:36:01 <ClaudiusMaximus> ALaunus: you can use a lambda, or flip, or sections
12:36:01 <byorgey> ALaunus: unless you specifically mean referring to arguments by index, in which case the answer is no
12:36:34 <ALaunus> ahh, ok
12:37:23 <ClaudiusMaximus> > map ($ z) [(x +), (+ y)]
12:37:24 <lambdabot>   [x + z,z + y]
12:37:41 <copumpkin> > flip [(x +), (+ y)] z
12:37:42 <lambdabot>   [x + z,z + y]
12:38:21 <ALaunus> I'm trying to check where mapping  (3 `mod`) over a list returns 1, so it seems like using multiple functions is more appropriate
12:38:36 <byorgey> copumpkin: stop confusing the newbies =P
12:38:55 <dgpratt> copumpkin: yeah, what the heck?
12:38:59 <copumpkin> :(
12:39:08 <byorgey> dgpratt: flip has a generalized type in lambdabot
12:39:19 <ClaudiusMaximus> > filter (\x -> 3 `mod` x == 1) [1 .. 5]
12:39:20 <lambdabot>   [2]
12:39:28 <dgpratt> :t flip
12:39:28 <byorgey> @type flip
12:39:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:39:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:39:33 <byorgey> @type Prelude.flip
12:39:34 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:39:40 <dgpratt> byorgey: ah
12:40:00 <ALaunus> ahhh! forgot about filter! much obliged :D
12:40:06 <dgpratt> :t (+)
12:40:07 <lambdabot> forall a. (Num a) => a -> a -> a
12:40:13 <byorgey> :t (++)
12:40:14 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:40:39 <ClaudiusMaximus> :t [(+).(++),(+++)]
12:40:39 <dgpratt> :t x
12:40:40 <lambdabot>     Couldn't match expected type `b -> c'
12:40:40 <lambdabot>            against inferred type `Either b (b -> c)'
12:40:40 <lambdabot>     Probable cause: `+++' is applied to too many arguments
12:40:40 <lambdabot> Expr
12:41:05 <dgpratt> @hoogle Expr
12:41:05 <lambdabot> Text.Parsec.Expr module Text.Parsec.Expr
12:41:05 <lambdabot> Text.ParserCombinators.Parsec.Expr module Text.ParserCombinators.Parsec.Expr
12:41:05 <lambdabot> Text.ParserCombinators.Parsec.Expr buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
12:41:14 <byorgey> @where Expr
12:41:15 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:41:18 <byorgey> dgpratt: ^^^
12:41:56 <dgpratt> byorgey: ah
12:42:04 <dgpratt> (again)
12:43:43 <GreaseMonkey> hey, what's the ghci equivalent of hugs's "where"?
12:44:09 <GreaseMonkey> as in, foo 1 where foo x = (x:foo x)
12:44:25 <GreaseMonkey> or maybe: foo 1 where foo x = (x:foo (x+1))
12:44:32 <GreaseMonkey> > foo 1 where foo x = (x:foo (x+1))
12:44:33 <lambdabot>   <no location info>: parse error on input `where'
12:44:38 <byorgey> GreaseMonkey: let foo x = (x:foo (x+1)) in foo 1
12:44:46 <GreaseMonkey> oh thanks
12:45:03 * byorgey didn't know hugs let you do that
12:45:18 <GreaseMonkey> turns out that works in hugs too
12:45:35 <byorgey> GreaseMonkey: well, let ... in ... is standard Haskell syntax, so it ought to
12:45:46 <byorgey> blah where foo  is a Hugs-specific eextension
12:46:20 <GreaseMonkey> i suspect there's no real reason to use "where", then
12:46:48 <byorgey> 'where' is also standard Haskell syntax, but it goes with declarations, not expressions
12:46:59 * dufflebunk notes that c_wraith doesn't sleep long
12:47:22 <byorgey> I'm guessing Hugs extended it to work with expressions too since beginners failed to realize the difference, and, well, why not?
12:47:26 <c_wraith> dufflebunk: actually, that delay was "getting on the airplane".  I am now in mid-air
12:48:39 * byorgey causes electromagnetic radiation encoding this sentence to be beamed at an airplane
12:48:58 <c_wraith> byorgey: yes you did
12:49:01 <Feuerbach> > case () of _ -> a where a = 1
12:49:02 <lambdabot>   1
12:49:12 <Feuerbach> byorgey: that isn't a declaration, is it?
12:49:42 <byorgey> touche!
12:50:01 <byorgey> I forgot it can be attached to case as well
12:50:53 <simon> nice to know!
12:55:13 <Philippa> GreaseMonkey: where is for when you want to describe something top-down instead of bottom-up
12:55:28 <GreaseMonkey> hmmkay
12:56:25 <Philippa> code isn't just for computers
13:23:04 <ClaudiusMaximus> > 24000 / 25
13:23:05 <lambdabot>   960.0
13:27:36 <zzing> What is the best way to derive show for my data type data Ship = Ship (Double, Double) (Double, Double) ? I would prefer a custom show, but can't figure out easy way to do
13:29:27 <c_wraith> why does it take 2 pairs, instead of 4 args?
13:29:40 <zzing> A ship has a velocity and a position
13:29:49 <c_wraith> yes, it has 4 pieces of information
13:30:02 <zzing> Which is best expressed in their groupings
13:30:06 <c_wraith> That doesn't explain why you have that representation
13:30:08 <c_wraith> in any case
13:30:28 <c_wraith> you can write a custom instance like:  instance Show Ship where show (ship position velocity) = blah
13:30:31 <dufflebunk> zzing, make Ship and instance of Show. In the instance you define show
13:31:17 <c_wraith> err, capitalize that Ship in parens
13:31:28 <zzing> yes I got that part :P
13:31:53 <c_wraith> also, you could go with instance Show Ship where show (Ship (x, y) (vx, vy)) = blah
13:32:03 <c_wraith> if you want to not just depend on the show instance for the tuples
13:32:30 <zzing> Can the show instance of the tuples print something like this? instance Show (Double, Double) where show (x, y) = "(" ++ x ++ ", " ++ y ++ ")"
13:32:44 <c_wraith> that's almost exactly what it does
13:32:49 <zzing> awesome
13:32:53 <c_wraith> > show (5.3, 7.0)
13:32:54 <lambdabot>   "(5.3,7.0)"
13:33:03 <c_wraith> it doesn't have the space you wanted..
13:33:06 <c_wraith> That's the only difference
13:33:17 <zzing> not an issue tbh
13:35:11 <zzing> What is wrong with indentation here: instance Show Ship where show (Ship pos vel) \n    = "Ship At: " ++ (show pos) ++ " going " ++ (show vel)  -- where \n is the new line
13:35:34 <c_wraith> put the newline after the where
13:36:33 <c_wraith> that makes things the clearest when the type class has multiple functions you need to define in it, too
13:36:51 <c_wraith> you just have a bunch of indented function definitions as part of the instance declaration
13:38:52 <zzing> works merci
13:39:05 <c_wraith> you're welcome
13:42:10 * hackagebot safe 0.3.2 - Library for safe (pattern match free) functions  http://hackage.haskell.org/package/safe-0.3.2 (NeilMitchell)
13:46:29 <zzing> What is a good library for dealing with the sum of two vectors? and also multiplying by scalar?
13:47:23 <dufflebunk> zzing, zipWith could do the sum of two vectors
13:47:33 <dufflebunk> map would do multiplication
13:48:03 <bblum> I wish there were a "Boolean" typeclass that I could derive on two-armed datatypes
13:48:26 <zzing> hmm, it operates on lists by the looks
13:48:27 <bblum> (with no parametres)
13:48:30 <bblum> that would give me a function akin to "not" that would flip between the arms
13:51:51 <TomvdZ> In wxHaskell, how do I set the background of a disabled textarea to white? bgcolor, textBgcolor and color don't seem to do much.
14:00:32 <zzing> @src atan2
14:00:33 <lambdabot> Source not found. Sorry.
14:07:10 * hackagebot glib 0.12.2 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.2 (AxelSimon)
14:12:12 * hackagebot gio 0.12.2 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.2 (AxelSimon)
14:12:14 * hackagebot cairo 0.12.2 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.2 (AxelSimon)
14:12:16 * hackagebot pango 0.12.2 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.2 (AxelSimon)
14:12:18 * hackagebot gtk 0.12.2 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.2 (AxelSimon)
14:28:14 <BMeph> bblum: Have you considered writing instead of just wishing? ;)
14:38:48 <mike-burns> I think he wishes everything used it, too.
14:40:28 <Shin-LaC> I'm trying to come up with a simple problem (even a toy problem) which shows the advantage of STM in terms of composability and deadlock avoidance
14:42:16 <shachaf> Shin-LaC: The standard bank account thing?
14:44:18 <shachaf> Shin-LaC: As mentioned in kmc's talk in http://www.ugcs.caltech.edu/~keegan/talks/why-learn-haskell/talk.text
14:44:32 <Shin-LaC> hm, that's actually a good idea
14:45:07 <Shin-LaC> if the version with locks locks the source first and the destination second, you can easily get a deadlock if you perform transfers in opposite directions at the same time
14:45:33 <bgamari> Alright, I'm quite confused, somehow my code runs twice as fast with profiling enabled
14:45:36 <Shin-LaC> shachaf: is that a fragment of a tex document?
14:45:41 <hpaste> kush_ pasted “xmonad.hs” at http://hpaste.org/53996
14:46:09 <shachaf> Shin-LaC: It's a markdown thing that turned into slides.
14:46:17 <shachaf> Shin-LaC: http://www.ugcs.caltech.edu/~keegan/talks/why-learn-haskell/
14:47:15 <Shin-LaC> ah, thanks
14:52:10 * hackagebot effects 0.2 - Computational Effects  http://hackage.haskell.org/package/effects-0.2 (SjoerdVisscher)
14:56:35 <zzing> Can anyone give me their thoughts on my quick physics sim code? https://gist.github.com/e8162749e5abecc5a2bf   It has issues where the body in orbit actually moves away from the planet, so I welcome comments on the code itself and ways in which I can debug.
14:58:30 <Cale> zzing: Well, it looks quite reasonable purely from a Haskell style perspective.
14:58:42 <zzing> That is a good point then :P
14:59:15 <zzing> I notice there are limits to the depth that the ticky function can go, which is an error I am not sure I know how to solve
14:59:16 <Cale> Given that it's in 2D, I wonder if you could derive any benefit from using complex numbers as your vectors.
14:59:34 <zzing> Cale, I wouldn't be surprised
14:59:40 <Cale> oh... depth?
15:00:13 <zzing> Cale, a stack overflow
15:00:37 <zzing> When epsilon was 0.005 and I did 1000 seconds, I believe that is when it was caught
15:00:47 <zzing> So it isn't a proper tail call If I understand it right
15:01:00 <Cale> oh, that ticky (I was looking at tick and thinking "this can't be a problem" :)
15:01:05 <Cale> right
15:01:21 <Cale> You just need a little strictness there to avoid building up large expressions in the s parameter
15:01:29 <Cale> Or you could just use foldl'
15:01:52 <zzing> I don't quite understand foldl tbh
15:01:58 <zzing> @src foldl'
15:01:59 <lambdabot> foldl' f a []     = a
15:01:59 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:02:17 <zzing> Converting it to a list form?
15:02:22 <Cale> foldl' is like foldl, but strict so that it forces the accumulating parameter to be evaluated
15:02:36 <Cale> Oh, I have dinner...
15:02:49 <ion> (If not sure, use foldl'.)
15:02:53 <Cale> I'll talk with you about it more after
15:02:55 <Cale> But...
15:03:25 <Cale> ticky is really doing something with the list [t, t-e .. 0]
15:03:43 <Cale> (well, I don't know if I want to rely on Enum there, but you get the idea)
15:04:05 <zzing> Cale, you are correct
15:11:01 <Philonous> Brrr, emacs lisp is so horrible, it's almost like it's only redeeming feature is not being java
15:11:09 <codemac> can I get some help on installing cabal-dev? I'm stuck in dependency hell right now
15:11:54 <codemac> It exits because it can't find Data.Map (omg what) because containers-0.2.0.1 is a hidden package?
15:12:19 <codemac> i need to sandbox my sandbox
15:12:40 <RaptorRarr> codemac: Yo dawg...
15:12:45 <codemac> :P
15:13:31 <codemac> but any suggestions? How do I 'unhide' a packages (i don't recall explicity hiding it)
15:14:03 <RaptorRarr> I'd recommend searching Google for the error message you get.
15:14:20 <RaptorRarr> If I remember right, similar errors were resolved in completely weird ways.
15:14:29 <RaptorRarr> (i.e., not by unhiding)
15:16:20 <gienah> codemac: I don't know as I don't use cabal install, but I note that containers-0.2.0.1 sounds really old, maybe try: ghc-pkg list containers
15:18:13 <parcs_> :O http://haskell.org/haskellwiki/GHC/Kinds has been merged in
15:18:33 <codemac> gienah: the problem is I'm on my mac, and macports is the best package management I have right now, so I'm sure the ghc on here is old. I was hoping I could rock some cabal-dev and get around some stuff.. good suggestion though..
15:19:00 <codemac> /opt/local/lib/ghc-6.10.4/./package.conf:
15:19:02 <codemac>     containers-0.2.0.1
15:19:06 <codemac> well, it's there.
15:19:07 <kfish> parcs_, what's the extension name?
15:19:32 <parcs_> PolyKinds
15:19:57 <kfish> is that a valid extension name? it's < 32 characters! ;-)
15:20:38 <kfish> surely it must be UndecidablePolymorphicKindPromotion or something
15:20:50 <ocharles> -XBadassKindPolymorphism
15:21:15 <codemac> Philonous: I'm gonna put it outh there that I wish Yi was further along. Unfortunately my haskell-fu is too weak to contribute
15:21:21 <gienah> codemac: I wonder how dangerous this would be: ghc-pkg expose containers
15:22:53 <codemac> gienah: hm, did `sudo ghc-pkg expose containers` and then ran `cabal install cabal-dev` and still the exact same error
15:24:02 <hpaste> codemac pasted “cabal-dev errors” at http://hpaste.org/53997
15:24:33 <codemac> pasted the full error in case I'm having problems reading.
15:25:19 <scshunt> win 24
15:25:52 <Cale> zzing: So, I'm back :)
15:26:15 <ski> parcs_ : i would assume `PolyKinds' meant kind polymorphism
15:27:49 <codemac> does anyone use haskell platform along with macports? Maybe I can blow away the macports ghc.. hm, but I use that for xmonad..
15:28:10 <Hunner> xmonad on mac? :)
15:28:48 <kfish> Hunner, sounds more usable than that shiny mouse-needing ui cruft
15:29:29 <mike-burns> The application dialogs wouldn't change simply because you change WM.
15:29:33 <Hunner> I do seriously miss my xmonad :(
15:31:15 <gienah> codemac: I wonder if its having trouble understanding the cabal-dev.cabal file, on the part where it wants containers for ghc 6.10
15:31:22 <Cale> zzing: Okay, so looking again at it, ticky is more or less iterating (\x -> tick p x e) so long as the sum of the epsilons in time is less than t.
15:31:40 <codemac> Hunner: I built a macports version of x11, install xmonad, run urxvt & emacs under it (mostly so I can use my dina font)
15:31:46 <gienah> codemac: anyway ghc 6.10 is really old. Would be best to update it somehow.
15:32:08 <codemac> gienah: Yea, I did a cabal unpack, and removed the version restriction for 6.10, but didn't seem to help
15:32:20 <codemac> gienah: gonna see if I can't have two ghc's along side eachother...
15:32:43 <gienah> codemac: how much do you know or want to know about linux software development?
15:33:00 <codemac> gienah: I know plenty, I'm just out of my element on a mac
15:33:06 <Cale> zzing: If you're still around... one thing we can do to make this a little nicer is to make sure that in tick, the Ship is the last parameter, since 1) this means that it produces a function Ship -> Ship given its first two parameters, which is just nice, and 2) we're going to be applying it to different Ship values more frequently than different time steps.
15:33:38 <gienah> codemac: I can think of another experimental approach: gentoo prefix, this is where you install a gentoo development environment in a directory on the mac
15:34:19 <gienah> codemac: it would require some work, then theoretically I guess it should be possible to emerge ghc 7.2.1, xmonad, etc
15:34:26 <codemac> gienah: oh god, the last time I used gentoo I burnt out my laptop cpu (circa 2005?) because I was too stupid to implement cpufreqd on my laptop
15:34:52 <gienah> codemac: what I mean is running gentoo ebuilds under macos X
15:34:53 <Cale> zzing: To fix the bug, the simplest change we could make is to turn on BangPatterns with {-# LANGUAGE BangPatterns #-} and then stick a ! in front of the s parameter in ticky.
15:35:39 <codemac> gienah: Yup, I'd rather do it with pacman if I'm going to spend all that time anyways
15:35:59 <gienah> codemac: gentoo prefix supports macos x, the haskell stuff is experimental: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
15:36:14 <Hunner> codemac: So... dina comes in ttf now: http://www.geenat.com/?p=66
15:37:01 <codemac> Hunner: dina in ttf is no dice, bold looks bad, and the letters aren't the same
15:37:31 <gienah> codemac: maybe you can install arch linux in a chroot on macos X and install stuff with pacman, I guess this is what you mean
15:38:12 <gienah> codemac: maybe that might be better, if you are concerned about ghc and haskell builds melting the laptop
15:40:18 <codemac> gienah: haha, not too worried, I'm just way more experienced with archlinux. Unfortunately they don't have a working mac os x tree of pkgbuilds, so gentoo may go better if they have some active community around it.
15:40:38 <codemac> and all this because I wanted to install hakyll
15:41:28 <zzing> Cale, what would be a methodology for me to turn this program into something where I can print a progressive value changes?
15:41:28 <gienah> codemac: I'm a gentoo dev, we have a channel: #gentoo-haskell
15:43:05 <Cale> zzing: Well, once we've rearranged the parameters of tick, (if you don't want to, then you can use a lambda anyway) we can write what ticky is doing in terms of iterate
15:43:22 <Cale> iterate (tick p epsilon) s
15:43:36 <zzing> :t iterate
15:43:37 <lambdabot> forall a. (a -> a) -> a -> [a]
15:43:44 <Cale> > iterate (+1) 0
15:43:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:43:46 <zzing> I don't think I have seen that one
15:43:57 <zzing> ok
15:44:03 <zzing> How do we limit it?
15:44:12 <zzing> Or is it just infinite
15:44:15 <Cale> takeWhile/take/etc.
15:44:28 <Cale> It's always infinite, we can clip it afterward
15:44:43 <zzing> nice
15:44:49 <zzing> Lazy advantages
15:44:51 <ski> > take 20 (iterate (+1) 0)
15:44:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
15:45:15 <ski> it's only compute as much of the infinite list as is required
15:46:00 <fragamus> help
15:46:24 <Cale> zzing: The problem you were having with ticky, I should say, is that nothing was forcing the 's' parameter to be evaluated, so a large expression was being built up there.
15:46:38 <ski> fragamus : it's hard to help if you haven't said what you want help with ..
15:47:03 <fragamus> actually it helps that you care enough to say that
15:47:13 <fragamus> thank you!!!
15:47:28 <zzing> ...
15:47:48 <fragamus> I am trying to use RWH example to traverse the file system
15:47:50 <Cale> zzing: It's important to understand that expressions aren't just compile-time things :)
15:48:07 <zzing> certainly, there is work to do at runtime as well
15:48:10 <ski> fragamus : it's usually considered polite on IRC help channels to state your question immediately, so that people can decide if they're able to help before having to commit themselves to it :)
15:48:14 <Cale> zzing: Representations of expressions (also called "thunks") are hanging around at runtime
15:48:22 <fragamus> I'm having a problem:
15:48:57 <fragamus> maybeIO :: IO a -> IO (Maybe a)
15:48:57 <fragamus> maybeIO act = handle (\_ -> return Nothing) (Just `liftM` act)
15:49:24 <fragamus> Ambiguous type variable `e0' in the constraint: (GHC.Exception.Exception e0) arising from a use of `handle'
15:49:25 <parcs_> (\(_ :: SomeException) -> return Nothing)
15:49:31 <fragamus> ah
15:49:50 <fragamus> how do I find out where IOException is declared
15:50:14 <monochrom> @hoogle IOException
15:50:14 <mike-burns> @hoogle IOException
15:50:14 <lambdabot> Control.OldException IOException :: IOException -> Exception
15:50:15 <lambdabot> Control.Exception.Base data IOException
15:50:15 <lambdabot> Control.Exception data IOException
15:50:17 <lambdabot> Control.OldException IOException :: IOException -> Exception
15:50:17 <fragamus> or whatever the main catch all IO exception class is called
15:50:19 <lambdabot> Control.Exception.Base data IOException
15:50:19 <Cale> zzing: so when ticky was ticking away... say we had something like  ticky s 1 -> ticky (tick p s e) (1 - e)
15:50:21 <lambdabot> Control.Exception data IOException
15:50:30 <fragamus> ty
15:50:31 <monochrom> it's in Control.Exception
15:50:34 <Cale> now the 1 - e has to be evaluated because we need to know if it's < 0
15:51:09 <ski> @type liftM (either (\(_ :: Control.Exception.SomeException) -> Nothing) Just) . Control.Exception.try
15:51:10 <lambdabot> forall a. IO a -> IO (Maybe a)
15:51:21 <Cale> So we get, say, ticky (tick p s e) 0.99995 (or whatever), but nothing has forced the tick p s e to evaluate, and we proceed:
15:51:45 <Cale> -> ticky (tick p (tick p s e)) (0.99995 - e)
15:52:01 <Cale> and you can probably see the start of the problem here :)
15:52:11 <Cale> oh, I missed an e there
15:52:15 <Cale> but you get the idea
15:52:36 * ski . o O ( `ricky (tick y (tick y ta vi))' )
15:52:45 <Cale> It's going to build up a very large expression consisting of many applications of tick
15:52:51 <zzing> I think so
15:52:57 <zzing> May I assume that e is my ε῞
15:53:01 <Cale> yes
15:53:18 <Cale> I've been writing e in place of ε because it's easier for me to type
15:53:40 <zzing> fair enough, I type a bit of greek, so it is all good
15:53:46 <Cale> (Too lazy to have to press both my shift keys twice ;)
15:53:51 <bblum> can i quantify with a typeclass a parameterised datatype? "data (Show a) => Message a = Warn [a] | Error [a]", for example
15:54:35 <bgamari> Is there any way to get GHC to recursively specialize?
15:54:55 <ski> bblum : i'm not sure what you're asking
15:55:05 <zzing> ok, just so I see this again...
15:55:09 <zzing> :t iterate
15:55:10 <lambdabot> forall a. (a -> a) -> a -> [a]
15:55:12 <ski> (what does "quantify with a typeclass a parameterised datatype" mean ?)
15:55:14 <Cale> bblum: That is syntactically valid, but probably doesn't mean what you want it to mean. Also your description is... completely unrelated to the piece of code you gave.
15:55:34 <zzing> So I want to rewrite ticky ultimately
15:55:49 <Cale> bgamari: If you find one, please let me know :)
15:55:56 <bblum> ski: Cale: to rephrase, i want to have a parameterised datatype that i can only initialise with a type that implements a certain typeclass
15:55:56 <bgamari> i.e. if I have a polymorphic function f with calls other polymorphic functions g, h, etc., could I specialize f and have ghc specialize g and h as well
15:56:01 <bgamari> Cale: It would be a nice feature
15:56:05 <Cale> bgamari: I am in the process of specialising a fair amount of code by hand.
15:56:15 <Cale> (well, adding the pragmas)
15:56:51 <bgamari> Cale: Yeah, I have the same issue; minor annoyance in my case but I can envision cases where it would be far harder
15:56:53 <Cale> bblum: You can do it, but the syntax you wrote there only restricts the type of the data constructors somewhat uselessly.
15:57:11 <bblum> Cale: hm. what's the right way, then?
15:57:12 <ski> bblum : maybe with <http://hackage.haskell.org/trac/ghc/wiki/KindFact>, i'm not sure
15:57:12 <Cale> bblum: It doesn't save all the functions which use values of that type from requiring the same typeclass constraint
15:57:32 <bblum> Cale: right, that's what i am interested in
15:57:34 <Cale> bblum: You can use GADT syntax to get something deeper:
15:57:42 <fushunpoon> Hello, what's the most elegant Zipper-based library for Haskell right now? I have some large functional structure and would like to replace certain values deep inside that tree.
15:58:10 <Cale> data Message a where Warn :: (Show a) => [a] -> Message a; Error :: (Show a) => [a] -> Message a
15:58:36 <Cale> That will actually pack a typeclass dictionary for Show into the data constructors
15:58:51 <bblum> Cale: interesting. does that let me pattern-match with Show and Error?
15:59:06 <Cale> so functions accepting Message a arguments, and pattern matching on the constructors will automatically discharge a (Show a) constraint.
15:59:18 * ski things bblum wants `Message :: (a :: *) -> Show a => *'
15:59:19 <Cale> (as if by magic)
15:59:32 <parcs_> aw, PolyKinds doesn't work at all yet :(
15:59:42 <ski> bblum : it lets you match on `Warn' and `Error', yes
15:59:48 <Cale> bblum: So you'll then be able to write:
16:00:00 <Cale> display :: Message a -> IO ()
16:00:40 <zzing> @src iterate
16:00:40 <lambdabot> iterate f x =  x : iterate f (f x)
16:00:45 <Cale> display (Warn xs) = putStrLn $ "Warning: " ++ show xs
16:00:50 <Cale> etc.
16:01:00 <shachaf> Cale: Of course you could just use a String.
16:01:02 <ski> bblum : Cale's GADT there allows `foo :: Message a -> Either [String] [String]; foo (Warn as) = Left (show as); foo (Error as) = Right (show as)'
16:01:09 <Cale> Note the lack of a typeclass constraint on display
16:01:18 <bblum> interesting
16:01:23 <ski> bblum : note that `a' in the type signature of `foo' is *not* constrained
16:01:33 <bblum> it is implicitly constrained?
16:01:49 <shachaf> bblum: No, there's no such thing, really.
16:02:03 <Cale> bblum: It's only constrained once you know that it's either Warn or Error.
16:02:08 <shachaf> bblum: The dictionary is part of the Message constructors themselves.
16:02:14 <shachaf> Or, rather, is passed to them.
16:02:14 <bblum> Cale: oh that's super cool
16:02:32 <shachaf> You could still just use a String in this particular case. :-)
16:02:34 <ski> bblum : note that you can have different constraints on each data constructor, though Cale's GADT example didn't show that -- when you match on `Warn as' e.g., you "discover" the contraint `Show a' (from the data constructor signature), so that you can use `show' in that branch
16:02:48 <Cale> bblum: On an implementation level, it's just storing (a pointer to) the implementation of the Show typeclass in with the list of values.
16:02:57 * bblum nods
16:03:15 <ski> bblum : effectively, `Show a' is an implicit argument of the `Warn' (and `Error') data constructor(s)
16:03:22 <bblum> yes
16:03:22 <bblum> "GADT syntax" is the name for this technique? or it is something more general?
16:03:28 <ski> `foo' takes no implict argument, though
16:03:36 <ski> yes, GADT syntax
16:03:38 <shachaf> bblum: "Existential types"
16:03:53 <ski> (GADT stands for "Generalized Algebraic Data Type")
16:03:54 <Cale> GADT syntax is the syntax of data declarations using 'where' with explicit type signatures for each constructor
16:03:56 <shachaf> GADT syntax is one (natural) way to express them in GHC, though.
16:04:02 <Cale> NO!
16:04:06 <Cale> This isn't existential types
16:04:09 <shachaf> Oh.
16:04:12 <bblum> haha
16:04:14 <shachaf> Did I misread something?
16:04:19 <shachaf> Oh.
16:04:24 <Cale> Yes, you missed that the type parameter was not gone :)
16:04:25 <shachaf> I thought this was a completely different example.
16:04:28 <ski> bblum : it is possible to implement existential types using GADT syntax, instead of the other syntax
16:04:32 <shachaf> Ignore me.
16:04:44 <shachaf> This is more interesting than I thought, then.
16:05:06 <bblum> ski: "the other", meaning "data ... = ... | ... | ... ..."?
16:05:14 <shachaf> Because you can still have a function :: Message Int -> ... and so on.
16:05:16 <Cale> Yeah, to get the equivalent of existential types from here is easy. We can forget the type of the lists, remembering only their implementation of Show simply by removing the type parameter:
16:05:27 <shachaf> ski: But this isn't an existential type. :-)
16:05:31 <shachaf> Oh, er.
16:05:39 * shachaf is not able to read what people say very well today.
16:05:40 <Cale> data Message where Warn :: (Show a) => [a] -> Message; Error :: (Show a) => [a] -> Message
16:05:41 <ski> bblum : yeah, i mean like `data Foo a = forall x. C a x => MkFoo (Bar a x)'
16:06:27 <ski> bblum : which in GADT syntax is written like `data Foo :: * -> * where MkFoo :: forall x. C a x => Bar a x -> Foo a', where the `forall x. ' part is optional, as usual
16:06:46 <shachaf> ski: Foo :: * -> *?
16:06:49 <Cale> actually, can traditional existential types have more than one constructor? I don't know whether or not the syntax allows it.
16:07:05 <Cale> (of course it's semantically reasonable)
16:07:12 <ski> shachaf : kind signature, to avoid writing a dummy tyvar, which will not be of any use anyway
16:07:14 <jmcarthur> i think they can
16:07:32 <ski> Cale : they definitely can
16:08:08 <ski> one of the first examples i saw was `data Expr a = Lit a | forall b. App (Expr (b -> a)) (Expr a)'
16:08:11 <jmcarthur> ghc accepts this data Foo = forall a. Foo a | forall b. Bar b
16:08:31 <Cale> Egg salad
16:08:43 <jmcarthur> even if that wasn't acceptable syntax, GADTs would also suffice
16:08:46 <Cale> The GADT syntax is probably clearer anyway
16:09:18 <ski> sometimes it's nice not to have to repeat all the result types (in case they're the same in most/all constructors)
16:09:46 <ski> (especially if you have several type parameters)
16:10:35 <roconnor> @type min
16:10:36 <lambdabot> forall a. (Ord a) => a -> a -> a
16:10:36 <hpaste> dufflebunk pasted “haskell-platform error” at http://hpaste.org/53999
16:10:37 <zzing> Cale, I am trying to reason about iterate. So am I basically looking to write a function that calculates the new ship based on the previous ship?
16:10:47 <dufflebunk> Is anyone here familiar with building haskell-platform form source? I'm getting a weird error
16:12:14 <ski> @src iterate
16:12:15 <lambdabot> iterate f x =  x : iterate f (f x)
16:13:23 <zzing> x : (f x) : f (f x) : ...   therefore, yes
16:14:02 <dufflebunk> Setup is saying it needs the happy program, but it's trying to /build/ happy... so something odd is happening.
16:14:30 <ski> > iterate f x
16:14:31 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
16:14:37 <ski> zzing ^ :)
16:15:08 <ujihisa> > iterate iterate x
16:15:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:15:37 <zzing> This is why haskell eventually blows my mind up.
16:15:40 <zzing> But this is good
16:16:10 <zzing> : 3:+5
16:16:17 <zzing> > 3:+5
16:16:19 <lambdabot>   3.0 :+ 5.0
16:16:28 <zzing> > 3:+5 * 6:+7
16:16:30 <lambdabot>   Precedence parsing error
16:16:30 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `D...
16:17:01 <zzing> That is not what I would expect
16:18:22 <ski> > (3:+5) * (6:+7)
16:18:24 <lambdabot>   (-17.0) :+ 51.0
16:19:35 <zzing> Why is :+ not done so that it has more precidence than *?
16:19:50 <ski> well, it's conceptually an addition
16:20:42 <zzing> I suppose so
16:20:47 <Apocalisp> Was somebody asking for Icelandic translations of Type and Kind?
16:21:18 <zzing> I would love a 'i', 'j', 'k' ... 2+3j+4k+9l => Quaternion :P
16:22:55 <ski> well, you could define `u',`i',`j',`k' as inclusion functions and write `u 2 + i 3 + j 4 + k 9', i suppose
16:23:39 <ski> > let i = 0 :+ 1  in (3 + 5*i) * (6 + 7*i)
16:23:40 <lambdabot>   (-17.0) :+ 51.0
16:23:58 <rwbarton> define instance Num a => Num (a -> a) where ... fromInteger n = (*) n ...
16:24:16 <ski> > let u = (:+ 0); i = (0 :+)  in (u 3 + i 5) * (u 6 + i 7)
16:24:17 <lambdabot>   (-17.0) :+ 51.0
16:24:57 <ski> rwbarton : heh
16:25:06 <jmcarthur> or you could just have i j k and be what they actually mean and use multiplication
16:25:29 <ski> yeah, like my example above
16:25:41 <zzing> jmcarthur: i j and k are each different sqrts of -1 of a sort
16:25:50 <jmcarthur> yes?
16:26:11 <zzing> yes, it is a means of extending a complex number to higher dimensions
16:26:21 <zzing> i /= j /= k
16:26:24 <jmcarthur> well i mean... i know what they are
16:27:06 <jmcarthur> data Quaternion a = Quaternion a a a a; u = Quaternion 1 0 0 0; i = Quaternion 0 1 0 0; j = Quaternion 0 0 1 0; k = Quaternion 0 0 0 1
16:27:51 <jmcarthur> well i guess with this scheme you don't need u to be named, as it's just 1 if you have a sane Num instance
16:28:19 <rwbarton> instance Num a => Num (a -> a) with multiplication is a lot more useful than instance Num a => Num (b -> a) with constant functions
16:28:32 <jmcarthur> i disagree
16:28:41 <zzing> Is Cale this Cale? http://www.blogger.com/profile/02239068589033148700
16:28:51 <zzing> Just saw a comment on a haskell blog
16:28:56 <rwbarton> it's a lot more common in mathematics for "3" to mean "multiplication by 3" than "the constant function 3"
16:29:17 <rwbarton> though it helps if you know from context that things are linear
16:29:33 <jmcarthur> rwbarton: i think this is just a symptom of fromInteger being in the Num type class
16:29:51 <rwbarton> if a is a ring, then linear functions a -> a really are just elements of a
16:30:01 <jmcarthur> for the other things, i prefer the constant function semantics, but i agree that it doesn't always make as much sense for numeric literals
16:30:01 <rwbarton> so in particular they are a ring too, so why not make them an instance of Num
16:30:33 <jmcarthur> but i have used the numeric literals as constant functions too, really
16:30:44 <mm_freak> rwbarton: there is much more useful function arithmetic (than Num) in the vector-space package
16:30:46 <rwbarton> Of course you can't express in Haskell that the functions are supposed to be linear and simultaneously use function application
16:31:27 <Cale> zzing: Probably? :)
16:31:32 <zzing> heh
16:31:45 <zzing> Cale, I am exploring your idea about using complex numbers.
16:31:58 <Cale> zzing: I don't use Blogger, but I have put comments on Blogger blogs before
16:32:36 <zzing> I am wondering how much of these functional things I learn can be applied to C++ with the C++11 course I might end up taking next semester.
16:33:43 <zzing> Cale, the article I found was one on the evils of the for statement and many examples of how you can replace it with many of these nice higher level things.
16:35:40 <mm_freak> zzing: this is where OO languages really suck bad…  because everything is a special case, you need a special language construct for everything like the __call hack in PHP
16:35:50 <ski> > map (`mod` (-65)) [i^2 | i <- [8,18,47,57]]
16:35:52 <lambdabot>   [-1,-1,-1,-1]
16:35:57 <fragamus> what does it mean: ld: warning: text reloc in _blah
16:36:31 <cobra-the-joker> HEy guys ... i really cant print a newline in haskell ... any help ?
16:36:40 <zzing> putStrLn?
16:37:00 <mm_freak> or putChar '\n', if you really just want to print a line feed
16:37:06 <cobra-the-joker> zzing: i want to print a string that contains it
16:37:13 <mm_freak> putStr
16:38:17 <rwbarton> fragamus: it means your object file contains a section _blah which has a text reloc
16:38:20 <cobra-the-joker> ok this is what i want to do ... http://fpaste.org/8qVd/
16:38:25 <mm_freak> putStrLn "with implicit line-feed"
16:38:33 <mm_freak> putStr "with explicit line-feed\n"
16:39:04 <mm_freak> cobra-the-joker: what you want to do or what you want to print?
16:39:16 <mm_freak> because that code doesn't "do" anything…  it's just a string
16:39:47 <cobra-the-joker> mm_freak: its a function that returns a string ... and it doesnt recognise "\n" as a endline
16:39:59 <rwbarton> Yes, it does.
16:40:09 <rwbarton> what are you doing with the string it returns?
16:40:10 <cobra-the-joker> rwbarton: really ... it doesnt
16:40:18 <cobra-the-joker> rwbarton: i just call it
16:40:24 <rwbarton> from ghci?
16:40:33 <mm_freak> cobra-the-joker: print it with putStr
16:40:34 <cobra-the-joker> rwbarton: yes
16:40:52 <rwbarton> cobra-the-joker: putStrLn (printTree myTree)
16:41:01 <mm_freak> in GHCi you just get the string literal, which prints the line feeds escaped
16:41:14 <mm_freak> the line feeds are there, you just see them as \n
16:42:26 <rwbarton> this is so that you can see the value of any string in ghci, even if it has funny non-printing characters
16:43:22 <cobra-the-joker> hmmm .. i dont get what you are saying
16:43:32 <cobra-the-joker> but it is not working with putStr
16:43:32 <rwbarton> okay
16:43:36 <rwbarton> what is the name of your tree
16:43:40 <zzing> Is there a multiline comment available?
16:43:54 <cobra-the-joker> rwbarton: submit to you the full code ?
16:43:58 <mm_freak> cobra-the-joker: try this in GHCi:  Char.chr 10
16:44:01 <rwbarton> if you like
16:44:08 <mm_freak> this turns an Int character code into a character
16:44:23 <mm_freak> you will find it prints '\n' instead of two lines of single quotes
16:44:30 <zzing> > show (3 :+ 5)
16:44:31 <lambdabot>   "3.0 :+ 5.0"
16:44:34 <rwbarton> but all you need to do is put   putStr (...)   around whatever you are typing into ghci now
16:44:45 <cobra-the-joker> http://fpaste.org/V9AS/
16:45:00 <cobra-the-joker> mm_freak: yes
16:45:07 <mm_freak> zzing: {- ... -}
16:45:17 <rwbarton> for example, try   putStr "a\nb\n"
16:45:57 <mm_freak> cobra-the-joker: if the result of an expression is a String in GHCi, it prints the string literal
16:46:14 <mm_freak> it doesn't print the raw string to the terminal, but it prints a source code representation of the string
16:46:21 <zzing> merci
16:46:29 <cobra-the-joker> hmm
16:46:45 <mm_freak> if, on the other hand, the result of an expression is IO (), then it just runs the corresponding action…  putStr would print a raw string
16:46:55 <mm_freak> :t putStr
16:46:56 <lambdabot> String -> IO ()
16:47:56 <cobra-the-joker> yes ... it worked
16:48:02 <cobra-the-joker> thanx
16:48:59 <zzing> If I do import ...   will its contents be available from the top level or from within the name ...?
16:49:13 <mm_freak> zzing: both
16:49:17 <zzing> great
16:49:36 <mm_freak> if you want only qualified names, use "import qualified"
16:52:01 <mm_freak> the banana bracket syntax does not support infix operators
16:52:04 <mm_freak> that's odd
16:52:38 <mm_freak> you have to write (| (<+>) x y |) instead of (| x <+> y |)
16:53:16 <SavageSimian> how do i assign a value inside a function? ex: f n = do x = read getLine
16:53:41 <mm_freak> SavageSimian: x <- getLine
16:53:44 <mm_freak> then (read x)
16:53:52 <mm_freak> or:  x <- fmap read getLine
16:54:01 <JoeyA> Alternatively, import Control.Applicative and: x <- read <$> getLine
16:54:08 <JoeyA> (<$>) is the same as fmap
16:54:32 <SavageSimian> ok. so x <- fmap read getLine will return a Double if i input 5.5?
16:54:44 <mm_freak> SavageSimian: as long as you are in do-notation you can give the result of a monadic action a name using "<-"
16:54:54 <rwbarton> it will return whatever type you try to use x at
16:54:59 <mm_freak> yes, it will, as long as the compiler can infer the type of 'x' to be Double
16:55:08 <SavageSimian> ok. ty
16:55:35 <mm_freak> to specify the type, you can write (x :: Double) somewhere, where you use 'x'
16:55:46 <mm_freak> or you can write:  x <- fmap read getLine :: IO Double
16:56:04 <mm_freak> or, with the ScopedTypeVariables extension you can write:  x :: Double <- fmap read getLine
16:56:11 <SavageSimian> what's the difference between a Double and an IO Double?
16:56:28 <mm_freak> fmap read getLine is a value of type IO Double
16:56:37 <mm_freak> that's an action that, when run, results in a Double
16:58:28 <SavageSimian> does 'do' serve any other purpose then to define a scoped block of code?
16:58:48 <mm_freak> yes, it lets you compose an IO action from simpler parts (for now)
16:59:29 <mm_freak> in fact it has little to do with scope, except for the variables that are results from actions like x <- fmap read getLine
17:00:07 <mm_freak> the scope of the whole action is introduced by '=', not by 'do'
17:00:48 <SavageSimian> so 'do' has mainly to do with IO?
17:00:57 <mm_freak> for now ;)
17:01:13 <SavageSimian> ok. t
17:01:35 <mm_freak> IO is a monad, and 'do' is for every monad, but you will get to that later…  don't worry about it for now
17:02:12 <monochrom> (just like when you're playing 1.0+2.0 for Double, you don't know that it's way more general than just Double)
17:02:45 <JoeyA> > do {x <- [1,2,3]; y <- [4,5,6]; return (x,y)} -- /do/ worry about it now! (pun intended)
17:02:46 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:03:24 <mm_freak> > sequence [[1, 2, 3], [4, 5, 6]]
17:03:25 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
17:03:51 <mm_freak> > liftA2 (,) [1..3] [4..6]
17:03:52 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
17:03:56 <monochrom> I'm actually pretty agnostic whether you worry about it now or later.
17:04:40 <mm_freak> monochrom: people seem to have an easier time getting things, when they approach the generic 'do' later than the IO-specific 'do'
17:05:07 <mm_freak> at best after knowing how to transform do-notation into combinator style
17:05:18 <SavageSimian> isn't the return from (x, y) a tuple; ([1,2,3], [4,5,6]) ?
17:05:43 <mm_freak> SavageSimian: in the list monad 'x' represents the values 1, 2 and 3, and y represents the values 4, 5, 6
17:05:59 <mm_freak> so (x, y) represents all combinations where x is 1, 2, 3 and y is 4, 5, 6
17:06:37 <mm_freak> > do x <- [1..3 :: Int]; y <- [4..6 :: Int]; return (printf "I have %d and %d" x y)
17:06:38 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:06:38 <lambdabot>    `GHC.Show.Show b'
17:06:38 <lambdabot>      a...
17:06:45 <mm_freak> > do x <- [1..3 :: Int]; y <- [4..6 :: Int]; return (printf "I have %d and %d" x y :: String)
17:06:45 <lambdabot>   ["I have 1 and 4","I have 1 and 5","I have 1 and 6","I have 2 and 4","I hav...
17:07:41 <mm_freak> perhaps replace "all combinations" by "all tuples"
17:07:48 <SavageSimian> guess i'll have to work on it...
17:08:08 <mm_freak> i recommend not caring about the list-do for now…  concentrate on the IO-do
17:08:20 <mm_freak> but if you are interested, then your search term is "list monad"
17:09:04 <SavageSimian> i am. thanks.
17:09:08 <mm_freak> SavageSimian: one key similarity is:  IO is a monad and [] is a monad
17:09:21 <mm_freak> where in IO you have 'IO a' to the right of <- and 'a' to the left
17:09:29 <mm_freak> in the list monad you have [a] to the right and 'a' to the left
17:10:01 <mm_freak> for "x <- c" in the IO monad, x is a name for the result of running c
17:10:10 <mm_freak> in the list monad x is the name for each element from the list c
17:11:49 <mm_freak> if you can't get enough of that, Maybe is also a monad, and it's up to you to understand '<-' for it =)
17:12:11 <mm_freak> > do x <- Just 3; y <- Nothing; return (x, y)
17:12:12 <lambdabot>   Nothing
17:12:16 <mm_freak> > do x <- Just 3; y <- Just 4; return (x, y)
17:12:17 <lambdabot>   Just (3,4)
17:13:01 <mm_freak> and there are a lot more monads to explore
17:14:27 <zzing> Do we have a package that offers a polar vector field plotter?
17:22:16 * hackagebot iteratee-compress 0.3.0.0 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.3.0.0 (MaciejPiechotka)
17:23:35 <zzing> @hoogle atan2
17:23:36 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
17:23:52 <zzing> > atan2 (5 :+ 5)
17:23:53 <lambdabot>   Overlapping instances for GHC.Show.Show
17:23:53 <lambdabot>                              (Data....
17:23:57 <zzing> > atan (5 :+ 5)
17:23:58 <lambdabot>   1.4701377726075762 :+ 9.93254493672511e-2
17:24:13 <elliott> Does the vector package offer no boxed, /strict/ vectors?
17:24:43 <zzing> > atan2 (imagPart (5 :+ 5)) (realPart (5 :+ 5))
17:24:44 <lambdabot>   0.7853981633974483
17:25:08 <zzing> > 0.7853981633974483 * (pi/180.0)
17:25:10 <lambdabot>   1.3707783890401887e-2
17:25:35 <zzing> > 0.7853981633974483 * (180.0/pi)
17:25:37 <lambdabot>   45.0
17:25:43 <shachaf> elliott: Not that I saw when I looked for a few minutes this one time.
17:25:57 <elliott> shachaf: That sucks. I guess I'll just add my own seqs.
17:26:14 <cobra-the-joker> Hey guys ... How can i convert from IO String to String ... so i can perform some functions on it
17:26:33 <elliott> You can't.
17:26:34 <shachaf> cobra-the-joker: See the FAQ.
17:26:37 <shachaf> @where faq
17:26:37 <JoeyA> cobra-the-joker: Bind it to a subsequent action that uses it.
17:26:37 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:26:55 <JoeyA> e.g. readLn >>= \x -> print $ x + 10
17:27:03 <shachaf> cobra-the-joker: In particular section 5.10.
17:29:05 <cobra-the-joker> shachaf: yes yes , but it says i cant !!
17:30:27 <elliott> cobra-the-joker: You can't.
17:30:28 <shachaf> cobra-the-joker: It's correct.
17:30:40 <shachaf> cobra-the-joker: It also has a link to an explanation.
17:30:48 <JoeyA> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:30:53 <shachaf> We could explain it here, but our explanation probably won't be as thorough as the one it links to. :-)
17:31:02 <RaptorRarr> cobra-the-joker: Use fmap f io_str, then f will have io_str as a String.
17:31:46 <cobra-the-joker> hmmm ok
17:32:01 <mm_freak> does anyone know of a way to turn off CSE for specific definitions?
17:32:48 <shachaf> Put the definition in a different file.
17:33:17 <mm_freak> not a satisfying solution
17:33:28 <mm_freak> but probably the only one
17:33:36 <bblum> anybody who's familiar with Language.C around? what is the Bool in the return value of Language.C.Syntax.AST.partitionDeclSpecs do?
17:35:35 <shachaf> bblum: Seems to have to do with inlining.
17:35:45 <shachaf> Or with
17:35:48 <shachaf> "inline", rather.
17:36:15 * shachaf expects that wasn't very useful.
17:36:25 <ben_m> Greetings, everyone! I'm writing a genetic algorithm, which uses randomness at a lot of points. I really want to avoid having every function in the IO monad, so I have to thread the StdGen throw every function ... is there a nice way to do this, other than just (a, gen') = f gen; (b, gen'') = g gen'; ...?
17:36:40 <ben_m> through*
17:37:00 <shachaf> ben_m: Well, State will do the s -> (a,s) thing for you.
17:37:20 <shachaf> ben_m: You can probably write a more specific monad that has just that as its primitive, though.
17:37:22 <bblum> shachaf: yeah the documentation kinda sucks
17:37:45 <shachaf> @google MonadRandom
17:37:47 <lambdabot> http://hackage.haskell.org/package/MonadRandom
17:37:47 <lambdabot> Title: HackageDB: MonadRandom-0.1.6
17:38:09 <ben_m> shachaf, thanks, I'll look into State, didn't know you could use it like that
17:38:48 <shachaf> ben_m: That's exactly what State *is*. :-)
17:38:57 <shachaf> @unmtl State Random Char
17:38:58 <lambdabot> Random -> (Char, Random)
17:39:17 <ben_m> shachaf, the examples that used it have things like <- ask and <- put
17:39:32 <ben_m> I think.
17:39:35 <dylex> MonadRandom is quite nice -- I use it for all randomness.
17:39:38 <shachaf> ben_m: Right (though "get" instead of "ask").
17:39:44 <ben_m> Ah okay
17:39:57 <ben_m> I suppose they're just aliases to make working with the tuple nicer?
17:40:16 <shachaf> ben_m: So what your primitive would do would be the equivalent of do { randomState <- get; let (randomNumber, newRandomState) = makeRandom randomState; put newRandomState }
17:41:02 <rwbarton> ben_m: instead of "(a, gen') = f gen; (b, gen'') = g gen'" you will be able to write "a <- f; b <- g"
17:41:16 <ben_m> Okay, that's cool. Thanks :)
17:44:34 <simon> I just read a slide that exemplified bad monad tutorials with the analogy "A monad is like a burrito."
17:44:57 <shachaf> simon: Yes, it's a reference to a particular post about such things.
17:44:59 <shachaf> @where burrito
17:45:00 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
17:45:20 * shachaf tries to recall what edwardk's suggested addition to MonadState was. Was it state :: MonadState s m => (s -> (s,a)) -> m a?
17:45:39 <edwardk> shachaf: yes
17:45:54 <edwardk> shachaf: i do mean to push out a new version of mtl with that in eventually =)
17:46:16 <shachaf> Hah, edwardk is always watching you.
17:46:48 <Gwern-away> @quote
17:46:48 <lambdabot> fnord123 says: Haskell mainly helps with my C++ template coding when I'm doing money oriented programming
17:47:35 <simon> shachaf, cool!
17:48:16 <shachaf> gwern!
17:48:19 <shachaf> Are you going to Hac Boston?
17:53:52 <zzing> > (5 :+ 8) * 5
17:53:54 <lambdabot>   25.0 :+ 40.0
17:56:26 <zzing> > (+) 4 5 - 7
17:56:27 <lambdabot>   2
18:03:15 <zzing> @src Complex
18:03:15 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
18:03:58 <zzing> @src RealFloat
18:03:59 <lambdabot> Source not found. That's something I cannot allow to happen.
18:04:09 <zzing> @hoogle RealFloat
18:04:10 <lambdabot> Prelude class (RealFrac a, Floating a) => RealFloat a
18:04:10 <lambdabot> Data.Text.Lazy.Builder.RealFloat module Data.Text.Lazy.Builder.RealFloat
18:04:10 <lambdabot> Data.Text.Lazy.Builder.RealFloat realFloat :: RealFloat a => a -> Builder
18:04:33 <zzing> What precisely is a RealFloat?
18:04:50 <ion> See :i RealFloat in ghci.
18:05:43 <ion> It’s the intersection of reals and floats.
18:05:44 <cobra-the-joker> why IO in haskell so hard !!
18:05:58 <ion> It’s a conspiracy.
18:06:11 <cobra-the-joker> yes
18:06:16 <zzing> So a RealFloat can be a Double?
18:06:35 <ion> Sure, doubles represent real numbers and are floating.
18:07:19 * hackagebot statistics 0.10.0.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.0.1 (BryanOSullivan)
18:07:58 <zzing> hmm, this thing is taking time to figure
18:08:39 <ion> You can just think “everything these functions work with” when looking at the list in :i RealFloat.
18:09:38 <zzing> https://gist.github.com/e8162749e5abecc5a2bf    This error is not easy for me to figure: Couldn't match expected type `Planet' with actual type `Double'
18:09:55 <zzing> It is on line 68, the full error is at the top
18:10:24 <zzing> I give planetVelocity a planet, namely 'r', yet it seems to think it is a Double
18:11:07 <ion> r is not a Planet. It’s a Double. You extracted it from a Planet on line 67.
18:11:10 <shachaf> zzing: planetVelocity takes a Planet.
18:11:35 <zzing> oh I get it
18:11:36 <ion> If you want r to be the entire parameter, do “tick r (Ship pos vel) … = …”
18:11:38 <shachaf> zzing: But you're pattern-matching on the Planet that's given to "tick", so r is a Double.
18:11:54 <shachaf> zzing: Also, you should write type signatures on top-level functions. :-)
18:12:10 <ion> I was just about to say that. It really helps in verification and documentation.
18:12:19 * hackagebot ght 0.4.0.1 - Trivial routines for inspecting git repositories  http://hackage.haskell.org/package/ght-0.4.0.1 (ConradParker)
18:13:03 <zzing> ok, doing some of that
18:13:30 <elliott> Is there a widely accepted name for foo 0 _ = id; foo n f = f . foo (n-1) f?
18:13:41 <lpsmith> solidsnack, I don't think chris done's code will be all that useful to me, sadly
18:13:51 <solidsnack> lpsmith: Oh?
18:14:05 <aavogt> elliott:  \x -> iterate f x !! n ?
18:14:11 <elliott> aavogt: Name, not definition :-)
18:14:23 <lpsmith> Well, the philosophy behind his code and what I need is enough different...
18:14:25 <solidsnack> lpsmith: You need the pubsub functions or something else that only libpq provides?
18:14:31 <solidsnack> Oh, I see.
18:14:32 <zzing> > conjugate (5 :+ 5)
18:14:32 <shachaf> elliott: The Church encoding of a natural?
18:14:33 <lambdabot>   5.0 :+ (-5.0)
18:14:35 <lpsmith> No,  trying to hide the latency
18:14:41 <lpsmith> I have pubsub right now.
18:14:44 <shachaf> elliott: Going by the common convention, maybe "int" or something like that.
18:14:49 <aavogt> I mean that's 2 names, which is really close to the one name you wanted
18:14:56 <elliott> shachaf: I'd prefer something that evokes the repeating-a-function effect.
18:15:05 <lpsmith> I can't get the other aspects working,  because his code wasn't written with that in mind
18:15:14 <lpsmith> I kind of kludged my code to his.
18:15:15 <zzing> > magnitude (5 :+ 5)
18:15:16 <lambdabot>   Ambiguous occurrence `magnitude'
18:15:16 <lambdabot>  It could refer to either `Data.Complex.ma...
18:15:43 <lpsmith> and I'm not issuing queries before the results are back, yet.
18:15:57 <lpsmith> And I'm not sure why by inspection
18:17:04 <lpsmith> sigh
18:17:05 <solidsnack> Oh, hmm.
18:18:04 <solidsnack> I have to step out for awhile but I'll be in channel later and also tomorrow.
18:18:15 <lpsmith> well, I suppose it's almost ready to put up on github
18:18:20 <lpsmith> Even as is
18:18:28 <lpsmith> solidsnack, later!
18:18:29 <solidsnack> Would be neat to see it, yeah :)
18:19:12 <zzing> Now I have a problem with (vel + pvel) * ε  where ε is a double, but vel+pvel is complex. I thought they should multiply but it seems to be expecting a Complex Double. Not sure what to make of it. Line 71: https://gist.github.com/e8162749e5abecc5a2bf
18:20:22 <ion> zzing: * realToFrac ε
18:20:48 <zzing> ion, what exactly is the problem with ε?
18:20:55 <ion> It’s not complex.
18:21:06 <zzing> > ((5 :+ 5) + (5 :+ 5)) * 0.5
18:21:07 <lambdabot>   5.0 :+ 5.0
18:21:09 <zzing> neither is 0.5
18:21:15 <ion> :t 0.5
18:21:16 <lambdabot> forall t. (Fractional t) => t
18:21:28 <ion> Number literals are polymorphic.
18:21:42 <zzing> > ((5 :+ 5) + (5 :+ 5)) * (0.5::Double)
18:21:43 <lambdabot>   Couldn't match expected type `Data.Complex.Complex t'
18:21:43 <lambdabot>         against infer...
18:21:53 <zzing> > ((5 :+ 5) + (5 :+ 5)) * realToFrac (0.5::Double)
18:21:54 <lambdabot>   5.0 :+ 5.0
18:22:00 <zzing> fair enough, merci
18:24:39 <zzing> If I have an infinite list, how can I get the nth element safely?
18:24:52 <shachaf> zzing: !! is safe on an infinite list.
18:31:18 <zzing> hmm, my code looks better but I have to figure out the physics part of it later... :-(
18:32:20 <zzing> What is the easiest way to graph a whole lot of x and y coordinates and output an image for viewing?
18:32:55 <Eduard_Munteanu> @hackage chart
18:32:56 <lambdabot> http://hackage.haskell.org/package/chart
18:32:59 <Eduard_Munteanu> Maybe that ^^
18:33:15 <Eduard_Munteanu> Erm...
18:33:21 <Eduard_Munteanu> @hackage Chart
18:33:22 <lambdabot> http://hackage.haskell.org/package/Chart
18:33:31 <shachaf> @HACKAGE CHART
18:33:31 <lambdabot> Unknown command, try @list
18:33:48 <shachaf> ADD CHARTS TO HACKAGE GIVING HACKAGE
18:34:16 <Eduard_Munteanu> See Graphics.Rendering.Chart.Simple
18:34:26 <zzing> merci
18:38:54 <alang> @hackage plot
18:38:54 <lambdabot> http://hackage.haskell.org/package/plot
18:39:04 <alang> seems more up to date
18:39:50 <cobra-the-joker> http://fpaste.org/Mu17/ ---> gives me that error -> "Couldnt match expeted type 'Tree' with actual type 'm0 b0'
18:40:37 <shachaf> cobra-the-joker: The type of makeTree isn't given, but it probably doesn't return "IO anything".
18:40:48 <shachaf> So make it return IO something.
18:41:00 <shachaf> Or, rather, use its value in main.
18:41:07 <shachaf> What are you expecting this program to do?
18:41:23 <cobra-the-joker> shachaf:i want to make it return Tree type
18:41:36 <shachaf> cobra-the-joker: Not the function makeTree. The program.
18:41:51 <shachaf> You're defining a function "main"; what do you want it to do, once it has contructed a tree?
18:42:07 <shachaf> "returning" the Tree doesn't make much sense.
18:42:09 <cobra-the-joker> shachaf: its an assignment ... just make a tree from file input
18:42:19 <pchiusano> i have a class i want to make deriving Show, but one of the constructors contains a function - is there any way I can say derive show, except for this one constructor use some custom logic?
18:42:36 <cobra-the-joker> shachaf: so it should return a tree
18:43:23 <shachaf> cobra-the-joker: A program can't return a Haskell data structure. A program does something, like printing things out. Do you want to print the Tree out?
18:43:42 <cobra-the-joker> shachaf: i can recall it anything else
18:43:48 <shachaf> pchiusano: No easy way that I know of.
18:43:52 <shachaf> cobra-the-joker: What?
18:44:14 <cobra-the-joker> rename *
18:44:49 <shachaf> cobra-the-joker: What are you actually trying to do?
18:45:12 <cobra-the-joker> shachaf: make a function ... takes a fileName and returns a tree
18:45:17 <shachaf> You're writing a program which compiles to an executable, presumably. You're going to run that executable. That executable will read a file.
18:45:24 <Eduard_Munteanu> cobra-the-joker: main can't "return the tree"
18:45:26 <shachaf> What should it do then?
18:46:30 <Eduard_Munteanu> In that case it should be something like String -> ... -> IO Tree
18:46:50 <cobra-the-joker> shachaf: ok forget main .... i just wrote because i saw it in an example ... http://fpaste.org/ywpw/
18:47:18 <Eduard_Munteanu> That won't work.
18:47:20 <cobra-the-joker> Eduard_Munteanu: :( ... can't it return a tree ?
18:47:21 <shachaf> cobra-the-joker: If "main" isn't what your question is about, why is it the only thing you pasted? :-)
18:47:24 * shachaf looks.
18:47:34 * cobra-the-joker hides 
18:47:42 * shachaf sighs.
18:47:45 <cobra-the-joker> i thought it was like any other function :D
18:47:46 <cobra-the-joker> lol
18:47:57 <Eduard_Munteanu> cobra-the-joker: nope... either it returns IO Tree, or it can't read files
18:48:06 <shachaf> cobra-the-joker: We could probably explain what's going on here, but many other people have done that before.
18:48:22 <cobra-the-joker> hmmm ... so IO Tree then ... ok
18:48:22 <shachaf> cobra-the-joker: I recommend that you read an introduction to Haskell, which will probably explain it much better than anyone here can.
18:48:23 <Eduard_Munteanu> (IO anything generally)
18:48:35 <shachaf> cobra-the-joker: No, you probably don't want any function that returns IO Tree.
18:48:58 <cobra-the-joker> shachaf: i really read a big portion in many sections in it ... but  some stuff doesnt make sense to me sometimes
18:49:36 <Eduard_Munteanu> cobra-the-joker: how about a function that took the file contents, perhaps as a string, and returned a tree?
18:49:58 <cobra-the-joker> Eduard_Munteanu: thats what i am trying to do
18:50:05 <shachaf> Eduard_Munteanu: That's makeTree in http://fpaste.org/Mu17/ , presumably.
18:51:10 <Eduard_Munteanu> cobra-the-joker: ok, but then you have to forget about reading files. You just need to parse the input string.
18:52:01 <Eduard_Munteanu> How you come up with that string is a separate problem.
18:52:26 <cobra-the-joker> Eduard_Munteanu: getting the input from the file is mandatory ... get input from file ... produce a tree ... thats what i am trying to do
18:52:51 <Eduard_Munteanu> You will get it, only later.
18:53:08 <cobra-the-joker> after the deadline has come lol
18:53:43 <cobra-the-joker> Thanx for the info ... i should read more anyways
18:53:55 <Eduard_Munteanu> You should try to break this problem into smaller pieces.
18:54:13 <shachaf> cobra-the-joker: Produce a tree and *then what*?
18:54:16 <shachaf> Print it out?
18:54:20 <shachaf> Put it in another file?
18:54:32 <cobra-the-joker> shachaf: its a function ... so i can use it in the rest of the program
18:54:32 <shachaf> Dispose of it?
18:54:45 <shachaf> cobra-the-joker: You need to figure out what the rest of the program is.
18:54:58 <shachaf> Then you can just use your original "makeTree" function in that.
18:55:19 <Eduard_Munteanu> Do you have that "makeTree" function?
18:55:35 <cobra-the-joker> shachaf: i already told you ... its a tree manipulation assignment ... all what is told to us is writing functions .. like insertNode , deleteNode
18:55:39 <cobra-the-joker> Eduard_Munteanu: yes
18:55:47 <cobra-the-joker> i will submit the full file now
18:57:43 <wks> Hi. let f x = if x==0 then 1 else (f (x-1))+(f (x-1))
18:57:56 <cobra-the-joker> http://fpaste.org/oDW4/
18:58:07 <Eduard_Munteanu> wks: hi, let f x to you too :)
18:58:40 <c_wraith> wks: that looks like a *really* slow way to write: let f = (2^)
18:58:57 <wks> c_wraith:  It is true. That's very slow.
18:59:19 <wks> c_wraith:  It seems that f (x-1) is evaluated twice for every call to f
18:59:29 <c_wraith> it is, yes
18:59:58 <c_wraith> ghc does very, very minimal common subexpression elimination, because it's generally not a true optimization in haskell code.
19:00:34 <wks> I tried: let h x = if x==0 then 1 else let y=(f (x-1)) in y+y -- But this does not help.
19:01:01 <c_wraith> it should
19:01:01 <Eduard_Munteanu> cobra-the-joker: I see... but I'm going to ask you the same thing shachaf did
19:01:21 <c_wraith> wks: but note that running from ghci is very slow, anyway
19:02:21 <cobra-the-joker> Eduard_Munteanu: its a tree manipulation library :D
19:04:26 <Eduard_Munteanu> cobra-the-joker: the thing is, you can either make a tree from a string and an IO string from a filename, or you can make an IO Tree from a filename
19:05:15 <cobra-the-joker> Eduard_Munteanu: ok ... make an IO Tree from a filename
19:06:15 <Eduard_Munteanu> You write a function    readTree :: String -> IOTree
19:06:22 <Eduard_Munteanu> *IO Tree
19:06:24 <wks> c_wraith:  I wrote h in a program compiled with ghc. Unfortunately it does not seem to be optimized. h 30 is still slow.
19:06:44 <Eduard_Munteanu> That function can't be main, though.
19:07:07 <wks> Is there a way to force y=(f (x-1)) to be evaluated before y+y?
19:07:08 <Eduard_Munteanu> That's one of the reasons shachaf was asking what you want to do with it.
19:07:25 <tomprince> wks: Did your program do anyhting else? It may be that starup time is dominating.
19:07:38 <Eduard_Munteanu> wks: you should pass -O or -O2 to ghc
19:08:06 <RaptorRarr> wkc: seq y (y + y)
19:08:41 <c_wraith> RaptorRarr: that's basically irrelevant, unless y is a type with a non-strict +
19:09:09 <cobra-the-joker> Eduard_Munteanu: http://fpaste.org/fQgD/ ... doesnt work ... Invalid type signature : TreeMaker :: String -> IO Tree \n Should be of form <variable> :: Type
19:09:31 <Eduard_Munteanu> cobra-the-joker: 'TreeMaker' isn't a valid function name
19:09:45 <RaptorRarr> c_wraith: Sure :)
19:09:50 <Eduard_Munteanu> Functions / values can't start with uppercase letters.
19:09:56 <shachaf> Eduard_Munteanu: I don't think a function :: String -> IO Tree is a good idea if you can get away with String -> Tree.
19:10:20 <Eduard_Munteanu> I know.
19:10:30 <hpaste> wks pasted “A slow (2^).” at http://hpaste.org/54000
19:10:36 <Eduard_Munteanu> But he seems to think we'll never get to that :)
19:10:55 <shachaf> wks: h is calling f, not h. :-)
19:11:01 <wks> oops!!!
19:11:10 <wks> what a typo!
19:11:14 <shachaf> wks: Also see all those notes hpaste gave you.
19:11:45 <cobra-the-joker> Eduard_Munteanu: ok ... when i change the name ... it tells me cant match IO Tree with Tree
19:12:46 <Eduard_Munteanu> cobra-the-joker: well, makeTree gives you a Tree... how do you turn something into IO something, trivially?
19:12:56 <cobra-the-joker> i dont know :D
19:13:15 <cobra-the-joker> i wrote IO makeTree .. gave me error
19:13:34 <Eduard_Munteanu> Did your teacher tell you about 'return'?
19:13:45 <Eduard_Munteanu> :t return
19:13:46 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:14:07 <Eduard_Munteanu> (forget the monad stuff, pretend m is IO)
19:14:10 <cobra-the-joker> wow it worked :D
19:14:19 <cobra-the-joker> lol i actually made it
19:14:47 <cobra-the-joker> Eduard_Munteanu: the teacher gave us references to think about it .. baaad teacher
19:14:48 <cobra-the-joker> lol
19:15:16 <shachaf> cobra-the-joker: You're making it very difficult to help you, even though Eduard_Munteanu is really trying, you know. :-)
19:15:18 <Eduard_Munteanu> Oops, I might've spoiled it.
19:15:41 <cobra-the-joker> shachaf: i made it at last
19:15:45 * shachaf wonders whether cobra-the-joker is running into the runghc Show bug with main.
19:15:58 <wks> shachaf, Now h is faster after fixing the typo. And it concludes that ghci is not a problem.
19:16:29 <shachaf> cobra-the-joker: I wouldn't consider it "making it" until you have a good understanding of what you're doing. :-)
19:16:48 <Eduard_Munteanu> cobra-the-joker: what do you mean by references?
19:16:52 <cobra-the-joker> shachaf: well kind of ... they wanted a Tree ... i gave them an IO Tree
19:17:16 <cobra-the-joker> Eduard_Munteanu: like "Real World Haskell" .... and giving us chapters to read it
19:17:20 * hackagebot hastache 0.2.4 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.2.4 (SergeyLymar)
19:18:07 <monochrom> Real World Haskell is not a beginner book
19:18:21 <Eduard_Munteanu> cobra-the-joker: that's why I've been telling you to write a function that created a tree from a plain string instead of a filename
19:19:15 <cobra-the-joker> Eduard_Munteanu: makeTree does that
19:19:16 <Eduard_Munteanu> Something of type   String -> Tree   (where the String isn't a filename, but the actual contents of the file)
19:19:37 <Eduard_Munteanu> Yeah, almost...  [Int] -> Tree
19:19:38 <shachaf> Eduard_Munteanu: That's what cobra-the-joker's original makeTree function did.
19:19:50 <shachaf> Except it also didn't do the parsing (which is a good thing, I think).
19:20:00 <cobra-the-joker> Eduard_Munteanu: ok thats easy ... but how i can pass IO String to it ... that was the original problem
19:20:55 <RaptorRarr> cobra-the-joker: That's just fmap.
19:21:02 <RaptorRarr> @type fmap
19:21:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:21:30 <cobra-the-joker> makeTreeString :: String -> Tree		
19:21:30 <cobra-the-joker> makeTreeString str = (makeTree (toInts (splitString (str))))
19:21:39 <RaptorRarr> You have (String -> Tree) and IO String, you get IO Tree.
19:22:20 * hackagebot vty-ui 1.3 - An interactive terminal user interface library  for Vty  http://hackage.haskell.org/package/vty-ui-1.3 (JonathanDaugherty)
19:22:21 <Eduard_Munteanu> We can dumb this down using just do notation
19:23:42 <RaptorRarr> do { str <- whatsitToGetFromFile; print (treeThingy str) }
19:24:46 <Eduard_Munteanu> Right, fortunately, they derived Show.
19:25:38 <ben_m> Why does reads return a list of tuples, instead of just a single tuple?
19:26:12 <Jafet> Because some people love backtracking
19:26:22 <Jafet> Most people don't, which is why they return singleton lists
19:29:30 <ben_m> I'm really not good at this, how does a singleton (I assume that's a list with one element) list help with backtracking?
19:30:18 <Jafet> Returning multiple parses implies backtracking
19:30:41 <Jafet> Or at least, multiple parses
19:30:57 <ben_m> Can you maybe give an example where reads produces multiple parses?
19:31:24 <Jafet> No, because hardly anyone uses it that way
19:31:41 <ben_m> Okay :)
19:32:43 <Jafet> reads "pigrape" = [(Word "pi", "grape"), ...]
19:33:20 <ben_m> Oh okay, that makes sense.
19:33:29 <ben_m> Thanks :)
19:33:32 <Jafet> http://2.media.collegehumor.cvcdn.com/0/6/collegehumor.de9144a01407b9da6aea73e61b70d406.jpg
19:34:21 <ben_m> I like that my inner nerd beat my inner child by actually reading that as pi-grape
19:40:58 * BMeph just realized that "pi grape" could also read as "pig rape"
19:42:16 <hpaste> ClaudiusMaximus pasted “KdTree slow? alternatives?” at http://hpaste.org/54003
19:43:22 <ClaudiusMaximus> perhaps i should see if linear search is quicker than KdTree
19:44:18 <ClaudiusMaximus> linear search could be parallelized more easily i guess
19:49:28 <Shin-LaC> does the ghc implementation of retry use blocking or busy-waiting?
19:49:45 <elliott> stm? neither
19:50:58 <gwern> shachaf: no; can't really afford to gallivant off to boston
19:51:24 <kmc> blocking of sorts
19:51:42 <kmc> it knows the TVars you read before the retry
19:51:50 <kmc> it won't try again until one of those TVars changes
19:53:16 <Shin-LaC> kmc: ah, that's what I meant by blocking
19:53:27 <Shin-LaC> elliott: what do you mean by neither? the same thing kmc said?
19:53:46 <kmc> of course this wouldn't work if STM transactions could depend on arbitrary IO
19:54:10 <kmc> this is one reason why it's actually important to separate transactions from other IO
19:54:51 <kmc> and one reason why Microsoft's STM for C# failed
19:55:01 <kmc> cause they didn't have these type-based guarantees
19:55:19 <elliott> Shin-LaC: yes
19:55:31 <gwern> the efficiency killed them, spj said
19:55:37 <elliott> thought you said locking not blocking
19:55:40 <elliott> sorry
19:56:14 <roconnor> > 0x01 `shiftR` 1
19:56:16 <lambdabot>   Ambiguous type variable `a' in the constraint:
19:56:16 <lambdabot>    `Data.Bits.Bits a'
19:56:16 <lambdabot>      a...
19:56:19 <roconnor> > 0x01 `shiftR` 1 :: Integer
19:56:20 <lambdabot>   0
19:56:24 <roconnor> > 0x01 `shiftL` 1 :: Integer
19:56:25 <lambdabot>   2
19:56:29 <ben> The efficiency?
19:56:51 <kmc> right, they treated every variable as potentially transactional
19:56:57 <kmc> and it's C# so everything uses mutation for no reason
20:00:40 <__yhvh__> hey I'm using ghood/observe to view this recursive function, why are all the paths back to the inital node instead of more like a tree?
20:00:48 <__yhvh__> http://i.imgur.com/HAIA5.png
20:00:54 <Shin-LaC> ah, I see
20:01:02 <shachaf> gwern: Do you still live in Long Island?
20:01:23 <gwern> shachaf: that is one of many places Boston is not especially accessible from for cheap
20:02:12 <kmc> boston is quite accessible from long island for cheap
20:02:17 <shachaf> gwern: I went from Manhattan to Boston and back for $23.50. That's at least cheaper than getting to Boston from here. :-)
20:02:48 <gwern> shachaf: wait, how could you do it that cheap? that wouldn't cover the ferry even
20:03:03 <shachaf> Ferry?
20:03:09 <shachaf> I took a bus.
20:03:14 <gwern> (or bridges, they all cost a fair bit)
20:03:24 <shachaf> If I'd planned ahead it could've been cheaper.
20:03:53 <kmc> from LI you can take LIRR and then Megabus / Bolt Bus / chinatown bus
20:04:05 <kmc> not particularly fast, but reasonable and cheap
20:04:52 <shachaf> The bus is ~4-4.5 hours, and even has WiFi and power outlets.
20:05:47 <tgeeky_> this is a strange sounding question: (is there/what is) the the relationship between a function gcd(a,b) and a function like invert (\(x,y) -> x*y) [a,b] (as in Bird's Functional Pearl's book)?
20:05:54 <gwern> hm. but roundtrip LIRR to NYC is ~$20 all on its own
20:06:07 <RaptorRarr> tgeeky_: What is invert?
20:06:22 <kmc> gwern, sure, that's still like $50 round trip to Boston
20:06:28 <kmc> seems pretty good
20:06:31 <tgeeky_> RaptorRarr: pasting, one sec
20:06:37 <gwern> kmc: I suppose so
20:06:39 <RaptorRarr> Rarr
20:06:49 * gwern doesn't really care about attending a hackathon, he just wants xmonad 1.0 released
20:06:53 <zzing> @src unlines
20:06:54 <lambdabot> unlines = concatMap (++ "\n")
20:07:11 * shachaf just wants kmcwm
20:07:59 <hpaste> “tgeeky (from bird)” pasted “invert” at http://hpaste.org/54004
20:08:19 <tgeeky_> http://hpaste.org/54004 <-- 'factor' is the one in question
20:09:25 <tgeeky_> so the question is, if you have the factorization of the two numbers, you have somehow "more" information about the relationship between two numbers than what the gcd tells you
20:10:36 <c_wraith> tgeeky_: in some sense, yes.  If the gcd is a large composite, you may not know its factors.  if you know the factorization of each, you will know the factors of the gcd
20:10:53 <tgeeky_> yes, so what is that sense?
20:11:03 <c_wraith> well, exactly that one
20:11:09 <c_wraith> I'm not sure it's practical often
20:11:13 <tgeeky_> right, but what does that correspond to in categorical sense
20:11:14 <c_wraith> but it is more information
20:11:20 <tgeeky_> or in any other sense
20:12:25 <ClaudiusMaximus> wow, linear search seems to beat KdTree by a massive margin (over 6x faster) with my data set
20:14:45 <__yhvh__> no one help? there's code on that image I posted
20:14:48 <stepcut> ClaudiusMaximus: !
20:15:20 <ClaudiusMaximus> need to check for correctness i guess, maybe i made a typo somewhere...
20:16:33 <ClaudiusMaximus> seems to give the same output
20:16:51 <monochrom> hi FUDPAcker, do you have FUDs about haskell to tell us? :)
20:17:12 <FUDPAcker> HASKELL IS NOT SCALABLE. A FRIEND OF MINE TRIED IT ON THE CLOUD AND IT FAILED AND DELETED ALL HIS DATA
20:17:14 <shachaf> monochrom: It's all in #haskell-blah
20:17:25 <shachaf> I guess not.
20:17:44 <monochrom> heh ok!
20:17:56 <ClaudiusMaximus> maybe it's cache locality?  or using Float instead of Double?
20:18:19 <ClaudiusMaximus> but i'm glad i won't have to wait 20 hours until its done...
20:18:44 <Shin-LaC> getStdRandom is IO because it's nondeterministic, right?
20:18:51 <stepcut> ClaudiusMaximus: or a poor kdtree implementation? It's hard to get right..
20:19:14 <stepcut> ClaudiusMaximus: are you doing mostly lookups? Or insertions as well?
20:19:29 <ClaudiusMaximus> stepcut: http://hpaste.org/54003
20:19:40 <ClaudiusMaximus> mostly "delete an element and find the nearest neighbour"
20:20:09 <stepcut> deletions might lead to rebalancing which can be slow..
20:20:16 <stepcut> assuming it does any rebalancing
20:20:24 <stepcut> or maybe it rebuilds the whole tree after every deletion?
20:21:33 <ClaudiusMaximus> it seems to rebuild the subtrees below a deleted node
20:22:40 <stepcut> there is another kdtree implementation here,  darcs get http://src.seereason.com/kdtree
20:22:49 <stepcut> not complete yet.. but might be complete enough for your program..
20:22:59 <__yhvh__> I expected my output to look more like this, http://i.imgur.com/Qxeqt.png , because the recursive function calls itself possibly twice
20:24:52 <Rotaerk> __yhvh__, you could've just said "binary tree"
20:25:29 <ClaudiusMaximus> stepcut: well, i can wait 3 hours for this program run to complete - so no massive urge right now; but i might compare it if i want to run it again on different inputs
20:25:33 <__yhvh__> so what's happening
20:25:39 <stepcut> ClaudiusMaximus: :)
20:28:11 <__yhvh__> my output, and the code is on this: http://i.imgur.com/HAIA5.png
20:29:58 <ClaudiusMaximus> > 90000 * 10 * 4
20:29:59 <lambdabot>   3600000
20:31:51 <__yhvh__> it's basaically the recursive function from http://en.wikipedia.org/wiki/Partition_(number_theory)
20:32:26 <monochrom> perhaps "observe" or GHood is not meant to display in tree form to begin with
20:32:59 <__yhvh__> monochrom: http://community.haskell.org/~claus/icons/GHood.PNG
20:33:28 <monochrom> well yeah, what code produces that?
20:33:34 <hpaste> ClaudiusMaximus annotated “KdTree slow? alternatives?” with “KdTree slow? alternatives? (annotation)” at http://hpaste.org/54003#a54006
20:34:39 <__yhvh__> monochrom: you're telling me to rtfm, I thought there might be some obvious explanation, like a haskell optimisation
20:35:02 <monochrom> no, that's not what I said or thought or implied.
20:35:13 <monochrom> I ask again. what code produces that?
20:36:00 <__yhvh__> monochrom: something like it http://community.haskell.org/~claus/GHood/fold.html
20:37:20 * hackagebot GLFW-b 0.1.0.0 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.0 (BrianLewis)
20:37:54 <elliott> __yhvh__: what is "a" instantiated to?
20:38:02 <lpsmith> solidsnack, it's on github now
20:38:02 <elliott> I bet it is because addition is strict on Ints/Integers.
20:38:02 <lpsmith> for better or worse ;-)
20:38:07 <__yhvh__> int
20:38:12 <elliott> __yhvh__: compare http://community.haskell.org/~claus/icons/GHood.PNG, where it is a _lazy_ list.
20:38:23 <shachaf> > ((+) undefined) `seq` ()
20:38:24 <lambdabot>   ()
20:38:25 <elliott> there aren't any thunks because (+) is forcing its arguments
20:39:07 <lpsmith> solidsnack, https://github.com/lpsmith/pgsql-simple/tree/async
20:39:36 <shachaf> @quote Jafet unsafeCoerce
20:39:37 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
20:39:41 <solidsnack> lpsmith: loading...
20:40:36 <monochrom> elliott, I disbelieve it. despite (+) being strict, big deep thunks can be built as an intermediate before any addition happens
20:40:52 <elliott> monochrom: fair enough. it'd still be worth checking with a lazy natural type
20:40:58 <elliott> or similar
20:41:25 <Jafet> > (+) (undefined :: Int) `seq` ()
20:41:26 <lambdabot>   ()
20:42:45 <lpsmith> but yeah,  I don't think that the code that implements the protocol is useable for me,  really.   Two bits of code that are ok by themselves have been kludged together to make an unhealthy whole
20:45:14 <monochrom> __yhvh__: I wonder what would happen if you did something much closer to what the examples did, namely, only one observe, and only at the root call site, in main, and use printO
20:47:33 <solidsnack> lpsmith: Reading your comments...
20:48:27 <byorgey> elliott: did anything ever come of that 'Supply' monad?
20:49:07 <elliott> byorgey: ah -- I decided on a nicer representation but then had a nasty hardware crash before I could implement it
20:49:19 <solidsnack> lpsmith: What is %Q?
20:49:30 <elliott> I don't mind if anyone else wants to put a supply-monad on Hackage, but if not I'll probably be able to get round to it in a week or so
20:49:34 <__yhvh__> monochrom: even less information, one thunk that evaluates right away
20:49:38 <byorgey> elliott: oh, boo =(
20:49:40 <byorgey> elliott: ok
20:49:57 <lpsmith> %Q?
20:49:58 <byorgey> elliott: I'm in no particular rush
20:50:07 <elliott> ok :)
20:51:03 <solidsnack> lpsmith: Seems to be a timezone format thing.
20:51:14 <lpsmith> oh that
20:51:26 <lpsmith> yeah,  I had some trouble with that
20:51:45 <solidsnack> It's not in GNU date; I guess it is a Haskell specific thing.
20:51:51 <lpsmith> It adds the .00000 picoseconds so that the time round trips
20:52:18 <lpsmith> Which, by the way,  we don't have anything approaching support for the ISO time format standard
20:52:20 * hackagebot zoom-cache 0.7.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.7.0.0 (ConradParker)
20:52:22 * hackagebot zoom-cache-pcm 0.2.0.0 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.2.0.0 (ConradParker)
20:52:24 * hackagebot zoom-cache-sndfile 0.2.0.0 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.2.0.0 (ConradParker)
20:52:27 <lpsmith> As I discovered with that
20:53:11 <lpsmith> Also,  the conversion to results should be a little more liberal.  For example, I don't know of any reason to use a timestamp without time zone in postgresql,  as the behavior of that type makes absolutely no sense to me
20:55:07 <solidsnack> I don't understand this: "we don't have anything approaching support for the ISO time format standard"
20:56:35 <solidsnack> %FT%TZ seems to be enough
20:57:14 <solidsnack> You mean, handling variants, like "%F %T UTC" and "%FT%H:%MZ" and so forth?
20:57:16 <monochrom> __yhvh__: have you tried the advertised foldr examples etc in your own installation of Hood and GHood? just to verify that your installation works as advertised?
20:58:47 <lpsmith> well,  a cursory look at the standard suggests there are quite a few different formats,  that are unambigous,  that cannot be covered by a single format string
20:59:16 <solidsnack> Ah, I see.
20:59:20 <__yhvh__> monochrom: yup, those web page examples didn't work in browser so I had to chech them out here
20:59:35 <solidsnack> Well, that's true, there's no ISO 8601 parser that handles the whole spectrum.
20:59:45 <lpsmith> heh
20:59:56 <lpsmith> interesting to know,  I don't know a great deal about time
21:00:30 <solidsnack> I put together a more flexible one a while back, actually: https://github.com/solidsnack/logl/blob/master/Language/LogL/Pickle.hs#L44
21:00:40 <solidsnack> Only handles UTC, though.
21:01:05 <lpsmith> I don't know how dedicated I am to the -simple API either,  it seems a step in the right direction,  but eventually I do want to support things such as prepared statements
21:01:57 <solidsnack> I have found libpq quite workable, so far.
21:02:27 <solidsnack> Although, to be fair, I did have to write a lot of stuff around packing and unpacking my data for it.
21:03:10 <solidsnack> The system I put together uses stored procedures exclusively but at one point I was working with dynamic queries.
21:03:52 <solidsnack> After looking at -fext-core, wow does -ddump-simpl seem straightforward.
21:04:33 <lpsmith> yeah,  I don't have a problem with libpq particularly
21:04:39 <elliott> I wish `state` worked for general StateT, not just State. :-(
21:04:49 <lpsmith> Honestly I could probably fit my idea around the libpq asynchronous interfaces
21:05:10 <lpsmith> I did remove the outermost MVar in the existing binding though
21:05:21 <hpaste> monochrom pasted “?” at http://hpaste.org/54007
21:05:49 <monochrom> __yhvh__: could you try http://hpaste.org/54007 and see if the result is any more complicated?
21:06:10 <monochrom> oh sorry, typo, need a string name for observe
21:06:27 <lpsmith> Clearly the communication protocol that goes over my "dialog/PGHandle" channels should be improved
21:06:29 <hpaste> monochrom annotated “?” with “? (annotation)” at http://hpaste.org/54007#a54008
21:06:32 <monochrom> like that
21:06:39 <lpsmith> I'm not sure what that looks like
21:07:06 <lpsmith> but I'd like a protocol that supports either a libpq implmentation or a native haskell solution both pretty well
21:07:29 <PiRSquared17> Bye!
21:08:59 <elliott> bye
21:10:55 <monochrom> you know how "bye" or "good night" is ambiguous in that it may mean the speaker is leaving or it may mean the speaker is just answering someone else who says bye.
21:11:30 <solidsnack> lpsmith: I think really, the native Haskell implementation should support the semantics of libpq.
21:11:38 <monochrom> that ambiguous is somewhat but not completely resolved if the latter case adds a name
21:11:53 <lpsmith> solidsnack, what do you mean?
21:12:39 <solidsnack> I mean, shouldn't make a difference, really, what interface your access layer exports; it should be able to assume the full functionality of libpq is there.
21:12:52 <lpsmith> well yeah
21:13:07 <__yhvh__> monochrom: same, one thunk, evaluated immediately
21:13:07 * roconnor thinks maybe this is a bug in openssl?
21:13:38 <monochrom> so, theoretically, suppose A leaves and says bye. now B is going to answer bye to that. but then C and D mistakes that to mean B is leaving, so C and D also say bye. it goes on and on, an avalanche of bye's
21:14:35 <solidsnack> lpsmith: It sounds like pgsql simple doesn't have the async stuff, for example.
21:15:16 <solidsnack> Doesn't have prepared statements, &c.
21:15:22 <lpsmith> it's missing a lot
21:15:38 <lpsmith> then again,  even Haskell libraries that use libpq are missing a lot
21:15:39 <solidsnack> Honestly, I see this sort of thing and say why?
21:16:00 <lpsmith> I mean, HDBC doesn't actually prepare statements
21:16:04 <lpsmith> it just pretends to
21:16:09 <solidsnack> Oh, hmm.
21:16:42 <c_wraith> lpsmith: I think that's up to the backend.
21:16:45 <lpsmith> well, at least HDBC-postgresql,  but I have a hard time believing that the other drivers are any better
21:16:56 <c_wraith> but I'm sure none of them actually do
21:17:44 <c_wraith> however, there is a serious performance issue in the postgresql background if you don't fake-prepare queries...
21:18:28 <lpsmith> yeah,  database libraries for Haskell are a pretty sorry state of affairs.
21:18:32 <solidsnack> lpsmith: A Haskell libpq could actually be more thread safe than the existing one.
21:18:40 <c_wraith> because it's very, very slow at converting the format from the one the HDBC interface specifies to the one the libpq libraries uses
21:18:50 <c_wraith> *library
21:19:02 <lpsmith> I think I may have fixed some of that in my fork
21:19:24 <lpsmith> either that or I bopped it out and just used the postgresql-specific parameter syntax
21:19:36 <c_wraith> that should help you a bunch
21:19:41 <elliott> If you have (Foo m a) where (Foo m) is a Functor and an Applicative assuming m is and with listFoo :: m a -> Foo m a, and (Foo Identity) is also useful, is it fair to call it BarT (and the Identity version Bar) even if you're not sure it's a monad? (I think it might be, but I also think the Monad instance would be contrived, and it might not be after all.)
21:19:44 <c_wraith> with performance, anyway
21:20:02 <elliott> I feel like there might be a (valid) assumption that BlahT has lift.
21:20:44 <lpsmith> c_wraith, yeah,  i think the hdbc-postgresql/bytestrings branch on github is up-to-date with what I use
21:21:11 <lpsmith> unfortunately it's not at all compatible with hdbc
21:21:37 <wvoq> hello all, I have a (probably very simple) question that came up while I was writing a toy compiler
21:22:05 <wvoq> I have a datatype Context that basically amounts to "the program so far" plus a symbol table
21:22:35 <wvoq> and a bunch of functions that, when partially applied, have the type Context -> Context
21:23:29 <c_wraith> sounds like you're doing things right so far, then.
21:23:30 <wvoq> Generating the source would be something like Context -> [Context -> Context] -> Context
21:23:44 <wvoq> where my list is basically my source code
21:24:11 <c_wraith> this sounds more like an interpreter, but ok :)
21:24:16 <wvoq> it seems like there is a natural interpretation of this in terms of do syntax, but I can't seem to cram this into a monad
21:24:20 <c_wraith> :t foldr (.) id
21:24:21 <lambdabot> forall b. [b -> b] -> b -> b
21:24:34 <c_wraith> it's just a simple fold
21:24:50 <c_wraith> nothing as complicated as do syntax required
21:24:51 <solidsnack> wvoq: No type parameter means, not a functor. Not a functor means, not a monad.
21:25:49 <byorgey> wvoq: also, every time you cram something into a monad just to be able to use do syntax, seventy-nine kittens get run over by a steamroller
21:26:05 <c_wraith> at least the 80th kitten escaped
21:26:25 <byorgey> yes, it runs away and cries
21:27:32 <wvoq> c_wraith: thanks, I saw the fold; I just wanted to be sure there wasn't a more idiomatic way
21:27:47 <c_wraith> the fold is pretty much maximally idiomatic for that
21:27:52 <wvoq> solidsnack: much obliged-- that's a helpful way of putting it
21:28:06 <elliott> byorgey: we need do notation for applicatives and monoids :)
21:28:07 <monochrom> __yhvh__: what if main = printO (observe "p" p 3 1) ?  note how I am not doing (p 3 1)
21:28:12 <byorgey> you could of course use the  State Context  monad
21:28:21 <byorgey> but that seems overkill
21:28:45 <solidsnack> wvoq: If your "program so far" has an annotation and rules for combining annotations, you get can get a monad/functor.
21:29:07 <wvoq> solidsnack: rules for combining annotations?
21:29:07 <byorgey> elliott: not do-notation.  but some syntactic sugar for applicative would be awesome, actually
21:29:10 <byorgey> idiom brackets
21:29:23 <simon> c_wraith, the way I cram it into a monad is by having my interpreter having a type Foo a = State Context a, and all my Context -> Context functions become Foo () actions.
21:29:25 <elliott> byorgey: well, ok, just monoidal do notation then :) (would be really useful for Builder and similar things)
21:29:26 <byorgey> Conor McBride's SHE preprocessor supports them
21:29:41 <simon> oops, wvoq I meant.
21:29:41 <elliott> mon {} = mempty; mon {a;...} = mappend a (mon {...})
21:29:44 <byorgey> monoidal do notation? how would that work?
21:29:47 <elliott> like that :)
21:30:01 <solidsnack> wvoq: Like, a count of how many statements there are or an indicator of what kind of operations are performed.
21:30:04 <byorgey> bah
21:30:09 <solidsnack> Has to be generic annotations.
21:30:14 <wvoq> simon: thanks, I was looking at the state monad but couldn't make it fit before
21:30:18 <byorgey> elliott: what's wrong with  mconcat [ a, b, c, ... ]  ?
21:30:43 <elliott> byorgey: well, it works. it's kinda ugly not to be able to use layout though
21:30:49 <byorgey> elliott: maybe what you really want is layout syntax for lists
21:30:51 <elliott> admittedly, I can't think of usecases other than builders
21:30:56 <elliott> but you're "basically" writing imperative printing code, there
21:31:08 <elliott> which is why things like cereal build a silly monad on top of it
21:31:14 <elliott> byorgey: that would be cool, yes
21:31:15 <byorgey> layout for lists in general could be nifty
21:31:21 <solidsnack> elliott: Well, if any one has a DSL that allows for monoidal statement/expression building...
21:31:36 <elliott> solidsnack: Hm?
21:31:52 <solidsnack> elliott: I mean, for uses besides builders.
21:31:59 <elliott> Right.
21:36:45 <wvoq> ok, thanks all for the advice
21:48:29 <solidsnack> What does the '@' mean in core?
21:48:40 <solidsnack> Is it "apply"?
21:49:11 <simon> pattern matching aliases
21:51:59 <elliott> solidsnack: type apply
21:52:05 <elliott> f @ A passes the type A
21:52:24 <monochrom> type application. if a function has type "a -> b" for a hypothetical example, and you use it as "Int -> Bool", you do f @ Int @ Bool
21:53:18 <solidsnack> Hmm. So what about this?  (@ r{tv XB7} [tv])
21:53:27 <ben_m> What is this magic? :D
21:53:41 <solidsnack> Is r{...} a type?
21:54:08 <solidsnack> I'm seeing a lot of \ ... -> ... @ ...
21:54:30 <monochrom> I have never seen that. or I have but ignored
21:54:51 <monochrom> I could guess if I saw the bigger picture
21:56:02 <hpaste> solidsnack pasted “Foo.core.hs” at http://hpaste.org/54009
21:57:51 <solidsnack> The underlying code is basically:  f c = mappend (Blaze.fromChar c) (mappend builderA builderB)
21:58:09 <monochrom> well then, apparent, r{tv XB7} [tv] is a type or two types, because you will find "forall r{tv XB7} [tv] ."
21:58:25 <solidsnack> monochrom: Oh, I see.
21:58:48 <monochrom> but "(@ type)" or "(@ type type)" is new to me
22:03:16 <solidsnack> I am trying to sort out excessive memory use for a function that, ultimately builds a large string; but looking at core has proven to be less than productive.
22:03:25 <solidsnack> https://github.com/solidsnack/arx/blob/master/System/Posix/ARX/HEREDat.hs#L107
22:03:37 <solidsnack> This version, obviously, is going to have some memory usage problems.
22:04:17 <solidsnack> https://github.com/solidsnack/arx/blob/only-blaze/System/Posix/ARX/HEREDat.hs#L109
22:04:26 <solidsnack> This version does, too, though.
22:04:39 <solidsnack> For a ~1M string it allocates ~200M.
22:05:06 <Axman6> how do you know it's a 1M string btw?
22:05:21 <Axman6> because there's an overhead of like 4 words per character in a string
22:05:21 <solidsnack> I feed it a 1M file on STDIN.
22:05:23 <monochrom> (@ type) apparently is the syntax for formal type parameter. suppose f :: a->Int. then f's definition is like f = \ (@ a) (x :: a) -> ...
22:05:32 <solidsnack> Axman6: Oh, it's a ByteString.
22:05:48 <solidsnack> monochrom: Oh, I see.
22:05:50 <Axman6> ah, yeah, realised that when i looked at the code =)
22:06:08 <elliott> Axman6: more like 4 megabytes :)
22:07:54 <Axman6> solidsnack: try using foldr. I don't think you want to force a builder like you are by using foldl'
22:12:41 <solidsnack> Axman6: With foldr it only used ~114M.
22:12:50 <solidsnack> A big improvement!
22:12:56 <solidsnack> But still hard to understand, actually.
22:13:33 <dufflebunk> ahhh! I spent 4 hours trying to trace the cause of a memory leak in a program. Turns out there was a reason the profiling stuff wasn't giving me sensible results. The leak was in some C code on the other side of the FFI.
22:13:48 <dufflebunk> I guess the RTS profiling stuff can't account for malloc in C.
22:13:55 <monochrom> right
22:13:55 <lpsmith> solidsnack, actually the libpq async interface does *not* support issuing a second query until the first is complete.
22:15:14 <lpsmith> Even though the protocol nominally supports such things
22:15:37 <solidsnack> lpsmith: I guess I was thinking of multiple commands in the same query.
22:15:43 <lpsmith> So I'm curious if this will turn out to be a good idea or not.   That remains to be seen.
22:16:10 <lpsmith> Well, I do think libpq support is an important option
22:16:52 <solidsnack> lpsmith: Now that I think about it, each connection in Postgres is probably single threaded. It's backed by a distinct process and probably executes one query at a time.
22:17:26 <lpsmith> yeah,  libpq is not thread safe
22:17:35 <solidsnack> Well, I mean on the server side.
22:17:43 <solidsnack> I mean, each connection gets its own process.
22:17:54 <lpsmith> oh, I dunno
22:18:00 <solidsnack> (You can get the PID from libpq.)
22:18:07 <solidsnack> But each such process is single-threaded.
22:18:35 <lpsmith> I'd find that a little surprising,  as a process is a fairly heavyweight thing.  How many simultaneous connections can a server support?
22:18:36 <solidsnack> In otherwise, there is no concurrency on a single connection -- there is, in a sense, nothing for the library to export.
22:18:47 <solidsnack> lpsmith: Thousands.
22:19:21 <solidsnack> ...as long as you aren't running anything else :)
22:19:27 <lpsmith> :)
22:19:36 <lpsmith> Well,  my experiment is not about concurrency, really
22:19:42 <lpsmith> well, this aspect isn't
22:19:43 <solidsnack> s/In otherwise/In other words/
22:19:48 <lpsmith> it's about hiding latency
22:20:10 <solidsnack> Oh, hmm.
22:20:20 <lpsmith> instead of 2 round trips,  the round trips can overlap
22:20:23 <solidsnack> Well, being able to queue up queries on the server would do that.
22:20:27 <solidsnack> Yeah, I see that.
22:20:28 <lpsmith> right
22:21:07 <solidsnack> Are you sure the protocol supports this?
22:21:17 <lpsmith> Well, the manual says it does
22:21:22 <solidsnack> If it does, then maybe there's a case to be made for sorting out a Haskell binding.
22:21:26 <lpsmith> I haven't verified it in production
22:21:30 <solidsnack> I see.
22:22:02 <solidsnack> lpsmith: Can you point me to the page where it says it?
22:22:14 <lpsmith> already on it..
22:23:47 <lpsmith> http://www.postgresql.org/docs/9.1/static/protocol-flow.html#AEN91399
22:25:09 <lpsmith> of course,  I think it's pretty silly that the protocol can't support multiple commands *and* protocol-level parameters
22:25:26 <lpsmith> but this way you can get around that,  a little
22:25:46 <lpsmith> assuming your client library supports it
22:28:09 <JoeyA> Is it possible to invert a warning flag to GHC?  I want to say: -Wall -fno-unused-imports
22:28:43 <JoeyA> But it says: ghc: unrecognised flags: -fno-unused-imports
22:29:15 <lpsmith> hmm, it also seems a little silly to me that you have to prepare a statement to use protocol-level parameters
22:29:52 <elliott> Wow, writing a MonadTransControl instance sure does hurt my brain.
22:31:10 <solidsnack> lpsmith: Protocol level parameters?
22:31:27 <solidsnack> Oh, I get it.
22:42:20 * hackagebot portable-lines 0.1 - Alternative 'lines' implementation that understands CR-LF and CR  http://hackage.haskell.org/package/portable-lines-0.1 (JoeyAdams)
22:42:43 <JoeyA> (I'm not sure "portable" is a good choice of word, but oh well)
22:44:00 <kmc> -fno-warn-unused-imports
22:44:24 <JoeyA> Thanks
22:45:42 <shachaf> JoeyA: What about Unicode newlines?
22:46:45 <JoeyA> shachaf: What about vertical tab and form feed?  ;-)
22:47:07 <elliott> JoeyA: You really should handle LF/VT/Ff/CR/CR+LF/NEL/LS/PS.
22:47:13 <elliott> That's the official Unicode list of newlines you have to handle.
22:47:19 * shachaf wonders whether elliott typed that from memory.
22:47:30 <JoeyA> Are any of those non-ASCII?
22:47:35 <shachaf> Yes.
22:47:35 <elliott> Yes.
22:47:46 <elliott> (U+000A, U+000B, U+000C, U+000D, U+000D then U+000A, U+0085, U+2028, U+2029)
22:47:48 <shachaf> There's also LF/CR, which I heard an obscure operating called "@" uses.
22:48:02 <shachaf> s/\//+/
22:48:24 <JoeyA> Yeah, I'd rather pass.  Currently, the code above works with ASCII-compatible encodings and a few not-quite-ASCII ones too.
22:48:38 <elliott> Oh, it's based on ByteStrings. You're living a lie!
22:48:41 <shachaf> JoeyA: ByteString "lines" is evil anyway.
22:48:52 <shachaf> You should at least put "Char8" in the module name or something.
22:49:01 <elliott> Char8 is only acceptable when doing network protocols, and you know what kinds of newlines are being used then.
22:49:02 <JoeyA> shachaf: I call it lines8 for that reason.
22:49:08 <shachaf> Ah, at least that.
22:49:35 <elliott> shachaf: Also: please believe that I typed it out from memory, if this will impress you suitably.
22:50:03 <shachaf> I'm not sure whether "impress" would fully capture my emotional reaction.
22:50:23 <donri> u'ecai
22:50:56 <shachaf> donri: Are you one of those weird jbopre people or somethin'?
22:51:15 <elliott> I can detect Lojban flawlessly and understand it never.
22:51:22 <elliott> That has to be a talent I can put to some use.
22:51:49 <donri> go'i doi caxaf
22:51:54 <smoge> Ambiguous module name `Control.Monad.State.Strict':
22:51:56 <smoge>       it was found in multiple packages: monads-fd-0.2.0.0 mtl-2.0.1.0
22:52:01 <smoge> how can I fix that?
22:52:06 <elliott> smoge: ghc-pkg hide monads-fd
22:52:09 <shachaf> I misdetected Lojban today when copumpkin /nicked FUDPAcker
22:52:20 * hackagebot cairo-appbase 0.4 - A template for building new GUI applications using GTK and Cairo.  http://hackage.haskell.org/package/cairo-appbase-0.4 (ConradParker)
22:52:21 <donri> elliott: even my dot-free style of lojban?
22:52:24 <elliott> fu'dpack.er
22:52:38 <shachaf> elliott: You were serious about the not understanding it bit.
22:52:47 <donri> shachaf: there's a pythonista nicking "mitsuhiko"; I keep thinking it's a lujvo or something (it's japanese)
22:52:54 <shachaf> elliott: "'" is pronounced approximately like "h", as I understand it.
22:52:58 <elliott> "extreme wonder.." "[1«2go'i last bridi (3(4doi O! caxaf. [NAME])4)3»2]1"
22:53:02 <elliott> donri, I don't understand your second statement.
22:53:12 <elliott> shachaf: Yes, I know.
22:53:21 <shachaf> {caxaf}!
22:53:37 <donri> elliott: one dead give-away of lojban is weird placement of dots, however those dots are optional when writing spaces
22:53:42 <elliott> shachaf: Oh, well now I get that bit.
22:53:53 * shachaf has that registered on nickserv for some reason.
22:54:17 <donri> heh
22:54:20 <elliott> I remember once I asked Lojban people how to say my name in Lojban, and they all went "umm..." and stumbled over it for about ~20 iterations until they got something approximately phonetically correct; it was hideous.
22:54:23 <donri> also, ' can only go between vowels
22:54:41 <elliott> caxaf is positively elegant in comparison.
22:54:41 <donri> and ck would be pronounced something like shk
22:54:47 <shachaf>  {Eliyt}?
22:54:58 <donri> ie
22:55:05 <elliott> shachaf: It was .Eliy,t. or something ridiculous like that.
22:55:10 <elliott> I seem to recall "xrd" was the best anyone could do for my surname.
22:55:56 <elliott> Which is pronounced by choking.
22:56:15 <donri> well, again, the dots are optional if you type spaces, kinda like operator precedence and explicit parentheses
22:56:22 <shachaf> elliott: "x" isn't choking. It's my name.
22:56:28 <shachaf> s/my/in my/
22:56:35 <elliott> shachaf: It's choking when followed by rd.
22:56:38 <donri> not sure if the coma is required there, might be
22:56:41 <elliott> No vowels!! None at all!
22:56:58 <donri> kinda like polish
22:58:07 <donri> wait, is it comma
22:58:25 <donri> i actively thought "i always get that one wrong, better type the opposite of what i'm thinking"
22:59:01 <shachaf> donri: Yes, that's a strategy that I've had go wrong many times.
22:59:22 <donri> also finish vs finnish
23:00:56 <donri> shachaf: wouldn't it be so much easier if you could just never learn
23:01:37 * shachaf finds it weird that English doesn't have a glottal stop.
23:01:45 <shachaf> I guess this is starting to get pretty #-blah.
23:02:25 <JoeyA> shachaf: uh-uh!
23:02:37 <shachaf> JoeyA: Not as a consonant.
23:05:06 <mysticc> @hoogle split
23:05:06 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
23:05:06 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
23:05:07 <lambdabot> Data.Typeable splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
23:06:46 <ClaudiusMaximus> > splitTyConApp (typeOf (undefined :: Maybe Int))
23:06:47 <lambdabot>   (Maybe,[Int])
23:07:08 <ClaudiusMaximus> > splitTyConApp (typeOf (undefined :: Int))
23:07:09 <lambdabot>   (Int,[])
23:32:07 <ClaudiusMaximus> > listArray (1,10) (repeat (0 :: Int)) ! 5
23:32:08 <lambdabot>   0
23:35:48 <sbahra> :t listArray
23:35:49 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
23:36:06 <sbahra> Oh, right
23:36:11 <sbahra> Sigh.
23:36:46 <shachaf> ?
23:37:20 * hackagebot hosc 0.10 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.10 (RohanDrape)
23:41:45 <elliott> sbahra: Sigh?
23:45:52 <shachaf> sbahra probably wants listArray :: (Ix i) => (i,i) -> [e] -> Array i f
23:47:58 <elliott> shachaf: Sounds... useful?
23:48:23 <shachaf> In extreme cases you might want listArray :: (Ix i) => (i,i) -> [e] -> Array j f
23:48:44 <elliott> listArray :: q
23:48:48 <danr> shachaf: what would j and f be there? :S
23:49:02 <shachaf> danr: Variables.
23:49:21 <danr> shachaf: j isn't even Ix, so you won't be able to use that array for much
23:49:39 <sopvop> 1
23:49:46 <shachaf> danr: j is anything you want it to be.
23:50:02 <sopvop> sorry, missed channel
23:50:11 <danr> shachaf: I don't see how you could ever inhabit that type
23:51:31 <shachaf> danr: Yes.
23:51:39 * shachaf was not completely serious with those types.
23:51:45 <elliott> danr: With some furniture.
23:52:00 <danr> shachaf: aha
23:52:13 <danr> sorry, didn't catch your sarcasm :)
