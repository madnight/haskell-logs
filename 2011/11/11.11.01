00:00:17 <wavewave> Axman6: ask to me?
00:00:24 <Axman6> yeah
00:00:26 <dmwit> byorgey: Or R^3, rather. R^3 seems quite nicely behaved for a lot of stuff. For example, if you ask for a bounding box normal to the time direction, you won't get a time-varying box in R^2, like you would if you asked for the bounding box in R -> R^2.
00:00:42 <wavewave> Axman6: simple. it's coroutine.
00:00:52 <wavewave> event consumer coroutine.
00:01:29 <Axman6> edwardk: do you have plans to write any docs for trifecta? just trying to figure out where you should start looking for the functions you need to use is daunting given the number of modules it has
00:01:46 <liyang> It's just FRP!
00:01:49 <wavewave> Axman6: in iteratee monad, it looks like pulling events.
00:02:23 <edwardk> Axman6: yes i do. right now my focus is on finding the right api for some things though. in particular i don't like the current diagnostics subsystem in part
00:02:37 <edwardk> there are too many types involved, ErrLog, ErrState, Err, Diagnostic, et.c
00:02:39 <Axman6> ah fair enough
00:02:40 <wavewave> liyang: yeah.. finally it will be... but I am taking more traditional approach using state machine.
00:02:43 <edwardk> so i'm simplifying that part
00:02:50 <edwardk> moving more into Diagnostic
00:03:02 <edwardk> and i'm simplifying the monad as a result
00:03:02 <Axman6> this is an amazing type: unparser :: forall r. (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r
00:03:03 <dmwit> byorgey: And once again imprecise language comes back to bite me in the butt. What I really meant was the process of asking for a bounding box by asking for a bounding hyperplane in each of the {-x,x,-y,y,-z,z} directions seems much better behaved than asking for the bounding box function by asking for a bounding hyperplane in the {const (-x), const x, const (-y), const y, const (-z), const y} directions.
00:03:13 <edwardk> thats getting slightly simpler
00:03:23 <Axman6> hooray =)
00:03:41 <edwardk> but note that you don't have to reason about that type at all
00:03:41 <wavewave> anyway in this way, writing a GUI program is similar to writing a parser.
00:03:49 <edwardk> Prim is just _one_ implementation of the MonadParser class
00:03:50 <Axman6> sure
00:03:56 <Axman6> it's just an amazing type =)
00:03:59 <edwardk> its designed as a kitchen-sink where i put everything
00:04:00 <edwardk> hah
00:04:12 <Axman6> i've seen better though
00:04:15 <dmwit> byorgey: (...and yeah, the mask-XOR thing sounds pretty weird. =)
00:04:52 <edwardk> it is simplifying to data Parser e a = Parser { unparser :: forall r.  (a -> ParseLog e -> It Rope r) -> (Diagnostic Mark e -> ParseLog e -> It Rope r) -> (a -> Mark -> ParseLog e -> It Rope r) -> (Diagnostic Mark e -> ParseLog e -> It Rope r) -> Mark -> ParseLog e -> It Rope r }
00:04:52 <edwardk> P
00:05:08 <Axman6> liyang: do you remember what that package was that had the amazingly massive types for almost every single function? i remember each type being at least 4 lines long... but can't for the life of me remember what the package did >_<
00:05:10 <edwardk> which will let it run a little faster
00:05:33 <edwardk> that is part of me changing diagnostics to be a bifunctor again
00:05:42 <edwardk> so i can use different marks
00:05:58 <edwardk> which i need in order to port my c preprocessor the rest of the way
00:06:15 <Axman6> what're you making a C preprocessor for?
00:06:17 <edwardk> that way when you have diagnostics that occur during macro expansion or in an included file i can tell you the full context
00:06:34 <Axman6> ah nice
00:06:46 <edwardk> in a file included from blah, while expanding this macro with these arguments, this is the line where things went wrong
00:06:50 <edwardk> that sort of thing
00:06:50 <wavewave> I am showing my current working on github.   http://www.github.com/wavewave/hxournal
00:06:57 <edwardk> i already wrote the c preprocessor
00:07:03 <edwardk> i just need to port it to trifecta
00:07:09 <kmc> do you support C99 variadic macros
00:07:15 <edwardk> not yet
00:07:19 <kmc> :(
00:07:19 <kmc> SUX
00:07:25 <Axman6> it would be lovely to be able to write parsers with diagnostics like clang in such an easy way
00:07:26 <edwardk> it wouldn't be terribly hard to do
00:07:26 <kmc> :D
00:07:45 <edwardk> Axman6: exactly =)
00:07:45 <liyang> Axman6: either Takusen or some encoding of session types.
00:08:11 <Axman6> yeah it wasn't takusen. session types sounds familliar.. i'll see if i can find it from there
00:08:19 <edwardk> kmc: of course after that one wants some kind of hygienic macro system ;)
00:08:38 <Axman6> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
00:08:45 <Axman6> edwardk: that's got you beat for amazing types
00:09:32 <edwardk> Axman6: well, there is a difference, you can actually still reason about mine. he doesn't even bother using signatures any more ;)
00:10:05 <Axman6> sure, but... (~||~) :: forall prog prog' progOut progIn outgoing incoming finalState finalResult jumps l current currentUX. (ProgramToMVarsOutgoingT prog prog ~ progOut, ProgramToMVarsOutgoingT prog' prog' ~ progIn, ProgramToMVarsOutgoing prog prog progOut, ProgramToMVarsOutgoing prog' prog' progIn, SWellFormedConfig l (D0 E) prog, SWellFormedConfig l (D0 E) prog', TyListIndex progOut l (MVar (ProgramCell (Cell outgoing))), TyListIndex progIn
00:10:07 <edwardk> just uses near-monads to build up the type and closes his eye
00:10:09 <edwardk> yeah
00:10:12 <Axman6> just wow
00:10:27 <edwardk> session types are scary
00:10:47 <edwardk> lot easier to reason about when you just give up and extend the type system
00:10:48 <wavewave> hmmmm
00:10:54 <Axman6> heh
00:11:07 <Axman6> thanks liyang =)
00:13:15 <wavewave> Will this messy types of session types be able to be simplified with ConstraintKind?
00:14:44 <wavewave> and type promotion..
00:15:55 <wavewave> wow... this is just impressive.....
00:18:35 <wavewave> does somebody work on C++ AST types and parser like Language.C?
00:19:02 <ddarius> Hah.
00:19:16 <wavewave> i know there's libclang binding.
00:21:51 <kmc> wavewave, writing a C++ parser is tremendously painful
00:22:06 <kmc> i think we're lucky there's even one C++ parser under a permissive OSS license
00:22:09 <wavewave> kmc: I definitely think so.
00:22:34 <wavewave> so libclang is the best and unique?
00:24:22 <alpounet> wavewave, there's some ongoing work on another one, that i know of: http://42ndart.org/scalpel/
00:27:01 <wavewave> alpounet: thanks for the info.
02:07:10 <snappy> I have a list of tuples where each tuple is a pair of ints, I want to calculate [xi - yi, ... ] for [(xi,yi) ...]; trying to think what would be an ideal way to do this, at the moment lambda comes to mind
02:07:40 <kmc> :t map (uncurry (-))
02:07:41 <lambdabot> forall a. (Num a) => [(a, a)] -> [a]
02:08:26 <kfish> snappy: how would you do it using lambda?
02:09:03 <snappy> (coming from python here): map (\x y (x - y))) L
02:09:04 <kmc> another very direct way to write it is [ x-y | (x,y) <- listofpairs ]
02:09:17 <snappy> ah yeah, list comprehension, forgot about that.
02:09:29 <kmc> anyway «map (uncurry (-))» would be the most idiomatic Haskell solution, I think
02:11:16 <kfish> is it not iironic that uncurry is not unHaskell?
02:11:30 <kmc> @faq is it not iironic that uncurry is not unHaskell?
02:11:30 <lambdabot> The answer is: Yes! Haskell can do that.
02:12:23 <kmc> but you should call it unschönfinkel to be sure
02:22:23 <frerich> kmc: Cool, 'uncurry' always irritated me a bit and this little example (I was thinking of using 'map (\(x, y) -> x - y)') suddenly made "click" in my head :-)
02:22:25 <ziman> this is needed only when programming in Moses.
02:23:06 <frerich> kmc: So whenever I want to combine the elements of a 2-tuple in some way into a single value, uncurry would be idiomatic?
02:23:56 <opqdonut> exactly
02:24:17 <opqdonut> but oftentimes you could've done the combination when creating the tuple
02:24:33 <opqdonut> i.e. zipWith f xs ys instead of map (uncurry f) $ zip xs ys
02:24:45 <opqdonut> s/i.e./e.g./
02:25:17 <frerich> Yeah, makes sense. In fact, I think I don't have lists of tuples very often, for some reason.
02:26:54 <opqdonut> right
02:27:23 <opqdonut> in the cases where you actually want to lump values together, you'd normally go for a real record type
02:27:26 <opqdonut> instead of a tuple
02:29:51 <ddarius> uncurry is not a commonly used function.
02:30:35 <ddarius> curry is probably even less used
02:30:40 <frerich> This is probably a stupid question, but is there also something like a 'uncurry3 :: (a -> b -> c -> (d, e)) -> (a, b, c) -> (d, e)' which can be used to turn a 3-tuple into a 2-tuple?
02:30:49 <bsrk> How do I install the dependencies of a cabal package? I want to install all the dependencies including the ones required for tests
02:30:53 <frerich> Maybe this idea is stupid, Hoogle didn't find aynthing like that.
02:32:05 <frerich> I guess it's a silly idea because you only "curry one argument" at a time.
02:32:20 * frerich crawls back into his dark hole in the wall, lurking
02:32:38 <kfish> frerich: it's not stupid if it makes your code readable :)
02:33:01 <kmc> it's probably in http://hackage.haskell.org/package/tuple
02:39:59 <kmc> another reason to uncurry is that a function might *return* a tuple
02:40:09 <kmc> :t uncurry ?f . ?g
02:40:10 <lambdabot> forall a b c (f :: * -> *). (?f::a -> b -> c, ?g::f (a, b), Functor f) => f c
02:40:24 <kmc> :t uncurry ?f Prelude.. ?g
02:40:24 <lambdabot> forall a b c a1. (?g::a1 -> (a, b), ?f::a -> b -> c) => a1 -> c
02:41:19 <absence> is it possible to use a variable from an outer scope when pattern matching?
02:41:33 <kmc> what do you mean?
02:41:56 <Saizan> if you reuse it in a pattern you'd just be shadowing the outer binding
02:42:14 <Saizan> you've to use (==) in a guard
02:42:16 <kmc> yeah, you don't really use variables in patterns, you only bind them
02:42:32 <kmc> (unless you're using a language extension like ViewPatterns)
02:42:35 <absence> kmc: instead of doing e.g. myfunc (1:_) = ... i want to do myfunc (some_constant_that_is_one:_) = ...
02:42:58 <kmc> that doesn't work; it will match any non-empty list and bind the first element to that name
02:42:59 <absence> but that obviously matches anything and creates a new variable
02:43:09 <kmc> f (x:_) | x == some_constant = ...
02:45:28 <ddarius> f ((==1) -> True) = ...
02:45:39 <ddarius> s/1/one/
02:47:27 <absence> kmc: ahh right, i recognise the syntax. thanks :)
02:51:12 <fedvasu> hi guys , i have very basic question
02:51:42 <fedvasu> i have declared a function dbl x = x +x
02:52:27 <fedvasu> without declaring it's type signature (or writing it's type)
02:52:44 <fedvasu> i have declared another function qbl = dbl.dbl
02:53:02 <fedvasu> ghci infers the type of dbl as follows
02:53:13 <fedvasu> (Num a)=> a->a
02:53:38 <fedvasu> but for qbl it's Integer->Integer
02:53:52 <fedvasu> why? why the type has been downgraded?
02:53:54 <snappy> Hm, I'm looking at an exercise: write the function wholeNumbers, which takes no parameters and returns an infinite list of whole numbers, i.e. [0,1,2,...]. Use primitive, infinite recursion to generate your list. Is this even possible without some form of state, specifically a parameter?
02:55:03 <osfameron> snappy: your function without parameters could define an auxhiliary function with a parameter for that state
02:55:21 <fedvasu> any clues for my question? any places where i can dig more ?
02:56:02 <mah_b> fedvasu: maybe http://www.haskell.org/onlinereport/decls.html#sect4.3.4
02:56:18 <snappy> osfameron: ah yeah, i guess that'd do the trick
02:58:00 <fedvasu> mah_b: thanks for the pointer , in short can you tell me how my function had ambiguos type , so that composition of it had to be downgraded
03:01:31 <kmc> fedvasu, the problem is the Dreaded Monomorphism Restriction
03:02:12 <kmc> basically there is a dumb rule in the Haskell spec which says that declarations which are not *syntactically* functions will be made less polymorphic than they could be, under certain circumstances
03:02:28 <kmc> qbl is a function but it's syntactically a pattern-declaration, not a function-declaration
03:02:52 <fedvasu> i have no idea what you said first  , but yeah later explaination helps
03:02:53 <kmc> if you write «qbl x = (dbl.dbl) x» it will go away
03:03:18 <fedvasu> ok , but why can't i do dbl$dbl ?
03:03:31 <kmc> but the better solution is a) give a type signature to qbl, or b) disable the monomorphism restriction with ghc -XNoMonomorphismRestriction
03:03:32 <fedvasu> nice word "Dreaded monomorphism"
03:03:46 <kmc> (dbl $ dbl) would be something else entirely
03:03:52 <kmc> that's unrelated to the rest of what you've said
03:04:27 <fedvasu> like when i do this in ghci dbl$dbl 2.7
03:04:37 <kmc> that parses as dbl $ (dbl 2.7)
03:04:50 <fedvasu> it gives quadraple , i'm asking new question
03:04:51 <kmc> function application syntax always binds tighter than infix operators like ($)
03:05:06 <fedvasu> hmm
03:05:19 <kmc> but (dbl $ dbl) would be a type error, it's dbl + dbl
03:05:25 <kmc> i.e. trying to double the function itself
03:05:33 <kmc> (dbl $ dbl) is not a subexpression of (dbl $ dbl 2.7)
03:05:45 <fedvasu> yeah , i got that type error
03:05:55 <fedvasu> when trying to declare function
03:06:10 <fedvasu> but when i did it in repl , it gave answer
03:06:37 <fedvasu> i go your point the way it parsed and highest prefernce to <space> function application
03:06:53 <fedvasu> thanks again ,
03:07:01 <kmc> :)
03:07:14 <fedvasu> is this Dreaded Monomorphism taken from "Category theory"?
03:07:40 <fedvasu> i'm engineering graduate , i would like to dig more in that place
03:07:48 <xshoppyx> http://pastebin.com/Rfx0HsAV
03:07:51 <mauke> The paste Rfx0HsAV has been copied to http://hpaste.org/53387
03:07:57 <xshoppyx> Why is that not valid?
03:08:07 <fedvasu> but i have no idea what category theory is , but no a bit of fields and rings
03:11:06 <kmc> fedvasu, no
03:11:20 <mah_b> xshoppyx: the first "if" has to be somehow indented (adding one space solves this).
03:11:24 <kmc> fedvasu, in this case 'monomorphic' is just the opposite of 'polymorphic'
03:11:29 <fedvasu> form where? then
03:11:38 <fedvasu> oh...
03:11:52 <fedvasu> yeah that makes sense
03:11:52 <kmc> it's call the Monomorphism Restriction and sometimes Dreaded Monomorphism Restriction because of how it bites people
03:12:01 <kmc> it's a bad idea and will probably be removed in a future version of the language
03:12:09 <fedvasu> downgrading polymorphic code to monomorphic one
03:12:14 <xshoppyx> Thanks
03:13:01 <fedvasu> i'll keep digging into haskell and hopefully ask more questions for now bye , thanks again kmc :)
03:13:23 <kmc> bah I didn't get to deliver my "Haskell and category theory: not actually that related" rant
03:14:20 <yitz> kmc: they may not be related, but sometimes they're roommates
03:14:36 <kmc> heh :)
03:20:18 <absence> is there a library function similar to this? blabla p x = if p then Just x else Nothing
03:21:39 <kmc> heh the same question came up less than 24 hours ago
03:22:01 <kmc> i would go with:  guard p >> Just x
03:22:21 <kmc> or:   x <$ guard p
03:22:38 <kmc> with -XMonadComprehensions you can write [ x | p ]
03:25:59 <kmc> absence, also it's toMaybe in this module: http://hackage.haskell.org/packages/archive/utility-ht/0.0.7/doc/html/Data-Maybe-HT.html
03:26:16 <absence> interesting. thanks :)
03:26:43 <geheimdienst> absence: i was the one who asked a few days ago, and for the record, i went with writing it myself: "ensure p x = mfilter p (return x)"
03:29:15 <absence> geheimdienst: i'll probably end up with something like that yes
03:30:21 <kmc> ps ==> x = guard (and ps) >> Just x   -- in one of my projects
03:30:35 <kmc> in this case it was more convenient to check a list of booleans, but that's incidental
04:01:52 <rotflcopter> how would someone apply an N degree rotation of a 2d point around P_o ?
04:06:51 <kmc> a rotation of θ around the origin is \(x,y) -> (x * cos θ + y * sin θ,  x * sin θ + y * cos θ)
04:07:02 <kmc> in Haskell, θ would be in radians
04:07:37 <absence> is there a more readable way to express (x1,x2) /= (p1,p2) && (x1,x2) /= (p2,p1) ?
04:08:32 <kmc> (x /= p) && (x /= swap p)
04:08:44 <geheimdienst> perhaps "not ((x1,x2) `elem` [(p1,p2), (p2,p1)])"
04:08:46 <kmc> not (x `elem` [p, swap p])
04:08:49 <aavogt> does swap exist?
04:08:55 <kmc> in Data.Tuple, yes
04:08:57 <kmc> since maybe GHC 7
04:09:02 <ClaudiusMaximus> :t notElem
04:09:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:09:12 <geheimdienst> ClaudiusMaximus: right
04:09:47 <aavogt> kmc's first example looks better without parens
04:10:28 <kmc> if you say so
04:12:25 <absence> the notElem one fits nicely, thanks!
04:12:39 <aavogt> kmc: do you know about ways to make FFI less painful (question here http://hpaste.org/53311 ) ?
04:14:11 <kmc> you want to get rid of these allocas?
04:16:47 <aavogt> that and/or redundancy in the foreign import
04:17:08 <kmc> aavogt, there's some trick I've seen with ContT to combine many "withCString" uses
04:17:12 <kmc> which might work with your allocas as well
04:17:16 <kmc> I forget how the trick goes; ask Cale
04:17:28 <kmc> it's mentioned in the 'newtype' package as 'ala Cont traverse'
04:21:30 <Baughn> So I'm writing an mplayer vo module in haskell..
04:21:56 <Baughn> This is mostly opengl, but it involves a little bit of byte-wrangling
04:22:15 <Baughn> In particular, taking thee color planes and interleaving them.
04:22:47 <Baughn> Would it be silly for me to try that outside C, or are there any libraries fast enough for this purpose?
04:22:52 <Baughn> s/thee/three/
04:23:31 <Baughn> (That is, basically, [[1,2,3],[4,5,6],[7,8,9]] -> [1,4,7,2,5,...]. Only with packed arrays.)
04:24:56 <Axman6> depends how important speed is i guess. you might find that vector is fast enough, maybe not
04:27:02 <joni6128> Baughn, you might want to take a look at scalala too. It provides fast vector and matrix manipulations https://github.com/scalala/Scalala
04:27:09 * Baughn wonders how to dress up as shared mutable state for halloween
04:27:27 <Baughn> joni6128: Well, that's not haskell. :P
04:27:40 <joni6128> oops sorry :)
04:27:48 <joni6128> hmatrix then :)
04:27:56 <Baughn> MPlayer is already unknown territory, as is YUV
04:28:03 <Baughn> I'd rather not add yet another unknown to the stack
04:28:20 <joni6128> http://perception.inf.um.es/hmatrix/
04:28:21 <Baughn> HMatrix, array.. right.
04:28:25 <absence> if i have a bunch of constraint functions that either accept or reject a single value, what is the best way to express this without having to pass the value to be constrained around? state monad? maybe monad? something custom?
04:28:30 <Baughn> *vector
04:29:01 <ClaudiusMaximus> Baughn: personally i'd think about doing the interleaving and colour space conversion on the GPU with a shader, depends if you're targetting older hardware if that's an option
04:29:15 <Baughn> absence: As functions? I don't know what you need this for, though. Go up a level.
04:29:51 <atomicity> I need some help understainding a compiler error. I'm very new to haskell, and am trying to define a parametric datatype that would hold a list (values) and a function (distribution) with the type signature (Eq a) => a -> Float. I wrote data RandomVar a = RandomVar { values :: [a], distribution :: (Eq a) => a -> Float }. ghci says Illegal polymorphic or qualified type: Eq a => a -> Float. What can I
04:29:54 <atomicity> do to make this legal?
04:29:57 <Baughn> ClaudiusMaximus: You're right, and that's my target..
04:30:05 <Baughn> ClaudiusMaximus: I just don't know if I'll manage to do /everything/ in the shader
04:31:10 <ClaudiusMaximus> Baughn: actually, can glTexSubImage fill one channel at a time?
04:31:13 <Baughn> atomicity: GADTs would do it, assuming the 'it' you have in mind is the same 'it' I do
04:31:22 <Baughn> ClaudiusMaximus: No.
04:31:37 <rotflcopter> heh kmc thanks its that simple?
04:31:37 <Baughn> ClaudiusMaximus: Not efficiently, anyway.
04:31:44 <ClaudiusMaximus> Baughn: ok, good to know!
04:31:56 <absence> Baughn: what do you mean? maybe constraint is not the right word, but a bunch of functions that each check some property of the value to determine if it is valud or not (and if it isn't, there's no point in doing subsequent checks)
04:32:06 <Baughn> ClaudiusMaximus: It does have a notion of stride that could do it, but it's often implemented as a software fallback
04:32:25 <Baughn> absence: Right.. question, then:
04:33:04 <rotflcopter> kmc<< i used to make vector,alpha outof (xc,yc)->(x,y), rotate, then convert back
04:33:52 <Baughn> absence: ..
04:33:58 <atomicity> Baughn: um... the "it" having a function that will take a value from 'values' and spew out a probability stored beside the values.
04:34:00 <Baughn> absence: No, I can't quite picture it.
04:34:17 <Baughn> absence: Retrying. You're making a list. Of what, exactly?
04:35:04 <atomicity> Baughn: but I'm having a problem understanding GADSs, seems quite involved... Can you explain (in short) why I can't have such a datatype in a structure without GADSs? Or is the answer just "you can't, deal with it"?
04:35:58 <Baughn> atomicity: The answer would be "you can, but GADTs are easier to understand"
04:36:08 <Baughn> atomicity: However, I'm not at all sure a GADT is what you want. :)
04:37:58 <absence> Baughn: not making a list, but i have a list of values. i want to filter it so i end up with only "valid" values. if there was a single function to determine validity, it would simply be filter isValid values, but there are several functions to determine validity, and i'm hoping to express it in a better way than doing many calls to filter
04:38:11 <atomicity> Baughn: well... I want to store a random variable. A random variable is composed of a set of possible vaues and the probability distribution over those values. A probability distribution is a function from the set of those values to the real interval [0,1]. I want to be able to represent such a structure.
04:38:52 <absence> Baughn: so all those functions to determine validity have to be merged into one i guess
04:39:29 <atomicity> I'm doing this to learn haskell, and am asking for help in choosing the right tools because I don't have enough experience. So I guess I'm asking you: *are* GADTs what I want?
04:40:02 <Baughn> absence: Compose the functions, then pass them to filter.
04:40:21 <Baughn> > fitler ((< 3) . (> 0)) [-1..8]
04:40:22 <lambdabot>   Not in scope: `fitler'
04:40:28 <Baughn> > filter ((< 3) . (> 0)) [-1..8]
04:40:29 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
04:40:29 <lambdabot>    arising from the literal `3'...
04:40:40 * Baughn twitches violently
04:40:52 <ClaudiusMaximus> > filter ((< 3) `mappend` (> 0)) [-1 .. 8]
04:40:54 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
04:40:54 <lambdabot>    arising from a use of...
04:40:59 <Baughn> absence: Also please ignore the insanity of \bot.
04:41:13 <Axman6> :t on (&&)
04:41:13 <lambdabot> forall a. (a -> Bool) -> a -> a -> Bool
04:41:35 <Baughn> atomicity: Oh, now I get it. You want to store a probability distribution. :)
04:41:37 <ClaudiusMaximus> oh, there's more than one possible Monoid Bool ...
04:41:43 <atomicity> > filter ( \x -> (x < 3) || (x > 0) ) [-1,..,8]
04:41:43 <lambdabot>   <no location info>: parse error on input `..'
04:41:48 <leod> @pl \a->(a<3) && (a>0)
04:41:48 <atomicity> > filter ( \x -> (x < 3) || (x > 0) ) [-1..8]
04:41:49 <lambdabot> liftM2 (&&) (< 3) (> 0)
04:41:49 <lambdabot>   [-1,0,1,2,3,4,5,6,7,8]
04:41:51 <rotflcopter> still having syntax errors :(
04:41:53 <Baughn> atomicity: Sorry, I wasn't connecting it to the math. Anyhow..
04:41:59 <atomicity> > filter ( \x -> (x < 3) && (x > 0) ) [-1..8]
04:42:00 <lambdabot>   [1,2]
04:42:15 <rotflcopter> let x=(100,200)
04:42:24 <rotflcopter> let θ=(pi/180)*20
04:42:35 <rotflcopter> let rot \(x,y) -> (x * cos θ + y * sin θ,  x * sin θ + y * cos θ)
04:42:41 <Axman6> rotflcopter: please paste the whole code on hpaste.org!
04:42:49 <absence> Baughn: composing doesn't seem to work..
04:42:49 <rotflcopter> this is the whole code
04:42:49 <atomicity> Baughn: glad we got that sorted out :). So, *do* I need GADTs?
04:42:51 <rotflcopter> ;<
04:42:53 <Baughn> absence: *sigh*. Yes. I got my filter use wrong.
04:43:05 <atomicity> absence: look at my prev comment with the >
04:43:10 <Axman6> rotflcopter: then there's obviously errors. you can't use let at the top level
04:43:12 <Baughn> atomicity: What you probably want to store, then, isa function from a PRNG state to a.. Double, or whatever.
04:43:18 <yitz> atomicity: just leave off the Eq a constraint. Specify it on functions that use the data type.
04:43:18 <ClaudiusMaximus> > filter (any (flip id) [(< 3), (> 5)]) [-1..8]
04:43:19 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
04:43:19 <lambdabot>         against inferred type ...
04:43:29 <Baughn> atomicity: Which means you do not in any way, shape or form need GADTs or anything else advanced
04:44:08 <absence> atomicity: this is where i'm looking for something more elegant. if there are ten functions, i have to pass x to all of them
04:44:13 <atomicity> Baughn: I don't need prngs. This is for bayesian shit
04:44:25 <Axman6> rotflcopter: also, what is rot supposed to do?
04:44:33 <rotflcopter> it would be a function
04:44:39 <rotflcopter> but i messed up the syntax
04:45:15 <Axman6> you probably want rot (x,y) = ...
04:45:28 <Axman6> rotflcopter: what are you using to learn haskell?
04:45:34 <rotflcopter> i have a reference point, and another point to rotate with angle
04:45:38 <atomicity> yitz: thanks. Now I'm getting Show errors :)
04:45:43 <Baughn> atomicity: Right.. well, is's math, anyhow.. but what you need to store depends on what you want to do with it later
04:45:57 <rotflcopter> Axman6<< im still at the beginning
04:46:05 <Axman6> rotflcopter: of what?
04:46:08 <rotflcopter> trying out things in ghci
04:46:12 <Axman6> what are you reading to learn haskell with
04:46:13 <yitz> atomicity: yes, you can't Show a function.
04:46:21 <Baughn> atomicity: Which I suppose in the worst case will be a bunch of parameters characterizing the distribution
04:46:37 <atomicity> yitz: yeah, I'm figuring out how to derive show this kind of class right now
04:47:09 <rotflcopter> well a few days ago my chrome hanged and the links were opened in that, and im on opera now
04:47:10 <rotflcopter> ;/
04:47:38 <atomicity> Baughn: that's why I'm wrapping it all in a function. I'll probably write a bunch of functions that are more general but end with ... -> a -> Double
04:47:49 <atomicity> and curry it into the variable declaration
04:48:07 <Axman6> rotflcopter: so you're not using any tutorial then?
04:48:16 <atomicity> Axman6: I'm using learn you a haskell
04:48:25 <atomicity> Axman6: and dragonforce
04:48:27 <atomicity> :)
04:48:35 <Baughn> atomicity: It's not obvious to me that a function is what you want
04:48:38 <rotflcopter> Axman6<< i was, just did a pause
04:48:42 <Axman6> dragonforce?
04:48:44 <yitz> atomicity: here's an idea: define a "distribution" type that has a name and a function. showing it just gives the name.
04:49:10 <rotflcopter> ghc and some working code looks distant to me ;<
04:49:12 <atomicity> yitz: that's not a bad idea.
04:49:12 <Baughn> atomicity: You could have something like a 'data Distribution = Uniform | Exponential { lambda :: Double } | ..."
04:49:35 <atomicity> Baughn: again, not what I'm doing
04:49:40 <rotflcopter> since i didnt have a change to fully install it on / and itfails to setup with prefix properly
04:49:52 <Baughn> atomicity: That would carry all the information about the distribution, though
04:49:54 <atomicity> Baughn: although I can see why it would be a good idea to do that if I were doing what you normally do with these things
04:50:15 <rotflcopter> especially the cabal thing
04:50:21 <Baughn> atomicity: I don't see what else you could say about the distributions that /isn't/ covered by such a type
04:50:22 <atomicity> Baughn: hm...
04:50:35 <rotflcopter> ghc and ghci works,... without any extra libraries
04:50:37 <Baughn> atomicity: Then you'd have functions from the type to whatever you'd need at the moment
04:51:17 <atomicity> Baughn: ok, yeah, I can see now. Thanks for being stubborn enough to make me look again.
04:51:48 * hackagebot uu-parsinglib 2.7.2.2 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.2.2 (DoaitseSwierstra)
04:52:19 <yitz> atomicity: Baughn's idea is quite similar to what i said. instead of passing around the function, you just pass around the token, and have one function somewhere that delegates to implemenations of the various distributions.
04:52:53 <atomicity> yitz: yeah, great minds think alike and stuff :)
04:53:20 <yitz> heheh thanks for flattering me by comparing me to Baughn :)
04:53:33 <atomicity> I'm still figuring out how I can reconcile this concept (which I'll probably end up taking, as it's better than what I was thinking about) with the serious amount of data I need to actually compute the distributions.
04:54:18 <yitz> atomicity: yeah that will drive which of those or other similar approaches will help you structure your application best
04:54:27 <rotflcopter> how do i test something like
04:54:30 <atomicity> anyhoo, I'm off. No doubt I'll be back when (not if) I get stuck again :)
04:54:34 <atomicity> thanks
04:54:47 <rotflcopter> neg :: Vector3 -> Vector3
04:55:05 <rotflcopter> neg (x,y,z) = (-x,-y,-z)
04:55:07 <rotflcopter> in ghci?
04:55:13 <rotflcopter> ;/
04:55:41 <rotflcopter> cannot figure it out
04:55:44 <Axman6> rotflcopter: for that you need let
04:56:56 <flatwhatson> > let neg (x,y,z) = (-x,-y,-z); neg (1,2,3)
04:56:57 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:57:10 <flatwhatson> :(
04:57:23 <leod> try in instead of ;
04:57:29 <Axman6> > let neg (x,y,z) = (-x,-y,-z) in neg (1,2,3)
04:57:30 <lambdabot>   (-1,-2,-3)
04:59:23 <rotflcopter> hmm can i have ghci work like bash?
04:59:40 <rotflcopter> like ghci somecommand
05:00:03 <Tinned_Tuna> rotflcopter: I think you can use runhaskell <somefile>.hs
05:00:04 <opqdonut> rotflcopter: ghci -e expr
05:00:31 <opqdonut> yeah if it's a script file then runhaskell / runghc
05:01:08 <rotflcopter> hm lets see
05:01:55 <atomicity> um... so, let's say I did data Distribution a = Uniform [a] | Weird [a]; and declared the RandomVar a = RandomVar { values :: [a], distribution :: Distribution a }; How do I pattern-match specific distributions now? Sorry to be asking this, but I haven't a clue where to look or what to put into google.
05:02:12 <rotflcopter> $ ./runhaskell <(echo "neg (x,y) = (-x,-y) in neg p")
05:02:12 <rotflcopter> *** Exception: /dev/fd/63: hFileSize: inappropriate type (not a regular file)
05:02:13 <rotflcopter> :(
05:03:01 <atomicity> oh, I think I found something.
05:03:23 <Jaak> try: ghc -e "let neg (x,y) = (-x,-y) in neg (1,2)"
05:03:28 <opqdonut> $ ghc -e 'print $ let neg (x,y) = (-x,-y) in neg (1,2)'
05:03:28 <opqdonut> (-1,-2)
05:03:49 <opqdonut> oh yeah, works even w/o the print
05:04:12 <opqdonut> atomicity: just pattern match
05:04:13 <rotflcopter> ahah almost made it
05:04:14 <rotflcopter> t="neg (x,y) = (-x,-y) in neg p";echo "$t" >>/dev/shm/tmp.$$;./runhaskell "/dev/shm/tmp.$$";rm -f "/dev/shm/tmp.$$"
05:04:30 <opqdonut> rotflcopter: did you read what I and Jaak suggested?
05:04:35 <rotflcopter> yes now
05:04:58 <rotflcopter> wow thanks thats cool
05:05:13 <opqdonut> atomicity: i.e. "case rvar of (RandomVar vals (Uniform things)) -> something; ..."
05:05:50 <Baughn> atomicity: 'Uniform [a]' is not what I had in mind. Just 'Uniform'.
05:06:09 <Baughn> atomicity: When you know it's a uniform distribution, you should not need any further information..
05:06:57 <opqdonut> well only if the domain is implicit
05:07:19 <k0ral> hi, is there something like mapMaybe but for a -> IO (Maybe b) instead of a -> Maybe b ?
05:07:32 <rotflcopter> how to make this in one line? ghc -e "let p=(100,200)"$'\n'"let neg (x,y) = (-x,-y) in neg p"
05:07:42 <rotflcopter> (or work)
05:07:51 <rotflcopter> (and/or work)
05:07:53 <Baughn> Well, true. If it wasn't you'd have (a,a) though, not [a]
05:08:43 <opqdonut> k0ral: not as such. you can either implement a mapMaybeM or just use mapM + filter
05:09:02 <atomicity> Baughn: it might turn out I don't need it, yes. I'm having some problems figuring out how I'll do conditional distributions, that's why I'm including the domain...
05:09:17 <Baughn> atomicity: [a] does not sound like a domain
05:09:22 <atomicity> Baughn: and (a,a) is for real distributions, my domains are discrete
05:09:25 <opqdonut> rotflcopter: $ ghc -e 'let p=(1,2); neg (x,y) = (-x,-y) in neg p'
05:09:57 <atomicity> Baughn: I'm programming a stupid spam filter, basically. For learning.
05:09:59 <rotflcopter> ah so i only need one let at the beginning of a line ?
05:10:03 <opqdonut> rotflcopter: you can use ; and {} instead of whitespace-based layout
05:10:31 <atomicity> Baughn: probably gonna extend it to arbitrary bayesian networks
05:10:32 <opqdonut> you give ghc a single expression and it evaluates it. the expression can be a let-expression. learn the language.
05:10:42 <rotflcopter> im doing it
05:10:43 <atomicity> Baughn: but first I need to get the basics working :)
05:11:00 <rotflcopter> but iassumed every expression needs let
05:11:03 <atomicity> Baughn: but of course you're right, I don't need any params for uniform distributions.
05:11:03 <rotflcopter> in ghci
05:12:16 <opqdonut> for example the expression 1+2 doesn't
05:13:35 <rotflcopter> given i have an input channel and a stdout i can already use ghc as some filter
05:15:45 <kmc> is there anything preventing name collisions between C functions defined in different Haskell packages?
05:15:54 <kmc> assume I'm using GHC and Cabal
05:16:07 <dcoutts> kmc: no
05:16:24 <atomicity> hah, compiles! :)
05:16:57 <kmc> dcoutts, thanks, 's what I thought
05:17:14 <kmc> frankly I would find it a bit terrifying if the answer were "yes"
05:17:44 <rotflcopter> ghc -e "let p=(100,200);θ=(pi/180)*20;rot (x,y) = (x * cos θ + y * sin θ,  x * sin θ + y * cos θ) in rot p"
05:17:48 <rotflcopter> why is this error?
05:17:50 <rotflcopter> ";"
05:18:02 <rotflcopter> after *20
05:18:12 <kmc> what's the error?
05:18:18 <rotflcopter> <interactive>:1:31: parse error on input `;'
05:19:35 <dcoutts> kmc: we could change the default symbol visibility
05:19:49 <kmc> rotflcopter, probably ghc fail at decoding non-ASCII characters in command line
05:20:19 <rotflcopter> ahm i see
05:20:24 <kmc> rotflcopter, for me it works in GHC 7.2 but not 7.0; there were improvements to text handling in the 'process' package in that timeframe
05:20:35 <rotflcopter> it works as 'a'
05:20:46 <rotflcopter> aham cool
05:20:55 <rotflcopter> i have 7.0.3 with nonworking cabal
05:21:48 * hackagebot Kleislify 0.0.1 - Variants of Control.Arrow functions, specialised to kleislis.  http://hackage.haskell.org/package/Kleislify-0.0.1 (DylanJust)
05:30:01 <adimit> @djinn b -> ((b -> c) -> c)
05:30:02 <lambdabot> f a b = b a
05:30:04 <BobFunk> tls-0.8.1 is failing to install on my lucid box - getting this message:
05:30:04 <BobFunk>     `RSA.public_sz' is not a (visible) field of constructor `RSA.PublicKey'
05:30:07 <BobFunk> any ideas?
05:32:07 <hpaste> geheimdienst pasted “mucking-around-making-a-filesystem” at http://hpaste.org/53388
05:32:46 <geheimdienst> ^^ i want to run this by you and see if you'd recommend typeclasses or what it may be
05:32:58 <geheimdienst> thanks for looking
05:38:04 <lunaris> geheimdienst: You could use a GADT (though personally your approach is not uncommon I'd wager)
05:38:08 <lunaris> geheimdienst: Something like:
05:38:14 <lunaris> data File
05:38:16 <lunaris> data Dir
05:38:19 <lunaris> data Entry a where
05:38:24 <lunaris>   File :: Entry File
05:38:27 <lunaris>   Dir :: Entry Dir
05:38:42 <lunaris> getContentsOfFile :: Entry File -> ...
05:38:52 <lunaris> etc.
05:39:13 <lunaris> ({-# LANGUAGE EmptyDataDecls, GADTs #-})
05:39:16 <geheimdienst> right, looks very good. this is the point where i go read the wikibooks chapter on GADTs
05:39:22 <lunaris> There are probably nicer ways which other people will recommend.
05:39:22 <geheimdienst> thanks a lot lunaris
05:39:26 <lunaris> No worries.
05:45:53 <yitz> BobFunk: looks like 0.8.2 was uploaded a few hours ago. maybe it's fixed there?
05:47:30 <BobFunk> yitz: yeah, but running into dependency hell
05:47:52 <BobFunk> since tls-0.8.2 requires certificate<=1.0.0 && <1.1.0
05:48:11 <BobFunk> and http-enumerator requires certificate >=0.7 && <0.10
05:48:23 <yitz> oh dear
05:49:13 <BobFunk> love haskell - but really, really miss bundler from ruby each time I do a fresh build of some of my stuff :/
05:49:17 <yitz> i'd email vincent and ask what to do
05:49:50 <BobFunk> might just try to grab the enumerator source and change the dependency or something
05:50:19 <BobFunk> just doing a small thing - have it working on my os x machine, but need to get it to compile under linux
05:50:21 <yitz> BobFunk: you could also try a downgrade and see if that works.
05:50:41 <yitz> BobFunk: with what version of tls does it work on the mac?
05:51:13 <BobFunk> guess I could try going eve further down than 0.8.0
05:51:57 <BobFunk> hmm, wont do
05:52:13 <BobFunk> http-enumerator also requires tls >= 0.8.1
05:52:20 <yitz> argh
05:53:43 <yitz> BobFunk: use ghc-pkg list to see what version of stuff you have working on the mac, then try to duplicate that on linux
05:54:09 <yitz> BobFunk: in the meantime. but really, ask vincent about it. sounds like a problem he would want to fix immediately.
05:55:34 <BobFunk> yitz: ust not sure what package to look for - on the mac tls 0.8.1 installs just fine, bu not sure whats breaking it on my ubuntu box
05:56:18 <yitz> BobFunk: oh, really? that's very weird. where does that RSA data type come from, another package?
05:56:34 <BobFunk> that's the question
05:56:55 <yitz> BobFunk: perhaps it's a broken dependency in tls and you happened to have the right other thing installed on the mac
05:59:37 <BobFunk> yitz: it's possible, yeah
06:00:33 <BobFunk> strange thing is that I havent run into that problem before on ubuntu with other projects - it was just now when starting from scratch with a new ubuntu install (HD died) that I'm running into it
06:00:45 <BobFunk> so could be that it's a c library missing or something
06:00:53 <rotflcopter> how to make "p" type point2d in ghci?
06:00:53 <BobFunk> just don't know what it would be
06:01:03 <rotflcopter> this is the point where i give up syntax error
06:01:08 <rotflcopter> Prelude> type point2d = (Float, Float)
06:01:08 <rotflcopter> <interactive>:1:1: parse error on input `type'
06:01:08 <yitz> BobFunk: no. it's from cryptocipher, by the same author. latest version does export that field.
06:02:06 <yitz> BobFunk: we can keep debugging this if this is urgent, you'll probably get it working. but report this to vincent, he's the one who really needs to fix this.
06:02:09 <rotflcopter> gci is not ghc?
06:02:15 <rotflcopter> ghci
06:03:03 <rotflcopter> Axman6<< can you help in syntax?
06:03:06 <BobFunk> yitz: will report
06:03:19 <rotflcopter> Prelude> type point2d = (Float, Float)
06:03:54 <yitz> BobFunk: next steps if you want to keep going - 1. check the import of RSA in tls (is it (..), or does it exclude that field?) 2. check versions of cryptocipher on both machines, and if different, whether one version doesn't export that field.
06:06:03 <kmc> you can't define types (or synonyms) at the GHCi prompt except in bleeding-edge versions of GHC
06:06:09 <rotflcopter> :(
06:06:15 <kmc> otherwise make a file and load that
06:07:01 <rotflcopter> i was thinking about learning haskell by means of entering code inghci an investigating but i see it is not cool
06:07:19 <BobFunk> yitz: yeah, pretty much what I'm doing now :)
06:07:45 <rotflcopter> so i make a file, then compile, and run instead right?
06:07:54 <kmc> rotflcopter, no, you make a file with definitions, and load that file into ghci
06:08:01 <kmc> then you can use the stuff you defined, interactively
06:08:54 <yitz> BobFunk: ok have fun :)
06:08:55 <rotflcopter> ahm
06:09:08 <rotflcopter> so ghci is a definition loader and user debugger
06:09:08 <BobFunk> hehe, thanks
06:09:18 <kmc> dunno what that means
06:09:32 <rotflcopter> well if i cant define type in it, but can load it...
06:10:06 <rotflcopter> so a definition (loader & user) debugger
06:10:38 <yitz> rotflcopter: you can definitely do a lot just at the prompt. the problem is that until the next version of GHC you can't define new types there. also, like in any command-prompt interpreter, it becomes a pain to keep hitting up arrow to get back to things you typed before.
06:10:38 <kmc> i don't know what you're getting at with these terms and definitions
06:11:32 <rotflcopter> kmc<< just getting to not trying to write code in ghci for testing
06:11:46 <rotflcopter> that is a '"!+"+%!+'
06:12:01 <kmc> you can write code in ghci for teesting
06:12:02 <hpc> rotflcopter: if it helps, you can think of ghci as a massive IO do-block
06:12:09 <kmc> you can define functions in ghci
06:12:14 <kmc> you just can't define types (yet)
06:12:26 <rotflcopter> i see
06:12:37 <kmc> but if you have a good function you probably wanted to save it in a file anyway
06:12:39 <rotflcopter> but if i load types i can also load definitions as you said
06:12:39 <kmc> you should still use ghci to test that function
06:12:44 <kmc> yes
06:12:55 <rotflcopter> and only test the complete functions with data
06:12:56 <kmc> type definitions, value definitions, whatever
06:12:57 <yitz> you can also define macros that run haskell code and feed the output to ghci commands
06:13:14 <hpc> you can also keep ghci open in one window and edit in another
06:13:19 <hpc> then use ":r" to reload the file
06:13:33 <hpc> iirc, you won't lose any functions you defined yourself
06:13:42 <hpc> (in ghci)
06:14:04 <rotflcopter> i have now discovered if i run mc, then ghci, and press control+o, open file for edit, i can switch between edited file and ghci
06:14:13 <rotflcopter> looks straight forward
06:16:49 * hackagebot acid-state 0.5.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.5.1 (DavidHimmelstrup)
06:19:59 <_Vi> I done "cabal install --global wx", but should have done "cabal install --enable-shared --global wx". How to fix it? For example, how to remove all packages installed by "cabal install --global"?
06:26:25 <absence> what library functions should i look at for finding which of two values occurs first in a list?
06:27:18 <Axman6> take
06:27:22 <Axman6> > take 2 [1..]
06:27:24 <lambdabot>   [1,2]
06:28:11 <Gothmog_> @pl \i j ->  foldr (\k v -> v + (f i k) * (g k j)) 0 [1..m]
06:28:12 <lambdabot> flip flip [1..m] . flip flip 0 . ((foldr . ((+) .)) .) . (. flip g) . ap . ((*) .) . f
06:28:13 <absence> sorry, i meant "which value occurs before the other". i.e. does a come before b in this list (which also contains c, d, etc), or does b come before a?
06:28:17 <Jafet> absence: first, write down the type of what you want.
06:28:46 <absence> Jafet: a -> a -> [a] -> Bool i guess
06:28:46 <Jafet> Presumably it starts with a -> a -> [a] -> ...
06:28:48 <rotflcopter> how would you rasterize a vectorgraphic curve in haskell? (just in theory)
06:29:11 <Jafet> The same way I would rasterize it with any other language
06:29:17 <Jafet> Whichever way that is
06:29:21 <kmc> using http://hackage.haskell.org/package/diagrams
06:29:38 <Jafet> diagrams = cairo?
06:29:46 <kmc> no
06:29:52 <kmc> but cairo is the main backend people use
06:30:12 <Baughn> yitz: And thanks, but I'm not really that good at haskell. I just abuse my position as "knower-of-C".
06:30:35 <Baughn> yitz: Which is great when trying to understand the evaluation process, but..
06:30:40 <rotflcopter> thanks so i read the source
06:30:52 <kmc> you're going to read the source to 'diagrams'?
06:30:57 <rotflcopter> yes
06:31:09 <kmc> i don't think it's directly relevant to your question
06:31:25 <kmc> maybe you should read an example program that invokes 'cairo' directly
06:31:31 <kmc> or maybe you should tell us what you're actually trying to do
06:31:40 <rotflcopter> well if i have a vectorgraphic curve and i want to rasterize it
06:31:55 <kmc> be more specific
06:32:06 * hackagebot doctest 0.4.2 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.4.2 (SimonHengel)
06:32:51 <kmc> why don't you use 'diagrams' instead of reading its source and reimplementing it
06:33:04 <kmc> is your goal here to learn about the algorithms used to rasterize images?
06:33:13 <kmc> because 'diagrams' does not particularly contain that
06:33:18 <kmc> it invokes a drawing library such as cairo
06:33:54 <rotflcopter> arc centerpoint startangle sweepangle linewidth linestyle linecolor
06:34:11 <rotflcopter> and radius
06:34:24 <rotflcopter> in doubt this is implemented
06:34:30 <rotflcopter> and others i'd like to do
06:34:50 <kmc> why don't you use 'diagrams' instead of reading its source and reimplementing it
06:36:17 <kmc> or do i misunderstad
06:38:01 <rotflcopter> i'd not like to draw a circle using any method, i'd like to build an array of coordinates for further calculation
06:38:28 <kmc> oh, that's a very different question
06:38:47 <kmc> 'diagrams' will not help you because it uses the cairo library to do that step
06:39:01 <rotflcopter> oh cool
06:39:06 <kmc> you can read about circle-drawing algorithms
06:39:10 <amisotis>            `'---'`
06:39:13 <rotflcopter> i know scribus uses cairo too for display
06:39:18 <amisotis> think about the function of a circle
06:39:23 <amisotis> just apply that to pixels
06:39:25 <rotflcopter> yes
06:39:36 <amisotis> isn't it y2 = x2 + a
06:39:49 <kmc> the simplest is [ (r * cos θ, r * sin θ) | θ <- [0, pi/n, ..., 2*pi] ]
06:39:49 <rotflcopter> but i wouldnt want to loop 10M times for each circle preying it will equal a pixel
06:40:47 <amisotis> err, you just have to draw 4 arcs it's easy
06:41:08 <rotflcopter> yeah did that in turbopascal 10 years ago
06:41:18 <rotflcopter> drawn 4, 8 pixels at once
06:41:29 <amisotis> I wrote a program that does sine waves on an Apple IIc in Applesoft basic when I Was like 8 years old, if I can do that, circles are easy
06:41:30 <rotflcopter> but still was iterating redundant
06:41:40 <kmc> i wrote a multi-tasking operating system as a fetus
06:41:49 <Ke> !
06:41:53 <rotflcopter> :)
06:42:48 <rotflcopter> can you recommend other methods for circle rendering?
06:42:58 <rotflcopter> without blind iteration ?
06:43:37 <Ferdirand> you coult iterate on x and use tan to compute the best y
06:43:40 <Ferdirand> -t+d
06:43:44 <danr> rotflcopter: http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
06:43:54 <rotflcopter> thanks <; looking into
06:47:29 <amisotis>            ,.-\-.,
06:47:29 <amisotis>         ,'`  / \  `'.
06:47:31 <amisotis>       ,'     | \     `.
06:47:33 <amisotis>      /      /   |      \
06:47:35 <amisotis>     /       `    ,      \
06:47:37 <amisotis>    |-,--------------------
06:47:39 <amisotis>   /   `.  |       \    -`\
06:47:41 <amisotis>   |     `.         ,,-`   |
06:47:42 <amisotis>   |      |`.      ,'      |
06:47:44 <amisotis>   |     /   `.  .`  |     |
06:47:46 <amisotis>   |     '     `.    \     |
06:47:48 <amisotis>    ,   |   _-`  `.   \   /
06:47:50 <amisotis>    |  /  ,'       `.  |  |
06:47:52 <amisotis>     \ /.`           `.\ /
06:47:54 <amisotis>      -`               ''
06:47:56 <amisotis>       `,             ,'
06:47:58 <amisotis>         `.,       _.'
06:48:00 <amisotis>            `'---'`
06:48:08 <KernelTrap> ...
06:48:10 <amisotis>      ,
06:48:12 <amisotis>     g'   4f xM9=*     4g    ]&_  4f A  &  pMF~~~!
06:48:14 <amisotis>    J!    7  .q_,N     4~_   ]8B  M B'  f  0g
06:48:16 <amisotis>    0    /!   6^`$     &mQL  ]& *jT 0  .8    ~~"W,
06:48:18 <amisotis>   ]T_ .N    *}   #   pX  Nc ]#  0! 0 _#   q,_,g0
06:48:19 <amisotis>    ""~'     `^   ~   `   ~'  ^  "  ~~~    `````
06:48:21 <amisotis>   _____,    ,g,           _g
06:48:23 <amisotis>   ``Z``    _M  ""         0&c
06:48:25 <amisotis>     .I     4&g,_         #V_p
06:48:27 <amisotis>      $      ___jp       y!"~~&
06:48:29 <amisotis>   wr0#gae   ~~~"`            "
06:48:31 <amisotis>                                                   
06:48:31 <geheimdienst> @where ops
06:48:32 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:48:33 <amisotis>    QN"MQ   &          m      p   q1 gwwmw, mmqpmmv
06:48:35 <amisotis>    M_  p!  F        _0Mq    *RQ  4$ #        4f
06:48:37 <amisotis>    N~~^^  ]Y        #@_j&   QS Muj6 M8*M     0
06:48:38 <amisotis>    #      0Nmamgq,_0M~^~Mq  #&  #8  N____   ]#
06:48:39 --- mode: ChanServ set +o copumpkin
06:48:40 <amisotis>    `              `'     "          ~``~^    ^
06:48:42 <amisotis>                                                   
06:48:42 --- mode: copumpkin set +b *!~otises@pool-108-15-229-250.hrbgpa.east.verizon.net
06:48:43 --- kick: amisotis was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
06:48:47 <geheimdienst> thanks copumpkin
06:48:59 <raichoo> +1 copumpkin
06:49:23 <Clint> now that was art
06:49:52 --- mode: copumpkin set -b *!~otises@pool-108-15-229-250.hrbgpa.east.verizon.net
06:49:53 <raichoo> What? Uranus is a planet?
06:50:17 <fryguybob> At least it wasn't something controversial like "Pluto is a planet"
06:50:30 <copumpkin> was it a mistake or you think it was a troll?
06:50:47 <copumpkin> kinda looks like a mistake
06:51:05 <fryguybob> looks like a mistake to me.
06:51:06 <geheimdienst> copumpkin: amisotis said something relevant before he started the long paste
06:51:15 <tensorpudding> that guy PM spammed me a few minutes ago
06:51:18 <copumpkin> oh?
06:51:22 <tensorpudding> from another channel i think
06:51:26 <copumpkin> what'd he say?
06:51:48 <kmc> i thought they renamed that planet to "urectum"
06:51:48 <tensorpudding> he's asking questions about  a VRML/X3D plugin
06:51:55 <copumpkin> ah
06:52:09 <tensorpudding> i saw three spam PMs, then tried to find out where it was coming from
06:52:19 <tensorpudding> he was asking about it in #defocus, then i saw him spamming here
06:52:35 <copumpkin> hmm
06:52:42 <copumpkin> ah well, I guess he isn't coming back anyway
06:52:45 --- mode: copumpkin set -o copumpkin
06:53:01 <dmwit> Erring on the side of being nice is nice.
06:53:07 <tensorpudding> oh, he's in #math now
06:53:10 <tensorpudding> asking the same question
06:53:27 <rotflcopter> <;
06:53:40 <raichoo> Bored kids are bored.
06:53:44 <danr> copumpkin: oh, what's with the convention of just being op when you need to?
06:53:49 <tensorpudding> he's spamming #math
06:53:54 <copumpkin> danr: it's more pleasant that way
06:54:05 <tensorpudding> for not answering his question about a VRML/X3D plugin
06:54:08 <kmc> it's a nice way to send a warning
06:54:26 <kmc> in my mind "* ChanServ gives channel operator status to <user>" is accompanied by the sound of a pump shotgun being cocked
06:54:45 <absence> http://hpaste.org/53390 <- can this be expressed better with a fold or other library functions?
06:55:08 <kmc> you're missing a case for []
06:55:18 <geheimdienst> kmc: where's my royalties on that joke?
06:55:26 <kmc> omg that's your joke geheimdienst?
06:55:28 <kmc> no way
06:55:51 <kmc> absence, it's not what you asked, but one possible improvement is the "worker-wrapper transform"
06:55:55 <raichoo> kmc: I recall hearing it in "futurama"
06:56:02 <kmc> oh the urectum one?
06:56:06 <raichoo> yeah
06:56:11 <kmc> yeah that's from futurama ;P
06:56:38 <kmc> notBefore p1 p2 = go where { go (x:_) | x == p1 = False ... }
06:56:50 <absence> kmc: pretend it's there :) i haven't bothered writing one since the list will always contain both (which i know is bad practice, but i'll deal with that later)
06:56:55 <Ferdirand> maybe geheimdienst secretly is one of the Futurama writers
06:56:56 <dmwit> I think ops have two distinct personalities: their Haskell- and fun-loving one, and the no-nonsense authoritarian one that they have to pull out in the bad times.
06:57:07 <kmc> lets you avoid the syntactic overhead of passing p1 and p2 through all these recursive calls
06:57:11 <dmwit> Putting an @ only when you're acting as the latter is a nice piece of communication.
06:57:14 <Ferdirand> we demand more haskell jokes in the upcoming episodes
06:57:27 <danr> dmwit: I see. It's a nice convention
06:57:43 <ClaudiusMaximus> @quote news
06:57:44 <lambdabot> u221e says: I swear, reading Haskell source code is like trying to read a Chinese newspaper
06:58:42 <drbean> Is there a nicer way to do: hasCommonElements = \xs ys -> 1 <= (length $ intersect xs ys)
06:58:55 <dmwit> absence: How about p2 `elem` takeWhile (/= p1) xs
06:59:10 <kmc> 'intersect' on lists is likely to be slow
06:59:40 <ClaudiusMaximus> @check (not . null == (1 <=) . length)
06:59:41 <dmwit> drbean: "null" is nice; also, "any" and "elem" should suggest an alternate approach
06:59:41 <lambdabot>   No instance for (GHC.Classes.Eq ([a] -> GHC.Bool.Bool))
06:59:41 <lambdabot>    arising from a u...
07:00:12 <kmc> :t (or .) . liftM2 (==)
07:00:13 <lambdabot> forall a1. (Eq a1) => [a1] -> [a1] -> Bool
07:00:22 <dmwit> :t \xs ys -> any (`elem` ys) xs
07:00:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:00:49 <frerich> dmwit: I think that's pretty nice.
07:01:22 <dmwit> :t any . flip elem
07:01:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:02:25 <absence> dmwit: won't that always be true if the list contains both p1 and p2?
07:02:41 <absence> ah wait, nm
07:02:48 <absence> remembering what takeWhile does :D
07:08:31 <absence> http://hpaste.org/53391 <- what about this one? can it be made simpler using library functions, or will it just end up a mess?
07:10:50 <kmc> you have the pattern (x1:xs@(x2:_))
07:10:52 <kmc> but you don't use xs
07:10:58 <kmc> might as well write (x1:x2:_)
07:11:24 <kmc> also i'd pull out [(p1,p2), (p2,p1)] into another definition in the 'where'
07:11:41 <dmwit> :t \p1 p2 xs -> any (`elem` zip xs (drop 1 xs)) [(p1, p2), (p2, p1)]
07:11:43 <lambdabot> forall a. (Eq a) => a -> a -> [a] -> Bool
07:11:53 <kmc> and you can reduce «notAdjacent p1 p2 h = notAdjacent' h» to simply «notAdjacent p1 p2 = notAdjacent'»
07:12:08 <kmc> also I don't like primed names; I'd just call the worker "go" or something else short
07:12:11 <dmwit> well...
07:12:28 <dmwit> :t \p1 p2 xs -> all (`notElem` zip xs (drop 1 xs)) [(p1, p2), (p2, p1)]
07:12:28 <opqdonut> go is a great name
07:12:29 <lambdabot> forall a. (Eq a) => a -> a -> [a] -> Bool
07:12:58 <amathew> inidivudally wrapped? are you shitting me
07:13:11 <amathew> whoops, wrong window :)
07:13:14 <opqdonut> :D
07:13:24 <amathew> Someone just gave me my first kinder - bueno
07:13:33 <opqdonut> individually wrapped functions
07:13:45 <byorgey> > let wrap x = [x] in map wrap "hi amathew"
07:13:46 <lambdabot>   ["h","i"," ","a","m","a","t","h","e","w"]
07:13:49 <amathew> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CDoQFjAA&url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FKinder_Bueno&ei=0v-vToaVEKH10gHb0djhAQ&usg=AFQjCNFtCOO0KrZZPGwDTt6nvaLnkWLmYA&sig2=HAQTGf9TyosQKYIEzl9n5Q
07:18:46 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:18:56 <flyupth>            ,.-\-.,
07:18:57 <flyupth>         ,'`  / \  `'.
07:18:58 <flyupth>       ,'     | \     `.
07:18:59 <flyupth>      /      /   |      \
07:19:00 <flyupth>     /       `    ,      \
07:19:01 <flyupth>    |-,--------------------
07:19:02 <flyupth>   /   `.  |       \    -`\
07:19:03 <flyupth>   |     `.         ,,-`   |
07:19:04 <flyupth>   |      |`.      ,'      |
07:19:05 <flyupth>   |     /   `.  .`  |     |
07:19:07 <flyupth>   |     '     `.    \     |
07:19:07 <flyupth>    ,   |   _-`  `.   \   /
07:19:08 <flyupth>    |  /  ,'       `.  |  |
07:19:09 <flyupth>     \ /.`           `.\ /
07:19:10 <flyupth>      -`               ''
07:19:11 <flyupth>       `,             ,'
07:19:12 <flyupth>         `.,       _.'
07:19:13 <flyupth>            `'---'`
07:19:15 <absence> dmwit: great, i'll need some time to wrap my head around it :) thanks
07:19:19 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:19:24 <geheimdienst> @where ops
07:19:25 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:19:29 <flyupth> X B | ` | ^ w q  n h + s ! E f f  n L z $ O r # o  v * / p E + @ :  { 3 : w + 5 ` e  % ` ( ) $ S }   R  F x % T ^ H
07:19:30 <flyupth> > / ; { P ? | T  [ u c W p m v )  / H p G f S q v  B & _ Q ' E ~ N  ] .   P [ \   q  B $ p g  v t h  j ! L n T f ! R
07:19:31 <lambdabot>   <no location info>: parse error on input `/'
07:19:31 <flyupth> <  p > q t s n  ^ Q \ y Z - k   f % & H D R I +  V 6 K ` M F ! 9  * T Z o ? h 8 F  I n y . = T f x    k ' a A ' a ,
07:19:32 <flyupth> q - d  C $ # ~  Q u ] r D h o Y  " ? Y b  q 8 t  B  { j G T Y M  ` S q  Z w   /  Q M R q |  R K  M u f t ) * Q C
07:19:33 <flyupth> e ] - v p > x x  z i R C Y K N   k : B ? ^ 5 q `  x F &    0 Y   n J / [ | I = z  Q > - ; . x < U  ! k : i / i z J
07:19:34 <flyupth> [ . k r _ d Y i  , ' . k | y ] C  z b b J b g B   B ' i z J - E E  f  b O D < d }  0 y \ a L }  &  J '  Z p s Q J
07:19:35 <flyupth> D L + d T f O 5  w ^ 9 t C d ! !  ~ A $ V M k = a  l O t 5 ; w ~ E  r _ > h ` = p   E t r + ~ [ H K  g 4 % N  ; " O
07:19:37 <flyupth> C w ~ < `  l F  X , E C a @ s 3  ) p G Q X ^ z {  O a & m E & 7 N  d P ^ T = W _ u  # < Z { ` l E F  f H U [ l : N
07:19:37 <flyupth> [ C o   < I { ,      _ @ N Z K  : A * w Q ; F j  @ Q Y ! X y R 4  n - I T " * R x  Z g L w & - Q $  ` S \ {  1 ` G
07:19:38 <flyupth> M 1 N p o h N v  e  E  # < X B  m = k < K G ` ]  x < d D D G f }  G * M E 3 ` ~ }  Y g ( k , q ) t  T _ i X 7 \ ' 5
07:19:39 <flyupth> - u X  6 y i i  I 7 z 8 . [ ~ M  / + } } : ] ~ d  ? + c m U U [ "  M   ) D ( e ,  > V K d d W h N  w 1 ] R o | * g
07:19:40 <flyupth> B N " t D f t y  a h o _ x N K (   , a i  @ h   & * w 3 P ! % f  )   S Z j  y  v [ / ( % * G k  _   A g < M # ;
07:19:42 <flyupth> W Z W ) G F U h  V B ~ b C Q > [   [ : _ 0 w Z <  F j | k A 5 [ &  ! k Q i  _  w   = R K x  p x  r W a 0 } E x &
07:19:42 <flyupth> D q v & } S ! l  I b Q ` l : . Z  i A ] : ) K H    M b ^ % _ Z X *  < & ^ Y h  " N  ` [ Y { o n \ =  J k r l k * ^ !
07:19:43 <flyupth> j p ^ : ] F  y  n 6 O L R [ M ]  _ $ ~ = ~ ! Y X   S B K _  H   * a # 0 { # I M  } ` , J d X  L  \ R   E K r o
07:19:44 <flyupth> z  s +  W i S  e E % S r & i l  t Y U J ( v C d  8 m } v m $ t M  , d " L % , E '  L 2 0 V  ~ d =  d & . m I ( 0 h
07:19:46 <flyupth> l ` W 5 C > H }  < g S }   D y k  W ) Z J w P ^ a  d  Y S . G D 5  _ V Z b 0 @ h |  ; I x G P $ n ]  o G P c ! < , d
07:19:46 <flyupth> p r 8 N V # O D  a n P t r ) * >  q + @ a  w @ =  | Y : u x Q d '  z r ] * K + \ q  _ ] F m } U & m  d ( O & % W B |
07:19:47 <flyupth> b n ` D ] W H &  Z % ! W s D m   t 3 w V $ j u R  % H N V d  o $  f | & @ + T L #  R , } P Q # J W  " Q   z > : J =
07:19:48 <flyupth> Y Y } r m S Z Q  U { X 6 I : U F   _ P z [ & r {  F K : r & y h I  H \ s , d s E %  Q v { i > _ F [  q D S , D J [ =
07:19:49 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:19:50 <flyupth> R U l ^ ( z t f  y 5 ? @ = H N f  L ; I   m g F  X U / : Y S Z .  Q F S A u ' . Z  a . % k i ! ? E  g g V @ ! , > .
07:19:50 <flyupth> + 3 G  c _ c P  K u e U [ ^ " g  : g M . 7 % v V  h ^ t < L $ s   /  b l E Z W )  { W f \ n S h 0  O w u I a  ; C
07:19:51 <flyupth> N C E ? ( Z  -  U c I i { ? { {  " t 0 Y ! O Y O  g k u Y K S c P  z ` 6 s ] G 8 (  C + m J E  c    } z $ w * ` .
07:19:52 <flyupth>  Q J ' W ^ 2 G  F h j c T V d R  { w  V r ~ m L  p L  K U _ 9   _ l T ^ ( . s r  3 P x = ] Z u w  > Z ! } , y E B
07:19:53 <flyupth> / 6 b 6 G | { %  X t " + < % 5 y  v X i S T . } G  h A . j - q ! &  ^ > i /  U  $  ( e p v    U o  ; h  / L ( ; Q
07:19:54 <flyupth> + F b ? , N C F  i " 8 q & r 9 n  O N t T k v . @  # g r $ s | Y x  & m [ H  ' 5 U  N M q G 3  P e    s f T F ( $
07:19:55 <flyupth> e } K T ! X ; 9  J K h 7 Z > G u  4 #  ? B x p *  A  d t 3 R p h  I / = H S Z c 5  Z r ]  & - C H  9 -  f O j P '
07:19:56 <flyupth> Z A + d Z } 9 a  0 c 6 Y w s 1 o   H q F S !  i  ? Q = X p t . z  & * D S ] O q e   ;   \ A ] 5 )  S v H : O   o &
07:19:57 <flyupth> F   K @ b ; H &  k S f  $ m G k  r  n : . _ p U  f a L n Y D m .  t S j J : m b *  ( S b | w K g   8 K Q L z , > /
07:19:58 <flyupth> { ] z X w @ R 7  Y + _    K R s  U l 3 . 0 ( - Y  \  # 8 c G C G  e ; a k - ' U x  } ; b j : a _ !  i  > H  m u -
07:19:59 <flyupth> S 7 b # } Y  ~  % [ C I n # z &  } G i G q E " "  @ j I [ < I > 7  g  : j B  i s  } C Z = B ' o y  K I 4 U v N K c
07:20:00 <flyupth> B ` > m t e K r  < j 3 y O ; - b  l | + y X 0 b n  [ ~ | d s  a     ( Z f D X 7 o   + O " T g N   '  L j < W ( x
07:20:01 <flyupth> p X ) d Z n - v  M I 9 P & n k a   i I j ? / n T  } > o n   a V R  k j { g < y K A  S ~ . z T z G s  / j $ m N u / ?
07:20:02 <flyupth> / G U : Y T < @  [ C  E ? = q _  x l   Z J m l  ( n G t % = ! A   7 ? @ e D f b  0 ? ^ " R U 1 F  v D f k b T D C
07:20:03 <flyupth> U \ U [ @   ~  . [ E B ) z r u  X B 0 P ; 9 0 ?  / j v K C N d X  t Y % g H W Y K  9 2 j ' 3 ; Q Y  C   7 U i H d
07:20:08 <geheimdienst> @where ops
07:20:08 <flyupth>                    ,,.-..,
07:20:09 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:20:09 <flyupth>                 ,-`       `',
07:20:10 <flyupth>                -             ',
07:20:10 <luite> hm this ascii art is significantly harder to decipher than the last one
07:20:12 <flyupth>              ,'                _,,,,,__
07:20:12 <flyupth>             /                  `,.....,``
07:20:13 <flyupth>             |                  `|      | |
07:20:14 <flyupth>        _.-``                     |   ,` /
07:20:15 <flyupth>      ,` _,-`                     ,.-` ,`
07:20:16 <flyupth>     |  |   |            ,,,.-''``  _.'
07:20:16 <kmc> is someone using the #haskell logs as data storage
07:20:17 <flyupth>     ` ,\ -'''```````````      _,.'`
07:20:18 <flyupth>        `'-.,,,,,,,,,,----''```  |
07:20:19 <flyupth>             \                   '
07:20:20 <flyupth>              \                 `
07:20:21 <flyupth>               `.             ,`
07:20:22 <flyupth>                 `.,       _.`
07:20:23 <flyupth>                    `''-''`
07:20:24 <flyupth>      ,
07:20:25 <flyupth>     g'   4f xM9=*     4g    ]&_  4f A  &  pMF~~~!
07:20:26 <flyupth>    J!    7  .q_,N     4~_   ]8B  M B'  f  0g
07:20:27 <flyupth>    0    /!   6^`$     &mQL  ]& *jT 0  .8    ~~"W,
07:20:28 <flyupth>   ]T_ .N    *}   #   pX  Nc ]#  0! 0 _#   q,_,g0
07:20:29 <flyupth>    ""~'     `^   ~   `   ~'  ^  "  ~~~    `````
07:20:30 <flyupth>   _____,    ,g,           _g
07:20:31 <flyupth>   ``Z``    _M  ""         0&c
07:20:32 <flyupth>     .I     4&g,_         #V_p
07:20:33 <flyupth>      $      ___jp       y!"~~&
07:20:34 <flyupth>   wr0#gae   ~~~"`            "
07:20:35 <flyupth>                                                   
07:20:36 <flyupth>    QN"MQ   &          m      p   q1 gwwmw, mmqpmmv
07:20:37 <flyupth>    M_  p!  F        _0Mq    *RQ  4$ #        4f
07:20:38 <flyupth>    N~~^^  ]Y        #@_j&   QS Muj6 M8*M     0
07:20:39 <flyupth>    #      0Nmamgq,_0M~^~Mq  #&  #8  N____   ]#
07:20:40 <flyupth>    `              `'     "          ~``~^    ^
07:20:41 <flyupth>                                                   
07:20:42 <flyupth>                                                   
07:20:43 <flyupth> X B | ` | ^ w q  n h + s ! E f f  n L z $ O r # o  v * / p E + @ :  { 3 : w + 5 ` e  % ` ( ) $ S }   R  F x % T ^ H
07:20:45 <flyupth> > / ; { P ? | T  [ u c W p m v )  / H p G f S q v  B & _ Q ' E ~ N  ] .   P [ \   q  B $ p g  v t h  j ! L n T f ! R
07:20:46 <lambdabot>   <no location info>: parse error on input `/'
07:20:46 <flyupth> <  p > q t s n  ^ Q \ y Z - k   f % & H D R I +  V 6 K ` M F ! 9  * T Z o ? h 8 F  I n y . = T f x    k ' a A ' a ,
07:20:47 <kmc> i just checked and it's not a magic eye
07:20:47 <flyupth> q - d  C $ # ~  Q u ] r D h o Y  " ? Y b  q 8 t  B  { j G T Y M  ` S q  Z w   /  Q M R q |  R K  M u f t ) * Q C
07:20:48 <flyupth> e ] - v p > x x  z i R C Y K N   k : B ? ^ 5 q `  x F &    0 Y   n J / [ | I = z  Q > - ; . x < U  ! k : i / i z J
07:20:49 <flyupth> [ . k r _ d Y i  , ' . k | y ] C  z b b J b g B   B ' i z J - E E  f  b O D < d }  0 y \ a L }  &  J '  Z p s Q J
07:20:50 <kmc> @where ops
07:20:50 <flyupth> D L + d T f O 5  w ^ 9 t C d ! !  ~ A $ V M k = a  l O t 5 ; w ~ E  r _ > h ` = p   E t r + ~ [ H K  g 4 % N  ; " O
07:20:50 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:20:52 <flyupth> C w ~ < `  l F  X , E C a @ s 3  ) p G Q X ^ z {  O a & m E & 7 N  d P ^ T = W _ u  # < Z { ` l E F  f H U [ l : N
07:20:53 <flyupth> [ C o   < I { ,      _ @ N Z K  : A * w Q ; F j  @ Q Y ! X y R 4  n - I T " * R x  Z g L w & - Q $  ` S \ {  1 ` G
07:20:54 <flyupth> M 1 N p o h N v  e  E  # < X B  m = k < K G ` ]  x < d D D G f }  G * M E 3 ` ~ }  Y g ( k , q ) t  T _ i X 7 \ ' 5
07:20:55 <flyupth> - u X  6 y i i  I 7 z 8 . [ ~ M  / + } } : ] ~ d  ? + c m U U [ "  M   ) D ( e ,  > V K d d W h N  w 1 ] R o | * g
07:20:56 <flyupth> B N " t D f t y  a h o _ x N K (   , a i  @ h   & * w 3 P ! % f  )   S Z j  y  v [ / ( % * G k  _   A g < M # ;
07:20:57 <flyupth> W Z W ) G F U h  V B ~ b C Q > [   [ : _ 0 w Z <  F j | k A 5 [ &  ! k Q i  _  w   = R K x  p x  r W a 0 } E x &
07:20:58 <flyupth> D q v & } S ! l  I b Q ` l : . Z  i A ] : ) K H    M b ^ % _ Z X *  < & ^ Y h  " N  ` [ Y { o n \ =  J k r l k * ^ !
07:21:00 <flyupth> j p ^ : ] F  y  n 6 O L R [ M ]  _ $ ~ = ~ ! Y X   S B K _  H   * a # 0 { # I M  } ` , J d X  L  \ R   E K r o
07:21:01 <flyupth> z  s +  W i S  e E % S r & i l  t Y U J ( v C d  8 m } v m $ t M  , d " L % , E '  L 2 0 V  ~ d =  d & . m I ( 0 h
07:21:02 <flyupth> l ` W 5 C > H }  < g S }   D y k  W ) Z J w P ^ a  d  Y S . G D 5  _ V Z b 0 @ h |  ; I x G P $ n ]  o G P c ! < , d
07:21:03 <flyupth> p r 8 N V # O D  a n P t r ) * >  q + @ a  w @ =  | Y : u x Q d '  z r ] * K + \ q  _ ] F m } U & m  d ( O & % W B |
07:21:04 <flyupth> b n ` D ] W H &  Z % ! W s D m   t 3 w V $ j u R  % H N V d  o $  f | & @ + T L #  R , } P Q # J W  " Q   z > : J =
07:21:05 <flyupth> Y Y } r m S Z Q  U { X 6 I : U F   _ P z [ & r {  F K : r & y h I  H \ s , d s E %  Q v { i > _ F [  q D S , D J [ =
07:21:06 <flyupth> R U l ^ ( z t f  y 5 ? @ = H N f  L ; I   m g F  X U / : Y S Z .  Q F S A u ' . Z  a . % k i ! ? E  g g V @ ! , > .
07:21:07 <flyupth> + 3 G  c _ c P  K u e U [ ^ " g  : g M . 7 % v V  h ^ t < L $ s   /  b l E Z W )  { W f \ n S h 0  O w u I a  ; C
07:21:09 <flyupth> N C E ? ( Z  -  U c I i { ? { {  " t 0 Y ! O Y O  g k u Y K S c P  z ` 6 s ] G 8 (  C + m J E  c    } z $ w * ` .
07:21:09 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:21:10 <flyupth>  Q J ' W ^ 2 G  F h j c T V d R  { w  V r ~ m L  p L  K U _ 9   _ l T ^ ( . s r  3 P x = ] Z u w  > Z ! } , y E B
07:21:11 <flyupth> / 6 b 6 G | { %  X t " + < % 5 y  v X i S T . } G  h A . j - q ! &  ^ > i /  U  $  ( e p v    U o  ; h  / L ( ; Q
07:21:12 <flyupth> + F b ? , N C F  i " 8 q & r 9 n  O N t T k v . @  # g r $ s | Y x  & m [ H  ' 5 U  N M q G 3  P e    s f T F ( $
07:21:13 <flyupth> e } K T ! X ; 9  J K h 7 Z > G u  4 #  ? B x p *  A  d t 3 R p h  I / = H S Z c 5  Z r ]  & - C H  9 -  f O j P '
07:21:14 <flyupth> Z A + d Z } 9 a  0 c 6 Y w s 1 o   H q F S !  i  ? Q = X p t . z  & * D S ] O q e   ;   \ A ] 5 )  S v H : O   o &
07:21:15 <flyupth> F   K @ b ; H &  k S f  $ m G k  r  n : . _ p U  f a L n Y D m .  t S j J : m b *  ( S b | w K g   8 K Q L z , > /
07:21:16 <flyupth> { ] z X w @ R 7  Y + _    K R s  U l 3 . 0 ( - Y  \  # 8 c G C G  e ; a k - ' U x  } ; b j : a _ !  i  > H  m u -
07:21:17 <flyupth> S 7 b # } Y  ~  % [ C I n # z &  } G i G q E " "  @ j I [ < I > 7  g  : j B  i s  } C Z = B ' o y  K I 4 U v N K c
07:21:18 <flyupth> B ` > m t e K r  < j 3 y O ; - b  l | + y X 0 b n  [ ~ | d s  a     ( Z f D X 7 o   + O " T g N   '  L j < W ( x
07:21:19 <flyupth> p X ) d Z n - v  M I 9 P & n k a   i I j ? / n T  } > o n   a V R  k j { g < y K A  S ~ . z T z G s  / j $ m N u / ?
07:21:21 <flyupth> / G U : Y T < @  [ C  E ? = q _  x l   Z J m l  ( n G t % = ! A   7 ? @ e D f b  0 ? ^ " R U 1 F  v D f k b T D C
07:21:22 <flyupth> U \ U [ @   ~  . [ E B ) z r u  X B 0 P ; 9 0 ?  / j v K C N d X  t Y % g H W Y K  9 2 j ' 3 ; Q Y  C   7 U i H d
07:21:23 <flyupth> http://www.astronautica.com/stars.wrl
07:21:23 <flyupth> f s * G = B m :  - k ) e L , ` )  ] > ! I " + ' M  x L  a # $ 2 )    T o K T ( Z ?  : k V D , Q { z  [ / ` _ > P @ #
07:21:24 <flyupth> ( I H Z Z   z !  i     u ( F i  ! N G W  I y g  y z y ~ - Q T z  P ) h u v t E I  !    n V r J M  { c " N O ^ ( x
07:21:25 <flyupth> v . } "    U p  O ( U F y " w D  ? q ` k  j G =  v ^ % V . i A a  ( n ^ $ t + Q m  Y j ) ? m +  b  [ J # ] k : @ E
07:21:26 <flyupth> o o { ! ) / p '  4 ; X g G Z R   B a ]  Q i 4 ,  c S ! . M t u o  G ~ d P H < o l  T # ` u d w , 7  P o n V g 2 v
07:21:27 <flyupth> f k k y G y d k  ] v q * !  Q m  W ' k z * S ' l  ' [ T q ? S k M  G p X H , : W s  : s d ( / o h J   U ( h Z Q I M
07:21:28 <flyupth>  9 Y K V j y J  I B { B c > i %  % 2 W # I K ~ T  d w { ` A ~  f  u V r  2 w q :  H n w / q H 4 &  f g " G d P # r
07:21:29 <flyupth> \ 1 Y ,  (   u  X 7 o W ] ' !   = & v U I -  /  q 1 / + P Y   {  Z { i n O G g 9  & h B ( N n e ^  g t U n K  ,
07:21:30 <flyupth> + N b a ? #   G  9 ) x d b K h p  t # 9 J ] ] D <  G T P . > & E ;   }   i / l L   x   S ] * p  W a P g y 4 k [
07:21:31 <flyupth> +  c * } 4 _ @    ! d F J U l  d , # 5 > [ D   ) R / o R o : v  d A y ` z ` Y   { T N , ^ M < p  . _ M @ q o p
07:21:32 <flyupth> F d y  N < I x  %  P D & k D !  { f r R ( r # $  ) T p [ d & w H  + c n }   t w  9   t K t X "  i n q F  F ) X
07:21:33 <flyupth> ` c ; < V ` = W  5 S  1 z n m Z  \ ~ b V x / j !  b ' K E  ? ;   , f ; | d @ C Q  a u Z _ ` , ,   e J K N V ~   b
07:21:34 <flyupth> http://www.astronautica.com/stars.wrl
07:21:35 <flyupth> x $ {  i Q ] r  [ n ` } z y _ a  p _ p 4 | D _ B  < R K o [ a j   k m  - B c U F  B \ ` f G j  I  A ! p } 3 ) ) r
07:21:35 <flyupth> 6 I 5 > J * % \  c Q f ` j K n Z  b  T & I T h [  < < G U J u ' ,  Z I $ P 3 Z t \  P j @ ( o /  D  n 7 S { 8 Z M v
07:21:35 <kmc> this is the worst conceivable way to get help with using VRML
07:21:36 <flyupth>    AAA
07:21:36 <flyupth>    AAA
07:21:37 <flyupth>   AA AA   AAAAA    AAAA  AA AA AA   AAAA   AA AA
07:21:37 <flyupth>   AA AA   AA  AA  AA     AA AA AA  AA  AA  AAAAA
07:21:38 <flyupth>   AA AA   AA  AA  AAAA   AA AA AA  AAAAAA  AA
07:21:38 <flyupth>  AAAAAAA  AA  AA   AAAA  AA AA AA  AA      AA
07:21:39 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:21:39 <flyupth>  AA   AA  AA  AA     AA   AA  AA   AA   A  AA
07:21:40 <flyupth>  AA   AA  AA  AA  AAAA    AA  AA    AAAA   AA
07:21:41 <flyupth>                                                 
07:21:42 <flyupth>                      MM
07:21:44 <flyupth>                      MM
07:21:44 <luite> is it possible to ban flyupth, he's spamming #haskell
07:21:44 <flyupth>  MMMMM MMM    MMMM   MM
07:21:45 <flyupth>  MM  MM  MM  MM  MM  MM
07:21:46 <flyupth>  MM  MM  MM  MMMMMM  MM
07:21:47 <luite> oops
07:21:47 <flyupth>  MM  MM  MM  MM      MM
07:21:48 <flyupth>  MM  MM  MM  MM   M
07:21:49 <flyupth>  MM  MM  MM   MMMM   MM
07:22:04 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:22:09 <flyupth> http://www.astronautica.com/stars.wrl <-- what plugin can view it?
07:22:11 <flyupth>    AAA
07:22:12 <flyupth>    AAA
07:22:13 <flyupth>   AA AA   AAAAA    AAAA  AA AA AA   AAAA   AA AA
07:22:14 <flyupth>   AA AA   AA  AA  AA     AA AA AA  AA  AA  AAAAA
07:22:15 <flyupth>   AA AA   AA  AA  AAAA   AA AA AA  AAAAAA  AA
07:22:15 <flyupth>  AAAAAAA  AA  AA   AAAA  AA AA AA  AA      AA
07:22:17 <flyupth>  AA   AA  AA  AA     AA   AA  AA   AA   A  AA
07:22:18 <flyupth>  AA   AA  AA  AA  AAAA    AA  AA    AAAA   AA
07:22:18 <flyupth>                                                 
07:22:19 <ccasin> @where ops
07:22:20 <flyupth>                      MM
07:22:20 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:22:21 <flyupth>                      MM
07:22:21 <kmc> no ops around?
07:22:22 <flyupth>  MMMMM MMM    MMMM   MM
07:22:22 <Jeanne-Kamikaze> umad ?
07:22:22 <flyupth>  MM  MM  MM  MM  MM  MM
07:22:23 <flyupth>  MM  MM  MM  MMMMMM  MM
07:22:25 <flyupth>  MM  MM  MM  MM      MM
07:22:25 <kmc> flyupth, please stop
07:22:26 <flyupth>  MM  MM  MM  MM   M
07:22:26 <flyupth>  MM  MM  MM   MMMM   MM
07:22:29 <flyupth>    AAA
07:22:30 <flyupth>    AAA
07:22:31 <flyupth>   AA AA   AAAAA    AAAA  AA AA AA   AAAA   AA AA
07:22:32 --- mode: ChanServ set +o Igloo
07:22:32 <flyupth>   AA AA   AA  AA  AA     AA AA AA  AA  AA  AAAAA
07:22:41 <geheimdienst> finally. thanks a lot igloo
07:22:50 <kmc> ah nice a k-line
07:23:18 <dylukes> :)
07:23:22 <ziman> phew, that was insane :)
07:23:43 <Jeanne-Kamikaze> the planet looked pretty nice though
07:23:43 <kmc> i thought I had seen some bad question-asking tactics
07:23:47 <kmc> but that's the worst one yet
07:23:50 <mattp_> haha
07:23:51 <Jeanne-Kamikaze> xD
07:23:59 <mattp_> well he got an answer
07:23:59 * musically_ut thought that was kinda cute.
07:24:03 <dylukes> hey so kmc
07:24:08 <kmc> hey so dylukes
07:24:10 <dylukes> how can I do colouring and pandoc?
07:24:12 <kmc> why you so dylukes
07:24:17 <dylukes> pandoc markdown+lhc -> html works nicely.
07:24:21 <dylukes> But I'm not sure how to have colour :<
07:24:34 <kmc> did you build pandoc with -fhighlighting
07:24:53 <dylukes> I don't think so :<
07:24:58 <dylukes> i just cabal installed.
07:25:22 <kmc> dylukes, I did warn you about this :D
07:25:26 <dylukes> >_<
07:25:29 <kmc> dylukes, cabal install --reinstall pandoc -fhighlighting
07:25:35 <kmc> might work
07:25:57 <geheimdienst> absence: regarding your paste, the big picture is that you wanted a function that, given p1 and p2, checks if a list contains the subsequence [p1,p2] or [p2,p1]. right?
07:26:03 <dylukes> seems to be, it's installing pcre now.
07:26:12 <geheimdienst> > [2,3] `isInfixOf` [1..5]
07:26:14 <lambdabot>   True
07:26:32 <dylukes> [  1 of 112] Compiling Paths_highlighting_kate ( dist/build/autogen/Paths_highlighting_kate.hs, dist/build/Paths_highlighting_kate.o )
07:26:34 <dylukes> oh lord. Here we go.
07:26:46 <byorgey> yes, compiling highlighting-kate takes a while =)
07:26:55 <luite> yeah that one takes a few weeks to compile ;0
07:26:55 <dylukes> Ada, Ansys, Apache, Asp, Awk, Bash, bibtex, Boo, Cmake...
07:26:56 <geheimdienst> ^^ you could also use that (from Data.List). i think it conveys your intent more directly if you say [p1,p2] `isInfixOf` h || [p2,1] `isInfixOf` h
07:26:59 <dylukes> highlight ALL the things.
07:27:02 <dylukes> 22/112
07:27:04 <dylukes> It's chugging along well.
07:29:33 <dylukes> hngh
07:29:37 <dylukes> kmc's focaccia makes me jelly.
07:30:14 <absence> geheimdienst: you're right
07:30:26 <kmc> focaccia?
07:31:19 <tensorpudding> talking about focaccia again?
07:31:28 <dylukes> Oh god the hunger.
07:31:31 <dylukes> It burns.
07:31:58 <tensorpudding> it was copumpkin who posted focaccia pictures on -blah yesterday
07:32:02 <kmc> i have no idea what you're talking about
07:32:38 <dylukes> yay kate's done.
07:32:41 <dylukes> recompling pandoc.
07:35:56 <absence> geheimdienst: thanks :)
07:36:17 <geheimdienst> absence, you're welcome
07:36:39 <rotflcopter> yeah :)
07:36:59 <rotflcopter> let sqr f=f*f;doc r xy=sqrt((sqr(r))-(sqr(xy)));cir r =[ (round xy,round (doc r xy)) | xy <- [0.0,1.0 .. r]]
07:37:06 <rotflcopter> cir 11.0
07:37:08 * hackagebot snaplet-hdbc 0.6.2 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.2 (JurrienStutterheim)
07:37:13 <rotflcopter> http://en.wikipedia.org/wiki/Midpoint_circle_algorithm
07:37:15 <rotflcopter> :)
07:38:27 <dylukes> kmc: https://github.com/jgm/highlighting-kate/blob/master/css/hk-tango.css
07:38:28 <dylukes> :D
07:38:34 <dylukes> tango premade for me. excellent.
07:38:54 <dylukes> whether I agree with the colors however...
07:38:58 <kmc> cool
07:39:08 <dylukes> So, are you able to put multiple languages in one document?
07:39:18 <dylukes> Like, can you put a C fragment within the markdown of the lhs?
07:39:23 <kmc> i just copied the stylesheet that pandoc produces with --standalone
07:39:24 <kmc> dylukes, yes
07:39:26 <dylukes> As if it where gfmkd?
07:39:42 <kmc> mmm yes where gfmkd uonc.uh qenutoeunt eounth very much so
07:39:56 <dylukes> what
07:40:06 <kmc> i've no idea what "As if it where gfmkd" means
07:40:25 <kmc> you can start a code block with
07:40:27 <kmc> ~~~~ {.perl}
07:40:34 <kmc> and it will highlight as perl until the next line with ~~~~
07:40:47 <kmc> telling Markdown your document is .lhs just gives you a special syntax for ~~~~ {.haskell}
07:41:02 <kmc> btw, markdown ordinarily uses > at beginning of line to be block quotes
07:41:10 <kmc> if you need that within lhs, put a space before >
07:41:21 <kmc> also you can do lhs inside other elements like list items :D
07:41:42 <kmc> my most recent post has that, as well as both C and Haskell highlighting
07:41:47 <dylukes> excellent.
07:41:55 <dylukes> I'll need to re-setup highlighting.
07:42:07 <kmc> the terminal prompt / command highlighting, I do with a wretched little regex
07:42:10 <kmc> and it doesn't totally work
07:42:11 <dylukes> I'll just move my current hscolour highlighting into the blog post itself, then move my "general" one to the theme-editing.
07:42:14 <kmc> I should use real xml tools
07:42:30 <kmc> or patch pandoc / highlighting-kate
07:42:58 <kmc> dylukes, occasionally I do one-off fixes to the HTML (like making "atomically" a keyword in that Fantasy C pseudocode)
07:43:07 <kmc> dylukes, best to do those at the end, but you can sometimes re-apply them with patch / diff
07:43:18 <dylukes> mm
07:43:49 <ClockFrog> on say "read" function what does the 'Read a =>'  bit mean?
07:44:02 <kmc> the type 'a' is required to be a member of the Read type class
07:44:08 <kmc> it's a constraint
07:47:40 <kmc> i wonder if ghc -threaded and/or +RTS -N will ever become the default
07:49:50 <wyfrn> hi all ... would anybody take a look on the following short code snippet: http://hpaste.org/53393 ? i'm trying to translate the code to "binder style" but my attempt don't work
07:52:35 <byorgey> wyfrn: I think you're trying to do too much at once.
07:52:52 <byorgey> wyfrn: just translate  x <- foo   to  foo >>= \x -> ...
07:53:03 <byorgey> and  foo  to   foo >> ...
07:53:21 <rotflcopter> why do i need to do ' in cir 11' instead of ';cir 11' at line end if i paste the function before?
07:54:25 <byorgey> wyfrn: so start out  get >>= \input -> let input' = ... in ...
07:54:37 <byorgey> wyfrn: once you've done that you can simplify it etc.
07:57:17 <wyfrn> byorgey: thx ... i think the problem is that i don't understand the guard function. If the predicate is wrong, it returns mzero what is Nothing in the Maybe Monad ... but if the predicate is true, how can unit be transleted to a Just value ?
07:58:39 <byorgey> wyfrn: if the predicate is true, guard returns unit. period. that allows the computation to continue.  at that point you probably want to continue with some value from a previous computation.
07:58:43 <mokus> @src guard
07:58:44 <lambdabot> guard True  =  return ()
07:58:44 <lambdabot> guard False =  mzero
07:59:00 <byorgey> wyfrn: for example:  do x <- foo; guard (x > 3); blah x
07:59:08 <byorgey> notice how I reused x after the guard
07:59:33 <byorgey> that would translate to  foo >>= \x -> guard (x > 3) >> blah x
08:00:15 <wyfrn> but isn't that a type mismatch: Maybe String vs Maybe () ?
08:00:39 <byorgey> wyfrn: no, look at the type of (>>)
08:00:42 <byorgey> @type (>>)
08:00:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:00:54 <byorgey> it ignores the return type of the first computation.
08:02:06 <ClockFrog> does head remove the first element or just copy it?
08:02:10 <byorgey> wyfrn: in other words, you do 'guard' just for its *effect* (of failing or not), but ignore the value it returns
08:02:34 <byorgey> ClockFrog: functions can never modify their arguments in Haskell.
08:02:43 <ClockFrog> oh
08:03:09 <byorgey> ClockFrog: the correct way to say it is that "head xs evaluates to the first element of the list xs".
08:03:19 <byorgey> whether there is any copying involved or not depends on the implementation.
08:03:40 <wyfrn> ahh i think i got it: get >>= dropWhile . isSpace >>= \inp -> guard . not null >> StateT $ \_ -> return (inp,inp)
08:04:04 <Nibble> dripWhile . isHot
08:04:46 <byorgey> wyfrn: that's closer, but dropWhile . isSpace is not a StateT computation
08:04:52 <ClockFrog> i was wondering if i could use it to parse through a list, recursively calling my function to move through the list. Would that work?
08:04:59 <byorgey> wyfrn: there's a reason you needed the 'let' in the do-version
08:04:59 <wyfrn> oh ... a return is missing
08:05:09 <byorgey> yes, you could add a return or use 'let'
08:05:16 <byorgey> wyfrn: also I think you want   guard . not . null
08:05:47 <Nibble> drop it's like it's hot
08:05:53 <Nibble> listen to snoop
08:06:02 <Nibble> he's got them magic mushrooms
08:06:09 <byorgey> ClockFrog: you would have to use 'tail' to pass the list without the head element to the recursive call.
08:06:16 <byorgey> ClockFrog: however, you shouldn't.
08:06:21 <byorgey> ClockFrog: instead, use pattern matching.
08:06:33 <byorgey> myRecursiveFunction [] = ...;  myRecursiveFunction (h:t) = ...
08:06:56 <Phlogistique> hi
08:07:22 <byorgey> ClockFrog: that says what to do for the empty list, and what to do with a non-empty list where the head is called 'h' and the tail is called 't'
08:07:23 <Phlogistique> are there equivalents to ruby/perl -ne/-pe switches?
08:07:33 <byorgey> ClockFrog: presumably you can call myRecursiveFunction recursively on t
08:07:41 <byorgey> Phlogistique: what do those do?
08:08:01 <ClockFrog> ok cheers i think i know how im going to do it
08:08:38 <wyfrn> byorgey: thx for the explanation
08:08:51 <Phlogistique> byorgey: wrap your code in a loop where a line is read before the code, and printed afterwards
08:08:54 <Phlogistique> like
08:08:57 <Phlogistique> main = interact $ \t -> unlines $ map ( =~ "(?<=\\().+?(?=\\))" ) $ lines t
08:09:24 <Phlogistique> something that would allow me to do runhaskell -pe '=~ "(?<=\\().+?(?=\\))"'
08:09:32 <Phlogistique> and get the same result as the above program
08:10:12 <rotflcopter> how can i do this?
08:10:15 <rotflcopter> let a1=[(10,0),(0,10)];am (a,b) = (a,b),(-a,-b)
08:11:58 <byorgey> Phlogistique: I recently saw a package someone created to do stuff very similar to that, but I'm having trouble finding it
08:19:28 <rotflcopter> let a1=[(10,0),(0,10)];am [(a,b)] = (-a,-b):[(-a,-b)] in am a1
08:19:28 <rotflcopter> *** Exception: <interactive>:1:24-53: Non-exhaustive patterns in function am
08:19:29 <rotflcopter> :(
08:21:33 <Phlogistique> rotflcopter: hum, let a1 = [(10,0),(0,10)]; am [] = []; am (a,b):x = (a,b):(-a,-b):x in am a1
08:21:38 <Phlogistique> is that what you want to do?
08:22:08 * hackagebot snaplet-hdbc 0.6.2.1 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.2.1 (JurrienStutterheim)
08:22:11 <roconnor> rotflcopter: am only accepts lists of length 1, but a1 is a list of length 2
08:23:50 <mysticc> @hoogle String -> ByteString
08:23:50 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:23:50 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
08:23:50 <lambdabot> Prelude read :: Read a => String -> a
08:26:35 <rotflcopter> let a1 = [(10,0),(0,10)]; am ax = [ (-xa,-xb):ax | (xa,xb) <- ax] in am a1
08:26:42 <rotflcopter> but this still not good
08:27:46 <rotflcopter> it creates arays in arrays to me ;<
08:28:29 <rotflcopter> let a1 = [(10,0),(0,10)]; am ax = [ (-xa,-xb) | (xa,xb) <- ax]:[ax] in am a1
08:28:30 <Phlogistique> https://github.com/tanakh/hoe#readme looks like what I was searching for (cc byorgey
08:29:16 <Phlogistique> I'm curious why anyone would do 'String->ByteString'. It
08:29:29 <Phlogistique> To me it sounds like an "untype" transformation
08:30:12 <mm_freak> list comprehensions would have /some/ value over combinators, if they could also act like concatMap
08:30:19 <Phlogistique> roflwhat are you trying to do?
08:30:29 <mm_freak> [ x+1, x-1 | x <- [10, 20, 30] ]
08:30:31 <rotflcopter> let a1 = [(10,0),(0,10)]; am ax = [ (-xa,-xb) | (xa,xb) <- ax]:[ax] in am a1
08:30:37 <Phlogistique> rotflcopter: what are you trying to do?
08:30:46 <rotflcopter> i'd like to make [(-10,0),(0,-10),(10,0),(0,10)]
08:31:00 <Phlogistique> in this order?
08:31:20 <rotflcopter> no, just without the nested arrays
08:31:55 <Ornedan> Is it normal that GHCI takes over 3GB of memory when I do "let foo <- readFile "50MB-sized-file"; length foo"?
08:31:57 <mm_freak> > concat [ [(x, 0), (0, x)] | x <- [-10, 10] ]
08:31:58 <lambdabot>   [(-10,0),(0,-10),(10,0),(0,10)]
08:32:13 <Phlogistique> rotflcopter: let a1 = [(10,0),(0,10)]; am [] = []; am ((a,b):x) = (a,b):(-a,-b):(am x) in am a1
08:32:49 <mm_freak> > concatMap (\x -> [(x, 0), (0, x)]) [-10, 10]
08:32:50 <lambdabot>   [(-10,0),(0,-10),(10,0),(0,10)]
08:32:51 <mm_freak> nicer
08:32:52 <rotflcopter> thanks <;
08:32:59 <jimmyrcom> Ornedan http://www.haskell.org/haskellwiki/Wc
08:33:30 <ClaudiusMaximus> Ornedan: ghci ends up keeping the whole String in memory in case you might use foo again later
08:33:33 <Phlogistique> mm_freak: I think your heuristics to generalize rotflcopter's question to a program failes
08:33:36 <Phlogistique> *failed
08:34:00 <Phlogistique> he was not asking specifically for "10", but for adding opposites of a pair in a list
08:34:37 <rotflcopter> yeah its logic function
08:36:11 <mm_freak> :t concatMap (\x -> [(x, 0), (0, x)]) . map (\x -> [-x, x])
08:36:12 <lambdabot> forall a. (Num [a], Num a) => [a] -> [([a], [a])]
08:36:19 <mm_freak> uh, no
08:36:25 <mm_freak> :t concatMap (\x -> [(x, 0), (0, x)]) . concatMap (\x -> [-x, x])
08:36:26 <lambdabot> forall a. (Num a) => [a] -> [(a, a)]
08:36:27 <mm_freak> there
08:36:56 <mm_freak> not sure i understood it now, though
08:38:36 <Ornedan> ClaudiusMaximus: Ok, but 3GB is still kind of a lot for it
08:41:14 <ClaudiusMaximus> Ornedan: String has a large overhead, being a linked list of boxed unicode code points.  perhaps Text would be more memory efficient? (or ByteString if you really have binary data)
08:41:23 <erus`> has anyone experimented with rendering haskell source code as a graph/flow chart type thing?
08:42:52 <Phlogistique> ClaudiusMaximus: this sounds insane to me. Why is it that String having the semantic interface of a linked list of boxed unicode code points prevents its memory representation to be a simple buffer?
08:43:05 <Phlogistique> It looks insane to me that to
08:43:32 <Phlogistique> get reasonable performance, you have to give up with the strong typing and use a ByteString
08:43:35 <ClaudiusMaximus> compilers are not yet sufficiently magical :(
08:44:02 <Phlogistique> they ought to be. Maybe I should try diving in GHC
08:44:06 <ClaudiusMaximus> there's Text
08:44:11 <Phlogistique> but it does not sound like an easy project
08:44:11 <mm_freak> Phlogistique: what's less strongly typed about ByteString?
08:44:25 <mm_freak> ByteString corresponds to [Char] or [Word8] depending on the interface
08:45:00 <Phlogistique> mm_freak: ...I'm not sure about ByteString, actually, I took it at face value before looking into it
08:45:21 <Phlogistique> I'll look into it and come back rant some more if I wasn't wrong :D
08:45:34 <mm_freak> well, ByteString is essentially a tightly packed, strict [Char]
08:45:37 <mm_freak> no
08:45:40 <mm_freak> rather a [Word8]
08:46:18 <mm_freak> and it also has some semantic differences:  you have O(1) length, O(1) indexing, etc.
08:46:50 <Phlogistique> is this semantic?
08:47:02 <mm_freak> slightly =)
08:47:09 <Phlogistique> anyway, the point is if I'm using a byte string
08:47:22 <Phlogistique> I'll use it to store data which is actually encoded
08:47:29 <Phlogistique> (prolly in UTF-8)
08:47:46 <shlevy> @hoogle [[a]] -> [a]
08:47:46 <lambdabot> Prelude concat :: [[a]] -> [a]
08:47:46 <lambdabot> Data.List concat :: [[a]] -> [a]
08:47:47 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
08:47:55 <Phlogistique> so strong typing should prevent any use of data as something else than utf-8
08:47:59 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html
08:48:01 * shlevy always wants it to be called flatten
08:48:10 <shlevy> @hoogle flatten
08:48:10 <lambdabot> Data.Tree flatten :: Tree a -> [a]
08:48:10 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
08:48:10 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
08:48:13 <shlevy> Aah
08:48:28 <Phlogistique> ByteString is only strongly typed if semantically, you are really dealing with a binary buffer, not text
08:48:46 <shlevy> :t concatMap
08:48:46 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:48:52 <shlevy> :t concat . map
08:48:53 <lambdabot>     Couldn't match expected type `[[a]]'
08:48:53 <lambdabot>            against inferred type `[a1] -> [b]'
08:48:53 <lambdabot>     Probable cause: `map' is applied to too few arguments
08:49:26 <norm2782> is there anyone with HDBC SQLite experience here? I'm getting SqlError {seState = "", seNativeError = 5, seErrorMsg = "step: database is locked"}
08:49:31 <Phlogistique> ClaudiusMaximus: thanks for the link
08:49:44 <hpc> :t concat .: map -- shlevy
08:49:44 <mm_freak> Phlogistique: really?  i wouldn't use ByteString for that, but rather Text
08:49:45 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
08:49:56 <Phlogistique> now why would anyone ever need String instead of Text, and why isn't Text the default?
08:50:09 <hpc> (f .: g) x y = f (g x y)
08:50:13 <Phlogistique> mm_freak: indeed
08:50:32 <mm_freak> Phlogistique: String is easy to explain to beginners, while Text is somewhat more involved
08:50:55 <hpc> mm_freak: Text should still be easy
08:50:57 <shlevy> hpc: Thanks. Some day I'll actually remember that
08:51:17 <hpc> mm_freak: you just have to teach it the java way, of "String is a black box until you know enough to read the source yourself"
08:51:20 <mm_freak> Text doesn't have the same properties as a list
08:51:36 <mm_freak> i think the default is fine, because String is fine for storing /some/ texts
08:52:06 <hpc> String is fantastic for text that you will only ever read in the one direction
08:52:26 <mm_freak> hpc: i like how you can approach String just before or after generic lists and say:  "this is just the same, because a string is just a list of characters"
08:52:30 <Phlogistique> hpc: that's a terribly specific use for a default class
08:52:47 <mm_freak> also there /one/ good reason for String over Text:  if you process character by character
08:53:00 <shlevy> Plogistique: Really? How often do you scan strings back and forth?
08:53:19 <shlevy> Phlogistique: My default is definitely read-once
08:53:21 <hpc> Phlogistique: default type, not class; "class" has a very specific meaning in haskell
08:53:40 <hpc> also String interacts nicely with stream fusion
08:54:10 <Phlogistique> hpc: yes, sorry
08:54:58 <geheimdienst> do i have this right -- what you can do with phantom types is a subset of what you can do with GADTs?
08:55:12 <hpc> geheimdienst: yes
08:55:16 <geheimdienst> thanks
08:55:37 <hpc> geheimdienst: specifically, GADTs let you use constructors instead of smart constructors
08:56:10 <hpc> so instead of foo :: Foo Int, it's data Foo a where Foo :: Foo Int
08:56:48 <Phlogistique> (on a side note: I wish the guys who designed Ruby 1.9 strings handling used Haskell. It is horrible to use in Ruby because you have to keep in ming the encoding of every single string whenever you use it, or your program will horribly crash at runtime depending on its input. The same system would have been wonderful with static typing)
08:56:59 <geheimdienst> yeah. it's shorter if you can ditch all those functions, and it's nicer to think about when there's no intermediate form
08:57:02 <atomicity> Ok... I have a problem reconciling the following. I'm writing a function f a b c d = (a + b)/(c + d). The only requirement I have is that the result is a double (so that the last division is carried out on doubles). How can I write such a function that will correctly coerce any numerical argument?
08:57:08 * hackagebot snaplet-hdbc 0.6.2.2 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.6.2.2 (JurrienStutterheim)
08:57:37 <hpc> atomicity: f a' b' c' d' = (a + b) / (c + d) where a = somesortofacast a'...
08:58:02 <atomicity> hpc: but casts are of the form 'fromWhatever', not 'toWhatever'
08:58:13 <hpc> :t fromIntegral
08:58:13 <lambdabot> forall a b. (Integral a, Num b) => a -> b
08:58:15 <atomicity> that means I probably need to know the types of arguments
08:58:16 <hpc> :t realToFrac
08:58:17 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
08:58:24 <hpc> > realToFrac 1.5 :: Double
08:58:25 <lambdabot>   1.5
08:58:26 <atomicity> hpc it may not be integral
08:58:32 <hpc> use realToFrac, i think
08:58:34 <atomicity> it may be however
08:58:41 <atomicity> realToFrac 5 :: Int
08:58:53 <atomicity> > realToFrac (5 :: Int)
08:58:54 <lambdabot>   5.0
08:59:00 <atomicity> hm..., nice
08:59:22 <atomicity> thanks hpc
08:59:41 <hpc> you should probably check the standard library to make sure the instances of Real are what you want
08:59:51 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Real
09:02:39 <atomicity> hpc, yay, it works :)
09:03:10 <KirinDave> I am so pleased after reading http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
09:03:15 <KirinDave> Great article.
09:03:38 <KirinDave> Dunno if the author is in here so I can slowclap
09:03:38 <hpc> KirinDave: i know, right? i independently came up with something similar for doing really long idle actions in gtk
09:03:56 <hpc> i just never made the connection of using ContT
09:04:21 <KirinDave> hpc: The thing is, it is intimidating but also very obvious once you walk through it.
09:04:58 <KirinDave> I've been avoiding ContT as "too complex". I did scheme and kinda just threw my hands up in the air at the prospect of using continuations; the code it generates is seldom maintainable.
09:05:07 <KirinDave> But this is a great use for continuations that is also clean
09:05:17 <KirinDave> And beautiful rendered via the do notation, to boot
09:05:56 <hpc> KirinDave: as soon as you start writing functions somethingWith :: m a -> m a
09:06:10 <hpc> KirinDave: you've basically learned to use ContT
09:06:27 <KirinDave> Well I have not and that seems a little confusing but okay. :D
09:06:34 <KirinDave> Actually I think I know how that'd be shaped.
09:06:45 <KirinDave> Yeah, nvm
09:06:52 <KirinDave> Considering it, that seems striaghtforward.
09:07:21 <hpc> an example of a function like that would be paragraph inside = putStrLn "<p>" >> inside >> putStrLn "</p>"
09:07:41 <KirinDave> Yeah
09:08:13 <hpc> congrats, you are now a member of the "understands continuations" club
09:08:14 <aristid> Monad m => m a is isomorphic to Cont a, i think dan piponi proved that too
09:08:29 <hpc> we're even more exclusive than the "understands monads" club
09:08:51 <hpc> aristid: yeah, i think that's a trivial consequence of the Mother of all Monads post
09:08:55 <KirinDave> I got my continuations merit badge
09:08:58 <KirinDave> And also
09:09:02 <KirinDave> I have my iteratees badge.
09:09:09 <hpc> KirinDave: ooh, i need to get that one
09:09:20 <KirinDave> If I can finish wiring up enumerator to the monadic zipper stuff in monadatron
09:09:34 <KirinDave> Then I will have a "actually wants to write reusable components in haskell" merit badge.
09:09:40 <KirinDave> That one is brass, did you hear?
09:11:14 <Philonous_> hpc:  Isn't there some old adage "If you think you understand continuations, you don't understand continuations"?
09:11:36 <hpc> Philonous_: i think the first rule of continuations is do not reify the remaining computation
09:12:10 <Philonous_> But I want to store it in a database!
09:12:10 <aristid> hpc: doesn't callCC do that?
09:12:43 <hpc> (*whoosh* goes the fight club joke)
09:13:19 <mm_freak> is there a transformer version of Kleisli somewhere?
09:13:42 <hpc> mm_freak: what would the type be?
09:13:48 <aristid> mm_freak: Kleisli automatically works on transformers, no?
09:13:49 <mm_freak> newtype KleisliT m (>~) a b = Kleisli (a >~ m b)
09:14:06 <hpc> ooooh
09:14:10 <Phlogistique> hi
09:14:11 <Phlogistique> http://pastebin.com/i7EZdDZZ
09:14:13 <mauke> The paste i7EZdDZZ has been copied to http://hpaste.org/53399
09:14:13 <hpc> no, there's not
09:14:19 <cicatristeza> i downloaded the source for snap-wesbite from here: http://github.com/snapframework/snap-website
09:14:32 <cicatristeza> when i do "cabal install" it tells me:
09:14:55 <mm_freak> hmm, the arrows library doesn't define one…  bad
09:15:08 <hpc> arrows has arrow transformers?
09:15:12 <cicatristeza> cabal: cannot configure snap-website-0.3. It requires snap-static-pages >=0.1
09:15:13 <cicatristeza> && <1.0
09:15:20 <cicatristeza> There is no available version of snap-static-pages that satisfies >=0.1 &&
09:15:21 <cicatristeza> <1.0
09:15:21 <cicatristeza>  
09:15:25 <mm_freak> hpc: yes
09:15:27 <erus`> which way are triangles drawn? is front face anticlockwise?
09:15:34 <mm_freak> hpc: in fact it has only transformers
09:15:36 <cicatristeza> how do i install snap-static-pages?
09:16:13 <mm_freak> aristid: arrow transformer version i mean, not monad transformer
09:16:36 <hpc> erus`: iirc, front face clockwise
09:16:51 <erus`> hmm opengl default is ccw
09:16:57 <erus`> why is there no standard
09:17:31 <mm_freak> erus`: it helps to think about the trigonometric functions
09:17:33 <mm_freak> they all work CCW
09:18:00 <mm_freak> that extends to rotation matrices, with which OpenGL works
09:20:03 <erus`> ok
09:20:47 <cicatristeza> anyone? how do i install snap-static-pages?
09:21:35 <hpc> cicatristeza: i don't see it anywhere on hackage
09:22:25 <cicatristeza> hpc: could you try running this please: http://github.com/snapframework/snap-website
09:22:41 <cicatristeza> and tell me if you get it running succesfully
09:24:11 <hpc> i would have to fight with my router to get it to work, i think
09:24:26 <cicatristeza> alright
09:24:29 * hpc is on campus atm, and so not in a position to configure his server that way
09:25:47 <erus`> is there an eclipsefp channel?
09:30:26 <hpaste> “Lev Broido” pasted “Loops in graph” at http://hpaste.org/53400
09:35:53 <RaptorRarr> on join spammer: (11:40.47) (dvorak_) What's the best VRML/X3D plugin for Linux/Windows? I need it to view the worlds linked from http://www.astronautica.com/owds.html Octaga, BS Contact and Cosmo Player don't work.
09:39:22 --- mode: ChanServ set +o monochrom
09:39:31 --- mode: monochrom set +b *!*@pool-173-67-166-199.hrbgpa.east.verizon.net
09:39:31 --- kick: dvorak_ was kicked by monochrom (dvorak_)
09:39:48 --- mode: monochrom set -o monochrom
09:40:37 <geheimdienst> thanks monochrom, that guy was in here earlier today
09:40:46 <RaptorRarr> Thanks :{
09:40:49 <RaptorRarr> :)
09:40:56 <petekaz`> LYOH is great! I've just finished the applicative functor chapter, so enlightening.
09:41:57 <petekaz`> (from a newbie's perspective)
09:42:28 <petekaz`> I meant Learn you a Haskell ...
09:43:21 <geheimdienst> @tell BONUS "LYAH is great! I've just finished the applicative functor chapter, so enlightening. (from a newbie's perspective)"
09:43:22 <lambdabot> Consider it noted.
09:43:29 <geheimdienst> petekaz`: there you go :)
09:44:04 <hpc> preflex: seen bonus
09:44:04 <preflex>  bonus was last seen on #haskell 184 days, 21 hours, 21 minutes and 54 seconds ago, saying: yeah i think that's better as well
09:44:12 <atomicity> hpc, yay, it works :)
09:44:25 <atomicity> damn, wrong buffer to hit up and enter in, sorry.
09:44:34 <hpc> heh
09:44:44 <hpaste> Phlogistique pasted “cabal install hoe” at http://hpaste.org/53401
09:44:57 <Phlogistique> I get this when trying to build hoe
09:44:59 <Phlogistique> any idea?
09:50:41 <hpaste> geheimdienst pasted “Gadt the hell?” at http://hpaste.org/53402
09:51:15 <geheimdienst> so i'm now using strange new witchcraft called GADTs. they give me a lot of errors, several of them concerning "rigid type variables". i have tried sprinkling "forall" over the code, but no luck. any help is greatly appreciated
09:52:11 <byorgey> geheimdienst: the type signature of f claims that it can take an arbitrarily-tagged Entry and turn it into an Entry with any *other* arbitrary tag
09:52:32 <byorgey> geheimdienst: that is obviously impossible.
09:53:03 <geheimdienst> i see, interesting. what i meant of course was *some* sort of Entry, not *any*
09:53:44 <byorgey> geheimdienst: the type of Directory is strange too
09:54:07 <byorgey> it says that a Directory contains a FileStat and a Map from Strings to Eio entries which are *all the same type*
09:54:18 <byorgey> but once you have a directory you cannot tell what type they are.
09:54:47 <geheimdienst> okay, so i'll shove a "forall b" into the type of Directory
09:54:50 <dylex> geheimdienst: By using GADTs, you're essentially saying that Entry x and Entry y are not interchangable types.  I'm not quite sure why you want GADTs here and not just data Entry = File .. | ..
09:55:03 <mm_freak> geheimdienst: a common error is to write something like this:  MyConstructor :: a -> MyType
09:55:05 <Eduard_Munteanu> The forall is already there.
09:55:18 <byorgey> geheimdienst: yeah, you will need to existentially quantify everywhere... in which case you're basically giving up the whole point of having a GADT in the first place.
09:55:25 <mm_freak> this is an existential type, unless you mention the type variable 'a' as an argument to MyType
09:55:48 <mm_freak> but i haven't read your code, just wanted to add that =)
09:55:55 <byorgey> geheimdienst: what you're doing doesn't seem like this is a particularly good match for GADTs
09:56:14 <geheimdienst> dylex: i was in here earlier and pasted this http://hpaste.org/53388 . basically, i had a "data = File | Dir ..." earlier and was a little unhappy, and people in here advised me to try GADTs
09:57:04 <geheimdienst> Eduard_Munteanu: this seems to contradict byorgey ...? "you will need to existentially quantify everywhere"
09:57:40 <tgeeky> he didn't existetentially qualify that statement, so it's just a guideline
09:57:58 <Eduard_Munteanu> data Foo = forall a. [...] is different from data Foo where Bar :: forall a. [...]
09:58:02 <geheimdienst> byorgey: about your earlier criticism of f, how do i express "some sort of Entry"? it's of course a mistake i told ghc "any sort of Entry"
09:58:20 <byorgey> geheimdienst: data SomeEntry = forall a. SomeEntry (Entry a)
09:58:27 <Nibble> It should have been "An entry of any sort"
09:58:40 <byorgey> geheimdienst: however, that is completely useless, because once you have a SomeEntry you can never use it
09:58:43 <Eduard_Munteanu> In your case,  Directory :: forall b. F.FileStat -> Map String (Eio (Entry b)) -> Entry Directory
09:59:31 <Eduard_Munteanu> But that's different from having 'b' existentially quantified in the datatype
09:59:39 <Nibble> Eduard_Munteanu: yeah
09:59:49 <Nibble> that's why it doesn't work
10:00:02 <geheimdienst> byorgey: thanks for the information so far :)
10:00:02 <dylex> geheimdienst: It comes down to the fact that you need to know the type of entries in a directory at runtime, not compile time, so you need a runtime indication of their types (i.e., a constructor).
10:00:04 <byorgey> geheimdienst: what were you hoping to accomplish by using GADTs?
10:00:30 <yitz> geheimdienst: what's wrong with having a single dispatch function that says what to do in each case - raise an error if dir, get contents if file, etc.?
10:00:42 <dylex> geheimdienst: If you additionally want a type that represents "only directories" that you can check at compile time, you need levels of representation, tagged and untagged.
10:00:44 <geheimdienst> byorgey: the underlying problem is http://hpaste.org/53388 . when i asked earlier today, people advised me to try GADTs
10:01:03 <copumpkin> GADTs are always the answer
10:01:19 <yitz> copumpkin: we need to modify @faq
10:01:36 <geheimdienst> copumpkin: i see. great. like 42. now all we need is a matching question
10:01:37 <copumpkin> @where+ answer The answer is GADTs!
10:01:38 <lambdabot> Done.
10:01:41 <copumpkin> @where answer
10:01:42 <lambdabot> The answer is GADTs!
10:01:51 <yitz> copumpkin: oh, good idea. thanks!
10:02:05 <copumpkin> :)
10:02:23 <Tyr42> @pl \f g xs -> map f (map g xs)
10:02:24 <lambdabot> (. map) . (.) . map
10:02:25 <byorgey> geheimdienst: hmm, I don't actually agree that GADTs are a good solution to this problem.
10:02:47 <hpc> :t \f -> map f .: map
10:02:48 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> [a1] -> [b]
10:02:50 <Tyr42> @pl \f g xs -> map (f . g) xs
10:02:51 <lambdabot> (map .) . (.)
10:02:54 <byorgey> geheimdienst: instead I think you would have to use a "data types a la carte" sort of approach.  But it seems a bit heavyweight for this.
10:03:02 <hpc> :t (.) `on` map
10:03:03 <lambdabot> forall b. (b -> b) -> (b -> b) -> [b] -> [b]
10:03:14 <yitz> Tyr42: i think you're looking for map.map
10:03:23 <dylex> geheimdienst: me neither.  you might just want something like data Directory = ..., data Entry = EntryDir Directory | ...
10:03:23 <yitz> @type map.map
10:03:24 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
10:03:34 <yitz> ah no not exactly
10:04:09 <hpc> you do want map (f . g)
10:04:18 <hpc> map (f . g) xs = map f (map g xs)
10:04:34 <hpc> @pl \f g xs -> map (f . g) xs
10:04:34 <lambdabot> (map .) . (.)
10:04:44 <yitz> geheimdienst: i would do something like your original type, but not split the different cases into separate handlers
10:04:45 <hpc> :t map .: (.)
10:04:46 <lambdabot> forall a b a1. (a1 -> b) -> (a -> a1) -> [a] -> [b]
10:04:54 <Tyr42> It was actually just a midterm question (first year) (bonus question)
10:05:28 * yitz missed the bonus question. drat.
10:05:31 <atomicity> is it possible to compose functions of more than one variable? I want to compare tuples by their first element only, so I'd think I could do something like (==) . (fst, fst) but that, of course, doesn't work.
10:05:44 <hpc> @let pipe = fmap .: fmap
10:05:45 <lambdabot>  Defined.
10:05:49 <Tyr42> Try running it though pl
10:05:54 <yitz> atomicity: (==) `on` fst
10:06:10 <Tyr42> @pl \(x,y) (a,b) -> x == a
10:06:11 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
10:06:13 <hpc> > pipe succ (* 2) [1..5]
10:06:16 <lambdabot>   [3,5,7,9,11]
10:06:22 <geheimdienst> yitz: by "not split into different handlers", you mean going with total functions everywhere instead of the "mustDir", "mustNotDir" functions?
10:06:46 <atomicity> yitz: wow.
10:06:46 <hpc> :t pipe
10:06:47 <lambdabot> forall a1 b a (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
10:06:52 <hpc> :t fmap fmap fmap fmap fmap
10:06:53 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
10:06:57 <hpc> lawl
10:07:30 <RaptorRarr> @src pipe
10:07:31 <hpc> @undefine
10:07:31 <lambdabot> Source not found.
10:07:36 <yitz> geheimdienst: instead of mustBeDir and getFileContents, have one function dispatchPath with different equations to match each of the constructors
10:07:38 <hpc> @let pipe = fmap fmap fmap fmap fmap
10:07:39 <lambdabot>  Defined.
10:07:51 <geheimdienst> yitz: roger, got it
10:07:54 <hpc> :t pipe -- ^ is the src
10:07:54 <lambdabot> forall a1 b a (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
10:07:57 <RaptorRarr> It would be nice if @src would show @let functions, too.
10:08:03 <RaptorRarr> @src pipe
10:08:03 <lambdabot> Source not found. There are some things that I just don't know.
10:08:14 <RaptorRarr> Then, we could see the evil handiwork of people.
10:08:16 <yitz> geheimdienst: if one of the actions is big, it can call out to a separate function without the constructor wrapper
10:08:21 <hpc> the more readable definition was fmap .: fmap
10:08:33 <hpc> where (.:) = fmap fmap fmap
10:08:42 <geheimdienst> okay everyone, thanks a great deal for your assistance. you have no idea how great that is
10:09:03 <atomicity> yitz: where is 'on' defined?
10:09:21 <yitz> geheimdienst: sorry if we steer you in different directions sometimes. we're different people. :)
10:09:26 <yitz> @hoogle on
10:09:26 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:09:26 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
10:09:26 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:09:41 <yitz> atomicity: ^^
10:09:42 <hpc> :t (.:)
10:09:43 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:09:44 <atomicity> yitz: thanks
10:10:36 <kirindave_> Wow
10:10:39 <kirindave_> that is a hell of a type
10:10:49 <yitz> atomicity: often you have to put the whole `on` expression in parens. oh well. still worth it though, in my opinion.
10:11:53 <hpc> kirindave_: it's fun to find useful examples of applying things to (fmap^n) for different values of n
10:12:18 <geheimdienst> yitz: no worries, i see it as progress. this morning i knew nothing about GADTs; now i am an expert since i have used them one abortive half of a time
10:12:23 <kirindave_> i thought .: was one of those semantic function combinators tho...
10:12:25 <kirindave_> Maybe that was :.
10:12:42 <kirindave_> That was like combining f (g x y)
10:12:57 <_Vi> Is there a way to remove all packages installed using "cabal install --global"?
10:13:51 <pwseo> Mkman: hi :p
10:14:18 <rotflcopter> did my first circle rasterization in haskell :) someone measured the time?
10:15:08 <Nibble> 56min 35s
10:20:03 <tswett> Have any dependently typed programming languages seen serious use?
10:20:35 <tswett> Coq seems like a well-developed proof language, but for programming, it lacks... certain features.
10:20:43 <tswett> Such as a built-in data type for integers.
10:21:51 <Mkman> pwseo: hey :D
10:22:11 <copumpkin> tswett: idris aims at filling that space
10:22:16 <copumpkin> but edwinb is still working on it
10:22:34 <companion_cube> tswett: i thought it had natural numbers
10:22:46 <copumpkin> you have all of that stuff if you import it
10:22:54 <copumpkin> coq even has reals (*shock* *horror*)
10:24:07 <companion_cube> :)
10:24:33 <companion_cube> who needs integers when they can have church naturals anyway?
10:25:41 <rotflcopter> :)
10:33:17 <Tyr42> @pl \f g x y -> (f (g x y))
10:33:18 <lambdabot> (.) . (.)
10:33:53 <roconnor> tswett: there is a machine integer library somewhere (maybe it is for the trunk version of coq only)
10:39:08 <ecuageo> hey all, I've just started to learn haskell, I'm going through learnyouahaskell.org. I'm also going through the machine learning course at ml-class.org. Is haskell a good fit for ML?
10:42:19 <copumpkin> tswett: http://www.cs.st-andrews.ac.uk/~eb/writings/dtp11.pdf
10:49:33 <qwer123> .
10:49:46 <rotflcopter> hmm
10:50:16 <rotflcopter> ghci processed 5656856 pixels for the fullcircle in 10 seconds, is that good?
10:50:51 <tswett> The thing is, you see, multiplication of two 16-bit integers really ought to take a couple of nanoseconds at most.  }:)
10:51:28 <rotflcopter> ok but i did floatingpoint precision
10:51:35 <rotflcopter> then rounded down to int
10:53:22 <RaptorRarr> rotflcopter: ghci is usually very, very slow.
10:53:57 <RaptorRarr> rotflcopter: Best to compile using O2 or Os or something and timing that.
10:54:23 <rotflcopter> :)
10:54:30 <rotflcopter> ok trying to compile
10:54:43 <rotflcopter> do i need a main function?
11:00:25 <yitz> ecuageo: welcome to haskell! i'm sure you'll enjoy it and profit from it. however, i have a feeling that the course will use their own software libraries, so you'll probably have to use whatever language they are designed to work with.
11:01:30 <RaptorRarr> rotflcopter: Yeah, you'd make a separate file that imports your module, has a main function that times whatever.
11:02:56 <rotflcopter> how can i output main = PutStrLn (length (perfectfullcircle 1000000)) ?
11:02:59 <lpsmith> kmc:  it seems to me that bug #5558 means that nearly any use of top-level state with the threaded runtime is broken.
11:03:30 <rotflcopter> and/or main = (perfectfullcircle 1000000)
11:04:08 <rotflcopter> ( it is array of doubles [(),()] )
11:04:10 <RaptorRarr> rotflcopter: print (length (perfectfullcircle 1000000))
11:04:16 <lpsmith> Honestly,  I'm of the opinion that GHC should offer top-level state done right.
11:04:38 <lpsmith> instead of this unsafePerformIO hack
11:05:09 <c_wraith> especially since the unsafePerformIO hack apparently has a bug in some versions of GHC
11:05:36 <lpsmith> kmc: I've also found that top-level state interacts badly with hint
11:05:42 <rotflcopter> coll thanks
11:05:43 <lpsmith> oh hai c_wraith =)
11:05:59 <rotflcopter> $ time ./midpointcircletest
11:05:59 <rotflcopter> 5656856
11:06:16 <lpsmith> c_wraith: yeah,  if I understand kmc's post correctly,   quite a few versions of GHC (if you use the -threaded runtime)
11:06:27 <rotflcopter> real    0m2.876s
11:06:39 <rotflcopter> so 1M pixel radius circle consisting of 5656856 pixels
11:06:45 <c_wraith> lpsmith: well.  It's impossible for top-level state to interact sanely with dynamic loading
11:06:50 <Leif_Bork> Hi! This may be a stupid question, but what is the time complexity of length?
11:06:55 <RaptorRarr> rotflcopter: So, that's compiled with -O2 and all?
11:07:13 <RaptorRarr> Leif_Bork: Whatever the time complexity of generating the spine of the list is.
11:07:32 <lpsmith> impossible seems like a rather strong word...
11:07:35 <rotflcopter> dont know what you thinking about
11:07:40 <rotflcopter> default is optimized no?
11:07:46 <RaptorRarr> rotflcopter: No, it's unoptimized.
11:07:49 <c_wraith> lpsmith: because it's impossible to define "sane" in that context
11:08:02 <yitz> lpsmith: there have been endless suggestions of various nice features to add that would provide this, from simple to fancy. none has ever been seriously considered.
11:08:05 <arcatan> Leif_Bork: O(n)
11:08:17 <rotflcopter> did ./ghc -O2 midpointcircletest.hs
11:08:19 <rotflcopter> and did nothing
11:08:26 <rotflcopter> its upto date i guess
11:08:30 <RaptorRarr> rotflcopter: Delete the .hi and .o files and do ghc -O2 --make midpointcircletest.hs
11:08:38 <Leif_Bork> arcatan: Thanks. Damn!
11:08:40 <c_wraith> lpsmith: you'll want it to be the same MVar if you're using it to control access to an unsafe C api.  You'll want it to be re-initialized if the type changes.  And there are undecidable cases in between
11:08:49 <RaptorRarr> rotflcopter: I think it won't figure out that it needs to regenerate new versions if the old unoptimized ones are still there.
11:08:52 <yitz> lpsmith: lpsmith: are you sure it's all TLS and not just MVar?
11:09:41 <lpsmith> yitz: well,  assuming that I understand kmc's post correctly,  yeah all TLS,  including IORefs
11:10:08 <rotflcopter> RaptorRarr<< ok did that, still real    0m2.668s
11:10:18 <yitz> lpsmith: bummer. the bug doesn't say that, but i believe you. anyway, it's marked fixed in HEAD.
11:10:19 <RaptorRarr> It can take longer than O(n) if you have something like if someexponentialtimefunction then a:xs else [a]
11:10:28 <RaptorRarr> rotflcopter: Ahh, cool. That should be how fast it is.
11:10:34 <yitz> lpsmith: where is kmc's post?
11:10:39 <Leif_Bork> arcatan: Is there any useful list alternative?
11:10:46 <rotflcopter> after loading file in cache, real    0m1.929s
11:10:51 <lpsmith> yitz: aslo,  assuming I understand correctly (which I'm not sure about) it only affects the -threaded runtime system
11:10:54 <rotflcopter> so 33% improvement ?
11:10:55 <c_wraith> yitz: http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
11:11:03 <yitz> ah that
11:11:23 <c_wraith> lpsmith: well, yes.  the non-threaded runtime doesn't actually run multiple threads simultaneously.
11:11:29 <RaptorRarr> rotflcopter: Ahh, cool. What does it mean to load a file in cache?
11:11:40 <rotflcopter> well i run it multiple times
11:11:44 <yitz> Leif_Bork: many. what do want to do?
11:11:45 <rotflcopter> and system caches things
11:11:45 <RaptorRarr> rotflcopter: Ahh, I see.
11:11:54 <yitz> *you
11:12:24 <RaptorRarr> rotflcopter: Now, if you use -O2 all the time, you won't have to redelete all the .o and .hi files, you can just time things pretty easily.
11:12:29 <rotflcopter> file has to be read from disk, and also libraries
11:12:30 <ClockFrog> Why doesn't filter work on strings?
11:12:48 <RaptorRarr> rotflcopter: So you can try different optimizations and see which speed things up to an acceptable performance.
11:12:49 <c_wraith> ClockFrog: it does
11:13:00 <c_wraith> > filter isChar "123abc"
11:13:01 <lambdabot>   Not in scope: `isChar'
11:13:09 <c_wraith> err
11:13:13 <c_wraith> > filter isAlpha "123abc"
11:13:15 <lambdabot>   "abc"
11:13:19 <RaptorRarr> @let isChar :: Char -> Bool; isChar _
11:13:19 <lambdabot>   TemplateHaskell is not enabled
11:13:24 <RaptorRarr> @let isChar :: Char -> Bool; isChar _ = True
11:13:25 <lambdabot>  Defined.
11:13:29 <lpsmith> i mean, I suppose you *could* work around the bug by making sure that your main function touches every point of top level state before it starts forking or using par
11:13:39 <lpsmith> by touch, I mean force
11:13:40 <rotflcopter> well actually seems quite good to generate 5.6Mpixels of circle data in 2secs
11:13:58 <RaptorRarr> rotflcopter: Oh, OK.
11:14:06 <c_wraith> lpsmith: doesn't help with the dynamic loading case, though
11:14:13 <lpsmith> right :)
11:14:32 <ClockFrog> > filter (/= " ") "abc zxc"
11:14:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:14:33 <lambdabot>         against inferred ty...
11:14:43 <c_wraith> ClockFrog: well, yes.  a string is not an element of a string
11:14:45 <RaptorRarr> rotflcopter: I think you might need to force the values in the list, too.
11:14:50 <c_wraith> ClockFrog: characters are elements of strings
11:14:53 <RaptorRarr> rotflcopter: length will only force the spine of the list.
11:14:59 <raphraph> Does anyone know how to convert an integer to IO integer?
11:15:07 <c_wraith> > filter (/= ' ') "abc zxc" -- ClockFrog
11:15:08 <lambdabot>   "abczxc"
11:15:20 <ClockFrog> oh
11:15:27 <ClockFrog> ty =]
11:15:30 <lpsmith> but that's also a hack from the deepest depths of hell... i mean,  a module might not even have it's TLS exposed in a way that main can force it properly,  so now you have to start hacking all the modules.
11:15:34 <rotflcopter> perfectfullcircle 4
11:15:47 <lpsmith> raphraph: return
11:15:55 <lpsmith> :t return
11:15:56 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:16:31 <lpsmith> :t return :: Integer -> IO Integer
11:16:32 <lambdabot> Integer -> IO Integer
11:16:43 <RaptorRarr> rotflcopter: What is an example element of that list?
11:16:48 <raphraph> lpsmith, thank you I didn't know that return will work in a case pattern
11:16:49 <rotflcopter> [(0,4),(4,0),(0,-4),(-4,0),(4,1),(4,-1),(-4,-1),(4,-1),(1,4),(1,-4),(-1,-4),(1,-4),(3,2),(3,-2),(-3,-2),(3,-2),(2,3),(2,-3),(-2,-3),(2,-3),(3,3),(3,-3),(-3,-3),(3,-3)]
11:17:01 <RaptorRarr> rotflcopter: Ahh, you could, to force the list, sum all the elements.
11:17:07 <c_wraith> I wonder if GHC has been updated to unload unused dynamically-loaded modules yet...
11:17:11 <RaptorRarr> @type foldl'
11:17:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:17:23 <rotflcopter> raphraph<< take 1 (perfectfullcircle 4)
11:17:23 <rotflcopter> [(0,4)]
11:18:51 <lpsmith> raphraph: you are welcome
11:22:41 <RaptorRarr> rotflcopter: main = let foldb _ [x] = x; foldb f xs@(_:_:_) = foldb f (go f xs) where go f (x:y:zs) = f x y:go f zs; go _ xs = xs in foldb (+) . concatMap (\(x, y) -> [x, y]) . fullperfectcircle 1000000
11:22:43 <lpsmith> yitz: I'm wondering if -threaded and a top-level IORef would be less problematic in that the rare bugs would tend to be more benign than a top-level MVar
11:22:56 <RaptorRarr> Bah.
11:23:01 <lpsmith> or,  harder to notice
11:23:29 <lpsmith> I mean,  you violate the protocol that a particular MVar uses and you tend to notice pretty quickly
11:23:47 <ecuageo> yitz: thanks for the reply, yes they use octave. I'm fine using that during the class, but for putting in serious time studying I wanted to see if many are using haskell for machine learning and if it it full-featured for it. ie does it perform well, have a supporting libraries, a ml community etc.
11:25:33 <yitz> lpsmith: well, you'd get two different IORefs when you hit the bug. let's say that each thread, if it finds the IORef empty, populates it with result <- launchMissiles.
11:26:02 <RaptorRarr> yitz: Doesn't launchMissiles need a target argument?
11:26:36 <yitz> RaptorRarr: no, it launches all of them. pointing everywhere.
11:26:40 <RaptorRarr> Oh!
11:26:44 <lpsmith> well, but IORefs are never empty :)
11:26:56 <RaptorRarr> I could see how that could be convenient.
11:27:13 <yitz> lpsmith: often the TLS hack involves an IORef initialized to Nothing
11:27:43 <lpsmith> point taken.   I suppose I was interpreting "empty" in the MVar sense
11:28:56 <Leif_Bork> yitz: I have some functions that require counting many the lengths of many lists
11:29:07 <Leif_Bork> counting the lengths of many lists
11:29:10 <yitz> RaptorRarr: and obviously you wouldn't want to do that twice. missiles are very expensive, you know.
11:29:20 <Leif_Bork> I'm build a clustering application
11:29:33 <Leif_Bork> as in machine learning
11:30:43 <yitz> Leif_Bork: if all you need to do is count them, you wouldn't even store the data at all. you'd just count the items to begin with.
11:31:06 <rostayob> what branch of GHC has KindPolymorphism?
11:31:17 <yitz> Leif_Bork: building the list is also O(n), assuming you need to access the whole thing.
11:31:21 <Leif_Bork> yitz: No, both counting and analysis
11:34:02 <yitz> Leif_Bork: if at some point in your algorithm you know how many items there are without counting them - e.g., when generating the data - record the number then.
11:34:36 <yitz> Leif_Bork: if you really need to count them one by one to find out how many there are, then there's no way to avoid O(n) no matter what data structure you use.
11:35:45 <c_wraith> yitz: not *fully* true.  Some data structures are guaranteed to be dense, so finding the last element is sufficient to tell you how many there are.  No one uses data structures with that property in that way, though.
11:35:59 <c_wraith> yitz: complete binary trees are one such example
11:36:11 <yitz> Leif_Bork: as for the analysis, there is no way to know what would be a good data structure for it without knowing what kind of analysis you are doing.
11:36:46 <yitz> c_wraith: sure. but i don't think that's the real issue here.
11:37:08 <c_wraith> yitz: it's not a good reason to use that kind of structure.  that's for sure. :)
11:37:42 <yitz> c_wraith: unlike some other languages, haskell does not encourage you to dump your data into memory any which way and only then start thinking about what you're going to do with it.
11:37:56 <dylex> m
11:38:45 <c_wraith> huh.  actually, come to think of it, a complete binary tree is going to require, on average, looking at about n/2 nodes to find the last one.  That's not a huge gain.
11:39:42 <mm_freak> so mtl 2 = monads-fd + transformers…  what's the equivalent for type families?  it should be based on transformers, too
11:39:59 <c_wraith> monads-tf is still out there
11:40:27 <mm_freak> is it still common enough, or is it a dying library?
11:40:33 <c_wraith> it's pretty much dying
11:40:41 <mm_freak> =/
11:40:43 <c_wraith> it wasn't very common before mtl 2
11:40:47 <c_wraith> and it's less common now
11:41:32 <yitz> c_wraith: hmm. sounds like mptc/fd are winning over tf for a silly reason.
11:41:41 <dolio> It does?
11:42:06 <yitz> dolio: well i hope not. but that's what is sounds like from what c_wraith is saying.
11:42:13 <yitz> s/is/it/
11:42:43 <c_wraith> It's mostly a matter of inertia.
11:43:09 <SethTisue> I'm on page 236 of LYAH, the bit about the Applicative instance for functions. it gives the code for the instance. is that code in the standard library somewhere? "import Control.Applicative" doesn't seem to get it
11:43:15 <c_wraith> Those were two libraries with equivalent functionality.  For compatibility, people mostly want to settle on one.
11:43:20 <rotflcopter> reloaded
11:43:21 <lambdabot> rotflcopter: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:43:34 <Leif_Bork> yitz: Required operations are rates of elements in the lists, unions and intersections.
11:43:43 <mm_freak> i could use monads-tf anyway
11:43:51 <c_wraith> SethTisue: it's in Control.Monad.Instances.  I think....
11:43:56 <mm_freak> people using mtl can still use the transformers part
11:43:59 <rotflcopter> cool
11:44:15 <SethTisue> c_wraith: yup, that did it! thanks! greetings from #scala
11:44:28 <mm_freak> i wonder what we have monads for…  there is ArrowApply, and we should write only arrow transformers =)
11:44:28 <c_wraith> SethTisue: I have no clue why it's there.
11:44:30 <yitz> Leif_Bork: ok. for unions and intersections of large sets, you might use Data.Set.
11:45:30 <yitz> c_wraith: the monad instance is there. also applicative? i wonder why.
11:45:41 <c_wraith> SethTisue: hmm.  on ghc 7.2, the applicative instance for functions is in scope with only import Control.Applicative
11:46:08 <yitz> SethTisue: please send warm greetings back to #scala from #haskell
11:46:16 <c_wraith> > liftA2 (+) (*2) (*3) 5 -- my quick test...
11:46:18 <lambdabot>   25
11:46:31 <c_wraith> of course, lambdabot imports the universe, so that doesn't tell us much :)
11:47:16 <mm_freak> SethTisue: i don't have to import Control.Monad.Instances, when i import Control.Applicative since base 4.*
11:47:38 <yitz> c_wraith: your example worked for me in ghci with just :m Control.Applicative
11:47:46 <c_wraith> yitz: same for me
11:48:02 <hpc> c_wraith: there's a funky Num instance that also works
11:48:09 <yitz> SethTisue: weird. we all seem to be getting that instance just by importing Control.Applicative
11:48:35 <hpc> > (+) (* 2) (* 3) $ 5
11:48:35 <lambdabot>   25
11:48:36 <SethTisue> I'm running GHCi 7.0.4
11:48:36 <petekaz> Is haskell.org down or is it me?
11:48:47 <yitz> SethTisue: where are you running your haskell code?
11:48:52 <sm> it's you
11:48:56 <yitz> hmm that should do it.
11:49:49 <SethTisue> yitz: http://pastie.org/2794856
11:50:31 <mm_freak> 201 195541 -!- Irssi: New peak in #haskell@fn : 864
11:50:36 <mm_freak> haskell takes over the world
11:50:51 <yitz> petekaz: http://www.downforeveryoneorjustme.com/haskell.org: It's just you. http://haskell.org is up.
11:51:12 <Leif_Bork> yitz: Thanks. I will overlook my algorithms, and see how often different types of operations are necessary, and compare overall time complexity using different types.
11:52:14 <yitz> Leif_Bork: ok good luck!
11:52:29 <petekaz> yitz: thanks
11:52:43 <Leif_Bork> yitz: Thanks! =)
11:52:49 <yitz> we should have a lambdabot command for that
11:53:33 <yitz> mm_freak: i think we need at least 865 to take over the world
11:54:09 <mm_freak> we are larger than ##php
11:54:17 <erus`> ChanServ doesnt count either
11:55:50 <RaptorRarr> I think that's because PHP help is widely available elsewhere, but a large proportion of Haskell help is here.
11:56:12 <mm_freak> that proves nothing, though…  the web is still infected with lots of PHP websites
11:56:12 <rotflcopter> why does ghc(and the compiled program) cause my system to hang for seconds sometimes?
11:56:17 <SethTisue> "brew install ghc" installs ghc 7.0.4. maybe a good samaritan here would like to try to update the formula
11:56:25 <rotflcopter> i have not even ran it as root
11:56:40 <mm_freak> RaptorRarr: a large proportion of help is also on SO and in the mailing list, though SO seems to take over
11:56:47 <RaptorRarr> rotflcopter: Your system or the program?
11:57:02 <RaptorRarr> mm_freak: Yeah, but even with that, there are much fewer places for PHP help.
11:57:08 <RaptorRarr> Sorry, Haskell help.
11:57:12 <rotflcopter> it hogs so much resources even the mouse cursor and time halts
11:57:16 <rotflcopter> ;/
11:57:17 <RaptorRarr> rotflcopter: Oh, wow.
11:57:30 <RaptorRarr> rotflcopter: It's probably churning memory.
11:57:35 <rotflcopter> and at every compile time
11:57:41 <mm_freak> RaptorRarr: true…  PHP also doesn't have such a learning curve
11:57:51 <mm_freak> PHP basically turns every idiot into a programmer
11:58:08 <shlevy> I'm testing a system that hooks hackage into my package manager. What's a hackage package that has lots of dependencies ?
11:58:11 <RaptorRarr> rotflcopter: Are you on a low-memory machine?
11:58:15 <rotflcopter> RaptorRarr<< so if i put 4GB+ ddr3 in a comp it will not hang up like this?
11:58:33 <RaptorRarr> rotflcopter: It will if it exhausts that.
11:58:36 <mm_freak> shlevy: yesod
11:58:41 <shlevy> mm_freak: Thanks
11:58:54 <rotflcopter> RaptorRarr<< well 1GB ram+4GB swap now
11:59:07 <RaptorRarr> rotflcopter: I'm not sure what the compiler does to make it work like that, but it seems to happen whenever my programs use huge amounts of memory.
11:59:09 <yitz> SethTisue: 7.0.4 should be fine - though i don't have it here so i can't test.
11:59:19 <RaptorRarr> rotflcopter: What's the memory usage when it hangs up?
11:59:25 <RaptorRarr> rotflcopter: From top or whatever.
11:59:26 <rotflcopter> donno
11:59:34 <rotflcopter> even my mouse cursor hanged
11:59:40 <mm_freak> rotflcopter: ./myprogram +RTS -s
11:59:49 <rotflcopter> no program can do this before
11:59:53 <RaptorRarr> rotflcopter: Yeah, most OSs hang when the IO system gets swamped.
12:00:02 <mm_freak> rotflcopter:                1 MB total memory in use (0 MB lost due to fragmentation)
12:00:11 <mm_freak> that's the interesting line
12:00:15 <RaptorRarr> rotflcopter: If you write a program that really uses IO, it can do the same.
12:00:26 <mm_freak> you need to compile with -rtsopts, if you have a recent (≥ 7) GHC
12:00:40 <rotflcopter> mm_freak<< whatsthat? hidden haskell program switches?
12:00:45 <ClaudiusMaximus> +RTS -M900M will make your program crash on out of memory, instead of letting the system thrash
12:00:47 <yitz> SethTisue: ah wait a minute. go out of ghci, go in, and try using :m +Control.Applicative instead of import.
12:01:01 <mm_freak> rotflcopter: if you compile with -rtsopts, you have a set of RTS command line switches available
12:01:21 <RaptorRarr> mm_freak: Oh, cool, I like that that's not compiled in by default.
12:01:23 <SethTisue> yitz: that does it
12:01:29 <mm_freak> RaptorRarr: it used to be
12:01:33 <yitz> SethTisue: using "import" syntax instead of ":m" in ghci is a new feature in 7.0.x, but it has some minor bugs that will be fixed in the next version.
12:01:39 <RaptorRarr> mm_freak: Is there a way to disable RTS switches on the command line, but to set them at compile time?
12:01:41 <SethTisue> yitz: thanks!
12:01:43 <mm_freak> but in recent GHC versions it's optional and needs to be enabled specifically
12:01:54 <rotflcopter> good to know
12:01:59 <yitz> SethTisue: but don't worry, import works fine when you compile!
12:02:10 <copumpkin> SethTisue: coming to hac boston?
12:02:11 <mm_freak> RaptorRarr: yes, there is, but i don't know what that option is called…  personally i would just enable RTS options
12:02:19 <RaptorRarr> mm_freak: Ahh, I see.
12:02:29 <mm_freak> RaptorRarr: you need to add "+RTS" anyway, otherwise the options are not recognized
12:02:32 <rotflcopter> so did the function actually generate the elements?
12:02:33 <RaptorRarr> Oh, OK.
12:02:40 <rotflcopter> i'd guess it did
12:03:02 <rotflcopter> but the printing of the array would take long time
12:03:57 <mm_freak> RaptorRarr: adding "+RTS -s" gives you a little resource summary from the run-time system, including memory usage, garbage collection and thread usage stats
12:04:13 <yitz> RaptorRarr: wrap it in a shell script
12:05:05 <RaptorRarr> I've never really liked the idea of my programming language being exposed in my programs. It's not that big of a bother, of course.
12:05:43 <edwardk> SethTisue: show up =P
12:06:08 <adimit> ok, I give up. arrows: given app :: (b ~> c, b) ~> c (from ArrowApply), how do i implement a "curried" app2 :: b ~> ((b ~> c) ~> c)? The example is from byorgey's typeclassopedia, and I just can't seem to find the answer.
12:06:53 <adimit> did all other exericeses in the paper, just this one is giving me a headache. I know that it probably is something along the lines of app2 = app >>> undefined … but I can't puzzle out what to fill in for undefined.
12:10:12 <RaptorRarr> @type curry
12:10:15 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:10:42 <RaptorRarr> @type curry (flip app)
12:10:43 <lambdabot> forall (a :: * -> * -> *) b a1 b1 b2. (ArrowApply a, Functor (a (a b ((a1, b1) -> b2), b))) => a1 -> b1 -> a (a b ((a1, b1) -> b2), b) b2
12:10:49 <yitz> @type &&&
12:10:50 <lambdabot> parse error on input `&&&'
12:11:01 <RaptorRarr> @type app
12:11:02 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
12:11:08 <yitz> @type (&&&)
12:11:09 <adimit> @type (&&&)
12:11:09 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:11:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:11:13 <adimit> lol. :-)
12:11:44 <yitz> adimit: that's a hint. got to run. :)
12:11:55 <adimit> yitz: with &&&
12:11:57 <adimit> ?
12:12:10 <RaptorRarr> @type app . flip (,)
12:12:11 <lambdabot>     Couldn't match expected type `(b -> b1, a -> b)'
12:12:11 <lambdabot>            against inferred type `a1 -> b2 -> (a1, b2)'
12:12:11 <lambdabot>     In the first argument of `flip', namely `(,)'
12:13:22 <adimit> I figured it'd have &&& somewhere in there…
12:15:07 <erus`> i would be cool to prototype an editor that is AST based rather than text based
12:15:37 <copumpkin> erus`: everyone wants one, nobody's figured out how to do it right yet :)
12:15:43 <copumpkin> I'd love to see one though
12:15:55 <erus`> use opengl and a kinect :P
12:16:05 <erus`> various knee slapping gestures
12:17:08 <erus`> also haskell functions can be defined in any order, unlike C so that would help
12:17:23 <RaptorRarr> ArrowApply a => a b (a (a b c) c)
12:18:36 <rostayob> https://gist.github.com/1331621 , because we can.
12:18:36 <edwardk> erus`: the major issue that folks run into with AST based editors are things like the cut and paste issue where you wind up only being able to graft trees since our text-based intuition for cutting and pasting is wrong in that world, and that folks are loathe to give up their ability to reindent and align code
12:19:36 <Saizan> also, it seems you can do a lot without being AST based
12:22:51 <erus`> it would cool to click and drag a function or value, into the body of another function though
12:23:30 <erus`> you could just show the type sigs and a description for the function
12:24:10 <shlevy> Which env vars affect hGetContents' processing? I'm getting hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
12:24:10 <atomicity> easiest way to calc a dot product of two lists?
12:24:26 <erus`> zipWith ?
12:24:36 <atomicity> erus`: nice, thanks
12:24:38 <shlevy> But only in my build chroot. Works fine from my normal login shell
12:27:14 <atomicity> is there a way to write sum (zipWith (*) l1 l2) without the parens over the arg of sum?
12:27:24 <atomicity> I'm trying with . but it doesn't work very well..
12:27:37 <atomicity> I mean, it won't swallow it the way I'm writing it
12:28:09 <rotflcopter> ok
12:28:33 <rotflcopter> next level: anti-alias circle
12:28:59 <erus`> sum $ zipWith (*) l1 l2
12:30:22 <rotflcopter> unsure what to do with colors
12:30:29 <rotflcopter> at linewidth=1 ;/
12:30:29 <dylex> shlevy: LANG, maybe LC_* (through iconv).  I tend to call hSetEncoding explicitly when I can.
12:32:07 <shlevy> Why am I getting different behaviour invoking runhaskell on a file vs cat'ing that file into runhaskell's STDIN?
12:32:22 <Ferdirand> or sum . zipWith (*) l1 $ l2
12:33:25 <atomicity> Ferdirand: sum $ zipWith (*) l1 l2 works too, I found
12:34:35 <shlevy> http://sprunge.us/GAIj
12:34:46 <Ferdirand> yes. I was hoping to stir a debate on the respective benefits of (.) and ($) :)
12:35:01 <abiii> hey everyone, is there a sensible way to use cabal to avoid dep install failures that I seem to be getting all the time these days?
12:35:40 <luite> yeah use cabal-dev instead
12:36:51 <rotflcopter> ahm ok i get it
12:37:00 <rotflcopter> too bad i cant test it yet :(
12:37:11 <rotflcopter> graphics library not found and cant install yet
12:38:15 <shlevy> Hm.... I have LANG="en_US.UTF-8" and localeEncoding is giving me "ANSI_X3.4-1968"
12:38:24 <abiii> luite: what's the difference?
12:39:00 <luite> abiii: cabal-dev uses a project-local package db, so is less likely to mess up your global one
12:39:40 <abiii> luite: ah i see, but for every project i have to reinstall/compile it or can i just copy folders around
12:40:17 <abiii> it would work perfectly but there are some things that have global commands like the agda language. in those cases, i'd still want to use cabal right
12:40:18 <abiii> ?
12:42:16 <luite> abiii: you can use both
12:42:47 <luite> abiii: I usually do a fresh install for every project with cabal-dev
12:42:55 <luite> which takes a while
12:43:18 <atomicity> oh, damn, haskell is awesome
12:44:12 <atomicity> except for the issues with getting different representations of real numbers to behave like in python (as in, you don't have to give a shit whether it's an int or a double)
12:44:40 <atomicity> anyway, thanks for all the help today.
12:44:57 <shlevy> dylex: Seems like I need to call hSetEncoding but it's a precompiled program
12:45:54 <abiii> luite: cool thanks
12:46:05 * shlevy files a bug report
12:46:19 <erus`> wow eclipsefp totally ignores the tab size :(
12:47:27 <dylex> shlevy: iconv may need stuff in /usr/share/locale or something; does that exist in your chroot?
12:47:54 <shlevy> dylex: Ah, no I don't think it does.
12:48:46 <Phlogistique> Preprocessing library haskell-src-1.0.1.4...
12:48:46 <Phlogistique> shift/reduce conflicts:  2
12:48:46 <Phlogistique> Building haskell-src-1.0.1.4...
12:48:46 <Phlogistique> Implicit import declaration:
12:48:46 <Phlogistique>     Ambiguous module name `Prelude':
12:48:47 <dylex> shlevy: locale-gen should be able to make what you need.  I'd look into iconv documentation (which is what it's using underneath).
12:48:48 <Phlogistique>       it was found in multiple packages: base haskell98-2.0.0.0
12:48:51 <Phlogistique> I get this while trying to install
12:49:03 <Phlogistique> a package with cabl
12:49:06 <Phlogistique> *cabal
12:49:19 <shlevy> dylex: Thanks
12:49:20 <Phlogistique> Should I hide a package? What's the problem?
12:49:40 <luite> Phlogistique: usually remove the haskell98 dependency from the .cabal
12:49:50 <luite> but you might need to fix some imports then
12:50:54 <Phlogistique> luite: any hints wrt why this problem happens?
12:51:52 <luite> Phlogistique: yeah there's a conflict between base and haskell98 in recent ghc versions, so you shouldn't depend on both
12:52:47 <Phlogistique> so basically I should contact the author of haskell-src to tell them their .cabal is broken?
12:53:11 <c_wraith> couldn't hurt.  But in the meantime, try using haskell-src-exts
12:53:15 <rotflcopter> how would you add 'A' value to (x,y) coordinates in haskell?
12:53:44 <Phlogistique> c_wraith: well, my problem is that I've got two other packages I'm trying to build which depend on Haskell-src
12:54:01 <c_wraith> Phlogistique: really?  What are you trying to install?
12:54:02 <rotflcopter> (for anti-alias affect)
12:54:45 <rotflcopter> 8-16 bit integer? or should icare? floating pont?
12:55:04 <rotflcopter> *floatingpoint
12:56:32 <rotflcopter> (0,11)[10] or (0,11,10) or [0,11,10] ?
12:57:20 <ion> Huh?
12:57:28 <statusfailed> Is function application the most binding operator?
12:57:30 <statusfailed> strongest binding*
12:57:36 <rotflcopter> x,y coordinate, and antialias attribute
12:58:37 <rotflcopter> float would be nice, but... that many bytes for each pixel?
12:58:41 <c_wraith> statusfailed: well, no.  But it's close
12:58:51 <wyfrn> is there a way to profile a function in ghci or is the only way to write a test program and use tools like time/ghc -p/valgrind, etc
12:58:57 <Eduard_Munteanu> Only record syntax is tighter AFAIK
12:58:57 <c_wraith> statusfailed: record "update" syntax binds more tightly than function application
12:59:21 <statusfailed> Ahh ok
12:59:30 <statusfailed> I've been bracketing as though it were the weakest
12:59:40 <statusfailed> which doesn't look great :p
12:59:42 <statusfailed> it's like LISP
12:59:48 <c_wraith> yeah, that's why it's the other way around :)
12:59:51 <statusfailed> hahah
12:59:58 <statusfailed> I just thought "I must be doing something wrong....."
13:00:37 <statusfailed> now I can use the . operator properly~
13:01:59 <Eduard_Munteanu> rotflcopter: I'm not sure what you're doing, but RGBA with 8 bits per channel should be pretty common
13:02:20 <rotflcopter> yes i know
13:02:33 <rotflcopter> doing anti-alias circle
13:02:50 <rotflcopter> and x,y coordinates need an alias attribute
13:03:04 <rotflcopter> (2dpoints)
13:04:46 <Eduard_Munteanu> rotflcopter: maybe you can use 8 bits for that and fit everything into something like a Word32?
13:05:05 <rotflcopter> yes
13:05:56 <c_wraith> wyfrn: ghc has a profiler built in.  you can try using it.  (see the ghc docs for how to use it, I don't recall the options offhand)
13:05:58 <rotflcopter> though i stored x,y coordinates of pixels instead of whole memory array...
13:07:08 <Eduard_Munteanu> rotflcopter: how about a Map (Int, Int) Word32?
13:08:02 <Eduard_Munteanu> Or even an IntMap.
13:08:13 <rotflcopter> not sure about it yet
13:09:02 <yitz> c_wraith: for many things haskell-src-exts is a pain, you really want haskell-src. i hope they fix it.
13:09:52 <shlevy> dylex: Is there anything I can do to get readFile to use a non-default encoding?
13:10:00 <yitz> c_wraith: i should word that differently - more commonly you want haskell-src-exts, but for some things that's a pain and you really want haskell-src.
13:10:26 <c_wraith> What worries me most about haskell-src-exts is that ghc extensions that add new syntax seem to be coming out incredibly fast.  Has any thought been put into making GHC's parser a standalone project?
13:10:27 <yitz> @hoogle hSetEncoding
13:10:27 <lambdabot> No results found
13:10:28 <Eduard_Munteanu> @hoogle hSetEncoding
13:10:29 <lambdabot> No results found
13:10:36 <Eduard_Munteanu> :)
13:10:42 <yitz> hmm
13:10:54 <yitz> @hoogle encoding
13:10:55 <lambdabot> Network.CGI newtype ContentEncoding
13:10:55 <lambdabot> Network.CGI ContentEncoding :: String -> ContentEncoding
13:10:55 <lambdabot> Network.HTTP.Headers HdrAcceptEncoding :: HeaderName
13:10:56 <Eduard_Munteanu> shlevy: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:23
13:11:24 <shlevy> Right, but I don't have a Handle
13:11:30 <c_wraith> then get one.
13:11:56 <shlevy> Trying to change this code as little as possible. Guess I'll have to be more invasive
13:12:03 <yitz> @hoogle stdin
13:12:03 <lambdabot> System.IO stdin :: Handle
13:12:21 <yitz> shlevy: isn't that your handle then?
13:12:39 <shlevy> yitz: for readFile?
13:12:40 <Eduard_Munteanu> Use, e.g., openFile.
13:12:41 <juliohm> Dear all, i heard is also possible to have comma syntax when defining a branched expression like "abs n = n, n>=0" \n "    = -n, otherwise". I get an compilation error tough.
13:13:26 <yitz> shlevy: ah no, that uses its own handle internally I think
13:13:50 <juliohm> I know the guards and the classical if/else approach, there is another way of making branches in Haskell?
13:13:53 <shlevy> @src readFile
13:14:05 <c_wraith> juliohm: whoever mentioned that was probably talking about list comprehensions
13:14:26 <c_wraith> > [ x * x | x <- [1..10], x > 3, x < 7 ]
13:14:30 <yitz> juliohm: guards. |
13:14:39 <juliohm> abs n = n, n>=0
13:14:40 <juliohm> .    = -n, otherwise
13:14:45 <c_wraith> ...  did \bot explode again?
13:15:01 <juliohm> This is not possible ^
13:15:06 <yitz> > let myAbs n | n >= 0 = n | otherwise = negate n in myAbs (-5)
13:15:32 <Eduard_Munteanu> @bot λ⊥
13:15:33 <yitz> oh oh
13:16:18 <yitz> juliohm: anyway, that's the syntax. traditionally, you start each | on a new indented line
13:17:00 <juliohm> Any hint?
13:17:03 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
13:17:08 <lambdabot>   [16,25,36]
13:17:20 <lambdabot>   5
13:17:31 <lambdabot> :)
13:17:35 <yitz> > let myAbs n | n >= 0 = n | otherwise = negate n in myAbs (-5) -- juliohm, like this
13:17:47 <byorgey> adimit: did you ever find the solution to that arrows exercise?
13:18:00 <lambdabot>   5
13:18:13 <yitz> @nixon you are very slow
13:18:14 <lambdabot> When the President does it, that means that it is not illegal.
13:18:28 <juliohm> yitz, these are guards, i was wondering if the comma was possible someway. :-)
13:18:46 <yitz> juliohm: why is a comma better than a bar?
13:19:15 <ciaranm> that sounds like some bad joke with a pun punchline
13:19:25 <Ferdirand> because it uses less pixels on a typical font, therefore it saves power !
13:19:34 <blackdog> "except the sheep!"
13:19:41 <juliohm> yitz, the order is more clear, the condition after the expression. :-)
13:20:56 <rotflcopter> http://learnyouahaskell.com/starting-out
13:21:14 <rotflcopter> im here, if i do
13:21:21 <blackdog> hah, just watching bos's startup preso... i'm relatively sure don didn't go to sydney uni, unless the dude in the cubicle next to me was a hologram...
13:21:23 <rotflcopter> let asd i = (if ((round i)-i) > 0.01 then "a" else "b")
13:21:26 <rotflcopter> then it fails
13:21:51 <DanBurton> Ferdirand: wait a minute...if you are using a black font, then doesn't it save more power to use a bar since it requires less of the screen to be lit up?
13:22:14 <ClaudiusMaximus> rotflcopter: needs more fromIntegral
13:22:27 <byorgey> rotflcopter: (round i) and i  do not have the same type, so they cannot be subtracted
13:22:39 <rotflcopter> :(
13:22:40 <DanBurton> :t round
13:22:45 <Ferdirand> DanBurton: aha, but on an lcd the backlight is permanently on, and masking out black pixels consumes power !
13:23:01 <rotflcopter> but i need the fractional part/difference
13:23:09 <DanBurton> lambdabot's running a bit slow today. :(
13:23:11 <yitz> > let backwardsGuards = fst . head . dropWhile (not . snd); myAbs n = backwardsGuards [(n, n>=0), (-n, otherwise)] in myAbs (-5)
13:23:35 <byorgey> > let asd i = if (fromIntegral (round i) - i) > 0.01 then "a" else "b" in asd 4.6
13:23:49 <byorgey> oh, is lambdabot dead? =(
13:23:56 <yitz> byorgey: no just sick
13:24:01 <DanBurton> @botsnack
13:24:04 <rotflcopter> oh thanks
13:24:05 <byorgey> rotflcopter: use 'fromIntegral' to convert an integral type to a floating-point type
13:24:07 <balor> given two unsorted lists, any algorithm to find the elements common to both lists is necessarily O(n^2) right?
13:24:08 <rotflcopter> :)
13:24:26 <yitz> byorgey: hang around for a while, you might get your answer from lambdabot eventually
13:24:30 <rotflcopter> so no simpler solution to the problem right?
13:24:32 <yitz> preflex: seen Cale
13:24:32 <preflex>  Cale was last seen on #haskell 16 hours, 13 minutes and 22 seconds ago, saying: scooty-puff: That's also a good option, considering that numeric defaulting will tend to pick Integer
13:24:52 <byorgey> balor: if the elements in the lists *can* be sorted, then you can do it in O(n log n)
13:25:04 <yitz> oops, out she goes. too bad.
13:25:07 <byorgey> balor: just sort the lists first and then scan through them in parallel looking for common elements
13:25:37 <DanBurton> preflex: seen lambdabot
13:25:38 <preflex>  lambdabot was last seen on #haskell 7 minutes and 24 seconds ago, saying: When the President does it, that means that it is not illegal.
13:25:39 <yitz> @tell Cale Ol' bot just went belly up again. Thanks.
13:25:41 <RaptorRarr> balor: You can also store the first lists' elements' indices in a hash table or something.
13:25:54 <yitz> oops
13:25:56 <DanBurton> lol
13:26:00 <balor> byorgey, d'oh, of course.
13:26:01 <DanBurton> the irony
13:26:01 <yitz> preflex: help tell
13:26:01 <preflex>  tell NICK MESSAGE - when NICK shows activity, tell them MESSAGE
13:26:14 <yitz> preflex: tell Cale Ol' bot just went belly up again. Thanks.
13:26:14 <preflex>  Consider it noted.
13:26:16 <RaptorRarr> balor: Check out set union algorithms.
13:26:27 <RaptorRarr> balor: Any set union algorithm will, of course, tell you if there are matches.
13:26:31 <balor> RaptorRarr, thanks.  I'll do that.
13:27:39 <tromp> aka union-find
13:34:18 <DanBurton> Lambdabot dies => #haskell dies
13:34:25 <yitz> byorgey: i thought the solution to the arrows problem uses &&& >>> and app, but that seems to require mulitple uses of arr. is that wrong?
13:34:29 <sm> not at all
13:34:39 <yitz> DanBurton: try us
13:35:04 <byorgey> yitz: the only solution I know of uses arr.  I do not know whether it is required.
13:35:22 <yitz> byorgey: ok i'm not going crazy then. thanks. :)
13:35:27 <edwardk> preflex: xseen jmcarthur
13:35:27 <preflex>  jmcarthur was last seen on freenode/#haskell-blah 3 days, 2 hours, 32 minutes and 3 seconds ago, saying: or just use a little type magic in agda
13:35:35 <byorgey> yitz: that does not logically follow ;)
13:35:40 <yitz> heheh
13:39:15 <DanBurton> Does anyone know of a HashMap + Linked List data structure on Hackage? I started rolling my own but I wouldn't want to reinvent the wheel completely: http://stackoverflow.com/questions/7970402/haskell-hash-table/7971705#7971705
13:40:00 <edwardk> DanBurton: =(
13:40:56 <ion> Why not a map of monoids instead of a map of lists?
13:41:16 <DanBurton> erm...to avoid overgeneralization?
13:41:34 <Cale> lists are a universal monoid
13:41:34 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
13:41:52 <yitz> byorgey: i guess in that case you might as well just use (,) instead of &&&.
13:41:57 <c_wraith> a quick application of mconcat converts lists to the monoid of your choice!
13:42:09 <c_wraith> well.   a map and then an mconcat
13:42:42 <yitz> c_wraith: we need mconcatMap
13:42:46 <c_wraith> clearly
13:43:02 <yitz> c_wraith: it actually does come up quite often
13:43:10 <c_wraith> :: Monoid b => (a -> b) -> [a] -> b
13:43:38 <ion> @type foldMap
13:43:45 <lambdabot> Not in scope: `foldMap'
13:43:49 <ion> @type Data.Foldable.foldMap
13:43:51 <yitz> thanks Cale
13:43:55 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
13:44:04 <Cale> DanBurton: umm... does it have to involve a hash? I would usually just use Data.Map with lists in it.
13:44:09 <byorgey> yitz: yes, I suppose so
13:44:16 <c_wraith> hmm.  yes, that does appear to be the function in question
13:44:29 <Eduard_Munteanu> @bot
13:44:35 <lambdabot> :)
13:44:57 * Cale feels perhaps unduly insecure about using hashes when there are easier to understand alternatives that perform well enough...
13:45:05 <DanBurton> Cale: the reason for having lists in it is *because* of the hash. If two different things hash to the same slot, then they get added to the list.
13:45:11 <c_wraith> wow, lambdabot's slow.  Cale, is its machine choking under infinite mueval-core processes?
13:45:30 <Cale> c_wraith: Many people on the network (including me) have been lagging out
13:45:39 <c_wraith> Cale: ah, ok.
13:46:18 <byorgey> @type arr $ (flip (,) >>> arr) >>> (>>> app)   -- a nicely obfuscated solution
13:46:19 <lambdabot> forall (a :: * -> * -> *) (a1 :: * -> * -> *) b c. (Arrow a, ArrowApply a1) => a b (a1 (a1 b c) c)
13:46:26 <Cale> DanBurton: Oh, but why do you care about that implementation detail? :)
13:46:41 <DanBurton> Cale: for writing a library
13:46:51 <Cale> DanBurton: Map doesn't suffer from having linear worst case behaviour because it doesn't hash things
13:47:02 <yitz> @type arr $ (>>> app) . app . flip (,)
13:47:02 <lambdabot>     Couldn't match expected type `(b2 -> cat a (cat b1 c, b1),
13:47:02 <lambdabot>                                    b -> b2)'
13:47:03 <lambdabot>            against inferred type `a1 -> b3 -> (a1, b3)'
13:47:11 <Cale> and it doesn't give up and store everything in a list at some depth
13:47:27 <yitz> @type arr $ (>>> app) . arr . flip (,)
13:47:28 <lambdabot> forall b (a :: * -> * -> *) (cat :: * -> * -> *) c. (Arrow a, ArrowApply cat) => a b (cat (cat b c) c)
13:47:32 <DanBurton> Cale: I never said it was a *good* idea to make this data structure xD I just wanted to know if it has been made already; and I want to make it if it hasn't
13:47:50 <Cale> oh, okay
13:48:14 <Ferdirand> would it make sense to store a map in a n-ary prefix tree backed by a hash function ?
13:48:22 <yitz> byorgey: ^^ not so obfuscated. on the other hand, perhaps cheating because of lambdabot's definition of (.).
13:48:29 <DanBurton> then maybe later I'll run some performance tests and see how it does
13:48:32 <c_wraith> Ferdirand: yes.  that's what the unordered-containers package does
13:48:38 <Ferdirand> or would that just be more expensive than rebalancing ?
13:49:02 <byorgey> yitz: no, that's only using normal function composition
13:49:15 <dylex> DanBurton: I'm probably missing the point, but how is this different than Data.HashTable?
13:49:15 <byorgey> yitz: that solution works in my ghci too
13:49:17 <DanBurton> Ferdirand: that would only work for datatypes that have a prefix. I suppose you could probably define that for most of the useful data types, though
13:49:31 <Ferdirand> no, i meant the prefixes are from the hash output
13:49:35 <yitz> @type arr $ (<<<) app . (&&&) arr id . arr . const -- byorgey, my original thought
13:49:36 <lambdabot>     Couldn't match expected type `(cat b c, b)'
13:49:36 <lambdabot>            against inferred type `b1 -> c1'
13:49:36 <lambdabot>     In the second argument of `(&&&)', namely `id'
13:49:41 <DanBurton> dylex: maybe it's not. Is that how Data.HashTable works?
13:49:43 <yitz> argh
13:49:44 <c_wraith> Ferdirand: as I said, that's *exactly* what unordered-containers does
13:50:01 <Ferdirand> c_wraith: heh, thanks, suddently I feel less like a total noob :)
13:50:10 <byorgey> yitz: yes, I had something akin to that at first too
13:50:14 <Cale> DanBurton: Ah, okay, Data.HashMap uses hashing, but stores values with the same hash in a Data.Map instead of a list.
13:50:34 <Cale> DanBurton: So it's similar to what you're asking for, but perhaps a bit more convenient implementation-wise.
13:50:40 <dylex> DanBurton: what Cale said, while Data.HashTable uses lists, afaik
13:50:52 <DanBurton> Cale: right. It assumes that you never care to put two different things in the map with the same key
13:50:56 <c_wraith> unfortunately, two different packages each provide Data.HashTable
13:51:13 <c_wraith> So...  Which one are you talking about?
13:51:47 <yitz> @type arr $ (<<<) app . (&&&) (arr id) . arr . const -- byorgey, my original thought, corrected
13:51:48 <lambdabot> forall b (a :: * -> * -> *) (cat :: * -> * -> *) c. (Arrow a, ArrowApply cat) => a b (cat (cat b c) c)
13:52:03 <DanBurton> c_wraith: the better one?
13:52:06 <Cale> DanBurton: Oh, well, if you do, you just use a list or set type as your value type, and use insertWith (++) or insertWith union to add new elements.
13:52:10 <dylex> c_wraith: base-4.4?
13:52:23 <Cale> I guess you could abstract over that
13:52:35 <Cale> But it's pretty easy to just use it that way
13:53:29 <DanBurton> True
13:57:03 <yitz> DanBurton: you may be interested in hashmap
13:57:07 <yitz> @hackage hashmap
13:57:08 <lambdabot> http://hackage.haskell.org/package/hashmap
13:57:28 <Cale> yitz: HashMap is what we've been talking about ;)
13:57:29 <yitz> DanBurton: it's pretty heavily optimized
13:57:46 <yitz> Cale: oops ok sorry
13:58:08 <DanBurton> Yep :)
13:58:14 <hpaste> tgeeky pasted “cabal dependencies” at http://hpaste.org/53406
13:58:52 <tgeeky_> can someone please advise on (1) what to do about this: http://hpaste.org/53406 , and (2) what should I be thinking in this case -- ie, what do I do next?
13:59:19 <DanBurton> I like this part in base Data.HashMap  prime :: Int32; prime = 33554467 http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-HashTable.html#prime
13:59:24 <yitz> c_wraith, DanBurton: the hashmap i linked to. author milan straka
13:59:47 <yitz> DanBurton: don't use the one in base
14:00:16 <Philonous_> How conservative is -XOverloadedStrings considered to be?
14:00:49 <Cale> Philonous_: It's not a very popular extension, but it's also not hard to implement.
14:01:03 <c_wraith> Philonous_: what it does is considerered pretty harmless.  Which instances you use with it might cause ire from certain people
14:01:06 <rotflcopter> let asd2 [a,b] i = if abs (intdif i) > 0.01 then [[a,b,1.0],[a,b,0.0]] else [a,b,1] in asd2 [10,10] 1.99
14:01:13 <DanBurton> Philonous_: since practically everyone uses GHC anyways...
14:01:18 <rotflcopter> whats the syntax error?
14:01:40 <yitz> tgeeky_: yes people have been complaining about problems building tls today.
14:01:47 <DanBurton> is OverloadedStrings isn't included in the Haskell Report is it?
14:02:02 <c_wraith> No, it's not
14:02:08 <Cale> > let intdif = undefined; asd2 [a,b] i = if abs (intdif i) > 0.01 then [[a,b,1.0],[a,b,0.0]] else [a,b,1] in asd2 [10,10] 1.99
14:02:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
14:02:17 <Cale> There's no syntax error
14:02:23 <Cale> There is a type error
14:02:32 <rotflcopter> ah stry
14:02:40 <Cale> The two branches of your if expression have different types
14:03:00 <yitz> Philonous_: OverloadedStrings is a dangerous hack in my opinion, but since we don't have anything better sometimes you have to use it.
14:03:14 <rotflcopter> let intdif f = (fromIntegral (round f) - f)
14:03:15 <mercury^> What would be a better solution?
14:03:17 <Philonous_> c_wraith:  I'm converting a library from String to Text and just can't be bothered to add a Text.pack in front of every literal
14:03:38 <c_wraith> Philonous_: I hope no one objects to the Text instance for IsString
14:03:40 <DanBurton> yitz: it seems no more dangerous than overloaded numbers, which is standard Haskell
14:03:44 <rotflcopter> let abs n = if n<0 then -n else ņ
14:04:00 <c_wraith> Philonous_: in particular, it's the ByteString.Char8 instance that people object to.
14:04:09 <Cale> imo, you pretty much never really have to use OverloadedStrings, because applying pack manually to strings is almost never going to be all that terrible.
14:04:21 <Philonous_> c_wraith:  I don't see why anyone would. Strings are supposed to be Unicode anyway, aren't they?
14:04:21 <yitz> mercury^: provide a way to specify other types for string literals so that their syntax is checked at compile time, not at run time.
14:04:22 <Cale> But it can be nice to have
14:04:35 <DanBurton> Cale: the same could be said of fromInteger
14:04:55 <c_wraith> (though I don't see why...  It's no worse than being allowed to use literals for Num instances that will truncate)
14:05:05 <Cale> DanBurton: Sort of, if fromInteger had a shorter name, especially.
14:05:09 <rotflcopter> Cale<< but why thats problem?
14:05:15 <yitz> DanBurton: you're right. but somehow it has been extremely rare for it to cause problems for numbers. whereas hackage is now filling up with packages that cause syntax errors at runtime for strings.
14:05:44 <Philonous_> yitz:  TH to the rescue!
14:05:52 <yitz> DanBurton: and now they're talking about extending this mistake to lists as well. horrors!
14:05:53 <DanBurton> Cale: let nummy = fromInteger
14:05:55 <c_wraith> yitz: clearly, overloaded strings should be converted at compile-time then. :)
14:06:15 <mercury^> Eww, runtime syntax errors?
14:06:20 <mercury^> How can that even be?
14:06:31 <c_wraith> horrible abuse of IsString
14:06:39 * DanBurton is one of those people that *wants* overloaded syntax for lists >.>
14:06:52 <c_wraith> I should make string an instance of Num, with fromInteger = show
14:07:29 <yitz> c_wraith: yeah. it's not quite that simple though - you'll only be able to do that for string literals whose type can be resolved to a monomorphic type at compile time, but the current API using classes allows you to use string literals with polymorphic type.
14:07:31 <DanBurton> c_wraith: sounds like fun!
14:08:03 <c_wraith> yitz: along with the fact that it essentially needs a Lift instance for the data type in question
14:08:45 <yitz> Philonous_: yes, what we really need is to be able to tell GHC internally to treat string literals as if they were quasiquotes.
14:09:42 <DanBurton> We have printf in Text.Printf, but is there a library with sprintf?
14:09:53 <c_wraith> DanBurton: exact same function
14:10:01 <Cale> DanBurton: printf is sprintf too
14:10:03 <hpc> DanBurton: printf is polymorphic to strings and IO
14:10:06 <c_wraith> :t printf "foo" :: IO ()
14:10:06 <lambdabot> IO ()
14:10:09 <c_wraith> :t printf "foo" :: String
14:10:10 <lambdabot> String
14:10:12 <DanBurton> ahhh
14:10:21 <shlevy> :t printf
14:10:22 <hpc> DanBurton: the special one is hPrintf, which has to take a handle and produce an IO action
14:10:22 <lambdabot> forall r. (PrintfType r) => String -> r
14:10:23 <DanBurton> wonky polymorphic result types
14:10:36 <hpc> consult the hoogle for moreinfo
14:10:42 <yitz> @type printf "foo" :: ()
14:10:43 <lambdabot>     No instance for (PrintfType ())
14:10:43 <lambdabot>       arising from a use of `printf' at <interactive>:1:0-11
14:10:43 <lambdabot>     Possible fix: add an instance declaration for (PrintfType ())
14:10:56 <Cale> If printf is going to be polymorphic in that it may produce a function, it might as well be polymorphic in that way too.
14:11:06 <shlevy> How many PrintfTypes are there?
14:11:15 <Cale> Just a few
14:11:23 <yitz> text?
14:11:28 <hpc> Cale: ...oh, that might even work
14:11:28 <Cale> Well, infinitely many, but just a few instances.
14:11:31 <yitz> @type printf "foo" :: Data.Text
14:11:31 <lambdabot> Couldn't find qualified module.
14:11:40 <yitz> @type printf "foo" :: T
14:11:41 <lambdabot>     No instance for (IsChar Int)
14:11:41 <lambdabot>       arising from a use of `printf' at <interactive>:1:0-11
14:11:41 <lambdabot>     Possible fix: add an instance declaration for (IsChar Int)
14:11:41 <shlevy> @src PrintfType
14:11:41 <lambdabot> Source not found. I feel much better now.
14:12:04 <yitz> @info T
14:12:04 <hpc> Cale: oh, no it won't without an API change
14:12:04 <lambdabot> T
14:12:12 <hpc> :t printf `asTypeOf` hPrintf
14:12:13 <lambdabot>     Couldn't match expected type `[Char]'
14:12:13 <lambdabot>            against inferred type `GHC.IO.Handle.Types.Handle'
14:12:13 <lambdabot>       Expected type: String
14:13:58 <Philonous_> yitz:  Why not use actual QQ in those cases?
14:14:18 <Cale> QQ how?
14:14:34 <Cale> oh
14:14:43 <Cale> Missed the original comment
14:15:01 <c_wraith> can QQs splice as patterns yet?
14:16:05 <Cale> Yeah, I think I agree. If your desired instance IsString t is such that you can't really write a function String -> t, then you probably shouldn't be using IsString?
14:16:17 <Cale> Or string notation at all
14:16:21 <c_wraith> Possibly the most bizarre thing OverloadedStrings lets you do is use literals in pattern matches.
14:17:20 * hackagebot http-enumerator 0.7.1.4 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1.4 (MichaelSnoyman)
14:17:29 <hpaste> DanBurton pasted “Abomination: instance Num [Char]” at http://hpaste.org/53411
14:17:44 <c_wraith> ah, QQs can splice as patterns
14:17:50 <yitz> Philonous_: yeah it's possible to write a QQ that will work for some of the popular packages that implement IsString instances.
14:18:02 <c_wraith> So you can use a QQ expression as a pattern match, too
14:18:11 <yitz> Philonous_: but that's not as nice as being able to use string literal syntax
14:18:17 <DanBurton> :t printf `asTypeOf` hprintf 'c'
14:18:18 <lambdabot> Not in scope: `hprintf'
14:18:27 <DanBurton> :t printf `asTypeOf` hPrintf 'c'
14:18:28 <lambdabot>     Couldn't match expected type `GHC.IO.Handle.Types.Handle'
14:18:28 <lambdabot>            against inferred type `Char'
14:18:28 <lambdabot>     In the first argument of `hPrintf', namely 'c'
14:18:36 <DanBurton> oh /sigh
14:18:43 <DanBurton> :t printf `asTypeOf` hPrintf undefined
14:18:44 <lambdabot> forall r. (PrintfType r, HPrintfType r) => String -> r
14:19:10 <Cale> DanBurton: You are halfway to reinventing Expr :)
14:19:15 <shlevy> DanBurton: signum = undefined is kind of cheating, isn't it?
14:19:29 <Cale> http://hackage.haskell.org/package/simple-reflect
14:19:34 <c_wraith> :t x
14:19:35 <lambdabot> Expr
14:19:36 <DanBurton> :) I assume Expr uses an ADT though instead of String, so that it can simlpify
14:19:55 <DanBurton> > x - x
14:19:56 <lambdabot>   x - x
14:19:59 <Cale> not really...
14:20:04 <DanBurton> maybe not xD
14:20:05 <Cale> data Expr = Expr
14:20:05 <Cale>    { showExpr   :: Int -> ShowS  -- ^ Show with the given precedence level
14:20:05 <Cale>    , intExpr    :: Maybe Integer -- ^ Integer value?
14:20:05 <Cale>    , doubleExpr :: Maybe Double  -- ^ Floating value?
14:20:05 <Cale>    , reduced    :: Maybe Expr    -- ^ Next reduction step
14:20:06 <Cale>    }
14:20:49 <yitz> Philonous_: for example, it's nice to write parsers like "foo" .*> bar <*. "baz"
14:21:12 <yitz> Philonous_: it wouldn't be nearly as readable with QQ syntax, even though that's also fairly light.
14:22:02 <Philonous_> yitz:  If we are at that point we might drop the facade of isString and make it type-directed quasi quoting. That might be useful for other things as well. (isString Hamlet ... )
14:22:30 <DanBurton> :i ShowS
14:22:34 <yitz> Philonous_: right that's what i proposed. people didn't like it. oh well.
14:22:51 <Philonous_> yitz:  More metaprogramming. I'm all for it.
14:27:08 <erus`> how do i enable stencil test with HOpengl?
14:27:24 <erus`> i cant find the docs with all the functions from the tutorials
14:27:52 <hpc> erus`: http://haskell.org/hoogle/?hoogle=opengl -- it's just opengl now
14:30:37 <Philonous_> yitz:  TH does seem to stir up a lot of resentment overall. Nobody likes macros :(
14:31:00 <adimit> byorgey: no I didn't yet :-(
14:31:36 <blackdog> Philonous_: i think it's wrongheaded. obviously you don't pull out TH as a first choice, but it doesn't make sense to leave stuff on the table just to avoid templates.
14:32:20 <adimit> byorgey: right now, I'm trying to implement curry and flip in in terms of arrows, since I know that I can get what I want with «flip $ curry app»
14:33:18 <adimit> but I think I'm just spending too much time on a problem I just can't see a solution to… sometimes you're so close you're only seeing your own nose, not the paper.
14:33:47 <DanBurton> adimit: hpaste what you've got; maybe we can help
14:34:29 <Cale> adimit: Well, what types should they have?
14:34:34 <Cale> :t curry
14:34:34 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:35:00 <Cale> I suppose you could do  ((a,b) ~> c) -> (a ~> (b ~> c))
14:35:23 <adimit> Cale: exactly, that's what I'm trying to find.
14:35:41 <adimit> I'm having difficulty "thinking" in arrows. I don't even know why, they look conceptually simple.
14:35:42 <Cale> curry f = proc x -> do returnA -< (proc y -> do f -< (x,y))
14:36:01 <copumpkin> eww
14:36:13 <copumpkin> noise
14:36:21 <Cale> proc/do is ugly but straightforward to write
14:36:51 <adimit> well, thanks, I'll try to translate that into "normal" arrows, Cale :-)
14:37:01 <erus`> hmm how the hell do i set the stencil operation
14:37:18 <DanBurton> I suppose @undo can't handle arrow do notation?
14:37:18 <adimit> even though I think I do not need to define a general curry and flip for my original problem.
14:37:20 * hackagebot clientsession 0.7.3.3 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.3.3 (MichaelSnoyman)
14:37:36 <adimit> there should be @unproc
14:38:19 <Cale> adimit: Yeah, it's kinda weird to want curry
14:38:30 <Cale> In the case of most arrow libraries I can think of
14:38:53 <adimit> Cale: it's not a practical problem. It's a brainteaser in byorgey's typeclassopedia.
14:39:00 <Cale> okay
14:39:11 <dylex> erus`: stencilOp $= (failop, zfailop, zpassop)
14:39:13 <adimit> I'm well aware that it has … limited … practical use. :-)
14:39:37 <erus`> dylex: why do i ned have to include any of the child modules?
14:39:43 <Phlogistique> so if I understand well, a lot of packages in Hackage are broken by GHC 7. What is the standard way to workaround? (for example, "hint" and "hoe" both depend on "haskell-src" which depends on "haskell98" and "base" which conflict)
14:39:54 <erus`> where ned = not
14:40:12 <adimit> the idea is to curry app :: ((b ~> c, b) ~> c) (ArrowApply) into app2:: b ~> (b ~> c) ~> c
14:40:29 <dylex> erus`: Graphics.Rendering.OpenGL re-exports all of them (including, in this case, Graphics.Rendering.OpenGL.GL.PerFragment)
14:40:40 <erus`> ah cool
14:41:11 <Cale> curry f = arr (\x -> arr (\y -> (x,y)) >>> f)
14:41:23 <Cale> would be what it looks like without proc/do
14:41:36 <copumpkin> needs m0ar @pl
14:41:41 <copumpkin> @pl arr (\x -> arr (\y -> (x,y)) >>> f)
14:41:42 <lambdabot> arr ((>>> f) . arr . (,))
14:41:53 <Cale> I don't know about others, but I have to think a bit more about how to get things into the right form when I write it like that
14:42:07 <Cale> (and I write arrow code all day long)
14:42:29 <adimit> I'm just starting out with arrows, really. thanks for your help :-)
14:42:50 <DanBurton> Cale: what, exactly are you doing with arrows all day long?
14:43:01 <adimit> also, I'd like to consider @pl harmful.
14:43:09 <Cale> DanBurton: Working on a commercial game for iPhones and other mobile devices.
14:43:22 <Cale> DanBurton: Our FRP system is Arrowy.
14:43:33 <DanBurton> Cale: in Haskell?
14:43:36 <Cale> yes
14:43:40 <DanBurton> cool sauce
14:45:23 <Cale> All the AI code for the monsters is written in arrows, and the UI stuff (which I'll be reviving shortly, since it worked on the device, but we'll need it to also work on Linux for testing) is written in an applicative functor built on top of an arrow (originally Yampa, but needs updating to our new FRP library)
14:47:00 <adimit> that sounds really nice!
14:47:05 <gienah> Phlogistique: I sort of thought most stuff would build with ghc 7.0.4, for ghc 7.2.1 hint builds from the secret repo: http://darcsden.com/jcpetruzza/hint
14:47:23 <adimit> gotta look into FRP next. seems to be the in thing right now.
14:49:26 <kosmikus> adimit: is it more "in" than it was 10 years ago?
14:49:30 <Phlogistique> gienah: it seems I've got ghc 7.0.3
14:50:17 <Phlogistique> gienah: but I've done "cabal install --upgrade-dependancies" at some point
14:50:24 <Phlogistique> maybe this is the problem?
14:50:34 <adimit> kosmikus: don't know. ten years ago I was a teenager more concerned with getting laid than functional programming.
14:50:40 <gienah> Phlogistique: for other stuff that doesn't build like the haskell98 base issue with ghc 7.2.1, our approach in the gentoo haskell overlay is to patch it so it does build, source code is here: https://github.com/gentoo-haskell
14:51:04 <kwos> adimit: if your priorities changed then you should re-examine your life :)
14:51:07 <gienah> Phlogistique: I don't know as I never use cabal install
14:51:20 * gienah just creates gentoo ebuilds
14:51:32 <yitz> Phlogistique: are you trying to build tls?
14:51:42 * gienah has to got do stuff
14:51:47 <Phlogistique> yitz: nope; trying to install "hoe"
14:51:53 <yitz> oh right
14:52:32 <adimit> kwos: nah, I just got the getting laid part out of the way. so now I can concentrate on FP.
14:53:01 <yitz> tgeeky_: hmm, i just installed tls in a clean directory using cabal-dev (so all dependencies were downloaded from hackage and built from scratch). the build went fine.
14:53:18 <yitz> tgeeky_: i wonder why so many people are having problems with it today.
14:55:16 <yitz> Phlogistique: try that for hoe: install cabal-dev, create an empty directory, cd into it, do another cabal update to make sure, then do cabal-dev install hoe. see if that works.
14:56:41 <Phlogistique> yitz: thanks
14:57:15 <yitz> Phlogistique: hmm just tried it. doesn't build there either. bad news.
14:57:50 <yitz> Phlogistique: i have ghc 7.0.2
14:58:43 <Phlogistique> yitz: so I guess I should manually install each dependancy
15:01:06 <edwardk> @ask byorgey do you know if the kind polymorphism/lifting code made it in under the wire for 7.4 ?
15:01:06 <lambdabot> Consider it noted.
15:02:07 <yitz> Phlogistique: not sure how that will help.
15:02:20 <Phlogistique> yitz: well I can fix them on the way
15:02:30 <Phlogistique> while I'm not sure how to do it using cabal
15:03:44 <yitz> Phlogistique: it seems to want older versions of some of ghc's internal packages. things break when you try to do that. i guess you'll have to fix those packages to work with the current versions somehow.
15:04:53 <Phlogistique> another question: is it possible to tell ghc (runhaskell) to interpret a file as literate haskell even though its extension is not lhs?
15:04:55 <theddy> Cale: Im curious, what are you using to compile for iOs?
15:09:13 <erus`> how do i only draw to z and stencil? not colour
15:10:44 <MatrixFrog1> phlogistique: iirc there is, but i don't remember how
15:12:04 <Phlogistique> MatrixFrog1: ok, found it:
15:12:07 <Phlogistique> runhaskell -x lhs
15:12:31 <Phlogistique> ... well, I'm not so sure now
15:25:14 <MatrixFrog1> i remember noticing it recently while i was looking for something else
15:25:20 <MatrixFrog1> i just don't remember what the actual flag was
15:30:37 <erus`> hackage/haddock could rather do with an UP button that goes back a namespace
15:30:48 <erus`> eg A.B -> A
15:31:20 <rostayob> that would be really useful
15:31:46 <rostayob> it's particularly awkward to go back to the index of a package
15:38:11 <ddarius> Namespaces aren't hierarchical.
15:41:42 <erus`> why can't i do a 'translate' inside a 'renderPrimitive' ?
15:44:29 <dylex> erus`: That's the way opengl works.  see the opengl specification section 2.6.3.
15:44:54 <roconnor_> the derivative of the dirac delta function is hard for me to visualize.
15:46:01 <kmc> asking "is the dirac delta function a function" is a good way to start an argument between mathematicians and physicists
15:47:04 <roconnor_> kmc: I've been reading lighthill's generalized functions
15:56:43 <int80_h> can I have a guard in a where binding?
15:56:52 <Saizan> yes
15:57:08 <int80_h> hmm parse error and I dont know why. Posting to hpaste
15:57:41 <int80_h> can I have pattern matching in a where binding?
15:57:49 <shachaf> Yes.
15:58:06 <int80_h> okay those hwere my guessing, I'll post
15:58:17 <int80_h> oh I see it
15:58:38 <int80_h> maybe not
15:58:50 <erus`> how do i transform the camera back on z 10 units then rotate a cube ? when i rotate the cube its moving around the camera rather than around itself
15:59:02 <erus`> and when i rotate first it transforms in the wrong direction
15:59:29 <theddy> erus`: Try #opengl
15:59:58 <hpaste> int80_h pasted “why parse error in this where binding?” at http://hpaste.org/53418
16:00:42 <int80_h> oh wait
16:00:44 <int80_h> I got it
16:00:44 <Ferdirand> ==
16:00:47 <int80_h> ya
16:04:30 <Aune> I have trouble installing hlint, when i run "cabal install hlint" I get haskell-src-exts-1.11.1 failed during the configure step. The exception was:
16:04:30 <Aune> ExitFailure 1
16:04:56 <shachaf> Aune: Presumably the failure isn't with hlint but with haskell-src-exts
16:05:22 <Aune> yeah, but I still dont know how to fix it.
16:05:22 <shachaf> The error "ExitFailure 1" tells us approximately nothing about what actually went wrong. :-)
16:05:50 <xshoppyx> How can I declare a type annotation that forces both elements in a list of tuples to be members of Ord?
16:05:51 <shachaf> Try running "cabal install haskell-src-exts" and examining the entire output.
16:05:53 <xshoppyx> compareTupleList :: (Ord a, b) => [(a, b)] -> [(a, b)] -> Bool
16:06:01 <shachaf> xshoppyx: (Ord a, Ord b)?
16:06:02 <xshoppyx> Isn't working
16:06:11 <Aune> ok, will do
16:06:55 <JoeyA> Is there a better way to have a pattern guard for a single value in a list comprehension than to use a singleton list?  For example:
16:06:58 <JoeyA> > let list = [Just 3, Just 4, Nothing] in [(a, x) | a <- list, Just x <- [a]]
16:06:59 <lambdabot>   [(Just 3,3),(Just 4,4)]
16:07:06 <hpaste> tgeeky pasted “scumbag yesod” at http://hpaste.org/53419
16:07:16 <koeien> why does the 'encoding' package contain a binary?
16:07:19 <JoeyA> Yes, I could just say Just x <- list, but not in my particular situation.
16:08:08 <shachaf> JoeyA: Perhaps you should explain your particular situation, then. :-)
16:08:21 <xshoppyx> Thanks I was trying (Ord a) (Ord b) first, guess I was close
16:08:42 <shachaf> xshoppyx: I believe Ord a => Ord b => ... is also valid.
16:08:43 <JoeyA> shachaf: I'm finishing a project that was supposed to be done yesterday.  Does that crystallize things?  :-)
16:09:00 <shachaf> Not particularly.
16:09:04 <JoeyA> heh
16:09:20 <shachaf> If you reduce your test case so much that the problem doesn't come up in it anymore, I'm not sure how much people can really help.
16:09:21 <JoeyA> I'll need a minute to figure out what exactly my situation is.
16:09:36 <xshoppyx> shachaf I think that looks better
16:10:02 <Cale> tgeeky_: I don't know about yesod, but I had a hell of a time with text the other day. There are a couple things which make it brutal to install correctly. One is that it doesn't depend on the deepseq package explicitly, but if you build it without having deepseq installed, you get a version of text without an NFData instance that you might need.
16:10:42 <shachaf> xshoppyx: ((Ord x, Ord y) => is certainly more canonical, though. I don't think I've ever seen the pseudo-curried form of it used.)
16:10:43 <tgeeky_> Cale: :(. I have to re-do this whole thing. And unregister only accepts one argument at at time! :(
16:11:07 <Cale> (and then if you later reinstall it to get that instance, all your packages become broken like that)
16:11:21 <Cale> tgeeky_: one sec
16:11:50 <Cale> ghc-pkg check 2>&1 | grep 'There are problems' | sed 's/^There are problems in package \(\([a-zA-Z][a-zA-Z0-9-]*\)*\)-[0-9].*$/\1/g' | xargs -n 1 sudo ghc-pkg unregister
16:11:54 <jerry> can anyone tell me what does this operator do >>
16:11:54 <lpsmith> Cale: I haven't noticed this subtlety with the NFData instance.   Did you have any other trouble?
16:12:17 <Aune> Hmm, seems that the problem is: "The program happy version >=1.17 is required but it could not be found." Happy seems to install fine, it just seems cabal cant find it afterward.
16:12:19 <lpsmith> :t (>>)
16:12:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:12:28 <int80_h> is there a typeclass I can make my type an instance of, such that I will be able to do boolean operations on it?
16:12:31 <scrappy_doo_> JoeyA (map fromJust) . (filter isJust)?
16:12:38 <tgeeky_> Cale: thanks muchly for that!
16:12:45 <shachaf> Aune: You might need to add ~/.cabal/bin to your path.
16:12:47 <shachaf> scooty-puff: :-(
16:12:52 <shachaf> @ty catMaybes
16:12:53 <lambdabot> forall a. [Maybe a] -> [a]
16:13:07 <lpsmith> jerry,  it performs a monadic action purely for effect,   ignoring the return result,  and then executes another monadic action.
16:13:24 <JoeyA> Well, in my case, I'm applying a function to a value that produces a Maybe.  I want to guard to ensure that it is a Just, but I also want to use the original value.
16:13:28 <jerry> lpsmith: tx
16:13:29 <JoeyA> (before applying the function)
16:13:57 <Cale> lpsmith: I did, though it's more understandable, and less a text thing than a cabal thing, cabal at one point also decided to install deepseq-1.2.0.1 for some reason in addition to 1.1.0.2, which caused me to reinstall text yet another time, because its NFData instance was for the NFData class in deepseq-1.2.0.1
16:14:09 <lpsmith> Well, technically speaking it doesn't execute anything,  rather it combines two monadic actions and returns a new monadic action that does just that,  but constantly referring to that is awkward
16:14:14 <gienah> Cale: the NFData instances have been moved from deepseq 1.2.0.1 into collections for ghc 7.4, so the easiest approach I guess would be to constrain deepseq to 1.1.0.2 for ghc 7..2
16:14:19 <shachaf> int80_h: Why do you want a type class?
16:14:45 <lpsmith> cale:  yeah, cabal-install is a wonderful thing when it works ;-)
16:15:07 <Cale> (and then of course, all the newly-broken packages from that point on)
16:15:24 <gienah> Cale: another approch that comes to mind is to conditionally patch deepseq 1.2.0.1 to add back in the missing NFData instance when building with ghc < 7.4
16:15:24 * shachaf >>= undefined
16:15:49 <Cale> I spent a few hours upgrading to ghc-7.2.1 yesterday, most of which was spent struggling to have a non-broken set of packages.
16:15:56 <Drakken> JoeyA original value sounds redundant
16:17:37 <gienah> Cale: for some packages you could look for how we built it in the gentoo haskell overlay: https://github.com/gentoo-haskell/gentoo-haskell
16:18:12 <gienah> Cale: the deepseq NFData stuff: http://www.haskell.org/pipermail/libraries/2011-August/016676.html
16:18:18 <powerc> is haskell awesome
16:18:36 <dylukes> @ask is haskell awesome?
16:18:36 <lambdabot> Consider it noted.
16:18:44 <dylukes> Er...
16:18:45 <tgeeky_> wait, that's not right
16:18:45 <Cale> Well, I also have special needs because there are a few patches against packages that are required to fix bugs for our game. (We've submitted the patches, but they haven't been applied by the maintainers yet)
16:18:46 <blackdog> @lambdabot can haskell be awesome?
16:18:46 <lambdabot> Unknown command, try @list
16:18:51 <tgeeky_> @vixen is haskell awesome?
16:18:52 <Ferdirand> @faq can haskell be awesome ?
16:18:52 <lambdabot> The answer is: Yes! Haskell can do that.
16:18:52 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
16:18:53 <blackdog> lambdabot: can haskell be awesome?
16:19:02 <dylukes> @vixen are you back!?
16:19:04 <blackdog> oh, vixen's back
16:19:13 <c_wraith> no, that's nixon
16:19:18 <dylukes> DAMN.
16:19:24 <dylukes> Mistaking Vixen for Nixon again :P.
16:19:26 <dylukes> @vixen
16:19:26 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
16:19:26 <c_wraith> also, you're looking for @faq I think
16:19:27 <Cale> I did eventually get everything working and up to date :)
16:19:32 <dylukes> @vixen
16:19:32 <lambdabot> Any change is resisted because bureaucrats have a vested interest in the chaos in which they exist.
16:19:47 <dylukes> @. elite nixon
16:19:48 <lambdabot> i'm 9LAD i'/\/\ no+ 8Rez|-|NEV. B3iN9 7hE ru$5ian |3adEr in 7h3 Kre/\/\|In. yoU NEVER kn0\/\/ If s0meOne'$ +AP3 r3C0RDinG \/\/HaT joo sAy.
16:19:50 <Cale> tgeeky_: Did that command help?
16:20:28 <Cale> tgeeky_: To be honest, I'm not sure it wouldn't just be easier to blow away ~/.ghc
16:20:34 <Aune> shachaf, didnt work ;(
16:20:40 <powerc> If I learned haskell would that by extension make me cool?
16:20:42 <gienah> Cale: the bug for deepseq NFData moved to containers: http://hackage.haskell.org/trac/ghc/ticket/5468
16:21:04 <Cale> gienah: what's in the deepseq package then, if not NFData?
16:21:13 <tgeeky_> Cale: it did
16:21:20 <tgeeky_> Cale: I'm re-installing now
16:21:36 <tgeeky_> Cale: though I think it's going to break, again.
16:21:58 <Cale> tgeeky_: just be careful if you see it installing a package that you already installed
16:22:09 <tgeeky_> Cale: yeah, I don't know how to stop it.
16:22:10 <Cale> I *really* hate that it does that.
16:22:16 <blackdog> powerc: probably not. i'm still waiting for my parade.
16:22:36 <Cale> powerc: It won't make you cool, but it might make you more powerful.
16:22:46 <powerc> I can live with power
16:22:48 <theddy> Cale: Thought you mentioned iOs earlier.... Are you by chance compiling for ARM with a registered build of ghc?
16:23:32 <dylukes> powerc: It will give you an appreciation for strong/static type systems.
16:23:32 <theddy> powerc:  it wont make you cool by extension, it will make you cool by abstraction
16:23:43 <dylukes> theddy: ^
16:23:45 <Cale> theddy: We are compiling for ARM with a custom GHC backend. I am kinda hazy on the details, you'd be better off asking blackh (Stephen Blackheath) about it
16:24:19 <Cale> theddy: But we do plan on getting our changes back into GHC proper.
16:24:27 <powerc> theddy I see what you did there
16:24:41 <dylukes> Cale: couldn't you use the LLVM backend?
16:25:13 <Cale> dylukes: There's been talk of that as well, I think there's work ongoing on that -- it may actually already be working.
16:25:27 <koeien> are those restrictions lifted by Apple now?
16:25:34 <dylukes> koeien: which restrictions?
16:25:35 <theddy> Cale: Thanks - was waiting on his project to be updated to ghc7
16:25:40 <Cale> koeien: The restrictions only ever really applied to Adobe anyway.
16:25:48 * koeien remembers something about programs needing to be "originally written in C,C++ or ObjC"
16:25:53 <Cale> yes
16:26:12 <Cale> That was specifically aimed at preventing Adobe from releasing flash for iOS.
16:26:21 <Cale> and never applied to anyone else
16:26:35 <Cale> and has since been removed anyway
16:26:43 <koeien> ah cool
16:26:56 <Ferdirand> what's flash written in ?
16:27:12 <powerc> flash
16:27:23 <c_wraith> it has been replaced by the restriction that your application not be allowed to download and execute code
16:27:54 <c_wraith> Which still kills flash, but also javascript!  So making a web browser is breaking the rules
16:28:02 <Ferdirand> and how to they set the border between data and code ?
16:28:06 <Ferdirand> -t+d
16:28:12 <c_wraith> yeah, they don't address that either
16:28:24 <c_wraith> it's apple.  They'll remove your app if they feel like it.
16:28:28 <c_wraith> with or without explanation
16:28:28 <Cale> The same way they do with pornography in the App Store?
16:28:54 <Cale> "We'll know it when we see it, and we know what's best for you."
16:29:47 <Cale> Apple has somehow become more evil than I think Microsoft ever was.
16:29:49 <Aune> shachaf, I gor it to work now, had to uninstall and then reinstall some packages
16:30:17 <powerc> is this statement true haskell > python
16:30:27 <Cale> powerc: define >
16:30:42 <Cale> > "haskell" > "python"
16:30:43 <lambdabot>   False
16:30:50 <Cale> It's not lexicographically true
16:30:54 <pwseo> lool
16:31:06 <powerc> damn I just got haskell'd
16:31:51 <hpc> > "is this statement true haskell" > "python"
16:31:51 <lambdabot>   False
16:32:09 <Ferdirand> > let (haskell,python) = (1,0) in haskell > python
16:32:10 <lambdabot>   True
16:32:22 <incluye> > let (haskell,python) = (0,1) in haskell > python
16:32:23 <lambdabot>   False
16:32:32 <mdxbhmt> heresy
16:32:36 <mdxbhmt> lol
16:32:59 <mdxbhmt> @quote python
16:32:59 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:33:15 <hpc> wtf is that bug?
16:33:19 <mdxbhmt> @quote monad
16:33:19 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
16:33:27 <mdxbhmt> @quote python
16:33:27 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
16:33:33 <koeien> no quotes about python, then.
16:33:34 <mdxbhmt> @.@'
16:33:34 <lambdabot> Maybe you meant: . @
16:33:40 <koeien> partial functions are evil :)
16:33:41 <hpc> monads are like burritos, they make it hard to poop?
16:34:13 <powerc> I have one thing to say.... its over 9,000
16:34:19 <mdxbhmt> @quote youwontfindanything
16:34:19 <lambdabot> No quotes match. I am sorry.
16:34:32 <mdxbhmt> yeah, bug on python
16:34:33 <koeien> mdxbhmt: curious.
16:35:24 <powerc> wait why are we talking about python
16:36:31 <mdxbhmt> powerc: I think it was you how started this with your question ahahahahah
16:37:15 <powerc> I have the power!
16:37:20 <acowley> Reviewing a paper where they name their threaded state as "Id" and I twitch everytime I read it. I can't figure out a way in which I'd think that was a good variable name, anyone have any ideas?
16:38:48 <mdxbhmt> "state"?
16:40:08 <blackdog> mdxbhmt: i think there are lots of good alternatives - suspect acowley was looking for insight into the author's twisted mind
16:40:23 <acowley> yes, precisely
16:40:39 <acowley> Since space is always a premium, I think I would have gone with "S"
16:41:45 <acowley> although I will admit that using "id" as a field of a record is a common enough thing in other languages that Haskell beats out of you, so I'm probably overly sensitive to uses of "id" or "Id"
16:44:15 <mdxbhmt> blackdog: certainly
16:45:43 <mdxbhmt> probably the autor was so eager to release it's paper that he chose id because it was shorter
16:47:13 <blackdog> acowley: i think it's still reasonable to use fooId in haskell ORMs
16:48:02 <acowley> blackdog: You're right, and for ORMs it's hard to avoid something like that, but I try to avoid type name prefixing of record fields whenever possible.
16:48:42 <acowley> blackdog: Coming from another language, you'd probably expect an ORM to use a HasIndex class with a method id::a -> Integer or something along those lines.
17:04:04 <rostayob> is there any way to do prolog-style logic programming in haskell? I'm sure hackage.haskell.org/package/logict would help but unification is a problem
17:04:23 <rostayob> there's this package: http://hackage.haskell.org/package/unification-fd but I can't really understand how to use it
17:05:41 <rostayob> what I'd like is something like kanren ( http://kanren.sourceforge.net/ ), which enables logic programming in scheme, but for haskell
17:06:10 <rostayob> but I can see why it's a lot easier in scheme (dynamic typing, uniform data)
17:06:52 <Saizan> you could use some TH or SYB to write a generic unification algorithm
17:07:06 <rostayob> yes I was thinking about SYB to traverse data types
17:07:06 <Saizan> or even the Generics extension
17:08:52 <rostayob> Saizan: Generics extension = ?
17:09:36 <rostayob> is there a list of all the language extensions? browsing the GHC manual is quite hard
17:10:20 <Saizan> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/generic-classes.html
17:11:25 <rostayob> mhm yeah apparently it's deprecated now (GHC HEAD)
17:11:27 <rostayob> thanks
17:11:31 <kmc> ghc --supported-languages
17:11:47 <rostayob> kmc: whoa, thanks
17:11:59 <kmc> the Generics extension is deprecated; GHC 7.2 added DeriveGeneric instead
17:12:01 <rotflcopter> fromintegral converts to float, what converts to int ?
17:12:01 <kmc> which seems much better
17:12:08 <rostayob> so I can assume that something like that doesn't exist already? It'd be a nice project
17:12:09 <kmc> rotflcopter, fromIntegral also
17:12:14 <kmc> it converts to any Num type
17:12:15 <rotflcopter> hmmm
17:12:46 <Axman6> :t fromIntegral
17:12:47 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:13:11 <Axman6> fromIntegral converts any Integral type to any Num type (and all Integral tpyes are Num types)
17:13:51 <Axman6> > fromIntegral (7 :: Integer) :: Int
17:13:52 <lambdabot>   7
17:14:11 <doserj> if your input isn't integral, you want something like round, or floor, etc.
17:16:17 <yitz> perhaps the earliest connection (sort of) between haskell and category theory:
17:17:16 <yitz> haskell curry, after whom haskell is named, and saunders maclane, who later founded category theory, were two americans who both earned a phd in mathematical logic in Göttingen around the same time.
17:17:54 <yitz> curry's advisor was david hilbert, and maclane's advisor was hilbert's student hermann weyl
17:18:20 <platzhirsch> this is amazing!
17:18:57 <yitz> maclane arrived in Göttingen probably just after curry left. it is likely maclane knew of curry and his work, even though they may not have met
17:19:14 <rotflcopter> why does it cause error if i add round to a float ?
17:19:19 <rostayob> Saizan: it looks like you could write a unification algorithm using GHC.Generics. Thanks
17:19:28 <koeien> i thought Weyl worked in analysis
17:19:32 <rotflcopter> Ambiguous type variable `t0' in the constraints:
17:19:32 <rotflcopter>       (RealFrac t0) arising from a use of `circlefirstoctant'
17:19:42 <koeien> rotflcopter: can you paste your code somewhere?
17:19:43 <koeien> @hpaste
17:19:43 <lambdabot> Haskell pastebin: http://hpaste.org/
17:20:08 <kmc> heh cool yitz
17:20:54 <Ferdirand> dear #haskell, I never remember which ones of any/all and or/and operate on predicates vs bools. Is there a trick to remember that, or a rationale behind the names ?
17:21:08 <kmc> :t all even
17:21:09 <lambdabot> forall a. (Integral a) => [a] -> Bool
17:21:14 <kmc> this reads pretty well as english
17:21:30 <doserj> rotflcopter: either the compiler doesnt know the type of the input to round, or the type of the output of round
17:21:46 <kmc> the relationship between 'and' and (&&) is like the relationship between 'maximum' and 'max'
17:21:46 <rotflcopter> well im currently leaving
17:21:48 <shachaf> Ferdirand: "or" is a fold of "||", which is also pronounced "or".
17:21:52 <kmc> spelling it out more indicates the version which works on lists
17:21:52 <rotflcopter> so
17:22:01 <rotflcopter> bb <;
17:22:10 <rotflcopter> but still bothers me
17:22:23 <Ferdirand> @t any
17:22:23 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:22:23 <rotflcopter> code working, displaying float array, if i add round it fails
17:22:26 <Ferdirand> @type any
17:22:27 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:22:56 <Ferdirand> mhh, weird brain glitch
17:23:13 <Ferdirand> i expected this to be [(a -> Bool)] -> a -> Bool
17:23:40 <Drakken> rotflcopter what does "add round" mean?
17:23:50 <Ferdirand> that was a stupid question, disregard it
17:24:46 <RaptorRarr> Why are existential types called existential?
17:25:09 <kmc> because they correspond to existential quantification in logic
17:25:13 <kmc> "there exists x such that..."
17:25:14 <RaptorRarr> How?
17:25:33 <kmc> do you know about the correspondence between types and logic in general?
17:25:34 <shachaf> RaptorRarr: Directly.
17:25:38 <RaptorRarr> I mean, it seems like there's just as much of "there's a type that fits here" in regular Haskell types.
17:25:49 <RaptorRarr> Not really.
17:26:12 <kmc> http://en.wikipedia.org/wiki/Curry-Howard_correspondence
17:26:18 <kmc> i don't know if this article is actually good
17:26:24 <shachaf> "x :: exists p. p" ~ "there exists a p such that x is of type p"
17:26:28 <dodgems> rotflcopter: round returns an Integral.. to get a Number out of it, use fromIntegral.. fromIntegral (round x) + y
17:26:44 <kmc> RaptorRarr, anyway, types are propositions; programs are proofs of their type
17:26:45 <shachaf> I don't think you need to understand Curry-Howard particularly well to understand existential quantification.
17:26:57 <kmc> the type T stands for the proposition "type T is not empty"
17:27:06 <kmc> which sounds really boring at first
17:27:24 <kmc> «3 :: Int», so 3 is a "proof" that Int is not the empty type
17:27:28 <kmc> whatevs
17:27:42 <kmc> but it starts to get interesting when you look at types built out of other types
17:27:48 <kmc> the tuple type (A,B) is a proof of "A and B"
17:27:53 <kmc> that is, it's a proof of A and a proof of B
17:27:58 <kmc> the type (Either A B) is a proof of "A or B"
17:28:10 <kmc> it's a proof of A, or a proof of B, and it tells you which
17:28:14 <kmc> does this make sense so far?
17:28:23 <RaptorRarr> Yes, so far.
17:28:37 <kmc> then the function type (A -> B) is a proof of "A implies B"
17:28:43 <kmc> "if you give me a proof of A, i'll give you a proof of B"
17:29:04 <RaptorRarr> Is that because, if you have a function that takes any A and gives a B, you know a nonempty A means a nonempty B?
17:29:08 <kmc> *nod*
17:29:14 <RaptorRarr> Alright.
17:29:21 <kmc> ignoring the fact that Haskell functions can cheat and return "undefined"
17:29:24 <rostayob> in the end, Haskell type systems doesn't really correspond to anything, since you can prove whatever you like
17:29:27 <rostayob> oh right.
17:29:28 <kmc> Haskell is an unsound logic
17:29:31 <kmc> fix :: (a -> a) -> a
17:29:34 <kmc> if A implies A, then A!
17:29:37 <kmc> derp
17:29:43 <kmc> but anyway
17:29:54 <shachaf> undefined :: a
17:29:54 <kmc> the "forall" of GHC Haskell corresponds to universal quantification
17:30:02 <shachaf> kmc: "fix" isn't primitive, recursion is.
17:30:06 <rostayob> :t let x = x in x
17:30:07 <lambdabot> forall t. t
17:30:14 <rostayob> you don't even need undefined
17:30:15 <kmc> second-order quantification, which is to say quantification over types / propositions
17:30:26 <rostayob> just recursion yo
17:30:37 <shachaf> rostayob: Right, that's what undefined is.
17:30:44 <kmc> i can write a function of type «forall a b. (a, b) -> a»
17:30:44 <rostayob> shachaf: well not exactly but yeah
17:30:53 <RaptorRarr> What does 'forall t. t' mean in terms of types having a member?
17:31:09 <kmc> i don't understand the question
17:31:18 <shachaf> rostayob: Denotationally.
17:31:20 <RaptorRarr> Or types that aren't empty.
17:31:35 <shachaf> rostayob: If x :: forall t. t, that means "for any type t, the type t is inhabited"
17:31:45 <RaptorRarr> Like a -> b is a proof that if a is nonempty, then b must be nonempty.
17:31:56 <kmc> my function above is a proof that "for any propositions A, B,  if (A and B) then A"
17:31:58 <rostayob> shachaf: yes I know that, but undefined and fix id have different semantics in haskell
17:31:58 <shachaf> s/rostayob/RaptorRarr/
17:32:08 <kmc> that "for any proposition" bit is second-order universal quantification
17:32:08 <shachaf> rostayob: Not denotationally.
17:32:21 <shachaf> rostayob: (Also, that wasn't meant to be addressed to you.)
17:32:22 <rostayob> shachaf: right
17:32:31 <RaptorRarr> shachaf: So, that would be untrue if there were any empty types?
17:32:40 <shachaf> RaptorRarr: Yep.
17:32:45 <shachaf> Which there are.
17:32:58 <shachaf> "forall t. t" is an example of an empty type. :-)
17:33:07 <RaptorRarr> How is it a type?
17:33:28 <kmc> RaptorRarr, you might like to read http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
17:33:32 <shachaf> > let x :: forall t. t; x = undefined in x
17:33:33 <lambdabot>   *Exception: Prelude.undefined
17:34:56 <RaptorRarr> kmc: Thanks, I will.
17:35:34 <ion> What does equivalence in propositional logic correspond to?
17:35:34 <mdempsky> RaptorRarr: You're familiar with existential/universal quantifiers in a math context?
17:35:56 <RaptorRarr> Yeah, the first-order logic (and I think I get the second-order, too) version.
17:35:57 <rostayob> RaptorRarr: if you want to learn about types, types and programming languages is a good book. i spilled coffee over the library copy and i ended up reading it.
17:36:00 <rostayob> well i am reading it.
17:36:02 <rostayob> true story.
17:36:08 <RaptorRarr> Haha
17:36:14 <rostayob> 45£, the bastard
17:36:36 <RaptorRarr> Ouch
17:37:01 <mdempsky> RaptorRarr: My understanding of the 'existential types' extension is just that it lets you control the scope of the quantifiers, whereas Haskell 98 only allows quantifiers at the 'top' of a type.
17:37:23 <mauke> mdempsky: no, that's rank n types
17:37:28 <mdempsky> mauke: Oh?
17:37:41 <ben> I thought rank n types is the extension you need to use existential types
17:37:41 <rostayob> mdempsky: existential types lets you quantify inside data declarations
17:37:50 <kmc> no, ExistentialQuantification is
17:38:21 <kmc> a value of type «∀x. T x» is like a function from types to terms
17:38:28 <kmc> if you give it any type x, you get a term of type (T x)
17:38:31 <RaptorRarr> So, you can't (in a 'proper' type system) make a program that implements forall t. t, right?
17:38:46 <kmc> this function interpretation is explicit in System F, which has Λ (big-lambda) for abstraction over types
17:38:47 <rostayob> RaptorRarr: well it depends what you mean with proper :P
17:39:03 <rostayob> but for example, in System F (and in agda) you can't
17:39:03 <Cale> I guess it's easy to confuse ExistentialTypes and RankNTypes because they both involve forall somehow, but that's about the extent of their similarity ;)
17:39:09 <RaptorRarr> Ahh, OK.
17:39:19 <kmc> whereas a value of type «∃x. T x» is like a pair of a type and a term
17:39:36 <kmc> it's a type x and a value of type (T x)
17:39:55 <rostayob> RaptorRarr: but yes haskell type system is unsound as others have said, and so is ML type system. the problem in those is general recursion (both in 'let' and in recursive types)
17:40:06 <RaptorRarr> Ahh, OK.
17:40:06 <Cale> RaptorRarr: In a type system for a Turing complete language, you generally will be able to write a term with that type.
17:41:33 <shachaf> ∄x. T x
17:41:53 <kmc> Cale, they're related by a CPS transform
17:42:33 <kmc> «∃x. T x»  ⇒  «∀r. (∀x. T x → r) → r»
17:43:09 <RaptorRarr> So, a function of type Num a, Num b => a -> b is a proof that, if all num types are nonempty, then all num types are nonempty?
17:43:12 <RaptorRarr> Or something else?
17:43:56 <hpaste> “recursion is cool, lazyness is cool” pasted “rostayob” at http://hpaste.org/53422
17:43:57 <kmc> it's a proof that, for any two Num types a,b,  then if a is nonempty so is b
17:44:19 <RaptorRarr> Ahh, I see.
17:44:21 <kmc> which has the consequence that, if any Num type is inhabited, they all are
17:44:53 <shachaf> Of course, a trivial proof of that type is "const 1". :-)
17:45:04 <Cale> Or undefined ;)
17:45:07 <kmc> yeah, Haskell provides a direct proof that all Num types are inhabited
17:45:09 <Cale> hehehe
17:45:10 <kmc> even without undefined
17:45:53 <Cale> instance Num Void where
17:46:08 <yitz> kmc: not really. the literal 1 can produce _|_ .
17:46:11 <shachaf> Cale: Void doesn't obey the Num laws.
17:46:18 <Cale> Oh?
17:46:25 <RaptorRarr> instance Num ()
17:46:26 <shachaf> Well, maybe it does.
17:46:42 <kmc> yitz, what I said "without undefined" I meant to exclude that possibility
17:46:50 <Cale> 0 = 1 = undefined
17:47:15 <kmc> () is a fine group
17:47:19 <kmc> it's not so great as a ring
17:47:30 <Cale> It's a ring too
17:47:38 <yitz> it's just not a ring with 1.
17:47:39 <kmc> it's not a ring-with-1
17:47:41 <Cale> It's the unique ring in which 0 = 1
17:47:41 <kmc> *nod*
17:47:48 <Cale> It has a 1!
17:47:49 <mauke> if you like it, then you should've put a monoid on it
17:47:51 <kmc> heh
17:47:53 <Cale> () * () = ()
17:47:57 <Cale> So () = 1 is fine
17:48:09 <rostayob> RaptorRarr: #haskell reflects how peculiar Haskell is.
17:48:20 <kmc> does it?
17:48:23 <rostayob> yeah
17:48:35 <mauke> haskell reifies #haskell
17:48:48 <kmc> #haskell reflects how peculiar the people who choose to discuss a programming language for fun on IRC are
17:49:15 <kmc> the "for fun" part is unusual among the language channels on freenode
17:49:19 <rostayob> kmc: well but #haskell is the place where those people go
17:49:27 <shachaf> kmc: It is?
17:49:34 <RaptorRarr> #ruby-lang used to be like that, until the Rails explosion.
17:49:40 <rostayob> kmc: that's not true
17:49:48 <rostayob> maybe #agda
17:49:54 <rostayob> or #ocaml, or whatever
17:50:06 <rostayob> but #haskell wins in terms of size & quality i think
17:50:21 <kmc> the proportion of traffic here which is "/join; ask question; receive answer; /part" is abnormally low
17:50:29 <kmc> rostayob, what's not true?
17:50:37 <rostayob> kmc: that all language chans are like this one
17:50:44 <kmc> what
17:50:45 <rostayob> in terms of content
17:50:50 <kmc> when did i say that
17:51:04 <yitz> @faq Can Haskell inspire the best IRC channel?
17:51:05 <lambdabot> The answer is: Yes! Haskell can do that.
17:51:17 <rostayob> <kmc> the "for fun" part is unusual among the language channels on freenode
17:51:17 <kmc> great now I've set off another round of self-congratulation
17:51:28 <rostayob> ah.
17:51:31 <rostayob> unusual.
17:51:47 <rostayob> I read usual
17:51:50 <kmc> neither "many" nor "few" means "all" nor "zero"
17:52:15 <kmc> when I make a claim like "foo is fairly common" people keep trying to refute me with single counterexamples
17:52:21 * hackagebot happstack-server 6.2.5 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.2.5 (JeremyShaw)
17:52:32 <copumpkin> kmc: nuh uh, I saw you say that once and nobody refuted you
17:52:37 <kmc> :D
17:52:41 <blackdog> kmc: buzzharsher
17:52:54 <rostayob> speaking of types, i've got a type systems lecture in 8 hours, night
17:53:14 <RaptorRarr> rostayob :: Sleeping Person
17:53:25 <copumpkin> did his type really change?
17:53:37 <RaptorRarr> Yes.
17:53:42 <shachaf> Mutable types are the future.
17:53:50 <RaptorRarr> Yes!
17:53:59 <copumpkin> how many languages allow that?
17:54:08 <shachaf> All the cool ones.
17:54:13 <copumpkin> I can't think of any
17:54:17 <RaptorRarr> I suppose you could say Ruby does that.
17:54:21 <DasIch> copumpkin: python does more or less
17:54:37 <RaptorRarr> You can reassign something with a different class or use evil.rb to change the class.
17:54:45 <copumpkin> oh, well
17:54:49 <copumpkin> that isn't language
17:54:57 <copumpkin> RaptorRarr: I'm saying you have an instance of a class
17:55:03 <copumpkin> and the language allows you to change that instance's type
17:55:14 <RaptorRarr> Yeah, evil.rb lets you do that, if I remember.
17:55:23 <kmc> i think there are many people who program in Haskell regularly but would not be comfortable as active regulars in #haskell
17:55:36 <copumpkin> because we're too awesome for them
17:55:41 <DasIch> copumpkin: in python you can do that by setting the __class__ attribute
17:55:46 * copumpkin initiates back-patting session
17:55:52 <copumpkin> DasIch: ah, ok
17:55:55 <kmc> basically I agree that it reflects the weirdness of the language, but through a crazy-shaped mirror which catches a bunch of other stuff
17:56:36 <RaptorRarr> copumpkin: http://www.koders.com/ruby/fid071535C0BD128E011EDCB3D9E4EFF0EE14607435.aspx#L413
17:57:23 <copumpkin> RaptorRarr: yeah, I've played with it before, but I'd hesitate to call that "ruby"
17:57:25 <kirindave> Does anyone know if there is an updated version of that mother-of-all-monads post?
17:57:30 <copumpkin> in the same way I wouldn't call the IO internals of GHC part of haskell
17:57:52 <xenocryst> I'm trying to do something like: takeWhile (current sum < constat) [infinite list], but I don't know how to do it since takWhile has no memory
17:57:55 <xenocryst> Any pointers?
17:58:00 <RaptorRarr> copumpkin: Ahh, I see.
17:58:55 <RaptorRarr> xenocryst: You can get the current sum using scanl, zip that with the list, takeWhile, map to get rid of the scanl.
17:58:57 <copumpkin> > map fst . takeWhile ((<10) . snd) . ap zip (scanl (+) 0) $ [1..10]
17:58:59 <lambdabot>   [1,2,3,4]
17:59:07 <RaptorRarr> Yeah, that :)
17:59:26 <xenocryst> thanks guys!
17:59:27 <copumpkin> RaptorRarr: I'm just really fast at typing! I saw your response and typed it out
17:59:35 <RaptorRarr> Haha
17:59:51 <RaptorRarr> That's insanely fast typing if true.
18:00:07 <copumpkin> > ap zip (scanl (+) 0) $ [1..10]
18:00:08 <lambdabot>   [(1,0),(2,1),(3,3),(4,6),(5,10),(6,15),(7,21),(8,28),(9,36),(10,45)]
18:00:15 <copumpkin> whoops, off by one :)
18:00:24 <copumpkin> > map fst . takeWhile ((<10) . snd) . ap zip (scanl1 (+)) $ [1..10]
18:00:26 <lambdabot>   [1,2,3]
18:03:36 <dobblego> @type (.:)
18:03:37 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:03:50 <dobblego> which package is this function in?
18:03:59 <shachaf> dobblego: lambdabot
18:04:17 <dobblego> oh
18:04:21 <dobblego> I thought it was on hackage
18:04:39 <sal23> given a function f::a , what does that mean for the function's type? Asking because normally a function type signature is f:: a -> b -> ...
18:04:52 <shachaf> dobblego: lambdabot is on hackage. :-)
18:05:05 <shachaf> sal23: That's not necessarily a function.
18:05:24 <shachaf> sal23: If it is a function, it means that "a" is actually "b -> c" for some "b" and "c".
18:05:37 <sal23> shachaf, yes, thought so
18:07:05 <xenocryst> copumpkin: I've been messing with your one liner, and I have no idea how ap makes zip do the right thing in this case
18:07:24 <copumpkin> :t ap zip (scanl (+))
18:07:25 <lambdabot>     Couldn't match expected type `[b]'
18:07:26 <lambdabot>            against inferred type `[[a]] -> [[a]]'
18:07:26 <lambdabot>     In the second argument of `ap', namely `(scanl (+))'
18:07:33 <xenocryst> I thought I was good with applicative functors, but I suppose wrong
18:07:35 <copumpkin> :t ap zip (scanl1 (+))
18:07:36 <lambdabot> forall b. (Num b) => [b] -> [(b, b)]
18:07:40 <copumpkin> so basically
18:07:55 <copumpkin> it's equivalent to \xs -> zip (scanl1 (+) xs) xs
18:08:07 <copumpkin> or wait, the other way around
18:08:08 <copumpkin> :)
18:08:10 <xenocryst> heh
18:08:17 <copumpkin> zip xs (scanl1 (+) xs)
18:08:17 <xenocryst> this is really awesome stuff. Again, thanks
18:08:28 <copumpkin> np
18:09:54 <dolio> zip (scanl1 (+) xs) xs = zip =<< scanl1 (+)
18:10:16 <magicman> @type ap zip
18:10:18 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
18:11:18 <Axman6> :t ap zip . map
18:11:18 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
18:11:57 <Axman6> > (ap zip . map $ replicate 3) [1,2,3]
18:11:58 <lambdabot>   [(1,[1,1,1]),(2,[2,2,2]),(3,[3,3,3])]
18:12:21 <magicman> :t Data.Map.fromList . ap zip . map
18:12:22 <lambdabot>     Couldn't match expected type `[a1 -> (k, a)]'
18:12:22 <lambdabot>            against inferred type `[a2] -> [b] -> [(a2, b)]'
18:12:22 <lambdabot>     In the first argument of `ap', namely `zip'
18:12:27 <magicman> Oh, right.
18:12:27 <Cale> lpsmith: Oh, just remembered another problem I had involving text: when I installed hexpat afterward, it wanted to force me to rebuild text every time. Building text, network, parsec, and hexpat together was my ultimate solution to that problem.
18:12:28 <Sgeo|web> I may have convinced my teacher to look at Haskell based mostly on the function definition syntax
18:13:39 <shachaf> Sgeo|web: Did your teacher say "oh, that looks like a language that encourages equational reasoning"?
18:14:18 <Sgeo|web> Not really. He said it looked like it would have been useful for a program he once wrote
18:21:01 <int80_h> :q
18:21:06 <int80_h> :quit
18:21:07 <int80_h> exit
18:21:21 <Sgeo|web> He did make a comment about Lisp
18:21:45 <wyfrn> Hi all ... Anybody familiar with CmdArgs? Is there a way to set a default value for an option wich is classified as enum?
18:27:24 <hpaste> “bitpacked hamt charset” pasted “edwardk” at http://hpaste.org/53423
18:27:41 * edwardk gets pasted
18:32:25 * hackagebot dns 0.3.1 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.3.1 (KazuYamamoto)
18:33:34 <Cale> Heh, gmail asked me what I liked best about the new layout, and I responded with "The extent to which it is the same as the old layout."
18:33:37 <c_wraith> you won't get pasted so long as you don't go to that url
18:34:15 <yitz> wyfrn: i did that, but i tried a few things and i'm not sure which made it work, or all were needed
19:00:56 <hpaste> edwardk annotated “edwardk” with “more HAMT charset silliness” at http://hpaste.org/53423#a53425
19:01:42 <edwardk> cale: my biggest problem with the new layout is i had kinda liked the 'tree' theme in the old version, which under the new version is pretty noisy
19:03:34 <Cale> edwardk: I can't stand text-on-pictures.
19:03:43 <edwardk> *nods*
19:04:02 <Cale> In fact, I'm annoyed enough at the dark-grey-on-light-grey text.
19:04:24 <edwardk> thats my problem. the old one put a big block around the inbox, but now its gone so you have to read the "Priority Inbox" etc labels on whatever random background that theme puts up (it bases it on your local weather)
19:04:40 <Cale> I think it should be a rule that if either the foreground or background is anything other than 100% white or 100% black, then the other ought to be.
19:04:40 <edwardk> i use it as my only cue as to whether or not i should bring my umbrella/jacket, etc.
19:05:09 <mm_freak> which GHC package introduced base 4?
19:05:18 <mm_freak> 6.10, i think?
19:17:40 <byorgey> edwardk: as far as I know the promotion/kind polymorphism stuff is slated for 7.4
19:17:40 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
19:17:51 <edwardk> yay!
19:18:23 <copumpkin> yay!
19:18:38 <byorgey> yay!
19:18:56 <byorgey> now don't quite me on that
19:18:57 <edwardk> looking forward to Dict as a functor from Constraint -> * =)
19:19:00 <byorgey> *quote
19:19:07 <byorgey> yes =)
19:19:17 <edwardk> er from (:<=) to (->)
19:19:32 <edwardk> reminds me i need to write up the liskov substitution post
19:19:37 * copumpkin makes sure to quote byorgey on that
19:19:39 <edwardk> did you see the code i had for that?
19:19:41 <kmc> yay!
19:20:52 <hpaste> edwardk pasted “Liskov Substitutability of Constraint Kinds” at http://hpaste.org/53426
19:21:13 <edwardk> apparently they fixed the bug that was making me comment out those two instances
19:21:28 <edwardk> and with the kind polymorphism Cat can become just Category
19:22:44 <edwardk> so, if class associated type defaults can have a more restricted kind than the most general, so Functor could be generalized without requiring overhead for average users then Dict can become a Functor from (:<=) to (->)
19:27:52 <byorgey> hah, I love that you can now write things like runDict :: Dict a -> (a => r) -> r
19:28:00 <byorgey> it looks so wrong and yet so right
19:28:12 <edwardk> =)
19:28:39 <edwardk> i confess i expected large swathes of that not to typecheck
19:28:58 <edwardk> the early versions weren't as pretty
19:29:28 <edwardk> (//) let me get rid of most of the cases
19:29:39 <edwardk> since i need to only open up dicts in very restricted contexts
19:30:08 <edwardk> (//) :: a => (b => r) -> (a :<= b) -> r made me very happy
19:30:54 <edwardk> but instance Instance (Class (Class (Class a))) where type Context (Class (Class (Class a))) = (Class a, Class (Class a)) is probably the most absurd statement in the whole thing
19:30:59 <byorgey> instance (Class a, Class (Class a)) => Class (Class (Class a)) where  -- wtf
19:31:12 <edwardk> consider the class Class
19:31:32 * byorgey considers
19:31:51 <edwardk> instance Class (Ord a)         where type Super (Ord a) = Eq a; super = Sub Dict
19:31:59 <byorgey> yup
19:32:11 <edwardk> supplies the typing information from   class Eq a => Ord a where ...
19:32:16 <byorgey> right
19:32:48 <edwardk> but now we want the instance of Instance for that instance, etc.
19:33:00 <edwardk> since instance Class (Ord a) is an Instance
19:33:37 <byorgey> ohhh, I see
19:33:45 <byorgey> so where does it stop?
19:33:51 <edwardk> so i need to bootstrap the tower
19:33:55 <byorgey> yeah
19:34:16 <edwardk> it doesn't =) it has a base case and you can ask for as many Class (Class (Class (Class (Class a)))))) layers as you need
19:34:32 <edwardk> so it closes the reflection
19:35:06 <edwardk> two base cases and an induction principle
19:35:16 <edwardk> (the version i pasted has a bug, but the idea is right)
19:35:21 <byorgey> heh, I see
19:35:26 <rwbarton> why do you need two base cases? that confused me
19:35:44 <rwbarton> though I didn't think about it very hard at all
19:36:03 <edwardk> consider instance Eq a => Eq [a]
19:36:28 <edwardk> now we get instance Instance (Eq [a]) where type Context Eq [a] = Eq a
19:36:31 <rwbarton> oh is it to make the contexts work out right
19:36:37 <edwardk> but that instance has no context
19:36:55 <edwardk> so instance Instance (Instance (Eq [a])) where type Context (Instance (Eq [a])) = ()
19:37:13 <edwardk> but the Instance (Instance (Instance )))  can be bootstrapped uniformly
19:38:02 <edwardk> the Class instances there are meant to be Instance Instances, since the Class Class is pretty simple
19:38:17 <edwardk> er rather then Class (Class ()) instances are meant to be Instance instances
19:38:24 <edwardk> blech. say that 3 times real fast
19:39:32 <byorgey> edwardk++
19:39:37 <byorgey> this stuff is really cool =)
19:39:44 <edwardk> gets cooler with constraint kinds
19:39:46 <edwardk> er
19:39:49 <edwardk> with polymorphic kinds
19:40:10 <edwardk> i've been meaning to write up a blog post on this since i wrote it a couple weeks back
19:40:15 <byorgey> yes, I'm sure it does!
19:40:19 <byorgey> edwardk: you should
19:40:44 <edwardk> i will. if this weekend goes by without a blog post. you may feel free to officially give me shit about it
19:40:48 <Philippa> edwardk: was it fortran or cobol that let you write something similarly bad with if statements?
19:41:54 <byorgey> edwardk: I will. =)
19:41:56 <edwardk> not sure what you mean
19:42:52 <edwardk> the cleaner version looks like
19:42:53 <edwardk> instance Class (Class h)       where super = Sub Dict
19:43:03 <edwardk> instance Instance (Class (Class h)) where inst = Sub Dict
19:43:40 <kmc> i wanna see this blog post :D
19:43:40 <edwardk> but the instance of Instance (Instance …)) picks up the current complexity
19:44:19 <edwardk> now, ideally, i'd be able to use TH to derive the instances of Instance automatically
19:44:52 <edwardk> since i need to derive 2 of them for every instance to fully reify the substitutability of constraints in the constraint system
19:47:17 <kmc> this shit is craaaaaazy
19:47:25 <kmc> i can't believe it's actually in GHC HEAD
19:48:22 <edwardk> =)
19:57:12 <edwardk> i'm not very happy with the Not and Bottom definitions though
19:57:29 <edwardk> since i can't really exploit them
20:02:22 <byorgey> is there any special name for a set equipped with an associative binary operation with a right but no left identity (or vice versa)?
20:06:38 <ybit> byorgey: let me know if you find this, i'm interested
20:06:40 <edwardk> "semigroup with left zeros"
20:06:51 <edwardk> or semigroup with right zeros
20:07:17 <edwardk> er guess not
20:07:18 <edwardk> hrmm
20:07:56 <byorgey> seems like that's for absorbing elements, not identities
20:08:01 <edwardk> yeah
20:08:22 <ybit> (M . x)
20:08:35 <roconnor> apparently we call it a LeftMonoid
20:08:42 <edwardk> there you go =)
20:08:46 <ybit> in category theory, the . symbol represents a binary operation iirc
20:08:47 <roconnor> though we probably made up that name
20:09:05 <byorgey> well, that's fine, I guess what I really want to know is what sort of properties it has
20:09:16 <ybit> i'll have to google associative binary opeation, not sure what the associative part is
20:10:12 <ybit> oh, drr
20:10:19 <byorgey> ybit: a binary operation + is associative if (a + b) + c == a + (b + c)  for all a,b,c
20:10:27 <ybit> si
20:10:36 <byorgey> so you can write  a + b + c + d + e  unambiguously
20:11:00 <rwbarton> apparently it is perhaps called a right monoid
20:11:23 <rwbarton> http://tinyurl.com/43wtfqz
20:11:24 <ybit> associativity, it seems to be the canonical introduction to operations on sets
20:11:41 <ybit> i'm a noob to this stuff, but i love it
20:11:57 <byorgey> ybit: they come up a lot, and non-associative operations tend to not be as useful
20:12:01 * ybit accepts criticism and corrections 
20:12:30 <Tekmo> So you don't think a tree is useful?
20:12:33 <Philippa> byorgey: or two involved two or more types/sets
20:12:47 <Philippa> *to involve...
20:12:59 <Philippa> wow, me no speak gud english tonight
20:13:17 <blackdog> Philippa: gud english can hard
20:14:21 <byorgey> searching for "right monoid" on the Google gives a lot of hits about "right monoid actions" which is not the same thing =(
20:14:51 <rwbarton> it took me a rather long time to even think of an example of one of these things :P
20:14:58 <rwbarton> considering how simple the example turned out to be
20:15:06 <reiddraper> I'm having trouble understanding an implementation of the average functon in Haskell, using applicative functors. The code is: avg = div <$> sum <*> (fromIntegral. length)
20:15:31 <byorgey> rwbarton: what was the example you thought of?
20:15:35 <rwbarton> x * y = x
20:15:43 <rwbarton> or maybe the other way
20:15:47 <reiddraper> In order to try to understand better, I rewrote it as: avg = (fmap div sum) <*> (fromIntegral . length)
20:15:52 <rwbarton> yeah this way, x * y = x for all x, y in S
20:16:27 <byorgey> reiddraper: OK
20:16:46 <byorgey> reiddraper: do you know what instance of Applicative is being used there?
20:16:49 <roconnor> reiddraper: step 1 - figure out what applicative functor is in use
20:17:24 <ybit> Philippa: blame it on teh gubmint
20:17:44 <reiddraper> as I understand it, (fmap div sum) is the applicative functor being passed to <*>
20:18:29 <reiddraper> the part I'm getting tripped up on starting to understand is how (fmap div sum) is even legal
20:18:53 <reiddraper> given the type signature of fmap
20:18:54 <Tekmo> Listen to byorgey
20:18:54 <reiddraper> (a -> b) -> f a -> f b
20:19:16 <byorgey> reiddraper: right, so let's figure out what a, b, and f are
20:19:47 <Axman6> :t fmap div sum
20:19:48 <lambdabot> forall a. (Integral a) => [a] -> a -> a
20:19:59 * ybit will unfortunately have to grep the logs later for this conversation, lots of reading to do in the next 30 minutes
20:20:01 <Axman6> @unpl fmap div sum
20:20:02 <lambdabot> fmap div sum
20:20:05 <Axman6> -_-
20:20:25 <byorgey> reiddraper: just for concreteness let's say  div :: Integer -> Integer -> Integer
20:20:32 <reiddraper> byorgey: ok
20:20:32 <Tekmo> So, we know from fmap's type signature that sum must be a functor
20:20:37 <byorgey> no need to get the Integral class confusing things for now
20:20:49 <byorgey> reiddraper: so a and b are?
20:21:00 <reiddraper> byorgey: Integer and Integer
20:21:23 <Axman6> :t div . sum
20:21:24 <byorgey> reiddraper: right. and now we must match f a against the type of sum
20:21:25 <lambdabot> forall a. (Integral a) => [a] -> a -> a
20:21:50 <byorgey> reiddraper: this is probably where you are getting tripped up, right?
20:22:02 <edwardk> woot
20:22:08 <Tekmo> Here, let me find a tutorial that has a list of functors
20:22:17 <Tekmo> So he's not completely lost
20:22:26 <reiddraper> byorgey: sorry, which "this"?
20:22:29 <edwardk> finally got instance (Instance (Instance a), Instance (Instance b)) => Instance (Instance (a, b)) where  type Context (Instance (a, b)) = (Context (Instance a), Context (Instance b))  -- to work
20:22:34 * monochrom loves chinese div sum lunch
20:22:48 <byorgey> reiddraper: matching 'f a' with the type of 'sum'
20:22:52 <edwardk> using inst = Sub (Dict // bimapS (inst :: Context (Instance a) :<= Instance a) (inst :: Context (Instance b) :<= Instance b))
20:22:59 <reiddraper> byorgey: ah yes
20:23:08 <reiddraper> byorgey: so it must be a functor?
20:23:15 <byorgey> reiddraper: so let's say  sum :: [Integer] -> Integer
20:23:25 <edwardk> that let me finally close the loop on all my Instance instances
20:23:32 <reiddraper> byorgey: yes
20:23:38 <byorgey> reiddraper: notice that we can rewrite this as  (->) [Integer] Integer
20:23:55 <byorgey> reiddraper: which can also be written as  ((->) [Integer]) Integer
20:24:00 <reiddraper> byorgey: i'm not familiar with that notation, but ok
20:24:13 <byorgey> reiddraper: It's the same as how 3 + 4 can be written (+) 3 4
20:24:16 <Tekmo> reiddraper: Or you can use the notation ([Integer] ->) Integer
20:24:34 <byorgey> Tekmo: that's not actually valid Haskell
20:24:42 <byorgey> although it's a useful informal notation
20:24:51 <Tekmo> Whatever helps him learn it
20:25:08 <reiddraper> byorgey: ok i'm following
20:25:20 <byorgey> reiddraper: ok. so now do you see how to match the type of sum with f a?
20:25:36 <byorgey> of course, we already know  a = Integer
20:25:43 <byorgey> so we have to match it with  f Integer
20:25:53 <byorgey> so what is f?
20:26:34 * reiddraper thinks
20:27:09 <reiddraper> byorgey: a "function" type?
20:27:29 <byorgey> well, sort of, but which one, specifically?
20:27:33 <edwardk> awww. finally ran into a place where i need (,) to be polykinded
20:27:47 <edwardk> i wanted to make class BifunctorS (t :: Constraint -> Constraint -> Constraint) where bimapS :: (a :<= b) -> (c :<= d) -> t a c :<= t b d
20:27:55 <reiddraper> byorgey: functor?
20:28:06 <edwardk> and make an instance of BifunctorS for (,)
20:28:10 <byorgey> reiddraper: no, that doesn't really make sense
20:28:12 <edwardk> but i can't do that with the current ghc
20:28:31 <Tekmo_> functor is a class
20:28:36 <byorgey> reiddraper: remember what we are trying to do: we are passing 'sum' as the second argument to 'fmap', which expects something of type 'f a'
20:28:37 <reiddraper> byorgey: right, ok
20:28:37 <Tekmo_> He's asking which instance of functor
20:28:58 <byorgey> reiddraper: and sum has type  [Integer] -> Integer, which can also be written as ((->) [Integer]) Integer
20:29:12 <byorgey> reiddraper: so we need   ((->) [Integer]) Integer = f a
20:29:34 <reiddraper> so ((->) [Integer]) ?
20:29:37 <byorgey> right!
20:29:57 <byorgey> reiddraper: it turns out that ((->) e)  is an applicative functor for any type e.
20:30:04 <byorgey> reiddraper: and now your job is to go read about how it works.
20:30:09 <byorgey> =)
20:30:30 <Tekmo_> Learn You a Haskell talks about it in their chapter on Functors
20:30:34 <byorgey> I recommend reading the typeclassopedia, although I am biased =)
20:30:36 <Tekmo_> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
20:30:38 <sagelywizard> In the example here (http://hackage.haskell.org/packages/archive/aeson/0.3.2.12/doc/html/Data-Aeson-TH.html#v:deriveFromJSON) what does ''Foo mean?
20:30:59 <Tekmo_> How much do you know about functors, reiddraper?
20:31:02 <reiddraper> byorgey: thanks, appreciate the help
20:31:16 <reiddraper> Tekmo_: I've gone through that chapter, but it didn't "stick" yet
20:31:24 <reiddraper> Tekmo_: clearly not enough :)
20:31:31 <byorgey> sagelywizard: it's a quoted data constructor name
20:31:44 <Tekmo_> Just keep trying
20:31:48 <reiddraper> Tekmo_: I'm getting caught up apparently understanding how a function is a functor
20:31:53 <Tekmo_> They are a really useful pattern
20:32:05 <byorgey> sagelywizard: sorry, I mean a quoted type constructor name
20:32:22 <byorgey> sagelywizard: ''Foo :: Name
20:32:59 <byorgey> reiddraper: yes, that's exactly what's going on in the example you gave.
20:33:06 <Axman6> reiddraper: the thing to note about the (->) functor is the type of fmap: fmap :: (a -> b) -> (c -> a) -> (c -> b)
20:33:32 <dabblego> the ((->) c) functor
20:33:34 <byorgey> reiddraper: now, intuitively, what is going on in that example is that a function argument is getting duplicated
20:33:35 <sagelywizard> byorgey: Oh, okay, thanks! I'll do some Googling. :-)
20:33:54 <Axman6> dabblego: yeah, was just too lazy to call it the function functor =)
20:34:05 <dabblego> lazy daisy
20:34:11 <byorgey> reiddraper: so  (div <$> sum <*> (fromIntegral . length)) [1,2,3] == div (sum [1,2,3]) (fromIntegral . length  $ [1,2,3])
20:34:21 <reiddraper> Axman6: got it
20:34:45 <byorgey> reiddraper: but to understand why you'll have to wrestle with the Functor and Applicative instances for ((->) e) for a while
20:34:48 <Axman6> reiddraper: if you've done a bit of haskell, that type should look familliar
20:35:18 <reiddraper> byorgey: yes I think you're right, I need to make sure my functor and applicative understanding is on sturdier ground
20:36:17 <reiddraper> byorgey: your deconstruction is helping
20:36:31 <byorgey> reiddraper: I'm glad =)
20:37:06 <reiddraper> thanks for the help all, going to do some more LYAH reading :)
20:47:26 * hackagebot text 0.11.1.8 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.8 (BryanOSullivan)
20:49:04 <napping> Objects are pretty messy. I think I've got a faithful encoding of single inheritance, but I don't see how to do checked downcasts (let alone extensibly)
20:50:13 <monochrom> use Dynamic or do something like it for checked downcasts
20:52:04 <napping> maybe with the Typeable1 instance
20:59:01 <kmc> I don't suppose Cabal defines a CPP macro which expands to the z-encoded package name...
21:03:06 <Cale> napping: Downcasts are evil anyway?
21:04:46 <Cale> Well, okay, I'll admit I haven't done that much object oriented programming lately, but in my experience, most downcasts that you see in typed OO languages were ones caused by either a lack of other type system features (like parametric polymorphism), or the fact that method implementations were tied to the class definitions.
21:04:47 <monochrom> not evil if you put a truckload of Maybe's on it
21:05:21 <monochrom> of course, naturally, you also want a kind of type-case to go with it.
21:07:37 <napping> I'm using types parameterized over a tail and a self type, so subclasses are actually instances of the parent
21:08:03 <napping> existential containers with a GADT tag describing the tail seems to allow downcasts
21:09:23 <mzero> Woot - my build of HP 2011.3.0.0 based on GHC 7.0.4 **works on Lion**
21:10:19 <endojelly> HP?
21:10:23 <endojelly> ah, haskell-platform
21:10:27 <monochrom> what?! 2011.3.0.0 and no one told me?!
21:10:57 <monochrom> or is it announced just hours ago and my mail server has been down?
21:11:56 <kmc> not on the website
21:12:27 <kmc> why are the last two version components necessary?
21:12:32 <kmc> i'd expect one for bugfixes only
21:12:52 <mzero> oh - uhm
21:13:00 <portnov> hi all.
21:13:01 <mzero> (sorry overwhelmed in #ows...)
21:13:08 <monochrom> the haskell platform mailing list doesn't announce it or even the standard pre-release activities ("I have tested building on windows!")
21:13:20 <mzero> We are targeting end of the month for a 2011.3.0.0 for HP
21:13:28 <portnov> Q: is there any way to get file modification time as UTCTime ?
21:13:36 <mzero> it will be based on 7.0.4 and some small revision changes to the packages
21:14:08 <mzero> kmc: yes, we had a 2011.2.0.1
21:14:23 <mzero> which was for revving when GHC had a similar bump to 7.0.2
21:14:45 <mzero> I don't pick the numbers, I just build as I'm told!
21:14:55 <monochrom> haha
21:28:23 <roconnor> @hoogle runError
21:28:23 <lambdabot> Control.Monad.Error runErrorT :: ErrorT e m a -> m (Either e a)
21:28:27 <Drakken> portnov Data.Time.LocalTime.localTimeToUTC?
21:29:23 <monochrom> looks like you will involve both old-time and time. from System.Directory.getModificationTime get System.Time.ClockTime (old-time). ClockTime has 2 Integer fields for seconds since 1970-1-1 00:00 UTC and remainder picoseconds. combine them carefully (through Rational or Data.Fixed.Pico if you divide), then realToFrac to Data.Time.Clock.POSIX.POSIXTime (time), then posixSecondsToUTCTime
21:29:39 <portnov> Drakken: it gets LocalTime, but System.Directory.getModificationTime returns ClockTIme
21:29:51 <portnov> yeah, all by hands :/
21:30:37 <portnov> and involving unix package, which is not buildable on windows, afaik :/
21:31:01 <monochrom> ? I don't think I have mentioned anything involving unix
21:31:22 <portnov> is'nt POSIXTime in unix?
21:31:25 <monochrom> time
21:31:45 <monochrom> I even wrote "Data.Time.Clock.POSIX.POSIXTime (time)"
21:31:50 <BlankVerse> how to recursively delete all the hi and o files from a haskell project?
21:31:51 <portnov> ah, ok then.
21:32:22 <portnov> BlankVerse: find . -name \*.hi -delete. Or, if you're using zsh, simply rm **/*.{hi,o}
21:32:55 <monochrom> oh, there is a -delete
21:34:31 * monochrom lost the opportunity to say "in time" there! :)
21:41:14 <mm_freak> BlankVerse: if it's a haskell /project/ using cabal:  cabal clean
21:41:25 <monochrom> oh! forgot that one, haha
21:41:27 <Sgeo|web> Is it normal to want to yell at whoever made http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html , or is that just my inexperience
21:41:46 <BlankVerse> mm_freak: it has a .cabal file , but cabal clean doesnt delete hi files
21:41:53 <Sgeo|web> One of those functions accepts two bools, and one of those functions returns a tuple mostly of strings
21:41:58 <monochrom> also "cabal clean --help" for how to fine-tune it
21:42:06 <mm_freak> BlankVerse: it deletes the entire 'dist' directory
21:42:20 <mm_freak> that also includes all *.hi and *.o files
21:42:25 <BlankVerse> mm_freak: my hi,o files are outside the dist directory
21:42:30 <Sgeo|web> Is it better practice to make a datatype for options like that, and for results like that?
21:42:56 <mm_freak> Sgeo|web: generally yes
21:43:14 <mm_freak> Sgeo|web: type aliases might suffice
21:43:21 <monochrom> I would not yell. the 2 Bools and the 4 Strings are well-documented right there
21:44:12 <monochrom> you would have to hack hackage and delete the docs to make me yell
21:44:46 <edwardk> hah, replacing the class 'Instance' with (:=>) makes it so you define instance Foo a b => Bar a b c    then instance Foo a b :=> Bar a b c    then instance () :=> Foo a b :=> Bar a b c
21:44:47 <edwardk> =)
21:45:02 <mm_freak> Sgeo|web: i build my interfaces such that :t is enough to know how to use them (assuming you know what the package is doing)
21:45:11 <edwardk> very easy to remember and a hell of a lot easier to read
21:45:32 <Sgeo|web> Which is better, reading the code and understanding what it does, or reading the code and needing to check documentation just to see the order of the options
21:46:10 <Sgeo|web> Or is monochrom just saying that this isn't yell-worthy yet
21:46:40 <mm_freak> Sgeo|web: it's a matter of taste…  IMO a function's type signature together with its name should be enough to have a clue about what it does and how to use it
21:46:50 <monochrom> I just read the doc, almost never the source code
21:47:11 <mm_freak> yeah, you shouldn't have to read the source code
21:48:37 <monochrom> "True <=> matching is case-sensitive" is not a convincing case of "this lib is so poor, I have to read its source code". find a less-documented lib to complain about.
21:49:12 <roconnor> what's the recommended way to removing Warning: Defaulting the following constraint(s) to type `Integer' in the expression 2^256 ?
21:49:57 <edwardk> it does result in
21:49:58 <edwardk> instance (caa :=> ca :=> a) => (ca :=> a) :=> caa :=> ca :=> a where inst = Sub Dict
21:50:01 <edwardk> which is a bit odd
21:50:56 <mm_freak> monochrom: if you have two Bool arguments, i would give type aliases
21:51:04 <mm_freak> then :t and :i are enough
21:51:04 * Eduard_Munteanu wonders if GMP uses some tricks to easily compute 2^256
21:51:28 <mm_freak> Eduard_Munteanu: yes, it does…  it just shifts by 256 binary digits
21:51:35 <Sgeo|web> mm_freak: Would there be anything wrong with making full data things for those?
21:51:47 <Sgeo|web> So that it's not aliases, but actually things like CaseSensitive
21:51:51 <Sgeo|web> etc?
21:52:18 <Eduard_Munteanu> mm_freak: as in, write one non-zero byte followed by all zeros? Or repeated shifts until you get to 2^256? :)
21:52:22 <mm_freak> Sgeo|web: that would make it inconvenient…  you couldn't use Bool functions directly
21:52:29 <roconnor> @type (^)
21:52:30 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:52:45 <monochrom> our experience with iteratees shows that inventive type names don't help, either
21:53:09 <mm_freak> Eduard_Munteanu: the latter
21:53:17 <Sgeo|web> mm_freak: o.O
21:53:22 <mm_freak> Eduard_Munteanu: the former would be an optimization to be done by GHC
21:53:34 <dabblego> monochrom: how do you mean there?
21:55:58 <Sgeo|web> mm_freak: Hmm. Example? Also, would it then make sense to make, say, caseSensitive = True or something?
21:56:28 <monochrom> everyone says that type names like "Iteratee", "Enumerator", "Enumeratee" don't tell them anything. that seems to affirm the benefit of meaningful names. until you also see that everyone disagree on how they should be renamed. that affirms the failure of meaningful names. people argue forever over meanings of names.
21:57:26 <dabblego> monochrom: interesting thoughts, thanks
21:58:06 <mm_freak> monochrom: you are talking about a fundamental matter here…  my point is entirely pragmatic:  :t in GHCi tells you in which order you need to give the two Bool arguments…  and you can use :i, if you are not sure about CaseSensitive = Bool
21:58:21 <mm_freak> no need to look into the documentation
21:58:29 <mm_freak> → faster development
21:58:44 <mm_freak> Sgeo|web: example for what?
21:59:13 <Sgeo|web> Inconvience of not being able to use bool functions for something like data CaseSensitivity = CaseSensitive | CaseInsensitive
21:59:21 <mm_freak> Sgeo|web: i don't think you need to give True and False better names…  just type aliases for documentation
21:59:39 <mm_freak> Sgeo|web: CaseSensitive || CaseInsensitive
21:59:45 <mm_freak> Sgeo|web: similarly (&&), not, etc.
22:00:11 <Sgeo|web> Not sure what the meaning of || and && would be for those, but the not makes sense
22:00:27 <monochrom> CaseSensitive is the easy one. what would you call the other Bool? CaretMatchTheBeginningDollarMatchTheEndDotDoesNotMatchNewline?
22:01:00 <mm_freak> monochrom: think about someone, who knows the library, but just can't remember the exact order of the arguments
22:01:04 <MatrixFrog> this is an interesting question i think...
22:01:07 <MatrixFrog> http://programmers.stackexchange.com/questions/117411/haskell-gui-how-much-should-be-done-outside-of-haskell
22:01:49 <Sgeo|web> LineBased
22:01:53 <Sgeo|web> vs WholeTextBased
22:02:02 <mm_freak> monochrom: that programmer doesn't need an extraordinary verbose type name…  he really just needs a little clue
22:02:05 <monochrom> are you going to answer me what you would call the other Bool?
22:02:24 <Cale> MatrixFrog: I'd use a Haskell binding to a GUI library over writing the same code in C.
22:02:33 <Sgeo|web> LineOrWholeText
22:02:39 <Sgeo|web> Although that's a bit verbose
22:02:40 <Cale> MatrixFrog: It's still going to be nicer.
22:02:49 <mm_freak> Sgeo|web: LineBased seems fine
22:02:57 <mm_freak> True = line-based
22:03:52 <Cale> Even with a fairly low-level binding, you have the fact that IO actions are first class, and even if the C library itself isn't threadsafe and you have to do all your GUI stuff from inside one thread, you still get the benefit of nice concurrency primitives if you want other threads for deciding what the GUI should display.
22:04:00 <Cale> (among many other benefits)
22:04:22 <Cale> It's much nicer using a Chan than trying to do interprocess communication.
22:04:24 <mm_freak> the other option is not to have two Bool arguments, or have then in a sensible order with respect to currying
22:04:41 <MatrixFrog> (it's not my question, you should answer it on the site too)
22:04:55 <MatrixFrog> Cale i just put it here since i figured most haskellers read stackoverflow more than programmers.SE
22:05:09 <Cale> I don't Stack Overflow.
22:05:25 <Cale> Or Stack Exchange, whatever :P
22:05:37 * Sgeo|web hits Cale with a non-tail-recursive factorial function
22:05:45 <Yarou> stackoverflowed
22:06:16 <monochrom> Cale only overflows heap
22:06:30 <Cale> yeah
22:06:33 <Cale> heh
22:20:49 <Sgeo|web> @src sequence
22:20:50 <lambdabot> sequence []     = return []
22:20:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:20:50 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
22:21:29 <Sgeo|web> Um
22:21:57 <Sgeo|web> Does sequencing things in the State monad do anything remotely similar to what I want, which, I think, is folding with (>>=)
22:22:31 <Axman6> what do you want?
22:22:39 <monochrom> foldM is folding with >>=
22:22:57 <Axman6> @src foldM
22:22:57 <lambdabot> foldM _ a []     = return a
22:22:57 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:23:00 <Sgeo|web> List of stuff in the state monad, to a single state monadic value
22:23:03 <Sgeo|web> :t foldM
22:23:05 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:23:11 <monochrom> "sequence = foldr (liftM2 (:)) (return [])" says that sequence is a fold, too, but not simply over >>=
22:23:20 <dabblego> sequence :: [State s a] -> State s [a]
22:31:31 <kmc> are there any platforms where the C compiler invoked by Cabal is not gcc?
22:32:07 <Axman6> OS X now
22:32:17 <Axman6> well, unless you could llvm-gcc as gcc
22:32:43 <kmc> isn't it?
22:33:03 <kmc> specifically, it supports the gcc extensions to the C language, no?
22:33:05 <Axman6> well, sort of. there are some differences i think, there's some stuff gcc can compile that llvm-gcc can't
22:33:15 <kmc> i want to use http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Atomic-Builtins.html
22:34:15 <Axman6> are they supported in ghc 4.2.1?
22:34:17 <Axman6> gcc*
22:34:21 <kmc> yes
22:34:34 <kmc> I just need a C library which provides atomic compare-and-swap and works on most common platforms
22:34:45 <Axman6> then you should be ok. if you want, i'm happy to test that your stuff compiles on OS X for you
22:34:59 <kmc> ok cool :)
22:35:30 <Axman6> i was just about to say that GHC has a cas function... then i remembered i read about it from your blog post =)
22:36:03 <kmc> :)
22:36:09 <kmc> yeah, I thought about calling that
22:36:14 <kmc> but it's not exactly in any public API
22:36:19 <Axman6> yeah
22:36:25 <kmc> i think depending on GCC is the more portable choice here
22:36:30 <Axman6> why don't you see how that's defined in ghc?
22:36:41 <kmc> it's a bunch of inline assembly for various architectures
22:37:05 <Axman6> yeah might as well go with the gcc version then
22:37:17 <kmc> i could pick a version of ghc and copy out the cas function and that would probably work too
22:37:23 <Axman6> it probably ends up bring the same thing, but gcc probably supports more platforms
22:37:36 <kmc> but using GCC's builtin is one line of code; you don't even need a header ;)
22:37:46 <kmc> yeah on x86 it uses the same instruction as ghc's inline asm
22:38:03 <kmc> lock cmpxchg
22:38:30 <Axman6> yeah
22:39:27 <luite> that instruction still scares me after the f00f bug ;p
22:39:57 <Axman6> f00f bug?
22:40:04 <kmc> @google pentium f00f bug
22:40:06 <lambdabot> http://en.wikipedia.org/wiki/Pentium_F00F_bug
22:40:06 <lambdabot> Title: Pentium F00F bug - Wikipedia, the free encyclopedia
22:41:28 <Axman6> oh wow, ha
22:41:54 <hydo> wow... I remember when that was news.  Right about the time I first installed redhat over slackware.
22:42:08 <tensorpudding> heh, foof
22:42:20 <hydo> and then went back to slackware.  You thought rpm can be bad now?  hehe
22:42:23 <kmc> http://drdobbs.com/architecture-and-design/184410555 here's a nice article about the bug and the workarounds
22:48:32 <hpaste> edwardk pasted “Pretty Liskov Substitutability of Constraint Kinds” at http://hpaste.org/53428
22:48:37 <steakknife> ah the good old days of pipeline scheduling
22:48:55 <kmc> are the days different today?
22:49:23 <edwardk> sure. they are slightly shorter
22:49:50 <steakknife> fall back. :)
22:50:14 <edwardk> that big earthquake in Japan back in march shortened them by ~1.8 microseconds =)
22:50:34 <steakknife> how does that work?
22:50:51 <steakknife> is it a change of phase or did the earth get more compact?
22:51:36 <kmc> time for a leap [micro]second!
22:52:15 <edwardk> just the redistribution of mass towards the equator
22:52:30 <steakknife> that's me after the holidays.
22:53:27 <edwardk> kmc: which do you prefer, Instance or :=> ?
22:54:17 <kmc> heh
22:54:20 <kmc> haven't thought about it
22:54:42 <edwardk> the former is perhaps a bit less confusing, the latter leads to the cute fact that to make the instance you just put a : in front of the => in your existing instance
22:55:04 <edwardk> instance Eq a => Eq [a]
22:55:09 <edwardk> instance Eq a :=> Eq [a]
22:55:17 <edwardk> instance () :=> Eq a :=> Eq [a]
22:55:37 <kmc> :psyduck:
22:55:45 <edwardk> the lack of parens is winning me over
22:56:00 <kmc> the last one is (() :=> Eq a) :=> Eq [a] -- ?
22:56:12 <edwardk> () :=> (Eq a :=> Eq [a])
22:56:21 <edwardk> they associate like => and ->
22:56:25 <kmc> ok
22:56:37 <kmc> "associate like =>" is not very meaningful in Haskell :)
22:56:45 <edwardk> actually you can curry =>
22:56:49 <edwardk> =P
22:57:01 <kmc> that's amusing
22:57:16 <edwardk> yeah
22:57:20 <edwardk> i didn't believe it at first either
22:57:29 <tomprince> edwardk: Is this to support reoganizing typeclass hierarchies?
22:58:06 <edwardk> tomprince: it reifies the type class hierarchy into a category so i can compose witnesses of subtyping between constraints
22:58:32 <kmc> :large psyduck vomiting smaller psyducks:
22:58:55 <edwardk> tomprince: this is needed because types of the constraint kind are unified using ~, but they are used in the type checker  on the left of => in a much more lax fashion
22:58:58 <arcatan> kmc: :O
22:59:15 <edwardk> (Eq a, Ord a) => ....   can unify with (Ord a) => ….
22:59:52 <edwardk> so if you want to stitch together constraints you may need to swap arguments around, etc.
23:01:01 <MostAwesomeDude> Hey, is there a recommended high-level networking library, or does everybody use Network?
23:01:19 <tomprince> is the eventual goal to teach haskell to be smarter about derving derivable instances?
23:01:34 <blackdog> MostAwesomeDude: depends what you're trying to do.
23:02:09 <Sgeo|web> o.O at currying =>
23:02:12 <MostAwesomeDude> blackdog: I come from Twisted-land. I'm used to having events for new connection, data received, and connection closed, and being able to write and close the connection.
23:02:17 <edwardk> tomprince: well, the idea is that i can make a small template haskell program that generates the two :=> instances for each instance and the one Class instance for each class, then you can use these to reason manually about constraints whenever the constraint system isn't smart enough to figure something out
23:02:23 <MostAwesomeDude> I don't care much beyond that.
23:02:50 <blackdog> MostAwesomeDude: are you writing web stuff?
23:02:51 <kmc> MostAwesomeDude, just use a thread and blocking I/O
23:02:56 <Axman6> MostAwesomeDude: doesn't Network give you all that?
23:02:59 <blackdog> basically, threads are super-cheap in haskell.
23:03:02 <MostAwesomeDude> blackdog: Nope! Non-web stuff.
23:03:13 <kmc> GHC threads are very cheap, and the runtime system will do event-based IO calls behind the scenes
23:03:27 <blackdog> you don't need to go event-driven, you can just dedicate a thread per logical line of interaction
23:03:29 <kmc> in other words you don't need to turn your code inside out anymore :)
23:03:39 <Axman6> MostAwesomeDude: the usual method for working with this sort of stuff is write a loop that accepts connections and forks off a thread for each connection it accepts
23:03:43 <edwardk> MostAwesomeDude: haskell is geared towards running a couple hundred thousand threads and dealing with the blocking and so forth for you down in the bowels of the RTS using epoll, etc.
23:03:45 <MostAwesomeDude> Okay. I'm mostly concerned about the socket boilerplate -- has nobody come up with a good abstraction over that?
23:04:31 <edwardk> kmc: of course the silly part is that i spent so long doing it the other way and scoffing at the java folks that now _this_ feels like the inside out way ;)
23:04:37 <Axman6> what boilerplate?
23:04:47 <kmc> haha
23:04:51 <kirindave> Wow, wacky
23:04:54 <luite> MostAwesomeDude: haskell can do 100k http req per second with threads, most other languages / frameworks claim that you can only do that with event loops
23:05:01 <Axman6> the times i've done network programming with haskell, i only have like four lines of code
23:05:02 <kmc> i think he gets it :)
23:05:14 <kirindave> Very slight changes in haskell files (like adding pattern matching) can easily double compile time.
23:05:25 <edwardk> kmc: but the horse, it is dead. we need to beat it a few more times.
23:05:27 <blackdog> kmc: yes, someone should let him know that haskell threads are cheap :)
23:05:32 <MostAwesomeDude> luite, blackdog, kmc, edwardk : Yes, okay, I am not doubting Haskell's ability to do this. I'm asking if there's something standard which is better than http://rosettacode.org/wiki/Echo_server#Haskell
23:05:42 <blackdog> sadoequinecrophilia
23:05:47 <kmc> yikes
23:05:53 <MostAwesomeDude> I come from Python-land; I'm really not doubting that Haskell can be fast. :3
23:06:03 <kmc> moving swiftly along, would anyone care to comment on https://github.com/kmcallister/global-lock
23:06:22 <edwardk> kmc: *twitch*
23:06:27 <kmc> hey man
23:06:28 <Axman6>  @hoogle interact
23:06:30 <kmc> sometimes you just need a global lock
23:06:31 <edwardk> now we can be like python!
23:06:35 <kmc> :D :D :D
23:06:36 <Axman6> @hoogle interact
23:06:36 <lambdabot> Prelude interact :: (String -> String) -> IO ()
23:06:36 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
23:06:36 <lambdabot> System.IO interact :: (String -> String) -> IO ()
23:06:39 <blackdog> MostAwesomeDude: I don't think there is. What abstractions would you like?
23:06:47 <blackdog> I note that the python solution there is actually longer than the haskell one...
23:06:48 <Axman6> hmm, we need a hInteract =)
23:06:51 <kmc> this one doesn't use unsafePerformIO so it shouldn't fall victim to GHC bugs like the one I describe recently
23:07:14 <MostAwesomeDude> blackdog: One second, let me paste a *real* Python solution. >:3
23:08:07 <tomprince> edwardk: Looks intersting. Quite impresive what can be done in the type system.
23:08:09 <Axman6> MostAwesomeDude: the haskell version should easily support tens of thousands of connections per second =)
23:08:25 <blackdog> Axman6: it's not even a smear on the pavement any more, dude
23:08:41 <kmc> I don't think MostAwesomeDude said anything about performance :)
23:08:46 <tomprince> Coming from coq, though, it sometimes seems that a lot of type hackery in haskell is to get around the lack of dependent types.
23:08:57 <edwardk> tomprince: *nods*
23:09:02 <MostAwesomeDude> Axman6: Cool story. I'm *really* not concerned with that. >:3
23:09:16 <MostAwesomeDude> blackdog: http://paste.pocoo.org/show/501558/
23:09:16 <edwardk> tomprince: we're getting polymorphic kinds momentarily, but the key is that we still have inference ;)
23:09:23 <Axman6> MostAwesomeDude: what boilerplate are you wprried about then?
23:09:35 <MostAwesomeDude> Axman6: Sockets, not having events, that sort of thing.
23:09:42 <Eduard_Munteanu> Heh, coming from Coq to Haskell :)
23:09:49 <kmc> is the code actually shorter with events? it might be
23:10:08 <Axman6> MostAwesomeDude: that is actually all event based, but the great thing is that you don't have to think in events
23:10:24 <MostAwesomeDude> Axman6: What do you mean "have to"? Events are *great*.
23:10:37 <Axman6> kmc: it's shorter when you're using a library specifically designed for making network servers like twisted seems to be =)
23:10:59 <kmc> right
23:11:07 <kmc> I think MostAwesomeDude was asking whether Haskell had such a library
23:11:16 <Axman6> MostAwesomeDude: they're really not, threads are a superior model for servers, and with haskell, you get the benefit of being able to write threads, which perform exactly as events
23:11:18 <kirindave> Is there a nice framework for writing command line apps in haskell? I'm thinking like git where commands can have subcommands
23:11:25 <edwardk> there isn't a good twisted-like DSL for making small network servers in haskell that i know of
23:11:26 <MostAwesomeDude> And yeah, Twisted's designed for this kind of thing. I *know* there's not a Twisted Haskell. I'm hoping that there's a runSimpleServer :: Callbacks or something along those lines.
23:11:26 <kmc> kirindave, cmdargs
23:11:36 <Axman6> i do seem to remember there is an easier way to listen on a socket though
23:11:37 <mzero> @pl \f -> concat `fmap` mapM f
23:11:38 <lambdabot> (join `fmap`) . mapM
23:12:09 <edwardk> MostAwesomeDude: what you should do is annoy shapr into writing twisted for haskell. he knows all the twisted guys, does lots of python and loves haskell. ;)
23:12:38 <MostAwesomeDude> edwardk: Most of Twisted isn't applicable to Haskell though. :c
23:12:39 <tomprince> coq has type infernce, although I am willing to believe that haskells is smarter.
23:12:52 <mzero> hmmm... guess I want   concatMapM
23:13:21 <Axman6> tomprince: are dependant types really that necessary?
23:13:22 <MostAwesomeDude> Anyway, if there's not some blessed way to do this beyond what's in Network, then I guess I'll just roll up my sleeves and get started.
23:13:39 <kmc> there are blessed ways for web stuff
23:13:44 <kmc> not for general networking afaik
23:13:49 <blackdog> MostAwesomeDude: I think more effort has gone into web stuff. there are definitely still some lacunae in the libraries.
23:14:02 <MostAwesomeDude> This ain't web stuff.
23:14:06 <kmc> and did you know, for the 9000th time, that Haskell threads are lightweight? ;P
23:14:30 <kmc> (it's not even true, only true for GHC)
23:14:31 <blackdog> even web client stuff is a bit painful. there's no equivalent of HTTParty, or whatever the pythonistas have (which i'm sure is very good and concise and usable)
23:14:38 <steakknife> MostAwesomeDude: have a look to see what pronk uses
23:14:39 <edwardk> great, now 'haskell threads are lightweight' will become the new 'do you understand confluence proofs?' around here
23:14:46 <kmc> haha
23:14:50 <kmc> any de bruijn experts
23:15:01 <MostAwesomeDude> Yes, but I'm not trying to find some magical callback-only-no-threads-allowed thing. I'm trying to find a general way to hook up some pure code that takes input streams and writes output streams to a listening socket.
23:15:16 <MostAwesomeDude> kmc: Pretend I am porting github.com/MostAwesomeDude/bravo to Haskell as an exercise in masochism.
23:15:21 <tomprince> Axman6: They are nice. They allow you to express more exact types for things.
23:15:24 <MostAwesomeDude> Because that's what I'm doing. >:3
23:15:35 <kmc> MostAwesomeDude, I was just making fun of the channel for beating that dead horse :)
23:15:53 <kmc> we're kind of twitchy about it because the average programmer thinks threads will kill their dog or something
23:15:54 <MostAwesomeDude> kmc: Ah. Yes, the necroequine heckler. Of course.
23:16:17 <MostAwesomeDude> Well, pthreads in non-pure languages, sure.
23:16:18 <steakknife> You bastard!
23:16:28 <kmc> or Python threading, or...
23:16:29 <steakknife> you killed spot :*(
23:16:33 <MostAwesomeDude> But this isn't pthreads, and it's a pure language, so I don't see the problem.
23:16:41 <kmc> it's not a "pure language" really
23:16:49 <MostAwesomeDude> Python threads are real pthreads, BTW, but that's a whole 'nother can of worms.
23:16:51 <Axman6> i thought it was a joke to say python had threads...
23:16:58 <kmc> Haskell threads are IO actions with concurrent execution, and they can share state
23:17:06 <kmc> parallel pure evaluation is a whole other thing
23:17:06 <blackdog> MostAwesomeDude: i'll have a look
23:17:23 <MostAwesomeDude> blackdog: Oh. Thanks!
23:17:33 <tomprince> Axman6: Plus, as I commented above, a lot of type-hackery in haskell seems to be due to the fact that haskell doesn't have dependent types.
23:17:43 * Axman6 thought one of the points of threads were to allow concurrent computation, and python doesn't seem to let that happen
23:17:47 <kmc> the Haskell approach to state is still better because a) you have less of it, b) you're explicit about where it goes
23:17:56 <Axman6> tomprince: like what?
23:17:56 <kirindave> Hum.
23:18:00 <edwardk> tomprince: dependent types come at a pretty poor power to weight ratio though. you lose a LOT to get them
23:18:01 <kmc> but the threading model is far from "pure"
23:18:10 <MostAwesomeDude> The *really* fun stuff is yet to come. Haskell doesn't have dynamic code loading, does it? :3
23:18:20 <kmc> sure
23:18:23 <tomprince> But I am perhpas not the best person to ask, since I use them for mathematics, not programing.
23:18:25 <kmc> after all GHCi is written in Haskell
23:18:30 <kmc> and that functionality is available to your program too
23:18:32 <kmc> http://hackage.haskell.org/package/hint
23:18:40 <kmc> http://hackage.haskell.org/package/plugins
23:18:43 <kmc> http://hackage.haskell.org/package/mueval
23:18:50 <MostAwesomeDude> Can I load a module from source, overriding its own imports and optionally parameterizing the globals of the module?
23:18:56 <kmc> ...maybe.
23:18:58 <MostAwesomeDude> Because that's how Bravo loads plugins.
23:19:04 <Axman6> i hope not
23:19:08 <MostAwesomeDude> And then we use dynamic interface discovery to classify them.
23:19:21 <MostAwesomeDude> Trufax: I
23:19:58 <luite> you can use haskell-src-exts to parse and modify the module before loading it
23:20:16 <MostAwesomeDude> Ooh, I'll look into that.
23:20:16 <blackdog> MostAwesomeDude: btw, the network code in the rosetta stone can be slimmed down to 8 lines  + imports
23:20:18 <luite> otherwise I think you probably need some deep ghc api interaction
23:20:28 <MostAwesomeDude> Well, maybe I'll just not have plugins.
23:20:44 <MostAwesomeDude> blackdog: Is the error handling largely superfluous?
23:20:51 <blackdog> MostAwesomeDude: thoroughly recommend don stewart's PhD thesis on runtime code loading.
23:21:02 <blackdog> or the 'hint' package if you don't have a day to spend :)
23:21:15 <blackdog> MostAwesomeDude: well, it's not in your version, so i figured it was fair game:)
23:21:21 <kmc> MostAwesomeDude, you can also do configurability the way xmonad does
23:21:33 <MostAwesomeDude> I'll just tackle that later. Somehow I don't think people will be keen on writing Haskell to customize their servers.
23:21:33 <kmc> which is to say the program recompiles and re-executes itself
23:21:37 <kmc> passing state through
23:21:49 <kmc> MostAwesomeDude, xmonad is customized in Haskell and it's a pretty popular window manager
23:21:58 <kmc> anyway you can use http://hackage.haskell.org/package/dyre for that
23:21:59 <MostAwesomeDude> kmc: Yeah, a couple of my coworkers run it.
23:22:04 <kmc> it does involve the server restarting, of course
23:22:19 <hpaste> blackdog pasted “slimmed-down echoserver” at http://hpaste.org/53429
23:23:39 <blackdog> MostAwesomeDude: ha, you're doing minefold stuff? i know a few guys who are monkeying about with the protocol
23:23:53 <blackdog> i mean, minecraft stuff. i know the minefold guy.s
23:24:30 <MostAwesomeDude> blackdog: I am porting Bravo to Haskell. I don't talk with anybody who isn't part of the community. They should stop by #mcdevs sometime.
23:25:27 <MostAwesomeDude> I am noting that hGet and friends don't let me read an indeterminate number of bytes.
23:25:59 <MostAwesomeDude> So if I want to get as many bytes as are currently available, I just can't do that. I wonder if attoparsec can handle that for me?
23:26:53 <blackdog> MostAwesomeDude: have you looked at iteratees?
23:26:54 <kmc> MostAwesomeDude, there's Data.ByteString.hGetNonBlocking
23:27:44 <kmc> network IO should pretty much always use ByteString
23:27:50 <Axman6> indeed
23:27:54 <MostAwesomeDude> blackdog: Not yet.
23:28:05 <MostAwesomeDude> kmc: Yeah, I'm noticing that attoparsec insists on ByteString.
23:28:15 <MostAwesomeDude> Is it lazy in all the right places, so to speak?
23:28:27 <kmc> if part of your protocol is representing Unicode text, that requires a parser ("Unicode decoder") like any other structured data
23:28:40 <kmc> e.g. http://hackage.haskell.org/packages/archive/text/0.11.1.7/doc/html/Data-Text-Encoding.html
23:29:11 <kmc> I don't know what "lazy in all the right places" means
23:29:16 <MostAwesomeDude> Well, I get to do that fancily; MC uses UCS-2, which is missing from most Unicode converters.
23:29:41 <kmc> but I know that attoparsec is explicitly designed for high-performance network protocol parsing
23:29:45 <MostAwesomeDude> I was thinking of, well, Data.ByteString.hGetSome, which can return early if there's not enough data.
23:29:46 <blackdog> MostAwesomeDude: lazy IO is a bit of a trap... you end up leaking file descriptors if you're not careful
23:30:01 <mzero> @pl \f as -> mapM f as >>= return . concat
23:30:01 <lambdabot> flip flip (return . join) . ((>>=) .) . mapM
23:30:08 <kmc> i assume text-icu can do UCS-2
23:30:14 <blackdog> MostAwesomeDude: iteratees are an attempt to get around that in a more principled way
23:31:00 <mzero> @pl \as -> mapM (lines . readFile) as >>= return . concat
23:31:00 <lambdabot> (join `fmap`) . mapM (lines . readFile)
23:32:45 <MostAwesomeDude> Interesting.
23:32:59 <MostAwesomeDude> Well, seems like I've got stuff to hack on now. Thanks, guys!
23:33:15 <kmc> so does anyone have comments on this 'global-lock' library
23:35:49 <_Ray_> Hi. If b <- [2..(toInteger . sqrt l)], and let x = (toInteger $ (b^m - 1)/(b-1)), why am I getting a tpe error at "b /= x - 1", "Couldn't match expected type `a0 -> Integer' with actual type `Integer'" in the first argument of (-), namely x?
23:36:44 <Axman6> _Ray_: you can't use (/) on Integral types
23:37:08 <Axman6> and (b^m-1) is an integral type
23:37:14 <_Ray_> Axman6, but isn't toInteger making it integral?
23:37:33 <Axman6> it is, after the division. but you're giving (/) integral types:
23:37:36 <Axman6> :t (/)_
23:37:37 <lambdabot> Pattern syntax in expression context: _
23:37:37 <Axman6> :t (/)
23:37:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:38:27 <_Ray_> So I need something like on (toFloat) (/)?
23:38:39 <Axman6> either you want top use integral division, or you need a floating version of b
23:38:42 <_Ray_> or really fromIntegral
23:38:47 <Axman6> yeah
23:39:07 <_Ray_> Well (b^m - 1)/(b-1) is always integral, with m > 1 integer.
23:39:12 <Axman6> so, i'd do: let bf = fromIntegral b; x = toInteger...
23:39:21 <Axman6> then you need to use div, not (/)
23:39:26 <_Ray_> Ahhh cool :)
23:39:27 <Axman6> > div 12 4
23:39:28 <lambdabot>   3
23:39:35 <Axman6> > 12 `div` 4
23:39:36 <lambdabot>   3
23:41:38 <_Ray_> I'm apparently still doing something wrong :s
23:41:41 <_Ray_> let l = 1000 in sum [x | b <- [2..(toInteger . sqrt l)], let t = 1 + (floor $ logBase b ((b-1)*l)), m <- [3..t], let x = div (b^m - 1) (b-1), b /= x-1, x <= l]
23:44:28 <_Ray_> Ah, toInteger . truncate . sqrt $ l.
23:44:46 <Axman6> :t toInteger
23:44:46 <lambdabot> forall a. (Integral a) => a -> Integer
23:44:51 <Axman6> ah, that's why
23:44:58 <Axman6> just use truncate then
23:45:03 <Axman6> no need for toInteger
23:49:05 <augur> anyone know of any good algorithms for finding (correctly, not probabilistically) the minimal number of feature dimensions to describe a set of values that form groups?
23:50:49 <JoeyA> In STM, is there a concise way to say this?  If a TVar is true, return something, otherwise retry.
23:50:56 <JoeyA> The obvious way is: readTVar var >>= \v -> if v then return something else retry
23:51:34 <Axman6> that sounds familliar... i thought there was a way
23:51:49 <kmc> readTVar var >>= guard -- ?
23:52:27 <JoeyA> Seems right
23:53:08 <kmc> you can use monad comprehensions!
23:53:17 <kmc> [ something | v <- readTVar var, v ]
23:53:37 <Axman6> what about just [something | True <- readTVar var]?
23:53:44 <Axman6> or will that not work
23:53:51 <JoeyA> What version of GHC does that require?
23:53:54 <kmc> 7.2
23:54:00 <JoeyA> :(
23:54:02 <kmc> Axman6, good question
23:54:17 <_Ray_> Axman6, where am I screwing up? let l = 1000 in let k = (toInteger . truncate $ sqrt l) in sum [x | b <- [2..k], let t = 1 + (on logBase fromIntegral b ((b-1)*l)), m <- [3..t], let x = div (b^m - 1) (b-1), x <= l]
23:54:18 <JoeyA> I'm on 7.0.3.
23:54:41 <Axman6> _Ray_: can you paste it somewhere and give it clearer layout?
23:54:52 <kmc> Axman6, looks like they don't define 'fail' for STM
23:54:54 <_Ray_> I can try.
23:54:57 <kmc> so it won't :/
23:55:21 <Axman6> kmc: lame :(
23:55:55 <hpaste> “_Ray_” pasted “Comprehension” at http://hpaste.org/53430
23:55:57 <kmc> yeah
23:56:02 <kmc> well 'fail' is controversial
23:56:08 <kmc> but it would be convenient here
23:56:12 <JoeyA> Lambda-if would be really nice in my case
23:56:20 <JoeyA> readTVar var >>= if then return something else retry
23:56:22 <kmc> IMO it shouldn't be so controversial if it's moved to a new class
23:56:34 <Axman6> :t logBase
23:56:34 <kmc> JoeyA, I found a patch sitting on the GHC Trac which adds lambda-if and lambda-case
23:56:34 <lambdabot> forall a. (Floating a) => a -> a -> a
23:56:38 <kmc> I don't know if it ever got merged
23:57:08 <JoeyA> Lambda case / lambda if showed up on my radar when I looked at GHC's high-priority tickets: http://hackage.haskell.org/trac/ghc/ticket/4359
23:57:18 <Axman6> _Ray_: well logBase can on;y be used on Floating types, and i think you're trying to use it on integers?
23:57:31 <_Ray_> Axman6, I'm using it "on fromIntegral"
23:57:43 <Axman6> :t on fromIntegral
23:57:44 <lambdabot> forall b c a. (Integral b, Num c) => (a -> b) -> a -> a -> c
23:57:46 <hpaste> “_Ray_” annotated “Comprehension” with “Comprehension (annotation)” at http://hpaste.org/53430#a53431
23:57:59 <_Ray_> Pasted the error message.
23:58:02 <Axman6> :t on logBase fromIntegral
23:58:03 <lambdabot> forall b a. (Floating b, Integral a) => a -> a -> b
23:58:32 <_Ray_> If I say "let l = 1000 in let k = (toInteger . truncate $ sqrt l) in k", it works. But it doesn't if I use k in an arithmetic sequence.
23:58:40 <kirindave> Hello _Ray_.
23:58:46 <_Ray_> Hi :)
23:59:07 <Axman6> _Ray_: ah, maybe you want ... $ sqrt (fromIntegral l)?
23:59:21 <kirindave> Okay, so... obviously real world haskell is out of date
23:59:28 <_Ray_> Ah, sqrt doesn't even take Integral types :s
23:59:38 <kirindave> handle (\_ -> putStrLn "Fail") (print $ 10 `div` 0)
23:59:40 <kirindave> Doesn't work
23:59:53 <Axman6> :t handle
23:59:53 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
23:59:57 <Axman6> :|
