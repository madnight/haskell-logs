00:00:59 <rwbarton> the issue is that suppose you had a second instance C E where type T E = Word32 and then you tried to use f1 at the type (Word32, Word32) -> (Word32, Word32); it would have no possible way to determine which instance to use
00:01:36 <alios> ahh ok ic ...
00:02:38 <alios> mmm ok so then the type T c should maybe encoded as a type class variable ...
00:02:40 <rwbarton> so in general you solve this by making the type c "reachable" from the type of the members of the class
00:03:29 <alios> mmm so then Iam not sure whats the real use of the type family style type declerations on class level ...
00:04:12 <Saizan> if you also had an argument of type c to that  method it would've worked fine
00:04:48 <Saizan> or of type D c where D is a non-type-family
00:04:51 <rwbarton> right, for example something like   class Collection c where type Element c :: *; insert :: Element c -> c -> c
00:05:36 <alios> ok ic ...
00:06:49 <alios> what i was actually trying was to a) play with type families and b) use to express Network Addresses....
00:07:25 <alios> ... so I started to write down some stuff what looked nice from the type sigs....
00:08:15 <alios> ... so what I first wrote down was this:
00:08:37 <alios> data IPv4
00:08:38 <alios> instance AddressFamily IPv4 where type Address IPv4 = Word32
00:09:43 <alios> so T c == Address c, C c == AddressFamily c
00:10:32 <rwbarton> putting aside type families it probably makes more sense to do something like I suggested with   data IPv4 = IPv4 Word32 ; instance AddressFamily IPv4
00:10:46 <rwbarton> class AddressFamily a where f1 :: (a, a) -> (a, a)
00:11:51 <ian_mi> mlh: did that work?
00:15:06 <alios> @rwbarton: I think that should work, but I like the idea to have a type (Address IPv4)...
00:15:06 <lambdabot> Unknown command, try @list
00:16:03 <alios> mmm maybe GADTs are a better way to do what I want ...
00:19:27 <alios> actually its not realy about getting the problem solved, its more that I need to come uppon a real use for language feature, to have the feeling that I realy understood what the possiblities and use cases of that lang feature are... TypeFamilies are still open at the momen ;-)
00:20:08 <mauke> momen est omen
00:23:23 <alios> f $ lastMsg alios where f l = take . (length l - 9) l ++ " moment on my list ;)"
00:24:34 <alios> btw. I've added the real coded to the gist to make it more clear: https://gist.github.com/1342569
00:25:12 <huangyi> Is it possible to let cabal reinstall all dependencies automatically? I just turned library-profiling options on, and i have to reinstall all the packages one by one.
00:34:42 <Saizan> huangyi: you can rm -fr .ghc/ so that it won't know about the already installed ones
00:44:27 <copumpkin> > (10^10)^(2^32)
00:44:47 <lambdabot>   thread killed
00:59:26 <lpsmith> copumpkin, the answer is a one followed by 40 billion zeros
00:59:36 <copumpkin> thanks!
01:00:13 <lpsmith> actually, nearly 43 billion zeros ;-)
01:00:47 <lpsmith> But I assume you were poking lambdabot to see if it would fall over
01:02:12 <ddarius> copumpkin is vicious and cruel.
01:02:34 <copumpkin> I was actually puzzled
01:02:34 <copumpkin> [02:50:54 AM] <Madoka-Kaname> > (10^10)^(2^32)
01:02:35 <copumpkin> [02:51:09 AM] <lambdabot>  *E
01:03:57 <ddarius> copumpkin is puzzled, vicious and cruel.
01:04:07 <copumpkin> I try
01:40:26 <Janni> Hello. Someone is having a problem with intercalated terminal input/output that I cannot reproduce on my system. Just wanted to ask if anyone knows the following problem (and a solution / workaround):
01:41:29 * shachaf hFlush stdout and/or hSetBuffering stdout NoBuffering
01:42:00 <Janni> When running two threads where the reader thread runs getLine periodically and the writer thread writes something to the terminal via putStrLn, the input of the user not followed by an ENTER yet gets deleted by the putStrLn.
01:42:12 <yitz> or is it a concurrency issue?
01:42:35 <shachaf> Ah, so not that. :-)
01:42:39 <Saizan> heh, then he might want LineBuffering instead
01:42:42 <shachaf> Janni: Can you @paste the code?
01:42:50 <Janni> Saizan: Tried that already.
01:42:51 <yitz> Saizan: would that help?
01:43:03 <Cale> I'm a little surprised that it would be deleted, but it's unsurprising that the formatting would get messed up
01:43:04 <Janni> shachaf: Just a moment
01:43:25 <edwardk> hah, i think i just derived the most horrible abuse of constraint kinds to model universally quantified constraints
01:43:42 <edwardk> (forall a. Monoid (m a)) => ‚Ä¶.
01:43:49 <hpaste> Janni pasted ‚ÄúgetLine/putStrLn concurrency problem‚Äù at http://hpaste.org/53630
01:44:31 <yitz> edwardk: i think you may have been rubbing your hands so much waiting for that feature that you've injured your hands
01:44:51 <Janni> The problem appeared on a Windows system btw.
01:44:54 <edwardk> make up a data type that you don't export, say, 'data Skolem', then DO export type Forall (p :: * -> Constraint) = p Skolem
01:44:55 <Saizan> edwardk: how many olegs?
01:46:20 <edwardk> when combined with my :=> instance for modeling instances. i can make constraints that have the effect of   (forall a. Eq a => Eq (f a)) => ‚Ä¶ f Int -> ...
01:46:41 <edwardk> where you can only use it with 'f's such that that inference rule is available
01:46:57 <edwardk> yitz: i'm abusing that feature quite steadily now =)
01:47:48 <Saizan> with an unsafeCoerce somewhere, right?
01:48:03 <edwardk> i'm debating about using it in the Symantics class for my grid computing project, to require (forall a. Fun (t a)) and (forall r a. Fun r => Fun (t a -> r))
01:48:04 <edwardk> yep
01:48:19 <edwardk> which is made safe by the fact that i don't export Skolem and i make no instances for it
01:48:29 <yitz> Janni: in the unix shell, if you are in the middle of typing a line and something else outputs to stdout, the shell automatically retypes your partial line for you at the new prompt afterwards (sometimes). i wonder if that behavior is built in to stdin/stdout, or provided manually by the shell. probably the latter.
01:48:41 <edwardk> so ideally there is no way for you to extract it and cheat
01:48:48 <ddarius> edwardk is rediscovering logic programming language implementation.
01:48:54 <edwardk> ddarius: sure
01:49:09 <yitz> Janni: and your not even on unix. so i have a feeling you can't really expect what you are doing to work properly automatically.
01:49:20 <yitz> s/your/you're/
01:49:20 <ddarius> I have to say, though, I always love skolemization.
01:49:20 <Janni> I see.
01:49:25 <Cale> That's certainly a shell feature
01:49:34 <edwardk> *nods*
01:49:49 <edwardk> abusing it a _lot_ at work lately
01:50:15 <edwardk> since we're using a suped up HM(X)/HMF-like type checker
01:50:44 <edwardk> realized the other day that HMF is downright trivial to extend to add (higher rank) existentials to
01:50:50 <Cale> hellOlÈ
01:50:50 <Cale> o
01:50:50 <Cale> You typed: hello
01:50:52 <Saizan> i like foralls in the meta-language so that skolemization is just working under assuptions :P
01:50:56 <Cale> it seems to work for me
01:51:02 <Cale> Though I'm on Linux
01:51:12 <edwardk> Saizan: *nods*
01:51:46 <edwardk> actually there is a slight risk with regards to the skolem bit i just stated
01:51:49 <yitz> Cale: you'd have to try that a lot of times to know really.
01:51:52 <ddarius> edwardk: A couple of days ago I went on a mini rhapsody of using kind polymorphism and such to soup up Category and make interesting instances.  Unfortunately, of the three bulleted items in the paper of things they don't support, I think I used all three.
01:52:12 <edwardk> which ones?
01:52:29 <edwardk> i had a blast getting product categories out of it, etc.
01:52:44 <edwardk> adding a category for natural transformations was also nice
01:52:56 <edwardk> but i admit i didn't do anything too scary
01:53:58 <Cale> hmm... it behaves a bit differently when compiled oddly enough
01:54:12 <Cale> What is this System.Posix.Unistd thing anyway?
01:54:20 <ddarius> The ones in section 3.3: "We do not promote higher-order types of kind", "We do not promote a type whose kind itself involves promoted types", "We do not promote type constructors with polymorphic kinds."
01:55:16 <Cale> Janni: Try replacing sleep 3 with threadDelay (3*10^6)
01:56:11 <Cale> I didn't have any problem running the program under ghci, but when compiled, it wouldn't print anything from the readLoop after the first time it printed OlÈ
01:57:04 <Cale> after replacing the sleep 3 in that way, it now behaves sanely
01:58:18 <Cale> I think probably the problem has to do with whatever sleep was doing causing the entire OS thread that the Haskell thread was running on to block (and maybe drop input?)
01:01:23 <edwardk> type Forall (p :: * -> Constraint) = (p Skolem1, p Skolem2) seems to bandaid the easiest hack that had made it possible to see through my Skolem type
01:01:27 <ddarius> Oct 26 23:39:40 <ddarius> newtype Prod c d x y = Prod (c x x) (d y y); instance (Category c, Category d) => Category (Prod c d) where id = Prod id id; Prod f g . Prod h k = Prod (f . h) (g . k)
01:03:10 <edwardk> s/newtype/data ?
01:03:22 <Janni> Cale: Thanks for the help. But in the original code there was no "sleep". Instead the writer thread was blocking while waiting for a message from another host with hGetLine.
01:03:48 <elliott> Using http-enumerator, is there a way to send a number of requests at once, and have their results streamed together, with some kind of delimiter between requests (i.e. pipelining)? I guess no based on reading the code, just wondering if anyone has done this. (I'd also be interested to know whether the HTTP package supports it.)
01:05:06 <edwardk> i was using data (:*) :: (x -> x -> *) -> (y -> y -> *) -> (x,y) -> (x,y) -> * where (:*) l a b -> r c d -> l '(a,c) '(b,d)
01:06:10 <edwardk> er (:*) ::l a b -> r c d -> (l :* r) '(a,c) '(b,d)
01:07:03 <edwardk> there things seem to go through fine
01:07:38 <edwardk> i can't  '(:*) doesn't exist, but thats okay
01:07:59 <edwardk> since (:*) is the only one i need
01:09:07 <ddarius> edwardk: That example is relatively tame, but yes, the generalization to base categories other than Hask is likely the cause of most of the trouble.
01:09:52 <dcoutts> elliott: HTTP's browser module doesn't, note sure about the lower level interfaces
01:10:25 <elliott> dcoutts: afaict there is no way to even do persistent connections without using HTTP's browser model. at least, the "standard" API does everything in one shot; I suppose you could play tricks with HStream
01:11:22 <dcoutts> elliott: right, you just hold onto the connection, the Browser monad is implemented on top of the rest of the HTTP package's lower level modules without using anything internal afaik
01:11:24 <ddarius> The Nat was fun.  newtype Nat hom f g = Nat (forall a. hom (f a) (g a)); instance Category (hom :: k1 -> k1 -> *) => Category (Nat hom :: (k1 -> k2) -> (k1 -> k2) -> *)
01:11:34 <elliott> dcoutts: right.
01:11:48 <elliott> dcoutts: seems like it's fundamentally limited to reading a response before you get more in, though
01:12:00 <ddarius> It's easy to define a category of isomorphisms from which a category of adjunctions comes readily.
01:12:01 <dcoutts> that may well be
01:12:31 <dcoutts> elliott: imho we don't have the right client side http api yet
01:12:54 <ddarius> This doesn't seem like it would be a hard problem ...
01:13:15 <elliott> dcoutts: well, the more you support the more of a pain the api is to use :) ... but there's no reason you can't add layers on top, of course
01:13:23 <Cale> Janni: hrmm...
01:13:37 <elliott> dcoutts: I'm tempted to just roll my own thing, since both HTTP and http-enumerator seem fundamentally unable to do this
01:13:39 <Cale> Janni: are you building with -threaded? That tends to solve lots of weird problems
01:14:01 <dcoutts> elliott: sure, it can be hard to come up with a "scalable" api that lets some people not care about features they don't want to use
01:14:55 <dcoutts> elliott: I'd go for an IO based api, not using a custom monad. Instead use a IO context object, like we have for Handles
01:15:03 <dcoutts> and thereby allow concurrency
01:15:50 <elliott> dcoutts: I agree a custom monad isn't the best solution. I do think iteratees can help here: say, a convenient interface may let you make all the requests at once, which send the response and then result in an iteratee, which will block until that response is reached
01:16:22 <elliott> ...they're all fully separated from each other, and it has the behaviour you want as long as you read from them in the right order
01:16:24 <dcoutts> elliott: and I was also thinking about returning ordinary Handles
01:16:30 <elliott> yeah, that could work too
01:16:39 <dcoutts> if you want to use an iteratee to read the Handle then that works
01:17:04 <elliott> dcoutts: hmm, i wonder why there isn't a library for turning iteratees into handles
01:17:11 <elliott> seems like an obvious thing to do
01:17:19 <dcoutts> non-seekable ones at least, yeah
01:17:22 <elliott> ("because nobody's bothered yet" :))
01:17:26 <dcoutts> probably
01:18:26 <elliott> http-enumerator's dependency list also bothers me a bit, so I guess I'll hack something up for this application then extract it to a library if it works out
01:20:00 <dcoutts> elliott: another alternative for associating responses with requests might be an async interface
01:20:25 <elliott> dcoutts: i.e. passing a callback to each request?
01:20:31 <dcoutts> or something that explicitly associates some user-supplied token with each request
01:20:51 <dcoutts> and you get these back in order
01:20:58 <elliott> that works; you can implement the iteratee API based on that... I don't think it's very nice to use in practice, though, because with pipelining you still get the responses back sequentially
01:21:06 <elliott> so a callback model will have you writing state machines pretty quickly
01:21:14 <dcoutts> avoids the problem of you pulling on the wrong response and it all blocking
01:21:28 <dcoutts> unless you use buffering of course
01:22:18 <dcoutts> my ideal client side http api would have caching by default, so the user doesn't have to consume the response eagerly to prevent timeouts
01:22:41 <elliott> dcoutts: oh, you could actually have something looking like [Request] -> IO (Iteratee (Iteratee Response IO ()) ()) or something... not sure whether this is genius or horrible
01:22:50 <dcoutts> :-)
01:23:04 <dcoutts> elliott: it means you have to remember somehow which response is which
01:23:13 <elliott> yeah
01:23:15 <dcoutts> hence associating a token with each
01:23:30 <dcoutts> (and that token might be your handler)
01:24:10 <elliott> yeah, with tokens it seems like a reasonable interface, since you can build both the callback and separate iteratees models on top of it
01:24:16 <elliott> quite easily
01:31:41 <elliott> dcoutts: oh! i misunderstood what you were saying. yes, in my seperate iteratee model, an automatic buffer would be involved, so accessing a later iteratee "too early" would only result in blocking until that response is reached, not forever
01:31:56 <dcoutts> ah right ok
01:32:19 <elliott> i agree that something that reflects the sequential nature of responses would be nicer, though
01:32:28 <luite_> is there an easy way to find all unused dependencies in a cabal package?
01:32:30 <dcoutts> elliott: though there's quite a bit of machinery involved since you eventually need to buffer to disk
01:32:34 <elliott> but separate iteratees is convenient for concurrent access
01:33:04 <elliott> dcoutts: well, if I have a reference to [0..] and try and descend two terabytes in to the list, I expect my haskell program to fail :)
01:33:09 <dcoutts> luite_: prune your build-depends to just 'base' and build :-)
01:33:10 <elliott> (while keeping the [0..] reference)
01:33:15 <elliott> but I suppose it's more common with http requests
01:33:43 <dcoutts> elliott: right, you're less likely to know the size of the response
01:34:07 <luite_> dcoutts: yes that would work, though slightly tedious if you have 75 deps :)
01:34:18 <elliott> dcoutts: swapping would kind of do it, but it would be pretty painful :)
01:34:27 <dcoutts> elliott: heh
01:34:55 <dcoutts> luite_: yeah, sorry I don't think we have anything sensible for this
01:35:01 <paolino> @src scanl
01:35:01 <lambdabot> scanl f q ls = q : case ls of
01:35:01 <lambdabot>     []   -> []
01:35:01 <lambdabot>     x:xs -> scanl f (f q x) xs
01:35:46 <luite_> dcoutts: hehe I guess it's not a very common problem, I'm just cleaning up some old projects, moving things into separate packages
01:35:57 <ddarius> All these requests are on different connections?
01:36:05 <elliott> ddarius: no, the same one, and possibly pipelined
01:36:13 * Nafai sighs
01:36:17 <Nafai> I hate dealing with XML
01:36:34 <ddarius> elliott: How do you demultiplex the responses?
01:36:49 <elliott> ddarius: they come in sequentially; how this is reflected in the haskell api is what we're discussing :)
01:37:16 <vharishankar> Why is libffi.so needed to run Haskell compiled programs?
01:37:40 <ddarius> elliott: So the requests are still ordered with respect to each other even though they are all sent at once?
01:37:53 <elliott> ddarius: Yes, you send the requests in the order you receive their responses.
01:38:02 <elliott> So if you send A, B, C, you get A, B, C.
01:38:02 <ddarius> Okay.
01:38:14 <elliott> It's not "all at once" like, interleave every byte of each request pseudo-randomly :-)
01:38:48 <ddarius> elliott: My first question was whether they were on different connections.
01:38:53 <elliott> Right.
01:39:07 <paolino> scanl or mapAccumL , how too choose the right one ?
01:39:09 <dcoutts> vharishankar: it's used for certain FFI constructs
01:39:32 <vharishankar> dcoutts, OK.
01:39:36 <dcoutts> vharishankar: not all Haskell progs use them, but the rts is linked to the ffi.so
01:40:00 <dcoutts> it's for dynamic wrapper exports, used for callbacks
01:40:00 <vharishankar> dcoutts, is there any way to tell ghc to avoid linking against it if not needed?
01:40:14 <dcoutts> vharishankar: no, because it's the rts that uses it
01:40:15 <vharishankar> dcoutts, ah I see.
01:40:34 <dcoutts> you could possibly link statically to it
01:41:06 <ddarius> elliott: Are the requests conceptually independent and this ordering arbitrary?
01:41:19 <vharishankar> dcoutts, OK.
01:41:31 <elliott> ddarius: There's no reason you couldn't depend on it: POST to a form, GET a page that will change because of that form update.
01:42:00 <ddarius> elliott: Yes, but the general case is that you could use it to just send a bunch of queries with no particular order in mind.
01:42:12 <elliott> Yes, that's the most common use-case.
01:42:44 <dcoutts> or a bunch of PUTs
01:42:52 <dcoutts> expecting no interesting response
01:43:00 <dcoutts> (except confirmation / error)
01:44:08 <dcoutts> and doing this pipelining is particularly good for RESTful services that provide lots of little resources where you need to poke several at once
01:44:41 <yitz> edwardk: what is a "Dict-like data type"? What is this Dict thing trying to do?
01:44:47 <vharishankar_> I am actually beginning to understand Haskell better now since starting on Real World Haskell. And thanks to all you helpful folk here. :)
01:45:08 <edwardk> yitz: ? Dict captures the constraint so you can pattern match on Dict later and bring it into scope
01:45:34 <edwardk> consider capturing a Dict (Ord a)  at one point and then later on using it in your Foldable instance
01:45:46 <edwardk> where you don't have access to put any constraints on 'a'
01:46:10 <edwardk> with Set the current approach works fine where you sort a priori
01:46:14 <edwardk> but if you have a priority queue?
01:46:38 <edwardk> then you want to capture the ordering when you insert your first singleton element
01:46:54 <ddarius> Seems like a request would be like sending a message on a channel asynchronously and that it would return a promise that could be forced that would block.  The requests would seem like they could be transparently batched (a more explicit interface could also be provided.)  The waiters on the promise would be woken up as their response began to get loaded into memory.
01:47:46 <dcoutts> ddarius: yes, that'd be achievable with the interface elliott and I were thinking of
01:48:04 <dcoutts> since you'd associate a user-supplied token with each request, that you get back in the response
01:48:10 <dcoutts> which might just be the handler
01:48:13 <ddarius> dcoutts: I know.  This seems like the natural threaded approach.
01:48:17 <elliott> ddarius: Yeah, it's just that that introduces a certain abstraction leak that causes you to need to buffer arbitrarily.
01:48:32 <ddarius> elliott: Where?
01:48:49 <elliott> ddarius: Reading a later response before an earlier one; all responses up to then must be buffered so that they can be accessed later.
01:48:59 <elliott> ddarius: In practice, you're ~never going to want to read responses out-of-order, so this is quite an ugly mismatch.
01:49:30 <dcoutts> so it's not like a normal promise, where you choose when to exercise it
01:49:50 <dcoutts> when it's ready to exercise is determined by the order in which they were made
01:50:13 <elliott> the absolute simplest representation is really just "a stream of data | next-file", which is what the HTTP protocol actually gievs you... it's just a matter of making that usable
01:50:57 <yitz> edwardk: still not following. you keep using Dict recursively in your explanation of Dict. I guess I'll read the post again more slowly and see if I can figure out what you're trying to do.
01:52:01 <edwardk> Dict captures the constraint so you can pattern match on Dict later and bring it into scope isn't recursive. the statement is that it captures the constraint =)
01:52:22 <edwardk> Dict (Foo Bar)        captures the satisfiability of the constraint "Foo Bar"
01:52:57 <elliott> is the simplest explanation not: Dict Foo is the typeclass dictionary for the instance Foo? :p
01:53:04 <edwardk> Dict (Ord a)  -- says there exists an instance of Ord a.     Pattern matching on that constructor brings it into scope
01:53:07 <elliott> upsettingly low-level, I know...
01:53:24 <edwardk> elliott: it is very close, but not quite the dictionary. its a value of kind * that carries around the dictionary
01:53:44 <elliott> right :) (values have kinds?)
01:53:50 <edwardk> pattern matching on it will bring the dictionary scope
01:54:07 <Cale> values have types which have kinds
01:54:19 <edwardk> elliott: it is a type of kind * such that the value carries around the dictionary =P
01:54:35 <elliott> call me back when you get sort metaprogramming
01:54:40 <ddarius> dcoutts: Yeah, it does seem that you would need to register a handler on sending the request that would be responsible for doing any buffering if the sender didn't want to immediately handle the response.
01:54:42 <edwardk> *shrug*
01:54:43 <elliott> template sortskell, sort generics
01:54:49 <elliott> sortclasses/
01:55:14 <edwardk> my toy type/kind checker for haskell is universe agnostic ;)
01:55:35 <edwardk> mind you i lack the heterogeneous equality to really make _use_ of that but still =)
02:07:04 <ddarius> Making a blocking sendBatch call that returns a sequence of handles or a handle that returns a sequence of blobs, in addition to the transparent batching, would seem to resolve the issue.
02:08:40 <elliott> ddarius: I'd prefer an API that maps more directly -- i.e. conceptually [(a,Request)] -> IO [(a,Response)], except the result is properly steaming
02:09:05 <elliott> pick the right as and many things become simple. e.g. a = Response -> IO ()
02:14:49 * hackagebot constraints 0.1 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.1 (EdwardKmett)
02:15:59 <ddarius> elliott: Are you going to use unsafeInterleaveIO?  Otherwise, it would seem that interface would require all the responses to be in memory before I could begin to handle them.
02:16:46 <elliott> ddarius: Thus "conceptually", "except the result is properly steaming" :-) (One may question the moral standing of using lazy-IOish types to explain a far less terrible interface, but there you go...)
02:17:55 <ddarius> elliott: Okay.  I wasn't talking about a "conceptual" interface, but one that would work with streaming.  I'm attempting to go for what the threaded equivalent of the somewhat more obvious event-loop approach would be.
02:19:24 <elliott> ddarius: Well, [(a,Request)] -> (a -> Response -> IO ()) -> IO () would work; the nicest-seeming interface to me is something like [(a,Request)] -> IO (Iteratee (a, Iteratee ResponseChunkBlah IO ()) IO ()) -- you can see why I described it with the list type :)
02:19:45 <elliott> (It probably just needs some type synonyms to look less awful.)
02:21:30 <elliott> On top of that, you can build interfaces like the "list of independent, buffering streams" one.
02:21:30 <ddarius> The former (guessing at the semantics) seems to be exactly the event-loop interface that I'm paralleling.
02:22:00 <elliott> Yes, the former is that. I don't like it that much, though, since you'll end up emulating a state machine to do any of the higher-level, non-event-based interfaces.
02:22:12 <ddarius> elliott: Hence my threaded approach.
02:22:17 <elliott> And because the protocol is really more like a stream of streams than anything to do with events.
02:22:27 <elliott> ddarius: Hmm, maybe I'm misunderstanding what you meant by that.
02:26:29 <ddarius> Call your primitive with the former type, sendBatchAsync.  If you wanted to do something like send A, send B then pair up their results, it would look fugly.  You'd need an MVar or something because the passed in callback wouldn't otherwise have anyway of knowing what earlier callbacks got.
02:26:52 <elliott> Actually, something like sendRequest :: Connection a -> Request -> a -> IO (), nextResponse :: Connection a -> IO (a, Iteratee ResponseChunkBlah IO ()) seems better; the nested-iteratee stuff doesn't really generalise to sending requests in different patterns.
02:27:08 <elliott> ddarius: Right. But I think that's a fairly common usecase.
02:27:21 <elliott> e.g. "request all these files as ByteStrings, do logic on them".
02:27:51 <ddarius> I agree.  With the synchronous sendBatch it would be: do h <- sendBatch [A,B]; r1 <- readResponse h; r2 <- readResponse h; return (r1, r2)
02:28:12 <elliott> Right.
02:28:35 <elliott> Actually my nextResponse type is problematic because you could still request a later iteratee before exhausting the earlier one. :/
02:28:58 <elliott> It'd be nice to enforce the stream processing in the API for the lowest level, and then build buffering on top of that.
02:29:13 <ddarius> That's what I'm envisioning.
02:29:24 <dcoutts> elliott: yeah
02:30:00 <elliott> Maybe the Iteratee could return the next response as its final result :-)
02:30:16 <elliott> (Seriously, kidding. That would be hideous and not even work.)
02:30:23 <dcoutts> why not?
02:30:38 <elliott> dcoutts: you could still call getResponse multiple times on a Connection
02:30:45 <elliott> ddarius: I'm warming to sendBatchAsync because it enforces the stream processing.
02:30:50 <ddarius> You have an unavoidable trade-off between transparent buffering and having one bad apple being able to block everybody (or thirdly, giving a limited time-window to process responses.)
02:31:36 <elliott> ddarius: Well, if the response was modelled as a stream of (data chunk | next-response <token>), this wouldn't happen.
02:31:58 <elliott> The problem with that is, implementing a /non/-pipelined request model (e.g. send a request, figure out which url to request next based on that, repeat) is fairly painful.
02:32:04 <elliott> Or maybe it isn't and I'm just imagining things.
02:34:19 <ddarius> elliott: readResponse could return partial responses or (more or less equivalently) sendBatch could return an Iteratee of the response data appropriately sectioned.
02:34:37 <elliott> Right, the latter was what I was imagining.
02:35:27 <elliott> It seems like there's not much use for an API in-between one that supports the full interface as it is in the protocol like that, and one which doesn't support pipelining (i.e. traditional "send request, get response, repeat" model).
02:35:36 <elliott> Or at least, you pay a high cost for it.
02:36:43 <ddarius> I could see someone wanting to send unpipelined requests ("out of band" requests) while using pipelining for most requests.  I don't think that would be a problem.
02:37:03 <dcoutts> ddarius: that'd need multiple connections, no?
02:37:04 <elliott> Sure, they'll just have to use the more raw API for the former.
02:37:33 <ddarius> dcoutts: Possibly.  I haven't explicitly dealt with pipelined HTTP requests.
02:37:40 <elliott> dcoutts: nah
02:37:53 <elliott> dcoutts: send ten requests, get responses, choose next page to go to based on them, continue in sequential browsing pattern
02:37:58 <elliott> you just don't close the connection after the ten
02:38:26 <dcoutts> hmm, out-of-band suggested something else to me, never mind
02:39:17 <elliott> ddarius: hmm, looks like the http spec actually specifically forbids you from pipelining non-idempotent requests
02:39:29 <elliott> and, indeed, any sequence of requests with data dependencies
02:39:49 <elliott> of course wikipedia could also be lying to me
02:40:59 <ddarius> elliott: That would suggest that responses could be duplicated or out-of-order.
02:41:11 <elliott> ddarius: can't be out of order, the paths aren't part of them
02:41:20 <ddarius> Yeah which is why it seems strange.
02:41:42 <elliott> ddarius: I guess the idea is the HTTP server could parse them all at once, process them in parallel, and then stream the results
02:41:44 <ddarius> Oh, I see what it means.
02:41:45 <elliott> or other such things
02:42:24 <ddarius> Yes, it's a reasonable restriction and one that I don't think impacts you too much other than you should probably handle the case that the user unknowingly tries to do that.
02:42:45 <ddarius> The issue is something like PUT A; GET A
02:42:45 <elliott> I don't think I can; there's no way to tell whether any request might affect another.
02:42:54 <elliott> Yes, but also: PUT A; GET A/STUFF
02:43:00 <elliott> Or: PUT A; GET B -- turns out B uses information from A.
02:43:06 <ddarius> elliott: Well in that case, it's the user's problem and it doesn't impact you.
02:43:21 <elliott> Yeah, I just thought it interesting that that decision was made.
02:43:35 <elliott> It seems like pipelined requests don't really need to be treated specially in the protocol at all to me.
02:43:40 <ddarius> elliott: You may need to provide a "fence" operation though.
02:43:50 <ddarius> (or maybe "flush" is the more appropriate metaphor.)
02:44:33 <elliott> Yes, a flush operation would be reasonable in an API at a higher level. The user of this API will always know how they're sending the requests, though, so it's their problem.
02:45:46 <dcoutts> elliott, ddarius: yes, the spec says "Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request."
02:46:05 <elliott> Oh, so it's not actually banned or undefined behaviour or anything.
02:46:09 <elliott> They're just telling you it's naughty.
02:46:26 <dcoutts> or that you'll get yourself into trouble because you'll have no way to handle errors
02:46:38 <dcoutts> or rather, have any way to know what state things are in if an error occurs
02:48:00 <dcoutts> elliott: so PUT A; GET A/STUFF would be bad, but all PUTs or all GETs would be fine
02:48:05 <elliott> Right.
02:48:38 <dcoutts> in principle then you could check and enforce this
02:48:47 <ddarius> That case is conveniently handled without a flush.  send (Put A) >>= readResponse
02:48:52 <dcoutts> simply by delaying requests that'd make a sequence non-idempotent
02:49:22 <ddarius> You could split batches, that broke the rules, though I'd do that in a higher layer.
02:49:22 <dcoutts> which you can detect conservatively just by looking at the http method
02:51:48 <ddarius> I guess that should have been: send (Put A) >>= readResponse >> send (Get A) >>= readResponse to be a bit clearr.
02:52:16 <ddarius> A flush should probably be provided anyway.
02:56:26 <ddarius> @hoogle mergeIO
02:56:27 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
02:56:28 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
02:56:54 <hpaste> elliott pasted ‚Äúlowest-level api‚Äù at http://hpaste.org/53631
02:57:04 <elliott> Something like this looks good to me; I'm pretty sure you can build everything imaginable on top of it fairly easily.
02:57:26 <elliott> The further away from the protocol it gets, the harder it gets (e.g. having to manually buffer for out-of-order access), which seems like the right thing to me.
02:57:43 <elliott> The "k" parameter is a little annoying but bearable.
03:00:53 <ddarius> What happens if I call responseStream more than once before exhausting the iteratee?
03:03:20 <elliott> ddarius: What on earth could happen? It's a pure function.
03:03:34 <elliott> Presumably a Connection value contains that iteratee behind the scenes.
03:05:29 <ddarius> I guess that's fine.  The iteratee should force you to handle all responses.
03:06:22 <elliott> ddarius: Hmm? Like, a use of withConnection won't type if you have data left on the iteratee?
03:06:53 <ddarius> I was stating (what I believe is) a fact, not a suggestion.
03:07:30 <elliott> Oh.
03:07:46 <ddarius> Though I guess you could always put another request after handling a response or just never get the iteratee in the first place.
03:08:00 <elliott> Nah, you can do "head" on an iteratee.
03:08:13 <elliott> Being able to send requesta after reading responses is a feature of this model :-)
03:08:33 <elliott> Actually what it reminds me of most is the old [Response] -> [Request] model of Haskell IO.
03:08:39 <ddarius> elliott: The point is sending a request and just never even bothering to listen for a response.
03:08:49 <elliott> You have to keep track of all synchronisation and the like, but in this case it's actually how the protocol works.
03:08:58 <elliott> ddarius: Right. Well, that doesn't really hurt anything.
03:09:07 <elliott> You exit the withConnection block, it cleans up the socket, you wasted your time.
03:09:56 <ddarius> This would all be in the "batch manager" anyway for most users, so anything reasonable should do.
03:10:34 <elliott> ddarius: Right.
03:27:52 <elliott> dcoutts: hmm, I think including tokens in the API is actually overkill: it adds a type parameter to everything, means it has to maintain its own queue... and most of all, you can easily maintain your own queue with a direct loop or an IORef of a Seq, so it's not clear to me that you necessarily want the API bookkeeping required by making tokens part of the lowest-level interface
03:47:29 <hpaste> elliott pasted ‚Äúhigher-level interface‚Äù at http://hpaste.org/53634
03:48:02 <elliott> ddarius: dcoutts: I think that's as good as I can make a sufficiently-general interface right now... I'll decide on one later. But this one seems very appealing.
03:51:49 <Jsauidhasj> hi guys.i'm a beginner,and my question is:when choose to make a function tail recursive?is there some rule about this?
03:53:42 <erus`> Jsauidhasj: if it is gonna be recursed alot
03:54:09 <luite_> Jsauidhasj: the rule should be that you shouldn't stress tail recursion in haskell at all
03:56:28 <luite_> Jsauidhasj: since the evaluation model is different. in fact, in haskell, non-tailcall code can sometimes be optimized to fast loops, and code with tail recursion can cause stack overflows
03:57:08 <Kirkkaf> Hello everyone.
03:58:05 <Jsauidhasj> luite_: could you give me an example?
04:01:40 <dcoutts> Jsauidhasj: think about the function 'map'
04:01:42 <luite_> Jsauidhasj: map is not a tail call in haskell, it's very fast. something like myLength (x:xs) n = myLength xs (n+1) is tail recursive, but results in huge thunks
04:29:45 <Jsauidhasj> thank you guys
04:47:04 <dixie_> is there something like hlint but which provides hints about possible space leaks? :)
04:50:25 <elliott> dixie_: a human with a good intuition about haskell evaluation
04:54:03 <erus`> where can i download that?
04:54:53 <hpc> erus`: blog.ezyang.com :P
04:55:00 <sipa> brain://localhost
05:02:13 <erus`> i cant google f*
05:02:32 <erus`> where can i find some docs about it?
05:03:16 <elliott> erus`: http://research.microsoft.com/en-us/projects/fstar/
05:04:23 <erus`> its not 'pure' ?
05:16:51 <dixie_> elliott: :)
05:19:53 * hackagebot gamma 0.9.0.1 - Gamma function and related functions.  http://hackage.haskell.org/package/gamma-0.9.0.1 (JamesCook)
05:45:21 <shum> why nub :: [a] -> [a] has such the name?
05:45:37 <shum> every time I need it, I can't remember the name
05:45:49 <shum> hoogle is the only way to find it
05:46:05 <shum> is it an acronim?
05:46:16 <ddarius> @wn nub
05:46:18 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
05:46:18 <lambdabot> nub
05:46:19 <Cale> nub is an English word
05:46:19 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
05:46:19 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
05:46:19 <lambdabot>      3: the choicest or most essential or most vital part of some
05:46:20 <lambdabot> [5 @more lines]
05:46:33 <Cale> @more
05:46:33 <lambdabot>         idea or experience; "the gist of the prosecutor's
05:46:34 <lambdabot>         argument"; "the heart and soul of the Republican Party";
05:46:34 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
05:46:34 <lambdabot>          {center}, {essence}, {gist}, {heart}, {heart and soul}, {inwardness},
05:46:34 <lambdabot>          {marrow}, {meat}, {pith}, {sum}, {nitty-gritty}]
05:47:49 <shum> ty, but I don't see still...
05:48:02 <MostAwesomeDude> Is there a uniq function which does something different?
05:48:04 <MostAwesomeDude> @hoogle uniq
05:48:05 <lambdabot> Data.Unique module Data.Unique
05:48:05 <lambdabot> Data.Unique data Unique
05:48:05 <lambdabot> Language.Haskell.TH.Syntax type Uniq = Int
05:48:08 <Cale> shum: As in, the most essential part of the list
05:48:49 <ddarius> It's an odd name regardless.
05:48:53 <Cale> uniq probably would have been a better name
05:49:22 <Cale> oh, except that nub doesn't do the same thing as unix uniq
05:49:39 <Cale> which might have been confusing in another way :)
05:49:48 <Cale> (because it's almost the same, but not quite)
05:49:58 <elliott> Or just "unique".
05:50:04 <Cale> unix uniq is like  map head . group
05:50:51 <MostAwesomeDude> I think of nub as being similar in cost and purpose to Python's list(set(stuff)).
05:51:03 <Cale> (presumably out of the desire to run in space bounded by the longest line in the input)
05:51:31 <ddarius> MostAwesomeDude: Set.toList . Set.fromList would be faster than nub, but would require ordering on the elements.
05:51:43 <ddarius> (asymptotically faster to be clear)
05:52:00 <waern> it's nice and short and a little obscurity won't hurt if you want to avoid success at all cost
05:52:02 <Cale> Well, asymptotically faster in the worst case, but divergent or slower in others.
05:52:18 <Cale> > nub [1..]
05:52:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:52:37 <Cale> > S.toList . S.fromList $ [1..]
05:52:41 <lambdabot>   mueval-core: Time limit exceeded
05:53:32 <Cale> Also, converting back and forth from a set will sort the elements
05:53:38 <elliott> How much time does lambdabot give exactly?
05:53:40 <Cale> > nub "mississippi"
05:53:41 <elliott> 3 nanoseconds?
05:53:41 <lambdabot>   "misp"
05:53:49 <Cale> > S.toList . S.fromList $ "mississippi"
05:53:51 <lambdabot>   "imps"
05:53:59 <Cale> > map head . group . sort $ "mississippi"
05:54:00 <lambdabot>   "imps"
05:54:02 <ddarius> @help run
05:54:03 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
05:54:13 <elliott> Those are quick 3 seconds.
05:54:36 <Cale> I'm actually not sure if it's still 3 seconds or what
05:55:00 <ddarius> elliott: You have to account for 2003 seconds.
05:55:12 <elliott> Ah.
06:11:29 <yitz> > map snd . sortBy (comparing fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..] $ "mississippi"
06:11:30 <lambdabot>   "misp"
06:12:50 <Nimatek> > nub "mississippi"
06:12:50 <lambdabot>   "misp"
06:14:40 <yitz> Nimatek: right, the discussion above was comparing nub, S.fromList.S.toList, and map head.group.sort. I was just adding a version of the latter that preserves order.
06:15:33 <Nimatek> yitz: Ah yeah.
06:16:13 <Cale> There's also a fast version of nub which uses Ord by accumulating a Set as it traverses the list, doing membership tests to determine if each element should stay.
06:17:16 <yitz> Cale: isn't that pretty much what S.fromList does?
06:17:42 <Cale> No
06:17:49 <Cale> You don't convert the whole list into a set
06:18:19 <yitz> Cale: ?
06:18:19 <Cale> Well, not at once, anyway
06:18:41 <ziman> i've never thought of that.
06:18:43 <yitz> Cale: S.fromList doesnt convert the whole list, only non-duplicates
06:19:00 <Cale> yitz: perhaps I should just write it, and it would be clearer what I mean :)
06:19:17 <ddarius> yitz: Think about how you'd write nub, then think about how you'd write it faster using roughly the same algorithm.
06:19:24 <ddarius> but given ordering.
06:19:55 * hackagebot augeas 0.5.1 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.5.1 (JudeNagurney)
06:20:23 <yitz> Cale: ah you mean so that it will work for infinite lists too?
06:20:24 <ddarius> (or perhaps I should say, "think about how you'd write it in an imperative language.)
06:20:30 <Cale> yes
06:20:33 <yitz> ah ok
06:20:36 <Cale> > let nubOrd' s [] = []; nubOrd' s (x:xs) = if x `S.member` s then nubOrd' s xs else x : nubOrd' (S.insert x s) xs; nubOrd xs = nubOrd' S.empty xs in nubOrd "mississippi"
06:20:37 <lambdabot>   "misp"
06:20:41 <Cale> > let nubOrd' s [] = []; nubOrd' s (x:xs) = if x `S.member` s then nubOrd' s xs else x : nubOrd' (S.insert x s) xs; nubOrd xs = nubOrd' S.empty xs in nubOrd [1..]
06:20:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:21:36 <Cale> It preserves order and produces results in a streaming fashion, but still takes O(n log n) time for finite lists of length n.
06:22:28 <yitz> Cale: so it's best if you've got an Ord instance and you're not playing golf.
06:22:51 * elliott really wishes Set had a memberOrInsert thing.
06:22:56 <elliott> Same with Map and lookupOrInsert.
06:23:02 <Cale> Map has one
06:23:06 <elliott> It does?
06:23:13 <elliott> I know HashMap doesn't, at least.
06:23:24 <Cale> insertLookupWithKey
06:23:28 <ddarius> memberOrInsert for a set would just be insert unless I'm misguessing it's meaning.
06:23:47 <Cale> ddarius: It should insert the element, and also tell you if it was already there
06:23:47 <elliott> ddarius: memberOrInsert :: (Ord k) => k -> Set k -> (Bool, Set k)
06:24:16 <elliott> Cale: OK, you can implement it with insertLookupWithKey, but it's not quite the API I'd like.
06:24:43 <elliott> But I suppose it's just a matter of giving a trivial f.
06:24:48 * ddarius would not call memberOrInsert "memberOrInsert."
06:25:02 <Cale> It's memberAndInsert :)
06:25:10 <ddarius> Indeed, that would already be better.
06:25:37 <elliott> memberInsert?
06:25:54 <ddarius> memsert
06:25:59 <Cale> heh
06:26:08 <Cale> Thanks ants, thants.
06:26:21 <elliott> memfrob :: a -> Boom
06:26:51 <hpaste> cal pasted ‚Äúinsertforsok‚Äù at http://hpaste.org/53644
06:28:23 <dmos> Haskell naming/implementation style question: in UrgencyHook.hs from XmonadContrib, is the naming of the functions [from,on,with,read,adjust]Urgents more or what I should aim for these particular types of functions?
06:28:39 <dmos> highlighted version of the file: http://www.eng.uwaterloo.ca/~aavogt/xmonad/docs/xmonad-contrib/src/XMonad-Hooks-UrgencyHook.html
06:29:03 <Cale> dmos: Those all seem like fine names to me.
06:29:21 <Cale> adjust- is often modify-
06:29:50 <Cale> (by analogy with the State monad's modify function)
06:30:11 <dmos> ok. but usually you have such a group of functions for data structure and 'monadic context' operations
06:30:17 <elliott> lenses
06:30:20 <Cale> oh, I didn't know that aavogt was at Waterloo
06:30:26 * elliott knew the answer to that question before it was asked
06:30:31 <dmos> yeah, I thought that modify might make more sense.
06:31:08 <dmos> just trying to avoid learning bad habits.
06:32:21 <dmos> elliott: 'lenses' was that in response to my question?
06:32:31 <elliott> dmos: I thought after <dmos> ok. but usually you have such a group of functions for data structure and 'monadic context' operations
06:32:36 <elliott> you'd be asking if there was a way to generalise/abstract this
06:32:43 <elliott> so you don't have to define each operation every time
06:32:47 <elliott> guess i was wrong, though :)
06:33:49 <dmos> elliott: well, I don't really need to abstract it here, as it's more a question about what the convention is around these often similar functions.
06:34:02 <elliott> dmos: Fair enough
06:34:15 <dmos> they could arguably be abstracted, but in my current usecase probably overkill.
06:34:39 <dmos> will have to look into lenses though for another project, haven't used them in Haskell so far.
06:34:55 <ddarius> Have you used them in another language?
06:35:16 <elliott> dmos: lenses are pretty lightweight, they're just a simple data type, a handful of useful operations, and TH to save you the deriving code
06:35:39 <dmos> I explored/followed the discussion in the Java/Scala world, where they are more of an architectural pattern.
06:35:59 * elliott doubts Java has lenses of any kind.
06:36:02 <elliott> Scala, perhaps.
06:36:51 * Cale looks over at the blank new 2TB hard drive on his shelf and considers starting the process of installing it and Debian.
06:37:21 <Cale> I'm really annoyed with Ubuntu right now, but I also have work to get done today :P
06:37:35 <KernelTrap> debian will take maybe 15 minutes to install
06:37:38 <ddarius> Cale: Install Windows.
06:37:46 <elliott> KernelTrap: With what kind of network?
06:37:55 <KernelTrap> ddarius: ew, no, windows takes a long long time to install, waste of time if you've got work to do
06:38:01 <elliott> Downloading the packages with a netinstall easily takes at least that much.
06:38:04 <KernelTrap> elliott: doing it off the CD, even
06:38:17 <KernelTrap> updates and stuff, meh
06:38:18 <elliott> KernelTrap: /The/ CD?
06:38:21 <KernelTrap> do it as you work
06:38:24 <elliott> You're aware Debian comes on like fifteen CDs?
06:38:31 <KernelTrap> elliott: only need one to install!
06:38:37 <Cale> I'm sure it'll take a good few hours for me to get it into a configuration where I'm happy with it.
06:38:58 <Cale> I'd be installing unstable anyway
06:39:01 <ddarius> I'll follow KernelTrap's advice.  Install MS-DOS.
06:39:07 <Cale> and probably off of a USB key
06:39:12 <dmos> elliott: not really as nicely done as they work in a pure functional language. As I said, it's more of an architectural/convention pattern, or in other words, it has a pretty name, but there's no enforcing of it at all.
06:39:25 * gienah prefers to build the os, compilers, everything from the source code
06:39:28 <elliott> dmos: Right. Well, I still doubt they're functional lenses. Something similar, perhaps.
06:39:38 <KernelTrap> gienah: well, not everyone has that kind of time, you know!
06:39:49 <Cale> gienah: I view it as an affront to my dignity to be forced to compile anything.
06:39:54 * ddarius prefers to write the os, compilers, everything from nichts.
06:40:06 <dmos> elliott: yeah. likely a watered down version of the same idea.
06:40:18 <ddarius> Cale is shamed whenever he writes code.
06:40:20 * elliott writes his own OS at bootup time.
06:40:22 <elliott> Every time.
06:40:27 <Cale> ddarius: lol
06:40:48 * KernelTrap doesn't boot, uses a pencil and paper to walk himself through his software
06:40:52 <ddarius> Of course Cale may have a continuous integration setup.
06:41:27 <ddarius> "KernelTrap doesn't boot" sounds more accurate.
06:41:33 <Cale> ddarius: Computer! Make it so! COMPUTER! WHY AREN'T YOU LISTENING TO ME?!
06:41:59 <ddarius> You probably have the microphone volume too low.
06:42:54 <Cale> But yeah, I probably should have said "anything that I didn't write/change", but that would not have been as funny.
06:44:55 * hackagebot sphinx 0.5.1 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.5.1 (GregWeber)
06:46:28 <tech2> isn't it "daemon"?
06:47:12 <luite_> oh it is, I should've fixed that actually
06:48:17 <jerry> can someone show me how to test (to see the output) of function sepBy1......
06:48:39 <jerry> i have 2 parsers needed...just want to see result of function sebBy1
06:48:49 <jerry> can someone show me loittle example of using that function
06:48:49 <Botje> look at the runParser function
06:49:17 <Botje> you give it a parser, a name for your source, and your source
06:49:29 <jerry> Botje: ok
06:49:55 * hackagebot tag-stream 0.2.1 - streamlined html tag parser  http://hackage.haskell.org/package/tag-stream-0.2.1 (YiHuang)
06:49:58 <ski>   parseTest (sepBy1 foo bar) "blah"
06:50:04 <Botje> or that
07:07:56 <Phyx-> Hello, Can someone help me with this error "base:Prelude can't be safely imported! The package (base) the module resides in isn't trusted."
07:08:09 <Phyx-> trying to install haddock 2.9 and it needed ghc 7.2.1
07:08:24 <luite_> ghc-pkg trust base
07:08:46 <mizu_no_oto> Does anyone know when & where the map function first originated?
07:08:51 <Phyx-> ty luite_
07:09:10 <Phyx-> that trusted package system almost made me rip my hair out
07:09:18 <hpc> mizu_no_oto: presumably lisp's mapcar
07:09:32 <luite_> Phyx-: are you still working on visual haskell?
07:09:55 * hackagebot mix-arrows 0.1 - Mixing effects of one arrow into another one  http://hackage.haskell.org/package/mix-arrows-0.1 (MiguelMitrofanov)
07:10:47 <Phyx-> luite_: not really sure.. Everytime I try it's like I take 1 step forward and 2 back :/
07:11:15 <Phyx-> luite_: as it happens i'm currently trying to modify haddock to output Mshelp 3.0
07:11:21 <luite_> Phyx-: hmm ok :(
07:12:04 <Eduard_Munteanu> Isn't that some SafeHaskell weirdness?
07:12:30 <Phyx-> yeah.. http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/safe-haskell.html doesn't mention *how* to trust modules
07:12:35 <Phyx-> so it's why i was fustrated
07:12:37 <luite_> I think it's an omission in ghc 7.2.1
07:13:01 <luite_> it took me a while to figure out, needed it to build new ghc's :)
07:13:10 <Phyx-> hehehe
07:15:34 <byorgey> oh, release candidate for 7.2.2
07:15:44 <byorgey> I'm guessing it fixes the problem with untrusted base =)
07:15:54 <Phyx-> luite_: oh and I also found out that following the sample of using the GHC api on the wiki result in basically unportable code... unfortunately all my functions were based on those samples on how to initiallize the api calls. Because of stuff like that and a few other changes in ghc 7.x it's much better for me to start over.. So i've started re-implementing it from scratch again. Atleast this time I know what i'm doing :P
07:16:14 * ddarius wouldn't trust base.  It's full of evil code.
07:16:53 <Phyx-> ddarius: isn't ghc itself full of evil code? :P
07:18:10 * ddarius wouldn't trust ghc.
07:18:38 <saati> Zy9P6c4
07:18:50 <luite_> good password, bit short ;p
07:18:51 <saati> sorry
07:19:07 <Phyx-> luite_: oh mind if i ask you a quick question
07:19:17 <luite_> I only do slow questions today
07:19:19 <dmos> If I have an X (String) and I want an X (Maybe String) is '>>= return . Just' the appropriate way of expressing that?
07:19:20 <Phyx-> saati: i would add some symbols to it too :P
07:19:28 <hpc> [sudo] password for luite:
07:19:29 <saati> Phyx-: it was autogenerated
07:19:37 <elliott> dmos: fmap Just
07:19:43 <elliott> === liftM just
07:19:45 <elliott> === Just <$>
07:21:03 <byorgey> dmos:   >>= return . f   is always equivalent to   fmap f
07:21:32 <elliott> byorgey: Unless there's no Functor instance.
07:21:33 <Phyx-> luite_: well, should i generate the docs using the style used by other VS languages, or keep the current style in use by haddock...
07:21:45 <elliott> Or possibly, a bad Functor instance.
07:21:51 <ski> or, generic code
07:22:00 <byorgey> for sufficiently small values of "always"
07:22:11 <dmos> elliott byorgey: nice, that worked.
07:23:06 <byorgey> elliott: I know that, but see no reason to introduce that particular historical complication to dmos quite yet
07:23:14 <elliott> :-)
07:23:19 <elliott> Better use liftM just in case!
07:23:26 <byorgey> nooooooo
07:23:42 * elliott just uses (<$>) all the time, because what's life without a gigantic tangle of binary operators?
07:24:08 * ski mostly uses `liftM', sometimes infixed
07:24:20 <dmos> byorgey elliott: I'm very much interested in corner cases, those are the ones that bite you at the wrong time. But I think I already read about some of that evolution.
07:24:24 * byorgey uses (<$>) too
07:24:30 <byorgey> dmos: OK =)
07:24:49 <elliott> dmos: The chances of a /wrong/ Functor instance biting you are 0, because you'd have a hard time finding a type with more than one valid Functor instance.
07:25:01 <dmos> ok, so recommended would be fmap, unless GHC barfs (or weird stuff happens) and then resort to liftM
07:25:07 <elliott> The chances of there not being one are slim but possible; in generic library code you'll usually use liftM to avoid adding an additional Functor constraint.
07:25:19 <elliott> Weird stuff won't happen, you'll just get a "No Functor instance ..." message.
07:26:09 <dmos> elliott: Ah, thanks for the reference to library code. There's always a different quality hurdle when writing code for consumption by others.
07:26:27 <elliott> Well, nobody could /object/ to a Functor constraint, it's just a little ugly :-)
07:27:34 <dmos> ok, so essentially fmap is preferred because of logical consistency and expressivity, and liftM would be used for portability.
07:28:14 <elliott> Nah, fmap is preferred because the capital M is ugly. (<$>) is preferred even more because operators are great.
07:28:26 <dmos> elliott: :D ok.
07:28:37 <elliott> There's basically no meaningful distinction at all, so unless you have a polymorphic "m" in a library, it's not worth worrying about at all.
07:34:28 <Blkt> good evening everyone
07:34:57 <byorgey> good morning Blkt
07:35:01 <byorgey> =)
07:35:04 <Blkt> :D
07:46:07 <RC> HI, I was having some problems using xmonad-contrib and was hoping to get some help here.
07:46:36 <opqdonut> did you try #xmonad already?
07:47:14 <Cale> RC: we can often answer questions about xmonad here too, but yeah, there is the more specialised channel for it
07:47:27 <RC> OK. I will try there. Thanks.
07:47:28 <Cale> I usually don't mind trying, though I don't use xmonad myself
07:59:55 * hackagebot blaze-html 0.4.2.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.2.1 (JasperVanDerJeugt)
08:05:11 <tech2> Is there a memocombinator that acts as a most-frequently-used cache instead of just caching for all values from 0-100000 or whatever with things like Memo.arrayRange (1,1000000)? Say I wanted to cache the results for the top 1000000 most frequently used inputs?
08:05:59 <luite_> that's not possible
08:06:13 <luite_> at least not with unsafePerformIO kind of tricks
08:08:10 <luite_> without
08:08:36 <tech2> Hrmm, I guess so :/ damn, forgot about that I'd have to cache everything then basically, or at least maintain a counter somewhere for each input.
08:08:54 <Botje> .oO(splay tree + unsafePerformIO)
08:09:08 <elliott> luite_: Those kinds of tricks ar par for the course when memoising...
08:10:44 <Peaker> It makes sense to have unsafePerformIO tricks behind memoization
08:11:06 <ski> thunks mutate, too !
08:11:35 <elliott> ski: yeah, but traversing a memoisation tree usually ends up slower in practice than a hashmap lookup afaiu
08:14:58 <Peaker> ugly-memo uses that, but for some reason uses Data.Map under the hood (I think if you use unsafePerformIO and in-place mutation, might as well use a hash table or such)
08:34:55 * hackagebot elerea 2.3.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.3.0 (GergelyPatai)
08:43:03 <rotflcopter> :)
08:43:22 <rotflcopter> i have made this example using functional logic in C http://matrix.z-labor.com/tmp/C/sdltest_circle3.c
08:44:05 <rotflcopter> looks like a clean way of drawing a circle
08:44:38 <ski> argh, no indentation
08:46:16 <dylukes> rotflcopter: http://www.inwap.com/pdp10/hbaker/hakmem/hacks.html#item149
08:48:56 <rotflcopter> dylukes<< that's not my goal btw
08:49:07 <dylukes> I just joined :P
08:49:10 <rotflcopter> im adding anti-aliasing right now
08:49:13 <dylukes> I have no idea what you're doing
08:50:51 <peterjoel> hi.. if I have several Maybe functions - how can I link them together concisely to find the first one that doesn't produce Nothing? Kind of like an inside out version  of  >>=
08:51:21 <dylukes> peterjoel: What do you mean "find" the first noe?
08:51:51 <peterjoel> I'm currently doing find ( /= Nothing ) [‚Ä¶..]
08:52:30 <peterjoel> but I thought I must be able to do something a ? b ? c ? d‚Ä¶ (where ? is some operator)
08:52:44 <Saizan> peterjoel: msum
08:52:51 <peterjoel> aha
08:52:54 <peterjoel> thanks
08:53:06 <peterjoel> I read about that just yesterday, but forgot :)
08:55:11 <BMeph> Is there an Omega IRC channel?
09:04:52 <paczesiowa> how long do you usually wait for a hackage account?
09:06:21 <rostayob> is there a library with the type classes used by "Data types a la carte" and similar?
09:06:32 <rostayob> specifically coproduct (:+:) and injection (:<:)
09:07:04 <rostayob> or in general a library to work with those kind of data types
09:09:07 <elliott> paczesiowa: I got mine in five minutes :)
09:09:19 <rostayob> i got mine in a few hrs
09:09:31 <peterjoel> Saizan: msum isn't quite what I wanted.   I want to get rid of the list syntax and just combine the functions
09:10:12 <peterjoel> so I have find (\= Nothing) [a,b,c,d,e]  and I want to do  a ? b ? c ? d ? e   instead
09:10:48 <hpaste> hanna pasted ‚Äúhanna‚Äù at http://hpaste.org/53653
09:11:26 <monochrom> a `mplus` b `mplus` c `mplus` d `mplus` e
09:11:39 <peterjoel> ah ok :)
09:11:51 <monochrom> msum is based on mplus
09:12:11 <Saizan> <|> also
09:13:24 <rotflcopter> dylukes<< wow thats a huge collection of hacks ;>
09:13:38 <dylukes> rotflcopter: yep
09:14:13 <elliott> rotflcopter: it's the famous HAKMEM
09:14:28 <elliott> rotflcopter: that's only part of it, see http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html :)
09:15:34 <rotflcopter> elliott<< yeah i hacked the link out ;)
09:19:56 * hackagebot cereal-derive 0.1.0 - Automatic deriving of Binary using GHC.Generics  http://hackage.haskell.org/package/cereal-derive-0.1.0 (JaredHance)
09:19:58 * hackagebot cereal-derive 0.1.1 - Automatic deriving of Serialize using GHC.Generics  http://hackage.haskell.org/package/cereal-derive-0.1.1 (JaredHance)
09:20:17 <elliott> nice
09:20:26 <eevar> how do I write a parser that ignores any char up to some string prefix?
09:20:54 <Peaker> eevar: example?
09:20:57 <troydm> what's wrong with this http://hpaste.org/53654 ?
09:21:22 <Peaker> troydm: in   class Functor f where ... what is the kind of "f"?
09:21:33 <Peaker> @src Functor
09:21:34 <lambdabot> class  Functor f  where
09:21:34 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:21:43 <hpaste> cal pasted ‚Äúhmmhmm‚Äù at http://hpaste.org/53655
09:21:47 <eevar> Peaker: somethign that ignores anything up to "lalal" alskdjflasdjfprefixlalala
09:22:11 <troydm> ohh
09:22:32 <Peaker> "a" and "b" are used as types of values in (a -> b) so we know that   a :: * and b :: * -- so the kind of "f" which is applied to "a" and then used as a value must be   * -> *
09:22:53 <Peaker> troydm: anyway, (Tree a) has kind * so is not a valid match for "f"
09:23:03 <MrElendig> eevar: search for substring, when found, parse the rest?
09:23:21 <troydm> Peaker: so how do i make functor that will fmap to a tree ?
09:23:32 <eevar> MrElendig: yup. using Parsec, which I didn't mention
09:23:56 <Peaker> troydm: Tree :: * -> *      Tree a :: *
09:24:05 <Peaker> troydm: do you see why?
09:24:25 <troydm> Peaker: let me think about it a minute, i'm little confused
09:24:42 <Peaker> troydm: do you know Haskell's kind system?  What * is and what * -> * is, etc?
09:25:22 <eevar> the general approach should do. just need a starting point
09:25:24 <troydm> Peaker: yes
09:25:39 <MrElendig> eevar: http://www.haskell.org/pipermail/haskell-cafe/2010-June/078592.html
09:25:52 <MrElendig> eevar: a whole discussion on implimenting substring :)
09:26:00 <eevar> MrElendig: thanks
09:26:21 <Peaker> troydm: whenever you define a data-type with type-variables as parameters, you're defining a type that has a kind different from *
09:26:44 <Peaker> troydm: data Tree a = ...   the kind of Tree is * -> *  (or may be different if "a" has a kind other than *)
09:27:17 <rwbarton> troydm: when you write "instance Functor (Tree a)", the "a" is not just some noise that reminds us that Tree takes an argument--it's an implicitly universally quantified type variable.  So you're saying Tree Bool is a Functor, and Tree Int is a Functor, and ....
09:27:21 <s951> Is it possible to put functions in a list? e.g. something like [( "plus", (+) ), ("minus", (-), ("times", (*)), ("sin", (sin) )]?
09:27:33 <rwbarton> And none of that makes sense because Tree Bool is not the sort of thing that can be a functor.
09:27:46 <hiroaki_> hello there, i just startet to learn haskell and my type definitions do not work, what ist wrong with "data Point = Pt Int Int"?
09:27:59 <Peaker> s951: sure -- but like all lists, they'd have to have the same types
09:27:59 <paczesiowa> eevar: anyChar >> notFollowedBy (string "foo")
09:27:59 <paczesiowa>  
09:28:16 <Peaker> @type [("minus", (-)), ("times", (*))]
09:28:17 <lambdabot> forall a. (Num a) => [([Char], a -> a -> a)]
09:28:38 <Peaker> @type [sin, (*)]
09:28:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
09:28:40 <lambdabot>     Probable cause: `*' is applied to too few arguments
09:28:40 <lambdabot>     In the expression: (*)
09:28:57 <Peaker> s951: the type of  sin  and of  (*)   are incompatible
09:29:01 <eevar> paczesiowa: excellent. thanks
09:30:47 <troydm> http://hpaste.org/53657
09:31:01 <troydm> can any1 replace --------- with the right code
09:31:08 <dylex> hiroaki_: that looks like a fine data definition.  How are you using it, or what error are you getting?
09:31:10 <troydm> i'll understand more then
09:31:43 <kirindave> So does 7.2.2 have the fix for this parallel IO deadlock issue?
09:31:51 <troydm> i've tried
09:32:01 <troydm> fmap fun (Node a) = Node (fun a)
09:32:10 <troydm> but it seems to give compile errors
09:32:15 <hiroaki_> this is my error message: "ERROR "/home/hiroaki/test.hs":1 - Undefined data constructor "Point"" i use hugs
09:32:56 <rwbarton> troydm, it looks ok so far, "seems to give"? can you paste the errors?
09:33:09 <rwbarton> hard for us to guess what they are...
09:33:10 <byorgey> troydm: well, note that you are not allowed to give a type signature for fmap there
09:33:18 <dylex> hiroaki_: ah.  With that definition "Point" is the type, while "Pt" is the constructor.  So, you'd write "Pt 2 3" which has type "Point"
09:33:33 <byorgey> troydm: also, the type of fmap would be  (a -> b) -> Tree a -> Tree b
09:33:36 <troydm> byorgey: no type signature?
09:33:46 <troydm> byorgey: yes i have that
09:33:58 <hiroaki_> yes, but why doesn't it work?
09:34:04 <byorgey> troydm: what's the definition of Tree?
09:34:21 <troydm> data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
09:34:29 <rwbarton> oh , well...
09:34:41 <byorgey> troydm: ok, well, (Node a) is not a tree.  Node takes three arguments.
09:34:41 <dylex> hiroaki_: are you trying to use "Point 4 3" instead of "Pt 4 3" somewhere?
09:34:54 <troydm> writing fmap fun (Node a) = (Node (fun a)) gives me compile error
09:35:05 <hiroaki_> no, my file consists only of this one line
09:35:11 <Peaker> troydm: When you pattern match the Node constructor, you must match the exact number of fields/arguments that constructor has
09:35:34 <Peaker> troydm: then, when you use the constructor to build a (Tree a), you have to give it 3 arguments to fully apply it and get a (Tree a)
09:36:12 <troydm> fmap fun (Node a l r) = (Node (fun a) l r)
09:36:17 <troydm> still errors
09:36:25 <byorgey> troydm: that's getting closer
09:36:40 <byorgey> troydm: what is the type of 'l' ?
09:36:48 <troydm> Tree a
09:36:55 <byorgey> troydm: right
09:37:06 <byorgey> troydm: and what should be the type of the right-hand side, after the = ?
09:37:16 <troydm> Tree a
09:37:22 <byorgey> no
09:37:30 <byorgey> remember the type of fmap
09:37:50 <troydm> i don't quite get it
09:37:57 <troydm> it's little hard to understand
09:38:00 <s951> Peaker: Could I then substitute the function into the place of the string? e.g. 2 (maybe (lookup "plus" functionlist)) 7 = 9
09:38:04 <troydm> can you write the correct way
09:38:08 <KitB> Guest12709: /win 34
09:38:12 <KitB> Ah damn it
09:38:20 * KitB forgot he had typed stuff
09:38:21 <adrake> KitB.win++ :P
09:38:33 <byorgey> troydm: no, I think you won't learn as much that way
09:38:34 <KitB> :P
09:38:46 <byorgey> troydm: what's the type of fmap?
09:38:48 <troydm> byorgey: ok, let me think about it
09:39:07 <troydm> (a->b) -> Tree a -> Tree b
09:39:08 <rwbarton> maybe it helps to imagine has some concrete type
09:39:09 <troydm> but
09:39:14 <rwbarton> *imagine fun has some
09:39:21 <byorgey> troydm: right
09:39:21 <troydm> (a->a) -> Tree a -> Tree a seems more correct
09:39:32 <rwbarton> why?
09:39:42 <byorgey> troydm: (a -> a) -> Tree a -> Tree a  is not as general
09:39:57 <Peaker> s951: Haskell tries to guarantee that at runtime, you won't be getting silly type-errors such as "not enough arguments" or "too many arguments" for function calls. What if you use:  (lookup computedString functionlist) 1 2 3  <-- how can Haskell know you applied the function correctly at compile-time if you don't specify a particular type there?
09:40:01 <troydm> well ok i get it
09:40:05 <byorgey> troydm: that would let you, say, increment every value in a Tree Int, but it would not let you apply 'show' to all the Ints in a Tree Int to get a Tree String
09:40:08 <Peaker> s951: what exactly are you trying to do with this string to function map?
09:40:10 <troydm> so the result of right hand is Tree b
09:40:21 <rwbarton> You seem a little uncomfortable with the idea of writing "Tree" and not putting "a" after it :P
09:40:41 <byorgey> troydm: right. so now do you see why passing 'l' and 'r' as arguments to Node will not work?
09:41:32 <troydm> byorgey: yes, but what should i write then instead?
09:41:53 <troydm> (Tree (fun l))
09:42:00 <byorgey> another way of thinking about it is that  Node (fun a) l r  only applies the function to the top element but does nothing to l and r
09:42:08 <byorgey> but we want to apply the function to *every* node in the entire tree
09:42:38 <byorgey> troydm: you have the right idea -- you want to apply the function fun to every node in l
09:42:42 <troydm> byorgey: yes
09:43:05 <byorgey> fun l  does not work because the types don't match -- fun is a function on a's not on Tree a's
09:43:05 <dylex> hiroaki_: hrm, that seems strange. how are you loading the file?
09:43:26 <troydm> byorgey: yes, that's the quiz
09:43:35 <byorgey> troydm: can you think of a way to apply a function to an entire tree?
09:43:47 <troydm> byorgey: recursion ?
09:44:00 <troydm> fmap fun l
09:44:04 <byorgey> troydm: yes!
09:45:11 <troydm> byorgey: compiled at last, i'll try it out
09:45:22 <byorgey> troydm: if it compiled it's probably correct =)
09:47:42 * byorgey is impressed that everyone in #haskell resisted the urge to just give troydm the solution that entire time =D
09:48:11 <s951> Peaker: 3 arguments: string + 2 operands. I want to substitute the string for the function and apply it to both operands.
09:49:04 <luite_> byorgey: I was going to but I was still optimizing it with @pl and Arrow functions ;)
09:49:14 <byorgey> hahahaha
09:49:56 * hackagebot cmdargs-browser 0.1 - Helper to enter cmdargs command lines using a web browser  http://hackage.haskell.org/package/cmdargs-browser-0.1 (NeilMitchell)
09:50:56 <Peaker> s951: what types are the operands?
09:51:02 <s951> Peaker: Floats.
09:51:17 <Peaker> s951: I'll assume the result is also Float.. then your list is simply: [(String, Float->Float->Float)]
09:52:16 <byorgey> @type let fromTree (Node a cs) = (a,cs); toTree = uncurry Node in fix $ \tMap f -> fromTree >>> arr f *** arr (map . tMap $ f) >>> toTree
09:52:16 <s951> Peaker: It keeps throwing type errors, complaining that I'm passing it a double rather than float :(
09:52:16 <lambdabot> forall t c. (t -> c) -> Tree t -> Tree c
09:52:42 <Peaker> s951: You can either convert it Double->Float, or generalize your function to take a more general type
09:52:49 <simon> is there a general way of doing 'do { x <- foo; return $ bar x }'? so far I've only rewritten it into 'foo >>= return . bar'
09:53:05 <byorgey> simon: fmap bar foo
09:53:17 <simon> byorgey, or liftM, I suppose?
09:53:22 <byorgey> simon: yes, or liftM
09:53:34 <hiroaki_> dylex, i type strg-c strg-l in emacs, it is the same as :l <filename|
09:53:43 <hiroaki_> <filename>
09:53:49 <byorgey> simon: fmap and liftM ought to be the same for types with both a Functor and a Monad instnace
09:53:51 <Peaker> s951: you can use: Floating a => [(String, a->a->a)] as your list
09:56:10 <dylex> hiroaki_: when i :load a file with that one line in hugs I don't get that error. but I don't use hugs very often, so I'm not sure.
09:56:15 <jerry> how would i try to get some output when i use readS parser
09:56:26 <jerry> iis there way to get some output to the ghci
09:56:49 <troydm> is there any emacs function that direclty pastes selected region to hpaste ?
09:57:19 <troydm> if there is no such thing i'll write it because i'm tired of copy pasting
09:57:30 <byorgey> troydm: there used to be, I'm not sure what happened to it
09:57:31 <luite_> http://www.haskell.org/haskellwiki/Hpaste.el
09:57:45 <byorgey> luite++
09:57:55 <troydm> byorgey: thx
09:58:02 <monochrom> no, you can't get some output when you use ReadS parser
09:58:09 <hiroaki_> dylex, i will try to restart emacs and hugs
09:58:59 <hiroaki_> o.k. it works now :)
09:59:02 <hiroaki_> weird o_O
09:59:22 <elliott> hiroaki_: hugs???
09:59:26 <elliott> it's 2011, right? :)
09:59:32 <hiroaki_> yes
09:59:51 <elliott> but people still use hugs?
10:00:08 <jerry> monochrom: how would i test it....i read that output of readS is  [(a,String)]
10:00:44 <hiroaki_> o.k. now it works, but how do i access the two Ints in "data Point = Pt Int Int"?
10:00:50 <KitB> elliott: Cute, eh?
10:00:55 <elliott> hiroaki_: just fyi, you should probably be using ghc... :)
10:01:10 <elliott> hiroaki_: hugs has been dormant for the better part of a decade
10:01:20 <elliott> (ghc has ghci which is just like the hugs console)
10:01:26 <hiroaki_> o.k. i'll try ghci ;)
10:02:01 <hiroaki_> but how do i access the diferent ints in my definition?
10:02:18 <dylex> hiroaki_: usually with pattern matching, something like "f (Pt x y) = ..." or "... where Pt x y = p"
10:02:58 <hiroaki_> I don't get it, sorry
10:04:32 <dylex> hiroaki_: you might check out one of the haskell introductions, like http://learnyouahaskell.com
10:05:45 <Peaker> s951: did it work out?
10:09:30 <s951> Peaker: :( Still getting type errors.
10:11:03 <s951> Peaker: Ah, fixed it. Never mind.
10:25:13 <Dodek> hey, what's the point of withMVar, if it's not atomic?
10:26:12 <Dodek> i mean, if i have two threads that want to modify MVar, i cannot use withMVar, right?
10:26:16 <c_wraith> Dodek: its point is to abstract out the exception-handling
10:26:35 <Peaker> @type Control.Concurrent.MVar.withMVar
10:26:36 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO b) -> IO b
10:26:38 <c_wraith> Dodek: and depending on how you intend to use the MVar, you certainly *can* use it
10:26:47 <Igloo> If all your uses follow the withMVar pattern then presumably it's effectively atomic
10:26:52 <Dodek> c_wraith: so what does it mean that it's not atomic?
10:27:08 <Peaker> Dodek: withMVar does not modify it -- it's probably better to use modifyMVar than withMVar for modification
10:27:10 <c_wraith> Dodek: for instance, most times I use an MVar, I follow the pattern "take, do something, put"
10:27:26 <elliott> Dodek: it's useful for locks
10:27:32 <elliott> where the value is irrelevant
10:27:41 <c_wraith> Dodek: if *every* access to the MVar uses that pattern, it's plenty safe
10:27:43 <Peaker> @type Control.Concurrent.MVar.modifyMVar
10:27:44 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO (a, b)) -> IO b
10:28:33 <c_wraith> Dodek: in fact, I can't think of any time I've used any *other* pattern with MVars
10:30:31 <elliott> c_wraith: you never modify the value in an MVar?
10:30:45 <c_wraith> elliott: modifying is "take, do something, put"
10:31:19 <Dodek> so what if the value in MVar is relevant?
10:31:25 <elliott> @type Control.Concurrent.withMVar
10:31:26 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO b) -> IO b
10:31:31 <elliott> c_wraith: withMVar does not allow you to modify
10:31:36 <elliott> modifyMVar does, but withMVar does not.
10:31:44 <elliott> it restores the original value only
10:31:55 <c_wraith> so use only the one that matters to you
10:32:04 <Dodek> basically, i want to keep in MVar the game state
10:32:09 <elliott> i was just qusetioning the claim that all your uses of mvar are withmvars :p
10:32:16 <Dodek> one thread is responsible for drawing, basing on the state
10:32:31 <Dodek> and others read network packets and modify the state accordingly
10:32:39 <c_wraith> elliott: I never said that.  I said all my uses of MVar are "take, do something, put". There's no claim the value put is the same as the value taken.
10:32:51 <Dodek> in other language, i'd just use mutex to ensure atomicity of reads and writes
10:33:01 <elliott> c_wraith: ah, ok
10:33:07 <Dodek> what should i do in haskell
10:33:10 <Dodek> ?
10:33:39 <monochrom> mvar can be a mutex too. P -> putMVar, V -> takeMVar. or the other way round depending on initial condition
10:33:44 <c_wraith> Dodek: is the state fine-grained enough that different actions will modify different non-overlapping parts of it?
10:35:03 <Dodek> c_wraith: server only sends only the information on what changed, it does not resend full state every turn.
10:36:12 <Dodek> monochrom: yeah, but i thought that modifyMVar is with-mutex
10:36:48 <monochrom> not sure what is the semantics of "with-mutex"
10:36:53 <c_wraith> Dodek: that's not what I was asking.  I was asking if the state has a lot of relatively-independent parts, where most won't be updated on each request
10:38:00 <Dodek> c_wraith: they're independent, but they're highly likely to change every turn.
10:38:23 <c_wraith> Dodek: in that case, an MVar is probably the easiest.  But why not just keep the game state in the MVar?
10:38:52 <Dodek> c_wraith: that's what i do.
10:38:56 <monochrom> I too keep "shared" state in an MVar and modifyMVar my way through it
10:39:03 <Dodek> c_wraith: maybe i'm just confused about how it works.
10:39:56 <jerry_> can someone show me example of this function -> sepBy1 :: ReadP a -> ReadP sep -> ReadP [a]
10:40:06 <Dodek> c_wraith: by "it's not atomic" i understand that if i use modifyMVar on some MVar, my action gets current contents of MVar, and puts new ones, but other thread may have put other contents in between reading and writing.
10:40:08 <monochrom> like c_wraith says, if every thread does "take, blah, put", then where is the "non-atomicity"? show me an execution trace that breaks.
10:40:08 <hpaste> cal pasted ‚Äúhhmm3‚Äù at http://hpaste.org/53660
10:40:44 <mauke> jerry_: something like sepBy1 word (string ",")?
10:41:06 <jerry_> mauke:what is the output
10:41:15 <mauke> jerry_: output?
10:41:21 <jerry_> mauke: can you write actual example so i can play with it
10:41:32 <mauke> jerry_: no, I don't know what ReadP is
10:41:47 <jerry_> mauke: efinition of that function says that output is ReadP[a]
10:41:51 <jerry_> output is some list
10:42:03 <mauke> ah, so "output" means return value
10:42:11 <hpaste> cal annotated ‚Äúhhmm3‚Äù with ‚Äúhhmm3 (annotation)‚Äù at http://hpaste.org/53660#a53661
10:42:13 <mauke> no, ReadP [a] is not a list
10:42:32 <jerry_> mauke: what is it then?
10:42:37 <mauke> a parser
10:42:52 <jerry_> pareser that produces a list
10:43:07 <mauke> yes
10:43:38 <mauke> 'sepBy1 p sep' parses one or more occurrences of p separated by sep
10:43:48 <mauke> it returns the results of the p's
10:44:28 <jerry_> mauke: but not inludin separator
10:44:49 <mauke> yes. p is not sep. (?)
10:45:09 <jerry_> ok.,,,thank you
10:46:39 <c_wraith> Dodek: think of it this way:  If one thread has already taken out the game state to work on, and hasn't put it back yet...  How is any other thread going to put a new game state into that MVar, unless it creates it from scratch?
10:46:56 <ben_> Is there any circumstance under which unsafePerformIO is justified in a library?
10:47:15 <c_wraith> ben_: sure.  if you can prove it's safe.
10:47:19 <Dodek> c_wraith: hm, it makes sense.
10:47:20 <monochrom> memoization :)
10:47:22 <elliott> ben_: many
10:47:38 <ben_> I'm looking at time-recurrence and it seems to use unsafePerformIO to do timezone lookups
10:48:02 <ben_> https://github.com/hellertime/time-recurrence/blob/master/src/Data/Time/CalendarTime/CalendarTime.hs#L96
10:48:12 <elliott> ouch.
10:48:13 <elliott> that looks bad
10:48:33 <elliott> pretty sure you can change that, even
10:48:38 <elliott> during process runtime
10:48:42 <elliott> i'd report an issue
10:48:53 <ben_> in the author's defence, it is a real pain to put all time processing in IO
10:48:56 <monochrom> most of the time the question is referential transparency. do the same unsafePerformIO call many times. do they all give the same answer? if yes, cool.
10:49:12 <ben_> Alright, this definitely fails that test
10:49:20 <elliott> ben_: that just means a better abstraction is required than IO :)
10:49:32 <ben_> elliott: What would you suggest?
10:49:50 <monochrom> the devil in the details is what kind of scope those many calls span. over one execution session? over many execution sessions?
10:51:34 <monochrom> for example in many parts of US and Canada, if you asked "what's the local timezone" just 14 hours ago, then asked again just 11 hours ago, you would get different answers. the question is: do you care?
10:52:56 <ben_> It seems like building a library on the assumption that you don't care when the timezone changes is a poor idea
10:53:17 <ben_> Does anyone have any clever ideas concerning how this might be refactored
10:57:01 <scshunt> ben_: make functions take a time zone as an additional argument?
10:57:17 <scshunt> and use implicit arguments if you're squeamish?
11:00:29 <ion> dylukes: Have you had a chance to work on a CloudHaskell supervisor?
11:00:34 <ben_> scshunt: That is I guess an option
11:00:38 <dylukes> No, I have not.
11:00:44 <ben_> albeit a painful one
11:00:45 <dylukes> I've been totally busy with schoolwork.
11:00:56 <ion> dylukes: Alright
11:01:14 <copumpkin> edwardk: is there an approach to lenses that allows you to change types?
11:01:33 <ben_> Perhaps to/fromCalendarTime should just become an action
11:01:39 <ben_> yuck
11:02:03 <edwardk> copumpkin: not a nice one
11:02:19 <hiroaki_> i can't find the posibility to write polymorhic funktions in haskell. is it possible? does someone have a good turorial for me?
11:02:24 <dylukes> What do you mean change types in lenses?
11:02:31 <scshunt> ben_: alternatively, work with time in a timezone-agnostic manner
11:02:37 <scshunt> and only use timezones at the IO boundary
11:02:38 <copumpkin> dylukes: data Moo a b = Moo { getA :: a; getB :: b ]
11:02:47 <copumpkin> say I have a Moo True 5
11:02:57 <scshunt> (this seems to me to be a better idea)
11:02:58 <copumpkin> I can do { getA = () }
11:03:25 <dylukes> but a = Bool?
11:04:01 <ben_> scshunt: True
11:04:15 * ion secretly hopes jlouis ports CombinaTorrent to Remote and incidentally implements a Remote supervisor. ;-)
11:04:25 <ion> I probably won‚Äôt have the energy to implement one myself.
11:04:54 <edwardk> copumpkin: maybe you can use my Forall trick or something
11:04:58 <copumpkin> dylukes: http://snapplr.com/wsk4 works
11:05:33 <dylukes> copumpkin: Wait, that actually works?
11:05:37 <copumpkin> yeah, why shouldn't it?
11:05:50 <dylukes> I guess.
11:05:51 <copumpkin> it even barfs correctly if you have a fun existential messing things up
11:05:53 <monochrom> @quote monochrom record
11:05:53 <lambdabot> monochrom says: Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
11:05:54 <rwbarton> it's creating a new Moo value anyways, so why need it have the same type
11:06:00 <edwardk> dylukes: foo { bar = 123 } is allowed to change the type of bar as long as both before and after the type typechecks
11:06:07 <monochrom> @quote monochrom record
11:06:07 <lambdabot> monochrom says: Co dawg, we heard you like records so we put record puns so you can omit field names while you name fields.
11:06:13 <monochrom> @quote monochrom linear
11:06:14 <lambdabot> No quotes match. Wrong!  You cheating scum!
11:06:24 <edwardk> @quote dylukes
11:06:25 <lambdabot> dylukes says: Yea, though I walk through the valley of the shadow of APL, I shall fear no evil, for I can string 6 primitive monadic and dyadic operators together.
11:06:25 <monochrom> oh well
11:06:50 <monochrom> I had one that says: linear types can change the world! record updates can change the type!
11:07:21 <edwardk> copumpkin: the main tricky prospect is the type of set, so if you can get that right you can do anything =)
11:07:37 <copumpkin> dylukes: http://snapplr.com/phv2
11:07:46 <copumpkin> edwardk: yeah, sounds scary :P
11:08:10 <edwardk> btw- did you see my horrible hack for quantified constraints?
11:08:16 <copumpkin> nope :o
11:08:29 <edwardk> https://github.com/ekmett/constraints/blob/master/Data/Constraint/Forall.hs
11:08:53 <edwardk> relying on the fact that you were able to get an instance for a type i never exported
11:09:00 <copumpkin> lol
11:09:18 <copumpkin> nice skolems
11:09:25 <edwardk> i requirethat you can do so for two different such to avoid you doing the easy MPTC Foo A A trick
11:09:29 <edwardk> yep
11:09:42 <copumpkin> that's neat
11:10:16 <copumpkin> man, I can't wait for polymorphism to blast your Forall1 out of existence
11:10:22 <edwardk> the reason i wanted it was coz i was playing around with trying to make a constraint like
11:10:31 <copumpkin> although I guess it might not be able to here
11:10:42 <copumpkin> since you need to create real "skolems"
11:10:54 <edwardk> class (‚Ä¶. , forall a. Fun t (t a), forall a. Fun r => Fun t (t a -> r)) => Symantics t where ...
11:11:35 <edwardk> yeah
11:12:00 <edwardk> i could probably do so with the argument to something like a Proxy and get tricky about it
11:12:51 <edwardk> Foo p A  rather than p a and have class p a => Foo p a or instance p a => Foo p a or some such
11:13:35 <edwardk> anyways with Forall, one can use the :=> constraints
11:13:40 <edwardk> as constraints =)
11:13:56 <copumpkin> lol
11:14:06 <copumpkin> I would accept nothing less
11:14:52 <edwardk> class FunT t a where ‚Ä¶; instance Fun (t a) => FunT t a where ‚Ä¶      Forall (FunT t)      is then the equivalent of forall a. Fun (t a)
11:15:15 <edwardk> or something like that
11:15:23 <edwardk> but its annoyingly first order ;)
11:17:18 <jerry_> i have import Data.Either on top of my file but stil have error....Not in scope: `lefts'
11:19:28 <danr> @hoogle lefts
11:19:28 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
11:19:28 <lambdabot> Graphics.UI.GLUT.Window LeftSide :: Cursor
11:19:28 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
11:22:00 <hiroaki_> is it possible in haskell to use one function name one different data structures?
11:22:34 <mauke> with typeclasses, yes
11:23:38 <hiroaki_> ah, thank you now i have something to google
11:30:14 <f77> Hi guys
11:30:49 <f77> I'd like to write a small game in haskell, just to get to know the language better
11:31:08 <f77> My Problem is: I have no idea which grahpics library to use
11:31:52 <f77> In C I kept using SDL, in python I've used pygame (pygame is the SDL binding f¸r python). But in haskell, there is a big Problem with hSDL
11:32:14 <f77> there some problem so I cant install hSDL properly on windows
11:32:22 <f77> without any weird hacks
11:32:32 <morolin> f77: the Haskell bindings for OpenGL aren't bad. The game raincat was made with it, if you want an example of a game.
11:32:55 <morolin> f77: http://www.haskell.org/haskellwiki/Opengl
11:32:59 <f77> I think 2D Stuff should be enough
11:33:26 <morolin> OpenGL is pretty good for 2D, actually.  Dwarf Fortress is 100% OpenGL.
11:33:37 <f77> ok I keep it in mind
11:33:39 <f77> thx
11:33:51 <hpc> morolin: DF is basically curses with a custom font, it doesn't count :P
11:34:12 <morolin> hpc: Isn't that what most 2D sprite games basically are?
11:34:42 <f77> morolin, do you have any more suggestions? (I'm going to try opengl bindings but in case I need somethign else)
11:34:56 <morolin> Not really, the only thing I've played with was OpenGL
11:35:21 <f77> I just need a simple lib comparable to SDL, I actually just need 1) graphics and 2) keyboard/mouse itneraction
11:35:40 <parcs_> df is not even curses
11:35:45 <parcs_> there is no mouse support
11:35:56 <zmv> so what?
11:36:05 <zmv> you can have curses with no mouse, right?
11:36:14 <parcs_> f77: there are haskell sdl bindings
11:36:24 <f77> parcs_, yeah but it doesnt work on windows
11:36:31 <f77> without doing some weird hack
11:36:44 <f77> on linux it does work
11:36:51 <morolin> f77: OpenGL + GLUT will get you that, but if you find something better, feel free to let me know as well.
11:36:53 <f77> I actually need it to run on both linux and windows
11:37:10 <zmv> should work on windows too
11:37:12 <f77> morolin, ty, I think I'll try opengl first since I have nothing better right now
11:37:21 <f77> oh btw
11:37:24 <dylukes> Not much works on Windows without some weird hack :|
11:37:37 <dylukes> The whole "OpenGL is just 3d" thing is a huge sham anyways.
11:37:44 <dylukes> That's a relic of the old fixed pipeline.
11:37:48 <copumpkin> preflex: seen heffalump
11:37:49 <preflex>  heffalump was last seen on #darcs 5 hours, 33 minutes and 33 seconds ago, saying: http://tortoisedarcs.sourceforge.net/ does exist, but I'm not sure how up to date it is
11:37:54 <parcs_> huh
11:38:00 <dylukes> "new" OpenGL doesn't favor 3D anymore than anything else.
11:38:05 <zmv> OpenGL is even 1D!
11:38:14 <zmv> (if you want it to be)
11:38:14 <f77> in case I wanna play with opengl on linux and there is no 3D driver available or broken, does it stillwork for 2D?
11:38:15 <dylukes> Hell, you could write a 4D engine if you wanted too.
11:38:21 <dylukes> There are float4 types in GLSL.
11:38:26 <hpc> dylukes: and people have
11:38:32 <dylukes> hpc: I'm sure.
11:38:33 <zmv> and 5D!
11:38:38 <zmv> and pretty much any D!
11:38:40 <dylukes> f77: OpenGL is *not*  a "3D library"
11:38:44 <zmv> or rather
11:38:44 <morolin> f77: it should work with software rendering
11:38:51 <parcs_> what does that have to do with the fixed function pipeline?
11:38:52 <dylukes> It's a way to work with the GPU for arbitrary rendering.
11:38:56 <f77> ok thanks a lot!
11:39:14 <f77> I'm just asking since my 3D driver in linux does some trouble quite often
11:39:15 <dylukes> parcs_: The fixed function pipeline had the matrix stack and favored 3D. For 2D you have to use orthographic mode and mess with stuff.
11:39:16 <f77> :D
11:39:26 <dylukes> Or you'd have to project your scene onto a single texture rect.
11:39:47 <zmv> KD¬†with K being a natural number
11:39:53 <zmv> or even not a natural number
11:40:00 <zmv> but that would be weird :P
11:40:17 <Eduard_Munteanu> AFAIK, you don't get any sort of software rendering by default, unless your drivers do that for you.
11:40:27 <morolin> zmv: I don't think K not natural would work.  Can you really have fractional dimensionality?
11:40:32 <dylukes> Eduard_Munteanu: You get software rendering if your computer has a software rendering driver.
11:40:48 <dylukes> Also, like 90% of intel CPUs have integrated graphics anyways.
11:40:54 <dylukes> In case you need a fallback.
11:41:33 <Eduard_Munteanu> Hm, I thought that was just recent stuff.
11:41:46 <zmv> morolin: not under our physics
11:41:55 <zmv> morolin: but that's a computer we're talking about.
11:42:30 <zmv> we could simulate space with different laws of physics
11:43:00 <hpc> how would the math work out?
11:43:04 <morolin> zmv: yeah, I know that.  IANA geometry guy, but I thought you had to have real numbered dimensionality just because the number of dimensions corresponded to the number of numbers in your coordinate specification?
11:44:48 <Eduard_Munteanu> morolin: there are extensions to that notions of dimensionality, e.g. http://en.wikipedia.org/wiki/Hausdorff_dimension
11:44:54 <Eduard_Munteanu> *notion
11:45:03 <asdf_> test
11:45:31 <Eduard_Munteanu> asdf_: test to you too
11:45:36 <Eduard_Munteanu> :)
11:45:38 <asdf_> =)
11:45:42 <morolin> Eduard_Munteanu: Whoa.  Neato.
11:45:49 <jerry_> how to extract values from Either type
11:45:53 <jerry_> is it possible
11:46:22 <ion> @type either  --for instance
11:46:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:46:38 <Eduard_Munteanu> jerry_: sure, the constructors are available, and you can just pattern-match
11:46:40 <ion> Pattern matches are another way.
11:46:51 <Eduard_Munteanu> Or use a decision function like ion hinted.
11:47:00 <ion> @src either
11:47:00 <lambdabot> either f _ (Left x)     =  f x
11:47:01 <lambdabot> either _ g (Right y)    =  g y
11:47:08 <ion> either uses pattern matching like so.
11:47:26 <jerry_> Eduard_Munteanu: thank you:)
11:54:49 <jerry_> Eduard_Munteanu: can you give me example how to extract Right from result which is of Either data type
11:54:59 <jerry_> example using constructor
11:56:07 <hpc> > either id (const undefined) (Right "example")
11:56:08 <lambdabot>   *Exception: Prelude.undefined
11:56:26 <hpc> > either (const undefined) id $ Right "example" -- er
11:56:27 <lambdabot>   "example"
11:56:32 <hpc> > either (const undefined) id $ Left "example"
11:56:33 <lambdabot>   *Exception: Prelude.undefined
11:56:43 <hpc> poof!
11:59:59 <ion> > case Right "foo" of { Right a -> "Right " ++ a; Left a -> "Left " ++ a }
12:00:01 <lambdabot>   "Right foo"
12:00:21 <ion> > either ("Left " ++) ("Right " ++) $ Right "foo"
12:00:22 <lambdabot>   "Right foo"
12:00:28 <jerry_> what i am asking is that my result returns Left = error.....Right returns list
12:00:37 <jerry_> i want to access that list and play with it
12:01:14 <ion> > ("new item":) <$> Right ["foo", "bar", "baz"]
12:01:15 <lambdabot>   Right ["new item","foo","bar","baz"]
12:01:24 <jerry_> ion: ?
12:01:29 <ion> There‚Äôs that, too.
12:02:04 <geheimdienst> jerry_: the most straightforward thing is to use case-of. case something of Right r -> doStuffWith r ...
12:03:48 <jerry_> geheimdienst: tjere is no already made up function to get right values out
12:04:46 <rwbarton> @hoogle Either a b -> b
12:04:46 <lambdabot> Data.Either rights :: [Either a b] -> [b]
12:04:47 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:04:47 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:05:03 <zmv> lolno
12:05:04 <Nisstyre> I would tend to disagree with that viewpoint
12:05:07 <zmv> hehehehe
12:05:44 <geheimdienst> jerry_: you might use "either", as ion demonstrated above. a more advanced thing is to use fmap (also known as <$>)
12:06:19 <jerry_> geheimdienst: can you show me actualy example when you use "either" please
12:06:27 <ion> > either ("Left " ++) ("Right " ++) $ Right "foo"
12:06:29 <lambdabot>   "Right foo"
12:06:44 <geheimdienst> jerry_: there you go
12:07:11 <jerry_> geheimdienst: ....i dont understand that...look ill give you my example.....i have function that when i run it returns following
12:07:29 <jerry_> Right [1,2,3,4,5]
12:07:47 <jerry_> i want to get number 1 from that list
12:07:52 <jerry_> how would i do that
12:07:55 <ion> And do what with it?
12:08:09 <jerry_> nothing....just want to extract that integer thats all
12:08:14 <ion> What do you want to return?
12:08:32 <jerry_> to return number 1 from that list
12:08:43 <ion> What do you want to return when you get Right []? What do you want to return when you get Left x?
12:09:00 <jerry_> oh i see what you mean
12:09:24 <jerry_> reaszon why i am asking this is ecause i want to once when the function is done i want to get number 1 out
12:09:55 <paolino> > either (error "Left") head $ Right [1,2,3,4,5]
12:09:55 <lambdabot>   1
12:09:56 * hackagebot virthualenv 0.2 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/virthualenv-0.2 (BartoszCwiklowski)
12:10:08 <ion> > case Right [1,2,3,4,5] of Right (a:_) -> a; _ -> 0
12:10:09 <lambdabot>   1
12:10:41 <ion> paolino: ‚Äúerror‚Äù isn‚Äôt a very good general suggestion.
12:10:55 <rwbarton> neither is 0 :P
12:11:25 <lolno> hello
12:11:26 <paolino> neither head
12:11:27 <Nisstyre> I would tend to disagree with that viewpoint
12:11:30 <jerry_> ion: i dont understand this at all
12:11:32 <ion> Given no information about what to return when the pattern doesn‚Äôt match, an example of returning *something* is better than an exmple of returning bottom. :-)
12:11:34 <jerry_> when i am on ghci
12:11:41 <jerry_> and i run this function
12:11:54 <jerry_> this function returns exactly this "Right [1,2,3,4,5]
12:12:06 <jerry_> if i say let a = this function'
12:12:20 <jerry_> now a = Right [1,2,3,4,5]
12:12:30 <ion> a is either Right ‚Ä¶ *or* a function.
12:12:32 <jerry_> cant you say "head a"
12:12:36 <rwbarton> no
12:12:44 <rwbarton> a is not a list
12:12:56 <jerry_> ok whjat function can i apply to "a" to get number 1 out
12:13:07 <ion> > case Right [1,2,3,4,5] of Right (a:_) -> a; _ -> 0
12:13:07 <rwbarton> case a of Right (x:_) -> x
12:13:14 <lambdabot>   mueval: ExitFailure 1
12:13:14 <lambdabot>  mueval-core: Time limit exceeded
12:13:15 <rwbarton> don't give a default case...
12:14:02 <rwbarton> jerry_: you can also write something like "let Right b = a"
12:14:05 <rwbarton> and then "head b"
12:14:16 <paolino> case a of Right xs -> head xs
12:14:24 <jerry_> rwbarton: oh ok.,....that sounds like an option
12:14:38 <rwbarton> or for that matter "let Right (x:_) = a" and then x will be 1
12:14:45 <Dodek> in Prelude documentation, i found that there's an instance Functor ((,) a)
12:15:07 <Dodek> but when i try fmap (1+) (2, 3), i get no instance error, instead of (3, 4) i expected
12:15:16 <Dodek> what am i doing wrong?
12:15:24 <paolino> > fmap (+1) (1,1)
12:15:25 <lambdabot>   (1,2)
12:15:29 <ion> import Control.Monad.Instances (or just import Control.Applicative, you‚Äôll get it indirectly)
12:15:49 <hpc> @quote golf
12:15:49 <lambdabot> No quotes match. stty: unknown mode: doofus
12:16:29 <Dodek> ion: importing C.M.Instances helps, but C.Applicative not
12:16:46 <paolino> > fmap (const "ciao") (1,1)
12:16:46 <Dodek> anyway, now i'm puzzled at the result
12:16:46 <lambdabot>   (1,"ciao")
12:17:27 <Dodek> instance Functor ((,) a) where fmap f (x,y) = (x, f y)
12:17:28 <Dodek> oh.
12:17:30 <rwbarton> think about the type of fmap for Functor ((,) a)
12:17:56 <ion> @type fmap `asAppliedTo` (undefined :: (a,b))
12:17:56 <lambdabot>     Couldn't match expected type `a -> b'
12:17:57 <lambdabot>            against inferred type `(a1, b1)'
12:17:57 <lambdabot>     In the second argument of `asAppliedTo', namely
12:18:06 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: (a,b))
12:18:06 <lambdabot> forall a b a1. (a -> b) -> (a1, a) -> (a1, b)
12:21:55 <Dodek> anyway, it's kind of fun to see familiar terminology (e.g. functors) in unfamiliar setting (programming)
12:24:32 <shapr> Dodek: Funny, I feel the same way when I take math classes and all my Haskell fun is suddenly applicable.
12:26:33 <hpc> shapr: even more fun is when your compilers/parsing class is suddenly applicable to people who insist "you should put the comma inside the quote," or something like that
12:26:45 <shapr> eh?
12:27:02 <hpc> because you can show that their "style rule" introduces ambiguity
12:27:50 <shapr> Oh right!
12:28:13 <Dodek> hpc: my native language puts comma outside of the quote by default. :)
12:28:15 <Peaker> do you need parsing class for that? :)
12:28:21 <shapr> Dodek: lucky you!
12:28:27 <shachaf> hpc: It's pretty obvious that it introduces ambiguity, I think.
12:28:31 <shachaf> English is full of ambiguity.
12:28:55 <hpc> shachaf: but thanks to the class, you can give a long wordy explanation with words the english major doesn't understand
12:29:06 <hpc> thereby providing a proof of your correctness :P
12:29:34 <serega> Hi there. I get a compilation error which I don't understand well. Playing in GHCi with the same code goes smooth. Can anybody drop an eagle eye at my humble piece of code please? http://pastebin.com/DaeuMEvs http://pastebin.com/D9Erdsir
12:29:37 <mauke> The pastes DaeuMEvs D9Erdsir have been copied to http://hpaste.org/53669 http://hpaste.org/53670
12:29:37 <shachaf> hpc: Try giving the explanation to ddarius. :-)
12:29:56 * hackagebot cqrs 0.4.0 - Command-Query Responsibility Segregation  http://hackage.haskell.org/package/cqrs-0.4.0 (BardurArantsson)
12:30:16 <hpc> whoa, mauke's script handles multiple pastes
12:30:18 <shachaf> serega: Try commenting out the type signature and then using ":t" in ghci.
12:30:37 <shachaf> Also, don't use length. :-(
12:31:03 <shachaf> Well, I guess it's not that horrible there... But your program has a bug, also, I think.
12:31:42 <rwbarton> the bug is that you can't tell whether there's a bug
12:32:15 <serega> shachaf: oh... it seems I must specify the Eq typeclass constraint for the parameter. Thank you very much!
12:34:15 <shachaf> Oh, I guess the bug I thought there was wasn't.
12:34:58 * hackagebot cqrs-example 0.4.0 - Example for cqrs package  http://hackage.haskell.org/package/cqrs-example-0.4.0 (BardurArantsson)
12:35:06 <shachaf> serega: Anyway, yes; in order to compare things, you must have Eq.
12:35:24 <copumpkin> compare things for equality
12:35:34 <shachaf> Right.
12:35:48 <shachaf> That's also what the GHC error was telling you, though maybe getting used to GHC errors can take some time.
12:36:48 <serega> shachaf: I was sure this is going to be checked when I try to call the function with a certain parameter types. That's cool Haskell is that strict.
12:38:14 <serega> also, I've tried things like [1,1] == [1,1] in GHCi and I thought Eq is defined for any [a]
12:38:39 <ski> try `[getChar,getChar] == `[getChar,getChar]'
12:38:52 <ski> or `[not,not] == `[not,not]'
12:39:23 <shachaf> > not == not -- lambdabot's instance can be misleading
12:39:24 <lambdabot>   *Exception: (==): No overloading for function
12:40:11 <serega> ski: ah, really. [1,1] == [1,1] works due to the 'Eq Int' definition, not a generic one for all list
12:40:35 <lewis1711> would it be incorrect to call foldr "overloaded"? I didn't think haskells type class polymorphism thing was true overloading, but..
12:40:53 <shachaf> serega: Yes. There's an instance Eq a => Eq [a]
12:41:04 <shachaf> lewis1711: foldr doesn't use any type classes.
12:41:29 <shachaf> lewis1711: Also, who decides waht "true overloading" is?
12:41:36 <shachaf> Ask them and I'm sure they can answer for you. :-)
12:41:38 <lewis1711> hmm yeah. it's polymorphic though
12:42:03 <Cale> serega: there's two instances which the compiler uses together
12:42:19 <shachaf> lewis1711: http://en.wikipedia.org/wiki/Parametric_polymorphism
12:42:40 <lewis1711> well, it's an old exam question :/ foldr is... polymorphic, overloaded, curried, recursive, higher-order. I figured overloaded was the least correct
12:42:41 <ski> lewis1711 : `foldr' is polymorphic. in some other languages this is sometimes called "generic" (e.g. Ada,Java (and C++ ?))
12:43:05 <ski> `foldr' is not overloaded, right
12:43:07 <Cale> lewis1711: Everything except overloaded
12:43:28 <shachaf> foldr isn't curried unless someone curries it. :-)
12:43:42 <shachaf> (Or, rather, produces it by currying.)
12:43:42 <Cale> well, the standard definition of it is
12:43:44 <lewis1711> yeah that was my other guess:/
12:45:09 <Philippa> type classes were originally introduced as a means of supporting slightly less ad-hoc overloading, though
12:45:24 <Philippa> we don't see them that way these days, of course
12:46:06 <lewis1711> that's how i see them tbh
12:46:14 <Cale> (but foldr isn't typeclass polymorphic)
12:46:25 <copumpkin> I have a version that is
12:46:30 <lewis1711> and sort of analagous to generic types, like ski said
12:46:48 <copumpkin> foldrCtx :: All ctx as => Context ctx -> (forall a. ctx a => a -> b -> b) -> b -> HList as -> b
12:46:53 <lewis1711> though I don't know much at all
12:47:21 <Cale> They're vaguely like Java interfaces, but somewhat more precise in that they're not conflated with types.
12:47:45 <Saizan> what's Context?
12:47:57 <copumpkin> Saizan: data Context (ctx :: * -> Constraint) = Context
12:48:00 <copumpkin> :)
12:48:10 <copumpkin> Saizan: you can define foldrCtx without it, but you can never call it
12:48:12 <Saizan> ah :)
12:48:28 <rwbarton> couldn't you use a kind-polymorphic proxy type
12:48:46 <copumpkin> I don't have kind polymorphism
12:48:58 <rwbarton> oh, how tragic
12:49:01 <copumpkin> I couldn't get it to work when I tried it :)
12:49:16 <copumpkin> there's also the more traditional: foldrH :: (forall a as. a -> b as -> b (a, as)) -> b () -> HList as -> b as
12:49:30 <copumpkin> which could probably be used to implement the other one
12:49:36 <copumpkin> with some suitable newtyping
13:05:45 <dropdrive> I just wrote the "obvious" function with signature [a->b] -> a -> [b].  Is it true that there is only one (non-trivial) function with this signature, and more generally, does it hold of m (a->b) -> a -> m b?  If so, is it possible to only specify the type signature and have GHC do the rest?
13:06:09 <hpc> dropdrive: ooh, good question
13:06:15 <hpc> dropdrive: do you understand Functor?
13:06:27 <dropdrive> hpc: More or less, yes.
13:06:31 <hpc> sweet
13:06:36 <aristid> :t flip
13:06:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:06:44 <hpc> aristid: spoilers... :P
13:06:48 <aristid> hpc: :)
13:07:08 <hpc> dropdrive: so, imagine something like
13:07:13 <hpc> :t ($ 5)
13:07:13 <lambdabot> forall a b. (Num a) => (a -> b) -> b
13:07:26 <hpc> :t \f -> f 5 -- more clearly
13:07:26 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
13:08:04 <hpc> dropdrive: so we have a data structure full of functions and we want to apply our 'a' to every function inside, without changing the structure
13:08:11 <dropdrive> hpc: I follow.
13:08:22 <hpc> dropdrive: "without changing the structure" and "apply to every function inside" sounds like fmap, but what do we fmap?
13:08:40 <hpc> :t \x structure -> fmap ($ x) structure
13:08:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
13:08:54 <hpc> or to match your type
13:09:03 <hpc> :t \structure x -> fmap ($ x) structure
13:09:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
13:09:20 <hpc> dropdrive: this matches the (much fancified) type of flip that aristid pointed out earlier
13:09:34 <dropdrive> hpc: I see.
13:09:43 <dropdrive> hpc: And what about uniqueness?
13:09:44 <hpc> > flip [(+ 1), (* 2), (+ 117)] 5
13:09:45 <lambdabot>   [6,10,122]
13:10:51 <hpc> dropdrive: i know there's multiple definitions with the type [a -> b] -> a -> [b]
13:10:58 <hpc> :t \_ _ -> []
13:10:59 <lambdabot> forall t t1 a. t -> t1 -> [a]
13:11:12 <dropdrive> hpc: I did say non-trivial :)
13:11:35 <hpc> dropdrive: i do not know that there is any other definition of the type f (a -> b) -> a -> f b
13:12:09 <hpc> Functor f => ... -- rather
13:12:34 <hpc> my suspicion is that when it's fully polymorphic like that, there's only the one definition
13:13:09 <aristid> at least without involving bottom
13:14:24 <ski> dropdrive : `\functions input -> reverse (map ($ input) functions)'
13:14:35 <dropdrive> hpc: So the "flip" that I'm used to is actually flip for (-> c) (or something like that)?
13:14:53 <hpc> dropdrive: exactly
13:14:57 <hpc> :t Prelude.flip
13:14:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:15:12 <hpc> er
13:15:24 <hpc> for (->) a, rather
13:15:55 <dropdrive> hpc: Is it possible to make lambdabot spit out flip for (->) a ?
13:16:10 <ski> @djinn (a -> b -> c) -> b -> a -> c
13:16:10 <dropdrive> hpc: And then flip for [] ?
13:16:10 <lambdabot> f a b c = a c b
13:16:43 <hpc> @src flip
13:16:43 <lambdabot> flip f x y = f y x
13:16:51 <ski> @djinn-env
13:16:51 <lambdabot> data () = ()
13:16:52 <lambdabot> data Either a b = Left a | Right b
13:16:52 <lambdabot> data Maybe a = Nothing | Just a
13:16:52 <lambdabot> data Bool = False | True
13:16:52 <lambdabot> data Void
13:16:53 <lambdabot> type Not x = x -> Void
13:16:55 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
13:16:57 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:17:02 <aristid> ski: spammer :P
13:17:03 <ski> @djinn-add class Functor f where fmap :: (a -> b) -> (f a -> f b)
13:17:11 <ski> @djinn Functor f => f (a -> b) -> (a -> f b)
13:17:12 <lambdabot> -- f cannot be realized.
13:17:29 <ski> so, djinn isn't smart enough to figure out this one
13:17:41 <hpc> ski: might want to @djinn-env and make sure it was added :P
13:17:44 <ski> (because it doesn't understand higher-rank types)
13:18:08 <ski> hpc : i'll leave that exercise to the interested listeners :)
13:18:14 <ski> (in private, of course)
13:18:15 <dropdrive> So given a signature, is it a mechanical procedure to figure out if it's uniquely populated (assuming non-bottom, non-trivial, whatever that means concretely)
13:18:31 <shachaf> @djinn ((c -> d) -> f c -> f d) -> f (a -> b) -> (a -> f b)
13:18:31 <lambdabot> -- f cannot be realized.
13:18:34 <shachaf> Hmm.
13:18:40 <shachaf> @djinn ((c -> d) -> f c -> f d) -> (a -> b) -> (f a -> f b)
13:18:40 <lambdabot> -- f cannot be realized.
13:19:03 <hpc> dropdrive: i think so; i haven't read Theorems For Free though, which is the paper on the topic
13:19:07 <hpc> @where theorems for free
13:19:07 <lambdabot> I know nothing about theorems.
13:19:11 <hpc> @where djinn
13:19:11 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
13:19:20 <hpc> @where free
13:19:20 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
13:19:47 <dropdrive> hpc: Cool, thanks.  I think I might have asked here years ago, but it would be nifty if you could write signatures and GHC does the rest :)
13:21:01 <shachaf> dropdrive: I doubt it is.
13:21:21 <ski> dropdrive : well, djinn could probably be extended to handle at least some higher-rank types
13:21:29 <dropdrive> hpc: Last question -- where is this cooler flip defined?  Only the (->) a flip shows up on hoogle
13:21:38 <hpc> dropdrive: it's a lambdabot thing
13:21:39 <ski> dropdrive : in lambdabot
13:22:07 <hpc> iirc, the exact code is flip fs x = fmap ($ x) fs
13:22:13 <dropdrive> shachaf: You doubt which part exactly?  "mechanical procedure"?
13:22:23 <shachaf> Yes.
13:22:33 <ski> dropdrive : see <http://code.haskell.org/lambdabot/State/L.hs>
13:23:16 <dropdrive> ski: I see, thanks.
13:23:17 <aristid> :t \fs x -> fmap ($ x) fs
13:23:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
13:23:22 <aristid> @pl \fs x -> fmap ($ x) fs
13:23:22 <lambdabot> flip (fmap . flip id)
13:23:43 <hpc> :t let flip = flip (fmap . flip id) in flip
13:23:44 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
13:23:44 <lambdabot>     Probable cause: `flip' is applied to too many arguments
13:23:44 <lambdabot>     In the expression: flip (fmap . flip id)
13:23:55 <hpc> :P
13:23:58 <DanBurton> defining flip in terms of flip :P
13:24:12 <DanBurton> :t let flip = flip
13:24:13 <lambdabot> <no location info>: not an expression: `let flip = flip'
13:24:13 <ski> i suggested this generalized `flip' to Cale some while ago, as a counterpart to his generalized `(.)'
13:24:19 <DanBurton> :t let flip = flip in flip
13:24:20 <lambdabot> forall t. t
13:24:46 <tomprince> :t let flip' = flip (fmap . flip id) in flip'
13:24:47 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:25:14 <ski> @type let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip
13:25:15 <tomprince> :t let flip = Prelude.flip (fmap . Prelude.flip id) in flip
13:25:15 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:25:16 <lambdabot> forall (f :: * -> *) a c. (Functor f) => f (a -> c) -> a -> f c
13:25:35 <ski> (when i doubt, use brute force)
13:25:45 <shachaf> ski: Brilliant!
13:25:46 <DanBurton> ski: why ask for the type when you specify the type
13:25:52 <shachaf> I'll define all my functions that way from now on.
13:26:00 <ski> DanBurton : well, to check that it's consistent
13:27:45 <Hakomak> hello, can i ask a quick question here?
13:27:53 <shachaf> Hakomak: You just did.
13:27:57 <hpc> Hakomak: yes, but unfortunately that was it
13:28:01 <shachaf> That's your allotment for today, though.
13:28:02 <ski> you may also ask longer questions
13:28:25 <DanBurton> Hakomak: is it in any way vaguely related to Haskell? If so then yes.
13:28:29 <tomprince> ski: Is your definition eluatable?
13:28:36 <hpaste> Hakomak pasted ‚Äútranspose‚Äù at http://hpaste.org/53671
13:28:44 * shachaf eluates ski's definition.
13:28:45 <Hakomak> http://hpaste.org/53671
13:28:47 <ski> (you see, you may only ask one *quick* question, but as many non-quick questions as you like)
13:28:48 <tomprince> s/eluatble/evaluateable
13:29:05 <ski> tomprince : i wouldn't expect so, but try ?
13:29:06 <Hakomak> i get inferred type not general enough
13:29:15 <Hakomak> or too general
13:29:18 <Hakomak> cant remember
13:29:33 <Hakomak> bottom line is i for some reason return an [[Integer]]
13:29:44 <ski> Hakomak : tried adding `Ord a => ' after the ` :: ' ?
13:29:56 <ski> hm, no, that's not enough
13:30:10 <ski> (or is it ?)
13:30:13 <Hakomak> what would that do?
13:30:17 <tomprince> @ let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Maybe $ \x -> x + 5)
13:30:35 <Hakomak> what the hell is that
13:30:42 <Hakomak> i assume it does what i want
13:30:51 <hpc> no, that's from before you joined
13:30:56 <Hakomak> k
13:31:03 <tomprince> :t let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Maybe $ \x -> x + 5)
13:31:04 <lambdabot> Not in scope: data constructor `Maybe'
13:31:08 <hpc> Hakomak: perhaps you could rewrite it without using (!!)
13:31:13 <tomprince> :t let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Some $ \x -> x + 5)
13:31:14 <lambdabot> Not in scope: data constructor `Some'
13:31:20 <tomprince> :t let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Just $ \x -> x + 5)
13:31:21 <lambdabot> forall a. (Num a) => a -> Maybe a
13:31:24 <ski> Hakomak : what's the type of `longest' ?
13:31:27 <tomprince> :t let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Just $ \x -> x + 5) 6
13:31:27 <lambdabot> forall a. (Num a) => Maybe a
13:31:31 <Hakomak>  @hpc: ive thought about that
13:31:41 <hpc> Hakomak: hint: what's the top row of a transposed matrix, and what's the rest of the rows
13:31:43 <tomprince> :t let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Just $ \x -> x + 5) 6 :: Maybe Int
13:31:44 <lambdabot> Maybe Int
13:31:51 <tomprince> @ let flip :: forall f a b. Functor f => f (a -> b) -> (a -> f b); flip = flip (fmap . flip id) in flip (Just $ \x -> x + 5) 6 :: Maybe Int
13:32:20 <Hakomak> the top row is the last column of the untransposed matrix isnt it
13:32:38 <Hakomak> or the first
13:32:42 <Hakomak> its the first
13:32:48 <rotflcopter> cool
13:32:49 <rotflcopter> :)
13:33:25 <Hakomak> Ord doesnt help by the way
13:33:36 <dropdrive> hpc, ski, shachaf: Thanks for the informative discussion about flip :)  -- I might read "theorems for free" -- is it still the recommended treatment these days (22 years later)?
13:34:07 <hpc> dropdrive: more or less, yeah
13:34:20 <shachaf> The theorems might have eroded over time. It's a well-known property of theorems taht they're only for for ~15 years after being proven before special cases start to come up.
13:34:46 <ski> Hakomak : what's the type of `longest' ?
13:34:55 * shachaf accidentally a bunch of words there.
13:35:18 <Hakomak> Int
13:35:26 <hpc> shachaf: that was proved 30 years ago, so now there are exceptions
13:35:26 <tomprince> ski: Seems your definition is actually bottom.
13:35:56 <hpc> (diagonalize until logic breaks)
13:35:58 <shachaf> hpc: Right. After 25 years the negation of the theorem starts to be truer than the original.
13:36:06 <shachaf> tomprince: Yes -- I believe that was the point. :-)
13:36:39 <DanBurton> ski: longest :: a; longest = undefined;
13:36:51 * DanBurton grins evilly
13:37:18 <shachaf> That's not very impressive as evil goes.
13:37:22 <DanBurton> or slightly less evil: longest = unsafeCoerce
13:37:43 * DanBurton is not very good at evil-doing
13:37:48 <ski> tomprince : yeah, i suspected so, but was too lazy to check
13:38:42 <ski> Hakomak : hm, `longest' must be a function, at the very least
13:38:43 <dropdrive> shachaf: Very droll -- but I'd argue that *treatments* of theorems do erode over time.
13:38:54 <Hakomak> it is
13:39:03 <ski> so it can't have type `Int'
13:39:12 <ski> (since that's not a function type)
13:39:12 <Hakomak> oh im sorry
13:39:27 <Hakomak> yeah youre right
13:39:28 <DanBurton> I'm guessing it finds the length of the longest list in a list of lists
13:39:33 <Hakomak> it takes an [[Integer]]
13:39:43 <Hakomak> thanks a lot
13:41:47 <DanBurton> longest = length . maximumBy (comparing length)
13:41:47 <dropdrive> So what is the framework in which we "prove" things like:  a -> (a->b) -> b  has a unique "realization"?  It certainly seems true.
13:43:04 <shachaf> DanBurton: ...Or maximum . map length?
13:43:18 <shachaf> Anyway, length is evil.
13:43:24 <ski> Hakomak : anyway, what i would do in your case is : (a) comment out the type signature; (b) ask your interactor what type it inferred for `transpose'; (c) put that as your type signature, maybe after polishing it up a little
13:43:26 <DanBurton> shachaf: nope. There is only One Right Way to do things in Haskell >.>
13:43:38 <shachaf> DanBurton: But there are many wrong ways...
13:43:43 <hpc> DanBurton: and that way is to do it all of the other ways, then use continuations
13:43:46 <hpc> :D
13:44:04 <DanBurton> shachaf: actually Haskell's basically the opposite. If you try to do it the wrong way, the typechecker says no
13:44:15 <shachaf> Not necessarily.
13:44:36 <DanBurton> but still often true
13:45:47 <DanBurton> Hakomak: I loaded the file into ghci and it worked perfectly, with the definition  longest = length . maximumBy (comparing length)
13:46:13 <Hakomak> yeah, the problem was that i defined longest as [[Integer]] -> Int
13:46:17 <Hakomak> i already said so
13:46:33 <DanBurton> Hakomak: ah I missed that
13:49:51 <lpsmith> So is there example code for GHC 7 to implement something along the lines of "Dynamic Applications from the Ground Up?"   http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.113.1406
13:55:09 <etpace> Has anyone here used haskell-llvm? I'm trying to get some toy example working (specifically anonymous functions) and I was wondering if anyone had experience with the bindings (or maybe the llvm) could give some pointers of what to read (something more involved than the examples on github)
14:04:14 <Maggi> hello, I'd like to read up on combinatory-parsing, any recommended papers (both general and Haskell-specific)?
14:26:03 <Maggi> anybody?
14:26:21 <Cale> Maggi: hi
14:26:53 <Maggi> Cale: hello
14:27:03 <Cale> Maggi: Hmm, good papers on combinator parsing... well, I would recommend the (somewhat old, but still relevant) original Parsec documentation as a good intro
14:27:10 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
14:27:55 <Cale> http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf is the paper introducing Parsec
14:29:00 <Cale> http://eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf -- here's a more basic paper introducing how combinator parsing works -- the implementation they choose is not the most efficient, but it is easy to understand.
14:29:35 <Maggi> Cale: thanks, was more looking for more general papers, e.g. pre-parsec, the basic idea and motivation behind combinatory-parsing
14:29:50 <Maggi> Cale: ah, thanks!
14:31:08 <Cale> Oh, and that's apparently the condensed version of http://www.cs.nott.ac.uk/~gmh/monparsing.pdf
14:31:34 <Cale> http://www.cs.nott.ac.uk/~gmh/bib.html#pearl has links to the corresponding source code
14:33:03 <ExFalso> hello there, what should i do if cabal keeps downloading and reinstalling dependency packages whenever i 'cabal install' my project?
14:33:06 <Cale> http://www.cse.chalmers.se/edu/course/afp/Papers/parser-claessen.pdf is another good paper moving in the direction of implementing combinator parsing efficiently while preserving nice operations on parsers.
14:33:58 <Maggi> Cale: thanks, that's exactly what I was looking for, also has references to the original ideas
14:34:01 <Cale> ExFalso: I wish I knew the answer to that. I've had it happen with various other people's packages.
14:35:25 <Eduard_Munteanu> Maybe some deps actually fail to build correctly?
14:35:37 <Eduard_Munteanu> I've had that happening, IIRC.
14:36:02 <Cale> Maggi: It's worth noting that this last paper's library comes with GHC in the form of Text.ParserCombinators.ReadP -- for being in the base package and being generally pretty efficient, that library could use a little more popularity.
14:36:37 <Cale> Eduard_Munteanu: I've had it go ahead and install the same version of an already existing package, which of course, breaks all the existing dependencies of that package.
14:37:06 <ExFalso> Eduard_Munteanu: one of those packages is Network, i reckon that should build fine
14:37:09 <Cale> The problem is not so much that it does this, but that it doesn't explain why it needs to do it, or ask whether it's really okay.
14:38:18 <Cale> I think it's a subtle problem having to do with which versions of other packages each package was built against.
14:39:45 <Cale> (if your package depends on a newer version of some package which network depends on than the version which network was built against, then the same version of network gets rebuilt to make it depend on the newer version of that package instead
14:39:53 <Cale> )
14:40:34 <Cale> This sort of thing would be fine, except that cabal doesn't seem to pick up the resulting mess by rebuilding all the deps of the package that it's replacing.
14:40:51 <Cale> er, sorry, all the things which depend on the package which it's replacing
14:41:09 <dcoutts> unfortunately that's not possible in general
14:41:26 <dcoutts> and we can't find out without trying it
14:41:34 <Cale> hmmm
14:41:43 <dcoutts> unless... we have a nix-style persistent package db!
14:42:01 <dcoutts> in which case we can try it without breaking anything
14:45:58 <Cale> Just the other day, I ended up in a cycle where I would install... I think it was network, text, parsec, and hexpat, in some sensible order, and when I got to hexpat, it would want to rebuild text, which would break parsec and network, and, I can't quite remember the details, but it was package whack-a-mole
14:46:18 <Cale> Eventually I realised that installing all 4 packages at the same time might work, and it did
14:46:29 <Eduard_Munteanu> So it's this about having different versions of the same package?
14:46:47 <dcoutts> Cale: that's always the right thing to do, install them simultaneously
14:46:59 <dcoutts> if you want to use them together, install them together
14:47:06 <dcoutts> it ensures they have consistent deps
14:47:11 <dcoutts> or it fails
14:47:20 <shapr> How does debian solve all this craziness?
14:47:32 <dcoutts> shapr: by making sure the solver never fails
14:47:41 <sagelywizard> When using do notation, do all of the variables you're binding to need to be of the same type?
14:47:45 <shapr> So the package graph is always safe?
14:47:52 <Cale> dcoutts: It would just be nice if all installed packages in any given package db were required to be consistent with each other?
14:47:55 <ski> shapr : no
14:48:00 <dcoutts> shapr: right, which involves a lot of work
14:48:00 <ski> er
14:48:05 <ski> sagelywizard : no
14:48:16 <Cale> dcoutts: maybe we could have named package dbs to make up for the obvious problem with that?
14:48:17 <shapr> dcoutts: And can't easily be done in a distributed manner...
14:48:18 <dcoutts> Cale: sadly then you'd not be able to install ver much
14:48:27 <dcoutts> shapr: right
14:48:28 <shapr> not without building some sort of invariants into the installer itself (cabal).
14:48:39 <shapr> Sounds like much work.
14:48:42 <hpaste> DanBurton pasted ‚ÄúCreating a list with a variadic argument function‚Äù at http://hpaste.org/53673
14:48:56 <dcoutts> Cale: again the solution is nix-style package dbs
14:49:30 <DanBurton> any thoughts? ^
14:49:39 <dcoutts> Cale: then you can have two packages installed at once and it doesn't matter if they have consistent deps (as long as you're not trying to use both simultaneousl in one package)
14:50:18 <Cale> dcoutts: and what happens when you try to use both at once?
14:50:33 <DanBurton> it's supposed to work like this: listM 'a' 'b' 'c' :: String => "abc"
14:50:53 <Cale> I usually want all my installed packages to be usable together, and if they're not all usable together, I want to at least know about it.
14:51:00 <DanBurton> which it does; but it gets a little wonky with numbers
14:51:19 <dcoutts> Cale: well if you were using cabal it'd complain, if you use ghc directly you'd either get a type error or a message about not being able to link multiple instances of the same package
14:51:31 <dcoutts> Cale: problem is, we don't really know if you can use them together
14:51:36 <Cale> hmm
14:52:01 <dcoutts> Cale: e.g. it's ok to have two instances of parsec in your package graph, so long as they're encapsulated
14:52:05 <Cale> oh
14:52:27 <dcoutts> and we don't really know for sure if they're encapsulated without just typechecking it
14:52:29 <Cale> I also don't want to have more than one version of any package installed, and I *really* want to know about it if that's about to happen.
14:52:36 <dcoutts> we can make conservative approximations
14:52:49 <Cale> I really wish that cabal would warn me and make me type "yes" whenever it was about to do that.
14:53:00 <dcoutts> Cale: but that's not the case, you do want two versions if that's the only possible solution
14:53:07 <Cale> Or give me the option of unregistering the other package and rebuilding things against the new one
14:53:26 <Cale> Yeah, only if that's the only possible solution
14:53:36 <dcoutts> it's likely not your fault either, it's some random package you depend on that wants parsec 2, and another one that wants parsec 3
14:53:45 <Cale> I will happily rebuild everything to avoid it
14:53:53 <dcoutts> there's nothing you can rebuild to solve it
14:53:57 <ski> `type Elem (Elem r -> r) = Elem r' sounds fun
14:54:00 <Cale> Well, sure, sometimes.
14:54:24 <Cale> But often there's the better solution of upgrading wholesale and rebuilding everything against the new version.
14:54:50 <DanBurton> ski: :) but for some sad reason, you can't use type synonym family application in typeclass declarations :(
14:54:56 <dcoutts> Cale: sure, but it means we have to allow situations where there are multiple instances in the package graph (not just in the db)
14:55:15 <dcoutts> Cale: and it's not very easy to tell if that was deliberate or not
14:55:28 <Cale> dcoutts: Sure, you have to allow it, but as a user, I would really like the automatic process to stop and warn me before it happens.
14:55:38 <Cale> and for cabal to explain why it thinks it's necessary
14:55:40 <dcoutts> Cale: if you cabal install a; cabal install b; ghci -package a -package b, it's really hard to know
14:55:45 <ski> DanBurton : hm, have you tried with the extension that allows to use type synonyms in instances ?
14:56:04 <DanBurton> ski: yeah, no dice.
14:56:31 <DanBurton> I tried with TypeSynonymInstances
14:56:35 <dcoutts> Cale: if you were using cabal with your local package c that depends on a and b, then cabal would require that the deps are consistent (or known to be properly encapsulated)
14:57:02 <Cale> hmmm
14:57:03 <dcoutts> Cale: but that's a conservative approximation
14:57:47 <dcoutts> Cale: but perhaps ghc should try and enforce the same property, and only try to load both instances of some not-known-to-be-encapsulated package if you explicitly request it
14:57:59 <Cale> dcoutts: another thing is that we have packages like text which do super-evil things like using CPP to tell whether or not you have deepseq installed and only providing an NFData instance when the deepseq package was installed before text
14:58:29 <dcoutts> Cale: that's not necessarily super-evil
14:59:02 <dcoutts> Cale: actually, it's more complicated than that
14:59:07 <dcoutts> I think
14:59:32 <Cale> It is really really frustrating that I have to know to install deepseq before text if I plan on using that NFData instance
15:00:06 <Cale> especially when I've already installed text and a bunch of its deps, and I'm going to have to break all my packages to fix the problem
15:00:33 <dcoutts> Cale: I don't think that's right. the current text package just depends on deepseq (though conditional on ghc-6.10)
15:00:48 <dcoutts> so deepseq must be installed first, there's no other way
15:01:39 <Cale> errr
15:01:41 <Cale> hmm
15:02:01 <Cale> Dependencies	(array, base (<5), bytestring (‚â•0.9 & <1.0), extensible-exceptions) or (array, base (4.*), bytestring (‚â•0.9 & <1.0), deepseq (‚â•1.1.0.0), ghc-prim)
15:03:07 <dcoutts> Cale: oh that's nonsense, the hackage presentation is borked there. Look at the .cabal file.
15:03:31 <Cale> hmmm
15:03:36 <Cale> also in the source...
15:03:40 <Cale> #if defined(HAVE_DEEPSEQ)
15:03:40 <Cale> instance NFData Text
15:03:40 <Cale> #endif
15:04:09 <hinkes> Hi Haskellers, quick question.  I'm confused by a use of Iteratee.
15:04:19 <dcoutts> Cale: but HAVE_DEEPSEQ is defined if ghc >= 6.10, and in that case it's depending on deepseq
15:04:23 <hinkes> newtype Iteratee a m b
15:04:31 <Cale> okay
15:04:59 <hinkes> but I see things like this:  Iteratee Bytestream IO Response
15:05:02 <Cale> dcoutts: Well, perhaps it was another problem which was causing the NFData instance to be unusable
15:05:30 <hinkes> It looks like "Iteratee Bytestream IO Resposne" is missing the last argument.
15:05:32 <dcoutts> Cale: packages cannot (at least not with help from Cabal) use CPP to test if packages are installed
15:05:47 <hinkes> I think I'm missing something.
15:05:56 <dcoutts> Cale: you might be loading a different version of deepseq
15:06:03 <dcoutts> Cale: hence no instance is provided
15:06:24 <Cale> dcoutts: yeah, that's probably what it was. I ended up just getting rid of my whole package db and starting over.
15:06:29 <hinkes> Specifically I'm talking about the useage here: http://hackage.haskell.org/packages/archive/wai/0.4.2/doc/html/Network-Wai.html#t:Application
15:06:50 <dgpratt> hinkes: really? to me it looks like a = Bytestream, m = IO, b = Response
15:07:07 <hinkes> I thought IO by itself wasn't a type
15:07:24 <hinkes> I read it as a = Bytestream m = (IO Response)
15:07:36 <dgpratt> hinkes: well, it's polymorphic
15:07:36 <Cale> hinkes: IO is a type constructor
15:07:57 <dgpratt> hinkes: without the parens, it wouldn't be interpreted that way
15:07:59 <Cale> hinkes: the second parameter to Iteratee has to be a type constructor of kind * -> *
15:08:02 <rwbarton> hinkes: that would be written Iteratee Bytestream (IO Response)
15:08:27 <hinkes> ok, thanks.  This is a bit confusing to me.
15:08:36 <rwbarton> just like I can write  f [] length "hello"  and it doesn't mean  f [] (length "hello")
15:08:41 <Cale> Iteratee :: * -> (* -> *) -> * -> *
15:08:51 <hinkes> I thought in type definitions, the type variables must be types
15:08:53 <Cale> where * is the kind of types which have values in them
15:09:13 <Cale> IO :: * -> *
15:09:43 <Cale> so it's okay as the second parameter to Iteratee
15:09:51 <rwbarton> terminology varies as to whether a "type" is necessarily of kind *
15:09:53 <dgpratt> terminology question: type constructors are types, yes?
15:09:55 <Cale> This is perhaps clearer too if you look at the definition of Iteratee
15:10:14 <Cale> newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
15:10:48 <Cale> data Step a m b = Continue (Stream a -> Iteratee a m b) | Yield b (Stream a) | Error Exc.SomeException
15:10:59 <rwbarton> it seems natural to use "type" for the type of a value, so something of kind *, but then you need some other term like "type expression"(?) for things like "Either Bool"
15:11:31 <alpounet> Either Bool still is a type constructor
15:11:34 <hinkes> Right, so by the definiation it makes sense that m needs another type after it.
15:11:50 <rwbarton> that terminology seems strange to me, is "Maybe Bool" a data constructor?
15:11:55 <Cale> hinkes: Yeah, it takes a type as a parameter
15:11:57 <rwbarton> er "Maybe True"
15:12:16 <Cale> hinkes: In fact, I think that in order for most of the stuff on Iteratees to work, m has to be a monad, even.
15:12:23 <rwbarton> At any rate, type variables are surely not type constructors
15:12:25 <hinkes> But if you just looked at the newtype definition alone, what would stop me from using "Iteratee Int Bool String"
15:12:27 <sagelywizard> Is there a way to extract a value from a monad? Like, a function (M a -> a)? Like "extract_fun (Just 4)" -> "4"
15:12:46 <Cale> you mean just the left side of the = sign?
15:12:56 <simon> like <|>, is there a conjunction operator in parsec?
15:13:12 <Cale> simon: >> and the other monad operations
15:13:20 <simon> Cale, ah right.
15:13:30 <hpc> also the other applicative functions
15:13:56 <rwbarton> "conjunction operator"?
15:14:26 <Cale> hinkes: The kind of Iteratee is inferred from its entire definition and the kinds of the type constructors that occur in it
15:14:27 <rwbarton> As in you have two parsers and you want a parser that matches strings that match both of them?
15:15:16 <simon> rwbarton, well, I was thinking about >>.
15:15:32 <Cale> hinkes: as the kind system is simple enough that almost all kinds can be inferred in Haskell 98, that standard doesn't even let you provide kind signatures. You can provide them with GHC now if you use GADT syntax for type declarations
15:15:46 <Cale> er, for data declarations, I should say :)
15:16:06 <Cale> data Iteratee a m b :: * -> (* -> *) -> * -> * where
15:16:11 <hpc> Cale: some kinds can't be inferred?
15:16:31 <Cale>   Iteratee :: m (Step a m b) -> Iteratee a m b
15:16:37 <rwbarton> well consider  data Proxy a b = Proxy b,  what is the kind of a
15:16:46 <hpc> rwbarton: ah
15:16:53 <rwbarton> since there is no kind polymorphism, in Haskell 98, it defaults to *, but maybe I wanted something else...
15:16:55 <hpc> that's really obvious in retrospect
15:16:56 <Cale> hpc: H98 will give you a kind, but it might not be the one you really wanted
15:17:09 <parcs> Cale: i don't think that's correct
15:17:34 <parcs> that would mean Iteratee :: * -> (* -> *) -> * -> * -> (* -> *) -> * -> *
15:17:55 <Cale> parcs: whaaaaat
15:18:09 <Cale> oh
15:18:12 <rwbarton> yeah I don't think you want both the type variables and the kind
15:18:13 <hpc> Cale: f x y :: Int -> Int -> Int :P
15:18:15 <Cale> right, we leave the params off
15:18:23 <Cale> data Iteratee :: * -> (* -> *) -> * -> * where
15:19:33 <hinkes> Thanks guys/gals.  Is there a name for this type of thing that I'm getting hung up on?  I'll do some reading.
15:19:44 <Cale> hpc: Sometimes I've wanted the ability to specify the type of a complete expression as extra information for the typechecker.
15:20:15 <ski> hinkes : a name for what ?
15:20:24 <Cale> hinkes: I'm not sure exactly which part of it you're hung up on still
15:20:40 <ski> hinkes : for kinds not to match up ? -- kind checking is maybe what you're after, then
15:20:41 <Cale> But feel free to ask questions :)
15:21:33 <Cale> I guess you could call these higher-kinded types
15:22:12 <rwbarton> in general monad transformers provide many examples of these
15:22:29 <Cale> If higher-order functions are functions that take other functions as parameters, then these are type functions which take other type functions as parameters
15:22:59 <Cale> So "higher order type constructor" seems apt
15:23:05 <Cale> dinner for me :)
15:23:31 <hpc> functions are higher-valued values! they are values that take values as parameters
15:24:06 <Axman6> :o
15:24:59 * hackagebot snaplet-sedna 0.0.1.0 - Snaplet for Sedna Bindings. Essentailly a rip of snaplet-hdbc.  http://hackage.haskell.org/package/snaplet-sedna-0.0.1.0 (EricJones)
15:31:45 <erus`> has anyone implemented a triangle packing algorithm?
15:34:53 <Cale> hpc: the right analogy would be "higher-typed values", I think
15:37:51 <erus`> i thought this would be a fun one for you guys...
15:37:55 <erus`> you love maths
15:41:05 <DanBurton> Posted some SO questions based on my paste earlier: http://stackoverflow.com/questions/8031288/variadic-list-constructor-how-to-default-to-the-correct-type-and-get-type-safet and http://stackoverflow.com/questions/8031320/variadic-arguments-using-type-families-instead-of-multi-param-typeclasses
15:42:22 <DanBurton> @google triangle packing
15:42:23 <lambdabot> http://www.trianglepackage.com/
15:42:23 <lambdabot> Title: Food Packaging | VFFS, Weighing, Bag-In-Box
15:42:30 <DanBurton> @botsmack
15:42:30 <lambdabot> :)
15:42:41 <DanBurton> @google triangle packing algorithm
15:42:42 <lambdabot> http://research.microsoft.com/en-us/um/people/eyal/papers/trishort.pdf
15:42:42 <lambdabot> Title: A note on the random greedy triangle-packing algorithm
15:44:59 * hackagebot bounded-tchan 0.2.3 - Bounded Transactional channels (queues)  http://hackage.haskell.org/package/bounded-tchan-0.2.3 (ThomasDuBuisson)
15:54:47 <Mbarak_> Hello, i'm doing my very first haskell (and yesod) program and was wondering if I could get some help with it?
15:56:09 <adnam> Mbarak_: what do you need help with?
15:57:40 <Mbarak_> Basically I'm trying to put a Text.Feed.Item's description out onto a page, but when I do I get an error; something todo with Blaze HTML
15:58:10 <Mbarak_> more specifically it suggests i try to make an instance of Data.Foldable.Foldable IO
15:59:57 <mm_freak> Mbarak_: i suggest learning haskell before learning yesod
16:00:00 <sipa> Mbarak_: can you paste your code somewhere?
16:00:01 * JoeyA wasn't doing blaze nothing when he started learning Haskell.
16:01:04 <mm_freak> Mbarak: yesod uses many advanced haskell features, which will confuse you all the time‚Ä¶  you should at least have a basic understanding of haskell's type system before using yesod
16:01:13 <mm_freak> so read a tutorial like LYAH first
16:01:17 <hpaste> Mbarak pasted ‚ÄúMy Code‚Äù at http://hpaste.org/53675
16:01:47 <Mbarak> I am trying to get my feet wet with "something simple". and I did (albeit pretty quickly) read LYAH
16:02:46 <mm_freak> Mbarak: do you understand how to do IO (interact with the real world) in haskell?
16:02:58 <mm_freak> i.e. have you written some nontrivial command line programs?
16:03:14 <Mbarak> not in haskell...
16:03:23 <mm_freak> i'm asking specifically about haskell
16:03:23 <JoeyA> My favorite "somethings simple" for Haskell are solving algorithmic challenges.  That's how I got started.
16:03:41 <Mbarak> the way i understand the IO monad is that, it's a result wrapped in an IO operation
16:03:49 <luite_> Mbarak: getStories is an IO action, in a Handler, you run those with articles <- liftIO $ getStories "feeds.txt"
16:03:52 <Mbarak> and, the operation won't get run until it needs to?
16:03:54 <mm_freak> JoeyA: won't help you with yesod‚Ä¶  you need to have a good grasp about monads
16:04:12 <Mbarak> $forall article <- articles #I have that
16:04:51 <mm_freak> Mbarak: IO is just a language‚Ä¶  IO String is a real world interaction that eventually results in a String when performed
16:04:56 <luite_> Mbarak: that's different, that's just a loop in Hamlet, it's line 18 that you need to change
16:05:42 <Mbarak> so, I have to first perform the IO in my Handler, and then make that data available to hamlet
16:05:59 <JoeyA> Question about the design of the bounded-tchan package: Why are there two counters, readSize and writeSize?  Why not just one counter: the number of items currently in the channel?
16:06:09 <Mbarak> So, pass hamlet some non IO data?
16:06:27 <mm_freak> Mbarak: Handler is just a richer version of IO‚Ä¶  when you want to have IO actions as part of Handler actions, you need to liftIO them
16:06:32 <mm_freak> liftIO :: IO a -> Handler a
16:06:59 <luite_> Mbarak: yes if your hamlet contains article <- articles, then Hamlet expects articles to be a list
16:07:21 <Mbarak> right now articles is IO [Text.Feed.Item]
16:07:34 <luite_> Mbarak: so IO [a] won't do, it needs to be a :)
16:07:42 <mm_freak> Mbarak: rename that to getArticles
16:07:46 <mm_freak> it's an action
16:07:56 <mm_freak> then you can write:  articles <- getArticles
16:08:01 <mm_freak> in haskell, not in hamlet
16:08:09 <mm_freak> and finally use 'articles' in hamlet
16:08:16 <mm_freak> $forall article <- articles
16:08:25 <Mbarak> i thought hamlet could "see" all the variables I make? it 'sees' articles as IO [F.Item]
16:08:40 <mm_freak> it does see them, but it doesn't get a list of articles
16:08:44 <luite_> Mbarak: yep, but it can't do much with IO [F.Item]
16:08:47 <mm_freak> it gets an action to compute a list of articles =)
16:08:53 <Mbarak> so, I need to first unwrap it
16:09:06 <mm_freak> you need to make it a part of your Handler computation
16:09:11 <shachaf> There's no "unwrapping".
16:09:23 <mm_freak> by using <- you give names to results of subcomputations
16:09:28 <shachaf> x :: IO String doesn't "contain" a String any more than /bin/ls "contains" a list of files.
16:09:28 <DanBurton> you need to "perform" the computation first
16:09:38 <Mbarak> by "unwrapping" i mean, perform the operation
16:09:45 <mm_freak> Mbarak: you never "perform" operations
16:09:51 <shachaf> Someone should clearly write a "goose than lay the golden eggs" monad tutorial.
16:10:03 <mm_freak> Mbarak: your whole Handler computation is a computation which, when performed, results in a webpage
16:10:14 <DanBurton> IO Foo is a computation, usually involving IO, that needs to be performed in order to get the Foo
16:10:21 <mm_freak> Mbarak: you need to embed the computation, which fetches a list of articles, inside of your Handler computation
16:10:48 <Mbarak> Ok. so, let articles ... or let getArticles <- liftIO $ getStories "feeds.txt"
16:10:56 <luite_> Mbarak: no let
16:11:06 <luite_> and name it articles again
16:11:07 <Mbarak> make a function getArticles
16:11:29 <Mbarak> ?
16:11:33 <mm_freak> Mbarak: if you have [Article], then the right name is 'articles'
16:11:34 <Mbarak> or...just remove let?
16:11:44 <mm_freak> Mbarak: if you have IO [Article], then the right name is getArticles
16:11:48 <luite_> articles <- liftIO $ getStories "feeds.txt"
16:11:56 <luite_> that's what it should be
16:12:13 <Mbarak> wait, i don't have a handler articles, this is all in one handler...
16:12:26 <mm_freak> Mbarak: as i understood you have the latter version, but apparently that's not the case
16:12:35 <luite_> Mbarak: that's what you replace line 18 with
16:12:46 <Mbarak> luite_: if I do that, it complains about
16:13:04 <Mbarak> Ambiguous type variable `t0' in the constraints:
16:13:07 <mm_freak> Mbarak: btw, i just made up the Article type in this example‚Ä¶  you probably have something like Text, Builder or Html
16:13:13 <Mbarak>  Probable fix: add a type signature that fixes these type variable(s)
16:13:39 <Mbarak> The types i'm using is from feeds, Text.Feed.Feed and Text.Feed.Item
16:13:45 <luite_> Mbarak: ok, that means you're probably close. which line is it complaining about?
16:13:52 <Mbarak>     let articles = liftIO $ getStories "feeds.txt"
16:14:05 <Mbarak> I tried:     let articles = liftIO $ getStories "feeds.txt"  :: [F.Item] but
16:14:05 <mm_freak> Mbarak: articles <- liftIO $ getStories "feeds.txt"
16:14:16 <mm_freak> there is a big difference between "<-" and "="
16:14:17 <luite_> Mbarak: ...
16:14:44 <lewis1711> is there a nicer way of determining whether a list has an even or odd number of elements, than doing "even (length xs)" ? I remember doing that before and someone telling me off
16:14:50 <mm_freak> Mbarak: "=" introduces an equation in haskell‚Ä¶  it literally means "equals"
16:15:25 <Mbarak> i thought that was the let syntax? i guess i'm defining a function articles which is defined as liftIO $ getStories "feeds.txt"
16:15:27 <shachaf> mm_freak: Well, not literally.
16:15:28 <Mbarak> is that wrong?
16:15:42 <mm_freak> shachaf: not counting data/newtype/type definitions
16:15:43 <shachaf> Closer to ‚âù, surely. :-)
16:15:53 <DanBurton> lewis1711: no, that's about as good as it gets.
16:16:02 <Axman6> Mbarak: no thats right. but now you have to use the function articles to get its result
16:16:05 <mm_freak> Mbarak: you are defining a value
16:16:15 <luite_> Mbarak: it's better to see <- as performing the action on the right, and binding it to the name on the left
16:16:18 <shachaf> mm_freak: It's not symmetric, for instance. And you can't take a "foo = bar" statement on its own without context.
16:16:29 <mm_freak> Mbarak: you are saying that 'articles' and 'liftIO $ getStories "feeds.txt"' are the same thing
16:16:30 <luite_> Mbarak: binding the result
16:16:45 <Axman6> luite_: you could use this: (one sec)
16:16:53 <Mbarak> oooooooook
16:16:53 <DanBurton> lewis1711: you need to traverse the entire list in order to tell if it has an even or odd number of elements, so `length` is just fine in this case
16:16:54 <mm_freak> shachaf: as far as what you write is valid, "=" makes an equation
16:17:09 <mm_freak> shachaf: you can't write every equation, but when you write a valid one, it's an equation
16:17:27 <lewis1711> DanBurton: alright, i'm happy with that. I guess there is no way around it
16:17:39 <DanBurton> lewis1711: You could write it pointfree though: evenLength = even . length; instead of: evenLength xs = even (length xs)
16:17:45 <mm_freak> Mbarak: "<-" is for embedding actions into actions, and it's only valid in do-notation
16:17:55 <luite_> Mbarak: there's also #yesod, which is a bit quieter but usually also quite helpful
16:18:12 <mm_freak> Mbarak: where you have an IO Something on the right hand side, you write a pattern on the left side, which has the type Something
16:18:23 <Axman6> > let evenList [x] = False; evenList [] = True; evenList (_:_:xs) = evenList xs in map evenList [[],[1],[1,2],[1,2,3]]
16:18:24 <lambdabot>   [True,False,True,False]
16:18:42 <Mbarak> you guys are very helpful.  i don't think this is a yesod specific issue since, in yesod all i'm doing is #forall article <- article
16:18:44 <Mbarak> you guys are very helpful. i don't think this is a yesod specific issue since, in yesod all i'm doing is #forall article <- articles
16:18:48 <mm_freak> Mbarak: 'do a; b; c' = computation a, then computation b, then computation c‚Ä¶  throw away the results of a and b and make the entire computation result in c
16:19:09 <Mbarak> ooook. so, that's why i thought I had to use 'let'
16:19:12 <mm_freak> Mbarak: 'do a; x <- b; c' = computation a, then computation b, then computation c‚Ä¶  but give the result of 'b' the name 'x'
16:19:22 <DanBurton> > let evenLength = even . length in map evenLength [[],[1],[1,2],[1,2,3]]
16:19:24 <lambdabot>   [True,False,True,False]
16:19:29 <luite_> Mbarak: that's true
16:19:31 <Mbarak> if i do x <- b, does it automatically add that as a parameter to c?
16:19:40 <mm_freak> no
16:19:44 <mm_freak> it doesn't change anything per se
16:19:48 <mm_freak> unless you use the 'x' somewhere
16:19:55 <Mbarak> ok, i was afraid it did :p hence the use of 'let'
16:19:58 <luite_> Mbarak: no, but it will be in scope there
16:20:16 <Mbarak> in the entire do ?or just the next line?
16:20:21 <luite_> Mbarak: entire do
16:20:39 <Mbarak> ok.
16:20:41 <mm_freak> Mbarak: the "<-" is the key feature of a monad, basically allowing you to write recipes, where later actions can refer to the results of earlier ones
16:21:07 <Mbarak> you guys have been extremely helpful to me. i wish i had come here much earlier.
16:21:31 <f77> gnite
16:21:42 <BMeph> Is there a channel for Omega?
16:21:57 <DanBurton> BMeph: /join #Omega ?
16:21:57 <Mbarak> lol now I have a Maybe String that Blaze doesn't want to output.  I guess I have to pattern match against the Maybe String with something like \x -> Just x ?
16:22:16 <mm_freak> Mbarak: use the 'maybe' combinator or $maybe in hamlet
16:22:20 <luite_> Mbarak: there's fromJust, but that will fail with an exception if you have Nothing
16:22:33 <mm_freak> $maybe x <- maybeX \\ something \\ $nothing \\ something
16:22:43 <DanBurton> Mbarak: case x of Just x -> foo; Nothing -> bar
16:22:53 <Mbarak> $maybe? combinator? you've gone over my head.
16:22:58 <mm_freak> Mbarak:
16:22:59 <mm_freak> :t maybe
16:22:59 <Mbarak> fromJust, case x, that i recognize
16:23:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:23:12 <luite_> Mbarak: it's Hamlet syntax
16:23:23 <mm_freak> > maybe "got nothing" (("got something: " ++) . show) $ Just 3
16:23:23 <shachaf> @djinn b -> (a -> b) -> Maybe a -> b
16:23:23 <lambdabot> f a b c =
16:23:24 <lambdabot>     case c of
16:23:24 <lambdabot>     Nothing -> a
16:23:24 <lambdabot>     Just d -> b d
16:23:24 <lambdabot>   "got something: 3"
16:23:28 <mm_freak> > maybe "got nothing" (("got something: " ++) . show) $ Nothing
16:23:30 <lambdabot>   "got nothing"
16:23:30 <shachaf> djinn++
16:23:42 <DanBurton> > maybe 0 (+1) (Just 3)
16:23:43 <lambdabot>   4
16:23:49 <DanBurton> > maybe 0 (+1) Nothing
16:23:50 <lambdabot>   0
16:24:11 <Mbarak> Ok, i'll see what I can do from here. thank you all very much.
16:24:18 <shachaf> > ((+1) . fromMaybe (-1)) (Just 3)
16:24:20 <lambdabot>   4
16:24:20 <mm_freak> Mbarak: there is also the simpler variant fromMaybe, if you import Data.Maybe
16:24:20 <shachaf> > ((+1) . fromMaybe (-1)) Nothing
16:24:22 <lambdabot>   0
16:24:32 <mm_freak> Mbarak: and forget about fromJust or (\(Just x) -> ‚Ä¶)
16:24:36 <mm_freak> it's not there ;)
16:24:46 <Mbarak> not there?
16:24:55 <shachaf> if isJust x then Just (f (fromJust x)) else Nothing
16:24:58 <Mbarak> Prelude Data.Maybe> :t fromJust
16:24:59 <Mbarak> fromJust :: Maybe a -> a
16:24:59 <Mbarak> Prelude Data.Maybe> :t fromMaybe
16:24:59 <Mbarak> fromMaybe :: a -> Maybe a -> a
16:24:59 <Mbarak> Prelude Data.Maybe>
16:25:00 <DanBurton> :t fromMaybe
16:25:01 <lambdabot> forall a. a -> Maybe a -> a
16:25:04 <mm_freak> Mbarak: just a funny way to say:  don't use them
16:25:04 <Mbarak> it's there :p
16:25:13 <mm_freak> > fromJust Nothing
16:25:14 <lambdabot>   *Exception: Maybe.fromJust: Nothing
16:25:16 <luite_> Mbarak: but you usually shcouldn't use it
16:25:37 <Mbarak> even if i dnt care about exceptions and errors at this point?
16:25:48 <Mbarak> I should use \(Just x) -> x ?
16:25:53 <shachaf> Mbarak: No.
16:25:57 <DanBurton> It's bad form to ignore the Nothing case by using an irrefutable Just pattern
16:25:57 <luite_> Mbarak: no, that's worse :)
16:26:00 <mm_freak> Mbarak: you really give up a lot of what haskell gives you by using unsafe functions
16:26:02 <shachaf> Although that's better than using fromJust.
16:26:05 <DanBurton> \(Just x) -> x is an irrefutable Just pattern
16:26:10 <mm_freak> Mbarak: a correct name for fromJust would be unsafeFromMaybe
16:26:12 <monochrom> usually you don't even need fromJust. pattern-matching already sufficies
16:26:31 <Mbarak> how do i do multiple patterns in lambdas?
16:26:44 <companion_cube> \x -> case x of ...
16:26:52 <shachaf> DanBurton: That's not what "irrefutable pattern" means.
16:26:59 <mm_freak> Mbarak: learn to use safe combinators properly‚Ä¶  in the end that will be easier and lead to better programs
16:27:01 <DanBurton> shachaf: isn't it?
16:27:05 <Mbarak> lol of course, how could i forget case ...
16:27:06 <shachaf> It isn't.
16:27:08 <monochrom> \m -> case m of { Just x -> you can now use x here; Nothing -> deal with this case or something }
16:27:15 <DanBurton> the what does "irrefutable pattern" mean?
16:27:19 <shachaf> > (\(Just x) -> 0) Nothing -- Refutable.
16:27:20 <lambdabot>   *Exception: <interactive>:3:1-14: Non-exhaustive patterns in lambda
16:27:36 <mm_freak> DanBurton: an irrefutable pattern is a pattern which never fails to match
16:27:42 <shachaf> @google what does "irrefutable pattern" mean?
16:27:43 <lambdabot> http://stackoverflow.com/questions/6711870/what-are-the-cases-that-will-cause-irrefutable-pattern-failed-for-pattern
16:27:43 <lambdabot> Title: haskell - What are the cases that will cause "irrefutable pattern failed for pat ...
16:27:48 <Axman6> there's talk about adding case lambdas to GHC: (\case of foo -> bar; baz -> quux)
16:27:48 <dschoepe> > (\~(Just x) -> 0) Nothing
16:27:49 <lambdabot>   <no location info>: parse error on input `->'
16:27:49 <Mbarak> in the case of maybe, irrefutable is Just and Nothing right?
16:27:57 <mm_freak> > (\(~(Just 3)) -> "blah") Nothing
16:27:58 <lambdabot>   "blah"
16:28:02 <shachaf> Mbarak: No.
16:28:07 <DanBurton> > let Just x <- Just (Just 3) in x
16:28:08 <lambdabot>   <no location info>: parse error on input `<-'
16:28:19 <monochrom> irrefutable means not checked until too late
16:28:32 <DanBurton> > do Just x <- Just (Just 3); return x
16:28:33 <lambdabot>   Just 3
16:28:41 <DanBurton> > do Just x <- Just Nothing; return x
16:28:41 <ddarius> monochrom: A variable is an irrefutable pattern.
16:28:42 <lambdabot>   Nothing
16:29:03 <monochrom> sure. not checked until too late is fine for a variable
16:29:05 <DanBurton> hm wait a minute..
16:29:07 <mm_freak> Mbarak: you won't need irrefutable patterns in normal day-to-day stuff
16:29:21 <mm_freak> Mbarak: in fact you only need them when there is absolutely no other way to express what you want
16:29:29 <Mbarak> i remember reading something or other about it in lyah...
16:29:32 <mm_freak> Mbarak: i have encountered this exactly once in years of haskell
16:29:42 <Mbarak> lol ok, today i'll forget about it then
16:29:43 <monochrom> irrefutable is most useful if there is only one possibility and you want more non-strictness, e.g., ~(x,y)
16:29:54 <mm_freak> Mbarak: an irrefutable pattern is kind of a lazy pattern, for which it is just assumed to match always
16:30:05 <shachaf> mm_freak: Well, which *does* match always.
16:30:08 <DanBurton> > (do [x] <- Just [3]; return x, do [x] <- Just []; return x)
16:30:08 <Mbarak> oook. that makes sense
16:30:08 <lambdabot>   (Just 3,Nothing)
16:30:12 <shachaf> Sometimes it binds variables to _|_, though.
16:30:36 <Mbarak> ok...a hamlet question...how do i use anonymouse functions in hamlet?
16:30:37 <DanBurton> darn you, MonadFail
16:30:57 <mm_freak> shachaf: the pattern is only used for the names‚Ä¶  no matching is performed at all
16:31:07 <mm_freak> until you use the names
16:31:18 <shachaf> mm_freak: Right.
16:31:37 <mm_freak> so "it always matches" is misleading
16:32:10 <mm_freak> i wish there would be semi-irrefutable patterns
16:32:16 <DanBurton> does Hamlet have anonymous functions?
16:32:23 <shachaf> mm_freak: "matching" is always successful.
16:32:32 <Mbarak> I thought you could put arbitrary haskell in hamlet?
16:32:36 <mm_freak> where match is assumed, until it turns out lazily that it didn't match, at which point the other clauses are tried
16:32:45 <mm_freak> Mbarak: nope, you can't
16:32:45 <DanBurton> The general rule of thumb is: do the heavy lifting in Haskell, and do only simple stuff in Hamlet
16:32:59 <mm_freak> Mbarak: but you can put arbitrary haskell in your handler and give names to results
16:33:06 <mm_freak> Mbarak: those names you can refer to in hamlet
16:33:08 <ddarius> "It is sometimes helpful to distinguish two kinds of patterns. Matching an irrefutable pattern is non-strict: the pattern matches even if the value to be matched is _|_. Matching a refutable pattern is strict: if the value to be matched is _|_ the match diverges. The irrefutable patterns are as follows: a variable, a wildcard, N apat where N is a constructor defined by newtype and apat is irrefutable (see Section 4.2.3
16:33:09 <ddarius> ), var@apat where apat is irrefutable, or of the form ~apat (whether or not apat is irrefutable). All other patterns are refutable."
16:33:28 <ddarius> Admittedly, ~apat is also specifically called an "irrefutable pattern"
16:33:30 <Mbarak> I want to do \(Just x) -> Q.getItemDescription articles
16:33:56 <mm_freak> ddarius: well, it is irrefutable
16:34:17 <Mbarak> *I know that is bad...but, i want to get something working before getting something working....properly
16:34:22 <DanBurton> Mbarak: what do you do with the x?
16:34:33 <mm_freak> Mbarak: just use fromMaybe instead of fromJust
16:34:48 <Mbarak> that's in hamlet, it should print that stuff out using blaze
16:35:17 <mm_freak> Mbarak: you can't write functions in hamlet
16:35:30 <mm_freak> Mbarak: you can write functions in haskell and use them in hamlet
16:35:36 <mm_freak> #{myFunction myValue}
16:35:42 <Mbarak> oook
16:35:48 <mm_freak> in the handler:  let myFunction x = ‚Ä¶
16:36:12 <Mbarak> in this case I use '=' for sure ;-)
16:36:29 <mm_freak> let renderSomething = maybe (toHtml "nothing to render") (\x -> renderTheX)
16:37:06 <Mbarak> hhmm....can i define that outside of the do...?
16:37:11 <mm_freak> sure
16:37:19 <mm_freak> you can define it as a top level function, if you want
16:37:32 <Mbarak> and will hamlet see it or do i have to do, let funcRenamed = func in the do?
16:37:34 <mm_freak> whatever is in scope to $(‚Ä¶) is also in scope to your hamlet template
16:38:25 <mm_freak> rule of thumb:  you can refer to everything your handler could refer to, but you can't define new stuff
16:38:41 <Mbarak> ook.
16:40:17 <mm_freak> you can even refer to liftIO, getLine, runDB or your handler itself, but none of them will typecheck anywhere in your template =)
16:40:46 <Mbarak> hhmmm. i think i tried using liftIO in the hamlet once which, didn't help too much
16:40:48 <Mbarak> that might be why
16:41:41 <luite_> Mbarak: you can only use a very limited subset of haskell code in Hamlet, so don't be surprised if other, non-IO things, don't work either
16:41:55 <Mbarak> :D
16:41:57 <Mbarak> omg...
16:42:00 <Mbarak> it's working...
16:42:09 <luite_> In a recent update, pattern matching on tuples was added, but in general, pattern matching won't work
16:42:09 <DanBurton> Eureka!
16:42:27 <mm_freak> basically you can use anything with a ToHtml instance or for which hamlet has special syntactic constructs like $forall or $maybe
16:42:28 <Mbarak> lol i have been working on this more or less non-stop for a week and a half
16:42:51 <Mbarak> needless to say...haskell is something completely new to me
16:42:53 <Mbarak> thank you all
16:43:19 <Mbarak> "basically you can use anything with a ToHtml instance or for which hamlet has special syntactic constructs like $forall or $maybe" -> that little tidbit of knowledge will come in very handy
16:44:38 <Phyx-> Hello
16:45:21 <Phyx-> I was wondering if it's possible with xhtml to test for the existence of an attribute, and if found remove it
16:46:53 <ddarius> If you mean the xhtml package, it looks like it only generates xhtml.
16:47:39 <Phyx-> yeah, was afraid of that
16:47:46 <Phyx-> the Html type is abstract
16:47:59 <Phyx-> guess I'll just have to change haddock's codegen a bit
16:48:17 <Phyx-> it's generating multiple class attributes instead of grouping the values
16:48:26 <Phyx-> so a strict xhtml parser would fail
16:48:43 <ddarius> Does it generate Strict XHTML ?
16:49:19 <Phyx-> no, Transitional, but i'm not even sure it's allowed then
16:49:28 <ddarius> Also, it sounds like something that perhaps the xhtml package should be handling.
16:50:12 <Phyx-> quite possibly
16:52:08 <ddarius> Why would you use flash for a scrollbar?
16:52:52 <Phyx-> hm?
16:55:05 <Phyx-> right. so according to the w3c duplicate attributes are not allowed on elements. class="foo" class="bar" should be class="foo bar"
16:55:29 <Phyx-> but then the question is, is it a xhtml or haddock bug
16:56:51 <ddarius> Well I guess the maintainer of xhtml could say how is he supposed to know how to combine attributes.
16:58:20 <monadic_> Okay. I have an annoying problem where what is going into the network socket doesn't seem to be what is going out. https://github.com/jhance/network-stream/blob/master/Network/Stream.hs is the code
16:58:22 <Phyx-> alright, i'll report it to him then
16:58:41 <monadic_> All the writing is done in streamProcess, and the reading done in readBytes and streamEnum
16:59:38 <monadic_> Alot of the code has little printings to try and debug but I can't figure out why, for some reason, the length of the bytes exponentially increases while it always reads the value as "8". Which seems like it is reading the length as the value because every length should be 8
17:00:44 <monadic_> it puts 0 to signal it is sending bytes, puts 8, the length of the bytes, and then puts the 8 bytes that represent it... The putting seems to be correct but the receiving never works
17:01:19 <parcs> is ghc 6.12 still in general supported by library developers?
17:01:24 <parcs> it's what debian stable packages
17:01:37 <sam2> I have a question about haskell
17:01:41 <sam2> I am trying to learn monads
17:01:46 <sam2> I cannot quite understand the statement:
17:02:03 <sam2> Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))
17:02:27 <sam2> in the (\y -> Just (show x ++ y)) how can you have access to x?
17:02:54 <simon> sam2, because x is inherited in the inner lambda's scope.
17:03:14 <ddarius> sam2: Then you don't understand higher order funcions and you should understand them before bothering with monads as they are by far the more important concept and you need them to understand monads in Haskell.
17:03:17 <monadic_> parcs: Debian stable is typically ancient though
17:03:22 <simon> \x -> \y -> x + y -- is possible
17:03:25 <kmc> sam2, it sounds like you might... what ddarius said
17:03:55 <sam2> hm2026 perhaps2026 let me think through one more time
17:04:07 <kmc> sam2, a lot of people who are "confused about monads" are really confused about one of the pre-requisite concepts, like higher order functions or type classes
17:04:24 <monochrom> or types
17:04:39 <kmc> sam2, there is a lot of hype about monads, particularly written by people who are not Haskell experts
17:04:59 <parcs> monochrom: actually the current version of stable was released in october
17:05:14 <parcs> monadic_* so it's ancient yet :P
17:05:21 <kmc> which leads beginners to think monads are more important than they are, and to learn them earlier than they should
17:05:40 <parcs> i guess i'll upgrade to testing and get 7
17:05:43 <monadic_> Monads aren't that important; and thats coming from someone named monadic
17:05:51 <monochrom> hehehe
17:05:59 <monadic_> they're cool though :P
17:08:55 <monochrom> the general phenomenon happens in #math all the time. people ask calculus questions, then you find out the asker can't even do highschool algebra.
17:09:25 <monadic_> highschool algebra can be pretty hard at olympiad level
17:10:01 <monochrom> x^2+2x+1 = (x+1)^2 is not olympiad level, although sometimes useful in olympiad
17:10:04 <kmc> my new favorite useless monad analogy is that Monad is the higher-order abstract finally-tagless symantics for a language with literals and sequential binders
17:11:08 <monadic_> Gah. Writing code is: Write 0 Word8, write 8 length, write 8 bytes (encoded 1). Reading code is: Read 0 Word8, Read 8 bytes to find length of 8, Read 8 bytes and find that the value is... 8.
17:11:10 <ian_mi> is symantics somewhere inbetween syntax and semantics?
17:11:12 <monadic_> WHY
17:11:39 <conal> :i monadic
17:11:48 <monadic_> conal: I posted the source at https://github.com/jhance/network-stream/blob/master/Network/Stream.hs
17:12:04 <monadic_> Take a look at the Serialize instance for writing as well as streamProcess
17:12:18 <monadic_> and for reading its in streamEnum and readBytes
17:12:36 <monadic_> I swear its the exact same reading as it writes; I must be missing something stupid
17:13:42 <monadic_> maybe... the Put instance for ByteString is weird?
17:14:16 <kmc> ian_mi, yeah
17:14:33 <kmc> ian_mi, i saw edwardk use this word once to describe the finally-tagless classes
17:14:40 <kmc> i'm not sure if it's widespread
17:14:55 <monadic_> OH MY
17:15:07 <monadic_> The instance for B.ByteString encodes the length so I was encoding the length twice
17:15:10 <monadic_> -.-
17:15:53 <edwardk> ian_mi: symantics is an oleg/ken shan/jacques carette-ish for syntax/semantics
17:16:04 <edwardk> er ism
17:17:17 <copumpkin> a mortpanteau!
17:17:17 <copumpkin> ;)
17:17:31 <ddarius> kmc: It was used in the finally-tagless paper.
17:18:08 <kmc> is the class itself considered "symantic", or is the idea that instances are symantics (the way instances of Monad are monads)?
17:18:35 <kmc> it seems like the class is syntax and instances semantics, basically
17:18:52 <shachaf> But the danger was past -- they had landed at last, / With their boxes, portmanteaus, and bags; / Yet at first sight the crew were not pleased with the view, / Which consisted to chasms and crags.
17:23:15 <ddarius> "consisted to" ?
17:29:52 <Phyx-> there, bug reported
17:29:58 <Phyx-> *yawn* 2.38am
17:30:05 <Phyx-> enough haddock hacking for today
17:30:29 * Phyx- has *almost* gotten visual studio to recognize and index haddock docs
17:38:39 <ion> edwardk: Oh, Trifecta‚Äôs Monoid instance doesn‚Äôt do what i expected. :-) I was hoping mconcat [‚Ä¶] would have been like mconcat <$> sequence [‚Ä¶]
17:38:57 <edwardk> hrmm
17:39:17 <gwern> @quote
17:39:17 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
17:39:31 <edwardk> the monoid was picked to be consistent with parsec
17:41:59 <ion> It seems a bit redundant since we have <|> and choice anyway. How many libraries have alternative-ish monoid instances and how many have append-ish monoid instances, i wonder?
17:45:53 <simon> I've got 'foo <|> bar', and when foo fails, shouldn't it try and match with bar at the point where foo hasn't eaten anything?
17:50:00 * hackagebot sphinx 0.5.2 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.5.2 (GregWeber)
18:02:06 <simon> e.g. parse (string "foobar" <|> string "foo") "" "foo"
18:02:28 <shachaf> simon: Maybe you want "try"?
18:02:42 <simon> shachaf, yes I do!
18:03:27 <shachaf> Or maybe you want to left-factor your grammar?
18:05:00 * hackagebot sphinx 0.5.2.1 - Haskell bindings to the Sphinx full-text searching daemon.  http://hackage.haskell.org/package/sphinx-0.5.2.1 (GregWeber)
18:08:04 <simon> shachaf, trying is much easier in this case.
18:08:14 <simon> shachaf, no recursion.
18:33:07 <ion> edwardk: Is there a parse :: Parser ‚Ä¶ a -> ByteString -> Either e a?
18:34:12 <edwardk> not really. one can be adapted from https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/ByteString.hs
18:34:45 <edwardk> i was meaning to add it to https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Prim.hs
18:35:44 <ion> Ok, thanks
18:53:26 <mm_freak> why is returnA = arr id and not returnA = id?
18:53:49 <mm_freak> the latter would allow some very useful optimizations
18:54:40 <ddarius> :t arr id
18:54:41 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
18:54:48 <ddarius> History.
18:54:58 <ddarius> Category was added to Arrow after it was defined.
18:55:05 <byorgey> mm_freak: probably because the original Arrow class did not include 'id' (because it included 'arr')
18:55:41 <mm_freak> can we change it?
18:55:45 <ddarius> Yes.
18:57:04 <mm_freak> if i submit a patch, how likely is it to be included in the mainstream base library?
18:57:11 <ddarius> Pretty likely.
18:57:19 <mm_freak> alright, thanks
18:57:24 <DanBurton> doooo iiiiiit
19:00:02 * hackagebot llrbtree 0.0.0 - Left-Leaning Red-Black Tree  http://hackage.haskell.org/package/llrbtree-0.0.0 (KazuYamamoto)
19:00:03 * hackagebot time-recurrence 0.6 - Generate recurring dates.  http://hackage.haskell.org/package/time-recurrence-0.6 (ChrisHeller)
19:12:41 <roo1> If I do a "mod shift (" (by accident) in xmonad the started windows go off the screen into the background, anyone knows how to get them back?
19:14:31 <roo1> oh, sorry, going over to #xmonad to ask that
19:30:34 <SavageSimian> is there a way to set a working directory for WinGHCi and the editor that it launches?
19:35:30 <monochrom> try :cd
19:35:52 <SavageSimian> yea. just found it. thanks.
19:37:01 <SavageSimian> is it possible to override the edit command? i need to put an empty file in the dir if there's nothing there before launching the editor.
19:41:26 <Zamarok> Anyone having trouble getting Cabal to install the Chart module? I keep getting 'cannot satisfy -package Cabal-1.10.1.0: unusable due to missing or recursive dependencies: directory, process.'
19:42:08 <Zamarok> I thought process and directory were installed with GHC? I reinstalled GHC too
19:43:22 <kmc> SavageSimian, command in ghci?
19:43:34 <kmc> SavageSimian, you can define your own ghci commands; I'm not sure about overriding bulit-in ones
19:43:36 <kmc> but it's in the manual
19:44:13 <byorgey> Zamarok: sounds like your package database is screwed up
19:44:36 <byorgey> Zamarok: can you paste the output of 'ghc-pkg check' on hpaste.org?
19:44:36 <SavageSimian> ok. i'm looking for docs on the 'def' command right now.
19:45:09 <Zamarok> byorgey: ghc-pkg check returns nothing
19:45:18 <Zamarok> that seems bad :(
19:45:29 <byorgey> Zamarok: that means there are no errors
19:45:52 <byorgey> Zamarok: ok, how about the output of 'ghc-pkg list Cabal' and 'ghc-pkg list directory'
19:46:42 <byorgey> Zamarok: also, what version of GHC do you have, and what version of cabal ?
19:47:15 <hpaste> Zamarok pasted ‚Äúghc-pkg list Cabal‚Äù at http://hpaste.org/53678
19:47:44 <Zamarok> GHC 7.0.3
19:48:07 <Zamarok> Cabal 1.10.1.0
19:48:12 <byorgey> Zamarok: hmm, it's weird that you have slightly different versions of Cabal installed in both your local and global package DBs
19:48:17 <byorgey> that is likely to cause problems
19:48:25 <byorgey> Zamarok: what is the output of 'cabal --version'?
19:48:37 <Zamarok> using version 1.10.1.0 of the Cabal library
19:49:00 <Zamarok> Oops, above that was "cabal-install version 0.10.2"
19:49:07 <byorgey> Zamarok: ok. try 'ghc-pkg unregister --user Cabal-1.10.2.0'
19:49:08 <marvinalone> Left "foo" >>= (\x -> Left (x ++ "bar")) -- This doesn't work in ghci. Why not? What do I have to import?
19:49:20 <shachaf> marvinalone: Probably Control.Monad.Instances?
19:49:46 <marvinalone> shachaf: still doesn't work
19:49:53 <copumpkin> > map pred "Bynbo7"
19:49:54 <lambdabot>   "Axman6"
19:50:13 <Zamarok> byorgey: ok, done that. Should I try to install Chart now?
19:50:22 <marvinalone> on hackage, it says Control.Monad.Either, but when i try to import that, it can't find it
19:50:24 <byorgey> Zamarok: first, try 'cabal install --dry-run Chart'
19:50:29 <dcoutts> marvinalone: works for me
19:50:32 <shachaf> marvinalone: Works for me.
19:50:47 <byorgey> marvinalone: what version of ghc?
19:50:57 <marvinalone> then i guess my question becomes, how do i unfuck my ghci?
19:51:00 <Zamarok> byorgey: it informs me of which dependencies it needs
19:51:09 <ion> Is there a library that creates isFoo, isBar :: Baz -> Bool using TH based on data Baz = Foo { ‚Ä¶ } | Bar { ‚Ä¶ }?
19:51:15 <marvinalone> 6.12.3
19:51:18 <byorgey> Zamarok: yes, and what are they?  does it include Cabal?
19:51:45 <hpaste> Zamarok pasted ‚Äúcabal install --dry-run Chart‚Äù at http://hpaste.org/53679
19:51:54 <dcoutts> marvinalone: try Control.Monad.Error
19:51:56 <Zamarok> Those ^, doesn't include Cabal
19:52:11 <byorgey> Zamarok: looks good. OK, now without --dry-run =)
19:52:13 <dcoutts> marvinalone, shachaf: it's a mtl-1 -- mtl-2 change
19:52:25 <shachaf> dcoutts: Ah.
19:52:36 <shachaf> Only bad people use mtl-1, I'm told.
19:52:51 <dcoutts> shachaf: that must include you then :-)
19:52:55 <hpaste> Zamarok pasted ‚Äúcabal install Chart‚Äù at http://hpaste.org/53680
19:52:56 <dcoutts> marvinalone: you must be using mtl-2
19:53:04 <marvinalone> Control.Monad.Error works.
19:53:07 <Zamarok> byorgey: still errors :( There's the entire log pasted
19:53:14 <shachaf> dcoutts: I suppose so.
19:53:16 <dcoutts> marvinalone: which is fine, just import the new module
19:53:26 * shachaf has mtl-1 installed because of Pugs.
19:53:39 <marvinalone> dcoutts: I don't know what mtl is, but it says this: Loading package mtl-1.1.0.2 ... linking ... done.
19:53:56 <marvinalone> dcoutts: It seems I have mtl-1 then.
19:54:06 <byorgey> Zamarok: oh, I see.  hmm, that's bad
19:54:24 <Zamarok> That's weird.. "Cabal -V" says that I do have that version installed
19:54:33 <dcoutts> marvinalone: that's confusing, that's the opposite of what I get
19:54:55 <byorgey> Zamarok: yes, you have it installed, but the versions of directory and process that it was compiled against don't exist (or at least it thinks they don't)
19:55:16 <byorgey> Zamarok: what do you get when you 'ghc-pkg list directory'?
19:56:02 <hpaste> Zamarok pasted ‚Äúghc-pkg list directory‚Äù at http://hpaste.org/53681
19:56:20 <byorgey> yikes
19:56:31 <Zamarok> seems bad lol
19:56:41 <Zamarok> I probably don't need three of those..
19:56:56 <byorgey> Zamarok: I don't know why it happens but sometimes cabal gets confused like this, if you ever see the same package in both your global and local package DB you want to delete the ones in your local DB
19:57:10 <byorgey> Zamarok: so try  ghc-pkg unregister --user 'directory-1.1.0.0
19:57:16 <byorgey> and same for 1.1.0.1
19:57:27 <byorgey> check the 'process' package too
19:58:09 <Zamarok> Unregistering 1.1.0.0 would break a few other packages.. like XMonad..
19:58:29 <byorgey> eesh, I was afraid of that
19:58:54 <byorgey> go ahead and do it anyway, with --force
19:59:00 <byorgey> you'll have to rebuild XMonad etc.
19:59:12 <Zamarok> looks like XMonad depends on both 1.1.0.1 and 1.1.0.0 haha
19:59:13 <Zamarok> ok
20:00:43 <Zamarok> looks like directory won't be unregistered without root access..
20:00:55 <Zamarok> sudo ghc-pkg unregister?
20:01:07 <byorgey> no, that should not be necessary
20:01:17 <byorgey> what is the exact error you get?
20:01:44 <byorgey> Zamarok: you definitely DON'T want to accidentally unregister the one in the global DB.
20:01:47 <hpaste> Zamarok pasted ‚Äúghc-pkg unregister --user 'directory-1.1.0.0' --force‚Äù at http://hpaste.org/53682
20:02:33 <byorgey> hmm, it is trying to unregister the one in /usr/lib
20:02:57 <byorgey> note ghc-pkg unregister has a bug where even if you say --user, if it doesn't find the package in the local DB it will try to unregister the one in the global DB =(
20:02:59 <Zamarok> ghc-pkg list directory returns that there is only one directory package installed, in /usr/lib/ghc...
20:03:23 <byorgey> ok, good, so you are done =)
20:03:26 <byorgey> now check 'process'
20:03:54 <nolrai123123> Okay I want to do something like "instance Basic (EqStm a) where     type Value = a" but apparently the a isn't in scope. Help?
20:03:57 <Zamarok> Oh I see. Two process packages. Remove the local one?
20:04:12 <byorgey> yep
20:04:47 <byorgey> nolrai123123: type Value = a  doesn't make sense, Value ought to have at least one argument
20:05:07 <Zamarok> great, now "ghc-pkg check" is just telling me that the directory package is missing and affecting a bunch of other ones. Do I "cabal install directory"?
20:05:19 <shachaf> byorgey: type Value = forall a. a? :-)
20:05:19 <byorgey> Zamarok: no, you already have directory
20:05:24 <nolrai123123> byorgey: really?
20:05:43 <byorgey> Zamarok: the problem is all those broken packages are looking for the version of 'directory' that you just uninstalled
20:05:53 <byorgey> Zamarok: so the solution is to reinstall all of THOSE packages.
20:05:53 <Zamarok> Oh I see, you're right
20:06:02 <rwbarton> type Value (EqStm a) = a probably
20:06:06 <Zamarok> ok. Thanks for your help byorgey.
20:06:31 <byorgey> Zamarok: what does 'cabal install Chart' do now?
20:07:03 <byorgey> all of this stuff we've been doing is the Right Thing to do but I still don't know whether it will actually fix the problem...
20:07:23 <byorgey> nolrai123123: what is Basic?
20:07:34 <nolrai123123> A class?
20:07:43 <hpaste> Zamarok pasted ‚Äúcabal install chart‚Äù at http://hpaste.org/53683
20:07:55 <byorgey> nolrai123123: did you write it yourself? or get it somewhere else?
20:08:04 <byorgey> Zamarok: argh
20:08:06 <nolrai123123> write it my self.
20:08:24 <nolrai123123> Its so another datatype can do the right thing with it.
20:08:25 <byorgey> nolrai123123: so what is the definition of Value?
20:08:36 <nolrai123123> type Value :: *
20:08:47 <Zamarok> I think I know why lol.. I don't have the Cabal module at all now maybe? ghc-pkg list cabal returns nothing
20:09:05 <nolrai123123> Or "type Value :: * -> *" it doesn't work either way.
20:09:20 <nolrai123123> "a" isn't in scope is the problem.
20:09:49 <byorgey> nolrai123123: you probably want something like   class Basic b where  type Value b :: *
20:09:58 <byorgey> nolrai123123: Value needs a type to pattern-match against
20:10:02 <byorgey> that's where the 'a' will come from
20:10:21 <byorgey> nolrai123123: then write  instance Basic (EqStm a) where  type Value (EqStm a) = a
20:10:44 <byorgey> Zamarok: eek!
20:11:01 <nolrai123123> That seems really strange, but works!
20:12:27 <byorgey> Zamarok: honestly, at this point I would suggest deleting your local package DB, reinstalling GHC so it overwrites your global package DB, and starting over =(
20:12:33 <byorgey> unless dcoutts has any better ideas
20:13:14 <Zamarok> I can do that. I still have the packages downloaded, barely any other packages installed so it's not a big deal
20:13:35 <Zamarok> still have ghc* downloaded, rather
20:13:40 <byorgey> Zamarok: OK.
20:13:52 <Zamarok> how does one delete their local package DB?
20:14:35 <byorgey> Zamarok: so you'll want to delete ~/.ghc/x86_64-linux-7.2.1  or whatever the appropriate directory is for your arch and GHC version
20:15:07 <dcoutts> Zamarok: ghc-pkg is case sensitive, does ghc-pkg list Cabal report anything?
20:15:50 <Zamarok> dcoutts: good catch, I missed that. Now I see that 1.10.1.0 is installed twice, locally and globally
20:16:43 <byorgey> aha, progress =)
20:17:06 <byorgey> try uninstalling the local one of course
20:17:33 <Zamarok> Yea, now I'm recompiling gtk2hs-buildtools
20:17:51 <byorgey> spiffy
20:20:20 <Zamarok> Eh, still no luck. Might just delete my local DB and try again
20:21:35 <Zamarok> so, I want to delete ~/.ghc/{my_arch}, then reinstall GHC, and then just "cabal install" the packages I need.. I miss anything?
20:22:31 <byorgey> nope, that should do it
20:23:28 <byorgey> Zamarok: but you may want to cabal install --dry-run  and check for anything funny (such as packages like Cabal, directory, process, etc. being reinstalled)
20:23:45 <byorgey> it's a bit of extra work but it has saved me from a lot of grief at times
20:24:11 <Zamarok> After tonight, I will definitely do that haha.. thanks
20:24:39 <byorgey> sure, hope it works =)
20:25:33 <byorgey> dcoutts: I wonder whether it would make sense to have cabal-install issue a warning if it decides to install a different version of a package which is already in the global package DB?
20:26:01 <dcoutts> byorgey: the current dev version does that
20:26:03 <byorgey> I don't really understand all the issues involved, but in my experience it is almost always the wrong thing to do
20:26:08 <byorgey> ah!
20:26:09 <byorgey> dcoutts++
20:26:14 <dcoutts> no kosmikus++
20:26:19 <byorgey> kosmikus++
20:26:23 <Zamarok> Reinstalled GHC after deleting my local package DB.. "cabal install chart" still giving the same errors though lol
20:26:25 <shachaf> byorgey++
20:26:37 <dcoutts> byorgey: he did it as part of the new solver
20:26:38 * shachaf contributes to karma inflation.
20:27:04 <byorgey> Zamarok: cabal install Chart gives an error about Cabal-1.10.1.0 being unusable or whatever?
20:27:46 <hpaste> Zamarok pasted ‚Äúcabal install chart‚Äù at http://hpaste.org/53684
20:27:59 <Zamarok> Errors near the bottom of course
20:28:28 <byorgey> Zamarok: ah, you need to install gtk2hs-buildtools first
20:28:35 <Zamarok> weird that it doesn't recognize gtk2hs-buildtools.. I JUST installed that
20:28:41 <Zamarok> after reinstalling GHC
20:29:30 <byorgey> Zamarok: and where did it install gtk2hsC2hs? in ~/.cabal/bin ?
20:29:38 <byorgey> if so, is that in your $PATH ?
20:30:33 <marvinalone> Now I have this expression: Right Map.empty >>= addFoo >>= addBar >>= (\x -> Right (SomeWrappingType x)). Is there a better way to write this, particularly the start and end of the chain?
20:30:53 <Zamarok> Hmm, it doesn't appear to be in my $PATH, even though the file is there. Do I need to export it or something? bear with me.. been using Linux a month or two :s
20:31:49 <byorgey> Zamarok: OK, do you use bash?
20:32:21 <Zamarok> zsh
20:33:13 <byorgey> Zamarok: ah, ok. so edit your .zshrc, and put something like  export PATH="$HOME/.cabal/bin:$PATH"
20:33:22 <nolrai123123> marvinalone: (Right . SomeWrappingType) === (\x -> Right (SomeWrappingType x))
20:33:38 <ddarius> addFoo Map.empty >>= fmap SomeWrappingType . addBar
20:33:45 <Zamarok> ahh ok I see some entries in there already, I'll just add one
20:33:50 <byorgey> sure
20:34:34 <byorgey> Zamarok: then you will have to either open a new terminal, or type 'source ~/.zshrc' for the new $PATH to take effect
20:34:44 <byorgey> you can  'echo $PATH' to make sure
20:34:59 <marvinalone> nolrai123123, ddarius: ahh, yes. I really should have thought of that. i was looking for some monad magic where none is required :-)
20:35:24 <Zamarok> ahh yes, tab-completion works for those files now
20:35:25 <ddarius> marvinalone: Right = return.  Apply monad laws.
20:36:03 <byorgey> Zamarok: ok, now try 'cabal install Chart' again =)
20:36:14 <byorgey> and we'll see what the next error is ;)
20:36:37 <Zamarok> now Cabal is compiling Chart's dependencies, but it can't satisfy the mtl package.. hmm, let me investigate
20:37:03 <marvinalone> ddarius: do people really write stuff like return . SomeWrappingType?
20:37:26 <ddarius> m >>= return . f = fmap f m
20:37:39 <ddarius> Occasionally you might write return . SomeWrappingType.
20:38:42 <byorgey> Zamarok: strange, it should be able to install mtl
20:39:24 <marvinalone> ddarius: how about the start of the sequence? i was looking for something like mzero, mzero is Left
20:39:25 <Zamarok> Very strange.. I tried "cabal install Chart" again and now it's past the point where that happened the first time..
20:39:43 <marvinalone> *but* mzero is Left
20:39:59 <byorgey> Zamarok: very weird...
20:40:00 <Zamarok> Cabal is moody today I suppose
20:40:29 <byorgey> Zamarok: network hiccup perhaps?  sometimes that happens to me where it fails when trying to download a package
20:40:52 <byorgey> but in that case it would say something about "failed when downloading the package"
20:41:08 <marvinalone> I guess it can't really do that. How would it know what a "neutral" m is
20:41:20 <Zamarok> sure, could be my connection, especially in this rural area
20:42:21 <Zamarok> And finally Chart and is done compiling and installing :D. I dedicate my first chart to you byorgey
20:42:53 <byorgey> yay!
20:42:55 <byorgey> thanks =)
20:56:49 <ddarius> return x >>= f = f x
21:50:21 <edwardk> xkcd++
21:51:07 <edwardk> my wife just came in the room and said 'some times i just want you to pass the salt' ;)
21:54:30 <bmh> am I missing some array implementation that contains a function: Array i e -> (i -> e -> f) -> Array i f?
22:01:41 <tomprince> bmh: amap
22:02:06 <bmh> tomprince: amap maps over the elements, not the elements and indices simultaneously
22:11:12 <tomprince> \a f -> listArray (bounds x) $ fmap (uncurry f) (assocs a)
22:11:16 <tomprince> @ \a f -> listArray (bounds x) $ fmap (uncurry f) (assocs a)
22:12:07 <tomprince> :t \a f -> Data.Array.listArray (Data.Array.bounds x) $ fmap (uncurry f) (Data.Array.assocs a)
22:12:08 <lambdabot>     Couldn't match expected type `Array i e'
22:12:08 <lambdabot>            against inferred type `Expr'
22:12:09 <lambdabot>     In the first argument of `bounds', namely `x'
22:12:24 <tomprince> :t \a f -> Data.Array.listArray (Data.Array.bounds a) $ fmap (uncurry f) (Data.Array.assocs a)
22:12:25 <lambdabot> forall i e c. (Ix i) => Array i e -> (i -> e -> c) -> Array i c
22:12:43 <tomprince> ^-bmh
22:12:51 <tomprince> @pl \a f -> Data.Array.listArray (Data.Array.bounds a) $ fmap (uncurry f) (Data.Array.assocs a)
22:12:51 <lambdabot> ap ((.) . Data.Array.listArray . Data.Array.bounds) (flip (fmap . uncurry) . Data.Array.assocs)
22:13:22 <bmh> is that actually‚Ä¶ you know, fast?
22:13:40 <tomprince> no idea :)
22:13:56 <byorgey> probably not
22:14:15 <byorgey> bmh: I agree, this seems like an oversight
22:15:57 <tomprince> Is http://www.haskell.org/ghc/docs/7.2.1/html/libraries/array-0.3.0.3/Data-Array.html missing listing some instances? ixmap claims there is a functor instance for Array, but it isn't listed above.
22:16:30 <tomprince> Or, I am just blind.
22:16:50 <rwbarton> I'm sure you can do this with repa, though I have some trouble understanding which operations are efficient in repa
22:17:19 <bmh> "oversight" -- more like gaping API hole
22:19:46 <rwbarton> well tomprince's suggestion won't be so horribly inefficient
22:25:46 <tomprince> bmh: Prehaps you should write a patch? The implementaions is probably almost identical to amap.
22:26:03 <tomprince> An Applicative instance would probably also make sense.
22:26:27 <bmh> tomprince: There's probably too much red tape involved for that to be worth my time
22:26:39 <bmh> (ie. clearing it with my employer)
22:27:37 <MatrixFrog> that is sad
22:28:44 <bmh> MatrixFrog: Making sure the i's are crossed and t's dotted on an open source project can be a pain. I've seen it done (Dungeon Crawl relicensing)
22:29:37 <tomprince> bmh: https://gist.github.com/1344335
22:29:59 <tomprince> 9 chars insted from amap, if you want to herd it through the patch process.
22:30:42 <tomprince> and untested
22:31:11 <bmh> if it typechecks, it probably works.
22:31:58 <tomprince> Like I said, untested ... just typed into gist, with code copied from haddock's source link.
22:41:54 <edwardk> bmh: there is also an indexed map in my keys package
22:42:59 <bmh> edwardk: how's your performance? I'm implementing a cellular automata, fwiw
22:43:39 <edwardk> its fine, btw- for cellular automata you might just want to use the pointer comonad =)
22:46:13 <huangyi> Isn't the concepts thing of c++ just like typeclass? http://en.wikipedia.org/wiki/Concepts_(C%2B%2B)
22:46:54 <edwardk> not quite. concepts describe a lot of things, typeclasses basically describe a dictionary of members
22:48:39 <edwardk> for instance you get axioms out of concepts, and there isn't much if anything new out of the concept proposal. they can be modeled using templates, the boost guys have been doing so for years, it just makes them nicer and more approachable
22:50:01 * hackagebot TCache 0.9 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.9 (AlbertoCorona)
22:50:06 <edwardk> they really exist to just make error messages a little bit nicer
22:51:35 <huangyi> Oh, i see axioms, c++ compiler can guarantee them?
22:52:26 <edwardk> they give a specification of some behavior, and then you may have different tools that can check them quickcheck style or prove them and you can let the compiler assume they are correct for optimization purposes
22:53:28 <huangyi> So it just a hint for compiler to do optimization?
22:53:42 <edwardk> yeah
22:54:26 <huangyi> Then, i guess other than that, concepts is just the same as typeclass? ;-)
22:54:26 <edwardk> and since you can talk about concepts by name you can blame the concept not the list of attributes that you found missing when you try to use a template on something that doesn't provide the requisite members
22:54:29 <edwardk> no
22:54:49 <edwardk> a typeclass is a dictionary, think of it like a vtable used for dispatching virtual methods
22:55:01 <edwardk> classes can _have_ those, but they can also have lots of other things
22:55:32 <edwardk> concepts aren't even that, they are just a sketch of a common set of features you want a class to have but they have no formal relationship to the dispatching mechanism whatsoever
22:55:39 <huangyi> But we have type constraint.
22:56:30 <edwardk> template <LessThanComparable T> ‚Ä¶.    is not in any way the same thing that happens when you have foo :: LessThanComparable t => ...
22:57:59 <edwardk> the former is a description of a choice made at compile time and LessThanComparable is only a HINT not a requirement. so that when you go to access foo < bar for T foo, and T bar that it knows to blame the fact that they aren't "LessThanComparable" for its absence rather than the actual operator name
22:59:34 <edwardk> all concepts in this capacity are is a refinement of the error messages you'd get out of template <typename T> ...
23:01:41 <edwardk> the resemblance is quite superficial
23:07:16 <huangyi> ... still confused, isn't `concept_map Stack vector` just like `instance Stack vector` ?
23:09:07 <sopvop> Hello #haskell. So, I'm using parsec GenTokepParser for parsing and want to get current SourcePos, but can't find how. Is it possible at all? How do I do that?
23:09:26 <huangyi> Concept is a method table, which the concrete type can choose to implement.
23:10:04 <huangyi> edwardk: thank you very much,any way. ;-)
23:11:58 <edwardk> you are conflating concepts and classes
23:12:43 <edwardk> a concept is something i can write well after the class i'm applying it to. as a set of requirements that my template requires to be satisfied which i (may) check when i instantiate the template
23:13:11 <edwardk> a class has an actual dispatch mechanism to get at those properties, be it direct, through a vtable, through the crazy vtables you get through multiple inheritance etc
23:14:03 <huangyi> I mean typeclass have them both, isn't it?
23:14:12 <edwardk> the concept is a set of constraints owned by the caller (the template), while your superclasses, etc. are properties of the callee
23:15:03 <sopvop> About parsec, found it myself. Sorry for dumb question :)
23:15:51 <edwardk> class Foo a b c where foo :: a -> b -> c      describes a particular structure, a dictionary if you will that contains a single method. that i can pass around. an instance of that class has associated with it a dictionary. i pass those to functions, or i provide them some other way to call that method, but it is very much a runtime concept how those things get dispatched, its
23:15:51 <edwardk>  polymorphic. templates ultimately get instantiated down to a single concrete thing
23:16:56 <edwardk> _classes_ in c++ and typeclasses have a lot in common, a class in c++ has a vtable which provides for the dispatch of virtual function calls. those have a lot in common with the calling of foo above, except for the fact that in c++ the vtable is always carried around with the object in question
23:17:25 <edwardk> (and classes in c++ may not have a vtable, if there are no virtual function calls and no multiple inheritance is used)
23:18:27 <edwardk> concepts aren't related to dispatch. when i instantiate a template i'm not polymorphically doing something at runtime, i compiled that code for some particular list of type arguments a priori at compile time. and as such each instantiation of the template can do something radically different
23:18:40 <edwardk> this is where all the c++ metaprogramming stuff kicks in
23:19:07 <edwardk> the polymorphism we have in haskell is more like java/scala/c# generics than it is like a c++ template
23:19:37 <kalven> there are also concept maps which are used to say /how/ some type implements a certain concept.
23:20:44 <edwardk> so if i say template <typename T> const T & min(const T &x, const T &y) { return y < x ? y : x; }   i'm just saying that there is a < method provided for T, not that i care how its built, and when the template gets instantiated, then for that particular type i look for a < operator
23:21:09 <edwardk> it could be in the class, it could be outside the class, it could be that i coerce to some other type that has a <, etc.
23:21:23 <edwardk> typeclasses are much more homogeneous than that
23:22:28 <edwardk> kalven: true, but again they are done on a very monomorphic basis, and dispatched/dealt with very differently than a typeclass
23:22:36 <kalven> yes
23:22:56 <edwardk> and they serve as a proxy for the template machinery we used to use
23:24:31 <edwardk> now if i make a concept up for LessThanComparable   rather than say typename there it doesn't change the dispatch in any way, its just a different way of phrasing the assertion
23:25:02 * hackagebot HTF 0.8.1.1 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.8.1.1 (StefanWehr)
23:25:40 <Zamarok> this language has got to be the best tool ever for solving Project Euler problems
23:25:49 <edwardk> such that rather than blaming that i couldn't figure out how to call < in return y < x ? y : x;    i blame the fact that whetever type you gave me wasn't "LessThanComparable". you didn't make your type an instance of LessThanComparable, you probably didn't instantiate a concept_map, its just prettier blame
23:26:07 <edwardk> Zamarok: how far in are you?
23:26:51 <Zamarok> I started a long time ago, when I was young. Solved maybe 3 or 4, but the math was too deep.. then I started again on Thursday after picking up Haskell earlier that week..
23:26:57 <Zamarok> Solved my 29th just now :D
23:27:09 <huangyi> I see, the plain template instantiation don't do any check about if the class implement the operator or not, now with concept, it can check that.
23:27:10 <Zamarok> er, 27th
23:27:24 <Zamarok> They're addictive
23:28:14 <Zamarok> edwardk: and yourself?
23:28:53 <huangyi> I think i understand that now, but i still think they kind of solve the same problems.
23:29:16 <edwardk> huangyi: it really doesn't check any differently, it just blames the concept rather than the method when it goes wrong
23:29:32 <edwardk> you don't have to explicitly instantiate the concept
23:30:01 <edwardk> Zamarok: i don't think i ever got sucked into project euler
23:30:17 <copumpkin> they get kind of old after a while
23:30:32 <copumpkin> I think int-e holds the record in this channel :)
23:30:34 <edwardk> yeah i looked over the structure of it and thought it would have been great had i found it 15 years ago
23:30:42 <huangyi> They are both used to describe some constraints on types, maybe the implementation is very differently.
23:31:15 <edwardk> huangyi: sure, but at that point classes, typeclassses, interfaces, generics, templates all fit that loose definition
23:31:36 <Zamarok> copumpkin: agreed.. I'm finding them incredibly useful for learning Haskell though. Haskell is full of useful tools for it out of the box
23:31:51 <copumpkin> yeah, I played with them when I was first starting with haskell too
23:31:52 <Zamarok> but all-the-same after a while
23:32:04 <copumpkin> after a while they stopped being about haskell and were just about project euler :)
23:32:22 <edwardk> Zamarok: yeah
23:32:23 <copumpkin> I persevered a bit and then got sucked deeper into haskell
23:32:50 <edwardk> haskell was how i escaped from template metaprogramming hell ;)
23:32:51 <Zamarok> I would like to finish the entire set over time though, as I am fascinated by the math problems
23:33:02 <shachaf> Zamarok: I expect that they're both not very useful for learning Haskell and not all-the-same-after-a-while.
23:34:14 <Zamarok> shachaf: maybe it's that my attention span runs out
23:34:44 <Zamarok> either way :P
