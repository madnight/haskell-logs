00:22:58 <Blkt> good morning everyone
00:26:25 <parcs_> good 3:38 am to you
00:32:55 <fragamus> whew... I think I reasoned out my problem
00:33:28 <fragamus> it is the first time I really felt like I knew what I was doing in Haskell
00:33:48 <fragamus> with monads anyhow
00:41:24 <mm_freak> fragamus: and you keep feeling like that?
00:41:38 <mm_freak> if yes, and if you are urged to write a monad tutorial…
00:41:41 <mm_freak> … don't =)
00:41:53 * Enigmagic is currently writing two monad tutorials
00:43:41 <fragamus> haha
00:45:03 <fragamus> I finally started applying the type driven development approach that one of you guys taught me some time ago
00:45:43 <fragamus> so I spend a lot of time in ghci  doing :t
00:46:07 <fragamus> and making my expressions grow slowly in ghci with  :t lighting the way
00:46:20 <erus`> wheres the fun in that?
00:46:34 <erus`> i like changing stuff randomly until it builds
00:46:43 <fragamus> well... failure is fun too
00:46:57 <fragamus> and I used to have a LOT of that kind of fun
00:48:59 <erus`> what are you writing?
00:49:30 <Veinor> anybody here have any experience with tagsoup/other forms of scraping unstructured html?
00:52:42 <fragamus> a monad tutorial
00:53:05 <fragamus> :P
00:53:44 <shachaf> fragamus: Great! We don't have any of those yet.
00:53:47 <paolino> hello, is it possible to specify a flag for a dependency  ina cabal file ?
00:57:06 <paolino> Depending on a library built with a specific flag
00:57:59 <ion> veinor: I’ve used Text.XML.HXT.TagSoup.
00:58:24 <Veinor> hmm
00:59:24 <Veinor> ... i think i have to give up and accept there's no 'nice' way to do this.
01:00:11 <ion> veinor: Some code: https://gist.github.com/1369649
01:00:30 <Veinor> see, the problem is that the thing i'm parsing isn't very structured at all
01:00:55 <Veinor> it looks like <br><br><br><a href="link">data</a><br>more data<br><br><br><a href="link">data</a><br>more data
01:01:30 <Veinor> so basically my code is going to be full of dropWhiles and such which means that if the format changes it'll start erroring
01:02:06 <shachaf> Veinor: Is this Tumblr again?
01:02:12 <Veinor> nah, something else
01:02:24 <Veinor> tumblr's html seems to be pretty decent
01:06:49 <Veinor> ... then again if the format changes i think i want it to error because it'll have changed in an unpredictable way
01:07:06 <fragamus> @hoogle flatten
01:07:07 <lambdabot> Data.Tree flatten :: Tree a -> [a]
01:07:07 <lambdabot> Data.Graph flattenSCC :: SCC vertex -> [vertex]
01:07:07 <lambdabot> Data.Graph flattenSCCs :: [SCC a] -> [a]
01:07:27 <Veinor> > join [[2,3,4], [4,5,6]]
01:07:28 <lambdabot>   [2,3,4,4,5,6]
01:07:40 <fragamus> ty
01:07:45 <Veinor> np
01:08:52 <fragamus> @hoogle join
01:08:53 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
01:08:53 <lambdabot> package join
01:08:53 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
01:11:21 <paolino> depending on a package compiled with specific flags is considered a bug of the dependency library, which expose a different interface depending on flags ?
01:12:38 <paolino> fragamus: for lists it's concat
01:12:58 <paolino> :t concat
01:12:59 <lambdabot> forall a. [[a]] -> [a]
01:13:29 <fragamus> ty
01:13:46 <fragamus> @hoogle intersperse
01:13:46 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:13:47 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
01:13:47 <lambdabot> Data.ByteString.Lazy.Char8 intersperse :: Char -> ByteString -> ByteString
01:16:21 <paolino> > foldr (\x y -> x ++ y) [] $ map return [0 ..]
01:16:23 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:18:46 <hpaste> erus` pasted “help me refactor ugly code :)” at http://hpaste.org/54099
01:20:15 <dcoutts> paolino: it's not possible to specify a flag for a dependency. If that would appear necessary then the library you're depending on is wrong. The flags should not change the library interface. That'd be an abuse of the system.
01:21:55 <paolino> dcoutts: right, I realized that while I was asking, let's pester package manteiner, thanks.
01:22:22 <erus`> my code looks liek it has been run through an obfusticator
01:35:22 <erus`> what a fast compression algorithm for binary data? I need to encode/decode like 4 meg in milliseconds
01:35:27 <erus`> is that possible?
01:35:53 <flux> run-length-encoding?
01:36:12 <flux> maybe take a look at lzop, at leaast fast compression is its main feature
01:36:12 <kalven> snappy
01:37:41 <erus`> snappy looks good
01:37:45 <erus`> i will look at lzop
01:39:34 <kalven> snappy is slightly faster than lzo and has a more permissive license
01:39:35 <flux> if your goal is 10 milliseconds, it's only 2.5 ns per byte. might not be feasible for any advanced encoding.
02:00:57 <hpaste> srhb pasted “foldD” at http://hpaste.org/54100
02:01:22 <srhb> Could someone help me deconstruct the error that results from that definition? I can't figure out what's wrong.
02:03:53 <exlevan> srhb: did you forget to pass f to foldD?
02:04:11 <srhb> I did. Thank you. Duh.
02:04:19 <srhb> I'm clearly blind as a bat.
02:04:52 <erus`> would be cool if type class variables were added to the scope
02:05:08 <erus`> so when i define a function in a where
02:05:22 <erus`> i can re use them from the parent's type definition
02:05:30 <mux> you mean like with the ScopedTypeVariables extension?
02:41:09 <erus`> mux how do i enable it?
02:42:09 <erus`> i forgot the pragma command
02:42:13 <erus`> and i cant find it
02:42:32 <Veinor> {-# LANGUAGE ScopedTypeVariables #-}
02:44:45 <srhb> It's not possible to do ws <- words getLine in a do statement in any way, is it? I have to do two steps?
02:45:23 <Veinor> ws <- words <$> getLine
02:45:28 <Veinor> where <$> is defined in Control.Monad
02:45:34 <srhb> Aha, a new and exciting operator.
02:45:40 <Veinor> :t (<$>)
02:45:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:46:23 <erus`> a <- (fmap words getLine)
02:46:55 <ion> It’s defined in Data.Functor but Control.Applicative exports it, too. It’s an infix version of fmap.
02:47:25 <sefb1704> Hello :)
02:47:39 <srhb> Thanks, I'll try to understand what's going on there :)
02:48:12 <ion> srhb: I recommend reading about functors in LYAH and then the Typeclassopedia.
02:48:23 <hpaste> sefb1704 pasted “Superprint” at http://hpaste.org/54101
02:48:46 <srhb> ion: I'll do that, thank you.
02:48:57 <sefb1704> I want to print out text with a short delay between every letter but this wont work :/
02:50:18 <sefb1704> seems like i have a type problem but .. its a list and i even use "read" i dont understand why haskell doesnt allow this
02:50:49 <ion> mapM_ (\c -> putChar c >> threadDelay 1000000) string
02:51:08 <Veinor> sefb1704: You want show, not read
02:51:25 <sefb1704> okey so i use "show" instead?
02:51:27 <sefb1704> i will try..
02:51:42 <Veinor> show takes a value and produces a String, read takes a String and produces a value
02:51:43 <ion> Actually, better flush just in case. mapM_ (\c -> putChar c >> hFlush stdout >> threadDelay 1000000) string
02:52:21 <sefb1704> ion i think i dont get the code you pasted. my sleep function is copied from a website .. what do i have to do with your code? ^^
02:52:35 <Veinor> also, superprint will have type [a] -> IO ()
02:53:04 <sefb1704> okey i now wrote "show" instead of "read"
02:53:15 <sefb1704> should i change the type settings? i will try ..
02:53:42 <sefb1704> oh nice, one error is eliminated
02:54:16 <Veinor> also, instead of return 0 you want return ()
02:54:31 <sefb1704> hmkey. seems like i cant use drop like that.
02:54:41 <sefb1704> okey i fix this return thing ..
02:54:48 <Veinor> oh
02:54:57 <ion> sefb1704: Run it in ghci for instance. (But never run any code you got from the Intertubes you don’t understand.)
02:54:59 <Veinor> superprint [x] means 'to superprint a list containing the single element x, do this'
02:55:11 <Veinor> you want superprint x
02:55:36 <sefb1704> ow okey.
02:55:49 <ion> Use pattern matching instead of ‘if’ to check for an empty list. (But rather use mapM_ for the whole thing.)
02:57:47 <sefb1704> okey. would pattern matching work like this in this case .. "superprint x = [] =0; superprint x = [i dont know] .. blablabla the rest of my original code"
02:58:10 <ion> superprint [] = …
02:58:15 <ion> superprint xs = …
02:58:25 <sefb1704> aaah
02:58:28 <sefb1704> dammit -.-
02:59:38 <sefb1704> dammit -.-
03:00:16 <sefb1704> putStr (show(xs !! 0)) gives the error that it is applied to five arguments? :O
03:00:33 <sefb1704> ah oh ok
03:00:37 <sefb1704> dont answer
03:00:48 <ion> You probably forgot a “do”, so the next line looks like a continuation to that line.
03:01:27 <ion> Also, instead of xs !! 0, use pattern matching.
03:01:36 <ion> superprint (x:xs) = …
03:02:02 <ion> Since that pattern only matches a non-empty list, you can also choose to put the [] definition after that one if you want.
03:02:10 <sefb1704> oO pattern matching for a function? please let me take the function :D
03:02:58 <sefb1704> there is only 1 error left, suddenly this guy does no now "sleep" anymore. gives a parse error ..
03:04:08 <sefb1704> ah its nothing wrong about sleep
03:04:24 <sefb1704> ah its nothing wrong about sleep
03:04:54 <hpaste> sefb1704 pasted “Superprint” at http://hpaste.org/54103
03:05:38 <sefb1704> do you know what my mistake is? :/
03:06:25 <ion> Dunno, you never gave the error message, but use a (x:xs) pattern so you’ll be able to refer to the head as “x” (instead of “xs !! 0”) and to the tail as “xs” (instead of “drop 1 xs”).
03:06:44 <Veinor> sefb1704: the type of superprint is (Show a) => [a] -> IO ()
03:06:50 <Veinor> because you can only show things that have a show instance
03:06:50 <ion> Oh, your type signature doesn’t say ‘a’ is something you can apply show to.
03:07:26 <erus`> can i use shaders with glut?
03:07:31 <erus`> or only fixed function?
03:07:45 <sefb1704> oh okay. now this really is not my fault, we havent learned that yet and there is nothing about this in LYAH
03:08:16 <sefb1704> yaaay
03:08:32 <sefb1704> works! :D but not how i want :/ i wanted him to make a break between every letter ..
03:08:48 <sefb1704> this guy now makes a break after having printed the whole thing
03:09:05 <ion> “there is nothing about this in LYAH” [citation needed]
03:09:07 <ion> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
03:09:31 <Veinor> sefb1704: ["Test"] is a list containing the string "Test". "Test" is a list containing 4 characters
03:09:36 <Veinor> so you want superprint "Test"
03:10:05 <sefb1704> lovely <3
03:10:57 <sefb1704> output: 'T''e''s''t'
03:11:25 <sefb1704> can i avoid these '_' ?
03:11:30 <ion> Don’t use show.
03:11:44 <sefb1704> ok
03:12:19 <sefb1704> umm.. okey i will try pattern matching but i am new to this i guess i will make it wrong ..
03:15:08 <sefb1704> i tried it with (x:xs) so i can simply use putStr (x) but now there is a really long error ..
03:15:21 <sefb1704> looks like "show" in the head is wrong now..
03:16:56 <ion> Your type was “(Show a) => [a] -> IO ()”: a list of “a”s (with the restriction that they must be showable) → an IO action. Now that you’re not using show, what do you suppose the function should get as input?
03:17:39 <sefb1704> input is a list that should be a string .. maybe again String -> IO ()
03:17:49 <ion> Great, indeed.
03:17:55 <sefb1704> ..
03:18:46 <ion> > case "o hai" of (x:xs) -> (x, xs)
03:18:47 <lambdabot>   ('o'," hai")
03:19:18 <ion> If you pattern match a string with (x:xs), you’ll notice the head (a Char) goes into x and the tail (a [Char] a.k.a. a String) goes into xs.
03:19:26 <ion> @type putStr
03:19:27 <lambdabot> String -> IO ()
03:19:29 <ion> @type putChar
03:19:30 <lambdabot> Char -> IO ()
03:19:41 <ion> There are separate functions for printing strings and char.
03:19:42 <ion> s
03:19:55 <sefb1704> String -> IO() does not work :/ expects [Char] but gets Char
03:20:09 <sefb1704> String -> IO() does not work :/ expects [Char] but gets Char
03:20:29 <Veinor> sefb1704: instead of putStrLn, use putChar
03:20:45 <qnikst> hello, I have problems with StateT transformer
03:21:13 <qnikst> I have a type > type Low a = StateT MyState IO a
03:21:29 <qnikst> and wan't to make another StateT on the top of Low
03:21:44 <ion> Why?
03:21:45 <qnikst> i.e. make smth like: > type Tran a = StateT TranState Low a
03:22:11 <qnikst> but it not work because of Type synonym `Low' should have 1 argument, but has been given none
03:22:20 <lunaris> qnikst: You'll need a newtype
03:22:34 <lunaris> newtype Low a = Low { runLow :: StateT MyState IO a }
03:22:49 <lunaris> newtype Tran a = Tran { runTran :: StateT TranState Low a }
03:22:50 <qnikst> can you advice cases when I need to make a newtype
03:23:00 <qnikst> or point out where to look for documentation
03:23:03 <qnikst> thanks
03:23:12 <lunaris> qnikst: Effectively, when you need a new "first class" type.
03:23:24 <lunaris> qnikst: Type synonyms are essentially syntactic.
03:24:20 <lunaris> qnikst: newtypes are like data, but they have certain restrictions (and certain advantages).
03:24:21 <sefb1704> Veinor: with putChar it only prints every second char in my whole String
03:24:36 <lunaris> qnikst: See http://www.haskell.org/haskellwiki/Newtype
03:24:39 <Veinor> jpaste your code?
03:25:10 <qnikst> lunaris: and if I want Low behave like state I should add derive (MonadState) (with generalized deriving) or explisitly write instances?
03:25:19 <hpaste> sefb1704 pasted “Superprint” at http://hpaste.org/54105
03:25:50 <sefb1704> output is Test
03:25:53 <Veinor> sefb1704: you can get rid of the second 'sleep 1'
03:26:07 <Veinor> and also, instead of superprint (drop 1 xs), just superprint xs
03:26:07 <ion> type Low = StateT MyState IO
03:26:14 <ion> type Tran = StateT TranState Low
03:26:19 <ion> I suppose that should work as well.
03:26:22 <Veinor> because when you call superprint "Test", x will be 'T' and xs will be "est"
03:26:48 <lunaris> qnikst: You can derive MonadState if you want, but it may not be good practice.
03:26:55 <lunaris> qnikst: Ion's solution is an alternative too.
03:27:25 <sefb1704> Veinor: oh my god what a stupid mistake of mine -.- y thanks that was it
03:28:18 <sefb1704> Thank you ion and Veinor, with this new way of outputting text, my haskell-adventure game will be WAY more fun :D
03:28:25 <qnikst> lunaris, ion,  and can you give an advices when which is better to use?
03:28:36 <qnikst> if it will not take much of your time
03:30:24 <qnikst> in real program I have a huge monad-transformer: Reader State (StateType a) IO
03:30:52 <qnikst> and want to make a State simplifier to make transactions in that monad
03:31:56 <ion> How about putting all the state and perhaps even the reader value into a single state transformer?
03:32:52 <sefb1704> Thank you ion and Veinor, with this new way of outputting text, my haskell-adventure game will be WAY more fun :D bye
03:33:48 <qnikst> ion: this will not work, I'll try to explain
03:34:43 <qnikst> I have monad to work with device, and one part is transactional, i.e. I should authorize, re-authorize on error and so on
03:34:58 <qnikst> it can be done explicilty with "Low" monad
03:35:45 <qnikst> but I want to add some higher level api, so user will not bother of low-level commands and re-authorizing, and some error-handling
03:37:43 <ion> Okay, you’ll probably want to hide the whole lower StateT stuff behind a newtype and provide a clean API for the higher-level stuff in a separate file.
03:43:32 <qnikst> not exaclty, I wanted to give user opportunity to use low-level api, and higher-level for some difficult operations
03:43:45 <qnikst> it seems I should have 2 files and newtypes
03:45:25 <ion> That doesn’t prevent you from using both the higher- and lower-level APIs, but one might still want to hide what they’re made of (StateT …), thus using a newtype.
03:47:04 <qnikst> thanks
03:53:13 <qnikst> and about generalized deriving, why it's not a good practice?
04:07:48 <qnikst> ion: lunaris, thanks now my code works as needed
04:09:46 <geheimdienst> as a regular user, can i delete spam pages on the haskell wiki?
04:16:02 <lunaris> qnikst: ion deserves the credit :)
04:20:54 <qnikst> and how I have slightly more complicated situation
04:21:15 <qnikst> I've made:
04:21:16 <qnikst> > newtype Low a b = Low {
04:21:16 <qnikst> >   runLow :: StateT (LowState a) IO b
04:21:17 <lambdabot>   <no location info>: parse error on input `newtype'
04:21:17 <qnikst> > } deriving (Monad,MonadIO, MonadState (LowState a))
04:21:17 <lambdabot>   Not in scope: type constructor or class `LowState'Not in scope: `runLow'
04:21:18 <lambdabot>   <no location info>: parse error on input `}'
04:21:36 <qnikst> sorry for copying from .lhs file
04:22:16 <qnikst> and I have: data LowState a = LowState a deriving (Show) -- ^ user state
04:22:47 <qnikst> then I'm trying to make type Tran  = StateT TranState Low  (or newtype)
04:23:30 <qnikst> and if I need to add type a to Tran, or I should make forall a. StateT TransState (Low a)
04:34:53 <hpaste> tmhz pasted “Error handling for parsing ints” at http://hpaste.org/54108
04:36:15 <tmhz> Could someone suggest a way to handle the parse error if an integer is not found? in the paste above. Could it somehow be done with a Maybe?
04:36:44 <tmhz> I am sorry for the toy code I am new to Haskell
04:37:04 <hpc> :t reads
04:37:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:37:09 <hpc> > reads
04:37:10 <lambdabot>   Overlapping instances for GHC.Show.Show
04:37:10 <lambdabot>                              (GHC.B...
04:37:24 <hpc> > reads "1234 this isn't a number" :: [(Int, String)]
04:37:25 <lambdabot>   [(1234," this isn't a number")]
04:37:47 <geheimdienst> i find it hilarious how it's not just a joke, we really do have a monad tutorial industry going. there's even a "timeline" page on the wiki listing monad tutorials by year and month
04:37:51 <hpc> a successful parse matches the pattern [(number, "")]
04:38:29 * ibid is pretty sure he never committed a monad tutorial
04:38:36 <tmhz> ahh ok so then I could filter for a null list? is that the best way?
04:38:44 <geheimdienst> won't be long until we can have a meta-study, a history of explaining monads or something
04:39:17 <exlevan> monad tutorials are like burritos
04:39:44 <hpc> geheimdienst: a history of the history of monad tutorials
04:41:38 <ddarius> geheimdienst: Is monthly fine enough granularity?
04:41:54 <ddarius> ibid: You will go to Haskell heaven then.
04:42:15 <tmhz> hpc: thankyou for your help I've got it now. cheers
04:43:36 <geheimdienst> seems that we average about 3 monad tutorials per year, with the expection of 2006 (7 tutorials) and 2007 (9 ... a very good, or bad, year)
04:43:44 <geheimdienst> i'll make a graph ...
04:44:15 <XexonixXexillion> quickly; everyone write monad tutorials to skew the data :p
04:45:02 <ibid> ddarius: but i have taught monads to my students :)
04:46:28 <NOOB1235> hello
04:47:02 <NOOB1235> what is better haskell or lis[
04:47:05 <NOOB1235> lisp*
04:47:05 <Axman6> hello NOOB1235
04:47:13 <NOOB1235> hey
04:47:13 <XexonixXexillion> what kind of lisp?
04:47:15 <Axman6> both
04:47:17 <NOOB1235> common
04:47:22 <NOOB1235> \or yeah both
04:47:58 <ibid> the question is not answerable until you specify a metric
04:47:59 <NOOB1235> please dont be biased
04:48:02 <ibid> better for what?
04:48:15 <NOOB1235> which is faster
04:48:17 <XexonixXexillion> If you're using the JVM, i'd recommend clojure
04:48:18 <Axman6> NOOB1235: please don't ask stupid questions then :\
04:48:57 <XexonixXexillion> NOOB1235: and haskell will probably be faster, because it can be compiled
04:48:58 <NOOB1235> my dick is very very large right now
04:49:55 <Axman6> @where ops
04:49:55 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:50:07 <osfameron> trolling aside, you can compile lisp too, can't you?
04:50:13 <ibid> yes
04:50:17 <erus`> cabal install froze and i cant kill it
04:50:58 <ibid> NOOB1235: "faster" is not a language metric. it's an implementation metric, and it is underspecified. "faster" in what context?
04:51:13 <Axman6> ibid: quit feeding the trolls
04:51:28 <Axman6> being correct doesn't work, true me
04:51:31 <Axman6> trust me even
04:51:57 <tmhz> hpc: One more question, why is tuple from reads wrapped in a list [(Integer, String)]? Is it just the way it is being typed?
04:52:03 <_Mikey> geheimdienst, When I grow up in the haskell world I want to write a mondad tutorial ^^
04:52:59 <Axman6> tmhz: because if reads can't parse the input, it returns an empty string
04:53:01 <geheimdienst> osfameron: some lisps, i think. should help in the speed department. don't know if it helps much in the finding-bugs department, because lisps are so dynamic. i doubt the typical lisp compiler could type-check your program as much as ghc can
04:53:08 <geheimdienst> _Mikey: it's a rite of passage ...
04:53:48 <tmhz> hpc: gotcha
04:53:52 <Axman6> technically, reads is supposed to return all possible parses that can succede, I think. but in practice it only ever gices zero or one results
04:54:05 * Axman6 isn't hpc
04:54:50 <ski> Axman6 : empty list
04:55:31 <XexonixXexillion> if you define read on your own data types in such a way as there are two possible ways of parsing the data, you'll get multiple results
04:55:46 <int-e> > (reads :: ReadS Float) "[]" -- ;-)
04:55:47 <lambdabot>   []
04:56:05 <Axman6> ski: huh?
04:56:06 <ski> tmhz : if `reads' can't parse, it returns an empty list. if `reads' can parse in more than one way, it returns a list with more than one pair in it
04:56:24 <ski> Axman6 : an empty list of type `[(Integer, String)]' is never an empty string
04:56:49 <Axman6> oh, right. yeah it's been a very long day
04:57:14 <Axman6> spent the last 7 hours directing embassadors' cars around for the Obama visit
04:57:36 <ski> tmhz : note that none of the standard `Read' instances (afaik) ever generate more than one parse possibility
04:57:45 <ddarius> Axman6: You should have wrote a program to do it for you.
04:58:31 <tmhz> ok that makes more sense, so it is just a way to describe a non-parse
04:58:53 <tmhz> is there some type of Maybe read? I could not find one?
05:00:02 <Axman6> no
05:00:12 <erus`> whats the HOpengl way to load textures?
05:00:26 <geheimdienst> tmhz: i always do what the faq suggests http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
05:00:34 <mux> :t listToMaybe . reads
05:00:36 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
05:00:40 <geheimdienst> although that method is not in the standard library (yet)
05:00:41 <ddarius> @hackage safe
05:00:42 <lambdabot> http://hackage.haskell.org/package/safe
05:00:44 <mux> close enough?
05:00:53 <mux> listToMaybe is under-appreciated
05:01:20 <ddarius> mux: It's just a special case of traverse.
05:01:52 <mux> ddarius: yeah well, traverse is so general I'm not surprised
05:02:02 <geheimdienst> mux: yeah, it's basically the replacement for head. although listToMaybe is kind of a goofy, long name
05:02:15 <int-e> > let readM s = case reads s of [(a, s)] | all isSpace s -> return a; _ -> mzero in readM "  123  " :: Maybe Integer
05:02:16 <lambdabot>   Just 123
05:02:59 <tmhz> wow thats a lot of possibilities, thank you
05:03:39 <int-e> (throwing away the remaining string would allow you to parse "123 123" as an integer, which presumably you don't want)
05:03:45 <geheimdienst> int-e: seems like you put a trim into that ... not sure if that's so cool :)
05:03:58 <int-e> geheimdienst: it's what read does
05:04:00 <geheimdienst> what monads other than Maybe would readM help with?
05:04:41 <int-e> > (reads :: ReadS Integer) "  123  "
05:04:41 <lambdabot>   [(123,"  ")]
05:05:38 <int-e> @type readIO
05:05:39 <lambdabot> forall a. (Read a) => String -> IO a
05:06:14 <int-e> geheimdienst: Maybe is the most natural one. List is another. IO will work, but would profit from using 'fail' with suitable error messages; same for Either.
05:06:19 <frerich> Hm, in C++, you can bind the second argument of some functor using the std::bind2nd function (e.g. 'bind2nd(less<int>(),0)' yields an unary function which tells whether the given argument is negative'). How would that be done best in haskell, using 'flip' and then just currying the first argument I guess (like "flip map "Hello"" to bind the second argument of 'map')?
05:06:28 <tmhz> > (reads :: ReadS Integer) "  \t \n 123"
05:06:29 <lambdabot>   [(123,"")]
05:06:42 <frerich> Hm, or I could maybe use 'map' infix...
05:06:43 <tmhz> so reads trims all whitespace
05:06:53 <geheimdienst> int-e: right, List might be useful
05:07:00 <mux> frerich: using flip seems okay to me here, though I'd use (`map` "Hello") myself
05:07:03 <frerich> Hm indeed, (`map` "Hello") works :-)
05:07:18 <earthy> sounded like a section :)
05:07:18 <int-e> tmhz: except at the end.
05:07:19 * mux guesses he's too late again
05:07:28 <Gothmog_> \pl \s d -> replicate (d - length s) ' ' ++ s
05:07:34 <Gothmog_> pl \s d -> replicate (d - length s) ' ' ++ s
05:07:41 <Gothmog_> @pl \s d -> replicate (d - length s) ' ' ++ s
05:07:41 <lambdabot> flip =<< ((++) .) . flip flip ' ' . (replicate .) . subtract . length
05:07:43 <frerich> mux: It's good to see somebody else had the same idea :-)
05:07:59 <mux> frerich: IIRC, that is one of the automatic suggestions of HLint
05:08:58 <frerich> mux: Is ther ealso a nice way to bind any other argument (say, the third argument of 'foldr')?
05:09:59 <mux> frerich: not that I know of - I guess I'd write it (\x f -> foldr x f "Hello")
05:10:21 <geheimdienst> frerich: i'd do (\x y -> foldr x y [1..42]), suppose you want to fix that. it wouldn't be hard to emulate c++ however. a bind3 function is easily written in haskell
05:12:58 <geheimdienst> in c++, afaik you can't just write something like "\x y -> foo". lambda syntax is much more cluttered, so those bind functions pay off somewhat more
05:16:47 <bxc> geheimdienst: have you played with the boost lambda library?
05:17:22 <bxc> (can't remember name of it, btu friend was enthused about it)
05:17:33 <geheimdienst> nope ... i don't use the word "play" when c++ is involved, i use "torture"
05:17:42 <geheimdienst> is the library any good?
05:18:19 <bxc> never played with it -just know my friend liked it
05:19:40 <anincog> A question about laziness and garbage collection: Suppose I have a data type Foo = Foo Int Bar, where Bar is some type. Let y = Foo 5 huge, where huge is some very big Bar. If I have a series of computations, say in the IO monad: First there is one that takes the y and prints something based on the Bar field. Afterwards, we simply take the y and use it only to print the Int field. Will GHC be able to garbage collect the Bar after the
05:19:40 <anincog>  first print, or does it think that "y will still be used"?
05:20:17 <deggis> so i'm using this statistics package, which offers i.e. this function returning general vector of type Data.Vector.Generic.Base.Vector v1 Double. how to find a vector implementation that suits that type? (in other words, how to call that)
05:22:25 <anincog> I guess what I'm saying is: For types that consist of multiple other types, is GHC able to garbage collect individual fields, or does it only garbage collect (or not) the entire composite type?
05:23:14 * Eliel wonders how a CPU designed for running haskell code would differ from the current CPUs.
05:24:08 <Ke> o_O
05:24:59 <geheimdienst> hardware support for monads
05:26:38 <Nimatek> Thunk registers!
05:26:40 <Eliel> would be an interesting CPU if it could interpret haskell code directly (or perhaps a monomorphic translation).
05:27:17 <Nimatek> Pretentiousness cache.
05:28:05 <Axman6> Eliel: google "reduceron"
05:28:34 <Axman6> it's a CPU specifically designed for running haskell like programs, using graph reduction
05:28:44 <Axman6> s/programs/languages
05:29:51 <flux> I wonder if you could somehow express graph reductions as matrix operations, something a GPU could do :)
05:29:57 <Gothmog_> @pl \a b -> elems a == elems b
05:29:58 <lambdabot> (. elems) . (==) . elems
05:30:17 <Gothmog_> @pl \a b -> f1 a == f2 b
05:30:17 <lambdabot> (. f2) . (==) . f1
05:32:25 <troydm> can i see the definition of Maybe monad using hoogle? if not how/where can i see definition ?
05:33:11 <Axman6> @src Maybe (>>=)
05:33:12 <lambdabot> (Just x) >>= k      = k x
05:33:12 <lambdabot> Nothing  >>= _      = Nothing
05:33:15 <Axman6> @src Maybe return
05:33:15 <lambdabot> return              = Just
05:34:07 <troydm> Axman6: ohh ok but wouldn't that bother ppl in this channel if i will use it everytime?
05:34:26 <troydm> Axman6: is there an alternative (more like web site) way?
05:34:34 <earthy> troydm: you can msg lambdabot
05:34:47 <earthy> /msg lambdabot @src Maybe (>>=)
05:35:16 <troydm> earthy: ok that aside, there is no web site for browsing haskell source?
05:35:32 <Saizan> the haddocks on hackage have source links
05:35:46 <Saizan> finding the code for an instance is not that easy though
05:37:51 <troydm> heh found this http://lukeplant.me.uk/blog/posts/haskell-api-docs-suck-a-lot/
05:38:46 <earthy> saizan: it's not that bad. The instances tend to be quite close under the sources for the datatype definitions
05:40:14 <gienah> @hoogle '(>>=) :: Maybe a'
05:40:14 <lambdabot> Parse error:
05:40:14 <lambdabot>   '(>>=) :: Maybe a'
05:40:14 <lambdabot>   ^
05:40:24 <geheimdienst> troydm: the Maybe Monad instance is here: http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.1.0/Data-Maybe.html (click the "source" link in the top right corner). instances are exported from a lot of places, but as Saizan says, finding where it's actually defined is kind of a wild-goose chase
05:40:26 <gienah> @hoogle (>>=) :: Maybe a
05:40:26 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:40:26 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:40:26 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:41:11 <troydm> geheimdienst: ohh missed that one, thx
05:41:31 <geheimdienst> and the blog you linked is right, haddocks often suck :-(
05:41:52 <earthy> well, yes and no. haddocks often don't have usage examples
05:42:12 <earthy> and figuring out usage just from types may well be complex
05:42:55 <geheimdienst> earthy: yeah. so without examples, even if you do everything else perfectly, you still have only mediocre documentation
05:43:56 <geheimdienst> earthy: and the blog criticizes =~~, which is undocumented and has the type (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 Source target, Monad m) => source1 -> source -> m target
05:44:15 <geheimdienst> could be worse, but could be much better as well
05:45:57 <troydm> also 1 more question. I have ghc 7.0.3 and i see that there is an ghc 7.0.4 out already, can i use cabal to upgrade to this version
05:46:13 <troydm> or i should download the new binary distribution and install it
05:46:15 <troydm> ?
05:48:47 <earthy> geheimdienst: but RegexMaker, Regex, CompOption, ExecOption and RegexContext *are* documented
05:49:04 <earthy> so it is nontrivial, but not impossible either to figure out
05:49:08 <geheimdienst> troydm: afaik cabal can't upgrade ghc. but since it's just a 0.0.1 difference, i wouldn't bother in the first place, unless you have some problem with 7.0.3 which the 7.0.4 release notes say is fixed
05:49:30 <troydm> geheimdienst: ok
05:49:38 <srhb> I think that's only the case for OS X users.
05:52:10 <geheimdienst> earthy: sure, but it's a slippery slope. "it's not impossible to figure out, if you have spent months thinking about the problem domain / if you have six phds / if you studied obscure math for decades"
05:52:20 * earthy nods
05:52:47 <earthy> still, having the types and some documentation on them is a lot better than only having the code
05:53:01 <earthy> so the slope slips the other way too :)
05:53:13 <earthy> (and yeah, I do agree with the base sentiment that docs Should Be Better)
05:53:30 <earthy> no time to do anything much about them unfortunately.
05:54:16 <geheimdienst> well as i said, it could be worse, but it also could be a lot better. i didn't mean to uphold that regex function as the worst possible case, or whatever
05:54:57 <earthy> ofcourse, docs that simply point to the writings of Oleg are no good either :P
06:02:53 <geheimdienst> http://www.haskell.org/haskellwiki/Monad_tutorials_timeline <- ok, added a chart :)
06:03:10 <Veinor> haha
06:07:00 <osfameron> I gave a mini monad tutorial as part of a Perl talk http://www.slideshare.net/osfameron/functional-pearls-version-2-presentation (from slide 39)
06:07:30 <erus`> i saw that on vimeo
06:12:52 <Veinor> rank(a -> b) = 1 + rank(a), right?
06:13:25 <hiptobecubic> osfameron, nice slides, still probably don't get it. lol
06:15:36 <osfameron> hiptobecubic: heh, to be fair some of it is a fairly esoteric mix of haskell ideas and perl source-filters.
06:15:58 <osfameron> it was mostly worth it to make a joke about *finally* being able to write imperative code *in pure Perl!*
06:16:15 <hiptobecubic> osfameron, i can grok the perl-side, just the monad concept isn't solid
06:16:16 <Gothmog_> @pl \i -> (a `at1` i) + (b `at1` i)
06:16:17 <lambdabot> liftM2 (+) (a `at1`) (b `at1`)
06:16:25 <Gothmog_> yeah.
06:16:29 <hiptobecubic> it's like.. a collection of actions to be done?
06:17:36 <Veinor> honestly
06:17:46 <Veinor> the only way i actually 'understood' monads is by working with them
06:18:01 <cheater> and eating burritos
06:18:12 <Veinor> monads are a model for computation, but that's not something that'll mean anything to you unless you really grok them
06:18:28 <geheimdienst> hiptobecubic: as far as IO is concerned -- yeah, that's kind of an okay explanation. in other monads, you don't have "IO actions to be done" of course
06:19:17 <alistra> monads are just syntactic sugar :|
06:19:17 <cheater> for example the list monad is a completely different thing
06:19:25 <cheater> alistra: for monad comprehensions?
06:19:30 <alistra> so you don't have to combine computation in a complex way
06:19:31 <hiptobecubic> geheimdienst, well i just worked through this 'roll your own irc bot' no the haskell wiki and introduces a 'Net' monad as a way to pass state around between functions 'in the monad'
06:19:41 <geheimdienst> > fmap even $ Just 3
06:19:43 <lambdabot>   Just False
06:19:47 <geheimdienst> > fmap even $ Nothing
06:19:48 <lambdabot>   Nothing
06:21:20 <hiptobecubic> it's a bit puzzling, the whole thing
06:22:02 <alistra> hiptobecubic: what's puzzlink?
06:22:06 <alistra> hiptobecubic: what's puzzling?
06:22:31 <hiptobecubic> something being 'in the IO monad' or 'in the Net monad' or some combination of the two
06:22:57 <Botje> the Net monad is a combination of IO and State.
06:23:08 <alistra> IO monad is a special kind of monad
06:23:10 <alistra>  :P
06:23:18 <sipa> what's special about it?
06:23:24 <alistra> hmm
06:23:38 <sipa> as far as its monadness is concerned, it is imho the most typical of them all
06:24:04 <alistra> you cannot write a copy of an IO monad by yourself with a new datatype
06:24:05 <alistra> :P
06:24:15 <alistra> at least without ghc internals mangling
06:24:16 <alistra> i think
06:24:22 <sipa> that has nothing to do with monads
06:24:27 <sipa> IO is just a very special type
06:24:44 <alistra> yes thatas why
06:24:52 <alistra> lift special
06:24:58 <alistra> and the monad is special too
06:25:08 <hpaste> ujm pasted “pack” at http://hpaste.org/54109
06:25:26 <ujm> so I am doing number 9 from http://www.haskell.org/haskellwiki/99_questions/1_to_10
06:27:03 <Botje> ujm: okay
06:27:17 <ujm> and it gives me Couldn't match expected type `[Char]' with actual type `Char' on the 3rd line
06:27:18 <Botje> ujm: as a sidenote, using String makes your function less generic than it should be
06:28:11 <alistra> > map (foldl (\(n,e) e2-> (n+1,e2)) (0,0)) (groupBy (==) [1,1,1,3,4,4,4])
06:28:12 <lambdabot>   [(3,1),(1,3),(3,4)]
06:28:20 <alistra> spoiler
06:28:36 <alistra> (works only for ints)
06:28:41 <alistra> nums*
06:28:46 <Botje> ujm: why the ++ " " ++ in the middle?
06:29:03 <Botje> the assignment doesn't need it, it returns a [String]
06:29:14 <Botje> :t (" " ++)
06:29:15 <lambdabot> [Char] -> [Char]
06:29:18 <ujm> so I could use words to split it up into a list of strings
06:29:26 <Botje> ujm: why?
06:29:36 <ujm> couldn't think of a better way to do it :S
06:29:42 <alistra> oh wait i've made 10.
06:29:47 <Botje> takeWhile (== head xs) xs :: String
06:29:53 <alistra> groupBy (==)
06:30:07 <Botje> so you cons (using the : operator) that to the recursive invocation of pack
06:30:19 <alistra> > groupBy (==) "aaaabccaadeeee"
06:30:20 <lambdabot>   ["aaaa","b","cc","aa","d","eeee"]
06:30:33 <EvanR-wo1k> groupBy is genius
06:30:43 <alistra> come on
06:31:03 <alistra>  map (foldl (\(n,e) e2-> (n+1,e2)) (0,0)) (groupBy (==) [1,1,1,3,4,4,4])
06:31:07 <alistra> this is 10 anyway
06:31:12 <ujm> :O I should look through all the functions in the library. didn't see groupsBy
06:31:22 <EvanR-wo1k> also nubBy
06:31:27 <EvanR-wo1k> and \
06:31:31 <alistra> try hoogle ujm
06:31:37 <alistra> and image what would the type be
06:32:08 <ujm> thanks
06:32:22 <luite> > groupBy (<) [1,2,3,4,3,2,1]
06:32:23 <lambdabot>   [[1,2,3,4,3,2],[1]]
06:32:40 <alistra> @hoogle Eq a => (a->a->Bool) -> [a] -> [[a]]
06:32:40 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
06:32:41 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
06:32:41 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
06:32:46 <alistra> see
06:32:50 <alistra> typesa
06:32:53 <alistra> types are magic
06:33:25 <EvanR-wo1k> its like fantasia magic symbols swirling around you
06:33:44 <alistra> an you can infer functions from them
06:33:46 <alistra> in hoogle
06:37:35 <ujm> oh that is nice, I've only been using Hoogle to guess the name of the functions I need
06:39:37 <xzvz> is there a person who can help me with php ?
06:39:51 <alistra> troll
06:40:05 <xzvz> why am i troll ?
06:40:07 <geheimdienst> xzvz: you're in the wrong place here, this channel is about the haskell programming language, not php programming
06:40:38 <xzvz> please give me a link because i don't get along with the language
06:41:01 <EvanR-wo1k>  /join #php
06:41:11 <EvanR-wo1k> and god have mercy on your soul
06:41:20 <alistra>  /disco
06:41:24 <xzvz> `10x
06:41:39 <EvanR-wo1k> hes a bot
06:41:42 <xzvz> join #php
06:42:11 <statusfailed> MercyFacilitator.FacilitateMercy(GodFactory.CreateGod(), this.AsSoul())
06:42:32 * osfameron wonders if people in real life just walk into random shops and demand products / support
06:42:42 <byorgey> osfameron: yes
06:42:43 <liyang> I think they do.
06:42:56 <osfameron> great!  I might start doing that myself
06:43:07 <Botje> osfameron: notalwaysright.com has a story like that almost on a daily basis
06:43:09 <osfameron> it sounds a lot more convenient than actually having to decide which shop to go to
06:43:13 <alistra> except the people in shops get paid
06:43:24 <statusfailed> osfameron: wave enough money around and it would probably work~
06:43:26 <Ferdirand> nonsense, that should be GodFactory.getGodSingleton().getInstance()
06:43:30 <statusfailed> Ferdirand: lol
06:43:45 <EvanR-wo1k> this javaphp shit is really painful please stop
06:44:13 <alistra> Ferdirand: depends on Env.isMonotheistic
06:44:39 <statusfailed> ... I think a website just went down
06:44:54 <EvanR-wo1k> disturbance in the force
06:44:56 <byorgey> looks like it
06:45:05 <byorgey> guess they should have implemented their website in Haskell
06:45:12 <EvanR-wo1k> its like 22 voices were suddenly silenced
06:45:46 <Gothmog_> @pl \a -> matrix (1, 1) (const $ fromInteger a)
06:45:47 <lambdabot> matrix (1, 1) . const . fromInteger
06:46:13 <statusfailed> What does @pl do, simplify code?
06:46:17 <geheimdienst> byorgey: yes, that would clearly make it much safer. granted, the site would still be in the planning stages with programmers off site for training, but if they ever get there, it'd be great :)
06:46:21 <EvanR-wo1k> pointless
06:46:24 <alistra> statusfailed: point free form
06:46:34 <alistra> not exactly simplifies
06:46:35 <saml> https://github.com/szeiger/luhnybin/blob/master/luhny.hs  hey explain this to me
06:46:46 <_Mikey> o.o
06:46:47 <statusfailed> alistra: What's "point free"?
06:46:51 <EvanR-wo1k> no variables
06:46:54 <statusfailed> oh I see
06:46:54 <geheimdienst> statusfailed: it converts that to pointless form, see here http://haskell.org/haskellwiki/Pointfree
06:46:58 <alistra> this ^
06:48:12 <statusfailed> oh, cool
06:48:33 <byorgey> statusfailed: sometimes it's a simplification and sometimes it isn't ;)
06:48:37 <statusfailed> heehe
06:48:52 <byorgey> @pl \x y z w -> f x (g y y z) (h x)
06:48:52 <lambdabot> ((const .) .) . ap (flip . (flip .) . (. join g) . (.) . f) h
06:49:16 <alistra> @def ap
06:49:17 <lambdabot> Maybe you meant: bf do let
06:49:30 <alistra> @hoogle ap
06:49:30 <byorgey> @src ap
06:49:30 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
06:49:30 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
06:49:30 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
06:49:30 <lambdabot> ap = liftM2 id
06:49:39 <alistra> lol @ liftM2 id
06:49:50 <sipa> @pl liftM2 id
06:49:50 <lambdabot> ap
06:50:03 <byorgey> alistra: in this particular case it is using the 'ap' of the ((->) e) monad
06:50:36 <byorgey> which is also known as the S combinator, defined as   \f g x -> f x (g x)
06:51:06 <liyang> @pl liftM2 ($)
06:51:06 <lambdabot> ap
06:51:29 <alistra> uh i had a curry-howard isomorphism lecture recently
06:51:39 <alistra> with some combinators
06:52:10 <geheimdienst> > ((==) `ap` reverse) "radar" -- this is as good a time as any to blatantly show off my palindrome checker again
06:52:11 <lambdabot>   True
06:52:12 * liyang had used `id` a couple of times when he wanted to use ($) for something else.
06:52:35 <snappy> 1
06:59:18 <applicative> @pl \x ->  x ==  reverse  x
06:59:18 <lambdabot> ap (==) reverse
06:59:57 <applicative> @pl (\x ->  x ==  reverse  x) "radar"
06:59:58 <lambdabot> ap (==) reverse "radar"
07:00:19 <alistra> isFixedPoint f = ap (==) f
07:00:20 <alistra> :D
07:00:30 <applicative> sometimes its awesome, this @pl...
07:00:40 <alistra> it's pointless
07:01:09 <FUZxxl> alistra: Completely
07:01:28 <geheimdienst> > ((==) <*> reverse) "kinda like this better, actually. probably @pl doesn't know about <*> however"
07:01:29 <alistra> Totally
07:01:29 <lambdabot>   False
07:01:42 <Ferdirand> it is strangely intuitive
07:02:14 <Ferdirand> strangely in a sense that it seems obvious what it does, but maybe not for good reasons
07:02:49 <applicative> geheimdienst: maybe we should take up maintaining it, we can introduce some really insane combinators...
07:03:20 * geheimdienst giggles insanely
07:03:33 <alistra> is it complete in that sense
07:03:45 <alistra> that each expression can be written pointfree?
07:03:48 <alistra> oh wait
07:03:55 <alistra> i just realized that the question is dumb
07:04:07 <alistra> you can write everything using 2 combinators
07:04:17 <alistra> @pl let f x = f x
07:04:18 <lambdabot> (line 1, column 14):
07:04:18 <lambdabot> unexpected end of input
07:04:18 <lambdabot> expecting variable, "(", operator, ";" or "in"
07:04:24 <geheimdienst> i'd like that, an at-best-intermediate haskeller like me willy-nilly introducing new combinators every week
07:04:28 <alistra> @pl let f x = f x in f 5
07:04:29 <lambdabot> fix id 5
07:04:40 <geheimdienst> this can only lead to great good
07:07:14 <alistra> @pl \f g h x -> f $ g $ h $ x
07:07:15 <lambdabot> (. (.)) . (.) . (.)
07:07:35 <alistra> mutant boobs :|
07:07:41 <zomg> Total Recall
07:08:50 <EvanR-wo1k> Q "and you have first hand experience with [triple breasted alien girls]?" A "first hand, second hand, ... third hand"
07:09:55 <erus`> does ghc unroll small loops?
07:10:10 <kyagrd> @pl fmap fmap
07:10:11 <lambdabot> fmap fmap
07:10:38 <erus`> like this: isRightAngled = any (≡ 90) [a1, a2, a3]
07:11:38 <geheimdienst> erus`: have you profiled the code and found out that particular place is slower than you expected?
07:11:59 <erus`> no just a theoretical
07:14:53 <djanatyn> ...*wow*
07:15:09 <djanatyn> I can't believe I never took the time to pay attention to LYAH instead of skimming int
07:15:26 <djanatyn> currying functions is awesome, I never considered the consequences before
07:15:45 <yrlnry> The nice thing about reading is that you can go back and do it over a different way.
07:16:16 <djanatyn> and pattern matching is so awesome - you can use it everywhere!
07:16:27 <mzero> despite coding in HS for several years, I bought the hardcopy of LYAH and went through it -- it was delightful!
07:16:38 <mike-burns> I like the pictures.
07:16:39 * djanatyn got the hardcopy from the library
07:16:56 <mzero> ...and it is nice to lend to my not-yet-coding-in-Haskell friends
07:17:25 <mm_freak> is there something like monad-control for arrows?
07:17:49 <Saizan> erus`: i'd guess no, but it shouldn't be hard to check by looking at the core for such a small example
07:18:28 <mm_freak> i need something like this:  finally :: ArrowControl (>~) => (a >~ b) -> (a >~ c) -> (a >~ b)
07:21:46 <cfricke> Hey folks, is there a short way to receive an item from a list with the highest frequency?
07:22:14 <EvanR-wo1k> histogram, sort, !! 0
07:22:32 <cfricke> Not part of Ord.
07:22:36 <_Mikey> I would have said !! but no idea if its short.
07:22:48 <EvanR-wo1k> s/!! 0/head/
07:22:58 <EvanR-wo1k> cfricke: counts are in Ord
07:23:11 <cfricke> EvanR-wo1k: Got it, misread, thanks!
07:23:56 <EvanR-wo1k> > maximum []
07:23:57 <lambdabot>   *Exception: Prelude.maximum: empty list
07:24:17 <EvanR-wo1k> also cfricke [] = error "empty list"
07:25:02 <cfricke> Hm,I don't suppose histogram is predefined?
07:25:09 <EvanR-wo1k> heh
07:25:42 <EvanR-wo1k> histogram is sort, groupBy (==), map length
07:25:56 <mike-burns> So no, it's not.
07:26:17 <EvanR-wo1k> its predefined, in your brain
07:26:45 <mux> groupBy (==) would be more happily written group
07:26:52 <EvanR-wo1k> ya
07:27:01 <EvanR-wo1k> map length . group . sort
07:27:07 <cfricke> So many things already forgotten.
07:27:27 <cfricke> Ok, let me try something and return upon failure, or success.
07:28:15 <applicative> @type snd . last . sort . map ((,) =<< length) . group . sort
07:28:16 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:28:33 <applicative> lame, but pointless
07:28:46 <zorzar> can anybody tell me why fromJust(Just "Hello") tells me that formJust is not in scope?
07:28:56 <EvanR-wo1k> import Data.Maybe
07:29:08 <EvanR-wo1k> and fromJust is for weenies
07:29:14 <mzero> > let histogram = map (\a -> (length a, head a)) . group . sort in histogram "four score and twenty years ago"
07:29:16 <lambdabot>   [(5,' '),(3,'a'),(1,'c'),(1,'d'),(3,'e'),(1,'f'),(1,'g'),(2,'n'),(3,'o'),(3...
07:29:18 <applicative> zorzar it's not a Prelude function.
07:29:18 <ion> fromJust is unsafe.
07:29:42 <zorzar> applicative: EvanR-wo1k: great thanks
07:29:58 <applicative> zorzar, plenty of Prelude functions are just as unsafe as fromJust ... :)
07:30:06 <mike-burns> `fromJust (Just 4)' is fine, though.
07:30:07 <wlangstroth> what's the fromJust alternative?
07:30:12 <zorzar> well i'm just getting my feet wet with python
07:30:13 <mike-burns> :t maybe
07:30:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:30:17 <EvanR-wo1k> ion: its totally safe, if isJust then fromJust else ;)
07:30:21 <geheimdienst> wlangstroth: fromMaybe
07:30:42 <geheimdienst> > (fromMaybe "default" $ Nothing, fromMaybe "default" $ Just "something")
07:30:43 <applicative> @type maybe 2 id Nothing
07:30:43 <lambdabot>   ("default","something")
07:30:44 <lambdabot> forall a. (Num a) => a
07:31:03 <mux> maybe x id == fromMaybe x
07:31:26 <mzero> > let histogram = map (\a -> (length a, head a)) . group . sort in maximum . groupBy fst . histogram $ filter (/=' ') "four score and twenty years ago"
07:31:27 <lambdabot>   <no location info>:
07:31:27 <lambdabot>      lexical error in string/character literal at chara...
07:31:28 <mm_freak> :t fst . head . sortBy (comparing (snd . negate)) . map (head &&& length) . group . sort
07:31:29 <lambdabot> forall a. (Num a, Ord a) => [a] -> a
07:31:37 <mzero> > let histogram = map (\a -> (length a, head a)) . group . sort in maximum . groupBy fst . histogram $ filter (/= ' ') "four score and twenty years ago"
07:31:38 <lambdabot>   <no location info>:
07:31:38 <lambdabot>      lexical error in string/character literal at chara...
07:31:45 <wlangstroth> geheimdienst: ha! I read "fromJust" as "fromMaybe" and thought "what's wrong with "fromMaybe"???
07:31:46 <EvanR-wo1k> whats with the backslashes
07:31:50 <mm_freak> > fst . head . sortBy (comparing (snd . negate)) . map (head &&& length) . group . sort $ "afnsdfsssasif"
07:31:51 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:31:51 <lambdabot>    arising from a use of `GHC....
07:32:20 <wlangstroth> (dangers of working an irc-ing at the same time)
07:32:24 <applicative> zorzer, fromMaybe is classier, but it's not in the Prelude either.
07:32:24 <mm_freak> > fst . head . sortBy (comparing (negate . snd)) . map (head &&& length) . group . sort $ "afnsdfsssasif"
07:32:26 <lambdabot>   's'
07:32:35 <mm_freak> :t fst . head . sortBy (comparing (negate . snd)) . map (head &&& length) . group . sort
07:32:36 <lambdabot> forall a. (Ord a) => [a] -> a
07:33:21 <EvanR-wo1k> whats the state of the time lib?
07:33:23 <DevHC_> what is the fromIntegral-equivalent for floating point types?
07:33:25 <EvanR-wo1k> Data.Time ?
07:33:29 <EvanR-wo1k> use dont use?
07:34:11 <ion> realToFrac
07:34:14 <mux> > maximumBy (comparing length) . group . sort $ "adeopdeudnjuijdnaaa"
07:34:16 <lambdabot>   "dddd"
07:34:26 <mux> close enough.
07:34:33 <applicative> much nicer
07:34:35 <mux> > maximumBy (comparing length) . group . sort $ "aadeopdeudnjuijdnaaa"
07:34:37 <lambdabot>   "aaaaa"
07:34:46 <mux> yeah, it avoids the whole tupling with length dance
07:35:44 <mzero> aha
07:35:45 <mzero> > let histogram = map (\a -> (length a, head a)) . group . sort in maximum $ groupBy (on (==) fst) $ sort $ histogram $ filter (/= ' ') "four score and twenty years ago"
07:35:47 <lambdabot>   [(3,'a'),(3,'e'),(3,'o'),(3,'r')]
07:35:51 <mm_freak> EvanR-wo1k: i use it all the time
07:35:56 <mm_freak> the time library that is
07:36:04 <mzero> it is important to note that in a Histogram there may not be a single greatest
07:36:28 <EvanR-wo1k> mm_freak: isnt there a replacement
07:36:29 <mm_freak> i can't name a single package that i have written in the past three months which doesn't use it
07:36:38 <mm_freak> EvanR-wo1k: time is the replacement for old-time
07:36:44 <EvanR-wo1k> ok
07:36:54 <mike-burns> @hoogle histogram
07:36:54 <EvanR-wo1k> i see the absolute time was removed?
07:36:54 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Histogram module Graphics.Rendering.OpenGL.GL.PixelRectangles.Histogram
07:36:55 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.Histogram histogram :: Proxy -> StateVar (Maybe (GLsizei, PixelInternalFormat, Sink))
07:36:55 <lambdabot> package histogram-fill
07:36:59 <DevHC_> btw, what r the chances that (realToFrac :: CFloat -> Float) is unsafeCoerce on my system?
07:37:13 <ion> r = 42
07:37:25 <DevHC_> @let r = are
07:37:26 <lambdabot>  <local>:2:4: Not in scope: `are'
07:37:33 <DevHC_> so i'll just stick to using r
07:37:48 <mike-burns> What.
07:37:57 <roconnor> DevHC_: maybe more likely to be id
07:37:59 <mike-burns> Anyway, it looks like there's at least histogram library.
07:38:10 <DevHC_> x86, FreeBSD
07:38:26 <ion> The only RULES entry for realToFrac seems to be for Int → Int. http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html#realToFrac
07:38:52 <ion> Perhaps the respective fromRational and toRational will be inlined and optimized away anyway.
07:38:55 <mux> DevHC_: you sir have very good taste for operating systems
07:39:04 <mike-burns> Agreed.
07:39:33 <DevHC_> mux: ^^
07:39:40 <EvanR-wo1k> openbsd
07:39:40 <ion> Less good taste for hardware architectures.
07:39:42 <roconnor> EvanR-wo1k: there is another package with AbsoluteTime
07:39:50 <DevHC_> ion: D:
07:39:52 <mux> ion: yeah but x86 at least is understandable
07:40:09 <EvanR-wo1k> also in the new time package, is there a 'datetime' type like in mysql
07:40:37 <EvanR-wo1k> guess thas UTCTime
07:40:49 <roconnor> oh wait, it looks like it is in time ...
07:40:57 <roconnor> http://www.haskell.org/ghc/docs/7.2.1/html/libraries/time-1.2.0.5/Data-Time-Clock-TAI.html
07:41:03 <roconnor> strange
07:41:20 <EvanR-wo1k> there used to be a way to convert from TAI to UTC with a leap second table
07:41:23 <roconnor> AbsoluteTime /= UTCTime
07:41:37 <cheater> ;w
07:41:38 <EvanR-wo1k> im probably not looking for absolute time, like most people
07:41:42 <cheater> wrong window! sorry
07:41:43 <EvanR-wo1k> i was just curious
07:41:54 <roconnor> utcToTAITime :: LeapSecondTable -> UTCTime -> AbsoluteTime
07:42:01 <roconnor> taiToUTCTime :: LeapSecondTable -> AbsoluteTime -> UTCTime
07:42:11 <DevHC_> Prelude Unsafe.Coerce Foreign.C> unsafeCoerce (4.0 :: CFloat) :: Float
07:42:11 <DevHC_> 4.0
07:42:11 <DevHC_> Prelude Unsafe.Coerce Foreign.C> unsafeCoerce (4.0 :: Float) :: CFloat
07:42:11 <DevHC_> 4.0
07:42:12 <EvanR-wo1k> seems undocumented
07:42:20 <roconnor> indeed
07:42:26 <mm_freak> EvanR-wo1k: you have UTCTime (absolute), LocalTime (zoneless) and ZonedTime (zoned)
07:42:54 <mm_freak> i use LocalTime or ZonedTime for displaying dates and UTCTime for handling them
07:42:55 <mux> "absolute time" sounds like insulting Einstein's intelligence
07:42:56 <EvanR-wo1k> ah LocalTime
07:43:03 <ion> mux: Hah
07:43:07 <mm_freak> also NominalDiffTime is a useful type when working with time deltas
07:43:13 * roconnor will use AbsoluteTime instead of UTC when building his operating system
07:43:20 <ion> (“Quantum physics” sounded like insulting Einstein’s intelligence.)
07:43:37 <mux> ion: most people misunderstand Einstein's objections to quantum physics though
07:43:49 <EvanR-wo1k> einstein was one of the founding fathers of QM
07:43:55 * mux nods at EvanR-wo1k 
07:44:10 <mm_freak> EvanR-wo1k: unless you have very specific reasons to work in local time, i recommend using UTCTime where possible
07:44:12 <mux> he was annoyed at the interpretation of it, or lack thereof, I think
07:44:14 <EvanR-wo1k> after he recovered from his inability to do basic math ;)
07:44:16 <roconnor> mux: still looking for a time-dependent hidden variable theory?
07:44:35 <mm_freak> EvanR-wo1k: particularly LocalTime is dangerous
07:44:41 <mux> roconnor: I'm sure some people are :-)
07:44:46 <EvanR-wo1k> mm_freak: right, looks like local time is a bone being thrown to be compatible with every other computer time system
07:44:47 <roconnor> :)
07:45:05 <EvanR-wo1k> mysql has an insane time system
07:45:10 <roconnor> I think LocalTime might have a place in some scheduling applications
07:45:30 <EvanR-wo1k> roconnor: bohmian!
07:45:33 <roconnor> I want my 10:00 am meets to still be at 10:00 am even after a DST change
07:46:01 <mm_freak> roconnor: can be done with UTCTime
07:46:36 <EvanR-wo1k> speaking of 'wrong in six months' what about when the governments change DST
07:46:37 <roconnor> mm_freak: ya, by reimplementing LocalTime
07:46:42 <hpaste> KitB pasted “Cumulative frequency” at http://hpaste.org/54110
07:46:48 <mm_freak> roconnor: ah, i see what you mean
07:46:56 <mm_freak> yes, that's a use case for LocalTime
07:47:16 <mm_freak> but then you're probably better off with ZonedTime
07:47:37 <mm_freak> in general i recommend either UTCTime or ZonedTime
07:47:48 <KitB> Anyone able to help on my hpaste?
07:48:18 <EvanR-wo1k> the time from midnight, 0 <= t < 86401s (because of leap-seconds)
07:48:21 <EvanR-wo1k> this is wrong
07:48:36 <EvanR-wo1k> 86402 ;)
07:48:45 <EvanR-wo1k> two leap seconds at once
07:48:47 <roconnor> I don't entirely understand ZonedTIme
07:49:15 <roconnor> EvanR-wo1k: are they allowed to do that ?
07:49:17 <EvanR-wo1k> yes
07:49:23 <roconnor> :O
07:50:24 <EvanR-wo1k> "Over long time periods, leap seconds must be added at an ever increasing rate (see ΔT)."
07:50:45 <bxc> theres a LEAPSECS mailing list
07:50:50 <bxc> if people are interested in this
07:50:53 <bxc> its pretty nuts
07:50:57 <danr> @unpl (.) . (.) . (.)
07:50:58 <lambdabot> (\ l b c f i -> l (b c f i))
07:51:05 <erus`> im there a timescale without all this rubbish?
07:51:05 <roconnor> This is the thing about software, you have to implement the entire rule set all at once, no matter how unlikely rules are going to occur.
07:51:14 <roconnor> erus`: TAI
07:51:26 <EvanR-wo1k> TAI and derivatives
07:51:40 <geheimdienst> but afaik 2 leap seconds in one day never happened. and the whole leap-second issue is vastly overrated, if you ask me. if your system completely ignored it, and ran for 30 years, it'd be off by what, 40 seconds or so. for most applications that's clearly tolerable, and not worth the effort of worrying about leap seconds all the time
07:51:53 <bxc> geheimdienst: heh go troll that on the leapsecs list
07:51:57 <EvanR-wo1k> note that unix time is not TAI nor UTC
07:52:39 <EvanR-wo1k> bxc: i think abolishing leap seconds would be good
07:52:49 <ion> devhc: ghc -O compiles (realToFrac :: Float -> CFloat) to id indeed.
07:52:55 <EvanR-wo1k> and leave UTC at +20 seconds from TAI
07:52:58 <roconnor> geheimdienst: Isn't there a movie about hackers gain access to a military computer during a 1-second leapsecond window due to a bug made by the assumption about the monotonicity of the clock?
07:53:02 <ion> s/compiles/optimizes/
07:53:02 <EvanR-wo1k> or whatever it is now
07:53:17 <EvanR-wo1k> roconnor: lol thats awesome
07:53:25 <hpaste> KitB annotated “Cumulative frequency” with “Cumulative frequency” at http://hpaste.org/54110#a54111
07:53:36 <geheimdienst> roconnor: oh yes, hollywood movies, crown jewel of technical accuracy
07:53:38 <bxc> leapseconds are still monotonous
07:53:55 <Nimatek> Time will be such a mess once people start travelling at relativistic speeds.
07:53:59 <EvanR-wo1k> bxc: except for negative leap seconds ;0
07:54:15 <EvanR-wo1k> Nimatek: nasa already has that covered
07:54:25 <Nimatek> EvanR-wo1k: They sure think ahead.
07:54:29 <EvanR-wo1k> http://en.wikipedia.org/wiki/Barycentric_Dynamical_Time
07:54:33 <EvanR-wo1k> http://en.wikipedia.org/wiki/Barycentric_Coordinate_Time
07:54:38 <codnik> hmm, does anyone know if Pastorn goes by a different name nowadays?
07:54:39 <bxc> EvanR-wo1k: in one, your clock goes 57, 58, 59, 60, 1:00, the other it goes 57,58,1:00
07:54:46 <bxc> EvanR-wo1k: they're both monotonous
07:55:04 <roconnor> Nimatek: I'm sure nasa has to make relativistic considerations when interpreting data from Voyager
07:55:37 <mux> they sure do, you have to do it even for GPS satellites
07:55:37 <EvanR-wo1k> bxc: two leap seconds at once
07:55:38 <roconnor> although that is probaby more due to the gravitational field than speed
07:55:54 <geheimdienst> yes yes, and every little hacked-together xmonad clearly should be designed with running on the voyager probe in mind
07:55:55 <EvanR-wo1k> GPS has to account for speed AND gravity
07:56:02 <geheimdienst> s/xmonad/xmonad module
07:56:05 <roconnor> bxc: good point
07:56:13 <roconnor> bxc: This movie sucks
07:56:29 <bxc> geheimdienst: its time libraries should be...
07:56:29 <ClaudiusMaximus> > let k xs = xs `zip` drop 1 (scanl (+) 0 xs) in k [1..5]
07:56:31 <lambdabot>   [(1,1),(2,3),(3,6),(4,10),(5,15)]
07:56:31 <EvanR-wo1k> geheimdienst: well if we didnt have leap seconds, we wouldnt have to
07:56:45 <roconnor> EvanR-wo1k: rumour has it that speed and gravity cancel and they don't have to consider anything at all :D
07:56:50 <EvanR-wo1k> lol
07:56:51 <EvanR-wo1k> right
07:56:59 <KitB> ClaudiusMaximus: Awesome
07:57:54 <roconnor> EvanR-wo1k: if you are right about 2 leap seconds you should tell Ashley.  Things like clipValid 0 60.999999999999 s need to be changed
07:58:14 <mux> that looks terribly fragile
07:58:48 <hpaste> cfricke pasted “freq” at http://hpaste.org/54112
07:58:56 <geheimdienst> > (zip <*> (tail . scanl (+) 0)) [1..5]
07:58:57 <lambdabot>   [(1,1),(2,3),(3,6),(4,10),(5,15)]
07:59:00 <roconnor> mux: it is slightly less fragile than it looks
07:59:03 <cfricke> Not pretty, but it works.
07:59:07 <EvanR-wo1k> roconnor: ill need to find a citation about it
07:59:10 <roconnor> mux: 60.999999999999 is fixed float
07:59:12 <mux> roconnor: yeah, not judging either, I never had to write such code
07:59:41 <roconnor> so the 12 9's is specific to picoseconds
08:00:26 <bxc> EvanR-wo1k: leapsecs mailing list probably love to tell you
08:00:32 <roconnor> (I'd personally write it in a more convoluated way to determine the smallest unit achivable in a given Fixed Float type.
08:00:55 <mux> roconnor: I suppose that if it guarantees at least picosecond precision we're safe
08:01:02 <dylex> is it really called Fixed Float?  that is an unfortunate choice.
08:01:03 <mux> assuming this is what you meant
08:01:24 <roconnor> mux: no. I mean the type is Fixed E12
08:01:29 <roconnor> er
08:01:32 <EvanR-wo1k> Some time in the 22nd century, two leap seconds will be required every year.
08:01:36 <Varakh> is it possible to construct a truthtable (2 dim table) for bool expressions? if yes, how
08:01:36 <roconnor> fixed point?
08:01:40 <roconnor> fixed precision?
08:01:55 <EvanR-wo1k> http://www.ucolick.org/~sla/leapsecs/HTMLutcdoomed.html
08:02:02 <Varakh> let x = 1
08:02:04 <Varakh> x
08:02:04 <k0ral> hi, I can't find any haskell library to manage the clipboard under linux
08:02:12 <k0ral> did I miss something ?
08:02:16 <Varakh> > let x = 1
08:02:16 <lambdabot>   not an expression: `let x = 1'
08:02:20 <mux> roconnor: this may be very stupid, but then I don't understand why this code isn't just using integrals?
08:02:21 <roconnor> http://en.wikipedia.org/wiki/Fixed_float
08:02:37 <roconnor> mux: it is using integrals under the hood
08:02:43 <ion> > liftA2 (&&) [False,True] [False,True]
08:02:44 <lambdabot>   [False,False,False,True]
08:02:44 <mux> ooooh!
08:02:51 <ClaudiusMaximus> > listArray ((minBound, minBound), (maxBound, maxBound)) [False, True, False, True] ! (False, True)
08:02:52 <lambdabot>   True
08:02:53 <applicative> KitB: if efficiency is needed note that the combinators ClaudiusMaximus used -- zip , drop , scanl etc. are all in Data.Vector.Unboxed
08:03:07 <dylex> EvanR-wo1k: but won't those two happen in different months?
08:03:20 <EvanR-wo1k> dylex: it wont be enough to do one per 6 months
08:03:22 <roconnor> dylex: I think I'm incorrectly using the term fixed float
08:03:33 <ion> > liftA2 (\a b -> (a,b,a && b)) [False,True] [False,True]
08:03:34 <KitB> applicative: So if I switch to unboxed version, mostly less memory usage?
08:03:34 <lambdabot>   [(False,False,False),(False,True,False),(True,False,False),(True,True,True)]
08:03:51 * KitB very much still a noob after a couple of years
08:04:50 <alistra> how to make a concatMapM
08:05:08 <alistra> oh wait it's specific for the list monad
08:05:18 * roconnor feels Data.Fixed is underused
08:05:51 <ion> alistra: What’s the type you want?
08:06:15 <ClaudiusMaximus> kakos: unboxed means there's no pointer for each element, generally they're stored in contiguous memory, which is both more space efficient and faster (for cache locality and lack of indirection reasons) - on the down side you lose laziness
08:06:17 <EvanR-wo1k> roconnor: perhaps by the time it will matter, civilization will change the whole time system 5 times
08:06:26 <ClaudiusMaximus> oops
08:06:33 <ClaudiusMaximus> KitB: ^^
08:06:40 <EvanR-wo1k> but i hate writing code that is sure to be wrong in some time
08:06:57 <EvanR-wo1k> that being said i will now use UTCTime!
08:06:59 <applicative> KitB I mentioned .Unboxed because you were using Int, so it is possible to use it, rather than regular Data.Vector
08:07:06 <KitB> applicative: Cool
08:07:11 <KitB> Though I don't need *that* much speed
08:07:12 <roconnor> EvanR-wo1k: 2 leap seconds every year is fine since they are allowed to add leap seconds in July as well as January
08:07:23 <KitB> This is just a helper function for some side work I'm doing for a piece of coursework
08:07:24 <EvanR-wo1k> roconnor: i was talking about two leap seconds per jump
08:07:26 <KitB> It's nice to know these things
08:07:34 <EvanR-wo1k> which would happen if you need 3 per year
08:07:45 <EvanR-wo1k> under the current regime
08:08:20 <kakos> ClaudiusMaximus: Awww.  I was hoping that was a spontaneous piece of information as a gift for my birthday.
08:08:22 <applicative> KitB, I recommend trying it if you haven't when you have menacing gluey list operations, it somehow does the right thing. See dons tutorial if you haven't http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
08:08:29 <dylex> EvanR-wo1k: most haskell code written today will be wrong in the sense of not having a working compiler/library long before then.
08:08:42 <roconnor> oh according to your link you have have a leap second at the end of any month
08:08:54 <EvanR-wo1k> dylex: i dont accept the existence of x86 machines when writing the code
08:08:57 <roconnor> ``
08:08:59 <roconnor> primary preference for semiannual scheduling in June
08:09:01 <roconnor> & December, and secondary preference for quarterly scheduling in March
08:09:01 <EvanR-wo1k> the data is pure
08:09:02 <roconnor> & September.
08:09:38 <EvanR-wo1k> i dont know the bureaucratic details
08:09:44 <EvanR-wo1k> but unix time allows for 2 leap seconds at once
08:09:48 <EvanR-wo1k> i think
08:10:16 <KitB> applicative: Cool, I'll have a look at that when all of my coursework is over (so much coursework)
08:10:29 <roconnor> EvanR-wo1k: your link suggests to me that there can only be 1 leap second per adjustment
08:10:44 <mah_b> Hi, are there similar techniques like shown in https://github.com/relevance/clojure-conj/raw/master/2011-slides/ambrose-bonnaire-sergeant-introduction-to-logic-programming.pdf  for haskell?
08:10:44 <EvanR-wo1k> well theres only 12 months in a year
08:10:56 <EvanR-wo1k> roconnor: i got that link from wikipedia universal coordinated time
08:10:59 <roconnor> EvanR-wo1k: otherwise it wouldn't conclude that after 12 leap seconds per year UTC is doomed
08:11:01 <EvanR-wo1k> coordinated universal time
08:11:29 <roconnor> (estimated to occur in the year 3752)
08:12:30 <EvanR-wo1k> roconnor: were at the point of arguing over wikipedia, which is stupid. but the leap second page shows only 2 months being used
08:12:45 <EvanR-wo1k> i think the leap second mailing list is a better idea
08:13:26 <roconnor> EvanR-wo1k: I'm refering to the posting you refered to on the Leap Second Discussion List
08:13:43 <roconnor> ... I guess their list has an FAQ that addresses this :)
08:14:11 <roconnor> although I don't see one
08:26:35 <deggis> hip. http://hpaste.org/54113 any other ways to accomplish myWrapper?
08:28:37 <ion> deggis: http://hackage.haskell.org/package/spoon
08:29:55 <deggis> just what i wanted would be an understatement. thanks! :)
08:30:16 <EvanR-wo1k> there is no spoon
08:31:36 <deggis> maybe there's a fork (of it) instead
08:32:31 <gtirloni> is there a process which decides the extensions that will be enabled by default in the next ghc versions?
08:32:39 <gtirloni> (i.e. a formal process)
08:34:52 <dickon> http://27bslash6.com/missy.html
08:35:04 <dickon> wrong channel, sorry
08:35:54 <EvanR-wo1k> mm_freak: if i remember correctly you were skeptical of LocalTime, well it looks like im about to use it in order to make my configurations compatible with mysql and csv files with 'amorphously defined' times in them
08:36:36 <EvanR-wo1k> the times are certainly not utc, and they have no time zone info associatd with them
08:36:55 <EvanR-wo1k> mysql does not record any time zone info
08:41:28 <_Mikey> home time!
08:43:59 <dmwit> gtirloni: Yes. See the Haskell' proposal process.
08:44:20 <dmwit> http://hackage.haskell.org/trac/haskell-prime/
08:44:35 <dmwit> (You can't search for Haskell', of course, you have to search for Haskell Prime.)
08:46:59 <gtirloni> dmwit: thank you!
08:54:58 <hpaste> KitB pasted “spans?” at http://hpaste.org/54114
08:59:15 * hackagebot timeplot 0.3.12 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.12 (EugeneKirpichov)
08:59:29 <dmwit> :t \p -> let (bs, es) = span p xs in zipWith (\b e -> (b, e ++ es)) (inits bs) (tails bs)
08:59:30 <lambdabot> Not in scope: `xs'
08:59:38 <dmwit> :t \p xs -> let (bs, es) = span p xs in zipWith (\b e -> (b, e ++ es)) (inits bs) (tails bs)
08:59:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [([a], [a])]
09:12:32 <mm_freak> EvanR-wo1k: no, there is nothing wrong with LocalTime…  it's just that it doesn't have as many use cases as one might think
09:14:22 <EvanR-wo1k> mm_freak: i cant think of any good ones, but im not in a good data situation
09:17:54 <Shin-LaC> if you need to correlate something with sunlight, bank opening times, human activity in general
09:23:49 <EvanR-wo1k> Shin-LaC: zoned time
09:38:41 <infogulch> hello everyone
09:39:19 <Guest12936> can someone tell me the positive and negative things about haskell
09:40:01 <Guest12936> and please do not give me something, biased :) Thank you
09:40:35 <Guest12936> am I even connected to this channel 0.o
09:40:46 <sp3ctum> you are
09:40:50 <Guest12936> oh ok lol
09:41:05 <Guest12936> this is a pretty quiet room :D
09:41:11 <alistra> positive: it's strogly typed, you're program has a low ppb that it'll fail at runtime
09:41:33 <yrlnry> ppb?
09:41:38 <Guest12936> what do you mean by strongly typed
09:41:40 <Cale> probability?
09:41:41 <yrlnry> parts per billion?
09:41:49 <sp3ctum> possipiliby
09:41:56 <alistra> negative: io is much more complicated than in other languages, lazyness sometimes has some quirks
09:42:01 <alistra> probability
09:42:04 <hydo> pointy perceptive buffoon!
09:42:06 <sp3ctum> :)
09:42:08 <EvanR-wo1k> io is not more complicated
09:42:10 <EvanR-wo1k> io is easier
09:42:12 <Cale> I don't actually agree about IO being more complicated at all
09:42:20 <Guest12936> yes why does the wiki page say that haskell is a lazy language?
09:42:23 <Cale> It's *different* from in other languages
09:42:44 <parcs> Guest12936: because it is a lazy language
09:42:58 <Guest12936> by IO do you guys mean Input/Output?
09:43:00 <EvanR-wo1k> negative: haskell doesnt easily let you make an addition operation which causes missiles to launch from a silo
09:43:04 <Cale> I'd say the main downsides for choosing Haskell for a new project if you don't already know it is that it is really different from other languages you probably know, and will thus involve an investment of time to learn.
09:43:17 <sp3ctum> Guest12936, it refers to how fields (variables) are accessed: they are only evaluated when they are needed
09:43:38 <Cale> (and I guess that's more than one downside because there's more than one aspect to being good at programming)
09:43:45 <sp3ctum> if they are not needed, they store some pointer only i guess
09:43:54 <Guest12936> is haskell the fastest functional language?
09:44:01 <EvanR-wo1k> sp3ctum: its pointers all the way down
09:44:03 <Cale> Guest12936: Languages don't have a speed
09:44:09 <Guest12936> oh ok thanks
09:44:26 <Cale> Language implementations produce better and worse code on various architectures.
09:44:31 <EvanR-wo1k> 'language speed' should not be your first criteria
09:44:31 <Cale> for various programs
09:44:33 <yrlnry> Is a Haskell program to calculate my taxes faster or slower than a Perl program to solve Sudoku puzzles?
09:44:42 <Cale> yrlnry: lol
09:44:52 <yrlnry> PLEASE ANSWER THIS ASAP IT IS VERY IMPORTANT
09:44:57 <sp3ctum> depends on the algorithms, the data size, the hardware, x, y
09:45:08 <Cale> Guest12936: But generally, GHC produces fairly decent code.
09:45:11 <Guest12936> can you make cool games with haskell and even do server programming for web dev?
09:45:17 <Cale> Guest12936: yes
09:45:18 <alistra> yes
09:45:31 <Cale> Haskell is general purpose
09:45:36 <Guest12936> are there any specific examples that you know of?
09:45:44 <EvanR-wo1k> lol cool games in haskell
09:45:48 <Cale> The things which are good about Haskell are things which tend to be good for any sort of program
09:46:02 <wlangstroth> what's the name of that that platform game ... ?
09:46:06 <alistra> Guest12936: web servers: snap, happstack, yesod
09:46:08 <EvanR-wo1k> mario
09:47:00 <brbbtb> newbie question: how can I load all functions and datatypes from multiple files into ghci? If I make :l *file1.hs *file2.hs only the functions of file1.hs are available in ghci ...
09:47:38 <Cale> Guest12936: There aren't yet many examples of games in Haskell, though you will probably want to see http://joyridelabs.de/game/
09:48:00 <Cale> Guest12936: and the company I'm working for is writing another one, but we don't have too much to show publically yet :)
09:48:37 <Cale> brbbtb: Have one module import the other? Or :m + ModuleName
09:48:52 <dbelange_> Shiny Marble Simulator 2012
09:48:59 <Cale> where ModuleName.hs is in the current directory and has  module ModuleName where  at the top
09:49:07 <wlangstroth> Guest12936: also, Snap, Yesod and Happstack for web dev
09:49:22 <Cale> dbelange_: heh, good name for a pinball game, I guess :)
09:49:34 <wlangstroth> (sorry, alistra just said that)
09:50:18 <Cale> http://haskell.org/haskellwiki/Frag -- this was an early proof of concept for games in Haskell
09:50:27 <brbbtb> Cale: I have file1.hs with module File1 where in the current directory, but :m File1 fails with "Could not find"
09:50:45 <Cale> brbbtb: Rename it to File1.hs
09:51:05 <Cale> (case probably matters on your system?)
09:51:21 <alistra> lol case doesn't matter on windows :3
09:51:35 <brbbtb> Cale: did that, doesn't work. An yeah, matters :) good old linux
09:52:57 <angstrom> what's a reasonable approach to use functions from Data.Text on regular Strings? e.g., `split' p xs = map unpack $ split p (pack xs)' seems kindof cumbersome..
09:52:58 <wlangstroth> Guest2917: depending on your definition of awesome, http://www.youtube.com/watch?v=AJQZg3Po-Ag
09:53:32 <Cale> angstrom: You'd have to convert them... Maybe there's a String or list version of the function you're using though.
09:54:02 <Cale> angstrom: I'm not sure what split p does, but there's probably a version of it in the split package on Hackage :)
09:54:45 <Cale> ah, okay, it's what I thought
09:55:11 <angstrom> Cale: ah. nice, regarding the split package :-)
09:55:15 <brbbtb> so, it doesn't work, I have no clue why. Neither with ghci -i.
09:55:26 <Cale> It's the same as splitWhen, apparently
09:56:22 <Cale> brbbtb: what are you seeing?
09:56:37 <Cale> You should be able to :m + File1  and then  :m + File2
09:56:40 <Cale> and have them both
09:56:51 <angstrom> Cale: but then again, I don't want to depend on a whole package just for a single function :\
09:57:01 <Cale> Or use  import File1  and  import File2  now, I'm kinda old-fashioned that way
09:57:37 <Cale> angstrom: Well, you'd kinda be doing so anyway, if you're not really using Text.
09:57:52 <rwbarton> Cale: wouldn't that only get you exported names in ghci
09:58:17 <rwbarton> oh he left anyways
09:58:18 <alistra> wow the nikki game even works out of the box for me
09:59:34 <Cale> alistra: :)
10:00:14 <alistra> the german interleaved with english on the page looks crappy though
10:00:56 <Cale> How so? Just visually?
10:01:15 <Cale> Or it's badly written German, I wouldn't know :)
10:02:02 <alistra> visually
10:02:05 <alistra> i want to read
10:02:10 <alistra> and suddenly german
10:02:22 <Cale> They have a Japanese language page which is separate, I'm not sure why they didn't separate the English and German ones.
10:04:38 <angstrom> alistra: the white dot is English, the two blue dots is the German translation?
10:06:17 <alistra> yeah but people read from top to bottom
10:06:28 <alistra> not from top to bottom with ommiting blue dots
10:09:04 <hpaste> wlangstroth pasted “splitWith” at http://hpaste.org/54117
10:09:29 <wlangstroth> angstrom: is that what you had in mind?
10:10:08 <rwbarton> ahaha, ghc is too clever for me.  I tried to measure the space used by a large expression by doing "let x = [large expression]; print x; print x".
10:10:09 <dmwit> uh... that looks a bit buggy
10:10:28 <dmwit> > let splitWith p xs = ys : splitWith p zs where (ys, zs) = break p xs in splitWith id [True, False, True, False]
10:10:29 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
10:10:30 <rwbarton> But ghc inlined the definition of print and then shared "show x".
10:12:05 <dmwit> rwbarton: cute =)
10:12:12 <dmwit> rwbarton: -fno-cse, maybe?
10:12:16 <wlangstroth> dmwit: fair enough
10:12:50 <rwbarton> dmwit: will try that
10:12:53 <rwbarton> Is there a better way to do this?
10:12:55 <dmwit> This is why you just go ahead and depend on another package. They already wrote and debugged the damn thing, why not take advantage of that? =)
10:13:46 <dmwit> rwbarton: print x; evaluate x?
10:13:59 <rwbarton> dmwit: anyways, that seems to have worked, thanks
10:14:04 <angstrom> dmwit: you can always copy/paste, though ;-P
10:14:25 <rwbarton> I seem to have found a performance bug/memory leak in Data.ByteString.sort
10:14:40 <dmwit> angstrom--
10:14:44 <angstrom> >:D
10:14:47 <dmwit> =P
10:17:06 <wlangstroth> also, the split package is actually pretty small
10:17:31 <rwbarton> it uses a counting sort for which it allocates an array of 256*sizeof(size_t) bytes with allocaArray
10:18:00 <rwbarton> and it appears as though that space is being retained somehow
10:22:21 <wlangstroth> dmwit: also, thanks for the help - I was playing around with that function, and I was hoping someone would tell me where I might have gone wrong
10:28:26 <dmwit> wlangstroth: Sure, you forgot to alternate between break and span.
10:29:25 <hpaste> rwbarton pasted “Data.ByteString.sort test” at http://hpaste.org/54118
10:30:05 <rwbarton> this is using 400 MB on my system, which is more than a little unreasonable
10:31:41 <wlangstroth> dmwit: Aha! Thank you. Much appreciated.
10:39:16 <dmwit> rwbarton: Out of curiosity, how much does it use without the sort?
10:41:39 * edwardk waves hello.
10:41:50 <rwbarton> something like 20M
10:41:53 <dmwit> o~
10:42:14 <dmwit> rwbarton: yow!
10:42:45 <rwbarton> 17 MB to be precise
10:50:03 <jabracy> I'm pretty new to haskell and trying to right a program that will merge 2 files. But I'm having an issue just reading 1 file. The file and error are here: https://gist.github.com/1370645
10:50:11 <jabracy> I know that I'm mixing the pure and impure
10:50:18 <jabracy> but can't figure out how to not do it
10:51:26 <Botje> you need to *do* something with the results of the foldr on line 13
10:52:10 <Botje> also, processFile file is an IO action, so you cannot use it with foldr/insert
10:52:19 <Cale> jabracy: The foldr constructs a Map from filenames to IO actions which if run, will process the files.
10:52:53 <Cale> jabracy: So you could do individual lookups in that map and run the corresponding actions to process the corresponding files, I guess.
10:53:18 <Cale> jabracy: But more likely, it's just not what you meant to do at all.
10:54:07 <Cale> jabracy: (also, since that foldr is not itself an IO action, it has no place being where it is as a statement of a do block)
10:55:45 <Cale> jabracy: Perhaps you just want to  rs <- mapM processFile files  and then  let m = Map.fromList (zip files rs)
10:56:04 <Cale> jabracy: or something like
10:56:13 <Cale> forM files $ \f -> do
10:56:19 <Cale>   r <- processFile f
10:56:24 <jabracy> ok, so I shouldn't be using the foldr, should it be recursive?
10:56:25 <Cale>   return (f,r)
10:56:35 <dmwit> foldr is recursive.
10:56:47 <Cale> foldr isn't explicitly recursive
10:57:12 <Cale> (as in, using foldr doesn't make your definition recursive)
10:57:22 <jabracy> what is the forM?
10:57:33 <jabracy> and mapM?
10:57:52 <Cale> jabracy: mapM :: (a -> IO b) -> [a] -> IO [b]
10:58:05 <Cale> and forM is just mapM with the arguments swapped
10:58:18 <Cale> (actually, they both have a more general type, but this will do)
10:58:40 <cedric_> hi, I am just trying Haskell on tryhaskell.org; how can I do mutually recursive types in the interpreter (if it is possible to do so, of course)?
10:58:46 <jabracy> ah! map with a Monad
10:58:58 <jabracy> ok, great, I think that is what I was looking for
10:58:59 <Cale> jabracy: Yeah, they work in any monad
10:59:10 <rwbarton> mapM f xs is the action that will execute f on each element of xs in turn and return a list of the results
10:59:15 <Cale> cedric_: hmm, I'm not sure what the tryhaskell.org interpreter is capable of
10:59:58 <cedric_> thanks, so I will wait the end of compilation of ghc
11:00:12 <Cale> cedric_: Defining new datatypes interactively in the interpreter is kind of an unusual thing to be doing in the first place... usually people will keep a file open in their text editor alongside ghci, and tap :r in ghci whenever they edit their definitions
11:00:25 <Cale> cedric_: Don't compile ghc yourself
11:00:42 <Cale> cedric_: Because if you can successfully compile ghc, it means you already have a working ghc, so there's no point.
11:00:45 <cedric_> why not? It is a FreeBSD port
11:00:54 <dmwit> cedric_: Do you really mean mutually recursive types, or just mutually recursive definitions?
11:01:18 <cedric_> There is a bootstrap system, I believe
11:01:28 <cedric_> types
11:01:48 <dmwit> cedric_: I don't think tryhaskell.org lets you define types at all, mutually recursive or otherwise.
11:01:49 <Cale> cedric_: Yeah, but you kinda have to be a GHC dev to get that to work, last I checked. Maybe they've automated it more.
11:02:23 <Cale> http://haskell.org/ghc/dist/7.0.3/ghc-7.0.3-x86_64-unknown-freebsd.tar.bz2 <-- use this package.
11:02:44 <Cale> http://haskell.org/ghc/download_ghc_7_0_4#freebsd <-- or one of these
11:02:52 <Cale> Or if you want 7.2...
11:03:02 <Cale> http://haskell.org/ghc/download_ghc_7_2_2#freebsd
11:03:40 <cedric_> ok, I will wait if my port fail, I'll try yours
11:03:58 <Cale> Those should be pretty much instantaneous to install
11:04:36 <Cale> Compiling GHC takes a very long time, and is kind of a waste of CPU effort if you're not hacking on it :P
11:06:06 <Cale> cedric_: The fact that the port is chugging away doing something probably means that you already have a working GHC installed :P
11:06:30 <Cale> (because otherwise, there's no way that GHC could be building itself)
11:06:35 <rwbarton> Maybe the port includes a GHC binary :P
11:06:43 <Cale> So it probably just went ahead and included a GHC binary
11:06:46 <Cale> yeah
11:07:03 <Cale> and installed that first, and then proceeded to waste your time by compiling the same thing again
11:19:28 <Philonous> cedric_:  The ghc ports are outdated, I'd use the binaries here: http://haskell.org/ghc/download_ghc_7_2_2#freebsd
11:19:39 <Philonous> Never mind, Cale beat me to it
11:20:11 <shachaf> Cale: What if you're not hacking on it but just want constraint kinds?
11:21:35 <Philonous> Cale:  The same argument could be used for almost all ports.
11:22:08 <shachaf> Philonous: Which argument? That you shouldn't build it from source unless you're hacking on it?
11:22:29 <shachaf> With GHC it's different because if you're building it from source, it means you already have a working GHC.
11:25:50 <shachaf> 
11:25:53 <shachaf> Er.
11:26:05 <shachaf> Please disregard previous two messages.
11:30:50 <duaneb> Hi, can someone help me with a type error?
11:30:56 <duaneb> My haskell skills are extremely rusty
11:31:04 <shachaf> duaneb: Not if you don't say what it is.
11:31:06 <duaneb> program here: https://gist.github.com/1371111
11:31:06 <prototrout> duaneb: Yes.
11:31:28 <shachaf> duaneb: You should say what the error is. :-)
11:32:35 <duaneb> gist updated with error :)
11:32:39 <prototrout> duaneb: randomWord8 = randomIO
11:32:55 <prototrout> is one problem I think
11:32:59 <prototrout> er, maybe not
11:34:44 <duaneb> I guess, I don't know why fromList (Z :. size) should be expected to have a type of IO (Array sh Word8)
11:34:54 <duaneb> I would expect it to have a type of Array sh Word8
11:34:55 <Cale> duaneb: one problem is that (randomListOfSize size) needs parens
11:35:03 <shachaf> duaneb: You probably need -- yes.
11:35:11 <Cale> (you're passing 3 parameters to liftM, when you want 2)
11:35:29 <Cale> another is that Z :. size looks really suspicious
11:35:39 <Cale> well, I need to look at repa again
11:35:44 <mm_freak> when using (| |) notation, is there any way to write a type signature for the input type?
11:36:12 <mm_freak> for implicit inputs that is
11:36:19 <duaneb> well I don't want the size of the resulting array to be variable on size
11:36:29 <duaneb> err, I do want that
11:36:30 <duaneb> haha
11:36:58 <Cale> duaneb: but that's not supposed to be a size, it's a shape...
11:37:09 <duaneb> Ah.
11:37:29 <Cale> Z means a Zero dimensional array
11:37:39 <Cale> which doesn't have a size...
11:37:54 <Cale> oh...
11:38:01 <Cale> actually, maybe this is okay
11:38:13 <Cale> because type DIM1 = DIM0 :. Int
11:38:29 <Cale> and :. is just a pair type with weird syntax
11:38:36 <Cale> and type DIM0 = Z
11:38:37 <shachaf> DIM ARR AS PIRATE
11:41:27 <mm_freak> given an arrow function:  f :: Arrow a => a b c -> a b c
11:41:40 <mm_freak> when writing (| f (…) |)
11:41:54 <mm_freak> does the input type 'b' in 'f' have to be fully polymorphic?
11:42:20 <mm_freak> i have an arrow function, which has an Eq constraint on the input type, and i can't get it to work with (| |) notation
11:45:11 <byorgey> mm_freak: what is (| ... |) notation?
11:45:25 <duaneb> I guess I'm just wondering, what does this mean: "Could not deduce (sh ~ (Z :. Int))     from the context (Shape sh)"
11:45:30 <duaneb> I don't understand the notation used
11:45:50 <mm_freak> byorgey: instead of writing:  f (proc (a, b, c) -> …) -< (a, b, c)
11:46:02 <mm_freak> you can write:  (| f … |)
11:46:10 <shachaf> duaneb: t ~ u means that two types are the same type.
11:46:18 <duaneb> ahh
11:46:33 <duaneb> ok, I guess I just passed in DIM1 to the type and it compiled
11:47:18 <mm_freak> byorgey: it saves you from having to pass the inputs explicitly…  (| |) takes care of that for you
11:47:50 <mike-burns> Is that a banana?
11:47:58 <mm_freak> yeah =)
11:48:17 <mm_freak> i call it the banana bracket notation
11:48:21 <byorgey> mm_freak: neat.  where is that defined? is it in GHC?
11:48:32 <mm_freak> byorgey: yes, see the arrow notation manual
11:48:38 <mm_freak> section 7.10
11:48:57 <byorgey> cool, didn't know about that
11:49:55 <mm_freak> byorgey: it goes further
11:50:14 <mm_freak> f :: Arrow a => a (b, i) c -> a b c
11:50:34 <mm_freak> then you can write:  (| f |) myValueOfTypeI
11:50:43 <mm_freak> ah, no
11:50:52 <mm_freak> f :: Arrow a => a b c -> a (b, i) c
11:50:58 <mm_freak> in this case you can do that
11:51:07 <mm_freak> in the other case you can use arrow lambda notation
11:51:24 <mm_freak> (| f (\myValueOfTypeI -> …) |)
11:53:22 <mm_freak> byorgey: for example in netwire i have this (simplified):  sample :: Wire a b -> Wire (a, Time) b
11:53:46 <mm_freak> now i can write:  t <- (| sample (time -< ()) |) 1
11:53:53 <mm_freak> that gives me a clock, which is updated every second
12:10:21 <duaneb> So I have a c library that calls into haskell. How can I have mutable state across those callbacks?
12:10:59 <duaneb> The callbacks have the type Context—which is for all purposes immutable—in Context -> IO ()
12:11:39 <c_wraith> have the callbacks close over an IORef?
12:12:08 <c_wraith> I mean..  You're in IO.  mutable state shouldn't be a problem
12:12:18 <duaneb> Yea, I'm new to haskell :P
12:12:44 <duaneb> I was under the impression that because the callbacks have the type Context -> IO (), I can't return anything but ()
12:12:45 <shachaf> duaneb: You should probably learn how mutable state works in Haskell in general before calling Haskell from C. :-)
12:13:03 <shachaf> What callbacks are you talking about?
12:13:08 <duaneb> shachaf: what better way to learn it?
12:13:41 <rwbarton> well, do you know about IORefs?
12:14:00 <shachaf> duaneb: Using pure Haskell for a while?
12:14:09 <shachaf> FFI is just another annoyance on top.
12:14:23 <duaneb> well, I guess, my real question is: In a function returning IO (), can I use IORefs?
12:14:40 <shachaf> Any IO action can use IORefs.
12:15:46 <rwbarton> either make sure the IORef is in scope when you define the callback, or stuff it into the Context somehow
12:15:54 <c_wraith> http://hpaste.org/54120 is an amusing IORef example
12:16:41 <shachaf> c_wraith: Hmm, is that a bug in hlint?
12:16:46 <c_wraith> yes it is!
12:16:59 <dmwit> No it's not.
12:17:18 <duaneb> ok, and how do I intialize a Ptr to being a NULL pointer?
12:17:26 <dmwit> That is a perfectly cromulent transformation, thanks to the monad laws.
12:17:28 <rwbarton> @type nullPtr
12:17:29 <lambdabot> Not in scope: `nullPtr'
12:17:33 <c_wraith> dmwit: no, it's not
12:17:35 <rwbarton> @hoogle nullPtr
12:17:35 <lambdabot> Foreign.Ptr nullPtr :: Ptr a
12:17:40 <dmwit> c_wraith: Yes, it is.
12:17:42 <dmwit> ?src join
12:17:42 <lambdabot> join x =  x >>= id
12:17:47 <c_wraith> dmwit: if it was talking about line 17, it would be correct
12:17:47 <hasker> Is there a web interface to lambdabot sorta like tryhaskell? Just curious
12:17:52 <c_wraith> dmwit: but it's talking about line 12
12:17:53 <dmwit> ?undo do { counter2 <- makeCounter; counter2 }
12:17:54 <lambdabot> makeCounter >>= \ counter2 -> counter2
12:17:57 <c_wraith> dmwit: and it's wrong on line 12
12:18:03 <rwbarton> ?
12:18:14 <rwbarton> it's not very specific about location, true
12:18:18 <dmwit> c_wraith: It's talking about the do-block that begins on line 12, but the actual suggested transformation changes line 17.
12:18:25 <jabracy> vim /etc/security/
12:18:28 <c_wraith> yes, lines 17 and 18 could be made a join
12:18:40 <c_wraith> but when it says the mistake is on 12, that's a bug
12:18:44 <jabracy> jk, ignore that :)
12:18:45 <dmwit> Oh, fine.
12:18:54 <shachaf> Oh, 17 and 18. But it's saying 12.
12:19:02 <shachaf> Ah.
12:19:21 <rwbarton> so you're saying it's telling us to replace the "d" in "do" with a join? :P
12:19:39 <c_wraith> rwbarton: well, that's what it says!
12:19:55 <rwbarton> well, no it's not! etc.
12:19:59 <shachaf> Does this example not print 0,1,2,0,3?
12:20:11 <c_wraith> yes, it does
12:20:14 <rwbarton> sigh
12:20:19 <dmwit> It probably prints 1,2,3,1,4
12:20:20 <rwbarton> oh oops, sorry
12:20:30 <dmwit> err
12:20:33 <c_wraith> rwbarton: was answering shachaf's question, not trying to annoy you :)
12:20:37 <dmwit> Yes, it starts from 0.
12:21:09 <rwbarton> what it's reporting is the location of the expression that can be simplified
12:21:15 <dmwit> rwbarton++
12:22:37 <hiptobecubic> What's happening in this line?      'newtype State s a = State { runState :: (s -> (a,s)) }'
12:22:49 <c_wraith> hiptobecubic: it's declaring a newtype using record syntax
12:23:05 <c_wraith> hiptobecubic: in this case, it declares a constructor, State, and a destructor, runState
12:23:23 <hiptobecubic> hm
12:23:52 <dmwit> hiptobecubic: That declares an isomorphism between the types "State s a" (which coincidentally didn't exist until this line did) and "s -> (a,s)" witnessed by "State :: (s -> (a,s)) -> State s a" and "runState :: State s a -> (s -> (a,s))".
12:25:38 <hiptobecubic> runState is a mapping from s to the tuple (a,s)
12:26:04 <dmwit> runState is a destructor which takes a State s a and returns a mapping from s to the tuple (a,s).
12:26:11 <hiptobecubic> hm
12:26:24 <hiptobecubic> it returns the mapping, unevaluated?
12:26:29 <dmwit> Yes.
12:26:45 <dmwit> I guess I'm not sure what you mean by "unevaluated", actually.
12:26:53 <hiptobecubic> I'm probably not either.
12:26:54 <c_wraith> it returns a function
12:27:16 <hiptobecubic> What would be done with this thing then?
12:27:24 <c_wraith> by itself, it's not all that useful.
12:27:44 <c_wraith> But the thing that makes it useful are helper functions like get, put, and modify
12:27:55 <c_wraith> and the monad instance for the type
12:28:41 <c_wraith> Those, in combination, let you compose smaller functions that work with "state" into larger functions.
12:28:58 <c_wraith> So you can put together something that looks somewhat like iterative code for mutating local state
12:29:24 <c_wraith> But it's actually just assembling a giant function underneath that does works via explicit state-passing, rather than mutation
12:29:29 <c_wraith> -does
12:29:36 <hiptobecubic> I have a feeling this is the same concept that i didn't grok in the 'roll your own irc bot' tut
12:30:09 <dmwit> hiptobecubic: You can think of a function whose type matches "s -> (a,s)" as being a thing which uses some local state of type "s", perhaps updating it, to produce a value of type "a". It turns out this is a monad. Unfortunately, for some variously silly reasons, we can't just declare an instance Monad (s -> (a,s)); the "newtype" thing is just a trick that lets us declare the instance.
12:30:52 <dmwit> You should think of things of type "State s a" as *actually being* functions of type "s -> (a,s)", but with a bit of annoying extra syntax that gives the compiler some hints about how to handle those functions.
12:31:24 <dmwit> (At runtime, values of type "State s a" really are functions of type "s -> (a,s)", so don't worry that you're making an inaccurate mental model this way!)
12:32:20 <dmwit> ?google meet the monads
12:32:21 <lambdabot> http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
12:32:22 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki
12:32:26 <dmwit> ick
12:32:27 <c_wraith> also, if you don't completely understand, it's ok
12:32:29 <hiptobecubic> so if "State s a" is the mapping "s -> (a,s)", what the hell is runState for :D
12:32:42 <c_wraith> runState just removes the newtype wrapper
12:32:50 <dmwit> hiptobecubic: "runState" tells the compiler to stop treating the value as a "State s a" and start treating it as a function.
12:33:07 <dmwit> hiptobecubic: And "State" tells the compiler to stop treating a function as a function and start treating it as a "State s a".
12:33:14 <hiptobecubic> c_wraith, it's not ok. this is THE thing i've been failing to 'get' for quite literally months. I intend to get it eventually. :)
12:34:02 <dmwit> Huh, "All About Monads" (and the excellent section therein titled "Meet the Monads") seems to have disappeared from the web.
12:34:10 <rwbarton> On the line 'newtype State s a = State { runState :: (s -> (a,s)) }' itself, there is almost nothing to "get".
12:35:10 <dmwit> hiptobecubic: The only difference between "State s a" and "s -> (a,s)" is that *they have different types*. This is super handy for writing class instances.
12:35:19 <hiptobecubic> hmm
12:35:42 <dmwit> hiptobecubic: ...but it's super annoying for using, since you can apply functions to arguments, but you can't apply "State s a"s to arguments.
12:35:47 <KSkrzet> hi, I have a question about sharing. I have a two functions foo1, foo2, that looks like this:
12:35:52 <KSkrzet> foo1 = do { let bigList = [0..10^6] }; print bigList
12:35:53 <KSkrzet> foo2 = do { let bigList = [0 .. 10^6]; mapM_ print bigList }
12:35:58 <dmwit> hiptobecubic: So you want a way to convert between the two different types. "State" and "runState" are the conversion functions.
12:36:02 <byorgey> equality: way more complicated than you think.
12:36:06 <KSkrzet> main = foo1 >> foo2
12:36:10 <hiptobecubic> dmwit, so you have to runState (State s a) s1 a1 ?
12:36:12 <dylex> in many newtypes, runState would instead be called "unState", e.g. newtype MyInt = MyInt { unMyInt :: Int }.  I've always worried it was confusing for OO people to call these "destructors".
12:36:20 <KSkrzet> is compiler allowed to share bigList among foo1 and foo2?
12:36:21 <dmwit> hiptobecubic: err...
12:36:29 <hiptobecubic> dmwit, so you have to runState (State s a) $ s1 a1 ?
12:36:30 <dmwit> hiptobecubic: "State s a" isn't a value.
12:36:49 <hiptobecubic> dmwit, well if s and a had values and you construct the State right there anonymously?
12:36:50 <dmwit> hiptobecubic: "State (\s -> (3,s))" would be a value of type "State s Int", for example.
12:36:50 <byorgey> hiptobecubic: you have the right idea, but what you have literally written does not make sense
12:36:55 <rwbarton> KSkrzet: there are no guarantees in the language spec about sharing or lack of sharing, and in practice GHC might share them
12:37:24 <dmwit> hiptobecubic: Remember, "State s a" really is a function "s -> (a,s)" under the hood -- so if what you're applying the "State" value constructor to doesn't look like a function, you're in trouble!
12:37:24 <hiptobecubic> s and a are types? in 'State s a' ?
12:37:40 <dmwit> hiptobecubic: Yes.
12:37:52 <hiptobecubic> as in "State Int String" ?
12:37:56 <dmwit> hiptobecubic: One thing that's a bit confusing here is that State lives in two different namespaces: the type namespace and the expression namespace.
12:38:26 <dmwit> Inventing some syntax, we could write State%Type and State%Expr to differentiate them for now.
12:39:04 <hiptobecubic> dmwit, ok
12:39:10 <dmwit> So "State%Type Int String" is a perfectly cromulent type, and "State%Expr (\s -> (3,s))" is a perfectly cromulent expression.
12:39:12 <hiptobecubic> "State%type Int String" ?
12:39:16 <dmwit> right
12:39:26 <hiptobecubic> ok
12:39:42 <hiptobecubic> cromulence is important here.
12:40:06 <mdempsky> State<Int, String>
12:40:18 <dmwit> =)
12:40:21 <tswett> Agda is a Haskell library, right?
12:40:44 <dmwit> tswett: (Not sure if that's a joke or a legitimate question...?)
12:40:46 <rwbarton> it's a program written in Haskell
12:40:48 <byorgey> tswett: Agda is a programming language implemented in Haskell
12:42:01 <dmwit> hiptobecubic: Ask us more questions. =)
12:42:18 <hiptobecubic> i'm reading about bob and his lovers
12:42:19 <tswett> I should ask that question better.
12:42:24 <hiptobecubic> or is bob the lover?
12:42:31 <hiptobecubic> and the beloveds are the other people?
12:42:36 <dmwit> Bob?
12:42:47 <hiptobecubic> http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
12:42:58 <dmwit> Oh, the result of my Google search?
12:42:58 <tswett> It's easy to link a Haskell program with Agda, right?  Just download it and say "import".
12:43:10 <dmwit> I was looking for something else. I can't vouch for the quality of that one.
12:43:24 <hiptobecubic> well it's entertaining at least
12:43:47 <dmwit> tswett: I think Agda has an FFI to Haskell. Don't know that it's as easy as "import", though.
12:44:15 <tswett> And by "link a Haskell program with Agda", I mean with Agda itself, not with an Agda program.
12:44:27 <dmwit> oh
12:45:16 <byorgey> hiptobecubic, dmwit: I can vouch for the quality of that one. the quality is poor.
12:45:37 <byorgey> I recommend not reading it, even if it is amusing.
12:45:37 <hiptobecubic> there's a lot of innuendo and not a lot of 'what the hell is going on here'
12:47:13 <hiptobecubic> dmwit, http://groups.google.com/group/haskell-cafe/browse_thread/thread/6beafe5cfd9d0dd3
12:48:14 <byorgey> tswett: oh, in that case, yes
12:49:49 <hiptobecubic> i think i found it
12:50:00 <hiptobecubic> http://www.exactas.org/modules/UpDownload/store_folder/1_-_COMPUTACION/All_About_Monads.pdf
12:56:24 <eulyix> Hi, Cabal has installed the QuickCheck library into /usr/local/lib, but ghci seems to only look for libraries in the CWD, how can I get around that? Thanks.
12:56:44 <decaf> is it normal that ghc recognizes my system as i386-unknown-linux ?
12:57:05 <dcoutts> decaf: if it's x86 not x86-64 then yes
12:57:13 <hiptobecubic> decaf, that's what was given to configure when ghc was built, i think
12:57:31 <dcoutts> eulyix: actually it uses ghc-pkg to know what packages are registered
12:57:36 <decaf> it's an i686-linux-gnu specifically
12:57:49 <dcoutts> eulyix: if ghc-pkg list knows about the library then it's ok, otherwise it's not registered
12:58:11 <hiptobecubic> this all about monads thing has a link in it to 'a physical analogy of a monad' which i am dying to see but it doesn't work
12:58:11 <dcoutts> eulyix: doesn't matter so much where the lib files are, the ghc-pkg db points to wherever they live
12:58:24 <eulyix> Thanks, I'll investigate this.
12:58:36 <dcoutts> decaf: that gets "normalised" to i386-unknown-linux
12:58:49 <decaf> ok thank you
12:59:10 <hiptobecubic> dmwit, http://monads.haskell.cz/html/meet.html  is this what you were googling for?
13:00:13 <byorgey> eulyix: can you tell us exactly what you are doing, what you expect to happen, and what happens instead?
13:00:15 <eulyix> Hmm, QuickCheck-2.4.1.1 show up from ghc-pkg list
13:01:11 <eulyix> byorgey: I have a .hs file with import QuickCheck, I just want to make sure I can load the library. ghci says "Could not find module `QuickCheck' when I load my file in.
13:01:30 <byorgey> eulyix: there is no module called QuickCheck.
13:01:50 <byorgey> eulyix: see here for a list of modules that QuickCheck exports: http://hackage.haskell.org/package/QuickCheck
13:01:59 <byorgey> eulyix: you probably want to say  import Test.QuickCheck
13:02:46 <eulyix> Oh, silly me. Thank you, it works now.
13:05:19 <dmwit> hiptobecubic: Yes!
13:05:29 <dmwit> hiptobecubic: That's an excellent guide.
13:05:48 <hiptobecubic> i'm reading the 'physical analogy' part with the chopstick-making assembly line
13:05:51 <hiptobecubic> http://monads.haskell.cz/html/analogy.html
13:05:55 <dmwit> hiptobecubic: Jump to http://monads.haskell.cz/html/statemonad.html for the best help. =)
13:07:35 <tgeeky> So, on Bird Chapter 5: Sorting Pairwise Sums.
13:07:35 <hiptobecubic> dmwit, this is making it very apparenty that i had no idea what 'do' meant
13:08:09 <tgeeky> He starts with: "Let A be osme linearly ordered set and ((+)) :: A -> A -> A some monotonic binary operation on A ...     sortsums :: [A] -> [A] -> [A]
13:09:09 <tgeeky> and he never actually supplies any other specification for A
13:09:12 <tgeeky> what should I think to do?
13:09:36 <edwardk> tgeeky: what do you mean?
13:10:04 <tgeeky> edwardk: I mean, if I need to supply (or locate, in standard libraries) an appropriate (type, newtype, data) decleration to make it compile
13:10:13 <edwardk> tgeeky: the binary operation preserves inequality, its an ordered semigroup
13:10:19 <hiptobecubic> This is pretty entertaining as well, really.
13:10:27 <edwardk> so you just make a class for that and parameterize the rest of your code on it
13:10:50 <edwardk> class (Ord a, Semigroup a) => OrderedSemigroup a
13:10:53 <tgeeky> edwardk: so my first thought should have been -- I need a typeclass
13:10:58 <edwardk> yep
13:11:08 <tgeeky> if I didn't actually care about the Ord constraint yet
13:11:14 <tgeeky> my first thought still should have been typeclass?
13:12:13 <edwardk> well, you need an operation on A. so your options are to pick a priori some particular type A you want to work with, or you can make a class that describes the operation (circle_plus) that he uses and which provides the (<=) he also uses
13:12:39 <edwardk> the latter is the more general approach and helps ensure that you don't accidentally depend on the details of your chosen example
13:13:34 <ColonelJ> [21:26] <qx> i think even haskell people acknowledge lazy by default is a bad thing   <<< help me!
13:13:36 <tgeeky> sensible, thank you.
13:14:02 <ColonelJ> if you think laziness is awesome by default let me know
13:14:07 <edwardk> and since you need an OrderedGroup for lambert's algorithm, you might as well then make the subclass of OrderedSemigroup that adds the group operations as you go through the rest of the article ;)
13:15:57 <roconnor> edwardk: any thoughts on the relationship between reprsentable functors and W-Types?
13:16:19 <edwardk> not off hand
13:16:53 <roconnor> ok
13:16:55 <edwardk> i really don't have a good intuition for them
13:17:02 <DanBurton> random question: which incurs a greater cost to speed and/or space? Existential Quantification or using GADTs to accomplish the same?
13:17:20 <edwardk> DanBurton: they use the same in ghc
13:17:42 <edwardk> DanBurton: in theory you could make existentials lighter weight though
13:17:46 <tgeeky> roconnor: Do you know of examples of usage of multiplate other than yours and Sjoerd's two examples (1-to-1 structure, ZigZag structure)?
13:18:47 <edwardk> i've wanted newtyped existentials for a long time to make things like colimits that don't pick up an extra bottom, etc.
13:19:11 <roconnor> tgeeky: nope
13:19:24 <tgeeky> roconnor: also, it looks like nobody has ever tried composition of multiplates?
13:19:31 <tgeeky> even though you laid the framework
13:19:33 <roconnor> I'm not aware of Sjoerd's examples
13:19:39 <tgeeky> oh.
13:19:42 <tgeeky> i can link them, if you wish.
13:19:47 <roconnor> sure
13:20:42 <tgeeky> ZigZag: https://gist.github.com/1256281    1-to-1: https://gist.github.com/707890
13:20:54 <roconnor> ya, I guess multiplates ought to be composable
13:20:54 <ColonelJ> when is laziness bad?
13:20:57 <tgeeky> roconnor: and here's something about W-types that he did, in his gists https://gist.github.com/763402
13:21:34 <tgeeky> ColonelJ: laziness/strictness is just a tradeoff that exists in the computational universe.
13:21:46 <tgeeky> ColonelJ: both of them can be good and bad in the same problem
13:21:56 <ColonelJ> *why is laziness a bad default?
13:22:08 <roconnor> it isn't
13:23:46 <tgeeky> roconnor: let me know if you have any thoughts about his examples. The 1-to-1 example is linked from haskellwiki, the other I just found.
13:23:59 <DanBurton> edwardk: I just quoted you on that in a SO comment
13:24:21 <edwardk> DanBurton: newtyped existentials?
13:24:25 <DanBurton> the thing before
13:24:31 <DanBurton> newtyped existentials would be nice though
13:24:33 <DanBurton> I agree
13:24:54 <wlangstroth> ColonelJ: like tgeeky said, trade-offs. "Good" and "bad" probably aren't the right adjectives.
13:24:57 <roconnor> tgeeky: Oh interesting; ZigZag is a non-uniform recursive type
13:25:15 <DanBurton> is there a ghc ticket open for that?
13:25:54 <roconnor> tgeeky: oh I think I've seen 1-1 before; it is his example of how to make a plate on a per-constructor basis rather than a per type basis.
13:27:11 <roconnor> tgeeky: I think someone else was using Multiplate
13:27:25 <tgeeky> roconnor: there are the guys who are doing Javascript stuff with it
13:27:43 <tgeeky> PLOhttp://hackage.haskell.org/package/WebBits-multiplate-0.0.0.1
13:27:45 <DanBurton> interesting discussion about newtyped existentials that I googled up: http://stackoverflow.com/questions/5890094/is-there-a-way-to-define-an-existentially-quantified-newtype-in-ghc-haskell
13:28:29 <roconnor> tgeeky: that could be what I'm thinking of
13:29:32 <roconnor> even I don't use multiplate;  I have some basterdized version of it in ocaml since I'm not ocaml33t enough to use the module system to recreate it properly
13:29:41 <tgeeky> hehe :(
13:30:02 <roconnor> Multiplate-Simplified is a nice touch
13:30:12 <tgeeky> I didn't really get the point
13:30:16 <roconnor> it will probably be useful in most common situations
13:30:18 <tgeeky> other than it helps you write some instances?
13:30:47 <tgeeky> roconnor: is the zigzag datatype something like type-level integers?
13:30:52 <roconnor> I guess that is about all it does
13:31:08 <roconnor> tgeeky: I don't think so
13:31:57 <DanBurton> Answering my own question, found this closed ghc ticket: http://hackage.haskell.org/trac/ghc/ticket/1965
13:32:32 <tgeeky> roconnor: the only other meaningful link to 'zigzag' I found was some JPEG compression thing, and I didn't assume it was related
13:33:02 <roconnor> tgeeky: zigzag looks like simply a test case for applications to non-uniform recursive types
13:33:53 <roconnor> though it is very simple
13:34:05 <roconnor> I double it would extend to more complex uses of non-uniform recursion
13:34:17 <tgeeky> doubt*?
13:34:23 * hackagebot type-unary 0.1.8 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.8 (ConalElliott)
13:34:54 <roconnor> *doubt
13:35:09 <roconnor> edwardk: is there some collection of reprenstable instances somewhere?
13:35:21 <hiptobecubic> dmwit, mplus and mzero are kind of strange
13:35:24 <gwern> sanity check please: for someone to be 150 in 2085, that means they are already 76 years old (2011 (2085 - 150))
13:35:35 <edwardk> i'll happily take patches for representable-functors ;)
13:35:54 <aristid> > 2085 - 150
13:35:55 <lambdabot>   1935
13:36:00 <aristid> > 2011 - 1935
13:36:01 <lambdabot>   76
13:36:16 <gwern> * (2011 - (2085 - 150))
13:36:40 <roconnor> gwern: I can barely compute how old I am
13:36:53 <gwern> roconnor: wow, you're that old? well, try knuth's up-arrow notation
13:37:43 <roconnor> I'm so old my age is indisinguishable from a Martin-Loef random number. <hi-hat/>
13:38:49 <roconnor> edwardk: not even (Representable f, Representable g) => Representable (f,g) ?
13:39:08 <bog3yman> can anyone help me with haskell :(
13:39:15 <roconnor> oh wait I see it now
13:39:18 <roconnor> it is product
13:39:25 <edwardk> there is Product
13:39:25 <edwardk> yeah
13:39:26 <roconnor> because, duh, they are functors, not data
13:39:40 <edwardk> You're thinking HasTrie
13:39:43 <edwardk> for the other way around
13:39:51 <edwardk> there should be a HasTrie for (a,b)
13:40:01 <edwardk> but thats stronger that 'is a representation for some functor'
13:40:23 <bog3yman> if someone can help me with a haskell question which involves zf expressions + recursion plz PM me!! would be much appreciated
13:40:47 <roconnor> edwardk: I was actually trying to think of scalar multiplication
13:40:58 <edwardk> any other standardish types that you're thinking of that are missing from that module?
13:41:04 * roconnor isn't entirely sure when type theory turned into linear algebra
13:41:31 <roconnor> edwardk: is (Constant f) representable?
13:42:02 <roconnor> well, (Constant a)
13:42:34 <roconnor> probably not
13:42:36 <edwardk> newtype Const a b = Const a ?
13:42:41 <roconnor> ya
13:42:46 <edwardk> where does the 'a' come from?
13:42:54 <wlangstroth> bog3yman: you can just ask the question
13:42:56 <roconnor> I was thinking a is any type
13:43:13 <roconnor> but I guess a isn't isomorphic to key -> b for any key in general.
13:43:22 <edwardk> what i mean is i can't generate it by tabulating any sort of (Key f -> b) function at all
13:43:29 <edwardk> yeah
13:43:44 <edwardk> you could make a data Trivial a = Trivial
13:43:55 <edwardk> and make that have Key f = Void
13:44:10 <roconnor> Maybe these W-types are less related to representable types than I thought
13:44:13 <edwardk> that is the only one i can think of off hand that is missing
13:44:44 <edwardk> or maybe a coproduct
13:46:07 <roconnor> ... But the (S -> Type) in W :: (S: Type) -> (S -> Type)  -> Type  looks a lot like a representable functor.
13:46:35 <bog3yman> Ok if anyone can help me... it might be a long read for the problem but... I'm trying to create a function which given an integer will return all the "integer partitions" (i.e. all the combinations of numbers which when summed up will equal the given integer) .. so given 3, it will return [[1,1,1],[1,2],[3,]].. I can see the pattern to solve it which involves recursion and zf expressions (which I can describe to you) but I'm having
13:47:01 <tgeeky> bog3yman: you just want the partition function?
13:47:15 <rwbarton> bog3yman: your message got cut off after "but I'm having"
13:47:36 <bog3yman> hmm partition function o.0 never heard of it still a beginner at haskell
13:47:45 <tgeeky> bog3yman: it's a mathematical function.
13:47:51 <edwardk> i can't tabulate coproduct. nevermind
13:47:51 <rwbarton> he wants the list of partitions
13:47:55 <edwardk> the only one i'm missing is trivial =)
13:47:56 <bog3yman> *but I'm having trouble implementing it.. so please contact me if you can help! can show you what i've got so far
13:48:06 <tgeeky> oh, the partition function is the number of them
13:48:15 <edwardk> but that lacks a standard name
13:48:21 <edwardk> hence the lack of instance
13:48:33 <tgeeky> http://en.wikipedia.org/wiki/Partition_function_(number_theory)#Partition_function <-- that gives you the number of partitions
13:49:45 <bog3yman> yup thats what im tryna do tgeeky, but the function im creating actually needs to produce the actual partitions which make up an integer
13:50:03 <bog3yman> i can see a blatant pattern for the integers..
13:50:05 <edwardk> roconnor: not sure i see what you're seeing there
13:50:07 <roconnor> @where TTFP
13:50:07 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
13:50:28 <DanBurton> bog3yman: put it up on http://hpaste.org/new/haskell and we can all take a look
13:50:37 <tgeeky> bog3yman: yes, though it is more subtle than you'd think - Ken Ono (and others) just proved a (closed form) algebraic formula for it
13:50:41 <roconnor> edwardk: probably nothing;  I was thinking that a W-Type is a contain of recursive values of W-Type
13:50:50 <_Mikey> what DanBurton said.
13:50:50 <roconnor> *is a contaner
13:51:01 <bog3yman>  thanks danburton i'll post my solutions and thoughts on that  webpage
13:51:25 * DanBurton will forever preach the virtues of hpaste, hlint, hoogle, LYAH, RWH, and typeclassopedia
13:51:41 <edwardk> roconnor: well i don't have any fixed-point-like representable instances
13:51:50 <edwardk> so perhaps that is what you are looking for?
13:52:03 <tgeeky> bog3yman: may I suggest the species package
13:52:09 <edwardk> something like the (co)free store comonad
13:52:52 <bog3yman> hmm tgeeky i think that's a bit too complicated as i'm still a beginner at haskell lol.. sec lemme just paste my code and i'll show you whats happening
13:58:10 <hpaste> tgeeky pasted “partition function” at http://hpaste.org/54124
13:58:12 <mreh> is there a strategy for multiple instances of a Monad* type class in a tranformer stack?
13:58:22 <mreh> like two Writers
13:59:00 <tgeeky> bog3yman: there are some examples using species
13:59:29 <tgeeky> actually, I think that's *set* partitions
13:59:32 <hpaste> parcs pasted “impossible” at http://hpaste.org/54125
13:59:38 <tswett> Does Happstack actually offer a way to store data on disk in a kind of database-like way?
13:59:53 <parcs_> can anyone confirm that the above paste segfaults ghci?
13:59:57 <tswett> I see it has MACID, but MACID isn't very D.
14:00:05 <mreh> tswett: D?
14:00:09 <wlangstroth> durable
14:00:16 <parcs_> oops, not segfaults, but causes it to report ' the impossible happened?'
14:00:26 <wlangstroth> tswett: acid-state?
14:00:43 <tgeeky> parcs_: nope
14:00:44 <mreh> acid-state is supposed to be MACID too
14:01:06 <parcs_> tgeeky: what ghc version are you using?
14:01:09 <tgeeky> 7.2.1
14:01:11 <tswett> An in-memory data store presumably loses the data when the server is turned off.  But... possibly not?
14:01:12 <parcs_> o
14:01:16 <mreh> it's rewrite of the Happstack acid stuff
14:01:27 <parcs_> okay, look's like a 7.x thing then
14:01:32 <mreh> tswett: nah, both use a transaction log I recall
14:01:35 <shachaf> tswett: It does?
14:01:37 <hpaste> tgeeky annotated “impossible” with “impossible (annotation)” at http://hpaste.org/54125#a54126
14:01:41 <shachaf> I thought the point of it was that it didn't.
14:01:52 <tswett> I guess I don't actually know what "in-memory" means.
14:01:55 <mreh> basically it writes all the functions performed on the database and applies them when it recovers from a crash
14:02:12 <parcs_> 7.0.x* :P
14:02:18 <tgeeky> parcs_: :)
14:02:19 <mreh> or when it's told to create a "checkpoint"
14:02:41 <tgeeky> parcs_: did you ever get "eager write to history in ghci" thing to work?
14:02:49 <wlangstroth> and the writes are asynchronous (or so says the readme)
14:02:51 <tgeeky> parcs_: testing stream functions in Windows is a disaster.
14:03:10 <hpaste> bog3yman pasted “bog3yman” at http://hpaste.org/54127
14:03:16 <tswett> What's the difference between MACID and plain old ACID?
14:03:23 <mreh> the M
14:03:31 <tswett> Yes, and what does that M signify?
14:03:55 <mreh> monadic
14:04:07 <mreh> this is haskell
14:04:24 <tswett> Huh, this other thing says that it means "in-memory".
14:04:36 <mreh> really? :)
14:04:53 <tswett> In any case, the idea I'm getting is that MACID still writes the data to disk, just like the SQL databases I'm used to.  Is that right?
14:04:55 * DanBurton would've expected HACID
14:05:12 <shachaf> tswett: As far as I understand it logs transactions to disk, yes.
14:05:17 <shachaf> Otherwise it wouldn't be very durable.
14:05:29 <mreh> DanBurton: that would never make it past the marketing committee
14:05:38 <bog3yman> if anyone can check out my integer partition code and see if they can fix it lol! http://hpaste.org/54127
14:06:08 <bog3yman> also regarding my code, i know that my algorithm (when it works) will have duplicates, but i'll sort that out afterwards!
14:06:11 <mreh> is anyone else completely baffled by digestive functors, I was so confused that I started writing my own library for html forms
14:06:32 <mreh> they are so abstract it makes my head hurt
14:06:36 <tswett> I guess I got thrown for a loop, then.  Thank you all for setting me straight.
14:06:39 <mreh> digestive-functors
14:06:47 <_Mikey> DanBurton, I'm down with all of those except... typeclassopedia?
14:07:00 <rwbarton> bog3yman, what do you mean when you write in your program "a:func(x-a)"
14:08:45 <bog3yman> you see what a is [1..(n-1)].. i wanted it so a (1 in the first case) will be inserted to the front of every single list which is generated by func (n-1) ... and then through recursion.. 2 will be inserted infront of every list generated by func (n-2)
14:08:51 <hiptobecubic> (\ x -> 1) is preferred over (\x -> 1) ?
14:08:53 <bog3yman> hope you understand... recursion is still very confusing to me!
14:09:26 <bog3yman> (also i'm actually missing a result for func 4 [2,2] should be one of the solutions as well)
14:10:11 <Cale> bog3yman: you want to use map then
14:10:28 <Cale> > map reverse ["here", "are", "some", "strings"]
14:10:29 <rwbarton> bog3yman: right, do you understand why what you wrote isn't that
14:10:29 <lambdabot>   ["ereh","era","emos","sgnirts"]
14:10:33 <rwbarton> ?
14:10:42 <Cale> > map ('A':) ["here", "are", "some", "strings"]
14:10:42 <lambdabot>   ["Ahere","Aare","Asome","Astrings"]
14:11:39 <bog3yman> i'm not too sure, i thought doing a:[[list]] would have the same effect as map (a:)[[list]]
14:11:45 <Cale> nope
14:11:55 <Cale> (Chuck Testa)
14:12:07 <Cale> > [1,2,3]:[[4,5],[6,7,8]]
14:12:08 <lambdabot>   [[1,2,3],[4,5],[6,7,8]]
14:12:20 <Cale> : is used to add a list to the beginning of a list of lists
14:12:36 <Cale> not an element to the beginning of each of the lists
14:12:45 <bog3yman> ah rightt
14:13:28 <bog3yman> if i replace the last line of my code with  | otherwise = [ map (a:) func(x-a) | a <- [1..(x-1)]] .. should that have compiled?
14:14:14 <DanBurton> @where typeclassopedia
14:14:14 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:14:19 <DanBurton> _Mikey: ^
14:14:33 <mreh> GHC will decide the writer instance based on context?
14:14:50 <mreh> cool
14:16:07 <bog3yman> argh so confusing =/
14:17:59 <rwbarton> bog3yman: I think it would yes
14:18:52 <bog3yman> weird getting an error when trying to run the program. and hugs isn't very clear with the errors lol!-
14:19:06 <bog3yman> Type error in application *** Expression     : map (a :) func (x - a) *** Term           : map *** Type           : (e -> f) -> [e] -> [f] *** Does not match : a -> b -> c -> d
14:20:11 <rwbarton> oh, sorry, you need parentheses around the call to func
14:20:36 <bog3yman> so should be:  | otherwise = [ map (a:) (func(x-a)) | a <- [1..(x-1)]]
14:21:19 <bog3yman> ehhh giving me a Type error in explicitly typed binding
14:21:26 <bog3yman> *** Term           : func *** Type           : Int -> [[[Int]]] *** Does not match : Int -> [[Int]]
14:21:52 <hpaste> DanBurton annotated “bog3yman” with “bog3yman (annotation)” at http://hpaste.org/54127#a54128
14:22:02 <rwbarton> oh, ah right
14:22:48 <rwbarton> you need to concatenate all the lists for different a
14:23:01 <DanBurton> ew don't ask me why my emacs put a tab character in there. whoops
14:23:18 <rwbarton> or you can do what I was going to suggest initially, extend your list comprehension
14:23:25 <rwbarton> which is also what DanBurton wrote
14:24:22 <DevHC> data T = T { a :: Integer, b :: Integer }. what's up with (read "T { b = 0, a = 0 }" :: T) failing? D:
14:24:32 <DanBurton> I was struggling with using a list comprehension; now that I stopped for a moment I see it's a straightforward transformation from what I wrote
14:24:52 <DanBurton> [x:xs | x <- [1..n], xs <- func (n-x)]
14:25:18 <copumpkin> DevHC: is it the right type?
14:25:25 <copumpkin> I guess it is
14:25:29 <shachaf> DevHC: You have to give them in order.
14:25:31 <shachaf> (Apparently.)
14:25:41 <shachaf> I.e., "T { a = 0, b = 0 }" will work.
14:25:53 <heyman_> hello
14:25:56 <DanBurton> I think I read that once. Read instances for records, by default, need to have the fields in order.
14:25:57 <shachaf> Autoderived read instances aren't really meant to be very fancy parsers.
14:26:13 <heyman_> hello
14:26:17 <DanBurton> heyman_: hello
14:27:05 <heyman_> im new to this, so you just chat here about haskell
14:27:28 <DevHC> shachaf: the question is: why?
14:27:31 <DanBurton> and/or monads, type theory
14:27:37 <shachaf> DevHC: Because it's simpler?
14:27:49 <bog3yman> hmm
14:27:52 <shachaf> DevHC: And it works with the output of show.
14:28:06 <DevHC> 2nd argument is vacuous
14:28:31 <copumpkin> DevHC: because one would have to be complex and accumulate fields in a map or something as it went along
14:28:39 <copumpkin> DevHC: and they probably didn't want to have to do that :P
14:28:55 <_Mikey> heyman_, What's going on?
14:29:06 <DevHC> copumpkin: it's time to sue someone for not doing that
14:29:13 <copumpkin> DevHC: go ahead
14:29:16 <_Mikey> oh
14:29:18 * DanBurton sues himself for not implementing that
14:29:19 <bog3yman> wow yes that danburton that list comprehension does work, excepts also returns duplicates :P whats the easiest way to get rid of duplicates e.g. [3,1] and [1,3] .. filter>
14:29:25 <DevHC> what does the Report say?
14:29:45 <copumpkin> I dunno, read it? :)
14:29:56 <DevHC> @where report
14:29:57 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
14:30:03 <DanBurton> bog3yman: erm...sounds like hoogle time.
14:30:25 <rwbarton> "If the constructor is defined using record syntax, the derived Read will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration."
14:30:29 <DanBurton> we have a list of stuff [a]. in our case [[x]] where a = [x], but whatever
14:30:39 <copumpkin> rwbarton, the human report
14:30:53 <DanBurton> suppose we have some way to determine whether to [x] are the same. so a function a -> a -> Bool
14:31:06 <DanBurton> s/to/two
14:31:19 <DanBurton> and we want the result to be [a]
14:31:27 <DanBurton> @hoogle [a] -> (a -> a -> Bool) -> [a]
14:31:28 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
14:31:28 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:31:28 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
14:31:41 <DanBurton> if you know Haskell lingo, then nubBy should ring a bell
14:31:44 <_Mikey> Someone in the #haskell IRC channel used (***), and when I asked lambdabot to tell me its type, it printed out scary gobbledygook that didn't even fit on one line! Then someone used fmap fmap fmap and my brain exploded.
14:31:50 <_Mikey> this ^
14:31:54 <_Mikey> sooo much
14:32:10 <bog3yman> ohh hoogle is a name of a functionn... is there an API where i can find out more about it? i'm new to haskell lol
14:32:19 <DanBurton> @where hoogle
14:32:20 <lambdabot> http://haskell.org/hoogle
14:32:20 <shachaf> jaspervdj: Implementing LZW for what?
14:32:25 <DanBurton> there's a website
14:32:31 <bog3yman> ty mate, i'll check it out
14:32:33 <DanBurton> or you can just ask lambdabot. hoogle isn't really a function
14:32:41 <DanBurton> it's a search database
14:33:18 <bog3yman> i seee
14:33:29 <DevHC> "If the constructor is defined using record syntax, the derived Read will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration. "
14:33:31 <DevHC>  D: D: D: D:
14:33:45 <DanBurton> @let equating = on (==)
14:33:45 <rwbarton> Wow, I remembered it exactly right!
14:33:46 <lambdabot>  <local>:2:50:
14:33:46 <lambdabot>      Equations for `equating' have different numbers of argume...
14:33:57 <DanBurton> :t equating
14:33:58 <shachaf> DevHC: Don't use autoderived Read instances as real parsers.
14:33:58 <lambdabot> forall a b. (Eq b) => (a -> b) -> a -> a -> Bool
14:34:24 <DanBurton> what is that equating doing there?
14:35:14 <rwbarton> @hoogle equating
14:35:14 <lambdabot> No results found
14:35:17 <DanBurton> > let equating = on (==); parity = even in nubBy (equating parity) [1,2,4,6,1,3,7]
14:35:18 <lambdabot>   [1,2]
14:36:57 <DanBurton> @hoogle Eq a => [a] -> [a] -> Bool
14:36:57 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
14:36:57 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:36:57 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:37:21 <DanBurton> is there a function for testing if the contents of two lists are the same, regardless of order?
14:37:54 <_Mikey> :t (***)
14:37:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:39:53 <hpc> :t comparing `on` sort -- DanBurton?
14:39:54 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
14:39:54 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
14:39:54 <lambdabot>     In the first argument of `on', namely `comparing'
14:40:02 <hpc> :t comparing sort -- DanBurton?
14:40:03 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
14:40:18 <DanBurton> hpc: yes that sounds about right
14:41:08 <DanBurton> > let equating = on (==); sameContents = equating sort in nubBy sameContents [[1,1,1],[1,2],[2,1],[3]]
14:41:09 <lambdabot>   [[1,1,1],[1,2],[3]]
14:41:37 <DanBurton> I was going to try something weirder, using \\
14:41:46 <bog3yman> what's this lol, i don't understand the lingo :$
14:42:03 <DanBurton> > sameContents xs ys = null (xs \\ ys) && null (ys \\ xs) in nubBy sameContents [[1,1,1],[1,2],[2,1],[3]]
14:42:04 <lambdabot>   <no location info>: parse error on input `='
14:42:14 <DanBurton> > let sameContents xs ys = null (xs \\ ys) && null (ys \\ xs) in nubBy sameContents [[1,1,1],[1,2],[2,1],[3]]
14:42:15 <lambdabot>   [[1,1,1],[1,2],[3]]
14:42:32 <DanBurton> @src ($)
14:42:33 <lambdabot> f $ x = f x
14:42:43 <DanBurton> bog3yman: $ is just function application ^
14:43:28 <prototrout> I think ":$" was just a face.
14:43:49 <bog3yman> ^ yeah was just a face lol.. when you got rid of the duplicates in [[1,1,1],[1,2],[2,1],[3]], what would you actually type in haskell i didn't understand that line you wrote
14:44:04 <DanBurton> let me work it into the hpaste
14:46:31 <hpc> bog3yman: removeDups = nubBy (comparing sort)
14:46:47 <hpc> er
14:47:18 <hpc> bog3yman: removeDups = nubBy ((==) `on` sort)
14:48:04 <hpaste> DanBurton annotated “bog3yman” with “bog3yman (annotation) (annotation)” at http://hpaste.org/54127#a54129
14:48:23 <DanBurton> @info comparing
14:48:24 <lambdabot> comparing
14:48:28 <hpc> @src comparing
14:48:28 <lambdabot> Source not found. You untyped fool!
14:48:36 <DanBurton> which command tells you the package?
14:48:41 <hpc> (comparing = on compare)
14:48:47 <hpc> @hoogle comparing
14:48:47 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:48:58 <DanBurton> @database comparing
14:48:58 <lambdabot> Unknown command, try @list
14:49:03 <hpc> http://haskell.org/hoogle/?hoogle=comparing -- it's in base
14:49:03 <DanBurton> ah well whatever
14:49:06 <DanBurton> hoogle works
14:49:22 <DanBurton> s/package/module
14:49:31 <DanBurton> Data.Ord though, thanks
14:49:47 <DanBurton> @hoogle equating
14:49:47 <lambdabot> No results found
14:50:09 <DanBurton> lambdabot seems to have the right equating, but it's not in the standard libs :(
14:50:30 <DanBurton> > nubBy (equating sort) [[1],[1],[1,2]]
14:50:32 <lambdabot>   [[1],[1,2]]
14:50:58 <hpc> someone defined equating with @let, i think
14:51:00 <hpc> @undefine
14:51:06 <DanBurton> > nubBy (equating sort) [[1],[1],[1,2]]
14:51:07 <lambdabot>   Not in scope: `equating'
14:51:08 <hpc> > nubBy (equating sort) [[1],[1],[1,2]]
14:51:09 <lambdabot>   Not in scope: `equating'
14:51:19 <DanBurton> ah that's it. I tried earlier but someone beat me to it
14:51:21 <hpc> equating = on (==)
14:51:29 <DanBurton> @let equating = on (==)
14:51:30 <lambdabot>  Defined.
14:51:38 <DanBurton> > nubBy (equating sort) [[1],[1],[1,2]]
14:51:38 <lambdabot>   [[1],[1,2]]
14:53:59 <DanBurton> equating is in the utility-ht package, apparently http://hackage.haskell.org/packages/archive/utility-ht/0.0.7/doc/html/src/Data-Eq-HT.html#equating
14:56:31 <jaspervdj> shachaf: a pure haskell gif parser/renderer
14:57:36 <hiptobecubic> What going on in the grandparent function here? How are the parents being unpacked? http://monads.haskell.cz/html/solution3.html
14:58:11 <luite> what's a good haskell lib for rendering text (with ttf fonts) on png images, with some effects? (for in a web application)
14:58:16 <hpc> hiptobecubic: let's assume a data type
14:58:37 <hpc> data Sheep = Sheep {parent1 :: Sheep, parent2 :: Sheep}
14:58:43 <hiptobecubic> yes
14:58:52 <hpc> hiptobecubic: parent s = [parent1 s, parent2 s]
14:59:37 <hiptobecubic> hpc, ok?
14:59:40 <hpc> hiptobecubic: the rest is list monad plumbing
15:00:03 <hpc> hiptobecubic: so what happens is
15:00:11 <hiptobecubic> hpc, but ithink you're missing part of it
15:00:16 <hpc> grandparent s = do
15:00:21 <shachaf> jaspervdj: Aha, so it's the GIF version of LZW.
15:00:28 <hiptobecubic> the parents are Maybe Sheep
15:00:32 <hpaste> timp pasted “html” at http://hpaste.org/54130
15:00:35 <shachaf> jaspervdj: I once wrote the world's worst GIF LZW decoder. :-)
15:00:36 <hiptobecubic> because the sheep could be cloned, apparently
15:00:53 <hpc> hiptobecubic: oh yes, i am
15:00:57 <hiptobecubic> and you dno't want your list to have [Nothing, Just s]
15:01:01 <hpc> that doesn't change the nature of the problem though :P
15:01:01 <hiptobecubic> you just want [s]
15:01:26 <hpc> so a sheep with no parents has parent s = []
15:01:29 <hiptobecubic> I have solved the exercise, i just don't understand how they did it htere
15:01:41 <hpc> but that's boring for dissecting grandparent, so let's say the parents are [f, m]
15:01:47 <Pseudonym> shachaf: I'd be willing to bet that yours wasn't the world's worst, if I still had the source code of mine hanging around.
15:01:57 <jaspervdj> shachaf: I haven't implemented it myself but from what I heard, it sounds pretty ugly
15:01:58 <hpc> so then on the next line of that do block, we have parent p
15:02:01 <shachaf> Pseudonym: Mine was pretty bad...
15:02:05 <Pseudonym> So was mine.
15:02:17 <Pseudonym> It was a rite of passage, I suspect.
15:02:20 <shachaf> jaspervdj: GIF LZW is pretty simple, actually.
15:02:26 <hpc> hiptobecubic: so what that does (based on the definition of (>>=), btw) is apply parent to every element of that list, then smush the lists together
15:02:31 <Pseudonym> Actually, my encoder was worse than my decoder.
15:02:34 <hiptobecubic> hpc, and it automatically maps it across the list/
15:02:39 <hiptobecubic> ?*
15:02:39 <lambdabot> Maybe you meant: . ? @ v
15:02:40 <hpc> hiptobecubic: so [[ff, fm], [mf, mm]]
15:02:43 <shachaf> Pseudonym: Really? The encoder is easier than the decoder, if I recall correctly.
15:02:50 <hpc> then joined, [ff, fm, mf, mm]
15:02:52 <shachaf> Because the decoder has to take some extra edge case into account.
15:02:56 <hpc> and that's how grandparent works
15:02:58 <shachaf> CSCSC or something along those lines.
15:03:03 * shachaf doesn't remember.
15:03:03 <jaspervdj> shachaf: https://bitbucket.org/nudded/gif-parser/src/5b54a09b8bfe/src/LZW.hs (code is not mine)
15:03:19 <hiptobecubic> :t (>>=)
15:03:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:03:26 <shachaf> jaspervdj: https://github.com/shachaf/jsgif/blob/master/gif.js (code is sadly mine)
15:03:34 <Pseudonym> The encoder has to implement some kind of dictionary data structure (usually a probing hash table), which is difficult if you don't know what you're doing.
15:03:43 <hpc> hiptobecubic: the reason this works is because (list >>= f) = join (map f list)
15:03:52 <hiptobecubic> hpc, oh
15:03:59 <hpc> or, concat (map f list)
15:03:59 <hiptobecubic> ok
15:04:02 <hpc> or concatMap
15:04:08 <hpc> :t concatMap
15:04:09 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:04:12 <hiptobecubic> grandparentList s = concatMap parentList (parentList s)   was my solution
15:04:14 <hpc> :t (=<<)
15:04:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:04:24 <hiptobecubic> and then grandparentList' s = (maybeToList (mother s) >>= parentList) `mplus` (maybeToList (father s) >>= parentList)
15:04:27 <shachaf> Pseudonym: Well, I used JavaScript.
15:05:03 <shachaf> And I added the entire entry to the dictionary for each code, rather than just "previous entry + 1 character".
15:05:03 <Pseudonym> I used K&R C.
15:05:21 <timp_> The code at http://hpaste.org/54130 results in Not in scope: type constructor or class `XHTMLString' but I thought I had defined it in line 1
15:05:34 <_Mikey> Bye all!
15:05:34 <shachaf> Pseudonym: Why do you need a dictionary data structure that isn't an array?
15:05:49 <shachaf> I think all your keys are integers and they're all consecutive. Or soemthing.
15:06:00 <Pseudonym> It's a compound key: previous code and next char.
15:06:17 <shachaf> Oh, for the encoder.
15:06:49 <hiptobecubic> hpc, so why doesn't something like this work?
15:07:00 <hiptobecubic> > [1,2,3] >>= (+ 3)
15:07:01 <lambdabot>   No instance for (GHC.Num.Num [b])
15:07:01 <lambdabot>    arising from a use of `e_11233' at <in...
15:07:21 <copumpkin> hiptobecubic: the types don't work
15:07:21 <hpc> hiptobecubic: because the stuff afterwards has to produce a list
15:07:41 <shachaf> > [1,2,3] <**> [(+3),(*4)]
15:07:42 <lambdabot>   [4,4,5,8,6,12]
15:07:49 <hpc> > [1, 2, 3] >>= replicate 3
15:07:50 <lambdabot>   [1,1,1,2,2,2,3,3,3]
15:07:58 <hiptobecubic> oh
15:07:59 <Pseudonym> > [1,2,3] >>= return . (+3)
15:08:01 <lambdabot>   [4,5,6]
15:08:06 <hiptobecubic> what is <**> ?
15:08:09 <Pseudonym> > mapM (+3) [1,2,3]
15:08:09 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
15:08:10 <lambdabot>    arising from a use of `M33255971...
15:08:20 <Pseudonym> > fmap (+3) [1,2,3]
15:08:20 <lambdabot>   [4,5,6]
15:08:21 <hpc> hiptobecubic: unimportant; they are just geeking out :P
15:08:25 <shachaf> > map (+3) [1,2,3]
15:08:26 <lambdabot>   [4,5,6]
15:08:28 * Pseudonym can never remember the monad map functions
15:08:37 <hiptobecubic> hpc, no this is what i'm trying to learn
15:08:44 <Pseudonym> I'm still annoyed that map != fmap.
15:08:45 <hpaste> charly pasted “How can I access an attribute” at http://hpaste.org/54132
15:08:56 <shachaf> > (+3) . [1,2,3] -- Pseudonym: Does this appease you?
15:08:58 <hiptobecubic> Pseudonym, why would map == fmap ?
15:08:58 <lambdabot>   [4,5,6]
15:09:02 <charly__> hi there. can someone help with my posted problem? thanks
15:09:14 <Pseudonym> hiptobecubic: The small name should be the generic function.
15:09:16 <hiptobecubic> shachaf, wtf ..
15:09:21 <Pseudonym> And, in fact, it was pre-Haskell 98.
15:09:44 <shachaf> hiptobecubic: "fmap" is a generalization of "map" that works for anything that can be mapped over.
15:09:45 <Pseudonym> shachaf: Simultaneously appealing and annoying.
15:10:00 <shachaf> Appoyling.
15:10:09 <hiptobecubic> so map is just for lists
15:10:15 <hiptobecubic> and fmap is for monads
15:10:25 <copumpkin> functors
15:10:40 <hiptobecubic> ... functors?
15:12:02 <hiptobecubic> For the regulars in here, what is ratio of time spent taalking about interesting haskell problems to that explaining monads, curry, and functors to the uninitiated?
15:12:15 <hpc> hiptobecubic: http://learnyouahaskell.com/making-our-own-types-and-typeclasses -- start from here; it explains it better than we can
15:12:27 <Peaker> hiptobecubic: I'd guess it's 50/50 ?
15:12:36 <hiptobecubic> Peaker, that good?
15:12:41 <Peaker> hiptobecubic: some days it's mostly the former, sometimes mostly the latter
15:12:42 <hpc> Peaker: you forgot the other 50 where we talk about stuff that should really be in -blah :P
15:13:12 <Pseudonym> hiptobecubic: Depends if there's someone who has a specific Haskell question.
15:13:24 <Pseudonym> If so, we talk Haskell. Otherwise, we talk maths.
15:16:59 <ian_mi> shachaf: hu
15:17:32 <shachaf> ian_mi: iv
15:17:41 <ian_mi> shachaf: lists aren't categories, are they?
15:18:12 <Pseudonym> ian_mi: The monad axioms form a category.
15:18:30 <Pseudonym> In particular, Kleisli composition is a category arrow.
15:18:41 <Pseudonym> Kleisli composition is this:
15:19:02 <copumpkin> ian_mi: you can make a simple category using lists
15:19:12 <Pseudonym> (@@) :: (Monad m) => (a -> M b) -> (b -> M c)
15:19:22 <Pseudonym> Hang on,.
15:19:35 <ian_mi> I know what Kleisli categories are
15:19:43 <Pseudonym> Right.
15:20:06 <Pseudonym> So the three monad laws can actually be summarised as saying that Kleisli composition forms a category.
15:20:15 <shachaf> ian_mi: lambdabot has (.) = fmap, if that's what you're referring to.
15:20:31 <ian_mi> shachaf: yes
15:20:45 <ian_mi> why?
15:20:46 <Pseudonym> In convenient Haiku form: Monad axioms / Kleisli composition forms / a category
15:21:08 <hiptobecubic> Pseudonym, i have to agree with you
15:21:16 <alistra> srsly why does everybody use parsec
15:21:19 <shachaf> ian_mi: Because Prelude's (.) is a special case of fmap.
15:21:25 <alistra> happy + alex are million times more readable
15:21:29 <ivanm> alistra: I don't!
15:21:32 <ivanm> I use polyparse
15:21:36 <ivanm> ;)
15:21:48 <hiptobecubic> map should be fmap
15:22:05 <hpc> they should all be (<$>)
15:22:08 <ivanm> alistra: well, happy+alex only makes sense if your languages have a specified grammar, right?
15:22:14 <Pseudonym> ian_mi: As a simple exercise, prove that the Haskell monad axioms imply that Kleisli composition forms a category, and vice versa.
15:22:28 <ian_mi> it's also a special form of (.) for categories, which makes a lot more sense
15:22:43 <Axman6> alistra: you really think they're more readable? o.O
15:22:58 <hpaste> gregounech pasted “join has Sit at the end FU” at http://hpaste.org/54134
15:23:07 <Pseudonym> hiptobecubic: Actually, fmap should be map, and what is currently map should just drop on the floor.
15:23:11 <Saizan> let's say that we don't commonly use many instances of Category with lambdabot :)
15:23:23 <hiptobecubic> Pseudonym, indeed.
15:23:26 <Pseudonym> There's always list comprehensions if you must. map f xs = [ f x | x <- xs ]
15:23:41 <Saizan> in fact, the only two in scope might be (->) and Kleisli m
15:24:04 <hpc> Saizan: i don't know of any other arrows
15:24:10 <ian_mi> Pseudonym: shouldn't you specify that return = id?
15:24:16 <Saizan> also, (.) = fmap predates Category
15:24:24 <alistra> ivanm: how can you parse something without a grammar
15:24:29 <hpc> oh i do, AFRP and... yampa?
15:24:31 <alistra> Axman6: yes
15:24:43 <Pseudonym> ian_mi: return is the identity morphism, yes.
15:25:00 <Axman6> hmm, if we were to change fmap to map, we could do it with a transitional period where class Functor f where map :: (a -> b) -> f a -> f b; map = fmap; fmap :: (a -> b) -> f a -> f b. then all the current instances should work fine
15:25:02 <ivanm> alistra: because I know what I want to parse but I don't have a full out specified grammar for it?
15:25:11 <Pseudonym> Remember the monad axioms, like m >>= return = m
15:25:32 <ivanm> alistra: or at least not a grammar of the required form for a parser generator
15:25:37 <alistra> Axman6: parsec has a lot haskell parts, happy + alex only return constructors (at least i write that they do)
15:26:04 <alistra> it's easier to reason about grammars
15:26:05 <ivanm> alistra: so are you saying that happy + alex are more readable to you because they have less Haskell in them than parsec?
15:26:13 <alistra> than some haskell code that parses something
15:26:29 <ian_mi> Pseudonym: what I'm saying is that the statement Kliesli composition is a category isn't strong enough.
15:27:22 <ian_mi> it could concievably be a category in which id is not return and therefore not satisfy the monad laws
15:27:41 <alistra> ivanm: from the computational complexity point of view each grammar can express at most a context-free language, and each haskell program can express a recursively enumerative program
15:27:56 <ivanm> ... so ?
15:28:00 <Pseudonym> Fair enough. The IRC format doesn't always encourage precise statements, but I think you knew what I meant.
15:28:16 <alistra> and happy syntax grammar has like 2 contructs :P, and haskell is well haskell
15:28:34 * ivanm admits that he doesn't have that much experience with grammars, languages, etc. so his understanding of the terminology on all this is a little fuzzy
15:28:41 <hpc> ian_mi: (return, (<=<)) forms a category -- fixed
15:28:45 <ivanm> alistra: yes, but I quite _like_ Haskell!
15:28:51 <alistra> yeah
15:28:56 <alistra> it feels like
15:29:01 <ian_mi> thanks
15:29:03 <alistra> writing a parser by hand
15:29:16 <Axman6> alistra: why on earth would we as haskell users want to learn another syntax for something that
15:29:24 <Axman6> that's more elegantly expressed in haskell?
15:29:34 <alistra> it's not more elegant :|
15:29:57 <ivanm> in terms of composability it is IMHO
15:30:04 <alistra> handing border cases must be a nightmare
15:32:25 <Cale> alistra: What are you saying is a nightmare exactly?
15:32:28 <Cale> Using Parsec?
15:32:56 <alistra> it looks like it
15:33:02 <alistra> i tried reading the docs
15:33:04 <alistra> and making something
15:33:09 <ivanm> or else you haven't written your parser well enough
15:33:11 <alistra> but it repulses me lol
15:33:31 <alistra> i've written like 20 parsers in happy and alex
15:33:36 <ivanm> alistra: if you have a pre-specified grammar that you can easily translate into happy's syntax, then you might as well use happy
15:33:45 <ivanm> if not, then I prefer a parser combinator library
15:33:58 <alistra> i think of grammars when i write a parser
15:34:10 <alistra> i can't imagine thinking about it in another way
15:34:29 <byorgey> people are comfortable with things they are comfortable with.  news at 11.
15:34:43 * monochrom think of grammars when writing parsec-using code
15:34:48 <ivanm> byorgey: but I prefer my news at 12!
15:34:59 <hpc> byorgey: that sounds too level-headed to be one of my local stations
15:35:05 <byorgey> haha
15:35:55 <alistra> also does parsec has a lexer? i see some code exapmles using spaces keyword
15:36:00 <alistra> it's weird
15:36:06 <geheimdienst> byorgey: see also http://2.bp.blogspot.com/-8d39N01N8ng/TfEF2hiwcHI/AAAAAAAAAXQ/-y7z4DY09Gk/s1600/funny-pictures-cat-is-in-an-uncomfortable-position-but-sleeps-sweetly.jpg
15:36:31 <hpc> alistra: i don't think it has any special code for it, it just uses the same level of power as the other parsing stuff
15:36:41 <byorgey> alistra: parsec encourages a style that combines lexing with parsing
15:36:46 <monochrom> my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements shows an example of using lexer in parsec
15:36:48 <alistra> uhh
15:36:49 <gentleben> alistra: we use ragel. we have found the perf to be better than anything in haskell
15:36:50 <hpc> (you can simulate a DFA with a CFG donchaknow)
15:37:27 <Axman6> alistra: having to learn to and then use a lexer, then having to learn and use a separate parser language instead of using the one framework for both that uses syntax we're familliar with, and allows us to do much more powerful things doesn't seem like that makes happy+alex 'better' :\
15:37:32 <alistra> hpc: but my point is that haskell is a turing machine not a cfg :|
15:37:39 <Pseudonym> alistra: Once upon a time, we used to parse programming language with a top-down LL parser for the main syntax, then an operator precedence parser for the expression sublanguage.
15:37:57 <Axman6> alistra: you can use lexer if you like, and have that as the token stream that parsec takes in
15:38:11 <Pseudonym> alistra: That's _kind_ of like what separating lexing and parsing is like.
15:38:44 <alistra> Pseudonym: i don't quite follow your point
15:39:22 <alistra> Axman6: i just assumed everybody has knowledge about automata, regexps, cfgs from school
15:39:23 <Cale> Axman6: You can even write that lexer in Parsec :)
15:39:31 <ivanm> alistra: I don't
15:39:56 <ivanm> all I know about them is from having to tutor them (they do 1 topic/week; I now other topics well, but not these ones)
15:40:29 <clsmith> welp, i'm in my final year at university and they have yet to mention regular expressions
15:40:30 <incomprehensibly> > putStrLn "test"
15:40:31 <lambdabot>   <IO ()>
15:40:39 <incomprehensibly> is there a way you can execute the IO actions?
15:40:44 <incomprehensibly> printing out stuff
15:40:46 <hpc> incomprehensibly: not in lambdabot
15:40:49 <incomprehensibly> ok
15:41:15 <shachaf> > unsafePerformIO $ putStrLn "<IO ()>"
15:41:16 <lambdabot>   <IO ()>
15:41:26 <Cale> incomprehensibly: In ghci, it'll run them automatically
15:41:37 <incomprehensibly> Cale: yeah, I'm doing it there
15:41:38 <alistra> monochrom: this code example is prettier then other parsecs i've seen
15:41:40 <clsmith> i guess it could just shortcircuit it into the output string and not actually do the IO
15:41:47 <alistra> maybe just people write shitty parsers
15:41:53 <clsmith> but that would be hacky
15:42:04 <monochrom> thanks. yes I write better.
15:42:05 <mdempsky> > unsafePerformIO $ fix (forever . forkIO)
15:42:06 <lambdabot>   Not in scope: `forkIO'
15:42:10 <mdempsky> aw :<
15:42:23 <alistra> clsmith: that's sad
15:42:57 <acowley> what's a nice implementation of a function with type (a -> m b) -> (a,c) -> m (b,c)
15:43:00 <Axman6> alistra: I have that knowledge, and it's what makes me want to use parsec like parsers even more
15:43:01 <clsmith> they did however introduce me to haskell, so i'm willing to let that one slide
15:43:18 <alistra> @hoogle  (a -> m b) -> (a,c) -> m (b,c)
15:43:19 <lambdabot> No results found
15:43:37 <alistra> @hoogle  (a -> m b) -> a -> m b
15:43:38 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:38 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
15:43:38 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:43:43 <Axman6> @djinn Monad m => (a -> m b) -> (a,c) -> m (b,c)
15:43:44 <lambdabot> -- f cannot be realized.
15:43:44 <clsmith> i also got bonus points for implementing my cryl
15:43:47 <clsmith> ahem
15:43:52 <clsmith> cryptography coursework in haskell
15:43:55 <alistra> @hoogle first
15:43:55 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:43:55 <lambdabot> Data.Monoid newtype First a
15:43:55 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:44:02 <Axman6> @sjinn (a -> Maybe b) -> (a,c) -> Maybe (b,c)
15:44:03 <lambdabot> f a (b, c) =
15:44:03 <lambdabot>     case a b of
15:44:03 <lambdabot>     Nothing -> Nothing
15:44:03 <lambdabot>     Just d -> Just (d, c)
15:44:06 <Axman6> :(
15:44:15 <alistra> @type first (=<<)
15:44:17 <lambdabot> forall a (m :: * -> *) b d. (Monad m) => (a -> m b, d) -> (m a -> m b, d)
15:44:18 <acowley> "cannot be realized" seems a bit harsh
15:44:21 <clsmith> there needs to be a warning in irssi which says, "oops, it seems you're part-way through a word right now"
15:47:17 <alistra> @type second
15:47:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:48:20 <acowley> :t (uncurry (liftM2 (,)) .) . (*** return)
15:48:21 <lambdabot> forall a1 b b' (m :: * -> *). (Monad m) => (b -> m a1) -> (b, b') -> m (a1, b')
15:48:39 <acowley> doesn't get much more readable than that, does it?
15:48:47 <alistra> :t ***
15:48:48 <lambdabot> parse error on input `***'
15:48:52 <acowley> :t (***)
15:48:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:49:47 <_oz> acowley: what about this for a nice implementation
15:49:53 <_oz> :t (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:49:54 <lambdabot> forall a a1 (m :: * -> *) a2. (Monad m) => (a1 -> m a2) -> (a1, a) -> m (a2, a)
15:50:10 <acowley> I actually went crosseyed for a moment there
15:50:15 <alistra> @unpl (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:50:15 <lambdabot> (\ s -> (\ ah o -> (s (fst ah)) >>= \ ak -> return ((,) ak o)) >>= \ aq -> snd >>= \ ao -> return (aq ao))
15:50:15 <_oz> (used pointfree to cheat, i admit)
15:50:19 * clsmith screws up face
15:50:32 <acowley> I'll stick with my version that's only 75% unreadable
15:50:46 <alistra> @pl @unpl (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:50:47 <lambdabot> (line 1, column 1):
15:50:47 <lambdabot> unexpected "@"
15:50:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:50:56 <alistra> @comp pl unpl (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:50:57 <lambdabot> ((snd >>=) . (return .) =<<) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .) . (. fst)
15:51:14 <_oz> wll, there is always the obvious implementation right, i fail to see the point in this exercise to be honest :)
15:51:19 <acowley> If .: was a standard operator it'd be prettier
15:51:22 <alistra> comp unpl (comp pl unpl) (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:51:24 <_oz> :t \ a (b,c) -> do x <- a b; return (x,c)
15:51:25 <lambdabot> forall t t1 (m :: * -> *) t2. (Monad m) => (t -> m t2) -> (t, t1) -> m (t2, t1)
15:51:32 <alistra> @comp unpl (comp pl unpl) (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:51:32 <lambdabot> Plugin `compose' failed with: Unknown command: "(comp"
15:51:41 <alistra> @comp unpl comp pl unpl (`ap` snd) . (. fst) . flip flip ((return .) . flip (,)) . (((.) . (>>=)) .)
15:51:41 <lambdabot> Plugin `compose' failed with: Unknown command: "comp"
15:51:51 <acowley> _oz: I think the obvious implementation is pointier than it deserves to be
15:52:10 <_oz> acowley: i see.
15:52:14 <clsmith> pointy functions are good because i can read them :(
15:52:29 <acowley> _oz: that's not always the trend, though
15:52:35 <acowley> err, that was to clsmith
15:52:40 <clsmith> "pointy functions, pointy pointy, anoint my head, anointy-nointy."
15:52:54 <acowley> I find that points often cloud a flow that follows the obvious contours of the data
15:53:43 <_oz> for this specific case, i really think the obvious implementation is very easy to read tho.
15:53:47 <acowley> In this case, the obvious is probably better :/
15:53:49 <acowley> yes
15:53:52 <Emanes> Hello, can someone help me with this excersise : Find the type of this function g z = snd z [fst z] ..... (the answer is g :: (a,[a]->b)->b) .... but how do i get it?
15:54:21 <acowley> that's why I came here to ask, in case there was an elegant formulation in terms of, most likely, Arrow
15:54:37 <Cale> Emanes: Well, we know that g is a function, because it takes a parameter
15:54:41 <alistra> Emanes: do you know how to type simble lambda terms?
15:54:46 <clsmith> with simple things, where it's just a case of a bunch of compositions and so on, sure. but for stuff like the abominations you guys just posted? ;-;
15:54:48 <Cale> Emanes: so g :: u -> v  for some types u and v
15:54:56 <hpc> Emanes: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=4 -- this might help you
15:55:06 <alistra> Emanes: your function is a (\z -> snd z [fst z]) lambda term
15:55:09 <Cale> z :: u
15:55:27 <Cale> and since we apply  snd z and fst z,  z had better be a pair
15:55:29 <hpc> Emanes: basically, turn things into a system of equations of sorts, then solve
15:55:46 <alistra> listen to hpc:
15:55:56 <Cale> u = (l, r) for some types l and r
15:56:59 <Cale> snd z :: r is being applied as a function, so r = s -> t for some types s and t
15:57:22 <Cale> and the result of applying that function is g z, so v = t
15:58:08 <Cale> and [fst z] :: [l] is used as an argument to that function, so we have s = [l]
15:58:20 <Cale> so r = [l] -> v
15:58:34 <alistra> it's usually hard without a piece of paper
15:58:37 <alistra> :p
15:58:55 <Emanes> mmmm.... i`m trying to understang :D
15:59:30 <alistra> Emanes: you know what unification is :D
15:59:33 <Cale> and u -> v = (l,r) -> v = (l,[l] -> v) -> v
16:00:05 <Emanes> yes, i know
16:00:06 <Cale> and we've examined every subexpression of this thing and collected all the equations we're going to get, so this'll work for any types l and v
16:05:28 <tmhz> @compose extractEven = unlines . strInts . filter even . parseInts . lines
16:05:28 <lambdabot> Plugin `compose' failed with: Unknown command: "extractEven"
16:06:15 <tmhz> sorry wrong window
16:11:32 <Eduard_Munteanu> tmhz: that composes two lambdabot commands
16:11:52 <Eduard_Munteanu> @compose google quote
16:11:56 <lambdabot> http://irclog.perlgeek.de/darcs/2009-12-23
16:11:56 <lambdabot> Title: IRC log for #darcs, 2009-12-23
16:14:08 <shachaf> @. google quote
16:14:11 <lambdabot> http://www2.fiu.edu/~mizrachs/paradigms.html
16:14:11 <lambdabot> Title: The search for a Fortean paradigm
16:14:46 <byorgey> haha, that makes for a fun game of "guess the quote"
16:15:09 <hpc> byorgey: ahaha
16:15:35 <shachaf> byorgey: No reasonable way to verify your answers, sadly.
16:15:42 <shachaf> Well, I guess @google is mostly deterministic.
16:16:41 <Saizan> @. google nixon
16:16:42 <lambdabot> http://www.youtube.com/watch?v=ejvyDn1TPr8
16:16:42 <lambdabot> Title: Nixon - When the president does it, that means that it is not illegal - YouTube
16:16:55 <Eduard_Munteanu> Heh.
16:16:57 <alistra> @help list
16:16:58 <lambdabot> list [module|command]
16:16:58 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
16:16:59 <Saizan> that's too easy
16:17:23 <alistra> @users
16:17:23 <lambdabot> Unknown command, try @list
16:17:31 <alistra> @list
16:17:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:17:42 <alistra> @help users
16:17:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:17:54 <alistra> @help seen
16:17:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:18:11 <alistra> seen module doesn't work, but it's listed in the commandlist
16:19:04 <Eduard_Munteanu> @. google run "tro" ++ cycle "lo"
16:19:07 <lambdabot> http://www.vibers.to/vibe/153476
16:19:07 <lambdabot> Title: OptimusDouche :: TROLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO ...
16:19:56 <alistra> > cycle "lo"
16:19:58 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
16:19:59 <Eduard_Munteanu> alistra: hm, preflex should handle that
16:20:10 <Eduard_Munteanu> preflex: seen alistra
16:20:10 <preflex>  alistra was last seen on #haskell 13 seconds ago, saying: > cycle "lo"
16:20:20 <alistra> preflex: users
16:20:40 <geheimdienst> alistra: you can talk in a private window with the bots
16:20:47 <Eduard_Munteanu> Although IIRC preflex answers @seen too
16:20:50 <Eduard_Munteanu> @seen alistra
16:20:51 <preflex>  alistra was last seen on #haskell 30 seconds ago, saying: preflex: users
16:20:51 <lambdabot> Unknown command, try @list
16:28:12 <bog3yman> can s
16:29:34 <Eduard_Munteanu> @faq can Haskell s?
16:29:34 <lambdabot> The answer is: Yes! Haskell can do that.
16:41:14 <bog3yman> is anyone free to help.. prob a basic question.. I'm tryin to make a program which calculates the longest list of the same elements in a list, e.g. [1,2,2,2,2,3] will return 4, [1,2,3,4,5,5] will return 2...
16:41:38 <bog3yman> i've made a function that given a list e.g. [2,2,2,2] it will return the number of repeated elements
16:41:39 <hpc> > group [1, 2, 3, 2, 4]
16:41:40 <lambdabot>   [[1],[2],[3],[2],[4]]
16:41:54 <hpc> > maximumBy length . group $ [1, 2, 2, 2, 2, 3]
16:41:55 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
16:41:55 <lambdabot>         against...
16:42:01 <hpc> :t maximumBy
16:42:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
16:42:16 <bog3yman> but now i'm trying to use the function to create a list of list of the different lengths..
16:42:21 <hpc> :t maximum . length . group $ [1,2,2,2,2,3]
16:42:22 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
16:42:23 <lambdabot>     In the first argument of `(.)', namely `length'
16:42:23 <lambdabot>     In the second argument of `(.)', namely `length . group'
16:42:35 <bog3yman> e.g. [1,1,1,2,2,3,3,3,3] will return [[3],[2],[4]]
16:42:36 <c_wraith> hpc, you want comparing length
16:42:38 <hpc> :t maximum . map length . group $ [1,2,2,2,2,3]
16:42:39 <lambdabot> Int
16:42:44 <hpc> >t maximum . map length . group $ [1,2,2,2,2,3]
16:42:51 <hpc> > maximum . map length . group $ [1,2,2,2,2,3] -- ffs
16:42:53 <lambdabot>   4
16:43:10 <hpc> longestSubList = maximum . map length . group
16:43:32 <alistra> oh groupBy (==) = group
16:43:41 <alistra> somebody was looking for group earlier
16:44:28 <bog3yman> hpc i dont understand what you just did im a newbie to haskell :S is it really just one line code that can find out the longest sequence of the same numbers?
16:44:41 <hpc> bog3yman: yeah, sorry
16:44:52 <hpc> bog3yman: (.) is function composition
16:44:58 <hpc> (f . g) x = f (g x)
16:45:24 <hpc> so basically, you group the list, then apply length to all the sublists, then get the maximum of those lengths
16:45:35 <hpc> > group [1,2,2,2,2,3]
16:45:36 <lambdabot>   [[1],[2,2,2,2],[3]]
16:45:42 <hpc> > map length [[1],[2,2,2,2],[3]]
16:45:43 <lambdabot>   [1,4,1]
16:46:41 <bog3yman> group [1,2,2,2,2,3]
16:47:14 <Nimatek> bog3yman: prefix it with '>' for lambdabot
16:47:23 <bog3yman> ah k
16:47:28 <hpc> > text "> command"
16:47:28 <bog3yman> >group [1,2,3,3,3,4]
16:47:29 <lambdabot>   > command
16:47:42 <Nimatek> with a space after the > :)
16:47:47 <bog3yman> > group [1,2,3,3,3,4]
16:47:48 <lambdabot>   [[1],[2],[3,3,3],[4]]
16:47:52 <bog3yman> cool
16:47:58 <tomprince> > group [1,2,1]
16:47:59 <lambdabot>   [[1],[2],[1]]
16:48:09 <bog3yman> is group some kind of special function though? because when i try it in WinHugs it says Undefined variable "group"
16:48:15 <tomprince> > group . sort $ [1,2,1]
16:48:16 <lambdabot>   [[1,1],[2]]
16:48:20 <Nimatek> @src group
16:48:20 <lambdabot> group = groupBy (==)
16:48:27 <Nimatek> @src groupBy
16:48:27 <lambdabot> groupBy _  []       =  []
16:48:27 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:48:27 <lambdabot>     where (ys,zs) = span (eq x) xs
16:48:29 <hpc> bog3yman: you probably have to import Data.List
16:48:46 <tomprince> > maximum . length . group . sort $ [1,2,1,2,3,4,3,2]
16:48:47 <lambdabot>   Couldn't match expected type `[a]'
16:48:47 <lambdabot>         against inferred type `GHC.Types...
16:49:11 <tomprince> > maximum . map length . group . sort $ [1,2,1,2,3,4,3,2]
16:49:12 <lambdabot>   3
16:53:47 <bog3yman> hmmm... can someone help me to manually implement the "group" function.. i've tried this but it doesnt compile so dont think i'm thinking correctly..
16:53:50 <bog3yman> groupz :: [Int] -> [[Int]]
16:53:53 <bog3yman> groupz [] = [[]]
16:53:56 <bog3yman> groupz [x] = [[]]
16:53:59 <bog3yman> groupz xs
16:54:02 <bog3yman>  | head xs == head (tail xs) = (head ++ tail xs)
16:54:05 <bog3yman>  | otherwise = tail xs
16:54:40 <bog3yman> or is it more complicated involving another function lol
16:55:19 <hpc> @src span
16:55:19 <lambdabot> span _ xs@[]                     =  (xs, xs)
16:55:19 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
16:55:20 <lambdabot>                   | otherwise    =  ([],xs)
16:55:43 <hpc> bog3yman: well first, it's groupz [x] = [[x]]
16:56:02 <hpc> bog3yman: second, your last pattern should be (x:y:xs)
16:58:01 <hpc> bog3yman: i haven't worked it out myself, but i expect the function to not be too hard
16:58:42 <mike-burns> Especially since someone did   @src group   above.
16:59:08 <Sgeo|web> :t group
16:59:09 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
16:59:15 <alistra> @type span
16:59:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:05:52 <Nimatek> > let groupz [] = [[]]; groupz [x] = [[x]]; groupz (x:xs) = ([x] ++ takeWhile (==x) xs) : groupz (dropWhile (==x) xs) in groupz [1,2,2,2,2,3,2,4]
17:05:54 <lambdabot>   [[1],[2,2,2,2],[3],[2],[4]]
17:09:33 <hpaste> IOQWJWQO pasted “EJIOQJ” at http://hpaste.org/54142
17:14:07 <bog3yman> hmmm.. if i had the list [1,2,3] ... is there a way using only pattern matching/guards to get all the sequences our of it? i.e. [[1],[1,2],[1,2,3],[2,3],[3]]
17:14:24 <bog3yman> out* not our
17:16:18 <copumpkin> not that I know of, no, unless you mean pattern matching with recursion
17:16:48 <bog3yman> yeah with recursion :P
17:17:51 <Sgeo|web> Is mm_freak here?
17:19:30 <hpaste> stribor pasted “graphics” at http://hpaste.org/54144
17:20:03 <Sgeo|web> @tell mm_freak I don't think it's necessary to remove the infix typing thing, just explain it.
17:20:03 <lambdabot> Consider it noted.
17:20:25 <stribor> i am trying to use above little program to get little window on the screen...i use ghci interpreter...but when i close the window it seems program is still hanging in interpreter...i dont get ghci prompt againn
17:23:27 <mike-burns> I think this is a GTK question, and as I remember it you need to hook up the close button properly.
17:23:37 <mike-burns> But I haven't touched GTK in a year.
17:23:49 <stribor> mike-burns: thanks
17:25:44 <monochrom> window `on` deleteEvent $ liftIO mainQuit >> return False
17:25:53 <mike-burns> Yeah, you need a gtk_main_quit(), but however you write that in Haskell.
17:25:54 <monochrom> add that line anywhere before calling mainGUI
17:25:55 <mike-burns> Oh, like that.
17:26:20 <monochrom> I wrote http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro#Signals :)
17:26:37 <monochrom> (i.e., I wrote section 3)
17:26:46 <Eduard_Munteanu> Nice.
17:27:54 <monochrom> I also have an elaborate example at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
17:28:09 <stribor> monochrom: liftIO not in the scope
17:28:28 <monochrom> import Control.Monad.Trans(liftIO)
17:34:23 <Eduard_Munteanu> Can't you quit from the GTK monad somehow?
17:35:18 <Eduard_Munteanu> I somehow remember not needing liftIO for that stuff, but it's been a long time since I touched it as well.
17:38:46 <monochrom> there is no GTK monad. most event handlers are run in the EventM monad, which is ReaderT (gtk2hs internal data) IO, so it needs liftIO
17:51:50 <Sgeo|web> Is Idris currently anywhere close to being useful for, say, games?
17:56:55 <Eduard_Munteanu> Sgeo|web: what sort of games? Mind most languages aren't terribly useful without proper bindings to libraries you need
17:57:58 * Sgeo|web shrugs
18:09:25 <gwern> I wonder if I've triggered a bug in pandoc; my spaced repetition article has been rendering for 4 minutes already
18:10:21 <gwern> (5 minutes)
18:23:51 <dmwit> hiptobecubic: mzero and mplus are just another pattern that some types happen to fit into.
18:27:11 <bog3yman> whats the easiest way to find the largest number in the list? e.g [1,2,3] returns 3?
18:27:26 <bog3yman> or simplest way*
18:27:28 <dmwit> :t maximum
18:27:29 <lambdabot> forall a. (Ord a) => [a] -> a
18:27:49 <dmwit> ?hoogle Ord a => [a] -> a
18:27:50 <lambdabot> Prelude maximum :: Ord a => [a] -> a
18:27:50 <lambdabot> Data.List maximum :: Ord a => [a] -> a
18:27:50 <lambdabot> Prelude minimum :: Ord a => [a] -> a
18:27:54 <dmwit> ;-)
18:28:00 <bog3yman> ah maximum function, ty
18:31:07 <Sgeo|web> > foldr f x [1..5]
18:31:08 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
18:31:12 <Sgeo|web> > foldl f x [1..5]
18:31:13 <lambdabot>   f (f (f (f (f x 1) 2) 3) 4) 5
18:31:36 <shachaf> @src maximum
18:31:37 <lambdabot> maximum [] = undefined
18:31:37 <lambdabot> maximum xs = foldl1 max xs
18:31:41 <shachaf> But what if I'm using lazy naturals?!
18:32:32 <geheimdienst> gwern: if i see a new page that's clearly spam on the "recent changes" wiki page, what button do i have to press to delete it? i know how to revert an edit, but deleting pages?
18:32:48 <Sgeo|web> Is there a reason for using foldl1 but not foldl1'?
18:32:59 <Sgeo|web> I remember reading that left folds should usually be strict
18:35:00 <shachaf> Sgeo|web: It's defined that way in the Report.
18:35:04 <ddarius> foldl1' is not in the Prelude.
18:36:32 <letrec> ?hoogle (a -> Bool) -> [a] -> [a]
18:36:32 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
18:36:33 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
18:36:33 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
18:38:05 <Sgeo|web> > putStrLn
18:38:06 <lambdabot>   Overlapping instances for GHC.Show.Show
18:38:06 <lambdabot>                              (GHC.B...
18:38:10 <Sgeo|web> > putStrLn "Hi"
18:38:11 <lambdabot>   <IO ()>
18:38:21 <shachaf> Sgeo|web: That's not how you do it.
18:38:34 <Sgeo|web> shachaf: It is when I want to see the Show instance for IO in action
18:38:43 <shachaf> > unsafePerformIO $ putStrLn "<IO ()>"
18:38:45 <lambdabot>   <IO ()>
18:39:11 <Sgeo|web> shachaf: I ... are you trolling? I think you're trolling
18:39:49 <Sgeo|web> I can't figure out how though, is unsafePerformIO in scope why? Can't be the real deal, can it?
18:39:49 <geheimdienst> > unsafePerformIO $ putStrLn "lolcats"
18:39:51 <lambdabot>   <IO ()>
18:40:04 <geheimdienst> @undef
18:40:06 <dbelange_> > wang
18:40:07 <lambdabot>   Not in scope: `wang'
18:40:10 <geheimdienst> > unsafePerformIO $ putStrLn "lolcats"
18:40:11 <lambdabot>   Not in scope: `unsafePerformIO'
18:40:28 <Sgeo|web> Was unsafePerformIO defined as id?
18:40:34 <shachaf> No.
18:40:35 <geheimdienst> some jokester defined unsafePerformIO = id. i'm looking at you shachaf
18:40:51 <shachaf> It was defined as unsafePerformIO x = x!
18:40:52 <shachaf> Come on!
18:41:24 <dbelange_> > (car (cdr []))
18:41:25 <lambdabot>   Not in scope: `car'Not in scope: `cdr'
18:41:39 <ddarius> @let unsafePerformIO = const (text "<IO ()>")
18:41:41 <lambdabot>  Defined.
18:41:53 <Sgeo|web> @define car = head
18:42:12 <Sgeo|web> @define cdr = tail
18:42:13 <shachaf> @let unsafePerformIO = const (text "<IO ()>")
18:42:14 <lambdabot>  Defined.
18:42:18 <shachaf> @let unsafePerformIO = const (text "<IO ()>")
18:42:19 * Sgeo|web derps
18:42:19 <lambdabot>  <local>:2:0:
18:42:19 <lambdabot>      Multiple declarations of `L.unsafePerformIO'
18:42:19 <lambdabot>      Declared...
18:42:30 <Sgeo|web> @let car = head
18:42:31 <lambdabot>  Defined.
18:42:31 <shachaf> @let car = take 1; cdr = drop 1
18:42:32 <lambdabot>  <local>:3:0:
18:42:32 <lambdabot>      Multiple declarations of `L.car'
18:42:32 <lambdabot>      Declared at: <local>...
18:42:33 <Sgeo|web> @let cdr  tail
18:42:37 <lambdabot>   TemplateHaskell is not enabled
18:42:40 * shachaf sighs.
18:42:41 <Sgeo|web> @let cdr = tail
18:42:42 <lambdabot>  Defined.
18:43:06 <shachaf> @botspamk
18:43:06 <Sgeo|web> Type-safety means no whatchamacallits, pair thingies
18:43:06 <lambdabot> :)
18:43:47 <Sgeo|web> I can't define datatypes in lambdabot, can I?
18:45:08 <geheimdienst> Sgeo|web: i don't think so
18:46:55 <hpaste> tgeeky pasted “i can has instances?” at http://hpaste.org/54146
18:47:38 <tgeeky> any takers on telling me precisely what I need to do for A
18:47:42 <tgeeky> http://hpaste.org/54146 <-- thanks!
18:56:06 <DukeDave> I'm fairly sure this has come up before, so my apologies:
18:56:06 <DukeDave> In my code I use "type Vertex = Int", and then I have a "Map Vertex Foo", now I would like to use some "Ord a" instead of "Int", what's the best way to proceed?
18:57:32 <shachaf> DukeDave: Change all your Vertex-operating functions to take an Ord constraint, I think.
18:58:22 <DukeDave> shachaf: Gah, the words "change", "all", and "functions" are ones I was hoping to avoid..
18:58:40 <DukeDave> And also, I'd *like* to keep the term 'vertex' some how..
18:58:50 <DukeDave> I suppose I could just use "Ord vertex"
19:00:21 <DukeDave> Is there any other approach?
19:02:28 <Sgeo|web> http://blog.ezyang.com/2011/11/how-to-read-haskell/ this might be the most evil thing I have ever read
19:03:01 <Sgeo|web> (Note: Prior statement not to be taken literally)
19:12:34 * ddarius choose to not take "read" literally.
19:13:51 <Sgeo|web> Suppose I have an Arrow instance, which obeys the Arrow laws
19:14:19 <Sgeo|web> I then turn it into an ArrowApply instance, and am unsure whether that addition still lets it obey the laws
19:14:31 <Sgeo|web> Will any Arrow law breakage be reflected as a breaking of the Monad laws?
19:19:25 <ddarius> You are changing the type so that it can be an instance of ArrowApply?
19:23:55 <Sgeo|web> ddarius: No, just adding an ArrowApply instance
19:28:13 <ddarius> Sgeo|web: That's not going to change the fact that it satisfies the arrow laws.
19:28:29 <Sgeo|web> Ok
19:28:40 <Sgeo|web> But I can still end up breaking the monad laws, I guess
19:37:47 <ddarius> Sgeo|web: If you fail to satisfy the ArrowApply laws, yes.
19:52:20 <parcs_> "GHC gets a new constraint solver. More efficient and smaller in size."
19:55:05 <byorgey> hurrah!
19:56:07 <ddarius> Is it a little more efficient, or is it SICP Prolog to BAM?
19:57:35 <byorgey> only Dimitrios Vytiniotis knows, and he doesn't hang out in here
20:14:31 * hackagebot graphviz 2999.12.0.4 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.12.0.4 (IvanMiljenovic)
20:40:35 <Cale> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=608497 -- lol, someone submitted proof of concept code for triggering buffer overflows in gimp written in COBOL :)
20:41:10 <byorgey> haha what
20:41:13 <Axman6> classy
20:42:15 <byorgey> 000040*SHOE SIZE DECLARATION.   43.
20:43:06 <Axman6> i was just about to paste that!
20:43:16 <Axman6> what is that, i don't even
20:43:16 * byorgey wins!
20:43:31 <byorgey> what do you mean, it is a shoe size declaration, obviously.
20:43:50 <byorgey> that's the nice thing about COBOL, everything is spelled out for you so you don't have to wonder what it is
20:44:53 <Cale> I like their convention of replacing random letters of variable names with following letters of the alphabet to indicate variations
20:49:40 <gerald> hello everyone, what's today
20:50:43 <byorgey> hi Guest3603, today is a good day for Haskell
20:51:26 <Guest3603> great byorgey
20:51:34 <shachaf> byorgey: Every day is a good day for Haskell!
20:51:44 <shachaf> Other than yesterday. Yesterday was not good at all.
20:51:50 <monochrom> @hoogle today
20:51:50 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
20:51:51 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYearValid :: Bool -> Int -> Int -> Maybe Int
20:51:51 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
20:52:54 <Guest3603> still summer in my town, so can be sun bathing all day byorgey
20:53:00 <Guest3603> how abaut u byorgey
20:53:32 <byorgey> Guest3603: the weather here is not so good for sunbathing.  but it is great for Haskell.
20:54:58 <Guest3603> alright good day for Haskell byorgey
20:55:48 <Guest3603> where are u  come from byorgey
20:57:40 <byorgey> Guest3603: Philadelphia, and you?
21:02:40 <PatrickRobotham> byorgey: Thank you for writing the Typeclassopedia, It's been great for getting me in to the weird and wonderful world of the Haskell type system. :)
21:03:18 <byorgey> PatrickRobotham: great! glad you have found it useful =)
21:03:43 <shachaf> PatrickRobotham: Consider thanking byorgey in advance for Typeclassopedia 2.0.
21:03:49 <shachaf> Then he'll have no choice but to write it.
21:04:08 * PatrickRobotham seals his thankyous in a time capsule
21:04:35 <monochrom> no, it's lazy evaluation, your gratitude drives the writing
21:05:00 <PatrickRobotham> I thought the writing drives my gratitude.
21:05:25 <PatrickRobotham> Oh well, thank you in advance for writing the Typeclassopedia 2 byorgey
21:05:27 <monochrom> that's eager evaluation, which you're used to, yes
21:50:39 <Sgeo|web> There were tiny updates to the Typeclassopedia?
21:59:01 <Sgeo|web> fmap (g . h) = (fmap g) . (fmap h)
21:59:32 <Sgeo|web> How does that law make sense? I mean, I'm guessing it has something to do with Categories, but the Typeclassopedia isn't there yet
21:59:39 <Sgeo|web> Erm, I'm not there yet in the Typeclassopedia
22:00:01 <shachaf> fmap (fmap fmap fmap) = fmap (fmap fmap) (fmap fmap)
22:00:08 <shachaf> Sgeo|web: How does it make sense in what way?
22:00:43 <mzero> Sgeo|web: Are you asking why that law is there? or why that law is useful, or sensical, for programming?
22:00:45 <shachaf> It's indeed part of the definition of functors in category theory.
22:00:52 <Sgeo|web> fmap g and fmap h aren't guaranteed to be functions, are they?
22:01:00 <mzero> yes they are
22:01:03 <shachaf> Although members of the Functor class in Haskell are actually endofunctors in Hask.
22:01:11 <Sgeo|web> ...Oh, ugh
22:01:11 <shachaf> Sgeo|web: Sure. fmap :: (a -> b) -> (f a -> f b)
22:01:18 <Sgeo|web> Derp
22:03:36 <Sgeo|web> "fmap g . point  =  point . g ∗ ... modulo ⊥, seq, and assuming a lawful Functor instance. However, you need not worry about it: this law is actually a so-called “free theorem” guaranteed by parametricity"
22:03:45 <Sgeo|web> Erm, that copy/paste got butchered
22:04:13 <Sgeo|web> But is it fmap g . point = point . g still true if the Functor laws are broken?
22:04:26 <Sgeo|web> Oh,
22:04:44 <Sgeo|web> It mentions it in the sidebar, which I accidentally copied but didn't read
22:04:50 * Sgeo|web is in a derpy mood, apparently
22:05:12 <copumpkin> @free point :: a -> f a
22:05:13 <lambdabot> Extra stuff at end of line
22:05:21 <Sgeo|web>  @free?
22:05:23 <Axman6> too much stuff!
22:06:08 <shachaf> @free point :: a -> F a
22:06:08 <lambdabot> $map_F f . point = point . f
22:44:36 <Sgeo|web> mlt doesn't have MaybeT yet?
22:46:01 <parcs_> it's in the parent package 'transformers': http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-Maybe.html
22:46:26 <Sgeo|web> Typeclassopedia mentions mdo
22:46:32 <Sgeo|web> Shouldn't it use rec or something?
22:46:54 <byorgey> oh, yeah, I think  do rec  is the new syntax replacing  mdo
22:47:11 <byorgey> it was accurate at the time I wrote it =)
22:47:55 <shachaf> byorgey: Typeclassopedia mentions import renaming. Shouldn't it be import qualified?
22:49:18 <Sgeo|web> But someone did some updates in September, they should have caught it!
22:49:19 <Sgeo|web> >.>
22:50:07 <byorgey> Sgeo|web: eh? updates in september?
22:51:25 <Sgeo|web> Oops, November
22:51:26 <Sgeo|web> "As published 12 March 2009, issue 13 of the Monad.Reader, with tiny November 2011 updates by Geheimdienst"
22:51:28 <rwbarton> byorgey: Typeclassopedia mentions Haskell. Shouldn't it be Agda?
22:51:47 <shachaf> Huh, there's an inline wikisyntax version of Typeclassopedia.
22:51:49 <Sgeo|web> http://www.haskell.org/haskellwiki/Typeclassopedia
22:53:53 <byorgey> oh, geheimdienst made a wikified version
22:55:22 <shachaf> "Someone in the #haskell IRC channel used (***), and when I asked lambdabot to tell me its type, it printed out scary gobbledygook that didn't even fit on one line! Then someone used fmap fmap fmap and my brain exploded."
22:55:47 * shachaf feels like that's a personal attack.
22:59:25 <Sgeo|web> :t (***)
22:59:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:59:32 <Sgeo|web> That fits on one line!
22:59:42 <strager> Not on an 80-char term!
22:59:58 <Sgeo|web> And most of that goobledy gook is just excess gunk produced by :t
23:00:16 <shachaf> > length "07:13 < lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')"
23:00:17 <lambdabot>   106
23:00:24 <shachaf> > length "forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')"
23:00:25 <lambdabot>   87
23:00:33 <c_wraith> yep.
23:00:33 <shachaf> Lines are, like, 80 characters, man.
23:00:36 <c_wraith> doesn't fit on a standard line
23:00:41 <c_wraith> "standard"
23:01:08 <Sgeo|web> > length "(Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')"
23:01:09 <lambdabot>   50
23:02:16 <shachaf> > length "Arrow a=>a b c->a d e->a(b,d)(c,e)"
23:02:17 <lambdabot>   34
23:02:28 <strager> If you write Haskell like that, I will strangle you.
23:03:02 <shachaf> Strangler Neds
23:03:15 <strager> Rawr.
23:03:43 * Sgeo|web doesn't write Haskell like that. He writes Haskell like: 'H':'a':'s':'k':'e':'l':'l':[]
23:04:02 <Sgeo|web> Yay for combining two crappy jokes
23:04:09 <mauke> > length "Arrow(/)=>b/c->d/e->(b,d)/(c,e)"
23:04:10 <lambdabot>   31
23:04:26 <shachaf> mauke++
23:04:35 <mauke> > undefined :: Arrow(/)=>b/c->d/e->(b,d)/(c,e)
23:04:36 <lambdabot>   Overlapping instances for GHC.Show.Show
23:04:36 <lambdabot>                              ((/) b...
23:04:41 <mauke> nice
23:05:07 <shachaf> mauke: Not Haskell 98, though.
23:05:07 <mauke> :t (***) :: Arrow(/)=>b/c->d/e->(b,d)/(c,e)
23:05:08 <lambdabot> forall (/ :: * -> * -> *) b c d e. (Arrow (/)) => (/) b c -> (/) d e -> (/) (b, d) (c, e)
23:05:23 <shachaf> Hmm, that's a bug in the pretty-printing, isn't it?
23:05:31 <shachaf> Should be ((/) :: * -> * -> *)?
23:08:42 <copumpkin> quotienting is an arrow?
23:08:53 <copumpkin> the kind of the second parameter feels wrong :)
23:09:03 <marvinalone> I have a Data.Map, and I'm using map on it to produce a different map. The problem is that the transforming function returns a Maybe. Is there a mapM for Data.Map?
23:09:18 <copumpkin> marvinalone: you want mapM or mapMaybe?
23:09:41 <Axman6> mapM would fail as soon as you get a Nothing value
23:09:43 <marvinalone> copumpkin: I do want mapM, but there isn't a definitio for it.
23:09:48 <copumpkin> marvinalone: it's in traversable
23:10:01 <copumpkin> look at traverse in Traversable
23:10:08 <copumpkin> there's an instance for Map k
23:12:21 <marvinalone> It doesn't work. It says "Couldn't match expected type `[a]' against inferred type `ClassMap'". ClassMap is Map.Map String String.
23:13:01 <marvinalone> i think my mapM comes from Control.Monad, not from Data.Traversable
23:15:16 <c_wraith> yes, that can happen.  import the other one
23:15:32 <c_wraith> :t Data.Traversable.mapM
23:15:33 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:15:39 <marvinalone> i put int a bunch of hiding. now I know what's that for :-)
23:25:31 <Sgeo|web> Typeclassopedia suggested working out how to define >>= in terms of join
23:25:47 <Sgeo|web> I think I can do it using `ap` too, but I'm not sure how ap is defined
23:25:49 <Sgeo|web> @src ap
23:25:49 <lambdabot> ap = liftM2 id
23:25:55 <Sgeo|web> @src liftM2
23:25:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:25:59 <Sgeo|web> ...
23:26:17 <c_wraith> ap is not sufficient
23:26:22 <Sgeo|web> Well, for it to be a monad, it, in a mathematical sense, should define <*>, right?
23:26:25 <c_wraith> since ap is equivalent to <*>
23:26:41 <Sgeo|web> c_wraith: I meant using join and ap
23:27:05 <c_wraith> hmm.  That doesn't sound right.
23:27:14 <c_wraith> oh.  you can do it with ap, join, and return
23:28:16 <c_wraith> but how it's defined isn't as important as the type
23:28:24 <c_wraith> with this exercise, you'll know if it's right just by the type
23:28:31 <Sgeo|web> k >>= f = join $ return f <*> k
23:28:58 <Sgeo|web> :t \k f -> join $ return f <*> k
23:28:59 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Applicative m) => m a1 -> (a1 -> m a) -> m a
23:29:06 <c_wraith> yep
23:29:08 <c_wraith> that's right
23:29:13 <Sgeo|web> Yay!
23:29:37 <shachaf> Hmm, I wonder if ap is a good primitive for monads in general.
23:29:38 <c_wraith> a crucial observation here come from Applicative
23:30:05 <c_wraith> where f <$> x is defined (in the literature, not in the implementation) as pure f <*> x
23:30:13 <shachaf> Given that it can sometimes be implemented more efficiently than the thing you can make with >>=.
23:30:58 <Sgeo|web> k >>= f = join $ f <$> k
23:31:01 <Sgeo|web> erm
23:31:12 <c_wraith> also true
23:31:13 <Sgeo|web> :t \k f -> join $ f <$> k
23:31:14 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
23:39:05 <piccollo> hi. anyone there can offer me help ? ;o
23:39:34 <piccollo> or everyone asleep :P
23:39:58 <XexonixXexillion> piccollo: What's the problem?
23:41:01 <piccollo> given i have a list, e.g. [[1,2],[2,1],[1,2,3] ... how do i go about removing the duplicates (in this case remove [1,2] OR [2,1]) ... i know there's a function called nubby which can solve it i think, but i'm not sure on the syntax/how to define it
23:41:14 <piccollo> give i have a list of lists*
23:41:22 <shachaf> piccollo: Is this an assignment from a class?
23:41:30 <shachaf> I think we had this exact problem, with the same example list, earlier today.
23:43:13 <piccollo> ah no worries, i will research myself on how to use the function :)
23:46:34 <XexonixXexillion> piccollo: Not a very efficient way to do it, but why not convert each of the lists to a set, convert your list of sets to a set, and then convert it back to a list of lists
23:46:36 <marvinalone> isSame a a = True   -- will this work?
23:47:46 <marvinalone> the answer is no
23:51:40 <sp3ctum> maybe it needs a function, like isSame a = (==) a
23:55:04 <marvinalone> sp3ctum: it was a simplified example
23:55:34 <salisbury> are there any ottawa haskellers out there?
23:56:44 <danr> marvinalone: you could actually do that in Miranda, a language Haskell is very much inspired from. And you can do like that it in Erlang
23:58:45 <shachaf> marvinalone: What would you want it to do?
23:58:47 <shachaf> Compare with (==)?
23:59:45 <marvinalone> shachaf: yes ... but from the question alone i can see that there are problems with that
