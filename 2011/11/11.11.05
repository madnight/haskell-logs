00:19:39 <copumpkin> @ask jaspervdj I think I've asked you this before, but it was ages ago for an old hakyll and I forgot the answer anyway: what would be the best approach to writing a custom code highlighter for hakyll? I'm flexible regarding input and output formats, and can take and generate just about anything
00:19:39 <lambdabot> Consider it noted.
01:15:50 <amtal> Are there any bit-level combinatoric parsers?
01:15:59 <amtal> I want to parse non-aligned bitstreams without writing my own thing :)
01:18:34 <gienah> amtal: there is attoparsec
01:22:41 <edwardk> amtal: i have a small bit-packed version of binary somewhere, not sure if it ever made it to hackage though
01:22:55 <edwardk> and its not really a parser combinator library at that
01:25:01 <amtal> I had something small I was writing myself, but I wasn't planning to use it with an existing parser library.
01:25:29 <amtal> And was more interested in providing detailed printouts + backtracking and re-trying to parse if something failed.
01:44:56 <amtal> Hm. It looks like I -could- implement a custom MonadParser for trifecta that worked on non-bytealigned binary data. Then I'd get existing goodness + be able to implement a few of my own operators to do bit ops.
01:45:12 <edwardk> yeah
01:45:35 <edwardk> you'd want to patch the Renderer to do something smarter about showing non-ascii characters though
01:45:51 <edwardk> that is if you want to use the diagnostics
01:46:27 <edwardk> i'd been meaning to get around to patching it so the renderer showed multi-character proxies for non-displayable characters, but it hasn't been at the top of my priority list yet
01:46:53 <edwardk> right now the only one I have is the hacked in <EOF> at the end of the stream
01:46:58 <amtal> Hm. With that as a primitive, I could implement the "backtrack and retry with different bit offsets" attempt at handling parse failures at a higher level.
01:47:33 <amtal> I'm not sure what the right way of solving my problem is, really - I just want something smart for reverse engineering bit-packed binary protocols.
01:47:47 <edwardk> hrmm
01:48:10 <edwardk> grabbing it off the wire?
01:49:09 <amtal> Off a dump to file, more likely.
01:49:30 <amtal> So no partial parsing needed, just want something that automatically tries handling gaps in knowledge.
01:51:12 <edwardk> i wonder if it'd be better to try to figure out a way to do so using an LR-like parser as a base that way you can do nice recovery and start parsing again once it fits the format
01:52:02 <edwardk> easier than when scanning forward using LL-ish techniques
01:54:33 * hackagebot uniplate 1.6.4 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.4 (NeilMitchell)
01:57:36 <hpaste> Harishankar pasted “Not getting why this pattern matching doesn't work properly” at http://hpaste.org/53588
01:57:49 <amtal> Also, the maintainers/writers of CoreErlang haven't responded to my requests to push a patch. Maybe the emails listed are defunct, but I think it's time to try the takeover route.
01:59:01 <vharishankar> Not sure why the above code doesn't work correctly. It always returns TokenUnrecognized (Trying to do posfix evaluator on my own)
02:01:43 <amtal> What kind of input are you passing it?
02:02:09 <vharishankar> amiri: I pass a stream of tokens like [TokenNum 12, TokenNum 15, TokenSym SymMinus]
02:02:16 <vharishankar> Sorry amtal
02:03:15 <vharishankar> It works correctly for a single token like [TokenNum 12]
02:03:18 <amtal> An aside: in the recursive cases, 'toks' may be []. So they actually handle terminal cases too.
02:04:27 <vharishankar> amtal: I expected it to work that way. Not sure why the pattern compute_expression (TokenNum num:toks) stack never seems to match
02:05:26 <vharishankar> It appears that only the last pattern is getting matched.
02:05:29 <amtal> Oh, I think `eval toks [TokenNum (b+a)]++stack` should have ( ) around the [...]++stack
02:05:58 <amtal> Function application has higher priority than ++, ends up doing (eval toks [...]) ++ stack.
02:07:10 <vharishankar> amtal: thanks.
02:07:37 <vharishankar> Let me try that.
02:08:09 <hpaste> amtal annotated “Not getting why this pattern matching doesn't work properly” with “Not getting why this pattern matching doesn't work properly (annotation)” at http://hpaste.org/53588#a53589
02:09:55 <vharishankar> amtal: thanks.
02:15:08 <vharishankar> amtal: it works fine now.
02:15:35 <vharishankar> Thank you for the correction. I was so confused as to why it didn't work. Because everything seemed right.
02:16:26 <amtal> Yeah, infix operators being less sticky than function argument applications takes a moment to get used to. :)
02:17:03 <amtal> Once you figure out that 'foo bar baz' is always top priority, you can start writing some really succinct code.
02:18:08 <vharishankar> amtal: I am learning slowly. I am now beginning to understand how functions work in haskell
02:19:46 <vharishankar> Actually surprisingly I never created an expr evaluator in any other programming language before
02:20:06 <vharishankar> this is my first attempt, because Haskell provides such elegant pattern matching.
02:21:58 <amtal> Yeah, it actually works really well :) Once you start building complex ASTs with all kinds of mixed types... You've got the parsers to parse 'em, the pattern matching to use 'em, and the typechecking to not make dumb mistakes. (Provided your types are heterogeneous enough, and not all lists of symbols ;))
02:22:20 <amtal> It gets even better when you're dealing with large ASTs and discover Uniplate/SYB.
02:25:43 <vharishankar|2> Sorry I got disconnected. Sudden power cut.
02:27:24 <vharishankar|2> Hello
02:28:40 <vharishankar> Not sure if I am still connected. If anybody can read this please respond. :-)
02:29:27 <Cale> I can
02:29:57 <shachaf> Cale is the only one who can read that, though.
02:30:01 <shachaf> It's one of his superpowers.
02:30:18 <vharishankar> Cale: thanks. I was disconnected and started typing into vaccuum.
02:30:47 <mike-burns> I'm having trouble finding this documented, though it might be obvious: does Network.HTTP support HTTPS?
02:31:37 <shachaf> mike-burns: I was told that it doesn't.
02:32:07 <mike-burns> I wish that were in the README.
02:32:52 <rostayob> why is it that some mantainers put upper bounds on minor versions?
02:32:53 <mike-burns> Aha, there's a Github Issue for it.
02:32:56 <rostayob> like < 1.2.
02:33:26 <rostayob> doesn't that cause more annoyances than anything else?
02:41:10 <mike-burns> OK I need library help: I want to do a HTTPS POST. Which library do I use?
02:41:27 <c_wraith> http-enumerator, probably
02:41:38 <Saizan> rostayob: if you follow the PVP the first two components of the version are the "major version"
02:41:48 <mike-burns> Oh maybe http-enumerator can do it.
02:41:51 <mike-burns> Thanks c_wraith .
02:48:43 <rostayob> Saizan: oh. so the convention is to set the upper bound to the second component?
02:48:55 <rostayob> in my experience, it is unneded most of the times
02:51:09 <mgccl> p x = g ((f x) (h x)), how to make it pointfree? it seems currently I only have ability to make things pointfree if the variable only shows up once
02:51:32 <mgccl> typo p x = g (f x) (h x)
02:51:38 <shachaf> @pl p x = g (f x) (h x)
02:51:38 <lambdabot> p = liftM2 g f h
02:51:44 * shachaf trumpets
02:52:35 <mgccl> woah! the bot can do this automatically...
02:52:38 <mgccl> thx
02:53:16 <shachaf> mgccl: Also read about S and K.
02:56:28 <mgccl> shachaf: this? http://www.haskell.org/haskellwiki/Type_SK
02:57:17 <dobblego> @google ski combinator calculus
02:57:18 <lambdabot> http://en.wikipedia.org/wiki/SKI_combinator_calculus
02:57:18 <lambdabot> Title: SKI combinator calculus - Wikipedia, the free encyclopedia
02:57:22 <dobblego> that ^^
02:57:28 <Jafet> @quote ski
02:57:28 <lambdabot> ski says: our tribe is better than their tribe <companion_cube> we have advanced technologies like fire or STM !
02:57:36 <shachaf> @google combinatory logic
02:57:37 <lambdabot> http://en.wikipedia.org/wiki/Combinatory_logic
02:57:37 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
02:57:39 <shachaf> That.
02:58:37 <shachaf> You can convert any lambda expression to point-free form using two combinators, S x y z = (x z) (y z) and K x y = x
02:58:51 <shachaf> And I x = x, but I = S K K
02:59:09 <shachaf> S duplicates a variable and K eliminates it, in a sense. :-)
03:00:18 <mgccl> I see...
03:00:47 <shachaf> In Haskell, const = K and ap = S
03:00:59 <shachaf> ap is also a bunch of other things, though; it's S almost by accident.
03:02:33 <mgccl> so all these solution use monads, are there ones that doesn't use monads?
03:03:06 <shachaf> What does "use monads" mean?
03:03:37 <mgccl> Monad m => m (a -> b) -> m a -> m b   so m has to be a monad
03:04:01 <dobblego> it is not possible to write a computer program without "using monads"
03:04:01 <shachaf> Every time you use a function you're "using monads".
03:04:18 <shachaf> In this particular case, the monad in question is (r ->).
03:04:26 <dobblego> it is possible to write computer programs "without knowing you're using monads"
03:04:29 <shachaf> So ap :: (r -> a -> b) -> (r -> a) -> r -> b
03:06:36 <mgccl> I see... I wonder when will I "get" Haskell like you do...
03:13:01 <jpcooper> hello
03:13:11 <jpcooper> could anyone suggest how to get around the lack of @ patterns in Agda?
03:19:18 <Saizan> a with?
03:23:56 <paolino1> hello , When wrapping up a Float , it seems that fromRational . toRational is a way to get its value without unwrapping. Is there a better way, avoiding the computation of a Rational ?
03:25:19 <paolino1> @hoogle Floating a => Floating -> a
03:25:20 <lambdabot> Warning: Unknown type Floating
03:25:20 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:25:20 <lambdabot> Prelude acos :: Floating a => a -> a
03:26:01 <paolino1> @hoogle (Floating a, Floating b) => b -> a
03:26:01 <lambdabot> Prelude acos :: Floating a => a -> a
03:26:01 <lambdabot> Prelude acosh :: Floating a => a -> a
03:26:02 <lambdabot> Prelude asin :: Floating a => a -> a
03:31:14 <Jafet> Well, it's easier if you don't need it to be polymorphic
03:31:44 <Jafet> (So, why do you need it to be polymorphic?)
03:40:41 <paolino> Jafet, I don't need it to be polymorphic, I was trying to avoid the selector, which is not the purpose of a class method I guess
03:42:24 <paolino> but then fromInteger and fromIntegral seem sensible to the objection too
03:45:07 <mgccl> If I use liftM2, I get an error that want me to add a instance. so I wonder what's the point since I can write the function lift2 h f g x = h (f x) (g x) and use that all the time instead.
03:47:16 <danr> mgccl: you need to add import Control.Monad.Instances
03:47:33 <paolino> mgccl: which instance ?
03:47:51 <danr> paolino: ((->) e)
03:47:57 <paolino> ok
03:48:07 <paolino> liftA2 should suffice
03:48:53 <tenniscp25> how long have you guys programmed in haskell?
03:48:58 <danr> paolino: yes, true
03:49:06 <danr> if you have Control.Applicative imported
03:49:30 <danr> tenniscp25: 3,5 years here, why? :)
03:49:36 <mgccl> oh that works! thx
03:50:39 <tenniscp25> nothing.. just feeling.. lost. i've just started reading a haskell book for about a week.
03:51:27 <paolino> tenniscp25: I must sum a lot of distant (in time) pieces of time, maybe 1 year and a half, or 2
03:51:59 <sipa> tenniscp25: which book?
03:52:35 <tenniscp25> learn you haskell
03:53:03 <tenniscp25> pretty easy to follow but when i start doing stuff.. it's really hard to wrap my head around functional concepts.
03:53:41 <paolino> tenniscp25: but I'm sure it would take a lot more if I kept trying when my brain was not able to learn
03:56:27 <paolino> in the end I think learning haskell is overheating , which is not a perfect brain state to learn
03:56:42 <paolino> *for learning
03:57:19 <tenniscp25> hmmm...
03:57:50 <paolino> obviously there are icy brains around :)
03:58:57 <paolino> tenniscp25: what programming background you have ?
03:59:53 <Cale> tenniscp25: I've been programming in Haskell for around 10 years. It originally took me about 2 months before I felt like I could do much with Haskell, and about a year to really feel comfortable.
04:00:34 <gseitz> Cale: about a year of daily use?
04:00:37 <tenniscp25> java, groovy for years and few months of scala
04:00:42 <Cale> (though I was studying a bunch of math courses at the time, and not really using it daily)
04:02:16 <paolino> abandoning objects is not easy, you must be firm there is another way
04:03:00 <tenniscp25> cale: what kind of software have you programmed in haskell?
04:03:30 <paolino> @type (.)
04:03:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:03:35 <paolino> this one
04:04:01 <Cale> tenniscp25: Well, right now I'm working for a startup called iPwn studios, on a game for iPhones and other mobile devices in Haskell.
04:04:18 <silver> woo
04:04:19 <silver> cool
04:04:25 <silver> games in Haskell
04:04:37 <Cale> (It's a sort of Diablo-esque action RPG called BloodKnight)
04:04:38 <tenniscp25> wow
04:05:05 <silver> the mighty-freaking-ducks of the video game world
04:05:06 <silver> lol
04:05:28 <Cale> and previously, probably the largest project that I'd done was a register allocator and instruction scheduler for PPC+Altivec, as part of a project writing a special purpose compiler in Haskell for signal processing applications.
04:07:04 <silver> when I was like 13 I had a hat with with mighty ducks logo, and since then a was a fun because of that funny duck-logo (they couldn't go to play-offs atm). And later when I grew up I was really pleased to know that guys playing finals
04:07:27 <silver> sorry for the off-topic
04:07:29 <Cale> (We had a clever bit of PPC + Altivec assembly that was 30 some-odd instructions long, and my scheduler made it run, iirc, 16 or 17 clocks, and it outputted 4 sines and 4 cosines every clock. Practical performance (including loads and stores into the picture) was about 2.5 clock cycles/float
04:07:55 <Cale> By contrast, if you call the GNU math library's sine function, it takes around 200 clock cycles)
04:09:00 <tenniscp25> (+_+"
04:11:54 <savask> Hello. I read that fusion optimization is implemented with rewrite rules in GHC. Where are these default rules written?
04:15:54 <luite_> they're RULES pragma's in the source code: see for example http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/src/Data-Vector-Fusion-Stream.html#inplace
04:16:50 <savask> And where are rules for default functions, like map and filter? In the Prelude?
04:17:45 <luite_> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/src/GHC-Base.html#map
04:18:40 <savask> Thanks.
04:29:43 <chridi> is it better to use a two dimensional array or a list of lists?
04:29:56 <chridi> (for performance reasons)
04:34:11 <c_wraith> chridi: they're entirely different for performance.  It depends on what you're doing
04:34:47 <zzo38> Parsec seem it does not follow the MonadPlus laws!
04:34:49 <chridi> I'm implementing a game strategy for a board game
04:36:09 <chridi> Ill just use arrays ;)
04:36:10 <zzo38> It doesn't have   v >> mzero = mzero   because if v is consuming some input, then it will be error instead of mzero
04:36:47 <c_wraith> MonadPlus doesn't have a set of laws
04:36:55 <c_wraith> it has multiple conflicting sets of laws
04:39:33 <zzo38> c_wraith: Like, how is that?
04:42:51 <c_wraith> IO and [] handle MonadPlus very differently.
04:43:07 <zzo38> Is there instance of MonadPlus for IO?
04:43:27 <zzo38> I did manage to make a instance of Alternative for IO.
04:43:30 <c_wraith> yeah, though it's hidden with, like...  MonadError
04:43:59 <zzo38> instance Alternative IO where { empty = fail []; x <|> y = catch x $ \e -> modifyIOError (\z -> if z == userError [] then e else z) y; };
04:46:28 <zzo38> I think this one is properly identity and associative.
04:47:21 <Cale> zzo38: The MonadPlus instance for IO is basically a (sometimes handy) simplified way to handle exceptions.
04:47:49 <zzo38> Cale: I wrote the Alternative instance for a similar purpose.
04:48:15 <zzo38> In addition, it allows using many, some, and optional.
04:49:24 <zzo38> For example you can write:   main = many getLine >>= print . length;
04:49:37 * hackagebot uniplate 1.6.5 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.5 (NeilMitchell)
04:50:54 <zzo38> How does the MonadPlus IO work? Is it anything similar to what I have?
04:54:13 <Cale> zzo38: x `mplus` y tries x, and if x throws an exception, it proceeds with y
04:54:18 <Cale> m `mplus` n = m `catch` \_ -> n
04:54:30 <Cale> mzero       = ioError (userError "mzero")
04:54:39 <zzo38> Cale: So, it is something similar to what I have.
04:55:08 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal -- this might interest you :)
04:55:36 <zzo38> But I don't think it is right because it does not seem to have the identity law proper.
04:55:47 <Cale> This reform hasn't taken place, but it makes clear the different concepts which are currently smashed together and called MonadPlus
04:56:07 <Cale> also http://www.haskell.org/haskellwiki/MonadPlus
04:57:29 <zzo38> It is why I use Alternative instead.
04:58:33 <Cale> Heh, unfortunately, Alternative has the same problem.
04:59:01 <Cale> (though the comments at the bottom of the page seem to indicate at least one person who thinks it should be left-catching)
04:59:02 <zzo38> Alternative simply has to have an identity and associative; I think I made it properly follow identity by making it, you can use empty to propagate the previous error.
04:59:07 <Cale> yeah
04:59:42 <zzo38> According to the official documentation it simply forms a monoid.
04:59:48 <zzo38> (That is, for Alternative)
05:00:51 <zzo38> So I think that makes my instance work.
05:03:00 <zzo38> However, guard is a useful command; and the laws for MonadPlus are followed for Maybe and [] (that is, in addition to making a monoid, mzero >> x = x >> mzero = mzero)
05:03:58 * hpc thinks MonadPlus can get by fine with just Monoid and Left Zero laws
05:04:08 <hpc> using mplus on two non-zero values is just a bonus
05:04:30 <hpc> and can do whatever makes sense in the current monad
05:05:03 <zzo38> hpc: I think what you said is reasonable.
05:07:23 <zzo38> It can satisfy Monoid and Left Zero laws; so that every MonadPlus is Alternative but not every Alternative is MonadPlus. (And the Alternative IO instance I wrote does in fact satisfy  mzero *> v = mzero  as far as I can tell.)
05:07:35 <hpc> the other possible set of laws is "don't be a duplicate of Alternative", i suppose
05:07:37 <zzo38> Or, I mean,   empty *> v = empty
05:07:38 <hpc> yeah
05:10:17 <zzo38> But [] and MonadPlus do satisfy the MonadPlus laws specified in the official documentation.
05:10:46 <hpc> MonadPlus satisfies the MonadPlus laws?
05:10:49 <hpc> fascinating! :P
05:10:57 <zzo38> Sorry, I mean [] and Maybe
05:13:06 <zzo38> And can be used like:   x <$ guard (x > 5)   and   guard (fst x) >> lines (snd x);
05:13:35 <hpc> :t guard
05:13:36 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
05:14:09 <zzo38> With the Maybe monad it seem useful to use guard with <$ and with list monad it is useful to use with >>
05:17:57 <zzo38> I think the laws (x >> mzero = mzero >> x = mzero) could be known as "annihilation laws" by its similarity with the annihilation laws for semirings.
05:33:15 <Phlogistique> Hi
05:33:35 <Phlogistique> I'm editing a project called HOE, which provides two executables
05:34:21 <Phlogistique> called 'runhs' and 'hoe'
05:34:37 <Phlogistique> so in it's src folder it has one HOE.hs file and one runHS.hs file
05:34:43 <Phlogistique> which is normal
05:34:59 <Phlogistique> but it also has a Main.hs which is a copy of HOE.Hs
05:35:23 <Phlogistique> I'm unsure if this is made necessary by Cabal, or by a misconfiguration in Cabal's .cabal
05:35:28 <Phlogistique> https://github.com/tanakh/hoe/blob/master/hoe.cabal
05:35:40 <Phlogistique> (I'm not the original author)
05:46:51 <zzo38> mappend (WrapMonad x) (WrapMonad y) = WrapMonad $ liftM2 mappend x y; mpappend (WrapMonad x) (WrapMonad y) = WrapMonad $ mplus x y;  What will be the distributive properties (assuming mplus follows the annihilation properties)? It seems to be right-distributive but not left-distributive? Is that it?
05:47:42 <ClaudiusMaximus> Phlogistique: try cabal sdist and see what gets tarballed, then check that it still builds/installs from that - i'm guessing the Main.hs is irrelevant/unused
05:55:10 <Phlogistique> ClaudiusMaximus: thanks
06:04:37 * hackagebot compose-trans 0.1 - Composable monad transformers  http://hackage.haskell.org/package/compose-trans-0.1 (MiguelMitrofanov)
06:09:46 <gregnarg> What is hibbit
06:10:01 <gregnarg> ?? ???? norgs ?? ???? ??? ???? ??? ??? ??? ... ?? KORG Keyboargs ?? ???? ??? ??? ??? ???!
06:10:01 <lambdabot> Plugin `compose' failed with: Unknown command: "??!"
06:10:02 <gregnarg> ??? ???? ???? ???? ???. ??? ?? ???? ?? ??? ????. ??? ??????? ?????? ????.
06:10:03 <gregnarg> ?? ???? ?? ??? ????. ?? ????? attendants ?? ???? ?????. ?? ?? ?????? ?? ?? ?? ?? ?????.
06:10:03 <lambdabot> Plugin `compose' failed with: Unknown command: "????."
06:10:04 <gregnarg> ??? ?? ???? ???? ??. ?? ?????????? ?? ??? ??????. ??? ?? ?????? ???? ???.
06:10:05 <gregnarg> ????? ???? ?????? ???? ?? ??? ??? ???? ??. ??? ????? ????
06:10:06 <gregnarg> ??? ???? ??????. ????? ?? ???? ?? ????? ???? ??. ?? ?????? ?? ?? ?????? ?? ?????? initializes. ?????? ??? ??????? ?? ?????? ?? ???.
06:10:07 <gregnarg> ????? ?????? ??????? ?????? ??? ???????? ?????. ???? ?? ??? ?? ????????? ??????? ?????? ?? ???? ???? ?? ?? ?????? ?? ???? ????.
06:10:08 <gregnarg> ?? ????????? ???? ??????? ???? ???. ?? ?????????? ?????? ?? ??? ?????? ?????? ???. ????? ?? ???? ?? ??? ?? ?????.
06:10:08 <lambdabot> Plugin `compose' failed with: Unknown command: "????."
06:10:09 <gregnarg> ?? ?? ???? ???? ??? ??? ?? ??? ???? ?? ??? ???????. ????????? ???? ??????? ?? ???? ???? ???? ??? ?? ???? ???? ??????. ?? ????? ???????????? ???? ??? ??? ?? ????????.
06:10:09 <lambdabot> Plugin `compose' failed with: Unknown command: "???????."
06:10:10 <gregnarg> Rumina bibbidle ????? ?? ???? ?????? ?? ???? ???? ????.
06:10:11 <gregnarg> ????? ?????? ???? ?????? ??????. ?? ??? ?? ?????? ?? ????????? ?????? ?????. ??? ?? ??? ?? ???? ?? ??????? ??? ??????
06:10:12 <gregnarg> ???????? ??? - ???? ???? ????? ???? ???? ??? ????? frowning ??????? ?????? ?? ??? congests. ?? ????? ???????? ?? ???? ???? ?? ??????? bobs.
06:10:13 <gregnarg> ?? ???? ??? ?????? ???? ??? rants. ??? ?? ???? ?? ???? ?????? ?? ??? composes. ??? ???? sectored ???????? founds.
06:10:13 <lambdabot> Plugin `compose' failed with: Unknown command: "???????"
06:10:14 <gregnarg> ?????? ???? ?????? teck ????? ???? ???? ?? ??? teck
06:10:15 <gregnarg> ?? ???? ??? ?? ????? ??? ???? ??. ?????? ???????? ????? ??????. ???? ?????? ???? ?????? ??????? ???? ???? ?? raves.
06:10:15 <lambdabot> Plugin `compose' failed with: Unknown command: "???"
06:10:16 <gregnarg> ??????? ??????? ????? ??. ???? ?? ???? ?? ?? ???? ????? ????.
06:10:17 <gregnarg> ????????? ????????? ??????? ????????? ??? ?? ???? ??.
06:10:18 <gregnarg> ??? ?? ??? ?? ?????? ?????? ???? ?? ??? ???? ???. ?? ??????? ??? ???? ??? ??? biases. ???? ??? ???? ?????. ????? ??? ??? ????????? ??? ?? ???? ??? moans.
06:10:19 <gregnarg> GmJ ?? ???? ??? ?????. ?? ????? ????? ?? ???? ???? ?????? ??????? ?????????. ?? ????? ??????? ?? ????? ????? ????? ??. ???? ?? ????? ?? ??? ????? ?????? ?? ??? ?? ??????. ?? ???????? ??????? ????? ????? ???? ??.
06:10:20 <gregnarg> ???? ?? ??????? ??? ????????? ????? ??? ?? ?????? ?? ????? ?? ????????? ????? ???? ?? ???? ?????? ?? ?????? ???? ?? ??? ?? ????????? ?????. ?????? ?????? ????? ???? ????? ???? ?? ?? ?????? ??????? ?? asterisk ????? ?? ???? ?????? ??. ?? ????? ??????? blackmails ?? ???? ???? ?? ????? ???.
06:10:21 <gregnarg> ??? tooge hep ??? ??????? ?? ???! ??? tooge ????????? tep ????? ?? ???!
06:10:22 <gregnarg> ????? ??? ???? ?????????? ??????? ?????? ??? ?????? ???? ???? ???????? ???? ?? ??? ????? ??.
06:10:23 <gregnarg> ?? ???????? ????? ?? ???? ???? ??????? ?? ???? ??? ?????. ????? ???? ???? ??. ????? ???? ????? ?? ?? ????. ???? ?? ?????? ???? ????? ??????? ??? ?? ??? ????? ???? ???????? ????. ??????? ?????? ???? ?? ???? ???? ?????.
06:10:23 <lambdabot> Plugin `compose' failed with: Unknown command: "????."
06:10:24 <gregnarg> Hama ?akora norgs ke bare me? nahi? soca rahe hai?... Hama KORG Keyboargs ke bare me? soca rahe hai?!
06:10:25 <gregnarg> Mai? paise kharca karate hai?. Mai? eka genda ko lata mari. Yahi prabandhaka daravaja khola.
06:10:26 <gregnarg> Vaha mali eka kara dhoya. Una u?ana attendants eka a?u u?haya. Una basa calako? ko eka basa ki savari.
06:10:27 <gregnarg> Mai? eka ?opi pahani thi. Vaha pho?ographara eka kara ?ra'iva. Mai? eka alarma gha?i se?a.
06:10:28 <gregnarg> Sunna bhe?a uttari naukara ke satha jama deta hai. Ga?ara batate hai??
06:10:29 <gregnarg> Gita adesa kutte. Krodha eka badha ka virodha karata hai. Eka kutte ko eka vikalpa ke sampadaka initializes. Kutta age aspa??a eka billi ke pasa.
06:10:30 <gregnarg> Hamare janajati nirvahana akar?a?a upara aniscita ?okari. Vahana ke bada eka bud'dhimana vyavahara snataka kara sakate hai?? Eka ghara bavasira eka dahasata patita.
06:10:31 <gregnarg> Eka prakriya nidhana cetavani dete hai?. Eka purvavarti korasadala ke bada ?igri kramika ?aisa. Kalina isa ?ilara ke tahata pha?a ja'ega.
06:10:32 <gregnarg> Jo bhi phe?ka diya a?u ra?ga eka samaya sima ke upara ma??arana. Pustakalaya galati klasika kara sakate hai?? Mera baja?a eka ajiba kan¯ca i??e??a. Eka sud'dha konakai?ene?sa sima me? abhi bhi dubha?iya.
06:10:33 <gregnarg> Rumina bibbidle logo? ko mere savalo? ka javaba nahi? hoga.
06:10:34 <gregnarg> Kisora khilauna hatasa vikar?a mamalo?. Laga raha hai gurde bhara svayansevaka cau?a'i bacate. A?ka ke satha eka cho?i si sabdajala cikha cahi'e?
06:10:34 <luite_> ugh again...
06:10:35 <gregnarg> Pratyeka ka?a - cham??a karana ikka na?aka karata hai? Hamare frowning tyohara aha?kara ke tahata congests. Eka kharida sardiyo? ke bahara kisi bhi silikona bobs.
06:10:36 <gregnarg> Eka caudaha ko'i prabhava pahale sera rants. Dukha ke bhitara ki avadhi samapta ho khoja composes. Vo?a kharaba sectored megaba'i?a founds.
06:10:37 <gregnarg> Cinta karana billi teck dhyana dena karane ke li'e teck
06:10:38 <gregnarg> Eka ja?gala me? eka vimana ?u?a jata hai. Sansodhana rikor?ara thisisa adhikr?ta. Ba??ala yatra karana cahi'e? Gun¯ja'isa bina caku ke raves.
06:10:39 <gregnarg> Arthahina aspa??a cikhati hai. Ho??ha ke nice jo bhi udara patta pai??a.
06:10:54 --- mode: ChanServ set +o dobblego
06:10:57 <hpc> um... what
06:11:14 <PHO_> wha?
06:11:15 <ash98> hh
06:11:20 <ash98> hello
06:11:36 <ash98> how r u
06:27:15 <erus`> how are _you_?
06:28:56 <Jafet> r u confounds beginners.
06:42:17 <erus`> Half the stuff i have learned, i have learned from books and interwebs. I could be pronouncing everything wrong! I should have gone to uni
06:49:06 <gtirloni> http://www.haskell.org/haskellwiki/Pronunciation
06:49:24 <fcr> question: is this function tail recursive? let f (Just k) = f (Just (k+1))
06:49:57 <gtirloni> looks like it, you're not doing anything with the result
06:50:10 <fcr> if it is, why when I run it, does it keep eating ram?
06:50:11 <gtirloni> it'll go forever too, right?
06:50:18 <fcr> yes
06:51:08 <gtirloni> looks like it will
06:51:25 <gtirloni> i don't know how ghc does its optimizations behind the scenes
06:52:23 <PHO_> what if you use `seq`
06:52:31 <PHO_> let f (Just k) = k+1 `seq` f (Just (k+1))
06:52:34 <fcr> hmmm, the problem is that I'm using a code more complex, but with the same idea on the loop of an interpreter, and I'm getting memory leaks
06:54:05 <fcr> PHO_: but... isn't + strict?
06:54:37 <fcr> I guess that I'll need to strictify things on the body, then...
06:54:57 <PHO_> fcr: + is strict, but Maybe a isn't.
06:55:29 <hpc> > let f (Just k) = f (Just (k + 1)) in f (Just 0)
06:55:45 <hpc> lambdabot?
06:55:46 <lambdabot>   thread killed
06:55:52 <hpc> > let f ~(Just k) = f (Just (k + 1)) in f (Just 0)
06:56:20 <hpc> > let f k = f (k + 1) in f <$> Just 0
06:56:42 <hpc> humbug
06:57:10 <lambdabot>   thread killed
06:57:42 <fcr> thank you guys... I'll see what can I do
07:04:50 <parcs> @where sicp
07:04:51 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
07:04:51 <lambdabot> classes/6.001/abelson-sussman-lectures/>
07:05:09 <parcs> where is the other sicp?
07:07:38 <hpc> @where other sicp
07:07:38 <lambdabot> I know nothing about other.
07:12:32 <k0ral> hi, I read how to use the Reader monad that is supposed to prevent boilerplate code, but I end up prepending liftIO just about everywhere, is it normal or am I doing it wrong ?
07:14:07 <Feuerbach> k0ral: might be, but really hard to say without seeing the code
07:15:26 <wavewave> hi.
07:16:07 <k0ral> Feuerbach: please don't tell me that again, I just can't give you my whole program's code, I'm sure you can figure out alone that just using the standard System.IO functions (putstrLn, readFile...) and the Gtk functions (most of which are all IO ()) implies the use of a lot of liftIO
07:16:29 <wavewave> is there any way to make a compiler error message when a code tries to call some function?
07:16:45 <wavewave> I know that this is weird but...
07:16:51 <hpc> wavewave: you could try not importing the function :P
07:16:53 <parcs> k0ral: it's normal but ideally every IO action should be lifted by the library
07:17:12 <hpc> import Foo hiding (don'tCallMe)
07:17:13 <wavewave> hpc: it's impossible. okay let me explain more.
07:17:19 <hpc> or comment it out, i suppose
07:17:32 <hpc> dunno if there's a way to do it at the level of GHC flags
07:17:46 <Phlogistique> I thought I had asked a question in this chan but now I can't find it again. Is there a way to limit the amount of memory GHC (and the processes it calls) will eat up?
07:18:00 <wavewave> hpc: I am writing down a FFI for a C++ lib.
07:18:16 <wavewave> hpc: it's defined in superclass but protected in subclass (hate it!)
07:18:27 <hpc> Phlogistique: i think there's a flag you can use to set the heap size
07:18:57 <wavewave> hpc: since when importing subclass, superclass is automatically imported, so I cannot hide it unfortunately.
07:19:04 <hpc> Phlogistique: i expect it will be a runtime flag (+RTS -heapsize 50M -RTS # or something like that)
07:19:05 <k0ral> parcs: how could the library possibly know which monad I'm wrapping it into ?
07:19:19 <parcs> k0ral: type classes
07:19:19 <wavewave> the only option is using ghc warning and make a runtime error.
07:19:28 <Phlogistique> hpc: thanks
07:19:28 <wavewave> error "this method is protected"
07:19:41 <parcs> liftIO :: MonadIO m => IO a -> m a
07:20:00 <wavewave> just wondering if there is a way to protect it at compile time.
07:20:04 <parcs> you provide an instance of MonadIO for your Monad (ReaderT has one)
07:20:50 <k0ral> parcs: so every library function should actually be :: MonadIO m => m (), right ?
07:20:53 <hpc> wavewave: perhaps you could have separate types SuperFoo and SubFoo?
07:20:59 * hpc doesn't FFI
07:21:00 <k0ral> parcs: I mean, instead of IO (
07:21:02 <k0ral> )
07:21:20 <parcs> k0ral: ideally
07:21:27 <wavewave> hpc: yes. I separated SuperFoo and SubFoo..
07:21:59 <wavewave> hpc: and in an external module, if I import SubFoo... then all SuperFoo methods are imported.
07:22:33 <wavewave> hpc: anyway, this is not a very big deal.. compile time error vs runtime error.
07:22:52 <wavewave> anyway I can give some warning..
07:23:15 <k0ral> parcs: why isn't even System.IO following this ideal ?
07:24:31 <hpc> k0ral: functions that take IO actions as parameters, perhaps?
07:24:40 <hpc> there's no polymorphic runMonadIO function
07:25:23 <hpc> also for the usual reasons for specializing other types
07:25:40 <hpc> (historical / "import generic versions from here")
07:25:42 * wavewave is thinking about what 'every library function should actually be :: MonadIO m => m ()' means..
07:25:53 <parcs> he means vs IO ()
07:26:06 <hpc> so you aren't liftIOing everything
07:26:43 <paolino> wavewave: maybe a class instance is not the right interface
07:26:57 <k0ral> hpc: I'm sorry but I didn't get everything you said
07:27:16 <parcs> k0ral: exception-handling functions (catch, throw, etc) require extra plumbing to be polymorphic
07:27:25 <k0ral> functions that take IO actions as parameters, perhaps? --> err, no, take putStrLn for example
07:27:36 <wavewave> paolino: yeah. that's true. unfortunately, classes with multiple inheritance, typeclass is the only way for me.
07:28:00 <k0ral> parcs: am I supposed to do this extra plumbing, and is it recommended or is there another way to tackle the problem ?
07:28:13 <wavewave> paolino: if only with single inheritance, I can use a single type for each class with phantom type chaining..
07:28:27 <parcs> there a bunch of libraries that provide polymorphic exception handlers
07:29:06 <hpc> k0ral: one way to do it would be something like
07:29:12 <hpc> foo = do
07:29:17 <hpc>   r <- ask
07:29:19 <k0ral> parcs: well, fine for exception handlers, but what about any other IO () function built-in Prelude ?
07:29:20 <hpc>   liftIO $ do
07:29:24 <hpc>     lots of IO stuff
07:29:38 * hackagebot cuda 0.4.0.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.4.0.0 (TrevorMcDonell)
07:29:39 <wavewave> I prefer having IO and MonadIO m both provided. ;-P
07:30:13 <k0ral> hpc: that isn't good enough, for example if you call a function f :: ReaderT env IO () inside foo, you have to break the liftIO $
07:30:26 <wavewave> we can make it as a template haskell function for generating MonadIO out of IO.
07:30:56 <paolino> wavewave: why are there *private* methods in a class ?
07:31:06 <k0ral> hpc: and as far as I noticed, every constant term used in the liftIO $ block will be unavailable to the ReaderT function
07:31:28 <wavewave> paolino: don't ask me ;-P... I am asking myself the same question. ;-P
07:31:40 <hpc> k0ral: indeed; it's a start though :P
07:32:02 <wavewave> paolino: that's 'protected' keyword in C++.
07:32:14 <wavewave> paolino: hate it very much.
07:32:16 <paolino> if the client must implent those, he can use them without the instance
07:32:23 <hpc> it at least lets you lift huge swaths of IO code into their own functions, which you can reuse nicely in other places
07:33:09 <wavewave> k0ral: you may use MonadControl class by the way.
07:33:09 <k0ral> hpc: I got so used to seeing Haskell solve problems in a nice way that I can't believe this case cannot be dealt with in an elegant manner :)
07:33:18 <parcs> k0ral: i'm not sure why the Prelude is not as good as it could be. it probably has to do with keeping things simple and trying to not scare everyone off :P
07:33:40 <hpc> k0ral: it probably can, somehow; i just don't know the solution :P
07:33:54 <hpc> (types are hard that way)
07:34:14 <paolino> wavewave: if the client is not going to implement those they can just sit outside the class and have the class in the constrains
07:35:06 <k0ral> wavewave: can't find MonadControl in the doc
07:35:15 <wavewave> paolino: yeah. I agree.
07:35:37 <wavewave> k0ral: recent yesod blog introduces it quite well.
07:35:44 <wavewave> k0ral: let me find.
07:36:27 <wavewave> http://www.yesodweb.com/blog/2011/10/yesods-monads
07:36:28 <hpc> http://www.yesodweb.com/blog/2011/08/monad-control
07:37:32 <wavewave> http://www.yesodweb.com/book/monad-control
07:38:12 <wavewave> you can run a monadic action of higher stack inside lower stack
07:38:12 <k0ral> this is getting harder :)
07:38:23 <wavewave> k0ral: yeah. this is advanced.
07:38:36 <k0ral> I'll need more than a couple of minutes to get it
07:38:39 <wavewave> k0ral: it's related with Coroutine and continuation.
07:38:45 <parcs> i think the solution to your problem is to not use ReaderT
07:39:06 <hpc> parcs: haha, probably true
07:39:14 <k0ral> but it actually deals with another problem I have indeed, when a library function takes as argument an IO (), while I would like it to be a ReaderT env IO ()
07:39:33 <k0ral> for now, I'm always prepending a runReaderT...
07:39:37 <wavewave> k0ral: anyway, liftIO is not a big deal in my thought.
07:39:59 <wavewave> k0ral : if you hate it.. just rename it. parameterize it.
07:40:05 <k0ral> parcs: don't tell me that :p I've begun a complete rewrite of my code just to use this monad
07:40:25 <wavewave> I think using Reader itself is not a bad idea.
07:40:39 <k0ral> wavewave: that would do the job, but it's quite intrusive
07:41:05 <k0ral> wavewave: I expose an "API" and I don't want users to get confused because I wrapped every library function
07:41:32 <wavewave> k0ral: I am not suer. in fact. I prefer to have explicit 'IO' mark ;-)
07:42:08 <wavewave> s/suer/sure
07:43:10 <k0ral> isn't my problem a common one ? I mean, I would imagine every beginner that starts with the Reader monad would end up with this question
07:44:16 <parcs> what is your problem again? the liftIO boilerplate?
07:44:21 <wavewave> k0ral : would you give some example?
07:44:40 <wavewave> k0ral: some code that you feel ugly or smelling
07:45:11 <wavewave> we can tell you at least if it is idiomatic or not.
07:46:48 <k0ral> wavewave: I'm pasting a piece of code I'm rewriting so do expect some errors, but this is to show you how many liftIO I'm obliged to use
07:46:57 <k0ral> parcs: indeed
07:47:17 <wavewave> with many levels of monad stacks, lift lift lift kind of annoyance is quite unavoidable..
07:47:47 <wavewave> monad zipper is an alternative, but it looks not popular.
07:49:31 <hpaste> koral pasted “Boilerplate liftIO ?” at http://hpaste.org/53596
07:50:17 <k0ral> wavewave: ^
07:50:38 <hpc> step 1: split up realMain'
07:50:45 <hpc> because damn that's huge
07:50:46 <wavewave> ugh..
07:51:05 <wavewave> k0ral: lots of your functions are simply IO actions.
07:51:07 <vharishankar> A strange behavior in System.Environment getArgs function
07:51:07 <pr>  /query lambdabot
07:51:15 <wavewave> k0ral: define them as IO.
07:51:16 <k0ral> hpc, wavewave, parcs: basically, this is the main code of hbro (in hackage) rewritten with Reader
07:51:37 <vharishankar> if * is part of the arguments, it returns entire list of files in the directory.
07:51:40 <wavewave> k0ral: when you need 'ask', then combine it in Reader monad.
07:52:23 <wavewave> k0ral: if possible, you can make your function in Reader monad to take generic IO action as a parameter.
07:52:33 <k0ral> I must go now ; I'll be happy to read your comments as I come back so don't hesitate to post them here
07:53:00 <wavewave> k0ral: then your function becomes more generic... and then you will get some kind of combinator library...
07:53:19 <wavewave> k0ral: but of course, from time to time, check public library.
07:53:38 <wavewave> k0ral: often you will end up with the function which is already defined in other good libraries.
07:54:09 <vharishankar> How does one read * as a literal in getArgs?
07:54:18 <wavewave> k0ral: number 1 principle is always to make your function as short as possible.
07:54:39 <wavewave> k0ral: any functions longer than 10 lines smell..
07:55:51 <wavewave> k0ral: and basic principle of monad stack is that the function in the stack must use the functionality in the stack
07:56:16 <wavewave> when need Reader, you define the function in Reader monad.
07:56:25 <wavewave> when need IO, you define the function in IO monad.
07:56:49 <wavewave> when you need Reader and IO, then you define the function in ReaderT s IO  monad.
07:57:20 <wavewave> k0ral: if you break your functions more, you will end up with either Reader or IO in most cases.
07:57:37 <hpc> if after you do that, you find individual functions that you are repeatedly calling with "liftIO" over and over and over, then maybe it might be a good idea to lift the function itself
07:57:42 <hpc> but don't do so prematurely
07:58:08 <wavewave> k0ral: and a function that really need (ReaderT s IO) will have more generic meaning.
07:58:29 <wavewave> k0ral: and what I really want to emphasize is
07:58:47 <wavewave> k0ral: refactor your program very aggressively..
07:58:55 <wavewave> k0ral: you will be very happy with type system.
07:59:43 <wavewave> k0ral: try to make your total monad completely different. You will find yourself to have conversation with ghc.
08:00:29 <wavewave> k0ral: after fixing all type error, in most cases, it simply works! haskell is a really nice language for refactoring.
08:02:07 <wavewave> I often change a very base type in my program in quite large program ~ several thousand lines.
08:02:57 <vharishankar> Is the problem with getArgs a non-haskell problem?
08:03:04 <wavewave> actually looking at how this type change propagate in the whole source code is amazing..
08:03:36 <wavewave> vharishankar : oh sorry, your question was buried in my solitude murmuring.
08:03:43 <vharishankar> I found this: http://programmersgoodies.com/prevent-haskells-getargs-from-parsing-glob-expressions
08:04:13 <vharishankar> wavewave: no issues. I was just googling the issue.
08:05:37 <wavewave> vharishankar: yeah, that is just shell thing. shell automatically convert * to corresponding arguments.
08:05:56 <vharishankar> I guess the solution is to wrap the whole thing in quotes.
08:06:04 <wavewave> yes
08:06:22 <vharishankar> And use words to get a list of the individual items
08:06:50 <wavewave> and for some special characters like spaces, you use \
08:07:58 <vharishankar> wavewave: OK.
08:08:47 <vharishankar> wavewave: I wonder if this is the behaviour in C ?
08:09:59 <wavewave> vharishankar: I don't think so. It's just a design of sh or bash.
08:10:52 <vharishankar> wavewave: yup. I confirmed it
08:11:30 <vharishankar> In C, I just tried it out - it returns the list of files. So shell is the culprit. :-)
08:11:38 <wavewave> k0ral: as for your program more specifically... many of your IO functions need only one or two parameters. like horizontal size or vertical size.
08:12:08 <wavewave> k0ral: then just make those function take those parameters explicitly, not using (Parameters a) which
08:12:12 <wavewave> is too big.
08:12:34 <vharishankar> wavewave: Yes, but I was writing an expression evaluator and I wanted to make the expressions from the command line
08:12:52 <wavewave> vharishankar: you can use ghci as your shell. ;-D
08:13:23 <vharishankar> wavewave: Of course. :-)
08:13:23 <wavewave> k0ral: that's more transparent since you can explicit see what parameters this IO action uses.
08:13:39 <vharishankar> I must go now. Urgent call.
08:13:45 <wavewave> :-)
08:13:47 <vharishankar> Thanks for your help wavewave
08:13:58 <wavewave> welcome
08:14:31 <wavewave> k0ral: and even you can reuse those IO functions in different program.
08:15:12 <nogden> would anyone be kind enough to help me understand the ((->) r) monad instance?
08:15:28 <wavewave> nogden: yeah, I can help you.
08:15:36 <nogden> thanks wavewave
08:15:51 <wavewave> so what's the question?
08:15:58 <nogden> I'm just learning Monads and, although I think I have a decent idea, I'm sruggling with this one
08:16:11 <nogden> so... I'll talk you through what I understand so far...
08:16:34 <nogden> the implementation or return:
08:16:42 <nogden> return x = \_ -> x
08:17:04 <nogden> wraps the value x in a default minimal context, in this case a function?
08:17:37 <wavewave> nogden: not quite exactly..
08:17:57 <wavewave> "default minimal context" is not a good way of thinking that.
08:18:25 <nogden> ah, ok... I'm following the tutorial "Learn you aa haskell for great good" and that's the way it's described there
08:18:28 <wavewave> nogden: just think like x is as it is independent of what my environment is..
08:19:03 <wavewave> nogden: hmm.. I need to bring my own hard copy of that book. :-P
08:19:43 <nogden> so, the context being the environment... x is seperate from that, just wrapped in it right?
08:20:46 <wavewave> nogden: I would say 'separate -> independent', but anyway sounds right.
08:20:49 <nogden> I mean, essentially, return evaluates to 'a function that, when evaluated, will always return x'
08:21:03 <wavewave> yes.
08:21:11 <nogden> good, so I understand that part
08:21:26 <nogden> now.... >>= is where I get lost
08:21:29 <nogden> so....
08:21:46 <nogden> h >>= f = \w -> f (h w) w
08:22:17 <wavewave> okay, what's the meaning of w first of all?
08:22:37 <nogden> that's where I get lost
08:23:13 <wavewave> nogden: remember (-> r) monad,  every action is  ( r -> something ) :: type
08:23:35 <Jafet> It's the ((->) r) monad, not the (-> r) monad
08:23:36 <wavewave> nogden : and h >>= f is an action of (-> r) monad
08:23:55 <wavewave> Jafet: ah, yeah,, thanks for pointing the error.
08:24:16 <ion> A.k.a. the (r →) monad.
08:24:19 <wavewave> ((->) r)  = (r -> )      /= (-> r )
08:24:31 <nogden> ok
08:24:39 <wavewave> nogden: so w must be of type  r
08:24:57 <nogden> right...
08:25:09 <wavewave> nogden: w is the environment or context as you want to call.
08:25:17 <ion> @type (=<<) `asTypeIn` \(=<<) -> undefined =<< (undefined :: a -> b)
08:25:18 <lambdabot> forall a b a1. (a -> a1 -> b) -> (a1 -> a) -> a1 -> b
08:25:23 <ion> @djinn (a -> a1 -> b) -> (a1 -> a) -> a1 -> b
08:25:24 <lambdabot> f a b c = a (b c) c
08:25:30 <nogden> so, if I might explain what I think I understand so far
08:25:46 <wavewave> nogden: yes, please ;-)
08:26:01 <Jafet> @type ap
08:26:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:26:25 <nogden> h is a value wrapped in an environment
08:26:32 <nogden> of type r
08:26:47 <ion> @type (<*>) `asTypeIn` \(<*>) -> undefined <*> (undefined :: a -> b)
08:26:48 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
08:26:51 <ion> @djinn (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
08:26:51 <lambdabot> f a b c = a c (b c)
08:27:33 <wavewave> nogden: okay. then what's f?
08:27:52 <nogden> f is a function that takes a value and returns a new value wrapped in an environemnt of type r
08:27:53 <Jafet> Also it's not hard to spot that return is const.
08:28:19 <wavewave> nogden: great. then.... let's see the definition again
08:28:48 <nogden> h >>= f = \w -> f (h w) w
08:28:52 <nogden> so...
08:28:55 <wavewave> nogden: because of the definition of f, it should take a value in the first argument.
08:29:07 <wavewave> in this case, it's (h w)
08:29:56 <nogden> in order to apply the function f to the value in h we have to extract that value from h
08:30:08 <tomprince> @pl f = \w -> f (h w) w
08:30:08 <lambdabot> f = fix (join . (. h))
08:30:24 <nogden> since h is a function we have to apply that function to get at the value
08:30:25 <wavewave> nogden: that makes sense since essentially h is a function that take an environment w .
08:30:33 <tomprince> @pl \w -> f (h w) w
08:30:33 <lambdabot> f =<< h
08:30:44 <nogden> now this is where I get lost
08:30:57 <nogden> where does w come from?
08:31:11 <wavewave> nogden :  w is in the beginning...
08:31:26 <wavewave> nogden : reader monad must be run at the first time.
08:31:38 <ion> (=<<) a b c = a (b c) c
08:31:42 <wavewave> nogden : using runReader.
08:32:15 <wavewave> nogden:  so environment was given a very long time ago....
08:32:47 <wavewave> nogden: okay, seriously... it is given.. at the point of (>>=) binding, it was already given.
08:33:11 <nogden> right
08:33:15 <nogden> an it is of type?
08:33:16 <wavewave> nogden: and passed it as the last parameter of a function.
08:33:45 <wavewave> nogden: of type r in ( (->) r ) monad .
08:34:36 <nogden> so we apply h to w to yeald the value upon which we apply f
08:34:48 <wavewave> nogden : yes.
08:35:02 <wavewave> nogden: and again f still need w
08:35:11 <ion> nodgen: http://heh.fi/haskell/functors/#function-instance
08:35:41 <nogden> ah!
08:35:58 <nogden> w being the second paraeter to f
08:35:58 <wavewave> nogden: did you get AHA moment? ;-D
08:36:22 <wavewave> nogden: yes.. w must be always the last parameter of actions
08:36:46 <wavewave> nogden: that's why it's ((->) r) monad.
08:37:04 <wavewave> nogden:  (r -> something) type
08:37:14 <DasIch> can I make cabal-dev look for sandboxes in ancestor directories?
08:37:33 <nogden> ok, I'm still not all the way there, but I'm much closer, thanks wavewave
08:37:47 <wavewave> nogden: welcome. ;-0
08:38:00 <wavewave> s/;-0/;-)
08:39:30 <wavewave> DasIch: sounds like it's opposite to cabal-dev's philosophy.
08:40:42 <paolino> What is the meaning difference between f :: a -> b -> b and f :: a -> (forall b . b -> b) ?
08:41:10 <wavewave> paolino: no difference.
08:41:10 <DasIch> wavewave: it would be convenient if you are in a subdirectory of a project you are working on which has a sandbox
08:42:25 <wavewave> @djinn f :: a -> b -> b
08:42:26 <lambdabot> Cannot parse command
08:42:34 <mm_freak> flip const
08:42:41 <wavewave> @djinn  a -> b -> b
08:42:41 <lambdabot> f _ a = a
08:43:40 <paolino> wavewave: then if I have g :: (forall . b -> b) -> a I can call g f and it makes no difference ?
08:43:53 <wavewave> paolino: that's different.
08:44:22 <paolino> ops, I mean "g x f" where x :: a
08:44:38 <paolino> nah, sorry
08:44:50 <paolino> g (f x)
08:45:24 <wavewave> paolino: (forall x . blahblah   ) means scope of type variable x up to  )
08:45:48 <paolino> it's the signature of g that makes "f x" a rank2
08:47:06 <monochrom> g is rank-2. f x is rank-1.
08:47:15 <paolino> ok
08:48:16 <paolino> f :: a -> (forall b . b -> b) ?
08:48:51 <wavewave> paolino : that's same as f :: a -> b -> b, and rank 1
08:50:41 <paolino> So the only reason I should write that is to use a type synonym like type Mutate = forall b . b -> b in f signature.
08:51:12 <paolino> then it's f :: a -> Mutate and g :: Mutate -> a
08:51:24 <Jafet> Usually, higher-rank types are used to make types.
08:52:14 <wavewave> paolino : hmm. I don't get your question yet.
08:53:09 <wavewave> paolino : f is rank 1, g is rank 2. then what's your question now?
08:54:23 <paolino> well I have a piece of code and was wondering if it was more correct to put the type synonym in the library or in the client
08:55:56 <wavewave> paolino : I am not sure, but I feel okay with those signatures of f and g with Mutate..
08:56:23 <wavewave> paolino: anyway that's how lots of monad libraries are doing.
08:56:57 <wavewave> paolino: Ah... I get your question now..
08:57:00 <paolino> I need to reflect a search in a Tree a in all Tree b having same structure of Tree a
08:57:24 <wavewave> paolino :  you want to hide b..
08:57:54 <paolino> inspector  :: (a -> Bool) -> Tree a  -> Ispettore
08:57:58 <wavewave> paolino: wait
08:59:16 <paolino> wavewave: can I paste Ispettore ?
08:59:47 <wavewave> paolino; of course, you can ;-)  Now I am experimenting something.
08:59:49 <Jafet> What's wrong with inspector :: (a -> Bool) -> Tree a -> Tree b -> foo?
09:00:05 <paolino> Jafet it's ok
09:00:47 <paolino> but then I need Rank2 in the client , because I don't define Ispettore in the lib
09:01:19 <Jafet> That isn't a rank-2 type at all.
09:01:52 <wavewave> yes. inspector is rank-1
09:02:42 <paolino> no, the rank-2 is in the client which needs to store a generic (Tree b - > foo)
09:02:50 <Jafet> That isn't rank-2.
09:03:16 <Jafet> A rank-2 type is where a quantifier disappears.
09:03:16 <wavewave> paolino: then you need existential.
09:03:22 <Jafet> @type runST
09:03:23 <lambdabot> forall a. (forall s. ST s a) -> a
09:03:44 <Jafet> s disappears at (-> a).
09:03:52 <wavewave> paolino: your Mutate kind of thing is not existential by itself.
09:04:28 <wavewave> if your type variable survives to the end of type signature
09:04:41 <wavewave> then it can be inferred to outside.
09:05:25 <wavewave> so the type variable has outside scope.. that cannot increase the rankness of your function.
09:06:01 <wavewave> but as we see in runST, s has only a scope up to )
09:06:34 <Jafet> > let f :: forall a. -> (forall b. -> (a, b)); f x y = (x, y); g = f 0 in (g 'a', g "a")
09:06:35 <lambdabot>   <no location info>: parse error on input `->'
09:06:41 <Jafet> > let f :: forall a. a -> (forall b. -> (a, b)); f x y = (x, y); g = f 0 in (g 'a', g "a")
09:06:42 <lambdabot>   <no location info>: parse error on input `->'
09:06:43 <paolino> Jafet yes.  In the client I have functions Tree a -> (forall b . Tree b -> foo) -> Tree a
09:06:43 <monochrom> a -> (forall t . t -> t is still rank-1 even without converting to forall t. a -> t -> t. count forall's on the left of ->
09:06:49 <wavewave> then the value of runST has no inference for s.. i.e. s just has a local scope... then it has rank-2.
09:07:22 <Jafet> > let f :: forall a. a -> (forall b. b -> (a, b)); f x y = (x, y); g = f 0 in (g 'a', g "ah")
09:07:23 <lambdabot>   ((0,'a'),(0,"ah"))
09:08:04 <Jafet> paolino: what does that function do?
09:08:25 <monochrom> more precisely, count forall's in the left-operand of ->
09:08:42 <paolino> Jafet , it changes the tree at a specified point
09:09:09 <paolino> using (forall b. Tree b -> Tree b -> (b -> b)) as selector
09:09:23 <paolino> of the point
09:09:27 <wavewave> paolino: my suggestion is just to expose type variable b in your type synonym. and use forall when needed.
09:09:40 * hackagebot tagsoup 0.12.4 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.4 (NeilMitchell)
09:09:51 <paolino> aha
09:10:28 <Jafet> Why do you need to quantify b like that? You can pass a polymorphic function and it will be unified appropriately.
09:10:44 <wavewave> monochrom: yes. that's the practical way to check rank.
09:11:01 <monochrom> practical? just practical? it's the definition.
09:11:01 <paolino> because I have Tree a and Tree c to change
09:11:13 <paolino> in the same place
09:11:16 <wavewave> monochrom: ah.. probably that's the definition ;-P
09:11:32 <Jafet> Write the exact type of your function, and what it does.
09:11:58 <ghosting> I'm stuck on a really silly problem: write a function that returns 1 from [(5,'b'),(1,'c'),(6,'a')]
09:12:26 <byorgey> > const 1 [(5,'b'),(1,'c'),(6,'a')]
09:12:27 <lambdabot>   1
09:12:33 <byorgey> but that's probably not what you meant ;)
09:12:50 <byorgey> ghosting: why should the function return 1?
09:12:56 <wavewave> paolino: if possible, just expose your a and c outside. but if you really need, use existential.
09:13:04 <geheimdienst> byorgey: no, it's nicely general. your solution even works for [(17,"lolcats")] and all kinds of arguments
09:13:22 <wavewave> paolino: not use type synonym, use 'data' keyword with constructor.
09:13:23 <Jafet> It invalidates those arguments, too
09:13:32 <paolino> wavewave: I don't have constraints for b
09:13:53 <ghosting> Byorgey, he wants you to make use of list and tuple functions
09:14:00 <Ferdirand> @type lookup
09:14:01 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:14:06 <byorgey> ghosting: who is 'he'?
09:14:13 <Jafet> paolino: I don't know what exactly you're writing, but it's highly probable that you don't need rank-2 types.
09:14:45 <byorgey> ghosting: also, "using list and tuple functions" is not a specification of the function.  What is the function supposed to do?
09:15:47 <geheimdienst> > fst ("lol","cat") -- ghosting, here's one half of your solution. fst and snd get you the first and second part of a 2-tuple
09:15:48 <lambdabot>   "lol"
09:15:50 <wavewave> paolino: you don't need constraint for define existential. in fact you don't need data keyword for existential..
09:16:34 <wavewave> ((forall b. b -> b) -> NewType) is already existential.
09:16:41 <paolino> Jafet say my state is made of some rose trees with same structure. This way I keep my data separated but I can merge them when needed via zipTreeWith
09:16:43 <wavewave> but not (forall b. b-> b)
09:16:45 <W_Blas> How do I iterate through a list?
09:16:52 <ghosting> I'm reading Hal daumes book
09:17:02 <troydm> does haskell do tco in recursive functions when compiling ?
09:17:04 <ghosting> Excercise 3.6
09:17:19 <troydm> so called tail-recursion
09:17:23 <Jafet> haskell doesn't compile
09:17:34 <troydm> Jafet: ghc
09:17:56 <ion> troydm: TCO doesn’t really apply to the way GHC runs code AFAIU.
09:18:00 <W_Blas> In particular how do I print a contents of a list of pairs of strings.
09:18:03 <W_Blas> ?
09:18:03 <monadic> Jafet: Err? Haskell doesn't compile or the compiler doesn't compile
09:18:04 <wavewave> forcing your (forall x. blah )  in the left of -> makes it existential.
09:18:14 <ghosting> The function takes a list of pairs of length at least 2 and returns the first component of the second element in the list
09:18:20 <troydm> ion: so there is no such thing as recursion limit?
09:19:00 <Jafet> troydm: just think about how haskell is evaluated
09:19:30 <troydm> yes but in order to track what function it should call doesn't it uses a stack ?
09:19:40 * hackagebot binary-derive 0.1 - Automatic deriving of Binary using GHC.Generics  http://hackage.haskell.org/package/binary-derive-0.1 (JaredHance)
09:19:41 <wavewave> troydm: no.
09:19:45 <Nimatek> W_Blas: pairs of strings, as in tuples?
09:19:52 <wavewave> troydm: magic of lazy evaluation.
09:19:55 <Jafet> Ok, you can't think about it. Then use this:
09:19:57 <Jafet> @where stepeval
09:19:57 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
09:20:15 <wavewave> troydm: it's graph reduction, not stack push-pop
09:20:57 <troydm> wavewave: hmm, so basicly if i have list of 1 million numbers and call recursive qsort on it it won't be a problem?
09:21:00 <paolino> Jafet, wavewave: one of those trees contains values good for selecting an element via (a -> Bool) , say Tree a.  I then need a function to modify the same position element in those trees. That is funzione inspector :: (a -> Bool) -> Tree a -> (b -> b) -> Tree b -> Tree b
09:21:36 <Jafet> troydm: ghc uses a stack, of course, but not for function calls.
09:21:55 <W_Blas> Nimatek: (String, String)
09:22:18 <Jafet> With lazy evaluation, expressions can get arbitrarily large, and a stack is needed to evaluate them.
09:22:40 <troydm> it makes me wonder why does erlang have tail recursion optimization then
09:22:53 <troydm> both are lazy evaluated
09:22:54 <ian_mi> the gmachine probably uses a stack to represent the graph, but a "tail call" will replace the function application with the function body.
09:23:33 <Jafet> Erlang does not use lazy evaluation.
09:23:39 <wavewave> troydm: is Erlang lazy?
09:23:45 <Ferdirand> erlang is not lazy
09:23:46 <Nimatek> W_Blas: mapM_ (\(s1,s2) -> putStrLn $ s1 ++ " " ++ s2) yourList
09:23:56 <Jafet> (If it did, no one would use it.)
09:24:58 <geheimdienst> ghosting: any luck so far? if you're stuck with your excercise, ask for some more hints
09:25:52 <Jafet> troydm: this is the role of the stack in haskell http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=let+f+[]+%3D+0%0D%0A++++f+%28x%3Axs%29+%3D+x+%2B+f+xs%0D%0Ain+f+[1%2C2%2C3%2C4%2C5]
09:26:15 <troydm> wavewave: i think it is lazy, it doesn't have a state
09:26:32 <paolino> Jafet, wavewave, I think I see the point, I only need rank-2 if I use the same function with different type in the same function
09:26:34 <Jafet> You are really really confused.
09:26:40 <wavewave> troydm: that's purity
09:27:27 <wavewave> erlang is 'rather' pure language but strict
09:27:29 <Jafet> paolino: that's rank-1 and you can write `inspector' exactly like that
09:28:04 <Jafet> Then (inspector f t) :: forall b. (b -> b) -> Tree b -> Tree b, as expected
09:28:28 <Ferdirand> what are the processes mailboxes if not state ?
09:28:33 <Jafet> You can bind it to a polymorphic variable and use it on as many types as you like
09:28:58 <wavewave> Ferdirand: that's where purity breaks down in erlang as I know..
09:29:21 <ghosting> Geheimdienst: I just need to know how to break into the list, and I'm done. Head and tail doesn't work on this
09:29:27 <wavewave> controlled way of impurity in message passing process.
09:30:00 <wavewave> if I understand well.. unfortunately I haven't had a chance to learn erlang after I knew haskell ;-P
09:30:52 <paolino> Jafet, but, if I have a function using it on  2 different types it must be rank-2 ?
09:30:54 <geheimdienst> ghosting: the function you're looking for is in the Prelude in section "List operations" http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
09:31:12 <Jafet> paolino: no, you still don't understand what a rank-2 type is.
09:31:14 <wavewave> paolino: no no
09:31:35 <geheimdienst> (it's not the safest or nicest way to do it, but we'll discuss that when you get there)
09:31:53 <Jafet> > let f x y = (x, y); g = f () in (g 1, g 1.0, g '1', g "one")
09:31:54 <lambdabot>   (((),1),((),1.0),((),'1'),((),"one"))
09:32:04 <Jafet> Rank-1.
09:32:21 <wavewave> paolino: I suggest you to just forget about rank-2 type and erase all the 'forall' keyword and see what happens in your code.
09:32:22 <Jafet> (Needs a type signature in ghc 7)
09:32:44 <paolino> ok
09:32:47 <wavewave> paolino: if you don't have a problem, you are not using rank-2 at all..
09:33:48 <paolino> wavewave I cannot assign b
09:33:51 <wavewave> paolino: if you have a problem, there may be a chance that you deal with rank-2... (but not always because Scoped type variable need forall keyword in different context. )
09:34:20 <W_Blas> Nimatek: Say I have a function print_list myList = mapM_ (\(s1,s2) -> putStrLn $ s1 ++ " " ++ s2) myList, then how do I print two lists one after another? I tryed (print_list dictA) ++ (print_list dictB)  and my compiler reports syntax error...
09:34:21 <wavewave> paolino : ?
09:34:26 <rostayob> the current GHC.Generics arrangement for types of kind with arity > 1 is quite ugly. Are there plans to generalize those type classes in some ways? is it even possible?
09:34:43 <dylukes> So, why does GHC STG use \r for "not updatable"?
09:34:48 <dylukes> What does the 'r' stand for?
09:34:57 <geheimdienst> readonly?
09:34:57 <Jafet> W_Blas: programming by random guessing does not usually work
09:35:01 <paolino> wavewave: g :: ((b -> b) -> Tree b -> Tree b) -> Tree a -> Tree c -> (Tree a, Tree c)
09:35:31 <Feuerbach> dylukes: reentrant
09:35:33 <Nimatek> W_Blas: print_list dictA >> print_list dictB
09:35:37 <dylukes> Feuerbach: Ah!
09:35:41 <dylukes> that makes more sense :P.
09:35:46 <W_Blas> Jafet: I see!
09:35:50 <paolino> wavewave : g f x y = (f k x, f  k y)
09:35:54 <wavewave> paolino: hmm... that's rank2... but do you need it?
09:36:16 <Nimatek> W_Blas: Or use the do notation: do print_list dictA; print_list dictB
09:36:24 <wavewave> paolino : can't you change b to a or c ?
09:36:37 <Jafet> He can't, because he wants it to be both a and c.
09:36:41 <paolino> not to both together I suppose
09:36:52 <Jafet> Also, paolino seems to be missing a (a -> a) and (c -> c).
09:37:03 <paolino> that is k , sorry
09:37:16 <wavewave> paolino: in fact, if you really want to define like that, your function argument is only id.
09:37:28 <wavewave> I mean that only allowed function is id.
09:37:32 <paolino> :)
09:37:42 <wavewave> Ah... wait...
09:37:52 <Nimatek> W_Blas: http://learnyouahaskell.com/input-and-output
09:37:54 <wavewave> paolino: no..let me back up.
09:38:07 <paolino> g :: (a -> a) -> (c -> c) -> ((b -> b) -> Tree b -> Tree b) -> Tree a -> Tree c -> (Tree a, Tree c)
09:38:30 <paolino> g ka kc f x y = (f ka x, f  kc y)
09:38:45 <wavewave> you basically want a functor.
09:38:48 <Jafet> (a -> Bool), too, otherwise, it's just two fmaps
09:39:10 <snappy> hm, read that as two faps.
09:39:31 <Feuerbach> dylukes: this is described in A.1 appendix of the STG paper
09:39:33 <ghosting> > fst(head(tail(init [(5,'b'),(1,'c'),(6,'a')])))
09:39:33 <paolino> nono, (b -> b) -> Tree b -> Tree b is not fmap
09:39:34 <lambdabot>   1
09:39:39 <wavewave> paolino: why don't you constrain your type variable to be a functor instance.
09:40:05 <wavewave> paolino: hmm...
09:40:20 <Jafet> paolino: fmap is (a -> b) -> Tree a -> Tree b
09:40:59 <wavewave> paolino: again, anyway, I got lost... what was the problem anyway? kk
09:41:48 <wavewave> paolino: rank-1 / rank-2 kind of theoretical discussion is not a problem of yours, I guess.
09:42:12 <paolino> g :: (a -> a) -> (c -> c) -> ((b -> b) -> Tree b -> Tree b) -> Tree a -> Tree c -> (Tree a, Tree c), g ka kc f x y = (f ka x, f  kc y) is wrong
09:42:24 <W_Blas> Nimatek: Thanks a lot for that link! I program in Java (professionally), C++, Python. After these languages Haskell program looks like a complete mess for me!
09:42:46 <paolino> g :: (a -> a) -> (c -> c) -> (forall b. (b -> b) -> Tree b -> Tree b) -> Tree a -> Tree c -> (Tree a, Tree c)
09:42:46 <paolino> compiles
09:43:20 <Nimatek> W_Blas: Yeah, it's a different way of composing your programs.
09:43:22 <wavewave> paolino: :-)
09:43:41 <ghosting> Thanks for the help Geheimdienst
09:43:42 <Jafet> paolino: yeah, that's a rank-2 function
09:43:45 <wavewave> W_Blas: which is mess?
09:43:51 <paolino> In the lib I define Inspector b = (b -> b) -> Tree b -> Tree b and in the client g :: (a -> a) -> (c -> c) -> (forall b . Inspactor b) -> Tree a -> Tree c -> (Tree a, Tree c)
09:44:18 <wavewave> paolino: great. you accepted my suggestion. heh ;-D
09:44:21 <Jafet> I can't think of any use for that function, though
09:44:50 <Jafet> The only reason it is rank-2 is because you're doing the exact same thing to two different inputs
09:45:00 <wavewave> paolino: for type synonym, do not use forall... that's very confusing.
09:45:02 <W_Blas> wavewave: I'm talking about Haskell code It looks like gibberish
09:45:20 <Jafet> And you could just do the exact same thing to both inputs, without having to make up a function for it
09:45:20 <paolino> Jafet , say you want change element [1,3,0,2] down some rosetrees
09:45:41 <Nimatek> It looks closer to mathematical notation than many other languages.
09:45:55 <paolino> where [1,3,0,2] is the path
09:46:11 <paolino> but you hate paths
09:46:25 <Jafet> g' :: (a -> a) -> ((a -> a) -> Tree a -> Tree a) -> Tree a -> Tree a, is a rank-1 function, that does exactly the same thing
09:46:45 <Jafet> Then you do (g' fa ta, g' fc tc)
09:47:07 <paolino> ah , I see :)
09:47:25 <Jafet> Or (g' ka f x, g' kc f y) with your names
09:47:31 <wavewave> W_Blas: hmm.. that's a kind of opposite reaction to mine when comparing languages.
09:47:51 <geheimdienst> ghosting: you're welcome
09:48:22 <Jafet> And f :: Inspector is, again, of an old usual regular rank-1 type
09:48:23 <wavewave> W_Blas: but do not judge things by looking at things only at a superficial level.
09:48:59 <wavewave> W_Blas: one can understand what it should be like that.. At least, haskell is very consistent.
09:49:44 <wavewave> W_Blas : in a sense, haskell people are very sensitive to consistency..
09:50:48 <Jafet> I'm only sensitive to light
09:51:06 <paolino> Jafet, ok a one type variable function is not eligible for a rank-2, then I need an example of a useful rank-2 before throwing away some code
09:52:20 <Yrogirg> What is better for asking a question --- stackoverflow or Haskell-cafe?
09:52:33 <monochrom> both
09:52:50 <wavewave> Yrogirg: I found that Haskell-cafe is more advanced.
09:53:21 <wavewave> Yrogirg: given that all haskell guru really care about it.
09:54:42 * hackagebot binary-derive 0.1.0 - Automatic deriving of Binary using GHC.Generics  http://hackage.haskell.org/package/binary-derive-0.1.0 (JaredHance)
09:55:32 * wavewave thinks that consistency is most important value. 
09:55:48 <Jafet> paolino: you can get very far with rank-1 typing
09:56:20 <dylukes> You still can't document GADT's?
09:56:21 <dylukes> the hell?
09:56:36 <wavewave> Probably, paolino wants to delight himself with fancy rank-2 types.
09:57:29 <wavewave> paolino: remember that if you do really interesting thing using higher rank types, it's usually ph-d thesis kind of work.
09:57:31 <paolino> wavewave: it's better to know that it was for fancy and not necessary before selling as knowledge :)
09:58:10 <wavewave> paolino: I am very affirmative about what you are doing. :-)
09:58:43 <copumpkin> preflex: seen jaspervdj
09:58:44 <preflex>  jaspervdj was last seen on #haskell 7 days, 6 hours, 40 minutes and 30 seconds ago, saying: ugly hacks for haskell-src-exts :-(
10:00:03 <wavewave> paolino: in fact, I also experienced similar phase.. like considering everything using higher-rank type... later, I just found much easier solution all the time like Jafet suggested .
10:01:24 <wavewave> because it's so different from other language and so powerful.... but it's too powerful.. ;-P
10:03:18 <paolino> wavewave I guess if you need g :: a -> (forall b .  a -> (b -> b)  -> a)  -> a , then there is no simplification  , but I never needed stuff like that actually
10:03:34 <Jafet> Nah, phd theses use rank-3 types now
10:03:46 <Jafet> Rank-2 is passe
10:04:00 <wavewave> @djinn a -> (forall b. a -> (b -> b) -> a) -> a
10:04:00 <lambdabot> f a _ = a
10:04:14 <dylukes> paolino:wavewave why would you need g :: a -> (forall b .  a -> (b -> b)  -> a)  -> a  ?
10:04:23 <Jafet> iHm, It seems that rank-3 inference is undecidable.
10:04:24 <dylukes> the b part seems pretty unnecessary...
10:04:51 <wavewave> @djinn forall b. a -> (b -> b) -> a
10:04:52 <lambdabot> f a _ = a
10:04:55 <Jafet> I guess that's what makes it phd material.
10:05:20 <paolino> dylukes, then please make a useful example of rank-2
10:05:28 <paolino> so I can relax
10:05:34 <dylukes> uh
10:05:44 <wavewave> ST monad.
10:05:53 <monadic> Yes ST Monad is pretty much THE example
10:05:58 <dylukes> oh thats true
10:06:04 <Jafet> @quote ContT
10:06:04 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
10:06:04 <lambdabot> just don't know what it means.
10:06:08 <dylukes> runST :: (forall s. ST s a) -> a
10:06:10 <monadic> But why do you care so much about rank 2 types; they are so painfully horid
10:06:28 <wavewave> in fact, all existential types are rank-2
10:06:35 <dylukes> wavewave: ^
10:06:36 <monadic> The only reason runST uses it is so that there's no use of the mutable s thing
10:06:46 <monadic> or something like that.
10:07:00 <dylukes> ??
10:07:20 <monadic> "The forall ensures that the internal state used by the ST computation is inaccessible to the rest of the program." from docs
10:07:24 <rostayob> rank-n types are really useful
10:07:26 <wavewave> dylukes: asking me?
10:07:32 <paolino> an example without existentials
10:07:38 <dylukes> no, monadic.
10:08:38 <paolino> runST seems cheating ....
10:08:41 <hpaste> rostayob pasted “rank-n types” at http://hpaste.org/53598
10:08:44 <monadic> If it was just ST s a -> a then you could depend on the type of s which is potentially dangerous in some way. I don't remember quite why though.
10:08:54 <rostayob> rank-n types are also useful for this kind of stuff http://hpaste.org/53598
10:09:00 <rostayob> monadic: you don't want that type to escape
10:09:08 <rostayob> that's a common trick with rank-n types as well
10:09:17 <companion_cube> i wonder why there are called "existential" although they can be proper universal in a positive postion
10:09:20 <companion_cube> position
10:09:29 <Jafet> Because no one ever uses them that way
10:09:34 <rostayob> I also don't get why they're "horrid"
10:09:38 <paolino> rostayob: sorry, we ruled out that use
10:09:46 <rostayob> what use?
10:09:48 <paolino> it's refactorable
10:09:53 <monadic> because you can usually refactor out the rank n type
10:09:59 <rostayob> monadic: no. http://hpaste.org/53598
10:10:15 <rostayob> write that function without rank-n types
10:10:30 <companion_cube> Jafet: or maybe you can pull the quantifier out in this case, and thus get a regular type
10:10:40 <monadic> rostayob: Firstly, I said USUALLY. Secondly, we can refactor that out by giving two function parameters and passing in the same rank-1 function to both
10:10:48 <rostayob> monadic: which is stupid
10:11:01 <Jafet> Yes, and that makes it easier to use than littering type annotations all over your code. So people don't ever use them that way
10:11:17 <joo> Would a function f g [x1, x2, ... xn] = g x1 x2 .. xn violate the type system?
10:11:29 <monadic> joo: yes
10:11:38 <Jafet> joo: that's not valid haskell anyway
10:11:49 <rostayob> joo: it depends on the type of g, you can have functions that consume lists
10:12:09 <Jafet> There is no [x1, x2, ... xn] syntax.
10:12:14 <paolino> :t foldr ($)
10:12:14 <lambdabot> forall b. b -> [b -> b] -> b
10:12:19 <wavewave> joo; you wanna have variadic parameters.
10:12:19 <joo> I know, that was just to illustrate my point
10:12:24 <rostayob> yes but i think that that's what he meant
10:12:27 <monadic> paolino: that is rank 1
10:12:31 <geheimdienst> guys, it's clear what he means ...
10:12:50 <monadic> If I recall you have to use Data.Dynamic for it
10:12:57 <rostayob> joo: http://okmij.org/ftp/Haskell/vararg-fn.lhs
10:13:02 <rostayob> the very first type class
10:13:12 <monadic> or type class recursion
10:13:27 <paolino> monadic: I'm not trying to invent a useful example for rank-2, just trying to give an answer to joo
10:13:28 <rostayob> you don't really need anything special if you type annotate the bottom type
10:13:38 <paolino> :t foldr (flip $)
10:13:39 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> [f (f b -> b)] -> f b
10:13:40 <wavewave> f g [x1, x2 ... , x2 ] = g <$> x1 <*> x2 <*> ..
10:14:13 <joo> Hmm...
10:14:27 <rostayob> joo: maybe it's better if you just tell us what you want to do
10:14:43 <rostayob> there's probably a simple solution :P
10:14:46 <Jafet> @src Mu
10:14:46 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:14:47 <monochrom> rostayob: I wonder if you could omit "Show c =>" in your example.
10:15:13 <monochrom> nevermind, it is necessary
10:15:15 <monadic> forall a => String is constant
10:15:42 <rostayob> no but that kind of use for rank-n types is a practical use case
10:15:55 <rostayob> at least for me
10:16:13 <rostayob> i mean it just makes sense to be able to write that
10:16:24 <rostayob> or things along those lines
10:16:27 <paolino> it was for me too , until an hour ago ....
10:16:44 <rostayob> paolino: what happened an hour ago?
10:17:11 <paolino> someone refactored it to rank-1
10:17:20 <rostayob> paolino: yes but you *can't* refactor that to rank-1.
10:17:25 <rostayob> (what I posted)
10:17:37 <wavewave> paolino: but that doesn't mean everything can be refactored. :-)
10:17:40 <rwbarton> in what you posted the left hand side is longer than the right hand side
10:17:48 <rwbarton> so it's hardly a realistic example
10:18:01 <rostayob> rwbarton: i'd never write that function, it's just a minimal case
10:18:02 <joo> rostayob, I have some data of the form ("name", [x1, x2, ... xn]) representing a symbolic function taking n arguments all of the same type, applied to some specific values. I want to convert that to some actual function applied to the given list of arguments.
10:18:19 <wavewave> joo: use Applicative
10:19:06 <rostayob> joo: a "symbolic functtion"?
10:19:10 <paolino> rostayob: it's so similar to my case, that I think it is.
10:19:17 <rostayob> paolino: it isn't.
10:19:34 <joo> rostayob, a function referred to by Haskell only in name.
10:19:43 <rostayob> otherwise the a -> String would be bound to some type specific to one of the arguments
10:19:44 <wavewave> joo: sounds like mathematica ;-)
10:19:53 <joo> Something like that, yes.
10:20:07 <rostayob> so wait, how do you get the "real" function?
10:20:22 <wavewave> rostayob: there must be a lookup table.
10:20:29 <joo> I have a lookup table, yes.
10:20:59 <joo> I would just store references to the actual function... but I am not in control of the input data.
10:21:05 <SavageSimian> i'm a haskell noob. what does "5 /= 5" mean? i know what it means in c++ but it's apparently not the same in haskell.
10:21:18 <rostayob> anyway yes, use applicative
10:21:20 <joo> SavageSimian, /= is "not equal to"
10:21:20 <monochrom> 5 != 5
10:21:29 <SavageSimian> ah. ty
10:21:49 <rwbarton> what is the type of the lookup table
10:21:53 <monochrom> please don't try to draw inspiration from c++ or anything else really
10:21:57 <geheimdienst> joo: have you considered putting this data into a .hs file and change it using a text editor so that «("name", [x1,x2])» becomes «name x1 x2»? that sounds like the simplest and most effective
10:22:03 <rostayob> rwbarton: I'd like to know that as well :P
10:22:10 <rwbarton> don't see how applicative will help you
10:22:12 <monochrom> indeed, haskell 5 doesn't even mean c++ 5.
10:22:41 <ptrf> i'm reading the rwh book, chap 6: http://book.realworldhaskell.org/read/using-typeclasses.html - the authors first define a type class called JSON with functions toJValue and fromJValue. then they're making some instances, but noting that without the use of pragmas, one can't do an instance JSON String where ... (without TypeSynonymInstances) nor instance JSON [Char] where ... (without FlexibleInstances)
10:22:47 <wavewave> joo: what is the type of your function references/
10:23:15 <monadic> ptrf: do you have a question with that?
10:23:23 <ptrf> yes, it's coming...
10:23:29 <ptrf> i'm wondering about two things: first, is it possible to define this instance without the use of pragmas (and how), and second..
10:23:45 <joo> wavewave, now that I think about that, the lookup table cannot exist.
10:24:03 <joo> They would be (Float -> Float) or (Float -> Float -> Float) etc...
10:24:05 <ptrf> why is it not possible to use [Char]?
10:24:08 <wavewave> joo: it can exist.. actually this is a famous problem.
10:24:19 <monadic> Not really. You have to use something like Constraint => [a]. The one thing you could probably do was make an IsChar constraint and define the instance for only Char, I think.
10:24:19 <wavewave> joo: there is a monad reader article about that.
10:24:22 <rwbarton> just put the version of the functions that accept lists into the table
10:24:23 <monadic> It's not possible to use [Char] because of constraint being smaller than head
10:24:30 <wavewave> joo: let me see.
10:25:13 <geheimdienst> i thought TypeSynonymInstances and FlexibleInstances are very harmless. some other extensions are stinky or should only be used when you know what you're doing, but not these two
10:25:52 <monadic> yes Flexible Instances is fine. Stay away from IncoherentInstances. UndecidableInstances is _usually_ okay as the only thing it can do is cause a nonterminating compile. If the program compiles fine with it, it's all good
10:25:56 <rwbarton> the reason you can't use [Char] is a more-or-less arbitrary restriction on the form of instance heads in Haskell 98 (perhaps it makes implementors' tasks a bit easier)
10:26:03 <ptrf> monadic: i don't quite get the constraint part?
10:26:32 <monadic> ptrf: Constraint being the constraint on the instance, as in you could do "instance IsChar c => [c]" but not "instance [Char]"
10:26:32 <ptrf> monadic: but basically, is it because [] has several types?
10:26:57 <ptrf> monadic: ok, i think i might go read up on that.
10:27:01 <rwbarton> the reason is that [Char] is not the application of a type constructor to zero or more variables
10:27:20 <rwbarton> e.g. instance Foo Int is OK, instance Foo (Maybe a) is OK, instance Foo (Maybe Int) is not OK
10:27:34 <rwbarton> [Char] is really [] Char so it is like Maybe Int
10:27:48 <monadic> Yeah it has to be of the form Constraint => T a0 a1 a2 a3. IF we could define [Char] instances we would be blocking [a] instances for forever
10:27:51 <ptrf> rwbarton: oh, I see!
10:27:52 <wavewave> joo : I cannot find it out easily now.
10:28:21 <monadic> Enabling FlexibleInstances allows us to define [Char] as long as we promise not to provide [a] as well. Using OverlappingInstances [dangerous!] we can define both
10:28:34 <wavewave> joo: anyway this depends on the level of your requirement.
10:28:41 <rwbarton> this makes instance selection a bit easier, if we want the instance for (C X Y Z) we only ever care about what constructor C is
10:29:05 <rwbarton> (this = the haskell 98 restriction which is removed by FlexibleInstances)
10:29:27 <ptrf> monadic: rwbarton geheimdienst: thanks for the help. i think i'll go chew on this for a while, I'm sort of new to haskell, coming from sml where we just have eqtypes:)
10:29:28 <wavewave> joo: you can interprete lambda  calculus or  you can interprete only expression with fixed set of functions..
10:30:06 <wavewave> joo: or you can use FFI for that... this evaluation problem has huge design space.
10:30:35 <wavewave> joo: even whether you do partial evaluation or not can be important..
10:30:36 <joo> wavewave, there is a fixed set of functions. In fact, they only take either 1 or 2 arguments, so I could write this all in two parts.
10:30:46 <rwbarton> that's probably a good idea anyways
10:30:49 <joo> However, it feels a bit dirty to do that.
10:30:55 <wavewave> joo: okay great.
10:31:06 <joo> Partial application shouldn't really happen either.
10:31:18 <geheimdienst> ptrf: happy chewing ;) again, it's pretty normal to routinely switch on a few extensions (everyone always does NoMonomorphismRestriction, for example). i wouldn't worry about it much
10:31:27 <joo> (Since for a 2-argument func, a list of two arguments will be supplied)
10:31:32 <wavewave> joo: okay.. that's another simplification.
10:32:27 <wavewave> joo: you can write a lambda calculus for that.
10:32:35 <ptrf> geheimdienst: good to know, thanks
10:32:57 <joo> Hmm..
10:33:12 <wavewave> joo : but easiest way is
10:33:30 <wavewave> just make a data type mimics your operation.
10:33:48 <wavewave> if you have + and - then you have a data type Expr with Plus and Minus
10:34:40 <joo> In fact, I have data Expr = Num Float | Id String | App String [ Expr ]
10:34:46 <joo> (Yes, I lied)
10:34:57 <wavewave> joo: great.
10:35:01 <geheimdienst> joo: this input data that you can't change, how often do you get it? is it a one-off thing or will it happen regularly?
10:36:05 <joo> geheimdienst, that is up to the "user", so as far as I am concerned, it could happen as regularly as they like.
10:36:25 <wavewave> joo: I think that you already have a solution for what to do with a list of variable at least.
10:36:44 <k0ral> wavewave: waw, thank you very much for the verbose comments :)
10:36:57 <k0ral> wavewave: I'm following them one by one
10:37:50 <wavewave> joo: just write down a function 'eval' which replace your data constructor with a real predefined function.
10:38:14 <wavewave> joo: just recursion.
10:39:08 <wavewave> joo: you can generalize this using Applicative and Foldable later probably... but it doesn't matter.
10:39:18 <joo> wavewave, that is exactly what I had before. I had, e.g. eval (App "+" [x, y]) = x + y, but it got tedious typing all of them out.
10:39:33 <joo> Er, well,  = (eval x) + (eval y)
10:39:42 * hackagebot interpol 0.2.0 - GHC preprocessor to enable variable interpolation in strings  http://hackage.haskell.org/package/interpol-0.2.0 (AlexandruScvortov)
10:40:24 <wavewave> joo: that's why its design space is huge.. if you have fixed function... then you just need implement them one by one.
10:40:41 <rwbarton> you could maybe save a little with some kind of ugly typeclass hackery, but it doesn't seem worthwhile
10:40:51 <wavewave> joo: but if you want to have more generic definition, then you need to think about its generic type signature.
10:41:09 <wavewave> joo:  the keywords are applicative and foldable....
10:41:18 <wavewave> joo: If you even want to have type safety..
10:41:25 <joo> wavewave, right.
10:41:29 <rwbarton> the keywords are typeclass hackery and ugliness :P
10:41:40 <wavewave> as rwbarton said, you need a real master of type hackery.
10:41:53 <rwbarton> or just switch to data Expr = Num Float | Id String | App1 String Expr | App2 String Expr Expr
10:42:19 <wavewave> rwbarton: using GADT, tagless compilation, etc etc..
10:42:45 <wavewave> joo: so this is not a simple thing..
10:42:48 <geheimdienst> joo: i don't know, the things proposed so far seem pretty overcomplicated to me. i'd look into making a small program that translates your input into actual haskell (main = print $ name x1 x2), then does ghc on it, and runs it. for this translater you might use plain haskell, template haskell if you feel like it, or even just something like a shell script
10:43:35 <wavewave> joo : even another direction like geheimdienst suggests :-)
10:44:25 <wavewave> partial evaluation is another real big topic.
10:44:37 <joo> That would be more work that just writing two versions of eval.
10:44:40 <geheimdienst> you'd have a library that has as many as you want (name x y = ..., simple regular haskell functions) and import that. if your users mess up the input and call functions that don't exist, ghc will tell them
10:45:26 <geheimdienst> joo: okay, well you're the one who knows the actual data :)
10:45:49 <wavewave> I personally encountered this topic soem time ago... I found that it's quite hard to design welll at the beginning.
10:46:59 <wavewave> In my case, I was trying to evaluate polynomial.
10:47:33 <wavewave> polynomial with lots of parameters.. which is fixed in some period of time.
10:48:12 <wavewave> so need partial evaluation for those.. but I implemented the original evaluator using lambda calculus.
10:48:44 <k0ral> wavewave: I agree that most of my functions are simply IO (), but let me explain why I added this reader to them
10:48:47 <wavewave> I was stuck and I had to rechange them again for supporting partial evaluation.
10:49:12 <k0ral> wavewave: the user will be able to configure key bindings, using a list [Keys, Callback]
10:49:26 <k0ral> wavewave: these callbacks must then have a common type
10:49:27 <wavewave> at that time, I had no time.. so I just make a simple C code generator finally... I was defeated.. :-(
10:50:23 <k0ral> wavewave: as I want the user to be able to use core functions as callbacks, I turned them into the Callback type
10:50:40 <wavewave> k0ral: let me remind myself of your case.. would you show the link of your code again?
10:50:55 <k0ral> wavewave: I realize this isn't a nice way to do it but I didn't find better, and I'm open to suggestions
10:51:10 <k0ral> wavewave: http://hpaste.org/53596
10:51:54 <fedvasu> why this statement gives parse error in ghci : negate(read "False")
10:52:28 <fedvasu> any idea folks ? the book programming in haskell , says it should be fine
10:52:41 <wavewave> k0ral: one thing I can suggest is make a datatype for your function for those cases.
10:53:28 <wavewave> k0ral: horizontalEnd may be related to only a certain part of your (Parameters a)
10:53:33 <rwbarton> :t negate
10:53:34 <lambdabot> forall a. (Num a) => a -> a
10:53:40 <rwbarton> it's definitely not fine
10:53:44 <rwbarton> are you confusing "negate" and "not"?
10:53:51 <wavewave> k0ral: then explicit define a data type for that..
10:54:08 <fedvasu> ok i got it,
10:54:18 <wavewave> k0ral: probably that data type is useful for horizontalEnd, horizontalHome and verticalEnd.... etc.
10:54:26 <sipa> fedvasu: what ws your question?
10:54:28 <sipa> was
10:54:34 <fedvasu> but i don't know how to , use boolean negate in ghci
10:54:44 <sipa> :t negate
10:54:46 <rwbarton> not?
10:54:50 <rwbarton> not is called "not"
10:55:00 <k0ral> wavewave: I shall do that
10:55:02 <rwbarton> > not (read "False")
10:55:03 <fedvasu> yeah, but wait
10:55:03 <lambdabot>   True
10:55:08 <geheimdienst> > negate 17
10:55:08 <lambdabot>   -17
10:55:13 <wavewave> k0ral: later on, you will be able to generalize your horizonal-thing to some more generic abstract function.
10:55:34 <fedvasu> ok , it does it , i got confused with the notation
10:55:41 <wavewave> k0ral: one key good idea for refactoring is that do not be afraid of making data types.
10:55:41 <fedvasu> i got it.
10:56:00 <wavewave> data types are always good.
10:56:20 <wavewave> data types usually always have the key idea of abstraction.
10:56:23 <yitz> wavewave: never say always. but yeah.
10:56:47 <wavewave> usually always sounds strange.. meh ;-P
10:56:59 <yitz> :)
10:58:01 <wavewave> k0ral: in fact, one impression I got from your code is that you are from OOP world and think monad stack as more like inherited class.
10:58:41 <wavewave> k0ral: that's probably why you wrote all your code in ReaderT s IO monad.
10:58:43 <k0ral> wavewave: you got it :)
10:58:50 <wavewave> k0ral: that's the thing you have to unlearn.
10:58:59 <k0ral> I would be glad to :)
10:59:08 <wavewave> k0ral: also I have to unlearn.. ;-P
10:59:44 <wavewave> k0ral: are you familiar with policy thing in OOP?
11:00:24 <wavewave> k0ral: I read a book by Andrei Alexandrescu : Modern C++ Design
11:00:57 <k0ral> policy ?
11:00:59 <wavewave> k0ral: that policy thing is more similar to haskell thing although it's again much different.
11:01:03 <k0ral> I'm afraid I don't see what you mean
11:01:10 <wavewave> k0ral: if you don't know, then never mind.
11:01:49 <wavewave> k0ral : I just wanted to make some analogy if you have a similar background.
11:02:28 <wavewave> k0ral: anyway...
11:02:41 <wavewave> k0ral: another thing I can tell you is
11:02:55 <wavewave> k0ral: although this is very distant now...
11:03:24 <wavewave> k0ral: GUI programming will be able to be reimplemented using FRP
11:03:36 <wavewave> k0ral: or more easily coroutine.
11:03:41 <mkscrg> how can you set constraints on associated type families? say you have a class A a that defines type AHelper a, and you want to use the constraint (Eq (AHelper a)). where does the constraint go?
11:03:57 <sipa> mkscrg: in de instance definition
11:04:44 <sipa> instance Eq (AHelper a) => A a where type AHelper a :: *
11:05:06 <sipa> eh, i'm confusing things
11:05:33 <wavewave> mkscrg: you can do that.
11:06:10 <k0ral> wavewave: I'm looking at what is FRP
11:06:29 <wavewave> mkscrg: if your constraint is necessary then in your class definition, if your constraint is special for a certain case, then in your instance definition.
11:06:50 <mkscrg> wavewave: can i put it in the class definition without using flexibleinstances?
11:06:52 <wavewave> mkscrg: nothing special compared with other type definition..
11:07:05 <wavewave> mkscrg: oh you have to use it.
11:07:14 <wavewave> FlexibleInstances is good.
11:07:46 <mkscrg> wavewave: ok, good to know.
11:08:01 <wavewave> FlexibleContexts is also good and often needed.
11:09:01 <ybit> i was thinking that destructive updates are what allow ocaml to generally perform better than haskell, since it allows for cache locality. kmc tells me haskell is able to desctructively update as well using IORef, MVar, and others. something must be different in how haskell implements this so that its slower currently
11:09:18 <wavewave> k0ral: I am now writing a GUI program using coroutine.. it's more simplified version of FRP..
11:09:21 <shapr> hurrah, I got my xmonad working again!
11:09:22 <ybit> this is me inviting conversation on the matter
11:09:26 * shapr does the cheerfuly happy dance
11:09:31 <ybit> aha, so you do use xmonad :)
11:09:34 <shapr> ybit: A Haskell matter?
11:09:37 <ybit> what was wrong with it?
11:09:47 <shapr> ybit: I don't know, but now it works.
11:09:54 <ybit> i don't understand that question :)
11:10:14 <ybit> minus my silly emoticon at the end
11:10:33 <wavewave> ybit: IORef is not slow..
11:10:37 <shapr> ybit: You said you were inviting conversation on the matter. What matter is that?
11:10:42 <ybit> ah
11:11:02 <ybit> shapr: see my comment right before you said "hurrah..."
11:11:16 <rostayob> is anyone here using the unification-fd package?
11:11:22 <wavewave> ybit:  at least not slow in principle.
11:11:24 <ybit> wavewave: i wasn't implying it's slow, it's just that haskell generally performs worse than ocaml
11:11:25 <shapr> ybit: I joined after your comment, thus I was unable to see it.
11:11:30 <ybit> oh
11:11:45 <ybit> 11:16 < ybit> i was thinking that destructive updates are what allow ocaml to generally perform better than haskell, since it allows for cache locality. kmc tells me haskell is able to  desctructively update as well using IORef, MVar, and others. something must be different in how haskell implements this so that its slower currently
11:12:01 <wavewave> ybit: I am not sure whether the statement is true any more.
11:12:17 <ybit> wavewave: shootout thinks so
11:12:54 <rostayob> ybit: does it? also, as kmc said, haskell has references
11:12:55 <shapr> I don't think the shootout actually matters that much.
11:13:12 <shapr> The real goal is to make things easy to use, so people can write software quickly and easily.
11:13:21 <ybit> rostayob: yes, http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ocaml&lang2=ghc
11:13:30 <shapr> The shootout uses very broad brush strokes to paint any sort of picture at all.
11:13:47 <ybit> shapr: but people can see the code used and suggest something faster
11:14:34 <shapr> I think I'll fix my hakyll atom feed, it's not validating correctly.
11:14:35 <ybit> shapr: i like that goal
11:14:50 <ybit> i just want it faster than that whatit currently is
11:14:54 <ybit> what it
11:15:05 <wavewave> ybit: shootout is very misleading nowadays.
11:15:11 <ybit> wavewave: why is that?
11:15:14 <rostayob> ybit: have you ever hit practical problems given by the speed of haskell?
11:15:26 <Phlogistique>     No instance for (Num a1)
11:15:28 <Phlogistique>       arising from the literal `0'
11:15:33 <rostayob> because that's when i'd start worrying, instead of worrying before based on a 10% difference in benchmarks
11:15:35 <ybit> i've been talking with some guys working in the financial industry, they prefer the ml languages because they are faster
11:15:38 <Phlogistique> does GHC mean that 0 is not a numeral?
11:16:02 <rostayob> ybit: maybe they don't know what they're talking about?
11:16:33 <mdxbhmt> Phlogistique: from where you are getting this?
11:16:58 <Phlogistique> mdxbhmt: a test program I'm writing
11:17:05 <rostayob> ybit: also, you never end with that kind of reasoning
11:17:15 <rostayob> there's always going to be the faster option
11:17:19 <ybit> rostayob: from my experience, they don't seem like someone who would bs me on the matter, they have years of experience writing code for large firms
11:17:22 <rostayob> and i don't think that ocaml is sinifically faster anyway
11:17:38 <mdxbhmt> Phlogistique: some mismatched type?
11:17:47 <shapr> ybit: Yes, you can make ML languages run faster, you can also make assembly run faster. But, the tradeoff I choose is to be able to develop and modify my programs faster.
11:17:51 <ybit> one of them is friends with a firm that writes strictly using haskell, but they work on different timescale
11:17:53 <wavewave> ybit: haskell is very rapidly changing..
11:17:55 <Phlogistique> mdxbhmt: indeed
11:17:59 <ybit> in the millisecond range
11:18:20 <shapr> For hard real-time applications, a lazy language doesn't match the hardware, and is not the best choice.
11:18:25 <jmcarthur> ybit: the ml family isn't really faster, IMO
11:18:30 <shapr> You want a strict language and a CPU with no OOE or caching.
11:18:38 <mdxbhmt> Phlogistique: if you are trying to do string-> Int,  you nead read i think
11:18:48 <mdxbhmt> > read "0" :: Int
11:18:48 <lambdabot>   0
11:18:53 <rostayob> ybit: 1) i don't know what your friends are doing 2) how is the fact that for some people haskell is not enough a problem for you?
11:18:57 <Phlogistique> mdxbhmt: that's not what I'm trying to do
11:18:59 <ybit> wavewave: i'm not arguing against haskell, i'm just wondering what it is that makes ocaml generally faster, and then i'd like to know what can be done to make haskell fater
11:19:01 <wavewave> ybit: for some very low-level thing, you need lots of optimization. that's unavoidable though.
11:19:04 <parcs_> the shootout is garbage now. all non-standard language implementations have been removed
11:19:07 <Phlogistique> mdxbhmt: I'll look into it some more; thanks
11:19:10 <jmcarthur> shapr: for hard real time you wouldn't use most things that even have a garbage collector
11:19:14 <parcs_> eg pypy, rubinius, luajit..
11:19:14 <mdxbhmt> Phlogistique: Good luck D:
11:19:24 <parcs_> the maintainer is a silly person
11:19:27 <jmcarthur> ybit: i don't think ocaml is faster
11:19:30 <ybit> by haskell i mean ghc
11:19:35 <jmcarthur> ybit: are we talking about a particular benchmark?
11:19:41 <wavewave> ybit: yes.. I understand your intent. It's quite hard to make conclusion at the current stage.
11:20:02 <rostayob> ybit: I think a lot of people could argue over "OCaml is generally faster"
11:20:13 <wavewave> ybit: I dare to say that all the previous saying before 2009 about haskell are just wrong.
11:20:51 <wavewave> you know there is no speed of language... only speed of compiled code.
11:21:06 <mdxbhmt> wavewave: there is development speed
11:21:10 <wavewave> ghc is under heavy development phase...
11:21:28 <wavewave> mdxbhmt: that's another thing but now we are talking about the resultant code speed.
11:21:38 <mdxbhmt> wavewave:  i know D:
11:21:46 <wavewave> ;-)
11:22:02 <ybit> jmcarthur: i linked to a shootout between ocaml and haskell, there were a few tests which showed ocaml winning. as i mentioned earlier, monochrom mentioned cache locality is what makes desctructive updating (du) so fast. kmc mentioned haskell too has this, so this makes me wonder if this is the actual reason ocaml is typically faster. maybe the ml langs use DU differently than haskell
11:22:08 * ybit reads above comments
11:22:25 <jmcarthur> ybit: ocaml has a terrible performance regression when you use a lot of mutation, actually
11:22:25 <wavewave> for example.. some bug in garbage collection in haskell was fixed ghc 6.12 which is in 2010.
11:22:38 <ybit> wavewave: yes, right, i do realize this re:speed of compiled code
11:22:40 <wavewave> ghc IO system is much rewritten in ghc 7..
11:22:53 <mdxbhmt> I know haskell won't be good at numerical problem from the lack of SSE2 etc support
11:23:10 <mdxbhmt> float numerical*
11:23:10 <jmcarthur> mdxbhmt: that should be somewhat improved with data parallelism though :)
11:23:22 <wavewave> mdxbhmt: even that is now being overcome by parallesim.
11:23:26 <wavewave> yeaj
11:23:26 <erus`> mdxbhmt you can write any parts that need micro optimization in C
11:23:29 <jmcarthur> mdxbhmt: and i think SSE2 support isn't too far around the corner, from recent discussion
11:23:30 <erus`> then call from ffi
11:24:02 <mdxbhmt> yes, that's true
11:24:19 <wavewave> but but but...In many cases, I have to admit that haskell code needs some optimization for performance... that's actually true.
11:24:53 <mdxbhmt> which in any case is not a problem, you must first have a working program, then make it faster
11:25:06 <wavewave> ybit: so the answer for yours is yes and no.. haskell can be quite slow with just very simple intuitive code... some times.
11:25:10 <ybit> 11:31 < erus`> mdxbhmt you can write any parts that need micro optimization in C
11:25:11 <mdxbhmt> doing otherwise is 'early optimization'
11:25:13 <ybit> good point
11:25:42 <jmcarthur> ybit: basically if you do a mutation in ocaml it has to do an expensive check to make sure that you aren't making things in the major heap point to things in the minor heap, and if you are then it has to do some other terrible magic. it could be significantly improved fairly easily, but a fundamental limitation still lies there due to how its GC works.
11:25:45 <wavewave> but normally, that's a job of library writers and gurus...
11:26:22 <wavewave> worrying too much about it is not very helpful usually at the level of choosing language.
11:26:50 <wavewave> worrying more about maturity of libraries and ecosystem is more sensible to me.
11:27:12 <jmcarthur> ocaml *should* be a lot faster than it actually is
11:27:15 <wavewave> and haskell definitely passed a point of that kind of worry now, i think.
11:27:52 <mdxbhmt> wavewave: isn't dificult to judge maturity of a lib on hackage?
11:28:12 <wavewave> mdxbhmt: I mean necessary libraries.
11:28:31 <ghosting> Haskell is fat sluggish but intelligent
11:28:31 <wavewave> mdxbhmt: and you know library adding speed. ;-)
11:28:42 <wavewave> basically means community size.
11:28:42 <ybit> i completely forgot about ffi, if i run into performance problems i know what to do
11:29:01 * ybit stops prematurely worrying about optimization
11:29:09 <Rotaerk_> ghosting, why do you say that?
11:29:09 <wavewave> ybit: so shootout is misleading.
11:29:35 <wavewave> ybit: just follow as you heart goes.. ;-)
11:29:42 <ybit> heh :P
11:30:13 <wavewave> seriously.. I do haskell programming simply because I love it.
11:30:14 <ghosting> It comes off that way after using c and others for so long
11:30:32 <ybit> i love the community and the knowledge i've been gaining by learning it
11:30:42 <wavewave> probably I am the only person programming haskell entirely in my field.
11:30:55 <ybit> wavewave: if you don't mind me asking, which field?
11:31:04 <wavewave> particle physics theory.
11:31:12 <ybit> best field ever
11:31:17 <ion> I’d love to understand some of that.
11:31:21 <mdxbhmt> ha, i have a friend on particle physics that also is interested on haskell
11:31:23 <mdxbhmt> hahaha
11:31:40 <ion> There should be something like ml-class or Khan Academy for getting started in theoretical physics. :-)
11:31:56 <wavewave> but recently I did some computationally intensive job using haskell before anyone did
11:31:57 <hpaste> someone pasted “someone” at http://hpaste.org/53601
11:32:09 <ybit> ion: don't forget the ai class :)
11:32:25 <ybit> www.ai-class.com
11:32:26 <wavewave> just simply 'development time' matters.  and 'enthusiasm' matters.
11:32:43 <ion> ybit: I’m there, too, but the quality of ml-class has been better IMNSHO.
11:33:09 <ybit> wavewave: are you dealing with individual particles or a group of them, maybe at the femto scale?
11:33:28 <ybit> ion: i agree
11:33:40 <ybit> ion: ai has a broader scope though, i like that
11:33:57 <wavewave> ybit: no. that's what experimentalists are doing.. and it has very hard realtime constraints.
11:34:23 <wavewave> ybit: I was doing some general model comparison using montecarlo simulation.
11:34:38 <wavewave> from LHC result and tevatron result.
11:35:12 <wavewave> basic montecarlo programs are written in fortran previously (a decade ago.)
11:35:27 <mdxbhmt> kilometric fortran, probably
11:35:57 <ybit> wavewave: i would love to get in your field at some point, maybe when i'm 47 years old i'll think about it
11:36:02 <wavewave> mdxbhmt: yes and no... in fact fortran is quite efficient in writing formula.
11:36:39 <mdxbhmt> wavewave:  hmmm
11:36:43 <ybit> closest thing around here is a professor at a local college, val. dolmatov, specializing in electron configuration
11:36:47 <k0ral> wavewave: you tell me not to be afraid of gathering some "attributes" (sorry for my OOP interpretation) into a new datatype, but doesn't that imply chaining many more "accessors" function to finally get the "attribute" I want ?
11:36:54 <wavewave> what I am writing in haskell was basically a kind of integration software.. doing cluster jobs and gathering information in web servers something like that.
11:37:03 <ybit> v.k. dolmatov if you want to google scholar
11:38:07 <wavewave> mdxbhmt: it's because of its built-in features (like built-in complex number and powers )
11:39:11 <mdxbhmt> i'll probably need to write fortran one day
11:39:39 <wavewave> k0ral: one way is just to make a local attribute in your structure.
11:40:10 <wavewave> k0ral: it's hard to discuss it without an example.
11:41:01 <wavewave> k0ral: what I can tell you is just make some datatype structure and pass them as a function argument.
11:41:21 <wavewave> k0ral: and your data structure must be much simpler than your global structure.
11:41:32 <wavewave> k0ral: if not, there is no reason why to make..
11:42:06 <wavewave> k0ral: but if you need, consider Lenses or fclabels or something like that.
11:42:23 <wavewave> mdxbhmt: in fact, fortran 95 is not bad...
11:42:43 <wavewave> mdxbhmt: bad fortran is fortran 77 and before...
11:42:51 <mdxbhmt> wavewave: hmmm that's encouraging
11:43:07 <wavewave> mdxbhmt: I have to deal with that old legacy codes often....
11:43:59 <wavewave> anyway, I do feel that I am blessed that I just got to know haskell before anybody else in our field. ;-D
11:44:21 <erus`> any music people in here? why in an add9 chord do i add a note 5 semitones above the root?
11:44:26 <erus`> why not 9?
11:45:35 <mdxbhmt> that's a case of strange algebra lol
11:46:31 <byorgey> erus`: first of all, an add9 chord adds a note 2 semitones above the root, not 5
11:46:32 <ziman> you add 9 "tones" above the root, which wraps around to octave+2 semitones
11:46:44 <byorgey> erus`: and the 9 does not refer to semitones, but to scale steps
11:46:47 <mah_b> erus`: http://www.wolframalpha.com/input/?i=add9&a=*MC.add9-_*MusicChord-
11:47:45 <byorgey> erus`: the reason it is 9 and not 2 is because you can think of it as a natural extension of 1-3-5-7-9
11:48:09 <erus`> ah
11:48:18 <byorgey> if you want to continue discussing it we should probably move to #haskell-blah
11:53:21 <dylex> @pl \f x -> (f x, f x)
11:53:21 <lambdabot> ap =<< ((,) .)
11:54:24 <hpaste> barish pasted “barish” at http://hpaste.org/53602
11:55:20 <erus`> hpaste needs wrapping
11:55:29 <monochrom> I agree
11:55:38 <ion> > (join (,) .) succ 'x'
11:55:40 <lambdabot>   ('y','y')
11:56:34 <Mathnerd314> can every sort of operation tied to a data structure be written using a series of folds and unfolds?
11:56:50 <dylex> ion: that's better
11:56:59 <SavageSimian> anybody here work with EclipseFP on Win7 ?
11:57:02 <wavewave> 'every' is hard to be justified.
11:57:30 <wavewave> Mathnerd314: many operations are.
11:59:23 <SavageSimian> i've run into a problem that appears to be common with the Eclipse Haskell plugin. "double-conversion-0.2.0.1 ... <command line>: can't load .so/.DLL for: stdc++". so far i haven't run into a fix that works. anybody got a suggestion?
11:59:48 <wavewave> SavageSimian : are you usin mac?
11:59:59 <SavageSimian> no. Win7 on a PC.
12:00:35 <wavewave> Ah.. probably it is a file name problem.. in mac case,it was.
12:00:48 <wavewave> where is your libstdc++.DLL?
12:00:56 <erus`> how do i do     Eq+Show a => a  -> a
12:01:22 <SavageSimian> hold on. i'll look.
12:02:19 <dylex> erus`: (Eq a, Show a) => a -> a
12:02:29 <erus`> ah ok
12:04:35 <SavageSimian> the closest i can find is "Haskell Platform\2011.2.0.1\mingw\bin\libstdc++-6.dll"
12:05:56 <wavewave> SavageSimian : make a link of it to libstdc++.dll
12:06:38 <wavewave> SavageSimian: in cygwin, you can do that with ln -s  ( am i right? )
12:07:32 <SavageSimian> not sure i can do that in windows. i'll just make a copy. (i don't use cygwin. i'm a VS kinda guy. Bill Gates is my daddy. :p )
12:08:10 <wavewave> SavageSimian: okay, whatever... what does it give?
12:08:37 <wavewave> that's how I solved it in mac.
12:09:43 * hackagebot sednaDBXML 0.1.2.4 - Sedna C API XML Binding  http://hackage.haskell.org/package/sednaDBXML-0.1.2.4 (EricJones)
12:11:17 <wavewave> at least, if we can change HashTable in k-nucleotide using the fast HashMap or whatever in language shootout, haskell speed will be marked faster than before.
12:11:36 <SavageSimian> still no joy. "install failed for browser server"
12:11:49 <wavewave> current code looks like a version before ghc 6.12.
12:12:14 <wavewave> SavageSimian : hmm at least you solve double-conversion problem.
12:12:38 <SavageSimian> naw. it's still there. the error is identical to the original.
12:12:47 <steakknife> Has anyone thought of doing a ruby hotline for haskell?
12:12:53 <wavewave> SavageSimian: hmm ..
12:12:56 <SavageSimian> the previous error was in a popup.
12:13:26 <SavageSimian> i guess i'll go ahead and post on the EclipseFP forum.
12:13:48 <wavewave> SavageSimian: make sure that your library path directory includes the dll directory.
12:14:04 <byorgey> steakknife: what's a ruby hotline?
12:14:26 <wavewave> I do not use windows so I don't think I can help more...
12:14:40 <SavageSimian> i'll give it a shot. thanks.
12:17:21 <SavageSimian> according to the research i've been doing the double-conversion problem appears to be a problem with GHC. if it were that cabal can't find libstd++ i'd think there would be more errors when compiling the scion server.
12:19:25 <wavewave> SavageSimian: it can be different. it gives an error when it invoke ghci during the compilation.
12:20:21 <wavewave> SavageSimian: if a code that uses template haskell is being compiled, ghci is invoked. ghci only uses dynamic libary..
12:20:55 <wavewave> SavageSimian: so  ghc compilation uses libstdc++.a and probably it found that library file okay
12:21:14 <wavewave> but ghci uses libstdc++.dll and can have a problem.
12:22:01 <wavewave> that was my understanding of the problem that happened in my system. I guessed that you might encounter simlar situation in windows.
12:22:05 <wavewave> but who knows.
12:22:09 <SavageSimian> ok. i'll see if adding the *.dll folder to my path will help.
12:23:38 <pandacat> Are there any alternative to windows cmd.
12:23:56 <fryguybob> pandacat: powershell, msys
12:23:56 <wavewave> power shell?
12:24:00 <wavewave> monad>
12:24:18 <pandacat> cool, ill look them up.
12:24:26 <wavewave> it was originally code-named 'monad'
12:24:39 <wavewave> did SPJ play some role there?
12:24:55 <mdxbhmt> afaik  not
12:25:16 <mdxbhmt> he was not involved, i think
12:26:09 <wavewave> it's ironic that ghc works best in unix machines until now. ;-P
12:30:45 <pandacat> Sighs I am gonna have to make the switch to linux I guess
12:32:08 <wavewave> pandacat: use cygwin.
12:32:37 <pandacat> Yeah, it seems like a much better alternative.
12:32:53 <Nimatek> Programming on windows is an exercise in frustration anyway.
12:33:19 <mdxbhmt> why so?
12:33:27 <SavageSimian> i have absolutely no problem programming .NET.
12:33:29 <wavewave> what's status with haskell .net ?
12:33:48 <erus`> wavewave: f# ?
12:33:57 <Nimatek> mdxbhmt: Installing libraries, using a proper toolchain..
12:34:06 <Nimatek> But yes, .NET works well.
12:34:25 <SavageSimian> afaik there is no haskell.net. the closest thing is F# which is closer to OCAML
12:34:29 <wavewave> erus` : i mean 'haskell' interoperatabble with .net component.
12:34:41 <mdxbhmt> Nimatek: those problem arises from linux tool, don't they?
12:34:46 <erus`> i would rather see haskell -> javascript first
12:35:09 <luite_> erus`: have you started working on ghcjs yet? ;p
12:35:18 <adrake> erus`: that'd be exciting. there's no js tail call
12:35:19 <Nimatek> mdxbhmt: It also arises from many windows-specific quirks.
12:35:25 <erus`> no im waiting for someone else to fix it for me :)
12:35:43 <SavageSimian> i'd love to see Visual Haskell. from what i've see there used to be one for VS 2005 but it wasn't updated to 2010.
12:35:52 <wavewave> tail call is the current block in ghcjs??
12:35:59 <luite_> SavageSimian: there was someone working on it
12:36:08 <mdxbhmt> Nimatek: I can't argue with that
12:36:10 <dgpratt> luite_: Phyx?
12:36:14 <SavageSimian> oh yea? any progress?
12:36:14 <luite_> yeah
12:36:25 <erus`> wavewave: having to recompile ghc is my block
12:36:44 <adrake> wavewave: I don't know anything about ghcjs, that js function calls are expensive sort of seems hard to overcome
12:36:59 <adrake> if there's a clever way to avoid it then awesome :)
12:37:02 <luite_> wavewave: there's an implementation with trampolining should be ok
12:37:40 <wavewave> ah.. web community.... simply use haskell!!!
12:37:46 <luite_> adrake: is that really true anymore?
12:38:16 <wavewave> ghc for every browser!
12:38:18 <paolino> gnome-shell  is configured in javascript
12:38:36 <dgpratt> SavageSimian: the last time I brought it up with Phyx, he said he hadn't any time to work on it recently
12:38:58 <adrake> luite_: yeah, it's pretty bad. mozilla's js engine is moving toward inlining as much as it can to avoid it
12:39:14 <adrake> bring recursion into the mix and you're sort of stuck
12:39:47 <luite_> hmm
12:40:13 <wavewave> there's some evil force against FP... hmm
12:40:22 <adrake> well, the real evil force is imperative programming :P
12:40:34 <monochrom> COME JOIN THE DARK SIDE!
12:40:53 <adrake> if fp was common, js engines would be optimized for that, instead/too :P
12:48:46 <W_Blas> I'm a beginner in Haskel. I have the following problem: I have two lists of string tuples [(String, String)] and I need to join 'em into third list, so that if (u, v) is in the first list and (v, w) is in the second list, then the third list must contain a tuple (u, w). How to write such a program?
12:50:00 <byorgey> W_Blas: is this an assignment for class or are you just learning on your own?
12:51:12 <mdxbhmt> this can be done by pattern matching, but i'm trying to see how to do it by list comprehension
12:52:12 <Nimatek> > zipWith (\(a,b) (c,d)  -> (a,d)) [("u1","v1"), ("u2","v2")] [("v1","w1"), ("v2","w2")]
12:52:13 <lambdabot>   [("u1","w1"),("u2","w2")]
12:52:14 <geheimdienst> > map (\x -> x+6) [1,2,3,4] -- W_Blas: a good place to start would be to get a feel for the 'map' function, and go from there
12:52:15 <lambdabot>   [7,8,9,10]
12:53:21 <mdxbhmt> ...zip magic
12:54:06 <geheimdienst> Nimatek: nice, but i guess that isn't what he meant ...
12:54:08 <byorgey> > zipWith (\(a,b) (c,d)  -> (a,d)) [("u1","v1"), ("u2","v2")] [("v2","w2"), ("v1", "w1")]
12:54:09 <lambdabot>   [("u1","w2"),("u2","w1")]
12:54:44 <Nimatek> geheimdienst: That's how I understood the problem description.
12:54:49 <W_Blas> byorgey: This is my homework. I'm not asking to do it for me, but I have lots of questions about it, such as how to iterate through a list. Or maybe there is another way to do that, than the one I'm thinking about.
12:54:58 <geheimdienst> byorgey: omg how did you get access to my private lambdabot window? i have exactly that in there!!1! ;-)
12:55:10 <W_Blas> geheimdienst: Thanks!
12:56:05 <byorgey> W_Blas: do you know about list comprehensions?
12:56:29 <W_Blas> byorgey: No, I don't.
12:57:00 <byorgey> W_Blas: they might be useful. But I don't know if your instructor wants you to use/not use certain language features.
12:57:20 <byorgey> W_Blas: are you using some sort of textbook in your class?
12:57:37 <shachaf> Presumably W_Blas means (u,v1) and (v2,w) such that v1 == v2, taken anywhere from either list?
12:58:14 <W_Blas> shachaf: Exactly.
12:59:06 <geheimdienst> W_Blas: using "map" is one way, but have a look at that and see if anything looks relevant http://www.haskell.org/haskellwiki/List_comprehension (hint: it should)
12:59:49 <byorgey> just 'map' by itself is not enough, actually.
13:00:02 <byorgey> W_Blas: you may also be interested in reading LYAH
13:00:06 <byorgey> @where LYAH
13:00:06 <lambdabot> http://www.learnyouahaskell.com/
13:01:52 <erus`> to one of my bug reports for hslint got fixed today
13:02:04 <erus`> i should get my name in the changelog
13:02:05 <steakknife> byorgey: check it out http://www.pockethotline.com/
13:02:13 <erus`> or contributors.txt
13:02:14 <W_Blas> byorgey: It's not a big deal, the deadlines for assignmet are the 9th of Novemeber and January 2012 so I have an opportunity to ask my tutor. I have Real word Haskell by Sullivan.
13:02:41 <shapr> W_Blas: Whoa, you're using Real World Haskell as a textbook?
13:03:02 <geheimdienst> byorgey: yeah, i was suggesting that as a starting point ...
13:03:08 <yitz> steakknife: are you a person or a bot?
13:03:27 <shapr> steakknife: This is your Turing Test. You must respond usefully or be banned for life.
13:03:30 <steakknife> geheimdienst:  is this bos class by chance?
13:03:32 <W_Blas> No I've just found it by accident
13:03:40 <steakknife> unfortunately human. you?
13:03:48 <W_Blas> hapr:  No I've just found it by accident
13:03:57 <geheimdienst> steakknife: hm?
13:03:58 <shapr> steakknife: Is this hotline related to Haskell?
13:04:19 <steakknife> shapr: well it could be if someone set it up.
13:04:19 <shapr> steakknife: The hostname certainly looks like spam.
13:04:38 <geheimdienst> shapr: he was suggesting we make one of these for haskell, since apparently ruby has one ...
13:04:40 <steakknife> it looks like spam but it's awesome.
13:05:11 <erus`> who would answer haskell calls in their free time?
13:05:18 <steakknife> i don't see that they're charging anything at this point.
13:05:34 <shapr> I dunno man, seems like overkill to me.
13:05:36 <steakknife> whomever wants to be most awesome.
13:05:49 <shapr> I want to finish awesome projects, that's not the same thing at all!
13:06:49 <steakknife> For example, I'm having this issue with railties initializers however the irc group isn't much help.
13:06:58 <steakknife> ^— #rubyonrails
13:07:43 <shapr> joyfulgirl: Are you learning Haskell?
13:08:27 <shapr> steakknife: If I can't find any online information on a task I wish to accomplish, I write a tutorial as I go along. That way maybe other people can benefit once I'm done.
13:08:57 <scooty-puff> can someone help me with use of Data.Generics?
13:09:10 <shapr> steakknife: I've found that to be very successful at increasing the popularity of various things.
13:09:18 <steakknife> shapr: to finish awesome projects, sometimes you need to know things that only a smaller group of people know to save time.
13:09:19 <qnikst> hello, can somebody advice how can I add test data to function run by criterion package, I need to create ByteString with following properties: 1). fixed length 2). I need a fixed number of special character in it
13:09:21 <scooty-puff> getting a few ambiguous type `a' in the constraint (Typeable a) errors
13:09:35 <shapr> steakknife: Except, sometimes nobody really cares about some subjects (the vagaries of mounting a three inch tire on a unicycle).
13:10:27 <steakknife> shapr: is there a connection to how that relates?
13:10:58 <shapr> Yah, I think the connection is that if you have the chance to document something others may not know, that's a worthwhile accomplishment.
13:11:05 <shapr> But at the same time, you never really know what might be popular.
13:11:29 * companion_cube wonders if there exists a scooty-puff junior
13:13:20 <scooty-puff> good to know its assumed i'm the doombringer
13:14:26 <hpaste> scooty-puff pasted “Generics issues” at http://hpaste.org/53603
13:14:43 * hackagebot hlint 1.8.18 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.18 (NeilMitchell)
13:14:45 * hackagebot cmdargs 0.9 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.9 (NeilMitchell)
13:15:01 <joyfulgirl> shapr: Yup
13:15:09 <joyfulgirl> But I haven't been working on it lately, tbh
13:16:17 <steakknife> shapr: Documentation's great.  But the idea of a hotline is that sometimes it's faster and easier to talk to someone awesome whom possibly wrote the framework.
13:17:09 <steakknife> shapr: Sometimes 2 minutes with a key developer can save someone 16 hours.
13:18:13 <steakknife> Anyhow if people don't like it, whatever.  I'll find a community that's more helpful.
13:18:18 <Mathnerd314> zipWith f x y == pure f <*>x <*> y, right?
13:18:34 <shachaf> Mathnerd314: No.
13:18:39 <shachaf> Only if you use ZipList.
13:19:03 <Mathnerd314> oh.
13:20:00 <Mathnerd314> right, how did I forget that discussion last year?
13:21:13 <Mathnerd314> and I think I concluded that ZipList a was a subset of the monad Stream (Maybe a)
13:22:13 <Mathnerd314> (where data Stream a = Stream a (Stream a))
13:22:41 <W_Blas> What am I doing wrong: ff dA dB = map ( \(p,q) -> map ( \(u,v) -> [ (p, v) | q == v ] ) dB ) dA ?
13:23:01 <scooty-puff> HAH!
13:23:05 <scooty-puff> ok it was ext1Q vs. extQ
13:23:24 <scooty-puff> that'll teach me to scroll down all the way..
13:23:34 <scooty-puff> (in the data.generics.aliases doc)
13:32:24 <dgpratt> W_Blas: you said that the second value of the first pair must match the first value of the second pair, yes?
13:33:17 <dgpratt> it looks like you're comparing the second value of each pair
13:33:55 <W_Blas> dgpratt: Well, yes, that's a typo, but there is a syntax error as well: ff dA dB = mapM_ ( \(p,q) -> (mapM_ ( \(u,v) -> [ (p, v) | q == u ] ) dB) ) dA
13:34:53 <Nimatek> W_Blas: You don't need mapM_ in non-monadic functions.
13:35:00 <dgpratt> W_Blas: mapM_? I don't think that's what you want, how about just 'map'
13:35:28 <rwbarton> [ (p, v) | q == u ] is pretty stylish
13:36:31 <W_Blas> I've tried both with no luck. I get the following syntax error: Couldn't match expected type `(String, String)'
13:36:31 <W_Blas> with actual type `[b0]'
13:36:32 <W_Blas> In the return type of a call of `map'
13:36:32 <W_Blas> In the expression: (map (\ (u, v) -> [(p, v) | q == u]) dB)
13:36:32 <W_Blas> In the first argument of `map', namely
13:36:32 <W_Blas> `(\ (p, q) -> (map (\ (u, v) -> [(p, v) | q == u]) dB))'
13:36:39 <rwbarton> that's not a "syntax error"
13:36:43 <rwbarton> it's a type error
13:36:54 <W_Blas> Maybe I have to cast type to String
13:36:57 <W_Blas> ?
13:36:59 <rwbarton> no
13:37:08 <rwbarton> it looks like you want concatMap?
13:37:18 <geheimdienst> W_Blas: for code or errors longer than 1 line, please use hpaste
13:37:25 <geheimdienst> @where hpaste
13:37:25 <lambdabot> http://hpaste.org/
13:38:10 <monochrom> paste completely.
13:38:12 <hpaste> Nimatek pasted “meh” at http://hpaste.org/53604
13:38:12 <W_Blas> geheimdienst: Sorry!
13:38:21 <geheimdienst> W_Blas: no worries :)
13:39:23 <W_Blas> rwbarton: concatMap works like a charm! Thanks!
13:40:10 <monochrom> for beginners, type errors reflect thought errors
13:40:42 <Berengal> monochrom: I find that's still true after several years of programming
13:40:44 <geheimdienst> for experts, type errors reflect megalomania
13:40:53 <byorgey> s/for beginners, //
13:41:02 <Berengal> (Unless you're Oleg)
13:41:37 <int-e> well a lot of times they simply point at typos.
13:41:42 <monochrom> well, for experts, some type errors are type system limitations. for example there are some legit infinite types
13:41:54 <Berengal> True
13:41:59 <int-e> which ... I suppose means I should use longer identifiers.
13:42:20 <Berengal> int-e: I'm sure the most common typo is leaving off a ' at the end
13:42:59 <monochrom> but GHC relaxes the type system so much that, yes, there are fewer and fewer limitations
13:44:37 <monochrom> oleg stays amazingly well within Haskell 2010's boundary, actually
13:45:47 <monochrom> AFAIK his only excursion is in implementing delimited continuations. one legit use of unsafeCoerce is there. that's about all.
13:46:13 <monochrom> alright, that implementation also uses GADT
13:46:39 <hpc> GADTs might as well be considered standard at this point :P
13:47:01 <monochrom> but overall it seems that in most of his articles he takes pride in saying "the following is Haskell 98" :)
13:48:24 <hpc> http://haskell.spreadshirt.com/oleg-already-did-it-A6499531 -- haha
13:48:43 <int-e> . o O ( no type checkers were harmed in the preparation of these notes. )
13:49:00 <Phlogistique> Hey there
13:49:04 <shachaf> monochrom: unsafeCoerce is in Haskell 2010. :-)
13:49:14 <monochrom> what??!!!
13:49:15 <int-e> (I'm musing whether Oleg should add a disclaimer like that to his posts.)
13:49:26 <Phlogistique> Is there any alternative Haskell library not using fancy haskell extensions and complex types?
13:49:35 <Phlogistique> with a more straightforward interface?
13:49:41 <rwbarton> library for what?
13:49:45 <int-e> monochrom: it is because FFI is included, thus you can use unsafePerformIO and implement unsafeCoerce ;)
13:49:48 <Phlogistique> ooops, sorry
13:49:51 <Phlogistique> Regexes
13:49:56 <shachaf> Right.
13:50:00 <monochrom> right, I just figured
13:50:44 <Berengal> int-e: Isn't unsafeCoerce part of the dynamic stuff?
13:50:59 <monochrom> even the regex lib you're using has a non-fancy API.
13:51:51 <yitz> Phlogistique: a regex by its nature takes a variable number of parameters
13:52:02 <shachaf> yitz: What?
13:52:20 <Berengal> yitz: Sure you're not confusing regexes with format strings?
13:52:22 <Phlogistique> yitz: variable? really?
13:52:52 <yitz> ok let's try that again
13:53:36 <int-e> wee, there's unsafeLocalState in Foreign.Marshal.
13:53:36 <yitz> a regex, after you match it, produces a varialbe number of values. (better?)
13:54:19 <rwbarton> fortunately Haskell has data structures that can represent a variable number of values :)
13:54:19 <int-e> @type Foreign.Marshal.unsafeLocalState
13:54:20 <lambdabot> Not in scope: `Foreign.Marshal.unsafeLocalState'
13:54:21 <yitz> Phlogistique: and those values can have varying types
13:54:28 <Berengal> yitz: s/variable number/list/
13:54:38 <Phlogistique> yitz: indeed. does that require Multi-parameters type definitions and Functional dependancies?
13:54:52 <Berengal> A regex
13:55:07 <monochrom> that's a variable number of return values
13:55:12 <yitz> Phlogistique: so if the regex is specified by a string, you'll need some kind of type trickery
13:55:13 <Berengal> A regex matches only strings, I think?
13:55:24 <Phlogistique> yitz: why?
13:55:24 <int-e> unsafeLocalState :: IO a -> a
13:55:38 <Phlogistique> is Regex -> [Match] so complicated?
13:55:48 <rwbarton> no
13:56:05 <yitz> Phlogistique: whereas if you're regex is specified by some kind of typed combinators - well, in that case, you might as well use a parsing combinator library that's designed for that.
13:56:43 <yitz> Phlogistique: what does Match look like?
13:56:46 <W_Blas> How to write an annotation for function that takes list and returns list, f :: [] -> []?
13:56:55 <Berengal> The only regex type-trickery I've seen is stuff to get the match result to be whatever type you want, wether that is a bool, a list of strings matched or a list of more complicated stuff, like start and end position etc.
13:57:04 <monochrom> f :: [a] -> [a]  given your information
13:57:38 <byorgey> W_Blas: f :: [a] -> [a]  would mean it can take a list with any type of elements and return a list with the same type
13:57:46 <monochrom> any name starting with lowercase in place of "a" is also fine, e.g., f :: [vX] -> [vX]
13:57:51 <Phlogistique> yitz: a starting position, an end position, and a list of submatches. why?
13:58:04 <Phlogistique> (a submatch being a starting position and an end position)
13:58:08 <int-e> I missed the fact that haskell2010 changed the name of unsafePerformIO.
13:58:08 <byorgey> W_Blas: if it can only take lists with a specific type of elements, then you would write, say,  f :: [Int] -> [Int]  if it only works on lists of Ints
13:58:23 <W_Blas> byorgey: Thanks! That's the thing I want!
13:58:26 <byorgey> int-e: o rly?
13:58:52 <byorgey> int-e: what's the new name?
13:59:28 <int-e> unsafeLocalState, as mentioned above -- and I mean the adaption of the FFI extension.
13:59:58 <Nimatek> W_Blas: If you're unsure, load it into ghci and query the type of your function with :t - it will give the most general annotation.
14:00:55 <int-e> byorgey: oh it's actually unsafeDupablePerformIO. Funny.
14:01:13 <yitz> Phlogistique: hmm i suppose in principle you don't need any type extenstions then.
14:01:17 <Phlogistique> Berengal: well, that's a lot of type trickery already
14:01:33 <Berengal> Phlogistique: yes, I'm not a big fan
14:02:51 * byorgey is a fan
14:02:58 <kmc> h10 call it unsafeLocalState iirc
14:03:01 <byorgey> it's a DSL syntax with multiple interpretations, what's not to like?
14:03:15 <Berengal> Phlogistique: Have you seen http://hackage.haskell.org/package/pcre-less ?
14:03:17 <byorgey> and it doesn't require a lot of "trickery", just type classes.
14:03:27 <Phlogistique> byorgey: added complexity, the fact that there is no up-to-date doc
14:03:27 <int-e> Berengal: the dynamic stuff is not part of haskell2010 though, as far as I can make out.
14:03:47 <Berengal> byorgey: If you're not familiar with it, it's a bit hard to use
14:03:55 <kmc> and GHC still implements it with unsafePerformIO, afaik
14:04:09 <kmc> but there was a mailing list thread suggesting switching to unsafeDupablePerformIO
14:04:10 <byorgey> ahh, now a lack of good documentation I am very sympathetic to
14:04:17 <byorgey> but that is a separate issue =)
14:04:52 <int-e> kmc: it's changed in git at least
14:04:59 <Berengal> byorgey: The principle is sound, I can agree with that
14:05:00 <kmc> oh really, cool
14:05:24 <Berengal> It's just the indirection is a bit bothersome
14:06:05 <Phlogistique> http://hackage.haskell.org/packages/archive/pcre-less/0.2.1/doc/html/src/Text-Regex-Less.html#<< why the hell does it export this?
14:06:06 <int-e> kmc: actually it appears to be unsafeDupablePerformIO in ghc 7.2.1, too.
14:07:05 <Phlogistique> 22:13:07 < Berengal> It's just the indirection is a bit bothersome <- yes that. It's pretty unintuitive for example that there is an instance for String, for [[String]] but not for [String]
14:07:20 <kmc> int-e, ah, I just checked the latest haskell2010 package on hackage
14:07:24 <Phlogistique> and that there is an instance for (Int, Int) but not for [(Int, Int)]
14:07:25 <kmc> i guess it has not been updated for ghc 7.2 yet
14:08:11 <int-e> which I imagine means that you cannot use unsafeLocalState to implement unsafeCoerce safely. hehe :)
14:08:12 <kmc> fwiw I benchmarked the overhead of noDuplicate as about 70 μs on my machine, in one test
14:08:27 <kmc> but I expect it to be context-dependent
14:08:40 <kmc> if your evaluation stack is deeper, it will take longer
14:09:01 <Berengal> In general, when I see a function like "foo:: (SomeClass x y z, OtherClass a b) => x a b -> y z -> a -> b y" I become somewhat annoyed at the author
14:09:20 <kmc> Berengal++
14:09:45 <kmc> they should have gone all the way
14:09:46 <Philippa> yeah, you should make the variable names longer at the least in cases like that
14:09:57 <kmc> class C a where { x :: a }
14:10:04 <Berengal> Especially if it's just "foo = fromOtherClass . internalFoo . toPreciceType"
14:10:09 <kmc> now everything can be an instance of C
14:10:21 <kmc> and your program just combines x in the proper order
14:10:31 <Berengal> Hah, yes
14:11:08 * byorgey doesn't really see what all the fuss is about.
14:11:18 <byorgey> (full disclosure: many functions in diagrams-lib have types like that)
14:11:27 <Berengal> byorgey: Again, documentation
14:11:45 <byorgey> ok, well complain about documentation then, not types =)
14:11:46 <Berengal> First of all, it's absolutely impossible to read the haddoc and gain an overview of the library
14:12:06 <kmc> it particularly annoys me when I'm expected to write a newtype and an instance, instead of just passing a function to whatever function is actually doing the work
14:12:09 <Berengal> You need fully fledged tutorials to make sense of that stuff
14:12:27 <byorgey> Berengal: well, I do agree with that.
14:12:31 <Berengal> Also, finding out which instances exist can be hard
14:12:32 <kmc> (i haven't noticed it with diagrams; the overloading seems to make sense there)
14:12:51 <Berengal> You often have to load up ghci and import the entire universe to get all the available instances
14:13:14 <byorgey> kmc: interesting.  I wonder if we can come up with a theory of when it makes sense and when it is annoying.
14:13:49 <byorgey> Berengal: Haddock does at least help with that.
14:13:53 <kmc> but, y'know, I'm annoyed by things like:  class Fooable a where { foo :: a -> Int };  bazulate :: (Fooable a) => [a] -> String
14:13:58 <Berengal> byorgey: I think that's called software engineering
14:14:03 <kmc> i'd rather use bazulate :: (a -> Int) -> [a] -> String
14:14:18 <byorgey> Berengal++
14:14:20 <byorgey> kmc: agreed
14:14:27 <kmc> yeah, I haven't put anywhere near enough thought into the theory here
14:14:29 <Berengal> kmc: In that specific case I'd rather have bazulate :: [Int] -> String
14:14:32 <byorgey> I guess s/Fooable/Intable/
14:14:40 <kmc> Berengal, touché
14:14:47 <Berengal> But I agree with the idea
14:15:06 <companion_cube> keep it simple..
14:15:07 <kmc> i guess I should have used an example like «[a] -> [a]»
14:15:15 <kmc> the best I have are some theories about why people overuse type classes
14:15:21 <kmc> but I haven't really tested those theories, either
14:16:01 <Berengal> byorgey: One thing I've noticed is that once you use functional dependencies the difficulty of understanding the library from haddoc reference alone increases by several orders of magnitude
14:16:23 <yitz> byorgey: Phlogistique has a point. most people who want to use a regex don't want to read a tutorial or puzzle out types. they just want to get out part of string.
14:17:12 <byorgey> yitz: that's a good point.
14:17:51 <byorgey> Berengal: I agree, I find fundeps unintuitive as well.  diagrams does not use them (although it does use a tone of other GHC extensions =)
14:17:56 <byorgey> *ton
14:18:43 <luite_> tonne!
14:19:16 <kmc> yeah, the standard regex library is a big offender here
14:19:42 <byorgey> diagrams uses 1.4 metric tonnes of GHC extensions
14:19:52 <Phlogistique> yitz, byorgey: maybe I should write up a document specifying the interface of a simple Regex library for Haskell and get comments on it?
14:20:04 <Phlogistique> yitz: is the Haskell wiki appropriate for this?
14:20:04 <kmc> i think it has been tried
14:20:10 <kmc> there are plenty of alternative regex libs on Hackage
14:20:20 <Phlogistique> ok
14:20:21 <kmc> i haven't seen a good comparative overview
14:20:26 <byorgey> Phlogistique: if you ask for comments you'll get endless arguing
14:20:34 <kmc> but I'd love to see your proposal alongside such a comparison
14:20:49 <yitz> Phlogistique: sure
14:21:06 <byorgey> Phlogistique: I say, just make a package that gives a simple monomorphic interface to an existing package, and upload it to Hackage
14:21:11 <byorgey> THEN ask for feedback =)
14:21:37 <Berengal> The pcre-less library seems to be pretty simple and monomorphic
14:21:56 <Phlogistique> Berengal: yes
14:22:04 <Berengal> I mean, it doesn't have any documentation, but I can still make sense of it easily
14:22:09 <byorgey> Text.Regex.Less.Quackers??
14:22:17 <Phlogistique> I still don't get why it exports (<<) = \a,b -> (a,b) though :p
14:22:37 <Berengal> Phlogistique: That seems to be a mystery. Maybe the author just prefers it to (,) ?
14:23:23 <yitz> personally i just use attoparsec when i want to do the kind of thing such a library would provide
14:24:03 <yitz> i used to love regexes before i came to haskell. now it's part of the pain i feel when i'm forced to use some legacy language.
14:24:10 <Berengal> Me too. I would probably use regexes more if the regex libraries were easier to use
14:24:31 <Phlogistique> Berengal: well, OK, but I still don't see how it's related to regexes
14:24:33 <Berengal> At the same time, haskell has a weird lack of parsers that can parse all CFGs
14:25:06 <Mathnerd314> is there an instance of Applicative for the composition of two instances of Applicative?
14:25:08 <yitz> Berengal: i wouldn't. why encode your parser as a bunch of line noise when you can write the same thing as nice clear combinators?
14:26:03 <Berengal> yitz: Some regexes are clearer than the combinator equivalents. Especially short grammars containing mostly static text
14:26:25 <Phlogistique> yitz: concision
14:26:29 <yitz> Berengal: never seen such a thing. have an example?
14:27:23 <Berengal> yitz: "^Exception,*"
14:27:36 <copumpkin> ^[a-zA-Z]+(([\'\,\.\- ][a-zA-Z ])?[a-zA-Z]*)*\s+&lt;(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})&gt;$|^(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})$
14:27:37 <Berengal> .**
14:27:38 <copumpkin> what could be clearer
14:28:10 <ddarius> You can compose regular expressions from combinators.  It is not necessary to use that syntax.
14:28:21 <Phlogistique> yitz: because you know your grammar is regular?
14:28:38 <yitz> Berengal: "Exception" *> many ","
14:28:39 <W_Blas> I'm trying to implement my own List.nub. Why this doesn't compile: http://codepad.org/wJIvb7DO ?
14:29:00 <ddarius> W_Blas: I bet the compiler tells you why.
14:29:03 <Berengal> yitz: that was meant to be a dot star, not comma star
14:29:08 <Berengal> but whatever...
14:29:22 <rwbarton> could not match inferred type String against expected type Parser a
14:29:27 <sipa> W_Blas: your uniquifyHelper uses the == operator
14:29:39 <sipa> which is not defined very just any type a
14:29:39 <yitz> rwbarton: -XOverloadedStrings
14:29:53 <sipa> s/very/for/
14:30:04 <rwbarton> you are sort of arguing both sides now, but whatever
14:30:05 <Berengal> yitz: but that's not all. The regex would return the entire string, but to do that with combinators you need something like "(++) <$> string "Exception" <*> many anyChar"
14:30:28 <Berengal> Which gets complicated fast
14:31:01 <yitz> Berengal: you get the rest of the string in the Result, no need.
14:31:20 <Berengal> It's not uncommon for me to have combinations starting with something like "(\a b c d e -> concat [a,b,c,d,e]) <$>"
14:31:29 -Enjambre(Enjambre@rolls.fat.blunts.ws)- Check out the results of the first meeting of Tijuana's Haskell Club! Over 50 attendees at our banquet hall from both sides of the border! http://i.imgur.com/tB4hB.jpg
14:32:02 <Philippa> THC, eh?
14:32:13 <yitz> Berengal: true
14:32:29 <yitz> how did Enjambre's nick become purple?
14:32:38 <ddarius> Again, there's nothing stopping someone from developing combinators that behave exactly like regex notation.
14:32:50 <Enjambre> I have special status on the access list
14:32:59 <ddarius> This has been done in Scheme and, if I remember correctly, Haskerl.
14:32:59 <Enjambre> as an official Haskell contributor
14:33:34 <companion_cube> haskerl ? is it a typo or a language on erlang's runtime?
14:33:42 <ddarius> Neither.
14:34:02 <kmc> yitz, by sending a NOTICE instead of a PRIVMSG
14:34:08 * kmc wonders if he should click the link or not
14:34:16 <yitz> kmc: don't
14:34:37 <ddarius> kmc: Even if it is what it claims to be, do you care about a picture of a bunch of random people you don't know?
14:34:52 <ddarius> @where haskerl
14:34:53 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
14:35:02 --- mode: ChanServ set +o copumpkin
14:35:07 <juliohm> What the Haskell community need? Answer: A good benchmark page comparing C++ / Haskell / Other interpreted languages such as Python
14:35:14 --- mode: copumpkin set +b *!Enjambre@rolls.fat.blunts.ws
14:35:15 --- kick: Enjambre was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
14:35:23 --- mode: copumpkin set -o copumpkin
14:35:48 <Nimatek> > let myNub [] = []; myNub (x:xs) = x : myNub (filter (/=x) xs) in myNub "abaaabababacde" -- W_Blas
14:35:49 <lambdabot>   "abcde"
14:35:54 <copumpkin> not sure why my client has such a pretentious default kick message
14:36:09 <ddarius> juliohm: I'm quite sure we don't need that.
14:36:16 <kmc> ddarius, I was wondering if it's an amusing joke or a disgusting one
14:36:38 <ddarius> kmc: I don't know why you would assume it was a joke rather than just a waste of your time.
14:36:41 <kmc> juliohm, "other interpreted languages"?  firstly Haskell is not usually interpreted, second there's no such thing as an "interpreted language", people can and do use compilers for Python, Ruby, etc
14:36:43 <yitz> Berengal: thing is, it's usually not concat. you have some function in a where clause that takes the pieces and puts them together into something. which is fine - and regexes won't change that.
14:36:43 <copumpkin> kmc: it's just a some gay sexual activity
14:37:06 <kmc> juliohm, thirdly http://shootout.alioth.debian.org/
14:37:13 <kmc> already wastes a lot of Haskell community's time ;)
14:37:17 <gavri> beginner here. I have "(\i -> (W.view i . W.shift i))" in my xmonad configuration file. can that be made more succinct?
14:37:32 <juliohm> kmc, i know Haskell can be compiled, i know Python can be compiled, you understood what i mean. ;-)
14:37:34 <Berengal> yitz: Yes, most of the time, but most of the time a regex wouldn't be appropriate anyway. If we're restricting our use-case to where a regex /would/ be appropriate, it would mostly be concat
14:37:40 <kmc> juliohm, not really
14:37:41 <shachaf> @pl (\i -> (W.view i . W.shift i))
14:37:41 <lambdabot> liftM2 (.) W.view W.shift
14:37:48 <shachaf> gavri: However, are you sure you care?
14:38:03 <kmc> juliohm, why would you say "interpreted language" if it's a wrong term which relies on the other person already "knowing what you mean"
14:38:19 <yitz> gavri: remove the inner parens. nothing more than that.
14:38:22 <Berengal> gavri: W.view `ap` W.shift, I think
14:38:36 <gavri> doesn't look very DRY. and it definitely helps for a pedagogical purpose
14:38:49 <kmc> what we really need are benchmarks regarding the maintainability, readability, ease of development, security, and general quality of code in various languages
14:38:51 <juliohm> ddarius, i think we really need to promote Haskell, people don't use it because there is no experienced benchmarkers comparing the performance of the language. People will don't learn another language with so different concepts if it's slow.
14:38:58 <mkscrg> type class issue that's been bugging me: what's the best way to associate a specific expression with an instance? i.e. i have a class A and i want to associate each instance with a String value
14:39:01 <rwbarton> what's repeated is "i"
14:39:02 <Philippa> juliohm: even in the usual sense, Haskell isn't a language that's hard to implement a compiler for or which is overwhelmingly used in interpreter form
14:39:04 <rwbarton> I think that's ok
14:39:11 <kmc> but of course those are much harder to gather
14:39:15 <copumpkin> juliohm: you're ignoring a very important consideration
14:39:26 <Philippa> avoid success at all costs!
14:39:26 <c_wraith> juliohm: people use ruby and python.  clearly, performance isn't the only thing they care about
14:39:29 <copumpkin> Philippa got it
14:39:41 <ddarius> juliohm: Again, I think you are wrong on all counts.  I disagree with every single clause of your paragraph.
14:39:43 <gavri> shachaf, yitz and Berengal, thanks
14:39:49 <yitz> @type \f g i -> f i . g i
14:39:50 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> a -> b) -> (t -> f a) -> t -> f b
14:39:53 <Philippa> c_wraith: yeah, though at least that in and of itself is only going to cost you a constant hit generally
14:40:00 <kmc> juliohm, I'm not interested in marketing Haskell to people who value performance above all.  those people can keep using C and wanking off to how hardcore they are
14:40:03 <yitz> @type \f g i -> f `ap` g
14:40:04 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> t -> m b
14:40:08 <yitz> @type \f g -> f `ap` g
14:40:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:40:10 <Philippa> (or a small non-constant in the case of class dictionaries)
14:40:12 <juliohm> c_wraith, exactly, if Haskell has the plus of good performance, people will migrate from Python to it. ;-)
14:40:37 <kmc> juliohm, anyway, does the Language Shootout I linked not already fulfill your idea?
14:40:42 <Philippa> kmc: some people *have* to just because it's part of their problem domain - but yeah, Haskell's not currently suitable for that kind of thing whether they're wanking or not
14:40:48 <juliohm> kmc, i'm reading it right now. :-)
14:41:19 <kmc> Philippa, I draw a distinction between the people who need performance (and can justify the balance with other business concerns)
14:41:36 <kmc> versus the people who are micro-optimizing their C code to show off
14:41:58 <kmc> often the latter people aren't even achieving real performance, they have a 1960's model of computers which ignores memory bandwidth etc
14:42:01 <c_wraith> how well does atom-generated code perform in embedded environments, anyway?  I know it was designed for that, but I don't know if it's been used successfully.
14:42:08 <Mathnerd314> does one really need the power of a monad, or are there "applicative comprehensions"?
14:42:10 <Berengal> I micro-optimize my C code to show off. It's just as fun to micro-optimize Haskell or Python. Language doesn't matter
14:42:16 <steakknife> uno has a famous quip about optimization.
14:42:23 * ddarius doesn't think most professional developers micro-optimize their C (or any) code to show off, at least for work.
14:42:25 <kmc> c_wraith, it was developed by a user and they have used it
14:42:42 <yitz> @quote uno
14:42:42 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
14:42:47 <c_wraith> Mathnerd314: "idiom brackets" are essentially applicative comprehensions.  there's no sugar for them in ghc, that I know of
14:42:53 <kmc> to develop control systems for hydraulic-powered garbage trucks
14:43:00 <Phlogistique> in Haskerl's announce mail " One additional non-standard Haskell idea we use heavily
14:43:00 <kmc> there are some presentations about this, you can find
14:43:02 <c_wraith> kmc: cool
14:43:03 <Phlogistique> herein is "monadic I/O" [3]."
14:43:18 <kmc> Mathnerd314, you can't implement (>>=) with Applicative only
14:43:21 <steakknife> yitz: the TAOCP variety of uno.
14:43:29 <kmc> Mathnerd314, that is, you can't perform one action and use the result to decide the next action
14:43:36 <kmc> Applicative can only combine a fixed arrangement of actions
14:43:38 <ddarius> Phlogistique: Yes, it's a bit scary how much of Haskerl exists in modern Haskell.
14:43:41 <juliohm> hehehe, avoid success, this has some valid truth. lol
14:44:24 <Mathnerd314> kmc: you can zip things together... I'm wondering if that's all you need for comprehensions
14:45:17 <steakknife> when asking for funding, ask for advice (and the converse).
14:45:26 <juliohm> Haskell making success ==> Newbie programmers ==> Poor uses of the language ==> Haskell failing success, and we back to the initial state. :-P
14:45:49 <copumpkin> juliohm: all part of the plan :D
14:45:53 * copumpkin rubs hands evilly in glee
14:45:54 <kmc> Mathnerd314, not for list-style comprehensions
14:46:13 <kmc> Mathnerd314, [ z |  y <- x,  z <- y ]
14:46:18 <kmc> that requires (>>=)
14:48:09 <Phlogistique> 22:51:22 < ddarius> Phlogistique: Yes, it's a bit scary how much of Haskerl exists in modern Haskell. <- how did they do IO then?
14:48:43 <ddarius> A stream-based request-response IO.
14:49:39 <Mathnerd314> kmc: ok. I couldn't think of much beyond  [ (x,y) | x <- a, y <- b ] which does not.
14:50:12 <kmc> Mathnerd314, comprehensions have a direct translation to "do"
14:50:19 <kmc> an isomorphism almost
14:51:01 <BMeph> It's at times, surprisingly sad, how non-jokingly "avoid success at all costs" is a valid remark.
14:51:09 <BMeph> Case 1: Records.
14:51:13 <BMeph> Case 2: Num
14:51:26 <BMeph> Case 3: the Prelude.
14:51:51 <DanBurton> Records aren't that bad
14:52:06 <Philippa> they're just not that good, eitehr
14:52:07 <mgsloan> if I had millions of dollars I'd hire half of y'all to fix it :)
14:52:09 <Philippa> *either
14:52:10 <c_wraith> records kind of are that bad
14:52:21 <DanBurton> what's so bad about records?
14:52:23 <Philippa> and the need to pick ad-hoc replacements /is/ that bad
14:52:30 <c_wraith> If you make heavy use of nested records, things get ugly
14:52:46 <Philippa> I think you missed an f out there
14:52:53 <mgsloan> I think the fact that ad-hoc replacements are possible is good, though
14:53:16 <mgsloan> means that we can experiment with systems before settling on one
14:53:19 <Mathnerd314> c_wraith: is there some good reading about idiom brackets? Haskell wiki seems out of date
14:53:28 <Philippa> mgsloan: also means we never settle on one or even some syntax
14:53:29 <c_wraith> Mathnerd314: not that I'm aware of
14:53:33 <Berengal> I think some language support for lenses would go a long way...
14:53:43 <mgsloan> Philippa - well, not in any reasonable amount of time
14:53:50 <Philippa> Mathnerd314: they're just a way to write f <$> a <*> b <*> c with a linear decrease in token count
14:54:33 <BMeph> DanBurton, Philippa: My point with records: they are barely serviceable now, and everyone agrees that they could, and should, be better.
14:54:34 <steakknife> what are some LALR / LL parser generator packages that might be able to return an AST?
14:54:37 <Philippa> Mathnerd314: [[f a b c]]
14:55:12 <Philippa> BMeph: yeah, definitely. Personally I think a good intermediate step'd be sugar we can plug into libraries. ConstraintKinds might make that easier
14:55:15 <Mathnerd314> Philippa: yeah, but the syntax is extensible slightly with constraints and alternatives
14:55:18 <BMeph> We just can't decide on how to make them better, largely, because n oone wants to break so much of what is hobbling along now as it is.
14:55:24 <kmc> http://personal.cis.strath.ac.uk/~conor/pub/she/ implements idiom brackets
14:55:48 <c_wraith> I think there are some quasi-quoters that implement idiom brackets, too
14:56:15 <Philippa> BMeph: yeah. A blatant -XFuckOldRecords flag for transitional use seems a good thing
14:56:20 <steakknife> found some http://www.haskell.org/haskellwiki/Applications_and_libraries/Compiler_tools
14:56:21 <BMeph> Indecision about whether the "improvement" will be swiftly improved upon itself is another impediment to the first improvement, which is in itself, another example of failing to "avoid success".
14:56:29 <Philippa> especially if there's a tolerable way to subsume the old system by eg autogenerating instances
14:56:44 <c_wraith> I wish quasiquoters didn't slow down compilation so much
14:56:48 * ddarius thinks that a more "rationalized" Num hierarchy/class would not immediately improve "success."
14:57:11 <c_wraith> 7.4 is actually changing the Num hierarchy, too
14:57:20 <c_wraith> which will probably break a ton of stuff
14:57:24 <steakknife> BMeph: spectacular failure is often a prerequisite for substantive change.
14:57:48 <rwbarton> it is? can I read about this somewhere
14:57:59 <BMeph> I wonder, can someone summarize why GHC can handle same-name value/type constructors, but not same-name record destructors?
14:58:06 <W_Blas> I'm trying to use list elemIndex, but getting an error  Not in scope: `List.elemIndex'. What's wrong?
14:58:12 <c_wraith> rwbarton: all it's doing is removing the Eq and Show superclasses on Num
14:58:15 <rwbarton> ah
14:58:38 <rwbarton> BMeph: do you mean "type constructors with the same name as data constructors"?
14:58:44 <Berengal> BMeph: you mean same name within the same type?
14:59:03 <mgsloan> I think things are fine -  these particular issues are relatively surface level and can be simulated with preprocessors
14:59:13 <steakknife> i wonder if there's an evolutionary advantage to making random api changes.
14:59:34 <Berengal> BMeph: "data Foo = A { foo :: String} | B { foo :: String}" works
14:59:43 <BMeph> ddarius: Regardless of whether a new Num would bring more success, it's pretty much a given that the reason a new Num hasn't been adopted is due to Haskell's current success.
14:59:57 <kmc> once again we're talking about record systems and once again nobody has mentioned Trex
15:00:02 <mgsloan> building a set of excellent, well documented libraries is the main problem, and that does start at the prelude
15:00:14 <W_Blas> Ah I had just import Data.List
15:00:29 <ddarius> BMeph: That's not a given at all.  People have wanted a better Num for much, much longer than Haskell's current success.
15:00:58 <c_wraith> the current Num situation really isn't all that bad, anyway.  It mostly works.
15:01:08 <c_wraith> which is way better than the current record situation
15:01:25 <kmc> current records mostly work
15:01:53 <ddarius> Current Haskell mostly works.
15:02:15 <Berengal> kmc: current records mostly works because they're not used for things they don't work for
15:02:38 <Berengal> Which kinda makes sense
15:02:58 <Mathnerd314> is there a function in the standard library of type a -> Bool -> Maybe a ?
15:02:58 <ddarius> (In fact, the way Num is probably is a failure to "avoid success at all costs.")
15:03:11 <steakknife> maybe there are cooler people in here . . .
15:03:13 <ddarius> @goole a -> Bool -> Maybe a
15:03:14 <lambdabot> http://www.amazon.com/Maybe-Days-Book-Children-Foster/dp/1557988021
15:03:22 <steakknife> is there any way to order food from the command line?
15:03:25 <ddarius> @hoogle a -> Bool -> Maybe a
15:03:25 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
15:03:25 <lambdabot> Control.Exception assert :: Bool -> a -> a
15:03:26 <lambdabot> Control.OldException assert :: Bool -> a -> a
15:03:35 <Mathnerd314> right, I tried that first
15:03:36 <ddarius> steakknife: Yes.
15:03:46 <nazgjunk> steakknife: most stuff like that involves scripts that scrape an ordering website
15:03:51 <nazgjunk> it exists but easily breaks
15:03:54 <Berengal> steakknife: You could probably do it with wget
15:04:02 <Berengal> or curl
15:04:13 <steakknife> arg, hoping for some lunch arbitrage api
15:04:31 <Mathnerd314> steakknife: build it and make huge amounts of $$$!
15:04:36 <steakknife> automatically order food based on history and preferences.
15:04:46 <steakknife> it's too easy.
15:04:54 <ddarius> You are going to exploit mispricings in the lunch food market to resell lunches at a profit?
15:04:57 * steakknife already has a startup
15:05:12 <Berengal> Man, now I'm wondering what it would be like to make a fully-fledged desktop app just for ordering from the local pizza place...
15:05:20 <steakknife> i support the right for laziness from the command line.
15:05:24 <BMeph> ddarius: My point is not that they don't work, or that they were only recently objected to, but that active efforts to change things now are thwarted because of Haskell's success now.
15:05:29 <Berengal> I mean, it would be way overkill, but that would make it sorta cool
15:05:33 <dylex> Mathnerd314: no, there isn't, but you can often use something like guard b >> Just x
15:06:03 <rwbarton> BMeph: I think ddarius is suggesting that you need very little success to create enough inertia to not fix things.
15:06:05 <kmc> http://www.coryarcangel.com/things-i-made/pizzaparty/ steakknife
15:06:22 <steakknife> ddarius: actually arbitrage from the demand side. ;)
15:06:28 <BMeph> ddarius: I have no idea why any efforts to change things earlier (if there were any, and not just "I don't like it"-style objections) were thwarted due to other considerations.
15:06:31 <ddarius> BMeph: My point is that that explanation fails in this case.  It might be an additional concern, but it does not explain why it wasn't done before and suggests that even if we removed that concern it still would not change.
15:07:09 <steakknife> kmc: nice.
15:07:19 <BMeph> ddarius: Then do you know why, Num, for instance, was not changed earlier?
15:07:23 * steakknife thinks: cabal install feedme
15:07:33 <ddarius> BMeph: All the "new numeric preludes" predate the current popularity by quite a bit.  It's nowadays that people just bitch but do nothing.
15:07:36 <steakknife> feedme now whatever
15:07:55 <rwbarton> kmc: nice, I can put it in a cron job
15:08:04 <steakknife> :D
15:08:13 <steakknife> ifttt is also pretty neat
15:09:27 <steakknife> okay, fsck it . . . i don't know enough haskell, but i'll make a git repo.
15:09:38 <ddarius> BMeph: I'm sure one factor is that it was not considered a great idea to require knowledge of abelian groups and rings to understand how to do basic arithmetic.
15:10:15 <Philippa> mmm. Any replacement prelude needs to include a stand-in for the current Num class
15:12:31 * BMeph wonders if basic arithmetic *needs* to be an abelian group, or simply *is* one...
15:13:12 <ddarius> BMeph: The whole point is that you'd end up with types like (AdditiveGroup a, Ring b) => ..., and to make a new numeric type you'd need to instantiate these classes.
15:14:05 <kmc> it might be more convenient with GHC 7.4's very fancy type classes
15:14:08 <mgsloan> Maybe Num needs to be a constraint synonym? and make it so that you can implement constraint synonyms in a single instance?
15:14:09 <ddarius> (NormedSpace a) =>
15:14:15 <BMeph> ddarius: What if your numeric type isn't in one of your classes? Does that mean you are in the same boat as you are now? :)
15:14:17 <ddarius> kmc: Yes, there is a technology aspect.
15:14:58 <ddarius> BMeph: I don't understand your question.
15:16:30 <Mathnerd314> > catMaybes $ getZipList ((\char n -> guard (even n) >> Just (char * n)) <$> ZipList [2..4] <*> ZipList [1..3])
15:16:31 <lambdabot>   [6]
15:16:33 <ddarius> There's also the issue that most of the algebraic structures that a "rationalized" numeric hierarchy would likely hold require several laws that are unenforceable.
15:16:48 <ddarius> Admittedly, so do several standard classes including, arguably, Num.
15:16:51 <BMeph> darius: I'm thinking of how certain "numbers" don't have commutative multiplication. I guess that's where the group/ring part kicks in?
15:16:53 <Mathnerd314> ^ ugliest line ever
15:16:59 <ddarius> And then, of course, there are floats.
15:17:22 <ion> char * n <$ guard (even n)
15:17:49 <dolio> ddarius: We just need to add neelk's support for equations, then.
15:18:57 <yitz> the numeric classes aren't really about abstract algebra. they're about overloading syntax. we just just have a few simple classes to allow that separately for each operator and be done with it.
15:19:07 <BMeph> "Classes need work. :)
15:19:11 <yitz> s/just just/should just/
15:19:40 <BMeph> "Classes need work." :)
15:19:48 <yitz> BMeph: class Addable a where (+) :: a -> a -> a
15:20:00 <ddarius> BMeph: Yes, that's another issue.  There's a lot of overloading and a lot of overlap.  So I'd like to use (+) for additive group, but also for commutative monoid, and I'd like all additive groups to be groups, and I'd like to use (*) for group multiplication, but then also for scalar multiplication.  I could probably generalize the latter two, but that creates something not nearly as simple as a group.
15:20:19 <ddarius> So there's also the perennial problem of finding the "best" new hierarchy.
15:20:25 <rwbarton> then you lose the ability to express the assumptions that your functions make about the type
15:20:46 <Berengal> yitz: class Addable a b c where (+) :: a -> b -> c
15:20:47 <BMeph> "The good is oft the enemy of the best."
15:20:57 <Mathnerd314> ion: thanks, that actually makes it look OK.
15:21:14 <ddarius> BMeph: You do understand that that is one of the ideas behind "avoid success at all costs."
15:21:33 <yitz> Berengal: you could make that argument about (*) perhaps.
15:21:39 <BMeph> ddarius: Not to mention, "Worse is Better." ;þ
15:21:43 <Mathnerd314> ion: still not as good as a list comprehension though
15:22:15 <BMeph> ion: 'guard' is a Monad function. ;)
15:22:21 <ddarius> BMeph: The Num class is an example of not trying to "avoid success at all costs."  And this is what you got.  Also we stole the hierarchy from Lisp.
15:22:28 <yitz> Berengal: but even for (*) i think it's a reasonable compromise to force the use of a different operator for things like vector spaces and module.
15:22:29 <ion> bmeph: Yes. So?
15:22:56 <Mathnerd314> BMeph: the code is using Maybe as a monad anyways
15:22:58 <Berengal> yitz: I was being facetious
15:22:59 <BMeph> ion: NM, dif't convo. :)\
15:23:08 <yitz> Berengal: i know :)
15:23:22 <ion> (It’s actually a MonadPlus function.)
15:33:20 <mkscrg> advice on associating data values with a class instance?
15:33:45 <shachaf> mkscrg: What do you mean?
15:33:48 <mkscrg> i.e. i want instances of class A to define some String value
15:34:07 <ddarius> @src Ix
15:34:07 <lambdabot> class (Ord a) => Ix a where
15:34:07 <lambdabot>     range           :: (a,a) -> [a]
15:34:07 <lambdabot>     index           :: (a,a) -> a -> Int
15:34:07 <lambdabot>     inRange         :: (a,a) -> a -> Bool
15:34:07 <lambdabot>     rangeSize       :: (a,a) -> Int
15:34:17 <ddarius> Not what I wanted.
15:34:18 <mauke> mkscrg: why?
15:34:29 <ddarius> @src Storable
15:34:29 <lambdabot> Source not found. You type like i drive.
15:34:34 <ddarius> Curse you.
15:34:51 <rwbarton> add a class method of type Proxy a String or a -> String (ignoring the argument)
15:35:01 <mkscrg> the class represents datatypes that can be parsed from a standard data format
15:35:06 <Berengal> mkscrg: you could make a function "f :: a -> String; f _ = "foo""
15:35:18 <Berengal> mkscrg: Or you could return a newtype with a phantom type
15:35:23 <mkscrg> i'd like the class instance to define the name of the file from which each type is parsed
15:35:45 <mkscrg> Berengal: the former doesn't work because there are no values of type a when the String is needed
15:35:49 <ddarius> mkscrg: Type classes are not OO classes.
15:35:52 <Berengal> e.g newtype MyData a = MyData String, then have "class MyClass a where foo :: MyData a; foo = MyData "foo""
15:36:04 <Berengal> mkscrg: Use undefined
15:36:19 <mauke> filenames in classes? what
15:36:32 <ddarius> mkscrg: Doing this would mean you want a canonical file name per type decided once and for all.
15:36:38 <Berengal> Can you do the newtype thing with just type aliases?
15:36:47 <rwbarton> no
15:36:56 <Berengal> What about type families?
15:37:00 <mkscrg> ddarius: right. that's exactly what i want
15:37:19 <rwbarton> Maybe if they are data/newtype families, as opposed to type families
15:37:30 <mkscrg> i've tried this with type families but i always get stuck with non-deducible errors
15:37:35 <Berengal> data/newtype wouldn't work that well I think
15:37:38 <ddarius> mkscrg: That seems extremely strange, but the ways Berengal mentioned have both been used in practice.
15:39:02 <mkscrg> ddarius: consider a data package that you want to parse, which includes a number of csv files. the rows of each csv file parse to a specific datatype. hence the desire to associate the name of the file with the class instance
15:39:26 <mkscrg> (where the class represents different datatypes that are parsed from this data package)
15:39:33 <mauke> wat
15:40:12 <ddarius> mkscrg: Now I want to parse another csv file with one of those formats, what do I do?
15:41:07 <mauke> that's easy, you just define a new type, with a new instance, with a new filename, then recompile yourself
15:41:37 <Berengal> ddarius: It's not that strange. It's used often in the FFI, where types have associated size and alignment
15:41:58 <ddarius> Berengal: I know.  I said as much.  You misread what I said.
15:42:02 <Berengal> Ah
15:42:06 <yitz> mkscrg: have a look at the tagged package
15:42:12 <yitz> @hackage tagged
15:42:12 <lambdabot> http://hackage.haskell.org/package/tagged
15:42:23 <ddarius> Berengal: Note that I'm the one that wrote @src Storable originally.
15:42:46 <mkscrg> ddarius: you don't. the filenames are defined as part of the data package's specification. the class we're talking about, and all the parsing code, is hidden behind the library's api. the exposed function just taks the .zip file containing all this crap
15:42:53 <Berengal> ddarius: Hah, I'd forgotten that. Ignore me then
15:43:24 <mkscrg> ddarius: but you make a good point. writing the filenames into the classes makes the code a lot less reusable
15:43:25 <ddarius> mkscrg: So?  I might want to, you know, test each parser individually.  I might be interested in these formats independent of the "data package."
15:43:28 <yitz> mkscrg: add a method like name :: Tagged a String
15:43:55 <ddarius> mkscrg: Also, is the Microsofts Open XML package stuff for docx and co.
15:43:57 <ddarius> ?
15:43:58 <rwbarton> it sounds like these names will only occur in one place in the program anyways...
15:44:30 <mkscrg> ddarius: yeah, i can see that happening. also what?
15:44:31 <rwbarton> so it feels more natural to me to put them in whatever top-level function actually reads the files
15:45:07 <ddarius> Ah yeah, the docx stuff doesn't contain csv's to my knowledge.  All xml.
15:45:42 <ddarius> mkscrg: The new Microsoft Office formats, such as docx, are zip files that contain various XML files arranged in a certain way.
15:45:49 <rwbarton> The OpenOffice file format is also a zip file containing a bunch of xml files
15:46:15 <ddarius> rwbarton: Yes, there was a competition to set the new standard.  Microsoft lost.
15:46:55 <mkscrg> ddarius: ah, interesting. i'm working on parsing the GTFS format (general transit feed spec, used by agencies like the MTA to publish data like the NYC subway routes/schedules/etc.)
15:46:55 <rwbarton> Oh, is docx actually the same format?
15:47:38 <ddarius> rwbarton: docx is (one case of) http://www.ecma-international.org/publications/standards/Ecma-376.htm
15:47:43 <yitz> ddarius: ms lost? how many docx vs. odt documents are there in the world?
15:48:06 <ddarius> yitz: The standard is basically OpenOffice's format not Microsoft's proposals.
15:48:44 <yitz> ddarius: it depends what you mean by "standard"
15:49:09 <ddarius> I mean ECMA 376.
15:49:34 <ddarius> Or the analogous ISO standard.
15:50:31 <yitz> ddarius: oh a particular formalized standard by a particular standards body. ok.
15:56:56 <dgpratt> ddarius: are you sure? the only reference I find to OpenOffice on the Wikipedia page for the "Office Open XML" format is: Not to be confused with OpenOffice.org XML
15:57:22 <dgpratt> this page, btw: http://en.wikipedia.org/wiki/Office_Open_XML
15:57:28 <yitz> ddarius: haven't read the standards, but many web sites (including MS sites) claim that those standards are docx etc.
15:57:56 <BMeph> dgpratt: He's ddarius. He's sure. And if he weren't sure, he'd still likely be correct. ;)
15:58:37 <dgpratt> BMeph: *citation needed* :)
15:59:01 <BMeph> yitz: They may want to imply that it means "docx SETS the standard," but it technically just means that "docx MEETS the standard".
15:59:31 <yitz> ddarius, BMeph: http://blogs.msdn.com/b/chrisrae/archive/2010/10/06/where-is-the-documentation-for-office-s-docx-xlsx-pptx-formats-part-2-office-2010.aspx
16:00:18 <mythmon> hmm. so I feel kind of silly asking this, but why doesn't my one liner in ghci work when i try to compile it with ghc?
16:00:26 <scooty-puff> is it possible to have a type instance defined only when a type var is not some type?
16:01:15 <kmc> mythmon, because ghci takes expressions and ghc takes whole programs
16:01:31 <kmc> mythmon, but we can give better advice if you tell us what the one-liner is and what "doesn't work" means
16:01:41 <BMeph> dgpratt: See the "ddarius" clause
16:02:05 <dylex> scooty-puff: no... why?
16:02:06 <MostAwesomeDude> mythmon: Oh hi. :3
16:02:13 <BMeph> yitz: I read "Office 2007 uses the file format specified in the first edition of the international standard ECMA-376 as its default file format" to suggest my prior statement.
16:02:31 <mythmon> kmc: "sum [1..100]" is the one liner (actually "main = sum $ [1..100]"), and "doesn't work" means it gives me an error along the lines of "No instance for (Num (IO t0))"
16:02:32 <scooty-puff> dylex, i am writing a simple compiler, and would like phases to be able to annotated nodes
16:02:54 <scooty-puff> the annotation was to look like With a b, and have type classes HasName where name :: a -> Name, etc.
16:02:57 <mythmon> MostAwesomeDude: you're :3 smiley looks funny in my font, since the 3 is assymetric :P
16:03:09 <kmc> mythmon, 'main' needs to be an IO action
16:03:16 <kmc> main = print (sum [1..100])
16:03:16 <scooty-puff> the idea was With Name b would just give the direct name, while HasName b => With a b would search b
16:03:28 <scooty-puff> *annotated-> annotate
16:03:32 <mythmon> kmc: ah. that would make sense, from the rest of the error.
16:03:51 <kmc> mythmon, *nod*  ghc is being overclever and trying to come up with a way that a number could be an IO action
16:04:17 <dgpratt> BMeph: it's certainly not unheard of that Wikipedia could be wrong, but presently I cannot reconcile ddarius' statement with what I find on Wikipedia
16:04:25 <shachaf> runghc with "main = return (sum [1..100])" will actually work, though, due to a bug.
16:04:49 <BMeph> mythmon: Since GHCi is an interpreter (FSVO), the most direct (guess) for your compiled program should/would be: "main = print $ sum $ [1..100]". I'd drop the second "$", but since it was there originally, I wanted to give a direct "translation". :)
16:04:55 <kmc> shachaf, haha, I didn't know that
16:05:00 <mythmon> kmc: thanks for the pointer. Now off to go butcher the language with project euler problems.
16:05:15 <shachaf> kmc: My guess is that it evaluates main using whatever mechanism ghci uses to evaluate expressions.
16:05:22 <scooty-puff> dylex, the current workaround is to define it for all other annotations manually
16:05:23 <kmc> shachaf, this is because it basically does ghc foo.hs -e main
16:05:26 <kmc> yeah
16:05:28 <mythmon> BMeph: the $ was only there becuase my brief google led me to believe it would help.
16:05:35 <shachaf> I.e., if it's of type IO a where a is Show and not (), then it'll print the result.
16:05:56 <kmc> iirc runghc is a small Haskell program which ships with GHC
16:05:59 <kmc> which invokes ghc -e
16:06:03 <kmc> mythmon, ($) is an infix operator
16:06:05 <kmc> @src ($)
16:06:05 <lambdabot> f $ x = f x
16:06:12 <kmc> it can be used to avoid parentheses
16:06:20 <kmc> f (g (h x))  ≡  f $ g $ h x
16:06:22 <scooty-puff> @src (.)
16:06:22 <lambdabot> (f . g) x = f (g x)
16:06:22 <lambdabot> NB: In lambdabot,  (.) = fmap
16:06:27 <kmc> though we'd prefer   f . g $ h x
16:06:35 <shachaf> f . g . h $ x ?
16:06:35 <kmc> or f . g . h $ x
16:06:54 <kmc> because (f . g) and (f . g . h) are well-typed expressions on their own, whereas (f $ g) and (f $ g $ h) wouldn't be
16:07:10 <dylex> scooty-puff: well, with OverlappingInstances (and maybe IncoherentInstances) you can define instances for both With Name a and HasName b => With a b, and because the first one is more specific it will get chosen when appropriate, but...
16:07:41 <rwbarton> (the ... stands for "Don't use OverlappingInstances")
16:07:42 <kmc> mythmon, but it's a real infix operator, not special syntax.  so you can use it in other contexts
16:07:47 <kmc> > map ($ 3) [pred, succ]
16:07:47 <lambdabot>   [2,4]
16:08:34 <dylex> scooty-puff: right. since you're defining HasName instances yourself, doing it explicitly (or something else entirely) is probably cleaner.
16:08:50 <hpaste> scooty-puff pasted “Type Class when !~ SomeType” at http://hpaste.org/53609
16:08:52 <mythmon> kmc: right. I read about that in the tutorial I am using. I haven't quite figured out how useful it is though.
16:09:09 <scooty-puff> dylk
16:09:12 <scooty-puff> meh..
16:09:14 <scooty-puff> dylex, k
16:09:24 <zzo38> How can you access the printing driver by Haskell?
16:10:46 <rwbarton> openFile "PRN"
16:10:57 <rwbarton> seriously though it will depend on your OS of course
16:11:23 <zzo38> rwbarton: Yes I know that is what I ask. openFile "PRN" would be a DOS device code.
16:11:36 <rwbarton> point is it is not a haskell question
16:11:57 <scooty-puff> can template haskell be used to add imports?
16:12:10 <byorgey> scooty-puff: no
16:12:15 <zzo38> scooty-puff: No, I think not. Template Haskell is not as powerful as a real macro system
16:12:21 <scooty-puff> k
16:12:26 <zzo38> However, it does do some things macros doesn't, too.
16:12:33 <Nafai> scooty-puff: I've wanted to do that too :(
16:13:45 <zzo38> I made up part of a module Graphics.DVI so I want to make up some submodules for dealing directly to printer driver of the system, such as Graphics.DVI.Printout to send to the printer
16:13:50 <MostAwesomeDude> Okay, I want to have something *gasp* stateful.
16:13:51 <scooty-puff> i seem to be particularly prone to running into boundaries
16:14:04 <scooty-puff> StateT, ST, IO
16:14:06 <MostAwesomeDude> Precisely, I want to handle network connections, and there's a little bit of state I have to track for each connection.
16:14:16 <zzo38> So that you can make Haskell program for printing files
16:14:31 <BMeph> dgpratt: Hmm, looks like you (and Wikipedia) are right. Nice catch.
16:15:12 <MostAwesomeDude> scooty-puff: Any more detail on that?
16:15:52 <kmc> stateful is fine
16:16:07 <scooty-puff> well, don't have much context (hadn't been following the conversation much), but what might be best is a newtype around StateT IO
16:16:14 <kmc> can we drop the "haskell is for fundamentalists" thing and maybe describe it as a practical, multiparadigm language?
16:16:15 <scooty-puff> depending on if you need IO or not
16:16:20 <dgpratt> BMeph: it had to happen sometime :)
16:16:47 <scooty-puff> if you want real world side effects, maybe define them as narrowly as you can, and make a newtype around just IO
16:17:08 <scooty-puff> a (probably not related) example i have on-hand:
16:17:30 <scooty-puff> ok, actually, its really not related
16:17:53 <hpaste> scooty-puff pasted “ErrorIO wrapper” at http://hpaste.org/53610
16:18:08 <kmc> it really depends on the scope of the system you are building
16:18:24 <kmc> if it's something small, I would use IO for everything as much as possible
16:18:36 <MostAwesomeDude> I need to coordinate a bunch of connections.
16:18:53 <zzo38> It isn't a computer. It is a mathematics.
16:18:55 <MostAwesomeDude> I need each connection to remember a couple things about what it's done, and I need each connection to be able to ask all other connections to do something.
16:19:34 <kmc> in many cases the effort of building a custom restricted monad or a fancy transformer stack just isn't worth it
16:19:40 <kmc> there's a lot of boilerplate etc
16:19:53 <kmc> and the engineering benefits scale with the project size
16:20:00 <MostAwesomeDude> Well, here, let's try something simpler.
16:20:08 <kmc> but if you start with just IO, you will have to recognize when it's grown too big
16:20:16 <kmc> MostAwesomeDude, how many lines of code do you expect to write for this project
16:20:16 <MostAwesomeDude> I want to build an echo server. This server will echo anything sent to it to *all* currently connected clients.
16:20:21 <MostAwesomeDude> How would I approach this?
16:21:00 <MostAwesomeDude> kmc: 28k lines of Python. What's that in Haskell? >:3
16:21:04 <kmc> that's a lot
16:21:22 <MostAwesomeDude> Well, I don't do small things. :3
16:21:37 <kmc> at that scale, putting some engineering around IO probably does make sense
16:21:55 <MostAwesomeDude> Well, I already have a IO thingy which isolates all of the IO code.
16:22:14 <MostAwesomeDude> So I'm in pure land. The part of the code that does the actual echo (and presumably the bookkeeping) isn't in IO.
16:22:15 <yitz> MostAwesomeDude: 28k lines just to echo?
16:22:23 <kmc> wrapped IO isn't IO?
16:22:37 <kmc> for a simple echo server, I would store a list of outgoing Handles in an MVar
16:22:41 <MostAwesomeDude> yitz: No, but this thing that I'm *actually* building is big. I explicitly said that I'll do something simpler first.
16:22:53 <kmc> fork a thread to listen to each client, pass the MVar to that thread
16:22:54 <yitz> oh ok :)
16:23:04 <MostAwesomeDude> MVar?
16:23:07 * MostAwesomeDude goes to Google
16:23:15 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/Control-Concurrent-MVar.html
16:23:16 <yitz> @google MVar
16:23:18 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
16:23:18 <lambdabot> Title: Control.Concurrent.MVar
16:23:23 <kmc> this is the basic mutable variable for concurrent haskell
16:23:36 <kmc> there's also IORef, which is useful in single-threaded and some limited multi-threaded cases
16:23:38 <yitz> @hoogle MVar
16:23:38 <lambdabot> Control.Concurrent.MVar module Control.Concurrent.MVar
16:23:38 <lambdabot> Control.Concurrent.MVar data MVar a
16:23:39 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
16:23:47 <kmc> and then there's STM, which is a very nice way of building atomic memory transactions
16:23:54 <kmc> MostAwesomeDude, I think the last few chapters of RWH cover this stuff well
16:24:14 <MostAwesomeDude> Interesting. Thanks.
16:24:32 <kmc> it has chapters on concurrency and network programming
16:24:37 <kmc> and the introduction to STM is good
16:25:10 <kmc> MostAwesomeDude, the basic constructs for state shared between threads are MVar and Chan
16:25:16 <kmc> the latter is a typed message channel
16:25:37 <MostAwesomeDude> Very nifty.
16:25:51 <kmc> it's funny how many people on reddit etc. will tell you "Haskell doesn't have mutable state", when there are like a dozen mutable state types in the standard libraries alone
16:26:10 <kmc> i guess in the past, haskellers were ashamed of these things and tried not to talk about them
16:26:19 <MostAwesomeDude> Well, I don't care about mutable state. I care about convenient ways to build the things I want to build.
16:26:25 <kmc> possibly as an overreaction to the idea that beginners would misuse them
16:26:38 <kmc> i hope that's changing now, with more practical software being written in haskell
16:26:39 <MostAwesomeDude> And, TBH, doing this sort of thing in e.g. Scheme without set! would be painful.
16:26:42 <mythmon> MostAwesomeDude: knowing what you are writing makes this kind of entertaining.
16:26:44 <hpaste> bluelizard37 pasted “svg_tut” at http://hpaste.org/53611
16:27:02 <MostAwesomeDude> mythmon: Doesn't it, though? BTW, I've got a repo "baskerville" up if you wanna see how far I've gotten.
16:27:23 <kmc> the common perception is that Haskell is an extreme language design for fundamentalists
16:27:30 <bluelizard37> I am getting "Parse Error: naked expression at the top level on the last line", please help. http://hpaste.org/53611
16:27:38 <kmc> whereas to me the position seems quite moderate: use state when you need to
16:28:17 <scooty-puff> bluelizard37, it looks like lines 25 and 27 and expressions
16:28:21 <kmc> bluelizard37, well, it's a naked expression
16:28:29 <scooty-puff> if you want them executed, add in a main :: IO ()
16:28:30 <kmc> bluelizard37, maybe you wanted "main = ... that stuff ..."
16:28:54 <kmc> bluelizard37, by the way, the 'diagrams' library provides a much much nicer way to do vector graphics
16:29:03 <kmc> http://projects.haskell.org/diagrams/
16:29:40 <kmc> bluelizard37, if you're committed to outputting raw SVG text, I recommend at least using a library like http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/pretty-1.0.1.2/Text-PrettyPrint-HughesPJ.html
16:29:54 <kmc> your code will be more readable, the svg output will also be more readable
16:29:54 <hpaste> scooty-puff annotated “svg_tut” with “svg_tut (annotation)” at http://hpaste.org/53611#a53613
16:30:02 <scooty-puff> didn't actually attempt to run it..
16:30:09 <bluelizard37> kcm, scooty-puff, thnx I am just going through a tutorial.
16:30:16 <bluelizard37> I will check out your suggestions..
16:33:22 <kmc> bluelizard37, the intermediate option between those two would be to use an XML library
16:33:25 * kwos needs a powerful hex editor for mac... any recommendations?
16:33:41 <kmc> bluelizard37, anyway Diagrams is wonderful; it would be a great way to play with haskell at a beginner stage
16:33:48 <bluelizard37> I put in ..     main :: IO () ; main = writeFile  , but the error is the same.
16:34:19 <yitz> kmc: how does diagrams compare to gloss?
16:35:15 <ptek> Does anyone use cabal test for his/her work? I have a problem with automatically installing dependencies when issuing "cabal install --enable-tests"
16:35:32 <ptek> There is a ticket: http://hackage.haskell.org/trac/hackage/ticket/824 which says its fixed
16:36:21 <ptek> but with the newest cabal 1.10.2.0 I get the same problem as described in the ticket. http://hpaste.org/53615
16:36:37 <dcoutts> ptek: it's fixed in the dev version
16:36:38 <ptek> Just want to make sure, that I'm not doing something really stupid
16:36:39 <kmc> yitz, haven't used gloss, but I guess it's for realtime output by opengl, while Diagrams is aimed at output to png, pdf, svg via Cairo
16:36:46 <kmc> though diagrams supports pluggable backends
16:37:06 <ptek> dcoutts: so its not in the "stable" version yet?
16:37:26 <dcoutts> ptek: well there's not been a release since
16:37:58 <ptek> dcoutts: ah. I see. Thank You! I'll try to install cabal from source then :)
16:39:18 <timp> I am getting warnings Defaulting the following constraint(s) to type `Integer' despite a default(Integer) at the top of my module
16:39:25 <hpaste> scooty-puff annotated “svg_tut” with “svg_tut (annotation) (annotation)” at http://hpaste.org/53611#a53616
16:39:40 <scooty-puff> emacs is too smart - showed it as an image
16:39:55 <scooty-puff> (when i openned the .svg file)
16:40:02 <zzo38> emacs must have some command to tell it not to do that, though.
16:40:17 <scooty-puff> yeah, couldn't find it fast enough, xclip'ed it
16:40:19 <kmc> timp, that sounds correct.  'default(Integer)' says what the allowable default types are
16:40:28 <kmc> timp, but defaulting at all causes a warning
16:40:37 <kmc> because it's this weird hack bolted onto haskell's type system
16:40:46 <scooty-puff> bluelizard37, it if you mean main :: IO (); (with the semicolon), not sure if that is valid
16:40:49 <dcoutts> yitz: you about?
16:41:04 <yitz> dcoutts: yes (though going to sleep soon)
16:41:24 <timp> kmc is there a way to use a bald number without a -Wall warning?
16:41:27 <dcoutts> yitz: just wanted to let you know I'm putting Data.Monoid.<> in, I think you were the only person objecting
16:41:38 <dcoutts> yitz: so just in case you wanted to discuss it
16:41:50 <yitz> dcoutts: i's a pretty clear consensus against me :)
16:41:55 <kmc> timp, use it in a context where the type can be inferred completely
16:41:59 <yitz> it's
16:42:05 <kmc> putting on a type annotation is one way to do this
16:42:19 <dcoutts> yitz: ok, and I think we can do what you were after later, if Data.Semigroup is added to base or whatever
16:42:19 <kmc> often you can put the annotation in some other more natural place
16:42:24 <kmc> like a function which takes that number as an argument
16:43:02 <timp> kmc: thx
16:43:05 <dcoutts> yitz: and it also looks hopeful that we'll have a mechanism to solve the Functor, Applicative, Monad problem in the not too distant future, so the same upgrade path would be available for semigroup
16:43:16 <yitz> dcoutts: it just seems we're creating yet another Functor/Monad situation, when it could so easily be avoided. too bad
16:43:35 <dcoutts> yitz: yes we are, but it looks like default instances will solve that
16:44:07 <dcoutts> and in a nice way that lets people who don't know/care about the superclass to continue not knowing/caring
16:44:08 <yitz> dcoutts: the real answer is for the improvements to classes simon is suggesting be implemented, so that we don't have to worry about these things so much anymore
16:44:15 <dcoutts> aye
16:44:24 <zzo38> I made up some other additions to Monoid called Data.Monoid.Plus
16:44:50 <yitz> dcoutts: not just default instances but yeah the she-like stuff they want to do
16:45:14 * dcoutts isn't aware of the other stuff
16:45:28 <dcoutts> I know about the data types as kinds thing
16:45:43 <dcoutts> but not any 'she' stuff relating to classes
16:45:44 <yitz> dcoutts: something like class aliases
16:45:56 <dcoutts> there's context aliases
16:46:03 <zzo38> It includes operators |*| |/| |+| |-| as well as new classes: MonoidPlus, Group, MonoidMinus, MonoidNorm, MonoidPlusNorm, Semiring, and Ring.
16:46:40 <yitz> zzo38: have you seem edwardk's packages for that kind of stuff?
16:46:52 <ddarius> Or the several other packages which do similar things.
16:46:56 <zzo38> yitz: No. I have not seen it.
16:47:08 * ddarius doesn't know where we would be with zzo38 to fix all our problems.
16:47:11 <scooty-puff> semigroup and semigroupoids i'm guessing?
16:47:16 <yitz> dcoutts: anyway thanks. progress is good.
16:47:41 <zzo38> I also added the   instance Monoid t => Monad ((,) t)   since they forgot that one and since it is easy to understand what join would be for that one.
16:47:48 <dcoutts> yitz: np, g'night
16:47:50 <zzo38> join (x, (y, z)) = (x |*| y, z);
16:48:03 <ddarius> That's not missing.
16:48:16 <ddarius> Or rather it is written a different way.
16:48:25 <ddarius> That's the Writer monad.
16:48:57 <yitz> ddarius: well we have Monad ((->) a) in addition to Reader, too
16:49:00 <zzo38> The operators are |*| for mappend, |+| for mpappend, |/| for mappend and minverse, |-| for mpappend and mpinverse.
16:50:11 * yitz yawns
16:51:00 <zzo38> yitz: I know the Monad ((->) a) is simple because I wrote it on a paper one day, and I realized how to do it:   return = const; fmap = (.); join f x = f x x;
16:51:24 <hpaste> bluelizard37 pasted “svg_tu2” at http://hpaste.org/53617
16:51:40 <zzo38> And <*> corresponds to S combinator with that monad
16:51:42 <ddarius> yitz: I think the issue is that Control.Monad and Control.Monad.Instances doesn't depend on Monoid.
16:51:52 <bluelizard37> kmc, scooty-puff: I am still getting the naked expression at top level : http://hpaste.org/53617
16:52:13 <hpaste> jerry pasted “difference” at http://hpaste.org/53618
16:52:27 <ddarius> At any rate, zzo38 putting it in his package is a horrible idea in theory.  (In practice, it probably makes no difference either way.)
16:52:32 <Jerry> can anyone explain why the first part doesnt have "do"
16:53:16 <ddarius> Because "do" wasn't written there.
16:53:24 <zzo38> The  Monad ((->) a)  is already in Haskell.
16:53:51 <kmc> bluelizard37, no, i meant "main = writeFile "tut0.svg" $ writePolygons (blue [[(100,100),(200,100),(200,200),(100,200)],[(200,200),(300,200),(300,300),(200,300)]])"
16:53:59 <bluelizard37> oh ic.
16:54:00 <kmc> bluelizard37, or "foo = writeFile "tut0.svg" $ writePolygons (blue [[(100,100),(200,100),(200,200),(100,200)],[(200,200),(300,200),(300,300),(200,300)]]);  main = foo"
16:54:02 <kmc> but that's silly
16:54:04 <zzo38> But I added the  instance Monoid t => Monad ((,) t)  and if you can implement the same kind of thing in other package in case you want to put it in the base package
16:54:15 <kmc> bluelizard37, the line starting with "writeFile" is still a bare expression; it doesn't define anything
16:54:32 <DanBurton> Jerry: you don't need to write "do" in order for something to be a monadic value
16:54:37 <kmc> a Haskell file is a sequence of definitions -- types, functions and other values, etc.
16:54:38 <scooty-puff> ok i know they are awful for many reasons, but IncoherentInstances just feels so right..
16:54:50 <Jerry> DanBurton: i am trying to write choices in my parsers
16:54:57 <zmv> tsc, haskellites :P
16:54:59 <bluelizard37> kmc, it works !
16:55:01 <Jerry> so for each choice one do..right?
16:55:15 <ion> foo <|> bar <|> baz
16:55:22 <DanBurton> do is only sugar
16:56:23 <Jerry> DanBurton: can you give me example for 2 choices then
16:56:23 <bluelizard37> kmc, even if I put function signature, it will still give me error.    So   main = do writeFile would not do either.
16:56:28 <zzo38> I also think the documentation for MonadPlus needs to be corrected. It should follow monoid laws and left zero (remove the right zero law; many don't follow that anyways). Alternative can have only monoid laws and no left zero/right zero.
16:56:56 <ddarius> zzo38: If anyone uses your package (specifically any module which transitively uses the module that contains the instance declaration), whether or not they use the instance, it will break if they use any other module that makes such an instance.  And of course it will break if such an instance is added to base.
16:57:13 <dobblego> zzo38: http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
16:57:28 <ddarius> dobblego: zzo38 doesn't believe in research.
16:58:05 <zzo38> ddarius: Well, that does describe one problem with Haskell in general; it has nothing to do with me personally. You should have the option to override instances
16:58:15 <zzo38> dobblego: I did already read it.
16:58:47 <zzo38> The definition someone on here posted for  MonadPlus IO  seem wrong to me, however, due to not the identity law.
16:59:01 <rwbarton> I think I asked this previously, but can you write unsafeCoerce using overlapping/incoherent instances and type families?
16:59:04 <ddarius> zzo38: No, you shouldn't have the option to override instances, and it has something to do with you personally assuming you care if anyone (including yourself) uses your package.
16:59:23 <ptek> dcoutts: it worked. Thanks again!
16:59:24 <ddarius> rwbarton: If you can, then it's a bug.
16:59:32 <dcoutts> ptek: oh good
17:00:05 <dobblego> Scala effectively has the ability to "override instances" and for the API user to explicitly disambiguate instance selection where they are ambiguous -- it results in a mess
17:00:43 <zzo38> ddarius: But, sometimes you will need to load a lot of programs, including version mixed up, and a lot of other stuff, so it should be permitted but turned off by default.
17:01:26 <ddarius> zzo38: That's the wrong way to solve the problem, and that doesn't solve the problem anyway.
17:01:43 <zzo38> So that override instances is off by default but still can be turned on selectively, such as by using special forms of the "qualified" and "hiding" commands, and having instances in your own module be overriding those that are imported.
17:02:13 <rwbarton> this idea makes no sense.
17:03:39 <JoeyA> I want to learn what dependent typing is all about.  For someone familiar with Haskell, what would be a good dependently-typed language to jump into?
17:03:49 <dobblego> what mechanism is proposed to solve the Functor/Monad Semigroup/Monoid problem?
17:03:53 <rwbarton> JoeyA: agda
17:03:57 <dobblego> JoeyA: agda
17:04:13 <JoeyA> I guessed right!  :-)
17:04:18 <JoeyA> (already cabal installed it)
17:04:25 <zzo38> GHC does have option for IncoherentInstances but it should be done by qualified and local module instead, in most cases.
17:04:33 <JoeyA> thanks
17:04:34 <rwbarton> Its syntax is about 90% the same as Haskell's.
17:08:46 <zzo38> I did read MonadPlus proposal and it is good; there are a few different opinions, I think it should be left zero and monoid laws. But I wrote some proposals too and most people doesn't like it.
17:09:27 <dobblego> where are your proposals
17:09:28 <dobblego> ?
17:09:41 <zzo38> dobblego: In my user page.
17:10:43 <JoeyA> Is my understanding of what dependent typing is true? :  I can prove anything about my code and have the computer check it, but the burden is on me to write a proof that terminates.
17:10:47 <mercury^> Why is agda not used more for actual programming?
17:11:12 <rwbarton> for some values of "anything"
17:11:26 <zzo38> However I have not updated those proposal a lot. I do have some additional ideas by now, such as a type that holds only bijective functions.
17:12:28 <rwbarton> JoeyA: but essentially that's right.  Agda will not go out of its way too much to help you prove the statements you want to prove.
17:13:22 <JoeyA> Whereas Haskell dangles the UndecidableInstances carrot, and could theoretically not terminate?
17:13:25 <bluelizard37> scooty-puff, I just saw your correction of my file.
17:13:26 <bluelizard37> thnx
17:13:40 <JoeyA> (among other undecidable things Haskell does or could do)
17:14:28 <JoeyA> Also, how well does Agda integrate with Haskell?  If I was writing an application in Haskell, and had a tricky function I wanted to write and formally prove the correctness of, could I write the source in Agda and compile it straight to Haskell, or would I need to write the function twice?
17:14:37 <JoeyA> (once in Agda and again in Haskell, keeping the versions in sync)
17:16:30 <erus`> i thought i saw a video where they said agda to haskell compilation has to use some usafeIO or unsafeCoerce  to get around the type system differences
17:16:32 <byorgey> JoeyA: in theory, you can compile Agda to Haskell, though I am not sure how maintained the compiler is
17:16:39 <byorgey> erus`: it does.
17:16:41 <zzo38> However, I did make some proposals which are already implemented and I did not know that; and some proposals which nobody needs to implement because it can still be used anyways (such as the "X-Printout-" commands for cabal package file to indicate preparing printout of literate programs).
17:17:20 <erus`> what does agda target? C?
17:17:35 * shapr bops cheerfully
17:17:58 <ddarius> erus`: Haskell.
17:18:03 <zzo38> But if you use literate programming, you might be interested in the "X-Printout-" commands; it will not cause any damage to use them since the name has "X-" at front.
17:19:22 <mauke> hmm. this channel is much better since I ignored zzo38
17:19:38 <erus`> mauke: are you still ignoring erus` ?
17:19:51 <mauke> did I ever?
17:20:19 <ddarius> mauke: Sounds like you should.
17:20:51 <mauke> but I generally don't ignore people :-(
17:20:51 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
17:21:21 <ddarius> mauke: If the person themselves thinks you should, what could be more damning?
17:21:39 <erus`> someone was ignoring me. I forget who
17:22:16 <zzo38> I don't use the ignore more. I can read everyone's opinion, question, comment, complain, point of view, etc.
17:22:17 <lambdabot> zzo38: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:17 <preflex>  zzo38: you have 1 new message. '/msg preflex messages' to read it.
17:22:32 <zzo38> s/more/mode/
17:23:43 <zzo38> ?messages 0
17:23:43 <lambdabot> mauke said 2m 9s ago: yes.
17:35:59 * ddarius realizes that he may want to time-stamp his input events at the time they occur.
17:38:33 <scooty-puff> for an IntSet or IntMap, better, when producing them, to fold with IntSet.insert and IntSet.singleon, or produce a list and IntSet.fromList
17:39:07 <scooty-puff> er, make that IntSet.union and IntSet.singleton
17:39:24 <ddarius> What are you folding over?
17:39:37 <scooty-puff> a generic data structure (Data a)
17:40:11 <scooty-puff> which i believe is converted to a list
17:40:17 <scooty-puff> so foldl over a list
17:40:36 <ddarius> What function are you calling to do the fold?
17:41:24 <JoeyA> "* ddarius realizes that he may want to time-stamp his input events at the time they occur."  Indeed.  I learned recently that that's a good way to prevent a mysterious problem from ever appearing again :-)
17:41:32 <JoeyA> (better logging in general, that is)
17:42:51 <scooty-puff> ddarius, "everything"
17:43:01 <scooty-puff> so either:
17:43:08 <scooty-puff> IntSet.fromList . everything (++)
17:43:17 <scooty-puff> or:
17:43:29 <scooty-puff> everything (IntSet.union)
17:43:46 <scooty-puff> in the first just produce [Int], the latter IntSet
17:43:56 <scooty-puff> as argument to the above
17:44:53 <ddarius> scooty-puff: Do the latter.
17:44:58 <scooty-puff> k
17:45:59 <scooty-puff> i'm pretty horrible about reasoning about complexity - whenever i know something will be applied on i for 1 .. n, i just kind of assume log n
17:46:11 <scooty-puff> is it because of the strictness of IntSet?
17:47:18 <ddarius> No.
17:56:05 <scooty-puff> ddarius, does IntSet do a decent job of sharing after updates?  otherwise, i am not sure why
18:07:49 * shapr sighs
18:08:40 <dobblego> shapr!!
18:08:45 <dobblego> wossup mate?
18:08:46 <blackdog> shapr: don't sigh. bounce!
18:10:14 <ddarius> scooty-puff: Actually, since IntSet.union is stated to be O(n+m) in the worst case and IntSet.fromList is O(n) and (++) is O(n), then essentially everything union will always be O(n^2) whereas fromList . everything (++) may not be O(n^2) in some cases (e.g. right leaning trees.)  Both will be O(n^2) for typical roughly balanced trees.
18:10:19 <poindontcare> were the zip functions hand typed in haskell or autogenerated  ? there seemed to be a zip ,zip3 , zip5
18:10:31 <ddarius> Of course, how they perform on actual practical sized problems is a totally different question.
18:11:20 <ddarius> poindontcare: Why do you care?
18:11:36 <poindontcare> just wondering
18:14:10 <Lemmih> poindontcare: Written by hand.
18:14:38 <shachaf> Autogenerated by humans.
18:14:46 <poindontcare> xD
18:15:17 <poindontcare> thought I might be missing some fanciness
18:15:56 <shachaf> poindontcare: You probably oughtn't use the big zip functions anyway.
18:16:02 <shachaf> Probably anything more than zip3 is evil.
18:16:36 <poindontcare> yup, yup
18:16:51 <ion> (,,,) generally is indicative of something smelling.
18:17:03 <shachaf> And zipWithN is probably better than zipN for the most part anyway.
18:17:26 <ddarius> poindontcare: So your real question seems to be "is there a way to autogenerate things like zipN?"
18:17:47 <shachaf> Also, you can use repeat and zipWith id to make any-sized zipWithN.
18:18:07 <ddarius> Or ZipList.
18:18:17 <poindontcare> ddarius: yeah , sort of
18:18:18 <shachaf> Right.
18:18:47 <shachaf> > let a = zipWith id in repeat (,,,) `a` [1,2,3] `a` [4,5,6] `a` [7,8,9] `a` [10,11,12]
18:18:48 <lambdabot>   [(1,4,7,10),(2,5,8,11),(3,6,9,12)]
18:18:48 <ddarius> Though explicitly writing zapp = zipWith($) is probably the most convenient thing to do.
18:20:25 <poindontcare> shachaf: you blowing my mind
18:21:07 <poindontcare> thats neat
18:21:12 <shapr> blackdog: g'day! Long time no see!
18:21:30 <shapr> dobblego: howdy! I'm writing LaTeX, it's not quite working out the way I was hoping.
18:24:01 <ddarius> In what way is it not working out?
18:24:45 * hackagebot system-filepath 0.3.4 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.4 (JohnMillikin)
18:24:47 <shapr> I was hoping to embed my graphviz graph directly into my LaTeX source, but the various packages I tried all failed, so I'm generating an EPS and embedding that.
18:24:47 * hackagebot system-filepath 0.4.3 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.3 (JohnMillikin)
18:27:46 <dylex> clearly the only reasonable thing to embed in latex is funcmp.
18:33:46 <blackdog> shapr: how're you doing?
18:34:17 <blackdog> i'm learning javascript for a new project... there'll be a little yesod in it, but mostly js shenanigans
18:34:41 <aristid> :t let zapp=zipWith($) in (,) `map` [1,2,3] `zapp` [4,5,6]
18:34:42 <lambdabot> forall a b. (Num a, Num b) => [(a, b)]
18:34:44 <aristid> > let zapp=zipWith($) in (,) `map` [1,2,3] `zapp` [4,5,6]
18:34:45 <lambdabot>   [(1,4),(2,5),(3,6)]
18:35:19 <shachaf> aristid: I suppose you *could* do that...
18:35:30 <aristid> shachaf: but? :)
18:36:11 * ddarius finds the first paragraph of this difficult to read: http://drdobbs.com/architecture-and-design/208402614
18:37:21 <aristid> ddarius: why do you read this?
19:19:46 * hackagebot system-fileio 0.2.3 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.2.3 (JohnMillikin)
19:24:33 <michaelh> When I do rails all day, I dream of yesod...when I do yesod, I dream of rails. what does this mean?
19:25:00 <parcs> you are confused
19:25:35 <michaelh> well, besides that.
19:26:16 <parcs> web programming is immature
19:26:28 <parcs> sorry, "web development"
19:27:13 <michaelh> yes, but mongodb is webscale!
19:27:28 <dobblego> I can confirm, you are confused
19:29:46 * hackagebot system-fileio 0.3.3 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.3.3 (JohnMillikin)
19:32:26 <DanBurton> Yesod...on rails?
19:32:53 <Nimatek> You mean ruby on yesod.
19:34:35 <michaelh> ;( all i meant was that i like haskell except for when i actually do it.
19:34:38 <MostAwesomeDude> michaelh: You secretly desire Flask. >:3
19:39:21 * edwardk waves hello
19:40:06 <copumpkin> ohai edwardk
19:40:40 <edwardk> worked out your opencl backend yet? =)
19:41:33 <copumpkin> lol no
19:41:55 <copumpkin> been adding some stuff to agda
19:42:05 <edwardk> bah
19:42:07 <ddarius> The compiler or the libraries?
19:42:10 <copumpkin> the compiler
19:42:15 <ddarius> What stuff?
19:42:18 <ddarius> (Briefly.)
19:42:28 <edwardk> i added numeric types and sugar for those, bools, etc.
19:42:49 <edwardk> lots of constraints
19:42:58 <copumpkin> nothing exciting, just fixing its parsing so that the parser and highlighting mechanism can be called easily from other contexts so that we can highlight articles/blog posts in it easily
19:43:07 <edwardk> yay
19:43:11 <edwardk> =)
19:43:11 <copumpkin> all the parser stuff is in IO for some reason
19:43:14 <copumpkin> despite not needing to be
19:43:28 <copumpkin> edwardk: nice!
19:43:37 <edwardk> ah
19:43:37 <copumpkin> RebindableSyntax!
19:43:40 <edwardk> yep
19:43:44 <ddarius> edwardk: You have copumpkin in your list of attendees twice.
19:43:52 <shachaf> ddarius: Also dmwit.
19:44:00 <shachaf> Anyone can edit the list, though.
19:44:01 <copumpkin> people like having spare Dans lying around
19:44:07 <edwardk> I worked out a -horrible- IfThenElse class that lets me use it properly for both Bool and the limited versions i need with inference
19:44:18 <copumpkin> cool
19:44:19 <edwardk> similar hacks for Eq, etc.
19:44:20 <shachaf> Wait, there's only one dmwit.
19:44:45 <shachaf> Ah, he removed it.
19:44:57 <ddarius> shachaf: Anybody who can remember their haskellwiki password.
19:46:10 <shachaf> ddarius: Or their username (and can access their email address), presumably?
19:46:46 <ddarius> If only I knew my user name.  I may also not have access to the email address associated with it.
19:48:14 <shachaf> ddarius: http://haskell.org/haskellwiki/Special:Contributions/Derek_Elkins ?
19:48:45 <ddarius> I knew my password in 2009?  I'm amazed.
19:51:36 <shachaf> Could be a different Derek Elkins.
19:51:48 <shachaf> Are you related to Steve Elkins?
19:52:03 <shachaf> I suppose it might be a reasonably common surname.
19:52:57 <ddarius> Yes, particularly in the area I'm from.  I've walked past Elkins, WV and there's an Elkins, VA somewhere, as well as several others.
19:53:46 <shachaf> What's the area you're from?
19:53:57 <shachaf> Well, I suppose the answer might be WV/VA...
19:54:21 <copumpkin> shachaf holmes
19:54:32 <ddarius> I'll give you a hint.  I'm -not- from West Virginia.
19:54:53 <shachaf> What a coïncidence, nor am I!
19:55:00 * shachaf realizes that he may have been vaguely mentally associating ddarius with elk.
19:56:05 <ddarius> According to something Elkins is derived from Ellins and was created when England needed to reduce confusion.
20:08:50 <dylex> did module exports change in 7.2?  Say A and B both export datatype D.  B imports A hiding (D) and also qualified, and exports module A.  Another module importing B complains D is ambiguous (it didn't on 7.0).
20:10:27 <gienah> dylex: I've seen that problem, my workaround was to list all the imports I want
20:10:28 <ddarius> "34% of the world's top 100 Web sites were using HTML5" - I find this sentence extremely bizarre.
20:11:00 <dylex> In fact, the error is "D may refer to B.D or B.D", which seems wrong.
20:11:43 <Mathnerd314> edwardk: I stumbled across http://comonad.com/reader/2009/recursion-schemes/ ; are you ever going to do that expansion you promised?
20:11:52 <edwardk> no
20:11:55 <dylex> gienah: I'm not sure how I can do that, since I do want to refer to A.D in B, and B.D in C.
20:12:21 <edwardk> i wrote a couple of articles after that but they were eaten when the old comonad.com server was compromised
20:12:45 <edwardk> (someone i know who ran a php bulletin board on the same box was to blame)
20:12:55 <edwardk> and i lost the content of the paramorphism post
20:12:56 <gienah> dylex: this is how I patched gf-3.3 to compile with ghc 7.2.1, where I added the list of package imports: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/gf/files/gf-3.3-ghc-7.2.patch
20:13:36 <ddarius> Alack, I knew PHP would be the death of recursion schemes!  I could not resist the elegance and ease of implementation of PHP.
20:13:42 <edwardk> in any event, i don't believe that the greek/latin roots are useful for describing recursion schemes, and i don't believe that they have much to offer once you get past the basic approach
20:14:23 <edwardk> ddarius: exactly =)
20:14:45 <dylex> gienah: oh, I see. let me try that. if it works it seems like a bug.
20:15:36 <shachaf> Hylomorphisms ought to be called katanamorphisms.
20:16:00 <ddarius> They can slice through all problems.
20:16:16 <edwardk> shachaf: =)
20:16:48 <edwardk> then hylo fusion would just be katana folding, which is something they were doing in japan for a millennium
20:16:55 <Mathnerd314> edwardk: did you try archive.org? I see a paramorphism post on http://web.archive.org/web/20080917030540/http://comonad.com/reader/
20:17:16 <edwardk> wow the haskell cafe
20:17:20 <edwardk> that is old =)
20:18:09 <edwardk> there you go
20:18:27 <edwardk> if someone wants to scrape that and throw it on the wiki, more power to them
20:20:06 <edwardk> what is worse is that captured a post where i made a rooky mistake on asymptotics =0
20:20:19 <edwardk> er rookie
20:20:49 * ddarius has a hard time finding any decent sherbet.
20:20:49 <shachaf> edwardk: You moved in vertical and horizontal lines across the board?
20:20:59 <edwardk> exactly
20:21:23 <ddarius> @google etymology rookie
20:21:24 <lambdabot> http://en.wikipedia.org/wiki/Rookie
20:21:24 <lambdabot> Title: Rookie - Wikipedia, the free encyclopedia
20:21:47 <edwardk> rooky: Of, characteristic of, or abundant in rooks.       I just played a very rooky chess game, I had the run of the board and kept underpromoting.
20:22:23 <blackdog> edwardk: could be cheating, too
20:22:31 <blackdog> to rook is to cheat
20:22:37 <Mathnerd314> edwardk: but you never wrote entries for any of the later items, so there's nothing to put...
20:23:11 <edwardk> there is the recursion-schemes package and the old entries in category-extras. basically i got bored with them. there wasn't any grand insight to be had
20:23:33 <edwardk> even tarmo uustalu, who worked on as many of them as anybody said they were a bad idea ;)
20:23:41 <Mathnerd314> hmm, then what was the point? :p
20:23:45 <edwardk> exactly
20:23:59 <shachaf> edwardk: "as many of them as anybody" -- i.e., none of them? :-)
20:24:05 <edwardk> hence why i'm bothering right now to say "you know this thing I did? it sucked" =)
20:24:27 <Mathnerd314> edwardk: so how do you model recursion then?
20:24:37 <edwardk> shachaf: he defined the one that sort of closed the set the recursion theme for the cofree recursive comonad, which he refused to give a greek/latin name ;)
20:24:46 <edwardk> to model recursion first you must model recursion
20:25:08 <Mathnerd314> lol. so you don't, basically.
20:25:18 <edwardk> well
20:25:22 <edwardk> what i mean is this
20:25:52 <edwardk> the interesting bits come from cata, ana and hylo and their generalization in the form that you can extend them with a monad or a comonad with a distributive law
20:26:46 <edwardk> _any_ monad or comonad with a distributive law will do though
20:26:46 <edwardk> giving every one of those some random greek name just because lambert meertens had a fetish doesn't help and actively hinders their adoption
20:27:28 <Mathnerd314> ah. so it's only the cata-, ana-, and hylomorphisms that are important?
20:27:32 <edwardk> yes
20:27:32 <byorgey> edwardk: hmm, interesting, I didn't know this.
20:27:38 <edwardk> and their g_ variants
20:27:46 <ddarius> From a theoretical perspective, cata and ana (fold and unfold / initial algebras and final coalgebras) are the important things.  Most of the rest are just variation or elaborations.
20:28:21 <edwardk> hylo is just a mix of cata and ana, it is interesting because there is a (crappy) fusion law for it, which hasn't panned out as an effective optimization strategy to automate
20:28:25 <ddarius> Many more complicated constructions can be viewed as initial algebras (or final coalgebras) in more complex categories.
20:28:33 <edwardk> ddarius++
20:28:48 <ddarius> Hylomorphisms also give you general recursion which somewhat defeats the point...
20:29:57 <Mathnerd314> ok, so it's only the cata- and anamorphisms? :p
20:31:11 <edwardk> Mathnerd314: yes and if you are going that far, you might as well take them out of their scary greek sheetcovers since Halloween has just passed and just call them fold and unfold.
20:31:15 <ddarius> Categoristss actually care about initial algebras and final coalgebras.  Occasionally they use the terms fold and unfold for them.  Catamorphism and anamorphism are unheard of by categorists.  Categorists also mostly don't care about zygomorphism etc.
20:32:50 <edwardk> http://www.kestrel.edu/home/people/meertens/diverse/calc.pdf is the only other bit of material i can think of by meertens. i think his naming speaks for itself ;)
20:35:32 <edwardk> ddarius: didn't we just have this conversation the other day?
20:35:40 <edwardk> or am i stuck in a timewarp again?
20:36:54 <MostAwesomeDude> Are there cache maps in Haskell? I see the basic map, but is there some sort of map which caches/weakrefs its values?
20:37:30 <BMeph> edwardk: It's just a jump to the left... ;)
20:37:53 <MostAwesomeDude> And a step to the riiiiight~
20:37:58 <MostAwesomeDude> Sorry, reflex.
20:38:13 <edwardk> Ack. The only problem with time travel is all the tenses. I need to brush up on my present future pluperfect ;)
20:38:45 * BMeph imagines that "pelvic thrust" must make some a little "MAD"... ;þ
20:39:03 <edwardk> MostAwesomeDude: you can make a map that holds WeakRefs but you need to access them using IO in the end
20:39:29 <MostAwesomeDude> BMeph: :3
20:39:38 <scooty-puff> is it possible to use type class contraints on a query that will be used with any of Data.Generics.Aliases?
20:39:51 <edwardk> MostAwesomeDude: an older version of my intern library used to have a map/cache that does what you want, but it turned out to be unsound, and failed under high load
20:40:02 <MostAwesomeDude> edwardk: Hm. If I wanted to cache a finite number of things, what would be the best approach?
20:40:39 <edwardk> well, build some kind of manual LRU cache. easiest way is with a priority search queue, there are several
20:40:58 <MostAwesomeDude> Or, perhaps more generally, if I had a type which represented an on-disk resource, what would be the best model for managing those resources in Haskell?
20:41:13 <MostAwesomeDude> Reading, modifying, writing, but without impacting performance.
20:41:35 <edwardk> you'll still need to deal with mapping it in as an IO action of some sort, which can be a bit of a pain in the neck
20:41:49 <edwardk> so there isn't a _particularly_ elegant solution
20:44:29 <Mathnerd314> so how do folds and unfolds relate to SYB (or other generics libraries)?
20:46:25 <edwardk> they really kinda don't. the gfold gunfold operations really only describe a single layer of the result
20:51:17 <ddarius> The key behind the generic libraries is essentially providing a uniform isomorphic view of the data from which point you can define uniform functions.
20:59:44 <Mathnerd314> ah. so they basically rip the data structure into (uniformly small) shreds and then let you scrounge through the pieces.
21:00:35 <Axman6> MostAwesomeDude: i'm not sure if this is at all what you're after, but zoom-cache might be related (and if it's not, it's still very cool =)
21:00:38 <Mathnerd314> whereas a fold turns the data structure into a call tree
21:01:13 <Mathnerd314> and thus preserves the structure
21:01:48 <MostAwesomeDude> Axman6: I'll take a look.
21:04:29 <Mathnerd314> and apparently one has to worry about ripping it too much and losing the data you want to extract
21:05:50 * ddarius is not sure where Mathnerd314 got this idea of "ripping" things up.
21:07:20 <Mathnerd314> it's a metaphor I invented while reading the slides
21:07:30 <Mathnerd314> is it inaccurate?
21:07:56 <ddarius> What slides?
21:08:21 <Mathnerd314> last of https://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
21:09:40 <ddarius> What are these "shreds" you envision the data structure being ripped up into?
21:09:57 <shapr> sawzall makes shreds?
21:11:07 <Mathnerd314> ddarius: primitive types like Int, or "small" structures of them
21:12:45 <Mathnerd314> e.g. [Int]
21:14:56 <ddarius> What would be something that isn't a "small structure."
21:14:57 <ddarius> ?
21:15:54 <ion> yo momma
21:16:00 <ion> *zing*
21:16:18 <Mathnerd314> ddarius: whatever "complicated" type you're genericizing over. E.g. a trinary tree or something evil like that
21:16:26 <ddarius> Ah, a refreshing blast from the 1990s.
21:16:38 <blackdog> ion: yo momma's so fat her binary trees have three branches
21:17:21 <ion> hah
21:18:47 <ddarius> Mathnerd314: What if my "complicated" type is [Int]?  Also what are all the "small" structures?
21:20:56 <Mathnerd314> the "small" structures are probably Int's
21:21:24 <ddarius> Well I meant in general for the latter question.
21:21:52 <Mathnerd314> well, they're whatever you write special cases for
21:36:35 <Mathnerd314> so the question IMO is whether you can write folds and unfolds using gfold and gunfold
21:42:54 <Mathnerd314> and I'm guessing the answer is "yes, but it's not generic"
22:06:01 <hpaste> abi pasted “yesod cabal-dev install” at http://hpaste.org/53623
22:06:09 <abiii> what's the simplest way to get yesod installed? i first used cabal but ran into a bunch of conflicts. next, i tried cabal-dev and it gave me this wall of text: http://hpaste.org/53623
22:09:48 * hackagebot tag-stream 0.2.0 - streamlined html tag parser  http://hackage.haskell.org/package/tag-stream-0.2.0 (YiHuang)
22:10:27 <Saizan> abiii: you've to look into the backlog to find the real error
22:22:27 <hpaste> abi annotated “yesod cabal-dev install” with “yesod cabal-dev install (annotation)” at http://hpaste.org/53623#a53624
22:23:02 <abiii> Saizan: seems to be transformers
22:25:12 <abiii> but i thought the idea with cabal-dev was that everything was being installed in an isolated environment. shouldn't there be no conflicts?
22:27:31 <Saizan> i'm not that familiar with cabal-dev
22:28:14 <Saizan> i assume it will install the packages needed for yesod in the same isolated environment, otherwise yesod can't use them
22:28:46 <Saizan> also, cabal-dev will still use at least the ones from the global db, since most of those can't be installed separately from ghc
22:30:45 <MostAwesomeDude> So, I'm noticing that my actual LOC rate is roughly 10 LOC/hr for actual code. Does it slowly get easier with experience? My Python rate's over 500 LOC/hr, so I'm kinda worries.
22:30:48 <MostAwesomeDude> *worried, even.
22:31:39 <shachaf> If you're new to Haskell, then presumably it'll get easier with experience, yes.
22:31:46 <byorgey> MostAwesomeDude: 10 LOC/hr is quite good.
22:31:48 <shachaf> Also -- 500 lines per hour?
22:31:55 <mlh> you might take that to mean 1 haskell loc = 50 python loc :-)
22:32:02 <ddarius> Yeah, 500LOC/hr is ridiculous.
22:32:21 <ddarius> As in you are doing something ridiculous.
22:32:48 <ddarius> With experience you LOC/hr of Haskell decreases.
22:33:32 <shachaf> You should probably compare something other than lines of code, anyway.
22:34:28 <MostAwesomeDude> ddarius: I type fast and don't spend more than about 10min at a time typing.
22:34:36 <abiii> Saizan: what do you mean by "the ones"?
22:34:43 <ddarius> On one old study, that I have no idea if it was replicated much, and only really compared languages like C++ and Java to each other, they found that the defect rate per lines of code was independent of language, but the number of lines of code was not, i.e. less lines means less defects.
22:35:01 <MostAwesomeDude> Anyway, if it's normal, then no worries. :3
22:35:31 <MostAwesomeDude> Also, the ST monad appears to be cheating. Would it really be possible for me to operate an entire thread of control, like a forkIO'd socket connection, inside one of those?
22:35:35 <ddarius> MostAwesomeDude: Typing fast is irrelevant, unless you mean you type at 500LOC/hr for 6 minutes a day and spend the rest of the day thinking.
22:36:37 <ddarius> If you averaged 500 LOC/hr, the vast majority of those lines of code are either utter boilerplate or copy/paste style repetition.
22:36:41 <MostAwesomeDude> ddarius: I commit over 100 LOCs/day, easy, on pet projects. LOCs at work are harder to measure, but I am confident that I am only inhibited at work by Django, not by Python itself.
22:37:31 <Saizan> abiii: the packages
22:38:12 <abiii> Saizan: it should install every package that is a dep for yesod inside the subdir, shouldn't it?
22:38:33 <ddarius> MostAwesomeDude: 100 LOC/day is less than 15 LOC/hr.  Also, I too can spew out a lot of code at a time when I hit one of those spots where I know what I want to do and how, but just counting that time would be disingenuous.
22:39:03 <MostAwesomeDude> ddarius: I'm talking about typing time, not total usefulness over a day.
22:39:28 <MostAwesomeDude> Perhaps another way to look at what I'm thinking: I find myself sitting at a keyboard, with Haskell, constantly typing out things which don't work.
22:45:16 <Saizan> abiii: it can't do that with e.g. base
22:46:43 <abiii> Saizan: sure
22:48:17 <ian_mi> MostAwesomeDude: I made you an echo server
22:48:22 <hpaste> “Ian Milligan” pasted “Echo Server” at http://hpaste.org/53625
22:48:38 <ian_mi> using STM
22:51:48 <mm_freak> i have a type class, which i can't modify, and i have an instance of the form:  SomeClass (>~) => SomeClass (MyArrow (>~))
22:52:16 <mm_freak> i need UndecidableInstances for that, even though it's safe, as long as nobody defines a SomeClass instance for MyArrow itself
22:52:29 <mm_freak> is there any way to solve this without UndecidableInstances?
22:54:12 <mm_freak> well, more elegant than making more specific instances
22:54:54 <ddarius> There probably is, but it's probably not worth the hassle.
22:55:52 <Saizan> but that's pretty clearly structurally recursive, how come ghc can't see that?
22:57:08 * ddarius suspects either a typo or that mm_freak try using a name like 'a' instead of '(>~)'.
22:57:34 <mm_freak> instance (ArrowChoice (>~), ArrowState s (>~)) => ArrowState s (Wire e (>~)) where
22:57:40 <mm_freak> that one causes it
22:57:59 <mm_freak> i just simplified it
22:58:01 <Saizan> ah, ok, it's because of the fundep in ArrowState
22:58:05 <ddarius> Indeed.
22:58:14 <ddarius> mm_freak: You simplified away the problem.
22:58:22 <mm_freak> ok
22:58:38 <Saizan> it's still fine anyway
22:58:48 <mm_freak> then i probably didn't understand the problem itself
22:58:51 <ddarius> As an example, Show a => Show [a] is of the same form.
23:00:59 <Saizan> the problem is that s doesn't appear in (Wire e (>~)) so ghc can't confirm that the fundep is respected
23:05:52 <mm_freak> i see
23:11:46 <wdd`````````````> http://i.imgur.com/5m1Vp.gif
23:18:39 <mlh> ian_mi: echo-server-ian-milligan.hs:30:44: Not in scope: `tryIOError'
23:18:49 <mlh> Am I missing a package?
23:19:33 <mlh> I tried changing that to try<space>IOError, no good
23:20:19 <scshunt> @hoogle tryIOError
23:20:19 <lambdabot> No results found
23:30:35 <ian_mi> mlh: I'm using ghc 7.2.1. The tryError in System.IO.Error was renamed to tryIOError so it doesn't clash with Control.Exception. Just change tryIOError to tryError.
23:32:53 <ian_mi> MostAwesomeDude: ^ You'll probably have to do that too if want to try it out.
23:46:53 <mlh> ian_mi: 6.12.3 here. tryError is not in scope either
23:47:18 <mlh> @hoogle tryError
23:47:18 <lambdabot> No results found
23:50:43 <ian_mi> it's here http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO-Error.html
23:51:04 <ian_mi> mlh: oh, sorry use try
23:51:12 <ian_mi> mlh: not tryError
23:51:40 <ian_mi> still doesn't explain why hoogle doesn't find it...
23:53:01 <alios> i have a small proplem with type families and classes. how can I express the following, so the type system excepts it? https://gist.github.com/1342569
23:54:11 <rwbarton> can you just rewrite it to "class (Bits a) => C a where f1 :: (a, a) -> (a, a); ..."
23:54:14 <rwbarton> ?
23:55:35 <rwbarton> also, do you understand why you are getting an error?
23:59:44 <alios> I understand more or less whats its problem is... The example is a reduced version of a more complex class and I wanted to play with typefamilies ...
