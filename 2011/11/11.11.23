00:49:00 <sefb1704> hello guys
00:53:07 <hpaste> sefb1704 pasted “small problem” at http://hpaste.org/54423
00:53:46 <shachaf> sefb1704: You can't just say "a = b" like that.
00:53:58 <sefb1704> :(
00:54:05 <shachaf> You probably want something like "let knife = x!!0; wood = x!!1 in ..."
00:54:09 <shachaf> Actually, you don't want that either.
00:54:16 <sefb1704> :(
00:54:18 <shachaf> (!!) is very often a sign that you're doing something wrong.
00:54:23 <sefb1704> ?!
00:54:24 <lambdabot> Maybe you meant: . ? @ v
00:54:42 <shachaf> function (knife:wood:theRest) "clearance" = ...
00:54:43 <sefb1704> i save variables in a list and i know at what index they are saved
00:54:52 <shachaf> function (knife:wood:theRest) somethingElse = ...
00:54:56 <sefb1704> i thought !! would be the right way to read them
00:55:16 <sefb1704> oh thats smart
00:55:28 <shachaf> sefb1704: There isn't much contet, but it feels like you're trying to force an unnatural way of thinking about things into Haskell code.
00:56:04 <shachaf> It doesn't really work, and when you manage to make it work it can come out ugly and inefficient.
00:56:09 <shachaf> However, I don't know what you're trying to do. :-)
00:56:10 <sefb1704> however i got it thanks :)
00:56:36 <alistra> :t (@)
00:56:37 <lambdabot> parse error on input `@'
00:56:42 <alistra> hoogle @
00:56:47 <alistra> @hoogle @
00:56:48 <lambdabot> keyword
00:56:49 <lambdabot> Test.HUnit.Base (
00:56:49 <lambdabot> Test.HUnit.Base (
00:57:19 * hackagebot Agda 2.3.0 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.3.0 (UlfNorell)
00:57:21 * hackagebot Agda-executable 2.3.0 - Command-line program for type-checking and compiling Agda programs  http://hackage.haskell.org/package/Agda-executable-2.3.0 (UlfNorell)
00:58:12 <sefb1704> btw im doing a text-adventure-game in haskell
01:01:21 <shachaf> sefb1704: It might be a good idea to read further in whatever Haskell guide you're using before trying to make a full text-based adventure game.
01:01:51 <shachaf> On the other hand, you might just figure things out as you go along. :-)
01:02:05 <shachaf> But getting a general idea of the syntax and common idioms will be really helpful.
01:02:15 <sefb1704> naaah, im doing just fine. yesterday there was recursion in the lecture and i finally figured out how to change variables <3
01:02:43 <sefb1704> y i know already about that (x:xs) trick but it didnt come to my mind to use it in this situation
01:03:06 <shachaf> sefb1704: You can't change variables.
01:03:24 <sefb1704> y but you can simulate it by doing recursion <3
01:05:35 <sefb1704> dammit
01:06:16 <sefb1704> why does this " else if  knife==1 && wood==1  " not work? :( error arising from a use of `=='
01:06:30 <JaffaCake> jaffa
01:06:39 <sefb1704> cake
01:06:41 <JaffaCake> oops, ignore me
01:07:15 <sefb1704> shachaf: why does this " else if knife==1 && wood==1 " not work? error arising from a use of `=='
01:08:13 <shachaf> JaffaCake: But you come around here so rarely!
01:08:14 <Sgeo> What is the exact error message?
01:08:28 <JaffaCake> I am always here, watching :)
01:08:29 * Sgeo should be sleeping :/
01:08:32 <sefb1704> sgeo have you just joined?
01:08:48 <Sgeo> sefb1704, I've been here a while, but just started paying attention
01:09:16 <sefb1704> my function looks like this :function :: [a] -> String -> IO()
01:09:18 <sefb1704> function (knife:wood:xs) nextstep = ... if wood == 1 && knife == 1
01:09:19 <sefb1704> this guy dislikes the "=="
01:09:44 <Sgeo> Because you can't necessarily compare any two items
01:09:54 <Sgeo> Do you know about typeclasses?
01:10:12 <Sgeo> sefb1704, what would happen if wood was a list, or a string?
01:10:31 <sefb1704> the thing is, i know the type of wood and knife is always integer
01:10:32 <Sgeo> (Ignore my typeclasses comment0
01:10:34 <shachaf> Sgeo: What if it was a list *and* a string?!
01:10:43 <Sgeo> sefb1704, does the compiler know it?
01:10:43 <sefb1704> so i dont have to tell haskell that it has to be integer
01:10:53 <shachaf> sefb1704: Yes you do.
01:10:57 <shachaf> Haskell needs to know.
01:10:57 <opqdonut> yes you do
01:10:58 <Sgeo> sefb1704, yes you do, unless it can figure it out on its own
01:11:07 <opqdonut> you can either leave the type sig completely out
01:11:11 <opqdonut> or it has to be correct
01:11:19 <opqdonut> there has been talk about allowing wildcards in type sigs
01:11:36 <opqdonut> something like marking things to be left inferred with a _
01:11:44 <opqdonut> but there's nothing like that yet
01:12:06 <sefb1704> we use wildcards in our lecture .. well however so its okay if i write Eq => [a] -> String -> IO() in the contract?
01:12:28 <Sgeo> sefb1704, you probably meant (Eq a), but ... you're comparing against a Number
01:12:45 <Sgeo> You can't compare something of type a with something of different type b
01:12:53 <Sgeo> (Compare may be the wrong word here)
01:13:06 <Sgeo> (Also, I should have said Num)
01:13:38 <sefb1704> okey so what do i have to "=>"  befor [a] to be able to make this if wood == 1 && knife == 1
01:13:54 <Sgeo> (Num a)
01:13:55 <opqdonut> Num should work
01:14:01 <opqdonut> because:
01:14:03 <opqdonut> :t 1
01:14:04 <lambdabot> forall t. (Num t) => t
01:14:11 <opqdonut> numeral constants are actually polymorphic
01:14:27 <sefb1704> okey .. so i write (Num a) => [a] -> String -> IO()
01:14:29 <opqdonut> but if you know  that the argument to that function will always be a [Int], why not tell that in the type signature?
01:14:42 <sefb1704> caus i thought it was unnecessary
01:14:48 <opqdonut> you can also just leave the type signature out, and ask ghc what the type should be
01:15:05 <shachaf> sefb1704: The type signature is what the function *is*.
01:15:13 <shachaf> It's a function from a list of Integers to blah blah blah.
01:15:21 <Sgeo> sefb1704, try commenting out the type signature, and see what happens
01:15:28 <sefb1704> awesome guys this code works!! <3
01:15:34 <opqdonut> :t let f (knife:wood:xs) nextstep = if wood == 1 && knife == 1 then return () else print "" in f
01:15:35 <lambdabot> forall t t1. (Num t) => [t] -> t1 -> IO ()
01:15:37 <sefb1704> okey i will try it sgeo
01:15:51 <frerich> sefb1704: Taking a small step back, if you have something like 'function (knife:wood:xs) = ... if knife == 1 && wood == 1 then ..' then maybe pattern matching would be a good alternative.
01:16:15 <sefb1704> dude my if clauses are simply so huge
01:16:17 <sefb1704> i dont want this
01:16:20 <Sgeo> Do we even know why sefb1704 is using a list instead of a tuple?
01:16:30 <sefb1704> um i havent told you yet
01:16:36 <Sgeo> sefb1704, pattern matching would remove some of the ifs
01:16:38 <sefb1704> i am working on a textadventure game in haskell
01:17:02 <sefb1704> aaaand in this game you have different items that you can have if you find them in the world i creat
01:17:04 <sefb1704> e
01:17:21 <sefb1704> and i am still at the start of the programm, so i only have 2 items
01:17:57 <sefb1704> but if i want to add more i think i save time in implementing them by using a list and not seperate items
01:18:46 <Sgeo> A record might be more convenient and semantically correct
01:18:49 <Sgeo> But I'm not sure
01:18:57 <kmc> data Item = Knife | Wood;  type Items = Set Item
01:19:20 <frerich> sefb1704: Leaving the question of whether a list makes sense here or not aside; pattern matching would actually get rid of a few if's for you. You can write something like 'function (1:1:xs) = ...' and that definition is only used if the first two items in the list are '1'.
01:19:27 <mux> you'd need an Ord constraint on Item
01:19:36 <mux> plus you wouldn't be able to have two knives if you're using a Set
01:19:40 <Sgeo> @hoogle (Ord a) => a -> Set a -> Bool
01:19:41 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
01:19:41 <lambdabot> Data.Set notMember :: Ord a => a -> Set a -> Bool
01:19:41 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
01:19:54 <sefb1704> frerich: but my program is really huge
01:20:01 <sefb1704> i think i dont want pattern matchin in there
01:20:11 <kmc> you keep saying that, but it keeps not making sense
01:20:34 * Sgeo :/s at lists using elem but sets using member
01:20:40 <hpaste> sefb1704 pasted “adventuregame” at http://hpaste.org/54424
01:21:04 <mauke> sefb1704: line 14 uses pattern matching
01:21:08 <mauke> your argument is invalid
01:21:12 <Sgeo> data Item = Knife | Wood; type Items = Map Item Int
01:21:26 <mux> Sgeo: you still need 'deriving Ord'
01:21:29 <Sgeo> Erm, still need deriving .. right
01:22:00 * Sgeo still wants a TreeOrd for when comparison makes no sense except for purposes of making certain algorithms more efficient
01:22:22 <sefb1704> :'( please i dont want to convert this into pattern matching
01:22:25 <kmc> sefb1704, i'm going to be honest; this code is terrible
01:22:32 <frerich> sefb1704: Note how you have a lot of 'if nextstep == "foo"' in there. You could use pattern matching here nicely; factor the individual branches into a separate function  (say: 'dostep') and then use pattern matching there (like: 'dostep "jungle" = do ...')
01:22:40 <kmc> you definitely need to break things up into separate definitions
01:22:44 <mauke> sefb1704: YOU ARE ALREADY USING IT
01:22:50 <mauke> sefb1704: WHAT DO YOU MEAN BY "CONVERT"?
01:22:50 <kmc> it's not ok to have a 100 line function named 'function'
01:22:52 <frerich> sefb1704: That way, you can get rid of a lot of ifs and you reduce the indentation depth a lot.
01:22:55 <kmc> most haskell functions will be a few lines
01:23:05 <kmc> you also have a ton of repeated code, as is probably clear visually
01:23:09 <frerich> Guys, you have to grant him that the ASCII art of the wild bear (at the bottom of 'function') is really nice!
01:23:09 <kmc> you can factor that out into helper functions
01:24:12 <kmc> anyway I think you should learn more about the language
01:24:15 <kmc> and do more small exercises
01:24:19 <kmc> before you attempt something this big
01:24:29 <frerich> Boo, that's not the spirit :)
01:24:41 <Sgeo> I should attempt to do something big, to see that my code wouldn't end up turning out horrible
01:24:44 * frerich thinks starting to write a game and picking things up on the way is really good for motivation.
01:24:51 <Sgeo> I've written very little Haskell code :(
01:25:19 <kmc> frerich, writing a total mess, then having IRC tell you you've painted yourself into a corner and need to start over
01:25:22 <kmc> does not seem motivating.
01:25:39 <kmc> learning happens when you try things which are only a little beyond your current ability
01:25:47 <frerich> kmc: Only if you're not willing to learn (but in that case, all hope is lost anyway)
01:25:49 <kmc> if you aim too far, you just flail
01:26:15 <frerich> kmc: Maybe, but if you fail and then learn how to do it better, the reason for *why* doing it that other way is better is probably much more apparent.
01:26:38 <kmc> no that's my point
01:26:42 <kmc> if the task is too far beyond your ability
01:26:47 <kmc> then "how to do it better" won't make any sense
01:26:58 <kmc> you just get confused and lost
01:26:58 <sefb1704> :'( leave me alone i will leave this irc now you mean ppl!! :'(
01:27:05 <kmc> and a sense of dread
01:27:18 <frerich> Seems he just confirmed your point.
01:28:03 <mux> I don't blame him, he got yelled at for no good reason
01:28:06 <kmc> at the point where you're already using pattern matching, and protesting angrily that you can't switch to using pattern matching
01:28:20 <kmc> then something has gone wrong
01:28:38 <Sgeo> kmc, to me, it was clear that he meant switch to more pattern matching
01:28:50 <kmc> yelled at by mauke you mean?
01:28:53 <Sgeo> And he only ended up using pattern matching when we told him what to do, he may not have realized it
01:28:57 <mux> kmc: yes
01:29:43 <frerich> I still like the ASCII art bear.
01:30:10 <frerich> And the 'OK, NOW YOU ARE IN DANGER' message in the game would make a good source code comment, too :-)
01:30:33 <mauke> <sefb1704> i think i dont want pattern matchin in there  <mauke> sefb1704: line 14 uses pattern matching  <sefb1704> :'( please i dont want to convert this into pattern matching  <mauke> sefb1704: YOU ARE ALREADY USING IT
01:31:09 <mauke> I just wanted him to acknowledge :-(
01:31:34 <mux> I completely understand your frustration... chances are that I'd have had the same reaction as you did if I was the one talking
01:32:09 <mux> but still, he seemed like a complete newbie and this probably didn't make him want to go on asking questions in here
01:32:47 <frerich> Mayeb there was some language barrier as well (he's apparently german).
01:32:50 <shachaf> Wow, I just saw the rest of the code.
01:32:59 <kmc> might be my fault too for saying the code is 'terrible'
01:33:04 <kmc> but... it is
01:33:05 * shachaf is vaguely glad to have given up early.
01:34:13 <kmc> and i gave some suggestions for improvement
01:34:22 <kmc> but i think throwing it out and starting on a simpler project is the way
01:34:45 * Sgeo needs sleep time now
01:35:46 * mux remembers when he nearly broke his keyboard out of frustration while completely failing to write a simple "guess the number between 1 and 100" game in haskell
01:35:53 <mauke> given their host they're a university student and at least 19 years old
01:36:00 <shachaf> mux: Were you reading YAHT, by any chance?
01:36:20 <mux> shachaf: if I remember correctly, YAHT didn't exist at that time
01:36:22 <shachaf> mauke: How can you figure out their age?
01:36:37 <mauke> oh wait, may be down to 18 now
01:36:40 <shachaf> mux: Ah. It starts out with an introduction that's vaguely similar to that.
01:36:49 <mux> I was using some tutorial named "Haskell for C programmers" or something
01:37:04 <frerich> shachaf: Well, a university student is usually at least 18-19 years old.
01:37:19 <kmc> usually
01:37:21 <mauke> shachaf: they had to finish Gymnasium
01:37:36 <shachaf> Haskell for C programmers: (1) Forget C. (2) See "Haskell for everybody else".
01:37:48 <frerich> mauke: Maybe she was female and had 12 years of Gymnasium only, in that case 17 would prolly be possible, too :)
01:37:57 <mauke> I was 19 when I did, and then there was a year of military service
01:38:17 <mauke> now there's no military service and it's down to 12 years
01:38:23 <mauke> so possibly 18
01:38:55 <shachaf> Is it not possible to start university earlier in .de?
01:39:05 <shachaf> Not that that's particularly relevant.
01:39:10 <mauke> hmm
01:39:28 <mauke> you could skip a grade or two
01:40:06 <frerich> mauke: Or you could go to school at 5.
01:40:07 <mux> shachaf: sometimes, analogies with another language can go a long way helping you understand a new one, even if the analogies are terribly wrong/inaccurate in the end
01:40:37 <kmc> sometimes
01:40:46 <kmc> but it's easier to come up with analogies which are worse than useless
01:40:54 <mux> as I remember it anyways, Haskell for C programmers helped me a great deal
01:41:22 <mux> there was some other tutorial, but it assumed some pre-existing knowledge of FP which blew my mind
01:41:46 <kmc> analogies to C might be better than most languages
01:42:00 <kmc> because there aren't many things in C
01:42:05 <shachaf> Monads are like pointers.
01:42:05 <mux> by the time I got the gist of it, there was LYAH. that got me slightly angry :-)
01:42:19 * hackagebot happy 1.18.8 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.8 (SimonMarlow)
01:42:22 * kmc vaguely considers auto-ignoring anyone who says "monads are like"
01:42:49 <mauke> monads are like, totally sweet, man
01:43:00 <mux> monads are like women: you can't really understand them, but you can learn to coexist peacefully with them.
01:43:13 <kmc> oh fuck this
01:43:39 <mux> heh, did we really get him angry with that? that's what I call being short-tempered.
01:44:00 <mauke> I blame you
01:44:06 <mauke> because I think that was awful
01:44:20 <mux> ok, I'll take the blame
01:44:55 * shachaf should take the blame.
01:45:11 <mux> let's split the blame then
01:45:22 <mux> @karma- mux
01:45:23 <lambdabot> You can't change your own karma, silly.
01:45:24 <shachaf> OK, I'll take 51%.
01:45:45 <alistra> @karma- mux
01:45:46 <lambdabot> mux's karma lowered to 7.
01:45:48 <alistra> lemme help
01:45:54 <mux> you're so kind :-P
01:46:47 <opqdonut> I think I learned with YAHT
01:47:04 <opqdonut> and haven't really looked at any of the other haskell materials that've appeared since then
01:47:14 <opqdonut> except some RWH
01:47:35 <opqdonut> I read HSOE but too late, I didn't learn anything
01:48:13 <alistra> opqdonut: http://www.scs.stanford.edu/11au-cs240h/notes/
01:48:40 * mux notes kmc also left #ghc
01:49:06 <shachaf> mux: That's what "quit" is.
01:49:16 <alistra> monads are like being short-temered like kmc
01:49:20 <mux> d'oh
01:49:28 <alistra> monads are like people who say what monads are like
01:49:48 <mauke> monads are like analogies
01:50:16 <alistra> monads are like me and you
01:50:22 <alistra> monads are people too
01:51:29 <frerich> Finally some more intuitive explanations than burritos!
01:51:54 <alistra> monads are like two thousand spoons when all you need is a knife
01:52:03 <alistra> monads are like rain on a wedding day
01:52:04 <mauke> how ironic
01:52:13 <mux> alanis morrissette references? oh god
01:52:38 <alistra> mauke:with Monad m, Ironic m => Moronic m
01:53:06 <mux> it's a good thing kmc already left or he would probably have gone on a rampage by now
01:53:11 <opqdonut> alistra: thanks for the link! I'm teaching a haskell course this spring and that looks like a nice angle
01:53:28 <alistra> opqdonut: teaching?
01:53:30 <alistra> what university
01:53:47 <opqdonut> Helsinki
01:54:50 <cwl> I've post a question about binomial heaps from <Purely Functional Data Structures> in stackoverflow
01:54:52 <alistra> monads are like warm summer rain
01:54:55 <Brax> why isn't this working: let echo = do {c <- getChar; unless (c == '\n') (putChar c >>= echo)}
01:54:58 <Brax> Couldn't match expected type `() -> IO ()' with actual type `IO ()'
01:55:18 <opqdonut> cwl: link?
01:55:20 <alistra> putChar c
01:55:23 <Brax> copied from a slide
01:55:27 <alistra> Brax: why do you need echo>
01:55:30 <shachaf> Brax: What slide?
01:55:35 <shachaf> Brax: You probably want ">>", not ">>=".
01:55:41 <Brax> from a lecture
01:55:48 <alistra> ditch the >>= echo
01:55:49 <shachaf> Is the slide online?
01:55:58 <cwl> http://stackoverflow.com/questions/8237847/how-to-understand-segmented-binomial-heaps-described-in-purely-functional-data
01:56:00 <sefd1637> hello
01:56:04 <cwl> opqdonut
01:56:06 <shachaf> alistra: That changes the function.
01:56:19 <alistra> @src echo
01:56:19 <lambdabot> Source not found. I feel much better now.
01:56:24 <alistra> hoogle echo
01:56:27 <mauke> alistra: dude.
01:56:28 <sefd1637> i got a question to pattern matching
01:56:28 <alistra> @hoogle echo
01:56:29 <lambdabot> System.Posix.Terminal EchoErase :: TerminalMode
01:56:29 <lambdabot> System.Posix.Terminal EchoKill :: TerminalMode
01:56:30 <lambdabot> System.Posix.Terminal EchoLF :: TerminalMode
01:56:32 <Brax> thanks
01:56:42 <Brax> that was it
01:56:42 <mauke> sefd1637: willkommen zurück
01:56:59 <alistra> mauke: what?
01:57:06 <sefd1637> its german
01:57:09 <shachaf> alistra: Read the code.
01:57:11 <sefd1637> "welcome back"
01:57:13 <mauke> alistra: <Brax> why isn't this working: let echo =
01:57:20 <alistra> oh
01:57:25 <alistra> sorry
01:57:36 <opqdonut> cwl: yeah, found it
01:59:24 <alistra> monads are like not reading the question throughly before answering on #haskell
02:00:59 <mauke> cwl: my 6.3.1 talks about justifying the banker's method
02:02:24 * frerich wonders whether sefd1637 was eaten by a wild bear, or whether he's in a private query with mauke.
02:02:36 <frerich> The excitement might be the same, I guess.
02:02:38 <mauke> not with me
02:03:06 <opqdonut> cwl: answered.
02:03:23 <frerich> sefd1637: In that case - I didn't see your question regarding pattern matching yet.
02:04:15 <cwl> mauke, 6.3.1 is Segmented Binomial Random-Access Lists and Heaps
02:04:22 <mauke> cwl: oh, you're not talking about the book
02:04:29 <mauke> you linked to the thesis
02:05:07 <alistra> i've read only functional rbts by okasaki
02:05:12 <alistra> i enjoyed the paper
02:05:28 <mauke> functional rabbits
02:05:49 <alistra> robots
02:06:39 <alistra> functional rainbow cactus
02:06:48 <alistra> grep -r "^r.*b.*t.*s$" /usr/share/dict/*
02:07:21 <mauke> rowboats
02:07:26 <mauke> ribbits
02:08:28 <cwl> mauke, is the book different from the thesis much? I didn't read the book
02:08:43 <mauke> I didn't read the thesis
02:08:56 <alistra> iirc the book is more basic
02:09:02 <opqdonut> the book has more stuff
02:09:06 <alistra> and thesis only has the interesting stuff
02:09:06 <opqdonut> IIRC
02:09:59 <Brax> rebates
02:10:08 <Brax> ratbats
02:10:31 <opqdonut> roberts
02:11:03 <alistra> opqdonut: is it advanced haskell or basic?
02:11:35 <opqdonut> basic, but it'll be practical as opposed to theoretical
02:11:56 <opqdonut> CS240h has way too much material
02:12:17 <alistra> cs240h was the awesomest haskell resource i've found
02:12:26 <opqdonut> but the material might still be of some inspiration
02:13:15 <alistra> i could've tried to find the advanced, but i guess you don't need it
02:13:21 <shachaf> opqdonut: cs240h is great.
02:13:43 <alistra> it was some high level fun, like counting shit on types, making a polyargument functions, etc
02:14:34 <Matt`> folks, is there a library for handling ascii chars with value greater than 127?
02:14:52 <Botje> Matt`: there is no such thing.
02:14:54 <shachaf> Matt`: There is no such thing.
02:14:59 * Botje high fives shachaf 
02:15:09 <Matt`> more's the pity
02:15:22 <shachaf> Matt`: No such characters, that is.
02:15:32 <mauke> well, you can propose a change to the ASCII standard to include characters > 127
02:15:32 <shachaf> (Also no such library, but that follows directly.)
02:15:38 <mauke> (good luck with that)
02:15:40 <Botje> Matt`: what do you want to do?
02:15:41 <mux> ascii characters whose values is greather than 127 is an oxymoron
02:16:12 <Matt`> I would retort with a cheap joke but I shall resist the temptation :)
02:16:28 <Matt`> I wnat it forhandling characters such as the e-acute and such
02:16:33 <Matt`> accented characters
02:16:35 <shachaf> Matt`: That's not ASCII.
02:16:42 <mauke> define "handle"
02:16:51 <mux> that is most likely iso-8859-1 or iso-8859-15 you're talking about
02:17:11 <mauke> heresy, the one true encoding is utf-8
02:17:12 <shachaf> Those characters are part of Latin-1 HEY WHAT DID I DO #HASKELL STOP IT WHAT DID I DO
02:17:14 <Matt`> extended ascii, perhaps?
02:17:24 <mauke> Matt`: everything is "extended ascii"
02:17:32 <mauke> well, most things are an extension of ascii
02:17:35 <shachaf> Matt`: EBCDIC?
02:17:36 <mauke> that doesn't really help you
02:17:40 <shachaf> s/Matt`/mauke/
02:17:48 <Matt`> you said, doesn'thelp at all
02:17:53 <Matt`> one at a time, please
02:17:57 <mauke> shachaf: ah, the data encryption standard invented by IBM?
02:18:08 <mux> lol
02:18:17 <Matt`> looks like I'm talking to robots
02:18:19 <shachaf> @remember mauke <shachaf> mauke: EBCDIC? <mauke> shachaf: ah, the data encryption standard invented by IBM?
02:18:20 <lambdabot> Nice!
02:18:24 <shachaf> Wow.
02:18:31 <shachaf> People sure are irritable today.
02:18:36 * mux nods
02:18:42 <mux> we were even being helpful
02:19:38 <alistra> opqdonut: what will you say monads are like on your lecture?
02:19:52 <opqdonut> I'll say they're useful :)
02:20:01 <alistra> space suit, burrito, box?
02:20:14 <opqdonut> I think I'll start with giving people some hands-on experience with IO and State
02:20:35 <alistra> just ask them to implement something that involves passing 8 arguments around
02:20:45 <alistra> and they'll understand why they need State
02:20:54 <mux> that's a case for Reader, rather
02:21:16 <alistra> pass around and change, mr smart guy
02:21:30 <mux> yeah, people sure are irritable today :-P
02:46:12 <Brax> coincidentally, i am just looking at IO and State
02:46:31 <alistra> Maybe is a monad too
02:50:19 <funk> hello?
02:50:55 <funk> haskell people?
02:52:01 <Cale> hello
02:52:02 <alistra> wrong number
02:53:27 <Brax> i have two functions that do the same thing, one using IO, the other using state...f_IO :: (Ord a, Num b, Num a) => a -> IO b...f _ST:: (Ord a1, Num a, Num a1) => a1 -> a
02:53:34 <Brax> i let ghci infer the type declarations
02:53:55 <Brax> is there any particular reason why b is chosen in the first one?
02:54:16 <Brax> because it is a parameter type or whatever you call it to IO?
02:54:27 <alistra> you mean the unique names of type variables?
02:54:33 <Brax> just wondering how the variables are picked
02:54:55 <Brax> y
02:55:59 <Brax> or could it be different for another session or based on the ghci version
02:56:43 <Philonous_> Brax:  From experience it seems that ghc tries to pick the names that are chosen in the type declaration
03:02:29 <Brax> philonous_: like i said, i didn't give any
03:02:32 <Brax> or what do you mean
03:04:41 <Philonous_> Brax:  I meant the variables used where IO is defined
03:05:26 <jessopher_> it just passes along the names of ancestors if there is no signature... i think
03:06:13 <jessopher_> unless there is a conflict, in which case it uses varN
03:08:47 <WINDBAG118> whats this room all about
03:08:48 <jessopher_> so if foo :: a -> b, and bar :: x -> a baz = foo . bar would be something like baz :: a -> a1
03:09:04 <WINDBAG118> yeah because...
03:09:09 <WINDBAG118> that will make you happy
03:09:14 <WINDBAG118> *smh
03:09:45 <jessopher_> hi
03:10:18 <Brax> well, it uses newIORef, readIORef, writeIORef or the ST versions respectively, ghci says they are all defined with "a" *shrug*
03:10:49 <WINDBAG118> and what does that do for you?
03:11:03 <hebz0rl> hi, can i time a function in ghci? like time myfunction [1..1000]?
03:11:12 <Axman6> hebz0rl: :set -S i think
03:11:20 <Axman6> :help will probably tell you how
03:11:48 <hebz0rl> Axman6, thx
03:11:49 <WINDBAG118> how does this et - S shit service you
03:11:53 <jessopher_> well thats how I would imagine it to work, if not, then its probably magic, its layer upon layer of type system modifications all interacting and trying to be smart about things in different ways
03:12:05 <Brax> :set +s
03:12:07 <hebz0rl> Axman6, ah its +s
03:12:17 <hebz0rl> Brax, yeah thx
03:12:26 <WINDBAG118> yeah..it makes you feel so msart
03:12:31 <WINDBAG118> smart also
03:12:32 <Axman6> @google Haskell
03:12:33 <lambdabot> http://haskell.org/
03:12:38 <Axman6> WINDBAG118: ^^
03:12:55 <Brax> is it a windbag bot?
03:12:59 <jessopher_> WINDBAG118: are you 118 years old?
03:13:21 <WINDBAG118> lol no I was in another room with the nick so it made me this one automatically
03:13:52 <jessopher_> no i think windbag is something else
03:14:45 <WINDBAG118> something else?
03:14:53 <jessopher_> something other than a bot
03:15:02 <WINDBAG118> I dont know why it puts a smiley face next to my name like that
03:15:04 <Axman6> a lost soul
03:15:14 <WINDBAG118> you wish
03:15:53 <Axman6> WINDBAG118: do you actually want to know about haskell? or would you just prefer the ops to remove you?
03:16:07 <WINDBAG118> they always remove me no matter what I say
03:16:16 <Axman6> i mean, we're more than happy to teach you, if you're interested in programming in haskell
03:16:36 <Axman6> but if you're just going to make noise, then they'll be happy to kick you
03:16:38 <WINDBAG118> I didnt know what haskell was until I googled it just now
03:17:02 <WINDBAG118> what I say is better than typing out haskell in the open room
03:17:11 <WINDBAG118> really what does THAT do
03:17:16 <Axman6> no, not really
03:17:24 <WINDBAG118> besides make your head get bigger
03:17:34 <Axman6> @where ops
03:17:34 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
03:17:41 <jessopher_> WINDBAG118: well this is a technical chatroom, most things that arent about the topic are.. off topic
03:18:13 <WINDBAG118> Ill find something else
03:19:09 * jessopher_ shrugs
03:19:25 <Brax> random chat hopping
03:19:58 <Axman6> we often get people in here who came here because it's one of the top channels when sorted by size
03:20:13 <jessopher_> not even freenode is immune to the ocassional wanderlust
03:20:33 <jessopher_> Axman6 that makes sense
03:21:25 <Axman6> when I used to hang in #latex, they used to get lots of people looking for sex. it was pretty fun to go along with it too
03:21:33 <jessopher_> haha
03:22:18 <jessopher_> at least they are being safe about it
03:22:35 <Axman6> urgh, i hate it when you're installing something, and it installs half the packages on hackage, only to fail to compile with the package you wanted >_<
03:24:10 <Brax> one of the biggest, really? i wouldn't have thought
03:24:19 <jessopher_> is there a cabal-uninstall yet?
03:24:23 <Axman6> it's got over 800 users last time i heard
03:24:52 <Brax> i wouldn't think programming channels could top a list of everything
03:25:12 <jessopher_> well this is a uniquely programming slanted irc network
03:25:25 <Brax> was just about to ask, that makes sense, then
03:26:03 <Brax> and less sense for windbag to search on freenode
03:27:40 <jessopher_> I don't think it was a very intentional search. More like searching for your keys in the garbage disposal
03:36:49 <Blkt> good day everyone
03:39:33 <nataraj> haskell's qt binding, how good is it?
03:47:23 <gienah> nataraj: it works in simple examples, which is all I have done with it
03:50:34 <Brax> if i have "env <- get", is the type of env "s"? get :: m s
03:51:03 <Axman6> whatever the state of the state in your State monad is
03:51:27 <Axman6> s/state/type/ (the first one)
03:51:42 <Axman6> so if you have State Int a, then the s will be Int
03:52:20 <mauke> no, env will be an Int
03:52:23 <geheimdienst> brax: yup. and s might be String or whatever
03:52:30 <mauke> and m will be State Int
03:52:38 <geheimdienst> :t State
03:52:38 <nataraj> elementary question, is Haskell interpreted language like python or ruby?
03:52:39 <mauke> oh, I'm stupid
03:52:39 <lambdabot> Not in scope: data constructor `State'
03:52:49 <mauke> nataraj: there are no interpreted languages
03:52:57 <mauke> "interpreted" is a property of the implementation, not the spec
03:53:10 <Axman6> nataraj: GHC can interpret or compile haskell
03:53:18 <geheimdienst> nataraj: no, it's (usually) compiled. there is a repl available though, which is called ghci
03:53:24 <Axman6> > 2 + 2 -- obviously we can interpret Haskell
03:53:24 <lambdabot>   4
03:54:06 <nataraj> Prelude> ?
03:54:09 <Brax> sloppily said, the "<-" always removes the m from the right side, correct?
03:54:14 <Brax> or too general?
03:54:15 <mauke> Brax: yes
03:54:54 <mauke> in 「x <- y」, 「y :: m a」 and 「x :: a」
03:55:02 <Brax> btw, i was confused by "env s" because i thought s was a state...
03:55:18 <Brax> in my code
03:55:25 <nataraj> presently on arm-linux with Qt gui on /dev/fb0
03:55:56 <Brax> asking too quickly before reading :D
03:56:41 <Brax> ok, so that's always the case, wasn't sure if "<-" could be used some other way
03:57:41 <nataraj> Prelude> print 4*"nataraj"
03:57:49 <nataraj> was expecting it work like ruby
03:58:00 <mauke> nataraj: er, you can't multiply 'print 4' by a string
03:58:02 <Brax> not easy (possible?) to hoogle for <-
03:58:29 <mauke> Brax: it's syntax, not an operator
03:58:41 <jessopher_> you should hoogle for >>= though... that is bound to throw you for a loop
03:58:44 <Brax> or google :p
03:59:00 <mauke> Brax: do { x <- y; ... } is syntactic sugar for y >>= \x -> do { ...}
03:59:24 <nataraj> " Possible fix: add an instance declaration for (Num (IO ()))"
04:00:03 <Brax> ah, right
04:00:08 <jessopher_> nataraj: * binds loser than application, so its read as (print 4)*("whatever")
04:00:21 <jessopher_> which is nonsense
04:00:29 <Brax> if it's specifically for bind, then it's clear
04:00:47 <Brax> then again, do-notation is specifically for monads, i think
04:00:59 <Brax> so that follows
04:01:04 <jessopher_> which isnt very specific at all :P
04:01:30 <jessopher_> but its true
04:02:30 <geheimdienst> brax: you have a good grasp on "<-" if you just say "inside a do block, it unwraps things". if you want to read more, check out "do notation". there's a section in typeclassopedia
04:02:34 <geheimdienst> @where typeclassopedia
04:02:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:02:55 <geheimdienst> grmbl ... i meant this http://haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
04:03:01 <Brax> yeah, i read it as unwrapping
04:03:11 <Axman6> so, i'm watching the Yesod screen casts, and it seems pretty magic and cool
04:03:48 <geheimdienst> Axman6: and revolutionary? magical and revolutionary?
04:04:00 <hvr> jfyi, as I assume some here might be able to provide some insights: http://stackoverflow.com/questions/8241821/how-to-properly-use-the-hsopenssl-api-to-implement-a-tls-server
04:04:03 <Brax> oh, that looks nice, thanks!
04:04:09 <Axman6> not sure, seems a lot like what you'd do with ruby etc, but more haskelly
04:04:16 <Brax> ah, monad reader
04:44:16 <nataraj> any port to arm-linux?
04:46:01 <nataraj> i work on kinda embedded gadget based on Arm core
04:46:36 <nataraj> would like to know if Haskell is suited on these 200Mhz ones
04:46:36 <d-snp> hey nataraj, http://hackage.haskell.org/trac/ghc/wiki/Platforms
04:46:41 <gienah> nataraj: on gentoo yes: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-lang/ghc/ghc-7.2.2.ebuild
04:46:42 <Axman6> there's some work that's been done for an ARM port of GHC for use on the iPhone
04:46:51 <d-snp> oO 200mhz is a bit slow..
04:47:11 <d-snp> should work ofcourse
04:47:40 <Axman6> nataraj: depends on what apps you're writing.
04:47:51 <nataraj> does haskell generate native binaries or works on thingy like jvm?
04:48:08 <Axman6> it uses native binaries
04:48:09 <stianhj> nataraj: native
04:48:39 <d-snp> hey guys, I need to introduce some state to my app, it has multiple threads that produce and consume from one thread, is there a good introductory article for this sort of thing?
04:48:41 <nataraj> some way to get the asm listing?
04:49:13 <d-snp> .. the asm listing?
04:49:13 <nataraj> "Building haskell-src-1.0.1.4"
04:49:27 <Axman6> nataraj: it won't make much sense at all
04:49:30 <stianhj> you can use haskell on arduino.. is there a step between haskell code and arduino native code?
04:50:03 <d-snp> arduino is just arm, what do you mean with a step between?
04:50:05 <Axman6> nataraj: before you start asking questions like this, you should probably start learning and using haskell, to see what it's actually like
04:50:10 <d-snp> haskell compiles to native code
04:50:11 <Axman6> arduino is not ARM
04:50:14 <d-snp> it's not?
04:50:20 <Axman6> Arduino uses AVR
04:50:35 <Axman6> they're working on an ARM board though
04:50:52 <Axman6> d-snp: look at using a Chan to pass data between threads btw
04:51:39 <nataraj> on arm, it would make a lot of sense, to check out how much it adheres to ATPCS
04:52:06 <Axman6> ATPCS?
04:52:24 <nataraj> Arm Thumb procedure call standard
04:52:57 <nataraj> freepascal does give an optional assembler listing
04:53:07 <Axman6> i believe GHC doesn't use actual calls to procedures, unless calling a C function, or if you've exported a Haskell function to C
04:53:30 <Axman6> nataraj: you seem to have no idea what haskell is actually like. it is nothing like C or Pascal
04:53:45 <nataraj> hmmm, more like scheme perhaps?
04:53:58 <jessopher_> more like, but not very close in general
04:54:10 <nataraj> done something on scheme
04:54:24 <nataraj> lambda calculus
04:54:57 <nataraj> need to make sure i get things done on Arm linux
04:55:01 <jessopher_> its something like ML
04:55:52 <d-snp> why would you want to use haskell on an embedded device if you don't know haskell yet?
04:55:58 <nataraj> cos, i work for somebody
04:56:16 <jessopher_> lucky
04:56:20 <d-snp> :P
04:56:39 <d-snp> not many employers actually want their employees to use haskell :P
04:57:36 <nataraj> the company got some results using C++ and Qt, so least resistance path is to try Haskell and Qt
04:58:02 <nataraj> i like it the functional way
04:58:22 <Jafet> Unfortunately, Qt is dysfunctional
04:59:07 <Brax> that's a nice opposite
05:00:02 <nataraj> any other suggestion for a Gui on framebuffer or directfb with Haskell binding?
05:01:01 <nataraj> i used to have a good time with fxruby on Arm (ruby bindings for Foxlib toolkit) but that was on X
05:01:54 <nataraj> neat stuff though, a true RAD
05:02:14 <d-snp> you ran ruby on 200mhz arm devices?
05:02:19 <nataraj> yep
05:02:20 <d-snp> wasn't it like very slow? :P
05:02:31 <nataraj> nope, decent speed
05:02:34 <d-snp> cool
05:02:42 <d-snp> on mri?
05:02:50 <nataraj> but used it for mainly prototyping
05:02:59 <nataraj> mri? what is that?
05:03:12 <d-snp> matz ruby interpreter, the default ruby interpreter
05:03:33 <d-snp> (as opposed to ree, jruby, tinyruby or something)
05:03:34 <nataraj> ruby somefile.rb
05:03:51 <nataraj> Include Fox
05:04:02 <nataraj> this was like it
05:04:04 <d-snp> k
05:04:07 <d-snp> cool :)
05:05:10 <nataraj> but then Fox didn't work on /dev/fb0, had to dump fxruby for Qt
05:06:53 <nataraj> "Configuring the cabal-install-0.10.2 package failed"
05:07:17 <nataraj> seems lots of dependencies
05:07:44 <carpi> could someone please tell me why does this not work "map 4 $ map (*) [1..10]
05:08:02 <Botje> map expects a function, you're giving it 4
05:08:12 <Botje> try giving it map (\f -> f 4)
05:08:39 <nataraj> may i know what kinda apps being built using Haskell? server side?
05:09:08 <jessopher_> all kinds
05:09:52 <carpi> Botje: thx that worked. silly me.. what was i thinking.. giving an Int to a function expecting another fucntion. my bad
05:09:57 <nataraj> i ll be back
05:10:06 <Phyx-> :t map ($4)
05:10:07 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
05:10:27 <jessopher_> if you want to have a look at libraries and programs written in haskell, take a look at hackage.haskell.org/
05:10:31 <jessopher_> and he left
05:10:54 <d-snp> carpi: map ($ 4) $ map (*) [1..10]
05:10:56 <d-snp> oh shit
05:10:58 <d-snp> someone beat me :(
05:12:02 <carpi> what does prepending '$' to 4 do?
05:12:10 <d-snp> no, $ is a function
05:12:17 <d-snp> it's the function application function :P
05:12:19 <ion> ($ 4) is sugar for (\x -> x $ 4).
05:12:28 <Phyx-> map (($4) . (*)) would be better too
05:12:49 <carpi> you mean it converts 4 to a function?
05:12:52 <Phyx-> and would make a weird emoticon
05:12:55 <carpi> i know im wrong somehwre
05:13:18 <ion> @src ($)
05:13:18 <lambdabot> f $ x = f x
05:13:21 <d-snp> :t $
05:13:22 <lambdabot> parse error on input `$'
05:13:25 <d-snp> oh
05:13:32 <carpi> :t ($)
05:13:33 <lambdabot> forall a b. (a -> b) -> a -> b
05:13:36 <carpi> :)
05:13:57 <Jafet> > 4("ever")
05:13:58 <lambdabot>   4
05:14:01 <ion> Given that ($ 4) means (\f -> f $ 4) and the definition of (f $ x) is (f x), it means (\f -> f 4).
05:14:14 <pordan30_> yes, ($ 4) takes the value four and constructs the function λ x . x 4
05:14:20 <Phyx-> > 4 4
05:14:21 <lambdabot>   4
05:14:28 <Phyx-> lol, well, that 4 isn't a 4
05:14:36 <Phyx-> :t 4
05:14:38 <lambdabot> forall t. (Num t) => t
05:14:47 <Phyx-> *blinks*
05:14:48 <earthy> :t 4 4
05:14:50 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
05:15:05 <d-snp> oO
05:15:08 <jessopher_> this is magic
05:15:10 <d-snp> wait what? :D
05:15:11 <Phyx-> since when is there a num instance for (a -> b)
05:15:27 <jessopher_> ohh i see
05:15:34 <ion> “We have always been here.” – Num instance for (a → b).
05:15:43 <d-snp> > (4 4) 1
05:15:49 <lambdabot>   4
05:15:51 <d-snp> hm
05:15:58 <d-snp> > (5 4) 1
05:16:02 <lambdabot>   5
05:16:05 <d-snp> oh sorry, I'm experimenting
05:16:06 <Phyx-> seems it's just const
05:16:18 <ion> > (sin^2 + cos^2) 1
05:16:19 <lambdabot>   1.0
05:16:24 * earthy nods
05:16:29 <Phyx-> @src Num (a -> b)
05:16:30 <lambdabot> Source not found. Just try something else.
05:16:33 <Phyx-> @src Num Int
05:16:34 <lambdabot> Source not found.
05:16:39 <Phyx-> @src Int Num
05:16:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
05:16:48 <Phyx-> always forget how that command goes
05:17:21 <Jafet> > fix 1
05:17:22 <lambdabot>   1
05:17:33 <jessopher_> hah
05:17:56 <Jafet> @src [] Monad
05:17:56 <lambdabot> Source not found. My mind is going. I can feel it.
05:18:03 <Jafet> @src [] (>>=)
05:18:04 <lambdabot> xs >>= f     = concatMap f xs
05:18:12 <ion> > (4 * atan) 1
05:18:13 <lambdabot>   3.141592653589793
05:18:57 <jessopher_> @src (a -> b) fromIntegral
05:18:58 <lambdabot> Source not found. Do you think like you type?
05:19:14 <Jafet> @hackage vector-space
05:19:14 <lambdabot> http://hackage.haskell.org/package/vector-space
05:19:20 <Jafet> fromInteger = const
05:19:34 <Jafet> Or fromInteger . const
05:20:40 <d-snp> :t <$>
05:20:42 <lambdabot> parse error on input `<$>'
05:20:48 <d-snp> hm
05:20:51 <Phyx-> :t (<$>)
05:20:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:22:18 <d-snp> :t (< >)
05:22:20 <lambdabot> parse error on input `>'
05:22:26 <d-snp> ok last experiment :P
05:22:26 <jessopher_> lol
05:22:51 <d-snp> I was hoping it would say the same as (<$>), but that was naive :P
05:25:02 <jessopher_> > map 2 [undefined,undefined,undefined]
05:25:03 <lambdabot>   [2,2,2]
05:26:09 <alistra> >map 1 [2]
05:26:13 <alistra> > map 1 [2]
05:26:15 <lambdabot>   [1]
05:26:27 <alistra> > 1 :: Int -> Int
05:26:28 <lambdabot>   *Exception: show: No overloading for function
05:26:38 <alistra> > True :: Int -> Int
05:26:39 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Int'
05:26:39 <lambdabot>         again...
05:28:14 <alistra> @instances Num
05:28:17 <lambdabot> Double, Float, Int, Integer
05:28:25 <jessopher_> liar!
05:28:52 <Phyx-> > 1 :: (Num t, Num (t -> t)) => t
05:28:54 <lambdabot>   1
05:30:14 <mauke> > 1 :: (Num t, Num (1 -> t)) => t
05:30:15 <lambdabot>   1
05:30:33 <alistra> > 1 :: (Num t, Num (1 -> t)) => t -> t
05:30:34 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
05:30:34 <lambdabot>    arising from a use of `...
05:31:00 <jessopher_> 1 is a type?
05:31:08 <Philonous_> A value
05:31:17 <jessopher_> but its in the type signature
05:31:26 <ion> No, it’s on the other side of the ::
05:31:35 <ion> Whoops, i missed that.
05:31:39 * mauke trollface.jpg
05:31:40 <Philonous_> Yes
05:31:44 <jessopher_> its on all sides
05:31:55 <jessopher_> except top and bottom
05:32:03 <Phyx-> wtf
05:32:06 <Phyx-> how
05:32:11 <jessopher_> i dunno
05:32:15 <alistra> > 1 :: 1
05:32:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
05:32:17 <lambdabot>    arising from the literal...
05:32:17 <Phyx-> lambdabot: stop being freaky!
05:32:40 <jessopher_> its a synonym for unit?
05:32:52 <jessopher_> > () :: 1
05:32:53 <alistra> monads are like that
05:32:53 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
05:32:53 <lambdabot>         against inferred t...
05:33:33 <Phyx-> > 1 :: (Num 1, Num (1 -> 1)) => 1
05:33:34 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
05:33:34 <lambdabot>    arising from an expressi...
05:33:45 <Phyx-> > 1 :: (Num t, Num (t -> 1)) => 1
05:33:46 <lambdabot>   Ambiguous constraint `GHC.Num.Num t'
05:33:46 <lambdabot>      At least one of the forall'd type...
05:33:52 <Phyx-> > 1 :: (Num t, Num (t -> 1)) => t
05:33:54 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
05:33:54 <lambdabot>    arising from an expressi...
05:33:56 <Philonous_> @type undefined :: 1
05:33:57 <ion> @type GHC.Generics.Unit :: 1
05:33:58 <lambdabot> Unit
05:33:58 <lambdabot> Unit
05:34:30 <jessopher_> oh generics, thats explains atleast why im confused
05:35:15 <Philonous_> Sooner or later the values will brake through the colon anyway.
05:35:37 <alistra> haha, he said colon
05:36:23 <Philonous_> break even
05:37:06 <Phyx-> jessopher_: no, i'm still confused
05:37:22 <Phyx-> i'm more confused about the fact that it's valid for a type to begin with a number
05:37:34 <jessopher_> i am too, but i avoid generics on purpose, so that justifies my confusion
05:39:54 <absence> "somelist >>= \x -> guard (f x) >> return x" <- is there some alternative to guard that would let me write "somelist >>= guardalternative f"?
05:40:35 <alistra>  >>= (guard . f)
05:40:57 <alistra> @type guard
05:40:58 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
05:41:07 <absence> alistra: guard returns ()
05:41:18 <absence> so i need >> return x
05:41:42 <mauke> @pl somelist >>= \x -> guard (f x) >> return x
05:41:42 <lambdabot> ap ((>>) . guard . f) return =<< somelist
05:42:22 <mauke> absence: [ x | x <- somelist, f x ]
05:42:23 <alistra> @src guard
05:42:24 <lambdabot> guard True  =  return ()
05:42:24 <lambdabot> guard False =  mzero
05:43:35 <absence> mauke: thanks, i know of both list comprehension and pointfree. i'm wondering if there is a library function that does something similar to guard
05:43:59 <mauke> meh, just define it yourself
05:44:23 <absence> mauke: if there is one in the library, i wouldn't want to make another one :)
05:45:07 <alistra> @hoogle MonadPlus m => (a -> Bool) -> (a -> b) -> a -> b
05:45:08 <lambdabot> Did you mean: (a -> Bool) -> (a -> b) -> a -> b
05:45:09 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:45:09 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
05:45:31 <alistra> @hoogle MonadPlus m => (a -> Bool) -> (a -> b) -> a -> m b
05:45:33 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:45:33 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
05:45:33 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
05:47:02 <jessopher_> there is always refactoring later if/when you find it
05:47:46 <alistra> absence: make it yourself and send a patch to upstream, and then cry here that nobody applied it
05:47:51 <jessopher_> reinventing the wheel is ok if you dont know where the wheel is
05:48:57 <ExFalso> cabal: dependencies conflict: DiplomacyCommon-0.1 requires parsec ==3.1.2 however parsec-3.1.2 was excluded because DiplomacyCommon-0.1 requires parsec ==2.1.0.1
05:48:59 <ExFalso> any ideas?
05:49:33 <ExFalso> (tried rming .ghc and .cabal)
05:49:51 <dcoutts> ExFalso: it's a genuine conflict
05:49:59 <dcoutts> well, sort-of
05:50:13 <ExFalso> DiplomacyCommon-0.1 was built with -any
05:50:32 <ExFalso> and this is a different package depending on it
05:50:37 <dcoutts> it indirectly depends on two versions of the same package, cabal cannot cope with that
05:50:51 <dcoutts> since it's trying to find solutions where there's a single version of each package
05:50:56 <kosmikus> it will soon, hopefully
05:51:49 <ExFalso> i tried setting the parsec version manually
05:52:00 <ExFalso> (with == in both packages)
05:52:13 <ExFalso> i also tried >3.0
05:54:08 <dcoutts> ExFalso: you want to try to get your package and its deps using one version of parsec, rather than two
05:54:34 <ExFalso> dcoutts: i set it to -any in both
05:56:02 <ExFalso> not sure what else i can do
05:56:18 <absence> "mguard f p = if f p then return p else mzero" does the trick
05:56:39 <ExFalso> btw it works on one machine and not on another
05:57:07 <alistra> absence: using if, like imperative animals
05:57:11 <alistra> maybe use a variable too
06:05:04 <absence> alistra: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#mfilter for comparison :P
06:12:23 * hackagebot hakyll 3.2.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.2.0 (JasperVanDerJeugt)
06:42:23 * hackagebot OpenCL 1.0.2.2 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.2.2 (LuisCabellos)
06:42:30 <EvanR-work> > filter id [True,False,True,True,False]
06:42:31 <lambdabot>   [True,True,True]
06:43:45 <alistra> mfilter id  [True,False,True,True,False]
06:43:48 <alistra> > mfilter id  [True,False,True,True,False]
06:43:49 <lambdabot>   Not in scope: `mfilter'
06:44:03 <EvanR-work> > (count . filter id) [True,False,True,True,False]
06:44:04 <lambdabot>   Not in scope: `count'
06:44:08 <EvanR-work> > (length . filter id) [True,False,True,True,False]
06:44:09 <lambdabot>   3
06:48:46 <raph_ael> hi, is there a specific chan to talk about install from cabal or is it here ?
06:51:12 <leoncamel> raph_ael: you can ask here.
06:52:17 <raph_ael> leoncamel: thanks
06:53:34 <carpi> why is it that right folds can be used on infinite lists whereas left folds cannot?
06:53:42 <raph_ael> i'm trying to install the yi editor either from cabal packages and sources and get this : http://paste.lisp.org/display/126035
06:54:16 <dcoutts> raph_ael: what does cabal --version say?
06:54:57 <raph_ael> cabal-install version 0.8.0 / using version 1.8.0.2 of the Cabal library
06:55:04 <dcoutts> raph_ael:  http://www.haskell.org/cabal/FAQ.html#internal-error-invalid-install-plan
06:55:22 <raph_ael> dcoutts: thanks
06:55:28 <aninhumer> carpi: the first part of a left fold is to fold the deepest element with the second deepest, an infinite list has no such elements
06:55:49 <flux> carpi, look at the pretty pictures at: http://www.haskell.org/haskellwiki/Fold
06:58:16 <carpi> aninhumer: you mean to say internally the left fold actually starts at the deepest element.. in other words the end of the list?
06:59:12 <Axman6> > foldl (+) x [a,b,c,d,e,f] :: Expr
06:59:13 <lambdabot>   x + a + b + c + d + e + f
06:59:18 <Axman6> bleh
06:59:22 <EvanR-work> lol
06:59:25 <Axman6> > foldr (+) x [a,b,c,d,e,f] :: Expr
06:59:26 <lambdabot>   a + (b + (c + (d + (e + (f + x)))))
07:00:03 <Axman6> @src foldl
07:00:04 <lambdabot> foldl f z []     = z
07:00:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:00:07 <Axman6> @src foldr
07:00:07 <lambdabot> foldr f z []     = z
07:00:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:00:39 <Axman6> carpi: look at how f is used in the two definitions
07:01:38 <Axman6> in foldl, we always recurse, in foldr, we only recurse if f uses its second argument
07:10:06 <Phyx-> is there a library for haskell for sparse matrices?
07:10:32 <carpi> Axman6: so with foldl.. "foldl f z [] = z" will never be pattern matched and so will go on forever?
07:10:42 <Axman6> yes
07:11:07 <Axman6> and there, z is the entire computation you've been calculating
07:11:31 <snappy> 1
07:11:53 <Axman6> 0
07:12:26 <carpi> Axman6: then this must be true for every function that does recursion, whose edge condition depends on an empty list?
07:12:54 <Axman6> obviously not, since foldr works fine
07:13:26 <Axman6> > foldr const 0 [1..]
07:13:27 <lambdabot>   1
07:14:31 <carpi> Axman6: true but foldr's edge condition will always be matched. infinite list or not
07:14:52 <Axman6> what do you mean by edge condition?
07:15:11 <carpi> "foldr f z [] = z"
07:15:39 <Axman6> why will that always be matched in an infinite list?
07:15:55 <Axman6> if it's infinite, there is, by definition, no []
07:16:06 <Axman6> so foldr f z [] can never be matched
07:16:33 <carpi> Axman6: if its infinite.. there is an edge condition .. only if you were to traverse to the beginning..which is exactly what foldr does
07:18:00 <mauke> ?!
07:18:00 <lambdabot> Maybe you meant: . ? @ v
07:18:11 <Axman6> > let takeUntil f xs = foldr (\y ys -> if f y then [] else ys) [] xs in takeUntil (==7) [1..10]
07:18:12 <lambdabot>   []
07:18:15 <Axman6> hmm
07:18:27 <Axman6> > let takeUntil f xs = foldr (\y ys -> if f y then ys else []) [] xs in takeUntil (==7) [1..10]
07:18:28 <lambdabot>   []
07:18:31 <Axman6> >_<
07:18:46 <Axman6> > let takeUntil f xs = foldr (\y ys -> if f y then [] else y:ys) [] xs in takeUntil (==7) [1..10]
07:18:47 <lambdabot>   [1,2,3,4,5,6]
07:19:03 <Axman6> > let takeUntil f xs = foldr (\y ys -> if f y then [] else y:ys) [] xs in takeUntil (==7) [1..]
07:19:04 <lambdabot>   [1,2,3,4,5,6]
07:33:26 <EvanR-work> > (length . filter id) [True,False,True]
07:33:27 <lambdabot>   2
07:33:39 <EvanR-work> > (sum . map fromEnum) [True,False,True]
07:33:41 <lambdabot>   2
07:34:03 <EvanR-work> > True + False
07:34:04 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:34:04 <lambdabot>    arising from a use of `GHC.N...
07:38:55 <magicman> @hoogle (a -> Maybe a) -> a -> [a]
07:38:56 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:38:56 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:38:56 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:39:23 <magicman> :t unfoldr
07:39:25 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:40:51 <EvanR-work> :t listToMaybe
07:40:52 <lambdabot> forall a. [a] -> Maybe a
07:41:48 <EvanR-work> magicman: use unfoldr and return (x,x) instead of x
07:42:12 <magicman> Yeah, that's what I figured. Thanks :)
07:42:53 <EvanR-work> (\x -> (x,x)) . f ;)
07:45:01 <Axman6> Just . join (,) . f
07:45:35 <EvanR-work> :t join
07:45:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:45:43 <magicman> @type \f -> fmap (join (,)) . f
07:45:45 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> f1 (f (a, a))
07:46:13 <magicman> @type \f -> fmap (join (,)) . f :: (a -> Maybe a) -> (a -> Maybe (a,a))
07:46:15 <lambdabot>     Couldn't match expected type `Maybe (a, a)'
07:46:15 <lambdabot>            against inferred type `(a1, a1)'
07:46:15 <lambdabot>     In the first argument of `join', namely `(,)'
07:46:20 <magicman> Darn.
07:47:29 <sebfisch> I'm looking for a package but forgot it's name.
07:49:18 <sebfisch> What packages do you recommend for writing a book in markdown syntax, with web-based commenting on each paragraph like RWH used?
07:49:55 <sebfisch> I found doc-review but think I remember something else that had pandoc integrated.
07:53:21 <dylex> magicman: perhaps :: binds more tightly than you think
07:53:37 <dylex> @type (\f -> fmap (join (,)) . f) :: (a -> Maybe a) -> (a -> Maybe (a,a))
07:53:38 <lambdabot> forall a. (a -> Maybe a) -> a -> Maybe (a, a)
07:53:42 <magicman> Yeah, probably. The code is right, afaics.
07:54:10 <sipa> > (\x -> (x,x)) 5 :: (Int,Int)
07:54:11 <lambdabot>   (5,5)
07:54:21 <acowley> How can I figure out where a linker flag is coming from in a cabal-driven build? I have a '-Lbuild' flag coming frome somewhere that gives me a linker warning on every build because the directory does not exist.
07:54:26 <alistra> @type 1 :: 1
07:54:28 <lambdabot>     No instance for (Num Unit)
07:54:28 <lambdabot>       arising from the literal `1' at <interactive>:1:0
07:54:28 <lambdabot>     Possible fix: add an instance declaration for (Num Unit)
07:54:39 <magicman> @pl \f x -> fmap (\y -> (y,y)) (f x)
07:54:40 <sipa> > ((\x -> (x,x)) 5) :: (Int,Int)
07:54:40 <lambdabot> (fmap (join (,)) .)
07:54:41 <lambdabot>   (5,5)
07:54:43 <magicman> Or that <_<
07:54:47 <sipa> > (\x -> (x,x)) (5 :: (Int,Int))
07:54:48 <lambdabot>   ((5,5),(5,5))
07:54:50 <alistra> @type undefined :: 1
07:54:52 <lambdabot> Unit
07:54:58 <Axman6> :t undefined :: 2
07:54:59 <alistra> @type undefined :: 2
07:54:59 <lambdabot> Only unit numeric type pattern is valid
07:55:00 <lambdabot> Only unit numeric type pattern is valid
07:55:07 <Axman6> o.O
07:55:11 <Axman6> :t undefined :: 0
07:55:12 <alistra> ah
07:55:12 <lambdabot> Only unit numeric type pattern is valid
07:55:22 <alistra> it's for n+k patterns?
07:55:28 <Axman6> i doubt it
07:56:02 <alistra> > let f (n+1) = f n in f
07:56:03 <lambdabot>   <no location info>: Parse error in pattern
07:56:29 <magicman> Hah.
07:57:01 <acowley> Ah! I think it's coming from GLFW-b.
07:57:24 <alistra> :k 1
07:57:26 <lambdabot> *
07:58:00 <sipa> > let a @@ b = (a,b) in 5 :: Int @@ 4 :: Double
07:58:01 <lambdabot>   Only unit numeric type pattern is valid
07:58:15 <sipa> > let a @@ b = (a,b) in (5 :: Int) @@ (4 :: Double)
07:58:16 <lambdabot>   (5,4.0)
07:58:24 <sipa> > let a @@ b = (a,b) in 5 :: Int @@ 4
07:58:25 <lambdabot>   Only unit numeric type pattern is valid
07:59:36 <ash_> so… i heard ghc 7.4 has an arm backend? anyone know anything about that? I am in the process of checking it out to see, just thought i'd ask in here as well
08:00:46 <acowley> ash_: I think it's more that 7.4 can take advantage of LLVM 3.0's ARM support.
08:00:52 <acowley> but LLVM 3 isn't out yet afaik
08:01:06 <alistra> fibonacci series, now on your smartphone
08:02:22 <acowley> Although I think there are still issues in that GHC can't cross-compile and the RTS isn't ready for ARM (though hopefully I'm wrong about that last one).
08:04:57 <tomprince> llvm 3 is on rc4 or so.
08:05:31 <ash_> ya, llvm-3.0's release date is in like 7 days, so it will probably be out before 7.4 is finialized
08:06:46 <ash_> i wonder what level of arm support they are targeting, i think it would be interesting if you could use the arm backend on bare metal
08:09:21 <acowley> I think it will be a bit frustrating having to compile on the target architecture, and if the RTS isn't ready yet then I'm not sure where we are.
08:09:53 <thalll> @hoogle [[a]] -> [a]
08:09:54 <lambdabot> Prelude concat :: [[a]] -> [a]
08:09:54 <lambdabot> Data.List concat :: [[a]] -> [a]
08:09:54 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
08:10:13 <acowley> I think github is my favorite technology of the past few years
08:10:15 <ash_> i was toying with the idea before, i had the ghc dump the llvm-ir, then compiled that to arm, but it won't link, since its missing lots of stuff from the RTS
08:10:30 <mike-burns> acowley: That same thought occured to me the other day.
08:12:23 <acowley> This is kind of weird
08:12:36 <acowley> I think I fixed the linker warning due to GLFW-b
08:12:49 <ash_> I was thinking about just trying to implement the bits of the RTS I am missing, but it occurred to me there are a number of things that would be needed if you really wanted to run the ghc on bare metal arm, such as a way to describe MMIO and interrupts that are architecture specific, but hey, getting it to compile is a start
08:13:54 <acowley> But to do so I just removed an "extra-lib-dirs" field from the GLFW-b cabal file to see what happened. The warning went away, but why would that field affect building an executable that depends on GLFW-b?
08:14:34 <alistra> intercalate?
08:14:39 <hpaste> yogsosoth pasted “how to memoize this?” at http://hpaste.org/54426
08:15:11 <Phyx-> is therea  toLower for bytestring?
08:15:48 <c_wraith> Phyx-: you can fake one, badly, with map from .Char8
08:16:05 <Phyx-> badly?
08:16:18 <c_wraith> well, it will utterly fail on non-ascii
08:16:23 <Phyx-> ah
08:16:41 <Phyx-> i only support ascii so that shouldn't be a problem
08:16:57 <hpaste> yogsototh annotated “how to memoize this?” with “how to memoize this? (annotation)” at http://hpaste.org/54426#a54427
08:17:05 <shurikas> @hoogle a -> IO a
08:17:05 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
08:17:06 <lambdabot> Control.Exception evaluate :: a -> IO a
08:17:06 <lambdabot> Control.OldException evaluate :: a -> IO a
08:17:14 <Phyx-> thanks c_wraith
08:22:11 <ash_> so, I have been curious. Are there any constructs of describing a memory address in ghc? I haven't found any but that doesn't mean one doesn't exist
08:22:28 <sipa> Ptr ?
08:23:59 <ash_> yea, I guess, can you tell a Ptr to be at a specific location?
08:24:59 <mauke> o_O
08:26:11 <leoncamel> ash_: ForeignPtr ?
08:26:24 <acowley> unsafeCoerce 1337 :: Ptr ()
08:27:17 <ash_> Thanks, that sounds like what I wanted
08:27:27 <dmwit> I think it was a joke.
08:27:32 <mauke> it was
08:27:36 <acowley> Oh, sorry, yes that was a joke!
08:27:39 <ash_> ah
08:27:48 <mauke> but you shouldn't have spoiled it
08:28:18 <byorgey> no, what acowley does indeed sound like what ash_ wanted.  It's just that ash_ shouldn't want that.
08:28:25 <byorgey> *acowley said
08:28:42 <ash_> i would if I was trying to run a program on bare metal (eg. no OS)
08:28:59 <mauke> then you'd have rewritten the runtime system anyway
08:29:03 <mauke> and knew all this stuff
08:29:04 <mike-burns> It's totally possible for him to want this.
08:29:13 <acowley> There is a polite name for what I wrote: intPtrToPtr $ fromIntegral 1337
08:29:54 * ski . o O ( `move.l (4),a6' )
08:30:16 <ash_> mauke: I have been thinking about that, working on an RTS for an embedded system (like an arm processor), thats why I am asking all these dumb questions
08:31:05 <acowley> Another classy version is, plusPtr nullPtr 1337
08:31:16 <acowley> Haskell has many ways of shooting yourself in various body parts with pointers.
08:31:30 <acowley> I do so regularly.
08:31:34 <ash_> sounds fun
08:32:28 <ash_> MVar is synchronized, does that mean its doing a memory access for each time you read from the variable?
08:32:47 <ash_> just looking for an equivalent to 'volatile' in C
08:32:55 <mauke> how can you read from memory without reading from memory?
08:33:04 <ski> ash_ : maybe `SampleVar' would be better ?
08:33:47 <ash_> mauke: by re-using a copy of the value
08:33:55 <mauke> which is stored where?
08:34:04 <ash_> if you load it from memory and assume it hasn't been updated and it intact has been updated you could miss something
08:34:16 <mauke> do you know any haskell?
08:34:20 <ash_> hence, volatile in C
08:34:27 <ash_> i thought i did, but I may not
08:35:01 <mauke> before looking for a 'volatile' can you tell me the equivalent of no 'volatile'?
08:35:14 <mauke> i.e. something like int x; in haskell
08:35:15 <acowley> under the hood, various pieces do use an atomic CAS which does use barriers
08:37:55 <ash_> mauke: volatile memory locations are only important for interrupt based behavior, which is how most things are accomplished in embedded systems without an OS
08:38:15 <mauke> non sequitur
08:38:30 <alistra> glory isn't a demon, she's a god
08:40:53 <ash_> volatile is just useful for telling the compiler that the hardware can change this value at anytime, or it could be modified in an interrupt, which isn't exactly predictable
08:42:25 * hackagebot dropsolve 0.1.2 - A command line tool for resolving dropbox conflicts.  http://hackage.haskell.org/package/dropsolve-0.1.2 (DanielTrstenjak)
08:43:06 <triyo> Anyone running xmonad 0.10, ghc 7.x on a Mac OS X?
08:43:26 <mauke> ash_: or a signal handler
08:43:32 <triyo> Not to sure of what the installation / setup process is. I get an error when running `xmonad
08:43:50 <leoncamel> triyo: sure, both ghc-7.2.1 and ghc-7.2.2
08:44:19 <dmwit> triyo: You might also be interested in #xmonad. =)
08:44:27 <leoncamel> triyo: Sorry, no. I miss the xmonad. :)
08:44:33 <triyo> hehe
08:44:38 <triyo> np
08:46:05 <ash_> mauke: so, do you understand why I'd want a way to describe volatile memory locations?
08:46:10 <mauke> no
08:46:18 <mauke> you haven't answered my question
08:46:38 <ash_> the int x;?
08:46:47 <ash_> I'd need more information, is that local or global?
08:47:00 <mauke> local
08:47:23 <ash_> mutable? I guess, otherwise you'd of said const
08:48:49 <ash_> If it has to be mutable, i'd try to put it in a state monad, or change it to be immutable if possible
08:49:03 <mauke> how would State help you?
08:50:19 <ash_> State would let you assign it a value you can change later
08:50:38 <mauke> not really
08:50:51 <mauke> also: how do you do a volatile State then?
08:51:22 <ash_> I don't know thats why I have been asking in here
08:51:52 <mauke> do you even know what State is?
08:51:55 <ash_> I'd imagine you'd need a new something to describe that it is volatile to the compiler
08:52:08 <mauke> State has no mutable parts
08:52:29 <ash_> Control.Monad.State ?
08:52:34 <c_wraith> correct.
08:52:39 <c_wraith> No mutable parts in it
08:52:49 <acowley> I think MVar is basically what ash_ wants supported in interrupt handlers on ARM
08:53:24 <aninhumer> I think you'd need some kind of transaction system to handle a volatile memory location in Haskell
08:53:50 <aninhumer> or CAS as someone said
08:57:46 <Cale> ash_: If you're compiling Haskell code to run on a device, then even if you somehow do without an OS proper, whatever runtime system you have will probably do a lot of OS-like functions.
08:58:04 <Cale> and it's not necessarily written in Haskell (GHC's runtime system is written in C)
08:58:53 <ash_> I know, I'd probably only implement a small subset, or as small as I could
08:59:45 <DukeDave> What about? http://hackage.haskell.org/package/atom/  (for ash_)  ?
09:00:04 <ash_> libc and libstdc++ for embedded systems are only subsets, I imagine it would be along those lines, obviously there are somethings that don't make sense on an embedded system, like filesystem stuff
09:00:09 * DukeDave just joined conversation
09:00:48 <acowley> This cabal issue is officially bizarre: there is a GLFW-b/build/libglfw.dylib which cabal needs to know about when building GLFW-b, but then I get a '-Lbuild' when cabal builds a separate executable that depends on GLFW-b
09:01:23 <acowley> atom is more about writing carefully-considered C in Haskell
09:02:22 <ash_> I have seen atom before, I am partly looking into it running the ghc on an embedded system as a learning experience, I doubt I'll ever get it fully running but its interesting to consider
09:05:25 <carpi> >@ src fold1
09:05:55 <aninhumer> @src fold1
09:05:56 <lambdabot> Source not found. You untyped fool!
09:06:03 <aninhumer> @src foldl1
09:06:04 <lambdabot> foldl1 f (x:xs) = foldl f x xs
09:06:04 <lambdabot> foldl1 _ []     = undefined
09:06:24 <carpi> thnx )
09:17:36 <ash_> I think the other thing that would make using the ghc on an embedded system difficult is the limited memory, for example, the mbed only has 32KB of ram
09:19:19 <Cale> ash_: Running GHC itself is probably impractical on most embedded systems, but you can cross compile
09:19:29 <Cale> ash_: Which is what we're doing for iPhone
09:20:02 <Cale> It's certainly impractical to run GHC with anything less than a few hundred megabytes of RAM.
09:20:19 <ash_> even a subset of the GHC?
09:20:34 <Cale> Well, I don't know how you'd cut memory consumption that much...
09:20:45 <ash_> yea, true
09:20:57 <Cale> GHC takes a lot of memory while it's running.
09:21:05 <Cale> Quite commonly
09:21:07 <ash_> i wonder what parts are consuming the most memory
09:21:16 <Cale> 32KB is a few orders of magnitude off
09:21:43 <c_wraith> heh.  on linux systems, LD consumes the most memory :)
09:21:54 <c_wraith> well, ld
09:22:11 <ash_> ld as in the linker?
09:22:17 <Cale> yeah
09:22:27 <ash_> oh, I meant the runtime
09:22:48 <c_wraith> ah, so you really mean "programs compiled with ghc"
09:22:56 <ash_> ya, sorry
09:23:07 <Cale> Cross compiling can be okay
09:23:11 <ash_> cross compiled targeting an embedded system such as an arm
09:23:19 <Cale> though 32KB of memory is certainly pushing it
09:23:20 <saati> do the runtime parts fit in 32K?
09:23:53 <Cale> I don't think you'll easily manage with that little ram. You're better off using Haskell as a metalanguage instead.
09:24:56 <Cale> (i.e. use Haskell to write a program which writes the program to run on your device)
09:25:29 <Cale> at least with GHC
09:25:34 <ash_> ya, thats the concept behind atom
09:26:11 <Cale> It's certainly possible to have a Haskell-like language which runs in that little space.
09:26:45 <Cale> But I don't think there are many implementations like that.
09:28:03 <ash_> I'd love to find on, the ghc's seemed like a good bet to me, because you can use the llvm to cross compile, most other languages don't have great support for cross compiling, at least not at the embedded level
09:28:44 <Younder> Haskell is atruly lovely language To know it is to love it.
09:29:07 <EvanR-work> how do you run haskell on low mem, no gc?
09:29:23 <Cale> The reduceron (an FPGA program for doing reduction of Haskell expressions) uses 32K*77 for its heap
09:29:43 <Cale> er, sorry, that's 77 bits
09:29:57 <Younder> I have yet to know a language that gives such ascetic pleasure.
09:30:42 <Cale> So 308 KiB or so.
09:30:48 <Younder> EvanR-work, I don't
09:31:32 <Younder> EvanR-work My machine has 24 GB and 16 cores so that is never a problem
09:31:34 <Cale> EvanR-work: good question :)
09:31:45 <Cale> Younder: EvanR-work was talking to ash, I guess.
09:32:42 <ash_> EvanR-work: I don't think turning off the GC would help low memory… but maybe tuning it to have different allocation amounts and thresholds could help
09:32:50 <Cale> ash_: We're doing cross compiling to run on iPhones (Stephen Blackheath, one of my coworkers was responsible for a lot of the work in that direction)
09:33:25 <Younder> Multi-threading in Haskell is somewhat of adventure
09:34:02 <ash_> thats neat, do you still use a GC on the iPhone? I know objective-c on iOS doesn't have a GC, it uses reference counting, actually Apple is phasing out the objective-c GC for ARC
09:34:06 <Cale> ash_: I'm not even sure whether the garbage collector's code will currently fit in 32KB :P
09:34:10 <Cale> yes
09:34:49 <Cale> We're just using a pretty standard GHC runtime system.
09:35:02 <Cale> But the iPhone has lots of memory
09:35:19 <Cale> well "lots"
09:35:26 <kmc> the iPhone is certainly more powerful than the machines GHC was initially developed on
09:35:43 <ash_> i duno, the original iPhone only had 128 MB of ram
09:36:05 <Cale> 128 MB is way more reasonable than 32 KB
09:36:10 <ash_> newer ones, like the iPhone 4 and 4S have 512 MB
09:36:11 <ash_> ya
09:36:42 <EvanR-work> ash_: thats what i meant, eliminate the gc for the purpose of just saving space
09:36:47 <Younder> kmc It is indeed
09:36:58 <Cale> You might not be able to run GHC itself on the iPhone (we haven't attempted it)
09:37:10 <Cale> but you can cross compile and have programs run okay
09:37:53 <Younder> You SHOULD actually be able to compile programs on that IPhone
09:37:54 <kmc> 'To compile up this source-only release, you need a machine with 16+MB memory, GNU C (`gcc'), `perl' plus a version of GHC installed (either version 0.29 or 2.02 onwards).'
09:37:55 <ash_> EvanR-work: Ya, I don't know of any embedded systems programming languages that use a GC, I have, however, seen ones that use reference counting
09:38:03 <kmc> that's from GHC 2.10
09:38:13 <EvanR-work> uhg reference counting
09:38:31 <ash_> EvanR-work: have you seen the new ARC stuff from the llvm guys?
09:38:36 <geheimdienst> kmc, may i put your comment through tortured fanboy logic and take it to somehow prove that the iphone is magical and revolutionary?
09:39:07 <kmc> not sure why my permission would be required
09:39:22 <geheimdienst> :D
09:39:24 <acowley> Cale: does the cross-compiling stuff work with newer GHCs?
09:39:26 <kmc> ash_, "embedded device" is too vague a category
09:39:40 <kmc> like i said, it encompasses devices more powerful than 10-year-old UNIX workstations
09:39:44 <kmc> does J2EE do garbage collection?
09:40:16 <Cale> Yeah, what kind of a fanboy are you if you need permission to take other people's statements out of context as proof that your favourite products are amazing?
09:40:41 <ash_> the gist of it is they use static analysis to determine how the reference count should be controlled, and have it all handled at compile time, Apple's planning on phasing out the GC system from OS X in favor of the ARC (automatic reference counting http://clang.llvm.org/docs/AutomaticReferenceCounting.html if your interested), its performing better than the old GC was
09:41:32 <Cale> acowley: yes-ish. It's currently for 7.2, but I think the plan is to get it into GHC 7.4 proper? Maybe I misheard something. In any case, it's eventually going to be in mainline GHC.
09:41:50 <ash_> kmc: I'd love to be able to program my mbed with a haskell-ish language, it probably won't happen soon, but one can dream
09:42:30 <acowley> Cale: That would be fantastic! For so long we've just had confident rumors that it worked with 6.something, but nothing for the unwashed masses to play with.
09:42:48 <ash_> the mbed has an arm cortex-M3 running at 96MHz, with 512KB of program memory with 32KB of ram
09:42:51 <kmc> for so long we've had rumors that iPwn is making a video game
09:43:05 <Cale> kmc: We're working on it :)
09:43:37 <acowley> kmc puts the fine point on my politic enthusiasm
09:46:10 <acowley> is Agda -> Haskell FFI now awesome?
09:46:24 <Cale> It's quite a lot of work constructing an FRP system and a game engine in terms of that, and then writing a game using that engine :)
09:48:11 <Cale> We're sort of doing all of them at once, and having them inform each other.
09:48:30 <kmc> so is iPwn secretly a nonprofit center for PL research?
09:48:37 <Cale> lol
09:48:45 <EvanR-work> 'write games, not engines'
09:49:18 <Cale> EvanR-work: Yeah, in some cases the separation between game and game engine isn't as clear as we might want, too.
09:49:23 * geheimdienst writes an engine that lets you make engines for games
09:49:34 <cheater> acowley: why would you want a haskellish language for embedded applications?
09:49:37 <Cale> geheimdienst: Well, that's kinda what the FRP system would be
09:49:44 <geheimdienst> :D
09:49:49 <EvanR-work> write an engine (engine (engine (engine (...
09:50:06 <Cale> EvanR-work: and that would be Haskell? ;)
09:50:08 <geheimdienst> > "game " ++ fix ("engine" ++)
09:50:08 <cheater> acowley: it doesn't make much sense to have a lazy scheme in a single-purpose, memory-limited environment
09:50:10 <lambdabot>   "game engineengineengineengineengineengineengineengineengineengineengineeng...
09:50:16 <EvanR-work> lol
09:50:51 <Cale> cheater: well...
09:51:04 <Cale> cheater: Depends on how memory-limited and how single-purpose
09:51:16 <acowley> cheater: was that in response to a particular comment I made?
09:51:21 <Cale> Laziness can be good for memory consumption too!
09:52:39 <acowley> cheater: I think Haskell is a nice language for dealing with, for example, streams of network data. I've written web servers for PICs before, and it would have been nice to do pieces of that in something other than the mostly-C the compiler accepted.
09:52:57 <cheater> 18:59 < ash_> kmc: I'd love to be able to program my mbed with a haskell-ish
09:53:12 <cheater> isn't that what you meant by "mbed"
09:53:21 <acowley> ah, ash_ and I are not actually the same person
09:53:36 <acowley> mbed is a particular platform
09:54:05 <cheater> right sorry i got confused
09:54:09 <cheater> ash that was for you
09:54:43 <Cale> "The current hardware of the mbed microcontroller is based around an NXP-built ARM based Cortex-M3 core, running at 96MHz, with 512KB FLASH, 64KB RAM, as well as several interfaces including Ethernet, USB Device, CAN, SPI, I2C and other I/O."
09:56:33 <acowley> I think a more realistic target is the soon-to-be-released Raspberry Pi with extra IO slaved to it
09:56:54 <acowley> costs less and has the right order of magnitude of RAM
09:57:31 <parcs> i hope the raspberry pi does not end up to be vaporware
09:57:38 <ash_> well, a problem with most embedded languages (C, C++ are the most common) is they don't always clearly show the intent of a function, if you have a function "foo" does it modify a global variable? is it reentrant? Can I use it in an interrupt handler?, those languages don't describe those kinds of things
09:57:50 <acowley> parcs: I think it'll come out but disappoint most people
09:58:26 <ash_> for $25, you have to be realistic
09:58:35 <acowley> parcs: Mostly due to unrealistic expectations. It won't out-Arduino an Arduino, and it won't be a viable PC replacement for most people.
09:59:26 <ash_> the raspberry pi can supposedly do 1080p output (via hdmi)
09:59:33 <ash_> thats impressive to me
10:00:04 <cheater> raspberry pi looks very good imo
10:00:10 <cheater> i hope it lifts off very well
10:00:11 <acowley> It's super-impressive! But it's not yet clear what it offers to people who can also afford a $250 netbook.
10:00:29 <cheater> acowley: i think it's about having something supercheap that is also fairly good.
10:00:38 <ash_> I think his target crowd is low income and education
10:00:56 <cheater> 3rd world countries
10:00:58 <cheater> etc
10:01:17 <acowley> If that is the only market, then they will probably have trouble.
10:02:28 <co_dh> greeing! how can I convert a file into lines by iteratee?
10:03:03 <co_dh> s/greeing/greeting
10:05:11 <parcs> what package are you using that provides iteratees?
10:06:15 <co_dh> iteratee-0.8.7.2,
10:06:22 <co_dh> are there a lot of choice?
10:06:52 <acowley> enumerator is another popular option
10:07:55 <parcs> co_dh: see break and breakE in Data.Iteratee.ListLike
10:08:10 <co_dh> parcs: thanks!
10:08:45 <co_dh> which iteratee lib you guys recommend that are easy to use?
10:09:15 <parcs> i use enumerator
10:09:26 <parcs> it's a little simpler i think
10:15:59 <Jeanne-Kamikaze> must be very fun when you're a mathematician and you see one of these books like "category theory for software engineers" AKA "category theory for the mentally challenged"
10:16:14 <Jeanne-Kamikaze> :(
10:16:34 <Jeanne-Kamikaze> oh yes, this one has pictures
10:16:51 <kmc> heh
10:17:02 <kmc> in my experience, mathematicians do not look down upon software engineers in this way
10:17:25 <kmc> also all category theory has tons of pictures
10:17:56 <Jeanne-Kamikaze> is it true that one must learn category theory to fully understand haskell ?
10:18:23 <kmc> that's not an interesting question
10:18:29 <kmc> it's a question of how you define "fully understand haskell"
10:18:53 <EvanR-work> do you need to learn haskell to fully understand category theory!
10:18:56 <Jeanne-Kamikaze> as in why stuff is the way i tis
10:19:24 <kmc> do you need to understand CPU architecture to fully understand haskell
10:19:37 <EvanR-work> if you look at most software, you will question the non mentally challenged status of the developers
10:19:40 <Jeanne-Kamikaze> no, but for example if you're doing C it helps understanding the machine
10:19:53 <EvanR-work> Jeanne-Kamikaze: not if you ask ##c
10:20:04 <kmc> Jeanne-Kamikaze, many C programmers are under serious delusions about what "the machine" is
10:20:19 <kmc> they think that assembly-level instructions correspond to discrete steps in the hardware
10:20:24 <Jeanne-Kamikaze> well, you have to understand cache memory and know basic assembly
10:20:32 <kmc> that registers are physical, etc.
10:20:33 <EvanR-work> not in C you dont
10:20:41 <acowley> I think virtually everyone is under serious delusions about how their computer works
10:20:59 <kmc> acowley, the choices are serious delusion or acknowledged ignorance
10:21:02 <EvanR-work> yep, intel has massive NDA on its mechanisms
10:21:03 <acowley> The trick is to find a set of delusions that works for you.
10:21:27 <mbret> quit
10:21:32 <mbret> close
10:22:33 <EvanR-work> end
10:22:35 <EvanR-work> terminate
10:22:44 <EvanR-work> abort
10:22:50 <EvanR-work> obliterate
10:23:40 <saati> Jeanne-Kamikaze: understanding caches and having some ideas about how much memory does it cost to do some operation helps with any language
10:25:01 <solirc> Is ther still an instance of Hackage with reverse dependencies running somewhere?
10:25:31 <solirc> http://bifunctor.homelinux.net/~roel/hackage seems to be dead
10:26:29 <acowley> hackage 2 has this
10:28:25 <hpaste> DukeDave pasted “Need for FlexibleInstances ?” at http://hpaste.org/54430
10:28:29 <solirc> acowley: an is there an instance running somewhere?
10:28:41 <DukeDave> Does anyone wish to comment on that error ^
10:29:01 <acowley> solirc: yes, but I can't find the URL at the moment
10:29:02 <DukeDave> I always assumed I can make an instance out of a higher type?
10:29:19 <DukeDave> e.g. instance Foo (Maybe Int)
10:29:27 <DukeDave> Or is that illegal?
10:30:03 <solirc> acowley: same here
10:30:18 <rwbarton> DukeDave: it is not legal in Haskell 98 to write an instance for something like (Maybe Int)
10:30:29 <DukeDave> rwbarton: Wow
10:30:38 <DukeDave> Do we know for why?
10:31:28 <kmc> Haskell 98 instance resolution is designed for easy implementation
10:31:31 <parcs> usually you can define an instance Foo a => Foo (Maybe a)
10:31:46 <DukeDave> parcs: That was my next quetsion
10:31:47 <DukeDave> :)
10:32:02 <kmc> every instance has the form (C a b ...) where C is a constructor and a,b,... are the proper number of variables
10:32:34 <kmc> the implementation can just store a map of (class name, constructor name)
10:32:41 <kmc> there's no possibility of overlap, no need to find the "best instance"
10:32:58 <DukeDave> kmc: Magic, gotcha :)
10:33:09 <kmc> once you find the one and only instance, you may get some additional class constraints which need to be satisfied
10:33:13 <acowley> It's actually sadly unmagical :(
10:33:29 <kmc> but there's no backtracking or anything
10:33:32 <kmc> DukeDave, ?
10:33:34 <rwbarton> DukeDave: it's not magical at all
10:34:04 <rwbarton> DukeDave: it means if you (the compiler) need to find an instance for MyClass (MyType1 MyType2 MyType3) you only need to inspect MyType1 to know which instance to use
10:34:26 <DukeDave> rwbarton: Ah, okay, I understand now
10:34:55 <DukeDave> And the FlexibleInstances allows for such things?
10:34:59 <kmc> yes
10:35:09 <DukeDave> Hazaa
10:35:11 <kmc> GHC has a variety of extensions to relax these restrictions
10:35:15 <DukeDave> Thanks
10:35:29 <acowley> Is it on by default in Haskell2010?
10:35:33 <kmc> don't think so
10:35:50 <rwbarton> it is considered very benign as far as extensions go, though
10:35:54 <DukeDave> Is Haskell2010 what I've known as Haskell' in the past?
10:36:01 <acowley> solirc: I found what I was thinking of http://www.haskell.org/pipermail/haskell/2011-October/023048.html
10:36:06 <parcs> i don't understand why the report creates restrictions to ease typechecking implementation
10:36:10 <acowley> solirc: but the URL given there doesn't work for me
10:36:15 <kmc> DukeDave, Haskell' is the name of the process which produces new Haskell versions
10:36:21 <kmc> it's not the name of a specific version
10:36:23 <acowley> solirc: namely, http://revdeps.hackage.haskell.org/
10:36:25 <DukeDave> Does it have any implications other than implementation complexity?
10:36:41 <kmc> FlexibleInstances should be fine
10:36:49 <DukeDave> kmc: Ah, that never occurred to me, has anyone decided when then next standard will be yet?
10:36:57 <kmc> sometime in 2012
10:37:05 <kmc> they were supposed to do one per year, but they punted on 2011
10:37:19 <kmc> they issued like an advisory recommendation for the 2012 spec
10:37:26 <kmc> DukeDave, UndecidableInstances is fine too
10:37:40 <kmc> (it adds a new way for GHC to error out at compile time, but there are plenty of those already)
10:37:50 <DukeDave> kmc: They also skipped [1999.. 2009], right?
10:37:53 <DukeDave> 'they' :)
10:37:55 <kmc> yeah
10:38:03 <acowley> those people
10:38:06 <kmc> i don't know when the Haskell' committee was convened
10:39:38 <kmc> @where+ h10.announcement http://www.haskell.org/pipermail/haskell/2009-November/021750.html
10:39:38 <lambdabot> It is forever etched in my memory.
10:39:46 <kmc> that has the list of accepted extensions
10:40:14 <snappy> shit wifi lounge is shit slow
10:40:20 <snappy> er srory, wrong channel
10:40:30 <kmc> anyway one can ask "why are Haskell classes designed for implementation ease"
10:40:40 <kmc> i'm not sure, but I think it has to do with type classes being a new and experimental feature
10:40:44 <kmc> as of the beginning of haskell
10:40:57 <kmc> there is a paper "type classes: exploring the design space"
10:44:55 <solirc> acowley: not working here, neither
10:50:15 <DukeDave> kmc: Interesting, thanks for the link
10:50:59 <Sebasti0n> Hi there. I have [IO String], what is a good way to turn it into IO [String]
10:51:06 <Botje> sequence
10:51:27 <Botje> you generally want to use mapM, which combines map and sequence
10:52:53 <companion_cube> mapM and mapM_
10:53:09 <Sebasti0n> thanks a lot Botje and companion_cube
10:53:32 <calsaverini> is there a "flip" combinator for functions of three arguments? Like: flip3 :: (a -> b -> c -> d) -> c -> a -> b -> d ?
10:53:50 <kmc> @hoogle (a -> b -> c -> d) -> c -> a -> b -> d
10:53:51 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
10:53:51 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:53:51 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:53:54 <Botje> @pl \f c a b -> f a b c
10:53:55 <lambdabot> flip . (flip .)
10:54:04 <calsaverini> hummmm
10:54:18 <calsaverini> thanks, I didn't now this command @pl
10:54:34 <calsaverini> Can I marry lambdabot?
10:54:46 <kmc> you can download her
10:54:49 <calsaverini> hahaha
10:54:54 <kmc> which is kind of the same thing
10:55:47 <calsaverini> I'll do that, haha
11:18:37 <kstt> how is the show instance defined for String ?
11:19:22 <kstt> it amazes me that "(Show a) => SomeClass [a]" is haskell 98 but "SomeClass [Char]" is not ...
11:19:46 <kmc> kstt, this is why Show has the 'showList' method
11:20:10 <kmc> the Show instance for String is really implemented by the showList method in the Show instance for Char
11:20:15 <kmc> i.e. a huge hack
11:20:58 <kmc> and you can only pull this hack if you're the one defining the type class in question
11:21:21 <_kit_> @pl map (\x -> map ($ x) [(+1), (+2), (+3)]) [0..10]
11:21:21 <lambdabot> map (flip map [(1 +), (2 +), (3 +)] . flip id) [0..10]
11:21:32 <kmc> what's worse is Text.Printf:  instance IsChar c => PrintfType [c];  class IsChar c; instance IsChar Char
11:22:14 <dolio> What's worse is overlapping instances.
11:22:17 <kstt> kmc: thanks for
11:22:25 <kstt> kmc: thanks for your clear explanation
11:22:32 <kmc> :)
11:23:07 <kstt> I'd like to define an instance of a (custom, at the moment) class for String, and I'm contemplating the solutions
11:23:29 <daganu> :)
11:23:43 <kstt> What's the rational behind prohibiting [Char] as a instance type ?
11:24:00 <kmc> ease of implementation of type classes
11:24:08 <kmc> i explained this a little while ago
11:24:13 <dolio> [Char] as a type is allowed with FlexibleInstances which are uncontroversial.
11:24:28 <dolio> Allowing both [Char] and [a] is overlapping instances which is controversial.
11:24:50 <kstt> dolio: do you mean I can use it with confidence that is will make it into next haskell revision
11:25:10 <kmc> with the H98 restriction, it's easy for a Haskell compiler to look up the one and only possible instance
11:25:22 <kmc> for a given (class, constructor) pair
11:25:34 <dolio> Use which?
11:25:37 <kmc> kstt, I would just use FlexibleInstances
11:25:45 <kmc> it will be supported by any Haskell compiler anyone cares about
11:25:46 <dolio> Neither of those are in any Haskell standard.
11:25:52 <kmc> it will probably make it into the standard eventually
11:25:54 <kstt> cool, thanks !
11:25:57 <kmc> it's not controversial
11:26:00 <dolio> But FlexibleInstances have a much better change of getting in.
11:26:10 <kstt> chanCe ?
11:26:15 <dolio> Yeah.
11:26:19 <kstt> cool, thanks
11:27:31 * hackagebot RefSerialize 0.2.8 - Write to and read from Strings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.2.8 (AlbertoCorona)
11:27:55 <usererror> Hey guys
11:28:03 <usererror> I have a problem with haskell und glut
11:28:25 <usererror> I've installed everything as told here: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
11:28:25 <kstt> things are working now with your advises, kmc and dolio. Thank you very much.
11:29:03 <usererror> but when I try the example teapots.hs, it compiles, but when I wanna run is: teapots.exe: user error (unknown GLUT entry glutInit)
11:29:21 <usererror> when I google for that, I only find people having the same problem but no solution
11:30:04 <usererror> libglut32.dll is in system32 folder of windows, but even copying it to the same folder where teapots.exe is located wont help
11:35:29 <danm_> libglut32.dll or glut32.dll?
11:36:19 <mah_b> usererror: imho you should need glut.dll/glut32.dll
11:36:44 <mah_b> usererror: eg from http://www.opengl.org/resources/libraries/glut/glutdlls37beta.zip
11:38:43 <usererror> mah sry I meant glut32.dll und glu32.dll are already in System32
11:40:16 <usererror> ok I copied the glut32.dll (from the package you gave me) to system32
11:40:19 <usererror> still the same error
11:40:57 <mah_b> and if you add it to the same directory?
11:41:36 <usererror> hey now it works
11:41:41 <mah_b> yay
11:41:44 <usererror> weird, before I dod copy it to the same folder
11:41:52 <usererror> but why does it work now but not before??
11:41:58 <mah_b> what have you changed?
11:42:22 <usererror> I copied now YOUR dlls to the same folder as my *.exe
11:42:29 <usererror> before I did it too but with my old dll
11:42:30 <usererror> hmm
11:42:34 <usererror> thanks a lot
11:42:42 <mah_b> yw
11:43:03 <usererror> btw: why is like any haskell-bingings-installation so crappy for windows?
11:43:12 <usererror> on linux it works fine
11:43:24 <usererror> but once I wanna use some bingings in haskell on windows, I have to use hacks etc
11:44:09 <usererror> like... I tried once the SDL bindings fpr haskell on windows
11:44:18 <usererror> I still have no idea how to install them in windows
11:45:28 <acowley> Because the whole Windows platform is tailored to installing binary executables, while Unix derivatives are tailored to distributing source code.
11:45:38 <usererror> hm
11:45:49 <usererror> well yeah on linux the installation was easy and no trouble at all
11:47:03 <usererror> ok but thanks anyway!
12:03:53 <acowley> What version of GHC do I need for ConstraintKinds?
12:04:04 <acowley> ah, 7.4
12:04:21 <strager> I'm using Control.Monad.State.  I have a "global" and a "local" state.  Right now I have type MyState = State MyGlobalData, and type MyLocalState = State (MyGlobalData,MyLocalData).  This words, except I'd like some functions to return MyGlobalState but also work within the MyLocalState monad.  What's a better way to approach this problem?
12:05:18 <melan> Somebody using here Haskell on a Gentoo linux system?
12:05:43 <acowley> strager: StateT MyLocalData (StateT MyGlobalData)
12:06:40 <illissius> strager: lenses, methinks
12:07:02 <strager> I'll look into both; thanks
12:07:29 * elliott doesn't see how lenses would help.
12:07:36 <dylex> melan: some, yes
12:08:08 <rwbarton> I think one or more of the lens libraries includes a function like  Lens a b -> State a r -> State b r
12:08:12 <acowley> lenses help if he wants to keep a flat design and use AllMyState { globalData :: Meh, localData :: Meh }
12:08:27 <shachaf> elliott: Lenses always help.
12:08:45 <illissius> http://hackage.haskell.org/packages/archive/data-lens-fd/2.0/doc/html/Data-Lens.html
12:08:51 <shachaf> acowley: That's assuming that the local state is the same everywhere.
12:08:58 <acowley> shachaf: that's a good point
12:09:48 <melan> dylex, I want to emerge dev-haskell/wxcore and got dependency problems with "containers >=0.2 && <0.4", now I don't know which gentoo package manage "containers"
12:09:49 <illissius> (i haven't thought through whether lenses are the right solution, but it smells like it)
12:10:05 <shachaf> If lenses are the wrong solution, you're solving the wrong problem.
12:10:18 <elliott> Lens is a good alternative to (->).
12:10:19 <elliott> More strict.
12:10:23 <acowley> How can I fake ConstraintKinds until 7.4 is out?
12:10:43 <elliott> badly
12:10:55 <shachaf> acowley: By using 7.3.
12:11:00 <acowley> elliott: Yeah, that's what I've come up with so far.
12:11:26 <acowley> shachaf: too much compiling
12:11:47 <illissius> GADTs + type families + lots of typing
12:11:59 <shachaf> elliott: Lens is a clever alternative?
12:12:15 <shachaf> acowley: Compiling GHC takes minutes.
12:12:20 <illissius> (that's how RFunctor/RMonad do it)
12:12:23 <shachaf> (But quite a few of them.)
12:12:25 <elliott> shachaf: It takes about 100 of them.
12:12:25 <acowley> it takes seconds, too
12:12:37 <shachaf> Ugh, RFunctor/RMonad.
12:12:39 <elliott> (More, really.)
12:12:42 <shachaf> I am deeply suspicious of those classes.
12:13:02 <acowley> it's not just GHC, of course, but having to recompile all my dependencies, and then again when 7.4 is released or I determine my chosen version of 7.3 was a poor choice
12:13:03 * elliott wants Set to be a monad, but not at the expense of making Functor/Monad ugly.
12:14:10 <ali> hi guys
12:14:33 <shachaf> elliott: RFunctor means that fmap can do anything at all to your values.
12:14:48 <shachaf> That's quite evil.
12:14:52 <Philonous_> acowley:  There are nightly builds
12:15:04 <shachaf> ali: Good evening.
12:15:31 <illissius> shachaf: yeah, RFunctor/RMonad are weird. but with ConstraintKinds they look a lot nicer. and it seems they even make sense categorically: http://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
12:15:55 * illissius wonders whether there's any kind of decent name for things of kind forall X. X -> Constraint
12:16:27 <shachaf> We have kind polymorphism now?
12:16:33 <elliott> illissius: haskell 98 classes :P
12:16:36 <illissius> (or rather exists X. X -> Constraint might make more sense)
12:16:55 <illissius> shachaf: that was just a figure of speech, but unrelatedly, in fact we do.
12:18:06 <rwbarton> shachaf: that is what functor laws are for...
12:18:07 <illissius> elliott: well, yeah. the problem is that H98 classes are all $word, but not all (plural $word) are H98 classes.
12:18:53 <shachaf> rwbarton: I guess.
12:20:52 <elliott> shachaf: Don't you just mean that RFunctor makes proving the functor laws not necessarily trivial?
12:23:43 <dylex> melan: (sorry got distracted) containers should come with ghc itself. are you using the haskell overlay or any keywords?
12:24:25 <dylex> melan: you could try re-emerging ghc I suppose.  you can also check ghc-pkg list and ghc-pkg check to see if it says anything weird.
12:24:36 <melan> dylex, already found the problem, i have installed containers-0.4.0.0 but i need <0.4
12:24:45 <melan> dylex, now iam trying it with cabal
12:25:07 <melan> dylex, btw. do you know, how can i remove packages with cabal?
12:25:54 <elliott> You can't.
12:26:11 <elliott> Well, you can; rm -r ~/.cabal ~/.ghc && cabal install everything but one package.
12:27:49 <dylex> melan: you can also just ghc-pkg hide or ghc-pkg unregister it so it doesn't show up anymore
12:28:18 <dylex> melan: I've generally stuck with portage (haskell overlay + hackport, which is awesome) rather than cabal myself.
12:29:43 <dylex> melan: if you're using unkeyworded ghc (6.12.3 currently) it really should have containers-0.3.0.0 already.
12:31:02 <melan> dylex, thats the problem, iam using system-wide ~gentoo... should switch back to normal... only problems with that :-/
12:32:45 <dylex> melan: yeah. the wxcore in portage won't work with the latest ghc.  but there's a newer one in the haskell overlay that should.
12:33:10 <melan> dylex, ok i will try it, thank you!
12:46:36 <nejucomo> How do I read the contents of a file *non-lazily*?
12:46:36 <lambdabot> nejucomo: You have 1 new message. '/msg lambdabot @messages' to read it.
12:47:58 <tromp> nejucomo compute its length?
12:49:39 <ash_> does computing the length require loading the whole file? Can't the FS return the length of the file without fully loading it?
12:49:46 <zygoloid> nejucomo: use Data.ByteString.readFile
12:50:13 <shachaf> zygoloid: Or Data.Text.readFile.
12:50:32 <shachaf> It would be vaguely nice if there was a non-evil String function to read a file.
12:50:41 <tromp> not if you take length of the String
12:51:13 <wavewave> nejucomo: or you can check out strict package : System.IO.Strict
12:51:30 <wavewave> nejucomo : if you like to use String instead of ByteString
12:52:00 <nejucomo> So this code using System.IO is wrong, due to laziness, correct?  http://codepad.org/LMV7b9g6
12:52:38 <wavewave> shachaf: isn't System.IO.Strict.readFile a non-evil String function?
12:52:56 <shachaf> wavewave: I guess so.
12:53:20 * nejucomo looks up the different between Data.Text.readFile and String.IO.Strict.readFile.
12:53:28 <zygoloid> shachaf: yeah, something which reads into a memory-efficient data structure, then lazily produces a String from it, would be ideal
12:53:45 * zygoloid thinks that System.IO.Strict will rarely be the implementation which is wanted
12:53:51 <shachaf> zygoloid: Oh, that would actually be nice.
12:54:29 <wavewave> zygoloid: I agree with you. ByteString is much better.
12:54:54 <wavewave> just in case that some people want. ;-P
12:55:36 <wavewave> I remember I used it some time ago when I was still uncomfortable with ByteString.
12:56:26 <zygoloid> i think i have to consider a 'readFile' API which uses 40x as much memory as the size of the file somewhat evil
12:58:31 <nejucomo> Wouldn't strict ByteString reading then lazy Text decoding be a fairly simple integration of strict ByteString IO and Data.Text.Lazy ?
12:58:41 <wavewave> Strict.readFile may be useful for just checking whether a strict implementation can solve some memory leak problem without changing whole program structure.
12:58:49 <nejucomo> (I am still quite a GHC performance noob, but slowly picking it up.)
12:59:21 <etpace> hmm... when rednering a doc, I seem to have lots of \NUL about.. (they come up as ^@ in vim), but if I just print instead of rendering, then I cant see the \NUL, any ideas?
12:59:59 <wavewave> nejucomo: lazy bytestring is a list of strict bytestring basically.
13:00:23 <wavewave> nejucomo; a strict bytestring is a singleton in lazy bytestring.
13:01:46 <sajkr> hello fellow haskellers.
13:02:03 <wavewave> so converting lazy to/from strict is fairly easy process.
13:02:14 <wavewave> sajkr: hi
13:02:23 <sajkr> :)
13:02:34 <wavewave> :)
13:02:42 <etpace> Basically: hPutStr h $ show ir <-- lots of  ^@, print ir <-- works fine (when ir :: Doc), does anyone know why?
13:03:14 <jimOTS> I'm having some trouble understanding the documentation of mersenne-random: http://hackage.haskell.org/packages/archive/mersenne-random/1.0.0.1/doc/html/System-Random-Mersenne.html
13:03:20 <rwbarton> well your terminal probably doesn't render NUL characters
13:03:37 <rwbarton> oh wait, print?
13:03:43 <rwbarton> oh never mind
13:03:46 <jimOTS> For instance, the example for getStdRandom referenced getMTRandom, but not getStdRandom
13:04:09 <etpace> Well, ideally the NUL should not be there rwbarton
13:04:19 <etpace> (im not sure why they are.. they are using the GHC llvm pretty printer)
13:04:19 <jimOTS> Also the large example at the bottom has an undefined variable 'g' that I think is an MTGen
13:04:28 <rwbarton> well yes, you must have NULs in your ir though
13:04:36 <etpace> do you know of a "hack" to remove them? simply adding a filter !=^@ is a utf-8 decoding error
13:04:51 <etpace> well, I'm using GHC's LLVM printer
13:04:54 <etpace> so im not sure whats going on there
13:05:04 <sajkr> instead of having a directly recursive type, one can write a functor which captures the structure of the type modulo recursion, and then take the fixpoint of that functor.
13:05:05 <rwbarton> that's pretty odd, I don't know either
13:05:12 <wavewave> jimOTS : yeah, it's not a complete documentation.
13:05:21 <sajkr> is there a common name for such a functor?
13:05:36 <jimOTS> wavewave: It seems worse than incomplete. It seems incorrect
13:05:45 <etpace> In the mean time, how would I remove NUL from a string?
13:06:02 <elliott> sajkr: Mu
13:06:07 <elliott> newtype Mu f = Mu (f (Mu f))
13:06:10 <wavewave> jimOTS: send an email to dons ;-)
13:06:17 <elliott> etpace: filter (/= '\NUL')
13:06:19 <rwbarton> :t filter (/= '\0')
13:06:20 <lambdabot> [Char] -> [Char]
13:06:43 <jimOTS> Is there a high quality PRNG replacement (or plugin) for System.Random that has correct documentation
13:07:06 <wavewave> jimOTS : System.Random is slow
13:07:23 <wavewave> there is a pure version of mersenne PRNG.
13:07:35 <etpace> doh, thanks
13:07:40 <sajkr> elliott: yes, i know, but what about its argument functor?
13:07:46 <jimOTS> wavewave: what should I use instead? I'm looking for something where my nterface doesn't have to change a whole lot
13:07:52 <elliott> sajkr: f? :p
13:08:03 <jimOTS> wavewave: I think useing a pure PNRG would require passing around state in a bunch of place
13:08:13 <sajkr> elliott: i think i encountered the phrase "shape functor" somewhere...
13:08:15 <wavewave> mesenne-random-pure64
13:08:36 <sajkr> elliott: but google doesn't agree. :)
13:08:50 <elliott> sajkr: heh, dunno then :)
13:08:54 <wavewave> jimOTS: pure version is better in parallelization though.
13:09:08 <jimOTS> wavewave: I don't care about parallelization for this application
13:09:56 <wavewave> jimOTS: anyway, for your purpose, mersenne library is still best except its documentation.
13:10:02 <elliott> <jimOTS> wavewave: I think useing a pure PNRG would require passing around state in a bunch of place
13:10:08 <elliott> jimOTS: just use State RNG a
13:10:11 <elliott> no passing at all, just like using it from IO
13:10:28 <jimOTS> elliott: don't I have to go stack my monads and change my type signatures then?
13:11:03 <sajkr> elliott: do you think "shape functor" is appropriate? i like it. :)
13:11:07 <elliott> jimOTS: that's why you abstract it into a type. this is standard haskell architecturing :P
13:11:10 <elliott> sajkr: it's nice, yes
13:11:27 <elliott> jimOTS: but... not _all_ of your code will use the RNG
13:11:34 <elliott> you don't have to use "the same monad everywhere"
13:11:44 <jimOTS> elliott: standard or not, I'm trying to avoid writing much more code
13:11:44 <wavewave> jimOTS: Is it much difficult to figure out how to use mersenne-random library with that rather incorrect documentation?
13:11:59 <jimOTS> It's furstrating to have the type system get in my way here
13:12:18 <elliott> jimOTS: it only gets in your way because you're not experienced yet...
13:12:27 <jimOTS> elliott: you don't know me
13:13:03 <wavewave> jimOTS: in the last long example of the haddock page, just missing random generator g can be obtained from newMTGen
13:13:23 <elliott> jimOTS: true, but i'm not sure of the relevance.
13:13:39 <byorgey> sajkr: I have heard the terms "shape functor", "structure functor", and "base functor" all used for that
13:13:51 <jimOTS> wavewave: The documentation says "There is a single, implicit, global random number generator of type StdGen", but getStdGen returns an IO MTGen
13:14:03 <jimOTS> Is the gloabl generator of type StdGen or MTGen?
13:14:08 <jimOTS> Or are there two?
13:14:22 <elliott> jimOTS: StdGen is the standard rng
13:14:25 <elliott> from System.Random in base
13:14:28 <jimOTS> elliott: Please don't make assumptions about my my experience level
13:14:34 <elliott> presumably the documentation is adapted from that
13:14:45 <jimOTS> do, what does getStdGne in mersenne-random return?
13:14:56 <elliott> what does the type signature say in the docs?
13:15:05 <elliott> jimOTS: I wasn't, I was going off "don't I have to go stack my monads and change my type signatures then?", which is a common issue experienced by those new to haskell
13:15:11 <wavewave> jimOTS: Just forget about StdGen. use only MTGen
13:15:23 <shurikas> @hoogle a -> IO ()
13:15:23 <lambdabot> Control.Concurrent.SampleVar writeSampleVar :: SampleVar a -> a -> IO ()
13:15:23 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
13:15:24 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
13:15:24 <jimOTS> elliot: it says: getStdGen :: IO MTGenSource Gets the global random number generator.
13:15:40 <illissius> what's the interaction in cabal between multiline freeform fields and indentation? (read: how should I indent multiline freeform fields?)
13:15:44 <elliott> jimOTS: then getStdGen :: IO MTGen.
13:16:19 <jimOTS> Yes, I know. My question is not "what type does it return?". My question is "What thing does it return?"
13:16:38 <jimOTS> I ask because the documentation says that there is aglobal random number generator of type StdGen
13:16:49 <elliott> yes, but that is from System.Random in base
13:16:52 <jimOTS> It does NOT say that there is a global random number generator of type MTGen
13:16:53 <rwbarton> that seems to be a typo (or a copy-paste error)
13:16:55 <elliott> this is a separate package with another type
13:17:01 <jimOTS> so you are saying this is a typo?
13:17:04 <jimOTS> I see
13:17:06 <elliott> so clearly it is going to return the global random generator that this package provides
13:17:37 <wavewave> jimOTS: indeed, the package's documentation is messed up.. anyway, now you seem that you almost figured out how to use it
13:18:59 <wavewave> jimOTS: by just looking at the source coe.. getStdGen is nothing but newMTGen Nothing
13:30:43 <shurikas> @hoogle IO a -> IO ()
13:30:44 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:30:44 <lambdabot> Control.Exception.Base block :: IO a -> IO a
13:30:44 <lambdabot> Control.Exception block :: IO a -> IO a
13:30:54 <shurikas> hm
13:31:45 <c_wraith> shurikas: what behavior do you want?
13:32:14 <shurikas> I am trying to write a simple console application which can respond to user commands
13:32:43 <sajkr> byorgey: speaking of shape/structure/base functors, do you think that decomposing (for example) an AST node type in such a manner and then progressively adding data such as type information by composing functors is worth the effort?
13:32:57 <hpaste> zhulikas pasted “so far...” at http://hpaste.org/54433
13:33:03 <Phyx-> :t interact
13:33:05 <lambdabot> (String -> String) -> IO ()
13:33:18 <zhulikas> so yeah, this is what I have so far
13:33:36 <zhulikas> no process returns [Char] everytime
13:33:37 <byorgey> sajkr: as in "Data Types a la Carte"?
13:33:46 <zhulikas> but instead of that I want it to be able to return some IO stuff
13:33:55 <zhulikas> like if user enters "Time", it should return system time
13:34:09 <byorgey> sajkr: it may or may not be worth the effort, depending on your specific use case.
13:34:18 <zhulikas> and that is IO ClockTime
13:34:29 <zhulikas> but at the same time I need to be able to return IO [Char]
13:34:32 <zhulikas> to print out
13:34:33 <elliott> sajkr: i like edwardk's strick for this
13:34:44 <zhulikas> so I need to generalize IO types into something
13:34:45 <elliott> sajkr: data a :> b = a (a :> b) :> b
13:34:52 <elliott> sajkr: a is your AST, b is an annotation like source information
13:34:57 <elliott> that pattern-matches nicely
13:35:07 <elliott> it's limited to things which fit that pattern though
13:35:43 <Phyx-> @src unless
13:35:44 <lambdabot> unless p s = if p then return () else s
13:36:20 <sajkr> byorgey: so that's where i saw that. thanks.
13:36:29 <Phyx-> zhulikas: that case a of ... could be replaced with "unless (null a) (putStrLn a)
13:37:20 <zhulikas> Phyx-, isn't it a syntactic sugar for what I did?
13:37:27 <rwbarton> zhulikas: well at some point you are going to have to convert ClockTime to [Char] anyway
13:37:28 <zhulikas> @type null
13:37:29 <lambdabot> forall a. [a] -> Bool
13:37:30 <rwbarton> s
13:37:46 <rwbarton> zhulikas, it is not syntactic sugar
13:37:51 <rwbarton> but it is equivalent, yes
13:38:00 <zhulikas> rwbarton, that makes sense. I can do that and work only with IO [Char] :)
13:38:18 <zhulikas> thanks
13:38:49 <sajkr> elliott: a :: * -> *, (:>) :: (* -> *) -> * -> *?
13:38:58 <zhulikas> hmm and I cannot pattern-match IO types I see :)
13:39:14 <elliott> sajkr: yeah
13:39:16 <zhulikas> does null work with IO types?
13:39:39 <elliott> sajkr: foo :: AST :> SrcLoc; foo (If (Blah ... :> a) ... :> b) = If (Bleh ... :> a) ... :> b
13:39:39 <rwbarton> null is for lists
13:39:49 <rwbarton> so, no.
13:39:52 <elliott> erm
13:39:55 <zhulikas> so I need to evaluate IO, right?
13:39:58 <elliott> sajkr: foo :: AST :> SrcLoc -> AST :> SrcLoc
13:40:01 <rwbarton> you need to execute it
13:40:02 <elliott> might want parens there :P
13:40:03 <zhulikas> @hoogle IO a -> a
13:40:03 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
13:40:04 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:40:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:40:08 <zhulikas> shit, that again
13:40:36 <zhulikas> rwbarton, data <- someIOstuff, right?
13:40:50 <rwbarton> yes
13:41:00 <zhulikas> well that's odd
13:41:15 <rwbarton> well, I'm not sure you can call your variable 'data'
13:41:19 <zhulikas> it seems that there is a mistake to do so :)
13:41:44 <zhulikas> I get IO, try to match it against a pattern, then return it as IO again
13:42:15 <elliott> zhulikas: try fmap?
13:42:16 <elliott> :t fmap
13:42:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:42:25 <elliott> fmap myFunctionPatternMatchingOnAList someIOAction
13:42:38 <zhulikas> O.O
13:42:50 <elliott> hmm in retrospect
13:42:55 <elliott> that fmap signature is not the most reassuring thing to see
13:42:59 <elliott> especially with lambdabot's kind annotations
13:43:11 <byorgey> (a -> b) -> f a -> f b    -- the important part
13:43:40 <zhulikas> I don't get it
13:43:59 <zhulikas> I mean how to use it in my case
13:44:31 <sajkr> elliott: it's nice, but i guess i want something like (,) SrcLoc, and compose that with my AST shape functor.
13:44:52 <elliott> sajkr: yeah. the constructor overhead will be really painful to pattern match with though
13:45:06 <elliott> sajkr: you might want to try the strathclyde haskell preprocessor. she has pattern synonyms
13:45:42 <nejucomo> I have some haskell source containing unicode in string literals, which compiles with GHC.  Attempts to read that file with Text.IO.readFile say: hGetContents: invalid argument (invalid byte sequence)
13:45:47 <zhulikas> @hoogle IO ClockTime -> IO [Char]
13:45:47 <lambdabot> Prelude show :: Show a => a -> String
13:45:48 <lambdabot> Text.Show show :: Show a => a -> String
13:45:48 <lambdabot> Test.QuickCheck.Text showErr :: Show a => a -> String
13:45:57 <zhulikas> oh, Show, not show
13:45:59 <nejucomo> Is this a problem with my locale?
13:46:01 <zhulikas> oh wait. show.
13:46:38 <sajkr> elliott: so that finally, instead of taking the fixpoint i can use Int/IntMap a la Data.Reify, and have both sharing and destructive updates.
13:46:43 * nejucomo starts relearning the locale voodoo on linux.
13:47:15 <elliott> sajkr: that's clever
13:48:14 <nejucomo> grr...
13:53:27 <sajkr> elliott: i did some finite automata transformation in python for an assignment (parsing class), used indirection through a dict(), so i figured why not do that in haskell. turns out Data.Reify does exactly that, but i kinda dislike the IO.
13:54:03 <elliott> sajkr: well, the IO is just because observable sharing is impure
13:54:46 <elliott> sajkr: the nice thing about Data.Reify isn't that it does sharing, because you can do sharing easily, it's that it lets you see sharing in haskell structures, so that you can process things like EDSLs written "recursively"
13:56:06 <sajkr> elliott: i got the impression that IO was there just to generate fresh Ints/Uniques.
13:56:34 <elliott> sajkr: no; observable sharing is impure
13:57:09 <elliott> sajkr: because it can distinguish e.g. (let ones = 1 : ones in ones) from (map (const 1) [0..])
13:57:40 <elliott> sajkr: Data.Reify uses StableNames to do this
13:59:59 <nejucomo> Ah, relearned export LANG=en_US.UTF-8
14:00:18 <mike-burns> I just learned that this morning.
14:00:23 <mike-burns> Changed my life.
14:02:48 <sajkr> elliott: hm, i just looked at the source, and it seems to me that IO could be avoided, if node ids were drawn from [0..] instead of using StableNames or Data.Unique...
14:02:56 <illissius> hmmmmf. if you have a Dynamic d, and pass (fromJust $ fromDyn d) which is a value of type (forall a. Typeable a => a) to a function of type (forall a. Typeable a => a -> r), am I wrong in concluding that nothing bad can actually result? typeOf works even on bottoms, so whatever the function tries to do with it via Typeable, if it's the right type it won't be bottom, and if it's the wrong type then it'll be bottom but Typeable won't let
14:02:57 <illissius> it be cast so it won't matter.
14:03:04 <zhulikas> I don't understand. 'fmap reverse getLine' works, but 'fmap printIO a' doesn't. (printIO :: [Char] -> IO ()), (a :: IO [Char])
14:03:19 <SgeoN1> Observable sharing?
14:03:47 <carpi> is function application by <space> left or right associative?
14:03:50 <carpi> left yea?
14:04:00 <carpi> and ($) make it right associative yea?
14:04:46 <sajkr> elliott: one can distinguish between two otherwise equal lists by giving each node an identity (an Int) and simply comparing the identity.
14:06:27 <SgeoN1> Space makes it left associative and is tightly binding, ($) is right assoc and loosely binding
14:06:30 <SgeoN1> So yes
14:06:52 <SgeoN1> *space is, and ($) is
14:07:14 <zhulikas> @hoogle IO a -> IO ()
14:07:14 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
14:07:15 <lambdabot> Control.Exception.Base block :: IO a -> IO a
14:07:15 <lambdabot> Control.Exception block :: IO a -> IO a
14:07:42 <copumpkin> [04:48:12 PM] <shurikas> @hoogle IO a -> IO ()
14:07:45 <copumpkin> [05:24:43 PM] <zhulikas> @hoogle IO a -> IO ()
14:07:48 <kniu> is there a channel for algorithmics?
14:07:55 <copumpkin> ತ_ತ
14:08:09 <zhulikas> copumpkin, short-term memory is short
14:08:12 <copumpkin> :)
14:08:23 <copumpkin> zhulikas: I understand
14:08:27 <zhulikas> didn't last for an hour
14:08:28 <copumpkin> zhulikas: I understand
14:08:35 <copumpkin> zhulikas: I understand
14:08:36 <zhulikas> :/
14:08:50 * copumpkin wonders what he was doing
14:10:40 <carpi> > max 30 $ max 40 $ min 90 $ 11
14:10:42 <lambdabot>   40
14:10:46 <carpi> >max 30 . max 40 . min 90 $ 11
14:11:00 <carpi> > max 30 . max 40 . min 90 $ 11
14:11:02 <lambdabot>   40
14:11:04 <sajkr> elliott: sharing is observable, but not in a way which interferes with purity. i mean, you observe it by being aware of the IntMap-Int sandwich your nodes are placed in, you explicitly transform your data into this form, and "observability" doesn't magically creep out into the rest of your program.
14:11:09 <sajkr> elliottt: amirite?
14:11:13 <carpi> why is there no difference between * and '.'
14:11:23 <carpi> s/*/$
14:12:39 <xenocryst> carpi: there is
14:12:51 <aninhumer> carpi: just not in that example
14:13:19 <rwbarton> the difference is that f $ g $ x is f $ (g $ x) while f . g $ x is (f . g) $ x
14:13:38 <byorgey> there is even a difference in that example.
14:13:44 <byorgey> they just happen to have the same result.
14:14:17 <byorgey> f $ g $ x = f (g $ x) = f (g x)
14:14:24 <byorgey> f . g $ x = (f . g) x = f (g x)
14:15:06 <noidea`> hi. cairo-0.11.1 calls for the package cairo-pdf, but cabal doesnt seem to be able to find it. Same error as after line 18 of this http://hpaste.org/41811 . Any suggestions?
14:15:35 <carpi> seems like $ is more syntactic sugar and '.' has real purpose
14:16:15 <rwbarton> carpi, i'd say that's more or less accurate though occasionally you can use ($) as an argument to a higher-order function
14:16:25 <SgeoN1> ($) is easily definable, and usually defined, in Haskell
14:16:33 <aninhumer> carpi: there are actual uses for $, but usually that is the case
14:16:56 <shoerain> kniu: if you count #algorithms, then yes
14:17:27 <aninhumer> I found cases where map ($ x) fs was useful (probably there was a better way to do it though...)
14:17:32 <zhulikas> time <- getClockTime
14:17:33 <kniu> shoerain, thanks
14:17:36 <zhulikas> this is executing, right?
14:18:17 <zhulikas> I imagine executing takes time, so I should minimize it as much as possible, right?
14:21:34 <charly__> hi there. i want to use the church function from wikipedia http://en.wikipedia.org/wiki/Church_encoding#Translation_with_other_representations in my program. but when i type for example "church 3" i always get the message "No instance for (Show (Church t0)) ..." any help?
14:21:45 <mike-burns> zhulikas: We don't know how performance analysis in Haskell works, in general.
14:21:57 <zhulikas> :o
14:22:04 <mike-burns> zhulikas: Laziness is confusing.
14:22:07 <shachaf> charly__: Well, you can't print out a Church-encoded number.
14:22:09 <zhulikas> but I guess you care about good design, right?
14:22:11 <shachaf> charly__: You can use it, though.
14:22:13 <zhulikas> whoa...
14:22:23 <zhulikas> so you mean laziness does so much to performance?
14:22:26 <shachaf> church 3 ("succ "++) "zero"
14:22:42 <rwbarton> I would suggest you not worry about performance.
14:22:43 <XexonixXexillion> charly__: or if you want a number, (church 3) succ 0
14:22:53 <Botje> laziness is hard, let's go shopping
14:22:53 <zhulikas> I worry about code design
14:22:54 <mike-burns> zhulikas: It's hard to promise you that `time <- getClockTime' actually is executing right there and then.
14:23:04 <shachaf> XexonixXexillion: Well, there's an easier way of turning 3 into the result of that...
14:24:09 <mike-burns> Is Church something charly__ defined, or is it an existing thing I didn't know about?
14:24:24 <cgroza> Hello everyone. I am looking at the Control.Applicative, and I do understand <*> and <$>, but still can't figure out the uses of <* and *>. Does anyone use them?
14:24:25 <charly__> no it's from wikipedia
14:24:27 <rwbarton> well there's a wikipedia page about it
14:24:35 <mike-burns> The data type in Haskell I mean.
14:24:47 <waterson> hey folks, i'm trying to define an array recursively in terms of earlier elements in the array (a la Ch 13 of A Gentle Introduction to Haksell)
14:24:48 <shachaf> mike-burns: I assume it's a standard Church-encoding of peano numbers.
14:24:50 <waterson> here's my code: http://pastebin.com/bwHTmuj2
14:24:50 <mike-burns> Can't he add `deriving (Show)' and be done with?
14:24:52 <mauke> The paste bwHTmuj2 has been copied to http://hpaste.org/54434
14:24:54 <shachaf> Oh, I have no idea.
14:24:54 <charly__> ok the succ command helps me. but is there no way to implement a show function?
14:25:06 <rwbarton> charly__: how did you define Church?
14:25:11 <charly__> for example if i want to see the function
14:25:12 <waterson> i'm stumped, since it ends up as a <<loop>> and I can't see how it's significantly different from the examples in GIH
14:25:27 <shachaf> Oh, it's just a type synonym.
14:25:29 <rwbarton> waterson: I'll guess you've defined an element in terms of itself
14:25:36 <shachaf> rwbarton: Wikipedia says type Church a = (a -> a) -> (a -> a)
14:25:51 <shachaf> Which is a sensible definition of Church.
14:25:53 <rwbarton> oh, no
14:26:02 <rwbarton> waterson: you're using an unboxed array
14:26:04 <mike-burns> Oh, I see.
14:26:09 <waterson> rwbarton: yes i have, but that seems to be what's happening here as well: http://www.haskell.org/tutorial/arrays.html
14:26:32 <waterson> the "fib" example works fine with unboxed arrays
14:26:41 <waterson> as does wavefront
14:26:59 <cgroza> Nevermind. I got it.
14:27:11 <rwbarton> it doesn't work for me
14:27:15 <rwbarton> (fib with UArray)
14:28:16 <rwbarton> it printed "ar: <<loop>>" when i compiled with optimizations
14:29:38 <waterson> rwbarton: odd, i'm using GHC 7.0.4 and it seems to work fine for me. hmm. (http://pastebin.com/f2G1mJek)
14:29:41 <mauke> The paste f2G1mJek has been copied to http://hpaste.org/54435
14:30:07 <mlb-> I am considering writing a custom log parser for work, would this problem lie in the domain of Haskell's strengths?
14:30:33 <Botje> what are you going to do with it afterwards?
14:30:40 <mlb-> I am also learning haskell (reading learnyouahaskell)
14:31:00 <rwbarton> that's not a boxed array--you wrote Array, not UArray
14:31:08 <rwbarton> I mean, not an unboxed array
14:31:23 <waterson> oh, sigh.
14:31:48 <waterson> rwbarton: that is it. thank you.
14:32:28 <rwbarton> An unboxed array depends on all its values
14:32:51 <waterson> yes, that makes sense.
14:33:41 <mike-burns> mlb-: Yes, much of that is within Haskell's strengths.
14:34:00 <mike-burns> Especially if you're doing intense parsing and not something that's better suited for Perl.
14:34:09 <mlb-> mike-burns: okay, cool. Just wanted to check if I had the right hammer for this nail.
14:34:28 <cgroza> Is there a way to define a function similar to !! for tuples?
14:34:51 <mlb-> The logs are big (usually capped at 5gigs), often rely on keeping some state around to see "where" the product crashed, and what it was doing
14:34:57 <mike-burns> cgroza: No.
14:35:45 <cgroza> mike-burns: Is there a datatype similar to tuples that allows it? I know index access is possible in python.
14:36:08 <mike-burns> mlb-: It's going to take you longer to do it in Haskell than in what you already know, the first time. This is merely because you'll be learning a ton of Haskell and parsing and whatnot along the way.
14:36:19 <mike-burns> cgroza: Array?
14:36:53 <mike-burns> I'm suspicious of your desire to index into a data structure.
14:37:06 <mlb-> mike-burns: I thought haskell would be a bit more apt than trying to do some finite-state-machine stuff in Erlang
14:37:18 <mike-burns> mlb-: Quite likely.
14:37:27 <cgroza> mike-burns: I am just asking out of curiosity. I only access my tuples via pattern matching. :D
14:37:30 <mlb-> and haskell seems a bit more... disciplined than learning snobal4 or something
14:37:37 <mike-burns> Heh.
14:37:50 <mike-burns> Give it a shot in Haskell, mlb- . You'll at least have fun.
14:38:00 <mlb-> oh, for sure
14:38:28 <mike-burns> cgroza: It's hard to answer "data type like tuple but with indexing" without having a problem domain to give more context, you know?
14:38:53 <mlb-> been falling in love with functional languages since I picked up erlang - a more concise lambda syntax and having things like function composition is quite pleasant
14:39:07 <mike-burns> Yeah!
14:39:10 <mlb-> (built into the syntax, I mean)
14:39:18 <mike-burns> There's a lot to like about both languages.
14:39:23 <cgroza> mike-burns: yeah. ok.
14:40:11 <mlb-> much like the binary parsing in erlang is surprisingly easy (and possibly fun)
14:42:44 <mike-burns> Haskell has more generally useful libraries, from what I've seen.
14:43:04 <mike-burns> (All I've seen of Erlang has been conversations with my girlfriend and no actual programming on my part.)
14:43:28 <mike-burns> (So I could be wrong and maybe she's missing some awesome Erlang libs.)
14:45:23 <c_wraith> erlang has one incredibly good library, that almost all erlang programs use: the open telecom platform (OTP)
14:45:57 <c_wraith> It handles all kinds of software lifecycle management issues.
14:46:03 <usererror> which part of erlang is not pur-functional programming btw?
14:46:25 <c_wraith> the part where you can read input into values absolutely anywhere
14:46:36 <c_wraith> that is, you can do IO anywhere
14:46:59 <mike-burns> Oh yeah, the OTP is totally fantastic. Agreed there.
14:47:01 <usererror> are all variables immutable?
14:47:15 <c_wraith> yes, all erlang values are immutable
14:55:05 <Philonous_> cgroza:  Indexing into tuples can be done with some advanced type magic, but it's ugly and not really all that useful; yet it's a great way to push one's understanding of Haskell's type system
14:56:51 <DukeDave> I'd like to pair together a non Ord type with an Int, and make the tuple Ord, to this would it be legal to write:
14:56:51 <DukeDave> instance Ord (Int, MyType) where compare (i,_) = compare i          ?
14:57:28 <Botje> compare takes two arguments
14:57:40 <Philonous_> :t comparing fst
14:57:41 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
14:57:42 <Botje> so compare (i,_) (j,_) = compare i j
14:57:55 <Botje> DukeDave: however, there is already an Ord instance for tuples
14:58:11 <Botje> so unless you allow overlappinginstances...
14:59:25 <rwbarton> another "solution" is to make your "non Ord type" an instance of Ord with compare _ _ = Eq
15:00:36 <DukeDave> Botje: There is, but it requires all 'parts' of the tuple to be Ord, I believe?
15:00:55 <Botje> DukeDave: yes.
15:01:05 <Botje> DukeDave: so you have to ask haskell nicely to allow overlapping instances
15:01:32 <DukeDave> Botje: My intuition said to just make a new type, specific to the pairing, and make that Ord
15:01:51 <DukeDave> rwbarton: What's the consensus on this?
15:02:09 <Botje> oh, if it's really a new type instead of a tuple, go ahead
15:02:22 <DukeDave> Botje: Well, it kind-of-is..
15:02:38 <DukeDave> But then most tuples are new types, aren't they?
15:03:03 <DukeDave> Except perhaps for the a convenient return type for things like splitAt
15:03:15 <DukeDave> rwbarton: There's a debate between me and someone else on my 'team' about where a unique ID belongs in a record, or outside it..
15:04:03 <DukeDave> I'd rather put the ID inside the record, make the record Eq, Ord, and then collect them in Set MyRecordType
15:04:44 <DukeDave> They suggest that the the ID doesn't belong in there, and we collect with IntMap MyRecordType,
15:05:14 <DukeDave> Thoughts? :D
15:05:28 <mike-burns> How just barely vague.
15:05:30 <rwbarton> if you want to be able to look up a record by its ID, the Set MyRecordType solution won't work
15:05:59 <mike-burns> Sure it will, it's just less performant.
15:06:07 <rwbarton> well OK
15:06:14 <rwbarton> I was going to say that but it seemed unnecessary :P
15:06:28 <mike-burns> Well depending on the number of items it might be just as fast.
15:06:36 <mike-burns> Maybe.
15:07:02 <rwbarton> I mean obviously the two are interconvertible so "it doesn't matter which one you use"
15:07:23 <mike-burns> Once you've done a lookup by ID and gotten the MyRecordType, do you need the ID again?
15:07:29 <mlb-> man, I'd love to see an OTP library for haskell, and hot-code reload ing too,
15:07:41 <mike-burns> Indeed.
15:07:56 <rwbarton> If you can't have two records with the same ID then the IntMap makes more sense
15:08:18 <DukeDave> Mm, I guess IntMap does make more sense
15:08:19 <mike-burns> If you need the ID after the lookup then the Set makes more sense.
15:08:21 <DukeDave> Thanks guys
15:43:41 <aavogt> is there a data structure (on hackage?) that behaves like  Map a (Map b x), except doesn't emphasize looking up by 'a' first?
15:44:20 <JoeyA> Map (a, b) x ?
15:44:51 <JoeyA> Or do you mean looking up either by a or by b?
15:45:04 <JoeyA> similar to two separate indexes on a database table
15:45:13 <aavogt> the latter
15:46:11 <Saizan> there's happstack-ixset (or whatever it's called now), which basically a bunch of Map's
15:46:18 <Saizan> +is
16:20:51 <stribor> guys is there a way to split strings like this "first part of string,second part of string"  to [fist part of string,second part of string]
16:21:04 <kmc> http://hackage.haskell.org/package/split
16:22:01 <geheimdienst> stribor: there's also a function for that in the MissingH package. alternatively, Prelude has "break", which might be approximating what you want
16:22:05 <mike-burns> Spliting strings is so hot right now.
16:22:15 <geheimdienst> > break (=='l') "lolcats"
16:22:15 <lambdabot>   ("","lolcats")
16:22:17 <stribor> mike-burns: very hot:)
16:22:23 <companion_cube> you mean, it's so webscale
16:22:26 <stribor> geheimdienst: thanks
16:22:27 <geheimdienst> > break (=='b') "abcabc"
16:22:28 <lambdabot>   ("a","bcabc")
16:23:48 <stribor> geheimdienst: can you exclude separator first encountered
16:25:35 <geheimdienst> stribor: not directly (break is a little crummy). you'd have to do "drop 1" on that part. also, note how break splits only at the first opportunity, and leaves later ones alone
16:25:53 <geheimdienst> ... so you'd probably want to call recursively
16:26:03 <stribor> geheimdienst: yes..i can do that...thank you so much
16:28:11 <Axman6> > text $ map pred "Bynbo7"
16:28:12 <lambdabot>   Axman6
16:28:19 <Axman6> hmm
16:28:24 <geheimdienst> stribor: you can (or should?) do it yourself as a learning exercise, but really, what i would recommend is the MissingH package. it has some other useful things too http://hackage.haskell.org/package/MissingH
16:29:01 <stribor> geheimdienst: let me look into that
16:30:38 <Sgeo> http://hackage.haskell.org/packages/archive/MissingH/1.1.1.0/doc/html/Control-Concurrent-Thread-Utils.html
16:30:54 <Sgeo> Is that not just combining them with >>= and doing that in another thread?
16:31:13 <Sgeo> Is is, except with a return ()
16:31:16 <kmc> runInThread action callback = forkIO $ action >>= callback >> return ()
16:31:17 <mike-burns> Also the split package, stribor .
16:31:25 <mike-burns> As has been mentioned.
16:31:40 <kmc> wonder how the ease of use compares to http://hackage.haskell.org/packages/archive/spawn/0.3/doc/html/Control-Concurrent-Spawn.html#g:1
16:31:51 <kmc> i like the ultra simplicity of spawn :: IO a -> IO (IO a)
16:34:55 <ddarius> Sgeo: Going from threads to events is really easy.
16:35:19 <ddarius> Or I should say, going from a blocking interface to a non-blocking one is really easy.
16:39:03 <SgeoN1> Hmm, I guess
16:42:42 * hackagebot concrete-typerep 0.1.0.1 - Binary and Hashable instances for TypeRep  http://hackage.haskell.org/package/concrete-typerep-0.1.0.1 (ReinerPope)
16:58:14 <ybit> A poll asking if haskell should have a mascot: https://docs.google.com/spreadsheet/viewform?formkey=dFpic3dzZkVtcW5yZkVWbFNuckpyWmc6MQ
16:58:43 <Bynbo7> Axman6: fuck off, i cbf'd ghosting you
16:59:38 <Eduard_Munteanu> That's something about self-esteem :P
17:01:17 <ybit> i created some images and sent them to haskell-cafe: http://imgur.com/a/CTFJZ
17:01:30 * ybit goes afk for a few days
17:08:02 <kmc> cute drawings :)
17:08:32 <kmc> what would be the point of an official mascot?
17:09:56 <Eduard_Munteanu> Not sure about the point, but yeah, the graphics are nice.
17:10:58 <geheimdienst> it's just a bit of fun?
17:11:54 <shachaf> Haskell should not have a mascot.
17:12:06 <bwright> geheimdienst: Worst pun ever.
17:12:50 <stribor> guys I have data like this  - > data SomeData = arg1    |  arg2.....Is there way to have succh function to return something like this - > function arg1 arg2 = Maybe arg1
17:12:58 <kmc> if it's just a bit of fun then there's no need to ask IRC and reddit and have a poll about it
17:13:08 <kmc> (Maybe x) isn't an expression; it's a type
17:14:08 <stribor> kmc: could you show me example how to return that type then
17:14:09 <PiRSquared17> Maybe (*pun intended*) he meant Just x ?
17:14:09 <shachaf> data Just x = Maybe x
17:14:24 <stribor> oh ok
17:14:28 <stribor> i see
17:15:02 <shachaf> stribor: My line contained counterfactual information, by the way; sorry if it caused any confusion.
17:15:13 <PiRSquared17> > let f arg1 arg2 = Just arg1 in f 6 7
17:15:14 <lambdabot>   Just 6
17:15:25 <PiRSquared17> Is that what you meant?
17:15:25 <stribor> shachaf: its ok...lol....thanks anyway
17:15:30 <stribor> PiRSquared17: yes
17:16:08 <PiRSquared17> @type \x y -> Just x
17:17:30 <lambdabot> forall t a. a -> t -> Maybe a
17:17:35 <mike-burns> :i Maybe
17:17:37 <mike-burns> No? It doesn't do :i ?
17:17:45 <mike-burns> @info Maybe
17:17:45 <lambdabot> Maybe
17:17:45 <mike-burns> Well. Thanks.
17:17:51 <PiRSquared17> @type Just . const
17:17:58 <lambdabot> forall a b. a -> Maybe (b -> a)
17:18:14 <PiRSquared17> oops
17:18:25 <PiRSquared17> @type const . Just
17:18:38 <lambdabot> forall b a. a -> b -> Maybe a
17:26:50 * ddarius should probably get one of these new-fangled browsers with there hot rod JS engines.
17:27:07 <PiRSquared17> V8?
17:27:56 <PiRSquared17> ddarius: using Lynx ?
17:27:58 <PiRSquared17> :p
17:28:26 * Eduard_Munteanu thought even lynx used webkit by now :P
17:31:05 <PiRSquared17> Lynx with AJAX and Canvas getContext("text") :p
17:42:09 <KitB> I need some help understanding the api for Graphics.Rendering.Chart
17:42:26 <KitB> How on Earth do I set the axis sizes myself?
18:01:31 <PiRSquared17> !hoogle Graphics.Rendering.Chart
18:01:39 <PiRSquared17> @hoogle Graphics.Rendering.Chart
18:01:39 <lambdabot> package Chart
18:01:39 <lambdabot> package barchart
18:01:39 <lambdabot> package GoogleChart
18:01:45 <PiRSquared17> @hoogle Graphics
18:01:46 <lambdabot> package graphics-drawingcombinators
18:01:46 <lambdabot> package graphics-formats-collada
18:01:46 <lambdabot> package graphicsFormats
18:01:53 <PiRSquared17> @hoogle Graphics#
18:01:54 <lambdabot> No results found
18:02:24 <KitB> PiRSquared17: package Chart
18:04:01 <PiRSquared17> Hmm... not sure
18:06:33 <KitB> I've been reading the source and haddock docs for a while now
18:06:33 <KitB> I think I might almost be there
18:06:35 <KitB> Seriousl though
18:06:35 <KitB> This is way too hard to find
18:07:43 * hackagebot unix-time 0.1.0 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.0 (KazuYamamoto)
18:08:32 <PiRSquared17> Yes, it is.
18:08:49 <PiRSquared17> But a lot of hackage is like that...
18:17:30 <aavogt> KitB: laxis_override_ ?
18:23:54 <KitB> aavogt: Well that would seem the obvious thing
18:24:01 <KitB> But bugger me if I can't figure out how to make that actually do what I want
18:24:31 <aavogt> you want to make the graph include a larger range than the points you have?
18:24:39 <aavogt> or the other way around
18:24:43 <KitB> I want to make the graph have fixed range
18:24:53 <KitB> Because I am generating hundreds of graphs
18:25:03 <KitB> And I want them all to be on the exact same scale
18:29:15 <aavogt> KitB: you tried replacing the existing AxisFn with makeAxis?
18:29:37 <KitB> aavogt: Please do elaborate
18:29:54 <KitB> I'm rather tired and probably should be coding right now but I feel like this should be simple
18:32:48 <aavogt>  layout1 ^: layout1_bottom_axis ^: laxis_generate ^= (\ _ -> makeAxis show ([0 .. 10], [], [0, 2 .. 10]))
18:33:42 <aavogt> KitB: I'm not sure that works, but that's what I would start with
18:33:51 <aavogt> (looking at the haddocks)
18:40:33 <KitB> Well that worked
18:41:46 <KitB> But I can't figure out how to change the title *and* make it fixed.
18:52:56 <pshrmn> A strange question. Hi! :-D I'm a recursive data structure. I am being read from a context that gives the id of my children for future lookup. In order to lookup a child I need to use the IO monad and an ID (an external database is being used). But it seems unnecessary to keep track of the id, when I can just use haskell's laziness and keep track of the ID by using applied functions like f :: ID -> IO a (where ID is provided). Oh noes!!! 
18:55:46 <Axman6> you can't get a pure value out of that
18:56:44 <Axman6> well, you sort of can. but anyway, that's not how laziness works. laziness is only really usable for pure computations, where the answer is guaranteed to be the same, no matter what time you inpsect it
18:57:42 <shachaf> pshrmn: I don't understand your question (if there was one).
18:57:43 <shachaf> What are you trying to do?
18:57:49 <pshrmn> thanks, umm
18:58:42 <geheimdienst> fwiw, i enjoyed the question, but i didn't really understand what exactly was "oh noes"
19:01:25 <monochrom> Hi, I am a co-recursive program. nice to meet you, recursive data structure.
19:01:34 <mike-burns> This has turned very Smalltalk.
19:01:50 <kmc> i seem to be a verb
19:02:15 <shachaf> monochrom: Are you going to consume pshrmn?
19:02:34 <monochrom> nah, that's a job for d/dx
19:02:38 <mike-burns> I didn't understand how laziness worked into that non-question.
19:02:43 * hackagebot ghc-mod 1.0.0 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.0 (KazuYamamoto)
19:02:51 <mike-burns> Three exclamation points; clearly he's crazy.
19:03:26 <pshrmn> Suppose (roughly) data Obj = Value Object; and trying to read a binary file containing {Value, Location of Next Object}. I function f :: Location -> IO Object. I want to be able to lazily read an Object. So f is only evalulated when needed.
19:03:34 <strager> I think they assumed lazy ~= futures/promises
19:04:12 <mike-burns> Oh, a stream?
19:04:40 <geheimdienst> people, go easy. maybe he could have been a little more explicit about what exactly the question was. that's all, in my view
19:04:59 <pshrmn> I really have no idea what my question is. lol
19:05:39 <strager> pshrmn: I think I see what you're saying.
19:06:16 <strager> Though I don't know the question and I don't know any answers.  ;P
19:06:25 <Floodman> Hhhhhh.
19:06:37 <tomprince> pshrmn: What is the type you want to get out?
19:06:55 <tomprince> It probably has to be IO (somethinge)
19:07:05 <geheimdienst> pshrmn: i find that often, a question turns out to have an obvious answer, once i have written up the situation so that others could understand it. so there's value in that
19:07:44 <pshrmn> Basically a way to store a way to mix an impure functions where only pure functions belong...which I am fairly sure violates intergalactic law.
19:07:53 <shachaf> pshrmn: There exists a way to do what you want -- "lazy IO" -- but you might not actually want to do it.
19:08:06 <shachaf> It does violate intergalactic laws. It has "unsafe" in front of its name.
19:08:32 <nexion> hey guys.. if I have a "do" with forkIO on the last line, can I get that to typecheck? adding a putStrLn after it works, but I'm sure there's a clean way
19:08:42 <kmc> return ()
19:08:51 <kmc> is an IO action of type "IO ()" which does nothing
19:09:02 <nexion> ty :)
19:09:06 <geheimdienst> shachaf, pshrmn: i thought that very broadly, iteratees are "lazy io done better". maybe you want to look into that
19:09:22 <kmc> nexion, you can also use Control.Monad.void
19:09:24 <kmc> :t Control.Monad.void
19:09:25 <lambdabot> Not in scope: `Control.Monad.void'
19:09:28 <kmc> @hoogle Control.Monad.void
19:09:28 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
19:09:29 <lambdabot> package void
19:09:29 <lambdabot> package hVOIDP
19:09:29 <shachaf> geheimdienst: Well, it a specific type of context. And "done btter" is arguable.
19:09:37 <shachaf> Certainly "done different".
19:09:56 <nexion> which way is preferred?
19:10:00 <aavogt> code using lazy IO will look simpler
19:10:31 <ddarius> "Done explicit."
19:10:58 <geheimdienst> nexion: return () is fine
19:11:47 <ddarius> When did we add void to Control.Monad?
19:12:09 <geheimdienst> ddarius: pretty recently. i think it was at gwern's insistence
19:12:11 <kmc> GHC 7.0 or so
19:12:52 <geheimdienst> must have been in the past year, is my guess
19:14:21 <ddarius> Sqlite may be -too- much of a toy for my purposes.
19:14:42 <Axman6> sqlite's a toy now? o.O
19:14:46 <Floodman>  .
19:15:03 <PiRSquared17> Floodman: ?
19:15:13 <Floodman> PiRSquared17  , !
19:15:18 <geheimdienst> Floodman: your message was unreadable. switch to utf-8 please
19:15:24 <PiRSquared17> èëîëé
19:16:03 <kmc> ẙo̸ṷrͮ ̾m̤e̤s̼s̙ăg͆e̎ ͟wͮa̻s̀ ͤu͈n̼r̿e͘a͜d͠ḁbͤl̓e̺.̚ ͓s͢wͫi͍t͕cͩh̗ ̉t̚o̘῾u͗t́f̙-̵8̈ ͤp̬l̊ḛa̿s̯ë
19:16:35 <geheimdienst> kmc, a chicken walked over your message, please resend
19:16:59 <kmc> @quote zalgo
19:16:59 <lambdabot> zalgo says: import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
19:18:02 <shachaf> @where+ zalgo import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
19:18:02 <lambdabot> It is stored.
19:19:36 <tgeeky> so - here's a conversation starter:
19:19:52 <tgeeky> I've noticed watching SPJ videos that he *often* (perhaps upwards of 80% of the time) closes his eyes when explaining functions
19:20:21 <tgeeky> any thoughts? do you guys do this when thinking or communicating haskell code to others?
19:20:26 <byorgey> haha
19:20:34 <byorgey> SPJ closes his eyes when explaining a lot of things =)
19:20:46 <kmc> that's in order to see the machine elves
19:21:00 <Axman6> it reduces the IO he needs to perform
19:21:12 <tgeeky> do you gifted bastards all just see the lambda-matrix when you close your eyes?
19:21:26 <geheimdienst> tgeeky: i see IO actions
19:23:41 <byorgey> tgeeky: I don't notice the lambds anymore, I just see map, fold, zygohistomorphic prepromorphism...
19:24:08 <PiRSquared17> zygohistomorphic prepromorphism
19:24:09 <PiRSquared17> ?
19:24:24 <PiRSquared17> Joke?
19:24:42 <irene-knapp> well, it's a real term, but it's somewhat of an in-joke
19:24:48 <shachaf> "real" term.
19:24:50 <irene-knapp> @google zygohistomorphic prepromorphism
19:24:51 <lambdabot> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
19:24:51 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki
19:25:13 <geheimdienst> irene-knapp: so it's like "monad"?
19:25:24 <irene-knapp> haha
19:25:26 <irene-knapp> sorta
19:25:29 <byorgey> hahaha
19:25:46 <byorgey> Monads: Just a Big In-Joke
19:26:16 <shachaf> An in-joke so big, you can never get out of it.
19:26:17 <waterson> sounds like something from harry potter ;)
19:26:20 <kmc> sigh
19:26:25 <shachaf> Oops.
19:26:28 <kmc> shachaf, that's not how monads work
19:26:40 <shachaf> kmc: I know. It's how the in-joke works.
19:26:56 <geheimdienst> kmc: but the IO in-joke, one of the most popular ones, does work like that
19:26:58 <kmc> sigh
19:27:08 * shachaf is annoyed by any serious usage of "you can never get out of a monad".
19:27:16 <shachaf> Let's stop in-joking before kmc gets mad and /quits again.
19:27:17 <kmc> so why make jokes which suggest that
19:27:27 <mike-burns> Hahaha, I love the idea of "monad" being an in-joke.
19:27:30 <Saizan> so an in-joke is a like a spacesuit?
19:27:33 <byorgey> everyone knows monads are actually like a burrito traveling through space full of apples, but if you take an apple out you have to put two oranges back in as you travel backwards through time to before the apple was there in the first place
19:27:41 <Axman6> Saizan: in a burrito
19:27:45 <ddarius> mike-burns: Look up the date on the Haskell 1.0 Report.
19:27:51 <geheimdienst> Saizan: yes, you are either in the spacesuit or not
19:27:54 <kmc> i'm just sick of the standard monad joke templates
19:28:02 <kmc> and i think they probably alienate beginners to some degree
19:28:03 <mike-burns> ddarius: Heh, I had forgotten about that!
19:28:13 <Saizan> byorgey: i guess neutrinos are involved then
19:28:14 <shachaf> kmc: The goal of jokes is rarely information transfer.
19:28:20 <geheimdienst> byorgey: thanks for clarifying
19:28:32 <mike-burns> In-jokes are for re-enforcing community.
19:28:41 <shachaf> I agree in general, though, really.
19:28:46 <byorgey> Saizan: probably.  Those CERN people are actually doing monad research.
19:28:49 <kmc> people come here to ask a question, they're told "no, monads are actually easy", and then they get 20 minutes of incomprehensible in-jokes
19:28:56 <kmc> easy to feel like the joke's on you
19:28:59 <geheimdienst> shachaf: except lolcats, of course. the knowledge of the ages is conveyed by lolcats.
19:29:22 <kmc> shachaf, I understand that the point is not information transfer.  i'd think the point is humor
19:29:27 <ddarius> geheimdienst: Which says something about the current ages.
19:29:33 <geheimdienst> kmc: that is actually true, in all seriousness
19:29:37 <shachaf> kmc: And it fails at that point pretty badly too? :-)
19:29:43 <ddarius> shachaf: Yes.
19:29:44 <kmc> that's what i'm saying.  others are free to disagree
19:29:47 <mike-burns> We should be more helpful for people who come in with IO questions.
19:29:49 <irene-knapp> mm
19:30:10 <irene-knapp> well, I mean, I think most of us realize at this point that beginners don't really need to understand monads, and try to convey that message
19:30:14 <shachaf> I actually do agree.
19:30:18 <irene-knapp> rather than saying they're easy, which, even if true, is unhelpful
19:30:29 <kmc> beginners do need to understand monads fsvo 'beginner'
19:30:39 <kmc> and saying they're easy does serve a purpose
19:30:45 <geheimdienst> well fsvo 'understand'
19:30:55 <kmc> these days i try to say something like 'simple but abstract'
19:31:06 <ddarius> fsvo f,s,v, and o
19:31:08 <mike-burns> We're trying to combat all the "monads are complex" tutorials out there, when we say that they're easy.
19:31:20 <kmc> trying to convey that understanding is difficult because there's so little to it, not because there's so much to it
19:31:35 <kmc> both are valid reasons for a concept to be difficult
19:31:38 <irene-knapp> OH YES!  Stack trace!  Well, simple-cost-center trace.
19:31:47 <irene-knapp> now I can finally debug this freaking thing!
19:31:51 <mike-burns> Heh.
19:31:53 <irene-knapp> that only took a week :(
19:31:59 <mike-burns> Ouch.
19:32:04 * ddarius should write a text-analysis program and measure the proportion of discussion versus meta-discussion on #haskell over time.
19:32:28 <irene-knapp> point of order.  we're spending too much time on points of order.
19:32:33 <Saizan> i was worrying about the frequency of meta too
19:32:34 <mike-burns> It's important that we are sorta unified-ish in the way we help people with common questions.
19:33:02 <kmc> now we can have some in-jokes about the frequency of meta-discussion about in-jokes
19:33:33 <Saizan> at least going meta has replaced c++ rants, it seems
19:33:44 <mike-burns> True!
19:33:57 <Saizan> though those were often more informative for me :)
19:34:30 <aavogt> is there a way to use http://hackage.haskell.org/package/ad to look at propagating (independent) variance in calculated values?
19:34:55 <geheimdienst> i think a discussion of how to best teach haskell is on-topic and important. it's not meta overhead imho
19:35:09 <aavogt> I'm running into trouble taking arguments that can be both passed to diff, and calculate the actual values
19:35:26 <irene-knapp> yes, certainly, geheimdienst
19:35:59 <aavogt> I think to do that I need -XRank2Types, but then those functions passed can only depend on specific classes
19:36:04 <mike-burns> It's easy to think that we can just paste a link to something on "why you can get the 'a' out of 'IO a'" and they'll be happy, but if we can explain it quickly and easily that's probably best.
19:36:14 <mike-burns> Er, why you CAN'T.
19:36:41 <kmc> wait, why should these things not be links?
19:37:21 <kmc> linking to a wiki page should speed convergence to a good explanation
19:37:21 <mike-burns> I was about to say "because they've searched Google and found those links already", but maybe not. Likely not.
19:37:26 <kmc> almost certainly not
19:37:34 <mike-burns> I'm convinced.
19:37:46 <kmc> one of the important roles of #haskell is to recommend good articles over spacesuit burrito articles
19:38:11 * aavogt settles for accepting  (forall a. RealFrac a => a -> a)
19:38:25 <shachaf> Usually people don't listen even on getting a link to such an article.
19:38:40 <ddarius> Usually people don't listen.
19:38:51 <geheimdienst> faq -- why can't you extract the a from IO a? you can, but only if the function that does the extracting is itself in IO
19:38:53 <mike-burns> I'd love for us to stop shouting about unsafe* when they ask any question.
19:39:05 <kmc> functions aren't 'in IO'
19:39:14 <aavogt> yes. I have a problem and nobody is helping!
19:39:20 <kmc> you can't extract the a from IO a, because there is no 'a' inside it
19:39:29 <mike-burns> aavogt: If I knew anything about what you were saying, I'd help!
19:39:43 <kmc> how can you extract the cake from a recipe?
19:40:07 * shachaf likes "getLine :: IO String contains a String in the same way that /bin/ls contains a list of files"
19:40:37 <ddarius> shachaf: I also like that.
19:40:57 <irene-knapp> okay wtf :(
19:41:03 <irene-knapp> this thing isn't crashing now :(
19:41:13 <irene-knapp> kmc: that's a good way of putting it
19:41:47 <kmc> basically i am skeptical of the value of the "pure functions and IO functions" analogy
19:42:06 <ddarius> It's not completely unreasonable.
19:42:47 <monochrom> humans suffer from priority inversion. case study #1: while you and someone are conversing in person (it may be even a scheduled meeting), your phone rings, you prefer to answer the phone and even converse with the phone, and ditch the person already in front of you and the conversation already going on.
19:43:01 <mike-burns> I really like the idea behind this blog post: http://neilmitchell.blogspot.com/2010/01/haskell-io-without-monads.html
19:43:02 <geheimdienst> yes, and you have certainly a point. but at the same time i don't think for a beginner the terminology is so terribly off when he asks "how to get the char out of getc / scanf / etc."
19:43:02 <kmc> it's an incomplete description, and it encourages a particular type of common confusion
19:43:19 <kmc> weigh that against the difficulty of explaining what an IO action is directly
19:43:21 <monochrom> case study #2: you ask a question in IRC. one answer is a url. another answer is 10 minutes of text wall. you prefer the text wall.
19:43:24 <irene-knapp> monochrom: not ME.  yes, some rude people do that!
19:44:09 <newsham> IO action is an easy one
19:44:16 <newsham> its a computer program :)
19:44:45 <kmc> perhaps programs manipulating programs seems foreign and exotic
19:45:00 <kmc> if so, we are kind of fucked
19:45:10 <irene-knapp> hmm
19:45:17 <newsham> program construction kit
19:45:32 <geheimdienst> haskell is a big dsl for writing IO actions
19:45:51 <kmc> that's a pretty big 'domain'
19:46:03 <kmc> Python is a DSL for writing computer programs
19:46:04 <ddarius> Haskell is a DSL for writing programs!
19:46:22 <irene-knapp> Agda is a DSL for crashing my brain
19:46:24 <newsham> the difference is that programs are first class entities in haskell and not python
19:46:33 <kmc> meh, functions are first class entities in python
19:46:39 <mike-burns> One complexity is that they need to use functions with 'm a' in their type, which leads them down monads, which leads them to "oh I've heard that's hard".
19:46:40 <newsham> but functions arent programs
19:46:41 <kmc> and they can have side effects
19:46:51 <kmc> which gets you first-class actions by a different means
19:47:15 <newsham> you can make first class actions in python but the syntax is rather heavy
19:47:30 <newsham> or maybe a better way to say it is you can make first class semicolons in python?
19:47:41 <mike-burns> Hah.
19:47:44 <geheimdienst> kmc: i guess the analog might be that python is a dsl for controlling and commanding a certain interpreter ...
19:47:45 <irene-knapp> hah
19:47:50 <rwbarton> even in C you have void (*)(void)
19:48:04 <aavogt> preflex: seen edwardk
19:48:05 <preflex>  edwardk was last seen on #haskell-blah 2 days, 7 hours, 33 minutes and 52 seconds ago, saying: shachaf: hah
19:48:28 <kmc> *shrug*
19:48:49 <kmc> i doubt this conversation is going to yield different results from the previous 900 times
19:49:03 <mike-burns> What are some things we want out of this conversation?
19:49:28 <monochrom> yikes
19:49:32 <mike-burns> Less unsafe*, less monad in-jokes as the first response?
19:50:26 <irene-knapp> I want a cookie
19:50:57 <shachaf> We want kmc not to get sick of #haskell and leave forever.
19:51:01 <shachaf> Before I do it, anyway.
19:51:26 <geheimdienst> shachaf, before you get sick of it? are you in danger?
19:52:01 <shachaf> geheimdienst: It'll likely happen someday! Too much IRC isn't good for one.
19:52:17 <hpaste> irene-knapp pasted “hmm” at http://hpaste.org/54438
19:52:23 <mike-burns> Tonight, in a very special #haskell, shachaf and kmc get sick of the channel.
19:52:41 <irene-knapp> okay, so, the above SCC-stack trace
19:52:47 <irene-knapp> is when I try to run haddock on base
19:52:52 <irene-knapp> (while building GHC)
19:53:14 <monochrom> you try to divide by 0 while happy-parsing?
19:53:21 <irene-knapp> looks to me like it's trying to read a Rational somewhere in the source that has invalid syntax
19:53:24 <monochrom> oh, then nevermind
19:53:27 <irene-knapp> well, not me, but the code does!
19:54:20 <irene-knapp> what is the syntax of a Rational?  maybe it's distinctive enough that I could grep the source for it?
19:54:33 <irene-knapp> it must be in a comment somewhere, since it doesn't crash the actual build, only the haddock run
19:54:42 <shachaf> > 1 / 2 :: Rational
19:54:43 <lambdabot>   1 % 2
19:54:49 <irene-knapp> hmm
19:55:12 <monochrom> look for a % sign
19:55:43 <irene-knapp> right, doing that
19:57:05 <Guest82424> hi all
19:57:29 <Guest82424> :-)
19:57:43 * hackagebot husk-scheme 3.4.2 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.4.2 (JustinEthier)
20:06:08 <irene-knapp> hmmmm
20:06:10 <irene-knapp> I'm not finding anything obvious
20:06:17 <irene-knapp> maybe I can instrument the parsing code
20:06:45 <geheimdienst> irene-knapp: i've been looking at http://hackage.haskell.org/trac/ghc/browser/compiler/utils/Util.lhs?rev=f32f90b5bae79688b56951904f626569d91cb46d , but it's not obvious to me how this could cause a div-by-zero. my best guess is to take line 930 and whack at it with different values, and see if you can make it crash
20:07:12 <geheimdienst> (readRational is at 958, readRational__ at 927)
20:07:21 <irene-knapp> ah!  thanks, I appreciate the effort
20:08:34 <geheimdienst> you're welcome :) it's also somewhat informative to google "util readrational". it finds some commits that are only a few months old and concern readRational
20:08:46 <irene-knapp> ah!  good thought :D
20:10:54 <irene-knapp> hm
20:11:00 <irene-knapp> there's not actually any division in that code :/
20:12:53 * irene-knapp puts in a call to trace and sees if that works
20:47:18 <ddarius> The Sqlite documentation uses the term "manifest typing" in almost the exact opposite way that I understand it.
20:47:28 <irene-knapp> ddarius: oh?
20:48:30 <ddarius> http://www.sqlite.org/different.html
20:49:34 <irene-knapp> ah hm, yes
20:49:41 <irene-knapp> it's my biggest beef with sqlite actually
20:49:48 <irene-knapp> though I remain an advocate of it
20:51:03 <ddarius> Reading most of that makes me want to punch the developers in the face.
20:51:24 * irene-knapp nods
20:52:47 <elliott> SQLite is amazingly engineered, I just wish it engineered something nicer.
20:53:06 <newsham> sqlite the adventure game?
20:53:42 <irene-knapp> I want to write a database engine in Agda :D
20:53:48 <irene-knapp> for fun, not to actually use
20:53:58 * irene-knapp would note that she doesn't actually even know how to write Hello World in Agda yet
20:53:59 <ddarius> Writing database engines is fun.
20:54:03 <irene-knapp> yep
20:54:29 <newsham> putStrLn "Hello World"    ?
20:54:36 <irene-knapp> really?  oh :)
20:54:46 <irene-knapp> that's remarkably similar to Haskell haha
20:54:53 <newsham> not sure.  do people actually "run" agda?
20:54:56 <newsham> or just compile it?
20:55:03 <elliott> agda has an IO type and all that.
20:55:05 <newsham> come to think of it, i remember hearing there's an "FFI" to haskell
20:55:28 <newsham> bbl
20:55:42 <elliott> http://www.cse.chalmers.se/~nad/listings/lib/IO.html
20:55:49 <elliott> putStrLn : String → IO ⊤
20:55:49 <elliott> putStrLn s = putStrLn∞ (toCostring s)
21:05:06 <hpaste> aavogt pasted “error propagation” at http://hpaste.org/54439
21:05:33 <aavogt> the -XRank2Types is kind of ugly there
21:06:47 <ddarius> aavogt: Why do you say that?
21:06:48 <aavogt> and maybe it can be done more efficiently (I don't follow how the ad package works, but this is very similar)
21:07:43 <aavogt> ddarius: because using the minimal class constraints would mean I have to duplicate the those lnv functions
21:17:30 <copumpkin> we want higher-rank subtyping in GHC now!
22:44:18 <QinGW> > :t (.)
22:44:19 <lambdabot>   <no location info>: parse error on input `:'
23:05:41 <performance_> > data Bird { name ::String, age ::Int }
23:05:42 <lambdabot>   <no location info>: parse error on input `data'
23:05:56 <performance_> > data Bird =  Bird { name ::String, age ::Int }
23:05:57 <lambdabot>   <no location info>: parse error on input `data'
23:06:01 <performance_> :t Bird
23:06:02 <lambdabot> Not in scope: data constructor `Bird'
23:06:40 <Axman6> you can't define data types in lambdabot
23:06:42 <Jafet> lambdabot does not allow you to (flip Bird).
23:07:01 <performance_> b1::Bird  b1 = { "asdf", 20 }
23:09:50 <performance_> when creating a value, does one always have to provide the field name ? isnt there a way to not have to use the field name?
23:10:17 <Jafet> Bird :: String -> Int -> Bird.
23:10:36 <Jafet> @where cheatsheet
23:10:37 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
23:10:57 <Cale> performance_: you can write  Bird "Canary" 2
23:11:23 <augur_> copumpkin: ping
23:12:22 <performance_> how abt if there are nested types, example if i have an owner field, which happens to also have personName and personAge  fields?
23:12:58 <performance_> wait dont answer
23:13:03 <performance_> i'm going to try first
23:13:57 <Jafet> Cale will answer you, whether you like it or not
23:19:08 <performance_> sucks :( every single constructor has to be used :(
23:38:07 <performance_> is there a function like choose in Test.QuickCheck that chooses outside a subrange within a given range?
23:38:39 <performance_> e.g. chooseOut 0 2 5 10 should choose outside [2,5] but in [0,10]
23:42:33 <carpi> why are many functions common between Prelude and Data.List?
23:43:05 <frerich> carpi: I think it's because lists are like the bread-and-butter data structure in Haskell, they're omnipresent. So Prelude exports stuff from Data.List for convenience.
23:43:06 <drbean> Is there a haskell function that will return the same string that ghci's :t command returns?
23:44:05 <aavogt> drbean: Data.Typeable might be more useful. But something in the ghc-api (or maybe hint) can get you that string.
23:44:08 <aavogt> @hackage hint
23:44:08 <lambdabot> http://hackage.haskell.org/package/hint
23:45:09 <frerich> performance_: You mean, 'chooseOut 0 2 5 10' would pick a random element out of [0,1,6,7,8,9,10]?
23:45:21 <performance_> yes
23:45:26 <carpi> so in ghci if i import Data.List while already using Prelude..which modules functions will I be using if ?
23:46:07 <trichomonad> quick question: which function joins list of lists of stuff into a list of stuff?
23:46:26 <koala_man> concat
23:46:49 <trichomonad> oh, how could I forget! :) thanks!
23:47:15 <performance_> frerich: im trying to write one using frequency. if one is already there, please do let me know
23:49:19 <koala_man> trichomonad: also, http://www.haskell.org/hoogle/?hoogle=[[a]]+-%3E+[a]
23:50:54 <trichomonad> Oh, It can search by signature! Thanks a lot!
23:53:50 <frerich> performance_: Maybe something simple using 'take' and 'drop' would cut it, too. Like '\start p q end -> let xs = [start..end] in take p xs ++ drop (q+1) xs'
23:54:37 <performance_> frerich: it needs to work for floats too
23:54:38 <augur_> someone remind me what "late binding" means in OO
23:55:06 <performance_> augur_: the function to be executed is decided at run time
23:55:07 <frerich> augur_: It means delaying the decision which function is actually called until runtime
23:55:16 <augur_> oh ok
23:55:23 <augur_> so dynamic dispath, essentially
23:56:20 <frerich> performance_: You could generalize it to any sort of list by passing the list as a dedicated argumetn (instead of uing start/end positions)
23:56:56 <performance_> right now i'm stuck converting a floating point percentage to Int because frequency expects an Int
23:57:35 <frerich> performance: Like 'chooseOut xs p q = take p xs ++ drop (q+1) xs' cold be called with 'chooseOut [0.1,0.2..1] 2 5'
23:58:24 <frerich> performance: Actually, I think the function doesn't *quite* do what you want: it yields a list with all the possible choices, (everything except the [2..5] range) - you still have to pi ck a random element frmo that.
