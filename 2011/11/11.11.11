00:00:07 <liyang> Hmm.
00:00:37 <edwardk> with 7.3+ (7.2?) you can use the new default declarations
00:00:56 <edwardk> but you still need to write the line for each instance, if not the body
00:01:32 <edwardk> showRecord :: a -> (String, [String])    default showRecord :: Show a => (String. [String]); showRecord x = (show x, [])
00:01:42 <edwardk> would make it so you only have to write instance ShowRecord ByteString
00:01:54 <edwardk>  no body for anything that is already Show'able
00:02:36 <liyang> Ooh! Didn't know about the default declarations.
00:02:44 <Sgeo|web> What's the difference between TVs and FRP?
00:02:47 <edwardk> they are shiny and new
00:03:18 <Sgeo|web> Which is "they"?
00:03:34 <edwardk> Sgeo|web: 'default declarations' so neither ;)
00:03:48 <Sgeo|web> Oh
00:05:03 <edwardk> the tangible value stuff was conal's composable guis where you could visually manipulate inputs and get outputs, and then pipeline those together
00:05:18 <edwardk> i confess i never really grokked the point
00:05:44 <earthy> edwardk: the point is to make mvc obsolete
00:05:59 <earthy> or... rather... declarative and functional
00:06:29 <edwardk> earthy: i gathered that as the goal. i'm not just sure that i buy that either is actually a practical path towards meeting that end ;)
00:06:54 <earthy> well... I'm not sure it isn't either. ;)
00:09:24 <Sgeo|web> Iteratees are monads?
00:09:39 <Sgeo|web> This makes me feel happy
00:12:08 <Sgeo|web> So, are Iterators and Enumeratees essentially safe replacements for when I might be tempted to use a lazy I/O _list_?
00:12:41 <edwardk> yes
00:12:55 <edwardk> as is 'ListT done right'
00:13:22 <Sgeo|web> What other types of lazy I/O are tempting? Mostly I think about lists
00:15:21 <hpaste> poin pasted “mode” at http://hpaste.org/53890
00:15:59 <Sgeo|web> A lazy I/O Map sounds tempting...
00:16:14 <shachaf> poindontcare: You can't maximumBy on a Data.Map, can you?
00:16:24 <shachaf> You probably want to convert it to a list first.
00:16:47 <shachaf> Also, your paste would be much easier to read if you wrote types in.
00:16:48 <edwardk> shachaf: you can
00:16:55 <edwardk> shachaf: Data.Foldable.maximumBy
00:17:03 <shachaf> Oh.
00:17:03 <edwardk> :t Data.Foldable.maximumBy
00:17:04 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => (a -> a -> Ordering) -> t a -> a
00:17:28 <shachaf> Well, that's still essentially the same thing, what with Foldable being the toList class. :-)
00:17:42 <shachaf> But I didn't know about that.
00:17:46 <shachaf> poindontcare: Is that the maximumBy you're using?
00:18:20 <edwardk> to be fair it does do a slightly better join using foldr1 and your comparison function
00:18:23 <edwardk> er job
00:19:18 <shachaf> Is there a function like foldr/foldl that will use foldr1/foldl1 if the list is non-empty?
00:19:30 <shachaf> Assuming that the function you're folding with is really expensive, I suppose.
00:19:34 <augur> are there any good libraries for generating graph diagrams/hasse diagrams in haskell?
00:20:02 <augur> possibly multi-dimensional ones, or with arbitrary graphical annotations?
00:20:13 <Sgeo|web> shachaf: and if the list is empty, wouldn't it just return the starting value?
00:20:19 <edwardk> http://hackage.haskell.org/package/diagrams-lib-0.4.0.1 can do lots of crazy things but i know none of its internals
00:20:40 <edwardk> shachaf: the tricky part is that some containers don't know the result is empty for a while
00:21:43 <edwardk> and by the time they do, you've the the whole result list. so you might as well just convert to a list, and then do your constructor check for the first cons/nil and go from there
00:23:31 <shachaf> edwardk: I just mean foldr/foldl for lists.
00:24:25 <shachaf> As in foldr f z [] = z, foldr f z [x,y] = f x y
00:25:12 <edwardk> yes
00:25:24 <shachaf> It's certainly conventional to give f and z satisfying forall x. f x z = x anyway.
00:25:33 <Blkt> good morning everyone
00:25:52 * shachaf tries to figure out what the "yes" is to. :-)
00:26:24 <edwardk> shachaf f z xs = case toList xs of (x:xs) -> foldr1 ….; [] -> z
00:26:34 <shachaf> Right.
00:26:49 <edwardk> is what i was trying to say above in ~4am strung out mode ;)
00:26:52 <shachaf> I meant whether that function is actually defined anywhere.
00:27:06 <edwardk> oh, good luck
00:27:08 <shachaf> Or makes much sense to use, in general. Probably not.
00:28:06 <edwardk> woot. skyrim finally installed. my attention span just officially cut in half
00:28:31 <shachaf> Although I can imagine fun f (error "oops") xs being nicer than foldr1 f xs. Though I suppose the same could be accomplished by a foldr1 returning a Maybe.
00:28:51 <shachaf> In fact, a safeFold1 seems like a better solution to that problem should it possibly ever come up.
00:29:24 <edwardk> the main issue is that you wind up doing the loop iteration through Maybe
00:29:35 <edwardk> which means you construct and throw away a lot of Just's
00:30:51 <shachaf> safeFoldr1 f z [] = Nothing; safeFoldr1 f z l = Just (foldr1 f l) -- ?
00:31:17 <edwardk> look at Data.Foldable.foldr1's default definition
00:32:57 <shachaf> But that's not a problem if you take safeFoldr1 as a primitive, is it?
00:35:30 <edwardk> ultimately you'd need to roll it into some kind of typeclass if you want it on general structures
00:35:31 <Sgeo|web> Why is Data.Foldable.foldr1's default definition problematic?
00:36:15 <augur> edwardk: thanks, ill check it out
00:37:16 <shachaf> Sgeo|web: mf x (Just y) = Just (f x y)
00:37:29 <shachaf> edwardk: I just meant for this to be on lists, though. :-)
00:37:39 <edwardk> shachaf: oh then *shrug*
00:37:40 <shachaf> I suppose it's special-purpose enough that someone can write it if they want it.
00:38:40 <shachaf> I'm surprised Foldable doesn't have toList as its primitive, or at least a possible primitive.
00:39:47 * Sgeo|web is going to write an evil Haskell library
00:40:43 <Sgeo|web> Or maybe not
00:40:47 <Sgeo|web> I want to though
00:41:53 <Sgeo|web> Is there a compiler option to prevent all inlining?
00:43:11 * Sgeo|web is planning promiscuous use of unsafePerformIO
00:51:06 <Phyx-> Sgeo|web: i only know of the noinline pragma
00:53:35 <Sgeo|web> Do top-level unsafePerformIOs run in any particular sequence?... wait, they're still only performed lazily, right, so the idiom of top-level IO-based variable creation is based on basically ensuring that it gets created once, at first access?
00:53:41 <shachaf> Sgeo|web: What/why are you doing?
00:54:16 <Sgeo|web> shachaf: Library for treating Haskell as though it were a strict language that allowed side-effects
00:54:28 <Sgeo|web> I did say it was evil
00:55:00 <flux> I seriously doubt that's going to work :)
00:55:11 <flux> at least not without disabling many of ghc optimizations
00:59:41 <Sgeo|web> I _suspect_ that things will still sequence properly
01:00:40 <Sgeo|web> Ooh, I should make things Maybes underneath, so that the joys of null can be experienced
01:01:23 <poindontcare> shachaf: yeah
01:01:59 <Sgeo|web> Syntactically I can't really do anything to make a = 5; a = 6 compile
01:02:11 <Sgeo|web> I think syntactically is the wrong word there
01:02:22 <Sgeo|web> But I don't see a way for me to really break that
01:07:22 <shachaf> Sgeo|web: a := 5; a := 6?
01:08:37 <Sgeo|web> shachaf: I can't do that at top-level, can I?
01:08:49 <Sgeo|web> Just.. inside something else
01:09:41 <shachaf> Sure. That's what do was (not) invented for!
01:11:06 <shachaf> @hackage BASIC
01:11:06 <lambdabot> http://hackage.haskell.org/package/BASIC
01:11:44 <shachaf> http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html
01:13:07 <Sgeo|web> I feel like there's nothing interesting I can ever do
01:13:29 <Sgeo|web> Even ABUSING THE CORE CONCEPTS OF HASKELL ITSELF someone else done first, and in actually interesting ways
01:13:45 <sp3ctum> heh
01:14:23 <shachaf> Plenty more abusin' left to do.
01:14:38 <shachaf> @google full employment theorem
01:14:40 <lambdabot> http://en.wikipedia.org/wiki/Full_employment_theorem
01:15:04 <Saizan> Sgeo|web: if you are quick you can abuse the new 7.4 features
01:15:34 <shachaf> Saizan: Better yet, start abusing polymorphic kinds now.
01:16:16 <shachaf> Type-check everything by hand, and when support gets merged into GHC, release packages that use them immediately.
01:16:43 <shachaf> Sgeo|web: Anyway, you're not going to be able to compete with augustss for Haskell abuse.
01:17:46 <shachaf> preflex: seen augustss
01:17:46 <preflex>  augustss was last seen on #haskell 2 days, 8 hours, 56 minutes and 42 seconds ago, saying: > div (-1) 2
01:17:52 <Sgeo|web> I wasn't even aware until now that there was competition to be had
01:18:07 <Sgeo|web> I thought I could sweep the field with half-baked notions
01:18:54 <ddarius> augustss wrote the first Haskell compiler, has won IOCCC multiple times, and has probably won one of the IOHCCs.
01:21:29 <shachaf> We need to bring IOHCC back.
01:21:55 <shachaf> Seems like Haskell has a lot of potential.
01:23:02 <shachaf> http://www.haskell.org/pipermail/haskell/2004-August/014387.html -- import renaming?
01:24:22 <shachaf> Hmm, apparently that existed in 1.2.
01:25:13 <hpaste> sanjoyd pasted “Better way?” at http://hpaste.org/53892
01:25:36 <sanjoyd> Am I repeating something Haskell already has?
01:26:38 <Sgeo|web> KH is ... being lame
01:27:18 <Sgeo|web> The right half of that program, with 2 exceptions I think, is commented out
01:29:44 <ion> data qualified Foo = Foo { bar :: Bar; baz :: Baz } ▬▬▶ Foo.bar :: Foo → Bar, Foo.baz :: Foo → Baz
01:30:27 <shachaf> The way . is overloaded is evil.
01:33:43 <Sgeo|web> shachaf: huh?
01:33:51 <osfameron> eeek!  huge unicode arrows!
01:34:51 <shachaf> Sgeo|web: ?
01:37:33 <Sgeo|web> <shachaf> The way . is overloaded is evil.
01:38:58 <shachaf> Sgeo|web: It's an operator and also used for qualified modules.
01:42:27 <jeltsch> Hi, HackageDB shows me build failures for several of my packages, because it cannot find a proper base package.
01:42:46 <shachaf> jeltsch: That usually comes with GHC, not from Hackage.
01:42:55 <shachaf> Sounds like your GHC installation is messed up.
01:43:08 <jeltsch> The build logs contain messages like these:
01:43:10 <jeltsch>     base-4.3.1.0 was excluded because of the top level dependency base -any
01:43:38 <jeltsch> shachaf: It should have nothing to do with my GHC installation, since HackageDB cannot build my package.
01:43:38 <Phyx-> shachaf: he's talking about packages that were uploaded to HackageDB
01:43:57 <Phyx-> has nothing to do indeed with his local GHC
01:44:56 <Phyx-> jeltsch: dw, it's not just you, hackage seems to be f'ed
01:45:12 <Phyx-> jeltsch: I get these http://hackage.haskell.org/packages/archive/Hs2lib/0.5.5/logs/failure/ghc-7.2
01:45:18 <jeltsch> I see that HackageDB uses GHC 7.2 these days. Could it be that it can only use the base package that comes with 7.2?
01:45:23 <Phyx-> the GHC 7.2 installed on these seems broken
01:46:38 <sanjoyd> Does && impose any ordering, like in imperative languages?  I mean, is (not null foo) && ((head foo) == 5) safe?
01:46:49 <ddarius> That's a syntax error.
01:46:58 <sanjoyd> Sorry, I mean (null foo) && ((head foo) == 5)
01:46:58 <ddarius> (&&) evaluates from left to right.
01:47:05 <jeltsch> sanjoyd: Not really an ordering, but yes, (&&) is not commutative.
01:47:29 <jeltsch> sanjoyd: If the first evaluates to False, then the second can be undefined (errornous).
01:47:37 <sanjoyd> jeltsch: okay, thanks.
01:47:39 <jeltsch> You will get False nevertheless.
01:47:52 <jeltsch> lambdabot: False && undefined
01:47:57 <ddarius> @src (&&)
01:47:57 <lambdabot> True  && x = x
01:47:57 <lambdabot> False && _ = False
01:48:07 <ddarius> says everything
01:48:24 <jeltsch> @help
01:48:24 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:48:29 <jeltsch> list
01:48:30 <Phyx-> ddarius well put :)
01:48:34 <jeltsch> @list
01:48:34 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:49:00 <jeltsch> lamdabot: This doesn’t tell me the shortcuts.
01:49:08 <jeltsch> I mean, the shortcut for expression evaluation.
01:49:23 <jeltsch> . False
01:49:27 <jeltsch> @ Fasle
01:49:39 <jeltsch> How can I make lambdabot evaluate an expression?
01:49:44 <jeltsch> And wasn’t there some other bot?
01:50:09 <Phyx-> > 5
01:50:13 <lambdabot>   5
01:50:16 <Phyx-> > id 4
01:50:18 <lambdabot>   4
01:50:45 <Phyx-> hmm are my warnings too wordy? http://p.zhox.com/spkbqqyg
01:51:37 <jeltsch> > False && undefined
01:51:38 <lambdabot>   False
01:51:43 <jeltsch> > undefined && False
01:51:45 <lambdabot>   *Exception: Prelude.undefined
01:51:59 <jeltsch> sanjoyd: See above.
01:54:40 <Sgeo|web> It would be kind of cool if it could, in fact, avoid evaluating the lesser defined one if possible. But that's kind of a nonsensical idea, although I think I've heard of a library that does both in separate threads then checks the first to return?
01:54:59 <ddarius> That would be parallel and.
01:57:46 <jeltsch> Sgeo|web: Conal Elliott’s unamb operator probably lets you do this.
01:58:31 <jeltsch> Should be something like this: x `parAnd` y = (x && y) `unamb` (y && x)
01:59:15 <ddarius> It definitely lets you do this.
02:02:34 <alang> Can I write a function like 'isNum :: a -> Bool' which returns True if a's type is instance of Num, and false otherwise?
02:03:10 <shachaf> alang: You can kind of write functions like that sometimes, but why do you want to?
02:03:11 <ddarius> No.
02:03:29 <amtal> Might be doable via SYB or something similar.
02:03:32 <shachaf> ddarius's answer is better than mine.
02:03:57 <shachaf> You can write isNum :: Num a => a -> Bool; isNum _ = True, though.
02:04:09 <Sgeo|web> I remember being told that type information doesn't exist at runtime. I'm not sure how true that is, but ... does that make sense?
02:04:50 <alang> shachaf: the problem is that I want to use this on an existentially quantified data type, which is not instance of Num
02:05:04 <ddarius> alang: A Bool is useless.
02:05:38 <alang> ddarius: in what sense?
02:06:18 <ddarius> alang: If that function were implementable at that type (which it is not except as const True/False) using it wouldn't provide you with any evidence that the type was, in fact, an instance of Num, so you would not be able to use the fact even if it were accurate.
02:06:58 <Phyx-> grrrrrr (╯°□°）╯︵ ┻━┻
02:07:13 <alang> ok agreed
02:07:59 <alang> can i write a function like this then; isNum :: a -> Either a (Num a => a)
02:08:23 <ddarius> There are (a variety of) ways to package the Num dictionary with your existential, so that you can get it if it exists or otherwise get nothing, detectably.
02:08:50 <quicksilver> not without using problematic extensions
02:08:57 <quicksilver> typeclasses are open
02:09:06 <ddarius> alang: Not with that type, for multiple reasons, but ultimately you can't do it fully polymorphically since it would violate parametricity.
02:09:19 <quicksilver> so the property of "not-being-a-Num-instance" is not closed under module composition
02:12:57 <alang> ddarius: ok, I am aware of ways to pack the Num dictionary with my existential, but I was hoping be able to do it without having to modify the existential (because it comes from a library).
02:14:25 <ddarius> alang: You can make a type class with a numDict :: a -> Maybe NumDict method, but then you have to write the instances for every type.
02:14:49 <ddarius> There are things you might be able to do to avoid needing to write those instances using crazy hackery.
02:15:13 <quicksilver> I think the general rule is, if you are trying to write something "IF x IS NOT AN INSTANCE OF y", then you're fighting the system.
02:15:21 <quicksilver> typeclasses don't want to do that. Don't use a typeclass.
02:15:29 <amtal> And if you fight the law, it tends to win.
02:15:48 <quicksilver> typeclasses are overused anyway. If in doubt don't use them in the first place.
02:16:17 <amtal> I've heard something like that said before: what counts as "overused"?
02:16:31 <amtal> Should typeclasses be restricted to really general, ever-present things like monoids and monads?
02:16:32 <quicksilver> people using them when they'd be better off using something else.
02:17:09 <quicksilver> it's not a intended to be a religious point but a practical one - there are other ways of solving problems and I see typeclasses used when the other way  would be easier.
02:17:52 <amtal> There's some code like the regex stuff, where typeclasses seem to make it way nastier than it should be. Is there another pattern to provide one-interface, multiple-implementations?
02:18:11 <quicksilver> of course
02:18:13 <quicksilver> data types.
02:18:35 <quicksilver> data Frobnitzer = { frobnitz :: Foo -> Bar }
02:18:45 <quicksilver> erm
02:18:52 <quicksilver> data Frobnitzer = Nitz { frobnitz :: Foo -> Bar }
02:19:18 <quicksilver> create as many values of that type as you which, each is a different implementation of that interface
02:19:40 <amtal> So two modules might define two different Nitz.frobnitz definitions, and you can swap between them by changing the include.
02:20:38 <quicksilver> no.
02:20:50 <quicksilver> they're just values.
02:21:02 <quicksilver> two modules might define different values of type Frobnitzre
02:21:08 <quicksilver> you use whichever one you want.
02:21:11 <Ferdirand> and then it becomes incredibly confusing when you want to combine pieces of code that uses frobnitzers from different modules ?
02:21:20 <quicksilver> not remotely, no.
02:21:30 <shachaf> Ferdirand: Much less confusing than with type classes, probably.
02:21:33 <quicksilver> unless you find all code which uses more than one value of each type confusing.
02:21:39 <Ferdirand> that was in remark to amtal, quicksilver was too fast
02:21:41 <quicksilver> OHNO! This code uses '1' and also '7'!!!!
02:21:53 <shachaf> Passing a Nitz around is approxiamtely the same thing as passing a function :: Foo -> Bar around, in this case.
02:21:59 <shachaf> I mean, a Frobnitzer.
02:22:01 <quicksilver> of course.
02:22:13 <amtal> Ferdirand: possibly, but the typeclass thing in the regex libraries is downright scary :)
02:22:17 <quicksilver> but a more complex "interface" might have more than just the one function
02:22:21 <quicksilver> but that is the point, anyhow
02:22:31 <quicksilver> amtal: the regex typeclass is just (excessive) overloading
02:22:31 <shachaf> quicksilver: Sure, that wasn meant in the way of explanation, not criticism. :-)
02:22:52 <quicksilver> IIRC there are unoverloaded versions too
02:23:08 <quicksilver> btu the hideousness of the API does serve a useful purpose. It discourages people from using regexps at all :)
02:23:29 <shachaf> That's a terrible way of doing that.
02:23:30 <amtal> Hah. Yeah, that's kinda malicious but an effective way to encourage parser combinators :)
02:23:37 <shachaf> Make a good API and then stick unsafe in front of every function in it.
02:24:19 <Ferdirand> oh I misunderstood what you meant. What I find incredibly confusing is two modules defining different, but identically named and similarly operating types
02:24:34 <quicksilver> Ferdirand: yes, that would be confusing.
02:24:40 <quicksilver> :)
02:25:15 <shachaf> Ferdirand: Like ByteString.Lazy?
02:25:20 <Ferdirand> shachaf: spot on
02:27:54 <alang> so to be more specific about my problem: I want to plot some data which is in a existential, but I can only plot Doubles. If the data is instance of Real, then I can plot it via realToFrac. So I'd like to be able to do plot it if  it's Real, but somehow fail otherwise
02:29:20 <quicksilver> why do you have data inside an existential in the first place?
02:29:54 <quicksilver> basicaly the problem is that, for something inside a "Num" existential, the only thing you can do with it is what you can do with 'Num' methods.
02:30:22 <quicksilver> none of the 'Num' methods that springs to mind has the ability to detect "am I a real, if so provide my Real instance"
02:30:28 <quicksilver> so, can't be done.
02:30:31 <alang> yea I used Num for my example, but in fact I am interested in Real
02:30:47 <alang> sorry about the confusion
02:30:49 <quicksilver> it's inside a 'Real' existential?
02:30:53 <alang> no
02:32:04 <shachaf> Real is an amusing type class.
02:32:06 <shachaf> @src Real
02:32:06 <lambdabot> class  (Num a, Ord a) => Real a  where
02:32:06 <lambdabot>     toRational      ::  a -> Rational
02:32:07 <alang> http://hackage.haskell.org/packages/archive/zoom-cache/0.5.1.0/doc/html/Data-ZoomCache-Types.html
02:32:33 <alang> a ZoomReadable existential
02:36:23 <quicksilver> alang: ok well that's easy then.
02:36:32 <quicksilver> alang: ZoomReadable is a subclass of Typeable.
02:36:41 <quicksilver> you can just use 'cast'
02:36:45 <quicksilver> @hoogle cast
02:36:47 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
02:36:47 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
02:36:47 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
02:37:23 <quicksilver> alang: just try casting it to Double,Float,Int,anything else
02:37:29 <liyang> So try casting to every known Real type?
02:37:40 <quicksilver> yes.
02:37:44 <liyang> lulz
02:37:51 * quicksilver shrugs
02:38:14 <quicksilver> you have to recover static type information somehow
02:40:44 <alang> quicksilver: ok thanks!
02:41:22 <quicksilver> alang: the general point is that this is not in *general* possible for an arbitrary existential.
02:41:34 <quicksilver> alang: the class needs to provide some useful information - methods - to recover
02:49:13 <quicksilver> alang: ...fortunately 'Typeable' does that in a fairly general way.
02:49:31 <quicksilver> although for your particular application an even better typeclass would explicitly have a way to recover 'Reals'.
03:04:18 <alang> quicksilver: hmm I'm not sure what you meant by your last comment
03:05:11 <quicksilver> well to avoid you having to try every type one by one
03:05:46 <quicksilver> your ideal typeclass would contain a maybeToDouble :: a -> Maybe Double
03:05:46 <quicksilver> or something similar.
03:06:03 <ddarius> quicksilver: It could just have a Real constraint.
03:06:19 <quicksilver> ddarius: no, because they're not always Real
03:06:33 <alang> hmm right
03:07:05 <quicksilver> alang: it wasn't a profound point :) Just emphasising that how much information you can recover is determined solely by the methods of the class that is existentially bound.
03:07:12 <quicksilver> because all you can possibly do is all those methods.
03:07:15 <ddarius> quicksilver: It could just have a maybe a type that reveals a Real constraint.
03:07:17 * alang nods
03:07:23 <quicksilver> ddarius: :)
03:07:55 <ddarius> In particular, there's no way to recover any type information from exists a. a
03:12:34 <whald> i'm looking at the ("-hy") allocation profile of my program while reading in a rather large data set, and it says it's about 30% of actual data, and the rest is of type "[]". as I'm reading the data into a list this is somehow expected
03:13:02 <whald> my actual data consists of 3 floats, so is the observed overhead reasonable?
03:13:55 <whald> (my actual data is a single-constructor data type which takes three floats)
03:15:40 <whald> and is there a nice drop-in replacement for that list? i imagine something like an array doubling the size when the capacity is reached. this would give some benefit even in the worst case here
03:15:43 <int-e> if you have a list of those, that will use 2 tags + 2 pointers overhead per list element; if the target is a 64 bit architecture that's already more than the data itself (3 words). So I think 30% is reasonable.
03:16:10 <whald> int-e: thanks for confirming this
03:16:47 <int-e> using Array will save one tag and one pointer per entry; an unboxed array would be most efficient, but harder to access.
03:17:22 <int-e> (oh and if the arrays are not mutable then you'll be copying them from time to time which also costs memory -- so it's not a clear win.)
03:18:57 <whald> int-e: the copying is expected, and amortized adding an element is still O(1) -- plus the much better memory locality is likely to help as well. i'm mainly wondering how to us and unbox, mutable vector for the job without wrapping the whole thing in ST
03:20:57 <whald> i think it should be possible. i wonder if the thaw/freeze cycle i'd do in a naive addElement implementation will *always* cause the vector to be copied, or only if we actually had to grow it
03:21:28 <whald> somewhere in the vector documentation I read the phrase "creates and copy *if needed*" (or the like)
03:22:08 <whald> don't know if it's a good idea to depend on this behaviour (which is magic, at least to me :-) )
03:22:24 <whald> s/and/an
03:35:41 <iboB> hey, say i need to create a list but the algorithm needed doesn't work on consecutive elements (for example the sieve of eratosthenes)
03:35:53 <iboB> is there a general approach for that in haskell?
03:36:21 <Axman6> wtf... what the hell is wrong with my ghc o.O
03:36:56 <whald> iboB: you can use arrays (or vectors)
03:37:32 <Axman6> urgh, forgot that bang patterns need a language pragma >_<
03:39:16 <iboB> thanks, whald
03:40:05 <quicksilver> IntMap is probably more idiomatic for the sieve
03:40:28 <iboB> quicksilver, thank you
03:40:30 <abernstein> hi. i am serializing some haskell values to bytestrings. Is there an advantage to use blaze-builder for that, instead of working directly with bytestrings ?
03:41:21 <whald> using (x:xs) to prepend an element to a list is O(1), right?
03:41:51 <quicksilver> yes. whald
03:42:04 <iboB> another question: is there a type of software for which haskell is a much much better choice than a non-functional language (for example a parser, or a database engine, or the ai for a game, etc)
03:42:07 <whald> quicksilver: why is it taking so long then? ;-)
03:42:16 <quicksilver> you're doing it billions of times?
03:43:02 <whald> quicksilver: indeed. i'll have to figure out how to dynamically grow a vector, the overhead of lists is pretty bad for what i'm doing
03:44:17 <whald> iboB: personally, after having used parsec (so parsers) for a while now, i don't want to go back any more. i'm not exactly sure if that's specific to functional languages
03:44:26 <gienah> iboB: the type system and most stuff for a compiler, ghc and agda are written in haskell.
03:44:55 <whald> iboB: for my limited experience, STM and parsec are unmatched (at least i don't know any other language offering such powerful tools)
03:46:32 <quicksilver> whald: odd. The time overhead of (:) is really quite low. I suspect you're paying more for the space overhead and concomitant GCs/cache misses
03:47:59 <whald> quicksilver: i think so. especially the space overhead is killing me currently. i'm trying to load some decent sized meshes in my renderer, and a space overhead of 60% while reading in the data is a no-go
03:48:26 <quicksilver> if you're sending them to a graphics card you might as well load them into packed memory in the format the graphics card wants
03:48:48 <whald> quicksilver: after the data is completely in memory it goes into an unboxed vector, so it's fine then. unfortunately i don't know the size of the vector when i start parsing the file...
03:49:05 <dever> hey all, quick question, been a while since i've hit this error. my prog gives stack overflow, so i gave it strictness hints, getting rid of the stack overflow, now it just plain chews through available memory and crashes... any hints
03:49:50 <whald> quicksilver: it's a pure haskell raytracing engine, i consider getting this runing on opencl/cuda an execise for compiler writers :-)
03:49:59 <quicksilver> oh
03:50:18 <iboB> quicksilver why did you say that IntMap is a good choice for a sieve of eratosthenes? wouldn't a better choice be a structure that has a key lookup with O(1) complexity?
03:50:26 <whald> quicksilver: after all i'm doing it for fun and learning haskell, not for best possible speed
03:50:44 <quicksilver> iboB: it's more idiomatic in haskell than a mutable data structure.
03:50:57 <quicksilver> iboB: also, you have been lied to, and O(1) doesn't exist.
03:51:25 <whald> quicksilver: hey, then you lied to me as well! :-)
03:51:26 <mauke> wait, I thought IntMap was O(1)
03:51:39 <iboB> er... quicksilver you mean 1 doesn't exist. That's why we use O(1)
03:51:49 <quicksilver> iboB: no, I mean O(1) doesn't exist.
03:51:54 <iboB> how so?
03:52:14 <iboB> int c a[i] is O(1)
03:52:25 <quicksilver> because arrays only work up to the pointer size of your computer
03:52:32 <quicksilver> 64 bit, say.
03:52:45 <quicksilver> if you are bounded by 64 bit, then O(log n) is the same
03:53:03 <quicksilver> becase log n < 64 so it's bounded by a constant so O(log n) = O(1).
03:53:15 <quicksilver> IntMap is actually O(log wordsize)
03:53:27 <quicksilver> and wordsize is a constant.
03:53:34 <mauke> a small constant, even
03:53:36 <quicksilver> real machines aren't asymptotic.
03:54:20 <quicksilver> so all that matters is which one is *actually* faster in practice.
03:54:36 <quicksilver> a C mutable array probably is a little faster than an intmap, but not massively
03:54:52 <quicksilver> and often memory bandiwtdh will be your limit
03:55:23 <quicksilver> (so your mutable array deref won't be able to run at its theoertical speed ebcause it spends all its time waiting on memory)
03:55:26 <whald> quicksilver: so true, especially on older AMD cpus...
03:55:36 <Jaak> does intmap behave well with cache?
03:55:41 <iboB> so you're saying that a billion lookups in a IntMap will be as fast as a billion integer additions?
03:55:59 <iboB> because log 64 is about 5
03:56:05 <iboB> (assuming a natural algorithm)
03:56:09 <iboB> er
03:56:10 <quicksilver> iboB: the slow part of array lookup isn't the addition, it's the pointer following.
03:56:10 <iboB> logarithm
03:56:11 <iboB> :)
03:56:13 <iboB> silly me
03:56:18 <quicksilver> pointer lookup is only one cycle if it's in L1 cache
03:56:31 <quicksilver> Jaak: not perfectly, no
03:56:38 <quicksilver> Jaak: it depends what order the bits get allocated in
03:56:43 <quicksilver> GHC makes some effort to be cache-friendly
03:56:46 <Jaak> i see
03:56:48 <Jaak> cool
03:56:53 <quicksilver> but carefully coded C is easier to optimise for caches
03:56:58 <quicksilver> if you understand your machine well.
03:57:11 <iboB> quicksilver: true, but that's why the processor loads chunks of memory in the cache, and that's why a in C an array is efficient for traversal
03:57:21 <quicksilver> right.
03:57:49 <quicksilver> so, the short answer is it's a lot more subtle than the difference between O(1) and O(log log n) and O(log n)
03:57:58 <quicksilver> it's more about memory access patterns and GC and sharing.
03:58:11 <iboB> yeah I see what you mean now
03:58:31 <quicksilver> in general I would expect a mutable array to be a little faster, but IntMap is very fast
03:58:44 <quicksilver> if you can take advantage of sharing then IntMap becomes a win.
04:01:08 <quicksilver> the reason I answered 'IntMap' is because your code will probably look nicer
04:01:15 <quicksilver> (and it won't be terribly slow)
04:01:35 <iboB> yep, got it, thanks :)
04:15:58 * hackagebot buildwrapper 0.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.2 (JeanPhilippeMoresmau)
04:18:04 <chra> I have something like "data Tree = Node String [Tree a] | Text String" and "Parsec Node u a". How would I go about making "descend :: Parsec Node u a → Parsec Node u a", i.e. take a parser to run on the subtree, returning what it returns?
04:18:38 <mauke> that looks like a couple of errors
04:19:00 <chra> *Parsec Tree u a, I mean.
04:26:36 <bxc> trying to install profiling versions of libraries that i already have installed as non-profiling, using cabal - is there a way to get it to install the entire dependency tree (like what happens when the dependencies are not installed at all)? I seem to have to wait for an error about missing profile libraries, and be walking the tree manually
04:27:24 <dcoutts> bxc: sadly no, ghc-pkg and cabal do not track the presense of profiling libs
04:27:49 * dcoutts notes that we know how to fix it though
04:28:10 <TomvdZ> Is it possible to do something similar to "let (a,b) = f b in a" where f is an IO function?
04:28:29 <bxc> i guess all packaging systems have a Most Frustrating Feature
04:28:34 <hpc> TomvdZ: sounds like you want fixIO
04:28:58 <bxc> although its kinda interesting to shown all the packages
04:37:33 <TomvdZ> It was explained to me at some point, but is there a nice resource that will remind me how to use fix to rewrite a recursive let?
04:38:40 <Nimatek> TomvdZ: http://www.vex.net/~trebla/haskell/fix.xhtml
04:43:52 <chra> Answer to my own question above: descend p = getNode >>= \e → getInput >>= \i → setInput e >> p >>= \a → setInput i >> return a
04:47:03 <troydm> only after reading both Learn Yourself Haskell and Real World Haskell chapters about Monad i'm starting to understand what monads are
04:47:28 <troydm> seems complicated and at the same time really simple
04:48:37 <amtal> troydm: time to go write a blog post teaching monads!
04:48:48 <amtal> Haskell rite of passage! Yaay!
04:48:56 <troydm> amtal: yeah right :)
04:49:13 <amtal> Well, you can put it off for a bit. But the important thing is, you can! :)
04:49:16 <hpc> troydm: yeah, they're just yet another typeclass, just with a couple of really ridiculous instances ;)
04:50:19 <troydm> the most confusing part about Haskell i think is monads
04:50:48 <amtal> I'm thinking about how to implement them in a new language. (I figure it's more interesting to implement list comprehensions via do notation, rather than just by themselves.) Do I understand correctly that there needs to be some lazy evaluation, so >>= can choose to not evaluate the input function and just short-circuit?
04:51:09 <amtal> I mean, I guess if there's no side effects you can evaluate anyway and nobody will know.
04:51:21 <gienah> _flow_: yes
04:51:29 <troydm> that's interesting question
04:52:47 <hpc> amtal: depends on how the language works; in haskell it's just extra functions built on top of general lazy evaluation
04:52:47 <patrek> Anyway to convert Exp to Pat in Template Haskell automatically?
04:52:50 <troydm> return "Hello" >> return Nothing >> putStrLen "Hello" for example
04:53:32 <hpc> (plus the IO hack, but nothing is perfect)
04:53:35 <patrek> any function  Exp -> Pat in TH ?
04:53:40 <amtal> In a strict language though you could have do-notation wrap lines in functions, and have >>= implementations choose whether to evaluate the function passed in.
04:53:44 <hpc> @hoogle Exp -> Pat
04:53:45 <lambdabot> Language.Haskell.TH.Syntax ViewP :: Exp -> Pat -> Pat
04:53:45 <lambdabot> Language.Haskell.TH ViewP :: Exp -> Pat -> Pat
04:53:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:53:57 <hpc> lol unsafeCoerce
04:54:07 <amtal> What's a better name for >>= and return by the way? Bind seems okay, but return goes against most intuitions.
04:54:10 <amtal> Bind and wrap?
04:54:21 <hpc> amtal: pure?
04:54:23 <hpc> @hoogle pure
04:54:23 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
04:54:23 <lambdabot> package pure-fft
04:54:23 <lambdabot> package pure-priority-queue
04:54:41 <troydm> pure works on Applicative's only
04:54:43 <hpc> if you do what you are supposed to when you write your instances, pure = return
04:54:47 <amtal> No intuition is better than pre-existing intuition, I guess.
04:54:47 <iboB> i have n :: Integer, i want an int equal to it's root ( floor.sqrt$fromIntegral n is Integer)
04:54:55 <troydm> if type is Applicative it doesn't mean it's Monad
04:54:56 <iboB> what do?
04:55:05 <hpc> troydm: all monads are also applicative, where (<*>) = liftM2, pure = return
04:55:19 <hpc> troydm: it's just not required in haskell, for hysterical raisins
04:55:40 <hpc> er crap, where (<*>) = ap
04:55:43 <hpc> :t ap
04:55:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:55:58 * hackagebot hxt 9.1.5 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.5 (UweSchmidt)
04:56:33 <hpc> troydm: applicative was added to base after monad, and the heirarchy never got updated because it would break some really old libraries
04:56:49 <hpc> not sure if the reasons are still applicable, but there you go
04:57:03 <troydm> hpc: yeah i understand
04:57:36 <hpc> they are also all functors, where fmap = liftM
04:59:08 <hpc> :t fromInteger -- iboB
04:59:09 <lambdabot> forall a. (Num a) => Integer -> a
04:59:47 <troydm> :t liftM
04:59:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:59:49 <hpc> > fromInteger (floor . sqrt . fromIntegral $ 10000) :: Int
04:59:53 <lambdabot>   mueval-core: Time limit exceeded
05:00:58 * hackagebot splot 0.3.0 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.0 (EugeneKirpichov)
05:45:49 <hpc> 830 people and nobody talking... :P
05:46:00 * hackagebot Hs2lib 0.5.6 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.6 (TamarChristina)
05:47:12 <Lemmih> hpc: So, how's life?
05:47:13 <Phyx-> hpc: well it is a friday
05:47:29 <Phyx-> all the cool grown ups went out
05:47:40 <hpc> Phyx-: no wonder #haskell is so full :D
05:47:44 <Phyx-> :P
05:49:36 <Phyx-> so what's shaking hpc, Lemmih
05:50:22 <Lemmih> I said Hi! to SPJ the day before yesterday.
05:51:10 <Lemmih> He gave a talk about type hackery and supercompilation at my school.
05:53:20 <Phyx-> Lemmih: cool
05:59:40 <mauke> there should be a law that all talks by SPJ must be recorded for the internet
05:59:51 <wlangstroth> mauke: +1
06:01:19 <whald> hm, what's the parsec combinator that repeatedly applies a parser for it's state modifications? a bit like "sequence_" to replace the ugliness of "_ <- many foo"?
06:01:46 <whald> ( where the _ would be a [()] )
06:02:32 <Saizan> many foo >> return ()
06:02:44 <Saizan> or i think you'd have to write your own
06:06:03 <hpc> whald: instead of "_ <- many foo", just write "many foo"?
06:06:43 <whald> hpc: hlint doesn't like it, and I like hlint not to complain :-)
06:06:59 <hpc> o.O
06:07:14 <hpc> honestly, that sounds like a problem with hlint
06:07:32 <mauke> ghc also doesn't like it
06:07:43 <mauke> i.e. it warns about it
06:07:51 <mauke> I think this is new in ghc 7
06:07:58 <whald> hpc: Saizan: maybe i'm misinterpreting my allocation profile, but it seems that parsec's many actually allocates the "[()]"
06:08:04 <hpc> that sounds really odd
06:08:33 <whald> hpc: the warning says that you're discarding a value of type ...
06:08:34 <wlangstroth> parsec 3?
06:08:38 <Saizan> whald: yeah, it  does
06:08:49 <hpc> what a pointless warning
06:09:13 <whald> Saizan: but that [()] is actually bigger than the data i'm reading in... :-/
06:09:26 <hpc> especially because in a do-block, "_ <- ..." and just "..." both desugar to the same thing
06:10:06 <Saizan> whald: weird, but it should be easy to write a many_ if you take a look at the source for many from the parsec package
06:10:10 <whald> hpc: in some way the "_ <-" indicates that "you know what your're doing" -- somehow i'm fine with that
06:11:44 <dmwit> whald: How is that possible? That would seem to imply that the parser you're applying "many" to will apply more than once to some particular token, but "many" throws a runtime error if it's applied to a parser that accepts the empty string of tokens.
06:12:03 <dmwit> whald: (The answer won't help you solve you're problem, I'm just genuinely curious how what you're describing is possible.)
06:12:08 <dmwit> ack
06:12:12 <dmwit> s/you're/your/
06:13:04 <whald> dmwit: I can show you the source, interested?
06:13:21 <dmwit> Yeah!
06:14:42 <whald> dmwit: here's the source: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/IO/WaveFront.hs
06:15:48 <dmwit> Is it the "many (pUV <|> vertex <|> face <|> ignore)" one?
06:16:02 * hackagebot derp-lib 0.0.0.1 - combinators based on parsing with derivatives (derp) package  http://hackage.haskell.org/package/derp-lib-0.0.0.1 (KiYungAhn)
06:16:04 <whald> dmwit: yes, i think so
06:16:47 <whald> dmwit: sadly a collegue keeps talkin to me while i try to convert the memory profile pdf to png and upload it somewhere for you to see :-)
06:17:10 <byorgey> those pesky colleagues
06:17:32 <dmwit> heh
06:21:20 <bxc> whats a good structure for storing immutable strings?
06:21:21 <whald> dmwit: oh my, here it is : http://imageshack.us/f/534/blingh.png/
06:21:45 <dmwit> bxc: String or Text
06:22:26 <bxc> String is [Char], right?
06:22:35 * bxc wants something less memry hogging
06:22:37 <dmwit> Yes.
06:22:47 <mauke> what do the strings contain?
06:22:55 <bxc> lists of filenames
06:22:58 <bxc> read out of a file
06:23:07 <mauke> could be done with ByteString
06:23:19 <whald> you do hp2ps | ps2pdf | pdftopng (now you have an UNCOMPRESSED 7 MB png) , a final "convert x.png x.png" gives you a reasonable size image you can actually upload to some image hosting thingie. computers have a long way to go before i'd call them "friendly"
06:23:20 <dmwit> whald: What makes you say the result is bigger than your input?
06:23:33 <wlangstroth> I find Text easier to deal with than ByteString
06:23:58 <bxc> never used next - bytestring was what i was looking at, but I'll try text as the API looks closer to what i have already
06:24:26 <dmwit> bxc: On *nix, ByteString is probably okay, but on Windows, you'll want to use Text.
06:24:34 <mauke> dmwit: why?
06:24:37 <whald> dmwit: not the result is bigger, but the [()] grows faster than the data (which sometimes doubles size, what i'm kinda proud of :-) )
06:24:40 <dmwit> (There is a longish thread on -users right now about the difference there. =P)
06:24:56 <dmwit> mauke: Because on Windows, file names are actually Unicode strings.
06:25:08 <mauke> dmwit: so they are on unix
06:25:18 <wlangstroth> bxc: for most things, there shouldn't be much difference between Text and ByteString anyway, I just find Text easier
06:25:29 <sipa> in unix, filenames are usually utf8
06:25:35 <sipa> i believe in windows it's uts16
06:25:37 <dmwit> mauke: On Unix, file names are sequences of bytes (which often happen to correspond to the locale-specific encoding of some particular Unicode string).
06:25:37 <sipa> utf
06:25:57 <dmwit> (...but they aren't required to.)
06:26:07 <whald> dmwit: I'd expect the waveFrontParser function to allocate nothing at all, but as it stands it's the most allocating function in there
06:27:29 <saati> can i somehow make a function that applies a certain arguments to any other function? i mean a -> b -> c -> (a -> b -> c -> whatever) -> whatever
06:28:00 <shachaf> saati: That type signature is valid.
06:28:00 <dmwit> ?djinn a -> b -> c -> (a -> b -> c -> whatever) -> whatever
06:28:00 <lambdabot> f a b c d = d a b c
06:28:39 <saati> yes but what if whatever is d -> e -> f vs d -> e
06:28:47 <dmwit> saati: That's fine.
06:28:50 <ion> Still works.
06:29:05 <shachaf> What are d, e, and f?
06:29:07 <dmwit> saati: whatever can be whatever
06:29:13 <saati> shachaf: anything
06:29:15 <PiRSquared17> ?djin a -> a
06:29:15 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
06:29:20 <PiRSquared17> ?djinn a -> a
06:29:20 <lambdabot> f a = a
06:29:34 <PiRSquared17> ?djinn a -> b -- impossible
06:29:35 <lambdabot> Cannot parse command
06:29:42 <PiRSquared17> ?djinn a -> b
06:29:42 <lambdabot> -- f cannot be realized.
06:30:08 <whald> dmwit: sorry for spamming you, but here is the "-hy" graph which shows it's actually []s which are allocated: http://imageshack.us/f/10/blinga.png/
06:30:39 <whald> dmwit: now i'm afk for 5 min to cheer up my colleague
06:30:48 <dmwit> =)
06:34:22 <saati> shachaf, dmwit thanks, this type system is quite smart
06:37:34 <mah_b> hi, is there some simple code to do gaussian elimination?
06:38:28 <wlangstroth> have you tried googling "gaussian elimimation haskell"?
06:38:52 <dmwit> Did you mean: "gaussian elimination haskell"?
06:38:58 <dmwit> ;-)
06:39:14 <ClaudiusMaximus> :t Data.Vec.LinAlg.solve
06:39:14 <wlangstroth> I have a cold
06:39:15 <lambdabot> Couldn't find qualified module.
06:39:45 <wlangstroth> http://www.reddit.com/r/haskell/comments/98spf/imposing_the_edges_later_lazy_evaluation/
06:41:16 <blackdog> wlangstroth: wow, lazarus award right there
06:41:36 <yrlnry> What does "lazarus award" mean?
06:41:41 <mah_b> wlangstroth: yes, I have found that. but I was too dumb to see the code. thanks :)
06:41:50 <dmwit> yrlnry: Presumably digging up something long dead to revive it.
06:42:03 <blackdog> yrlnry: lazarus was raised from the deda by jesu
06:42:04 <yrlnry> I admit I didn't actually look at the reddit thing.
06:42:05 <blackdog> *s
06:42:30 <blackdog> (uh, allegedly etc. so a lazarus thread is a very old one resuscitated)
06:42:38 <yrlnry> thanks.
06:45:13 <wlangstroth> mah_b: not dumb - I understand the temptation to first ask a channel full of people who *might* just have a PhD.
06:45:17 <troydm> why doesn't this compiles ? newtype Logger a = { runLogger :: (a,Log) }
06:45:27 <mauke> troydm: missing constructor name
06:45:29 <troydm> type Log = [String]
06:45:43 <whald> dmwit: replacing "many" with "manyAccum (\_ _ -> [])" does the trick!
06:45:43 <troydm> mauke: ohh thx
06:45:58 <dmwit> whald: Great!
06:46:46 <whald> dmwit: plain "many" insists on reversing the [()] before giving it back, and to reverse a [()] you have to accumulate it first
06:47:19 <whald> dmwit: wouldn't it be a good idea to specialize the reverse function to be identity for [()] then?
06:47:31 <dmwit> That doesn't seem sound.
06:47:35 <whald> dmwit: i mean in the prelude or something?
06:47:43 <dmwit> > reverse [(), undefined]
06:47:44 <lambdabot>   [*Exception: Prelude.undefined
06:48:12 <whald> dmwit: thats that bottom thing i never understood, right?
06:48:32 <whald> > id [(), undefined]
06:48:33 <lambdabot>   [(),*Exception: Prelude.undefined
06:48:38 <dmwit> whald: Sure. There's not much to understand; undefined can be defined as an infinite loop:
06:48:41 <dmwit> undefined = undefined
06:49:20 <statusfailed> What's the best ordered set / hashtable / hash set structure for doing lots of removes and replaces?
06:49:29 <dmwit> So [(), infinite loop] and [infinite loop, ()] behave differently, and reverse /= id.
06:49:39 <whald> dmwit: so it's not that ghc missed a chance of optimization here, but it really *has* to allocate so it knows if it "fails"?
06:50:08 <dmwit> Right.
06:50:23 <dmwit> statusfailed: I'd start with Data.Set.
06:50:48 <whald> dmwit: cool, I learned something *and* my program runs faster than before. usually I get only either of the two. a good day, and thanks! :-)
07:07:27 <PiRSquared17> > undefined
07:07:28 <lambdabot>   *Exception: Prelude.undefined
07:07:35 <PiRSquared17> > const 0 undefined
07:07:37 <lambdabot>   0
07:07:58 <PiRSquared17> > (flip . flip . const) 0 undefined
07:07:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
07:07:59 <lambdabot>    arising from a use of `...
07:08:15 <PiRSquared17> > (flip (flip const)) 0 undefined
07:08:18 <lambdabot>   0
07:10:41 <PiRSquared17> @type undefined
07:10:42 <lambdabot> forall a. a
07:10:59 <PiRSquared17> @type \x -> undefined
07:11:00 <lambdabot> forall t a. t -> a
07:13:51 <Cale> > 0 `seq` undefined
07:13:52 <lambdabot>   *Exception: Prelude.undefined
07:13:56 <Cale> > 0 `seq` (\x -> undefined)
07:13:57 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
07:13:57 <lambdabot>    arising from a use of `...
07:14:03 <Cale> er, duh
07:14:08 <Cale> > (\x -> undefined) `seq` 0
07:14:09 <lambdabot>   0
07:14:12 <Cale> > undefined `seq` 0
07:14:13 <lambdabot>   *Exception: Prelude.undefined
07:17:19 <Cale> So apparently the acceleration due to gravity is close to pi^2 m/s^2 for a good reason. One of the original proposals for the definition of the metre was the length at which a pendulum would have a half-period of 1 second. t = pi (l/g)^(1/2) gives g = l pi^2/t^2, and when l = 1m and t = 1s, you have g = pi^2 m/s^2.
07:17:45 <ion> Heh, interesting.
07:17:58 <ion> > pi^2
07:17:59 <lambdabot>   9.869604401089358
07:19:57 <Peaker> What's a nice way to generate quickcheck input lists of a certain length only?
07:20:02 <Peaker> Using ==> rules out too many inputs
07:20:23 <Cale> Peaker: in the Gen monad you can just use replicateM
07:20:37 <Peaker> Cale: What's the Gen monad?
07:20:54 <Cale> The monad in which definitions of arbitrary are written.
07:21:11 <Cale> It's a random value generation monad
07:21:23 <Peaker> ah, do I have to newtype around [] for that?
07:21:45 <Cale> yeah, there are a bunch of existing newtypes, but to restrict for a given length would require moar type hackery
07:21:52 <Cale> (to do it generally, that is)
07:22:17 <Cale> If you only have one length that you're interested in, then a newtype alone would be fine
07:22:22 <Peaker> is there a way to run QuickCheck with a custom Gen computation rather than the Arbitrary instance?
07:22:48 <Cale> Let me, er... check :)
07:22:50 <ion> peaker: prop_foo (take 42 -> xs) = …
07:23:09 <Peaker> ion: what if it's shorter than 42?
07:23:55 <ion> > take 42 [0..3]
07:23:56 <lambdabot>   [0,1,2,3]
07:24:02 <ClaudiusMaximus> @hoogle vectorOf
07:24:02 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
07:24:02 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
07:24:22 <Cale> There ought to be:
07:25:44 <Cale> oh, yes, there is an instance of Testable for Gen a whenever there's an instance of Testable for a
07:26:05 <Cale> So you should be able to give a computation in the Gen monad directly to quickCheck
07:26:07 <ion> oneToFive :: Gen [a]; oneToFive = take 5 . fromNonEmpty <$> arbitrary
07:26:33 <Peaker> Cale: thanks, I'll try
07:26:33 <ion> fromNonEmpty (NonEmpty xs) = xs
07:27:25 <Cale> quickCheck (someTestOn <$> vectorOf 5 arbitrary)
07:27:38 <simon> why do lexeme parsers clear whitespace *after* a parser and not *before*? that way you would avoid having to use whiteSpace once manually before applying parsers.
07:27:48 <Cale> (where someTestOn is whatever your original property was)
07:28:29 <parcs> simon: tehn you would have to use whitespace manually after applying the parsers
07:28:33 <ion> Actually, oneToFive = take 5 <$> liftOf1 arbitrary
07:29:48 <Peaker> ok.. I finally understand the behind-the-scenes of quickcheck (never used it non-trivially before)
07:30:35 <Peaker> easier to control generation of inputs than I thought :)
07:31:34 <Cale> Peaker: There are also lots of convenient newtypes of lists which you can pattern match away to restrict their properties
07:31:44 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Modifiers.html
07:32:16 <Cale> I shouldn't say just lists, there are some dealing with numbers and other things too
07:32:17 <simon> parcs, just once, at the end, but I don't really care about whitespace at the end of my program.
07:32:32 <simon> parcs, all other cases are handled by lexeme parsers just like they are now.
07:33:21 <Cale> simon: Perhaps it's because if a language is going to be whitespace sensitive, it's far more likely to care about whitespace before a symbol than after it.
07:33:23 <ion> Note the difference between ghci> sample (vectorOf 5 arbitrary :: Gen [Integer]) and ghci> sample (take 5 <$> listOf arbitrary :: Gen [Integer])
07:33:29 <statusfailed> why does "str <- hGetLine handle; putStrLn str" work, and "fmap putStrLn $ hGetLine handle" not?
07:33:47 <Cale> ion: Yeah, I'd assumed we wanted lists of a fixed size
07:33:50 <simon> Cale, good point.
07:34:07 <shachaf> statusfailed: join (fmap putStrLn $ hGetline handle) would work.
07:34:08 <ion> Oh, i misread the original question.
07:34:17 <shachaf> statusfailed: Or hGetLine handle >>= putStrLn
07:34:28 <Cale> Or putStrLn =<< hGetLine handle
07:34:42 <statusfailed> never seen =<< before :|
07:34:52 <shachaf> (=<<) is just flip (>>=)
07:34:58 <statusfailed> is it in Monad?
07:35:00 <hpaste> angstrom pasted “which version seems clearest?” at http://hpaste.org/53901
07:35:00 <Cale> Yeah
07:35:08 <Cale> Well, it's defined in terms of >>=
07:35:10 <statusfailed> ghci doesn't show it for :i Monad
07:35:13 <shachaf> It's in Control.Monad; it's not in the type class. :-)
07:35:16 <statusfailed> Ahhh
07:35:17 <statusfailed> ok
07:35:21 <shachaf> statusfailed: I just gave you its definition.
07:35:30 <statusfailed> shachaf: I was just wondering where it was :p
07:35:35 <Cale> v =<< x = x >>= v
07:35:36 <PiRSquared17> @type (>>=)
07:35:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:35:39 <PiRSquared17> @type (=<<)
07:35:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:35:53 <Cale> From the ministry of symmetric code
07:35:53 <PiRSquared17> @type filp (=<<)
07:35:54 <lambdabot> Not in scope: `filp'
07:35:59 <shachaf> statusfailed: If you're wondering where something is, you should do :i something, not :i SomeClassRelatedToSomething. :-)
07:36:01 <PiRSquared17> @type flip (=<<)
07:36:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m a -> (a -> m b) -> m b
07:36:07 <ion> :browse! Control.Monad
07:36:14 <statusfailed> shachaf: duly noted ^^
07:36:24 <simon> =<< just looks so sad.
07:36:42 <Cale> :<
07:36:47 <statusfailed> hahah
07:36:51 <cheater> it's an upside down horned devil
07:36:56 <shachaf> Hmm, ":browse!".
07:37:10 * shachaf tries to figure out practical difference.
07:37:36 <ion> It’s slightly more terse.
07:47:12 <applicative> @type (putStrLn . reverse <=< readFile <=< const getLine) ()
07:47:13 <lambdabot> IO ()
07:48:00 <Cale> shachaf: It keeps all the data flowing in the same direction
07:48:21 <Cale> oh, you meant with browse!
07:49:08 <Peaker> is there a modulo operator that works on rationals/floats?
07:49:22 <Cale> Peaker: Not in the standard library :/
07:49:34 <Cale> It's not too hard to implement in terms of floor
07:49:53 <Cale> (but it requires the same small amount of thinking every time I do it :P)
07:51:07 <Peaker> Python's modulo works on non-ints :-P
07:51:30 <Cale> I'm not sure that's an argument for that design though
07:51:30 <Peaker> but yeah, I know how you'd use floor .. floor-division, multiply back, subtract
07:52:04 <Cale> (but yeah, it would be convenient to have an fmod for fractional cycling)
07:52:20 <scooty-puff> is there an everything' available anywhere, where everything is to everything' as everywhere is to everywhere'?
07:52:26 <Peaker> > let testMod x y = x - floor (x / y) * y in testMod 5.5 2
07:52:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:52:27 <lambdabot>    `GHC.Real.Integral a'
07:52:27 <lambdabot>   ...
07:52:34 <Peaker> > let testMod x y = x - floor (x / y) * y in testMod (5.5::Double) (2::Double)
07:52:35 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
07:52:35 <lambdabot>    arising from a use ...
07:52:48 <Cale> fromIntegral
07:52:49 <Peaker> > let testMod x y = x - (fromIntegral . floor) (x / y) * y in testMod (5.5::Double) (2::Double)
07:52:51 <lambdabot>   1.5
07:53:38 <quicksilver> > 3.4 `mod'` 0.9
07:53:39 <lambdabot>   0.6999999999999997
07:53:41 <quicksilver> Cale: ^^^^^^
07:53:57 <mauke> foreign import "math.h" fmod :: CDouble -> CDouble -> CDouble
07:54:05 <quicksilver> > 3.4 `mod'` 0.9 :: Rational
07:54:05 <lambdabot>   7 % 10
07:55:06 <angstrom> regarding my paste: tp1' seems clearest to me, but I don't like the "pattern duplication"; hence I'll probably go with tp1
07:55:15 <monochrom> @bots
07:55:15 <Peaker> @index mod'
07:55:15 <lambdabot> bzzt
07:55:16 <lambdabot> :)
07:55:28 <quicksilver> Peaker: Data.Fixed
07:55:41 <Peaker> thanks
07:55:50 <clsmith> hey. how come Bool isn't a MonadPlus?
07:55:57 <quicksilver> not sure why @index didn't find it.
07:56:00 <mauke> clsmith: kind error
07:56:03 <quicksilver> clsmith: itdoesn't have a type parameter.
07:56:11 <clsmith> oh right, silly me :p
07:56:12 <quicksilver> you could ask why it isn't a Monoid.
07:56:23 <applicative> scooty-puff: everywhereBut
07:56:23 <mauke> it's two monoids
07:56:25 <Cale> quicksilver: What about that?
07:56:37 <monochrom> Bool is at least 3 monoids
07:56:41 <quicksilver> Cale: isn't tht what you were looking for.
07:56:50 <Cale> oh, yes :)
07:56:57 <clsmith> quicksilver: that's where i began, but i figured it must be because True && False == True, which isn't strictly 'ascending'
07:57:00 <Cale> That's in Data.Fixed, right.
07:57:06 <clsmith> so i figured binding was a different deal
07:57:07 <Cale> I always forget that's there.
07:57:10 <clsmith> uh
07:57:13 <clsmith> *False
07:57:16 <Cale> It's kind of a silly place to put it.
07:57:20 <quicksilver> clsmith: well there are multiple sensible ways to make Bool a monoid
07:57:25 <quicksilver> as monochrom
07:57:26 <mauke> :t And
07:57:26 <lambdabot> Not in scope: data constructor `And'
07:57:28 <quicksilver> and mauke
07:57:32 <mauke> :t All
07:57:33 <quicksilver> have said.
07:57:33 <lambdabot> Bool -> All
07:57:48 <scooty-puff> applicative: the resulting data type will be different - i need something with type a -> r, vs. a -> a
07:58:11 <scooty-puff> i'm considering using synthesize
07:58:16 <scooty-puff> >:t synthesize
07:58:18 <applicative> scooty-puff: ooh synthesize
07:58:30 <scooty-puff> :t synthesize
07:58:31 <lambdabot> forall s t a. (Data a) => s -> (t -> s -> s) -> GenericQ (s -> t) -> a -> t
07:58:57 <clsmith> what monoids would Bool be? i suppose, ||, &&, ==, or whatever?
07:59:00 <scooty-puff> :t synthesize (return ()) (>>)
07:59:01 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Data a1) => GenericQ (m () -> m a) -> a1 -> m a
07:59:36 * applicative considers that  s -> (t -> s -> s) -> GenericQ (s -> t) -> GenericQ t  is too many Q's to figure out this evening
07:59:43 <clsmith> well, if i need bool to be an &&-monoid right now, i suppose it's kosher just to instance it?
07:59:59 <scooty-puff> yeah, its much easier in practice than it looks
08:00:07 <byorgey> clsmith: use All
08:00:14 <byorgey> defined in Data.Monoid
08:00:47 <clsmith> ah, i'll have a look
08:00:53 <hpaste> Peaker pasted “pure Haskell FFT” at http://hpaste.org/53902
08:01:10 <Peaker> which is prettier, mine (^paste) or http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/src/Numeric-FFT.html#fft ?
08:01:35 <clsmith> hmm, how would i use that? just use All instead of Bool in the type?
08:01:48 <Peaker> hmm.. the pure-fft package seems wrong!
08:01:57 <Peaker> ifft xs = let n = (fromIntegral . length) xs in fmap (/n) (fft xs) <-- this is wrong
08:02:02 <clsmith> no, that can't work
08:02:13 <byorgey> clsmith: yes; you also have to use All to convert a Bool to an All, and getAll to convert back
08:02:32 <Peaker> who uploads a buggy FFT to hackage? :-P
08:02:44 <byorgey> > getAll . mconcat . map All $ [True, False, True, True]
08:02:46 <lambdabot>   False
08:02:47 <clsmith> ohhhh, i see. the field syntax threw me off
08:02:52 <clsmith> thanks :)
08:02:52 <byorgey> > getAll . mconcat . map All $ [True, True, True, True]
08:02:54 <lambdabot>   True
08:03:08 <clsmith> that's perfect, thanks all
08:03:15 <quicksilver> and thanks "All"
08:03:15 <rwbarton> Peaker: what's wrong about it?
08:03:16 <quicksilver> :P
08:03:18 <clsmith> lol
08:03:39 <byorgey> clsmith: yeah, using record syntax like that is a common idiom for defining a projection out of a newtype wrapper
08:03:43 <Peaker> rwbarton: idft needs to rotate the other way around
08:03:51 <Peaker> rwbarton: relative to dft
08:05:30 <Peaker> rwbarton: so idft cannot be defined in terms of dft afaik (only very similarly)
08:08:28 <applicative> @type ala All Data.Foldable.foldMap
08:08:29 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t Bool -> Bool
08:09:13 <applicative> >  ala All Data.Foldable.foldMap [True, True, True, True]
08:09:14 <lambdabot>   True
08:14:38 <clsmith> hmm, i think maybe i ought to learn how to use Data.Data instead
08:29:44 <byorgey> applicative: oh, nice, didn't realize lambdabot had the 'newtype' package installed =D
08:39:08 <ion> @type ala All foldMap
08:39:09 <lambdabot> Not in scope: `foldMap'
08:39:14 <ion> @type ala All Data.Foldable.foldMap
08:39:15 <lambdabot> forall (t :: * -> *). (Data.Foldable.Foldable t) => t Bool -> Bool
08:39:27 <ion> > ala All Data.Foldable.foldMap [True, True, False, True]
08:39:28 <lambdabot>   False
08:40:07 <ion> Whoops, i missed that applicative already said that.
08:41:35 <ion> < Peaker> who uploads a buggy FFT to hackage? :-P
08:41:41 <ion> Perhaps it’s the Gutenberg FFT.
08:42:05 <applicative> haha
08:55:54 <clsmith> :/ hoogle seems to ignore type constraints
08:56:51 <shachaf> clsmith: I think it tries to match them if it can.
08:57:53 <byorgey> clsmith: what are you searching for?
08:59:48 <clsmith> i was searching for (Monoid a => Int -> a). it failed with Bool as well, which i guess is just because it doesn't check whether the strict types are actually instances of a given type class. (i.e., it should have yielded All, etc, because All is a Monoid)
09:00:50 <byorgey> clsmith: what were you hoping it would find?
09:01:00 <byorgey> I don't know of any library function with that type
09:01:05 <hpaste> wowdamn pasted “Need Help” at http://hpaste.org/53903
09:01:32 <wowdamn> whats up with that? am i right in wanting to use a list comprehension?
09:02:21 <djanatyn> hmm, time to read some LYAH
09:02:26 <djanatyn> I want to write something cool in haskell today!
09:02:40 <clsmith> byorgey: i was hoping for number monoid for hashing purposes
09:02:44 <shachaf> wowdamn: Everything you can do with a list comprehension you can do without one. :-)
09:03:13 <clsmith> although i just realised i can do it a different way, so d/w :p
09:03:20 <shachaf> wowdamn: You might consider using another guide than YAHT, whose introduction to this topic I seem to remember is rather confusing; I think LYAH is often recommended around here.
09:03:35 <wowdamn> i see
09:03:48 <wowdamn> well, can u at  least give me a solution to that excercise
09:03:53 <wowdamn> then ill stop reading it
09:04:22 <djanatyn> shachaf: You totally spoiled the solution to that problem, btw.
09:04:27 <shachaf> wowdamn: What's the point?
09:04:29 <djanatyn> It turned out I was overthinking it - a lot.
09:04:39 <wowdamn> because ive been stuck on it
09:04:47 <wowdamn> i just wanna see it
09:05:36 <shachaf> wowdamn: Why do you care? It won't be particularly enlightening until you figure out how IO works in Haskell anyway. :-)
09:05:53 <shachaf> Also, you should add types to top-level declarations; it'll make things much less confusing for people reading your code.
09:06:06 <wowdamn_> i see
09:06:20 <shachaf> You have a weird sort of mutual recursion in that program that probably isn't what you meant.
09:06:44 <wowdamn_> okay then another thing , in the code, i need to store values that the user puts in, was (n : recursiveresult) the right way to do that?
09:07:03 <wowdamn_> oh
09:07:11 <rwbarton> sort of...
09:07:11 <shachaf> The right way is to write the code differently, probably.
09:07:22 <mauke> wowdamn_: why store a list?
09:07:25 <shachaf> readNum shouldn't be calling main; it should be a stand-alone thing that main calls.
09:07:33 <troydm> say i have return 1
09:07:48 <troydm> whoa could i make it to result to [1]
09:07:55 <troydm> doing return 1 :: [s]
09:08:01 <wowdamn_> mauke: to add all the elements together
09:08:03 <troydm> says it's invalid
09:08:05 <wowdamn_> at the end
09:08:09 <mauke> wowdamn_: why not just add them?
09:08:14 <rwbarton> troydm: return 1 :: [Integer]
09:08:21 <wowdamn_> bc iam afraid it wont add all of them
09:08:26 <mauke> huh?
09:08:30 <wowdamn_> if i just do it
09:08:33 <troydm> rwbarton: i have to explicitly specify type itself
09:08:36 <troydm> rwbarton: thx
09:08:57 <rwbarton> troydm: or in many cases, you won't have to specify the type at all because the context will require it to be a list
09:09:08 <shachaf> mauke: Computers have a tendency to stop adding after a while if you don't use a list.
09:09:16 <mauke> intredasting
09:09:16 <clsmith> hmm, is there some type class i can derive which gives me the ability to generate a unique(-ish?) number for a given data structure..?
09:09:23 <shachaf> mauke: They get lazy. You have to keep a record of everything that's happened to keep them in check.
09:09:45 <rwbarton> anyways writing an IO action to read a list of integers isn't a wrong way to go about solving this problem
09:10:14 <copumpkin> rwbarton: coming to the haskell meetup next week?
09:10:26 <FUZxxl> Is there a German channel for Haskell?
09:10:35 <FUZxxl> http://german.stackexchange.com/questions/2971/deutsche-bezeichnungen-fur-begriffe-aus-der-typtheorie
09:10:37 <copumpkin> FUZxxl: if there is, it'll be #haskell.de
09:10:44 <shachaf> rwbarton: BostonHaskell is the place where cool people go, so I'm told.
09:10:49 <shachaf> Just sayin'.
09:11:44 <Nimatek> FUZxxl: German terminology in CS is way uglier than "häßliche Anglizismen"
09:11:47 <troydm> why isn't it working return 1 >>= (\x = [x])
09:11:58 <saati> what datastructures should i use to create a binary file? it needs ascii chars, 16bit ints and 32 bit ints (both little-endian)
09:12:03 <troydm> i have [Int] >>= (Int -> [Int])
09:12:09 <shachaf> troydm: Because it's (\x -> [x])
09:12:20 <troydm> shachaf: ohh yeah thx
09:12:24 <shachaf> troydm: And the latter thing is not valid syntax (unless (>>=) is a type variable).
09:12:25 <FUZxxl> Nimatek: Well, it depends. That's why I explicitly wrote 'häßlich'
09:12:29 <copumpkin> I'll probably ramble about agda a bit at the next one
09:12:47 <copumpkin> since I'm not really ready to talk about anything more substantial that I've been working on
09:12:47 <dylex> clsmith: not automatically, unless you do something with Typeable, but that is what the Hashable class is generally for.
09:12:53 <clsmith> saati: you checked out Put?
09:12:55 <rwbarton> copumpkin: possibly, I am usually busy Tuesday evenings but I might not be next week
09:12:59 <hpaste> mauke annotated “Need Help” with “Need Help (annotation)” at http://hpaste.org/53903#a53904
09:13:03 <shachaf> copumpkin: You should've rambled about Agda last time, man.
09:13:15 <copumpkin> shachaf: you didn't like the talks last time? I'll let people know
09:13:20 <troydm> schroedinbug: thx, i guess it'll take time until i won't make any syntax errors)
09:13:42 <shachaf> copumpkin: I never wanted BostonHaskell to end!
09:13:49 <copumpkin> shachaf: aww
09:13:51 <copumpkin> come back
09:13:53 <saati> clsmith: no, what is that?
09:13:54 <shachaf> I don't see why you limit yourselves to two talks per evening.
09:15:01 <mah_b> hi, is there a (hardware accelerated) way of getting the MSB?
09:15:02 <jhance> saati: Basically, look at the binary and cereal packages on Hackage
09:15:13 <jhance> saati: Binary deals with lazy bytestrings, Cereal uses strict
09:16:27 <clsmith> that's what i was trying to say, Data.Binary.Put
09:16:33 <clsmith> tip of the tongue :p
09:17:04 <jhance> clsmith: I know, but it didn't seem like he knew about the package that Put comes from ;)
09:17:15 <saati> thanks
09:17:24 <hpaste> anonymous annotated “Need Help” with “Need Help (annotation)” at http://hpaste.org/53903#a53905
09:17:56 <shachaf> OK, who's this "anonymous"?
09:18:05 * shachaf prepares the hungusprod.
09:18:58 <clsmith> jhance (who has parted): neither did i
09:19:05 <cheater> what is a hungusprod?
09:19:17 * liyang would like to know too.
09:21:04 * hackagebot terminfo 0.3.2.3 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.2.3 (JudahJacobson)
09:21:27 <Sgeo|web> .
09:22:07 <liyang> cheater: I think it's a Zork thing.
09:22:41 <shachaf> liyang: http://www.youtube.com/watch?v=2FiRhbWP7To#t=6m57s
09:23:08 <dylex> mah_b: gcc exposes clz (really bsr on x86) as a builtin, but that doesn't give you an easy way to get to it from haskell...
09:23:47 <liyang> (Or it could be a reference to Karl Hungus from The Big Lebowski, who has a rather large penis.)
09:25:32 <luite> mah_b: I think tibbe added primitives for that in ghc 7.2
09:25:52 <tibbe> luite: for what?
09:25:58 <tibbe> I added POPCNT
09:26:08 <tibbe> we should add the rest of the low-level bit operations as well
09:26:21 <tibbe> I need the right and left linear scans for bits
09:26:35 <luite> tibbe: oh I thought you also added clz
09:26:53 <tibbe> luite: unfortunately not, I didn't have time
09:27:13 <geheimdienst> mah_b: are you sure you need that? have you tried any alternatives and benchmarked them?
09:27:15 <tibbe> luite: we should make a list (in a feature request ticket) of what functions are still missing
09:27:34 <copumpkin> @remember liyang Or it could be a reference to Karl Hungus from The Big Lebowski, who has a rather large penis.
09:27:34 <lambdabot> I will never forget.
09:27:39 <augur> heyo
09:39:09 <clsmith> :t msum
09:39:10 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:39:25 <clsmith> :t Data.Foldable.msum
09:39:26 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, MonadPlus m) => t (m a) -> m a
09:39:39 <clsmith> ^ why does that require a MonadPlus and not a Monoid>
09:39:41 <clsmith> *?
09:40:10 <shachaf> @ty msum
09:40:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:41:59 <shachaf> clsmith: Because that's what MonadPlus is, presumably?
09:42:27 <shachaf> @ty mconcat
09:42:28 <lambdabot> forall a. (Monoid a) => [a] -> a
09:42:32 <shachaf> s/MonadPlus/msum/
09:42:35 <shachaf> @ty fold
09:42:36 <lambdabot> Not in scope: `fold'
09:42:39 <shachaf> @ty Data.Foldable.fold
09:42:39 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
09:43:02 <clsmith> ohhh. i'm mixing up my kinds again. fold is what i wanted, thanks :p
09:48:34 <mysticc> :t fold
09:48:35 <lambdabot> Not in scope: `fold'
09:48:44 <mysticc> :t Data.Foldable.Fold
09:48:45 <lambdabot>     Not in scope: data constructor `Data.Foldable.Fold'
09:48:52 <mysticc> :t Data.Foldable.fold
09:48:53 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
09:57:49 <roconnor> What is GHC's recent change to Num?
09:58:59 <parcs> dropping of the Eq and Show superclasses i think
10:02:10 <Sgeo|web> Will we ever see an unamb-based language extension?
10:02:20 <Sgeo|web> http://conal.net/blog/posts/lazier-function-definitions-by-merging-partial-values
10:02:50 <roconnor> Sgeo|web: what is (1 `unamb` 2) ?
10:03:50 <Sgeo|web> Meaningless, but not provably meaningless at compile-time
10:03:58 <Sgeo|web> :/
10:04:43 <roconnor> Scott has a top element in is CPOs for contradictions such as this.
10:04:49 <roconnor> I don't know how to make a programming language out of this though.
10:08:09 <chridi> isn't there a function which replaces one element in a array?
10:08:14 <chridi> !hoogle
10:08:56 <chridi> needs to be something like Array (Int, Int) a -> a -> Array (Int, Int), or?
10:09:13 <rwbarton> @type (//)
10:09:14 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:12:58 <chridi> rwbarton: thx :)
10:13:27 <djanatyn> are there any shells for ghci, like dreampie or IDLE or bpython for python?
10:18:03 <shachaf> There's probably an emacs thing.
10:18:05 <shachaf> I just use ghci.
10:18:13 <shachaf> It does tab completion and all.
10:21:08 <geheimdienst> shachaf: no colors though
10:22:37 <djanatyn> Yeah, I don't mind that much. I was just noticing it wasn't very colorful
10:31:30 <hpaste> saati pasted “i'm confused by numeric types” at http://hpaste.org/53906
10:31:41 <saati> can someone help me with that?
10:32:25 <morel> what do i have to "derive" to be able to create a list `[Foo..Baz] :: Foobar' where `data Foobar = Foo | Bar | Baz' ?
10:32:36 <parcs> Enum
10:32:45 <morel> ty, parcs
10:32:54 <parcs> :t \x y -> [x..y]
10:32:55 <lambdabot> forall t. (Enum t) => t -> t -> [t]
10:33:06 <morel> cool, thanks again.
10:33:22 <saati> oaky nevermind
10:33:25 <rwbarton> if you also derive Bounded, you can write [minBound..maxBound]
10:41:24 <kstt> hey, my ReaderT CustomServerState IO () code is littered with liftIOs ... what am I doing wrong please ?
10:41:57 <morel> parcs: i did "data Day = Mon | Tue | Wed | Thu | Fri | Sat | Sun deriving (Eq, Ord, Enum)" but it still doesnt work :/
10:42:15 <hpc> kstt: you can factor out parts of your functions so they are just of type IO ()
10:42:18 <Javi> Hi
10:42:23 <hpc> then liftIO the whole thing
10:42:27 <morel> hello, Javi
10:42:36 <luite> kstt: you can group multiple IO actions in a sinle liftIO, and you can make a liftIO'd version of IO functions you use often
10:42:46 <kstt> hpc: that's what I'm trying to do at the moment indeed
10:43:09 <hpc> another way is to lift a small set of actions into your monad, then only use those
10:43:27 <hpc> foo' = liftIO foo
10:43:31 <kstt> but at best, I can factor out sequential uses of liftIO
10:43:45 <hpc> kstt: one thing to be careful of is
10:43:50 <hpc> liftIO $ do
10:43:55 <hpc>   x <- blah
10:44:00 <hpc> blahblah x
10:44:13 <kstt> oh, I should not get trapped by that one :)
10:44:49 <kstt> if what you mean is that x isn't defined for blahblah
10:44:50 <parcs> morel: and your expression is [Mon..Sun] ?
10:44:56 <rwbarton> morel: what does "doesnt work" mean
10:44:59 <ben> Surely there's some higher-order way of saying "import System.IO but put liftIO $ before everything"?
10:45:09 <kstt> thank you, I will try to improve this code with your advices
10:45:23 <hpc> ben: that breaks when you try to use polymorphic actions
10:45:32 <hpc> and it craps out trying to figure out if it should liftIO it
10:45:33 <morel> parcs: yep
10:45:45 <morel> rwbarton: [Mon..Sun] doesnt work
10:45:46 <hpc> ben: also it would take TH to implement
10:46:19 <parcs> morel: it should
10:46:20 <mike-burns> Haskell isn't a convenient language, ben; it's a high-level language. Sometimes they intersect.
10:46:23 <mike-burns> Not here, though.
10:46:29 <parcs> try deriving Show and inputting that expression into ghci
10:46:38 <magicman> morel: Does [Mon .. Sun] work?
10:46:44 <rwbarton> you still are using this phrase "doesnt work" :P
10:46:49 <morel> magicman: YES!
10:46:55 <morel> rwbarton: =)
10:47:01 <morel> magicman: cool, ty
10:47:02 <rwbarton> rather than say telling us what the error was
10:47:23 <shachaf> Someone needs to add an error "that doesn't work" to GHC.
10:47:28 <morel> rwbarton: oops, okay, i'll try to remember this fault, sry
10:47:35 <hpc> > fix error
10:47:36 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:47:36 <morel> shachaf: hehe
10:47:42 <morel> hehe
10:47:43 <magicman> Excellent. The error was a parse error, where it tried to parse Mon..Sun as a qualified thing from module Mon. Except that .Sun is not a valid name.
10:48:03 <rwbarton> actually I think it's Mon.. Sun
10:48:04 <morel> i see, okay…
10:48:13 <magicman> Oh, right. Derp.
10:48:18 <parcs> silly parser
10:48:21 <morel> [Mon.. Sun] "doesnt work"
10:48:30 <morel> A section must be enclosed in parentheses thus: (`Mon..` Sun)
10:48:45 <hpc> this is one of the few cases where parsing does surprising things in haskell
10:49:22 <magicman> It's why I make it a habit to always surround the .. with spaces, even if it's not needed.
10:49:34 <rwbarton> morel: right, I mean [Mon.. Sun] is how ghc parses [Mon..Sun]
10:49:47 <morel> rwbarton: aah, okay, okay…
10:50:20 <shachaf> http://www.youtube.com/watch?v=B8J6yQ4mhr4#t=6m52s -- "That doesn't work."
11:00:10 <edwardk> erm, where does the instance of Monad for Monoid w => (,) w  live?
11:00:29 <edwardk> i for some reason thought it was in Control.Monad.Instances
11:01:03 <edwardk> and i had a nice class i wanted to make it an instance of, but need the monad =/
11:01:50 <aristid> edwardk: use Writer?
11:02:04 <edwardk> aristid: i have an instance for Writer, but i also wanted an instance for a raw (,)
11:02:14 <edwardk> we have the C.M.I instance for (->)
11:02:40 <edwardk> i've used the (,) monad before though, so i'm trying to figure out where it lives these days or where it went
11:02:41 <aristid> edwardk: do you have a Monad constraint in your class?
11:02:47 <edwardk> yes
11:02:53 <geheimdienst> edwardk: you mean this? instance (Monoid a, Monoid b) => Monoid (a,b)
11:02:54 <aristid> hmm.
11:03:03 <aristid> geheimdienst: no
11:03:09 <edwardk> class Monad m => MonadRecord m where record :: m a -> m (m a, a)
11:03:18 <aristid> geheimdienst: notice that he wants Monad :)
11:03:36 <edwardk> geheimdienst: no i mean instance Monoid w => Monad ((,) w) where return = (,) mempty; ...
11:04:06 <geheimdienst> aristid: oh right, i misread, sorry :-/ i was wondering why edwardk was asking a question that i possibly might have a shot at being able to answer
11:04:13 <aristid> who stole the Monad instance?!
11:04:16 <geheimdienst> edwardk: yes, sorry, ignore me
11:04:16 <hpc> lol
11:04:23 <edwardk> geheimdienst: hah no worries
11:04:35 <copumpkin> aristid: sry, i eated it
11:04:44 <aristid> copumpkin: oh noes
11:04:57 <edwardk> i have instances for Record for all the mtl classes, its actually quite handy
11:04:58 <copumpkin> ceiling cat is sending me to hell
11:05:15 <aristid> edwardk: what's the intuition?
11:05:43 <edwardk> aristid: semantically record m = (,) m `liftM` m   but its allowed to be more efficient than that
11:06:07 <aristid> :t \m -> (,) m `liftM` m
11:06:08 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (m a1, a1)
11:06:35 <edwardk> aristid: record (ReaderT f) = ReaderT $ \e -> do (m, a) <- record $ f e; return (ReaderT $ \e -> e == e' then m else f e', a)
11:06:36 <hpc> that's an entertaining function
11:07:03 <aristid> edwardk: where does it prove useful?
11:07:30 <edwardk> hpc: i'm using it in my revision control monad, so you can run an action through record, and then it returns an optimized version of the action, and the result
11:08:10 <edwardk> so for instance there, i ran it in the current environment, and then on subsequent invocations of the returned monadic action it can short circuit, checking that the environment is the same and so just give you the answer
11:08:21 <aristid> revision control monad? soon, we'll be able to build git just by stacking monad transformers! :D
11:08:33 <hpc> edwardk: that sounds like higher-level thunking; i love it
11:08:38 <edwardk> aristid: http://github.com/ekmett/revisions
11:09:51 <edwardk> basically you fork and join and define 2 and 3 way merge strategies for different versioned variables, so that forks have their own copies of everything, but on join everything gets rectified
11:10:05 <edwardk> since the result is deterministic it can be run like ST
11:10:16 <hpc> edwardk: when you say "basically", it really isn't ;)
11:10:53 <edwardk> recording takes it one step farther and makes it so i can take that tree of forks and joins and recycle the branches that only depended on variables that haven't changed since we last ran the computation
11:11:48 <edwardk> that way you can take your mutate/calculate loop and record the calculation pass and subsequent invocations get to use the memoized 'partially evaluated' result wherever they can
11:12:06 <aristid> edwardk: is this a purely academic exercise, or do you think that this particular revision control monad can be used as such?
11:12:18 <edwardk> hpc: well, i could give the more complicated explanation with the skew binary history list, etc.
11:12:51 <edwardk> aristid: actually its something i'm planning on using directly on a number of projects. i've been also playing with a related checkpointing monad that can be used to fastforward the resumption of very long running computations
11:13:32 <aristid> edwardk: i do think that a lot of things can be improved with revision control
11:13:36 <edwardk> kind of like the bastard child of this and cloud haskell's thunking
11:14:05 <edwardk> aristid: daan leijen has a nice paper where he uses the revision controlled variable approach and some traditional imperative code for things like ray tracing, css layout, etc.
11:14:13 <aristid> where can i find it?
11:14:31 <edwardk>  daan leijen microsoft research, his page has a lot of papers, mostly about this
11:14:41 <edwardk> all i'm doing is reimplementing it using sparks instead of IO everywhere
11:14:48 <edwardk> and generalizing the record concept
11:15:47 <edwardk> anyways, he gets something like 2.5-6.4x speedup on 8 cores taking imperative algorithms and using the revision library, and then boosts that to 12-37x by using record.
11:15:58 <edwardk> by sharing work with previous iterations
11:16:33 <edwardk> why i care is i have a type checker that i want to do a lot of type error slicing, during which i'll be making minor changes to my input assumptions and checking to see if i still get the same error
11:16:47 <edwardk> er that i want to have do
11:17:13 <edwardk> so it makes sense to record the type checking pass, and then make those mutations each in turn
11:18:00 <edwardk> similarly if i take a packrat style parser and allow it to access a revision controlled symbol table, then i can share even context sensitive fragments
11:18:11 <aristid> is it this stuff? http://research.microsoft.com/en-us/projects/revisions/default.aspx
11:18:46 <edwardk> yes
11:18:49 <edwardk> http://research.microsoft.com/en-us/people/daan/ is a better link though
11:18:52 <edwardk> since it has more papers
11:19:25 <aristid> which can be considered most introductory?
11:19:38 <edwardk> "Prettier Concurrency"
11:20:03 <edwardk> and then the most recent one "Two for the Price of One" after you have the context
11:20:29 <edwardk> his implementation is very MVar'y
11:20:38 <edwardk> mine is actually pure (modulo my variable supply)
11:20:58 <edwardk> which is nice because then forked computations are just sparks
11:21:17 <edwardk> and i can throw them away or lazily evaluate them on join
11:21:19 <aristid> i hope i'll actually understand a bit of it :D
11:21:37 <aristid> i guess for some things a computer science degree wouldn't be so useless
11:21:39 <edwardk> it is actually disturbingly straighforward
11:21:58 <edwardk> fork :: m a -> m (Task m a)     join :: Task m a -> m a
11:22:23 <edwardk> and versioned variables that you use like IORef's or TVars reading and writing to them
11:22:39 <aristid> edwardk: perhaps slightly related: have you read this? http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html
11:22:54 <edwardk> but when you define the variable you are allowed to specify a merge strategy, which has access to both the forked and main versions and their least common ancestor
11:24:04 <aristid> glad i got a duplex printer
11:24:30 <edwardk> aristid: i hadn't but its a pretty straightforward article
11:25:25 <aristid> i'm not quite sure why i associated it with the things you're saying, but you never know why the brain does what it does :D
11:25:59 <sanjoyd> What is the difference between existential quantification and bounded quantification?
11:28:10 <Saizan> bounded quantification is where you impose some predicate on the type you are quantifying over, existential quantification is when you use the "exists" quantifier
11:29:03 <mgccl> I need to understand why fix f can terminate, the definition fix f = f (fix f) doesn't really give any termination conditions. I wonder where does it encode the information that if f (w/e just applied) = f, terminate.
11:29:10 <aristid> edwardk: do i get this right that instead of arbitrating between states, as in STM and other approaches, you arbitrate between transitions?
11:29:48 <edwardk> aristid: well, revisions never rollback, they only roll forward. you get two change sets and then you resolve them by mutating with the merge strategies
11:29:56 <Saizan> mgccl: that's the whole code, it'll terminate only if f is lazy enough
11:30:04 <edwardk> > fix (1:)
11:30:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:30:11 <hpc> mgccl: try evaluating fix (const 5)
11:30:19 <edwardk> > fix error
11:30:19 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:30:26 <troydm> from ghci for example i want to see definition of [] Monad
11:30:30 <troydm> how do i do that?
11:30:33 <hpc> fix (const 5) = const 5 (fix (const 5))
11:30:36 <hpc> = 5
11:30:42 <hpc> > fix (const 5)
11:30:43 <lambdabot>   5
11:31:05 <aristid> edwardk: i'm not sure whether this is more of a yes or more of a no
11:31:21 <sanjoyd> mgccl: fix f will terminate only if there is a case where f does not evaluate its argument.
11:31:24 <geheimdienst> "fix f" terminates only if f doesn't give a damn about its argument?
11:31:32 <simon> fix is fixpoint-iteration, right?
11:31:41 <hpc> simon: more or less, yeah
11:31:48 <hpc> simon: it's the same equation
11:32:02 <aristid> @src fix
11:32:02 <lambdabot> fix f = let x = f x in x
11:32:12 <hpc> key point (x = f x)
11:32:14 <aristid> i think this one is slightly easier for beginners:
11:32:17 <mgccl> > fix (\x -> (x*x)) 0
11:32:18 <lambdabot>   *Exception: stack overflow
11:32:20 <aristid> fix f = f (fix f)
11:32:33 <hpc> aristid: i like that definition too
11:32:39 <sanjoyd> mgccl: so if you're solving for the factorial function, there will be a point where you say "the integer is 0, so the factorial is 1" and you throw away the fixed point.
11:33:09 <sanjoyd> Saizan: the page on Haskell wiki gives this example:  data Worker x y = forall b. Buffer b => Worker {buffer :: b, input :: x, output :: y}
11:33:29 <mgccl> sanjoyd: see, thus that's why fix (\x->(x*x)) 0 doesn't work.
11:33:48 <sanjoyd> Isn't this bounded quantification?
11:34:53 <Saizan> it's both bounded and existential, i'd say
11:35:17 <sanjoyd> Saizan: can you given an example which is clearer, then?  Something that distinguishes the two more clearly?
11:35:24 <sanjoyd> s/given/give/
11:35:36 <Saizan> if you remove Buffer b it's not bounded
11:36:21 <sanjoyd> Isn't that universal quantification?  And anyways, what is the point of doing that?  I won't be able to use the b for anything, right?
11:36:37 <sanjoyd> (If I remove the Buffer b).
11:36:42 <sanjoyd> (Sorry if I'm being thick.)
11:37:01 <Saizan> well, universal and existential are dual of each other, so it's also a matter of your POV
11:38:10 <Saizan> which is why it's not so horrible to reuse the forall keyword to do what's an existential quantification in spirit
11:38:28 <Saizan> and, regardless of it being useful or not in this situation that's what it'd be
11:39:11 <Saizan> but it's true that you would be able to use the buffer field for anything interesting then
11:39:13 <hpaste> KitB pasted “Error installing lambdabot” at http://hpaste.org/53907
11:39:15 <Saizan> *wouldn't
11:39:27 <KitB> Anyone?
11:39:54 <Saizan> KitB: OS X?
11:40:01 <KitB> Arch Linux
11:40:30 <Saizan> anyhow, you might try removing the -fvia-C flag
11:40:49 <KitB> Quick way of doing this if building from cabal?
11:41:08 <Saizan> cabal unpack
11:41:18 <dcoutts> or possibly --ghc-options=-fasm
11:41:49 <Saizan> will that override {-# OPTIONS .. #-} ?
11:41:55 <KitB> Hmm
11:42:01 <KitB> I *might* have just run out of space
11:42:10 <KitB> on the partition I'm trying to install on
11:42:20 <KitB> That would be a hilariously simple solution
11:43:48 <Nimatek> KitB: I get the same on Arch, lack of free space is not the issue.
11:43:58 <dcoutts> Saizan: oh, no, just if it were in the .cabal file (I think)
11:44:15 <KitB> Ah
11:44:22 * KitB still needs to fix the free space issue
11:44:26 <KitB> Can't unpack it ^_^
11:46:19 <sanjoyd> Okay, this page was helpful:  http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html
11:46:22 <sanjoyd> Thanks Saizan!
11:47:12 <troydm> say i want to see definition of [] monad in ghci
11:47:19 <troydm> or in hoogle
11:47:22 <troydm> how do i do that?
11:47:27 <parcs> :i []
11:47:46 <parcs> oh, the monad
11:47:50 <shachaf> troydm: You can't see the source without looking at the source.
11:49:33 <troydm> even in hoogle?
11:49:59 <KitB> troydm: Hoogle can link to sources
11:50:04 <KitB> (I think)
11:50:09 * KitB uses hayoo
11:50:14 <gtirloni> i think it doesn't link to C src
11:50:35 <gtirloni> i was looking for the src code of seq the other day
11:50:36 <shachaf> gtirloni: Not many things are defined in C, though. :-)
11:50:40 <gtirloni> :)
11:50:50 <gtirloni> yea, not a problem at all
11:53:06 <bblum> hey guys, I'm trying to use Language.C, using the example code given in the tutorial, and the sample code builds but doesn't link: http://pastebin.com/fJUVXD6Y
11:53:09 <mauke> The paste fJUVXD6Y has been copied to http://hpaste.org/53908
11:53:37 <mauke> are you compiling with --make?
11:54:01 <wowdamn> ..and it was a weird sort of mutual recursion that saved the world
11:54:19 <mauke> wowdamn: did you see the annotations to your code?
11:54:43 <wowdamn> checking now
11:55:01 <bblum> mauke: oh, um, no; that seems to have fixed it
11:55:06 <wowdamn> oh wow this is awesome
11:55:11 <wowdamn> thanks ill brb later
11:55:17 <bblum> mauke: why does that make a difference?
11:55:43 <mauke> bblum: because --make tells ghc to automatically find (and if necessary, compile) all prerequisites
11:55:54 <rwbarton> and to link them to your program
11:56:00 <rotflcopter> @type (type (type (,,,,,)))
11:56:02 <lambdabot> parse error on input `type'
12:00:06 <hpc> whoa, i think i just managed to take apart the definition of callCC into comprehendable pieces
12:00:21 * hpc gives self a canada-sized cookie
12:04:58 <wyfrn> is there some weird way to make 'and' accept IO Bool ?
12:05:10 <bblum> thanks mauke
12:05:14 <shachaf> wyfrn: fmap?
12:05:20 <Shane_> @help
12:05:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:05:22 <shachaf> Er, wait.
12:05:30 <Shane_> @help pl
12:05:30 <lambdabot> pointless <expr>. Play with pointfree code.
12:05:32 <hpc> wyfrn: what is the type of the function you want?
12:05:41 <Shane_> @pl map
12:05:42 <lambdabot> map
12:05:45 <shachaf> Shane_: You can /msg lambdabot if you want to try things out. :-)
12:05:52 <Shane_> Oh really? Thanks :P
12:05:53 <wyfrn> [IO Bool] -> IO Bool .. with and semantic
12:05:56 <Shane_> Sorry about that
12:05:57 <Spockz> dcoutts: Is it possible to add extra mirrors to cabal installs? So you can have your own 'hackage' network?
12:06:03 <tsuraan_> @seen chrisdone
12:06:03 <preflex>  chrisdone was last seen on #haskell 22 hours, 49 minutes and 53 seconds ago, saying: forgot what i came on for, bbl
12:06:04 <lambdabot> Unknown command, try @list
12:06:07 <shachaf> wyfrn: fmap and . sequence?
12:06:13 <shachaf> @ty fmap and . sequence
12:06:14 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
12:06:19 <dcoutts> Spockz: yes, but they would not be mirrors, they mask
12:06:31 <sanjoyd> copumpkin: do you have the slides you used for the agda talk at Boston Haskell uploaded somewhere?
12:06:34 <hpc> :t and .: sequence
12:06:35 <lambdabot> forall (g :: * -> *). (Monad g, Functor g) => [g Bool] -> g Bool
12:06:44 <rwbarton> a totally different type!
12:06:44 <dcoutts> Spockz: the indexes of all the listed servers are merged, later ones masking earlier ones.
12:06:45 <hpc> (.:) = fmap fmap fmap
12:07:05 <rwbarton> note that these functions will execute all the actions even if one of the early actions had a result of False
12:07:06 <wyfrn> shachaf: thx ... iam still not smart enough :-/
12:07:06 <Spockz> dcoutts: ok, thx
12:07:07 <copumpkin> sanjoyd: hmm, yes, trying to remember where
12:07:15 <dcoutts> Spockz: for mirrors you'd want round-robin/fallback within a group I presume
12:07:18 <Spockz> dcoutts: we are thinking of putting up a mirror
12:07:26 <shachaf> rwbarton: Oh, true.
12:07:37 <copumpkin> sanjoyd: not sure they'll be particularly good for anything much outside of the talk, though: http://dl.dropbox.com/u/361503/Agda%20and%20dependent%20types.pdf
12:07:38 <KitB> Right
12:07:42 <poindontcare> question, how does one configure haskell,emacs so inferior-haskell-find-function definition works ?
12:07:43 <shachaf> wyfrn: If you want a smart "and" you might have to write it yourself.
12:07:44 * KitB is building with -fvia-c removed
12:07:46 <dcoutts> Spockz: how do you plan to do the mirroring?
12:07:53 <sanjoyd> copumpkin: I'm watching the talk on youtube. :)
12:08:03 <copumpkin> sanjoyd: /me crawls into a hole
12:08:27 <Spockz> dcoutts: actually it's two things we want to achieve 1) mirroring (fast cabal update) 2) Being able to install our own packages without polluting the hackage lib
12:08:47 <copumpkin> sanjoyd: hope you enjoy it :P I'm giving another one next week, probably
12:08:48 <sanjoyd> copumpkin: seriously, very good stuff. :)
12:08:49 <dcoutts> Spockz: then you might prefer to use the new hackage-server and its mirroring client
12:09:06 <copumpkin> sanjoyd: thanks :)
12:09:06 <sanjoyd> copumpkin: nice!  Where?
12:09:08 <homie> poindontcare: you have to have the ghc sources ?
12:09:09 <dcoutts> Spockz: it's designed with that use case in mind
12:09:10 <Spockz> dcoutts: it's mirroring client?
12:09:17 <poindontcare> homie: yes
12:09:17 <copumpkin> sanjoyd: same place, boston haskell meetup
12:09:23 <sanjoyd> copumpkin: oh, okay.
12:09:34 <dcoutts> Spockz: the new hackage-server impl comes with a mirroring client prog
12:09:35 <copumpkin> sanjoyd: you're not in the boston area are you?
12:09:44 <sanjoyd> copumpkin: no.  I live in a far off land.
12:09:47 <copumpkin> aw
12:09:57 <Spockz> dcoutts: ah right, but that actively mirrors/copies from the main server I suppose?
12:09:59 <dcoutts> Spockz: can do nearly-live mirroring (e.g. update every 30 min)
12:10:06 <poindontcare> homie: is that all i need will ghci installed from sources include line numbers in :info
12:10:07 <hpaste> KitB annotated “Error installing lambdabot” with “Error installing lambdabot (annotation)” at http://hpaste.org/53907#a53909
12:10:17 <Spockz> dcoutts: I was more thinking along the lines of a caching proxy
12:10:17 <KitB> New error
12:10:37 <homie> poindontcare: i don't know, never used linum-mode or so in info mode
12:11:02 <KitB> Saizan: Any ideas here?
12:12:17 <poindontcare> homie: do you use find function definition ? Or grep ? Or something else?
12:14:12 <homie> poindontcare: http://linux.about.com/od/emacs_doc/a/emacsdoc162.htm, they only work for emacs .el source files afaik....
12:14:25 <Saizan> KitB: the problem is that your libncurses.so is a linker script rather than a binary or a symlink to one
12:14:26 <homie> poindontcare: i don't know if haskell code would be possible too....
12:14:33 <KitB> Saizan: Indeed
12:14:39 <KitB> Sorry, I've been googling
12:14:46 <KitB> It's a bug in GHC <7.2
12:14:57 <KitB> Sort of
12:15:01 <KitB> Bug on both ends
12:15:06 <Saizan> yeah
12:15:12 <alistra> is there any pragma like LANGUAGE CPP for DrIFT?
12:17:07 <Cale> alistra: Perhaps OPTIONS_GHC -F -pgmF drift
12:17:09 <Cale> or whatever
12:17:31 <Cale> (I haven't tried DrIFT so I don't know what the binary is called)
12:17:44 <poindontcare> homie: there does seem to be something in haskell inferior mode for just this i think it is called inferior-haskell-mdoe , it however uses a regular expression which requires :info to respond with ---Defined at GHC.Bar 22 , it parses out the line number and jumps to haskell source. Would be neat if it worked :)
12:18:57 <homie> poindontcare: should be possible to make it work for haskell code, or write another for haskell code from scratch/or-almost-copy ....
12:19:41 <homie> poindontcare: i don't think having info mode a requirement for source be sane....
12:20:04 <poindontcare> yup yup
12:20:06 <homie> poindontcare: info is for info/documentation
12:21:19 <poindontcare> k, I thought it was a requirement, k will see, thanks
12:23:48 <alistra> Cale: thanks, it didn't help, but it pointed me to the right track :D
12:24:49 <alistra> Cale: there's a wrapper script, so the pragma is: {-# OPTIONS_GHC -pgmF drift-ghc -F #-}
12:25:02 <Cale> oh, hah, that works?
12:25:43 <Cale> (oh, perhaps drift-ghc is just a preprocessor still...)
12:28:39 <accel_> is there a release date for haskell platform for Osx Lion? ROARRRRRRRRRRRRRRRRRRRRRRR!
12:31:22 <shachaf> accel: Does the regular Haskell Platform not work with OS X Lion? ROARRRRRRRRRRRRRRRRRRRRRRR!
12:32:47 <accel> ROARRRRRRRRRRRRRRRRRRRRRRRRRR I believe it's only availalbe for snow leopard. ROARRRRRRRRRRRRRRRRRRRRRRRRR
12:33:07 <Mitsu> :/
12:33:07 <accel> My install from Snow Leopard "works" in that I can run ghc; but I get weird ld link errors GRRRRRRRRRRRRRRRRRRRRRRRR
12:33:34 <accel> so I'm hesistant to nuke my old install + reinstall (since it kinda works, except for the flood of link errors at the end of building a binary GRRRRRRRRRR)
12:36:47 <Mitsu> better yet
12:36:55 <Mitsu> uninstall your mac os.
12:37:12 <Mitsu> get a better one
12:37:15 <Mitsu> and then profit
12:37:49 <accel> i used linux laptop for many hears
12:37:53 <accel> many years
12:37:56 <accel> then I used mac laptop
12:37:58 <accel> then I use linux laptop
12:38:03 <accel> and I closed lid, expecting it to hibernate
12:38:07 <accel> and put it in bag
12:38:09 <accel> and burned screen
12:38:12 <accel> now I use mac products
12:38:44 <parcs> lol
12:38:48 <leod> hah
12:38:50 <wlangstroth> :)
12:38:56 <Mitsu> that's just linux yelling at you
12:38:59 <Mitsu> because you used a mac product
12:39:04 <Mitsu> apple(
12:39:05 <Mitsu> *
12:39:37 <PiRSquared17> ...
12:40:08 <PiRSquared17> Xcode
12:40:38 <jhance> accel: That's just a very poor configuration mistake.
12:40:51 <accel> nah; it's that I'm an idiot
12:40:57 <accel> for beliving that computers should work out of the box
12:41:00 <accel> without kernel recompiles
12:41:14 <parcs> jhance: configuration that shouldn't have needed to be configured
12:41:30 <Mitsu> so switching to a mac is a better solution?
12:41:31 <Mitsu> olol
12:41:33 <jhance> parcs: Well it has to have _something_ to be configured
12:41:40 <jhance> Whatever.
12:42:27 <parcs> accel: https://gist.github.com/1169332
12:44:17 <jhance> parcs: Not relevant, that's for 7.2 installation
12:44:23 <jhance> not platform
12:44:32 <accel> hmm
12:44:36 <accel> that only looks like 10 commands
12:44:42 <accel> I bet even I can figure itout.
12:45:08 <mike-burns> The state of development environments is sad these days. We're not a target audience.
12:45:27 <parcs> unless you write java and/or c#
12:45:27 <KitB> Right, so
12:45:30 <KitB> I have lambdabot running
12:45:36 <KitB> But it can't evaluate anything
12:45:37 <copumpkin> people prefer to make big fancy IDEs that write a whole bunch of boilerplate for languages that are impossible without the boilerplate
12:45:58 <parcs> haskell does have a lot of boilerplate that an ide could take care of though
12:46:01 <mike-burns> Even still, setting up an Android dev environment is more than one step.
12:46:09 <jhance> Unix is my IDE
12:46:10 <mike-burns> This has nothing to do with actually writing code.
12:46:11 <parcs> language pragmas and imports being the most prominent
12:46:18 <wlangstroth> mike-burns: boy howdy
12:46:37 <mike-burns> It's going from a new machine to writing hello world; that's too hard, still.
12:46:37 <hpaste> edwardk pasted “Capturing monads on tape” at http://hpaste.org/53910
12:46:54 <edwardk> well, i got the MonadRecord stuff to compile
12:48:36 <edwardk> so with those once i get the basic revision monad recording working, then you'll be able to use it in a monad transformer stack as well
12:48:59 <edwardk> though i'll probably rehome most of those instances to their respective packages to keep the dependency list small
12:49:15 <edwardk> for some reason i think there is a larger market for concurrency than there is for representable-tries
12:50:36 <edwardk> parcs: sadly i've had files where the pragmas took up more than the rest of the code ;)
12:51:02 <edwardk> so either i use too many extensions or write modules that are way too small ;)
12:53:01 <micrypt> Haskell + OS X Lion > Should I be using the Haskell Platform beta?
12:53:08 <micrypt> *experimental
12:53:53 <PiRSquared17> ?
12:57:50 <micrypt> PiRSquared17: Me? I'm referring to http://hackage.haskell.org/platform/mac.html (Experimental 64 bit support) Are there any issues with this or alternatives for OS X Lion?
12:58:01 <AtnNn> GHC 7.2.2 is out :)
13:00:08 <KitB> What provides ShowIO?
13:00:40 <rwbarton> ShowIO is some ancient thing IIRC
13:01:00 <KitB> It's a module, according to lambdabot
13:01:45 <PiRSquared17> :t ShowIO
13:01:45 <Axman6> @hoogle ShowIO
13:01:46 <lambdabot> Not in scope: data constructor `ShowIO'
13:01:46 <lambdabot> No results found
13:02:08 <rwbarton> well there's the ShowIO module which lambdabot uses for a Show (IO a) instance, is that what you're talking about?
13:03:08 <PiRSquared17> :t Show
13:03:08 <lambdabot> Not in scope: data constructor `Show'
13:03:13 <PiRSquared17> @hoogle Show
13:03:13 <lambdabot> Prelude class Show a
13:03:13 <lambdabot> Text.Show class Show a
13:03:13 <lambdabot> Prelude show :: Show a => a -> String
13:04:37 <KitB> @type ShowIO
13:04:38 <lambdabot> Not in scope: data constructor `ShowIO'
13:04:46 <KitB> @info ShowIO
13:04:46 <lambdabot> ShowIO
13:07:28 <elliott> KitB: <rwbarton> well there's the ShowIO module which lambdabot uses for a Show (IO a) instance, is that what you're talking about?
13:07:44 <elliott> hmm, I expected it to be part of http://hackage.haskell.org/package/show
13:07:59 <rwbarton> so did I
13:08:48 <KitB> rwbarton, elliott: that is almost certainly what I should be finding
13:08:50 <KitB> But I'm not
13:08:54 <KitB> I'm running lambdabot
13:09:01 <KitB> (this thing is impossible to get running)
13:09:02 <elliott> well, you can implement it like so:
13:09:17 <elliott> instance Show (IO a) where show _ = "<IO " ++ show (typeOf a) ++ ">"
13:09:18 <elliott> :-)
13:09:33 <KitB> elliott: That doesn't solve my problem :P
13:09:33 <elliott> or probably showsPrec 11 (typeOf a) ">"
13:09:37 <rwbarton> http://www.mail-archive.com/haskell-cafe@haskell.org/msg90264.html might be relevant
13:09:43 <elliott> KitB: sure it does, you can just roll your own rather than finding lambdabot's
13:09:56 <elliott> rwbarton: ah
13:10:09 <elliott> KitB: just patch lambdabot to import ShowFun instead :P
13:11:15 <KitB> elliott: No need to patch :P
13:11:17 <KitB> It's in L.hs
13:11:29 <KitB> (Thanks for the hint)
13:11:50 <KitB> Oh ffs :P
13:12:04 <KitB> Could not find module `Control.Parallel.Strategies'
13:12:09 <elliott> KitB: np, and install parallel package
13:12:22 <KitB> Am doing
13:12:31 <KitB> It's just annoying that it isn't listed as a dependency
13:14:29 <elliott> KitB: welcome to lambdabot
13:14:49 <KitB> elliott: :D
13:16:13 * hackagebot elerea 2.4.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.4.0 (GergelyPatai)
13:21:13 * hackagebot base 4.4.1.0 - Basic libraries  http://hackage.haskell.org/package/base-4.4.1.0 (IanLynagh)
13:24:40 <alistra> how long am i supposed to wait for the haddock docs to be generated
13:24:52 <elliott> a day or so
13:25:07 <elliott> or actually i think it's like 6 hours
13:26:07 <alistra> why is it so long?
13:26:30 <c_wraith> it's not independent
13:26:45 <c_wraith> all the packages' docs are built against each other
13:26:54 <c_wraith> and it does a full rebuild each time.
13:27:01 <c_wraith> if it did that on demand, it'd be a DOS vector
13:27:45 <elliott> hmm, it shouldn't have to do a full rebuild...
13:27:53 <elliott> just reverse dependencies
13:27:58 <elliott> which I guess it doesn't calculate now so ok :P
13:28:14 <alistra> i would understand 1h
13:28:24 <alistra> but 6h is kinda long :D
13:28:30 <elliott> alistra: you should get a refund
13:29:15 <alistra> hey, hackagebot says there's an exciting new lib
13:29:30 <alistra> and how i'm supposed to look up the exciting new features
13:29:45 <c_wraith> the release notes will have them, of course.  Oh, wait.
13:29:49 <c_wraith> :)
13:31:03 <alistra> also a dead link in the older base doc http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/System-Posix-Internals.html
13:32:22 <c_wraith> a lot of internal modules don't get hscoloured.  Not sure why, but it happens with the bytestring .Internal modules, too
13:35:52 <elliott> c_wraith: #hide, probably
13:36:29 <c_wraith> So...  I can't use hackage to look at the bytestring docs when I want to use the internal representation?
13:37:54 <elliott> c_wraith: you can't use haddock full stop
13:38:01 <elliott> c_wraith: pester bytestring maintainers
13:38:05 <elliott> or read the code
13:45:41 <lpeterse_> is it possible to catch the undefined exception?
13:46:09 <rwbarton> in IO, yes
13:47:12 <lpeterse_> how do I do that? I tried catch from Control.Exception, but it didn't work
13:47:49 <parcs> handle (\(_ :: ErrorCall) -> ...) undefined
13:48:10 <ne> suppose i have a function f :: t -> t.  is it possible to specify the formula for how f should operate when t is some specific type (say, Int)?  sort-of like patterns, except based on the type..
13:48:18 <parcs> > handle (\(_ :: ErrorCall) -> return ()) undefined
13:48:19 <lambdabot>   Not in scope: type constructor or class `ErrorCall'
13:48:43 <parcs> > handle (\(_ :: Control.Exception.ErrorCall) -> return ()) undefined
13:48:43 <lambdabot>   Not in scope:
13:48:44 <lambdabot>    type constructor or class `Control.Exception.ErrorCall'
13:48:44 <lpeterse_> parcs: this might answer my question. I didn't know of what type the exception was
13:50:31 <alpounet> c_wraith, why use the internal representation ?
13:50:59 <alpounet> that's an actual question, not a criticism
13:51:20 <KitB> I'm getting "unrecognised option --loadfile" from inside lambdabot when I run @check
13:51:23 <KitB> @check True
13:51:24 <lambdabot>   "OK, passed 500 tests."
13:51:25 <hpc> :t Control.Exception.ErrorCall
13:51:26 <lambdabot> String -> GHC.Exception.ErrorCall
13:51:26 <KitB> To be specific
13:51:38 <hpc> :k GHC.Exception.ErrorCall
13:51:39 <lambdabot> *
13:51:56 <c_wraith> alpounet: playing around with various implementations of isPalindrome, in this case.  I wanted to see how well I could manage when I had direct access to backing byte array and inlinePerformIO
13:52:26 <parcs> > return undefined :: IO ()
13:52:26 <lambdabot>   <IO ()>
13:53:16 <Sgeo|web> Is it fair to compare Iteratees to Python generators, except Iteratees don't need special language support?
13:53:30 <c_wraith> alpounet: benchmarking revealed my approach was faster than bytewise comparison without going through those mechanisms, but not as fast as using bulk operations that also exist in bytestring
13:54:16 <alpounet> c_wraith, ok, good luck then heh
13:54:36 <c_wraith> alpounet: this was something I was playing around with several months ago.  Nothing current
13:55:05 <alpounet> c_wraith, have you tried Data.Text too ?
13:55:08 <alpounet> to see how it performs
13:55:13 <alpounet> just out of curiosity
13:55:40 <c_wraith> alpounet: no, but it wasn't relevant in this case.  It also wouldn't admit the same mechanisms, because unicode is hard. :)
13:58:17 <lpeterse_> parcs: thanks, it works
13:58:49 <djanatyn> hmm, Y combinators
13:59:03 <djanatyn> do they have those in haskell?
13:59:20 <djanatyn> like, how do you define an anonymous function in.haskell
13:59:25 <copumpkin> :t fix
13:59:26 <lambdabot> forall a. (a -> a) -> a
13:59:28 <copumpkin> @src fix
13:59:28 <lambdabot> fix f = let x = f x in x
13:59:32 <copumpkin> that's all you need
13:59:46 <djanatyn> oh, cool
14:00:01 <copumpkin> you can't write the traditional Y combinator without some ugliness that comes with a lot of syntactic noise
14:00:15 <copumpkin> because the usual Y combinator is in the untyped lambda calculus
14:01:20 * hackagebot network-bitcoin 0.1.0 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.0 (MichaelHendricks)
14:02:55 <Saizan> Sgeo|web: an iteratee would be an user of a generator, but yeah
14:10:05 <hpaste> chrisdone pasted “strings from a haskell file” at http://hpaste.org/53911
14:10:19 <chrisdone> check this for an idea
14:10:34 <chrisdone> that code ran on itself:
14:10:35 <chrisdone> λ> withArgs ["-in=mod","-out=strings","Main.hs"] main ["","-",": ","=","Error: ","Expected -","Expected one or more ","No value for -","Unable to parse -","Usage: [files..] -in=<mod> -out=<json|strings> [files..]","calls","cons","files","in","out","string","type","value"]
14:11:23 <chrisdone> was thinking, it would be nice to have a haskell-aware grepper, i.e. "find me strings", "find me types", "find me values", "find me call sites"
14:11:44 <chrisdone> a sed, too
14:13:32 <byorgey> chrisdone: neat
14:13:41 <byorgey> chrisdone: hmm, couldn't you use some sort of generic traversal library to make that a lot shorter?
14:14:22 <chrisdone> byorgey: what library could do that? something using Data a => a?
14:15:03 <byorgey> chrisdone: my go-to would be uniplate, but there are others as well
14:15:06 <elliott> chrisdone: that would be about 9000000x shorter with syb
14:15:15 <byorgey> syb is another, yes
14:15:18 <elliott> you could literally do it as a oneliner, I think
14:15:46 <chrisdone> elliott: what would the one liner be?
14:16:03 <elliott> chrisdone: main = print . concatMap extractStringLiteral . listify (mkT isALiteral) $ theAST
14:17:11 <chrisdone> elliott: hmm. it would need to be a fold, as i need location information, which is not available in every node, so it needs to track parent nodes
14:17:24 <elliott> oh. it'd be a 30-liner then :)
14:17:29 <elliott> maybe not that much
14:17:36 <elliott> but yeah, this is pretty much what syb/uniplate were made for
14:20:45 <chrisdone> i'll read the uniplate manual
14:29:26 <simon> is there an or-like operator for Maybe values? I'd like Nothing `thisOrOperator` Just x = x
14:29:30 <chrisdone> elliott: actually, i think your one liner wouldn't work as the haskell-src-exts AST is composed of many different types, not one. that's from what i can tell from the uniplate api, anyway
14:29:35 <elliott> > Nothing <|> Just 42
14:29:36 <lambdabot>   Just 42
14:29:47 <elliott> chrisdone: I said syb, not multiplate. I haven't used multiplate, I do not know if it will work.
14:29:50 <chrisdone> elliott: so it will shorten it substantially, but it seems more or less every type of expression will need a separate piece of code
14:29:52 <monochrom> <|> is from Control.Applicative
14:29:56 <simon> right
14:29:58 <elliott> chrisdone: You want string literals, right?
14:30:00 <simon> thanks.
14:30:01 <elliott> So there is only really one type involved.
14:30:12 <monochrom> one more test:
14:30:18 <monochrom> > Just 3 <|> Just 42
14:30:19 <lambdabot>   Just 3
14:30:27 <chrisdone> syb, uniplate, multiplate…
14:30:31 <chrisdone> what's the difference?
14:30:51 <c_wraith> multiplate uses more plates than uniplate
14:31:04 <chrisdone> elliott: i'm scanning a whole module. i want string literals and their associated source location
14:31:25 * hackagebot Allure 0.4.2 - Near-future roguelike game in early development  http://hackage.haskell.org/package/Allure-0.4.2 (MikolajKonarski)
14:31:26 <aristid> c_wraith: the name gives it away :D
14:31:40 <chrisdone> (actually not just string literals, anything that is stringy. so literals, quasiquotes, rule strings, etc. but the problem is more or less the same)
14:31:55 <elliott> chrisdone: yep... you can be generic on any type that contains a SrcLoc
14:32:00 <elliott> and use it to update state while processing its children
14:32:18 <elliott> s/SrcLoc/whatever your data type uses/
14:32:35 <chrisdone> elliott: any type that contains srcloc, but surely i can't walk the haskell-src-ext AST generically?
14:32:47 <elliott> chrisdone: Is it an instance of Data?
14:32:48 <elliott> If so: yes.
14:32:57 <chrisdone> elliott: it's about 30 types which are all instances of data
14:33:01 <elliott> Right.
14:33:06 <elliott> That's sort of the point of /generic/ programming.
14:33:16 <elliott> Otherwise it'd be called specific programming and we wouldn't need packages for it :p
14:34:56 <chrisdone> i've used syb before, but that was really hard
14:35:19 * elliott does not find using syb hard. definitely not as hard as your current code :P
14:35:48 <chrisdone> testing it in the repl was basically impossible if i recall correctly until you had a big expression completely done and type correct
14:36:06 <shachaf> > everywhere (mkT (reverse :: String -> String)) "elliott"
14:36:07 <lambdabot>   "littole"
14:36:28 <elliott> chrisdone: on balance, testing a program that did this with syb requires about 100% less testing than your current code because you don't have to test all the boilerplate that is being scrapped :P
14:36:47 <chrisdone> elliott: i get the point, syb was still hard for me
14:37:05 <elliott> *shrug* it depends on what you're doing
14:37:15 * elliott found haskell hard too, before using it a lot :)
14:37:18 <bmm> is there a way for cabal to download dependencies automatically?
14:37:52 <alpounet> it does
14:37:58 <chrisdone> elliott: haskell in general is easy because you can do it in parts. code as generic as syb just tells you to sod off until everything is instantiated and correct
14:38:07 <elliott> alpounet: Cabal doesn't; cabal-install does
14:38:22 <shachaf> elliott: Haskell isn't hard anymore? Clearly you're not doing it right.
14:38:26 <chrisdone> (programming with haskelldb can be similar)
14:38:40 <elliott> chrisdone: i don't find that true at all, really... sure, you have to have your traversal structure down, but you should know that anyway
14:38:45 <alpounet> elliott, i think he meant the cabal binary, i.e cabal-install
14:38:46 <rwbarton> > everywhere (mkT (reverse :: String -> String)) ("hello", "world")
14:38:47 <lambdabot>   ("elolh","oldrw")
14:38:48 <elliott> what you do at the leaves can be filled in later
14:38:56 <rwbarton> wait
14:38:56 <rwbarton> oh
14:39:02 <elliott> alpounet: I suspect bmm is doing runhaskell Setup.hs configure or cabal configure and it's complaining about dependencies
14:39:11 <elliott> more precisely: cabal-install only does it in install mode :)
14:39:13 <rwbarton> right, a String has a String inside it
14:39:22 <rwbarton> > everywhere (mkT (reverse :: String -> String)) "abcdefghi"
14:39:23 <lambdabot>   "bdfhigeca"
14:39:23 <shachaf> rwbarton: It's kind of annoying.
14:39:26 <elliott> shachaf: wow, that's a really pretty way of writing that :)
14:39:27 <rwbarton> I can imagine.
14:39:32 <chrisdone> elliott: nevermind. you don't have to understand what i mean, it's just observation
14:39:38 <elliott> I mean, that effect
14:39:44 <elliott> chrisdone: what I said was observation too
14:40:14 <chrisdone> elliott: yeah, and some contradicting of my observation :)
14:40:25 <elliott> yep! let's violently disagree until the end of time :)
14:41:00 <byorgey> anyway, uniplate is easier to use than syb =)
14:41:10 <bmm> elliott: I'm experimenting with a KVM build machine to do automatic testing of cabal based projects. I would like to kick off "cabal test", but I need to get configure to work, which needs to install dependencies
14:41:26 <elliott> byorgey: i've been meaning to try uniplate sometime
14:41:29 <PiRSquared17> :t /=
14:41:30 <lambdabot> parse error on input `/='
14:41:30 <shachaf> > let f [] = []; f (x:xs) = reverse (x : f xs) in f "elliott"
14:41:31 <lambdabot>   "littole"
14:41:34 <PiRSquared17> :t (/=)
14:41:35 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:41:50 <elliott> bmm: cabal install --only-dependencies
14:41:55 <shachaf> > foldr (\x xs -> reverse (x : xs)) [] "elliott"
14:41:56 <lambdabot>   "littole"
14:42:03 <byorgey> bmm: cabal install --only-dependencies
14:42:27 <shachaf> > foldr (reverse .: (:)) [] "elliott"
14:42:29 <lambdabot>   "littole"
14:42:36 <shachaf> I wonder if there's a reasonable way to make SYB not do that.
14:42:43 <shachaf> The answer is probably Don't use SYB.
14:43:13 <elliott> shachaf: well you only want the topmost String, so I guess you could define a combinator to do it
14:43:22 <elliott> almostEverywhere
14:43:31 <shachaf> elliott: How would that combinator work?
14:43:36 <rwbarton> > everywhere' (mkT (reverse :: String -> String)) "abcdefghi"
14:43:37 <lambdabot>   "iahbgcfde"
14:43:50 <rwbarton> > everywhere'' (mkT (reverse :: String -> String)) "abcdefghi"
14:43:51 <lambdabot>   Not in scope: `everywhere'''
14:43:53 <elliott> shachaf: it wouldn't traverse into children if the transformation succeeds
14:44:10 <elliott> you might need to split the transformation into a "testing" and "operate" phase...
14:44:35 <Nimatek> KitB: my lambdabot refuses to evauluate as well. "mueval: Most RTS options are disabled. Link with -rtsopts to enable them." and building with -rtsopts flag had no effect on this.
14:44:52 <elliott> Nimatek: that's a ghc error
14:44:57 <elliott> you need to get mueval to pass -rtsopts to ghc, i guess
14:46:03 * shachaf looks up the definition of everywhere again.
14:46:16 <Nimatek> elliott: How can I get it to do that?
14:46:25 <elliott> dunno :)
14:46:29 <Nimatek> Hah.
14:46:32 <shachaf> Ah, so you have gmapT f []  = []; gmapT f (x:xs) = f x : f xs
14:46:49 <elliott> shachaf: I sort of wish there was a way to do generic programming without exposing implementation details.
14:46:50 <shachaf> everywhere f x = f (gmapT (everywhere f) x)
14:47:01 <elliott> Like, I suppose you can get tricksy with your Data instances.
14:47:05 <shachaf> And then mkT is implemented with cast.
14:47:25 <elliott> But "interface-generic programming" sounds as nice as it must be painful to implement.
14:47:25 <rwbarton> you'd need to replace mkT (reverse :: String -> String) with something that could indicate whether the replacement occurred
14:47:37 <shachaf> Right.
14:47:45 <Nimatek> Gentoo is nothing compared to lambdabot.
14:48:06 <shachaf> Norway is nothing compared to avocado.
14:48:40 <Nimatek> It was a joke on the difficulty of setting it up.
14:49:09 <shachaf> It was a joke on the obscurity of your joke.
14:49:41 <Nimatek> Yes, avocados are pretty obscure.
14:51:16 <simon> [ ] Programming in this language is an adequate punishment for inventing it.
14:51:25 * hackagebot certificate 1.0.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.0.1 (VincentHanquez)
14:58:27 <chrisdone> looks like the syb library can do what i want somehow, but figuring it out is giving me headache
14:58:47 <gienah> Nimatek: dev-haskell/lambdabot from the gentoo-haskell overlay should work, if you have problems with that ask us in #gentoo-haskell
14:58:59 <chrisdone> anyway i was pasting more to demonstrate the concept as maybe a nice idea, but will come back and talk about it later when my head is less hurty
14:59:33 <Nimatek> gienah: I am not on a gentoo install right now.
15:03:58 <gienah> Nimatek: ok, other options might be (1) chroot (2) gentoo prefix (experimental): http://www.gentoo.org/proj/en/gentoo-alt/prefix/ (3) look at the gentoo-haskell overlay ebuilds for hints, like this patch: https://raw.github.com/gentoo-haskell/gentoo-haskell/master/dev-haskell/lambdabot/files/lambdabot-4.2.3.2-eval.patch
15:06:35 <Nimatek> gienah: Thanks, I'll check it out
15:07:36 <KitB> Nimatek: Did you get it running?
15:07:46 <KitB> I can help you out here
15:08:26 <KitB> You need to add -rtsopts to the library and both executable sections in the .cabal file
15:08:55 <Nimatek> KitB: I solved that one by rebuilding mueval with -rtsopts
15:09:12 <KitB> What's wrong now?
15:09:21 <dufflebunk> If I have a DTD, is there a tool I can use which will generate a haskell module which can parse the XML?
15:09:22 <Nimatek> ShowIO :p
15:09:33 <KitB> Nimatek: Once you have it installed
15:09:40 <KitB> go into ~/.lambdabot/State
15:09:44 <KitB> and edit Pristine.hs
15:09:55 <KitB> modify the line "import ShowIO" to read "import ShowFun"
15:10:08 <Nimatek> KitB: Thanks, will do.
15:10:10 <KitB> do the same to L.hs
15:13:23 <KitB> Can lambdabot join password protected channels?
15:19:52 <Nimatek> Hm, it still complains about ShowIO after being built with ShowFun. This is strange.
15:20:32 <Nimatek> (and doesn't join channels either)
15:21:04 <acowley> Can someone explain pigworker's Hier.agda to me? I haven't written any Agda in a couple years and am totally lost.
15:25:27 <KitB> Nimatek: It's not about being built with it
15:25:38 <KitB> Go into ~/.lambdabot/State
15:25:43 <KitB> There are .hs files in there
15:25:48 <KitB> that attempt to import ShowIO
15:26:07 <Nimatek> Oh Those. I thought the ones in the unpacked build dir.
15:28:45 <byorgey> acowley: link?
15:29:50 <DukeDave> Can anyone thing of a nice function to take give me words of a string up until a given total string lenght
15:29:52 <DukeDave> ?
15:30:30 <DukeDave> Oh, oh, I know..
15:32:01 <acowley> byorgey: http://personal.cis.strath.ac.uk/~conor/pub/Hmm/Hier.agda
15:34:06 <DukeDave> No, I don't, my thought:
15:34:06 <DukeDave> > unwords . init . words . take 10 $ "here is my long string"
15:34:08 <lambdabot>   "here is"
15:34:40 <dgpratt> http://personal.cis.strath.ac.uk/~cono │ abbe
15:34:42 <DukeDave> But it drops the last word if it /just/ fits in
15:35:00 <abbe> hmmm...?
15:35:01 <RarrRaptor> take (10 + 1)
15:35:40 <DukeDave> RarrRaptor: Ha, yes,
15:35:48 * DukeDave should probably take a break
15:36:06 <edwardk> is there a good class like class Cache t where type Key t :: * insert :: Key t -> a -> t a -> t a; delete :: Key t -> t a -> t a; union :: t a -> t a -> t a  -- with instances for different LRU strategies using (Int|Hash)?Maps somewhere?
15:36:33 <copumpkin> dgpratt seems to have pasting issues sometimes :)
15:37:06 <edwardk> (obviously with lookup and the ilk as well, or the implementation is trivial
15:37:08 <edwardk> =)
15:37:17 <dgpratt> oh noes! did I do it again?
15:37:25 <alistra> :t 5
15:37:26 <lambdabot> forall t. (Num t) => t
15:37:33 <alistra> :k []
15:37:34 <lambdabot> * -> *
15:38:15 <elliott> edwardk: with no lookup? :)
15:38:31 <edwardk> elliott: see my comment a couple lines below =)
15:38:37 <elliott> oops :P
15:38:37 <dgpratt> well, I...apologize again!
15:38:42 <dgpratt> sheesh
15:39:28 * dgpratt is feeling super embarrassed
15:39:53 <acowley> edwardk: I'm not aware of one
15:40:28 <copumpkin> dgpratt: oh, it wasn't bad
15:40:32 <copumpkin> maybe it wasn't even a mispaste
15:40:39 <copumpkin> I was just talking about [06:45:41 PM] <dgpratt> http://personal.cis.strath.ac.uk/~cono │ abbe
15:40:46 <copumpkin> which looks like a truncated URL
15:41:19 <dgpratt> copumpkin: oh, I was worried I pasted more than that
15:41:26 <copumpkin> nope, sorry!
15:41:30 <dgpratt> (either way, it wasn't intentional)
15:41:50 <nicolector> hola hola
15:42:07 <acowley> hi!
15:42:21 <nicolector> how are you?
15:42:38 * Sgeo|web wants the Monad.Reader as an epub
15:43:26 <copumpkin> Sgeo|web: pandoc
15:52:40 <hpc> :t ((**), (^), (^^))
15:52:41 <lambdabot> forall a a1 b a2 b1. (Floating a, Num a1, Integral b, Fractional a2, Integral b1) => (a -> a -> a, a1 -> b -> a1, a2 -> b1 -> a2)
15:52:52 * ddarius hopes copumpkin is admiring his new permit.
15:53:03 <hpc> what an obnoxious set of functions
15:53:04 <shachaf> copumpkin has a permit? To do what?
15:53:23 <hpc> shachaf: to flip arrows in a squash category
15:54:57 <acowley> Does he still need a fully licensed practitioner to be standing at the board with him when he does it?
15:55:36 <shachaf> pumpkin: I hear you're permitted to flip arrows or something?
15:55:55 <acowley> that's why he lost the co
15:56:03 <acowley> he can go back and forth now
15:58:29 <dgpratt> so what does the typical "runhaskell Setup ..." actually do?
16:00:02 <dgpratt> particularly the "configure" and "install" cases
16:00:03 <ocharles> Hey, I'm playing around with HaskellDB and having problems with overlapping instances
16:00:11 <ocharles> https://gist.github.com/1359750 is my minimal problematic test case
16:00:29 <ocharles> it seems that making an attribute polymorphic doesn't work as well as I'd hope :(
16:00:44 <ocharles> the error is: https://gist.github.com/1359752
16:00:54 <hpc> dgpratt: "configure" checks dependencies, and "install" moves the compiled libraries to /usr/share, /usr/lib, or whatever
16:00:58 <hpc> afaik
16:00:59 <monochrom> "configure" detects your environment, e.g., what ghc you have, what libs you have
16:01:05 <ocharles> I can't understand exactly what it means though ,as the error says "[overlap ok]"
16:01:07 <monochrom> "install" includes "configure"
16:01:39 <monochrom> "install" is "configure" "build" "haddock" "copy" "register" the whole shebang
16:02:03 <dgpratt> hpc, et al: ok, thanks
16:02:39 <monochrom> most common mistake is "Setup configure --flags --moreflags" then "Setup install". buzz. the latter undoes the former.
16:03:42 <hpc> monochrom: really?
16:03:47 <monochrom> either "Setup intall --flags --moreflags" in the first place, or "Setup configure --flags --moreflags" then "Setup build" "Setup haddock" "Setup copy" "Setup register" etc
16:03:51 <hpc> i never had a problem with configure => build => install
16:03:53 <monochrom> really
16:04:00 <hpc> oh, that's why
16:04:05 <monochrom> oh sure if you add no flags
16:04:10 <shachaf> I never had a problem with "cabal install".
16:04:12 <hpc> with flags, too
16:04:24 <hpc> they were build flags though
16:04:38 <hpc> so i would build with profiling and without, then install, and both would be on my system
16:04:46 <dgpratt> why is "cabal install" the "preferred method"?
16:05:02 <dgpratt> (according to HaskellWiki)
16:05:09 <hpc> dgpratt: it calls Setup configure, etc, for you
16:05:15 <c_wraith> because it does transitive dependency installation
16:05:15 <monochrom> sorry, I see I may be wrong, I have to check
16:05:29 <hpc> and what more knowledgable people say :P
16:06:27 <monochrom> sorry, I am totally wrong. everything I said was about "cabal configure" and "cabal install" etc. Setup is totally different. hpc is right all along.
16:07:02 <monochrom> so the common mistake is "cabal configure --flags" then "cabal install" which loses the flags.
16:07:08 <Mitsu> I swear, as3 is trolling me.
16:07:24 <c_wraith> as3 is javascript, give or take.  So trolling would be accurate
16:07:33 <Mitsu> uh? lol?
16:08:01 <ddarius> c_wraith: ECMAScript
16:08:09 <c_wraith> did you mean an as3 other than actionscript 3?
16:08:48 <ddarius> Is "X is Y, give or take" a transitive relation?
16:08:53 <Mitsu> no lol, I was reffering to your comment saying as3 is javascript
16:09:22 <jhance> Mitsu: As3 _is_ javascript with glorified typing
16:09:32 <c_wraith> yes.  that wasn't a joke
16:09:35 <c_wraith> as3 is javascript
16:09:44 <jhance> ddarius: Lol
16:09:47 <Mitsu> \shrugs\
16:09:59 <c_wraith> ddarius: sounds like it. :)
16:10:00 <acowley> ddarius: no
16:10:01 <Mitsu> if you say so lol
16:10:03 <acowley> !
16:10:25 <acowley> I think give or take equality is symmetric and reflexive, but not transitive
16:10:49 <jhance> Aren't ECMAscript and javascript the same language though, acowley?
16:11:02 <ddarius> jhance: Give or take.
16:11:07 <acowley> hahaha
16:11:08 <hpc> lol
16:14:34 <Jafet> ECMAscript is a skin disease; javascript is a mind disease
16:14:57 <EvanR> lol
16:15:25 <hpc> and AS3 is a facelift gone horribly wrong?
16:16:42 <geheimdienst> ... at least those guys don't need a hundred lines of imports to get anything done ...
16:17:06 <shachaf> Silly geheimdienst. You can put as many imports as you like on one line, if you use semicolons.
16:17:45 <geheimdienst> shachaf: that's what i'm doing. it was 4000 import lines before
16:18:04 <Nimatek> Interesting. lambdabot works fine on freenode, but not on mibbit.
16:18:19 <acowley> Apparently we need a minifier for Haskell import blocks
16:18:49 <c_wraith> Nimatek: I ran into that.  You can use the @join directive interactively on mibbit.  I can't figure out why a join command run at startup doesn't work.
16:18:52 <hpc> geheimdienst: jesus herbert walker christ
16:18:58 <jhance> acowley: Eh?
16:19:21 <Nimatek> c_wraith: Not only that, it refuses to post anything in the channel. It does respond in a query though.
16:19:25 <Jafet> geheimdienst: do what the C programmers do; make a file containing all your imports
16:19:40 <geheimdienst> import EverythingAndTheDog
16:19:47 <hpc> (it's also what i do, though it takes more lines to pull it off)
16:19:50 <Jafet> That way, you can also make peace with incoherent instances
16:20:31 <Nimatek> Maybe a wildcard? import Control.Monad.*
16:20:38 <ddarius> Nimatek: That wouldn't make sense.
16:20:46 <hpc> Nimatek: that would be a disaster in many cases
16:21:05 <geheimdienst> you know, i actually hacked together an addition to Setup.hs that after building would write out all the modules in an "All.hs" file, so you'd only need to import that one file for the entire package (modulo clashes)
16:21:07 <Nimatek> I guess. but it would minimize the import blocks when done right.
16:21:23 <hpc> i think it would be nice to just have an "export" keyword for re-exported modules
16:21:26 <hpc> instead of export lists
16:22:19 <ddarius> Nimatek: There is no necessary relation between Control.Monad and Control.Monad.Foo nor between Control.Monad.Foo and Control.Monad.Bar.
16:23:03 <hpc> the only reason wildcards work in java is because packages are all prefixed with "com.oracle.db.database.sql.query..."
16:23:31 <ddarius> hpc: If that were true, then wildcardsd wouldn't work.
16:23:52 * ddarius wins literalism awards.
16:24:33 <jhance> imports aren't that big of a deal... Besides if you could wildcard import you would clash with the prelude A LOT
16:24:40 <hpc> ddarius: what i mean is, there's so much crap at the beginning that identifies where the code comes from
16:24:49 <ddarius> hpc: I know what you mean.
16:24:56 <hpc> oh :P
16:25:25 <shachaf> ddarius knows what you mean, but he won't let that get in the way of his literalism awards.
16:25:35 <hpc> apparently
16:25:39 <ddarius> shachaf: Damn straight.
16:25:39 <acowley`> We want qualified exports! We want "import qualified Data.Map as M (Map)" to import "Map" unqualified!
16:25:52 <Nimatek> c_wraith: Did you run into the bot not responding in channel problem, too?
16:26:08 <shachaf> acowley`: import qualified Data.Map as M; import Data.Map (Map)
16:26:24 <ddarius> hpc: The key thing in that case is that the hierarchy provides at least the information that the package are all from one "provider" and thus putatively related and conflict free.
16:26:37 <c_wraith> Nimatek: I did not run into that
16:26:47 <Nimatek> Hmm.
16:27:49 <elliott> Don't Java wildcard imports only import all names from a single module?
16:27:56 <elliott> Module. Whatever they're called. Package.
16:28:02 <hpc> in any event, modularity is really hard to get right
16:28:14 <opensourcegeek> hello guys
16:28:23 <ddarius> By contrast, Data.Graph is a completely different and incompatible library versus Data.Graph.Inductive produced by two separate parties.
16:28:36 <hpc> even agda's incredibly powerful module system has problems
16:28:43 <opensourcegeek> can someone please help me install scion in fedora 14?
16:28:47 <hpc> (in this case, me not being able to figure out wtf any of it means)
16:29:44 <dgpratt> `/quit
16:30:13 <ddarius> hpc: That might suggest that modularity is only really hard for you.
16:30:23 <opensourcegeek> i can't use cabal - it says expected ghc version is >= 6.10 and < 6.12
16:30:40 <ddarius> opensourcegeek: What GHC version do you have?
16:30:43 <opensourcegeek> and I have 6.12.3 from yum
16:31:45 <opensourcegeek> ddarius: should i reinstall ghc from source to get a compatible version?
16:32:54 <jhance> opensourcegeek: No! You should update cabal to the 6.12-compatible version
16:33:41 <hpc> ddarius: i mean in the general case
16:33:50 <opensourcegeek> jhance: sorry im new to haskell environment - so i did cabal update
16:34:03 <jhance> opensourcegeek: Are we talking about cabal-install or Cabal
16:34:07 <opensourcegeek> jhance: n i also ran cabal-install
16:34:14 <hpc> making your system powerful enough to allow for the different ways people organize their code
16:34:30 <jhance> opensourcegeek: Basically GHC and Cabal and Cabal-install all have to be the right version
16:34:58 <opensourcegeek> jhance: cool, I will check it now
16:35:00 <jhance> I don't know the right version for a ghc 7.2.1
16:35:05 <jhance> sorry, I mean 6.12.3
16:37:20 <monochrom> a ghc-6.12.3-compatible cabal is cabal-install version 0.8.2 using version 1.8.0.6 of the Cabal library
16:38:45 <opensourcegeek> jhance: I have the right version as monochrom has suggested
16:39:27 <opensourcegeek> if i do a cabal install scion after that I get the version incompatibility
16:40:21 <ddarius> jhance: The problem is simply that the version of scion that opensourcegeek has does not (claim to) build with GHC 6.12 or higher.  There is no brokenness.
16:40:36 <jhance> ddarius: Oh, that's odd
16:40:41 <ddarius> jhance: No it isn't.
16:41:01 <jhance> ddarius: Wait, where did we mention Scion
16:41:08 <monochrom> scion's scion.cabal doesn't even like ghc 6.12.x
16:41:09 <jhance> ddarius: I'm pretty sure we were talking about Cabal
16:41:29 <ddarius> jhance: You're wrong.
16:41:38 <monochrom> but I should "cabal update" and try again
16:41:42 <ddarius> Or at least, -you- are talking about Cabal.
16:42:08 <jhance> ddarius: Oh, I only read the part where he said that "Cabal was not working"
16:42:19 <opensourcegeek> guys, sorry I was talking about scion!
16:43:10 <opensourcegeek> I want to be able to install scion with the current version and I wasn't sure if I had to install ghc manually rather than from repo to make it work with scion
16:43:11 <monochrom> "cabal: cannot configure scion-0.1.0.2. It requires ghc >=6.10 && <6.12"
16:43:51 <monochrom> no, don't try that. only two sane options to try.
16:43:52 <opensourcegeek> monochrom: yes thats the message I see
16:44:13 <monochrom> 1. edit scion.cabal to allow your favourite ghc version
16:44:20 <monochrom> 2. use an older GHC
16:44:43 <opensourcegeek> option 1 sounds easier to me
16:45:11 <monochrom> but IIRC it's a real API change from 6.10 to 6.12, lying won't go far
16:45:43 * gienah likes option 1, then fix the breakage
16:45:52 <opensourcegeek> would there be any issues if I edit cabal file and run cabal install then?
16:46:19 <ddarius> opensourcegeek: It will fail to build.
16:46:21 <gienah> opensourcegeek: most likely, you would need to try it and see what breakage you get :-)
16:46:33 <ddarius> Or maybe it won't, and it will break in nefarious ways.
16:46:36 <ddarius> Or maybe it won't.
16:46:37 * monochrom would not even try
16:47:23 <opensourcegeek> hmmmm so it might result in unpredicted behaviour...
16:47:51 <ian_mi> actually, the failure has been predicted
16:47:55 <opensourcegeek> I need to install ghc which is compatible then?
16:48:25 <opensourcegeek> k another thing is I'm trying to use eclipse ide for doing haskell - hence my necessity for scion
16:48:48 <gienah> opensourcegeek: oh no, looking on hackage I see scion uses ghc API, this would be difficult to bump
16:50:03 <opensourcegeek> i know leskah is out there, its quite different from what I'm used to though - eclipse cause I do java, C development in it
16:50:48 <opensourcegeek> it would be nice to use the same IDE to do haskell as well! ah well, if it doesn't work I can just go back to vim
16:51:13 <jhance> Vim is wonderful for haskell because haskell is much different than Java or C. It has ghci.
16:51:52 <clsmith> truth. repls change everything :p
16:52:00 <hpc> agree; all you really need to dev in haskell is a terminal for vim and a terminal for ghci
16:52:05 * monochrom knew of a Casio calculator that had a C interpreter
16:52:08 <clsmith> sooo, what's that tool which lets me check for holes in my pattern matches?
16:52:15 <hpc> clsmith: hlint?
16:52:20 <hpc> clsmith: or -Wall
16:52:33 <gienah> opensourcegeek: for scion the first thing to try would be to try building it from the github repo: https://github.com/nominolo/scion
16:52:37 <ddarius> or Catch
16:52:47 <monochrom> or ask monochrom
16:53:11 <clsmith> ah, i was thinking of catch, but i always forget about -Wall <.< need to stick it in my makefile
16:53:13 <opensourcegeek> jhance: i agree - but wouldn't it be nice to have a single ide for different languages...
16:53:25 <dpratt71> I'm late to this convo, but is there any reason to prefer vim over emacs (or vice versa) for Haskell hacking?
16:53:35 <opensourcegeek> ... oh well i live in an ideal world - forgetting side effects :)
16:53:42 <hpc> dpratt71: not especially; both are editors, kinda
16:53:47 <monochrom> no reason
16:53:50 <clsmith> opensourcegeek: i find text editors are more useful for many different languages than IDEs are
16:54:10 <clsmith> dpratt71: well, the reason to prefer vim over emacs is whether you get on with vim or emacs...
16:54:25 <saati> i tried compiling something with -O2 and i got some output (warning maybe) that i can't decipher: SpecConstr Function `$w$j{v s1mM} [lid] has two call patterns, but the limit is 1
16:54:29 <hpc> emacs is going to be for the crowd that prefers to wear the fancy pants, and vim is going to be for the people who are sensitive to a third of a second of startup time
16:54:32 <monochrom> eclipse is cool. do what gienah says, try the repo version of scion first
16:54:55 <dpratt71> clsmith: I think I could do either; emacs is more like what I'm used to (a bit), but I appreciate the 'philosophy' of vim
16:55:02 <monochrom> people are just looking for excuses to talk people out of IDEs
16:55:04 <clsmith> hpc: and who are too simple to remember a small number of keybindings, at the end of the day
16:55:07 <opensourcegeek> clsmith: you are right most of the coding can be done with text editors - when it comes to debugging i really love ides
16:55:19 <hpc> clsmith: :P
16:55:27 <ddarius> hpc: A third of a second is a palpable amount of time.
16:55:46 <hpc> clsmith: both have fairly minimal bindings, but i don't really like how emacs' are laid out
16:55:50 <jhance> does EclipseFP use cabal files for projects or does it have its own project
16:56:05 <blackdog> opensourcegeek: might be why they're not super-popular with haskell hackers - there's more up-front work and less belting a program into shape at runtime
16:56:07 <opensourcegeek> jhance: apparently it uses cabal files
16:56:09 <hpc> it seems really easy to screw up C-x C-c c and C-x C-c C-c
16:56:17 <hpc> or something like that, and mess up everything
16:57:10 <hpc> eclipse is a fantastic IDE though, even if it's stupefyingly fat
16:57:11 <clsmith> screen and shell hurt my little finger enough without emacs taxing it
16:57:36 <opensourcegeek> gienah: i'm trying scion from source
16:57:36 <gusto> clsmith: gnu screen?
16:57:40 <clsmith> i just found eclipse (1) unbearably slow, and (2) impossible to comprehend.
16:57:41 <hpc> if the effort and features that went into eclipse went into all other IDEs, i might consider using one
16:57:43 <clsmith> gusto: yeah
16:57:49 <gusto> clsmith: i am using tmux
16:57:53 * monochrom knows someone who even talks you out of X11
16:58:03 <clsmith> yeah, i've been recommended tmux, but have yet to try it out
16:58:05 <hpc> clsmith: the magic shortcuts in eclipse are ctrl+1 and f2
16:58:16 <hpc> and i think f3 for javadoc
16:58:26 <gusto> clsmith: it's so cool that you never want screen back
16:58:40 <clsmith> i open it and am blown backwards from my chair by the vast array of buttons and options and panes
16:59:26 <hpc> clsmith: the first thing i do when i install eclipse is close all the windows except the code viewport
16:59:38 <hpc> then add panes i want as i decide they are helpful
16:59:47 * ddarius doesn't know how javadoc helps him with Haskell hacking.
16:59:52 <hpc> same for most of the configuration options, which there's a lot of
16:59:54 <clsmith> it's the menus, too. so many menus.
17:00:08 <gusto> yes
17:00:24 <gusto> there is need for more simplicity, like in browsers
17:00:24 <hpc> ddarius: im talking about using eclipse for java; it's kind of shitty for other languages because the plugins don't do everything eclipse does
17:00:41 <clsmith> i barely use any features in vim. autocompletion scares me away. it frightens me when my text editor starts popping stuff up everywhere.
17:01:10 <gusto> hpc: i think eclipse is only usable for java, and maybe c++
17:01:32 <hpc> gusto: i haven't ever gotten C or C++ modes to work in eclipse
17:01:38 <hpc> python is almost managable
17:01:41 <gusto> hpc: you see?
17:02:25 <hpc> for me the nicest part of vim is command-mode
17:02:34 <opensourcegeek> gienah: its weird
17:02:35 <hpc> ghci says error on line 141, i can just type :141
17:02:46 <opensourcegeek> i got the code from github
17:03:11 <clsmith> hpc: yeah. i also make much use of :%s/../../gc
17:03:20 <opensourcegeek> and when i run cabal install in source package it says version it needs is >= 6.12 & < 7.3
17:03:32 <hpc> actually, i lie
17:03:41 <hpc> the nicest part is typing a number, then an arrow key
17:03:42 <gienah> opensourcegeek: I'll try building scion from github
17:03:45 <opensourcegeek> but when i run ghc --version, it says 6.12.3
17:03:50 <hpc> 11*down* moves me 11 lines down
17:04:11 <clsmith> i wish 'f' and 't' wrapped over lines
17:04:13 <hpc> if i want to delete a lot of code i just type d11111111*down* and poof, gone
17:04:29 <monochrom> dG
17:04:30 <clsmith> you have that many lines of code? :o
17:04:31 <hpc> i wish 'e' and 'w' skipped over more punctuation
17:04:33 <ddarius> hpc: You use arrow keys?  What's wrong with you?
17:04:40 <ddarius> hpc: dG
17:04:43 * clsmith uses arrow keys
17:04:45 <hpc> :P
17:04:47 <clsmith> hpc: dW
17:04:54 * hpc can't remember which directions hjkl go in
17:04:55 <clsmith> W is a bigger w
17:04:58 <geheimdienst> hpc: W and E and B skip to the next space
17:05:07 <opensourcegeek> gienah: i ran cabal configure first sorry - thats when I saw the error
17:05:10 <ddarius> I use arrow keys too, but less so with vim and I would never do 11*down*.
17:05:20 <monochrom> h goes the direction of ctrl-h, j goes the direction of ctrl-j, that's how I remember
17:05:20 <opensourcegeek> i didn't even get to build
17:05:24 <jhance> I probably use ce more than I use i
17:05:29 <ddarius> hpc: Hopefully you can remember h and l.
17:05:49 <clsmith> monochrom: nice way of remembering. but ofc, it's mostly muscle memory
17:05:54 <hpc> ddarius: i can't remember if it's vertical on the inside or outside
17:05:56 <gienah> opensourcegeek: I'm trying to build it to see what happens
17:06:09 <opensourcegeek> gienah: sure thanks mate
17:06:09 <hpc> i know that left is left/up and right is right/down though
17:06:12 <hpc> i think
17:06:25 <ddarius> hpc: Left is the leftmost one.  What else would it be?
17:06:30 <opensourcegeek> gienah: may be its too late and I should hit the sack!! :)
17:06:39 <hpc> ddarius: oh, that helps
17:06:44 <clsmith> i know l goes right simply because i abuse gU5l
17:06:46 <monochrom> the real question is who the hell (apart from oldgeezers like me) care to remember what ctrl-h and ctrl-j do
17:06:51 * hpc should probably actually look at his keyboard one of these days
17:07:07 <ddarius> hpc: That wouldn't help me.  It's dhtn for me.
17:09:28 <dylex> ddarius: I actually use htns instead of hjkl because I got used to hjkl for a long time before remapping, so kept h.
17:10:29 <opensourcegeek> gienah: any luck??
17:11:00 <shachaf> hpc: Command mode is the only mode vi has.
17:11:00 <monochrom> probably killed his computer XD
17:11:01 <gienah> opensourcegeek: working on it, haven't got to try it yet
17:11:25 <elliott> shachaf: You should have to press whatever letter you want to insert at the same time as i.
17:11:40 <elliott> Truly modeless.
17:12:07 <shachaf> elliott: It's already modeless, although it has variable-length commands.
17:12:29 <elliott> Heh.
17:13:40 <ddarius> Like the iinsert this text command
17:13:43 <monochrom> ed is the modeless one
17:13:55 <Bfig> > unfold (\_ -> True) head reverse "ja"
17:13:56 <lambdabot>   Not in scope: `unfold'
17:14:04 <Bfig> > prelude.unfold (\_ -> True) head reverse "ja"
17:14:04 <lambdabot>   Not in scope: `prelude'Not in scope: `unfold'
17:14:12 <shachaf> ddarius: Precisely. Esc-terminated.
17:14:13 <Bfig> > Prelude.unfold (\_ -> True) head reverse "ja"
17:14:14 <lambdabot>   Not in scope: `Prelude.unfold'
17:14:20 <shachaf> For example, 3iabc<esc> inserts "abcabcabc".
17:14:37 <Bfig> mmm... ?
17:14:51 <shachaf> d3/abc<enter> deletes from the cursor to the third occurence of "abc".
17:16:01 <monochrom> http://www.gnu.org/fun/jokes/ed.msg.html
17:17:18 <gienah> opensourcegeek: it built without the server option, failed when trying to build haddock docs for scion
17:17:37 <gienah> opensourcegeek: I'll try it again with the server option
17:17:56 <hpc> Bfig: unfoldr or unfoldl
17:18:06 <hpc> :t unfoldr
17:18:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:18:09 <hpc> :t unfoldl
17:18:10 <lambdabot> Not in scope: `unfoldl'
17:18:14 <Bfig> i didn't think it would make any sense to unfoldl
17:18:42 <hpc> @src unfoldr
17:18:42 <lambdabot> unfoldr f b  = case f b of
17:18:42 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
17:18:42 <lambdabot>    Nothing        -> []
17:18:43 <EvanR> unfoldl doesnt exist, i think
17:18:50 <hpc> yeah, it doesn't
17:18:59 * monochrom volunteers to write an unfoldl for you
17:19:01 <hpc> oh right, it's scanl/r
17:19:03 <Bfig> > unfoldr (\x -> Just (head x, reverse x) ) "ja"
17:19:04 <lambdabot>   "jajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajajaja...
17:19:47 <hpc> ...oh hey: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#v:unfoldl
17:19:52 <gienah> opensourcegeek: scion builds fine with server option (no haddock docs) with ghc 7.0.4 from github
17:20:13 <hpc> and i just discovered the menu key is for composing unicode in putty
17:20:27 <monochrom> nice
17:20:29 <opensourcegeek> gienah: hmmm, may be I need to get a more recent version of ghc
17:20:41 <gienah> opensourcegeek: all I did was bump some dependencies: sed -e 's@attoparsec   >= 0.8.5.1 && < 0.9@attoparsec   >= 0.8.5.1 \&\& < 0.10@' 's@unix-compat  >= 0.2 && < 0.3@unix-compat  >= 0.2 \&\& < 0.4@' scion.cabal
17:21:45 <opensourcegeek> i dont understand, cause I do have 6.12.3 but it still complains
17:21:48 <gienah> opensourcegeek: sed line missing a -e before the second s script
17:21:49 <monochrom> yikes, did you write that sed script by hand?
17:22:13 <gienah> opensourcegeek: I'll try it with ghc 6.12.3
17:22:54 <elliott> monochrom: Don't you like writing sed scripts? :(
17:23:34 <gienah> monochrom: yes :-)
17:23:41 <monochrom> not if a lot of escapes are involved
17:24:24 <ddarius> monochrom: What do you use to write your sed scripts for you?
17:25:19 <monochrom> I have written about 20 characters worth of sed scripts in my whole life, luckily they needed few escapes.
17:25:47 <hpc> i think i would have used perl
17:25:54 <monochrom> I haven't needed more sed scripts. I get by with writing by hand.
17:25:54 <hpc> more lines, but less pain
17:26:49 <ddarius> @google purely functional 1-2 brother trees
17:26:52 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
17:26:57 <ddarius> @google purely functional 1-2 brother trees
17:26:57 <monochrom> but there is the prospect of having diff write one for you
17:26:58 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
17:27:07 <ddarius> Hmm.
17:27:16 <hpc> wow, who wrote half these plugins?
17:27:27 <hpc> @quote
17:27:27 <lambdabot> WilliamTaysom says: The journey to the dark side begins with the desire for power. In our case the power function
17:27:50 <hpc> half the time @quote fails, too
17:28:11 <monochrom> may be host problem
17:28:55 <elliott> Clearly we need seddiff.
17:29:54 <monochrom> yikes, diff offers to write an ed script instead
17:30:23 <elliott> unfortunately ed is not sed-compatible :)
17:30:26 <monochrom> well, on the bright side, "take that, vi!"
17:30:27 <elliott> and doesn't work on infinite streams!
17:30:50 <ddarius> @google purely functional brother trees
17:30:52 <lambdabot> http://www.cs.ox.ac.uk/ralf.hinze/publications/Brother12.pdf
17:30:52 <lambdabot> Title: FUNCTIONAL PEARLS Purely Functional 1-2 Brother Trees
17:31:19 * monochrom thinks of "bromance"
17:31:42 <geheimdienst> bro trees before ho trees
17:32:28 <gienah> opensourcegeek: scion wants http://hackage.haskell.org/package/canonical-filepath, and canonical-filepath wants >=ghc-7.0 (as it wants directory ==1.1.*, filepath ==1.2.* which are ghc core packages)
17:33:24 <opensourcegeek> gienah: okies then should it not say ghc >= 7.0 when it fails to build
17:33:38 <opensourcegeek> its a bit misleading i guess
17:34:47 <gienah> opensourcegeek: yes I wonder if it should as wanting ghc core libs that are only present in >=ghc-7.0 is an obscure way to say it really wants >=ghc-7.0
17:35:11 <monochrom> wait, http://hackage.haskell.org/packages/archive/canonical-filepath/1.0.0.1/canonical-filepath.cabal shows no ghc bound
17:35:33 <monochrom> oh, nevermind, I see what you mean
17:37:59 <monochrom> onoes, GHC 7.2.2 is out
17:38:49 <dufflebunk> If I have a DTD, is there a tool I can use which will generate a haskell module which can parse the XML?
17:38:54 <opensourcegeek> gienah: oh well, i will try updating my ghc and trying again
17:39:17 <opensourcegeek> i can't see any other way out!!
17:39:34 <gienah> opensourcegeek: for scion it seems that it wants ghc-7.0.4, scion also fails to build with ghc 7.2.1 due to differences in the ghc api
17:39:36 <opensourcegeek> oc i can always use my vim :)
17:39:57 <monochrom> dufflebunk: IIRC yes, let me find one
17:40:22 <gienah> opensourcegeek: I guess using vim would be easier to get started
17:41:46 <opensourcegeek> gienah: okies thanks for your time mate
17:41:58 <gienah> opensourcegeek: no worries
17:43:18 <dufflebunk> Ah, something in this, I think: http://hackage.haskell.org/package/HaXml
17:47:54 <monochrom> yes, that's the one. it contains "a translator from DTD types to Haskell datatypes" ( http://projects.haskell.org/HaXml/ )
17:48:07 * monochrom misremembered that it's in hxt
17:50:53 <dufflebunk> Thanks monochrom
17:57:16 <Mitsu> > t: Int
17:57:17 <lambdabot>   Not in scope: data constructor `Int'
17:57:23 <Mitsu> k
17:58:04 <Mitsu> > [ (a,b,c) | a <- [1..24], b <- [1..24], c <- [1..24], a^2 + b^2 == c^2, a + b + c == 24]
17:58:05 <lambdabot>   [(6,8,10),(8,6,10)]
18:00:31 <gienah> opensourcegeek: blog post seems to say eclipsefp no longer wants scion: http://jpmoresmau.blogspot.com/2011/11/eclipsefp-220-released.html
18:02:47 <opensourcegeek> gienah: interesting, that would be brilliant - let me try it and see!!
18:12:18 <dpratt71> as part of my Haskell on Linux experiment, I thought I might build GHC from sources, just for fun
18:13:02 <dpratt71> I'm a little concerned, though with how that might interact with the Haskell bits I already have installed
18:13:09 <dpratt71> justifiable concern?
18:13:18 <shachaf> You can have multiple versions of GHC installed at the same time.
18:13:57 <Jafet> Or you can just not install it
18:14:15 <shachaf> Jafet's approach is quite effective.
18:14:27 <dpratt71> ok
18:16:29 <opensourcegeek> gienah: thats brilliant - i had to update my eclipse but its worked!
18:17:08 <opensourcegeek> i can do haskell hacking inside eclipse now!
18:17:22 <gienah> opensourcegeek: that's great :-)
18:22:55 <opensourcegeek> now a more theoretical question - i'm having trouble grasping monads, i went through several tutorials and books
18:23:40 <Jafet> Of course you'd have trouble with that! Monads aren't corporeal.
18:23:44 <RarrRaptor> Monads are simple. They're like burritos filled with space suits.
18:23:54 <RarrRaptor> That's what I've been told by people in the know.
18:23:56 <opensourcegeek> everyone seems to differ in the ideas
18:25:14 <mike-burns> That's a theorectical question?
18:25:17 <opensourcegeek> for someone who is new to functional programming monads are hard to understand - atleast for me!
18:26:28 <c_wraith> fortunately, they're not really that important to understand.
18:26:43 <opensourcegeek> mike-burns: sorry mostly people talk about monadic laws and introduce symbols purely mathematical
18:26:48 <c_wraith> despite what anyone may have told you to the contrary, monads are not an important part of haskell.
18:27:02 <mike-burns> And the monads in Haskell are not particularly mathematical.
18:27:18 <mike-burns> It's some functions.
18:27:21 <opensourcegeek> c_wraith: interesting, i thought side effects are always handled by monads
18:27:48 <c_wraith> opensourcegeek: the way IO is handled happens to fit into haskell's representation of a monad.  but that fact is 100% irrelevant for actually using it.
18:28:20 <acowley`> Monads are a red herring when learning Haskell. You will eventually encounter a problem whose solution is precisely the interface monads describe; let it happen naturally.
18:29:13 <opensourcegeek> so from a clean state of mind - if i write something that needs to do some network io, i would need to separate handling io and logic
18:29:33 <acowley> s/need/should
18:30:09 <opensourcegeek> and handling io, would it be monads?
18:30:22 <BMeph> NO!
18:30:33 <c_wraith> handling IO is done with IO.
18:30:40 <opensourcegeek> or are you saying there are modules that does it for you and you just make use of it?
18:30:45 <acowley> it's a well named type!
18:30:45 <c_wraith> you don't need to ever care about the word "monad"
18:30:53 <mike-burns> Monad is some typeclass.
18:31:22 <mike-burns> Just like Eq is.
18:31:30 <Jafet> It's more fun to write a whole network program in applicative IO
18:32:36 <opensourcegeek> wow, so how do you guys do it - if you are writing an interface for outside world like db or screen or serial comms?
18:32:47 <mike-burns> I use putStrLn most of the time.
18:32:56 <c_wraith> also, getLine
18:33:01 <c_wraith> those are good things
18:33:08 <Jafet> @where lyah
18:33:08 <lambdabot> http://www.learnyouahaskell.com/
18:33:10 <Jafet> @where rwh
18:33:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:33:28 <mike-burns> @type putStrLn
18:33:29 <lambdabot> String -> IO ()
18:33:31 <c_wraith> many simple command-line programs can be written with no more use of IO than those two workers
18:33:32 <RarrRaptor> @where raptors
18:33:32 <lambdabot> http://funstoo.blogspot.com/2011/02/rarr-i-am-dinosaur-hat-delightful.html
18:33:37 <incluye> @type getLine
18:33:37 <lambdabot> IO String
18:33:42 <c_wraith> holy crap, raptors.
18:33:58 <me23> what would be a good way to make a queue in haskell?
18:34:03 <RarrRaptor> Rarr!
18:34:11 <me23> like best data structure to use, etc
18:34:25 <mike-burns> I recommend using a queue.
18:34:44 <c_wraith> me23: take a look at Chris Okasaki's work.  he's described several good queue implementations for languages like haskell
18:34:59 <c_wraith> me23: start with his thesis.  It's actually pretty readable
18:35:24 <acowley> me23: use Seq
18:35:43 <acowley> me23: then read Okasaki
18:35:48 <opensourcegeek> lambdabot: thanks for the links
18:36:48 <opensourcegeek> i'm through few chapters in RWH, but every now and again i hear about monads
18:36:56 <PiRSquared17> > map (+ 1) [0..]
18:36:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:37:24 <mike-burns> I mean, learn about the monad typeclass if you're into it, but don't make it into some grandiose thing.
18:37:26 <PiRSquared17> @pl \x -> \y -> \z -> z y x (x y z ap)
18:37:26 <lambdabot> ap (ap . (ap .) . flip (flip . flip id)) (flip flip ap . (flip .))
18:37:46 <dufflebunk> Is there an already made version of an explode function... explode "123/456/789" "/" = ["123", "456", "789"]
18:38:01 <acowley> opensourcegeek: the main thing we get all riled up about is that you shouldn't unnecessarily conflate IO with monads in general
18:38:07 <PiRSquared17> :t explode
18:38:07 <lambdabot> Not in scope: `explode'
18:38:14 <RarrRaptor> @src words
18:38:14 <lambdabot> words s = case dropWhile isSpace s of
18:38:14 <lambdabot>     "" -> []
18:38:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:38:29 <PiRSquared17> @src map
18:38:29 <lambdabot> map _ []     = []
18:38:29 <lambdabot> map f (x:xs) = f x : map f xs
18:38:37 <PiRSquared17> @src ap
18:38:37 <lambdabot> ap = liftM2 id
18:38:43 <PiRSquared17> @src liftM2
18:38:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:39:11 <mike-burns> The opposite of `intercalate'.
18:39:45 <dufflebunk> mike-burns, Yeah
18:39:59 <mike-burns> I think I had to write that myself.
18:41:27 <acowley> splitOn "/" "123/456/789"
18:42:05 <acowley> (splitOn is from the split package)
18:42:50 <mike-burns> Oh, and in text.
18:50:46 <hash_> Hi - I was wondering how closely Try Haskell mirrors ghci/ghc. Am I going to hurt myself trying to learn it in the browser? I'm stuck on an airplane with nothing but a Chromebook so I don
18:50:49 <hash_> Don't have terminal access
18:51:46 <acowley> You can use gloss web, too!
18:51:53 <Sgeo|web> hash_: Well, you really want file compilationm
18:52:10 <Sgeo|web> Because even GHCi isn't sufficient to learn Haskell, you want GHC
18:52:12 <mike-burns> The error messages are the important part, I feel.
18:52:49 <acowley> hash_: http://dac4.designacourse.com:8000/
18:54:15 <RarrRaptor> hash_: There's codepad.org for some of your GHC-like needs.
18:54:28 <hash_> @acowley Nice! couldn't google gloss web though
18:54:28 <lambdabot> Unknown command, try @list
18:54:39 <mike-burns> This ain't Twitter.
18:54:45 <elliott> RarrRaptor: codepad.org uses Hugs!!
18:54:47 <hash_> acowley Nice! couldn't google gloss web though
18:54:57 <elliott> I use two exclamation marks because it is impossible to believe.
18:55:05 <RarrRaptor> elliott: Hugs are nice!
18:55:12 <elliott> Good point!
18:55:18 <elliott> I am defeated.
18:55:32 <RarrRaptor> That's the power of love!
18:55:36 <hash_> Not to belittle hugging, I do know that I need ghc...
18:55:41 <acowley> @faq Can Haskell exploit the power of love?
18:55:41 <lambdabot> The answer is: Yes! Haskell can do that.
18:55:58 <acowley> Huey Lewis would be proud.
18:56:07 <Mitsu> @fag Can haskell do anything?
18:56:07 <lambdabot> The answer is: Yes! Haskell can do that.
18:56:14 <Mitsu> well
18:56:18 <Mitsu> I meant to type @faq
18:56:25 <Mitsu> but I guess fag works as well
18:56:25 <Mitsu> olol
18:56:54 <acowley> lambdabot is very easy going
18:57:16 <elliott> @fqa Can Haskell be C++?
18:57:17 <lambdabot> Maybe you meant: faq ft
18:57:19 <elliott> Darn.
18:57:19 <PiRSquared17> @fag Can haskell turn into an airplane?
18:57:19 <lambdabot> The answer is: Yes! Haskell can do that.
18:57:38 <PiRSquared17> @fag Can haskell go fatser than the speed of light?
18:57:38 <lambdabot> The answer is: Yes! Haskell can do that.
18:58:20 <PiRSquared17> @faq Can Haskell be C++?
18:58:21 <lambdabot> The answer is: Yes! Haskell can do that.
18:58:40 <mike-burns> As a tip: anything you ask it, it will respond with the same answer.
18:59:00 <PiRSquared17> @faq Haskell
18:59:00 <lambdabot> The answer is: Yes! Haskell can do that.
18:59:05 <PiRSquared17> Oh, ok
18:59:13 <Mitsu> wait PiRSquared17 you didn't know that? lolz
18:59:15 <PiRSquared17> Then, why is there a @faq ?
18:59:19 <hash_> @faq Can haskell determine if arbitrary functions halt?
18:59:20 <lambdabot> The answer is: Yes! Haskell can do that.
18:59:25 <PiRSquared17> lol
19:00:01 <hash_> It's not technically wrong... I didn't say all arbitrary functions. Tricksy Haskell.
19:00:20 <acowley> PiRSquared17 was just going for a proof by exhaustion that @faq is a constant function.
19:00:48 <clsmith> lol
19:01:06 <hash_> Nice.
19:01:53 <RarrRaptor> @faq Does Haskell make it easy to write constant functions for IRC bots?
19:01:53 <lambdabot> The answer is: Yes! Haskell can do that.
19:02:42 <PiRSquared17> > (const "The answer is: Yes! Haskell can do that.") " Does Haskell make it easy to write constant functions for IRC bots?"
19:02:42 <lambdabot>   "The answer is: Yes! Haskell can do that."
19:03:10 <RarrRaptor> > text "zomg no quotes!"
19:03:11 <lambdabot>   zomg no quotes!
19:03:24 <hash_> You're going to cause it to catch on fire.
19:03:38 <RarrRaptor> Is that bad?
19:03:45 <mjrosenb> :t text
19:03:45 <lambdabot> String -> Doc
19:04:00 <mjrosenb> what is Doc?
19:04:11 <PiRSquared17> @hoogle Doc
19:04:12 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
19:04:12 <lambdabot> Text.PrettyPrint data Doc
19:04:12 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
19:04:18 <PiRSquared17> ?
19:04:44 <RarrRaptor> @hoogle text
19:04:45 <lambdabot> System.IO data TextEncoding
19:04:45 <lambdabot> GHC.IO.Encoding.Types data TextEncoding
19:04:45 <lambdabot> GHC.IO.Encoding data TextEncoding
19:05:51 <acowley> Writing a one page paper in ACM proceedings format leaves room for about 20 words of content.
19:06:09 <RarrRaptor> http://hackage.haskell.org/packages/archive/pretty/latest/doc/html/Text-PrettyPrint-HughesPJ.html#v:text
19:16:09 <hash_> Is there a more fully featured Haskell repl on the web?
19:17:22 <PiRSquared17> http://tryhaskell.org
19:17:39 <mike-burns> The "more" in his sentence was in comparison with that.
19:17:40 <hash_> Sorry, I meant more fully featured than tryhaskell
19:18:26 <elliott> hash_: /usr/bin/ghci
19:18:33 <mike-burns> He's on a Chromebook.
19:19:11 <hash_> Somewhere over Wyoming, about to be over Nebraska :)
19:19:24 <tensorpudding> haskelling while flying?
19:19:33 <hash_> Learning Haskell while flying.
19:19:45 <mike-burns> Oh, you have IRC? There's lambdabot.
19:19:56 <tensorpudding> lambdabot can't do IO
19:20:19 <hash_> I also don't want to spam you guys with my crazy attempts to do basic Haskell.
19:20:28 <mike-burns> You can PM with the 'bot.
19:20:33 <RarrRaptor> hash_: /query lambdabot
19:20:47 <Mitsu> yet you forget
19:20:48 <Mitsu> <tensorpudding> lambdabot can't do IO
19:21:12 <mike-burns> Can tryhaskell do IO?
19:21:22 <hash_> IO is over-rated anyway.
19:21:54 <hash_> So I did the /query thing on Senior Lambdabot... How do I issue him Haskell?
19:22:02 <RarrRaptor> > 5 + 11
19:22:03 <lambdabot>   16
19:22:32 <blackdog> anyone got any recommendations for handling PNG files in haskell?
19:22:35 <Mitsu> > [x * 2 | x <- [1..10]]
19:22:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:22:37 <hash_> I did something wrong, I don't get any results.
19:22:43 <hash_> Oh...
19:22:51 <blackdog> tried pngload, but it's doing some things i don't quite understand
19:23:03 <hash_> I was missing the angled bracket, got it. Thanks.
19:23:59 <tensorpudding> pngload looks a bit ugly
19:24:10 <mike-burns> Yes, but what is better?
19:25:20 <tensorpudding> blackdog, what are the things it does you don't understand?
19:26:55 <acowley> blackdog: you can try stb-image
19:27:37 <acowley> Although I've had issues building one of its dependencies lately, so I have a locally patched version.
19:29:48 <jamiely> if I have a m :: (Either Int Int), how do I do this simply? show $ case m of Left v -> v Right v -> v
19:30:10 <mike-burns> either show show m
19:31:00 <mike-burns> > either show show (Either 1 2)
19:31:01 <lambdabot>   Not in scope: data constructor `Either'
19:31:05 <copumpkin> show . join either id
19:31:07 <copumpkin> just to be obscure
19:31:09 <mike-burns> heh. Whoops.
19:31:17 <monochrom> > either show show (Left 1)
19:31:18 <lambdabot>   "1"
19:31:18 <jamiely> thx
19:31:24 <monochrom> > either show show (Right 2)
19:31:25 <lambdabot>   "2"
19:31:36 <mike-burns> In my defense, it's late at night and it's been a long week.
19:32:17 <acowley> that is obscure
19:32:18 <acowley> I like it
19:33:46 <mauke> :t join either show
19:33:47 <lambdabot> forall a. (Show a) => Either a a -> String
19:33:58 <mauke> :t either show show
19:33:59 <lambdabot> forall a b. (Show a, Show b) => Either a b -> String
19:40:51 <smoge> Hi, I'm new to Haskell and I'm trying to figure out the best way to work with Tree Data Structures
19:41:12 <smoge> I'm trying to represent music rhythms in haskell
19:41:13 <smoge> http://www.algorithmiccomposer.com/2010/05/openmusic-rhythm-trees-tutorial-part-2.html
19:41:17 <mike-burns> Pattern matching.
19:41:20 <smoge> As trees
19:41:36 <smoge> Any ideas how to get started?
19:42:12 <tensorpudding> what does that site have to do with haskell
19:42:26 <smoge> nothing, it is implemented in lisp
19:42:29 <mike-burns> It's the algorithm he's implementing, or something?
19:42:34 <smoge> but it's the same idea
19:42:44 <tensorpudding> there's still a package with rose trees right?
19:42:50 <wavewave> smoge: do you know Paul Hudak's book ?
19:42:52 <smoge> yes, this representation of music rhythms
19:42:57 <wavewave> smoge : about music
19:43:03 <tensorpudding> rose tree? i don't remember if that's the name
19:43:07 <tensorpudding> Data.Tree, probably
19:43:16 <copumpkin> there are many sorts of trees
19:43:18 <smoge> I will search for his book, thanks
19:43:18 <tensorpudding> trees with arbitrary numbers of subbranches
19:43:27 <smoge> Rose trees? hum..
19:43:36 <tensorpudding> http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/Data-Tree.html
19:43:45 <wavewave> Haskell School of Music
19:43:47 <mike-burns> Oh yeah, I was trying to think of the name of those the other day, and just called them rose trees. Is that the official name?
19:44:23 <wavewave> http://haskell.cs.yale.edu/?page_id=276
19:44:35 <wavewave> you can download pdf file there.
19:44:46 <smoge> wavewave: thanks
19:44:56 <simon> there was someone who made a combinator library for generating music in haskell a while ago. whatever happened to that project?
19:45:13 <wavewave> probably, it will be out of online after he publish it.
19:45:14 <smoge> I'd like to take a look into that too
19:45:27 <tensorpudding> but in all honesty, this structure is very specialized
19:45:29 <wavewave> simon: yeah... I remember it....
19:45:32 <smoge> I'm interested in manipulating rhythmic structures
19:45:39 <tensorpudding> i don't think i'd use that kind of tree
19:45:57 <smoge> hum..
19:46:20 <wavewave> http://www.youtube.com/watch?v=xaoLbKWMwoU
19:46:38 <tensorpudding> i mean
19:46:41 <smoge> wavewave: is that your work?
19:46:47 <tensorpudding> he uses the tree to represent not just notes, but time signatures
19:46:51 <wavewave> of course not. ;-P
19:47:11 <wavewave> I am searching for the person yaxu..
19:47:22 <mike-burns> smoge: You could start by defining your own tree data structure.
19:47:25 <mike-burns> Also, pattern matching.
19:47:40 <tensorpudding> it's virtually impossible to read his nested lists to figure out the structure of music
19:47:44 <wavewave> http://yaxu.org/haskell-hack
19:47:47 <tensorpudding> and it's not just lisp's fault
19:48:21 <smoge> this is the only good representation of comple rhythms I know
19:48:39 <smoge> I see in hudak book that he also uses it
19:49:05 <smoge> but in a different way, not as time proportions as in openmusic, that is more flexible
19:49:17 <simon> wavewave, the youtube film you link to was not the one I remember.
19:49:42 <tensorpudding> i suppose one way you could order it, is in terms of a series of measures
19:49:57 <tensorpudding> and each measure has a time signature and a series of notes
19:49:57 <wavewave> simon: probably the video with graphical programming?
19:50:01 <tensorpudding> or rests
19:50:27 <tensorpudding> you don't even have to use numbers
19:50:33 <smoge> And what about this one: http://en.wikibooks.org/wiki/Haskell/Zippers
19:50:42 <smoge> is it a good start?
19:50:50 <wavewave> http://www.youtube.com/watch?v=IY-NaFqRvil
19:50:55 <tensorpudding> well, you would to create irregular proportions in your beats
19:51:01 <wavewave> the same person in fact.
19:51:06 <tensorpudding> zippers are complicated
19:51:26 <tensorpudding> learn about plain-old-trees first
19:51:38 <smoge> ok
19:52:05 <tensorpudding> a zipper is a way of representing a tree such that you get asymptotically fast operations near a particular point
19:52:38 <tensorpudding> instead of the usual, which is being fast only near the root node
19:52:55 <mike-burns> I think the fastest way to get this project up and interesting is to hack out some quick, boring data structures. Refactor later.
19:52:58 <wavewave> okay.. found that library : called tidal
19:54:02 <wavewave> http://yaxu.org/tidal
19:54:03 <tensorpudding> implementing usual tree stuff using tree zippers is hard
19:54:27 <smoge> thanks, I will do my homework with plain old trees =)
19:55:15 <tensorpudding> is this programming homework or music homework or what
19:55:30 <smoge> "homework"
19:56:04 <wavewave> this video is fun.
19:57:09 <smoge> is there a mailing list for music stuff?
19:57:21 <smoge> I see several systems here related to this
19:59:17 <simon> wavewave, thanks.
20:00:15 <smoge> have anyone worked with musicxml or hly (lilypond)
20:00:24 <smoge> I'm wondering which one is more mature to work
20:02:46 <dylex> smoge: there's one list that's mainly been about midi sorts of music stuff, http://lists.lurk.org/mailman/listinfo/haskell-art
20:06:48 <augur> sooo...
20:06:57 <augur> who's written abstracts for paper submissions?
20:10:22 <dylex> augur: is there something specific coming up or just in general?
20:10:41 <augur> im just looking for advice on abstract writing
20:12:04 <dylex> summarize clearly and directly, but try to make it sound at least a little interesting.
20:12:48 <dylex> don't worry too much about giving background info or motivation, though.  but i presume you have something more specific in mind?
20:13:03 <liyang> Your contributions and how they differ from existing work.
20:13:10 <liyang> Succinctly.
20:13:20 <liyang> But not too abstract.
20:13:35 <blackdog> tensorpudding: i'm running getAssocs on the storablearray i get back, and the length of the list i get back is not width*height
20:15:37 <blackdog> acowley: doesn't build on 7.2 - bitmap-0.0.1 is broken
20:15:46 <tensorpudding> weird
20:16:30 * hackagebot monoidplus 0.1 - Extra classes/functions about monoids  http://hackage.haskell.org/package/monoidplus-0.1 (AaronBlack)
20:36:31 * hackagebot monoidplus 0.1.0.1 - Extra classes/functions about monoids  http://hackage.haskell.org/package/monoidplus-0.1.0.1 (AaronBlack)
20:37:17 <zzing> Has anyone done anything with cairo targetting opengl in haskell?
20:37:17 <lambdabot> zzing: You have 1 new message. '/msg lambdabot @messages' to read it.
20:37:36 <mm_freak> zzing: opengl yes, cairo no
20:38:09 <kfish> zzing, cairo yes, opengl no
20:38:52 <zzing> I am considering the use of cairo and opengl for a game, and considering ghc for it
20:41:07 <mm_freak> zzing: do you specifically want cairo?
20:41:40 <zzing> mm_freak: I want a vector library, ultimately this is going to use geometry. SVG wouldn't hurt either.
20:41:44 <zzing> 2d only
20:42:11 <mm_freak> well, opengl is vector-based
20:42:21 <mm_freak> though drawing text can be a challenge
20:42:27 <zzing> I don't want to have to deal directly with opengl
20:42:43 <zzo38> I sent a package but it won't display the list of what things it exports in the webpage.
20:42:55 <Jafet> SVG ostensibly has animation, but no one implements it
20:43:10 <mm_freak> zzo38: don't worry…  the documentation is rebuilt every 6 hours or so
20:43:12 <mm_freak> just be patient
20:43:27 <mm_freak> it should display the exported modules, but doesn't link them
20:43:51 <zzo38> mm_freak: O, OK. Thanks.
20:45:00 <zzing> If people make 2d games, what would they typically use?
20:45:38 <mm_freak> opengl =)
20:45:45 <mm_freak> with glut/glfw/sdl
20:46:08 <zzing> Are there any 2d libraries that operate ontop of opengl?
20:46:23 <mjrosenb> zzing: what do you want from a 2d library?
20:46:25 <parcs> haskell libraries?
20:46:30 <mjrosenb> zzing: widgets + stuff?
20:46:47 <zzing> I want to be able to say draw a line here, a circle there, and an image there
20:47:01 <mm_freak> well, there is gloss, but that one is quite limited…  it forces your entire application into a pure framework
20:47:25 <parcs> i think pure sdl can do that 'easily'
20:47:34 <parcs> but it's not hardware-accelerated
20:47:43 <parcs> that shouldn't matter though
20:48:12 <mm_freak> parcs: zzing doesn't want to deal with opengl, and software rendering with SDL is either slow (SDL-gfx) or very low-level (directly via a Ptr to the pixel buffer)
20:49:02 <dylex> even with opengl alone that's still pretty easy.  a few short functions to load textures and draw shapes.
20:49:22 <zzing> dylex: I would want to avoid use of evil immediate mode
20:49:37 <mm_freak> zzing: what's evil about that?
20:49:46 * Jafet feels evil.
20:49:54 <zzing> mm_freak: new code should be using buffers
20:50:17 <mm_freak> you can write your wrapper library on top of opengl
20:50:59 <dylex> buffers like double-buffering? or is this more about pipelining?
20:51:00 <parcs> mm_freak: relatively slow :)
20:51:12 <parcs> i doubt speed matters in zzing's case
20:51:23 <zzing> correct
20:51:39 <dylex> double-buffering is trivial in opengl.
20:51:45 <zzing> We have opengl 2.1 support?
20:52:03 <mjrosenb> parcs: sdl tries to be hardware accelerated
20:52:17 <mjrosenb> parcs: that being said, I don't think sdl has primitives for circles?
20:52:26 <mjrosenb> at least I've never used them :(
20:52:26 <dylex> zzing: OpenGL claims to be up to 3.2
20:52:28 <mm_freak> SDL is no primitives whatsoever
20:52:45 <mm_freak> it has only primitives for pushing boxes around (blitting)
20:53:26 <mm_freak> and those are HW-accelerated when possible…  if you draw something that is not a box with some precalculated content, then SDL is going to be slow, at least at high resolutions
20:53:52 <Jafet> Blitting is great if your game still uses sprites
20:54:04 <Jafet> Like super mario bros.
20:54:33 <zzing> SDL-gfx has primitives
20:54:36 <parcs> or dungeon crawl stone soup (which uses sdl)
20:55:03 <mjrosenb> Jafet: but sdl doesn't have the nice blit masks that bitblt had :(
20:55:05 <mm_freak> SDL-gfx has some basic primitives, yes…  if your game isn't highly interactive with a lot of animations, it might suffice
20:57:40 <hpaste> letrec pasted “Improve_it” at http://hpaste.org/53914
20:58:06 <zzing> What is a good example of a game using opengl?
20:58:11 <zzing> a simple game
20:58:35 <Jafet> glxgears
20:58:42 <Jafet> It's inherently multiplayer though
20:59:12 <letrec> Hey! I'm a beginner, any comment on my code? How can I improve the style? Thx (http://hpaste.org/53914).
20:59:33 <dylex> Jafet: where multi means n != 1?  I presume zzing wants something haskell, though.
20:59:40 <Jafet> THX? I thought we were still stereo.
21:00:44 <incluye> :t readFile
21:00:45 <lambdabot> FilePath -> IO String
21:03:00 <mm_freak> there was this game, where you navigate a 2x1 block around…  bloxors or something
21:03:00 <letrec> :t liftM
21:03:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:03:12 <mm_freak> but i think that's not really the kind of example zzing is looking for
21:03:14 <mjrosenb> letrec: that is quite the function...
21:03:55 <dylex> zzing: there's a number of opengl games in the game section on hackage...
21:04:19 <zzing> raincat?
21:04:19 <ash_> has anyone ever tried to build a 'bare metal' ghc? (specifically for arm) just curious
21:04:53 <letrec> mjrosenb: I was hoping there was a way to avoid the do/if/do/case nesting. But ok, thx for looking at it.
21:06:01 <mm_freak> letrec: you may want to split that into multiple definitions or use a monad that captures the kind of control flow you use
21:06:13 <mm_freak> though i don't really see a monad for your case
21:06:18 <mm_freak> ContT at best
21:06:50 <letrec> :t ContT
21:06:50 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
21:06:54 <mm_freak> you basically have:  "if this, then do this short code, otherwise proceed to the rest"
21:07:05 <mm_freak> ContT captures that
21:07:39 <mm_freak> "if short-code-condition, ignore the continuation and use the following escape code"
21:08:40 <mjrosenb> letrec: i'd say something like x <- (if eof then (foo >> Nothing) else bar); y <- fmap (foo) x
21:09:10 <mjrosenb> letrec: and using fmap to do nothing if the previous case resulted in Nothing
21:09:11 <Jafet> grep fn s = do ls <- lines <$> readFile fn; sequence_ [ putStr $ printf "Line %3d matches for %s\n" i fn | (i, l) <- zip [1..] ls, Just _ <- findSubstring s l ]
21:10:05 <mm_freak> letrec: also using withFile instead of openFile/hClose may yield better code in both readability and style
21:11:11 <mm_freak> letrec: finally turning your 'search' function into an iteratee will get rid of most of the boilerplate you have there
21:11:27 <mm_freak> search = do line <- nextLine; …
21:12:06 <mm_freak> apply a line-numbering enumeratee for the line numbers
21:12:27 <Jafet> That sounds like a lot of boilerplate, heh
21:12:29 <mm_freak> search = do mLine <- head; case mLine of Nothing -> return(); (lineNum, lineStr) -> …
21:13:29 <mm_freak> it's really not…  the line-numbering enumeratee is really just a zip-operation for iteratees
21:14:12 <incluye> @pl \p f -> filter (isInfixOf p) . lines <$> readFile f
21:14:12 <lambdabot> (. readFile) . (<$>) . (. lines) . filter . isInfixOf
21:14:29 <letrec> mm_freak: How does mLine <- head works?
21:14:44 <letrec> But ok, I'll have a look at that, thanks
21:15:11 <mm_freak> letrec: 'head' corresponds to the 'head' function for lists…  it's an iteratee
21:15:33 <mm_freak> you would first apply a line-splitting enumeratee, then a numbering enumeratee
21:15:50 <mm_freak> then 'head' just gives you Just the next tuple of line number and line string or Nothing on EOF
21:15:57 <mm_freak> (at least in the 'enumerator' library)
21:16:36 <letrec> mm_freak: Ok, let me google enumeratee now :)
21:16:47 <Jafet> Well, grep shouldn't be of type FilePath -> ByteString -> IO () in the first place
21:16:58 <Jafet> At least, it's very questionable for the result type to be IO ()
21:17:16 <zzing> raincat is awesome and might be what I need
21:17:16 <Jafet> What's C, by the way?
21:17:41 <Jafet> If it is Char8, I will physically assault you over the internet.
21:17:42 <PiRSquared17> @faq C
21:17:43 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:36 <incluye> Why use ByteString over String
21:19:58 <Jafet> Why do you think you can use String instead of ByteString?
21:20:06 <Jafet> They're very different things
21:20:22 <letrec> Why couldn't C be Char8 ?
21:20:49 <RarrRaptor> type C = Char8
21:21:04 <Jafet> Because Char8 should never, ever appear in a program.
21:22:20 <Jafet> Instead, encode your Chars with something like Text.Encoding.
21:22:23 <letrec> I'm actually using my own package for some conversion reason. But I would have happily use Char8 :) Why shouldn't people use it?
21:22:44 <Jafet> Because it is nearly always incorrectly used.
21:22:46 <ben> Because you can't squeeze most unicode characters into a Char8
21:23:22 <Jafet> @where unicode
21:23:22 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
21:27:06 <hpaste> “Ertugrul Söylemez” annotated “Improve_it” with “Improve_it (annotation)” at http://hpaste.org/53914#a53915
21:27:24 <mm_freak> @ letrec
21:27:29 <mm_freak> dirty and simple =)
21:27:44 <mm_freak> and using the more appropriate Text instead of ByteString
21:29:05 <letrec> mm_freak: Much appreciated, thx!
21:29:35 <Jafet> You might want to make str lazy, instead of txt strict
21:30:10 <mm_freak> no reason…  isInfixOf doesn't fuse anyway
21:31:03 <Jafet> For the files with very long lines
21:32:19 <lpsmith> Does anybody know offhand if a cabal dependency that is needed to build a package (due to template haskell) but not use a package will be loaded when that package is used?
21:32:45 * lpsmith wonders if I shouldn't statically generate the code and include that.
21:35:37 <letrec> :t uncurry
21:35:38 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
21:36:24 <augur> dylex, liyang: mind giving me your opinion on the abstract?
21:38:08 <dylex> augur: sure, though i probably don't know the field
21:38:12 <augur> dylex: http://wellnowwhat.net/linguistics/GLOW%20Abstract.pdf
21:40:14 <letrec> :t (\a b -> printf "%s %d" a b)
21:40:15 <lambdabot> forall t t1 t2. (PrintfType (t -> t1 -> t2)) => t -> t1 -> t2
21:40:27 <letrec> :t (uncurry $ printf "%s %d")
21:40:28 <lambdabot> forall a b c. (PrintfArg a, PrintfArg b, PrintfType c) => (a, b) -> c
21:40:59 <dylex> augur: does the journal have any requirements for length?
21:41:05 <augur> two pages max
21:41:44 <mauke> *> :t $(printf "%s %d")
21:41:44 <mauke> (Text.Printf.Mauke.TH.ToString a, Integral a1) => a -> a1 -> String
21:42:44 <elliott> IIntegral?
21:42:54 <elliott> oh... rendering error in my irc client o_O
21:43:23 <vav> what's the difference in _t vs. t in e.g. `foo _t Bar = f; foo t Baz = g; foo _ _ = h' ?
21:43:40 <dylex> augur: huh, definitely longer than what I'm used to, which tends to be a single paragraph.  but at two pages I expect they want references?
21:43:47 <mauke> vav: none
21:43:52 <PiRSquared17> Bye!
21:43:54 <augur> dylex: well, its not for a journal, its for a conference
21:44:00 <augur> but yes, there will be refs
21:44:08 <elliott> vav: none (although I seem to recall reading something about _ prefix disabling some ghc warning?)
21:44:09 <augur> im concerned right now with the content :p
21:44:13 <elliott> maybe it stops it warning about an unused variable
21:44:34 <vav> elliott: ah, ok thanks. Will experiment with that. Thanks
21:44:49 <dylex> augur: ah, okay, that makes sense.  i'd add a concluding paragraph, mirroring discussion, and maybe expand the first paragraph a bit.
21:44:50 <elliott> vav: (you'll need -Wall to see)
21:45:20 <augur> dylex: what do you think i could add to the first paragraph, and how could i conclude without being repetitive? :(
21:48:38 <mm_freak> lpsmith: GHC seems to link libraries as soon as you import a module from them
21:48:55 <mm_freak> at least 7.0.3
22:21:40 <zzing> What is the best way to resolve an ambiguous module: Ambiguous module name `Prelude':
22:21:47 <zzing> it was found in multiple packages: base haskell98-2.0.0.0
22:22:00 <byorgey> zzing: it depends. what are you trying to build?
22:22:08 <zzing> FunGEn
22:23:38 <zzing> removing hasekll98 was the answer
22:23:56 <byorgey> yes, I was just going to suggest that, glad it worked =)
22:26:13 <zzing> It looks like fungen might be useful
22:43:13 <mithos28> Does ghc support a mode to recompile all my code if I want to change compile flags? Currently I have to rm **/*.{hi,o} and was wondering if there was an easier way
22:44:14 <blackdog> -fforce-recomp
22:44:59 <mithos28> blackdog: thanks
22:46:24 <Jafet> Is obsolescence planned for -fforce-recomp?
22:48:09 <mithos28> Jafet: what is wrong with it?
22:48:45 <Jafet> What you said
22:49:22 <Jafet> The compile flags really should be included in the signature
22:50:18 <mithos28> oh ok. Nothing is wrong with it, but it shouldn't be needed
22:50:39 <hpaste> mbuf pasted “Last statement must be do” at http://hpaste.org/53916
22:51:22 <Jafet> mbuf: indent the lines so that they're after "do"
22:51:38 <Jafet> And line up with "t"
22:51:44 <mbuf> Jafet: I see
22:51:59 <Jafet> Or move the first statement to a new line, and line it up with "if"
22:53:17 <letrec> :t zip
22:53:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
22:55:26 <hpaste> mbuf pasted “Last statement must be do” at http://hpaste.org/53917
22:55:38 <mbuf> Jafet: still no luck
22:57:38 <mbuf> Jafet: got it now!
22:57:41 <mbuf> Jafet: thanks
22:59:28 <Jafet> Don't program using luck!
23:00:17 <letrec> :t second
23:00:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
23:02:15 <letrec> Could someone explain what is 'second'? Is it a function?
23:02:28 <Jafet> @src second
23:02:28 <lambdabot> Source not found. You speak an infinite deal of nothing
23:02:32 <Jafet> @src (->) second
23:02:32 <lambdabot> second f = id *** f
23:02:47 <Jafet> @src (->) (***)
23:02:47 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
23:03:20 <Jafet> second f ~(x,y) = (x,f y)
23:03:41 * Jafet wonders why a lazy pattern
23:03:51 <letrec> What does the ~ means?
23:04:11 <monochrom> it means more non-strict
23:04:15 <Jafet> In this context? I think it means nothing
23:07:32 <elliott> Jafet: So that second f undefined =/= _|_.
23:07:43 <elliott> second f _|_ = (_|_, f _|_)
23:07:51 <elliott> Presumably it needs that to follow a law.
23:09:20 <huangyi> I just straced a simple warp server, found it use select, I'm using ghc7.2.1, shouldn't it use epoll?
23:10:31 <Jafet> Oh, right
23:11:13 <Jafet> Doesn't ghc use whatever is supposed to be used on the system?
23:11:34 <elliott> huangyi: You're on Linux, right? :-)
23:11:38 <huangyi> I'm using linux 2.6.38
23:11:46 <elliott> huangyi: Maybe GHC is using select for something else, and epoll is what's being used in the main loop?
23:12:20 <huangyi> I've watched the whole request sycle, don't see any epoll call.
23:13:16 <sanjoyd> ?djinn [a]->a
23:13:16 <lambdabot> Error: Undefined type []
23:13:23 <sanjoyd> ?djinn (a->a)->a
23:13:23 <lambdabot> -- f cannot be realized.
23:13:29 <hpaste> huangyi pasted “strace result of a warp server serving a static file” at http://hpaste.org/53918
23:14:26 <hpaste> huangyi annotated “strace result of a warp server serving a static file” with “strace result of a warp server serving a static file (annotation)” at http://hpaste.org/53918#a53919
23:15:37 <mbuf> if I have a HTTP url in the text, I want to put that text within <a href=""></a> tags; how can I do that in Haskell? I use the following in Python, for example, line1 = re.sub(r'(https?:[^\s\n\r]+)', r'<a href="\1">\1</a>', line1)
23:15:37 <mbuf>  
23:17:04 <Jafet> Ignoring your first sentence: import Text.Regex
23:17:25 <elliott> mbuf: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
23:17:36 <elliott> Oh, wait, you're generating it, not parsing it.
23:17:51 <elliott> ...not that that means you should do it with regexps, but :)
23:17:59 <Jafet> Well, he's matching HTTP URLs.
23:18:33 <elliott> those are significantly less nested than html :P
23:18:41 <mbuf> Jafet: yes, I am matching HTTP URLs
23:19:06 <drbean> haskeline truncated ghc_history to 100 lines, even though I have maxHistorySize of Just 50000 in ~/.haskeline
23:24:35 <letrec> :t return
23:24:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:26:53 <Jafet> You need to say Really 50000
23:30:26 <letrec> With ghc, how to print the signature of all functions while compiling?
23:35:28 <letrec> :t liftM
23:35:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
23:48:44 <huangyi> It seems ghc only use epoll when compiled with -threaded.
23:49:38 <c_wraith> huangyi: yes, the new IO manager is only in the threaded runtime
