00:00:20 <gentleben> process creation/destruction has a price too
00:00:33 <Eduard_Munteanu> I guess it might be a tradeoff between allocation and collection/compaction cost.
00:01:06 <Eduard_Munteanu> (and best locality/fragmentation over time)
00:02:15 <gentleben> its actually a very difficult problem for any reasonably complex app
00:02:31 <gentleben> will be an area of active research in the future
00:04:08 <Eduard_Munteanu> I wouldn't forget region inference either, that sounds like fun.
00:11:25 <Eduard_Munteanu> theos: o hai again
00:11:33 <theos> :D hai
00:48:54 * hackagebot global-lock 0.1 - A global lock implemented without unsafePerformIO  http://hackage.haskell.org/package/global-lock-0.1 (KeeganMcAllister)
01:09:53 <hnsz> ping
01:16:54 <theos> pong
01:30:49 <frerich> Does anybody know whether there's maybe a more idiomatic way to write 'apSnd f (a,b) = (a, f b)'?
01:31:09 <rostayob> :t second
01:31:10 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:31:27 <rostayob> > second (+1) (1,2)
01:31:28 <lambdabot>   (1,3)
01:31:39 <frerich> Oh! I didn't know that, thanks :-)
01:31:45 <shachaf> > fmap f (a,b) :: (Expr,Expr)
01:31:46 <lambdabot>   (a,f b)
01:31:59 <rostayob> function are arrows, remember eheh
01:32:37 <frerich> I didn't quite grok what arrows are, yet - sorry. :-) I only know that they are some generalization of functions
01:33:25 <rostayob> well you can still look at the types to find out what to do with them http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html
01:33:25 <frerich> Anyway, thanks for pointing 'second' out!
01:34:08 <rostayob> yw
01:35:40 <Blkt> good morning everyoen
01:36:14 <Blkt> everyone*
01:38:31 <Kelet> Morning? Still coding.. if I sleep now I can get a solid 1.5 hours before work!!
01:43:25 <rostayob> is it possible to say something like "trust me, this is going to be an instance of this typeclass" to GHC?
01:44:15 <Blkt> lol Kelet
01:47:23 <Saizan> rostayob: it's not just a matter of trust, you've to give it the code for the methods or it won't know what to do at runtime
01:48:10 <rostayob> no but the problem here is that I want an heterogeneous type class
01:48:15 <rostayob> sorry, heterogenous map
01:48:55 * hackagebot websockets 0.4.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.4.0.0 (JasperVanDerJeugt)
01:49:06 <rostayob> and I have a typeclass like 'Foo a b'. I want every pair of items to be Foo a b and Foo b a
01:49:24 <rostayob> and I make sure that this happens with my insertion methods
01:49:33 <rostayob> but I can't capture this notion at the type level, rigth?
01:49:57 <Saizan> you can
01:50:30 <rostayob> oh. How?
01:50:45 <rostayob> (in haskell of course)
01:51:55 <Saizan> the most convinent way would be with ContraintKinds since you can just make an All (p :: * -> Constraint) (hlist :: *) :: Constraint family
01:52:09 <Saizan> but you can do something similar with gadts and typeclasses
01:53:00 <rostayob> Saizan: ok, I'll look into ConstraintKinds... but I don't understand how to do it with type classes. A list wouldn't be good, I want to have a proper map
01:53:21 <Saizan> https://plus.google.com/u/0/106318233255980016498/posts/39J5UwBjvBg
01:53:34 <Saizan> well a map is a list of pairs
01:53:43 <Saizan> conceptually at least :)
01:54:01 <Saizan> https://plus.google.com/u/0/106318233255980016498/posts/hyUwjUyCpGx
01:54:06 <leod> it's a pair of lists!
01:55:05 <Saizan> ConstraintKinds mostly help with abstracting over the particular Foo
01:55:09 <rostayob> Saizan: yeah but that would be pretty slow for what I need to do. With polymorphic kinds doing that is even easier I guess
01:55:40 <rostayob> actually couldn't you have a proper map as well with polymorphic kinds? with the type being a tree of types as well?
01:56:37 <Saizan> you have some room on how to store values even if you keep it an association list at the type level
01:58:29 <rostayob> true
02:01:57 * Sgeo|web ponders using ReaderT and IO for spreadsheet-y stuff
02:02:00 <Saizan> or if you don't have a need to index your map by the key/value types you can put the Foo a b, Foo b a context in the constructor where you're storing the values anyway
02:02:54 * Sgeo|web is suddenly unsure why he involved ReaderT
02:03:17 <rostayob> Saizan: no I need that
02:03:52 <rostayob> what about having a proper heterogeneous map, so that the return type is known statically but it might be different things
02:04:03 <rostayob> with polymorphic kinds that is possible with a list
02:04:30 <Saizan> how would the code look?
02:04:35 <rostayob> is it doable maybe in an uglier way with an actual map and the current language extensions?
02:05:58 <rostayob> Saizan: can't you have a mapping per type and when you lookup for a certain type you first check if there is the mapping for your type and then lookup?
02:07:10 <rostayob> mhm
02:09:38 <rostayob> Saizan: you know what, I'll just unsafeCoerce!
02:18:01 <erus`> are there any cool recent haskell/FP papers to read?
02:21:25 * applicative hasn't read all the cool old ones yet
02:23:45 <ksinkar> are there any known issues for installing haskell on ubuntu 11.04?
02:28:43 <luite_> I don't know of any ubuntu specific issues, but the compiler that comes with it is old
02:29:02 <luite_> and there are the usual caveats for installing haskell packages with the OS package manager
02:35:18 <erus`> The only things that dont have kind * are type constructors?
02:35:38 <erus`> or data constructor
02:39:08 <quicksilver> type constructors.
02:39:19 <quicksilver> data constructors are something else.
02:39:43 <erus`> are kinds totally separate from types?
02:40:02 <quicksilver> yes, in the same way that types are separate from value
02:40:13 <quicksilver> types classify values and kinds classify types
02:41:48 <erus`> Could kinds ever be types?
02:42:13 <erus`> or store some generic type instead of a kind?
02:42:37 <quicksilver> not *entirely* sure what you're trying to ask by "could"
02:42:51 <quicksilver> there exist systems where the notions of type and kind are unified, yes
02:43:03 <erus`> ah cool
02:43:05 <quicksilver> but those systems are quite unlike haskell
02:43:45 <quicksilver> sensible approaches to dependent types operate in a world where values, types and kinds are all values
02:44:02 <quicksilver> however those systems are theoretically complex
02:44:27 <kmc> in some implementations of Haskell, the same datatype is used internally for kinds and types
02:44:29 <kmc> but this is a hack
02:44:57 <kmc> erus`, the kind system in GHC Haskell is more complicated than the kind system in Haskell
02:45:24 <kmc> in Haskell, types have kind *, and type constructors have kind of the form (a -> b) for kinds a, b
02:45:26 <kmc> and that's all
02:46:01 <kmc> in GHC Haskell, unboxed types have kind #, and unboxed tuples have kind (#)
02:46:20 <kmc> then you have a little "subkinding":  ?? means "* or #", and ? means "* or # or (#)"
02:46:22 <kmc> hence:
02:46:24 <kmc> @kind (->)
02:46:25 <lambdabot> ?? -> ? -> *
02:46:43 <quicksilver> kmc: (and in GHC 7.4 and beyond there are yet more kinds)
02:46:43 <kmc> that's the kind of the type constructor of function types
02:47:51 <kmc> it says that a function takes an boxed or unboxed value, and returns a boxed or unboxed value or an unboxed tuple
02:47:56 <kmc> and that functions themselves are boxed
02:48:15 <kmc> erus`, don't know if you're familiar with boxed vs. unboxed values; I can explain that if you like
02:48:26 <kmc> and quicksilver is right, there are many more kinds in GHC 7.4
02:48:40 <kmc> like Constraint, the kind of type class constraints (and I guess implicit-parameter constraints and type equality constraints?)
02:48:45 <erus`> what is the difference, kmc?
02:49:27 <kmc> also in GHC 7.4, algebraic data constructors are lifted to also be types, and their types are lifted to be kinds
02:49:55 <kmc> erus`, boxed values could be undefined, they could be unevaluated thunks, and they're always represented uniformly
02:50:44 <kmc> a boxed value is always a pointer to a GHC heap object, which has a certain uniform structure
02:51:00 <kmc> there's a uniform way to evaluate it, and a uniform way to garbage-collect it, etc.
02:51:12 <kmc> it's this uniformity which makes polymorphism possible
02:51:34 <kmc> this is why GHC only needs to compile one function for 'map', despite the infinity of different types it may be used at
02:51:39 <frerich> kmc: This indirection is also what makes working with boxed values less efficient than working with unboxed ones?
02:52:05 <kmc> erus`, unboxed types are a GHC extension, and they don't have this uniform representation
02:52:22 <kmc> for example, 3# is a naked machine integer, of type Int#
02:52:25 * frerich thinks this sounds a lot like boxed values in other programming languages. Say, C#.
02:52:37 <kmc> they fail to be first-class values in a variety of ways
02:52:52 <erus`> ok
02:52:53 <kmc> for example, you can't have [Int#].  you can't even call (id 3#) because id is a polymorphic function
02:53:15 <kmc> and unboxed tuples are even less first-class.  they aren't really values; they're a convention for how functions may return multiple values
02:53:42 <kmc> so they can only appear as the return type of a function, and must immediately be pattern-matched by the caller
02:53:57 <quicksilver> frerich: yes, although it's not as bad as you might imagine because pointer dereference is very fast as long as the memory location is in cache, which should be the common case. Still, it makes a difference in tight arithmetic loops etc.
02:54:30 <kmc> frerich, yeah, it's not just the indirection, but the relative opacity of boxed values
02:54:47 <kmc> since any value might be a thunk, you have to jump into them to ask them to evaluate
02:54:54 <kmc> except GHC has an optimization here
02:55:16 <kmc> since heap objects are aligned to a machine word (4 or 8 bytes), the lower 2 or 3 bits of a pointer are always 0
02:55:54 <kmc> if we *know* that the pointed-to value is already evaluated (i.e. not a thunk), we tag the low bits of the pointer
02:56:36 <kmc> specifically, if it's the nth constructor of its data type, we store n in those low bits
02:56:51 <kmc> provided there are at most 3 respectively 7 constructors total
02:57:13 <kmc> @src Maybe
02:57:13 <lambdabot> data Maybe a = Nothing | Just a
02:57:38 <kmc> (numbering from 1 for a change, because 0 means "might be a thunk")
02:57:59 <kmc> so if you get a pointer to a (Maybe T), and the low bits of that pointer are 2, then you know it's a (Just x), and you can dereference x directly
02:58:39 <frerich> It never occurred to me that you could exploit memory alignment like that. I always only knew it as a performance improvement, bt it's a neat idea to (ab-)use the unused bits like that. :)
02:58:51 <kmc> if the low bits are 0, you have to dereference to get a function pointer, then call that function, and it will eventually push x onto the STG stack or something
03:00:06 <kmc> frerich, yeah, it is like boxed values in other languages.  the uniform representation thing is why you can't have a List<int> in Java
03:00:19 <kmc> though it will transparently convert between int and Integer
03:00:32 <frerich> kmc: Won't that create boxed values automagically? My Java is a bit rusty...
03:00:53 <kmc> Java made the (somewhat ugly) decision of codifying the semantics of unboxed values, which breaks the "everything is an object" idea
03:01:15 <frerich> kmc: Thanks a lot for these explanations, very interesting stuff :-)
03:01:17 <kmc> Haskell and GHC take the (also ugly) decision of making unboxed stuff a compiler extension
03:01:33 <kmc> which means high-performance "Haskell" code is less portable than it might otherwise be
03:01:45 <kmc> but it fails to be portable for many other reasons :)
03:02:02 <Ken`> what does the $ mean?
03:02:05 <kmc> the perpetual hope is that all the implementation-dependent insanity shows up only at the lowest level of core datastructures and algorithms
03:02:06 <kmc> @src ($)
03:02:06 <lambdabot> f $ x = f x
03:02:15 <kmc> Ken`, it's an infix operator, low precedence, means function application
03:02:26 <hpaste> anacrolix pasted “prime sieve” at http://hpaste.org/53540
03:02:26 <Ken`> hmmm.. but why introduce that notation at all?
03:02:28 <kmc> often used to eliminate parentheses, i.e. (f . g . h $ x) = (f (g (h x)))
03:02:35 <hpaste> “type system” pasted “erus`” at http://hpaste.org/53541
03:02:35 <kmc> but also useful in a higher-order context, i.e.
03:02:37 <Ken`> okay, i see
03:02:38 <Ken`> thanks
03:02:38 <kmc> > map ($ 3) [pred, succ]
03:02:39 <lambdabot>   [2,4]
03:02:40 <anacrolix> can someone comment on my prime sieve program?
03:02:45 <anacrolix> http://hpaste.org/53540
03:02:49 <erus`> couldnt i fake a haskell style type system like that?
03:02:54 <anacrolix> i'm trying to make it more idiomatic
03:03:42 <anacrolix> it's my first haskell program i want some criticism
03:03:46 <frerich> anacrolix: I'm just a beginner myself, but I'd start by adding type signatures for toplevel functions.
03:04:29 <kmc> (by contrast C++ doesn't assume uniform representations for polymorphism; a compiler is expected to generate new code for each instantiation of a template.  which has its own suite of benefits and drawbacks.)
03:06:44 <anacrolix> frerich: thx, but i'm from python land, such things make me cringe
03:07:47 <frerich> anacrolix: I can imagine, but in Haskell land, programs are statically typed - and it's actually common (and good, I think) practice to explicitely write down type signatures (at least for toplevel functions) instead of letting the compiler infer them. Just so that you can be sure that what the compiler infers is indeed what you think :)
03:07:57 <frerich> In my case, being a beginner, it helps readability :)
03:09:30 <frerich> anacrolix: The second thing cmae to my mind is that it seems your whole program is in the IO monad. So I'd try hard to extract stuff into pure functions.
03:09:35 <koala_man> and the compiler error messages point closer to the actual problem
03:12:48 <kmc> yeah
03:13:12 <kmc> the better you explain to the compiler what you meant, the more precisely the compiler can explain why it's wrong :)
03:13:51 <kmc> there's no such thing as "no types" -- in Python you have to think about types too, you just have no precise terms in which to express them or ask for compiler checking
03:14:48 <kmc> and the type signatures act like machine-checkable comments
03:15:09 <kmc> though an ideal Haskell IDE could insert them without you typing them in
03:16:01 <kmc> anacrolix, I assume your goal is explicitly to write a sieve using concurrent communicating processes?
03:16:08 <kmc> it's a cool example of concurrency :)
03:16:19 <kmc> but there are much simpler ways to compute primes
03:17:33 <kmc> anacrolix, overall this looks pretty good for a first Haskell program
03:17:53 <kmc> good indentation style, etc.
03:20:45 <kmc> anacrolix, one improvement is, you'll note that 'filter' only uses readChan with in_, and only uses writeChan with out
03:21:05 <kmc> so you don't need to pass the Chans; you can apply readChan / writeChan and pass that
03:23:58 * hackagebot uuagc-cabal 1.0.0.9 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.9 (ArieMiddelkoop)
03:25:07 <kmc> this makes it easier to reason about your code, because it limits the operations available to each part
03:27:04 <sylecn> how to fix broken packages reported by ghc-pkg check? here is the output of ghc-pkg: http://pastebin.com/W8jrR25F
03:27:05 <mauke> The paste W8jrR25F has been copied to http://hpaste.org/53542
03:31:04 <kmc> anacrolix, also just attempting this problem and getting it to work, as a first Haskell program, is pretty good
03:31:07 <kmc> are you still there?
03:41:01 <gtirloni> sylecn: i've used "cabal install --reinstall"
03:41:15 <opqdonut> is there a function to flip an Ordering?
03:41:34 <opqdonut> I'm quite sure I've seen one somewhere in the libraries
03:42:01 <kmc> > map (EQ `compare`) [LT ..]
03:42:02 <lambdabot>   [GT,EQ,LT]
03:42:42 <opqdonut> nice, but obscure
03:42:45 <kmc> indeed
03:42:58 <kmc> i've not seen the predefined function
03:43:08 <kmc> sometimes you can use (flip compare), which is less obscure
03:43:10 <opqdonut> I'm actually perfectly fine with "reverse.sortyBy f" since the list is small
03:43:19 <opqdonut> hmm
03:43:30 <kmc> sortBy (flip f) ?
03:43:46 <opqdonut> yeah
03:53:17 <sylecn> gtirloni: thanks, will try that next time. I have already done rm -rf .ghc.
03:53:49 <anacrolix> kmc: the tip about passing the read/write chan is fantasitc
03:54:54 <kmc> :)
03:55:02 <anacrolix> is there some way to close a chan?
03:55:30 <kmc> not explicitly
03:55:37 <kmc> if it's unreachable then it will be garbage-collected
03:55:40 <anacrolix> also, is there a better way to "repeat until" other than recursion?
03:55:58 <anacrolix> i guess if i insisted on explicit closing chans, i could wrap them up for that
03:56:07 <kmc> not really, there are some libs like http://hackage.haskell.org/package/monad-loops
03:56:23 <anacrolix> is hte use of Maybe here the right way to indicate the end of input?
03:56:40 <kmc> it's fine
03:56:46 <kmc> i think a custom data type is somewhat more readable
03:57:11 * Sgeo|web hmms
03:57:36 <anacrolix> i tried to set something up like that and couldn't get it to work
03:57:38 * Sgeo|web also has a use for a closable channel >.>
03:58:34 <anacrolix> the monad loops look interesting
03:58:36 <hpaste> kmc annotated “prime sieve” with “prime sieve (annotation)” at http://hpaste.org/53540#a53545
03:58:41 <kmc> anacrolix, this is approximately how i would write it
03:59:19 <anacrolix> kmc: thx, reading now
04:01:37 <anacrolix> kmc: get >>= act
04:01:48 <anacrolix> what the hell?! is this act <- get ?
04:02:05 <anacrolix> ohhh i get it
04:03:09 <kmc> @undo do { x <- get; act x }
04:03:10 <lambdabot> get >>= \ x -> act x
04:03:14 <kmc> @. pl undo do { x <- get; act x }
04:03:14 <lambdabot> act =<< get
04:03:16 <kmc> heh
04:03:38 <anacrolix> kmc: is there some way to do that without having to name "act"
04:04:03 <kmc> well yeah, it's what you had before
04:04:05 <kmc> case inside do
04:04:18 <kmc> i think this is a bit more readable, but tastes vary of course
04:04:25 <anacrolix> nah i had to bind it to a value before i could put it into the case
04:04:30 <anacrolix> i want to do
04:04:37 <anacrolix> case (get >>=) of
04:04:42 <kmc> right
04:04:48 <anacrolix> case (return get) of?
04:04:51 <anacrolix> :\
04:05:00 <kmc> there's a proposed extension which would be like:   get >>= \case of ...
04:05:06 <kmc> but it's not implemented in GHC
04:05:50 <anacrolix> so the issue is that case is not callable?
04:06:00 <kmc> i guess you could put it that way
04:06:16 <mm_freak_> @undo do c <- cc; c
04:06:16 <lambdabot> cc >>= \ c -> c
04:06:28 <kmc> (x >>= id) = join x
04:06:32 <mm_freak_> do-notation never translates to join?
04:06:38 <kmc> apparently not in @undo
04:06:45 <kmc> but it's not even clever enough to eta-reduce
04:06:59 <mm_freak_> hmm, ok
04:07:09 <kmc> i think implementations are free to do whatever they like as long as it preserves the intended semantics
04:07:39 <mm_freak_> well, to what extent?  are implementations allowed to optimize (>>= return) away?
04:07:47 <rostayob> is there a type class for primitive types?
04:07:55 <mm_freak_> rostayob: what's a primitive type?
04:08:02 <mm_freak_> like Int#?
04:08:04 <rostayob> yes
04:08:07 <kmc> mm_freak_, I don't know, ask a lawyer :)
04:09:00 <danr> Yesterday, someone asked about changing the state in a state monad, and today I remembered this blog post by sigfpe: http://blog.sigfpe.com/2009_02_01_archive.html
04:09:03 <kmc> "Instances of Monad should satisfy the following laws:"
04:09:25 <kmc> does "should" imply that failure to do so is undefined behavior? or unspecified behavior? or implementation-defined behavior?
04:09:29 <rostayob> mm_freak_: well I guess unboxed types is the correct term
04:09:29 <kmc> (to borrow the terms from C)
04:09:40 <cicatristeza> hello, i installed happstack and i have setup a simple guestbook project. how do i run it?
04:09:42 <kmc> rostayob, what would you do with this class?
04:10:11 <lol_> hello
04:10:52 <donri> cicatristeza: simpleHTTP nullConf ...
04:11:01 <mm_freak_> rostayob: no, unboxed types don't need to be primitive
04:11:19 <anacrolix> kmc: a lot of complex things in this rewrite you did, is all the increased abstraction really worth it?
04:11:39 <anacrolix> kmc: it's a fantastic example to learn from however
04:12:15 <cicatristeza> donri: not cabal install?
04:12:35 <rostayob> kmc: here i am again, I am working with Generic and I want to traverse a data type calling "to" repeatedly, so that I convert it to a generic representation
04:12:37 <kmc> anacrolix, that's up to you.  i'm not sure I really increased abstraction
04:12:46 <kmc> anacrolix, which parts in particular are you iffy about?
04:12:51 <rostayob> so if I have Tree (Maybe Int), I convert Tree and then each Maybe element
04:12:52 <donri> cicatristeza: sure, if you have an Executable confiured
04:13:04 <rostayob> the thing is that, I have to stop when I hit primitive types
04:14:21 <rostayob> since I just want to leave those values in
04:14:37 <rostayob> I could list them manually
04:15:02 <anacrolix> kmc: i guess it's general programming technique, but is there really any need to abstract Msg, Get, Put since their use so tightly mirrors the raw types anyway?
04:16:27 <kmc> Get and Put are pretty marginal
04:16:37 <kmc> it's just that the type sig is easier to read if you see "Put" rather than (Msg -> IO ())
04:16:46 <kmc> they're just synonyms so they confer no additional type checking
04:16:54 <kmc> but Msg does, it's a new type which can't be confused with Maybe
04:17:10 <opqdonut> is there an indentation style guide or something? I'm wondering how to format "longthing . longthing $ longthing ++ longthing" nicely
04:17:11 <anacrolix> this is an advantage, yes i see
04:17:12 <kmc> and I think the code reads better with "Stop" instead of "Nothing"
04:17:21 <anacrolix> yea it certainly does, thx
04:18:53 <anacrolix> what's the standard socket module to use?
04:19:01 <anacrolix> tehre are a bunch that i can't differentiate
04:19:41 <kmc> Network if it has what you need; Network.Socket is lower-level
04:20:03 <kmc> usually you'd use them with the ByteString IO functions
04:20:14 <kmc> i guess there is also Network.Socket.ByteString for that purpose
04:25:46 <anacrolix> yeah y would you ever use them with Strings
04:25:49 <anacrolix> that's weird
04:26:01 <kmc> historical reasons
04:26:12 <cartman412> hi all
04:26:45 <anacrolix> kmc: so strings are unicode strings like in python? or are they cons' integers that just happen to always be in [0, 256)?
04:26:54 <kmc> type String = [Char]
04:27:00 <kmc> Char is a Unicode character
04:27:06 <kmc> or a code point anyway
04:27:19 <anacrolix> sorry for the crazy questions but i really need to clear some stuff up
04:27:23 <kmc> (actually, GHC allows certain invalid code points as Chars, like half of a UTF-16 surrogate pair, but let's not talk about that ;)
04:27:52 <kmc> Python has both ASCII and Unicode strings
04:27:57 <anacrolix> so if i received from a socket with the String types, will it decode utf-8, utf-16 or assume latin1?
04:28:05 <kmc> no idea, that's why you shouldn't do it :)
04:28:14 <kmc> probably it uses whatever locale is set; that's how String IO works generally
04:28:37 <kmc> i'd read ByteString and decode to Unicode with http://hackage.haskell.org/packages/archive/text/0.11.1.9/doc/html/Data-Text-Encoding.html
04:28:45 <anacrolix> cheers
04:28:58 <kmc> Text is a Unicode text type, like String, but it has an efficient packed representation, like ByteString
04:29:32 <kmc> unfortunately ByteString came first so there's still a lot of broken code which assumes ASCII or Latin-1 and uses ByteString
04:29:43 <hpaste> cartman412 pasted “Parsing” at http://hpaste.org/53546
04:30:14 <cartman412> anyone know why im getting that error, im fairly new to the whole FP
04:32:12 <anacrolix> is hackage the best place to look for modules? if i google i get weird looking descriptions from ghc6
04:32:40 <cartman412> im trying to parse a string, i was parsing from a file perfectly but now that i want to parse directly from the string im getting an error
04:34:21 <cartman412> http://hpaste.org/53546 heres the code
04:34:31 <cartman412> Error is type String
04:35:03 <mah_b> cartman412: what type has (parse program)?
04:35:29 <danr> cartman412: you cannot bind string to content because string is String and not Either Error a
04:35:39 <danr> I guess you can just do parse program string
04:35:59 <danr> you only use the bind, or <-, when it is acutally a monadic value
04:36:05 <kmc> anacrolix, docs for standard Haskell Platform modules are here: http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
04:36:11 <kmc> otherwise yeah, look up the package on hackage
04:36:28 <mah_b> cartman412: if (parse program) :: String -> Either Error String, then parseString = parse program
04:37:29 <mah_b> s/Either Error String/Either Error Program/
04:38:43 <quicksilver> kmc: that's a funny URL
04:38:54 <quicksilver> handy though.
04:38:57 <cartman412> danr: tried that, now im getting a different error, but seems that im very close to it
04:39:39 <danr> cartman412: ok feel free to ask again with your new error :)
04:40:31 <hpaste> cartman412 pasted “Parsing” at http://hpaste.org/53547
04:40:42 <cartman412> danr:  heres the new error
04:41:07 <kmc> quicksilver, yeah.  it's linked from http://hackage.haskell.org/platform/
04:41:28 <anacrolix> kmc: thx for ur help
04:41:59 <cartman412> danr:  heres the new error http://hpaste.org/53547
04:42:09 <cartman412> not sure u saw the paste before :)
04:42:25 <danr> cartman412: what is the type of parse?
04:43:36 <cartman412> danr: parse
04:43:36 <cartman412>   :: Text.Parsec.Prim.Stream s Data.Functor.Identity.Identity t =>
04:43:37 <cartman412>      Text.Parsec.Prim.Parsec s () a
04:43:37 <cartman412>      -> SourceName
04:43:37 <cartman412>      -> s
04:43:37 <cartman412>      -> Either ParseError a
04:44:10 <danr> I guess you don't need neither return nor do then
04:44:44 <hpaste> danr annotated “Parsing” with “Parsing (annotation)” at http://hpaste.org/53547#a53548
04:45:03 <cartman412> danr: that worked beautifully
04:45:08 <danr> cartman412: good :)
04:45:11 <cartman412> cheers :)
04:46:59 <cartman412> another question, i have a type Name = String, but i have certain reserved names that i want to make sure can't be assigned to the type Name
04:47:46 <cartman412> im using L.reservedNames = ["bla", "bla1", etc]
04:48:01 <cartman412> L being Parsec.Token
04:48:04 <basvandijk> cartman412: Turn Name into "newtype Name = Name String" and don't export the constructor.
04:48:31 <basvandijk> That way users can't accidentally construct a Name.
04:48:36 <Athas> Is Clemens Fruhwirth here?
04:49:03 <basvandijk> Does anybody know where the cereal repository is located?
04:49:08 <kmc> anacrolix, no problem :)
05:03:21 <rostayob> these two instances are overlapping:
05:03:23 <rostayob>   instance ToVar (Var a) a
05:03:25 <rostayob>   instance (Generic a, GToVar (Rep a) (Rep b)) => ToVar a b
05:03:29 <rostayob> the thing is, (Var a) is not generic
05:03:37 <rostayob> so they're not actually overlapping
05:03:43 <kmc> that's not how overlapping works, though
05:03:54 <kmc> instance resolution does not backtrack
05:03:58 <rostayob> yep, but is there some extension or something like that?#
05:04:02 <kmc> no
05:04:04 <rostayob> :(
05:04:12 <kmc> you pick an instance by the head only, and then recursively try to satisfy its constraints
05:04:20 <rostayob> mhm. so I can't express something like that
05:04:20 <kmc> i mean, there is an extension to allow overlapping instances
05:04:27 <kmc> but not to do backtracking
05:04:51 <cartman412> how would i tell the parsec to consider any whitespace as a normal space?
05:05:09 <rostayob> cartman412: well, you've got isSpace
05:05:15 <rostayob> dropMany isSpace
05:05:20 <quicksilver> normally you'd do lexing first, cartman412
05:05:30 <quicksilver> well normally I would, anyhow ;)
05:05:40 <kmc> most parsec parsers I see don't have a separate lexer
05:05:46 <cartman412> i am using lexer
05:05:57 <kmc> though it's easy enough to map whitespace characters to ' ' ahead of the parser
05:05:57 <quicksilver> most parsec parsers aren't written by me :)
05:06:26 <cartman412> parseString string = parse program "" string
05:07:28 <cartman412> how would i change that to take any whitespace char as a space between tokens?
05:07:48 <cartman412> sorry if its a silly/dumb question
05:08:03 <quicksilver> replace 'string' at the end with (map (\x -> if isSpace x then ' ' else x) string)
05:08:12 <quicksilver> would be kmc's hack
05:08:38 <quicksilver> which is fine if that's what you need
05:08:46 <cartman412> Not in scope: `isSpace'
05:08:53 <quicksilver> I have become used to thiking of lexical analysis as another phase
05:08:58 <quicksilver> @index isSpace
05:08:58 <lambdabot> Data.Char
05:10:24 <cartman412> still getting the same error
05:10:25 <cartman412> lexical error in string/character literal at character '\r'
05:10:52 <quicksilver> that sounds like a haskell compilation error
05:10:59 <quicksilver> not at error form your parser?
05:11:19 <cartman412> ok
05:11:26 <simon> are you ever supposed to have more than one module within a file?
05:11:34 <cartman412> i'll paste some more of the code so u can see?
05:11:42 <quicksilver> cartman412: yes. And the exact error.
05:11:46 <quicksilver> simon: not in GHC no.
05:12:40 <hpaste> blankverse pasted “settings.yml” at http://hpaste.org/53550
05:14:48 <hpaste> cartman412 pasted “whitespaces” at http://hpaste.org/53552
05:15:01 <cartman412> there you go quicksilver
05:16:18 <quicksilver> cartman412: you can't just break lines inside a haskell string
05:16:24 <quicksilver> neither in ghci not in a sourcefile.
05:16:37 <quicksilver> the error is just that your example is not a valid haskell expression
05:17:10 <cartman412> i see
05:17:15 <cartman412> so theres actually nothing wrong?
05:17:38 <quicksilver> well, your code is obviously compiling fine :)
05:17:48 <quicksilver> as to whether it works or not, I don't know
05:17:52 <cartman412> eheh
05:18:00 <cartman412> well, that code i try to parse
05:18:05 <cartman412> if its put in a file as is its fine
05:18:07 <quicksilver> try putting your example program in a file called 'example.txt'
05:18:21 <cartman412> but just like that it doesnt
05:18:24 <quicksilver> and then doing liftM parseString (readFile "example.txt")
05:18:27 <quicksilver> or suchlike
05:18:32 <cartman412> but if i put it all in a string in one line then it works
05:19:10 <quicksilver> good
05:19:30 <cartman412> so it should be fine?
05:19:52 <cartman412> i mean, its just because i broke a line?
05:19:58 <cartman412> that the error occured
05:20:00 <quicksilver> yes.
05:22:19 <HugoDaniel> what is the quick n dirty way of doing foldr (++) "" . lines  ?
05:22:41 <HugoDaniel> wasnt there a special function for that ?
05:23:40 <ClaudiusMaximus> @check \s -> foldr (++) "" s == concat s
05:23:42 <lambdabot>   "OK, passed 500 tests."
05:24:30 <wunki> is it possible to build a single .hs file with a cabal-dev environment?
05:24:30 <MostAwesomeDude> Oh man, this bot's got everything.
05:25:05 <osfameron> @faq is it possible to find someting that lambdabot *can't* do?
05:25:05 <lambdabot> The answer is: Yes! Haskell can do that.
05:25:16 <mm_freak_> @djinn a -> b
05:25:17 <lambdabot> -- f cannot be realized.
05:25:18 <mm_freak_> there you go
05:25:28 <mm_freak_> lambdabot is too stupid to do this
05:27:09 <applicative> @type let f :: a -> b ; f = undefined
05:27:10 <lambdabot> <no location info>:
05:27:10 <lambdabot>     not an expression: `let f :: a -> b ; f = undefined'
05:27:16 <applicative> aw
05:27:25 <applicative> @type let f :: a -> b ; f = undefined in f
05:27:26 <lambdabot> forall a b. a -> b
05:27:48 <rostayob> :t let x :: a -> b = x in x
05:27:48 <lambdabot> Not in scope: type variable `a'
05:27:49 <lambdabot> Not in scope: type variable `b'
05:27:55 * applicative agrees with djinn, really
05:28:07 <rostayob> :t let x = (x :: a -> b) in x
05:28:07 <lambdabot>     Inferred type is less polymorphic than expected
05:28:08 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
05:28:08 <lambdabot>         x :: a -> b (bound at <interactive>:1:4)
05:28:21 <rostayob> :t (let x = x in x) :: a -> b
05:28:22 <lambdabot> forall a b. a -> b
05:28:27 <rostayob> uff
05:28:46 <rostayob> :t let x = x in (x :: a -> b)
05:28:47 <lambdabot> forall a b. a -> b
05:28:58 <applicative> oh excellent
05:29:25 <rostayob> :t (fix id) :: a -> b
05:29:26 <lambdabot> forall a b. a -> b
05:30:22 <rostayob> :t ((\x -> f ((unroll x) x)) (Roll (\x -> f ((unroll x) x))) id) :: a -> b
05:30:23 <lambdabot> Not in scope: `unroll'
05:30:23 <lambdabot> Not in scope: data constructor `Roll'
05:30:23 <lambdabot> Not in scope: `unroll'
05:30:38 <rostayob> what is it called in lambda bot? Mu a = Mu a -> a
05:31:15 <rostayob> :t ((\x -> f ((unroll x) x)) (Mu (\x -> f ((unroll x) x))) id) :: a -> b
05:31:16 <lambdabot> Not in scope: `unroll'
05:31:16 <lambdabot> Not in scope: data constructor `Mu'
05:31:16 <lambdabot> Not in scope: `unroll'
05:31:18 <rostayob> :t Mu
05:31:18 <lambdabot> Not in scope: data constructor `Mu'
05:31:22 <rostayob> :k Mu
05:31:23 <lambdabot> (* -> *) -> *
05:31:28 <rostayob> ok that's the other mu
05:31:29 <applicative> :t In
05:31:30 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
05:31:54 <rostayob> yeah that's another mu, I just wanted Mu a = Mu a -> a
05:32:09 <rostayob> why this sympathy for Mu anyway
05:32:19 <rostayob> μμμμμ
05:34:05 <rotflcopter> hiii
05:34:10 <rostayob> hi rotflcopter.
05:34:11 <rotflcopter> any C programmers here?
05:34:19 <rostayob> yes, but we don't talk about that.
05:34:27 <rotflcopter> i'd have 1 question
05:34:32 <lunaris> Sounds like the first rule of #haskell.
05:34:47 * kmc talks about it...
05:34:53 <rotflcopter> might allow for an unusual question in C for greater good?
05:35:01 <rostayob> why not ##C?
05:35:06 <lunaris> rotflcopter: I have no problems with C questions.
05:35:07 <lunaris> Well.
05:35:08 <kmc> because it's full of assholes and trolls
05:35:09 <lunaris> Accepting them.
05:35:10 <rotflcopter> i'd need an example of doing asynchronous screen flipping from backbuffer, and have 60hz video refresh rate while having unlimited mainloop performance.
05:35:12 <rostayob> or #haskell-blah, or whatever
05:35:13 <lunaris> Answering them, perhaps.
05:35:22 <rostayob> wat?
05:35:27 <rotflcopter> using SDL_Flip
05:35:30 <kmc> rotflcopter, those... don't seem like C concepts to me
05:35:40 <applicative> this isn't a C question
05:35:41 <kmc> you have a question about SDL?
05:35:44 <rostayob> rotflcopter, you stand by that nickname.
05:35:46 <MostAwesomeDude> rotflcopter: Well, that's kind of tricky.
05:35:53 <rotflcopter> no, it would be general/mixed rather
05:35:56 <rotflcopter> ;/ú
05:36:04 <MostAwesomeDude> rotflcopter: First, why do you want your mainloop to spin so fast? Why can't you block on flip?
05:36:09 <rotflcopter> was thinking about one of the fork() things, or ptheread
05:36:14 <rotflcopter> pthread()
05:36:19 <rostayob> i'm intrigued by the concept of "unlimited mainloop performance"
05:36:42 <rotflcopter> because i'd need a core funciton that is uninterrupted / realtime, and display is secondary in my case
05:36:57 <rotflcopter> for CNC machine control
05:37:20 <rotflcopter> and SDL_Flip waits for vertical retrace...
05:37:22 <kmc> i would separate that into two processes
05:37:22 <MostAwesomeDude> rotflcopter: Well, soft realtime, right? Hard realtime is *really* difficult when graphics get involved.
05:37:36 <kmc> one which does machine control and sends data to the GUI process
05:37:41 <MostAwesomeDude> rotflcopter: Do you mind tearing? A cheap solution is to turn off vsync for flips.
05:37:48 <rotflcopter> i cant :(
05:37:53 <kmc> and perhaps has a realtime scheduler priority
05:37:58 <rotflcopter> but anyway i dont have to display every time ;)
05:38:03 <rotflcopter> 60fps is more than enough
05:38:05 <kmc> your "C question" was first a SDL question and now a systems question ;P
05:38:12 <cheater> saying hard realtime with graphics is difficult is like saying hard realtime with audio is really hard
05:38:24 <cheater> and to be honest i don't hear cd players cutting out
05:38:25 <cheater> ever
05:38:32 <cheater> unless the cd is broken, that is
05:38:39 <MostAwesomeDude> cheater: *Big* buffers. :3
05:38:46 <rotflcopter> i have a realtime-preempt kernel and im sure it would produce good results btw
05:38:46 <cheater> no
05:38:52 <cheater> that is an incorrect way to do it
05:38:54 <MostAwesomeDude> It's difficult to determine how long a graphics rendering operation will take.
05:38:57 <kmc> "hard realtime" with a 60Hz refresh would be easy, if the latency requirements are much less than 1/60s
05:39:11 <kmc> "hard realtime" does not mean "low latency"
05:39:28 <rotflcopter> so someone can show an example of creating such a thing in a child thread? :)
05:39:52 <cheater> we usually don't condone child labor
05:40:02 <rotflcopter> currently learning the fork() and pthread() functions
05:40:11 <rotflcopter> ahah cheater
05:40:26 <rotflcopter> so you don't support cloning
05:41:18 <linduxed> hey guys, i've got a piece of code that refuses to load a text file that clearly lies in the same directory as the code that is executed
05:41:21 <kmc> i have a C question, please write for me a full implementation of UNIX
05:41:39 <linduxed> pastie here: http://pastie.org/2809719
05:41:47 <rotflcopter> kmc<< yeah it can do 60fps, but i'd need 1000fps+ to be decent
05:41:58 <flux> kmc, I don't have the whole implementation, but it starts with the letter '/'. hth, hand.
05:42:11 <rotflcopter> and video display is of secondary importance
05:42:39 <kmc> use two processes
05:42:41 <kmc> like i said
05:43:02 <rotflcopter> yeah was only bagging for syntax
05:43:12 <kmc> how is this a syntactic question
05:43:26 <rotflcopter> in-theory i have my answer
05:43:58 <cheater> rotflcopter: what are you doing that requires 1000 fps
05:44:14 <cheater> (the answer is "nothing" but i'll amuse myself)
05:44:27 <rotflcopter> step-dir CNC machine control needs it
05:44:32 <hpc> how is your monitor going to display those thousand frames?
05:44:42 <rotflcopter> resolution is 10um/step
05:44:52 <cheater> hpc: by having 1000 monitors he can display 1000 fps
05:45:07 <cheater> rotflcopter: why does it need to be video output again?
05:45:22 <rotflcopter> it would be nice if i know what it is doing
05:45:34 <rotflcopter> but unimportant, really
05:45:36 <cheater> so you want to output this at 1000 fps
05:45:52 <kmc> why not use a real machine controller like http://linuxcnc.org/
05:45:56 <rotflcopter> no, as i stated video refresh rate is good at 60hz
05:45:56 <cheater> see how my prediction was true? i'm good.
05:46:06 <cheater> kmc: because the language is terrible :O
05:46:15 <cheater> rotflcopter: i think you got your units messed up
05:46:28 <cheater> rotflcopter: you want fps for the graphics, hz for the machinery update.
05:46:32 <rotflcopter> kmc<< i cannot install that right now, it REQUIDRES/ENFORCES/DEMANDS the use of RTAI application interface
05:46:34 <cheater> not the other way around.
05:46:54 <rotflcopter> and i have the time to code a machine controller myself for my own machine
05:47:40 <rotflcopter> and i have a realtime-preempt kernel that should be enough for me right now
05:48:18 <rotflcopter> i can define the maximum step-rate...
05:48:53 <linduxed> also, i've tried turning that function in to one that actually takes arguments, but i failed at that too
05:48:57 <kmc> you're off topic and also crazy
05:49:04 <rotflcopter> also was thinking about doing the same in GHC, given it will be able to do calculations fast-enough to make it worth the laziness
05:50:34 <linduxed> mitra_: ping
05:50:37 <dylex> linduxed: when you say it "refuses" what do you mean? does it throw an exception?
05:50:50 <linduxed> dylex: yes it does
05:51:02 <linduxed> dylex: it doesn't find the file, it claims
05:51:43 <dylex> linduxed: okay, and how are you running the program?  have you tried referencing to the file by the full path -- it might be a working directory issue.
05:52:07 <linduxed> dylex: yeah, it could be a working dir issue
05:52:39 <linduxed> dylex: but that would make me fairly surprised, i opened the interpreter in the dir
05:52:45 <linduxed> oh well, will check
05:53:49 <rotflcopter> [134748] kmc i have a C question, please write for me a full implementation of UNIX - ahah :)
05:55:02 <rotflcopter> ok looks like i have to read pthread and fork functions, and search for examples until i find the best opinion for this job ;<
05:59:02 <statusfailed> Why does this work at the GHCI prompt but not when loading a file? length [1..10] >< 2 $ [0,0..]
05:59:19 <statusfailed> it's using Numeric.LinearAlgebra
05:59:21 <hpc> statusfailed: what's the error?
05:59:41 <statusfailed> ambiguous type arising from usage of ><
05:59:49 <statusfailed> it's quite long, shall I paste it somewhere?
06:00:12 <statusfailed> oh, it's from the [0,0..]
06:01:14 <hpc> ah, sounds like the monomorphism restriction
06:01:31 <statusfailed> I change it to [0,0..] :: [Double] and it works
06:01:45 <statusfailed> Why does it work at the prompt?
06:02:10 <linduxed> dylex: you were right, it was a path issue
06:02:35 <linduxed> dylex: doing this on a friend's windows computer, completely lost because of it :-P
06:02:40 <hpc> because ghci decides to just say "that's a Double" all by itself
06:03:02 <hpc> it does that for polymorphic things so it knows how to display the result
06:03:39 <statusfailed> Ah ok
06:03:46 <statusfailed> fair enough!
06:04:33 <hpc> there's a more technical explanation of what it does if you look up "monomorphism restriction" on the wiki
06:08:39 <statusfailed> hpc: cheers, I will check it out
06:14:41 <dmwit> statusfailed, hpc: No monomorphism restriction here; this is the result of ghci's extended defaulting.
06:23:44 <cwl> * Missing (or bad) header file: runProcess.h
06:23:57 <cwl> cabal install process failed
06:24:01 <cwl> * Missing (or bad) header file: runProcess.h
06:24:13 <cwl> what dependency is missing?
06:29:12 <nh2> what happened to to-string-class?
06:29:21 <nh2> why is it obsolete?
06:40:49 <kmc> cwl, look in the package's cabal file
06:40:53 <kmc> to see what C library it expects
06:41:32 <mm_freak> i have a Seq-based FIFO queue…  incoming data comes as lists, gets converted to Seq and then (><)-ed to the end of the current queue
06:41:37 <cwl> kmc: http://hackage.haskell.org/trac/ghc/ticket/5449
06:41:48 <mm_freak> is there any point in using Seq here?  i feel i could just as well use a list
06:41:49 <cwl> someone else also met the problem
06:42:49 <cwl> kmc: I download the process-1.1.0.0, include/runProcess.h exists.
06:42:59 <cwl> but cabal configure failed
06:43:01 <mm_freak> (>< currentQueue) . S.fromList  -- even seems to have a higher complexity than (++)
06:43:17 <cwl> cabal configure -v3 shows that include/runProcess.h:47:26: fatal error: processFlags.h: No such file or
06:43:21 <cwl> directory
06:43:30 <mm_freak> and i'd expect pattern matching on a list to be faster, too, as opposed to S.viewl
06:48:26 <mm_freak> ok, a quick benchmark shows that Seq is still faster
06:54:09 <quicksilver> mm_freak: at the head lists are faster. at the tail Seq is *much* faster.
06:54:44 <quicksilver> mm_freak: since you have to use both for FIFO, Seq will be a win unless the average list length is so small the constant factor dominates.
06:55:05 <cwl> where is the processFlags.h for package process-1.1.0.0
06:57:11 <dmwit> mm_freak: You could also consider using the ([a], [a]) queue.
06:57:26 <chrisdone> bind = flip (>>=) — is a really nice function
06:57:31 <dmwit> It'll probably be faster than Seq if you don't need to do things to the middle of the queue (only the front and back).
06:57:39 <dmwit> chrisdone: (=<<), and yes it is
06:57:54 <chrisdone> =<< is not good for the same reason
06:58:22 <chrisdone> fmap f $ foo bar mu naturally is updated to bind f $ foo bar mu when f becomes monadic :)
06:59:53 <hpaste> chrisdone pasted “bind” at http://hpaste.org/53557
07:00:27 <chrisdone> ^_^
07:02:30 <simon> is there a way to avoid having to write 'lexeme $ string "foo"' in the middle of my parser without having to define a foo-lexer?
07:03:33 <hpaste> anonymous annotated “bind” with “bind (annotation)” at http://hpaste.org/53557#a53558
07:03:56 <simon> that's a very useful elaboration hpaste made there.
07:05:52 <chrisdone> i generally don't like >>, >>= and especially =<<, operators like that. they complicate otherwise simple code changes
07:06:17 <clsmith> hey. is there a special name for higher-order types like Monoid, Monad, etc?
07:06:40 <hpc> type classes
07:06:46 <hpc> (they aren't types)
07:06:53 <clsmith> sorry, for context, i want to say "a foldable structure of monoids". is there a nicer way to say that?
07:07:17 <clsmith> (that's anything that can be passed through a more generic concat)
07:07:57 <hpc> oh
07:08:01 <hpc> @hoogle foldable
07:08:02 <lambdabot> Data.Foldable module Data.Foldable
07:08:02 <lambdabot> Data.Foldable class Foldable t
07:08:02 <lambdabot> Control.Seq seqFoldable :: Foldable t => Strategy a -> Strategy (t a)
07:08:41 <dainanaki> I'm using cabal-dev with a CI server to sandbox my build changes, but I'm running into an issue in that if I run cabal-dev install-deps, it reinstalls the dependencies whether it needs to or not. Is there any way to only reinstall dependencies if something has changed?
07:16:11 <rotflcopter> hah i see now, i can thrash my system performance by allocating too much data, so ghc just allocates memory
07:19:08 <mm_freak> quicksilver: incoming elements come as whole lists of them, so i need (++) anyway…  is prepending much faster than appending for lists?
07:19:32 <mm_freak> dmwit: how is that a queue?  i see only a list zipper there
07:20:38 <quicksilver> mm_freak: yes, much faster
07:20:49 <quicksilver> new_list (++) old_list is O(new_list)
07:20:56 <quicksilver> but old_list ++ new_list is O(old_list)
07:21:02 <quicksilver> (obviously!)
07:21:30 <quicksilver> mm_freak: It's a standard way to represent a queue. Push on one, pop from the other, reverse and swap when it gets empty.
07:23:02 <quicksilver> [ push x (a,b) = (x:a,b); pop (a,(x:xs)) = (x,(a,xs)); pop ([],[]) = error "POP GOES THE WEASEL"; pop (a,[]) = pop ([],reverse a)
07:32:51 <eulyix> I have a function, eval, that evaluates to a Float. I'm trying to write a pretty printer, but how can I concatenate a Float to a string? In Scheme I'd probably open a string output port, but I'm not sure how that's done in Haskell.
07:33:13 <quicksilver> show
07:33:19 <quicksilver> > show 3.14 ++ "string"
07:33:21 <lambdabot>   "3.14string"
07:33:21 <eulyix> Oh FFS
07:33:26 <eulyix> I was just told about that...
07:33:28 <eulyix> Thanks
07:33:32 <quicksilver> it's ok advice is free
07:33:37 <quicksilver> being told twice doesn't cost more :)
07:33:41 <eulyix> :)
07:34:53 <mm_freak> quicksilver: would you suggest ([a], [a]) over Seq a for efficiency?
07:35:15 <quicksilver> mm_freak: no, I'd suggest using Seq because it's simple to use and has a good API and is probably good enough
07:35:26 <quicksilver> however you could benchmark the list pair if you're curious :)
07:35:50 <mm_freak> quicksilver: the reversing seems to kill most of it
07:36:09 <dever> quick question, i want to override the (-) method so i can subtract tuples, i know i've done something like this before but i can't remember it
07:36:21 <mm_freak> dever: for vectors?
07:36:45 <dever> tuples, say (x,y,z)
07:36:52 <mm_freak> dever: yes, but in the vector sense?
07:37:06 <mm_freak> (x1,y1) + (x2,y2) = (x1+x2, y1+y2)?
07:37:17 <dever> yes, in the vector sense :)
07:37:19 <haderach> has anyone had trouble installing glib with cabal? Wants gtk2hsC2hs version >=0.13.5, only has 0.13.4
07:37:25 <mm_freak> dever: then use the vector-space package
07:37:38 <mm_freak> not only does it provide all instances for you, it has real vector space classes, too
07:37:42 <dcoutts> haderach: install the latest gtk2hs-buildtools
07:37:44 <mm_freak> tuple1 ^+^ tuple2
07:37:55 <mm_freak> tuple ^* scalar
07:37:56 <mm_freak> etc.
07:37:58 <dmwit> mm_freak: It's amortized O(1) for push and pop, actually.
07:38:26 <mm_freak> dmwit: is it really O(1) for pop in the case one of the lists runs empty=
07:38:27 <mm_freak> ?
07:38:33 <dmwit> yup
07:38:47 <dmwit> *amortized* O(1)
07:38:50 <dever> mm_freak: cheers!
07:39:17 <mm_freak> dmwit: what's the difference?
07:39:43 <dmwit> mm_freak: The idea is that, for each push, you pay for a cons + a tiny constant amount for the extra work reverse has to do later.
07:40:21 <dmwit> mm_freak: The difference is that no particular single operation has any O(1) guarantee, but over large numbers of operations, an average O(1) is guaranteed.
07:40:25 <mm_freak> dmwit: in the FIFO case Seq has improved the performance by a factor of about 50
07:40:38 <mm_freak> i see
07:40:41 <mm_freak> i'll give it a try
07:45:06 <haderach> dcoutts: thanks. For the future, what's a fast way to discover which cabal package owns a problematic file?
07:45:56 <mokus> there are also variations of the list-based-queue idea that have worst-case O(1) time guarantees for push and pop
07:46:18 <mokus> for example, okasaki describes a simple version at: http://www.eecs.usma.edu/webs/people/okasaki/jfp95.ps
07:46:52 <mokus> still a lot more complex than the basic 2-stack version though
07:47:14 <dcoutts> haderach: you mean to find the package that supplies an executable, no currently that kind of inverse lookup is not easy.
07:47:35 <mokus> er, 2-list version i mean
07:47:35 <dcoutts> finding the exes provided by a package is easy, but not the inverse
07:48:45 <quicksilver> that list always runs empty in normal use
07:48:59 <quicksilver> oops, scrolled way way up
07:49:11 * hackagebot cabal-macosx 0.2 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.2 (AndyGimblett)
07:49:13 * hackagebot epub-tools 1.1.0 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-1.1.0 (DinoMorelli)
07:50:04 <scooty-puff1> is it possible to have ghc only warn about top level .. things without type signatures if they are exported?
07:54:53 <quicksilver> no.
07:56:22 <traviscline> hello 368
07:59:26 <o-_-o> when I say print "P2", it prints "P2" with the double quotes. How do I make it to print without the double quotes ?
07:59:50 <chra> putStr
08:00:08 <rotflcopter> is separate process, or separate thread better for multicore ?
08:01:40 <mm_freak> http://www.haskell.org/ghc/docs/latest/ ⇐ which version does this refer to right now?
08:04:43 <mm_freak> nevermind
08:19:31 <lda> what is the recommended way (if any) of communicating with a server that uses SunRPC?
08:19:57 <miasma> not a directly haskell related question, but could someone suggest some source to read if one wants to _implement_ a very simple ml/haskell like type system with mainly primitive built-in types, scopes, and parametric polymorphism
08:20:03 <quicksilver> Burn server in cleansing fire. Enlist services of spiritual medium.
08:20:32 <lda> sounds like a plan
08:20:44 <hpc> @where stg
08:20:44 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:20:58 <hpc> miasma: the STG paper is a good place to start
08:22:28 <miasma> hpc: thanks, reading. i kind of have already done several experiments, but have some problems distinguishing between variable names between scopes and propagating type binding updates back to the parent scope
08:24:40 <kowey> Prelude.chr: bad argument: 1818838566 makes kowey sad
08:25:00 <kowey> (in the process of trying to get wxHaskell to work on 64 bit)
08:25:08 <applicative> > chr 1818838566
08:25:09 <lambdabot>   *Exception: Prelude.chr: bad argument: 1818838566
08:25:28 <kowey> would be nice to be able to find out who is invoking chr
08:25:52 <HaskellElephant> The Language shootout game has entries for different compilers, maybe it would be nice to see how the llvm backend holds up against the GHC native code generator... Just a thought...
08:26:59 <applicative> HaskellElephant: I thought some of them ask to be compiled with  -fllvm now, maybe not
08:27:49 <MostAwesomeDude> HaskellElephant: The shootout's busted; the guy who runs it has issues and refuses to run more than one platform per language.
08:27:59 <HaskellElephant> Ahhh...
08:28:00 <MostAwesomeDude> So there's no test of Python or Lua JITs. :T
08:28:19 <HaskellElephant> too bad
08:29:38 <applicative> MostAwesomeDude: did you see three 'quad core' thread ring?  http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
08:29:39 <MostAwesomeDude> Anyway, cross-language benchmarks are inherently flawed, so it's not a biggie.
08:29:54 <HaskellElephant> But are any of them compiled with llvm? I just see standard here...
08:30:08 <applicative> HaskellElephant: I take that back looking at them.
08:30:46 <MostAwesomeDude> Something like speed.pypy.org/speed.python.org for Haskell would be pretty awesome, though.
08:30:52 <applicative> HaskellElephant: I think someone mentioned that it needs to be studied, as you just did... my impression is that they haven't been worked on much lately
08:30:58 <HaskellElephant> I remember a while back I tested llvm on pidigits and it was about a 20% decrease in runningtime
08:31:51 <HaskellElephant> pypy speedcenter looks really nice...
08:31:55 <applicative> HaskellElephant: I remember trying a few too.
08:32:23 <gcr> Howdy! I want a function like Char.ord but that returns an Integer, not an Int
08:32:31 <gcr> IS there a better way than (fromIntegral . Char.ord) ?
08:32:36 <monochrom> no
08:33:20 <hpc> gcr: you can always give (fromIntegral . ord) a name :P
08:33:33 <applicative> gcr, just write   'khr = fromIntegral . chr
08:33:33 <HaskellElephant> What is wrong with fromIntegral . ord ?
08:34:14 <applicative> gcr, just write   owd = fromIntegral . ord rather
08:34:54 <hpc> @src Integer
08:34:54 <lambdabot> data Integer = S# Int#
08:34:55 <lambdabot>              | J# Int# ByteArray#
08:35:09 <applicative> @type (ord,chr)
08:35:10 <lambdabot> (Char -> Int, Int -> Char)
08:35:17 <hpc> gcr: if the problem is performance, you could be extremely silly and write
08:35:39 <hpc> kord c = let (I# i) = ord c in S# i
08:36:20 <hpc> (iirc that's what the S# constructor is for)
08:36:22 <monochrom> hahaha
08:37:03 <mm_freak> when defining a function 'arr' i remember being able to write this:  w@(arr f) = … w …
08:37:04 <HaskellElephant> hpc: That is the most rediculous optimization I have ever seen, kudos =D !
08:37:17 <mm_freak> that doesn't work anymore…  what am i missing?
08:37:40 <mm_freak> or does that only work for nonfunctions?
08:37:43 <gcr> Ok. Thanks, everyone
08:38:13 <applicative> mm_freak: doesnt x@(Maybe y) and the like require a constructor.
08:38:38 <miasma> hpc: ok, i realized that this probably simplifies the type checking a lot. i thought that the declarations and expressions inside a function may give more information about the type variables in the original type signature, but I don't need to propagate the type information back
08:38:58 <mm_freak> applicative: not sure…  well, that raises another question
08:39:11 <mm_freak> typically i write:  f x = let w = … in w
08:39:28 <hpc> miasma: you're a bit over my head, but feel free to attribute your eureka moment to my brilliant insight :D
08:39:28 <mm_freak> is there a performance penalty with writing f x = … f x … instead?
08:39:32 <elliott_> yes
08:39:38 <elliott_> btw, that's the same as
08:39:40 <elliott_> fix $ \w -> ...
08:39:42 <miasma> hpc: in some languages like C++ the type signature just says that some type variable T is a placeholder and it accepts anything and the later uses inside the function may constain the type a bit more
08:39:50 <elliott_> with the latter you're not guaranteed sharing
08:39:53 <elliott_> indeed you're not likely to get it
08:39:54 <Aune> Im reading "Giving Haskell a Promotion", and it made me think. We have a programming language, on top of that we have a type system that se can use to express qualities of our programs. On top of that we have a kind system to allow us to program in the type system, in order to be able to express more compicated invariants. My question is, is the kind system the upper bound of the hierarchy or does it make sence to later on add a super-kind syst
08:39:54 <Aune> em to be able to express the properties of kinds?
08:39:57 <elliott_> both "let" and "fix" preserve sharing
08:40:15 <elliott_> Aune: kind polymorphism is a thing, so... yes, it does make sense.
08:40:25 <hpc> Aune: above kind is sort, and above sort is something else i forget the name of
08:40:34 <elliott_> oh
08:40:38 <hpc> Aune: you should check out Agda
08:40:40 <applicative> Aune, try Agda, things just keep going.
08:40:40 <elliott_> right, i see the question more
08:40:52 <mdempsky> above sorts are 'turtles'.
08:40:53 <elliott_> i thought Aune was asking, is it reasonable to extend the above systems
08:41:11 <mdempsky> And then beyond that it's turtles all the way down.
08:41:37 <hpc> Aune: and when you want to get really ridiculous, agda has universe polymorphism, which is when you don't know how high up the tower of turtles you have managed to climb
08:42:38 <elliott_> @remember hpc and when you want to get really ridiculous, agda has universe polymorphism, which is when you don't know how high up the tower of turtles you have managed to climb
08:42:38 * applicative is using --type-in-type 
08:42:38 <lambdabot> Okay.
08:43:46 <Aune> elliott_, hpc,    Aaah, yes, so there is a contably infinite hierarchy: type -> kind -> sort -> (succ sort) -> (succ succ sort) -> ... ;) Seems awesome.
08:44:06 <elliott_> Aune: as long as you have some values they're serving at the end of the day... :)
08:44:16 * applicative is more inclined to retreat to a primitive version of ML
08:44:41 <elliott_> Aune: dependent typing, btw, is just letting values float up the hierarchy... i.e. types depending on values. I wonder if anyone's worked on dependent kinding?
08:44:49 <quicksilver> hpc: it's easy to lose track, those turtles all look the same to me!
08:45:45 <dolio> Sort is a poor name for a level, it typically means something slightly different.
08:47:01 <applicative> dolio, check out this imitation of the great Ryle http://www.youtube.com/watch?v=80AovwgVY8Q
08:47:05 <Jeanne-Kamikaze> so... how does one do anything remotely extensible without dynamic dispatch ? I feel comfortable enough to solve the average problem in haskell (the implementation will probably suck, but at least I can get shit done), but I'm left clueless when it comes to designing a system
08:47:18 <Aune> elliott_, Yeah, I cant say I can imagine the use of anything beyond Kind at the moment, but thats just a failiure of my imagination.
08:47:41 <Jeanne-Kamikaze> or maybe I haven't learned anything
08:47:45 <elliott_> Aune: Just lift all your data-types and computations one level higher.
08:47:55 <Eelis> elliott_: i don't think that's accurate. for example, a typical dependent type for a polymorphic identity function is   forall t, t -> t  . this is a dependent type which has nothing to do with letting values float up the hierarchy.
08:47:58 <elliott_> Aune: Who needs the lower classes?
08:48:10 <applicative> dolio, Ryle is from the earlier types vogue of the 20's -50's
08:48:16 <elliott_> Eelis: uh? you can express that type without dependent types
08:48:18 <elliott_> :t id
08:48:19 <lambdabot> forall a. a -> a
08:48:51 <Eelis> elliott_: yes, if you have those weird Haskell-style implicit specially-treated quantitifers. in a system like Coq, which has dependent types, we use a dependent type for it.
08:49:38 <applicative> Eelis: what's wrong with id :: a -> a ?
08:49:40 <elliott_> Eelis: I think that is just stuff floating up the hierarchy: the /argument/ is a value (which just happens to be of type Type[n] for some n) which then floats up to the type level
08:49:53 <elliott_> Eelis: The fact that it is values floating up the hierarchy is obscured by the fact that the type of the value involved is Type.
08:50:04 <Eelis> applicative: from a Coq perspective, what's wrong with it is that the 'a' variable there is unbound :P
08:50:19 <hpc> from an agda perspective, it only works on values
08:50:26 <applicative> yes, its unbound, coq cant express the thought it expresses
08:50:28 <Aune> elliott_, Doh.. Yeah, we can probably encode natural numbers at any level, and then its just a question of finding a property about a subset of the natural numbers that we want to express by using natural numbers in the level above it and we have already recursed through all the turtles..
08:50:40 <Eelis> elliott_: sure, if you want to pervert language by calling types values, then your statement becomes trivially true
08:51:09 <elliott_> Eelis: types being values is sort of half the point of a dependent language
08:51:35 <Eelis> elliott_: if you say so.
08:51:53 <applicative> Eelis, it is what Russell called a 'real' variable, as distinct from forall x ... which is an 'apparent variable', i.e. not a variable at all
08:51:57 <kmc> Jeanne-Kamikaze, dynamic dispatch? you mean like storing a function in a data structure and then calling it?
08:52:05 <dolio> applicative: Exactly. Types and kinds are the same kind of thing, but sorts are a different kind of thing.
08:52:36 <Eelis> applicative: Coq does not have that weird distinction
08:52:46 <Jeanne-Kamikaze> kmc, I mean programming stuff against an interface / abstract class and then letting the user define his own subclasses to get some particular behaviour
08:52:46 <Eelis> applicative: in Coq, variables must be bound.
08:53:00 <Jeanne-Kamikaze> of course this is very oo so I'm not quite sure how it maps to fp
08:53:07 <kmc> Jeanne-Kamikaze, "interface / abstract class" => type, "subclasses" => values
08:53:12 <applicative> yes, that's why you can't think in it
08:53:16 <kmc> it all becomes much simpler in FP
08:53:16 <Jeanne-Kamikaze> yeah, that's what I was told once
08:53:26 <Eelis> applicative: i don't know what you mean by that
08:53:30 <kmc> it becomes hardly worth talking about, which is where you might get the impression that there's no solution
08:53:31 <Jeanne-Kamikaze> but if different subclasses have different attributes
08:53:40 <Jeanne-Kamikaze> how can you have two values of the same type ?
08:53:52 <Jeanne-Kamikaze> hmm, not sure if the wording is correct
08:54:19 <kmc> if there is implementation-dependent state, that can be hidden in various ways
08:54:24 <applicative> in high school algebra, all reasoning is with free variables;  such reasoning is implicit wherever quantifiers are used
08:54:31 <kmc> if you have a hierarchy of interfaces, you can use containment
08:54:46 <kmc> I can probably give a better answer if you can give a more concrete question
08:54:49 <hpc> Jeanne-Kamikaze: suppose you wanted to write an "increment" object
08:55:06 <Jeanne-Kamikaze> kmc, strategy pattern for example
08:55:11 <Eelis> applicative: high school algebra can be done in Coq just fine, so i don't see the problem
08:55:12 <hpc> abstract class Increment {int counter; void increment();}
08:55:19 <hpc> Jeanne-Kamikaze: in haskell you would write
08:55:21 <Jeanne-Kamikaze> ok
08:55:25 <dolio> Isn't strategy one of the higher-order function patterns?
08:55:31 <Jeanne-Kamikaze> is it ?
08:55:40 <kmc> Jeanne-Kamikaze, "patterns" are not problems to be solved; "patterns" are names for standard workarounds for flaws in Java
08:55:45 <applicative> yes,you can do high school algebra in high school logic class; then you use quantifiers
08:56:02 <hpc> data Increment = Increment {counter :: Int; next :: Increment}
08:56:18 <hpc> Jeanne-Kamikaze: and then a (+ 1) counter would be
08:56:41 <Jeanne-Kamikaze> damn, so you just pass a different next function to get different behaviours ?
08:56:51 <hpc> plusone start = Increment {counter = start; next = plusone (start + 1)}
08:57:00 <hpc> yeah, more or less
08:57:05 <Jeanne-Kamikaze> right
08:57:05 <hpc> or a generic counter
08:57:11 <quicksilver> kmc: well, flaws in smalltalk originally in most cases, surely?
08:57:16 <kmc> shrug
08:57:17 <elliott_> hpc: Forgive me, the @pl in my head requires me to say [Int] and then shut up.
08:57:17 <Eelis> applicative: so.. your concern is that being clear about how variables are quantified is such a tremendous burden that it makes easy things hard?  i've done my fair share of Coq formalizing, and that's just patently absurd :)
08:57:32 <hpc> counter increment start = Increment {counter = start; next = counter increment (increment start)}
08:57:42 <hpc> elliott_: :P
08:57:59 <hpc> Jeanne-Kamikaze: and as elliott_ just said, you would really just have an infinite list
08:58:09 <hpc> > iterate (+ 1) 0
08:58:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:58:15 <hpc> > iterate (* 2) 0
08:58:16 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:58:22 <hpc> > iterate (* 2) 1 -- derp
08:58:22 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:58:23 <elliott_> hpc: the data type is better anyway :) since you don't want []
08:58:49 <applicative> Eelis, my only point is it in general a falsification to say that whenever I say, x + y + z = whatever, there are 'implicit quantifiers'
08:58:57 <hpc> Jeanne-Kamikaze: make sense?
08:59:21 <Jeanne-Kamikaze> yeah
08:59:31 <Eelis> applicative: *shrug* whatever.
08:59:47 <applicative> Eelis, there is an inference from x + y = y + x to forall x y , x + y = y + x and reciprocally.  this isn't just a feature of a given language, but of human knowledge irrespective of representation
08:59:56 <hpc> @quote abstract over a function
08:59:57 <lambdabot> No quotes for this person. Take a stress pill and think things over.
09:00:02 <hpc> @quote search abstract over a function
09:00:02 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
09:00:18 <hpc> blah
09:00:45 <hpc> Luke Palmer: Functions are the masters of reuse: when you use an advanced feature, you need a yet more advanced feature to abstract over it (think: classes < existential types < universally quantified constraints < unknown). But all you need to abstract over a function is another function.
09:00:51 <hpc> there we go
09:01:25 <Jeanne-Kamikaze> I am saving all of this so that I can meditate about it, thanks
09:01:29 <silver> hm
09:02:43 <quicksilver> I'm not sure that tower is right
09:02:51 <applicative> Eelis: suppose you know that x <+> y = y <+> x and that if x = y then x <+> z = y <+> z  ; you will then know as you did in school x <+> y <+> z = y <+> x <+> z
09:03:03 <quicksilver> classes as used in existential types are just quantified-over dictionaries
09:03:08 <quicksilver> and you can quantify over them fine
09:03:29 <applicative> Eelis, you know the last by knowing the others, but if you try writing it with quantifiers, first all understanding is lost; second, you use this kind of reasoning in the middle anyway.
09:03:40 <Eelis> applicative: 17:06:35 <Eelis> applicative: *shrug* whatever.
09:04:20 <applicative> Eelis, you are putting down the a -> a of ML and Haskell, but you're just lying that's all
09:04:27 <Eelis> lol
09:05:05 <rwbarton> I lol'ed also.
09:05:52 <kirindave> Someone, tell me there is something out there better than cmdArgs. :(
09:06:31 <applicative> what's wrong with it, I was thinking of using it just now....
09:06:42 <elliott_> applicative: your argument is not particularly compelling; at worst, forall is some syntactic noise, not some major impediment to true understanding...
09:07:32 <applicative> elliott_ I concede I haven't taken up enough space to compel your agreement.  :)
09:07:46 <elliott_> heh
09:08:09 <erus`> what was the name of the haskell in java implementation?
09:08:41 <hpc> erus`: jaskell, and it was a different language
09:08:45 <applicative> erus` there was the strangely Frege recently and other before
09:08:54 <applicative> others before
09:10:18 <erus`> ah frege
09:10:23 <kirindave> applicative, just... look at the api
09:10:45 <kirindave> applicative, for example, what if you want to use the "modes" function but not define all your modes in one place.
09:10:54 <kirindave> Like for an application that is extensible.
09:10:57 <kirindave> Cannot.
09:11:19 <kirindave> Or at least ,I couldn't find a way to make the types match up, that's for sure.
09:11:53 <applicative> kirindave: I just remember using it once, just because the examples file was very clear.  Everyone complained about unsafePerformIO, probably rightly, instead of praising the documentation...
09:12:35 <kirindave> Its documentation is fine
09:12:47 <kirindave> It's more that it... I dunno what design goals it had
09:12:54 <kirindave> Its Implicit mode is almost trying to be too cute.
09:13:04 <kirindave> At some point template haskell makes more sense.
09:14:36 <applicative> everyone's using it, it must be good http://81.26.216.99/~roel/cgi-bin/hackage-scripts/revdeps/cmdargs-0.8#direct or maybe that's not a good argument
09:15:18 <kmc> cmdargs is nice
09:15:26 <kmc> i've used it a few times with no complaints
09:15:27 <quicksilver> applicative: the unsafePerformIO just made we wonder what the author had been smoking
09:15:32 <quicksilver> which reduced my confidence in the package as a whole
09:15:35 <quicksilver> I'm sure it's fine though
09:15:42 <HaskellElephant> Does anyone else hear the music from the duel scene in The good, The bad and The ugly  (The Trio) when starting ghci :trace?
09:16:04 <quicksilver> I actually quite liked the baroque but powerful System.Console.GetOpt anyway
09:16:24 <applicative> quicksilver didn't he take care of that objection somehow?  I haven't used since when it was fairly new  I think.
09:17:55 <quicksilver> applicative: dunno, I only follow it by the echoes in this channel :)
09:18:27 <applicative> quicksilver, I see he wrote a post "CmdArgs is not dangerous" http://neilmitchell.blogspot.com/2011/05/cmdargs-is-not-dangerous.html
09:18:51 <mkscrg> ok, so i'm trying to understand type families
09:18:54 * applicative is shaking in his boots
09:19:05 <mkscrg> specifically the idea of type synonym families as type functions
09:19:35 <mkscrg> can i write a type function that turns (a,b) into ([a],[b]) for any length of tuple?
09:19:56 <mkscrg> (i see how to do it for specific lengths)
09:20:48 <quicksilver> that is not a problem that type families attempts to solve, mkscrg
09:21:01 <flux> mkscrg, mayeb you can, if you can figure out the type the function should have ;)
09:21:02 <quicksilver> it can express it but you still write every instance by hand.
09:21:17 <quicksilver> type families are type functions which you write "pointwise"
09:23:17 <mkscrg> quicksilver: i see. is there a different haskell extension that attempts to solve this problem?
09:23:50 <quicksilver> there are various.
09:24:08 <quicksilver> template haskell possibly. Or Generics for a more consistent approach maybe.
09:24:13 * hackagebot simpleprelude 1.0.1.3 - A simplified Haskell prelude for teaching  http://hackage.haskell.org/package/simpleprelude-1.0.1.3 (JeanMarieGaillourdet)
09:24:28 <quicksilver> Generics can sometimes enable you to write those "pointwise" instances all in one go
09:24:32 <quicksilver> by induction over the structure of types.
09:24:41 <quicksilver> I've not used it though.
09:24:45 <quicksilver> it's new.
09:25:08 <mkscrg> quicksilver: thanks, i'll check it out.
09:31:08 <quicksilver> applicative: he doesn't seem to see the point
09:31:19 <quicksilver> applicative: which is that "impure tricks give us syntax which doesn't make sense any more"
09:31:36 <quicksilver> you try to break down his impure example and you can't work out how it could type-check and still do something useful
09:31:41 <quicksilver> because, of course it can't.
09:31:55 <quicksilver> this makes it pretty unhelpful for people trying to establish their haskell intuition
09:32:09 <quicksilver> or trying to (as I often do) understand code in an unknown library by following the type signatures
09:37:39 <applicative> quicksilver, yes, this is difficult, maybe I will try to use cmdargs for the trivial purpose I was thinking of, just so I can figure out what's up
09:38:07 <quicksilver> applicative: At some level it doesn't matter. It works, ndm's tests are presumably thorough, it's fine.
09:38:17 <quicksilver> but I hate stuff not being first-class - you can't abstract it, make it higher order, etc.
09:38:33 <quicksilver> the reason I *use* haskell is because of the consistent syntax and abstraction power.
09:39:19 <applicative> haha, "You used unsafePerformIO, you got what you deserved. – augustss May 7 at 18:43"
09:39:33 <applicative> http://stackoverflow.com/questions/5920200/how-to-prevent-common-sub-expression-elimination-cse-with-ghc
09:41:25 <applicative> quicksilver: then when ndm figures out how to outwit ghc, he gets "It works now, but maybe it won't work in the next version. – augustss May 7 at 18:45"
09:41:45 * quicksilver nods
09:42:00 <quicksilver> and an hour later "The answer is not to use unsafePerformIO. The way you are using it is wrong, because what you are doing is not implementing an pure function in an impure way. You are actually using the side effects. That's not what Haskell is for"
09:42:20 <quicksilver> unfortunately, augustss finally caved 6 minutes later
09:42:28 <quicksilver> "Neil's use of unsafePerformIO is actually rather clever and not at all performance critical (command line argument decoding). I don't know of any way to do it quite as conveniently as it is with unsafePerformIO. But I'm willing to pay a price in inconvenience for purity."
09:43:24 <applicative> well, that was well-spirited of him.
09:43:51 * applicative is secretly inclined to use the unsafe version, even though the 'price' of purity in his case will be nil. 
09:44:56 <quicksilver> applicative: isn't augustss actually ndm's boss, or something?
09:45:57 <applicative> oh, I don't know.
09:46:11 <kmc> UNDERCOVER BOSS
09:48:24 <kowey> I wonder what folks here would make of cmdlib
09:49:07 <kowey> which I understand to have been written partly as a reaction to the above
09:49:20 <mkscrg> quicksilver: when you say generics do you mean the separate language/compiler that they wrote at utrecht, or is this integrated into ghc now?
09:49:59 <quicksilver> mkscrg: unfortunately there have been 47 haskell features which used the name 'generics'
09:50:08 <quicksilver> over the last 20-odd years
09:50:11 <quicksilver> I should have been more precise
09:50:47 <monochrom> to some extent, parameteric polymorphic is a genericity
09:51:24 <mkscrg> quicksilver: ah, no problem. were you referring to a specific one?
09:51:28 <monochrom> afterall, that's what "java generics" means
09:51:43 <troydm> can any1 explain me what's wrong with this http://pastebin.com/wdpcRadD ?
09:51:44 <quicksilver> mkscrg: yes
09:51:45 <mauke> The paste wdpcRadD has been copied to http://hpaste.org/53565
09:51:51 <quicksilver> mkscrg: I'm trying to find the right link
09:52:23 <quicksilver> mkscrg: this one! http://www.haskell.org/haskellwiki/Generics
09:52:57 <quicksilver> monochrom: yeah, although I think in our end of the field generics generally means something which works by induction over the structure of types.
09:53:32 <mkscrg> quicksilver: excellent! thanks again
09:53:46 <monochrom> yeah, we have higher bars.
09:53:50 <quicksilver> (if you want the other 47, most of them are listed at http://haskell.org/haskellwiki/Research_papers/Generics or http://www.haskell.org/haskellwiki/Libraries_and_tools/Generic_programming ; neither of which pages seems to mention the newest one. But I meant the newest one)
09:54:03 <monochrom> "you call id::a->a generic? bwahahahaha"
09:54:29 <quicksilver> wikis suck.
09:55:20 <dylex> troydm: do is only used for monads, but your function (as written) isn't monadic.  you'll want to use let or where i = ord x ... instead.
09:56:36 <dylex> troydm: (that whole function can also be written "map ord")
09:57:27 <quicksilver> or in caleskell, just (ord.)
09:57:29 <quicksilver> ;)
09:57:32 <applicative> kowey, I see, maybe I will try cmdlib, it seems more intelligible anyway
09:58:19 <monochrom> > do True
09:58:20 <lambdabot>   True
09:58:36 <monochrom> that's the only corner case where "do" does not need Monad :)
09:59:00 <elliott_> monochrom: I hate that :(
09:59:06 <elliott_> it should force monadicosity
10:00:30 <kirindave> cmdlib
10:00:34 <kirindave> Oh this looks better.
10:01:51 <monochrom> in fact I am totally uncertain whether Haskell 2010 allows it or it is a GHC simplification
10:02:15 <Saizan> it used to force (m a)'ity in earlier ghcs
10:02:39 <kirindave> Yeah, cmdlib has Command typeclass as opposed to trying to dig into data objects
10:02:50 <kirindave> Way better.
10:03:34 <hpaste> applicative annotated “pastebin.com/wdpcRadD” with “pastebin.com/wdpcRadD (annotation)” at http://hpaste.org/53565#a53566
10:04:07 <applicative> troydm: ^^^ is what you mean, no?
10:04:45 <applicative> troydm, the form messed with my indentation somehow.
10:06:24 <troydm> applicative: what do you means/
10:06:38 <troydm> i'm reading book Programming in Haskell
10:07:08 <troydm> and in chapter 8 (writing a parser) there are a lot of references to f = do
10:07:24 <troydm> however the concept of monad is not introduced
10:07:27 <applicative> troydm, you don't have use for do notation there, I was thinking you were using "a <- blah" to mean: let a = blah
10:08:02 <troydm> applicative: i don't quite understand that, i've just copyed the code from that book
10:08:03 <applicative> troydm, yes, he uses parsers to get somethings on the table before springing the monad concept on you
10:09:19 <troydm> applicative: this f function doesn't compile saying that Couldn't match type [t0] with Int
10:10:03 <cheater_> hey anyone know a link for the zippers paper?
10:10:06 <cheater_> i think by conal
10:10:07 <applicative> troydm, yes, the rest of the context entails that you are 'in the list monad', which means that ord i should be  list
10:11:02 <troydm> applicative: i don't quite understand, can you write the version that will compile so i can read the source and understand
10:11:04 <applicative> troydm: a <- blah ; ... in the case of lists means something like "draw an item from the list blah, call it a; ...."
10:12:00 <troydm> applicative: ohhh like in comprehensions of generators
10:12:05 <troydm> applicative: now i understand
10:12:57 <troydm> applicative: thx
10:14:35 <hpaste> applicative annotated “pastebin.com/wdpcRadD” with “pastebin.com/wdpcRadD (annotation) (annotation)” at http://hpaste.org/53565#a53568
10:14:55 <applicative> troydm: here's a list related use of do notation ^^^
10:15:41 <troydm> applicative: thx i understand now
10:19:25 <bartavelle> this must be obvious, but how do you handle multi line comments with alex ?
10:22:19 <tac-tics> Is there a name for the function \f x y -> do { arg1 <- x; arg2 <- y; f arg1 arg2 }
10:22:38 <tac-tics> @let myFunc f x y = do { arg1 <- x; arg2 <- y; f arg1 arg2 }
10:22:39 <lambdabot>  Defined.
10:22:42 <tac-tics> @type myFunc
10:22:43 <lambdabot> forall t t1 (m :: * -> *) b. (Monad m) => (t -> t1 -> m b) -> m t -> m t1 -> m b
10:23:04 <ben> @pl \f x y -> x >>= \arg1 -> y >>= \arg2 -> f arg1 arg2
10:23:04 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
10:23:07 <ben> hmm...
10:23:27 <tac-tics> @pl myFunc
10:23:27 <lambdabot> myFunc
10:23:33 <tac-tics> Convenient :P
10:24:00 <quicksilver> tac-tics: join $ liftM2 f x y ?
10:24:15 <ben> Isn't it simply liftM2
10:24:24 <quicksilver> no it's missing a return
10:24:32 <bfig> @pl myFunc
10:24:32 <lambdabot> myFunc
10:24:35 <ben> Oh, indeed
10:24:58 <applicative> join (liftM2 x y)
10:25:07 <shachaf> Should be called bind2 or something like that.
10:25:17 <bfig> @pl f x y = do { a1 <- x; a2 <- y; f a1 a2}
10:25:17 <lambdabot> (line 1, column 12):
10:25:17 <lambdabot> unexpected "{"
10:25:18 <lambdabot> expecting variable, "(", operator or end of input
10:25:18 <ben> Maybe it's some variation on ap
10:25:31 <tac-tics> quicksilver: thanks
10:25:31 <bfig> @pl f x y = do { a1 <- x; a2 <- y; f a1 a2 }
10:25:31 <lambdabot> (line 1, column 12):
10:25:31 <lambdabot> unexpected "{"
10:25:32 <lambdabot> expecting variable, "(", operator or end of input
10:26:07 <quicksilver> ben: well, it's also f `ap` return x `ap` return y
10:26:29 <quicksilver> no it's not
10:26:41 <quicksilver> yes, you can mess around with ap and return
10:26:54 <quicksilver> but you can't do substantially better than join $ liftM2
10:27:04 <ben> Yeah, I suppose
10:27:06 <shachaf> It does the opposite of return.
10:27:27 <shachaf> (I.e., unsafePerformIO. :-) )
10:27:37 <quicksilver> ben: (a -> b), (a -> m b) and (m a -> m b) are three different types
10:27:50 <quicksilver> this is at the route of the clumsiness somehow.
10:27:53 <quicksilver> root.
10:28:01 <shachaf> It's also pretty important.
10:28:06 <quicksilver> well sure :)
10:28:11 <quicksilver> it's important and for good reason
10:28:19 <quicksilver> but it's why the combinators "aren't quite right"
10:28:33 <quicksilver> SHE has sugar for invoking join, I htink
10:29:13 <kmc> shachaf, you and your lies
10:29:20 <shachaf> kmc: What did I say this time?
10:29:27 <kmc> join = unsafePerformIO
10:29:31 <kmc> fwiw for some monads it's much easier to implement 'join' than (>>=)
10:29:34 <kmc> like the CPS'd IO monad
10:29:40 <kmc> shachaf, did I learn about that one from you?
10:29:56 <ben> I actually misremembered what ap did :(
10:29:57 <danr> ouch, what is join liftM2 really?
10:30:01 <shachaf> Oh. No, I said it was conceptually the opposite of return, and then jokingly added that that must be unsafePerformIO.
10:30:11 <shachaf> kmc: About what one?
10:30:17 <kmc> what is "what is really?", really?
10:30:25 <kmc> :t \f x y -> join $ liftM2 f x y
10:30:26 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:30:30 <ben> kmc: fix (what is . really)
10:30:41 <shachaf> Do you mean the thing that came up in the context of talking about tamejs?
10:30:46 <kmc> shachaf, data IO t = PutChar Char (IO t) | GetChar (Char -> IO t) | Return t
10:30:52 <shachaf> Oh.
10:31:03 <shachaf> Possibly, but it's a pretty standard definition.
10:31:12 <kmc> *nod*
10:31:24 <kmc> i found writing (>>=) for this type to be quite confusing, and join quite straightforward
10:31:34 <shachaf> kmc: http://r6.ca/blog/20110520T220201Z.html
10:31:52 <shachaf> It's not really a "real" monad, just a convenient one.
10:32:29 * shachaf must >>=
10:32:35 <MostAwesomeDude> Hm. My coworker has a curious question: If you have a computationally expensive but totally reducible expression in Haskell, does it resolve at compile time?
10:32:51 <kmc> the spec says nothing about compile time
10:32:59 <shachaf> kmc: (By the way, all implementations of IO are CPSed just as much as that one. This just makes it explicit.)
10:33:19 <danr> kmc: aha, i was looking for the type signature of join liftM2
10:33:22 <erikc> anyone know when the next haskell platform update is gonna be?
10:33:22 <danr> @type join liftM2
10:33:23 <lambdabot> forall a2 r. ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
10:33:28 <danr> a little more confusing
10:33:59 <quicksilver> danr: that's not what I said though
10:34:02 <MostAwesomeDude> kmc: But, practically, what happens? Does the compiler make a judgement call?
10:34:06 <quicksilver> I said join $ liftM2 f x y
10:34:15 <quicksilver> @type \f x y -> join $ liftM2 f x y
10:34:16 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
10:34:22 <parcs> is there an implementation of rose trees on hackage?
10:34:22 <quicksilver> quite different from join liftM2
10:34:33 <kmc> MostAwesomeDude, I think GHC will do constant folding.  I'm not sure what the limitations are
10:34:43 <kmc> MostAwesomeDude, if you want to force evaluation to happen at compile time, you can use Template Haskell
10:35:03 <quicksilver> MostAwesomeDude: the practical answer is "No."
10:35:18 <quicksilver> GHC does very limited constant folding. Just simple numeric expressions.
10:35:21 <kmc> parcs, Data.Tree in 'containers'
10:35:23 <MostAwesomeDude> kmc: No, it was a thought experiment. If I had a problem that calculated the answer to Life, the Universe, and Everything, would the calculation be dominated by compile time, or run time?
10:35:34 <MostAwesomeDude> !s/problem/expression/g
10:36:05 <parcs> kmc: oh cool
10:37:07 <erus`> data Maybe (a :: *) :: *     does that mean maybe is a * ? I thought it was a * -> * ?
10:37:21 <bfig> MostAwesomeDude, irrelevant question since you can program in compilation time
10:37:42 <kmc> erus`, it means (Maybe a) is *
10:37:46 <applicative> erus` isn't that saying
10:37:50 <applicative> like kmc said
10:37:53 <bfig> (using dependent types)
10:38:04 <kmc> if I say (f 3 :: Int) it means f :: Int -> Int or so
10:38:25 <erus`> ah ok that makes more sense :)
10:38:26 <applicative> erus` its saying that, and that the 'argument' a must be of kind * so Maybe alone is * -> *
10:40:20 <applicative> erus` in data Maybe (a :: *) :: *  the kinds are marked like the types in primitive types systems, int foo(int bar) instead of foo:: Int -> Int
10:41:05 <applicative> I mean, where you mark the types (here kinds) of the argument and result types, instead of making an independent signature with -> .
10:43:42 <tac-tics> > 1 + 1
10:43:43 <lambdabot>   2
10:46:28 <mdxbhmt> >let 1+1=3 in 1+1
10:46:31 <mdxbhmt> > let 1+1=3 in 1+1
10:46:32 <lambdabot>   3
10:46:57 <mdxbhmt> > let 1+1=3 in 1+2
10:46:58 <lambdabot>   *Exception: <interactive>:3:4-8: Non-exhaustive patterns in function +
10:53:14 <applicative> > let 1 + 1 = 3; _ + _ = 4 in (1 + 1 , 1 + 2)
10:53:15 <lambdabot>   (3,4)
10:53:45 <applicative> > let 1 + 1 = 3; _ + _ = 4 in map (1+) [0..10]
10:53:46 <lambdabot>   [4,3,4,4,4,4,4,4,4,4,4]
10:54:21 <simon> how do I find out which has the highest precedence of <|> and >>=?
10:54:30 <kmc> use :i in ghci
10:54:46 <mdxbhmt> > :i <|>
10:54:47 <lambdabot>   <no location info>: parse error on input `:'
10:54:58 <mdxbhmt> ;(
10:55:18 <simon> thanks, kmc.
10:57:15 <Saizan> Katy B - Easy Please Me
10:57:15 <Saizan> vaiduti5  10 videos   Subscribe
10:57:36 <simon> okay, Saizan.
10:58:28 <applicative> infixl 3 <|> infixl 1 >>=
10:59:17 <applicative> > [1,2,3] <|> [10] >>= show
10:59:18 <lambdabot>   "12310"
10:59:49 <Aune> :t <|>
10:59:50 <lambdabot> parse error on input `<|>'
10:59:58 <Aune> :t (<|>)
10:59:59 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:01:30 <erus`> whats the weird v in agda?
11:02:04 <erus`> ∀
11:02:23 <siracusa> forall?
11:02:28 <Cale> That's an upside-down A
11:02:38 <Cale> and yeah, it means "for all"
11:03:33 <Cale> It's a standard symbol used in logic to quantify variables, along with a backwards E for "there exists"
11:04:44 <kmc> H∀LFLIF∃
11:05:30 <Cale> For a mathematical example, ∀x. ∃y. x < y is read as "for all x, there exists a y such that x is less than y"
11:06:04 <monochrom> "for all" means that someone makes a choice, and it can be ANY choice. "there exists" means that someone makes a choice, and it can be ANY choice.
11:06:12 <Cale> heh
11:06:28 <applicative> For an unmathematical example, ∀x : boy. ∃y:girl. x loves y is read as "Every boy loves some girl"
11:06:35 <Cale> "for all" means that the falsifier makes the choice, "exists" means the verifier does.
11:06:42 <monochrom> after reading that, you should realize that the distinct is not in the "any" part, but in the "someone" part.
11:06:56 <monochrom> s/distinct/distinction/
11:07:54 <monochrom> I say this because traditional math texts emphasize on the "any" aspect and completely neglects to explain who is the "someone".
11:08:59 <monochrom> hrm, how come I failed to deop myself?
11:09:02 --- mode: monochrom set -o monochrom
11:09:30 <applicative> is that why you had a @ next to your name?
11:09:35 <monochrom> yes
11:10:18 <applicative> at first I thought lambdabot was accepting an esoteric new command
11:10:19 <bscarlet> monochrom: It seems kind of odd to bring roles / multiple actors into explaining such an abstract concept.
11:10:30 <applicative> @monochrom fmap
11:10:30 <lambdabot> Unknown command, try @list
11:10:40 <monochrom> haha
11:10:54 <monochrom> it is all that abstract?
11:11:54 <bscarlet> it certainly doesn't rely on much built up structure that might otherwise tie it to any specifics.
11:15:23 <dgpratt> Cale: what is the falsifier, and what is the verifier?
11:15:53 <byorgey> dgpratt: think of a type as a claim that you possess a value of that type
11:16:08 <dgpratt> byorgey: ok
11:16:12 <monochrom> the most abstract and fundamental meaning of the quantifiers is in the inference rules. for example ∀-introduction and ∀-elimination, etc. you could stick to that level if you want.
11:16:15 <Cale> dgpratt: You can imagine every logical statement as being like a game played between two players. The verifier is trying to make the statement true, and the falsifier is trying to make it false.
11:16:39 <dgpratt> Cale: hmm; interesting
11:16:51 <Cale> Whenever you have a "for all" quantifier, the falsifier gets to pick the value of the variable. Whenever you have an "exists", the verifier does.
11:17:10 <monochrom> but as soon as a person starts using those rules, we have two actors: an author who writes a proof using the rules, and a checker looking for mistakes in that proof using the rules.
11:17:14 <dgpratt> Cale: ah, I think I get it
11:17:15 <Cale> The statement is true if the verifier has a winning strategy for the game, and false if the falsifier does.
11:17:59 <dgpratt> makes sense
11:18:03 <monochrom> it is also equivalent to what happens to a computer program: there is an author of the program, and there is a user of the program.
11:18:16 <Cale> and they take turns in the order that the quantifiers occur from left to right
11:19:03 <dgpratt> funny, I was reading someone's blog post the other day (a Haskell blogger) and they had these two characters, I think that's what they were supposed to represent
11:19:25 <monochrom> suppose a program's type is ∀t. t->t. The user chooses what t becomes. The author must be prepared for any choice made.
11:19:49 <Cale> indeed!
11:20:01 <byorgey> dgpratt: was it http://blog.ezyang.com/2011/09/lets-play-a-game/  ?
11:20:07 <monochrom> conversely, suppose a program's type is ∃t. Show t => t. The author chooses what t becomes. The user must be prepared for any choice made.
11:20:17 <dgpratt> byorgey: yes!
11:20:29 <byorgey> dgpratt: then yes, that's exactly what those characters represented
11:20:35 <tac-tics> Cale: When you say "winning strategy", does that mean you could have a proof system with infinitely nest proofs?
11:20:37 <dgpratt> byorgey: oh, cool
11:20:47 <tac-tics> I guess that'd be something like induction....
11:20:57 <Cale> tac-tics: Some people study such things.
11:21:00 <byorgey> dgpratt: note that he was using different terminology than Cale.
11:21:07 <dgpratt> byorgey: noted
11:21:15 <monochrom> programming is always at least a two-person game. you can't go more abstract than that. you can't abstract away the two players.
11:21:22 <byorgey> dgpratt: he used "proposer" for what Cale called "verifier" and, confusingly, "verifier" for what Cale called "calsifier"
11:21:28 <byorgey> *falsifier
11:21:49 <monochrom> then by drinking the curry-howard koolaid wholesale, logic is at least a two-person game too, and you can't abstract the two players away either.
11:21:51 <shachaf> Calesifier.
11:21:52 <dgpratt> byorgey: I see; I think I'll have to re-read that post soon
11:22:04 <byorgey> tac-tics: general recursion means that you define "winning strategy" to mean "non-losing strategy"
11:22:16 <byorgey> tac-tics: as opposed to "winning in a finite amount of time"
11:22:36 <Cale> There are game-theoretic generalisations of the quantifiers as well. http://planetmath.org/encyclopedia/GameTheoreticQuantifier.html
11:23:44 <tac-tics> byorgey: sounds like LEM to me.
11:24:04 <Cale> (also http://en.wikipedia.org/wiki/Branching_quantifier)
11:24:24 <tac-tics> I always found that epsilon delta definitions were a good introduction to quantifiers, in that they form the simplest non-trivial example that is hard for students :3
11:24:27 <byorgey> tac-tics: not really.  But LEM does come into game-theoretic semantics in interesting ways.
11:24:27 <monochrom> you could insist on terminating recursion. then a winning strategy is required to win in finite time.
11:24:42 <Cale> So you can just partially order a bunch of quantifiers, specifying what choices are allowed to depend on which others.
11:24:57 <bscarlet> monochrom: I guess I see what you mean, but it still feels odd to wind up with such an operational notion of what logic means.
11:25:44 <monochrom> the natural deduction rules are pretty computational and operational too.
11:30:38 <monochrom> I believe that ε-δ limit is hard for students precisely because they are not given a proper introduction to quantifiers first.
11:31:04 <tac-tics> for sure
11:31:29 <tac-tics> It's even worse because almost every book I've ever read with an ep-delta definition....
11:31:32 <tac-tics> uses only two quantifiers
11:31:41 <tac-tics> when most implicitly use three
11:32:13 <tac-tics> for all e, exists d. forall x . blah blah blah
11:32:16 <monochrom> In fact similarly induction. (∀n. P n → P (n+1)) is not ((∀n. P n) → (∀ n. P (n+1)). you're doing the former. students think you mean the latter. therefore students think you're doing circular logic.
11:32:26 <tac-tics> There's also that logical implication in there too, which students tend to suck at
11:32:36 <tac-tics> monochrom: yeah
11:33:35 <mdempsky> so many nerds in here
11:33:49 <tac-tics> It's hard, though, because you go through your entire K-12 education without learning about the scope of variables.
11:34:37 <monochrom> I finally knew scope of variables when I learned Pascal.
11:34:39 <copumpkin> mdempsky: a profound observation
11:35:42 <bscarlet> #haskell :: m Nerd
11:35:46 <monochrom> and yes, henceforth, all those quantified statements suddenly became crystal clear. (I had vague understanding, but crystal-clear is certainly welcome.)
11:35:46 <bscarlet> ?
11:35:47 <Cale> Speaking of games, here's a cute proof of the uncountability of the interval [0,1]. Let S, a subset of [0,1] be given. Two players, Left and Right, play a game, alternately picking numbers in (0,1). Left plays first, picking a number 0 < a_1 < 1 and then Right plays, picking a number a_1 < b_1 < 1. On subsequent moves, the players must pick a number between the two most recent choices, so if a_0 = 0 and b_0 = 1, we hav
11:35:47 <Cale> e a_(n-1) < a_n < b_(n-1) and a_n < b_n < b_(n-1) for all n > 0.
11:36:00 <mrothe> What is the solution for Ambiguous module name `Prelude': it was found in multiple packages: base haskell98-2.0.0.0?
11:36:21 <mrothe> besides ghc-pkg hide haskell98
11:36:30 <tac-tics> monochrom: for me, it was learning a bit of Coq. Those foralls are just functions :D
11:36:31 <monochrom> depends on why you run into it.
11:36:44 <Cale> Since a monotone increasing sequence {a_n} which is bounded above has a limit a = lim n -> inf of a_n, the players determine from an infinite sequence of such plays a real number in [0,1]
11:36:58 <mrothe> monochrom: building haskell-src 1.0.1.4
11:37:02 <tac-tics> And variables introduced with forall or exists are just like any other variable, except they don't have definitions.
11:37:09 <Cale> We'll say that Left wins the game if a is in S, and Right does if it isn't.
11:37:30 <tac-tics> "For all n, blah" means "n is an integer. And no, you don't get to ask which integer it is"
11:37:54 <Cale> Now, if S is countable, then Right has a winning strategy here.
11:39:16 <byorgey> mrothe: ah, yes, I've run into that one too, sadly, ghc-pkg hide haskell98 does not work because it explicitly requires the haskell98 package.
11:39:24 <Cale> If S = {s_1,s_2,...} then for n >= 1, Right will choose b_n = s_n if possible. Otherwise, Right plays any legal move randomly.
11:39:32 <byorgey> in fact, the haskell98 package ought to be hidden by default anyway.
11:39:38 <monochrom> haskell98-2.0.0.0 means you're at GHC 7.2.1? perhaps haskell-src 1.0.1.4 is not meant to be buildable there.
11:40:12 <monochrom> in fact, even the Haskell Platform people are only going for GHC 7.0.4 for now (later this month)
11:40:55 <mrothe> byorgey: so the solution would be to not depend on haskell98 in haskell-src?
11:41:08 <Cale> Because of this strategy, for all n we have that either s_n <= a_n, or s_n >= b_n, and since the limit of our game x lies somewhere a_n < x < b_n, this means x can't be s_n for each n, and so x can't be in S.
11:41:22 <luite_> mrothe: many packages need to be updated, best solution is probably to remvoe the haskell98 dependency, update imports (IO to System.IO etc) and send a patch to the maintainer
11:41:25 <byorgey> mrothe: yes, but the reason it does is because happy generates some code which imports Array, which is the haskell98 name for the Data.Array module
11:41:34 <DanBurton> What's the ETA on Haskell Platform with GHC 7.4?
11:41:36 <Cale> Now if S = [0,1], Left obviously always wins.
11:41:40 <Cale> So [0,1] is uncountable
11:41:42 <byorgey> so it's a few levels more annoyingly removed from the obvious solution
11:41:56 <byorgey> DanBurton: the next HP release will not be with 7.4
11:42:09 <DanBurton> byorgey: what about the one after that? :)
11:42:15 <byorgey> DanBurton: probably.
11:42:33 <dgpratt> byorgey: I want to make sure I understand what he is talking about with the "cloud of abstraction" stuff in that article...
11:42:47 <mrothe> luite_: thanks. so it's base we want to check on and if it's <'something' we need to depend on haskell98?
11:42:48 <dgpratt> he makes an example of this type: ((b -> a) -> c) -> a -> c
11:43:21 <dgpratt> so I gather that the proposer first realizes that he's gonna need (b -> a)
11:43:22 <mrothe> byorgey: Is Array or Data.Array 'the way to go'?
11:43:33 <byorgey> mrothe: Data.Array
11:43:37 <mrothe> k
11:43:40 <luite_> mrothe: I think base should be enough for any recent ghc, but you need to change the old-style package imports
11:43:51 <luite_> mrothe: usually it's only a few lines
11:43:56 <cacodaemon> :i 1
11:44:01 <dgpratt> so he claims that he can 'invent' (b -> a)
11:44:13 <cacodaemon> :t 1
11:44:14 <lambdabot> forall t. (Num t) => t
11:44:14 <mrothe> luite_, byorgey: thanks. I think I get it.
11:44:26 <cacodaemon> :t forkIO
11:44:27 <lambdabot> Not in scope: `forkIO'
11:44:34 <DanBurton> @hoogle forkIO
11:44:35 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
11:44:35 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
11:44:35 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
11:44:41 <cacodaemon> thanks :)
11:44:42 <dgpratt> which obligates the 'verifier' to furnish a 'b'
11:45:17 <dgpratt> and the proposer takes that and the 'a' he already has and makes (b -> a) (all in the 'cloud of abstraction')
11:46:07 <dgpratt> then he uses the (b -> a) along with ((b -> a) -> c) to make the goal 'c'
11:46:15 <dgpratt> is that about right?
11:46:19 <tac-tics> dgpratt: the "cloud of abstraction" just means that you are assuming that some other variables have been brought into scope for you.
11:46:35 <tac-tics> For example, at the top level, a variable "x" does not exist and has no type.
11:46:41 <tac-tics> But in the expression (\x -> .....)
11:46:41 <byorgey> dgpratt: sounds right.
11:46:48 <tac-tics> where the ..... is, x exists
11:46:56 <cacodaemon> @hoogle mapM_
11:46:56 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:46:57 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
11:46:57 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
11:47:08 <cacodaemon> @hoogle forM_
11:47:08 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
11:47:08 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
11:47:24 <mrothe> A small follow up question: how do I know that the culprit is Array? The error message mentiones Prelude...
11:48:06 <DanBurton> is this an issue with haskell98 non-hierarchical modules?
11:49:12 <byorgey> mrothe: you know the culprit is Array because of the comment in the haskell-src.cabal file ;)
11:49:14 <tac-tics> dgpratt: It's called the cloud of abstraction, because certain variables might come into scope with impossible-to-instantiate types. But that's not a problem, because if those types are impossible to instantiate, then the function can't ever be called.
11:49:18 <monochrom> in GHC 7.0.x, base provides Prelude, haskell98 doesn't. in GHC 7.2.x, both provide Prelude
11:50:08 <byorgey> mrothe: or because of the error you would get if you tried removing the haskell98 dependency from the haskell-src.cabal file
11:50:10 <mrothe> byorgey: haha.. okay :-)
11:50:20 <monochrom> the change is presumably to let you do this: if you want to write a Haskell 98 program, you can undepend on base, just grab haskell98 and be done.
11:51:24 <dgpratt> tac-tics: I see, thanks
11:52:27 <mrothe> monochrom: thanks. that makes sense.
11:54:25 <byorgey> dgpratt: consider this type:   ((a -> b) -> c) -> a.  Can it be implemented?
11:55:40 <dgpratt> byorgey: I have to run away for a bit, be back soon
11:56:04 <byorgey> dgpratt: ok, I'm about to head home, we can continue some other day if you want
11:56:23 <tac-tics> @djinn ((a -> b) -> c)->a
11:56:23 <lambdabot> -- f cannot be realized.
11:56:29 * Cale wonders if anyone followed his proof of the uncountability of the reals :)
11:56:58 <tac-tics> Cale, I got up to about the point where you used the inf
11:57:10 <copumpkin> Cale: it's obviously false
11:57:21 <tac-tics> I think I'm missing just a small slice of brain that would let me be a mathematician
11:57:24 <Cale> I like this one for not relying on expansions in terms of digits
11:57:26 <copumpkin> Cale: cause if you put all the reals on a grid, with pi in the middle, then you count in a spiral outwards from pi
11:57:30 <copumpkin> Cale: then you can count all the reals
11:57:33 <Cale> copumpkin: heh
11:58:26 <Cale> copumpkin: That seems vaguely reminiscent of a rather misguided attempt at counting the reals that I'd seen before
11:58:35 <byorgey> maybe  ((a -> Int) -> Int) -> a  is a better exampl
11:58:37 <byorgey> *example
11:59:25 <Cale> "Can you recover an arbitrary value given a program which answers Int-valued questions about it?"
11:59:27 * byorgey has been counting the reals since July 1994, and is now up to 405,207,583
11:59:57 <Cale> byorgey: Integers first?
12:00:08 <byorgey> just whatever order I feel like
12:00:34 <byorgey> I'm slowing down since checking to make sure I haven't already counted each number before takes longer each time ;)
12:00:59 <cacodaemon> reals or real representations in ieee-754?
12:01:13 <tac-tics> byorgey: Try using a hash-set. It has O(1) membership testing ;)
12:01:31 <byorgey> tac-tics: lies!
12:01:42 <monochrom> use python to count all reals in O(1) time.
12:01:59 <Cale> tac-tics: If you got lost about the property of monotone increasing, bounded sequences of reals having a limit, then the chunk of your brain which is missing will be filled in by obtaining a copy of Spivak's "Calculus", which is an introduction to analysis (and a lovely introduction to mathematics proper) disguised as a first year calculus textbook :)
12:02:04 <monochrom> w00t! oleg can count all reals in O(1) time --- at the type level!
12:02:23 <cacodaemon> :)
12:02:28 <Cale> I highly recommend it
12:02:51 <tac-tics> Cale: I do love analysis. I'm just not especially adept at it.
12:03:12 <Cale> In fact, I have a pdf of it if anyone wants to participate in some book piracy
12:03:19 <Aune> Cale, tac-tics, another good book on that subject is "Understanding analysis"
12:03:21 <copumpkin> Cale: yeah, I'm trying to find that blog post
12:03:25 <ben> I always thought calculus was the foreign word for analysis
12:03:37 <tac-tics> I hated calculus in high school because they never justified any of the integral or derivative mumbojumbo. But when I found out analysis was a real thing, I was a much more satisfied person.
12:04:08 <Cale> ben: It's usually considered to be the stuff supporting the computational aspects of differentiation and integration.
12:04:23 <mdempsky> tac-tics: I thought analysis was about complex things.
12:04:28 <sbi> never drink and derive
12:04:32 <Cale> The word "calculus" refers to a system of calculating something in general.
12:05:11 <Cale> http://cale.yi.org/share/Michael%20Spivak%20-%20Calculus.pdf
12:05:11 <tac-tics> I just remember driving my calc teacher nuts, because I spent the majority of my time not paying attention to what he was saying, and instead trying to figure out what the hell "dx" and "dy" really where
12:05:38 <tac-tics> Then, I realized the notation was all garbage, and that it's just there to "get the right answer" rather than be rigorously accurate.
12:05:53 <Cale> You can come up with definitions of dy and dx which make things work.
12:06:02 <tac-tics> yeah
12:06:06 <Cale> (there's more than one solution to the problem, even)
12:06:37 <tac-tics> I guess I'm not totally settled on infinitesimals either. I found an e-book once that did a decent job explaining them, with two exceptions.
12:06:50 <Cale> The most elementary answer is to simply treat dy and dx in a given context as arbitrary numbers such that dy = f'(x) dx
12:06:58 <tac-tics> The first is that it used a vague axiom that basically said "all operations that work on reals work obviously on infinitesimal/infinities"
12:07:27 <Cale> They don't even have to be infinitesimal, so long as they have the right proportion with each other.
12:07:45 <tac-tics> and the other issue was that I thought integrals were totally mishandled in the book, to the point that I didnt believe infinitesimals and infinites could explain integration.
12:08:07 <Cale> But yeah, once you get to integration, the answer has to get more subtle.
12:08:21 <tac-tics> Cale: what do you mean more subtle exactly? :)
12:08:37 <Cale> and "multiplication" on these dx and dy things has to work in an appropriate way, or you'll get garbage results
12:08:44 <tac-tics> I was always curious why things broke down for integrals.
12:09:08 <Cale> I mean http://en.wikipedia.org/wiki/Exterior_derivative
12:11:02 <Cale> (Spivak also wrote a much smaller, but more advanced book called "Calculus on Manifolds" which provides a nice introduction to that.)
12:11:26 <bscarlet> personally, I usually thought of it as if there were an implied set of limit_{dx->0} for various x around everything, which were left off for notational simplicity, usually to no effect.
12:12:13 <bscarlet> and that it's when there is an effect (such as when the order of the limits matters) that life gets really interesting.
12:12:15 <tac-tics> Cale: That wiki page is a little out of my league.
12:12:34 <Cale> yeah :|
12:12:45 <Cale> It's also not the clearest presentation to begin with
12:13:21 <tac-tics> Wikipedia is notoriously terrible for math articles.
12:13:40 <tac-tics> At least, anything outside of the highschool/early college cirriculum
12:13:41 <monochrom> guess who wrote those articles.
12:13:50 <cgroza> How can I avoud the scientifical notation for large numbers when using print?
12:13:50 <tac-tics> mathematicians? :P
12:13:59 <tac-tics> Or people who copied them from their professor's textbook?
12:14:01 <monochrom> yeah! especially lifeless math grad students
12:14:20 * hackagebot ghc-mtl 1.0.1.1 - An mtl compatible version of the Ghc-Api monads  and monad-transformers.  http://hackage.haskell.org/package/ghc-mtl-1.0.1.1 (DanielGorin)
12:14:53 <monochrom> over-enthusiastic about math, under-enthusiastic about what information should be given in what order
12:15:32 <Zamarok> hmm, I'm trying to use the -sstderr rts opt.. I keep getting "Most RTS options are disabled. Link with -rtsopts to enable them."
12:15:33 <Cale> But differential geometry has a huge notational problem atm
12:15:46 <Zamarok> I tried linking with -rtsopts already :/
12:16:07 <monochrom> erase the exe and link with -rtsopts again to be sure
12:16:18 <Cale> Even outside wikipedia, half of everything uses horrible notation, probably due to the influence of physicists. ;)
12:16:36 <Zamarok> monochrom: Done that many times.
12:17:12 <monochrom> check PATH etc, make sure you are not invoking some other exe of the same name somewhere elsewhere
12:17:51 <Zamarok> "which ./myApp" returns "./myApp"
12:18:09 <monochrom> then I don't know. can't reproduce anyway
12:19:21 * hackagebot hint 0.3.3.3 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.3 (DanielGorin)
12:19:28 <Zamarok> monochrom: I think I found the problem >_> I was trying to link with -with-rtsopts="myRTSopts" like some documentation told me to do.. apparently you only need the -rtsopts flag
12:35:21 <dgpratt> Cale: did you see the question byorgey posed to me before I ran off?
12:35:45 <Cale> dgpratt: no, what was it?
12:36:00 <dgpratt> byorgey: dgpratt: consider this type:   ((a -> b) -> c) -> a.  Can it be implemented?
12:36:03 <Cale> <byorgey> dgpratt: consider this type:   ((a -> b) -> c) -> a.  Can it be implemented?
12:36:06 <Cale> oh, right
12:36:08 <Cale> yeah
12:36:18 <dgpratt> I'm inclined to say "no"
12:36:22 <dgpratt> correct?
12:36:23 <Cale> You'd be right
12:36:35 <dgpratt> you are expected to produce an 'a'
12:36:57 <copumpkin> :t undefined :: ((a -> b) -> c) -> a
12:36:58 <lambdabot> forall a b c. ((a -> b) -> c) -> a
12:36:59 <dgpratt> but you aren't given an 'a' nor anything that could produce an 'a' from other input
12:37:00 <copumpkin> bam!
12:37:03 <Cale> Well, there's undefined ;)
12:37:18 <copumpkin> challenge
12:37:26 <dgpratt> copumpkin: :)
12:37:27 <copumpkin> write an expression that has that type without annotations
12:37:33 <Cale> Well, you could also specialise c = a, but then you're stuck needing an (a -> b)
12:37:33 <dgpratt> undefined == winning!
12:37:43 <stephens2424> Quick question: when writing a module, can you import other modules into it?
12:37:46 <Cale> and then you could specialise b = a, and use id
12:37:53 <hpc> stephens2424: yes
12:37:55 <tac-tics> dgpratt: What about fix?
12:37:57 <tac-tics> @type fix
12:37:58 <lambdabot> forall a. (a -> a) -> a
12:38:06 <tac-tics> There's your a :)
12:38:10 <tac-tics> @type fix id
12:38:11 <lambdabot> forall a. a
12:38:15 <Cale> But that wouldn't be an implementation which would be polymorphic enough
12:38:25 <stephens2424> hpc: thanks. are you supposed to put the import statement before or after the module statement?
12:38:28 <Cale> to implement the original request
12:38:57 <Cale> You can't assume a = b or a = c because as the implementor, you're not allowed to control b and c
12:39:16 <hpc> stephens2424: after
12:39:32 <tac-tics> Another way to say that is that, since a, b, and c are all bound by (an implicit) forall quantifier, they are constants.
12:39:33 <dgpratt> Cale: err, that's right, of course!
12:39:38 <tac-tics> And constants can't be changed :)
12:39:48 <dgpratt> any fool can see that
12:41:45 <bscarlet> http://en.wikipedia.org/wiki/Indiana_Pi_Bill <- some fools are more foolish than others
12:41:55 <dgpratt> that does break my brain a bit, I must admit
12:42:27 <Cale> @djinn ((a -> a) -> a) -> a
12:42:28 <lambdabot> f a = a (\ b -> b)
12:42:38 <Cale> @djinn ((a -> b) -> c) -> a
12:42:38 <lambdabot> -- f cannot be realized.
12:43:10 <dgpratt> I mean the bit about "fix id" not being polymorphic enough
12:43:16 <Cale> oh
12:43:33 <Cale> pff, no, you can implement anything with fix id, but it doesn't count for this discussion
12:43:38 <tac-tics> dgpratt: "fix" is an unsafe operation :)
12:43:40 <dgpratt> the type is "forall a. a" how much more polymorphic can you get?
12:43:52 <Twey> ‘undefined’
12:43:53 <Cale> You're not allowed general recursion here
12:44:07 <hpc> dgpratt: universe polymorphism, ofc
12:44:11 <Cale> because you can write a value of *any* type with general recursion, and that's unsurprising
12:44:17 <Cale> (just don't terminate)
12:44:19 <dgpratt> Cale: oh, so the typechecker would allow that?
12:44:21 <tac-tics> dgpratt: fix id has any type, but it never terminates, regardless of what type you try to make it
12:44:35 <tac-tics> dgpratt: What we're discussing here are programs which *always* terminate
12:44:38 <dgpratt> fix id == undefined, semantically, yes?
12:44:42 <Cale> yes
12:44:44 <tac-tics> dgpratt: yep
12:44:49 <dgpratt> ah, ok
12:45:04 <dgpratt> brain less broken now
12:45:14 <tac-tics> dgpratt: In many logics, (such as the simply typed lambda calculus and System F), fix is totally disallowed.
12:45:19 <tac-tics> because it's a lie.
12:45:27 <tac-tics> (from a logical standpoint)
12:45:32 <tac-tics> @type fix
12:45:33 <lambdabot> forall a. (a -> a) -> a
12:45:37 <Cale> If a implies a, then a
12:45:46 <tac-tics> reads in english "if a implies a, then a is true"
12:45:48 <dgpratt> but no general recursion means no turning complete, right?
12:45:52 <Cale> right
12:45:54 <tac-tics> dgpratt: correct
12:45:54 <hpc> if false implies false, then false
12:46:00 <hpc> if true, then false
12:46:01 <hpc> false
12:46:04 <hpc> QED
12:46:12 <dgpratt> implication is weird
12:46:22 <tac-tics> dgpratt: however, languages like Coq and Agda are still pretty darn powerful, even though they aren't turing complete.
12:46:54 <dgpratt> tac-tics: interesting
12:46:56 <tac-tics> If you use STRUCTURAL recursion instead of GENERAL recursion, you can write any program as long as you can prove it terminates (eventually)
12:47:17 <dgpratt> tac-tics: also interesting
12:47:21 <hpc> agda/coq programs can run forever if you can give them infinite input
12:47:38 <hpc> but they produce output at every step
12:48:42 <Cale> There's this whole large class of possible typed programming languages in between finite state automata and Turing machines with lots of variation in power, but they don't seem as well known or popular somehow.
12:48:55 * tac-tics feels like most learning happens a bit backwards in #haskell :)
12:49:06 <tac-tics> but I suppose most people come from a more pragmatic background
12:49:11 <Cale> Lots of people seem to have the impression that programming languages which aren't Turing complete must be very inexpressive as well.
12:49:25 <copumpkin> Cale: clearly they're just regular expressions with a fancier syntax
12:49:34 <copumpkin> nothing between regular and TC
12:49:35 <Saizan> the infinite input part is not quite relevant, there's an agda program equivalent to fix (1:), where's the input there?
12:49:41 <dgpratt> I wish there was a way to encode...uh...well-defined-ness in the type system
12:49:41 <Cale> copumpkin: heh
12:49:49 <Nimatek> Because Turing machines are so expressive..
12:50:22 <dgpratt> maybe I mean "non-partial-ness"
12:50:25 <Cale> Nimatek: Yeah, but there are languages where you can still write most of the programs which people actually want to write, but which aren't Turing complete.
12:50:31 <mauke> copumpkin: are you saying my regexes aren't turing complete?!
12:50:43 <tac-tics> mauke: Perl 6's are :)
12:50:47 <copumpkin> mauke: sorry you had to find out this way
12:50:53 <Cale> (It is, however, more awkward to write many of them)
12:51:00 <dylukes> tac-tics: are they really regexes though? :P
12:51:07 <mauke> (spoilers: no)
12:51:11 <dylukes> they stray significantly from the original concise definition.
12:51:29 <dylukes> http://en.wikipedia.org/wiki/Regular_expression#Definition
12:51:35 <mauke> http://mauke.dyndns.org/stuff/perl/rfc2822 - perl5 is "bad" enough
12:51:39 <tac-tics> Regular Expression: A string with lots of f-ed up characters that lets you parse things if you make them long enough
12:52:28 <dgpratt> so in the absence of general recursion, is it possible to prove program termination (in the general case)?
12:52:29 <chris2> hi. i want a takeM and thought i could to that with sequence
12:52:47 <monochrom> someone should harp the "regular expression is academic" thing
12:52:52 <mauke> :t (sequence .) . take
12:52:53 <tac-tics> dgpratt: The absence of general recursion (more or less) guarantees program termination automatically.
12:52:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> [m a] -> m [a]
12:53:02 <chris2> oh
12:53:03 <dylukes> dgpratt: mutual recursion
12:53:13 <chris2> mauke: thanks!
12:53:25 <dylukes> if you can prove there are no cycles in the call graph, then that would guarantee it.
12:53:55 <dylukes> In other words, if the call graph is a directed-acyclic-graph :P.
12:55:28 <dgpratt> agda programs are required to terminate, yes?
12:55:43 <tac-tics> dgpratt: Pretty much :)
12:55:48 <dgpratt> (with finite input)
12:56:06 <tac-tics> Unless you don't use absurd postulates, etc.
12:56:09 <dgpratt> how does agda deal with mutual recursion? disallow it?
12:56:22 <tac-tics> There's syntax for it. You have to declare it when you do it.
12:56:30 <tac-tics> And it figures stuff out for you.
12:58:16 <yrlnry> dgpratt:  I think this topic is covered extensively in the doctoral thesis of Andreas Abel.
12:58:31 <zzo38> I have another idea for another Haddock input format.
13:14:11 <amstan> hello, i have this one issue for a project that i'm working on. It's a programming contest and we're wondering how to compile haskell stuff.
13:14:19 <amstan> can i get someone's oppinion on this? https://github.com/aichallenge/aichallenge/pull/317
13:14:20 <zzo38> You use ghc
13:14:25 <zzo38> To compile Haskell stuff
13:15:07 <amstan> zzo38: the issue is more about the merits of -O2
13:15:59 <monochrom> -O is cross-module
13:16:01 <mdempsky> amstan: I think you're going to have to provide more context for anyone to give meaningful feedback.
13:16:05 <gentleben> why doesn't haskell have epsilon defined for Double?
13:16:05 <Cale> amstan: Opinion on whether to enable -O2?
13:16:21 <Cale> hmm
13:16:24 <amstan> Cale: yes
13:16:59 <Cale> I would say try both if you really care, but I usually just -O2 without thinking much about it.
13:17:31 <amstan> Cale: what about compile time?
13:17:38 <monochrom> you should benchmark both. for each project.
13:17:38 <Cale> There is a really good performance testing library called criterion which might help to decide which to use for a given project.
13:17:54 <Cale> -O2 applies more optimisations, so compiling with it will take longer
13:17:59 <Cale> (in general)
13:18:06 <amstan> monochrom: that's not an option, we have 1000s of submissions
13:18:10 <zzo38> What is your opinion of this?   http://sprunge.us/WXRb   It is something I have used in my packages
13:19:02 <monochrom> benchmark a sample of submissions
13:19:38 <Cale> Can't the submissions themselves determine the GHC options?
13:20:07 <Cale> I forget whether {-# OPTIONS_GHC -O2 #-} works or not
13:20:14 <Cale> but it seems like it ought to
13:21:17 <bfig> where can i find Graphics.Vty example code?
13:21:26 <bfig> (or a how to of some sort=
13:21:28 <bfig> )
13:21:38 <Cale> Right, OPTIONS_GHC works with any dynamic options to the compiler, and -O and -O2 are marked as dynamic in the flags reference
13:21:52 <Cale> So the users can decide their optimisation level with that pragma.
13:21:56 <zzo38> What is your opinion of the X-Printout- stuff?
13:22:10 <zzo38> Some parts are not yet written do you know how to write them?
13:22:21 <zzo38> Or any other suggestions please?
13:22:46 <Cale> zzo38: I'm not certain I really get what it's to be used for...
13:23:06 <zzo38> Cale: It says right there: "These are used to prepare printouts of a literate Haskell program."
13:23:15 <Cale> For saying how to run lhs2TeX and stuff?
13:24:18 <zzo38> Cale: I suppose lhs2TeX could be another one of the possible modes. Although the modes it includes now do not require anything like that.
13:25:03 <zzo38> For example, PlainTeX mode has the .lhs file directly processed by TeX. The HTML mode has the .lhs file directly viewable in a HTML browser.
13:25:19 <zzo38> I think lhs2TeX is for LaTeX, isn't it?
13:25:53 <zzo38> Well, if you know anything about these things you can suggest how the modes LaTeX, ConTeXt, XeTeX, XeLaTeX, can work.
13:26:28 <desaiu> What is the difference between the types Int and Integral?
13:26:38 <MatrixFrog> Integral is a type*class* not a type
13:26:39 <mauke> Integral isn't a type
13:27:05 <zzo38> Cale: Do you understand it now?
13:27:18 <MatrixFrog> desaiu: you might mean, what's the difference between Int and Integer
13:27:50 <MatrixFrog> Ints are a limited size, 29 bits iirc, Integers are limited only by how much memory you have, kind of like integers in python if you're familiiar with that
13:27:51 <desaiu> MatrixFrog: yes!
13:28:04 <desaiu> Ah, thank you
13:28:05 <MatrixFrog> Integral is a typeclass, and both Int and Integer are instances of Integral
13:28:17 <mauke> Int is 32/64 bits in ghc
13:28:20 <zzo38> (I have written a Cabal package that uses the "X-Printout-Mode: PlainTeX" and will probably do that for all Cabal packages I make)
13:28:26 <desaiu> Thank you, thank you, thank you
13:28:47 <mauke> use fromIntegral to convert between them
13:30:43 <MatrixFrog> ah, it IS 32 bits, but it's not guaranteed to be so: http://stackoverflow.com/questions/7786662/bit-size-of-ghcs-int-type
13:30:51 <MatrixFrog> (or 64)
13:33:09 <Cale> Yeah, Int is at least 30 bits, but in practice it's at least 32.
13:33:45 <Cale> (and probably a power of two bits, the standard allows for a couple of tag bits, but I don't know of any implementations which actually use them)
13:39:06 <hpaste> bfig pasted “vty error” at http://hpaste.org/53575
13:41:46 <dgpratt> what is good about type classes and types being completely seperate concepts?
13:42:05 <bfig> dgpratt, do you know how typeclasses are implemented_
13:42:34 <mauke> dgpratt: how could you merge them?
13:48:05 <dgpratt> bfig: not really
13:48:05 <MatrixFrog> dgpratt, good question. i guess one reason is that you can use a function like >>= and have it mean something totally different depending on the context
13:48:05 <MatrixFrog> (or fmap, or show)
13:48:06 <applicative> dgpratt, you can have all the types, and polymorphism, just the same without type classes -- leaving aside 'sexy types'
13:48:09 <john_r_watson> is it possible to put a deriving (...) statement in a GADT declaration?
13:48:09 <john_r_watson> so far I haven't seen any
13:48:09 <john_r_watson> another GADT Q: can I do record syntax somehow?
13:48:10 <zzo38> I think classes should really be types having (&) as the kind after all parameters are specified. It is how I think it ought to be made now you can make type families of classes and instances and whatever else too.
13:48:10 <bfig> dgpratt, typeclasses are a type with a dictionary of functions inside (those that get implemented by the typeclass)
13:48:10 <shachaf> john_r_watson: Yes, and yes.
13:48:10 <dgpratt> mauke: I'm not thinking to strictly unify them, mind you...
13:48:16 <shachaf> @google gadt deriving
13:48:17 <lambdabot> http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
13:48:17 <lambdabot> Title: 7.5.�Generalised Algebraic Data Types (GADTs)
13:48:18 <dgpratt> ...rather making one a specialization of the other, or giving them a common ancestor
13:48:18 <shachaf> @google gadt record syntax
13:48:19 <lambdabot> http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
13:48:19 <lambdabot> Title: 7.5.�Generalised Algebraic Data Types (GADTs)
13:48:20 <zzo38> And it is possible to have classes with no members
13:48:30 <shachaf> That second link is a bit outdated.
13:48:49 <john_r_watson> shachaf: thanks!
13:48:56 <elliott_> shachaf: so is the first
13:49:14 <shachaf> elliott_: Not as far as answering the question is concerned.
13:49:14 <dgpratt> and I'm also not saying I really want to do that much, either; it's just a thought excersize
13:49:21 <elliott_> fair enough
13:49:29 <bfig> dgpratt, i don't remember the implementation details exactly but it is something totally doable in the typed lambda calculus
13:49:34 <john_r_watson> http://www.haskell.org/ghc/docs/6.6/html/users_guide/gadt.html
13:49:48 <shachaf> john_r_watson: That link is outdated too. :-)
13:50:05 <dgpratt> like it might be convenient to say I want a list where the element type is the Show typeclass type
13:50:21 <shachaf> The new syntax is something like Foo :: {a :: Bar} {b :: Baz} -> Blah
13:50:23 <dgpratt> I know there are existentials and such, but that's sorta cumbersome
13:51:53 <john_r_watson> shachaf: gotcha
13:53:21 <shachaf> john_r_watson: Foo :: {a :: Bar} -> {b :: Baz} -> Blah, rather.
13:56:30 <john_r_watson> shachaf: that makes sense
14:11:20 <Clint> does arossato irc here?
14:12:14 <shachaf> Clint: Not for a while.
14:12:45 <Clint> then does anyone know where hs-bibutils is expecting c_stdin and c_stdout to come from?
14:25:00 * Baughn wonders how to get at C defines with c2hs
14:25:52 <cgroza> skype
14:26:06 <Baughn> Right, that makes sense..
14:27:45 <ybit> lambdabot: help
14:28:02 <ybit> lambdabot: list your commands
14:28:28 <ybit> lambdabot: i'm warning you!
14:28:56 <ybit> > add
14:28:57 <lambdabot>   Not in scope: `add'
14:29:00 <ybit> > help
14:29:01 <lambdabot>   Not in scope: `help'
14:29:06 <ybit> > src help
14:29:07 <lambdabot>   Not in scope: `src'Not in scope: `help'
14:29:10 <Baughn> @help
14:29:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:29:43 <ybit> it doesn't seem to respond to PM
14:29:51 * ybit would rather not spam the channel
14:30:10 <dylex> ybit: Yes it does, just start your command with @
14:30:14 <ybit> oh
14:32:32 <ybit> > index 2
14:32:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.Int)
14:32:33 <lambdabot>    arising fro...
14:32:36 <tac-tics> It it possible to write loop :: IO () -> IO (); loop f = f >> loop f, without recursion using Cont or ContT?
14:32:51 <mauke> loop = forever
14:33:03 <tac-tics> can you write foreer using ContT and no recursion?
14:33:07 <ybit> hoogle add
14:33:24 <mdxbhmt> @help
14:33:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:33:26 <ybit> i see
14:33:29 <mdxbhmt> @elp hoogle
14:33:30 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
14:33:39 <ybit> i messaged it, it just gave me the same hoogle results i'm seeing
14:33:44 <mauke> :t fix (ap (>>) .)
14:33:46 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => f (m a -> m b)
14:33:46 <mdxbhmt> ah, lol
14:33:52 <ybit> i forget how to look at the source of functions, e.g. add
14:34:08 <monochrom> there is no "add" function
14:34:16 <ybit> er...
14:34:32 <mauke> :t fix (ap (>>))
14:34:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:35:00 <ybit> i don't know where my mind's at, i give up on that distraction, here's the question i'm wondering...
14:35:04 <dylukes> Baughn: Hello?
14:35:08 <dylukes> ?seen Baughn
14:35:09 <lambdabot> Unknown command, try @list
14:35:10 <Baughn> dylukes: ?
14:35:19 <dylukes> Hey, a small bug in the emacs haskell mode.
14:35:28 <ybit> i meant sum, not add
14:35:38 <monochrom> @src sum
14:35:38 <lambdabot> sum = foldl (+) 0
14:35:41 <dylukes> in haskell-doc.el, haskell-doc-install-keymap assumes current-local-map is non-nil.
14:35:44 <Baughn> dylukes: Use /msg. No time to talk about it right now.
14:35:48 <ybit> woah, that's simple enough
14:35:55 <dylukes> Alright, I'll send a message on G+. I was about to anyways :).
14:36:01 <ybit> much more elegant than what i'm about to paste
14:36:06 <Baughn> Works too.
14:36:20 <dylukes> Alright, there you go.
14:36:23 <dylukes> Thanks!
14:36:35 <mauke> sum = eval . intercalate "+" . map show
14:36:52 <hpaste> ybit pasted “sum” at http://hpaste.org/53577
14:37:51 <monochrom> hahaha mauke
14:38:19 <mauke> EXPERT JAVASCRIPT PROGRAMMER
14:38:23 <ybit> not sure how to type that in ghci
14:38:48 <ybit> maybe i should say, i'm not sure how to input that into ghci :)
14:39:27 <mauke> input what?
14:39:33 <ybit> the paste
14:39:38 <mauke> don't
14:39:40 <mauke> put it into a file
14:39:56 <ybit> i want to use ghci though :)
14:40:02 <mauke> yes
14:40:08 <mauke> but first you must put it into a file
14:40:33 <ybit> is that first line a type declaration or a type class declaration or both?
14:40:39 <ybit> i'm not sure what to call that
14:40:55 <ybit> according to lyah, everything left of => is a class constraint
14:40:58 <mauke> yeah, I'd call it a type declaration or type signature
14:41:06 <mauke> (Num a) is a class constraint
14:41:28 <ybit> probably should reread the type class section
14:41:52 <ybit> i guess that constraint says that it takes one input a of the type Num?
14:42:25 <monochrom> no, "a" is the type, "Num" is the type class
14:42:49 <ybit> aha
14:43:37 <ybit> so why would i have to put that into a file before being to input that into ghci?
14:43:53 <Baughn> Luminous haskell are we, not this crude C..
14:44:09 * Baughn may have gone slightly insane from overexposure to FFI
14:44:14 <ben> :V
14:47:12 <mauke> ybit: because ghci only evaluates expressions (more or less)
14:47:20 <zzo38> Which outputs formats does Haddock have by now? HTML, LaTeX, DocBook, anything else?
14:47:49 <ybit> zzo38: pandoc
14:48:09 <mdxbhmt> >  let sum = foldr (+) 0  in sum [1..10]
14:48:11 <lambdabot>   55
14:48:41 <zzo38> Other ideas I have is to allow it to output in Plain TeX format, gopher menu format, and MediaWiki format.
14:49:26 <shachaf> Gopher menu format!
14:49:49 <monochrom> hypercard
14:50:00 <mdxbhmt> hackage uses only haddock?
14:50:06 <monochrom> yes
14:50:25 <mdxbhmt> hmmm, imo should leave space for user anotation
14:50:55 <ybit> > let sum' [] = 0
14:50:56 <lambdabot>   not an expression: `let sum' [] = 0'
14:51:11 <ybit> > let sum' (x:xs) = x + sum' xs
14:51:12 <lambdabot>   not an expression: `let sum' (x:xs) = x + sum' xs'
14:51:20 <ybit> hmm
14:51:34 <zzo38> I made this document describing another idea for alternative Haddock input format, which can be combined with standard format or used alone:   http://sprunge.us/jdWh
14:51:38 <ybit> > let sum' (x:xs) = x + sum' xs in sum' [1,2,3,4]
14:51:39 <lambdabot>   *Exception: <interactive>:3:4-28: Non-exhaustive patterns in function sum'
14:51:42 <Baughn> ..there are far far too many bugs in C2HS. :/
14:51:45 <ybit> yeah.. what's with that
14:51:52 <mauke> > let sum' [] = 0; sum' (x:xs) = x + sum' xs in sum' [1,2,3,4]
14:51:53 <lambdabot>   10
14:52:09 <monochrom> yeah, what's with omitting sum []
14:52:46 <shachaf> > let sum' _ = 10 in sum' [1,2,3,4]
14:52:47 <lambdabot>   10
14:52:50 <ybit> why would i need that if i'm providing a non-empty list
14:53:13 <mauke> ybit: you are providing 4 non-empty lists and 1 empty list
14:53:18 <monochrom> because recursion, base case, etc?
14:53:22 <ybit> ah yes
14:53:28 <mdxbhmt> ybit: what your function mean if you input []?
14:53:30 <ybit> 1:2:3:4:[]
14:53:33 <monochrom> do you know computer science?
14:53:37 <mauke> > let sum' (x:xs) = x + sum xs in sum' [1,2,3,4]
14:53:38 <lambdabot>   10
14:53:39 <zzo38> I don't particularly like the Haddock markup format so I wrote a specification of possibly new format
14:53:42 <mauke> magic, ladies and gentlemen
14:53:43 <ybit> derp
14:53:53 <shachaf> mauke++ # magic
14:53:56 <ybit> mauke: re:do i know cs, no
14:54:04 <mauke> ybit: wrong nick
14:54:13 <zzo38> Another output format that Haddock should have is Plain Old Documentation format
14:54:14 <ybit> monochrom rather :)
14:54:26 <shachaf> You need to know CS if you want to be in this channel, man.
14:54:28 <shachaf> The whole thing.
14:54:38 <mauke> I know CS!
14:54:39 <tac-tics> How much CS is that shachaf ?
14:54:41 <mauke> a/s/l?
14:54:41 <monochrom> no, no need. just asking.
14:54:53 <elliott_> learn you the cs for great good
14:54:54 <mdxbhmt> <- actually doesn't know half the cs
14:55:14 <blackdog> Neo sez "WHoa. I know CS"
14:55:26 <blackdog> mdxbhmt: science all the computers, man
14:55:27 <mdxbhmt> \me hoorray for SICP
14:55:35 <shachaf> tac-tics: It's quite a lot.
14:55:38 * mdxbhmt hooray for sicp*
14:55:46 <shachaf> I think mauke is the only one who knows the CS.
14:55:57 <Baughn> mauke knows the CS. All of it.
14:56:06 <mdxbhmt> The big thing
14:56:09 <mauke> DVDA
14:56:09 <zzo38> If anyone else write literate programming in Haskell, I can suggest you can use the "X-Printout-" format.
14:56:28 <monochrom> what is the X-Printout- format?
14:57:02 <zzo38> monochrom: It is  http://sprunge.us/WXRb  It is a format for some extra fields in Cabal package files
14:57:49 <zzo38> These are used to prepare printouts of a literate Haskell program.
14:58:52 <Cale> zzo38: One good person to ask would be dcoutts, I think :)
14:59:46 <zzo38> Cale: OK. Who is that?
15:01:55 <Cale> Duncan Coutts, he's one of the main developers of Cabal
15:02:04 <haskellNoobie> i had a quick question
15:02:10 <Cale> sure
15:02:42 <haskellNoobie> so lets say i have a bytesting hold the contents of a file
15:02:48 <haskellNoobie> how would i get the length of the string?
15:02:58 <mauke> S.length str
15:03:02 <Cale> Using the length function from Data.ByteString or Data.ByteString.Lazy
15:03:13 <zzo38> Is Duncan Coutts on the IRC?
15:03:14 <Cale> So if you have
15:03:19 <Cale> zzo38: Yes, he's dcoutts
15:03:32 <Cale> (he's here, but idle at the moment)
15:03:34 <haskellNoobie> what is S?
15:03:45 <zzo38> It says 7117 seconds idle
15:04:01 <monochrom> wait til it's 86400 seconds
15:04:17 <Cale> haskellNoobie:  import qualified Data.ByteString as S -- mauke is assuming that you're importing the library like this
15:04:38 <haskellNoobie> oh gotcha
15:05:53 <haskellNoobie> im getting this error
15:05:57 <haskellNoobie>  Couldn't match expected type `IO ()'                 with actual type `GHC.Int.Int64'
15:06:29 <mauke> you forgot a 'return'
15:06:46 <shachaf> mauke: Wouldn't it be "IO something" instead of "IO ()", in that case?
15:06:55 <blackdog> forgot "print", more likely...
15:07:10 <mauke> shachaf: hmm, right
15:07:16 <blackdog> haskellNoobie: assume you're doing this as a standalone program, with 'main', rather than at the REPL?
15:07:20 <haskellNoobie> yes
15:07:37 <blackdog> so in that case, you need to actually do something with that number once you've found it, right?
15:08:00 <blackdog> it does no good for the computer to know the answer unless it communicates it to the outside world somehow
15:08:06 <blackdog> which is an IO action
15:08:16 <tac-tics> Does anyone know if you can define forever using ContT, but without using recursion?
15:08:31 <Cale> tac-tics: um, sure
15:08:32 <Baughn> mauke knows the CS. All of it.
15:08:39 <mauke> forever = fix (ap (>>))
15:08:40 <haskellNoobie> ok thank you
15:08:49 <tac-tics> mauke: No fix, just continuations :)
15:09:11 <Baughn> ..yes, please don't catch me in an eternal loop. ;_;
15:09:32 <blackdog> haskellNoobie: np. btw, is usually easier if you chuck your code into hpaste and give a link, that way we don't have to guess.
15:09:55 <ddarius> tac-tics: You'll need recursion somewhere.
15:09:59 <shachaf> tac-tics: ContT is just a newtype for (a -> m r) -> m r
15:10:12 <haskellNoobie> kk
15:10:20 <Cale> Yeah, you *will* be using recursion indirectly somehow
15:10:28 <tac-tics> ddarius: For some reason, I'm convinced you can do it with ContT and IORefs
15:10:32 <Cale> It's just a matter of where you put it
15:11:38 <Cale> getCC :: MonadCont m => m (m a)
15:11:39 <Cale> getCC = callCC (\c -> let x = c x in return x)
15:11:54 <Cale> for example, you can put the recursion in that
15:12:12 <hpaste> me pasted “ID3 Viewer” at http://hpaste.org/53579
15:12:30 <Cale> and then use something like  foreverC x = do again <- getCC; x; again
15:12:32 <ddarius> tac-tics: All that would mean is that you can do it with IO.
15:12:38 <monochrom> print length  or  putStr (show length)
15:12:39 <mauke> me: print (BL.length contents)
15:12:42 <ion> edwardk: Does AD work with some matrix library (and benefit from its vectorized implementation)?
15:12:48 <mauke> monochrom: length doesn't exist
15:13:07 <tac-tics> ddarius: Or I could use STRefs and I could do it purely.
15:13:13 <tac-tics> Which probably constitutes a proof that it's not possible.
15:13:18 <monochrom> oh darn. nevermind
15:13:37 <Cale> tac-tics: It wouldn't be surprising that pure code admits an infinite loop
15:13:40 <Cale> (fix id)
15:13:46 <mdxbhmt> why lenght<- doesn't work on that paste?
15:13:50 <haskellNoobie> http://hpaste.org/53579
15:14:02 <mauke> mdxbhmt: because BL.length contents is a number, not an action
15:14:21 <Cale> mdxbhmt: because v <- x means "run the action x and name its result v"
15:14:23 * hackagebot hierarchical-clustering-diagrams 0.1.0.1 - Draw diagrams of dendrograms made by hierarchical-clustering.  http://hackage.haskell.org/package/hierarchical-clustering-diagrams-0.1.0.1 (FelipeLessa)
15:14:34 <Cale> mdxbhmt: and the length is a number, not an action, as mauke mentioned
15:14:50 <tac-tics> ok, well, I ran out of time
15:14:52 <tac-tics> thanks guys :)
15:14:52 <mdxbhmt> Cale: mauke thanks, It's make sense
15:14:58 <haskellNoobie> so how would i store that number?
15:15:01 <Cale> You want  let l = BL.length contents -- let's not shadow the Prelude definitions ;)
15:15:26 <Cale> haskellNoobie: Store it where?
15:15:44 <haskellNoobie> wrong word, not store
15:15:44 <Cale> You can give it a name using let
15:15:53 <Cale> which scopes over the rest of the do-block
15:16:17 <Cale> oh, also, there are tab characters in that paste
15:16:36 <Cale> you're going to want to configure your text editor not to insert tabs into your source files (it should convert them to spaces)
15:16:51 <Cale> Most decent text editors have that option somewhere
15:17:02 <haskellNoobie> ok
15:17:04 <shachaf> Tab characters are good for you. You might consider adding an extra tab character to the end of each line, just to give things space.
15:17:06 <haskellNoobie> im on gedit
15:17:14 <Cale> shachaf: hah
15:17:33 <mauke> I don't gedit
15:17:45 <Cale> Yeah, it's in the Preferences, under Editor -> "Insert spaces instead of tabs"
15:17:48 <monochrom> I'm on gedit too. but I turned off tabs
15:18:18 <haskellNoobie> you guys are really helpful
15:18:24 <haskellNoobie> this is awesome
15:19:02 <haskellNoobie> but yea i got it to compile correctly
15:20:58 <ddarius> do r <- newIORef (return ()); writeIORef r (join (putStrLn "*" >> readIORef r)); join (readIORef r)
15:21:53 <shachaf> ddarius++
15:22:06 <ddarius> Exercise: Where is the recursion?
15:22:43 <monochrom> that gives me ideas
15:23:50 <dylukes> I really hate the parenthetization here
15:23:50 <mauke> writeIORef r (... r)
15:23:54 <dylukes> any ideas?  FloatL <$> (option id (negate <$ char '-') <*> double)
15:24:15 <dylukes> I'm always bothered by Foo <$> (...)
15:25:45 <zzo38> Does the people managing the account for HackageDB have UNIX mail? I send a UNIX message to them and I don't know if it work.
15:25:50 <zzo38>  Maybe it doesn't work; my name is not on there.
15:26:09 <ddarius> mauke: That's not recursion.
15:26:28 <zzo38> Who are they anyways?
15:26:29 <shachaf> ddarius: It's a cyclical data structure.
15:26:56 <ddarius> shachaf: Yes, but where is the recursion?  Why am I allowed to make this data structure?
15:27:57 <monochrom> do { rec { r <- return (putStrLn "*" >> threadDelay 1000000 >> r) }; r }
15:27:59 <mauke> the result of readIORef is the result of readIORef
15:28:33 <ddarius> the result of succ is the result of succ
15:28:59 <dolio> Your second 'line' is 'x = putStrLn "*" ; x'.
15:29:33 <monochrom> "do, a block, a monad block. rec, a knot tied in the block." http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html
15:30:41 <monochrom> mutable cells allow building cyclic data. exemplified by 1st year Pascal homework
15:30:44 <ddarius> dolio: I don't think you wrote (or at least clearly wrote) what you meant to write.
15:31:04 <ddarius> monochrom: -Why- do they?  Do they have to?  (The answer is "no.")
15:31:20 <monochrom> and then haskell allows turning cyclic data into cyclic control
15:31:23 <ddarius> And even if they do, again, where is the recursion?  The expression I wrote is clearly non-recursive.
15:31:32 <monochrom> I don't know why, and I don't care.
15:32:05 <monochrom> oh, I see what you mean. the executioner carries out the recursion. the executioner is a big loop.
15:32:42 <monochrom> I build cyclic data but I need the executioner to interpret it into cyclic control
15:32:46 <dolio> Is 'x = delay(putStrLn "*" ; force x)' clearer?
15:33:15 <ddarius> dolio: The parentheses were what you were lacking.
15:33:25 <dolio> Oh, I see.
15:34:06 <ddarius> At any rate, as I said, the expression I wrote is clearly non-recursive, though I agree that it is equivalent to that (plus a follow-on 'x').
15:34:48 <dolio> My C AST is clearly non-recursive, but somehow it can represent recursive programs.
15:36:22 <monochrom> perhaps it's the same as why Y recurses. you wait for a poor student to raise hand and ask. then you answer "try it yourself!". the student is amazed. the student doesn't know that you have tricked him/her into being the recurser.
15:37:06 <dgpratt> monochrom: what?
15:37:24 <monochrom> try it yourself! :)
15:37:34 <dfjkalsfd> does ones = fix (\x -> 1 : x) quality as a recursive definition?
15:37:35 <ddarius> dolio: I don't use fix; I don't define a name in terms of itself.  I'm not saying the AST of my expression is non-recursive.  I'm not using the recursive constructs provided by Haskell.  fix id is equivalent to (\x -> x x) (\x -> x x), that doesn't make the latter recursive.
15:38:21 <dolio> An IO action is an AST.
15:38:29 <dolio> Your IO action describes a recursive program.
15:39:45 * monochrom likes recursion, recursion relegated to the meta level, and all meta-level games!
15:39:55 <ddarius> An IO action is not an AST.  You can model it as one if you want, which at least gets you looking in vaguely the right direction.
15:40:38 <ddarius> The right direction being modelling of, particularly, mutable state, IO isn't relevant here, not the "AST" part.
15:41:34 <ddarius> dolio: If you were going to give a denotational semantics of just enough mutable state and expression forms to provide a denotation for my expression, what would it look like?
15:42:26 <dolio> I don't know.
15:42:33 <ddarius> Try it!
15:44:32 <monochrom> yuck, what is expression form? sounds like a denotation semantics of it is a monster, no less monster than D = (D->D)
15:46:07 <monochrom> ddarius's example looks like a limited kind of self-modifying program
15:46:44 <dolio> I'm not entirely sure what you're asking for. Your example requires mutable references and expressions as first-class values.
15:46:49 <ddarius> It certainly does not modify any of its code.
15:47:09 <ddarius> dolio: You know how to model mutable state purely.  We teach it in introductory books on Haskell.
15:47:17 <dolio> Your example assigns to r an expression that will print * and then evaluate the expression stored in r.
15:47:55 <dolio> And then it evaluates the expression stored in r.
15:48:05 <monochrom> it could be rewritten to StateT IO?
15:48:36 <dolio> I'm not sure. That might be an infinite type.
15:48:50 <monochrom> oh, right
15:48:52 <ddarius> Well, it can be written with just IO, so surely it could be done with StateT IO, but, ignoring the putStrLn which was just there for clarity in execution.
15:49:11 <ddarius> You can model the mutable state aspect with State.
15:49:54 <dolio> put (join $ lift (putStrLn "*") >> get) ; join get
15:49:55 <ddarius> In fact, simply writing the equivalent of the expression using State, makes it rather clear where the recursion is.
15:50:04 <monochrom> I may add an unsafeCoerce to avoid an infinite type :)
15:50:22 <dolio> @type put (join get)
15:50:23 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (MonadState (m a) m, MonadState (m a) m1) => m1 ()
15:50:32 <dolio> @type put (join get) >> join get
15:50:32 <lambdabot> forall (m :: * -> *) b. (MonadState (m b) m) => m b
15:50:46 <dolio> I guess you don't need a newtype.
15:51:12 <dolio> @type evalState
15:51:13 <lambdabot> forall s a. State s a -> s -> a
15:51:18 <ddarius> :t runState (put (join get) >> get)
15:51:19 <lambdabot> forall (m :: * -> *) a. (MonadState (m a) m) => m a -> (m a, m a)
15:51:31 <ddarius> :t evalState (put (join get) >> get)
15:51:32 <lambdabot> forall (m :: * -> *) a. (MonadState (m a) m) => m a -> m a
15:51:38 <ddarius> Bloody new MTL!
15:51:40 <dolio> > evalState (put (join get) >> join get) 1
15:51:40 <lambdabot>   Occurs check: cannot construct the infinite type:
15:51:40 <lambdabot>    m
15:51:41 <lambdabot>    =
15:51:41 <lambdabot>    Control.Mona...
15:52:02 <dolio> Oh, okay.
15:52:30 <dolio> It's only the abstractness that's preventing complaints.
15:52:35 <ddarius> Yes.
15:53:18 <dolio> Anyhow, presumably you get something that looks like Y out of that.
15:53:25 <eulyix> If I have a datatype Expression declaring Variable String and a function diff :: Expression -> String -> Expression with a rule diff (Variable x) x = 1.0 why does Haskell say "Conflicting definitions for `x'"?
15:53:30 <dolio> Or one of the many other fixed point combinators.
15:53:59 <mauke> eulyix: because you're trying to define x twice
15:55:00 <eulyix> mauke, ah, I was trying to ask Haskell to execute that rule when the two things were the same, I guess I'll just have to use an IF, then.
15:55:15 <eulyix> Thanks
15:55:16 <mauke> there are no IFs
15:55:20 <mauke> you probably want a guard
15:55:26 * dolio heads out.
15:55:36 <monochrom> thank you ddarius for pushing us to see its true nature, and from two angles at that.
15:55:41 <eulyix> diff (Variable x) y | x == y = 1.0
15:55:44 <ddarius> :t let put s = const ((), s); get s = (s, s); join f s = case f s of (g, s') -> g s'; andThen m n s = case m s of (_, s') -> n s' in put (join get) `andThen` get
15:55:44 <lambdabot> Parse error in pattern
15:56:12 <eulyix> It would be super cool if you could pattern match like that, though :-)
15:56:41 <shachaf> eulyix: What would you want it to reduce to? (==)?
15:57:04 <ddarius> :t let put s = const ((), s); get s = (s, s); join f s = case f s of { (g, s') -> g s' }; andThen m n s = case m s of { (_, s') -> n s' } in put (join get) `andThen` get
15:57:05 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:57:05 <lambdabot>       Expected type: (t -> t1, t)
15:57:05 <lambdabot>       Inferred type: (t -> t1, t -> t1)
15:57:13 <monochrom> (I certainly played similar tricks with IORef. I didn't think of it too much.)
15:57:16 <eulyix> shachaf, can you rephrase? Not sure I follow.
15:57:31 <Baughn> ..all right. Would you say c2hs is unmaintained?
15:57:49 <eulyix> Currently, mine looks like diff (Variable x) y = if x == y (Constant 1.0) else (Variable x)
15:58:10 <eulyix> (you can probably guess what the constructors stand for)
15:58:10 <eulyix> *then
15:58:19 <ddarius> Note that the second component of the tuple is the state.  The recursion is through the state.  If you make a denotational model of mutable state that allows you to put things like get into a mutable variable, your state domain will be recursive unless you do a whole lot of shenanigans.
15:58:29 <shachaf> > let put s = const ((), s); get s = (s, s); join f s = case f s of { (g, s') -> g s' }; andThen m n s = case m s of (_, s') -> n s' in put (join get) `andThen` get
15:58:30 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
15:59:02 <ddarius> In other words, if you were to give a type for the heap, it is recursive.
16:04:50 <ddarius> shachaf: If you make a type like newtype Stately = Stately (State Stately Stately) and inserted the appropriate wrappers, you could make that work.
16:06:59 * ddarius recommends http://www.cas.mcmaster.ca/~bendermm/thesis.pdf as follow on reading.
16:12:51 <dgpratt> considering this discipline is supposed to be based on logic and science, myths are surprisingly prevalent
16:13:56 <kmc> which discipline?
16:14:56 <dgpratt> kmc: the discipline of programming
16:15:40 <kmc> heh
16:15:41 <DasIch> dgpratt: wait a moment, programming is based on logic and science?
16:15:45 <kmc> i wish it was based on logic and science
16:16:09 <dgpratt> DasIch: well, that's the mythological origin, anyway
16:16:18 <kmc> a lot of programmers just can't be bothered to understand what they're doing
16:16:24 <kmc> and some are actively anti-intellectual
16:16:30 <JoeyA> Is there some funky GHC extension that will let me make a data constructor of type forall a. a ?
16:16:38 <JoeyA> (I'm using it for an acme module)
16:16:43 <DasIch> dgpratt: i personally prefer the sicp tale of magic
16:16:52 <kmc> JoeyA, not that i'm aware of
16:17:04 <dgpratt> kmc: I often don't know what I'm doing, I'm just more willing to admit it than some people
16:18:42 <kmc> it's not about either of those things
16:25:45 <dgpratt> what version of GHC introduces constraint kinds?
16:25:52 <kmc> not yet released
16:26:11 <kmc> i.e. 7.3.something
16:26:14 <kmc> dgpratt, I also think everything else based on logic and science is full of myths
16:26:18 <kmc> including logic and science
16:26:23 <dgpratt> kmc: :)
16:26:30 <kmc> but yeah the level of anti-intellectualism in programming is disappointing
16:27:48 <kmc> i could speculate all day as to the reasons
16:28:58 <monochrom> most programmers positively do not want to be scientists or engineers
16:29:52 <monochrom> look at even Knuth, "the art of computer programming". most programmers want to be called artists, craftsmen
16:30:53 <kmc> i don't think most programmers adhere to the "programming is like painting" subculture
16:31:14 <kmc> i think that's a specific circleblog which is very visible on reddit, hacker news, etc
16:31:48 <shachaf> Programming is to painting as functors are to boxes?
16:31:51 <kmc> realistically most programmers just want a nice job which is kinda fun
16:32:06 <kmc> and since nobody is forcing them to be scientists or engineers in order to get that job, they aren't
16:36:40 <dgpratt> kmc: do you think this is a lamentable situation, or are these merely your observations?
16:37:41 <kmc> which part
16:39:59 <monochrom> to be fair, an engineer's job is not as fun
16:40:00 <dgpratt> ah, it's bed-time for the kiddos
16:40:08 <dgpratt> be back in a bit
16:41:44 <kmc> the "programmers are painters" crowd have obvious incentives to convince you that only their kind is worth hiring.  and they've pushed out many pages of blog to this effect
16:41:45 <luite_> not as fun as a painter's?
16:41:52 <kmc> but don't have much concrete evidence
16:42:03 <kmc> evidence, however, is only valued by scientists and engineers, not by painters
16:43:09 <BrianHV> what sort of evidence do you value that you feel the "painters" don't?
16:44:02 <monochrom> for example evidence for "language XXX increases productivity"
16:44:22 <Nimatek> They are painters alright. The kind that paints with their fingers.
16:44:45 <BrianHV> does evidence of that for any XXX exist?
16:44:51 <monochrom> very hard to gather evidence for or against that, sure. but painters don't even try. they don't even time themselves.
16:45:06 <kmc> http://morendil.github.com/folklore.html
16:45:43 * BrianHV clicks the "Read Later" button and will surely do so
16:45:49 <monochrom> whereas at least a few "ivory-tower" academics tried very preliminary quantitative studies.
16:45:55 <kmc> here's an evidence-based refutation of one of the most beloved myths of the real programmer / hacker painter subculture
16:47:46 <BrianHV> oh.. I think I've seen a refutation of that before. perhaps even this one.
16:48:08 <monochrom> the academics couldn't do more realistic studies because they're under-funded
16:51:11 <BrianHV> so is there an evidence-based subculture that fits your expectations? because I've found that the hacker/painters tend to value evidence, even if they're not as rigorous as they ought to be, where as the average programmer might not value evidence much at all
16:51:22 <BrianHV> s/where as/whereas/
16:51:56 <simon> I'm not sure I understand these metaphors.
16:52:58 <dgpratt> simon: it's better that way; you can assume they mean whatever you wish
16:53:08 <kmc> dgpratt gets it
16:53:30 <dgpratt> kmc: :)
16:54:10 <kmc> BrianHV, I'm not sure why these subcultures need to exist, which is why I'm not looking for one that makes me happy
16:54:39 <alpounet> kmc, propane looks nice
16:54:47 <kmc> thanks alpounet
16:55:12 <BrianHV> kmc: I find them valuable because they provide a community of developers to learn from and to improve with. that's why I'd love to find an evidence-based culture
16:55:25 <alpounet> so that was why you needed this global lock
16:55:39 <simon> Parsec is LL(K), right?
16:55:45 <kmc> alpounet, yeah... DevIL is not thread-safe and none of the existing Haskell bindings solve this problem
16:56:00 <Dashkal> BrianHV: I've found that the "culture" that is the set of people in this channel tends to qualify
16:56:08 <kmc> BrianHV, specifically, I don't know why we need all these blogs "about programming" which never discuss code or technology
16:56:40 <alpounet> ok
16:56:47 <kmc> but rather discuss "hacker culture" (unsoundly generalized to all programmers) and Common Wisdom about hiring and managing programmers (which is never evidence-based)
16:58:53 <BrianHV> Dashkal: I certainly find this channel valuable. :)  but we don't often discuss empiricism in here either
16:59:15 <kmc> i'm constantly calling people out for not making their performance claims empirical
16:59:46 <BrianHV> well, yes. painters do that too. ;)
16:59:49 <kmc> but it's not just the lack of rigour of the hacker painter bloggers which bothers me
17:00:09 <kmc> I just hate the things they write about
17:00:27 <BrianHV> fair enough
17:00:35 <kmc> lack of rigour just explains how they get away with saying incredibly wrong things
17:00:55 <kmc> anyway I don't have a good solution to finding a community which is relatively free of this bullshit
17:01:16 <shachaf> kmc: Have you considered the painting community?
17:01:27 <shachaf> I doubt they make any programmer analogies.
17:01:41 <kmc> reddit's /r/haskell is still pretty good, but staying within the walls of Haskell has obvious disadvantages
17:02:02 <kmc> you can also read /r/programming or Hacker News and just skip over the bullshit
17:02:13 <BrianHV> yeah. I'd be really interested in an empirical approach to methodology, but that's hard to do/find
17:02:36 <kmc> that might work for you; personally I just get angry and ragequit
17:03:08 <kmc> i guess /r/coding is supposed to be the low-bullshit version of /r/programming
17:03:33 <dylukes> kmc: Isn't there some way to halt all of the threads except for one?
17:03:37 <dylukes> For non-threadsafe C stuff?
17:04:08 <shachaf> dylukes: Halt all of the threads except for one? Why?
17:04:18 <dylukes> For libraries like DevIL that are not threadsafe.
17:04:53 <dylukes> I recall something about foreign calls and blocking all of the Haskell threads.
17:05:21 <shachaf> Why do you want to "block" Haskell threads that are unrelated?
17:05:28 <kmc> with threaded rts, unsafe foreign calls block all the Haskell threads on one OS thread only
17:05:33 <monochrom> you can take the first step of being evidence-based by asking "how to reproduce the error" whenever someone says "I get compiler error, how to fix?". and yes, what kmc says, when someone makes performance claims, call him/her bluff.
17:05:34 <dylukes> kmc: Ah oay.
17:05:35 <kmc> and you can't depend on that behavior either
17:05:46 <kmc> GHC explicitly reserves the right to implement unsafe calls as safe calls
17:05:58 <dylukes> hehe.
17:07:27 <ion> How about other threads using IPC with a single bound thread that actually does the FFI calls?
17:07:49 <monochrom> dylukes: see my http://www.cs.toronto.edu/~trebla/personal/haskell/ghc-conc-ffi.xhtml  (temporary location, my normal www.vex.net site is down)
17:08:31 <blackdog> i tried that approach recently on windows... ended up running the C stuff in a separate process and talking over a pipe. Kludgey, but i timed out on trying to make it work otherwise.
17:09:46 <monochrom> if you use the unthreaded rts, you have a unique OS thread, but you lose much concurrency. every FFI call is stop-the-world.
17:09:47 <dilinger> kmc: sigh.  i'd be all over that hackathon if i still lived in the area.
17:10:05 <monochrom> but wait, perhaps you're asking for it
17:10:43 <shachaf> dilinger: Which hackathon? Which area do you live in?
17:12:20 <kmc> ion, that's a way, but how do you get access to the single global thread?
17:12:24 <dilinger> shachaf: at mit, jan 20th.  it's on his blog.
17:12:36 <kmc> creating a global thread or Chan in IO is no easier than creating a global lock in IO, as far as I know
17:12:54 <shachaf> dilinger: There are going to be several hackathons. :-)
17:14:13 * monochrom rewrites ddarius's example to global IORef :)  "where is the recursion?" :)
17:16:28 <ddarius> monochrom: The version with get/put was effectively using a single piece of global state.  The newIORef and passing r around in the first example was just (unavoidable) noise.
17:17:03 <ion> kmc: Erlang/OTP has a process registry. Perhaps Cloud Haskell could standardize something equivalent.
17:17:06 <tac-tics[home]> > 1 + 1
17:17:07 <lambdabot>   2
17:17:08 <monochrom> yeah
17:18:11 * ddarius would expect the best programmers to be a -lot- more than 10 times better, for any reasonable metric, than the worst...
17:18:39 <blackdog> ddarius: you'd expect a sign change
17:18:59 <monochrom> ha ha ha
17:20:00 <blackdog> monochrom: not joking. think about talking a newbie through a piece of haskell - is always going to be heaps slower than just understanding it yourself. even an experienced programmer who doesn't know the language is going to be a net negative for a while
17:22:07 <shachaf> ddarius: What about the best and worst of the median 50%, say?
17:23:23 <blackdog> shachaf: i wonder if there's evidence for distribution of ability. could probably make an argument for both power law and normal distribution.
17:28:31 <dylex> blackdog: It will depend how you define ability -- what metric you use.  In psychology we generally expect the underlying distribution to be normal, and try to find a metric that shows that.
17:29:20 <Steven807> Hey folks, can anyone help me with a problem installing Haskell?  I'm on RedHat, and there's no HaskellPlatform for it, and the latest generic linux build that works is 6.8.3.  So I'm trying to compile from source, and having issues..  (Yes, I've tried Googling — no luck.)
17:29:23 <blackdog> dylex: there was an interesting essay a while ago about baseball players, suggesting the vast majority are just barely good enough to be in the team
17:29:54 <blackdog> which sounds weird, until you realise that it's competitive enough that even if the underlying distribution is normal, you've filtered out the bottom 99%
17:30:04 <blackdog> (or more, probably)
17:30:24 <dylex> blackdog: right, you're looking at the very very top of a fairly small-tailed distribution.
17:30:27 <mauke> Steven807: how does ghc-7.0.3 fail?
17:30:54 <blackdog> dylex: what's the evidence for expecting a normal distribution, btw? is it just an article of faith?
17:31:06 <blackdog> many things do seem to obey power law distributions...
17:32:01 <Steven807> oops — 7.04 actually (but I got the same problem with 6.12.3):
17:32:01 <Steven807> "inplace/bin/ghc-cabal" install "/opt/local/lib/ghc-7.0.4/ghc" "/opt/local/lib/ghc-7.0.4/ghc-pkg" "strip" "/opt/local/lib/ghc-7.0.4" libraries/ghc-prim dist-install '' '/opt/local' '/opt/local/lib/ghc-7.0.4' '/opt/local/share/doc/ghc/html/libraries' NO
17:32:01 <Steven807> Installing library in /opt/local/lib/ghc-7.0.4/ghc-prim-0.2.0.0
17:32:01 <Steven807> ghc-cabal: Error: Could not find module: GHC.Bool with any suffix: ["p_hi"] in
17:32:01 <Steven807> the search path: ["dist-install/build"]
17:32:01 <Steven807> make[1]: *** [install_packages] Error 1
17:32:02 <Steven807> make: *** [install] Error 2
17:32:24 <mauke> tl;dr
17:32:35 <dylex> blackdog: mostly that the sources of variation are genetic and experience, which both are generally normal.  but you're right that a lot of it is just arbitrary definition.
17:32:43 <Steven807> You think it was too long for you!  I've been at this for 6 solid hours.. :-)
17:33:09 <Cale> Steven807: um, which generic linux package? The one from the GHC website?
17:33:15 <Steven807> Cale: yup
17:33:30 <Steven807> Cale: in this case, http://www.haskell.org/ghc/dist/7.0.4/ghc-7.0.4-src.tar.bz2
17:33:35 <mauke> Steven807: why 7.0.4?
17:33:37 <Cale> http://haskell.org/ghc/dist/7.0.4/ghc-7.0.4-i386-unknown-linux.tar.bz2 -- that one, yeah?
17:33:42 <Cale> oh, that's a source package
17:33:44 <tsaad> how would i split a byteString and keep only the second half?
17:33:50 <Cale> Try the binary 7.0.4 first
17:33:56 <Steven807> oops, that's the source one.  I can't install the binary one because this redhat installation (which I don't have control over) has a glibc of 2.5
17:34:01 <ddarius> tsaad: split it and then keep only the second half.
17:34:18 <Steven807> Mauke: 7.0.4 because I know the code i wrote works on my mac, and on my mac I'm running 7.0.4
17:34:40 <Steven807> 6.8 doesn't support cabal-install, so I can't easily get at the packages I need for my program (aeson, etc)
17:34:47 <tsaad> would i use splitAt?
17:35:09 <mauke> tsaad: drop
17:35:10 <Cale> tsaad: yeah, probably
17:35:17 <Cale> Or drop, yes
17:35:34 <Steven807> Cale: I tried the binary for 7.2*, 7.0*, 6.12*…  Finally I hit the suggestion at http://sheyll.blogspot.com/2010/05/installing-haskell-prime-on-cent-os-54.html to use 6.8.3
17:36:09 <Cale> I wonder if it's possible to use a newer glibc from your home directory
17:36:23 <Steven807> (from 6.8 I tried to build 6.12, failed, succesfully built 6.10, but that still doesn't work with my code, so I tried for 7.0.  I could try 7.2, but at 1.5 hours per attempt, I thought I'd ask here next.)
17:36:57 <Steven807> That's an idea — I could try setting LD_LIBRARY_PATH, etc.  Ugh.  More painful than I'd like, but it's better than giving up.
17:39:07 <newsham> doing some code golf..  anyone know a clean way to hide the "x" parameter passed around often here:  http://www.thenewsh.com/~newsham/x/machine/marsh.hs
17:39:40 <Dashkal> kmc: good read.  thank you
17:39:57 <shachaf> newsham: Seems like a liftM2 sort of thing.
17:40:57 <newsham> shachaf: I was thinking looks kinda like Reader, but the thing is the x i'm passing into functions is a diff x than the one passed in
17:43:00 <scshunt> anyone have any good (mathematical) books on category theory?
17:43:08 <shachaf> newsham: Which function, for example?
17:43:33 <newsham> ie. xferFoo
17:43:44 <monochrom> Steven807: use 6.10 to build 6.12? then use 6.12 to build 7.0?
17:44:31 <newsham> would be nicer if it was something like;   Foo <$> xfer32 d x1 <*> xfer8 d x2 <*> xfer8 d x3 <*> xfer16 d x4
17:44:41 <monochrom> or just erase fedora
17:44:43 <Steven807> monochrom: I'm trying that now — 6.12 is the one that is failing to build
17:44:48 <newsham> oh, i can hide the "d" at least I guess.
17:45:00 <shachaf> xferFoo d x = Foo `fmap` (xfer32 d . x1) x `ap` (xfer8 d . x2) x `ap` (xfer8 d . x3) x `ap` (xfer16 d . x4) x
17:45:33 <Steven807> monochrom: I wish i could use a different Linux, but it's "Company-Mandated".  Grr.
17:45:48 <blackdog> Steven807: virtualbox?
17:45:55 <newsham> shachaf: right.
17:46:09 * monochrom not crazy enough to suggest virtualbox yet :)
17:46:13 <Steven807> monochrom, Cale, mauke: thanks for your attention and thoughts; I have to go, but I'll see if I can get the local glibc thing going.
17:46:23 <blackdog> monochrom: i use a mac and deploy on linux, it's my first option :)
17:48:30 <scshunt> hey copumpkin
17:48:40 <copumpkin> hi
17:49:07 <dmwit> scshunt: I have a great book called "Topoi".
17:49:24 <dmwit> It's at school, though, so I can't tell you the authors for sure until Monday.
17:49:36 <dmwit> I *think* it's this one.
17:49:41 <dmwit> http://www.amazon.com/Topoi-Categorial-Analysis-Logic-Mathematics/dp/0486450260/ref=sr_1_1?ie=UTF8&qid=1320454571&sr=8-1
17:51:42 <ddarius> Does anyone have good non-mathematical books on category theory?
17:51:56 <dmwit> nope.avi
17:51:59 <Dashkal> *blinks* Can that exist?
17:52:12 <scshunt> dmwit: looks a little applied
17:52:13 <Ferdirand> I have a book titled "what men know about women"
17:52:27 <Ferdirand> it's full of blank pages
17:52:43 <Dashkal> s/"what men know about women"/"what people know about people"
17:53:00 <Cale> scshunt: Awodey's book is a good intro
17:53:14 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
17:53:27 <ddarius> newsham: What's wrong with Control.Applicative?
17:53:35 <monochrom> I have a photocopy of most of "category theory for computer scientists"
17:54:10 <dmwit> scshunt: Oh, well, if you want abstract, then "Categories for the Working Mathematician" is the classic text. =)
17:54:49 <ddarius> Categories for the Working Mathematician is a little grab-bag-y.
17:54:59 <dmwit> (And anyway, the applied-ness is what makes that book so great for me. "Why would I want to define it that way?" is never a question, because he starts with a bunch of stuff that you obviously wants to do and *then* makes the definition that does all that.)
17:55:21 <dmwit> s/wants/want/
17:56:08 <scshunt> ddarius: grab-bag-y?
17:56:38 <scshunt> monochrom: which "category theory for computer scientists?" There's 400
17:56:54 <monochrom> benjamin peirce
17:58:11 <monochrom> http://www.amazon.com/PHP-Bible/dp/0262660717/
17:58:56 <scshunt> Cale: ah, yeah, library has that one too
17:59:05 <scshunt> will get both
17:59:09 <scshunt> in some order
18:03:53 <ybit> in the language shootout
18:03:57 <ybit> sbcl stomps ghc
18:04:01 <ybit> http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=sbcl&lang2=ghc
18:04:21 <monochrom> what is sbcl?
18:04:35 <mauke> steelbank common lisp
18:05:11 <ybit> minus memory usage
18:07:30 <Nimatek> Isn't that the benchmark where people optimize implementations to the point where they could've been written in assembly just as well?
18:12:16 <kmc> yep
18:12:49 <kmc> eh "stomps" is pushing it
18:12:58 <kmc> they're within a factor of 3 each way, with ghc ahead in several cases
18:14:16 <Aune> There seems to be a serious lack of benchmarks that I would be interesdted in. Like 1. How easy is it to write correct code, 2. How easy is it for a person knowlegeable in the language to grok a general piece of code, 3, how efficient is a program writen by someone who are closer to average skill than say Oleg level skill
18:14:55 <kmc> (is Oleg actually an expert at Haskell performance tuning?  I would say like "dons skill level" or "Simon Marlow skill level")
18:16:00 <kmc> those things are much harder to quantify
18:16:08 <monochrom> no, Oleg is not dons level
18:16:09 <kmc> so we don't quantify them, we just write handwavey blog posts about them
18:16:29 <gentleben> i don't know about dons, he writes a lot of slow code
18:16:51 <shawn_> I always assumed oleg was from another planet and not a human like dons or simon
18:16:56 <gentleben> in fact i have found most galois code the be terribly unperformant
18:17:09 <monochrom> oleg is probably at #haskell regular level
18:17:13 <Aune> kmc, yes I agree, but the point is, most code in these benchmarks are really hand optimized to the point of making the benchmark almost a moot exersice
18:17:50 <kmc> there's also a general bias towards performance over correctness in education, arising from the fact that your professors learned to program decades ago and therefore learned on machines which were approximately one million times slower
18:18:06 <Nimatek> kmc: So true.
18:18:18 <kmc> > 2 ^ (30 * 12 / 18)
18:18:18 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:18:19 <lambdabot>    `GHC.Real.Fractional t'
18:18:19 <lambdabot> ...
18:18:23 <kmc> eff you lambdabot
18:18:30 <ben> I'd like to call myself a #haskell regular and being compared to Oleg at any level kind of scares me
18:18:49 <shawn> I was amazed at the WAI server performance numbers I saw
18:18:52 <edwardk> ion: currently no. though i was talking to the hmatrix guy for a while. if we finished breaking out the licensing we can probably make it work
18:18:57 <kmc> Aune, sure, you have to take it for what it is, but I don't think it's entirely irrelevant.  shootout tells us "how far can we push the envelope on core algorithms / datastructures code"
18:18:57 <bfig> is oleg super good at haskell_
18:19:07 <kmc> if you look at ByteString etc., it's written in similar insane style
18:19:12 <blackdog> ben: haskell performance tuning is a pretty nichey thing
18:19:18 <newsham> ddarius: i like control aplicative.. i was just avoiding an import
18:19:26 <newsham> sicne i already have fmap and ap... same deal
18:19:32 <ben> Didn't Oleg invent iteratees? I thought those were a performance tuning thing.
18:19:36 <edwardk> does anyone involved in cloud haskell/remote haskell sign in here?
18:19:49 <copumpkin> edwardk: I think dcoutts is involved isn't he?
18:20:07 <kmc> ben, i thought the advantage of iteratees is safety and solid semantics, compared to lazy IO
18:20:11 <bfig> i'm having doubts with a certain piece of code: i have a function FilePath -> BM (), and i have to read a file... what are my options for IO?
18:20:12 <edwardk> @ask dcoutts cloud haskell _really_ needs an applicative instance ;)
18:20:13 <lambdabot> Consider it noted.
18:20:22 <shawn> I never thought to benchmark Oleg's code but I've read several posts or papers of his that impressed me with his insight
18:20:26 <ben> hm
18:20:43 <Aune> To measure most of the things I want to know you would have to do some large scale statistical experiments on undergrads where people are educated in certain languages in certain orders and a lot of information is collected. While harder to quantify in a precise sence it is by no means impossible. Just much more expensive
18:20:58 <kmc> yes, there is no money for that kind of study
18:21:27 <kmc> the conceivable source of money is that Oracle or Microsoft pays for a study which proves that, surprise, Java / C# is the best language
18:21:33 <kmc> but I think even that is pretty far-fetched
18:21:39 <Philippa> it's also hard to know what's appropriate
18:22:13 <Philippa> for example: when Haskell gets harder to understand, it's usually because someone's writing something at a level of genericity that'd make the average C++ TMP hacker go catatonic
18:22:28 <Philippa> (or, admittedly, insisting on abusing CPS or something like that)
18:22:47 <Philippa> (the sphagetti code you can write in any half-decent FPL makes BASIC look like a walk in the park)
18:23:03 <kmc> i think it's still true that most performance improvements come from using the right algorithms, data structures, and general code structures
18:23:06 * monochrom walked BASIC in the park :)
18:23:11 <kmc> not from language-specific tricks
18:23:25 <kmc> however, the right algorithms/structures for pure functional code are not generally known
18:23:51 <bfig> :!
18:23:54 <kmc> which explains some (not all) of the phenomenon where performance-optimizing Haskell code involves making it look more imperative
18:23:57 <Philippa> mmm. Haskell's just a nice metalanguage for however you want to expose the right stuff, if you want to work that way
18:23:59 <bfig> sorry wrong tab
18:24:13 <Philippa> don't worry, we won't bang your colon
18:24:26 <monochrom> hehehe
18:24:31 <kmc> you have to keep a perspective on performance stuff, though... think about how many billions of dollars are made every day using slow interpreters for PHP, Python, Ruby
18:24:35 <blackdog> ben: yes, but that's not tuning - that's a fundamental algorithm change.
18:24:40 <copumpkin> :O
18:25:00 <bfig> q
18:25:13 <kmc> learning vim are we
18:25:15 <ben> The best kind of tuning
18:25:28 <bfig> lol. sorry, i'm tabbing in two monitors and there is just no visual cue
18:25:28 <Philippa> kmc: right. So asymptotic factors matter, but so does knowing whether your log term is really going to be bigger than 30 or so
18:25:40 <monochrom> now imagine how many trillion dollars are made if hugs is even slower
18:26:01 <shawn> I would consider even a simple benchmark like the yesod/warp one is more impressive than more corruptable algo tuning - http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
18:26:16 <bfig> as you approach asymptotically to zero efficiency you destroy earth by the sheer amount of money you generate
18:26:35 <blackdog> ben: it's bigger and more important than tuning. that's why i said don-style tuning is nichey:)
18:27:08 <monochrom> to qualify for dons level, you have to write rewrite rules
18:27:31 <monochrom> and then there is the tibbe level where you go modify GHC
18:27:47 <kmc> people who expect Haskell to be clearer than Python, denser than Lisp, and faster than C will be disappointed
18:28:00 <kmc> it can be each of these things but rarely all three at once
18:28:06 <bfig> why would anyone be denser than lisp?
18:28:24 <ddarius> kmc: I want denser than APL.
18:28:42 <shawn> I think that beyond the terse or mathematical stuff, the problem was heap/memory management for the average user
18:28:44 <gentleben> ddarius: you should write in Q
18:28:58 <companion_cube> or pure
18:29:09 <shawn> someone writing python code usually won't spend a sizable fraction of their time tracking down big memory mysteries
18:30:26 <Aune> lets be satisfied with: denser than c++, clearer than APL and faster than Python
18:30:27 <monochrom> part of the memory bloat is still just porting imperative algorithms to haskell rather than using an algorithm designed for haskell (or at least lazy haskell)
18:31:20 <shawn> I saw a Jane St ad today crowing about their commitment to Clojure, probably retargeting me for reading some Clojure blog, did they put out some rationale for moving from ocaml to clojure?
18:31:31 <kmc> i doubt they've "moved"
18:31:41 <shawn> I guess it did mention Schemers welcome too
18:31:47 <shawn> so that's just open arms
18:31:47 <kmc> can you link the ad?
18:31:52 <blackdog> shawn: they advertise in gmail if you subscribe to haskell-cafe too.
18:32:08 <kmc> those weirdo FP langs are all the same, right? ;)
18:32:19 * shachaf used to get Jane St ads all the time.
18:32:33 <shawn> fair enough, it's probably hard to find any FP talent in a world of C# and Java
18:32:34 <kmc> honestly I think keying ads on haskell-cafe is a pretty good strategy no matter what language your company usees
18:32:49 <blackdog> kmc: heh. yeah, i used to hire haskell programmers for perl jobs at optus
18:32:51 <kmc> though maybe the size is small enough that it doesn't matter
18:33:19 <kmc> by the way Jane St. does a lot of work in Excel and VBA, too, but they're not as vocal about it ;)
18:33:22 <shachaf> That's true, because Haskell people are the best people.
18:33:27 * ddarius programs in C#.
18:33:33 <kmc> shachaf, you can tell because you and I are here
18:33:38 <shachaf> kmc: Exactly.
18:33:39 <ddarius> C# also isn't completely horrible for FP.
18:33:39 <shawn> At least in the world of windows it looks like F# isn't too hobbled vs C#
18:33:42 * shachaf puffs out chest.
18:33:58 <ddarius> shawn: In many ways I'd rather program in C# than F#.
18:34:04 <shawn> from what I can tell you could do an xbox live arcade game in F#, that's a lot beter than most of the alternatives
18:34:10 <gentleben> kmc: we are mostly haskell but we use a mixture of excel and R for most of our front end
18:34:13 <blackdog> ddarius: interesting, bos said the same thing in his startup talk
18:34:28 <dgpratt> ddarius: funny I've been coming to a similar conclusion, re: F# vs C#
18:34:45 <kmc> we = who?
18:35:11 <shawn> I haven't actually tried any non-trivial work in F# but wouldn't it basically be the same decision as using Jaskell, Clojure, or Scala on the JVM instead of Java?
18:35:26 <ddarius> Java is horrible.
18:35:29 <shawn> lots of boilerplate in C#/Java that I'd rather avoid
18:35:39 <ddarius> C# is much better than Java.
18:36:06 <monochrom> the devil is in the details. perhaps some details in F# are painful. and C# has LINQ.
18:36:07 <shawn> I haven't used C# in years, so maybe it's a lot better now, used to strike me as pretty much about the same level of nuisance
18:36:28 <kmc> "Jaskell"?
18:36:38 <dgpratt> C# has grown a lot, esp. in its functional aspects
18:36:56 <ddarius> (The JVM is, in many ways, better than the CLR.)
18:37:03 <blackdog> gentleben: what's your company doing?
18:37:19 <ddarius> shawn: C# 1.0 was Java on the CLR.  Even 2.0 was much better and the latest versions are rather nice.
18:37:29 <gentleben> blackdog: trading
18:37:31 <steakknife> Sun's and one other JVM have significant production deployment.
18:37:44 <monochrom> IBM's JVM
18:37:46 <hpaste> edwardk pasted “fun” at http://hpaste.org/53582
18:37:50 <steakknife> Yeap.
18:37:58 <kmc> gentleben, which trading company
18:38:08 <gentleben> a small one
18:38:17 <shawn> http://en.wikipedia.org/wiki/JVM_Languages Jaskell is a Haskellish JVM lang
18:38:31 <djahandarie> ddarius, what do you not like about Java?
18:38:41 <djahandarie> Where Java does not include the Java libraries or the JVM.
18:38:46 <steakknife> Java is three things
18:38:53 <steakknife> API, language and runtime.
18:39:11 <gentleben> the java runtime is one of the most performant out there
18:39:23 <shawn> I favor Ruby over Python but I'll still concede they probably have roughly the same leverage and friction
18:39:29 <steakknife> It's been beaten on for years and years.
18:39:30 <gentleben> all those PhDs sitting around optimizing it
18:39:39 <shawn> I mean Python over Ruby
18:39:40 <steakknife> JRuby #ftw
18:39:41 <kmc> i think there's a big community difference between Ruby and Python
18:39:42 <shawn> either way
18:39:45 <kmc> 's what I hear anyway
18:39:59 <gentleben> little JIT tricks to make it faster, its mostly a manpower problem
18:40:37 <steakknife> kmc: more than how many ways there are to do something? :)
18:40:47 <ddarius> djahandarie: The lack of concise higher order functions.  The lack of type inference.  It's disguisting type-erasure semantics.  Covariant mutable arrays (though C# has this too).  Verbose syntax.  The lack of (C#) properties.  The lack of operator overloading.
18:41:10 <ddarius> djahandarie: I also hate much of the libraries, though the C# libraries are rarely much better.
18:41:17 <ben> What about unsigned integer types? Are they in now?
18:41:20 <shawn> LLVM or compiling minimal VM images probably offers a way around some of the deployment lock JVM/CLR has, so eventually they'll lose much of the advantage
18:42:19 <shawn> Really if you have to deploy to a JVM anyone here would be better off using Scala or Clojure, to taste
18:42:38 <steakknife> osgi bundles are the world of the devil.
18:42:46 <shawn> Scala papers over a lot of the Java garbage
18:42:49 <steakknife> s/world/work/
18:43:12 <gentleben> scala papers slowly over the JVM, and their release testing leaves something to be desired
18:43:35 <gentleben> i found a really nasty bug in one of their collections that dropped data
18:43:59 <steakknife> i hear terracotta has improvements that are being consider for inclusion in JDK 8.
18:44:13 <gentleben> i used scala extensively before switching to haskell
18:44:39 <kmc> my understanding is that Scala attempts to incorporate all Java concepts as first-class, and is somewhat monstrous as a result
18:44:53 <kmc> Clojure asks that you buy into the Clojure way up-front, and provides Java libs more as a FFI
18:45:36 <gentleben> kmc: IMO they made some really bad choices with scala, the compiler is slow and tends to produce code that is much slower than java code
18:46:01 <gentleben> kmc: so we kept moving important bits of scala to java to increase perf
18:46:22 <gentleben> eventually it was like, why are we doing this
18:46:22 <kmc> sucks
18:46:50 <gentleben> however when i used it for hadoop it was great, i would do that again
18:47:06 <gentleben> very little code and hadoop is already so slow you don't notice
18:48:13 <steakknife> a flea on the elephant's back.
18:48:44 <gentleben> more or less
18:49:18 <gentleben> once you are on a big cluster the actual executing code is usually not the bottleneck
18:49:32 <gentleben> network almost always, sometimes disk
18:49:50 * steakknife used to be an hpc sysadmin in another life.
18:50:07 <kmc> is hadoop not used for many embarrassingly parallel tasks?
18:50:15 <steakknife> let me tell you about infiniband.
18:50:33 <kmc> btw does anyone want to talk about Haskell?
18:50:37 <steakknife> joking, no rants tonight
18:51:18 <gentleben> steakknife: in finance infiniband has had quite the uptake
18:52:02 <steakknife> gentleben: sdr/ddr is really cheap these days, sensible for webhosting too.
18:53:16 <steakknife> parallel conversation. . . how many good paxos (CP/FP) libraries are available for haskell?
18:53:22 <gentleben> do any of the haskell db drivers for mysql offer connection pooling?
18:53:50 <simon> Text.ParserCombinators.* is Parsec2, right?
18:53:53 <gentleben> steakknife: I know of 1 (don't know if its good), you know of any?
18:54:04 <ddarius> simon: Or Parsec 3's compatibility layer.
18:54:20 <simon> ddarius, ah, but it should have the same interface.
18:54:33 <ddarius> simon: Modulo some very minor gotchas, yes.
18:54:35 <steakknife> gentleben: http://stackoverflow.com/questions/1141677/concurrent-db-connection-pool-in-haskell
18:55:21 <steakknife> gentleben: looking for something similar to zookeeper or doozer.
18:55:45 <gentleben> steakknife: be very very careful, don't believe the hype
18:55:59 <steakknife> gentleben: obviously a DLM is something like ZFS that you want to just !@$*% work.
18:56:31 <gentleben> steakknife: well they are extremely hard to test and have lot of edge cases
18:57:24 <steakknife> gentleben: That's why it seems ZK is the only game in town.
18:57:29 <gentleben> steakknife: I talked to the ZK guys and they were like "yahoo uses it and has never lost data", i asked how they measured that, they waffled on for 20 min
18:57:53 <gentleben> a good distributed state manager is very hard to test
18:58:02 <steakknife> gentleben: I used to go to the meetups on campus.
18:58:11 <gentleben> the one at microsoft was tested for a couple years
18:58:15 <steakknife> gentleben: was thinking about using OCFS2 just for that.
18:58:17 <gentleben> at MSR
18:58:42 <steakknife> gentleben: all derived from VMS implementation, which seems to have sufficient history.
18:58:58 <gentleben> seems ok
18:59:13 <gentleben> one of the things i want to do is build a paxos implementation in agda
18:59:15 <steakknife> gentleben: OCFS2 can apparently store arbitrary data in addition to locks.
18:59:34 <steakknife> (in the dlm of course)
18:59:36 <gentleben> it would be much easier to test for correctness
19:00:05 <gentleben> i built part of one in f#
19:00:13 <gentleben> but agda would make it much easier
19:01:16 <ion> edwardk: Ok, thanks
19:03:54 <steakknife> gentleben: fast paxos, yeah?
19:04:01 <gentleben> yeah
19:04:32 <companion_cube> you can do networking in agda?
19:04:35 <steakknife> classic seems to fit more for cloud-to-cloud.
19:05:18 <steakknife> is boundary (yes, erlang shop i hear) working on some ridiculous network stuff?
19:05:49 <steakknife> of the share nothing ever sort.
19:21:32 <kmc> companion_cube, you can call arbitrary Haskell code from Agda
19:21:52 <companion_cube> nice
19:22:06 <companion_cube> cloud agda...
19:27:28 <ion> I wonder if Jeff Epstein (the author of Cloud Haskell) is on IRC?
19:28:00 <monochrom> likely not
19:46:38 <shawn> steakknife: as a practical matter, you could just use google's paxos datastore for longer term storage
19:47:52 <steakknife> shawn: i could.  this project cannot.
19:47:59 <shawn> latency?
19:48:18 <steakknife> shawn: uncountable practical concerns.
19:48:33 <shawn> are you using any cloud storage?
19:50:16 <steakknife> shawn: this isn't for storage.
19:52:32 <steakknife> shawn: there is an interesting related problem . . .
19:52:57 <steakknife> steakknife: google uses chubby instead of dns in some cases.
19:53:16 <shawn> chubby for the locks
20:04:11 <shawn> skimming the cloud haskell paper, my intuition is that solutions to large scale distributed problems don't have much to do with serialization formats.  Assume you're going to pass json over http between your haskell cores, really any discussion of the wire format or IDLs is a waste of time
20:05:01 <kmc> you may not care about the format, but you care a lot about what can and can't be serialized
20:05:44 <shawn> I'm assuming a message doesn't include code that's going to be run, so data is data
20:06:51 <kmc> Haskell data structures can contain many things which are tricky to serialize
20:07:20 <kmc> functions, IO actions, mutable variable references, handles to resources opened by the OS
20:07:27 <kmc> and thunks or closures which invisibly contain these
20:07:41 <shawn> how is a another computer going to make use of your local handle?
20:07:50 <kmc> exactly
20:08:07 <danharaj> It's a breach of abstraction to serialize haskell data structures IMO.
20:08:44 <kmc> from the abstract: "A key contribution is a method for serializing function closures for transmission across the network"
20:09:32 <shawn> I guess I'm still trying to figure out what they're contributing over, say, a REST function closure across teh network
20:10:13 <kmc> the paper I'm reading does not seem to discuss the wire format much
20:10:23 <kmc> it's all about the Haskell API to this functionality
20:10:26 <shawn> http://eg.is/function?closure:foo
20:10:38 <kmc> what
20:10:48 <kmc> i'm reading: Towards Haskell in the cloud, Jeff Epstein, Andrew Black, and and Simon Peyton Jones. Haskell Symposium, Tokyo, Sept 2011.
20:11:06 <shawn> I've got it in front of me
20:17:18 <Steven807> For those who were around earlier and saw my question about building Haskell: I found the answer.  It turns out "make install" doesn't work, but "make" _then_ "make install" works.  D'oh, I lost about 4 hours on that little problem.. :-/
20:18:32 <shawn> :winces
20:20:31 <kmc> Steven807, building Haskell?
20:20:47 <Steven807> yah — I had some problems compiling from source
20:20:52 <kmc> compiling what?
20:20:58 <kmc> Haskell is a language, not a piece of software
20:21:06 <steakknife> shawn: chubby isn't just for locks, it's for super-important things like where is my *(&!%ing master node.
20:21:28 <Steven807> Ghc in various versions — 7.0.4, 6.10.4, g.12.3...
20:21:32 <kmc> ah
20:21:33 <Steven807> 6.12.3
20:22:04 <Steven807> Yeah, I misspoke (mistyped) — it's been a while since I looked at other Haskell systems than GHC; I shouldn't conflate them.
20:22:19 <kmc> the other thing I thought you might have meant is Haskell Platform
20:22:22 <kmc> which is why I asked :)
20:35:19 <ybit> so, monads are the reason to use haskell over clean?
20:35:42 <shachaf> No.
20:35:49 <ybit> shachaf: then why?
20:35:49 <blackdog> ybit: no. you can make monads in anything.
20:36:05 <blackdog> bigger community, more active development, more libraries
20:36:10 <shachaf> The main reason might be that Haskell is popular.
20:36:21 <ybit> http://www.haskell.org/pipermail/haskell-cafe/2006-January/013735.html
20:36:32 <dobblego> "monads are useful" is a reason to use monads
20:36:35 <ybit> there isn't much of an argument in that correspondence either
20:36:52 <blackdog> and it's five years old:)
20:37:10 <ybit> blackdog: but the only reasoning here is large community, etc.
20:37:17 <ybit> larger library
20:37:25 <Cale> Haskell has more features than Clean
20:37:31 <ybit> such as?
20:37:48 <ybit> not trolling, just curious
20:38:15 <Cale> Almost every GHC type system extension has no counterpart in Clean, for example.
20:39:07 <Cale> Hey, has anyone else had weird problems with Google and Firefox lately? I'm getting immediately redirected to a blank search page whenever I use the search bar.
20:39:11 <Cale> (starting today)
20:39:47 <ion> Try with a fresh profile and/or with extensions disabled.
20:40:06 <ybit> +1 ion
20:40:11 <shachaf> Does there exist a person who uses Clean?
20:41:27 <Cale> Oh, Clean actually does support existentials, so that's something :)
20:41:52 <Cale> And it supports constructor classes now, which it took a good bit longer to implement than Haskell.
20:41:54 <ion> It seems neither Unclean nor Dirty seem to exist as programming languages.
20:42:22 <ybit> ..because programmers like to be tidy
20:42:31 <Cale> The Clean guys are working on a front end for their compiler to accept Haskell code though, so...
20:42:36 <companion_cube> ion: Unclean has been renamed "perl" since
20:42:53 <ybit> *rimshot*
20:43:44 <ybit> in conclusion..
20:45:09 <ybit> why haskell instead of clean: popular, larger community, more devs, more libs, more features (one listed)
20:45:22 <ybit> not much about the language :\
20:45:33 <ybit> guess i should do more research over the coming weeks
20:45:35 <blackdog> ybit: they're not hugely different
20:45:41 <blackdog> i think clean has uniqueness typing?
20:45:45 <ybit> yes
20:45:50 <ybit> versus monads
20:45:54 <copumpkin> no, not versus monads
20:45:55 <ion> companion_cube: And Dirty as PHP?
20:46:00 <dobblego> no
20:46:03 <ybit> copumpkin: take it up with wikipedia
20:46:20 <copumpkin> ybit: monads are still useful even in the presence of uniqueness typing
20:46:22 <blackdog> ybit: you can have monads in anything. haskell just happens to use them for IO, as well as a bunch of other things.
20:46:24 <dobblego> if one were to correct all wrong things on wikipedia, one would be very busy indeed
20:46:25 <ybit> !wikipedia clean programming language
20:46:30 <ybit> something like that
20:46:37 <dobblego> uniqueness typing is not "versus monads"
20:46:37 <ybit> http://en.wikipedia.org/wiki/Clean_programming_language
20:46:48 <companion_cube> is uniqueness typing related to linear logic ?
20:46:51 <ybit> "Clean's method for dealing with mutable state and I/O is done through a uniqueness typing system, in contrast to Haskell's use of monads."
20:47:12 <copumpkin> for dealing with IO and state in particular, that isn't really wrong
20:47:15 <ybit> ah, blackdog, i see
20:47:28 <ybit> and copumpkin, both of your points are taken
20:47:33 <copumpkin> :)
20:47:36 <ybit> s/taken/understood
20:48:30 <ybit> "In addition, Clean I believe is based on graphs instead of lambda calculus"
20:48:32 <geheimdienst> copumpkin: what do monads help with that can't be done with uniqueness typing? (curious)
20:49:02 <copumpkin> geheimdienst: all sorts of other non-statey monads
20:49:07 <copumpkin> cont, list, etc.?
20:49:24 <copumpkin> generalizing over monad operations
20:49:48 <ybit> http://sequence.complete.org/node/119#comment-688
20:50:20 <ybit> the blog post the comment came from: http://sequence.complete.org/node/119
20:50:25 <copumpkin> ah
20:50:26 <Cale> If I was programming in clean, I'd probably write a monad class and implement the IO monad in terms of uniqueness types for convenience
20:50:38 <copumpkin> ybit: the speed vs. clean issue has changed a lot since 2005
20:51:07 <Cale> (because it's nice once you have a monad library to not have to pass worlds around)
20:51:52 <copumpkin> yeah
20:52:06 <ybit> i wonder why the language shootout doesn't have clean on a quad-core
20:52:18 <Andres_> e
20:52:19 <copumpkin> does it even do multi-threading?
20:52:25 <ybit> beats me
20:52:25 <copumpkin> Andres_?
20:53:26 <ddarius> copumpkin: Consider yourself harassed, unless my harassment is no longer necessary ... ?
20:53:27 <Andres_> hi, just got here from tryhaskell :P
20:53:47 <ddarius> Cale: There are IO monads in Clean, but I don't think they are used often.
20:53:50 <ybit> Andres_: welcome!
20:54:09 <Cale> Well, it's obvious enough how to write the IO monad
20:54:10 <ddarius> There are some benefits to the linear world passing style and they have syntax to make it not be so bad.
20:54:26 <ybit> i searched for concurrency on clean's wiki and it tells me i don't have permission to edit this page, eek
20:54:32 <copumpkin> ddarius: DMV is closed over weekend but I'll go next week :)
20:54:36 <ybit> someone needs to fix that
20:54:42 <ddarius> copumpkin: Good.
20:54:56 <kmc> what practical software is written in Clean?
20:55:23 <ybit> kmc: i'll have to google
20:55:39 <ybit> i'm curious why clean has been faster
20:55:51 <ybit> and i'm curious how it handles concurrency
20:56:13 <kmc> ybit, I guess others explained this, but uniqueness types don't replace monads in general.  they could replace the IO monad
20:56:46 <kmc> it's a common fallacy that Haskell's monads are about impurity or side effects, but that is only one use case
20:57:11 <ybit> http://wiki.clean.cs.ru.nl/Functional_Programming_and_Parallel_Graph_Rewriting
20:57:14 <ybit> http://www.st.cs.ru.nl/papers/1993/plaseek93/Ch15.ConcClean.ps
20:58:09 <copumpkin> I wonder if uniqueness types could give us a correct DList type
20:58:41 <ybit> kmc: yes, understood, pero thanks for reiterating
20:59:29 <ybit> ugh
20:59:31 <ybit> but
20:59:50 <copumpkin> italian or spanish?
21:00:04 <ybit> spanish, i've been studying for my spanish lessons tomorrow morning
21:00:17 <copumpkin> ah :)
21:00:19 <ybit> it looks silly in the middle of an english sentence
21:00:24 <copumpkin> mucho silly
21:00:27 <ybit> :P
21:00:32 <copumpkin> (or muy, if you're careful)
21:00:40 <ybit> si
21:01:17 <ybit> i wonder how well concurrent clean performs in comparison to haskell
21:01:47 <copumpkin> install it and find out :)
21:02:01 <Cale> What's not to like about the current DList type (apart from the fact that using functions directly is basically as easy to work with most of the time.
21:02:31 <Cale> )?
21:02:33 <ybit> clean just lacks in libraries is all
21:02:51 <copumpkin> Cale: it has way more inhabitants than it should have
21:02:53 <ybit> and a community, but that's a chicken/egg problem i think
21:03:04 <u_> anyone here doing the ants ai challenge in haskell?
21:03:14 <copumpkin> but I'm not sure that's fixable in any useful way without way crazier types
21:03:20 <u_> pleees? :(
21:03:21 <ybit> u_: i am, jmcarthur mentioned it to me
21:03:32 <ybit> u_: also #aichallenge
21:03:38 <u_> thanks ybit
21:03:40 <ybit> np
21:03:43 <ybit> gl!
21:03:44 <u_> what os are you on?
21:03:48 <ybit> ubuntu
21:03:55 <u_> i have a mac :l
21:04:05 <ybit> better than win, cheer up :)
21:04:13 <u_> and i can't get ubuntu on it due to some obscure graphical bug
21:04:18 <ybit> hmm
21:04:24 <u_> haskell seems to have problems on macs. i can't get the starter kit bot to work
21:04:27 <ybit> u_: you might try #ubuntu for such problems
21:04:48 <ybit> u_: i take it you downloaded the haskell platform?
21:04:50 <u_> i've looked around before, as of 3 months ago there was no fix
21:04:52 <u_> yes
21:05:08 <ybit> what error are you receiving?
21:05:30 <u_> SandboxError: Failed to start ['./sample_bots/MyBot']
21:05:44 <ybit> sec
21:06:13 <NemesisD> anyone have a suggestion for blocks of text in haskell source? i need to write some specs for some code that parses JSON. i could put them in a file but there's no good reason why my tests should require IO
21:06:47 <Cale> NemesisD: unlines?
21:07:25 <NemesisD> Cale: it isn't very readable that way. i'd prefer to write the json in expanded form, i.e. { and } get their own lines. it is verbose but very easy to read
21:07:26 <u_> http://www.haskell.org/haskellwiki/Poor_man's_here_document
21:07:35 <u_> doesn't look that good
21:07:38 <kmc> there are various quasiquoters for here documents on Hackage
21:07:56 <c_wraith> is there a quasiquoter for generating JSON literals?
21:08:03 <c_wraith> ...  for whatever JSON library you want
21:08:11 <Cale> u_: That first thing is really evil
21:08:17 <kmc> can never have enough JSON libs
21:08:23 <NemesisD> yeah all of those examples make my skin crawl if i recall correctly
21:08:28 <Cale> I would just go with unlines
21:08:41 <blackdog> the quasiquoter one isn't too horrible
21:08:47 <kmc> > "foo\      \bar"
21:08:48 <lambdabot>   "foobar"
21:08:53 <kmc> this worke over newlines too, iirc
21:09:01 <hpaste> geheimdienst pasted “blocks-of-text” at http://hpaste.org/53584
21:09:14 <geheimdienst> NemesisD: ^^ some suggestions
21:09:50 <NemesisD> yeah. i'd like the one with backslashes except it is going to *hurt* if i'm doing proper json
21:10:02 <NemesisD> since the keys in json objects must be surrounded by "
21:10:17 <Cale> NemesisD: Wait, you're constructing JSON in the strings?
21:10:27 <NemesisD> Cale: the string is a JSON string
21:10:29 <geheimdienst> NemesisD: that's true, i've sometimes wished for something like pythons triple-quote thingy
21:10:33 <Cale> (You know there are JSON libraries, right?)
21:11:01 <NemesisD> Cale: im usin Aeson to parse the JSON. i want a JSON string literal in the test so i can assert it parses to what i want
21:11:56 <NemesisD> i don't mind the quasiquote one either
21:12:01 <geheimdienst> you could also put it in an extra plaintext file, and do readFile
21:12:10 <geheimdienst> and yeah, i guess TH is what looks most promising
21:12:44 <ybit> u_: sorry internet went went bb for a few mins, i'm sure it's a simple solution, i'll try to look at it tomorrow afternoon, about to get ready for bed
21:13:00 <u_> ybit: thanks man
21:13:04 <ybit> u_: heathmatlock@gmail.com if you want to ask me there or, i'm always on here
21:13:19 <NemesisD> geheimdienst: thats what i wanted to avoid. i'll do it if i have to but there's not really a good reason why i should need IO for these tests, unless you consider the lack of heredocs a reason :P
21:13:36 <Eduard_Munteanu> Wgt not read both JSON and the correct parse from external files? Then maybe you could have a generic tester.
21:13:36 <NemesisD> i think im gonna see if the quasi quote method works out
21:13:37 <ybit> u_: i might get second wind before passing out
21:13:48 <Eduard_Munteanu> *Why
21:14:10 <NemesisD> Eduard_Munteanu: the correct parse is a pretty complex haskell type and much easier to construct in code than in a Readable form
21:15:19 <u_> ybit: second wind?
21:15:19 <Cale> One might also ask why do unit tests at all, if you have both a JSON parser and JSON prettyprinter, you can test them against one another using QuickCheck :)
21:20:09 <Cale> (this includes JSON documents which are supposed to fit a specified schema, so long as you have a way to construct elements of that schema)
21:23:39 <mkscrg> hey, what's the name of that extension that lets you write negative type constraints?
21:23:55 <Cale> Such an extension exists?
21:24:59 <ddarius> There isn't.  There's a hack that sort of gives you something like that by Oleg.
21:25:07 <Cale> Negative typeclass constraints would go against the open design of typeclasses (you can always add new instances in a future module, so it can never be asserted while compiling a module that any given instance doesn't exist)
21:25:34 <mkscrg> hmmmm. i guess i dreamed that one...
21:27:26 <hpaste> NemesisD pasted “heredoc fail” at http://hpaste.org/53586
21:27:41 <NemesisD> what am i doing wrong?
21:27:54 <mkscrg> so i want to write a generic curry function that curries a function of a nested tuple, like this http://hpaste.org/53587
21:28:12 <mkscrg> except that raises errors about conflicting instances
21:28:16 <mkscrg> thoughts?
21:28:49 <ybit> u_: i didn't even think to ask, how are you running playgame.py?
21:29:20 <ybit> i.e. what are the arguments you are giving it
21:29:27 <Cale> You'll probably have to use OverlappingInstances, at the very least
21:29:43 <u_> i tried the play_one_game script and invoked it manually once
21:29:49 <ybit> u_: i can replicate your error by using ghci haskell/MyBot.hs
21:29:53 <u_> lemme see about the manually invoked one
21:30:15 <u_> i used ghc --make
21:30:19 <ybit> ah
21:30:28 <u_> i'll try ghci...
21:30:32 <ybit> nope
21:30:33 <ybit> don't
21:30:52 <ybit> python tools/playgame.py "runhaskell <path-to-your-bot>/MyBot.hs" "python tools/sample_bots/python/HunterBot.py" --map_file tools/maps/example/tutorial1.map --log_dir game_logs --turns 60 --scenario --food none --player_seed 7 --verbose -e
21:31:33 <ybit> the magic of brushing your teeth! things just come to you! ;)
21:31:56 * u_ hadn't even heard of runhaskell o.o
21:32:04 <ybit> it's how you run .hs files
21:32:14 <u_> really? huh
21:32:20 <u_> i was just using leksah up till now
21:32:32 <ybit> i suppose you could compile them, chmod +x, and then execute
21:32:38 <ybit> the .o file
21:32:58 <Cale> I usually either load things in ghci, or I compile them
21:33:05 <u_> hehe
21:33:10 <u_> i tried ghci and it worked!
21:33:16 <ybit> heh
21:33:20 <ybit> okay
21:33:22 <u_> thanks man
21:33:32 <ybit> i apparently didn't help you, but yw :)
21:33:58 <ybit> how did you run the hs files with ghci?
21:34:00 <u_> well i didn't even know you could use ghci that way, so you did :) do you know how the contest organizers will run it once i send it to them?
21:34:44 <ybit> probably just like they are doing now, i really haven't read the rules that much
21:35:02 <NemesisD> anyone? i'm not so well versed in TH/QQ (i.e. i know nothing about it)
21:35:06 <u_> well as long as they don't do ghc --make on a mac i'm probably fine
21:35:19 <ybit> u_: http://aichallenge.org/problem_description.php and http://aichallenge.org/specification.php might help yout
21:35:22 <ybit> you out*
21:35:47 <u_> O.o in the game it produced, only LeftyBot gathered any food... the rest just sat there
21:35:52 <ybit> u_: you'll be fine, they know how to run haskell programs, it's automated :)
21:36:13 <ybit> and teams take turns, so speed isn't an issue
21:36:35 <ybit> hah, have you written anything?
21:36:47 <u_> i heard there was a 100ms limit or so
21:37:09 <u_> nope but now i can start!
21:37:38 <Cale> In that case, you'll probably want to compile with -O2 (if the problem is that your program is too slow)
21:38:03 <u_> the supplied bots aren't doing anything either except for lefty
21:38:14 <u_> actually, wait, i saw one move just now
21:38:17 <u_> they're just really dumb :P
21:39:24 <ybit> NemesisD: i havent' actually used qq or th yet
21:40:45 <u_> Cale: but aren't i letting them compile it?
21:41:04 <ybit> NemesisD: have you tried #yesod, they seem to be very familiar with this
21:41:18 <NemesisD> ill check there
21:41:20 <Cale> u_: Oh, perhaps, but if there are limitations on performance, probably they'll be nice and compile with optimisations
21:42:54 * ybit 21:04 < kmc> it's a common fallacy that Haskell's monads are about impurity or side effects, but that is only one use case
21:43:06 <ybit> kmc: can you list a few more use cases?
21:43:17 <Cale> nondeterminism, parsing
21:43:17 <MostAwesomeDude> :t Data.Attoparsec.parseWith
21:43:18 <lambdabot> Couldn't find qualified module.
21:43:25 <MostAwesomeDude> Hm.
21:44:19 <blackdog> ybit: so, for instance, you can do comprehensions in the list monad:
21:44:40 <blackdog> > do a <- [1..3]; b<- ['a'..'c']; return (a,b)
21:44:41 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
21:45:01 <u_> well great, the game starts but the starter haskell bot is timing out
21:45:08 <Cale> The advantage being that you have all the stuff in Control.Monad which works in any monad
21:45:20 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
21:45:20 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
21:45:38 <Cale> > filterM (const [True, False]) [1,2,3]
21:45:39 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:46:14 <Cale> > replicateM 3 [0,1]
21:46:15 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
21:46:46 <Cale> ^^ none of that had much to do with IO or statefulness ;)
21:47:06 <ybit> :)
21:48:05 <mdxbhmt> Polemic question: why this code is so ugly (haskell) http://shootout.alioth.debian.org/u32q/program.php?test=revcomp&lang=ghc&id=3 compared to (python)http://shootout.alioth.debian.org/u32q/program.php?test=revcomp&lang=python3&id=4 , isn't there a nice clean way in haskell too?
21:48:06 <Cale> Some library defining a monad basically just says something about the shape of its API, and lets us use these polymorphic functions which work with anything whose API fits that particular shape (though saying that is really just recognising that Monad is a typeclass)
21:48:11 <MostAwesomeDude> Cale: I have a Parser Packet (from Attoparsec) and want to make a Parser [Packet], some sort of thing which I can continuously kick to get an indefinite parser.
21:48:26 <MostAwesomeDude> Hm, what do I want...
21:48:30 <Cale> MostAwesomeDude: replicateM?
21:48:31 <kmc> mdxbhmt, the shootout code is rarely the nicest, cleanest way
21:48:36 <kmc> mdxbhmt, it's optimized for speed
21:48:37 <MostAwesomeDude> @hoogle Monad m => m a -> m [a]
21:48:37 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
21:48:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:48:37 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:48:44 <MostAwesomeDude> Aha.
21:49:03 <Cale> oh, or many
21:49:07 <MostAwesomeDude> Cale: I bow to your knowledge.
21:49:21 <Cale> Probably Attoparsec defines a combinator called many
21:49:25 <MostAwesomeDude> I'm still trying to understand exactly *how* these things work.
21:49:27 <ybit> aye, falling asleep at the keyboard
21:49:33 <Cale> Let me look, I only use normal Parsec for the most part
21:49:35 <kmc> mdxbhmt, in their tests the Python code takes 4 times as long to run
21:49:40 <mdxbhmt> kmc: that case is one python is very close to haskell, i would say that the optimization isn't workin so well
21:49:43 <ybit> can't keep up with Cale's output
21:49:58 <ybit> ..must rest
21:50:00 <Cale> yeah, many :: Alternative f => f a -> f [a]
21:50:09 <MostAwesomeDude> Cale: Aha, Data.Attoparsec.Combinator.many
21:50:14 <kmc> mdxbhmt, factor of 4?
21:50:14 <ybit> will reread what didn't sink in tomorrow
21:50:17 * ybit waves gn
21:50:23 <Cale> and you'll find that Parser is an instance of Alternative
21:50:32 <MostAwesomeDude> And so I could use that to get a parser which handles an indefinite number of a in Parser a.
21:50:57 <MostAwesomeDude> And then I just feed it ByteStrings when I get them from the network.
21:51:04 <kmc> mdxbhmt, anyway, "why isn't the optimized code faster" is a different question from "why is the optimized code ugly"
21:51:10 <kmc> i hope i have answered the latter
21:51:47 <ybit> wait!
21:51:59 <ybit> Uniqueness typing: Allows descructive updates on objects with only one reference (prepend a '*')
21:52:04 <ybit> that's why clean is faster
21:52:21 <ybit> cache locality, just like ml
21:52:25 <kmc> mdxbhmt, also, I've heard that a lot of the micro-optimizations in shootout code are no longer necessary on recent GHC
21:53:05 <ybit> it still claims to be purely functional
21:53:05 <kmc> mdxbhmt, when performance is the only goal, there is a tendency to go crazy with unboxing etc, whether or not it helps
21:53:15 <ybit> ..and i thought purely functional meant no destructive updates
21:53:21 <kmc> ybit, Haskell also has destructive updates
21:53:25 <kmc> see: IORef, MVar, etc.
21:53:32 <ybit> huh
21:53:32 <mdxbhmt> kmc:  well, I was comparing to other code where haskell could go 28* faster, but the problem could have a bottleneck
21:53:38 <kmc> yeah
21:53:44 <kmc> i don't know why it's only 4 times faster in this case
21:53:48 <Cale> ybit: You don't *write* the destructive updates in that case, the compiler proves that it's okay to destructively update something and does it for you.
21:54:19 <ybit> "Generates highly optimized assembly code"
21:54:27 <ybit> maybe that's where it's getting the performance boost
21:54:49 <u_> ybit: turns out ghci and runhaskell both work, but ghci just makes it time out on the first turn
21:54:52 <ybit> whatever those optimizations are
21:55:10 <ybit> u_: how are you running that with ghci?
21:55:15 <ybit> are you giving ghci some flag?
21:55:19 <u_> just ghci filepath
21:55:25 * ybit doesn't know how to run .hs files with ghci
21:55:37 <u_> but... didn't you just say it a few minutes ago?
21:55:41 <ybit> nope
21:55:48 <vharishankar> Isn't it runghc?
21:55:56 <Cale> You load them, and then type main at the prompt
21:55:57 <ybit> yes
21:56:06 <mdxbhmt>  I should in fact try to write a simpler code, and see how bad it performs. I'll learn haskell and optimizing that way, and see if the uglyness is **really** justified
21:56:09 <ybit> runhaskell is an alias for runghc
21:56:11 <ybit> iirc
21:56:29 <Cale> mdxbhmt: yes!
21:56:46 <Cale> mdxbhmt: You should decide using the excellent GHC profiling tools what needs optimisation
21:56:50 <u_> huh... you can't...
21:57:01 <ybit> u_: i think what you are doing by using ghci is attempting to load your haskell file in an interactive session of ghc, and not actually execute the code, which is why it's timing out
21:57:03 <u_> well that explains the timing out. hehe
21:57:15 <u_> "i can replicate your error by using ghci haskell/MyBot.hs" is what you said
21:57:25 <u_> ybit: yeah
21:57:29 <ybit> yeah, you're error :)
21:57:45 <mdxbhmt> Cale: i'll see if I have any luck  D:
21:58:09 <u_> random ghci question: is there a way to clear bindings?
21:58:25 <ybit> good question
21:58:57 <mdxbhmt> reload?
21:58:57 <Cale> mdxbhmt: The other trick to it is learning to think about your program's evaluation a bit differently. Lazy evaluation (which is just a good approximation of what GHC really does) is inside out from strict.
21:58:58 <ybit> i think you can reassing bindings
21:59:12 <ybit> since ghci uses, what was it.. we discussed this the other day
21:59:30 <mdxbhmt> Cale: what you mean by inside out from strict?
22:00:19 <Cale> mdxbhmt: If you have something like f (g x), in a strict language, you evaluate g x first and apply f to the result
22:00:21 <ybit> variable shadowning, that's what ghci is using to let you "rebind" variables
22:00:26 <ybit> shadowing
22:00:39 <mdxbhmt> u_: do you mean reload the code? maybe :r helps
22:00:42 <Cale> mdxbhmt: Under lazy evaluation, f is applied to g x without evaluating it
22:00:44 <ybit> so i don't know if you need to clear bindings
22:00:55 <ybit> right, sleepy
22:00:58 <ybit> bb
22:01:04 <u_> mdxbhmt: ybit said reload
22:01:05 <Cale> (g x) will only be evaluated when f pattern matches on it (and it will be evaluated at most once)
22:01:28 <copumpkin> at most approximately once
22:01:32 <u_> reload kills everything though. what if i just wanna clear up a few names?
22:01:48 <mdxbhmt> u_: maybe there is a clear *binding*
22:01:56 <u_> nope
22:02:07 <mdxbhmt> Cale: So you mean that i should worry first of f then g?
22:02:24 <Cale> I just mean that f gets to decide what happens.
22:02:30 <Cale> Consider something like foldr
22:02:35 <Cale> @src foldr
22:02:35 <lambdabot> foldr f z []     = z
22:02:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:02:46 <mdxbhmt> yes i see
22:02:49 <Cale> foldr in some sense is O(1)
22:02:49 <ybit> sorry, i have to say this before knocking myself out: clean's license... there's your problem
22:03:01 <ybit> dual license: lgpl and proprietary
22:03:08 <Cale> because it always passes control to something else in one step
22:03:16 <ybit> also.. concurrent clean is free only for non-commercial purposes
22:03:25 <ybit> there, that's why clean loses
22:03:27 * ybit sleeps
22:03:32 <Cale> and only if f decides to pattern match on its second parameter will foldr continue
22:03:46 <Cale> this is what makes it possible for foldr to work on infinite lists:
22:03:55 <Cale> > foldr (\x xs -> (2*x) : xs) [] [1..]
22:03:56 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
22:04:27 <Cale> While foldl on the other hand:
22:04:30 <Cale> @src foldl
22:04:30 <lambdabot> foldl f z []     = z
22:04:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:04:57 <mdxbhmt> I see, foldl is 'strict', it needs the whole list
22:05:13 <Cale> It doesn't do anything but to apply itself to different arguments until it finds the end of the list. It never passes control away to the combining function
22:05:22 <Cale> So what it'll do is build up a large expression
22:05:26 <Cale> foldr (+) 0 [1,2,3]
22:05:32 <Cale> er
22:05:34 <Cale> foldl (+) 0 [1,2,3]
22:05:39 <mdxbhmt> yes, it won't do the computation
22:05:42 <Cale> -> foldl (+) (0 + 1) [2,3]
22:05:48 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
22:05:53 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
22:05:58 <Cale> -> ((0 + 1) + 2) + 3
22:06:10 <blackdog> Cale: is foldl ever preferable to foldl'?
22:06:15 <Cale> blackdog: rarely
22:06:23 <Cale> In the case of reverse, it's somewhat better
22:06:26 <Cale> for example
22:06:40 <ddarius> Not really.  It saves you a ' and a seq that can probably be optimized to nothing anyway.
22:07:38 <Cale> Well, assuming that the compiler isn't doing extra magic, it saves you from computing a bunch of flips earlier than you need to
22:07:51 <ddarius> Who cares?
22:08:06 <mdxbhmt> what's the dif of foldl'?
22:08:10 <Eduard_Munteanu> Presumably it makes sense if the folding operation isn't strict.
22:08:28 <Cale> If that flip was instead something computationally intensive, then you might care
22:08:43 <ddarius> Eduard_Munteanu: In most of those cases, though, foldr makes even more sense.
22:08:43 <Cale> (but then, you're probably better off with foldr anyway)
22:08:47 <Eduard_Munteanu> Though foldr might make more sense then, but I wonder what happens if it isn't associative.
22:08:51 <Eduard_Munteanu> Yeah.
22:09:01 <Cale> You can always foldr and reverse
22:09:06 <Cale> if it's not associative
22:10:47 <ddarius> I think the way to characterize when foldl is best is if you have a function that's "usually" strict but may short-cut and avoid an error and you care about that.
22:11:24 <ddarius> By "error", I mean bottom in general
22:11:53 <u_> or just pointless work
22:12:03 <mdxbhmt> question: can the compiler optimize reverse . reverse to id ?
22:12:37 <ddarius> It -can-.  I don't believe GHC does though.
22:12:41 <Eduard_Munteanu> Through fusion, maybe.
22:12:45 <Cale> mdxbhmt: It would be incorrect to do so though.
22:12:49 <u_> depends what reverse looks like
22:12:51 <Cale> Well, "incorrect"
22:12:55 <ddarius> Cale has a point.
22:12:59 <Cale> In that it would make some nonterminating programs terminate
22:13:00 <mdxbhmt> hmmm?
22:13:01 <u_> if it's an infinite list
22:13:09 <mdxbhmt> well, yes
22:13:18 <mdxbhmt> but in teory is in fact correct
22:13:23 <mdxbhmt> i want to reverse that infinity
22:13:28 <djahandarie> Don't a number of rewrite rules not give a shit about bottoms?
22:13:28 <Cale> It's correct for finite lists
22:13:42 <ddarius> djahandarie: stream . unstream doesn't.
22:14:09 <djahandarie> Right
22:14:16 <MostAwesomeDude> What does reverse [1, 2..] even look like? Does it just hang?
22:14:27 <u_> it should hang
22:14:36 <Cale> Yeah
22:14:42 <ddarius> > reverse [1..]
22:14:43 <blackdog> think you'll run out of memory at some point.
22:14:45 <ion> @src reverse
22:14:47 <lambdabot>   mueval-core: Time limit exceeded
22:14:47 <lambdabot> reverse = foldl (flip (:)) []
22:15:02 <ion> Feel free to see what happens when you expand the definition manually.
22:15:02 <u_> ok i just tried it, i'll get back to you guys once it finishes :P
22:15:17 <mdxbhmt> lambda stop on time, but ghci will prob run out of mem
22:15:21 <Cale> u_: You will likely run out of memory pretty quickly
22:15:22 <Eduard_Munteanu> With optimizations it probably shouldn't blow the stack..
22:15:24 <mdxbhmt> prob not, certainly
22:15:38 <ddarius> Eduard_Munteanu: It won't blow the stack either way.
22:15:40 <Cale> Well, it's not using any stack space
22:15:46 <mdxbhmt> hmmm?
22:15:54 <Cale> because all the pattern matches complete immediately
22:16:05 <Cale> [1..] isn't hard to evaluate
22:16:12 <Eduard_Munteanu> Ah, right, strictness doesn't help there.
22:16:41 <Cale> But it is using lots of heap in the accumulating parameters to foldl
22:16:51 <u_> i actually did try it just to see if it would say <<loop>>
22:16:55 <u_> ouchie
22:17:47 <ddarius> GHC is good at allocating memory quickly.
22:20:36 <Eduard_Munteanu> @faq Can GHC "benchmark" your OOM killer?
22:20:36 <lambdabot> The answer is: Yes! Haskell can do that.
22:21:56 <mdxbhmt> @faq The Game?
22:21:57 <lambdabot> The answer is: Yes! Haskell can do that.
22:22:50 <ddarius> @faq Can Haskell entertain five year olds?
22:22:50 <lambdabot> The answer is: Yes! Haskell can do that.
22:24:06 <mdxbhmt> And haskell for kids it's a proof
22:24:16 <wavewave> hi
22:25:49 <mdxbhmt> hi
22:27:23 <wavewave> anyone have used haskell for GPU programming?
22:28:09 <kmc> sort of
22:28:10 <wavewave> I know of accelerate, but it's last modified in 2010.
22:28:17 <kmc> i wrote a EDSL which produced GLSL code once
22:28:51 <wavewave> kmc: do you have a public library for that?
22:29:02 <ddarius> There are at least a few libraries that either use the GPU or provide interfaces to the GPU.
22:29:20 <kmc> wavewave, no
22:30:22 <ddarius> kmc doesn't believe in publicity.  He got burned by it in his former career as a rock star.
22:30:30 * ddarius continues to elaborate kmc's history whole cloth.
22:30:36 <kmc> i had it all... but i got greedy
22:30:39 <kmc> i flew too close to the sun
22:30:48 <wavewave> ddarius: would you indicate me of those libraries?
22:31:22 <scshunt> btw guys, thanks for the book recommendations. I got the working mathematician one and a friend got Awodey's; we'll compare notes later.
22:31:57 <Eduard_Munteanu> scshunt: you know there's ##categorytheory right?
22:32:06 * ddarius types hackage.haskell.org into a browser, clicks on Packages, then presses /cuda
22:32:18 <scshunt> Eduard_Munteanu: I didn't
22:32:26 <scshunt> Eduard_Munteanu: I may have to go lurk now
22:33:00 <Eduard_Munteanu> It was started by people in here (in case you're thinking it's unrelated to this channel).
22:33:07 <ddarius> There's even a GPU category (with, admittedly only two packages in it and not including accelerate or the cuda package.)
22:33:43 <ddarius> Searching for "GPU" on the package page seems pretty effective.
22:34:19 * Eduard_Munteanu thought Categories for The Working Mathematician wasn't really the best way to go about CT :/
22:34:21 <wavewave> ddarius: thanks.
22:34:57 <Eduard_Munteanu> (well, unless your background makes it suitable, dunno)
22:35:20 <wavewave> anyway, what's overall opinion about the GPU programming experience in haskell now?
22:35:51 <mdxbhmt> If memory serves me well, there was 3 packages for gpu
22:36:10 <mdxbhmt> were*
22:36:35 <wavewave> now I found cuda, opencl, accelerate.
22:38:08 <mdxbhmt> accelerate last time i checked is cuda only
22:38:31 <wavewave> I am most interested in accelerate, but I am sure whether it's mature for some serious use.
22:39:28 <mdxbhmt> i've seen a talk of ManuelChakravarty (accelerate maintainer ) and it seemed quite good
22:39:31 <wavewave> s/sure/not sure
22:40:14 <wavewave> mdxbhmt: do you have a link for the talk?
22:40:15 <mdxbhmt> wavewave: http://vimeo.com/28477220
22:40:27 <wavewave> mdxbhmt: great.. Thnx!
22:41:21 <mdxbhmt> does repa do some gpgpu too?
22:43:05 <mdxbhmt> doesn't seem so, i'm confusing with something else
22:44:11 * wavewave is watching manual's talk. it starts with a cool app.
22:44:48 <blackdog> wavewave: the edge detector?
22:45:06 <wavewave> blackdog: yes.. and some fluid thing too.
22:45:35 <mdxbhmt> the k means also
22:46:36 <mdxbhmt> but i'm surprised accelerate was last modified in 2010
22:47:01 <wavewave> mdxbhmt: that's why I was asking about it just now.
22:47:14 <blackdog> mdxbhmt: check out trevor's github repo - they might just not have done an official release
22:47:26 <wavewave> mdxbhmt: whether it's mature or it's rather stopped.
22:47:28 <mdxbhmt> yes,  probably
22:47:53 <blackdog> mdxbhmt: https://github.com/tmcdonell
22:48:06 <blackdog> last commits about three days ago
22:48:24 <mdxbhmt> wavewave: well, last paper i saw from Chakravarty, it lacked fusion . But it could accelerate quite  a lot compared to cpu anyway
22:49:05 <wavewave> blackdog: oh, good!
22:49:10 <mdxbhmt> wavewave: http://www.cse.unsw.edu.au/~chak/papers/acc-cuda.pdf
22:50:22 <wavewave> does repa use nested data parallelism by the way?
22:50:46 <wavewave> I remember nested data parallelism using [: :] operator.
22:51:33 <mdxbhmt> I think repa only uses cpu instructions
22:51:52 <copumpkin> dph is [: :]
22:51:54 <copumpkin> repa is regular
22:51:57 <copumpkin> doesn't need nestiness
22:51:58 <wavewave> mdxbhmt: I know that part.
22:52:21 <wavewave> copumpkin: so what's the status of [: :] ?
22:52:33 <copumpkin> supposedly will almost be usable in 7.4
22:52:35 <copumpkin> but who knows
22:52:42 <wavewave> it was introduced from 6.10, I remember. right?
22:52:46 <copumpkin> I think so
22:52:51 <mdxbhmt> wavewave: last comment from spj was it's closer to usefull
22:53:06 <wavewave> but I never saw examples using it yet.
22:53:23 <wavewave> mdxbhmt: oh.. do you have a link for that? ;-)
22:53:25 <mdxbhmt> wavewave: did you see spj data paralelism talk?
22:53:49 <wavewave> mdxbhmt: quite some time ago.. so probably not latest.
22:53:55 <mdxbhmt> wavewave: http://www.youtube.com/watch?v=NWSZ4c9yqW8
22:54:26 <mdxbhmt> I think it was this talk that really put me on wanting to learn haskell
22:55:25 <wavewave> mdxbhmt: I think I have watched this one.. it's already at least 1.5 years ago ;-P
22:55:46 <mdxbhmt> wavewave: yes, true
22:55:53 <wavewave> mdxbhmt: given the speed of ghc development, it's too ancient.. ;-)
22:56:01 <mdxbhmt> wavewave: true D:
22:56:12 <mdxbhmt> wavewave:  i think i saw the coment from spj in the last ghc report
22:56:26 <mdxbhmt> wavewave: let me find the link in reddit
22:56:33 <wavewave> mdxbhmt: I see.. sounds very good.
22:57:08 <mdxbhmt> wavewave:  http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2011
22:57:17 <mdxbhmt> wavewave: It's not a guarantee, but it's recent D:
22:58:00 <wavewave> mdxbhmt: Ahh great... the workshop program is now online!
22:58:07 <wavewave> mdxbhmt: great.
22:58:23 <mdxbhmt> and everywhere i see, ghc 7.4 is all the good things
22:58:25 <wavewave> thanks.
22:59:05 <mdxbhmt> have a nice time watching the videos ;p
22:59:50 <wavewave> mdxbhmt: already started GHC status report.. :-P
23:00:22 <mdxbhmt> the audio isn't great, sadly
23:06:26 <wavewave> oh... default signature!
23:07:19 <wavewave> ghc 7.4 should be regarded as ghc 8 :-P
23:24:28 <slack1256> all the parsec documentation i found is old (pre 2007)
23:24:42 <slack1256> what should i read to learn about parsec 3.X
23:25:24 <wavewave> slack1256: yeah, that's unfortunate..
23:26:17 <wavewave> slack1256: as far as I know, there is no parsec 3 documentation. you need to read haddock directly.
23:26:43 <wavewave> slack1256: but if you know parsec 2, it's not very difficult though.
23:27:02 <slack1256> wavewave: learn by doing then. well thanks anyways
23:27:42 <wavewave> slack1256: one thing you need to know is monad transformer for understanding new parsec 3
23:29:09 <ddarius> The original documentation is just as applicable today.  You just use different module names.
23:29:22 <ddarius> And there are a few more functions and bells and whistles.
23:29:59 <slack1256> mmm yeah. guess I'll have to read them also
23:30:22 <slack1256> i just wanted to be lazy and read some 5 pages tutorial ;_;
23:32:18 <slack1256> thanks #haskell goodnight.
23:45:55 <NemesisD> anyone know anything about test-suite in cabal? the module for my main-is runs fine in runhaskell but when i try to run the tests in cabal it looks like it doesn't even try and fails right away with no output
23:49:04 <gienah> NemesisD: I've only tried to run it with stuff like: runghc ./Setup.hs configure --enable-tests; runghc ./Setup.hs build; runghc ./Setup.hs test
23:54:50 <NemesisD> gienah: my steps are: cabal configure --enable-tests --user; cabal build; cabal test --show-details=always
23:54:58 <NemesisD> it just fails immediately
23:55:45 <NemesisD> ah wait i think it might be the module name
23:55:47 <NemesisD> woo!
23:56:09 <NemesisD> so i keep my testing main in Web.MyLibrary.Testing.Main
23:56:14 <NemesisD> but the module had to be just Main
23:56:27 <gienah> NemesisD: that's good that you found the problem
23:58:47 <NemesisD> gienah: that has been haunting me in every package i've worked on.
