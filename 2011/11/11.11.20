00:03:44 <carpi> could someone please tell me how "repe x = x:repe x" produces an infinite list with the element 'x' in it? The reason I ask is that... at no point during the evaluation of 'repe' a list is returned. In that case, how is it possible to use the (:) function, since it expects a list as the 2nd argument?
00:04:26 <shachaf> carpi: A "list" is something that's either a cons or an "empty list" object.
00:04:43 <shachaf> carpi: Since repe x returns a cons, it returns a list.
00:04:57 <shachaf> s/returns/is/
00:05:04 <shachaf> s/$/g/
00:05:25 <shachaf> In particular, "repe x" is of the form SOMETHING : SOMETHINGELSE; it doesn't matter what those things are.
00:05:43 <shachaf> (As long as it type-checks, which we know it does because we just showed that repe returns a list. :-) )
00:08:07 <carpi> if the cons function is an empty list how come something like this doesn't work? "3:"?
00:09:03 <shachaf> "the cons function is an empty list"? What?
00:09:50 <carpi> i thought you said a a list is something thats either a cons or an empty list
00:10:09 <shachaf> Right.
00:10:39 <shachaf> In this particular case, that's an exclusive "or". A list is either a cons (of an element to another list) or an empty list, but it's not both.
00:11:00 <shachaf> carpi: Before trying to understand repe, understand this:
00:11:05 <Sgeo> For an empty list, you have to write out []
00:11:05 <shachaf> ones = 1 : ones
00:15:20 <carpi> shachaf: the only way i see something 'ones = 1:ones' being possible is if somewhere in the definition of cons there is a statement to return an empty list
00:15:39 <shachaf> The definition of lists is something like this:
00:15:50 <shachaf> data List a = Nil | Cons a (List a)
00:16:01 <shachaf> When you define ones = 1 : ones, there is no empty list involved anywhere.
00:16:18 <shachaf> It's just a cyclical data structure. You could even make that particular thing work in C.
00:16:20 <Sgeo> Look at it this way. You try to get the first value of ones
00:16:24 <Sgeo> You see a 1
00:16:32 <Sgeo> Then, the next element comes from the list ones
00:16:42 <Sgeo> So, you get the first element from ones, which is 1
00:16:48 <Sgeo> Then, the next element... etc. etc.
00:19:01 <ion> data Cons a = Cons a (Cons a) deriving Show; ones = 1 `Cons` ones
00:19:03 <ion> ghci> ones
00:19:51 <shachaf> data Cons = Cons Cons
00:25:59 <Yrogirg> what do braces mean in Haskell? e.g. data SF a b = SF {sfTF :: a -> Transition a b}
00:26:18 <carpi> time to dig inside the inner workings of haskel
00:26:58 <shachaf> Yrogirg: They can mean various things.
00:27:05 <shachaf> In this case they mean that you're using record syntax.
00:27:26 <Yrogirg> oh, right
01:12:55 <Sgeo> If I have an expression a `f` (b `f` (c `f` d)), will a be evaluated first, then b, then c, then d, assuming f is strict in its arguments?
01:13:29 <ion> Why do you care?
01:13:55 <Sgeo> ion, I'm going to write an evil prelude and associated tutorial, which completely bastardizes Haskell
01:14:44 <elliott> Please don't.
01:14:45 <shachaf> Sgeo: There are no guarantees about the order things are evaluated in.
01:15:00 <elliott> But yeah, even "seq" doesn't guarantee anything about order.
01:15:17 <Sgeo> Blurgh, it doesn't?
01:15:29 <shachaf> Nope, it just has a strictness guarantee.
01:15:53 <ion> You could see what the specific version you happen to be running of whatever Haskell compiler/interpreter you happen to be running does with Debug.Trace.
01:16:06 <shachaf> Your Haskell environment is allowed to evaluate any of your thunks as much as it likes, as long as it doesn't actually _|_ an expression that isn't _|_.
01:16:37 <elliott> shachaf: I like how you're allowed to wait two hundred years, but not to wait forever.
01:16:42 <elliott> That's a really useful guarantee.
01:16:51 <Sgeo> Suppose x = unsafePerformIO somethingThatShouldntBeUnsafePerformIOed
01:16:59 <Sgeo> And I do x `seq` whatever
01:17:05 <Sgeo> Are you saying x might be performed early?
01:17:08 <shachaf> Sgeo: That's part of what the "unsafe" means.
01:17:19 <elliott> Sgeo: You expect (x `seq` y) not to force x?
01:17:21 <shachaf> elliott: It's completely reasonable for a language spec.
01:17:26 <elliott> You might be looking for `const`.
01:17:31 <elliott> Sorry, `flip const`.
01:17:31 <Sgeo> elliott, I'm expecting x to be forced before y
01:17:37 <elliott> That's not what you said.
01:17:41 <shachaf> > x `flip const` y
01:17:42 <elliott> But no, that's an incorrect expectation.
01:17:42 <lambdabot>   <no location info>: parse error on input `const'
01:17:44 <Sgeo> But not, say, way way before y is evaluated
01:17:51 <elliott> unsafePerformIO (evaluate x >> return whatever) gives that guarantee.
01:17:59 <shachaf> "guarantee"
01:18:11 <elliott> shachaf: The Report's semantics for unsafePerformIO specify that completely, I believe.
01:18:22 <shachaf> Oh.
01:18:40 <elliott> (I think we're a bit too cavalier about standardising that thing. Can't we put it in an addendum at least?)
01:19:22 <Sgeo> So, with x `seq` y, what are possible unexpected behaviors?
01:19:23 <shachaf> Is "evaluate" in the Report too?
01:19:32 <shachaf> Sgeo: It could evaluate y and then x and then return y.
01:19:42 <shachaf> Or it could evaluate them in parallel.
01:19:59 <Sgeo> Hmm, blah
01:20:00 <ion> Or x and then y
01:20:26 <elliott> Sgeo: Here are the entire semantics of seq:
01:20:31 <shachaf> Or it could evaluate x and y five times each.
01:20:35 <elliott> seq _|_ a = _|_
01:20:39 <elliott> seq a _|_ = _|_
01:20:46 <elliott> seq a b = b where both a and b aren't bottom.
01:20:55 <elliott> i.e., (seq a b) is bottom if a or b is bottom, and b otherwise.
01:21:02 <elliott> <shachaf> Is "evaluate" in the Report too?
01:21:06 <shachaf> elliott: Quick, is seq strict?
01:21:06 <elliott> shachaf: That's just for exceptions.
01:21:20 <elliott> unsafePerformIO (x `seq` return y) should do it too.
01:21:34 <Sgeo> I was kind of figuring that x needs to be evaluated at some point in order to determine whether it's bottom. But I guess it doesn't have to do it in any reasonable order
01:21:38 <shachaf> Makes sense.
01:21:49 <shachaf> (Kind of.)
01:21:49 <elliott> Sgeo: GHC can evaluate a before b in (seq a b).
01:21:53 <elliott> It's totally allowed to.
01:22:01 <elliott> And does.
01:22:02 <shachaf> Anyway, the answer is that seq isn't a strict function.
01:22:20 <elliott> shachaf: It's strict in whichever of its arguments you'd rather it wasn't.
01:22:20 <Sgeo> elliott, but not always?
01:22:28 <shachaf> > seq (seq undefined) True
01:22:29 <lambdabot>   True
01:22:36 <elliott> shachaf: (This answer from the "universal quantification means you have to provide whatever your caller asks for" school of phrasing things.)
01:22:37 <elliott> Sgeo: Erm.
01:22:38 <elliott> Sgeo: b before a.
01:22:48 <Sgeo> Ah
01:22:52 <shachaf> b before a except after c
01:22:59 <Sgeo> So much for my brilliant plan :(
01:23:04 <elliott> Sgeo: Oh, and if a looks like (unsafeDupablePerformIO m), then it could execute m up to N times.
01:23:11 <ion> > (undefined `seq`) `seq` True
01:23:12 <lambdabot>   True
01:23:15 <elliott> I don't really know how that blackholing stuff works.
01:23:22 <elliott> But I'm sure you could arrange for it to happen.
01:23:32 <shachaf> kmc wrote a post about some of it.
01:23:35 <elliott> Now let's not tell Sgeo about pseq because we have to stop this thing from existing.
01:23:47 <elliott> shachaf: Indeed. I read it, and that's why I can use the term "blackholing" with confidence.
01:24:11 <Sgeo> "Note that we use pseq rather than seq. The two are almost equivalent, but differ in their runtime behaviour in a subtle way: seq can evaluate its arguments in either order, but pseq is required to evaluate its first argument before its second, which makes it more suitable for controlling the evaluation order in conjunction with par."
01:24:19 <elliott> *Sigh*, he found out.
01:24:20 <ion> -feager-brownholing
01:24:39 <shachaf> Blackholing is, like, the first thing Haskell guides teach you about.
01:24:49 <t4nk567> I don't really get happstack, FromReqURI and so on. How can I do the following? myApp = msum [ dir "thread" $ path $ \p -> ok $ template "new Thread" $ p ]  when I go to "mypage/thread/hello", for example, I want there to be a page with <p>hello</p>
01:24:53 <shachaf> A Gentle Introduction BLACKHOLING to Haskell
01:25:04 <Sgeo> elliott, you realize I'm going to include some sort of disclaimer at the top of the tutorial, right?
01:25:40 <Sgeo> "If you're new to Haskell, or otherwise still learning the basics, ignore this. Everything in it is a lie. Not "advanced Haskell", but outright lies."
01:25:56 <shachaf> Sgeo: elliott is trying to say that he just thinks it's a waste of your valuable time which could be put to much better use elsewhere.
01:26:21 <elliott> Ha ha, "valuable time". Other people experience this concept!
01:26:46 <shachaf> elliott: Quiet. I'm trying to help.
01:27:00 <Sgeo> What's a nice name that invokes notions of semicolons in people's minds?
01:27:08 <shachaf> Sgeo: "Monad"
01:27:12 <Sgeo> Can ;; be used as an operator?
01:27:19 <Sgeo> :t (;)
01:27:20 <lambdabot> parse error on input `;'
01:27:23 <Sgeo> :t (;;)
01:27:25 <lambdabot> parse error on input `;'
01:27:28 <Sgeo> THat's a no
01:27:31 <shachaf> Why isn't there a one-page version of the Report that I can search in my browser?
01:27:55 <Sgeo> :t (=:)
01:27:56 <lambdabot> Not in scope: `=:'
01:28:12 <Sgeo> I'd rather use :=, but I think that has to be a constructor?
01:28:50 <shachaf> #define := =:
01:29:16 * elliott wonders if Sgeo shouldn't learn Advanced Haskell before writing a tutorial on it.
01:29:24 <elliott> The arcane ways of uppercase symbols.
01:29:35 <Sgeo> myFunction !(!x,!y) = x+y
01:34:47 * Sgeo is wondering how to shove "weakly typed" in there
01:34:59 <Sgeo> I'm thinking heavy use of unsafeCoerce, but not sure if that's enough
01:35:57 <shachaf> Use an editor that automatically adds toDyn and fromDyn to everything.
01:36:09 <Sgeo> Overuse will cause the compiler to complain, won't it? And it's still too easy for the user to write strongly-typed functions, I think telling them "prefix everything with unsafeCoerce" is a bit too immersion-breaking
01:36:10 * hackagebot typelevel-tensor 0.1.0.2 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.1.0.2 (TakayukiMuranushi)
01:36:13 <shachaf> You can call it orechDyn.
01:37:15 <Sgeo> Hmm
01:38:27 <Sgeo> myFunction !(!x, !y) =u$ x + y
01:38:51 <elliott> fn f = unsafeCoerce . f . unsafeCoerce
01:38:52 <elliott> fn $ \x -> x
01:39:32 <Sgeo> Ah, running the input through unsafeCoerce too, hmm
01:40:17 <Sgeo> Not quite sure of a nice way to incorporate that
01:41:18 <shachaf> elliott: That type makes me sad in a very different way from most types that make me sad.
01:41:41 <shachaf> Somehow a -> b doesn't have as much of an effect as (a -> b) -> c -> d
01:42:09 <ion> λ> let ponies f = unsafeCoerce . f . unsafeCoerce in ponies (+1) "o hai"
01:42:09 <ion> <interactive>: out of memory (requested 15638462464 bytes)
01:42:20 <shachaf> I wonder whether the implicit foralling with uppercase/lowercase identifiers in Haskell is actually a good thing.
01:42:20 <augur> ion: diaf
01:43:05 <shachaf> If foralls were required to be explicit you could just use any identifier, and it would be clearer even in an out-of-context type which variables were free and which weren't.
01:43:08 <Sgeo> ion, does it work with a number instead of "o hai"?
01:44:30 <ion> Depends on your definition of “work”.
01:44:44 <Sgeo> o.O
01:45:14 <ion> λ> let ponies f = unsafeCoerce . f . unsafeCoerce in ponies (+1) 0.5 :: Rational
01:45:17 <ion> Segmentation fault
01:46:01 <Sgeo> Are there values for which it does work?
01:46:27 <ion> I’m tempted to say “no” if that discourages you from actually using it. ;-)
01:46:31 <shachaf> unsafeCoerce never works.
01:47:09 <Sgeo> ion, I'm already planning on heavy usage of unsafePerformIO and pseq to sequence them. How much worse could unsafeCoerce be?
01:47:10 <shachaf> λ> let ponies f = unsafeCoerce . f . unsafeCoerce in ponies ((+1) :: Rational -> Rational) (0.5 :: Rational) :: Rational
01:47:13 <shachaf> 3 % 2
01:48:03 <Sgeo> Hmm, required to provide type signatures or risk run-time error... not sure if I want to do that or not
01:49:31 <shachaf> You're risking run-time errors no matter what.
01:49:53 <Sgeo> Let me reparenthesize that
01:50:04 <shachaf> Anyway, type classes are fundamentally incompatible with unsafeCoerce.
01:50:05 <Sgeo> Hmm, required to (provide type signatures or risk run-time error)... not sure if I want to do that or not
01:50:21 <shachaf> Even more than many other things.
01:51:19 <Sgeo> I still don't know what I think about currying
01:51:28 <Sgeo> myFunction !x !y = x+y is less noisy
01:51:43 <Sgeo> But why introduce even one thing that makes this workable?
01:52:15 <shachaf> Sgeo: Of course that doesn't have any guarantees on the order that x and y are evaluated in either.
01:53:50 <Sgeo> Can I, using a language extension, replace (,) to (,,,,) with smart constructors? But then I can't pattern match on those in function definitions, so nevermind
02:09:02 <Sgeo> I think I have a solution to my typing problem:
02:09:20 <Sgeo> Promiscuous use of unsafePeformIO and IORefs can lead to accidental type breakage, right?
02:09:40 <Sgeo> I'll just claim that it's inconsistently-typed! Sometimes strong, sometimes weak.
02:28:57 <Rc43> Hi, guys.
02:29:57 <Rc43> Anybody knows should I separate my code into cabal packages if I want to build shared objects?
02:30:13 <Rc43> I mean, I have an executable and some modules which I want to make shared objects.
02:30:35 <Rc43> Should I place each module in its own package?
02:40:23 <augur> are there any methods akin to curve fitting, but for non-numerical data?
02:41:02 <augur> im heading to bed, so please ping/msg if so
02:43:34 <ion> Like what data for example?
03:00:53 <KitB> Does anyone know of any projects that use HaNS or HalFS?
03:07:10 <AfC> Rc43: you could probably just put all the modules in a single [cabal package → ] shared library
03:08:30 <AfC> Rc43: ie, tiny executable, enormous shared (and with any luck mostly if not entirely ro segments) library has long been a usually a good pattern for things that fire up frequently.
03:09:18 <AfC> Rc43: that's certainly not "best practice" in Haskell land, of course, since most people are content to have their single, statically linked, binaries.
03:31:13 * hackagebot stompl 0.0.1 - Stomp Parser and Utilities  http://hackage.haskell.org/package/stompl-0.0.1 (TobiasSchoofs)
03:31:15 * hackagebot stomp-queue 0.0.1 - Stompl Client Library  http://hackage.haskell.org/package/stomp-queue-0.0.1 (TobiasSchoofs)
03:32:32 <Abraxas> can i have a function that returns either () or (String, String)?
03:33:27 <Abraxas> does that even make sense
03:33:30 <ben> It'll want to return Either () (String, String)
03:35:25 <Abraxas> i'd have to pretend i don't know about Either, i guess...but not sure, actually, might be accepted
03:35:45 <ben> You could always make your own either
03:36:33 <c_wraith> returning () is kind of useless, though
03:36:44 <Abraxas> the function is parser :: Parser () and Parser is: type Parser a = String -> [(a, String)]...that's why i need ()
03:37:07 <c_wraith> it's the same as having a return type of Maybe (String, String)
03:37:27 <ben> Give or take a few places to squeeze bottoms in
03:37:38 <c_wraith> or, in that case, Parser (Maybe (String, String))
03:37:50 <c_wraith> only one extra place in the either case for a bottom
03:38:14 <c_wraith> and you'd be unlike to find that bottom unless you explicitly pattern-matched on (), or forced it...
03:38:19 <c_wraith> err, unlikely
03:38:21 <Abraxas> i know about Either, but i think i should be able to go without
03:38:45 <DRMacIver> Question: I'm creating a class with an associated type. I'd like to be able to force that associated type to be a member of some other type class. Am I able to do that?
03:38:52 <Abraxas> although it looks unlikely atm
03:39:21 <DRMacIver> (I'm reading the type families wiki entry and it's not obvious what the syntax would be if it's even possible)
03:39:44 <c_wraith> DRMacIver: well, you can put "(Foo (F a)) =>" in a function in the class
03:39:46 <ion> data Skhleither a b = Yellow a | Orange b
03:39:52 <c_wraith> that will practically force it
03:40:08 <c_wraith> (where Foo is the class, and F is the type function)
03:41:28 <DRMacIver> c_wraith: Hm. I guess I can if there's no better way. It's a little annoying though - the class isn't small and it'd be nice to just declare this in one place.
03:41:32 <DRMacIver> Thanks
03:42:35 <c_wraith> There might be a better way, but I don't know one.  I don't know that feature especially well, though
03:44:12 <DRMacIver> Fair enough
03:45:05 <DRMacIver> I don't particularly either, but this is iteration 3 or 4 of this API and I seem to have bumped into design constraints that make it impossible without associated type synonyms.
03:45:10 <DRMacIver> Or at least prohibitively annoying
03:46:13 <DRMacIver> (And I'm not yet 100% sure it's possible even with about 6 extensions turned on. Still tinkering...)
03:47:48 <DRMacIver> woohoo. Got my trivial instance compiling. Guess it's possible.
03:49:23 <lars9> which package manager in Mac supports haskell related pkgs better?
03:51:36 <rostayob> lars9: just use cabal
03:52:08 <lars9> i'm using brew now, and the ghc pkg it has is just 7.0.4
03:52:17 <lars9> way behind ghc releases
03:52:18 <rostayob> lars9: that's all right, the haskell platform is at 7.0.3
03:52:46 <rostayob> most packages are coded to work with the haskell platform (and you should do the same)
03:53:04 <rostayob> anyway if you want newer versions you can use the ghc binaries
03:53:10 <rostayob> or build ghc yourself
03:54:35 <lars9> rostayob: i used to use archlinux, and am not used to manually building pkgs...
03:54:53 <leoncamel> some of my installed packges seems broken. What is the best way to reinstall them?
03:55:26 <rostayob> lars9: then 7.0.4 should serve you well. if you really want 7.2, you can download the binaries here http://www.haskell.org/ghc/download_ghc_7_2_2#binaries
03:55:34 <rostayob> but again, what you should be using is 7.0.3
03:55:42 <rostayob> or 7.0.4, i don't think it makes a great difference
03:55:46 <darkangel> Does haskell has printf that support Data.Text?
03:56:14 <darkangel> or printf that can be extensible to user types?
03:56:15 <rostayob> leoncamel: you mean reinstall the broken ones? i don't think there is a way, you can hack a little scrip
03:56:17 <rostayob> t
03:56:59 <lars9> "If you're using GHC 7.2 or newer and want to read simplifier output, consider using options like -dsuppress-all to prevent GHC from annotating the Core."
03:57:25 <lars9> so i want to use that option to produce more readable core...
03:57:51 <rostayob> yeah if you need 7.2 download the binaries
03:58:07 <leoncamel> rostayob: I try a package name `ghc-pkg-autofix`. I seems quite cool, I *did* repair pkgs. But something bad happend when I installed a new packages.
03:58:10 <rostayob> darkangel: why would you use text when formatting a string?
03:58:11 <lars9> rostayob: yeah that's doable thanks
03:58:28 <rostayob> darkangel: but anyway the base printf is only String-compatible :)
03:59:01 <rostayob> leoncamel: I don't know about that, sorry (ghc-pkg-autofix)
03:59:08 <rostayob> what does ghc-pkg check say?
04:00:25 <gienah> rostayob: I wonder if something like this would work (I don't know, I don't use cabal): cabal install world --dry-run
04:00:35 <leoncamel> rostayob: a lot of "dependency "text-0.11.1.9-460f06cddd79c3c37d43775fd8e469d6" doesn't exist"
04:00:49 <DRMacIver> Hm. Of course a downside of this way of writing things is that it's now all but impossible to write down the type signatures for my tests.
04:01:13 <rostayob> gienah: maybe you could loop that until it works :P
04:01:29 <rostayob> leoncamel: ok so you probably upgraded text or something like that
04:02:08 <rostayob> leoncamel: you should start by reinstalling the ones that depend on text directly and then go down in the dependency tree
04:02:17 <rostayob> it's boring but i don't know something that does it automatically
04:02:28 <rostayob> well you upgraded text and removed the old version
04:02:36 <leoncamel> rostayob: OK. I will try it.
04:03:08 <gienah> rostayob: thanks (on gentoo haskell-updater rebuilds the broken packages, for text it rebuilds about 200 packages out of over 500 when text is bumped)
04:03:14 <leoncamel> rostayob: But, is seems wired that there is *no* uninstall for cabal.
04:03:48 <rostayob> leoncamel: yeah cabal is messy. there is no "upgrade" either
04:04:06 <KitB> Does anyone know if anyone has actually written any kernel modules in Haskell?
04:04:13 <leoncamel> gienah: where can I download that script ? I use gentoo before, I thought it would be a python script.
04:04:17 <rostayob> gienah: yeah, i remember that when i used gentoo
04:04:21 <KitB> I could do with an example.
04:04:25 <darkangel> rostayob: because most of my printf arguments is Data.Text. So, there is no generic formating library?
04:04:29 <rostayob> leoncamel: there should be a very up to date overlay
04:04:41 <rostayob> darkangel: i'm not sure
04:04:58 <carpi> could someone please tell me how i can analyse the performance characteristics of this snippet? http://codepad.org/LayShc7F i just want to know if its efficient to do it that way ?
04:05:41 <gienah> leoncamel rostayob: ivanm wrote haskell-updater and others have hacked it: https://github.com/gentoo-haskell/haskell-updater
04:06:06 <leoncamel> gienah: Oh, thanks...
04:06:15 <rostayob> gienah: i don't use gentoo anymore, but wasn't there an overlay for haskell?
04:06:34 <rostayob> carpi: isn't it better to consume the second list?
04:06:42 <rostayob> @src (++)
04:06:42 <lambdabot> []     ++ ys = ys
04:06:42 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:06:42 <lambdabot> -- OR
04:06:43 <lambdabot> xs ++ ys = foldr (:) ys xs
04:06:46 <gienah> leoncamel rostayob: yes there is an overlay: https://github.com/gentoo-haskell/gentoo-haskell
04:06:57 <rostayob> oh well
04:07:07 <rostayob> gienah: yeah i think that gentoo is the more up to date distro
04:07:11 <rostayob> considering that overlay
04:07:40 <carpi> rostayob: what do you mean consume second list?
04:07:44 <rostayob> carpi: anyway, i would say that no it's not efficient to do it what way
04:08:13 <gienah> leoncamel rostayob: if someone with a mac wanted to hack some gentoo stuff with us, then the overlay could be convinced to work on mac with gentoo prefix: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
04:08:41 <rostayob> carpi: you're traversing x twice each time
04:08:47 <rostayob> while you can traverse it once
04:09:11 <Eduard_Munteanu> rostayob: Arch is reasonable in that respect as well, FWIH
04:09:12 * gienah does not have a mac though, which makes it a little tricky. we have a channel #gentoo-haskell
04:09:15 <rostayob> gienah: i don't have a mac, i just use ubuntu now ):
04:09:24 <rostayob> no wait, it was meant to be a happy smile
04:09:25 <rostayob> :)
04:09:27 <rostayob> that
04:09:32 <rostayob> macs are bad kids
04:09:34 <carpi> ah..so true.. thansk for the observation
04:10:02 <gienah> rostayob: of course gentoo prefix should work on ubuntu (or there is chroot)
04:10:49 <zhulikas> I read about list implementation in Haskelll.
04:10:51 <zhulikas>  If you defined the same and redefined all the operations, you would get the exact same performance.
04:11:02 <zhulikas> does anybody tried comparing performance with arrays in other programming language?
04:11:04 <leoncamel> gienah: OH, very interesting, install gentoo on my macbook. But, I do not have enought harddisk to try it. :(
04:11:14 <rostayob> zhulikas: arrays are completely different from haskell lists
04:11:19 <zhulikas> ok, linked lists
04:11:30 <gienah> leoncamel: oh well :-/
04:11:32 <rostayob> well with haskell you get fusion for free
04:11:33 <zhulikas> rostayob, so you say that haskell lists are slower than arrays?
04:11:44 <rostayob> i say that haskell lists are not arrays
04:11:50 <zhulikas> ok :D
04:12:07 <zhulikas> but it's the simpliest set structure
04:12:19 <rostayob> but in the domain of lazy streams GHC should be fast
04:12:20 <zhulikas> therefore should be compared with other language's simpliest set structure
04:12:30 <rostayob> a list is not a set
04:13:07 <gienah> leoncamel: of course gentoo prefix just builds gentoo packages to run under macos x, theoretically, not sure if anyone has actually tried it with the haskell overlay (but we have added support for it anyway in the ebuilds)
04:13:30 <zhulikas> so what about performance?
04:13:51 <rostayob> zhulikas: but anyway, haskell lists are really simple, so there shouldn't be much to say about performance that has to do with the data structure itself
04:13:55 <rostayob> apart from deforestation
04:14:02 <rostayob> but there is a lot to say about lazyness
04:14:09 <rostayob> but that's a broader discussion
04:15:59 <Kazoone> so ass
04:16:04 <Kazoone>      ,
04:18:20 <zhulikas> :<
04:18:39 <rostayob> zhulikas: are you worried about performance in some list-heavy software :P?
04:18:54 <leoncamel> gienah: I am curious that, how does haskell-overlay `emerge ghc` for the first time? It will download a binary one, then rebuild the package?
04:19:29 <gienah> leoncamel: yes it needs to download a binary ghc first in order to build ghc
04:19:35 <zhulikas> rostayob, I am just wondering how haskell differs from other programming languages
04:19:44 <zhulikas> in comparing lists
04:19:49 <NerfOrNothin>  -,,                                       ,    _,.
04:19:51 <NerfOrNothin>     `'-.,                                  ,\-'`
04:19:53 <NerfOrNothin>          ``'.,                       _,-'``  \
04:19:55 <NerfOrNothin>               ``'.,,            ,.-``         \
04:19:57 <NerfOrNothin>   `-,,              `'-,, ,,-'``               `.
04:19:58 <NerfOrNothin>       `'.,          _,.-``'-.,                   `
04:20:01 <NerfOrNothin>           `'.,_,.-'`          `'-.,               |
04:20:02 <NerfOrNothin>          _,.-```'-.,,              ``'.,_         `
04:20:04 <zhulikas> combo breaker!
04:20:04 <NerfOrNothin>     ,.-'`            ``''--.,,,,         `'.,,   /
04:20:06 <NerfOrNothin> -'``                            `````''''''''--.'
04:20:16 <NerfOrNothin>      ,
04:20:18 <rostayob> zhulikas: lists are different from most list-list structures in other programming languages because, like every data structure in haskell, they're lazy. that's the biggest difference
04:21:00 <rostayob> usually a structure like that is called a lazy stream in the broader programming world
04:21:01 <zhulikas> what about lazyness when adding a new value to a list? I believe it will require the whole list to be copied
04:21:44 <leoncamel> NerfOrNothin: oh my god, please stop that. I am use Text-to-speech in this channel.... Just now, it becomes *crazy* here... :)
04:22:06 <rostayob> zhulikas: well that has more to do with immutability
04:22:42 <gienah> leoncamel: so that means its necessary to emerge =dev-lang/ghc-6.12.3-r2 it has stuff for the binaries on macos for both x86 and ppc https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-lang/ghc/ghc-6.12.3-r2.ebuild
04:23:14 <zhulikas> well I see how lazyness benefits in searching through list, but nowhere else
04:23:22 <rostayob> zhulikas: what about infinite lists?
04:23:30 <rostayob> or sorting a list and getting the first element?
04:23:39 <leoncamel> gienah: So, for mips/arm architecture, we have to *cross building* ?
04:23:56 <rostayob> zhulikas: also, the fact that you have to copy the list when appending will be present in every immutable list. it has nothing to do with haskell
04:23:58 <zhulikas> I didn't do any sorting yet
04:24:09 <rostayob> you asked me about advantages of lazyness
04:24:15 <zhulikas> ok, sure
04:24:29 <zhulikas> hmm ok
04:24:43 <rostayob> lazyness has a lot of advantages
04:25:00 <gienah> leoncamel: no, thats for buiding on mips and arm, ghc does not have cross building
04:25:09 <Abraxas> parse p inp = [ x | (x,rest) <- p inp, rest == ""]
04:25:11 <rostayob> zhulikas: also, if you cons something to another list, nothing will be copied
04:25:15 <zhulikas> I love infinite lists so far :)
04:25:25 <zhulikas> what?
04:25:28 <zhulikas> cons?
04:25:36 <rostayob> 1 : xs
04:25:40 <rostayob> : == cons
04:25:45 <zhulikas> ok, what happens then?
04:25:47 <gienah> leocamel: then after the emerge of the binary ghc 6.12.3, then can build gc 7.2.2 with the use flags: ghcbootstrap llvm source
04:26:08 <rostayob> zhulikas: since haskell is immutable, the newly created list will point to the old one
04:26:18 <rostayob> the compiler doesn't need to copy anything
04:26:25 <zhulikas> lazy bastard:)
04:26:30 <leoncamel> gienah: Cool.
04:26:35 <rostayob> again this is purity more than lazyness :)
04:27:11 <rostayob> and this is true for every data structure in haskell
04:27:13 <zhulikas> so, 1 : xs
04:27:16 <rostayob> what can be shared will be shared
04:27:20 <leoncamel> gienah: are you the maintainer of haskell overlay in gentoo?
04:27:21 <zhulikas> just a reference is added
04:27:26 <Abraxas> hold on...can i put a bunch of function defs in here and they will stick?
04:27:46 <zhulikas> I thought it would be copied
04:27:50 <gienah> leoncamel: gentoo has very good support of haskell, however of course gentoo is a complex system to install - yes I'm one of the gentoo devs
04:28:03 <rostayob> zhulikas: well lists in haskell are basically (element, pointer to next cell)
04:28:10 <zhulikas> linked list
04:28:15 <rostayob> zhulikas: in this case we'll have (1, pointer to xs)
04:28:30 <rostayob> nothing will be copied
04:28:33 <Abraxas> let item = \inp -> case inp of
04:28:34 <Abraxas>                  ""     -> []
04:28:34 <Abraxas>                  (x:xs) -> [(x,xs)]
04:28:40 <Abraxas> :t item
04:28:41 <lambdabot> Not in scope: `item'
04:29:00 <zhulikas> what about right/left association? is it involved here somehow?
04:29:23 <rostayob> zhulikas: if you append you have to copy. you might be interested in "purely functional data structures" iirc it explains lazy streams
04:29:40 <rostayob> zhulikas: what do you mean? the associativity of the operator?
04:29:42 <zhulikas> how is append different from 1 : xs ?
04:29:48 <leoncamel> gienah: Cool. I installed a gentoo years ago. It was my favorite linux distro. :)
04:30:00 <Abraxas> let plus a b = a+b
04:30:05 <Abraxas> plus 2 3
04:30:19 <rostayob> zhulikas: ok so we have a linked list being (element, ptr to next cell)
04:30:30 <rostayob> when you append something to a list, you can't share the first part
04:30:38 <Abraxas> :t plus 2 3
04:30:39 <lambdabot> Not in scope: `plus'
04:30:44 <rostayob> since you have to go to the appended part at some point
04:30:49 <rostayob> and the original list will just end
04:30:50 <gienah> leoncamel: anyone that is interested can hack ebuilds and send us a pull request to merge new packages into the gentoo haskell overlay
04:31:15 <rostayob> zhulikas: i'm probably crap at explaining, i'm sure there are some pages explaining this better
04:31:58 <leoncamel> gienah: cool.
04:32:46 <rostayob> zhulikas: http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&sqi=2&ved=0CDkQFjAA&url=http%3A%2F%2Fwww.cs.cmu.edu%2F~rwh%2Ftheses%2Fokasaki.pdf&ei=EvfITqDPL8ab8QPOsZWGAQ&usg=AFQjCNGXKQqKJho73FE372EjGzUoeSJm1w&sig2=0ioXH5b2DkKkkqVSWfcTaA
04:32:48 <rostayob> no sorry
04:32:54 <rostayob> www.cs.cmu.edu/~rwh/theses/okasaki.pdf
04:33:02 <zhulikas> a big one :)
04:33:56 <rostayob> zhulikas: mhm actually i remember some nice figures in the book
04:34:10 <Abraxas> ok...let's say i have type Parser a = String -> [(a, String)] and a sat function for parsing a character which satisfies the condition in the sat
04:34:28 <Abraxas> then i have: parse_asbs = sat (=='a') ||| sat (=='b')
04:34:34 <DRMacIver> c_wraith: FWIW, it turns out that adding a Metric constraint to the class instances isn't a sufficient solution
04:34:49 <Abraxas> that's parse_asbs :: Parser Char
04:35:07 <DRMacIver> The problem is that as soon as you try to write a function that relies on it outside of the class declaration it becomes impossible to get your code to compile
04:35:18 <DRMacIver> Because you can't specify the type instance in your constraints
04:35:20 <zhulikas> rostayob, thanks, I'll look into it
04:35:51 <Abraxas> and let's say    parse parse_asbs inp   is String -> [Char]
04:36:36 <DRMacIver> Fuckit. I'll just make these tests non-generic for now and grumble about it later.
04:36:42 <Abraxas> and let's say i forgot my question over all this...
04:36:59 <rostayob> zhulikas: in general immutable data structures have a lot of avantages, and sharing is one of them
04:37:02 <rostayob> http://stackoverflow.com/questions/4399837/what-is-the-benefit-of-purely-functional-data-structure
04:37:43 <rostayob> sometimes mutability can be beneficial, e.g. mutable arrays or hash tables
04:38:43 <rostayob> but purity (a nicer name for immutability) is a *good thing* most of the times
04:39:30 <Abraxas> where can i access the [(a, String)]
04:39:45 <rostayob> zhulikas: anyway i wouldn't worry about performance before learning haskell :)
04:39:51 <Abraxas> i need a case of that
04:43:03 <Abraxas> i mean, the parse returns [Char], not [(a, String)]...and i can't see why
04:44:23 <Abraxas> i am not sure if the correct Parser is used right now...GHCI tells me Parser Char, but i have several defs, the right one should be loaded, but no idea
04:45:27 <Abraxas> can i display what Parser is right now?
04:45:49 <rostayob> Abraxas: getParserState or something like that
04:46:02 <rostayob> wait i'm not sure i know what you want
04:46:19 <rostayob> what's the problem again?
04:46:27 <rostayob> ah
04:46:28 <Abraxas> it's not an official parser package
04:46:34 <rostayob> are you reading "programming in haskell" :P?
04:46:38 <Abraxas> nope
04:46:49 <rostayob> ah. there is something really similar in it.
04:46:49 <Abraxas> but it might be from there :D
04:47:27 <rostayob> Abraxas: can you post on code? it's hard to guess from messages scattered around :P
04:48:03 <Abraxas> the parser is supposed to read strings with equal amounts of only a's and b's...but i already have type trouble
04:48:14 <rostayob> yeah post the whole thing
04:48:14 <Abraxas> it's quite a few modules
04:48:28 <rostayob> can't you reduce to something short?
04:48:45 <Abraxas> not exactly sure how much you would need and if it works, because it doesn't :D
04:49:09 <rostayob> well then i'm not sure i can understand your problem :D
04:49:11 <Abraxas> i'll try
04:49:43 <rostayob> ok
04:50:16 <Abraxas> that's always the problem with my questions...i try to get an answer for one step, but nobody can understand it without the whole thing :p
04:50:56 <rostayob> well but we can't guess what the context is, and the context is important if you ask "how do I fix this" :P
04:51:17 <Abraxas> i don't really want to have someone to solve it, just a hint, but it never works out :D
04:51:42 <rostayob> ok i'll give you hints then ehehe
04:52:38 <DRMacIver> Hm. The impression I'm strongly getting here is that rather than being the useful tool for generic code they promise to be associated type instances actually make it almost impossible to write generic code. That's rather frustrating. :(
04:52:43 <DRMacIver> Either that or I'm doing something very badly wrong
04:53:36 <rostayob> DRMacIver: what are you talking about? syb? GHC.Generics?
04:53:50 <DRMacIver> rostayob: No. I'm talking about associated type synonyms.
04:53:56 <DRMacIver> (I said instances before, my mistake)
04:54:47 <DRMacIver> the problem is that as soon as you need constraints on the synonym (e.g. for writing quickcheck tests, as in my current case) the type signatures become impossible to write and the ones GHC infers become wrong.
04:54:47 <rostayob> ah. i think i partly agree
04:55:43 <rostayob> btw, GHC.Generics uses associated type synonyms
04:56:22 <rostayob> are you using with some particular library?
04:56:29 <DRMacIver> No, I'm writing a library.
04:56:39 <rostayob> that phrase didn't make much sense
04:56:48 <DRMacIver> Well your question didn't really either. :)
04:56:54 <DRMacIver> I'm just using the feature
04:56:59 <rostayob> yes, with "that phrase" i meant my question :P
04:57:17 <DRMacIver> Fair enough
04:57:29 <rostayob> just use fundeps then
04:58:44 <DRMacIver> Yeah, I guess. Or I could just give up in a sulk which is the other tempting option.
04:59:23 <DRMacIver> As we're now hitting iteration 6 of Haskell forcing me to redesign this API because doing it can't do what I want with the previous iteration
04:59:54 <rostayob> maybe you're just overcomplicating. all those language extensions are really tempting, but i'd use them when you really need them
04:59:56 <carpi> could someone please tell me how i may assign the result of an expression to different identifiers depending on the results of those expressions..?
05:00:30 <DRMacIver> rostayob: Well I mean it's not like I dived in and said "I know! I'm going to use exciting language extensions!"
05:00:31 <carpi> i want to put values in 2 different lists depending on whether the elemnts in the list or greater or lesser
05:00:36 <DRMacIver> Iteration 1 didn't even use type classes.
05:00:43 <carpi> and i want to be able to do this in one pass
05:00:55 <rostayob> DRMacIver: oh. ok. then I don't know :P
05:00:58 <bxc> carpi: filter?
05:01:03 <rostayob> carpi: partition
05:01:08 <rostayob> @type partition
05:01:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:01:16 <bxc> even better
05:01:42 <DRMacIver> Sigh. Ok. Time to iterate again.
05:01:44 <DRMacIver> Tanks rostayob
05:01:54 <carpi> thanks.. guys
05:01:57 * DRMacIver goes to read up on functional dependencies
05:02:02 <carpi> back to business )
05:02:23 <Botje> they're like asbestos-wrapped monkeys rolling down a hill made of money.
05:02:26 <hpaste> Abraxas pasted “parse_asbs” at http://hpaste.org/54308
05:02:38 <Botje> (\bot feature request: @analogy)
05:02:46 <DRMacIver> Well, I mean, I know what functional dependencies are. I mostly just need to look up the syntax to use them. :)
05:02:58 <Abraxas> well
05:03:02 <rostayob> class Foo a b | a -> b where
05:03:12 <rostayob> you can have multiple params on the lhs of the ->
05:03:15 <DRMacIver> Yeah, just reading the wiki article now.
05:03:18 <rostayob> and you can have multiple ->
05:03:19 <Abraxas> guess i had to c/p both modules after all :p
05:03:20 <rostayob> that's it yo
05:03:24 <DRMacIver> Looks straightforward enough
05:03:58 <Abraxas> no, hold on, i am stupid
05:04:03 <Abraxas> MParserCore is monad parsing
05:04:07 <Abraxas> it's not even used
05:07:21 <Abraxas> i probably won't be able to use parser combinators that way, because i need to access the parse result for each character
05:15:07 <Abraxas> rostayob, please don't look at it...i am not even sure what i want to know...
05:16:44 <rostayob> Abraxas: well I can't look at it right now :P
05:17:08 <Abraxas> good
05:17:15 <Abraxas> i'll let you know
05:21:04 <kurenai> my opengl animation tutorial only updates screen on window resize :( what could be the problem?
05:21:49 <hpc> kurenai: you need an idle action that forces a screen refresh at the framerate you want
05:22:07 <kurenai> thank you, i'll try that, hpc!
05:22:32 <hpc> kurenai: what happens now is you have your logic in the display action, which doesn't get called unless it needs to redraw the screen
05:22:38 <hpc> performance concerns and all that
05:23:26 <ClaudiusMaximus> postRedisplay if you're using GLUT
05:27:41 <kurenai> how do i force screen refreshing with glut?
05:28:31 <hpc> postRedisplay
05:28:35 <hpc> apparently
05:28:50 <hpc> http://hackage.haskell.org/packages/archive/GLUT/latest/doc/html/Graphics-UI-GLUT-Window.html#v:postRedisplay
05:29:27 <kurenai> ooo! magic. it really works now %)
05:29:47 <kurenai> thank you :)
05:32:27 <kurenai> i actually want to learn how to do data visualizations in Haskell. with such a friendly community i'll be there in no time.
05:32:50 <hpc> kurenai: #diagrams (iirc) would be the best place to start
05:33:03 <hpc> http://hackage.haskell.org/package/diagrams -- it's the channel for this package
05:35:55 <kurenai> i'll check it out.
05:37:55 <DRMacIver> rostayob: fundeps worked like a charm. Thanks
05:47:46 <DRMacIver> Of course the new versions of my tests to match the changed API are failing. Sigh
05:48:37 <DRMacIver> oh, because I'm a numpty and quickcheck was helpfully doing what I asked it to instead of what I meant.
05:53:57 <rostayob> DRMacIver: btw, what are you trying to express?
05:54:03 <rostayob> i mean what does the type class look like?
05:59:29 <DRMacIver> rostayob: It's a metric space (I was previously also trying to write a type class for search indexes on that metric space but have just decided to say fuckit on that one and go concrete)
05:59:36 <DRMacIver> hold on, I'll hpaste the declaration
06:00:13 <hpaste> DRMacIver pasted “class Metric m a” at http://hpaste.org/54312
06:00:47 <DRMacIver> The search index type class was a bit more complicated (that's where I wanted the instance constraint)
06:02:09 <rostayob> that makes sense, i guess. i don't know what "bound" is for
06:03:16 <DRMacIver> rostayob: It's effectively a shape parameter. In cases where you've got e.g. an ultrametric it lets you get tighter bounds on metrics so you can shrink the search space faster.
06:03:36 <rostayob> DRMacIver: ok, i don't know what you're talking about, but i guess the type class makes sense
06:04:29 <DRMacIver> rostayob: fair enough. I can explain further if you care, but I don't imagine you do :)
06:04:39 <rostayob> DRMacIver: no I don't think i do :)
06:05:22 <rostayob> i didn't even know what a metric space was before this conversation eheh
06:07:00 <mantovani> good morning :)
06:15:30 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (replacing parser)” at http://hpaste.org/54308#a54313
06:15:53 <Abraxas> rostayob (or anyone)?
06:16:13 <Abraxas> it's probably wrong in all sorts of ways
06:16:31 <Abraxas> but maybe it's easily fixable
06:17:13 <Abraxas> i was trying to pass the parsed char through the ++> combinator...but i suspect that i should just write a new parser from scratch, taking the string as input and doing a case for that
06:22:53 <Abraxas> it's horribly wrong...
06:30:32 <hpaste> Sebasti0n pasted “Similarity Datatype” at http://hpaste.org/54314
06:30:39 <Sebasti0n> Hey there. I have a weird problem. I am using ghci to do a computation using a custom data type. when I want to print out the result it stops printing at a certain member of the data type. when I construct the data type manually with dummy data it prints the data just fine.
06:31:27 <rwbarton> "stops printing"? can you give example output?
06:31:55 <Sebasti0n> [Cluster {members = [IVector {id = "2", features = [("x",2.0),("y",1.0)], len = 2.23606797749979},IVector {id = "1", features = [("x",1.0),("y",1.0)], len = 1.4142135623730951}], high = [Similarity {one = "^CInterrupted.
06:32:28 <rwbarton> well, that's what would happen if you pressed ctrl-C while it was printing...
06:32:50 <hpaste> Sebasti0n pasted “Cluster Datatype” at http://hpaste.org/54315
06:33:16 <Sebasti0n> I pressed ctrl-C because it does nothing
06:33:20 <rwbarton> oh.
06:33:21 <mah_b> could you post the code that creates the similarity?
06:33:30 <rwbarton> Well, probably you have an infinite loop in the function that computes that value
06:34:06 <Sebasti0n> the cpu usage isn't up
06:34:19 <Sebasti0n> could it still be an infinite loop?
06:35:17 <Sebasti0n> I will have a look at the code again and see if I spot anything weird. If I can't fix it I'll ask again
06:36:03 <Sebasti0n> the program actually works fine if I do not print
06:36:17 <Sebasti0n> so I wouldn't suspect an infinite loop
06:36:26 <rostayob> Sebasti0n: i doubt it, maybe what you have it's just a suspension
06:36:35 <rostayob> try to force the contents of "high"
06:36:53 <ClaudiusMaximus> Sebasti0n: in my ghci, "let x = x + 1 in x" just sits there with no cpu consumption until i interrupt it, but compiled it spits out <<loop>>
06:36:55 <rostayob> Abraxas: I don't have time to read the code now
06:37:10 <rostayob> maybe later i'll read it :)
06:37:24 <rwbarton> yeah, you can have a "loop" in some part of your value which the rest of your program does not demand
06:38:10 <Sebasti0n> ok, I'll try to spot that
06:38:14 <Sebasti0n> thanks
06:39:02 <ClaudiusMaximus> Sebasti0n: try -Wall, it might tell you about a typo (eg: using x instead of x' might tell you that x' is defined but not used)
06:40:33 <carpi> could someone please tell me whhat is currying? I read some links on google and on learn you a haskell book..but they only say what it is. I feel like I understand that much. But i don't see where and when currying could be useful..
06:40:55 <ClaudiusMaximus> :t curry
06:40:59 <rostayob> @type curry
06:41:05 <rostayob> @type uncurry
06:41:07 <sipa> carpi: in most languages, if a function takes two arguments, you pass it both at the same time
06:41:11 <etpace> > map (+1) [1..5]
06:41:13 <ClaudiusMaximus> @botsnack
06:41:30 <sipa> for example f(x,y)
06:41:38 <ClaudiusMaximus> preflex: seen lambdabot
06:41:38 <preflex>  lambdabot was last seen on #haskell 1 hour, 40 minutes and 31 seconds ago, saying: forall a. (a -> Bool) -> [a] -> ([a], [a])
06:41:48 <carpi> sipa: yes true
06:41:52 <rostayob> Cale: lambdabot is dead
06:42:04 <sipa> carpi: in Haskell, you only pass it one argument, and it returns you a function; to this function, you pass the second argument and get the result
06:42:25 <sipa> for example, the (+) functions which adds to numbers
06:42:28 <sipa> :t (+)
06:42:44 <sipa> > (+) :: Num a => a -> a -> a
06:42:56 <ClaudiusMaximus> curry :: ((a, b) -> c) -> a -> b -> c
06:42:56 <carpi> sipa: yes. I understand that very well. infact.. i was able replicate that on the interpreter. It seemed quite trivial. But I don't see where it can be used..?
06:43:00 <carpi> or what purpose it serves
06:43:14 <sipa> carpi: imagine you want a function that adds the number 5 to its argument
06:43:15 <carpi> what is the advantage of being able to pass around a currried function?
06:43:16 <rwbarton> in Haskell you sort of don't have opportunities to curry things because everything is curried automatically
06:43:28 <sipa> you can write that as (+) 5
06:43:38 <rwbarton> unless you mean, why do we curry things rather than passing pairs
06:43:51 <carpi> rwbarton: exactly
06:43:52 <sipa> if you have a list of numbers, and want to add 5 to each of them
06:44:01 <rwbarton> okay, sipa's example is a good one
06:44:06 <sipa> you can do: map ((+) 5) [1,2,3,4]
06:44:40 <sipa> note that ((+) 5) can be further abbreviated to just (+5), but that is just syntactic sugar for ((+) 5)
06:44:50 <sipa> apologies, to (5+)
06:45:03 <ClaudiusMaximus> carpi: here's a curried function in some javascript i wrote once: function arcHandler    (p) { return function(q) { return function(r) { arcDo (p, q, r); return nullHandler; }; }; }
06:47:22 <carpi> sipa: yes it looks very handy in such a situation.. but i can accomplish the same thing trivially using a function that takes 2 arguments. What i don't understand is.. is currying simply a shortcut way of doing some things or is there something fundamentally mathematical about it that i don't understand?
06:48:19 <carpi> what im trying to say is .. i don't see how currying helps to solve any big problem.. it seems like its just a way to create functions that can take unlimited arguments
06:48:44 <tomprince> It doesn't solve any big problems.
06:48:50 <rwbarton> it's just a convenience but it comes up extremely often
06:49:02 <tomprince> But lots of little things can add up to more then the sum of their parts.
06:49:16 <sipa> if you want to, you can see a partial application like (f x) as syntactic sugar for (\y -> f (x,y))
06:49:30 <sipa> but the other way around is more interesting
06:49:41 <sipa> for example, the function id :: a -> a
06:49:50 <sipa> it looks like a function that takes 1 argument
06:50:10 <sipa> however, the type a in that signature can be equal to let's say (Int -> Int)
06:50:12 <tomprince> currying on its own isn't a big deal. but combinded with the wealth of higher-order (function taking) functions in haskell, it becomes quite powerful and concise.
06:50:43 <sipa> which means that (id (+)) has the type (Int -> Int) again
06:50:47 <sipa> right?
06:50:56 <carpi> yup
06:51:08 <sipa> this also means that i can pass it an extra argument
06:51:22 <sipa> ow
06:51:30 <sipa> id (5+) i mean
06:51:44 <sipa> id (5+) 3
06:52:07 <sipa> here i've passed two argument to id
06:52:43 <sipa> currying just allows you to think of every function as one that just takes one argument, and returns just one solution
06:53:08 <sipa> while at the same time not lose the syntactic convenience of passing multiple arguments to some thing that needs it
06:54:18 <carpi> i still need to wrap my head around it.. ill find a way. but thanks)
06:55:48 <carpi> you mentioned "id". It simply returns the argument given to it. Thats it?
06:55:55 <sipa> yes
06:56:10 <sipa> it's the identity function
06:56:50 <sipa> imagine you have a list of functions [(+5),(*2),\x -> x+x*x, ...]
06:57:22 <sipa> and a list of arguments to give to them [25, 18, 5]
06:57:37 <sipa> and you want the list of values obtained through it
06:57:43 <mux_> :t zipWith ($)
06:57:57 <mux_> hrm, lambdabot gone shopping again?
06:58:01 <sipa> you can use zipWith id [(+5),(*x),\x -> x+x*x] [25, 18, 5]
06:58:55 <carpi> sipa: can't i simply use zipWith [<functions>] [<values>]
06:59:21 <carpi> AH nope.. i guess not..
06:59:29 <sipa> zipWith takes 3 arguments: a) a function takes combines two elements, b) a first list c) a second list
06:59:50 <sipa> there is zip, which uses (\x y -> (x,y)) as default combiner
07:00:29 <hpc> zipWith ($) [f, g, h] [x, y, y] = [f $ x, g $ y, h $ z] = [f x, g y, h z]
07:00:39 <sipa> and ($) is really just id
07:01:22 <sipa> zipWith id [f, g, h] [x, y, z] = [id f x, id g y, id h z] = [f x, g y, h z]
07:05:06 <carpi> dzienkuje(Thanx)
07:31:03 * hackagebot lhe 0.1 - Parse for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.1 (ScottLawrence)
07:39:32 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (replacing parser again)” at http://hpaste.org/54308#a54316
07:40:01 <Abraxas> can someone have a look at the latest annotation?
07:40:21 <Abraxas> i don't understand the error, that should be fine for cons?
07:40:53 <Abraxas> disregarding everything else that could be wrong
07:41:51 <Abraxas> i don't see how that argument is bound to Char...Parser Char, if anything
07:43:48 <Saizan> Abraxas: in the 'a' case you use yield x, and x :: Char, so the type of parser_ something has to be Parser Char
07:44:15 <Saizan> Abraxas: so maybe you want yield [x] instead?
07:44:46 <Saizan> also, what's the type of liftP ?
07:45:12 <Saizan> Abraxas: ah, sorry, i meant in the ' ' case, not the 'a' one
07:45:26 <Saizan> ' '-> if length as == length bs then yield x else failure <- there
07:45:36 <Abraxas> the parser_ in the case has to be a list, i suppose
07:46:15 <Abraxas> yeah tried that, but then i have to wrap it some other way, i guess
07:46:45 <Abraxas> [x] won't work, has to be a parser
07:46:48 <Abraxas> Parser
07:48:27 <Saizan> yield should do that
07:48:41 <Saizan> so (yield [x]) should work
07:49:32 <Abraxas> right, i deleted yield :D
07:49:51 <Abraxas> you didn't say that, sorry
07:50:07 <Abraxas> yeah, that works
07:50:52 <Abraxas> sure does, now it's a list...
07:51:37 <Abraxas> only tried to put parser_ calls in a list, because i somehow thought the yielded x will be in front of the cons...silly me
07:52:24 <Abraxas> well, it type-checks, but it's still nonsense =)
07:57:25 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (type-checks previous version, but still no program logic)” at http://hpaste.org/54308#a54320
08:01:38 <gwern> oh dear http://haskell.org/haskellwiki/Rezultatele_neseriosului_Patrut_Bogdan
08:01:59 <Abraxas> i can't use the many parser combinator, right? then i can't access the intermediate results, i think
08:02:00 <gwern> the romanian on hawiki has been causing problems it seems
08:02:03 <alistra> n i high or what
08:02:08 <Abraxas> but the '' case is nonsense, i guess
08:02:08 <alistra> am i high*
08:02:24 <Abraxas> yield ['']
08:02:28 <Abraxas> doesn't look right
08:04:06 <gwern> the translation: http://translate.google.com/translate?sl=auto&tl=en&js=n&prev=_t&hl=en&ie=UTF-8&layout=2&eotf=1&u=http%3A%2F%2Fhaskell.org%2Fhaskellwiki%2FRezultatele_neseriosului_Patrut_Bogdan
08:04:11 <Abraxas> when the parse ends, i have to look at the (as,bs)
08:04:23 <gwern> apparently ha$kell is maintaining an attack/hit page on this bogdan square
08:04:40 <Abraxas> the parse should end automatically, but then i can't look at the (as,bs), it just ends
08:05:04 <Abraxas> the solution is probably simple, but my head hurts...
08:05:21 <Abraxas> (just my neck, actually)
08:06:23 <Cale> bribery in a plastic bag!
08:08:30 <Abraxas> cale: me? :D
08:08:54 <Cale> Abraxas: just weird translation from that page gwern linked
08:09:15 <Abraxas> wasn't sure, it kinda fits :p
08:09:46 <Cale> '' isn't valid syntax. You can't have an empty character
08:09:54 <Abraxas> ' '
08:10:35 <Abraxas> i was just saying that, because if it's easy, that's my excuse
08:11:46 <Abraxas> but yeah, that's a space and that's why it doesn't work
08:12:14 <Cale> Maybe you want a _ pattern after handling a and b
08:12:15 <Abraxas> or that's not even the only reason, but certainly one of them
08:12:29 <Cale> But... this code is kinda weird
08:12:43 <Cale> Is there a reason you're avoiding do notation? :)
08:12:43 <Abraxas> no, parse_asbs is already only accepting a and b
08:12:59 <Cale> right, that's true as well
08:13:12 <Cale> So you can ignore that case
08:13:35 <Abraxas> i need to get at the (as,bs) when the parse ends
08:13:38 <Cale> ah, yield = return
08:13:43 <Abraxas> but this is crap
08:13:59 <Abraxas> i could use do, mparser is monad
08:14:18 <Cale> You don't appear to have 'many'
08:14:20 <Abraxas> but i was trying to keep with the parser combinators
08:14:22 <Cale> That would be useful
08:14:25 <Abraxas> i do
08:14:33 <Abraxas> hold on
08:14:59 <Abraxas> ah, forgot to paste Parser
08:16:20 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (adding Parser module)” at http://hpaste.org/54308#a54324
08:17:15 <Abraxas> i tried many, but then how can i access the intermediate results?
08:17:25 <Abraxas> i thought i had to write it from scratch
08:17:51 <Cale> Abraxas: heh, this library has some unusual naming conventions when it comes to infix operators. Usually +++ is called >> and ||| is called +++
08:17:56 <dr_rotflcopter> hey
08:18:13 <Cale> Abraxas: you can write  xs <- many parse_asbs
08:18:27 <Cale> Abraxas: and then examine xs (which is guaranteed to only contain 'a' and 'b'
08:18:28 <Cale> )
08:18:34 <dr_rotflcopter> still having issues calculatin the common area of a square and a circle
08:18:44 <Abraxas> yeah, it's supposed to disguise the common parser functions
08:18:44 <dr_rotflcopter> Cale<< can you give a hint?
08:18:47 <Cale> Abraxas: however...
08:19:10 <Cale> you could write something like:
08:19:54 <Abraxas> damn...i realize only NOW that i am doing it all way too complicated
08:19:54 <Fuco> what does the pipe mean in this: class (Monoid w, Monad m) => MonadWriter w m | m -> w where
08:20:13 <Abraxas> i mean, it could be good practice to try and do something weird like i am doing right now
08:20:18 <ClaudiusMaximus> Fuco: functional dependencies (aka fundeps)
08:20:27 <Abraxas> but anyway, i could just count the characters when the parse is done
08:20:34 <Abraxas> lol
08:20:40 <Fuco> and what is that?
08:20:47 <Cale> balance <- mapP sum . many $ (sat (=='a') >> return 1) ||| (sat (=='b') >> return (-1))
08:20:48 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
08:20:56 <Fuco> good, thanks:P
08:21:04 <Cale> Abraxas: if balance is 0, then there were the same number of 'a' and 'b' characters :)
08:21:20 <ClaudiusMaximus> Fuco: sorry, i've not used them in anger, so don't know much about them
08:22:01 <Cale> Abraxas: since your parsers can return any type of value, you can have them return numbers too :)
08:22:29 <Fuco> it kind of seems like a syntactic sugar of sorts. Instead of writing m w I just use w
08:23:33 <Cale> Fuco: It's not syntactic sugar. It means that you're only allowed to write one instance of MonadWriter for any given m, and it allows type inference to determine w when given m
08:23:55 <Cale> wat
08:24:06 <Fuco> aren't you allowed to write only one instance for each type anyway?
08:24:31 <hpc> Fuco: multiparameter type classes are more complicated
08:24:40 <Cale> Fuco: you would normally be allowed to write an instance for each possible combination of types m and w
08:24:45 <hpc> you could have instance Foo m Int, and instance Foo Bar w
08:24:51 <Fuco> oh, it has two parameters, I see
08:24:57 <hpc> er, what Cale said
08:25:00 <hpc> ignore me
08:25:43 <BMeph> hpc: What? Did you say something? ;)
08:25:51 <dr_rotflcopter> synthetic sugar ia everywhere
08:25:57 <Fuco> I think that for now I'll just move on :D
08:26:03 <Cale> semantic sugar?
08:26:10 <Abraxas> cale: cool, thanks
08:26:44 <Abraxas> but seriously, why am i always doing things far more complicated than i have to
08:26:51 <dylex> I've actually always wondered why, say, MonadReader has that fundep.  It doesn't seem technically necessary, just prevents you from having to use some extra type signatures (and perhaps scoped type variables).
08:27:10 <Abraxas> since i have to parse the whole string, what difference does it make if i run a function over it AFTER the parse...ouch
08:27:42 <Fuco> so when I have instance Monoid w => MonadWriter w (Writer w) , Writer w is the m in the class definition right?
08:28:11 <Fuco> and that m -> w tells me the w there has to match?
08:28:16 <Abraxas> if doing weird shit like that would at least teach me something other than that i was doing too much work :D
08:28:31 <Cale> Abraxas: that's also possible, though it's also kinda nice to build your small parsers so that their results combine nicely into the information you want without having to do much extra processing at the end.
08:28:54 <Cale> Fuco: yeah
08:30:29 <Cale> Fuco: You can't now write something like  instance MonadWriter Integer (Writer w)
08:30:38 <Cale> because of the m -> w
08:30:44 <Fuco> I see
08:31:04 <Fuco> and they have to match because it wouldn't make sense otherwise, since you use tell to append to the Monoid inside the writer
08:31:35 <Fuco> oh man monads are amazing ;P
08:31:57 <Cale> Well, yeah, the functional dependency helps type inference determine what's going on when you use the operations and not complain about ambiguity.
08:32:46 <Cale> Though, in this case, the operations aren't likely to introduce all that much ambiguity anyway
08:33:32 <Cale> With reader though, for example, the type of 'ask' would be ambiguous without the corresponding functional dependency.
08:34:39 <Saizan> not really, both m and r appear in the type
08:36:33 <Fuco> ok now, the type of the tell is tell :: w -> m ().. that means it takes a Monoid value and return the Monad with no value attached? In the case of say lists and Writer id' be [a] -> Writer ()... now if I chain that with >>=, how would matching a () work?
08:37:05 <Fuco> or in other words, what the hell does () mean there?
08:37:54 <Fuco> oh wait, Writer actually have two type arguments...
08:37:59 <Fuco> so it'd be [a] -> Writer [a] () ?
08:39:00 <Saizan> yes
08:39:26 <dr_rotflcopter> Cale<< are you in coordinate-geometry?
08:39:30 <dylex> Fuco: right, the () being in the monad, so you could (if you wanted) write do () <- tell x
08:39:47 <Cale> dr_rotflcopter: what do you mean 'in'?
08:39:58 <dr_rotflcopter> having issues calculatin the common area of a square and a circle
08:40:15 <Fuco> and () <- tell x is the same as tell x >> right?
08:40:23 <Fuco> I just ignore the return value of tell
08:40:28 <dylex> right
08:40:29 * monochrom doesn't like #haskell turning into a catch-all geek channel
08:40:29 <jerry> i am inside "main" function an dtrying toi create  "widgetSetSizeRequest someFrame 1000 1000".......i also have function "myFunction that returns pair of Int"....i would like to use "myFunction" to this pair and use those 2 ints inside i am inside "main" function an dtrying toi create  "widgetSetSizeRequest someFrame 1000 1000".......i also have function "myFunction that returns pair of Int"....i would like to use "myFunction" to this
08:40:44 <bluej774> How can you get the level of precedence of an operator in ghci?
08:40:44 <Saizan> it's more like tell x >>= \ () -> ..
08:40:53 <rostayob> Fuco: it's not exactly the same
08:40:58 <Fuco> yea, that's what you get when you expand >>= or?
08:40:59 <rostayob> >> discards the result
08:41:13 <rostayob> with () you pattern match it
08:41:18 <Saizan> bluej774: :info
08:41:21 <bluej774> thanks
08:41:35 <elliott_> Using Control.Exception, how should I represent an exception hierarchy where the top-level exception type just has an error code, and a subtype of that has an error code and an integer? The example in Control.Exception doesn't really help as it doesn't show any way to have a supertype with less information than a subtype. Maybe I'm going about this the wrong way -- if so, what kind of exception hierarchy should I use for this situation? Thanks :)
08:41:56 <jerry> monochrom: can you help me with something please
08:42:00 <Abraxas> balance :: Num b => Parser b
08:42:00 <Abraxas> why
08:42:08 <roaldfre> is there a special function to do comparison on floats/double that takes the machine accuracy in account?
08:42:41 <yitz> Cale: what's the prognosis on lambdabot?
08:43:40 <dylukes> lambdabot's not seeming very reliable as of late.
08:43:48 <monochrom> roaldfre: http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm may help
08:43:53 <yitz> :(
08:44:07 <Cale> yitz: I didn't know it was missing
08:44:35 <yitz> looking at my scrollback, it seems to have gone missing during a netsplit about 3.5 hrs. ago
08:44:40 <Cale> okay
08:44:42 <roaldfre> monochrom: thanks! Do you know if there is a way to query the machine epsilon in haskell?
08:44:52 <yitz> Cale: oh, ok. i was sure you were being pestered about it :)
08:45:20 <jerry> guys how do i use function that returns Int inside " main" function....reason i ask is because i would like to use that integer inside this function -
08:45:32 <jerry> > widgetSetSizeRequest
08:45:40 <lambdabot>   Not in scope: `widgetSetSizeRequest'
08:45:46 <elliott_> Cale: hmm, has lambdabot forgotten state? it hasn't rejoined a channel which I think was on autojoin
08:45:46 <monochrom> it has enough functions to let you write a loop to find the machine epsilon
08:45:47 <yitz> yay!
08:45:59 <Cale> elliott_: I dunno
08:46:09 <Cale> elliott_: It has a lot of channels to join
08:46:15 <Cale> and I'm not sure what the limit is
08:46:19 <elliott_> heh
08:46:21 <roaldfre> monochrom: I see, that's probably the most robust approach anyway, I guess.
08:46:21 <opqdonut> jerry: "main = do ...; i <- anIOActionReturningAnInt; let j = aFunctionReturningAnInt arg1 arg2; ..."
08:46:25 <ddarius> It takes a long time for lambdabot to join all the channels.
08:46:27 <elliott_> I think it's like 20 on freenode unless you get a mode expanding it to 100
08:46:40 <Cale> I'm pretty sure lambdabot has that mode
08:46:41 <ddarius> elliott_: lambdabot has that restriction lifted.
08:46:48 <opqdonut> jerry: two different ways depending on whether it's of type "something -> IO Int" or just "something -> Int"
08:46:51 <Cale> or maybe it's lifted altogether?
08:46:53 <Cale> okay
08:46:56 <Cale> what channel?
08:46:58 <bluej774> Who decided it would be a good idea to make the precedence of the operators in Data.Bits opposite of what they are in most languages?
08:46:59 <elliott_> I would expect the mode.
08:47:13 <elliott_> At least I've never heard of it being completely lifted.
08:47:14 <ddarius> I'm not sure if it's lifted altogether, but lambdabot can certainly join more than 20 channels.
08:47:16 <Cale> what channel is it?
08:47:58 <jerry> opqdonut: my function that returns Int type....so i want to use that int to create sinwod using this function widgetSetSize.......function that returns Int is outside main.......call to widgetSetSize is inside main
08:47:59 <elliott_> Cale: #esoteric, which has admittedly fallen off the autojoin list several times :-)
08:48:13 <Cale> It's still in the join list
08:48:19 <elliott_> And it just joined.
08:48:25 <elliott_> Guess it was just taking a while.
08:48:32 <Fuco> but wait, now if I do use tell on some writer with a value, it will replace that value with () eh?
08:48:38 <Cale> There's a rate limit on lambdabot's output
08:48:52 <Cale> so it takes its time joining each channel on startup
08:49:09 <Cale> #haskell happens to be first ;)
08:49:45 <monochrom> roaldfre: actually floatRadix (which is usually 2) and floatDigits may help a lot, so you don't even need a loop
08:50:10 <monochrom> floatDigit gives the size of the mantissa
08:50:27 <roaldfre> perfect! That's exactly what I was looking for! Thanks! :-)
08:50:40 <jerry> opqdonut: so how do i do it if my function is return Int rather then IO Int
08:53:07 <opqdonut> jerry: look at the type!
08:53:37 <jerry> opqdonut: ok let me paste what i did
08:53:50 <opqdonut> jerry: okay, I read what you want to do, "main do ...; let size = function arg arg; widgetSetSize size; ..."
08:54:09 <opqdonut> jerry: or just simply "do ...; widgetSetSize (function arg arg); ..."
08:54:29 <jerry> opqdonut: i kno.w..its complaining about something..."not in scope"
08:55:04 <opqdonut> paste your code somewhere
08:55:35 <hpaste> stribor pasted “main” at http://hpaste.org/54328
08:55:47 <jerry> opqdonut: ^
08:56:00 <jerry> opqdonut: it says a is not in the scope
08:56:15 <opqdonut> first of all, is that stuff in a do block?
08:56:22 <jerry> opqdonut: yes
08:56:38 <opqdonut> secondly, if "myFunction" has a type "... -> Int" you should use "let" and not "<-"
08:56:54 <opqdonut> "<-" is for running IO actions, i.e. things with type "... -> IO Int"
08:56:56 <Cale> v <- x  means  "run the action x, and call its result v"
08:57:08 <opqdonut> yep
08:57:10 <Cale> if x isn't an action, then you don't want to run it
08:57:38 <opqdonut> "let v = x" means "give the name v to the expression x"
08:57:47 <opqdonut> roughly
08:57:47 <monochrom> that would still not cause a "not in scope"
08:58:35 <opqdonut> yeah I'm baffled by that. is it because of the ";"?
08:58:44 <opqdonut> or is the indentation wrong
08:58:49 <jerry> opqdonut: http://hpaste.org/54329
08:58:50 <monochrom> it is because of showing you minimal code
08:58:50 <illissius> let's say you have an existential type: data Foo = forall a. Bar a => Foo a. in the sentence Foo `verb` Bar, what would you use for verb? represents? wraps? encloses? evidences? contains? is there anything canonical?
08:59:15 <monochrom> "let a = function arg1"
08:59:24 <opqdonut> jerry: you forgot "let". and please paste the whole function. two-line snippets don't help
09:00:04 <opqdonut> (since we can't know whether you've misindented or something)
09:00:22 * monochrom still refuses to believe this to be the real code. no, not even excerpt of the real code. more like there is much secret involved and so the asker must paraphrase every token before pasting
09:00:57 * monochrom doesn't like to play zero-knowledge-proof games
09:01:00 <opqdonut> yep
09:02:09 <monochrom> the interesting question though is why does a beginner have much secret to keep? normally you only assign secret projects to a pro...
09:03:51 <jerry> monochrom: of course it is not a real code....i am  just trying to see why it is giving me parsin error...thats why i am asking all these questions....i
09:04:05 <zhulikas> @t (++)
09:04:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:04:22 <elliott_> jerry: You're trying to figure out how you get a parse error by giving us code that isn't the code that's getting a parse error?
09:04:25 <zhulikas> @type (++)
09:04:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:04:45 <elliott_> zhulikas: That, um, is not the canonical type for (++).
09:04:54 <elliott_> @type (Prelude.++)
09:04:55 <lambdabot> forall a. [a] -> [a] -> [a]
09:04:56 <zhulikas> I want to learn more about ++
09:05:06 <saati> @src (++)
09:05:07 <lambdabot> []     ++ ys = ys
09:05:07 <elliott_> It appends two lists.
09:05:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:05:08 <lambdabot> -- OR
09:05:08 <lambdabot> xs ++ ys = foldr (:) ys xs
09:05:11 <jerry> elliott_: i know..sorry...
09:05:30 <jerry> http://hpaste.org/54332
09:06:04 <zhulikas> @src reverse
09:06:04 <lambdabot> reverse = foldl (flip (:)) []
09:08:17 <elliott_> hmm, does anyone have any links to anything about constructing exception hierarchies with Control.Exception? it seems like what I'm trying to do should be easy, but maybe I'm just getting the whole thing wrong :)
09:09:27 <Cale> elliott_: Did you read the haddock?
09:09:33 <Cale> There are a few examples there
09:09:45 <elliott_> Cale: Yep, but as I said: "The example in Control.Exception doesn't really help as it doesn't show any way to have a supertype with less information than a subtype."
09:10:00 <Cale> Oh, sorry, I missed that part ;)
09:10:36 <Cale> Errr...
09:10:56 <Cale> It doesn't?
09:11:13 <elliott_> No.
09:11:23 <ddarius> elliott_: I'm not sure where you said that and I don't know what you mean.  What's demonstrated in the haddock seems exactly like what a typical exception hierarchy is.
09:12:02 <elliott_> If I have TopException, containing an ErrCode, and a SubException, containing an ErrCode and a String, and all SubExceptions should be catchable as TopExceptions with the same ErrCode, how can I express that? If I can't: How should I express this hierarchy by some alternative means?
09:12:39 <elliott_> I suppose I could define my own subclass of Exception with errCode :: e -> ErrCode, and then make TopException an existential of that.
09:12:44 <elliott_> But it feels like overthinking things.
09:13:04 <jerry> elliott_: does "let" have to be indented
09:13:13 <elliott_> jerry: Huh?
09:15:44 <saati> jerry: the in can't be on a column that's before the column of let
09:16:30 <hpaste> Idiot pasted “gentle Points” at http://hpaste.org/54335
09:16:45 <jerry> i found that problem with identitation inside do was because my do had brackets  ...i had it like this -> do {.................}....i took brackets off and no errors
09:17:01 <jerry> does anyone know taking brackets made it work
09:18:02 <opqdonut> you might've forgotten a ;
09:19:06 <jerry> opqdonut: no it wasnt that..i had ";"
09:19:17 <ion> Too many ;s? :-)
09:20:45 <elliott_> Hmm, I guess the Exception subclass is probably what you're Meant To Do, so I'll go with that for now if nobody sees any problems with it...
09:21:09 <elliott_> ...actually I do, it stops you pattern-matching on the simple error-code-only type...
09:21:47 <ddarius> It does look like it is difficult to have intermediate types in the hierarchy that have extra data.
09:22:24 <elliott_> The only way I can think of is to make the top exception be the pair of ErrCode and String, and define the ErrCode-only variant as a subtype that uses an empty string.
09:22:28 <elliott_> That's really ugly, but it'd work.
09:22:37 <yitz> elliott_: the exception hierarchy has to do with which exceptions get caught. nothing to do with what data is inside.
09:23:17 <elliott_> yitz: Sure, I realise that, but this is a case where refining a catch based on the subtype is a reasonable thing to do.
09:23:20 <jpf_> i'm following the gentle haskell tutorial, in it they have this example: "data Point a = Pt a a" Is this even necessary? What is the usual alternative to declaring a variable with this type?
09:23:24 <yitz> elliott_: how would you want to express your data types apart from them being thrown and caught?
09:23:25 <elliott_> I'm not just trying to represent (ErrCode, Maybe String) awkwardly :-)
09:24:18 <elliott_> yitz: It'd probably look like data Err = SimpleErr ErrCode | SubErr ErrCode String, but the problem is that that makes catching just SubErrs awkward.
09:24:38 <elliott_> As well as catching in the SimpleErr form, since you need to treat (SubErr e _) as (SimpleErr e) for that purpose.
09:24:46 <yitz> elliott_: well right they have to be separate types
09:24:47 <ddarius> jpf_: That's not declaring a variable at all.
09:25:12 <elliott_> yitz: right, so my question is how to organise the Exception hierarchy :P
09:25:13 <jpf_> ddarius: oh, i mean, what is alternative without using a type constructor?
09:25:31 <yitz> elliott_: what's wrong with data SimpleErr ErrCode; data SubErr ErrCode String?
09:25:53 <yitz> oops left out the = but anyway
09:25:55 <elliott_> yitz: How can I define the Exception SubErr instance? The example in Control.Exception erases via an existential.
09:26:15 <yitz> elliott_: yes, do it that way, what's the problem?
09:26:22 <elliott_> yitz: Where's the existential?
09:26:55 <elliott_> yitz: I take it you mean, have data SomeErr = forall e. Exception e => SomeErr e as in the documentation?
09:27:06 <elliott_> The problem then is, how can I define SimpleErr's fromException so that (SubErr e _) becomes (SimpleErr e)?
09:27:20 <elliott_> I suppose I could combine this with my own subclass of Exception like I was thinking... seems awfully involved though.
09:29:11 <elliott_> yitz: Actually, that could work if I just don't export SomeCLError or the class...
09:29:26 <ddarius> I take back what I said, I think this is readily doable.
09:29:26 <elliott_> Then you can catch everything with the error-code version or the subtype without worrying about how ugly it is underneath.
09:29:39 <elliott_> ddarius: I hope so :P
09:31:24 <elliott_> ddarius: Is it just with the subclass approach I mentioned, or...?
09:33:05 <ddarius> elliott_: You just do what the example in the haddock does.
09:33:10 <ddarius> I'll have an example momentarily.
09:33:24 <elliott_> I couldn't figure out how to make that fit my model, but OK, I'll wait :-)
09:33:33 <Abraxas> Cale: why is balance :: Num b => Parser b ?
09:34:15 <zhulikas> @src dropWhile
09:34:16 <lambdabot> Source not found.
09:34:26 <Cale> Abraxas: well, the way I wrote it, balance should have been a number, but if you just return that number, it'll be a parser which produces the number as its result
09:34:58 <Cale> Abraxas: Specifically, the number is just the number of a's minus the number of b's.
09:36:52 <Abraxas> should this work: parser = \inp -> if (equalAsAndBs inp) == [0] return inp else failure
09:37:05 <Abraxas> renamed balance, sorry
09:37:57 <Abraxas> forgot the then, lol
09:38:17 <Abraxas> The function `balance' is applied to one argument, but its type `Parser b0' has none
09:39:29 <Abraxas> not exactly sure how this works on a string
09:39:36 <Abraxas> but it does
09:39:38 <hpaste> ddarius pasted “Exception hierarchy” at http://hpaste.org/54336
09:39:54 <Abraxas> but i need to check inp
09:40:25 <elliott_> ddarius: Hmm, right, that work, and embedding the code directly into the top exception is a neat trick.
09:40:39 <elliott_> The pattern matching isn't as nice as I'd like, but I suppose it's not much of a big deal.
09:41:04 * hackagebot blaze-html 0.4.2.2 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.4.2.2 (JasperVanDerJeugt)
09:41:25 <Abraxas> this doesn't work, either: parser = \inp -> if (parse balance inp) == [0] then return inp else failure
09:41:27 <ddarius> elliott_: There's no reason for you to pattern match on TopException unless you don't care what the subexpression is, in which case the error code has to be in TopException.
09:41:51 <Abraxas> with parser "abab"...shouldn't that work?
09:41:58 <elliott_> ddarius: The vast majority of cases won't care what the subexpression is; most exceptions are just the error code.
09:42:06 <elliott_> But \(TopException e _) -> ... isn't bad.
09:42:12 <ddarius> Indeed.
09:42:23 * Cale wonders if anyone's already made a slightly less derpy interface to OpenGL vertex arrays.
09:42:35 <ddarius> You can also use something like getErrCode or a record field instead.
09:42:48 <ddarius> (Except that I think records don't work with existentials.)
09:43:04 <Abraxas> show error
09:43:17 <Abraxas> but inp == "abab", i would think
09:43:53 <Cale> Abraxas: don't use 'parse' inside a parser
09:44:07 <elliott_> ddarius: Actually, I think I can regain the pattern-matching properties with this basic design.
09:44:11 <Cale> Abraxas: that's what do-notation / the monad combinators are for
09:44:32 <elliott_> ddarius: I just need a data MostError = MostError ErrorCode, define that as an Exception going through TopException, and throw that most of the time.
09:45:12 <Cale> Abraxas: did you also need the string of a's and b's as the result?
09:46:03 <Abraxas> yes
09:46:12 <Abraxas> yeah, i know, using parse is bad
09:46:43 <Abraxas> but balance doesn't take a string
09:46:45 <Cale> Abraxas: okay, so you need more than just the numbers
09:46:59 <Cale> balance was a number in my code, but you've turned it into a parser :)
09:46:59 <Abraxas> i was wondering why balance works on a string
09:47:21 <Abraxas> since it takes a Num
09:47:30 <Cale> what do you mean?
09:47:40 <Abraxas> it's probably because i am not familiar with >>, yet
09:47:48 <Abraxas> only >>=
09:47:54 <yitz> ddarius, elliott_: in summary: so the idea is that toException and fromException are used when the runtime wants to cast an exception up to a type higher in the hierarchy. to do that, you need the extra existential parameter in the higher level types to hold the lower level thing that got casted. other than that, the types can be pretty much whatever you want. sound right?
09:47:55 <Cale> You had  balance :: (Num a) => Parser a, right?
09:48:00 <Cale> That's not a function.
09:48:03 <elliott_> yitz: Right.
09:48:31 <Cale> Abraxas: x >> y is the same as x >>= const y
09:48:32 <Abraxas> parse balance "abab" -> [0]
09:48:35 <elliott_> Thanks ddarius and yitz, I now have a solution with perfect pattern matching and subtyping without a bunch of hacks :)
09:48:48 <Abraxas> ok, that's like +++ and ++>
09:49:00 <Cale> yes, >> is your +++
09:49:01 <ddarius> yitz: Exception implements exactly a Java-like class hierarchy except that you have to explicitly upcast.
09:49:04 <Abraxas> we started with parsers as an introduction to monads
09:49:18 <Abraxas> that's why the syntax is "secret" like that
09:49:25 <Abraxas> undercover
09:49:30 <Cale> but it pains me to write +++ because that means something else usually
09:50:10 <Abraxas> i guess the lecturer tried to keep it a secret that it's the same thing
09:50:13 <yitz> ddarius: well, you have to say explicitly *how* to upcast. the runtime decides when.
09:50:37 <Abraxas> ok, >> would name clash
09:52:26 <Cale> Abraxas: >> is already defined and does that.
09:52:33 <Cale> Abraxas: it's defined in terms of >>= in the prelude
09:52:40 <Cale> and you have a definition of >>= for Parser
09:52:47 <Cale> so it'll work :)
09:53:17 <monochrom> import Prelude hiding((>>), (>>=), return, fail)
09:54:04 <Abraxas> ah, right...there is the def
09:54:24 <Abraxas> ok, he did it, so that he could show that it's monads
09:54:33 <Abraxas> by redefining it later on
09:55:11 <Abraxas> uh no, hold on...i am still talking about >>=
09:55:27 <dmos> Is there (or how would I write) a BoundedChan, which uses a contiguous (unboxed) vector underneath, and preferably with as little locking as possible (atomic*IORef?). The problem I run into is how to guarantee sequential consistency for *parts* of the vector... Ideas?
09:55:45 <Abraxas> there is no def for >> in MParserCore, i think
09:55:47 <Cale> Abraxas: It's in the Haskell Prelude.
09:55:49 <Abraxas> but anyway
09:55:54 <dmos> (contiguous vector -> ringbuffer)
09:56:04 <Abraxas> then i was right the first time :D
09:56:08 <Cale> Abraxas: In fact, it's part of the definition of the Monad class itself.
09:56:15 <Cale> Abraxas: but with a default implementation
09:56:41 <Cale> (it's only in there in case some instances have a more efficient implementation of >> than the default one)
09:57:31 <Cale> dmos: Use STM + TArray?
09:58:44 <Abraxas> ok, now that's weird...balance :: Parser Int
09:58:53 <Cale> dmos: Maybe the overhead is too much, but at least that would be a reasonably easy exercise to think about, rather than being publishable.
09:58:57 <Abraxas> i didn't change anything, why did it show me a different type back then
09:59:17 <Cale> Abraxas: Parser Int is just a more restricted type than the polymorphic type it used to have
09:59:35 <dmos> Cale: yeah, I'm arriving at the same conclusion. I'm running into a wall with my requirements at the moment.
09:59:59 <Abraxas> that's what i thought it would be
10:00:18 <noidea> @help
10:00:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:00:48 <noidea> 'list'
10:01:04 <Abraxas> but GHCI said it's Num b => Parser b
10:01:14 <Abraxas> no longer does
10:01:20 <Abraxas> no clue what happened there
10:01:48 <dmos> Cale: do you happen to know (or know where to look) how the STM is implemented underneath in terms of primitives (crit sections etc.)?
10:02:09 <Abraxas> oh right, i see...
10:02:12 <Abraxas> :t (mapP sum . many $ (sat (=='a') >> return 1) ||| (sat (=='b') >> return (-1)))
10:02:13 <Abraxas> (mapP sum . many $ (sat (=='a') >> return 1) ||| (sat (=='b') >> return (-1)))
10:02:13 <Abraxas>   :: Num b => Parser b
10:02:13 <lambdabot> Not in scope: `mapP'
10:02:14 <lambdabot> Not in scope: `sat'
10:02:14 <lambdabot> Not in scope: `sat'
10:02:23 <Abraxas> yeah yeah
10:03:10 <monochrom> monomorphism restriction causes balance :: Parser Int
10:03:13 <Cale> dmos: I vehemently don't care about how STM is implemented, as if it doesn't work well enough, it's the GHC guys' problem. ;)  However, there are some details about a possible implementation in the original paper on STM. I don't know whether those details actually still apply.
10:03:14 <Abraxas> got the exact same thing bound to the function balance and then :t balance shows Parser Int
10:03:16 <Abraxas> huh
10:04:17 <Cale> Where by "original paper on STM" I mean "original paper on STM in Haskell" which is http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
10:04:19 <noidea> are there any precompiled binaries of Yi?
10:04:27 <dmos> Cale: I know, always nice to stay at the abstract level, unfortunately, I might not be able to do that. I'll work myself through the wiki as a warmup and will see where that gets me.
10:04:32 <tgeeky> noidea: no idea
10:04:36 <tgeeky> (had to)
10:04:38 <monochrom> monomorphism restriction says that if you define "name = ..." and the inferred type involves Num etc, computer will look for an excuse to kill the polymorphism and choose a specific type
10:04:39 <dmos> Cale: Ah thanks. will look into it.
10:04:40 <noidea> thanks tgeeky
10:04:48 <tgeeky> noidea: I think not, though
10:05:19 <Abraxas> let balance_ = (mapP sum . many $ (sat (=='a') >> return 1) ||| (sat (=='b') >> return (-1))) in t: balance_ -> balance :: Parser Integer
10:05:20 <noidea> yea all Ive seen are guides on how to compile from source :/
10:05:28 <Abraxas> ok, seriously, why is that
10:05:44 <Abraxas> same thing, different type, just because it's bound to a function??
10:05:49 <Cale> dmos: Actually, my first implementation of a bounded Chan using STM would not be to use TArray
10:06:02 <Cale> dmos: I'd use a TVar Integer and a TChan :P
10:06:13 <hpc> Abraxas: look up the monomorphism restriction in the GHC docs
10:06:14 <Abraxas> the "->" is supposed to be the result of that line, sorry for confusion
10:06:37 <hpc> Abraxas: it's easy to fix with an explicit type signature (which you should be doing anyway)
10:06:47 <Cale> dmos: That would be absolutely trivial to implement, requiring pretty much zero actual thinking, and has a good chance of being efficient enough.
10:07:07 <Abraxas> hpc: but i get the Parser Int while i don't get the other type
10:07:14 <monochrom> because imagine you define "x = 5". do you expect x to be a "constant"? i.e., every time x is evaluated, you expect little or no computation?
10:07:21 <dmos> Cale: the version on hackage uses two MVars and and an Array of MVars.
10:07:30 <Abraxas> aaah, forget it
10:07:33 <Abraxas> stupid again
10:07:40 <Abraxas> it's a =>
10:07:45 <Cale> dmos: Yeah, that actually sounds significantly harder to write :)
10:08:10 <Abraxas> Parser a is the type, with a bound to a Num...not Num a -> Parser a... :p
10:08:16 <Abraxas> *slap*
10:09:05 <Abraxas> and because Parser a is defined in the modules...yeah
10:09:30 <Abraxas> oooook
10:09:58 <dmos> Cale: It's actually fairly short, about 2 pages of code (1 with a large screen). The problem there is really the Array of MVars which I'd like to replace with something that has a better memory layout.
10:12:05 <dmos> Cale: different question. Can I forced a certain memory layout of independent small objects (vectors). Let's say I want to allocate a block of memory of 1024 4Kb vectors. Can I force them to be adjacent in memory?
10:13:16 <Cale> dmos: Use one of the unboxed array libraries.
10:13:36 <Abraxas> how would i get balance applied to the first parse: parser = do {x <- many parse_asbs; y <- balance x; return y}
10:13:47 <dmos> Cale: ok, will have a look. Thanks for the help.
10:13:52 <Cale> dmos: If you care about how they'll be perceived by foreign code, then StorableArray or Data.Vector.Storable are your best bets.
10:13:56 <hpc> Abraxas: what's the type of balance now?
10:13:58 <hpc> Parser a?
10:13:58 <Abraxas> i though balance takes a String and x is a String
10:14:11 <Abraxas> Parser Int
10:14:16 <monochrom> y <- balance;
10:15:08 <dmos> Cale: It's not so much about foreign code, but that they align properly in memory and are read sequentially. todays CPU archs optimize such constant spaced memory access and can prefetch, that's what I'd like to exploit.
10:15:30 <Abraxas> ultimately i wanted to do: if balance x == [0] then return x else fail
10:15:52 <Cale> dmos: Have you already written the code that you're going to write without caring about this detail and determined that it's too slow? :)
10:16:59 * dmos quietly slinks away, after Cale's remark reminds him about premature optimization and all that.
10:17:07 <Cale> :)
10:17:09 <Abraxas> instead of y <- balance x
10:17:24 <Cale> dmos: Since the unboxed arrays pretty much use the same interface as the boxed ones, the translation should be pretty easy, so long as your array elements are simple
10:18:00 <Cale> dmos: and to be honest it's not all that hard to go from a dense Data.Map to a packed array most of the time.
10:18:10 <Cale> (though maybe a little more work)
10:21:04 * hackagebot off-simple 0.1 - A parser for simplified-syntax OFF files  http://hackage.haskell.org/package/off-simple-0.1 (AdamFoltzer)
10:22:04 <dmos> Cale: ok. My contents should be fairly simple, and for now at least really only arrays of bytes, which simplifies things. Custom datatypes requiring Storable etc. come later.
10:22:25 <Abraxas> is it even possible to hand it over to balance, cale? :D
10:23:27 <cgroza> Hello everyone. Is there a function that lists all the subdirectories of a directory? The System.Directory gives me relative names, and it includes the files also, I need only the directories and the full paths...
10:24:09 <hpaste> b pasted “a” at http://hpaste.org/54339
10:24:19 <zhulikas> what's wrong with this one?
10:24:39 <zhulikas> I want to map a value to a tuple
10:24:47 <zhulikas> of (Int, a)
10:25:02 <Cale> Abraxas: balance isn't a function, it doesn't take parameters, it's a number, or in your code, it's apparently a parser
10:25:24 <Cale> Abraxas: (in your case, you run the parser to get a numeric result)
10:25:30 <Cale> (and it eats some input)
10:27:29 <dylex> zhulikas: what's pack do (and what's its type)?
10:27:36 <ddarius> :t pack
10:27:36 <monochrom> what is "pack"? what is "myLength"?  erase your type signature "encode :: (Eq a) => [a] -> [(Int, a)]" and find out what type the computer infers, to see why you had totally wrong ideas of what your type means?
10:27:37 <lambdabot> forall o n. (Newtype n o) => o -> n
10:27:40 <ddarius> hmm
10:27:46 <zhulikas> pack :: (Eq a) => [a] -> [[a]]
10:28:35 <monochrom> then most likely the computer will infer encode :: (Eq a) => [[a]] -> [(Int, [a])] ?
10:28:48 <Abraxas> but it should not be too hard to keep that input
10:29:01 <Abraxas> and return it instead
10:29:42 <shachaf> cgroza: Something along the lines of getDirectoryContents "." >>= filterM doesDirectoryExist >>= mapM canonicalizePath?
10:29:52 <zhulikas> sorry, my bad
10:29:57 <zhulikas> monochrom, you are right
10:30:02 <monochrom> actually encode :: (Eq a) => [a] -> [(Int, [a])]
10:30:02 <zhulikas> it should be (Int, [a])
10:30:19 <cgroza> shachaf: let me test it. Thanks
10:30:32 <zhulikas> awesome, works o/;
10:30:33 <zhulikas> o/
10:31:04 * hackagebot thrist 0.2.1 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.2.1 (GaborGreif)
10:32:27 <cgroza> shachaf: perfect. Except it includes ./. and ./.. .
10:32:42 <shachaf> So exclude them.
10:32:52 <cgroza> shachaf: yes :D
10:34:38 <shachaf> Something like filter (`notElem` [".",".."]) <$> getDirectoryContents "." >>= filterM doesDirectoryExist >>= mapM canonicalizePath
10:35:29 * ddarius thinks he will steal Yesod's type-safe URL idea.
10:43:47 <timp_> Created in Haskell http://context-computing.co.uk/FPR/fpr.xhtml - yay me!
10:45:05 <sbi> xhtml validator link is so 90s
10:45:38 <monochrom> so is IRC
10:45:55 <sbi> you got a point :p
10:46:39 <monochrom> in fact, with more than 90% probability, you're even running IRC software inside a "terminal"
10:49:40 <companion_cube> where did you get this probabilty? :)
10:50:16 <monochrom> The 2010 Survey of Programmers On IRC
10:50:27 <companion_cube> neat
10:50:53 <Philonous> 87% of all statistics are made up on the spot!
10:51:43 <companion_cube> 104% of statistics are inaccurate!
10:52:37 <gwern> lovely. a legal threat over the romanian stuff
10:52:52 <gwern> wonder who I should forward this to - not sure I even have ashley's address
10:54:23 <gwern> who's in charge of the haskell.org stuff anyway?
10:55:37 <ddarius> There's a committee for it.
10:56:24 <zugz> I want to use a package which isn't supported by hugs (system.process) - is there a way to fail gracefully if we're run with hugs?
10:56:31 <gwern> ddarius: and who should I be cc'ing on this matter then?
10:57:23 <shachaf> gro.lleksah@haskell.org
10:57:30 <ddarius> gwern: http://haskell.org/haskellwiki/Haskell.org_committee
10:57:50 <ddarius> committee@haskell.org should work.
10:58:34 <gwern> shachaf: leksah?
10:59:07 <shachaf> Disclaimer: That address may not be valid. Also, I may have gotten it backwards.
10:59:09 <elliott_> zugz: nobody uses hugs :P
10:59:36 <shachaf> @hugs
10:59:36 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:59:40 <shachaf> See?
10:59:54 <gwern> heh
11:00:14 <elliott_> @slugs
11:00:14 <lambdabot> Unknown command, try @list
11:00:15 <monochrom> @mugs
11:00:16 <lambdabot> Maybe you meant: bug msg
11:00:20 <elliott_> @pugs
11:00:21 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:11:20 <Brax> i have written it like this, now: parser = do {x <- many parse_asbs; let as = length . filter (=='a') $ x in if as*2 == length x then yield x else failure}
11:13:55 <Brax> parser :: Parser [Char], not quite...
11:19:40 <al3l54h> anyone watched the productive-talk on reddit? is that graham button presenting?=
11:20:02 <al3l54h> I don't have any audio available at the moment..
11:21:17 <Brax> i gave the explicit type signature    parser :: Parser String  and would expect to have Strings returned, not a list of strings, hm
11:21:37 <Brax> *to have a string returned
11:23:36 <sinelaw> greetings!
11:23:49 * sinelaw has been ressurected. 43 manna left.
11:24:46 <sinelaw> ghc 7.2! I've been away for too long
11:26:40 <alpounet_> pretty much yeah :p
11:26:45 <byorgey> al3l54h: I haven't watched it but I assume it is Graham Hutton presenting.
11:26:59 <shachaf> sinelaw: The real excitement is about 7.4, of course.
11:27:20 <ion> No, the real excitement is about 7.6.
11:27:23 <byorgey> Brax: [Char] and String are the same
11:27:25 <sinelaw> what's waiting in 7.4?
11:32:10 <dolio> What's up for 7.6?
11:32:20 <ddarius> sinelaw: 7.2 is a "technology preview" release but also 7.4 adds a bunch of crazy new stuff.
11:32:26 <ddarius> Which is just like Haskellers.
11:32:46 <Brax> yes, but a list of String is returned not a String
11:32:49 <sinelaw> what kind of crazy new stuff
11:32:51 <sinelaw> ?
11:33:00 <sinelaw> and don't say * -> * -> *
11:33:03 <dolio> Constraint kinds and kind polymorphism.
11:33:06 <ddarius> sinelaw: Kind polymorphism and a richer kind system in general.
11:33:16 <Brax> that's because type Parser a = String -> [(a, String)]
11:33:20 <Brax> i guess
11:33:29 <sinelaw> example?
11:33:46 <sinelaw> for my feeble-minded mind
11:33:48 <parcs_> sinelaw: see http://blog.omega-prime.co.uk/?p=127 and http://haskell.org/haskellwiki/GHC/Kinds
11:35:13 <ddarius> @google "Giving Haskell a Promotion" filetype:pdf
11:35:14 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/promotion-tldi12-sub.pdf
11:35:15 <lambdabot> Title: Giving Haskell a Promotion
11:35:44 <shachaf> GHC 7.4 is going to have a much kinder type system.
11:37:26 <Brax> now i don't know how to retrieve the head of the Parser String
11:37:27 <Saizan> ...
11:37:31 <al3l54h> kinder?
11:37:39 <al3l54h> like christmas?
11:38:22 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (far simpler version...)” at http://hpaste.org/54308#a54340
11:39:01 <Brax> last annotation, you can basically forget everything else except the module listing, should you need that
11:39:02 <Philonous> Oh, is it now officially in 7.4?
11:39:48 <Brax> and two posts up, what it's supposed to do
11:40:02 <Brax> parse strings with equal amounts of only a's and b's
11:40:26 <sinelaw> @seen Peaker
11:40:27 <preflex>  Peaker was last seen on #haskell-blah 19 hours, 24 minutes and 3 seconds ago, saying: shachaf: SSDs make laptops expensive :-(
11:40:27 <lambdabot> Unknown command, try @list
11:41:42 <byorgey> Brax: so what exactly is the problem you are having?
11:42:58 <Brax> parse parser "abab" returns ["abab"], should return "abab"
11:43:19 <byorgey> Brax: and what is the type of parse?
11:43:44 <Brax> type Parser a = String -> [(a, String)]
11:43:57 <byorgey> yes, but what is the type of the function 'parse' ?
11:43:58 <Brax> see LParserCore in the hpaste, first post
11:44:30 <Brax> parse :: Parser a -> String -> [a]
11:44:31 <Brax> sorry
11:44:48 <shachaf> parse parser "parse parser"
11:44:49 <byorgey> well, then if you give it a Parser String of course it is going to return a list of Strings.
11:45:08 <shachaf> > parse parser "parse parser "
11:45:09 <lambdabot>   "parse parser \"parse parser \""
11:45:21 <byorgey> Brax: presumably because a parser here is modeled as non-deterministic, i.e. you could have multiple possible parses
11:45:30 <Brax> yes
11:45:59 <Brax> in this case it makes no sense to use this one, but that's fixed for some reason
11:46:10 <shachaf> Brax: So what do you want to do if the list is (a) empty, (b) of one element, (c) of more than one element?
11:46:47 <shachaf> It might be easier to answer in Haskell code than in English. And then it might be easier to put that code in your source file rather than in the IRC channel. :-)
11:46:48 <byorgey> Brax: well, write your own function  maybeParse :: Parser a -> String -> Maybe a, which calls 'parse' and then pattern-matches on the resulting list
11:47:18 <shachaf> byorgey: You could do that but I don't think it actually saves much work for the most part. You still need to pattern-match on the Maybe or something.
11:48:07 <Brax> shachaf: i did an hpaste
11:48:27 <Brax> there is no maybe, it's specifically not to be used
11:49:03 <shachaf> What do you mean by "specifically not to be used"?
11:49:12 <shachaf> Who decides?
11:49:17 <shachaf> ("Decides? It is written!")
11:49:26 <byorgey> Brax: well, you have no hope of writing a function of type  Parser a -> String -> a, unless you use 'error'
11:49:36 <byorgey> because what if the parser fails?
11:50:10 <ddarius> This channel is getting large.
11:51:50 <Brax> it's a web form in autotool and there is a fixed "blueprint" that imports all modules which are allowed
11:52:07 <Brax> it dictates LParserCore to be used
11:52:21 <Brax> from this hpaste, at the top: http://hpaste.org/54308
11:52:56 <ddarius> Maybe is in the Prelude.
11:53:10 <Brax> it's one of the tasks i haven't solved yet and while i don't have to (enough points), i'd like to, anyway
11:53:48 <shachaf> autotool?
11:54:13 <Brax> problem is that i have no idea why the non-deterministic list parser should be used, when it makes no sense in this case
11:54:37 <Brax> name of that web tool
11:55:11 <Brax> evaluates the code on the page
11:58:34 <Brax> anyway, i am gonna quit, my neck kills me, can't think straight
11:58:43 <Brax> thanks for all the help today!
12:00:52 <meme_> hey i need some help with my haskell assignment
12:00:55 <meme_> can anyone help?
12:01:36 <hpc> meme_: what's the assignment?
12:01:39 <ddarius> There may be some psychics here.
12:01:45 <Brax> :p
12:02:05 <meme_> the assignment is just a couple of questions u have to answer
12:02:13 <meme_> unfortunately haskell seems to be very hard for me
12:02:38 <meme_> What does the following do? Describe the four special cases and the main case as a Divide & Conquer algorithm? data Bigit = O | I deriving (Show,Eq) add x y = reverse $ addC O (reverse x) (reverse y) addC O [] [] = [] addC I [] [] = [I] addC carry [] r = addC carry [O] r addC carry l [] = addC carry l [O] addC carry (left:leftOver) (right:rightOver) = sumBigit : (addC newCarry leftOver rightOver) where (sumBigit,newCarry) = case (left
12:02:42 <meme_> thats one of the questions
12:03:01 <Cale> lol, Bigit
12:03:13 <Cale> (normally those are called bits)
12:03:45 <Cale> meme_: You seem to have smushed the entire program onto one line without inserting semicolons
12:03:56 <meme_> sry i copy pasted
12:03:56 <Cale> also, it's cut off
12:04:05 <Cale> hpaste.org
12:04:18 <Cale> http://hpaste.org/new
12:04:27 <meme_> ihttp://hpaste.org/54342
12:04:31 * byorgey likes the word 'smushed'
12:04:33 <byorgey> Cale++
12:04:34 <beefcube> are there some real world case studies of Haskell being used by ordinary programmers and not intellectual/academic elites to accomplish of something of real value?
12:04:45 <danr> this looks like a homework
12:04:47 <danr> :D
12:04:50 <beefcube> something of real value*
12:04:58 <meme_> it is :P
12:05:15 <Cale> beefcube: sure, there are companies using it. The company I'm working for is writing a game for iPhones in Haskell :P
12:05:17 <danr> meme_: your indentation is messed up
12:05:29 <Cale> http://www.haskell.org/haskellwiki/Haskell_in_industry
12:05:59 <meme_> http://hpaste.org/54343
12:06:00 <monochrom> but those companies probably don't qualify for "ordinary programmers"
12:06:15 <monochrom> I mean, employees of those companies
12:06:19 <Cale> heh
12:06:21 <dxq> Cale: do you have any apps on the app store?
12:06:32 <Cale> dxq: not yet, we're still working on our first :)
12:07:11 <Cale> dxq: But hopefully once it's done, we'll be able to write lots more :)
12:07:35 <beefcube> monochrom: point well taken, I'm trying to gauge whether this language is worth my time to learn and do general application programming, or whether in its current state its simply intellectual masturbation/job security tool
12:07:58 <Cale> dxq: We're working on a nice FRP game engine alongside the game, which probably the majority of the programming effort has been put into so far.
12:08:13 <monochrom> you should drop all conditions except "of real value"
12:08:50 <Cale> beefcube: I would say it is, regardless of whether you actually use it directly (though you're going to want to)
12:08:56 <hpc> beefcube: can't it be both?
12:09:00 <meme_> ?
12:09:02 <hpc> :P
12:09:20 <ddarius> I would say "intellectual masturbation" and "job security tool" are somewhat contradictory.
12:09:49 <monochrom> COBOL satisfies both
12:09:55 <ddarius> It can only be useful for job security if you used it for a job to begin with, in which case it presumably is not intellectual masturbation.
12:09:57 <Cale> beefcube: That is to say, you will likely learn enough about programming in general by learning Haskell that it will have been worth learning independently of whether or not you use it to write any useful programs.
12:10:16 <Cale> beefcube: But it *is* a useful programming language already :)
12:10:26 <Philonous> Haskell is an entry drug to agda!
12:10:38 <hpc> beefcube: haskell is far and away the best environment to learn functional programming, because it's the only one that makes you stick to that style
12:11:19 <hpc> (modulo some other ML-like languages, probably)
12:11:38 <ddarius> hpc: No, all widely used MLs are imperative.
12:12:05 <ddarius> hpc: Agda, Coq, and other such languages, would be other languages that enforce an FP style.
12:13:38 <Philonous> ddarius:  I daresay dependently typed programming has little to do with programming in Haskell
12:14:04 <ddarius> Philonous: I agree, but Agda and Coq are still FP languages.  Functional programming doesn't care about your type system.
12:21:05 * hackagebot hosc 0.10.1 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.10.1 (RohanDrape)
12:32:38 <nolrai> So, I think I want a type level queue. Is that even doable?
12:33:23 <nolrai> Yeah it should be..
12:34:31 <ddarius> nolrai: Anything is doable.
12:34:47 <nolrai> Okay good point..
12:35:04 <elliott_> nolrai: You probably don't really want that.
12:35:11 <nolrai> I don't think it should be too hard though..
12:36:17 <hpaste> zhulikas pasted “Result is not applied to enough type arguments” at http://hpaste.org/54344
12:37:04 <zhulikas> :)
12:37:12 <zhulikas> any ideas?
12:37:16 <nolrai> elliott: your right I just want something like function types.
12:38:15 <nolrai> zhulikas: should be " [a] -> [Result a b]" or some such.
12:38:30 <zhulikas> but I am not sure whether it will be Single or Multiple
12:39:03 <zhulikas> ok, thanks :D
12:39:21 <nolrai> Either way the type is Result a b.
12:39:37 <zhulikas> or b a in my case
12:40:32 <nolrai> Yes. btw, I don't think what you are trying to do will work.
12:40:51 <zhulikas> why not? http://www.haskell.org/haskellwiki/99_questions/11_to_20
12:40:53 <zhulikas> 11.
12:40:54 <ClaudiusMaximus> @djinn f :: a -> Either b a
12:40:54 <lambdabot> Cannot parse command
12:41:25 <ClaudiusMaximus> @djinn a -> (b, a)
12:41:25 <lambdabot> -- f cannot be realized.
12:42:02 <nolrai> because it seems to me that the right hand side will have diffrent types given differnt left hand sides.
12:42:39 <zhulikas> O.O
12:43:45 <nolrai> Oh, okay no that should work.
12:44:16 <nolrai> You want Result Int a.
12:46:58 <Philonous> Has someone seen Huttons "how to be more productive" video? It seems to me that (map (const 1)) is a contractive function but it's least fixed point is still _|_
12:49:54 <monochrom> haven't learned contractive, but yes map f ⊥ = ⊥ in Haskell
12:51:21 <shachaf> Philonous: Hmm, I haven't seen this, but looking at the slides, is map on Streams actually strict in its second argument?
12:52:04 <shachaf> Well, I suppose you could define a map that is.
12:53:46 <byorgey> map on Streams ought to be lazy in its second argument.
12:53:48 <Philonous> shachaf:  Map at least has to pattern match the spine
12:54:10 <byorgey> list map does. Stream map doesn't.
12:54:15 <shachaf> Right.
12:54:23 <shachaf> There's only one constructor.
12:54:51 <Philonous> Still, it can't produce any values without looking at the constructor eventually
12:55:46 <shachaf> map f ~(x:xs) = f x : map f xs; map (const 1) anything = repeat 1, no?
12:56:17 <Philonous> shachaf:  The lazy pattern match will have to be forced once I actually look at the resulting stream
12:56:50 <shachaf> Oh, no, it still looks at the spine, I guess. But not when you force the cons, only when you look at its tail.
12:57:06 <shachaf> So map (const 1) _|_ = 1 : _|_?
12:57:34 <byorgey> no
12:57:37 <ClaudiusMaximus> > let f ~(a,b) = (b,1) in (f . f) undefined
12:57:39 <lambdabot>   (1,1)
12:57:56 <byorgey> it would only look at the spine when one of the elements in the input Stream is forced
12:58:00 <sinelaw> shachaf, how can that be
12:58:03 <byorgey> which is never if you are mapping (const 1)
12:58:10 <sinelaw> when even for [] it's less than that
12:58:25 <shachaf> Oh, true.
12:58:37 <shachaf> It's just repeat 1, of course.
12:59:08 <sunfun> good evening
12:59:50 <sinelaw> hi
13:00:25 <Philonous> OK, I can still construct a contractive function that does that. map (\x -> if x ==1 then x else 1)
13:00:53 <sunfun> i'm trying to understand if it is good to make a binary search in a ordered list or if there is an already existent method
13:01:36 <Philonous> sunfun:  List access is linear, so binary search is a bad idea
13:01:57 <sunfun> Philonous, ok, but how to find an element?
13:02:06 <sunfun> i have to do a simple scan?
13:02:16 <elliott_> :t (!!)
13:02:17 <lambdabot> forall a. [a] -> Int -> a
13:02:18 <elliott_> (don't do it)
13:02:44 <shachaf> Philonous: Is (\x -> if x == 1 then x else 1) any different from id?
13:02:55 <Philonous> shachaf:  It forces x
13:03:00 <elliott_> So does id.
13:03:01 <shachaf> Er, wait.
13:03:18 <shachaf> I thought it was /=. Anyway, yes, id is just as strict.
13:03:23 <Philonous> elliott_:  I dearly hope not
13:03:32 <elliott_> Philonous: id is strict.
13:03:35 <shachaf> Philonous: id is strict. (id x) forces x.
13:03:46 <sinelaw> why?
13:03:46 <shachaf> (x `seq` x) == id x
13:04:00 <Philonous> What? That's surprising
13:04:06 <shachaf> id is strict because the definition of a strict function is a function f such that f _|_ = _|_
13:04:09 <gwern> http://translate.google.com/translate?hl=en&ie=UTF8&prev=_t&sl=auto&tl=en&twu=1&u=http://haskell.org/haskellwiki/Jocuri wtf
13:04:11 <shachaf> id _|_ is clearly _|_
13:04:23 <gwern> apparently I made a mistake by not checking User:Ha$kell's edits
13:04:24 <elliott_> lazyID x = x; lazyID _|_ = x
13:04:26 <Philonous> shachaf:  Errr, obviously
13:04:32 <shachaf> (id x) forces x because how else would it work?
13:04:41 <elliott_> gwern: In college you learn one of the most productive languages: Haskell!
13:04:51 <elliott_> so close to "learn you a haskell" :(
13:04:52 <gwern> elliott_: no, before that...
13:04:55 <sunfun> Philonous, if i have to find, for example, an Int in a list. The best way to do that is to start from the first element and check for that?
13:05:22 <elliott_> sunfun:
13:05:23 <elliott_> :t find
13:05:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:06:14 <sunfun> elliott_  thanks
13:06:43 <shachaf> It may or may not be the best way, but it's the only way.
13:07:20 <Philonous> sunfun:  It's stil linear, though. If you want better asymptotic performance you put it into an array and go for binary search (which only makes sense if you want to search in the same list more than once)
13:07:47 <shachaf> Binary search occasionally makes sense with linked lists.
13:09:22 <elliott_> Guest2917: Literally the second I ghosted you.
13:09:29 <Philonous> Btw. Yes, id is just as strict, but I wanted a const that is strict in it's second argument. map i = id is not contractive
13:09:35 <elliott_> Guest2917: NickServ is on your side.
13:09:53 <Guest75930> your name activates my hilighter :(
13:10:08 <elliott_> Get a better name :P
13:10:11 <elliott_> Er.
13:10:12 <elliott_> A worse name.
13:11:31 <sunfun> Philonous, hummm... yes, i have to implement the graph structure, so in more functions i need to find a node to get its content...
13:12:34 <dylex> sunfun: maybe try Data.Map?
13:17:23 <sunfun> dylex, oh, i see, there are just things i need, thanks. The problem is that I have to to that as an exercise for the university, and we haven't seen this module, so i think i have to do that without this library...
13:18:35 <Philonous> @type lookup
13:18:36 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:20:24 <gwern> man, what a pain in the ass this Romanian thing has been
13:20:35 <gwern> but hopefully I deleted all the remaining crap
13:21:59 <ddarius> gwern: ?
13:22:01 <c_wraith> gwern: wiki spam?
13:22:10 <gwern> c_wraith: no, attack pages
13:22:14 <c_wraith> oh
13:22:41 <gwern> (if it were simply spam, that'd be easy. spam is very recognizable.)
13:22:59 <sunfun> Philonous, how should I do to reuse an element found using "find"? I have Just... but, how could I take the element after Just>
13:23:39 <mike-burns> @hoogle maybe
13:23:39 <lambdabot> Prelude data Maybe a
13:23:39 <lambdabot> Data.Maybe data Maybe a
13:23:39 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:25:50 <incluye> > maybe 1 (+1) Nothing
13:25:51 <lambdabot>   1
13:25:56 <Philonous> sunfun:  Pattern matching. case x of Nothing -> ...; Just y -> ...
13:27:07 <mike-burns> > maybe 1 (+1) (Just 4)
13:27:08 <lambdabot>   5
13:49:52 <KitB> Is there a good reference for the ST monad anywhere?
13:50:34 <aristid> KitB: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST-Safe.html ?
13:50:51 <KitB> Sorry, I meant tutorial
13:51:42 <u_> hello
13:52:26 <shachaf> KitB: ST is pretty much the same thing as IO with restrictions on the operations you can use.
13:52:29 <u_> i'm doing the ants ai challenge and i need a mutable data structure to hold my ant's info
13:52:31 <shachaf> Or do you mean the Rank-2 business?
13:52:43 <u_> and right now i'm suing IORef (Map Int (IORef Ant))
13:52:45 <shachaf> u_: Are you sure you need a mutable data structure?
13:52:52 <u_> is this going to bite me?
13:52:55 <u_> shachaf: yep
13:53:07 <shachaf> Why?
13:53:23 <u_> every ant gets changed every turn
13:53:43 <shachaf> Right, but you can use State or something pure like that to represent that.
13:53:45 <u_> and i only have 1/2 of a second for each turn
13:53:48 <copumpkin> that seems like a situation where you don't need a mutable datastructure
13:53:59 <shachaf> Ah, it's an efficiency thing?
13:54:03 <u_> yeah
13:54:44 <shachaf> Hmm. You might want to try out a non-mutable approach and see if it's as bad as you think.
13:55:15 <shachaf> What's the Ant structure like? It seems weird that you need an IORef to hold the Map and also to hold the Ants.
13:55:24 <u_> i've heard other people recommend the mutable approach without saying a specific structure
13:55:40 <ddarius> 500ms = ~1,000,000,000 cycles
13:55:59 <clsmith> computers are crazy
13:56:21 <u_> Ant has a lot of stuff in it. it's pretty big. the outer IORef is mainly for convience
13:56:48 <u_> one thing i don't like about this is i still have to rebuild when i add ants
13:56:59 <u_> and at some point i'll be adding at least 1 every turn
13:57:15 <copumpkin> "rebuild"
13:57:19 <copumpkin> do you understand how maps work?
13:57:29 <u_> data.map is just a tree right?
13:57:35 <copumpkin> yes
13:57:39 <copumpkin> so what does rebuilding involve?
13:58:03 <u_> i'm not sure what it looks like when you add an element
13:58:23 * ddarius constantly switches encodeUtf8 and decodeUtf8 around.
13:58:36 <copumpkin> Map Int can be done more efficiently (for most operations) with IntMap, by the way
13:58:45 <copumpkin> and again, I'd avoid using IORefs
13:58:55 <u_> what should i use instead?
13:59:01 <copumpkin> the time to look up the IORef in the map is the same amount of time it'd take to "rebuild" the map
13:59:11 <copumpkin> IntMap Ant
13:59:21 <u_> i meant instead of an IORef
13:59:27 <copumpkin> what I just said
13:59:33 <u_> no IORef?
13:59:38 <copumpkin> no IORef
14:00:08 <u_> but then won't it duplicate every constructor from the root of the tree to the leaf i'm updating every time i change an ant?
14:00:25 <copumpkin> how many of those will there be?
14:00:36 <u_> if i'm winning, up to 700
14:00:42 <copumpkin> huh
14:00:49 <copumpkin> how many ants will you have?
14:00:56 <u_> 700
14:00:59 <copumpkin> okay
14:01:08 <copumpkin> so log_2 700
14:01:17 <u_> times 700?
14:01:25 <copumpkin> log base 2 of 700
14:01:28 <copumpkin> which is < 10
14:02:00 <u_> times some constant, for each of my 700 ants.
14:02:13 <copumpkin> how long will it take you to look up your IORef in the structure you described?
14:02:52 <u_> oh you're talking about just looking them up
14:02:56 <copumpkin> no
14:03:02 <Influ> Would anyone here be willing to spare 5 minutes to help me solve something? I've spent numerous hours and am getting nowhere, it would really be appreciated :(.
14:03:07 <copumpkin> I'm saying that updating a map uses as much time as looking up a value in it
14:03:15 <copumpkin> and this reeks of premature optimization
14:03:27 <u_> i've heard other people have the same problem
14:03:39 <u_> it does?
14:04:19 <copumpkin> if you don't know the complexity of operations on your datastructures, maybe you should look at those before trying to hardcore optimize your system :P
14:04:28 <copumpkin> but yes
14:04:43 <shachaf> Influ: You should say what the problem is.
14:04:50 <Influ> Ah sorry
14:04:52 <u_> i know how trees work, i just didn't know what you were calculating
14:04:55 <shachaf> Influ: I'm mean and I never help anyone, but maybe some quiet people in the channel would be able to help you.
14:05:08 <Influ> You don't sound too mean
14:05:13 * shachaf bares teeth.
14:05:20 <Influ> Evil!
14:05:21 <gwern> preflex: @seen nomeata
14:05:21 <preflex>  nomeata was last seen on #darcs 1 day, 4 hours, 7 minutes and 44 seconds ago, saying: Heffalump: I thought it was darcs2.
14:05:27 <hpc> down, boy!
14:05:33 <hpc> *activates shock collar*
14:05:34 <hpc> :P
14:05:35 <copumpkin> u_: then it shouldn't be a surprise to you that updating a tree takes the same amount of time as looking something up in it, which suggests that you aren't really gaining much at all by sticking IORefs in your tree instead of just keeping it immutable
14:05:54 <Influ> Right, well I have implemented a picture using Haskell. The picture works fine, but as part of the assignment, we have to use high order functions such as a Map, but I can't for the hell of me get it to work using a Map :(
14:06:00 <gwern> @ask nomeata How goes uploading debs for xmonad 0.10? I don't see anything in http://packages.qa.debian.org/x/xmonad.html
14:06:00 <lambdabot> Consider it noted.
14:06:07 <gwern> @flush
14:06:14 <gwern> @quote nomeata
14:06:15 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it's fun to explore the higher parts.
14:06:32 <shachaf> Influ: "Map" is a type, not a higher-order function.
14:06:40 <shachaf> Are you talking about Data.Map or the function "map"?
14:06:48 <Influ> The function map
14:06:52 <Influ> Sorry, I should have been more specific
14:07:08 <copumpkin> u_: anyway, if you want the idiomatic, haskeller-approved approach here, I'd use IntMap Ant, but the other one will work too (it just buys you some complexity for not much gain at all)
14:07:41 <shachaf> Approved by a real Haskeller?!
14:07:45 <copumpkin> indeed
14:07:48 * copumpkin pulls out his stamp
14:08:54 * gwern hopes joachim packages up xmonad 0.10 soon. let those poor debian users finally get a new xmonad release
14:09:07 * ddarius never updates xmonad.
14:09:07 <rwbarton> if you always update every ant at the same time, you may as well just use an array
14:09:24 <copumpkin> rwbarton: I wasn't sure if the ant numberings were sparse, but yeah
14:09:25 <rwbarton> provided also your indexes are dense (1..n)
14:09:26 <shachaf> rwbarton: Assuming it's dense.
14:09:29 <rwbarton> yeah
14:10:05 <shachaf> Which I don't think they are -- though it might not matter that much.
14:10:28 <u_> i see the other people were actually recommending mutable arrays
14:10:34 <shachaf> Which other people?
14:10:52 <shachaf> Looks like you might have to pull out more sinister things than your stamp today, copumpkin.
14:11:01 <rwbarton> I didn't mean mutable arrays btw
14:11:10 <copumpkin> yeah, I wouldn't recommend mutable arrays
14:11:24 <u_> why not?
14:11:29 <ddarius> > 1000000000/700
14:11:30 <lambdabot>   1428571.4285714286
14:11:31 <copumpkin> u_: 99% of the programmers in the world will reach for mutable structures when given the chance. That doesn't mean they're necessarily the right thing to do
14:12:08 <copumpkin> u_: if you're updating all your ants at once, you're performing a linear traversal of the array anyway, which (assuming cheap allocation) isn't all that different from making another array based on your earlier one
14:12:57 <u_> there isn't a particular order when i update the ants
14:13:01 <u_> but yeah that makes sense
14:13:12 <copumpkin> by linear I mean O(n)
14:13:17 <copumpkin> not necessarily specifying an order
14:13:22 <u_> oh
14:13:43 <hpaste> “Me.” pasted “Module.hs” at http://hpaste.org/54345
14:14:17 <hpaste> “Me.” pasted “MyPicture.hs” at http://hpaste.org/54346
14:14:30 <shachaf> "Error: Eta reduce"? Quite presumptous on hlint's part, isn't it?
14:14:30 <Influ> Eeep
14:14:39 <Influ> Didn't know it pasted directly
14:14:46 <Influ> Right, so I have Module.hs and MyPicture.hs
14:15:10 <Influ> I need to change MyPicture.hs to use any higher order function
14:15:19 <Influ> Preferrably, Map
14:15:23 <Influ> Any takers?:$
14:16:12 <shachaf> Influ: Capitalization is important in Haskell -- "Map" is very different from "map".
14:16:29 <shachaf> Also, using a higher-order function for the sake of using one is silly.
14:16:35 <u_> copumpkin: can i still keep the outer ioref?
14:16:46 <copumpkin> u_: sure you can, but I don't think it buys you much
14:16:53 <Influ> It is specified in the scope of the assessment
14:16:54 <irene-knapp> okay, so pop quiz!  is anyone here using a GHC they compiled themselves on OS X Lion?
14:16:57 <Influ> I've achieved the desired effect already
14:16:58 <u_> it just saves me a few characters
14:17:05 <Influ> But unfortunately, it has to be done how they want it
14:17:10 <copumpkin> u_: I think you'll learn more actual haskell if you try to avoid things like that wherever possible
14:17:14 <Influ> :x
14:17:15 <irene-knapp> if so, I desire to compare setups to find out why it isn't working for me
14:17:51 <shachaf> Influ is engaging in the famous practice of test-driven development.
14:18:54 <Influ> :(
14:19:13 <Influ> I'm completely baffled, and submission closes in a few hours, and after trying for numerous horus this was my last resort for help!
14:19:59 <KitB> Anyone know of a way to apply sequence to a Data.Vector.Unboxed?
14:21:09 <copumpkin> apply sequence?
14:22:14 <KitB> Control.Monad.sequence
14:22:19 <KitB> But for Vectors
14:22:25 <KitB> Can't find it in Data.Vector anywhere
14:22:37 <ClaudiusMaximus> @hoogle sequence
14:22:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:22:38 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:22:38 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
14:23:04 <KitB> Looks like a no?
14:23:17 <copumpkin> how could you even sequence an unboxed vector
14:23:21 <copumpkin> you could mapM it
14:23:26 <copumpkin> or traverse, I should say
14:23:45 <KitB> I'm going to have a vector of monadic values
14:23:48 <copumpkin> the only sequencing I can think of is on the pairs
14:23:57 <copumpkin> yes, but how will you construct _unboxed_ monatic values?
14:23:59 <copumpkin> *d
14:24:07 <KitB> Ah
14:24:21 * KitB still a noob
14:25:01 <copumpkin> having said that, there is a potential monad/applicative instance for (a, _)
14:25:06 <copumpkin> or Monoid a => (a, _)
14:25:24 <copumpkin> so you could probably do that one, but it probably isn't the one you wanted
14:25:49 <u_> copumpkin: but if i were to use an array at all, would i want a mutable one?
14:26:36 <copumpkin> u_: if you're always going to be updating the whole thing at once, it shouldn't really make a difference except in your allocation behavior
14:26:40 <copumpkin> and allocations are cheap in GHC
14:26:43 <u_> the starter pack uses an immutable array for the terrain and i think it updates it one tile at a time. does that copy the entire thing?
14:27:05 <copumpkin> you will make more garbage using this approach, which needs to get collected every so often
14:27:07 <u_> like, copy it once for each tile?
14:27:46 <copumpkin> you said at first you were updating them all at once
14:27:57 <u_> i'm not using the starter pack
14:28:13 <copumpkin> I have no clue what the starter pack is :P
14:28:22 <copumpkin> I'm just giving general algorithmic advice
14:28:23 <u_> here's what it does: newWorld = world gs // [(loc, MetaTile {tile = FoodTile, visible = True})]
14:29:08 <u_> doesn't that copy the whole thing once per food item?
14:29:39 <copumpkin> that one does, yeah
14:29:54 <u_> and that's bad, right?
14:30:36 <copumpkin> yeah
14:30:59 <u_> okay, well at least i was right about making my terrain map mutable
14:31:20 <copumpkin> well, that's only if you use their silly approach :P
14:31:32 <copumpkin> if you apply a function to the whole array, then the cost is almost the same
14:31:49 <u_> you mean use // with a list of every food at once?
14:32:02 <copumpkin> u_: yeah, or some other bulk operation on arrays
14:56:49 <dibblego> yo there; I recently saw a great library for wrapping up quickcheck tests, etc. for a project, but I have forgotten the name -- any hints?
14:57:58 * gwern rues being hawiki admin. another complaint.
15:00:05 <monochrom> oh gwern, while we are at it, I have always been thinking, what is the plan for fixing <hask>?
15:01:11 <monochrom> in particular I have documented the problem at http://www.haskell.org/haskellwiki/MigratingWikiContent and included a demo
15:01:48 <gwern> monochrom: fixing?
15:02:44 <monochrom> it is sometimes very maddening. (well, it should be maddening all times for those who care, but I no longer care all times.) if I write something with <code>, some do-gooder is bound to come along to change that to <hask>, and boom, all the paragraphing is gone.
15:02:52 <gwern> monochrom: I have no idea. is it a hawiki problem or a genshi issue?
15:03:05 <monochrom> I don't know.
15:04:13 <monochrom> but firstly, have you seen the demo? "In the first paragraph we use head on lists. In the second paragraph we use tail on lists." those two sentences are really two separate paragraphs. merged into one because of <hask>
15:05:25 <gwern> oh my god, the shit is multiplying: http://www.haskell.org/haskellwiki/Intrebari_despre_activitatea_universitara
15:05:36 <gwern> what did I do to deserve this
15:06:10 <gwern> and Ha$kell hasn't even logged in yet since the purge started. this may end in tears and me reverting anything written in romanian
15:06:20 <irene-knapp> hm :(
15:06:22 <irene-knapp> spam sucks :(
15:06:58 <gwern> this isn't spam in the usual sense
15:10:19 <monochrom> that seems to be someone called Dan V. Popa treating haskell.org as his rightful personal CV posting site
15:10:33 <scshunt> clever
15:11:29 <irene-knapp> hm
15:11:47 <monochrom> to be fair, http://www.haskell.org/haskellwiki/User:<login name> is fine for that. but you really have to confine yourself to that page, not creating other pages for that purpose.
15:12:53 <monochrom> IMO should just ban Ha$kell
15:13:28 <gwern> monochrom: he was contributing haskell stuff in romanian as far as I can tell
15:13:39 <aristid> AND delete all pages that are not in english
15:14:04 <aristid> simply because you can't be asked to tell
15:14:09 <gwern> he's been warned; he may not have known that these pages were unacceptable on hawiki - normally we're very liberal about what we host
15:14:26 <gwern> he does it again, then I'll start blocking
15:15:41 <co_dh> Greeting, haskeller. I come with a javascript question (not really) , and I'm looking for inspiration from Haskell.  I have 2 ajax calls, each retrieve a file from a server, and when both are ready , I call a function.  These ajax call is like jQuery.get( url, callback) . Is there a combinatory way to do it ?
15:16:29 <co_dh> something like  waitboth (jQuery.get url1 ) ( jQuery.get url2)  callback
15:16:31 <monochrom> this Ha$kell character felt free to harass gwern and waving the "democracy" wand at http://www.haskell.org/haskellwiki/index.php?title=User:Gwern&oldid=43051
15:17:34 <gwern> monochrom: a wand I've waved in the past. he's clearly not a native english speaker and so I cut him a lot of slack for tone and phrasing
15:21:08 <Sgeo> The Haskell Facebook group makes me sad
15:25:41 <kjartan> hello Haskell users :D
15:26:00 <byorgey> hi kjartan!
15:26:46 <byorgey> kjartan: visiting from tryhaskell?
15:26:47 * gwern sighs and sends off the reply to the new complainant
15:27:12 <byorgey> gwern: =(  Thanks for dealing with this.
15:27:25 <monochrom> oh gwern, what was the complaint? pray tell! I want to hear it and then say a few words of comfort or something :)
15:27:26 <gwern> I'd ask on -cafe for some Romanian speakers to look through the contribs and tell me what's up, but I suspect they're probably all related to one of the parties
15:27:53 <dibblego> can anyone point to a package that uses cabal to integrate testing, hpc, criterion, etc?
15:27:58 <gwern> monochrom: academic squabbling, accusations of corruption and inefficiency. your normal aspie on a vendetta
15:29:27 <irene-knapp> that's unfair to aspies :D
15:29:43 <monochrom> you have my support in taking any of your vendetta against them!
15:30:01 <gwern> irene-knapp: but accurate. any aspie would uphold my right to be offensively right!
15:30:11 <Cale> Is this about that bizarre page on the Haskell wiki from earlier?
15:30:15 <Cale> What was that all about?
15:30:39 <Cale> I understood the deletion of it, as it doesn't exactly seem Haskell-related.
15:30:51 <gwern> Cale: about? see my summary to monochrom
15:31:42 <Cale> Well... okay, so just offtopic stuff then?
15:32:06 <monochrom> there used to be a famous "I am being prosecuted by MI5" character on usenet. of course, when any admin deleted his/her posts, he/she would send out more "see? I'm being prosecuted!" posts.
15:32:15 <Botje> co_dh: that'd be liftM2.
15:32:37 <co_dh> Botje: interesting, which monad?
15:32:59 <Botje> co_dh: *any* monad
15:33:22 <Cale> So much cooler than being prosecuted by the CIA.
15:33:29 <irene-knapp> I think the person meant persecuted, anyway
15:33:32 <co_dh> Botje: for the callback question I have, what monad is it?
15:33:36 <irene-knapp> if he had been /prosecuted/ there would be a public record of it :D
15:33:47 <Cale> indeed
15:33:56 <Botje> co_dh: the callback system is a kind of monad.
15:34:22 <Botje> m >>= f = call m and pass f as callback
15:34:42 <Botje> co_dh: except with callbacks you don't know in which order your arguments will resolve.
15:35:50 <co_dh> Botje: are you sure it's a monad? is it already in hackage?
15:35:55 <monochrom> it seems I screwed up "prosecution" vs "persecution"
15:36:27 <monochrom> http://groups.google.com/group/cz.comp.linux.mandrake/browse_thread/thread/f9a5b34543019510/ce6fda971712bbe0 :)
15:36:56 <Botje> co_dh: functions-with-callbacks is the Cont monad, if you must know
15:37:20 <co_dh> Botje: thanks. let me read some Cont monad .
15:37:36 * Botje sneaks off to sleep while co_dh goes to headsplosion
15:41:53 <Hydrant> hi, quick question... how do I convert to/from a Double to an Int ?
15:42:43 <monochrom> @quote monochrom Double
15:42:45 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:43:26 <monochrom> the other direction is ambiguous. disambiguate.
15:43:37 <Jafet> @hoogle Double -> Int
15:43:38 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
15:43:38 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
15:43:39 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
15:43:52 <Jafet> @hoogle Double -> a
15:43:53 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:43:53 <lambdabot> Prelude id :: a -> a
15:43:53 <lambdabot> Data.Function id :: a -> a
15:43:55 <monochrom> heh, sizeOf may be right :)
15:44:23 <monochrom> unsafeCoerce actually has a use for this
15:45:24 <Nimatek> > map ($ 0.6) [floor, truncate, round]
15:45:25 <lambdabot>   [0,0,1]
15:45:28 <shachaf> addressOf :: a -> Word; addressOf x = W# (unsafeCoerce# x)
15:46:02 <monochrom> you forgot ceiling
15:46:03 <prelude> is ML still a good language to use?
15:46:07 * hackagebot xmonad-extras 0.10 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.10 (DanielSchoepe)
15:46:16 <Nimatek> Indeed. And maybe more.
15:47:31 <Hydrant> ceiling seems to take a RealFrac type as input though
15:47:55 <monochrom> all of floor, ceiling, truncate, round take the same type
15:48:25 <monochrom> Double is a RealFrac type
15:53:14 <dschoepe> Anyone code.haskell.org admin around? /srv/projects/xmonad-extras is owned by cardinal-http-p instead of xmonad-extras-p.
15:54:35 <Hydrant> I'm confused why something like floor sqrt 3 doesn't work
15:55:34 <dylex> > floor (sqrt 3)
15:55:35 <lambdabot>   1
15:55:39 <mapreduce> > floor . sqrt 3
15:55:41 <lambdabot>   No instance for (GHC.Show.Show (f b))
15:55:41 <lambdabot>    arising from a use of `M2428039617...
15:56:10 <Jafet> > floor sqrt 3
15:56:12 <lambdabot>   No instance for (GHC.Real.RealFrac (a -> a))
15:56:12 <lambdabot>    arising from a use of `GHC....
15:56:15 <Jafet> Boo
15:56:16 <mapreduce> > (floor . sqrt) 3
15:56:18 <lambdabot>   1
15:56:55 <Hydrant> ah, thx
15:57:00 <mapreduce> Hydrant: floor sqrt 3 parses as if you were passing the arguments 'sqrt' and '3' to a function named floor, aiui.
15:57:15 <mapreduce> floor(sqrt, 3) in C-like langs.
15:57:30 <Hydrant> yah, I'm still getting used to the syntax :-)
15:58:15 <shachaf> mapreduce: floor(sqrt)(3) would be a more precise translation. :-)
15:58:43 <mapreduce> With an extra level of complexity in explanation. :)
15:59:05 <shachaf> > fmap floor sqrt 3
15:59:05 <lambdabot>   1
15:59:25 <Jafet> Oh god no, not the functors
15:59:34 <Jafet> So much needless complexity
15:59:46 <shachaf> fmap is just line noise.
16:00:00 <shachaf> «The following functions are probably line noise, and can probably be ignored. liftIO, lift, runX (e.g. runState), unX (e.g. unConstructor), fromJust, fmap, const, evaluate, an exclamation mark before an argument (f !x), seq, a hash sign (e.g. I# x).»
16:00:34 <Saizan> where's that from?
16:01:12 <Jafet> Also return, and fromIntegral. Especially fromIntegral.
16:01:28 <shachaf> Saizan: blog.ezyang.com
16:05:41 <gentleben> am I the only person that finds it difficult to reason about memory usage in a large program
16:05:58 <shachaf> gentleben: You are alone in the world in that.
16:06:02 <shachaf> Sad, isn't it?
16:06:12 <gentleben> it makes me sad
16:06:26 <Influ> Hi guys, I was wondering if anyone could help to (point me in the right direction) so as to convert http://hpaste.org/54352 so that it implements a higher order function such as map whilst behaving recursively...please :(
16:06:30 <gentleben> i just want a thunk profiler right now
16:06:31 <shachaf> Everyone else has figured it out, and there you are, dawdling, not understanding what's going on.
16:06:45 <Jafet> I reason that my programs use too much, all the time, and that's how it's meant to be.
16:07:23 <gentleben> i do think most of mine use too much memory
16:07:39 <gentleben> i think i have too many thunks floating around
16:07:56 <shachaf> Influ: This is the wrong way to go about things.
16:08:13 <Influ> What would be the correct way? That is specific, concise and to the point, with an appropriate paste :x.
16:08:19 <Influ> I'm honestly dying here!
16:08:23 <shachaf> Influ: "I want to use function foo" is backwards.
16:08:52 <shachaf> You don't even have any lists in that file.
16:09:01 <Influ> I know, hence the conundrum
16:09:03 <byorgey> Influ: the way you asked the question was great, I think shachaf was referring to the technical content of your question
16:09:04 <shachaf> And flower is already a higher-order function -- it returns a function. :-)
16:09:26 <Influ> I'm not too great with Haskell at all to be honest
16:10:03 <Influ> I'm not allowed to edit the functions that are used, so can't really convert functions such as ellipse to accept lists, hence the conundrum!
16:10:09 <Jafet> @type unfoldr
16:10:11 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:11:36 <byorgey> Influ: so to make sure I understand, you are trying to generate a bunch of ellipses where each one is rotated a bit more?
16:11:53 <Influ> Yep, that is correct
16:11:57 <Influ> The image works great
16:12:08 <Influ> The only issue is, i'm meant to be using higher order functions, which I am finding impossible to do
16:12:23 <shachaf> I have a feeling you're misunderstanding the assignment.
16:12:42 <shachaf> Or maybe it's just a bad assignment.
16:12:43 <byorgey> Influ: ok, well, you could do something like: first make a list of ellipses. then generate a list of rotation angles.  then combine them using 'zipWith'.
16:12:58 <Influ> Doesn't get much clearer than "The first picture should feature a repetitive element coded concisely using higher-order functions from the List library.
16:12:59 <Influ> "
16:13:03 <Influ> so i'm going to go with the bad assignment!
16:13:18 <byorgey> I don't think there's anything wrong with that assignment.
16:14:16 <Influ> Ah, that sounds like a start
16:14:22 <shachaf> "Where did the function 'map' get into it?", I hear you cry.
16:14:24 <Influ> Would that be difficult to implement?
16:14:42 <Influ> On a discussion forum, he mentioned map would be a good place to start
16:14:50 <byorgey> Influ: you seem to be thinking about it in a low-level step-by-step way.  Try to think instead about starting wiht some simple data structure (e.g. a list of ellipses) and then applying a series of transformations to it
16:15:05 <byorgey> but each transformation should do something to the *whole* list
16:15:11 <byorgey> don't think about it element-by-element.
16:15:39 <luite> perhaps a list of transformations would be more appropriate
16:16:18 <byorgey> this sort of "wholemeal" style (where you transform entire data structures) works really well in Haskell and not in strict languages; it can be hard to wrap your head around this way of thinking at first
16:34:32 * jessopher_ starts thinking about food recipies written in haskell
16:35:23 <dr_rotflcopter> :)
16:35:40 <BMeph> I think these two concepts are what blows the minds the most of those new to Haskell: 1) Use functions; 2) use functions as if they were regular values.
16:35:45 <dr_rotflcopter> make food
16:36:19 <BMeph> dr_rotflcopter: make food where...
16:36:43 <dr_rotflcopter> i did cooking brown rice :) just done
16:36:43 <jessopher_> instance Cake ....
16:36:59 <min> functions as values makes complete sense, and is very intuitive, when learning haskell as a first language.
16:37:20 <dr_rotflcopter> i think the unclear syntax, and lack of useful logical examples make the noobs feel like +!%"+%!"!
16:37:25 <jessopher_> i think its just the maginitude of differences, not necessarily any one or two in particular
16:38:19 <jessopher_> high order functions arent a hard thing to grasp for someone just comming in, but applying them to 5 other concepts you have never heard either is
16:40:00 <BMeph> dr_rotflcopter: There's no such thing as unclear syntax. Only unclear use of syntax, which is different, since it's more about meaning than structure.
16:40:39 <BMeph> dr_rotflcopter: Also, in my world, logic is overrated. ;)
16:41:19 <dr_rotflcopter> was meaning that like i was trying to test the example codes provided in the leearnyouahaskell website
16:41:28 <dr_rotflcopter> and ghci had many errors
16:41:42 <dr_rotflcopter> and i had to put let before some lines
16:42:07 <dr_rotflcopter> and ghci couldnt define types
16:42:38 * BMeph is trying to think of a "clever" way to say "ghci isn't Haskell"...
16:42:59 <hpc> "ghci is a giant IO do-block"
16:43:02 <jessopher_> no need, its true enough stated like that
16:43:06 <dxq> ghci isn't haskell
16:43:09 <dxq> there you go
16:43:13 <mapreduce> @quote ghci
16:43:14 <lambdabot> Berengal says: I was squashing a bug, got frustrated, and typed "fix error" in ghci...
16:43:25 <jessopher_> hah
16:43:44 <accel_> @quote haskell
16:43:45 <lambdabot> haskell says: wow am I in the wrong chat maybe?
16:43:51 <accel_> @quote ghci
16:43:51 <lambdabot> byorgey says: you seem quite determined to prove that ghci is trying to screw you over, but I assure you it is just doing its job
16:43:59 <accel_> @quote lambdabot
16:43:59 <lambdabot> lambdabot says: Of course i'm female
16:44:06 <Jafet> It's worse than you think! Even Haskell isn't Haskell.
16:44:06 <accel_> @quote accel
16:44:07 <lambdabot> accel says: fuck; *.lhs files are unreadable
16:44:25 <accel_> wtf, did I ever say that?
16:44:30 <accel_> @quote accel
16:44:31 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
16:44:39 <BMeph> Hmm, byorgey's quote sounds reasonable...until you think: "What is screwing you over _IS_ ghci's job?" ;)
16:44:57 <accel_> hmm, does lambdabot have a log of the entireity of #haskell?
16:45:02 * BMeph meant "What ->if<- ..."
16:45:10 <accel_> @quote accel
16:45:11 <lambdabot> accel says: < accel> one day, it was raining < accel> I was walking home < accel> I saw Knuth biking home, wearing a helmet, in the rain < accel> and I freaked out < accel> rain was hitting him like
16:45:11 <lambdabot> any other mortal ... it wasn't bounching off his aura of awesomeness
16:45:53 <accel_> @quote accel
16:45:54 <lambdabot> accel says: next time I'll read a few research papers before I start trolling hakell
16:46:03 <accel_> alright; time I stop before I get kicked for bot flooding the channel
16:46:41 * BMeph imagines Dijkstra glaring at the rain until it just avoids hitting him altogether... ;)
16:47:37 <accel_> Dijkstra would change the gravitation field aroudn himself so the least energy pass for the rain is to go around dijkstra.
16:48:08 <jessopher_> or maybe he would just use an umbrella :o
16:48:10 <Jafet> Dijkstra takes the quickest way home, so he never gets caught in the rain.
16:48:27 <hpc> rofl
16:48:43 <Jafet> Don, on the other hand, can be digressive.
16:49:19 <dr_rotflcopter> [015530] * BMeph is trying to think of a "clever" way to say "ghci isn't Haskell"... - well ok as a newb, i thought it is GHC interpreter.
16:49:31 <mapreduce> Great, now I've got a bullet-time sequence going on in my head with Dijkstra dodging individual raindrops.
16:49:50 <jessopher_> ghc interpreter still wouldnt be 'haskell interpreter'
16:50:01 <accel_> given the distribution of rain drops in 3d space
16:50:04 <accel_> I don't thikn that is possible
16:50:19 <accel_> i.e. I bet any sphere of radius > 0.5 inch contains a raindrop
16:50:33 <bluej774> Why does the type system as implemented in ghci sometimes use t and sometimes a as a type variable?
16:50:39 <mapreduce> Perhaps it's not raining all that hard.
16:50:59 <hpc> bluej774: people used different things for type variables for different types
16:51:03 <accel_> so then it's not really dodging rain drops; it's more like dodging toilet flushes from overhead plane?
16:51:24 <mapreduce> Ok, now the picture got worse.
16:51:25 <hpc> bluej774: or let the signatures be generated automatically, like if you are getting the type of an expression
16:51:25 <bluej774> hpc, I mean when you use :type
16:51:32 <hpc> :t 5
16:51:32 <monochrom> God, why would you associate "reality distortion field" with Dijkstra?!
16:51:33 <lambdabot> forall t. (Num t) => t
16:51:37 <hpc> :t id
16:51:38 <lambdabot> forall a. a -> a
16:51:55 <hpc> bluej774: oh, then probably just part of how it names things
16:51:57 <Jafet> monochrom: because he could project it around himself
16:52:09 <Jafet> It's a unique ability of dutch computer scientists
16:52:11 <hpc> bluej774: nums start with 't', monads with 'm', functors with 'f'
16:52:12 <hpc> etc
16:52:21 <accel_> he would update the space-time edge costs of the world around him
16:52:29 <accel_> causing the rain drops' shortest paths to go aroudn him
16:52:30 <monochrom> haha
16:52:40 <monochrom> haha ok I forgive you!
16:52:58 <bluej774> hpc, I meant when I write my own functions and get hints from ghci using :t it sometimes tells me things like [t] -> [t] and sometimes things like [a] -> [[a]]
16:53:22 <bluej774> If there's no solid reason, that's fine.  I just wondered if there was a reason.
16:53:32 <Jafet> bluej: they're equivalent.
16:53:48 <hpc> bluej774: no solid reason then, i suppose
16:53:58 <bluej774> That's weird.
16:54:08 <hpc> bluej774: it's the interaction of lots of different parts of the typechecker
16:54:12 <_oz> bluej774: the reason is simple. it infers the type of your function from its components, and tries to be clever about it.
16:54:50 <jessopher_> that seems like a bug. cleverness
16:55:02 <bluej774> jessopher_, +1
16:55:06 <_oz> not really
16:55:11 <_oz> why would it be a bug?
16:55:16 <accel_> bugs are merely clever optimizations we have not yet learned how to use
16:55:18 <DevHC> HALP ! i have a very basic shared library exporting 1 "callme" symbol and importing 1 "required" symbol, using FFI. the library uses Data.Array. when i try to dlopen() the library, i get: ./Dyn.so: Undefined symbol "stg_newArrayzh"
16:55:26 <Influ> Does anyone here accept money for Haskell help? I am that desperate :|
16:55:34 <hpc> jessopher_: nah, it's purely cosmetic; you wouldn't like (>>= id) to be of type Monad a => a (a b) -> a b, would you?
16:55:40 <accel_> can you pay in bitoin?
16:55:43 <jessopher_> _oz i dont know, i was just being clever... see how that worked out?
16:55:44 <Jafet> Influ: most people here aren't.
16:56:02 <Influ> Oh lord, I have spent hours trying to do something someone experienced would find so simple
16:56:11 <accel_> you should probably produce a minimum working example
16:56:12 <Influ> Something one of you pros could do in 5 minutes :/
16:56:12 <bluej774> _oz, It would be a bug because there's not any consistency.
16:56:13 <accel_> then post it to hpaste
16:56:16 <accel_> and maybe someone will take a look at it
16:56:22 <accel_> (I don't know how to debug FFI, so it won't be me)
16:56:25 <Influ> I have done so, and been told how to approach it
16:56:32 <Influ> But, I just can't implement the suggestion
16:56:37 <Influ> I'm not stupid, just incredibly new to Haskell lol
16:56:37 <_oz> bluej774: there is consistency. it reuses type variable names from the components if possible
16:56:41 <_oz> :t fst
16:56:42 <lambdabot> forall a b. (a, b) -> a
16:56:57 <monochrom> Influ: what's the url again?
16:56:59 <Jafet> :t first succ
16:57:00 <lambdabot> forall b d. (Enum b) => (b, d) -> (b, d)
16:57:10 <Jafet> Okay, that's just weird
16:57:17 <Influ> http://hpaste.org/54352
16:57:20 <accel_> my general approach for solving such problems
16:57:25 <accel_> since people are rarely kicked for being on topic
16:57:36 <Influ> I want to create a list of the elippses, a list of the rotation angles, and join them using zipWith
16:57:36 <accel_> is to just start typing in the channel every little debugbing effort I try
16:57:45 <accel_> then, at some point, someone intelligent gets fed up, and solves my problem
16:58:32 <jessopher_> Jafet: i think because a b c and d are associated with first and succ respectively
16:58:41 <shachaf> accel_ is the reason we can't have nice things.
16:59:04 <jessopher_> :t (first,succ)
16:59:06 <lambdabot> forall (a :: * -> * -> *) b c d a1. (Arrow a, Enum a1) => (a b c -> a (b, d) (c, d), a1 -> a1)
16:59:13 <monochrom> oh, ellipse (x,y) hr vr : rotate 30 (x+hr,y+vr) (flower (x,y) hr vr (n-1))
16:59:19 <monochrom> that is ":" replacing "++"
16:59:43 <monochrom> unless I guess wrong about what "ellipse" is supposed to mean
16:59:52 <Jafet> type Picture = [Ellipse]
16:59:53 <monochrom> which is then your problem keeping secrets from me
16:59:58 <Influ> ellipse is a function being called from an import
17:00:42 <djanatyn> scanl and scanr are interesting functions
17:00:49 <djanatyn> I can't really think of any situations in which I would use them, though
17:01:12 * shachaf counts down to Fibonacci.
17:01:29 <hpc> :t scanl
17:01:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:01:49 <hpc> djanatyn: suppose you had a function that was a fold
17:01:59 <hpc> djanatyn: now suppose you wanted all the intermediate results too
17:02:03 <hpc> djanatyn: voila, scan
17:02:23 <hpc> djanatyn: it's unfold that's tricky
17:02:23 <djanatyn> :)
17:02:28 <hpc> :t unfoldl
17:02:29 <lambdabot> Not in scope: `unfoldl'
17:02:32 <hpc> :t unfoldr
17:02:34 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:02:45 <hpc> well, less tricky
17:02:47 <djanatyn> woah, unfold?
17:02:52 <djanatyn> weird
17:02:56 <scshunt> unfoldl is fantastic
17:03:04 <hpc> > unfoldr (listToMaybe . lex) "abc def + 5"
17:03:06 <lambdabot>   ["abc","def","+","5","","","","","","","","","","","","","","","","","","",...
17:03:09 <shachaf> scshunt: "fantastic" in the sense that it doesn't exist? :-)
17:03:15 <scshunt> shachaf: yes :D
17:03:25 <scshunt> unfoldr is, of course, fantasticer
17:03:33 <min> :t mapAccumL
17:03:34 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
17:03:37 <hpc> > lex ""
17:03:38 <lambdabot>   [("","")]
17:03:52 <min> a useful and underused function
17:03:54 <shachaf> fold, unfold, refold, defold, prefold, exfold, afold, infold
17:04:20 <hpc> min: ooh, it's like a State-ful fold
17:04:26 <hpc> er, scan
17:04:32 <min> recursion schemes for the aging haskell programmer: crease, wrinkle, ...
17:04:34 <shachaf> hpc: map
17:04:35 <monochrom> oh, perhaps it should be ellipse (x,y) hr vr : map (rotate 30 (x+hr,y+vr)) (flower (x,y) hr vr (n-1))
17:04:40 <hpc> or that
17:04:40 <jessopher_> lol
17:04:42 <monochrom> (again, blind guessing in the dark)
17:04:50 <hpc> shachaf: so it's mapM, then
17:04:51 <hpc> ;)
17:04:52 <shachaf> hpc: It's a lot like map, with an accumulator, from the left.
17:04:53 <Influ> the elipse works fine
17:05:04 <shachaf> It has little to do with mapM, even in State.
17:05:09 <min> yeah, it maps with an accumulating value
17:05:15 <shachaf> Hmm, maybe I'm wrong, actually.
17:05:19 <Jafet> unfoldl = repeat . fix
17:05:23 * djanatyn tries to write an interesting fibonacci function
17:05:27 <jessopher_> i like to think of my programs as elaborate pieces of origami
17:05:32 <Jafet> @where evolution
17:05:33 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:05:35 <shachaf> I guess it has a little to do with mapM.
17:06:04 <hpc> shachaf: it's fmap reverse . mapM . reverse, plus a lot of wrapping
17:06:12 <hpc> (or something like that)
17:06:12 <shachaf> hpc: I doubt it.
17:07:15 <shachaf> > mapAccumL (\acc x -> (acc + q, x + acc)) z [a,b,c,d]
17:07:16 <lambdabot>   (z + q + q + q + q,[a + z,b + (z + q),c + (z + q + q),d + (z + q + q + q)])
17:08:23 <Saizan> mapAccumL is exactly mapM for State, except without the State newtype
17:08:36 <min> woah. lambdabot will do rewriting over uninterpreted terms and variables?
17:08:49 <monochrom> yes, sometimes
17:08:58 <Saizan> :t z
17:08:59 <lambdabot> Expr
17:09:08 <monochrom> I'll find you the library that does it
17:09:18 <hpc> min: it's a neat but limited library
17:09:23 <djanatyn> okay, how about this:
17:09:41 <monochrom> it's http://hackage.haskell.org/package/simple-reflect
17:09:48 <djanatyn> > let fib x y = (x + y) : fib y (x + y) in take 10 $ fib 1 1
17:09:49 <lambdabot>   [2,3,5,8,13,21,34,55,89,144]
17:09:52 <djanatyn> that works
17:09:55 <djanatyn> very ugly, though
17:10:06 <djanatyn> what's the usual way of writing fibonacci?
17:10:25 <Jafet> > fix $ (0:) . scanl (+) 1
17:10:26 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml has another nice fib
17:10:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:10:33 <Jafet> @where evolution
17:10:34 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
17:10:43 <djanatyn> isn't fix like, a y combinator?
17:10:45 <hpc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
17:10:45 <Jafet> @quote undoubtedly
17:10:46 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
17:10:46 <lambdabot>   not an expression: `let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)'
17:10:48 <hpc> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:10:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:10:57 <monochrom> fix is "like" *the* Y combinator
17:11:07 <min> thanks hpc and monochrom. that's  a neat library
17:11:11 <djanatyn> ooh, zipWith is nice
17:12:01 <djanatyn> hmm, do you have to import something to use fix? :t fix doesn't do anything for me
17:12:12 <Jafet> @index fix
17:12:13 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
17:12:16 <monochrom> Data.Function
17:12:32 <monochrom> in fact probably no longer in Control.Monad.Fix
17:12:47 <Jafet> Control.Monad.Error is awesome
17:13:02 <Jafet> Like an unexpected yard sale
17:19:09 <jessopher_> are there any guidelines for refactoring large haskell modules into smaller ones, without ending up with a bunch of mutual recursive dependencies? I have module in a project that is starting to become an indivisible black hole of almost everything
17:20:16 <monochrom> sometimes, they put data type declarations in one module, operations in other modules
17:21:11 <monochrom> sometimes, the library itself is clearly several layers of abstraction, so one module for one layer
17:21:55 <Jafet> But more often, the authors just toss the whole interface into one module and be rid of the issue
17:22:58 <monochrom> sometimes, you find that one group of users cares only about one subset of your API, another group cares only about another subset... so one module per subset or user group
17:23:37 <jessopher_> this module is an interpreter. declaration depends on evaluation, evaluation depends on declaration, and the combination of the two in the same place depends on lots of scrolling
17:24:23 <dmwit> <3 the "installed" constraint
17:25:29 <kfz> ghc's extension implicit parameters only saves you to pass arguments to every function or am I missing something?
17:25:47 <dmwit> You are not missing anything.
17:26:43 <dmwit> jessopher_: Why does declaration depend on evaluation?
17:27:15 <tivrfoa> hi. could someone recommend a GUI library?
17:27:54 <dmwit> tivrfoa: What library do you know?
17:28:05 <dmwit> There are bindings to wx, gtk, and opengl.
17:28:08 <dmwit> Pick your favorite.
17:28:17 <scshunt> win 4
17:28:30 <dmwit> There might be bindings to qt lying around somewhere, too, though I'm not as confident about that one.
17:28:34 <tivrfoa> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
17:28:49 <jessopher_> dmwit: because a declaration in this language is a mapping between a name, a set of declarations, and a computation
17:28:49 <monochrom> I recommend gtk2hs
17:29:14 <dmwit> If you don't know what you want, I also recommend gtk2hs.
17:29:17 <jessopher_> and building the computation requires the evaluator
17:29:53 <tivrfoa> could you mention some reasons?
17:30:09 <DevHC> wtfbbq Undefined symbol "stg_CAF_BLACKHOLE_info"
17:30:24 <tivrfoa> I'll try gtk2hs so. Thank you folks
17:31:02 <luite> tivrfoa: to answer your next question, you need to install gtk2hs-buildtools first ;)
17:31:16 <tivrfoa> haha ;)
17:31:41 <luite> (either that or the development version of the gtk libraries)
17:31:51 <monochrom> gtk2hs installation process (would be on its home page if not down): get the C-side lib and dev files (libgtk2.0-dev on debian and ubuntu), then "cabal install gtk2hs-buildtools", then "cabal install gtk"
17:32:03 <luite> (err you need both, but either one could've been your next question)
17:32:38 <monochrom> if you want the glade part too, add libglade2-dev and "cabal install glade"
17:33:16 <tivrfoa> ok
17:33:41 <accel_> @quote Knuth
17:33:42 <lambdabot> Knuth says: The conventional wisdom shared by many of today's software engineers call for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being
17:33:42 <lambdabot> practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs.
17:33:51 <accel_> @quote Dijkstra
17:33:51 <lambdabot> Dijkstra says: I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have
17:33:51 <lambdabot> liked this", well, that would be enough immortality for me.
17:33:56 <monochrom> I recommend it because it is actually maintained, e.g., so as to be buildable at all on recent platforms
17:35:21 <dbelange_> @quote stallan
17:35:22 <lambdabot> No quotes match. :(
17:35:24 <dbelange_> @quote stallman
17:35:25 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
17:35:35 <jessopher_> @quote stalin
17:35:36 <lambdabot> Adamant says: quantity (of programmers) has a quality all its own - Stalin the Pragmatic Programmer
17:35:59 <dbelange_> @quote lenin
17:36:00 <lambdabot> No quotes match. stty: unknown mode: doofus
17:36:35 <hpaste> foo annotated “MPTC's” with “MPTC's (annotation)” at http://hpaste.org/52440#a54354
17:36:45 <jessopher_> @quote rasputin
17:36:46 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
17:37:26 <accel_> is htere a way to get lambdabot to list all quotes?
17:37:31 <accel_> (in a private msg, of course, not channel)
17:38:00 <monochrom> I think no
17:38:00 <shachaf> You can look at its source repository, which has a vaguely recent version of its state.
17:38:07 <jessopher_> that seems like it would be a dangerous feature, even in private msg
17:38:10 <dbelange_> accel_: use haskell
17:38:33 <accel_> jessopher_: why?
17:38:35 <accel_> shachaf: wherE?
17:38:41 <accel_> is it on github?
17:38:52 <shachaf> accel_: You can probably find it if you look.
17:38:57 <jessopher_> sendq on the server, and multiple people using the feature at once
17:39:09 <accel_> https://github.com/seliopou/lambdabot
17:39:15 <accel_> is the seliopou guy the official mainter?
17:39:23 <shachaf> Who knows?
17:39:32 <shachaf> You're not going to find a very recent version of the quotes file at any rate.
17:57:35 <dmwit> ?where state
17:57:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
18:05:52 <augur> what should i read to get into topology?
18:06:39 <hpaste> “/dev/humancontroller” pasted “fuck this shit” at http://hpaste.org/54355
18:06:44 <DevHC> ^HALP
18:07:15 <min> i have been recommended munkres, but haven't started working through it
18:09:30 <kmc> @remember zalgo import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
18:09:30 <lambdabot> Good to know.
18:12:47 <JoeyA> DevHC: What version of GHC are you using?
18:13:12 <DevHC> 7.0.3
18:13:29 <dmwit> import Random -- ಠ_ಠ
18:15:06 <JoeyA> DevHC: This may have to do with it: http://hackage.haskell.org/trac/ghc/ticket/3705
18:15:15 <kmc> i̊m̶pͩo͖ŕt͑ ͜Rͮa͡n̋dͥo̮m̈́;̬m̵a̭i͂nͬ=͟m̳a̳p̻Mͩ_̯(̕(̾>̳>͍(̮י̜=͢<͂<͑r̎ä́n̛d͐oͦm̥R̲ÌO͝(ͫ'͆̀ͤ'̏,͆'̅ͯ̿'ͅ)̈)͒)͛.̚י̞)̕=ͪ<̳<̦g͊ętͤCͅo̜ńt̋ėn̚t́s̬;ͨי͂=͍p͐u̡t̒C͎h́aͤr̗
18:15:53 <JoeyA> Is that a captcha for Haskell programmers?
18:16:23 <djanatyn> hmm :\
18:16:37 <djanatyn> > map (mod 100) [0..99]
18:16:38 <lambdabot>   [*Exception: divide by zero
18:16:45 <djanatyn> oh, ermm
18:16:54 <djanatyn> > map (mod 100) [1..99]
18:16:55 <lambdabot>   [0,0,1,0,0,4,2,4,1,0,1,4,9,2,10,4,15,10,5,0,16,12,8,4,0,22,19,16,13,10,7,4,...
18:16:55 <DevHC> JoeyA: no, i'm using both -fPIC and -dynamic
18:17:19 <djanatyn> > map (/= 0) [1..99]
18:17:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
18:17:23 <DevHC> depending on wether i give -dynamic or no -dynamic, i get a different undefined reference
18:17:49 <DevHC> Undefined symbol "stg_ap_n_fast"
18:17:52 <djanatyn> > map (/= 0) $ map (mod 100) [1..99]
18:17:53 <lambdabot>   [False,False,True,False,False,True,True,True,True,False,True,True,True,True...
18:18:04 <djanatyn> > map (/= 0 . mod 100) [1..99]
18:18:05 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
18:18:05 <lambdabot>    arising from the arithmetic seq...
18:18:12 <djanatyn> ^-- I don't understand why that above line doesn't work
18:18:53 <fryguybob> > map ((/= 0) . mod 100) [1..99]
18:18:55 <lambdabot>   [False,False,True,False,False,True,True,True,True,False,True,True,True,True...
18:19:53 <DevHC> also, depending on what i use in Dyn.hs, i get different undefined references yet again
18:19:57 <DevHC> now i'm getting stg_CHARLIKE_closure
18:20:55 <shachaf> kmc++
18:21:47 <kmc> shachaf u like
18:21:56 <shachaf> kmc u cheater
18:22:33 <DevHC> so
18:22:52 <DevHC> is dynamically loading haskell libraries even supposed to work? lol
18:23:34 <dmwit> DevHC: Seems there aren't any experts on #haskell right now; maybe you should try one of the mailing lists or #ghc.
18:23:52 <dmwit> StackOverflow also seems like a good next choice.
18:24:53 <shachaf> #ghc is good because your question will stay on-screen for hours, so someone will see it for sure.
18:25:14 <DevHC> i'll sp4m #ghc then
18:25:55 <irene-knapp> actually yes, it is supposed to work if you use either hs-plugins or my own direct-llugins
18:25:58 <irene-knapp> both have bitrotted
18:26:00 <irene-knapp> but
18:26:07 <irene-knapp> but reading their source will give you an idea of what's involved
18:27:05 <DevHC> any short explanation?
18:27:25 <irene-knapp> mm, no :)
18:27:32 <irene-knapp> it's not a short topic
18:27:46 <DevHC> like, do i have to dlopen() some /usr/local/lib/*.so files?
18:28:05 <DevHC> i mean before dlopen()ing my Dyn.so
18:28:13 <shachaf> Oh, are you just trying to call Haskell from C/C from Haskell?
18:28:22 <DevHC> http://hpaste.org/54355
18:28:57 <blackdog> DevHC: you have to initialise the ghc runtime
18:29:07 <DevHC> how?
18:29:09 <irene-knapp> ah hm
18:29:12 <irene-knapp> yes hs_init should do it
18:29:24 <irene-knapp> although I don't know that passing NULL, NULL is valid
18:29:36 <irene-knapp> it might be, but I doubt it
18:29:38 <DevHC> it is valid
18:29:40 <ClaudiusMaximus> there's some stg_init thing that you need to add all top-level modules with too, iirc
18:29:42 <irene-knapp> okay
18:29:48 <irene-knapp> Claudius: no they took that requirement out
18:30:03 <DevHC> FFI specification says: NULL can be passed in the absense of arguments
18:30:09 <irene-knapp> (thank gawd, because it was a huge maintenance hassle)
18:30:14 <shachaf> DevHC: Shouldn't it at least be (0, NULL)?
18:30:28 <DevHC> last?
18:30:28 <ClaudiusMaximus> irene-knapp: oh cool
18:30:58 <irene-knapp> DevHC: oh I see your problem
18:30:59 <DevHC> shachaf: u mean hs_exit(0, NULL)? or wat?
18:31:03 <irene-knapp> you need to load all the dependent libraries
18:31:07 <irene-knapp> including the RTS itself
18:31:18 <DevHC> fuck this shit
18:31:59 <irene-knapp> yes, that attitude is why I was reluctant to get involved =p
18:32:07 <DevHC> ok, how does a dynamic library containing both C and Haskell do it automatically?
18:32:13 <blackdog> DevHC: https://github.com/mwotton/Hubris/blob/master/ext/stub/stub.c shows one way
18:32:17 <irene-knapp> I've never done it dynamically, I only know the static case
18:32:21 * shachaf notes that DevHC isn't behaving in a way that is optimal for getting help in IRC.
18:32:28 <blackdog> with a bit of ruby fluff you can ignore
18:32:42 <irene-knapp> that is, I've done dynamic loading of Haskell from Haskell
18:32:52 <blackdog> (i had to malloc and copy because of some memory protection stuff, IIRC)
18:32:55 <irene-knapp> and I've done static loading of Haskell and C from Haskell and C (all four possibilities)
18:33:14 <irene-knapp> your exact scenario is not one that I have tried
18:33:14 <shachaf> irene-knapp is an expert in the ld cube.
18:33:21 <irene-knapp> haha unfortunately true
18:33:31 <irene-knapp> I actually am not sure what the motivation for making it dynamically loaded is, though?
18:33:34 <dr_rotflcopter> ahah DevHC
18:33:39 <dr_rotflcopter> ghc doesnt like you?
18:36:12 <DevHC> dr_rotflcopter: something doesn't like me, and i have a feeling that it is indeed GHC
18:36:21 <DevHC> blackdog: and what does that thing DO?
18:36:40 <dr_rotflcopter> the GHC?
18:36:43 <dr_rotflcopter> noone knows
18:36:58 <dr_rotflcopter> but should do what you tell it
18:37:09 <dr_rotflcopter> getting the result in whatever methods
18:37:10 <blackdog> DevHC: it's my ruby-haskell bridge. that bit is just the part that starts up the ghc runtime so that ruby can load the .so files.
18:37:29 <blackdog> (which are haskell .so files, of course)
18:37:45 <DevHC> blackdog: so r u saying taht i should try passing some non-NULL arguments to hs_init()?
18:38:13 <irene-knapp> I would try hs_init(0, NULL)
18:38:13 <blackdog> i think NULL _should_ work, but i haven't tried it
18:38:18 <irene-knapp> and see where it gets you
18:38:24 <irene-knapp> but it does seem like that's not the problem
18:38:29 <DevHC> why? 0 is NULL basically
18:38:42 <DevHC> well nvm
18:38:44 <DevHC> let's see
18:38:46 <irene-knapp> *sigh* they are of different types
18:39:03 <DevHC> EPIC FAIL
18:39:25 <shachaf> I couldn't have put it better myself.
18:39:48 * shachaf stopped paying attention a while ago, though.
18:41:23 <DevHC> void hs_init(int *argc, char **argv[]);
18:41:29 <shachaf> Oh.
18:41:31 <irene-knapp> oh, right, hm
18:41:33 <shachaf> Never mind, then.
18:42:03 <blackdog> ah, it's coming back to me. i remember trying to pass a pointer to the real argc and argv, and having everything break horribly
18:43:09 <c_wraith> huh?
18:43:14 <c_wraith> isn't it just int argc?
18:43:17 <irene-knapp> no
18:43:21 <irene-knapp> it wants to modify your arguments
18:43:26 <sylecn> Can I write (\(_,h1) (_,h2) -> h1 == h2) using sections with snd and (==)?
18:43:26 <c_wraith> oh!
18:43:30 <c_wraith> it's not main
18:43:30 <c_wraith> hah
18:43:41 <dmwit> :t (==) `on` snd
18:43:42 <lambdabot> forall a b. (Eq b) => (a, b) -> (a, b) -> Bool
18:44:10 <shachaf> @let off = flip on
18:44:11 <lambdabot>  Defined.
18:44:37 <shachaf> Hmm, that function seemed a whole lot more useful a few seconds ago.
18:45:06 <sylecn> thanks
18:45:26 <dmwit> shachaf: off is a much better function for prefix use.
18:45:44 <shachaf> Oh, yes.
18:45:44 <dsj36> Is there a clean way to get, say, a parallel map when my evaluations live within the IO monad?
18:45:48 <dmwit> (And the infix version is crappy for full application.)
18:46:22 <dmwit> ?faq Is there a clean way to get, say, a parallel map when my evaluations  live within the IO monad?
18:46:23 <lambdabot> The answer is: Yes! Haskell can do that.
18:46:38 <dsj36> hehe so how should I go about it?
18:47:04 <dsj36> I'm writing a scheme interpreter, so everything is inside an IO monad with the ErrorT transformer
18:47:24 <dsj36> I'd like to provide a "parallel-let" special form that evalutes the bindings in parallel, say
18:47:34 <dsj36> ditto for parallel-map/parallel-reduce
18:48:08 <dsj36> It seems like the Control.Parallel.Strategies won't do it in this case
18:48:32 <rwbarton> indeed. You should use forkIO in some way
18:48:35 <ClaudiusMaximus> dsj36: http://hackage.haskell.org/package/spawn
18:49:04 <dsj36> cool thanks
18:49:06 <shachaf> Of course, this is going to be a concurrent map. :-)
18:49:24 <dsj36> how should I be worrying about strictness for parMapIO/spawn?
18:49:45 <Axman6> yes, but you get to use the evaluate function so s'all good
18:50:05 <Axman6> :t evaluate
18:50:07 <lambdabot> Not in scope: `evaluate'
18:50:09 <Axman6> bleh
18:50:15 <Axman6> evaluate :: a -> IO a
18:50:22 <rwbarton> parMapIO will execute the actions concurrently
18:50:51 <rwbarton> so you can use evaluate to construct an action that will evaluate an expression to WHNF
18:51:24 <dsj36> great, thanks! I will try this out
18:55:03 <DevHC> OMFG !!!!!!!!!!!!!!!!!!!!!!!!!!!!11
18:55:09 <Axman6> is there any reason to not make things like putStrLn have type MonadIO m => String -> m ()?
18:55:22 <DevHC> adding -lm -lHSffi -lHSrts -lHSbase-4.3.1.0 -lffi -liconv -lgmp -lHSinteger-gmp-0.2.0.3 -lHSghc-prim-0.2.0.0 when compiling Dyn.so fixes the issue
18:55:36 <rwbarton> Axman6: it's more complicated
18:55:38 <DevHC> wtf is --make for?
18:55:57 <Axman6> DevHC: --make is for haskell modules only, not C libraries
18:56:13 <DevHC> Axman6: and?
18:56:33 <Axman6> it seems odd that you'd need more than half of those
18:57:12 <DevHC> i didn't say i need them all
18:58:21 <DevHC> ok, i only need -lHSrts
18:58:27 <jessopher_> haha
18:58:32 <DevHC> WTF?
18:58:41 <DevHC> so --make fails?
19:00:48 <monochrom> call it whatever you like.
19:01:30 <DevHC> TODO: fuck this shit
19:03:06 <incluye> done
19:06:04 <copumpkin> preflex: seen mzero
19:06:04 <preflex>  mzero was last seen on #haskell 19 hours, 45 minutes and 48 seconds ago, saying: I suppose I could do the deep-clean if you invoke the utility with the name high-colonic
19:06:25 <parcs> putStrLn is in 'base', MonadIO in 'transformers'. the base package shouldn't really depend on any other package
19:09:27 <shachaf> Axman6: The real annoyance is with things that take IO actions as arguments, not things that return them.
19:12:15 <ddarius> copumpkin: I hope you didn't just get back.
19:12:44 <copumpkin> I got back about 10 minutes ago
19:13:03 <ddarius> Jeez.
19:13:11 <copumpkin> the wonders of the green line :)
19:14:01 <ddarius> It would probably be faster for you to walk.  It shouldn't be that far from Harvard Square.
19:14:14 <copumpkin> yeah, it isn't that bad
19:14:17 <copumpkin> but probably not faster
19:14:26 <copumpkin> I walked back from central square yesterday in about 45 minutes
19:14:39 <copumpkin> so probably about an hour
19:14:41 <ddarius> Central is even farther away than Harvard.
19:14:51 <copumpkin> really? hmm
19:15:09 <copumpkin> nope, if I just keep walking along mass ave I get to harvard from central
19:15:21 <ddarius> Maybe you don't live where I think you live.
19:15:44 <byorgey> try 'map'
19:15:56 <copumpkin> wrong type, sorry
19:16:39 <dolio> Pretty sure Harvard isn't closer to his place.
19:16:48 <ddarius> Yeah, I guess Central is closer.
19:17:02 <ddarius> I thought you lived further west than you do.
19:17:10 <shachaf> Did you go to a Greek restaurant?
19:25:44 <Cale> http://hackage.haskell.org/trac/ghc/ticket/3497 -- this ticket closure is kinda hilarious
19:26:38 <Cale> in that, if you wanted to construct GADTs with Template Haskell, this theoretically solves the issue while making things extremely painful.
19:28:04 <ddarius> Cale: That can be solved by library support.
19:28:18 <ddarius> It does reveal the essence of GADTs.
19:28:29 <Cale> sure, it's just annoying :P
19:28:49 <Cale> It would be nice for the TH library to have something which looks more like the concrete syntax of GADTs
19:29:19 <ddarius> I agree.
19:30:33 <copumpkin> I've constructed GADTs with TH before
19:30:39 <copumpkin> it's unpleasant
19:31:09 * hackagebot enumerator-fd 0.1.0.2 - Enumerator instances for monads-fd classes  http://hackage.haskell.org/package/enumerator-fd-0.1.0.2 (JohnMillikin)
19:31:43 <dolio> At least that encoding works identically to the concrete syntax you'd usually use.
19:32:38 <dolio> Unlike the equivalent in Agda.
19:33:00 <dolio> Not that Agda has comprehensive metaprogramming.
19:33:55 <ddarius> Template Haskell has never been able to catch up to the language.
19:38:54 <ddarius> Spitting out strings is more efficient than DOM manipulation it seems ...
19:41:09 * hackagebot enumerator 0.4.16 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.16 (JohnMillikin)
19:41:43 * shachaf wonders what ddarius is doing.
19:43:34 <aristid> shachaf: ddarius is a bot made by a superior alien intelligence to amuse themselves
19:50:06 <mathstuf> hi, are there any existing webdav client libraries?
19:50:28 <mathstuf> i didnt see any on hackage, but i thought someone might know of one here
19:52:49 <DevHC> what was, again, the first version of GHC supporting FFI?
19:53:04 <ddarius> Probably the first version of GHC.
19:53:25 <shachaf> When was the first version of GHC released?
19:53:45 <ddarius> It depends on what you count as the first but anytime between 1987 and 1990.
19:54:22 <ddarius> Probably closer to the latter.
19:54:46 <shachaf> Hmm, the first version downloadable from the website is from ~1996.
19:55:17 <shachaf> "We could provide diffs from previous versions of GHC, should you require them.  A full set would be very large (7MB)."
20:01:23 <ddarius> I believe the GRASP project started in 1987.  Haskell 1.0 would be April 1st, 1989 if I remember correctly.  GHC was bootstrapped with HBC, I believe, so there wouldn't have actually been something to see until after HBC existed.
20:04:35 <bobzhang> has anybody tried lifted spine view? I could not make it compile in my GHC?
20:04:41 <bobzhang> http://hpaste.org/54357
20:05:48 <shachaf> The first few lines of that file read like one of those unpronounceable ingredient lists.
20:06:37 <bobzhang> shachaf: are you  talking to me?
20:07:29 <Cale> There wouldn't happen to be a nice GHC flag for capturing intermediate source after TH splices have all run? I know there's -ddump-splices...
20:11:09 * hackagebot cuda 0.4.0.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.4.0.1 (TrevorMcDonell)
20:22:06 <amalloy> any recommendations for an introductory haskell book? i'm happy to get LYaH, but i would love to know if there's something else. i've got experience with functional programming in clojure, so if possible i'd like something that doesn't waste a lot of time on (e.g.) how to write map, instead looking at the things that make haskell especially shine
20:22:55 <dmwit> ?where rwh
20:22:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:23:01 <dmwit> ?wiki books
20:23:01 <lambdabot> http://www.haskell.org/haskellwiki/books
20:23:58 <amalloy> thanks dmwit! i'll take a look
20:24:19 <dmwit> Oh, and my favorite (not a book, though):
20:24:20 <dmwit> ?where gentle
20:24:21 <lambdabot> http://www.haskell.org/tutorial/
20:25:18 <amalloy> dmwit: yeah, i'm trying to find an actual paper book: i got about a third of the way through LYaH several months ago and then forgot about it. a physical object is harder to neglect
20:26:36 <dmwit> Assuming you've got a nearby print shop that will do 10c/sheet (which I think is roughly the price these days?) you could turn it into a book for less than $7. =)
20:27:14 <shachaf> amalloy: _Programming in Haskell_ by Hutton is good.
20:28:19 <shachaf> A bit short, though. But as an introductory book it's great.
20:28:25 <shachaf> dcoutts seems to agree. :-)
20:29:55 <shachaf> It would be nice if it was available for free online so I could recommend it to people without feeling guilty.
20:30:49 <amalloy> shachaf: "Assumes no programming experience" horrifies me. i don't want to waste a bunch of time learning what a variable is :P. but RWH looks like a good choice
20:31:27 <luite> shachaf: well it is, but you'd feel guilty about referring people to pirate sites ;p
20:36:09 * hackagebot luautils 0.1 - Helpers for Haskell integration with Lua  http://hackage.haskell.org/package/luautils-0.1 (AnupamJain)
20:37:03 <Sgeo> I can, in my module, if I hide Prelude, redefine (:), right?
20:37:29 <shachaf> Sgeo: I don't think so.
20:37:44 <Sgeo> Hm :(
20:37:50 <Sgeo> :t (:::)
20:37:50 <lambdabot> Not in scope: data constructor `:::'
20:38:11 <DevHC> not really haskell related, but: can i dlopen() a library which requires a function that is defined in the address space of the program calling dlopen()?
20:38:40 <Sgeo> 1:::2:::3:::N seems rather ... like a giveaway. (It has been suggested to me to make it look to an outside like there's no real difficulty to using it this way, like it's ho hum)
20:47:55 * gwern checks email. no new romanian complaints. so far so good...
20:49:26 <ClaudiusMaximus> DevHC: yes, at least on linux (provided you give certain options to dlopen(); you can also dlopen(a) then dlopen(b) which depends on symbols in a)
20:50:32 <gwern> and just one random spam edit on hawiki
20:50:38 <gwern> which is a relief
20:50:46 <performance> is there a way to enumerate all possible constructors of a data ?  e.g. data TodoOptions = List | Add | Edit | Delete | Quit deriving ( Enum, Eq, Read, Show )
20:51:00 <DevHC> call dlopen(b) inside a)?
20:51:06 <DevHC> ClaudiusMaximus ^
20:51:12 <ClaudiusMaximus> performance: derive also Bounded, then [minBound..maxBound]
20:51:14 <dmwit> performance: derive Bounded as well
20:51:15 <performance> same as [ List .. Quit] but using only Todo
20:51:22 <performance> same as [ List .. Quit] but using only TodoOptions
20:51:50 <dmwit> performance: [List .. Quit] should work just fine
20:52:08 <ClaudiusMaximus> DevHC: not sure how the nesting works - i think the option is RTLD_GLOBAL or something
20:52:24 <dmwit> performance: But [minBound .. maxBound] is a bit better because if you later change the constructors you don't have to fix your list bounds.
20:52:24 <geheimdienst> gwern: thanks for doing the spam removal work :) much appreciated
20:52:35 <performance> dmwit: it does work.. but i was wondering if there was a way to get that info from TodoOptions
20:52:39 <gwern> geheimdienst: you're welcome
20:52:44 <dmwit> performance: Get what info?
20:52:51 <ClaudiusMaximus> DevHC: but i meant consecutive library loading from the main program in the example i gave
20:52:57 <gwern> (not glamorous but this sort of thing keeps the haskell community going - endless unpaid labor, that is)
20:53:10 <performance> the same list as [List .. Quit] in this case
20:53:26 <dmwit> performance: Yes. As both ClaudiusMaximus and I suggested, derive Bounded.
20:53:47 * gwern goes to bed. I'll probably wake up to something. at least the night was quiet.
20:54:57 <performance> dmwit: yes even after i do that, i still need to explicitly say [ List .. Quit ] I need to know those bounds, is there a different way to get that same list , with out having to explicitly use the List and Quit constructor names
20:55:18 <DevHC_> ClaudiusMaximus: fails here
20:55:24 <dmwit> performance: Use [minBound .. maxBound].
20:56:12 <dmwit> (Again, as both ClaudiusMaximus and I suggested above.)
20:56:39 <rwbarton> performance: I recommend you read what dmwit wrote above.
20:56:43 <rwbarton> (maybe that will help?)
20:57:05 <DevHC_> ClaudiusMaximus: i have "int required(int a) { ... }" in a local scope, and i'm using dlopen("Dyn.so", RTLD_LAZY | RTLD_GLOBAL);, and get: ./Dyn.so: Undefined symbol "required". (Dyn.so was built with: foreign import ccall "required" ...)
20:58:21 <performance> :D duh, dumb me. it was the type sig, for the list it has to be a list. [minBound .. maxBound]::TodoOptions did not work, but for the list, the type should be  ::[TodoOptions]
20:58:41 <performance> dmwit: rwbarton sorry for the extra bother . and thanks
20:58:52 <DevHC_> ClaudiusMaximus: btw the manpage talks a lot about DAGs D:
20:59:10 <performance> that is exactly what i was looking for
21:00:26 <ClaudiusMaximus> DevHC_: maybe RTLD_NOW instead of LAZY ? or add 'extern' in the C source? i'm not an expert (and this is a bit off-topic..)
21:00:52 <ClaudiusMaximus> (oh, it's not off-topic, if there's ffi - i should sleep..)
21:01:13 <dmwit> performance: You can write [minBound .. maxBound :: TodoOptions] if you prefer fewer brackets.
21:01:46 <DevHC_> ClaudiusMaximus: extern for a C function definition? :O
21:02:20 <DevHC_> ClaudiusMaximus: RTLD_NOW can just make things worse in this case
21:03:47 <performance> dmwit: i just tried all three possibilities, and find that for me [minBound::TodoOptions .. maxBound::TodoOptions] is the most , intuitive.. but losing the type sig on the max bound seems a good compromise
21:07:02 <Sgeo> Should I get Haskell Platform from my distro, or from the website?
21:07:24 <shachaf> Sgeo: Depends on the version.
21:07:29 <shachaf> Probably from the website.
21:08:36 <Sgeo> I don't think my distro even has GHC 7
21:08:46 <shachaf> There you go.
21:09:48 <Sgeo> http://haskell.org/ghc/distribution_packages#ubuntu
21:09:52 <Sgeo> Recommending I get GHC6
21:10:00 <Sgeo> Which won't work with source form of Haskell Package
21:10:04 <Sgeo> *HAskell Platform
21:10:14 <shachaf> Sgeo: Don't listen to them!
21:10:20 <shachaf> GHC 7 is the one true GHC.
21:10:59 <shachaf> Is (const undefined) a strict function?
21:12:07 <Axman6> no?
21:12:16 <Axman6> actually, hmm
21:12:17 <geheimdienst> shachaf: strict in its argument? i don't think it evaluates its argument ...? i thought it's the same as "\x -> undefined", x is never touched and could be written as _
21:12:24 <shachaf> geheimdienst: Yes.
21:12:31 * geheimdienst , strictness expert
21:12:33 <Axman6> all that's required is that f _|_ = _|_ right?
21:12:41 <shachaf> But the standard definition of a strict function is -- what Axman6 said.
21:12:47 <Axman6> =)
21:12:50 * Axman6 wins!
21:13:04 * Axman6 should be doing more study for how PoPL exam tomorrow
21:13:24 <geheimdienst> > (const undefined) undefined
21:13:24 <kfish> fastest to the bottom
21:13:25 <lambdabot>   *Exception: Prelude.undefined
21:14:04 <Axman6> hmm, does that mean that f x = f x is strict?
21:14:35 <shachaf> f x = f x isn't very different from f x = undefined
21:14:46 <Axman6> i guess
21:14:51 <shachaf> _|_ is _|_
21:16:48 <geheimdienst> btw does "asks" (or "gets") from Reader make any sense to anyone? i mean, i know what it does, but it seems like an odd unenglish way to phrase things. "x <- asks someRecordField" ... it's not asking the record field, it's asking *for* it
21:48:13 <hpaste> NemesisD pasted “yesod failure” at http://hpaste.org/54360
22:05:31 <unlink> @pl \f g h x -> g x `f` h x
22:05:31 <lambdabot> liftM2
22:06:26 <c_wraith> > liftM2 (+) (*2) (`div` 3) 18
22:06:27 <lambdabot>   42
22:06:54 <unlink> Well I'll be a monkey's uncle.
22:10:44 <unlink> > (+) <$> (*2) <*> (`div` 3) $ 18
22:10:45 <lambdabot>   42
22:16:00 <unlink> @pl \f g x y -> f (g x y)
22:16:00 <lambdabot> (.) . (.)
22:17:59 <c_wraith> people often define something like .: for that.
22:18:23 <c_wraith> since it is helpful, and doesn't match any of the existing combinators
22:20:01 <ddarius> :t (.:)
22:20:02 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
22:20:28 <Sgeo> Gimme a good semicolon-like character that can legally be used as an operator. Not >>
22:20:58 <Sgeo> Then again, if I don't use `pseq`, the evil of what I'm doing may not be immediately apparent
22:21:23 <unlink> c_wraith: I was using (...) for the visual similarity to (.).(.)
22:21:58 <shachaf> unlink: .: also has three dots. :-)
22:22:08 <unlink> hah.
22:24:20 <unlink> could use … for that matter.
22:59:36 <performance> *** Exception: <stdin>: hGetChar: invalid argument (Bad file descriptor)
23:00:40 <performance> any one know why i get this?
23:01:10 <shachaf> You're probably giving hGetChar an invalid argument (I'm guessing it's a bad file descriptor).
23:01:40 <hpaste> performance pasted “Exception bad file descriptor ” at http://hpaste.org/54361
23:03:51 <performance> shachaf: getChar is a prelude function,
23:03:58 <performance> > :t getChar
23:03:59 <lambdabot>   <no location info>: parse error on input `:'
23:04:04 <shachaf> performance: I'm aware.
23:05:35 <bmh> How do I hide something like ++ in an import?
23:05:41 <c_wraith> put it in parens
23:05:49 <c_wraith> import Prelude hiding ((..))
23:05:56 <c_wraith> err, ++, not ..
23:05:57 <bmh> that was obvious. Thanks :)
23:06:01 <c_wraith> .. isn't even valid :)
23:06:41 <Sgeo> performance,
23:06:44 <performance> shachaf: also, how would one use interact instead of the doLoop i have there?
23:06:45 <Sgeo> :t getChar
23:06:46 <lambdabot> IO Char
23:08:13 <shachaf> performance: I don't think you'd use interact for that sort of thing.
23:08:47 <performance> how does one quit the loop in interact?
23:08:57 <c_wraith> you don't
23:09:03 <performance> if it always keeps applying a function to the user's input on stdin ?
23:09:16 <performance> c_wraith:  :) hmm
23:09:56 <c_wraith> :t interact
23:09:58 <lambdabot> (String -> String) -> IO ()
23:10:00 <performance> oh by the way i forgot to tell, i am on windows vista
23:10:19 <c_wraith> well.  You can always have your function produce the end of the string without consuming all its input
23:10:29 <c_wraith> that will cause it to stop running
23:11:18 <performance> i couldnt find much help on google :(
23:11:29 <c_wraith> well it's just standard lazy evaluation
23:11:50 <performance> regarding the exception
23:13:18 <Axman6> don't you just return []?
23:13:37 <Axman6> because you just get the contents form getContents, and that output gets printed
23:13:53 <Axman6> and once you return the end of the list, there's nothing more to print
23:24:11 <performance> hmm.. gnite
23:27:05 <Sgeo> Undefined behavior is going to be my best friend >:)
