00:08:56 <SgeoN1> What does >~ mean?
00:10:04 <byorgey> SgeoN1: Haskell operators do not have fixed meanings, it depends where you saw it.
00:12:16 <SgeoN1> It was in a type signature for something related to Netwire
00:13:13 <SgeoN1> And Netwire is some arrowy thingy
00:13:23 <byorgey> SgeoN1: well then, you'll have to see how >~ is defined in netwire
00:13:48 <byorgey> SgeoN1: or ask mm_freak.
00:13:50 <SgeoN1> How can you have operators like that in a type signature though?
00:14:03 <byorgey> SgeoN1: with the  TypeOperators  extension.
00:14:08 <SgeoN1> Or, I guess I should consider types to be a bit like functions?
00:15:15 <SgeoN1> I'd guess that >~ has kind * ->* >- *
00:15:28 <byorgey> SgeoN1: probably
00:17:14 <byorgey> SgeoN1: ah, it looks like netwire uses (>~) simply as a variable to stand for some arbitrary arrow
00:17:24 <byorgey> SgeoN1: for example, see http://hackage.haskell.org/packages/archive/netwire/2.0.1/doc/html/Control-Wire-Types.html
00:19:26 <SgeoN1> I should sleep soon
00:21:01 <byorgey> me too
00:23:12 <mm_freak> copumpkin: i'm using Map in netwire for 'context'…  that's basically a context-sensitive automaton, where the input signal is the context
00:23:20 <mm_freak> copumpkin: i did not notice any speed difference with IntMap
00:24:06 <mm_freak> SgeoN1: as byorgey said, (>~) is just the underlying arrow for the Wire arrow transformer
00:24:37 <mm_freak> you can think of Wire as:  newtype Wire e (>~) a b = Wire (a >~ (Either e b, Wire e (>~) a b))
00:24:40 <edwardk> netwire?
00:25:04 <byorgey> edwardk: yep
00:25:29 <edwardk> Control.Wire is a pretty cool module name, but er.. what does it do?
00:25:46 <mm_freak> SgeoN1: replacing (>~) by (->) might help you to understand its purpose
00:25:58 <mm_freak> edwardk: automaton arrow transformer library
00:26:01 <mm_freak> mainly for FRP
00:26:04 <edwardk> ah
00:26:35 <edwardk> ah, i see it now. >~ all over the place
00:26:44 <SgeoN1> Sleep time. I still do not quite understand arrows, although I think I have vague notions about the syntax
00:26:52 <edwardk> i usually use ~> for user arrow and category types
00:27:18 <mm_freak> edwardk: in some fonts ~ is not easily distinguishable from -
00:27:24 <mm_freak> that's why i use >~ instead of ~>
00:27:44 <byorgey> . o O ( ~>  looks like an alligator eating a Cheeto )
00:27:47 <edwardk> but the problem for me is that that notation doesn't scale well. because the - vs ~ thing and that i often need to see more than one arrow
00:27:49 <edwardk> yeah
00:28:05 <Blkt> good morning everyone
00:28:37 <edwardk> byorgey: thanks now i'll never be able to see it the same way
00:28:37 <edwardk> >~ just looks like a hungry piranha or an moray eel
00:28:42 <edwardk> er a moral
00:28:44 <edwardk> er moray
00:28:45 <edwardk> bah
00:29:17 <byorgey> ah, moray eel, that's it!  I knew it looked like a hungry *something*
00:33:32 <mm_freak> hehe
00:38:01 <edwardk> or maybe its just a baby alligator
00:49:37 <simon> >~ looks like a duck pinching its eye.
00:53:33 <edwardk> >p -- is it a duck or a rabbit?
00:54:26 <mm_freak> well, the ~ reminds me of a wave, hence the symbol =)
00:54:32 <mm_freak> otherwise i would have just used >-
00:54:36 <mm_freak> or something like that
00:55:36 <edwardk> well >~ looks like you have too much wire. so clearly it should be >- =)
00:55:46 <mm_freak> hehe
00:57:07 <yitz> perhaps ~~> or ~-> or -~> would be better
00:57:08 <Entroacceptor> just use the one symbol everyone used consitently here: =)
00:57:28 <Entroacceptor> yitz: ugh, worst evar
00:57:58 <mm_freak> yitz: don't like them =)
00:58:01 <mm_freak> i like >~
00:58:10 <yitz> Entroacceptor: well, ~> is confusing in some fonts, and >~ doesn't even look like an arrow
00:58:15 <edwardk> sadly i just use 'k' these days because i wind up needing two whenever i talk about functors betwee them anyways
00:58:43 <mm_freak> edwardk: k for arrows?
00:58:53 <edwardk> well, since he's binding it at the type level he could use (-)
00:59:35 <mm_freak> or (--) =P
00:59:38 <yitz> how about -=>
00:59:43 <edwardk> yeah c and d woud be more traditional but i wind up using them for object names, which puts me down in i j k for category names, because f and g are taken by functors
01:00:17 <shachaf> --> -=> -≡> -≣>
01:00:21 <edwardk> i almost used that for entailment in my constraints package
01:00:28 <yitz> shachaf: haha nice
01:00:36 <yitz> except --> has its problems
01:00:51 <edwardk> |- at least shows a notion of entailment =)
01:01:13 <yitz> edwardk: yeah i've seen that one used. it's not too bad.
01:01:16 <kstt> happstack-lite is a nice initiative
01:01:40 <edwardk> being that i was binding a type constructor i went with :- because :|- looked pretty redundant
01:02:21 <edwardk> :=> made a good class name though
01:02:59 <kstt> (I'd write my praise as a comment on jeremy's blog if I could do so without registering to a google or aim or whatever online service first)
01:03:03 <edwardk> instance Eq a => Eq [a]    then reifies as instance Eq a :=> Eq [a]
01:03:26 <yitz> kstt: link?
01:03:35 <edwardk> kstt: i find it funny how happs lightened to happstack, which is now shedding more weight
01:04:02 <yitz> then there are always more expressive things like !@#$%^&*
01:04:08 <yitz> > let (!@#$%^&*) = (+) in 2!@#$%^&*3
01:04:09 <lambdabot>   5
01:04:18 <edwardk> what is funny to me is that the name is obviously not the thing being shortened
01:04:40 <edwardk> in the end the module name will be 40k long but the library will be just a stub
01:04:46 <yitz> edwardk: the next step will be happstack-lite-even-easier
01:05:07 <edwardk> happstack-lite-with-tartar-control
01:07:29 <kstt> yitz: http://happstack.blogspot.com/2011/11/ann-happstack-lite-friendly.html
01:08:31 <Tordek> hi, can anyone give me a simple example of >=>? everywhere I find the oh-so-useless foo >=> bar
01:09:21 <kstt> edwardk: ;)
01:10:06 <edwardk> tordek: i use it occasionally when writing out examples for iteratees for the continuation binding
01:10:38 <shachaf> > ((`lookup`[("a","b"),("c","d")]) >=> (`lookup`[("b",5),("d",8)])) "a"
01:10:39 <lambdabot>   Just 5
01:11:11 <edwardk> The "Iteratees a la Oleg" slide in http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf uses it that way for instance
01:11:53 <edwardk> but then i have to give it up again when i move on later and need an extra argument
01:11:54 <shachaf> I think it's typically much less useful in practice than (>>=).
01:12:09 <edwardk> yeah, though it has a nicer theoretical justification in many ways
01:12:12 <Tordek> awesome, thanks :)
01:12:13 <shachaf> But if you come across a case where you're composing two monadic functions, well, there you go. :-)
01:12:15 <edwardk> and makes the monad laws easy to state
01:12:18 <shachaf> edwardk: Right, and the monad laws -- yes.
01:12:41 <edwardk> because then the monad laws are just the associativity of (>=>) and at return forms its unit
01:13:12 <mm_freak> yitz: i think that >~ is fine
01:13:32 <edwardk> but but we want to color the bikeshed pink!
01:15:21 <edwardk> more importantly, we want you to repaint it pink. that way we don't have to lift up the brush
01:15:32 <edwardk> because that sounds conspicuously like work
01:21:19 <shaan> hi
01:21:21 <shaan> hello
01:21:29 <shaan> nebody there???
01:21:58 <shachaf> There is only silence and some second-hand clothes.
01:26:54 <erus`> is the a neat way to write (-1) as a Num -> Num ?
01:26:59 <erus`> > (-1) 2
01:27:00 <lambdabot>   -1
01:27:11 <shachaf> > subtract 1 2
01:27:12 <lambdabot>   1
01:27:23 <shachaf> Also, Num -> Num isn't a type. :-)
01:33:12 <rostayob> > flip (-) 1 2
01:33:13 <lambdabot>   1
01:33:19 <rostayob> but that's not neat ehe
01:33:27 <rostayob> - is the only prefix operator in haskell
01:33:59 <rostayob> so it comes at a price
01:34:27 <shachaf> rostayob: - and every no-symbol.
01:34:31 <shachaf> s/no/non/
01:34:52 <rostayob> well that's what i mean by operator
01:37:54 <akosch> what would be an elegant way of generating a list of all possible tuples of booleans (with size 6)? Example for size 2: [(False, False), (False, True), (True, False), (True, True)]
01:39:03 <danr> akosch: do you mean 6-sized tuples?
01:39:10 <akosch> danr: yeah
01:39:34 <danr> > let bs = [True,False] in (,,,,,) <$> bs <*> bs <*> bs <*> bs <*> bs <*> bs
01:39:35 <lambdabot>   [(True,True,True,True,True,True),(True,True,True,True,True,False),(True,Tru...
01:39:44 <danr> but why would you want 6-tuples?
01:41:23 <akosch> danr: I have 6 boolean inputs for a function and want to verify it for each input
01:42:07 <akosch> danr: btw, how does this work exactly?
01:42:36 <danr> akosch: it uses the applicative instance for lists
01:43:02 <danr> it's a bit like [ (x,y) | x <- bs , y <- bs ], but you don't need to name all the lists
01:43:04 <akosch> danr: it would be more verbose with a list comprehension, right?
01:43:16 <danr> akosch: yes, you would need to name all 6 variables
01:43:23 <akosch> danr: got it, thanks
01:43:36 <danr> np :)
01:58:02 <akosch> danr: how would I do the same for lists instead of tuples and with a much larger length?
01:58:44 <akosch> danr: where I don't want to write <*> bs a hundred times :)
01:59:13 <danr> > let bs = [True,False] in replicateM 4 bs
01:59:14 <lambdabot>   [[True,True,True,True],[True,True,True,False],[True,True,False,True],[True,...
01:59:35 <danr> I guess you don't really need to let bind bs there, since you only need to use it once :)
01:59:55 <akosch> danr: wow, this is great... thanks again!
02:00:30 <danr> yeah the list monad is quite awesome
02:00:42 <alistra> > foldl (>>=) [] [True,False]
02:00:43 <lambdabot>   Couldn't match expected type `b -> [b]'
02:00:43 <lambdabot>         against inferred type `GHC....
02:00:45 <alistra> uh
02:00:48 <danr> this technique can be used to enumerate many alpabets
02:00:59 <danr> > do { x <- [0..] ; replicateM ['a'..'c'] }
02:01:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
02:01:01 <lambdabot>         against inferred type ...
02:01:07 <alistra> > foldl (>>=) [[]] [True,False]
02:01:08 <lambdabot>   Couldn't match expected type `[a] -> [[a]]'
02:01:08 <lambdabot>         against inferred type `...
02:01:08 <danr> > do { x <- [0..] ; replicateM x ['a'..'c'] }
02:01:09 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
02:01:22 <erus`> (x -) and (x `subtract`) seem to be doing different things....
02:01:26 <alistra> > foldr (>>=) [] [True,False]
02:01:26 <lambdabot>   Occurs check: cannot construct the infinite type: b = a -> b
02:01:43 <danr> @type foldr (>>=)
02:01:44 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
02:01:44 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
02:01:44 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
02:02:06 <akosch> danr: and it's quite concise
02:02:33 <danr> akosch: yes :)
02:06:51 <alistra> :m Unsafe.Coerce
02:06:55 <alistra> @m Unsafe.Coerce
02:06:56 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
02:06:58 <erus`> god damnit subtract take arguments in switched order than (-) :P
02:06:59 <alistra> :m Unsafe.Coerce
02:07:03 <alistra> > :m Unsafe.Coerce
02:07:04 <lambdabot>   <no location info>: parse error on input `:'
02:08:48 <rostayob> erus`: that's the point so you can write sections like (subtract 1) - which is what you asked
02:08:58 <erus`> yeah it makes sense now :)
02:09:14 <erus`> ok i have world coords to texture coords working
02:09:16 <erus`> hurrah
02:10:22 <edwardk> erus`: gratz!
02:50:24 * Baughn just went from 180s with Parsec to 28s with Attoparsec. Lovely.
02:52:06 <Baughn> Parallel performance still sucks, but this way I don't /need/ it
03:07:27 <jack999> hello there
03:08:55 <Phyx-> hi
03:13:19 <jack999> hii
03:14:44 <edwardk> baughn: nice!
03:16:38 <jack999> x=(28,"hi") in fst x
03:16:48 <erus`> why use json when we have read :)
03:16:53 <jack999> getting error
03:17:19 <jack999> its tryhaskell.org site
03:17:33 <jack999> do anybody c whats wrong
03:18:43 <bxc> > let x=(28,"hi") in fst x
03:18:44 <lambdabot>   28
03:18:56 <jack999> ok, let forgotten
03:19:02 <jack999> thanks
03:19:06 * bxc nods
03:24:20 <Baughn> @tell edwardk On an unrelated note, this is ~10x faster than my handwritten C/Python parser. Which spends most of its time constructing python data structures, sure.
03:24:21 <lambdabot> Consider it noted.
03:43:53 <Phyx-> g
04:15:24 <erus`> @hoogle Num a => a -> Int
04:15:25 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
04:15:25 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
04:15:25 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
04:15:31 <erus`> @hoogle Num a => a -> a
04:15:31 <lambdabot> Prelude abs :: Num a => a -> a
04:15:31 <lambdabot> Prelude negate :: Num a => a -> a
04:15:32 <lambdabot> Prelude signum :: Num a => a -> a
04:24:17 <erus`> anyone wanna help me write an arbitrary-triangles-into-square  packing algorithm :)
04:34:46 <yitz> preflex: seen edwardk
04:34:46 <preflex>  edwardk was last seen on #haskell 1 hour, 20 minutes and 4 seconds ago, saying: baughn: nice!
04:35:38 <yitz> @tell edwardk Could you please add replicate :: Whole n => n -> a -> NonEmpy a ? Thanks.
04:35:38 <lambdabot> Consider it noted.
04:36:30 <yitz> oops. s/NonEmpy/NonEmpty/. oh well, he'll get it.
04:43:44 <yitz> @tell edwardk oh i suppose it should actually be replicate1p
04:43:44 <lambdabot> Consider it noted.
05:25:28 <erus`> can i get the average of points without a divide?
05:29:55 <koala_man> erus`: and without any operations equivalent to a divide?
05:30:09 <erus`> i have all the num operations
05:30:13 <erus`> Num*
05:30:38 <Eliel> erus`: bit shift operations work for doubling and halving if you have those.
05:31:40 <Eliel> but if you can't do even that, you could approach it as a binary search problem.
05:35:15 <_oz> @hoogle Alternative f => f a -> f b -> f (Either a b)
05:35:15 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
05:35:16 <lambdabot> Text.Parsec.Prim runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
05:35:16 <lambdabot> Text.Parsec.Prim runPT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a)
05:35:50 <_oz> Is there a library function with the above type?
05:37:07 <statusfailed> What's the "squiggly arrow" operator in this page? http://slawekk.wordpress.com/2009/05/31/probability-monad/
05:37:20 <statusfailed> P -squiggle-> f
05:38:16 <_oz> I find myself typing this often: Left <$> a <|> Right <$> b
05:38:55 <hpc> statusfailed: http://s0.wp.com/latex.php?latex=%28P+%5Cleadsto+f%29%28b%29+%3D+%5Csum_%7Ba%5Cin+A%7D+P%28a%29%5Ccdot+%28f%28a%29%29%28b%29&bg=ffffff&fg=333333&s=0
05:38:56 <statusfailed> oh, it says it's a bit like >>=
05:39:04 <statusfailed> interesting
05:39:04 <hpc> statusfailed: ^ is the definition of the function
05:39:05 <Botje> statusfailed: the type is exactly like >>=
05:39:19 <statusfailed> oh!
05:39:27 <statusfailed> right
05:39:31 <statusfailed> haha
05:39:48 <statusfailed> I just got to the arrow and decided I needed to look it up :D
05:40:08 <statusfailed> This library is cool
05:42:23 <hpc> :t liftA2 either
05:42:24 <lambdabot> forall a c b (f :: * -> *). (Applicative f) => f (a -> c) -> f (b -> c) -> f (Either a b -> c)
05:44:41 <hpc> _oz: it looks like you are generalizing on optional: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#optional
05:45:02 <hpc> _oz: it doesn't look like there's a function like what you want
05:45:38 <_oz> hpc: thanks. I'll just put it in my Utils.hs
05:46:00 <_oz> hpc: what do you think of <||> as the name?
05:46:55 <hpc> that works
05:48:42 <geheimdienst> _oz: is that a parsec thing?
05:48:58 <geheimdienst> (or other parsec-like thingy for parsing)
05:49:15 <HaskellElephant> I haven't done a survey or anything, but there is a general agreement that haskell beginners should pick up haskell platform now right?
05:49:40 <_oz> geheimdienst: currently yes for parsing. but i'll use it for pretty-printing as well at the least.
05:50:20 <hpc> HaskellElephant: on windows, definitely; on mac, no idea; on linux, it's a toss-up
05:50:37 <hpc> HaskellElephant: you can go with the platform from the website, or get the platform through your package manager
05:50:46 <hpc> HaskellElephant: or install ghc and libs separately
05:51:21 <geheimdienst> _oz: teh hoogl finds this http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Perm.html#v:-60--124--124--62- ... may or may not be relevant :)
05:51:33 <HaskellElephant> Yea, I just think that there still is some missinformation about hugs beeing a good system to install for beginners.
05:51:44 <HaskellElephant> Something that was the case quite some years ago...
05:51:55 <hpc> hugs is ancient, at this point; you should go with ghc
05:52:26 <hpc> you will be able to learn more, and more people here know how to help if things go wrong
05:53:34 <_oz> geheimdienst: not really. thanks anyway.
05:53:51 <HaskellElephant> hpc: Yea, I just have seen some beginners still picking up hugs. My university is using a book that recommends hugs.
05:53:53 <geheimdienst> _oz: i meant if you're looking for name clashes or something :)
05:54:46 <HaskellElephant> hpc: and I saw a beginner Haskell question on Stackoverflow where the problem basicly was that that he was using hugs...
06:01:57 <statusfailed> Is it possible to sample from the probability monad?
06:08:02 <yitz> @tell edwardk never mind, this is getting too long. see my email. thanks!
06:08:02 <lambdabot> Consider it noted.
06:10:12 <yitz> hpc, HaskellElephant: on mac, get the platform. macports used to have good support, but not anymore. people are working on homebrew but i don't think it's ready yet.
06:11:07 <yitz> mzero is doing a fantastic job with the platform installer for the mac. i think it's better than on any other os.
06:12:24 <Nimatek> Is it better than "pacman -S haskell-platform" ?
06:12:40 <wlangstroth> brew install haskell-platform worked fine for me (Snow Leopard)
06:13:55 <luite> ./configure --prefix=/Users/luite/haskell/ghc --with-iconv-includes=/opt/local/include --with-iconv-libraries=/opt/local/lib && make -j9 && make install   worked find here ;p
06:43:31 * hackagebot th-extras 0.0.0.1 - A grab bag of useful functions for use with Template Haskell  http://hackage.haskell.org/package/th-extras-0.0.0.1 (JamesCook)
06:43:33 * hackagebot flexible-defaults 0.0.0.3 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.0.3 (JamesCook)
06:44:42 <srhb> Hi, I've just started with Haskell and I have a couple of issues. The error messages are still a bit hard to decipher, so I thought I'd ask here: How do I read arguments from command line and convert them to integers that I can do calculations on? I tried read (getArgs !! 0) :: Int bu failed horribly. :-)
06:45:27 <Botje> getArgs is an IO action
06:45:29 <sipa> :t getArgs
06:45:30 <lambdabot> Not in scope: `getArgs'
06:45:41 <yitz> @hoogle getArgs
06:45:41 <lambdabot> System.Environment getArgs :: IO [String]
06:45:41 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
06:45:46 <donri> :t System.Environment.getArgs
06:45:47 <lambdabot> IO [String]
06:46:13 <srhb> Which is exactly what the error message tells me, too.
06:46:40 <Botje> why do you want to work with commandline arguments?
06:46:43 <yitz> srhb: so in your main function, do args <- getArgs, then use args the way you want
06:47:05 <yitz> Botje: why not?
06:47:19 <Botje> messing around in ghci is easier :)
06:47:48 <yitz> Botje: not if what you want is a command that can be used in a shell script with other programs
06:48:20 <Botje> agred.
06:48:22 <Botje> *agreed
06:48:25 <yitz> Botje: but yeah, for just learning haskell, or just computing something, definitely
06:48:35 * hackagebot random-source 0.3.0.2 - Generic basis for random number generators  http://hackage.haskell.org/package/random-source-0.3.0.2 (JamesCook)
06:48:47 <srhb>  This too gives me an error: args   <- getArgs
06:48:47 <srhb>   length <- args !! 0, it says that args expected [IO t0] but got [String]
06:49:11 <yitz> Botje: and even more so in the next version of ghc when we'll be able to define data types in ghci. yay!
06:49:16 <donri> fmap (map read) getArgs --?
06:49:51 <yitz> srhb: no once you've go args, it's a pure value, just use it in pure functions without the <- stuff.
06:50:11 <srhb> Ah, I guess my confusion is over the do-notation them/
06:50:13 <srhb> then*
06:50:38 <yitz> srhb: you should do a tutorial to get the basics of how that stuff works.
06:50:38 <hpaste> blankverse pasted “settings.yml” at http://hpaste.org/54051
06:51:01 <srhb> yitz: I did, but obviously I did not understand what was going on with the <- arrows
06:51:06 <srhb> Thank you
06:51:10 <donri> do args <- getArgs; callSomethingWith (read (args !! 0))
06:51:12 <yitz> srhb: have you seen LYAH? or tryhaskell.org?
06:51:19 <srhb> The latter, yes.
06:51:21 <yitz> @where lyah
06:51:21 <lambdabot> http://www.learnyouahaskell.com/
06:51:24 <srhb> Oh, learn you a haskell, that too.
06:51:41 <srhb> I skimmed that, however. Wanted to dive in, but got a little too deep. :)
06:51:47 <yitz> srhb: ok. good. keep it up then, you'll pick it up quickly. :)
06:52:05 <yitz> srhb: yeah go ahead and dive in! play around.
06:55:55 <hpaste> yitz pasted “sample haskell program for srhb” at http://hpaste.org/54052
06:56:46 <srhb> Oh so by using print I avoid having to use read to get back to String?
06:57:01 <yitz> srhb: you don't avoid read. you avoid show.
06:57:09 <srhb> Hmm.
06:57:11 <hpc> @src print
06:57:11 <lambdabot> print x = putStrLn (show x)
06:57:14 <yitz> @type show
06:57:15 <lambdabot> forall a. (Show a) => a -> String
06:57:16 <srhb> Aha!
06:57:16 <srhb> Yes
06:57:17 <srhb> Thanks
06:58:29 <srhb> How does read know to convert them to ints? I had this:
06:58:29 <srhb>     w:h = map read args :: [Int]
06:58:47 <yitz> srhb: type inference.
06:58:59 <srhb> So it actually goes further down to check that, and does so by the addition in your example
06:59:07 <yitz> srhb: in this case also defaulting - numeric things default to Integer.
06:59:19 <yitz> or Double
07:00:17 <milo_> Hi everybody. I messed up my packages (ghc-pkg check gives me an impressive list). but instead trying to fix it, I would like to rebuild the entire plattform. can somebody give me a hint how to do this in a clean manner. couldn't find anything so far
07:04:19 <geheimdienst> milo_: i'm fairly sure what most people do is renaming ~/.ghc to something else. that's where all the compiled packages live. after reinstalling, if everything works, you can remove the old directory
07:04:42 <geheimdienst> (be careful, of course)
07:06:26 <milo_> geheimdienst: ok, that looks fairly straightforward. thanks
07:07:21 <djanatyn> are there any operators in haskell that are *not* functions?
07:08:00 <hpaste> srhb pasted “Area from command line width, height” at http://hpaste.org/54053
07:08:23 <srhb> yitz: Is that an okay way to do the bindings?
07:08:29 <byorgey> djanatyn: no
07:08:33 <srhb> Sorry to pester you, I feel like I just broke through that annoying wall. :-)
07:08:41 <geheimdienst> djanatyn: there's some punctuation which is not a function (such as "::" or "<-" or "="), but you wouldn't normally call those "operators"
07:09:41 <djanatyn> ah, yeah. cool :D
07:12:15 <geheimdienst> djanatyn: when we say operator, we usually mean "infix function", such as (==) or (+). basically it's the same as a function, except it's written between its two arguments (regular functions: before all arguments). "subtract 3 1" vs. "3 + 1"
07:12:25 <yitz> srhb: well, does it work?
07:12:40 <srhb> yitz: It certainly does. :) Thanks.
07:14:50 <donri> well, technically (==) isn't an infix function ;)
07:16:18 <geheimdienst> um, it's a function, and it's infix? from the source: infix  4  ==, /=, <, <=, >=, >
07:16:41 <donri> == is infix, (==) is not. ;)
07:16:56 <geheimdienst> ... oh you mean because of the parens. well *shrug*
07:16:57 <geheimdienst> :)
07:17:52 <donri> i wonder, is `f` typically considered an operator?
07:18:57 <ion> The backticks make it an operator.
07:19:06 <Nimatek> Is it water or H2O? We shall never know.
07:19:28 <donri> most water is more than h2o ;)
07:20:12 <Nimatek> But that's impure water from the Real World.
07:20:23 <donri> IO Water
07:20:49 <donri> nowait, type Water = IO H2O
07:20:58 <Nimatek> Haha.
07:28:48 <troydm> can any1 explain me something
07:28:51 <troydm> Parsec s () a
07:29:03 <troydm> where type Parsec s u = ParsecT s u Identity
07:29:24 <troydm> now as i see Parsec definition takes two types
07:29:34 <solidsnack> troydm: Yes.
07:29:35 <troydm> but Parsec s () a is three types
07:29:43 <troydm> i'm confused
07:29:51 <solidsnack> Maybe ParsecT takes more types than  three.
07:29:52 <zenzike> troydm: have you looked at how many arguments ParsecT takes?
07:30:05 <Botje> you can write "type Parsec s u a = ParsecT s u Identity a" just fine. it's just more typing
07:30:16 <troydm> data ParsecT s u m a
07:30:42 <troydm> Botje: ohh i get it
07:30:45 <zenzike> troydm: so it just means that ParsecT is partially applied in the definition of Parsec
07:31:21 <troydm> ok i get it
07:31:51 <troydm> so to use Parsec i need to apply to it four types anyway
07:32:04 <troydm> but simply last type gets wrapped around Identity
07:32:39 <zenzike> troydm: no, Identity doesn't wrap the last type
07:33:20 <dever> hey all, just wondering if theres a way to make this line a bit neater: http://pastebin.com/J2FeXTg8
07:33:22 <mauke> The paste J2FeXTg8 has been copied to http://hpaste.org/54054
07:35:47 <Botje> troydm: Parsec takes three types. the type definition sets m = Identity in ParsecT
07:36:09 <troydm> Botje: ohh ok
07:37:55 <Botje> dever: use "zipWith (^-^) (tail nfs) nfs" as a second parameter
07:38:48 <Botje> and then you can rewrite nqx' as another zipwith
07:39:22 <dbelange_> Why do astronauts always need a suit?
07:39:25 <chrisdone> jaspervdj: ping
07:39:46 <dbelange_> How come an astronaut doesn't need a suit before entering a space station, but needs one afterwards.
07:39:51 <chrisdone> dbelange_: it creates a good atmosphere
07:41:16 <dbelange_> ??
07:41:50 <koala_man> oh lol
07:43:23 --- mode: ChanServ set +o copumpkin
07:43:26 <copumpkin> not again
07:45:21 <hpaste> Botje annotated “pastebin.com/J2FeXTg8” with “for dever” at http://hpaste.org/54054#a54055
07:45:23 <chrisdone> jaspervdj: it seems that inputList is a good way to receive an arbitrary number of inputs for a form, but I realise I have no way to populate with an existing arbitrary-length set of inputs, i.e. for the U in CRUD :/ maybe we can extend it so that you can provide a list of formlets at creation time
07:45:38 <Botje> dever: without knowing anything more about your various types / operators, that's the best I can come up with
07:46:48 <chrisdone> jaspervdj: (a "default" list)
07:49:53 <dbelange_> I mean, what happens if a space station doesn't use a space suit for its astronauts?
07:50:08 <dever> Botje: sorry was working out the code there. my second zipWith ends up with an emptylist exception - they're not equal in size
07:50:14 <dever> thanks for the help!
07:50:49 <Botje> dever: I don't know about the other cases for nqx', of course.
07:51:09 <Botje> dever: if nqx' does something else when the lengths differ, you can't use zipWith.
07:51:17 <Botje> you can still use zipWith for that nfs thing, though.
07:51:25 <wlangstroth> dbelange_: its ... unsafe?
07:51:32 <wlangstroth> it's*
07:51:35 <dever> aye, figured as much :) i'm just going to use it for nfs, thanks for the help!
07:51:52 <dbelange_> wlangstroth, but the astronauts didn't need a space suit to go there
07:52:17 <dbelange_> Why do they need one now?
07:52:35 <dever> Botje: that actually helps me tidy up a few other functions too, thanks!
07:53:12 <dbelange_> Why not just have no space suits and do away with the binder robot.
07:53:28 <mah_b> dever: maybe you could make it even more pretty using parallel list comprehensions
07:53:33 <wlangstroth> dbelange_: is your comment on the metaphor, or the underlying mechanism?
07:53:38 <bfig> why not naked dbelange_ ?
07:53:46 <chrisdone> copumpkin: needs moar hammers
07:54:52 <dbelange_> wlangstroth: yeah
07:55:33 <dbelange_> wlangstroth: This is worse than Java typecasting
07:55:38 <dbelange_> putting suits on and taking them off
07:55:49 <wlangstroth> sorry all, I didn't know I was feeding the troll
07:55:51 <dbelange_> for no reason other than that the libraries need the suits on
07:56:39 <copumpkin> oh sorry
07:56:48 --- mode: copumpkin set -o copumpkin
07:56:59 --- mode: ChanServ set +q *!*@taurine.csclub.uwaterloo.ca
07:57:10 * copumpkin whistles
07:57:39 <hpaste> mah_b annotated “pastebin.com/J2FeXTg8” with “version with parallel list comprehension” at http://hpaste.org/54054#a54056
07:58:20 <mm_freak> does anyone know a arrow transformer library, which defines something like:  class ArrowMonadic a where type MonadOf a; arrM :: (MonadOf a ~ m, Monad m) => a (m b) b
07:58:23 <mm_freak> ?
07:58:34 * hackagebot HsOpenSSL 0.10.1.2 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.1.2 (MasatakeDaimon)
08:00:29 <Phyx-> hm, it's been a few days now and hackage still hasn't build the haddock for my lib
08:00:37 <Phyx-> no error log either
08:00:38 <Phyx-> weird
08:01:08 <Ferdirand> was this comment about space suits an argument against type erasure ?
08:01:37 <Ferdirand> or against newtype constructors/matching ?
08:01:41 * Ferdirand confused
08:02:06 <hiptobecubic> Is there a haskell community endorsed formatting style? like PEP 8 in python, if you will. 'always expand tabs to spaces. don't put spaces here. put spaces there. don't use parens for these patterns. use tabwidth=4 instead of 8.." etc
08:02:58 <wlangstroth> hiptobecubic: there's one the Snap guys use, but it's by no means universal
08:03:29 <Saizan> "expand tabs to spaces" is pretty universal
08:03:34 * hackagebot network-bitcoin 0.1.3 - Interface with Bitcoin RPC  http://hackage.haskell.org/package/network-bitcoin-0.1.3 (MichaelHendricks)
08:03:39 <hiptobecubic> sure, it was just an example
08:04:19 <wlangstroth> https://github.com/snapframework/snap-core/blob/master/style-guide.md
08:04:32 <wlangstroth> (only as an example)
08:05:21 <chrisdone> mightybyte: ping
08:05:40 <mightybyte> hiptobecubic: It's prettier here: http://snapframework.com/docs/style-guide
08:05:44 <mightybyte> chrisdone: pong
08:05:58 <dever> mah_b: maybe i could, it's an idea anyway
08:06:07 <dever> think i need to solve my memory issues first ;)
08:06:08 <hiptobecubic> mightybyte, yeah found it thanks.
08:06:30 <chrisdone> mightybyte: hi :) was wondering, i see you've done some stuff with digestive-funcotrs and blaze, did you encounter/solve the problem of prepopulating and inputList?
08:06:39 <chrisdone> s/and/an
08:07:00 <jaspervdj> chrisdone: sounds like a reasonable request
08:07:09 <mightybyte> chrisdone: Hmmm, it's been awhile...
08:07:32 <mightybyte> It seems like I remember allowing for that.
08:07:47 <geheimdienst> "((,) e) represents a container which holds an “annotation” of type e along with the actual value it holds." <- i thought it was just a tuple? anyone got any ideas on this?
08:08:01 <geheimdienst> (the quote is talking about the Functor instance for (,) e)
08:09:32 <mightybyte> chrisdone: That's the whole point of the Formlet type.
08:09:40 <chrisdone> jaspervdj: ah you're here :) i'm not sure how it would interact/confuse the `defaults` parameter of the formlet. would it make sense to keep or remove it?
08:09:56 <mightybyte> @hoogle Formlet
08:09:57 <lambdabot> package formlets
08:09:57 <lambdabot> package formlets-hsp
08:09:57 <lambdabot> package named-formlet
08:10:18 <mightybyte> type Formlet m i e v a = Maybe a -> Form m i e v a
08:10:40 <simon> geheimdienst, I think that has to do with fmapping on a 2-tuple leaves one value alone.
08:10:41 <mightybyte> chrisdone: That "Maybe a" is the prepopulated default.
08:11:18 <simon> geheimdienst, i.e. one value in a 2-tuple is just an annotation and the other is the one that's being transformed with fmap.
08:12:16 <chrisdone> mightybyte: that's true, I considered that, but it's not used to generate the form
08:12:36 <mightybyte> It's not?
08:13:12 <chrisdone> mightybyte: at least, afaict. i put in (Just [somethingPopulated]) and it outputs a single formlet that's empty. maybe i'm using it wrongly
08:13:17 <mightybyte> That was a prominent part of my use case.
08:13:45 <chrisdone> hmm. looking at the source it looks like it does zipWith the defaults and the formlet
08:13:57 <chrisdone> tch
08:14:06 <geheimdienst> simon: yeah, fmap only twiddles the right half, not the left ...
08:15:26 <mightybyte> I never actually ended up using that code in production, so there could be issues.
08:15:32 <chrisdone> jaspervdj: mightybyte: ah, yep, you're right. sorry about that
08:16:39 <chrisdone> I'm new to this API so I tripped myself up a bit
08:16:57 <mightybyte> Yeah, that's easy to do.
08:17:14 <mightybyte> inputList is seriously nontrivial
08:22:31 <bfig> copumpkin is it regluar david belanger behaviour to do that?
08:29:03 <roconnor_> wow, my C skills are rusty.
08:29:25 <roconnor_> you forget one return statement, and it compiles fine but segfaults
08:29:48 <ion> With -Werror -Wall?
08:29:57 <roconnor_> probably not :(
08:30:03 <mux> also add -W
08:30:03 <roconnor_> I just did make
08:30:14 <mux> it enables a lot more than -Wall
08:31:06 <ion> It seems -W is called -Wextra nowadays.
08:31:44 <mux> yeah but -W still works as far as I can tell
08:31:53 <ion> Sure
08:38:45 <hpaste> chrisdone pasted “formlets” at http://hpaste.org/54058
08:39:05 <chrisdone> damn, mightybyte left
08:39:29 <_oz> ion: I just tried Wextra with ghc-7.2.1: "ghc: unrecognised flags: -Wextra"
08:40:12 <dylex> _oz: they were talking about C, presumably gcc
08:40:19 <_oz> dylex: oops :)
08:41:08 <_oz> didn't read all of it, and was surprised to see a new flag. thanks.
08:49:24 <geheimdienst> "fmap takes two parameters, a function and a container, and applies the function “inside” the container, producing a new container." wouldn't it be a bit clearer to say it produces the same container with new stuff in it? fmap modifies the contents, not the container
08:49:24 <geheimdienst> (except in pathological cases. "modifies" in the immutable sense, "replace with a new one")
08:50:16 <c_wraith> geheimdienst: only if you were already very comfortable with immutability
08:51:01 <hpc> geheimdienst: "produces a new container with the structure of the old one"?
08:51:03 <d-snp> I don't get it, I get the error last statement must be an expression here: http://pastie.org/2867976
08:51:18 <d-snp> isn't that last statement an expression?
08:51:24 <Ferdirand> is it true that the structure always stays the same ?
08:51:42 <hpc> d-snp: indentation
08:51:44 <c_wraith> d-snp: too much indentation
08:51:53 <d-snp> eh ohh
08:52:00 <d-snp> shit, I have mixed indentation :S
08:52:03 <chrisdone> fmap takes the apples from the bucket, eats then, and then puts then back in another bucket
08:52:05 <hpc> if you are using tabs...
08:52:06 <geheimdienst> hpc: you wasted a perfectly good opportunity to wave around the word isomorphic ... :)
08:52:09 <d-snp> the pastie kind of gives it away :P
08:52:09 <hpc> don't :P
08:52:14 <chrisdone> List Monad Approved™
08:52:40 <c_wraith> Ferdirand: according to the Functor laws, it should return the same structure.  fmap id = id, and all that.
08:53:21 <Ferdirand> okay, let's consider ordered lists, with an fmap that reorders elements to preserve this property. Does that violate the functor laws ?
08:53:27 <c_wraith> yes
08:53:30 <geheimdienst> c_wraith: yeah ... i guess you don't need to explain immutability. you could say doing fmap on a list won't give you a Maybe, or an Either, or even a list of a different length
08:53:47 <chrisdone> fmap id [1,2,3] == [1,2,3]
08:53:58 <chrisdone> by the law
08:53:59 <Ferdirand> so what are the other functor laws again
08:54:01 <c_wraith> ordered lists can't be valid Functor instances, due to fmap negate
08:54:08 <mm_freak> geheimdienst: i don't think that metaphor is useful at all
08:54:20 <c_wraith> fmap f . fmap g = fmap (f . g)
08:54:33 <geheimdienst> mm_freak: what metaphor, the apple thing?
08:54:39 <mm_freak> the container thing
08:54:40 <c_wraith> and I think another one, that I can't recall at the moment
08:55:23 <geheimdienst> c_wraith: typeclassopedia has only these 2 functor laws
08:55:24 <c_wraith> no, those two are all the laws
08:55:26 <mm_freak> i prefer the computation metaphor…  fmap allows to apply a function to a computation's result
08:55:35 <mm_freak> that's clear
08:55:38 <Ferdirand> so is that one violated by reordering ? i'm not sure I see how
08:56:05 <mm_freak> fmap f c is the same as c with f applied to the result
08:57:30 <c_wraith> I guess there's no reason you couldn't write a Functor instance for an ordered list type.  It just wouldn't be the mechanical instance.  Interesting
08:57:35 <geheimdienst> mm_freak: yeah ... i guess a newbie might then say "oh so fmap is the same as (.)", which it isn't ...
08:57:39 <Ferdirand> but then there's the thing that ordered lists require the content to be in Ord
08:57:54 <c_wraith> Oh, you're right.  there is a reason! :)
08:58:20 <Ferdirand> so maybe when no constraints are allowed you can't actually build a different structure without violating the laws ?
08:58:42 <d-snp> http://pastie.org/2867976 <-- in this it complains that bytes is not defined in lines 9 and 10, isn't this how you do that?
08:58:52 <Ferdirand> @type (.)
08:58:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:59:01 <geheimdienst> Ferdirand: yeah, your Functor instance might make the ordered list not be ordered anymore. apart from that caveat, i guess you could.
08:59:48 <c_wraith> geheimdienst: well, for a list, you could always re-order it without breaking the functor laws.
09:00:40 <c_wraith> however, given, say, a binary search tree (like Data.Set), it gets more complicated.
09:00:42 <geheimdienst> sure, the functor isn't concerned with the order of the list elements
09:01:00 <copumpkin> c_wraith: no you can't
09:01:09 <geheimdienst> first of all, there's no Functor instance for Set
09:01:20 <c_wraith> right, that's because of the Ord constraint
09:01:29 <c_wraith> there can't be a Functor instance
09:01:43 <d-snp> should I use let instead of where then?
09:02:19 <geheimdienst> yes, er, no. in the pathological sense yes, it'd typecheck, but it'd violate the functor laws, i think
09:02:53 <geheimdienst> similar to the pathological Functor instance that typeclassopedia gives, which duplicates all elements in a list
09:03:03 <copumpkin> c_wraith: fmap id = id is violated by reordering
09:03:29 <c_wraith> copumpkin: not in an ordered list scenario.  because as long as you use a stable re-ordering, that will remain true
09:04:03 <copumpkin> what does stability mean here?
09:04:18 <c_wraith> like a stable sort.  doesn't change the order of equal elements
09:04:28 <copumpkin> so they're equal but distinguishable?
09:04:45 <c_wraith> it happens sometimes.  you have to account for the possibility
09:05:01 <copumpkin> yeah, it just seems a lot more rare around these parts :)
09:05:36 <c_wraith> that's certainly true
09:06:21 <c_wraith> :t (*) <*> sign
09:06:22 <lambdabot> Not in scope: `sign'
09:06:27 <Eduard_Munteanu> Hm, like if you map x to (x , a)?
09:06:30 <c_wraith> hmm.  what is the name of it?
09:06:41 <copumpkin> signum
09:06:43 <c_wraith> ah
09:06:46 <c_wraith> :t (*) <*> signum
09:06:47 <lambdabot> forall a. (Num a) => a -> a
09:06:49 <geheimdienst> i guess that sorting fmap implementation would be okay if you only ever apply it to sorted lists
09:07:06 <c_wraith> that would be a funny operation to apply to a sorted list
09:07:07 <Eduard_Munteanu> (but how do you get different a's just by fmapping then?)
09:07:28 <copumpkin> you can't even write a functor instance for a sorted list
09:07:34 <c_wraith> fortunately
09:07:47 <c_wraith> because otherwise this question would be a lot more practical
09:07:56 <c_wraith> and it doesn't really have a great answer
09:08:12 <geheimdienst> fmap f xs = map f $ sort xs -- giggle giggle
09:08:26 <c_wraith> geheimdienst: that's wrong, of course. :P
09:08:46 <geheimdienst> iz purrfecly purrfect
09:09:01 <c_wraith> except for the fact that it sorts the input, not the output. :)
09:10:09 <geheimdienst> right, also it violates the law "fmap id = id". if you don't change the contents, the evil fmap would still change your container
09:10:27 <c_wraith> yes, it is broken in every way possible!
09:12:51 <c_wraith> > exp 1 * pi
09:12:52 <lambdabot>   8.539734222673566
09:14:49 <d-snp> yay it compiles \o/
09:17:33 <geheimdienst> now to break the second functor law, i guess you could use: instance Functor (Either a) where fmap f (Left x) = Right (f x) ; fmap f (Right x) = Left (f x)
09:17:47 <geheimdienst> with that, "(fmap negate) . (fmap succ) $ Right 3" would be Right -4, but "fmap (negate . succ) $ Right 3" would be Left -4
09:18:26 <ocharles> golf time! Looking for a concise way to normalize a list of Doubles. I have https://gist.github.com/1367709 atm
09:18:40 <ocharles> just wondered if there was any cleverer ways to do it :)
09:19:47 <copumpkin> geheimdienst: you can't write that
09:19:52 <ocharles> Seems like it's going to be difficult to avoid the multiple loops/let clauses
09:20:01 <ocharles> maybe there are cleverer idioms for feedback loops or something
09:20:34 <dylex> ocharles: actually, you can leverage laziness and do it in a single mapAccum, if you want to be fancy
09:21:21 <ocharles> dylex: fancy for the sake of learning is fine by me!
09:21:25 <ocharles> I'll look into mapAccum now
09:25:03 <geheimdienst> ocharles: in general, when you reference a binding only once, you can always just use the bound expression instead. "let scale = (/ max) in map scale l" is the same as "map (/ max) l". if you do that too much, however, it may become unclear; it's a balancing act
09:25:33 <hpc> too many lets can be unclear too
09:26:07 <hpc> because you have to pick the whole thing apart to check for mutual recursion
09:27:05 <ocharles> geheimdienst: mmm, I factored that out so the final map read cleanly
09:27:10 <ocharles> (you could see what each part was doing)
09:39:19 <ocharles> dylex: a single mapAccum you say? this is quite a brainteaser :)
09:39:50 <dylex> > let normalize l = let ((a,b),r) = mapAccumL (\ab x -> ((min x *** max x) ab, (x-a)/(b-a))) (join (,) $ head l) l in r in normalize [2,0,4,1]
09:39:51 <lambdabot>   [0.5,0.0,1.0,0.25]
09:40:47 <ocharles> bah, was hoping to get there my self, but that works too :)
09:40:55 <ocharles> deciphering time
09:41:00 <dylex> i'm sure you can make it even better
09:42:39 <ocharles> :t (***)
09:42:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:42:58 * ocharles pushes learning about arrows up his list
09:43:52 <dylex> it's just shorthand for (min x (fst ab), max x (snd ab)).  There might be a way to take out the x too but I'm not perflectly fluent in arrows either.
09:44:15 <geheimdienst> ocharles: what you really only need is (&&&), which just does two functions on one input, and (***), which is somewhat similar ...
09:44:25 <geheimdienst> > (pred &&& succ) 13
09:44:26 <lambdabot>   (12,14)
09:44:35 <geheimdienst> > (pred *** succ) (13, 17)
09:44:36 <lambdabot>   (12,18)
09:44:50 <ocharles> :t (&&&)
09:44:52 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
09:46:22 <geheimdienst> the types are unclear in that case. you could try to read "a b c" as "b -> c" ... (b -> c) -> (b -> c') -> (b -> (c, c'))"
09:46:43 <geheimdienst> takes two functions with same input, gives you a function that gives a tuple
09:47:09 <ocharles> i'm more puzzled by how that let binding works, and mapAccumL seems to read the let binding :)
09:49:09 <dylex> Is there :: (a b c, a b c) -> a b (c, c)  (or something similar)
09:49:19 <ocharles> Ok, so it finds the minimum and the maximum in the accumulator, this comes out of mapAccum as fst
09:49:31 <ocharles> and snd refers to the final minimum and maximum?
09:49:48 <ocharles> so it actually only does the offset/scaling when we request values, after mapAccum has really ran?
09:50:01 <ocharles> piss poor explanation, but it makes a bit of sense to me
09:50:11 <dylex> ocharles: yeah, you have the right idea
09:50:20 <ocharles> that is very cool, I had no idea you could do that
09:51:24 <kstt> I read on stackoverflow that Control.Concurrent.Chan.dupChan is deprecated, but the doc does not mention that. What do you think ?
09:53:49 <ocharles> :t join
09:53:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:53:56 <ocharles> :info join
09:55:05 <dylex> ocharles: that's just (kind of ugly) shorthand for (head l, head l).  there's probably a better way to avoid it entirely.
09:55:46 <rostayob> @pl \o -> (precedence o >) . precedence
09:55:46 <lambdabot> (. precedence) . (>) . precedence
09:56:30 <ocharles> dylex: is that monad join?
09:57:43 <dylex> ocharles: yeah, using the function (reader) monad.  it's (a -> a -> b) -> (a -> b) here.
09:58:08 <dylex> :t join (*)
09:58:11 <lambdabot> forall a. (Num a) => a -> a
09:58:13 <dylex> > join (*) 5
09:58:14 <lambdabot>   25
09:58:30 <alistra> :t join
09:58:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:58:35 * hackagebot csv-enumerator 0.9.5 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.9.5 (OzgunAtaman)
09:59:12 <ocharles> :t join (*)
09:59:13 <lambdabot> forall a. (Num a) => a -> a
09:59:16 <ocharles> ah.
09:59:53 <ocharles> so, with the reader monad, join f takes an binary function and turns it into a function that applies the function with the same argument twice
10:00:00 <ocharles> (or 'both sides' of the operator)
10:00:20 --- mode: ChanServ set -q *!*@taurine.csclub.uwaterloo.ca
10:00:25 <dylex> ocharles: exactly, by "joining" the two "a ->" monads.
10:01:48 <dylex> ocharles: (infinity, -infinity) might make more sense.  in pratice this is kind of an ugly implementation, but it's a neat trick.
10:01:58 <ion> ocharles: http://heh.fi/haskell/functors/#function-instance
10:02:28 <ocharles> dylex: or minBound maxBound
10:02:50 <ocharles> ion: sweet, bookmarked
10:02:55 <ocharles> and tagged as to read :)
10:03:02 <dylex> ocharles: even better, though there's no Bounded Double
10:03:33 <ocharles> I'm just taking a work break by rewriting http://news.ycombinator.com/item?id=3237819
10:04:09 <ion> Double certainly has a maximum value. :-) Too bad you’ll have to decide whether you want an infinity or not.
10:05:02 <ion> https://gist.github.com/1188115
10:11:09 <ocharles> From https://github.com/Mgccl/mgccl-haskell/blob/master/random/spark.hs to https://gist.github.com/1367865
10:11:10 <ocharles> mwahaha
10:17:11 <geheimdienst> suppose i have a class C, with perhaps an instance C Maybe. how do i import C and hide C Maybe?
10:17:32 <edwardk> ion: as infinity compares as greater than the maximum representable double i suppose infinity would win ;)
10:17:33 <lambdabot> edwardk: You have 4 new messages. '/msg lambdabot @messages' to read them.
10:17:36 <mike-burns> You can't hide instances.
10:17:40 <edwardk> ack i'm popular
10:18:25 <ocharles> geheimdienst: if you want a new instance of C for Maybe, you'll have to use a newtype
10:18:36 <geheimdienst> hm okay
10:18:38 <geheimdienst> thanks
10:19:04 <mike-burns> If you're in charge of it, you can split them into separate files.
10:21:27 <sanjoyd> What does data (:->:) a :: * -> * mean?  I get that * -> * is the kind of something, but the kind of what exactly escapes me.
10:22:15 <rwbarton> the kind of (:->:) a is * -> *
10:22:29 <rwbarton> so the kind of (:->:) is most likely * -> * -> *
10:23:15 <rwbarton> (the kind of the parameter 'a' will be inferred from the definition of (:->:), defaulting to * if it is unconstrained)
10:23:23 <sanjoyd> rwbarton: okay, makes sense.
10:29:15 <Veinor> in parsec, how can i create a parser that accepts a token that satisfies a certain predicate?
10:30:52 <geheimdienst> so is category-extras deprecated now? if you try to cabal install it today, it doesn't even build, and the newest version where hackage says "built successfully" is 3.5 years old ...
10:31:34 <byorgey> geheimdienst: yes
10:32:34 <ocharles> Veinor: there is the satisfy function to take a character that satifies a condition, but I don't think that's what you want
10:32:35 <ocharles> right?
10:32:50 <Veinor> ocharles: yeah, i'm parsing a stream of things other than characters
10:33:36 * hackagebot safe 0.3.3 - Library for safe (pattern match free) functions  http://hackage.haskell.org/package/safe-0.3.3 (NeilMitchell)
10:33:40 <hpaste> chrisdone pasted “digestive-functors testcase” at http://hpaste.org/54062
10:33:47 <Veinor> (i'm trying to screenscrape data out of a webpage)
10:34:17 <Veinor> (and my tokens are tagsoup objects, so tags and text)
10:35:16 <hpaste> chrisdone annotated “digestive-functors testcase” with “example invocation” at http://hpaste.org/54062#a54063
10:35:18 <Veinor> either way, it looks like parsec is really meant for parsing strings and similar things
10:36:18 <chrisdone> jaspervdj: do you see something wrong with my use of inputList pasted above? I am having trouble just getting it to take the defaults. expect it to output a list item populated with "foo" "bar" 0
10:37:15 <chrisdone> jaspervdj: it's taken from the example in the digestive-functors package, I just updated addressForm1 to take a default and added testcase
10:38:08 <yitz> edwardk: sorry my fault
10:40:04 <Veinor> maybe i want something other than parsec
10:45:01 <_Mikey> hey guys,
10:45:16 <_Mikey> what would you say is the most common way of representing a matrix in Haskell?
10:45:18 <geheimdienst> just checking: the canonical source for the Pointed class was category-extras and is now the "pointed" package, right? and for Comonad "comonad". otherwise, nothing substantial has changed in these classes, compared to typeclassopedia's description
10:46:49 <rwbarton> _Mikey: probably one of the built-in array types like UArray
10:47:09 <mike-burns> @hoogle matrix
10:47:09 <lambdabot> Graphics.Rendering.OpenGL.GLU.Matrix module Graphics.Rendering.OpenGL.GLU.Matrix
10:47:09 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans class Matrix m
10:47:09 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans matrix :: (Matrix m, MatrixComponent c) => Maybe MatrixMode -> StateVar (m c)
10:47:14 <mike-burns> Meh.
10:47:22 <_Mikey> hmm
10:47:23 <Cale> _Mikey: there are various linear algebra libraries
10:47:41 <Cale> Nothing you could really say is the "main" one.
10:47:43 <rwbarton> though the new package repa is interesting
10:47:53 <_Mikey> ok :)
10:48:03 <_Mikey> I dabble in everything I guess ;)
10:48:29 <_Mikey> UArray first
10:49:00 <_Mikey> I initially was trying to implement it as a list of lists of Types I wanted to store in my matrix
10:49:12 <_Mikey> but.. I'm not sure thats sensible.
10:49:15 <rwbarton> it might be
10:49:40 <illissius> ...somewhat amusingly, C++'s type system doesn't have kind polymorphism either.
10:51:20 <ville> almost had concepts
10:51:29 <Cale> illissius: You're probably aware that ours does now? :)
10:51:45 <illissius> Cale: I am. :)
10:51:50 <Cale> (at least, in future GHC :)
10:51:52 <illissius> or almost does, or something
10:52:02 <Cale> near-future GHC :)
10:52:14 <illissius> it's in a branch, but i'm not sure about the state of its working-or-notness
10:52:57 <illissius> (according to a byorgey comment on reddit it could be in 7.4 but isn't a certainty..)
10:54:07 <_Mikey> can you have a type which links to other values?
10:54:23 <letrec> :t liftIO
10:54:24 <lambdabot>     Ambiguous occurrence `liftIO'
10:54:24 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
10:54:24 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
10:58:19 <Cale> _Mikey: what do you mean by that exactly?
10:58:59 <_Mikey> hmm like
10:59:13 <Cale> _Mikey: Haskell isn't a dependently typed language, so if you want a type whose structure depends on a value, that's not easy (though the type system in GHC is often rich enough to construct type-level versions of the values you're interested in, but it's lots of work)
10:59:49 <_Mikey> data SomeType = SomeType Int OtherIntThatAlreadyExists Bool
11:00:02 <Cale> Er...
11:00:13 <Cale> If OtherIntThatAlreadyExists is a type, then that's fine
11:00:21 <rwbarton> what's the difference between OtherIntThatAlreadyExists and Int?
11:00:29 <_Mikey> hmm
11:00:29 <copumpkin> the name
11:00:35 <_Mikey> lol
11:00:37 <_Mikey> um
11:00:54 <Cale> Do you just want   data SomeType = SomeType Int Int Bool  ?
11:01:03 <rwbarton> maybe he wants a "smart constructor"
11:01:04 <_Mikey> technically yes
11:01:05 <_Mikey> but
11:01:28 <rwbarton> anyways I shouldn't speculate
11:01:28 <_Mikey> I want the second int to reference another expression which evaluates to an int
11:01:50 <Cale> _Mikey: that sounds like a value-level assertion about what the second Int is.
11:01:51 <rwbarton> that is what it means when you have an Int field
11:02:05 <hpc> > let another_expression = (5 + 6) / 2 * 100 in (5, another_expression) -- _Mikey <--
11:02:06 <lambdabot>   (5,550.0)
11:02:19 <Cale> Any Int field is allowed to be an expression, and that expression won't necessarily be evaluated unless it's necessary
11:02:35 <geheimdienst> _Mikey: i think you should give us a little more context. maybe paste some code to hpaste
11:02:35 <_Mikey> hmm
11:02:36 <Cale> (actually, not just any Int field, but any field at all, pretty much)
11:02:37 <geheimdienst> @where hpaste
11:02:38 <lambdabot> http://hpaste.org/
11:02:52 <_Mikey> hmm
11:02:53 <hpc> > let another_expression = undefined in fst (5, another_expression) -- _Mikey <--
11:02:54 <lambdabot>   5
11:03:03 <_Mikey> I'll go for more context as I'm lacking in code
11:03:35 <_Mikey> I'm doing a project to simulate ants moving around a grid based world in parrallel.
11:03:39 <_Mikey> hopefully.
11:04:13 <_Mikey> and I'm trying to figure out how to represent the world in a haskell datastructure
11:04:34 <_Mikey> I'm trying to see how I can define a type t
11:04:48 <_Mikey> ok
11:04:52 <_Mikey> a type square
11:05:14 <_Mikey> which knows which squares it is touching.
11:07:02 <Cale> Well... if you want to be super-implicit about everything, you *could* have  data Square = Sq { hasAnt :: Bool, north :: Square, east :: Square, south :: Square, west :: Square }
11:07:44 <hpc> you would have your work cut out for you getting all of the squares to point at each other though
11:07:52 <_Mikey> ok. that makes sense.
11:08:02 <hpc> i think
11:08:29 <saati> won't that be a problem? i mean if square A has square B to it's west can B hold A in it's east?
11:08:40 <dylex> Maybe you just want a function touching :: Square -> [Square], that can figure out which squares each square is touching, rather than storing them explicitly
11:08:42 <_Mikey> and these would be Maybe Squares as not all squares will have a North for example
11:09:04 <hpc> you could also try a zipper
11:09:43 <_Mikey> on a tree like structure?
11:10:20 <rwbarton> your grid is tree-like?
11:10:22 <_Mikey> saati, I assume so
11:10:38 <_Mikey> no,
11:10:56 <_Mikey> I just thought zippers were used mainly on lists and trees.
11:11:03 <rwbarton> yes
11:11:27 <hpc> _Mikey: you would have nested zippers on a list of lists
11:11:42 <hpc> _Mikey: one zipper that moves through x, another moves through y
11:11:43 <rwbarton> that doesn't really work very well, does it...
11:12:05 <_Mikey> hmm,
11:12:25 <_Mikey> but if the zippers do all the accessing won't that be a nightmare to parallelize?
11:12:26 <Cale> _Mikey: However you probably really just want a Data.Map from (Integer,Integer) to whatever is in the cells
11:12:31 <geheimdienst> _Mikey: i'd have a look at what dylex suggests. haskell really is a functional language, from what i know about your plan, it feels "right" to me to have a function do that, not store things in a data structure
11:13:09 <Cale> _Mikey: because it's really hairy and inefficient to update a loopy structure like this (cycles will look indistinguishable from an infinite tree)
11:13:45 <_Mikey> ok
11:14:00 <_Mikey> I'll take a look at Data.Map
11:14:08 <_Mikey> and zippers on lists.
11:14:24 <hpc> if you use a Map as your grid, you should try IntMap
11:14:26 <troydm> ok, i'm learning and i think i mostly understand everything but i'm getting confused by reading monadic code especilly when there is a lot of litM forM and <* and <*> staff going on
11:14:36 <hpc> it's going to be faster for Int keys
11:14:45 <_Mikey> hpc ok cheers
11:14:50 <troydm> so my question is it really hard to understand programs written in monadic code
11:14:52 <rwbarton> depending on what kind of simulation you are doing you may also just want an Array
11:14:54 <Botje> troydm: that's the common response to seeing monadic code ;)
11:14:54 <troydm> or i'm too dumb
11:15:06 <Botje> troydm: ezyang posted a guide to reading monadic programs earlier this week
11:15:24 <Botje> http://torrents.thepiratebay.org/6817143/Dexter_S06E07_720p_HDTV_X264-DIMENSION_[eztv].6817143.TPB.torrent
11:15:25 <mike-burns> You're not dumb, and they're not really hard. You get used to it.
11:15:27 <Botje> uh
11:15:28 <Botje> >_<
11:15:31 <Cale> troydm: You're just inexperienced. It gets easier.
11:15:31 <troydm> i'm reading Real World Haskell's Monad Transformers
11:15:36 <Botje> http://blog.ezyang.com/2011/11/how-to-read-haskell/
11:15:37 <Botje> this one.
11:15:40 <troydm> and i kind of get whole idea
11:15:45 <Cale> Botje: rofl
11:15:46 <troydm> but i can't read the code
11:15:52 <troydm> it's like  maze
11:15:58 <Cale> (@ paste fail)
11:16:06 <dgpratt> Botje: if you hear helicopters, go to ground!
11:16:54 <troydm> especially i get confused what logic happens when
11:17:03 <Botje> troydm: write some more code first
11:17:07 <troydm> sometimes it's applicative logic like <?> and <*>
11:17:17 <Cale> troydm: Monad transformers are really not super-important. Understand some specific monads first, and maybe try to get a feel for what the monad operations are about in general through examples.
11:17:20 <Botje> troydm: you quickly become used to ping-ponging between body and where/let expressions
11:17:45 <Cale> troydm: But monad transformers are really just a clever trick for defining some monads you might want to use quickly.
11:18:00 <troydm> should i try using Snap and writing some web code?
11:18:06 <Cale> troydm: and even if you're using them, you probably want to hide this fact from the users of your library
11:18:14 <Cale> troydm: maaybe...
11:18:20 <shachaf> troydm: Why would you do that?
11:18:28 <rwbarton> you could but it probably wouldn't teach you much about monad transformers
11:19:04 <Cale> iirc, Snap uses some fancy things which aren't particularly beginner friendly. Try writing a bit of plain old IO code, and maybe pick up something like Parsec
11:19:09 <mike-burns> If it's what you want to do then, yes, do it.
11:19:22 <dhun_233> Saizan, are you active?
11:19:23 <Cale> I don't think I really understood the idea of the monad abstraction until I learned Parsec.
11:19:48 <hpc> troydm: http://hpaste.org/54065 -- here's an example of some plain old IO code that makes a fragment of HTML
11:20:51 <shachaf> Cale: That's why Hutton's _Programming in Haskell_ starts off by defining a parser combinator library. :-)
11:21:01 <shachaf> (And only gets to IO and so on later.)
11:21:01 <troydm> hpc: that kind of code i undestand
11:21:02 <Cale> shachaf: Absolutely, it's a great example
11:21:22 <dhun_233> I am trying to proof that   fmap f = pure f <*> for any applicative functor, two days ago Saizan gave the following hint:
11:21:35 <dhun_233> it's true if the relation you build for F in the statement of the abstraction theorem is equivalent to equality when applied to the identity relation for the argument type
11:22:03 <stepcut> troydm: you might try happstack-lite, http://happstack.blogspot.com/2011/11/ann-happstack-lite-friendly.html
11:22:11 <dhun_233> now I learn in "Theorems for free" about the parametricity theorem
11:22:33 <dhun_233> and I know about building realtions with it.
11:23:10 <dhun_233> My Problem is that F is a type contructor and not a function, so I don't really know how to apply it
11:23:13 <troydm> stepcut: what's happstack lite? another version of happstack or it's just lite introduction?
11:23:45 <dhun_233> but possibly I just don't know that any typeconstructor is also a function
11:23:46 <hpc> troydm: it's happstack with less nasty type signatures and a file that explains how to get started
11:24:16 <hpc> i don't know happstack, but i assume it will be a lot like what i pasted
11:24:20 <hpc> possibly with more line noise
11:24:21 <stepcut> troydm: it is basically a subset of happstack. It actually just re-exports functions from normal Happstack. But with much nicer types and stuff.
11:24:22 <troydm> hpc: ohh i see
11:24:39 <Cale> troydm: as for (<*>), for monads, you can read  f <*> x  as  do fr <- f; xr <- x; return (fr xr). More idiomatically, you'll see things like  f <$> x <*> y <*> z  where x, y, z, are some computations, and f is a function which takes the results of those computations, and produces another computation to be performed.
11:25:19 <stepcut> hpc: yeah. if you use blaze-html, it looks a lot like what you just pasted..
11:25:24 <Cale> So for example...
11:25:44 <hpc> stepcut: yeah, i discovered that within like a week of getting my website live :P
11:25:54 <stepcut> hpc: ;)
11:25:57 <troydm> Cale: yes i'm getting confused trying to figure out which type is when
11:26:18 <troydm> like i know that one the left of <$> there is always (a->b)
11:26:29 <Cale> er, actually, that's not quite right what I just said :)
11:26:31 <stepcut> hpc: blaze-html is definitely the best way of doing that type of templating. Though there are many ways to template.
11:26:31 <troydm> and on right m a that becomes m b
11:26:36 <hpc> stepcut: not sure if i like my way or blaze's better; blaze has that thing with (#) that lets you set attributes on tags, where i would rather not allow such overriding without it being explicit
11:26:46 <Cale> Here f is just a pure function taking the results and combining them somehow
11:27:13 <Cale> So for instance, (++) <$> getLine <*> getLine  will be an action that gets two lines and concatenate them together
11:27:17 <Cale> +s
11:27:18 <hpc> like, blaze would do indent = div # rightMargin (Em 10) -- or something like that
11:27:20 <rotflcopter> hi:)
11:27:47 * stepcut is off to make lemonade
11:27:49 <rotflcopter> i just got a 64MB agp ati 9000 card for linux what is your opinion?
11:28:05 <stepcut> hpc: personally I prefer HSP, but that is definitely not for everyone
11:28:12 <hpc> rotflcopter: as in the GPU has 64MB of memory?
11:28:19 <hpc> rotflcopter: that must be ancient
11:28:36 <shachaf> stepcut: When life gives you monad, make lemonade.
11:28:47 <rotflcopter> well it has 8 samsung memory chips on it
11:29:02 <stepcut> shachaf: hehe. Never heard that one before.
11:29:19 <rotflcopter> ot any integrated vga on a ddr3 board will beat this ?
11:29:35 <rotflcopter> *or
11:31:27 <Cale> rotflcopter: Probably depends, but a lot of motherboards actually have a pretty decent level of graphics hardware built-in these days (powerful, if a little on the flaky side)
11:32:34 <Cale> rotflcopter: The onboard graphics on my dad's motherboard is enough to run Half-Life 2 just fine, for example, though some games just don't work at all.
11:32:48 <rotflcopter> heh
11:33:17 <rotflcopter> yeah i really should put together a ddr3 system now with some amd 2-4 core cpu
11:34:05 <rotflcopter> ddr3 and integrated vga board is dirt cheap compared to previous solutions
11:35:31 <sidlors> hi
11:35:41 <sidlors> guys
11:35:44 <mightybyte> Cale: What fancy unfriendly things does Snap use?
11:36:10 <mike-burns> Fight!
11:36:22 <mightybyte> Heh, I'm genuinely curious.
11:36:34 <edwardk> yitz: hah, no problem
11:36:46 <dhun_233> so what I calculate is that fmap f . pure = pure . f
11:37:06 <Cale> mightybyte: Last I checked, it required some knowledge of Iteratees to use.
11:37:17 <dhun_233> where pure, maybe pure or any other function, having the signature of pure
11:37:29 <mightybyte> Cale: Not at all.
11:37:44 <Saizan> dhun_233: seen this? http://code.haskell.org/~Saizan/Functor.agda
11:37:50 <Cale> mightybyte: I only saw it very early on and might be mis-remembering things.
11:38:07 <mightybyte> Cale: We do expose some of the iteratee stuff to enable more sophisticated use, but it's not required.
11:38:14 <Cale> runSnap :: Snap a -> (ByteString -> IO ()) -> (Int -> IO ()) -> Request -> Iteratee ByteString IO (Request, Response)
11:38:48 <sidlors> ...
11:39:08 <mightybyte> Cale: That's not the common way of using it.
11:39:29 <dhun_233> Saizan, I don't understand anything when I look at it
11:39:46 <chrisdone> mightybyte: do you see anything wrong with this invocation of inputList? http://hpaste.org/54062 I've been fighting all evening, I can't get it to use the defaults given to it :/
11:39:52 <Nimatek> Hm, I wonder why lambdabot doesn't send messages to channels on mibbit.
11:40:01 <Cale> mightybyte: okay :)
11:40:03 <mightybyte> Cale: See for instance http://snapframework.com/docs/tutorials/snap-api
11:40:20 <chrisdone> mightybyte: currently reverse-engineering a local copy of inputList so i can see where it fails to use them >_>
11:41:46 <mightybyte> chrisdone: looking...
11:42:06 <brence> do normal ghc lists use stream fusion?
11:42:35 <cetchmoh> hi there
11:43:54 <nwf> Can I pester somebody with a type-classes-and-existentials woe?
11:44:18 <hpaste> nwf pasted “Unnecessary Ambiguity Warnings?” at http://hpaste.org/54069
11:44:34 <smoge> how can I model music scales and degrees in haskell?
11:44:57 <smoge> I'm trying to do a function like degreesToMidi
11:45:10 <smoge> any idea to get started?
11:45:23 <Cale> mightybyte: Well, it's not at all clear to me from the example whether that will remain beginner-friendly much longer, as I don't understand (or know the types of) a fair amount of the things being used in that code, not actually knowing much about Snap. But I'll take your word for it that it's more beginner friendly than it used to be :)
11:45:28 <EvanR-wo1k> how do i write a parser like this "a b {{c}} d {{e}}" -> [L "a b ", R "c",L " d ",R "e"]
11:45:35 <EvanR-wo1k> L R is Left Right
11:45:59 <mightybyte> Cale: lol, it's always been this friendly
11:46:25 <Cale> mightybyte: I recall seeing lots of horrible explicit use of Iteratee primitives.
11:47:02 <mightybyte> Cale: Required to implement an app, or used in the internals?
11:47:03 <Cale> mightybyte: When Snap was first released, all the examples appeared to require knowledge of Iteratee.
11:47:08 <mightybyte> No
11:47:23 <Cale> Well, who knows what I was looking at then :P
11:47:33 <mightybyte> writeText and writeBS have been around the whole time
11:47:39 <chrisdone> to be fair I never learned what iteratees were and I started using Snap immediately
11:47:49 <Cale> smoge: I would recommend haskore if Henning Thielemann hadn't ruined it.
11:47:49 <chrisdone> yeah, writeText is what I used
11:48:00 <smoge> ok
11:48:15 <smoge> Cale: I'll look at it, but I was considereing this an exercise
11:48:20 <Cale> smoge: Maybe read Hudak's original paper on it :)
11:48:22 <brence> do normal ghc lists use stream fusion? or is it only used in Data.List.Stream?
11:48:24 <Cale> It'll be interesting
11:48:30 <letrec> :t par
11:48:32 <lambdabot> forall a b. a -> b -> b
11:48:53 <Cale> http://cs.yale.edu/c2/index.php/research/project/haskore-music-notation-an-algebra-of-music
11:48:56 <dhun_233> Saizan, I will not understand it soon, and I am not sure if I will learn agda in order to unterstand it
11:49:01 <geheimdienst> ruined? :-o
11:49:12 <chrisdone> haskore = awesome
11:49:26 <hpaste> smoge pasted “degreeToKey” at http://hpaste.org/54070
11:49:37 <smoge> more or less this idea
11:49:58 <smoge> can't find a "funcional" version...
11:50:25 <troydm> ok can any1 explain me what's this
11:50:25 <Saizan> dhun_233: yeah, i understand
11:50:31 <troydm> exists <- liftIO . doesDirectoryExist $ "/home/troydm"
11:50:35 <troydm> ?
11:50:37 <Cale> smoge: All you want to do is say "the nth note of such and such scale is E-flat"?
11:50:45 <Cale> smoge: or something?
11:51:01 <troydm> as i understand <- lifts monad
11:51:12 <troydm> so if i have a <- IO Bool
11:51:13 <smoge> I have to define a "scale", and then the nth index of that scale starting in note N
11:51:17 <troydm> a would be Bool
11:51:28 <troydm> but why is there a reason for liftIO ?
11:51:39 <EvanR-wo1k> :t liftIO
11:51:40 <lambdabot>     Ambiguous occurrence `liftIO'
11:51:40 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
11:51:40 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
11:51:41 <smoge> Im still learning haskell, that's not difficult I know
11:51:49 <EvanR-wo1k> troydm: look at the type of liftIO
11:51:52 <nwf> troydm: So that the type of the action isn't IO _ but (MonadIO m) => m _.
11:52:10 <nwf> troydm: i.e. so that you can use a stack of transformers (e.g. StateT) over IO.
11:52:13 <incluye> so it lifts the result of your IO action into your monad
11:52:34 <troydm> nwf: ohhhh
11:52:37 <troydm> nwf: i see
11:52:44 <Cale> troydm: v <- x means "run the action x and call its result v"
11:52:48 <chrisdone> mightybyte: no idea?
11:52:52 <troydm> nwf: i see, so basicly to use transformer i need monad
11:52:55 <Cale> troydm: So if x :: IO a, then v :: a
11:53:03 <nwf> liftIO is a specialization of "lift" that "lifts all the way to IO" even if you have a stack of transformers.
11:53:08 <mightybyte> chrisdone: Still thinking
11:53:11 <troydm> and liftIO transforms my IO mand into simple monad
11:53:52 <nwf> troydm: liftIO :: MonadIO m => IO a -> m a
11:54:08 <Cale> liftIO turns IO actions into actions of a fancier monad than IO
11:54:10 <nwf> So it takes an IO action and moves it into your favorite (probably transformed over IO) monad.
11:54:43 <troydm> yeah i understand
11:54:50 <troydm> but i don't understand why?
11:55:12 <troydm> why? you need to have more fancier monad than IO
11:55:20 <troydm> in transformer ?
11:55:21 <Cale> Well, honestly, a lot of the uses of monad transformers over IO are ones which I consider to be quite spurious and silly.
11:55:37 <chrisdone> mightybyte: it's pretty hard to decompose this function into separate parts to inspect it
11:55:42 <c_wraith> I still don't understand your objection to StateT IO
11:55:43 <Cale> IO has a lot of features already, and it's often not worth building a fancier monad around it.
11:56:00 <c_wraith> Replacing it with ReaderT IO isn't any better...
11:56:02 <nwf> troydm: Well, in the case of xmonad (for example), it wraps IO in a StateT for tracking the state of windows and a ReaderT for tracking the configuration.
11:56:10 <mightybyte> chrisdone: Yeah, it's a complex beast
11:56:12 <Cale> c_wraith: My objection is that needing to liftIO all over the place is not better than an extra IORef parameter most of the time.
11:56:22 <nwf> troydm: The resulting transformed monad is called X, creatively enough, :)
11:56:49 <c_wraith> Cale: there are advantages beyond that...  StateT is intrinsically thread-safe.  the IORef is not.
11:57:12 <Cale> c_wraith: Unless you're also *restricting* your view of IO heavily to a mostly-finite subset of IO (where you'll only very rarely using things outside of that sandbox), it's not worth it.
11:57:26 <mightybyte> chrisdone: I'm thinking it has something to do with how you set up the environment.
11:57:38 <mightybyte> But I can't point to anything concrete right now.
11:57:38 <nwf> Cale, FWIW, the xmonad code is pretty nice and doesn't use liftIO "all over the place" (they call it io, so it's less obtrusive, but even then, it's sort of sparing.)
11:58:03 <EvanR-wo1k> any help on my parser question
11:58:05 <Cale> nwf: and they've built up a whole language of X actions, which is fine
11:58:08 <luite> c_wraith: yeah but the generalized exception handling for all those transformers is rather awkward and counterintuitive
11:58:59 <Cale> nwf: so that you can mostly get away not knowing that you're in a StateT over IO and just regard X as a completely separate thing for the most part.
11:59:10 <Cale> That's fine if you want to do it.
11:59:31 <nwf> Cale: I would just like it noted that it works out pretty well.
11:59:33 <Cale> But it's a lot more involved than just using StateT
11:59:48 <chrisdone> mightybyte: hmm, this environment comes from the example/ dir in blaze. I guess it's correct. if i add an error (show (defaults)) inside inputList, I get: Just [Address {addressLine = "foo", addressCity = "bar", addressPostal = 0}]. so the function is /receiving/ the default, but… not using it somehow
11:59:51 <c_wraith> Well.  You should basically never use StateT and leave it exposed.
11:59:53 <geheimdienst> so uhm, Pointed embiggens Functor, and Applicative embiggens Pointed, with the caveat that in Applicative it's called "pure" while in Pointed it's "point". right?
12:00:03 <Cale> StateT and other monad transformers can be a handy way to define specific monads once you have a library design in mind.
12:00:34 <mightybyte> chrisdone: iirc, the environment supercedes the passed-in default
12:00:49 <mightybyte> ...which is the behavior you would usually expect
12:00:58 <Cale> and there's a place for one-liners involving StateT as well, I think. But there's this medium scale on which StateT can produce code which is uglier than it needs to be.
12:01:26 <luite> does anyone know a library that does that by the way? something like StateT IO that doesn't lose state manipulation side-effects if you use exceptions?
12:01:31 <Cale> Where you have exposed stacks of monad transformers, things get ugly really quickly.
12:01:43 <c_wraith> I agree that the stacks shouldn't be exposed
12:01:45 <chrisdone> mightybyte: sure. so you think because the environment is specified, like a 'submit' has occured, it's ignoring the defaults? i had a hunch something like that, but not sure how to prevent it
12:01:55 <Cale> luite: IO itself? ;)
12:02:13 <mightybyte> chrisdone: Yeah
12:02:29 <luite> Cale: hehe i guess :)
12:02:39 <mightybyte> chrisdone: I'm not sure either, since I've never actually used d-f in production.
12:03:34 <Cale> troydm: So as a beginner, I just recommend you avoid monad transformers altogether in your own code. Learn what you need to about them as you go. StateT isn't really that hard to understand if you understand State, but StateT over IO is a bit of an awkward thing to do most of the time unless you take it really seriously and have a large-scale design in mind.
12:03:37 <mightybyte> luite: Did you see the monad-control discussion in haskell-cafe?
12:03:44 <chrisdone> mightybyte: this will be in production soon :) (http://eudl.eu/)
12:03:52 <Cale> StateT over [] on the other hand can be really fun :)
12:03:52 <luite> Cale: but it's tricky to get thread-local state that way
12:04:43 <luite> mightybyte: hmm, not sure, I might have picked up a few bits
12:04:52 <Cale> luite: I control threads' access rights to bits of state by handing them readIORef/writeIORef pre-applied to specific references.
12:04:56 <troydm> Cale: it's just that i have a huge experience in Java coding and did a lot of programming staff, but learning and understanding haskell seems so complicated
12:05:04 <chrisdone> mightybyte: ahaaaaaaaaaaaaaaaaa
12:05:07 <troydm> with this things when for example
12:05:14 <mightybyte> Cale: Heh, that's funny.  I actually have exactly the opposite opinion.  I've even been thinking about writing a monad tutorial that introduces transformers immediately.
12:05:15 <troydm> i need to do some program
12:05:24 <chrisdone> forms = zipWith ($) fs $ maybe (maybe [Nothing] (map Just) defaults)  (flip replicate Nothing)  countFromForm
12:05:33 <troydm> imagining how to structure and write the program
12:05:40 <Cale> troydm: yep. It took me about 2 months to get to the point that I felt like I could really put Haskell to use and about a year to feel really comfortable. It's different, but I think it's quite worthwhile :)
12:05:49 <troydm> even if it's in functional way
12:05:59 <chrisdone> mightybyte: so i replaced countFromForm with Nothing and sure enough, the defaults work. so i just need to stop the countFromForm being populated. it's what we thought, but now i have a lead :)
12:06:00 <troydm> in lisp for example
12:06:02 <Cale> troydm: Here's something that may help.
12:06:03 <troydm> i can
12:06:11 <Cale> troydm: Are you familiar with Model/View/Controller?
12:06:20 <troydm> Cale: yes, offcourse
12:06:34 <mightybyte> Cale: In my own Haskell odyssey I did essentially what you recommended, but things didn't really start to take off for me until I actually learned transformers.
12:06:39 <chrisdone> i use monads for MVC (actually, my View consists only of pure functions)
12:07:01 <mightybyte> chrisdone: Ok, good.
12:07:06 <Cale> troydm: Okay, so your Model is really a pure specification of sorts of how your inputs (coming from the Controller) are tied to outputs (going to the View)
12:07:25 <luite> mightybyte: I'm quite unhappy about the transformers+exceptions situation to be honest, but I don't really know how to fix it
12:08:04 <mightybyte> luite: Yeah.  I avoid exceptions whenever I can help it and have managed to not care too much yet.
12:08:06 <Cale> troydm: So implement the Model part of your design as a pure function of some appropriate type (which will be specific to what your program is actually doing). The view and controller translate into stuff which usually involves a bit of IO code in Haskell.
12:08:36 * chrisdone wtf's when he sees functions defined in a Types module
12:09:24 <troydm> Cale: the most hard part is that there is no good description for most of the functions that i find using hoogle
12:09:41 <troydm> Cale: there is only type definition and few words explanation
12:09:41 <Cale> troydm: Well, I'm happy to help :)
12:10:00 <troydm> Cale: thank you
12:10:03 <Cale> troydm: The documentation is often a little sparse because once you get good at reading types, you don't need all that much.
12:10:24 <Cale> (the types often tell you most of what something does, in a lot of well-designed libraries)
12:10:55 <Cale> Of course, in some cases, they're just sparse because people are lazy :P
12:12:55 * chrisdone . o O ( honestly I'm happier with a well-typed undocumented haskell function than a documented lisp function )
12:12:56 <geheimdienst> "no i don't need to write much haddock, i all spelled it out in my unfindable incomprehensibly-titled paper published in the 1887 proceedings of the southeast-slovakian society of barely functional witchcraft"
12:13:39 <luite> after a while you'll immediately know from the type what a function like this does: forall n o b. (Monad n, Monad o) => t n b -> n (t o b)
12:13:43 <geheimdienst> "... that documents some preliminary version of the package, much improved since, of course"
12:14:12 <Cale> luite: t isn't in scope :P
12:14:24 <luite> yeah I know I missed a part of it :(
12:14:28 <geheimdienst> luite: how about "new :: Integral s => l -> [i] -> [sd] -> StackSet i l a s sd"
12:14:35 <Cale> (But probably is a monad transformer :)
12:14:57 <chrisdone_> (stupid webchat client threw a javascript exception)
12:15:13 <ciaranm> clearly if your entire interface isn't defined by the type system then the type system is insufficiently powerful
12:15:40 <geheimdienst> (solution: i stands for tag, l = layout, a = Window, sid = Screen, sd = Screen again)
12:15:46 <geheimdienst> it's all perfectly clear
12:15:49 <geheimdienst> ;)
12:15:58 <luite> f :: Monad m => (Run t -> m α) -> t m α
12:16:01 <luite> Run t = forall n o b. (Monad n, Monad o) => t n b -> n (t o b)
12:16:01 <chrisdone_> i'll take a well-typed undocumented haskell function over a documented untyped lisp function any day
12:16:03 <luite> this is the complete one
12:16:56 <paolino> Monad.Control
12:17:02 <mightybyte> chrisdone_: Amen to that
12:17:57 <luite> yeah our beloved liftControl
12:18:22 <hpaste> chrisdone annotated “digestive-functors testcase” with “viewForm invocation doesn't work either” at http://hpaste.org/54062#a54072
12:18:37 * hackagebot uu-parsinglib 2.7.3 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.3 (DoaitseSwierstra)
12:18:40 * hackagebot epub-tools 1.1.1 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-1.1.1 (DinoMorelli)
12:18:43 <chrisdone_> mightybyte: that result surprises me ^
12:19:24 <chrisdone_> viewForm runs with NoEnvironment
12:19:30 * chrisdone_ . o O ( did this ever work? )
12:21:21 <chrisdone_> awwww, nice. I just hit M-. on getResult in emacs and it took me to the definition in my lib/digestive-functors/… sexy
12:21:26 <chrisdone_> etags ftw
12:21:38 <mightybyte> chrisdone_: It worked when I wrote it.
12:21:54 <chrisdone_> mightybyte: :p
12:22:12 <mightybyte> I'd suggest doing your testing with digestive-functors-snap so you don't have to worry about all the other infrastructure.
12:22:53 <mightybyte> troydm: Here's a great example of how types reduce the need for documentation.
12:22:57 <mightybyte> troydm: http://haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Concurrent-Chan.html#v:readChan
12:23:25 * mike-burns looks, doesn't see it.
12:23:40 <troydm> mightybyte: thx i'll try reading and understanding it ;)
12:23:40 <mightybyte> troydm: A Chan is basically a queue.  Awhile back I was looking at the API and wondering whether readChan blocked or not.
12:23:52 <mightybyte> troydm: Then it suddenly hit me
12:24:16 <mightybyte> troydm: It obviously blocks because that's the only way it can work and still have that type signature.
12:24:31 <luite> mightybyte: except that neither the haddock page nor the type sigs show that isEmptyChan can cause deadlocks
12:24:58 <mike-burns> Ah, the classic "documentation left as an exercise for the reader".
12:25:02 <mike-burns> "The proof is obvious!"
12:25:03 <mike-burns> Etc.
12:25:06 <mightybyte> luite: Well, it can't magically make all your problems go away.
12:25:36 <mike-burns> If only you implement the package then you'd understand how it works.
12:25:50 <luite> I still need to replace some Chan with TChan somewhere... but I'll lose fairness :(
12:25:51 <brence> o normal ghc lists use stream fusion? or is it only used in Data.List.Stream?
12:25:56 <mightybyte> mike-burns: Well, my use of "obviously" above was a poor choice of words.
12:26:06 <troydm> unGetChan seems strange
12:26:42 <MHD> troydm: it is just prepending to the Chan
12:26:46 <Cale> troydm: unGetChan *is* strange
12:26:55 <ciaranm> not as strange as 4Chan
12:26:59 <Cale> It's uncommon to use it
12:27:52 <troydm> i'll try writing a simple example with Chan, and see what happens
12:28:36 <ciaranm> i want a function named 'lift' which automagically works out which lift[AM]n i want and does that. and that works with other things too.
12:29:15 <srhb`> Does anyone know of a so-called "Online Judge" (I only learned the term today) that is suited for Haskell practice?
12:29:22 <mightybyte> The cool thing is that the use of the type variable 'a' there is what really proves to you that readChan has to block.
12:30:09 <EvanR-wo1k> srhb`: overruled
12:30:27 <shachaf> ciaranm: Idiom brackets?
12:30:55 <shachaf> srhb`: What's an online judge?
12:30:59 <Cale> troydm: It should mostly just be newChan/readChan/writeChan
12:31:35 <ciaranm> shachaf: something like that, yeah
12:31:44 <srhb`> shachaf: Apparently they are sites with a range of programming problems with specifications on input output, you paste in your code for a supported language and it runs it through various tests to see if it does work according to specifications.
12:31:50 <EvanR-wo1k> Cale: how about ungetc ;)
12:31:57 <Cale> troydm: It's pretty easy, you make a Chan using c <- newChan before forking your threads, and then either pass c to the thread you forked or pass either (readChan c) or (writeChan c) if you want the thread to only be able to read/write.
12:32:04 <shachaf> srhb`: I don't know about anything like that for Haskell.
12:32:10 <shachaf> srhb`: You should make one!
12:32:15 <geheimdienst> uh, project euler?
12:32:17 <srhb`> shachaf: Totally!
12:32:39 <EvanR-wo1k> srhb`: the type checker?
12:32:56 <troydm> Cale: i'm not familliar with Threading in haskell yet, so i'll just simply write readChan and writeChan only
12:33:36 <Cale> troydm: Sure, though it'll be a bit tricky to do much that's very interesting. I guess it's reasonable to use it as a simple queue.
12:33:56 <srhb`> EvanR-wo1k: I understand the joke, but I do feel they are really nice tools to learn a new language since they expose you to various problems - and the "contesty" feel is a great motivator to compete with friends on good solutions :-)
12:34:09 <chrisdone_> mightybyte: so the problem is that it uses the defaults when the result of the form is an error. if it's OK it doesn't use them
12:34:19 <EvanR-wo1k> srhb`: youre trying to win a contest using a language you dont know?
12:34:33 <chrisdone_> mightybyte: so i guess your use of it in snap or whatever treats an unsubmitted form as erroneous?
12:34:58 <srhb`> EvanR-wo1k: No. And nevermind. ;)
12:35:00 <mightybyte> chrisdone_: Hmmm, that could easily be an edge case I missed.
12:36:03 <mike-burns> srhb`: tryhaskell.org has a tutorial. That might do an online judge thing, but I don't know.
12:36:33 <mightybyte> chrisdone_: Semantics there aren't obvious.  My main concern was that you don't want someone to go to a lot of trouble inputting a huge list only to submit and have everything disappear because you had an error somewhere.
12:36:36 <srhb`> mike-burns: Thanks, I've seen it and it's a very nice start.
12:36:42 <chrisdone_> mightybyte: it's doing "countFromForm = getResult countRes" and then "maybe <use-the-defaults> <nothing> countFromForm". o, in order to make this right for me i'm not sure what the solution is
12:36:50 <troydm> now given this http://hpaste.org/54075
12:37:02 <troydm> how can i rewrite this testChan function to give me back b value ?
12:37:05 <shachaf> srhb`: What you should do is compete in answering questions of people in this channel.
12:37:18 <mightybyte> chrisdone_: I think jaspervdj touched that line last.  Not sure whether that caused a regression or not.
12:37:29 <shachaf> Your score is the number of seconds it takes you to type a technically correct answer (no matter how useful).
12:37:36 * mike-burns watches people not get it.
12:38:06 <shachaf> mike-burns: Who's not getting what?
12:38:07 <chrisdone_> mightybyte: sure, it definitely makes sense that once the form is submitted, what they submitted should be shown in the result/reply. definitely that makes sense
12:38:13 <ciaranm> technically correct is the best kind of correct
12:39:24 <EvanR-wo1k> technical knock out
12:39:58 <saml> hey, how can I write a parser or state machine?
12:40:16 <EvanR-wo1k> which one
12:40:31 <chrisdone_> so if i grok this properly, it actually /only/ tries to use defaults when there is an error. this is confusing /me fiddles more
12:40:35 <saml> parser.. but state transition is pretty complicated
12:40:41 <ciaranm> technically you could say that 'id' is a parser
12:40:44 <saml> parsec might not be suitable
12:40:50 <ciaranm> or 'const'
12:40:51 <EvanR-wo1k> saml: are you sure you need 'state transition'
12:40:57 <rwbarton> srhb`: Sphere Online Judge (http://www.spoj.pl/) supports Haskell
12:41:06 <saml> i mean...
12:41:16 <saml> that's how i learned. maybe i'm misusing the term
12:41:37 <EvanR-wo1k> saml: if you get to a point in the parsing where you need to 'switch state', it just means you need to use another parser
12:41:47 <saml> there is consumer that consumes character from the tape and it moves head and changse state
12:42:10 <EvanR-wo1k> monadic parsing in haskell hides the mechanics of the moving read head
12:42:19 <saml> yup. so parsec that is
12:42:23 <saml> it changed so much
12:42:34 <EvanR-wo1k> or just :t readS
12:42:36 <EvanR-wo1k> :t readS
12:42:37 <lambdabot> Not in scope: `readS'
12:42:41 <EvanR-wo1k> :(
12:42:46 <chrisdone_> :t reads
12:42:47 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:42:50 <chrisdone_> :i ReadS
12:42:56 <chrisdone_> no :i? :(
12:43:03 <chrisdone_> @info ReadS
12:43:04 <lambdabot> ReadS
12:43:06 <chrisdone_> lol
12:43:14 <EvanR-wo1k> String -> [(a,String)] is a parser
12:43:18 <saml> what does readS do?
12:43:23 <EvanR-wo1k> reads
12:43:28 <paolino> at least she didn't insult
12:43:30 <saml> u craz
12:44:09 <saml> are you talking about Prelude.reads ?
12:44:19 <EvanR-wo1k> yes
12:44:30 <EvanR-wo1k> the type though, not any particular Read instance
12:44:52 <saml> > reads "asd"
12:44:53 <lambdabot>   []
12:45:13 <EvanR-wo1k> > reads "asd" :: [(Char,String)]
12:45:14 <lambdabot>   []
12:45:16 <saml> how do I write my parsers in terms of ReadS ?
12:45:35 <saml> do I implement Read typeclass?
12:45:44 <saml> i mean instantiate Read for my data?
12:45:50 <EvanR-wo1k> you dont have to, thats just an interface you can satisfy
12:46:05 <saml> so, given a  String, I want to parse it into my data
12:46:20 <saml> shouln't I use parsec to do that?
12:46:29 <saml> i haven't seen ReadS
12:46:59 <saml> is there example for reads and ReadS ?
12:47:29 <saml> ReadS is a parser
12:47:36 <EvanR-wo1k> calm down >_<
12:48:04 <EvanR-wo1k> what is the language for your parser
12:48:25 <saml> i want to parse some numbers in String
12:48:34 <EvanR-wo1k> example
12:48:44 <saml> numbers are deliminated by various strings  and numbers follow some rules
12:48:49 <EvanR-wo1k> like
12:48:54 <saml> 1234-3423 4534 -4545
12:49:00 <ciaranm> that last sentence sounds like timecube
12:49:25 <saml> i'll parse those.. and apply my function to see the number meets criteria or not. of it does, yes i found it. else, i move on
12:50:23 <EvanR-wo1k> n1 <- number; hyphen; n2 <- number; space; n3 <- number; etc
12:51:16 <saml> yah that's how parsec gives me
12:54:55 <saml> is there manyMN in parsec? my parser should be only applied from M times to N times
12:55:27 <saml> manyMN 2 4 (return char 'a')
12:55:51 <saml> that accepts   "aa", "aaa", "aaaa" and nothing else
12:56:11 <EvanR-wo1k> replicateM
12:57:05 <saml> i don't think it fits well with parsec
12:57:20 <EvanR-wo1k> uh
12:57:25 <EvanR-wo1k> thats what you asked for
12:57:44 <saml> yah that's what i assumed you will reply with
12:59:09 <EvanR-wo1k> if theres less than 2 it will be a parse error
12:59:23 <EvanR-wo1k> if theres more than 4, you will need to use lookahead to detect that
12:59:39 <EvanR-wo1k> and throw a parse error
12:59:47 <maurer> Say I have two processes, a la forkProcess, is there any reason why they won't manage to write to a TChan? If so, is there any other way for me to do communication between these?
13:00:03 <maurer> (for various reasons, forkIO will not do what I need, they need to be separate processes)
13:00:51 <EvanR-wo1k> or just dont do anything for >4, and ignore the rest of the input
13:01:53 <Saizan> i don't think the RTS survives in the forked process but icbw
13:03:11 <maurer> Saizan: So, I'm trying to do this now, and the TChans are blocking indefinitely, which makes me suspect you are right.
13:03:37 <maurer> I am trying to come up with another solution, because if I do forkIO, some of their resources won't get partitioned right.
13:03:58 <maurer> (THey're wait4ing on children, and if one fo the threads gets the other thread's child, it will explode)
13:05:58 <Saizan> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process.html#v:forkProcess <- plenty of scary warnings
13:06:14 <maurer> Saizan: Yes, which is why I suspected it.
13:06:29 <maurer> But unless haskell has a replacement for ptrace and wait4, I need to fork the process
13:06:35 <EvanR-wo1k> No instance for (Data.String.IsString ByteString)
13:06:39 <EvanR-wo1k> o_O
13:06:49 <maurer> So mostly at this point I'm wondering if there's another comms mechanism
13:07:11 <Saizan> Socket?
13:07:23 <Saizan> EvanR-wo1k: import ....Char8
13:07:43 <EvanR-wo1k> oh
13:07:56 <EvanR-wo1k> also can i get overloaded bytestring strings in ghci
13:10:03 <maurer> Saizan: :( I guess I can.
13:10:16 <maurer> (Mostly :( because that means I need to encode first)
13:22:06 <srhb`> So, I'm truing to read a number of lines from stdin into a list until "something" is entered. I think I'm on the right path, but I got stuck here: test = takeWhile (/= "stop") lines =<< getContents
13:22:28 <srhb`> So I can't do the string comparison because.. I have IO String?
13:23:37 <EvanR-wo1k> you need a takeWhileM
13:23:41 <EvanR-wo1k> so to speak
13:23:43 <EvanR-wo1k> untilM
13:23:46 <parcs> :t fmap (takeWhile (/= "stop") . lines) getContents
13:23:47 <lambdabot> IO [[Char]]
13:24:18 <EvanR-wo1k> ah lazy IO
13:24:30 <EvanR-wo1k> funny business
13:24:54 <srhb`> The whole monadic thing is quite confusing here at first...
13:25:08 <EvanR-wo1k> using getContents probably isnt helping with that, either
13:25:20 <srhb`> I figured out a longer way to do it
13:25:31 <srhb`> But I got stuck on wanting this to work :P
13:26:17 <rwbarton> this sort of thing will always consume the whole file, even after the line "stop"
13:26:28 <ciaranm> well a monad is just a monoid in the category of endofunctors
13:26:34 <ciaranm> so it should be fairly obvious
13:26:51 <rwbarton> I mean, if you wanted to extract two "stop"-delimited lists of lines, you couldn't use fmap (takeWhile (/= "stop") . lines) getContents twice.
13:26:52 <srhb`> ciaranm: Thanks, I feel much better now. Even broke a sweat before you calmed me. :-)
13:27:11 <EvanR-wo1k> lol
13:27:25 <srhb`> rwbarton: but I'm reading from stdIn, so there shouldn't be any more?
13:27:51 <rwbarton> if you only want to run this action once, it will work fine, yeah
13:27:58 <srhb`> Hmm.
13:28:17 <copumpkin> rwbarton: have you signed up for hac boston? :D
13:28:24 <rwbarton> Yes
13:28:28 <copumpkin> sweet
13:28:31 <rwbarton> though I actually won't be able to make it on one of the days
13:28:35 <copumpkin> ah okay
13:28:44 <rwbarton> but I am not sure which day yet, should I adjust my registration when I know for sure?
13:31:15 <EvanR-wo1k> srhb`: doing an IO action until some condition is true happens often enough but with boundary details different enough that you probably want to write your own control flow primitive
13:31:28 <EvanR-wo1k> two lines usually
13:31:52 <EvanR-wo1k> or use explicit recursion, or use fix ;)
13:32:28 <ciaranm> explicit recursion is like goto!
13:32:47 <callen> ciaranm: haha, what.
13:33:16 <EvanR-wo1k> property is theft
13:33:35 <callen> theft cannot exist without property
13:33:42 <callen> property can exist without theft.
13:33:48 <callen> therefore, property is not theft.
13:33:50 <EvanR-wo1k> you totally missed the point!
13:33:55 <callen> you never had one!
13:34:04 <ciaranm> proper tea is expensive
13:34:14 <EvanR-wo1k> no true scotsman
13:34:15 <callen> I prefer Ten-Ren, in Chinatown..
13:36:10 <EvanR-wo1k> look i made a web2.0 template engine http://codepad.org/oAZjef4K
13:41:20 <singpolyma> Is there any way to tell functions like hGetLine to use \r\n instead of \n ?
13:43:06 <EvanR-wo1k> singpolyma: yes
13:44:18 <EvanR-wo1k> hSetNewlineMode
13:48:22 <d-snp> man.. I thought I got how it worked
13:48:22 <d-snp> but now this is throwing me off entirely: http://pastebin.com/YCddAf1E
13:48:22 <mauke> The paste YCddAf1E has been copied to http://hpaste.org/54079
13:48:27 <kstt> I have a server listening on a socket, waiting to accept connections. How to make it release the socket, for gracefull restart ?
13:48:44 <EvanR-wo1k> kstt: you have to set sockopts
13:48:52 <EvanR-wo1k> platform specific
13:48:58 <singpolyma> EvanR-wo1k: thx
13:49:10 <d-snp> anyone know what I'm not getting/doing wrong?
13:49:15 <kstt> EvanR-wo1k: The problem is that the line  '(conn, _) <-  accept sock' is blocking
13:49:32 <EvanR-wo1k> thats not a problem
13:49:53 <kstt> then should an other thread act on the socket ?
13:50:19 <EvanR-wo1k> no, just end the main thread
13:50:44 <kstt> but I don't want to :) I have clients connected (accepted) that can stay as long as they need
13:51:02 <kstt> I just want to release the socket
13:51:14 <EvanR-wo1k> uhm, if they are connected, what does accept have to do with it, and hwo can they stay if you shutdown the server
13:51:15 <kstt> so that a new process can bind to it
13:51:56 <EvanR-wo1k> you can have more control over the sockets by using select, but youre just making it way more complex for nothing
13:52:20 <EvanR-wo1k> might as well use C
13:52:29 <d-snp> nvm, forgot a $
13:52:49 <singpolyma> kstt:   (conn, _) <- accept sock; _ <- forkIO $ somefunc conn
13:53:00 <kstt> graceful restarts is usualy implemented as : 1) immediatly release the listening socket, 2) start a new server accepting new connections, 3) keep existing connections on first server and serve them as needed
13:53:22 <EvanR-wo1k> 3) keep existing connections, how is that a restart
13:53:38 <EvanR-wo1k> doesnt sound very graceful to me
13:54:03 <EvanR-wo1k> if you want to achieve some goal by restarting, but without restarting, then dont worry about restarting
13:54:07 <EvanR-wo1k> and just do the goal separately
13:54:23 <yitz> d-snp: try return $ hostAddress host
13:54:37 <EvanR-wo1k> also i hope the word elegant also doesnt show up
13:55:43 <kstt> mmh, something is misunderstood here.
13:56:34 <kstt> imagine you want to update your server. You first replace the binary, then you tell running instance to release the accepting socket, otherwise your new instance will not be able to bind to it.
13:56:42 <kstt> then you start a new instance
13:56:56 <kstt> for a moment, both instances will run, until clients on first finish
13:57:33 <Veinor> is hackage being unresponsive for anyone else?
13:58:11 <DanBurton> Veinor: trying to load hackage.haskell.org in my browser, it's not loading
13:58:28 <Veinor> not responding to pings either
13:58:44 <DanBurton> yep pings timing out here too
13:58:47 <kstt> yeah, down here too
13:58:51 <yitz> Veinor: http://www.downforeveryoneorjustme.com/hackage.haskell.org: It's not just you! http://hackage.haskell.org looks down from here.
13:59:32 <EvanR-wo1k> kstt: sounds like the server wont work very well
13:59:35 <DanBurton> yitz: time for another lambdabot extension
13:59:49 <EvanR-wo1k> half the clients wont know about the other half
14:00:24 <FNTom> It's just you. http://hackage.haskell.org is up.
14:00:27 <FNTom> According to that site
14:00:38 <FNTom> Works here
14:01:13 <Veinor> just went up for me
14:01:15 <kstt> EvanR-wo1k: that's a graceful restart
14:01:43 <kstt> As implemented by most tcp servers AFAIK
14:01:56 <EvanR-wo1k> kstt: use System.Timeout to periodically see if accept thread needs to stop
14:02:03 <kstt> :)
14:02:41 <DanBurton> yep hackage is back, mystically
14:05:46 <ezyang> Did Mailrank get... acquired by Facebook?
14:06:22 <yitz> DanBurton: indeed, that one comes up all the time.
14:06:54 <wlangstroth> ezyang: where did you see that?
14:07:34 <ezyang> http://blog.mailrank.com/
14:08:24 <singpolyma> Is there any way to catch the Prelude.read: no parse error?
14:08:55 <yitz> ezyang: it looks from there more like they hired bos so he's discontinuing mailrank. but i know no more than you.
14:09:24 <ezyang> Yeah, I have no idea.
14:09:29 <wlangstroth> from what I've heard, Facebook is very generous with its "hiring", so congrats to bos
14:09:32 <ezyang> singpolyma: It's an exception, so you can use Control.Exception to grab it.
14:09:54 <yitz> ezyang: i wonder if they want him to work on their haskell-based php tools.
14:10:01 <singpolyma> ezyang: I tried onException (thing) (handle error), but that didn't seem to work
14:10:36 <ezyang> singpolyma: Did you evaluate inside onException?
14:10:39 <ezyang> Laziness will bite you here.
14:10:45 <singpolyma> oh
14:11:03 <saml> given a decimal number, i want to get [Int].    234 ==>  [2,3,4]
14:11:26 <saml> what should be the name of such function?  splice?
14:11:50 <ezyang> Him... base10rep?
14:12:09 <saml> ezyang, what does rep mean?
14:12:15 <ezyang> Representation
14:12:47 <RaptorRarr> digits
14:13:07 <yitz> > let toRadix b = reverse . map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in toRadix 10 234 --saml
14:13:08 <lambdabot>   [2,3,4]
14:13:16 <ezyang> Oh, radix is the right word, isn't it :^)
14:13:46 <saml> thanks yitz
14:13:52 <yitz> np
14:14:18 <wlangstroth> saml: there's a digits package on hackage, too: http://hackage.haskell.org/package/digits
14:14:31 <singpolyma> ezyang: is there an easy way to force?   onException (processLine h line) (hPutStrLn h "ERROR")
14:14:49 <ezyang> It depends on what kind of data structure you're reading out.
14:15:08 <singpolyma> processLine returns IO ()
14:15:08 <RaptorRarr> > let digits 0 = [0]; digits n = f [] n where f ds 0 = ds; f ds n = f (mod n 10:ds) (div n 10) in map digits [0..20]
14:15:10 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5...
14:17:03 <saml> oh iterate first just puts x
14:17:18 <saml> iterate f x == [x, f x, f (f x), ...]
14:18:00 <rostayob> Oleg's post about Iteratees mentions lazy IO deadlocks. does he mean something like do { h <- hOpen whatever; s <- readHandle h; hClose h; putStrLn h}?
14:18:29 <rostayob> well that wouldn't deadlock
14:18:30 <saml> yitz, your style is so nice.. automatically works for negative numbers
14:18:49 <saml> do you have blog or public source code repo? i want to learn
14:19:35 <rostayob> or does he just mean when we read something lazily from a file and then it gets deleted or something like that?
14:20:00 <yitz> saml: thanks, but i didn't invent that, it's the classic combinator-approach definition of that function. :)
14:20:21 <saml> is that from your memory?
14:20:35 <yitz> yes (because i've used it many times)
14:20:56 <saml> just like memorizing english idioms, do i have to memorize haskell idioms ?
14:20:58 <yitz> i use that pattern for many other things too
14:21:19 <saml> the pattern is  iterate, take, and map, right?
14:21:23 <ciaranm> if you use it three times you should write a paper on it and call it an "Ism" of some kind and give it a weird symbol
14:21:32 <yitz> saml: i don't think you should memorize. you'll remember things you like a lot.
14:21:38 <yitz> ciaranm: there you go!
14:22:00 <ezyang> singpolyma: Oh, then the exception should be triggering
14:22:11 <saml> there's name for it:  itm (iterate, take, map)
14:22:16 <yitz> saml: here's another example:
14:22:41 <saml> i never used iterate freely
14:22:52 <saml> i mean never used iterate
14:22:54 <yitz> > let groupsOf n = map (take n) . takeWhile (not . null) . iterate (drop n) in groupsOf 3 [1..10]
14:22:55 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
14:23:35 <saml> that's real complicated
14:23:49 <saml> oh never mind.. i thought groupsOf was recursiong
14:24:11 <yitz> saml: actually no, it's simple. it's a series of steps. think about each step (or try it separately)
14:26:52 <saml> iterate is so useful with laziness
14:26:57 <singpolyma> ezyang: hmm, ok, with catch it is working.  so onException must not do what I thought
14:27:05 <saml> i'm gonna tweet about this a bunch
14:27:52 <ezyang> Hm. well, that's strange.
14:29:51 <yitz> saml: laziness lets you separte the edge conditions from the body when you write iteration. often those belong in two totally different parts of a system.
14:30:31 <saml> that sounds like..error by typical generalization/abstraction
14:30:56 <yitz> saml: i was careful, i said "often"
14:31:09 <saml> :P
14:31:13 <singpolyma> ezyang: is there a nice way to set the type of the argument for catch?
14:31:37 <saml> that's the pun.. since laziness separates edge conditions
14:31:52 <ezyang> It's not too difficult to write a trivial extra function specialized to the right type.
14:31:57 <ezyang> like, catchReadError...
14:32:09 <DanBurton> challenge - write groupsOf as an unfold
14:32:53 <_Mikey> Hi all
14:35:04 <yitz> DanBurton: yeah it comes out pretty short if you can assume the list is infinite
14:35:24 <saml> is there fast concat (++)  where I don't mind the order being reversed?
14:35:39 <saml> [1,2] ++ [3,4]  ==> [2,1,3,4]  is okay
14:35:54 <Botje> saml: so you basically want a set?
14:36:01 <DanBurton> saml: there's Data.Sequence for fast(er) concat and snoc
14:36:13 <DanBurton> or Data.Set if order doesn't matter at all
14:36:19 <saml> no, i was wondering if there is fast concatenation. not linear one
14:36:35 <DanBurton> there is no fast concatenation of linked lists
14:36:47 <dibblego> saml: you probably want not-a-list if you are wondering this
14:36:49 <copumpkin> concatenation of linked lists is almost free
14:36:56 <alistra> saml: use a tree
14:36:59 <copumpkin> just don't do it more than O(1) times
14:37:12 <DanBurton> "almost free"  meaning O(n)?
14:37:24 <alistra> in a tree you make a new node
14:37:29 <alistra> in O(1)
14:37:38 <alistra> with pointers to 2 subtrees
14:37:40 <copumpkin> DanBurton: yeah, but you don't actually pay much for it
14:37:41 <yitz> there is a very fast concatenation of arrays when you know that they happen to be contiguous in memory
14:37:48 <copumpkin> yitz: zomg
14:38:05 <DanBurton> yitz: xD that's quite an assumption, though
14:38:12 <yitz> oh well
14:38:24 <aristid> sometimes it's a valid assumption
14:38:26 <DanBurton> if you're into that sort of hackery, try C
14:38:32 <alistra> you can allocate a biggerone preemptively
14:39:40 <_Mikey> can you get pointers in Haskell/
14:40:03 <alistra> sure you can
14:40:06 <alistra> probably somehow
14:40:14 <rostayob> @t alloca
14:40:14 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:40:20 <rostayob> :t alloca
14:40:21 <lambdabot> Not in scope: `alloca'
14:40:24 <_Mikey> cool.
14:40:31 <rostayob> @hoogle alloca
14:40:32 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
14:40:32 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:40:32 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
14:40:34 <byorgey> _Mikey: why do you ask?
14:40:52 <DanBurton> but...pointers are so...icky
14:40:56 <alistra> byorgey: why do you ask him why does he ask?
14:41:11 <rostayob> _Mikey: you also have certain kinds of references
14:41:11 <byorgey> alistra: why do you ask me why do I... oh never mind
14:41:16 <_Mikey> byorgey, trying to write a type that links to other types
14:41:20 <alistra> you started it byorgey
14:41:29 <dmwit> _Mikey: Yes, there is Ptr for pointers and IORef for references. Moreover, much pure code can be understood as mutating pointers (at most once).
14:41:30 <yitz> alistra: weren't we just talking about the iterate function?
14:41:42 <byorgey> _Mikey: what do you mean? can you give an example?
14:41:43 <DanBurton> _Mikey: ADTs aren't sufficient?
14:42:16 <_Mikey> byorgey, I mentioned it earlier but I want to make a grid with square types
14:42:29 <byorgey> alistra: seriously, though, I ask because I suspect _Mikey doesn't actually want pointers.
14:42:29 <dmwit> "square types"?
14:42:35 <_Mikey> where each square is linked to the four sqares around it
14:42:46 <_Mikey> square being a type defined by me
14:42:50 <zmv> @protontorpedo
14:42:50 <lambdabot> cmon Im asking cool questions
14:42:55 <zmv> lol
14:42:59 <_Mikey> nice
14:43:01 <byorgey> oh, I see.
14:43:10 <dmwit> _Mikey: Ah. Perhaps you'd be interested in zippers, then.
14:43:18 <alistra> byorgey: yeah, but maybe he does, or maybe the answer is interesting
14:43:20 <zmv> @protontorpedo
14:43:21 <lambdabot> is there a decent scheduler in haskell? how about a netwrok monitor?
14:43:31 <alistra> who are you to judge byorgey
14:43:41 <alistra> everybody knows that haskell is mainly functional
14:43:56 <dmwit> _Mikey: The 10 second explanation of zippers is that they are a finger pointing at a particular place in a data structure. Moving the finger is cheap.
14:43:57 <alistra> @prontorpedo
14:43:58 <lambdabot> and haskell is not a lisp. correct? holy shit then m learning haskell
14:43:58 <_Mikey> so square would be a type holding a type variable and 4 pointers to the surrounding squares
14:43:58 <byorgey> alistra: I wasn't judging. I was soliciting more information in order to help _Mikey better.
14:44:14 <DanBurton> _Mikey, byorgey : zippers?
14:44:23 <_Mikey> but only work in lists right?
14:44:27 <shachaf> DanBurton: Yes, zippers.
14:44:30 <byorgey> dmwit: 2D zippers are... on the level of "open research problem", IIUC.
14:44:33 <dmwit> _Mikey: You can have zippers for other types.
14:44:36 <DanBurton> shachaf: i knew it
14:44:44 <dmwit> byorgey: ...oh =/
14:45:11 <yitz> byorgey: you take the gradient of the type
14:45:44 <byorgey> _Mikey: can you just use a 2D array?
14:46:04 <_Mikey> I could I guess
14:46:16 <zmv> weren't zippers related to zip?
14:46:23 <alistra> i don't think so
14:46:37 <_Mikey> but the next part of the problem is I want to be able to update multiple squares in parallel.
14:46:45 <alistra> is zipper basically 2 stacks?
14:47:39 <_Mikey> as far as I understand using multple zippers would take up too much memory
14:48:17 <alistra> _Mikey: to tailor the data structure to your needs you probably have to provide more info
14:48:19 <_Mikey> and don't think I'd be able to update multiple squares and the different zippers would hold the rest of the list incorrectly.
14:48:20 <alistra> about the usage
14:48:50 * hackagebot type-unary 0.1.7 - Type-level and typed unary natural numbers, vectors, inequality proofs  http://hackage.haskell.org/package/type-unary-0.1.7 (ConalElliott)
14:49:14 <_Mikey> ok
14:49:24 <SgeoN1> Is there a thing to automatically make zippers?
14:49:50 <alistra> like the Text module, import qualified Zippers as Z
14:49:59 <alistra> Z.(++)
14:50:07 <alistra> etc
14:50:13 <saml> should I worry about reverse?  many of my functions have reverse.. and i can see i can eliminate a few couple of reverses.. but function semantics change
14:50:15 <alistra> SgeoN1: actually a good question
14:50:19 <_Mikey> cool.
14:50:59 <alistra> i was imagining a module
14:51:04 <alistra> i don't know if one like that exists
14:51:04 <alistra> :D
14:51:46 <DanBurton> saml: it's usually nice to avoid functions like "reverse" and "length" when possible
14:52:06 <alistra> because they're O(n)
14:52:18 <dibblego> and non-total
14:52:26 <DanBurton> > reverse []
14:52:27 <lambdabot>   []
14:52:27 <alistra> actually reverse has a little more shitstorm in it
14:52:36 <DanBurton> reverse is ok
14:52:42 <dibblego> > reverse [1..]
14:52:42 <DanBurton> as is length
14:52:47 <dibblego> > length [1..]
14:52:50 <alistra> like making many lists in the memory
14:53:04 <alistra> don't know how it's written
14:53:19 <DanBurton> lambdabot...isn't vomiting on those?
14:53:23 <DanBurton> > 2
14:53:25 <lambdabot>   2
14:53:26 <alistra> @src reverse
14:53:26 <dibblego> of course it is
14:53:27 <lambdabot> reverse = foldl (flip (:)) []
14:53:32 <DanBurton> usually it spits out errors
14:53:33 <dibblego> because they are both non-total functions
14:53:37 <lambdabot>   mueval: ExitFailure 1
14:53:37 <lambdabot>  mueval-core: Time limit exceeded
14:53:39 <lambdabot>   thread killed
14:53:46 <DanBurton> there we go
14:54:10 <EvanR-wo1k> > reverse [1..]
14:54:15 <lambdabot>   mueval-core: Time limit exceeded
14:54:20 <_Mikey> aww
14:54:25 <alistra> error "lol"
14:54:26 <_Mikey> poor lamdabot
14:54:27 <alistra> > error "lol"
14:54:30 <lambdabot>   *Exception: lol
14:54:46 <alistra> error "lol" :: IO ()
14:54:53 <alistra> > error "lol" :: IO ()
14:54:57 <lambdabot>   mueval-core: Time limit exceeded
14:55:02 <DanBurton> o_O
14:55:02 <EvanR-wo1k> wuh
14:55:10 <alistra> win?
14:55:11 <alistra> > error "lol" :: IO ()
14:55:13 <lambdabot>   <IO ()>
14:55:15 <DanBurton> @botsnack
14:55:16 <lambdabot> :)
14:55:49 <alistra> > error "lol" :: IO (IO ())
14:55:51 <lambdabot>   <IO (IO ())>
14:55:58 <alistra> > error "lol" :: IO (IO IO())
14:55:59 <lambdabot>   `GHC.Types.IO' is applied to too many type arguments
14:56:01 <yitz> [∞, ∞-1..]
14:56:15 <EvanR-wo1k> lol
14:56:31 <alistra> > error error :: IO (IO (IO()))
14:56:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:56:33 <lambdabot>         against inferred ty...
14:56:37 <alistra> > error error
14:56:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:56:38 <lambdabot>         against inferred ty...
14:58:32 <DanBurton> yitz++
14:59:27 <DanBurton> if it's reverse [1..], then the answer should be [inf, inf-1 .. 1]
14:59:35 <EvanR-wo1k> (reverse [1..]) !! ∞
15:00:07 <alistra> > ∞
15:00:08 <lambdabot>   <no location info>: parse error on input `
15:00:30 <EvanR-wo1k> > let ∞ = (*) in 4 ∞ 9
15:00:32 <lambdabot>   <no location info>: parse error on input `
15:00:43 <EvanR-wo1k> > let (∞) = (*) in 4 ∞ 9
15:00:44 <lambdabot>   36
15:01:27 <alistra> gay
15:01:54 <hpc> alistra: yes; infinity has sex with other infinities of the same sign
15:02:29 <alistra> cardinalisexual
15:03:03 <ziman> what about transfinity? :)
15:03:47 <DanBurton> is there a Haskell instance of Num that includes an "infinity" value?
15:04:07 <hpc> DanBurton: uh... Double?
15:04:12 <hpc> > 1 / 0
15:04:13 <lambdabot>   Infinity
15:04:20 <DanBurton> > :t Infinity
15:04:21 <lambdabot>   <no location info>: parse error on input `:'
15:04:25 <DanBurton> doh
15:04:27 <DanBurton> :t Infinity
15:04:28 <alistra> > (1/0) + (1/0)
15:04:29 <lambdabot> Not in scope: data constructor `Infinity'
15:04:29 <lambdabot>   Infinity
15:04:35 <alistra> > (1/0) + (1/0)
15:04:36 <DanBurton> -_-
15:04:36 <lambdabot>   Infinity
15:04:42 <hpc> it's not a constructor
15:04:46 <alistra> > (1/0) * 0
15:04:47 <lambdabot>   NaN
15:04:51 <DanBurton> that's just what it prints out?
15:04:56 <alistra> > ((1/0) * 0) * 1
15:04:57 <lambdabot>   NaN
15:04:58 <DanBurton> how do you construct infinity without dividing by zero?
15:05:00 <alistra> > ((1/0) * 0) * 0
15:05:01 <lambdabot>   NaN
15:05:05 <alistra> > ((1/0) * 0) * (1/0)
15:05:07 <lambdabot>   NaN
15:05:08 <hpc> > read "Infinity" :: Double
15:05:09 <lambdabot>   Infinity
15:05:25 <hpc> not all Show instances are valid haskell :P
15:05:26 <EvanR-wo1k> lol
15:05:27 <Draconx> > exp 9999999
15:05:29 <lambdabot>   Infinity
15:05:42 <alistra> > unsafeCoerce NaN :: Int
15:05:43 <lambdabot>   Not in scope: `unsafeCoerce'Not in scope: data constructor `NaN'
15:05:45 <EvanR-wo1k> > -1 / 0
15:05:46 <lambdabot>   -Infinity
15:05:49 <SgeoN1> What's the Floating exponentiation?
15:05:51 <DanBurton> @let ∞ = read "Infinity" :: Double
15:05:52 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8734) is outside of bounds (0,255)
15:05:59 <EvanR-wo1k> > 3 ** 4
15:06:00 <lambdabot>   81.0
15:06:10 <_Mikey> 1+1
15:06:19 <SgeoN1> > 1 ** (1/0)
15:06:20 <lambdabot>   1.0
15:06:22 <DanBurton> > ∞
15:06:23 <lambdabot>   <no location info>: parse error on input `
15:06:28 <alistra> ghc should have multiplayer mode
15:06:32 <SgeoN1> Um, that should be wrong
15:06:33 <_Mikey> :o
15:06:35 <_Mikey> totally
15:06:39 <Draconx> SgeoN1, why?
15:06:49 <Draconx> SgeoN1, infinities represent limits.
15:06:53 <SgeoN1> 1^inf is indeterminate
15:07:01 <_Mikey> :t fst
15:07:02 <lambdabot> forall a b. (a, b) -> a
15:07:11 <Draconx> SgeoN1, lim (x -> inf) 1**x = 1.
15:08:02 <alistra> @help
15:08:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:08:04 <EvanR-wo1k> floating point doesnt reflect real math ;)
15:08:08 <alistra> @help list
15:08:09 <lambdabot> list [module|command]
15:08:09 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
15:08:25 <alistra> @help slap
15:08:26 <lambdabot> slap <nick>. Slap someone amusingly.
15:08:33 <alistra> slap lambdabot
15:08:36 <alistra> > slap lambdabot
15:08:37 <lambdabot>   Not in scope: `slap'Not in scope: `lambdabot'
15:08:39 <alistra> @slap lambdabot
15:08:39 * lambdabot smashes a lamp on lambdabot's head
15:08:45 <SgeoN1> lim (x -> 0+) (1-x)**(1/x) == ?
15:09:02 <alistra> @unlambda (\a -> a)
15:09:03 <lambdabot>   unlambda: Unknown operator '('
15:09:09 <alistra> @unlambda \a -> a
15:09:09 <lambdabot>   unlambda: Unknown operator '\\'
15:09:13 <alistra> @unlambda a -> a
15:09:13 <lambdabot>   unlambda: Unknown operator 'a'
15:09:20 <alistra> @help unlambda
15:09:21 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
15:09:23 <SgeoN1> Try Djinn?
15:09:32 <alistra> @help viexen
15:09:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:09:33 <DanBurton> unpl?
15:09:35 <alistra> @help vixen
15:09:36 <hpc> try learning unlambda :P
15:09:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:09:43 <hpc> @help @vixen
15:09:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:09:46 <SgeoN1> Wait, not Dionne.
15:09:49 <SgeoN1> Djinn
15:09:53 <alistra> @vixen
15:09:53 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
15:09:53 <lambdabot> is because most of them are psychiatrists.
15:10:04 <alistra> @vixen
15:10:05 <lambdabot> Your boys will be home for Christmas.
15:10:14 <alistra> @bf
15:10:15 <lambdabot>  Done.
15:10:20 <alistra> @help bf
15:10:21 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
15:10:28 <alistra> @bf
15:10:29 <lambdabot>  Done.
15:10:39 <alistra> @bf  \n
15:10:39 <lambdabot>  Done.
15:10:40 <DanBurton> needs moar lambdabot spam
15:10:59 <alistra> @type id id id id id id id
15:11:01 <lambdabot> forall a. a -> a
15:11:05 <alistra> @type id id id id id id id 0
15:11:07 <lambdabot> forall a. (Num a) => a
15:11:09 <alistra> eh
15:11:28 <alistra> @ghc
15:11:29 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
15:11:35 <DanBurton> you know you can /query lambdabot to avoid flooding #haskell
15:11:40 <alistra> oh
15:11:59 <kakos> lambdabot: Open the pod bay doors.
15:12:07 <SgeoN1> Is lambdabot available for local use?
15:12:14 <DanBurton> @hackage lambdabot
15:12:15 <lambdabot> http://hackage.haskell.org/package/lambdabot
15:12:34 * SgeoN1 is still embarrassed by the thought of needing to be online to figure out monad transformers
15:12:34 <DanBurton> super hard to install
15:12:41 <DanBurton> but there's the package
15:13:07 <_Mikey> :bindings
15:13:14 <alistra> @elite well that's a weird option to have
15:13:15 <lambdabot> WelL 7HAT'z 4 WeIRd OP7IoN tO h4Ve
15:13:41 <SgeoN1> What does lambdabot use logict for?
15:13:56 <alistra> @karma alistra
15:13:56 <lambdabot> You have a karma of 0
15:14:06 <_Mikey> I want karma!
15:14:12 <alistra> @karma+ _Mikey
15:14:13 <lambdabot> _Mikey's karma raised to 1.
15:14:21 <alistra> circlejerk!
15:14:27 <_Mikey> @karma+ alistra
15:14:27 <lambdabot> alistra's karma raised to 1.
15:14:36 <_Mikey> totally
15:14:38 <alistra> @hoogle+ hi
15:14:39 <lambdabot> Foreign.Marshal.Alloc allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
15:14:39 <lambdabot> Foreign.Marshal.Alloc allocaBytesAligned :: Int -> Int -> (Ptr a -> IO b) -> IO b
15:14:39 <lambdabot> package allocated-processor
15:14:54 <DanBurton> does lambdabot karma also take into account the person++ syntax?
15:14:56 <sidlors> how does work lamda function??
15:14:59 <alistra> is hoogle+ to hoogle like google+ to google?
15:15:04 <_Mikey> \
15:15:07 <_Mikey> NO
15:15:15 <_Mikey>  /
15:15:22 <_Mikey> no
15:15:23 <DanBurton> > (\x -> x+1) 1 -- sidlors: like this?
15:15:24 <Nimatek> λ
15:15:24 <lambdabot>   2
15:15:26 <_Mikey> don't listen to me
15:15:34 <_Mikey> what Dan said
15:15:51 <DanBurton> _Mikey: you got it the first time :)
15:16:05 <_Mikey> self doubt.. it cripples me
15:16:14 <DanBurton> lambdabot removes all self doubt
15:16:20 <DanBurton> well most, anyways
15:16:25 <_Mikey> yea :)
15:16:59 <sidlors> oh thnks
15:18:00 <_Mikey> this is totally the wrong place to ask this question I'm sure
15:18:08 <_Mikey> but I'm too lazy to go anywhere else
15:18:18 <_Mikey> does anyone run debian?
15:18:25 <_Mikey> and if so, and also if not..
15:18:28 <DanBurton> nope. no one.
15:18:38 <_Mikey> do they know how to make gedit transparent?
15:18:57 <DanBurton> @google gedit transparency
15:19:00 <lambdabot> http://ubuntuforums.org/showthread.php?t=971425
15:19:01 <lambdabot> Title: [gnome] Gedit Transparency? - Ubuntu Forums
15:19:07 <_Mikey> ubuntu -.-
15:19:13 <DanBurton> @google gedit transparency debian
15:19:15 <lambdabot> http://linux.bigresource.com/Debian-Gedit-gnome-terminal-missing-theme--VcCaOJ565.html
15:19:15 <lambdabot> Title: Debian :: Gedit - Gnome Terminal Missing Theme?
15:19:20 <DanBurton> better? :)
15:19:29 <_Mikey> I'll check
15:19:36 <_Mikey> got a funny feeling I've been there though
15:20:30 <d-snp> woop woop, my sctp stack is beginning to communicate \o/
15:20:34 <d-snp> it's over UDP for now
15:20:38 <_Mikey> no luck
15:20:47 <prototrout> _Mikey: I don't think gedit can be made transparent on its own. You can use a compositing manager (Compiz) to do it though.
15:21:12 <prototrout> (this is based on 20 seconds of googling, not first-hand knowledge)
15:21:26 <_Mikey> I've heard about compiz
15:21:50 <_Mikey> but I've also heard about people getting it natively in gedit on ubuntu
15:22:10 * _Mikey isn't sure natively is the correct word to use there.
15:23:05 <saml> I want to create a monad with various states. how can I do that?
15:23:20 <saml> I want to do   n <- getInt;  putInt n;   s <- getString; ...
15:23:35 <shachaf> Use State with a record containing several things.
15:23:47 <alistra> saml: do you know how many states you want?
15:23:49 <saml> is State monad part of standard?
15:23:57 <alistra> Control.Monad.State
15:26:23 <maurer> Does anyone know how if there are any common pitfalls related to a TChan that can cause space leaks?
15:27:01 <DanBurton> _Mikey: I bet there's a #debian channel that would be more knowledgeable
15:27:12 <DanBurton> maybe even #gedit
15:27:18 <DanBurton> or #gnome
15:29:25 <DanBurton> maurer: with Channels, I think it's pretty hard to space leak unless you're really trying to. For example, writing tons of stuff and never reading.
15:29:46 <saml> is there a tutorial for simple custom parser combinator other than "essense of functinoal programming"  ?
15:29:47 <maurer> DanBurton: So, I think I'm reading it all off
15:30:19 <DanBurton> maurer: when in doubt, hpaste?
15:30:22 <_Mikey> hmm
15:30:33 <maurer> DanBurton: The code is uh, pretty massive
15:30:38 * _Mikey wiggles on over to the #gedit channel
15:30:41 <srhb`> Okay, I've been trying to read a number of lines, using foldM - and it works - but I generalte a list [1..n] for it to fold over and this seems cheasy. Is it the right way to do such a thing?
15:31:14 <DanBurton> maurer: generally the solution to any programming problem is to try to create the smallest possible instance of the problem :)
15:31:18 <shachaf> srhb`: What are you trying to do?
15:31:19 <maurer> DanBurton: (approximately 1.5klines)
15:31:20 <_Mikey> just me chlling alone in the gedit channel ;)
15:31:23 <shachaf> Maybe replicateM does what you want?
15:31:38 <srhb`> shachaf: Maybe it is, I'll have a look. I want to read n lines from stdin.
15:32:03 <maurer> I'm gonna try a bounded channel and see if that helps
15:32:07 <saml> I want to parse credit card numbers  where a credit card number is made of 14, 15, or 16 digits that passes Luhn test.  and between two digits, there can be spaces or dash (-).
15:32:15 <maurer> (if I'm failing to read, it should force me to block so I can debug it)
15:32:15 <shachaf> replciateM 3 getLine :: IO [String] -- gets three lines
15:32:35 <srhb`> shachaf: Was it really that simple. Thank you. :)
15:32:57 <shachaf> srhb`: Assuming you spell replicateM correctly, yes. :-)
15:33:49 <SgeoN1> Suppose I want to do something over a list with index numbers. Is zip [0..] mylistbthe best way to approach it?
15:33:54 <DanBurton> @hoogle Int -> IO a -> IO [a]
15:33:55 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
15:33:55 <lambdabot> Prelude replicate :: Int -> a -> [a]
15:33:56 <lambdabot> Data.List replicate :: Int -> a -> [a]
15:34:18 <DanBurton> srhb`: hoogle is your friend :)
15:34:33 <DanBurton> also hayoo for more exotic searches
15:34:45 <_Mikey> @hoogle Bored
15:34:46 <lambdabot> No results found
15:34:48 <shachaf> SgeoN1: Why not?
15:34:48 <_Mikey> :(
15:35:35 <srhb`> DanBurton: Yes, I get the feeling, but the signatures in Haskell are all new to me (coming from SML) and I'm still working ongetting the intuituin for them :-) What was your logic in that search? "Something" that takes and in and... what? And produces a list of these.
15:35:50 <elliott> SgeoN1: You could also do [... | x <- xs | i <- [0..]]
15:35:50 <srhb`> an int*
15:35:53 <srhb`> not and in.
15:36:21 <shachaf> srhb`: Have you figured out how IO in Haskell works?
15:36:29 <DanBurton> srhb`: So you have an IO action, "IO a". You want to perform it a certain number of times, "Int". The result will therefore be an IO action that produces a list of that given type: "IO [a]"
15:36:31 <shachaf> srhb`: That'll probably help a lot with doing IO in Haskell. :-)
15:36:53 <srhb`> shachaf: In the broadest sense no, but I've read up on it and am now trying to understand it in practice.
15:37:01 <srhb`> DanBurton: Thanks
15:37:35 <DanBurton> LYAH and RWH are highly recommended reads, as well as Typeclassopedia
15:37:42 <Cale> srhb`: my quick intro: http://www.haskell.org/haskellwiki/Introduction_to_IO
15:37:48 <_Mikey> I'm 4 chapters into RWH
15:37:53 <_Mikey> crazy shizz!
15:38:21 <SgeoN1> RWH recommends raw GHC download doesnt it?
15:38:25 <srhb`> DanBurton, Cale: Thanks! I must admit I find the format of RWH hard to read online. LYAH was awesome though.
15:38:48 <DanBurton> srhb`: you could aways get RWH in dead tree format
15:38:54 <elliott> srhb`: (Cale's intro)++
15:38:57 <elliott> (Does lambdabot recognise that?)
15:39:02 <shachaf> elliott: No, but preflex does.
15:39:06 <shachaf> @karma intro)
15:39:07 <lambdabot> intro) has a karma of 1
15:39:08 <_Mikey> dead tree format.. I love this.
15:39:10 <elliott> Thanks preflex.
15:39:13 <shachaf> preflex: karma Cale's intro
15:39:14 <preflex>  Cale's intro: 1
15:39:15 <DanBurton> lol
15:39:21 <srhb`> DanBurton: I'm very much considering it, but student in poverty and all that. :-)
15:39:32 <shachaf> If you're getting a paper book containing an introduction to Haskell, Hutton's _Programming in Haskell_ is good.
15:39:51 <shachaf> Anyway there are plenty of resources online if you're determined enough to find them. :-)
15:40:03 <shachaf> IO in Haskell is essentially a kind of burrito.
15:40:04 <maurer> Hm. Bounded channels solved my space leak
15:40:10 <_Mikey> o.o
15:40:20 <maurer> shachaf: Y U TROLOLOL
15:40:24 <_Mikey> I like the sound of this
15:40:32 <scottj> for basic cli options parsing for newbie, do you reocmmend System.Console.GetOpt?
15:40:33 <elliott> maurer: :(
15:40:43 <maurer> elliott: I know shachaf irl, it's cool.
15:41:00 <DanBurton> the problem with Haskell is that once you start "getting" monads and IO and such, then you forget what was so hard about getting it, which makes it hard to explain to others that don't "get" it yet
15:41:00 <shachaf> maurer: You do?
15:41:03 <elliott> It's never cool. Never :'(
15:41:09 <maurer> shachaf: Yeah, we met last summer.
15:41:26 <maurer> shachaf: Remember, you worked with rntz, and I met you brievely at the haskell meetup thing?
15:41:28 <shachaf> Hmm, I guess we said hi once.
15:41:32 <maurer> *briefly
15:41:34 <_Mikey> I want to hear about this burrito analogy.
15:41:37 <srhb`> DanBurton: I recently said the same thing about OOP. :P
15:41:44 <elliott> _Mikey: http://blog.plover.com/prog/burritos.html
15:41:48 <srhb`> So I'm hoping it will come to me in the same way.
15:41:49 <elliott> Thank me later for ruining your education.
15:41:53 <_Mikey> sweet!
15:42:18 <DanBurton> @where burrito
15:42:19 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:42:38 <DanBurton> @where io
15:42:38 <elliott> DanBurton: False adveritisng; that post doesn't tell you how monads are like burritos at /all/.
15:42:38 <lambdabot> Raphael Finkel's language with continuations as fundamental structure, described in chapter 2 of his book `APLD', implementation `Amalthea'
15:42:49 <DanBurton> elliott: ikr
15:43:25 <shachaf> elliott: We've already determined in #-blah that burritos are a lot more like comonads than like monads.
15:43:48 <shachaf> If you've ever eaten a burrito, you'll know how easy "extract" is to implement, for instance.
15:43:55 * kfish is hungry
15:44:45 <SgeoN1> I think I read that every monad has a comonad, or something?
15:45:04 <SgeoN1> What's the comonad of IO?
15:45:05 <Cale> SgeoN1: no, but every adjunction gives rise to a monad and comonad
15:45:11 <prototrout> "This is true because tortillas are indistinguishable. " Hilarious.
15:45:41 <DanBurton> Cale: reading your IO intro on the wiki, "there is no function unsafe :: IO a -> a"...except of course The Function Which Shall Not Be Named
15:46:00 <_Mikey> wow
15:46:06 <Cale> DanBurton: Well, that function doesn't officially exist
15:46:07 <shachaf> Cale: I like the phrase "gives rise to".
15:46:08 <Cale> ;)
15:46:10 <srhb`> Is this where I eagerly ask for the name?
15:46:11 <elliott> Cale: It's in the Report.
15:46:11 <_Mikey> I will not be able to program monads
15:46:18 <_Mikey> without getting hungry
15:46:19 <shachaf> Cale: Sure it does, in Haskell 2010.
15:46:21 <Cale> elliott: sssshhhhh
15:46:28 <elliott> srhb`: The name is [YOU DO NOT HAVE CLEARANCE TO VIEW THIS TEXT]
15:46:34 <srhb`> sneef.
15:46:45 <DanBurton> The Function Which Shall Not Be Named tends to stick around the shadows and SPJ
15:46:54 <shachaf> That function is called ***************
15:47:04 <prototrout> @hoogle IO a -> a
15:47:04 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
15:47:05 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:47:05 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:47:16 <srhb`> At least they are nicely labelled.
15:47:22 <SgeoN1> @hoogle a -> a -- yes I'm evil for giving a hint how to find functions based on type signatures
15:47:23 <lambdabot> Parse error:
15:47:23 <lambdabot>   a -> a -- yes I'm evil for giving a hint how to find functions based on type signatures
15:47:23 <lambdabot>          ^
15:47:23 * DanBurton gasps at hoogle's audacity
15:47:39 <SgeoN1> Stupid keyboard blocks chat
15:47:41 <srhb`> I think I'll treat "unsafe" as I would "DO NOT PRESS RED BUTTON"
15:47:51 <shachaf> srhb`: Some unsafe functions are safe.
15:48:02 <srhb`> You say that now...
15:48:13 <shachaf> @google "return . unsafePerformIO" reddit
15:48:13 <lambdabot> http://www.reddit.com/r/haskell/comments/jarp0/hi_guys_i_made_a_haskell_to_clojure_translator/
15:48:14 <lambdabot> Title: Hi guys, I made a Haskell to Clojure translator. Check it out :D : haskell
15:48:14 <DanBurton> let definitelyVerySafePerformIO = ...
15:48:16 <SgeoN1> Hoogle doesn't like comments?
15:48:32 <DanBurton> SgeoN1: guess not
15:48:40 <shachaf> @quote unsafeCoerce.*generali
15:48:40 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
15:49:00 <shachaf> safePerformIO :: IO a -> IO a
15:49:09 <shachaf> extraSafePerformIO :: IO a -> IO (IO a)
15:49:32 <DanBurton> that would be more like dontPerformIO
15:49:43 <elliott> shachaf: Oh god, don't remind me of that post.
15:49:50 <shachaf> elliott mad
15:49:59 <elliott> shachaf: It broke my brain :-(
15:50:00 <DanBurton> @google extrasafeperformio
15:50:02 <lambdabot> No Result Found.
15:50:04 <DanBurton> aw
15:50:35 <_Mikey> question..
15:50:37 <shachaf> @let extraSafePerformIO :: IO a -> IO (IO a); extraSafePerformIO = return
15:50:39 <lambdabot>  Defined.
15:50:44 <_Mikey> can anyone upload something to Hoogle?
15:50:44 <shachaf> _Mikey: remark..
15:50:50 <shachaf> To Hoogle?
15:50:50 <Cale> _Mikey: yes
15:50:52 <shachaf> No.
15:51:00 * _Mikey is confused
15:51:03 <shachaf> Hoogle's database is set.
15:51:07 <DanBurton> you can upload to Hackage, which is indexed by Hayoo
15:51:10 <shachaf> Hayoo scans more things, though, I think.
15:51:10 <Cale> shachaf is trolling
15:51:12 <DanBurton> @where hayoo
15:51:13 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:51:13 <shachaf> Cale: What?
15:51:26 <_Mikey> ok
15:51:29 <shachaf> Cale: How can anyone upload something to Hoogle? Is its database public somewhere?
15:51:33 <gio123> Cale: hi
15:51:34 <DanBurton> when is shachaf ever not trolling? :)
15:51:50 <Cale> oh, Hoogle, lol
15:51:54 <Cale> I misread that, sorry
15:51:54 <shachaf> I am not a troll!
15:51:55 <shachaf> @nixon
15:51:56 <lambdabot> I don't know anything that builds the will to win better than competitive sports.
15:51:57 <_Mikey> so if in the future I knock out some kickass algorithm in Haskell
15:52:04 <_Mikey> I can can just throw it up?
15:52:11 <SgeoN1> You.c
15:52:13 <Nimatek> unsafeCallCthulhu
15:52:14 <gio123> Cale: hi
15:52:16 <Cale> _Mikey: You can put stuff on Hackage, and it'll be indexed maybe
15:52:19 <Cale> hi
15:52:29 <SgeoN1> You can, but I think it won't be seen by hoogle. It will be seen by hayoo
15:52:43 <gio123> Cale: minute?
15:52:43 <_Mikey> Ahh
15:52:44 <_Mikey> ok
15:52:57 <alpounet> hayoo searches hackage, doesn't it ?
15:53:00 * shachaf doesn't like how Cale's default assumption is "shachaf is trolling". :-(
15:53:19 <elliott> shachaf: Stop trolling about Cale trolling you with how you are trolling.
15:53:32 <alistra> #meta
15:55:17 <stribor> i am trying to install Gtk2Hs on ubuntu from command line...
16:02:22 <alistra> @google on ubuntu from command line
16:02:25 <lambdabot> https://help.ubuntu.com/community/UsingTheTerminal
16:02:31 <alistra> xD
16:09:21 <stribor> can someone help me with this problem..i installed Gtk2hs using cabal...i am trying to test it with simple program and i am getting following error
16:09:26 <stribor>  Could not find module `Graphics.UI.Gtk.Gdk.Events':       Use -v to see a list of the files searched for.
16:12:59 <Cale> stribor: -package gtk ?
16:13:02 <Cale> stribor: or --make?
16:13:40 <stribor> Cale: -package gtk ? No command '-package' found, did you mean:  Command 'package' from package 'mailagent' (universe) -package: command not found
16:14:15 <Cale> stribor: those were intended as ghc commandline options
16:14:19 <alistra> what is the usual way of handling erroneus opts with getOpt
16:14:19 <stribor> Cale: this is what i did to install it ->cabal update cabal install gtk2hs-buildtools cabal install gtk
16:14:29 <Cale> stribor: sounds right
16:14:33 <alistra> like -c -i flags are mutually exclusive
16:15:09 <stribor> Cale: this is error from ghci command line ->Prelude> -package gtk ?  <interactive>:1:14: parse error (possibly incorrect indentation)
16:15:26 <Cale> stribor: not into ghci either
16:15:35 <Cale> stribor: pass it on the commandline when you run ghci
16:15:43 <Cale> Or :set -package gtk
16:15:46 <Cale> from inside
16:16:22 <stribor> Cale: pass it to command line when run ghci?
16:16:38 <stribor> i start ghci just by typing ghci
16:17:47 <stribor> you mean line this....once oi am on unix command line to do this .....ghci -package gtk ?
16:18:47 <alpounet> yes
16:19:05 <stribor> alpounet: ghci -package gtk ? GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help <command line>: cannot satisfy -package gtk     (use -v for more information)
16:20:02 <Cale> stribor: then gtk didn't get installed
16:20:08 <Cale> stribor: maybe there was some error
16:20:58 <stribor> Cale: i didnt get any errors....can it be that PATH variable needs to be added
16:21:27 <alpounet> nope, 'cause cabal installs packages in places ghc knows about
16:21:36 <alpounet> are you *sure* there wasn't any error ?
16:21:44 <stribor> alpounet:pretty sure
16:21:49 <stribor> should i try to install again
16:21:56 <elliott> stribor: ghc-pkg list | grep gtk
16:22:01 <elliott> does that print anything when you run it from unix?
16:22:43 <stribor> elliott: nothing
16:22:49 <alpounet> stribor, ghci -package somepackagename is perfectly valid, and will only fail if there's something wrong with the installation of the package
16:23:06 <elliott> stribor: ls ~/.cabal/lib/gtk*
16:23:14 <elliott> stribor: if that doesn't print anything, then gtk definitely failed to install.
16:23:18 <elliott> gtk2hs, that i
16:23:18 <elliott> s
16:23:50 <stribor> elliott: bash: /.cabal/lib/gtk*: No such file or directory
16:23:58 <shachaf> elliott: If it doesn't print *anything*, then I'd assume that there exists one empty directory in ~/.cabal/lib/ whose name starts with "gtk".
16:24:01 <elliott> stribor: you forgot the ~
16:24:08 <elliott> shachaf: Good point
16:24:33 <stribor> elliott: i did this -> ls ~/.cabal/lib/gtk*
16:24:52 <elliott> stribor: You didn't put the ~ there, or it'd have printed it in the error.
16:24:53 <stribor> elliott: no such file or directory
16:25:11 <elliott> well, gtk2hs failed to install, anyway.
16:25:18 <shachaf> bash: elliott: No such file or directory
16:25:39 <alpounet> stribor, just "re"-install it and paste us the output
16:25:39 <stribor> elliott: this is what i got in error -> ls: cannot access /home/.../.cabal/lib/gtk*: No such file or directory
16:25:47 <stribor> alpounet: ok
16:25:49 <elliott> Right.
16:27:23 <stribor> alpounet: i did this -> cabal install gtk2hs-buildtools .......Linking dist/build/gtk2hsC2hs/gtk2hsC2hs ... Installing executable(s) in /home/..../.cabal/bin
16:27:31 <stribor> alpounet: ill do next now
16:27:47 <alpounet> looks fine so far indeed
16:28:02 <alpounet> it would have failed before, if this step was the problem
16:28:41 <hpaste> stribor pasted “error” at http://hpaste.org/54085
16:28:52 * hackagebot fixhs 0.1 - FIX (co)parser  http://hackage.haskell.org/package/fixhs-0.1 (ArvinMoezzi)
16:28:52 <stribor> alpounet: i am doing now -> cabal install gtk ....output == error here http://hpaste.org/54085
16:31:21 <Saizan> stribor: cabal install gtk2hs-buildtools first
16:31:38 <stribor> Saizan: i did that before
16:31:43 <stribor> Saizan: i already install that
16:32:06 <Saizan> do you have $HOME/.cabal/bin in your PATH?
16:32:15 <stribor> Saizan: no
16:32:27 <Saizan> you should
16:32:39 <stribor> Saizan: how do i add that...i am new to linux
16:33:51 <Saizan> export PATH=$PATH:$HOME/.cabal/bin/
16:34:11 <stribor> Saizan: ok i did that
16:34:37 <ybit> hi
16:34:50 <ybit> i saw go's mascot and i figure we need one
16:34:57 <ybit> so i spent the past hour or so making a logo
16:35:05 <ybit> er, mascot
16:35:13 <ybit> http://i.imgur.com/4UcXe.png
16:35:35 <ybit> you like?
16:35:59 <Saizan> stribor: then try cabal install gtk again
16:36:09 <stribor> Saizan: ok give me sec
16:36:57 <stribor> Saizan: could i not add the PATH by editing some file....what file stores PATH
16:37:49 <hpaste> stribor pasted “error” at http://hpaste.org/54086
16:38:06 <Saizan> stribor: you can put that command in ~/.bashrc to make it run everytime
16:38:16 <stribor> Saizan: this is error i get now http://hpaste.org/54086
16:38:34 <stribor> Saizan: whats cairo?>
16:39:01 <Saizan> stribor: another library
16:39:22 <stribor> Saizan: how do i installl that
16:39:26 <Saizan> stribor: in your log you should find the actual build error for cairo
16:39:27 <stribor> install cairo
16:40:40 <kfish> ybit: lamb curry?
16:40:45 <stribor> Saizan: where are errors?..log directory but what file?
16:40:55 <ybit> http://i.imgur.com/OlDLF.png kfish
16:42:11 <Saizan> stribor: i mean in the scrollback
16:42:30 <Saizan> stribor: i.e. in your terminal but before those lines
16:43:23 <stribor> Saizan: i had 24 out of 24 comiples ok..and then at the end it says this ->cairo-0.12.2 failed during the configure step. The exception was: ExitFailure 1
16:44:00 <Saizan> stribor: it must be before, when it's trying to configure cairo
16:44:28 <Saizan> stribor: i guess you could run cabal install gtk again, there should be less messages so it'd be easier to find the real error
16:44:42 <stribor> here -> Configuring cairo-0.12.2... setup: The pkg-config package cairo-pdf is required but it could not be found.
16:45:23 <Saizan> ok, so cairo-pdf is a C library, you've to install that via your distro
16:47:07 <stribor> Saizan: i am doing it now
16:48:34 <stribor> Saizan: its compiling cairo now
16:49:05 <Saizan> nice
16:49:10 <stribor> Saizan: now i have this error...-> Configuring pango-0.12.2... setup: The pkg-config package pango version >=1.0 is required but it could not be found. cabal: Error: some packages failed to install: gtk-0.12.2 depends on pango-0.12.2 which failed to install. pango-0.12.2 failed during the configure step. The exception was:
16:49:12 <stribor> Saizan: lol
16:49:28 <Saizan> same as above :)
16:49:42 <Saizan> these are all bindings to C libs, so you must have those installed
16:49:48 <stribor> Saizan: ok
16:51:52 <gwern> oy vey http://i.imgur.com/Mib6Q.png
16:53:28 <_riba> why?
16:53:31 <shapr> gwern: is cute!
16:53:40 <gwern> not abstract enough for haskell
16:54:27 <elliott> haskell's mascot is the >λ= logo. it's a monad.
16:54:29 <gwern> our cool abstract stylized lambda/bind logo conveys our feelings
16:54:29 <elliott> it's warm and fuzzy.
16:54:37 <gwern> namely, 'we're smarter and better and alien efficient'
16:55:03 <elliott> look out for my new book, "learn haskell the fun way with our pal, >λ=!". it moves its little equal sign instead of having arms, it is completely adorable
16:55:27 <shapr> Eh, I liked Cale's submission to the Haskell logo contest.
16:56:36 <luite> yeah I also liked that one
16:56:40 <elliott> which was that?
16:57:08 <shapr> It was a lambda-shaped mountain with day on one side and night on the other.
16:57:09 <luite> perhaps because mountains are awesome :)
16:57:28 <luite> http://www.haskell.org/wikiupload/5/57/Haskell-logo-6up.png
16:57:53 <shapr> Yes, especially the one on the bottom right appeals to me.
16:58:20 * elliott thinks it's a bit too noisy.
16:58:39 <luite> yep I also like that one best, though maybe the font might need some adjustment
16:58:41 <Draconx> my eyes, the kerning does nothing!
16:58:58 <jmcarthur> of those six i prefer either to top right or the center left
16:59:00 <shapr> To me, it was the most professional looking logo of the submission.
16:59:20 <luite> I thought it would win actually... meh ;p
16:59:21 <jmcarthur> *the
16:59:45 <jmcarthur> i think overall the mountain thing is a bit cheesy and not having much to do with haskell at all, though
16:59:54 <jmcarthur> i mean, i see the lambda, but why a mountain?
17:00:01 <luite> but it's a lambda!
17:00:26 <shapr> I like the day on one side, night on the other.
17:00:33 <shapr> Feels like the time I spend coding :-)
17:00:35 <_riba> but a lamb does?
17:00:46 <elliott> _riba: oh god, I bet it's a pun on LAMB-da
17:00:51 <elliott> :(
17:00:58 <_riba> :(
17:01:01 <luite> :)
17:01:06 <luite> not so negative guys ;
17:01:08 <luite> ;)
17:03:13 <gwern> elliott: I could forgive it if it were a visual pun; otherwise meh
17:04:18 <stribor> Saizan: it worked.....thank you so much for help
17:04:58 <Philippa> jmcarthur: the mountain's a device to frame the day/night thing, which I suspect referred to purity and impurity?
17:05:38 <shapr> How does Haskell handle time ranges?
17:06:07 <Saizan> stribor: np
17:06:18 <shapr> Also, is there an easy way to produce 32-bit binaries on a 64-bit system?
17:06:24 <shapr> Or alternatively, does GHC run on the OLPC XO?
17:06:25 <gwern> shapr: if it's like any thing else to do with time, painfully
17:06:45 <shapr> gwern: Python runs on my XOs natively, so I thought about using that, but I'd rather use Haskell if possible.
17:07:16 <luite> shapr: NominalDiffTime is for time differences, at least that's the one I've used for it
17:07:19 <luite> with a Num instance
17:07:21 <shapr> hrm
17:07:24 <shapr> sounds interesting!
17:07:28 <Pseudonym> What's wrong with Duration?
17:07:33 <Pseudonym> It's a perfectly servicable word.
17:07:51 <shapr> @index NominalDiffTime
17:07:51 <lambdabot> bzzt
17:08:04 <luite> Data.Time.Click
17:08:07 <luite> Clock
17:08:09 <luite> time package
17:08:10 <shapr> ah
17:08:23 <ddarius> gwern has had his heels wounded by time.
17:09:15 <ddarius> @google tock oz
17:09:17 <lambdabot> http://en.wikipedia.org/wiki/Tick_tock
17:09:17 <lambdabot> Title: Tick tock - Wikipedia, the free encyclopedia
17:11:31 <gwern> ddarius: time may heal all wounds, but it causes them, and it doesn't heal the final one
17:12:17 * shapr upgrades his local time library
17:12:53 * shapr reads http://www.haskell.org/pipermail/libraries/2005-January/002908.html
17:19:18 <Mathnerd314> is there a version of lambdabot's undo command for arrows?
17:20:09 <shachaf> Mathnerd314: No one understands arrow notation, sadly.
17:20:57 <Mathnerd314> but it's cool...
17:21:11 <c_wraith> arrow notation has some really complex stuff in it
17:22:27 <Mathnerd314> but the desugaring is rather straightforward...
17:54:25 <AfC> When considering two competing packages to do a job, what criteria might you suggest?
17:54:37 <AfC> I'm trying to choose between http://hackage.haskell.org/package/redis and https://github.com/bumptech/redis-haskell (as referred to from http://devblog.bu.mp/haskell-at-bump )
17:55:17 <AfC> obviously the former is on Hackage and that's all good; the other (as described in the blog post) is a fork of someone else's effort but with what sound like quite sensible improvements.
17:55:40 <AfC> I suppose I could make a harness which drives both and see which I "like" but perhaps there are more objective ways of determining quality?
17:57:57 <_Mikey> Good night cruel world I'll see you in the morning!
18:02:25 <kfish> hi AfC
18:02:42 * AfC waves to kfish
18:03:03 <AfC> Guess I should probably pose that as a more general question to haskell-cafe.
18:04:22 <kfish> AfC, it probably needs someone familiar with redis ...
18:04:40 <AfC> True.
18:04:58 <kfish> from the looks of it the hackage package has a higher level (more haskelly) api, the github one is closer to the bindings
18:05:13 <elliott> AfC: version, update rate, reverse dependencies, dependencies, and then just plain looking atthe APIs :P
18:05:39 <shachaf> elliott: I love comparing on version number.
18:05:54 <AfC> shachaf: heh
18:05:55 <shachaf> elliott: What if version 0.1 was perfect so no updates were needed since?
18:06:12 <elliott> shachaf: I can't handle such perfection. Sorry.
18:07:23 <kfish> author `elem` [DonaldKnuth]
18:07:31 <AfC> I guess the part that threw me was "...we swapped out the internals to use attoparsec for protocol parsing and the binary package for protocol generation. ..." [regards redis-haskell] to a newcomer, that all sounded very astute and desirable.
18:08:07 <kfish> well it sounds like someone cares about developing it at least :)
18:13:14 <hpaste> smoge pasted “degreeToKey” at http://hpaste.org/54089
18:13:25 <smoge> could someone help me with this?
18:13:38 <smoge> I don't know how to fix..
18:14:10 <smoge> probably a studio mistake
18:14:13 <smoge> 0stupid
18:15:03 <smoge> it's a function that converts the degree (in a music scale) to the key (note number)
18:16:31 <smoge> looks like a type problem
18:17:05 <kfish> smoge, what's the error?
18:17:19 <JoeyA> Something something rational?
18:17:41 <kfish> deg.hs:10:47:
18:17:41 <kfish>     No instance for (Fractional Int)
18:17:41 <kfish>       arising from a use of `/'
18:17:48 <JoeyA> > (3 :: Int) / 5
18:17:49 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
18:17:49 <lambdabot>    arising from a use o...
18:17:52 <JoeyA> > (3 :: Int) `div` 5
18:17:54 <lambdabot>   0
18:18:08 <smoge> http://hpaste.org/54090
18:18:18 <JoeyA>  / is fractional division in Haskell, while `div` is floor division (like in C, except more consistent behavior w.r.t. negative numbers)
18:18:30 <smoge> hum... okay..
18:18:58 <shachaf> JoeyA: There's also `quot`.
18:18:59 <ddarius> > (-1) `div` 2
18:19:00 <lambdabot>   -1
18:19:23 <smoge> seems to work now
18:19:37 <shachaf> > -1 `div` 2
18:19:38 <lambdabot>   0
18:19:39 <mzero> and yay Haskell: one of the rare languages where mod is really modulo!
18:19:39 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
18:19:42 <smoge> but it rounds or returns a rational number???
18:19:44 <shachaf> Hmm.
18:19:45 <mzero> > -1 `mod` 5
18:19:46 <lambdabot>   -1
18:19:59 <mzero> > -1 `rem` 5
18:19:59 <JoeyA> smoge: `div` rounds down.
18:20:00 <lambdabot>   -1
18:20:01 <shachaf> > (-1) `mod` 5
18:20:02 <lambdabot>   4
18:20:04 <JoeyA> > 3 `div` 5
18:20:05 <lambdabot>   0
18:20:27 <mzero> d'oh - always get caught by negatives!
18:20:49 <shachaf> mzero: How's BayHac going to compare to Hac Boston?
18:20:59 <ddarius> @google daan leijen div mod
18:21:01 <lambdabot> http://research.microsoft.com/pubs/151917/divmodnote.pdf
18:21:01 <lambdabot> Title: Division and Modulus for Computer Scientists
18:21:28 <ddarius> shachaf: I suspect it will be much warmer.
18:21:30 <mzero> compare? I don't think BayHac or Hac Boston are instances of Ord
18:21:54 <shachaf> mzero: Well, chronologically, let's say. I suppose it'll be in February?
18:22:05 <shachaf> ddarius: That seems likely. You should come!
18:22:31 <mzero> shachaf: we haven't picked a weekend yet
18:22:34 <mzero> but, probably Feb....
18:22:47 <mzero> probably end of Feb
18:24:10 <shachaf> Hac Boston already has a date, a location, and pizza funding. We gotta keep up, man!
18:24:41 <mzero> pizza funding? from who?
18:24:54 <shachaf> CapitalIQ, I think.
18:34:31 <gwern> hm... I wish I knew more math. I want to map an arbitrary list of integers onto 1-7, where the lowest in the range is 1 and the highest is 7. I can do this by hand dividing by ever greater multiples of 7 and rounding, but there's a right approach using div or mod or something
18:35:43 <Cale> mod by 7 and then add 1
18:36:19 <Cale> > map (\x -> x `mod` 7 + 1) [0..]
18:36:19 <lambdabot>   [1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,3,4,5,6,7,1,2,...
18:36:46 <gwern> > map (\x -> 1 + x `mod` 7) [610, 513,527,500]
18:36:47 <lambdabot>   [2,3,3,4]
18:37:03 <gwern> Cale: ^ I did try just mod 7, but look at that - the highest value is 4! not 7
18:37:30 <Cale> Er...
18:37:39 <Cale> Maybe I misunderstand what you're trying to do
18:38:41 <gwern> Cale: I'm playing with sparklines, using a terminal generator which has only 7 different glyphs. I want the output to show as much difference as exists in the list
18:39:42 <elliott> gwern: 8 glyphs surely
18:39:44 <elliott> if you're using unicode bars
18:39:53 <gwern> Cale: it works fine for some data; eg. ' spark 1 4 5 15 ~> ▁▂▃▇'. but not when they get big: ' spark 610 513 527 500 ~> ▇▆▇▆'
18:40:11 <elliott> gwern: it sounds like you need to get the maximum of the list
18:40:11 <Cale> If you mod, you're just taking the remainder after division, so that's not what you want
18:40:18 <gwern> Cale: right
18:40:20 <elliott> and then it's just (elem*max)`div`7
18:40:23 <Cale> You need to get the maximum and minimum of the list
18:40:29 <elliott> oh right
18:40:31 <elliott> and subtract the minimum
18:41:13 <kfish> gwern: do you have a haskell one-liner for spark? ;-)
18:41:28 <gwern> kfish: no; someone else wrote a spark-clone in haskell
18:41:36 <gwern> I just cleaned it up a little, no need to rewrite it
18:41:36 <kfish> oh, link?
18:41:51 <gwern> kfish: and you don't need to, the glyphs are just placeholders for 1-7
18:42:38 <gwern> > let n = [610, 513,527,500] in let m = max n in let m' = min n in map (\x -> (x - m') * m `div` 7) n
18:42:39 <lambdabot>   No instance for (GHC.Real.Integral ([t] -> [t]))
18:42:39 <lambdabot>    arising from a use of `...
18:45:37 <gwern> I guess max and min are not defined like I thought they were...
18:46:03 <gwern> > let n = [610, 513,527,500] in let m = maximum n in let m' = mininum n in map (\x -> (x - m') * m `div` 7) n
18:46:04 <lambdabot>   Not in scope: `mininum'
18:46:25 <gwern> > let n = [610, 513,527,500] in let m = maximum n in let m' = minimum n in map (\x -> (x - m') * m `div` 7) n
18:46:26 <lambdabot>   [9585,1132,2352,0]
18:46:40 <gwern> > let n = [610, 513,527,500] in let m = maximum n in let m' = minimum n in map (\x -> (x - m') `div` 7) n
18:46:41 <lambdabot>   [15,1,3,0]
18:47:40 <gwern> > let n = [610, 513,527,500] in let m = maximum n in let m' = minimum n in map (\x -> ((x - m')*m) `div` 7) n
18:47:41 <lambdabot>   [9585,1132,2352,0]
18:47:54 <hasker> Any reports of the "GHC 7.2 and cabal-install" thingie in the topic working on windows?
18:47:57 <gwern> > let n = [610, 513,527,500] in let m = maximum n in let m' = minimum n in map (\x -> ((x*m) - m') `div` 7) n
18:47:58 <lambdabot>   [53085,44632,45852,43500]
18:48:13 <fryguybob> > let n = [610, 513,527,500] in let m = maximum n; m' = minimum n in map (\x -> (x - m') * 7 `div` (m - m')) n
18:48:14 <lambdabot>   [7,0,1,0]
18:48:53 * hackagebot verilog 0.0.2 - A Verilog parser.  http://hackage.haskell.org/package/verilog-0.0.2 (TomHawkins)
18:49:11 <gwern> > let n = [610, 513,527,500] in let m = maximum n; m' = minimum n in map (\x -> ((x m') * 7) `div` (m - m')) n
18:49:12 <lambdabot>   [38,32,33,31]
18:49:24 <gwern> > let n = [610, 513,527,500] in let m = maximum n; m' = minimum n in map (\x -> (x m') * (7 `div` (m - m'))) n
18:49:25 <lambdabot>   [0,0,0,0]
18:49:49 <Eduard_Munteanu> > let max = 610; min = 500 in map (\x -> ceiling $ 1 + (x - min) * (7 - 1) / (max - min)) [610, 513, 527, 500]
18:49:50 <gwern> huh. it didn't associate either way I thought it would.
18:49:50 <lambdabot>   [7,2,3,1]
18:50:57 <ybit> http://www.reddit.com/r/haskell/comments/mds9d/meet_curry_the_lamb_haskells_new_mascot/
18:52:12 <shachaf> ybit: You can't just decide that sort of thing, you know.
18:52:16 <ybit> yeah i know
18:52:21 <ybit> hoping for discussion
18:53:37 <Eduard_Munteanu> Though you probably want to round.
18:53:58 <ybit> i wouldn't have imagined it would be so controversial
18:58:53 * hackagebot pop3-client 0.1.4 - POP3 Client Library  http://hackage.haskell.org/package/pop3-client-0.1.4 (TomRudick)
19:12:27 <Cale> ┳━┳︵╭(˳□˳╭）
19:16:02 <elliott> Cale: heh
19:48:53 * hackagebot husk-scheme 3.4.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.4.1 (JustinEthier)
20:01:13 <Mathnerd314> is there a backwards version of ($) like (>>>) is a backwards version of (.)?
20:01:52 <Cale> not pre-defined
20:02:15 <Mathnerd314> @let (>>>>) = flip ($)
20:02:16 <lambdabot>  Defined.
20:02:32 <Mathnerd314> > 1 >>>> (+2)
20:02:33 <gtirloni> only makes code harder to read, doesnt it?
20:02:34 <lambdabot>   3
20:02:44 <Mathnerd314> > 1 >>>> (+2) >>>> (/2)
20:02:45 <lambdabot>   1.5
20:02:52 <Mathnerd314> yay :-)
20:03:20 <Mathnerd314> Now, where did it get the proper associativity?
20:03:33 <parcs_> infixl is default
20:03:38 <shachaf> Mathnerd314: (|>) is a popular name for it.
20:03:41 <parcs_> coincidentally that is proper in this case
20:03:51 <shachaf> parcs_: Or is it?
20:03:56 <shachaf> Cale: Should flip ($) be infixr? :-)
20:05:50 <Mathnerd314> shachaf: no! as you can see, it is much easier to use infixl
20:06:21 <Cale> shachaf: probably
20:06:57 <Cale> Mathnerd314: easier to use wastefully where you could be using flipped composition :)
20:07:21 <ion> @type (Seq.|>)
20:07:22 <lambdabot> forall a. Seq.Seq a -> a -> Seq.Seq a
20:07:24 <Cale> Mathnerd314: but you lose expressiveness like that
20:07:30 <elliott> it should be infixr for the same reason ($) should be infixl, no?
20:07:34 <Cale> yeah
20:08:27 <Mathnerd314> I can write (+1) >>> (+2) >>> (/2), why can't I write  1 >>>> (+2) >>>> (/2)
20:08:46 <elliott> because it should be 1 >>>> (+1) >>> (+2) >>> (/2)
20:09:06 <elliott> I can write (/2) . (+2) . (+1), why can't I write (/2) $ (+2) $ (+1) $ 1
20:09:10 <shachaf> 1 >>>> (+1) >>>>>>> (+2) >>>>>>>>>>>>>>> (/2)
20:09:11 <elliott> answer: you can, but you shouldn't
20:09:17 <elliott> because (/2) . (+2) . (+1) $ 1 is better
20:09:22 <elliott> especially because you can trivially factor out the argument
20:09:37 <shachaf> elliott: It's kind of convenient that whatever expression I have (almost), I can stick "length $" in front of it in ghci.
20:09:47 <shachaf> Even if it happens to contain a $ somewhere.
20:09:52 <Cale> > length $ 1 + 1
20:09:53 <lambdabot>   No instance for (GHC.Num.Num [a])
20:09:53 <lambdabot>    arising from the literal `1' at <inter...
20:09:59 <Cale> :(
20:10:03 <shachaf> Cale: Well, list expression.
20:10:09 <ion> > length $ "foo" :: String
20:10:10 <shachaf> instance Num [a]
20:10:11 <lambdabot>   Couldn't match expected type `GHC.Base.String'
20:10:11 <lambdabot>         against inferred typ...
20:10:16 <elliott> shachaf: length (<Ctrl+E>) isn't that bad...
20:10:26 <shachaf> ion: Yes, that was my special case too.
20:10:31 <elliott> shachaf: Maybe we need paredit for Haskell.
20:10:44 <elliott> <apply>length<enter>
20:10:46 <shachaf> elliott: It kind of is, especially since I may want to remove it later.
20:11:05 <Cale> Try:  [1..10] <enter>  length it
20:11:08 <elliott> I think :: should have a lower precedence. Or is it higher?
20:11:18 <elliott> Cale: That stops you editing the expression.
20:11:26 <elliott> Repeated amendment is better than a more "compositional" style here.
20:11:58 <shachaf> elliott logic
20:13:26 <Mathnerd314> > 1 >>>> (+2) >>> (/2)
20:13:27 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
20:13:27 <lambdabot>    arising from a use of `...
20:13:50 <Mathnerd314> it has the wrong precedence...
20:13:56 <shachaf> elliott: (That was a lazy form of agreement.)
20:14:09 <hasker> elliott: are you trying to kill things in between parens? if so C-M-k works.
20:14:12 <elliott> Oh, I thought you were mocking me. :'(
20:14:15 <elliott> hasker: No.
20:14:25 <hasker> oh, then nevermind, carry on
20:14:30 <ion> > let (!!!!!) = (+); infixl (!!!!!) 0  -- Does this work here?
20:14:31 <lambdabot>   <no location info>: parse error on input `('
20:14:37 <ion> > let (!!!!!) = (+); infixl !!!!! 0
20:14:38 <lambdabot>   <no location info>: parse error on input `0'
20:15:03 <ion> > let (!!!!!) = (+); infixl 0 !!!!!
20:15:04 <lambdabot>   not an expression: `let (!!!!!) = (+); infixl 0 !!!!!'
20:15:28 <ion> Crap. @let
20:15:34 <ion> @let (!!!!!) = (+); infixl 0 !!!!!
20:15:35 <lambdabot>  Defined.
20:18:34 <Mathnerd314> Cale: could you give an example where you'd use the fact that >>>> is infixr? I have the feeling it'd be illegible
20:19:58 <elliott> that's because (>>>>) is illegible
20:20:29 <elliott> Mathnerd314: use of infixl ($): foo $ bar a b $ baz c d
20:22:04 <Mathnerd314> elliott: it's not illegible in a font with ligatures such that >> looks like »
20:22:22 <elliott> sure, let me know when you mix it up with (>>>) for the billionth time
20:26:08 <Mathnerd314> @let (>>>>) = flip ($); infixr (>>>>) 0
20:26:08 <lambdabot>   Parse error: (
20:26:21 <Mathnerd314> @let (>>>>) = flip ($); infixr >>>> 0
20:26:21 <lambdabot>   Parse error: 0
20:29:51 <Mathnerd314> wtf...
20:31:04 <Mathnerd314> oh, duh. switched them. :p
20:34:34 <Mathnerd314> @type \foo bar baz a b c d -> foo $ (bar a b $ baz c d) `asTypeOf` (d >>>> c >>>> baz) >>>> b >>>> a >>>> bar >>>> foo
20:34:35 <lambdabot>     Precedence parsing error
20:34:36 <lambdabot>         cannot mix `$' [infixr 0] and `>>>>' [infixl 0] in the same infix expression
20:34:52 <Mathnerd314> @type \foo bar baz a b c d -> (foo $ (bar a b $ baz c d)) `asTypeOf` ((d >>>> c >>>> baz) >>>> b >>>> a >>>> bar >>>> foo)
20:34:53 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
20:34:53 <lambdabot>     Probable cause: `baz' is applied to too few arguments
20:34:53 <lambdabot>     In the second argument of `(>>>>)', namely `baz'
20:38:27 <Mathnerd314> hmm... I guess it dropped the infixr declaration
20:40:37 <Mathnerd314> @type \foo bar baz a b c d -> (foo $ (bar a b $ baz c d)) `asTypeOf` ((d >>>> c >>>> baz) >>>> (b >>>> a >>>> bar) >>> foo)
20:40:38 <lambdabot> forall b a b1 a1 a2 a3 a4. (b1 -> b) -> (a4 -> a3 -> a -> b1) -> (a2 -> a1 -> a) -> a4 -> a3 -> a2 -> a1 -> b
20:41:19 <Mathnerd314> I don't see how to drop those two pairs of parens
20:44:18 <Mathnerd314> ^ Cale, elliott
20:44:47 <elliott> Mathnerd314: foo . bar a b $ baz c d
20:44:51 <elliott> that's what (.) is for.
20:45:06 <elliott> and it's idiomatic to use chains of (.) rather than chains of ($) anyway
20:45:21 <Mathnerd314> elliott: *while using >>>> and >>>*
20:45:36 <elliott> just flip it around?
20:45:41 <shachaf> print $ f . g . h $ x -- I see this pretty often
20:45:44 <elliott> baz c d >>> bar a b >>> foo
20:45:48 <elliott> erm
20:45:50 <elliott> baz c d >>>> bar a b >>> foo
20:45:56 <shachaf> atomically $ liftIO $ instead of atomically . liftIO $
20:47:26 <Mathnerd314> elliott: but I want to flip everything around, including ordinary function application. So it sounds like I need to go up to (>>>>>) to do what you want to do, and have 3 operators
20:48:16 <elliott> sure, if you make a new operator for function application, things mess up.
20:48:29 <elliott> shachaf: That's always a type error. :-)
20:48:54 <shachaf> elliott: Not with my fancy definition of (.)!
21:01:40 <Mathnerd314> elliott: and I think this breaks down if I need another level of nesting.
21:01:57 <elliott> right. this is why you don't try and reverse application.
21:02:40 <mzero> someone missing their belovéd HP calculator or yore?
21:02:56 <newsham> #forth
21:03:09 <Mathnerd314> elliott: no, you get the same problem if doing it forward
21:03:21 <elliott> you don't need an application operator doing it forward
21:03:24 <elliott> because you can press the space bar instead.
21:06:26 <mm_freak> i wonder if (in a more powerful type system) it's possible to unify the Category and Monoid classes
21:06:53 <mm_freak> kind polymorphism with some sort of kind families might be enough
21:08:03 <Mathnerd314> elliott: I meant with levels of nesting. I don't think you can write a (b (c d)) e using space, (.) and ($)
21:08:25 <elliott> Mathnerd314: yes, it is true that these convenience operators do not cover all application
21:08:30 <SgeoN1> Could I make an arrow out of (a,a)->(a,a)?
21:08:40 <elliott> Mathnerd314: for an entirely paren-less application syntax, please see Principia Mathematica
21:08:50 <elliott> I think you might come out of the experience preferring parentheses :)
21:09:34 <SgeoN1> How about Factor?
21:09:35 <Mathnerd314> elliott: who wrote it?
21:09:45 <elliott> Mathnerd314: uh, the Principia Mathematica?
21:09:50 <SgeoN1> Or Forth
21:09:55 <mm_freak> SgeoN1: i don't see any problem with that
21:10:22 <mm_freak> but what would be the point?  it would be a restricted function arrow
21:10:29 <SgeoN1> mm, which of the thugs I said are you referring to?
21:10:30 <mm_freak> the function arrow can already express computations of that kind
21:10:35 <SgeoN1> Oh
21:10:50 <SgeoN1> Trying to get a grip on what, exactly, an arrow is
21:11:00 <Mathnerd314> elliott: well, apparently there's a book by Newton, but there's also a book by Bertrand Russell and Alfred North Whitehead
21:11:20 <mm_freak> SgeoN1: see the (&&&) and (***) combinators
21:11:29 <elliott> Mathnerd314: i refer to whitehead and russell's, yes.
21:11:47 <elliott> the one goedel put a dent in :)
21:11:49 <mm_freak> SgeoN1: i'm writing an arrow tutorial, but it's not finished yet
21:12:03 <mm_freak> if you would like to read its current version, just tell me
21:12:11 <ion> mm_freak: Nice
21:12:18 <SgeoN1> Maybe tomorrow, I need sleep soon
21:12:33 <ion> How about a FRP tutorial next? ;-)
21:12:53 <snappy> Don't really know much about the error function in Haskell, but is it possible to catch an error? I'm trying to write some tests for a simple function which reports errors
21:12:53 <mm_freak> ion: my tutorial goes into automaton and wire arrows =)
21:13:03 <ion> mm_freak: Alright, cool.
21:13:11 <mm_freak> snappy: only in IO
21:13:17 <mm_freak> 'error' uses 'throw'
21:13:21 <SgeoN1> snappy, only in IO. Don't use error for pure stuff, if you can avoid it
21:13:52 <SgeoN1> Make the return type a Maybe or Either instead, possibly
21:13:53 <mm_freak> snappy: Maybe and Either are preferable to 'error'
21:14:00 <mm_freak> lol
21:14:16 <monochrom> since you're writing test code, the test code can easily be using IO and catching exceptions. do not forget "evaluate" from Control.Exception
21:14:28 <snappy> So I'm actually trying to grade a bunch of code that are haskell submissions. They were instructed to use error or let the interpreter throw the error. Trying to find a way to automatically test these functions including the cases where it will error.
21:14:47 <SgeoN1> Ah, that's different
21:15:11 * monochrom never rushes to suggest "don't use exception, use Either" for this reason
21:16:01 <mm_freak> well, 'error' somewhat disrupts pure computations
21:16:02 <snappy> I'm wondering if quickcheck is the tool that I'd want to use then
21:17:07 <SgeoN1> snappy, without unsafePerformIO, you cannot write a function a -> Bool that tells you whether there was an ertor
21:17:21 <SgeoN1> Although I don't know mug about quickcheck
21:17:25 <mm_freak> ion: the part that explains the difference between arrows and monads is already complete…  if you promise to give feedback, i can send you a link =)
21:17:40 <snappy> Hm, fair enough
21:17:42 * SgeoN1 would like to see ot
21:18:02 <JoeyA> If Haskell were totally functional, would infinite loops and exceptions in the IO monad still be possible?
21:18:07 <Mathnerd314> SgeoN1: but he can use unsafePerformIO and whatever other hacks there are.... so the question is which one he uses
21:18:12 <monochrom> you could try HUnit or you could row your own
21:18:49 <mm_freak> JoeyA: "totally functional"?
21:20:00 <JoeyA> mm_freak: As in, functions cannot error.  "Total" also means functions always terminate (right?), which can't simply be dropped into Haskell without it having to solve the halting problem.
21:20:07 <theos> hi
21:20:25 <JoeyA> hi
21:20:30 <theos> sup
21:21:13 <snappy> hm, ok, i just thought of a really hacky way to go about this, but it should suffice
21:21:35 <adrake_> JoeyA: I'd think the lambda calculus would be the epitome of "totally functional", and there are plenty of nonterminating lambda calculus terms
21:21:47 <monochrom> not a quickcheck user here, but it seems to have provision for testing monadic things, including IO. so, write an IO wrapper over student functions, and quickchekc the IO wrapper instead
21:21:55 <adrake_> e.g. (\x.xx)(\x.xx)
21:22:51 <monochrom> does RWH teach quickcheck?
21:22:59 <Mathnerd314> elliott: apparently PM just uses arbitrarily large numbers of dots. So it doesn't provide a solution to the problem, of using only a (small) finite set of operators to represent the tree
21:23:18 <elliott> Mathnerd314: Indeed.
21:23:24 <JoeyA> What I'm thinking is that, if all expressions must evaluate to head normal form, you can still do an infinite loop in the IO monad.
21:23:30 <elliott> There is that paren-less TC combinator base.
21:23:35 <elliott> It's been linked here before. I forget who wrote the paper.
21:23:37 <SgeoN1> snappy, you can write a -> IO Bool fairly easily, I think. I'm personally not sure how, but I'm not a Haskell expert
21:24:35 <adrake_> SgeoN1: (\x -> return False) is a -> IO Bool :P
21:25:08 <SgeoN1> >.> that's not what I meant.
21:25:33 <JoeyA> @hoogle >.>
21:25:33 <lambdabot> No results found
21:25:55 <ion> mm_freak: I’m a bit busy with ai-class etc. I’m interested, but i’m afraid i can’t promise to get around to read it by any specific time. Whenever i finally do, i’ll be sure to give feedback.
21:26:23 <JoeyA> As in, test if the value evaluates or throws an exception?
21:26:37 <monochrom> RWH teaches quickcheck but not its monadic power
21:27:00 <SgeoN1> Well, mathematically can't catch infinite loops, but can catch error
21:27:00 <Mathnerd314> elliott: you mean the one that rewrites the program in postfix? that's not what I'm looking for.
21:27:07 <elliott> Mathnerd314: I don't think so.
21:27:14 <elliott> It's just P and Q in a merry dance together, I believe.
21:27:23 <shachaf> SgeoN1: Huh? You can't catch either.
21:27:38 <SgeoN1> shachef, I meant in the IO monad
21:27:38 <shachaf> Er, I assumed that "mathematically" applied to the whole sentence.
21:27:57 <Mathnerd314> elliott: so not this one? http://www.eecs.usma.edu/webs/people/okasaki/jfp03flat.pdf
21:28:04 <elliott> Oh, I think it was Okasaki, yes.
21:28:05 <SgeoN1> Even the IO monad can't catch infinite loops, for mathematical reasons
21:28:16 <mm_freak> ion: sure, that's fine
21:28:23 <elliott> Bah, I really need universally quantified constraints.
21:28:34 <elliott> I need to `instance (forall a b. Show (t a b)) => Show (Foo t)`.
21:28:54 <monochrom> an impredicative type system would allow that
21:29:05 <shachaf> elliott: I think that's what they call "firstworldproblems" on the Internet.
21:29:14 <elliott> haskellworldproblems
21:29:20 <elliott> "My type system just isn't dependent enough."
21:29:48 <shachaf> SgeoN1: You can catch some infinite loops in IO too.
21:31:46 <elliott> shachaf: Actually I'm already using unsafeCoerce, so maybe I'll just apply more of it.
21:32:08 * shachaf looks in the other direction.
21:35:29 <SgeoN1> But not all, unless you falsely detect some non-infinite loops as inffinitr loops
21:36:33 * monochrom doesn't understand why #haskell airs a lecture on decidability and computability every so often
21:36:40 <shachaf> If all you want to detect is inffinitr loops, you can just solve the haulltin problem (which is much easier than the halting problem).
21:36:52 <monochrom> shachaf++
21:37:25 <ion> hah
21:37:42 <mm_freak> i would have expected someone to mention agda in this context
21:38:12 <Mathnerd314> mm_freak: I thought about it, but then I thought of Idris and epigram, and was too confused to mention it
21:38:53 <ion> Does Agda solve the haulltin problem?
21:38:54 * hackagebot msgpack 0.6.1.3 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.1.3 (HideyukiTanaka)
21:39:40 <Mathnerd314> ion: mostly. IIRC it requires help for complex programs
21:40:00 <mm_freak> ion: it's not turing-complete, so it doesn't even have the halting problem (i don't know what the haulltin problem is)
21:40:54 <mm_freak> Mathnerd314: idris is not designed to be total…  i'm not sure about epigram
21:41:04 <mm_freak> agda is specifically designed to be a total language
21:42:37 <mm_freak> in essence idris is really just haskell with dependent types…  i think its goal is to be a practical language for real world problems…  i'd love to see it become actually useful
21:43:14 <Eduard_Munteanu> Agda still has programming in mind, though.
21:43:40 <shachaf> Epigram is still aware that there exists such a thing as a programmer somewhere.
21:43:49 <Eduard_Munteanu> Perhaps not at the expense of theorem proving.
21:43:53 <SavageSimian> how do i putStrLn a type?
21:44:09 <elliott> shachaf: Well, dimly at least.
21:44:16 <shachaf> SavageSimian: Why do you putStrLn a type?
21:44:33 <ion> putStrLn "String"
21:45:08 <elliott> print (typeOf x)
21:45:09 <SavageSimian> shachaf: no. how. i know i can use :t from the interactive shell but how do i get the type output from 'main'?
21:45:11 * elliott is trolling.
21:45:22 <elliott> SavageSimian: No, it's definitely "why".
21:45:34 <shachaf> SavageSimian: You want a compiled program to print out the type of one of its variables?
21:45:42 <SavageSimian> yes
21:45:52 <parcs_> :t typeOf
21:45:53 <lambdabot> forall a. (Typeable a) => a -> TypeRep
21:46:05 <shachaf> SavageSimian: I agree with elliott.
21:46:06 <mm_freak> > show (typeOf (3 :: Int))
21:46:07 <lambdabot>   "Int"
21:46:14 <SavageSimian> ty
21:46:17 <mm_freak> SavageSimian: but in haskell there is little point in doing that
21:46:19 <elliott> mm_freak: I'm not sure you're helping.
21:46:19 <shachaf> However, given Typeable, you can do what people here are saying.
21:46:20 <elliott> :p
21:46:23 <parcs_> > typeOf (undefined :: [Int])
21:46:24 <lambdabot>   [Int]
21:46:24 * elliott beat you to it, though!
21:46:33 <elliott> SavageSimian: You really don't want to do whatever you're doing.
21:46:34 <mm_freak> SavageSimian: unless you need it for debugging
21:46:49 <shachaf> > typeOf [()]
21:46:50 <lambdabot>   [()]
21:47:00 <SavageSimian> why do i not want to know the type of a variable?
21:47:05 <shachaf> SavageSimian: Why would you want to know it at runtime?
21:47:16 <Eduard_Munteanu> SavageSimian: because you already know it at compile time
21:47:25 <Eduard_Munteanu> It doesn't magically change.
21:47:31 <mm_freak> SavageSimian: you want to know, but not at runtime…  type information is either complete at compile time or the program doesn't compile
21:47:37 <SgeoN1> You should possibly think of types as things that don't really exist at runtime.
21:47:42 <SavageSimian> because i want to make sure it's what i think it should be.
21:47:52 <rwbarton> that's the compiler's job.
21:47:55 <mm_freak> SavageSimian: that's debugging, so go ahead =)
21:48:04 <rwbarton> Add a type annotation
21:48:07 <mm_freak> i think, debugging is the only justification to print a type at runtime
21:48:13 <SgeoN1> Savage, add abtype signature. The compiler will complain if the type is wrong
21:48:16 <mm_freak> but using a type signature is the preferred way
21:48:21 <SavageSimian> yea. debugging and learning...
21:48:44 <mm_freak> SavageSimian: when you write (3 :: Int) in your code, then you can be sure it will be Int (or the program doesn't compile)
21:48:56 <Eduard_Munteanu> Well, I guess he has a point... at least as long as you can't select an arbitrary subexpression and get its type.
21:48:57 <elliott> SavageSimian: You should probably add type signatures and test things with :t in GHCi, rather than printing it at runtime.
21:49:16 <SgeoN1> With Haskell, in general, type problems should prevent the program from compiling.
21:49:49 <Veinor> Eduard_Munteanu: i really want to be able to do that
21:50:08 <Veinor> it's part of the reason i dislike using a lot of where expressions
21:50:13 <shachaf> I want to be able to select an arbitrary *substring* of my source code and get its type!
21:50:33 <mm_freak> Veinor: the other method (which i use) is to write type signatures for them as well
21:50:36 <SavageSimian> shachaf: yes
21:50:42 <shachaf> It's weird how "where" doesn't really make much sense in strict languages.
21:50:45 <nejucomo> What does "a@B{..}" in a pattern mean?  Is it equivalent to "a@B{}" ?
21:50:49 <mm_freak> that's why virtually all of my programs and libraries use the ScopedTypeVariables extension
21:50:50 <shachaf> SavageSimian: :-(
21:50:52 <elliott> shachaf: Urgh, don't, you'll make me want to code it up... I've wanted that billions of times.
21:51:05 <elliott> shachaf: /Especially/ if it lets me put a hole in place of a function argument and then ask what its "type" is.
21:51:10 <elliott> (i.e. what type it has to have...)
21:51:15 <elliott> Wait, I'm asking for Agda, aren't I.
21:51:21 <mm_freak> shachaf: in strict languages my "where" is an anonymous function…  i use that quite often
21:51:21 <ion> > let f a@Just {..} = a in f (Just 42)
21:51:22 <lambdabot>   Illegal `..' in record pattern
21:51:22 <lambdabot>  Use -XRecordWildCards to permit this
21:51:29 <shachaf> elliott: Didn't you also mention something about "runtime"?
21:51:32 <nejucomo> It turns out that "haskell {..}" searches on google aren't very useful.
21:51:38 <elliott> shachaf: Hm?
21:51:39 <Veinor> 01:04:25         <elliott> shachaf: /Especially/ if it lets me put a hole in place of a function argument and then ask what its "type" is.
21:51:43 <Veinor> this would be great, oh my god
21:51:51 <shachaf> nejucomo: RecordWildCards would find it, however. :-)
21:52:07 <elliott> Veinor: You can sort of do that by putting () there and parsing the compiler's complaint about it, as a stop-gap until we get perfect editors.
21:52:11 <rwbarton> nejucomo: it's like that but it also brings the field names into scope as variables whose values are the fields of a
21:52:14 <elliott> Unless () is OK there. In which case you're done!
21:52:28 <Veinor> true
21:52:34 <nejucomo> rwbarton: Thanks.
21:52:41 * shachaf doesn't like record punning.
21:52:47 <elliott> shachaf++
21:52:47 <nejucomo> schachaf: Thanks, I'll look it up.
21:52:51 <Veinor> also, when playing around with types, one thing i've found useful is let f = undefined :: MySuper -> Complicated Type
21:53:04 <mm_freak> nejucomo: use quotes around "{..}"
21:53:10 <mm_freak> then google searches literally
21:53:36 <ion> Doesn’t seem to work for me.
21:53:39 <SavageSimian> how can you get the type of something that's not in scope? for instance; str <- getLine inside of 'main' is not in scope from GHCi
21:53:44 <rwbarton> Your search - "{..}" - did not match any documents.
21:54:02 <shachaf> SavageSimian: You can look at the type of getLine and work it out, I suppose.
21:54:16 <mm_freak> for me the quotes work, but the results are not satisfactory =)
21:54:17 <ion> > do str <- getLine :: a; undefined
21:54:18 <lambdabot>   Couldn't match expected type `a'
21:54:18 <lambdabot>         against inferred type `GHC.Types.I...
21:54:34 <ion> The “inferred type” in the error message.
21:54:48 <rwbarton> if by "are not satisfactory" you mean "do not exist" then yes
21:54:56 <mm_freak> SavageSimian: do you really want to /learn/ the type?  or do you just want to verify it?
21:55:42 <elliott> We need a value that doesn't match any type at all.
21:55:44 <elliott> Not even (forall a. a).
21:55:50 <elliott> Then we can use it as a hole variable.
21:56:03 <SavageSimian> shachaf: yes i realize that. my point is that if you're debugging or investigating how haskell is parsed...
21:56:12 <mm_freak> elliott: define a type, which you don't use anywhere else
21:56:28 <elliott> mm_freak: But we can't stop anyone else using that!
21:56:33 <SavageSimian> mm_freak: i just want to verify. make sure it's doing what i expect it to be doing.
21:56:41 <elliott> mm_freak: I'll put up CompletelyUnusedNoInstances on Hackage and the next day someone will put up a package to spite me that declares an Eq instance. :-)
21:56:46 <mm_freak> newtype HoleForF = HoleForF HoleForF
21:56:48 <shachaf> elliott: Skolem variables?
21:57:05 <elliott> shachaf: How would that help?
21:57:24 <mm_freak> elliott: you don't need to export HoleForF
21:57:31 <mm_freak> SavageSimian: x <- getLine :: IO String
21:57:32 <elliott> mm_freak: You have to export the type.
21:57:46 <elliott> instance Eq HoleForF where _ == _ = True -- mwahaha
21:57:47 <mm_freak> elliott: not sure whether i understand the purpose
21:57:57 <elliott> mm_freak: So you can do
21:58:03 <elliott> f (undefined :: HoleForF)
21:58:09 <shachaf> elliott: I was under the impression that that's what that was. But my impression may be incorrect.
21:58:12 <elliott> mm_freak: and GHC goes "waah, it's not the right type", and tells you what the right type should be.
21:58:12 <SavageSimian> mm_freak: i'm very new to haskell and just want to see how things operate. i know the type for getLine.
21:58:29 <elliott> shachaf: I'm not sure how you could construct a hole like that.
21:58:35 <mm_freak> elliott: myUndefined :: Hole
21:58:38 <mm_freak> newtype Hole = Hole Hole
21:58:48 <elliott> mm_freak: Oh, and don't export the type?
21:58:51 <elliott> mm_freak: I think that messes up .hi files.
21:58:51 <mm_freak> yes, it unifies with other holes
21:59:00 <elliott> mm_freak: Anyway, that doesn't work.
21:59:04 <ion> That’s what she… wait
21:59:07 <elliott> mm_freak: Because it has to not match polymorphic variables, either.
21:59:11 <shachaf> elliott: Well, you can't.
21:59:20 <mm_freak> SavageSimian: no, you can write that literally in source code
21:59:28 <mm_freak> SavageSimian: that forces the type
21:59:59 <mm_freak> SavageSimian: you can also do:  do x <- getLine; putStrLn (x :: String)
22:00:16 <mm_freak> SavageSimian: if the compiler infers a different type, you get a type error
22:00:20 <mm_freak> that's how you verify types
22:00:52 <mm_freak> elliott: i see the problem, but isn't that better solved by editor tools?
22:01:02 <elliott> mm_freak: The idea is to implement editor tools with this :)
22:01:03 <mm_freak> elliott: sounds like you want some 'to do' functionality
22:01:05 <elliott> mm_freak: Without patching GHC.
22:01:08 <elliott> But maybe the GHC API is enough.
22:01:10 <SgeoN1> mm, I has a sad
22:01:17 <SgeoN1> Almost reached To Do
22:02:14 <mm_freak> elliott: for now i'm fine with grep -i "undefined" **/*.hs
22:02:16 <mm_freak> =)
22:03:23 <elliott> mm_freak: heh
22:03:38 <elliott> mm_freak: that's sort of the opposite of what you want: the idea is that you can ask what the type of a hole should be
22:03:56 <mm_freak> yeah, agda supports that
22:04:01 <elliott> i.e. "f x y {} z", hover over {}, it shwos "{} :: String -> IO Int"
22:04:02 <elliott> shows
22:04:02 <mm_freak> although you can't really ask for the type
22:04:35 <mm_freak> source code holes are great and even greater in combination with breakpoints
22:04:54 <mm_freak> but i usually use a bottom-up approach, so i don't really miss them often
22:06:06 <mm_freak> SgeoN1: oh, you are quick…  is it understandable?
22:06:15 <SavageSimian> would it be correct to say that a type is a member of the Typeable class or would it be more correct to say that Typeable is a definition of the association between a type and a type representation?
22:06:27 <mm_freak> SavageSimian: the latter
22:06:35 <mm_freak> and types can be instances of Typeable, but not all are
22:07:08 <SgeoN1> Mostly, yes. I think. I may have skimmed a bit, but I think I understand more now
22:07:20 <mm_freak> Typeable is the library variant of what you would call "typeof" in dynamic languages
22:07:34 <SgeoN1> One thing that almost tripped me up was backticks in type signatures :/
22:07:39 <mm_freak> SgeoN1: why did you skim?  is it too verbose?
22:07:54 <SgeoN1> mm, because I have a tendency to skim
22:08:01 <mm_freak> backticks in type signatures?  i don't remember using any
22:08:14 <mm_freak> do you mean single quotes?
22:08:22 <SavageSimian> mm_freak: so typeof could be looked at as inheriting from Typable?
22:08:33 <SgeoN1> id :: a `cat` a
22:08:39 <mm_freak> SgeoN1: oh, right
22:08:51 <mm_freak> SavageSimian: Typeable is a type class just like Read or Show
22:09:13 <mm_freak> and typeOf is a function just like 'read' or' show'
22:10:08 <SavageSimian> mm_freak: ah. so typeOf is a static member of Typeable that takes an argument of any type and returns a TypeRep?
22:10:29 <mm_freak> SavageSimian: don't confuse type classes with OOP concepts
22:10:42 <shachaf> SavageSimian: No, it takes an argument of type a where a is an instance of Typeable.
22:10:51 <shachaf> I don't know what a static member of Typeable is.
22:11:04 <shachaf> Haskell classes aren't much like OOP classes.
22:11:16 <SavageSimian> mm_freak: yea. i'm trying to associate functional concepts with something i'm more familiar with.
22:11:25 <mm_freak> but if you want to think in terms of OOP, for now you can think of type classes as a more powerful variant of interfaces
22:11:27 <shachaf> SavageSimian: That's not a good way to go about it.
22:11:38 <shachaf> SavageSimian: Translate type classes to dictionary passing if you like. :-)
22:12:07 <mm_freak> however, there are no objects in haskell…  everything is expressed in terms of types and values =)
22:12:14 <mm_freak> even functions and IO actions are values
22:12:30 <SgeoN1> Unless you're using OOHaskell, which I think is just a libray
22:12:52 <SgeoN1> Savage, pretend I didn't say that, it will just make things worse
22:13:07 <hpaste> fragamus pasted “this thing prints a lot of slashes” at http://hpaste.org/54096
22:13:25 <nejucomo> phew.  My haskell-fu is finally sufficient that I can read much of the ghc source without going cross-eyed...
22:13:34 <mm_freak> SavageSimian: you may be aware of that, but you really need to go far away from thinking in objects to write haskell code successfully
22:13:36 * nejucomo hopes he's not jinxing himself.
22:13:46 <SavageSimian> SgeoN1: yea. i don't have any interest in an object oriented haskell. i'm a .NET kinda guy. mostly i'm learning haskell because it's supposed to be pure functional programming.
22:14:17 <mm_freak> SavageSimian: being a .NET guy have you looked into F#?
22:14:31 <mm_freak> F# is a functional language, which has borrowed a lot from haskell and ocaml
22:14:49 <mm_freak> it doesn't quite match haskell's power though
22:15:02 <fragamus> I was trying an example from RWH and it behaved predictably without the call to infoPath
22:15:04 <SavageSimian> i'm staying away from F# for now because it's multi-paradigm. i want to be forced to think in functional terms without being tempted to use OO as a crutch.
22:16:02 <ion> Haskell is multi-paradigm.
22:16:24 <SavageSimian> i'm comfortable with OO and would probably try to turn F
22:16:24 <mm_freak> what do you guys think about type families with phantom types for inter-module type extensibility?
22:16:38 <ion> @faq Can Haskell do OO?
22:16:39 <lambdabot> The answer is: Yes! Haskell can do that.
22:17:09 <mm_freak> data family GameEntity t
22:17:18 <mm_freak> newtype Player = Player Player
22:17:28 <mm_freak> data instance GameEntity Player = …
22:17:46 <mm_freak> the point is to have a GADT, which you can extend across modules
22:17:52 <fragamus> does anyone understand what my hpaste above is doing
22:17:53 <SavageSimian> as i understand it, any language can be made OO. C++ is just C modified with objects.
22:18:00 <kfish> mm_freak, yeah, i'm doing that in zoom-cache
22:18:10 <mm_freak> kfish: does it work well?
22:18:14 <kfish> yeah, it works
22:18:25 <kfish> it can be a bit tricky to maintain the abstraction, but it works
22:18:29 <mm_freak> great, good to know, thanks
22:18:55 <mm_freak> fragamus: could you be more specific about what exactly troubles you?
22:19:01 <kfish> eg. zoom-cache defines some general io methods and stuff, and also some default codecs; zoom-cache-pcm is a separate package which contains new, compatible codecs
22:19:05 <SavageSimian> ion: the real question is does Haskell have OO built in or is it just something Haskell can be made to do?
22:19:22 <fragamus> well, i expected it to print some paths but it printed slashes
22:19:31 <copumpkin> SavageSimian: it does not have OO built in
22:19:43 <copumpkin> also, C++ is not just C modified with objects at all
22:19:43 <parcs_> mm_freak: what will that give you?
22:19:48 <mm_freak> SavageSimian: haskell is great at domain-specific languages…  you can write an OO /library/ in haskell
22:19:57 <copumpkin> SavageSimian: also, I do not see OO as a selling point
22:20:01 <SavageSimian> copumpkin: i didn't think so.
22:20:21 <kfish> mm_freak, netwire looks cool btw :)
22:20:31 <mm_freak> SavageSimian: but again, doing OO in haskell, you could just as well use C# and forget about the better design patterns…  and again, you probably already know that =)
22:20:48 <SavageSimian> copumpkin: that's why i want to investigate FP. to be able to gain a new perspective as an alternative to OO.
22:20:49 <mm_freak> parcs_: a GADT, which i can extend across modules and packages
22:21:02 <SavageSimian> mm_freak: yes
22:21:03 <mm_freak> kfish: =)
22:21:05 <parcs_> mm_freak: why would you want that?
22:21:19 <mm_freak> parcs_: game objects, UI widgets, etc.
22:21:45 <mm_freak> not to say i would do it that way…  i was just wondering whether you can write extensible types that way
22:22:12 <SavageSimian> or simply so that i can write better multi-paradigm apps...
22:22:38 <parcs_> i don't see the utility in that.. but i'll cease asking questions and think about it more :P
22:23:07 <mm_freak> SavageSimian: the easiest way to get insight is to go ahead and write programs…  don't worry about using the wrong paradigm for a problem…  i change my paradigms every six months or so =)
22:23:33 <rwbarton> if my program has "537 MB total memory in use" (+RTS -sstderr) then why does the graph I made with hp2ps top out at around 24 MB?
22:23:52 <mm_freak> parcs_: when defining a GADT for game objects, you have to completely specify it…  another author cannot change the type in any way in his own library
22:24:01 <mm_freak> parcs_: to change the type, he needs to fork your library
22:24:36 <mm_freak> parcs_: a weaker variant of that is that i just want to be able to spread a type definition across multiple modules
22:25:03 <mm_freak> so that when i write a TextWidget module, i define both the type instance and the functions there
22:25:05 <parcs_> mm_freak: i think type classes + associated types would be more useful no?
22:25:22 <applicative> darn lambdabot wont let me rewrite this pleasing 'sparkline' maker https://github.com/Mgccl/mgccl-haskell/blob/master/random/spark.hs
22:25:28 <mm_freak> parcs_: they solve a different problem
22:25:40 <mm_freak> parcs_: consider this:  drawWidgets :: [Widget] -> IO ()
22:25:41 <SavageSimian> mm_freak: i tried that with F# and found that i didn't like FP very much. however, i'm thinking that the main reason i didn't like it was because i was unfamiliar with it. it's like learning to write left-handed. if you tie the rh behind your back you'll learn it whether you like it or not... :p
22:26:34 <SavageSimian> assuming of course, that you're right-handed to begin with...
22:27:19 <SavageSimian> if i started out with haskell instead of C++ i'd probably dislike OO
22:27:19 <mm_freak> SavageSimian: i'd say it's fine to start with imperative code in haskell
22:27:25 <mm_freak> haskell is a great imperative language
22:27:55 <SavageSimian> mm_freak: i'm sure it is. but, that's not really my goal.
22:28:10 <mm_freak> you will pick up functional style along the way, because even for imperative programming in haskell you will use combinator style a lot
22:28:12 <mike-burns> You don't have to dislike other paradigms. It's totally acceptable to like all of them, even.
22:28:22 <SavageSimian> imperative languages are a dime a dozen.
22:28:38 <parcs_> mm_freak: is it data Widget = forall a. Widget (WidgetFamily a), and data family WidgetFamily a ?
22:29:02 <mm_freak> parcs_: i'm not sure…  haven't put much thought into that yet…  it was really just an idea
22:29:17 <applicative> > > "▁▂▃▄▅▆▇"
22:29:18 <lambdabot>   <no location info>: parse error on input `>'
22:29:22 <applicative> >  "▁▂▃▄▅▆▇"
22:29:23 <lambdabot>   "\9601\9602\9603\9604\9605\9606\9607"
22:29:26 <parcs_> if you extend WidgetFamily how will the library know how to draw it?
22:29:40 <SavageSimian> mike-burns: it's not really whether i have to or don't. i just don't like FP. i want to change that.
22:29:47 <applicative> > text  "▁▂▃▄▅▆▇"  --  : (
22:29:48 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
22:29:50 <parcs_> with type classes + associated types you can extend WidgetFamily and define how to draw it, and whatever else
22:30:09 <mm_freak> parcs_: that's a different problem…  the problem i'm trying to solve is really just the extensibility problem
22:30:13 <parcs_> oh
22:30:29 <mm_freak> and it's not even like i'm really trying…  i'm just considering =)
22:30:50 <parcs_> the extensibility seems ultimately useless though. (i'm probably wrong :))
22:30:54 <mm_freak> anyway, one way to solve the other problem is to use an associated type, but a 'data' instead of a 'type'
22:31:13 <mm_freak> you still need the existential type, but now you have an extensible type
22:31:30 <mm_freak> every module can define a new type instance along with operations for it
22:31:36 <parcs_> yeah
22:32:04 <kfish> that's what i'm doing: data families and existential wrappers
22:32:44 <mm_freak> kfish: well, i'm wondering whether it makes sense to do that…  you could just as well use a type class only
22:32:52 <parcs_> kfish: do you have a source link?
22:33:32 <mm_freak> data Widget = forall a. Drawable a => Widget a
22:33:50 <parcs_> never mind, found it
22:33:54 <nejucomo> So I'm reading the source for GHC.Event in ghc7.2.
22:33:54 * hackagebot msgpack-rpc 0.6.1.2 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.6.1.2 (HideyukiTanaka)
22:37:21 <nejucomo> Rather than storing a TimeoutQueue) and modifying it in the main loop, it stores (TimeoutQueue -> TimeoutQueue).  Does anyone know why this is?
22:37:46 <nejucomo> I have a vague recollection it's related to performance, but I haven't found the paper on its design...
22:40:33 <parcs_> nejucomo: see the source of GHC.Event.Manager
22:40:45 <parcs_> it has three paragraphs explaining why
22:45:15 <nejucomo> parcs_: Thanks. I am looking at the source, but I missed that part.  (Maybe I should actually look at the comments.  ;-)
22:46:21 <applicative> "... This problem is known as "floating garbage""
23:09:06 <nejucomo> This looks like a fun read: http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
23:10:01 <shachaf> This looks like a fun read: "zomg #haskell is the best channel ever!"
23:10:17 <shachaf> Wow, that *was* fun. I feel thoroughly self-satisfied.
23:24:15 <SavageSimian> data BookInfo = Book Int String [String] - in this would it be appropriate to say that 'Book' is a constructor for the BookInfo type?
23:24:34 <byorgey> SavageSimian: yes
23:24:34 <shachaf> SavageSimian: Yep.
23:24:56 <shachaf> SavageSimian: (Of course, "constructor" means something very different from OO languages, if you're still looking for that analogy. :-) )
23:25:20 <SavageSimian> shachaf: can you expand on that?
23:26:00 <SavageSimian> i'm thinking constructor as similar to defining the fields of a struct.
23:26:09 <shachaf> Well, it's just not the same thing. It constructs a value whose type is BookInfo when you give it an Int and a String and a [String].
23:26:51 <SavageSimian> shachaf: i'm not sure i see the distinction.
23:27:12 <shachaf> I guess there is some similarity.
23:27:14 <SavageSimian> that sounds pretty much like what a constructor for a class does.
23:27:37 <shachaf> A constructor in OO languages is a some function that runs arbitrary code.
23:28:08 <shachaf> Book is a thing that gets a few arguments and gives you a BookInfo with them. You can also pattern-match on it.
23:29:50 <SavageSimian> i would say that a constructor in OO initializes the state of an instance of a type. i'm not sure that's any different than saying that an instance of BookInfo is initialized to an Int, a String, and a [String]...
23:30:43 <SavageSimian> i'm still not familiar with pattern matching so can't really apply it to what i've learned so far.
23:31:10 <shachaf> SavageSimian: You can define a function f :: BookInfo -> Int; f (Book i _ _) = i
23:31:32 <mike-burns> There is a ton of overlap between proper OO (like, Smalltalk-style or even Ruby-style) and proper FP.
23:31:37 <mike-burns> I bet you've noticed that now.
23:32:12 <shachaf> mike-burns: Well, a ton of overlap in the sense that there exist things that you generally want to do, which you can do in both of them? :-)
23:32:22 <SavageSimian> mike-burns: i have noticed it but it seems that ppl discourage thinking of FP in OO terms.
23:32:35 <mike-burns> SavageSimian: Yeah, but those people think OO means Java.
23:33:02 <shachaf> More importantly, even if this particular analogy can be made to work, I'd say that just because a word X is used for something in Haskell, that doesn't mean it means the same thing as X in most OO languages.
23:33:04 <mike-burns> Or C++.
23:33:04 <ujm> is it possible to use guards in where statements?
23:33:12 <shachaf> mike-burns: They do?
23:33:18 <SavageSimian> mike-burns: eek. did you just use that dirty 'J*' word?
23:33:19 <shachaf> ujm: Yep.
23:34:01 <shachaf> mike-burns: Saying "Haskell classes, instances, methods, etc. don't really correspond to OO classes, instances, methods, etc." is hardly saying "OO is bad". :-)
23:34:02 <mike-burns> Oh sure, the words all mean different things, but the concepts are all very similar, beyond just "you can write code in it".
23:35:16 <mike-burns> Constructors in Haskell are very similar to case classes in Scala. It's dangerous to take that too far, but it's good to get going. Similarly typeclasses in hs vs interfaces in Java.
23:36:04 <shachaf> mike-burns: In one sense, yes. But there are many things you'd do with interfaces in Java that you wouldn't use type classes to do in Haskell (because there are better ways).
23:36:15 <SavageSimian> basically, i don't really see the concept of a constructor or a type as an OO exclusive term. i could see where the concepts would overlap and still have pretty much the same meaning in both paradigms.
23:36:17 <mike-burns> Yes, agreed.
23:36:40 <mike-burns> But writing code even though there's a better way to do it is just what we do.
23:36:46 <shachaf> mike-burns: I'm not saying the analogies don't exist, but I don't think trying to make a one-to-one correspondence with OO concepts is a good way to learn Haskell concepts.
23:37:10 <mike-burns> Depends on the person.
23:37:34 <mike-burns> If they've come here to lean how OO differs from FP, comparisons are going to be made.
23:38:34 <SavageSimian> shachaf: actually, to say the idea of a constructor is not the same in FP as it is in OO only serves to confuse. i don't really need to refer to OO just to think about some type of construction going on in and instance of something.
23:39:09 <shachaf> SavageSimian: In that case, sure. I have no objection to the word "constructor", certainly.
23:39:49 <shachaf> Earlier you (I think? Unless it was someone else) were making OO analogies that seemed misleading, so I thought I'd clarify.
23:40:06 <mike-burns> I even think it's useful to see the implementaion of e.g. the sum of a recursively-defined list data structure in both Haskell and some OO.
23:40:48 <SavageSimian> shachaf: i don't know if analogy is the right word. i was associating the concept with something that i'm already familiar with which happens to be in the context of OO.
23:42:36 <SavageSimian> i can't offhand thing of any place else where i would use the concept of construction as an initializer other than programming and since my experience originates in OO that would naturally be the context that i would associate with the idea.
23:44:47 <SavageSimian> my objective would be to understand construction in the FP context well enough to be able to distinguish it from the same concept in an OO context.
23:45:09 <mike-burns> http://pastie.org/2871105 - here's the list comparison I alluded to earlier.
23:46:37 <mike-burns> Construction differs in what is being constructed. In Haskell you are constructing values; in OO, instances of classes.
23:46:58 <mike-burns> And there the difference is that values have no inherent behavior, but instances have behavior.
23:48:13 <mike-burns> It's mostly an inversion of data and functionality. In OO the behavior goes on the data; in FP the data is applied to the behavior.
23:48:24 <silver> because in FP values don't have morphisms bundle with them
23:48:39 <SavageSimian> ok. i understand. but wouldn't something like ThingType = Thing f (a) be a type with inherent behavior?
23:48:57 <silver> what's behavior?
23:49:07 <shachaf> SavageSimian: What are those parentheses doing?
23:49:08 <SavageSimian> f (a)
23:49:19 <mike-burns> I'm confused by your syntax.
23:49:20 <shachaf> Is that supposed to be "the function f applied to the value a"?
23:49:27 <SavageSimian> nothing. it's a function with a generic argument.
23:49:38 <SavageSimian> shachaf: yes
23:49:44 <silver> in type definition you have _type_ variables
23:49:47 <silver> bot value variables
23:49:50 <shachaf> Function application in Haskell is "f x", not "f (x)". :-) Sometimes you need to group that, as in "(f x)".
23:49:55 <shachaf> And anyway that's not how datatypes work.
23:50:08 <shachaf> They just contain data. Nothing more.
23:50:12 <silver> (well not until dependent types)
23:50:15 <SavageSimian> for me the parens are more habit than anything else.
23:50:26 <shachaf> SavageSimian: Maybe GADT syntax will clarify things for you.
23:50:31 <ion> “Thing f (a)” is a redundant way to say “Thing f a”.
23:50:44 <shachaf> data Book where { MkBook :: Int -> String -> [String] -> Book }
23:50:50 <mike-burns> You can store functions as data, which can also be used in an OO manner, and sometimes this makes sense to do.
23:51:33 <shachaf> That's the actual type of the constructor MkBook. You don't write the implementation -- GHC will do that for you, and there only exists one reasonable behavior for this function.
23:51:38 <SavageSimian> mike-burns: that was my point. if you store the function as data how is that any different than defining a behavior for a type?
23:51:53 <silver> it's not bundled to a type
23:52:10 <mike-burns> Encapsulation, to use OO terminology.
23:52:37 <silver> a -> [a] will work on any type a
23:52:37 <mike-burns> But you can do OO in any language, just as you can do FP in any language.
23:52:47 <silver> and this type don't have to relate anyhow
23:52:53 <shachaf> Is that a challenge?
23:53:04 <mike-burns> Hah, I didn't think it was ...
23:53:21 <silver> s/this type/possible types
23:53:52 <SavageSimian> getting late here. thanks for the help guys.
23:53:57 <mike-burns> Good luck.
