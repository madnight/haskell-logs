00:49:08 <bwright> How do I write a function f^n that represents f . f .. f (n-fold composition).
00:49:41 <shachaf> foldr (.) id (replicate n f)?
00:55:37 <cads> :D
00:55:38 <ion> @type \f -> ala Endo foldMap (replicate 10 f)
00:55:38 <bwright> So is that the simplest way to replicate n-folds?
00:55:38 <lambdabot> Not in scope: `foldMap'
00:55:38 <ion> @type \f -> ala Endo Data.Foldable.foldMap (replicate 10 f)
00:55:38 <lambdabot> forall a. (a -> a) -> a -> a
00:55:38 <shachaf> \z -> iterate f z !! n? I think that might have some strictness issues or something.
00:55:38 <ion> > ala Endo Data.Foldable.foldMap (replicate 10 (+2)) 4
00:55:38 <lambdabot>   24
00:55:38 <shachaf> I don't know if there's a simple library function for it. You could write one easily enough.
00:55:40 <cads> you can reduce the complexity from linear to log
00:55:41 <bwright> thanks.
00:55:42 <cads> not sure how you'd do it with higher order functions
00:55:42 <shachaf> cads: You can?
00:55:42 <cads> but f^(2n) = f^(n) . f^(n)
00:56:13 <shachaf> cads: How does that help you?
00:57:12 <Gothmog_> shachaf: you might want to google for the double-and-add method.
00:57:23 <shachaf> Gothmog_: How does this help you with function composition?
00:57:32 <Axman6> yeah, it doesn't save any work :\
00:57:50 <Axman6> > ((+1) ^ 3) 7
00:57:51 <lambdabot>   512
00:58:04 <Axman6> > ((+1) ^ 3) 1
00:58:06 <lambdabot>   8
00:58:14 <Axman6> > ((+1) ^ 3) x
00:58:15 <lambdabot>   (x + 1) * (x + 1) * (x + 1)
00:58:22 <Axman6> oh right
00:58:30 <Axman6> > ((+1) ^ 8) 2
00:58:30 <lambdabot>   6561
01:00:01 <Axman6> anyway, f . f can't be evaluated any more than that at runtime. x * x can, and the result can be reused, but you get no advantage from doing it with function composition
01:00:21 <Axman6> hmm, well, unless n is large, you spend less time computing it... hmm
01:00:51 <cads> I was thinking, for example, f^(16) = g.g, where g = h.h, where h = i . i, where i = f.f.   i = f^2, h = f^4, g = f^8
01:00:55 <dmwit> The savings you get on constructing the spine of applications of (.) to f is almost certainly going to be negligible next to the cost of actually running f n times (which this trick doesn't help with).
01:01:05 <shachaf> Right.
01:01:22 <cads> and you've only done four compositions
01:01:45 <dmwit> cads: Unfortunately, though you've only done four compositions, actually executing the resulting composed function still runs f 16 times.
01:01:56 <cads> but for all I know g is still evaluated the same way f.f.f.f.f.f.f.f would be
01:02:27 <cads> ah okay
01:04:32 <cads> heh, so this only works on the 'paper and pen' programming language, where there algebra of functions that f lives in lets you simplify f^(n) to something as simple as f itself
01:06:11 <cads> say f is an affine transform and composing f^(n) corresponds to actually multiplying some matrices together
01:07:31 <cads> then the trick would work to reduce the number of times you have to reduce a function to its canonical form or whatever
02:01:12 * hackagebot hsndfile 0.5.2 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.5.2 (StefanKersten)
02:01:14 * hackagebot hsndfile-vector 0.5.2 - Haskell bindings for libsndfile (Data.Vector interface)  http://hackage.haskell.org/package/hsndfile-vector-0.5.2 (StefanKersten)
02:01:16 * hackagebot hsndfile-storablevector 0.5.2 - Haskell bindings for libsndfile (Data.StorableVector interface)  http://hackage.haskell.org/package/hsndfile-storablevector-0.5.2 (StefanKersten)
02:01:18 * hackagebot Geodetic 0.4 - Geodetic calculations  http://hackage.haskell.org/package/Geodetic-0.4 (TonyMorris)
02:11:12 * hackagebot nonlinear-optimization 0.3.5.1 - Various iterative algorithms for optimization of nonlinear functions.  http://hackage.haskell.org/package/nonlinear-optimization-0.3.5.1 (FelipeLessa)
02:33:12 <kowey> hello #haskell! is hs-plugins still the way to go if I want people to be able to write plugins for my Haskell program?
02:36:29 <shachaf> kowey: I was under the vague impression that it wasn't.
02:36:39 <shachaf> But I don't know much about it.
02:52:03 <newbeginner> hello
02:52:41 <shachaf> Good afternoon.
02:52:42 <aavogt> hi
03:02:20 <hpaste> newbeginner pasted “Order Tree” at http://hpaste.org/54365
03:03:46 <newbeginner> hello can anyone help me with this: http://hpaste.org/54365
03:05:38 <mauke> yes!
03:05:41 <mauke> what's your question?
03:07:38 <jem|osx> is there a way to write a function where it lists the fibonacci numbers between 2 given numbers?
03:08:03 <mauke> yes
03:08:28 <jem|osx> what should I use?
03:08:34 <mauke> dropWhile, takeWhile
03:08:45 <mauke> and a list of all fibonacci numbers
03:12:50 <newbeginner> does anyone know about order trees
03:13:13 <mauke> yes! what's your question?
03:14:18 <newbeginner> <mauke> I posted it here: http://hpaste.org/54365
03:14:30 <mauke> I never said that
03:14:36 <mauke> and there's no question there
03:16:46 <newbeginner> [mauke] ... ok sorry, 4got to paste it, I 'm trying define an order tree
03:16:54 <mauke> I know
03:16:54 <Phyx-> oh give him a break mauke, he even used your beloved hpaste :P
03:17:01 <mauke> I don't love hpaste
03:17:19 <mauke> newbeginner: why do you keep putting brackets around my name?
03:17:39 <osfameron> and different brackets every time
03:17:47 <Axman6> {mauke} isn't it the cool thing to do?
03:17:59 <mauke> «Axman6» is it now?
03:18:03 <newbeginner> o so u know I'm talking to u.. i'm new to yhis
03:18:10 <mauke> you can just use my name
03:18:11 <Phyx-> lol
03:18:17 <Axman6> “mauke” yes it is
03:18:30 <Phyx-> %mauke% indeed
03:18:41 <mauke> 「Phyx-」 intredasting
03:18:44 <newbeginner> ok mauke
03:19:20 <int-e> ⟧Axman6⟦ this could be fun.
03:19:28 <Phyx-> @mauke@ interdasting... that's a new one for me
03:19:28 <lambdabot> Unknown command, try @list
03:19:41 <Axman6> ≤Phyx-≥ I reminds me of doing stuff in rails
03:19:56 <Axman6> that*
03:20:13 * Axman6 shouldn't change sentenses half way through and forget to re-read them
03:20:20 <Phyx-> lol
03:20:24 <newbeginner> mauke w/ the parts I have so far, I keep getting an error w/ my guard at line: compare tree1 tree2  = Ordering | tree1 == tree2 = EQ -- One of the Ordering values
03:20:29 <Phyx-> newbeginner started a trend
03:20:39 <mauke> newbeginner: you should get an error on line 14
03:20:51 <mauke> and that's not a guard
03:20:57 <Axman6> newbeginner: what is Ordering supposed to do there?
03:21:09 <Axman6> hint, that
03:21:15 <Axman6> that's not how you write guards*
03:21:30 <newbeginner> how phyx
03:21:54 <Phyx-> newbeginner: padding nicknames with symbols
03:21:55 <Axman6> compare tree1 tree2 | tree1 == tree2 = EQ
03:22:05 <mauke> newbeginner: I get: `Ord' is applied to too many type arguments in the instance declaration for `Ord (Tree a) Ord Tree'
03:22:38 <Axman6> uh, yeah, that's pretty broken too. completely missed that
03:22:41 <Phyx-> whoops... he pressed F4
03:22:42 <Axman6> and he's gone
03:22:43 <Phyx-> err
03:22:46 <Phyx-> Alt + F4
03:23:23 <frerich> Or he discovered "/join 0"
03:23:28 <newbeginner> back
03:23:29 <jem|osx> and mauke how can I generate a list of fib numbers?
03:23:32 <Phyx-> wb
03:23:50 * Phyx- predicts mauke will answer "with a function"
03:23:56 <Axman6> jem|osx: be prepared for a boatload of ways... it's what we love to do in haskell!
03:24:06 <shachaf> frerich: "/join 0"?
03:24:08 <jem|osx> lol
03:24:14 <mauke> jem|osx: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
03:24:23 <jem|osx> oh
03:24:33 <Phyx-> :O
03:24:43 <shachaf> Oh, I didn't know about that.
03:25:12 <Axman6> > let fibs = fix (\f a b -> a : f b (a+b)) 0 1 in fibs
03:25:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
03:25:19 <shachaf> > fix((1:).scanl(+)1)
03:25:20 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
03:25:22 <Axman6> shachaf: see, I understand fix :P
03:25:34 <newbeginner> mauke did u understand my question or problem?
03:26:04 <mauke> newbeginner: did you understand why line 14 is wrong?
03:26:15 <shachaf> Axman6: Well, I didn't dispute that. But understanding how to use fix isn't the same as understanding how Y works.
03:26:15 <mauke> newbeginner: and you haven't asked a single question yet
03:26:24 <shachaf> In particular fix is completely different from Y except that it behaves exactly the same.
03:26:44 * Axman6 wants to @remember "fix is completely different from Y except that it behaves exactly the same."
03:26:53 <shachaf> mauke: "mauke did u understand my question or problem?"
03:26:55 <cads> shachaf: HAH
03:27:09 <mauke> shachaf: but that refers to a previous question
03:27:12 <mauke> it's not a letrec
03:27:29 <shachaf> mauke: True, but you said "haven't", not "hadn't".
03:27:39 <osfameron> newbeginner: it looks like you've posted a homework question?  That's OK, but you say what you've already tried and which part exactly you've got stuck on.
03:27:50 <cads> shachaf: I feel like that set me back in understanding
03:28:00 <newbeginner> mauke I did but I got disconnected, maybe u didn't c it let rewrite it
03:28:05 <cads> shachaf: spectacularly
03:28:23 <mauke> the last thing I said was <mauke> newbeginner: I get: `Ord' is applied to too many type arguments in the instance declaration for `Ord (Tree a) Ord Tree'
03:28:44 <cads> like, my mind has been wiped and now all I know about the Y combinator and the fix function is that they're completely different but act the same
03:29:58 <newbeginner> ya I am having a problem on line 15 mauke and osfameron
03:30:37 <Axman6> newbeginner: get rid of "Ord Tree" on that line
03:30:45 <newbeginner> my last error is parse error on input `|'
03:30:52 <Axman6> you should just have instance Eq a => Ord (Tree a) where
03:30:57 <mauke> Axman6: there is no "Ord Tree" on line 15
03:31:06 <mauke> Axman6: and it should be Ord a
03:31:34 <Axman6> mauke: i'm not sure it should. It depends on whether ordering is based on the elements, or the sizes of the trees
03:31:51 <mauke> how could it be based on the sizes?
03:31:53 <Axman6> which the comments for min and max seems to suggest it should be
03:32:02 <mauke> no, it doesn't
03:32:05 <erus`> whats the difference between infixr and infixl?
03:32:09 <Axman6> no, i guess not
03:32:13 <mauke> erus`: right associative, left associative
03:32:30 <erus`> 1 + 1 = + 1 1
03:32:36 <Axman6> erus`: ((a + b) + c) + c vs a + (b + (c + d))
03:32:48 <mauke> erus`: ?
03:32:49 <Axman6> (though, in the other order)
03:33:36 <Axman6> erus`: it's got to do with how you parse a + b + c + d. if it's infixl, you get ((a + b) + c) + d and if it's infixr you get a + (b + (c + d))
03:33:51 <erus`> aha
03:33:57 <Axman6> so, you want things like (++) to be infixr
03:34:17 <aristid> and for (+) it doesn't really matter that much because it's associative
03:34:39 <Axman6> but usually (+) is left associative right?
03:35:12 <Axman6> s/right/correct/ -- to make that sentense less confusing
03:35:25 <erus`> ", correct?"
03:35:41 <sipa> but (+) and (-) have the same priority level
03:36:11 <aristid> sipa: ok yeah then you probably want left assocativity
03:36:15 <int-e> of course in the case of (+) it's not supposed to matter :)
03:36:19 <erus`> can you have an infixr and an infixl with the same priority? (i forget the proper word)
03:36:28 <opqdonut> erus`: no, ghc will complain
03:36:35 <opqdonut> and the term is precedence
03:36:42 <erus`> yeah that makes sense :)
03:36:51 <int-e> (I do realise that the floating point Num instances have a non-associative (+) though)
03:37:11 <aristid> int-e: use CReal, man ;)
03:37:48 <int-e> aristid: I was going to answer but then I noticed the smiley.
03:38:42 <aristid> int-e: you got any gripes with CReal other than it being slow? :)
03:39:05 <newbeginner> axman6 I tried what u said but I am still getting the same error
03:39:09 <KitB> @hoogle maxBy
03:39:09 <lambdabot> No results found
03:39:11 <KitB> Bah
03:40:02 <aristid> @src max
03:40:02 <lambdabot> max x y = if x <= y then y else x
03:40:29 <osfameron> @src maxHeadroom
03:40:30 <lambdabot> Source not found. Sorry.
03:40:31 <aristid> @pl maxBy (<=) x y = if x <= y then y else x
03:40:31 <lambdabot> (line 1, column 16):
03:40:32 <lambdabot> unexpected "="
03:40:32 <lambdabot> expecting variable, "(", operator or end of input
03:40:48 <aristid> @pl \(<=) x y = if x <= y then y else x
03:40:49 <lambdabot> (line 1, column 3):
03:40:50 <lambdabot> unexpected "<"
03:40:50 <lambdabot> expecting pattern
03:40:55 <shachaf> @Pl maxBy f x y = if f xy then y else x
03:40:55 <lambdabot> maxBy = flip . if' . ($ xy)
03:40:57 <int-e> aristid: No. But it's slow. :)
03:41:19 <aristid> shachaf: pl can't deal with operator parameters? :(
03:41:53 <aristid> i think that function is flip (??)
03:42:05 <aristid> :t \(<=) x y = if x <= y then y else x
03:42:07 <lambdabot> parse error on input `='
03:42:12 <aristid> LOL stupid me
03:42:16 <aristid> :t \(<=) x y -> if x <= y then y else x
03:42:18 <lambdabot> forall t. (t -> t -> Bool) -> t -> t -> t
03:42:37 <aristid> hmmm
03:42:42 <aristid> no it's not
03:43:31 <newbeginner> mauke Ord can only take 1 arguement or parameter
03:43:57 <aristid> newbeginner: ()
03:45:25 <newbeginner> what does that do aristid
03:46:35 <mauke> newbeginner: uh, ok?
03:46:37 <mauke> newbeginner: what?
03:47:02 <aristid> newbeginner: you can add parantheses to make it be 1 argument
03:48:45 <newbeginner> ok
03:49:31 <newbeginner> but my error seems to w/ the guard: parse error on input `|'
03:49:55 <newbeginner> I'm not sure y
03:50:14 <Axman6> hmm, is there any other haskell syntax that enforces a type on expressions placed in them apart form if and guards?
03:50:39 <Axman6> newbeginner: compare tree1 tree2 | tree1 == tree2 = EQ
03:50:45 <mauke> newbeginner: because you don't have a guard
03:50:50 <mauke> newbeginner: you just put a | somewhere in your code
03:51:27 <Axman6> the = in guards comes after the | and the boolean expression. and I don't know why you put in the Ordering on like 15
03:51:41 <Axman6> foo | bexp = result
03:52:03 <mauke> Axman6: various parts of list comprehensions
03:52:11 <Axman6> ah yes
03:52:20 <Axman6> though, is the only type enforced there also Bool?
03:53:02 <Axman6> what a horrible sentense
03:54:41 <aavogt> > case () of _ | True <- True, let x = 5 -> x
03:54:43 <lambdabot>   5
03:55:55 <mauke> Axman6: also lists
03:56:15 <Axman6> oh right, obviously
03:56:22 <Axman6> though, not for long, heh
03:56:24 <jem|osx> ok I'm really bad at this since I just started with haskell 2 weeks ago
03:56:33 <newbeginner> mauke and axman6 I am  using this as example for writing the guards: http://learnyouahaskell.com/syntax-in-functions#guards-guards which seems to implie I can write it like that
03:56:37 <jem|osx> this is totally wrong isn't it? http://pastebin.com/GFNSAf9w
03:56:38 <mauke> The paste GFNSAf9w has been copied to http://hpaste.org/54366
03:56:50 <mauke> newbeginner: I don't see how that corresponds to your code
03:57:05 <mauke> jem|osx: yes, that looks like three different things, all named 'fibs'
03:57:09 <Axman6> newbeginner: your code really doesn't look like the code on that page though...
03:57:12 <aavogt> > case () of _ | [] -> 1 | otherwise -> 2 -- this is possible mauke?
03:57:14 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:57:14 <lambdabot>         against inferred type ...
03:57:45 <jem|osx> so does it have to be 3 different functions?
03:57:50 <Axman6> jem|osx: first define fibs, then define fibsBetween :: Integer -> Integer -> [Integer]
03:57:56 <Axman6> why three?
03:57:59 <mauke> jem|osx: fibs isn't even a function
03:58:01 <mauke> it's a list
03:58:05 <jem|osx> yeah
03:58:48 <jem|osx> if I get it correctly, the second line generates the list right?
03:58:56 <Axman6> jem|osx: what's the , doing there?
03:59:00 <Axman6> did you mean .?
03:59:07 <Axman6> no
03:59:16 <mauke> jem|osx: yes
03:59:19 <Axman6> (well, you did, but you're doing something else wrong)
03:59:20 <newbeginner> axman6 yes I was just trying under why I get that error
03:59:47 <jem|osx> so how do I drop all the numbers outside the two given numbers?
04:00:00 <newbeginner> I think its indent issue but I am not sure
04:00:01 <jem|osx> I know it could be done with drop and take but I'm not sure how
04:00:02 <Axman6> jem|osx: you seem to be treating take and drop as if they are modifying fibs, but you cannot modify anything in haskell*
04:00:07 <mauke> jem|osx: no, it can't
04:00:26 <Axman6> you want dropWhile and takeWhile
04:00:27 <jem|osx> ah..
04:00:36 <ichor_> Hello everyone, I'm trying to use sockets in Haskell on FreeBSD, but the program only listens on localhost, not the network address.
04:00:59 <jem|osx> and the syntax?
04:01:08 <mauke> jem|osx: they have no special syntax
04:01:13 <mauke> they're not keywords
04:01:23 <Axman6> :t dropWhile
04:01:23 <pesco> which iteratee package should i use, "iteratee" or "enumerator"?
04:01:24 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:01:48 <ichor_> On my linux box everything is fine. And other programs, like netcat, has the correct behaviour on FreeBSD. Any ideas?
04:01:52 <Axman6> pesco: IterIO is good too. if you need to pick between those, enumerator is probably the better choice
04:02:12 <mauke> ichor_: does freebsd have anything like strace?
04:02:27 <pesco> Axman6: had not heard of IterIO.
04:03:00 <Axman6> mauke: it's got dtrace
04:03:06 <Axman6> o/ TacticalGrace
04:03:41 <ichor_> mauke, not sure. Not sure what strace is. What would I use it for here?
04:04:16 <mauke> seeing what happens at the syscall level
04:04:25 <mux> FreeBSD has something similar to strace that you can use: ktrace/kdump; you can also install strace from ports but you'll have to have procfs mounted.
04:05:19 <ichor_> mux, yeah, strace also requires i386, and I have amd_64.
04:05:32 <mux> it does? oh well, use ktrace then
04:06:22 <Axman6> of dtrace :\
04:06:36 <newbeginner> axman6  and mauke my code is suppose to be similar to the trafficlight in : http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
04:06:41 <mux> dtrace is quite different
04:06:55 <Axman6> man -k dtrace to find the relevant scripts
04:07:50 <ichor_> thanks everyone, I'll look into ktrace and dtrace and see if I can figure out what's going on.
04:08:46 <mux> btw, your symptom just sounds like you didn't use INADDR_ANY as you should*
04:10:10 <ichor_> mux, I'm using the high level interface, I'm not sure where INADDR_ANY would go there.
04:11:06 <mauke> listenOn binds to iNADDR_ANY
04:20:34 <KitB> @hoogle iterateM
04:20:34 <lambdabot> No results found
04:20:36 <KitB> Bah
04:21:07 <rostayob> kmc: you mentioned some time ago an alternative to Haskell "taint" model of IO with similar expressiveness
04:21:13 <rostayob> kmc: but i forgot
04:23:04 <pesco> Axman6: so, would you suggest iterIO yet over iteratee or enumerator? i read the intro, but i'm not familiar enough with either really to judge...
04:26:03 <rostayob> pesco: enumerator seems to be the "standard" enumerator library
04:26:20 <rostayob> i think that iterIO is more bound to.. IO as the name suggests
04:26:54 <rostayob> while enumerator is just the base data types and the related functions
04:27:16 <newbeginner>  mauke or axman6 should line 15 be like this: compare tree1 tree2  | tree1 == tree2 = EQ -- One of the Ordering values
04:27:19 <rostayob> well + some other stuff (Text, IO, etc)
04:27:32 <rostayob> but most libraries that use enumerators are based on enumerator
04:28:49 <Axman6> newbeginner: yes, like i told you earlier
04:29:33 <Axman6> pesco: IterIO makes a bit more sense, but enumerator is pretty easy to use too. though you're quite a bit closer to the workings when using enumerator
04:30:52 <newbeginner> axman6 but now I get this: Ambiguous occurrence `EQ'
04:30:58 <rostayob> iterIO also has an impressive documentation
04:31:44 <newbeginner> I am to refer to data ordering eq  axman6
04:31:49 <Axman6> newbeginner: you should probably comment out the line data Ordering = ... because Ordering is already defined in the standard prelude
04:36:17 * hackagebot parsec1 1.0.0.4 - Portable monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.4 (ChristianMaeder)
04:40:32 <ichor_> So, regarding my socket problems: ktrace tell me that my program's bind and listen calls are a bit different from the ones of "netcat -l".
04:40:59 <ichor_> But I'm not quite sure how to see what exactly these differences mean.
04:41:22 <ichor_> I've pasted them here: http://hpaste.org/54368
04:46:08 <spring> Whats a bangpattern? Thanks
04:46:49 <ichor_> Does somebody have any hints or ideas? I'm using listenOn, so I'm a bit stumped at what I can change in my code.
04:47:20 <frerich> spring: http://bit.ly/tcdMNe
04:48:17 <rostayob> spring: in short, is syntactic sugar to introduce strictness without using seq
04:49:04 <spring> Thanks rostayob (the expl helps)
04:50:58 <mux> ichor_: I think I know what happens here
04:51:59 <mux> ichor_: IPv6
04:52:26 <mux> ichor_: the third parameter to the bind() syscall in your traces is the socklen_t parameter telling the size of the struct sockaddr_*
04:52:49 <mux> ichor_: your program passes 1C == 28 bytes, the size of struct sockaddr_in6
04:53:02 <mux> ichor_: nc -l passes 10 == 16 bytes, size of struct sockaddr_in4
04:53:37 <mux> so it looks like the high-level listenOn API decided IPv6 was a better choice than IPv4 somehow
04:54:05 <ichor_> mux, ah, that would explain it.
04:54:29 <mux> you can easily verify this hypothesis using sockstat -l
04:54:38 <mux> but I'm like 99% sure this is your problem.
04:55:36 <ichor_> Yeah, sockstat -l verifies your hypothesis :)
04:56:31 <ichor_> So, i guess I must use the low-level api, to force IPv4?
04:56:59 <ichor_> Or can I convince the high-level api to use IPv4?
04:57:08 <mux> well, the documentation talks about some IPv6Only socket option so maybe there's a way around it using the high-level API, but I don't know how
04:57:23 <mux> and reading the code, I don't see how it could either...
04:58:09 <mux> the listenOn code is indeed far from being optimal
04:58:34 <mux> it tries to filter the addresses returned by getaddrinfo() to only keep v6 addresses; if it has some, it goes with the first one
04:58:35 <erus`> http://letmebingthatforyou.com/?q=haskell%20bangpattern
04:58:37 <erus`> hurrr
04:58:44 <mux> if it cannot find any, it goes with the first IPv4 address
04:58:51 <mux> this is pretty much useless if you ask me
04:59:15 <mux> ichor_: reading this, I would advise using the low-level API
04:59:47 <ichor_> yeah, either that, or try to make my network use IPv6...
05:00:28 <mux> that being said, it is quite regrettable that the DNS lookup request ends up receiving invalid IPv6 addresses
05:00:48 <mux> but listenOn would be a lot more useful if one could have more control over this
05:01:49 <ichor_> Yeah, it should realise that what it chooses will not be the best choice in any case.
05:02:52 <mux> and letting you pass a AddrInfo -> Bool predicate, for instance
05:04:28 <ichor_> mux, thanks so much for your help. I'll set off to figure out how to use the low-level API.
05:04:39 <mux> you're welcome
05:10:27 <docTony> Is there a strict version of a foldM ? Or is there a way to tell Haskell that it can delete something from memory? I ask this because I work with a very large set of files and ghc keeps stuff in memory too long and I know it is not going to need it...
05:11:46 <zhulikas> getStdRandom (randomR (1, 10))
05:11:51 <zhulikas> it returns IO
05:11:57 <zhulikas> how can I get type without IO?
05:12:02 <zhulikas> I need a random number
05:12:43 <aristid> zhulikas: you could pass the random seed from your main
05:13:29 <hpaste> zhulikas pasted “nu” at http://hpaste.org/54370
05:13:38 <zhulikas> this is how I do it
05:16:07 <silver> @type getStdRandom
05:16:08 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
05:16:47 <silver> try value <- getStdRandom...
05:39:19 <docTony> Is there a way to tell Haskell to forget something in memory? Or are there strict versions of foldM ? Like foldl' but  then with a monad?
05:39:21 <docTony> plz help
05:39:58 <docTony> I need to process large amounts of files and I keep getting errors that I have either too many files open or my memory explodes keeping all files in memory...
05:41:15 <Nimatek> docTony: You should be able to limit the heap size with compiler options.
05:42:31 <Botje> docTony: use strict bytestrings.
05:43:39 <docTony> yeah, the stict bytestring might be an option
05:43:43 <docTony> I'll try it
05:43:46 <docTony> thnx, Botje
05:44:07 <etpace> Is there a way to import http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/Llvm.html ? Copy/pasting the source into my folder is a bit dodgy as it uses #include and some #ifdef and I'd rather not hack with them but use it straight from the GHC pkg
05:45:27 <Eduard_Munteanu> docTony: the reason stuff remains in memory is you're still holding references to it, so the GC can't collect. Either that, or you're blowing the stack.
05:45:31 <dylex> etpace: is the llvm package insufficient in some way?
05:46:43 <etpace> I'm finding it too high level to do some things
05:46:54 <etpace> (or rather, i'm unable to get what I want to work :))
05:48:04 <Eduard_Munteanu> docTony: also, lazy bytestrings could be alright, depending on your access patterns.
05:48:51 <dylex> etpace: hm. well, ghc's llvm is pretty tied in to the rest of the compiler, so have to pull in a good bit of ghc to use it as is.
05:49:59 <etpace> am I able to generate IR (with the danger of blowing my own leg off) using the llvm package?
05:50:15 <docTony> I think I fixed it using: return $! ....     in 2 of my functions :-)
05:50:54 <Botje> or that.
05:52:37 <dylex> etpace: I haven't looked in a while, but is that what LLVM.Core.Instructions provides?
06:09:10 <cwl> Have any one read <Purely Functional Data Structures> or <Algorithms: A Functional Programming Approach>
06:09:57 <Abraxas> i posted this yesterday: http://hpaste.org/54308...the problem is that i receive a list (as i should, for the non-deterministic list parser that is used), but i want the content of that list and i can't seem to find a way to get it...
06:10:17 <Abraxas> latest entry, objective is two posts up from that one
06:10:38 <Abraxas> i have to use the list parser, even though (i think) it makes no sense for this task
06:11:21 * hackagebot digestive-functors 0.2.0.1 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.2.0.1 (JasperVanDerJeugt)
06:11:34 <paolino> anyone knows how to get the parameter of a spline which mapped point is nearest to a given one ?
06:11:58 <Abraxas> i believe the only way to get the content of the list is to use   do content<-parser  ?
06:12:23 <Abraxas> as i understand it the parser is a monad and the do-notation retrieves the content of the monad in which it is wrapped
06:13:25 <fryguybob> paolino: What kind of spline?
06:13:45 <paolino> fryguybob: bspline
06:14:36 <Abraxas> so i wrote this: parser_ = do {result <- parser; case result of {[] -> failure; (x:xs) -> return x}}
06:15:43 <Abraxas> for parse parser "abab" i get ["abab"]...for parse parser_ "abab" i get "a"
06:15:52 <Abraxas> how do i get "abab"?
06:16:23 <paolino> fryguybob: I'm just touching those, I was thinking on how to add a knot to a spline selecting a point next to it
06:17:08 <Abraxas> there may be cases missing, didn't think about that yet
06:17:36 <DrSyzygy> cwl: I've skimmed through PFDS
06:18:34 <fryguybob> paolino: I don't think there is a closed form for that, you can probably do a reasonable search with subdivision, but the answer is ambiguous.
06:21:26 <cwl> DrSyzygy: how do you think about them
06:21:57 <Abraxas> well, since it's only ever going to be one result i could concatmap it i guess
06:25:28 <Abraxas> that would require that i can access the content outside of a do, which i don't seem to able to do
06:25:38 <Abraxas> same problem
06:28:03 <Abraxas> oh, that "weird" notation of the parser in my hpaste is straight out of huttons book
06:28:31 <Abraxas> @Cale ;)
06:28:32 <lambdabot> Unknown command, try @list
06:28:37 <Abraxas> oops
06:32:24 <Abraxas> but my ||| is +++ there...which you said yesterday...alright
06:48:53 <FUZxxl> Do you know any Haskellish jokes?
06:49:17 <kowey> thanks, shachaf (re hs-plugins), I ended up just exposing my executable as a library (gui and all)
06:49:35 <leoncamel> FUZxxl: http://www.haskell.org/haskellwiki/Humor
06:50:14 <FUZxxl> aha... thanks
06:57:04 <Abraxas> for mapP from http://hpaste.org/54308 ...does this always hold:  mapP f p == do {x<-p; return (f x)}
06:57:06 <silver> how can I check sources of (==) for particular instance of Eq?
06:57:09 <Abraxas> mapP :: (a -> b) -> Parser a -> Parser b
06:57:23 <Abraxas> mapP f p = p ++> \x -> yield (f x)
06:57:35 <Abraxas> looks similar, but is it immediately obvious it is the same?
06:57:55 <Abraxas> i mean, is it a direct translation into do-notation?
06:58:20 <Veinor> what's ++>?
06:58:40 <silver> homebrew bind I guess
06:58:47 <Veinor> oh, it's bind on Parserss
06:58:59 <Veinor> @do p >>= \x -> yield (f x)
06:58:59 <Abraxas> yeah, it's bind
06:59:00 <lambdabot> do { x <- p; yield (f x)}
06:59:07 <Abraxas> ah
06:59:10 <Abraxas> nice
06:59:27 <Veinor> by the way, it's considered good style to use >>= and return instead of ++> and yield
06:59:33 <Veinor> even though they're equivalent
06:59:39 <Abraxas> well that still doesn't solve my problem then...just a different way to write it
07:00:01 <Abraxas> yeah i know, it's a course that introduces monads through parsers
07:00:18 <Abraxas> using some unconventional syntax
07:00:26 <silver> yeah
07:00:28 <silver> same in rwh
07:00:49 <Abraxas> that's where it's from, ok
07:01:10 <Abraxas> re: my problem...
07:01:42 <Abraxas> parse parser "abab" should return "abab" instead of ["abab"]
07:02:13 <Abraxas> so i was trying to manipulate the result in the do before returning it...but then it's not a list, yet
07:02:55 <Abraxas> now i am trying to apply a function to the list outside of the do, but turns out mapP isn't the one i want
07:04:06 <Abraxas> but since Parser a is basically (or totally) a monad...can i get the content without using do or an equivalent?
07:04:21 <silver> you can try to lift you function into the monad
07:04:46 <Abraxas> isn't that what mapP does
07:04:56 <silver> oh yeah
07:04:58 <silver> hmm
07:05:21 <Veinor> @hoogle liftM
07:05:21 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
07:05:21 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:05:21 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:05:28 <Veinor> liftM is just fmap, so
07:05:31 <arbn> Does anyone here have experience using the Haskell starter kit for the "AI Challenge", perchance?
07:05:40 <Abraxas> still not sure why the hell we are supposed to use the list parser for this
07:05:59 <Abraxas> i was told that maybe would be much easier...probably the point, then :D
07:06:42 <Abraxas> well, we only had liftP
07:06:56 <Abraxas> that's liftM2, i guess
07:07:08 <Abraxas> ok thanks
07:07:34 <Abraxas> i guess i will have to use it
07:08:24 <Abraxas> ah no
07:08:41 <Abraxas> the imports are fixed, if it's not in those provided, it's a no-go
07:09:46 <Veinor> what are you trying to do, exactly?
07:10:42 <Abraxas> uhm: liftM f m1              = do { x1 <- m1; return (f x1) }
07:10:51 <Abraxas> that is mapP, alright
07:10:55 <Veinor> yep
07:11:02 <Abraxas> :D
07:11:16 <Abraxas> parse parser "abab" should return "abab" instead of ["abab"]
07:11:33 <Abraxas> here: http://hpaste.org/54308
07:12:14 <Abraxas> second from the bottom describes the objective, latest entry is relevant, the rest was crap
07:12:27 <Abraxas> aside from listing all the modules
07:15:37 <Veinor> hmm
07:15:44 <Veinor> i'm a little confused, which block contains your actual current code
07:16:49 <Veinor> oh here's a question
07:17:01 <Veinor> if you want parse parser "abab" to return "abab", what should parse parser "aba" return?
07:18:43 <Veinor> i haven't run your code but i'm pretty sure right now it'd return []
07:18:50 <Veinor> by 'return' i mean 'evaluate to'
07:20:37 <hpaste> Abraxas annotated “parse_asbs” with “parse_asbs (current relevant code)” at http://hpaste.org/54308#a54371
07:21:45 <Abraxas> yes it does
07:22:08 <Veinor> so if parse parser "abab" = "abab", what should it evaluate to for input that fails to parse?
07:23:03 <Abraxas> [] is fine, i guess
07:23:21 <Veinor> but [] is equal to the empty string
07:23:29 <Veinor> and parse parser "" will then be ""
07:24:00 <Veinor> regardless of whether or not it parses or not
07:24:11 <geheimdienst> (how often do you want some parsing witchcraft to parse an empty string ...?)
07:24:34 <Abraxas> well, didn't worry about that, because the simple case is not even working, yet
07:25:33 <Abraxas> i could use Either, although technically, for this task it shouldn't be required knowledge
07:25:51 <Abraxas> it's an older task
07:26:36 <Abraxas> in the meantime we have written a MessageParser which prints meaningful error messages
07:27:08 <Abraxas> could it be related to this: newtype Parser a = P {unP :: ParserCore.Parser a}
07:27:15 <Abraxas> using the unP
07:35:04 <Abraxas> unP is from MParserCore...which is imported, but still GHCI says that unP is out of scope...so it has to be exported from MParserCore separately of Parser?
07:35:41 <Abraxas> nm, it's encapsulation
07:36:12 <Abraxas> for obvious reasons
07:56:19 <hqm> How can a combine a Writer with a WriterT to log two different things?
07:57:42 <byorgey> hqm: there are ways, but it's ugly.  if I were you I would instead use a single Writer with a pair.
07:58:12 <byorgey> then you can define helpers like  tell1 x = tell (x,mempty)
07:59:06 <hqm> type DoubleWriter a = WriterT [Int] (Wrtiter [String]) a ....     tell [42] -> works ... tell ["xyz"] -> type error
07:59:46 <hqm> ok thanks! great idea
08:03:32 <kowey> confused about Cabal paths on the Mac, seems to be randomly ~/.cabal/foo vs ~/Library/Haskell/foo
08:05:43 <copumpkin> preflex: seen mzero
08:05:43 <preflex>  mzero was last seen on #haskell 1 day, 8 hours, 45 minutes and 45 seconds ago, saying: I suppose I could do the deep-clean if you invoke the utility with the name high-colonic
08:05:50 <copumpkin> @tell mzero yo
08:05:50 <lambdabot> Consider it noted.
08:08:32 <Botje> hqm: you probably need to do lift (tell ["xyz"])
08:13:52 <gwern> @quote
08:13:53 <lambdabot> turbopascal says: I heard that next year, the whole [ICFP] spec will be given in a made up alien language that you will have to decipher as step I.
08:14:05 <mm_freak> hqm: note:  there is a Monoid instance for tuples, when the component types are monoids
08:16:23 * hackagebot lhe 0.1.1 - Parse for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.1.1 (ScottLawrence)
08:37:10 <joe9> i have ghc 7.2.1 installed on my system. I want to upgrade to the latest ghc. Any suggestions on which would be a good stable release to upgrade to? Something that will not break many packages.
08:39:33 <joe9> 7.2.2 seems to be the latest available
08:39:50 <cheater> there's a 7.4 in beta i believe
08:40:38 <kirindave> Is cabal-install now building without patches for 7.2.2?
08:41:26 <joe9> cheater: i want to stick with the stable release as the beta versions normally have all kinds of package failures.
08:41:45 <joe9> kirindave: thanks for raising that. did not know that there was an issue there.
08:42:07 <kirindave> joe9, look in the /topic :)
08:42:34 <kirindave> I also had a pretty epic s3 bill from handing out a link with a pre-patched source tree of caball-install.
08:43:12 <edwardk> dolio: hi
08:44:29 <cheater> joe9: yeah, they do.
08:49:42 <copumpkin> dolio: hi
08:49:50 <dmwit> Hi, dolio!
08:50:11 <kirindave> So does cabal-install build cleanly under 7.2.* now?
08:50:13 <copumpkin> hi dmwit!
08:50:18 <dmwit> Hi copumpkin!
08:50:21 <kirindave> If so, the /topic stuff should be removed
08:52:27 <joe9> after I upgrade ghc, is there a simple method to upgrade all the cabal packages?
08:55:03 <joe9> i am upgrading ghc-7.2.1 to ghc-7.2.2
08:56:26 <joe9> http://stackoverflow.com/questions/6563769/haskell-cabal-regenerate-documentation-for-all-installed-packages found this
09:16:23 <copumpkin> hey mzero
09:18:24 <mzero> hello
09:18:24 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
09:18:28 <edwardk> preflex: xseen shapr
09:18:28 <preflex>  shapr was last seen on freenode/#haskell-blah 3 minutes and 30 seconds ago, saying: So, EJECT and ABORT refer to two of those power buttons.
09:18:42 <edwardk> shapr: picked up reamde yet?
09:18:57 <dcoutts> joe9: note that the --upgrade-dependencies given there is almost certainly not a good idea
09:19:03 <mzero> yo back at cha', copumpkin
09:19:11 <shapr> edwardk: wot?
09:19:17 <edwardk> shapr: first 10 pages, a southern family reunion, guns, and autodidacticism =P
09:19:21 <joe9> dcoutts, ok, thanks.
09:19:32 <shapr> huh, I have to get that book.
09:19:42 <edwardk> shapr: hah i figured neal stephenson must have interviewed you to set it up ;)
09:20:38 <shapr> edwardk: hahah, if I've chatted with him, I didn't know it was him. But I certainly do talk to random strangers.
09:24:49 <applicative> license killjoys have run amok on haskell-cafe again, I see.
09:24:53 <shapr> edwardk: I was recently invited to film and shoot a flintlock.
09:27:31 <leoncamel> Who can help me download the latest citeproc-hs darcs source code for me ? I can not install darcs here, after I upgrade ghc to 7.2.2. :(
09:27:54 <edwardk> don't blow off your hands. i hear its harder to program without hands
09:28:26 <applicative> leoncamel: let me think how.  where is it patch-tag?
09:29:10 <Phyx-> edwardk: now that's a pro-tip
09:29:19 <leoncamel> applicative: so ? is there a mirror of darcs ?
09:29:24 <applicative> leoncamel oh i see it
09:29:31 <Phyx-> edwardk: could always use Siri
09:31:03 <applicative> leoncamel: whoa its mercurial?
09:31:49 <leoncamel> applicative: huh ?
09:32:31 <applicative> the citeproc-hs source code, is that what we're talking about?  http://gorgias.mine.nu/repos/citeproc-hs/#installation
09:33:46 <applicative> leoncamel, i see, it *is* a little confusing, hg comes in with the test suite, somehow
09:34:53 <applicative> leoncamel, anyway should I zip it and email it to you or something?
09:35:02 <leoncamel> applicative: yes, there are test suite on mercurial.
09:35:44 <applicative> leoncamel: yeah, it just confused me for a sec, I thought he had switched over to it.
09:35:45 <leoncamel> applicative: Oh. great, how big is it? My gmail can only accept 20MB per mail.
09:37:15 <KitB> Does anyone have any experience with Graphics.Rendering.Chart ?
09:39:29 <applicative> leoncamel: the zipped file, after using darcs --lazy is minute
09:42:56 <mprokos> What is a good library for encode/decode haskell types to/from a specific binary encoding? I need to write a TCP server for a specific protocol.
09:43:42 <leoncamel> mprokos: parsec or attoparsec, I guess.
09:45:16 <mprokos> Speed is not really an issue, as it's just providing a simulation for testing.
09:46:29 <rwbarton> how about the binary package?
09:46:47 <mprokos> That was my next question..  Any thoughts on Data.Binary?
09:49:18 <Cale> mprokos: it's decent, but it's poor at error handling. You may also want to look at cereal
09:51:36 <parcs> is there any work done on parallelizing cabal?
09:53:05 <vitka> By the way, What is purpose of blaze-builder? It seems kind of redundant when you have Binary, It provides Builder monad but if you can get/put directly to bytestring, what's the point?
09:53:33 <vitka> Am I missing something?
09:56:26 * hackagebot cabal2nix 1.19 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.19 (PeterSimons)
09:56:48 <hpaste> zhulikas pasted “doesnt work? ” at http://hpaste.org/54373
09:56:56 <zhulikas> please take a look
09:57:15 <zhulikas> can't figure out how to successfuly mix pure with impure functions :|
09:57:47 <kirindave> zhulikas, [IO Int] is a funny type.
09:57:52 <kirindave> I seldom see that
09:58:05 <zhulikas> :D
09:58:13 <kirindave> zhulikas, why not just IO [Int]?
09:58:22 <zhulikas> Didn't see that one comming
09:58:23 <copumpkin> you might not want to execute all the actions
09:58:38 <copumpkin> you can easily go from [IO Int] to IO [Int], but not the other way around
09:58:42 <copumpkin> those missiles can't be unlaunched!
09:58:45 <copumpkin> what is seen cannot be unseen
09:58:54 <zhulikas> I don't get it
09:59:01 <kirindave> copumpkin, granted, but
09:59:03 <zhulikas> randomRIO returns IO a
09:59:17 <kirindave> copumpkin, I do not think that is the case here given that getRandoms takes an Int.
09:59:20 <copumpkin> but yeah, after some useless pedantry, I agree with kirindave
09:59:34 <vitka> Well, first step is to get rid of select.
09:59:49 <zhulikas> @type randomRIO(1,2) : randomRIO(1,2) : []
09:59:50 <lambdabot> forall t. (Num t, Random t) => [IO t]
09:59:50 <vitka> Hlint on hpaste is pretty direct about it.
10:00:09 <vitka> (!!) is pure.
10:00:14 <gseitz> zhulikas: take a look at http://hackage.haskell.org/packages/archive/acme-missiles/0.2.1/doc/html/Acme-Missiles.html
10:00:16 <zhulikas> ahh, !!
10:00:18 <zhulikas> of course
10:00:34 <gseitz> no unlaunchMissiles there ;)
10:01:43 <zhulikas> and it's impossible to match IO values against anything O.o
10:02:25 <kirindave> zhulikas, from pure code, yes
10:02:29 <kirindave> but consider why that makes a lot of sense.
10:02:43 * zhulikas is thinking in impure ways 
10:02:46 <zhulikas> an't figure out why
10:03:09 <hpaste> applicative annotated “doesnt work? ” with “doesnt work?  (annotation)” at http://hpaste.org/54373#a54374
10:03:12 <applicative> zhulikas: it needs to be reoganized, but this compiles, no?
10:03:21 <zhulikas> it doesn't
10:03:44 <kirindave> zhulikas, pure code doesn't have any of the context necessary to know anything other than "That is an IO"
10:04:25 * ski . o O ( every function in Haskell is pure )
10:04:36 <zhulikas> so there is IO and there is normal data types?
10:04:51 <zhulikas> then why there is like IO Int
10:04:54 <kirindave> zhulikas, no, IO is a data type too.
10:04:55 <zhulikas> IO a in general
10:04:55 <applicative> theres all the data types a, and then the corresponding IO types
10:04:57 <zhulikas> :/
10:05:22 <applicative> which are data types.  There's IO (IO (IO Int))) just like [[[Int]]]
10:05:24 <zhulikas> IO is the only way to work with external world, right?
10:05:29 <kirindave> zhulikas, you can only think about the context of IO a within an IO action.
10:05:50 <ski> zhulikas : an `IO Int' is a recipe on how to interact with the world to get an `Int' -- each time you follow the recipe you might get a different `Int'
10:05:50 <vitka> Actually, to make pure (!!) work, you need to rewrite getRandoms function. Pure was is to pass StdGen to function and have, and you'll have your random sequence.
10:05:55 <zhulikas> and only IO action is main? (I don't know anything about monads!)
10:05:56 <applicative> getChar is an action, there's no mystery about it, once you realize how often you do it yourself, reading
10:06:02 <ski> zhulikas : remember, the recipe is not the cake ! :)
10:06:03 <kirindave> Which are things with that monadic shape, a -> IO b and the like.
10:06:55 <zhulikas> hmm, passing StdGen...
10:07:04 <mike-burns> Monads are a red herring.
10:07:07 <ski> zhulikas : yes, `IO' is the only way to interact with the external world
10:07:28 <zhulikas> also random is only possible in IO, right?
10:07:42 <zhulikas> it wouldn't make sense it to work in pure function
10:07:48 * applicative is surprised how good red herring can be
10:07:54 <ski> zhulikas : no, you can also pass around `StdGen's which are pseudo-random generators
10:07:56 <mike-burns> I've never tried it!
10:08:10 <ski> zhulikas : each tim you use the same `StdGen' to get an `Int', you'll get the same `Int', however
10:08:31 <zhulikas> ski, so I can pass a generator from a IO Action to pure function and that pure function uses StdGen to generate pure data? O.o
10:08:37 <zhulikas> oh.
10:08:40 <zhulikas> heheh:)
10:08:48 <zhulikas> that's what I meant about random in pure function
10:08:51 <ski> zhulikas : so, in any case, you must make sure to not use the same `StdGen' more than once. you can use `IO' to hide this, but the same thing happens if you use `IO' to get pseudo-random numbers
10:09:24 <zhulikas> is there a way to rewrite my functions to be like IO Actions?
10:09:44 <zhulikas> hmm I could get rid of external functions...
10:09:45 <rwbarton> write functions that return IO actions
10:10:00 <zhulikas> by IO actions you mean (IO a) or IO () ?
10:10:07 <ski> zhulikas : either of those
10:10:14 <rwbarton> values of one of those types, yeah
10:10:23 <zhulikas> but can my functions take non-IO parameters?
10:10:31 <ski> anything of type `IO Foo', where `Foo' is any type whatsoever, is an `IO'-action
10:10:34 <applicative> zhulikas: you should be going the other way! select wasn't an action, as you had typed it it was an ordinary function
10:10:46 <zhulikas> yes it was :D
10:10:49 <ski> zhulikas : if you don't need to do `IO' in a function, it's better to not have it do `IO'
10:10:51 <zhulikas> but it was working on impure data
10:11:12 <rwbarton> actually it was working on *actions*
10:11:15 <zhulikas> ski, I totally agree with you! but I don't know a way not to deal with IO in my functions
10:11:15 <applicative> zhulikas: no, you were using it in main, but you use (+) and (*) in them too
10:11:19 <rwbarton> (well really it wasn't working at all)
10:11:37 <vitka> You still can use pure function inside main.
10:12:08 <applicative> you use 'map' on the last line, what does that have to do with action?
10:12:17 <zhulikas> would it be too wrong if somebody rewrote this code in a way it works?
10:12:20 <kirindave> zhulikas, a key thing to understand is that once you get an IO action to disgorge a value (usually via <- in a "do" block or via >>=), it is no longer impure from the perspective of functions you could call upon that result
10:12:34 <kirindave> zhulikas, once it is in the past (you evaluate the IO action) the result is decided upon
10:12:47 <ski> zhulikas : i'm not sure if anybody has already said this but : your `select' calls no `IO'-operations, so doesn't need to have `IO' in its type -- if you comment out the type signature, and ask your interactor for the type, you should get a more general type (not including `IO')
10:13:11 <kirindave> zhulikas, so reading a string from stdin, for example. It is an IO action to do so
10:13:18 <kirindave> but that IO action can take the results and feed them into pure code
10:13:43 <kirindave> Because once you have evaluated the IO actions, you have the results and pure code is okay with that.
10:13:49 <applicative> zhulikas: don't let them worry you, by the time you understand the program you have (almost) written, you'll understand everything
10:13:56 <ski> zhulikas : if you want `getRandoms' to do `IO' at all, it's better to change `[IO Int]' to `IO [Int]' (also changing the code a bit), as people have remarked
10:13:58 <cheater> ski: what is an interactor?
10:14:03 <zhulikas> "evaluating the IO actions" means doing something like arr <- getLine ?
10:14:14 <kirindave> zhulikas, sssorta
10:14:22 <rwbarton> he means executing the IO actions
10:14:24 <zhulikas> arr is no longer IO
10:14:26 <tac-tics> zhulikas: evaluation is something you only do when you RUN a haskell program :)
10:14:31 <rwbarton> also he is talking about the view "from inside the monad"
10:14:32 <applicative> ski, i commented out the signature for select on my dubious  annotation
10:14:45 <ski> cheater : the thing in which you interact with any system. it can be a compiler, it can be an interpreter. in case of GHC, it's GHCi (`i' standing for `interactive')
10:14:50 <zhulikas> rwbarton, don't twist my words! I didn't say that!
10:15:01 <rwbarton> I'm twisting kirindave's words
10:15:04 <kirindave> zhulikas, ultimately what happens is your "main" function yields up a big fugly complex IO action which then drives your program.
10:15:23 <cheater> ski: ok
10:15:26 <kirindave> zhulikas, these io actions get lumped together via uses of things like <- (in do notation) and >>=
10:15:26 <ski> kirindave : s/evaluated the IO actions/executed the IO actions/ :)
10:15:32 <kirindave> ski, my bad
10:15:37 <kirindave> executed
10:15:59 <kirindave> zhulikas, if this all seems a little mysterious, I wouldn't worry too much over it at the start. It will become clearer over time.
10:16:05 <vitka> Basically, getLine is IO String. arr <- getLine means you "extract" string as arr and can use it in pure functions which a called later,
10:16:27 <zhulikas> http://www.haskell.org/haskellwiki/99_questions/21_to_28
10:16:32 <zhulikas> I am on 23rd exercise
10:16:38 <zhulikas> I am comfortable enough to start messing with IO
10:17:06 <bluej774> I'm having an issue with deepseq.  I can use it in ghci just fine, but when I try to compile a program that uses it, I get undefined reference errors from the linker.  Any ideas?
10:17:17 <zhulikas> but ok... I'll try to rewrite my code a bit
10:17:29 <kirindave> zhulikas, there is no reason not to write your random number generator to IO [Int] in this case.
10:17:38 <zhulikas> I don
10:17:50 <zhulikas> I don't see a difference between IO [Int] and [IO Int]
10:17:51 <rwbarton> bluej774: compile with --make
10:18:01 <bluej774> I'll try it.  Thanks
10:18:03 <kirindave> zhulikas, well, how do you get at the [Int] in IO [Int]
10:18:29 <kirindave> zhulikas, you'd use <- in a do block or >>= (or fmap or a dozen-or-so other ways we are not mentioning)
10:18:35 <applicative> ghc --make -O2 foo.hs -o foo   -- or add your optimization flag of choice
10:18:57 <kirindave> but the key insight is that IO [Int] gets all your randoms at once when you execute the IO action.
10:19:07 <kirindave> It is an IO action that returns a batch of ints to you, all at once.
10:19:11 <rwbarton> zhulikas: it seems like you think that an IO Int is an Int that came from the outside world
10:19:21 <zhulikas> hehe, yes, I do!
10:19:42 <rwbarton> this is a common misconception
10:20:09 <kirindave> [IO Int] is a list of IO actions, as yet unevaluated. Pure code can actually move these around! But once you are in the IO monad and say <- or >>=, the ONE int will be randomly generated.
10:20:17 <rwbarton> actually an IO Int is like ski said -- a recipe to interact with the world and produce a result of type Int
10:20:43 <kirindave> I keep saying evalauted when I mean executed, my apologies to Ski and the family I have shamed.
10:20:45 <bluej774> How can I force my program to do work without using 'show' or printing anything to the screen or writing it to disk?
10:21:30 <rwbarton> now you might ask "what can I do with this recipe?"
10:21:46 <bluej774> deepseq doesn't seem to be forcing evaluation
10:22:03 * ski looks sternly at kirindave : "I hope you've learned your lesson now."
10:22:10 <ski> ;)
10:22:40 <zhulikas> I should have read this one before I got here http://www.haskell.org/tutorial/io.html
10:22:51 <ski> zhulikas : an `IO [Int]' is a recipe which you can execute, to get a list of `Int's
10:23:17 <ski> zhulikas : a `[IO Int]' is a list of recipes, which you can select any recipe you want from, and execute that to get an `Int'
10:23:44 <Varakh> hi. is it possible to have a function declared in my instance of Show ?
10:23:47 <paolino> bluej774:  main = x `seq` return () -- should force the evaluation of (part of) x
10:23:49 <zhulikas> ok, it makes sense how to extract something from them
10:23:54 <ski> zhulikas : in the `IO [Int]' case, the whole list will be generated whether ot not you only wanted the third `Int'
10:24:34 <zhulikas> @h
10:24:34 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
10:24:36 <Cale> Varakh: ...yes? I'm not sure what you're asking.
10:24:41 <cheater> zhulikas: try reading some of my tutorials on http://cheater.posterous.com/
10:24:43 <zhulikas> @hoogle a -> IO a
10:24:44 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:24:44 <lambdabot> Control.Exception evaluate :: a -> IO a
10:24:44 <lambdabot> Control.OldException evaluate :: a -> IO a
10:24:55 <Cale> Varakh: in particular, you will probably define the show function.
10:24:57 <ski> zhulikas : in the `IO [Int]' case, you don't know (in the general case) how many `Int's you will get back -- in the `[IO Int]' case, you know how many `Int'-recipes you have, and can pick and choose from that list before deciding to *do* anything with the external world
10:25:00 <bluej774> Good call.  You got it.
10:25:02 <zhulikas> @hoogle IO a -> a
10:25:02 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
10:25:02 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
10:25:03 <lambdabot> Foreign unsafePerformIO :: IO a -> a
10:25:11 <zhulikas> unsafePerformIO :D
10:25:20 <Cale> bluej774: I wrote some code for you the other day, but you left before I could show it to you
10:25:39 <ski> zhulikas : you should *only* use `unsafePerformIO foo' if `foo' actually has no (observable) effect on the world at all
10:25:54 <Varakh> Cale: my instance Show (the show function used another one)
10:26:02 <ski> zhulikas : so `unsafePerformIO (return 42)' is ok, but `unsafePerformIO getInt' isn't
10:26:14 <Cale> rofl
10:26:22 <Cale> He left again!
10:26:37 <Varakh> instance Show TestDataType where
10:26:37 <Varakh>  show x = anotherFunction x
10:26:38 <Cale> These people who don't know how to idle, what the heck :P
10:26:45 <ski> zhulikas : the compiler depends on you not breaking this rule -- if you break it, the compiler may (unknowingly) compile your code into doing something completely different from what you intended
10:27:10 <paolino> Cale: maybe they are on payed connections
10:27:14 <Varakh> Cale: u see what i mean?
10:27:14 <rwbarton> Varakh: you can write that but you have to define anotherFunction outside the Show instance
10:27:18 <ski> zhulikas : so, generally, *don't* use `unsafePerformIO', unless you know exactly what you're doing, ok ? :)
10:27:37 <Cale> Varakh: you can write that, it's perfectly valid
10:27:37 <zhulikas> isn't unsafePerformIO same as <- ?
10:27:44 <mike-burns> I don't understand how `unsafePerformIO' comes up so often. It has very few uses.
10:27:45 <ski> no
10:27:49 <ski> zhulikas : no, it isn't
10:27:54 <mike-burns> <- is the same as >>= .
10:27:57 <rwbarton> ski: you forgot these: !!
10:28:20 <ski> zhulikas : `unsafePerformIO' is a performance hack, comparable to modifying the compiler yourself (except for not having to actually modify the compiler)
10:28:33 <zhulikas> when I execute something like x <- getLine
10:28:34 <rwbarton> <- (or >>=) are how you build up a recipe from parts
10:28:35 <zhulikas> x is of String type
10:28:42 <mike-burns> "!!" is going to look like a pair of skis to me now. Great.
10:28:43 <ski> zhulikas : yes
10:28:56 <ski> @type (!!)
10:28:56 <zhulikas> @type getLine
10:28:57 <lambdabot> IO String
10:28:58 <lambdabot> forall a. [a] -> Int -> a
10:29:09 <zhulikas> IO String -> String
10:29:12 <zhulikas> when using <-
10:29:13 <zhulikas> :|
10:29:23 <kirindave> zhulikas, so I made an example of the difference between IO [Int] and [IO Int] that also somewhat apes the shape of your code.
10:29:23 <rwbarton> <- is not a function
10:29:30 <rwbarton> and if it was that wouldn't be the syntax anyways
10:29:36 <ski> @undo do { x <- getLine; putStrLm (reverse x) }
10:29:37 <lambdabot> getLine >>= \ x -> putStrLm (reverse x)
10:29:51 <ski> zhulikas : using `<-' is syntactic sugar for using `>>='
10:29:57 <mike-burns> :t (>>=)
10:29:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:30:01 <paolino> zhulikas: if you want to get there you must learn class Monad
10:30:07 <kirindave> zhulikas, I dunno if this will confuse you more or not. :)
10:30:10 <zhulikas> and >>= is combining IO Actions
10:30:12 <kirindave> zhulikas: https://gist.github.com/1383510
10:30:14 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b  -- in zhulikas's case
10:30:28 <mike-burns> No need to learn anything about monads.
10:30:35 <zhulikas> yeah
10:30:39 <zhulikas> don't scare me off, please
10:30:50 <kirindave> zhulikas, runhaskell on that script I sent you
10:30:57 <kirindave> It may help you realize how these two things are different.
10:31:00 <vitka> Don't worry.
10:31:01 <zhulikas> @type return
10:31:02 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:31:05 <ski> zhulikas : yes, `(>>=)' is for combining `IO'-actions
10:31:12 <ski>   return :: a -> IO a  -- in your case
10:31:15 <kirindave> The Biggest Air Quotes
10:31:26 <zhulikas> @type putStrLn
10:31:27 <lambdabot> String -> IO ()
10:32:00 <vitka> I assume you "need" [IO Int] because you need a list of random values, so you attempt to get each one from outside world?
10:32:54 <kirindave> I really wanna make some mad conan metaphors here
10:33:05 <kirindave> about how main is the tree of woe upon which ghc contemplates your IO actions.
10:33:11 <kirindave> I suspect this would be unhelpful though.
10:33:19 <kirindave> and maybe 2 people would get the reference.
10:34:00 <ski> zhulikas : may i ask what is your goal here ?
10:34:15 <kirindave> ski, he is doing some exercises from the wiki
10:34:23 <ski> zhulikas : is it writing a specific (example) program, and in that case, what is the program supposed to do ?
10:34:31 <kirindave> ski, http://www.haskell.org/haskellwiki/99_questions/21_to_28 he said. #23
10:34:58 <kirindave> I don't really get why 23 comes before 24
10:35:11 <kirindave> Considering that the most obvious implementation of 23 includes 24.
10:35:16 <cheater> because 7 8 9
10:35:23 <kirindave> (the assignments, not the numbers)
10:35:28 <kirindave> (womp womp #haskell-pedantic)
10:36:52 <zhulikas> kirindave, why the hell does your function return only IO [Int] if it includes putStrLn ? (halp)
10:37:14 <zhulikas> and do is a shortcut for >>=
10:37:24 <kirindave> zhulikas, yes
10:37:34 <kirindave> zhulikas, ah, it's there so that there is a side effect with the IO action
10:37:42 <kirindave> zhulikas, it's just so that you can see what is happening
10:37:46 <dylex> kirindave: 23 is with replacement, 24 is without, so 24 can be a bit harder.
10:38:07 <kirindave> dylex, ohhhh
10:38:24 <kirindave> dylex, didn't read "different". Eyes bounced right off of it.
10:40:57 <vitka> zhulikas: getRandoms rng xs n = map (xs !!) $ take n (randomRs (0, (length xs)-1) rng))
10:41:07 <vitka> Something like that,
10:41:23 <zhulikas> :D
10:41:34 <vitka> Pure function that does it. :P
10:41:44 <dylex> kirindave: you might argue that an obvious implementation of 24 uses 25, but that's more true in haskell than the original lisp.  similarly, 23 doesn't require learning something entirely new (random state) in lisp either.
10:42:03 <mm_freak> kirindave: the do-notation is just syntactic sugar…  it allows you to build larger IO actions from simpler parts, and the "<-" notation allows you assign names to intermediary results
10:42:32 <mm_freak> /if/ we are talking about IO…  i inferred that from a little context
10:42:49 <kirindave> mm_freak, you might want to be addressing zhulikas
10:43:08 <mm_freak> oh, ok…  i read it like he was pointing that out to you =)
10:43:14 <zhulikas> :)))
10:51:09 <letrec> What does the instance NFData a => NFData [a] means? (In NFData class?)
10:52:29 <parcs> if a has an instance of NFData, then [a] has an instance of NFData
10:53:03 <mm_freak> letrec: it means that deepseq forces the entire structure of a list, including its elements
10:53:07 <byorgey> if elements of type 'a' can be full evaluated, then we can fully evaluate a list of them
10:53:18 <byorgey> s/full/fully/
10:53:32 <rwbarton> mm_freak: surely that's what the next line means :)
10:53:50 <mm_freak> rwbarton: ?
10:53:59 <rwbarton> "where deepseq xs = ..."
10:54:48 <shapr> o hai joyfulgirl, how's code?
10:55:39 <byorgey> hi shapr
10:55:53 <mm_freak> rwbarton: i don't understand
10:55:58 <shapr> howdy byorgey, how's code?
10:56:02 <joyfulgirl> shapr:  Nonexistant lately; concentrating more on the jobhunt thing I'm doing
10:56:07 <joyfulgirl> You?
10:56:36 <byorgey> shapr: it's great!  see http://hpaste.org/54359  which generates  http://www.cis.upenn.edu/~byorgey/cycle.mp4
10:56:42 <byorgey> shapr: what about you?
10:57:06 <rwbarton> < mm_freak> letrec: it means that deepseq forces the entire structure of a list, including its elements
10:57:06 <shapr> I've been writing some Python code to control an RGB LED for a "wakeup,go to school, time for sleep" color clock.
10:57:16 <rwbarton> "instance NFData a => NFData [a]" could be any definition for deepseq
10:57:21 <rwbarton> like deepseq _ = ()
10:57:24 <shapr> I'd rather use Haskell, but can't figure out how to get GHC installed on my OLPC XO.
10:57:40 <byorgey> shapr: nice.  does it transition smoothly between colors? or just discrete changes?
10:57:43 <roconnor> @where ttfp
10:57:43 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
10:58:12 <shapr> byorgey: So far, only discrete changes at particular times. But fuzz factor transitions are the goal.
10:58:28 <byorgey> shapr: sounds cool.
10:58:40 <shapr> Like, half an hour before wakeup time, keep the dull red of "sleep" and add in a touch of the green for "wakeup".
10:59:17 <developernotes> is it possible to define a type signature directly within ghci?
10:59:17 <shapr> I ended up making the Arduino side purely a USB serial interface that takes "r255 g0 b150" or whatever.
10:59:32 <shapr> byorgey: Seems like transitioning would be more easily done in Haskell.
10:59:49 * shapr thinks
10:59:57 <byorgey> shapr: yes, it would!  In fact, I am about to release a library that would help =D
11:00:04 <developernotes> I've tried let myinit :: [a] -> [a] but it says I am missing an accompanying binding.
11:00:19 <monochrom> developernotes: try this: let { x :: Int; x = 5 }
11:00:19 <shapr> byorgey: oooh, what?!
11:00:40 <shapr> oohh
11:00:57 <shapr> blend <*> pure red <*> pure blue
11:00:58 <byorgey> the library is called 'active' -- based on an idea from Andy Gill and Kevin Matlage, it basically gives you a nice interface for programming with 'active' values, i.e. values that change over time
11:01:08 <shapr> wow, awesome!
11:01:10 <byorgey> shapr: you can see it in action in that paste =)
11:01:20 <companion_cube> byorgey: you mean, FRP?
11:01:52 <byorgey> I suppose you could view it as a super-dumbed-down FRP-ish sort of thing.
11:02:01 <developernotes> monochrom:  thanks, I still get the same error message when I wrap it with {}.
11:02:03 <ski> developernotes : yeah, you need a definition like `myinit ... = ...'
11:02:26 <ski> developernotes : maybe you have a typo ? (show the code ?)
11:02:27 <mm_freak> rwbarton: i see
11:02:28 <developernotes> ski:  is there a way to allow for multi line entries?
11:02:29 <byorgey> but it's only useful for *continuously* changing values
11:02:32 <shapr> The only 32-bit linux system I have is my OLPC XO :-(
11:02:43 <shapr> so, not sure how to produce 32-bit GHC binaries
11:02:44 <ski> developernotes : yes, but i doubt you need it here
11:02:52 <mm_freak> rwbarton: but there is a point, where useful explanations stop and hairsplitting starts =)
11:02:52 <developernotes> let {myinit :: [a] -> [a]}
11:02:53 <ski> developernotes : well ..
11:02:53 <monochrom> the point is not only wrapping with {}
11:03:04 <shapr> Does GHC run with 256mb of ram and 1gb of storage?
11:03:06 <ski> developernotes : .. unless you're trying to enter this in GHCi, i.e. (are you ?)
11:03:20 <monochrom> type this in verbatim: let {x :: Int; x = 5}
11:03:27 <monochrom> and then read seriously what it contains
11:03:29 <developernotes> yes, sorry for not being clear - I am doing this in ghci - just trying to play around with it.
11:03:30 <ski> developernotes : ok, you are, so use `;', like monochrom suggests
11:03:46 <monochrom> the point is not just ";" either
11:04:03 <ski> developernotes : btw, you don't really need the braces, only the `;', like `let x :: Int; x = 5'
11:04:25 <shapr> byorgey: The circle is changing color... how is the start/stop time established?
11:04:36 <mm_freak> byorgey: what's "active" functional programming exactly?  FRP without events?
11:04:40 <developernotes> ski: does it all need to be contained to a single line within ghci when I use the ";"
11:04:58 <byorgey> shapr: ui :: Active Double  is an active value that changes from 0 to 1 starting at time 0 and ending at time 1
11:05:03 <ski> developernotes : yes, unless you use `:{' and `:}' instead
11:05:12 * shapr reads the hpaste again
11:05:54 <byorgey> shapr: combining with <*> just superimposes things in time
11:06:08 <byorgey> shapr: and takes the min start time and max end time
11:06:23 <zhulikas> getLine is in a sense impure because its result value is not guaranteed to be the same when performed twice.
11:06:30 <zhulikas> is it because user can write something else each time?
11:06:31 <developernotes> monochrom:  ski: thanks!
11:06:37 <byorgey> ui # scale (-tau)  goes from 0 to -tau  over the time interval [0,1]
11:06:38 <mm_freak> zhulikas: getLine itself is pure
11:06:50 <ski> zhulikas : `getLine' itself is pure, because it's always the same action (/ recipe)
11:06:55 <mm_freak> zhulikas: it is an action, not that action's result (hence IO String, not String)
11:07:19 <byorgey> mm_freak: I haven't thought too hard about the connection with FRP yet... but I guess it's like FRP without events and with explicitly tracked start/end times
11:07:29 <zhulikas> :|
11:07:30 <mm_freak> ah, ok
11:07:38 <shapr> byorgey: That sounds really usable when you put it that way :-)
11:07:45 <byorgey> =)
11:07:50 <ski> zhulikas : but yes, running the action two times, the result doesn't have to be the same, because the user can insert a different line
11:08:05 <shapr> byorgey: sooo... when do we get to play with it?
11:08:05 <mm_freak> zhulikas: you are never actually "running" actions…  you are just building actions like 'main'
11:08:23 <ski> byorgey : what is the start and end times for ?
11:08:25 <shapr> I'm not sure how I'd persuade this lib to output serial commands, but I'm sure I can figure it out.
11:08:33 <mm_freak> zhulikas: then there is an interpreter (like your machine) that actually runs your actions, and that's outside of the scope of haskell
11:08:38 <byorgey> shapr: soon!  I hope to have it cleaned up and released within a week
11:08:44 <shapr> awesomeness!
11:08:45 * ski . o O ( "end times actions" )
11:09:31 <byorgey> ski: so you can do things like sequence things one after another, reverse things in time, constrain something to take a certain amount of time, etc.
11:09:44 <shapr> That reminds me a bit of the original Haskore
11:09:49 <shapr> with transposition etc
11:09:57 <shapr> Easy ways to produce a crab canon :-)
11:10:17 <byorgey> yes, I think there are strong resemblances to Haskore
11:10:56 <shapr> I haven't played with Haskore in years, would like to do that again.
11:12:00 <shapr> BUT, haskore that lets me put anything Haskell into the notes would be WAY more interesting!
11:12:16 <shapr> Explicit time sequencing of Haskell code... hm
11:12:36 <mm_freak> does anyone know why banana brackets in arrow notation seem to require a fully polymorphic input type for the argument computations?
11:12:58 <mm_freak> (| f c |) fails to compile, whenever c does not have a fully polymorphic input type
11:13:58 * ski can't recall what banana brackets do
11:14:12 <mm_freak> however, it seems to work with less polymorphic additional inputs, like:  f :: Arrow a => a b c -> a (b, Int) c
11:14:21 <mm_freak> (| f c |) 100
11:14:22 <mm_freak> works
11:14:54 <dolio> Since when does arrow notation have that?
11:15:37 <mm_freak> ski: when using transformed computations, you can write (| f (c -< x) |) instead of:  f (proc x -> c -< x) -< x
11:15:59 <mm_freak> basically frees you from having to pass all your arrow variables to the transformed computation
11:16:26 <mm_freak> "transformed" in the sense of "passed through a function"
11:16:40 <shapr> byorgey: If you have your lib released by wednesday morning, I'll have hours of free time to make it work with my arduino RGB clock.
11:17:04 * ski doesn't quite follow
11:17:59 <mm_freak> ski: http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
11:18:03 <ski> mm_freak : must `c -< x' there have that exact shape, or could it e.g. be an arrow `do' ?
11:18:04 <mm_freak> see section 7.10.3
11:18:15 <byorgey> shapr: in that case I'll try!
11:18:16 <mm_freak> it can be do-notated
11:18:25 <mm_freak> you can use all arrow variables in scope
11:18:45 * ski can't imagine how that would be translated
11:19:22 <mm_freak> (| f (do x <- c1 -< v1; y <- c2 -< v2; returnA -< x + y + v3) |)
11:19:22 <dr_rotflcopter> hi, does your linux kernel support HRT by default ?
11:19:44 <mm_freak> basically becomes:  f (proc ((v1, v2), v3) -> …) -< ((v1, v2), v3)
11:20:42 <mm_freak> very useful, but seems to require the argument computation's input type to be fully polymorphic
11:21:00 <mm_freak> i have a transformer function, which has a constraint on the input type, and GHC rejects it
11:21:18 <mm_freak> f :: (Arrow a, SomeClass b) => a b c -> a b c
11:21:23 <ski> mm_freak : hm, and this requires `f :: forall a. ar a b -> ar a c' where `Arrow ar' ?
11:21:40 <mm_freak> seems so
11:21:58 <letrec> :t $!!
11:22:00 <lambdabot> parse error on input `$!!'
11:22:05 <letrec> :t ($!!)
11:22:06 <lambdabot> Not in scope: `$!!'
11:22:16 <ski> @hoogle ($!!)
11:22:17 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:22:46 <letrec> ski: Thx :)
11:22:52 <mm_freak> ski: seems to be documented, but in a different context, not in the context of (| |) notation, but rather in the context of regular combinator notation
11:23:42 <mm_freak> arrow notation allow you to write:  proc x -> do … <+> do … <+> do …
11:23:53 <mm_freak> where the <+> are lined up with the 'proc' keyword
11:24:11 <mm_freak> there it's explicitly documented that the input type for the arguments of <+> must be polymorphic
11:24:36 <mm_freak> don't really understand why
11:26:53 <aristid> mm_freak: i never understood the arrow proc syntax
11:28:49 <mm_freak> aristid: proc in its simplest form is really just syntactic sugar for (<<^)
11:29:11 <mm_freak> do-notation adds (.) (from Control.Category, not from Prelude)
11:29:36 <mm_freak> and creates implicit side-channels using first/second, whenever they are needed
11:29:38 <aristid> :t (<<^)
11:29:40 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> (b -> c) -> a b d
11:29:57 <mm_freak> proc x -> Kleisli putStrLn -< show x
11:30:09 <mm_freak> Kleisli putStrLn <<^ show
11:30:11 <aristid> mm_freak: (.) being (<<<)? :)
11:30:22 <mm_freak> yeah, (<<<) is an alias for (.)
11:30:51 <aristid> wasn't (>>>) the traditional Arrow function for that?
11:31:28 * hackagebot lhe 0.2 - Parse for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.2 (ScottLawrence)
11:32:15 <mm_freak> aristid: yeah
11:32:35 <mm_freak> used to be part of Arrow and there was no Category
11:33:48 <ski> mm_freak : well, from the rationale, it's clear that combinators that are polymorphic in the arrow inputs are sensible
11:34:18 <ski> it's not clear to me whether ones whose input aren't fully polymorphic are always sensible
11:35:27 <ski> let's take `(| f (do ..x..y..) |)' as an example, where `x,y :: Int'
11:36:16 <ski> let's say `f :: ar (Int,Int) a -> ar (Int,Int) a' (for some particular types `ar' and `a')
11:36:52 <beefcube> in ghci, how do i reload and run main all in one command? sorry, new to haskell
11:37:04 <ski> iiuc, one way to translate this would be `f (proc (x,y) -> do ..x..y..) -< (x,y)'
11:37:19 <ski> another way would be `f (proc (y,x) -> do ..x..y..) -< (y,x)'
11:37:35 <ski> mm_freak : how do we know that these two possible ways of translating it are equivalent ?
11:38:08 <ski> in the polymorphic `f :: forall e. ar e a -> ar e b' case, we know this, because of parametricity
11:39:05 <zhulikas> http://www.haskell.org/haskellwiki/99_questions/Solutions/23
11:39:10 <zhulikas> first solution
11:39:12 <zhulikas> return [l!!p | p <- pos]
11:39:14 <zhulikas> what happens here?
11:39:19 <mike-burns> :t return
11:39:20 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:39:24 <zhulikas> I understand only l!!p
11:39:26 <mike-burns> (Where m is .)
11:39:30 <mike-burns> (Where m is IO.)
11:40:08 <mike-burns> [l!!p | p <- pos]  can be read as: the p'th element of l for each p in pos.
11:40:12 <ski> > ["abcdefgh" !! p | p <- [0,1,3,7]]
11:40:13 <lambdabot>   "abdh"
11:40:21 <ski> > ["abcdefgh" !! p | p <- [0,2,4,6]]
11:40:22 <lambdabot>   "aceg"
11:40:28 <zhulikas> is pos a [Int] or Int ?
11:40:34 <zhulikas> oh, ok
11:40:36 <ski> `pos' is a list
11:40:46 <zhulikas> and what about that | ?
11:40:48 <ski> `p' will become, in turn, each element of `pos'
11:40:51 <zhulikas> in the middle
11:40:59 <ski> the `|' is part of the syntax of a list comprehension
11:41:27 <zhulikas> and I assume return [...] combines everything what's inside a [ ] into one IO (), right?
11:41:29 <ski> the general shape is `[expression | clauses]', which means : the list of every `expression' value, where `clauses'
11:41:38 <shachaf> zhulikas: Reading solutions to Haskell puzzles may not be the best way to learn Haskell. :-)
11:41:53 <zhulikas> shachaf, it's the first time when I am really lost
11:42:03 <zhulikas> but it kind of makes sense
11:42:18 <zhulikas> though I didn't know about replicateM
11:42:20 <ski> in the `["abcdefgh" !! p | p <- [0,2,4,6]]' case, it means : the list of all `"abcdefgh" !! p' (each of those are a character), where `p' is drawn from / comes from `[0,2,4,6]'
11:42:31 <byorgey> zhulikas: no,  return  does no combining
11:42:31 <zhulikas> ok, thanks
11:42:33 <zhulikas> :}
11:42:49 <shachaf> zhulikas: Well, you should probably read an introduction to the syntax, at least -- things like list comprehensions.
11:42:50 <ski> zhulikas : you should probably learn about list comprehensions before learning about `replicateM'
11:43:03 <shachaf> And then solve the puzzles yourself instead of reading other people's solutions. :-)
11:43:56 <mike-burns> `return' takes an   a   and produces an   IO a.
11:44:00 <mike-burns> 13:47:34*< kirindave> The Biggest Air Quotes
11:44:02 <zhulikas> list comprehension is awesome O.O
11:44:07 <mike-burns> Meh.
11:44:31 <ski> > [n^2 | n <- [0,1,2,3,4,5,6,7,8,9] , even n]
11:44:32 <lambdabot>   [0,4,16,36,64]
11:44:45 <zhulikas> but I kind of know the syntax... it's more about syntactic sugar I need to get familiar with
11:45:02 <shachaf> "syntax" *is* "syntactic sugar".
11:45:03 <ski> well, list comprehension is part of the syntax :)
11:45:24 <mike-burns> But it does desugar into map, filter.
11:45:47 <ski> (and `concatMap')
11:45:57 <ski> @undo ["abcdefgh" !! p | p <- [0,2,4,6]]
11:45:58 <lambdabot> concatMap (\ p -> ["abcdefgh" !! p]) [0, 2, 4, 6]
11:46:06 <ski> @undo [n^2 | n <- [0,1,2,3,4,5,6,7,8,9] , even n]
11:46:07 <lambdabot> concatMap (\ n -> if even n then [n ^ 2] else []) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
11:46:16 <mike-burns> Now @undo is awesome.
11:46:28 * hackagebot lhe 0.2.1 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.2.1 (ScottLawrence)
11:46:29 <ski> the first could have been done simpler with a `map', yes
11:46:30 * hackagebot hbro 0.7.0.0 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.7.0.0 (koral)
11:46:31 <beefcube> really? there is no simple way to do that? ugh, academic elitism at its best
11:46:32 * hackagebot lhe 0.2.2 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.2.2 (ScottLawrence)
11:47:47 <ski> beefcube : define your own GHCi command, using `:def'
11:48:54 <parcs> beefcube: first you troll ##c++, now #haskell? :)
11:49:14 <dr_rotflcopter> :)
11:50:29 <ski> beefcube : try `:def beefcube \_ -> return ":reload\nmain"', then try `:beefcube'
11:50:46 <copumpkin> beefcube: you'll not get any help by insulting and stereotyping the people you want to help you
11:51:28 <beefcube> copumpkin: too late
11:51:29 <shachaf> copumpkin: Oh. Is that where I went wrong in IRC?
11:51:42 <shachaf> I always thought it made people friendlier.
11:51:46 <copumpkin> beefcube: except for ski, who's too nice to get pissed off at assholes
11:55:05 <KitB> How about now, any of you know much about Graphics.Rendering.Chart?
11:55:05 <wlangstroth> shachaf: this channel is weird - here, I've had people *help* me with things, and not insult me in the process
11:55:32 <wlangstroth> it's a bit freaky, but once you get past that, it's fine
11:55:51 <shachaf> wlangstroth: I don't quite get it. Whenever that happens I just insult people more.
11:56:51 <copumpkin> wlangstroth: Thou burly-boned lily-livered fustilarian!
11:57:09 <wlangstroth> copumpkin: aw, I didn't know you cared!
11:57:13 <ski> @arr
11:57:14 <lambdabot> Ahoy mateys
11:57:27 <shachaf> @arrow
11:57:27 <lambdabot> Aye Aye Cap'n
11:57:41 <sp3ctum> @arr
11:57:42 <lambdabot> Shiver me timbers!
11:58:04 <mm_freak> ski: in your example both ways would be fine
11:58:34 <cmasseraf> Hello, anyone knows what's the maturity of the Distributed Haskell Project?
11:58:41 <mm_freak> ski: i'm saying it doesn't need to be fully polymorphic, it just has to follow some rules
11:59:00 <shachaf> cmasseraf: I think it's about 4.6.
11:59:12 * shachaf doesn't know.
11:59:18 <ski> mm_freak : yeah, but you agree an `f' with that type could conceivable give different answers for the two translations ?
11:59:30 <mm_freak> yes, i do
11:59:41 <ski> mm_freak : ok
11:59:44 <mm_freak> i understand your point
11:59:57 <ski> mm_freak : i'm not sure why you want/need a non-polymorphic one, though
12:00:37 <mm_freak> ski: basically this:  memoize :: Ord a => Auto a b -> Auto a b
12:00:49 <ski> (but yes, i see your point that one could require that the operation satisfy the property, and if it doesn't, the user could be blamed)
12:00:50 <mm_freak> (| memoize (do …) |)
12:01:09 <mm_freak> it would be awesome, if i could write it that way
12:01:18 <ski> interesting
12:01:34 <mm_freak> the Ord is ruling out (| |) notation
12:01:37 <ski> (you don't rely on *what* order there is, only that there is some order)
12:01:43 <mm_freak> yeah
12:01:45 <mm_freak> exactly
12:02:15 <mm_freak> i would also be fine with a slightly more verbose syntax for that purpose
12:02:17 <wlangstroth> copumpkin: Here's a good one: "Thou whoreson mandrake, thou art fitter to be worn in my cap than to wait at my heels."
12:02:32 <copumpkin> lol
12:02:40 <mm_freak> (|| memoize (scope (x1, x2) -> …) ||)
12:02:42 <ski> and i suppose you don't want to use a memo based on `unsafePtrEq' (or what's the name)
12:02:55 <mm_freak> no, i don't want impure code
12:02:57 <rwbarton> @hoogle reallyUnsafe
12:02:58 <lambdabot> No results found
12:03:17 <ski> mm_freak : well, as long as you can't observe any implementation detail of that, it's not impure
12:03:45 <mm_freak> ski: the 'memoize' example was simplified…  i need somewhat more control…  i do need to refer to the values, not just the pointers
12:03:57 <ski> wlangstroth : "I'm rubber, you're glue."
12:05:02 <ski> mm_freak : ok, so you have `Auto ... Blah' where `...' is not just a type variable, then ?
12:05:24 <mm_freak> ski: this is the full version:  cache :: (ArrowChoice (>~), ArrowClock (>~), Ord a, Ord t, Num t, Time (>~) ~ t) => Wire e (>~) a b -> Wire e (>~) ((a, t), Int) b
12:05:34 <mm_freak> you probably see why i simplified =)
12:05:58 <mm_freak> it should never replay for the same value and sharing is no option
12:06:22 <wlangstroth> ski: I am defeated, sir, for all insult that I cast thine way appear to bounce thence and become thereafter fixed to my person.
12:06:28 * hackagebot lhe 0.2.3 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.2.3 (ScottLawrence)
12:07:08 <ski> wlangstroth : "You fight like a dairy farmer."
12:07:53 * ski wonders what the `Int' and `t' is doing in mm_freak's `cache'
12:08:17 <mm_freak> t is the maximum age and Int is the maximum number of cached inputs
12:09:13 <ski> hm
12:09:31 <ski> i'm not sure how you mean to feed it a specific `t' and `Int', if you could use the banana syntax
12:10:02 <mm_freak> ski: the values themselves are not used, only the comparison…  i'm just saying that pointer comparison won't work here, because you can very well have this:  lift (Kleisli readFile) >>> cache
12:10:36 <mm_freak> well, assuming that banana syntax would allow the Ord, you can write this:  (| cache (…) |) 100 1000
12:10:49 <mm_freak> caches a maximum of 1000 entries for a maximum of 100 seconds each
12:11:11 <mm_freak> where t is some time delta unit in seconds like NominalDiffTime or Double
12:11:30 <ski> hm, and banana syntax supports that kind of "currying syntax" ?
12:11:36 <mm_freak> yes
12:13:03 <parcs> mm_freak: maybe ConstraintKinds can help you there
12:13:05 <hiptobecubic> What's the real difference in using type and data?
12:13:32 <parcs> memoize :: Dict (Ord a) -> Auto a b -> Auto a b
12:14:09 <mm_freak> ski: for a transformer f :: MyArrow (a, Int) b -> MyArrow a b you can even write:  (| f (\x -> …) |)
12:14:16 <mm_freak> where x :: Int
12:14:33 <ski> mm_freak : ok, this is a bit strange :)
12:14:35 <mm_freak> parcs: possibly, but i guess i'll have to wait a while for that to become available in arch linux =)
12:14:39 <ski> (maybe in a good way, i'm not sure)
12:15:25 <parcs> arch linux is still on 7.0.3 :(
12:15:39 <ski> mm_freak : well, you could do the GADT `data OrdDict :: * -> * where MkOrdDict :: Ord a => OrdDict a' ..
12:16:04 <mm_freak> ski: actually that's a very interesting idea
12:17:05 <mm_freak> i could also add a third constructor to Wire:  data Wire e (>~) a b where WMemo :: Ord a => (a >~ (Either e b, Wire e (>~) a b)) -> Wire e (>~) a b
12:17:10 <mm_freak> then i wouldn't even need 'cache'
12:17:22 <mm_freak> i could perform the caching in the arrow instances
12:18:39 <mm_freak> hmm, no…  that wouldn't work as well =/
12:19:48 <xil> hi. I'm looking for a library for matrix/vector operations. Google is giving me mixed results =/
12:20:02 <mm_freak> xil: like hmatrix?
12:21:12 <xil> mm_freak: uh...maybe? I'm looking at it but I can't find quite what I'm looking for
12:21:31 <mm_freak> xil: http://hackage.haskell.org/package/hmatrix
12:21:45 <xil> I'd like to be able to do things like define vectors or matrixes and then add, multiply, etc. them
12:22:18 <xil> yeah that's what I'm looking at
12:22:20 <mm_freak> xil: well, there is hmatrix for fast numerical vector/matrix calculations, and there is the vector-space package for vector space operations
12:22:28 <mm_freak> (unfortunately) they are unrelated
12:24:26 <Cale>     Couldn't match expected type `forall (a1 :: * -> *). Ref a1 x -> Ref (Instantiated a1) x''
12:24:26 <Cale>                 with actual type `forall (a1 :: * -> *). Ref a1 x -> Ref (Instantiated a1) x''
12:25:01 <xil> mm_freak: okay I found the Matrix data type in hmatrix. I think that's what I want, thanks =]. Now I just need to find the right functions
12:25:19 <c_wraith> Cale: that's impressive
12:25:31 <Cale> c_wraith: it's also quite frustrating
12:27:24 <dr_rotflcopter> hi
12:27:28 <dr_rotflcopter> does your linux kernel support HRT by default ?
12:28:25 <Cale> For reference, Instantiated here is a type family (an associated type)
12:28:30 <CakeProphet> elliott: hi
12:28:44 <rwbarton> hmm, glpk-hs won't build on GHC 7.2 because Data.Map.Map is missing an NFData instance
12:28:51 <rwbarton> who is supposed to provide that instance?
12:28:56 <Cale> I have no idea what's going on, but I guess there are enough real type errors to worry about for me at this point.
12:29:52 <ski> dr_rotflcopter : are you sure you're asking in the right channel ?
12:30:16 <c_wraith> rwbarton: you have the wrong version of deepseq installed
12:30:32 <c_wraith> rwbarton: use deepseq 1.1.*, not 1.2.*
12:30:33 <parcs> dr_rotflcopter: if the cpu supports it
12:30:40 <rwbarton> :(
12:30:50 <rwbarton> okay, thanks
12:36:38 <rwbarton> c_wraith: thanks, that worked.  What is the story here?  If I were the maintainer of glpk-hs, what would I do to avoid my users having this problem?
12:37:03 <rwbarton> just depend on deepseq 1.1.* unconditionally?
12:37:11 <c_wraith> rwbarton: the instance for NFData for Data.Map moved from deepseq to containers, because it can be more efficient in containers
12:37:38 <c_wraith> really, you should depend on deepseq and containers in linked versions
12:37:57 <c_wraith> because deepseq < 1.2 is broken for the version of containers that comes with ghc 7.2
12:38:22 <mm_freak> c_wraith: can you even fully force a Map outside of Data.Map?
12:38:39 <elliott> sure
12:38:39 <bytbox> Is there some way to read in a large (100MB) ASCII file without having horrible (4GB) RAM usage? At the moment I'm using readFile.
12:38:40 <elliott> toList
12:38:44 <c_wraith> mm_freak: well, it's spine strict, so yes.  just force all the values in it.
12:38:56 <elliott> c_wraith: surely toList would force any lazy spine too
12:38:57 <mm_freak> oh, ok
12:39:00 <mauke> bytbox: use ByteString
12:39:09 <bytbox> mauke: thanks, I'll try it
12:39:10 <c_wraith> elliott: that's true too, but even slower :)
12:39:20 <elliott> heh
12:42:36 <pcavs> What's the proper way to drop a known number of characters from the end of a string and from the start of a string? Is double reversing really what I should be doing?
12:43:40 <c_wraith> pcavs: it's the simplest, and for small strings, the inefficiency doesn't matter.  For large strings, you shouldn't be using String anyway
12:45:00 <rwbarton> there is a cleverer way to drop from the end, though
12:45:15 <rwbarton> zipWith const xs (drop n xs) -- drop the last n elements from xs
12:45:41 <mzero> rwbarton: +1!
12:45:49 <elliott> rwbarton++
12:45:50 <shachaf> rwbarton: Clever indeed.
12:45:59 <elliott> zipWith const might want a name.
12:46:01 <rwbarton> ... pretty sure I learned it here :P
12:46:03 <elliott> I think I saw someone else using it too.
12:46:41 <mzero> > let soLongAs = zipWith const in  "abcdefghijk" `soLongAs` [1..5]
12:46:42 <lambdabot>   "abcde"
12:47:00 <rwbarton> and yeah, I thought it was quite clever when I saw it too
12:47:45 <elliott> > liftA2 (zipWith const) (drop 2) [1,2,3,4,5]
12:47:47 <lambdabot>   Couldn't match expected type `[a] -> [b]'
12:47:47 <lambdabot>         against inferred type `[a...
12:48:05 <ique> Is there a way to do ++ in multiple lines? I just want to concat three lists together so I could do concat [one, two, three] with newlines between those three elements but it would look tidier if I could do one ++ two ++ three over multiple lines.
12:48:11 <elliott> :t liftA2 (zipWith const) (drop 2)
12:48:12 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [a]
12:48:15 <elliott> oh, duh
12:48:39 <dmwit> :t ap (zipWith const) (drop 2)
12:48:40 <lambdabot> forall b. [b] -> [b]
12:49:21 <dmwit> ique: Yes, that's fine.
12:49:29 <rwbarton> ique: sure, you can format any expression over multiple lines provided you indent it properly
12:50:12 <ski> > getZipList ((liftA2 const `ap` (ZipList . drop 2 . getZipList)) (ZipList [1,2,3,4,5]))
12:50:14 <lambdabot>   [1,2,3]
12:50:55 <ique> Oh I see! I tried but got an error message, so I assumed you had to do something special with parens or something
12:50:56 <alistra> what's the best way to get a line from a user, that is basically "34 23", two ints separated by a whitespace, i want to have IO (Int,Int)
12:51:27 <Cale> alistra: What do you want to have happen when it doesn't parse?
12:52:00 <alistra> try again?
12:52:05 <alistra> would be the best
12:52:23 <mzero> alistra: getLine >>= return . map read . words
12:52:27 <ski> alistra : you might try `[m,n] <- liftM (map read . words) getLine' if you don't care about errors
12:52:32 <Cale> fmap (map read . words) getLine
12:52:49 <Cale> will read the words, but if there's a parse failure, it doesn't manage so well
12:52:53 <mzero> which returns as IO [Int]
12:52:55 <ski> mzero : `foo >>= return . bar' is the same as `liftM bar foo' (and that's the same as `fmap bar foo', yes)
12:52:55 <Cale> yeah
12:53:19 <mzero> ski: aware, I was typing as you were ---
12:53:23 <alistra> oh words
12:53:43 <Cale> [sm,sn] <- fmap words getLine
12:53:47 <Cale> m <- readIO sm
12:53:48 <ski> mzero : ok. please don't write `... >>= return . ...' anymore, then ;)
12:53:52 <Cale> n <- readIO sn
12:54:01 <Cale> will throw an exception in IO if there's a parse failure
12:54:26 <Cale> Which you should be able to catch
12:54:43 <alistra> ok, thanks very much Cale++
12:54:49 <alistra> mzero++ ski++
12:55:21 <mzero> ski: asl    bar `fmap` foo   --- my fav. since liftM isn't in the prelude
12:55:45 <sbi> i feel bad every time i see a postincrement
12:56:02 <bobzhang> hi, does anybody know which flag is used to turn such warnings "Warning: Defined but not used: `f'"
12:56:13 <ski> mzero : *nod*, except i use (because of hysterical raisins) `liftM' if the code is polymorphic in the monad
12:56:15 <bobzhang> sorry, turn off
12:56:19 <mzero> oh, I don't know - sometimes I find   >>= return    more clear - it depends on how long the stuff after the return is, and the other statements around it
12:56:25 <alistra> nobindsomething bobzhang
12:56:26 <alistra> :P
12:56:49 <mzero> but hey, Haskell is TIMTOWDY!
12:56:55 <bobzhang> I added -fno-warn-unused-binds
12:57:00 <bobzhang> does not work
12:57:11 <alistra>        -fwarn-unused-binds
12:57:35 <bobzhang> alistra: I want to turn off the warning, quite anonying
12:57:39 <ski> mzero : *nod*, but my way is the correct one ;)
12:57:41 <alistra> try at the to of the file?
12:58:00 <alistra> are you using a pragma or ghci parameter?
12:58:16 <bobzhang> I put {-#OPTINS_GHC -fno-warn-unused-binds #-} in the file
12:58:16 <mzero> @src liftM
12:58:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:58:22 <mzero> your way is my way!
12:58:25 <bobzhang> OPTIONS_GHC
12:58:25 <dylex> :t (<$>)
12:58:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:58:34 * ski wonders whether sbi prefers predecrements
12:59:30 <sbi> ski, better :p
13:01:28 * hackagebot lhe 0.3 - Parser and writer for Les-Houches event files  http://hackage.haskell.org/package/lhe-0.3 (ScottLawrence)
13:05:13 <rekahsoft> :i Monad
13:05:32 <rekahsoft> > 1 + 1
13:05:33 <lambdabot>   2
13:05:42 <chreekat> From a little googling I've found that "there are a few hoops to jump through to get [an executable that uses TH] to compile with profiling." From this (old) ticket: http://goo.gl/Yg5Ka , I am led to believe that one of those hoops might be 'declaring that [the executable] uses TemplateHaskell'. What does that mean exactly, assuming it is relevant?
13:05:42 <rekahsoft> :info Monad
13:05:58 <parcs> > (zipWith const <*> drop 2) [1..5]
13:05:59 <lambdabot>   [1,2,3]
13:06:09 <parcs> > (zipWith const =<< drop 2) [1..5]
13:06:10 <lambdabot>   [3,4,5]
13:06:34 <ski> @src Monad
13:06:35 <lambdabot> class  Monad m  where
13:06:35 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:06:36 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:06:36 <lambdabot>     return      :: a -> m a
13:06:36 <lambdabot>     fail        :: String -> m a
13:06:37 <ski> @index Monad
13:06:38 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:08:47 <aavogt> chreekat: compiling with -XTemplateHaskell or having {-# LANGUAGE TemplateHaskell #-} at the top of the file
13:15:13 <mzero> parcs++
13:24:08 <unlink> @pl \f (a,b,c) -> f a b c
13:24:08 <lambdabot> (line 1, column 8):
13:24:09 <lambdabot> unexpected ","
13:24:09 <lambdabot> expecting letter or digit, operator or ")"
13:24:09 <lambdabot> ambiguous use of a non associative operator
13:24:19 <chreekat> aavogt: I guess that was a false lead then -- the files in question already have the LANG pragmas
13:29:04 <etpace> hm.. I've seen how to create a polyvariadic function (with the printf example), but is it possible to create a function that takes a list of length n, and then a function of n-arity and applies each argument in the list to f?
13:33:00 <dylex> etpace: no... the function's arity is encoded in its type (at least implicitly), while the list's length is not
13:33:09 <xil> I'd like to make some constant Vectors and Matrixes, but I need to use functions to make them. Can I rely on Haskell to remember the values and not recalculate them every time? For example if I have "myConst = 4 |> [1..4]" I know Haskell will compute the Vector the first time I obtain the value of myConst, but can I rely on it not recalculating periodically/every time?
13:34:55 <dylex> etpace: but, on the other hand, yes, if you don't care about checking the length of the list at compile time
13:36:28 * hackagebot cblrepo 0.4.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.4.1 (MagnusTherning)
13:38:52 <hiptobecubic> What would be the most reasonable way to do element wise subtractraction of list b from a?
13:39:22 <monochrom> map (subtract a) b
13:39:27 <mauke> zipWith (-)
13:39:37 <monochrom> > map (subtract 1) [3,1,4]
13:39:38 <lambdabot>   [2,0,3]
13:40:51 <alistra> > map (-1) [3,1,4]
13:40:53 <lambdabot>   [-1,-1,-1]
13:41:16 <alistra> :t (-1)
13:41:17 <lambdabot> forall a. (Num a) => a
13:41:38 <alistra> unary minus is what's wrong with todays world
13:43:38 <hiptobecubic> i assume nothing i said went through...
13:44:11 <monochrom> you last said "What would be the most reasonable way to do element wise subtractraction of list b from a?"
13:44:27 <monochrom> we last said "map (subtract 1) [3,1,4]" and "zipWith (-)"
13:44:27 <hiptobecubic> monochrom, ok.
13:44:46 <hiptobecubic> It seems like a lot of the art of writing decent haskell is learning the library functions well and leaning on them hard. My first thought was [x-y | (x,y) <- zip a b]... which is probably because that's the only way I can think of in python.
13:45:15 <Cale> hiptobecubic: that's pretty acceptable
13:45:19 <geheimdienst> hiptobecubic: that's not terrible either
13:45:20 <monochrom> [x-y | (x,y) <- zip a b] is totally cool, don't feel bad about it.
13:45:38 <monochrom> and IMO python is the one that really stresses learning the library
13:46:01 <Cale> Knowing the list library is pretty important in Haskell though, that's true, I think.
13:46:26 <hiptobecubic> monochrom, you think? I find that writing ugly list comprehensions and overloading operators does most of the work for me.
13:46:28 * hackagebot attoparsec 0.10.0.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.0.0 (BryanOSullivan)
13:46:30 * hackagebot attoparsec-text 0.8.5.2 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.5.2 (BryanOSullivan)
13:46:31 <Cale> But pretty much everyone ends up reimplementing half of it on their own anyway
13:46:49 <hiptobecubic> Cale, i think that's because there are lots of great functions that you just never hear about
13:46:52 <Cale> yeah
13:46:55 <hiptobecubic> i just discovered uncurry
13:47:17 <monochrom> reason is that e.g. haskell prelude stuff is pretty user-definable and trivial. you may just as well roll your own and most importantly rolling your own does not cause a serious performance hit.
13:47:31 <hiptobecubic> which i needed yesterday and ended up changing a bunch of functions to take tuples instead of two args because it didn't occur to me to write a fucntion that modified my problematic function
13:48:05 <monochrom> whereas in python, most libraries (even prelude or whatever it's called there) are FFI bindings. if you roll your own, well you can, but it's hard and it's dog slow.
13:49:15 <geheimdienst> hiptobecubic: the way for me to learn about those little functions and tricks was putting code on hpaste and asking in here for improvements
13:49:19 <Cale> Well, I'm thinking of it just as a learning process. It's good, but a little boring to start learning the language by sitting there and carefully reading through the entire set of standard libraries. You pick things up and find out about them as you go, usually.
13:49:28 <geheimdienst> ... and to some extent also reading and messing with xmonad's sources
13:49:30 <Cale> But the Prelude is one worth reading, certainly.
13:50:09 <hpc> the prelude is almost a good introduction to haskell all on its own
13:50:20 <monochrom> you mention list. so take list for example. you can define your own list type and your own list library. it will not be too much slower than prelude's list functions. (just a bit.) and then if you know about GHC's RULES pragma, your custom list library will not be slower at all.
13:50:29 <hpc> (it lacks good examples of IO and other monadic style, plus it uses 'error' too much)
13:50:42 <Cale> yeah, from a performance standpoint, there's not really much harm in defining your own stuff.
13:50:43 <monochrom> now try defining your own list type and functions in python.
13:51:02 <sbi> well if learning by reading library is boring in haskell what about lisp/scheme
13:51:03 <hpc> monochrom: piece of cake, but python uses dict/array :P
13:51:06 <Cale> Well, there are also some unboxed type tricks involved in some list functions (take/length/etc.)
13:51:25 <Cale> But it is still doable in something which looks mostly like Haskell :)
13:51:49 <hpc> @src take
13:51:49 <lambdabot> take n _      | n <= 0 =  []
13:51:50 <lambdabot> take _ []              =  []
13:51:50 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:52:06 <Cale> That's not the actual source, that's the source from the Report.
13:52:09 <hpc> ah
13:52:11 <dr_rotflcopter> anybody here having linux and willing to check this for me?
13:52:15 <hpc> @src Int
13:52:15 <dr_rotflcopter> grep -Ei 'now at.*|\.resolution:.*|event_handler:.*' /proc/timer_list | sort -u | tr "\n" ","
13:52:15 <lambdabot> data Int = I# Int#
13:52:27 <Cale> *that's* a bit of actual source :)
13:53:39 <mauke> dr_rotflcopter: useless use of .*
13:53:50 <mauke>   .resolution: 1 nsecs, event_handler:  hrtimer_interrupt, event_handler:  tick_handle_oneshot_broadcast,now at 7417729055280944 nsecs,
13:53:50 <dr_rotflcopter> ok :)
13:54:00 <hiptobecubic>   .resolution: 1 nsecs, event_handler:  hrtimer_interrupt, event_handler:  tick_handle_oneshot_broadcast,now at 8024120912250 nsecs,
13:54:05 <dr_rotflcopter> cool, you have realtime kernel too
13:54:46 <dr_rotflcopter> i mean high resolution timer
13:54:50 <dr_rotflcopter> :)
13:55:05 <dr_rotflcopter> what is your version?
13:56:02 <seafood> What's the status of GHC on Mac OS X Lion? (10.7)
13:56:12 <seafood> Are there any binary installer packages that work on it?
13:56:13 <strager> Interesting; I get a different ordering.  sort isn't ignoring the . prefix.   event_handler:  hrtimer_interrupt, event_handler:  tick_handle_oneshot_broadcast,now at 184441865205107 nsecs,  .resolution: 1 nsecs,
13:56:28 * hackagebot attoparsec 0.10.0.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.0.1 (BryanOSullivan)
13:57:03 <marlo> trying out haskell. :D
13:58:32 <strager> or isn't ignoring whitespace
13:58:41 <strager> try sort -b, dr_rotflcopter
13:58:44 <strager> -bu
14:00:26 <dr_rotflcopter> yeah i see
14:01:10 <noidea> Hello. Im trying to install Yi via cabal on Ubuntu 11.0. I'm receiving a package dependency complication between ghc and yi. Is it ok if I paste the error?
14:01:19 <alistra> dr_rotflcopter:  event_handler:  hrtimer_interrupt, event_handler:  tick_handle_oneshot_broadcast,now at 777164300324440 nsecs,  .resolution: 1 nsecs,%
14:01:19 <noidea> 11.04*
14:01:28 * hackagebot attoparsec 0.10.0.2 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.10.0.2 (BryanOSullivan)
14:02:03 <dr_rotflcopter> so everybody having tickless kernels with high resolution timer enabled i guess ;>
14:02:21 <monochrom> paste the error on hpaste.org
14:03:40 <noidea> monochrom: thanks. http://hpaste.org/54377
14:04:43 <monochrom> does yi really require Cabal 1.10.*?
14:04:59 <pcavs> Do people have experience with using the Alex lexer? If so, could you point to any example lexers for real* languages that use Alex? real* = non toy
14:05:27 <noidea> I dont know. Ive just been reading that this is the best way to do it. I dont really have time to compile it myself atm, even if there was a guide.
14:05:32 <monochrom> ah, it does. use an older yi or a newer GHC
14:06:30 * hackagebot configurator 0.2.0.0 - Configuration management  http://hackage.haskell.org/package/configurator-0.2.0.0 (BryanOSullivan)
14:06:50 <wlangstroth> bos is on a roll
14:07:10 <bos> amazing what a bit of time off will do
14:07:31 <wlangstroth> :)
14:07:43 <_Mikey> :t >>>
14:07:45 <lambdabot> parse error on input `>>>'
14:08:00 <_Mikey> :t (>>>)
14:08:01 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:08:55 <_Mikey> :t first
14:08:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:09:31 <hpc> pcavs: not many useful languages are parsable with just a lexer
14:10:15 <noidea> ha. yi-0.6.2.4 is installing
14:10:34 <noidea> neither 0.6.3.0 or 0.6.4.0 installed
14:10:56 <noidea> thats rather strange considering its newer, but requires an older version of cabgal?
14:11:00 <noidea> cabal*
14:11:17 <pcavs> hpc: I guess I mean Alex -> Happy
14:12:12 <hpc> pcavs: ah, in that case i have no idea
14:12:36 <hpc> pcavs: naively, i would guess that it would look about the same as the same language implemented with lex/yacc
14:12:43 <hpc> albeit in haskell
14:12:49 <alistra> hpc: regular languages are parsed with just a lexer
14:13:11 <alistra> hpc: context-free -> grammars
14:13:22 <alistra> formal languages!
14:14:10 <hpc> alistra: you know what i mean :P
14:14:44 <hpc> alistra: i could be obnoxious and say that lexers are technically turing machines because you can perform arbitrary computation on the .* pattern
14:15:35 <alistra> i could be obnoxious and say that it isn't even regular, because memory in you pc is to small to encode some automata
14:15:58 <alistra> computation complexity'd
14:16:50 <alistra> finite disk space and ram :D
14:16:54 <c_wraith> alistra: that's ok, I cache to the internet
14:17:09 <alistra> c_wraith: and that helps, because internet is infinite
14:17:28 <c_wraith> alistra: close enough.  The available capacity is growing faster than transmission speeds. :)
14:17:54 <alistra> especially in eastern europe
14:21:59 <mooseburger> I'm having a problem with the module Control.Monad.State. After I import it in ghci, I don't seem to have the "state" function.
14:23:26 <c_wraith> mooseburger: what version of mtl?
14:23:41 <c_wraith> mooseburger: I think that function was added in mtl2, and didn't exist before then
14:24:03 <monochrom> that's correct
14:24:06 <mooseburger> oh
14:24:14 <mooseburger> I have mtl 1.1.0.2
14:24:32 <monochrom> dually, data constructor "State" was in mtl-1 and not in mtl-2
14:25:15 <wto> @src any
14:25:16 <lambdabot> any p =  or . map p
14:25:17 <monochrom> Corollary: to migrate between mtl-1 and mtl-2, replace "State" by "state" or vice versa at the value level. (don't change the type level.)
14:25:39 <wto> @src or
14:25:40 <lambdabot> or    =  foldr (||) False
14:26:49 <mooseburger> does anyone know if Ubuntu 11.10 has mtl-2/
14:26:51 <mooseburger> ?
14:27:10 <c_wraith> I pretty much universally recommend against using distro versions of GHC
14:27:22 <c_wraith> but, in this case, you can just take monochrom's advice
14:27:29 <c_wraith> and use State in place of state
14:27:40 <c_wraith> it has the same type, and does the same thing
14:28:28 <monochrom> http://packages.ubuntu.com/oneiric/libghc-mtl-dev
14:30:01 <ross_> @src foldr1
14:30:02 <lambdabot> foldr1 _ [x]    = x
14:30:02 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:30:02 <lambdabot> foldr1 _ []     = undefined
14:31:28 * hackagebot hosc 0.11 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.11 (RohanDrape)
14:31:58 <carpi> could someone please tell me why this is right or wrong? or if what im doing is even valid? http://codepad.org/xhjZTvPT
14:32:23 <carpi> it is one of the problems from "99 haskell problems" webpage
14:34:26 <shachaf> carpi: I don't know what you're trying to do, but that's probably the wrong way to do it.
14:34:30 <shachaf> What's the problem?
14:34:40 <c_wraith> carpi: that's amazingly inefficient
14:35:20 <carpi> shachaf: it is a problem where I have to find the kth element in a list
14:35:41 <hpaste> Anon pasted “WhyLoop” at http://hpaste.org/54378
14:35:44 <carpi> the 3rd problem in the 99 problem website to be exact
14:35:47 <c_wraith> carpi: well, then, the code is both wrong and O(n^2) when it could be O(n)
14:35:48 <shachaf> Oh. Well, yes, there exists a much simpler way of doing that.
14:36:08 <carpi> one moment..
14:36:19 <carpi> may i show some of the other ways i came up with..
14:36:20 <carpi> one sec
14:36:28 * hackagebot hsc3 0.11 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.11 (RohanDrape)
14:36:29 * shachaf >>= undefined
14:36:33 <_Mikey> hey guys
14:36:50 <carpi> http://codepad.org/1fjm95Fn
14:36:54 <carpi> ^ are they any good?
14:36:55 <_Mikey> why does the code Anon posted loop?
14:37:11 <d34df00d_> Hi!
14:37:16 <_Mikey> hey
14:37:23 <d34df00d_> Where should I report excessive memory usage by GHC?
14:37:35 <d34df00d_> I don't think my program really needs >7 TiB of RAM to compile.
14:37:39 <shachaf> carpi: The first looks OK.
14:37:47 <shachaf> carpi: You should pretty much never use "length".
14:37:49 <shachaf> Except when you should.
14:38:01 <shachaf> But keep in mind that it's a semi-evil function.
14:38:08 <_Mikey> :)
14:38:13 <elliott> d34df00d_: You have 7 TiBs of RAM?
14:38:16 <elliott> And GHC is exhausting it?
14:38:29 <shachaf> elliott: Maybe GHC is requesting that much RAM.
14:38:37 <d34df00d_> elliott: nope.
14:38:38 <c_wraith> carpi: however, there's a case you aren't handling...  GHC would tell you about it if you used -Wall
14:38:46 <jessopher> its not like he doesn't have enough to share
14:38:49 <d34df00d_> I don't have 7 TiB of RAM, and I get `ghc: out of memory (requested 7015595245568 bytes)`
14:38:53 <shachaf> c_wraith: You can't really handle that case except with _|_...
14:39:03 <elliott> d34df00d_: Oh. Well, it doesn't need >7 TiB, it just needs 7 TiB.
14:39:05 <carpi> c_wraith: is true.. soo true.. and thats what im breaking my head over..
14:39:10 <elliott> It should work if you buy more RAM ;-)
14:39:11 <c_wraith> shachaf: true, but at least you could use a better error message
14:39:13 <shachaf> d34df00d_: Sounds like an actual bug.
14:39:17 <shachaf> @hug d34df00d_
14:39:18 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:39:19 <carpi> c_wraith: everytime 'n' is greter than the length of the list.. i get an exception
14:39:31 <d34df00d_> elliott: oh, I thought 16 GiB would be enough for quite a long when I upgraded last time :(
14:39:34 <d34df00d_> shachaf: thanks.
14:39:44 <elliott> d34df00d_: Moore's law!
14:39:45 <hpaste> Mikey annotated “WhyLoop” with “WhyLoop (annotation)” at http://hpaste.org/54378#a54379
14:39:55 <c_wraith> carpi: yep.  But what else can you do?  What if you're asked for the first element of an empty list?
14:39:58 <shachaf> 16GB is nothing these days.
14:40:12 <c_wraith> carpi: (there's an answer, but you have to change the type signature)
14:40:25 <d34df00d_> shachaf: should I really attach all my sources? I wasn't able to narrow down the problem to a somewhat short example, and my sources are ~1200 LOC.
14:40:42 <carpi> c_wraith: change sig? for which problem? finding first element or kth elemnt?
14:40:53 <c_wraith> carpi: they're the same problem
14:41:12 <shachaf> d34df00d_: Narrowing it down would be a good idea if ypossible.
14:41:23 <jessopher> dead food: use the profiler
14:41:28 * hackagebot hsc3-dot 0.11 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.11 (RohanDrape)
14:41:47 <d34df00d_> Well, I guess I could at least find when does my program start requesting such amounts of memory to compile.
14:42:05 <d34df00d_> jessopher: I'm afraid profiler won't help.
14:42:05 <jessopher> oh, to compile
14:42:12 <jessopher> no, it wont
14:42:32 <jessopher> well, if you have profiling compiled into ghc, and you run ghc with profiling, lol
14:42:39 <carpi> c_wraith: so you're saying that with one small change i can take care of all the cases for finding kth element more efficiently?
14:42:50 <jessopher> but not thats dumb
14:43:49 <d34df00d_> Ok, thanks, I'd try now to find what line causes such behavior.
14:44:12 <jessopher> d34df00d_ do you have any sort of revision history of this program?
14:44:36 <d34df00d_> Yep.
14:44:42 <d34df00d_> Local git repo FTW!
14:44:51 <jessopher> why not just roll it back till it stops?
14:45:20 <d34df00d_> The last commit is fine (I commit only after compiling and running successfully), so that'd hardly help.
14:45:31 <d34df00d_> I guess (well, I'm sure) the change in quesion is since the last commit.
14:45:36 <Jafet> (Isn't every git repo local, by definition?)
14:45:43 <elliott> d34df00d_: git diff | hpaste?
14:45:46 <d34df00d_> Jafet: I mean, even not pushed to any remote.
14:45:57 <d34df00d_> (though my one is pushed occasionally)
14:46:28 * hackagebot hsc3-db 0.11 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.11 (RohanDrape)
14:46:36 <carpi> c_wraith: ?
14:47:46 <d34df00d_> Hm, strange things.
14:47:56 <d34df00d_> I am now unable to compile even that stuff that compiled successfully.
14:48:07 <carpi> shachaf: can you please tell me if my where clause is syntactically valid?
14:48:16 <jessopher> sounds like its probably not your source code then
14:49:32 <shachaf> carpi: I have no idea.
14:49:43 <shachaf> If GHC accepts it without a syntax error then probably.
14:49:49 <d34df00d_> Hmmm, I guess I was too pessimistic (or to optimistic to find a good bug to report).
14:50:03 <d34df00d_> I walked back and forth through commit history, and now everything compiles fine back again.
14:50:19 <d34df00d_> Even the latest code, that failed 15 minutes ago.
14:50:41 <d34df00d_> Though I removed *{hi,o} between every compile tries.
14:50:42 <jessopher> sounds like you need to tweek your p-ram
14:50:47 * d34df00d_ wonders what is that.
14:50:48 <carpi> shachaf: but what i would like to know is if chaining the "where" clause where the higher most functions depend on the lower most functions works as we expect it to?
14:50:53 <d34df00d_> jessopher: eh?
14:51:15 <jessopher> its a pauly shore quote
14:51:19 <sipa> carpi: within one where block, all definitions can depend on one another
14:51:35 <sipa> including thenselves
14:51:46 <d34df00d_> Oh, I don't seem to know it :(
14:51:53 <Jafet> Speaking of RAM, consider memtest
14:54:03 <d34df00d_> Yeah, that's a good idea.
14:54:07 <d34df00d_> I'd try at next boot.
14:55:14 <Jafet> ...as a last resort.
14:55:34 <Jafet> Surely if your hardware was faulty, it would be showing by now.
14:55:50 <Peaker> I had debugged some C compilation issues for many hours until I discovered it was some bug/edge case in ccache -- since that time I never use compilation caches anymore
14:56:01 <d34df00d_> No segfaults in dmesg, or otherwise strange behavior.
14:56:28 * hackagebot hsc3-rec 0.11 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.11 (RohanDrape)
14:56:30 * hackagebot hsc3-unsafe 0.11 - Unsafe Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-unsafe-0.11 (RohanDrape)
15:03:17 <carpi> was it jus me or did everyone get disconnected?
15:04:28 * d34df00d_ is still online.
15:04:58 <sipa> carpi: you had a ping timeout
15:05:12 <sipa> so it's most likely a problem with your local internet connection
15:06:23 <carpi> oh btw.. someone here said length was evil or rather semi evil
15:06:28 <carpi> it doesn't seem so
15:06:34 <epsilon108> hello... I'm somewhat new to programming and I'm trying to decide on which language would be good to learn... I was considering maybe python.  i enjoy set theory and mathematical logic though... so I was thinking that Haskell could be the right fit for me... any advice?
15:07:18 <shachaf> carpi: I said that and I'll stand by it!
15:07:34 <shachaf> carpi: If you're using length it probably indicates something bad.
15:08:28 <carpi> haskell is like the BBC of the programming world. so once you go haskell you can't go any else )
15:08:37 <carpi> epsilon108: so do haskel)
15:08:42 <hpc> epsilon108: go through the first chapter or so of LYAH
15:08:45 <hpc> @where lyah
15:08:46 <lambdabot> http://www.learnyouahaskell.com/
15:08:54 <carpi> shachaf: maybe its true.. but length itself is not so bad
15:08:56 <blackdog> shachaf: why is length evil?
15:08:59 <hpc> epsilon108: you'll know right away which language you want to learn :P
15:09:09 <blackdog> space behaviour?
15:09:33 <shachaf> blackdog: It's evil when you're learning Haskell and using it for things like http://codepad.org/xhjZTvPT
15:09:46 <hpc> blackdog: it breaks down on infinite lists, and it tends to indicate that you haven't thought your algorithm through enough
15:09:51 <blackdog> shachaf: ouch
15:09:51 <epsilon108> haha ok
15:09:55 <hpc> blackdog: like using (!!) to reimplement map
15:10:19 <blackdog> hpc: lots of things break down on infinite lists:)
15:10:30 <carpi> even math : )
15:10:32 <epsilon108> thanks for the suggestions
15:10:33 <blackdog> but yeah, if you're using it in a loop there's probably something wrong
15:10:33 <carpi> -- sometimes
15:11:29 * hackagebot hsc3-sf 0.11 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.11 (RohanDrape)
15:12:57 <carpi> does hackagebot make an announcment whenever someone uploads or updates a package in hackage?
15:13:03 <rostayob> yes it does
15:13:16 <shachaf> Using /me, for some reason.
15:13:24 <rostayob> he's boasting.
15:13:51 <epsilon108> will i be able to read these if i don't have much experience with programming yet?
15:14:03 <mauke> it would make a bit more sense if it did /nick hackage and used /me upload ...
15:14:30 <carpi> epsilon108: its easy if you want it to be. its hard if the moment the thought of giving up crosses your mind
15:14:46 <carpi> eventually.. the ones who it bad.. will learn it anyhow ;)
15:14:56 <carpi> s/who/"who want"
15:15:09 <rostayob> is there any package to work with vectors/points on a sperical surface?
15:15:22 <rostayob> there is probably some mathematical term for that that i'm not aware of
15:15:25 <epsilon108> haha, alright
15:15:49 <carpi> anyone else feel.. writing haskell code is like playing civilization..? "mom.. just one more function.. pleaseeeee" : D D D
15:16:23 <Pseudonym> rostayob: I'd be tempted to use quaternions for that.
15:16:30 * hackagebot hsharc 0.11 - Haskell SHARC bindings  http://hackage.haskell.org/package/hsharc-0.11 (RohanDrape)
15:16:44 <Pseudonym> 3D spinors
15:16:51 <Pseudonym> But I guess it depends what operations you need to do.
15:16:53 <rostayob> Pseudonym: I want to simulate objects moving on the surface of a sphere
15:17:01 <Pseudonym> So you want dynamics?
15:17:04 <d34df00d_> Hmm, where can I read about SpecConstr transformation or something?
15:17:18 <Pseudonym> Or just some kind of interpolation between positions?
15:17:24 <rostayob> i don't know what dynamics means, in this context
15:17:27 <d34df00d_> I have a function with 7 pattern matching cases, and ghc with -o@ complains.
15:17:31 <Pseudonym> Dynamics in this case means physics.
15:17:56 <rostayob> Pseudonym: oh, no. I just want to move points, and calculate distances
15:18:06 <Pseudonym> How do you want to move them?
15:18:12 <monochrom> #haskell is like playing civilization
15:18:25 <Pseudonym> Like navigation, sort of thing?
15:18:38 <rostayob> Pseudonym: each element has a velocity and they avoid each other
15:18:49 <rostayob> on a normal plane they're really simply operations with vectors
15:19:03 <Pseudonym> Oh, I see.
15:19:25 <rostayob> but I'd like to have a "closed" space and the most intuitive thing is a finite sphere
15:19:27 * applicative thinks, 'every document of civilization is a document of barbarism' but maybe that wasn't about the game. 
15:19:28 <Pseudonym> You have to realise that Brouwer's theorem is the problem here.
15:19:37 <Pseudonym> You can't comb a hairy ball smooth.
15:19:41 <rostayob> i think it's some kind of geometry, but i don't know much about maths
15:20:00 <Pseudonym> Any coordinate system that you pick will either have a singularity or a gauge symmetry.
15:20:09 <Pseudonym> Ah.
15:20:09 <rostayob> Pseudonym: ok, now I don't know what you're talking about :P
15:20:19 <Pseudonym> Yeah, OK.
15:20:25 <Pseudonym> Have you heard of quaternions?
15:20:29 <rostayob> nope
15:20:31 <d34df00d_> Gauge simmetry?
15:20:34 <d34df00d_> What's that?
15:20:35 * mehitabel is the angel of history, processing logs
15:20:52 <d34df00d_> I guess I could deduce the meaning of singularity here, but not gauge symmetry.
15:20:56 <c_wraith> quaternions sound like 4-sided onions.
15:20:59 <d34df00d_> Or even both, maybe.
15:21:09 <Pseudonym> d34df00d_: A singularity is something like the north and south poles on many map projections.
15:21:22 <d34df00d_> Yeah, that's intuitive.
15:21:28 <d34df00d_> But how you'd define it more, eh, strictly?
15:21:29 <Pseudonym> A gauge symmetry is where you add degrees of freedom to your coordinate system.
15:21:30 * hackagebot hsc3-lang 0.11 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.11 (RohanDrape)
15:21:36 * applicative thinks, quaternips, quatarsnips
15:21:42 <Pseudonym> So, for example, think of unit vectors.
15:21:52 <Pseudonym> A sphere can be thought of as a unit vector.
15:22:07 <Pseudonym> Unit vectors are three-dimensional objects, but the surface of a sphere is two-dimensional.
15:22:16 <rostayob> yeah
15:22:18 <mehitabel> (*set* of unit vectors)
15:22:21 <d34df00d_> I'm not native English speaker, so, to clarify, unit vector v is such that |v| = 1?
15:22:30 <Pseudonym> hang on
15:22:41 <cmasseraf> yes
15:22:47 <applicative> d34df00d_: I'd think you have to choose one of them though
15:23:08 <cmasseraf> rostayob: You are look for operations over quaternions
15:23:32 <d34df00d_> applicative: so is unit vector just a vector with length of 1, or is it a vector of a coordinate system? Like v such that |v| = 1 and projections of v to all axises but one are 0?
15:23:51 <d34df00d_> Or, well, I don't get why I should choose one :)
15:23:54 <applicative> d34df00d_: I was just trying to follow Pseudonym
15:24:00 <d34df00d_> Ah.
15:24:21 <cmasseraf> just |v| = 1
15:24:26 <Jafet> As you can see, rostayob, the answers you get are as vague as your question
15:24:27 <d34df00d_> Ok, great.
15:24:42 <rostayob> Jafet: I was expecting maths
15:24:45 <d34df00d_> Then what's meant by a sphere as a unit vector?
15:24:48 * applicative thinks, clearly the trouble with haskell is plain: no inbuild syntactic support for quaternions.  Wonder if *fortress* has it.
15:25:11 <copumpkin> @remember applicative clearly the trouble with haskell is plain: no inbuild syntactic support for quaternions.  Wonder if *fortress* has it.
15:25:12 <lambdabot> Nice!
15:25:20 <Jafet> type Quaternion a = (a, (a, (), a), a)
15:25:44 <rostayob> d34df00d_: i think they mean that the surface of a sphere is composed by all the 3-dimensional unit vectors
15:26:03 <d34df00d_> Assuming the radius of that sphere is 1.
15:26:15 <d34df00d_> Yeah, that's pretty clear too.
15:26:20 <rostayob> it doesn't really matter i guess
15:26:24 <rostayob> but i'm no mathematician
15:26:42 <mehitabel> what do you actually want to do?
15:27:29 <rostayob> i explained it before, I have this elements that start with a certain velocity, and they avoid collision
15:28:10 <mehitabel> how do they avoid collision? you're simulating some physics?
15:28:29 <d34df00d_> Oh, great, hand-crafted partial differentiation is faster than using Numeric.FAD.jacobian.
15:28:49 <rostayob> they just "steer" away from other elements
15:29:24 <Jafet> So, they change their velocities in some arbitrary way to avoid collision.
15:29:37 <rostayob> they change the direction, not the velocity
15:29:46 <Jafet> Direction is a component of velocity
15:29:50 <rostayob> (note: all this is in my head)
15:30:25 <rostayob> well ok, on a simple plane they'd be just a vector, an angle and velocity
15:30:45 <Jafet> And you want to find an arbitrary way that happens to look natural according to your sense of aesthetics
15:31:00 <epsilon108> Quick question, it looks sort of like there are problems with Haskell on Ubuntu 11.04?
15:31:01 <d34df00d_> Hm, is there a way to rewrite this function to be a bit more efficient? http://paste.pocoo.org/show/511192/
15:31:06 <rostayob> Jafet: i just want to see what happens
15:31:18 <Cale> epsilon108: I have never relied on Ubuntu's packages for anything related to Haskell.
15:31:21 <d34df00d_> I'm profiling my code now, and it's third cost centre, with 11% time and 4% allocations.
15:31:23 <Jafet> Okay, you're getting close to maths, but you're still at aesthetics
15:31:36 <rostayob> i'm not close to maths at all eheh
15:31:47 <rostayob> i was watching glschool and i was wondering how hard it is to do
15:31:49 <epsilon108> hmm, ok
15:31:53 <Cale> epsilon108: The generic linux binary for GHC is easy enough to install, and then you can grab cabal-install from hackage, run the bootstrap.sh script from that, and you'll have everything you need
15:32:02 <applicative> epsilon108: well, there's certainly not much more scope for BangPatterns
15:32:13 <rostayob> epsilon108: or simply GHC binaries + haskell platform
15:33:10 <epsilon108> thanks
15:33:11 <rostayob> Jafet: the problem is, of course, that on a simple plane they'd just be driven to the edges
15:33:13 <epsilon108> =)
15:33:32 <acowley> d34df00d_: does the vars list get long?
15:33:59 <acowley> d34df00d_: if so, use something that has better than O(n) lookup
15:34:13 <Jafet> (a plane has no edges mumble mumble)
15:34:14 <_Mikey> :t byte
15:34:16 <lambdabot> Not in scope: `byte'
15:34:19 <_Mikey> :t Byte
15:34:20 <lambdabot> Not in scope: data constructor `Byte'
15:34:25 <acowley> :info Word8
15:34:29 <rostayob> Jafet: yes sorry, they'd be just drive away from each other, forever
15:34:38 <acowley> :/ Anyway, Word8 is our Byte
15:35:10 <Jafet> Okay then, pick a spherical coordinate system and use angular velocities about the origin
15:35:32 <Jafet> Whether you use Euler angles or quaternions or god forbidden matrices is up to you then
15:36:00 <Pseudonym> Sorry, phone call.
15:36:07 <c_wraith> shouldn't that be forsaken?
15:36:13 <d34df00d_> acowley: nope, it's about 10^1.
15:36:21 <c_wraith> I mean, if god forbids matrices, that takes the decision out of his hands :)
15:36:22 <d34df00d_> And about 10-20, to be more precise.
15:36:40 <Pseudonym> To complete my thought, if you add dimensions to make your coordinate system more convenient, the flip side is that you end up with a conservation law.
15:36:46 <Pseudonym> e.g. x^2 + y^2 + z^2 = 1
15:36:54 <Pseudonym> That's called a gauge symmetry.
15:37:02 <Jafet> To avoid collisions, you can invent a force that pushes the objects apart. Probably one with finite support.
15:37:02 <acowley> d34df00d_: then you're right at the threshold where you might start to feel O(n)
15:37:04 <Cale> Jafet: It's Euler angles which are god forbidden.
15:37:16 <Jafet> c_wraith: only if god is omnipotent!
15:37:17 <companion_cube> remind me, any monad can be applicative?
15:37:23 <hpc> companion_cube: yes
15:37:24 <rostayob> companion_cube: yes
15:37:26 <d34df00d_> acowley: hm, thanks for the hint.
15:37:29 <rostayob> Pseudonym: mhm...
15:37:39 <d34df00d_> I'd play around with other data structures for vars.
15:37:50 <Cale> Euler angles have no nice properties, at least matrices and quaternions are nicely compositional.
15:37:50 <rostayob> Jafet: I'm not worried about figuring out a way to avoid collisions, i'm worried about a convenient way to represent that spherical space
15:37:53 <rostayob> finite spherical space
15:37:56 <companion_cube> hmpf, so why is GenParser not applicative in Parsec2 ? :/
15:38:10 <rostayob> companion_cube: because they're lazy. <*> = ap
15:38:16 <acowley> d34df00d_: IntMap is a common choice in these situations
15:38:21 <applicative> d34df00d_:  I don't have much experience with specifically lookupy things, but I think you can do much better than [(a,b)] if you want speed.
15:38:24 <Pseudonym> Matrices with the constraint that they're unitary is another example of a gauge symmetry.
15:38:31 <ick> what built in function is there that returns whatever it's given? is there a little built in that is simply x a = a?
15:38:33 <rostayob> oh ok, i get it
15:38:43 <Cale> companion_cube: Parsec2 was possibly written a bit before Applicative. At the very least, Applicative was not yet popular.
15:38:57 <Pseudonym> Incidentally, there's a classic point repulsion algorith, due to Greg Turk.
15:39:02 <mehitabel> here are some ways to represent points on a sphere
15:39:07 <Pseudonym> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CCQQFjAA&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.113.8621%26rep%3Drep1%26type%3Dpdf&ei=nOTKTqPrIsuziQe1lsToDw&usg=AFQjCNGcxgAxFJlDZaMjKdF0VPQroSohSg&sig2=1sI_-rAwiFfLy9XeYbXgaQ
15:39:10 * applicative was always popular, no?
15:39:10 <Pseudonym> Err...
15:39:22 <mehitabel> 1. keep track of two different stereographic projections, one from the north pole and one from the south
15:39:33 <c_wraith> applicative: not in high school
15:39:33 <Jafet> @pl x a = a
15:39:34 <lambdabot> x = id
15:39:55 <Pseudonym> @google "Generating Textures on Arbitrary Surfaces Using Reaction-Diffusion"
15:39:55 <xil> how forgiving is Haskell to whitespace? I need to format my code to a line length limit and some of my lines are VERY long
15:39:56 * applicative concedes all
15:39:58 <mehitabel> 2. just let vectors in \mathbb{R}^3 be vectors
15:40:09 <companion_cube> Cale: uh, I'll add it myself
15:40:19 <d34df00d_> acowley: unfortunately, I guess it'd be hard to rewrite the code to address the variables by index rather than by name.
15:40:21 <mehitabel> 3. consider nonzero vectors in \mathbb{R}^3 up to scale
15:40:24 <rostayob> xil: use haskell-src, parse ad pretty the code :P
15:40:33 <applicative> xil, there will be subtleties, id you post it on hpaste we can reflect
15:40:34 <d34df00d_> acowley: so would a map with key = String and val = Int do?
15:40:48 <applicative> xil, if, not id
15:41:02 <d34df00d_> applicative: yeah, I've already ran into that some time ago.
15:41:12 <d34df00d_> Though that time the list of things was a bit longer.
15:41:18 <rostayob> Pseudonym: mhm... I'd like something simple to implement and to read
15:41:19 <Pseudonym> @botsnack
15:41:20 <lambdabot> :)
15:41:22 <d34df00d_> ~10^5, or smth like that.
15:41:28 <Pseudonym> Did I kill lambdabot?
15:41:30 * hackagebot hps 0.11 - Haskell Postscript  http://hackage.haskell.org/package/hps-0.11 (RohanDrape)
15:41:38 <rostayob> Pseudonym: I'll think about it anyway, thanks
15:41:44 <Pseudonym> rostayob: I'd look into quaternions.
15:41:53 <Pseudonym> If you understand vectors and complex numbers, they're pretty straightforward.
15:42:12 <Pseudonym> Then look up "spherical linear interpolation", which sounds complex, but isn't.
15:42:24 <Pseudonym> "Slerp" for short.
15:42:29 <rostayob> yeah sounding complex and being simple is common in maths
15:42:33 <acowley> d34df00d_: Sure, Map is a good choice. There are also tries tuned for String keys on hackage.
15:42:44 <Pseudonym> You're going to have to learn _some_ maths to do this.
15:42:51 <Pseudonym> Unavoidable, I'm afraid.
15:43:01 <Pseudonym> BTW...
15:43:05 <acowley> I'm actually working on my coordinate frame library right now
15:43:08 <rostayob> well I know *some* maths ehe
15:43:10 <Pseudonym> Another option is to use a torus rather than a sphere.
15:43:12 <acowley> does somebody need quaternions and slerps and things?
15:43:16 <rostayob> Pseudonym: yes, I had thought about that
15:43:19 <d34df00d_> acowley: ok, thanks, I'd try :)
15:43:25 <Pseudonym> The coordinate system is simpler.
15:43:38 <d34df00d_> Oh, I got rid of a bunch of 'realToFrac' everywhere, and everything seems to be much faster now.
15:43:40 <d34df00d_> Great!
15:43:52 <rostayob> Pseudonym: is it?
15:43:54 <acowley> d34df00d_: realToFrac will eat your soul
15:43:59 <Jafet> But a torus doesn't let you show off your Awesome 3D GFX Skillz
15:44:00 <Pseudonym> Yes.
15:44:14 <Pseudonym> Jafet: On the contrary, a torus is more awesome than a sphere.
15:44:46 <Pseudonym> It's at least one nano-james-webb-space-telescope more awesome.
15:44:51 <xil> rostayob: how do I use haskell-src? I installed it with cabal
15:44:54 <d34df00d_> But now this line consumes 47% of allocations, how could this be
15:44:58 <d34df00d_> binaryOps = [ (Plus, (+)), (Minus, (-)), (Mul, (*)), (Div, (/)), (Pow, (**)) ]
15:45:00 <d34df00d_> ?
15:45:07 <d34df00d_> acowley: yeah, I already got that .__.
15:45:17 <Pseudonym> JWST is the current accepted unit of awesomeness, IIRC.
15:45:29 <d34df00d_> acowley: that was from the times when I used Numeric.FAD for calculating jacobians, and it uses some uber-math with dual types and such.
15:45:57 <d34df00d_> And 17% of time for that line, yeah.
15:45:58 <acowley> Yes, I've used fad
15:46:07 <rostayob> Pseudonym: well in that case isn't the surface described by all the vectors with one dimension being always 1?
15:46:13 <applicative> xil, do you really want mechanized reformatting? i wish I could compose haskell so quickly....
15:46:14 <Pseudonym> BTW, lots of conservation laws in physics are due to coordinate system artifacts.
15:46:15 <acowley> although edwardk will demand you use ad instead
15:46:28 <Pseudonym> rostayob: Yes. That's a gauge symmetry.
15:46:31 * hackagebot hls 0.11 - Haskell Lindenmayer Systems  http://hackage.haskell.org/package/hls-0.11 (RohanDrape)
15:46:39 <d34df00d_> acowley: I'm now using totally hand-written bicycle :)
15:46:39 <rostayob> Pseudonym: ah! you see i'm not that bad at maths.
15:46:46 <Pseudonym> Exactly!
15:47:08 <d34df00d_> Turns out it's quite easy to differentiate expression trees.
15:47:08 <Pseudonym> Similarly, if you use quaternions, there's yet another gauge symmetry.
15:47:23 <xil> applicative: I don't need it at this point. I've already formatted most of the code. Problem is that I realized that I messed it up because of poorly considered whitespacing. So either I need to learn proper whitespacing, which I could use help with, or I can settle for mechanized
15:47:26 <d34df00d_> Pseudonym: where can I read more on all this?
15:47:29 <rostayob> xil: with haskell-src you can parse and pretty print your code
15:47:40 <d34df00d_> Sounds like a pretty beautiful branch of maths.
15:47:43 <rostayob> xil: similar to what the compiler uses when showing errors
15:47:43 <acowley> d34df00d_: try a hand-written unicycle for maximum NIHness
15:47:48 <xil> applicative: this isn't too important so I'd be okay with whatever mechanized gives me
15:47:53 <Pseudonym> d34df00d_: Do you have access to a university library?
15:47:58 <rostayob> d34df00d_: isn't this simple linear algebra?
15:48:05 <epsilon108> any recommendations on which text editor to use?
15:48:09 <rostayob> epsilon108: EMACS
15:48:19 <applicative> here is a beginning, just to show how to import it etc.  http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
15:48:20 <d34df00d_> Pseudonym: yep, but I guess there are not so much English publications there.
15:48:22 <d34df00d_> Mostly Russian ones.
15:48:26 <hpc> epsilon108: oh god
15:48:32 <rostayob> emacsemacsemacs
15:48:38 <epsilon108> haha
15:48:38 * d34df00d_ votes for vim.
15:48:39 <rostayob> :)
15:48:42 <Pseudonym> Right.
15:48:48 <Pseudonym> I'd start with something on Clifford algebra.
15:48:49 <Jafet> @quote sucks
15:48:50 <lambdabot> kmc says: If your Linux system breaks you can walk into any lounge and say "Linux sucks, it's broken" and a dozen people will jump up to assist you. If you say "Windows sucks, it's broken" they will
15:48:50 <lambdabot> shrug and agree.
15:48:58 <hpc> epsilon108: emacs has strange keyboard shortcuts; vim has stranger keyboard shortcuts which i like more
15:49:00 <Pseudonym> But I guess it depends what you're specifically interested in.
15:49:32 <epsilon108> ok
15:49:43 <Pseudonym> It took me about 10 years to understand what a gauge symmetry actually is, and it turned out to be extremely simple and could have taken 5 minutes' explanation.
15:49:56 <Pseudonym> And it's something that even a high school student can understand.
15:49:57 <epsilon108> is one easier than the other? or just different
15:50:07 <d34df00d_> So, any ideas why this simple thing occupies half of my memory allocations and 1/5 of CPU?
15:50:10 <rostayob> epsilon108: emacs is better in every respect. that is all.
15:50:14 <d34df00d_> binaryOps = [ (Plus, (+)), (Minus, (-)), (Mul, (*)), (Div, (/)), (Pow, (**)) ]
15:50:14 <Jafet> @quote ion suck
15:50:15 <lambdabot> ion says: let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
15:50:20 <epsilon108> haha
15:50:35 <epsilon108> XD
15:50:38 <d34df00d_> Plus, Minus and such are just different constructors of an ADT.
15:51:29 <Pseudonym> It constantly annoys me that simple concepts are made artifically complex by the way we teach stuff.
15:51:32 * hackagebot hsc3-graphs 0.11 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.11 (RohanDrape)
15:51:35 * applicative , looking for uses of Language .Haskell.Exts came across a long lost awesome ddarius module reinterpreting haskell whitespace in your preferred Idion
15:51:42 <applicative> Idiom even
15:51:44 <rostayob> Pseudonym: the problem with maths is that is too abstract, and this generates absurd naming and absurd "framing" of concepts in general
15:51:50 <Pseudonym> Like how category theory was mostly universally taught via topology.
15:51:51 <rostayob> i think that is why i don't like maths in the first place
15:51:59 <Pseudonym> Topology is _harder_ than category theory.
15:52:58 <Pseudonym> rostayob: There's maths, and there's maths.
15:53:11 <rostayob> Pseudonym: eh but i was so bored in high school
15:53:23 <Pseudonym> Yeah, but high school maths is... uh....
15:53:36 <Pseudonym> Well, let me put it this way. High school maths is to maths as playing scales is to music.
15:53:54 <rostayob> still, most people that enjoy maths enjoy maths in high school
15:53:59 <Pseudonym> It's important to do to be competent, but you wouldn't want to _only_ do that.
15:54:07 <Pseudonym> You reckon?
15:54:14 <cmasseraf> Pseudonym... I little less then playing scales maybe
15:54:21 <Pseudonym> Most people I know who enjoy maths found high school maths trivially boring.
15:54:30 <Pseudonym> For the most part.
15:54:31 <hpaste> applicative pasted “phormathaskell” at http://hpaste.org/54381
15:54:53 <applicative> xil: here's a simple minded use of Language.Haskell.Exts ^^^^^^^
15:55:09 <ian_mi> ha, I hated math until I was 21, and I'm now a math grad student.
15:55:21 <rostayob> Pseudonym: mah, I just did the bare minimum, but in general not only maths
15:55:23 <Pseudonym> The endless revision of stuff I already understood certainly got to me in high school.
15:55:26 <applicative> ian_mi: that is very pleasing to hear
15:55:32 <mwc> You know how there's a Chinese proverb advising "before setting out on an errand of revenge, dig two graves?" I feel there ought to be a version of that for programming language design
15:56:09 <xil> applicative: so I should get haskell-src-exts as well as haskell-src?
15:56:13 <cmasseraf> mwc: what do you mean?
15:56:32 * hackagebot hmeap 0.11 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.11 (RohanDrape)
15:56:37 <rostayob> xil: oh actually yeah, get haskell-src-exts.
15:56:48 <Pseudonym> Every new programming language makes two programming languages obsolete. One of these is the new one.
15:56:54 <mwc> Oh, just that one can easily get carried away thinking of how to make Haskell an even better language for EDSLs. Then you're into redesigning it.
15:57:14 <rostayob> ian_mi: that's pretty unconventional
15:57:15 <cmasseraf> oh
15:57:45 <applicative> xil, I guess to follow that module.  I think it reformats so you module is wall to wall semicolons and braces, I was proving a point to some C moron
15:58:04 <ian_mi> no one told me math could be interesting
15:58:14 <applicative> xil, thus the options, post-colonial and colon-cancer :)
15:58:28 <Pseudonym> If all you're exposed to is scales and arpeggios, you could easily find music boring, too.
15:59:02 <ian_mi> exactly
15:59:21 <xil> applicative: haha, okay, well thanks =]. I'm reading through it now
15:59:21 <rostayob> mah, i think that maths is deeply "inhuman", in the sense that is completely disconnected from experience
15:59:24 <blackdog> ian_mi: read "Lockhart's Lament"?
16:00:00 <ian_mi> blackdog: yes, I think it's spot on
16:00:02 <Cale> I think almost everyone in math has read and agreed with that by now. :)
16:00:12 <ian_mi> probably
16:00:16 <Pseudonym> Actually, that's the goal of some mathematicians.
16:00:19 <rostayob> i don't think that maths will ever be universally interesting, it takes a certain kind of mind imho
16:00:27 * ddarius has read it and forgot what it was
16:00:32 <Pseudonym> But I'd argue that economics is also pretty disconnected from humanity for what's supposed to be a social science
16:00:41 <ddarius> Pseudonym: So eventually we'll obsolete all programming languages.
16:00:48 <Pseudonym> That's the plan, ddarius.
16:00:48 <Cale> I'd even made the same music analogy prior to reading it.
16:01:07 <Pseudonym> rostayob: Very few disciplines are universally interesting.
16:01:11 <Pseudonym> Probably the only one is history.
16:01:20 <Pseudonym> Because whatever you're interested in, there's a history of it
16:01:23 <rostayob> Pseudonym: ok, then i maths is almost universally uninteresting
16:01:27 <Cale> rostayob: Not everyone is interested in making music either.
16:01:33 * hackagebot hmeap-utils 0.11 - Haskell Meapsoft Parser Utilities  http://hackage.haskell.org/package/hmeap-utils-0.11 (RohanDrape)
16:01:44 <rostayob> music is deeply rooted in how humans experience the world
16:01:51 <ddarius> As is mathematics.
16:01:53 <Cale> Well, so is mathematics
16:01:55 <rostayob> not really
16:02:00 <rostayob> i mean we can argue on that
16:02:23 <Cale> Mathematics is rooted in little else.
16:02:47 <Cale> It is *deeply* human.
16:03:00 <rostayob> mathematics is not rooted, mathematics is just formality, while for example notes are universal
16:03:09 <hpc> notes are a formality
16:03:28 <rostayob> no, every man can tell you if something is in tone or not
16:03:35 <rostayob> i don't know the word in english
16:03:38 <rostayob> but anyway you get the idea
16:03:42 <hpc> because notes happen to correspond to a physical phenomenon
16:03:45 <ddarius> rostayob: Actually, not everyone can.
16:03:56 <elliott> rostayob: tone deaf people, just plain deaf people
16:03:58 <rostayob> ddarius: well, not everyone can see colors
16:04:01 <Cale> rostayob: Not everyone can tell you if something is C# or not.
16:04:19 <ddarius> rostayob: Are such people subhuman?
16:04:27 <Cale> (in fact, I'd say most people probably can't)
16:04:27 <arbn> Also, not everyone can have well-defined philosophical conversations.
16:04:29 <rostayob> that's not the point. my point is the concept of note originates from how our brain is
16:04:36 <elliott> Wow, gcc is getting STM.
16:04:39 <ddarius> As does mathematics.
16:04:40 <rostayob> elliott: yes
16:04:50 <Cale> rostayob: Maybe up to octaves
16:04:52 <rostayob> ddarius: well, i disagree on that
16:04:54 <ulidtko> rostayob: nope, I think you are wrong
16:05:05 <ddarius> Also, the way are ear is is a significant factor.
16:05:27 <rostayob> why can there be professional musicians that have no idea about formalities in music, but there can't be mathematicians unaware of the formalities of maths?
16:05:39 <d34df00d_> ulidtko: hey ulidtko!
16:05:41 <ddarius> rostayob: What makes you think that?
16:05:47 <ulidtko> rostayob: because there are alternative note staffs, not 12 tones per octave
16:05:51 <ddarius> There are -plenty- of intuitive mathematicians.
16:05:51 <hpc> rostayob: they are arguably unprofessional musicians
16:06:01 <hpc> rostayob: an unprofessional mathematician gets ignored
16:06:05 <rostayob> hpc: tell that to stevie ray vaughan :P
16:06:09 <rostayob> hpc: no, world class musicians
16:06:29 <ddarius> rostayob: Look up Ramanujan.
16:06:29 <rostayob> ddarius: ? evidence?
16:06:42 <Pseudonym> rostayob: A violin player will tell you that a piano is out of tune.
16:06:43 <Cale> rostayob: But not the western scale.
16:06:43 <Cale> dividing the octave into 12 equal parts is not a universal or a human thing, but a cultural one
16:06:43 <Pseudonym> The well-tempered scale is out of tune with respect to harmonic tones.
16:06:56 <Pseudonym> The only human scale is the pentatonic scale. Everyone in the world seems to have that.
16:07:02 <rostayob> ddarius: ramanujan studied on a textbook, and had an incredible talent
16:07:14 <applicative> lookup all the people Coxeter consulted
16:07:28 <ddarius> rostayob: And most of his results were unproven and he went -far- beyond his textbooks.
16:07:36 <rostayob> but the word "maths" refers to the collection of formalities that we built up
16:07:52 <rostayob> or at least that's what we're talking about now
16:08:26 <rostayob> ddarius: yeah yeah he had an incredible talent, but i doubt that as a child he would have "started" alone, while anyone will sing, or play with some rythm, etc.
16:08:54 <ddarius> rostayob: Look up subitization.
16:09:06 <ddarius> rostayob: Is walking human?
16:09:08 <elliott> rostayob: have you raised a child without once letting them hear music or singing?
16:09:21 <applicative> rostayob, I forgot that one of the unprofessional mathematicians coxeter consulted was a daughter of Boole
16:09:38 <rostayob> elliott: there have been extensive studies on the pervasiveness of music in every human civilization
16:09:40 <applicative> http://www.agnesscott.edu/lriddle/women/stott.htm
16:10:00 <elliott> rostayob: fair enough
16:10:03 <rostayob> ddarius: yeah walking is human. maybe the concept of number is human. but what maths is now is not that
16:10:17 <Cale> Couldn't match type `b0' with `()'  `b0' is untouchable inside the constraints (n ~ Hold a1) bound at a pattern with constructor HoldT :: forall a. NodeTypeRep (Hold a), in a case alternative
16:10:40 <Jafet> U CAN'T TOUCH THIS
16:10:46 <elliott> Cale: ooh, "untouchable", haven't seen that one before
16:10:53 <elliott> GHC continues to advance the field of confusing error messages
16:11:01 <rostayob> Cale: I got "my brain exploded" from GHC today.
16:11:04 <Cale> Yeah, b0 is untouchable inside some constraints which don't mention b0
16:11:13 <Cale> ;___;
16:11:14 <rostayob> trying to pattern match an existential type
16:11:25 <elliott> rostayob: that's pretty common :P
16:11:27 <Cale> Earlier I had a "couldn't match type" with two identical types.
16:11:33 <rostayob> elliott: i was still amused :P
16:11:35 <Cale> syntactically identical
16:11:44 <applicative> is untouchable a new concept?  awesome. untouchable types. even Agda doesn't have them
16:11:48 <rostayob> also, I guess it makes sense
16:11:57 <elliott> Cale: Maybe there's an associated type involved? Aren't fundeps implemented as type families nowadays? In which case you might include them in an error like that, since they'll be part of the instance head.
16:12:00 <elliott> Just a wild guess :P
16:12:19 <Cale> elliott: There was an associated type involved, in fact.
16:13:08 <d34df00d_> Oh.
16:13:19 <d34df00d_> I start feeling stupid and such seeing such discussions.
16:13:19 <Pseudonym> Haskell should have a --classist option which lets you pick your types from higher castesz/
16:13:21 <Pseudonym> castes
16:13:44 <d34df00d_> Associated types, someone really using existential types, etc.
16:13:46 <SoleSoul> does anybody here use nixos?
16:14:18 <rostayob> ddarius: logic is more human imho.
16:14:22 <ddarius> d34df00d_: Existentials have been supported for at least 15 years.
16:14:25 <Cale> apparently the solution to that type error above is matching the empty pattern at the end of the case containing that.
16:14:32 <Pseudonym> All my types are Brahmins. I never use untouchables.
16:14:41 <ddarius> rostayob: I don't tend to make a big distinction between logic and math.
16:14:49 <elliott> d34df00d_: Nah, it's a good thing if you don't push the limits of the type system much :P
16:15:01 <rostayob> ddarius: fair enough. anyway, i hope you got my point :P
16:15:05 <d34df00d_> ddarius: yeah, I know, and I played around with them a bit.
16:15:07 <elliott> d34df00d_: Things must be so much easier for you.
16:15:46 <ddarius> rostayob: I don't know what your point was.  I got your opinion, I believe.
16:15:48 <d34df00d_> But I still feel uncomfortable, understanding that I can't understand those error messages and, moreover, don't even get them!
16:16:00 <dschoepe> Is there a library to generate pretty-looking tables from values like [[String]]? What I have in mind is something like this: http://code.google.com/p/prettytable/
16:16:08 <rostayob> ddarius: yeah, ok
16:16:10 <d34df00d_> elliott: surely, but I don't know that well, so that's rather bad from the knowledge/experience point of view :)
16:16:12 <rostayob> dschoepe: groom
16:16:25 <rostayob> (which is like 4 lines of code)
16:16:42 <elliott> Groom doesn't generate tables...
16:16:46 <elliott> It's just a line-wrapper over show.
16:16:56 <rostayob> well, it will still indent that nicely
16:17:06 <tomprince> rostayob: I find that the beauty of math is obscured most of the time, when it is taught, because the people teaching it don't understand it  well.
16:17:25 * dschoepe tries if groom is sufficient for him
16:17:28 <ian_mi> math is reasoning and problem solving, two of the most human activities
16:17:51 <hpc> dschoepe: unwords . unlines?
16:17:54 <rostayob> tomprince: i wasn't debating the beauty of maths. i was just saying it's too distant to be enoyed by most people
16:18:04 <hpc> it's not /that/ pretty, though
16:18:26 <ian_mi> math gives me the same feeling I got solving a puzzle in zelda as a kid.
16:18:29 <rostayob> intercalate "\" . unlines
16:18:37 <rostayob> intercalate "\t" . unlines
16:18:43 <dschoepe> hpc: I care especially about annoying things like same column width, etc.
16:18:55 <Cale> rostayob: I disagree, but maybe we mean two different things when we each say "math"
16:19:02 <elliott> dcolish: It's not sufficient.
16:19:04 <tomprince> I think that is at least in part because they were introduced to it in subobtimal ways.
16:19:15 <rostayob> dschoepe: pipe the result into 'column'
16:19:22 <rostayob> (man column for info)
16:19:28 <rostayob> if it's for debugging ehehe
16:19:43 <acowley> Tablet versions of text books can bring Zelda's sound effects to math, too.
16:20:06 <Cale> tomprince: Most people are only ever introduced to a strawman mathematics which has been almost completely stripped of logical reasoning and real problem solving of any kind.
16:20:33 <ddarius> Cale: They are introduced to calculation.
16:20:39 <rostayob> dschoepe: also, unlines . map (intercalate "\t") should work for short words. you can add more tabs at will eheh
16:20:44 <acowley> Coq needs a visual mode with nice colors so we can start kids early. Also a name change to avoid lawsuits.
16:20:55 <tomprince> Cale: exactly
16:20:55 <dschoepe> rostayob: Nah, it's for actual program output :) -- I guess I could cook something up with pretty or a similar library
16:21:33 * hackagebot hcg-minus 0.11 - haskell cg (minus)  http://hackage.haskell.org/package/hcg-minus-0.11 (RohanDrape)
16:21:35 * hackagebot html-minimalist 0.11 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.11 (RohanDrape)
16:21:37 * hackagebot hmt 0.11 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.11 (RohanDrape)
16:21:39 * hackagebot hsc3-auditor 0.11 - Haskell SuperCollider Auditor  http://hackage.haskell.org/package/hsc3-auditor-0.11 (RohanDrape)
16:22:11 <Jafet> acowley: Poule
16:22:27 <epsilon108> so if I learn Haskell, is it possible that it will help me with my logic studies?
16:22:30 <chadz> anyone use vty-ui have any idea how to force a complete screen refresh?
16:22:52 <Jafet> It is possible that learning Haskell will lead you to true love
16:22:54 <hpc> epsilon108: quite likely
16:22:59 <acowley> Jafet: that is an excellent suggestion
16:23:07 <hpc> @faq can haskell lead you to true love?
16:23:07 <lambdabot> The answer is: Yes! Haskell can do that.
16:23:08 <epsilon108> haha i hope so!
16:23:10 <acowley> Oh wait
16:23:22 <acowley> "Poule means a prostitute in French slang."
16:23:25 <epsilon108> oh my goodness
16:23:45 <acowley> can't win
16:23:46 <epsilon108> now I'm excited
16:24:03 <acowley> epsilon108: The #haskell faq has that effect on people
16:24:11 <dschoepe> epsilon108: There's also a chance that learning Haskell will motivate you to learn Agda, which will _definitely_ help you get better acquainted with logic :)
16:24:16 <epsilon108> the love effect
16:24:23 <epsilon108> or the excite effect
16:24:33 <epsilon108> ooo
16:24:37 <epsilon108> Agda?
16:24:51 <epsilon108> ...the plot thickens
16:24:52 <acowley> and learning Agda will motivate you to learn Coq to get access to tactics, and that will help get you acquainted with lisp
16:25:00 <rostayob> aha
16:25:37 <tomprince> acowley: How is coq related to lisp?
16:25:53 <chadz> nobody uses it
16:25:56 <chadz> zing
16:26:03 <epsilon108> hehe
16:26:09 <acowley> tomprince: I was referring to the lack of types in tactics and general AST munging you tend to do
16:26:16 <epsilon108> do many people use haskell?
16:26:26 <monochrom> yes
16:26:32 <rostayob> epsilon108: everyone uses haskell
16:26:35 <acowley> epsilon108: >= /names #haskell
16:26:36 <tomprince> Ah, yes. I want to fix that.
16:26:37 <dschoepe> learning Coq as well might also create serious inner conflicts, since Agda lacks tactics while Coq lacks sufficiently convenient syntax to write actual programs in (imo).
16:26:51 <epsilon108> i mean generally =p
16:26:55 <rostayob> agda is not fit to write actual programs in.
16:27:00 <Eduard_Munteanu> Presumably... at least it's got a really big channel here on IRC. Bigger than even well-known languages.
16:27:06 <Eduard_Munteanu> s/IRC/Freenode/
16:27:13 <acowley> Agda at least looks like it's fit to write actual programs in
16:27:14 <Pseudonym> Has anyone used both Coq and Isabelle?
16:27:18 <Pseudonym> Anyone here, I mean.
16:27:25 <Pseudonym> Curious about the tradeoffs between them.
16:27:26 <monochrom> there is no contradiction between "minority" and "many"
16:27:36 <dschoepe> rostayob: Yeah, but that's not a matter of syntax, I think.
16:27:48 <Jafet> Haskell, the most overhyped language on freenode
16:28:19 <rostayob> dschoepe: no, it's just that normalizing languages like agda are not usable
16:28:28 <Eduard_Munteanu> Pseudonym: I wonder that too... I know Isabelle isn't type-theoretic in nature.
16:29:01 <dschoepe> rostayob: Could you expand on that? I've never considered that to be a problem.
16:29:04 <Cale> epsilon108: It's still tiny compared to, say, Java, but growing pretty rapidly.
16:29:07 <tomprince> acowley: Although, coq's syntax is almost entirely programable.
16:29:08 <Pseudonym> Eduard_Munteanu: That would make it less intuitive for a Haskeller, but it's not necessarily a mark against it.
16:29:12 <Eduard_Munteanu> I guess it might be easier to investigate theories that don't fit a particular type system like Coq's.
16:29:16 <scshunt> '/win 41
16:29:21 <Pseudonym> Right.
16:29:32 <chadz> i wonder if theres a vty/vty-ui channel...
16:29:39 <rostayob> dschoepe: i'm just saying that a language without general recursion is not that practical
16:29:42 <Cale> epsilon108: and there are more and more companies using Haskell all the time now
16:30:12 <acowley> tomprince: the lack of fancy pattern matching really burns, though, and I've never managed to get the relevant extension to work for me
16:30:13 <Eduard_Munteanu> Or maybe safer if you can start with a blank slate.
16:30:21 <Jafet> rostayob: how often do you need general recursion
16:30:30 <tomprince> There are in fact two (related) term syntaxes. (Officially called Gallina and Russell)
16:30:34 <rostayob> Jafet: pretty often
16:31:04 <acowley> I didn't know about Russell!
16:31:18 <thoughtpolice> rostayob: you can turn the termination checker off if you really want. also, i think it's well known that while there are some programs you can't write that we care about, there are many programs we do care about, and we can write them.
16:31:27 <Eduard_Munteanu> I think Coq looks really odd if intend to do programming, at least considering all those tactics you see in a Coq script.
16:31:33 <Eduard_Munteanu> *if you
16:31:52 <tomprince> Russell is the from 'Program'. I think it may have the same syntax, but different interpration.
16:32:01 <dschoepe> There are also usually useful programs that are not typeable; that does not mean type systems are a bad idea.
16:32:04 <acowley> On the contrary, I think tactics give interactive proving the potential to be readable
16:32:10 <thoughtpolice> also, this is really hearsay, so someone else could qualify, but i thought that programs written in agda for example are allowed to not terminate, only as long as they do so 'productively'.
16:32:14 <rostayob> thoughtpolice: that's true, but i don' think that language like agda are that relevant to practical programming. both the absence of recursion and dependend types are double edged swords
16:32:15 <dschoepe> I think the same goes for not allowing general recursion.
16:32:23 <elliott> rostayob: agda has recursion.
16:32:32 <elliott> Does turning off the termination checker turn off the type termination checker too in Agda?
16:32:39 <tomprince> You mostly only use tactics for Prop, so if you aren't proving things about your program, you probably don't need many tactics.
16:32:42 <acowley> tomprince: Yes, Program is what I failed to get working when I tried it
16:33:06 <rostayob> elliott: really? general recursion? isn't it a theorem prover?
16:33:13 <rostayob> with general recursion you can inhabit whatever type
16:33:19 <elliott> rostayob: You said "recursion", not "general recursion".
16:33:26 <rostayob> ok, i said general recursion before
16:33:29 <Eduard_Munteanu> rostayob: no, not general recursion, although it's easy to disable termination checking.
16:33:34 <monochrom> the most readable proof displays tactics alongside with results of using the tactics
16:33:44 <tomprince> And, hugo has commited a bunch of code over the last couple of months to improve pattern matching. (I am not sure exactly what it does, but ...)
16:33:46 <hpc> you don't need general recursion for a whole lot of algorithms, incidentally
16:34:04 <hpc> i understand someone is writing an IRC bot in agda
16:34:04 <Jafet> rostayob: why do you need general recursion?
16:34:12 <thoughtpolice> elliott: i suppose so. i'm still learning agda and frankly i'm probably the worst agda programmer ever, because i actually tend to like to compile and run programs a lot, as opposed to write proofs. i'll probably move to proofing more later
16:34:14 <Eduard_Munteanu> The interesting part is how you write programs *without* general recursion.
16:34:16 <Jafet> You still haven't explained the relevance of general recursion to anything
16:34:43 <elliott> thoughtpolice: Suppose what?
16:34:51 <rostayob> Jafet: because, for example, having recursive data types is really convenient?
16:35:02 <thoughtpolice> elliott: "Does turning off the termination checker turn off the type termination checker too in Agda?"
16:35:07 <elliott> Anyway, a language without side-effects is hopeless; they're really convenient, and I don't see how you can write programs without them.
16:35:16 <Jafet> And how is general recursion relevant to that, rostayob?
16:35:17 <hpc> rostayob: and general recursion isn't necessary for recursive data types
16:35:17 <elliott> It's like general recursion!
16:35:17 <dschoepe> Recursive data types have nothing to do with general recursion?
16:35:34 <c_wraith> recursive data types have to do with structural recursion :)
16:35:44 <Eduard_Munteanu> elliott: you can have side-effects in Agda.
16:35:46 <rostayob> if you can write a data type like data Foo a = Foo a -> a
16:35:56 <rostayob> you can do pretty much what you want
16:36:02 <tomprince> haskell doesn't have side-effects.
16:36:05 <Jafet> Well, they merely can't be corecursive
16:36:09 <Jafet> tomprince: sure it does
16:36:13 <elliott> Eduard_Munteanu: tomprince: If you look carefully, you might see a parody of rostayob's argument inside mine :-)
16:36:21 <Eduard_Munteanu> Oh :P
16:36:23 <rostayob> elliott: yeah I had seen that :)
16:36:24 <c_wraith> what's agda's story for corecursion, anyway?
16:36:32 <elliott> c_wraith: it does it with a lot of unicode
16:36:39 <rostayob> Jafet: oh, right. does agda have that?
16:36:39 <elliott> at least that's what i got from reading its corecursion stdlib module
16:36:41 <Eduard_Munteanu> Musical notation :P
16:36:48 <elliott> yeah :P
16:37:05 <elliott> "with a lot of unicode" is like agda's @faq
16:37:05 <Jafet> c_wraith: false, I suppose
16:37:12 <elliott> "yes, agda can do that with a lot of unicode!"
16:37:13 <monochrom> hahaha
16:37:18 <acowley> hahah
16:37:53 <monochrom> @remember elliott "with a lot of unicode" is like agda's @faq. "yes, agda can do that with a lot of unicode!"
16:37:54 <acowley> please somebody save that c_wraith/elliott exchange for a quote file
16:37:54 <lambdabot> It is forever etched in my memory.
16:37:56 <acowley> !
16:38:16 <c_wraith> What, I was barely involved?
16:38:23 <elliott> yesss, I'm going to be in like three HWNs in a row! or something
16:40:04 <rostayob> Jafet: wait, doesn't general recursion simply mean to be able to write recursive functions?
16:40:49 <dschoepe> rostayob: It means being able to write arbitrary recursive functions, not just structurally recursive ones.
16:41:22 <Eduard_Munteanu> IMO, for real programs, apart from having termination so you can prove certain properties about them, the interesting thing would be setting actual bounds on space / time behavior (say asymptotics). Something that refines "termination", in a way, I guess. But I don't see that anywhere in common theorem provers.
16:41:27 <Eduard_Munteanu> At least, not easily.
16:42:03 <ddarius> Eduard_Munteanu: Just provide a cost semantics to your operations.
16:42:05 <rostayob> dschoepe: ok, but so does agda support structural recursion?
16:42:10 <sacheie> does anyone know a better way to write " zipWith (\a b -> [a,b]) " ?
16:42:20 <ddarius> rostayob: It supports more than structure recursion.
16:42:21 <dschoepe> rostayob: Yes, it would indeed be quite useless if it didn't.
16:42:28 <ddarius> s/structure/structural/
16:42:34 <Eduard_Munteanu> ddarius: I remember copumpkin saying you pretty much have to write an embedded language to do that. Quite inconvenient in a way.
16:42:35 <c_wraith> structural recursion over data (not co-data) is well-founded.
16:43:13 <Jafet> @where agda
16:43:14 <lambdabot> Agda2, proof assistant / dependently typed FPL, at <http://wiki.portal.chalmers.se/agda/> -- Agda1, earlier incarnation, at (broken) <http://www.cse.chalmers.se/~catarina/agda/>,<http://web.archive.
16:43:14 <lambdabot> org/web/*/http://www.cs.chalmers.se/~catarina/agda/>. Also see `Alfa',`Cayenne'
16:43:54 <Eduard_Munteanu> Because if you want cost-related semantics, you'll have to redefine all your semantics.
16:43:59 <Jafet> Maybe you'd be better at math if you didn't assume stuff...
16:44:31 <tomprince> I have started working on a lambdabot for coq (although not written in coq, at least not yet. :)
16:44:48 * ddarius assumed 1=0 and has since proved all the major outstanding conjectures.
16:44:53 <Jafet> @pl ap id id (ap id id)
16:44:54 <dschoepe> epsilon108: So, in conclusion, learning Haskell might cause you derail questions like yours into a discussion about general recursion :)
16:44:54 * Eduard_Munteanu sometimes wishes for an agdabot
16:44:55 <rostayob> Jafet: aha. maybe. i don't know much about agda as a language, but i know it has dependent types and that is normalizing
16:44:57 <lambdabot> ap id id (ap id id)
16:44:57 <lambdabot> optimization suspended, use @pl-resume to continue.
16:44:58 <ddarius> For good measure, I also refuted all of them.
16:45:07 <rostayob> Jafet: but are you seriously suggesting agda for practical use?
16:45:12 <epsilon108> Haha
16:45:28 <ddarius> rostayob: Did you mean "that _it_ is normalizing"?
16:45:45 <rostayob> ddarius: ...yes?
16:46:23 <dschoepe> rostayob: I'd argue that it is fit for practical uses aside from performance issues and lack of libraries.
16:46:36 <Eduard_Munteanu> rostayob: the practicality of Agda doesn't hinge on lack of generalized recursion as much as other stuff, I think
16:46:51 <Jafet> rostayob: of course not. It's a silly academic toy.
16:47:11 <Eduard_Munteanu> Haskell would be really impractical if it didn't have any bindings, for example.
16:47:14 <tomprince> Eduard_Munteanu: Ideally you would only need to define the cost semantics once.
16:47:42 <epsilon108> my skeptical friend is asking... how many lines of haskell does it take to implement a web server?
16:47:49 <dschoepe> for the record: there even are serious attempts to do something practical with agda: https://github.com/larrytheliquid/Lemmachine
16:48:03 <rostayob> Jafet: note that with "practical use" i mean in software engineering
16:48:08 <Jafet> epsilon: hit him with a large stick.
16:48:17 <rostayob> of course it's really useful at what it was created for
16:48:21 <rostayob> (i hope)
16:48:43 <ddarius> epsilon108: There was a paper about one many, many years ago that made a high-performance web server with a few bells and whistles in 1500 lines of code (and probably not using any web libraries.)
16:48:47 <monochrom> I last heard 200 lines. but it was an old one. there are more recent ones I haven't counted. go find "warp" on hackage and count it, it's a recent one.
16:48:48 <copumpkin> Eduard_Munteanu: ?
16:48:51 <elliott> epsilon108: http://hackage.haskell.org/packages/archive/warp/0.4.5/doc/html/src/Network-Wai-Handler-Warp.html
16:49:09 <ddarius> You could certainly make a toy one in anywhere from 1 to 80 lines of code depending on which libraries you are willing to import.
16:49:12 <rostayob> warp is 500 loc but it uses a lot of other libraries
16:49:13 <elliott> epsilon108: Built upon that is http://hackage.haskell.org/package/mighttpd, which exceeds nginx in performance.
16:49:21 <elliott> (Or at least, does in at least one benchmark :-))
16:49:50 <elliott> Oh, wait.
16:49:52 <monochrom> and you should get your skeptic friend here directly and screw the middleman game
16:49:55 <elliott> epsilon108: Sorry, I meant http://hackage.haskell.org/package/mighttpd2.
16:50:08 <ddarius> monochrom: But then he wouldn't get his cut.
16:50:14 <monochrom> the middleman is the weakest link
16:50:27 <Jafet> monochrom: they turn to stone when you bring them out here
16:50:40 <dschoepe> ddarius: Doesn't that mean we should start charging him, too?
16:50:41 <epsilon108> yay!!! slightly swayed
16:50:52 <epsilon108> hehe
16:51:00 <epsilon108> dinner time
16:51:16 <acowley> Is Skolem the Haskell equivalent of golem?
16:51:32 * ddarius doesn't know what acowley is talking about.
16:51:33 <monochrom> no. the logic equivalent of golem.
16:52:02 <acowley> I was thinking of what we'd call someone we turned to stone and taught Haskell to
16:52:08 <ddarius> Wouldn't he be the Norwegian equivalent?
16:52:19 <acowley> yes, that's more geographically sensible
16:52:35 <ddarius> Also, Thoralf is a cool name.
16:52:37 <acowley> however, I am terrible with directions so I must invent my own mythology
16:53:22 <Jafet> I was referring to beasts that turned to stone when exposed to daylight
16:53:33 <acowley> Why is there no programming language called Thoralf?
16:53:46 <ddarius> @google Thoralf programming language
16:53:48 <lambdabot> http://en.wikipedia.org/wiki/Thoralf_Skolem
16:53:48 <lambdabot> Title: Thoralf Skolem - Wikipedia, the free encyclopedia
16:53:52 <ddarius> Jafet: Mudmen?
16:53:53 <monochrom> isotropic mythology looks the same in all directions
16:54:12 <Eduard_Munteanu> tomprince: I'm not sure that's the issue. I think the problem is you have to prove a lot more about your embedded programs than you'd otherwise do. Not just for costs, but for termination, well-formedness etc., even for simple stuff.
16:54:20 <acowley> monochrom: thank you for giving a name to the oral history I will impart to my children
16:54:26 <Eduard_Munteanu> Unless you had some sort of tactic that took care of most of those issues for you.
16:54:41 <Eduard_Munteanu> copumpkin: I remember you saying that. (I think I asked about it.)
16:55:03 <copumpkin> about productive corecursion?
16:55:09 <copumpkin> oh, about cost
16:55:15 <Eduard_Munteanu> copumpkin: yeah, cost.
16:55:21 <ddarius> copumpkin: Is that what kids are calling it these days?
16:55:25 <copumpkin> lol
16:55:35 <copumpkin> that's what I think would be needed to reason about programs, anyway
16:55:41 <copumpkin> otherwise, you can't really look at the structure
16:56:12 <acowley> "productive corecursion" is an excellent euphemism for ... a lot of things
16:56:35 * hackagebot hps-cairo 0.11 - Cairo rendering for the haskell postscript library  http://hackage.haskell.org/package/hps-cairo-0.11 (RohanDrape)
16:56:41 * copumpkin is innocent and knows of only one possible meaning
16:56:44 <copumpkin> O:-)
16:58:02 <Eduard_Munteanu> What's non-productive corecursion anyway? :P
16:58:05 <acowley> There are plenty of clean interpretations. Like using extra verbiage as a stalling tactic, or in a quest for partial credit on an exam!
16:58:12 <acowley> Eduard_Munteanu: _|_
16:58:23 <cgroza> Does anynone know of a graphical way to represent graphs in haskell? I am looking for something similar to a GUI widget.
16:58:38 <acowley> cgroza: fgl's graphviz output piped to graphviz
16:58:40 <ddarius> @hackage blobs
16:58:40 <lambdabot> http://hackage.haskell.org/package/blobs
16:59:03 <cgroza> acowley: thanks.
16:59:43 <Jafet> (_|_)
17:00:10 * Eduard_Munteanu throws a parse error on acowley's answer :)
17:00:24 <cgroza> acowley: so I could put this in a text control in wxHaskell?
17:00:35 <ddarius> ...
17:00:47 <acowley> cgroza: graphviz output would be more appropriately used as an image
17:01:00 <cgroza> acowley: it outputs a string...
17:01:15 <Eduard_Munteanu> Hence piping to graphviz
17:01:22 <acowley> cgroza: if you want a text-rendering of an arbitrary graph, you could consider Data.Tree.drawTree if you have a tree
17:01:34 <cgroza> acowley: ok.
17:01:37 * hackagebot hts 0.11 - Haskell Music Typesetting  http://hackage.haskell.org/package/hts-0.11 (RohanDrape)
17:01:39 * hackagebot hly 0.11 - Haskell LilyPond  http://hackage.haskell.org/package/hly-0.11 (RohanDrape)
17:02:19 <cgroza> makes sense nonw.
17:02:25 <ddarius> If you want a text-rendering of an arbitrary graph, you could consider const "*" if you have a single vertex, no edges graph.
17:03:22 <Faucelme> Hi everyone, I'm a Haskell newbie and I have the following doubt: do lazy bytestrings have something to do with lazy IO, or are they unrelated concepts?
17:03:42 <Eduard_Munteanu> Faucelme: they do
17:03:47 <shachaf> Faucelme: They aren't very related.
17:03:53 <shachaf> You can do lazy I/O with them, however.
17:04:03 <shachaf> (Which you can't do with strict bytestrings.)
17:04:25 <acowley> "unrelated" is a strong word, but they're not essentially connected
17:04:35 <irene-knapp> ddarius: "an arbitrary graph" haha
17:06:07 <monochrom> an efficient data structure for storing arbitrary sets such that no elements are in such sets.
17:06:54 <Eduard_Munteanu> monochrom: that pretty much describes a lot of data structures
17:07:14 <irene-knapp> monochrom:hahahah nice
17:08:52 <elliott> monochrom: An efficient data structure for storing the empty set?
17:08:54 <elliott> Sounds useful.
17:09:10 <irene-knapp> I can do one better
17:09:15 <Eduard_Munteanu> I was thinking of the set '3'. :)
17:09:23 <monochrom> don't forget Bill Gates's digital future book which says "cryptography relies on hard problems such as factoring primes"
17:09:36 <irene-knapp> an efficient data structure for storing no sets at all
17:09:42 <irene-knapp> it requires EmptyDataDecls though
17:10:24 <mauke> newtype Void = V Void
17:10:40 <acowley> productive corecursion!
17:10:44 <Faucelme> So, lazy bytestrings are a prerequisite for lazy I/O, but aren't limited to that single use?
17:10:53 * monochrom thinks Bill Gates wrote "prime factorization" or "prime factoring" which was fine, then English major editors blew it
17:10:54 <irene-knapp> mauke: hah! :D
17:11:04 <Eduard_Munteanu> That requires --no-positiv.... oh, Haskell :P
17:11:10 <Cale> Faucelme: well, lazy String or Text also serve that purpose :)
17:11:11 <acowley> Faucelme: no, they are not essential to each other. You can use lazy IO without lazy bytestrings.
17:11:45 <Faucelme> ok, thanks for the clarification.
17:11:58 <elliott> monochrom: quantum computers can factor primes in O(1)!
17:12:30 <cgroza> elliott: any resources to see how that works?
17:12:42 <Cale> Faucelme: but yeah, lazy bytestrings are also a fine representation of strings of bytes which is lazy, and might not be directly involved in any I/O
17:12:44 <elliott> cgroza: f(p) = {p,1}
17:12:55 <Eduard_Munteanu> acowley: I think lazy BS needs lazy IO
17:12:55 <irene-knapp> cgroza: it's the same algorithm you use on a traditional computer, actually. :)
17:12:58 <elliott> cgroza: proving this algorithm O(1) left as an exercise to the reader
17:13:25 <ddarius> Eduard_Munteanu: No it doesn't.
17:13:26 <acowley> Eduard_Munteanu: I can create a lazy BS purely
17:13:34 <cgroza> irene-knapp: so the secret is just in the architecture?
17:13:35 <Jafet> elliott: careful, it's only expected O(1)
17:13:39 <acowley> Eduard_Munteanu: It's just a chunky list
17:13:52 <monochrom> lazy BS needs no IO at all, so nevermind lazy IO
17:13:57 <elliott> Jafet: What's the worst case?
17:13:59 <irene-knapp> cgroza: no, haha, the algorithm is even O(1) on a traditional computer
17:14:03 <Eduard_Munteanu> Erm, right, I was hung up on the IO aspects.
17:14:03 <ddarius> What monochrom said.
17:14:09 <irene-knapp> cgroza: reread what cgroza said carefully :)
17:14:26 <Cale> Well, depending on how you implement that, it may be O(log p), copying the prime number to the output.
17:14:27 <irene-knapp> s/cgroza/elliott/
17:14:40 <cgroza> irene-knapp: hehe. sorry, it's late here.
17:14:45 <irene-knapp> hehe np :)
17:14:47 <elliott> irene-knapp: Rather, what monochrom said :-) ...or what Bill Gates said...
17:14:49 <Jafet> elliott: D-Wave insolvency
17:14:55 <irene-knapp> he was just saying that primes are already factored so all you have to do is return them
17:14:57 <elliott> Jafet++
17:15:40 <Cale> You have to return the input, but depending on the machine model, that still might take more than constant time.
17:15:44 <dschoepe> elliott: Your algorithm seems to be incorrect, since 1 is not a prime and thus not a prime factor of p :) (sorry, could not resist)
17:15:59 <elliott> dcoutts: I never said factoring primes into prime factors!
17:16:02 <elliott> I just said factoring primes.
17:16:07 <irene-knapp> oh, well, that's easy
17:16:11 <Cale> f(p) = {-1,-1,-1,-1,p}
17:16:11 <dschoepe> hm, damn
17:16:16 <elliott> Prime factorisation of primes.
17:16:18 <monochrom> "into prime factors" is usually implied
17:16:20 <irene-knapp> factors(p) = { p / pi, pi }
17:16:26 <elliott> monochrom: So is "not of primes" :-)
17:16:27 <c_wraith> Cale: where's negate p?
17:16:37 <shachaf> monochrom: When elliott is in his pedant mode, nothing is implied.
17:16:44 <elliott> irene-knapp: Are you sure division is O(1)?
17:16:48 <elliott> shachaf: Hey, monochrom brought it up :P
17:16:54 <irene-knapp> elliott: good point
17:17:12 <elliott> This is why you should stick to tried and tested algorithms, like mine.
17:17:21 <Eduard_Munteanu> Heh.
17:17:34 <monochrom> lazy division is O(1) if you don't force evaluation
17:17:44 <Jafet> @check \p -> product [1,p] == p
17:17:46 <lambdabot>   "OK, passed 500 tests."
17:18:15 <monochrom> or rather, putting a division thunk in a cons list or something
17:18:33 <ddarius> @google "hamiltonian integers"
17:18:34 <lambdabot> http://mathworld.wolfram.com/HamiltonianInteger.html
17:18:35 <lambdabot> Title: Hamiltonian Integer -- from Wolfram MathWorld
17:18:37 <shachaf> @check \p -> product [1,p] == (p::Expr)
17:18:38 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary SimpleReflect.Expr)
17:18:39 <lambdabot>    arising f...
17:18:40 <Jafet> monochrom: well then, you didn't divide anything at all
17:18:55 <ddarius> Yay, that was exactly what I wanted it to be.
17:19:02 <elliott> monochrom: Every algorithm is O(1)!
17:19:06 <elliott> Just wrap it in (:[]).
17:19:44 <monochrom> Hamiltonian integers are more wacky than Gaussian integers
17:20:00 <ddarius> @google "Clifford integers"
17:20:05 <lambdabot> http://cdsweb.cern.ch/record/365411/files/9808010.pdf
17:20:05 <lambdabot> Title: UNREAL PROBABILITIES Partial Truth with Clifford Numbers
17:20:34 <monochrom> unreal probabilities are totally out of whack
17:21:03 <monochrom> "Lie algebras and Lie probability"
17:21:22 <irene-knapp> @google "Irene Integers"
17:21:25 <lambdabot> http://www1.hrbust.edu.cn/zuzhijigou/dangban/guestbook/default.asp?pageno=9420
17:21:32 <c_wraith> I judge the probability of a lie to be near 100%
17:21:33 <monochrom> in fact, "Lie algebras, Lie probability, Lie partial truth and Lie logic"
17:21:34 <Eduard_Munteanu> Heh.
17:21:53 <irene-knapp> aw :( that link does not in fact say anything about this important class of number!
17:22:25 <Eduard_Munteanu> Maybe it's a really hard problem :P
17:24:41 <cgroza> Does anyone know how to avoid the use of <- when working with IO?
17:24:50 <stepcut> cgroza: >>= ?
17:24:53 <ddarius> @undo do a <- m; n
17:24:54 <lambdabot> m >>= \ a -> n
17:25:18 <stepcut> or join and fmap, if you are a true masochist
17:25:22 <c_wraith> sufficient use of fmap and join
17:25:24 <Eduard_Munteanu> If by that you mean using = instead of <-, no.
17:25:26 <c_wraith> gah, darn you stepcut
17:25:32 <stepcut> :)
17:25:40 <shachaf> @@ @pl @undo do a <- m; return a
17:25:40 <lambdabot>  m
17:25:44 <cgroza> stepcut: works for functions that take 1 IO argument. I have diffClockTimes that should take 2 ClockTimes, but when I get them, they are inside IO.
17:25:49 <stepcut> c_wraith: I would have said it even sooner, but I was checking my spelling of masochist
17:26:11 <elliott> cgroza: try (<$>) and (<*>)
17:26:14 <elliott> from Control.Applicative
17:26:18 <cgroza> elliott: thanks.
17:26:29 <elliott> foo <$> a <*> b == do {x <- a; y <- b; return (foo a b)}
17:26:31 <Eduard_Munteanu> @undo do a <- m; b < - n; f a b
17:26:31 <lambdabot> m >>= \ a -> b < - n >> f a b
17:26:38 <shachaf> `liftM` `ap`
17:26:41 <elliott> cgroza: but stepcut was referring to the fact that any monadic computation can be built up from return, fmap and join
17:26:45 <Eduard_Munteanu> Oops.
17:26:49 <elliott> m >>= k === join (fmap k m)
17:26:49 <Eduard_Munteanu> @undo do a <- m; b <- n; f a b
17:26:49 <lambdabot> m >>= \ a -> n >>= \ b -> f a b
17:27:00 <Jafet> Use Applicative if you're a sadist
17:27:23 <scrap> hi
17:27:25 <cgroza> elliott: ok. I am going to spend some time with those functions. :D
17:27:26 <shachaf> @ty fmap join return
17:27:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
17:27:39 <elliott> shachaf: Perfect.
17:27:42 <Eduard_Munteanu> Anyway, I guess you don't want to trade '<-' for '->' :)
17:27:49 <Cale> hello scrap
17:28:00 <EdwinForTheWin> Hello
17:28:08 <Cale> hello Edwin
17:28:18 <shachaf> Cale: Hello!
17:28:22 <Cale> HELLO
17:28:23 <Eduard_Munteanu> shachaf: hi
17:28:40 <shachaf> EHLO localhost
17:28:45 <EdwinForTheWin> How are you?
17:28:47 <cgroza> does IO have a function instance?
17:28:47 <shapr> byorgey: Would you happen to have a pre-release version available if I have a press pass?
17:28:53 <elliott> cgroza: Huh?
17:28:54 <cgroza> functor **
17:28:57 <elliott> cgroza: Yes.
17:28:58 <shachaf> Cale: Are you going to Hac Boston? :-)
17:29:05 <elliott> cgroza: Every Monad in the standard library is Functor and Applicative.
17:29:05 <c_wraith> yes, IO is an instance of Functor
17:29:13 <cgroza> elliott: thanks
17:29:17 * ddarius needs to resurrect MegaMonad.
17:29:27 <c_wraith> elliott: that's relatively recent, though.  6.10 lacked an applicative instance for ST
17:29:31 <elliott> cgroza: (Applicative should be a superclass of Monad, and Functor of Applicative, but they're not. But it's easy to write an instance for any Monad which isn't an instance of those two, so don't hesitate to use applicative style.)
17:29:33 <shachaf> That sounds dangerous.
17:29:41 <ddarius> shapr: Do you have a press pass?
17:29:42 <elliott> c_wraith: Bah, ancient history :)
17:29:48 <Eduard_Munteanu> All decent monads are functors anyway :P
17:29:57 <shachaf> Hmm, seems to be an IRC bot.
17:30:22 <shachaf> elliott: Next you'll say Pointed should be a superclass of Applicative.
17:30:38 <c_wraith> shachaf: can I lobby to get it renamed to Pointy?
17:30:46 <elliott> shachaf: I don't really like Pointed.
17:31:09 <shachaf> elliott: No?
17:31:09 <shapr> ddarius: No, but I could pretend.
17:31:19 <elliott> shapr: No.
17:31:26 <shapr> elliott: I could too!
17:31:30 <elliott> Oops.
17:31:33 <elliott> shachaf: No.
17:31:41 <shachaf> elliott: Why no?
17:31:47 <elliott> shapr: Please always make shachaf say something after you do, so you don't break my autocomplete :-)
17:31:49 <ddarius> "Pretending" is a modal operator.
17:31:56 <elliott> shachaf: Why yes?
17:32:26 <shachaf> elliott: Are four character too much to type?
17:32:30 <shachaf> elliott: What if you want to talk to shapr?
17:32:45 <EdwinForTheWin> Hey I see it
17:32:57 <EdwinForTheWin> I quarreyed you
17:33:01 <elliott> shachaf: I tab-complete everyone with under four characters.
17:33:14 <elliott> Anyway, if I want to talk to shapr I'll just sort of say things without any general direction.
17:34:45 <Cale> EdwinForTheWin: you mined us right out.
17:35:28 <ddarius> Cale doesn't mined though.
17:36:58 <shapr> elliottt: Clearly tab complete is always accurate.
17:37:23 <shachaf> elliotttt: What shapr said.
17:53:27 <jaredj> is it foldr that's sorta bad or foldl
17:53:41 <monochrom> foldl
17:53:48 <elliott> you want foldr or foldl'
17:53:49 <shachaf> foldl is almost never the function you want to use.
17:53:55 <jaredj> ok
17:54:09 <shachaf> jaredj: foldr is also more fundamental than foldl.
17:54:19 <jaredj> next stop, avoiding concatenating a string from scratch character by character. hmm
17:54:47 <jaredj> mmk. i think i remember reading that in rwh like six months ago
17:55:08 <elliott> jaredj: difference lists
17:55:14 <elliott> jaredj: (you can use ShowS from the standard library)
17:55:16 <noidea> Does anyone have experience with cabal's error "setup: happy version >=1.17 is required but it could not be found.
17:55:19 <noidea> "
17:55:25 <shachaf> noidea: cabal install happy
17:55:26 <elliott> jaredj: alternatively, Data.Sequence, but if ShowS suffices...
17:55:27 <jaredj> :d ok thx elliott, will read up
17:55:35 <shachaf> Also add ~/.cabal/bin to your $PATH, or something like that.
17:55:57 <noidea> shachaf: I have. But when trying to cabal install derive-2.4 it tells me that erro
17:56:06 <noidea> I should have happy 1.18 or so
17:56:10 <shachaf> noidea: You have both of the things I said?
17:56:18 <shachaf> `which happy`
17:56:51 <noidea> Im not sure about the path. Ill check
17:57:23 <noidea> I am on Ubuntu 11.04 if it makes any different
17:57:27 <noidea> difference*
17:57:53 <shachaf> Did you add ~/.cabal/bin to your $PATH?
17:57:56 <shachaf> Otherwise it's probably not there.
17:58:10 * irene-knapp needs to really advocate the whole global-install thing
17:58:20 <irene-knapp> so that other people will run into the same problems she does and fix them for her
17:58:25 <shachaf> irene-knapp: Why would you advocate evil-install?
17:58:33 <irene-knapp> there's nothing wrong with it!!!
17:58:43 <irene-knapp> I have never once gotten the triangle dependency problem
17:58:48 <shachaf> Nothing wrong with having *write* permissions to a global directory?
17:58:54 <irene-knapp> uh, I do it with sudo
17:59:03 <irene-knapp> I don't have write permissions when I actually run the stuff
17:59:08 <shachaf> Nothing wrong with using sudo?
17:59:15 <irene-knapp> not if I know what it's going to do, no
17:59:15 <AfC> It's be nice if hackage would automatically build a .deb package for any cabal upload. Combined into a repository, that might get things on track.
17:59:29 <irene-knapp> also I have it configured so it's isolated from the boot libraries
17:59:34 <irene-knapp> I mean it uses the same package.conf.d
17:59:43 <irene-knapp> but its own directory for the actual installs
18:00:02 <shachaf> sudo bash -c 'kill -9 $$'
18:00:33 <irene-knapp> so if I ever need to revert a package I can just, uh, stick my fingers into a random orifice of the .pkg that installed it in the first place and get the .conf file back out from there
18:00:54 <irene-knapp> .deb packages actually probably have metadata that .cabal files don't
18:01:01 <irene-knapp> but it WOULD be nice
18:01:12 <irene-knapp> you get volunteered to implement it (dcoutts doesn't get around to reviewing my patches :( )
18:01:18 <elliott> <irene-knapp> I have never once gotten the triangle dependency problem
18:01:23 <elliott> irene-knapp: you're temporarily lucky!
18:01:39 <irene-knapp> elliott: and if I did get it I would just roll back, as I just said!
18:01:52 <shachaf> Is that the problem where cabal says "Error: A triangle is required but one could not be found"?
18:01:53 <irene-knapp> elliott: so it would be fine.  but it's not luck.  I actually know what I'm doing in there :)
18:01:57 <elliott> i typed that before seeing that :P
18:01:57 <irene-knapp> haha
18:02:01 <irene-knapp> oh, okay
18:02:33 <irene-knapp> shachaf: but I know what cabal-install does, see, and it doesn't do kill -9 $$
18:02:50 <irene-knapp> (what is $$, anyway?  is it the pid of the shell?)
18:03:23 <irene-knapp> (and why would killing the calling shell even be a problem?)
18:04:18 <shachaf> irene-knapp: Did I say it does?
18:04:27 <shachaf> I just like doing kill -9 $$.
18:04:30 <irene-knapp> shachaf: hahaha okay then
18:04:32 <shachaf> It's how I exit most shells.
18:04:54 <elliott> irene-knapp: (It's because it discards history.)
18:05:06 <irene-knapp> oh!  yeah, that would be annoying
18:05:23 <jaredj> i would love if it could reliably save history
18:05:56 <irene-knapp> agreed
18:06:27 <jaredj> but i suppose if you could save eight divergent histories, getting back to them may not be so simple as the up-arrow
18:06:38 * hackagebot zoom-cache-sndfile 0.2.0.1 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.2.0.1 (ConradParker)
18:06:39 <noidea> shachaf: alright. It should be added to my path.
18:06:46 <noidea> I've re run cabal install happy
18:06:50 <gienah> irene-knapp: I'm not exactly sure what you mean by the triangle dependency problem. I can obtain a consistent set of packages by using sed to bump the dependencies (with the current exceptions of statistics required by criterion, and dbus-core required by manatee)
18:07:11 <gienah> irene-knapp: and then patch things to fix the breakages
18:07:19 <noidea> and then cabal install derive-2.4
18:07:25 <irene-knapp> gienah: it's a problem that I'm not really exactly sure what it is either, except newbies were perpetually getting it for a while and we were having to page dcoutts because he was the only one who knew how to fix it
18:07:31 <jaredj> noidea: if it makes you happy, it can't be that baaaad
18:07:36 <irene-knapp> gienah: but then he disabled "cabal upgrade" and it stopped happening as much
18:07:44 <elliott> noidea: derive==2.4, surely
18:07:45 <noidea> and it still throws setup: happy version >=1.17 is required but it could not be found.
18:07:55 <elliott> are you sure happy is of version >= 1.17?
18:08:01 <irene-knapp> happy --version
18:08:02 <elliott> cabal might have decided to install another version.
18:08:44 <noidea> mmm... it ends with Installing executable(s) in /home/lucas/.cabal/bin
18:08:44 <shachaf> elliott knows all my secrets. :-(
18:08:58 <noidea> but I ran happy --version and it tells me it doesnt have it
18:09:02 <noidea> so Ill apt-get it
18:09:10 <elliott> noidea: PATH=~/.cabal/bin:$PATH
18:09:16 <elliott> Like shachaf said.
18:09:37 <irene-knapp> I'm not sure you can put a tilde in the value of $PATH
18:09:43 <shachaf> elliott: Why would anyone do what I say?
18:09:45 <irene-knapp> I think you have to expand it before that
18:09:51 <elliott> A good question.
18:09:52 <shachaf> PATH="$HOME/.cabal/bin:$PATH"
18:09:52 <mauke> PATH="$HOME/.cabal/bin:$PATH"
18:10:10 <elliott> $ PATH=~/.cabal/bin happy
18:10:11 <elliott> Usage: happy [OPTION...] file
18:10:26 <elliott> Doesn't break if HOME changes :-)
18:10:27 <mike-burns> You can put a tilde in $PATH in most modern shells.
18:10:40 <shachaf> elliott: bash expands it when you set the variable.
18:10:44 <elliott> Oh no!
18:10:47 <elliott> Well, um, er.
18:10:53 <irene-knapp> I don't think it does expand it when you set the variable,
18:10:57 <irene-knapp> because it's not at the start of a word
18:11:06 <shachaf> FOO=~/a
18:11:09 <shachaf> echo $FOO
18:11:21 <irene-knapp> oh, go figure
18:11:24 <irene-knapp> it works
18:11:30 <elliott> Even works for ~/foo:~/bar.
18:11:38 <shachaf> Anyway, it won't work with double quotes.
18:11:40 <irene-knapp> but but but!
18:11:45 <irene-knapp> what if my home directory is NAMED tilde?
18:11:48 <shachaf> PATH="~/.cabal/bin:$PATH" doesn't work.
18:11:53 <shachaf> Which is what you want.
18:11:53 <irene-knapp> /Users/~/ ?
18:12:02 <shachaf> /Users/?
18:12:05 <noidea> ahh my bad. I forgot to save my .bashrc >.<
18:12:08 <irene-knapp> I'm on a Mac
18:12:13 * shachaf wants nothing more to do with this.
18:12:18 <irene-knapp> haha
18:12:46 <mike-burns> Whoa, you can name a file ~ .
18:12:57 <irene-knapp> of course you can
18:13:00 <mike-burns> Experimenting with this is going to lose me a bunch of data.
18:13:06 <irene-knapp> the only character you can't use in a filename is slash
18:13:11 <noidea> ~ is home .bashrc is a file / is a dir
18:13:17 <irene-knapp> (the null byte isn't a character)
18:13:18 <mauke> mike-burns: you can name a file '-', '-r', '-f', '\t', and '\n'
18:13:27 <mike-burns> I knew that much.
18:13:27 <irene-knapp> mauke: that's cruel :D
18:13:40 <mike-burns> Those are run to rm.
18:13:43 <mike-burns> fun
18:13:57 <irene-knapp> I actually do have some directories whose names start with dashes :/
18:14:07 <irene-knapp> suggestions for other things that collate before letters in the C locale would be welcome
18:14:20 <mike-burns> Space?
18:14:26 <irene-knapp> hm
18:14:31 <irene-knapp> but that would be EVEN MORE obnoxious to type :)
18:14:41 <mauke> irene-knapp: @ = % + # $ !
18:14:46 <irene-knapp> hmmmm
18:14:48 <shachaf> > take 40 $ [' '..]
18:14:49 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG"
18:14:52 <irene-knapp> but those are all special to the shell too :(
18:14:57 <shachaf> Ignore the $, please.
18:14:57 <mauke> irene-knapp: @? since when?
18:15:07 <mike-burns> shachaf wins for keeping it relevant to the channel.
18:15:07 <irene-knapp> oh, hm, good call
18:15:17 <irene-knapp> > take 40 "and call me in the morning"
18:15:18 <mauke> as far as I know @ % + are free and = is mostly free
18:15:18 <lambdabot>   "and call me in the morning"
18:15:25 <mike-burns> Hah.
18:15:27 <irene-knapp> $ costs money
18:15:46 <soapyyyy> hello
18:16:27 <irene-knapp> that worked, thanks
18:16:28 <irene-knapp> I went with @
18:20:05 <shachaf> Hmm, apparently I sometimes pronounce "&" as "at".
18:20:20 <irene-knapp> fascinating
18:20:35 <shachaf> I also pronounce "!!" as "not not".
18:21:04 <monochrom> do you pronounce "<|>" as "less than or bigger than"? :)
18:21:05 <elliott> irene-knapp: + is not special
18:21:07 <mauke> border: 1px solid red !important;
18:21:12 <elliott> irene-knapp: nor is %, = might be
18:21:16 <elliott> at least in initial filename position
18:21:29 <shachaf> monochrom: I pronounce it as "grunt", more or less.
18:21:34 <irene-knapp> mauke: border: solid red 1px !important; /* the order is significant */
18:21:51 <irene-knapp> elliott: hmmmm okay
18:21:55 <monochrom> border: solid red 1px !important; /* the order is !important */
18:22:04 <tomprince> = can be special before ~ too.
18:22:06 <shachaf> irene-knapp: Wait, what's the difference there?
18:22:13 <irene-knapp> monochrom: heh
18:22:23 <irene-knapp> shachaf: the difference is that my version works :)
18:22:33 <shachaf> irene-knapp: I've always used "1px solid red".
18:22:40 <shachaf> Not that I've done much CSSing.
18:22:41 <irene-knapp> shachaf: really?  I don't think that's standard
18:23:20 <elliott> Yes, it is.
18:23:23 <elliott> The size comes first.
18:23:37 <mauke> irene-knapp: where did you get your order from?
18:23:46 <irene-knapp> the 2.1 spec, let me check it
18:24:06 <elliott> irene-knapp: http://www.w3.org/TR/css3-background/#the-border-shorthands
18:24:29 <elliott> also http://www.w3.org/TR/CSS2/box.html#border-shorthand-properties
18:25:01 <irene-knapp> hmmmm, one sec
18:25:42 <irene-knapp> huh
18:25:47 <irene-knapp> I was sure it was going to be a 3 vs 2.1 thing
18:25:50 <irene-knapp> but http://www.w3.org/TR/CSS21/box.html#border-shorthand-properties agrees with you
18:26:06 <irene-knapp> I guess I didn't realize that their || notation in their extended BNF means something
18:26:19 <irene-knapp> so I assumed the order was fixed
18:26:24 <hpaste> tphyahoo pasted “hinotify needs hsc2hs to install... but hsc2hs IS installed” at http://hpaste.org/54382
18:26:42 <mauke> if you assume a fixed order, it would have to be "1px solid red"
18:26:59 <mauke> width comes first
18:27:11 <shachaf> red border: solid 1px;
18:27:23 <shachaf> 1px: solid red border;?
18:27:47 <mauke> you can't just style into bordor
18:28:07 <irene-knapp> border { 1px: solid red !shachaf; }
18:28:25 <tphyahoo> having trouble installing inotify... any ideas?
18:28:28 <ion> yoda
18:28:56 <irene-knapp> okay yeah, http://www.w3.org/TR/CSS21/about.html#value-defs officially blesses the any-order thing
18:28:59 <irene-knapp> who knew?
18:29:09 <irene-knapp> it's worth noting that CSS3 still isn't portable, heh
18:29:10 <shachaf> mauke knew
18:29:16 <irene-knapp> yes, let me rephrase that
18:29:33 <irene-knapp> setDifference (who knew) [mauke)
18:30:49 <irene-knapp> did I remember the name of setDifference correctly?  that sounds wrong
18:31:04 <monochrom> their || allows re-ordering. "A double bar (||) separates two or more options: one or more of them must occur, in any order."
18:32:58 <irene-knapp> yes, that's what I said :)
18:33:03 <irene-knapp> I just linked to where it says it, in fact :)
18:33:15 <monochrom> I was lagged
18:33:17 <irene-knapp> oh
18:33:44 <shachaf> monochrom: Are you going to Hac Boston?
18:33:57 <monochrom> no, too busy and no money
18:34:08 <monochrom> and too lazy to get passport
18:34:09 <irene-knapp> aw, you should come!
18:34:27 <monochrom> and US Customs is too much a jerk
18:34:27 <shachaf> Don't you live vaguely in the area?
18:34:34 <irene-knapp> well, I sympathize with that one, for sure
18:34:43 <monochrom> I live vaguely outside US Customs, yes.
18:35:14 <monochrom> did you know that they could retain your laptop at a whim?
18:35:30 <elliott> <irene-knapp> I guess I didn't realize that their || notation in their extended BNF means something
18:35:35 <irene-knapp> I read recently that they don't have a good solution for full-disk encryption yet
18:35:35 <elliott> irene-knapp: even if it does, the width is first there :)
18:35:54 <irene-knapp> elliott: well, rather, I guess I combined information from multiple sources, hahaha
18:35:58 <elliott> heh
18:36:04 <irene-knapp> elliott: although now I wonder where I got that order from :/
18:36:29 <monochrom> oh, doesn't matter whether they can read your data. they choose to retain your laptop for examination for one week. maybe after one week they read nothing. you still lose one week, and gain agony.
18:36:31 <shachaf> monochrom: You are vaguely near Cale, right?
18:36:32 <irene-knapp> so if you really want to waste their time, you should turn on FileVault
18:36:42 <irene-knapp> well, yeah
18:36:44 <monochrom> I am vaguely near Cale
18:36:54 <shachaf> You should both go.
18:36:59 <irene-knapp> but there's the vengeance factor, see
18:37:27 * Cale can haz passport?
18:37:35 <Cale> hau do?
18:37:44 <irene-knapp> "Ha ha!  I had no laptop for a week, and it sucked, but YOU spent eight hours staring at a progress bar while my drive copied only to realize afterward that you couldn't read the data."
18:38:37 <shachaf> Cale: Does that mean you have one, or don't have one, or want one?
18:38:46 <monochrom> would defeat the point of HacBos with laptop detained
18:38:54 <Cale> I don't have one
18:39:14 <shachaf> Cale: You should get one, then!
18:39:25 <shachaf> Or just get the special US/Canada only card thing that they have, maybe.
18:39:27 <Cale> Yeah, probably. I'm not sure how that all works.
18:39:29 <monochrom> and generally other US Customs harassments that do nothing to increase security
18:39:52 <Cale> I don't have a laptop to have detained.
18:39:57 <Cale> at least
18:40:48 <shachaf> Cale: I don't think it could be all *that* complicated.
18:41:41 <Cale> Yeah. I think you just have to get an appropriately constructed photo and then pay $60 or something.
18:41:50 <Cale> When is this thing again?
18:41:57 <irene-knapp> January, I think
18:41:57 <shachaf> Jan 20
18:42:07 <Cale> okay, so I have a decent amount of time
18:42:11 <irene-knapp> yep
18:42:27 <shachaf> Not all *that* decent, depending on how bureaucratic the process.
18:42:35 <noidea> haha
18:43:12 <noidea> ahhh. Im so close to installing Yi. Its not throwing the errors any mmore, but this one
18:43:13 <monochrom> go apply now
18:43:16 <noidea> cabal: The package yi-0.6.4.0 requires the following languages which are not
18:43:18 <noidea> supported by ghc-6.12.3: Haskell2010
18:43:42 <noidea> which is very unfortunate after all of that
18:44:05 <noidea> Trying to cabal install Haskell2010 gives me some sort of base error
18:44:22 <noidea> and Ive read that you cant reinstall base, and its important to the compiler(ghc)
18:44:37 <shachaf> http://www.ppt.gc.ca/cdn/service.aspx
18:44:39 <Cale> apparently it's 10 or 20 business days, so I should be able to manage, hmm
18:44:48 <monochrom> did you hear what I said earlier today? use an older yi or a newer ghc.
18:44:55 <Cale> yeah, that page :)
18:45:05 <irene-knapp> noidea: oh!  you need a newer GHC
18:45:10 <irene-knapp> or an older yi, as monochrom said
18:45:22 <noidea> monochrom: Im trying to compile from source this time. Id rather be up to date :)
18:45:24 <irene-knapp> but given yi's state of (in)completion, I'd recommend a newer GHC
18:45:42 <monochrom> use a newer ghc to be "up to date"
18:45:54 * irene-knapp notes that she has never actually tried yi, or looked at it, or anything.  she just knows it's incomplete because it's an attempt to reimplement Emacs :)
18:46:00 <monochrom> and yes screw your ubuntu's ghc if necessary
18:46:19 <noidea> ok
18:46:20 <Jafet> In ubuntu, ghc screws you!
18:46:34 <noidea> and my grandmother's name was Irene
18:46:45 <noidea> Shes long gone though.
18:47:03 <irene-knapp> ahhh
18:47:04 <irene-knapp> I see!
18:47:18 <irene-knapp> yes, the name had its height of popularity in the 1920s :)
18:47:24 <noidea> Yep
18:47:38 <scshunt> current ubuntu has 7.0.3
18:47:47 <irene-knapp> note that 7.2.2 is current
18:47:53 <irene-knapp> and 7.4 is any week now
18:48:11 <shachaf> Cale: How would you get to Boston? There's a bus, so I hear.
18:48:14 <irene-knapp> they just merged the ghc-kinds branch this morning (I think - I wasn't totally sure what the commit messages were saying)
18:48:17 <irene-knapp> no
18:48:19 <irene-knapp> do NOT take the inter-city bus
18:48:23 <Jafet> Current ubuntu is an oxymoron
18:48:26 <irene-knapp> take Amtrak if you can afford it
18:48:40 <irene-knapp> rent a car if you can't
18:48:57 <shachaf> Really?
18:49:02 <Cale> I can't drive, so renting a car isn't an option
18:49:04 <shachaf> My NYC<->BOS bus trip went well.
18:49:17 <Cale> Train?
18:49:30 <irene-knapp> ah, hm
18:49:45 <irene-knapp> shachaf: it can go okay... especially if you stick with Greyhound
18:49:53 <Cale> Maybe flying is actually cheaper than taking a train. I should check that too.
18:49:58 <irene-knapp> yeah, you should look at it
18:50:14 <shachaf> Flying is ~$300 round-trip, I think.
18:50:15 <irene-knapp> the last time I took a Greyhound, granted it wasn't a major route like that (it was Syracuse, NY to NYC)
18:50:28 <Cale> I remember taking a train trip to Montreal and then finding out after that it's actually cheaper to fly. :P
18:50:41 <irene-knapp> but I wound up seated next to a guy, stop me if I've told this one oh wait you can't beause it's all in one line, whose idea of conversation was explaining the significance of each digit in his parole number
18:50:46 <irene-knapp> for eight hours, mind you
18:51:10 <irene-knapp> he also borrowed my cellphone for some of that time (he offered to pay, but I didn't feel right taking the only $20 he had in the world.  apparently they give you $20 when they release you from prison.)
18:51:30 <irene-knapp> (so I let him use it for free and then immediately worried that he was making international calls or something)
18:51:34 <Cale> I ended up meeting a friend of mine from the pure math club at my university on the way back, and we had a game of go on the train :)
18:51:37 <irene-knapp> heh, cool, hahaha
18:52:05 <shachaf> I met a Haskell person on the train from San Francisco once.
18:52:27 <monochrom> flying is both cheaper and less hassle than train, in case of crossing US Customs. did you know that if you use train, at the border you have to get off one train, take your baggage, walk to another train?
18:53:03 <monochrom> and IIRC the walking distance is not exactly nice
18:54:03 <shachaf> monochrom: Have you done it?
18:54:14 <monochrom> no. a friend had to do it a long time ago.
18:54:28 <monochrom> long time ago but post-911 time
18:55:21 <cmasseraf> where is the ghci init files located in windows?
18:55:34 <monochrom> and yes tonight is US Customs bashing night. because of Hac Boston enthusiasism!
18:59:31 <shachaf> monochrom: So you're not going?
18:59:38 <shachaf> Even Cale will be there!
18:59:52 <monochrom> I am not going.
19:01:31 <djahandarie> monochrom will be busy at HacTor
19:12:12 <copumpkin> lame
19:16:39 * hackagebot hdf 0.11 - Haskell data flow library for audio processing  http://hackage.haskell.org/package/hdf-0.11 (RohanDrape)
19:21:06 <cmasseraf> any know a Distribute Haskell Library?
19:21:28 <gienah> cmasseraf: remote ?
19:21:39 * hackagebot hsdif 0.11 - Haskell SDIF  http://hackage.haskell.org/package/hsdif-0.11 (RohanDrape)
19:22:22 <gienah> @hackage remote
19:22:23 <lambdabot> http://hackage.haskell.org/package/remote
19:24:53 <gio123> Cale: hi
19:26:18 <dr_rotflcopter> hey
19:27:00 <elliott> cmasseraf: Cloud Haskell?
19:27:09 <elliott> oh, that is cloud haskell
19:27:44 <cmasseraf> not exactly
19:28:11 <cmasseraf> more like a Hadoop MapReduce
19:29:24 <jaredj> perhaps i have inadvertently used difference lists
19:29:45 <cmasseraf> I want to execute some heavy cpu bound programs on a cluster
19:31:22 <shachaf> jaredj: It happens.
19:34:30 <wvoq> hello all, quick question: I've noticed that hpaste can give some (IMHO) very sophisticated advice about the pastes it gets.  Does anyone know what's responsible for that?
19:34:42 <Jafet> @hackage hlint
19:34:43 <lambdabot> http://hackage.haskell.org/package/hlint
19:34:59 <Jafet> It uses the hlint program
19:35:10 <wvoq> thanks jafet
20:02:06 <Axman6> win 20
20:02:25 <irene-knapp> no no
20:02:27 <irene-knapp> win32
20:04:05 <shachaf> Axman6: Alt-O Ctrl-N
20:04:10 <kmc> punch the monkey and win $20
20:04:56 * Axman6 punches Xcode in the ballsack
20:05:03 <irene-knapp> no see
20:05:10 <irene-knapp> software is the part of the computer you CAN'T kick
20:05:48 <kmc> that's a good operational definition
20:05:57 <irene-knapp> yep
20:06:02 <irene-knapp> not original to me, sadly
20:07:01 <byorgey> operationally, that definition only lets you determine which things are NOT software
20:07:18 <byorgey> it is a semi-decision procedure.
20:07:27 <irene-knapp> what does "operational" actually mean formally, anyway?
20:07:50 <djahandarie> Constructivist scum!
20:09:30 <irene-knapp> hm
20:15:48 <thoughtpolice> kfish: so i think i have an idea of what i want to do with vacuum. i've got initial changes that move ivan's work out into its own vacuum-graphviz package and i started doing a little hacking on vacuum-cairo. i may ask dons if i can take maintainership of it too (since gtk2hs went cabal, it's much less hassle, even if it's a big dependency.)
20:15:57 <irene-knapp> hmmmm cool
20:16:01 <irene-knapp> @hackage vacuum
20:16:01 <lambdabot> http://hackage.haskell.org/package/vacuum
20:16:10 <thoughtpolice> i'm probably not going to get any further until after thanksgiving, however
20:16:15 <irene-knapp> oh gtk2hs is Cabal now!!!! awesome!
20:16:20 <irene-knapp> does it actually build though?
20:16:29 <thoughtpolice> i'll also probably just generally clean it all up too. some of that vacuum code looks a little crufty
20:16:32 <irene-knapp> haha but I don't even have a working gtk since Lion so I guess that's academic :(
20:17:13 <thoughtpolice> irene-knapp: yeah, but you have to install gtk2hs-buildtools first. all the remaining packages have custom Setup.hs files which use the build tools to get past various limitations
20:17:28 <irene-knapp> hmmmm okay
20:17:32 <irene-knapp> well, that's something!
20:17:39 <irene-knapp> can't it just depend on gtk2hs-buildtooks?
20:17:41 <kfish> thoughtpolice, sounds great :) i expect dons will be happy to have someone maintain vacuum-cairo too :)
20:17:43 <irene-knapp> s/k/l/
20:17:50 <thoughtpolice> so that's the only caveat. i've heard on the grapevine that these days it's possible to get gtk2hs to work with the native gtk+ port to OS X, as opposed to the x11 port
20:18:01 <irene-knapp> that would be very awesome
20:18:04 <thoughtpolice> irene-knapp: can't have dependencies on programs with cabal.
20:18:12 <irene-knapp> I am an expert on building the native gtk+ port to OS X (which is not distribute din binary form)
20:18:22 <irene-knapp> thoughtpolice: er, you can if the programs themselves are cabalized.  can't you?
20:18:38 <irene-knapp> thoughtpolice: that's how the dependency on alex and happy works, isn't it?  or are those hardcoded?
20:18:44 <thoughtpolice> irene-knapp: cabal can't track dependencies on programs, only libraries
20:18:55 <kfish> irene-knapp, i would be interested to know if cairo-appbase builds on osx :)
20:19:01 <thoughtpolice> it'll alert you you're missing alex/happy, but it won't install them for you
20:19:10 <irene-knapp> hmmmm, okay
20:19:14 <irene-knapp> @hackage cairo-appbase
20:19:14 <lambdabot> http://hackage.haskell.org/package/cairo-appbase
20:19:29 <irene-knapp> oh, interesting
20:19:47 <irene-knapp> I'd find out for you, except I don't want to build gtk+ right now :)
20:19:56 <irene-knapp> it takes me all day :(
20:20:42 <thoughtpolice> kfish: i'm sure he will. i also plan on taking care of other tidbits, like a new website and actual documentation. ;P so i expect i'll probably end up taking over maintenance of vacuum proper
20:21:06 <thoughtpolice> on the note of gtk2hs too, it needs a new maintainer these days. but working on UI toolkits isn't glamorous work :(
20:21:23 <thoughtpolice> (it's more problematic that it's one of the few we have, though!)
20:21:33 <irene-knapp> @ask dcoutts It came up in channel that Cabal doesn't install programs, such as alex, happy, and gtk2hs-buildtools, that are listed in build-depends but not installed.  Is that a deliberate decision?  Why?
20:21:33 <lambdabot> Consider it noted.
20:21:59 <irene-knapp> yeah - well, actually, I enjoy working on UI toolkits
20:21:59 <irene-knapp> but
20:22:02 <irene-knapp> not gtk+ :(
20:22:16 <irene-knapp> I have exacting standards
20:22:26 <irene-knapp> I won't accept anything that uses non-native widgets on Mac and Win
20:22:48 <irene-knapp> or non-native standard dialogs (open/save/font/color/... there's actually quite a lot of them)
20:23:06 <irene-knapp> or forces non-native menu layouts or keybindings
20:23:22 <irene-knapp> tcl/tk is actually the only thing I've ever seen that lives up to my expectations
20:23:39 <Clint> how bad is qt?
20:23:41 <thoughtpolice> i've thought of ripping out part of shoes and putting a haskell layer on top of its underlying C code, since it has mostly native widgets IIRC
20:23:45 <irene-knapp> which is rather unfortunate, as the GUI framework of it, which is actually rather solid, is wedded quite deeply to a horrible language :)
20:23:49 <ion> Say, a C API provides a single function that both flushes buffers to disk and deallocates everything. When using FFI, can i force Haskell to do finalization at a specific point (in a bracketed style) instead of leaving it for GC?
20:23:58 <Jafet> irene-knapp: because cabal-install sucks
20:24:10 <irene-knapp> Qt isn't awful, but it wants to rule your world.  You can't even integrate Qt into an external build system, heh.
20:24:26 <irene-knapp> Qt and Gtk+ are probably about equally bad
20:24:32 <irene-knapp> @hackage shoes
20:24:32 <lambdabot> http://hackage.haskell.org/package/shoes
20:24:51 <thoughtpolice> irene-knapp: shoes is a simple UI toolkit, not a haskell one :)
20:24:55 <irene-knapp> ah, hm :)
20:25:01 <thoughtpolice> er, for ruby :P
20:25:04 <irene-knapp> well, what I would do is
20:25:15 <irene-knapp> I would take libtk, right, and NOT use it as a base for my own thing
20:25:19 <thoughtpolice> but it does have a good portion of C code underlying it for abstracting out a bit of the tedious stuff. may be reusable
20:25:32 <irene-knapp> but would take PIECES of it as examples of how to design the API and also as shortcuts to correct implementation
20:26:13 <irene-knapp> shoes would probably also be worth looking at, in the same way
20:26:21 <irene-knapp> just as "inspiration", not really as a basis
20:27:38 <kfish> i thought recent gtk+ used native widgets on osx?
20:27:55 <ion> finalizeForeignPtr seems like it might be what i want. If only i could read the documentation at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html#v:finalizeForeignPtr
20:28:58 <Axman6> :t readLine
20:28:59 <lambdabot> Not in scope: `readLine'
20:29:03 <Axman6> :t readLn
20:29:04 <lambdabot> forall a. (Read a) => IO a
20:29:14 <irene-knapp> kfish: it.... not really :)
20:29:18 <irene-knapp> kfish: it uses the native windowing system, at least
20:29:36 <kfish> ok
20:30:17 <Jafet> Why not: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr-Safe.html#v:finalizeForeignPtr
20:30:26 <irene-knapp> @tell edwardk so, uh, I hear hac boston is full already!  I had meant to sign up, is it too late? :)
20:30:26 <lambdabot> Consider it noted.
20:31:14 <ion> jafet: I just tried what Hoogle linked for me.
20:40:24 <elliott> hmm, does finalizeForeignPtr prevent the pointer from being finalised again?
20:42:08 <shachaf> elliott: Ptrs aren't finalised, they're finalized.
20:42:15 <shachaf> ForeignPtrs, I mean.
20:42:21 <elliott> :p
20:43:17 <elliott> yes, it does
20:43:21 <Jafet> FinalizationFinialization
20:43:52 <JoeyA> AbstractMutableIteratorProxyFinalizer
20:44:20 <JoeyA> Factory
20:45:29 <Jafet> @quote factorybean
20:45:29 <lambdabot> kmc says: i <3 http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
20:47:12 <JoeyA> http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/beans/factory/InitializingBean.html
20:47:50 <elliott> Hey, finalizeForeignPtr isn't thread-safe.
20:48:01 <elliott> (Not that that... matters.)
20:49:25 <JoeyA> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Foreign-ForeignPtr.html#v:finalizeForeignPtr
20:49:41 <JoeyA> (hyperlink for convenience; I get 404s trying to access the same for 4.4.* or latest)
20:49:58 <elliott> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-ForeignPtr.html#finalizeForeignPtr
20:49:59 <elliott> works for me
20:51:15 <jaredj> elliott: http://patch-tag.com/r/jaredj/ofx1-censor/snapshot/current/content/pretty/Censor.hs line 75, entify function
20:51:26 <jaredj> have i inadvertently done the right thing?
20:51:44 * elliott has no idea what the context is, but is scared.
20:51:55 <elliott> prng = mkStdGen 5
20:52:06 <elliott> jaredj: You may find an unfortunate lack of randomness between runs of your program.
20:52:21 * elliott looks at entify.
20:52:25 <elliott> jaredj: Have you heard of concatMap?
20:52:25 <jaredj> buh? maybe my numbers and lines don't match up right
20:52:33 * elliott didn't see the entify bit.
20:52:42 <JoeyA> Gosh, that isn't threadsafe.  What if a finalizer is being run from one thread when finalizeForeignPtr is called?  Think of the children!
20:52:52 <elliott> Anyway, esc '<' = "&lt"; esc '>' = "&gt;"; esc '&' = "&amp;"; esc c = [c]
20:52:54 <jaredj> concatMap, yes..
20:52:56 <elliott> Then concatMap esc xs.
20:53:01 <elliott> jaredj: Also, you should really use an HTML library.
20:53:04 <jaredj> oic
20:53:09 <JoeyA> (referring to finalizeForeignPtr)
20:53:17 <jaredj> well - it's SGML
20:53:48 <jaredj> so the tags are different
20:54:01 <elliott> jaredj: Well, alright. The "html" library at least supports arbitrary tag names.
20:54:06 <jaredj> oh eh
20:54:13 <jaredj> i forgot how i seized on tagsoup
20:54:20 <elliott> blaze-html is also popular, I think.
20:54:23 <elliott> jaredj: No no, I mean for generation.
20:54:31 <elliott> What with your manual escaping and all that.
20:55:30 <elliott> jaredj: You should also use top level type signatures, but you probably know that.
20:55:44 <jaredj> oh, heck, i copied that entify function wholesale from the source noted :)
20:56:10 <elliott> heh
20:56:14 <JoeyA> Is there a library in Hackage for basic substring replacement?  E.g.: replace :: [(String, String)] -> String -> String
20:56:20 <elliott> jaredj: I'm nots ure what "have i inadvertently done the right thing" was about, anyway.
20:56:32 <elliott> JoeyA: split could do that with intercalate or something, no?
20:56:48 <jaredj> i was talking about re-forming strings a char at a time earlier and someone mentioned difference lists and ShowS.
20:57:36 <elliott> Oh! That's what you were talking about?
20:57:43 <elliott> String is just a singly-linked list of characters.
20:57:48 <jaredj> sure
20:57:54 <jaredj> i was nervous about all the ++
20:57:54 <elliott> So there's no problem building and processing them character by character at all; it's the *only* way you can do it.
20:58:16 <jaredj> but that appeared to be what the ShowS came down to
20:58:16 <elliott> Well, (++) there isn't that bad, since it's always applied the right way:
20:58:23 <elliott> smallstring ++ (smallstring ++ (smallstring ++ ...))
20:58:28 <jaredj> *nod* ok
20:58:34 <irene-knapp> well, the SHowS is a trick to always do the ++ in the efficient order
20:58:45 <irene-knapp> the one that avoids redundantly traversing the strings
20:58:59 <shachaf> elliott: Nonsense, didn't you hear? <> needs to be infixl.
20:59:07 <elliott> shachaf: Who said that? :p
21:02:15 <shachaf> elliott: Whoever was arguing with edwardk.
21:02:25 <elliott> shachaf: on what grounds??
21:02:39 <JoeyA> Is it possible to create manually specialized functions?  For example, nub :: Eq a => [a] -> [a] could be specialized for Int by using an IntSet to keep track of duplicate items.
21:04:58 <irene-knapp> gahhhhhhhhh freaking multipass makefiles!
21:05:18 <irene-knapp> can't get a simple variable update to work because I have no idea what the order of evaluation is
21:05:22 <jaredj> is it usual for "runhaskell Setup.hs configure" and "cabal configure" to get at different sets of installed libraries?
21:05:44 <irene-knapp> jaredj: do the following:
21:05:51 <c_wraith> JoeyA: that probably could be done with RULES pragmas.  But...  It's ugly :)
21:05:55 <irene-knapp> $ runhaskell Setup.js --version
21:05:57 <dolio> {-# RULE "nubInt" nub = nubInt #-}
21:05:58 <irene-knapp> $ cabal --version
21:06:06 <irene-knapp> $ runhaskell --version
21:06:08 <irene-knapp> $ ghc --version
21:06:25 <JoeyA> What keeps that rule from firing for other instances of nub?
21:06:32 <irene-knapp> I'm not quite sure what depends on what there, but hopefully comparing the output of those commands will be enough for you to intuit the solution :)
21:06:32 <dolio> The types are wrong.
21:06:33 <JoeyA> (i.e. those that don't work on Ints)
21:06:47 <jaredj> irene-knapp: indeed they are different. thanks for the tip
21:06:50 <JoeyA> So rule application is type-checked?
21:06:50 <irene-knapp> np :)
21:06:54 <dolio> Yes.
21:07:02 <JoeyA> and silently not performed when the types don't match?
21:07:12 <irene-knapp> interesting, didn't know that
21:07:13 <djahandarie> I wonder how that interacts with really complex type hacking.
21:07:21 <hpaste> tgeeky pasted “streams using G. Hutton's methods” at http://hpaste.org/54387
21:07:33 <Jafet> GHC does the only sensible thing to do? Amazing!
21:07:52 <Jafet> RULES in fact officially subsumes SPECIALIZE.
21:08:07 <irene-knapp> Jafet: it really is amazing though when you consider how many languages that isn't true of :)
21:08:20 <elliott> Jafet: Huh, SPECIALISE is deprecated?
21:08:36 <elliott> (shachaf will poke fun at my spelling but actually GHC accepts SPECIALISE.)
21:08:48 <Jafet> Okay, so it subsumes SPECIALISE.
21:09:11 <elliott> No, that was a sincere question :-)
21:09:15 <Jafet> elliott: that's what the GHC manual says, but JoeyA does not seem to trust the manual, because he doesn't read it
21:09:26 <Jafet> So perhaps this information isn't helpful to him
21:09:26 <elliott> lol
21:10:32 <Jafet> Oh, it isn't completely officially deprecated.
21:10:57 <JoeyA> "GHC makes absolutely no attempt to verify that the LHS and RHS of a rule have the same meaning. That is undecidable in general, and infeasible in most interesting cases. The responsibility is entirely the programmer's!"
21:11:05 <JoeyA> That makes me thing it doesn't even check types.
21:11:16 <copumpkin> it does check types
21:11:27 <copumpkin> Jafet: specialize generates the specialized function for you, too
21:11:29 <JoeyA> ". So a rule only matches if the types match too."
21:11:36 <copumpkin> Jafet: the old meaning of specialize is deprecated and you can't write it anymore without rules
21:11:56 <elliott> oh, there's a new meaning?
21:11:58 <Jafet> Yeah, I'm talking about that old meaning because JoeyA is talking about it
21:12:30 <copumpkin> ah okay
21:12:34 <elliott> hmm, maybe i don't know what the old meaning is, 7.2.2's SPECIALISE documentation looks like the meaning i'm used to
21:12:55 <copumpkin> apparently in the good ol days you could say "for type X, use implementation Y"
21:13:02 <copumpkin> you can do that now with rules
21:13:13 <copumpkin> but specialize covers the common case and you don't need to write any new code
21:13:32 <copumpkin> I think it boils down to creating the custom function and throwing a rule in for you
21:13:32 <elliott> oh, ok
21:14:01 <JoeyA> Can a RULE substitute a function for one that works on a subclass of values where applicable?  Say I implement nubOrd :: (Ord a) => [a] -> [a], which uses a Set to keep track of items that have already appeared.
21:14:25 <thoughtpolice> copumpkin: shouldn't you be sleeping?
21:14:30 <JoeyA> Will {# RULE "nubOrd" nub = nubOrd #-} work?
21:14:31 <irene-knapp> I have a question
21:14:34 <copumpkin> yeah, just brushed my teeth
21:14:34 <thoughtpolice> copumpkin: liar!
21:14:36 <irene-knapp> can we make a Haskell version of "make"
21:14:37 <copumpkin> am about to go to sleep
21:14:42 <irene-knapp> and rewrite the GHC build system in it
21:14:43 <dolio> He can just sleep at work tomorrow.
21:14:44 <irene-knapp> PLEASE
21:14:44 <thoughtpolice> ok then, that's acceptable
21:14:48 <copumpkin> dolio: good idea
21:14:51 <thoughtpolice> dolio: always a popular choice
21:15:06 <companion_cube> {# RULE TheWorld #}
21:15:07 <copumpkin> irene-knapp: shake, maybe? there's max bolingbroke's reimplementation of it on github
21:15:16 <thoughtpolice> i've thought about hacking on openshake
21:15:28 <irene-knapp> copumpkin: hmmmmmm, maybe.  it needs to be very versatile though, GHC actually does stretch the boundaries of what GNU make can do
21:15:31 <thoughtpolice> maybe add GHC support out of the box. :D -M is your friend
21:15:51 <shachaf> irene-knapp: There was ndm's "shake" thing.
21:15:54 <irene-knapp> I don't actually want this for my own projects - I want it for building ghc itself :)
21:15:58 <irene-knapp> @hackage shake
21:15:58 <lambdabot> http://hackage.haskell.org/package/shake
21:15:58 <shachaf> preflex: seen ndm
21:15:58 <preflex>  ndm was last seen on #haskell 337 days, 10 hours, 16 minutes and 44 seconds ago, saying: if you don't, then there was a parse error
21:16:09 <thoughtpolice> shake is what they use at credit suisse, iirc. they apparently use it for all their own projects with tons of code
21:16:10 <shachaf> irene-knapp: Not released publicly. There was something called "openshake", though.
21:16:14 <irene-knapp> oh hmmm
21:16:17 <irene-knapp> interesting
21:16:18 <JoeyA> Today, I learned about Nix ( http://nixos.org/nix/ ) while trying to install something.  It's a "purely functional package manager", but for some reason they chose to implement it in C++.
21:16:19 <thoughtpolice> but it's not open source. max bolingbroke has a clean room implementation
21:16:25 <irene-knapp> hmmmmm
21:16:27 <thoughtpolice> https://github.com/batterseapower/openshake
21:16:33 <elliott> JoeyA: nix is pretty well-known here.
21:16:36 <irene-knapp> yes, just got there
21:16:44 <thoughtpolice> irene-knapp: be sure to read this - http://community.haskell.org/~ndm/downloads/slides-shake_a_better_make-01_oct_2010.pdf
21:16:53 <irene-knapp> oh, good
21:16:54 <thoughtpolice> that's the only real reference on using shake/its design
21:17:08 <irene-knapp> thanks, hm
21:17:24 <elliott> JoeyA: it's pretty long-lived (circa 2004 or earlier iirc) and quite performance sensitive, dunno that it was obvious that haskell would be good at systems programming like that back then...
21:17:31 <elliott> but i wasn't around, so who knows :)
21:17:45 <shachaf> Why are Credit Suisse and all those companies so secretive about that sort of thing?
21:17:45 <JoeyA> ah
21:17:58 <elliott> shachaf: Build systems are a competitive advantage!
21:18:23 <irene-knapp> holy shit!!!!  Preview.app has a menu option "Import from Jiji..."  (Jiji is the name of my iPhone), and if I go to it, it shows me my entire photo stream!  I had no idea :)
21:18:59 <irene-knapp> hmm
21:19:14 <irene-knapp> now how do I get this PDF on there so I can read it during my commute tomorrow, hmm
21:19:18 <irene-knapp> I think I have to launch iTunes for that
21:19:19 <thoughtpolice> shachaf: i wonder about that too. i'd figure it would be a pretty isolated component worth releasing in the public, but who knows
21:19:27 <JoeyA> Have you tried the Cloud?
21:19:57 <irene-knapp> JoeyA: Not only have I tried the Cloud, I've attempted to do it using computers, too!
21:20:05 <JoeyA> heh
21:20:56 <copumpkin> shachaf: it's standard chartered :P but probably cause they're big companies with lots of bureaucracy and the suits make it difficult to release shit like that
21:21:04 <copumpkin> even if there isn't a huge reason not to
21:21:20 <copumpkin> they probably want to talk to legal teams about licensing and all that crap
21:22:31 <irene-knapp> hm
21:22:32 <irene-knapp> so
21:22:46 <irene-knapp> I got these slides open and it turns out shake is an EDSL.  not sure how I feel about that actually.
21:22:55 <irene-knapp> it seems like a freestanding DSL would be better, doesn't it?
21:23:15 <irene-knapp> easier to deploy (and invoke!!!), for starters
21:24:44 <irene-knapp> also, the GHC build system is multi-pass in the sense that it has rather a lot of situations where, for example
21:25:08 <irene-knapp> executable foo depends on file .foo_depends
21:25:46 <irene-knapp> and the build rule for "foo" says "read .foo_depends into this make instance, then re-attempt the building of foo"
21:26:13 <irene-knapp> and the result of reading .foo_depends changes both the dependencies and the build steps of foo
21:26:43 <irene-knapp> so it looks like shake is just flat-out not suitable for this task
21:27:13 <elliott> irene-knapp: "In the process of replacing the build system, we found out that it would require modifications to the build system, and so gave up"?
21:27:16 <irene-knapp> having it recompile and reinvoke itself is clearly too inefficient, since it would have to do so hundreds of times even in a build where nothing actually changed
21:27:20 <irene-knapp> elliott: haha
21:27:41 <irene-knapp> elliott: no see, what happens is that the build system actually succeeds at doing that the way it's written now :) it's quite clever :)
21:28:18 <irene-knapp> (and it should be noted that before the current GNU-make-based GHC build system existed, they were doing other things which involved spawning new processes and re-parsing the makefiles, and even that was too slow)
21:28:24 <irene-knapp> (so recompiling them would definitely be)
21:28:56 <irene-knapp> but yeah, changing from an EDSL to a freestanding DSL is not a small modification, it's a complete rewrite, to which not even the general ideas that I'm getting out of these slides are really applicable
21:31:24 <irene-knapp> I also actually don't believe the claim therein that a dependency graph can't handle generated files well
21:31:36 <irene-knapp> and most of the other novel features mentioned on the last few slides are kind of "why?"
21:32:01 <irene-knapp> so I do thank the people who pointed me towards it, it was interesting, but.
22:03:15 <thoughtpolice> lear
22:03:30 <thoughtpolice> oops, switched windows somehow
22:03:40 <byorgey> as in, King?
22:26:39 * hackagebot libmpd 0.7.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.7.0 (JoachimFasting)
22:28:23 <bwright> How far does haskell go in terms of metaprogramming? For example in C++ boost::mpl offers a lot of nice features to aid with doing interesting things in that regard.
22:29:41 <leoncame1> bwright: is it what you want ? http://www.haskell.org/haskellwiki/Template_Haskell
22:30:56 <bwright> leoncame1: More of a utility library for metaprogramming.
22:31:38 <bwright> leoncame1: Thanks I will look into it, probably something on cabal.
22:32:34 <mzero> bwright: seems to me most of the stuff in boost::mpl is just bread-n-butter of Haskell programs
22:32:55 <mzero> all the stuff in http://www.boost.org/doc/libs/1_48_0/libs/mpl/doc/tutorial/higher-order.html
22:36:40 * hackagebot zoom-cache 0.8.0.0 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-0.8.0.0 (ConradParker)
22:37:11 <bwright> mzero: How could you approach dimensional analysis with haskell-mp?
22:37:30 <mzero> @hackage dimension
22:37:30 <lambdabot> http://hackage.haskell.org/package/dimension
22:37:55 <mzero> er - that's not it - there is a package for that on Hackage
22:37:57 <mzero> or two
22:38:10 <bwright> Alright cheers
22:41:59 <mzero> @hackage dimensional
22:41:59 <lambdabot> http://hackage.haskell.org/package/dimensional
22:42:19 <mzero> there ya go, @bwright  - same thing as in boost
22:46:40 * hackagebot zoom-cache-pcm 0.2.0.1 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.2.0.1 (ConradParker)
22:47:45 <bwright> mzero: Actually that appears to be more like boost::units an application of boost::mpl for dimensions analysis. But I think I am just going to look into it more and see what I can find out. Thanks for all the help.
22:51:40 * hackagebot zoom-cache-sndfile 0.2.0.2 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-0.2.0.2 (ConradParker)
23:20:55 <ville> http://boost.codepad.org/fPWD8n4s man that yecr... has really difficult style
23:21:06 <ville> !give wunki away
23:21:10 <ville> oops
23:21:14 <ville> wrong channel all together. hah
23:21:31 <ville> off-by-one error as is so common source of bugs in C++.
