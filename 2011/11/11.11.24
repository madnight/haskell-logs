00:02:06 <hpaste> performance_ pasted “need to convert to Int” at http://hpaste.org/54440
00:02:27 <performance_> frerich: could you please look at my hpaste
00:04:38 <augur_> any good haskell vids lately?
00:04:43 <augur_> or FP vids in general?
00:06:02 <frerich> performance_: I think my Haskell-fu is not strong enough to understand what you're trying to do there; I must admit I never used QuickCheck very much. I know that the 'choose' function simply picks a random element given some interval, so I thought your 'chooseOut' function would simply need to generate two intervals, concatenate them, then pick a random element from that.
00:06:28 <elliott> I was hoping Data.DList wouldn't export the constructor :(
00:07:32 <looopy> not necessarily a haskell only question but what are some use cases where you would use a set opposed to a list?
00:07:47 <performance_> frerich: ahh actually, thats exactly what needs to happen.  but for floats making a List is impractical.  so we have to pick from each subrange, with probability proportional to the % of  elements in that range
00:26:19 <elliott> Does haskell-src-meta really have no way to go from a string which has Haskell-plus-more-stuff to an AST and that more-stuff?
00:26:32 <elliott> It seems like you have to isolate the Haskell code completely before using it.
02:07:13 <mr_sleepy> can anyone point me to any good plugin (for any editor, but preferable vim) to edit haskell in console. haskellmode-vim seems to require a gui browser for documentation
02:07:27 <jchia> could someone tell me what's wrong this code involving guards and how to fix it?
02:07:28 <jchia> http://pastebin.com/8Lsax0zM
02:07:30 <mauke> The paste 8Lsax0zM has been copied to http://hpaste.org/54441
02:07:55 <jchia> i get "Not in scope: `rep'"
02:08:13 <jchia> even with the _, I get "Pattern syntax in expression context: _"
02:09:48 <jchia> i suppose this is where i need to understand the limits of pattern matching
02:10:02 <lomeo_> Guards are boolean expressions not patterns. So rep should be defined, EncodedItem should derive Eq.
02:10:45 <jchia> how do i introduce rep in this case?
02:11:29 <jchia> i think it should be enough for a to be Eq, not (EncodedItem a)
02:11:30 <lomeo_> Using pattern matching I guess...
02:11:59 <lomeo_> No. You compare EncodedItem: x == Single ... so EncodedItem should derive Eq also.
02:18:12 <hpaste> joshchia pasted “What's wrong?” at http://hpaste.org/54442
02:18:19 <carpi> is it possible to write fibanocci series using the "iterate" function?
02:18:22 <jchia> ok, what's wrong with this new version?
02:18:58 <jchia> i dropped guards totally and was hoping to use pattern matching
02:19:35 <augur> so
02:19:40 <augur> source for quickcheck
02:19:41 <augur> my god
02:19:45 <augur> spj was right
02:19:48 <augur> i can die now
02:20:04 <carpi> rather what i meant is.. if it is possible to write a function that produces an endless stream of fibonacci numbers using the "iterate" function
02:21:41 <augur> carpi: i dont think so; i dont think theres a unary stepper function for fibs
02:23:24 <Eduard_Munteanu> > iterate (\xs -> (xs !! 0 + xs !! 1) : xs) [1,1]
02:23:25 <lambdabot>   [[1,1],[2,1,1],[3,2,1,1],[5,3,2,1,1],[8,5,3,2,1,1],[13,8,5,3,2,1,1],[21,13,...
02:23:48 <carpi> how do you determine if a certain function can be used to solve a problem? so in this case "iterate" can't be used. But what logical deductions did you make to arrive at that conclusion. And most importantly can it be generalized for any problem?
02:24:16 <carpi> i know this is more of a logic question than a haskel question..
02:24:22 <carpi> but i think its still relevant
02:25:30 <mr_sleepy> i am reformulating my question. what editor do you use for editing haskell in console? i can not get vim to handle indention at all.
02:25:48 <Eduard_Munteanu> carpi: it does give you Fibonacci, maybe not readily available in the form you want.
02:26:17 <mr_sleepy> basically what i want is this: if i am typing in something, for example a guard, i would not need to squeeze tab/indentionKey to write next guard
02:26:31 <mr_sleepy> it should automatically be at the right level
02:26:41 <Eduard_Munteanu> audunska_: what's wrong with QC?
02:26:53 <Eduard_Munteanu> Erm...
02:26:55 <Eduard_Munteanu> augur
02:27:01 <Eduard_Munteanu> Ah, he's gone. :)
02:27:42 <carpi> Eduard_Munteanu: could you please elaborate?
02:28:00 <Eduard_Munteanu> > iterate (\xs -> (xs !! 0 + xs !! 1) : xs) [1,1]   -- I already told you
02:28:01 * hackagebot pointless-haskell 0.0.6 - Pointless Haskell library  http://hackage.haskell.org/package/pointless-haskell-0.0.6 (HugoPacheco)
02:28:01 <lambdabot>   [[1,1],[2,1,1],[3,2,1,1],[5,3,2,1,1],[8,5,3,2,1,1],[13,8,5,3,2,1,1],[21,13,...
02:28:36 <Eduard_Munteanu> If you used a Seq, you could cons at the other end efficiently.
02:29:00 <poindont`> mr_sleepy: would haskell-mode work for you?
02:29:11 <Gothmog_> augur: yes, there is.  carpi: have a look at http://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding
02:29:44 <jchia> take 10 $ map fst $ iterate (\(x1,x2)->(x2, x1+x2)) (1,1)
02:30:08 <Eduard_Munteanu> Erm, good point, that also works, I forgot you end up with a list anyway.
02:30:19 <Eduard_Munteanu> > map fst $ iterate (\(x1,x2)->(x2, x1+x2)) (1,1)
02:30:19 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
02:32:02 <jchia> how do i use lambdabot?
02:32:10 <Eduard_Munteanu> jchia: like I did
02:32:22 <jchia> > take 10 $ map fst $ iterate (\(x1,x2)->(x2, x1+x2)) (1,1)
02:32:23 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
02:32:26 <jchia> got it
02:32:27 <Eduard_Munteanu> Also...
02:32:29 <Eduard_Munteanu> :t map
02:32:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:32:38 <Eduard_Munteanu> @list
02:32:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:33:08 <Eduard_Munteanu> lambdabot also answers private queries.
02:33:53 <jchia> nice. i'm not sure what babel, bf, check, etc means, so i'll just use '>'
02:34:50 <Eduard_Munteanu>  > and :t (you have to use @type in private messages) are the most common anyway.
02:35:22 <Eduard_Munteanu> Some of those aren't serious anyway :)
02:53:42 <Blkt> good day everyone
02:54:55 <Eduard_Munteanu> Blkt: hi
02:56:27 <Blkt> :D
03:03:01 <mr_sleepy> poindont`: do you mean haskell mode for emacs?
03:03:17 <poindont`> yeah
03:03:36 <poindont`> but i noticed i did have to hit tab
03:03:45 <mr_sleepy> i have to look at it... after all emacs has also vi-emulation so i would probably not have to learn that much new things
03:10:47 <erus`> Someone should write an RPG with a realistic economy driven by realistic AI NPCs with needs (hunger) etc.  Not me though.
03:11:27 <Eduard_Munteanu> We have one...
03:14:11 <Eduard_Munteanu> Basically some poor fellows who can code (here's your realistic AI), require to be fed and can't find a job. :)
03:15:24 <poindont`> what is NPC ?
03:15:56 <Eduard_Munteanu> They could work on that RPG, or they could be part of a story like that... you decide :P
03:16:12 <Eduard_Munteanu> poindont`: non-player character
03:17:02 <poindont`> ah :)
03:35:51 <telemachus> This is probably a very stupid question, but is there a rationale for the use of a, b, etc. versus t, t1 etc. in the output of :type <something>?
03:36:16 <Axman6> easier to read? more conventional?
03:36:21 <telemachus> (I'm working through a Haskell book on my own, and just want to make sure I'm understanding the results of doing the chapter exercises.)
03:36:38 <telemachus> Axman6: Ah, ok. I suppose I'm wondering "What's the convention?" then.
03:36:54 <Axman6> starting with a and b, and going from there?
03:38:01 <telemachus> ah, right, but for example if you define "swap (x, y) = (y, x)", ghci types that as "swap :: (t1, t) -> (t, t1)"
03:38:14 <telemachus> I was surprised not to see "(a, b) -> (b, a)"
03:38:31 <telemachus> A few other cases like that where t or t1 pop up instead of a, b, etc.
03:39:10 <adamCS> hey guys, got a quick Q... when I try load in program hugs complains about the type of a function. But if I comment it out and take  the type hugs infers, and replace the old type, it still complains. Any ideas?
03:40:21 <Eduard_Munteanu> You probably shouldn't be using Hugs, it's really old.
03:40:43 <adamCS> It's what has been installed on the machines for us
03:40:46 <Eduard_Munteanu> Anyway, what's the function?
03:41:06 <adamCS> runcount :: (Eq a, Num b) => [a] -> b runcount xs = runcountacc 0 xs  runcountacc :: (Eq a, Num b) => b -> [a] -> b runcountacc n (_:[]) = runcountacc (n+1) [] runcountacc n (x:xs) = runcountacc (n+(if head xs==x then 0 else 1)) xs  runcountacc n _ = n
03:41:13 <adamCS> wow that pasted horribly
03:41:23 <adamCS> runcount :: (Eq a, Num b) => [a] -> b
03:41:27 <adamCS> runcount xs = runcountacc 0 xs
03:41:28 <Eduard_Munteanu> Don't.
03:41:34 <Eduard_Munteanu> @where hpaste
03:41:35 <lambdabot> http://hpaste.org/
03:42:04 <hpaste> adamCS pasted “runcount type prob” at http://hpaste.org/54444
03:43:40 <adamCS> shit gotta go to a lecture now in the next minute or two
03:44:36 <Eduard_Munteanu> adamCS: what's the error?
03:45:01 <hpaste> adamCS pasted “"runcountacc error"” at http://hpaste.org/54445
03:45:06 <adamCS> there
03:47:10 <Eduard_Munteanu> :t let runcountacc :: (Eq a, Num b) => b -> [a] -> b; runcountacc n (_:[]) = runcountacc (n+1) []; runcountacc n (x:xs) = runcountacc (n+(if head xs==x then 0 else 1)) xs ; runcountacc n _ = n; in runcount xs = runcountacc 0 xs
03:47:11 <lambdabot> parse error on input `='
03:47:19 <Eduard_Munteanu> erm
03:47:25 <Eduard_Munteanu> :t let runcountacc :: (Eq a, Num b) => b -> [a] -> b; runcountacc n (_:[]) = runcountacc (n+1) []; runcountacc n (x:xs) = runcountacc (n+(if head xs==x then 0 else 1)) xs ; runcountacc n _ = n; in runcountacc 0 xs
03:47:26 <lambdabot> Not in scope: `xs'
03:48:02 <adamCS> you've lost menow
03:48:19 <adamCS> me now*
03:48:22 <Eduard_Munteanu> :t let runcountacc :: (Eq a, Num b) => b -> [a] -> b; runcountacc n (_:[]) = runcountacc (n+1) []; runcountacc n (x:xs) = runcountacc (n+(if head xs==x then 0 else 1)) xs ; runcountacc n _ = n; in \xs -> runcountacc 0 xs
03:48:23 <lambdabot> forall t a. (Eq a, Num t) => [a] -> t
03:48:57 <adamCS> gotta go
03:49:00 <adamCS> thanks anyway
03:49:41 <Eduard_Munteanu> Dunno why Hugs chokes on it.
04:04:19 <dsx7> hi
04:08:33 <carpi> can someone give me a hint on how to flatten a list without giving away the entire answer? Just a hint..to help me think in the right direction..
04:09:39 <Axman6> (++)
04:09:44 <Axman6> that's my hint
04:14:15 <Axman6> carpi: also, think about it this way: what is your base case? and what is the recursive case going to look like? i'd wager that the base case will match on []
04:14:39 <dsx7> I'm looking for an abstraction that executes a monadic function but then passes the original value to the next function, that is something like passThrough :: (a->m b)->a->m a in "getInput >>= passThrough doLog >>= doSomething" or (=>>) :: m a->(a -> m b)->m a in "getInput =>> doLog >>= doSomething" where doSomething gets a value from getInput. It's trivial to write but it seems that there should be something like this already
04:15:34 <Axman6> i'd just use do notation, it's much clearer
04:15:47 <Axman6> i almost never use (>>=) explicitly
04:16:24 <dsx7> Axman6: sure, I was wondering if there is an alternative to do notation
04:16:51 <hpaste> carpi pasted “mycat” at http://hpaste.org/54447
04:17:05 <carpi> Axman6: i see what your hinting at. Is that it? ^
04:17:43 <chra> passThrough x y = x y >> return y
04:18:33 <Axman6> carpi: looks pretty good to me...
04:18:37 <Axman6> @src concat
04:18:37 <lambdabot> concat = foldr (++) []
04:18:40 <Axman6> bleh
04:18:58 <Axman6> or, concat [] = []; concat (x:xs) = x ++ concat xs
04:19:29 <Axman6> carpi: it's worth convincing yourself that the foldr version is exactly the same
04:19:31 <dsx7> chra: thanks, I think these things are easy to write but I was wondering if there is something "standard" that would do it
04:19:48 <carpi> - ) thx. is there a way to do it in one line using map? the reason i ask is..i recall seeing someone doing it with map. not that it is more efficient..but im jus curious
04:20:48 <Axman6> well, it's not possible with ma[
04:20:51 <Axman6> map*
04:21:15 <Axman6> the result of map f xs will always be a list with the same number of elements as xs
04:21:59 <Axman6> anyone familliar with Yesod?
04:41:14 <aadrake> axman6: I was just reading about it actually, but that's about the extent of my "familiarity."
04:46:19 <donri> qualified operators are kinda annoying; is there a way to import only operators unqualified?
04:47:13 <Axman6> import Foo ((<*>),(<$>))
04:47:42 <donri> of course, but without listing them all?
04:48:42 <Axman6> import Foo >_>
04:48:58 <chra> dsx7: (runKleisli $ Kleisli doLog &&& Kleisli doSomething >>^ snd) works, but probably doesn't look good enough.
04:49:02 <Axman6> operators aren't something special, they're just functions that happen to be infix
04:49:35 <donri> in deed
04:50:54 <dsx7> chra: I was thinking about arrows but didn't come up with a very clean solution, it's cool though :)
04:51:57 <donri> perhaps prelude could benefit from some modularization; import Prelude (); import Prelude.Ops
04:53:53 <cwl> Any modification to a purely functional data structure has at least O(n) complexity, is that right?
04:54:21 <rostayob> cwl: what? no
04:54:26 <mux> good lord no
04:54:27 <cwl> because you nead another copy
04:54:47 <cwl> for example change node of a tree
04:55:04 <dschoepe> cwl: If you, say, change the first element of a list, the rest of the list will be shared.
04:55:58 <cwl> dschoepe, is it necessary to be lazy to share the rest
04:56:23 <rostayob> cwl: no
04:56:27 <rostayob> it's necessary to be immutable
04:57:06 <cwl> I want to learn more about that?
04:57:28 <cwl> any recommended reading matrials
04:57:29 <rostayob> cwl: search about "sharing" in purely functional data structures
04:57:39 <rostayob> cwl: or the book "Purely functional data structures"
04:57:39 <cwl> rostayob, thanks
04:57:44 <geirskjo> cwl: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf
04:57:47 <rostayob> the first chapters talk about that
04:57:56 <rostayob> geirskjo: isnt' that the STM paper?
04:58:05 <cwl> geirskjo, I'm reading the thesis, can't buy the book
04:59:10 <rostayob> cwl: i don't know about the thesis, but the book talks about sharing
04:59:46 <cwl> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf that is the thesis
05:00:22 <cwl> not much about sharing till chapter 6
05:01:29 <rostayob> cwl: in the book it explains that in chapter 2 (i have it here eheh)
05:01:42 <rostayob> i think that the thesis does less preliminar explaining
05:01:47 <rostayob> anyway i'm sure there are other resources
05:01:53 <rostayob> and it's quite a simple concept anyway
05:03:09 <rostayob> cwl: let's say that you have the classic immutable linked list. when you do let xs = x : ys, xs will be simply pointing to ys after the first cell containing x
05:03:26 <rostayob> the same holds for any immutable data structure
05:03:42 <cwl> rostayob, aha
05:03:57 <rostayob> cwl: ?
05:04:01 <cwl> get it
05:04:18 <rostayob> that book explains it better and has nices pictures
05:04:25 <cwl> I thought I must copy the origin one
05:04:27 <chra> dsx7: Found it: getLine >>= liftA2 (*>) doLog doSomething
05:04:42 <rostayob> cwl: well sometimes you do, e.g. when appending something to a list
05:05:19 <rostayob> cwl: http://en.wikipedia.org/wiki/Persistent_data_structure#Linked_lists
05:05:26 <rostayob> this example are taken straight from that book
05:05:51 <cwl> thanks
05:05:57 <dsx7> chra: thanks a lot, this or something along these lines is very interesting
05:15:01 <Chat7293> ur all gay ;)
05:15:41 <Axman6> lololol
05:17:37 <erus`> how can i dump a circular reference to file
05:17:46 <erus`> without making a new datastructure
05:17:47 <donri> i doubt *everyone* in here is a homosexual
05:20:55 <erus`> Are there many homosexual programmers? I havnt heard of any. Though I rarely ask about sexual orientation.
05:21:11 <erus`> It probably a male/female brain thing
05:22:04 <tgeeky_> it's easiest to assume that percentages in the superset population (humans) is the same to a subset (humans * programmers)
05:22:08 <tgeeky_> though that could be wrong
05:23:52 <KaneTW> i don't think there are many programmers who are sociologists
05:23:55 <sebz> Turing?
05:23:55 <Botje> there is no significant correlation between being a programmer and sexuality.
05:24:09 <KaneTW> 1 person of many
05:24:55 <erus`> i thought programmers generally have some similarities in brain type and stuff? tend to be further up the autism scale than the average human?
05:34:14 <mike-burns> Whoa, politically incorrect and outdated backlog.
05:34:19 * mike-burns skips reading it.
05:35:14 <sipa> erus`: i know a few gay programmers
05:35:17 <Botje> leave political correctness for politictians.
05:35:19 <Botje> -c
05:35:25 <sipa> i wouldn't say there's a correlation
05:38:45 <ExFalso> @hoogle t m a -> t m (m a)
05:38:45 <lambdabot> No results found
05:39:09 <Axman6> fmap return?
05:39:30 * Eduard_Munteanu thought of weirder stuff... fmap . duplicate
05:39:32 <Eduard_Munteanu> :)
05:39:49 <Eduard_Munteanu> (arguably that'd be a 'w' :P)
05:40:32 <Eduard_Munteanu> s/.//
05:42:00 <ExFalso> *liftM return
05:42:34 <Axman6> fmap ~= liftM
05:43:07 <ExFalso> according to cat theory, not to haskell :P
05:45:16 <Axman6> well, yes according to Haskell. you'd be doing well to find a Monad that doesn't implement Functor
05:48:29 <erus`> identity monad
05:49:08 <Botje> instance Functor Identity -- Defined in Control.Monad.Identity
05:50:00 <donri> vim snippet to make "gf" work for haskell imports, if anyone is interested: http://paste.pocoo.org/show/512358/
05:56:43 <KitB> Are there *any* 3d libraries that build these days?
05:57:12 <Axman6> HOpenGL?
05:57:18 <HugoDaniel> KitB: lets do some bindings to the doom3 engine ? :)
05:57:44 <KitB> Heh
05:57:48 <KitB> One day
05:57:54 <KitB> When I don't have deadlines to meet
05:58:17 <erus`> does doom3 build on linux?
05:58:32 <cheater> @protobtorpedo
05:58:32 <lambdabot> why haskell over lisp?
06:11:19 <lanjiao> anyone knows if Control.OldException is deprecated? we shouldn't catchDyn anymore?
06:13:27 <int-e> module Control.OldException {-# DEPRECATED "Future versions of base will not support the old exceptions style. Please switch to extensible exceptions." #-} (
06:15:49 <hpaste> yogsototh pasted “project euler 60 bottleneck” at http://hpaste.org/54451
06:17:12 <Botje> yogsototh: 10 ^ (num_of_digits x) * y + x ?
06:18:11 <lanjiao> int-e: so the "extensible exceptions" means Control.Exception here?
06:18:12 <int-e> instead of catchDyn you can simply use catch, after making the type you're interested in an instance of the Exception class
06:18:30 <int-e> (Control.Exception.catch)
06:18:33 <int-e> lanjiao: yes
06:19:39 <Botje> yogsototh: unrelated, and . map p === all p
06:20:40 <yogsototh> Botje: Thanks I'll try that!
06:21:07 <Botje> yogsototh: especially since you can compute the length of each prime once.
06:39:27 <carpi> fib = scanl (+) 1 (1:fib)
06:39:45 <carpi> could someone please tell me whats happeneing there? that is utterly confusing
06:39:46 <carpi> ?
06:39:58 <Botje> ah, that thing. :)
06:40:08 <ion> @src scanl
06:40:08 <lambdabot> scanl f q ls = q : case ls of
06:40:09 <lambdabot>     []   -> []
06:40:09 <lambdabot>     x:xs -> scanl f (f q x) xs
06:40:30 <Botje> carpi: scanl walks across a list, combining each element in turn with an accumulated value
06:40:40 <int-e> carpi: f(n) = 1 + f(0) + f(1) + f(2) + ... + f(n-2)  happens to be true for fibonacci numbers (n > 0)
06:40:43 <Botje> carpi: after each element, scanl emits the accumulated value so far
06:40:45 <Botje> so ..
06:41:01 <Botje> > scanl (+) 1 [1..10]
06:41:02 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56]
06:41:09 <Botje> right?
06:41:19 <ion> > scanl (+) a [b,c,d,e,x,y,z]
06:41:20 <lambdabot>   [a,a + b,a + b + c,a + b + c + d,a + b + c + d + e,a + b + c + d + e + x,a ...
06:41:27 <byorgey> > scanl (+) 1 [1,1,2,3,5,8]
06:41:28 <lambdabot>   [1,2,3,5,8,13,21]
06:41:29 <int-e> > fix ((0:) . scanl (+) 1)
06:41:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:42:09 <carpi> i think i understand scanl..even though that claim is questionable.. but what i don't understand is the (l:fib) at the end of the expression
06:42:28 <carpi> does scanl read from fib as it is creating elements for it?
06:42:38 <ion> yes
06:42:42 <carpi> in other words reading from and writing to fib at the same time?
06:42:44 <ion> And it’s (1:fib), not (l:fib)
06:42:55 <ion> > let ones = 1:ones in ones
06:42:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:43:03 <ion> ones is defined as 1 followed by ones.
06:43:23 <ion> It’s pretty the equivalent thing in your definition of fibs.
06:43:57 <ion> > let xs = 0 : map (+1) xs in xs
06:43:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:44:40 <ion> When map (+1) xs is looking at the first element, it sees a 0 and returns (1:…)
06:44:46 <ion> So xs is (0:1:…)
06:45:20 <ion> When it looks at the second element, it sees the 1 and results in 2.
06:48:33 <carpi> ion: in the end you use "in xs". That is supposed to call the fucntion xs recursively .. yes?
06:49:06 <carpi> no wait.. xs is a list
06:49:31 <ion> > let xs = "o hai" in xs
06:49:32 <lambdabot>   "o hai"
06:49:49 <ion> > let xs = "o hai" ++ xs in xs
06:49:51 <lambdabot>   "o haio haio haio haio haio haio haio haio haio haio haio haio haio haio ha...
06:49:57 <ion> > let xs = "o hai" ++ map succ xs in xs
06:49:58 <lambdabot>   "o haip!ibjq\"jckr#kdls$lemt%mfnu&ngov'ohpw(piqx)qjry*rksz+slt{,tmu|-unv}.v...
06:50:34 <ion> > let xs = 'o' ++ map succ xs in xs
06:50:35 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:50:35 <lambdabot>         against inferred type...
06:50:39 <ion> > let xs = 'o' : map succ xs in xs
06:50:40 <lambdabot>   "opqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\139\140\1...
06:53:09 * hackagebot OpenCL 1.0.2.3 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.2.3 (LuisCabellos)
06:54:12 <whald> recently I saw the announcement for a new package on hackage wich seemed to do roughtly what rrdtool does (handling time series data) -- now I could possibly use it, but I can't remember the name or a phrase to search for. anyone?
06:54:39 <whald> (I'm aware of the rrdtool bindings, but I wanted to look at this one first)
07:00:39 <byorgey> whald: http://hackage.haskell.org/package/zoom-cache ?
07:00:50 <byorgey> whald: there's also http://hackage.haskell.org/package/timeplot
07:02:04 <whald> byorgey: zoom-cache was the one I was thinking of, didn't know of timeplot as of now.
07:02:07 <whald> byorgey: thanks!
07:02:32 <whald> byorgey: can you recommend any of these packages?
07:06:05 <hpaste> joshchia pasted “Is there a cleaner way to write this?” at http://hpaste.org/54454
07:06:30 <jchia> is there a cleaner or more succinct way to write this?
07:06:38 <jchia> http://hpaste.org/54454
07:07:01 <jchia> especially the definition of addItem
07:07:23 <byorgey> whald: no idea, never used any of them
07:08:09 <int-e> > group [1,2,3,1,1,2,3,3,3,3,2,1]
07:08:10 <lambdabot>   [[1],[2],[3],[1,1],[2],[3,3,3,3],[2],[1]]
07:08:43 <whald> byorgey: ok, i'll try out zoom-cache. thanks!
07:08:53 <int-e> > map (\xs -> (length xs, head xs)) $ group [1,2,3,1,1,2,3,3,3,3,2,1]
07:08:54 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(1,2),(4,3),(1,2),(1,1)]
07:09:01 <roconnor> > (\x.0-x) 6
07:09:02 <lambdabot>   <no location info>: parse error on input `.'
07:09:04 <byorgey> jchia: I would write it using 'group'
07:09:09 <roconnor> > (\x -> 0-x) 6
07:09:10 <lambdabot>   -6
07:09:19 <dmos> Is there a recommended way to package/reference tests from Cabal?
07:09:36 <jchia> yeah, i'm doing the question from 99 haskell questions that says not to use group. can i define addItem more succincly?
07:09:48 <byorgey> jchia: something like   map encode . group   where   encode [item] = Single item; encode items@(item:_) = Run (length items) item
07:10:15 <byorgey> jchia: oh.  no, not that I can see
07:10:37 <byorgey> dmos: yes, it has a testing interface
07:10:53 <byorgey> dmos: I'm not sure how it works but you can look it up in the Cabal manual
07:11:09 <dmos> byorgey: thanks, will do.
07:13:05 <jchia> byorgey, do you know why haskell won't let me do this? addItem item l@(Single item:xs) = Run 2 item1:xs
07:13:14 <jchia> sorry i meant addItem item l@(Single item:xs) = Run 2 item:xs
07:13:39 <jchia> that's why i had to use a guard, which makes the definition af addItem rather long
07:13:47 <int-e> jchia: then I would still use  span
07:13:58 <int-e> > span (==2) [2,2,1,2,3,4,5]
07:13:59 <lambdabot>   ([2,2],[1,2,3,4,5])
07:14:16 <carpi> is it possible to set breakpoints on the interpreter/
07:14:17 <carpi> ?
07:14:24 <int-e> jchia: is there a reason why you treat singletons separately?
07:14:47 <int-e> (instead of a run of length 1)
07:15:13 <jchia> int-e: No. Is there a way to combine treatement of Run and Single into one?
07:16:32 <jchia> i want to output (Single x) for a single item and (Run rep x) for a run of multiple items. That's the requirement
07:17:34 <jchia> requirement of question 13 http://haskell.org/haskellwiki/99_questions/11_to_20
07:17:59 <byorgey> jchia: Haskell does not allow non-linear patterns (i.e. patterns with a repeated variable)
07:18:28 <hpaste> i annotated “Is there a cleaner way to write this?” with “Is there a cleaner way to write this? (annotation)” at http://hpaste.org/54454#a54455
07:19:13 <byorgey> jchia: it would be technically possible but somewhat convoluted -- since adding a non-linear pattern would suddenly change the type of the function (requiring an Eq constraint), you'd have to suitably translate patterns with more than two occurrences of the same variable, etc.
07:19:34 <int-e> jchia: I see. Anyway, see the annotation.
07:20:16 <byorgey> int-e: ah, nice
07:20:42 <int-e> jchia: it's not shorter, but it separates the counting from the creation of the list items
07:23:40 <jchia> nice. it is shorter. thanks
07:24:11 <carpi> ion: in your example "let xs = 0:map (+1) xs" what happens first? xs is being initialized to [0] or map being called?
07:24:12 <jchia> shorter by about 2 lines
07:24:41 <int-e> yes, but I also didn't use an extra line for the 'where' or the guard in 'go'.
07:25:00 <int-e> anyway, it's not really important is what I was really trying to say
07:25:00 <roconnor> carpi: it is initalized to 0:THUNK
07:25:25 <carpi> roconnor: meaning it will be calculated later?
07:25:28 <carpi> tak?
07:25:42 <roconnor> yes, THUNK will be refined later, when demanded.
07:25:48 <jchia> int-e,byorgey: if haskell did allow non-linear patterns, the guards would not be necessary
07:26:00 <byorgey> jchia: yes, that's true
07:26:35 <int-e> jchia: what would the precise meaning of those patterns be? Say: f :: (a -> a) -> (a -> a) -> Bool; f h h = True; f _ _ = False?
07:27:39 <jchia> since h is not used on the RHS, it can be treated as _ in this case
07:27:58 <jchia> int-e: that would reduce to f _ _ = True; f _ _ = False
07:28:08 <jchia> sorry
07:28:10 <int-e> jchia: that's not the same, you lost the non-linearity.
07:28:12 <jchia> i take that back
07:28:18 <int-e> (I guess you want to convert them to Eq-based equality tests anyway.)
07:28:53 <jchia> int-e: yeah, if the two arguments are equal, then the first definition is use. otherwise, the second
07:29:09 <jchia> this would imply Eq
07:29:27 <byorgey> int-e: in my hypothetical Haskell-with-non-linear-patterns, that would not type check
07:29:55 <byorgey> because the definition of f  would require it to have type   Eq a => a -> a -> Bool
07:31:01 <int-e> I guess a case can be made that non-linear patterns occur infrequently enough that the benefit of not allowing them -- namely, catching a certain class of unintended parameter name duplication -- outweighs the benefit -- eliminating a few guards.
07:31:32 <jchia> byorgey: agreed. but, this should be ok: f :: Eq (a -> a) => (a -> a) -> (a -> a) -> Bool; f h h = True; f _ _ = False
07:31:37 <jchia> if Eq (a->a) means something
07:32:07 <byorgey> yes
07:32:49 <ddarius> Nonlinear patterns would be a less that great idea.
07:33:32 <rwbarton> it's not as clear as one might think what the semantics of nonlinear patterns would actually be
07:34:02 <byorgey> rwbarton: can you elaborate?
07:34:03 <ddarius> int-e: It's worse than that.  If I'm using them, it's much easier to have a typo that causes me to make something that's supposed to be the same be different, and since it's a binding occurrence there will be no error, than for me to accidentally typo different things into the same which will probably lead to unbound variables.
07:34:17 <rwbarton> for example in f x x (Just a) = x, does the pattern match on Just happen before or after the x's are compared for equality?
07:34:27 <ddarius> rwbarton: After.
07:34:35 <int-e> ddarius: true
07:35:02 <byorgey> ah, and also, which x is returned?
07:35:13 <byorgey> just because they compare as (==) doesn't mean they are identical
07:35:17 <rwbarton> yes, good point
07:35:30 <int-e> ddarius: clearly I was arguing as somebody who would not want to use the feature even if it was implemented :)
07:35:34 <dmos> Is depending on newer Cabal versions something not recommended for some reason (obviously only if I need a feature of newer versions)?
07:35:38 <dmos> Reason for asking is that the cabal init sets cabal-version at >= 1.2 and I don't usually see higher than 1.6?
07:35:48 <nejucomo> What should I consider when choosing between foldl or foldr?
07:35:57 <byorgey> dmos: no, depending on newer Cabal versions is fine
07:36:06 <ddarius> byorgey wins.
07:36:08 <dmos> byorgey: ok. Thanks.
07:36:16 <byorgey> dmos: the HEAD version of cabal init sets cabal-version much higher.
07:36:35 <dmos> byorgey: so it will change with the next release, presumably?
07:36:39 <byorgey> dmos: yes
07:37:03 <dmos> byorgey: ok. Thanks.
07:37:19 <ddarius> f x@y y@z = x
07:37:57 <byorgey> nejucomo: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/94019
07:38:34 <nejucomo> thanks.
07:38:46 <ddarius> f x@(_:x@_) = Infinite
07:39:25 <ddarius> f xs@(_:xs) = Infinite
07:42:32 <ddarius> f xs@(reverse -> xs) = IsPalindrome
07:42:48 * ddarius is starting to think nonlinear patterns would be fun.
07:44:22 <erus`> would be cool if haskell could solve equations :)
07:45:32 * applicative wonders, has anyone noticed that oleg is wonderful?
07:46:51 * applicative aspires to cook up a problem for him to solve on -cafe
07:48:22 <wlangstroth> applicative: has anyone noticed? http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
07:49:12 <rwbarton> > let isPalindrome xs@((== xs) . reverse -> True) = True; isPalindrome _ = False in isPalindrome "abba"
07:49:14 <lambdabot>   True
07:49:17 <applicative> wlangstroth , I'll take three, thanks...
07:49:31 <rwbarton> > let isPalindrome xs@(reverse -> ((== xs) -> True)) = True; isPalindrome _ = False in isPalindrome "abba"
07:49:33 <lambdabot>   True
07:52:08 <ddarius> byorgey: That thread is pretty crappy, and Stack_overflow on the wiki already has a one-line summary as well as much more detail if desired.
07:52:38 <ddarius> @where stackoverflow
07:52:39 <lambdabot> I know nothing about stackoverflow.
07:56:33 <applicative> > (zipWith (==) <*> reverse)  "hannah"
07:56:34 <lambdabot>   [True,True,True,True,True,True]
07:56:45 <applicative> > and $ (zipWith (==) <*> reverse)  "hannah"
07:56:46 <lambdabot>   True
07:57:15 <copumpkin> ((==) <*> reverse) "hannah"
07:57:26 <donri> > and $ (zipWith (==) <*> reverse)  "hanna"
07:57:27 <lambdabot>   False
07:58:29 <ddarius> >ap(==)reverse"hannah"
07:58:33 <ddarius> > ap(==)reverse"hannah"
07:58:34 <lambdabot>   True
07:59:36 <applicative> hm, guess if you start out zipping you end zipping.
08:00:24 <Saizan> @wiki StackOverflow
08:00:24 <lambdabot> http://www.haskell.org/haskellwiki/StackOverflow
08:01:06 <applicative> i see, I'm doing an equality test by hand, for each letter, rather than invoking equality for String.
08:01:22 <applicative> which fits with my starting point
08:02:02 <Saizan> @wiki Stack overflow
08:02:02 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
08:02:18 <Saizan> i feel like there should be some redirects
08:06:20 <applicative> does @wiki not know anything, except what a wiki page would be called if it existed?
08:08:01 <applicative> > let wiki x = "http://www.haskell.org/haskellwiki/" ++ x in wiki "StACkOverFloW"
08:08:03 <lambdabot>   "http://www.haskell.org/haskellwiki/StACkOverFloW"
08:08:26 <zzattack> can we declare variables in the interpreter command window?
08:08:47 <Botje> let foo = 5
08:08:58 <Botje> functions can occasionally prove a problem
08:09:06 <zzattack> ah, thank you
08:09:21 <zzattack> foo needs to start with lowercase f?
08:09:22 <saati> > map (1) [1,2]
08:09:24 <lambdabot>   [1,1]
08:09:27 <applicative> what is the problem with functions?
08:09:32 <Saizan> zzattack: yes
08:09:34 <saati> why does this work in lambdabot?
08:09:41 <saati> in ghci it's a type error
08:09:58 <Saizan> saati: because of the Num a => Num (r -> a) instance that's imported from some library
08:09:59 <applicative> saati: there is secret sauce
08:10:31 <byorgey> saati: in lambdabot, 1 can act like the function (const 1)
08:10:35 <saati> Saizan: and it converts it into const?
08:10:45 <byorgey> > 1 2
08:10:46 <lambdabot>   1
08:10:51 <byorgey> > 1 "hello"
08:10:52 <lambdabot>   1
08:11:14 <applicative> > zipWith ($) [1,2,3] [4,5,6]
08:11:15 <lambdabot>   [1,2,3]
08:12:14 <applicative> > > [1,2,3] <*> [4,5,6]
08:12:15 <lambdabot>   <no location info>: parse error on input `>'
08:12:18 <applicative> >  [1,2,3] <*> [4,5,6]
08:12:19 <lambdabot>   [1,1,1,2,2,2,3,3,3]
08:12:20 <telemachus> Does anyone happen to know if the darcs wiki being down is a recent thing? (I'm looking for a darcs binary for OSX.)
08:14:00 <applicative> telemachus: is anyone away in #darcs?
08:14:17 <telemachus> applicative: I didn't try honestly, since I was already here.
08:14:21 <telemachus> But yes, that's smarter.
08:14:24 * applicative thinks they;re asleep
08:14:52 <erus`> your face when #darcs? is actually a channel...
08:15:12 <telemachus> erus`: ?
08:15:22 <telemachus> applicative: Thanks, I'm asking there.
08:16:44 <carpi> is there a way to get the source of a function in ghci?
08:18:08 <applicative> carpi, it would be very helpful wouldn't it?
08:18:45 <carpi> lol.. yes ofcourse.. its just that i saw people here doing @src name of function and getting source of a function. i tried it in ghci but it don't work
08:18:51 <dumael> carpi: :list <name>
08:19:15 <byorgey> that doesn't work for things in the Prelude though
08:19:33 <applicative> cannot list source code for foldr: module GHC.Base is not interpreted
08:19:39 <byorgey> carpi: the short answer is, no, there isn't
08:19:40 <carpi> byorgey: jus found out the hard way
08:21:59 <applicative> cannot list source code for |>: module Data.Sequence is not interpreted
08:22:11 <ddarius> :list is a debugging command.
08:25:11 <carpi> is it possible to degug an expression right in the ghci prompt?
08:25:20 <carpi> s/degug/debug
08:26:36 <opqdonut> yes
08:26:39 <opqdonut> :trace expr
08:26:41 <byorgey> carpi: sometimes with particularly ornery expressions I wish I could degug them right in the kisser
08:27:06 <carpi> opqdonut: doesn't work . tried that
08:27:15 <opqdonut> carpi: you need to set breakpoints, of course
08:27:29 <carpi> how can you set breakpoints for an expression you haven't entered yet?
08:27:40 <ion> Wow. bindings-DSL is very nice.
08:28:26 <applicative> it occurs to me that if we can make types and classes inside ghci, it will be easy to write quasi scripts with a much more imperative flavor than we are accustomed to
08:28:38 <ddarius> applicative: ?
08:29:22 <applicative> i'm just think we need only devise a way to feed them to ghci without seeming to open it. Of course you could do that now
08:29:24 <opqdonut> carpi: hmm, well one option is to use ":set -fbreak-on-error" and stick undefined somewhere in the expr
08:29:59 <carpi> opqdonut: you mean "error"
08:30:04 <opqdonut> or you could factor the expression into a couple of functions, define them, and set breakpoints
08:30:15 <opqdonut> @src undefined
08:30:15 <lambdabot> undefined =  error "Prelude.undefined"
08:30:15 <applicative> it would look a little like simple minded  ML or something.
08:30:19 <opqdonut> same thing
08:30:36 <parcs> applicative: you can define types in ghci 7.4
08:30:49 <parcs> classes i'm not sure
08:30:51 * parcs checks
08:31:15 <opqdonut> ah, right, you can't set breakpoints on things defined in the repl
08:31:18 <opqdonut> that's a shame
08:32:00 <parcs> cool, you can define classes in ghci too
08:32:05 <applicative> parcs, I was thinking, if you think of the succession of things you might type inside ghci, it would look like a simple ML script, with lets, top level requests for evaluation, etc
08:33:02 <dmos> Which QuickCheck is in general preferable, 1 or 2?
08:34:06 * applicative schemes to produce a depraved `runghci` to read your 'script' 
08:34:44 <statusfailed> Is there a function f :: Int -> [a] -> [[a]] to split a list into chunks?
08:34:46 <statusfailed> I tried hoogling
08:35:42 <Saizan> there's the split package
08:35:57 <applicative> there are many such functions around, often called chunk.  http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/src/Data-List-Split-Internals.html#splitEvery
08:36:03 <statusfailed> Saizan: nice, cheers
08:36:07 <statusfailed> applicative: also cheers :)
08:37:37 <statusfailed> How come it doesn't show up in hoogle?
08:40:09 <applicative> statusfailed: I don't know why the web hoogle doesn't know about Data.List.Split, it shows the Data.Text chunky stuff
08:40:41 <Saizan> hoogle doesn't index all of hackage
08:41:37 * applicative nominates Data.List.Split for the Haskell platform
08:41:44 <nejucomo> Is there no association list insert?  A hoogle for this doesn't reveal any: k -> v -> [(k, v)] -> [(k, v)]
08:42:26 <ddarius> :t curry (:)
08:42:26 <lambdabot> forall a b. a -> b -> [(a, b)] -> [(a, b)]
08:42:27 <applicative> > (1,'a') : [(1,'b')]
08:42:28 <lambdabot>   [(1,'a'),(1,'b')]
08:44:36 <nejucomo> ddarius: I require at most 0 or 1 elements with a given k value.
08:45:37 <ddarius> nejucomo: Maybe you should use a Map.
08:46:56 <nejucomo> Yeah, I suppose so.
08:48:44 <statusfailed> applicative: Second that motion :)
08:48:47 <statusfailed> belatedly~
09:00:46 <fff> hi
09:04:01 <byorgey> hi fff
09:04:11 <fff> hi
09:04:17 <fff> how r u?
09:04:26 <fff> where r u from?
09:04:30 <monochrom> hmm, is fff very loud? :)
09:04:53 <fff> hi
09:12:43 <monochrom> eh? where is haskell weekly news?
09:20:52 * monochrom missed the opportunity to comment on the foldr/foldl/foldl' thread in haskell-cafe.
09:20:58 <carpi> in the signature of a function if I see something like a1, a2, a3 .. what is that supposed to mean? I understand what 'a' might stand for..
09:23:57 <Saizan> 'a1' as a whole is just an identifier, in a type it'll be (the name of) a type variable
09:24:23 <carpi> findkey :: Eq a => a -> [(a, a1)] -> Maybe a1
09:24:29 <carpi> what coudl that mean ? ^^^^
09:24:35 <jessopher_> sub a1 for b
09:24:41 <jessopher_> same semantics
09:25:04 <monochrom> I understand asking "when to use foldl vs foldl'?"; they give the same answer, so you legitimately wonder why there are two of them. I don't understand "when to use foldr vs foldl or foldl'?"; they don't even give the same answer finite lists, they don't even have the same type, so which answer do you want? do you also ask "should I reverse my list or not?"? do you also ask "when do I read input vs write output?"? dude, are y
09:25:04 <monochrom> ou doing intelligent design or random mutation?
09:26:30 <cheater_> monochrom is riding the red wave
09:26:38 <monochrom> sorry?
09:26:46 <cheater_> euphemism for pms
09:27:00 <monochrom> no, just a rant.
09:27:09 <cheater_> got carried away?
09:27:13 <cheater_> by the red monster?
09:27:14 <cheater_> :)
09:27:23 <saati> carpi: a and a1 are two unrelated type variables
09:27:46 <monochrom> just catching up on haskell-cafe traffic
09:28:20 <carpi> so findkey :: Eq a => a -> [(a, a1)] -> Maybe a1 could be replaced with "findkey :: Eq a => a -> [(a, b)] -> Maybe b" ???
09:28:30 <jessopher_> yep
09:28:38 <saati> carpi: maybe you understand better if you see it as Eq keytype => keytype -> [(keytype, valtype)] -> Maybe valtype
09:29:37 <carpi> ah got it.. its just that sometimes, ghci uses a1 and b interchangeably.. thats what led to the confusion
09:30:59 <jessopher_> it seems to be a pretty common confusion too
09:32:00 <Saizan> the names of type variables don't matter so they can be replaced with other names if convenient
09:32:37 <jessopher_> they dont matter to the compiler anyway :P
09:33:31 * ddarius doesn't find that too be a common confusion.
09:33:51 <jessopher_> its a question that has been asked in #haskell 3 times in the last 24 hours
09:34:08 <jessopher_> that i was here for..
09:34:32 <ddarius> Note that the logic is identical to the value level.  One doesn't expect x and x1 to be related as far as the compiler is concerned.
09:34:53 <ddarius> jessopher_: Was it asked by carpi each of those times?
09:35:01 <jessopher_> hah, no
09:35:20 <Saizan> maybe there's some course/teaching material floating around that can be read as implying otherwise
09:35:42 <monochrom> it was asked by car1, carpi, and car-1 respectively. :)
09:36:03 <jessopher_> actually it wasnt the same question, but they were all related to 'what is the reason for the compiler using inconsistent type variable names'
09:37:43 <jessopher_> i think its some kind of repetitive stress disorder caused by looking at haskell type signatures all day
09:37:54 <dmos> Does anyone else have the problem that cabal install --only-dependencies doesn't pick up --enable-tests?
09:38:34 <leoncamel> hey, for a Applicative typeclass, how can I prounance (<*>) ?
09:38:44 <mauke> you can't
09:38:50 <applicative> 'ap'
09:39:04 <monochrom> less than asterisk greater than
09:39:33 <monochrom> glorified star
09:39:39 <applicative> to pronounce <*> just say "applied to" but in an elevated tone of voice
09:40:04 <leoncamel> applicative: Oh. thanks ...
09:40:41 <ddarius> applicative: Elevated a perfect fifth?
09:41:08 <geheimdienst> leoncamel: i just make up my own words. i guess i'd say "splat" for <*>
09:41:28 <applicative> I was thinking it depended on the applicative instance.  Should be distinctly shrill for IO
09:43:55 <leoncamel> geheimdienst: cool .. ;)
09:44:28 <jessopher_> i just type quietly :P
09:44:29 <geheimdienst> leoncamel: see this for inspiration http://poetry.about.com/od/poetryplay/l/blwakawaka.htm
09:45:06 <leoncamel> geheimdienst: how do you pronounce <* and *> ?
09:45:33 <TheRubberTurkey> I don't
09:45:46 <mauke> <* is herp and *> is derp. <*> is herpderp.
09:46:01 <TheRubberTurkey> good convention
09:46:23 <geheimdienst> squaggle, squoggle?
09:47:18 * jessopher_ wants to train a text to speech engine for programming
09:47:20 <geheimdienst> TheRubberTurkey: i have seldom, if anytime, heard of rubber turkeys pronouncing anything much at all
09:47:31 <TheRubberTurkey> well, that's an explanation
09:47:37 <TheRubberTurkey> anyway, I should go catch a plane
09:47:51 <jessopher_> and then arrive at conversational ascii
09:57:25 <Philonous> Just use applicative brackets and pretend there is no operator
09:58:08 <geheimdienst> Philonous: do you have a link about that style?
09:58:16 <Philonous> http://personal.cis.strath.ac.uk/~conor/pub/she/idiom.html
09:59:04 <geheimdienst> thanks
10:00:19 <hpaste> applicative pasted “haskellscript” at http://hpaste.org/54457
10:00:53 <applicative> the error messages from my new 'ghciscript' interpreter are great, if I say so myself
10:00:54 <statusfailed> What's a good haskell IDE?/
10:01:11 <statusfailed> or: is it just easier to use vim :D
10:01:32 <danm_> I've just been using emacs
10:01:39 <haole> emacs
10:01:41 <geheimdienst> statusfailed: i'm fairly happy with vim. be sure to set up haskellmode, it really helps
10:01:46 <geheimdienst> @google haskellmode vim
10:01:47 <lambdabot> http://projects.haskell.org/haskellmode-vim/
10:01:48 <lambdabot> Title: Haskell mode for Vim
10:01:56 * applicative uses textmate and nano
10:02:02 <statusfailed> hawt
10:02:05 <statusfailed> investigating
10:02:10 <statusfailed> (haskellmode...)
10:02:14 <haole> nano? oh well...
10:02:14 <leoncamel> emacs on Mac...
10:02:16 <statusfailed> hahah
10:02:28 <statusfailed> I didn't mean to start the editor wars again
10:02:30 <geheimdienst> applicative: ;) what does ghciscript do? except offer bright friendly error messages?
10:03:29 <hpaste> applicative annotated “haskellscript” with “haskellscript (annotation)” at http://hpaste.org/54457#a54458
10:03:39 <applicative> geheimdienst: here's my script
10:03:42 <applicative> ^^^^
10:04:30 <applicative> once I get ghc 7.4 my new ghciscript will also allow type definitions!
10:05:18 <applicative> geheimdienst: the possibilities for chaos are *endless*
10:05:42 <applicative> it does everything you want, and *then* tells you the errors
10:06:10 <geheimdienst> oh i see. that kind of thing might be handy for sample code you copy-paste from haddock. just throw it in and see the result. no need to write it to a file, put in "main = do print", fiddle with the indentation, write it to a temp file ...
10:06:47 <hpaste> applicative annotated “haskellscript” with “haskellscript (annotation) (annotation)” at http://hpaste.org/54457#a54459
10:07:10 <applicative> geheimdienst: here's my compiler source :)  ^^^
10:08:43 <geheimdienst> applicative: oh thanks
10:08:46 <poindont`> question, i want intersperse 'a' "a" to return nothing , should i be using maybe monad ?
10:08:52 <applicative> sorry, it's in a mixed state.  It was pretending to read a file a minute ago, now it's already reading, them. development is so fast in haskell
10:10:36 <applicative> poindont`: so that intersperse only works for things with two or more elements?
10:12:00 <poindont`> well i am using it as , map (intersperse l) ["bc","cb"]
10:12:04 <geheimdienst> poindont`: i don't think you'll need the maybe monad (except possibly as a learning exercise). you can just use pattern matching
10:12:44 * ski wonders what poindont` is trying to do
10:13:11 <poindont`> trying to make all aragements of list
10:13:37 <ski> > permutations "abc"  -- like this ?
10:13:38 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
10:13:54 <poindont`> damn yes
10:14:20 <poindont`> any way , i need to know how to do this too
10:14:22 <ski> i don't think you want anything like `intersperse' at all, then
10:14:55 <ski> `intersperse x xs' will insert `x' between every two adjacent pairs of elements in `xs'
10:15:05 <byorgey> > intersperse 'a' "bc"  -- definitely doesn't help generate permutations
10:15:06 <lambdabot>   "bac"
10:15:19 <byorgey> oh! well, it does in the case of n = 2 =)
10:15:33 <byorgey> > intersperse 'a' "bcde"  -- this time I mean it
10:15:34 <lambdabot>   "bacadae"
10:16:10 <Rotaerk> byorgey, eh? how does n=2 matter?
10:16:18 <Rotaerk> those aren't the permutations of "bc"...
10:16:34 <poindont`> well i map intersperse onto list of subsequent elements
10:16:35 <byorgey> Rotaerk: well, no, you're right, it doesn't help
10:17:00 <byorgey> it just wasn't as immediately obvious that it doesn't help as I thought it was going to be
10:17:11 <byorgey> (I was confused and thought intersperse 'a' "bc" == "abaca"
10:17:14 <Rotaerk> map (intersperse l) . permutations
10:17:26 <hpaste> ponidont pasted “maybe?” at http://hpaste.org/54461
10:17:38 <ski> poindont` : each permutation should mention each original element just once. mapping `intersperse' like that will in the general case duplicate elements in each "permutation", so it doesn't work
10:19:18 <ski> poindont` : what is the expected permutations list of `"aa"' ?
10:19:34 <poindont`> [aa]
10:19:35 <Lycurgus> HP still hasn't updated but at least they slipped explicitly.
10:19:52 <poindont`> ['aa]
10:19:54 <Lycurgus> is there a competitive packaging?
10:19:59 <ski> poindont` : i'm assuming you mean `["aa"]', there, which is just one element
10:20:05 <ski> > permutations "aa"
10:20:07 <poindont`> yeah
10:20:07 <lambdabot>   ["aa","aa"]
10:20:29 <ski> so, this is partly a question of definition
10:20:48 <poindont`> i guess , one could just call permutations and the nub it
10:21:13 <ski> do just just want all possible rearrangements of the elements, not caring about whether any of them are equal to others or not ?
10:21:31 <ski> or do you want to not get "duplicate permutations" ?
10:21:34 <poindont`> i dont want duplicates
10:21:54 <sipa> is sorting and removing duplicates not faster than nubbing?
10:22:04 <byorgey> you can do that by generating all and then nubbing.  But doing it efficiently is tricky.
10:22:18 <byorgey> sipa: it is faster.  But it is still way slower than not generating duplicates in the first place.
10:22:31 <sipa> byorgey: good point
10:22:32 <poindont`> yeah , since permutations "aaaaaaaaaaa" should be pretty huge i guess
10:22:35 <byorgey> > length $ permutations "aaaaaaaaaa"
10:22:37 <lambdabot>   3628800
10:22:43 <poindont`> ouch
10:23:17 <byorgey> poindont`: for fast generation of permutations with no duplicates, see http://hackage.haskell.org/package/multiset%2Dcomb
10:24:49 <poindont`> i see
10:25:26 <ski> poindont` : btw, are you required to have any specific type signature for your permutations-generating function ?
10:25:57 <poindont`> no not really
10:26:31 <poindont`> well as long as it works with list of elements and generates unique permutations
10:26:31 <ski> ok. but you're required to not yield duplicates ?
10:26:44 <poindont`> yeah
10:27:15 <poindont`> problem is these permutations grow too large to allow duplicates
10:27:33 <ski> i'm not sure what you mean by that
10:27:47 <byorgey> poindont`: is this for an assignment? Or just something you are trying to accomplish?
10:29:10 <poindont`> I was just writing it as a means of learning the language
10:30:08 <byorgey> poindont`: OK. In that case I suggest that you focus on writing a simple permutations function assuming all list elements are distinct, and don't worry about duplicates.
10:30:36 <byorgey> properly handling duplicates is quite nontrivial.
10:30:48 <poindont`> k, yeah multiset seems to be tough :)
10:32:20 <periodic> I just saw something in some code that I haven't seen before, a type synonym in an instance declaration.
10:32:37 <periodic> Is that different from a regular type synonym?  Does it have special scoping or something?
10:33:10 <litb> hello ALL folk
10:33:38 <litb> can you please explain haskell. in one word
10:33:50 <dbelange_> useless
10:34:00 <jmcarthur> haskell
10:34:15 <sipa> harmless
10:34:46 <dbelange_> Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz
10:35:22 <jmcarthur> nonmammalian
10:35:46 <parcs> can you please explain the purpose of your request. in one word
10:35:47 <periodic> unexplainable
10:36:01 <jmcarthur> troll
10:36:09 <jmcarthur> :)
10:36:14 <byorgey> combinatypabstractual
10:37:08 <periodic> I use Haskell to troll my coworkers and collaborators all the time.
10:37:12 <periodic> It's great for that.
10:37:17 <byorgey> periodic: it is not different, it is equivalent to the same instance with the type synonym expanded out
10:37:22 * ski . o O ( "Constantinopolitanischerdudelsackpfeifenmachergesellschaft !" )
10:37:28 <byorgey> periodic: however, to be accepted you must turn on the TypeSynonymInstances flag
10:37:42 <periodic> Whenever they bring up an issue or an interesting problem, just explain how much easier it would be to do in Haskell.
10:37:46 <ion> Yliesierikoisapulaisvaravaurioraivausvuorovarausratkaisupäällikkö
10:38:17 <periodic> byorgey: So does that type synonym bleed out elsewhere, or is it just handy for declaring types within that instance declaration?
10:38:38 <periodic> byorgey: wouldn't make much sense since type synonyms from different instances would overlap.
10:38:39 <byorgey> periodic: ohhhhh, wait, I think I misunderstood you
10:38:42 <periodic> must be scoped.
10:38:57 <byorgey> periodic: you mean something like   instance Foo Blah where  type Something Blah = ...
10:39:00 <byorgey> ?
10:39:07 <periodic> instance Class Type where { type Foo = Bar; ... }
10:39:08 <periodic> yeah
10:39:20 <byorgey> periodic: ok, I thought you meant  instance Class Synonym where ...
10:39:33 <byorgey> periodic: what you were actually asking about is called an "associated type"
10:39:54 <periodic> ah-ha!  Not having a name for it was making google less than helpful.
10:40:04 <byorgey> periodic: also google for "type families
10:40:09 <ski> "
10:40:13 <litb> parcs: i wanted to deduce the kind of haskell use
10:40:16 <byorgey> ski++
10:40:34 <periodic> thanks, byorgey.  I'll look up the docs.
10:40:35 <litb> s,$,},  s,^,{,
10:40:53 * ski wonders whether the key with `"' on it is beside the return key, on byorgey's keyboard
10:41:04 <ion> “”
10:41:12 <byorgey> ski: how did you know?
10:41:23 <litb> because the use of some language is based on the fanboi principle
10:41:38 <litb> but as i found now, the use of haskell seems to be real
10:41:43 <byorgey> ski: though in practice I think what actually happened is that my finger did not fully depress the " key
10:41:53 <byorgey> but my other finger was already on its way to hitting Return
10:42:05 <hpaste> tgeeky pasted “example streams” at http://hpaste.org/54462
10:42:09 <litb> classic race condition
10:42:49 <ski> byorgey : yesterday i modified a keymap file for a C64 emulator, modifying (what i assume to be) the `"' from being beside the return key, into being on the `2' key
10:45:14 <parcs> every language has fanboys
10:45:29 <ski> byorgey : hm, so is that an US layout, or an UK layout, or what ?
10:45:43 <_Mikey> :t vertices
10:45:44 <lambdabot> Graph -> [Vertex]
10:46:18 <byorgey> ski: US
10:46:27 <ski> ty
10:46:54 <byorgey> middle row goes ...jkl[;/:]['/"]Enter
10:48:06 <ski> ty
10:49:15 <periodic> Hmmmm... so if I have a sum type of two record types with different fields, I get an exception if I use the wrong field accessor on an a variable of other type.  Is it common practice to not do that and just have another layer of data types?
10:49:43 <periodic> e.g I could have data Foo = Bar { bar :: String} | Baz { baz :: Integer }
10:49:45 <ski> (so it appears to be the same as what the original keymap file expected; though, perversely not, not what actually resulted, due to an incompatible keymatrix version inside the rom images of the emulator)
10:50:05 <periodic> should I instead have Foo = BarType Bar | BazType Baz and then make Bar and Baz their own data types?  Seems safer.
10:50:09 <periodic> but more wordy.
10:51:00 <ski> typically i mostly use record syntax with at most one data constructor, yes
10:51:10 <hpaste> tgeeky annotated “example streams” with “example streams (annotation)” at http://hpaste.org/54462#a54463
10:51:42 <periodic> Same here.  Just wondering what was considered best practice by those wiser than me.
10:53:47 <ski> if you have lots of fields, you can match on `foo @ Bar {}' and then use `bar foo',`foo {bar = ...}'
10:54:27 <ski> (if you have any concrete code you're wondering about, maybe we could give more concrete advice)
11:01:20 <periodic> ski: Huh, I didn't realize you could pattern match on a set of empty fields.  Makes sense that 0 is a valid number of fields.
11:02:02 <periodic> ski: nothing really in particularly.  Just curious after I realized I could remove a layer of data types by combining the record types directly, but I don't like the way that opens the code up to exceptions.
11:02:23 <carpi> is there a way to make new types in GHCi?
11:02:36 <jmcarthur> carpi: not yet. the next version of ghc will allow it
11:03:09 <jmcarthur> carpi: the only way to do it right now is to write the type defs into a file and load that into ghci
11:03:10 <ski> periodic : it might be nicer (conceptually) to match on `Bar {..}' instead of `Bar {}', but the former requires the `RecordWildCards' extension
11:03:11 <carpi> jmcarthur: thankx.. been scratching my head over parse errors whenever i tried making new types
11:08:46 <alistra> anybody knows how to mix the - and the @ in makefile?
11:10:28 <sbi> alistra, what's the problem?
11:10:40 <sbi> - @ is fine as far as i remember
11:10:45 <alistra> ok
11:10:49 <sbi> -@
11:11:42 <alistra> it still prints out errors :/
11:12:05 <alistra> @ mutes the calls, - continues after an error
11:12:14 <alistra> rm: cannot remove `thesis.log': No such file or directory
11:12:23 <cedricshock> If a function sometimes evaluates to bottom for a specific input, do the haskell semantics require that it always evaluate to bottom for that input?
11:12:24 <alistra> still printed, should i just 2>/dev/null
11:12:50 <monochrom> usually you use rm -f
11:13:01 <Philonous> cedricshock:  Yes
11:13:32 <hpaste> applicative pasted “debauchery improved slightly” at http://hpaste.org/54464
11:14:16 <ski> cedricshock : however, see imprecise exceptions
11:14:23 <hpaste> applicative annotated “debauchery improved slightly” with “debauchery improved slightly (annotation)” at http://hpaste.org/54464#a54465
11:14:52 <alistra> monochrom++
11:15:15 <hpaste> applicative annotated “debauchery improved slightly” with “debauchery improved slightly (annotation) (annotation)” at http://hpaste.org/54464#a54466
11:16:04 * applicative is mutating variables wildly
11:17:12 <cedricshock> Hmm. It seems like it should be possible to have a library in which a side effect is invoked, and the result of the side effect is returned as a pure value without violating the semantics of haskell, because, since the value hasn't been evaluated yet it's meaning is undetermined, and examining the value has no side effects of its own, but must block until the value exists.
11:19:42 * applicative is dancing with naked expressions at the top level
11:20:39 * ski wonders whether cedricshock is thinking about using foreign functions
11:20:56 * tgeeky suggests applicative put some clothes on
11:21:14 * ski imagines clothed expressions
11:21:40 <tgeeky> <john madden voice> You see, Monads are like sweaters. (circles part of the field)
11:22:06 <monochrom> monads are like nike. "just do it"
11:22:29 <cedricshock> Nope, I'm thinking about whether a sort of trap-door MVar would be possible, where checking the result has no side effects and the MVar can only be set once so it can be treated as pure and lazy (without resorting to unsafePerformIO)
11:23:31 * applicative decides that, in his new 'ghciscript' language, Data.IORef is *always* in scope; all its exports are reserved words.
11:23:53 <jmcarthur> cedricshock: IVar
11:23:56 <ski> cedricshock : so, sortof like `IVar's ?
11:25:04 <jmcarthur> cedricshock: search hackage for ivar, or see my sink package for another kind of interface to basically the same thing
11:25:56 <cedricshock> Yep, just like that, except the value should be able to pop out as "a" instead of "IO (a)"
11:29:46 <ski> blocking until the `Ivar' was filled ?
11:30:16 <cedricshock> Yep, thus possibly being bottom.
11:31:07 <jmcarthur> cedricshock: newSink :: IO (Sink a, a); writeSink :: Sink a -> a -> IO ()
11:31:13 <ski> cedricshock : sounds like futures in Alice ML (and Oz) <http://www.ps.uni-saarland.de/alice/manual/futures.html>. also see CTM about declarative concurrency and dataflow variables
11:31:17 <ski> @where CTM
11:31:18 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
11:31:39 <jmcarthur> cedricshock: the result of newSink gives you a sink (for writing) and a pure value (for reading)
11:31:54 <cedricshock> I guess I'm just imagining the side effects being in the wrong place. It's not at the point that the data is read that the side effect exists, it's at the point it is created.
11:32:04 <jmcarthur> cedricshock: sink differs from most ivars in that reading an unwritten value immediately gives you _|_ instead of blocking until some other thread writes it
11:32:18 <jmcarthur> cedricshock: right. that's why no IO is needed to read the value
11:32:32 <ski> (see <http://www.ps.uni-saarland.de/alice/manual/library/promise.html> for details on how to manage those, cf. with jmcarthur `newSink' and `writeSink' operations)
11:32:45 <cedricshock> And why you can't create a pure version of it without getting wrapped up in a monad.
11:32:54 <jmcarthur> huh?
11:33:06 <jmcarthur> what's "wrapped up" in a monad?
11:33:16 <jessopher> taco meat
11:33:35 <cedricshock> Creating the sink has side effects.
11:33:59 <jmcarthur> what would you expect instead?
11:34:12 <irene-knapp> > Util.readRational "3.141592653589793238"
11:34:13 <lambdabot>   Not in scope: `Util.readRational'
11:34:24 <irene-knapp> > read "3.141592653589793238" :: Rational
11:34:25 <jmcarthur> maybe i should just ask... what are the types and functions you have in mind? how do they different from ivar or sink?
11:34:25 <lambdabot>   *Exception: Prelude.read: no parse
11:34:28 <irene-knapp> hmm
11:34:30 <jmcarthur> *differ
11:35:09 <carpi> is there a way to find out the types included in  a typeclass?
11:35:10 <irene-knapp> > read "3.141592653589793238"
11:35:11 <lambdabot>   *Exception: Prelude.read: no parse
11:35:13 <hpaste> “Mukesh Tiwari” pasted “Error in wirter monad” at http://hpaste.org/54467
11:35:22 <keep_learning> Hello all
11:35:33 <jmcarthur> carpi: in ghci, i assume you mean?
11:35:36 <applicative> carpi, doesnt :i Show tell you?
11:35:42 <carpi> yea
11:35:48 <jmcarthur> it is as applicative says
11:36:12 <keep_learning> I am reading writer monad from http://learnyouahaskell.com/for-a-few-monads-more and just copied the example given there
11:36:25 <keep_learning> but when i am trying to run it , i am getting error
11:36:38 <cedricshock> I imagined something more like this: sink :: IO (a) -> a, but that's not possible because the IO (a) is already impure.
11:36:46 <monochrom> @quote tiem
11:36:47 <lambdabot> geheimdienst says: * geheimdienst will from now on use a function carpeTiem aliased to getCurrentTime
11:36:51 <keep_learning> could some one please tell me why i am getting this error http://hpaste.org/54467
11:36:58 <Cale> keep_learning: there's been a small change to the mtl where the plain Writer monad is defined in terms of WriterT now. You have to replace the data constructor Writer with the function writer
11:37:00 <jmcarthur> cedricshock: err... that looks like it's just unsafePerformIO
11:37:04 <carpi> thx
11:37:19 <cedricshock> Yep.
11:37:23 <Cale> keep_learning: I have no idea why that decision was made :P
11:37:48 <jmcarthur> cedricshock: i don't think there is a way to simply remove the IO from the picture completely. writing to the sink, at least, must be in IO. it's only reading that needn't be in IO
11:37:51 <keep_learning> Cale: thank you
11:38:19 <jmcarthur> cedricshock: hence the pure value you get on the side when you use newSink
11:38:22 <ski> cedricshock : note how the promise thing in Alice ML basically has `future :: Promise a -> a'
11:38:23 <cedricshock> Yeah. That's what I realized 7 minutes ago when I confused everyone.
11:39:04 <jmcarthur> i imagine that Alice's promises have slightly different semantics from sinks
11:39:30 <jmcarthur> in that the future function probably just blocks until some other thread fulfills the promise
11:39:56 <jmcarthur> more in line with ivars
11:41:25 <cedricshock> Yeah, I'm looking for something with the interface of sinks and the blocking behaviour. I imagine I could make data BlockingSink a;
11:50:29 <jmcarthur> cedricshock: just look for ivar stuff on hackage
11:51:06 <jmcarthur> cedricshock: http://hackage.haskell.org/packages/archive/ivar-simple/0.1.0.1/doc/html/Data-IVar-Simple.html
11:51:21 <cedricshock> Yeah, I think I'd need to use an IVar instead of the IOref you used:
11:51:22 <cedricshock> x <- unsafeInterleaveIO $ fromMaybe (error msg) <$> readIORef ref
11:52:03 <copumpkin> why unsafeInterleaveIO?
11:52:17 <jmcarthur> copumpkin: it's all that's necessary. unsafePerformIO isn't needed
11:52:24 <copumpkin> I have no context
11:52:26 <copumpkin> just curious
11:52:36 <jmcarthur> copumpkin: http://hackage.haskell.org/packages/archive/sink/0.1.0.1/doc/html/Data-Sink.html
11:52:45 <copumpkin> oh
11:53:02 <cedricshock> x <- unsafeInterleaveIO $ blocking $ read ivarRef
11:53:10 <cedricshock> What does <$> do?
11:53:16 <jmcarthur> it's fmap
11:54:58 <cedricshock> Awesome, thanks a lot jmcarthur and ski!
11:56:38 * jmcarthur just realized that hackage didn't render the bottom character in his documentation :(
11:56:53 <keep_learning> :t <$>
11:56:55 <lambdabot> parse error on input `<$>'
11:57:10 <saati> :t (<$>)
11:57:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:57:15 <Jeanne-Kamikaze> where should I ask a question about a specific package on hackage
11:57:32 <jmcarthur> Jeanne-Kamikaze: you could email the author
11:57:39 <jmcarthur> or maintainer, i guess
11:57:45 <Jeanne-Kamikaze> ok
11:58:01 <jmcarthur> if it's a popular package then here is a good place
11:59:37 <Jeanne-Kamikaze> I'm just getting an error when building the "network" package, saying: lexical error (utf-8 decoding error)
12:01:07 <jmcarthur> huh, works for me
12:01:11 <jmcarthur> maybe it's your version of ghc?
12:01:28 <Jeanne-Kamikaze> I'm on windows with the latest haskell platform thing
12:01:29 <ddarius> It's presumably hGetLine or whatever using the locale now.
12:01:47 <Jeanne-Kamikaze> ghc 7.0.3
12:01:59 <Melvar> What does a kind of ? or ?? signify?
12:02:15 <jmcarthur> ah i'm using ghc 7.2.1
12:02:22 <Jeanne-Kamikaze> oh
12:02:44 <jmcarthur> Melvar: i think those are special black magic meant to allow things like unboxed types, which i think don't have kind *
12:05:29 <Melvar> @kind (->)
12:05:30 <lambdabot> ?? -> ? -> *
12:07:53 <jmcarthur> Melvar: i think my explanation was too ignorant to be useful. i just treat those kinds as black magic and pretend they don't exist for the most part
12:08:47 <applicative> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes  Melvar
12:09:48 <ski> Melvar : `??' is the superkind of `*' and `#', `?' is the superkind of `??' and `(#)'
12:10:58 <applicative> so -> cant take an unboxed tuple as argument
12:11:50 <applicative> i mean, as the 'argument' type, or am i reading it backwards
12:12:12 <ddarius> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/TypeType#Kindsubtyping
12:12:56 <Melvar> Okay, that’s clear enough, I suppose.
12:12:59 <carpi> how is it possible to implement arrays in haskell if there is no access to the underlying memory subsystem?
12:13:23 <ddarius> carpi: Your hypothesis is wrong.
12:13:49 <carpi> i know it is wrong and that is why i seek clarification
12:14:17 <ddarius> Look up the word "hypothesis."
12:15:03 <applicative> how is it possible to walk across the street is it's Monday morning?
12:15:05 <Cale> carpi: There is access to the underlying memory subsystem.
12:15:14 <applicative> if it's Monday morning
12:15:25 <carpi> ddarius: done. Now what?
12:15:34 <ddarius> Now read the definition.
12:15:41 <carpi> Cale: could you please tell me how?
12:15:47 <carpi> ddarius: done. now?
12:15:54 <ddarius> Now understand the definition.
12:16:30 <carpi> done..next?
12:17:01 <ddarius> Now apply the definition.
12:18:19 <applicative> carpi, don't do it.
12:18:36 <jessopher> capri: i think your if is missing an else
12:20:06 <Cale> carpi: The FFI... http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
12:20:35 <int-e> How can I write files to a hard drive without write access to the file system's superblock?
12:20:51 <carpi> ah okay..so it  is impossible to implement datastructures within haskel itself without resorting to the FFI?
12:21:03 * ski stares blankly
12:21:05 <ddarius> int-e: That's doable, for some values of "write access."
12:21:42 <int-e> ghc actually provides primitive operations for accessing arrays; the rts provides some more for allocating arrays
12:21:45 * int-e shrugs
12:22:05 <ddarius> Data structures = arrays
12:22:58 <int-e> ddarius: Yes. I was questioning both that access to the underlying memory subsystem (what is meant by that exactly anyway?) is required and also trying to suggest that there might still be sufficiently powerful higher level interfaces available.
12:23:17 <int-e> but whatever.
12:29:46 <irene-knapp> awwww hell, I think this bug is in integer-gmp
12:29:59 <irene-knapp> gcdInteger is returning 0
12:30:30 <irene-knapp> it's only ten lines, but it's opaque code with lots of magic hashes :(
12:30:31 <irene-knapp> hmmm
12:30:47 <irene-knapp> maybe I can transplant it into another module so I don't have to rebuild the infrastructure to test changes in it...
12:32:00 <ski> irene-knapp : hm, returns `0' for what inputs ?
12:32:25 <irene-knapp> 314159265358979323 and 1000000000000000000
12:32:37 <irene-knapp> > gcdInteger 314159265358979323 1000000000000000000
12:32:38 <lambdabot>   Not in scope: `gcdInteger'
12:32:47 <ski> > gcd 314159265358979323 1000000000000000000 :: Integer
12:32:48 <lambdabot>   1
12:32:55 <irene-knapp> hmm
12:33:09 <irene-knapp> wait, sorry
12:33:12 <irene-knapp> I copied/pasted missing a digit
12:33:18 <irene-knapp> 3141592653589793238
12:33:31 <irene-knapp> > gcd 3141592653589793238 1000000000000000000
12:33:32 <lambdabot>   2
12:33:36 <irene-knapp> yeah, that's what it should be
12:33:41 <irene-knapp> but for me it's 0
12:34:14 <sipa> > (gcd 3141592653589793238 1000000000000000000) :: Int
12:34:15 <lambdabot>   2
12:34:29 <irene-knapp> > gcd 3141592653589793238 1000000000000000000 :: Integer
12:34:30 <lambdabot>   2
12:34:49 <irene-knapp> > GHC.Integer.Type.gcdInteger 3141592653589793238 1000000000000000000 :: Integer
12:34:50 <lambdabot>   Not in scope: `GHC.Integer.Type.gcdInteger'
12:34:54 <irene-knapp> hmm
12:34:56 <ddarius> > gcd 3141592653589793238 1000000000000000000 :: Int32
12:34:57 <lambdabot>   106
12:35:04 <irene-knapp> well, sure, it's bigger than an Int32 :)
12:35:58 <irene-knapp> the implementation of gcdInteger is actually really complicated, it peeks inside the bignum to see how many whatever-you-call-thems it's made of
12:36:25 <ski> irene-knapp : digits ?
12:36:33 <irene-knapp> no, smaller bignums :)
12:36:54 <irene-knapp> or Ints, I guess
12:37:04 <ski> digits :)
12:37:08 <irene-knapp> haha okay then
12:37:56 <Cale> base 2^32 digits :)
12:38:04 <irene-knapp> haha yeah
12:38:08 <ddarius> 18446744073709551614-its
12:38:25 <Cale> or is it 2^64? :)
12:38:49 <irene-knapp> what LANGUAGE flag enables the (# ... #) pseudo-tuple syntax?
12:39:28 <monochrom> is that MagicHash?
12:39:34 <irene-knapp> no, unfortunately not
12:39:39 <ski> `UnboxedTuples' i would assume
12:39:43 <irene-knapp> hmm thanks
12:43:36 <irene-knapp> okay, hmm
12:43:50 <irene-knapp> I can't test changes to gcdInteger outside of integer-gmp, because they use non-exported constructors
12:44:02 <jessopher> i should start using ghc extension, my current project needs more superfluous dependency
12:46:23 <Cale> jessopher: That seems to be sarcasm, but there are actually quite a lot of useful ghc extensions :)
12:47:20 <jessopher> oh i know, i am definitely not saying they are superfluous, just that my usage would be
12:47:25 <Cale> heh
12:48:40 <jessopher> i got so caught up in some of them for a while that it was hard for me to find single lines of valid haskell98 in whole source trees
12:48:53 <hpaste> irene-knapp pasted “Find the bug!” at http://hpaste.org/54469
12:49:25 <irene-knapp> actually, I'm pasting that for suggestions of where I can put trace
12:49:39 <irene-knapp> (bearing in mind that I can't actually put trace anywhere, because integer-gmp does not depend on base)
12:59:05 <irene-knapp> oh hey WTH!!!  I have a stale copy of GMP on my system after working really hard to make sure I did not!
12:59:24 <irene-knapp> although it's a 32-bit copy
12:59:28 <irene-knapp> weird
12:59:41 * irene-knapp removes it and tries building again
13:04:14 <clsmith> hey all. is there a simpler way of saying (x >>= mapM f)? i suspect not, but i'm curious
13:08:24 <ski> i don't really think there is
13:09:09 <ddarius> Four tokens!
13:13:10 * hackagebot json-qq 0.4.1 - Json Quasiquatation library for Haskell.  http://hackage.haskell.org/package/json-qq-0.4.1 (OscarFinnsson)
13:18:12 * hackagebot text-json-qq 0.4.1 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.4.1 (OscarFinnsson)
13:30:20 <prokii> new to haskell... how do I curry the Text.Regex.Posix =~ function?
13:30:47 <sipa> :t (=~)
13:30:48 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
13:31:00 <prokii> I want to create something like matchBLAH = (=~"BLAH")
13:31:10 <sipa> that should work
13:31:51 <prokii> The problem is =~ can have different return types
13:32:00 <sipa> you may have to fix a data type
13:32:08 <sipa> if it's ambiguous
13:32:24 <prokii> I tried (=~"BLAH")::Bool
13:32:28 <prokii> but no dice
13:32:35 <sipa> that won't work
13:32:44 <Feuerbach> prokii: it's a function, it cannot be just Bool
13:32:48 <sipa> try :: String -> Bool
13:33:03 <sipa> (=~ "BLAH") :: String -> Bool
13:33:14 <prokii> ahh!
13:33:16 <prokii> awesome
13:34:37 <mellum_> if I do "import qualified Data.IntMap as IntMap", how can I access the ! operator?
13:34:55 <mellum_> IntMap.! doesn't seem to be it
13:35:48 <Feuerbach> mellum_: yes, it's IntMap.!
13:36:00 <monochrom> @type undefined Map.! undefined
13:36:01 <sipa> or IntMap.(!)
13:36:02 <lambdabot> Couldn't find qualified module.
13:36:16 <monochrom> @type undefined M.! undefined
13:36:17 <lambdabot> forall a. a
13:36:38 <sipa> and `IntMap.(!)` for infix maybe?
13:36:51 <Feuerbach> IntMap.! *is* infix
13:37:13 <mellum_> hmm, if I do :t IntMap.! or :t IntMap.(!) in ghci, I get errors
13:37:36 <monochrom>  :t IntMap.! is supposed to be as erroneous as :t +
13:37:43 <clsmith> :t (IntMap.!) ?
13:37:43 <Feuerbach> try :t (IntMap.!)
13:37:44 <lambdabot> parse error (possibly incorrect indentation)
13:37:52 <monochrom> @type (M.!)
13:37:54 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
13:39:10 <monochrom> > M.fromList [(1, 'x')] M.! 1
13:39:12 <lambdabot>   'x'
13:39:15 <monochrom> works
13:39:28 <monochrom> > (M.!) (M.fromList [(1, 'x')]) 1
13:39:29 <lambdabot>   'x'
13:39:32 <monochrom> worksforme
13:39:51 <mellum_> Okay, I think I have it figured out now...
13:40:25 <mellum_> It's kina weird that this is an infix operator and there is no normal function for it
13:41:23 <monochrom> there is lookup if you don't mind Maybe
13:41:53 <monochrom> (surely next year someone will say "strange, there is no normal operator for that")
13:41:56 <mellum_> Okay, actually I'm still confused :-) So if I have a map m, how do I look up element x with !?
13:42:20 <monochrom> "element" x? is that a key?
13:42:39 <monochrom> m IntMap.! (your key here)
13:43:05 <monochrom> or perhaps m IntMap.! your_key_here if the parentheses give you wrong ideas
13:43:50 <mellum_> Ah. Thanks.
13:46:58 * fcr is trying to define a function weirdMap :: Functor f => (a->a) -> f b -> f b; that is defined as fmap if a "has the same type as" b; and (\_->id) otherwise
13:47:06 <fcr> Is that possible?
13:47:44 <monochrom> no
13:47:50 <fcr> :S
13:48:11 <fcr> even if I declare that operation inside class Foo a b?
13:48:41 <monochrom> then it can be done to some extent, and I don't know to how much extent
13:49:06 <fcr> I did it for:  mapIfString :: (String -> String) -> F x -> F x
13:49:07 <fcr> though
13:49:10 <monochrom> and I don't know whether you will run into some evil UndecidableInstance
13:49:33 <jmcarthur> it could possible be done with Typeable?
13:49:36 <jmcarthur> *possibly
13:49:59 <fcr> jmcarthur: I guess so, but I was trying to avoid using Typeable
13:50:04 <jmcarthur> another way:
13:50:26 <jmcarthur> data Eq a b where Refl :: Eq a a; weirdMap :: Functor f => Eq a b -> (a -> a) -> f b -> f b
13:50:41 <jmcarthur> but then you almost might as well just make a and b the same in the first place
13:51:13 <jmcarthur> (requires GADTs, by the way)
13:52:02 <fcr> jmcarthur: thanks for the idea, I'll investigate that
13:52:35 <dylex> isn't that almost exactly mkT?
13:52:50 * jmcarthur isn't familiar with mkT
13:52:56 <dylex> :t mkT
13:52:57 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
13:53:19 <jmcarthur> looks pretty close, yeah
13:54:07 <dylex> > mkT (succ :: Int -> Int) (4 :: Int)
13:54:08 <lambdabot>   5
13:54:15 <dylex> > mkT (succ :: Int -> Int) ('x' :: Char)
13:54:16 <lambdabot>   'x'
13:54:50 <dylex> :t fmap . mkT
13:54:51 <lambdabot> forall b (f :: * -> *) b1. (Functor f, Typeable b, Typeable b1) => (b1 -> b1) -> f b -> f b
14:10:57 <nihtml_> win 7
14:11:02 <nihtml_> oops, sorry
14:14:33 <mellum_> is there a constant for the maximum Int?
14:14:48 <monochrom> maxBound :: Int
14:14:50 <ski> > maxBound :: Int
14:14:51 <lambdabot>   9223372036854775807
14:14:59 <mellum_> thanks
14:16:23 <TheRubberyTurk> > 2^29-1
14:16:24 <lambdabot>   536870911
15:11:41 <Philonous> Can I force ghc to show me the normalized type of something?
15:18:31 <HugoDaniel> when is ghc 64bits for windows planned ?
15:39:05 <hpaste> stribor pasted “rotation” at http://hpaste.org/54473
15:39:19 <stribor> can someone help me with example above
15:39:35 <stribor> i am trying to load image and then rotate it and put it into list
15:40:41 <stribor> like i dont get error or anything but it doesnt seem that my list is loaded with images
15:44:12 <jmcarthur> stribor: i don't know what package you're using, but i'm surprised to see the combination of rotation being in IO and it giving you a new result as though it was purely functional
15:44:28 <jmcarthur> stribor: are you getting a list of (), by chance?
15:44:40 <jmcarthur> like   [(), ()]
15:44:44 <stribor> jmcarthur: i am not sure....dont know how to check it
15:44:50 <stribor> i am not getting any errors though
15:44:57 <jmcarthur> stribor: what is the type of pixBufRotateSimple?
15:45:09 <stribor> jmcarthur: let me see
15:45:29 <jmcarthur> i'm suspecting something like pixBufRotateSimple :: PixBuf -> IO ()
15:45:44 <stribor> jm
15:45:49 <stribor> jmcarthur: pixbufRotateSimple :: Pixbuf -> PixbufRotation -> IO Pixbuf
15:45:57 <jmcarthur> huh, not what i expected
15:46:27 <jmcarthur> ah, i forgot the rotation parameter, but still, the result isn't what i thought it would be
15:46:42 <jmcarthur> so the listOfImages you're getting *should* have type [PixBuf] then
15:47:07 <jmcarthur> how do you know it doesn't have any images?
15:47:11 <stribor> jmcarthur: yes but i think i am gettin IO Pixbuf
15:47:38 <jmcarthur> mapM (pixbufRotateSimple image) [PixbufRotateCounterclockwise,PixbufRotateUpsidedown]
15:47:40 <jmcarthur> oops
15:47:53 <jmcarthur> mapM (pixbufRotateSimple image) [PixbufRotateCounterclockwise,PixbufRotateUpsidedown] :: IO [PixBuf]
15:48:04 <jmcarthur> so listOfImages :: [PixBuf]
15:48:42 <stribor> so io should add at the end :: IO [Pixbuf]??
15:48:58 <jmcarthur> :t mapM
15:49:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:49:16 <stribor> so yes result is monad
15:49:24 <jmcarthur> right
15:49:36 <stribor> so why am i not getting any errors
15:49:38 <jmcarthur> but you are using do notation, binding listOfImages with an arrow
15:49:47 <siracusa> stribor: The code so far seems to be correct. What are you trying to do with listOfImages afterwards?
15:49:54 <jmcarthur> therefore listOfImages is just [PixBuf], not IO [PixBuf]
15:50:11 <stribor> i am trying to put it on the screen
15:50:15 <jmcarthur> s/an arrow/a left arrow/
15:50:25 <siracusa> How?
15:50:27 <stribor> yes..like directoion of sort
15:50:30 <jmcarthur> could you paste your full code?
15:50:56 <stribor> let me see
15:52:11 <aavogt> can you pretty-print table-like data with Text.PrettyPrint?
15:53:37 <aavogt> as in I have a list [(String,Double)] and would like to print those on many lines
15:54:29 <aavogt> without having to compute myself the     maximum (length . fst), and pad the String by that value... stuff that seems unnecessarily difficult to get right
15:57:00 <aavogt> alternatively, if somebody knows a library that makes that kind of thing simple for text output that would be nice
16:01:29 <TheRubberyTurk> map (\(s,d) -> "<tr><td>"++s++"</td><td>"++show d++"</td></tr>")
16:04:07 <siracusa> TheRubberyTurk: I guess he wants plain text, not HTML code
16:07:39 <Sgeo> "GHCi can now accept ALL top-level declarations, including class definitions/instances, data type definitions, etc. This is a huge complaint for many newcomers who expect the REPL to be able to take any input."
16:07:41 <Sgeo> !!!
16:07:42 <Sgeo> :D:D:D
16:08:40 * TheRubberyTurk complains about not being able to type modules into GHCi.
16:46:23 <aavogt> TheRubberyTurk: yeah, I'm looking for a prettyprinting library that will avoid the pain when generating text
16:46:37 <aavogt> (though also doing html output would be welcome)
16:53:08 <gnoob> hello all
16:54:16 <byorgey> welcome, gnoob
16:55:08 <byorgey> gnoob: if you're learning Haskell, feel free to ask questions here
16:55:13 <gnoob> I've just started reading 'learn you a haskell for great good'
16:55:43 <gnoob> Thanks byorgey. I was wondering about the underscore
16:56:37 <byorgey> gnoob: underscore is a pattern which matches anything.  You use it to match things you don't care about.
16:56:56 <gnoob> so it's a wildcard for what I want to ignore?
16:57:04 <byorgey> let f x _ = x + 1  in  f 3 'x'
16:57:09 <byorgey> let f x _ = x + 1  in  f 3 'x'
16:57:14 <byorgey> erg, sorry
16:57:16 <byorgey> yes
16:57:20 <byorgey> > let f x _ = x + 1  in  f 3 'x'
16:57:22 <lambdabot>   4
16:57:49 <gnoob> neat!
16:57:50 <byorgey> that's the same as  let f x y = x + 1  in f 3 'x', but since we don't use the y there's no point in giving it a name
16:58:28 <byorgey> > let f (x:_) = x  in  f [1,2,3]
16:58:29 <lambdabot>   1
17:00:21 <gnoob> Thanks again byorgey I think I'm getting it. I'll be back with more questions later ;)
17:01:49 <pmilley> pl \x y z -> f (g x y z)
17:01:50 <byorgey> gnoob: great =)
17:02:11 <byorgey> pmilley: needs moar @
17:02:28 <pmilley> Ah.
17:02:28 <GordonFreeman> hi
17:02:35 <byorgey> hi GordonFreeman
17:02:37 <GordonFreeman> does GHC optimize code using SSE2 ?
17:02:49 <pmilley> @pl \x y z -> f (g x y z)
17:02:50 <lambdabot> ((f .) .) . g
17:02:54 <pmilley> Much better, thanks.
17:05:21 <jmcarthur> GordonFreeman: not yet, and even in the future it will only be library-level optimizations, as far as i'm aware
17:05:36 <pmilley> @pl \i f x -> x : (i f (f x))
17:05:36 <lambdabot> (ap (:) .) . ((.) =<<)
17:05:39 <jmcarthur> GordonFreeman: ghc will in the near-ish future have SSE primops, at least
17:06:15 <GordonFreeman> but i have read gcc supports automatic SSE optimization
17:06:36 <GordonFreeman> isnt ghc making č code then compile that ?
17:06:48 <jmcarthur> ghc doesn't generate C anymore
17:06:54 <jmcarthur> it has two main backends
17:07:01 <jmcarthur> one is a native generator
17:07:04 <jmcarthur> the other goes through llvm
17:07:20 <jmcarthur> (there may be a deprecated C backend hanging around)
17:18:12 * hackagebot ghc-mod 1.0.1 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-1.0.1 (KazuYamamoto)
17:21:28 <pmilley> @pl \x y -> x
17:21:29 <lambdabot> const
17:21:37 <pmilley> @pl \x y -> y
17:21:38 <lambdabot> const id
17:24:30 <Axman6> > const id a b
17:24:31 <lambdabot>   b
17:24:41 <Axman6> oh right
17:25:15 <augur> @unpl flip const
17:25:15 <lambdabot> (\ b c -> c)
17:38:35 <irene-knapp> > gcd 3141592653589793238 1000000000000000000 :: Integer
17:38:36 <lambdabot>   2
17:38:38 <irene-knapp> hm
17:38:54 <irene-knapp> it's /still/ 0 on my system, even after cleaning out the stale gmp
17:39:44 <aavogt> maybe if you reboot ...
17:39:48 <irene-knapp> haha
17:39:59 <Axman6> > gcd 3141592653589793239 1000000000000000000 :: Integer
17:40:00 <lambdabot>   1
17:40:05 <Axman6> > gcd 3141592653589793237 1000000000000000000 :: Integer
17:40:06 <lambdabot>   1
17:40:09 <Axman6> :(
17:40:23 <geheimdienst> :t gcd
17:40:24 <lambdabot> forall a. (Integral a) => a -> a -> a
17:40:33 <irene-knapp> it's specialized
17:40:41 <irene-knapp> it's implemented by (hidden) functions gcdInt or gcdInteger
17:40:47 <irene-knapp> the latter being contained in integer-gmp
17:40:51 <aavogt> it's not completely a joke since this stale gmp library might still be around somehow (since I have no idea how you cleared it out, or how you'd go about doing that anyways)
17:41:01 <irene-knapp> aavogt: well, yeah, you're right of course
17:41:14 <irene-knapp> but I'm pretty sure what I did is sufficient
17:41:42 <irene-knapp> or that if it isn't, rebooting wouldn't be either :)
17:41:56 <aavogt> @oes 3,1,4,5,9,2,6
17:42:01 <lambdabot>  Digits in order in which they first appear in the decimal expansion of Pi.
17:42:01 <lambdabot>  [3,1,4,5,9,2,6,8,7,0]
17:51:57 <geheimdienst> whoa, i never noticed it's forbidden to say "f 42 = ... ; g = ... ; f 37 = ..."
17:52:26 <geheimdienst> you can't put other functions in between. all partial definitions of f need to be adjacent
17:52:41 <aavogt> seems like a decent restriction for sanity
17:53:14 <Lycurgus> why? the segments appear delimited.
17:53:34 <aavogt> you can learn lots of useless stuff by studying the language grammar
17:53:45 <Lycurgus> same translation unit mehbe
17:53:56 <geheimdienst> aavogt: i dunno. it seems contrary to how you can refer forward to functions (functions defined later in the file)
17:54:26 <Jafet> Why would you want to put other functions in between?
17:55:40 <aavogt> Lycurgus: so you can look at a definition and see it's partial, rather than "oh maybe there's another equation somewhere else in this module"
17:56:31 <geheimdienst> jafet, because the function is kinda long. i was rewriting this, just for the fun of it. i thought "let's be idiomatic and use pattern matching", i.e. i threw out the table at the end and had only one function «dispatch "num" = ... dispatch "blank" = ...» http://haskell.org/haskellwiki/Simple_unix_tools
17:56:42 <sully> it seems like actually doing that would be incredibly tasteless
17:56:50 <Jafet> Well, someday when all the sillier haskell rules are fixed, we can look at this one
17:57:01 <Jafet> I'm still waiting for case of
17:57:40 <Lycurgus> aavogt, ah
17:57:40 <sully> ?
17:58:19 <Jafet> .oO(uniq isn't nub, it's (map head . group))
17:58:57 <aavogt> geheimdienst: you can get around that with template haskell if you can't use another preprocessor / rearrange your definitions
17:59:42 <geheimdienst> Jafet: in my opinion there's several things wrong with that wiki page
17:59:50 <aavogt> as in you write your equations like    [d|  f 42 = ... |]
17:59:58 <Jafet> Let's be idiomatic and not write dispatch tables by hand
18:00:11 <aavogt> which gives you a  Q Dec  (or maybe Q [Dec] I forget)
18:00:51 <geheimdienst> aavogt: interesting, so [d| ] pulls all of the defintions into one place?
18:00:55 * Lycurgus thinks of a.e. van vogt when he sees that nick.
18:01:06 <aavogt> not exactly, I'm not done explaining
18:01:26 <geheimdienst> Jafet: you mean you don't like the list at the end of the code?
18:02:28 <aavogt> you can then put those definitions all together into an IORef if you wrote them like:   $( runIO $ modifyIORef ref ([d| f 42 = ... |] :) )
18:02:45 <irene-knapp> Lycurgus: yeah, so do I
18:03:02 <geheimdienst> aavogt: oh i see :) interesting
18:03:02 <aavogt> where ref unsafePerformIO'd ioref containing [Q Dec]
18:03:45 <aavogt> actually for top-level $() you have to return [] at the end
18:04:12 <aavogt> Lycurgus: oddly I have read one book of said author
18:04:30 <Lycurgus> what's odd about it?
18:04:57 <aavogt> because it's also my last name and to my knowledge not related
18:05:14 <Lycurgus> isn't that the not-odd part?
18:05:44 <aavogt> then we have different definitions of odd
18:05:59 <Lycurgus> looks that way
18:06:54 <photex> happy thanksgiving al
18:06:55 <photex> all
18:07:06 <aavogt> geheimdienst: then to finish, you can have at the bottom of your file  $(runIO (readIORef ref)), (probably involving sequence...)
18:07:20 <photex> I'm trying to create a new IORef
18:07:23 <photex> with the value 0.0
18:07:30 <photex> and it's not compiling
18:07:35 <photex> if I use 0 it'll work fine
18:07:44 <photex> mdx_ref <- newIORef 0.0
18:07:54 <photex> No instance for (Fractional Int)
18:07:55 <photex>       arising from the literal `0.0'
18:07:55 <photex>     Possible fix: add an instance declaration for (Fractional Int)
18:08:10 <aavogt> photex: that error is related to how you use mdx_ref later on
18:08:10 <geheimdienst> aavogt: thanks for the explanation
18:08:33 <tswett> photex: it sounds like mdx_red has to be an IORef Int for some reason, but 0.0 is not an Int.
18:08:40 <photex> lol!
18:08:41 <photex> thanks
18:08:55 <photex> in a function that's using it
18:09:08 <photex> I accidentally declared IORef Int -> ...
18:09:17 <photex> many thanks aavogt tswett
18:09:27 <tswett> You're welcome.
18:10:36 <aavogt> geheimdienst: I'm 90% sure that kind of thing has worked, but of course there isn't much point in messing with TH there
18:11:37 <geheimdienst> yeah, let's leave that out of the beginner-level wiki page :) but it does sound like a handy trick
18:13:41 <pmilley> @pl \f x -> x : (i f (f x))
18:13:42 <lambdabot> ap (:) . ((.) =<< i)
18:16:01 <aavogt> @pl \f -> liftM2 (:) id (i f . f)
18:16:02 <lambdabot> liftM2 (:) id . ((.) =<< i)
18:16:25 <Axman6> ha! i've been told plenty of times that saying a class in haskell is like an interface in java is a bad idea. but SPJ just said the same thing, so i feel vindicated
18:16:37 <Axman6> in a video i'm watching*
18:17:10 <pmilley> @pl \f -> i f . f
18:17:11 <lambdabot> (.) =<< i
18:19:21 <shachaf> Axman6: He also explains IO a as ~ World -> (a,World).
18:20:08 <Jafet> It's not a bad idea for SPJ to say that, of course.
18:21:09 <Axman6> shachaf: good!
18:21:50 <shachaf> «A novice was trying to fix a broken Lisp machine by turning the power off and on. Knight, seeing what the student was doing, spoke sternly: "You cannot fix a machine by just power-cycling it with no understanding of what is going wrong." Knight turned the machine off and on. The machine worked.»
19:08:05 <lament> anyone here lives in vancouver and wants Real World Haskell?
19:09:13 <Quadrescence> i do
19:10:38 <lament> <3
19:10:46 <lament> liar
19:10:49 <lament> you don't want it
19:10:52 <lament> you already have it
19:10:58 <shachaf> lament!
19:11:03 <lament> shachaf!
19:11:09 <shachaf> We never see you around these parts.
19:11:27 <Quadrescence> shachaf: yeah lament is quitting haskell for good
19:11:31 <lament> what
19:11:35 <lament> i quit haskell for good years ago
19:11:40 <Quadrescence> see?
19:11:45 <lament> i started programming full-time and it ate my soul
19:11:51 <lament> now i hate computers
19:12:02 <shachaf> lament: You're just in #esoteric these days.
19:12:05 <Quadrescence> that's what you get for programming in a shitty language for your job
19:12:12 <lament> shachaf: i'm banned in #esoteric
19:12:16 <shachaf> lament: I saw.
19:13:06 <shachaf> Anyway, if you hate Haskell, you'll love #haskell-blah.
19:13:15 <shachaf> It's the ultimate place for people who hate Haskell.
19:13:17 <lament> i vaguely remember you're the guy who plays nethack
19:13:34 <shachaf> I haven't played in quite a while. It's a terrible game, NetHack.
19:13:40 <lament> i don't like #haskell-blah, it's all just people discussing the problems with their non-standard sexual orientations
19:13:48 <Quadrescence> haha
19:15:40 <shachaf> lament: I vaguely remember you as the person who can't Cale.
19:15:52 <shachaf> Also you knew a bit of Hebrew. Or something like that.
19:16:12 <lament> i used to know a bit of hebrew, but i shachaf
19:16:48 <Cale> shachaf: wat
19:17:01 <lament> sup Cale
19:17:11 <Cale> hi
19:17:20 <zeiris> lament: give it to me so I can pass it on to some UBC student
19:17:25 <shachaf> Cale: I vaguely remember the phrase "Why is it that Cale can lament, but lament can't Cale?".
19:17:58 <Cale> oh
19:18:05 <lament> i don't :(
19:18:06 <Cale> I don't recall that
19:18:30 <lament> Cale: probably we both weren't present
19:18:34 <lament> they were laughing behind our backs
19:18:36 <shachaf> Probably.
19:18:41 <lament> zeiris: okay
19:18:48 <lament> zeiris: are you ever downtown?
19:19:09 <shachaf> haskell/07.08.02:11:21:07 <shachaf> lament: How come Cale can lament, but lament can't Cale?
19:19:19 <shachaf> I knew it.
19:19:24 <lament> which of those numbers is the year
19:19:26 <shachaf> I remember random snippets of #haskell conversation for years.
19:19:30 <shachaf> lament: 07
19:19:33 <lament> jesus
19:19:49 <zeiris> lament: now that you mention it, probably not for a while :( You should just put a 'free book' stickynote on it and leave it in some nerd coffeeshop.
19:20:03 <shachaf> Like haskell/07.04.15:18:50:22 <sorear> dons: my dirty glasses antialias the fonts for me
19:20:05 <lament> okay...
19:20:25 <lament> are there nerd coffeeshops in vancouver
19:20:42 <lament> im only aware of hipster coffee shops and yuppie coffee shops
19:20:55 <shachaf> Aren't those all the same thing?
19:21:00 <lament> not at all
19:21:10 <lament> starbucks are yuppie
19:21:43 <PiRSquared17> > 0
19:21:44 <lambdabot>   0
19:23:54 <PiRSquared17> >
19:24:03 <confab> Vancouver, WA or BC?
19:24:10 <lament> bc
19:24:16 <PiRSquared17> > surgeon (0, 1, 2)
19:24:18 <lambdabot>   Not in scope: `surgeon'
19:24:18 <confab> ph
19:24:21 <confab> oh*
19:24:56 <PiRSquared17> > surgeon (0, 1, 2)
19:24:58 <lambdabot>   (0,2)
19:25:01 <PiRSquared17> What>
19:25:03 <PiRSquared17> *?
19:45:21 <shachaf> lament: The main reason you're banned in #esoteric is the irritable ops they have in there.
19:46:09 <lament> yeah
19:46:16 <lament> that channel has gone downhill
19:46:23 <lament> nazi ops and annoying regulars
19:47:35 <dbelange_> occupy #esoteric
19:49:40 <irene-knapp> heh, saw an amusing post recently where somebody said he was going to put up some "Occupy" signs at the line of people waiting for the Twilight movie release, and see if he could get them arrested
19:54:40 <shachaf> lament: Well, it's good to have you back in here.
19:54:53 <shachaf> We were lamenting your absence.
20:48:14 * hackagebot msgpack 0.6.4 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.4 (HideyukiTanaka)
