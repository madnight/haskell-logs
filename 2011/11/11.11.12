00:14:01 * edwardk waves hello.
00:14:30 * shachaf particles hello.
00:14:42 <eulyix> Hey, I'm trying to get this to be evaluated (sqrt 10) - (floor (sqrt 10)) though I can't get past the type check. I've tried annotating the RHS of (-) with several types, but I've become stuck.
00:15:02 <edwardk> :t floor
00:15:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:15:11 <shachaf> eulyix: floor returns an Integral type.
00:15:18 <edwardk> floor is converting from a floating point like number to one that looks like Int or Integer
00:15:24 <shachaf> You'll want to convert it to a Floating type with fromIntegral.
00:15:29 <edwardk> you'd need to fromIntegral it to get another float again
00:15:32 <eulyix> Aha, fromIntegral
00:15:43 <edwardk> > sqrt 10 - fromIntegral (floor (sqrt 10))
00:15:44 <lambdabot>   0.16227766016837952
00:15:52 <eulyix> Thank you, that's what I was looking for.
00:15:57 <shachaf> fromIntegral, also known as "differentiate". :-)
00:16:20 <edwardk> no, differentiate is off in another package ;)
00:19:29 <hpaste> letrec pasted ‚ÄúLaziness?‚Äù at http://hpaste.org/53920
00:20:13 <letrec> Can someone explain why when T is Data.Text.Lazy this doesn't work? (http://hpaste.org/53920)
00:20:15 <letrec> Thx
00:20:32 <letrec> Works when T is Data.Text
00:21:13 <shachaf> "doesn't work"? You might have to threaten it with a hungusprod.
00:23:18 <Saizan> withFile closes the handle
00:23:54 <Saizan> but D.T.Lazy.hGetContents defers the reading
00:23:59 <shachaf> Oh, you're using lazy I/O.
00:24:05 <shachaf> Saizan++
00:30:16 <letrec> Saizan: Yes but when we pattern match the list (case r of ...) we should actually perform the reading since we need the head of the list if it exists??
00:32:49 <Saizan> letrec: nothing is forcing the result of search in the callback you pass to withFile
00:35:00 <Saizan> this would work here: withFile fn ReadMode $ (return $! =<<) . liftM search . T.hGetContents
00:36:56 <letrec> :t (=<<)
00:36:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
00:37:23 <letrec> @src (=<<)
00:37:23 <lambdabot> f =<< x = x >>= f
00:37:42 <Saizan> ((return $!) =<<) <-- needs more parens, sorry
00:37:43 <c_wraith> consecutive infix operators is never syntactically valid...
00:40:55 <letrec> Saizan: Thx. Last question: if withFile closes the handle, why didn't we have an error when trying to read the file?
00:49:16 <iboB> hey is there a generalized outer product function in haskell (zipWith is a generalized inner product)
00:50:18 <iboB> outer [a,b] [c,d] -- makes [(a,c), (a,d), (b,c), (b,d)]
00:50:36 <FreeAsInJesus> Hi, anyone know how many buttons on the keyboard?
00:51:07 <AtnNn> > liftM2 (,) [1,2] [3,4]
00:51:08 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
00:51:08 <Maxdamantus> Depends on the keyboard.
00:51:21 <elliott> Probably 100 to 104 or so. What's that got to do with Haskell?
00:51:29 <iboB> tahnks AtnNn
00:51:36 <iboB> thanks, even :)
00:51:41 <FreeAsInJesus> what is the standard size. I swear mine got 200
00:51:59 <Saizan> letrec: hGetContents interprets a closed handle as EOF
00:52:38 <elliott> FreeAsInJesus: Why are you asking us?
00:53:48 <letrec> :t (,)
00:53:49 <lambdabot> forall a b. a -> b -> (a, b)
00:53:53 <shachaf> iboB: See also sequence.
00:54:17 <shachaf> > sequence [[a,b],[c,d],[e,x,y]]
00:54:21 <lambdabot>   [[a,c,e],[a,c,x],[a,c,y],[a,d,e],[a,d,x],[a,d,y],[b,c,e],[b,c,x],[b,c,y],[b...
00:54:54 <iboB> thanks you too, shachaf
00:55:22 <Jafet> Well, they work on finite lists
00:55:41 <Jafet> control-monad-omega has a diagonalization operator
01:06:05 <iboB> will "False && func" (or "True || func") evaluate func?
01:06:27 <iboB> silly question :)
01:06:29 <shachaf> iboB: func isn't going to be a function unless you've redefined (&&). :-)
01:06:31 <iboB> it's lazy so obbiously no
01:06:40 <shachaf> Nope, it won't evaluate it.
01:06:55 <shachaf> Well, it's not completely obvious.
01:07:06 <shachaf> For instance, foo && False will evaluate foo.
01:19:27 <hpaste> mbuf pasted ‚ÄúSOH Text.Regex substitute‚Äù at http://hpaste.org/53921
01:43:54 <ion> mornfall: Hi. I‚Äôm trying cmdlib. I have trouble figuring out how to have a Maybe String argument.
01:47:48 <hpaste> amtal pasted ‚Äúparser wat‚Äù at http://hpaste.org/53922
01:48:08 <amtal> More parser weirdness! How come 'character ','' works differently from 'character '\n''?
01:49:05 <mornfall> ion: Hmm. Good question.
01:49:33 <mornfall> ion: I don't think there's any way to distinguish between Just [] and Nothing though.
01:49:52 <mornfall> So it's probably not extremely useful.
01:52:00 <mbuf> Prelude Text.Regex> subRegex (mkRegex "e+") "hello" "\\1"
01:52:00 <mbuf> "h*** Exception: Ix{Int}.index: Index (1) out of range ((0,0)), why?
01:59:36 <ion> mornfall: %> [ Default Nothing, MapValue Just ] or something
01:59:54 <ion> mornfall: Something similar could work for parsing integers etc.
02:58:51 <roSievers> Hi, is the factorial (n!) included in some default haskell module?
03:02:39 <elliott> roSievers: factorial n = product [1..n]
03:02:47 <elliott> nowhere standard, but so simple as to be pointless to include
03:03:54 <mornfall> ion: Hmm.
03:05:00 <mornfall> ion: I don't think there's a MapValue though. :)
03:05:21 <mornfall> ion: What do you mean by parsing integers?
03:06:47 <mornfall> Integers would normally be parsed automatically, whenever the parameter type is Int(eger).
03:12:45 <tomh> hey guys, do hs-boot files work under ghci?
03:13:59 * mornfall wouldn't know, but I would be quite wary of using them either way.
03:14:31 <tomh> yeah hmm
03:15:22 <mornfall> As far as I remember it's a nasty hack anyway.
03:15:26 <tomh> it is
03:15:50 <tomh> but I have a state which contains a data type and I have a function on that data type that also takes the state as an input
03:15:58 <tomh> and ideally I want them in seperate files
03:16:15 <mornfall> Can't you lift the data type into a third file?
03:16:28 <tomh> how do you mean
03:16:33 <ion> mornfall: Ah, okay. I didn‚Äôt know that since i had only worked with strings so far. :-)
03:16:35 <mornfall> Maybe I misunderstood the problem. :)
03:16:48 <mornfall> ion: :-)
03:16:52 <tomh> create a third files that contain operations on both data types?
03:16:58 <tomh> * file
03:17:03 <ion> mornfall: MapValue was a suggestion: a function that gets applied to whatever the user gives.
03:17:48 <mornfall> ion: I see.
03:18:13 <mornfall> ion: Well, I'm still not sure how to handle parsing. Right now, you can override a generic "read" that's used by the parser.
03:18:20 <ddarius> Also, you -very- rarely want the factorial function.
03:18:44 <ski> tomh : sometimes you can make one of the types parametric in a nice way, breaking the recursion
03:18:54 <mornfall> ion: Data a => String -> a
03:19:21 <mornfall> ion: You could look at how readCommon works and even use it in the override.
03:19:24 <mornfall> ion: To that effect.
03:19:35 <mornfall> The problem is that it has to be pure, which is not entirely optimal.
03:19:52 <mornfall> Validation would often want to consult IO...
03:20:22 <mornfall> tomh: I'm not sure where the cycle comes from really.
03:20:37 <mornfall> tomh: You have data A and data B, where B depends on A, and operation c which depends on both A and B.
03:20:41 <mornfall> tomh: Is that right?
03:20:48 <tomh> yeah
03:20:50 <mornfall> In which case you can just have a file for A, file for B and file for c.
03:20:56 <tomh> and A depends on B
03:21:09 <mornfall> Okey, then A and B need to be in a single file.
03:21:09 <amtal> Does trifecta handle newlines specially due to the laidout/layout thing? Should I be using that in order to parse them?
03:21:26 <mornfall> tomh: You can't have mutually recursive data types spread among multiple modules.
03:21:33 <tomh> yeah hmm
03:21:36 <ski> tomh : maybe you should explain how `A' and `B' look in more detail
03:21:40 <Saizan> i don't see why .hs-boot files shouldn't work with ghci
03:21:54 <ion> mornfall: Perhaps the Map function could be simply applied after all the parsing etc. has been done, for instance when you want to turn an ‚Äúa‚Äù into a ‚ÄúMaybe a‚Äù.
03:21:58 <tomh> maybe I just need to refactor my code
03:23:16 <mornfall> tomh: Well, as long as the *types* are mutually recursive, not even hs-boot will help you, I suspect.
03:23:33 <tomh> ok
03:23:35 <mornfall> (as in data A = A B; data B = B A...)
03:23:54 * ski wonders why `hs-boot' wouldn't work with mutually recursive types, but haven't tried
03:23:56 <tomh> Im checking my file now, I suspect that B doesn't depend on A but only A on B
03:24:49 <tomh> ah yeah, then I can use the method mornfall proposed by putting the operations in a third file
03:24:55 <tomh> thanks!
03:25:03 <ski> heh
03:28:48 <mornfall> ski: How would the .hs-boot file look like?
03:29:03 <mornfall> ski: It can't import the other .hs file either.
03:31:00 <mornfall> ‚ÄûIf hs-boot files are considered distinct from their parent source files, and if a {-# SOURCE #-} import is considered to refer to the hs-boot file, then the module import graph must have no cycles.‚Äú
03:31:06 <Saizan> you just have to declare the kind of the type
03:32:32 <mornfall> And the module system somehow figures the kind declaration in the boot file goes with the real type in the non-boot file?
03:32:33 <ski> *nod*, as i suspected
03:33:44 <luite> are there haskell matrix libs with QR factorization that support matrices with Rational and complex rational elements?
03:34:06 <ski> a boot file is more or less a module interface
03:34:50 <ski> (which makes this into the standard way to handle recursive dependencies, unsurprisingly)
03:35:40 <mornfall> ski: Standard for GHC, other compilers use different hacks (if any at all)... ;)
03:37:05 <ski> sorry, i should clarify that : i meant that this bade it into the standard way to handle recursive dependencies, *being* : create an interface to break the cycle, and depend on the interface instead of on the source
03:37:12 <ski> s/bade/made/
03:37:54 <ski> (i didn't mean to imply that the particular way in which GHC does this is standard in any way, only that it's the standard way to solve this kind of problem)
03:40:34 <ddarius> luite: Does hmatrix have QR decomposition?
03:41:07 <luite> yeah but I think it only supports unboxed elements
03:43:09 <ddarius> http://hackage.haskell.org/packages/archive/hmatrix/0.12.0.1/doc/html/Data-Packed-Matrix.html#t:Element
03:43:46 <ddarius> :t undefined :: Complex Rational
03:43:47 <lambdabot> Complex Rational
03:44:07 <ddarius> > cis 2 :: Complex Rational
03:44:08 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
03:44:08 <lambdabot>    arising from a u...
03:44:21 <ddarius> :t (:+)
03:44:22 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
03:44:34 <ddarius> luite: You can't make a Complex Rational.
03:44:39 <ddarius> Well, you can in 2010.
03:44:43 <luite> ddarius: yes that works for Storable things
03:44:59 <elliott> What does 2010 add to let you do it?
03:45:06 <ddarius> elliott: It removes, it doesn't add.
03:45:15 <elliott> Ah. A constraint?
03:45:38 <ddarius> luite: Complex and Rational are both things that could be readily made Storable if they aren't already.
03:46:46 <luite> ddarius: I don't think they can. since the sizeOf method of Storable doesn't use the argument, and Rational doesn't have a fixed size
03:47:10 * ski ponders "rational eisensteinians"
03:47:24 <elliott> Anything can be made Storable.
03:47:31 <elliott> Just use a StablePtr.
03:47:46 <elliott> Memory leaks are an unfortunate implementation detail :P
03:48:00 <ski> elliott : how about `IORef a' ?
03:48:11 <elliott> ski: Like I said: StablePtr
03:48:12 <luite> let's do QR decomposition with pointer matrices
03:48:31 <elliott> ski: (Have you seen http://hpaste.org/53881?)
03:48:32 <ski> elliott : have fun serializing `IORef a's to disk, or over network
03:48:37 <elliott> (I wasn't expecting it to become relevant so quickly.)
03:48:45 <elliott> ski: I don't think Storable instances have to be able to do that.
03:48:50 <elliott> That's what cereal or whatever is for.
03:49:11 <ski> hm, you may be right there :)
03:51:30 <troydm> strange, i'm doing import Control.Monad.State
03:51:50 <troydm> but it still says that data constructor State is not in scope
03:52:23 <ski> it's changed, use `state' instead
03:52:36 <ski> @type State
03:52:37 <lambdabot> Not in scope: data constructor `State'
03:52:38 <ski> @type state
03:52:39 <lambdabot> forall s a. (s -> (a, s)) -> State s a
03:52:55 <ski> @type runState
03:52:56 <lambdabot> forall s a. State s a -> s -> (a, s)
03:53:09 <ski> (use `runState' instead of matching on `State')
03:54:07 <ski> @type case state random of StateT foo -> foo  -- or match on `StateT' instead
03:54:08 <lambdabot> forall s a. (Random a, RandomGen s) => s -> Identity (a, s)
03:54:17 <troydm> ski: i don't quite get it , so it's name changed or it's usage too ?
03:54:36 <ski> `State' has been redefined as `type State s a = StateT s Identity a'
03:55:00 <ski> usage is same, except the data constructor `State' doesn't exist anymore
03:55:42 <troydm> ski: i i get it ok
03:56:08 <ski> @type state random
03:56:09 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
03:56:21 <ski> @type state random :: StateT s Identity a
03:56:22 <lambdabot>     Could not deduce (Random a, RandomGen s) from the context ()
03:56:22 <lambdabot>       arising from a use of `random' at <interactive>:1:6-11
03:56:22 <lambdabot>     Possible fix:
03:56:32 <ski> @type state random :: (Random a,RandomGen s) => StateT s Identity a
03:56:33 <lambdabot> forall s a. (RandomGen s, Random a) => StateT s Identity a
04:04:31 <iboB> is there a way to write a single string on several lines of code?
04:04:44 <hpc> "first part\
04:04:48 <hpc> \second part"
04:05:03 <iboB> hpc: thanks
04:05:05 <ddarius> > "sma\                                          \ll"
04:05:06 <lambdabot>   "small"
04:05:09 <hpc> you can put whatever you want between the first '\' and the second, like if you want things to be aligned
04:05:17 <elliott> "sma\      \&   \\&ll"
04:05:20 <elliott> > "sma\      \&   \\&ll"
04:05:21 <lambdabot>   "sma&   \\&ll"
04:05:24 <elliott> :(
04:06:09 <ddarius> > "sma\      e      \ll"
04:06:10 <lambdabot>   <no location info>:
04:06:10 <lambdabot>      lexical error in string/character literal at chara...
04:06:18 <ddarius> You can put any -whitespace- between the \s.
04:06:20 <ski> hpc : only whitespace
04:06:59 <ddarius> @google design patterns as higher-order datatype-generic programs
04:07:01 <lambdabot> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/hodgp.pdf
04:07:01 <lambdabot> Title: Design Patterns as Higher-Order Datatype-Generic Programs
04:07:02 <ski> > "\013"
04:07:03 <ski> > "\01\&3"
04:07:03 <lambdabot>   "\r"
04:07:04 <lambdabot>   "\SOH3"
04:07:18 <elliott> I wonder who actually came up with \&.
04:07:32 <elliott> Did someone sit down and decide to invent the Best String Escape Language?
04:07:51 <drbean> That's better than "str" ++ "ing"
04:08:00 <ski> `\&' is for breaking something which would otherwise be interpreted as a longer escape sequence
04:08:23 <elliott> ski: yep, just have to wonder who came up with it
04:08:30 <elliott> I can safely say I'd have never have independently thought of the need for that on my own :P
04:09:12 <ddarius> It's not necessary.  It's just slightly convenient.
04:09:13 <ski> i suspect that when they wrote `show' and `read' for strings, they saw the need for something like that
04:10:01 <ski> > map chr [1,14]
04:10:02 <lambdabot>   "\SOH\SO"
04:10:08 <ddarius> > "\1234\3456"
04:10:09 <lambdabot>   "\1234\3456"
04:10:45 <ddarius> > "\1234\49"
04:10:46 <lambdabot>   "\1234\&1"
04:10:57 <ski> > map (map ord) ["\SOH","\SO\&H"]
04:10:58 <lambdabot>   [[1],[14,72]]
04:11:32 <ski> > length "\12341"
04:11:32 <lambdabot>   1
04:13:12 <ddarius> @google "Foundations of Inference"
04:13:13 <lambdabot> http://arxiv.org/abs/1008.4831
04:13:44 <ski> > "\BEL\BS\HT\LF\VT\FF\CR"
04:13:46 <lambdabot>   "\a\b\t\n\v\f\r"
04:14:01 <iboB> can I match a pattern for a list, shorter than 4 elemenst (i mean besides explicitly matching 3, 2, 1, and 0)
04:14:02 <alistra> "\a"
04:14:06 <alistra> > "\a"
04:14:07 <lambdabot>   "\a"
04:14:16 <ski> @read "\a"
04:14:17 <lambdabot>  
04:14:27 <alistra> oh
04:14:41 <alistra> it probably beeped somewhere :D
04:15:13 <ddarius> > text "\a"
04:15:23 <ski> iboB : one way is to first match on `a0:a1:a2:a3:as', and in the next pattern match on `as', which will now not be more than three elements
04:15:46 <iboB> ah... of course :) thanks, ski
04:16:25 * KitB just tried a bell character on the lambdabot running on a machine in the room he's in
04:16:28 <KitB> No beep
04:16:48 <alistra> :|
04:16:49 <ski> presumably they filter out most control characters :)
04:17:00 <alistra> but does your echo beep?
04:17:04 <alistra> when printing \a
04:17:18 <alistra> echo -e '\a'
04:17:22 <ddarius> > let f (splitAt 4 -> (xs,[])) = xs in map f . iterate ('a':) []
04:17:22 <lambdabot>   Couldn't match expected type `[a]'
04:17:22 <lambdabot>         against inferred type `GHC.Types...
04:17:32 <ddarius> > let f (splitAt 4 -> (xs,[])) = xs in map f $ iterate ('a':) []
04:17:33 <lambdabot>   ["","a","aa","aaa","aaaa","*Exception: <interactive>:3:4-32: Non-exhaustive...
04:17:47 <KitB> No it does not
04:17:54 <KitB> But that was over ssh
04:18:27 <ski> iboB : ddarius's way is more composable
04:18:54 <iboB> ski, but yours is much more readable and works for me :)
04:19:07 * ski first read "ssh" as "rsh" wondering KitB was using that ..
04:19:57 <KitB> :D
04:21:56 <Nimatek> KitB: Have you tried running lambdabot on networks other than freenode? I have noticed that it doesn't send messages to channels on mibbit, for some reason.
04:26:18 <troydm> is a <- Just 1 a valid expression
04:26:30 <troydm> Just 1 <- is monad yes?
04:26:37 <ski> it's not an expression, no
04:26:52 <ski> `a <- Just 1' is a command, just as `Just 1 <- a' is
04:27:02 <ddarius> "stmt"
04:27:08 <hpc> is that what it's called?
04:27:08 <troydm> statement ?
04:27:08 <ski> i.e. a command to be put inside a `do'-expression, or in GHCi
04:27:22 <troydm> is it a valid do statement ?
04:27:25 <hpc> "a <- Just 1" translates into "Just 1 >>= \a ->"
04:27:30 <ski> troydm : yes
04:27:40 <ddarius> The report doesn't actually give it a name, but the non-terminal in the syntax is stmt.
04:27:41 <hpc> "Just 1 >>= \a ->" is /part/ of an expression
04:28:00 <ski> ddarius : yes, i know. i prefer the general term "command", though :)
04:28:23 <ddarius> ski: I think command is a bit misleading here.
04:28:38 <ski> (to me, a statement is something declarative, like a Prolog clause, or maybe an equation clause defining a value in Haskell could also be called a statement)
04:28:41 <ddarius> Particularly as a discussion of syntax.
04:28:43 <troydm> http://hpaste.org/53923
04:28:54 <ski> ddarius : ok, any rationale ?
04:28:56 <troydm> ok can any1 explain me why it's invalid ?
04:28:57 <ddarius> ski: Declarations are declarative.
04:29:23 <Taejo> :t const const
04:29:24 <lambdabot> forall a b b1. b1 -> a -> b -> a
04:29:32 <ddarius> ski: I would likely call, e.g. putStrLn "foo" a "command", but that is also definitely an expression.
04:29:56 <ski> ddarius : sure, because it's also a "stmt"
04:30:09 <ddarius> Only because expressions are included in statements.
04:30:54 <ski> troydm : using `a <- Just 1' implies that the monad you're using is `Maybe'
04:31:11 <troydm> ski: yes that's right
04:31:11 <ski> troydm : the monad can't be both `Maybe' and `State Stack' at the same time
04:31:12 <ddarius> Also, even for a <- Just 1, I wouldn't call the whole thing a command, I'd call just the "Just 1" part the command.
04:31:27 <moriramar> tromp, You need a runIdentity to get the final number.
04:31:31 <ski> troydm : maybe you meant `let a = 1' instead ?
04:31:39 <troydm> ski: so type of the Monad in do must be the same for all commands ?
04:31:50 <troydm> ski: did i spelled it correctly ?
04:32:06 <moriramar> tromp, sorry, wrong person...
04:32:08 <ski> well, the monad *is* the type (plus the instance)
04:32:18 <ski> troydm : but, yes
04:32:24 <ski> (did you spell what correctly ?)
04:33:15 <troydm> statements in do are called commands
04:33:25 <ski> they are by me, yes
04:34:12 <KitB> Nimatek: I've got it running on my uni network
04:34:26 <ski> ddarius : ok
04:35:54 <mreh> are there tools to compile a large hoogle database from all of my cabal packages?
04:36:02 * ddarius expounds the importance and fundamental nature of monotonic strictly increasing regrades of addition.
04:36:40 * hackagebot aivika 0.2 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.2 (DavidSorokin)
04:37:52 <ski> regrades ?
04:46:41 * hackagebot timing-convenience 0.1 - Convenient functions for getting times.  http://hackage.haskell.org/package/timing-convenience-0.1 (MikeBurns)
04:57:45 <hpaste> ibob pasted ‚Äúpartitions‚Äù at http://hpaste.org/53924
04:58:04 <iboB> so this gives the integer partitions of n into ps parts
04:58:19 <iboB> is there a way of making the function return tuples instead of lists?
04:59:03 <mike-burns> A list of tuples?
04:59:08 <iboB> yes
04:59:11 <elliott> iboB: no
04:59:36 <iboB> aw :| ... thanks :)
05:00:14 <elliott> iboB: if you ever call partitions with a varying argument you couldn't process the resulting tuples anyway
05:00:28 <danr> Where is a complete list of the haskell operator symbols?
05:00:43 <iboB> yeah... i figured that, but i thought there might exist some magic, that i don't know of
05:00:48 <danr> found one on http://stackoverflow.com/questions/2480974/what-is-the-difference-between-an-operator-and-a-function-in-haskell
05:02:17 <elliott> danr: the haskell report :)
05:03:07 <geheimdienst> iboB: tuples and lists may look similar, but they actually play different roles. a function that processes a list of any length is very normal (map, foldr, ...), but that is uncommon or impossible for tuples
05:03:21 <danr> elliott: but of course! found this: ascSymbol -> ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @
05:03:23 <geheimdienst> iboB: you could think of tuples as "records whose fields have no names" ... you can see how processing all fields in a record is something a little weird
05:03:37 <ddarius> @where report
05:03:37 <lambdabot> http://www.haskell.org/onlinereport/
05:03:38 <elliott> danr: note that that omits :, the only uppercase symbol :)
05:03:48 <elliott> Hmm, that's out of date.
05:04:09 <elliott> @where+ report http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:04:09 <lambdabot> It is stored.
05:04:26 <ddarius> danr: That's just ASCII symbols.  Operator characters are not limited to ASCII.
05:04:51 * elliott suspected something like that, but couldn't find anything in the grammar to prove it from a cursory glance
05:05:01 <iboB> geheimdienst i know that, it sounded nice to me to have the partitions of an integer into n parts into n-tuples
05:05:18 <iboB> it's just that haskell doesn't allow n-tuples to be constructed this way
05:05:37 <danr> ddarius: that's of course true, but right now I'm just focusing on ascii symbols
05:05:49 <geheimdienst> danr: unlike other languages, haskell doesn't have a small, fixed number of operators. anyone and any library can define operators (they are "just regular functions that are written between their first 2 arguments"). if you're wondering about any particular one, use hoogle or hayoo
05:05:57 <geheimdienst> @where hoogle
05:05:57 <lambdabot> http://haskell.org/hoogle
05:06:01 <geheimdienst> @where hayoo
05:06:01 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:06:25 <ddarius> danr: Your list is incomplete anyway.  See the beginning of section 2.2 in the report.
05:07:23 <geheimdienst> iboB: yeah, haskell doesn't allow that. you can also see that from thinking about what type your partitions function would have: is it "... -> [(a,b)]"? or "... -> [(a,b,c)]"? or what?
05:07:42 <geheimdienst> so it's impossible on that level as well
05:08:31 <geheimdienst> :t fst
05:08:32 <lambdabot> forall a b. (a, b) -> a
05:08:34 <geheimdienst> :t fst3
05:08:35 <lambdabot> Not in scope: `fst3'
05:08:45 <danr> geheimdienst: thanks, and I know that
05:08:47 <iboB> geheimdienst, sure and that's why i asked (still a newb and don't know what magic to expect)
05:09:07 <_Mikey> :t float
05:09:09 <lambdabot> Float -> Doc
05:10:08 <geheimdienst> iboB: some packages define a function fst3 :: (a,b,c) -> a. note that is an entirely different function from fst, and there's no way to reconcile the two
05:10:33 <ddarius> @google "zip calculus"
05:10:34 <lambdabot> http://www.cs.yale.edu/~tullsen/zip-rr.ps
05:10:36 <iboB> is there a way to sum a bunch of Int's that have a sum bigger than Int can hold, without having to "map (\x -> fromIntegral x :: Int64) ints"
05:10:38 * elliott thinks that by the time you need fst3 you've already lost
05:12:39 <ddarius> iboB: No.
05:12:49 <iboB> thanks
05:13:37 <ddarius> I guess you could calculate an average and then do a multiply at the end at a higher precision.
05:14:53 <geheimdienst> iboB: Integer is arbitrary length. you can convert from Int to Integer using fromIntegral
05:15:04 <geheimdienst> > let x = maxBound :: Int in 2*(fromIntegral x :: Integer)
05:15:04 <lambdabot>   18446744073709551614
05:15:09 <geheimdienst> > let x = maxBound :: Int in 2*(x)
05:15:10 <lambdabot>   -2
05:15:33 <ddarius> geheimdienst: That's not his problem.
05:15:43 <ddarius> Admittedly, his problem isn't really a problem in my opinion.
05:15:48 <iboB> geheimdienst yes... i wanted to avoid a needless map
05:16:11 <iboB> well wouldn't this map needlessly slow the program?
05:16:33 <ddarius> iboB: It will probably get fused.
05:16:54 <ddarius> Even if it didn't, the thing to do would be to manually fuse the sum and the map.
05:19:08 <ddarius> Except that it probably really wouldn't be worthwhile to make this optimization manually.
05:35:38 <iboB> er... can someone please run this http://hpaste.org/53925
05:35:52 <iboB> and then "primes !! 18293"
05:36:05 <iboB> i wonder could this be a bug in my compiler
05:36:24 <iboB> i can't figure out what could be wrong with this algorithm
05:36:38 <iboB> but it somehow fails to find the 18293-rd prime number
05:37:42 <Guest18407> hi all!
05:41:11 <ddarius> iboB: It should take overwhelming evidence before you conclude that you are running into a bug in a twenty year old compiler.
05:41:38 <iboB> well still how come it fails on the 18293-rd prime? :)
05:42:20 <ddarius> First off, define "fails."
05:42:27 <iboB> it doesn't find it
05:42:44 <ddarius> Define "doesn't find it."
05:42:48 <iboB> it finds the 18292-nd and the next prime number it finds is the 18294th
05:42:50 <Lemmih> iboB: Does it find the wrong number or does it explode?
05:43:13 <ddarius> iboB: So your algorithm is wrong.  That seems by far the most likely explanation.
05:43:14 <iboB> it just skips the 18293-rd prime number
05:43:44 <iboB> it's a pretty weird way to be wrong
05:44:09 <ddarius> So?
05:44:14 <iboB> i know it sounds pretentious but a bug in IntMap or something looks much more likely to me
05:44:19 <ddarius> It's a pretty weird way for a compiler bug to manifest itself.
05:44:30 <iboB> well it could be a library bug
05:44:42 <iboB> or a memory leak
05:44:44 <iboB> i don't know
05:44:45 <geheimdienst> iboB: how about the first 18,000 primes, does it give expected results?
05:44:49 <iboB> yes
05:44:52 <ddarius> iboB: Yes, a library bug is more likely than a compiler bug, but still less likely than your code being wrong.
05:45:01 <iboB> it works fine up until prime !! 18293
05:45:08 <ddarius> Why would a memory leak be relevant?
05:45:34 <Lemmih> iboB: It works on my box.
05:45:54 <iboB> the algorithm stores prime iterators, if a prime iterator get corrupted it could decide that a number that's not prime is prime
05:46:07 <iboB> Lemmih what's prime !! 18293 on your box?
05:46:40 <Lemmih> iboB: take 4 $ drop 18291 primes  =>  [203869,203873,203897,203909]
05:47:07 <ddarius> iboB: "Memory leak" simply means memory is not being reclaimed that should be.  It will never cause incorrect functioning, just premature failure.
05:47:21 <iboB> weird
05:47:34 <iboB> i get [203869,203873,203909,203911]
05:47:35 <ddarius> I also omitted the other much more likely than compiler or library bug, user error.
05:48:02 * Lemmih also votes on user error.
05:48:07 <iboB> er...
05:48:13 <iboB> i just told you
05:48:27 <iboB> on  take 4 $ drop 18291 primes i get [203869,203873,203909,203911]
05:48:29 <geheimdienst> Lemmih: on my system take 4 $ drop 18291 primes gives [203869,203873,203909,203911]
05:48:38 <iboB> which is wrong
05:48:48 <iboB> Lemmih is right
05:48:48 <ddarius> It's probably a 32-bit v. 64-bit thing.
05:48:50 <Lemmih> Are both of you using 32bit boxes?
05:48:55 <iboB> i am yes
05:49:10 <geheimdienst> yeah
05:49:11 <ddarius> > 203873^2
05:49:12 <lambdabot>   41564200129
05:49:29 <ski> > 2^32
05:49:30 <lambdabot>   4294967296
05:49:52 <ddarius> Found the problem.  The program is wrong.
05:50:07 <iboB> ah yes
05:50:09 <ClaudiusMaximus> > 203873^2 :: Int32
05:50:10 <lambdabot>   -1385472831
05:50:16 <iboB> yes yes i got it :)
05:50:17 * ski originally thought of suggesting to use `Integer' ..
05:50:18 <iboB> thanks
05:50:36 <iboB> of course
05:50:38 <geheimdienst> iboB: so at some point you use an Int (machine-size integer), where you wanted Integer (arbitrary-size). that's the direction you should be looking
05:50:40 <iboB> thanks
05:51:34 <iboB> isn't Integer very slow? i should probably use Int64
05:52:24 <ski> better safe than sorry ?
05:52:44 <Axman6> iboB: not very slow, no
05:52:53 <ski> (or make sure to determine up to which bound your algorithm is correct)
05:52:56 <ddarius> Yes, I'm sure iboB needs the fastest prime number generator for integers representable in less than 32-bits.
05:53:07 <silver> iboB, well, Integer C backend is pretty fast library
05:53:11 <Axman6> obviously slower than Int64, but its damn fast when you realise what it actually has to do
05:53:51 <geheimdienst> iboB: i recommend to not worry about slowness until you've done some measuring. just do the simplest, safest thing as long as you can
05:54:12 <ion> ‚ÄúIsn‚Äôt Haskell very slow? I should probably use the machine code my CPU runs natively after translating x86 instructions to it.‚Äù
05:54:22 <ddarius> ion: Damn straight.
05:54:27 <iboB> well the simplest safest thing i did before this algorithm took about 40 seconds to calculate prime !! 18000
05:54:51 <silver> :O
05:55:25 <iboB> slowsieve (p:ps) = p : slowsieve (filter (`ndivisible` p) ps) where ndivisible a b = a `mod` b /= 0
05:55:26 <iboB> :)
05:55:27 <ddarius> iboB: It's not even clear that that is a problem since you haven't said what you need this for.  Also, I'm pretty sure you have some performance problems in your current code regardless of integer size.
05:55:43 <Axman6> iboB: Integer is implemented as Int for values that are prepresentable as Ints btw
05:55:48 <iboB> ddarius i'm sure of it, too
05:55:49 <silver> iboB, Ints won't solve your proble here
05:55:58 <iboB> i just want it to run in an acceptable ammount of time
05:56:09 <silver> modify algorithm
05:56:10 <ion> > let isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime [3,5..] in primes !! 18000
05:56:13 <ddarius> iboB: Define "acceptable amount of time."
05:56:14 <lambdabot>   200191
05:56:47 <silver> ion, nice
05:56:52 <iboB> ddarius "me not having to wait a long time, where "a long time" is what I, personally feel is a long time"
05:56:56 <Axman6> iboB: use rem for maor speed
05:56:57 <ddarius> > nubBy((>1).gcd)[2..]!!18000
05:56:57 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:56:57 <lambdabot>         against inferred ...
05:56:59 <Axman6> uh, ion
05:57:02 <Axman6> but iboB too
05:57:03 <ion> Not mine. I think it‚Äôs Cale‚Äôs, at least he has been using it.
05:57:05 <ddarius> > nubBy(((>1).).gcd)[2..]!!18000
05:57:09 <lambdabot>   mueval-core: Time limit exceeded
05:57:14 <ddarius> iboB: Wait for a long time to do what?
05:57:32 <iboB> to find prime !! 18000
05:57:34 <iboB> obviously
05:57:35 <iboB> :)
05:57:50 <Axman6> ion: i'm not sure if cale stole that from me or not. i remember implementing it ages ago, and i think he liked the mutual recursion
05:57:54 <geheimdienst> iboB: you did the right thing then -- first try it safely, when noticing it's too slow, start measuring and optimizing. just remember to compare those 40 seconds to the time (minutes? hours?) that you put into developing a faster version
05:58:09 * ski . o O ( `prime !! infinity' )
05:58:11 <ddarius> prime = replicate 18000 0 ++ [200191]
05:58:54 <TomvdZ> Could anybody get me started on how to mix IO with a state Monad? I'm looking for a way to tuple the two together.
05:58:54 <silver> there are also:
05:58:59 <silver> 1. http://en.wikipedia.org/wiki/Sieve_of_Atkin
05:59:03 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 18000
05:59:06 <lambdabot>   200191
05:59:10 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 180000
05:59:12 <iboB> geheimdienst, you're right, but since i do this for fun, the time spent optimizing a program that takes 40 seconds is time well spent for me, even if its hours and days
05:59:14 <lambdabot>   mueval-core: Time limit exceeded
05:59:20 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 20000
05:59:24 <lambdabot>   224743
05:59:34 <ski> Axman6 : hehe, i made a version that had `primes' and `composites' mutually recursive
05:59:40 <silver> 2. http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
05:59:54 <silver> (if you want to go pro :))
05:59:57 <ski> @karma+ silver
05:59:58 <lambdabot> silver's karma raised to 1.
06:00:29 <silver> :O
06:00:38 <ski> TomvdZ : you possibly want to use `StateT MyState IO MyResult'
06:00:54 <Axman6> I love that you can do shit like that in haskell. "Just assume you have a list of primes handy, and write a function which uses it to check if a number is prime... oh and by the way, the isPrime function will be used to calculate the primes list"
06:01:23 <ski> (silver : for the O'Neill reference)
06:01:34 <Axman6> hey did anyone else see the 'writing a faster wc -l in factor' thing on reddit?
06:01:52 <Axman6> I managed to write a version of wc -l in Haskell that's faster than wc -l =)
06:02:00 <Axman6> yay for iteratees
06:02:07 <TomvdZ> Thanks, I think that's what I was looking for
06:02:21 <geheimdienst> Axman6++ nice. do you have the code somewhere? i'd love to have a look at it
06:02:46 <ddarius> Axman6: Stream Natural ~ Natural -> Natural, so Natural primes(Natural n) { ... isPrime ... }; bool isPrime(Natural n) { ... primes ... }
06:03:11 <ddarius> Axman6: Now add all the other features of wc.
06:03:37 <Axman6> no :(
06:03:47 <Axman6> I could though, it wouldn't be too hard
06:05:16 <gbacon> if ghc-pkg list reports a package being installed, why wouldn't ghc be able to import a module defined in that package?
06:05:26 <Axman6> Also, it only handles unix newlines
06:07:38 <geheimdienst> gbacon: it might be hidden, for examples. ghc-pkg list prints hidden packages in blue
06:08:22 <gbacon> geheimdienst: the package in question is xmonad-contrib, and I've been rebuilding it all morning
06:08:44 <gbacon> been rebuilding xmonad.hs, that is
06:09:12 <iboB> Axman6 nice one, but still about 3 times slower than mine :P
06:09:47 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 180000 :: Int
06:09:51 <lambdabot>   mueval-core: Time limit exceeded
06:09:56 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 18000 :: Int
06:09:59 <lambdabot>   200191
06:10:07 <gbacon> geheimdienst: I installed yeganesh this morning. Could that have somehow hidden xmonad-contrib?
06:10:08 <Axman6> hmm, that's probably wrong
06:10:10 <geheimdienst> gbacon: try to give it some verbose switches
06:10:14 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 18000
06:10:18 <lambdabot>   200191
06:10:22 <Axman6> huh
06:10:26 <Axman6> or not =)
06:10:31 <iboB> it's not wrong
06:10:42 <geheimdienst> gbacon: sometimes a package gets broken when installing something. does ghc-pkg check say anything?
06:10:43 <Axman6> > let isPrime n = all (\p -> n `rem` p /= 0) . takeWhile (\p -> p*p <= n) $ primes; primes = 2 : filter isPrime  [3,5..] in primes !! 24000
06:10:46 <lambdabot>   mueval-core: Time limit exceeded
06:10:51 <Axman6> :(
06:12:23 <gbacon> geheimdienst: no output from ghc-pkg check, and ghc-pkg check -v outputs only the global cache and my private cache
06:15:25 <gbacon> geheimdienst: wading through ghci -v output, xmonad-contrib is missing due to dependency problems (X11-xft, directory, process, and xmonad)
06:15:25 <hpaste> Axman6 pasted ‚Äúwc -l‚Äù at http://hpaste.org/53926
06:15:26 <iboB> Axman6 on my machine your algorithm takes about 40 seconds to get prime !! 120000, while mine takes about 12 :P
06:15:42 <Axman6> sure, it's not a great algorithm
06:15:47 <iboB> (fixed with Int64)
06:16:01 <iboB> for which I thank everybody that helped!
06:16:12 <Cale> TomvdZ: The most common answer is that you don't. You use runState to get results from your State computation which are pure, and then print those or whatever.
06:16:18 <Axman6> geheimdienst: see the hpaste link above
06:16:40 <Cale> TomvdZ: But there are options like using StateT over IO -- they just don't tend to be very necessary
06:16:53 <gbacon> geheimdienst: and I see process installed globally and in my private library; could these be conflicting? (I've tried to keep all the global stuff managed by apt.)
06:16:56 <Cale> The IO monad already has tons and tons of state available to use :)
06:17:11 <Axman6> or, having IO () as part of yout state, and building up an IO action using >>
06:17:12 <Axman6> >_>
06:17:27 <gbacon> maybe unregister the user package?
06:18:17 <TomvdZ> I want to couple IO as part of networking communication with storing the server state. StateT (first time I've heard about it) sounds appealing to me and I'm not sure how to avoid it
06:19:58 <ddarius> In many networking applications, I would just store the state in parameters.
06:20:00 <ion> You could store server state on the stack.
06:20:30 <geheimdienst> Axman6: thanks, awesome
06:20:43 <geheimdienst> gbacon: sorry gotta go afk, i'll be back later today
06:20:44 <ion> loop state = do p <- receivePacket; ‚Ä¶; loop newState
06:20:55 <gbacon> geheimdienst: thanks for the pointers
06:21:13 <geheimdienst> others in here should be able to help you :)
06:21:15 <TomvdZ> oh thanks that's brilliant
06:21:22 <galagala> When I try to run this i get the error Malformed instance header: show. "data Br¯k = Br¯k Int Int deriving(show)". Any ideas? :)
06:21:46 <roconnor> deriving (Show)
06:22:09 <Axman6> case is important
06:22:10 <ddarius> I've actually never seen that error before.
06:22:29 <galagala> ah thanks!
06:23:34 <incluye> There's no operation that I can do to get an [IO String] out of an IO String, I have to deal with IO [String], right?
06:23:57 <Axman6> eh?
06:24:14 <Axman6> IO String -> [IO String]? o.O
06:24:25 <ddarius> : (:[]) :: IO String -> [IO String]
06:24:32 <ddarius> :t (:[]) :: IO String -> [IO String]
06:24:33 <lambdabot> IO String -> [IO String]
06:24:48 <Axman6> monkey saves the day again
06:25:00 <hpc> heh
06:25:09 <ion> I‚Äôve never seen that as a monkey. More like a robot.
06:25:13 <ocharles> Hey, I'm having some problems with overlapping instances in HaskellDB (I'm trying to make a field polymorphic)... This is the error I get: https://gist.github.com/1359752
06:25:20 <ddarius> @google "robot monkey operator"
06:25:22 <lambdabot> http://www.reddit.com/r/haskell/comments/i1l2g/haskell_the_craft_of_functional_programming_3rd/
06:25:22 <lambdabot> Title: Haskell: the Craft of Functional Programming, 3rd edition is out! : haskell
06:25:25 <ocharles> What I don't get is what "[overlap ok]" means on each of the matching instances
06:26:54 <ocharles> https://gist.github.com/1359750 is the code in question. If I change the type of `branch` to Ref (Revision Book), the problems go away (though it's more specific than what I want)
06:28:32 <boegel> hiya y'all
06:29:09 <ion> hiya all y‚Äôall you
06:30:23 <min> you forgot the plural: hiya alls y'alls youse
06:30:31 <rotflcopter> hey ion
06:30:37 <rotflcopter> whats with quarks?
06:31:00 <ion> Quark‚Äôs is a fine restaurant for gentlemen.
06:31:18 <ion> Say hi to Morn for me.
06:31:34 <rotflcopter> ;<
06:31:42 * hackagebot generic-binary 1.0.1 - Generic Data.Binary derivation using GHC generics.  http://hackage.haskell.org/package/generic-binary-1.0.1 (SebastiaanVisser)
06:31:49 <incluye> wow I did a terrible job of explaining myself
06:32:02 <incluye> I wanted to apply "lines" to an IO String
06:32:05 <rotflcopter> os my circle rasterization function is ready for unlimited number of cores? :(
06:32:16 <incluye> and get a list of IO Strings back rather than an IO [String]
06:32:18 <incluye> which seems dirtier
06:32:22 <Axman6> incluye: see fmap
06:32:27 <monochrom> that's fmap lines your_IO_String_here
06:32:31 <sipa> :t fmap lines
06:32:32 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f [String]
06:32:33 <Axman6> :t fmap lines getLine
06:32:33 <lambdabot> IO [String]
06:32:36 <incluye> Huh
06:32:43 <incluye> yeah, there you go.
06:32:45 <monochrom> aka lines <$> your_IO_String_here
06:32:52 <incluye> That's what I have right now
06:33:02 <sipa> that way you get IO [String], of course
06:33:05 <incluye> right
06:33:11 <incluye> hence my question
06:33:27 <incluye> I don't know which would be more convenient to work with
06:33:30 <rotflcopter> it would be nice to plot a whole circle in 3 clock ticks
06:33:54 <ion> incluye: Which one of the reulting IO actions in the [IO String] would run the side effects of the original input action?
06:34:12 <ddarius> ion: First question.  How many elements are in that list?
06:34:15 <incluye> well, I have no idea
06:34:35 <incluye> I have more learning to do
06:34:56 <ion> As for convenience, the IO [String] is certainly more convenient.
06:35:02 <incluye> Right.
06:35:05 <incluye> okay
06:35:35 <ddarius> incluye: Your problem is the way you are viewing IO.  There is no String in a value of type IO String.
06:35:51 <ion> If you end up having [IO String] for some reason, you usually find it useful to convert it into IO [String] using sequence.
06:36:06 <ion> @type sequence `asAppliedTo` (undefined :: [IO String])
06:36:08 <lambdabot> [IO String] -> IO [String]
06:36:13 <incluye> oh okay
06:36:15 <incluye> neat
06:37:02 <rotflcopter> ahm i need further improvements in my algorithm if circle is too small ;/
06:37:59 <rotflcopter> (attempting infinite resolution anti-aliased rasterization of vectorgraphic function with alpha channel)
06:48:52 <hpaste> chrisdone pasted ‚Äúcabal baffling‚Äù at http://hpaste.org/53928
06:49:38 <chrisdone> is there a special way of interpreting the pasted cabal message so that it make senses?
06:50:23 <chrisdone> cabal: dependencies conflict: ghc-7.0.4 requires filepath ==1.2.0.0 however filepath-1.2.0.0 was excluded because ghc-7.0.4 requires filepath ==1.1.0.4
06:51:58 <ski> Axman6 : `fmap lines getLine' :D
06:52:07 <monochrom> yes, you installed too many packages
06:52:48 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon has an example
06:54:05 <monochrom> my http://www.mail-archive.com/haskell@haskell.org/msg23784.html is another
06:55:28 * ddarius doesn't understand ski's amusement.
06:58:45 <ski> ddarius : it's funny to apply `lines' to a string definitely not containing any newlines
07:00:10 <monochrom> oh, I see now. but I was hoping getLine was a stand-in for another IO String command
07:00:25 <ski> it probably was
07:05:30 <reynir> javascript > haskell
07:05:45 <monochrom> > "javascript" > "haskell"
07:05:46 <lambdabot>   True
07:05:48 <monochrom> yes
07:06:12 <reynir> ^^
07:06:13 <ski> > "sml" > "javascript"
07:06:14 <lambdabot>   True
07:06:33 <monochrom> > sort ["haskell", "c", "javascript", "perl", "php"]
07:06:33 <ski> > "sml" > "ECMAscript"
07:06:34 <lambdabot>   ["c","haskell","javascript","perl","php"]
07:06:34 <hpc> > "xml" > "sml"
07:06:37 <lambdabot>   True
07:06:37 <lambdabot>   True
07:06:37 <silver> > "c" > "sml"
07:06:38 <lambdabot>   False
07:06:43 <silver> aww
07:06:57 <hpc> > "xslt" > "haskell"
07:06:58 <lambdabot>   True
07:07:04 <chrisdone> monochrom: going by speed, that sort seems accurate ;p
07:07:18 <monochrom> > all ("php" >) ["haskell", "c", "javascript", "perl"]
07:07:19 <lambdabot>   True
07:07:53 <reynir> you guys are funny :)
07:08:53 * monochrom writes paper "running time correlated to language name"
07:09:02 <Sgeo|web> Guess I should learn PHP then. Anyone know good PHP tutorials geared towards Haskell programmers?
07:09:14 <_Mikey> oooh
07:09:22 <chrisdone> monochrom: going by the computer language shootout, yeah
07:09:51 <Sgeo|web> Was B faster than C?
07:09:57 <monochrom> yes! http://www.amazon.com/PHP-For-Real-Programmers/dp/1593272839/
07:10:43 <reynir> woot monochrom
07:11:51 <Sgeo|web> I'd say monochrom++, but that might be looked down upon here
07:12:12 <byorgey> what? why would it be?
07:12:23 <ski> Sgeo|web : there's the `karma+' command, if you prefer
07:12:29 <byorgey> also, you just DID say it.
07:12:39 * Sgeo|web was trying to be humorous :
07:12:41 <Sgeo|web> :/
07:12:57 <byorgey> ah. sorry. =)
07:13:14 <jpcooper> hello
07:13:18 <Sgeo|web> Bluh, if people don't get the joke, it's not a good joke
07:13:39 <Sgeo|web> @karma+ monochrom
07:13:39 <lambdabot> monochrom's karma raised to 29.
07:13:49 <byorgey> hi jpcooper
07:14:17 <jpcooper> I've set library-profiling: True in my ~/.cabal/config, however, when I do cabal install -reinstall mtl, and try to compile with profiling a programme that requires mtl, it is not finding the profiling libraries. Could it be that cabal is reading its config from somewhere else?
07:14:26 <jpcooper> or maybe there's another problem?
07:16:00 <hpc> @quote hpc incompleteness
07:16:00 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
07:16:27 <hpaste> chrisdone pasted ‚Äúconfy build‚Äù at http://hpaste.org/53929
07:16:29 <chrisdone> monochrom: so i have a perfect build process on GHC 6.12.3. i want to upgrade to 7.0.4. enumerating the problems that can occur, we've got: ghc dependence on libraries like containers, mtl, time, ones like that. we've got, actual compile errors, all the packages that I use requiring a base and/or containers/mtl version bump. think of any other problems?
07:16:57 <chrisdone> monochrom: (fwiw: http://hpaste.org/raw/53929 )
07:27:17 <chrisdone> god i hate cabal
07:29:26 <luite> hm
07:34:56 <monochrom> since GHC 7.0.x has been around for a long time, hackage packages are mostly up-to-date for it, so version bump already solves most problems
07:36:20 <FUZxxl> Is haskell-cafe an appropriate mailinglist for asking questions related to jargon in languages other than English?
07:36:31 <monochrom> yes
07:39:55 <monochrom> ghc doesn't depend on mtl
07:41:18 <iboB> if i'm searchig for a value in a list how do i get the value just before that (ie find (>6) [1,3..] -- i need 5)
07:41:52 <iboB> the last value that doesn't break the condition
07:42:21 <hjulle> Configure fails for me when i try to install ghc-7.0.03, binary version (x86) :/
07:42:25 <monochrom> takeWhile (<= 6), then last
07:43:00 <iboB> monochrom thanks :) i was hoping there would be an easier way
07:43:13 <hpc> :t dropUntil
07:43:14 <lambdabot> Not in scope: `dropUntil'
07:43:29 <hpaste> hjulle pasted ‚ÄúError on configure‚Äù at http://hpaste.org/53930
07:45:00 <monochrom> that's odd. I got no such error when I installed ghc 7.0.3
07:45:03 <iboB> hpc dropUntil seems a bit more convenient, but google doesn't help me with what to import
07:46:04 <monochrom> disk full when you untarred the tarball?
07:46:10 <paolino> iboB: zip the list with its tail
07:46:13 <dgpratt> hmm...seems Haskell for Vim is not a binary choice...
07:46:46 <dgpratt> for those of you who use Vim, what do you use for Haskell?
07:46:57 <hpc> :t find (second (> 6)) . zip`ap`tail
07:46:58 <lambdabot>     Precedence parsing error
07:46:58 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
07:47:04 <hpc> :t find (second (> 6)) . (zip`ap`tail)
07:47:05 <lambdabot>     Couldn't match expected type `Bool'
07:47:05 <lambdabot>            against inferred type `(d, Bool)'
07:47:05 <lambdabot>     In the first argument of `find', namely `(second (> 6))'
07:47:11 <hpc> humbug
07:48:35 <paolino> :t find ((>6) . snd)
07:48:36 <lambdabot> forall a b. (Num b, Ord b) => [(a, b)] -> Maybe (a, b)
07:48:50 <monochrom> the tarball definitely contains ghc/stage2/build/tmp/ghc-stage2
07:49:06 <hpc> :t (zip`ap`tail)
07:49:07 <lambdabot> forall b. [b] -> [(b, b)]
07:49:19 <ski> @type fmap snd . find ((6 <) . fst) . (zip `ap` tail)
07:49:20 <lambdabot> forall b. (Num b, Ord b) => [b] -> Maybe b
07:49:30 <ski> > (fmap snd . find ((6 <) . fst) . (zip `ap` tail)) [0 ..]
07:49:30 <hpc> :t second
07:49:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
07:49:33 <lambdabot>   Just 8
07:49:38 <monochrom> incomplete tarball? it should be 108450171 bytes
07:49:43 <hpc> oh that's why
07:50:02 <ski> > (fmap fst . find ((6 <) . snd) . (zip `ap` tail)) [0 ..]  -- seems better
07:50:03 <lambdabot>   Just 6
07:50:04 <hpc> :t find ((> 6) . snd) . (zip`ap`tail)
07:50:05 <lambdabot> forall b. (Num b, Ord b) => [b] -> Maybe (b, b)
07:50:15 <monochrom> md5sum is 80adbf2356bacbe79234da730a7dfb88 for the x86 (32-bit) tarball
07:50:24 <hpc> > find ((> 6) . snd) . (zip`ap`tail) [1..10]
07:50:25 <lambdabot>   Couldn't match expected type `[(a, b)]'
07:50:25 <lambdabot>         against inferred type `(a1,...
07:50:31 <hpc> > find ((> 6) . snd) . (zip`ap`tail) $ [1..10]
07:50:33 <lambdabot>   Just (6,7)
07:52:27 <iboB> > let findLast f (x:y:xs) = if f y then x else findLast f (y:xs) in findLast (>6) [1,3..]
07:52:27 <lambdabot>   5
07:53:09 <iboB> probably should be called findLastNot
07:53:27 <iboB> or use (not f y)
07:53:44 <hjulle> Could someone look at my errors in the paste above (10 minutes ago)?
07:53:56 <monochrom> I did, 4 minutes ago
07:54:20 <hjulle> Oh, sorry, did not see your comment :P
07:54:48 * monochrom shakes head
07:55:19 * ski shakes tail
07:55:44 * hjulle stands in the corner and looks ashamed
07:56:40 * ski fails to see hjulle in #haskell.se
07:57:36 <hjulle> Not any more :)
08:00:39 <hpaste> ocharles pasted ‚ÄúHow can I write this without explicit type signatures?‚Äù at http://hpaste.org/53932
08:01:25 <ocharles> Hey, can anyone work out why I need to be so explicit with type signatures in the above paste? If I remove type signatures (except for the top-level), I get this error: https://gist.github.com/1360743
08:02:23 <paolino> :t join (ap zip tail)
08:02:24 <lambdabot>     Couldn't match expected type `[a1] -> a'
08:02:24 <lambdabot>            against inferred type `[(a1, b)]'
08:02:24 <lambdabot>     Probable cause: `zip' is applied to too many arguments
08:02:54 <monochrom> some fundeps on your type classes may save some type annotations, but it depends.
08:03:01 <ocharles> not my classes, sadly
08:03:09 <ocharles> HasField is from HaskellDB
08:03:14 <monochrom> or just get rid of overlapping instances
08:03:29 <ocharles> I don't know how to :) http://stackoverflow.com/questions/8105170/how-can-i-use-haskelldb-with-polymorphic-fields-problems-with-overlapping-inst explains my problem in more detail
08:06:58 <monochrom> well then, keep the type annotations. the price of putting all the abstraction burden on type classes
08:08:21 <jeff2> why is "f 1 = 10; f 2 = 20" ok, but "f 1 = 10; g = 0; f 2 = 20" fails with a "Multiple declarations of Main.f" error?
08:08:46 <monochrom> separation
08:08:51 <ocharles> jeff2: because all patterns must be together
08:09:08 <ocharles> that looks like 2 separation declarations of f, not 1 definition of f with 2 patterns
08:09:59 <jeff2> sometimes its clearer to separate the declarations, though. is there no way to do so?
08:10:10 <monochrom> no way
08:10:21 <jeff2> oh ok
08:10:39 * byorgey fails to see a situation in which separating the declarations would be clearer
08:10:43 <rwbarton> is that "there is no way" or "no way is it sometimes clearer to separate the declarations"?
08:10:56 <monochrom> no way to separate
08:11:14 * ski . o O ( .. in Prolog, there's an `:- discontiguous f/1.' directive )
08:11:41 * monochrom wouldn't argue with the author what means "clearer"
08:12:20 <jeff2> say I have a list of solutions to distinct problems, I could name them answer1, answer2, etc., like I am now, or (if separating the declarations was possible) I could use answer 1, answer 2
08:13:20 <monochrom> you said yourself, distinct problems
08:13:50 <monochrom> one function named "answer" solving ten thousand distinct problems is a textbook case
08:14:30 <monochrom> a textbook case of "example of no cohesion. don't do it" in introductory software engineering courses
08:14:53 <jeff2> well, I'd like to easily get all the answers. any other better way?
08:15:36 <sipa> jeff2: can you elaborate a bit more?
08:16:02 <sipa> why would you need several variables for answers - i suppose the point of the program is that it will calculate the answer as necessary
08:16:17 <monochrom> helper1 = ...; answer1 = ... ; helper2 = ...; answer2 = ...; ...  answer = [answer1, answer2, answer3 ... ]
08:16:46 <monochrom> no, sipa, "answer 1" solves question 1, "answer 2" solves question 2, etc
08:16:53 <sipa> oh, sure
08:17:10 <monochrom> where question 1 is like "what is 2+2" and question 2 is like "how many monkeys are there in India?"
08:17:18 <jeff2> monochrom: that's probably what I'll end up doing, just thought there might be a better solution. but it'll work
08:17:27 <jeff2> monochrom: exactly
08:23:44 <monochrom> they shouldn't even be in the same module, much less same function. just for the sake of separate compilation, if you will. hacking on one question's solution should not mean re-processing nine thousand nine hundred ninety nine other solutions
08:24:12 <Confusionist> Hi, I don't understand the following: if I ask ghci what ":t (ceiling . sqrt)" is, it says: "(ceiling . sqrt) :: (RealFrac b, Integral c, Floating b) => b -> c", which I understand . If I then declare "let f = (ceiling . sqrt)" and ask for ":t f", I get "f :: Double -> Integer".
08:24:29 <monochrom> thumbs up for Confusionism!
08:25:09 * ski . o O ( "make each exercise it's own Hackage project" )
08:25:14 <byorgey> Confusionist: you have triggered the Dreaded Monomorphism Restriction
08:25:49 <byorgey> Confusionist: solution: add the line ':set -XNoMonomorphismRestriction' to your .ghci file
08:25:51 <ski> Confusionist : do `:set -XNoMonomorphismRestriction' in GHCi
08:26:56 <Confusionist> OK thanks, /me is off to Google what that means :)
08:28:30 <ski> Confusionist : well, you could, you know, just ask in here as well ..
08:31:33 <monochrom> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:31:43 <Confusionist> ski: well, since you pretty much directly recognize the issue, I could imagine you've already explained it a zillion times and may be tired of it. And since I'm pretty new to Haskell, I may not be able to understand the explanation. So I'll read up a bit and then follow up with some questions to check whether I understood it :)
08:32:03 <Confusionist> monochrom, that was the first hit indeed
08:32:29 <monochrom> nice, I can retire now and let google do my job
08:35:50 <monochrom> actually, I am no longer sure that I endorse that entry.
08:36:28 <monochrom> the problem with the haskell wiki is that everyone wants to add his/her own new angle, and everyone is afraid of deleting other people's angles
08:37:39 <Taejo> "without the restriction, there would be some ambiguous types" -- what ambiguous types are eliminated?
08:37:52 <monochrom> so after several years an entry is incoherent, inconsistent, and doesn't get to the point
08:39:29 <parcs> '(RealFrac b, Integral c, Floating b) => b -> c' is a very ambiguous type
08:44:57 <Confusionist> monochrom, I've noticed wiki entries tend to diverge into notes/discussions that have been tacked on, but the usually the initial parts are at least helpful.
08:45:18 <paolino> I thought that was ghci defaulting. I must read about it too.
08:46:16 <parcs> paolino: it's defaulting that occurs due to the MR
08:46:19 <ski> paolino : it's a `let', so it's not defaulting
08:46:33 <ski> (or rather, not only defaulting)
08:47:25 <Confusionist> Well, it also answers the second question, which is why "(ceiling . sqrt) 17" is fine, while "let n = 17" followed by "(ceiling . sqrt) n" isn't
08:47:27 <paolino> oh, right it's a monomorphic let
08:48:32 <ski> Confusionist : btw, even if you have the DMR enabled, you can still add an explicit type signature to `f',`n',&c.
08:49:21 * Cale just realised that he can drag and drop tabs in the terminal version of vim :D
08:49:35 <paolino> so the monomorphism restriction applies not only to toplevel declaration
08:51:16 <ski> Cale : i thought you were in the "ban tabs" camp ?
08:52:02 <Cale> ski: lol
08:52:26 <Cale> ski: If only this were the sort of thing that the word 'tab' always referred to
08:52:51 <ski> oh .. now i see
08:53:43 * ski 'll try to keep tabs on that, in the future
09:03:02 <ocharles> What does the error "Could not deduce (r ~ RecCons f0 (Expr a0) RecNil) from the context (HasField (Revision Book) r)  bound by the type signature for revision :: HasField (Revision Book) r => Table r" actually mean?
09:06:41 <ski> hm, something about not finding field `f0' with type `Expr e0' in `r', i would guess
09:06:43 <sipa> ocharles: it means something requires (RecCons f0 (Expr a0) RecNil) to be equal to type r, but it is unable to prove tat
09:06:57 <ocharles> Ah, yes I think f0 and a0 are the problems
09:15:26 <incluye> so there's an operator to create a 62-tuple
09:16:39 <monochrom> no :)
09:16:48 <incluye> but anything larger than that, no go
09:17:01 <monochrom> oh, misread, but yeah
09:17:15 <dmwit> incluye: yeah GHC says "bugger off" if you try to go bigger =)
09:17:25 <incluye> I thought it seemed like an arbitrary restriction, but I realized you have to draw the line somewhere
09:17:36 <incluye> and anything bigger than a 12-tuple, say, seems excessive anyway
09:17:52 <dmwit> You don't really *have* to draw the line somewhere. But it bothers me a lot less than I thought it would that they did draw the line somewhere.
09:18:15 * monochrom wonders what to use 62-tuples etc for. cosmology? 58 microscopic dimensions?
09:18:45 <dmwit> To model a database with 62 columns, of course.
09:19:33 * incluye wonders what to use a 62-column database for
09:19:51 <sipa> To model 624~tuples, of course.
09:19:54 <sipa> *62
09:20:09 <incluye> Brillant
09:21:00 <monochrom> a database usually has enough semantic intention behind it to suggest a record with field names
09:21:45 <dmwit> Ugh, this is just a one-off monochrom, why are you making me do all that typing to do good coding practices?
09:22:10 <dmwit> The code won't get used beyond the end of the week anyway.*
09:22:13 <rwbarton> an O(1)-off
09:22:15 <dmwit> *code like this never dies
09:22:23 <monochrom> even if not, you already have to choose column names for the database, may as well make them field names too in haskell. it makes life easier.
09:22:54 <luite> is there a limit on the number of fields in a record?
09:27:40 <dmwit> I don't think so.
09:27:49 <dmwit> I think the error message even says "use a record".
09:29:18 <byorgey> yes, the limit is 2.73 x 10^80
09:29:41 <dmwit> PSH
09:29:44 <dmwit> What an arbitrary limit.
09:30:14 <dmwit> HOW AM I GOING TO WRITE MY CONSTANT-TIME LOOKUP MAP FROM PARTICLES IN THE UNIVERSE TO VECTOR3S???
09:30:39 <_Mikey> ooh
09:30:40 <ocharles> Remove particles from the universe, obviously
09:30:56 <byorgey> dmwit: use that quantum language that Benoit is working on, of course
09:31:07 <_Mikey> how does one remove particles from the universe?
09:31:12 <_Mikey> ^^
09:31:21 <dmwit> antiparticles?
09:33:59 <dmwit> Huh. Apparently *other people* can add you to groups on Facebook now.
09:34:16 <dmwit> Thanks, Zuckerberg!
09:34:27 <merijn> dmwit: You can turn that off somewhere in the settings
09:37:40 <Confusionist> OK, so I now have a faint global idea of why there is such a thing as a monomorphism restriction. But why does it make sense that  (RealFrac b, Integral c, Floating b) => b -> c ends up as Double -> Integer?
09:38:35 <dmwit> The default for Integral is Integer. The default for Floating is Double.
09:39:20 <dmwit> Not much more to say about it than that.
09:40:24 <Confusionist> OK, but wouldn't (Integral a) => Double -> a be slightly more general?
09:41:13 <dmwit> The monomorphism restriction kills generality.
09:41:26 <dmwit> (Wherever it knows a default to use.)
09:41:51 <dmwit> It makes polymorphic things monomorphic... hence the name.
09:42:15 <Confusionist> OK, that sounds logical :)
09:44:06 <Confusionist> If I use the -XNoMonomorphismRestriction as my default, are there other things I can be expected to run into pretty quickly?
09:44:09 <ski> the monomorphism restriction kills the constraints, not the polymorphism/generality per se
09:44:25 <Confusionist> Or would that be more sane for someone just newly experimenting with ghci
09:45:02 <dmwit> NoMR is a quite common extension to use.
09:45:12 <ski> Confusionist : well, if you say `myNumber = ...', then you can expect that to be recomputed each time instead of cached, if the type still has constraints
09:45:15 <dmwit> It will be included by default in a future version of Haskell.
09:45:30 <dmwit> (Is it already included by default in H2010? I think it might be.)
09:46:14 <ski> Confusionist : the DMR were only created because it was thought that people could find it confusing not to always have `myNumber' cached in such a case
09:47:11 <Confusionist> ski, it leads to performance problems that may be difficult to find?
09:48:01 <monochrom> no, not in Haskell 2010
09:48:23 <parcs> > putChar '\9728'
09:48:23 <lambdabot>   <IO ()>
09:48:34 <monochrom> > text "\9728"
09:48:34 <ski> Confusionist : well, as long as you're aware that `myNumber' has constraints in the type, and judge whether loss of cache is ok or not, there should be no problem
09:48:35 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
09:48:36 <parcs> > text ('\9728':[])
09:48:37 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
09:48:43 <mercury^> monochrom: MR is still in Haskell 2010, or NoMR does not lead to performance issues in Haskell 2010?
09:48:44 <monochrom> oh well
09:48:51 <parcs> > '\9728'
09:48:52 <lambdabot>   '\9728'
09:48:55 <ski> (btw, note that the language doesn't guarantee any caching, it's just that implementations typically do that)
09:48:56 <monochrom> MR is still in Haskell 2010
09:49:16 <parcs> > '‚òÄ'
09:49:17 <lambdabot>   '\9728'
09:50:09 <Confusionist> OK, thanks, I'll just have to see how it turns out for me then
09:50:49 <monochrom> MR or not, you use type sigs to resolve issues
09:53:47 <Confusionist> Speaking of type sigs: what would be a sensible type signature for this function: "let ceilSqrt = (ceiling . sqrt)", when I only intend to use it on integers?
09:53:59 <ocharles> Hm. Can a type family that's associated to a type class have constraints? If a typeclass A, with associated type synonym X a, but instances of X a must be instances of Eq too, for example? class A a where type X a :: *
09:54:43 <monochrom> @type ceiling
09:54:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:54:49 <monochrom> @type sqrt
09:54:50 <lambdabot> forall a. (Floating a) => a -> a
09:54:58 <sipa> ocharles: yes
09:55:06 <ocharles> or should I use flexible contexts and add (Eq (X a)) as a context to functions in the type class that need it?
09:55:14 <monochrom> (Floating a, RealFrac a) => a -> Integer, unless you want to a=Double
09:55:21 <sipa> ocharles: that's how you do it
09:55:42 <ocharles> ok, then I'm missing something else. back to fiddling :)
09:55:43 <sipa> class Eq (AsocType a) => FooClass a where { type AsocType a :: * }
09:55:57 <ocharles> oh
09:56:00 <ocharles> interesting
09:57:56 <ocharles> https://gist.github.com/1360893 seems to indicate that I'm missing something
09:58:27 <ocharles> (table :: ShowRecRow r => Table r -> ...)
09:59:49 <Confusionist> monochrom, OK , thanks, that indeed works. I'm now going to figure out why the others I tried didn't work, but having found the diagram in http://www.haskell.org/onlinereport/basic.html, some things suddenly became clear. I wrongly understood how Integral stood in the diagram
10:01:45 <ocharles> oh, adding a type signature for `foo` helps
10:04:07 <wto> @src fix
10:04:08 <lambdabot> fix f = let x = f x in x
10:12:16 <Jsauidhasj> hi guys! i have a question:is there any built-in function that is like (\ f x->f x) ?thanks
10:13:13 <dafis> > if cos 0
10:13:13 <ski> Jsauidhasj : yes, `($)'
10:13:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:13:17 <dafis> > id cos 0
10:13:18 <lambdabot>   1.0
10:13:26 <ski> > ($) f x :: Expr
10:13:26 <dafis> :t ($)
10:13:27 <lambdabot>   f x
10:13:27 <lambdabot> forall a b. (a -> b) -> a -> b
10:13:31 <ski> > (\f x -> f x) f x :: Expr
10:13:33 <lambdabot>   f x
10:13:49 <dafis> @pl \f x -> f x
10:13:50 <lambdabot> id
10:14:18 <ski> Jsauidhasj : .. where do you want to use this ?
10:14:54 <reynir> > id 1 2
10:14:55 <lambdabot>   1
10:15:27 <reynir> wut
10:15:39 <ski> > 2 3 4
10:15:41 <lambdabot>   2
10:15:56 <ski> > (cos ^ 2 + sin ^ 2) (pi / 4)
10:15:57 <lambdabot>   1.0
10:16:34 <Jsauidhasj> i was just curious about it.thanks for the answer
10:16:48 <ski> reynir : ARE we ENLIGHTENED yet ?
10:17:07 <ski> Jsauidhasj : both `($)' and `id' are valid answers, in any case
10:29:01 <reynir> ski: what?
10:29:17 <reynir> oh
10:29:43 <reynir> ski: No need for shouting
10:30:52 <ski> @yow
10:30:53 <lambdabot> Couldn't find fortune file
10:30:58 <ski> :(
10:33:16 <ski> reynir : try `M-x insert-zippyism' in emacs ..
10:33:32 <rwbarton> Excuse me, but didn't I tell you there's NO HOPE for the survival of OFFSET PRINTING?
10:34:10 <yitz> ski: M-x yow also works
10:34:50 <TomvdZ> Is there a function like lookup that allows you to specify your own comparison function?
10:36:14 <ski> yitz : i knew there was another command ..
10:39:28 <dylex> @pl \f l -> snd <$> find (f . fst) l
10:39:28 <lambdabot> ((snd <$>) .) . find . (. fst)
10:39:49 <dylex> TomvdZ: that one
10:42:36 <jasonq> good evening! am i right in thinking that a general, directed fold function is inherently sequential and could never be parallelised?
10:49:12 <byorgey> jasonq: it can if the folding operation is associative.
10:49:18 <byorgey> but not in general.
10:49:50 <shachaf> A fold for a tree can. :-)
10:50:17 <byorgey> good point, I was assuming list
10:52:00 <rwbarton> though in special cases you may be able to use speculative parallelism, such as in predictive parsing
10:55:02 <rwbarton> basically use some heuristic to guess what the value of the accumulator will be at a particular place in the list, and start a parallel computation based on that assumption; if it turns out that your guess was correct, you've just parallelized the fold
10:55:12 <rwbarton> and if it wasn't correct, throw away that speculative computation
10:55:57 <byorgey> rwbarton: neat =)
11:06:54 <Confusionist> When asked :t  (ceiling . sqrt), ghci will answer (ceiling . sqrt) :: (RealFrac b, Integral c, Floating b) => b -> c. When I want to define this function myself with a type signature, why can't I simplify this to let ceilSqrt :: (Floating a, Integral b) => a -> b; ceilSqrt = (ceiling . sqrt), since sqrt requires a Floating param?
11:09:16 <Confusionist> I think I'm missing something about the relationship between RealFrac and Floating. In fact, now that I think about it, with the diagram in http://www.haskell.org/onlinereport/basic.html in mind, I don't know why it works at all
11:09:42 <ski> @src Floating
11:09:43 <lambdabot> class  (Fractional a) => Floating a  where
11:09:43 <lambdabot>     pi                                                      :: a
11:09:43 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
11:09:43 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
11:09:43 <ski> @src RealFrac
11:09:44 <lambdabot>     (**), logBase                                           :: a -> a -> a
11:09:46 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
11:09:48 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
11:09:50 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
11:10:28 <edwardk> Anything Floating is a Fractional,      anything RealFrac is a Fractional, but they don't directly relate to one another
11:10:32 <ski> so, from `Floating a', you can't deduce `Fractional a', and neither vice versa : you need both, if you want to use both
11:10:35 <edwardk> @src RealFloat
11:10:35 <lambdabot> Source not found.
11:10:44 <dylukes> Why is the number hierarchy so confusing .__.
11:10:51 <dylukes> A flowchart would be nice.
11:10:59 <edwardk> dylukes: sometimes things are complicated because the domain is complicated
11:11:06 <dylukes> Oh, for sure :P.
11:11:13 <dylukes> Just wondering if there's an existing chart of it all.
11:11:24 <edwardk> there is on in the report
11:11:25 <ski> hm, i know WinHugs had a graph thing for displaying class dependencies (including user-defined)
11:11:28 <edwardk> er one
11:11:29 <Confusionist> Nevertheless, you can compose something that takes a RealFrac with something that yields a Floating. How does that work?
11:11:51 <edwardk> Confusionist: you can have multiple constraints on the same type
11:12:22 <ski> dylukes : convince edwardk to make a new numeric prelude based on the algebra stuff
11:12:31 <dylukes> That'd actually be very nice.
11:12:35 <dylukes> edwardk: *stares*
11:12:39 <edwardk> ski: heh, algebra has a ways to go still
11:12:40 <dylukes> Make monoid the default "+".
11:12:48 <dylukes> So we can just use + for mplus.
11:12:49 <dylukes> do et.
11:13:04 <edwardk> mplus is MonadPlus ;)
11:13:10 <dylukes> mappend*
11:13:25 <Confusionist> Oh wait, it doesn't matter that these classes are not in the same hierarchy, because the types themselves (Float, Double) are and that's enough
11:13:41 <edwardk> and that wouldn't make me happy, i'd want it to be Semigroup to give you "+" but then people would be annoyed because there are additive semigroups and multiplicative semigroups that you want to talk about
11:13:43 <Confusionist> (and please correct any terminology mistakes in that statements)
11:14:02 <edwardk> and then there are others like min and max that arise in the context of the same type through things like ordered monoids, etc.
11:14:04 <ski> Confusionist : it's not much more strange than having `foo :: (Read a,Show a) => ..a..' e.g.
11:14:16 <edwardk> Confusionist: yes
11:14:26 <Nimatek> People shouldn't be able to add two and two in Haskell without knowing monoids!
11:14:34 <_Mikey> @src Integer
11:14:35 <lambdabot> data Integer = S# Int#
11:14:35 <lambdabot>              | J# Int# ByteArray#
11:14:45 <ski> @remember Nimatek People shouldn't be able to add two and two in Haskell without knowing monoids!
11:14:46 <lambdabot> I will remember.
11:15:08 <edwardk> Nimatek: not sure i agree, because the alternative is that they have to understand the abortion of compromise that is Num
11:15:17 <edwardk> and _I_ don't even really understand it ;)
11:15:17 <stepcut> Nimatek: or multiply two and two ?
11:15:30 <Nimatek> stepcut: Yes, monoids are required for that as well.
11:15:38 <shachaf> Sometimes things are complicated because the domain is complicated. Other times things are complicated because edwardk.
11:15:44 <edwardk> shachaf: hahaha
11:16:04 <edwardk> @remember shachaf Sometimes things are complicated because the domain is complicated. Other times things are complicated because edwardk.
11:16:04 <lambdabot> It is stored.
11:16:13 <ski> edwardk : beat me to it :)
11:16:15 <stepcut> Num is an attempt to pretend things aren't complicated :-/
11:17:07 <edwardk> to be fair, Num does the right thing over the finite set of numeric types that were defined in the prelude. if you look at the hierarchy as the minimum set of things they needed to cleave out the functionality that they provided, its good
11:17:23 <edwardk> if you look at it from the perspective of extending it? not so much
11:17:28 <TomvdZ> does it create problems passing a filehandle through forkIO? I'm having some trouble, trying to rule out some possibilities?
11:17:44 <edwardk> _but_ it does have the benefits of being definable in Haskell 98, which few of these alternative proposals are
11:17:54 <shachaf> TomvdZ: It should work fine -- what kind of trouble?
11:18:20 <edwardk> and doing abs and signum correctly would require an MPTC or type family to properly handle using a different type for the norm or squared norm
11:19:19 <TomvdZ> I've got a simple server running and I'm expecting it to be receiving my messages but it's not. It does accept the connection and send a welcome message, but the thread that's responsible for receiving the messages from the client doesn't seem to be doing anything.
11:19:40 * ski . o O ( "Will noone think of the cubed norms ?" )
11:20:52 <edwardk> *twitch*
11:21:26 * ski grins evilly
11:22:54 * Eduard_Munteanu wonders if the inf-norm isn't more common than cubic ;)
11:23:07 <rwbarton> edwardk: will your rope package be reasonably space efficient if I build up a rope by concatenating lots of short (1-4 byte) bytestrings?
11:23:26 <TomvdZ> Ah, I think I might have got it. Does writing to the console work through threads? It appears it doesn't.
11:23:34 <edwardk> rwbarton: 'rope' on hackage?
11:23:36 <rwbarton> yes
11:23:49 <rwbarton> Or, other rope packages if you have suggestions
11:24:21 <edwardk> iirc it checks the bytestring next to it and folds them together if they are two small rather than make two leaves
11:24:28 <edwardk> but the 'too small' is actually quite small
11:24:32 <edwardk> i should probably raise it
11:24:49 <rwbarton> that's the sort of thing I was hoping for.
11:25:03 <parcs> is there a name for foldr (<|>) empty anywhere in base?
11:25:15 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.6.1.1/doc/html/src/Data-Rope-Internal.html#cons8
11:25:32 <edwardk> Data.Foldable.asum
11:25:45 <edwardk> :t Data.Foldable.asum
11:25:46 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
11:25:52 <rwbarton> yeah, 16 is probably too small at least on 64-bit systems
11:26:16 <edwardk> well, it should be at least larger than the overhead of storing the bytestring in the first place, which puts it up around 64-80 minimum
11:26:17 <parcs> cool :)
11:26:46 * hackagebot HROOT 0.7.1 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.7.1 (IanWooKim)
11:27:01 <edwardk> the main thing i got out of working with jaspervdj this summer is that understanding that bytestrings have a lot of overhead before you get to even storing the data in them
11:27:31 <edwardk> rwbarton: anyways, i don't use that rope package anywhere
11:27:43 <edwardk> rwbarton: it was my first stab at something, in particular the annotated rope concept
11:27:58 <edwardk> which i used for a while, but have since given up on doing in the nice type safe fashion
11:28:17 <edwardk> the technique i was using there was to treat a rope with an annotation as a comonad
11:28:56 <edwardk> at which point its just a pair of (rope, annotation)   -- and can be used like the product comonad, but any action i could write with that i could also write with a reader monad
11:29:03 <dylex> which looks best: "Just $ fromMaybe d o" "o <|> Just d" "o `mplus` Just d" or something else?
11:29:03 <edwardk> and so my graphs package does the latter
11:29:19 <edwardk> because then i can generalize the monad choice from reader, and allow offline graphs
11:29:37 <edwardk> not sure how that would work with ropes where we do more editing
11:30:04 <rwbarton> what I'm looking for is a data structure for strings where I can get length in O(1) or O(log n) time, concat in O(log n) time, and isn't ridiculously space-inefficient
11:30:04 <hpc> dylex: middle one perhaps
11:30:11 <rwbarton> *bytestrings
11:30:35 <edwardk> rwbarton: yeah, the ropes i use in trifecta do all that, but they are monomorphized to my problem domain
11:31:16 <edwardk> (though there i don't currently do the small chunk merges)
11:31:36 <edwardk> added to my TODO list
11:31:56 <zeiris> Is there some trick needed to make trifecta parse \ns?
11:32:02 <edwardk> the rope package should do everything you want, and you can feel free to even take it over and rewrite it if need be
11:32:16 <edwardk> zeiris: ?
11:32:53 <edwardk> zeiris: https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Char.hs#L103
11:32:57 <edwardk> nothing fancy
11:38:14 <ski> @type fromMaybe  -- dylex
11:38:15 <lambdabot> forall a. a -> Maybe a -> a
11:38:32 <ski> oh, no i misread
11:39:48 <Taejo> > Nothing < Maybe undefined
11:39:49 <lambdabot>   Not in scope: data constructor `Maybe'
11:39:54 <Taejo> > Nothing < Just undefined
11:39:56 <lambdabot>   True
11:39:57 <ski> dylex : i might have done `maybe (Just d) id o', but i'm not sure which looks best
11:41:49 <rwbarton> hmm, I wonder what Yi uses
11:42:17 <dylex> :t \d o -> maybe (Just d) id o -- isn't this wrong?
11:42:17 <lambdabot> forall a. a -> Maybe (Maybe a) -> Maybe a
11:42:45 <dylex> ski: Yeah, that's a different type.
11:43:08 <dylex> :t \d o -> maybe (Just d) Just o
11:43:09 <lambdabot> forall a. a -> Maybe a -> Maybe a
11:43:10 * ski . o O ( "A JavaScript mode for Yi",Deniz Dogan,<http://publications.lib.chalmers.se/records/fulltext/112284.pdf> )
11:43:47 <ski> sorry, s/id/Just/ yes
11:44:43 <_Mikey> length [1..10000000000]
11:44:52 <_Mikey> :t length
11:44:54 <lambdabot> forall a. [a] -> Int
11:45:19 <aristid> edwardk: i've read two of daan's papers on concurrent revisions, and isn't one disadvantage of it that you have to be very careful that your data types support merging, and that your merge strategy behaves as desired? (unless you use the default strategy)
11:45:59 <JoeyA> Is anyone aware of a portable version of lines :: String -> [String] on Hackage?  By "portable", I mean treat "\r\n", "\r", and "\n" as newline characters, not just "\n"
11:46:03 <edwardk> you need to be conscious of that, yes, but usually you didn't want some bizarre racy strategy in the first place
11:46:22 <edwardk> so doing the same thing with IORefs gives you a mess of race conditions, etc. to reason about
11:46:53 <aristid> edwardk: STM would be better than IORefs ;)
11:47:32 <_Mikey> length [1..100]
11:47:41 <edwardk> but STM rolls back and retries so under high contention for a resource it can spin forever
11:47:48 <aristid> edwardk: if you look at the counters example that can be both set and added, the data type seems to kind of be designed that you can rollback to where you forked from
11:47:52 <edwardk> and it isn't compatible with interleaving IO actions
11:47:56 <_Mikey> lamdabot: why you ignore me!
11:48:17 <edwardk> i'm not saying its a panacea, i'm just saying it is an interesting point in the design space
11:49:02 <aristid> edwardk: i'm not saying it's bad, i'm trying to check if i'm understanding the positive and negative attributes correctly
11:49:04 <edwardk> most of my merge strategies so far are for things like doing unification in parallel
11:49:24 <edwardk> but still giving you the same error message regardess of how i interleave the work
11:49:41 <_oz> JoeyA: what about Data.List.Split.linesBy
11:50:30 <JoeyA> http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html
11:51:21 <ski> _Mikey : you forgot to prefix the expression for lambdabot to evaluate with `> '
11:51:23 <JoeyA> _oz: linesBy :: (a -> Bool) -> [a] -> [[a]] doesn't recognize multi-character newlines, according to its type signature.
11:51:48 <JoeyA> I think I'll just write a module for it.  That way, it can support ByteString, too.
11:52:43 <JoeyA> Though I'm not too keen on writing a module with Data.PortableLines, Data.PortableLines.ByteString, Data.PortableLines.ByteString.Lazy, etc. where each module has only one function.
11:52:43 <_oz> JoeyA: oops, you're right.
11:52:55 <_Mikey> :info Show
11:53:17 <JoeyA> So 1) What other issues should such a module deal with, and 2) What's its name, since it probably already exists?
11:53:36 <_oz> JoeyA: splitOn accepts a multi character string on that module, I just assumed linesBy would too.
11:53:59 <JoeyA> splitOn doesn't support multiple formats, though.
11:54:55 <_oz> yes.
11:54:57 <JoeyA> Might be possible with Splitter, but then I might as well just write a simpler pattern-matching version myself.
11:55:21 <rwbarton> heh. the first two lines from Yi's Rope.hs:  {-# LANGUAGE CPP, MultiParamTypeClasses, FlexibleInstances #-} \n -- Consider splitting off as a separate package
11:56:45 <s951> Is there a prelude function that returns a bool if the input is an alphabetical/numeral/alphanumeric char)?
11:57:06 <ion> See Data.Char
11:57:11 <byorgey> s951: do you care which Bool is returned? ;)
11:57:17 <JoeyA> Maybe I should have the gall to write a "Text.Portable" module that provides, for now, the "lines" function I want.
11:57:28 <zzo38> What kind of normalizable semirings can be used with a monadic generalized probability distribution?
11:57:39 <byorgey> > isAlphaNum 'x'
11:57:39 <lambdabot>   True
11:57:42 <byorgey> > isAlphaNum '-'
11:57:42 <lambdabot>   False
11:57:45 <byorgey> > isAlphaNum '9'
11:57:46 <lambdabot>   True
11:58:06 <lpsmith> I'm thinking that a variant of hGet and hGetNonBlocking would be very useful
11:58:43 <lpsmith> namely that if no data is available, it would block,   but it doesn't wait until a specified amount of data is available,  that it just returns whatever is available
11:58:47 <dylex> JoeyA: isn't the IO system supposed to take care of newline issues? how did you get a string with "\r\n" in it?
11:59:00 <rwbarton> right, "Portable" isn't really the right word...
11:59:11 <s951> byorgey: are there specific ones for alphabetical characters or numeric characters?
11:59:22 <ion> See Data.Char
11:59:27 <byorgey> s951: yes
11:59:31 <lpsmith> I suppose I have to turn my handles into Fds and use waitReadFd
11:59:50 <byorgey> s951: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html#g:1
12:00:00 <dylukes> lpsmith: Couldn't you just wait for the minimum amount,
12:00:00 <JoeyA> dylex: 1) It should, but it doesn't.  in the case of Data.ByteString.Char8.readFile on Windows, \r\n isn't converted to \n, last time I checked.
12:00:03 <dylukes> then do a non-blocking read?
12:00:04 <s951> ah ty
12:00:11 <dylukes> so wait for any data, then read as much as possible
12:00:22 <JoeyA> dylex: 2) I may want to read Windows-format files on a non-Windows system.
12:00:45 <lpsmith> dylukes, yeah, that sounds like another possibility
12:01:07 <dylukes> Fd is a lower level of abstraction though. Might be nicer anyways.
12:01:18 <dylukes> select/poll is always an option there too.
12:01:22 <dylex> JoeyA: at least for (2) you can call hSetNewlineMode to set it directly, but I'm surprised the ByteString IO doesn't support that too.
12:01:31 <dylukes> (with an infinite timeout)
12:03:20 <JoeyA> dylex: But what if the file contains a mixture of \r\n and \n ?  ;-)
12:04:06 <dylex> JoeyA: If, instead of using readFile, you open the handle and hSetNewlineMode manually, ByteString IO seems like it should do the right thing.
12:04:25 <rwbarton> JoeyA: Maybe you should find a better file then.
12:05:14 <dylex> JoeyA: I would contend that such a file is broken and uninterpretable.  I don't know anything that will handle such files.
12:05:31 <zzo38> I made up |*| |/| |+| |-| operators for working with monoids
12:06:37 <rwbarton> this is a bit like trying to guess a file's encoding by examining it rather than from external metadata, which is a reasonable thing to do in practice sometimes
12:08:35 <JoeyA> It seems to me that reading a file with an explicit mode, after detecting what that mode is, is very inconvenient.
12:08:52 <JoeyA> I'm gonna write this module whether anyone cares or not!  :-)
12:09:04 <rwbarton> Sure, my point is just that this is not really a sanctioned operation, so you shouldn't necessarily expect it to exist already
12:09:22 <JoeyA> (I'll try to document the rationale I've given here)
12:11:36 <JoeyA> Thanks for the input.
12:14:38 <smoge> is it possible to optimize code on x86_64 ??
12:14:41 <smoge> it seems not, but maybe im wrong
12:15:51 <Saizan> what do you mean by that?
12:17:03 <smoge> optimization: True gives me an error
12:17:16 <smoge> I was wondering if optimization works only on i686?
12:18:21 <smoge> ?
12:18:37 <Saizan> nope it works on x86_64 too
12:19:00 <zeiris> edwardk: what's up with http://hpaste.org/53922 then?
12:19:51 <Saizan> my hunch is that symbol eats subsequent whitespace
12:21:30 <smoge> I get : cabal: Command.optionToFieldDescr: feature not implemented
12:21:45 <smoge> if I enable "optimization: True"
12:22:20 <edwardk> zeiris: the 'symbol' combinator consumes trailing whitespace after it parses
12:23:10 <edwardk> if you want exactly that not to automatically consume trailing space, use string
12:24:22 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Token/Combinators.hs#L122 shows how symbol is implemented
12:24:47 <edwardk> that'd also let you avoid using overloadedstrings if you wanted
12:31:31 <zeiris> Ohhh :)
12:32:07 <edwardk> symbol is intended for things like parsing "(" and ")" inside of a programming language where you just want to get to the next token
12:36:04 <smoge> is there a quick way to visualize the darcs repo structure with a GUI?
12:36:15 <smoge> darcs view or similar?
12:37:18 <edwardk> smoge: have you tried #darcs ?
12:37:37 <smoge> yes, very quiet there
12:37:51 <smoge> I though here would be more interactive
12:38:00 <smoge> darcs is dead?
12:38:03 <edwardk> i usually just chant 'kowey kowey kowey' three times and it gets his attention ;)
12:38:10 <edwardk> no
12:38:13 <edwardk> its quite active
12:38:20 <smoge> I;; wait
12:38:22 <smoge> thanks
12:38:23 <edwardk> but i don't know how to do what you want
12:38:48 <edwardk> i thought the whole idea of darcs was that a repository was just a collection of patches
12:38:50 <smoge> im just starting darcs from hg
12:38:58 <edwardk> which kind of renders the structure thing a moot point
12:39:00 <smoge> Im missing some GUI to visualize the changes
12:39:05 <edwardk> *nods*
12:39:46 <Saizan> darcsweb has something
12:40:05 <edwardk> *an expert appears*
12:40:07 * edwardk hides
12:40:20 <smoge> ok, so I must install darcsweb locally?
12:40:22 <smoge> hum...
12:40:27 <smoge> ok
12:42:42 * Saizan not an expert
12:43:50 <Saizan> you could also check darcsden and patch-tag
12:48:52 <lpsmith> the fake show instances for exceptions are pretty obnoxious
12:49:20 <lpsmith> Is there a nice way to figure out which exception you really want to catch?
12:49:22 <edwardk> lpsmith: yeah
12:49:31 <edwardk> er rather 'yes, they are'
12:49:49 <lpsmith> edwardk, that's what I understood you to mean :)
12:50:08 <edwardk> lpsmith: catch it as SomeException and then inspect the Typeable typerep
12:50:21 <lpsmith> That's what I figured
12:50:30 <lpsmith> I was catching it and showing it
12:50:42 <lpsmith> thanks!
12:51:09 <edwardk> you should just be able to show the typeRep
12:51:46 <edwardk> > show (typeOf 12)
12:51:47 <lambdabot>   "Integer"
12:52:38 <Sgeo|chromcrash> Do new packages on Hackage take a while for their documentation to be processed or something?
12:53:00 <edwardk> Sgeo|chromcrash: ~12 hours
12:53:11 <edwardk> Sgeo|chromcrash: they get batched and run all at once
12:53:23 <Sgeo|chromcrash> Hmm, ok
12:54:12 <erus`> instance forall a => Functor (Tri3 a) where
12:54:15 <erus`> whats wrong there?
12:54:34 <edwardk> instance Functor Tri3 is probably what you meant
12:56:01 <lpsmith> edwardk, ok,  how do I get it to show me something other than SomeException?   I haven't used typeable that much...
12:56:13 <edwardk> pattern match on the SomeException
12:56:52 <edwardk> case e of SomeException t -> print (typeOf t)
12:57:43 <edwardk> pattern matching brings the Typeable instance for the carried exception into scope
12:58:46 <lpsmith> ahh, thank you very much
13:00:01 <lpsmith> now I'll have to spend a few minutes figuring out why that works...
13:00:18 <edwardk> SomeException is a GADT
13:00:25 <hpaste> erus` pasted ‚Äúnope‚Äù at http://hpaste.org/53944
13:00:41 <Spockz_> dcoutts_: is it possible to add port numbers to repo urls?
13:00:41 <erus`> edwardk: what am i doing wrong there?
13:00:50 <edwardk> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Exception.html#SomeException
13:01:11 <edwardk> fmap f (Tri3 p0 p1 p2) = Tri3 (fmap f p0) (fmap f p1) (fmap f p2)
13:01:32 <lpsmith> ok, that makes sense now
13:01:33 <edwardk> you don't want to apply the function to each vertex. you want to _map_ the function over each vertex
13:02:10 <erus`> the Maybe Functor looks like this: fmap f (Just a)      = Just (f a)
13:02:49 <edwardk> thats because the Maybe functor contains values of type 'a'. you only contain (V3 a)'s to get down to the as there you need the fmap for V3
13:03:54 <edwardk> you have a function f from a -> b   but you need to use it to get V3 a -> V3 b     that is what fmap does =)
13:04:11 <erus`> I think im using functor wrong here
13:04:25 <erus`> i only need a -> a i think
13:04:48 <edwardk> you can use this more general operation even when a = b
13:04:51 <Spockz_> dcoutts_: nom, completely overseeing it
13:04:53 <edwardk> so you're good
13:06:17 <erus`> edwardk: so i can still pass in an operation for V3 -> V3
13:06:24 <edwardk> no
13:06:36 <erus`> thats what i need
13:06:36 <edwardk> you'd need another function
13:06:51 <edwardk> that isn't a "Functor", its something else
13:07:13 <erus`> "for each vertex do this"
13:07:22 <edwardk> mapV3 :: (V3 a -> V3 b) -> Tri3 a -> Trie3 b
13:07:29 <edwardk> then define it with the body you gave
13:07:49 <edwardk> or better still
13:08:05 <edwardk> data Tri f a = Tri (f a) (f a) (f a) deriving (Show, Eq)
13:08:47 <edwardk> instance Functor f => Functor (Tri f) where fmap f (Tri a b c) = Tri (fmap f a) (fmap f b) (fmap f c)
13:09:00 <edwardk> mapTri :: (f a -> f b) -> Tri f a -> Tri f b
13:09:13 <edwardk> mapTri f (Tri a b c) = Tri (f a) (f b) (f c)
13:09:24 <edwardk> then you use Tri V3   instead of Tri3
13:09:59 <edwardk> Tri V3 Float  -- is a triangle of 3d points,  Tri V2 Float would be a triangle of 2d points, etc.
13:10:42 <edwardk> Or you could just use V3 (V3 Float) since a triangle is just a triple
13:10:51 <edwardk> then you can just fmap
13:11:14 <erus`> i was told not to use a tuple last time :|
13:11:23 <edwardk> there are lots of design options here
13:11:23 <edwardk> triple, not tuple
13:11:32 <edwardk> i just meant it had 3 elements
13:12:10 <Nimatek> I just found out: http://www.urbandictionary.com/define.php?term=trifect
13:12:22 <erus`> Tri f a, whats f here?
13:12:28 <erus`> the constructor?
13:12:38 <dmwit> f :: * -> *
13:12:48 <edwardk> erus`: f is some type of kind * -> *..  its a type that needs another type
13:13:02 <edwardk> there I'm passing it V3, since V3 needs a type argument
13:13:20 <edwardk> V3 :: * -> *    Int :: *        V3 Int :: *
13:13:30 <erus`> ah
13:13:32 <edwardk> Tri :: (* -> *) -> * -> *
13:13:36 <edwardk> Tri V3 :: * -> *
13:13:39 <edwardk> Tri V3 Int :: *
13:13:55 <erus`> so i should get rid of Tri3 and Tri2
13:14:09 <edwardk> this would let you generalize them away, yes
13:14:43 <edwardk> this gradual process of generalizing away the concrete is something you'll get used to doing a lot in haskell ;)
13:15:05 <edwardk> Nimatek: you're on to me
13:18:14 <Nimatek> edwardk: Don't worry, it is a well known fact that all serious Haskell development involves substantial amounts of mind-altering substances.
13:19:18 <monochrom> such as burritos and unicycles
13:19:40 <hpc> or wearing roller skates in a maple syrup factory
13:19:48 <joeyh> this feels like a dumb question, but how can I convert a strict ByteString into a lazy ByteString?
13:20:01 <hpc> joeyh: put it in a chunk
13:20:11 <hpc> a lazy bytestring is a linked list of strict ones
13:20:16 <hpc> (not a dumb question)
13:20:31 <joeyh> ok, that makes sense
13:20:54 <ben> Isn't there a conversion function?
13:21:05 <joeyh> hayoo can't seem to anwser it, perhaps it doesn't understand module-qualified types
13:21:19 <ben> pack :: [Strict ByteString] -> Lazy ByteString or something
13:21:27 <ben> or fromChunks
13:21:33 <ben> @hoogle fromChunks
13:21:33 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
13:21:33 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
13:21:33 <lambdabot> Data.Text.Lazy fromChunks :: [Text] -> Text
13:21:37 <ben> ah
13:22:10 <joeyh> this is perfect, because I actually have two strict bytestrings I want to concat
13:22:29 <ben> Maybe someone should push for renaming lazy bytestring to byterope :)
13:22:45 <hpc> it's technically still a string
13:22:55 <hpc> (in the sense of having the same structure as String)
13:23:17 <ben> Isn't that the point of a rope?
13:23:43 <hpc> i mean, it's still a linked list, just of bigger things
13:23:45 <rwbarton> a rope is a tree
13:24:23 <edwardk> ben: ropes give you more that just a flat list of fragments
13:24:32 <ben> oh
13:24:50 <edwardk> ben: your fragments can have fragments (yo dawg)
13:25:12 <edwardk> also most SGI style rope structures don't give you efficient access to either endpoint
13:25:12 <dylukes> edwardk: What sort of structure would you recommend if I want a string/list that has fast matching against the END?
13:25:20 <edwardk> dylukes: a fingertree of bytestrings
13:25:31 <hpc> dylukes: a reversed list ;)
13:25:34 <dylukes> I'm writing a little program to conjugate verbs.
13:25:38 <rwbarton> rist
13:25:44 <dylukes> hpc: Yes but it's awkward to work with. :\
13:25:50 <edwardk> do you need ++?
13:25:56 <dylukes> edwardk: also, don't you do that for everything?
13:26:05 <dylukes> edwardk: Arguably a reversed list is probably perfect actually.
13:26:09 <edwardk> do you need random access?
13:26:11 <dylukes> Nope.
13:26:12 <dylukes> Just the end.
13:26:16 <edwardk> then just reverse a list
13:26:33 <edwardk> or make data SnocList a = Snoc (SnocList a) a | Nil
13:26:42 <edwardk> =)
13:26:48 <dylukes> Snoc always amused me.
13:26:55 <edwardk> in practice i'd just as soon use the list and remember its reversed
13:27:26 <dylukes> yeah, but say I want to append stuff...
13:27:37 <dylukes> the stuff has to be reverse too... it works yeah... but it feels meh.
13:28:15 <edwardk> if you need to append, or need access to both ends then i start recommending a fingertree or Data.Sequence
13:28:19 <dylukes> Actually an interesting thought, given a bunch of possible conjugations, I need to represent a graph of how to construct each.
13:28:31 <dylukes> I do need to append, but I could just cons on an empty list.
13:28:36 <dylukes> reversed list*
13:28:55 <edwardk> have you looked at Data.Sequence?
13:29:06 <edwardk> it would future proof you against other needs
13:29:36 <dylukes> mm, seems like ViewR is close to what I'm looking for.
13:30:24 <dylukes> what would you recommend for DAGs?
13:30:43 <dylukes> (I don't really need to enforce the acyclic part mind you...)
13:31:18 <dylukes> http://haskell.org/ghc/docs/7.0.3/html/libraries/containers-0.4.0.0/Data-Graph.html
13:31:20 <dylukes> is this okay?
13:31:59 <erus`> edwardk: the generic triangle brakes down because a 2d triangle doesnt have a normal
13:32:27 <edwardk> just define cross for Tri V3
13:32:30 <erus`> so some functions dont apply
13:32:31 <edwardk> its a special case
13:32:37 <erus`> ah i see
13:33:01 <edwardk> er rather define normal for Tri V3, etc.
13:33:32 <dylukes> edwardk: The whole "capital letters" thing for data types is a bit annoying some times.
13:33:38 <dylukes> I'd like to use hiragana...
13:33:58 <edwardk> dylukes: sok, those of us who want to read your code would prefer you didn't ;)
13:34:09 <dylukes> People want to read my code :0
13:35:07 <edwardk> dylukes: anyways it is far less annoying than trying to live in a world without punning between the term and type namespaces
13:35:16 <dylukes> This is true.
13:35:30 <dylukes> the "upper/lower" thing kind of falls apart for non-latin alphabets tho
13:35:37 <dylukes> or syllabaries or ideographs or what have you
13:35:43 <edwardk> you wind up like you do with ML where you get Foo FOO foo, all to get around naming the term, type and module structure and then you still sometimes need a 4th ;)
13:35:45 <dylukes> arguably thats a case not to use them.
13:35:53 <dylukes> haha, yeah
13:36:16 <edwardk> the alternative is to require a ' mark or some such as a syntactic distinction, but that also gets repetitive
13:36:27 <dmwit> dylukes: Will you want to observe sharing?
13:36:35 <dylukes> dmwit: what.
13:36:39 <dylukes> that sounds like edwardk-bait.
13:36:45 <edwardk> upper/lower isn't perfect, but it is a pretty good compromise for a rather wide audience
13:36:48 <edwardk> hah
13:36:51 <dylukes> edwardk: types' are' easy' like' this'
13:36:54 <dylukes> >_>
13:37:14 <edwardk> Its just 'a list, no problem, right? =)
13:37:14 <dmwit> dylukes: You can make a very efficient DAG in memory just using the Data.Tree type.
13:37:23 <dylukes> I'm not too concerned about efficiency
13:37:24 <hpc> T_hungarian_notation_ftw
13:37:28 <dylukes> rather I want the code to be elegant :P
13:37:29 <dmwit> dylukes: (by sharing subtrees)
13:37:37 <dylukes> hpc: ftw_notation_hungarian_dns_reverse_T
13:37:56 <dmwit> dylukes: But operations on a Data.Tree won't be able to tell the difference between an efficient DAG and its exploded version.
13:38:13 <dmwit> If you want to be able to observe the difference (for example, to preserve it), you need something fancier.
13:38:27 <edwardk> http://hackage.haskell.org/package/data-reify-0.6
13:38:52 <edwardk> i retired my code for doing observable sharing when andy released that
13:38:58 <dylukes> You're cruising over y head right now.
13:39:02 <dylukes> What is observable sharing?
13:39:19 <dmwit> dylukes: For example, the list (1:) only has one node in memory.
13:39:38 <dmwit> sorry
13:39:45 <dmwit> I meant "fix (1:)".
13:39:52 <dmwit> aka repeat 1
13:40:08 <edwardk> dylukes: it lets you use the fact that behind the scenes two things were built with the same thunk.
13:40:28 <dmwit> But other code that uses the list "fix (1:)" won't "notice" that it's only one node -- it will treat it like any other list with infinitely many nodes.
13:41:06 <edwardk> given data ListF a b = Cons a b | Nil     -- then you could reify fix ('x':) into Graph [(0, Cons 'x' 0)] 0 using data-reify
13:41:12 * gwern casually tries out some DoS attacks on http://dbwiscam.informatik.uni-tuebingen.de/trydsh/ 
13:41:16 <dmwit> So "map (+1) (fix (1:))", for example, doesn't have only one node, even though in principle it might be possible to create a semantically identical list with only one node.
13:41:29 <dylukes> edwardk: the point being?
13:41:32 <edwardk> where the numbers are just unique values and you can lookup the nodes in the list
13:42:18 <edwardk> because one is a small finite representation and the other would take infinite space to send over the wire
13:42:50 <edwardk> i'll start to serialize the latter, you start to serialize the former, we'll see who gets done first =)
13:42:50 <ben> dmwit: Is there a way around that? Like, with a smarter, nonportable map?
13:42:54 <dmwit> Right. Or, in the case of a DAG, one is a small finite representation and the other is a big finite representation.
13:43:12 <dmwit> ben: Yes, see data-reify, which edwardk has linked to above. =)
13:43:35 <ben> ah
13:43:39 <edwardk> ben: and i've built a 'nicer map' on top of something data-reify'ish, not sure i ever packaged it though
13:44:21 <edwardk> dylukes: but in the case of, say automatic differentiation, i wind up building a graph out of user inputs that i then have to walk backwards
13:44:26 <dmwit> dylukes: If you don't mind Data.Graph's API, then working explicitly with graphs (i.e. having the graph structure reflected in your data) is probably simplest.
13:44:37 <dylukes> dmwit: but I'm TRYING to work with a graph
13:44:42 <dylukes> specifically a graph of how you can conjugate
13:44:48 <dmwit> dylukes: But if you want to expose a different API that hides the explicit graph-ness, then you have to start thinking about what to do.
13:45:00 <edwardk> if i _don't_ observe sharing then computing the derivative of 2 ^ 256 won't complete before the heat death of the universe.
13:45:00 <edwardk> if i do its instantaneous
13:45:02 <dylukes> i.e, you can go from one conjugation to another.
13:45:14 <dylukes> If I had to represent it as a category actually,
13:45:24 <dylukes> each object would be a conjugation
13:45:32 <dylukes> each arrow is a transformation from one conjugation to another
13:45:50 <edwardk> dylukes: the point is to let you program using haskell's sharing as the only sharing you need to consider, and then use data-reify to magically construct the annoying graph representation
13:46:14 <dylukes> I hope you realize I'm not exactly following.
13:46:14 <dmwit> (...but only if you want to)
13:46:17 <dylukes> I actually just want a graph.
13:46:25 <dylukes> I'm not trying to do anything else but have a graph.
13:46:29 <dylukes> that I can traverse.
13:47:01 <edwardk> and we're trying to give you a graph, but let you program the stuff that build it in a nicer style
13:47:12 <mreh> http://echochamber.me/viewtopic.php?f=10&t=59236
13:47:17 <dmwit> dylukes: Okay, here's the point: there's two graphs of interest. One is the graph induced by your heap structure, where nodes are Haskell objects and edges are pointers. The other is the mathematical graph that you're modeling with your heap structure.
13:47:25 <dylukes> edwardk: Yes but it's a bit overwhelming ^^;
13:47:35 <dylukes> dmwit: alright.
13:47:39 <dmwit> dylukes: Those can often be quite different.
13:47:52 <dylukes> oay
13:47:54 <dylukes> okay*
13:48:12 <mreh> i found that whilst trying to find out what happened to MonadState for the acid-state
13:48:15 <mreh> MonadRandom*
13:48:16 <hpc> heh
13:48:29 <dmwit> dylukes: Moreover, the mathematical graph you're modeling may have features that make it possible to represent as a more compact in-memory graph.
13:48:45 <edwardk> fix (1:) has a very simple heap structure, but represents an infinite graph
13:49:22 <zzing> Would anyone consider using Gloss for games?
13:49:38 <dylukes> alright...
13:49:39 <dmwit> dylukes: (For example, the "graph" that has nodes 0, 1, 2, ..., each containing the Haskell object "Hi!" and edges 0 -> 1, 1 -> 2, 2 -> 3, ..., can be represented as a *single* in-memory node with a pointer to itself. These are observationally equivalent graphs.)
13:49:58 <dylukes> right.
13:50:02 <monochrom> observing sharing: http://ro-che.info/ccc/09.html :)
13:50:07 <dmwit> dylukes: So you get a beautiful API (the list API) for managing a mathematically infinite object.
13:50:16 <dylukes> so I might be able to represent an (lets pretend) infinite graph of all possible conjugations
13:50:23 <mreh> why did happstack-state have an monad random instance, seems unsafe to write out your random generator's state to the disk
13:50:24 <dylukes> although, there are not infinite conjugations
13:50:37 <dylukes> well, technically there are non terminating cycles you could go through, but they aren't "valid".
13:50:40 <dmwit> Even with finite nodes, there could be infinite edges. =)
13:50:52 <edwardk> in general in an ADT you wind up with the only sharing being done in the heap and if i go to compute something over all my branches i'll recompute it over and over for the branches that are the same, destroying that sharing
13:51:13 <edwardk> i can't see that i've already been there and given the answer for that common tail
13:51:18 <dylukes> mm
13:51:19 <edwardk> this is the difference between a tree and a dag =)
13:51:51 <edwardk> in haskell you can use ADTs to build trees, which may be represented on the HEAP as a dag, but you can't see that sharing directly
13:51:59 <edwardk> and mapping, etc. destroys it
13:52:15 <edwardk> the alternative is to instead of using a nice ADT where you directly have another node as a descendant
13:52:16 <dylukes> what do you mean by "destroying sharing"
13:52:31 <alpounet_> zzing, have you taken a look at fungen ?
13:52:39 <zzing> alpounet_: yes I have
13:52:42 <edwardk> to instead use something like an IORef which you can compare for equality or an Int for a node id and store the nodes in a list or map or something
13:52:51 <edwardk> map (+1) (fix (1:))
13:53:00 <edwardk> the result now takes more heap space
13:53:05 <edwardk> than fix (2:)
13:53:35 <dylukes> I... see... (nope)
13:53:39 <dylukes> Egh. one moment.
13:53:46 <erus`> would be nice if i could pattern match on types
13:53:48 <dylukes> Let me just jot down some stuff, then I'll describe the actual use case.
13:54:03 <edwardk> erus`: that is what classes are for
13:54:09 <edwardk> erus`: and it is very very nice that you can't ;)
13:54:24 <edwardk> erus`: you just need more exposure to the type system to realize those benefits
13:54:33 <edwardk> erus`: parametricity is a wonderful thing
13:54:48 <edwardk> it lets you know which details are completely irrelevant to the operation you are performing
13:54:59 <edwardk> i wouldn't give that up for typecase
13:55:23 <_oz> and also, how would you make sure you cover all the cases? :)
13:56:29 <aristid> _oz: by using stricter kinds than Set?
13:57:14 <_oz> then, someone will want pattern matching on kinds. there you go.
13:59:08 <edwardk> _oz: we're getting that actually in the new ghc =)
13:59:25 <edwardk> _oz: well, we're getting kind indexed type families as part of the new kind system
13:59:39 <edwardk> they are actually quite useful
13:59:50 <hpc> you can also try agda
13:59:51 <hpc> :P
14:00:02 <edwardk> hpc: i like type inference =)
14:00:08 <totofe> I wonder why 'let add2 = \n -> n+2' gets type Integer -> Integer rather than (Num a) => a -> a
14:00:19 <Saizan> in agda there's even less pattern matching on types.
14:00:26 <hpc> totofe: the dreaded monomorphism restriction
14:00:30 <Saizan> but you can use universes
14:00:37 <hpaste> erus` pasted ‚Äúerrur‚Äù at http://hpaste.org/53945
14:00:49 <hpc> add2 "looks like a value", so ghc decides that it is going to be defaulted to Integer -> Integer
14:00:49 <erus`> edwardk: one mroe look please?
14:01:03 <hpc> totofe: if you wrote 'let add2 n = ...', it would be correctly polymorphic
14:01:12 <_oz> totofe: http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
14:01:15 <edwardk> triMap :: (f a -> f b) -> Tri f a -> Tri f b
14:01:26 <zzing> What syntax is this? "resizeScene s@(Size width height) = do"  with the s@(...) I have seen it in pattern matching situations.
14:01:29 <Saizan> (but you can use universes in haskell too, to some extent)
14:01:30 <totofe> hpc: yes I tried add2 n = ...
14:01:37 <edwardk> then you can also make the Functor instance I gave above as well
14:01:48 * hackagebot scion-browser 0.1.3.2 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.1.3.2 (JeanPhilippeMoresmau)
14:01:49 <edwardk> so fmap and triMap are two distinct operations available on Tri
14:02:02 <hpc> zzing: foo@(Bar baz) is a pattern that binds the whole thing to the name 'foo', and matches against the Bar constructor
14:02:15 <zzing> Can be useful
14:02:17 <totofe> hpc: was thinking add2 n = .. was just syntactic sugar for add2 = \n -> ...
14:02:24 <hpc> zzing: it's basically so you don't have to say (Bar baz) everywhere if you want to pattern match
14:02:39 <hpaste> edwardk annotated ‚Äúerrur‚Äù with ‚Äúerrur (annotation)‚Äù at http://hpaste.org/53945#a53946
14:02:50 <hpc> totofe: it is, the monomorphism restriction is just dumb
14:04:06 <edwardk> hpc: you say that because you haven't noticed how many times its saved your butt
14:04:45 <edwardk> hpc: turning it off can mean rampant performance regressions, but scary asymptotic ones, not constant ones
14:04:49 <hpc> edwardk: it hasn't; i use type signatures on just about everything top-level
14:05:13 <edwardk> its the mono local binds that i'm concerned with
14:06:12 <edwardk> i just computed let v = 2 in v + v  -- i just computed fromIntegral 2 for an Int, oh crap lets do it again because we don't necessarily know that the type is the same....
14:07:07 <edwardk> the ability to share the definition of v there requires the local bind to be monomorphic, otherwise you baically just call the same function from a dictionary twice and rely on common subexpression elimination, which is more brittle to recover sharing
14:07:56 <edwardk> so under -O0 or so you really are screwed
14:08:50 <totofe> haskell 98 report, 4.5.5  The Monomorphism Restriction, thanks hpc
14:09:39 <dylukes> edwardk: what would you recommend with parser combinators
14:09:54 <edwardk> ?
14:10:02 <dylukes> Like, I've always run into situations where I had to turn it on
14:10:04 <Saizan> tbf, if v's definition transitively referred to some argument to your function the type would be monomorphic anyway, though that's more an argument for not generalizing let bindings at all than anything
14:10:04 <byorgey> . o O ( which is a worse surprise for newbies: that their types seem all screwy, or that their performance is bad? )
14:10:12 <dylukes> or Trifecta/we complains of bad types.
14:10:27 <edwardk> dylukes: there i'd just say turn it on. the situation is even worse under parsec =)
14:10:59 <edwardk> byorgey: one tells them they don't know what we're doing, the other tells them we don't know what we're doing =)
14:11:04 <dylukes> for something as simple as foo = oneOf "abc"
14:11:17 <dylukes> " Ambiguous type variable `m0' in the constraint"
14:11:17 <byorgey> edwardk: heh, fair enough =)
14:11:27 <dylukes> is there another way to resolve it than using no monomorphism restriction?
14:11:38 <edwardk> dylukes: nope
14:11:42 <dylukes> oh.
14:11:47 <dylukes> apparently putting the type signature fixes it.
14:11:48 <dylukes> somehow.
14:11:53 <dylukes> ...odd
14:11:55 <edwardk> the type signature fixes everything
14:12:05 <dylukes> :P
14:12:13 <edwardk> i just put in top level ignatures on everything i write because -Wall is whiny
14:12:20 <dylukes> yeah :P
14:12:33 <edwardk> and i have a pedantic streak that doesn't let me ship something with a warning in it ;)
14:12:42 <erus`> > (f a a a -> b) -> [a] -> b
14:12:43 <lambdabot>   <no location info>: parse error on input `->'
14:12:43 * byorgey does the same thing
14:12:46 <erus`> @hoogle (f a a a -> b) -> [a] -> b
14:12:47 <lambdabot> No results found
14:13:03 <erus`> @hoogle (f a a a -> b) -> (a,a,a) -> b
14:13:03 <lambdabot> No results found
14:13:04 <edwardk> eris: what the f a a a  ?
14:13:14 <ben> does polymorphism itself preclude sharing?
14:13:33 <edwardk> erus`: i don't think that means what you think it means
14:13:35 <byorgey> but the other day I had a warning about a missing sig, but I would have to depend on another package in order to be able to write the type
14:13:35 <erus`> to3D (Tri p0 p1 p2) = Tri $ unlistthing $ map V2.to3D [p0, p1, p2]
14:13:39 <byorgey> I didn't know what to do =(
14:14:07 <companion_cube> there should be cuurry/uncuurry functions for those cases :]
14:14:10 <edwardk> ben: polymoprhism is fine. polymorphism with constraints? the issue is that it desugars into a function from a dictionary to a value, which we share just fine =)
14:14:11 <dmwit> byorgey: wut
14:14:14 <byorgey> in the end I just added the dep, because after all it was already a transitive dep
14:14:21 <dmwit> ah
14:14:22 <erus`> can i write a function like:        Tri f a -> Tri g b ?
14:14:27 <edwardk> ben: of course sharing that function is kinda silly
14:14:35 <edwardk> as it isn't what you really wanted so share
14:14:46 <dmwit> erus`: (f a -> g b) -> Tri f a -> Tri g b
14:14:58 <dmwit> ?help djinn
14:14:58 <lambdabot> djinn <type>.
14:14:58 <lambdabot> Generates Haskell code from a type.
14:14:58 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:15:08 <edwardk> what you really wanted to share was the fact that in two places you applied that function to the same dictionary.
14:15:11 <dmwit> ?djinn-let data Tri f a = Tri (f a) (f a) (f a)
14:15:11 <lambdabot> Maybe you meant: djinn-del djinn-ver
14:15:18 <edwardk> that requires common subexpression elimination
14:15:26 <erus`> ah man thats sick
14:15:31 <ben> So in let v = 2 in v + 2, the constraint is Num?
14:15:33 <erus`> i feel like a 1337 hax0r
14:15:35 <ben> err, v+v
14:15:44 <dmwit> ?djinn-add data Tri f a = Tri (f a) (f a) (f a)
14:16:01 <dmwit> ?djinn (f a -> g b) -> (Tri f a -> Tri g b)
14:16:01 <lambdabot> Error: kind error: (KVar 4,KVar 2)
14:16:08 <dmwit> oh my
14:16:13 <edwardk> hah interesting
14:16:19 <edwardk> djinn bug!
14:16:47 <ben> Can't it tell that it's only ever used as one type and let it be nominally polymorphic while really optimising it or something, in this case? :V
14:17:30 <totofe> putting add2 :: (Num a) => a -> a in the has file solves it
14:17:39 <ben> wait the result coulditself be polymorphic ;_;
14:17:42 <totofe> but defining in ghci let add2 = (\n -> n + 2) :: (Num a) => a -> a don't, oddly
14:17:48 <edwardk> ben: exactly
14:18:07 <totofe> althoug let add2 = (\n -> n + 2) :: Int -> Int does work
14:18:27 <totofe> in the _.hs_ file, sorry
14:18:46 <edwardk> ben: so it gets around to desugaring it to foo_ numDict = plus_ numDict (fromIntegral_ numDict 2) (fromIntegral_ numDict 2)
14:18:56 <edwardk> then it needs to spot that fromIntegral_ numDict 2  is used twice
14:19:33 <edwardk> foo_ numDict = let v = fromIntegral_ numDict 2 in plus_ numDict v v
14:19:55 <edwardk> but that is just what the monomorphic local bind let us retain in the first place.
14:20:55 <edwardk> removing monomorphic local binds makes typechecking harder, and puts greater pressure on the optimizer
14:31:25 <iboB> how big is the stack of ghci?
14:31:52 <iboB> i'm getting stack overflows for recursion i wouldn't consider very deep (for a c program, for example)
14:32:03 <edwardk> ghc magically grows the stack for you, it starts out something ridiculously tiny like 256 bytes, and then grows quite deep
14:32:09 <dmwit> iboB: Stack overflows are different in Haskell.
14:32:20 <dmwit> iboB: They happen from deeply-nested thunks, not from deeply-nested function calls.
14:32:26 <edwardk> but what overflows in haskell vs. c is rather different, because of laziness
14:32:35 <iboB> aha
14:32:43 <edwardk> so you probably have a bad intuition about what part it crashing you
14:32:58 <edwardk> likely you're adding to a counter or something in a shallow looop
14:32:59 <dmwit> iboB: For example, if you are using foldl on a long list, you should probably stop doing that.
14:33:07 <edwardk> and then later looking at the counter
14:33:07 <iboB> yes i am
14:33:16 <dmwit> Or if you're writing a tail-call recursive function with an accumulator, don't bother.
14:33:17 <iboB> dmwit i'm using foldl on a quite long list
14:33:22 <edwardk> you want foldr
14:33:23 <dmwit> iboB: Use foldr or foldl' instead.
14:33:28 <edwardk> or foldl'
14:33:36 <iboB> thanks
14:34:10 <dufflebunk> Is there any way to make cabal to build hadock docs?
14:34:19 <dmwit> iboB: In general, you want foldr, foldl', or scanl; foldl and scanr are almost never a good idea. =)
14:34:39 <dmwit> dufflebunk: "cabal haddock"
14:34:59 <iboB> dmwit, thank you
14:35:13 <dmwit> dufflebunk: If you want "cabal install" to build and install haddocks, twiddle the bit in ~/.cabal/config
14:35:19 <zeiris> edwardk: how do I turn a `Parse String a` into a `Monadlayout m => m a`?
14:35:32 <edwardk> zeiris: adding Layout?
14:35:37 <Spockz_> did anyone actually benchmark cabal? cabal update is slow because of the processing not because of the time it takes to download the update!
14:35:40 <dmwit> dufflebunk: I have "documentation: True" in mine.
14:35:47 <iboB> hm... switched to foldr and got stack overflow again :)
14:36:06 <dmwit> ?hpaste some code, iboB
14:36:06 <lambdabot> Haskell pastebin: http://hpaste.org/
14:36:17 <edwardk> zeiris: https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Layout/Monad.hs#L38
14:36:20 <dufflebunk> For example, hxt doesn't seem to have docs anywerhe only, and cabal install doesn't build them.
14:36:48 <iboB> it's quite long actually
14:36:49 <iboB> but ok
14:36:52 <iboB> just a sec
14:37:02 <edwardk> zeiris: build your parser with Layout (Parser ‚Ä¶) a  instead of Parser ‚Ä¶ a
14:37:04 <byorgey> dufflebunk: eh?
14:37:25 <edwardk> Layout is a parser transformer which changes the behavior of the whitespace parser to understand haskell-style layout rules
14:38:31 <dufflebunk> byorgey, http://hackage.haskell.org/package/hxt  doesn't have links to the actual docs, and they don't seem to be on the home page either
14:39:20 <iboB> dmwit http://hpaste.org/53948
14:39:46 <iboB> i've been working for almost 8 hours... so :)
14:40:06 <iboB> basically pe23 is what's important
14:41:50 <jhance> m
14:41:57 <dmwit> pretty code... pretty code... pretty code... BAM! pe23
14:41:59 <dmwit> =P
14:42:03 <dmwit> (still reading)
14:42:09 <iboB> project euler problem 23
14:43:21 <iboB> basically find the sum of all numbers that can't be represented as a sum of two abundants
14:44:24 <dmwit> hm, using foldr and Set.insert together looks a bit fishy to me
14:45:35 <dmwit> Is there a reason you are using foldr toSet Set.empty rather than Set.fromList?
14:46:11 <iboB> the next argument (takeWhile...) returns a list of lists
14:46:44 <dmwit> fromList . concat
14:46:45 <iboB> a quite long one, too, several thousand lists of several hundred elements each
14:47:12 <sshc> What is that OpenGL library that defines its own GL type for OpenGL actions as generally a subset of IO?
14:47:49 <iboB> dmwit you're right, i didn't use concat because i used foldl which could've probably saved some memory
14:47:59 <iboB> (lazy evaluation and all)
14:48:23 <dmwit> iboB: So, yeah, Set is spine-strict; foldr works best with things that are lazy. So you can either switch to foldl' or fromList and concat; either should be approximately equally performant.
14:48:48 <dmwit> (fromList internally uses a strict left fold)
14:48:53 <dmwit> (like foldl')
14:49:08 <dmwit> ?src foldl'
14:49:08 <lambdabot> foldl' f a []     = a
14:49:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:49:17 <iboB> ok thanks, i'll try it
14:49:49 <dmwit> In fact, their internal "foldlStrict" is exactly that foldl', but worker-wrapper transformed.
14:51:15 <iboB> yay
14:51:19 <iboB> it worked
14:51:21 <iboB> thanks
14:52:27 <iboB> is there a compiler switch that links automatically to the imported libraries?
14:53:53 <hjulle> iboB: -make?
14:57:22 <iboB> hjulle -make? i use "ghc -o executable source"
14:57:27 <iboB> i get linker errors
14:58:06 <rwbarton> --make
14:58:19 <iboB> aah
14:58:24 <iboB> ok thanks
14:58:27 <iboB> it works now :)
14:59:45 <iboB> curiously the executable isn't that much faster than ghci
14:59:52 <elliott> iboB: -O
15:00:03 <jmcarthur> iboB: built with -O or -O2?
15:01:05 <iboB> is this compatible with --make?
15:01:19 <iboB> "ghc --make source.hs -O2" ?
15:04:17 <elliott> iboB: ghc --make -O2 source.hs
15:04:26 <elliott> i suppose it can go after too if you want
15:05:04 <iboB> yes it seems it doesn't matter where it is
15:05:34 <jjohnsson> I thought you didn't need to use --make as of GHC >7.0. But I might remember incorrectly.
15:05:39 <iboB> that's better, ghci runs my pe23 for 95 seconds and built with O2 it runs for 4 seconds :)
15:06:09 <iboB> again yay
15:06:13 <sshc> Aha!  OGL
15:26:28 <dylex> is there some class like MonadError that generalizes liftCatch for arbitrary Exceptions?  MonadError only does so for IOException.
15:27:18 <Hydrant> can anyone point me to some good documentation for fmap?  I'm fuzzy on what it does...
15:27:48 <_oz> Hydrant: do you understand what map does?
15:27:51 <_oz> :t map
15:27:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:28:23 <Hydrant> I do understand map..
15:29:04 <_oz> maybe it'll help you grok fmap
15:29:12 <_oz> fmap is similar, but works for every Functor not just only for lists
15:29:24 <_oz> map (+1) [0,1,2,3]
15:29:34 <_oz> fmap (+1) [0,1,2,3]
15:29:38 <_oz> are equivalent
15:30:03 <Hydrant> the code I am using does IO, so perhaps that is why fmap is used
15:30:16 <_oz> yes
15:31:18 <_oz> in that case IO is just like list, it is a context. you may think this way: fmap applies the given operation to the value contained in the context
15:31:59 <_oz> k :: IO Int
15:32:18 <_oz> l = fmap (+1) k
15:33:14 <Hydrant> okay, I get it well enough to trace some more code
15:33:25 * Hydrant is attempting to understand a block of haskell code
15:34:24 <shachaf> _oz: "the value contained" isn't really accurate.
15:34:58 <shachaf> For most functors f Int doesn't really contain an Int.
15:35:39 <_oz> shachaf: it makes sense for IO though. at least easier to think about
15:36:18 <shachaf> _oz: Well, for IO in particular, a value :: IO Int doesn't contain a value :: Int.
15:39:36 <elliott> Not the container model of monads? :(
15:39:54 <_oz> shachaf: I was just trying to simplify matters to aid understanding.
15:40:15 <elliott> Inaccurate models of monads have never helped anyone :P
15:40:33 <stepcut> :)
15:40:48 <stepcut> stupid models
15:40:59 <elliott> We should just read out the Prelude to everyone.
15:41:05 <_oz> elliott: to be fair, it was an inaccurate model of functors this time
15:41:09 <elliott> If they don't understand, they're not Worthy(tm).
15:41:13 <elliott> _oz: heh :)
15:41:29 <elliott> _functors are pretty hard to analogise because they're so simple, but thankfully they're so simple that usually you don't need to analogise... at least in my experience
15:42:07 <stepcut> but, once you understand funtors, pointed, and applicative, then monads are so simple you don't need a model either :)
15:42:38 <mithos28> How much nursery garbage is too much? If I am allocating 2.7 gigs in about 1 sec according to the profiling tools, is that likely my problem?
15:42:47 <_oz> everything is simple after you understand them.
15:43:15 <stepcut> mithos28: depends, are you running out of ram ?
15:43:22 <Hydrant> how do I parse this... map f $ g $ b... where f, g are functions and b is a list.... is it fmap (map f) (fmap g b) ?
15:43:52 <elliott> map f (g (b))
15:43:53 <rwbarton> it's just  map f (g b)
15:43:53 <_oz> Hydrant: check the types of f & g, they should help
15:43:57 <elliott> a $ b $ c = a (b c)
15:44:05 <elliott> a . b $ c = a (b c), too
15:44:08 <shachaf> elliott: Not in Caleskell!
15:44:19 <elliott> shachaf: We don't talk about Caleskell to the newbies.
15:44:25 <elliott> :t (.)
15:44:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:44:53 <mithos28> stepcut: not that I can tell, but 2.7 gigs seems like a lot of allocation
15:44:58 <stepcut> I wish there was a Category instance of $.. but that doesn't really work :-/
15:45:10 <elliott> stepcut: instance Category ($)?
15:45:23 <elliott> (.) :: b c -> a b -> a c?
15:45:25 <elliott> id :: a a?
15:45:28 <shachaf> elliott: That type is boring compared to composition in Agda. :-)
15:45:38 <stepcut> mithos28: depends what you are doing.. somethings just create a lot of temporary data. That is not wrong ..
15:45:47 <rwbarton> mithos28: 2.7 gigs / sec is pretty typical and probably not a problem
15:46:29 <stepcut> elliott:  yeah. (.)  = (<<<), and it kind of feels like we should have, ($) = (>>>). But that does not actually make sense
15:46:51 <elliott> stepcut: That's not what I said :P
15:46:56 <elliott> stepcut: There's ArrowApply.
15:47:05 <stepcut> but, f >>> g >>> h, is just so verbose when, f $ g $ h, would be nice
15:47:14 <mithos28> rwbarton: ok, I had no idea what typical is. But that seemed like a lot, but if it is normal I'll look somewhere else
15:47:16 <elliott> { class (Category c) => Apply c where ($) :: c a b -> a -> b } might be a reasonable thing.
15:47:25 <stepcut> hmm
15:47:27 <elliott> stepcut: We just need a name like (.>) for (>>>).
15:47:27 <Hydrant> elliott: to make sure I understand you,  a $ b $ c = a (b c) literally just means "call function a with arguments b c)?
15:47:34 <stepcut> elliott:
15:47:37 <stepcut> elliott: yeah
15:47:37 <elliott> Hydrant: Yes. $ is just a trick to avoid parentheses.
15:47:43 <rwbarton> mithos28: allocating memory itself is just decrementing a pointer, it's only data that gets copied by GC that has a significant cost
15:47:48 <elliott> foo $ bar baz $ quux blah
15:47:51 <elliott> == foo (bar baz (quux blah))
15:47:56 <Hydrant> elliott: thx
15:47:59 <shachaf> Hydrant: No, it means "call function a with argument (result returned by calling function b with argument c)".
15:48:11 <elliott> Oh, right.
15:48:15 <shachaf> a has only one argument.
15:48:26 <stepcut> elliott: I kind of like, (‚ê£) = (>>>)
15:48:44 <stepcut> because we normally use a 'space' for applying a function :)
15:48:55 <stepcut> but type unicode is a pain
15:49:22 <shachaf> Type Unicode sounds like a much bigger pain than Value Unicode.
15:49:25 <Hydrant> so ... map f $ g $ b is ... map f(g (b))
15:49:33 <elliott> Hydrant: Yes.
15:49:36 <stepcut> i mean.. typing unicode characters
15:49:36 <shachaf> Hydrant: map f (g b)
15:49:42 * stepcut should learn to proof-read before hitting enter
15:49:54 <dschoepe> stepcut: Sounds like you need a better editor :)
15:50:06 <stepcut> dschoepe: or a better emacs mode
15:50:12 <stepcut> using unicode in Agda is ok
15:50:25 <dschoepe> stepcut: then just run toggle-input-method and select agda
15:50:28 <stepcut> maybe I need a bigger keyboard
15:50:31 <dschoepe> stepcut: it will work in haskell as well
15:50:31 <Hydrant> is there somewhere I can read more about $ so I can understand it better?
15:50:55 <stepcut> @src ($)
15:50:55 <lambdabot> f $ x = f x
15:50:57 <dschoepe> (or anywhere else for that matter)
15:50:58 <shachaf> Hydrant: You should read an introduction to Haskell in general that explains infix operators.
15:51:28 <stepcut> @type ($)
15:51:30 <lambdabot> forall a b. (a -> b) -> a -> b
15:51:54 <stepcut> that is the definition of ($) in it's entirety.. it's just defined as a normal haskell function, which is cool
15:52:22 <stepcut> actually, there is one more part.. the part that declares the infix-ness
15:54:34 <Nimatek> Hydrant: One way of thinking about it, is that it takes the whole right hand side  as the parameter to the function on the left. The same as putting parenthesis around it.
16:12:14 <erus`> how can i build a rotation matrix such that m * v1 = v2 ? where v1 and v2 are vectors
16:12:57 <edwardk> erus: You used build tri out of vectors right? lets do the same thing with matrices, that way you can make matrices from a V3 to a V2, etc
16:13:30 <erus`> yeah i have the matrix type
16:13:33 <edwardk> You could make newtype Mat f g a = Mat (f (g a))
16:13:35 <erus`> but i dont know the math
16:13:45 <edwardk> Then you can view a matrix as a vector of vectors
16:13:50 <edwardk> Mat V3 V3
16:13:56 <erus`> yeah thats what i have :)
16:14:19 <edwardk> the tricky part is you need a way to zip up two vectors
16:14:31 <edwardk> so lets define a class for that
16:14:59 <edwardk> class Zip f where fzip :: (a -> b -> c) -> f a -> f b -> f c
16:15:05 <edwardk> er fzipWith
16:15:21 <edwardk> then you can make V2, and V3 instances of that
16:15:47 <edwardk> instance Zip V2 where fzip f (V2 x y) (V2 x' y') = V2 (f x x') (f y y')
16:16:01 <roconnor> > (-1 :: Integer) `shiftR` 8
16:16:02 <lambdabot>   -1
16:16:17 <erus`> i think you misunderstood my question :)
16:16:18 <strager> What's a recommended build process for (small) Haskell programs?  Should I roll my own make rules calling ghc, or is there some template or other preferred make program?
16:16:32 <edwardk> no. i'm getting to your question =)
16:16:44 <edwardk> oh
16:16:56 <edwardk> you want to know how to construct such a matrix given just v1 and v2?
16:17:04 <erus`> yup
16:17:07 <edwardk> you can't
16:17:13 <edwardk> its underdetermined
16:17:36 <edwardk> consider, you have 2 3d vectors. thats 6 numbers
16:17:43 <edwardk> but you want a matrix.. thats 9
16:17:52 <edwardk> even if you don't consider anything else
16:19:04 <erus`> in that case, i need to construct a matrix such that m * m1 = m2
16:19:18 <erus`> or is that m1 * m = m2 ? I dont know
16:19:20 <gio123> is there native english speaker?
16:19:44 <edwardk> gio123: i'm pretty sure there exists at least one
16:19:44 <edwardk> erus`: you want the inverse of the matrix
16:20:03 <gio123> edwardk: u?
16:20:45 <hpaste> swarley pasted ‚ÄúError in the first expression‚Äù at http://hpaste.org/53950
16:20:53 <edwardk> Given you want a matrix such that if x = A * y then inv A * x = inv A * A * y = y
16:20:58 <edwardk> gio123: yes
16:20:58 <swarley> Can anyone explain the error of that to me?
16:21:20 <monochrom> delete all "return"
16:21:22 <gio123> edwardk: may I pm u?
16:21:27 <edwardk> sure
16:21:38 <monochrom> sorry, maybe not
16:21:49 * hackagebot wai-middleware-route 0.1 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.1 (AlexanderDorofeev)
16:22:07 <monochrom> I see. I'll annotate
16:22:28 <kev07> Can anyone please explain to me why I should learn Haskell over something such as java?
16:22:41 <sipa> intellectual development
16:23:10 <kev07> Sipa: how so
16:24:14 <swarley> Well, imo i think haskell looks better syntactically and it makes you think differently than most languages do with its pure functional nature.. I would actually start with it because you can take the functional mind set and apply it else where, where it is harder to go say, Object Oriented to functional
16:24:21 <hpaste> monochrom annotated ‚ÄúError in the first expression‚Äù with ‚ÄúError in the first expression (annotation)‚Äù at http://hpaste.org/53950#a53951
16:24:31 <monochrom> there
16:24:37 <edwardk> kev07: if you learn java you learn yet another programming language. when you learn haskell you learn a new way of thinking. up until i found haskell i'd kind of fallen into a rut as a programmer.
16:24:59 <erus`> edwardk: ah so i need to invert a matrix somehow. :) you meant (inv a) * x = y     not      inv (a * x) = y right?
16:25:17 <edwardk> erus: yes
16:25:33 <kev07> Stupid reasons
16:25:35 <swarley> monochrom, thank you!
16:25:42 <elliott> kev07: stupid trolling
16:26:01 <Nimatek> kev07: You will be really popular at cocktail parties, and the chicks dig it.
16:26:15 <kev07> How do you even make equivalent of objects for ex
16:26:17 <swarley> kev07, well then, simply. Java looks ugly, haskell looks pretty
16:26:19 <kev07> Huh?
16:26:23 <elliott> kev07: data types and functions
16:27:09 <kev07> Java looks great with colors. The xmonad.hs file looks horrible in vim
16:27:31 <sipa> de gustibus et coloribus
16:27:33 <swarley> Car { model :: a, year :: b, color :: c} i think is  data type.. im still working through the Learn you a haskell book
16:27:42 <kev07> Elliott: java has data types/adt and methods
16:27:56 <elliott> kev07: sorry, you're not interesting enough a troll to feed :(
16:27:59 <sipa> kev07: why are you here?
16:28:18 <monochrom> IMO "why should I learn ___" in channel #____ should be defined as trolling and banned.
16:28:33 <prototrout> So I'm new to arrows and I want to sanity-check this: is it possible to write a function of type "Arrow a => a (b,[a b c]) [c]"?
16:28:38 <monochrom> it's a free country, you decide what not to learn, why ask provocatively.
16:28:45 <jmcarthur> monochrom: nah, i think it's what comes later that is trolling... "Stupid reasons"
16:28:48 <elliott> prototrout: that needs ArrowApply I think
16:28:48 <kev07> I'm trying to play devil advocate to learn about Haskell...
16:28:53 <prototrout> (Actually ArrowApply looks close to what I want, now if only I had an instance of it...)
16:28:55 <elliott> kev07: devil's advocate = trolling
16:28:59 <prototrout> elliott: Yep, just noticed that.
16:29:03 <elliott> it is indistinguishable from just wasting our time
16:29:16 <monochrom> learn, or not learn. there is no try. there is  no devil advocate.
16:29:24 <jmcarthur> kev07: java has adts? i wasn't aware of this
16:29:35 <tgeeky> elliott: curiously, one could say exactly the same thing about the original notion of "devil's advocate"
16:29:43 <Nimatek> And as incredibly busy and successdul Haskell programmers out time is infinitely valuable.
16:29:51 <Nimatek> successful*
16:30:13 <Nimatek> I have so little time, I don't even manage to type correctly.
16:30:17 <sipa> kev07: if you're willing to learn, we're very willing to help you; if you're trying to argue that another language has all advantages of the language you don't know yet, go use that language
16:30:20 <elliott> Nimatek: You forgot attractive, wealthy, intelligent.
16:30:50 <monochrom> anyway, provocative tactics are unwelcome here
16:30:53 <Nimatek> elliott: Yeah!
16:31:44 <swarley> arguing one language over another is stupid, they have different purposes and therefore cant be compared on the same levels. Yes java is good if you are trying to puts apps on a toaster
16:32:08 <roconnor> > 0xff :: Integer
16:32:08 <lambdabot>   255
16:32:15 <sipa> The easiest language is the one you already know
16:32:25 <Obfuscate> jmcarthur: The standard meaning of ADT outside of functional programming is abstract data type, not algebraic data type. I suspect kev07 means that.
16:32:53 <jmcarthur> Obfuscate: that did occur to me, but i didn't want to seem presumptuous.
16:33:06 <monochrom> adt and adt are opposites :)
16:33:13 <jmcarthur> heh
16:33:34 <monochrom> in fact Bart Jacobs would tell you they're duals
16:33:42 <jmcarthur> i was about to say that
16:33:47 <jmcarthur> without the bart jacobs part
16:34:11 <Obfuscate> jmcarthur: Java doesn't have them itself, although you can do something similar with generics.
16:34:27 <wavewave> hi
16:35:55 <jmcarthur> the best emulation of it that i know of is to translate each constructor into a different subclass
16:36:04 <jmcarthur> maybe there is something nicer
16:36:20 <monochrom> my http://www.cs.toronto.edu/~trebla/personal/humour/Nightmare.java shows how to use adt to encode adt!
16:36:58 <monochrom> and exceptions to encode pattern-matching :)
16:37:04 <jmcarthur> Nil and Cons as subclasses of exceptions? :o
16:37:19 <monochrom> yes, so you can pretend to pattern-match later :)
16:37:28 <elliott> nice
16:37:48 <monochrom> there is a reason I give it the name "Nightmare"! :)
16:37:49 <wavewave> yesterday I tried to relearn c++. :-/
16:37:53 <roconnor> > 0x80 :: Int8
16:37:54 <lambdabot>   -128
16:37:56 <swarley> lol
16:38:17 <wavewave> even bought a book :-(
16:38:18 <swarley> I dont have the patience to do anything with C++
16:39:07 * monochrom learned from Stroustrup's book, way back in 1990, way back well Stroustrup's book was just 300 pages.
16:39:07 <wavewave> clearly c++ is moving towards FP in c++11
16:39:13 <monochrom> s/well/when/
16:39:13 <roconnor> > 0xff00 :: Int16
16:39:14 <lambdabot>   -256
16:39:27 <roconnor> > 0xff7f :: Int16
16:39:27 <lambdabot>   -129
16:39:44 <swarley> Lol, i have the original C Programming Language book
16:39:48 <dylukes> Me too :P.
16:40:00 <swarley> Im a hoarder of Programming books
16:40:01 <wavewave> welcome addition was function almost as a first-class citizen..
16:40:20 <swarley> I have PHP and Javascript books and i never do web design lol
16:40:23 <monochrom> I have K&R 2nd edition hardcover and autographed by Kernighan! too bad I didn't catch Ritchie in time.
16:40:34 <dylukes> Hey, C has had function pointers for quite a long time :P.
16:40:48 <wavewave> It seems that c++ community is more willing towards FP compared with java community.
16:40:54 <roconnor> > -0x80
16:40:55 <lambdabot>   -128
16:41:03 <dylukes> wavewave: The Java community is pretty adamant about getting closures.
16:41:11 <dylukes> At least, one segment of it.
16:41:31 <wavewave> dylukes: Ah I see.
16:41:36 <swarley> i have tried to use java multiple times, i cant get into it
16:41:51 <swarley> but i have used jruby many times so be ale to use JFrame lol
16:41:55 <swarley> able*
16:42:19 <Nimatek> Java is.. wordy.
16:42:47 <monochrom> supportsMetaDataAndDataManipulations
16:42:55 <swarley> To me it looks horrid
16:43:19 <wavewave> trivialObjectFactoryFactoryFactoryProxy
16:43:21 <swarley> i would use Go more if it was well... a bit better
16:44:19 <dylukes> I once tried to get currying working in C.
16:44:22 <dylukes> It didn't go well.
16:44:27 <dylukes> I got it sort of working in C++...
16:44:40 <dylukes> by having the "top" function return a C++ object overloading operator()
16:44:43 <dylukes> and so forth.
16:45:31 <dylukes> basically each object when called returned a new object initialized with the current stack of arguments and the new one(s).
16:45:33 <tomprince> It would guess it wouldn't be all that hard with variadic templates now, at least assuming no overloading.
16:45:43 <dylukes> if it's saturated, it calls the actual function.
16:46:07 <dylukes> if it's over saturated, it calls the actual function and tries to apply the result of the function to the extras
16:46:11 <dylukes> it was really horrid type-wise.
16:46:20 <dylukes> A lot of hand waving and void * casting
16:46:21 <wavewave> C++ template language became almost monster now..
16:46:39 <dylukes> It should just use ASP for templating. Duh.
16:47:39 <wavewave> I do not understand why c++ template doesn't take an approach to deal with its AST directly.
16:47:59 <wavewave> like TH.
16:48:32 <wavewave> it just keeps adding new commands whenever new need arises..
16:49:35 <Bfig> yeah why don't we turn all languages to lisp (?)
16:50:09 <PiRSquared17> :t undefined
16:50:10 <lambdabot> forall a. a
16:50:22 <mauke> > iterate f x
16:50:22 <stepcut> I don't understand why C++.
16:50:23 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
16:50:24 <dylukes> Bfig: Because lisp is perfect and doesn't have its own set of problems.
16:50:43 <Bfig> i was just making a joke if you know what i mean
16:50:47 <dylukes> ;)
16:51:02 <Bfig> don't you dare take me for a language fundamentalist (especially one i don't even know how to use)
16:51:17 <companion_cube> do you guys know ATS?
16:51:29 <jmcarthur> we all do
16:51:37 <jmcarthur> you're the only one that doesn't
16:52:08 * companion_cube jumps out the window
16:52:21 <Bfig> what's an ATS?
16:52:43 <companion_cube> http://www.ats-lang.org this language
16:52:51 <ville> thought you meant an AST
16:53:06 <monochrom> if you just say "why not turn everything into s-expressions" it's less controversial :)
16:53:42 <monochrom> I looked at ATS a bit. decided that its proof language is too lengthy, its proof system too tedious.
16:53:50 <Bfig> what do you think about agda?
16:53:58 <jmcarthur> i love agda
16:54:03 <Bfig> what do you think in general of dependent typing and formal program construction?
16:54:20 <jmcarthur> i think it's not suitable for child consumption
16:54:25 <Bfig> i've heard recently by the formal methods people in my uni that this is *real*
16:54:45 <Bfig> i mean, it is being used on large scale projects already
16:54:53 <companion_cube> monochrom: but as a programming language, if one drops the proof part?
16:54:57 <monochrom> I can do formal program construction. but not in dependent type's narrow confine.
16:55:02 <jmcarthur> i'd be interested to learn that, Bfig
16:55:14 <Bfig> jmcarthur, learn what ?
16:55:25 <Bfig> know in which projects it is being used?
16:55:26 <jmcarthur> Bfig: that it's being used for large projects
16:55:31 <jmcarthur> i assume you mean real-world projects
16:55:38 <wavewave> what large system is using dependent type language?
16:55:45 <Bfig> mmm i heard it was used to test the core of java mini edition i think
16:55:53 <monochrom> seems to me more ergonomic to have a specification language and a type language, not combine them. i.e., e.g., PVS
16:56:01 <Bfig> no, formal methods i mean, not dependent typing
16:56:18 <jmcarthur> ah
16:56:34 <monochrom> and e.g., Z, VDM
16:56:40 <jmcarthur> formal methods have a long history
16:56:48 <wavewave> among dep languages, probably will agda rise first?
16:57:17 <jmcarthur> wavewave: i think either agda or some language of the future, but not any other existing language
16:57:23 <Bfig> it all depends on the academic community (from which we all belong in some way) to decide which languages survive
16:57:37 <jmcarthur> so in other words, agda i think at least stands the biggest chance of the existing dependently typed languages
16:57:40 <wavewave> maybe we can make agda /haskell FFI.
16:57:50 <jmcarthur> wavewave: that is already agda's ffi
16:57:53 <wavewave> agda / safe haskell /haskell   :-)
16:58:18 <jmcarthur> wavewave: or at least, for one of the compiler backends it is. i think the new epic backend uses C as its ffi
16:58:30 <jmcarthur> but i could be wrong about epic
16:59:20 <jmcarthur> currently i use agda for playing around with new ideas and then if they work out i port them to haskell by hand
16:59:52 <ddarius> @google CompCert coq
16:59:54 <lambdabot> http://compcert.inria.fr/doc/
16:59:54 <lambdabot> Title: The Compcert verified compiler
17:00:02 <ddarius> @google "Running the Manual" coq
17:00:04 <jmcarthur> unfortunately that sometimes results in losing some type safety, but it's easier to maintain once it's in haskell, at least for me
17:00:05 <lambdabot> http://www.cs.ru.nl/~wouters/Publications/BeautyInTheBeast.pdf
17:00:05 <lambdabot> Title: Beauty in the Beast
17:01:39 <wavewave> probably with new Kind polymorphism, haskell can be more similar to agda..
17:02:06 <stepcut> GHC 7.4 is going to rock.
17:02:41 <wavewave> ghc is like an evangelist.
17:03:03 <ville> GCC 4.7 is going to rock
17:03:23 <stepcut> 4.7 is before my time
17:03:30 <stepcut> GHC 4.7 that is :)
17:03:41 <stepcut> started with GHC 5.03
17:03:54 <wavewave> i am ghc 6.10 generation.
17:04:11 <stepcut> I think 5.03 was around the first version with hierachical modules ?
17:04:16 <stepcut> or was that later ?
17:04:32 <incluye> dude, type metaprogramming?
17:04:46 <incluye> they should invent type metametaprogramming next
17:15:22 <jmcarthur> i started around ghc 6.6 or so i think
17:16:28 <min> can anyone recommend a good book on category theory having the /most/ axiomatic or formal presentation and the /least/ diagrammatic presentation of definitions and theorems?
17:16:45 <_oz> any guesses with which ghc did base-4.1 come?
17:17:51 <ddarius> Fokkinga's Gentle Introduction, although it is not a book and I don't find it all that good.
17:18:27 <ddarius> stepcut: That was later.
17:18:53 <JoeyA> Is there a way to link to a module in another package using Haddock?  When I say "Data.ByteString.Char8" (quotes included), it's a dead link because I don't have a Data.ByteString.Char8 module in my package.
17:19:14 <stepcut> ddarius: 6.0 maybe?
17:20:23 <ddarius> stepcut: Way earlier than that.
17:20:39 <tgeeky> wavewave: -> pm
17:21:41 <ddarius> stepcut: Actually, you may be right.  The .03 confused me.
17:22:35 <ddarius> I know the transition happened around when I started which was ~5.04 and checking the site, it transitioned between 5.02 and 5.04.
17:23:38 <min> well, Fokkinga's notes are a little extreme; but thanks for the reference.
17:23:39 <stepcut> yeah that's what i looks like to me
17:23:49 <stepcut> I don't see it in 5.02 manual, but it is in 5.04
17:24:02 <stepcut> 5.03 was a typo on my part
17:24:13 <ddarius> The page for 5.04 explicitly states that the modules were new in that version.
17:25:49 <ddarius> I was reading 5.03 as 5.0.3 which would be super old.
17:27:15 <stepcut> heh
17:27:59 <solidsnack> JoeyA: Does 'ByteString' not work?
17:28:21 <solidsnack> JoeyA: I know for unqualified 'Word', 'Bool', &c. it seems to work okay.
17:28:28 <JoeyA> solidsnack: Yes, but I want to link to the module page, not just to a data type.
17:28:49 <solidsnack> Oh, aha. I misread what you wrote.
17:37:15 <stepcut> sometimes I wish that string literals in Haskell had the type Text instead of String or (IsString a) => a
17:37:48 <JoeyA> > "Hello" . " world"
17:37:48 <lambdabot>   Couldn't match expected type `a -> b'
17:37:49 <lambdabot>         against inferred type `[GHC.T...
17:38:12 <JoeyA> (I figured lambdabot would overload . as mappend)
17:38:24 <mauke> :t (.)
17:38:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:38:28 <incluye> > mappend "hello" " world"
17:38:28 <lambdabot>   "hello world"
17:38:30 <JoeyA> Oh, it's fmap.
17:38:33 <ddarius> JoeyA: That would make it not work for functions.
17:38:49 <JoeyA> > ("Hello" ++) . (" world" ++) $ []
17:38:49 <incluye> All it says is "an associative operation" :(
17:38:50 <lambdabot>   "Hello world"
17:39:26 <mauke> > ("Hello" ++) `mappend` (" world" ++) $ []
17:39:28 <lambdabot>   "Hello world"
17:39:37 <JoeyA> If string literals in Haskell defaulted to being a function like ([...] ++), then we could do string concatenation PHP style :-)
17:39:47 <ddarius> incluye: Yeah, it should say "an associative operation with unit."
17:40:39 <JoeyA> (except you'd have to put 'shows' before things that aren't strings)
17:40:45 <ddarius> Don't want to confuse monoids with semigroups.
17:41:36 <JoeyA> Most people are confused by monoids *and* semigroups.
17:42:52 <ddarius> Monoids are ridiculously common in computer science.
17:44:40 <_oz> ddarius: yes. what about semigroups though?
17:44:51 <ddarius> _oz: Every monoid is a semigroup.
17:45:37 <hpaste> stepcut pasted ‚Äústring concat with (.)‚Äù at http://hpaste.org/53952
17:45:37 <ddarius> "the larger the falsity value of ||A||, the falser the formula A"
17:45:57 <Ferdirand> sorry , what does a monoid have that a semigroup doesn't ?
17:46:01 <stepcut> i think XML is a semigroup
17:46:13 <ddarius> Ferdirand: An identity.
17:46:15 <stepcut> maybe not
17:46:21 <stepcut> but XML seems to lack a zero
17:46:42 <Ferdirand> semigroups don't have an identity ?
17:46:58 <stepcut> but XML doesn't really have a mappend either so..
17:47:22 <Ferdirand> ah, curse the language barrier
17:47:23 <ddarius> stepcut: I thought you were going to do newtype SCat a b = SCat String; instance Category SCat where id = SCat ""; SCat x . SCat y = SCat (x++y)
17:47:47 <stepcut> ddarius: I could..
17:47:55 <stepcut> ddarius: I started that way I think
17:48:03 <Ferdirand> french semi-groupe is monoid
17:48:24 <JoeyA> Isn't "" a zero for XML?
17:48:50 <ddarius> That isn't XML.
17:48:56 <kmc> hey copumpkin, are you giving a talk on Tuesday?
17:49:02 <kmc> i might miss it :/
17:49:09 <JoeyA> Thinking in terms of the xmlconcat function in SQL.
17:49:17 <JoeyA> Ah
17:49:28 <JoeyA> There's a distinction between an XML document and XML fragments.
17:49:59 <JoeyA> You can't really concatenate XML documents, but you can certainly concatenate '<a>Foo</a>' and '&nbsp; Bar'
17:50:07 <wavewave> kmc: what's happening on tuesday?
17:50:36 <stepcut> JoeyA: yeah, the children of an element are a bit monoid like
17:53:55 <stepcut> ddarius: I thought it was a bit odd that the SCat type had 'a' and 'b' params that were not actually used. But I guess I could do, type String' = SCat () (), or something
17:54:17 <ddarius> You can just leave them polymorphic.
17:54:46 <stepcut> yeah
17:56:28 <hpaste> stepcut annotated ‚Äústring concat with (.)‚Äù with ‚Äústring concat with (.) (annotation)‚Äù at http://hpaste.org/53952#a53953
17:56:38 <PiRSquared17> @pl const undefined
17:56:39 <lambdabot> const undefined
17:56:46 <PiRSquared17> :t const undefined
17:56:47 <lambdabot> forall a b. b -> a
17:57:39 * stepcut wonders what useful things could be done with the phantom types for StringCat
18:00:16 <kmc> wavewave, Boston Haskell meeting
18:00:56 <wavewave> ah.
18:01:03 <repot> kmc, are you Bostonian?
18:01:18 * repot didnt know there was  a Boston Haskell groupp
18:03:22 <wavewave> boston haskellers are quite active.
18:06:02 <repot> cool wavewave , never knew that.
18:06:09 <repot> Are you a member?
18:07:12 <wavewave> no no.. I am not in Boston.
18:07:47 <wavewave> but thinking to go there if possible in January.
18:09:18 <Sgeo|chromcrash> .
18:09:21 <Sgeo|chromcrash> "The mtl writers even went through all the trouble and made the monad transformers in- stances of each other (that is n2 instances)!  "
18:09:40 <Sgeo|chromcrash> I hope there are template haskell macros I could use if I wanted to do similar
18:11:02 <kmc> what's a chromcrash?
18:11:52 <Sgeo|chromcrash> Typo for Chrome crashed
18:11:53 <monochrom> it's when monochrom crashes :)
18:13:15 <stepcut> is there a proposal where we do all the proposals that break all the things all at once? (aka, fix the Num hierarchy, add Functor as a superclass for Monad, etc) ?
18:13:37 <lpsmith> I think it's called "agda"
18:13:50 <stepcut> lpsmith: you might be right
18:14:35 <lpsmith> unfortunately it gets to be very difficult to fix things once a language becomes somewhat successful.
18:14:52 <stepcut> lpsmith: yup. That is why we are avoiding success at all costs still right ?
18:15:01 <min> isn't there a correct algebraic hierarchy on hackage?
18:15:08 <lpsmith> heh
18:15:13 <stepcut> min: yup.
18:15:28 <lpsmith> well, Haskell certainly did benefit from that,  though that may be behind us.
18:16:09 <min> so unless one is concerned with backwards compatibility, why use Num, etc.?
18:16:12 <stepcut> I heard some theory about how the collapse of civilazations (or similar things) is invetiable, and a good thing..
18:16:33 <lpsmith> perhaps
18:16:38 <stepcut> min: because 'backwards capability' includes using the libraries currently on hackage
18:16:39 <wavewave> not my time
18:16:55 <min> ah, sure.
18:16:55 <lpsmith> A massive civilization collapse is probably the only way to ever get rid of Cobol :-P
18:16:57 <stepcut> min: the apps I write tend to depend on 100+ packages (directly and indirectly)
18:17:26 <lpsmith> However, I don't really want to live through a collapse
18:17:42 <lpsmith> or rather,  I really don't want to live through a collapse
18:17:49 <wavewave> is cobol still being used?
18:17:59 <lpsmith> oh yeah
18:18:02 <lpsmith> lots
18:18:11 <wavewave> where?
18:18:16 <lpsmith> all over the place
18:18:34 <lpsmith> any big company still employs cobol programmers,  you can be sure of that
18:18:46 <lpsmith> There is still new development in Cobol.
18:20:06 <stepcut> I know someone (in their 20s at the time) who did Fortran OpenGL programming a few years ago
18:20:19 <stepcut> but I think Fortran is less dead than Cobol
18:20:29 <ddarius> Fortran OpenGL programming makes sense.
18:20:33 <stepcut> though, I guess it depends on the industry
18:20:33 <lpsmith> fortran 90 is actually kind of nice
18:20:34 <wavewave> hmm fortran is not dead.
18:21:15 <stepcut> yeah.. people still use fortran because it is actually a good choice for some domains.. I think people mostly only use cobol because of legacy code ?
18:21:24 <lpsmith> mostly
18:21:40 <lpsmith> but there is still new development in cobol
18:21:51 * hackagebot interpol 0.2.1 - GHC preprocessor to enable variable interpolation in strings  http://hackage.haskell.org/package/interpol-0.2.1 (AlexandruScvortov)
18:21:59 <stepcut> Fortran is probably more popular in the industry than Haskell  :-/
18:22:05 <lpsmith> I met a Cobol programmer at a Haskell meetup this last spring
18:23:19 <lpsmith> But given the sheer size of cobol code out there...  you have to consider that there is more legacy than new development...
18:23:41 <lpsmith> Fortran is definitely more popular than Haskell.
18:23:59 <ddarius> SAC
18:24:46 <wavewave> fortran is good in high performance numerical analysis.
18:25:08 <stepcut> yup
18:25:23 <wavewave> and compiler was better than c compiler until very recently..
18:25:28 <stepcut> data parallel haskel has not triumphed over fortran.. yet
18:25:51 <wavewave> right now, the statement seems not true any more.
18:26:11 <ddarius> wavewave: It probably strongly depends on the architecture.
18:26:18 <stepcut> I still intend not to learn Fortran
18:26:24 <wavewave> ddarius: yes.
18:26:38 <wavewave> I meant intel fortran compiler.
18:26:48 <solidsnack> lpsmith: Did you meet them at a Haskell meetup in the United States or in Europe?
18:27:00 <kedar> no
18:27:00 <lpsmith> In the US
18:27:07 <lpsmith> solidsnack, ^
18:27:12 <kedar> no
18:27:29 <solidsnack> BayHac?
18:27:34 <ddarius> solidsnack: What about Japan and Australia and South America?
18:27:37 <lpsmith> He didn't know a lot about Haskell, but he knew quite a bit about history.   Nah, Chicago
18:27:46 <solidsnack> Oh, okay.
18:27:46 <lpsmith> computer history, that is
18:28:06 <lpsmith> But yeah, he still uses Cobol professionally
18:28:43 <solidsnack> ddarius: Didn't know about all those other ones.
18:29:18 <kedar> ya
18:30:05 <lpsmith> solidsnack, it also wasn't a hackathon,  instead a more informal gathering (if that's even possible)
18:30:20 <solidsnack> Oh, I see.
18:30:34 <solidsnack> I was thinking of Hackathons.
18:30:36 * ddarius is lpsmith has much more informal gatherings than hackathons on a daily basis.
18:30:53 <ddarius> +sure
18:31:19 <incluye> haskathons
18:32:03 <lpsmith> well, given that I've been to one hackathon and two other meetings...  I'm not sure about "daily basis", but yeah :)
18:34:40 <lpsmith> So my representation of a PostgreSQL connection has grown from one to two to four threads :-(
18:34:52 <lpsmith> Not that that's likely a major problem, but...
18:34:55 <stepcut> :)
18:35:11 * stepcut hopes to stick with acid-state forever
18:35:30 <lpsmith> Actually I know I could get away with three, but think I may be better off with four
18:35:44 <kedar> can we return more than 1 value from function.?
18:35:51 <lpsmith> sure
18:35:53 <lpsmith> :t divMod
18:35:54 <companion_cube> use a tuple
18:35:54 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
18:36:10 <lpsmith> > divMod 45 7
18:36:11 <lambdabot>   (6,3)
18:36:32 <wavewave> anything can be returned from a function.
18:36:34 <solidsnack> lpsmith: Oh, really?
18:36:41 <solidsnack> Is it to have timeouts?
18:36:58 <lpsmith> solidsnack, no
18:37:17 <lpsmith> it's to support asynchronous notification
18:37:38 <kedar> , in function how to create instance variables
18:37:53 <jmcarthur> what do you mean by instance variables?
18:37:57 <lpsmith> though I'm pretty pleased that I'll also be able to issue a second query before the first one returns,  and start returning results before the last result is back
18:38:08 <solidsnack> lpsmith: Do you use the async interface?
18:38:19 <lpsmith> solidsnack, yes
18:38:35 <solidsnack> lpsmith: I am trying to imagine what the three threads are for.
18:39:01 <solidsnack> If you use the async interface, it stands to reason each query needs one thread.
18:39:07 <solidsnack> s/reason/reason that/
18:39:08 <kedar> instance variable means scope of variable limited within function
18:39:09 <lpsmith> no
18:39:38 <kedar> what no (lpsmith)
18:39:40 <solidsnack> So you manage to have multiple queries with only three threads?
18:39:49 <jmcarthur> kedar: so you mean something like:    let foo = a b c in bar foo d   ?
18:39:50 <lpsmith> solidsnack, actually I could get away with one thread if GHC supported a basic choice operator
18:40:00 <lpsmith> solidsnack,  yes.
18:40:07 <solidsnack> Oh, hmm.
18:40:12 <ddarius> solidsnack: I would expect an asynchronous interface to all you to have arbitrarily many queries with a single thread.
18:40:19 <lpsmith> As in,   result <- query conn ... ;  result2 <- query conn ...
18:40:32 <wavewave> kedar: we don't use the term "instance variable"
18:40:37 <lpsmith> can launch the second query before the first returns
18:40:39 <kedar> i mean can we do like  , int a
18:41:00 <jmcarthur> kedar: just use let or where
18:41:01 <ddarius> lpsmith: What is 'result'?
18:41:09 <solidsnack> ddarius: Yes. I thought you'd want the thread for handling notifications for each query as they came in.
18:41:10 <jmcarthur> > let x = 5 in x * x
18:41:11 <lambdabot>   25
18:41:34 <lpsmith> of course, the nature of the protocol is that you you'll get all the results for the first query before you get any from the second
18:41:43 <lpsmith> ddarius, database rows
18:41:46 <solidsnack> lpsmith: Indeed.
18:42:23 <jmcarthur> kedar: <x is not in scope here> let x = <x is in scope here> in <x is also in scope here>) <x is not in scope here>
18:42:25 <wavewave> kedar: let x = ... in (some expression with x )   => then x is only scoped in ( some expression)
18:42:46 <ddarius> lpsmith: Be more specific.  It clearly can't be just the rows otherwise you'd have to wait for them to come back before executing the next line of code unless you are using unsafeInterleaveIO.
18:42:52 <wavewave> also in ... as jmcarthur said.
18:43:41 <lpsmith> Well, the threads feed what is a variation of a chan,  and yes I use unsafeIntereleaveIO
18:43:51 <lpsmith> But in a pretty safe way
18:44:01 <jmcarthur> kedar: <x is not in scope here> (let x = <x is in scope here> in <x is also in scope here>) <x is not in scope here>   -- missed a paren the first time, sorry
18:44:28 <solidsnack> lpsmith: I was trying to use the async interface a while back, for a different application -- an append-only log storage system. https://github.com/solidsnack/logl/blob/master/Language/LogL/PG.hs#L221
18:45:07 <lpsmith> Basically the messages from the database get fed back into a chan,   and the chan get's converted into the final results using unsafeinterleaveIO
18:45:25 <lpsmith> so lazy evaluation never actually drives the ordering of the IO,  which is critical
18:45:35 <solidsnack> I wanted to have two threads per query; one would poll and the other would kill it if it took too long.
18:46:12 <solidsnack> I had some trouble getting it to work, though; I don't remember what the problem was.
18:46:43 <lpsmith> concurrency is hard
18:46:53 <companion_cube> let's go shopping.
18:46:59 <lpsmith> =)
18:47:16 <solidsnack> Yeah, computers are hard.
18:47:21 <lpsmith> solidsnack, oh, I think we are talking about two different things
18:47:36 <companion_cube> not so hard once you get a hammer
18:47:39 <lpsmith> I'm talking about Listen/Notify.
18:47:52 <solidsnack> Oh, PG's pub/sub?
18:47:56 <lpsmith> right
18:48:00 <solidsnack> I see.
18:48:15 <solidsnack> Very different from what I'm talking about, yes.
18:49:17 <lpsmith> I haven't tried using libpq's asynchronous interface yet.
18:49:45 <lpsmith> Right now I'm playing with Chris Done's start on a native PostgreSQL client library
18:50:10 <solidsnack> Oh, so not the libpq bindings?
18:50:12 <lpsmith> the nice thing about that is you get asynchronous operation for free.
18:50:20 <lpsmith> I have used the libpq bindings
18:50:41 <lpsmith> but not for this project, no.
18:50:45 <ddarius> "where 1 ‚àà [1..‚Ñì]"
18:51:20 <lpsmith> Chris Done is missing a lot of functionality though,  such as asynchronous notifications,  which is something I need.
18:51:30 <lpsmith> Most of the rest I can live without
18:56:20 <solidsnack> lpsmith: Well, that's interesting to learn about; I may have to try that.
18:56:30 <solidsnack> It would probably suit my purpose fine.
18:57:43 <lpsmith> well,  depends on what you want out of async operations... pgsql-simple doesn't support cancelling in-progress queries
18:57:58 <lpsmith> so if you want that...
18:58:14 <solidsnack> Well, I can still kill the thread.
18:58:23 <solidsnack> I don't want cancellation, actually.
18:59:05 <solidsnack> I just need to be able to kill queries in any state, to free up the main program if a PG is misbehaving.
18:59:55 <solidsnack> The system I linked to stores entries in multiple PGs and should tolerate faults in a small number of them.
19:00:26 <solidsnack> The problem with libpq is if you just kill the thread while its in the middle of a query, it can corrupt the internal state of the library.
19:00:42 <solidsnack> You might as well restart the application, at that point.
19:00:58 <lpsmith> but yeah,  I've become aware of how bad Haskell's database access libraries are,  actually trying to use them.   Java and Python are definitely pretty much out in front on that regard.  Ruby isn't too bad.
19:01:16 <lpsmith> Perl is also pretty good.
19:02:06 <lpsmith> solidsnack, so you mean kill the thread and lose the database connection?
19:02:10 <lpsmith> That would probably work.
19:02:32 <solidsnack> lpsmith: It does seem like pqsql-simple can do that, yeah.
19:02:44 <lpsmith> You won't be able to accomplish what you want in pgsql-simple and retain the database connection.
19:03:09 <lpsmith> You might be able to do what you want and lose it.  Or kludge pgsql-simple in such a way to do that.
19:04:09 <solidsnack> lpsmith: It might be okay for my application for now.
19:04:17 <solidsnack> I have to add logic for reconnect, anyways.
19:04:43 <lpsmith> Actually I really liked the two-thread model.   But I couldn't figure out how I could simultaneously support timely user-initiated disconnects and asynchronous notifications
19:04:50 <lpsmith> I could have one or the other, but not both.
19:05:53 <lpsmith> but yeah, async notifications are definitely the way to go if you want to write a program that responds to changes in a database.
19:06:37 <solidsnack> Why is it that having both was hard to do?
19:06:57 <solidsnack> I am having trouble seeing what one has to do with the other, actually.
19:07:09 <lpsmith> well, basically I had a muxer that sent stuff to the database,  and a demuxer that read stuff and sent it to the right place
19:07:52 <lpsmith> I could have used asynchronous exceptions to deal with user-initiated disconnects,  but that's playing with fire
19:08:13 <lpsmith> I also would have been fine if PostgreSQL wouldn't hang up immediately if you sent it a Terminate connection
19:08:20 <tswett> How do I install the Haskell platform on Ubuntu?  Given that there seems to be a package called haskell-platform, I'd expect it to just be "apt-get install haskell-platform".
19:09:10 <solidsnack> tswett: I am running on Haskell on Ubuntu but it actually looks like I've used the ghc-* packages.
19:09:17 <solidsnack> lpsmith: Why was that problem?
19:09:25 <ddarius> haskell-platform is a meta package.
19:10:12 <solidsnack> s/that/that a/
19:10:18 <tswett> What does that entail?  Should I just install some of the packages it depends on, like ghc and cabal-install?
19:10:46 <solidsnack> tswett: Well, I would just try install haskell-platform and seeing how it goes.
19:11:00 <solidsnack> s/install/installing/
19:11:01 <tswett> I did.  I think it said it couldn't find that package.
19:11:21 <tswett> Yeah.  "E: Couldn't find package haskell-platform"
19:11:22 <lpsmith> solidsnack, so to maintain the illusion that I'm not pulling shenanigans with regard to unsafeInterleavePeformIO,   a disconnect needs to cause two things to happen:  the muxer has to start responding to new requests with a "connection closed",  and the demuxer needs to keep the connection open until it's done reading results.
19:11:49 <solidsnack> Oh.
19:12:12 <ddarius> And here is a place where the lack of a 'select' operation comes in.
19:12:21 <lpsmith> yeah
19:12:21 <solidsnack> lpsmith: And the need for unsafeInterleavePerformIO is you want, really, really timely results?
19:12:33 <lpsmith> well,  hide latency
19:12:37 <lpsmith> something like that
19:13:10 <lpsmith> I mean, without unsafeInterleaveIO,  I couldn't issue the next query before the results from the first query are back
19:13:27 <solidsnack> Oh, so there's multiple queries and you want to post results from whatever query has results whenever it has them.
19:14:04 <incluye> ah! unsafePerformIO
19:14:27 <solidsnack> lpsmith: I would think that multiple threads, dumping stuff in an MVar, could work...
19:14:33 <lpsmith> yeah
19:14:35 <lpsmith> it can
19:14:36 <solidsnack> ...the demuxer reads from the MVar.
19:14:53 <lpsmith> The concurrent haskell paper shows how it can be done with three threads.
19:15:05 <solidsnack> tswett: Interesting.
19:15:25 <solidsnack> tswett: Works for me, now that I tried it. Are you on 11.10?
19:15:38 <tswett> I think I'm on the most recent LTS version, whichever that is.
19:15:45 <lpsmith> ok,  but I can block on the MVar (bounded channel, actually)  and get the disconnection message,  or block on the handle and get the asynchronous notification
19:16:23 <lpsmith> or I could block on the handle and use asynchronous exceptions to signal the disconnect,  but like I said, that's playing with fire.
19:16:38 <lpsmith> And honestly I do not feel like debugging such things right now.
19:16:46 <solidsnack> Hmm.
19:17:41 <solidsnack> I imagined a scenario where one thread blocked on the MVar to put results in the UI, as they came in; and other threads waited for query responses.
19:18:17 <solidsnack> I guess they would need a "control MVar" to tell them when it's time to quit reading, if you didn't want to use exceptions.
19:18:17 <lpsmith> well, but you can only have one thread reading the handle
19:19:03 <solidsnack> That's true, yeah.
19:20:02 <solidsnack> So this thread needs to get the message, time to disconnect.
19:20:53 <solidsnack> I guess I am having trouble understanding what unsafeInterleavePerformIO is doing here.
19:22:47 <roconnor> @type testBit
19:22:48 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
19:23:07 <roconnor> > testBit 0x80 7
19:23:08 <lambdabot>   Ambiguous type variable `t' in the constraint:
19:23:08 <lambdabot>    `Data.Bits.Bits t'
19:23:08 <lambdabot>      a...
19:23:16 <roconnor> > testBit (0x80::Int) 7
19:23:17 <lambdabot>   True
19:23:17 <solidsnack> If there is really only one handle, where's the concurrency coming from?
19:24:55 <ddarius> It's just unsafeInterleaveIO.
19:25:30 <ddarius> The unsafeInterleaveIO is so he can return [Row] or whatever without having to actually have all the list elements yet.
19:26:44 <solidsnack> Well, maybe I should go take a look at the paper lpsmith mentions.
19:27:08 <ddarius> I doubt that paper uses unsafeInterleaveIO for the thing lpsmith was talking about.
19:27:16 <ddarius> Replicated select is so much easier than an unreplicated select.
19:28:05 <solidsnack> What's "replicated select"?
19:28:59 <solidsnack> Does the pub/sub stuff allow one to get some of the rows for one query, some for another, all in a jumble?
19:30:15 <solidsnack> I guess I'll have to go read about it; as I've asked lpsmith more about, I'm finding it hard to motivate the problem.
19:31:00 <ddarius> If I understood what lpsmith said earlier, he still returns all the rows in order, but the database can be performing later queries while you are still retrieving rows from the first.
19:31:43 <deech> Is there some way of introspecting on the runtime values of a running Haskell program? For example, if I have a web server I'd like to know what port it's running on. So far the only way I can think to do this is to run it from GHCI.
19:32:26 <lpsmith> the paper does show you how to implement choice operators.   If you read the source code for Control.Concurrent.Chan,  it has one function that uses unsafeInterleaveIO
19:32:43 <solidsnack> deech: I'm not sure of any other way to do it.
19:33:13 <lpsmith> ddarius, yeah that's basically it.  I'm not sure what PostgreSQL does or doesn't do in that case,  but the documentation says that it's fine to issue a few more queries before you get the results from the first one back.
19:33:46 <deech> solidsnack: Can I can launch a compiled file from GHCI? That way I wouldn't see performance loss.
19:34:17 <solidsnack> deech: Yes, though the exact syntax escapes me.
19:34:39 <ddarius> GHCi loads compiled object files, if they are available, by default.
19:34:47 <solidsnack> Probably just :load My.Module if My/Module.o is in cwd.
19:34:57 <ddarius> In fact, until recently there was no way to do otherwise.
19:35:01 <stepcut> if available and up-to-date
19:35:04 <JoeyA> Note that libpq, unlike some other systems, doesn't lazily retrieve rows one at a time.  It retrieves the entire result set at once.
19:35:11 <JoeyA> If you want laziness, create a cursor.
19:35:35 <lpsmith> JoeyA, it can if you use the asynchronous functions
19:35:49 <lpsmith> But I'm not using libpq for this experiment
19:36:50 <djanatyn> I want to see if I can rewrite my java project in haskell
19:37:29 <deech> djanatyn: Great!
19:37:42 <deech> solidsnack: Thanks!
19:38:03 <JoeyA> Is it possible to link to functions from a package index page?  'System.IO.hSetNewlineMode' doesn't work, because I haven't "imported" System.IO (how would I?  I'm in a .cabal file)
19:38:30 <ddarius> djanatyn: You can.
19:38:48 <lpsmith> JoeyA, but you are right,  you can use cursors to achieve a similar result without using the asynchronous functions,  which you probably only want to use to implement other libraries anyway,  not to use directly in your application.
19:39:39 <lpsmith> JoeyA, good question.  I'd be a little surprised if you can do that.
19:40:26 <djanatyn> ddarius: well, I know it's possible, but I want to see if I personally can do it ;)
19:40:38 <djanatyn> thanks for the encouragement, though
19:40:50 <solidsnack> lpsmith: This has been interesting to discuss. If you can release the sources I would like to read it to see what you did.
19:41:25 <lpsmith> solidsnack, yeah :)  I hope to have it up on github in a day or two.
19:42:39 <chreekat> If I want to tinker with a library that my project depends on, what's the best way to see the changes that i introduce? I tried using the steps (1) 'cabal unpack' library, (2) make changes and then perform 'cabal install', (3) go back to my project and 'cabal clean && cabal configure'. That method, unfortunately, resulted in a whole lot of 'package xyz is broken due to missing package' messages. In retrospect it's a pretty stupid idea altoge
19:44:12 <Sgeo|chromcrash> Suppose I want to use something similar to Python generators
19:44:23 <Sgeo|chromcrash> There's http://hackage.haskell.org/package/generator , but is that the recommended thing to do?
19:44:28 <Sgeo|chromcrash> Or is it better to use Enumerators?
19:44:28 <chreekat> Would I need to edit my .cabal file to remove the dependency on the library, and then move the library's source into my project's dir? I'd rather not need to modify my .cabal file, but perhaps that wouldn't be too bad
19:44:55 <ddarius> Sgeo|chromcrash: Just use lists... but I assume you want to do IO?
19:45:15 <JoeyA> chreekat: +1.  I'd like to know that, too.
19:45:38 <ddarius> Unpack the package into your source directory.
19:45:40 <Sgeo|chromcrash> ddarius: Not necessarily, but suppose I did want to do IO
19:46:38 <Sgeo|chromcrash> Or suppose I wanted to, uh.... it's meaningless to talk about maintaining the state of a function, isn't it
19:46:39 <Sgeo|chromcrash> Bluh
19:46:47 <geheimdienst> chreekat: i might be missing something, but if it successfully "cabal install"ed the modified package, why is it then saying "broken due to missing package"?
19:47:13 <ddarius> Sgeo|chromcrash: That generator package seems to do what you want.
19:47:37 <ddarius> There are other ways of doing it and likely other packages that do similar things.
19:48:30 <chreekat> geheimdienst: Unfortunately I am not familiar enough with cabal's workings to understand it. The packages listed do not seem related to the library in question.
19:49:26 <stepcut> how I do I extract the first <p></p> block from an html document using tagSoup
19:49:55 <stepcut> I can find the first block by doing, (~== "<p>), but that gives the openning <p> followed by everything to the end of the document
19:50:19 <chreekat> To be more concrete, I was tweaking shakespeare-js, and an example of a 'broken package' message is 'aeson-native-0.3.3.1 is broken due to ... text-0.11.1.9-<checksum>'
19:50:36 <stepcut> if I do, takeWhile (not . isTagCloseName "p") $ (~== "<p>") tags. Then I don't actually get the closing </p>
19:51:42 <geheimdienst> chreekat: try "ghc-pkg check" to find out what's breaking that package
19:54:03 <geheimdienst> chreekat: and don't worry, often enough nobody really "understands cabal's inner workings" :)
19:55:41 <stepcut> i really just need the missing, takeWhileAndThenOne
19:56:45 <Sgeo|chromcrash> :t runMaybeT
19:56:46 <lambdabot> Not in scope: `runMaybeT'
19:56:58 <Sgeo|chromcrash> :t Control.Monad.Maybe.runMaybeT
19:56:58 <lambdabot> Couldn't find qualified module.
19:57:02 <hpaste> chreekat pasted ‚ÄúProblems after tweaking library‚Äù at http://hpaste.org/53954
19:57:04 <Sgeo|chromcrash> @hoogle runMaybeT
19:57:04 <lambdabot> Control.Monad.Trans.Maybe runMaybeT :: MaybeT m a -> m (Maybe a)
19:57:34 <chreekat> geheimdienst: that paste is the reult of running ghc-pkg check. And thanks. :)
19:57:40 <Sgeo|chromcrash> ...but the monadic value is still trapped inside there
19:57:53 * Sgeo|chromcrash may be even more confused now
19:58:42 <Sgeo|chromcrash> :t Control.Monad.Trans.State runStateT
19:58:43 <lambdabot>     Not in scope: data constructor `Control.Monad.Trans.State'
19:58:51 <Sgeo|chromcrash> :t Control.Monad.Trans.State.runStateT
19:58:52 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
20:00:14 <Sgeo|chromcrash> Suppose I know a monad State exists
20:00:28 <Sgeo|chromcrash> Can I then make a StateT, or does StateT take on additional semantics
20:00:31 <PiRSquared17> :t \x -> flip (const undefined)
20:00:31 <lambdabot> forall t a b b1. t -> a -> b1 -> b
20:00:53 <ddarius> stepcut: span/break
20:02:31 <Sgeo|chromcrash> :i Num
20:02:39 <Sgeo|chromcrash> :i (->)
20:02:47 <geheimdienst> chreekat: it seems it really boils down to 4 missing packages: text, parsec, shakespeare, shakespeare-js ...
20:04:50 <geheimdienst> chreekat: have a look at "ghc-pkg list" as well. maybe the packages in question got replaced with slightly different versions, or something like that
20:05:52 <stepcut> ddarius: same problem?
20:06:09 <ddarius> But an easily fixable problem at that point, unless you are upset by the ++[x]
20:06:10 <stepcut> > break (== ',') "hello, world"
20:06:11 <lambdabot>   ("hello",", world")
20:06:19 <stepcut> the , is on the 'wrong' side
20:06:36 <stepcut> I just wrote, takeThrough which does what I need :)
20:06:44 <stepcut> not the first time I have written it either
20:07:09 <stepcut> the name make no sense.. but it does what I need :)
20:07:56 <ddarius> lpsmith: The singular select function described in the Concurrent Haskell paper wouldn't actually let you wait on reading multiple Chans.
20:08:54 <lpsmith> I'm using iterated choice
20:09:01 <ddarius> Yes, iterated choice is much easier.
20:09:23 <lpsmith> Yeah, I haven't taken the time to understand the singular choice in the paper yet
20:09:47 <lpsmith> but it seemed that iterated choice is what I needed anyway
20:11:11 <lpsmith> why wouldn't you be able to use singular choice to wait on two chans?
20:13:32 <chreekat> geheimdienst: What's it mean that some libraries are listed in red?
20:13:41 <ddarius> lpsmith: I can't undo a read from a Chan.
20:13:56 <geheimdienst> chreekat: broken (same as what ghc-pkg check says). blue means hidden
20:14:12 <ddarius> If I make a wrapper around Chans with a two phase commit protocol, I could do it, but then everyone needs to use my wrapped Chans.
20:14:41 <lpsmith> interesting.
20:17:43 <chreekat> geheimdienst: Ah, of course. Unfortunately I still don't know what I'm looking for. :) I actually just reinstalled everything (i.e. blew away ~/.cabal and started over) yesterday. Now that I think about it, I did that because I ran into the same issue. Previously, however, I was simply trying to install a brand new library.
20:18:10 <chreekat> I didn't look too closely at what went wrong that first time.
20:18:46 <byorgey> blowing away just .cabal will not work, you need to blow away .ghc too
20:19:09 <byorgey> in fact there's no reason to blow away .cabal
20:22:38 <monochrom> it feels like Dark Age when people don't know to erase .ghc
20:23:07 <chreekat> byorgey: ah ha! good to know. I should then clarify that I had actually configured cabal to install globally to /opt/haskell. Yesterday, I blew away both /opt/haskell *and* .cabal -- and I'd done away with .cabal mainly to change my install strategy. (I did local this time around.)
20:23:12 <geheimdienst> no, it feels like the dark ages when it's necessary to erase .ghc
20:23:38 <chreekat> So I conflated the issue by deciding to change install strategies at the same time..
20:24:13 <monochrom> if you install --global, that's even trickier. you have to find GHC's directory and erase one of its subdirectories
20:24:47 <monochrom> actually no, not erase it, you have to carefully find out what to keep and what to drop. it's a mess.
20:25:07 <geheimdienst> using --global is pretty cowboy. it's not recommended, unless you know what you're doing
20:25:42 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
20:27:16 <chreekat> monochrom: Thanks. I seem to recall stumbling upon that a few weeks ago.
20:27:44 <chreekat> geheimdienst: Yeah, that's part of the reason I (tried?) to switch back to a vanilla configuration
20:28:38 <chreekat> I've also found that the abi hashes in ~/.ghc definitely don't match what's in ghc-pkg's error message
20:29:15 <monochrom> "ghc-pkg check" is very weak. don't trust it. "ghc -v" is the comprehensive check.
20:29:34 <geheimdienst> i guess theoretically, you could whack all of the --global packages, then reinstall ghc
20:30:03 <monochrom> or go back in time.
20:31:26 * monochrom misses VMS
20:32:54 <chreekat> I do have daily backups snapshots :D
20:33:19 <monochrom> that's 31337
20:34:07 <geheimdienst> monochrom: where's ya vms now?
20:34:09 <geheimdienst> ;)
20:34:46 <chreekat> Well, here's another thing. Yesterday when I reinstalled everything, I grabbed ghc 7.0.4. Presumably, even if some global stuff was sitting around mucking things up, it would only do so for 7.0.3, which is what i was previously using.
20:34:59 <monochrom> right
20:35:45 * ddarius thinks chreekat's cabal is using a different ghc than him.
20:39:29 <chreekat> ddarius: Doubtful, I've only got the one. Under ~/.cabal I've only got lib/<lib>/ghc-7.0.4 directories, as well. I hope that's evidence that cabal is using 7.0.4
20:44:43 <ddarius> You deleted 7.0.3 when you installed 7.0.4?
20:46:39 <chreekat> I had installed both 7.0.3 and all cabal-installed packages to /opt/haskell. My hope in doing so was that I could simply move that directory to uninstall "The Haskells"
20:47:44 <chreekat> (actually I think it was 7.0.2, but hey)
21:02:38 <chreekat> Ah. I was pigeon dropped. I don't understand why cabal re-installed those four packages, but it did, and the abi hash changed as a result.
21:09:43 <chreekat> Just to single one out, why would cabal reinstall a perfectly healthy parsec when I was installing a package that indirectly depended on it? There was no version change.
21:12:09 <chreekat> Many are the mysteries of the universe. I'm just gonna cabal-dev-install my yesod app and call it a day
21:12:29 <monochrom> yes, that's safe
21:12:35 <monochrom> s/safe/safer/
21:13:42 <stepcut> poop. aeson-native is missing Data.Aeson.TH
21:31:53 <Sgeo|chromcrash> Would it ever make sense to use cabal-dev for everything?
21:35:21 <solidsnack> Sgeo|chromcrash: The moral equivalent of that is what all Ruby devs do now.
21:35:40 <chreekat> Aha! another newbie question. As I have now chosen to unpack shakespeare-js directly into my project, how do I hook it in? Must I intermingle the library's code with my own, and frankenstein the two cabal files? I hope not.
21:36:18 <Sgeo|chromcrash> solidsnack: Um, what? gems aren't global? Or are things such that they
21:36:30 <Sgeo|chromcrash> they're forced to use.. whatchamacallit
21:36:33 <solidsnack> Sgeo|chromcrash: Most Ruby devs use bundler.
21:36:37 <chreekat> Can I build the library and leave its .o lying around somewhere enticingly?
21:37:07 <solidsnack> chreekat: Probably better off to Frankenstein.
21:37:15 <Sgeo|chromcrash> What would happen if, for some reason, I wanted to use my own cabal ... repository
21:37:22 <Sgeo|chromcrash> Is that feasible?
21:37:25 <Sgeo|chromcrash> If not useful?
21:38:38 <chreekat> solidsnack: k
21:42:47 <ddarius> chreekat: If you just do ghc --make, it will find the modules in the current directory.
21:43:25 <chreekat> Sgeo|chromcrash: Dunno, but there *is* the line '-- local-repo:' in ~/.cabal/config
21:46:13 <Sgeo|chromcrash> cabal-dev still doesn't let you write a library that depends on two libraries that depend on incompatible versions of P, does it?
21:49:39 <donri> ghc does package-based imports with an extension, if that helps
21:50:24 <Sgeo|chromcrash> donri: oooh
21:50:51 <Sgeo|chromcrash> But then if I write a library that relies on that, can another library that knows nothing about that use my library?
21:51:32 <donri> duno; it relies on having separate cabal packages, don't think it does separate versions of one package
21:51:35 <donri> if that's what you want
21:51:48 <Sgeo|chromcrash> Oh, darn
21:51:56 <donri> it only disambiguates imports for modules with the same name from different packages
21:52:24 <Sgeo|chromcrash> Ah
21:55:37 <roconnor> > 0x41
21:55:37 <lambdabot>   65
22:12:43 <PiRSquared17> :t (pi *) . (^ 2)
22:12:44 <lambdabot> forall a. (Floating a) => a -> a
22:13:32 <PiRSquared17> #unpl (pi *) . (^ 2)
22:13:34 <RaptorRarr> @unpl (pi *) . (^ 2)
22:13:34 <lambdabot> (\ e -> pi * (e ^ 2))
22:13:46 <PiRSquared17> I wrote that myself
22:14:01 * RaptorRarr puts his claws together.
22:14:38 <RaptorRarr> > (pi *) . (^ 2) $ 17
22:14:40 <lambdabot>   907.9202768874502
22:15:29 <PiRSquared17> :)
22:19:26 <mdeboard> Hi, I'm trying to calculate, with some known values, linear combinations wrt Euclidean theorem of gcd. Something like [(x,y) | x <- [1..50], y <- [1..50], x*2420 - y*70 == 10]. but--
22:19:29 <mdeboard> nevermind. :)
22:19:59 <PiRSquared17> Bye!
22:52:38 <Jafet> (x,y,10) = extgcd 2420 70
22:53:05 <Jafet> Will the new messianic numeric prelude have extgcd?
22:54:58 <mdeboard> what
22:55:09 <ddarius> Jafet: Yes.
22:55:32 <mdeboard> That list comprehension worked fine, just bloat-y
22:56:02 <mdeboard> Not proficient with Haskell is all, just doing some number theory homework and enjoy that Haskell's syntax overlaps
22:56:16 <mdeboard> s/is all/at all
23:14:07 <michaelbaker> Hello, can anyone help me get my yesod projuct compiled using the wai-handler-webkit? This is the compliation error I'm getting: unknown symbol `___gxx_personality_v0'. After some searching I found that I need to link in the stdc++ library, so I added extra-libraries: stdc++ to my cabal file, but that doesn't seem to work. I'm on OSX 10.6
23:56:53 * hackagebot cairo-appbase 0.3 - A template for building new GUI applications using GTK, Glade and Cairo.  http://hackage.haskell.org/package/cairo-appbase-0.3 (ConradParker)
