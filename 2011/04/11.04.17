00:03:29 <ChongLi> yeah, looks like this stuff isn't well suited to higher order functions
00:06:52 <Gejokiz> Could someone tell me how to fix this? http://hpaste.org/paste/45757/trie_annotation#p45758 (scroll up for code)
00:08:07 <auastro> @pl (\a b f -> a . b f)
00:08:07 <lambdabot> (.) . (.)
00:09:07 <ChongLi> Gejokiz: what is the function fromCmu?
00:09:15 <ChongLi> it's expecting a list of strings
00:09:43 <Gejokiz> ChongLi: the type signature of fromCmu is String -> PronuncationTrie
00:09:51 <Gejokiz> IT's defined in that function
00:09:59 <Gejokiz> I'm not sure why it's expecting a list of them though?
00:10:30 <ChongLi> hmmm
00:10:33 <ddarius> "Foundations for Computable Topology" a.k.a. "Software development for mathematicians."
00:11:23 <Gejokiz> Also FWIW the other functions seem to work fine. It's jsut trying to use it from inpure code i'm having problems
00:11:27 <Gejokiz> but works fine in ghci
00:11:47 <Gejokiz> i.e. it's just that 1 line main function that has problems
00:11:56 <klugez> m3ga, monochrom: I had the same problem in installing network with Cabal earlier. This channel helped me to solve it by installing a newer Cabal.
00:13:12 <ChongLi> do { file <- readFile "cmudict.7a" ; show $ fromCmu file }
00:13:15 <ChongLi> would that work?
00:13:23 <ivanm> klugez: wait, installing a newer Cabal magically fixed a problem? :o
00:13:30 <ivanm> ChongLi: that doesn't look like it will typecheck
00:13:34 <Axman6> ChongLi: print, not show
00:13:41 <ivanm> Axman6: dammit, you beat me to it!
00:13:45 <ChongLi> oh yeah good point
00:13:46 <ivanm> go send some emails or something! :p
00:14:25 <klugez> ivanm: Well, first it gave that compilation error and after installing new Cabal and cabal-install it did not. I'm not 100 % sure I didn't do something else that made the difference in between.
00:14:41 <ivanm> preflex: seen dibblego
00:14:42 <preflex>  dibblego was last seen on #haskell 3 days, 2 hours, 4 minutes and 18 seconds ago, saying: don't ever step out of the Maybe until you get to main and run your side-effect
00:15:56 <Hertuar> ChongLi: My computer froze, could you pase me that do line again?
00:16:00 <Hertuar> and i'll try it
00:16:20 <ChongLi> I've been corrected
00:16:26 <ChongLi> do { file <- readFile "cmudict.7a" ; print $ fromCmu file }
00:16:28 <ChongLi> it should be
00:16:33 <ChongLi> (according to others)
00:16:37 <Hertuar> Ok, thanks. Let me try it
00:18:02 <Hertuar> ChongLi: Thanks! Works
00:18:08 <ChongLi> cool
00:18:13 <Hertuar> (and thanks to who corrected you)
00:18:38 <ChongLi> yeah, I had show in there
00:18:53 <Hertuar> Seems to work with show as well
00:18:55 <ChongLi> but that would've given a type error
00:18:59 <ChongLi> oh
00:19:01 <Hertuar> print $ show $ fromCMu file
00:19:08 <Hertuar> print $ fromCmu file
00:19:09 <ChongLi> that's redundant
00:19:10 <Hertuar> both work
00:19:15 <ChongLi> print runs show on its own
00:19:22 <Hertuar> fair enough
00:19:26 <ChongLi> but if you omit print you'll get a type error
00:19:32 <ChongLi> due to being in the IO monad
00:19:53 <Hertuar> Oh I see. The difference is it using print when i used putStrLn
00:20:13 <ChongLi> print is a handy high-level function
00:20:22 <ivanm> well, "print $ show" will give you extra quotes...
00:20:23 <ChongLi> it can print anything of the typeclass Show
00:20:38 <ChongLi> ivanm: good point
00:20:44 <ivanm> I don't know if I'd call "print" a high-level function...
00:20:48 <Hertuar> 	putStrLn $ show $ fromCmu file
00:20:51 <Hertuar> that works too
00:20:53 <shachaf> ChongLi: Are there any functions in the Prelude that are low-level?
00:20:54 <Hertuar> now i'm confused!
00:20:59 <ivanm> Hertuar: that's what show does
00:21:00 <shachaf> Hertuar: Yes -- print = putStrLn . show
00:21:02 <ivanm> @src print
00:21:03 <lambdabot> print x = putStrLn (show x)
00:21:03 <Hertuar> What did i have wrong in my original version? 
00:21:13 <Jafet> All functions in the Prelude are low-level!
00:21:14 <ivanm> shachaf: const! :p
00:21:53 <ChongLi> Hertuar: you were passing a value of type IO String to a function that expected a String
00:22:02 <shachaf> Pretty nifty function, const.
00:22:36 <Hertuar> ChongLi: Isn't that what the =<< thingy was for?
00:22:44 <Hertuar> I thought that's how people did it
00:23:16 <Hertuar> Like how would you write this on one line: file <- readFile "cmudict.7a"  \n	print $ fromCmu file
00:23:21 <ChongLi> =<< is >>= with the arguments interchanged
00:23:22 <Hertuar> (without using \n like i did :P)
00:23:39 <Jafet> @undo do { file <- readFile "cmudict"; print $ fromCmu file }
00:23:39 <lambdabot> readFile "cmudict" >>= \ file -> print $ fromCmu file
00:23:43 <ivanm> redFile "cmudict.7a" >>= (print . fromCmu)
00:23:48 <ChongLi> both operators are for sequentially composing actions
00:24:10 <Hertuar> Ah, I see
00:24:12 <Jafet> (... in the IO Monad)
00:24:12 <Hertuar> Thanks guys
00:24:20 <ChongLi> and do notation is just syntactic sugar for >>=
00:25:13 <shachaf> @ty (>>=) (>>=)
00:25:14 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => (((a -> m b) -> m b) -> m a -> b1) -> m a -> b1
00:25:54 <Hertuar> I'm annoyed at Data.Trie -- they're using black magic. My version processes a particular data set at ~5kb/s. Their version seems to do it in ~1MB/s
00:26:35 <ChongLi> what are you using it for?
00:26:57 <ChongLi> have you tried Data.IntMap? or do you need string keys?
00:27:10 <Hertuar> Storing a list of english words, and their pronuncation
00:27:20 <ChongLi> ah
00:27:53 <Hertuar> I'm using a Trie cause I then want to convert it into a trie of nested if statements
00:27:57 <Hertuar> And then compile that
00:28:11 <ivanm> nested if? *shudder*
00:28:21 <Hertuar> Well, nested case statements
00:28:38 <Hertuar> I tried using 1 giant case statement, but ghc explodes
00:28:41 <ChongLi> writing some kind of text-to-speech software?
00:28:56 <shachaf> case of {True,False} counts as an if. :-)
00:29:12 <Hertuar> ChongLi: not really, it's for a translitteration program :D
00:29:22 <Hertuar> converting English words into phonetic cyrillic
00:29:39 <ChongLi> ahh, interesting
00:29:52 <Hertuar> So I want to do a quick look up of a word
00:29:59 <Hertuar> and don't want to ship a dictionary with my app
00:30:08 <Hertuar> i want the dictionary being *embedded* in the app
00:30:14 <Hertuar> So i want to compile the dictionary in
00:30:23 <ivanm> Hertuar: why not just have a data file for it?
00:30:25 <Jafet> ...so you are shipping a dictionary with your app.
00:30:30 <ivanm> rather than hard-code the dictionary in?
00:30:36 <Jafet> In fact, inside your app.
00:30:37 <ivanm> since that would allow for easier updates
00:30:56 <Hertuar> Well i want to avoid having to process it at start time
00:31:17 <Jafet> You expect magic.
00:31:29 <Hertuar> Well, I'll have it as part of the executable
00:31:33 <Jafet> You shift the burden of loading the data to the operating system; nothing changes.
00:31:33 <Hertuar> so it'll be loaded in
00:31:44 <Hertuar> A little does, it's already in the proper format
00:31:51 <Jafet> You just can't load data without loading data.
00:32:00 <Hertuar> while if i used an in memory data structure, it has t oget processed and inserted into the data structure
00:32:10 <Hertuar> But if i compile it in, the OS can just load the program from disk
00:32:11 <ChongLi> how big is the dictionary going to be?
00:32:14 <Hertuar> it's already "loaded"
00:32:15 <Jafet> With a separate file, you can control its structure exactly and use an optimal loading algorithm.
00:32:47 <ivanm> exactly
00:32:49 <Hertuar> The dictionary is about 7MB
00:33:09 <ivanm> even if you use something like acid-state
00:33:59 <Jafet> Oh well, no meritorious argument is going to convince you.
00:34:21 <Hertuar> ivanm: consider if i compile it in, the only thing that needs to be done is the OS load the program from disk into memory. But if I have a separate dictioanry file,it has to load the program (albeit much smaller) and then that program has to load the dictionary and parse it
00:34:35 <Hertuar> So start up time with an in-memory format is much superior. 
00:34:38 <ivanm> Hertuar: is it really likely to take that long?
00:34:49 <ivanm> are you really going to be running the program that often that it's going to matter?
00:34:54 <Hertuar> nah, not really. I'm just trying to do what i'd do in c
00:35:02 <ChongLi> how often is your program being run?
00:35:03 <Hertuar> In c, i'd put it in an array -- and then at run time binary search it
00:35:12 <ivanm> are you going to update the dictionary that rarely that you're OK with it being a PITA to update it?
00:35:17 <ivanm> Hertuar: well, there's your problem
00:35:22 <ivanm> strangely enough, Haskell /= C
00:36:01 <Hertuar> And another benefit is, having a stand alone executable
00:36:08 <Hertuar> as opposed to 2 files files :D
00:36:17 <Axman6> huh?
00:36:18 <ivanm> Hertuar: what, you aren't going to require an installer?
00:36:22 <ChongLi> unless your target platform is a Mac
00:36:30 <Hertuar> nope, no installer
00:36:31 <ChongLi> where you can just put it all inside the .app bundle
00:36:34 <Hertuar> just an executable
00:36:52 <shachaf> > "Haskell" ∕= "C"
00:36:54 <lambdabot>   False
00:37:02 <Hertuar> Installers in both linux and windows is tedius :D
00:37:16 <Hertuar> So it's much nicer if i just have a single file to download
00:37:21 <boegel> I love it how Haskell programs crash with "<<loop>>" when you accidentally implemented an infinite loop :)
00:37:54 <Jafet> Indeed; GHC solves halting problems
00:37:57 <shachaf> The halting problem is no match for the Glorious Glasgow Haskell Compilation system.
00:38:12 <Jafet> It even serves as an oracle if you catch NonTerminationExceptions.
00:38:59 <ChongLi> Hertuar: how about a hash table?
00:39:05 <ChongLi> Data.HashTable
00:39:38 <Hertuar> ChongLi: A hash table is an ideal in memory datastructure -- but I'm trying to convert it to a datastructure that I can compile into the actual code
00:39:55 <Hertuar> So AFAICT my two options are a sorted array (and binary search it) or a trie
00:40:14 <ChongLi> Hertuar: just splat it all into a source file as an association list
00:40:40 <ivanm> ChongLi: no
00:40:50 <ChongLi> no? hehe
00:40:51 <ivanm> Data.HashTable is horrendous (partially by design)
00:41:01 <ivanm> use unordered-containers if you want hash-based data structures
00:41:52 <Hertuar> ChongLi: I also want to avoid anything with any run time costs of initializing the structure.
00:42:13 <Hertuar> [Just for kicks mainly, not to be that practical ]
00:42:37 <Hertuar> But in C this program would have zero statup costs, so i want the same in haskell :)
00:42:57 <Hertuar> Anyway the main purpose is for me to learn haskell :)
00:43:21 <ChongLi> so you just want to store a blob of memory and load it from disk?
00:43:27 <ChongLi> that's pretty low-level
00:43:30 <Hertuar> yup
00:43:31 <Hertuar> exactly
00:43:43 <Hertuar> And when i load that blob of memory, it should have no processing costs
00:43:59 <Hertuar> (i.e. it shouldn't be something that needs to be parsed)
00:44:12 <ChongLi> would Data.Serialize work for him?
00:44:32 <ChongLi> serialize your structure, print out the bytestring
00:44:38 <ChongLi> and then paste it into a source file
00:45:08 <Hertuar> Not sure how that would work
00:45:16 <ivanm> that's pretty anti-Haskell
00:45:17 <Hertuar> i don't think i understand
00:45:48 <ChongLi> Hertuar: data in memory needs to be serialized before being saved to disk
00:46:37 <Jafet> At 7MB, you can use any of the silly solutions here and not notice anything obviously wrong
00:46:47 <Jafet> The question is whether any of them are scalable to, say, 7GB
00:47:00 <Hertuar> ChongLi: http://hackage.haskell.org/trac/ghc/ticket/5102 That's basically the issue i'm trying to work around
00:47:05 <ChongLi> and the answer for that is almost certainly no :P
00:47:18 <Hertuar> (and you can have a look at the attachement i created for a sample data thing)
00:47:21 <ChongLi> for 7GB I would hope you'd load the file lazily
00:48:15 <ddarius> GHC has historically had problems with large source files.
00:48:36 <Hertuar> So my way of working around it is gonig to just nest case statements in each other
00:48:38 <Hertuar> (i.e. a trie)
00:48:44 <Hertuar> as opposed to a just case statement
00:49:10 <ChongLi> so what do all these case statements do?
00:49:18 <Jafet> If you really must do this in program code, write it in C and link it to the program. C compilers provide highly predictable control over memory layout.
00:49:21 <Hertuar> Have a look at the attachement
00:49:27 <Jafet> Otherwise, make a compact binary format and use mmap.
00:49:55 <Hertuar> Jafet: actually I did do that. I compiled it in c with a c function that does a binary search. And it all works quite well
00:50:04 <Hertuar> This is basically me just playing with haskell :)
00:50:18 <Jafet> This isn't playing with haskell, but contorting GHC to do silly things
00:50:33 <Jafet> I don't think it's productive
00:50:36 <Hertuar> And playing with haskell to contorth GHC :P
00:50:38 <Hertuar> I'm learning a lot
00:50:48 <ChongLi> Hertuar: are you used to doing a lot of pointer gymnastics?
00:51:11 <Hertuar> I'm not sure what you mean by taht? 
00:51:19 <Hertuar> My day job involves C code, so perhaps the answer should be yes
00:51:34 <ChongLi> **&**&&& and so on
00:52:08 <Hertuar> I think three levels is the most i've seen
00:52:21 <ChongLi> that stuff is totally alien to Haskell
00:52:23 <shachaf> You can't really have more than one "&" in a row.
00:52:24 <Hertuar> Which was passing in the address of an array that the library would modify
00:53:32 <Hertuar> shachaf: you can in c++ >: D
00:53:41 <Hertuar> (if you use parens)
00:53:49 <Hertuar> &(&(&(x))
00:53:56 <ian_mi> > let fixS n = appEndo . mconcat . replicate n . Endo
00:53:57 <lambdabot>   not an expression: `let fixS n = appEndo . mconcat . replicate n . Endo'
00:53:58 <Hertuar> )
00:54:26 <shachaf> Hertuar: How do you take the address of something that isn't an lvalue?
00:54:38 <Hertuar> by overloading it
00:54:50 <Jafet> :t let fixS n = appEndo . mconcat . replicate n . Endo in fixS
00:54:51 <lambdabot> forall a. Int -> (a -> a) -> a -> a
00:54:52 <Hertuar> :P
00:55:13 <Jafet> If this was a C++ channel, I would say that you cannot overload the address-of operator.
00:55:22 <Jafet> But this isn't, so I obviously won't.
00:55:32 <Hertuar> And if it was a c++ channel, people would correct you :P
00:56:05 <ian_mi> > (appEndo $ mconcat $ replicate 80 $ Endo (\x -> exp (-x^2))) 0
00:56:06 <lambdabot>   0.6529177169220124
00:56:23 <ian_mi> > exp (-0.6529177169220124^2)
00:56:24 <lambdabot>   0.6529194277979099
00:57:13 <ian_mi> aha, fix works for real valued functions :)
00:57:22 <ChongLi> Hertuar: if you truly want to learn Haskell, I suggest reading up on (and learning) about the philosophy of pure functional programming
00:57:26 <Jafet> So that's the category theorist's presentation of head . drop n . iterate
00:57:50 <Hertuar> ChongLi: Well, actually I'm turning the dictionary into a pure function!
00:58:00 <Hertuar> As opposed to anything with IO
02:51:44 <thomas432> hi
02:52:00 <crystal-cola> hi
02:52:43 <thomas432> http://nopaste.me/paste/2345345624daabbfa4dbfe whats wrong here?
02:55:59 <shachaf> thomas432: You don't have main =.
02:56:09 <NisseP> is that really the error is says? :o
02:57:22 <NisseP> ok, never mind, I got "e.hs:4:1: Parse error: naked expression at top level" with no extensions turned on.
02:57:39 <NisseP> because that'd've been the least helpful message i've ever seen :p
02:58:39 <thomas432> ah ok thanks, when i have a main it works
03:02:23 <Xaratas> arg
03:04:23 <Xaratas> somehow the pattern does not work for this matching rule :/
03:12:46 <Xaratas> http://hpaste.org/45761/show could someone help me and tell me what goes here wrong?
03:15:01 <opqdonut_> Xaratas: you need to enable extensions to be able to do that instance
03:15:06 <NisseP> Alist is just a type alias, not a new type; "Alist a" shared the same instances as "[(Char,a)]"
03:15:15 <opqdonut_> Xaratas: or you can use data
03:15:33 <opqdonut_> i.e. "data Alist a = Alist [ (Char,a)]"
03:16:04 <Xaratas> a, thats the difference between my BinTree, a little bit blinded
03:16:16 <lantti> Argh. Miners are a bit problematic when you get deep enough. They are pretty useless if restricted to a burrows but if not they make 500 step walks every time their favorite drink is not in the nearest stockpile or the mining job on the surface seems more attractive :(
03:16:19 <roconnor> copumpkin: twitter is maddness!!
03:16:37 <lantti> Oops, missed...
03:29:36 <mm_freak> is there a URI library like Network.URI, which uses ByteString instead of String?
03:29:41 <mm_freak> or Text
03:34:17 <roconnor> mm_freak: I'm using connectTo with Data.ByteString.hPut
03:34:22 <roconnor> FWIW
03:35:03 <roconnor> oh you wanted a URI library
03:35:04 <roconnor> sorry
03:35:55 <mm_freak> yes, i find only String-based URI libraries
03:37:43 <mm_freak> ok, seems like i have to do it myself
03:38:58 <mm_freak> what about getting the package version number of the current package being compiled?  is this possible?
03:39:09 <mm_freak> or do i have to read the cabal file through TH?
03:39:41 <Saizan> Paths_foo.version
03:39:51 <mm_freak> Saizan: thanks a lot
03:47:19 <dixie> after week of cheating with gnome3 I'm back to my old good wife xmonad :)
03:47:36 <ivanm> OK, that just sounded wrong...
04:04:58 <Jafet> Your mom is gnome3
04:06:40 <Cin> Jafet: Needlessly talked about?
04:07:54 <chris_> umm guys
04:08:00 <chris_> what the hell is haskell
04:08:09 <chris_> err
04:08:16 <Axman6> a prohramming language
04:08:23 <Axman6> programming*
04:08:26 <Guest60613> whats it made for
04:08:34 <Axman6> programming...
04:08:39 <Guest60613> the use of it.
04:08:41 <Skoala> It's general purpose
04:08:42 <Guest60613> lol
04:08:44 <Skoala> or meant to be
04:08:45 <Guest60613> oh
04:08:55 <Axman6> what is C used for? what is Java used for?
04:09:02 <Guest60613> yea true
04:09:05 <Guest60613> ...
04:09:15 <Guest60613> so then whats haskell good at
04:09:21 <Guest60613> >_>
04:09:30 <Skoala> concise correct programs
04:09:44 <osoleve> @faq can haskell do anything you want?
04:09:44 <lambdabot> The answer is: Yes! Haskell can do that.
04:09:45 <Axman6> it's fantastic for parallelism and concurrency
04:10:09 <Guest60613> i c.
04:10:10 <Ke> @faq can haskell programs be easily sandboxed
04:10:10 <lambdabot> The answer is: Yes! Haskell can do that.
04:10:12 <Axman6> it's also great for writing compilers in
04:10:17 <Ke> lol, no they can't!
04:10:18 <Axman6> and it's pretty good at everything else too
04:10:29 <Guest60613> so if i were to become a programmer
04:10:38 <Guest60613> lets say what should i learn first
04:10:44 <Guest60613> is haskell worth learning FIRST
04:10:46 <Skoala> what kind of programs do you want to make?
04:11:10 <Ke> Guest60613: you are not going to get unanbiguous answer for that ever
04:11:14 <Jafet> As a note, most people don't enjoy programming.
04:11:23 <ivanm> Jafet: :o
04:11:24 <Guest60613> yes i do know that
04:11:29 <Axman6> i enjoy programming
04:11:34 <Guest60613> thats why ive hesitated for 3 years to learn anything
04:11:36 <Guest60613> before collegte
04:11:40 <Jafet> Of course, freenode suffers from severe sampling bias.
04:11:47 <Axman6> heh
04:11:47 <Guest60613> but now im learning that college doesnt teach you shit
04:12:04 <Guest60613> w/e
04:12:22 <Skoala> it's a clich but do what you enjoy
04:12:25 <Skoala> cliche
04:12:38 <Guest60613> damnit. maybe i should just design motherboards
04:12:42 <Axman6> Guest60613: do you like problem solving?
04:13:04 <Guest60613> hmm...
04:13:11 <v0id> @pl (\a -> filter (even . ((head a) +)) a)
04:13:12 <lambdabot> filter =<< (even .) . (+) . head
04:13:23 <Guest60613> wtf
04:13:39 <Axman6> that's some rather ugly haskell code
04:13:58 <Axman6> > 1 + 2 -- some less ugly haskell code, followed by this comment
04:13:59 <lambdabot>   3
04:14:14 <Guest60613> 1 + 2
04:14:22 <Guest60613> 1 + 2 --
04:14:24 <Axman6> need the > first
04:14:29 <Guest60613> o shit
04:14:31 <Axman6> > 2^10
04:14:31 <lambdabot>   1024
04:14:43 <Axman6> > 2^1000
04:14:44 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
04:14:48 <Guest60613> lol
04:15:00 <Guest60613> > 9^99999999999
04:15:04 <Guest60613> opps
04:15:05 <Skoala> haha
04:15:14 <lambdabot>   mueval: ExitFailure 1
04:15:14 <lambdabot>  mueval-core: Time limit exceeded
04:15:16 <Skoala> yeah you'd make a good programmer
04:15:19 <Skoala> you like to break things
04:15:23 <yiannis_t> Guest60613: you are melting the bots brain... ;p
04:15:25 <Axman6> you will eventually get an answer, but not from lambdabot
04:15:32 <Guest60613> o damn 
04:15:41 <Guest60613> actually I enjoy breaking things
04:15:44 <Guest60613> testing limits
04:15:58 <Guest60613> and seeing what I can do with whats there but thats not supposed to be
04:16:20 <Axman6> well, it sounds like you may enjoy programming
04:16:30 <Guest60613> eventually
04:16:34 <Axman6> if you're interested, check out this web site:
04:16:37 <Axman6> @where lyah
04:16:37 <lambdabot> http://www.learnyouahaskell.com/
04:16:50 <mm_freak> Guest60613: haskell is good for web applications and network software
04:16:55 <Axman6> if there's stuff you don't understand, we're more than happy to explain
04:17:04 <v0id> damn, it didn't work
04:17:21 <mm_freak> that's the strong part of haskell, i think…  but also compilers, but not many people write compilers
04:17:43 <Guest60613> wow....i just realized ive collected all the ebooks and videos i ever needed to learn everything thats out there 
04:17:50 <Guest60613> wtf
04:17:53 <Guest60613> im so lazy
04:18:01 <Skoala> lol
04:18:10 <Guest60613> like literally
04:18:10 <tamiko> :D
04:18:16 <Guest60613> have any of you tried to learn drupal
04:18:17 <Guest60613> FUCK
04:18:34 <Axman6> i don't think a CMS is something you can 'learn' as such
04:18:47 <Jonno_FTW> Guest60613: what does this have to do with Haskell?
04:18:50 <Guest60613> well. i mean function with it properly
04:18:51 <Axman6> i used to know the brother of the creator of drupal
04:18:56 <Guest60613> nothing at all just an example
04:19:10 <Guest60613> who are you guys....
04:19:19 <Jonno_FTW> we are the dreamers of dreams
04:19:25 <Guest60613> FTW
04:19:36 <Axman6> I'm a university student in Australia
04:19:51 <Jonno_FTW> I'm a university student in South Australia
04:19:51 * tamiko just realized that FlexibleInstances ist not a good idea when instanciating something e.g. in Read :)
04:19:59 <Guest60613> i want to be a university student in Los Angeles
04:20:00 <v0id> I'm motherfucker with vodka and bears
04:20:05 <Guest60613> but i have to wait for residency
04:20:09 <Guest60613> >_>
04:20:10 <v0id> HELL YEAH
04:20:19 <Jonno_FTW> Axman6: what university do you attend?
04:20:29 <Axman6> ANU
04:20:45 <Jonno_FTW> Flinders
04:20:47 <mgsloan> University of Washington
04:20:48 <v0id> @pl (\a -> f (g . ((h a) +)) a)
04:20:48 <lambdabot> f =<< (g .) . (+) . h
04:20:58 <v0id> FFFFUUUU
04:21:06 <Axman6> i didn't know you were an aussie, you should join us in #haskell.au :)
04:21:16 <Skoala> what does the @pl do? suggest a refactoring?
04:21:28 <v0id> http://www.haskell.org/haskellwiki/Pointfree
04:21:28 <Axman6> Jonno_FTW: you ashould also come along to the hackathon we're holding in July, announced today
04:21:31 <Skoala> @pl (\y -> (\x -> x + y))
04:21:31 <lambdabot> (+)
04:21:36 <Skoala> ^^
04:21:41 <Jonno_FTW> Axman6: what will be taking place?
04:21:47 <Skoala> thanks v0id
04:21:49 <Axman6> haskell hacking!
04:21:56 <Guest60613> > ghci
04:21:58 <lambdabot>   Not in scope: `ghci'
04:22:05 <Axman6> it's good fun, you get to meat lots of other haskell hackers
04:22:13 <Axman6> meet even
04:22:14 <Axman6> >_>
04:22:25 <Axman6> we won't eat you, i promise
04:22:32 <Jonno_FTW> sure suer
04:22:35 <Jonno_FTW> well
04:22:53 <Guest60613> > doubleMe x = x + x
04:22:54 <Jonno_FTW> is there a page for this?
04:22:54 <lambdabot>   <no location info>: parse error on input `='
04:23:07 <v0id> you forgot 'let'
04:23:14 <Guest60613> huh
04:23:17 <Jonno_FTW> > let doubleMe = (2*) in doubleMe 5
04:23:18 <lambdabot>   10
04:23:23 <Axman6> Jonno_FTW: http://www.haskell.org/haskellwiki/AusHac2011
04:24:09 <Guest60613> alright guys.
04:24:09 <v0id> @pl (\n s -> [(a, b, c) | a <- [1 .. n], b <- [a + 1 .. n], let c = s - a - b, b + 1 <= c, c <= n])
04:24:09 <lambdabot> (line 1, column 10):
04:24:09 <lambdabot> unexpected "["
04:24:09 <lambdabot> expecting lambda abstraction or expression
04:24:17 <Jonno_FTW> Axman6: my Haskell isn't a level high enough to work on those sort of projects
04:24:19 <v0id> =((
04:24:23 <Guest60613> thanks for all this info
04:24:31 <Axman6> Jonno_FTW: pfft, there's no need for it to be
04:24:34 <Guest60613> > 6^66
04:24:34 <lambdabot>   2280250319867037997421842330085227917956272625811456
04:24:44 <Jonno_FTW> I'm only a lowly 2nd year software engineering student with 2.5 years haskell experience
04:24:44 <Skoala> have fun with Haskell :p
04:24:49 <Axman6> Jonno_FTW: http://www.haskell.org/pipermail/haskell-cafe/2011-April/091085.html
04:24:55 <v0id> > let gen n s = [(a, b, c) | a <- [1 .. n], b <- [a + 1 .. n], let c = s - a - b, b + 1 <= c, c <= n] in gen 3 10
04:24:56 <lambdabot>   []
04:24:58 <Guest60613> wait wait wait wait i gotta
04:25:07 <Guest60613> > 10000000000000000000000000000000000000000 ^ 0
04:25:08 <lambdabot>   1
04:25:12 <Guest60613> OWNED
04:25:13 <Axman6> Jonno_FTW: I've only got 3.5 years, and i organised this hackathon last year with only 2.5 years experience ;)
04:25:34 <blackdog> Jonno_FTW: and it was pretty good, apart from all the canberrans
04:25:34 <v0id> > let gen n s = [(a, b, c) | a <- [1 .. n], b <- [a + 1 .. n], let c = s - a - b, b + 1 <= c, c <= n] in gen 3 6 -- maybe?
04:25:34 <lambdabot> blackdog: You have 1 new message. '/msg lambdabot @messages' to read it.
04:25:35 <lambdabot>   [(1,2,3)]
04:25:56 <Guest60613> > 90 + 20 - 1 + 6)()()()()()()()()()(+ 8
04:25:57 <lambdabot>   <no location info>: parse error on input `)'
04:26:00 <Guest60613> ha
04:26:03 <Guest60613> idk wtf that is
04:26:09 <v0id> >0^0
04:26:18 <Guest60613> FUCK
04:26:24 <Guest60613> NOOOOOOoooo
04:26:25 <Axman6> watch the language
04:26:29 <Guest60613> sawy
04:26:30 <blackdog> Axman6: speaking of: gonna be at UNSW?
04:26:37 <Axman6> yeah
04:26:56 <Axman6> we had 25 people last year, so not worth trying to fit that many in a room for only 20
04:27:00 <Guest60613> > .000000000000000000000000000001^4
04:27:01 <lambdabot>   <no location info>: parse error on input `.'
04:27:05 <blackdog> yeah, makes sense. maybe next year:)
04:27:08 <v0id> leading zero!
04:27:14 <tamiko> @pl \f -> \m -> \a -> \b -> m >>= f a b
04:27:14 <lambdabot> flip ((.) . (.) . (>>=))
04:27:17 <Guest60613> > 0.000000000000001^4
04:27:19 <lambdabot>   1.0000000000000001e-60
04:27:31 <Xaratas> there is no thing like a generic default value for records or?
04:27:34 <blackdog> Axman6: i sort of got drafted for running an FP for newbies night at the ruby meetup as well as one for fp-syd
04:27:54 <Axman6> blackdog: when? I'm coming up next week
04:28:01 <v0id> @unpl flip ((.) . (.) . (>>=))
04:28:01 <lambdabot> (\ b c f i -> c >>= (b f i))
04:28:18 <blackdog> the ruby one is next month... haven't sorted out the fp one yet
04:28:20 <tamiko> :)
04:28:20 <v0id> @unpl (.).(.)
04:28:21 <lambdabot> (\ i b c f -> i (b c f))
04:28:28 <Axman6> ah ok
04:28:48 <v0id> @unpl (.).(.).(.)
04:28:48 <lambdabot> (\ l b c f i -> l (b c f i))
04:28:59 <v0id> hmmm
04:29:15 <v0id> @unpl (.)$(.)
04:29:15 <lambdabot> (\ b c e f -> b c (e f))
04:29:24 <v0id> @unpl (.)$(.)$(.)
04:29:24 <lambdabot> (\ b c f h i -> b c f (h i))
04:30:22 <v0id> damn, how does this (->) moandic hell work, I wanna have @pl in my brainz
04:31:03 <Axman6> none of that is monadic really
04:31:16 <Axman6> well, at least making use of the (->) monad
04:31:59 <v0id> (->) monad, arrows and couple of other things one would like to unsee
04:32:12 <tamiko> :D :D
04:32:23 <tamiko> instance Category (->) where ... :)
04:32:28 <ourfrank> I'm trying to use FTGL's buffer fonts, but each character always display's like a white box. The texture fonts work fine. Does anyone know if this is a library issue of some sort, because the docs seem to imply all kinds of fonts are handled the same (which I'm doing).
04:33:45 <ourfrank> I use createBufferFont (path-to-ttf), and then call setFontFaceSize (font) 10 72. From then on, every renderFont call will draw a filled-white box.
04:36:16 <tamiko> http://paste.pocoo.org/show/372329/
04:37:09 <Xaratas> @hoogle isUndefined
04:37:10 <lambdabot> No results found
04:37:23 <Xaratas> :(
04:37:23 <v0id> @pl \t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0
04:37:23 <lambdabot> (2 :) . flip filter [3..] . (`ap` (flip flip 0 . ((/=) .) . mod)) . (flip all .) . (. flip ((<=) . (^ 2))) . flip takeWhile
04:37:31 <v0id> YEEEEAH
04:38:25 <Xaratas> oo, what does this v0id?
04:38:36 <tamiko> v0id: So many flips make me dizzy...
04:38:50 <v0id> fixpoint of this generates an infinite list of primes
04:39:10 <tamiko> ic ic :D
04:39:24 <Axman6> > fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:39:27 <lambdabot>   mueval-core: Time limit exceeded
04:39:40 <v0id> INFINITE LIST of primes
04:39:51 <v0id> > take 10 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:39:55 <lambdabot>   mueval-core: Time limit exceeded
04:39:58 <DevHC> lol
04:40:00 <Boxo> derp
04:40:00 <Axman6> snap
04:40:00 <v0id> 0_o
04:40:05 <tamiko> *chrchr*
04:40:17 <Axman6> > head $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:40:20 <lambdabot>   2
04:40:31 <Axman6> > take 2 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:40:33 <lambdabot>   [2,3]
04:40:38 <Axman6> > take 4 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:40:40 <lambdabot>   [2,3,5,7]
04:42:15 <v0id> > take 10 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:42:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
04:42:30 <v0id> so what was the problem before?!
04:42:55 <v0id> *trollface*
04:43:00 <v0id> take 1000 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:43:09 <v0id> > take 1000 $ fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:43:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:43:21 <v0id> oh noes
04:43:29 <Xaratas> hm
04:43:37 <v0id> it would be niciest way to flood the whole chat
04:43:42 <Axman6> > fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)!! 100
04:43:44 <lambdabot>   547
04:43:47 <Axman6> > fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)!! 10000
04:43:50 <lambdabot>   104743
04:44:29 <v0id> it's pretty quick. it sieves each number with primes under the square root of that number
04:44:42 <v0id> * below
04:46:13 <v0id> @pl fix (\t -> (2 :) $ flip filter [3..] $ \n -> flip all (flip takeWhile t $ \i -> i ^ 2 <= n) $ \x -> n `mod` x /= 0)
04:46:14 <lambdabot> fix ((2 :) . flip filter [3..] . (`ap` (flip flip 0 . ((/=) .) . mod)) . (flip all .) . (. flip ((<=) . (^ 2))) . flip takeWhile)
04:52:45 <Xaratas> is undefined a value against which i could check? e.g. for a print function
04:53:38 <sipa> no
04:57:49 <ski> > fix $ \primes -> 2 : tail [n | n <- [2 ..] , all (\d -> n `mod` d /= 0) (takeWhile (\d -> d ^ 2 <= n) primes)]
04:57:50 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:00:23 * ski idly wonders how to generate gaussian primes
05:01:35 <crystal-cola> map (\p -> if p`mod`4 == 1 then let x^2 + y^2 = p in x :+ y else if p == 2 then 1 :+ 1 else p)
05:01:38 <crystal-cola> primes
05:04:36 <sipa> @src undefined
05:04:36 <lambdabot> undefined =  error "Prelude.undefined"
05:05:20 <ski> > let undefined | False = undefined in undefined
05:05:21 <lambdabot>   *Exception: <interactive>:3:4-32: Non-exhaustive patterns in function undef...
05:12:50 <v0id> @unpl fix ((2 :) . flip filter [3..] . (`ap` (flip flip 0 . ((/=) .) . mod)) . (flip all .) . (. flip ((<=) . (^ 2))) . flip takeWhile)
05:12:50 <lambdabot> fix (\ aa -> 2 : (filter ((\ bc o -> all o (takeWhile (\ s -> (s ^ 2) <= bc) aa)) >>= \ bh -> (\ aj j -> (mod aj j) /= 0) >>= \ bg -> return (bh bg)) [3 ..]))
05:13:04 <v0id> -______-
05:13:20 <ski> > [(p,x,y) | p <- primes , x <- [1 .. p] , x^2 <= p , let y = floor (sqrt (fromIntegral (p - x^2))) , x <= y , x^2 + y^2 == p]
05:13:22 <lambdabot>   [(2,1,1),(5,1,2),(13,2,3),(17,1,4),(29,2,5),(37,1,6),(41,4,5),(53,2,7),(61,...
05:14:52 <ski> hm, something like `divMod' for roots (and logarithms) might be nice
05:24:14 <Jafet> What's divMod for roots?
05:25:59 <v0id> @pl \a b c ->  ((.a).(b(.)).c
05:25:59 <lambdabot> (line 1, column 26):
05:25:59 <lambdabot> unexpected end of input
05:25:59 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or ")"
05:26:28 <v0id> @pl \a b -> ((.a).(flip(.)).b
05:26:28 <lambdabot> (line 1, column 26):
05:26:28 <lambdabot> unexpected end of input
05:26:28 <lambdabot> expecting letter or digit, variable, "(", ".", "`", "!!", operator or ")"
05:26:38 <v0id> @pl (\a b -> ((.a).(flip(.)).b)
05:26:39 <lambdabot> (line 1, column 28):
05:26:39 <lambdabot> unexpected end of input
05:26:39 <lambdabot> expecting variable, "(", operator or ")"
05:27:26 <v0id> @pl \a b -> (.a).(flip(.)).b
05:27:26 <lambdabot> (. (flip (.) .)) . (.) . flip (.)
05:31:34 <v0id> @pl \a b -> (.a).(flip(.)).b
05:31:34 <lambdabot> (. (flip (.) .)) . (.) . flip (.)
05:32:01 <homie> err what's the point of flipping so many points ?
05:35:12 <roconnor> @hoogle String -> ByteString 
05:35:12 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
05:35:12 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
05:35:12 <lambdabot> Prelude read :: Read a => String -> a
05:35:49 <Xaratas> what are the posibble ways to print out records with uninitialised values? use maybe a instead of a for the record type? 
05:37:27 <crystal-cola> uh
05:37:38 <crystal-cola> what does that have to do with printin
05:38:53 <Xaratas> the show function does not want to print uninitialised values
05:39:16 <sipa> it cannot
05:39:21 <opqdonut_> Xaratas: use Maybe
05:39:34 <Xaratas> and someone sayed i could not check it a field is initialised prior to use it
05:39:38 <opqdonut_> undefined record fields are bad practice
05:39:59 <sipa> Xaratas: indeed, it is effectively undefined, and as such, every expression that uses its value is undefined as well
05:40:03 <opqdonut_> you can check whether it's a Nothing if you use Maybe
05:40:46 <Vermeille> Hi all
05:41:47 <Vermeille> Guys, I'm looking to gtk2hs documentation and it looks very "imperative"
05:42:06 <Vermeille> Is there any GUI library with a more functionnal style ?
05:42:24 <ClaudiusMaximus> > Just{} :: Maybe Int  -- wondering if this is legal...
05:42:25 <lambdabot>   Just *Exception: <interactive>:3:0-5: Missing field in record construction
05:43:15 <Jafet> How do you make a record with uninitialized values?
05:43:35 <Xaratas> name {}
05:43:57 <Jafet> Oh, as above
05:44:15 <Axman6> :t Left{}
05:44:16 <lambdabot> forall a b. Either a b
05:44:29 <Jafet> Well, if it raises an exception, you can detect it using sinful means
05:44:32 <Vermeille> (And if someone has a good experience with a game library, always functional, I want to learn something else, I've done too much C#)
05:44:58 <Jafet> Vermeille: there is the concept of "functional reactive programming", but it is still being developed
05:45:30 <Axman6> the haskell GUI libraries are almost all quite imperative, there's not really a good way to avoid it
05:45:41 <Jafet> That's because they are bindings to imperative libraries
05:46:18 <Jafet> There aren't any FRP approaches to widgetty GUI either, last time I checked
05:54:06 <Vermeille> Okay thanks :)
05:54:19 <Vermeille> Any suggestion for a game / 2D Graphics library ?
05:54:32 <Vermeille> in a functional style, if possible
05:55:02 <hpc> Vermeille: there's fungen
05:55:27 <hpc> come to #haskell-game
05:57:37 <Vermeille> thx hpc :)
06:03:11 * roconnor is tempted to make a data type for prime numbers
06:04:34 <Jafet> At the type level?
06:04:55 <roconnor> basically make a recursive data type for Pocklington certificates
06:05:07 <roconnor> so at the data level
06:05:45 <Jafet> You mean Goldwasser-Kilian certificates, right
06:06:01 <roconnor> I don't know what those are
06:06:29 <Jafet> The ones that can be made in polynomial time
06:06:41 <roconnor> nope
06:06:54 <roconnor> but maybe I should make a data type for those instead :D
06:07:31 <roconnor> oh pocklington's theorem requires a gcd test
06:07:40 <roconnor> bah
06:08:57 <crystal-cola> how could there be a data type for prime numbers?
06:09:42 <crystal-cola> is it just natural numbers with a check built in
06:10:44 <Heffalump> I think roconnor is proposing having proofs of primality at the type level, so that at the value level you could only ever have a prime number.
06:11:49 <Jafet> GK certificates are worse, they require point counting or something
06:15:26 <roconnor> Heffalump: the proofs would be at the data level (after all proofs are programs)
06:15:44 <roconnor> Heffalump: then you'd write a function to convert these proofs to the integer prime that it is a proof of
06:16:00 <Heffalump> are they cheaper to check than just doing a primality test?
06:16:23 <roconnor> Heffalump: yes, but not cheaper than a probabilistic test
06:16:24 <Jafet> That's why they're called certificates...
06:18:38 <ski> Jafet : i was thinking : given `radicand' and (positive) `radix', find the largest `root' such that `root^radix =< radicand', and return `(root,radicand - root^radix)'
06:20:28 <ski> (so, the best approximation, from below, of the root)
06:21:17 <Jafet> The snd seems trivial to compute compared to the fst
06:21:34 <ski> yeah, as with `divMod'
06:22:06 <Jafet> Computationally, that is
06:23:04 <Jafet> Putting that aside, though, what would you use the snd for?
06:25:18 <ski> > [(p,x,y) | p <- primes , x <- [1 .. p] , x^2 <= p , (y,0) <- [rootMod 2 (p - x^2)] , x <= y]
06:25:19 <lambdabot>   Not in scope: `rootMod'
06:26:02 <ski> (.. was why i came to think about it above)
06:27:28 <Jafet> divMod is useful because it's much more efficient to compute both at once than separately
06:27:38 <Jafet> Anyway, we don't even have an integer sqrt.
06:28:07 <ski> yeah. i have no idea if something similar would hold here, for some sensible algorithm
06:36:43 <hpc> to expand on what Jafet said, x86 division and modulo are both the same instruction, and it saves both into separate registers
06:39:27 <Jafet> Well, I had much larger operands in mind
06:54:14 <ksf> is it possible to trigger haddock generation on hackage from the outside?
06:55:56 <Axman6> f you just submitted a package, it wakes several hours for haddock to be run (it's odne in batches)
06:56:00 <Axman6> if*
07:00:56 <ksf> well, then let me ask in a different way... could the cronjob be run more frequentli?
07:02:21 <td123> does anyone have any good resources on learning "continuation passing style"? I read that small tutorial at the end of the Types chapter in Yet Another Haskell Tutorial, but I still feel uneasy about the concept
07:02:47 <ksf> td123, there's only one way to actually grok it, and that involves using it
07:03:21 <ksf> then there's "advanced programming language design" (pdfs are online), which has a whole section about continuations
07:03:43 <ksf> otoh, there's very, very simple examples.
07:03:47 <ksf> consider, for example,
07:03:49 <Saizan> td123: OTOH, it's not so fundamental to understand CPS, especially for a beginner
07:03:55 <crystal-cola> what do you want to know about CPS?
07:04:15 <ksf> ifM c a p = if p then c else a
07:04:18 <aavogt> @type mkT
07:04:19 <Saizan> td123: i.e. i've never understood why YAHT places CPS there
07:04:20 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
07:05:00 <ksf> urm.
07:05:02 <aavogt> @ty everywhere
07:05:03 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
07:05:15 <ksf> I should stop trying to haphazardly explain without feedback.
07:05:27 <td123> well, I understand that you pass a continuation, that should execute after your function is done, but when I tried writing a continuation version of map, I got stuck
07:05:32 <smoge> hi
07:05:34 <crystal-cola> td123: what do you want to know about CPS?
07:05:41 <smoge> Im getting *a lot* of errors with cabal
07:05:44 <aavogt> CPS is important if you start to label everything a continuation
07:05:56 <smoge> im using archlinux
07:06:01 <smoge> is this an known bug?
07:06:08 <ksf> when doing that, one usually uses the Cont monad
07:06:14 <smoge> Im trying to install haskore
07:06:20 <rostayob> smoge: what kind of errors? anyway, I'd suggesto to package everything in archlinux packages with cabal2arch
07:06:21 <lambdabot> rostayob: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:06:21 <ksf> :t runCont
07:06:22 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
07:06:42 <td123> crystal-cola: well, I'm just looking for a clear tutorial on continuations so I can try to grasp how to code them
07:06:51 <crystal-cola> why?
07:06:57 <smoge> rostayob: http://pastebin.com/muAZb3A6
07:07:04 <smoge> dependency errors
07:07:09 <Axman6> crystal-cola: he just told you why :\
07:07:10 <smoge> ugly dependency errors
07:07:25 <td123> crystal-cola: because I was reading through YAHT and I didn't feel like I got anything out of their explanation, or very little
07:07:39 <smoge> packages like directory and process goes to loop problems
07:07:39 <rostayob> smoge: install the archlinux packages for process and directory
07:07:40 <td123> crystal-cola: I'm trying to go sequentially through that tutorial
07:07:45 <crystal-cola> I will look at YAHT
07:07:59 <smoge> rostayob: how can I remove then with cabal?
07:08:07 <td123> crystal-cola: it's the last part of the "Types" chapter
07:08:14 <rostayob> smoge: you delete .cabal and .ghc :P there is no "cabal uninstall"
07:08:18 <aavogt> smoge: probably you ended up with process-1.0.1.5, because one of the libraries broken? Or used cabal upgrade if that's still available
07:09:01 <smoge> aavogt: http://pastebin.com/Jg191RPD
07:09:11 <smoge> cabal upgrade does not work here
07:09:13 <rostayob> smoge: anyway, there are tools to convert cabal file to PKGBUILDs, and they help a lot. I haven't been using cabal for a while
07:09:19 <aavogt> smoge: ok, so you didn't use it then
07:09:31 <crystal-cola> td123: haha it says that CPS is a "style of functional programming"
07:09:57 <smoge> where the .cabal files goes?
07:10:01 <crystal-cola> td123: I don't think the author knows what CPS is about
07:10:32 <smoge> its ~/.cabal/lib ??
07:10:32 <td123> crystal-cola: that's why I'm asking for any good tutorials on it :)
07:10:39 <rostayob> smoge: if you install cabal2arch, you can use it directly with the cabal file on hackage, e.g. cabal2arch http://hackage.haskell.org/packages/archive/bytestring/0.9.1.10/bytestring.cabal
07:10:50 <crystal-cola> why do you want to learn it?
07:10:51 <rostayob> and it'll generate everything
07:11:07 <td123> crystal-cola: he does a good job imo with the previous parts, but drops the ball on cps
07:11:12 <hvr_> td123: do you know the 'call with current continuation patterns'-paper?
07:11:16 <smoge> rostayob: ok so I can just delete the folder .cabal??
07:11:16 <crystal-cola> td123: yes
07:11:28 <td123> hvr_: no
07:11:29 <rostayob> Eduard_Munteanu: I had reached the same conclusion at the end. it works fairly well anyway, thanks for the help
07:11:43 <rostayob> smoge: and .ghc. note that this will delete all the cabal installed packages
07:11:49 <smoge> rostayob: for example: xmonad does not work here when I use pacman
07:11:51 <hvr_> td123: I found it helpful when I was trying to understand CPS
07:11:58 <td123> crystal-cola: well I want to learn it because it's yet another programming style :)
07:12:14 <smoge> rostayob: It just worked when I installed with cabal
07:12:19 <rostayob> smoge: what? why?
07:12:26 <crystal-cola> it's not a programming style! that's whta I was pointing out, it's funny that the author says that because it's false
07:12:36 <smoge> rostayob: I don't know... It just didnt work here
07:12:43 <crystal-cola> td123: it's something compilers use half way between the input and output
07:12:51 <rostayob> smoge: well "it didn't work" is not really specific :P
07:13:01 <smoge> rostayob: "xmonad --recompile" returned ugly error of packages not installed
07:13:25 <rostayob> smoge: this happened with the official repository xmonad?
07:13:37 <smoge> yes
07:13:50 <rostayob> smoge: really weird. it's more of an archlinux issue anyway
07:13:53 <smoge> rostayob: with pacman -S xmonad
07:13:54 <td123> smoge: xmonad under archlinux works
07:14:03 <td123> smoge: I'm currently using it with xmobar :P
07:14:15 <smoge> td123: me too!
07:14:20 <smoge> td123: but installed with cabal
07:14:26 <td123> ah
07:14:36 <td123> I'm using the one already packaged for me
07:14:49 <rostayob> smoge: cabal is quite messy. in the end I prefer packaging everything, also because you get all the haddock documentation nicely
07:14:53 <rostayob> in /usr/share/doc
07:15:08 <aavogt> cabal does documentation if you enable it
07:15:17 <rostayob> aavogt: but not system-wide
07:15:20 <smoge> rostayob: ok, I will try your suggestion, lets see how it goes with haskore installation
07:15:53 <kernalogs> thinking of getting a haskell compiler, ubuntu... netbook, must be quite compact, and have useful stack tracing on error etc...
07:16:01 <aavogt> rostayob: if you like that, it can do that too
07:16:27 <td123> hvr_: crystal-cola: thanks, I'll take a look at the call w/ current continuation patterns (26 pages :S) and I'll have a stab at it
07:16:38 <rostayob> aavogt: the point is that cabal2arch creates the PKGBUILD and puts the docs where you would expect them automatically. I'm sure you can do it with cabal too but it's easier
07:16:43 <crystal-cola> td123: note that CWCC is nothing to do with CPS
07:16:58 <smoge> rostayob: we should have a wrapper for using cabal2arch
07:17:02 * td123 sighs
07:17:09 <smoge> rostayob: and installing it with pacman
07:17:29 <rostayob> smoge: it's as easy as cabal2arch whatever, cd haskell-whatever, makepkg
07:17:38 <rostayob> I mean you'll probably have to install other stuff to compile
07:17:53 <aavogt> rostayob: cabal2arch doesn't let you install multiple versions of a library with the same name without intervention (last I checked)
07:17:55 <rostayob> but anyway after you've got what you need I think it's a cleaner way, compared to cabal
07:18:04 <rostayob> aavogt: no, that's the limit I guess.
07:18:28 <rostayob> aavogt: it's not cabal2arch, it's pacman. you can't have multiple versions of the same package
07:18:44 <CSSE> hello guys
07:18:53 <CSSE> can I ask questions about leksah here?
07:18:55 <aavogt> so say you have two programs, one uses parsec 2, the other parsec 3: you can't build both using the scripts written by cabal2arch directly
07:19:01 <smoge> rostayob: maybe this is an issue of ghc 6.12.3 and 7.0.2 ???
07:19:19 <rostayob> aavogt: you cited the only case I ever had this problem with (parsec)
07:19:50 <CSSE> leksah says: Could not find module `Char'
07:20:12 <CSSE> how do I fix this?
07:20:25 <td123> well if it was helpful in getting to understand cps, then I'll take a look at it :)
07:20:26 <crystal-cola> td123: You can see some examples of what CPS transformed code looks like http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style#Starting_simple in this section of that page
07:20:32 <rostayob> smoge: no, I don't think so. but the current ghc has linking problems, at least on arch: https://bugs.archlinux.org/task/23247?string=ghc&project=1&type%5B0%5D=&sev%5B0%5D=&pri%5B0%5D=&due%5B0%5D=&reported%5B0%5D=&cat%5B0%5D=&status%5B0%5D=open&percent%5B0%5D=&opened=&dev=&closed=&duedatefrom=&duedateto=&changedfrom=&changedto=&openedfrom=&openedto=&closedfrom=&closedto=
07:20:38 <rostayob> oh god that's a long url, sorry
07:21:41 <Eduard_Munteanu> rostayob: ah you mean you didn't use records anymore.
07:21:45 <td123> rostayob: lol
07:22:02 <td123> luckily my irc client auto-tinyurls things :)
07:22:21 <td123> though I still see the original url
07:22:29 <rostayob> Eduard_Munteanu: no, not directly, I just pattern match with them, like Foo { whatever = var }
07:22:32 <crystal-cola> td123: you can adapt the 'thrice' example to CPS map quite easily
07:24:50 <hamishmack> CSSE: Where does it say that? In the log pane?
07:25:02 <smoge> rostayob: I got other kind of error
07:25:05 <smoge> WARNING: version requirement for haskell-containers is logically impossible.
07:25:18 <smoge> with cabal2arch  http://hackage.haskell.org/packages/archive/haskore-supercollider/0.1.2.2/haskore-supercollider.cabal 
07:25:50 <hamishmack> CSSE: Did you do import Char instead of import Data.Char ?
07:25:53 <rostayob> smoge: that's fine, maybe you'll have to edit the PKGBUILD
07:29:09 <crystal-cola> td123: was that no use?
07:29:20 <aavogt> containers comes with ghc
07:30:13 <td123> crystal-cola: I guess I should probably learn more haskell.. I've never used $
07:30:22 <crystal-cola> td123: oh that's just syntax
07:30:26 <td123> so I can't even read the example
07:30:48 <rostayob> td123: something $ something else == something (something else)
07:31:09 <crystal-cola> td123: instead of writing  f (\x -> g (\y -> ...
07:31:19 <crystal-cola> dcoutts_: it's shorter to write f $ \x -> g $ \y -> ...
07:31:23 <crystal-cola> dcoutts_: sorry
07:31:24 <crystal-cola> td123: ^
07:31:36 <td123> k
07:31:40 <aavogt> smoge: you should probably change the cabal file to allow a higher version of containers, so you can use the one that comes with ghc-7
07:31:47 <crystal-cola> td123: do you understand that notation?
07:32:23 <crystal-cola> it just saves on brackets and indentation
07:33:02 <td123> ya
07:33:13 <crystal-cola> td123: the main thing is that the conversion is type directed
07:35:27 <td123> crystal-cola: I understand $ now, but not your last comment :)
07:36:41 <crystal-cola> td123: CPS is a transform from one language (in this case both languages are subsets of haskell) to another: The first thing you do is convert the type of the functions - then you are (almost) forced to write the correct translation by that
07:39:46 <crystal-cola> td123: did that make sense?
07:39:54 <kernalogs> so what's the IDE like and what's the MB size of GHC
07:40:28 <rostayob> kernalogs: what IDE?
07:40:29 <parcs> kernalogs: ghc is ~700M and there is no official IDE
07:40:45 <hpc> parcs: wow, that huge?
07:40:54 <rostayob> yeah, ghc is huge
07:40:57 <Axman6> 700MB? eh?
07:41:02 <rostayob> it's more like 500MB, at least on linux
07:41:09 <Axman6> possibly installed size, but not download size
07:41:15 <rostayob> yeah installed size
07:41:31 <monochrom> 600MB here but yeah. (32-bit vs 64-bit?)
07:41:33 <parcs> rostayob: on linux x86_64 it's 700M at least
07:41:59 <rostayob> parcs: on 32 bit I remember something under 600MB
07:42:05 <rostayob> like 550
07:42:09 <parcs> but yeah the compressed size is like 50M
07:42:12 <rostayob> it doesn't matter that much I guess
07:42:59 <td123> crystal-cola: so you're saying that since modifying the function (for instance map) requires an additional parameter, that it follows that you just need to update your functions?
07:43:21 <td123> or usage of map to take into account that extra parameter?
07:43:53 <crystal-cola> td123: yeah the idea of a type directed transform is that modifying the type is the important bit: modifying the source code can only be done in one obvious way to fit the type
07:44:38 <td123> ah ok, I get it then :)
07:45:08 <crystal-cola> td123: note that this is technical stuff that happens inside compilers, it's bizarre to include it halfway through a beginners tutorial
07:45:57 <rostayob> @pl \f x -> f (f (f x))
07:45:58 <lambdabot> ap (.) (join (.))
07:46:07 <rostayob> mh
07:47:04 <rostayob> @pl \f x -> f (f (f (f x)))
07:47:04 <lambdabot> ap (.) (ap (.) (join (.)))
07:47:27 <td123> crystal-cola: I don't mind, I've used ocaml before so I flew through most of the examples, don't mind a challenge right now :)
07:48:01 <monochrom> eh? which tutorial is it?
07:48:12 <td123> yet another haskell tutorial
07:52:59 <TomMD> Does anyone know of an emacs mode for happy .y files?
07:53:35 <rostayob> TomMD: I guess that a mode for lex files would work fine
07:53:54 <rostayob> no sorry, a bison mode :P
07:54:44 <TomMD> Doesn't seem to, there are issues with the autoalign.
07:55:01 <rostayob> TomMD: oh ok, idk then.
07:55:18 <rostayob> with autoalign you mean with the indentation?
07:55:37 <smoge> cabal2arch is broken here
07:55:39 <smoge> does no work
07:55:55 <smoge> Setup: <command line>: can't load .so/.DLL for: HSdirectory-1.1.0.0 (libHSdirectory-1.1.0.0.so: cannot open shared object file: No such file or directory)
07:56:05 <smoge> damn, so many problems
07:56:19 <rostayob> smoge: this happens when doing makepkg?
07:56:23 <smoge> yes..
07:56:24 <TomMD> rostayob: yes, the indentation
07:56:43 <smoge> with *all* PKGBUILDS
07:56:54 <smoge> cabal2arch is broken I guess
07:57:49 <rostayob> smoge: I've been using cabal2arch for some months now, and it works fine
07:57:59 <rostayob> wait I'm going to try now haskore looks interesting anyway :P
07:58:04 <smoge> hum... whatsw wrong here?
07:58:31 <smoge> do you have testing enabled?
07:59:08 <rostayob> smoge: in arch? no, but I've got the testing fhc. it seems it can't find a shared library...
07:59:39 <rostayob> *ghc
07:59:43 <monochrom> it looks like (you didn't build the "directory" package with --enable-shared) or (you didn't install the arch subpackage that has "directory"'s shared lib version)
07:59:54 <smoge> better to downgrade ?
08:00:27 <td123> ok, I think I get cps, but to write a cps style of map, wouldn't you need to keep track of how many elements you have processed?
08:00:45 <td123> if you weren't to use map and processed one element at a time?
08:00:55 <smoge> --enable-shared is a makepkg option?
08:01:04 <crystal-cola> td123: start by writing out the type of map, then converting it to the type of CPS transformed map
08:01:09 <monochrom> --enable-shared is a cabal-install option
08:02:01 <crystal-cola> td123: (if that's difficult look at the type of thrice and how it was transformed for inspiration)
08:02:06 <td123> cause I can just write map f x c = c $ map f x but I'm pretty sure that's not what they want me to do :P
08:02:10 <smoge> well, insede PKGBUILD there is --enable-shared
08:03:15 <rostayob> smoge: what PKGBUILD? we're talking about directory
08:03:27 <smoge> haskell-directory PKGBUILD
08:03:36 <smoge> made with cabal2arch
08:03:42 <smoge> so confusing...
08:03:58 <tjgillies> is every function in haskell a higher order function?
08:04:05 <monochrom> no
08:04:09 <smoge> I get this with every PKGBUILD:
08:04:09 <smoge> Setup: <command line>: can't load .so/.DLL for: HSdirectory-1.0.1.2 (libHSdirectory-1.0.1.2.so: cannot open shared object file: No such file or directory)
08:04:18 <tjgillies> what is an example of one that nots?
08:04:25 <tjgillies> thats not*
08:04:26 <hpc> tjgillies: legnth
08:04:31 <hpc> ...length
08:04:34 <monochrom> f () = ()
08:04:55 <tjgillies> thnx
08:05:04 <Axman6> tjgillies: higher order functions are functions that take other functions as arguments
08:05:12 <Axman6> so map is ahigher order function, but sum isn't
08:06:00 <hpc> tjgillies: the type of a plain boring function is something like (a -> b)
08:06:03 <tjgillies> so essentially any function that only takes one argument isn't
08:06:12 <rostayob> smoge: btw, I've installed haskore now and it works
08:06:16 <hpc> tjgillies: the type of a higher order function looks like ((a -> b) -> c)
08:06:22 <Axman6> tjgillies: no...
08:06:27 <Axman6> :t map
08:06:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:06:32 <Axman6> :t (+)
08:06:33 <lambdabot> forall a. (Num a) => a -> a -> a
08:06:41 <smoge> damn, what am I doing wrong???
08:06:55 <Axman6> map is a higher order function because it take another function, (+) isn't because it doesn't take functions*
08:07:02 <rostayob> smoge: I don't know, it's easily to mess up things. try to re install directory
08:07:10 <smoge> I did with cabal
08:07:12 <hpc> *depending on what you consider to be a Num
08:07:13 <Axman6> (* it could if there were the appropriate Num instance)
08:07:15 <smoge> with cabal2arch it does not work
08:07:27 <rostayob> smoge: you can't install haskell-directory with cabal2arch?
08:07:28 <hpc> **but that's evil and not for beginners
08:07:34 <smoge> no...
08:07:50 <monochrom> "we need to go deeper" XD
08:08:06 <smoge> I get this: Setup: <command line>: can't load .so/.DLL for: HSdirectory-1.0.1.2 (libHSdirectory-1.0.1.2.so: cannot open shared object file: No such file or directory)
08:08:13 <smoge> with makepkg
08:08:35 <rostayob> smoge: yeah but that seems to be related to the thing you're trying to install
08:08:54 <Axman6> tjgillies:  f () () = () isn't a higher order function
08:08:59 <tjgillies> Axman6: (+) can be read as a->(a->a)
08:09:08 <tjgillies> which returns a function
08:09:19 <Axman6> tjgillies: that';s got nothing to do with being a higher order function, that's currying
08:09:35 <monochrom> my () functions has caught on \∩/
08:09:36 <rostayob> Axman6: well a function that returns a function is a higher order function
08:09:51 <Axman6> hmm, true i guess
08:09:58 <tjgillies> anything that takes a function or returns a function is higher order
08:10:08 <rostayob> so yeah, (1 +) is an higher order function
08:10:17 <rostayob> no sorry
08:10:52 <rostayob> I mean if you use it partially, it is an higher order function I guess.
08:10:56 <hpc> tjgillies: not sure if it is just a haskell thing, but we only consider a function higher-order if it TAKES a function
08:11:02 <hpc> or what rostayob said
08:11:16 <tjgillies> thats only a haskell thing
08:11:36 <tjgillies> http://en.wikipedia.org/wiki/Higher-order_function
08:11:53 <rostayob> but reasoning like that, every function with more than one argument is higher order in haskell, since a -> b -> c == (a -> b) -> c and so on...
08:12:04 <tjgillies> rostayob: thats what i was asking
08:12:05 <rostayob> boh
08:12:08 <monochrom> well, we are certainly allowed to focus on haskell in #haskell...
08:12:38 <Axman6> rostayob: i think you mean a -> b -> c = a -> (b -> c)
08:13:23 <rostayob> it's just a matter of terminology I guess. in haskell calling higher order just those functions makes more sense I guess 
08:13:29 <monochrom> oh let's ask dolio to arbitrate!
08:13:47 <monochrom> dolio: I have a function of type ()->()->(). is it a higher-order function?
08:14:04 <rostayob> Axman6: right
08:14:45 * Axman6 would say technically yes, but it's not vwrt interesting in haskell, and is happy to use HOF to refer to functions that take other functions as arguments in haskell
08:15:44 <monochrom> yeah, definitions are invented for convenience, not discovered from a platonic plane
08:15:54 <dolio> monochrom: It depends on a technicality of your definition. I'm not sure which is more widely accepted.
08:16:12 <monochrom> thanks dolio
08:16:53 <dolio> At a guess, I'd say most people take "higher-order" to be functions on the left of an arrow, but not the right.
08:17:02 <Axman6> if returning functions is all that's needed for a language to support HOFs, then even C supports HOFs
08:17:11 <Axman6> sort of
08:17:24 <rostayob> Axman6: C does support hof, with function pointers
08:17:40 <rostayob> both in the sense of taking functions as arguments, and returning functions
08:18:53 <dolio> Similar to how (forall a. a) -> b is higher rank, but a -> (forall b. b) is not. Although, there's an explanation for that.
08:18:53 <Axman6> yeah, realised that after i hit enter =)
08:19:22 <rostayob> you can even hack closures in C! ehe
08:21:23 <Axman6> I'd rather not hack and just use Apple's block implementation
08:22:02 <rostayob> Axman6: what's that?
08:22:25 <Axman6> http://en.wikipedia.org/wiki/Blocks_(C_language_extension)
08:22:25 <rostayob> and it's not to bad anyway: https://gist.github.com/913530
08:22:43 <Axman6> basically closures in C, which are quite easy to use
08:23:12 <Axman6> they've provided some very nice functions for using them for simple parallelism, and other such things
08:23:46 <rostayob> Axman6: yeah that thing I linked uses gcc nested functions, which is a similar thing.
08:24:23 <Axman6> similar, but blocks have the same scope as where they're created, which i
08:24:32 <Axman6> I'm not sure nested functions do*
08:24:53 <rostayob> Axman6: i'm not sure either, I'd rather avoid using closures in C anyway
08:25:05 <rostayob> I mean I'd rather write standard C
08:25:13 <tjgillies> or objective c ;)
08:25:21 <Axman6> I'd like this to become standard =)
08:26:01 <rostayob> Axman6: I don't see that happening. I'm sure that's kind of hacky to implement
08:26:18 <tjgillies> all standard means is that a few offical looking blokes get together and say, 'its official'
08:26:24 <Axman6> well, Apple have already implemented it in GCC and LLVM/Clang
08:26:43 <tjgillies> llvm is a beautiful thing
08:27:06 <Axman6> indeed
08:27:23 <Axman6> so is clang, makes writing C so much more pleasant
08:27:37 <rostayob> Axman6: yeah I'm sure it *can* be done, but considering what functions are in C (they're not first class) I don't see that happening
08:28:45 <rostayob> It's too much of a shift for C, I'm not sure I'd like that to happen. C is one of the things that's good as it is :D
08:29:29 <Axman6> from what i understand it's a fairly minor change really. it's functions pointers with a little bit extra
08:30:08 <rostayob> Axman6: no, because as you said, blocks share the scope in which they're created
08:30:39 <Axman6> oh well, the platforms i care about (OS 
08:30:49 <Axman6> OS X and FreeBSD) both support it, so I'm happy
08:31:21 <rostayob> yeah fair enough, as long as you write software for you, but you'll still be writing unportable code, which is a pity since C is really portable
08:31:49 <Axman6> heh, it's often not that portable at all
08:32:26 <rostayob> Axman6: usually it's not portable because you're working with platform-specific stuff, not because of an unportable language feature
08:32:40 <Axman6> I'm quite happy using things like OpenMP or pthreads by hand, but if I'm in a situation where I just want to make something run in parallel on OS X, then I'll use blocks
08:34:02 <rostayob> Axman6: ok ehe
08:34:43 <Axman6> I'm now also quite happy to use MPI for such things too =)
08:36:16 <copumpkin> ddarius: dolio and I are going to the MIT flea market if you want to join
08:42:53 <crystal-cola> how do generate the 2x2 integer matrices with determinant 1?
08:43:23 <aavogt> crystal-cola: they are rotations, right?
08:43:30 <crystal-cola> I don't know
08:43:51 <sipa> crystal-cola: solve the equation det(A)=1 :)
08:44:19 <sipa> for matrix [[a,b],[c,d]], that is a*d-b*c=1
08:50:59 <adamvh> pl (\x -> f x - x)
08:51:19 <adamvh> p1 (\x -> f x - x)
08:51:36 <siracusa> @pl (\x -> f x - x)
08:51:36 <lambdabot> (-) =<< f
08:51:51 <adamvh> Thanks siracusa
08:53:06 <td123> crystal-cola: took a small break
08:53:13 <td123> crystal-cola: I think I got it!
08:53:19 <crystal-cola> cool
08:54:27 <crystal-cola> what did you write?O
08:55:30 <adamvh> @src =<<
08:55:30 <lambdabot> f =<< x = x >>= f
08:55:44 <adamvh> @src >>=
08:55:44 <lambdabot> Source not found. My pet ferret can type better than you!
08:56:19 <rostayob> adamvh: >>= depends on the instance
08:56:30 <rostayob> it's a type class function
08:57:00 <adamvh> rostayob: I suppose it's implemented just for functions?
08:57:12 <adamvh> not "just"
08:57:26 <adamvh> I mean, function is an instance of Monad?
08:57:29 <rostayob> adamvh: mh? what do you mean? (>>=) is part of the Monad type class
08:58:10 <adamvh> Yeah, I wasn't expressing myself very well
08:58:23 <rostayob> adamvh: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Monad.html
08:59:39 <td123> crystal-cola: http://codepad.org/ECySZibj
08:59:46 <td123> crystal-cola: I'm almost there
09:00:05 <td123> crystal-cola: the function works with id as the continuation but now with show
09:00:15 <td123> s/now/not/
09:00:19 <crystal-cola> td123: cmap f xs id
09:00:22 <crystal-cola> sorry
09:00:37 <crystal-cola> this is a function application and you use its result directly
09:00:38 <crystal-cola> c $ f x : cmap f xs id
09:00:43 <crystal-cola> so that is not CPS
09:01:00 <crystal-cola> it should be written in the form  cmap f xs (\k -> ...)
09:01:07 <crystal-cola> where the ... part does the consing and passing to c
09:01:40 <crystal-cola> It's difficult to formally define the CPS grammar here,
09:02:00 <td123> :(
09:02:10 <td123> ok, I guess I'll skip cps for now
09:02:20 <crystal-cola> why don't you do it instead? You have almost written it
09:02:22 <td123> I'll continue reading the yaht
09:02:37 <td123> crystal-cola: ok fine
09:11:28 <td123> crystal-cola: cmap f (x:xs) c = cmap f xs (\k -> c ((f x) : k))
09:11:59 <crystal-cola> td123: that's almost it -- you have not got the type correct though
09:12:09 <crystal-cola> td123: You should CPS the type of f as well as cmap
09:15:03 <td123> I don't know what that means
09:15:15 <crystal-cola> see how you have f x
09:15:20 <crystal-cola> and that's the value
09:15:29 <crystal-cola> it should instead be  f x $ \k -> ... 
09:15:43 <crystal-cola> even "higher order" functions should be passing to continuations
09:16:10 <td123> oh..
09:16:17 <crystal-cola> look at the thrice example again for details
09:16:47 <crystal-cola> BTW once you get this you can probably CPS anything since this contains all cases of the transform
09:16:47 <td123> I see what you mean >.>
09:17:32 <td123> heh, 2nd day of haskell and I'm already doing CPS :)
09:17:46 <crystal-cola> :P
09:22:55 <HugoDaniel> hi
09:23:13 <Necrosporus> Which language is easier to learn, J or K at your opinion?
09:23:30 <HugoDaniel> H
09:23:51 <crystal-cola> J
09:23:58 <Necrosporus> crystal-cola, why?
09:24:09 <crystal-cola> because it's based on APL
09:24:10 <Necrosporus> What's the difference?
09:24:14 <Necrosporus> K is too
09:24:25 <crystal-cola> yeah but not as closely
09:24:57 <Necrosporus> Is there special function of square root on K?
09:25:14 <Necrosporus> Or only ^.5 would work
09:25:25 <td123> ah! APL was a cool language :)
09:25:49 <crystal-cola> yerah :)
09:25:51 <crystal-cola> -r
09:26:11 <crystal-cola> Necrosporus: maybe you find K easier though, I just like J better
09:26:12 <td123> if you want to impress ppl, show them your APL skills
09:27:47 <Necrosporus> +/I.(0 I. -. 5|i.1000) +. (0 I. -. 3|i.1000)
09:28:05 <Necrosporus> This one is the first program I wrote on J
09:28:18 <Necrosporus> I suppose, it's not very efficient
09:28:54 <Necrosporus> Do you know, how to make it shorter?
09:31:27 <td123> oh, apl programs were also fun to find shorter versions of
09:31:54 <td123> though I would have to revisit an apl tutorial to remember all the symbols and what they did
09:32:01 <crystal-cola> Necrosporus: you can write closed forms in terms of triangular numbers
09:32:22 <crystal-cola> e.g. 3 + 6 + 9 = 3*(1+2+3) = 3*T(3)
09:33:13 <crystal-cola> (but you need to subtract 15s)
09:33:18 <Necrosporus> I know, it can be reduced to just simple formula, computable on usual calculator
09:33:27 <crystal-cola> :/
09:33:32 <Necrosporus> But
09:33:41 <crystal-cola> don't ask to make the program shorter
09:33:48 <crystal-cola> then discard answers
09:34:13 <Necrosporus> Sorry, my question is not clear enough
09:34:44 <Necrosporus> T(3)
09:34:44 <Necrosporus> |value error: T
09:34:45 <Necrosporus> |       T(3)
09:34:48 <Necrosporus> However
09:34:52 <td123> ah, no function is supposed to return, that's why my previous declaration was wrong
09:35:01 <crystal-cola> Necrosporus: triangular numbers
09:35:35 <hpc> value error? are you using hugs?
09:37:49 <td123> this is getting rather messy.. but I think the statement "no function should terminate" gave me an "aha" moment
09:37:54 <smoge> what this means??
09:37:56 <smoge> Could not find module `Distribution.Simple':
09:38:16 <td123> my guess is that you don't have that module installed
09:38:19 <crystal-cola> td123: yeah that is some kind of catch phrase
09:38:24 <crystal-cola> i've heard that a lot
09:38:29 <Necrosporus> T=: +/1+i.
09:38:34 <Necrosporus> Doesn't seem to work
09:38:39 <crystal-cola> Necrosporus: +/ i.
09:38:53 <crystal-cola> +/ i. 5 = 1 + 2 + 3 + 4 + 5
09:38:54 <hpc> oh
09:39:00 <crystal-cola> 1 + 2 + 3 + 4 + 5
09:39:06 <crystal-cola> sorry I am mixing notations here
09:39:07 <smoge> what this means??
09:39:09 <smoge> Could not find module `Distribution.Simple':
09:39:31 <Necrosporus> crystal-cola, it's rather 0+1+2+3+4
09:39:37 * hackagebot state-record 0.0.1 - Better records for State monad states  http://hackage.haskell.org/package/state-record-0.0.1 (KarlVoelker)
09:39:51 <crystal-cola> Necrosporus: oh thanks! I was off by one
09:40:28 <Necrosporus> So, it's +/1+i.
09:40:38 <crystal-cola> Necrosporus: but use binomial coefficients
09:42:27 <Necrosporus> T=: x*(x+1)%2
09:42:39 <Necrosporus> Also doesn't seem to do what I wanth
09:43:23 <crystal-cola> You should do the tutorial
09:43:38 <Necrosporus> Where it is?
09:43:45 <crystal-cola> jsoftware website
09:43:59 <crystal-cola> lots of free books there
09:44:56 <td123> oh ya, jsoftware released j source under gpl or some other opensource licence didn't they?
09:45:05 <crystal-cola> td123: yes, it's great news!
09:46:02 <td123> hm, at the time I learned apl, I probably would have went with j if they were opensource
09:46:23 <crystal-cola> if you have any idea how to use APL you will pick up J no problem
09:46:45 <td123> great
09:46:48 <crystal-cola> it's basically just change of syntax and some refinements
09:47:54 <Necrosporus> crystal-cola, I thought, you are talking about some step-by-step tutorial. I know, where the vocabulary is
09:48:33 <crystal-cola> Necrosporus: http://www.rogerstokes.free-online.co.uk/book.htm 
09:48:44 <crystal-cola> Necrosporus: you only need to look at part 3
09:49:54 <td123> if anyone is interested, the j source code is at https://github.com/openj/core
09:50:03 <td123> I don't know if that's an official repo
09:50:58 <td123> the code looks like a top prize winner for some obfuscated C contest :P
09:53:00 <Necrosporus> td123, official is on jsoftware.com site
09:53:09 <Necrosporus> This one seem like a fork
09:54:03 <td123> they should probably say they unaffiliated with jsoftware then :/
09:54:44 <Mathnerd314> if I wanted to install linux + lots of haskell packages, which distro would be easiest to use?
09:56:21 <MasseR> Mathnerd314: Arch
09:56:36 <MasseR> Arch probably has the biggest amount of hackage projects in its repository
09:56:55 <MasseR> And there are afaik separate tools to cabal -> arch package
09:57:04 <Philonous> Can I toggle language extensions in a running ghci session?
09:57:53 <geheimdienst> MasseR: i tried the AUR haskell packages briefly, but i found them disappointing compared to cabal
09:58:24 <MasseR> geheimdienst: Wouldn't know about it. I ditched arch before starting haskell
09:58:44 <td123> MasseR: what do you use now?
09:58:49 <Philonous> Never mind, found it
09:58:50 <MasseR> Ubuntu 10.04
10:01:12 <crystal-cola> td123: The point of CPS is that you can take higher order programs (i.e. stuff with lots of lambda in it) and crush it down into completely first order (i.e. instead of passing a continuation you jump to a different location in source)
10:06:11 <Darkone> Uhhhmm lots of people here who are technical: Any of you on win7 or vista 64 bit, using a wireless dongle that has an Atheros driver? Trying to avoid the hell of searching for a version that doesn't bluescreen
10:06:59 <osoleve> if I have a structure [[String]], how do I apply a function to the Strings?
10:08:45 <mm_freak> osoleve: map . map
10:08:47 <monochrom> map (map f)
10:08:57 <osoleve> ah, thanks
10:09:01 <osoleve> makes sense
10:09:09 <Twey> A.K.A. fmap . fmap
10:09:10 <monochrom> > map (map show) [[1], [2,3]]
10:09:11 <lambdabot>   [["1"],["2","3"]]
10:09:14 <Twey> A.K.A. fmap fmap fmap
10:09:23 <monochrom> haha
10:09:35 <Twey> > fmap fmap fmap (+ 1) [[1, 2], [3, 4], [5]]
10:09:36 <monochrom> > fmap fmap fmap show [[1], [2,3]]
10:09:36 <lambdabot>   [[2,3],[4,5],[6]]
10:09:36 <lambdabot>   [["1"],["2","3"]]
10:10:09 <rothwell> 16 fmaps has quite an impressive type
10:10:27 <mm_freak> > (.).(.) (+1) [[1], [2,3]]
10:10:28 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:10:36 <mm_freak> > (.).(.)$(+1) [[1], [2,3]]
10:10:37 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
10:10:38 <Twey> @run fmap fmap fmap (+ 1) [[1, 2], [3, 4], [5]]
10:10:39 <lambdabot>   [[2,3],[4,5],[6]]
10:10:47 <mm_freak> > (.).(.) (+1)$[[1], [2,3]]
10:10:47 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
10:10:48 <Twey> @run unwords $ replicate 16 "fmap"
10:10:49 <lambdabot>   "fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap...
10:10:55 <Twey> @. type run unwords $ replicate 16 "fmap"
10:10:56 <lambdabot>     lexical error in string/character literal at end of input
10:11:08 <Twey> @. type run text . unwords $ replicate 16 "fmap"
10:11:10 <lambdabot> parse error (possibly incorrect indentation)
10:11:14 <Twey> Boo
10:11:36 <rothwell> http://hpaste.org/45768/16_fmaps
10:12:10 <Twey> That… what.
10:12:23 <Twey> 400 lines of type?
10:12:29 <rothwell> that's nothing!
10:12:55 <Twey> Maybe LoT should be the new unit of semantic complexity of Haskell code
10:13:04 <rothwell> hehe
10:13:10 <monochrom> hahaha that's awesome
10:13:24 <Dodek> hey, i'm writing a game ai and need to have some kind of two-dimensional array, representing game board. which data structure should i use?
10:13:35 <monochrom> how much time did ghci take to do that? :)
10:13:53 <rothwell> near instant, actually...
10:14:09 <TheZimm> lol
10:14:10 <Twey> Dodek: Sounds like a Vector
10:14:24 <Twey> Unless there's some smarter way to represent the board, like relationships between pieces
10:14:30 <Twey> Depends on your game
10:14:38 <mm_freak> > (.)(.)(.)(+1)((1:[]):(2:3:[]):[])
10:14:40 <lambdabot>   [[2],[3,4]]
10:15:25 <mercury^> mm_freak: why are you trying to confuse me? :(
10:15:49 <mm_freak> mercury^: sorry
10:15:51 <dmwit> Dodek: How about a two-dimensional array?
10:16:12 <Dodek> dmwit: how does one use them in haskell?
10:16:28 <mercury^> Everytime I see something like that, I am not satisfied until I figured out what exactly is going on. But because I am so bad at that I waste several minutes.
10:16:36 <dmwit> Dodek: The docs are here: http://hackage.haskell.org/package/array
10:16:52 <Dodek> dmwit: ok, thanks
10:16:52 <mm_freak> > foldM (flip $ \x -> zipWith (\l r -> l ++ x:r) <$> inits <*> tails) [] "abcd"
10:16:54 <lambdabot>   ["dcba","cdba","cbda","cbad","dbca","bdca","bcda","bcad","dbac","bdac","bad...
10:16:56 <dmwit> mercury^: nerd sniping =)
10:17:25 <longh> hi, is there a way to store cereal output in a cstring? ^^
10:17:49 <dmwit> > listArray ((0,0),(2,2)) "XXOOXXXOO"
10:17:50 <longh> (i.e. bytestrings, which contain NULLs)
10:17:50 <lambdabot>   array ((0,0),(2,2)) [((0,0),'X'),((0,1),'X'),((0,2),'O'),((1,0),'O'),((1,1)...
10:18:42 <dmwit> longh: You will need to store it in a string-length pair; the usual null-terminated C string simply Will Not Do.
10:19:15 <longh> yeah, but can I preprocess a bytestring in a way that it works?
10:19:43 <dmwit> And how to you plan to take a stream of 256-valued things and turn it into a stream of 255-valued things?
10:20:06 <Twey> zipWith (<*> tails) . (<$> inits) . fmap (++) . flip fmap . (:)
10:20:08 <dmwit> If you're using cereal, presumably you care about space...
10:20:24 <longh> I just need a way to store haskell objects
10:20:41 <longh> and the library which stores it does only accept cstrings
10:20:51 <TomMD> If you're using a computer, and not a theoretical turing machine, then presumably you care about space.
10:26:19 <longh> n*256 = m*255, should work...
10:29:47 <osoleve> if I have [String], how do I split the strings on numbers? I tried `map (split (whenElt isDigit)) strs`
10:30:47 <dmwit> > groupBy ((==) `on` isDigit) "123abc456def"
10:30:49 <lambdabot>   ["123","abc","456","def"]
10:31:02 <osoleve> thank you
10:31:33 <dmwit> It's a shame "equating" doesn't exist any more.
10:31:39 <dmwit> :t equating -- ...err, right?
10:31:40 <lambdabot> Not in scope: `equating'
10:31:53 <Jafet> Call in the equators!
10:36:01 <osoleve> map (groupBy ((==) `on` isDigit)) strs yields "Couldn't match expected type [Char] with actual type Char. Expected type: [String -> b0. Actual type: Char -> Bool"
10:36:04 <osoleve> :(
10:36:45 <dmwit> strs :: [String] -- ?
10:36:49 <osoleve> yes
10:37:02 <dmwit> > map (groupBy ((==) `on` isDigit)) ["a"]
10:37:03 <lambdabot>   [["a"]]
10:37:12 <dmwit> could not reproduce
10:37:24 <osoleve> hmm
10:37:59 <osoleve> @type splitOn "/" 
10:38:00 <dmwit> Are you double sure that strs :: [String]?
10:38:01 <lambdabot> Not in scope: `splitOn'
10:38:11 <osoleve> dmwit, trying to check that
10:38:51 <osoleve> it should be, yeah
10:39:35 <osoleve> i get strs by (strs = splitOn "/" str)
10:40:58 <dmwit> osoleve: str :: String -- ?
10:41:26 <osoleve> dmwit, yeah. those aren't the actual variable names, i just used those as examples because i thought it would convey types
10:41:34 <osoleve> i'll be more clear from here on out
10:41:44 <dmwit> osoleve: I'm asking you to double-check that str :: String.
10:42:10 <osoleve> it is, it's the param to the function
10:42:26 <dmwit> Why don't you paste some code.
10:42:33 <dmwit> Debugging it this way is like pulling teeth.
10:42:55 <osoleve> https://ideone.com/j6TYR
10:43:10 <osoleve> i'm having this issue with noteToSine
10:43:28 <osoleve> (there are probably more issues than that, i'm just working on this one now)
10:44:56 <dmwit> Surely you should just be doing a single map pair rather than a map (map pair).
10:45:32 <osoleve> i should? pair will be working with [[String]]
10:45:57 <accel> i want to write interactive javascript webpages
10:45:59 <accel> in haskell.
10:46:03 <accel> what should I look into?
10:46:20 <dmwit> osoleve: Right, and map (groupBy ...) strs :: [[[String]]]
10:46:43 <dmwit> accel: Julius, maybe?
10:46:56 <dmwit> accel: (Which is part of yesod.)
10:47:11 <dmwit> accel: ccasin has been doing some yesod recently and has nothing but glowingly positive things to say about it.
10:47:37 <osoleve> dmwit, that got rid of the type error, thank you.
10:47:46 <osoleve> could i bother you about one more? :3
10:48:05 <dmwit> Don't ask to ask, just ask.
10:48:35 <accel> dmwit: is the yesod book available as a pdf? I want to murder trees
10:49:02 <dmwit> <- no first-hand knowledge of yesod
10:49:23 <osoleve> line 46: Couldn't match expected type 'Double' with actual type '[Double]' Expected type [Double] -> [Double], actual type [Double] -> [[Double]]
10:49:35 <osoleve> in the return type of a call of `generateSoundWaves'
10:49:55 <accel> dmwit: the yesod philosophy looks very nice
10:50:01 <luite> is the yesod book available as pdf?
10:50:04 <osoleve> I thought the return type *should* be [[Double]] because i'm passing it to a function that takes [[Double]]
10:51:05 <accel> luite: when you find out, please leave me a msg via lambdabot
10:51:15 <dmwit> osoleve: generateSoundWaves ... :: [Double] -> [[Double]], so map (generateSoundWaves ...) :: [[Double]] -> [[[Double]]]
10:51:30 <osoleve> ohhh
10:52:43 <dmwit> osoleve: I would like to point out that you now have a single "map" at every single composition point. You should consider writing a function that takes a single chord (with no '/' in it) and simply map that whole damn thing over the split chord.
10:53:08 <luite> accel: I found one, but it doesn't look very haskelly ;) http://www.archive.org/details/kerenhayesodbook00paleuoft
10:53:09 <dmwit> Since map f . map g = map (f . g)
10:53:28 * hackagebot tuple-gen 1.1 - Generating all n-tuples without getting stuck in one infinity  http://hackage.haskell.org/package/tuple-gen-1.1 (TillmannVogt)
10:54:33 <accel> luite: don't know that haskell was the language of the ancients?
10:54:45 <accel> luite: All Monads lead to Rome
10:55:08 <TomMD> And all transformer stacks lead to IO.
10:55:33 <dmwit> Nuh-uh! Some lead to ST
10:56:29 * hackagebot grammar-combinators 0.2.5 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.5 (DominiqueDevriese)
10:57:22 <accel> how do I downooad the yesod screen casts? http://www.yesodweb.com/screencasts
10:57:24 <osoleve> dmwit, I appreciate your help, though I don't totally understand the last suggestion
10:57:30 <accel> how do I downooad the yesod screen casts? http://www.yesodweb.com/screencasts [I want to grab them for offline, stuck on a train, viewing]
10:57:54 <parcs> accel: are you on linux or windows
10:57:58 <accel> safari
10:58:01 <accel> but I have a lnux machine
10:58:02 <accel> right next to me
10:58:07 <accel> err, mac osx
10:58:12 <accel> safari is not an OS latst I checked
10:58:43 <dmwit> osoleve: Your function now has the form map buildChord . map generateSoundWaves . map getFreqs . map pair . map groupBy $ splitOn blah
10:59:01 <dmwit> osoleve: Why not consider doing map (buildChord . generateSoundWaves . getFreqs . pair . groupBy) (splitOn blah) instead?
10:59:28 <dmwit> osoleve: ...and splitting (buildChord . generateSoundWaves . getFreqs . pair . groupBy) into its own function, which is probably going to be useful elsewhere anyway?
11:00:08 <osoleve> i think i understand
11:00:24 <accel> holy fucking shit
11:00:28 <accel> what does cabal install yesod not depend on?
11:00:40 <dmwit> =)
11:00:45 <accel> my SSD is screaming ... WHY ARE YOU DOING THIS TO ME?
11:01:05 <parcs> accel: the website doesn't load for me, but i'd use cclive to download the videos from their respective providers (Youtube, vimeo)
11:01:24 <morphles> why sometimes in function type signature haskell will write i.e a -> a1, instead of say a -> b ?
11:01:25 <aristid> accel: if yesod was monolithic and not split into multiple packages, the SSD would not scream less.
11:02:25 <Jafet> morphles: because b is in scope and already taken by something else.
11:02:46 <accel> parcs: http://vimeo.com/14922583 <-- yesod video
11:02:56 <accel> parcs: cclive http://vimeo.com/14922583 <-- complains about some vimeo.lua file
11:03:19 <dmwit> morphles: GHC does its best to use the same names for type variables as are given in the type signatures for your functions. When it can't, it adds a number (rather than changing the name). So if you're using a lot of functions that use "a" in their type signatures...
11:03:38 <parcs> accel: that command works for me…
11:03:54 <accel> parcs: cclive http://vimeo.com/14922583
11:03:54 <accel> fetch http://vimeo.com/14922583 ...done.
11:03:54 <accel> error: libquvi: /usr/share/quvi/lua/website/vimeo.lua:57: no match: video id
11:04:06 <morphles> Jafet: "pairFs :: [a] -> (a -> a -> a1) -> [a1]" i dont have type siganutre defined in the module im working
11:04:16 <dmwit> morphles: (I've actually been very, very happy about this feature a few times when I was debugging code that actually used meaningful type variable names. "time", "time1", and "time2" make a lot more sense than "time", "timf", and "timg" would. =)
11:04:25 <Necrosporus> crystal-cola, do you know any book about K like that one about J?
11:04:37 <accel> parcs: can you send me a pm?
11:04:40 <parcs> accel: strange.. alternatively, vimeo provides download links to registered users
11:04:41 <Jafet> morphles: there was a type mismatch somewhere. Since you didn't give type signatures, ghc can't tell you exactly where it is, so it guesses.
11:04:59 <Jafet> (And if you try to give type signatures without ScopedTypeVariables...)
11:05:03 <crystal-cola> Necrosporus: no
11:05:15 <crystal-cola> Necrosporus: I'm not a fan of K
11:05:25 <Jafet> Sometimes I wonder why scoped type variables wasn't the default.
11:05:57 <morphles> but basically since a != a1 and b !=  a1; "a -> a1" in function type signature means same as "a -> b", or i miss something, and my understanding is wrong?
11:06:19 <dmwit> morphles: That is correct.
11:06:33 <Jafet> Not if a1 or b is already in scope and refers to the type of something else.
11:06:37 <morphles> so its jus haskell for some reason decided not to use b
11:06:44 <Jafet> Alpha substitution is a pain.
11:06:57 <dmwit> morphles: If you know the difference between a bound and free variable, then it might help you to read "a -> a1" as "forall a. forall a1. a -> a1", where "forall" is a binder.
11:07:03 <morphles> anyone here participate in project euler? :)
11:07:24 <morphles> no i havent yet read about bound or forall
11:07:34 <dmwit> Fine.
11:09:05 <accel> morphles: heard of it
11:09:16 <accel> morphles: it's that bi-math-progra-athaon right?
11:09:16 <morphles> its pure geek fun :D
11:09:34 <morphles> accel: something like that
11:10:10 <accel> fucking ain , installing boost-all-dev to compile cclive
11:10:12 <morphles> basicaly a list of math/programming puzless/problems that you solve 
11:10:20 <accel> today is "let's compile for fun" day
11:10:30 <accel> holy shit, yesod finished
11:10:31 <parcs> heh
11:11:08 <morphles> you only need to provide one number as answer in all problems, but its often imposible to use dumb/bruteforce algorithms to compute it since its infeasable, so you have to come up with good algorithms\
11:11:27 <accel> morphles: even with the powers of EC2?
11:11:27 <ccasin> accel: I haven't used much of Julius, but if it's anything like the other bits of yesod it will be great
11:11:36 <parcs> accel: i hope you know yesod 0.8 is slated to be released today
11:11:42 <morphles> accel: yes some definetly
11:11:42 <ccasin> also a new version of yesod is due out today so you may end up recompiling all that :)
11:11:53 <accel> ccasin: aren't you one of the core developers of yesod?
11:11:57 <accel> parcs: you're fucking kidding me right?
11:12:08 <ccasin> nope, I'm mostly a yesod newbie
11:12:09 <morphles> its easy to come up with computing problems that require ridiculous amount of computing power :)
11:12:16 <ccasin> I've just been using it a lot in the last couple of weeks
11:12:33 <parcs> accel: that's what the ML says
11:13:23 <accel> well, i hope it gets delayed :-)
11:13:30 <parcs> i dont!
11:13:51 <dmwit> You won't have to recompile everything. Only yesod.
11:13:53 <dmwit> yeesh
11:14:02 <accel> i can't find where the eysod binary is installed
11:15:00 <dafis> accel: try yesod instead of eysod? ;)
11:15:02 <accel> cabal install yesod
11:15:02 <accel> Resolving dependencies...
11:15:02 <accel> No packages to be installed. All the requested packages are already installed.
11:15:07 <accel> dafis: I did
11:15:21 <accel> i have a prog called "yes" installed
11:15:24 <accel> but not one called "yesod"
11:15:42 <dafis> accel: ~/.cabal/bin ?
11:15:45 <ccasin> accel: check your ~/.cabal/bin
11:15:58 <accel> ~/.cabal$ ls
11:15:58 <accel> config          config.platform
11:16:11 <dafis> uh-oh
11:16:43 <ccasin> perhaps your cabal is set to install system wide?  I don't know where the default location is in that case.
11:16:47 <dafis> accel: locate some-binary-you-installed-previously-with-cabal
11:16:48 <accel> ~/.cabal$ 
11:17:17 <accel> ~/.cabal$ ls /Library/Haskell/ghc-7.0.2/bin 
11:17:17 <accel> alex       cabal      cabal.real cabal.wrap happy
11:17:20 <accel> no yesod :-(
11:17:32 <accel> I'm going to go over to a corner and cry now
11:18:51 <accel> i'm wondering if maybe it failed silently
11:18:57 <accel> because there's some stupid C libarary
11:18:59 <accel> that I don't have instlaled
11:19:57 <dafis> accel: it should have said something, either "installing executable yesod in ..." or failed with an error
11:20:40 <accel> maybe this is a divine sign
11:20:44 <accel> that I should wait for yesod 0.8
11:21:23 <accel> ~$ locate happy | wc -l ; echo "###" ; locate yesod 20
11:21:23 <accel> ###
11:21:31 <accel> so happy is found
11:21:34 <accel> yesod is not :-(
11:22:41 <dafis> accel: locate will only find anything in its db, so unless you ran updatedb, it can't find it yet
11:23:10 <accel> i just did a updatedb
11:23:13 <accel> and i have an ssd
11:23:19 <accel> so updatedb is actually fast
11:23:22 <Lemmih> cabal install --reinstall yesod -v ?
11:23:36 <accel> Lemmih++
11:23:52 <accel> Readinv avaialble packages ...
11:23:55 <accel> Resolvin Ddependencies ...
11:23:59 <accel> holy shit output is fast, I can not keep up
11:24:09 <dafis> accel: redirect
11:24:57 <accel> /Users/x/Library/Haskell/ghc-7.0.2/lib/yesod-0.7.3/bin/yesod
11:25:08 <accel> someone should fire a msg off to the yesod developers
11:25:13 <accel> to have the binary instaled somewhere else
11:26:32 <rostayob> uh, they changed yesod website! it looks decent now
11:27:12 <accel> http://www.yesodweb.com/five-minutes is totally out of date
11:27:23 <accel> Start up your development server by running ./dist/build/devel-server/devel-server. (On Windows, use backslashes.) <-- LIES, such file does not exist
11:27:36 <accel> runhaskell devel-server.hs 
11:27:36 <accel> Please run: wai-handler-devel 3000 Controller withCNotes --yesod
11:27:40 <accel> wtf is wai-handler-devel ?
11:28:03 <rostayob> eheh in early stages docs are always outdated/wrong!
11:28:08 <morphles> :)
11:28:15 <morphles> ups sory wrong window
11:29:12 <accel> i bet it's a test
11:29:20 <accel> it's like "we only want competent people"
11:29:29 <accel> so we're going to subtly fuck up the insatllation / tutorial
11:29:32 <accel> so idiots give up
11:29:58 <accel> if I was running a project; I'd totally do that
11:33:42 <rostayob> accel: (:
11:34:54 <parcs> accel: wai-handler-devel is the preferred development server for WAI apps
11:35:24 <parcs> it automagically recompiles code when it detects a change
11:37:52 <accel> parcs: how do I get wai-handler-devel?
11:38:01 <mm_freak> accel: cabal install wai-handler-devel
11:38:02 <parcs> accel: cabal install wai-handler-devel
11:38:08 <parcs> curses
11:38:46 <accel> see, these evil developers
11:38:56 <accel> they're clearly biased against people (like me) who don't know how to use google
11:39:15 <mm_freak> well, documentation suffers a bit, but on the other hand i see that yesod is constantly improved
11:39:45 <accel> it's a nice threat to keep people focused
11:39:52 <accel> "if you don't keep up with the mailing list; you'll get left behind"
11:39:59 <accel> "and make a fool of yourself asking for help on #haskell"
11:40:25 <mm_freak> accel: once you got the general concept of yesod, for which the current documentation is fine, you can learn the rest by looking into the haddock docs
11:40:29 <rostayob> why didn't I know this: http://hackage.haskell.org/package/acme-dont ?
11:41:03 <accel> mm_freak: bah; I'll learn the rest by reading the fucking source code
11:41:12 <accel> and if that's not good enough, I'll finish off by submitting code to yesod
11:42:54 <Mathnerd314> rostayob: because hackage is a big place?
11:43:00 <accel> Could not find module `Yesod': Use -v to see a list of the files searched for.
11:43:03 <accel> FUCK
11:43:16 <rostayob> accel: getting angry won't help :D
11:43:22 <osoleve> accel, restart GHCi?
11:43:24 <accel> i fucking hate this new haskell platform on the mac
11:43:32 <accel> it seems to have installed everything in the wrong place
11:43:36 <rostayob> Mathnerd314: such a useful package
11:43:49 <rostayob> accel: well, you bought a mac...
11:43:52 <rostayob> don't complain
11:44:32 <accel> http://hpaste.org/45772/yesod_error
11:44:34 <Mathnerd314> rostayob: but you can't just write don't { ... }
11:44:34 <accel> I am sad
11:44:59 <rostayob> Mathnerd314: sadly, you can't
11:45:20 <rostayob> accel: did you install yesod?
11:45:24 <rostayob> ghc-pkg list
11:45:42 <mm_freak> accel: if you don't like yesod, try something else
11:46:00 <accel> ghc-pkg list | grep yesod
11:46:01 <accel> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
11:46:04 <rostayob> I don't think he managed to try yesod
11:46:07 <accel> ghc-pkg check
11:46:07 <accel> There are problems in package warp-0.3.3: dependency "sendfile-0.7.3-889829bb2e1b6750f22da87a610baf15" doesn't exist
11:46:15 <rostayob> accel: well, that explains it I guess
11:46:16 <accel> yesod-0.7.3 is insatlled, but apparently broken
11:46:28 <rostayob> reinstall warp and yesod
11:46:35 <Mathnerd314> rostayob: I view this as an extremely important bug in the Haskell language
11:46:54 <Mathnerd314> rostayob: people *need* their don'ts!
11:47:10 <rostayob> ehe
11:47:53 <Mathnerd314> also note that you see in other places like run*
11:47:53 <Mathnerd314> *see it
11:49:15 <accel> fuck, I think wai-handler-devel and yesod wants diferent versions of sendfile/warp
11:49:34 <accel> i'm going to wait for 0.8
11:49:46 <accel> parcs: please convey my msg of "please release 0.8" to the yesod devels
11:50:16 <rostayob> accel: you can have different versions of it
11:50:24 <rostayob> accel: and anyway, warp and yesod are meant to be together
11:50:34 <rostayob> so I doubt that they require conficting things
11:51:18 <rostayob> uh, you're right. they do require different versions of warp
11:51:35 <rostayob> but still, you can have different versions installed
11:52:04 <accel> rostayob: let us ask not "waht ist ehe problem", let us ask "what is the solution"
11:52:10 <accel> (besides waiting for yesod 0.8)
11:52:24 <rostayob> or you could simply use the git version of yesod
11:52:38 <rostayob> accel: I told you what's the solution
11:52:59 <accel> how do i have 2 versions of warp installed?
11:53:31 <TheZimm> >42
11:53:32 <rostayob> accel: with cabal you can have different versions of things installed. anyway, the best thing is just to install the git version i guess
11:53:35 <TheZimm> > 42
11:53:36 <lambdabot>   42
11:53:38 <TheZimm> :D
11:53:55 <TheZimm> lambdabot source
11:54:03 <TheZimm> :/
11:56:45 <rostayob> accel: anyway, all haskell web framework are not "ready" like you would expect. so if you get irritated that easily, I'd suggest to wait 2 years.
11:58:57 <TTimo> ok macro time
11:59:37 <TTimo> well .. preprocessor even
11:59:49 <rostayob> TTimo: TH! ehe
12:07:32 <Berengal> So, how about them first-class modules?
12:26:47 <RichardO> Is there a more canonical way to this pattern? http://hpaste.org/45775/reader_writer_stack
12:29:17 <c_wraith> Not really.  There's RWS, but it should be used when you're using all 3.
12:30:05 <aristid> c_wraith: when you use 3 readers and 3 states, then replacing them all by one RWS might be worth it, no? :)
12:30:39 <c_wraith> oh.  if you are nesting readers/writers/states, it's often better to flatten the stack.
12:31:21 <RichardO> How do you flatten the stack?
12:32:27 <c_wraith> RichardO: one thing you can do is newtype your combination of ReaderT and WriterT so that you only have one layer visible in your types, and one function to call to execute the combination
12:34:56 <c_wraith> Oh, you can combine multiples of any of ReaderT, WriterT, and StateT by making the type they're storing a combination of the types the different layers were storing.  Of course, this only works if you can rewrite your code in terms of using the whole stack at all times, rather than in terms of sequential wrapping and peeling.
12:36:21 <RichardO> like this? http://hpaste.org/paste/45775/reader_writer_stack_annotatio#p45777
12:38:59 <Philonous> Is ''Typename considered to be a splice? 
12:39:20 <Philonous> Or is there another reason I can't use it in patterns?
12:40:01 <applicative> Berengal: what about those first class modules?
12:40:35 <Berengal> applicative: http://research.microsoft.com/pubs/67016/first_class_modules.pdf
12:41:08 <parcs> what is the difference between monads-tf and mtl?
12:41:27 <aristid> mtl uses fundeps
12:42:15 <aavogt> Philonous: considering you can get the same result with a guard or view pattern (which are a bit more noisy), the omission isn't that bad?
12:42:57 <applicative> Berengal: What became of that?
12:43:21 <aavogt> write a quasiquoter to desugar the ''Typename to   ((==) ''Typename -> True) :p
12:45:40 <Berengal> applicative: Nothing it seems like. The link just popped up on reddit and I found it interesting
12:47:05 <Philonous> aavogt: Yes of course. I was just not seeing the wood for all the trees. 
12:48:24 <Philonous> aavogt: But you can't splice in the view pattern (no splices in pattern positions. bummer.)
12:48:52 <aavogt> you can have   f [$q| random string |] = ...
12:49:01 <aavogt> where q :: QuasiQuoter
12:49:11 * aavogt thinks you can leave the $ off now
12:53:01 <osfameron> is quasiquatation a haskell/json technique
12:53:22 <aavogt> it has nothing to do with json as far as I know
12:53:39 <osfameron> ... or has the same author uploaded 3x libraries with the same misspelling without anyone correcting him?
12:53:53 <ddarius> applicative: It wasn't perfect so it wasn't implemented.  There are several "better" module system proposals including ones that provide first-class modules out there but no real victor.
12:54:32 <hpc> ugh, first class modules? how hard do they want compilation to be?
12:57:23 <dolio> OCaml has first-class modules now. We've got to keep up.
13:01:26 <tomh-> what can you do with first-class modules that you can't do now properly in haskell now?
13:01:32 <ion> But we have first-class IO!
13:01:44 <tomh-> -now
13:02:09 <Mathnerd314> tomh-: http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
13:02:46 <Mathnerd314> you can always work around it but it's ugly
13:04:26 <Mathnerd314> (in the poster's opinion)
13:05:06 <ddarius> Alice ML has had first-class modules for quite a while.
13:05:47 <kleinucopia> I have a function that I am mapping across a list, but the function calls some library routine that throws an exception in some cases.
13:06:12 <kleinucopia> I'd rather it gave me a Nothing, but I can't change it. Is there some way I can see where in the list the function barfs?
13:06:21 <osfameron> what config file formats do people usually use for haskell command line apps?
13:06:28 <ddarius> Mathnerd314: That's not about first-class modules.
13:06:41 <aavogt> @hackage spoon
13:06:41 <lambdabot> http://hackage.haskell.org/package/spoon
13:06:54 <Mathnerd314> ddarius: then what is it about?
13:07:04 <kleinucopia> aavogt: just what I was hoping for?
13:07:06 <ddarius> Mathnerd314: Functors in the ML sense.
13:07:13 <ddarius> I.e. parameterized modules.
13:08:06 <aavogt> kleinucopia: it's better to hope that the library function doesn't throw exceptions (or use a different function than, ex. head)
13:09:00 <kleinucopia> aavogt: heh, the function here is taking Twitter userIDs and trying to get information on the user, but some uids are not working.
13:09:12 <kleinucopia> in this case, I'm forced to figure out which ones fail and filter them out somehow.
13:10:00 <kleinucopia> spoon might not work here since I don't think the function is pure.
13:10:04 <aavogt> oh, so you're in IO already, so you could just use catch
13:11:10 <kleinucopia> aavogt: I confess I know nothing of haskell exception
13:11:14 <kleinucopia> I can show you the code.
13:11:34 <aavogt> @docs Control.Exception
13:11:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:12:05 <aristid> @docs Test
13:12:05 <lambdabot> Test not available
13:12:17 <aristid> oh, so it does some checking :D
13:12:23 <aristid> unlike @hackage
13:12:27 <dolio> Mathnerd314: First-class modules would be where modules are values, and can be contained in other types and such.
13:13:22 <kleinucopia> aavogt: http://hpaste.org/45778/twit
13:13:30 <ezyang> Anyone know of research for "laziness" types, e.g. types that help characterize how unevaluated types are? 
13:13:38 <kleinucopia> when I try to run the commented line at the bottom, that's when the exception hits
13:14:14 <dolio> ezyang: There's been some of that by GHC folks, I think.
13:14:16 <osfameron> how do I find out what value a "RecursionPredicate" is?
13:14:27 <ezyang> dolio: Oh! Even better :-) 
13:14:28 <osfameron> as required for System.FilePath.Find's find function?
13:15:14 <parcs> osfameron: http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html
13:15:23 <dolio> ezyang: For instance, Types are Calling Conventions.
13:15:28 <kleinucopia> aavogt: ignore the filter in the pipeline, that was a sanity check -- some UIDs barf, some don't.
13:15:28 <osfameron> parcs: yes.  that's what I'm looking at...
13:15:32 <osfameron> haskell docs make no sense :-(
13:16:06 <osfameron> oh, it's a "FindClause Bool"
13:16:10 <dolio> I think GRIN may have similar stuff, too.
13:16:11 <parcs> osfameron: click on the data type to go to its definition/source code
13:16:19 <parcs> click as deep as you need to go
13:16:41 <ezyang> dolio: Good one. 
13:17:31 <ezyang> The subject that brought this up was whenever I 'rnf' a value, I do a full traversal over it whether or not it's already been fully evaluated or not. 
13:17:40 <ezyang> This seems... poor. 
13:18:13 <Heffalump> ezyang: have you seen Max Bolingbroke's strict core proposal?
13:18:17 <ezyang> In particular, it means that you'll pay a performance cost of some multiplicative factor if you try to put strict data types together the obvious way. 
13:18:26 <ezyang> Heffalump: Sounds like good reading... 
13:18:44 <ddarius> ezyang: Solution, don't use rnf.
13:18:51 <ezyang> It's true :-) 
13:18:51 <osfameron> parcs: apparently I need to understand the State monad in order to be able to write a FindClause...
13:19:15 <copumpkin> ezyang: use rnf + some nasty closure inspection ;)
13:19:31 <ezyang> copumpkin: But that wouldn't work on deeply recursive data! 
13:19:39 <ezyang> unless you cache the information as a flag of some sort. 
13:19:57 <ezyang> osfameron: state monad's not too hard to understand 8) 
13:20:53 <ezyang> Oh, it looks like Bolingbroke's strict core proposal is the same as the previously suggested paper :-) 
13:21:21 <osfameron> ezyang: perhaps. I haven't got my head round it
13:21:25 <parcs> osfameron: there are some predefined values of type RecursionPredication (FindClause Bool) that you may use w/o understanding their underlying implementation
13:21:30 <parcs> i.e http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html#t:FindClause
13:21:41 <parcs> (oops, ignore the link)
13:21:48 <parcs> search for "always"
13:22:48 <jmcarthur> ezyang: i avoid rnf/deepSeq stuff as much as i possibly can. i prefer to use strict data types when i need any sort of deep strictness
13:23:34 <dolio> ezyang: I'm not sure how much handling of data types the strict core stuff does.
13:23:43 <osfameron> parcs: ah!  yes, that looks like I might be able to play with it, thanks
13:23:56 <dolio> But then, I'm not sure how much of anything does.
13:23:59 <ezyang> Also, does anyone here fundamentally understand why 'map' in a strict language has problems, whereas it's fine in a lazy language? 
13:24:14 <ezyang> dolio: Since all boxed types can be unevaluated, not much, I imagine. 
13:24:32 <jmcarthur> ezyang: what kind of problems?
13:24:42 <Twey> ezyang: I'm confused by your question.  Many strict languages have ‘map’.
13:24:45 <jmcarthur> are you sure you don't mean impure vs. pure languages?
13:25:00 <ezyang> jmcarthur: map in a strict language is liable to stack overflow problems. 
13:25:11 <ezyang> You can work around it by writing it in iterative style, but then you have to reverse the list at the end. 
13:25:35 <jmcarthur> makes sense
13:25:57 <ezyang> I sort of feel like this problem hits on something kind of deep, but I don't know what. 
13:26:18 <aristid> hmm. would it make sense to have types be strict by default, but have lists always be lazy?
13:26:29 <ezyang> Streams are pretty darn useful. 
13:26:31 <dolio> ezyang: Well, everything can be unevaluated. That's the point of giving evaluated and unevaluated things different types. But moving from lists to 'lists such that the first N cons cells have been evaluated, and the rest haven't' is potentially more awkward.
13:26:45 <jmcarthur> aristid: i doubt it
13:26:46 <Twey> ezyang: That's a list issue, not a map issue
13:26:54 <ddarius> aristid: No.
13:27:02 <Twey> You can have a map over some other sequence type, like an array or a doubly-linked list, and you don't have to reverse it
13:27:08 <jmcarthur> aristid: if anything, i'd rather have both lazy lists and strict lists
13:27:47 <aristid> jmcarthur: why?
13:28:14 <jmcarthur> because strict lists are useful when you want it to be fully evaluated?
13:28:22 <dolio> ezyang: map makes a 'tail call' in lazy languages, but not in strict languages.
13:28:37 <ddarius> ezyang: Personally, I believe that there is a duality between eager and lazy languages where lazy languages "leak" values and eager ones continuations, related to the duality in Filinski's symmetric lambda calculus.
13:28:47 <jmcarthur> aristid: because i hate rnf, i guess
13:28:52 <ddarius> dolio: No it doesn't.
13:29:09 <dolio> Yes it does. It's a tail call to the list constructor.
13:29:23 <c_wraith> jmcarthur: just having the typeclass in your signatures, in particular?
13:29:31 <ddarius> dolio: Well then so does the eager version.
13:29:32 <jmcarthur> c_wraith: no
13:29:56 <aristid> jmcarthur: heh. do you actually have a strict list type in your codebase?
13:30:25 <copumpkin> jmcarthur: no
13:30:29 <ezyang> dolio: I agree. I wonder if there's something in the middle that is easier to use. 
13:30:33 <copumpkin> there's been a lot of "nick: no" recently
13:30:44 <aristid> copumpkin: no
13:30:49 <copumpkin> aristid: liar!
13:30:53 <jmcarthur> c_wraith: i hate deepSeq because i think its presence indicates a lack of understanding about the evaluation properties of your code, and can potentially lead to even more confusion. better to have a strict data structure so that you can reason about it wherever that structure is used instead of having to understand the implementation details of unrelated functions that just happen to be consuming it
13:31:03 <dolio> ddarius: The truth takes longer to explain. :)
13:31:16 * ddarius recommends head-strict lazy lists.
13:31:16 <jmcarthur> aristid: i have reimplemented it a few times, yes
13:31:22 <ezyang> Twey: Ah yes, and indeed, ML makes using arrays a bit more pleasant :-) 
13:31:36 <ddarius> dolio: Because of all the misinformation that must be overcome.
13:31:45 <ezyang> ddarius: That's an interesting viewpoint. 
13:31:50 <jmcarthur> aristid: the trouble is that sometimes i want a spine-strict list, an element-strict list, or a both-strict list, depending on the situation. gets a little awkward
13:31:57 <monochrom> last time I said I had doubts on the meaning of tail call, people thought I was dumb. so I recommend you to not doubt the widely adopted syntactic (and pretty useless) definition of tail call.
13:32:14 <lispy_> Has code.haskell.org been down at all recently? I received an email from a takusen user saying they couldn't access a darcs repo on there, but it's up for me
13:32:20 <ddarius> monochrom: It's perfectly useful, it's just not the whole picture.
13:32:25 <aristid> jmcarthur: hmm. if it was possible to write [!a], you could get element-strictness for free :)
13:32:30 <ezyang> jmcarthur: I have the same feeling. There are so many ways you want strictness. 
13:32:47 <ezyang> Fortunately, element strict is not too difficult to fake. 
13:32:58 <jmcarthur> aristid: is that an actual type that would be typechecked?
13:33:10 <aristid> jmcarthur: no, it is a pseudo-code type
13:33:18 <dolio> It may be a type in Clean.
13:33:23 <jmcarthur> no i mean in your theoretical extension
13:33:26 <aristid> yes.
13:33:32 <lispy_> I've never seen anyone go to the trouble, but couldn't you also get the strictness you want via newtypes + smart constructors?
13:33:51 <ddarius> lispy: Yes.
13:33:51 <jmcarthur> lispy_: interesting idea
13:33:55 <ezyang> lispy_: Yes. And view patterns would go quite a way to make that way of programming not too umpleasant. 
13:34:01 <jmcarthur> i wonder if it would be convenient
13:34:02 <ezyang> *unpleasant. 
13:34:07 <ddarius> Incidentally, you can define a lazy list in terms of a head-strict list.
13:34:27 <aristid> ddarius: how?
13:34:31 <ezyang> ddarius: Hmm, I think I misunderstand what head-strict means? 
13:34:34 <dolio> [Lazy a]
13:34:38 <aristid> heh
13:34:43 <c_wraith> jmcarthur: I just realized http://creativelad.wordpress.com/2011/04/03/dctp-model/ was your post.  I just have one question about that model: how do you move from t=1 to t=2?
13:34:47 <aristid> newtype Lazy a = Lazy a?
13:34:49 <ddarius> ezyang: Head strict means strict in the elements.
13:34:56 <dolio> No, data Lazy a = Lazy a.
13:34:58 <ddarius> aristid: data not newtype.
13:35:01 <ezyang> ah yes, that's easy. 
13:35:03 <aristid> hmmm.
13:35:05 * ddarius usually calls it Box.
13:35:18 <jmcarthur> c_wraith: by "move" do you mean "delay"?
13:35:25 <jmcarthur> c_wraith: or do you mean "consume"?
13:35:42 <ezyang> Or you have things like lazy bytestring, where what you'd like is strict in chunks of N elements :-) 
13:35:54 <ddarius> If you did an indirect composite approach you could get any of those types of lists from one type, but working with indirect composites is tedious.
13:36:09 <c_wraith> jmcarthur: I mean "how do you ever get to a time that's not infinitesimally later?"
13:36:18 <ezyang> "indirect composite"? 
13:36:24 <monochrom> data LazyLazy a = Lazy (Lazy a)
13:36:47 <c_wraith> Huh.  the strict identity monad is done with data, the lazy identity monad is done with newtype
13:37:04 <copumpkin> monochrom: Lazy is a comonad!
13:37:16 <jmcarthur> c_wraith: i was thinking that in hand-wavy terms that would be one of the semantically inexpressible things reserved for the interpreter, similarly to how actual time stepping is also reserved for the interpreter in classic FRP
13:37:18 <ddarius> http://www.haskell.org/haskellwiki/Indirect_composite
13:37:36 <ezyang> Ooh, I see. 
13:37:46 <ezyang> Very useful idiom, though I can't say I've used it before :-) 
13:38:07 <TTimo> does ghc have trouble properly recompiling / relinking when some compile options or preprocessor directives change? sort of seeing that here
13:38:09 <monochrom> hahaha c_wraith
13:38:12 <copumpkin> use the functor fixed points, luke
13:38:12 <c_wraith> jmcarthur: ok, that actually does make sense.  Though it's a bit mind-bending, to say the least.
13:38:22 <ezyang> TTimo: A little, though it's been made better in recent GHC head. 
13:38:25 <ezyang> try -fforce-recomp 
13:38:32 <jmcarthur> c_wraith: it's *either* mind-bending or hand-wavy, and i haven't figured out which yet
13:38:34 <ezyang> (on Linux only, unfortunately :-) 
13:39:05 <jmcarthur> meaning it's hand-wavy until i can explain it :P
13:39:16 <TTimo> ezyang: ah ok .. not dreaming that up then .. ty .. am on 7.0.3 though .. isn't that pretty recent ?
13:39:31 <ezyang> Simon Marlow literally committed the patch for this last week. 
13:39:35 <TTimo> ah
13:39:45 <TTimo> bleeding edge yeh :)
13:40:12 <jmcarthur> c_wraith: actually, it occurs to me that time-stepping is expressible in relative-time classic FRP as time shifts
13:40:19 <ezyang> https://github.com/ghc/ghc/commit/814edf44433801e37318ce79082ac6991dbc87dd 
13:41:19 <ezyang> I feel like we need some sort of methodological breakthrough for laziness. 
13:41:36 <ezyang> Full laziness has allowed us to discover all the various ways laziness can be suefully applied, and now we need to reign in this espressivity. 
13:41:44 <ezyang> *usefully 
13:41:49 * ddarius misses this page: http://replay.waybackmachine.org/20061011032657/http://www.haskell.org/hawiki/CommonHaskellIdioms
13:42:29 <ezyang> i,i it's a wiki 
13:43:04 <ezyang> Another conjecture: data structures that need to be strict should also be unboxed. 
13:43:30 <ezyang> In particular, you don't care about cheap polymorphism in these cases. 
13:44:10 <Saizan> http://replay.waybackmachine.org/20060902155722/http://www.haskell.org/hawiki/RemoveCorrect <- why the y combinator version?
13:45:11 <ezyang> More stupid conjectures: could we desugar ML modules into associated types/etc.? 
13:45:29 <dolio> Yes.
13:45:51 <ezyang> Type errors might be kinda horrendous, but I think it would be a kind of neat trick to try. 
13:46:12 <ezyang> OK, now to do some real GHC hacking instead of conjecturing :-) 
13:46:15 <dolio> The opposite direction is probably better explored territory, though.
13:46:47 <dolio> Classes -> Modules = Modular Type Classes
13:46:48 * ezyang wonders if one could extract a paper out of the topic 
13:46:56 <dolio> Modules -> Classes = some Oleg e-mail somewhere.
13:47:03 <ezyang> heehee 
13:48:36 <ddarius> dolio: There are two papers on the latter now.
13:48:52 <dolio> Oh, nice.
13:49:08 <ezyang> ddarius: Cool. 
13:49:28 <lispy_> so, was code.haskell.org down recently?
13:49:43 <lispy_> I asked a bit earlier, but I didn't see any responses
13:53:57 <monochrom> I heard so from other people too. but up now.
13:58:27 <lispy_> thanks
13:58:31 <lispy_> I'll ask the person to try again
13:59:48 <eikke> is there any standard definition for something like: f a b = if a then Just b else Nothing ?
14:01:20 <dafis> eikke: guard a >> return b
14:01:44 <jmcarthur> :t guard
14:01:45 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:01:53 <jmcarthur> hmm... is there a guard for Alternative?
14:02:27 <jmcarthur> because then that could be expressed as    guard' a *> pure b
14:02:54 <jmcarthur> or maybe even   b <$ guard' a
14:03:25 <dolio> I don't think there is, but one could be written.
14:03:30 <lispy_> yeh
14:04:00 <osoleve> if I have a structure [["foo","bar","baz","quux"]], how do I pattern match against foo bar?
14:04:18 <lispy_> I'm terrible about remembering to use Applicative/Alternative/MonadPlus.  I really need to make a stronger effort to use them.
14:04:29 <jmcarthur> ("foo":"bar":_):_
14:04:43 <osoleve> thanks
14:07:24 <osoleve> oops, i think there's one more level fo nesting in the lists
14:07:31 <osoleve> so would I wrap that in ():_?
14:07:41 <jmcarthur> sure
14:08:04 <eikke> hmh, there seems to be some difference
14:08:17 <osoleve> i'm getting a parse error :/
14:08:26 <jmcarthur> hpaste it
14:08:32 <osoleve> i also tried (([x]:[y]:ys):_):_
14:08:55 <osoleve> http://hpaste.org/45782/parse_error
14:09:09 <sipa> osoleve: give an example of what you're trying to match
14:09:19 <jmcarthur> @check \p a -> (if p then Just (a :: Int) else Nothing) == (guard p >> return a)
14:09:20 <lambdabot>   "OK, passed 500 tests."
14:09:24 <jmcarthur> eikke: ^^
14:09:36 <osoleve> [[["A#","3"]]]
14:09:49 <eikke> jmcarthur: http://hpaste.org/45783/guard
14:09:54 <osoleve> sorry, let me paste the rest of the code for reference
14:10:14 <eikke> using decr' the code works, using decr tests fail
14:10:24 <osoleve> http://hpaste.org/45784/parse_error
14:10:27 <jmcarthur> eikke: you have your Just and Nothing cases switched from what you asked for earlier
14:10:33 <nikr> Hi, I've got a beginner question about Haskell's laziness... how does it avoid duplicating calculations?  Does it memoize lazy results?  Eg, in the following snippet ...
14:10:34 <nikr> http://hpaste.org/45779/laziness_memoization
14:10:55 <eikke> jmcarthur: oh my :( :D
14:10:56 <jmcarthur> eikke: if you want the switched behavior, use guard (not a) instead of guard a
14:11:23 <nikr> ... function f1 and f2 both "pull" on the first element.  Seems compute would get called twice.
14:11:39 <eikke> jmcarthur: of course. /me feels stupid :)
14:12:41 <jmcarthur> nikr: (\x -> x+x) (2*2)   ==>   let x = 2*2 in x+x   ==>   let x = 4 in x+x   ==>   8
14:13:07 <jmcarthur> nikr: the "let" is being used to indicate sharing in memory
14:13:21 <jmcarthur> nikr: it's represents a single place in memory where the reductions are formed in place
14:13:24 <jmcarthur> *it
14:13:45 <jmcarthur> s/formed/performed/
14:14:11 <eikke> one more: I got a data type with constructors Left and Right (not related to Either), and those need to be mapped to '-1' or '1', any non-pattern-match way to achieve that?
14:14:20 <jmcarthur> :t either
14:14:21 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:14:52 <jmcarthur> :t either (const (-1)) (const 1)
14:14:53 <lambdabot> forall a a1 b. (Num a) => Either a1 b -> a
14:15:08 <man> Hello, haskellers!
14:15:17 <eikke> jmcarthur: but my Left and Right are not related to Either (there's no value)
14:15:28 <man> I have a problem with the http-enumerator library... could someone help me, please?
14:15:54 <jmcarthur> eikke: then use Bool :P
14:16:16 <man> I've encountered the HttpParserException "End of chunk newline", and dunno what it means.
14:16:33 <eikke> jmcarthur: nah, Bool is not descriptive
14:16:35 <jmcarthur> eikke: you mean this is a data type you made yourself? if so then you are of course responsible for defining combinators on it
14:16:44 <nikr> jmcarthur: Okay, so how does that work with parallel computation (two threads).  Might they both try the same reduction at the same time?  
14:16:49 <eikke> jmcarthur: indeed
14:16:59 <jmcarthur> nikr: in GHC is it possible, but not harmful
14:17:14 <jmcarthur> nikr: the result would be that both threads write the same result to the same location
14:17:21 <jmcarthur> nikr: it's also unlikely
14:17:37 <nikr> Okay, so the write is atomic and worst case you get that duplicated effort.
14:17:49 <jmcarthur> well, it's not atomic, but it doesn't have to be
14:17:54 <TTimo> ouch .. the new ghc platform release on OSX doesn't seem to support concurrency .. either that or the compile and execute options need to be different from 7.0.3 on Linux ..
14:18:04 <jmcarthur> it's *usually* atomic, unles things are timed *just right*
14:18:08 <jmcarthur> *unless
14:18:19 <lispy_> TTimo: doesn't support concurrency?
14:18:49 <ezyang> Since we do blackholing, the chance of a lost race is vanishingly small. 
14:18:51 <nikr> jmcarthur: if the update to that memory location is not atomic, couldn't a 2nd thread read something bogus and die?
14:18:54 <dolio> nikr: Evaluation is deterministic, so even if two threads are evaluating the same thing, they will arrive at and write back identical values.
14:19:04 <ezyang> In fact, I didn't even know there was a race here :-) 
14:19:08 <jmcarthur> nikr: oh, the actual write is thread safe, if that's what you mean
14:19:11 <jonas11235> hi all, I'm starting a pet project to learn some haskell, I create a module that should export some function and an empty data constructor (data ServiceExample = ServiceExample deriving Show). If I export all module and import all module it works fine but if I qualify the functions and data constructor in the export and import list I'm getting a 'not in scope: data constructor ...'. How should I put it?
14:19:20 <TTimo> lispy_: meaning .. I'm running +RTS -N4 like I do on Linux, but I am not seeing multiple OS threads being spawned out, and my timings suggests it's really on a single hardware execution thread
14:19:36 <nikr> jmcarthur: yeah that's what I meant to say.  Okay.
14:19:38 <jonas11235> I tried exporting exporting as ServiceExample(..) w/the same results
14:19:39 <dolio> As long as, say, pointer writes are atomic.
14:19:40 <jmcarthur> nikr: still not atomic though. it performs a write saying that it's being computed and then performs another write with the result
14:19:55 <TTimo> going to run a few more things to confirm though
14:20:05 <nikr> ah, okay
14:20:26 <jonas11235> probably I'm  doing some silly mistake
14:20:28 <jmcarthur> it's a weak lock, you could say. it captures most attempts to do the same work twice but not necessarily all
14:20:43 <lispy_> TTimo: hmm... and what does ./foo +RTS -info -RTS say?
14:20:50 <lispy_> TTimo: is it the threaded RTS?
14:21:22 <man> jonas11235: what do you mean by "if I qualify the functions and  data constructor in the export and import list
14:21:42 <TTimo> foo being .. some empty main ?
14:21:54 <lispy_> TTimo: whatever your program is called
14:21:58 <jonas11235> man: module MyModule and importing w/ import MyModule it works
14:22:02 <nikr> jmcarthur: thanks for the explanation.
14:22:20 <man> jonas11235: yes, that's exporting and importing all.
14:22:40 <man> jonas11235: have you tried exporting all, importing qualified?
14:22:56 <man> jonas11235: if that works, then export what you want.
14:23:03 <jonas11235> man: module MyModule (ServiceExample) and using import MyModule(ServiceExample) it doesn't work
14:23:13 <man> jonas11235: ah, of course.
14:23:24 <Anpheus_> What modules does lambdabot / pointfree have such that this works:
14:23:29 <man> jonas11235: you are exporting the type, but not the constructure...
14:23:29 <Anpheus_> @pl square x = x * x
14:23:29 <lambdabot> square = join (*)
14:23:45 <jonas11235> man: they have the same name
14:23:48 <man> jonas11235: use "module MyModule (ServiceExample(ServiceExample)) where"
14:23:58 <Anpheus_> That's using the ((->) a) instance of applicative, right?
14:24:01 <jonas11235> man: oh
14:24:05 <Anpheus_> But I can't find where join is defined
14:24:07 <man> jonas11235: it does not matter the name, they are different kind of animals :O
14:24:12 <Anpheus_> Or where I can get that to work in *my* code
14:24:27 <TTimo> lispy_: http://hpaste.org/45787/problem - it doesn't print anything ..
14:25:02 <jonas11235> man: I tried ServiceExample() and ServiceExample(..) let try the way you said
14:25:03 <lispy_> TTimo: weird!
14:25:31 <man> jonas11235: ServiceExample(..) should have worked, though.
14:25:34 <Mathnerd314> where is fileSize :: FilePath -> IO Integer?
14:25:47 <TTimo> I am using the 64 bit OSX haskell platform that was just updated 
14:25:53 <TTimo> guess I should go try the 32 bit
14:26:05 <parcs> @hoogle fileSize
14:26:06 <lambdabot> System.IO hFileSize :: Handle -> IO Integer
14:26:06 <lambdabot> System.IO hSetFileSize :: Handle -> Integer -> IO ()
14:26:09 <ddarius> @hoogle join
14:26:10 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
14:26:10 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
14:26:10 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
14:26:33 <Anpheus_> Right, but I can never get "square = join (*)" to compile
14:26:34 <lispy_> TTimo: it's --info I guess: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
14:26:46 <ddarius> @instances Monad
14:26:47 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
14:26:49 <jonas11235> man: it works now
14:27:03 <Anpheus_> oh you know what
14:27:06 <man> jonas11235: I'm glad!
14:27:11 <jonas11235> man: probably I made some other stupid mistake when I tried (..)
14:27:11 <Anpheus_> it works if I declare the type before-hand
14:27:14 <jonas11235> man: ty
14:27:14 <Anpheus_> that makes sense
14:27:21 <man> jonas11235: you're welcome.
14:28:20 <Anpheus_> actually no
14:28:21 <TTimo> lispy_: ah ok .. I updated the paste .. says yes to the important stuff 
14:28:24 <Anpheus_> I have no idea what's going on in ghci
14:28:28 <Anpheus_> if I do this:
14:28:34 <Anpheus_> let square :: Int -> Int -> Int; square = join (*)
14:28:45 <Anpheus_> I get "No instance for (monad ((->) Int))
14:29:04 <lispy_> TTimo: maybe report a bug then?
14:29:13 <aavogt> Anpheus_: import Control.Monad.Instances 
14:29:31 <Anpheus_> d'oh
14:29:37 <Anpheus_> it's not Int -> Int -> Int anyhow, it's Int -> Int
14:29:45 <Anpheus_> but that fixes the instance error
14:30:17 <Anpheus_> and now I can declare it without specifying a type as well, that's what I needed
14:30:18 <Anpheus_> Thanks!
14:32:57 <Anpheus_> Ok, that solves the last piece of the puzzle, I was trying to figure out where those instances were that allowed lambdabot to define (.) as fmap
14:33:09 <TTimo> lispy_: I think it's working fine actually .. the process tools I am using are not showing multiple threads, but reporting CPU at 200% etc. in my test cases .. I'll chalk that up to me not being much used to the way OSX represents that information
14:40:22 <td123> looking over the haskell library, couldn't the set operation Nub be naively implemented in nlogn time instead of the current n^2 time?
14:40:53 <jmcarthur> td123: not without requiring Ord
14:40:53 <aavogt> order matters sometimse
14:41:13 <BrianHV> could someone please explain to me the class declaration at line 47 of https://bitbucket.org/dibblego/haskell-course/src/57a00f8bebda/TicTacToe/haskell/Data/TicTacToe/Board.hs ?
14:41:14 <jmcarthur> aavogt: ordering could still be preserved by accumulating a Set without actually sorting the list
14:42:28 <adamvh> @pl (\x -> (N + 1) * (f x) - (f x) * ((f x) + 1))
14:42:28 <lambdabot> ap ((-) . ((N + 1) *) . f) (liftM2 (*) f ((1 +) . f))
14:44:07 <BrianHV> I suppose I could just give you the line rather than making you visit a web page... class Move from to | from -> to where
14:44:08 <td123> jmcarthur: ah, good point
14:45:14 <td123> jmcarthur: Ord a means that it has to have some way for it to compare (>,<,==) it to other vars of the same type right?
14:45:44 <osoleve> could someone help me out with the error at the bottom of this paste? it occurs on line 48. http://hpaste.org/paste/45789/parse_error_annotation#p45791
14:47:59 <aavogt> jmcarthur: how do you do that with a foldr?
14:48:31 <Mathnerd314> @type \x y -> Data.ByteString.Lazy.readFile x >>= Data.ByteString.Lazy.writeFile y -- does this work well as a copy operation?
14:48:32 <lambdabot> FilePath -> FilePath -> IO ()
14:51:08 <osfameron> I have a readFile failing because: hGetContents: invalid argument (Illegal byte sequence)
14:51:18 <osfameron> why should hGetContents care?
14:51:35 <jmcarthur> aavogt: it would be a left fold
14:51:36 <dafis> osfameron: because it tries to decode it
14:51:39 <osfameron> (it's a binary .swp file... so probably full of weird garbage)
14:51:40 <ezyang> Is it just me, or did the StackOverflow in the haskell tag spike recently? 
14:51:44 <osfameron> derrotebaron: decode it?
14:51:59 <osfameron> s/derrotebaron/dafis
14:52:07 <jmcarthur> aavogt: each step would be a query/insertion into the set
14:52:22 <dafis> osfameron: unless you set it to binary mode, it tries to translate the byte sequence into characters
14:52:24 <osoleve> ezyang, well, i posted like 3 in as many dys :B
14:52:26 <jmcarthur> oh hmm
14:52:29 <aavogt> > take 4 $ nub "abcdea"++undefined
14:52:31 <osoleve> s/dys/days/
14:52:31 <lambdabot>   "abcd"
14:52:54 <aavogt> > take 4 $ nub ( "abcdea"++undefined) -- what I actually mean
14:52:55 <lambdabot>   "abcd"
14:53:11 <ezyang> Oooh, I bet Don is going through and editing all the old post, and consequently filling up my RSS feed :-( 
14:53:14 <Hugglesworth> I'm stuck trying to convert from a String to a Lazy bytestring for hashing with sha
14:53:24 <osfameron> dafis: ah ok.  So I should either a) check if file is binary before attempting to read it, or b) recover from that error...
14:53:27 <Hugglesworth> I've been told to use fromEnum but It's not helping either
14:53:30 <osfameron> not sure how to do either ;-)
14:53:44 * osfameron closes the swap file to avoid the problem for now
14:53:58 <dafis> osfameron: you could read it as a ByteString
14:53:58 <Hugglesworth> Word8 seems to be where I'm having trouble converting
14:54:19 <osfameron> dafis: ok, how do I do that?
14:54:24 <dafis> Hugglesworth: pack ?
14:54:34 <sm> I think http://hackage.haskell.org/trac/ghc/ticket/4471 is still open with the latest GHC release (incorrect unicode output on windows console) - could anyone confirm ?
14:54:36 <Mathnerd314> @hoogle (String -> ByteString)
14:54:36 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
14:54:36 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
14:54:36 <lambdabot> Prelude read :: Read a => String -> a
14:54:47 <Hugglesworth> dafis: pack takes a Word8 list
14:54:59 <Hugglesworth> I'm having trouble getting from String to [Word8]
14:55:01 <dafis> osfameron: import qualified Data.ByteString[.Lazy] as BS; BS.readFile >>= doSomething
14:55:14 <dafis> Hugglesworth: Data.ByteString.Char8
14:55:41 <osfameron> dafis: ah, DB.readFile is a dropin replacement for the prelude one?
14:56:44 <dafis> osfameron: not dropin, it does something different, it reads the file as (a) chunk(s) of bytes
14:56:47 <osfameron> meh.  lines doesn't like bytestrings
14:57:01 <dafis> osfameron: split 10, or Char8
14:57:09 <Hugglesworth> dafis: ... alright, and how do I convert between different ByteStrings?
14:57:42 <dafis> Hugglesworth: Data.ByteString.Char8 is the same type, just a different interface
14:57:42 <jmcarthur> aavogt: here's a recursive version: http://hpaste.org/45792/ordnub
14:57:48 <osoleve> mmk, i'm going to jump in the shower and eat and i'll ask again later
14:58:24 <dafis> Hugglesworth: if you want to convert between strict and lazy, concat . toChunks resp. fromChunks . (:[])
14:58:25 <jmcarthur> aavogt: it's not a left fold. i was wrong. it's not just a right fold either though. maybe some sort of scan thing
14:58:26 <Hugglesworth> dafis: It's yelling about {Couldn't match expected type `Data.ByteString.Lazy.ByteString' against inferred type `Data.ByteString.Char8.ByteString'} though
14:58:35 <Hugglesworth> dafis: thanks
14:59:00 <aavogt> :t unfoldr (\(s,l) -> case l of x:xs -> Just (guard (x `S.notMember` s) >> Just x,(S.insert x s,xs)); [] -> Nothing) . (,) S.empty
14:59:01 <lambdabot> forall t. (Ord t) => [t] -> [Maybe t]
14:59:15 <dafis> Hugglesworth: you could also use Data.ByteString.Lazy.Char8.pack
14:59:31 <jmcarthur> aavogt: a scan that accumulates a set and a Maybe value, then a mapMaybes that drops the sets
14:59:32 <Hugglesworth> dafis: I am using Char8.pack
14:59:32 <aavogt> the unfoldr doesn't seem to have a way to say that you don't want to add elements
14:59:53 <aavogt> jmcarthur: I suspect you could write it as a foldr though
14:59:55 <jmcarthur> and it would be a scanl i guess
15:00:30 <dafis> Hugglesworth: strict or lazy though
15:00:32 <dafis> ?
15:00:54 <jmcarthur> i don't know if you can do it as a foldr
15:00:57 * jmcarthur tries
15:00:57 <Hugglesworth> ah, strict
15:01:30 <Mathnerd314> dafis: do you see anything wrong with: copy x y = Data.ByteString.Lazy.readFile x >>= Data.ByteString.Lazy.writeFile y
15:01:31 <dafis> Hugglesworth: so use Lazy.Char8.pack and you need not convert
15:01:36 <Hugglesworth> cool
15:01:48 <jmcarthur> aavogt: no i don't think you can. the accumulation has to be from the left
15:01:51 <Hugglesworth> dafis: thanks alot
15:01:54 <dafis> Mathnerd314: no, why?
15:02:08 <traviscline> best way to go from "123456" to [1,2,3,4,5,6] ?
15:02:08 <Mathnerd314> dafis: does readFile close the handle?
15:02:29 <dafis> Mathnerd314: when it's done it closes
15:02:54 <osfameron> what happens if you only lazily read the first few lines of the file?
15:03:00 <aristid> > map digitToInt "123456"
15:03:01 <lambdabot>   [1,2,3,4,5,6]
15:03:06 <aristid> ^ traviscline
15:03:14 <traviscline> ah thanks
15:03:14 <Mathnerd314> dafis: would using a strict bytestring and converting it to a lazy one be faster?
15:03:43 <dafis> osfameron: depends, if the compiler knows it's not used later, it may close it, otherwise it stays semi-closed
15:04:15 <dafis> Mathnerd314: for copying? probably not
15:05:50 <Mathnerd314> ok. I'm just really suspicious of lazy I/O right now ;-)
15:06:22 <dafis> Mathnerd314: it has some tricky spots
15:07:26 <jmcarthur> aavogt: catMaybes . snd . mapAccumL (\acc x -> if x `Set.member` acc then (acc, Nothing) else (Set.insert x acc, Just x)) Set.empty
15:10:11 <dolio> jmcarthur: It's an unfold.
15:10:56 <jmcarthur> dolio: yeah
15:11:38 <osfameron> right.  30 lines of Haskell should be enough for an evening's work :-) https://gist.github.com/924535
15:12:58 <dolio> @type let f (s, x:xs) = let s' = S.insert x s in Just (x, (s, dropWhile (`S.member` s') xs)) in unfoldr f . (,) S.empty
15:12:59 <lambdabot> forall a. (Ord a) => [a] -> [a]
15:13:25 <dolio> Oops, that should be "Just (x, (s', ..."
15:13:53 <aavogt> > foldr (\x xs b -> let xs' = xs (S.insert x b) in if x `S.member` b then xs' else x:xs') (const []) "abcdeeeeab" S.empty
15:13:54 <dolio> I missed a case on f, too.
15:13:54 <lambdabot>   "abcde"
15:14:25 <aavogt> > foldr (\x xs b -> let xs' = xs (S.insert x b) in if x `S.member` b then xs' else x:xs') (const []) "zabcdeeeeab" S.empty
15:14:26 <lambdabot>   "zabcde"
15:15:17 <aavogt> dolio: would it be a good idea to share the insert/member if this was possible?
15:15:52 <aavogt> jmcarthur: ^^ everything can be written with foldr!
15:17:02 <aavogt> I guess the insert isn't necessary to do when the element is already in the set
15:18:09 <td123> is there a sum function for tuples?
15:18:23 <aavogt> @hackage tuple
15:18:24 <lambdabot> http://hackage.haskell.org/package/tuple
15:19:02 <aavogt> hmm, no such function in that library
15:19:10 <aavogt> @wiki Template_Haskell
15:19:11 <lambdabot> http://www.haskell.org/haskellwiki/Template_Haskell
15:19:35 <applicative> td123, what do you want this sum to do?
15:19:54 <td123> applicative: I want to sum the elements ... oh
15:20:16 <td123> that probably wouldn't be nice since tuples don't require the elements to be the same :P
15:20:21 <td123> type
15:20:22 <aavogt> it's not straightforward because different lengths have differen types
15:21:03 <td123> I'll take a look at the Vec lib also
15:21:18 <td123> I'm going to need vector operations so that might be what I'm looking for
15:22:32 <aavogt> > getSum $ execWriter $ gmapM (mkM $ tell . Sum) (1,pi,5,5%2) :: Int
15:22:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:22:32 <lambdabot>         against inferred type ...
15:22:53 <ClaudiusMaximus> td123: http://hackage.haskell.org/packages/archive/Vec/0.9.8/doc/html/Data-Vec-Base.html#v:sum
15:23:12 <aavogt> > getSum $ execWriter $ gmapM (mkM $ \x -> tell (Sum x) >> return x) (1,pi,5,5%2) :: Int
15:23:13 <lambdabot>   0
15:23:23 <aavogt> > getSum $ execWriter $ gmapM (mkM $ \x -> tell (Sum x) >> return x) (1,pi,5,5%2) :: Integer
15:23:23 <lambdabot>   6
15:23:30 <aavogt> > getSum $ execWriter $ gmapM (mkM $ \x -> tell (Sum x) >> return x) (1,pi,5,5%2) :: Double
15:23:31 <lambdabot>   3.141592653589793
15:23:51 <osoleve> could someone help me out with the error at the bottom of this paste? it occurs on line 48. http://hpaste.org/45793/isdigit_error
15:23:54 <td123> ClaudiusMaximus: yup, that's the lib I'm talking about, haven't had a chance to check it out though, I'm still trying to bootstrap my haskell knowledge :P
15:24:10 <ClaudiusMaximus> i like Vec, but it's types scare the hell out of me
15:24:21 <ClaudiusMaximus> *its
15:24:26 <aavogt> it's really error prone if make mistakes like Int vs. Integer up there
15:24:46 <td123> oh
15:25:08 <aavogt> using the Data class that is
15:26:13 <ClaudiusMaximus> > break isDigit "blah42"
15:26:13 <lambdabot>   ("blah","42")
15:26:43 <osoleve> > break isDigit "blah42blah"
15:26:44 <lambdabot>   ("blah","42blah")
15:27:34 <osoleve> actually, given the preparations i make on the data before that, break isDigit should work
15:28:08 <accel> is any of gitit, orchid, and flippi usable? (looking for a wiki written in haskell)
15:28:24 <aavogt> osoleve: so add a type signature which will push the type error somewhere else?
15:29:26 <aavogt> accel: gitit works, it needs a bit of memory though
15:29:47 <aavogt> I'm not sure about the other ones
15:31:14 <accel> aavogt: are we talking 10s of MB, or Gigs ?
15:31:23 <ClaudiusMaximus> @type let pair (((x:y:ys):z):zs) = (x, read y :: Int) : pair ((ys:z):zs) in pair
15:31:25 <applicative> accel. I use gitit 'locally'
15:31:25 <lambdabot> [[[String]]] -> [(String, Int)]
15:31:34 <accel> applicative: that's what I plan to do too
15:31:38 <accel> i.e. a glorified todo list
15:31:48 <accel> but backed by git, written in haskell, and hyper linked
15:32:00 <accel> with mathjax thrown in, for TeX rendering
15:32:00 <eikke> whats the monad transformer library to be used nowadays? still mtl, or did something else pop up?
15:32:17 <osoleve> ClaudiusMaximus, that's the type I want it to have
15:32:22 <aavogt> accel: like 80-100 M when the site probably could be served with one tenth of that
15:32:49 <accel> aavogt: I can live with that
15:33:02 * accel is willing to close down youtube while using gitit
15:33:18 <ClaudiusMaximus> @type let f = undefined ; g = map (f . groupBy ((==) `on` isDigit)) undefined in f
15:33:20 <lambdabot> forall a. a
15:33:25 <applicative> accel right, that's what I do. it's nice.  I've never noticed any strain, but it's clearly no one of these three line perl wikis.
15:33:43 <ClaudiusMaximus> @type let f = undefined ; g = map (f . groupBy ((==) `on` isDigit)) undefined in (f, g)
15:33:44 <lambdabot> forall a b. (a, [b])
15:33:53 <ClaudiusMaximus> hm
15:34:13 <aavogt> then again, the wiki in question takes something like that amount of space on disk
15:34:16 <dafis> osoleve: but groupBy ((==) `on` isDigit) returns a [[Char]]
15:34:40 <applicative> aavogt, what wiki is this
15:34:40 <accel> applicative: blasphemy! the fundamental law of perl is that perl can, through breaking the laws of information theory, compress any N line perl program down to a 1 line perl program
15:34:52 <accel> gitit, I believe
15:35:02 <accel> cabal install need to be parallelized
15:35:11 <accel> I want to do cabal install - use all my 16 cores
15:35:34 <monochrom> cabal +RTS -N16 -RTS ...
15:35:46 <accel> are you kidding me?
15:36:37 <osoleve> dafis, i don't know what to do :(
15:36:41 <monochrom> it's probably not very useful anyway. the program doesn't forkIO or par all that much
15:36:45 <applicative> cabal: Most RTS options are disabled. Link with -rtsopts to enable them.
15:37:55 <applicative> if we had a proper module system we wouldn't need Cabal, cabal install, etc.  the language would already contain everything.
15:38:20 <lispy_> applicative: Um no.  Cabal isn't just for giving you libraries.
15:38:28 <lispy_> applicative: it does programs too, duh!
15:38:29 <accel> if haskell had a devent compiler, I wouldn't ahve to write code in haskell
15:38:33 <accel> I would start running the program,
15:38:40 <accel> and the compiler would lazily, on the fly, generate the rest of the program
15:38:42 <accel> as I needed it
15:39:00 <applicative> Cabal sorts out the heirarchy, no?  
15:39:04 <lispy_> Quick, someone change the /topic to sarcasm day!
15:39:30 <roconnor> monochrom: you awake?
15:39:33 <lispy_> how does cabal sort out the heirarchy?
15:39:50 <monochrom> am I awake? that's undecidable...
15:39:55 <roconnor> copumpkincan someone factor : or you
15:39:55 <lispy_> cabal is a means for describing haskell packages.  On top of that we have hackage and cabal-install.
15:39:58 <roconnor> ack
15:39:59 <accel> wtf
15:40:02 <roconnor> copumpkin: or you
15:40:02 <copumpkin> ?
15:40:03 <accel> why is recaptcha being installed?
15:40:04 <dcoutts> applicative: some aspects of package dependencies would be simpler I think if we did have a better module system
15:40:10 <monochrom> oh factoring! I'm awake yes!
15:40:19 * copumpkin races mono
15:40:21 <roconnor> monochrom, copumpkin: can one of you factor 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000266 for me
15:40:27 <copumpkin> wow
15:40:28 <copumpkin> that's big
15:40:35 <copumpkin> okay not prime
15:40:36 <roconnor> ya, it's a litte big
15:40:38 <tromp_> and even
15:40:41 <accel> how about 2^99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 ?
15:40:43 <roconnor> it is divisible by 6 if that helps
15:40:51 <byorgey> it fits EXACTLY in the number of columns on my screen
15:41:07 <ddarius> byorgey: You have a lot of columns.
15:41:08 <monochrom> 2*3*?
15:41:09 <Fuco> you sir are blessed with a nice screen :P
15:41:19 <byorgey> ddarius: I do indeed.
15:41:23 <copumpkin> > 6 * 592195611079901398522924962333874569719441380871953416116084911961457985952721672336785652456059871406894307015682350921088709867333384063758865529449243392963292828729221847128389688668285533661 * 281438537450051
15:41:24 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:41:30 <aristid> Fuco: or a small font.
15:41:35 <monochrom> will take a while because my program is running in a virtual machine
15:41:49 <Fuco> it would need to be 2px wide for me to fit on one line :D
15:41:52 <copumpkin> SMACKDOWN
15:41:59 <roconnor> copumpkin: is that the complete factorization (with high probability)?
15:42:00 <monochrom> well congrats
15:42:04 <copumpkin> roconnor: yep
15:42:07 <roconnor> thanks
15:42:09 <shachaf> > 6 * 1666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666667
15:42:10 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:42:12 <ddarius> Why are monochrom and copumpkin racing to factor numbers?
15:42:17 <copumpkin> ddarius: why not!
15:42:42 <Fuco> seems like someone has a spare quantum computer
15:43:10 <dolio> A proper module system automatically downloads modules for you from a web site?
15:43:47 <monochrom> yes it's a complete prime factorization (apart from the easy 6)
15:43:57 <applicative> dcoutts, of course.  i am only aiding and abetting no-proper-module-system hysteria.
15:44:11 <dcoutts> applicative: :-)
15:44:36 <applicative> dcoutts, it is the order of the day, you may have heard. 
15:44:58 <dcoutts> applicative: I'd certainly appreciate a better module system. A cabal-install project we're working on at the moment would certainly be simpler if the module system handled more of this stuff.
15:45:03 <aristid> dolio: among other things.
15:45:31 <dcoutts> applicative: this is the thing about "private" dependencies, having a package that uses a dep but does not expose anything from that package in its public interface.
15:45:45 <ddarius> dolio: With Alice ML you could easily write a function to do that.
15:46:13 <dolio> Yes, I believe that.
15:47:29 <osoleve> could someone help me out with this? it's really frustrating me. :(
15:47:30 <osoleve> http://hpaste.org/45793/isdigit_error
15:48:32 <monochrom> which line is that?
15:48:38 <osoleve> 48
15:49:29 <applicative> @type  groupBy ((==) `on` isDigit)) 
15:49:30 <lambdabot> parse error on input `)'
15:49:33 <monochrom> notes'' :: [String] is that right?
15:49:36 <applicative> @type  groupBy ((==) `on` isDigit)
15:49:37 <roconnor> monochrom, copumpkin: ah crap, I accidently gave you the wrong number
15:49:37 <lambdabot> [Char] -> [[Char]]
15:49:49 <copumpkin> o shit
15:49:53 * copumpkin revs up his engine
15:49:56 <roconnor> monochrom, copumpkin: I wanted (10^120 + 266)
15:49:58 <roconnor> much easier
15:50:00 <osoleve> monochrom, yes
15:50:06 <copumpkin> > 10^120 + 266
15:50:07 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:50:09 <ion> roconnor accudentally the wrong number. Is that bad?
15:50:29 <copumpkin> roconnor: that's pretty factorable
15:50:41 <roconnor> I hope it is
15:50:44 <copumpkin> http://snapplr.com/2s0k
15:50:52 <mauke> 2 3 281438537450051 592195611079901398522924962333874569719441380871953416116084911961457985952721672336785652456059871406894307015682350921088709867333384063758865529449243392963292828729221847128389688668285533661
15:50:58 <applicative> @type let pair (((x:y:ys):z):zs) = (x, read y :: Int) : pair ((ys:z):zs) in map (pair . groupBy ((==) `on` isDigit))
15:50:59 <lambdabot>     Couldn't match expected type `[String]'
15:50:59 <lambdabot>            against inferred type `Char'
15:50:59 <lambdabot>     In the second argument of `on', namely `isDigit'
15:51:08 <applicative> so it's all there.
15:51:32 <monochrom> 2 3 47 59 318023 938947 ?
15:52:36 <copumpkin> > 2 * 3 * 47 * 59 * 318023 * 938947 * 42364376876480910194807 * 4751146789111169845384250217206686906458475882944024838299195220157924537231900521
15:52:37 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:52:49 <monochrom> heh c program is faster than haskell program!
15:53:05 <copumpkin> zomg
15:53:34 <copumpkin> monochrom: I'm astounded
15:53:44 <copumpkin> roconnor: you could also just apt-get install qsieve
15:53:47 <roconnor> this integer factorization thing isn't has hard as people say :D
15:53:58 <roconnor> can i nix-env -i qsieve?
15:53:58 <copumpkin> okay maybe not apt-get
15:54:03 <copumpkin> I dunno, try :)
15:54:08 <copumpkin> msieve is also decent
15:55:02 <ivanm> roconnor: I found it interesting that most of the comments on proggit about your post were along the lines of "no, git is right!"
15:55:20 <copumpkin> there's proggit for you
15:55:48 <roconnor> ivanm: I think it is because people who agree with me don't post comments.
15:55:57 <ivanm> heh, yeah
15:55:59 <roconnor> $ nix-env -i qsieve
15:56:00 <roconnor> error: selector `qsieve' matches no derivations
15:56:21 <roconnor> $ nix-env -i msieve
15:56:22 <roconnor> error: selector `msieve' matches no derivations
15:56:28 <roconnor> I'll have to package qsieve later
15:56:37 <accel> fuck it, gitit is still compiling
15:56:42 <accel> it takes longer the leksah to build
15:56:47 <accel> and has more depenedencies than yesmod
15:57:01 <Mathnerd314> accel: what are you compiling it on?
15:57:11 <dafis> not speed
15:57:16 <accel> 13" macbook pro
15:57:18 <dolio> roconnor: Are you arguing about merge problems?
15:57:28 <Mathnerd314> accel: running max osx?
15:57:39 <roconnor> dolio: did you see my blog post?
15:57:43 <ivanm> dolio: http://r6.ca/blog/20110416T204742Z.html
15:57:47 <accel> Mathnerd314: ya
15:59:10 <accel> fuck, why is it building Text.Kate ?
15:59:13 <accel> this is so confusing
15:59:13 <dolio> roconnor: I've seen you bring it up before.
15:59:20 <roconnor> yes
15:59:26 <dolio> The same subject, that is.
15:59:29 <ivanm> accel: you're building pandoc with highlighting support? *shrug*
15:59:35 <roconnor> dolio: exactly the same
15:59:44 <ivanm> or that might be the "let's pretend we have highlighting support" module; can't recall
15:59:49 <accel> fuck. what's pandoc? I just want gitit
16:00:02 <Mathnerd314> accel: pandoc is the backend for gitit
16:00:38 <ivanm> @hackage pandoc
16:00:38 <lambdabot> http://hackage.haskell.org/package/pandoc
16:00:49 <Mathnerd314> accel: as you'd know if you read http://gitit.net/README
16:01:24 <ClaudiusMaximus> osoleve:           pair (xs:ys:zs) = (xs, read ys :: Int) : pair zs
16:01:25 <ClaudiusMaximus>           pair [] = []
16:01:36 <ClaudiusMaximus> i think that fixes it?
16:01:42 <ivanm> Mathnerd314: wait, what? people are expected to _read_ now? :o
16:01:43 <ivanm> :p
16:02:07 <Mathnerd314> ivanm: I know, it should be on Hackage
16:03:36 <nikr> Should this work?  Maybe I just can't find the module to import to get the Functor instance for Either...  fmap succ (Right 1)
16:03:53 <Mathnerd314> :t fmap succ (Right 1)
16:03:54 <lambdabot> forall a a1. (Enum a, Num a) => Either a1 a
16:04:08 <Saizan> Control.Monad.Instances i think
16:05:22 <nikr> Saizan: That did it.  
16:05:33 <nikr> How would I found that using haddocks?
16:06:01 <Saizan> you wouldn't, sadly
16:06:07 <Mathnerd314> you'd just keep asking #haskell ;-)
16:06:16 <nikr> Ha :)
16:06:27 <accel> ah
16:06:30 <accel> now it's building texmath
16:06:35 <accel> is there a way to tell my laptop:
16:06:40 <accel> tonight, while I sleep, compile all of ahckage?
16:06:59 <Mathnerd314> from your description, I think it already is
16:08:01 <parcs> accel: at
16:11:18 <dafis> accel: for package in `cabal list --simple-output`; do cabal install $package; done
16:11:30 <ivanm> you don't want to do that
16:11:38 <ivanm> a lot of them will clash, or just plain don't work anymore
16:12:02 <dafis> ivanm: but it will compile all of hackage ;)
16:12:09 <dcoutts> dafis: there's a better way to do that
16:12:17 <ivanm> dafis: I bet it won't, because at least one package won't compile!
16:12:32 <dcoutts> dafis: which is to do (more-or-less): cabal install `cabal list --simple-output`
16:12:46 <accel> text.pandoc.reader now
16:12:47 <accel> argh
16:12:51 <ivanm> e.g. there are a few packages that have over-restrictive deps and thus only work for old versions of GHC
16:12:51 <accel> this is taking fucking forever
16:12:52 <dcoutts> dafis: cabal install a; cabal install b  /=  cabal install a b
16:12:56 <Mathnerd314> ivanm: shouldn't there be someone going through the packages and making certain that they compile and aren't obsoleted by something else?
16:12:59 <accel> I want to go watch twilight until this finishes
16:13:05 <dafis> dcoutts: I know
16:13:08 <ivanm> Mathnerd314: not that I know of
16:13:28 <parcs> cabal list --simple-output | xargs cabal install
16:13:42 <Mathnerd314> ivanm: then what's the point of the maintainer field?
16:13:51 <dcoutts> parcs: no, it's important it's in one command only, not multiple.
16:14:00 <ivanm> Mathnerd314: someone to poke when you want to get something done
16:14:09 <ivanm> but just having a field there doesn't tell you anything
16:14:27 <parcs> dcoutts: it is in one command
16:14:51 <ivanm> parcs: isn't xargs a mapM equivalent?
16:15:12 <dcoutts> parcs: xargs will call the prog multiple times if needed.
16:15:13 <dafis> ivanm: no, it passes multiple args at once
16:15:27 <Saizan> it's a chunked mapM
16:15:37 <dcoutts> but if the number of args is bigger than the max command line length, it calls it multiple times
16:15:49 <parcs> ah, interesting
16:15:51 <ivanm> Saizan: ahhhh
16:15:58 <ivanm> so I've been misusing xargs all along...
16:16:18 <ivanm> who was writing bash equivalents of mapM, etc.?
16:16:51 <accel> text.pandoc.parsing
16:16:56 <accel> what is this, some patience torture test?
16:17:00 <accel> is cabal install the new chinese water torture?
16:17:07 <ivanm> accel: pandoc is big; get over it
16:17:13 <Mathnerd314> accel: go do something else
16:17:46 <Mathnerd314> accel: books, gardening, house cleaning...
16:18:14 <accel> eh
16:18:17 <accel> I'll go on irc instead
16:23:52 <eikke> > floor $ (1 / 0)
16:23:53 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:24:29 <shachaf> > ceiling (1/0)
16:24:30 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
16:27:04 <dafis> > decodeFloat (1/0)
16:27:05 <lambdabot>   (4503599627370496,972)
16:27:31 <accel> 2012 must be here
16:27:34 <accel> gitit finished compiling
16:28:50 * ivanm hopes accel never starts using a source-based distro
16:31:36 <Mathnerd314> is there some way to get a stack trace?
16:31:48 <Mathnerd314> or was that just a pipe dream?
16:32:30 <copumpkin> there was a paper on it
16:32:37 <copumpkin> but I'm not sure it ever got implemented
16:32:46 <dcoutts> there's something in the ghci debugger iirc
16:33:03 <Mathnerd314> that's history tracing, not stack tracing
16:33:22 <Mathnerd314> and it doesn't seem to mesh well with happstack
16:33:48 <monochrom> a mixture of pipe dream and impedence mismatch
16:34:22 <monochrom> do people in ##c ask "how to obtain a thunk trace?"?
16:34:57 <Mathnerd314> no, but they do ask "where is this $&%$ exception coming from?"
16:35:03 <mauke> unlikely
16:35:06 <mauke> C has no exceptions
16:35:16 <Mathnerd314> sorry, segfault
16:35:23 <accel> gitit: wikidata/.git/hooks/post-update: openBinaryFile: does not exist (No such file or directory)
16:35:26 <accel> what does that mean?
16:35:27 <monochrom> alright, so you should ask exactly that too. how to find exception causes
16:36:09 <monochrom> and a suitable history trace answers that, too. I don't see why it's rejected
16:36:13 <c_wraith> it means there's no post-update hook in that repo.  I know nothing about gitit, though
16:36:40 <Mathnerd314> monochrom: how so? it doesn't work with multithreaded programs
16:38:19 <monochrom> I take it that you're an expert in low-level machine code execution and you know the bare metal very well
16:39:16 <accel> hmm
16:39:20 <accel> how do I shut down gitit cleanly?
16:39:26 <accel> do I just ctrl-c gitit ?
16:41:00 <monochrom> happstack threads which are ghc threads might not even be OS threads to begin with
16:41:17 <Mathnerd314> monochrom: I'm an idiot who's trying to figure out why I'm getting "Server error: DeleteFile "%TMP%\\err11480": permission denied (The process cannot access the file because it is being used by another process.)" whenever I run gitit on windows
16:41:55 <Mathnerd314> if you have a wonderful method of determining where this comes from, please tell me
16:45:20 <c_wraith> hmm.  is gitit explicitly designed to support windows?
16:45:33 <c_wraith> because that kind of sounds like something that people do intentionally on non-windows
16:45:38 <monochrom> I don't have a wonderful method (or maybe I do but not guaranteed to work). but I know that insisting on stack trace is not a wonderful method, you would save a lot of time by forgetting it. there is no stack trace in the execution model of ghc-generated code
16:46:58 <c_wraith> monochrom, take out "stack trace" then, and just have all exceptions annotated with the source location of the call that results?  That would at least be better
16:47:30 * ddarius considers making an FRep CNC simulator.
16:47:44 <c_wraith> I guess that's not really tractable.
16:47:45 <monochrom> if you don't mind rebuilding all necessary libs and executables with profiling turned on (if they were not built so), there is a way the pros use: exename +RTS -xc
16:48:03 <monochrom> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/runtime-control.html#rts-options-debugging  then look for "-xc"
16:49:26 <monochrom> c_wraith: it is do-able but not yet done across-the-board. see Control.Exception.assert. has line numbers
16:49:59 <monochrom> nothing stops us from using the same trick for "error", other async exceptions, even IO exceptions
16:50:12 <ddarius> Someone should resurrect Buddha and extend it, in some way, to IO code.
16:50:25 <monochrom> but it is just not done.
16:51:11 <c_wraith> monochrom: I just meant that it's likely that in many cases, the line number will be useless.  say head is called on an empty list...  The message will tell you the error came from Data.List, in the call to head.
16:51:13 <monochrom> meanwhile, you can insert "assert" at interesting places to get the line numbers you want now
16:51:45 <monochrom> yes, but you can fight it by annotating the callers rather than callees
16:52:00 <ddarius> Yes, just make all partial functions CPP macros.
16:52:06 <paupau> is there an IRC channel around here for compiler implementation? (can't find an LtU channel for example)
16:52:24 <ddarius> LtU is not about compiler implementation anyway.
16:52:33 <monochrom> you have a million "head xs"s. change everyone to "assert (not (null xs)) (head xs)". annotate the call sites. now you know which call site triggers it
16:52:33 <Twey> monochrom: How does Control.Exception.assert do it?
16:52:47 <paupau> haha, true.
16:52:54 <c_wraith> ouch.  my use of sed isn't that good :)
16:53:20 <monochrom> I don't know how assert does its trick
16:53:27 <paupau> Wondering what makes SSA computation non-trivial such that all the dominance frontier stuff is required
16:53:36 <paupau> I'm guessing graph loops and gotos and things
16:53:53 <monochrom> to add more magic, if you compile with -O or above, the asserts are removed
16:54:11 <Mathnerd314> paupau: there's #compilers, but it's pretty empty
16:54:19 <paupau> oho
16:54:43 <Twey> Also, how about ‘import Prelude hiding (head); head = liftM2 assert (not . null) $ \(h : t) -> t’
16:54:57 <Twey> Or does that break assert-magic?
16:55:09 <monochrom> I used to be in the LtU channel. but now I don't even remember its name.
16:55:24 <Mathnerd314> #ltu
16:55:26 <paupau> oh whaddya know there is a #ltu
16:55:29 <monochrom> yes
16:55:31 <paupau> who wouldh ave thought
16:55:51 <paupau> I guess really the way to go is post on LtU
16:55:52 <dolio> I seem to recall the Buddha's author thought that some other Haskell debuggers had done better than him.
16:55:55 <paupau> But real-time!!
16:56:05 <dolio> I'm having trouble remembering which he thought were better, though.
16:56:58 <monochrom> nothing stops you from posting to both irc and website
16:57:13 <monochrom> multi-thread!
16:58:21 <ddarius> dolio: Maybe Hat which I didn't have the memory to build at the time.
16:58:31 <ddarius> That said, Buddha's approach was unique.
16:58:40 <Mathnerd314> monochrom: don't I have to link with -rtsops? how do I tell cabal to do that?
16:58:46 <dolio> Hat may be it.
16:59:09 <ddarius> And anyway, I wouldn't mind if someone resurrected Hat too.
17:00:38 <monochrom> ghc-options: -rtsops
17:00:53 <osoleve> @type splitOneOf "1234567890" $ splitOn "/" 
17:00:54 <lambdabot> Not in scope: `splitOneOf'
17:00:54 <lambdabot> Not in scope: `splitOn'
17:00:58 <osoleve> foo.
17:01:23 <dolio> Is Hat a declarative debugger? There doesn't seem to be a lot of information about it floating around.
17:01:29 <monochrom> I mean in the project.cabal file
17:01:54 <fryguybob> Mathnerd314: The error you pasted before looks like it would come from gitit's Network/Gitit/Export.hs line 202:  removeFile errPath
17:02:18 <ddarius> dolio: Hat is a tracer that will log the execution of a Haskell program and then let you replay that log.
17:02:18 <dolio> Oh, wait. Maybe I found something. Searching with "debugger" seems to have been a poor choice.
17:02:23 <monochrom> oh, there are --ghc-option and --ghc-options too for "cabal install" command line
17:02:23 <Mathnerd314> fryguybob: but I commented that line out and it didn't change
17:02:53 <monochrom> I think 'cabal install --ghc-option=-rtsopts ...
17:04:10 <dolio> ddarius: I guess that's similar to what Buddha allowed. It doesn't sound like a replacement or "better" to me, though.
17:04:13 <monochrom> is gitit meant to be run on windows to begin with?
17:04:14 <dolio> Then again, I've never used either.
17:04:23 <ddarius> paupau: The purpose of finding dominators is basically to rediscover lexical scoping.  Particularly, it corresponds to the lambda-dropping transform.
17:04:53 <ddarius> dolio: Buddha was interactive and was more goal directed.  Hat, though, was potentially more capabable.
17:05:34 <paupau> ddarius: Oh, interesting.
17:07:57 <monochrom> I would seriously consider this less efficient but more promising route: set up a virtual machine, set up linux inside it, run gitit there. ok, there is a daemon that accepts outside connections. set up the virtual machine software to forward outside connections to the virtual linux inside. (there are usually numerous ways)
17:08:58 <paupau> Cool, time to read this paper about lambda-dropping I guess
17:09:26 <elliotstern> I'm writing a simple AI for a board game I play, using a simple monte-carlo based approach.  Basically, the computer plays through a large number of random games, and chooses the move with the best win-rate.  In order to play the random games, it's useful to have a collection of the empty points to choose the random move from.  Basically, I'd like something with O(log n) indexing, addition...
17:09:28 <elliotstern> ...and removal.  I didn't see the indexing in Data.Tree.AVL or Data.Tree.  Any suggestion for packages for me to look at?
17:09:54 <elliotstern> Is there anything more efficient than the linked list that I should look at?
17:10:34 <monochrom> Data.Map or Data.IntMap
17:11:00 <monochrom> in other words key-value thing
17:11:37 <danharaj> hey, question. So if you want to associate a value to a type class instant, since it would be ambigious to have foo :: Bar in the class definition, so you use foo :: a -> Bar and pass it (undefined :: a) when you use it... is there a better way?
17:11:43 <monochrom> if you don't mind doing your own (i,j) -> i*n+j, Data.IntMap should be a very competitive choice
17:11:57 <applicative> http://i.imgur.com/t88vDl.jpg
17:12:02 <ddarius> danharaj: You could use the tagged package.
17:12:14 <danharaj> ddarius: thanks. I couldn't remember the name of the package :D
17:12:21 <parcs> i recommend Data.HashMap.Strict from unordered-containers
17:12:28 <monochrom> hahaha applicative
17:12:30 <ddarius> applicative: Your mother would be proud.
17:12:49 <monochrom> what were the original words?
17:12:59 <osoleve> okay, so let's say I have a string "A4/B#3", and I want to split it into [["A","4"],["B#","3"]]. how would I do so? I tried map (splitOneOf "1234567890") $ splitOn "/" to no avail
17:13:19 <aristid> monochrom: http://www.flickr.com/photos/clintjcl/3988064341/
17:13:27 <aristid> monochrom: google was very helpful there
17:13:36 <elliotstern> There's no key-value relationship here; are there any fast collections of single things?  This is essentially a [Point], but I'd like to use something more performant.
17:14:03 <monochrom> index:key :: element:value
17:14:35 <applicative> monochrom, as aristid notes.  
17:14:36 <monochrom> hell, index=key, element=value
17:14:55 <aristid> from "what were the original words?" to a link in 30 seconds. *pats himself on shoulder*
17:15:09 <applicative> aristid is a master, clearly
17:15:10 <paupau> android!
17:15:12 <ddarius> aristid: Your mother, too, would be proud.
17:15:26 * applicative is just annoyed that the original is no longer familiar
17:15:34 <aristid> ddarius: certainly
17:16:07 * ddarius wants to eat something but isn't sure what.
17:16:10 <aristid> applicative: it ever was familiar? well, google is familiar with it, isn't that good too?
17:16:18 <amalloy> elliotstern: sets are sometimes implemented as maps where the value associated with each key is simply the key itself. they're plenty fast that way
17:16:28 <aristid> ddarius: ice cream.
17:16:36 <osoleve> ddarius, choco taco
17:17:04 <elliotstern> amalloy: thanks
17:18:03 <monochrom> Data.Set or Data.IntSet then
17:18:38 <amalloy> monochrom: do you happen to know how those are implemented?
17:18:44 <monochrom> trees
17:18:46 <jmcarthur> balanced trees
17:19:11 <ddarius> amalloy: In pretty much the way you said.  Data.Set and Data.Map are very similar code-wise.
17:19:20 <ddarius> At times, they've even been the same code.
17:19:43 <jmcarthur> if it's the speed you need and not a mature API, i second parcs' recommendation to try unordered-containers, but if you want a richer API then stick with Data.[Int]Set
17:19:49 <elliotstern> The one problem is being able to get a random (as in data.random) element out.
17:20:20 <aristid> Set a being like Map a ()?
17:20:22 <monochrom> randomize moves not boards
17:20:52 <ddarius> aristid: Basically.
17:21:16 <monochrom> construct game tree by at every tree node: what are 5 random legal moves from here?
17:21:43 <elliotstern> Ah... the thing is that the empty points are pretty much my legal moves
17:21:47 <elliotstern> The game being go
17:22:12 <elliotstern> Some empty points aren't legal due to some sort of capture situation, but the vast majority of them are legal
17:22:27 <osoleve> was my method for splitting at least on the right track?
17:22:48 <ddarius> osoleve: I would parse rather than split.
17:23:03 <monochrom> add a proximity constraint. place a stone within distance 5 from some existing stone
17:23:48 <elliotstern> ugh, no, that would be terrible.  In the opening, most of the best moves are pretty far away from other stones
17:23:49 <monochrom> change "5" to "3.141592135..." if you like
17:24:01 <monochrom> use book openings
17:24:28 <osoleve> ddarius, so there isn't a simple way to split a list twice? :/ parsing is new territory for me.
17:24:28 <elliotstern> even so, that would lead to subpar play
17:24:57 <monochrom> give up randomization. apply for grad school in AI
17:25:01 <ddarius> osoleve: I don't see how that follows from what I said.
17:25:31 <elliotstern> Well, the the current best programs all use UTC, which is an extension of the Monte Carlo method
17:25:46 <osoleve> ...oh. okay.
17:26:23 <monochrom> then look into those programs for answers. I certainly don't know their answers
17:26:32 <parcs> osoleve: do something like map (groupBy isDigit)  . splitAt '/'
17:27:20 <elliotstern> Mostly, I'm just looking for the right haskell data structure to hold onto my candidate moves (i.e. all of the empty spots)
17:27:46 <elliotstern> Such that I can get out a random element, quickly.
17:28:37 <elliotstern> And also such that removal from the set is a reasonably cheap operation as well
17:30:49 <accel> anyone here got gitit to work with mathjax? I find jsmath and mathml ugly
17:31:27 <Mathnerd314> mathjax *is* jsmath / mathml, IIRC
17:31:41 <accel> no
17:31:51 <accel> MathJax is the successor to JsMath
17:31:57 <accel> and Gitit's MathML uses TexMath which produces ugly
17:32:03 <accel> MathJax produces beautiful math formulas.
17:33:30 <amalloy> elliotstern: for monte carlo, you don't really "need" to be able to get elements out in a uniformly-random way, do you? if a particular node gets sampled proportionally more or less often than others, it just means you'll have analysis that is better in some areas of the board and worse in others
17:35:03 <elliotstern> Not uniformly random, but with some level of randomness.  I mostly don't see a function from Collection a -> Int -> a for Trees and Sets, and that's the function I need
17:35:39 <jmcarthur> elliotstern: asymptotically, something like Sequence might be reasonable. O(log n) indexing, O(log n) splitting and concatenation, O(1) removal from head or tail. you could pick a random index, split the sequence at that index, extract and remove the head of the second sequence, then concatenate. the constant factors here might be pretty high though
17:35:51 <accel> okay; I just made changes to gitit
17:36:00 <accel> how do I tell cabal "take this current directory, rebuild gitit, install it?"
17:36:21 <djahandarie> monochrom, in Dijsktra's notation, <↑i : r.i : k.i> would just be a single element in some poset S, right?
17:36:28 <dcoutts> accel: you mean, you're in the gitit source dir?
17:36:37 <accel> dcoutts: yes
17:36:38 <dcoutts> accel: if so, just: cabal install
17:36:40 <accel> I made all the changes I needed
17:36:50 <amalloy> elliotstern: you certainly don't need Collection a -> Int -> a. Collection a -> a would be good enough, if it encapsulated the random selection itself. eg, clojure's randnth
17:37:20 <monochrom> yes djahandarie
17:37:46 <jmcarthur> elliotstern: how many elements in the collection are we talking about here?
17:37:57 <amalloy> jmcarthur: a few hundred
17:37:59 <paupau> If I see that naive qsort implementation ONE MORE TIME--
17:38:14 * jmcarthur doesn't know Go very well, obviously
17:38:19 <amalloy> *chuckle*
17:38:25 <elliotstern> It's a 19*19 board.
17:38:30 <elliotstern> 361 points
17:38:31 <jmcarthur> i have implemented UCT before, but for a game with far fewer moves available at a time
17:39:46 <monochrom> Data.Sequence is the next candidate
17:40:02 <amalloy> elliotstern: i'm friends with the guy behind many faces of go, but it's all in c and it seems unlikely that he has any insights into which persistent collection is best :P
17:40:26 <jmcarthur> hmm... but what i did would not require a collection like that at all. i had a concrete game tree instead, and i just traversed it, evaluating it lazily
17:40:45 <jmcarthur> such an approach might work for you if you use arrays with lazy element for the subtrees
17:40:48 <monochrom> although, with Data.Sequence, to obtain "delete the 15th guy" you have to compose two or three functions
17:40:49 <jmcarthur> *elements
17:41:41 <jmcarthur> in my case, there were only three or four possible moves at a time, so it was roughly a quadtree. this tree has a much larger branching factor, but the same general approach might work
17:42:01 <amalloy> someone please un-abbreviate UTC for me
17:42:17 <amalloy> UCT
17:42:39 <jmcarthur> upper confidence bounds applied to trees, IIRC. it's been a while
17:43:27 <elliotstern> How do you delete using Data.Sequence?
17:43:29 <traviscline> filter (\(a, b, c) -> (a+b+c == 1000)) triplets works but filter (\x -> (sum x == 1000)) triplets fails
17:43:33 <traviscline> can someone explain why?
17:43:45 <amalloy> ah, i now understand my confusion. jmcarthur called it UCT and elliotstern called it UTC
17:44:02 <elliotstern> Yeah, I kinda made a type there...
17:44:09 <copumpkin> traviscline: a triple is not a list
17:44:16 <traviscline> ohhh
17:44:18 <traviscline> gotcha
17:44:19 <traviscline> thanks
17:44:26 <amalloy> not that i actually understand anything; i just feel less bad about spelling it wrong
17:44:28 <traviscline> is there a more succinct way tot do that?
17:44:36 <copumpkin> not really
17:44:42 <traviscline> cool, thank you
17:44:48 <jmcarthur> elliotstern: split the sequence, remove the element from the head/tail of one of the two subsequences, concatenate
17:45:01 <jmcarthur> O(log n), O(1), and O(log n), respectively
17:45:21 <monochrom> O(leg n) :)
17:45:46 <jmcarthur> those are amortized operations, IIRC
17:45:53 <applicative> http://i.imgur.com/X45DW.jpg not as good as http://i.imgur.com/t88vDl.jpg
17:45:59 <elliotstern> Ah.  I'll try it with Data.Sequence, then
17:46:04 <elliotstern> Thanks!
17:46:33 <amalloy> jmcarthur: Data.Sequence sounds a lot like finger trees. is that basically what they are?
17:46:41 <jmcarthur> literally the same thing
17:46:46 <jmcarthur> just with a specific measure
17:46:49 <ivanm> amalloy: it's a specialised version
17:46:51 <monochrom> "while iteratee takes O(leg n), delimited continuation takes O(leg n^3)" :)
17:47:03 <amalloy> k
17:47:19 <jmcarthur> i think the measure is something like Sum Int?
17:47:27 <ivanm> jmcarthur: yeah
17:47:35 <jmcarthur> and the measure function is const (Sum 1) or somesuch
17:48:14 <monochrom> who is systematically mutilating these fine pictures into talking about module systems?! who?!
17:48:31 <ivanm> monochrom: looks like applicative is!
17:48:56 <monochrom> perhaps you could do some xkcd's and spikedmath's too
17:49:23 <esteth> I'm attempting to install reactive with cabal install, but when it compiles quickcheck it gets a tonne of "Overlapping instances for Show (a -> b)" errors. Do I need to unregister a module?
17:52:26 <applicative> who would have thought there'd be so many ways to make a show instance for (a -> b)?
17:53:08 <ivanm> applicative: as in, show _ = <random string> ?
17:54:51 <applicative> yes, but its this that's new?
17:54:52 <applicative> http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/Text-Show-Functions.html
17:55:07 <applicative> nope
17:55:20 <amalloy> applicative: (1) display the function's source code; (2) display a list of all each a and the b it maps to :P
17:55:40 <ivanm> applicative: that's been around for a while
17:55:51 <ivanm> amalloy: the latter isn't possible for arbitrary `a` AFAIK
17:56:01 <ivanm> and requires a Show instance for a and b
17:56:20 * ddarius has seen 3 classes of Show instances for functions.
17:56:27 <amalloy> ivanm: no, of course not. this wasn't a serious suggestion; just pointing out that there are multiple ways you could Show a function
17:57:01 <tjgillies> is there a ghci command to see declaration of function
17:57:02 <esteth> I'm getting conflicting instances from Text.Show.Functions and base:System.Event.Manager.IOCallback :S
17:57:03 <tjgillies> ?
17:57:13 <ivanm> tjgillies: as in the source?
17:57:14 <ivanm> no
17:57:20 <tjgillies> dang
17:57:24 <tjgillies> ivanm: thnx anyway
17:58:23 <jeffz> http://hackage.haskell.org/trac/ghc/ticket/5092
17:58:38 <jeffz> tjgillies: which version of GHC are you using?
17:59:09 <tjgillies> jeffz: 6.12.3
17:59:19 <jeffz> tjgillies: should be fixed in 7.0.3
17:59:26 <tjgillies> jeffz: thnx
18:01:00 <esteth> in fact: this is the error I'm getting - http://hackage.haskell.org/packages/archive/checkers/0.2.8/logs/failure/ghc-7.0
18:01:29 <esteth> I assume that it's a problem with the package, and that the version on hackage is just broken?
18:02:54 <applicative> esthet, hm I was getting the trouble too, with the checkers package, it seems.  
18:03:05 <dafis> esteth: ticket 5092, posted by jeffz a few lines above
18:03:44 <ivanm> yeah, jeffz should have pointed that link to you esteth, not tjgillies 
18:03:51 <esteth> dafis: Oh, sorry. I assumed he was talking to tjgillies :P
18:04:05 <tjgillies> lol
18:04:11 <tjgillies> i was like ... 'ok... thanks'
18:04:45 <applicative> esthet, so the problem is with the base 'package'
18:05:59 <esteth> seems like somebody just defined an instance they didn't need in Checkers. There's a patch, but I don't know if cabal-install can do it automagically, so you'll likely need to download the module yourself from hackage and install it manually after applying the patch
18:06:28 <ivanm> esteth: no, cabal-install can't apply patches for you
18:07:30 <Mathnerd314> is there a haskell binding to google's v8?
18:08:02 <Mathnerd314> I found https://github.com/martine/h8 but it's old
18:09:31 <ivanm> Mathnerd314: I haven't heard of one
18:09:37 <accel> Where is Gitit's "DisplayMath" type defined?
18:09:57 <ivanm> accel: tex-math or pandoc would be my guess
18:10:54 <applicative> data MathType = DisplayMath | InlineMath deriving (Show, Eq, Ord, Read, Typeable, Data)
18:10:59 <Mathnerd314> accel: have you looked at data/default.conf ?
18:11:14 <esteth> ivanm: Oh lordy, could you confirm if that patch is a patch to GHC or to Checkers? I don't want to rebuild my entire GHC just for that tiny patch :(
18:11:23 <applicative> pandoc-types package, Text.Pandoc.Definition
18:11:40 <ivanm> esteth: it wasn't to Checkers
18:11:53 <esteth> it definately looks like a GHC patch, but eurgh.
18:12:17 <esteth> ivanm: Thanks.
18:12:24 <ivanm> I don't know if it was to GHC or some low-level library
18:13:13 <Mathnerd314> accel: it looks to me like you just need to change "math: MathML" to "math: raw" and edit page.st to load MathJax
18:13:21 <applicative> accel https://github.com/jgm/pandoc-types/blob/master/Text/Pandoc/Definition.hs
18:14:40 <applicative> esteth, mysteriously I compiled checkers with accidental black magic.  I struck the offending line "import Text.Show.Functions ()" and tried that, knowing better.
18:15:09 <applicative> then i repented when it gave me 2000 lines of errors, but did cabal install without cabal clean.
18:15:15 <applicative> will i punished in the next life?
18:15:47 <applicative> in any case, with a proper module system, this would never have happened!
18:18:59 <esteth> applicative: Deleting that import just gives me a bunch of other, related errors about Show (a -> b) and halts compilation :(
18:19:23 <ivanm> applicative: quick, go forth and implement said proper module system then!
18:20:08 <accel> Mathnerd314: nah, it rips out the $$, which MathJax looks for
18:20:18 <accel> Mathnerd314: so I need to replace the <div class="math"> ... </math> to $$ ... $$
18:20:36 <accel> applicative: thanks
18:21:30 <accel> is there a way to grep a github repo
18:21:33 <accel> w/o cloning it first?
18:22:29 <ivanm> accel: google
18:22:30 <ivanm> ;)
18:23:04 <applicative> esthet, right, I got those errors, then corrected to the old way, and failing to clean, i began cabal install with the text corrected to its former state.
18:23:15 <accel> ivanm: right, google supports regexes over the internet :-)
18:23:15 <applicative> esteth: I don't recommend this procedure....
18:24:17 <esteth> applicative: :( Looks like I'm stuck without reactive until GHC 7.0.4 is released then
18:24:26 <applicative> esthet, I think so
18:25:17 <applicative> when we write "newtype Moo = Moo Int" it is sometimes said that the compiler ends up dispensing with the Moo wrapper very early on in crushing our code
18:25:34 <applicative> is this somehow part of Haskell, or of the ghc, how do you describe the claim?
18:27:19 <applicative> I mean, the difference between data Moo = Moo Int and newtype Moo = Moo Int.  Should we just say the newtype is just a new type, or something more complicated?
18:28:17 <esteth> my understanding is that newtype is like a #define in C, in that you're just defining a pretty name, not a new data type in and of itself. I don't know if that's what you're asking though
18:28:46 <mauke> your understanding is wrong
18:28:47 <mjrosenb> it is slightly different from a #define
18:28:48 <mjrosenb> in that you *need* to use the constructor in your code if you want it to typecheck
18:28:49 <applicative> well "type Moo = Int" is a synonym.  newtype is stranger, you have to wrap
18:28:49 <accel> victory
18:28:50 <accel> it works
18:28:55 <accel> i am the greatest haskell-er ever
18:28:58 <accel> not quite
18:29:01 <Mathnerd314> accel: post the patch somewhere?
18:29:08 <accel> but gitit / mathjax works for me now :-)
18:29:21 <accel> Mathnerd314: do you actually want it, or is this for others?
18:29:36 <Mathnerd314> accel: I actually want it
18:29:47 <Mathnerd314> once I get gitit itself running...
18:30:00 <accel> okay; I'll paste a patch
18:30:22 <applicative> mauke see FUD-master Harpers comment at http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/#comment-746
18:31:29 <accel> Mathnerd314: you need (1) use raw mode (as you suggested) (2) tell MathJax to use extensions: ["jsMath2jax.js"]
18:31:34 <applicative> certainly with a recursive newtype Blah = Blah (Either String Blah) or whatever there's little point denying it's a new type, since where else was it before.
18:33:23 <Mathnerd314> btw, any idea why cabal would insist on installing + using network 2.2.x when I already have 2.3.x installed?
18:33:55 <ivanm> Mathnerd314: because something else you want to install says it wants 2.2
18:33:56 <copumpkin> some dependency of yours insists on something pre 2.3?
18:34:36 <Mathnerd314> ivanm: but cabal doesn't complain when I add --constraint "network==2.3.0.2"
18:34:59 <ivanm> Mathnerd314: what are you trying to build?
18:35:07 <Mathnerd314> gitit, on windows
18:35:13 <parcs> where can i find a copy of http://code.haskell.org/haskell-platform/haskell-platform.cabal ?
18:35:16 <Mathnerd314> in profiling mode
18:35:17 <parcs> hoogle is asking for it
18:36:41 * TomMD installs ocaml while wondering how much space is taken up on his HD by compilers alone.
18:37:01 <amalloy> thanks to whoever found me a current version of haskellmode-emacs. much nicer than futzing around at the terminal
18:37:22 <accel> how do I left align shit in gitit?
18:37:49 <TomMD> I think you should put better content in your gitit.  Not much point in aligning things that aren't worth while.
18:38:44 <accel> how do I left align math equations in gitit?
18:40:53 <Mathnerd314> if they're in mathjax, you'll probably have to check the mathjax documentation
18:42:35 <dolio> applicative: Harper's complaint is that Ord is not a good way of abstracting over ordered types, and it isn't.
18:43:25 <dolio> It's for conveniently specifying a default ordering for a type. That's what all type classes are for, more or less.
18:44:56 <dolio> Wrapping things in newtypes to specify different orderings isn't a good solution, either.
18:45:32 <dolio> The good solution is to use (a -> a -> Ordering). However, that has the problem that you have to manually plumb it to all the places it's used.
18:46:36 <dolio> So, a better solution in that direction is to parameterize a module by an (a -> a -> Ordering), and define all the derived functions in that module. Then you open it once with the ordering you want.
18:47:18 <Mathnerd314> but is it *the* solution? suppose you put too many functions in one module, and you want different orderings for some of them
18:48:17 <dolio> You only open the module in the scope in which you want to use the functions inside it.
18:48:40 <Mathnerd314> usable, I guess
18:49:06 <dolio> If you need to use several different ones in the same expression or something, you're probably in bad shape, but otherwise....
18:49:34 <dolio> Anyhow, this is assuming you want to abstract over a type with an ordering.
18:49:45 <dolio> Type classes arguably solve a different problem.
18:49:57 <Mathnerd314> hmm... does it do type inference? can you open a module with a polymorphic type?
18:50:20 <dolio> But Haskell's lack of nice modules leads people to use type classes for the things modules are better for.
18:51:22 <dolio> Because you can use them for that, even though you probably shouldn't.
18:52:11 <dolio> I'm not sure what the last question means.
18:54:23 <applicative> dolio, it seems to me one often wants to do (something like) use two orderings in the same definition
18:55:19 <dolio> Two orderings on the same type?
18:55:33 <dolio> I can believe you'd want to use two orderings on different types.
18:55:38 <dolio> And modules kind of fail in that case.
18:55:49 <dolio> You have to keep things qualified, or rename things upon opening.
18:56:18 <dolio> Unless I'm forgetting something.
18:57:04 <dolio> I guess you could use some type-directed name resolution facility.
18:57:14 <dolio> The obvious best-in-class being type classes.
18:57:34 <dolio> So you'd have modules that contain type class instances.
18:58:52 <applicative> Hm, the Haskell report says newtype is a new type, and that it's a "renaming", and this " Unlike algebraic datatypes, the newtype constructor N is unlifted, so that N _|_ is the same as _|_."
18:59:19 <applicative> that propositions that it's a new type and that its a renaming, are directly contradictory.
18:59:26 <applicative> the propositions...
18:59:44 <dolio> It's a new type internally represented identically to the old type.
19:00:02 <dolio> At least, that's the idea behind it.
19:00:13 <applicative> fine, the text is still contradictory.  you cant rename a type that doesnt exist
19:00:16 <xplat> it's an opaque renaming
19:00:46 <xplat> preflex: seen conal
19:00:46 <preflex>  conal was last seen on #haskell 1 day, 4 hours, 29 minutes and 30 seconds ago, saying: ian_mi: that's why languages usually have at least one non-strict building block, typically if-then-else
19:01:19 <applicative> one can't speak this way without an antecedent theory of sameness and difference of type, which seems necessarily outside the language
19:02:49 <nanothief> Is it possible using the iteratee package to modify a file, eg to replace every 'a' with 'z' in a given file? I can understand how to use iteratees to read files, but not modify them.
19:06:13 <xplat> you use an enumerator to read the file, and couple it with an iteratee in IO to write the modified version.  they aren't really suitable in the usual form for modifying a file in place, though.
19:06:38 <RichardO> @pl f x y z = g (h (i x) y) z
19:06:39 <lambdabot> f = (g .) . h . i
19:06:57 <xplat> they're more suited for the rewrite-and-replace method à la perl's -i
19:06:58 <applicative> nanothief, in the enumerator package, there is Data.Enumerator.List.map, Data.Enumerator.Binary.map, Data.Enumerator.Text.map
19:07:52 <nanothief> xplat: yeah I was looking for an inplace replace
19:07:53 <applicative> nanothief, were you insisting that it be in-place?
19:08:06 <applicative> oh. :)
19:08:09 <nanothief> :)
19:08:52 <nanothief> applicative: do the functions you gave work in-place?
19:09:36 <osoleve> what's going on with the error in buildChord, here? http://hpaste.org/45797/rounding_doubles
19:11:47 <mauke> osoleve: what is WAVESamples?
19:11:58 <osoleve> mauke, [[Int32]]
19:12:07 <mauke> well, there's your problem
19:12:24 <mauke> map (round ...) ... :: [Int32]
19:13:28 <osoleve> mauke, where in the line would I put that?
19:13:34 <mauke> nowhere
19:13:54 <osoleve> oh oh ohh
19:13:55 <mauke> it was a statement of fact
19:13:59 <osoleve> got you
19:14:38 <nanothief> if you are only wanting to generate one channel, you need to change the function passed to map to ((: []) . round . sum)
19:14:52 <nanothief> > (: []) 3
19:14:52 <lambdabot>   [3]
19:15:02 <nanothief> > map (: []) [1,2,3,4,5]
19:15:03 <lambdabot>   [[1],[2],[3],[4],[5]]
19:15:22 <osoleve> ohhh, thank you
19:15:35 <osoleve> and thanks for your help on S/O the other night, nanothief 
19:15:42 <nanothief> no problem :)
19:16:32 <fryguybob> Mathnerd314: I got gitit working on Windows with a small change to FileStore.
19:17:01 <Mathnerd314> fryguybob: yay! what was it?
19:17:24 * Mathnerd314 pauses his download of Ubuntu
19:17:25 <geheimdienst> an api design question: peekCAString converts a latin-1-encoded c string. peekCString is currently an alias for peekCAString, but supposedly will change in the future to use something locale-dependent instead of latin-1
19:18:35 <fryguybob> runShellCommand is reading the redirected output lazy then deleting the file: http://hackage.haskell.org/packages/archive/filestore/0.4.0.3/doc/html/src/Data-FileStore-Utils.html#runShellCommand
19:18:36 <BrianHV> can someone please enlighten me about this syntax?   class Move from to | from -> to where (from https://bitbucket.org/dibblego/haskell-course/src/57a00f8bebda/TicTacToe/haskell/Data/TicTacToe/Board.hs)
19:18:54 <geheimdienst> so, why not just publish an api with only peekCAString, and whenever the other thing is ready, add it? i'm asking because releasing a function that will change in the future sounds like asking for confusion and broken code
19:19:21 <nanothief> BrianHV: read up on functional dependencies
19:19:33 <dafis> BrianHV: It's a functional dependency
19:19:45 * BrianHV googles
19:20:07 <Mathnerd314> fryguybob: I was looking at that code! I should have noticed that it only used Data.ByteString.Lazy...
19:20:08 <fryguybob> I don't have much experience with bytestring but I added a qualified import of Data.ByteString and used readFile from that instead and returned lazy versions with B.fromChunks.
19:20:45 <nanothief> BrianHV: the haskell wiki description is pretty good: http://www.haskell.org/haskellwiki/Functional_dependencies
19:21:20 <fryguybob> http://hpaste.org/45798/filestoreutilshs
19:21:56 <fryguybob> oops that has my debug output too.
19:22:05 <BrianHV> nanothief: yep, that's the one I found. I think I understand it now. thanks!
19:23:46 <milkpost> is there a library for representing and manipulating graphs in haskell?  FGL seems out of date
19:24:34 <applicative> out of date??!!
19:24:37 <milkpost> 2008
19:24:57 <milkpost> i guess maybe "not actively developed anymore"?
19:25:26 <applicative> http://hackage.haskell.org/package/fgl 2010 
19:26:42 <applicative> ivanm is the maintainer now, no?
19:26:52 <c_wraith> fgl was dead for a while, but yeah, ivanm picked it up
19:27:52 <milkpost> ok just wondered... i am just wondering what format, if any, it can import graphs from.  i don't know haskell pretty much at all but planning to try and learn and want to load some graphs i have in python, so need to export them to some format first
19:28:35 <milkpost> this documentation is not very documenting though, just function definitions mainly
19:28:47 <jeffz> you could export them to a compatible Read instance of some graph
19:29:00 * jeffz grins.
19:31:13 <milkpost> yeah, way over my head
19:31:37 <c_wraith> milkpost: that was mostly a joke anyway :)
19:31:40 <jeffz> milkpost: perhaps you should start with a haskell tutorial rather than just diving into fgl.
19:32:36 <milkpost> jeffz: yes, i will do that, but long story short I'm actually going to convert my graphs to *some* text format using python, and I figured, I might as well convert to something if it's more globally compatible with other languages I may get to.  rather than having to re-convert again later
19:33:16 <jeffz> it'll be clearer how to do what you want once you get down some basics.
19:34:23 <milkpost> so is there no such thing as like something to parse yaml? 
19:34:26 <c_wraith> It looks like fgl doesn't have support for import of any common format.
19:34:50 <c_wraith> That'd make your best bet producing as clean a format to parse as any.
19:35:50 <jeffz> you can build graphs using fgl piecewise, writing your own importer from something simple isn't hard, iirc Show and Read instances are relatively easy too, hence my suggestion to output something compatible with the latter, which would make an "importer" trivial.
19:40:00 <milkpost> yaml is out, taking FOREVER to export haha
19:42:14 <luqui> milkpost, fgl is bleh. have fun %-)
19:42:26 <milkpost> lol, that's encouraging
19:42:42 <luqui> at least it has some algorithms implemented
19:42:44 <nyingen> luqui: why do you say fgl is bleh?
19:43:03 <luqui> i just don't find the interface to feel in the same spirit as the rest of haskell
19:43:20 <nyingen> hm, I guess I can see that
19:43:24 <luqui> i have tried several times to do better, only to run into observability problems.  so i'm not criticizing it as a bad graph implementation
19:43:36 <luqui> just that i haven't seen a good way to do pure functional graphs yet
19:43:40 <nyingen> I've been using it a bit lately, and it definitely took several read-throughs to figure out how to work with it
19:43:50 <nyingen> In fact I'm thinking of using it now
19:44:35 <nyingen> I have a graph structure represented in some Java object, and I'm using Thrift to send it to a haskell function
19:45:09 <nyingen> on the haskell end it has to be deserialized into an equivalent graph structure, so I was thinking of using fgl
19:51:34 <mgsloan> Anyone care to comment on my WIP libraries: https://github.com/mgsloan/toyframework https://github.com/mgsloan/curve ?
19:52:04 <nyingen> I'm very curious as to how well the Thrift serialization from Java to Haskell is going to perform
19:52:43 <mgsloan> mainly looking for any criticism of api / code / formatting (though not documentation, that's still TODO)
19:54:05 * mgsloan tried to use patch-tag...
19:58:33 <mgsloan> https://github.com/mgsloan/curve/blob/master/Data/Curve/Math.hs :)
20:00:32 <copumpkin> koninkje_away: you around?
20:02:51 <applicative> mgsloan, it's all very well and good, but think how much better it would be with *first class modules*
20:03:20 <copumpkin> applicative: duuuuuuude
20:03:23 <mgsloan> :) think how much better it would be with type constraint synonyms!
20:05:29 <mgsloan> I'd love to use (AffineSpace a) => Curve (Bezier a), but AffineSpace brings in way too many type constraints, so writing anything that's generic ends up with a huge type sig
20:05:41 <mgsloan> so instead it's (Num a) => Curve (Bezier a)
20:05:59 <mgsloan> which means you can't do Bezier (a, a).  Instead it's (Bezier a, Bezier a)
20:06:26 <mgsloan> https://github.com/mgsloan/curve/blob/master/Data/Curve/Bezier.hs
20:08:04 <mgsloan> arguably, supporting both would lead to the annoying necessity of conversions between the two
20:08:16 <mgsloan> so perhaps it's for the best
20:10:10 <mgsloan> it does mean that I can't do (Bezier (Bezier a)) to get 2d functions :(
20:22:01 <xplat> ♥ AffineSpace
20:22:47 <lpsmith> luqui,  I completely agree with regard to fgl myself
20:24:15 <lpsmith> One of the frustrating things in my opinion with the inductive approach is demonstrating that any given function on graphs is actually a well defined function
20:26:15 <lpsmith> but,  I don't have many ideas about how to do better
20:26:18 <Mathnerd314> fryguybob: thanks a bunch! seems to be working well.
20:26:18 <xplat> isn't that sort of a problem in any presentation of graphs?
20:26:55 <lpsmith> xplat: I dunno;  I've done some with graphs, but I'm hardly an expert on graph-related algorithms
20:28:03 <xplat> you always have problems like 'you could loop following edges' or 'does the function depend on visitation order?' if you use a traversal you already know is well-defined
20:28:46 <xplat> the first problem makes it not a function; the second makes it a function but not on graphs
20:29:06 <lpsmith> right,  at least the former is approachable with the right combinators
20:30:14 <lpsmith> issues regarding vistation order on the other hand,  I have no idea how broach, or if it's even possible
20:31:16 <lpsmith> it might be nice if you could define,  say    double (x:xs) = x : x : double xs,  and then get a cyclic object if you wrote double (cycle [1,2,3])
20:33:25 <xplat> that problem in particular could be approachable by a recursion discipline
20:34:00 <lpsmith> oh,  luqui,  I guess you weren't connected when I said it,  but I mentioned that I agree completely with regard to fgl
20:34:33 <lpsmith> xplat: something along the lines of category-extras?
20:34:44 <xplat> something similar to what you do on the type level to get full type inference on (monomorphic) recursive functions, only you would do it on the value level
20:35:08 <lpsmith> oh, a language change
20:35:30 <xplat> in that case you could guarantee mapping a finite cyclic structure to a finite cyclic structure
20:35:47 <lpsmith> well, in some cases anyway
20:35:50 <xplat> well, language changes can sometimes be simulated usefully without changing the language
20:36:07 <lpsmith> true
20:37:18 <lpsmith> well,  I remember that I played around with that idea,   and came up with some examples that seemed problematic.  But I forget,  I should've taken notes :)
20:38:10 <luqui> lpsmith, i think part of the non-naturality of fgl comes from math actually
20:38:22 <luqui> we define a graph using an arbitrary 'carrier set'
20:38:26 <copumpkin> oh man, luqui is on IRC
20:38:39 <luqui> hide!
20:38:43 * copumpkin hides
20:38:48 * luqui hides
20:38:57 * luqui peeks
20:39:00 <lpsmith> I suppose if you approach it with some kind of memoization,  then you might get a non-cyclic infinite structure,  but in some cases get a cyclic structure from a cyclic structure
20:39:12 * lpsmith pokes
20:40:00 <lpsmith> luqui: yeah, I'm somewhat suspicious of that
20:40:44 <lpsmith> Higher order functions are very nice for certain kinds of graph constructions,  but FP doesn't seem to be a clearly huge win for general graph algorithms
20:41:08 <lpsmith> Not like it is for tree algorithms, anyway
20:41:19 <lpsmith> Which FP does so well at.
20:41:22 <luqui> maybe as functional programmers we should transcend graphs
20:41:35 <luqui> maybe graphs are just an ancient way of phrasing these problems :-)
20:41:48 <lpsmith> hah
20:42:12 <luqui> meanwhile using our trusty graph reduction machine to execute our code %-)
20:44:15 <luqui> or maybe a good repr of graphs relies on a good development of quotient types
20:44:30 <luqui> graph = inductive graph mod carrier set
20:44:48 <lpsmith> hmm
20:44:57 <lpsmith> Maybe I should learn Agda then
20:45:21 <lpsmith> Maybe Agda would have some kind of deep insight into graph algorithms if you worked at it for a while
20:45:21 <luqui> have you used agda or coq for more than a few lines?
20:45:28 <lpsmith> No, sadly
20:45:29 <jmcarthur> maybe someday we can think of a nicer way to talk about sharing in haskell
20:45:37 <jmcarthur> or in some other language
20:45:42 <luqui> I highly recommend it.  Coq has significantly changed my thinking about how abstraction works.
20:45:46 <dolio> Agda doesn't have quotient types.
20:46:09 <dolio> Not that you shouldn't learn it.
20:46:22 <lpsmith> aww,  but you do need some kind of theorem proving environment to do quotient types justice
20:46:36 <luqui> my recommendation is something of the opposite of my recommendation for learning haskell.  to learn haskell, make a real thing and get past the toy examples.
20:46:46 <luqui> for agda/coq, don't try to do anything real, and just play a lot.
20:47:03 <luqui> because there is a lot of stuff that is surprisingly hard that you will hit if you have a specific goal in mind
20:47:47 <ddarius> There aren't too many proof systems that support quotient types.
20:48:02 <lpsmith> I think PVS does,  IIRC
20:48:08 <dolio> There's NuPRL...
20:48:09 <ddarius> Nuprl does.
20:48:19 <dolio> I don't know any others.
20:48:32 <luqui> hmm what's it like?  quotient types are fairly simple to encode using existentials.
20:48:36 <luqui> or is it different than that?
20:48:47 <dolio> Oh, Epigram 2, if you even consider that a candidate.
20:48:59 <luqui> from __future__ import epigram 2
20:49:04 <lpsmith> hah
20:49:26 <ddarius> luqui: Nuprl is based on the semantic notion of partial equivalence relations.  A type is not much more than a partial equivalence relation.  A quotient type just uses a coarser PER.
20:49:59 <luqui> hmm.  sounds interesting
20:50:11 <luqui> is it cool?  :-)
20:50:32 <dolio> Most proof systems do not support existential types, either.
20:50:42 <dolio> In the sense that you'd need to recover quotients.
20:50:55 <lpsmith> why is that?
20:51:08 <dolio> Although I've heard that Agda may have gotten extended in that direction since I stopped looking.
20:51:23 <ddarius> It's different.  Nuprl is, allegedly, the only proof system that is based on semantic rather than syntactic notions.  Also, Nuprl is capable of dealing with things like the untyped lambda calculus due to its lazy computation system.
20:51:27 <lpsmith> (I've long wanted to play with existentials in arbitrary locations,  but no Haskell implementation supports that)
20:51:53 <ddarius> Adding free existentials to Haskell would not be hard.
20:51:57 <luqui> ddarius, those two things sound good so far
20:52:19 <jmcarthur> lpsmith: doesn't UHC support that, or am i misremembering something?
20:52:28 <ddarius> luqui: It's definitely worth at least reading about.  Unfortunately, they take the "avoid success at all costs" motto much more seriously than Haskell.
20:52:40 <luqui> heh
20:52:48 <dolio> lpsmith: Because existentials with proper quotienting and parametricity are trickier to get right than sigma types.
20:52:54 <shachaf> Hmm, I know someone whose Ph.D. thesis was about Nuprl.
20:53:09 <lpsmith> jmcarthur: sort of?   I remember I started playing with UHC because of that,  but found it was a bit more limited than I was hoping for.  I don't recall details, though.
20:53:22 <jmcarthur> ah
20:53:30 <dolio> UHC is missing existentials with type classes.
20:53:33 <dolio> If you care about that.
20:53:50 <lpsmith> yeah, that's what I wanted
20:53:53 <lpsmith> sort of 
20:54:07 <dolio> If you don't, then it should be fine, up to bugs.
20:54:08 <jmcarthur> ah
20:54:30 * luqui is much less enamoured with type classes than he used to be
20:54:56 <luqui> i would rather have a good module system
20:54:59 <dons> luqui: all burnt out and seeking modules eh? 
20:55:10 <luqui> yep
20:55:18 <dons> well, a small matter of implementing the shields/spj paper... for endless fame
20:55:32 <osoleve> dons, thanks for the advice on S/O before about breaking my code down and adding type sigs, it really helped me solve my problem
20:55:32 <lpsmith> I've been much less enamoured with type classes than I used to be for about 10 years now :-P
20:57:07 * applicative hadn't noticed any problem about the type classes Monad, Functor, etc.
20:57:30 <luqui> applicative, but you wouldn't, would you ;-)
20:58:03 <luqui> being related and all
20:58:13 <ddarius> dons: I don't think that that paper represents the best approach, and I don't think I'm alone, or else it would probably have been implemented by now.
20:58:40 <ddarius> Also, with the relatively recent connections between modules and type classes, a new module proposal would definitely need to take that into account.
20:59:26 <luqui> can't we just copy agda? ;-)
20:59:32 <tjgillies> is there a way to list type constructors for a given type in ghci?
20:59:36 * applicative notices lots of modules defined in the ocsigen source.  he thinks he would rather die.
20:59:39 <ddarius> luqui: Does Agda have type classes?
20:59:44 <luqui> shut up
20:59:45 <luqui> :-P
21:00:11 <dolio> Incidentally, when Harper is talking about how he's got a paper demonstrating that you can add features that cover uses of classes to a language with modules, is he talking about Modular Type Classes?
21:00:17 <lpsmith> tjgillies: :info type I think
21:00:19 <ddarius> Seriously, if it weren't for type classes, Haskell would already have a fancier module system, but type classes overlap so much with modules that one wants to capture both in a nice generalization.
21:00:24 <dolio> Because I thought that paper didn't quite have all the kinks worked out.
21:00:50 <dolio> Also, Agda just recently got some type-class-like features.
21:00:55 <jmcarthur> there is a recent proposal for more some sort of implicits that can be used to mimick haskell-style type classes and such in agda
21:01:03 <dolio> Although it's probably more like Scala's implicits, I guess.
21:01:06 <jmcarthur> i don't think they are in agda already though, are they?
21:01:12 <ddarius> dolio: There are papers showing that you can encode either into either (with perhaps some tweaks).  The encoding of ML style modules into type classes is not pleasant but bearable.  The other way is impractical.
21:01:16 <dolio> Probably not. They're in someone's branch.
21:01:50 <ddarius> At any rate, Harper's blog article doesn't make too much sense in that regard as Haskell's module system is its module system, not type classes.
21:01:53 <mgsloan> someone should do a preprocessor that encodes newspeak style modules as implicits
21:01:54 <dolio> I haven't pulled Agda in a while.
21:02:00 <jmcarthur> i haven't seen any direct comparison to scala's implicits yet, and that's the comparison i really want to see
21:02:28 <mgsloan> (implicit parameters)
21:02:30 <luqui> mgsloan, if i understand correctly, newspeak is not as modular as it thinks it is
21:02:52 <luqui> mgsloan, but i don't know much about it.  that's the one with the global "configuration" that you set up
21:02:56 <luqui> ?
21:03:01 * applicative considers that Prof. Harper might reflect that people who live in glass houses should not throw stones
21:03:05 <dolio> jmcarthur: I suspect Scala has more machinery behind the scenes working to propagate things than the Agda thing will have.
21:03:26 <tjgillies> lpsmith: thnx
21:03:27 <mgsloan> I don't know too much about it either, lucqui, but I believe the idea is that when importing a module, you pass in its dependencies
21:03:46 <applicative> ddarius, yes, his attention is entirely absorbed by type classes. 
21:03:50 <mgsloan> so that could probably amount to having a global default configuration
21:04:23 <tjgillies> wow :info is really handy
21:04:30 <luqui> mgsloan, yeah it is a very tricky issue.  ties into notions of "proof irrelevance"
21:04:48 <dolio> ddarius: There's at least a hint of a point there, in that Haskell's poor module system leads people toward using type classes for things modules would be better for.
21:04:49 <luqui> sometimes you don't want to care how it's done, but a lot of times you want to care when the module author didn't think you should want to
21:05:06 <ddarius> dolio: I haven't seen anyone do that.
21:05:38 <dolio> What about, a bunch of wrappers for selecting Monoid instances?
21:05:53 <luqui> ddarius, i wrote a blog post about the "existential typeclass" antipattern
21:06:03 <applicative> "according to the philosophy of type classes  the integers can be ordered in precisely one way"
21:06:04 <luqui> i think all instances of this pattern are typeclasses pretending they are modules
21:06:07 <ddarius> luqui: That's aiming at objects not modules.
21:06:08 * applicative facepalms
21:06:21 <jmcarthur> i'm tempted to think that there is a "big idea" behind type classes that is independent of the parts that overlap with modules and that if we could nicely separate the two things we would be better off
21:06:24 <luqui> ddarius, hmm... difference?
21:06:42 <ddarius> luqui: You think modules and objects are the same thing?
21:07:04 <luqui> ddarius, insofar as neither has a precise definition, and they are both basically fancy records... yeah
21:07:07 <ddarius> At any rate, an "existential type class" approach would give you a first-class thing.
21:07:13 <luqui> (precise definition in my brain i mean)
21:08:28 <luqui> jmcarthur, yeah that's interesting.  what is the essence of a typeclass?
21:08:32 <applicative> tjgillies:  :i is even handier :)
21:08:36 <ddarius> dolio: That's actually starting to be related to how modules can be encoded into type classes, but that particular use still doesn't come out to be something that could be readily done with (ML-style) modules.
21:08:46 <dolio> jmcarthur: The big idea behind type classes is that it's convenient to have the same name for related (but different) functions on many types.
21:08:49 <tjgillies> applicative: ;)
21:09:45 <luqui> dolio, but what do you mean by "related".  there is a level of abstractability there that we need to account for.
21:09:46 <jmcarthur> dolio: and with the addition of associated data types that also extends to the same name for related but different types as well as values
21:09:55 <dolio> jmcarthur: And modules kind of suck at that, especially if you have to use the overloaded name at different types in the same scope.
21:11:16 <dolio> luqui: Another way to put it would be: type classes are The Right Way to do type-directed name resolution.
21:11:24 <dolio> And modules simply don't solve that problem.
21:11:27 <ddarius> The one thing that I've seen that is explicitly trying to be a module is Parsec's Language record.
21:11:54 <applicative> that is a truly amazing (Haskell) module.  
21:11:55 <luqui> dolio, oh, TDNR + abstraction, bascially
21:12:16 <erenrich> why doesn't "sum . map2 (*)"  (w/ map2 defined to be a function that does zipWith) typecheck but (sum .) . map2 (*) does?
21:12:35 <luqui> ddarius, I certainly would be using modules if I had good functor support. I end up "hard coding" my dependencies when I would rather they be abstract.
21:12:39 <ddarius> erenrich: Because in the former the types don't match, and in the latter they do.
21:12:40 <dolio> If you think about how to give real types to TNDR, you get type classes, essentially.
21:12:46 <erenrich> ddarius: oh good call
21:12:46 <erenrich> thanks
21:12:51 <shachaf> @unpl sum . map2 (*)
21:12:51 <lambdabot> (\ c -> sum (map2 (*) c))
21:12:58 <jmcarthur> i think another interesting thing about type classes is that they are open. in a DT language you can implement something like closed type classes fairly easily
21:13:09 <ddarius> luqui: I'm not saying ML-style functors wouldn't be a great boon to programming in Haskell.
21:13:15 <dolio> And of course, it's probably good to have all the overloaded things be related in some conceptual sense.
21:13:23 <lpsmith> tjgillies: :info is also by far the easiest way of finding the fixity and precidence of any given infix operator
21:13:33 <lpsmith> Unfortunately that information is not represented in haddocks
21:14:03 <erenrich> shachaf: thanks
21:14:03 <luqui> ddarius, ah right.  i guess i was saying that I have had the urge to use typeclasses as modules many times, only to abandon it because it was too damn ugly.
21:14:17 <luqui> every function signature has a context a mile long
21:15:02 <erenrich> @unpl (sum .) . map2 (*)
21:15:02 <lambdabot> (\ d g -> sum (map2 (*) d g))
21:15:22 <ddarius> It wouldn't be hard to make a (localized) preprocessor that encodes an ML-style module system into Haskell type classes.
21:15:47 <luqui> ddarius, that idea has been gaining momentum in my head, actually
21:16:15 <applicative> erenrich,  sum . map2 (*)  suggests that only one argument is to follow,  (sum .) . map2 (*) suggest two
21:16:26 <luqui> esp as i'm about to launch a code project that really does not like things to have intensional identity
21:16:36 <luqui> so to support haskell will be hard without that coarse level of abstraction
21:17:19 <erenrich> applicative: why can't haskell infer the number of arguments it will need?
21:17:38 <erenrich> (it seems to have enough information in this case)
21:17:41 <applicative> it does that's why it signals a type error :)
21:17:53 <erenrich> hm
21:17:57 <osoleve> what's a good container for storing the transition matrix for a markov generator?
21:18:05 <luqui> erenrich, mostly because all functions are one argument, so it would have to know whether you indend to return a "function" vs. a "value"... when functions are values.
21:18:13 <luqui> erenrich, so it's hard to get right when you start abstracting over things
21:18:20 <erenrich> i see
21:18:34 <erenrich> ok that makes sense
21:18:38 <erenrich> thanks all
21:18:55 <jmcarthur> it's actually very good at inferring the number of arguments for a function. it's always one
21:19:00 <erenrich> heh
21:19:16 <applicative> map2sum op xs ys = sum (map2 op xs ys) is not like map2'sum f xs = sum (map2' f xs)
21:20:11 <applicative> erenrich: what is your definition of map2 ? 
21:20:55 <erenrich> map2 f (h1:t1) (h2:t2) = (f h1 h2) : (map2 f t1 t2)
21:20:59 <erenrich> applicative: ^
21:22:37 <Cale> That's known as zipWith, btw
21:22:47 <Cale> :t zipWith
21:22:47 <Axman6> :t zipWith
21:22:47 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:22:47 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:24:15 <applicative> erenrich has already noticed that, he reinvented it, suggesting it's worth defining
21:25:36 <mgsloan> osoleve: Data.Map.Map a [(Double, a)] ?
21:25:47 <mgsloan> or use Data.Graph ..
21:26:04 <osoleve> mgsloan, okay, i'll look into it. thanks.
21:26:45 <Cale> osoleve: You may also consider using one of the matrix libraries, like hmatrix
21:27:20 <Cale> or an array type indexed by pairs
21:27:37 <Cale> (or a map indexed by pairs!)
21:27:41 <mgsloan> or Data.HashTable
21:27:49 <copumpkin> omg no
21:27:53 <mgsloan> no?
21:28:04 * mgsloan isn't really up and up on his haskell data structures actually
21:28:07 <osoleve> dang, HashTable was actually the first place I looked haha
21:28:31 <copumpkin> in these here parts we don't use no nasty mutable datastructures
21:28:48 <mgsloan> :) but it's got nearly O(1) stuff!
21:28:59 <mgsloan> Data.Map.Map is a tree
21:29:01 <mgsloan> iirc
21:29:11 <Cale> "O(1)" with ridiculous constants that make it less usable than Data.Map
21:29:15 <ivanm> mgsloan: yup
21:29:29 <ddarius> Immutable hash tables are a fairly nice read-only data structure.
21:29:36 <Cale> Data.HashTable is only there for historical reasons
21:29:43 <Cale> At least, last I checked
21:29:45 <shachaf> Why does it have ridiculous constants?
21:29:49 <copumpkin> http://snapplr.com/c88r
21:29:55 <Cale> Because nobody cares about it :P
21:30:08 <Cale> It's always possible that someone has actually gone and improved it when I wasn't looking
21:30:13 <copumpkin> it has been improved
21:30:16 <copumpkin> but still isn't worth it
21:30:29 <osoleve> okay, i won't use a hashtable
21:30:47 <copumpkin> the comic convinced you, eh
21:30:51 <osoleve> i like the idea of a pair-indexed array, though
21:30:54 <ddarius> You can surely give it a try, though as a mutable data structure, it's much less pleasant to work with.
21:31:00 <osoleve> copumpkin, i only listen to ragecomics
21:31:04 <copumpkin> I knew it
21:31:06 <Cale> Yeah, if you're going to sell your soul to hashing, use Data.HashMap from unordered-containers
21:31:14 <ddarius> copumpkin: You should do all your future communication through stick figure comics.
21:31:17 <mgsloan> ahh that's the one
21:31:34 <copumpkin> ddarius: I already try to!
21:31:38 <shachaf> copumpkin: Drop the "le" in the future, though.
21:31:43 <copumpkin> shachaf: :(
21:31:57 <Cale> le "le"
21:32:08 <ddarius> copumpkin: Noone likes the French.  Not even the French.
21:32:11 <shachaf> copumpkin: That smiley face doesn't look like much of a comic to me.
21:32:13 <copumpkin> le french
21:33:26 * mgsloan goes and removes HashTable from toyframework...
21:33:29 <Cale> ddarius: Eventually, language will be obsoleted in favour of linking to pre-existing captioned pictures of cats and stick figures.
21:33:48 <copumpkin> shachaf: http://snapplr.com/0p2q
21:33:57 <mgsloan> this stuff really outta be deprecated
21:34:01 <osoleve> okay, so for this array, do I need to learn how state works, or is it enough to have a lookup function?
21:34:15 <Cale> osoleve: What operations are important?
21:34:18 <ddarius> Cale: I'll be dead by then... one way or another...
21:34:33 <Cale> osoleve: If you're mostly reading, you can just use an immutable array
21:35:01 <osoleve> Cale, just reading, that's all. The array is going to be created at the startand never modified.
21:35:06 <Cale> If you're doing lots of tiny updates, maybe you'd prefer a mutable array, or just switch to Data.Map or Data.HashMap
21:35:17 <Cale> Well, in that case, an immutable array is perfect
21:35:22 <osoleve> awesome, thanks
21:35:35 <Cale> Take a look at Data.Array
21:35:55 <osoleve> Data.Array.IArray?
21:37:12 <Cale> that too, that's the more general interface for various immutable array types
21:37:28 <osoleve> mmk
21:37:35 <Cale> (There are boxed and unboxed immutable arrays of various sorts which all implement the IArray class)
21:37:55 <osoleve> what's the difference between boxed and unboxed?
21:38:17 <Cale> boxed allows for lazy expressions being stored in each cell which are computed on demand
21:38:18 <mauke> (# X #) <- boxed;  X <- unboxed
21:38:35 <Cale> but each cell is a pointer to code, essentially
21:38:43 <osoleve> Cale, okay, makes sense. thanks.
21:38:51 <Cale> unboxed is more like a C array -- if any cell is demanded, you have to compute the whole thing
21:39:17 <Cale> (but the elements are stored directly)
21:43:30 <copumpkin> @tell koninkje_away I was thinking about free monoids and free commutative monoids and then thinking about the sum-product algorithm and whether a graph counts as a free semiring, and I googled "free semiring" and found a post by you talking about very similar stuff. Any more thoughts on the matter?
21:43:30 <lambdabot> Consider it noted.
21:43:50 <copumpkin> of course, when he's not away, he won't have _away on his nick, and lambdabot won't notify him of my message...
21:43:58 <copumpkin> oh, the dilemma 
21:44:13 * copumpkin is troubled by countless dilemmata 
21:44:19 <shachaf> copumpkin: @tell koninkje /nick koninkje_away; /msg lambdabot @messages
21:44:27 <shachaf> Or just make another comic.
21:44:35 <osoleve> comic!
21:44:36 <copumpkin> good idea
21:45:22 <ion> @tell *away Away nicks? SERIOUSLY?
21:45:23 <lambdabot> Consider it noted.
21:45:43 <djahandarie> Haha
21:45:44 <shachaf> Oh, that message'll never get delivered.
21:46:03 <shachaf> ion: Thanks for wasting lispy's RAM.
21:46:29 <ion> Yeah, it takes a megabyte per character because Haskell can only represent strings as linked lists.
21:46:46 <djahandarie> Haha
21:47:12 <shachaf> And GHC uses 8388608-bit pointers. Just in case.
21:47:35 <monochrom> and haskell wants to do unicode correctly with forward compatibility for the next 10000 years i.e. may need 1000000000 bits per character
21:47:39 <ion> > logBase 2 8388608
21:47:40 <lambdabot>   23.0
21:47:45 <mauke> preflex: quote Yaakov IP
21:47:45 <preflex>  <Yaakov> I am on IPv10. The addresses are 4GB.
21:48:29 <monochrom> 4GB ought to be enough for everybody's IP
21:52:42 <Cale> We could always have gone with an unbounded address scheme, but no.
21:53:25 <osoleve> an array that stores strings and is indexed by pairs of (String, Double) would have the type Array String (String, Double), yes?
21:54:29 <osoleve> or is it the other way around?
21:55:01 <Cale> other way around, except you can't index by String
21:55:14 <Cale> (or Double)
21:55:29 <osoleve> well... foo.
21:55:38 <Cale> You may want a Map for that, but indexing any datastructure by Doubles is pretty fragile
21:55:42 <shachaf> You can index by Bool, though!
21:56:12 <rothwell> Prelude> (\(x :: a, y :: a) -> [x, "hi"])
21:56:13 <rothwell> ghc: panic! (the 'impossible' happened)
21:56:15 * rothwell sighs
21:56:47 <Cale> lol, what?
21:57:12 <Cale> awesome
21:57:15 <rothwell> seems it's not happy with scoped type variables
21:57:21 <mauke> works here
21:57:26 <rothwell> colleague may be reporting it as i speak, if there's not one filed already...
21:57:29 <djahandarie> Do you have -XScopedTypeVariables on or not?
21:57:35 <rothwell> yeah, it's on
21:57:41 <Cale> I get the same panic. GHC 7.0.3 for Linux x86
21:57:52 <rothwell> 7.0.2, linux x86, here
21:57:57 <rothwell> also on darwin x86
21:58:04 <djahandarie> A regression apparently, it's fine in 6.12.1
21:58:05 <jmcarthur> same, x86_64
21:58:08 <jmcarthur> linux
21:58:12 <mauke> 6.10.2 ok
21:58:21 <jmcarthur> 7.0.2
21:58:30 <jmcarthur> i suck at giving my specs and versions
21:58:41 <djahandarie> "A pattern type signature cannot bind scoped type variables `a' unless the pattern has a rigid type context" is what 6.12.1 says
21:59:28 <osoleve> can I index by (Char, Int)?
21:59:51 <Cale> yes
21:59:56 <osoleve> nifty.
22:00:05 <applicative> djahandarie: 7.0.3 says the same here.
22:00:27 <copumpkin> okay my creation for koninkje_away is complete
22:00:32 <copumpkin> shachaf
22:00:56 <shachaf> copumpkin: ?
22:02:26 <copumpkin> shachaf: http://cheezburger.com/View/4666405888
22:03:19 <copumpkin> @tell koninkje http://cheezburger.com/View/4666405888 any thoughts?
22:03:20 <lambdabot> Consider it noted.
22:03:43 <mauke> "le"
22:03:51 <mauke> fucking annoying
22:03:54 <copumpkin> :(
22:04:20 * applicative considers clicking "Flag this as inappropriate."
22:04:25 <copumpkin> :(
22:04:28 * applicative doesnt really
22:04:39 * shachaf really does consider it.
22:04:44 <copumpkin> :(
22:05:04 <copumpkin> this took a lot of work!
22:05:16 * shachaf doesn't flag.
22:05:27 * applicative neither
22:05:38 * copumpkin heaves a sigh of relief 
22:05:38 <shachaf> #haskell is turning into Reddit.
22:05:49 <applicative> shachaf+
22:05:58 * applicative cant remember how to 'upvote'
22:06:12 <shachaf> applicative: Don't worry, you gave me half a karma point there.
22:06:37 <jmcarthur> ++
22:06:57 <shachaf> ++jmcarthur // For efficiency.
22:07:18 <copumpkin> I don't think that makes much of a difference in most c++ compilers nowadays
22:07:23 <copumpkin> for most situations
22:07:29 <copumpkin> don't quote me on that though
22:07:44 <mauke> and it doesn't work on irc
22:07:52 <shachaf> s/irc/lambdabot/
22:11:52 <copumpkin> roconnor: you got a blog post response
22:14:07 <ddarius> copumpkin: It doesn't for primitive types.  For overloaded operators though...
22:14:19 <copumpkin> oh yeah, sure
22:15:00 <ddarius> copumpkin: Sets are free commutative idempotent monoids.
22:15:01 <shachaf> copumpkin: You aren't calling jmcarthur a primitive type, are you?
22:15:43 <copumpkin> ddarius: fair enough, the "lists regarded as" bit is redundant I guess, if you ignore all the listiness anyway (as I was doing)
22:15:53 <copumpkin> and makes them less free
22:15:59 <copumpkin> since they have junk 
22:16:14 <td123> I used the cabal command to install the library bitmaps, and now I would like to generate hscolour documentation for it, how would I go about it?
22:16:26 <td123> I installed the package like "cabal install bitmaps"
22:16:43 <copumpkin> ddarius: so a (possibly-empty) set is a free bounded semilattice?
22:16:46 <td123> but "cabal hscolour bitmaps" says I need to specify <pkgname>.hs
22:17:36 <danharaj> Can you derive Enum for types that are just finite sums?
22:29:29 <luqui> danharaj, you mean data Foo = Bar | Baz deriving (Enum) ?
22:29:30 <ddarius> copumpkin: Since I think you are thinking of operations like union, you would have elements sets and so you would be talking about the powerset type which, in the finite case, does have a bounded semilattice structure freely generated from the elements.
22:31:15 <ddarius> The complete lattice generated from a set is the powerset.
22:39:41 <vegai> hmm, is there a nice place inside the ghc source package where I can see the version numbers of all included libs
22:40:59 <tjgillies> how do i make this work? (++)<$>getLine <*>pure " " <*>getLine
22:41:15 <vegai> well, perhaps I'll just grep through all the .cabal files
22:41:40 <vegai> tjgillies: is this a haskell golf assignment?
22:42:03 <tjgillies> vegai: just a hobbyist tring to grok the language
22:42:08 <tjgillies> trying*
22:42:13 <shachaf> (++)<$>((++)<$>getLine<*>pure" ")<*>getLine
22:42:28 <vegai> was <*> a functor thing?
22:42:34 <tjgillies> shachaf: thanks
22:42:52 <vegai> no, Applicative
22:43:19 <vegai> tjgillies: I guess you've read through http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux ?
22:43:45 <Axman6> :t mconcat [getLine, pure " ", getLine]
22:43:45 <lambdabot>     No instance for (Monoid (IO String))
22:43:46 <lambdabot>       arising from a use of `mconcat' at <interactive>:1:0-35
22:43:46 <lambdabot>     Possible fix: add an instance declaration for (Monoid (IO String))
22:43:53 <Axman6> hmm
22:44:02 <tjgillies> vegai: im on there now, im trying to tweak it in fun ways not documented by the book, thus being in irc for augmented help
22:44:08 <vegai> aye
22:44:20 <Axman6> :t concat <$> sequence [getLine, pure " ", getLine]
22:44:20 <lambdabot> IO [Char]
22:44:31 <vegai> I'm wondering whether it's bad coding practice to actually use Functor or Applicative
22:44:40 <shachaf> @ty sequence -- Ahem.
22:44:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:44:54 <tjgillies> vegai: its purely for educational purposes ;)
22:45:10 <vegai> tjgillies: yeah, that's perfectly ok
22:45:30 <shachaf> @ty foldr (liftA2 (++)) (pure []) [getLine, pure " ", getLine]
22:45:31 <lambdabot> IO [Char]
22:46:15 <vegai> well, perhaps it's ok. Perhaps functors should be considered basic haskell knowledge?
22:46:33 <shachaf> vegai: Why would it be bad coding practice?
22:47:07 <vegai> shachaf: my reasoning was along the lines of "it makes code harder for read for the other guy"
22:47:20 <ion> Harder, as opposed to what?
22:47:29 <tjgillies> easier ;)
22:48:13 <vegai> opposed to a less declarative approach
22:48:48 <vegai> I'm genuinely wondering and thirsty for reasons that I'm wrong and that they're actually cool
22:49:08 <tjgillies> fmap is a functor, i think its pretty handy
22:50:09 <vegai> yes, I suppose Functor is just a weirder name for "mappable" :P
22:50:32 <vegai> and Applicative is a weird name for ?
22:51:13 <shachaf> "Applicative Mappable".
22:52:09 <blackh> vegai: Able to suck functions into it
22:52:22 <tjgillies> "special mappable" heh
22:52:44 <vegai> FunctionVacuum
22:55:21 <tjgillies> they're good for list comprehensions
22:55:35 <tjgillies> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
22:56:38 <shachaf> > filter (>50) . getZipList $ (*) <$> ZipList [2,5,10] <*> ZipList [8,10,11]
22:56:40 <lambdabot>   [110]
22:57:11 <applicative> > filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
22:57:11 <lambdabot>   [55,80,100,110]
22:58:04 <td123> wow, is this bug for real... cabal hscolour, The program hscolour version >=1.8 is required but it could not be found, cabal info hscolour Versions installed: 1.17
22:58:41 <Jonno_FTW> td123: it requires >= 1.8, but you have 1.17
22:58:55 <td123> 17 > 8
22:58:56 <Jonno_FTW> wait
22:59:01 <Jonno_FTW> oh
22:59:04 <Jonno_FTW> :|
22:59:08 <applicative> td123: no it's just cabal straining at some insane dependencies
22:59:09 <Jonno_FTW> edit the cabal file then
22:59:46 <shachaf> Is 1.17 > 1.8 in Cabal version numbers?
22:59:46 <applicative> td123 what were you installing?
23:00:04 <td123> applicative: cabal hscolour
23:00:12 <td123> applicative: not installing anything, just want docs
23:00:14 <ion> (<$>) takes a function and draws the value x from its second parameter, applying the function into x. (<*>) draws function f from its first parameter, draws the value x from its second parameter and applies f to x. An example: (,) <$> [0,1,2] <*> [3,4,5]: Draw x from [0,1,2] and apply (,) to x. That results in [(0,), (1,), (2,)]. Then draw f from that list of functions (for List, that’s akin to “for each”), draw x from [3,4,5] and apply f to x. So, for each f in
23:00:20 <ion> [(0,), (1,), (2,)]: for each x in [3,4,5]: append f x to result.
23:00:21 <ion> > (,) <$> [0,1,2] <*> [3,4,5]
23:00:21 <lambdabot>   [(0,3),(0,4),(0,5),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
23:00:28 <ion> vegai: ↑
23:01:30 <applicative> shachaf: 17 > 8 in cabalese
23:01:36 <Dashkal> @unmtl StateT s (ReaderT r IO) a
23:01:36 <lambdabot> s -> r -> IO (a, s)
23:02:05 <shachaf> applicative: And dots separate integers?
23:02:07 <td123> applicative: I just want documentation for the bitmaps library because it seems like a good one, but there is no online docs that I could find :S
23:02:51 <applicative> shachaf, yes thats my understanding.  see e.g. http://hackage.haskell.org/package/hscolour
23:03:06 <td123> btw, why does http://hackage.haskell.org/package/bitmaps not include any online docs?
23:04:09 <applicative> td123: puzzling, it didnt get haddocked, look at the previous version
23:04:34 <applicative> td123 http://hackage.haskell.org/package/bitmaps-0.2.5.1
23:04:41 <td123> ah
23:04:48 <td123> applicative: oh, here http://hackage.haskell.org/packages/archive/bitmaps/0.2.6.0/logs/failure/ghc-7.0
23:05:01 <td123> applicative: that might be why.. but I just installed it fine using cabal
23:07:49 <td123> hmm, I'm still a nub at this, but does bitmaps provide a way to load an actual bitmap?
23:08:05 <shachaf> Who would use that?
23:09:21 <td123> I'm looking forward to using haskell to do a lot of things with raw data
23:10:24 <applicative> td123: where are the data coming from?
23:11:11 <td123> from images
23:11:43 <applicative> image files?
23:11:47 <td123> yes
23:12:18 <td123> the main goal is to easily load an image (don't care what format) into [(x,y,r,g,b)]
23:13:50 <td123> once I have that, I can start experimenting with some algorithms I've been working on
23:14:00 <blackdog> lists mightn't be ideal there...
23:14:42 <td123> I'm a nub, if you know something let me know :)
23:16:00 <blackdog> td123: is probably fine for playing around with. you just won't have fast random access to the list
23:16:13 <accel> has yesod latest
23:16:16 <accel> been released yet finally?
23:16:40 <td123> blackdog: don't need random, I just need to process the list sequentially
23:16:50 <applicative> td123 http://hackage.haskell.org/packages/archive/bmp/1.1.1.2/doc/html/Codec-BMP.html is interesting since it's bound up with the avant garde repa library
23:17:59 <td123> ok, well thanks for all the help, I'm off to bed now, it's way too late :(
23:20:55 <applicative> td123 http://repa.ouroborus.net/
23:21:56 * applicative keeps accidentally triggering the video for hp printers on Prof. Harper's 'blog'
23:22:21 * roconnor totally doesn't understand Bram's git post
23:22:33 * roconnor finds it as confusing as his own.
23:22:47 * applicative wonders where brams git post is
23:23:04 <roconnor> http://bramcohen.livejournal.com/74462.html
23:25:14 <sm> ack.. no HP for OSX 10.5
23:27:44 <applicative> sm, i will send you my install disk.  or is it ppc?
23:28:52 <sm> applicative: no intel.. thanks, what is your install disk ?
23:29:12 <sm> did you build the installer ?
23:29:15 <applicative> i just meant for OS X 10.6 :)
23:29:24 <sm> ahh very kind :)
23:34:19 <applicative> sm, there are installers for power whatever macs, which i think can at best run 10.5.  so in the view of the Haskell Community, you are just being contrary in not updating.
23:35:51 <applicative> oh, the latest I can see, though, is 7.0.1.  
23:36:43 <applicative> roconnor, can you get git to do things like what bramcohen is talking about.  the re-emergence of B is very pleasing.
23:37:38 <roconnor> applicative: I don't know what bram is talking about
23:43:36 * roconnor in unrelated comments, I find it pecular that people say darcs is complicated because it has a theory behind it, while other dvcs are simpler because they have no theory what-so-ever.
23:44:14 <rothwell> think that applies to just about everything
23:53:40 <ChongLi> hey
23:53:55 <ChongLi> is there any way to rewrite these 6 lines as a foldr?
23:53:57 <ChongLi> http://hpaste.org/45799/fold
23:57:07 <roconnor> ChongLi: a foldr on p?
23:57:21 <ChongLi> yeah
23:57:31 <roconnor> ChongLi: producinga  6, tuple?
23:57:38 <ChongLi> it can be a list
23:57:48 <ChongLi> all of those are the same type (Int)
23:58:15 <roconnor> ChongLi: I don't see any useful way of turning that into a foldr
23:58:27 <ChongLi> damn, figured as much
23:58:35 <roconnor> also (!) is a function that is gernally avoided
23:58:41 <roconnor> at least in serious code
23:58:57 <ChongLi> well, p is an unboxed array of ints
23:58:58 <sm> would someone have a function to count days between two dates ?
23:59:05 <shachaf> roconnor: Why?
23:59:35 <roconnor> lists are not well designed for random access
23:59:44 <shachaf> roconnor: List access is (!!). This is (!).
23:59:53 <sm> aha, diffDays
