00:12:39 <ddarius> copumpkin: Didacticism in the modern age.
00:16:07 <dobblego> is there a shorthand in Control.Monad.State for \f -> StateT (Identity . f) ?
00:17:04 <dolio> @type \f -> StateT (Identity . f)
00:17:05 <lambdabot> forall a s. (s -> (a, s)) -> StateT s Identity a
00:17:11 <shachaf> @ty state
00:17:11 <lambdabot> forall s a. (s -> (a, s)) -> State s a
00:17:18 <dobblego> oh yay thanks
00:23:08 <roconnor> do any haskell web servers support ssl?
00:24:27 <dobblego> @type  \j k -> state (j &&& k)
00:24:28 <lambdabot> forall s a. (s -> a) -> (s -> s) -> State s a
00:51:43 <espringe> http://hpaste.org/paste/45480/compile_error_annotation#p45481
00:51:43 <espringe> I swear I must be retarded. Anyone see what's wrong? 
00:53:43 <dobblego> espringe: where is the source?
00:53:56 <espringe> dobblego: scroll up
00:54:05 <espringe> Or if you mean, where I got it from -- I wrote it
00:55:19 <dobblego> espringe: you're missing a )
00:55:39 <dobblego> oh sorry, nothing
00:56:07 <dobblego> oh yes, you are
00:56:13 <espringe> dobblego: No, I think you're right! The first ( on line 26 isn't terminated
00:56:16 <espringe> Ty!
00:56:23 <espringe> I told you i was retarded :D
01:30:28 <alderz> how can I transform an Int to a Fractional?
01:30:49 <sipa> :t (%)
01:30:50 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
01:31:22 <shachaf> > fromIntegral 5 :: Double
01:31:23 <lambdabot>   5.0
01:31:56 <alderz> thanks
01:32:47 <alderz> and there was I function that reversed the arguments of another function, which was it?
01:33:42 <shachaf> @hoogle (a -> b -> c) -> b -> a -> c
01:33:43 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
01:33:43 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
01:33:43 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
01:34:26 <alderz> thanks again
01:38:28 <rostayob> this happened when compiling snap: http://hpaste.org/45482/ghc_panic
01:39:00 <mjrosenb> rostayob: congrats!
01:39:39 <rostayob> thanks! but I didn't write the code lol
01:41:05 <rostayob> mjrosenb: oh great, the archlinux people broke it: https://bugs.archlinux.org/task/23247
01:43:44 <rostayob> ah no, it's been fixed but not updated
02:05:17 * hackagebot cprng-aes 0.2.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.2.0 (VincentHanquez)
02:16:08 <Phyx-> gm
02:35:49 <markmywords> is it possible to have type parameters in a record definition?
02:36:30 <mjrosenb> eh?
02:37:09 <JoeyA> data Record a = Record {foo :: a -> String}
02:37:12 <JoeyA> Like that?
02:38:17 <mjrosenb> both type aliases and newtype support type parameters like that.
02:38:28 <mjrosenb> err...
02:38:39 <mjrosenb> yes... i totally read the question correctly
02:40:47 <isomorph> I'd like to generate a list of integers for quickcheck - I plan to use something like forAll (generate size num) $ (\list) -> in my test
02:41:00 <isomorph> what's wrong with this generator function? 
02:41:13 <isomorph> list size 0 = []
02:41:24 <isomorph> list size num = (\x -> x `mod` size) `fmap` (arbitrary) : listFor size (num-1)
02:41:26 <isomorph> ? 
02:41:48 <isomorph> (i get a type error :( ) 
02:42:33 <mjrosenb> :t arbitrary
02:42:34 <lambdabot> forall a. (Arbitrary a) => Gen a
02:42:50 <spidermario> :info Gen
02:42:55 <spidermario> @info gen
02:42:55 <lambdabot> gen
02:43:00 <spidermario> @info Gen
02:43:00 <lambdabot> Gen
02:43:03 <spidermario> hm.
02:43:30 <spidermario> :t listFor
02:43:31 <lambdabot> Not in scope: `listFor'
02:43:40 <mjrosenb> what is listFor?
02:43:42 <isomorph> ah - sorry, that should be 'list' 
02:43:46 <isomorph> it's a recursive function
02:44:08 <isomorph> I mean to create the list by appending the n-1 case
02:45:18 <mjrosenb> can you paste the type error it gives you?
02:45:40 <isomorph>     Couldn't match expected type `Gen a0'            with actual type `[Gen Integer]'
02:46:38 <mjrosenb> try putting parens around everything to the left of ":".
02:47:40 <isomorph> hrmm- still no go - same error
02:48:49 <mjrosenb> how about you explicitly type arbitrary as Gen Int?
02:49:41 <isomorph> still no love.  what's odd is that the expected type isn't a list type
02:49:52 <lars9> when Typeable is needed?
02:49:54 <isomorph> i assume that means
02:50:23 <isomorph> that this expression expects something other than a list? 
02:50:27 <isomorph> forAll (list size num) $ \(list) -> 
02:50:36 <mjrosenb> what do i need to import for quickcheck?
02:51:32 <Saizan> ?type Test.QuickCheck.list
02:51:32 <lambdabot> Not in scope: `Test.QuickCheck.list'
02:51:50 <isomorph> import Test.QuickCheck
02:51:53 <Saizan> isomorph: you've to use sequence
02:52:14 <isomorph> Saizan: ? where? 
02:52:18 <Saizan> forAll (sequence $ list size num) $ \list -> ...
02:52:55 <isomorph> ah ... 
02:52:55 <Saizan> because your list produces a [Gen Integer] but you need a Gen [Integer]
02:53:44 <erus`> a list is a monad? 
02:54:23 <Saizan> the list type constructor is an instance of Monad
02:54:49 <erus`> oh god
02:54:50 <Saizan> a specific list, i.e. a value of that type can be seen as a monadic action
02:55:00 <isomorph> :t sequence
02:55:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:55:05 <Saizan> but here it's not the case
02:55:43 <erus`> i watched an hour long video last night of some guy trying to explain monads, then slept on it. I still don't really get it
02:55:56 <isomorph> Works :) 
02:55:59 <isomorph> Thanks Saizan !
02:56:01 <Saizan> sequence glues together a list of actions of some monad to form a single action that returns a list of the results of those actions
02:56:43 <erus`> Saizan: like do?
02:57:02 <Saizan> well, do is just syntax
02:57:16 <isomorph> and thanks mjrosenb !
02:57:50 <Saizan> do x; y; z; <- you only get the result of z out of this, also
02:58:22 <Saizan> erus`: anyhow, there isn't much to understand about Monad, it's just a convenient but very general interface
03:00:10 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation <- i recommend this + getting familiar with some of the instances, e.g. Maybe, List, Reader, State ..
03:29:39 <Phyx-> is there A way in a cabal file to say, that a package depends on ghc >= 6.12 except 7.0.1?
03:32:03 <rostayob> I've got a piece of software that goes well for like, half an hour and then goes to 100% CPU. I can't really relate the problem with some external factor, what's the best way to analyze something like that? profiling?
03:33:13 <rostayob> profiling?
03:35:42 <Eelis> Phyx-: you can specify an upper bound on the version if you like
03:36:34 <Veinor> i think he wants 7.0.2 and 7.0.3 to be allowed as well
03:37:25 <Eelis> GHC >= 6.12, /= 7.0.1   <- this might just work.
03:37:37 * Phyx- tries
03:37:53 <Eelis> or perhaps && instead of a comma
03:38:49 <Phyx-> doesn't parse
03:39:04 <Eelis> ok, then i'm at a loss
03:39:39 <Phyx-> don't think cabal supports /= for the fields does it?
03:40:02 <aristid> does cabal some kind of or?
03:40:29 <Phyx-> idk, *looks at manual*
03:43:07 <Phyx-> hmm it does, so i could do ghc >= 6.12 && < 7.0 || ghc >= 7.0.2
03:44:09 <Phyx-> yeah, that seems to work
03:44:31 <Eelis> you could file a feature request for /=
03:47:04 <Phyx-> Eelis: yeah i'll write one up later
03:47:13 <Phyx-> hmm the accepted version looks kinda weird
03:47:16 <Phyx-> ">= 6.12 && < 7.0 || >= 7.0.2,"
03:47:18 <Phyx-> lol
04:09:56 <cartouche> hello
04:10:03 <Phyx-> hello
04:10:19 <cartouche> how can I remove an element of list?
04:10:28 <Phyx-> :t delete
04:10:29 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
04:12:49 <Phyx-> > 1 `delete` [1,1,2]
04:12:50 <lambdabot>   [1,2]
04:13:27 <Phyx-> > filter (/=1) [1,1,2]
04:13:27 <lambdabot>   [2]
04:14:28 <aristid> :t guard >>= return
04:14:29 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:14:53 <Phyx-> isn't that just guard?
04:14:56 <Phyx-> :t guard
04:14:56 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:15:14 <aristid> @pl \x -> guard x >> return x
04:15:14 <lambdabot> liftM2 (>>) guard return
04:15:38 <aristid> infix applicative syntax would be nice :)
04:40:34 <espringe> Is there any way to get a "backtrace". I've got this weird error (a function that's getting called with arguements it shouldn't. And I'm throwing an exception via 'error'). But what I want to know is what function is calling it
04:40:44 <espringe> So i really kind of need a "backtrace" 
04:41:13 <MasseR> espringe: ghci supports trace
04:41:47 <hpc> @quote oasis
04:41:47 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:42:14 <navaati> hello
04:46:22 <navaati> there is a rmonad package providing context restricted monads, is there aswell a package or even an implementation somewhere providing context restricted arrows ?
04:52:09 <Cin> Anyone successfully using Scion and with what versions of everything?
04:54:12 <Phyx-> Cin: you're asked that before :P
04:59:53 * hackagebot swish 0.3.0.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.0.1 (DouglasBurke)
05:01:48 <tomh-> hey guys, what are some nice books about advanced topics in functional programming?
05:05:53 <McManiaC> does HDBC support SQL arrays?
05:12:49 <byorgey> tomh-: I recommend "Pearls of Functional Algorithm Design" by Richard Bird
05:13:08 <tomh-> cool thanks
05:13:23 <tomh-> same stuff as covered in CLRS?
05:13:30 <tomh-> or whatever that algorithm book is called
05:13:41 <byorgey> no, not really
05:14:38 <byorgey> I mean, there's some overlap, but PoFAD is just a collection of beautiful explorations on selected topics, not a comprehensive reference work like CLRS
05:14:55 <luite_> tomh-: for more theory and background, you might like "Types and Programming Languages" by Benjamin Pierce
05:15:08 <tomh-> yeah got that on my list
05:15:31 <tomh-> and purely functional datastructures
05:15:37 <tomh-> I might order those 3 then
05:32:03 <rothwell> anyone got any idea how to use protocol-buffers? i use them regularly in java but the package on hackage is mystifying...
05:35:09 <rothwell> the documentation also mentions a 'hprotoc' tool that the package doesn't seem to provide
05:35:57 <rothwell> oh... maybe that's a separate package
05:37:01 <Botje> yeah, i just saw it
05:37:19 <Botje> presumably that hprotoc generates haskell code you can import
05:37:28 <Botje> (or C with FFI bindings)
05:37:34 <rothwell> yeah
05:37:49 <rothwell> from the stuff the package is building, it looks like it might be haskell code
05:40:19 <McManiaC> uhm
05:40:40 <McManiaC> how do you safely convert a ClockTime from the old-time package to a UTCTime from the current time package?
05:42:22 <winmike> hi
05:42:29 <Phyx-> hi
05:43:10 <winmike> i try to understand the basics of lambda functions. can anybody tell me whats going on in "(\x -> \y -> (x.y.x)) (sum) (\y -> [y,y]) [1,2,3]"? found this example but doesnt understand it :-((
05:44:17 <winmike> \x -> \y -> (x.y.x) i redfactored to "\x y -> (x.y.x)" but i still dont undertsand why there are 3 params possible ...
05:44:44 <Veinor> :t \x y -> (x . y . x) is a function that takes
05:44:45 <lambdabot> Not in scope: `is'
05:44:45 <lambdabot> Not in scope: `function'
05:44:45 <lambdabot> Not in scope: `that'
05:44:46 <Veinor> whoops
05:44:48 <Veinor> :t \x y -> (x . y . x)
05:44:49 <lambdabot> forall a b. (a -> b) -> (b -> a) -> a -> b
05:45:34 <winmike> hmm
05:45:49 <tener_> my program has just crashed with: Heap exhausted;
05:45:49 <tener_> Current maximum heap size is 2147483648 bytes (2048 MB);
05:45:49 <tener_> use `+RTS -M<size>' to increase it.
05:45:49 <tener_>   74,327,577,780 bytes allocated in the heap
05:45:49 <tener_>    3,827,968,124 bytes copied during GC
05:45:50 <tener_>    1,037,845,560 bytes maximum residency (22 sample(s))
05:45:52 <Veinor> so \x y -> x . y . x is a function that takes two functions and returns a function
05:45:52 <tener_>       29,686,148 bytes maximum slop
05:45:54 <tener_>             1339 MB total memory in use (0 MB lost due to fragmentation)
05:46:00 <tener_> what is actually the memory usage here?
05:46:16 <Jafet> tener: that depends on what you mean by usage
05:46:28 <winmike> Veinor, hmm thx
05:46:38 <Jafet> If you mean the largest amount of memory used at any one time, that's "maximum residency"
05:46:41 <tener_> Jafet: ok, so what does 1339 MB in use mean?
05:47:21 <Jafet> Not sure where the extra 350MB comes from, though
05:47:28 <tener_> I'm asking why one part says 2048 MB and the other 1339 MB 
05:47:51 <Jafet> I believe GHC uses a copying collector
05:48:01 <Jafet> So it needs two pools of memory
05:48:22 <Jafet> 1,037... bytes is about 1GB, or half of the heap size
05:49:28 <winmike> Veinor, hmm. so he automaticly expects a function for x and y because of the "." at the right?
05:49:36 <winmike> because "." only works on functions?
05:49:39 <Jafet> :t (Prelude..)
05:49:40 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:49:59 <winmike> ah ok - now its clear
05:50:02 <pmurias> is using quick check for assertions that don't take an argument sane?
05:50:04 <Jafet> In standard haskell, yes
05:51:48 <pmurias> Jafet: that was the answer to my question?
05:52:04 <Jafet> pmurias: I guess it makes sense if you want to use the quickcheck framework for everything
05:52:45 <Jafet> Is there Arbitrary ()?
05:52:52 <Jafet> @check \() -> True
05:52:53 <lambdabot>   "OK, passed 500 tests."
05:52:59 <Saizan> pmurias: so they are just Bool, or are you using forAll?
05:53:01 <Jafet> lol 500 tests
05:53:03 <Saizan> @check True
05:53:04 <lambdabot>   "OK, passed 500 tests."
05:54:25 <Alan> Something i never seem to remember: does composition bind tighter than application?
05:54:35 <Jafet> Application binds over everythin
05:54:45 <Jafet> You can pretend it's precedence 11
05:54:57 <Alan> ok
05:55:01 <Alan> that explains a lot
05:55:04 <Jafet> Composition is just an ordinary operator
05:55:06 <Jafet> @src (.)
05:55:06 <lambdabot> (f . g) x = f (g x)
05:55:06 <lambdabot> NB: In lambdabot,  (.) = fmap
05:56:25 <Jafet> tener, seems that I was wrong: http://hackage.haskell.org/trac/ghc/wiki/GarbageCollectorNotes
05:56:59 * hackagebot normaldistribution 1.1 - Minimum fuss normally distributed random values.  http://hackage.haskell.org/package/normaldistribution-1.1 (BjornBuckwalter)
05:59:15 <spidermario> @check False
05:59:16 <lambdabot>   "Falsifiable, after 0 tests:\n"
06:00:48 <markmywords> what is the backslash for? \
06:01:07 <spidermario> TIL that False is falsifiable
06:02:35 <Veinor> @check True
06:02:36 <lambdabot>   "OK, passed 500 tests."
06:03:17 <Jafet> @check unsafePerformIO (randomRIO (False, True))
06:03:17 <lambdabot>   Not in scope: `unsafePerformIO'
06:06:36 <pmurias> how can i make cabal test run QuickCheck tests
06:06:37 <pmurias> ?
06:11:42 <spidermario> @check System.IO.unsafePerformIO (randomRIO (False, True))
06:11:43 <lambdabot>   Not in scope: `System.IO.unsafePerformIO'
06:12:02 <spidermario> @check System.IO.Unsafe.unsafePerformIO (randomRIO (False, True))
06:12:03 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
06:12:16 <Phyx-> lambdabot is sandboxes
06:12:23 <Phyx-> you can't use unsafePerformIO
06:12:25 <spidermario> @check GHC.IO.unsafePerformIO (randomRIO (False, True))
06:12:25 <lambdabot>   Not in scope: `GHC.IO.unsafePerformIO'
06:12:35 <Phyx-> sandboxed*
06:15:25 <djame> hi
06:15:52 <Phyx-> hi
06:15:56 <djame> can someone help me to compile a program with the -rtsopts option on ghc7 on mac os X 10.6
06:16:17 <djame> I'm running :  cabal install --ghc-options="+RTS -rtsopts -ticky -RTS" morfette --bindir=$PREFIX/bin/ --datadir=$PREFIX/share 
06:16:28 <djame> and I got this error
06:16:42 <djame> cabal: ghc: the flag -rtsopts requires the program to be built with -ticky
06:17:51 <djame> I even tried to modify the runghc script (at some point) ton include the -rtsopts option but it doesn't work
06:18:33 <Saizan> djame: try ghc-options: in the .cabal file
06:19:19 <djame> the .cabal/config file ?
06:19:37 <Saizan> no the foo.cabal file of this cabal package
06:20:06 <Saizan> "cabal unpack foo" where foo is the name of the package to get the sources
06:20:13 <djame> ok
06:20:21 <djame> I have access to the svn source..
06:20:26 <djame> but it's not their
06:20:28 <djame> waitamn
06:21:08 <djame> so is it the cc-options ?
06:21:12 <djame> (I don't think so)
06:22:13 <djame> ok ghc-options:
06:23:02 <siracusa> djame: -ticky is a GHC option, not a RTS option, isn't it?
06:23:36 <djame> yes, it worked !!!
06:24:00 <djame> siracusa@ i have no idea I'm a total newb in ghc and cabal
06:26:36 <djame> also I have a question
06:26:50 <djame> how to prevent cabal from creating symlinks and all ?
06:35:04 <mercury^> TTimo: are you the id software employee?
06:35:50 <mercury^> Ok, looks as if. :)
06:36:43 <pmurias> deriving Show doesn't seem to work for GADTs, what am i supposed to do? write it manually?
06:39:22 <TTimo> hay
06:39:25 <TTimo> yeah
06:39:48 <mercury^> Thank you for all the linux releases then!
06:40:31 <TTimo> ah :)
06:40:38 <TTimo> yeah it's great to be able to work on those
06:42:01 * ksf thinks a haskellish make should look like a lazy, dynamically-typed timber
06:42:36 <ksf> or at least, dynamically typeable.
06:43:25 <ksf> the main reason for that being compilability into posix sh without going nuts.
06:43:43 <ksf> and more oo-ish because dynamic typing and typeclasses don't blend well.
06:44:52 <rothwell> pmurias: think you can get it using "standalone deriving"
06:46:09 <rothwell> pmurias: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/deriving.html#stand-alone-deriving
06:46:27 <rothwell> at least... it worked last time i wanted to derive Eq... should work for Show too
06:51:27 <rothwell> i just spent an infuriating half hour fighting Network.Socket
06:51:40 <rothwell> there doesn't seem to be any way to tell plain Network not to bind to an ipv6 address
06:51:56 <pmurias> rothwell: thanks, it worked
06:52:21 <rothwell> having changed things to use Network.Socket, i then find (after half an hour of bizarre nonsense) that PortNum requires an integer packed into network byte order
06:52:33 <rothwell> of course, the library doesn't seem to provide a function to do the packing
06:52:44 <rothwell> pmurias: welcome
06:53:48 <rothwell> amusing comment in the source:
06:53:54 <rothwell> -- newtyped to prevent accidental use of sane-looking
06:54:01 <rothwell> -- port numbers that haven't actually been converted to
06:54:03 <rothwell> -- network-byte-order first.
06:54:09 <rothwell> that worked well, didn't it?
06:54:15 <rothwell> PortNum 50000
06:54:22 <rothwell> look at how that's prevented!
06:54:26 <rothwell>  </rant>
06:54:40 * rothwell crawls back under a rock
06:56:10 <roconnor> rothwell: the Networking library for Haskell is a POS and has been for 10 years or so
06:56:51 <ClaudiusMaximus> rothwell: as far as i am aware (which is not very) you should just write 50000 instead of (PortNum 50000) and the Num instance does the right thing
06:57:05 <ClaudiusMaximus> rothwell: i may be confused, and/or wrong
06:57:53 <rothwell> ClaudiusMaximus: there isn't a Num instance for PortNumber
06:58:03 <rothwell> roconnor: hehe, yeah
06:58:12 <ClaudiusMaximus> rothwell: oh, then my second comment stands :)
07:00:02 <ClaudiusMaximus> [ot php rant]  $foo['bar'] fills my logs with errors; (isset($foo['bar'])?$foo['bar']:NULL) leave my logs clean and tidy
07:00:20 <osoleve> how do I signal to hGetContents that it's the end of the data to receive if the handle is a port?
07:00:39 <roconnor> rothwell: I'd be inclined to write new bindings from scratch, but I don't know anything about networking
07:02:36 <rothwell> roconnor: i might
07:02:53 <rothwell> roconnor: depends how much more pain this library inflicts
07:02:59 <roconnor> rothwell: can you make bindings that actually let you set timeouts?
07:03:16 <roconnor> rothwell: there is more to come
07:03:25 * rothwell braces
07:07:02 <erus_> music is just maths
07:07:14 <erus_> the whole world is maths
07:07:27 <erus_> especially women 
07:07:51 <erus_> whats the rules?
07:09:47 <osoleve> is it not possible to use hGetContents on a port and then accept input again afterwards?
07:10:12 <Jafet> That sounds unwise.
07:10:19 <roconnor> osoleve: more or less no
07:10:35 <osoleve> so, whta should I do if I have the server emitting multiple lines of information?
07:10:39 <osoleve> s/whta/what
07:10:57 <roconnor> hGetContents will read multiple lines
07:11:40 <osoleve> right, but then i can't close hGetLines to read more input from the user on the client side
07:11:43 <osoleve> :/
07:11:57 <merijn> Solution, multiple threads
07:12:22 <osoleve> will that cause any memory issues?
07:12:35 <osoleve> multiple occurrences of hGetContents?
07:13:30 <ousado> isn't there an async networking library for haskell?
07:14:16 <Saizan> you shouldn't use hGetContents at all if you don't what to get the whole input as a single String
07:14:17 <merijn> ousado: Not really, because Haskell's network calls are multiplexed by the runtime system
07:15:04 <merijn> ousado: i.e. the blocking calls are implemented using select/epoll/kqueue and since the runtime uses green threads instead of OS threads the assumption is you just use blocking networking in threads
07:15:29 <Saizan> there are bindings to use epoll directly iirc
07:15:53 <merijn> The same for select, but last I looked they weren't that great nor actively maintained
07:16:38 <ousado> merijn:  ah, I see. well, that counts as async :)
07:17:09 <merijn> ousado: Cost me a lot of confusion when I first wanted to do networking to :p
07:17:50 <merijn> But I saw some GHC benchmarks running 100k IO threads without any problems, so I figured by the time I need more then 100k concurrent clients I'll think of something new ;)
07:19:27 <ousado> merijn:  do you know how it deals with stuff like large file up/downloads etc. ?
07:21:28 <merijn> Well, if its really large you probably want to use something like iteratees to have reasonable memory consumption, but I don't have much experience with that
07:25:42 <ousado> merijn: ya nm, just interested, question inspired by osoleves one. thanks :)
07:27:09 * hackagebot alsa-mixer 0.1.2 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.1.2 (ThomasTuegel)
07:27:50 <merijn> Speaking of which, does anyone know any good intro's to the enumerator package (and or iteratees in general)? Oleg's writing is rather...dense and I only half grok what's going on
07:29:57 <elliotstern> Can you create instances of a typeclass for more complex types?  Say, IO String and IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle), in addition to String?
07:30:04 <jmcarthur> merijn: the enumerator package page has a link to a pretty good one i think
07:30:20 <merijn> jmcarthur: Ok, I'll take a look there
07:30:33 <merijn> elliotstern: Yes
07:31:26 <elliotstern> Is there anything special you need to do?  GHC was complaining that all of the types in the type tuple weren't unique, or something
07:31:42 <jmcarthur> merijn: http://www.yesodweb.com/book/enumerator
07:32:25 <jmcarthur> elliotstern: you can write instances like that with an extensions or two, but you have to be careful about overlapping instances
07:32:40 <merijn> jmcarthur: Ah, yeah. That's the one I was reading before but I got stuck halfway because the example code gets kinda convoluted and confusing. I was hoping there was something else to help me make sense of that one
07:32:42 <jmcarthur> elliotstern: e.g., if there is already an instance for lists then an instance for String will overlap with it
07:33:18 <jmcarthur> merijn: sadly, iteratees don't have a great specification beyond their implementation, yet
07:33:34 <jmcarthur> tough to wrap your mind around
07:34:05 <merijn> I've grokked the basic idea of iteratees, but enumerators and actually putting it all together hasn't been that easy
07:34:11 <jmcarthur> merijn: the one i linked to is the best one i know of
07:34:37 <merijn> Time for a LYAH "iteratees" chapter ;)
07:34:43 <jmcarthur> i'd just go back over it and maybe implement it as you go
07:34:56 <jmcarthur> seems like a lot of people don't get it until they rewrite it :\
07:34:57 <merijn> Yeah, that's the new plan
07:35:01 <elliotstern> Mostly, I want to have a log function that can take in one of those three types.  Should I make a Logger typeclass, or should I just have logStr, logIOStr, and logProc?
07:35:38 <merijn> elliotstern: Sounds like a need for the Writer monad? afaik that was intended for logging like things
07:35:51 <jmcarthur> i don't think that applies to the question
07:36:09 <jmcarthur> elliotstern: i'd go with whatever is simplest
07:36:15 <merijn> ^^
07:36:18 <elliotstern> k.
07:36:23 <kstt> hello here. This great post ( http://www.haskell.org//pipermail/haskell/2004-November/014929.html ) is 6 years old. More or less, it args for a clean way to augment the famous "world" in haskell parliance, with in-process mutable cells globally defined. I found it in the archive, and I'm wondering what is the state of the affairs today.
07:36:25 <merijn> That is always the best heuristic :p
07:37:26 <kstt> Or, in other words, do we still have to unsafeperformIO and {# noinline #} to have some in-process top-level defined state.
07:37:31 <merijn> kstt: There are mutable cells in haskell. There's MVars, TVars and IORefs depending on what exactly you need (maybe even more)
07:37:40 <jmcarthur> kstt: currently yes you still have to
07:37:47 <jmcarthur> merijn: i think you aren't reading questions closely enough :P
07:38:03 <Twey> BONUS: 154610 < merijn> Time for a LYAH "iteratees" chapter ;)
07:38:05 <jmcarthur> kstt: JHC has some support for top level IO which can be used for globals though
07:38:06 <Twey> ;)
07:38:07 * merijn is just going to shut up now >.>
07:38:45 <jmcarthur> we should make a bot that answers questions by keyword the way merijn does ;)
07:38:55 <jmcarthur> i'm just picking on you
07:39:05 <merijn> Who says I'm not an elaborate Eliza script
07:39:24 <jmcarthur> yeah, you just picked up on "bot" there
07:39:28 <merijn> And how does we should make a bot that answers questions by keyword the way merijn does make you feel?
07:39:35 <elliotstern> Also, is there a way of holding onto a monadic result when using do notation?  I'd like to hold onto the IO (Maybe Handle, Maybe handle, Maybe Handle, ProcessHandle) without it becoming a  (Maybe Handle, Maybe handle, Maybe Handle, ProcessHandle).
07:39:36 <jmcarthur> lol
07:40:03 <jmcarthur> elliotstern: just pass it around instead of using it
07:40:24 <Twey> ITYM Handle
07:40:30 <Twey> That's a big tuple
07:40:34 <kstt> jmcarthur: thank you. Are you aware of progresses, or at least on-goning discussion regarding this matter ? I'd like to raise my voice there if it can help.
07:40:36 <Twey> Have you considered a datatype?
07:40:42 <jmcarthur> elliotstern: that is, don't do anything like   x <- myHandleHandleHandleHandle
07:40:50 <Twey> Heheh
07:41:16 <jmcarthur> kstt: i think there has been some recent discussion, but i haven't been following it and have no idea where it was
07:41:47 <jmcarthur> kstt: maybe search the ghc trac or ask in #hgc?
07:41:53 <jmcarthur> *#ghc
07:41:55 <kstt> Not that I have something clever to propose, but just reading recent facts and supporting some proposal would make me feel like a good citizen.
07:42:30 <jmcarthur> kstt: JHC's extension is pretty neat. you might want to check it out, even if only to have some ideas for a proposal for ghc
07:44:37 <jmcarthur> dang, i would say all that and then not be able to find anything about it to link to
07:44:42 <jmcarthur> i forget the name of it
07:45:02 <elliotstern> jmcarther: pass it around how?  I was originally doing func1 $ funcReturningResultIWant, but I'd like there to be several lines in between there (in particular, the process I'm starting is a server, so I want to start up some other stuff and then close the server and log it's results after the user tells me to)
07:46:04 <elliotstern> Can I just say "proc = funcReturningResultIWant", or something?
07:46:52 <jmcarthur> elliotstern: yeah, just don't use <- to bind it
07:46:59 <elliotstern> thanks
07:47:01 <jmcarthur> elliotstern: using let foo = ... is fine
07:47:07 <merijn> I would mention let clauses for something like that, but I'm afraid to be wrong again :p
07:47:47 <merijn> Ha! Third time's the charm :>
07:48:48 <jmcarthur> kstt: pretty good summary of everything here though http://www.haskell.org/haskellwiki/Top_level_mutable_state
07:49:36 <kstt> I just read it, good reading indeed
07:49:54 <kstt> I guess I hoped it was obsolete :)
07:50:42 <navaati> @src guard
07:50:42 <lambdabot> guard True  =  return ()
07:50:42 <lambdabot> guard False =  mzero
07:50:49 <navaati> :t guard
07:50:50 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
07:56:25 <Veinor> "This breaks Haskell's tradition of bondage and discipline. "
07:56:27 <Veinor> heh
08:02:17 <rostayob> Does anybody use hsp here?
08:21:42 <merijn> Rings are a monoid? (Or vice versa, monoids are just a subset operations, etc of rings)
08:23:32 <Phyx-> @hoogle Tycon
08:23:33 <lambdabot> Data.Typeable data TyCon
08:23:33 <lambdabot> Language.Haskell.TH TyConI :: Dec -> Info
08:23:33 <lambdabot> Language.Haskell.TH.Syntax TyConI :: Dec -> Info
08:32:16 <Athas> unionBy (\(x,_) (y,_) -> x==y) foo bar
08:32:19 <Athas> How can this be shortened?
08:32:34 <mauke> :t (==) `on` fst
08:32:34 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
08:32:49 <Athas> Oh, on, nifty.
08:34:10 <merijn> :t on
08:34:11 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:34:16 <merijn> ...
08:34:27 <merijn> right.
08:34:53 <NisseP> @src on
08:34:53 <lambdabot> (*) `on` f = \x y -> f x * f y
08:35:14 <NisseP> Though that was kind of obvious, I suppose.
08:35:35 <merijn> It makes sense when I look at the type signature. But it took some time :p
08:38:47 <cheater00> are there version control systems where the changesets form a category (a cs is an arrow)?
08:40:48 <NisseP> I thought they all did..? Since changesets are arrows in a graph of repo states; then, identity is an empty changeset and (.) is concatenation
08:43:36 <cheater00> what about being able to combine changesets in any order?
08:43:46 <cheater00> any amount of changesets in any order..
08:45:54 <rovar> is there anything special that needs to be done to load a module for debugging in ghci?
08:46:10 <rovar> :l  loads the module.. but when I try to set a break on a line.. it says no modules loaded for debugging
08:46:42 <ski> merijn : a ring have a monoid (in fact a(n abelian) group), for the additive structure. if it's a unital ring, it also has a (commutative/abelian) monoid for the multiplicative structure
08:47:52 <ski> (or, hm, maybe the multiplicative structure isn't traditionally required to be commutative, for rings (for fields it is) .. /me checks WP)
08:49:24 <ski> (right, scratch the commutativity for the multiplication)
08:49:26 <merijn> ski: I was always confused what a monoid was supposed to be, it never struck me before that they'd just be structures in the same category as rings, etc
08:50:00 <ski> a monoid is like a group, but with no inverses required
08:50:08 <merijn> Right
08:50:59 <ski> (btw, i presume you don't mean "category" in the sense of "category theory" there ..)
08:51:13 <merijn> Correct :p
08:51:41 <merijn> I still need to read a Category Theory for Dummies book at some point :p
08:51:47 <ski> `monoid' is a kind of algebraic structure, as is `group',`ring',`lattice',...
08:52:17 <ski> all of those can be expressed in the theory of universal algebra
08:52:56 <merijn> Time to go read up on my algebra again...
08:53:06 <ski> <http://en.wikipedia.org/wiki/Universal_algebra>
08:53:26 <ski> you might find that simpler to begin with, instead of going to category theory directly
08:53:27 <pastorn> merijn: isn't this covered in the typeclass-o-pedia?
08:54:25 <Phyx-> merijn: everytime I try reading one.. I kinda fall asleep
08:54:33 <Phyx-> I don't know why, category theory books just knock me out
08:54:42 <pastorn> Phyx-: i see what you mean...
08:55:01 <merijn> ski: I have succeeded in passing two "algebra and discrete math" courses in the past (and I still have the lecture notes lying around) but those were mostly focused on stuff like Z mod p and polynomials.
08:55:09 <pastorn> Phyx-: too much general abstract nonsense :/
08:55:24 <merijn> But I never got to see any connection with things like lists and functions
08:55:30 <Phyx-> hehehehe
08:55:37 <merijn> So I forgot most of that due to lack of any practical applicability
08:55:38 <ski> merijn : btw, that WP page only talks about algebras with one carrier/sort/type, but you can have ones with more than one of those (as well as "constant/parameter" sorts/types)
08:55:42 <Phyx-> pastorn: I eventually would like to know it though, but yeah
08:55:50 <pastorn> merijn: and diophantine equations?
08:56:15 <merijn> pastorn: Never heard of those...
08:56:15 * monochrom likes universal algebra too
08:56:31 <pastorn> merijn: it's how to solve stuff like
08:56:59 <ski> merijn : a very simple example is directed (multi-)graphs : we have two sorts `V' and `E', for vertices and edges, and two operations `src : E >-> V',`tgt : E >-> V', mapping an edge to the source and target vertex of it. and finally we have zero laws
08:57:01 <merijn> Granted, my algebra courses were taught in Dutch which pisses me off in hindsight. Since now I don't know how stuff is called in English when I try to explore further >.>
08:57:06 <pastorn> "you have $11, small cookies are $.5, big ones are $.7, how can you maximize your money?"
08:58:00 <pastorn> merijn: recognize that?
08:58:24 <monochrom> I would maximize my $11 money by using to travel to a place with a lot of rich people, then beg or scam them.
08:58:51 <pastorn> monochrom: excellent choice
08:59:00 <ski> merijn : an example of (what i called above) "constant/parameter" sorts/types is vector spaces : we already have a given ("fixed") field `K', and then a `K'-vector-space has a carrier `V', and two operations `add : V * V >-> V' and `scale : K * V >-> V' satisfying various laws
08:59:04 <merijn> pastorn: Yeah, same stuff like "Which set of 3 coin denominations will give you the lowest average number of coins to pay any price"
09:00:28 <merijn> ski: Yeah, we covered vector spaces, but that's approximately the area I stopped following stuff. In hindsight it was because the prof was lousy. It took me a bunch of attempts at learning collision detection what the base of a vector space meant and what an orthonormal base was
09:00:43 <merijn> As I said, I should probably grab my lecture notes again some time
09:01:13 <ski> merijn : hm .. maybe if you haven't looked at graphs or vector spaces (i.e. linear algebra with vectors and matrices / linear transformations) the above won't be very intelligble to you atm
09:01:23 <ski> ok
09:01:24 <monochrom> if the prof is lousy, his/her lecture notes may hurt. grab a better book.
09:01:42 <monochrom> or kham academy!
09:01:47 <merijn> monochrom: The lecture notes were from some other prof, those actually made a bit of sense
09:01:49 <monochrom> s/kham/khan/
09:02:05 <ski> monochrom : is khan academy good ?
09:02:15 <geheimdienst> s/khan/khaaaaaaan/
09:02:21 <merijn> ski: Khan Academy rules for as far as I have seen
09:02:35 <merijn> I dunno about the more advanced math stuff, but the real basic stuff is excellent
09:02:47 <merijn> ski: Yeah, theoretically I've also passed linear algebra, but that's all buried under huge heaps of more directly applicable info :p
09:03:51 <pastorn> merijn: have you read the typeclassopedia?
09:04:47 <merijn> pastorn: I started a while back, haven't gotten very far
09:04:54 <merijn> So much to read, so little time :(
09:05:15 * ski nods solemnly
09:05:23 <Botje> merijn: read papers on the toilet
09:05:50 <merijn> I read papers during my morning/evening commute :p
09:06:32 <pastorn> merijn: yeah, reading on buses/trains is awesome!
09:06:47 <merijn> Got a Kindle DX for papers :p
09:06:49 <pastorn> unless it's at a time where sleeping is even more owesome
09:06:54 <pastorn> *awesome
09:07:35 <cheater00> i got ap rinter
09:07:37 <cheater00> a printer
09:07:40 <cheater00> it owns the kindle
09:07:46 <pastorn> preflex: seen lispy
09:07:46 <preflex>  lispy was last seen on #haskell 1 day, 11 hours, 33 minutes and 20 seconds ago, saying: That would make me /cheer
09:08:02 <pastorn> cheater00: haha :D
09:08:08 <merijn> cheater00: Printing 263 page phd theses every other week start to become expensive and annoying
09:08:19 <cheater00> i don't read 263 pages every day
09:08:42 <merijn> No, but carrying that many pages around becomes a bother
09:09:17 <cheater00> can't you leave them at home? or do you carry your whole house with you at all times, like some sort of bag lady?
09:09:42 <cheater00> "oh look, it's merijn the bag lady with her papers"
09:09:43 <cheater00> :p
09:09:51 <merijn> If I need to refer back to earlier pages I can't just take a partial thesis with me
09:10:10 <cheater00> make a note to refer later, and keep reading
09:10:25 <cheater00> if the thesis forces you to refer to something too far back, it sucks anyways
09:10:32 <pastorn> merijn: yeah, use those colored page marker thingies
09:11:22 <cheater00> or just a pen
09:11:28 <cheater00> and annotate the pages
09:11:40 <cheater00> they're usually ending up as chimney starter anyways
09:11:41 <pastorn> merijn: actually, just study this to learn the different ones :)
09:11:44 <pastorn> http://hackage.haskell.org/package/constructive-algebra
09:23:25 <Eduard_Munteanu> Yep, the toilet is a place of great contemplation. Many great ideas are born there.
09:35:57 <Athas> Is there a way to get Emacs to automatically sort the module import list?
09:37:06 <Berengal> Athas: M-x sort-lines
09:38:02 <Athas> Well, grouping them into categories as well, for example by the GHC convention of first internal modules, then library imports, then imports from the standard.
09:58:23 <rovar>  i need some help with instances..
09:58:53 <TomMD1> Don't we all
09:59:03 <rovar> i have a datatype, PersistValue.. which wraps basic types for Persistent.. 
10:00:32 <rovar> I have made that type an instance of another type.. MongoDB DB.Val 
10:00:55 <rovar> the instance of val has methods to cast back and forth between the two values.. 
10:00:59 <TomMD> instance of another "class", not "type" right?
10:01:05 <rovar> yes
10:01:14 <TomMD> good good
10:01:33 <rovar> my problem is that I am representing  the DB.Val's ObjectId  as a PersistByteString 
10:01:52 <rovar> this converts from ObjectID to PersistByteString just fine
10:02:22 <rovar> but obviously ByteString is much more generic than ObjectId so I don't want to convert every ByteString back into an ObjectId
10:02:43 <rovar> I only want to convert back into a ObjectId when an ObjectId value is expected. 
10:03:27 <TomMD> It sounds like you need to know when a particular ByteString is an encoded ObjectID
10:04:54 <rovar> yes.. but I don't really know how to do that without making a new type
10:05:55 <TomMD> Perhaps you can do the ugly hack the C unions always do - prefix each PersistentByteString with a single byte that tags the type it represents?
10:06:21 <rovar> i just threw up a little in my mouth.. 
10:06:35 <TomMD> rovar: Don't blame you.
10:06:57 <TomMD> But off hand and without knowing more context I don't have any better ideas.
10:07:00 <rovar> it seems like the information is there.. e.g. I know when the code is expecting an objectId.. i should be able to have a cast specifically for that occasion..
10:07:46 <rovar> so i'm dispatching not only on a pattern match .. but the expected resulting type.. 
10:07:51 <TomMD> You can/do have a function :: ByteString -> ObjectID, right?
10:07:55 <acowley`> Doesn't your instance define a function with type ByteString -> Foo?
10:08:22 <rovar> the instance  defines    PersistValue -> DB.Val 
10:08:31 <rovar> which are both ADTs
10:08:48 <rovar> so a pattern match on  the cast from PersistValue PersistByteString  gives me a bytestring...
10:09:31 <rovar> I do have a function that converts ByteString to ObjectId.. but I don't control all of the code, so I cant specify that it gets called in every case.
10:23:54 <merijn> Is there a reason why we don't have Functor as prerequisite for Monad (or a Monad m instance for Functor for that matter...)? Or is it just hysterical raisins
10:24:41 <Twey> Raisins
10:24:56 <Bfig> :t Raisins
10:24:57 <lambdabot> Not in scope: data constructor `Raisins'
10:24:57 <monochrom> mysterical accidents
10:25:07 <Bfig> :p
10:25:14 <navaati> it's the same reason that why we have return and fail in Monad…
10:25:50 <Berengal> Return makes sense to put in Monad as long as we don't have a Pointed, but fail doesn't belong anywhere near that
10:26:17 <monochrom> "monadic fail" :)
10:26:28 <merijn> Berengal: Well, you could argue that Applicative should also be a pre-req for Monad :p
10:26:37 <merijn> In which case return is just pure
10:26:53 * merijn is starting to see the light and is hoping it isn't an oncoming train...
10:27:48 <monochrom> the train also sees you
10:27:59 * BMeph still prefers "inject", but understands thatit's a subjective preference
10:28:13 <Twey> BMeph: I think we're trying to make this stuff *less* scary
10:28:24 <Twey> I'd want a Pointed
10:28:40 <Twey> Purely for the one-method-per-class neatness
10:28:40 <monochrom> "inject" is less scary. some programmers swear by injection when they take cocaine
10:28:51 <Twey> Injected cocaine?
10:28:56 <monochrom> yeah
10:29:20 <BMeph> I thought injection was a heroin thing... ;þ
10:29:32 <merijn> Haskell is like martial arts, I'll be 80 by the time I'm proficient in it >.>
10:32:24 <Twey> BMeph: I think injected cocaine is for people who hate their veins
10:32:59 <arlinius> heroin's not?
10:33:26 <merijn> Fortunately you can't inject type theory :p
10:33:53 <BMeph> arlinius: Heroin is not used medically for the purpose of closing blood vessels.
10:33:57 <monochrom> until we install a usb port into your head
10:34:36 <merijn> :t (<$)
10:34:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
10:34:44 <merijn> @src (<$)
10:34:44 <lambdabot> (<$) = (<$>) . const
10:34:51 <merijn> Ah...
10:34:52 <BMeph> merijn: Probably not. augustss was alredy old when he wrote the LML prototype. ;)
10:35:17 <merijn> :t (<$>)
10:35:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:35:33 <Jafet> @quote gateway
10:35:33 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
10:35:47 <merijn> Sometimes Haskell makes me feel like I'm accidentally learning Perl...
10:36:06 <RenJuan> lol
10:36:15 <tomh-> damn I was never made aware of that side effect!
10:36:18 * BMeph wonders what the road to Haskell is paved with... ;)
10:36:30 <tomh-> they should put a warning when compiling haskell programs for that :P
10:36:37 <merijn> BMeph: Coq, apparently
10:36:42 <monochrom> the road to haskell is paved with good abstractions
10:37:04 <Jafet> Haskell is compact as a consequence of being expressive; Perl is the opposite.
10:37:10 <BMeph> @remember monochrom the road to haskell is paved with good abstractions
10:37:10 <lambdabot> Good to know.
10:37:38 <merijn> @quote haskell.from.coq
10:37:38 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
10:37:49 <monochrom> hehehe
10:38:19 <adorablepuppy> Couldn't match expected type `IO Image' with actual type `Image'. How to dip back into IO mode?
10:38:30 <arlinius> Perl is expressive as a consequence of being compact?
10:38:33 <monochrom> return to IO
10:38:35 <merijn> adorablepuppy: return
10:38:58 <Jafet> Or if you want to be ironic, pure
10:39:08 <adorablepuppy> Thanks. That's fot it.
10:39:10 <adorablepuppy> got*
10:39:27 <BMeph> monochrom: Pity, you missed an opportunity there. I'd've said "extract the IO from an IO String"... ;)
10:40:13 <monochrom> this is the other direction. Image -> IO Image. or IO -> IO Image if you like
10:40:16 <Jafet> @quote the.IO
10:40:16 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
10:41:24 <merijn> <$> and fmap are the same, no?
10:41:35 <Berengal> Yes
10:41:36 <rovar> no.. one is infix
10:41:39 <rovar> :P
10:41:42 <merijn> rovar: harhar
10:42:04 <rovar> <$> and `fmap` are almost the same :) 
10:42:46 <Berengal> If we had mixfix, we could have _<_> too...
10:42:53 <merijn> Which is again the same as (.) in the case of ((->) r), no?
10:43:09 <Berengal> yes
10:43:33 <Jafet> :t (.)
10:43:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:44:47 <BMeph> @quote IO.String
10:44:47 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
10:45:29 <monochrom> my IO String -> IO quote is lost, if you're looking for it
10:45:58 <monochrom> fortunately it was only lost after it appeared in HWN
10:46:02 <BMeph> monochrom: Lost to lambdabot, but not to us... ;)
10:46:09 <rovar> please repeat
10:46:26 <monochrom> "how do I extract the IO from IO String?"
10:47:44 <rovar> that hurts my head 
10:48:32 <cheater00> does lambda calculus have a concept of synecdoche?
10:50:09 <rovar> cheater00,  certainly.  composable combinators are based on this concept
10:52:37 <c_wraith> monochrom: <$   :)
10:56:19 <aristid> :t (() <$)
10:56:20 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
10:56:31 <aristid> :t (() <$) :: IO String -> IO ()
10:56:32 <lambdabot> IO String -> IO ()
10:56:47 <BMeph> Aah! My eyes! =8*O
10:58:57 <BMeph> Specifically, the "explanation" of list comprehensions here: http://benlynn.blogspot.com/2011/04/list-comprehensions-in-c.html
10:59:05 <burp> utf8-light with ghc7: /tmp/ghc21501_0/ghc21501_0.s:8813:0:      Error: .size expression for __stginit_utf8zmlightzm0zi4_CodecziBinaryziUTF8ziLight does not evaluate to a constant
10:59:07 <burp> any hints?
10:59:12 <Jafet> :t (>> pure ()) :: IO String -> IO ()
10:59:13 <lambdabot> IO String -> IO ()
10:59:42 <Jafet> preflex, zdec __stginit_utf8zmlightzm0zi4_CodecziBinaryziUTF8ziLight
10:59:42 <preflex>  __stginit_utf8-light-0.4_Codec.Binary.UTF8.Light
11:01:56 <c_wraith> BMeph: the explanation is bad, but the code is worse
11:02:27 <EvanR> grumble. something changed about my haskell install so now certain MonadIO instance disappeared
11:02:53 <EvanR> No instance for (MonadIO (mtl-1.1.0.2:Control.Monad.Reader.ReaderT FastCGIState IO))
11:03:22 <EvanR> maybe i need to upgrade FastCGI
11:04:22 <damike84> i want to check if 2 neighbour nodes in a tree have the same value: http://pastebin.com/s5DvAQ26 it works. but i'm unhappy with the line "otherwise = (samevalue x) || (samevalue y)" is there a other way to call each function?
11:04:32 <c_wraith> burp: my only suggestion is use the text package instead.  It handles doing everything utf8-light does, and much more.
11:05:00 <burp> c_wraith: ok, sadly this utf8-light is a dependency for an other package ;)
11:05:09 <EvanR> i seem to have mtl-1 and mtl-2 installed, is that right
11:05:11 <c_wraith> hmm.  rewrite the other package?
11:05:24 <ezyang> Ah, sigfpe ♥ 
11:05:37 <burp> c_wraith: :D
11:07:13 <Phyx-> is it safe to use unsafePerformIO on the 'dynamic' wrappers generated by ghc for FunPtrs?
11:07:24 <c_wraith> damike84: well, not related to that yet, but I'd use an as-pattern on lines 7 and 8.  pattern-match as "n@(Node x y _)", then just use "checkNode n" in the guard on line 8
11:07:55 <damike84> c_wraith, not familar with that - but i check it. thx
11:08:15 <cheater00> rovar: can you explain?
11:08:35 <c_wraith> damike84: There's nothing you can really do to make line 9 simpler..  That really is exactly the operation you want.
11:10:22 <damike84> c_wraith, yes - but i thought there is a way do to a non recursive call - just for optimisation
11:10:22 <rovar> cheater00,  no. 
11:10:54 <cheater00> rovar: why not?
11:12:16 <Twey> damike84: otherwise = on (||) samevalue x y
11:12:17 <Twey> … maybe
11:12:40 <c_wraith> damike84: a) it's recurring twice...  You'll need either recursion or explicit stack management.  recursion is usually simpler and faster.  b) ghc has tail-call optimization that *will* cover the case in there that can be converted into a tail call, if you compile with optimizations
11:13:13 <damike84> c_wraith, ok thx
11:13:20 <damike84> Twey, thx
11:19:03 <pmurias> is there a cathegory theory book which will explain how are monads used in mathematics?
11:21:23 <Twey> damike84: Note: ‘if a then True else False’ is identical to a
11:22:06 <Botje> (except it forces a) -- nitpick
11:22:14 <Twey> Yes :þ
11:25:45 <mercury^> pmurias: pick any. :P
11:26:11 <mercury^> Twey: your tongue has the shape of an 'o'.
11:27:09 <ion> > tail [undefined, 42]
11:27:10 <lambdabot>   [42]
11:27:13 <ion> > tail [if undefined then 1 else 0, 42]
11:27:14 <lambdabot>   [42]
11:28:24 <Twey> mercury^: And you have no nose, but I was being polite and not mentioning it
11:28:45 <ion> twey: The nose is in his nick.
11:28:58 <Twey> That's where it got to!
11:29:32 <Twey> 〈(¦:ʌþ)
11:30:09 <ion> （　´_ゝ`）
11:31:32 <josh04> I'm getting a lot of undefined reference messages with a cabal install, and I think the problem is that it's not including libstdc++ (windows). Any ideas?
11:32:33 <Athas> Cabal needs libstdc++?
11:32:37 <Athas> That seems unlikely.
11:32:48 <josh04> I'm installing wxhaskell with -split-objs
11:32:56 <Athas> Oh.  Then maybe not so unlikely.
11:33:01 <damike84> got a last question today: http://pastebin.com/dJVzHENN is there a way to simplefy "simpleflatten"? can i do an optimisation on the pattern matching? i'm not interested in the order of the nodes :-(
11:33:19 <josh04> It's a pain in the ass to debug because each compile takes ~2 hours
11:34:20 <c_wraith> damike84: in all cases, "++ []" does nothing
11:34:48 <damike84> c_wraith, a yes - mixed it with ":" - you are right - thx
11:34:54 <c_wraith> damike84: second, that can be reduced to only 2 cases, total
11:35:35 <damike84> c_wraith, my solution is a recursive call with depth 1 - but how would you solve it?
11:35:36 <c_wraith> damike: err, maybe not.  that has weird behavior.  did you want it to flatten the entire tree, or just a couple nodes of it?
11:36:15 <damike84> c_wraith, 1 node + the nodes neighbours
11:36:35 <c_wraith> damike84: I'd write it as a more general "flatten to depth n" call, then.
11:36:49 <Berengal> Here's a conundrum: I have a C object where I can set pointers to other C objects. I need some way to reliably free them
11:36:50 <damike84> i just want to check if 1 of the childs has the same value than the neighbour
11:37:15 <damike84> c_wraith, ok thx - i will try :)
11:37:29 <Berengal> I'm thinking I have to wrap the C object in a Haskell datatype containing references to all the set objects, so the garbage collector can reliably track the references
11:37:48 <c_wraith> Berengal: arbitrary graph, or just low depth?
11:38:08 <Berengal> c_wraith: Seems low depth, but I might have missed this earlier on as well
11:38:40 <Berengal> Maybe a few level
11:38:46 <Berengal> s
11:38:53 <c_wraith> You could just use ForeignPtr with a finalizer that frees all the child elements...  Unless there's sharing.
11:38:59 <Berengal> There might be sharing
11:39:12 <c_wraith> Then yeah, you need full garbage collection
11:39:15 <Berengal> The actual case now is a Text object that has a Font pointer
11:40:48 <pmurias> mercury^: which is a recommended one?
11:41:12 <damike84> c_wraith, http://pastebin.com/hqZ7pkti found another solution :)
11:41:42 <c_wraith> damike84: sure, but it's twice as many lines of code :)
11:41:43 <ion> damike84: Make it an instance of Foldable and use Data.Foldable.toList, i think.
11:42:21 <c_wraith> ion: that not only doesn't do what he's actually asking, it also doesn't solve anything.  implementing Foldable requires implementing toList
11:43:20 <ion> I thought it only requires implementing foldMap or foldr.
11:43:45 <c_wraith> eh.  Both of those are equivalent to toList
11:44:23 <c_wraith> foldr is just toList with an arbitrary function instead of (:) and an arbitrary base case instead of []
11:44:58 <ion> But the documentation of Foldable provides nice examples for a tree structure not unlike his.
11:45:07 <aristid> @src (++)
11:45:07 <lambdabot> []     ++ ys = ys
11:45:07 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:45:07 <lambdabot> -- OR
11:45:07 <lambdabot> xs ++ ys = foldr (:) ys xs
11:45:18 <c_wraith> regardless, the name "flatten" is wrong.  That's not what it's actually doing. :)
11:45:32 <aristid> :t flip (foldr (:))
11:45:33 <lambdabot> forall a. [a] -> [a] -> [a]
11:45:57 <mercury^> pmurias: Category theory for the working mathematician and Toposes, triples, theories.
11:51:14 <pmurias> mercury^: are they suitable for someone who is not a mathematician?
11:52:31 <monochrom> not suitable
11:53:44 <luite_> you could read them if you have enough other reference material available, but then you might as well go all the way and become a mathematician ;)
11:54:32 <merijn> Which is a path steeped in dread, confusion, awe and enlightenment. Although so far for me mostly dread and confusion :p
11:54:41 <BMeph> luite_: ...although you may have to work at it. ;)
11:54:55 <merijn> Also, the occasional suspicion that you are staring into a Lovecraftian abyss...
11:55:59 <josh04> How do I pass ghc compile flags with cabal?
11:56:54 <luite_> BMeph: yes probably, but if you succeed in completely reading and understanding those, there's little hope of becoming a productive member of society, so mathematician seems to be the only logical option
11:58:50 <pmurias> so what is the recommended cathegory theory introduction for non-mathematicans?
11:59:27 <navaati> I think the wikibook on haskell is pretty good, isn't it ?
11:59:42 <mercury^> It covers category theory?
12:00:08 <navaati> there is pieces, and denotational semantic also
12:00:12 <navaati> there are*
12:00:39 <monochrom> "conceptual mathematics" by Lawvere and Schanuel. despite the name, it does need you to have known math. (rather, it only needs you to have known kindergarten math)
12:00:51 <mercury^> I just had a look. It seems insufficient.
12:01:04 <monochrom> err typo. it doesn't need to have known math.
12:01:20 <mercury^> The book? :p
12:02:21 <monochrom> precisely because it is so slow-going and kindergarten level, I decided not to buy it. but that's exactly the trait you want for non-mathematicians non-technical layperson etc
12:02:32 <mercury^> What might work is to start at the wikipedia article of category theory and continue to click links.
12:02:51 <mercury^> But then it is hard to know what is important and what is not.
12:02:56 <navaati> dangerous black hole
12:03:25 <luite_> yeah knowing what's important is possibly the main difficulty when learning about abstract stuff
12:03:40 <mercury^> I do not see why CTWM is that bad for a non-mathematician though.
12:06:06 <monochrom> well you have a source of inspiration. you're inspired by haskell to take a look at category theory. so just focus on those things mentioned in haskell. functors, natural transformations (free theorems), monads, initial algebras. skip pushout and pullback. skip cones and limits (until you also care about denotational semantics)
12:08:03 <mercury^> Limits are one of the main features of categories in my opinion. It would be a shame to learn category theory but not to have a look at them.
12:10:50 <monochrom> IMO it would be a greater shame to forget brain limits and time limits and to assume that one can learn category theory by infinite parallelization without needing to set priorities
12:11:59 <merijn> Denotational semantics is just proving/claiming an isomorphism between a mathematical object and something (like a programming language construct), right?
12:12:12 <Cin> Does anyone know if withSocketsDo can be called multiple times without effect?
12:13:23 <monochrom> the truth is if you come from haskell and are amazed by its types, but not yet quite ready for its denotational semantics, you won't see how co-limits arise, but you immediate appreciate natural transformations.
12:14:16 <TomMD> I'm a moron.
12:14:16 <TomMD> Open official x86-64 GP and system instructions PDF (1000+ pages)  --> search for "and" --> expect to find the "and" op code quickly.
12:14:28 <monochrom> haha
12:14:56 <ksf> any topologists around?
12:15:12 <ksf> what's the name of that beast?: http://i.imgur.com/zY47Z.gif
12:15:26 <TomMD> No, most of them are toruses
12:15:46 <mercury^> ksf: torus?
12:16:13 <luite_> how do you stop an animated gif?
12:16:15 <mercury^> It's a bit hard to see because it is rotating so quickly. :)
12:16:26 <TomMD> use a slower connection and refresh.
12:16:31 <mercury^> luite_: there are things such as gif expander.
12:16:50 <cheater00> open the gif in a movie player and pause it?
12:17:07 <monochrom> gimp :)
12:17:32 <rothwell> Cin: you can
12:17:34 <luite_> hm, escape in firefox
12:17:40 <luite_> can't find a button in chrome
12:17:42 <rothwell> Cin: there's a "winsock_inited" check in the source
12:18:34 <mercury^> Two tori maybe.
12:18:44 <Aune> Hello everyone, Im playing around with how to create structures that refer to themself in diffrent ways. Now I am a bit stuck and would appreciate some help: http://hpaste.org/45487/fun_with_structures#57
12:18:46 <tener_> is there a way to write type class instances for specific types and for the rest of types something like default definition?
12:18:48 <luite_> even paused it's difficult to see
12:19:36 <mercury^> ksf: are you interested in it from a knot-theoretic point of view?
12:19:41 <ksf> mercury^, I think it's moebiusish
12:19:51 <mercury^> Or do you just want to know the homeomorphism type?
12:19:52 <Aune> So some enlightening discussion would be nice
12:20:03 <ksf> I'm interested in it from a smart-alecish point of view.
12:20:05 <luite_> nonorientable? why?
12:20:06 <Aune> Well, knot theory is not something I am familiar with
12:20:26 <Aune> I just want to know it all ^
12:20:35 <Aune> *^^
12:21:50 <ksf> mercury^, there's nothing wonderous and misterious enough to be immune to being foozled by a topological definition
12:22:10 <Aune> Actually Im more interested in knowing how to go from the idea of a structure in my mind in some form of Haskell representation
12:22:29 <Aune> *to some form of implementation
12:22:43 <ksf> ſ is an integral part of knot theory
12:22:54 <ksf> (kudos if you get the references)
12:23:01 <tromp_> ghci is being most uncooperative
12:23:20 <tromp_> after let runs = map length . group
12:23:29 <monochrom> monomorphism restriction?
12:23:29 <tromp_> it decides runs :: [()] -> [Int]
12:23:35 <ksf> Aune, did you see http://www.haskell.org/haskellwiki/Tying_the_Knot yet?
12:23:38 <monochrom> yes!
12:23:59 <Aune> ksf:Yes I have
12:24:12 <tromp_> so i need to load a file with this definition?
12:24:53 <ksf> FIRST OFF, STOP USING ALL CAPS THIS ISNT LISP
12:25:10 <monochrom> Aune: a very simple self-referencing dllist would be: let me = NODE me 0 me in me
12:26:05 <ksf> Aune, whether the tree is finite or not is not a decision of the data definition but individual trees, that's the normal way to do it.
12:26:36 <ksf> you might want to switch to graphs if you want to finitise an infinite tree
12:26:51 <merijn> Aune: Why have a Right/Left node instead of an empty list node?
12:26:59 <RenJuan> even lisp doesn't use all caps any more
12:27:19 <monochrom> HTML 2 :)
12:27:28 <merijn> Then the left side would just be "Node a Empty (DlList a)"
12:27:37 <ksf> and when you want a doubly linked list, the usual approach is not to use one, but a finger tree.
12:27:40 <ksf> see data.sequence
12:28:05 <ksf> the doubly-linked list thing is really more of a curiosity than a practical thing
12:28:24 <ksf> ...as update costs are absolutely abysmal
12:28:55 <ncalday> A question: Why doesn't 
12:28:56 <ncalday> showVector (Vector.cons x xs) = show x ++" "++ showVector xs
12:28:56 <ncalday> pattern match?
12:28:58 <monochrom> a simple self-referencing tree: let moi = Node 0 moi moi in moi
12:29:03 <ksf> if you really really really want to do that use STRefs
12:29:15 <Aune> merjin, that was just how I thought about it in my head, a double linked list with two ends, and I thought I needed a left and a right end to be able to tell when I could no longer traverse in said direction
12:29:21 <ksf> ncalday, because Vector.cons is a function, not a constructor.
12:29:26 <ksf> you can only match constructors
12:29:31 <ksf> (and stuff like numbers)
12:29:38 <ncalday> Ok. Thanks.
12:30:05 <ksf> there's view patterns, but if you're only startinng out, leave them until later
12:30:05 <Aune> ksf: I apologize for the caps, but Scheme was my first programming language at it kind of sticks
12:30:18 <tromp_> can i state NoMonomorphismRestriction in a {-# LANGUAGE #-} pragma ?
12:30:41 <monochrom> I am beginning to think that this DLLIST is like a tree
12:30:46 <ksf> NO WORRIES I RESPECT PEOPLE WHO HAVE A 1960S TERMINAL ROM STUCK IN THEIR HEADS
12:30:53 <Aune> :merjin, thats a nice idea
12:32:21 <ncalday> I guess I should use a fold then?
12:32:53 <monochrom> yes tromp_
12:33:02 <tromp_> but ghci still complains
12:33:45 <rwbarton> LANGUAGE pragmas in your source file don't affect the ghci session
12:33:54 <monochrom> {-# LANGUAGE #-} pragma applies to file content only. -X applies to ghci prompt too
12:35:05 <monochrom> but do not delude yourself into thinking that therefore you should always use -X and never pragma
12:35:10 <tromp_> ghc also complains :(
12:36:07 <monochrom> here is why: if you only use -X, when you paste your file to hpaste, I can't load it, I don't know what secret -X's you use
12:36:16 <tromp_> http://hpaste.org/45488/nomonomorphismrestriction
12:37:12 <tromp_> i guess it should precede the module ... line
12:37:30 <monochrom> yes
12:37:32 <cheater00> nom nom nom
12:37:44 <tromp_> ok, problem solved
12:41:16 <tromp_> i'm trying to write OEIS sequence A2 in haskell:)
12:41:38 <tromp_> which actually needs the inverse of runs
12:43:57 <Cin> @hoogle Word32 -> Word32
12:43:57 <lambdabot> Prelude abs :: Num a => a -> a
12:43:57 <lambdabot> Prelude negate :: Num a => a -> a
12:43:57 <lambdabot> Prelude signum :: Num a => a -> a
12:44:04 <Cin> Does Windows support htonl?
12:44:50 <Cin> foreign import ccall unsafe "htonl" htonl :: Word32 -> Word32 — I want to use something like this, but dunno if it's cross-platform. Is there a Haskell function knocking about like this?
12:44:57 <mikeg> Does anyone know where I can find the graph that lists various programming languages (haskell98, ghc, clojure, etc) on type expressiveness and decideability? i specifically remember it had clojure as "unitype" and ghc was less decideable than haskell98
12:46:56 <tab> Cin: it would be probably more efficient if it was some kind of ghc primitive though
12:46:57 <Cin> Seems to be part of winsock… Meh. Don't care about Windows.
12:47:49 <mikeg> found it: http://james-iry.blogspot.com/2010/05/types-la-chart.html
12:47:50 <Cin> I need to write a Word32 onto a handle directly, rather than printing it.
12:47:58 <Cin> In network byte order…
12:48:17 <Cin> I feel like this should be obvious to me but it's not.
12:48:28 <monochrom> perhaps the "binary" package
12:48:41 <tab> Cin: you can do it with simple bit manipulation
12:48:43 <Cin> Sounds promising. *looks*
12:49:28 <Cin> Values are always encoded in network order (big endian) form, and encoded data should be portable across machine endianess, word size, or compiler version. For example, data encoded using the Binary class could be written from GHC, and read back in Hugs.
12:49:31 <Cin> monochrom: Perfect, thanks.
12:50:50 <Taslem> @pl randR range gen = fst $ randomR range gen
12:50:50 <lambdabot> randR = (fst .) . randomR
12:51:59 <Cin> tab: I've done that in C. I don't feel like doing it in Haskell; I use high-level languages so I don't have to do housework. ;-)
12:59:57 <nswill> Might someone be able to explain this syntax in this class definition? class Term t a | t -> a where
13:00:12 <Twey> nswill: It's a functional dependency
13:00:24 <erus_> i wanna write a program that can find a path from one word to another by only (changing one letter at a time) or (adding or removing 1 letter) and still leaving a word in the dictionary
13:00:36 <Twey> It means that for any value t, there exists only one a such that Term t a
13:01:04 <Twey> http://www.haskell.org/haskellwiki/Functional_dependencies
13:01:06 <tromp_> > let k=1:2:drop 2(concat.zipWith replicate k(cycle[1,2])) in k
13:01:07 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:01:07 <lambdabot>         against inferred type ...
13:01:26 <nswill> Thank you, I couldn't even figure out what to search for
13:02:16 <Twey> That's a problem with syntax, aye
13:02:40 <Twey> s/value/type/
13:04:43 <Berengal> Is there any predefined Storable instance for unsigned int32_t?
13:05:22 <Berengal> I want to use Word32, but I can't tell if that does the right thing, or if it marshals into some haskell-object struct
13:07:09 <tromp_> > let k=1:2:drop 2(concat.zipWith replicate k.cycle$[1,2]) in k
13:07:10 <lambdabot>   [1,2,2,1,1,2,1,2,2,1,2,2,1,1,2,1,1,2,2,1,2,1,1,2,1,2,2,1,1,2,1,1,2,1,2,2,1,...
13:11:24 <monochrom> Berengal: with high probability, unsigned int32_t corresponds to CULong, but yes I understand potential pitfalls
13:12:05 <monochrom> I don't think there is a CUInt32
13:12:47 <Berengal> monochrom: I had a look at the header file. It was really a custom sfUInt32 type, typedefed to unsigned int
13:12:57 <Berengal> So I used that
13:13:26 <Igloo> If you want a 32bit integer type then Int32
13:13:44 <Igloo> Oh, Word32 if you want it unsigned
13:14:12 <Berengal> Igloo: I want a 32bit unsigned integer type that pokes into a C unsigned int
13:14:26 <Berengal> Int32 and Word32 aren't guaranteed to do that
13:14:48 <Igloo> I don't follow. What happens if int isn't 32bit?
13:15:08 <monochrom> I suppose both CInt and Int "enjoy" haskell object struct when on the haskell side, but when you call Storable you will get just the right bits written out or read in fine
13:15:32 <monochrom> s/Storable/Storable methods/
13:17:01 <Berengal> Igloo: For example, Int stores as a HSInt struct
13:17:21 <Berengal> CInt, on the other hand, stores as a c-int
13:18:42 <monochrom> actually, let me quote you a code fragment from Foreign.C.Types
13:18:43 <heatsink> Are there any programming languages that have type classes, other than Haskell dialects?
13:19:02 <monochrom> -- | Haskell type representing the C @int@ type.
13:19:02 <monochrom> INTEGRAL_TYPE(CInt,tyConCInt,"CInt",HTYPE_INT)
13:19:31 <monochrom> the macro comes from some HsBaseConfig.h or CTypes.h
13:19:50 <navaati> heatsink: sure, ocaml must have them, and i think java's interfaces are pretty like typeclasses
13:19:58 <mauke> ocaml doesn't have them
13:20:09 <mauke> javas interfaces aren't typeclasses
13:20:15 <monochrom> without reading further, I would already wager that the internal representation of CInt is going to be more complicated than just one machine word
13:20:26 <rothwell> i think scala's the closest match, but they're implemented with implicits
13:20:26 <hiato> Right, well I thought I had the IO monad pretty much figured out, but then I couldn't get this to do what I thought it should: getLine >>= return (read :: Int). What would be the explanation?
13:20:49 <Berengal> clojure has something similar with its protocols, but they work different, and they're just a subset of multiple dispatch
13:20:52 <merijn> navaati: In fact, one of the main reasons for OCaml code often being extremely ugly is their lack of typeclasses
13:20:52 <mauke> hiato: why are you doing (return read)?
13:20:54 <navaati> mauke: even java's interfaces with generics ?
13:21:14 <heatsink> I know OCaml first-class modules and Java interfaces serve a purpose that overlaps with type classes.
13:21:16 <mauke> navaati: I haven't used generics but it would surprise me
13:21:20 <hiato> mauke: this is a good question. I guess there's no need to keep it IO a
13:21:30 <mauke> hiato: this has nothing to do with IO
13:21:32 <monochrom> but this does not prevent Storable methods from poking/peeking the exact right bits (and ignoring all the other stuff) so you get the right behaviour when sending bits over to the C side
13:21:39 <mauke> hiato: why are you trying to 'return' the read function?
13:22:18 <merijn> mauke: Probably because Read doesn't return an IO value like >>= expects?
13:22:19 <heatsink> navaati: That reminds me.  As I recall, Java generics + constrained types work like type classes.
13:22:22 <monochrom> you may ask why is there Int and then CInt, why two types.
13:22:24 <hiato> mauke: ok. Then I need to reevaluate. I wanted IO String -> IO Int in essence. and x >>= f (bind) I thought would allow me to do stuff to the value without worring about the action.
13:22:29 <mauke> merijn: >>= expects a function
13:22:38 <merijn> hiato: I think you want fmap
13:22:42 <mauke> hiato: so far, so good
13:22:44 * heatsink looks up scala implicits
13:22:57 <merijn> :t fmap
13:22:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:23:16 <merijn> Substitute IO for f and you have what you want :)
13:23:24 <hiato> mauke: so then the way I would change String -> Int would be to use read :: Int
13:23:28 <mauke> hiato: no
13:23:32 <mauke> hiato: read :: Int is an error
13:23:40 <hiato> ok, but why?
13:23:46 <mauke> because read is a function, not an Int
13:24:00 <monochrom> the reason is not "so CInt doesn't enjoy HsStuff record, thunking, etc". the reason is that Haskell 2010 "Int" may support fewer or more bits than C's "int".
13:24:40 <hiato> mauke: ok, I think I understand. But then how would I use read to do this?
13:24:44 <hiato> or do I not at all?
13:24:58 <merijn> hiato: Look at my answer a few lines up :)
13:25:00 <mauke> well, the correct type signature would be read :: String -> Int
13:25:01 <hiato> I realise I can use fmap, but I have this in a list which I use sequence on
13:25:10 <hiato> oh
13:25:11 <hiato> duh
13:25:16 <mauke> and then it would be return . read, not return read
13:25:19 <merijn> Or that, yes
13:25:44 <hiato> yes, another duh. Thanks mauke :]
13:26:00 <mauke> and then you notice that you've written x >>= return . f, which is the same as liftM f x
13:26:02 <tab> hiato: note that you could have almost the form you wanted, but the type annotation apply to the whole line (not only read)
13:26:05 <mauke> and that liftM == fmap
13:26:07 <tab> hiato: i.e. getLine >>= return . read :: IO Int
13:26:39 <hiato> ah, yes. Ok, I see now
13:27:05 <hiato> obviously the IO action needn't be preserved here
13:27:27 <copumpkin> what's the GPL's stance with me pulling out a chunk of binutils (libopcodes) and bundling it with my haskell binding to it?
13:27:41 <copumpkin> (as long as I still include the license and stuff)
13:27:41 <hiato> that's very nifty, thanks all
13:27:49 <mauke> copumpkin: probably a derived work; everything under GPL
13:27:58 <merijn> copumpkin: Depends whether you can claim it under fair use or not
13:28:04 <mauke> fair use? what
13:28:04 <merijn> If not, then it is a derived work
13:28:46 <merijn> mauke: Or whatever any similar relevant exemption applies
13:30:26 <JoeyA> Just wondering, do any compilers do strictness analysis almost hand-in-hand with type inference?
13:31:05 <Berengal> Writing c-bindings in Haskell is so much easier compared to other languages...
13:31:05 <JoeyA> For example, (:) :: ~a -> ~[a] -> [a]  and   (+) :: Num a => a -> a -> a   are givens.
13:31:48 <JoeyA> meaning cons is lazy in both of its arguments, and addition is strict in both of its arguments.
13:31:49 <Draconx> Berengal, only if the interface is trivial, really.
13:32:23 <Berengal> Draconx: What would a non-trivial interface look like?
13:32:30 <Draconx> Berengal, for example, writing a binding to a C function that takes a struct as a parameter is rather difficult.
13:32:35 <heatsink> JoeyA: (+) is not required to be strict in both arguments.  For some types it may be lazy.
13:32:49 <JoeyA> heatsink: Oh, didn't think about that.
13:33:04 <Berengal> Draconx: No, that's still easy. Harder than those that take primitive types or pointers, but still easier than other languages
13:33:09 <Draconx> (or maybe just tedious)
13:33:10 <JoeyA> primitiveAddInt :: Int -> Int -> Int, then :-)  (I guess that's what it's called)
13:33:35 <Berengal> It is tedious, yes...
13:33:35 <Draconx> Berengal, well, you basically have to write a C function that doesn't take a struct as a parameter to call it.
13:33:42 <copumpkin> JoeyA: how about indicating strictness of recursive structures? what if I force three elements of the spine of a list and the second element?
13:33:55 <Berengal> Draconx: I've got that down to an emacs macro now. The tedious bit is writing the Storable instance
13:34:22 <mauke> Haskell FFI doesn't do struct-by-value or varargs
13:34:26 <mauke> anything else that's impossible?
13:34:46 <JoeyA> copumpkin: You mean, indicating that one of the arguments of a function is lazy in parts of its arguments?
13:34:52 <copumpkin> JoeyA: yeah
13:35:00 <JoeyA> Just say f :: [a] -> ...
13:35:01 <Draconx> Berengal, but as soon as you have to write a C function to glue your haskell binding to the actual C function, things are just as easy as in any other language.
13:35:18 <JoeyA> To me, partially lazy structures seems like madness.
13:35:47 <mauke> Draconx: I take it you've never used the FFI in perl
13:35:56 <JoeyA> copumpkin: The way I see it, the type annotation could be quite literal.
13:35:57 <Draconx> mauke, I have not.
13:36:03 <rothwell> mauke: i can't imagine dealing with C structs that use bitfields are too much fun
13:36:26 <Draconx> or structs that contain a va_list :)
13:36:46 <JoeyA> (:) :: ~a -> ~[a] -> [a] could translate to a C function like this: void *cons(Box *x, Box *xs)
13:37:00 <Berengal> Draconx: No, because other languages tend to do all the marshalling in C, not in their native language
13:37:14 <JoeyA> Whereas addInt :: Int -> Int -> Int might be more like: int *addInt(int *a, int *b)
13:37:27 <Draconx> Berengal, but in Haskell, you have to write a C function to marhal data into a struct...
13:37:34 <Draconx> marshal*
13:37:41 <mauke> no, you don't
13:37:41 <Draconx> Berengal, how is that any different?
13:37:50 <mauke> that's what Storable is for
13:37:50 <Berengal> Draconx: All my wrapper functions look like this: http://hpaste.org/45489/cwrapper
13:38:58 <JoeyA> copumpkin: So I guess the style of strict analysis I'm thinking of is not entirely complete, but nonetheless useful.
13:38:59 <hiato> ok. I am back with yet another question. Why can I not do map (\x -> LiftM x getLine) [(read :: String -> Int),(read :: String -> [String])] for example? I'm really struggling to understand the error message that tells me that it's trying to infer a type of Int -> String for the read :: String -> [String]
13:39:08 <Draconx> Berengal, those functions take pointers, not structs.
13:39:17 <Berengal> Draconx: They're the wrapper functions
13:39:23 <Berengal> Of course they take pointers :P
13:39:24 <copumpkin> JoeyA: clean marks strictness in types
13:39:40 <mauke> hiato: because all elements of a list have the same type
13:39:52 <JoeyA> copumpkin: Interesting
13:39:58 <hiato> ... yes. Of course. Ehh. I really need to think before I try :P
13:40:17 <Draconx> Berengal, hm, how do you write portable Storable instances for structs?
13:40:22 <hiato> though that is an interesting example of it
13:40:43 <Draconx> Berengal, (without calling any C functions to put data into the struct)
13:40:46 <mauke> Draconx: using hsc2hs or c2hs
13:41:01 <mauke> hsc2hs is more low-level
13:41:09 <Berengal> Draconx: http://hpaste.org/45490/storable_instance_for_color
13:41:16 <Draconx> mauke, so I can take the output of c2hs and compile it on another computer, and it'll work?
13:41:23 <mauke> Draconx: I don't know
13:41:30 <mauke> for hsc2hs: no
13:41:42 <Berengal> c2hs neither
13:41:51 <mauke> what would be the point of that?
13:42:03 <Berengal> Which is why you distribute the c2hs files. The hs files are just compiler artifacts
13:42:41 <c_wraith> Draconx: and this is why you use cabal, because it just handles all of that automatically
13:42:49 <Draconx> ok, so in order to write a binding to C you need to use another program that generates a binding to C.  Why is this easier than other languages (except maybe perl), again?
13:43:06 <mauke> because you don't have to write it yourself
13:43:10 <c_wraith> Draconx: because cabal just handles it automatically
13:43:29 <c_wraith> much like how pod, in perl, just handles it automatically
13:43:43 <Berengal> You just put "Build-tools: c2hs" in the cabal file and Bob's your uncle
13:43:51 <mauke> I've used C functions in OCaml
13:43:55 <mauke> it wasn't very pretty
13:44:12 <monochrom> eh? why is this more difficult than other languages?
13:44:13 <mauke> had to do my own marshalling in C, use the OCaml API to access values, etc
13:44:35 <mauke> and this is was relatively easy because it was just <ctype.h>
13:44:40 <mauke> no fancy data structures
13:44:46 <Draconx> mauke, and that marshalling is impossible to generate automatically?
13:44:47 <thierry`> Hi, I'm working with [[Int]] types. I have two list of list : A and B. I want to remove from B all value that are in A. How do I handle that? I end up with map inside map it starts to get ugly. What am I doing wrong? 
13:44:54 <Berengal> I've written JNI bindings. The sucktitude was from a whole other world
13:45:04 <mauke> Draconx: I don't know
13:45:10 <mauke> Draconx: there is no framework and no tools for it
13:45:15 <JoeyA> copumpkin: Hmm, I didn't think of this case: f :: ... -> (!a, ~b)
13:45:30 <monochrom> if you have only one foreign function to bind, you can write the right line by hand, you don't need another program
13:45:33 <mauke> Draconx: in Haskell you just need a few numbers from C, for the sizes/alignment/offsets of structs
13:45:42 <mauke> the rest is easy
13:45:44 <Draconx> ok, so this is a quality of implementation issue, rather than anything to do with Haskell itself.
13:45:54 <monochrom> if you have a million foreign functions to bind, you can't write the right lines by hand, you have to use another program
13:46:07 <Draconx> monochrom, not if the function takes a struct.
13:46:07 <monochrom> I don't see how it is different anywhere
13:46:15 <JoeyA> err, I could compensate.  My thinking is that return values are implicitly strict.  There's no point in calling a function just to get a thunk.
13:46:17 <Draconx> monochrom, you can't just right a line by hand.
13:46:23 <Draconx> s/right/write/
13:46:47 <JoeyA> So it'd be f :: ... -> (a, ~b)
13:46:54 <copumpkin> JoeyA: being strict in a pair is not the same as being strict in the elements of the pair
13:47:18 <JoeyA> copumpkin: Right.  By the convention I have in mind (strict by default), the return value is strict.
13:47:46 <JoeyA> But the elements have varying strictness, and this is compatible with the type system.
13:47:49 <copumpkin> strict by default, eh
13:47:49 <JoeyA> Pair a ~b
13:48:01 <JoeyA> That's not the convention Haskell uses, of course.
13:48:16 <monochrom> well then, struct is pretty much forced to be a haskell issue then. do you know why?
13:48:35 <JoeyA> What convention does Clean use?
13:48:44 <monochrom> because haskell is a non-strict language. this forces data representation memory layout to be different
13:48:47 <copumpkin> lazy by default
13:48:59 <monochrom> different from all those stupid strict eager languages out there
13:49:04 <navaati> thierry`: use filter and any
13:49:07 <copumpkin> JoeyA: lazy things can be forced to make them strict, but strict things can't be unforced
13:49:42 <monochrom> you're talking about C struct readily usable in python and vice versa because they CONSPIRE to be the same shit
13:49:52 <Draconx> monochrom, the original statement I was responding to was: "Writing c-bindings in Haskell is so much easier compared to other languages..."
13:50:06 <JoeyA> I wrote a simple compiler for a Haskell-like language, and I define a C macro called "box" that takes a strict value and returns a lazy-typed one (though "forcing" simply means extracting the underlying value).
13:50:20 <thierry`> navaati : thanks a bunch
13:50:57 <monochrom> well then, that statement should s/haskell/c2hs/ if c2hs automates nicely
13:51:10 <dolio> Does non-strict force much data layout that parametric polymorphism doesn't.
13:51:32 <JoeyA> Is that a question or a statement?
13:51:39 <dolio> Question. My bad.
13:51:52 <dolio> It started as a statement, and then I modified it.
13:52:05 <Berengal> monochrom: Not really. I think maybe Greencard does though, but I haven't looked at it
13:52:19 <monochrom> oh then, s/non-strict/parameterically polymorphic/ and s/strict/ad-hoc polymorphic/ then
13:52:24 <JoeyA> Well, if you take type classes out of the equation, you really don't have to do anything special to get parametric polymorphism.
13:52:26 <JoeyA> :t foldr
13:52:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:52:43 <JoeyA> foldr is polymorphic by nature, not because it knows how to adapt to different data types.
13:52:59 <JoeyA> That is, unless the underlying representation requires foldr to be in an implicit typeclass like Sizeof
13:53:08 <dolio> You have to represent all your data uniformly.
13:53:23 <dolio> So that foldr only needs one implementation for all types.
13:53:25 <erus_> foldr takes a funct0r :)
13:53:28 <merijn> Haskell monads are math comonads and vice versa, right?
13:53:33 <monochrom> oh actually, parameteric polymorphism doesn't force a data layout. you could do the early c++ specialize-everything trick
13:53:47 <monochrom> yes merijn
13:53:53 <JoeyA> Or just make everything void* :-)
13:54:01 <dolio> Unless you're willing to generate code for every instantiation, which may not be statically known.
13:54:52 <JoeyA> Actually, foldr can have one implementation for all types in a class.  It would need an implicit parameter telling it information about the specific type.  This is how type classes work.
13:55:28 <JoeyA> It might internally become:  foldr :: Int -> (a -> b -> b) -> b -> [a] -> b , where the first argument is the size of the elements.
13:55:56 <JoeyA> foldr would then propagate that parameter to head and tail.
13:56:11 <JoeyA> (assuming they do in fact need to know that)
13:57:02 <Tomsik_> @src foldr
13:57:02 <lambdabot> foldr f z []     = z
13:57:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:57:21 <monochrom> IIRC early c++ requires all your polymorphic things to be entirely in header files. so by the time you "cfront -c my.cpp" everything you need is statically known
13:57:24 <JoeyA> Someone please stop me if I'm babbling nonsense.  I recently wrote a little compiler for a Haskell subset, and I'm going by what I learned.
13:57:33 <Tomsik_> Heh, I've always thought that haskell uses linked lists
13:57:54 <JoeyA> I thought it did, too.  I was being hypothetical.
13:58:23 <JoeyA> e.g. if it were implemented like template<T> struct Cons {T x; Cons *xs;}
13:58:38 <c_wraith> It's very hard to implement [] as anything other than a linked list.
13:58:38 <dolio> Well, with polymorphic recursion, you can use arbitrary, runtime-determined instantiations of polymorphic functions.
13:58:55 <dolio> And Haskell has that.
13:59:11 <JoeyA> Wow, I understood that.  Can I have a cookie?
14:00:04 <JoeyA> It took me a while to digest that morsel since I first heard it.  It means any program with type classes can be transformed into one without them.
14:00:26 <JoeyA> (without a combinatorial explosion of functions)
14:00:40 <monochrom> then I wonder whether c++ has polymorphic recursion too
14:00:51 <dolio> Not sure.
14:00:55 <JoeyA> You'll still need showInt, showChar, showBool, etc., but showList can take a show argument and handle all list cases.
14:00:55 <Aune> no
14:01:05 <monochrom> I blissfully have forgotten enough c++ to know for sure :)
14:01:15 <JoeyA> http://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c/1957#1957
14:01:34 <Tomsik_> AFAIK C++ templates just instantiate all needed cases and put that in the binary
14:01:47 <Tomsik_> might've changed with c++0x
14:01:48 <JoeyA> I tried to do polymorphic recursion in C++, and the error output was hilarious.
14:01:55 <monochrom> hehe
14:02:04 <heatsink> Do you have an example of a polymorphic program that does something useful and can't be statically unfolded?
14:02:16 <heatsink> I know how to make an example that can't be statically unfolded
14:02:23 <heatsink> But I can't think of one that corresponds to a "real" rpoblem
14:02:54 <pmurias> what's polymorphic recursion?
14:03:10 <heatsink> pmurias: A recursive function that calls itself at a different type
14:03:20 <JoeyA> > let f x :: a -> [a]; f x = [x] in show 0
14:03:21 <lambdabot>   <no location info>: Invalid type signature
14:03:25 <monochrom> alright c2hs automates somethings nicely. if other language communities have similar tools, that's cool. if not, then we can claim our community (as opposed to the language itself) makes life easier
14:03:29 <JoeyA> > let f :: a -> [a]; f x = [x] in show 0
14:03:30 <lambdabot>   "0"
14:03:35 <JoeyA> bah
14:03:39 <JoeyA> > let f :: a -> [a]; f x = [x] in show (f 0)
14:03:40 <lambdabot>   "[0]"
14:03:48 <JoeyA> > let f :: a -> [a]; f x = [f x] in show (f 0) -- dwim
14:03:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:03:55 <JoeyA> okay...
14:04:28 <JoeyA> I've done this before, why doesn't it work now?
14:04:36 <heatsink> > let f :: a -> a; f x = head (f [x]) in length (f [0])
14:04:37 <lambdabot>   *Exception: stack overflow
14:05:18 <JoeyA> > let f x = show [f x] in f 0
14:05:18 <lambdabot>   "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\...
14:06:00 <JoeyA> pmurias: Polymorphic recursion means the code is set up such that, if polymorphic functions were statically instantiated, you'd need an infinite number of them.
14:06:44 <JoeyA> In the example above, show needs to be implemented for [[[[[[... Int ...]]]]]]
14:08:11 <monochrom> data Funny a = Nil | X (Funny (a,a)) | Y a (Funny (a,a))  -- polymorphic recursion example from Okasaki's book!
14:08:13 <Tomsik_> Hey, you might want to have a show that works on Mu (Either a List a)
14:08:19 <Tomsik_> And I'm not kidding here
14:08:22 <erus_> @src foldl
14:08:22 <lambdabot> foldl f z []     = z
14:08:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:09:07 <int80_h> I'd like to discuss the following type, what does it say?
14:09:09 <int80_h> liftM (Number . read) $ many1 digit :: GenParser Char st LispVal
14:09:24 <Alan> Hmm, I've gotten myself into a spot of bother...
14:09:35 <int80_h> me too brother
14:09:41 <monochrom> the interesting part is not just to write out that data declaration, but write a useful function for it, and then ask what's the type of the function
14:10:39 <monochrom> GenParser Char st LispVal = token type is Char, stream type is st, result type is LispVal
14:10:50 <JoeyA> Oh, I see.  Because to implement a function for Funny a, you'll need to access sub-fields of type Funny (a,a)
14:10:50 <heatsink> *state type is st
14:10:54 <Alan> Using the State monad, i'm ending up with a computation that is something like "f = state $ \s -> if (some_condition s) then g else h", where g and h are also stateful computations...
14:11:18 <heatsink> Alan: That's normal
14:11:33 <Alan> heatsink: ok, but i can't get the thing to type-check
14:11:36 <heatsink> You're embedding 'case' into a monad
14:11:42 <Alan>     Couldn't match expected type `GenState -> (a, GenState)'
14:11:42 <Alan>            against inferred type `State GenState Int'
14:11:53 <Alan> is there a more sensible pattern?
14:12:09 <heatsink> State $ \s -> if p s then runState g s else runState h s
14:12:17 <heatsink> Or, more readable:
14:12:31 <heatsink> do {s <- get; if p s then g else h}
14:12:42 <Alan> ah, i was starting to wonder if runState was what i needed
14:13:08 <Alan> so it's kinda like nesting the state monad inside itself?
14:13:17 <int80_h> monochrom: okay I need to break it down further. the type of "digit" is digit :: CharParser st Char, while many1 is many1 :: GenParser tok st a -> GenParser tok st [a]. I don't see how many1 could take digit as an argument.
14:13:53 * hackagebot wai-handler-webkit 0.3.0 - Turn WAI applications into standalone GUIs using QtWebkit.  http://hackage.haskell.org/package/wai-handler-webkit-0.3.0 (MichaelSnoyman)
14:14:11 <monochrom> perhaps CharParser st Char = GenParser Char st Char
14:14:31 <erus_> > sum [1..]
14:14:33 <heatsink> Alan: You're taking apart State computations with runState and assembling the pieces into a new state computation with State
14:14:35 <lambdabot>   mueval-core: Time limit exceeded
14:14:36 <Alan> yay, now it type-checks, thans heatsink 
14:15:15 <erus_> > sum [1..10000000]
14:15:19 <lambdabot>   mueval-core: Time limit exceeded
14:15:22 <erus_> > sum [1..100000]
14:15:23 <lambdabot>   5000050000
14:16:50 <Tomsik_> Why is lambdabot not yet sufficiently smart enough to know to just print (1+1000000)*1000000/2
14:17:36 <monochrom> because of human suppression
14:17:45 <monochrom> oppression too
14:18:22 <navaati> if we wanted efficiency, we could write a rewrite rule...
14:18:26 <monochrom> anti-revolutionary humans remove sentient code from computers
14:18:35 <heatsink> > fix (1+) == fix (2+)
14:18:39 <lambdabot>   mueval-core: Time limit exceeded
14:18:47 <merijn> If skynet finally comes into being, it'll start as a lambdabot fork...
14:18:52 <merijn> s/If/When
14:19:16 <Tomsik_> lambdanet
14:20:33 <merijn> New nickname if I ever need one :>
14:22:38 <dmwit> > let sumEnumFromTo a b = (b + a) * (b - a + 1) `div` 2 in sumEnumFromTo 1 100000
14:22:38 <lambdabot>   5000050000
14:23:34 <erus_> im trying to add a Char onto the start of a string
14:23:40 <erus_> it doesnt like ++
14:23:44 <dmwit> :t (:) :: Char -> String -> String
14:23:45 <lambdabot> Char -> String -> String
14:24:29 <JoeyA> > "a" ++ "bcd"
14:24:34 <lambdabot>   mueval: ExitFailure 1
14:24:34 <lambdabot>  mueval-core: Time limit exceeded
14:24:46 <JoeyA> Okay, I guess that was a bit much.
14:24:54 <JoeyA> > "a" ++ "bc"
14:24:57 <lambdabot>   "abc"
14:25:04 <dmwit> > let c = 'a' in (c:"bcd", [c] ++ "bcd")
14:25:06 <lambdabot>   ("abcd","abcd")
14:25:50 <JoeyA> > 'a' : 'b' : "cdef" ++ 'g' : "hijk"
14:25:51 <lambdabot>   "abcdefghijk"
14:29:40 <erus_> can i put ranges in a case statement somehow?
14:29:56 <dmwit> With guards.
14:30:05 <nisbus> I'm getting module not found for contrib packages after installing xmonad-contrib, any ideas?
14:30:20 <dmwit> > case 32 of x | 0 < x && x < 10 -> "single digit" | x < 100 -> "double-digit"
14:30:21 <lambdabot>   "double-digit"
14:30:30 <heatsink> nisbus: Where does it show up in ghc-pkg list?
14:30:33 <dmwit> > sum [1...100000]
14:30:34 <lambdabot>   5000050000
14:31:09 <erus_> ah awesome
14:31:23 <nisbus> it shows up last as 0.9.2
14:31:29 <heatsink> Wait, this is after installing?  What command gives you the error?
14:31:35 <dmwit> nisbus: In your local database or the global one?
14:31:54 <nisbus> recompiling xmonad with imports to XMonad.Layout.xxx
14:32:05 <sonoflilit> Hi
14:32:08 <nisbus> local/global ?
14:32:23 <dmwit> nisbus: Maybe you'd better just put the output of "ghc-pkg list xmonad-contrib" online somewhere for us to look at.
14:32:28 <dmwit> sonoflilit: Howdy.
14:32:34 <nisbus> http://pastebin.com/BLr0KNDB
14:32:51 <dmwit> Cool, it's in the global one, then.
14:32:52 <sonoflilit> I have code with pattern matches like f ('a':'b':xs) = f1; f xs = f1
14:32:56 <dmwit> What's the exact error you're getting?
14:33:10 <dmwit> (Paste that one online, too, for bonus points. =)
14:33:15 <sonoflilit> all of a sudden, I started getting "pattern match overlap" warnings
14:33:31 <sonoflilit> I didn't change anything relevant, just upgraded to yesod 0.7.3
14:33:54 <nisbus> you know the shortcut for copy in xterm? CTRL/Shift C doesn't work
14:34:05 <dmwit> Just highlight; middle-click elsewhere to paste.
14:34:07 <sonoflilit> nisbus: just select it with your mouse
14:34:12 <parcs> or Shift+Ins
14:34:30 <ClaudiusMaximus> erus_++ # setting a nice little problem that kept me entertained :)
14:34:40 <erus_> can I add to a char somehow? like 'a' + 2    =     'c'
14:34:45 <sonoflilit> I even got one overlapping patter warning only on the profiler-enabled compilation stage, not on the normal one
14:34:48 <dmwit> erus_: Not safely.
14:34:55 <dmwit> > toEnum (fromEnum 'a' + 2)
14:34:56 <sonoflilit> does anyone know how I can fix it?
14:34:56 <lambdabot>   *Exception: Prelude.Enum.().toEnum: bad argument
14:35:02 <dmwit> > toEnum (fromEnum 'a' + 2) :: Char
14:35:03 <lambdabot>   'c'
14:35:10 <mauke> erus_: succ (succ 'a'), chr (ord 'a' + 2)
14:35:41 <nisbus> argh, shift-ins doesn't work and I dont have a middle mouse btn
14:36:07 <dmwit> > toEnum (fromEnum '\1114111' + 2) :: Char
14:36:08 <lambdabot>   *Exception: Prelude.chr: bad argument: 1114113
14:36:09 <heatsink> > (foldr (.) id $ replicate 2 succ) 'a'
14:36:11 <lambdabot>   'c'
14:36:15 <ClaudiusMaximus> nisbus: both mouse buttons together usually emulates middle button
14:36:16 <Alan> aw crap
14:36:19 <erus_> @src char
14:36:19 <lambdabot> Source not found. Are you on drugs?
14:36:24 <erus_> @src chr
14:36:24 <lambdabot> Source not found. Take a stress pill and think things over.
14:36:25 <Alan> there should be a law against driving the State monad under the influence
14:36:37 <parcs> nisbus: shift-ins for paste, i mean
14:36:42 <erus_> @hoogle org
14:36:42 <lambdabot> No results found
14:36:46 <erus_> @hoogle ord
14:36:47 <lambdabot> Data.Char ord :: Char -> Int
14:36:47 <lambdabot> module Data.Ord
14:36:47 <lambdabot> Prelude class Eq a => Ord a
14:37:13 <merijn> :t succ
14:37:14 <lambdabot> forall a. (Enum a) => a -> a
14:37:44 <merijn> Personally I think the succ . succ $ 'a' approach or something like that is nicest
14:39:36 * BMeph read merijn's last word as 'incest' for some reason...
14:40:03 <heatsink> Yes, thank you for sharing, BMeph.
14:40:07 <mauke> succ my char
14:40:14 <Berengal> > let addChar c n = foldl' (.) id (replicate n succ) c in addChar 'a' 2
14:40:16 <lambdabot>   'c'
14:40:51 <nisbus> http://pastebin.com/fLY2FRSY
14:41:01 <nisbus> included my xmonad.hs
14:41:19 <mauke> xmonad.hs:60:8:: command not found
14:41:20 <mauke> what
14:41:23 <parcs> :t (!!) . iterate succ
14:41:24 <lambdabot> forall a. (Enum a) => a -> Int -> a
14:41:56 <BMeph> Is there a way to declare a(n IORef-containing) variable in one module, but modify it in another?
14:42:12 <Berengal> nisbus: Try #xmonad, they have more specialized knowledge
14:42:30 <Heffalump> Berengal: without explicitly passing the IORef?
14:42:54 <monochrom> yes if the other module somehow knows about the IORef. pass as parameter or unsafePerformGlobalize
14:43:16 <Berengal> We have an unsafePerformGlobalize function now?
14:43:21 <BMeph> Heffalump: Yes. I want to use the IORef in a function called by other functions.
14:43:22 <monochrom> eventually I chose pass as parameter
14:43:25 <BMeph> Heffalump
14:44:27 <Heffalump> http://www.haskell.org/haskellwiki/Global_variables
14:44:43 <BMeph> Heffalump: I can track down all of the other functions that call the one that uses the IORef, but it'd be a pain to pass the Ref to those other functions.
14:44:53 * BMeph reads
14:45:00 <erus_> http://hpaste.org/45491/rot13 look what i made :) Learning haskell is like learning to program again 
14:45:16 <mauke> erus_: use pattern matching instead of head
14:45:43 <erus_> how?
14:45:43 <mauke> use map instead of recursing manually
14:45:50 <Berengal> Using implicit parameters kinda sorta looks like a good idea for this...
14:45:53 <erus_> oh yeah i should have used map
14:45:55 <mauke> erus_: rot13 (c : cs) = ...
14:46:01 <erus_> i just watched a lecture on recursive functions
14:46:20 <erus_> mauke: wont that throw an error on a single item list?
14:46:35 <mauke> erus_: that's what line 4 is for
14:46:48 <Berengal> Single-item lists still have a tail
14:46:58 <erus_> oh yeah durr :)
14:46:58 <mauke> wait
14:47:02 <Berengal> > (\(x:xs) -> x) [1]
14:47:02 <mauke> misbrain
14:47:03 <lambdabot>   1
14:47:45 <BMeph> Heffalump: Specifically, I have a command-line argument that gets used by a function in another module.
14:48:27 <sonoflilit> Does it make any sense that I'd get a warning when compiling with profiler enabled when regular compilation didn't give it?
14:48:43 <sonoflilit> or does it mean 100% that there's a problem with ghc?
14:48:46 <Berengal> BMeph: How about implicit parameters? That way you can use the functions in other ways too, if you have a need for it
14:49:01 <jargonjustin> Does attoparsec provide an efficient way to peek the next word8?
14:49:14 <Berengal> sonoflilit: When compiling with profiling, you need to have compiled the dependencies with profiling as well
14:49:27 <int80_h> exit
14:49:29 <mauke> Berengal: that doesn't affect warnings
14:49:53 <Berengal> mauke: Oh, right, I read that as "error"
14:49:55 <BMeph> Berengal: I'll look it over, but I'm still bothered by passing arguments through functions that don't use them, to the one that does.
14:50:08 <sonoflilit> Berengal: warning, not error. warning on a pattern overlap. ghc is acting very strange
14:50:23 <Berengal> BMeph: Strictly speaking, they *do* use it...
14:50:39 <Berengal> sonoflilit: Are you sure the options are all the same except for profiling?
14:50:52 <Berengal> (Maybe profiling adds -Wall or something as well. I don't know)
14:51:27 <Berengal> BMeph: I do know that having putStrLn and friends take an implicit stdout parameter would've been handy a couple of times...
14:51:36 <sonoflilit> Berengal: when I ask cabal to compile with profiling, it does two compilation steps, one for .o and one for .p_o
14:51:38 <Phyx-> :k (->)
14:51:38 <lambdabot> ?? -> ? -> *
14:51:47 <sonoflilit> it gave the warning on that second step
14:52:33 <sonoflilit> then when I changed the file to fix it, it recompiled most of the project and found a type ambiguity in a file I didn't touch
14:52:49 <sonoflilit> seems like GHC options have changed /somehow/... or something
14:53:00 <erus_> http://hpaste.org/45494/rot13_take_3
14:53:09 <erus_> is that better mauke ?
14:53:23 <Berengal> sonoflilit: Have you had a look at the .cabal file? Might be something there. Also, profiling might imply -Wall or something else.
14:53:23 <sonoflilit> (a file that compiled perfectly before that)
14:53:35 <sonoflilit> Berengal: I'm already using -Wall
14:53:43 <erus_> curried function now aswel :)
14:53:47 <mauke> erus_: why repeat the c in every case alternative?
14:53:51 <sonoflilit> and if I'd changed the cabal file, cabal build would've demanded I reconfigure
14:53:54 <mauke> also see hlint's warnings
14:54:07 <dmwit> erus_: rot13 "LOL I'M A SHOUTING BIRD"
14:54:20 <dmwit> =)
14:54:25 <erus_> it does toLower
14:54:30 <dmwit> Anyway, yeah, looks good.
14:54:33 <erus_> but it will still work
14:54:35 <dmwit> Yep, I noticed. =)
14:54:37 <Berengal> sonoflilit: I didn't say you did change it, I'm saying you should take a look to see if there's some magic options being passed around, or other clues.
14:54:45 <erus_> "YBY V'Z N FUBHGVAT OVEQ" :)
14:54:53 <dmwit> =)
14:54:58 <sonoflilit> Berengal: mmm, you may be right
14:55:15 <erus_> i gave me warnings for brackets round to toLowers
14:55:22 <erus_> but when i take them out it doesnt work correctly
14:55:31 <erus_> so i think thats a bug in the warning system
14:55:36 <sonoflilit> Berengal: I added project-wide -XOverloadedStrings and some other stuff, maybe reconfiguring the project didn't force a recompile of that file
14:55:46 <sonoflilit> many thanks
14:55:57 <mauke> erus_: how does it fail without them?
14:56:01 <Berengal> sonoflilit: OverloadedStrings could explain the ambiguous type error
14:56:30 <sonoflilit> yes, I just had another one in a different untouched file and remembered that it could be the cause
14:56:35 <erus_> mauke: no its was doing rot13 $ rot13 "Hello World!" as "Bello Uorld!" or soemthing
14:56:41 <mauke> erus_: unlikely
14:57:26 <erus_> mauke: what did you mean about the c's in the case statements?
14:57:28 <sonoflilit> no idea yet why GHC is warning about pattern overlap in the patterns ('a':'b':xs); s   -- but who knows...
14:57:35 <shachaf> @let rot13 = map rot13c
14:57:36 <lambdabot>  Defined.
14:57:49 <shachaf> > map (rot13 . chr) [0..127]
14:57:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:57:50 <lambdabot>         against inferred ty...
14:58:03 <shachaf> > rot13 (map chr [0..127])
14:58:04 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
14:58:30 <mauke> erus_: http://hpaste.org/45495/asdf
15:00:59 <dmwit> > map chr [0..127] == ['\0' .. '\127']
15:01:00 <lambdabot>   True
15:01:43 <erus_> o cool
15:02:10 <aristid> > filter (uncurry (/=)) . map (id &&& head . rot13 . return) $ ['\NUL'..]
15:02:13 <lambdabot>   mueval-core: Time limit exceeded
15:03:25 <shachaf> > filter (uncurry (/=)) . map (id &&& head . rot13 . return) $ ['\NUL'..'\127']
15:03:27 <lambdabot>   [('A','N'),('B','O'),('C','P'),('D','Q'),('E','R'),('F','S'),('G','T'),('H'...
15:09:01 <Alan> is "do { a; b; c }" just shorthand for "a >> b >> c" ?
15:09:27 <ceii> Alan: yes
15:09:31 <Alan> ok, cool
15:09:45 <Alan> just wanted to make sure :)
15:09:56 <Phyx-> @pl \f x-> g (f (g x))
15:09:56 <lambdabot> (g .) . (. g)
15:10:05 <Phyx-> heh
15:10:08 <Alan> :t do
15:10:09 <lambdabot> Empty 'do' construct
15:10:14 <Alan> pfft
15:10:15 <Alan> haha
15:10:16 <Phyx-> not really nicer
15:11:30 <shachaf> @pl \g f x -> g (f (g x))
15:11:30 <lambdabot> liftM2 (.) (.) (flip (.))
15:11:35 <shachaf> @pl \f g x -> g (f (g x))
15:11:36 <lambdabot> ap (.) . (.)
15:22:35 <gwern> hm. how do you do bulleted lists in a cabal package description? it's just Markdown, isn't it?
15:26:04 <NisseP> I thought it was Haddock[ish]
15:26:46 <acowley``> gwern: you need some extra characters in the package description text.
15:27:10 <acowley``> gwern: blank lines aren't handled, so just put a period as the first character
15:27:13 <gwern> hm, nm, I don't have enough links for a bulleted list, actually
15:27:18 <gwern> acowley``: yeah, I know that
15:27:35 <NisseP> http://haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#general-fields haddock it is. But the list syntax is the same between the two.
15:31:44 <christo_m> acowley:  do you just keep adding back quotes as you time out :P
15:34:02 <KSkrzet> GHC 7 has parallel GC. Does it mean that merely by linking with -threaded and running with -N will make my program run faster by performing GC in another thread?
15:34:46 <Heffalump> no, it's not concurrent GC
15:34:59 <Heffalump> it can't run while the mutator (i.e. the real code) is running
15:35:16 <Heffalump> but it runs faster (generally) because it can use multiple threads during the actual GC
15:35:58 <iago> KSkrzet, if you are running 4 threads then it is possible that one of those threads stop and do GC whilst the others continue working, previously all the threads had to stop in order to do GC
15:36:25 <iago> that is the improvement, IIRC
15:36:30 <mauke> iago: ...
15:36:35 <KSkrzet> I'm confused... Heffalump's answer seems to contradict iago's
15:36:42 <mauke> ignore iago 
15:36:47 <iago> ok
15:36:48 <iago> lol
15:36:49 <Heffalump> unless Simon Marlow has recently implemented independent minor GCs, which is possible, iago is wrong
15:36:50 <iago> I will re-read
15:36:57 <Heffalump> and he's certainly wrong about major GCs
15:37:46 <Cale> I know that at least independent minor GCs were designed and planned.
15:37:49 <Cale> I don't know if it's in.
15:42:12 <KSkrzet> another question... does anyone know of Data.Map equivalent which is known to be faster?
15:42:24 <parcs> unordered-containers
15:42:33 <mauke> for what operations?
15:42:45 <Twey> Data.IntMap
15:42:58 <KSkrzet> insert, lookup
15:43:06 <iago> well, sorry so, I remember to read stuff about "stop the world" GCs and because some reason I though that recent improvements were to break that restriction. http://hackage.haskell.org/trac/ghc/blog/new-gc-preview
15:43:14 <Twey> (or, ‘for what value of “equivalent”?’)
15:43:54 <KSkrzet> Twey: to be precise, Map ByteString Int and Map (ByteString,ByteString) Int
15:43:55 <Twey> I love how they have 32-core machines on which to test
15:44:11 <Twey> The future is here
15:44:18 <Twey> KSkrzet: Data.IntMap probably won't serve you, then.
15:44:38 <Twey> Unless your ByteString is short enough to fit in an Int.
15:44:42 <parcs> KSkrzet: Data.HashMap from the unordered-containers package
15:48:19 <KSkrzet> I'm worried that for many keys hash function will perform badly
15:48:21 <mauke> iago: ah, yeah. that looks like independent minor GC's
15:48:48 <mauke> iago: but "... it should be in the autumn 2011 major release of GHC", so it doesn't really exist yet
15:49:21 <parcs> KSkrzet: from a recent talk i watched, Data.HashMap is never slower than Data.Map for inserts/lookups
15:51:56 <iago> my fault, as I said I wrongly assumed that those were the recent improvements in GHC GC, but that was an inference that my mind done after read some blog post or paper and then read "GHC GC improvements"
15:53:05 <iago> I just read now what the improvements were, I apologize!
15:53:31 <kevinburke> is there any way to print the type of a variable to the screen at compile time? or what GHC thinks the type is?
15:54:11 <JoeyA> You could say: ghci Module.hs  ....  > :t foo
15:54:17 <JoeyA> Like that?
15:54:37 <kevinburke> Its not compiling atm is the problem
15:54:43 <JoeyA> oh
15:55:51 <kmc> you can replace the right hand side of your definition with "undefined"
15:55:57 <kmc> which always has the correct type
15:56:01 <kmc> then ask what that type is with :t
15:56:37 <gwern> Groklaw's closing!
15:56:45 <gwern> wow. I feel like part of my childhood is dying
15:56:58 <KSkrzet> is there a way to export from module A all contents of module B with something like "module A (module B(..)) where import B" ?
15:57:17 <kmc> module A (module B, ...) where import B
15:57:29 <KSkrzet> kmc: thanks
15:58:24 <kevinburke> kmc: thanks
15:58:42 <NisseP> KSkrzet: also, something which might be obvious but I didn't realise until recently is that you can do "module A (module A, module B) where import B; {- defs -}" to export another module and also the local definitions, without listing them all manually
16:00:32 <Volatile> What is the correct syntax for doing something like   newtype (Num f) => Foo f = ...   ? I don't know how to put the Num constraint on f...
16:01:01 <ph> i dont think you can
16:01:43 <Volatile> Hm. So there is no way of making a monad that works only for Nums?
16:02:06 <Volatile> Oh, or should I perhaps not doit in the type but in the monad...
16:02:07 <KSkrzet> NisseP: that is cool, thanks. I didn't think that was possible!
16:02:09 <mauke> :t return
16:02:10 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:02:20 <mauke> contemplate a
16:02:26 <Volatile> :/
16:04:33 <Volatile> Hm, maybe my constraint would violate one of the monad laws or something. Meh. I'll just do it some other way then.
16:05:42 <gwern> > 2011 - 2003
16:05:43 <lambdabot>   8
16:05:46 <gwern> d'oh
16:06:42 * Volatile would have liked to build a "monad" that had a state that would keep the biggest value given to it.
16:07:11 <Heffalump> Volatile: that sounds like a Writer monad
16:07:17 <Volatile> Apparently, however, that would not have been a monad. I guess.
16:07:31 <Heffalump> with an underlying Monoid that has `max` as its mappend operation
16:08:04 <Volatile> Oh. So Monoids can have "variable constraints"? (Sorry if my terminology is off.)
16:08:42 * Volatile goes to reread about Monoids.
16:10:11 <merijn> Volatile: Monads have more requirements then monoids and the value stored in the Writer monad only needs to be a monoid
16:10:58 <Volatile> oh
16:11:02 <merijn> I think monoids only require associativity and an identity element
16:11:43 <merijn> max is an associative function and (assuming only positive numbers) has an identity element, i.e. zero
16:13:43 <dmwit> ?instances Monoid
16:13:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:14:08 <azaq23> also algebraic closure
16:14:10 <azaq23> @type mappend
16:14:11 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:14:28 <dmwit> ?instances-importing Data.Max Monoid
16:14:28 <lambdabot> Couldn't find class `Monoid'. Try @instances-importing
16:14:40 <dmwit> ?instances-importing Data.Max Data.Monoid Monoid
16:14:41 <lambdabot> Couldn't find class `Monoid'. Try @instances-importing
16:14:55 <dmwit> huh
16:14:59 <dmwit> ?help instances-importing
16:14:59 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
16:15:08 <Volatile> Oh, wonderful! This seems to be just what I needed!
16:16:25 <dmwit> Oh. The error is just plain wrong. In fact what it means is "couldn't find module Data.Max".
16:16:32 <dmwit> Somebody (finger on nose) should fix that.
16:20:24 <jargonjustin> I'm having trouble writing a small parser with attoparsec without incurring an O(n) bytestring copy. Is there a good way to fix http://hpaste.org/45498/simple_mime_headers_parser?
16:29:02 <jargonjustin> Is there a module that defines something like: (<<) = flip (>>) ?
16:29:26 <mauke> I hope not, because I prefer (<<) = (<*)
16:29:30 <mauke> (no one else does)
16:30:18 <jargonjustin> mauke: Ah, my Monad is Applicative anyway, so <* will work great
16:30:19 <jargonjustin> Thanks!
16:30:28 <mauke> but that does something different
16:33:36 <rostayob> is there a good package to index stuff by Text?
16:33:44 <azaq23> every monad is also an applicative
16:33:48 <rostayob> like a trie for Text or something like that
16:34:27 <dmwit> I don't think so. You should make one!
16:34:56 <jargonjustin> azaq23: doesn't mean they're actually an Applicative instance without using WrappedMonad
16:35:09 <nikr> Does the :: have an operator precedence?  I'm trying to understand how that thing parses.
16:35:17 <mauke> very low
16:35:56 <mauke> let's see, what beats ::?
16:36:09 <mauke> -> = (
16:36:50 <nikr> okay, thanks.
16:36:52 <dmwit> jargonjustin: You can declare instances yourself, you know.
16:36:55 <rostayob> dmwit: actually I need something like a trie (to store a set of string) and something to index stuff by text... using a Map wouldn't be that efficient with strings indexes, there's hashmap but Text is not Hashable, but it's probably easy to create an instance
16:38:02 <dmwit> Okay. What do you expect me to do about it?
16:38:25 <rostayob> nothing, maybe you guys know something I don't know :P
16:40:53 <dmwit> http://en.wikipedia.org/wiki/Directed_acyclic_word_graph for sets, http://en.wikipedia.org/wiki/Radix_tree for maps, I guess
16:41:31 <gwern> hm, I seem to have found a parsing error in pandoc
16:41:59 <gwern> what would you expect 'foo bar^[2^n^ is of course the general form]' to render to?
16:42:55 <gwern> not '<p>foo bar<sup>[2</sup>n^ is of course the general form]</p>', I'd bet
16:43:33 <dmwit> That doesn't surprise me a priori.
16:43:56 <dmwit> I could imagine a reasonable syntax spec that leads from the former to the latter.
16:44:09 <rostayob> dmwit: yeah I had tries in mind, but there does not seem to be something ready to use, which is sad ehe
16:44:22 <gwern> dmwit: not mentioned in http://johnmacfarlane.net/pandoc/README.html#superscripts-and-subscripts at least
16:44:36 <dmwit> (Speaking as someone who doesn't know what pandoc's markup looks like.)
16:44:58 <dmwit> gwern: That looks like exactly the spec I was imagining.
16:45:19 <dmwit> ^ acts like " does in Haskell, but for superscript instead of String.
16:46:02 <dmwit> In other words, I don't think you found a parsing error.
16:46:09 <dmwit> I think it's doing exactly as advertised in the link you posted.
16:46:45 <gwern> why would you think that?
16:47:03 <dmwit> "superscripts may be written by surrounding the superscripted text by ^ characters"
16:47:09 <dmwit> The very first line of your link.
16:47:44 <dmwit> ^[2^ is [2 surrounded by ^ characters
17:01:56 <AtnNn> > return 1 >>= Right
17:01:57 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
17:01:57 <lambdabot>    arising ...
17:02:36 <Axman6> eh? o.O
17:02:37 <mauke> > return "a" >>= Left
17:02:37 <lambdabot>   Overlapping instances for GHC.Base.Monad
17:02:37 <lambdabot>                              (Data...
17:02:45 <AtnNn> where is the Monad (Either a) instance? I thought it was in Data.Either but get a no instance error
17:02:59 <dmwit> C.M.Instances, probably
17:03:06 <Axman6> probably Control.Monad... but i thought it was part os the prelude
17:03:17 <mauke> Control.Monad.Error
17:03:53 <dmwit> mauke++ all other answers were WRONGO
17:05:03 <AtnNn> thanks mauke. mtl or monads-tf?
17:05:54 <aristid> mtl 2.0, preferrably.
17:06:11 <aristid> isn't it also in base 4.3?
17:07:41 <AtnNn> aristid: seems so. http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/Data-Either.html
17:08:40 * hackagebot hplaylist 0.1 - Application for managing playlist files on a music player  http://hackage.haskell.org/package/hplaylist-0.1 (TimChevalier)
17:08:40 <aristid> it's in Control.Monad.Instances in base 4.3
17:08:54 <aristid> dmwit: so you WERE right, assuming base 4.3
17:09:26 <dmwit> whee
17:09:42 <aristid> :)
17:09:48 <AtnNn> even lambdabot doesn't know where to look
17:14:56 <Berengal> Yay! After days of coding: http://hpaste.org/45505/asdf
17:17:10 <Taslem> One of my files isn't loading the module I have in the same folder.
17:18:17 <Taslem> I have:  module NoGUIR ( ... )   in NoGUIR.hs, and in Main.hs, I do:    import NoGUIR
17:18:28 <Taslem> Any idea why it isn't loading it? It says it can't find the module.
17:19:26 <mauke> what command are you using, and what's the error?
17:19:38 <Taslem> Me?
17:19:59 <mauke> yes
17:20:15 <Taslem> I'm not using any "command."  It errors when it tries to parse it.
17:20:30 <mauke> you are using a command
17:20:51 <mauke> how do you interact with your computer?
17:20:52 <Taslem> I'm launching the file in ghci.
17:20:59 <mauke> define "launching"
17:21:09 <Taslem> Right Click -> Open With "ghci"
17:21:35 <mauke> in what program?
17:21:54 <Taslem> Windows Explorer.
17:22:40 <Taslem> The module I'm trying to import parses correctly.
17:22:48 <mauke> interesting
17:23:12 <Taslem> Actually... There's another module that imports it, and it can't load it either.
17:23:57 <mauke> what does ':!cd' in ghci say?
17:24:21 <Taslem> C:/User/MyUser/Desktop
17:24:30 <Taslem> Which is 2 folders up from where these files are....
17:24:40 <akahn> What's the proper way to create a ByteString from a string? http-enumerator wants ByteStrings for its Request constructor fields
17:24:46 <mauke> then that's the problem
17:24:55 <revenantphx> @hoogle String -> ByteString
17:24:56 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:24:56 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
17:24:56 <lambdabot> Prelude read :: Read a => String -> a
17:25:12 <revenantphx> or, use overloaded strings, if you're only doing http stuff
17:25:22 <Taslem> How do I fix that, then?
17:25:43 <Taslem> Nevermind, that was a silly question.
17:25:50 <akahn> revenantphx: overloaded strings, can you explain that?
17:26:06 <revenantphx> It's possible to make all string literals byte strings instead of strings
17:26:10 <revenantphx> but its an all or nothing thing
17:26:17 <hpc> akahn: in regular haskell "this" :: String
17:26:23 <revenantphx> hpc: ^
17:26:40 <hpc> oh, it makes them bytestrings?
17:26:42 <revenantphx> You do {-#LANGUAGE OverloadedStrings #-} at the top
17:26:50 <revenantphx> and it makes "this" default to :: ByteString
17:26:54 <hpc> i thought it turned String into String a => a
17:26:59 <shachaf> revenantphx: No it doesn't.
17:27:01 <revenantphx> idk
17:27:02 <mauke> hpc: yes
17:27:08 <shachaf> Overloading strings as ByteStrings seems a bit suspicious, at any rate.
17:27:09 <akahn> hm, I'm not sure I want that, because then would I not be able to deal with unicode in other places?
17:27:10 <revenantphx> hpc: that'd make more sense then.
17:27:20 <revenantphx> akahn: yeah, just pack byte strings then
17:29:54 <akahn> revenantphx: thanks. so, trying that, B.pack "Authenticate", I get an compile error that I'm giving pack a [Char] but it expects [GHC.Word.Word8]. How do I address this?
17:30:08 <akahn> B is Data.ByteString, btw
17:30:15 <revenantphx> @hoogle [Char] -> ByteString
17:30:15 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
17:30:15 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:30:15 <lambdabot> Prelude error :: [Char] -> a
17:30:16 <mauke> Data.ByteString.Char8
17:30:26 <revenantphx> import the Char8 module
17:30:32 <akahn> ok
17:31:51 <akahn> Using that, I get an error that the Request constructor is expecting an Ascii, but getting a B.ByteString from me... but Ascii is just a type synonym for ByteString defined in Network.HTTP.Types. What's the issue here?
17:32:10 <akahn> my mistake, this error is happening somewhere else
17:32:45 <pelotom> wow, http://tryhaskell.org/ is acting really weird
17:33:17 <Taslem> How do I set the default CD path in GHC?
17:33:20 <Taslem> *ghci
17:33:38 <mauke> what's a cd path?
17:33:57 <Taslem> The thing you get when you say :!cd
17:34:46 <fryguybob> Taslem: I would recommend using ghci from a console window directly.
17:34:59 <Taslem> Eh, okay then.
17:35:38 <mauke> that's its current working directory
17:35:43 <mauke> it's inherited from the calling program
17:36:09 <akahn> Actually, yeah, the compiler is telling me that I need to give it Ascii items but I'm giving it ByteStrings. Ascii is a type synonym for ByteString. How can I handle this?
17:36:36 <mauke> akahn: is it a synonym for ByteString.Lazy?
17:36:40 <Berengal> akahn: Beware that there are two different ByteString types
17:36:59 <akahn> no, just ByteString: http://hackage.haskell.org/packages/archive/http-types/0.6.1/doc/html/Network-HTTP-Types.html#t:Ascii
17:37:16 <mauke> akahn: that proves nothing
17:37:27 <akahn> D:
17:37:37 <mauke> hmm
17:37:41 <Berengal> akahn: Which ByteString are you using?
17:37:44 <mauke> do you have a testcase?
17:37:54 <akahn> i'm using Data.ByteString.Lazy.Char8
17:37:58 <mauke> argh
17:38:07 <mauke> GUESS WHAT
17:38:18 <akahn> What?
17:38:27 <akahn> I don't have a testcase but I could make one
17:38:28 <mauke> you're using Data.ByteString.Lazy
17:38:36 <aristid> Ascii from http-types is strict ByteString.
17:39:24 <akahn> I will switch to using strict ByteString, thanks.
17:40:08 <aristid> well they are convertible
17:40:27 <Taslem> http://hackage.haskell.org/packages/archive/gloss/1.0.0.1/doc/html/Graphics-Gloss.html    Has an error I think...  
17:40:33 <mauke> but it's easier to use what most of the libraries want
17:40:36 <Taslem> Because it lists a function that doesn't exist.
17:40:43 <Taslem> Or, at least, that isn't in scope.
17:41:29 <luite_> Taslem: you probably have version 1.3.1.2 installed, or 1.3.0.1
17:41:34 <luite_> Taslem: see ghc-pkg list
17:41:50 <luite_> and then use the documentation for the correct version :)
17:42:36 <Taslem> I see.
17:42:46 <Taslem> Any idea why they removed simulateIndWindow in newer versions?
17:43:04 <Taslem> Oh, Is ee, they just moved it.
17:45:15 <Taslem> Yay! I have a mutating genetic generative art program in Gloss!
17:45:47 <aristid> akahn: which part of http-types are you using, if i may ask? Header?
17:47:21 <akahn> aristid: yes, http-enumerator uses Header and Query, and the HTTP methods
17:47:59 <aristid> yeah :)
17:48:06 <akahn> now attempting to deal with the fact that headers are supposed to be CaseInsensitives 
17:49:11 <aristid> do you use OverloadedStrings? useful for that.
17:49:25 <aristid> http-types also defines some convenience functions for commonly used headers
17:49:49 <aristid> headerAccept and so on: http://hackage.haskell.org/packages/archive/http-types/0.6.1/doc/html/Network-HTTP-Types.html#g:5
17:49:59 <Taslem> Woot! I made something some limited use!  Time to expand!
17:50:21 <akahn> I'm not using OverloadedStrings. It was suggested above but I was concerned that I wouldn't be able to deal with unicode encoded responses if I set that. But maybe I don't understand what it does.
17:50:45 <akahn> aristid: yeah, saw that. none for Authenticate, unfortunately.
17:51:10 <aristid> akahn: OverloadedStrings just allows you to initializes arbitrary string types with normal string literals
17:51:26 <akahn> i wouldn't need to use the Request constructor explicitly at all if parseUrl understood foo:bar@ as authentication, it seems to think I'm specifying a port when I do that
17:51:27 <aristid> this way, "a" can be of type String, but also ByteString, Text, CI Ascii...
17:51:33 <akahn> ah. that sounds handy
17:51:34 <Berengal> akahn: OverloadedStrings just makes string literals polymorphic
17:51:44 <Berengal> akahn: The same way number litterals already work
17:51:53 <Berengal> literals*
17:51:56 <akahn> sign me up ;)
17:52:10 <aristid> {-# LANGUAGE OverloadedStrings #-}
17:52:14 <aristid> that's all you need :)
17:53:09 <akahn> thanks, this is making things simpler already
17:53:30 <akahn> this is my first time attempting to write real haskell code. i appreciate the help
17:54:17 <aristid> akahn: which headers do you need btw? if they are commonly used headers, i can add them to http-types :)
17:54:47 <akahn> aristid: I'm using Authenticate
17:54:58 <aristid> is that a standard header?
17:55:25 <akahn> I believe so
17:55:31 <aristid> not really. but Authorization is.
17:56:11 <akahn> whoops
17:56:14 <aristid> akahn: or did you actually mean Authorization? :)
17:56:18 <akahn> i did, yes.
17:56:53 <Berengal> Wikipedia says it's called WWW-Authorization...
17:57:08 <Berengal> No wiat
17:57:14 <Berengal> That's the server response
17:57:21 <Berengal> And it's WWW-Authenticate
17:57:45 <aristid> Berengal: WWW-Authenticate is another header.
17:57:55 <aristid> Authorization is in rfc 2616 too
17:58:33 <akahn> Anyways, at some point I'll have to try my hand at patching parseUrl to understand the foo:bar@ syntax
18:01:48 * hackagebot http-types 0.6.2 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.2 (AristidBreitkreuz)
18:01:55 <aristid> akahn: just added Authorization to the list of headers with convenience functions, and released it as http-types 0.6.2 :)
18:03:57 <akahn> awesome, thanks
18:04:09 <aristid> akahn: to use it, the following command should help: cabal update && cabal install http-types http-enumerator
18:04:56 <akahn> What is the reason I'd need to install http-enumerator again?
18:06:35 <aristid> because you want to make sure that http-enumerator does not use the old version of http-types
18:12:00 <elliottcable> micahjohnston: here
18:12:04 <elliottcable> micahjohnston: ask for help :D
18:12:06 <micahjohnston> lol
18:12:16 <micahjohnston> no one in here knows Paws
18:12:39 <elliottcable> I know Paws, they know Haskell, PROBLEM SOLVED™
18:13:09 <micahjohnston> so I'm trying to implement a highly parallel programming language, and I'm not sure which tools I should use in Haskell to do that
18:13:59 <micahjohnston> it's an impure language, so the different threads of execution need to be able to do impure things
18:14:18 <micahjohnston> so I don't think ST or par/pseq are the answer
18:18:00 <pelotom> micahjohnston: sounds like that leaves you with forkIO?
18:18:12 <micahjohnston> pelotom: yeah, that's what I think
18:18:19 <micahjohnston> I was wondering if there's something else magical that I don't know about
18:18:37 <micahjohnston> thanks
18:20:32 <micahjohnston> suggestions for where to learn it, or are the haskell.org docs simple enough?
18:21:04 <RenJuan> same as it ever was
18:21:28 <RenJuan> sorry, couldn't help myself
18:21:47 <KSkrzet> what are options for showing reverse dependencies for hackage packages?
18:22:54 <micahjohnston> RenJuan: ?
18:24:07 <RenJuan> micahjohnston, nm. Are reverse dependencies the set of things dependent upon something?
18:31:06 <KSkrzet> I have a wild idea: maybe someone can implement serialization with sharing using vacuum library?
18:35:51 <mm_freak> micahjohnston: there are quite a few concurrency libraries on hackage…  perhaps they provide some higher level abstractions
18:36:09 <micahjohnston> mm_freak: ok, I'll check them out
18:36:54 <mm_freak> micahjohnston: but if your language itself doesn't use high level abstractions, i doubt that anything but forkIO will be useful to you
18:37:02 <micahjohnston> ok
18:55:58 <akahn> What does the error "Stage restriction: `auth' is used in a top-level splice or annotation, and must be imported, not defined locally" mean?
18:57:21 <ddarius> Something along the lines that you can't use functions defined in a module in a splice within the same module.
18:58:39 <akahn> What does the word 'splice' mean in this context?
18:58:46 <ddarius> $(foo)
19:07:22 <akahn> Hm, I'm not doing that in my code.
19:07:42 * hackagebot hmatrix-gsl-stats 0.1.2.10 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.10 (VivianMcPhail)
19:09:42 <Berengal> Does ord return the unicode codepoint of a character?
19:12:36 <ncalday> Is there a way to overload (^) using instance?
19:16:09 <ddarius> akahn: Which GHC are you using?
19:16:24 <ddarius> Berengal: Yes.
19:16:33 <ddarius> ncalday: No.
19:17:11 <ncalday> ddarius: Thanks. Is there a way to do so without using instance?
19:17:11 <ddarius> @src (^)
19:17:11 <lambdabot> x ^ 0            =  1
19:17:11 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
19:17:12 <lambdabot>   where f _ 0 y = y
19:17:12 <lambdabot>         f x n y = g x n
19:17:12 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
19:17:13 <lambdabot>                       | otherwise = f x (n-1) (x*y)
19:17:15 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
19:17:33 <mgsloan> 'lo all! I'm curious, has a different operator precedence system been proposed for haskell?  I've been thinking lately that it should be based on partially ordered sets, and using two operators which are incomparable, in a row, would be a compile error.
19:17:51 <ddarius> If you make a Num instance for whatever type you are using, it will use that, in particular multiplication and fromInteger 1.
19:18:06 <ddarius> But it will always use the same algorithm.
19:18:25 <ncalday> Gotcha. yeah, that's what I did the first time (units system) but then I put in a negative exponent
19:18:33 <ddarius> You can hide the Prelude (^) if you want and define your own, but that won't change any definitions using the Prelude (^).
19:18:46 <ncalday> Noted.
19:18:47 <ncalday> Thanks
19:18:51 <ddarius> Use (^^) if you want to allow negative exponents.
19:19:27 <ddarius> mgsloan: Ideas like that have been suggested, though I doubt anything close to a formal proposal has been made.
19:21:38 <mgsloan> gotcha.  Haskell' is an ongoing process, right? perhaps this could be -XOperatorLattices
19:22:43 <ddarius> The new process is a new standard yearly, but there have to be proposals.  Preferably ones that are implemented in at least one significant Haskell implementation, though that's not necessary.
19:23:56 <mjrosenb> *cough* ghc *cough*
19:24:03 <reacocard> I just stared using Yesod, and I can't find any documentation on how to put a widget inside another widget. How can i accomplish this?
19:25:55 <ddarius> mgsloan: Also, while using a partially ordered set is the natural thing to do, it has some modularity and extensibility issues that aren't immediately obvious to me how to resolve (which is not to say they aren't present in the current system.)
19:28:33 <mgsloan> hmm, the point to me is encouraging modularity, eg, not having to worry about your operators interfering with those from other libs
19:29:30 <mgsloan> I suppose there is the issue that you could have independent modules declare contradictory orderings..
19:30:02 <mgsloan> I guess cycles would imply equality between all elements involved
19:30:07 <ddarius> An algorithm for detecting orderings that lead to something that is not a poset would be necessary, though I imagine there's a standard one.
19:30:14 <akahn> ddarius: 6.12.3
19:30:43 <dolio> Cycles would imply equality?
19:31:02 <dolio> Are you only able to declare op1 <= op2?
19:32:12 <ddarius> akahn: In a fairly recent GHC, I think it was the 7 series though maybe a bit earlier, GHC allowed writing just 'foo x' instead of '$(foo x)' for splices.  You could have something like that at the top-level, however, you should need to explicitly enable Template Haskell to get an error like that.
19:35:58 <akahn> I'm not sure what a splice is, really. the function in question is just `auth user = encode (user ++ ":password")`
19:37:32 <poneill> Hello, I was hoping to know if anyone could point me to some papers on implementing regular expressions as a data type, and maybe doing some equational reduction thereto.  Thanks in advance
19:39:06 <mrakan> When I do a "cabal install" of package A that relies on package B, and then delete package B, can I still use package A?
19:39:22 <mrakan> Does package A contain everything it needs from package B?
19:39:34 <ddarius> Define "delete package B"
19:39:36 <poneill> example: if r is a regular expression, then 1r = r1 = r for all r.  My first attempt at implementation failed with the "cannot construct the infinite type t = Regexp t" error
19:40:34 <mauke> data Regexp = Sym Char | Union Regexp Regexp | Star Regexp
19:40:36 <mrakan> ddarius: I simply remove the directory containing the package. Are there other ways? Is there a way to free up space taken by package B and still have package A work? (I'm distributing a Haskell program.)
19:40:50 <mauke> heh
19:40:58 <mauke>  | Concat Regexp Regexp
19:41:32 <poneill> mauke: thanks, I started along those lines
19:41:55 <poneill> mauke: that works fine, but I'd also like to simplify expressions algebraically
19:42:12 <poneill> here's an example of what I'm trying to do: http://hpaste.org/45510/regexp
19:42:39 <monochrom> mrakan: you have broken things then
19:42:49 <mauke> poneill: why do you have separate Atom and Re?
19:42:56 <ddarius> mrakan: Well once a package is built you are going to have some binary library files, you can link against those without their source whenever if that's what you want to do.
19:43:12 <poneill> the function simpRegexp should run over a regexp and look for instances of r+r, which you can simplify to r
19:43:58 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for what files are where
19:44:10 <poneill> mauke: uh, that was basically a sanity check.  I get the same answer whether I have Re a' or Atom a'
19:44:16 <mrakan> ddarius: These are the *.o files, I assume? So, they are the minimum needed to successfully use package A?
19:44:23 <mauke> poneill: both are wrong
19:44:26 <poneill> mauke: or the same error, rather
19:44:49 <mauke> poneill: remove Re from the data definition; | a' == b' = a'
19:45:12 <ddarius> mrakan: I would say everything in the .cabal/lib/<package> directory is potentially needed.
19:46:36 <ddarius> That's if the user wants to compile your library but not the dependent library.  Personally, I would distribute as source as a cabal package which will fetch the dependencies as needed, and also as a completely built binary which would have no dependencies like this.
19:47:15 <poneill> mauke: ok, so is there a natural way to perform the simplification?  I grant that I don't understand the type system very well, but is there a paper or tutorial you could recommend?  It's not obvious to me why this fails
19:47:38 <mauke> poneill: because a' is not a symbol; it's a regex
19:48:08 <mrakan> ddarius: I see. Thanks. monochrom: Thanks for the link.
19:48:52 <poneill> mauke: ah jeez, that's right.  Thanks for stepping through that with me
20:00:19 <blackdog> is it possible to derive instances outside the definition of a type?
20:00:30 <mauke> yes
20:00:39 <blackdog> i've currently got 'deriving Arbitrary' on a type - i'd like to move that into a tests-only file 
20:00:42 <blackdog> how do i do that?
20:00:55 <mauke> {-# LANGUAGE StandaloneDeriving #-}
20:00:56 <Axman6> deriving instance Aribitrary
20:01:29 <blackdog> great, thank you.
20:02:15 <blackdog> mauke: that'd tie you to GHC, then? or is it in a newer revision?
20:02:37 <mauke> GHC as opposed to what?
20:02:44 <monochrom> you will receive a warning of "orphan instances". it is harmless except for slightly less efficient separate compilation.
20:02:52 <mgsloan> dolio: sorry for the delay, but yes, you would only be able to declare op1 <= op2
20:03:39 <mgsloan> possibly declaring '<' to mean '<=, and a compile error should be raised if op2 <= op1 is declared
20:03:52 <blackdog> mauke: jhc? uhc?
20:04:02 <blackdog> not a real issue right now, but i'd like to know what i'm trading off
20:05:17 <dolio> So, if you have 'x `op1` y `op2` z', whether that can parse depends on whether there are other operators in scope that create a cycle involving op1 and op2.
20:05:54 <dolio> Or, if not whether it can parse, how it parses.
20:06:22 <mgsloan> right.  that is kinda ugly that their relations to other operators can effect their situation
20:06:36 <dolio> If op1 <= op2, and both are infixl, then without a cycle you get x `op1` (y `op2` z), but if a cycle is introduced you get (x `op1` y) `op2` z.
20:06:51 <ddarius> In my opinion, a cycle would be an error.
20:07:46 <mgsloan> yeah, cycles should be an error.  This definitely means that operator precedence constraints would need to be conditionally exported / hideable on import
20:09:24 <mgsloan> as long as I'm making proposals, import statements in where expressions would be a cool way to do local-imports, possibly avoiding import qualification
20:09:30 <akahn> When I attempt to use this httpLbs function, I get an error about the ambiguous type variable m in the constraint. How can I resolve this issue?http://hackage.haskell.org/packages/archive/http-enumerator/0.5.1/doc/html/Network-HTTP-Enumerator.html#g:1 
20:10:10 <mgsloan> (I realize a haskell-cafe post would be the most valuable way to go about this discussion, I should probably do that now that I've created freetime for myself..)
20:13:10 <blackdog> i'm trying to write Arbitrary instances on a newtype using standalone deriving. this works fine, but it means i now have to export the constructors for my datatype. what'd be the clean way to handle it? i guess i could always have a wrapper module that only exports the things i want to export, and have the tests run on the internal module, but it's still a bit ick.
20:13:29 <blackdog> sorry, the constructor for my newtype.
20:19:00 <TTimo> omahgad a print version of LYAH
20:19:56 <Axman6> n*
20:20:44 <ddarius> mgsloan: You may want to search Haskell-Cafe first.
20:28:18 <TTimo> so I am using the forM monad function to execute a bunch of IO actions .. but I now realize that I have to pass some state around between each iteration .. how do I need to transform my code to achieve that?
20:29:19 <monochrom> oh yikes, indeed we need data constructors for standalone deriving
20:29:35 <ddarius> monochrom: Which makes complete sense.
20:30:05 <gwern> TTimo: use a fold?
20:30:28 <gwern> @hoogle foldM
20:30:29 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:30:29 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
20:30:29 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:33:19 <monochrom> I am not so sure that it makes sense.
20:33:52 <monochrom> first I should clarify that "we need" means "we need import into scope"
20:35:21 <monochrom> it is an open secret that ghc knows all the unexported data constructors despite not-in-scope. for example at the ghci prompt, with just Prelude in scope, :info Integer tells you all about S# and J#
20:35:34 <ddarius> monochrom: I can break encapsulation otherwise potentially.
20:37:33 <ddarius> For example, if you are using the LCF methodology and have data Thm = -- abstract, then being able to add an Arbitrary instance without restriction would be catastrophic.
20:38:29 <monochrom> alright I guess
20:40:09 <monochrom> no, not alright. Arbitrary is not an example.
20:42:11 <TTimo> gwern: thanks, going to screw around with that see if I can figure it out
20:42:25 <monochrom> this hinges on ghc not being capable of "deriving Arbitrary" on normal ADTs.
20:43:10 <gwern> monochrom: hm, why can't it do that? it seems pretty easy - define the tree of all entries in that ADT and then randomly descend it x levels or something
20:43:20 <monochrom> as for newtype deriving Arbitrary, well if the underlying ADT doesn't already have Arbitrary, the newtype can't have it either
20:43:52 <ddarius> gwern: It just doesn't.
20:44:02 <gwern> oh. lack of manpower
20:44:09 <osoleve> @pl simpleFind p path = getRecursiveContents path >>= \names -> return (filter p names)
20:44:09 <lambdabot> simpleFind = flip ((>>=) . getRecursiveContents) . (return .) . filter
20:44:15 <ddarius> gwern: Not really.  
20:44:16 <osoleve> will I ever understand that?
20:44:17 <monochrom> I am not talking about Turing-computability.
20:44:25 <ddarius> monochrom: Nevertheless, deriving Read is an example.
20:45:15 <monochrom> alright, deriving Read works
20:48:20 <ddarius> At any rate, standalone deriving (or deriving) should never do something you couldn't do by hand.
20:50:01 <osoleve> @unpl simpleFind = flip ((>>=) . getRecursiveContents) . (return .) . filter
20:50:01 <lambdabot> simpleFind g c = (getRecursiveContents c) >>= \ p -> return (filter g p)
20:50:23 <osoleve> lambdabot amazes me
20:50:24 <monochrom> if you also @undo, you will see more :)
20:50:55 <monochrom> err, the inverse of @undo, but lambdabot probably doesn't have it
20:51:00 <ddarius> simpleFind p path = fmap (filter p) (getRecursiveContents path)
20:51:04 <ddarius> @redo
20:51:04 <lambdabot> Maybe you meant: do read todo undo
20:51:18 <ddarius> @do m >>= \x -> f x
20:51:18 <lambdabot> do { x <- m; f x}
20:51:23 <monochrom> alright nice
20:51:49 <ddarius> Or in the modern Haskell, simpleFind p path = filter p <$> getRecursiveContents path
20:52:04 <osoleve> monochrom: I already took that from a do, to make sure I could :)
20:52:54 <Berengal> Memory management sucks donkey balls
20:53:17 <monochrom> generally, all managements do
20:53:38 <Berengal> Not dependency management
20:53:41 <Berengal> In theory at least
20:53:47 <monochrom> har har har
20:53:51 <djahandarie> No management sucks in theory
20:54:02 <osoleve> middle management?
20:54:10 <Berengal> Manual memory management sucks in theory too
20:54:25 <monochrom> depends on whose theory
20:54:30 <jargonjustin> I'm trying to understand how to model a network protocol using request / response. Using something like an Iteratee to abstract the IO from the protocol logic seems reasonable, but how should command be modeled? Use a Writer monad? Yield command's along with a continuation Iteratee?
20:54:30 <BMeph> simpleFind = (. getRecursiveContents) . fmap . filter ? ;)
20:54:56 <Berengal> My theory. It goes something like this: Memory Management -> Sucktitude
20:54:58 <osoleve> now you're just messing with me :-P
20:55:11 <ddarius> Berengal: What's the proof term?
20:55:43 <monochrom> dennis ritchie's theory would probably disagree with your theory
20:55:56 <Berengal> ddarius: Simple; Sucktitude : Prop where [...] Memory Management -> Sucktitude [...]
20:56:37 <monochrom> goes a long way to show how "___ in theory" statements are flawed. whose theory? don't speak like everyone uses the same theory
20:57:11 <ddarius> "___ in theory" statements are flawed in theory.
20:57:37 <monochrom> but of course the honest "___ in my theory" lacks the authoritative tone
21:00:08 <Berengal> Oh wait, now it sucks less
21:00:44 <Berengal> I was strugling with the fact that I had a ForeignPtr passed to C that could possibly come out again somewhere else
21:01:11 <monochrom> C is a can of wormholes? :)
21:01:26 <ddarius> Memory is a can of wormholes.
21:01:27 <Berengal> But then I found I had a reference to the old ForeignPtr available, and could also avoid the C call altogether
21:03:22 <xplat> who cares about theory?  manual memory management sucks in practice :P
21:06:01 <mrakan> Can I somehow install a package into ghc/lib/extralibs, and not into a cabal directory?
21:08:52 <digitteknohippie> um... not using cabal, n using your package manager insead?
21:09:40 <mrakan> digitteknohippie: I'm on Windows, sadly.
21:09:57 <mrakan> When doing cabal install --global, it gets placed into Program Files/Haskell.
21:10:34 <mrakan> I need everything in a single place. Manually moving it to extralibs (and modifying the appropriate *.conf file so it references the new directory) doesn't seem to work...
21:17:26 * ddarius thinks, in a few years, he'll move to Ireland.
21:33:26 <jargonjustin> How do I check what version of a package GHC is using?
21:33:36 <monochrom> mrakan: you can edit <appdata>/cabal/config to control directories used for --global
21:34:30 <monochrom> c:\Users\blah\AppData\Roaming\cabal\config
21:41:26 <mrakan> monochrom: Thanks, that worked!
21:54:21 <adorablepuppy> I want to compare 2 elements in a list to each other in a list comprehension, do I just say x <- thing, y <- thing, comparionshere?
21:54:57 <Berengal> adorablepuppy: Yes
21:55:13 <adorablepuppy> thanks. Thought it looked right. Second guessing myself.
21:55:15 <Axman6> well, it depends what you want...
21:56:55 <adorablepuppy> Axman6: Well, I have these [Pixel]. My Pixel is made of (Location2D x y) and (PixelColor r g b a). Basically, if x has a color of a certain value, I want to check if y has an adjacent location to x and is another certain pixel value.
21:57:09 <espringe> I've written some nooby haskell: http://hpaste.org/45517/generator
21:57:10 <espringe> And to call it slow would be an insult to the word slow. It consists of two phases, first bulding a trie. And the second step, converting the trie to C
21:57:16 <espringe> How can i force 1 stage first
21:57:21 <espringe> and print "Finished generating trie" 
21:57:27 <espringe> That way I can tell which part is ridiciliously slow
21:57:30 <espringe> and work on improving that
21:58:11 <espringe> (It seems to be processing data at the breakneck speed of 1 KiB / 5 seconds) 
21:58:18 <espringe> I need like two orders of magnitude faster
21:58:26 <espringe> (preferably three)
22:00:26 <espringe> Actually never mind. Found a serious bug in it
22:00:28 <mrakan> espringe: Break "writeFile output . toC . cmuToTrie =<< readFile input" into two lines, insert print "Finished" between them. To force evaluation of first line, just print out the result. (Or use something like Data.Deepseq.)
22:00:49 <espringe> mrakan: Ok, i'll try that too
22:00:51 <espringe> thanks
22:01:16 <espringe> mrakan: Actually how does that work?
22:01:23 <espringe> Could you give an example of how i'd split that into two lines?
22:01:32 <mrakan> espringe: Sorry, Control.Deepseq.
22:02:01 <adorablepuppy> Axman6: Well, I have these [Pixel]. My Pixel is made of (Location2D x y) and (PixelColor r g b a). Basically, if x has a color of a certain value, I want to check if y has an adjacent location to x and is another certain pixel value.
22:02:07 <adorablepuppy> arg. Sorryy
22:02:36 <adorablepuppy> I ment to hit CTRL+Up and hit enter in emacs on the console.
22:03:06 <mrakan> espringe: First line would be something like "trie <- cmuToTrie `fmap` readFile input"
22:04:02 <mrakan> espringe: Then you'd do "print trie". And then, "print $ toC trie". Then you'll get output after each step.
22:04:11 <osoleve> why does this give Not in scope: data constructor 'IOException'? I import it from Control.Exception...
22:04:14 <osoleve> http://codepad.org/nTpG8han
22:05:02 <mrakan> espringe: "print trie" will force evaluation of (trie), and "print $ toC trie" will force evaluation of (toC trie).
22:06:06 <espringe> mrakan: Thanks
22:07:29 <mrakan> osoleve: Are you sure it's a constructor? I think it's just a type with no exposed constructors.
22:08:07 <mrakan> osoleve: So you'd do something like (\e -> print (e :: IOException)).
22:08:07 <monochrom> IOException is absolutely a type name not a data constructor name.
22:09:21 <osoleve> so what should I change that part of handle to to make it legal?
22:11:38 <mrakan> osoleve: You just have to add a type signature to the handlers input, I believe. With an extension, I think you could do something like: (\(e :: IOException) -> return Nothing).
22:12:28 <mrakan> osoleve: Or perhaps doing ((\_ -> return Nothing) :: IOException -> m (Maybe n)) might work.
22:15:12 <osoleve> it makes me sad that I have to fix the examples from RWH :/
22:15:36 <ivanm> RWH uses base-3 rather than base-4 ...
22:16:32 <mrakan> Which is a pity, since those interested in Haskell often get pointed to RWH as a sort of definitive guide.
22:16:36 <monochrom> add a user comment there to request for update
22:16:49 <osoleve> monochrom: there are like 10 :/
22:17:01 <monochrom> interesting
22:17:04 <ivanm> monochrom: I didn't think that they were updating the website :s
22:17:25 <ivanm> it's a pity base-4 + extensible-exceptions came out so soon after RWH did :s
22:17:27 <mrakan> Yes, if I remember correctly there's a lot of errors there...
22:17:43 <monochrom> bloody hell, they even have unfinished chapters planned to be finished in the future, what do you mean they won't update it :)
22:17:54 <ivanm> monochrom: :o
22:18:20 <mrakan> monochrom: Perhaps it's the slowness of the updates that tricked us :)
22:19:01 <mrakan> RWH is still a very good resource, of course. Nothing like it out there...
22:19:29 <monochrom> the other fun one is that LYAH goes to print before mtl-2 and comes out in print after mtl-2, so examples like "State $ \s -> blah" breaks.
22:20:25 <osoleve> i can't get this to work :( does anybody have any other ideas?
22:21:58 <ivanm> monochrom: really? when did it go to print?
22:22:17 <ivanm> I thought there was talk of having mtl-2 be monads-fd for a while...
22:23:12 <mrakan> osoleve: This doesn't work? http://codepad.org/meKtWq73
22:23:17 <osoleve> okay, if I import COntrol.OldException it works with (\_ -> return Nothing)
22:24:16 <monochrom> actually by "goes to print" I mean "begins the whole publishing process of infinitely many editing that takes centuries". that's a century ago.
22:24:24 <ivanm> Control.OldException is going the way of the dodo soon though, isn't it?
22:24:29 <osoleve> mrakan: that works
22:24:34 <ivanm> monochrom: heh
22:24:34 <Rotaerk> I don't like RWH because the examples seem too ... big
22:24:40 <osoleve> mrakan: thank you
22:24:46 <mrakan> osoleve: No problem.
22:24:47 <Rotaerk> I feel like they dillute the book and make it take longer to learn haskell itself
22:25:14 <osoleve> i'll leave a comment with it for future readers
22:25:24 <monochrom> that's what you get for asking for "real world" examples. big.
22:25:30 <mrakan> osoleve: The important thing is to tell GHC what type of value gets given to the handler.
22:25:39 <mrakan> osoleve: And we do that with a type annotation.
22:25:49 <monochrom> did you know that a "real world example" for OOP is at least 500 lines?
22:26:11 <ivanm> monochrom: you mean bank account examples aren't "real"? :o
22:26:12 <ivanm> :p
22:26:22 <xrl> I'm working through learn you a haskell and I've got a questions about currying functions... I don't like how "let compareWithHundred = compare 100" works... can I switch how the arguments are applied?
22:26:56 <ivanm> xrl: not familiar with it, can you provide a link or just the source of the function here?
22:26:58 <monochrom> bank account code isn't real unless some cobol and some vb is involved
22:27:15 <Rotaerk> apply a flip function to it, xrl?
22:27:18 <listofoptions> ik V
22:27:20 <xrl> compareWithHundred 10 should return LT, but with the current definition it returns GT
22:27:21 <ivanm> monochrom: but cobol isn't OOP!
22:27:22 <osoleve> oh and guys, thanks for being so patient and friendly. you're amazing.
22:27:32 <listofoptions> *ik... VB
22:27:39 <xrl> Rotaerk: ohh, I hadn't thought of that!
22:27:45 <Berengal> xrl: flip compare 100
22:27:46 <ivanm> xrl: yeah, looks like it needs a flip
22:27:54 <xrl> schwing
22:27:55 <ivanm> did you find a typo in LYAH as it's being printed? :O
22:27:56 <ivanm> :p
22:28:06 <monochrom> yeah, bank account code can't be fully OOP either
22:28:07 <Berengal> > (compare 100 10, flip compare 100 10)
22:28:08 <lambdabot>   (GT,LT)
22:29:00 <mrakan> Berengal: what is this madness?
22:29:04 <osoleve> > (`compare` 100) 10
22:29:05 <lambdabot>   LT
22:29:31 <mrakan> Berengal: Oh, no wait, everything's okay.
22:29:41 <xrl> but when I say "compareWithHundred 10" I expect it to say LT
22:29:55 <xrl> now I'm fouling up how I define it...
22:30:10 <xrl> "compareWithHundred = flip (compare 100)" isn't right
22:30:22 <Berengal> xrl: Just "flip compare 100"
22:30:39 <mrakan> xrl: The compare gets flipped, not the (compare 100).
22:31:25 <xrl> I'm going to let that settle in... thanks for the help :-D
22:35:08 <Axman6> @src flip
22:35:08 <lambdabot> flip f x y = f y x
22:37:23 <xrl> flip is funky
22:39:19 <Rotaerk> it's a pretty basic high-order function
22:39:56 <monochrom> in fact...
22:40:28 <monochrom> > let flip flip x y = flip y x in flip (:) "haha" 'h'
22:40:29 <lambdabot>   "hhaha"
22:40:50 <ivanm> @slap monochrom 
22:40:50 * lambdabot puts on her slapping gloves, and slaps monochrom
22:42:09 <monochrom> > let slap slap lambdabot monochrom = slap monochrom lambdabot in flip (\x y -> x ++ " slaps " ++ y) "lambabot" "monochrom"
22:42:10 <lambdabot>   "monochrom slaps lambabot"
22:42:28 <xrl> Rotaerk: flip is a great example of a high-order function... and he brings it up later "doh"
23:13:24 <adorablepuppy> If I'm parsing pixels, and color values indicate direction of the next pixel, how can I detect recursive patterns?
23:13:42 <adorablepuppy> All these pixels are in a list, of course.
23:14:13 <shachaf> A list might not be the ideal data structure.
23:14:44 <adorablepuppy> For?
23:15:06 <shachaf> Going in any direction other than forward.
23:16:05 <adorablepuppy> It's working just fine, until I do something recursive.
23:16:52 <ddarius> You writing a Piet interpreter?
23:17:00 <mrakan> adorablepuppy: This sort of operation. Perhaps shachaf has arrays in mind. Also, I guess you could do it by remembering which pixel you've visited. If you visit an already visited pixel, and the next pixel to visit is defined only by the current pixel, then you know you're in a recursive loop.
23:17:11 <adorablepuppy> ddarius, no I'm writing a game that include steganography as a magic system.
23:20:18 <adorablepuppy> mrakan: I figured it would come down to something like that. I might have to abandon the list comprehension method I'm using and stick to a regular recursive function.
23:20:57 <shachaf> Oh, that's what you mean by recursive patterns.
23:22:12 <ddarius> You have a directed graph.  The colors denote out-links.  Finding cycles in a graph is a solved problem.
23:22:20 <sanjoyd> Is there a version of putStrLn with the type String -> IO String?
23:22:44 <sanjoyd> I'm inside main::IO [String], and which I can use readLn, putStrLn throws a type error.
23:22:50 <adorablepuppy> ddarius: The colors not only denote direction, but also value.
23:24:21 <ddarius> adorablepuppy: If the colors tell how far to move, then that doesn't change anything.  If the values are irrelevant to the connectivity, then they are irrelevant.  Only if the colors can change do you start having problems.
23:25:31 <ddarius> If the colors can change, you may well have something that's Turing-complete (or at least a potentially large FSM.)
23:25:48 <adorablepuppy> ddarius: Some values are relevant to connectivity, I've got a "jump command" in two pixels, then a sequence of numbers to tell it how far to go, and the color of those numbers tell the direction, and the value is there too.
23:26:42 <adorablepuppy> I could cut the jump command because it's only there to preserve the "art" factor. . . 
23:28:35 <ddarius> As far as I can tell, that just means you have to "lex" the input and then you get your graph with the issue that you presumably can jump into the "middle" of a command.  Or you have other "commands" and this is just a programming language with funny notation, in which case you are likely in the Turing-complete case.
23:31:24 <adorablepuppy> ddarius, yes, quite. I'm building a lexer of sorts. First step was to determine how many programs there were in the file. I  looked for the pixels that made start happen, then feed those pixels into something that looks for other commands of the end command.
23:31:50 <mrakan> sanjoyd: Why is main :: IO [String]? It should be IO () surely. If putStrLn returns an IO String, what would that returned String be?
23:33:02 <applicative> @type \str -> putStr str >> return str
23:33:03 <lambdabot> String -> IO String
23:34:13 <mrakan> applicative: I think he transformed main to be IO [String] because he didn't extract the value a read action would return...
23:34:38 <sanjoyd> I did it because I'm an idiot who is new to Haskell.
23:34:40 <applicative> main :: IO [String] is legitimate, for some reason
23:34:49 <sanjoyd> I'm still trying to figure some things out.
23:34:53 <applicative> sanjoyd, excellent 
23:35:17 <applicative> @pl \f g x -> f x >> g x
23:35:18 <lambdabot> liftM2 (>>)
23:35:23 <ddarius> The Report states that the most general type of main is IO a.
23:35:29 <mrakan> sanjoyd: Don't be too harsh on yourself, it takes a bit of time to wrap your head around Haskell.
23:35:31 <applicative> right
23:35:56 <ivanm> applicative: yes, but you can't get the [String] as a return value from your program
23:36:06 <applicative> no, of course not.  
23:36:29 <shachaf> runghc has a weird bug with main :: IO a where a is in Show and isn't ().
23:36:30 <ivanm> so unless you either a) don't want to put a "return ()" at the end or b) are calling main from elsewhere, there's no point in having a return type being anything except IO ()
23:36:36 <ivanm> shachaf: :o
23:36:43 <ivanm> well, () is in Show... ;)
23:36:54 <applicative> but there are for example people who make main recursive.  main = putStrLn "a line" >> main
23:36:57 <shachaf> ivanm: If it wasn't I wouldn't have needed to specify.
23:37:14 <shachaf> ivanm: It behaves like ghci with IO actions.
23:37:38 <applicative> > ()
23:37:38 <lambdabot>   ()
23:37:58 <applicative> @type 
23:37:59 <lambdabot> <no location info>: not an expression: `'
23:40:28 <applicative> why shouldn't "" have a type?  e.g. a -> a
23:40:59 <ddarius> Because, as the error message clearly states, it's not an expression.
23:42:11 <applicative> No, I think the Haskell committee didn't want to let us in on the implicit monad we're writing in. 
23:42:33 <sanjoyd> What does "Prelude.readIO: no parse" mean?
23:44:16 <applicative> what was it supposed to read the string as an expressionfor?
23:44:24 <applicative> It couldn't manage to do it
23:44:36 <applicative> > read "5" :: Int
23:44:36 <lambdabot>   5
23:44:47 <applicative> > read "alphabet soup" :: Int
23:44:48 <lambdabot>   *Exception: Prelude.read: no parse
23:45:42 <sanjoyd> http://hpaste.org/45521/iomonad
23:45:46 <sanjoyd> The code ^^
23:45:56 <sanjoyd> I'm trying to read two lines of text.
23:46:07 <shachaf> If you just want to get a String, use getLine.
23:46:12 <shachaf> @ty readLn
23:46:13 <lambdabot> forall a. (Read a) => IO a
23:46:18 <applicative> you want getLine
23:46:26 <applicative> like shachaf says
23:46:27 <sanjoyd> Why will readLn not work?
23:46:39 <sanjoyd> (I don't have any particular purpose, just trying to learn).
23:46:40 <applicative> it reads the string as a Bool or an Integer or an Int or whatever
23:46:43 <shachaf> readLn ~ read <$> getLine
23:46:47 <applicative> > read "True" :: Bool
23:46:48 <lambdabot>   True
23:47:06 <applicative> > read "False" :: Bool
23:47:07 <lambdabot>   False
23:47:16 <applicative> > read "The Times" :: Bool
23:47:17 <lambdabot>   *Exception: Prelude.read: no parse
23:47:19 <shachaf> > read "FileNotFound" :: Bool
23:47:20 <lambdabot>   *Exception: Prelude.read: no parse
23:47:58 <applicative> it isn't readLn so much as read that's tripping you up, I'd guess
23:48:01 <applicative> @type read
23:48:02 <lambdabot> forall a. (Read a) => String -> a
23:48:24 <applicative> sanjoyd: you just want the String, not the 'a' it might be interpreted as meaning
23:49:33 <sanjoyd> The type of readLn (from :t, in ghci) is (Read a) => IO a. From what I understand, assuming a is a type which is an instance of the typeclass 'Read', readLn will read a value of type 'a'. But how does it decide what 'a' is?
23:49:50 <applicative> it infers it, or if it can't you have to tell it
23:49:51 <sanjoyd> i.e. how does readLn _know_ whether I want it to read an Int or a String?
23:49:52 <adorablepuppy> ddarius: Hate to sound dumb, but what does turing complete mean for my program exactly?
23:49:56 <shachaf> sanjoyd: Based on how you use a.
23:49:58 <applicative> > read "3"
23:49:58 <lambdabot>   *Exception: Prelude.read: no parse
23:50:23 <shachaf> adorablepuppy: It means you can't detect automatically whether your program will halt in general.
23:50:24 <applicative> I guess its defaulting to trying to read it as ()?
23:50:29 <applicative> > read "()"
23:50:30 <lambdabot>   ()
23:50:32 <applicative> right
23:50:36 <sanjoyd> Okay. So, now since readLn is the last expression in a do block (in main::IO ()), it is trying to read a ()?
23:51:23 <sanjoyd> (Since it tries to match IO a to IO ())?
23:51:32 <applicative> the second line of the do block shows that x is going to be a String, since you're appending it to a String.
23:51:46 <applicative> the next readLn it would have to be clueless about.  
23:52:13 <applicative> wait, you have the signature there though
23:52:18 <adorablepuppy> shachaf: Does that mean I should make it a different way?
23:52:19 <shachaf> Note that "going to be a String" means it'll try to read it as a String, double quotes and all.
23:52:30 <sanjoyd> @ty >>
23:52:31 <lambdabot> parse error on input `>>'
23:52:47 <sanjoyd> How do I get ghci or lambdabot to output the type of >> ?
23:52:56 <shachaf> @ty (>>)
23:52:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:53:14 <shachaf> adorablepuppy: What you "should" do is up to you.
23:54:01 <adorablepuppy> shachaf: My thought would be to restrict the design of the programs from the user in such a way that they must construct a valid program.
23:54:48 <shachaf> If the language is Turing-complete, and a "valid" program is one which halts eventually, then you can't detect whether a program is valid.
