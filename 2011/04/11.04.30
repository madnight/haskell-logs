00:00:03 <Eduard_Munteanu> > map (/ 5) [1..10]
00:00:05 <lambdabot>   [0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0]
00:00:06 <danharaj> sections are immensely useful
00:00:08 <danharaj> enjoy them :)
00:00:14 <Eduard_Munteanu> > map (5 /) [1..10]
00:00:15 <lambdabot>   [5.0,2.5,1.6666666666666667,1.25,1.0,0.8333333333333334,0.7142857142857143,...
00:00:27 <shachaf> > (+x) 5
00:00:28 <lambdabot>   5 + x
00:00:30 <shachaf> > (x+) 5
00:00:31 <lambdabot>   x + 5
00:00:43 <ciphergoth> but + being commutative it doesn't demonstrate it so well...
00:00:44 <danharaj> pl must be cheating
00:01:03 <shachaf> @. run pl (+x) 5
00:01:04 <lambdabot>   x + 5
00:01:07 <Eduard_Munteanu> @pl (/5)
00:01:08 <lambdabot> (/ 5)
00:01:11 * shachaf catches @pl in its own lies.
00:01:26 <Eduard_Munteanu> @pl (5/)
00:01:26 <lambdabot> (5 /)
00:01:27 <ion> @pl filter (flip isPrefixOf [1,2,3,4])
00:01:27 <lambdabot> filter (flip isPrefixOf [1, 2, 3, 4])
00:01:28 <shachaf> It just assumes + is commutative because it's silly like that.
00:01:36 <ion> @pl filter (`isPrefixOf` [1,2,3,4])
00:01:36 <lambdabot> filter (`isPrefixOf` [1, 2, 3, 4])
00:01:39 <shachaf> It's not silly enough to do it for all infix operations.
00:01:41 <danharaj> :t 5
00:01:42 <lambdabot> forall t. (Num t) => t
00:01:46 <ciphergoth> so what I really want to do is write some unit tests for this: http://hackage.haskell.org/package/hecc
00:01:49 <danharaj> :t (+5)
00:01:50 <lambdabot> forall a. (Num a) => a -> a
00:01:55 <danharaj> :t (5+)
00:01:56 <lambdabot> forall t. (Num t) => t -> t
00:02:05 <ciphergoth> and that means writing a parser for this: http://point-at-infinity.org/ecc/nisttv
00:02:10 <danharaj> ooh is that your package?
00:02:13 <ciphergoth> no
00:02:15 <Eduard_Munteanu> :t (- 5)
00:02:16 <lambdabot> forall a. (Num a) => a
00:02:24 <ciphergoth> no that's written by someone who knows Haskell :-)
00:02:26 <Eduard_Munteanu> @pl (- 5)
00:02:26 <lambdabot> -5
00:02:34 <Eduard_Munteanu> Hrm.
00:02:54 <Eduard_Munteanu> > map (- 5) [1..10]
00:02:55 <lambdabot>   [-5,-5,-5,-5,-5,-5,-5,-5,-5,-5]
00:03:09 <shachaf> > map (subtract 5) [5..]
00:03:10 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:03:12 <ciphergoth> Eduard_Munteanu: I was just wondering how to slice - in that way
00:03:13 <danharaj> ciphergoth: it looks like a simple grammar, so you could do it by hand. But if you want to use a full on parser library, Parsec is great at making grammars.
00:03:14 <ciphergoth> aha
00:03:16 <shachaf> > map (-5+) [5..]
00:03:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:03:28 <ciphergoth> I looked at Parsec
00:03:36 <Eduard_Munteanu> :t (-)
00:03:36 <lambdabot> forall a. (Num a) => a -> a -> a
00:03:39 <ciphergoth> which would you do?
00:03:52 <shachaf> ciphergoth: You should write your own parser library.
00:03:57 <danharaj> ciphergoth: It depends on whether I'm enjoying the journey or have to get to my destination as fast as possible :p
00:04:00 <ciphergoth> that's what everyone else is doign :-)
00:04:14 <shachaf> _Programming in Haskell_ goes through something like that, if you have that book available.
00:04:24 <ciphergoth> not to hand, think it's on the desk at work
00:04:26 <ion> I for one would parse that with Parsec.
00:04:27 <danharaj> I tend to enjoy the journey, so I would use Parsec even if I didn't know it.
00:04:36 <danharaj> But I know how to use Parsec so it would be quicker for me to use it :p
00:04:57 <shachaf> danharaj: You enjoy the journey, so you'd use a premade library that does everything for you?
00:04:57 <ion> Learning Parsec is very fast.
00:05:04 <ciphergoth> I've read Learn you a Haskell and I've looked at Real World Haskell.  Programming in Haskell is on my desk at work
00:05:16 <ciphergoth> Yes, Parsec seems straightforward and neat
00:05:31 <danharaj> shachaf: Learning a library is enjoying the journey for me.
00:05:32 <kmc> Parsec is not totally straightforward
00:05:45 <ciphergoth> let me ask the question a different way: which one would you hope to find if you'd just downloaded hecc?
00:05:46 <kmc> for example, it doesn't backtrack by default the way other parser frameworks do
00:05:51 <ciphergoth> I want to contribute back my unit tets
00:05:56 <danharaj> ciphergoth: Parsec.
00:06:03 <ciphergoth> OK
00:06:03 <danharaj> It's a standard library.
00:06:07 <danharaj> well not standard
00:06:09 <danharaj> de facto standard :p
00:06:31 <ciphergoth> I think the trickiest part of parsing it with Parsec would be skipping the junk at the start
00:06:52 <danharaj> no, that would actually be quite easy.
00:07:25 <ion> Unless i’ve understood this incorrectly, Parsec implementes PEG which is semantically very close to regexps, just with separate parts that can recurse.
00:07:50 <ion> If you’re familiar with regexps, PEG parsing will feel very natural.
00:07:50 <danharaj> Why do you have to parse that file as is?
00:07:55 <danharaj> Why can't you remove the header?
00:08:22 <kmc> that sounds correct, but the net result is something a lot more powerful than regexes
00:08:33 <ciphergoth> well, because it's a test I don't like to mess with the file first
00:08:38 <ion> kmc: Indeed
00:08:50 <ciphergoth> I'm slightly happier saying "here is the EXACT test vector file I got from elsewhere" and working with that
00:08:59 <danharaj> ah fair enough
00:09:37 <ciphergoth> but I could easily chop off the  prefix by hand, just by searching for the first instance of "\n Curve" and starting there
00:09:49 <ciphergoth> and then hand that to Parsec
00:25:57 <ciphergoth> I can't find string searching in Data.List - looking for instances of "Eq"
00:29:50 <shachaf> ciphergoth: You should specify the type you're looking for.
00:29:58 <shachaf> "string searching" is a bit vague.
00:30:30 <ciphergoth> well the first thing that springs to mind is something like  Eq a => [a] -> [a] -> Maybe Int
00:30:57 <ciphergoth> stringSearch "foo" "barfoobaz" = Maybe 3
00:31:08 <ciphergoth> stringSearch "foo" "blimble" = Nothing
00:31:24 <ciphergoth> but perhaps that's not very natural; I'm new to this as I say!
00:31:49 <ion> http://hpaste.org/46180/skipping_the_text_header
00:31:50 <sipa> stringSearch [] _ = Just 0
00:32:25 <ciphergoth> err yeah, meant Just 3 above
00:32:28 <sipa> stringSearch (a:b) (c:d) | a==b = stringSearch b d >>= return . (+1)
00:32:29 <ciphergoth> ion: wow, thanks!
00:32:41 <sipa> stringSearch _ _ = Nothing
00:36:30 <ciphergoth> sipa: neat, that's in the Maybe monad?
00:36:55 <sipa> yes
00:37:00 <sipa> :t ap
00:37:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:37:22 <sipa> @pl stringSearch b d >>= return . (+1)
00:37:22 <lambdabot> (1 +) `fmap` stringSearch b d
00:37:34 <deteego> does anyone have any idea what the ambiguos type variable in the constraint means?
00:37:56 <sipa> deteego: it means there are several concrete types that match whatever you've written
00:38:20 <deteego> sipa: is this something that was recently implemented into GHC
00:38:20 <deteego> sipa: because I am copying an example
00:38:33 <sipa> paste your code somewhere?
00:39:19 <deteego> sipa: hmm wait a sec
00:39:36 <ciphergoth> hmm, I'm going to have to actually understand Applicative, aren't I?  I kind of skipped that bit in learnyouahaskell...
00:41:42 <deteego> sipa: I am basically trying to do whats here
00:41:46 <deteego> sipa: http://www.yesodweb.com/book/widgets
00:42:04 <deteego> sipa: and I think this is what you are talking about
00:42:07 <deteego> sipa: However, there is a more subtle point as well. While in theory a Hamlet template is polymorphic, this actually depends upon what values are embedded inside it (using ^{...} interpolation). For example, [$hamlet|^{someValue}|] will have the same type as someValue; if someValue is of type Hamlet, then so will the template
00:43:18 <sipa> ciphergoth: the idea is, you have something of type Maybe x, but want to perform a transformation on the inner x, while leaving it Nothing if it already was
00:44:10 <sipa> deteego: and where is the error?
00:44:29 <shachaf> sipa: That stringSearch doesn't really work, does it?
00:44:35 <ciphergoth> sipa: if you're talking about your code, you're using a Monad rather than an Applicative, and I paid attention in the Monads bit because I already knew they were essential
00:44:54 <deteego> sipa: well on the code on that site I gave earlier, it errors at addHtml [$hamlet|<p>I was added with addHtml|]
00:45:02 <shachaf> @ty let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==b = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch
00:45:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
00:45:04 <lambdabot>       Expected type: t
00:45:04 <lambdabot>       Inferred type: [t]
00:45:09 <shachaf> @ty let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==c = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch
00:45:10 <lambdabot> forall t a. (Eq t, Num a) => [t] -> [t] -> Maybe a
00:45:13 <sipa> shachaf: it should be a==c
00:45:16 <shachaf> > let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==c = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch "foo" "ffoo"
00:45:16 <sipa> yeah :)
00:45:20 <lambdabot>   mueval-core: Time limit exceeded
00:45:20 <deteego> sipa: the example code on that site doesn't actually work, but it says afterwards about using interpolation to set the type
00:45:23 <shachaf> > let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==c = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch "foo" "ffoo"
00:45:27 <lambdabot>   mueval-core: Time limit exceeded
00:45:33 <shachaf> > 1 + 1
00:45:34 <lambdabot>   2
00:45:41 <sipa> shachaf: hmm
00:45:42 <shachaf> > let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==c = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch "foo" "ffoo"
00:45:45 <lambdabot>   Nothing
00:46:06 <sipa> shachaf: bah of course
00:46:12 <sipa> it's harder than this
00:46:23 <ciphergoth> just because a==c doesn't mean you're at the start of the real match
00:46:27 <ciphergoth> yes
00:46:35 <ciphergoth> > let { stringSearch [] _ = Just 0; stringSearch (a:b) (c:d) | a==c = stringSearch b d >>= return . (+1); stringSearch _ _ = Nothing } in stringSearch "foo" "afoo"
00:46:37 <lambdabot>   Nothing
00:46:40 <ciphergoth> oh
00:46:43 <shachaf> ciphergoth: There's isInfixOf for naïve substring search.
00:46:54 <ciphergoth> but that returns a bool
00:46:59 <shachaf> ciphergoth: It won't give you the index, but remember that indices are evil.
00:47:07 <ciphergoth> well that seemed likely
00:47:45 <ciphergoth> now I'm trying to understand ion's code - think I'll know a lot more about Haskell when I've finished!
00:52:51 <siracusa> > let find x y = findIndex (== x) $ map (take $ length x) $ tails y in find "foo" "a food"
00:52:52 <lambdabot>   Just 2
00:56:15 <ciphergoth> So in Parsec, x *> y means "find an x, then a y, then throw away the value of x and give me the value of y"
00:56:38 <shachaf> Just like >>, yes.
00:57:12 <ciphergoth> but with applicative functors instead of monads. OK thanks.
00:57:41 <shachaf> Well, the Applicative functions, anyway. It's still a monad. :-)
00:59:45 <ciphergoth> this is definitely the hardest language I've ever tried to learn! I'd kind of hoped that studying some category theory first would help, but not much...
01:02:07 <Nereid> yeah, not really :P
01:02:37 <Nereid> I guess it's only "hard" because it's different
01:04:07 <shachaf> ciphergoth: Even harder than the first one?
01:05:40 <ciphergoth> shachaf: I don't remember going "man, this is HARD!" with the first one
01:05:51 <ciphergoth> shachaf: but then it was zx81 basic
01:06:11 <ciphergoth> sorry about the delay there, was having a bit of a disagreement with my pair programming partner
01:06:15 <shachaf> Haskell itself is hard in a "man, this is HARD!" way?
01:06:20 <ion> ciphergoth: I felt like practicing Parsec, so here’s the whole parser. http://hpaste.org/46181/nisttestvectors_parser
01:06:30 <shachaf> Maybe it's just the things you're trying to do with it. :-)
01:06:36 <ciphergoth> I really don't think pair programming should involve standing in front of the monitor, sitting on the keyboard, or biting my fingers
01:07:06 <ciphergoth> ion: that's fantastic, thanks!
01:07:34 <ciphergoth> ion: if I submit all this as a patch to hecc, how should I credit your work?
01:09:22 <ciphergoth> shachaf: I wanted to get into some "non-Haskell-shaped" problems quickly
01:10:14 <ion> I’m happy to either assign copyright to the author of Hecc or keep it myself (The same license as Hecc (BSD3), © 2011 Johan Kiviniemi), whichever the author of Hecc prefers.
01:11:05 <ciphergoth> am thinking credit rather than copyright but that answers both questions, thanks!
01:12:37 <ion> You’ll want to put the type CurveMap and data TestVector declarations to a separate file (Whatever.Types) and import it from both the parser and whatever code uses the parser. You’ll also want to import the parser qualified since “NistTestVectors.file” (or whatever you’ll name the module) is clearer than “file”. :-)
01:13:15 <ciphergoth> OK
01:13:41 <ciphergoth> I'll probably also want to convert the strings to integers
01:13:45 <ion> yeah
01:13:48 <ciphergoth> Integer is the bigint type, right?
01:14:02 <Nereid> yeah
01:15:12 <ion> Yeah. Change the type in TestVector and in the testVector function change ‘vector "k" digit’ to e.g. ‘(read <$> vector "k" digit)’
01:15:46 <ciphergoth> yep - am looking at the way you use M.fromList
01:15:48 <ciphergoth> which is similar
01:16:35 <ciphergoth> I love the way you can use partial application of TestVector to read the fields in order!
01:17:49 <ion> And ‘vector "x" hexDigit’ to ‘(readHex' <$> vector "x" hexDigit)’ and define readHex' = (\[(a,"")] -> a) . readHex (could be nicer, but it’s a starting point that works).
01:17:53 <ciphergoth> > read ("0x" + "fff")
01:17:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
01:17:53 <lambdabot>    arising from a use of `GH...
01:18:12 <ciphergoth> > read ("0x" ++ "ff")
01:18:14 <lambdabot>   *Exception: Prelude.read: no parse
01:18:31 <ion> > let readHex' = (\[(a,"")] -> a) . readHex in readHex' "ef01"
01:18:33 <lambdabot>   61185
01:18:36 <ion> > readHex "ef01"
01:18:37 <lambdabot>   [(61185,"")]
01:18:53 <ciphergoth> ah thanks!
01:19:05 <ion> > let readHex' = (\[(a,"")] -> a) . readHex in readHex' "erroneous string"
01:19:07 <lambdabot>   *Exception: <interactive>:3:16-29: Non-exhaustive patterns in lambda
01:19:35 <ciphergoth> that's fine :-)
01:19:37 <ion> readHex' doesn’t handle erroneous input well at all, but the vector "x" hexDigit parser will never return one.
01:19:49 <ciphergoth> point
01:19:49 <ion> s/return/result in/
01:22:21 <ion> One could actually move the conversion to the vector function. Keep testVector as is, but use: vector :: (Num n) => String -> Parser Char -> (String -> n) -> Parser String; vector name digitP conv = string (name ++ " = ") *> (conv <$> many1 digitP) <* many1 newline
01:23:25 <ion> Oh, and change the call in testVector to ‘vector "k" digit read’ and ‘vector "x" hexDigit readHex'’
01:23:27 <Mkman> Hey!
01:27:31 <ciphergoth> yep, I see that
01:27:58 <ion> Text.Parsec.Token has a nice parser for base-n numbers, but one can’t just use it directly.
01:28:09 <ciphergoth> might be more natural to put digitP and conv arguments first, then I could define vectorHex = vector hexDigit readHex'
01:28:37 <ciphergoth> or even vectorHex = vector hexDigit readHex and have vector handle the readHex issue
01:28:47 <ciphergoth> since there's a matching readDec
01:29:52 <ion> aye
01:37:45 <ciphergoth> hmm, I notice that in your code and throughout LYAHFGJ, you don't rely on type inference but explicitly type everything
01:39:25 <Axman6> type inference is nice, but replying on it is a bad habit. writing out type signatures is simple, compiler checked documentationm
01:39:28 <Axman6> -m
01:40:03 <ion> ciphergoth: A lot of the code does depend on type inference, but the explicit types are for documentation and verification.
02:02:38 <ion> ciphergoth: FWIW, i just verified that printing the parse result in the same format as the original results in the correct data. The diff: http://paste.ubuntu.com/601232/
02:03:01 <ciphergoth> ion: superb!
02:03:22 <ciphergoth> I got the integer parsing working
02:03:42 <ion> Nice
02:05:09 <boegel> hi peepz
02:05:29 <boegel> I have a question regarding an overlap function I implemented, see http://hpaste.org/46183/list_overlap
02:06:05 <boegel> I'd expect the overlapEasy to be slower than overlap, because it goes over the same list multiple times without reason
02:06:43 <boegel> I must add, overlap is used on very small lists (lets say a dozen elements each or smaller)
02:07:01 <xAndromeda> can anybody help me install leksah?  i tried the solution here http://code.google.com/p/leksah/issues/detail?id=215#c10
02:07:13 <boegel> but I don't see how that could make overlap slower... does calling myIntersect and constructing the triple add that much overhead?
02:12:27 <xAndromeda> O.o
02:18:26 <ClaudiusMaximus> boegel: have you tested for correctness as well as speed?  last two characters of line 17 look suspicious to me - should they be 'xs', not 'ys'?
02:20:31 <kosmikus> boegel: you're also not actually strict in the components of the pair in the foldl'
02:21:57 <scree> boegel: if your list is small, going over it multiple times is unlikely to be expensive.  Constructing / destructing boxed pairs as you iterate over the list once, is likely to be expensive
02:23:06 <scree> boegel: btw, ovlp `seq` 1.0 - ovlp is essentially redundant
02:25:55 <kosmikus> boegel: you could try to avoid pair construction by making the foldl' use a pair continuation
02:27:13 <Blkt> good day everyone
02:27:14 <scree> boegel: or you could make the foldl' function strict, e.g. (\(!l1, !l2) x -> ...) and rely on GHC to make it all unboxed and fast
02:27:41 <scree> boegel: or you could use / define a strict pair type
02:29:28 <scree> boegel: or you could explicitly use unboxed tuples; see http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/primitives.html
02:34:59 <boegel> ClaudiusMaximus: myIntersect is correct imho
02:35:14 <boegel> kosmikus/scree: thx for the comments
02:37:09 <kosmikus> boegel: you really think myIntersect is correct? it doesn't depend on xs at all ...
02:39:06 <jkff> Hi. There are strict and lazy state and RWS monads - they're strict/lazy in *what*? in the state or the result?
02:40:53 <jkff> oh, never mind
02:41:09 <jkff> the documentation for Control.Monad.Trans.State.* (transformers package) says it's in the state
02:41:47 <scree> @let myIntersect xs ys = lx `seq` ly `seq` li `seq` (lx, ly, li) where { ly = length ys; (lx,li) = foldl' (\(l,l') x -> (l+1, if any (==x) ys then l'+1 else l')) (0,0) ys }
02:41:48 <lambdabot>  <local>:5:0:
02:41:48 <lambdabot>      Warning: Pattern match(es) are overlapped
02:41:48 <lambdabot>               In...
02:41:53 <scree> > myIntersect [1, 2] [3, 4]
02:41:54 <lambdabot>   (2,2,2)
02:42:01 <scree> boegel: ^^^
02:42:46 <scree> @let myIntersect xs ys = lx `seq` ly `seq` li `seq` (lx, ly, li) where { ly = length ys; (lx,li) = foldl' (\(l,l') x -> (l+1, if any (==x) ys then l'+1 else l')) (0,0) xs }
02:42:46 <lambdabot>  <local>:5:0:
02:42:46 <lambdabot>      Warning: Pattern match(es) are overlapped
02:42:46 <lambdabot>               In...
02:42:50 <scree> > myIntersect [1, 2] [3, 4]
02:42:52 <lambdabot>   (2,2,2)
02:45:46 <ClaudiusMaximus> boegel: i did a rough benchmark, with 50k element lists (no common elements) as inputs i got 27 seconds for overlap (with suggested BangPatterns and xs fix) and 41 seconds for overlapEasy (compiled with -O2, then tested with ghci :set +s)
03:02:41 <HugoDaniel> hey oh
03:02:50 <ClaudiusMaximus> > intersect [1,1,1,2,2,3] [1,1,1,1,2,3,3,3]
03:02:50 <lambdabot>   [1,1,1,2,2,3]
03:03:28 <rostayob> is anybody using HJScript here?
03:04:23 <boegel> ClaudiusMaximus: my lists only have unique elements
03:04:32 <ion> Is HJFreaks its author?
03:05:06 <boegel> kosmikus, scree, ClaudiusMaximus: damned, you're right
03:05:23 <ClaudiusMaximus> boegel: ok, do you have Ord (maybe use Data.Set), or only Eq?
03:05:36 <rostayob> ion: no eheh
03:05:56 <boegel> ClaudiusMaximus: I have both Eq and Ord
03:09:37 <jkff> Has everyone heard that ICFPC 2011 dates have been announced? It's gonna be on Jun 17-20.
03:09:52 <jkff> Now this time our team's gonna rock for real!
03:10:16 <jkff> We have some geographic switches and now we'll have 2 crazy russians in Bay Area and 3 crazy russians in St.-Petersburg, instead of 1 : 4
03:11:24 <jkff> ...Working day and night, since the time lag is 12 hours
03:13:10 <boegel> jkff: hehe, nice
03:13:11 <ClaudiusMaximus> boegel: well, i think Data.Set should be a massive win for larger inputs...
03:13:24 <ClaudiusMaximus> boegel: ..not sure about small inputs
03:13:58 <boegel> ClaudiusMaximus: the lists with unique elements come from lists that do contain doubles
03:14:14 <boegel> ClaudiusMaximus: so, I basically just do "overlap (nub xs) (nub ys)"
03:14:45 <boegel> ClaudiusMaximus: would construct a Data.Set from a list (and using it in overlap) be cheaper than using nub?
03:15:01 <jkff> boegel: that surely highly depends on the size and pattern of your lists
03:15:17 <jkff> nub is basically O(num items * num distinct items)
03:15:31 <jkff> Set.fromList is O(num items * log num distinct items) :)
03:15:58 <jkff> hmm. ok, probably it does not depend on the *pattern*. you'll just have to benchmark it :)
03:16:22 <boegel> jkff: my lists are very small (up to one dozen elements)
03:16:36 <boegel> jkff: the ones with unique elements are say half as small
03:16:41 <jkff> boegel: then don't bother with Set, I'd expect it to win at several dozens or more
03:16:47 <jkff> but better benchmark :)
03:17:55 <boegel> jkff: well, construction might be more expensive, but intersect on sets is O(n+m) (now it's n*m), and size is O(1) (with lists, it's O(n))
03:18:01 <boegel> jkff: so, it might be a win
03:19:25 <jkff> boegel: traversing 6 distinct items of a list seems faster than rebalancing a 6-item set implemented as a tree, even if its height is say 2.
03:19:42 <Jafet> So use sorted lists with tagged sizes
03:20:14 <jkff> boegel: what's the original problem? maybe you'd be better with something like bitmasks :)
03:21:44 <jkff> boegel: btw, can't you sort the lists?
03:21:49 <jkff> oh, that's what Jafet said
03:22:13 <Jafet> nubSortedBy... oh that's just (map head.) . groupBy
03:22:32 * hackagebot timeplot 0.3.0 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.0 (EugeneKirpichov)
03:22:38 <ClaudiusMaximus> was just thinking about bitmask...  might get down to O(length a + length b)
03:23:18 <rostayob> so no one uses HJScript? is there a decent Javascript DSL that I'm not aware of?
03:26:01 <ion> One could just write JavaScript in JavaScript. ;-)
03:27:15 <rostayob> ion: really?
03:31:50 <shachaf> rostayob: One could indeed. Many do.
03:32:10 <boegel> jkff: I can sort my list, yes
03:32:27 <jkff> boegel: Then your intersection is also O(m+n)
03:32:37 <boegel> jkff: yeah, how did I miss that...
03:32:49 <boegel> Jafet, jkff: thx, I'll look into that
03:33:01 <jkff> boegel: And then you'd have a harder time finding a case where Set would be faster - one would speak about hundreds of elements, with large consecutive chunks of one set missing in the other.
03:33:16 <boegel> jkff: hhmmright
03:33:26 <rostayob> shachaf: i do as well, but i wanted to know if there's anything to write js in haskell
03:33:39 <rostayob> since for example I write my html in haskell
03:33:54 <rostayob> maybe i can go all the way ehe
03:34:35 * hackagebot haskell-src-meta 0.4 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.4 (BenMillwood)
03:37:34 <plottfox> hi, is it possible to have a class declaration in the form class (BaseA data, BaseB (data a) ) => Derived data where ... ? data is of kind * -> * -> * and I need that forall a . (data a)  is an instance of BaseB implies that data is an instance of Derived
03:37:51 <plottfox> I get the error that the type variable a is not in scope
03:39:31 <HugoDaniel> yesterday i uploaded my first hackage package :) im so proud
03:42:04 <Phyx->  HugoDaniel gj :)
03:42:09 <Phyx-> I have yet to upload one, :P
03:42:56 <HugoDaniel> mine is just some functions to open a opengl window in xorg
03:43:37 <Phyx-> it's still a package :)
03:48:11 <jkff> HugoDaniel: Show that you're a brave man who fears nothing, make it into a debian package!
03:48:23 <jkff> HugoDaniel: Turned out I'm not brave enough for that yet :(
03:51:48 <HugoDaniel> :D
03:52:03 <HugoDaniel> http://hackage.haskell.org/package/GLHUI  here :)
03:52:24 <HugoDaniel> my roomate helped me out with the libx11 c functions
03:52:48 <Phyx-> Only thing my roommate helps me out with is booze
03:53:01 <HugoDaniel> eheh
03:55:12 <illissius> plottfox: http://hackage.haskell.org/trac/ghc/ticket/2893
03:58:29 <jeffz> HugoDaniel: homepage is 404
03:59:56 <HugoDaniel> jeffz: yeah, im working on that :)
04:00:40 <HugoDaniel> maybe next month ill have it ready, right now i need to finish a photogallery to be ready by the time offf festival starts :/
04:00:57 <plottfox> illissius: thanks, that seems to be what I need. I guess I shouldn't be betting on it being implemented anytime soon eh?
04:01:05 <mrBratok> hi all
04:01:19 <Phyx-> hi
04:01:41 <illissius> plottfox: doesn't seem like it :\
04:02:02 <illissius> though there's some really interesting work going on in the typechecker (for presumably 7.2?), but I'm not sure if it has any relevance
04:03:29 <Phyx-> arg, are they going to break it again?
04:05:07 <illissius> plottfox: if you visit the link from the last-comment-that-has-a-link-in-it there's a way to achieve comparable functionality in an uglier way using GADTs (basically, store the evidence for forall a. BaseB (data a) in a GADT constructor, and unwrap it whenever you need to use it)
04:09:25 <illissius> Phyx-: first paper here http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/, pretty interesting read.
04:10:40 <Phyx-> illissius: is System FC something like TyCore?
04:10:42 <plottfox> illissius: ok, thanks, I'm currently reading that. I think it's too ugly for my needs, but maybe I'll use it anyway ;P
04:11:09 <plottfox> illissius: do you have any pointer to the typesystem work you mentioned?
04:12:28 <illissius> Phyx-: I'm not sure about TyCore, sounds like a GHC thing. GHC's Core is an implementation of System FC, which is a typed lambda calculus (System F + coercions). We may or may not be talking about the same thing.
04:12:33 <illissius> plottfox: see above link :)
04:12:46 <plottfox> k
04:15:03 <Phyx-> illissius: hehe, could be, I'll add that paper to my queue
04:15:31 * Phyx- is currently writing code to write PE files out
04:33:51 <b52> uh my copy of lyahfgg just arrived :)
04:34:02 <b52> too bad that ive read the whole thing online :D
04:46:57 <roconnor> hah. Irish times
04:47:30 <Kerris> that was unexpected
04:47:57 <obbele> hi! I'm searching the magic GHC/RTS option to run a binary program on multiple cores, what is it ? -RTS --help gives me nothing :(
04:48:29 <obbele> I think the new GHC v7.x require a tag to enable the full RTS
04:48:38 <ezyang> You need to compile with -threaded -rtsopts
04:49:01 <obbele> ezyang hum oki, I will try ...
04:49:35 <ezyang> omit -rtsopts if you're pre-GHC 7
04:51:34 <obbele> ... I've added -rtsopts to the cabal file, and still nothing
04:51:58 <obbele> the option for the binary is '-RTS --help', right ?
04:52:01 <ezyang> you also need -threaded.
04:52:08 <ezyang> obbele: it's +RTS
04:52:22 <ezyang> also, --r-N2 for two cores.
04:52:24 <obbele> yes I have -threaded
04:52:36 <ezyang> erm, -N2 (no --r)
04:52:44 <obbele> oh ! it works !
04:52:49 <ezyang> but -N should show up in the help prompt..
04:52:51 <obbele> it was +RTS, yes
04:53:07 <obbele> thanks ezyang
04:54:57 <obbele> ... if I'm getting "ghc: ioManagerDie" error, every thing is fine, isn't it ?
04:55:28 <obbele> (that's not related to the RTS, its because my code use the EventManager)
04:56:04 <ezyang> If the behavior changed, probably yes.
04:57:44 <obbele> on a different topic, does someones now if I can display raw yuy2 video stream with some haskell package ?
04:57:47 <obbele> gstreamer ?
04:58:00 <ezyang> check hackage...
05:43:47 <boegel> @tell jkff sorting the lists really helped, tool runs 1/3 faster now, thx!
05:43:47 <lambdabot> Consider it noted.
05:49:36 <Eduard_Munteanu> boegel: that doesn't sound right, 1/3 faster :P
05:50:20 <Eduard_Munteanu> Argh, you mean 33% faster.
05:50:25 <neural> heh ;-)
05:50:27 * Eduard_Munteanu is tired :)
05:50:52 <boegel> Eduard_Munteanu: I was using a n*m algorithm before, now I'm using a n+m algorithm :)
05:50:54 <neural> you also got me confused when skimming over your comment Eduard :-)
05:51:03 <boegel> Eduard_Munteanu: sorry about th confusing :)
05:51:16 <boegel> *confusion
05:51:30 * boegel thinks he needs a nap too, but his wife disagrees
05:52:02 <neural> wifes..
05:52:27 <boegel> yeah, who needs them
05:52:28 <boegel> well, I do
05:52:33 <boegel> to take care of the kid :)
05:53:11 <neural> I don't have a kid, so i'd literally wouldn't need one :-)
05:54:35 <boegel> neural: except for making babies
05:54:39 <boegel> neural: oh, wait
05:55:24 <Necrosporus> http://paste.org.ru/?8ce6w7 how would you improve the code?
05:55:46 <Zao> Needs more descriptive names, and comments :D
05:56:02 <Zao> Also, that doesn't look like Haskell.
05:56:52 <neural> blegh. working on saturday.
05:57:48 <Jafet> We have descriptive names?
05:59:17 <neural> Jafet: something that makes it look like it was not typed by kid at random :P
05:59:35 <Eduard_Munteanu> In fact the names are a bit too descriptive.
06:07:32 <ezyang> I think it would be kind of cute if GHC emitted debug files with source level information corresponding to C--. Dunno how useful though.
06:21:50 <johnny123> hi can someone help me with 3d rotation on 8x3 matrix cube in matlab?
06:24:27 <hpc> johnny123: isn't that just multiplying by a 3x3 matrix with the transformation you want?
06:24:35 <hpc> (4x4 if you don't want gimbal lock)
06:29:39 <johnny123> at the moment i got this code M = repmat(MV,8,1)+ (handles.SHOULDER_V- repmat(MV,8,1))* [cos(pi/6) -sin(pi/6) 0; sin(pi/6) cos(pi/6) 0; 0 0 1];
06:29:52 <johnny123> which dont rotate properly
06:30:00 <johnny123> on 3d axes
06:30:11 <johnny123> MV=mean(handles.SHOULDER_V);
06:30:47 <johnny123> handles.SHOULDER_V is 8x3 vertex 6x4 faces cube
06:30:54 <roconnor> hpc: and quaternions if you don't want insanity :)
06:31:11 <hpc> :)
06:31:11 <roconnor> hpc: unless by 4x4 you mean the same as quaternions
06:31:55 <hpc> roconnor: http://en.wikipedia.org/wiki/Gimbal_lock#Gimbal_lock_in_applied_mathematics
06:33:08 <hpc> wait, that's not what i was thinking of
06:34:57 <hpc> http://knol.google.com/k/matrices-for-3d-applications-translation-rotation <- this might be it
06:35:39 <hpc> you use a matrix that's larger than the dimension of the space you are moving through, and the math miraculously works ot
06:36:25 <johnny123> hpc r u talking to me
06:36:26 <johnny123> ?
06:36:36 <hpc> nah, just rambling
06:37:04 <Jafet> Crouching matrix hidden subgroup
06:37:10 <johnny123> man can u write me an example code
06:37:30 <hpc> i wish
06:37:48 <hpc> i already use matlab/octave way more than i would like, and i am not very good at linear algebra
06:38:03 <johnny123> same here
06:38:25 <johnny123> do i have to convert this matrix in 4 something?
06:38:33 <johnny123> 4 columns?
06:38:37 <Jafet> Matlab is stuffy. Let's talk about C++ instead.
06:38:44 <pmurias> how is the ide toolkit with integration for vim with haskell called?
06:41:14 <crystal-cola> Is anyone studying homotopy type theory?
06:46:54 <aristid> i heard there's a blog about it :P
06:49:33 <crystal-cola> aristid: the problem is that I cannot understand that blog
06:49:39 <deech> Hi all, I have about 10-15 utility functions that I thinkg would be useful to the community. Would it be better to release them all in the same package or break it up as much as possible.
06:49:55 <aristid> crystal-cola: :)
06:49:57 <hpc> deech: they might already exist on hackage
06:50:22 <hpc> deech: there are several "utility packages" that do what you describe
06:51:00 <deech> hpc: They might, I checked for their signatures on Hayoo before making my own. Beyond that I don't know how to ensure that I'm not reinventing the wheel.
06:51:41 <hpc> deech: http://hackage.haskell.org/packages/archive/pkg-list.html
06:51:54 <hpc> deech: imo, a cursory run through the package descriptions should be enough
06:52:41 <FUZxxl> Is John Meachem here?
06:52:45 <geheimdienst> deech, maybe you should put them on hpaste, just so people here can get a quick look at them for feedback?
06:52:48 <geheimdienst> @where hpaste
06:52:48 <lambdabot> http://hpaste.org/
06:53:29 <hpc> hehe, Acme.Dont and Acme.Now are the best things ever
06:53:30 <boegel> are there any major differences between Haskell with GHC 6.12 on Linux and OS X?
06:53:55 <hpc> dont takes a monadic action, and instead of running it, it returns ()
06:54:03 <hpc> now = unsafePerformIO getCurrentTime
06:54:14 <boegel> because my MacBook Pro laptop (2.4GHz Core 2, 4G RAM) is like 10% faster than my work laptop (Linux, 2.4GHz Core i5, 8G RAM)
06:54:16 <boegel> wth?!?
06:54:30 <hpc> boegel: faster ram?
06:54:44 <boegel> hpc: I doubt it
06:54:54 <geheimdienst> is your code io-bound, cpu-bound, ...?
06:55:32 <deech> geheimdienst: Ok, I threw up an example (http://hpaste.org/46185/multiplicity). It's a simple thing I've used many times when querying databases and making sure only a single result is returned.
06:56:14 <boegel> geheimdienst: very much CPU bound
06:57:02 <boegel> geheimdienst: does very little IO (reads about 50M at the start, but doesn't print or read/write after that)
07:00:18 <geheimdienst> boegel, i think you're on to something interesting. i bet -cafe would like to hear about it as well
07:00:43 <boegel> geheimdienst: I'll try and figure out the memspeed of my Linux laptop first
07:00:57 <scree> deech: I can't see the point of that
07:01:01 <boegel> geheimdienst: but since my Mac is 1067Mhz DDR3, I doublt it'll be inferior
07:01:04 <aristid> boegel: is it 64-bit linux?
07:01:11 <boegel> aristid: yes
07:01:14 <boegel> aristid: oh, good point
07:01:26 <scree> deech: why is it easier to pattern-match against Single / Empty / Multiple rather than [] / [x] -> _ ?
07:01:31 <aristid> boegel: if it's memory intensive, then the 64-bits might hurt
07:01:51 <boegel> aristid: isn't OS X 64-bit too?
07:02:05 <boegel> aristid: it does produce a lot of junk in between things
07:02:12 <aristid> boegel: OS X is mixed. i think GHC 6.12 used to be installed as 32
07:02:28 <boegel> aristid: also, that makes perfect sense, because -s is reporting way more GC activity on Linux than it is on OS X
07:02:53 <boegel> aristid: my Haskell tool is definitely 32-bit on OS X
07:03:03 <deech> scree: I find that the multiplicity (proabably a bad name) makes code easier to write. It's analogous to the 'maybe' and 'either'.
07:03:04 <aristid> great that i could help. time for tea
07:03:39 <boegel> geheimdienst: see comments by aristid, it's a 64-bit vs 32-bit thing
07:03:48 <lars9> @hoogle anyKey
07:03:48 <lambdabot> No results found
07:03:51 <scree> deech: so, I agree your "multiplicity" function is potentially useful.  What I dislike is your "Multiple" datatype
07:03:55 <boegel> does GHC 64-bit support spitting out 32-bit binaries?
07:03:58 <lars9> @hoogle openDisplay
07:03:58 <lambdabot> No results found
07:04:04 <boegel> would be interesting to see whether that speeds up things
07:04:09 <scree> deech: e.g. what does "Single []" mean?
07:04:09 <ezyang> boegel: Sorry, we don't have cross-compilation yet.
07:04:20 <boegel> ezyang: k, np
07:04:31 <scree> deech: more so, what does "Multiple 5" mean?
07:04:36 <ezyang> Mark Lentczner is working on it (mtnviewmark)
07:04:45 <boegel> does anyone have any insight into how GHC 7 compares to GHC 6.12 in terms of code quality it produces?
07:04:48 <deech> scree: Ooh, it should be "Multiple [a]" shouldn't it.
07:05:07 <scree> deech: well, then you'd have to change your type signatures
07:05:24 <scree> deech: and you still have the problem that "Multiple []" or "Multiple [1]" are meaningless
07:05:55 <deech> scree: That's true.
07:06:32 * geheimdienst agrees that the function is pretty useful, but that the datatype is a little strange
07:06:35 <Apocalisp> data T f a = T a (T f (f a))
07:06:40 <Apocalisp> What is this structure called?
07:07:07 <Apocalisp> oops
07:07:20 <deech> scree: I'm not sure how to create a datatype to model a list that is that has at least one element.
07:07:35 <Apocalisp> data T f a = T a (f (T f (f a)))
07:07:42 <roconnor> Damn it, all the museums are closed on May 1 even though it is free museum day in Paris :(
07:07:43 <scree> @hoogle nonempty
07:07:43 <lambdabot> No results found
07:08:01 <deech> scree: maybe something like "Multiple a [a]" ?
07:08:36 <scree> deech: that would work
07:08:38 <deech> scree: I meant maybe something like "Multiple a a [a]" ? It should have at least two elements.
07:10:04 <boegel> is it possible to run GHC 7 alongside Haskell Platform 2010.x on OS X?
07:10:13 <scree> deech: so, if you want a type that's genuinely a non-empty list, you can have "data NonEmpty a = Single a | Cons a (NonEmpty a)"
07:11:44 <scree> deech: or you can do fancy stuff with GADT's, e.g. http://www.haskell.org/haskellwiki/GADT#Example_with_lists
07:11:56 <deech> scree: But then there is no termination case. If I wanted to model [1,2,3] I would be doing Cons 1 (Cons 2 (Cons 3 (?)))
07:12:23 <scree> deech: [1, 2, 3] is Cons 1 (Cons 2 (Single 3))
07:12:42 <Jafet> Er, no.
07:12:49 <Jafet> @src []
07:12:49 <lambdabot> data [] a = [] | a : [a]
07:13:10 <scree> Jafet: is that for me?
07:13:18 <Jafet> Er, yes.
07:13:21 <deech> scree: I see. Looks good!
07:13:30 <geheimdienst> deech: what is your datatype typically used for? i think that would give some insight on how it should be designed ...
07:13:50 <scree> Jafet: talking about the "non-empty" data type above, not standard lists.  I agree "is" was misleading
07:15:16 <Jafet> Oh, I missed that part
07:15:27 <deech> geheimdienst: so far to ensure that results returned from a database are either single, multiple or nothing. Eg. When I pull query a database for a some username's real name, I should only every get one result.
07:15:41 <scree> deech: but, if all you want is you handy utility function -- the equivalent of "maybe" -- I'd suggest you don't use a new datatype at all
07:16:15 <scree> deech: e.g. the version I've annotated to your paste
07:17:27 <deech> scree: Hmmm...I'll have to check my code to see if I really need the datatype.
07:17:33 <geheimdienst> deech: yes i see. but how would you use that, you'd make a function like this? "doSomethingWithUsername (Single a) = ... ; doSomethingWithUsername (Multiple a) = error"
07:18:34 <deech> geheimdienst: yup, but I use 'multiplicity throwError doSomething throwError".
07:18:49 <Jafet> do [username] <- return usernames;
07:19:03 <FUZxxl> Is anyone here familiar with JHC?
07:19:28 <deech> Jafet: How do I catch that error in a proper way?
07:20:00 <geheimdienst> deech: ok cool. my opinion is that i like "multiplicity throwError doSomething throwError" much more than "f (Single a) = ... ; f (Multiple a) = throwError" :)
07:20:03 <Jafet> Butterfly nets?
07:20:34 <Jafet> What that do-notation does is give you a free monad for handling failures
07:21:11 <deech> geheimdienst: Cool :)
07:21:12 <Jafet> If you literally want to use error and stuff, you're looking at Control.Exception
07:21:32 <scree> deech: agree with geheimdienst.  Non-empty lists are mainly useful when you have a runtime guarantee that your lists won't be emtpy, and want the type system to know
07:21:36 <scree> deech: that's not what you have here
07:22:05 <deech> scree: Agreed, the datatype is bad.
07:22:45 <scree> deech: and just fyi, "length as == 1" in your code is something you shouldn't really do
07:23:05 <scree> deech: after all, what if your database returns infinitely many results? :P
07:23:30 <deech> scree: Yes I really should be doing [x] shouldn't I. I wrote this a few years when i was just learning Haskell.
07:23:59 <scree> deech: ah ok that makes sense :).  In that case I'll stop criticizing your code
07:24:30 <deech> scree: No it was useful since I was considering releasing it!
07:39:21 <njs12345> is there a function in the standard library which looks like
07:39:28 <njs12345> State s a -> StateT s m a
07:40:17 <deech> lift (http://hackage.haskell.org/packages/archive/monadLib/latest/doc/html/MonadLib.html#v:lift)
07:40:35 <Phyx-> @hoogle State s a -> StateT s m a
07:40:35 <lambdabot> No results found
07:40:39 <jmcarthur> monadLib isn't the standard library though
07:40:46 <jmcarthur> (neither is mtl though)
07:40:57 <Phyx-> :t lift
07:40:58 <lambdabot>     Ambiguous occurrence `lift'
07:40:58 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
07:40:58 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
07:41:04 <Phyx-> o.O
07:41:18 <deech> What about transformers?
07:41:27 <jmcarthur> nah
07:41:37 <jmcarthur> by "standard library" i mean "base"
07:41:41 <siracusa> @ty Control.Monad.Trans.lift
07:41:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
07:41:45 <jmcarthur> i'm pretty sure transformers+mtl are in the platform
07:42:21 <Phyx-> mtl also comes with the standalone ghc doesn't it
07:42:21 <FUZxxl> jmcarthur: They are.
07:43:18 <deech> njs12345: For that matter I don't think StateT is in base. So it makes sense that  "lift" isn't either.
07:44:11 <njs12345> ah, ok, I don't really mean base
07:44:21 <njs12345> i guess stuff that comes with GHC is fine, or even outside libraries
07:45:04 <njs12345> lift doesn't seem to work
07:45:09 <deech> njs12345: Then the (Hackage) world is your oyster.
07:45:20 <njs12345> perhaps if I explain my situation?
07:45:30 <njs12345> i have a function which manipulates state but doesn't do any IO
07:45:44 <navaati> hi
07:45:47 <njs12345> and i want to lift that into a StateT with IO but manipulating the same state
07:46:31 <deech> njs12345: So why can't you just start off with a StateT x IO?
07:46:35 <navaati> does somebody have the problem with leksah where pressing the space bar doesn't produce a space ? (and how to fix this ?)
07:46:53 <njs12345> that works
07:47:03 <njs12345> but isn't it considered kind of poor style to have functions in IO which don't need to be?
07:47:29 <dmwit> njs12345: You have two choices: either rewrite the thing to be polymorphic over all MonadState instances, or retrieve the state and run the monad by hand inside your StateT mote.
07:47:31 <navaati> if you need StateT s IO, then you need IO
07:47:40 <deech> njs12345: Oh I see. You want to guarantee that one part of your state manipulation is pure and this other part isn't.
07:47:55 <njs12345> yup, so the inner function manipulates state but is pure in terms of IO
07:48:28 <dmwit> njs12345: Polymorphic stateful things are also provably IO-free. =)
07:48:33 <dmwit> So I recommend that approach.
07:49:38 <navaati> you can create a pure function using State and runState at the end (well, begining) of this function so that you do stateful computations in your function, but it's stateless from the outside, if it's what you want
07:49:44 <njs12345> dmwit: OK, I'll look into that, thanks :)
07:49:53 <njs12345> I tried writing something like this:
07:51:02 <njs12345> http://hpaste.org/46188/futile_attempt
07:51:32 <dmwit> njs12345: You can do this:
07:51:39 <dmwit> let (a, st') = runState f st
07:52:06 <dmwit> njs12345: But again, I'd recommend simply rewriting f to use only MonadState functions; then you just write
07:52:09 <dmwit> liftS f = f
07:52:09 <dmwit> =)
07:52:23 <Mathnerd314> is there a set of arrow operations equivalent to Applicative, like there is for Monad?
07:52:44 <dmwit> Mathnerd314: There was some discussion of this on reddit just a few days ago, hold on.
07:53:07 <navaati> Applicative are arrows oO ?
07:53:26 <njs12345> ah, I see, thanks dmwit, it works
07:55:21 <dmwit> here we go
07:55:47 <dmwit> http://www.reddit.com/r/haskell/comments/gv7fm/review_learn_you_a_haskell_for_great_good/c1qvuxl?context=5
07:56:01 <dmwit> Mathnerd314: You mean like that?
07:56:59 <ezyang> Has there been any research on persistent structures that turn ephemeral if there were no other references to the old structure?
07:57:06 <ezyang> i.e. "don't pay for persistence if you don't need it"
07:58:46 <deech> njs12345: I have sample code for your problem (http://hpaste.org/46189/state2statet)
07:59:37 <dmwit> ezyang: Wow! What a concept. I haven't heard of any.
08:00:00 <njs12345> thanks :)
08:00:08 <njs12345> in the end, I took my function from
08:00:19 <njs12345> State [Event] (Maybe Event)
08:00:19 <njs12345> to
08:00:31 <njs12345> (Monad m) => StateT [Event] m (Maybe Event)
08:00:34 <njs12345> which worked nicely :)
08:00:38 <dmwit> njs12345, deech: But, but, but... for that, you can just do "evalStateT (pureState >> impureState) 1"!
08:01:12 <deech> dmwit: TIL
08:01:14 <dmwit> That was the *whole point* of the MonadState class.
08:02:15 <ezyang> It's something that probably researchers of databases and other snapshot versioned systems would think about.
08:02:27 <ezyang> I'm kind of wondering if anyone's approached it from the opposite direction.
08:02:40 <lars9> @hoogle repeatM
08:02:40 <lambdabot> No results found
08:02:49 <ezyang> For example, is it actually true that conventional uses of persistent data structures are heavily shared?
08:02:56 <lars9> @hoogle repeatM_
08:02:56 <lambdabot> No results found
08:04:05 <ezyang> I can imagine usage patterns where a lot of garbage is repeatedly generated.
08:04:16 <Mathnerd314> dmwit: yeah, like that
08:11:49 <ezyang> Maybe I should ask about it on haskell-cafe.
08:12:52 <dmwit> I'm having trouble even imagining how a data structure would know when there were no references left.
08:13:19 <ezyang> It's a notable difficulty.
08:13:33 <ezyang> In particular, note that GC'd heap + persistent data structures = ephemeral data structures.
08:13:48 <ezyang> so any such system would probably require collaboration from the GC.
08:13:50 <geheimdienst> some languages have weak references ...
08:14:06 <geheimdienst> dunno how that fits in your picture though :)
08:15:26 <ezyang> Another really interesting thing to note is that while some data structures (e.g. lists) allow their internal structure to be arbitrarily touched, most advanced data structures don't export their constructors.
08:15:30 <ezyang> Which simplifies the problem a bit.
08:15:42 <ezyang> geheimdienst: More GC complication! :-)
08:15:58 <ezyang> In other news, the Beatles are awesome.
08:16:41 <morricone> hi, I tried optimising my algorithm using memoization, but it keeps using a lot of memory (http://hpaste.org/46192/memoization )
08:16:51 <ezyang> Memoization will make memory usage worse.
08:17:04 <morricone> it shouldn't use that much memory
08:17:14 <dolio> Memoization trades memory for time efficiency.
08:17:26 <mauke> that doesn't look very memoized
08:17:31 <ezyang> What is the algorithm supposed to do?
08:17:37 <morricone> solve http://www.codechef.com/problems/COINS/
08:17:56 <morricone> trying to learn haskell using a few problems
08:18:04 <lars9> @hoogle whenJust
08:18:05 <lambdabot> No results found
08:18:10 <ezyang> You've not managed to memoize it.
08:18:17 <morricone> http://www.haskell.org/haskellwiki/Memoization suggests this technique
08:18:17 <ezyang> Because map coin [0..] is not assigned to a variable.
08:18:21 <ezyang> so no sharing goes on.
08:18:42 <mauke> ezyang: really?
08:18:42 <ezyang> you can fix this by moving !! outside of memoizedCoin.
08:18:51 <ezyang> Well, unless it gets cse'd or something.
08:18:58 <ezyang> Let me bust out the core...
08:19:01 <mauke> I would have thought it's permanently bound inside of !!
08:19:09 <Phyx-> I assume cereal stores Bools as a single bit?
08:19:14 <mauke> http://www.spoj.pl/problems/COINS/
08:19:20 <copumpkin> Phyx-: how would that work?
08:19:59 <ezyang> oh yes, I suppose it would be memoized.
08:20:14 <ezyang> the real problem is process destroys the memoization.
08:20:31 <ezyang> oh, that's not true either ^_^"
08:20:55 <dolio> It's memoized.
08:20:57 <Phyx-> copumpkin: well, i'm not really sure, I'm wondering how i'm supposed to write out '2' bits
08:21:13 <geheimdienst> ezyang: i don't know how much complication weak references are in practice ... istr recall reading a blog post how java does it. basically, when it would throw an out of memory exception, it has one additional step called heroics, which kills all the weak references and re-runs GC
08:21:13 <copumpkin> Phyx-: it probably stores each one as a byte at least :)
08:21:21 <dolio> But the algorithm isn't recursively taking advantage of the memoization.
08:21:34 <morricone> how can I fix that dolio?
08:21:59 <Phyx-> copumpkin: no, i got it now, i looked at the rest of  the types, there are 16bits being written out, so just 2 bytes, the specs probably mean the first 2 bits should be used for the type
08:22:17 <copumpkin> for the type? :O
08:22:46 <dolio> morricone: You need to inter-define your list and cone, and make the recursive calls in cone actually reference the list.
08:22:48 <Phyx-> yes, there are only 3 possibility for the import type
08:23:14 <morricone> I will try that
08:23:18 * Phyx- slaps himself for asking a stupid question earlier
08:23:21 <ezyang> but you're going to pay a bit computationally speaking, since you're using a list...
08:23:45 <dolio> morricone: So, like, 'let mcone = (map cone [0..] !!) ; cone x = ... mcone n1 ...'
08:24:00 <dolio> Also, yeah, lists aren't going to be very memory friendly here.
08:24:21 <dolio> Or time friendly, since indexing is O(n).
08:24:36 <mauke> lazy array!
08:24:36 <morricone> yes, but it looked like the simplest solution on the wiki
08:24:43 <geheimdienst> ezyang: i think that was the java GC post :) http://blogs.sun.com/jonthecollector/entry/size_matters seemed kinda straightforward if you ask me
08:25:18 <Phyx-> thanks for slapping some sense into me copumpkin, lol.
08:25:30 <dolio> Yeah, it's simplest.
08:25:44 <dolio> Arrays would require you to know your upper bound.
08:26:16 <dolio> To do better you want some structure that can be infinite while providing log(n) access.
08:26:24 <mauke> you know your upper bound
08:26:54 <dolio> Like a trie, or a lazy list of arrays that increase in size by factors of 2, or ....
08:27:57 <mauke> dolio: http://codepad.org/TkzbDaDN
08:28:03 <dolio> I suppose in this case the upper bound is known.
08:28:07 <dolio> maxBound :: Int
08:28:15 <dolio> If the list memoization is right.
08:29:13 <lars9> how to call io (such as the print function) inside a ReaderT a (StateT b IO) () ?
08:29:22 <mauke> liftIO
08:29:24 <monochrom> liftIO (print x)
08:29:43 <lars9> how about only inside of ReaderT ?
08:29:50 <monochrom> same
08:29:52 * scree wonders how many operations it takes to determine min { n : 2^n >= k } for k < 2^32
08:30:12 <lars9> how about many layers of transformers?
08:30:22 <mauke> liftIO
08:30:25 <monochrom> same
08:30:46 <monochrom> you will fathom how it pulls it off
08:30:52 <lars9> oh, why liftIO can penetrate them all?
08:31:12 <lars9> @type liftIO
08:31:13 <lambdabot>     Ambiguous occurrence `liftIO'
08:31:13 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
08:31:13 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
08:31:30 <lars9> :i liftIO
08:31:56 <monochrom> lambdabot really imports too much
08:32:09 <lars9> @hoogle liftIO
08:32:09 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
08:32:33 <lars9> so liftIO $ print x can just make print x to any monad needed?
08:33:05 <scree> lars9: as long as that monad instantiates MonadIO
08:33:37 <scree> @instances MonadIO
08:33:38 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
08:33:55 <lars9> scree thanks
08:34:40 <monochrom> you should look at a line of code that lambdabot never shows
08:34:42 <Mathnerd314> dmwit: seems like http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf is closer to what I was looking for
08:35:08 <monochrom> that is, "instance MonadIO m => MonadIO (ReaderT blah m) where ..."
08:35:22 <lars9> monochrom: just found that doc...
08:35:54 <lars9> i didnt notice liftIO is MonadIO's method
08:44:37 <Mathnerd314> scree: two; floor . log_2
08:45:07 <Mathnerd314> s/floor/ceiling/
08:46:33 <parcs> > print $ fix (sum . take 2 . reverse . (1:) .: inits)
08:46:34 <lambdabot>   No instance for (GHC.Num.Num [t])
08:46:34 <lambdabot>    arising from a use of `Data.List.sum' ...
08:56:23 * hackagebot explicit-exception 0.1.6 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.6 (HenningThielemann)
09:07:24 * hackagebot iteratee 0.8.2.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.2.0 (JohnLato)
09:17:26 * hackagebot storablevector 0.2.7.2 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.7.2 (HenningThielemann)
09:29:59 <funktronic> i'm trying to decide on haskell vs ocaml vs potentially f# on mono. it seems like haskell has pretty decent support for linking c++ libraries. how mature is this? is there any performance impact? what is the effort involved ?
09:31:26 <Lemmih> funktronic: Calling C from Haskell is quite fast. Calling Haskell from C is somewhat slow.
09:32:19 <funktronic> Lemmih: do you know of any page that outlines the costs ?
09:32:56 <Lemmih> funktronic: Nope.
09:34:11 <Phyx-> Lemmih: what makes the inverse so slow?
09:34:35 <danharaj> Phyx-: You have to enter the Haskell runtime.
09:35:29 <mauke> funktronic: nothing has decent support for linking c++
09:35:32 <mauke> including c++
09:35:35 <kmc> including C++
09:35:39 <kmc> ;P
09:36:00 <Phyx-> danharaj: but if you're calling C don't you have to exit the runtime aswell? shouldn't those be equal? the RTS is only started once
09:36:06 <funktronic> i really wish there was a more reasonable lingua franca than C/C++
09:36:21 <mauke> C/C++ isn't a lingua franca
09:36:22 <kmc> i would not call C++ lingua franca, or lump it in with C that way
09:36:30 <mauke> I have the only existing C/C++ implementation
09:36:43 <kmc> very few people learn C++ in its full glory
09:36:44 <funktronic> kmc: the amount of C++ libraries far outnumbers others, save for maybe java
09:36:53 <danharaj> Phyx-: What does it mean to exit the runtime? You don't have to do anything special to prepare the arguments for the C function except handle calls for the heap and marshall your haskell arguments to C-land.
09:37:12 <kmc> there is no standard C++ ABI, so even two C++ compilers on the same platform can produce code which won't link
09:37:18 <mauke> hello and welcome to CPAN
09:37:26 <Phyx-> danharaj: but the inverse is also true, you just marshall your data and it's done
09:37:56 <kmc> funktronic, anyway, you asked about maturity, performance impact, and effort
09:38:07 <kmc> ignoring C++ for a moment
09:38:18 <kmc> Haskell's FFI is very mature
09:38:28 <kmc> it's been a part of most Haskell implementations for a long time
09:38:49 <kmc> and is part of the language standard now
09:39:10 <kmc> performance is quite good with GHC; fundamentally you have native-compiled code calling other native-compiled code
09:39:34 <danharaj> Phyx-: http://stackoverflow.com/questions/5665209/performance-considerations-of-haskell-ffi-c
09:39:54 <kmc> effort depends on two things: the library you're trying to wrap, and the degree to which you want to make its API feel like a Haskell API rather than a C API
09:40:14 <kmc> if you have some C lib which isn't threadsafe and has pointers and unsafe memory ops and mutation everywhere
09:40:23 <kmc> it will be easy to use it in Haskell in a way that isn't threadsafe and has pointers and unsafe memory ops and mutation everywhere
09:40:23 <funktronic> danharaj: that's pretty much covers everything, thanks
09:40:50 <danharaj> funktronic: the tl;dr; is, calling C from Haskell is easy and fast. Calling Haskell from C is iffy.
09:41:05 <kmc> and harder to bring it up to the standards Haskell programmers expect -- threading Just Works, automatic memory management, no segfaults, no unnecessary mutation
09:41:13 <funktronic> sounds like i'll just have to write a sample program and measure it and decide if it's a problem or not
09:43:11 <funktronic> i suppose i could always use the java library and do scala but scala doesn't look anywhere near as nice as haskell
09:43:43 <danharaj> So there isn't a specific C library you want to use?
09:44:06 <funktronic> danharaj: yes, they provide either C++ or java
09:44:11 <danharaj> ah fair enough.
09:44:32 <pmurias> funktronic: what is the library??
09:44:44 <danharaj> If you use Haskell you are going to have to do more work to bind the C++ library. Because C++ is stupid.
09:44:51 <luite> @hoogle (a -> IO (Maybe b)) -> (b -> IO (Maybe c)) -> a -> IO (Maybe c)
09:44:52 <lambdabot> No results found
09:44:53 <funktronic> pmurias: http://www.interactivebrokers.com/en/p.php?f=programInterface
09:46:33 <kmc> and if performance is a serious concern, Java + Scala will do worse than C + Haskell, assuming typical implementations
09:46:42 <kmc> and assuming the libraries are otherwise comparable
09:47:56 <funktronic> i'll try it out with c++ and haskell... not sure how much perf i'll need. plus looking at the scala examples i really don't like the syntax
09:47:56 <jmcarthur> what are some possible reasons that newtype wrappers might be slower than their unwrapped counterparts?
09:48:30 <hpc> kmc: using a specialized server JVM, java/scala could be faster
09:48:31 <jmcarthur> in this particular case, i'm also using it with unboxed vectors, which might be relevant
09:48:39 <hpc> probably would be, in fact
09:49:53 <funktronic> there's also nothing that stops me from mixing and matching... i could probably write a simple server in C++ that handles messages and decides what's important enough to act on and then passes it onto a different server that has all the business logic in haskell
09:50:36 <hpc> or not even use separate servers, but unix pipes
09:51:02 <gio123> hpc: hi
09:51:07 <kmc> Thrift might be a good choice for that IPC
09:52:12 <xenyl> what's a good editor / ide for haskell ?
09:52:20 <dolio> Vim or emacs.
09:52:23 <kmc> use whatever editor you're comfortable with
09:52:32 <funktronic> vim is the best for everything :)
09:52:34 <xenyl> i use emacs tbh, but i was looking for something better
09:52:56 <xenyl> better in the sense of: more haskellian
09:53:08 <dolio> I don't think you'll find anything with more Haskell editing functionality than emacs.
09:53:09 <kmc> what does that mean
09:53:18 <danharaj> Is Yi still in development?
09:53:25 <funktronic> xenyl: like a visual studio for haskell ?
09:53:31 <dolio> Although I haven't looked at leksah in a long time.
09:53:36 <xenyl> funktronic: why not
09:53:46 <xenyl> leksah is what i have been trying lately
09:53:53 <xenyl> haven't made up my mind yet though
09:54:20 <dolio> Does leksah do indentation? I think it didn't last time I checked.
09:54:38 <dolio> The emacs mode has better Haskell indentation than anything else.
09:54:54 <dolio> Although there's an okay mode for vim.
09:55:43 <sm> there's also eclipseFP
09:55:49 <xenyl> dolio: i'd say that yeah, emacs is pretty good in that
09:56:04 <xenyl> eclipse fp is like ghci with eclipse and not much more though, no ?
09:56:50 <Silvah> dolio: how many keys you have to press simultaneously in order to do anything in emacs? Twenty? ;P
09:57:20 <dolio> Two.
09:58:31 <dolio> I wouldn't be bragging about button presses.
09:59:07 <dolio> The intelligent indentation in emacs often means I can press backspace once or twice instead of 20 times in vim.
09:59:27 <xenyl> aha! http://www.reddit.com/r/haskell/comments/fz6ej/eclipsefp_203_released/
09:59:32 <Silvah> dolio: two? It's not emacs, then :P
09:59:32 <mauke> why are you pressing backspace in vim?
09:59:57 <dolio> Because I'm writing code in insert mode.
10:00:08 <mauke> and?
10:00:20 * sm thinks writing haskell code without auto indentation must be rather painful
10:01:03 <xenyl> all code without indentation is painful
10:01:06 <dolio> Vim has autoindent. It just doesn't work that well.
10:01:11 <dolio> For Haskell.
10:01:13 <crystal-cola> I barely use any indentation in haskell my code is usually just lines like   f = a . b . c . d
10:01:24 <Lemmih> Does EclipseFP work with GHC 7?
10:01:25 <dolio> it will auto-indent properly after 'do x <- ...'.
10:01:48 <dolio> But when you want to go back to the indenting level from before the do block, you're doing it manually.
10:01:56 <sm> crystal-cola: sounds like you have less imperative code than me
10:01:57 <mauke> or I could press ^D
10:03:04 <rostayob> mauke: wait, ^D intentates automatically in vim?
10:03:21 <mauke> ^D is decrease indentation, ^T is increase indentation
10:03:23 <mauke> of the current line
10:03:26 <rostayob> oh ok
10:03:36 <rostayob> emacs Tab just intentates correctly :P
10:03:49 <mauke> if I had to press something to indent, it wouldn't be automatic indentation, would it?
10:04:12 <rostayob> mauke: as in you press tab and it indents the line
10:04:15 <mauke> yes
10:04:18 <mauke> why would I want that?
10:04:25 <rostayob> ? because that's what you want
10:04:29 <mauke> no, it's not
10:04:32 <rostayob> why not?
10:04:33 <mauke> I just want to type my code
10:04:39 <mauke> indentation should be automatic
10:04:57 <rostayob> indentation can be automatic in emacs
10:05:02 <rostayob> but the point is, if you edit code
10:05:05 <rostayob> and you change stuff
10:05:11 <rostayob> Tab reindents it correctly
10:05:21 <mauke> that should be automatic
10:05:25 <rostayob> actually i think that indentation is automatic by default in haskell mode
10:05:27 <dolio> Where's the indentation mode for which ^D and ^T actually handles Haskell code correctly?
10:05:28 <rostayob> it's automatic.
10:05:34 <rostayob> you just have to choose
10:05:44 <dolio> Moving n spaces is not correct.
10:05:59 <mauke> dolio: dunno, all my code is written so that n spaces is actually correct
10:06:42 <rostayob> mauke: no I don't think you understand what I'm talking about. emacs Tab automatically indents according to the language. so when you move code around and stuff like that it's way easier to reindent it, for example. vim doesn't have that.
10:06:53 <mauke> rostayob: =
10:06:56 <dolio> Or, how about: I write a new line that's going to begin with a guard, and there are already guards on the function I'm writing.
10:07:08 <dolio> How do I get the mode to automatically line up the pipe with the other pipes?
10:07:10 <mauke> rostayob: as in == (reindent current line) or =aB (reindent current block)
10:07:36 <rostayob> mauke: does reindent mean indent according to the language? not just "insert/remove" n spaces?
10:07:57 <rostayob> and according to the context?
10:08:06 <mauke> rostayob: what's the difference?
10:08:17 <mauke> all reindentation will insert or remove spaces
10:08:34 <rostayob> mauke: yes but emacs it's smart and it indents it depending on the context
10:08:37 <rostayob> for example a multi line list
10:08:45 <dolio> Anyhow, I like vim better. But the tool support for Haskell isn't as good.
10:09:04 <rostayob> or guards, or whatever
10:09:08 <mauke> dolio: I don't know of a good haskell indent plugin that gets it right
10:09:20 <mauke> rostayob: yes, that's how it's supposed to work
10:09:33 <rostayob> mauke: haskell-mode if you don't use TH or other extensions works perfectly
10:09:38 <rostayob> haskell-mode for emacs
10:09:47 <mauke> I doubt that
10:10:13 <dolio> I'd just switched to emacs previously, because for Agda there's not even a ballpark.
10:10:15 <rostayob> mauke: well I use it every day... it's one of the main reasons I use emacs to edit haskell
10:10:26 <dolio> But everyone uses vim at work, so I guess I'll pick that up again.
10:10:30 <rostayob> also, font locking is fun :D
10:10:42 <sm> haskell-mode ships with 3 indentation modes, only one of which ever made sense to me
10:11:24 <dolio> The one written (or reworked) by kuribas is the best, I'd say.
10:11:30 <dolio> I'm not a fan of the cyclic tab thing.
10:11:31 <sm> turn-on-haskell-indent .. that's the one I use
10:11:45 <KirinDave> Hmm, weird parsec error...
10:12:04 <rostayob> sm: yeah I remember having to set it up the first time but afaik it's the only editor with good indentation support for haskell
10:13:09 <tg_> so, I'd like to ask a question about the prospects of doing a project in haskell...
10:14:04 <mauke> all my haskell code is "tab compatible" so I haven't needed much editor support
10:14:08 <KirinDave> Could anyone help me decipher this error?
10:14:09 <KirinDave> http://hpaste.org/46194/weird_parsec_error
10:14:32 <KirinDave> The error is in the annotation
10:14:49 <KirinDave> It's like it couldn't match a type but then says the type is the same in both cases.
10:14:57 <sm> KirinDave: do you mean the hlint error ?
10:14:57 <mauke> no, it doesn't
10:15:02 <mauke> sm: no
10:15:06 <rostayob> :t (>>)
10:15:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:15:20 <rostayob> KirinDave: edges should be unary
10:15:24 <Lemmih> KirinDave: What's with the isHidden thingy?
10:15:38 <KirinDave> I haven't wired that in.
10:15:40 <KirinDave> Ahh
10:15:42 <danharaj> man I make that error all the time
10:15:43 <tg_> Let's say I propose a project with a somewhat precise construction. I want to know three things: Is this construction comprehensible (ie, does it make sense to say this?)? Is it possible (ie, does language support it)? And, is there a better one?
10:15:58 <dolio> KirinDave: One type is T, the other is t -> T
10:16:08 <KirinDave> Ahh
10:16:13 <KirinDave> I misunderstood it
10:16:23 <KirinDave> Still getting my footing at reading these errors
10:16:34 <KirinDave> I just keep telling myself it can't be less helpful than the scala compiler ;)
10:16:49 <dolio> Yes, well, that's probably true.
10:17:08 <rostayob> KirinDave: that error is quite clear actually. it tells you I'm expecting this type but I've got this other type
10:17:19 <KirinDave> Yeah I was just failing to read it right.
10:17:26 <kmc> what's missing is the explanation of *why* it's expecting that type
10:17:40 <tg_> The constructed thing is this: A version of ghci which contains a isomorphism or a similary strong map from Haskell functions to Mathematica functions (for purposes of rendering only - descriptive purposes)?
10:17:42 <mauke> I think I have the ultimate in unhelpful errors
10:17:58 <rostayob> kmc: because of (>>) type signature
10:18:10 <mauke> I have a language without errors; the "best" you get from the interpreter is an infinite loop
10:18:23 <mauke> which is weirdly similar to "bottom", actually
10:18:27 <KirinDave> So
10:18:31 <KirinDave> My second question is
10:18:37 <KirinDave> I think this edges parser expresses what I want
10:18:38 <KirinDave> But
10:18:54 <KirinDave> Is there a way to write it that is less parthetical?
10:19:16 <dolio> mauke: Is every character string a valid program?
10:19:18 <mauke> :t sepBy
10:19:18 <KirinDave> There are zero or more comma-intercalaed edges, which are themselves name=value
10:19:19 <lambdabot> Not in scope: `sepBy'
10:19:20 <mauke> dolio: yes
10:19:23 <dolio> Ah.
10:19:43 <rostayob> KirinDave: well the type signature of that function is wrong, what's that "isHidden"?
10:19:48 <KirinDave> rostayob: Fixed
10:19:52 <rostayob> a string I guess
10:19:55 <rostayob> ok
10:20:01 <mauke> edges = edgeDef `sepBy` char ','
10:20:26 <KirinDave> mauke: That is sorcery if it works for 0 or more. :)
10:20:35 <mauke> it does
10:20:38 <KirinDave> sorcery!
10:21:17 <rostayob> mauke is telling you that you don't need parsec for that :P
10:21:27 <mauke> I am?
10:21:47 <KirinDave> rostayob: This is a subset of the fileformat
10:21:49 <rostayob> well your function doesn't use parsec
10:21:50 <orftz> :wc
10:22:00 <mauke> rostayob: http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Combinator.html#v:sepBy
10:22:19 <rostayob> oh right, I had the other sepBy in mind
10:23:06 <rostayob> i mean the one in base. nevermind
10:26:29 <KirinDave> It is pretty stunning how good the error messages from ghc are.
10:26:38 <KirinDave> I'm used to erlang, scala, and clojure.
10:26:43 <tg_> lol.
10:26:48 <tg_> that's embarassing. talking to myself in #haskell-math.
10:27:00 <rostayob> KirinDave: haskell has a cool type system
10:28:35 <Lemmih> tg_: It's hard to say without knowing more about what you want.
10:28:36 <rostayob> KirinDave: http://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm
10:29:32 <tg_> Lemmih: yeah, I pasted what I want in #haskell-math
10:29:39 <tg_> Lemmih: if you would join there, I can repaste it
10:29:46 <tg_> for you to see the specification
10:32:19 <MrMeh> Does anybody know of good treatments of haskell written with mathematicians in mind?
10:32:32 <tg_> MrMeh: haskell for maths
10:32:35 <tg_> is OK
10:33:42 <tg_> can I get a haskell expert (but not necessarily expert mathemitician) to join #haskell-maths for a conversation?
10:34:57 <MrMeh> tg_: Yeah, I've looked at it a bit, but wasn't too impressed.  I was looking more for an overview of the language itself that was written for math people.
10:35:13 <sipa> tg_: asking for experts exclude those who do not consider themselves experts, but would still know the answer :)
10:37:16 <rostayob> tg_: just ask here, I'm sure someone will answer
10:39:07 <pmurias> is the scion vim frontend any good?
10:39:39 * sm_ wonders if chris done is around
10:39:41 <monochrom> eh? there is #haskell-maths?
10:39:52 <monochrom> err #haskell-math. I'll look
10:39:54 <rostayob> Lemmih: is it possible to define acid-state Events on the fly, without deriving with TH? like if I need them just once - i'm writing some functions to check the db for consistency
10:40:17 <monochrom> is there also #haskell-meth? :)
10:41:30 <monochrom> MrMeh: I think "the haskell road to logic, maths and programming" works
10:42:01 <monochrom> in fact, http://www.amazon.com/Sex-Tips/dp/0954300696 :)
10:42:35 <rostayob> Sex-Tips?
10:42:42 <rostayob> mh.
10:43:08 <MrMeh> monochrom: awesome, thanks.  I'll give it a look.
10:43:09 <monochrom> in fact, http://www.amazon.com/Haskell-Road-To-Sex-Maniac/dp/0954300696 :)
10:43:38 <rostayob> monochrom: on. so amazon is stupid and lets you put anything there. that's bad
10:43:44 <rostayob> i prefer #haskell-meth
10:43:48 <Lemmih> rostayob: Follow-up in #happs.
10:43:53 <rostayob> Lemmih: k
10:44:56 <monochrom> I think it's pretty clever. there is often no normal form for book names, why not just ignore it and focus on the numeric id
10:45:21 <monochrom> but still allow some kind of book name for humans
10:45:44 <rostayob> monochrom: because different urls should have different content
10:45:54 <monochrom> I disagree.
10:46:36 <monochrom> since day one, "www.blahblah" and "www.blahblah/index.html" already point to the same thing
10:46:36 <danharaj> It's Uniform Resource Location, not Unique Resource Location :p
10:47:01 <monochrom> your injectivity dream was lost before you had it
10:47:10 <rostayob> ahah
10:47:28 <rostayob> boh maybe
10:47:32 <rostayob> it just looks wrong to me
10:48:20 <monochrom> you should just enjoy going into ##java and say "http://www.amazon.com/The-Secrets-Of-Java-Experts/dp/1593272839/ " :)
10:48:33 <danharaj> oh man
10:48:38 <danharaj> I want to do that so hard now.
10:48:46 <MrMeh> haha
10:50:06 <rostayob> i'd rather go in #javascript and do http://www.amazon.com/Crockford-Exposed/dp/1593272839/ or something like that
10:50:15 <rostayob> mh
10:50:29 <monochrom> yeah, do that
10:51:53 <rostayob> maybe those urls are not that bad.
10:54:44 <rnik> Anyone successfully used the FFI to call a Mac OS X framework (dynamic library)?  I wrote a simple test program to try to play some MIDI notes, and it just dies.  It seems 64 bit and dynamic support is not great on Mac so maybe this is impossible.
10:57:40 <navaati> woaw, LYAH is a book ? maybe it explains why the tuto on the web is not complete
10:58:19 <monochrom> I'm actually pretty sure that the web version is more updated than the paper version
10:58:34 <hpc> navaati: the web version and paper version are currently exactly the same
10:58:41 <hpc> i have the book right next to me
10:58:47 <DasIch> navaati: "The whole thing is completely free to read online" http://learnyouahaskell.com/
11:00:41 <DasIch> it would be nice if there would be an option to pay the author an amount of my choosing as a thank you for putting it online
11:03:08 <mercury^> BONUS: someone wants to give you money.
11:08:48 <BONUS> hey!
11:08:48 <lambdabot> BONUS: You have 6 new messages. '/msg lambdabot @messages' to read them.
11:08:50 <BONUS> its me!
11:08:58 <sipa> hi!
11:09:03 <BONUS> hi y'all
11:12:42 * hackagebot yesod-json 0.1.1 - Generate content for Yesod using the json-types package.  http://hackage.haskell.org/package/yesod-json-0.1.1 (MichaelSnoyman)
11:25:30 <Sagi> Anyone with a suitable alternative for the broken haskell-platform package on ubuntu? I'm running natty. (related bug on launchpad http://bit.ly/mU2ni1)
11:28:50 <Mkman> Hey!
11:29:35 <ArnoVanLumig> Sagi: manual install seems to be the only way
11:29:37 <parcs> Sagi: you can always install from source
11:30:36 <Sagi> hmm, no-one with an alternative repository? I noticed the one by justin bogner, but it's outdated.
11:31:31 <jkff> @djinn \a -> a
11:31:31 <lambdabot> Cannot parse command
11:31:36 <jkff> hm
11:31:36 <lambdabot> jkff: You have 1 new message. '/msg lambdabot @messages' to read it.
11:33:04 <sm_> is yackage useful for previewing the content and layout of a package's page on hackage ?
11:34:12 <jkff> @djinn (x -> (a, a -> x)) -> ((x -> (a, a -> x)) -> b) -> (x -> (b, b -> x))
11:34:12 <lambdabot> f a b c =
11:34:12 <lambdabot>     case a c of
11:34:12 <lambdabot>     (d, e) -> (b (\ f -> (d, \ _ -> f)), \ _ -> e d)
11:34:27 <jkff> no djinn, that's a bad cobind
11:36:46 * hackagebot storable-record 0.0.2.4 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2.4 (HenningThielemann)
11:52:59 * sm_ rediscovers that cabal haddock --exe is a good way to preview hackage content.. yay
11:56:51 <Somelauw> When a function accepts a tuple in haskell, should there be a space between the function and the tuple, like h (a, b) or h(a, b)
11:56:55 <Somelauw> ?]
11:56:55 <lambdabot> Maybe you meant: . ? @ v
11:57:15 <Somelauw> no, it wasn't supposed to be executed by a bit?
11:57:32 <Somelauw> It was just a question mark.
11:57:37 <ddarius> Somelauw: Why don't you try each and see what happens?
11:58:01 <Somelauw> ddarius: they both work. I am just wondering which one is cleaner.
11:58:16 <BONUS> space fo sho
11:58:30 <Somelauw> ? uncurry (+) (5, 6)
11:58:31 <ddarius> Somelauw: The former is the consistent one then.
12:00:47 <Somelauw> is the former the one with space?
12:02:54 <BONUS> yup
12:03:12 <BONUS> however, im still unsure whether it's better style to do (a,b) or (a, b)
12:03:40 <Somelauw> I think (a, b) looks better there, since it looks like English.
12:03:47 <ddarius> BONUS: The latter.
12:04:59 <BONUS> yeah i think that's better as well
12:09:46 <sm_> is there a way you can put a comment at the end of function's haddock, to be read by the programmer but not appear in the haddock ?
12:11:21 <ddarius> Put a normal comment there.  Separate by whitespace.
12:22:05 <sm_> ddarius: wow! I just figured that out. I always thought there couldn't be whitespace between haddock and function
12:22:23 <sm_> thanks
12:31:17 <balor__> How do I "catch" the exception "thrown" by "minimum []"?
12:31:55 <sipa> balor__: you don't call minimum if you're not sure it's not empty :)
12:32:40 <balor__> sipa, thanks.
12:33:09 <balor__> sipa, Are such partial functions marked in the API in any special way?
12:33:29 <scree> balor__: no
12:33:54 <sipa> minimum :: Ord a => [a] -> a
12:33:54 <sipa> minimum returns the minimum value from a list, which must be non-empty, finite, and of an ordered type. It is a special case of minimumBy, which allows the programmer to supply their own comparison function.
12:34:12 <balor__> scree, sipa: thanks again
12:34:15 <scree> balor__: there's a lobby to get minumum etc. rename unsafeMinumum, but I don't think anyone's taking that seriously :)
12:34:39 <sipa> you could have a minimumWithDefault or so
12:34:41 <applicative> how does the mind parse "case () of { _ etc ... }" in dons's definition of go here:  http://hpaste.org/46197/case__of
12:35:31 <balor__> sipa, Is it common to write a "min :: [a] -> Maybe a" and then use the "Nothing" as a "failure" indicator? or is that bad style?
12:35:35 * balor__ is n00b
12:35:40 <applicative> it is suppose to strictify the function, but I can't understand the mix of case and _ and { and |
12:36:21 <scree> applicative: heh.  That's nice syntax
12:36:37 <scree> applicative: it means "if ... then ... else if ..."
12:37:37 <scree> applicative: so, the braces are explicit layout; _ is "always match ()"; and the guards are guards
12:38:00 <Tomsik> balor__: that's what Maybe type is for :)
12:38:43 <danharaj> hmm... how do you do parametrized modules in Haskell?
12:38:46 <balor__> Tomsik, great
12:39:00 <applicative> scree, keep talking :) I get all the parts, but somehow not the whole
12:40:15 <applicative> scree, I guess I'm not seeing how it is legitimate to introduce guards at that point.
12:40:58 <scree> applicative: well, case () of { () -> 5 } is legitimate, right?
12:41:10 <dubhrosa> can someone help me understand why I don't get an incomplete pattern warning with this code: http://hpaste.org/46198/records_syntax
12:41:19 <scree> applicative: so case () of { _ -> 5 } is basically the same
12:42:04 <dubhrosa> it seems like a hole in the type system if you can end up with a runtime error when you add a reasonable alternative constructor to an ADT, am I missing something?
12:42:06 <scree> applicative: and case () of { () | 1 == 2 -> 5; | otherwise = 6 } is the same but with guards
12:42:12 <ddarius> danharaj: Use the encoding of ML-style parameterized modules into either System F or Haskell type classes.
12:42:24 <scree> s/=/->
12:42:30 <applicative> scree thats where i get lost
12:42:32 <dbpatterson> is it possible to write constant bytestrings as "some string" and have the compiler add the necessary pack calls? (sorry if this is a stupid question, I just feel like I've seen it done and dont know if it is a GHC extension or what).
12:42:52 <applicative> > case () of { () | 1 == 2 -> 5; | otherwise = 6 }
12:42:53 <lambdabot>   <no location info>: parse error on input `|'
12:43:05 <applicative> > case () of { () | 1 == 2 -> 5; | otherwise -> 6 }
12:43:05 <lambdabot>   <no location info>: parse error on input `|'
12:43:15 <scree> applicative: would you be happy with: "f () | 1 == 2 = 5; f () | otherwise = 6" ?
12:43:43 <scree> > case () of { () | 1 == 2 -> 5 | otherwise -> 6 }
12:43:43 <lambdabot>   6
12:44:00 <ddarius> dbpatterson: There's an extension that uses an IsString class to convert string literals much like fromInteger converts integer literals.
12:44:22 <dbpatterson> ddarius: what is it called?
12:44:55 <geheimdienst> dbpatterson: OverloadedStrings
12:45:02 <gio123> lambdabot do u know lambda calculus?
12:45:09 <geheimdienst> not sure if there's an instance for ByteStrings
12:45:13 <dbpatterson> geheimdienst: thanks!
12:45:19 <dbpatterson> oh hmm...
12:45:43 <Somelauw> haskell is almost lambdacalculus, right
12:45:52 <ddarius> geheimdienst: There is somewhere, and if there isn't, it isn't hard to write instance IsString ByteString where fromString = pack
12:45:54 <danharaj> ddarius: Sounds interesting and also beyond my means right now. :p
12:46:01 <scree> applicative: as in, you can use case syntax wherever you can use multiple equation syntax, as it's just sugar anyway
12:46:05 <geheimdienst> dbpatterson: check out this as well http://stackoverflow.com/questions/3815442/how-do-i-get-the-overloadedstrings-language-extension-working
12:46:10 <ddarius> danharaj: It's not that hard.
12:46:11 <gio123> <Somelauw i need some help in a theory
12:46:35 <geheimdienst> agreed, those instances are easy to write
12:46:38 <danharaj> ddarius: I am time constrained and also mentally exhausted from learning various things simultaneously. But ok. I'll look into it.
12:46:54 <applicative> scree thanks.    "f () | 1 == 2 = 5; f () | otherwise = 6" has done it for me
12:47:03 <dbpatterson> geheimdienst: great
12:47:14 <scree> applicative: cool
12:47:35 <applicative> scree, it was too many things at once... :)
12:48:10 <dubhrosa> A simpler example: data Mytype = A { getv :: Double} | B Double; test :: Mytpe -> Double; test = getv -- why does this compile without any warnings about incomplete patterns and then throw a runtime exception?
12:53:02 <applicative> dubrosa, it's maybe a bit weird but data List a = Cons { head :: a ; tail :: List a} | Nil
12:53:17 <ezyang> hee hee
12:54:36 <dubhrosa> applicative: indeed, good point
12:54:43 <applicative> dubhrosa, I think you are right to throw a coding-time exception, however....
12:56:21 <dubhrosa> seems the better way to it in my case (production code at work) is to make a new type rather than add a constructor to the existing one, but I'm modelling transactions and I really wanted to have a single list of them...
12:57:34 <gio123> ezyang: hi
12:59:32 * hackerhippie is away: Away
13:10:00 * hackagebot fixed-point 0.4.0.0 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.4.0.0 (JakeMcArthur)
13:10:02 * hackagebot fixed-point 0.4.0.1 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.4.0.1 (JakeMcArthur)
13:24:00 <rostayob> In haddock, can I create documentation for functions/data types by referring to them in some way, instead of putting it over the function?
13:24:09 <rostayob> I need this because I use a lot of TH functions to derive stuff
13:24:15 <rostayob> and I'd like to document the derived stuff
13:25:58 <applicative> yipe TH + Haddock, wasn't there unpleasantness about this on the -cafe list just recently?
13:27:47 <applicative> dubrosa, I only saw your paste afterward there, what about these 'safe' functions: http://hpaste.org/46200/records_syntax_annotation
13:27:48 <rostayob> applicative: could you point me to the discussion?
13:28:06 <applicative> rostayob, i'm looking, i could be wrong
13:29:13 <rostayob> applicative: ok, thanks
13:30:51 <applicative> http://www.haskell.org/pipermail/haskell-cafe/2011-April/091453.html
13:31:52 <Lemmih> rostayob: No, not really. One way is to use CPP.
13:32:46 <rostayob> Lemmih: oh, ok. never used CPP. of course the TH is related to acid-state (:
13:32:54 <rostayob> and I'd like to document the query/updates
13:34:51 <dubhrosa> applicative: yes, I see that that is the correct way to write it (or else to split out the types); my point is more that I got bitten by this and at first glance I thought it shouldn't be possible in haskell - originally the Transaction type had a single constructor, Trade, and there was a lot of code that processed lists of Trades. Then we added the Dividend constructor, and I expected a bunch of compiler errors/warnin
13:34:52 <dubhrosa> gs about the record accessors from the Trade constructor, but everything compiled fine
13:35:24 <dubhrosa> it's the type of refactor/incremental change that you expect the compiler to help out with but in this case it's silent
13:36:12 <rostayob> @pl (u, _, _) -> not (null u)
13:36:12 <lambdabot> (line 1, column 3):
13:36:12 <lambdabot> unexpected ","
13:36:12 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
13:36:17 <rostayob> @pl \(u, _, _) -> not (null u)
13:36:17 <lambdabot> (line 1, column 7):
13:36:17 <lambdabot> unexpected ","
13:36:17 <lambdabot> expecting operator or ")"
13:36:17 <lambdabot> ambiguous use of a non associative operator
13:36:51 <rostayob> @pl \(userName, _, _) -> not (null userName)
13:36:51 <lambdabot> (line 1, column 14):
13:36:51 <lambdabot> unexpected ","
13:36:51 <lambdabot> expecting operator or ")"
13:36:51 <lambdabot> ambiguous use of a non associative operator
13:36:56 <rostayob> mh?
13:37:42 <rostayob> what's the problem with that?
13:40:33 <applicative>  \(userName, a) -> not (null userName)
13:40:45 <applicative> @pl  \(userName, a) -> not (null userName)
13:40:45 <lambdabot> not . null . fst
13:41:01 <applicative> pl doesn't know what to do with ( , , )
13:41:31 <applicative> @pl  \(userName, (_ , _)) -> not (null userName)
13:41:32 <lambdabot> not . null . fst
13:42:03 <applicative> @pl  \((userName, _ ), _) -> not (null userName)
13:42:03 <lambdabot> not . null . fst . fst
13:42:27 <rostayob> oh. that's weird.
13:43:41 <Tomsik> > fix fst
13:43:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
13:43:53 <Tomsik> you bastard
13:51:48 <filcab> Hi all
13:52:07 <noteventime> hullo
13:52:14 <libertas> Hi, I'm in the beggining of a data mining project - clustering - and I started it in C++ (which I'm learning) because of its power and speed. But each time I turn to Haskell I feel tempted to try it in this lang.  My doubt is whether Haskell won't arise some problems when algorithm is very developed. I've never programmed in functional.
13:52:42 <filcab> I'm having problem limiting my memory usage while using hsql
13:52:42 <libertas> Is there someone that did some data mining - clustering - in Haskell?
13:52:54 <filcab> I have this: https://gist.github.com/950001
13:53:01 <aristid> libertas: which languages you know well?
13:53:17 <filcab> doRow will iterate all rows (using forEachRow)
13:53:38 <filcab> and it seems to me that the memory that's being used only depends on the maximum number of words in a song
13:53:57 <filcab> (the database has: (track_id, word, number))
13:54:05 <filcab> each row has the count of a word for a track
13:55:01 <luite> libertas: it's possible to write it in haskell, a readable haskell implementation may be slightly slower than a C++ implementation, but in general you can get it quite fast
13:55:10 <filcab> I have a state that has: number of rows iterated, number of songs iterated, track_id from last row, Map word count.
13:55:29 <luite> libertas: one problem tough might be that haskell isn't terribly popular in the machine learning community :)
13:55:35 <filcab> any ideas on where I can save some memory?
13:55:50 <filcab> or how to find out why I am leaking?
13:56:24 <libertas> aristid: I know Python, Php and VB and Pascal in the past. Now I already know a bit of C++
13:56:27 <filcab> I've iterated, for example, through 10000 rows and inspected the state afterwards... I get no help: the state is only pertaining to the last song, as I wanted
13:56:54 <aristid> libertas: where did you learn machine learning techniques?
13:56:58 <filcab> I have 700000 songs in that database, so it gets really big
13:57:22 <libertas> luite: and why is it not so popular?
13:58:16 <libertas> aristid: it's part of my Phd thesis that I'm preparing.
13:58:18 <filcab> As you can see in the code, I tried using a strict field in RowState. Before that, it was just a 'type' with the tuple.
13:58:20 <jmcarthur> because people don't like investing the effort to learn new things
13:58:46 <aristid> libertas: why not use python?
13:59:19 <luite> libertas: probably because the compiler and libraries have only recently become good enough for really large scale and fast computations, and because haskell's so different from what they're used to. They have R for example, where many algorithms are available, porting all those to haskell would take a tremendous effort
14:01:15 <Kaidelong> libertas: I did some simple clustering in Haskell (k-means)
14:01:33 <libertas> aristid: I needed something much faster than Python for heavy data.  How does Haskell deal with much data?
14:01:38 <Kaidelong> and I know a bunch of other people have if only to make benchmarks for Haskell's parallel programming performance
14:02:19 <luite> libertas: you can in general get relatively close to C performance
14:02:23 <aristid> libertas: well, ghc tends to produce pretty fast code (faster than python)
14:02:31 <luite> libertas: like 2-3x slower
14:02:44 <aristid> libertas: but are you sure that python is really too slow for you?
14:03:07 <Kaidelong> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:data mining
14:03:22 <luite> libertas: but it all depends on how far you want to go to optimize. optimized haskell code can look quite different from regular idiomatic code
14:03:56 <libertas> luite: parallel tasking is something that appeals to me in Haskell
14:04:01 <luite> libertas: there are libraries available for fast parallel mutable arrays
14:04:38 <luite> libertas: and it's very easy to do part of your algorithm in C if you really need to squeeze out the last drop of performance
14:04:51 <luite> it takes only a few lines of code to call a C function from haskell
14:04:58 <libertas> Kaidelong: thanks for the link.
14:05:33 <Kaidelong> libertas: Haskell has a lot of options for parallelization and that might be somewhat confusing
14:06:00 <Kaidelong> although in your case perhaps "par
14:06:04 <Kaidelong> " is enough
14:06:07 <Kaidelong> to make a big difference
14:07:51 <aristid> :t par
14:07:52 <lambdabot> forall a b. a -> b -> b
14:08:23 <Kaidelong> par = seq but the stuff can be evaluated in parallel
14:09:29 <jmcarthur> actually it's not denotationally equal to seq
14:09:48 <jmcarthur> par _|_ x = x, but seq _|_ x = _|_
14:10:03 <pmetzger> you are allowed to do
14:10:04 <gio123> lambda calculus<--need help
14:10:29 <pmetzger> gah. I was trying to say: you are allowed to write ⊥
14:10:58 <luite> libertas: if you want to learn haskell for this, start with learn you a haskell and the types that are explained there (i.e. lists, most likely). the code will most likely be slower than an equivalent python implementation, but it should be correct. from there, you can make it faster
14:11:05 <luite> @where lyah
14:11:05 <lambdabot> http://www.learnyouahaskell.com/
14:11:21 <crystal-cola> gio123: what about it?
14:12:17 <Kaidelong> jmcarthur: Mmm, is that so? So there is no barrier set up with par to ensure everything finishes evaluating?
14:12:25 <Kaidelong> that's quite handy potentially
14:12:34 <jmcarthur> Kaidelong: right. that's the design
14:12:51 <Kaidelong> i suppose you need that for x `par` y `par` z ... etc to work
14:13:01 <jmcarthur> Kaidelong: par just says that when one thing is forced you want something else to be sparked off for potentially parallel execution
14:13:23 <jmcarthur> Kaidelong: it may not even evaluate the parallel computation at all
14:13:31 <jmcarthur> and even if it does, it won't wait for it
14:13:45 <libertas> luite: one of the problems I had with Python was when I used really big lists for a genetic algorithm I built.  Python is nice but not for heavy loads, IMO.  Haskell suffers from the same problem or does it scale well?
14:14:02 <luite> libertas: it all depends on the data structures you use
14:14:07 <iFire> so who else ordered the paperback learn you a haskell?
14:14:13 <iFire> I got a fancy postcard
14:14:36 <gio123> crystal-cola: confluence proof :)
14:14:51 <crystal-cola> gio123: what about it?
14:14:52 * mgsloan only got stickers
14:14:53 <luite> libertas: lists can be quite slow (being linked lists), but in some cases they can be optimized away by the compiler
14:14:58 <Venzon> hello, does anyone know why data.array.diff got moved out of the haskell core libraries?
14:15:19 <gio123> crystal-cola: some problems to undestand proof of confluence
14:15:21 <Kaidelong> from what I understand, because it was broken
14:15:24 <gio123> are u familier about it
14:15:24 <gio123> ?
14:15:26 <jmcarthur> Venzon: because it is slow enough that it was almost useless
14:15:27 <crystal-cola> gio123: Do you have a proof of it you are reading?
14:15:33 <cloudhea3> is there anything special I'm supposed to do if STDOUT is a pipe? it doesn't seem to work..
14:15:38 <gio123> i amreading
14:15:42 <gio123> yes
14:15:57 <Venzon> jmcarthur: what should i be using if i want arrays that i can use in purely functional code? or just give it up and do it in IO?
14:16:02 <crystal-cola> what?
14:16:13 <Kaidelong> Venzon: What's wrong with ST?
14:16:15 <jmcarthur> Venzon: it depends on the kind of algorithm you're trying to write
14:16:21 <Kaidelong> thaw the array into ST
14:16:26 <Kaidelong> do your mutation
14:16:30 <luite> libertas: since lists are linked lists, you cannot quickly access an arbitrary element. but there are lots of alternatives, including arrays (regular arrays are immutable, but there are ways to get mutable arrays in haskell) and maps
14:16:31 <Kaidelong> freeze it back into a pure array
14:16:38 <jmcarthur> Venzon: many array algorithms can be written efficiently with folds and accumulations and stuff in purely functional style
14:17:20 <luite> Venzon: IntMap if you're ok with Int as keys
14:17:34 <jmcarthur> Venzon: the vector and repa packages can do quite a bit. if you really think you want to try it, i think diffarray is in its own package now too, but i recommend against it
14:17:53 <jmcarthur> Venzon: yeah, intmap works well for some things, too
14:17:57 <Venzon> i'm maintaining a roughly 256x256 playing area for a game
14:17:59 <Kaidelong> I like vector a lot
14:18:00 <jmcarthur> Venzon: also STArray etc.
14:18:06 <luite> IntMap or Map is the most generally useful thing, except if you need it to be really fast
14:18:29 <Venzon> i'm doing a lot of reads, not many writes
14:18:41 <luite> then immutable arrays could work
14:21:21 <Venzon> my game has a functional simulation update but the result goes into IO code that processes and draws the result; i can defer the array updates to the IO portion of the code, as long as i can read from the array in the functional code. maybe that's what's meant by freeze/thaw?
14:23:09 <luite> Venzon: not really, you probably want to view doing a move as a function from a board (array) to a new board
14:24:08 <Venzon> so any immutable array change results in O(n) operations where n is the number of elements in the array?
14:24:18 <luite> yes
14:24:45 <Venzon> luite :but element access is constant time?
14:25:01 <luite> yes
14:25:26 <Venzon> alright, i'll see if i can live with it, thanks!
14:25:34 <chris_st> hi -- noob haskell user here, trying to use the 'random-shuffle' package, installed with cabal, but I get an error when I try to use it. What should I do to figure out how to use it?
14:25:44 <mauke> what error?
14:25:56 <chris_st> Exception: src/System/Random/Shuffle.hs:(66,7)-(79,49): Non-exhaustive patterns in function extractTree
14:25:58 <luite> Venzon: a typical situation where you'd use freeze is an algorithm that requires a mutable array, because it does lots of updates (in the ST monad usually), at the end of that algorithm you freeze the result, you copy the mutable array to an immutable one
14:26:27 <tolkad> I was reading this post about some company deciding to use haskell: http://blog.silkapp.com/2009/09/why-we-use-haskell/
14:26:27 <tolkad> they say "For example, data is immutable: if you modify a list, for example, you create a new copy (although smart compilers share duplicate parts for efficiency"
14:26:27 <tolkad> I don't understand that. I thought in general data will only be reused if it was never reconstructed in the first place. the reason modifying the head of a list reuses its tail is because you are simply providing a pointer to the old tail
14:26:34 <mauke> chris_st: how are you using it?
14:26:57 <chris_st> Tried just a basic 'shuffle [1,2,3,4] [0,0,0,0]' (copied from the description text page)
14:27:03 <mauke> tolkad: without looking at the url I agree with you
14:27:06 <jmcarthur> Venzon: btw, you can use ST to create a new array from an old one. that way if you have m updates to perform to the array you can do all of them in O(n) time instead of O(mn) time
14:27:07 <Venzon> luite: ah, so you still end up with a O(n) operation for the copy
14:27:17 <Venzon> gotcha
14:27:37 <byorgey> chris_st, mauke: from the source of random-shuffle: "NOTE: the collection of patterns below is deliberately not complete. All the missing cases may not occur (and if they do, that's an error)."
14:27:39 <luite> Venzon: yes, there are unsafe operations for these, that don't copy the array, but those are somewhat risky
14:27:54 <byorgey> so I guess it's a bug
14:28:08 <chris_st> Ouch :-)
14:28:22 <Venzon> luite: how is vector different?
14:28:36 <jmcarthur> tolkad: your understanding is correct. i suspect the article is just poorly worded
14:28:39 <byorgey> chris_st: send an email to the maintainer, Manlio Perillo <manlio.perillo@gmail.com>
14:28:49 <chris_st> will do, thanks
14:29:25 <jmcarthur> tolkad: i think what they mean is just that reusing an identifier doesn't make new copies of the data
14:29:33 <luite> Venzon: not really different, it also has mutable and immutable vectors. there are two main differences, the first is that vector is a bit less flexible, where array can be indexed by any type that is an instance of Ix (for example Int, but also tuples of ints), vector is indexed by Int only
14:29:54 <olsner> "data is immutable: if you modify a list ..." :)
14:30:15 <luite> Venzon: but vector has stream fusion, which means that in many cases when you use immutable vectors, the compiler can actually optimize away many of the intermediate results
14:30:19 <aweber> Hi all. I have a small beginner question. I want to use for example this functions from Crypto package - encrypt :: AESKey a => a -> Word128 -> Word128 (http://hackage.haskell.org/packages/archive/Crypto/4.2.3/doc/html/Codec-Encryption-AES.html). Now I just wanted to do a quick test and call it once. There I needed to create a Word128 which is a Data.LargeWord (http://hackage.haskell.org/packages/archive/Crypto/4.2.3/doc/html/Data-L
14:30:19 <aweber> argeWord.html#t:Word128). Somehow it does not work (see http://codepad.org/BIignGjV) and I have no idea why :(
14:30:36 <jmcarthur> Venzon: and if you'
14:30:38 <jmcarthur> dang
14:30:48 <Venzon> luite: but the complexity is still similar for an immutable vector?
14:31:06 <jmcarthur> Venzon: if you're going to look at vector, it might be worth also looking at repa. it's a little complex and underdocumented, but you can write very fast, functional code with it
14:31:08 <tolkad> jmcarthur: you prime?
14:31:12 <jmcarthur> Venzon: for multidimensional arrays
14:31:26 <tolkad> nevermind
14:31:30 <jmcarthur> tolkad: i don't understand the question
14:31:42 <tolkad> jmcarthur: I was confused by "<jmcarthur> Venzon: and if you'"
14:31:54 <jmcarthur> ah
14:31:57 <jmcarthur> typo
14:31:59 <luite> Venzon: if you carefully write your code, the immutable vector can be much faster than a non-fusable data structure
14:32:20 <danharaj> repa is fun
14:32:31 <danharaj> not entirely clear on when and how to use force, personally
14:32:36 <jmcarthur> i haven't used it since the big update
14:32:37 <luite> Venzon: but the operations you can do on the data while retaining fusion are limited
14:33:13 <luite> Venzon: both array and vector have mutable counterparts, which give you the most power, but are also the most complex to use
14:33:29 <jmcarthur> s/complex/painful/
14:33:48 <tolkad> luite: does stream fusion just use rewrite rule pragmas?
14:34:31 <luite> I have to admit that I haven't read the papers, but yes, I think that's where the magic happens
14:34:50 <ddarius> danharaj: The logic would be similar to when you'd want a materialized view as opposed to a normal view from database theory.
14:34:58 <ddarius> (or perhaps database practice)
14:35:14 <Venzon> luite: is there any way to read a mutable array from functional code without an O(n) copy before hand?
14:35:45 <mauke> unsafeFreeze?
14:35:51 <luite> Venzon: yes, unsafeFreeze. but that's only acceptable if you never write to the mutable array again after you've done that
14:36:23 <jmcarthur> tolkad: stream fusion works by converting the data into a form that allows you to write unfolds without recursion so that they can be inlined into each other. each function vector converts into and out of this representation, and a rewrite rule eliminates redundant conversions
14:36:36 <jmcarthur> *each function in the vector package
14:36:57 <jmcarthur> tolkad: that representation is a "stream"
14:38:06 <Venzon> i think i'll break my 256x256 array into several 16x16 subarrays to cut down on the hurt of a full 256x256 copy... most of the updates should be pretty localized
14:38:25 <jmcarthur> Venzon: i think that is very unnecessary if you choose the right data structure
14:39:00 <jmcarthur> Venzon: what you describe effectively turns your array into a quadtree. you might as well just use one of the tree-based structures like IntMap or something
14:39:07 <danharaj> ugh. there's no good opengl text library for Haskell yet.
14:39:28 <Venzon> danharaj: C SFML is pretty easy to write a binding for
14:39:38 <copumpkin> danharaj: I think lispy was working on freetype stuff precisely for opengl?
14:39:45 <jmcarthur> yes
14:40:10 <danharaj> copumpkin: I am not aware.
14:40:40 <luite> Venzon: copying such an array once per move shouldn't really be a problem, or do you need to execute thousands of moves per second?
14:41:19 <tolkad> Venzon: using functional data structures instead of arrays changes lookups from O(1) to O(log n)
14:41:40 <Venzon> only a few per second, but 65k operations is most likely very noticeable when it happens
14:41:41 <Cale> Since you know the size of your array already, all the operations will be O(1) regardless of which structure you use
14:41:51 <jmcarthur> somebody had to say it
14:41:54 <copumpkin> lol
14:42:06 <ddarius> And that somebody had to be Cale.
14:42:40 <luite> Venzon: I'd just start with the most simple structure, either an immutable array or an IntMap or Map. optimize only when it really is too slow
14:43:14 <Venzon> yeah, good point. i'll get back to it. thanks for the help :-)
14:43:15 <ddarius> Of course, this scenario is probably simple enough to explicit count the number of "operations" so we don't need to talk about asymptotic silliness.
14:45:15 <ddarius> Last I checked, arrays were functional data structures.
14:45:40 <Cale> Arrays are just one way of concretely representing certain functions :)
14:45:57 <tolkad> Venzon: since you wont be using the full range of Int, you'll get a tiny amount of speed if you reimplement IntMap yourself using Word8
14:46:26 <tolkad> Venzon: actually I forgot it's 2-dimensional, Word16
14:46:55 <koeien> i'd just start with a normal Map. it's easy to plug in another data structure later presumably.
14:46:56 <Cale> tolkad: I'm not certain that's true, given that machine words aren't really Word8's
14:47:03 <ddarius> tolkad: I wouldn't be surprised if doing that actually made it slower.
14:47:08 <koeien> and then profile
14:47:36 <tolkad> Cale: well you would at least be eliminating the top redundant branch that says the first half of the bits are zero
14:48:19 <tolkad> Cale: I guess you could stick with Ints, the reason to switch to Word16 would be for safety
14:49:18 <tolkad> Cale: Does that make any sense?
14:50:17 <koeien> Word16 would silently wrap
14:50:18 <jmcarthur> could just use unordered-containers with Word16
14:51:01 <jmcarthur> instead of reimplementing IntMap
14:52:10 <tolkad> "This integer need not remain consistent from one execution of an application to another execution of the same application. " - http://hackage.haskell.org/packages/archive/hashable/1.1.1.0/doc/html/Data-Hashable.html
14:52:10 <tolkad> That doesn't make any sense, that is already ensured by haskell semantics
14:53:14 <jmcarthur> no, not necessarily. not if you're doing unsafe things (that's basically what the documentation is saying is permissible)
14:53:42 <koeien> unsafePerformIO getNumberOfCores
14:53:59 <copumpkin> @hoogle capabilities
14:53:59 <lambdabot> No results found
14:54:47 <jmcarthur> i'm personally not a big fan of the whole "as long as it appears to be referentially transparent during a single run of the program then it's referentially transparent" idea
14:55:13 * ezyang is not a big fan of it either. 
14:55:55 <jmcarthur> one of the common arguments for purity is parallelism, but this lax definition of RT is unsuitable for distributed computing or even just computing with any other form of IPC
14:56:18 <Cale> I'm somewhat ambivalent. Obviously you don't want too much of that, but things like program arguments being a non-I/O value wouldn't be totally unpalatable to me.
14:56:55 <Cale> Or information about the machine architecture
14:56:57 <ezyang> Ooh ooh! Clearly what we want is a staged language.
14:57:13 <ezyang> First stage is traditional compilation, second stage is command line arguments, third stage is actual runtime.
14:57:14 <jmcarthur> things like this prevent you from being able to write pure interfaces for distributed computing
14:58:11 <jmcarthur> e.g. laziness (with sharing) in a distributed setting would fail pretty badly if it tried to share this machineArchitecture value
14:58:40 <jmcarthur> and then again, it might be bad to have it evaluate differently on different machines, too
14:58:52 <jmcarthur> having it in IO just makes more sense for this setting, to me
14:59:11 <tolkad> What if you just defined a new version of haskell where a single traditional program implied an infite number of possible programs, from which the compiler and RTS could select based on available information
14:59:17 <Cale> ezyang: hah, recompile the program with the commandline args baked in as constants? :)
14:59:29 <ezyang> Cale: Well, that's how you'd think about it, but you wouldn't /actually/ do that.
14:59:31 <jmcarthur> tolkad: we basically have that already
14:59:43 <ezyang> but you'd have a source level stratification of these different layers.
14:59:48 <Cale> ezyang: There might actually be cases where it would be nice to actually do that
14:59:50 <dolio> If you just want to think about it that way, you can already do that.
14:59:58 <jmcarthur> tolkad: implying that when you write a haskell program, you actually don't know what program you've written until you pair it with the machine it's running on
15:00:10 <Cale> Of course, you can already rig that up if you really needed it
15:00:11 <ezyang> But in particular, claiming that arguments is just IO conflates the second and third stage.
15:00:17 <ezyang> Yeah.
15:00:57 <jmcarthur> i'm also uncomfortable with the undefined sizes of Int and Word
15:01:00 <tolkad> jmcarthur: yeah but if you put it explicitly into the language standard, then you can put this other stuff in the standard that would otherwise be considered to be breaking purity and nobody can say haskell isn't pure
15:01:18 <koeien> jmcarthur: I am primarily uncomfortable with Int being in the Prelude
15:01:20 <jmcarthur> being in the spec doesn't make something more pure
15:01:47 <koeien> if it's somewhere hidden in Data.IntWithAnUnspecifiedSize, ok
15:02:10 <jmcarthur> if we had a dependently typed language we could grab the native machine int size in IO and then use it in our types
15:02:11 <tolkad> jmcarthur: by redefining precisely what constitutes a haskell program, we can bypass questions of purity
15:02:11 <danharaj> Data.Int, actually
15:02:29 <jmcarthur> tolkad: i disagree. purity isn't defined by a spec. its definition exists outside of haskell
15:02:52 <jmcarthur> tolkad: redefining purity isn't something i see as an ideal solution
15:03:03 <tolkad> jmcarthur: we aren't redefining purity, we are redefining "haskell program"
15:03:21 <jmcarthur> tolkad: seems rather hand-wavy
15:03:42 <tolkad> jmcarthur: all good things do
15:03:58 <jmcarthur> i mean, i see what you mean, but your proposal basically says that you can't write a program with defined behavior
15:04:21 <dolio> Int is easier to explain than 'args :: [String]' would be.
15:04:30 <tolkad> jmcarthur: no, but you can describe an infinite number of programs with constrained behavior
15:04:39 <jmcarthur> dolio: System.Info is already very hard to explain
15:04:51 <dolio> It does screw you if you want to build distributed programs, though.
15:05:00 <jmcarthur> tolkad: i don't think i would find that very useful
15:05:18 <jmcarthur> it's rather fix it, not better explain existing (IMO flawed) behavior
15:05:32 <dolio> I doubt System.Info is harder to explain than Int.
15:05:59 <jmcarthur> i find them both pretty hard to explain
15:06:39 <jmcarthur> what is the meaning of (2147483648 :: Int) in my haskell program?
15:06:41 <dolio> Int is definable entirely in Haskell.
15:06:46 <tolkad> Everyone complains about Int while behind the scenes Word continues its insidious work
15:06:54 * geheimdienst notices the stuff in System.Info is Strings, not IO Strings
15:06:56 <jmcarthur> tolkad: i complained about Word above
15:07:06 <jmcarthur> geheimdienst: exactly!
15:07:27 <tolkad> geheimdienst: so you agree with my semantic manipulation solution?
15:07:37 <dolio> When you're building with 32-bit GHC, there's a line in the Prelude that says, "type Int = Int32."
15:07:55 <dolio> When you're building with 64-bit GHC, it's a different library, with "type Int = Int64."
15:08:11 <jmcarthur> dolio: System.Info is still harder to explain than Int because it depends on the machine the program is running on, not the machine it was built on
15:08:18 <tolkad> dolio: oh well let's just upload ghc's source code and stick it in the haskell standard
15:08:27 <dolio> Yeah, I guess os is bad.
15:08:41 <ezyang> jmcarthur: Though, in practice, executables are run on the same machine they were built on, or at the very least, same distro.
15:08:42 <BMeph> Does anyone know off-hand, of any blog responses to Rob Harper's "The Point of Laziness"?
15:08:53 <jmcarthur> i disagree with the idea of the program's meaning depending on the compiler you build it with
15:08:59 <dolio> tolkad: Why would we need to do that?
15:09:00 <jmcarthur> ezyang: usually
15:09:09 <dolio> Every haskell compiler comes with its own implementation of the prelude.
15:09:20 <geheimdienst> i think we can all mentally prefix "unsafe" to the stuff in System.Info
15:09:27 <dolio> And it decides which implementation your code is linked against.
15:09:34 <jmcarthur> geheimdienst: many people don't
15:09:37 <ezyang> Anyway, I do agree that there is a useful distinction that could be made here.
15:09:40 <tolkad> dolio: I was pointing out that the fact that Int is equivalent to Int32/Int64 is only relevant to ghc haskell. It doesn't have to be
15:09:52 <dolio> I didn't say it was.
15:10:04 <dolio> Other compilers might have 'type Int = Int30'.
15:10:04 <ezyang> And that Haskell doesn't do as much to help out here isn't ideal, although it seems to work out OK in practice.
15:10:14 <dolio> Or whatever.
15:10:44 <tolkad> dolio: well we weren't talking about GHC haskell, I don't see how some obscure implementation of haskell is relevant to haskell semantics in any way
15:11:07 <dolio> I wasn't talking about GHC Haskell either.
15:11:37 <tolkad> <dolio> Int is definable entirely in Haskell.
15:11:37 <tolkad> <dolio> When you're building with 32-bit GHC
15:11:43 <ezyang> It's a big deal with lots of functional languages, which specify you're only guaranteed X bits of precision, and the main implementation offers 31-bits or something (due to GC tagging) but...
15:11:44 <jmcarthur> dolio's argument is that Int's semantics is at least determined at compile time rather than run time
15:11:51 * BMeph runs ghci on a 64-bit Win7 OS machine, but GHC was compiled as 32-bit.
15:12:05 <tolkad> jmcarthur: not necessarily in all implementations of haskell
15:12:09 <dolio> tolkad: type aliases are part of the Haskell language specification, last I checked.
15:12:19 <danharaj> Well good thing there's only 2 implementations of Haskell anyone cares about.
15:12:19 <koeien> what if there is some intermediate format, and we run on a VM or something?
15:12:35 <jmcarthur> tolkad: sure about that? if you're right, i hate it even more
15:12:45 <tolkad> dolio: oh, I misunderstood you
15:13:19 <koeien> then the Num instance of Int might differ from invocation to invocation.
15:14:26 <tolkad> jmcarthur: I just assumed so, does the specification make any distinction between compile-time and runtime? I thought it only described the semantics of haskell at execution time
15:15:05 * jmcarthur shrugs
15:15:10 <tolkad> jmcarthur: I mean if you're using an interpreter then a compile time doesn't even exist
15:15:35 <jmcarthur> there is still a type checking phase, which i think suffices as "compile time"
15:16:30 <tolkad> jmcarthur: but the specification doesn't say that a haskell implementation can't do the type checking phase every time you run the program
15:16:54 <danharaj> In that case you are not defining a single program, you're defining a family of programs.
15:17:26 <tolkad> danharaj: that's exactly what I was saying, the haskell standard should just state that explicitly and banish all questions of purity
15:17:35 <jmcarthur> ugh
15:17:37 <danharaj> what is purity?
15:17:42 <tolkad> Thats right, not just prevent them, completely banish them
15:17:51 <Phyx-> danharaj: ask the jonas brothers
15:17:54 <dolio> The specification doesn't say your program can't be rebuilt against a version of the prelude with a different 'type Int = ...' every time it's run.
15:18:02 <jmcarthur> i really hate that idea. it's just refusing to define the behavior of a program at all
15:18:35 <jmcarthur> yes, tolkad and dolio are right about this notion of "compile time" i was imposing on the language
15:21:54 <jmcarthur> okay, i'm overstating my complaints about tolkad's idea. it's not refusing to define the behavior of a program *at all*, it's just refusing to be specific. it's hard for me to accept the purity of a language without a concrete meaning for a given expression in the first place.
15:22:12 <jmcarthur> instead it has to be some notion of purity assigned to the language's runtime
15:22:54 <ddarius> jmcarthur: It's explicitly refusing to define the behavior of -some- programs.
15:23:24 <koeien> but that also depends on (e.g.) the amount of memory a program has available
15:24:43 <Saizan> yeah, for Int you perfectly know the meaning of your program given just the report if you stick to given range
15:25:20 <jmcarthur> sure, as long as i'm using runtime checks...
15:25:30 <jmcarthur> oh
15:25:33 <jmcarthur> well i could just assume 30 bits
15:25:40 <ddarius> Yes.
15:25:41 <jmcarthur> *no less than 30 bits
15:26:37 <dolio> Well, you can always cheat a little if modules are in the picture.
15:27:19 <dolio> When you observe a different value for os between runs, you were actually running two different pure programs.
15:27:23 <dolio> Not one impure program.
15:27:42 <jmcarthur> -fexcess-precision is a troubling flag to me for similar reasons, but at least in the case of floating point i don't make very serious attempts to make it make much sense in the first place
15:27:59 <dolio> Your code was linked against two different libraries to produce the two different programs.
15:28:42 <dolio> There are situations where you can't make that excuse, though.
15:28:46 <jmcarthur> yeah this goes back to my argument about IPC or distributed computing, but i'd like to avoid circling back around to that
15:29:03 <dolio> When your observe different values for the same expression within a single run of the program.
15:29:27 <dolio> Yeah, it's not acceptable in that scenario.
15:33:49 <rostayob> ok, I'm generating haddoc docs and sometime a function/data type declaration doesn't get rendered.
15:34:21 <rostayob> it doesn't produce any error
15:39:10 <filcab> hi all!
15:39:30 <filcab> I'm having problems limiting my memory usage in Haskell
15:39:44 <filcab> I have a simple program that loops over an sqlite3 database
15:39:46 <filcab> I have this: https://gist.github.com/950001
15:40:15 <filcab> doRow iterates and it seems to me that the memory that's being used only depends on
15:40:15 <filcab>          the maximum number of words in a song
15:40:32 <filcab> any clues on what I can do to find out why so much memory is being used?
15:40:35 <applicative> rostayob, do you export them?
15:41:33 <Saizan> type RowState = !(Int, Int, String, TrackWords) <- the bang here doesn't do anything, i'm pretty sure
15:41:38 <tolkad> filcab: could you show us the code that does the iteration?
15:41:56 <filcab> it's on the gist: https://gist.github.com/950001
15:41:56 <filcab> oh
15:42:01 <filcab> wait, sorry
15:42:25 * hackagebot mutable-iter 0.6.1 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.6.1 (JohnLato)
15:43:29 <ezyang> Does anyone have an example of -fexcess-precision changing the value of a floating point expression?
15:43:34 <Saizan> doRow stmt st@(!_,!_,!_,!_) = .. should help
15:43:44 <filcab> here: https://gist.github.com/950001#comments
15:43:57 <Saizan> let (!newStN,!newTw) = ... also
15:44:07 <jmcarthur> ezyang: that's a great question
15:44:13 * jmcarthur makes an attempt
15:44:17 <filcab> hmm, nice
15:44:21 <filcab> I'll try that :)
15:44:34 <Saizan> you need {-# LANGUAGE BangPatterns #-}
15:44:38 <koeien> filcab: probably excessive laziness in the newStN and newTw
15:44:49 <koeien> and the (stRows st + 1)
15:46:00 <rostayob> applicative: ok, I found out why, i use the hsx preprocessor...
15:46:01 <filcab> how can I force strictness in that expression? something like (newStN, !(stRows st + 1), ...) ?
15:46:07 <rostayob> basically it inserts all the line numbers pragma
15:46:37 <jmcarthur> ezyang: would ghci be affected by -fexcess-precision?
15:46:56 <dolio> I suspect not.
15:47:04 <koeien> filcab: let !newStRows = stRows st + 1
15:47:15 <filcab> oh, right... easier :-P
15:47:37 <koeien> filcab: it might be easier to do data RowState = RowState { stN :: ! Int, ... } though
15:47:58 <scree> > let !blah = undefined in 0
15:47:58 <filcab> ok, I can try that too
15:47:58 <lambdabot>   *Exception: Prelude.undefined
15:48:02 <ezyang> jmcarthur: Unclear. I'm not really sure how GHCI does floating point.
15:48:09 <ezyang> Looking it up...
15:48:18 <Saizan> yeah, a custom record type with strict fields would be better, then you just need "return $! RowState ..."
15:48:54 <scree> interesting
15:50:08 <ezyang> No.
15:54:13 <applicative> filcab you should have a type with strict fields, not a tuple, I think.
15:54:35 <filcab> I'm changing it now... let's see if it works
15:54:52 <applicative> filcab, have you seen the helpfully lucid discussion in http://blog.johantibell.com/2010/09/slides-from-my-high-performance-haskell.html
15:55:35 <applicative> e.g. slide 35 and thereabouts
15:55:40 <filcab> thanks
15:59:14 <filcab> yaaay, it worked
15:59:20 <filcab> the small sums were killing it
15:59:47 <filcab> from 1000 rows to 100000 rows the max bytes residency changed from 50KB to 60KB
15:59:57 <filcab> it would climb by several megs
16:00:01 <filcab> Thank you very much
16:00:05 <jmcarthur> ezyang: i'm thinking -fexcess-precision might actually not do anything on x86_64, since (iirc) SSE must be used for floating point on x86_64
16:00:21 <filcab> remember: optimize and don't forget strictness when it's needed
16:00:22 <ezyang> hmm, I think I could believe that.
16:01:02 <jmcarthur> if you have access to a 32 bit machine i could paste what i was trying before i decided to research it online a little bit
16:01:13 <ezyang> sure.
16:01:39 <jmcarthur> i read that 3/7 has a different value in excess precision vs. double precision, so i was trying to compare 3/7 computed at runtime with 3/7 computed at compile time
16:02:57 <ezyang> What kind of floats were you testing with?
16:03:11 <jmcarthur> ezyang: http://hpaste.org/46201/attempt_to_break_fexcessprec
16:03:22 <jmcarthur> i tried with both floats and doubles
16:03:50 <jmcarthur> anyway, i was passing 3 7 to the program, obviously
16:03:53 <ezyang> Nope, doesn't work.
16:04:06 <jmcarthur> doesn't work as in it does work?
16:04:22 <ezyang> as in, True for -fexcess-precision and without.
16:04:23 <jmcarthur> built with optimizations and stuff?
16:04:40 <jmcarthur> s/and stuff//
16:04:44 <ezyang> ooh, there we go.
16:04:56 <ezyang> It goes false when built with optimizations.
16:05:02 <jmcarthur> yay! :(
16:05:07 <ezyang> but it's invariant of -fexcess-precision.
16:05:11 <jmcarthur> huh
16:05:13 <ezyang> strangely enough.
16:05:16 <jmcarthur> *that's* bad
16:05:23 <jmcarthur> -O or -O2?
16:05:35 <ezyang> let's try with a more recent GHC.
16:05:36 <ezyang> either.
16:06:03 <ezyang> nope, no dice.
16:06:24 <jmcarthur> so it's a fixed bug at least?
16:06:59 <ezyang> as in, it's still reporting False with -fexcess-precision on GHC HEAD.
16:07:04 <jmcarthur> not that you should be checking floats for equality anyway
16:07:08 <jmcarthur> oh yuck :(
16:07:33 <jmcarthur> oh, only with -fexcess-precision though?
16:07:53 <ezyang> -fexcess-precision doesn't seem to make a difference.
16:07:57 <jmcarthur> :\
16:08:22 <jmcarthur> there's something else to add to my blog post on fixed-point then
16:09:07 <jmcarthur> but i'd still say this sounds more like a bug than an inherent issue
16:09:13 <ezyang> ...wwwwhat?
16:09:22 <ezyang> ghc Bar.hs -fexcess-precision -fforce-recomp -O -fvia-C && ./a.out  3 7 >>> False
16:09:33 <ezyang> ghc Bar.hs  -fforce-recomp -O -fvia-C && ./a.out  3 7 >>> True
16:09:38 <ezyang> oh wait, no, that's expected.
16:09:44 <jmcarthur> yeah that's what we want
16:10:00 <jmcarthur> so the C backend does it right
16:10:16 <ezyang> I seem to have been confused.
16:10:38 <jmcarthur> ah
16:10:48 <ezyang> But the results are the same.
16:11:03 <ezyang> Amusingly, LLVM gets true for for with and without fexcess-precision.
16:11:14 <jmcarthur> wow, so all three backends are different here
16:11:56 <ezyang> Which makes sense, if you think about it.
16:12:13 <ezyang> My cursory grep for ExcessPrecision in the source code, I only saw it being passed as an arg to GCC.
16:12:19 <jmcarthur> ah
16:12:30 <ezyang> So I suspect the native backend doesn't actually implement excess precision.
16:12:39 <ezyang> But still, the optimization thingy seems a bit weird. I think I'll file a bug there.
16:12:43 <jmcarthur> then it should be returning True
16:12:48 <ezyang> Agreed.
16:13:05 <jmcarthur> cool. thanks for filing the bug
16:18:32 <ezyang> OK, I'm more confused.
16:18:44 <ezyang> When I pass -fexcess-precision to GCC, does that mean standard or fast?
16:19:38 <jmcarthur> ezyang: there's more than one kind of excess precision?
16:20:21 <ezyang> I believe -fexcess-precision=fast means "use the excess precision and don't bother with the spec"
16:23:09 <ezyang> Bleh, more confused.
16:23:20 <ezyang> it looks like my build of GHC is unhappy, but my distro's build is OK.
16:23:22 <jmcarthur> i think it depends on the C version that's used
16:23:33 <jmcarthur> wha-?
16:23:51 <jmcarthur> the native code gen?
16:23:55 <ezyang> yeah.
16:23:59 <jmcarthur> wtf
16:24:15 <ezyang> I bet the optimizer runs the floating point op in GHC itself or something? That's not really consistent though...
16:24:31 <jmcarthur> it wouldn't matter
16:24:45 <jmcarthur> because it has to write it out to the binary and cut out the precision
16:24:51 <ezyang> Either that or it's a regression from 6.12
16:25:06 <ezyang> Time to grab a blessed 7.03...
16:25:31 <jmcarthur> actually, if it runs it in the optimizer then i could foresee some issues with that too
16:25:44 <jmcarthur> depends on if ghc runs with extended precision or not
16:26:03 <jmcarthur> but this particular example would not be affected by that i'm pretty sure
16:26:40 <ezyang> Why not? If GHC sees a 7 and a 3 and thinks it can fold it, it will...
16:27:25 <jmcarthur> right
16:27:30 <jmcarthur> but it has to write the result back out
16:27:35 <ezyang> So the constant folded value should be IEEE precision.
16:27:37 <ezyang> ah, I see.
16:27:45 <ezyang> Actually, I don't, but I believe you :-)
16:27:59 <filcab> Well
16:28:01 <filcab> I'm going
16:28:04 <filcab> see you
16:28:07 <filcab> and many thanks :-)
16:28:09 <filcab> bye
16:28:15 <Saizan> bye
16:28:30 <jmcarthur> it would only be different with a more complex expression where the result converted to double precision will be different from if the entire thing has been computed with double precision
16:28:56 <ezyang> curioser and curioser.
16:29:09 <ezyang> I don't know very much about double-precision representation, so I can't really comment there.
16:29:45 <jmcarthur> double precision is just Double. -fexcess-precision just enables 80-bit representations that can be used until it has to be written out to memory
16:30:26 <ezyang> Ok, looks like this is a regression.
16:42:10 <tolkad> isn't there a fucntion that modifies float behavior?
16:42:16 <tolkad> function*
16:42:37 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/5165
16:42:59 <tolkad> no, not a pragma, a function
16:43:13 <ezyang> erm, sorry, I didn't see your question.
16:43:20 <ezyang> ^ jmcarthur: bug I filed.
16:43:22 <tolkad> oh
16:43:43 <dolio> I'm not sure the IEEE rounding mode similar stuff is exposed anywhere.
16:43:58 <dolio> You could write FFI bindings and whatnot, though.
16:45:06 <tolkad> dolio: I wanted to use it to pass messages between pure code
16:45:23 <dolio> Well, it wouldn't be a pure function anyway.
16:45:32 <dolio> So you'd probably be out of luck.
16:45:50 <dolio> You could use it to pass information from IO into pure functions, though.
16:45:51 <tolkad> dolio: well I could at least pass a message from nonpure code to pure code
16:45:57 <tolkad> yeah it would have been glorious
16:49:32 <ezyang> I'm kind of thinking it's not actually reasonable to have a distributed system running on a cluster that is heterogenous on int-size (32-bit or 64-bit)
16:50:00 <copumpkin> why not?
16:50:22 <ezyang> it just seems like a really bad idea, no matter what language you program in.
16:50:31 <geheimdienst> ezyang: if you're getting divergent results, just average them out
16:50:47 <copumpkin> if the language doesn't have any constructs that are aware of the machine word size, I don't see what the problem is
16:50:57 <copumpkin> i.e., just drop Int and Word
16:51:19 <ezyang> yeah, but does any real language do that?
16:51:27 <copumpkin> no, but it should
16:51:31 <copumpkin> haskell should
16:51:32 <copumpkin> fuck Int
16:51:55 * copumpkin is an anti-Int fundamentalist
16:52:21 <ddarius> SML
16:54:08 <hpc> there is some advantage to being able to say "this is a natively sized int/word"
16:54:15 <hpc> ideally, most code uses Integer
16:55:07 <tolkad> hpc: isn't the native code gen able to do optimizations with natively sized types than Integers?
16:55:17 <tolkad> more optimizations*
16:55:59 <copumpkin> so, use WordN or IntN if you want that
16:56:25 <copumpkin> or make it clear that Int and Word are machine-dependent
16:56:33 <copumpkin> and relegate them to special purpose high-performance code
16:56:59 <monochrom> restrict the use of Int to IO code
16:57:08 <hpc> lol
16:57:18 <hpc> restrict all computation to IO
16:57:22 <copumpkin> UnsafeInt
16:57:23 <copumpkin> UnsafeWord
16:57:42 <hpc> then add some convenient constructs that break referential transparency in subtle ways
16:57:45 <tolkad> copumpkin: I have never heard of WordN/IntN, I can't find them here: http://www.haskell.org/onlinereport/prelude-index.html
16:57:54 <copumpkin> Data.Int, Data.Word
16:57:56 <hpc> we will be forced to turn everything into a pointer to a value
16:57:56 <copumpkin> :k Word16
16:57:57 <lambdabot> *
16:58:00 <hpc> and suddenly... java
16:58:00 <copumpkin> :k Word64
16:58:01 <lambdabot> *
16:58:16 <tolkad> copumpkin: oh, you mean those
16:58:19 <copumpkin> hpc: everything already is
16:58:23 <hpc> :P
16:58:30 <copumpkin> Int is boxed
16:58:32 <copumpkin> it's a pointer
16:58:36 <copumpkin> Int# is not
16:58:47 <hpc> on a related note, right as i finished, my music player got to the chorus of In The Glass
16:59:01 <hpc> (it goes "what have i done, what have i done?" for a minute and a half)
16:59:03 <tolkad> copumpkin: are WordN/IntN portable between all potential haskell implementations? I don't seem them in the standard
16:59:10 <copumpkin> tolkad: fuck the standard :P
16:59:18 <copumpkin> but in practice, I think most things support them
16:59:36 <monochrom> not in the standard, as you have noticed from the haskell report
17:00:21 <hpc> the report is kind of dated
17:00:27 <hpc> hell, it was dated when it went online
17:00:30 <hpc> in 2002
17:00:34 <monochrom> and there is still no Word4, for those of us who still use 4004-based calculators
17:00:44 <hpc> there's a Word1
17:00:49 <hpc> but no Int1 :/
17:00:56 <copumpkin> hpc: there is?
17:00:57 <tolkad> What really _makes_ a language is the standard, the various implementations that crop up are just a fad
17:01:03 <hpc> copumpkin: it's called Bool :D
17:01:10 <copumpkin> tolkad: what really makes a language is how most people use it
17:01:36 <copumpkin> hpc: how is Int1 observably different from Word1?
17:01:41 <tolkad> copumpkin: those people eventually die, to be replaced by new more enlightened people who truly believe in standards
17:01:42 <copumpkin> -1 and 0 vs 0 and 1?
17:01:49 <hpc> hehe
17:02:38 <monochrom> I still haven't seen new cobol or fortran programmers who truly believe in standards
17:03:18 <dolio> hpc: The advantage is that natively-sized ints/words are fast, and other sizes are less so.
17:03:29 <copumpkin> UnsafeFastInt
17:03:31 <hpc> dolio: i am aware :P
17:03:32 <copumpkin> UnsafeFastWord
17:03:38 <dolio> And Integer is less fast than those, probably.
17:03:56 <copumpkin> length :: [a] -> Integer (or even better, Natural) could be made almost as fast though
17:04:00 <hpc> what i mean is, code that needs predictable behavior should use Integer, and code that can afford to say "the hell with it, use Int" can do so
17:04:08 <copumpkin> you could increment native ints up until they get fairly large
17:04:15 <copumpkin> then add those periodically to an Integer accumulator
17:04:22 <hpc> but people are doing the latter to much
17:04:29 <hpc> too much, when they don't need to
17:04:39 <ezyang> I don't trust the person to be able to figure that out.
17:04:43 <dolio> It's unfortunate that Int is baked into the prelude so much.
17:04:52 <copumpkin> yeah
17:05:15 * geheimdienst wishes the safe, clean, nice thing would have the short name and the ugly, stinky thing the long
17:05:54 <monochrom> oh, like MSWord being the ulgy, stinky thing
17:06:06 <hpc> s/Integer/Int/ , s/Int/MachineInt/ ?
17:06:11 <monochrom> (which stands for machine-sized word)
17:06:20 <tolkad> Without a standard you are lost, adrift in a sea of unspecified semantics. Hold fast to the rules of the specification lest you be consumed by ambiguity.
17:07:38 <hpc> @remember tolkad Without a standard you are lost, adrift in a sea of unspecified semantics. Hold fast to the rules of the specification lest you be consumed by ambiguity.
17:07:38 <lambdabot> It is stored.
17:08:06 <drhodes> I'm glad to report progress on getting haskell running on android, the logo: http://i.imgur.com/eLDXB.jpg
17:08:37 <drhodes> that's it just the logo, the rest should be easy
17:08:48 <monochrom> you should attach a soundtrack to it.
17:09:08 <drhodes> yes, maybe the one from duke nukem 3d
17:09:10 <monochrom> the soundtrack should say in a machine voice, "exterminate all humans"
17:09:36 <jmcarthur> a non-ambiguous standard helps
17:10:40 <blbrown_win3> I was writing a blog entry,"iinsertionSort' [] lst = lst"   with a statement line like this.  Would you call this just a statement?  a fact?
17:10:55 <monochrom> an equation
17:11:02 <blbrown_win3> OK
17:11:35 <tolkad> blbrown_win3: also a declaration
17:11:40 <ddarius> @where report
17:11:40 <lambdabot> http://www.haskell.org/onlinereport/
17:11:52 <blbrown_win3> tolkad, I think I like declaration
17:11:57 <blbrown_win3> tolkad, I think I like declaration statement?
17:12:02 <hpc> i would call it one pattern in a definition
17:12:11 <tolkad> blbrown_win3: in template haskell it's called a declaration
17:13:00 <ddarius> In the report, it is a specific form of declaration syntactically.
17:13:01 <monochrom> "free _ = True" declaration of indepedence
17:13:24 <jmcarthur> lol
17:13:31 <ddarius> Free from the tyranny of feet.
17:14:14 <hpc> who needs feet when you have a head and a tail
17:14:24 <hpc> if you are really lucky, instead of a head, you have a car
17:14:24 <blbrown_win3> free of side effects
17:14:33 <hpc> :P
17:14:54 <monochrom> "card (x:xs) = 1 + card xs" Magnus Carda
17:15:26 <hpc> (did nobody catch the lisp pun?)
17:16:02 <blbrown_win3> (cdr ())
17:16:10 <monochrom> "cdr (x:xs) = xs" Magnus Cdr
17:22:03 <Sagi> I'm calculating routes between nodes and would like to try some parallelism: The best spot seems to be "getBestRoutes <$> fs <*> gs", because all calls to getBestRoutes can take place in parallel. How would I use par in this context?
17:22:30 <Sagi> getBestRoutes basically tries to connect f with g
17:28:16 <NemesisD> i'm getting a weird type error with network URI. Simplified code: http://hpaste.org/46204/which_uri
17:29:18 <monochrom> you have two versions of "network"
17:29:32 <NemesisD> in cabal?
17:29:43 <monochrom> in the packages you have installed
17:29:49 <NemesisD> oh you mean Network and Network.URI?
17:29:55 <monochrom> no, packages
17:31:34 <NemesisD> so i have 2 versions of the package "network"? cabal list --installed network seems to only show 1
17:31:55 <Sagi> nvm, found http://stackoverflow.com/questions/5606165/parallel-map-in-haskell
17:32:57 <monochrom> I have never used cabal list. I cannot confirm or deny that it lies.
17:33:09 <monochrom> "ghc-pkg list network" is what I use and trust.
17:33:45 <monochrom> if that shows two networks, then it confirms that cabal list lies
17:35:07 <monochrom> a likely scenerio is that initially you had one version of network, then you built HTTP against it, then you added a new version of network
17:35:44 <monochrom> so now you have two data types both called "URI" and they are incompatible because they come from different networks
17:36:05 <monochrom> HTTP was built against the old one, so it wants the old one
17:36:23 <deteego> does anyone here by any chance use yesod?
17:36:28 <monochrom> "import Network.URI" by default refers to the new one
17:36:59 <NemesisD> oh boo, removing either one breaks packages
17:37:09 <monochrom> remove all new packages
17:37:27 <monochrom> and learn not to be a promiscuous upgrade whore again
17:38:15 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml for more ways to get into trouble by installing more packages
17:39:07 <monochrom> so indeed you have confirmed that "cabal list" lies
17:40:46 <monochrom> (and also how much cabal doesn't know)
17:44:59 <Saizan> it lists both versions here
17:45:24 <Saizan> maybe it got fixed in a later cabal, or the bug is more subtle than that
17:52:17 <NemesisD> anyone have any suggestions for http clients that support HTTPS?
17:52:33 <NemesisD> Network.HTTP seems to not implement https
17:52:56 <koeien> NemesisD: openssl s_client perhaps ?
17:54:14 <NemesisD> koeien: is that HsOpenSSL?
17:54:40 <dons> curl works
17:54:51 <koeien> NemesisD: no, that is just a command-line tool you can use to connect to ssl clients. you can then talk to this client using stdin/out
17:55:06 <NemesisD> koeien: oh, gross.
17:55:20 <NemesisD> i meant libraries, i think i misused the term client
17:56:18 <koeien> then check out curl as dons said
17:57:21 <NemesisD> man Sigbjorn Finne seems to have written practically every library that deals with the internets in haskell
18:31:09 <Guest18764> hi there!
18:31:33 <Guest18764> anybody in the room to talk
18:31:41 <djahandarie> About 727 people.
18:32:45 <djahandarie> You can use  /nick somenick  to fix your nickname, by the way. It's best to use a unique one, otherwise you'll get it switched away automatically (like just happened).
18:33:06 <Guest18764> oh. let me....
18:33:32 <carrom> I may be seen with new name
18:33:41 <carrom> hurray!!
18:33:46 <djahandarie> :) Do you have any questions?
18:34:39 <carrom> I'm a programmer, working mostly in oop environment
18:34:47 <KirinDave> Hum
18:35:00 <KirinDave> I'm trying to write the type signature String -> IO Map Int MyThing
18:35:07 <carrom> and there is a  how honestly follow it
18:35:08 <koeien> IO (Map Int MyThing)
18:35:11 <KirinDave> Ahh
18:35:15 <djahandarie> KirinDave, you probably want IO (Map Int MyThing)
18:35:17 <djahandarie> Oops, beat to it.
18:35:25 <KirinDave> Ahh,there
18:35:28 <KirinDave> Werid
18:35:37 <KirinDave> It seemed to hate that earlier. Must have been unrelated.
18:36:16 <koeien> if you use Map Int MyThing all over the place, you can make a type synonym (type MyMap = Map Int MyThing) as well.
18:38:13 <aristid> or even use IntMap
18:38:16 <aristid> which is faster
18:38:40 <carrom> I mean, I'm not getting all this functional stuff
18:39:29 <carrom> how it is different than oops and does it really make difference to the end users if I write functonal software
18:40:46 <djahandarie> In particular, Haskell is purely functional, which means you get a lot of neat things for free. For example, parallelizing your program tends to be far easier compared to other types of languages.
18:40:48 <luite> to the end user probably not, unless they notice that all your software is suddenly bug-free and works perfectly from the first version ;)
18:41:24 <djahandarie> But yeah, functional programming is mainly to make life easier on you, not for the user (except by extension). :p
18:41:46 <carrom> dj, what do you mean by things for free?
18:42:29 <KirinDave> aristid: Advice taken. Yay for import qualified
18:42:29 <carrom> Luite, do you mean, if I write programs in functional language they inherently bug free?
18:42:55 <djahandarie> I mean that doing certain tasks becomes a lot easier due to properties of your program. This is fairly abstract though, do you have any field you're particularly interested in?
18:43:06 <aristid> KirinDave: yeah, import qualified X as Y is how you should import most things that are not in base
18:43:19 <luite> carrom: not inherently, but haskell's type system combined with the purity makes some types of bugs impossible (or at least difficult)
18:43:38 <carrom> dj, I'm web developer. did you mean to ask that?
18:44:12 <carrom> @luite, that's great!
18:44:13 <lambdabot> Unknown command, try @list
18:44:13 <KirinDave> carrom: Also, Haskell makes it easy for you to track functions with side effects. This is a surprisingly powerful technique.
18:44:19 <djahandarie> Sure. There are a couple web frameworks in Haskell. They're damn fast, and some also give you compile-time protection against a lot of bugs.
18:44:34 <aristid> you can even have side effects that are not in functions.
18:45:13 <Kaidelong> MonadRandom is a good way to understand why it is useful to know what things are "side effecting"
18:45:14 <carrom> side effects?
18:45:33 <Kaidelong> since it allowsw you to distinguish an integer (like 5) from a random integer
18:45:56 <aristid> Kaidelong: i like random-fu's RVar
18:45:58 <Kaidelong> and illustrates that the two are entirely different things
18:46:11 <aristid> Kaidelong: where you can have random variables with different distributions
18:46:23 <Kaidelong> I think it is less obvious that an IO Int is something entirely different from an Int
18:46:38 <carrom> you guys rock!
18:46:53 <carrom> I'm trying at tryhaskell.org
18:46:59 <sshc> Bitcoin's worth ~4USD now!
18:47:08 <KirinDave> carrom: Yeah.
18:47:08 <sshc> (Thought #haskell should know)
18:47:22 <Kaidelong> random-fu is a fun name for a package
18:47:25 <luite> carrom: haskell does behave quite different than you might expect, especially evaluation, and reasoning about its performance is quite difficult if you are used to languages like php or java. so while djahandarie says that the web frameworks are quite fast (they are), you can easily screw up and make something very slow
18:47:41 <KirinDave> carrom: Functions in Haskell can't affect the context outside their local scope, and once they pass a value bac it's totally out of their hands.
18:48:24 <carrom> @luite, do we have best practices documented anywhere?
18:48:24 <lambdabot> Unknown command, try @list
18:48:33 <Kaidelong> I seem to recall a phrase "LISP is as fast as C. It is also easy to write slow LISP"
18:49:03 <luite> carrom: try this for the basics: http://www.learnyouahaskell.com/ , it's best to install your own haskell compiler, the book will explain how
18:49:04 <carrom> kaide: ha ha :)
18:49:12 <aristid> the funny thing about haskell is, it exists for a long time
18:49:25 <aristid> but the community is basically very young, and best practises are still being formed
18:49:28 <carrom> luite: thanks a ton, buddy!
18:50:25 <carrom> aristid: should that make me procrstinate my voyage on web development with haskell?
18:50:33 <KirinDave> carrom: Yes.
18:50:41 <KirinDave> carrom: Just until you get through the chapter on monads.
18:51:08 <carrom> I heard that guys at silkapp are using it.
18:51:15 <KirinDave> So they say.
18:51:23 <carrom> was just curious if anyboy from them is here
18:51:27 <aristid> somehow it's weird that they posted it in 2009
18:51:32 <carrom> and want share some of the insights
18:51:32 <aristid> and it's still in closed alpha
18:51:52 <carrom> oh.. means they are taking time...
18:52:13 <aristid> carrom: i made a small web thing in haskell in less than a day :)
18:52:19 <carrom> is because of development choice or they have other research reasons
18:52:23 <aristid> (admittedly it was really really trivial)
18:52:31 <carrom> ohk
18:52:46 <luite> carrom: once you have the basics down, you can move on to http://book.realworldhaskell.org/ , which has some info about optimizing for performance. and one of the well known web frameworks is http://snapframework.com/
18:52:52 <carrom> aristid, would you like to share
18:53:10 <KirinDave> aristid: Yessss. You should share.
18:53:10 <carrom> luite, you are to the point. thanks
18:53:12 <aristid> carrom: no, it'd be a bit embarrassing :D
18:53:12 <luite> carrom: but start slowly with learn you a haskell, and experiment a lot.
18:53:21 <Kaidelong> haskell is a different way of thinking
18:53:32 <Kaidelong> and there is no escape from it
18:53:35 <carrom> aristid:we learn new things like this only :D
18:53:49 <Kaidelong> once you go back to some other language because you have to you end up seeing haskell in there and re-implementing much of it
18:53:50 <KirinDave> carrom: I am in the same boat, learning Haskell. LYAH is the ONLY good explanation of Applicative Functors and Monads I've found. So it's a very, very valuable resource.
18:53:52 <carrom> Kaidelong: agreed
18:53:52 <aristid> well ok it's up again: http://breitkreuz.me:3000/
18:53:53 <ddarius> luite: Understanding the performance of Haskell isn't that hard, but certainly if you put no effort into understanding it and blindly apply techniques for other languages you will get poor performance and be mystified.
18:54:01 <aristid> KirinDave: but don't say it's too trivial :P
18:54:06 <aristid> also it's german only
18:54:08 <KirinDave> aristid: Me?
18:54:29 <KirinDave> aristid: You know me. I only make fun of people who don't write code, but tell you how to write it. )
18:54:30 <luite> ddarius: yes that's exactly what I meant to say
18:54:33 <Kaidelong> KirinDave: I think the types are a great explanation
18:54:39 <Kaidelong> @ty (<*>)
18:54:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:54:48 <KirinDave> Kaidelong: I needed more hand-holding.
18:55:19 <Kaidelong> applicative functors are actually one of the easier things to pick up
18:55:28 <Kaidelong> since function application is already familiar
18:55:31 <aristid> carrom: i wrote this for my brother who needed to create some bingo cards
18:55:37 <carrom> aristid: was off to see you app. well tried
18:56:26 <KirinDave> Kaidelong: I agree.
18:56:40 <KirinDave> Kaidelong: I originally tried to read the paper that introduced applicative.
18:56:50 <carrom> Kirindave: as we are same boat, can we keep in touch.
18:57:04 <carrom> off course #haskell is always there
18:57:05 <aristid> carrom: how about just hanging out in #haskell? :)
18:57:11 <carrom> yes
18:57:14 <KirinDave> Yeah it's not like I am not here. :)
18:57:33 <carrom> Kirin, aristid: thanks:)
18:58:07 <aristid> carrom: do you want to see the code for my web app?
18:58:18 <luite> aristid: aw why do you have to input all numbers first? that makes it more difficult to generate a 3000x3000 bingo card
18:58:28 <carrom> it seems effective members are 5/720 only
18:58:29 <carrom> :(
18:59:00 <aristid> luite: because the use case was for a list of rooms. rooms sometimes have weird room numbers like 23a
18:59:15 <aristid> carrom: here's the code https://github.com/aristidb/zimmerbingo/blob/master/zimmerbingo.hs
19:00:47 <carrom> aristid: oh. thanx
19:01:08 <carrom> aristid: why are passing all you parameters through url
19:01:32 <aristid> carrom: why not?
19:01:33 <carrom> aristid: a'nt you use post parameters
19:01:50 <carrom> url becomes to long and ugly
19:02:00 <aristid> but you can share the url
19:02:11 <aristid> and people get the same layout for the url
19:02:49 <carrom> hmm for that reason.. you can mention - range
19:03:10 <aristid> well no, because you don't actually always have a clean range
19:03:12 <carrom> not all number in the range,  am i right?
19:03:18 <aristid> sometimes room numbers are letters
19:03:21 <carrom> oh
19:03:25 <aristid> or there are missing rooms
19:04:16 <aristid> carrom: i could have polished this a lot more, but i just wanted to get out something that works well enough
19:04:17 <carrom> ok. need to think and go through you code.
19:04:35 <aristid> well, the code is outdated now. it uses an old version of the web framework
19:04:38 <carrom> aristid: I understand.
19:05:41 <carrom> Anybody here who has few experience of functional notion and work other than haskell?
19:05:45 <copumpkin> @remember Saizan it's much easier via type theory, 1) prove bottom 2) ???? 3) quodlibet
19:05:45 <lambdabot> Good to know.
19:05:48 <luite> that is one of the issues with haskell though, many things are still new, api's change, and often there's no single best way to do something
19:06:52 <luite> it's usually not a problem, but it's something to watch out for, especially if you want to do web development
19:11:06 <Kaidelong> carrom: I've done a fair deal of stuff with F# and C#
19:11:11 <Kaidelong> why?
19:11:34 <carrom> Kaidelong: just asking
19:11:46 <carrom> guys, did you read that? http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
19:12:32 <Kaide> Haskell is probably the most important functional language for the time being though
19:13:11 <djahandarie> It is?
19:13:25 <Kaidelong> in terms of libraries and community at least
19:13:30 <Kaidelong> and being actively maintained
19:13:48 <Kaidelong> although perhaps Scala, Clojure, F# and the like could get momentum and become big on their own
19:14:32 <luite> carrom: you should read the last line
19:16:10 <carrom> yes
19:16:31 <Kaidelong> perhaps important is not the right word
19:16:38 <luite> carrom: but there's some truth to it, haskell can make other languages look worse :)
19:17:12 <Kaidelong> actually I'm not all too clear on the concept I'm trying to express
19:17:53 <Kaidelong> something to do with the haskell libraries actually generally having functional designs?
19:19:32 <joe____> Having trouble with the live Haskell interpreter: http://tryhaskell.org/
19:19:45 <joe____> Any one else experience this?
19:20:01 <luite> it works fine here
19:20:02 <joe____> All expressions returns: Terminated!
19:20:06 <Shahed> Hey guys
19:20:06 <djahandarie> joe____, it's working here as well
19:20:19 <Shahed> Any of you guys interested in Start-ups?
19:20:22 <luite> joe____: click the reset button
19:20:23 <joe____> Hm perhaps there is some browser settings?
19:20:32 <Kaidelong> Shahed: Yes, PM me?
19:20:43 <luite> joe____: there might be something stuck in your session
19:21:30 <joe____> luite: I tried the reset without succes
19:22:20 <luite> joe____: and reloading the whole page?
19:22:20 <carrom> Shahed: One more here, PM me?
19:23:33 <joe____> luite: That worked! Thank you
19:24:37 <gwern> @quote
19:24:38 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to
19:24:38 <lambdabot> fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
19:24:39 <luite> joe____: but it's better to install the haskell platform :)
19:24:59 <gwern> heh. not often you can quantify how much a bug cost
19:25:52 <djahandarie> Heh
19:26:58 <luite> hmm so it took him 13 hours to track down the bug :)
19:28:44 <joe____> luite: Yes, that makes sense. I'm just messing around to get a basic feel for it atm :)
19:35:52 <blbrown_win3> anyone, good with Java, I have a problem for you...(especially a college student)
19:36:08 <blbrown_win3> java and haskell
19:36:25 <carrom> blb: I'm here
19:36:52 <copumpkin> haskell and java in a single question?
19:36:56 <copumpkin> now I'm curious
19:37:23 <copumpkin> blbrown_win3: anyway, ask the question!
19:38:41 <blbrown_win3> carrom  There you go, try to run that with an IDE.  I am missing something.  I don't get any errors but my output does produce a sorted list.
19:38:41 <blbrown_win3> https://gist.github.com/950204
19:39:52 <carrom> blb: let me...
19:39:57 <copumpkin> functional java?
19:40:07 * copumpkin summons dobblego and HaudRex 
19:40:10 <copumpkin> :P
19:40:49 <blbrown_win3> ok.  a little smaller.  https://gist.github.com/950205
19:41:42 <blbrown_win3> copumpkin, it is an excerise is futility but I was bored
19:43:18 <djahandarie> You should see the one I did some time ago, it got pretty crazy.
19:43:24 <djahandarie> I have no idea where the source to that is though
19:45:27 <dmwit> Java? In my #haskell?
19:45:29 <blbrown_win3> the haskell version is 7 lines and the java version is 170.  Of course, I was a little bit verbose
19:46:24 <gwern> @quote aztec
19:46:24 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
19:46:28 <dmwit> return $(); /* WTF? Is this even Java? */
19:46:36 <blbrown_win3> valid code
19:46:36 <gwern> > zip`ap`tail []
19:46:37 <lambdabot>   Couldn't match expected type `[a] -> [b]'
19:46:37 <lambdabot>         against inferred type `[a...
19:46:45 <copumpkin> $
19:46:52 <gwern> wait, how did zip`ap`tail work again?
19:46:53 <dmwit> $ is a variable
19:46:55 <dmwit> nasty
19:46:55 * copumpkin hands gwern a dollar
19:47:02 <dmwit> > zip`ap`tail $ [1..5]
19:47:03 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
19:47:09 <copumpkin> dmwit: you snatched it from me!
19:47:22 <gwern> > zip`ap`tail [1..]
19:47:22 <lambdabot>   Couldn't match expected type `[a] -> [b]'
19:47:23 <lambdabot>         against inferred type `[t]'
19:47:30 <djahandarie> $
19:47:37 <blbrown_win3> dmwit, I got it from dobblego.  See functional java
19:47:38 <gwern> > zip`ap`tail $ [1..]
19:47:38 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
19:48:21 <gwern> probably my favorite stupid haskell trick because of the aztec joke
19:48:21 <dmwit> > map (id&&&succ) [1..]
19:48:22 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
19:48:39 <dmwit> > id&&&succ`map`[1..] -- hm
19:48:40 <lambdabot>   Couldn't match expected type `b -> c'' against inferred type `[a]'
19:48:50 <djahandarie> > id&&&succ . [1..]
19:48:51 <lambdabot>   Couldn't match expected type `b -> a' against inferred type `[a1]'
19:48:52 <copumpkin> @let splirst f = f &&& id
19:48:52 <gwern> > map f [1..10]
19:48:53 <lambdabot>  Defined.
19:48:53 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:48:53 <lambdabot>    `SimpleReflect.FromExpr ...
19:48:58 <djahandarie> > (id&&&succ) . [1..]
19:48:59 <copumpkin> @let splecond f = id &&& f
19:49:00 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
19:49:00 <lambdabot>  Defined.
19:49:01 <dmwit> Yep, wrong precedence. That's a shame.
19:49:03 <gwern> > map x [1..10]
19:49:03 <lambdabot>   Couldn't match expected type `a -> b'
19:49:04 <lambdabot>         against inferred type `Simple...
19:49:15 <copumpkin> > splecond succ . [1..]
19:49:17 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
19:49:27 <djahandarie> > id&&&succ>>>[1..]
19:49:28 <lambdabot>   Couldn't match expected type `(a, a) -> c'
19:49:28 <lambdabot>         against inferred type `[...
19:49:34 <dmwit> ...splecond?
19:49:42 <copumpkin> ...and splirst!
19:50:02 <copumpkin> :t splirst
19:50:03 <lambdabot> forall b c. (b -> c) -> b -> (c, b)
19:50:06 <copumpkin> :t splecond
19:50:07 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
19:50:16 <dmwit> By the way, does anybody else use frst, scnd, thrd for triples and first, secnd, third, forth for quadruples? ^_^
19:50:40 <luite> I usually use fst3, snd3, trd3
19:50:52 <djahandarie> dmwit, that doesn't seem like it would scale
19:50:58 <gwern> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5])
19:50:59 <lambdabot>   "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
19:51:06 * ddarius usually uses pattern matching and/or records.
19:51:08 <dmwit> djahandarie: It runs into serious problems right where I stopped the question. ;-)
19:51:10 <gwern> > foldr f x [1..5]
19:51:11 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
19:51:30 <luite> and I've never needed them for larger than three tuples :)
19:51:35 <dmwit> You can always add primes, of course.
19:51:57 <dmwit> first', second, third', fourth, fifth'
19:52:44 <dmwit> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
19:52:49 <luite> tenth''''''
19:53:01 <dmwit> Of course somebody did this. o_o
19:53:20 <djahandarie> That package is pretty nice actually
19:53:46 <luite> dmwit: file a bug report to make it support tuples up to 63
19:53:54 <dmwit> sequenceT :: (m a, m b) -> m (a, b) -- neat!
19:54:05 <copumpkin> dmwit: Applicative?
19:54:20 <copumpkin> :t liftA2 (,)
19:54:21 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
19:54:27 <copumpkin> :t uncurry (liftA2 (,))
19:54:28 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
19:54:37 <dmwit> copumpkin: sequenceT :: (m a, m b, m c, m d, m e) -> m (a, b, c, d, e) -- also a valid type for this value
19:54:52 <copumpkin> no quantification on m? o.O
19:54:54 <djahandarie> It is unfortunate that he's using sequence though
19:54:57 <dmwit> Yes, Monad, sorry.
19:54:59 <djahandarie> copumpkin, Monad
19:55:00 <dmwit> I'm just lazy.
19:55:03 <copumpkin> ah okay
19:55:06 <luite> hmm, can't say that I often encounter that type
19:55:24 <luite> but it could be useful
19:55:34 <dmwit> I have sent him a patch for the Curry module, though.
19:55:44 <djahandarie> Tuples have always seemed extremely wrong to me in Haskell
19:55:46 <dmwit> It's really inconvenient that the FD in that module only points one way.
19:55:57 <copumpkin> fix it!
19:56:18 <dmwit> What... I...
19:56:21 <dmwit> I sent him a patch.
19:56:25 <dmwit> What else should I do?
19:56:32 <djahandarie> Dance! Dance you fool!
19:56:54 * djahandarie was pretty sure that copumpkin's messsage was directed at him
19:57:03 <dmwit> oh
19:57:05 <copumpkin> dmwit: you could violate The Code
19:57:07 <dmwit> haha, I'm so egotistical.
19:57:18 <copumpkin> or djahandarie is!
19:57:23 <djahandarie> dmwit, who said I was just talking to you there?
19:57:23 * copumpkin will leave his intent as a mystery
19:58:28 <dmwit> djahandarie: Doubly egotistical! I'm egotistical even when I'm trying not to be. D=
19:58:39 <djahandarie> :p
19:58:43 <djahandarie> Speaking of fixing stuff, I should really fix my Agda install
19:59:48 <Eduard_Munteanu> I should upgrade to latest darcs Agda and install it that way, but I'm lazy.
20:00:15 <Eduard_Munteanu> (I've been meaning to do that to test the non canonical implicits)
20:06:05 <deteego> ok, I have this weird problem described here http://permalink.gmane.org/gmane.comp.lang.haskell.web/1431
20:06:30 <deteego> originally I thought it was due to my code (and something specific to Yesod), but it appears that when copying the example straight from the website
20:06:59 <deteego> it compiles fine, so for some weird reason I am getting a Ambiguous type variable `mo0' in the constraint specifically in my code
20:07:11 <gienah> Eduard_Munteanu: could probably create a darcs ebuild of agda
20:07:52 <Eduard_Munteanu> Hrm, yeah, that'd be nice, I also run Gentoo.
20:07:58 <deteego> more specifically its a Ambiguous type variable `a0' in the constraint:       (Yesod a0) arising from a use of `defaultLayout'  compiler error
20:08:11 <deteego> does anyone know if this error can come up due to imports or something along those lines?
20:08:20 <Eduard_Munteanu> gienah: is there support for fetching Darcs repos? I've so far only worked with Git stuff there.
20:08:28 <deteego> or what it means eactly?
20:08:31 <deteego> *exactly
20:08:55 <gienah> Eduard_Munteanu: yes so creating a darcs ebuild of agda should be fairly easy, I'll try it :-)
20:09:13 <Eduard_Munteanu> Is there a Haskell overlay or such?
20:09:23 <Eduard_Munteanu> I never looked beyond what's in Portage.
20:11:24 <danharaj> Hmm
20:11:32 <danharaj> I am surprised there is no linear algebra library built on top of Repa yet.
20:12:04 <gienah> Eduard_Munteanu: there is a lot more stuff in the gentoo-haskell overlay than portage: http://www.haskell.org/haskellwiki/Gentoo
20:14:19 <Eduard_Munteanu> Nice.
20:16:08 <Eduard_Munteanu> Damn, xmonad seriously needs to release more often :)
20:16:56 <Eduard_Munteanu> 0.9 is getting really moldy already.
20:17:00 <gienah> Eduard_Munteanu: unmask xmonad-9999 :-)
20:17:51 <gienah> Eduard_Munteanu: or x11-xm/xmonad-0.9.2 is in the gentoo-haskell overlay
20:20:32 <Eduard_Munteanu> Ah, it seems 0.9.2 isn't quite an official release.
20:21:29 <Eduard_Munteanu> Well I tend not to run much -9999 stuff, I currently do so only for stuff like Gallium/Mesa to get FOSS 3D accel on my Radeon 5850 :)
20:22:19 <Eduard_Munteanu> I haven't even tried GHC 7.
20:24:52 <Eduard_Munteanu> Hm, dev-haskell/haskell-platform is just a meta, isn't it?
20:24:59 <Eduard_Munteanu> (though rather old)
20:25:09 <Eduard_Munteanu> -2009.2.0.2
20:25:25 <dmwit> Hm, how hard would it be to convince people to split Text.Printf out from base?
20:26:36 <dmwit> This "instance PrintfType (IO a)" should really be "instance Default a => PrintfType (IO a)".
20:27:35 <dmwit> Alternately, how hard to merge Data.Default into base? =P
20:29:21 <silver> hi there!
20:29:57 <dmwit> Hi there! Good thing you didn't reveal your secret identity there. =P
20:30:17 <sliverstone> ha ha :)
20:30:19 <sliverstone> Can snap framework run on windows?
20:30:22 <gienah> Eduard_Munteanu: haskell-platform-2011.2.0.1.ebuild is in the gentoo-haskell overlay :-)
20:30:28 <mzero> yes, snap can
20:30:36 <Eduard_Munteanu> Hm, interesting, thanks.
20:31:12 <sliverstone> mzero: but their site does not site it anywhere
20:31:35 <monochrom> gentoo users get overlaid :)
20:32:27 <dmwit> If it does not depend on the "unix" package somewhere deep in its dependency tree, you are often in pretty good shape.
20:32:44 <sliverstone> ok. I have on beginner problem for you guys
20:33:31 <mzero> silverstone - indeed, they don't, but it runs anywhere Haskell Platform does I think
20:33:32 <sliverstone> r u ready?
20:33:45 <dmwit> No. Give me an hour to get set up.
20:33:46 <sliverstone> mzero:ohk
20:33:52 <mzero> you don't need to brace us for questions - just lay it on the channel
20:34:06 <Eduard_Munteanu> Have type-level naturals made it in any GHC release?
20:34:12 <sliverstone> mzero: ok here it is
20:34:30 <sliverstone> what will be the best code line to generate 5 chars long unique alphanumeric string in haskell?
20:34:47 <mzero> here at #haskell, we all wear jump suits made of monadic kevlar and can withstand even the largest barrage of questions
20:35:05 <mzero> > "abcde"
20:35:06 <lambdabot>   "abcde"
20:35:29 <mzero> > 26^5
20:35:30 <lambdabot>   11881376
20:35:31 <sliverstone> mzero: i like that - monadic
20:35:41 <geheimdienst> > "kitty"
20:35:42 <lambdabot>   "kitty"
20:35:56 <sliverstone> u r outputting constants
20:36:00 <sliverstone> isn't that
20:36:08 <mzero> Not sure what you mean by "unique" given that their are only 11M five character alphabetic (Latin) strings
20:36:11 <monochrom> unique
20:36:44 <mzero> are you asking: "how do you generate a 5 character random string?"
20:36:47 <dmwit> > replicateM 5 [minBound..maxBound] :: [String]
20:36:48 <lambdabot>   ["\NUL\NUL\NUL\NUL\NUL","\NUL\NUL\NUL\NUL\SOH","\NUL\NUL\NUL\NUL\STX","\NUL...
20:36:50 <sliverstone> unique - string output once should not be output next time
20:36:56 <monochrom> "abcde" is unique. there is no other string equal to it.
20:37:08 <dmwit> sliverstone: There you go, all possible length-5 strings.
20:37:19 <dmwit> It will output them one at a time, no two the same.
20:37:20 <dmwit> Next!
20:37:30 <sliverstone> mzero: i'll be running this line only 11M times
20:37:50 <mzero> you want an executable or a function to be used elsewhere in a Haskell program?
20:38:03 <dmwit> > (ord maxBound - ord minBound)^5 -- largish
20:38:03 <lambdabot>   -4617890880364937217
20:38:14 <dmwit> > (fromIntegral $ ord maxBound - ord minBound)^5 -- largish
20:38:15 <lambdabot>   1716494084021838487826828951551
20:38:18 <sliverstone> mzero: say funtion
20:38:25 <monochrom> use what dmwit says. it contains way more than 11M choices.
20:38:29 <sliverstone> *function
20:38:31 <mzero> that's not generally how you'd write such a thing in Haskell
20:38:50 <mzero> because to do so implies that you've got state somewhere so the second calling of the function yeilds a different output
20:38:54 <sliverstone> mzero:please go ahead
20:39:00 <mzero> that generally isn't what one does
20:39:01 <leavengood> that's what I was thinking
20:39:08 <leavengood> state
20:39:19 <leavengood> (newbie here)
20:39:29 <mzero> instead, you can use something like what dmwit wrote to generate a list of all possible strings.... and then consume it while procressing
20:39:40 <mzero> though you might try
20:39:41 <sliverstone> let say u put it - state - in persistent storage
20:39:54 <mzero> > replicateM 5 ['a'..'z']
20:39:55 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaah","aaaai","a...
20:40:08 <mzero> silverstone - don't
20:40:12 <sliverstone> mzero: that's better
20:40:25 <copumpkin> > map read (replicateM 5 ['0'..'9']) :: [Int]
20:40:26 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:40:28 <mzero> don't put things in persistent storage without very good reason
20:40:36 <sliverstone> got it
20:40:40 <copumpkin> > map read (replicateM 5 ['0'..'9']) == [0..99999]
20:40:42 <lambdabot>   True
20:40:44 <copumpkin> yay
20:40:48 <dmwit> copumpkin: how... efficient
20:41:03 <copumpkin> thank you thank you
20:41:17 <copumpkin> if you like my high-performance coding skills, I'm available for contract work
20:41:34 <sliverstone> copumpkin: that was nice
20:41:41 <mzero> for example, if I had some operation I needed to perform, say once for each element of some list, and each operation needed a unique 5 character string.... I'd do something like:
20:41:47 <monochrom> > replicateM 5 ['\x2000' .. '\x2004']
20:41:48 <lambdabot>   ["\8192\8192\8192\8192\8192","\8192\8192\8192\8192\8193","\8192\8192\8192\8...
20:41:57 <dmwit> > '0x30000'
20:41:58 <lambdabot>   <no location info>:
20:41:58 <lambdabot>      lexical error in string/character literal at chara...
20:42:03 <dmwit> > '\x30000'
20:42:04 <lambdabot>   '\196608'
20:42:07 <monochrom> oh, it's hard to display them as spaces
20:42:26 <dmwit> > text "\x30000"
20:42:27 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
20:42:28 <mzero> > let labels = replicateM 5 ['a'..'z']; func i l = "writing " ++ show i ++ " into " ++ l; in   zipWith func [34, 12, 1, 42] labels
20:42:30 <lambdabot>   ["writing 34 into aaaaa","writing 12 into aaaab","writing 1 into aaaac","wr...
20:42:31 <dmwit> hah
20:43:29 <sliverstone> lamb..t: how fast u r
20:43:43 <sliverstone> lam..t: u must be haskell compile ;)
20:44:04 <dmwit> "guide" gets stemmed to the same thing as "GUID" on Google. ಠ_ಠ
20:44:06 <leavengood> > reverse "!looC"
20:44:06 <monochrom> I like this new s..e convention
20:44:07 <lambdabot>   "Cool!"
20:45:01 <sliverstone> mono..m: thanx. sometimes keyboard does not type as fast as you can
20:45:30 <monochrom> I personally just type sli<tab>
20:46:01 <sliverstone> mono: this is even right. as long as you are no cause ambiguity
20:46:13 <ddarius> ..
20:46:33 <sliverstone> dd..us: what was that?
20:46:46 <monochrom> this causes no ambiguity either
20:46:49 <dmwit> > length "ddarius" - length "dd..us"
20:46:50 <lambdabot>   1
20:46:56 <sliverstone> mono:yep
20:47:15 <dmwit> lern2tabcomplete
20:47:17 <leavengood> sliverstone: most decent IRC clients will tab complete nicks
20:47:18 <sliverstone> dd: ha ha
20:47:39 <monochrom> perhaps webchat software doesn't have completion
20:47:53 <sliverstone> leavengood: oh I just tried that
20:48:01 <monochrom> or should I say, perh..aps web..chat soft..ware does..n't ha..ve complet..ion
20:48:02 <sliverstone> leavengood: I was not knowing that
20:48:20 <dmwit> Although, to be fair, nobody laughs at "i18n" as an abbreviation.
20:48:34 <mzero> silverstone's client, qwebirc, does
20:48:39 <dmwit> Or that other one. l10n
20:48:50 <sliverstone> CTCP version
20:49:45 <sliverstone> mzero: how to get that
20:49:57 <sliverstone> I'm on tryhaskell.org
20:50:04 <mzero> how to get what? nicname autocompletion in qwebirc?
20:50:23 <sliverstone> mzero: you have requested CTCP version right?
20:50:48 <ddarius> dmwit: One needs to consider the finger parallelism that .. precludes.
20:50:56 <mzero> I have no idea what you're asking?
20:51:25 <shachaf> ddarius: Presumably a sufficiently-motivated user would bind a key to "..".
20:51:26 <sliverstone> mzero: let me put few line from this chat window that i saw few minute ago
20:51:42 <sliverstone> mzero [~markl@m208-18.dsl.rawbw.com] requested CTCP VERSION from sliverstone:
20:51:49 <mzero> ah - that was just my IRC client asking your IRC client what version it was
20:52:03 <monochrom> presumably a very motivated user would bind many keys to ".." to increase parallelization opportunities
20:52:05 <mzero> no idea why it showed that to you
20:52:10 <sliverstone> mzero: oh. i'm sorry
20:52:14 <mzero> NP
20:52:27 <mzero> I suggest a more, er, robust IRC client....
20:52:44 * shachaf tries to parse the end of mzero's line.
20:53:13 <mzero> nevermind, back to Haskell....
20:53:36 <dmwit> shachaf: "client...." is obviously short for "clientele."
20:53:47 <leavengood> LOL
20:53:57 <mzero> sliverstone: an advantage of lazy evaluation is that you can do the computation of "all possible 5 character labels" in one place, and then just take from it as you need it
20:54:59 <sliverstone> mzero: is that threadsafe?
20:55:06 <mzero> yes
20:55:07 <dmwit> > let increment [] = [minBound]; increment (x:xs) | x == maxBound = minBound : increment xs | otherwise = succ x : xs in iterate increment []
20:55:07 <lambdabot>   [[],[()],[(),()],[(),(),()],[(),(),(),()],[(),(),(),(),()],[(),(),(),(),(),...
20:55:11 <dmwit> lol
20:55:17 <dmwit> > let increment [] = [minBound]; increment (x:xs) | x == maxBound = minBound : increment xs | otherwise = succ x : xs in iterate increment [] :: [String]
20:55:18 <lambdabot>   ["","\NUL","\SOH","\STX","\ETX","\EOT","\ENQ","\ACK","\a","\b","\t","\n","\...
20:55:23 <shachaf> mzero: I just understood part of dons's monad analogy.
20:55:25 <lars9> @hlint
20:55:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:55:31 <monochrom> immutable data are thread safe
20:55:32 <dmwit> > let increment [] = [minBound]; increment (x:xs) | x == maxBound = minBound : increment xs | otherwise = succ x : xs in iterate increment [] :: [[Bool]]
20:55:33 <lambdabot>   [[],[False],[True],[False,False],[True,False],[False,True],[True,True],[Fal...
20:55:38 * shachaf didn't realize the "and you just take what you need" referred to laziness.
20:55:42 <mzero> shachaf: ?
20:56:04 <sliverstone> monochrom: what about memory usage that immutable data will take
20:56:04 <monochrom> there is a dons monad analogy?
20:56:13 <shachaf> @remember dons Think of a monad as a spacesuit full of nuclear waste in the ocean next to a container of apples. Now, you can't put oranges in the space suite or the nuclear waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need.
20:56:14 <lambdabot> I will remember.
20:56:28 <monochrom> oh that one
20:56:28 <sliverstone> monochrom: is it higher than mutable data languages?
20:56:42 <monochrom> you can make it higher or not higher
20:57:17 <sliverstone> monochrom: oh ok
20:57:53 <dmwit> There's no reason for mutability to change the amount of space a value takes.
20:58:20 <dmwit> I'm given to understand that in eager languages, mutability can sometimes gain you a log-factor for asymptotic time, but that nobody knows the answer to the corresponding question for lazy languages.
20:58:31 <mzero> sliverstone: when you build a large, or infinite list, and let it be built with lazily (as we have in the above examples), if you consume it from the front, generally, you are only consuming the memory for those items you are actually using
20:59:04 <mzero> for example:
20:59:24 <mzero> > product $ take 100 [1..]
20:59:25 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:59:51 <dmwit> Computers are so mind-bogglingly fast.
20:59:53 <mzero> in that expression, the lazy list [1..] never took more than two cells of memory:
21:00:18 <mzero> because as the list was produced, the take, then the product functions consumed them
21:00:42 <sliverstone> mzero: getting it slowly
21:01:06 <dmwit> > 4 * 1600 * 1200 * logBase 10 2
21:01:07 <lambdabot>   2311910.366699375
21:01:35 <dmwit> Your screen is basically a 2-million digit number, and your computer does enough computation to generate a new one sixty times per second.
21:01:41 <sliverstone> guys, I think first, I need to understand what is function programming and then come to haskell
21:01:46 <mzero> be careful though - should one set a top level identifier to such a list --- then all terms ever used will be kept around forever
21:02:03 <dmwit> There's no finer way to learn functional programming than to learn the Haskell language.
21:02:26 <mzero> so     all5CharacterLabels = replicateM 5 ['a'..'z']      woudl be a lousy thing to put at the top level of a module
21:02:28 <sliverstone> oops guys like me are finding it hard to digest
21:02:57 <mzero> sliverstone: no no, Haskell is a fine place to start learning
21:03:08 <mzero> in fact, probably the best way to learn a functional langauge ---
21:03:23 <sliverstone> mzero: advice taken
21:03:33 <mzero> lazy may seem strange, but laziness forces purity --- and purity is REALLY what programming in the functional paradigm is all about
21:03:55 * shachaf doesn't like the word "purity".
21:03:58 <dolio> But lazy doesn't enforce purity, apparently.
21:04:12 <dolio> Because Harper wants to use laziness to wrap up his impurity.
21:04:22 <dolio> That's all it's good for.
21:04:27 <mzero> put the cabinet back in the corner, and stop looking under the rugs, dolio
21:04:38 <mzero> :-)
21:04:48 <dmwit> Wow, was that a Zork reference?
21:05:07 <monochrom> haha
21:05:13 <dylukes> Random: http://cl.ly/6Nnc
21:05:15 <sliverstone> mzero: functional paradigm. what else is there? with example :)
21:05:16 <dylukes> I'm making origami!
21:05:22 <dylukes> hurray for math!
21:05:22 <mzero> sliverstone: which path are you using to learn Haskell? LYAH? RWH? Barley?
21:05:56 <mzero> very nice, dylukes !
21:06:12 <sliverstone> mzero: yet to decide.
21:06:21 <dylukes> the goal is five interlocked tetrahedrons
21:06:21 <sliverstone> mzero:  what could be the best
21:06:23 <leavengood> I can recommend LYAH: http://learnyouahaskell.com/
21:06:25 <dylukes> Im at three right now
21:06:29 <Eduard_Munteanu> Just don't get Cale started on symmetry groups and magnetic balls :P
21:06:41 <dylukes> @quote Cale balls
21:06:41 <lambdabot> No quotes match. You speak an infinite deal of nothing
21:06:44 <mzero> LYAH and RWH are both great, though very different ---
21:06:48 <dylukes> @quote revenantphx Cale
21:06:49 <lambdabot> revenantphx says: Cale... I like your balls. They're shiny. You obviously take good care of them.
21:06:52 <dylukes> there we are.
21:06:57 <mzero> look at the first chapters of both (both free on-line) and see
21:07:05 <dylukes> Eduard_Munteanu: see above.
21:07:10 <Eduard_Munteanu> Heh, yeah.
21:07:20 <mzero> Barley is still experimental, and only has three chapters (hey... I'm workin' on it!)
21:07:46 <mzero> On the other hand, it is gets you generating HTML from Haskell in the first 15 min.
21:07:51 <Eduard_Munteanu> mzero: link?
21:07:58 <mzero> @hackage barley
21:07:58 <lambdabot> http://hackage.haskell.org/package/barley
21:08:36 <Eduard_Munteanu> By chance, is it the stuff running on tryhaskell?
21:08:55 <leavengood> I think the different approaches to teaching/learning are good
21:09:06 <dylukes> I kind of used LYAH and RWH simultaneously
21:09:10 <dylukes> and I still haven't *finished*
21:09:18 <mzero> Eduard_Munteanu: no, tryhaskell is yet another system
21:09:20 <leavengood> LYAH has taught me a lot in a few days (I'm already a professional programmer)
21:09:22 <dmwit> Suppose I write "f x = let y = expensiveFunction x in \z -> cheapFunction y z". I'm hoping that if I do something like "map (f x) zs", the "y" gets shared. Is there a way to get similar sharing, but for the second argument instead of the first?
21:09:25 <Eduard_Munteanu> Surely it's nice to have different viewpoints when you don't grok something.
21:09:26 <djahandarie> You never finish learning!
21:09:46 <dylukes> djahandarie: nope, you just get distracted making origami out of money
21:10:02 <leavengood> I'm reading the intro to RWH now and I like the example projects described
21:10:13 <sliverstone> mzero: thanks for the pointer
21:10:19 <leavengood> sometimes the rubber has to hit the road
21:10:31 <sliverstone> will start with LYAH
21:10:46 <dmwit> Hm.
21:10:47 <mzero> good - enjoy it!
21:10:55 <dmwit> Do I even have to do anything as fancy as that to get the sharing I want?
21:10:58 <KirinDave> Man I don't even know the words to use to ask this question.
21:11:20 <dmwit> Can I just do "f x z = cheapFunction (expensiveFunction x) z"?
21:11:22 <monochrom> use symbols to ask the question
21:11:28 <leavengood> speaking of learning, are there any standard problems one could solve in Haskell where answers are provided?
21:11:36 <KirinDave> If I'm saying Nothing <*> something <*> something
21:11:44 <KirinDave> And I want to finally handle the case that i have nothing
21:11:46 <mzero> dmwit - I think that will work at higher optimization levels, not sure at less
21:11:47 <dmwit> :t (<*>)
21:11:47 <KirinDave> At the very end
21:11:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:11:48 <mzero> (or in ghci)
21:11:58 <KirinDave> Can I do that?
21:12:14 <KirinDave> In parsec there is a <?> at the end of the combinator chain to say, "Oh by the way this is fixed."
21:12:16 <shachaf> fromMaybe 4 (Nothing <*> Just 1 <*> Just 2)
21:12:20 <shachaf> > fromMaybe 4 (Nothing <*> Just 1 <*> Just 2)
21:12:21 <lambdabot>   4
21:12:51 <mzero> that's what I'd do!
21:12:55 <KirinDave> Okay.
21:12:55 <shachaf> > Nothing <*> Just 1 <*> Just 2 <|> Just 7
21:12:56 <lambdabot>   Just 7
21:12:59 <KirinDave> Ahhh
21:12:59 <shachaf> > Just (+) <*> Just 1 <*> Just 2 <|> Just 7
21:13:00 <lambdabot>   Just 3
21:13:04 <KirinDave> <|> is the combinator.
21:13:07 <Eduard_Munteanu> dmwit: you could try using a Map to make sharing explicit and compare
21:13:09 <KirinDave> Thu-hank you.
21:13:11 <mzero> AHA
21:13:32 <dmwit> Eduard_Munteanu: Good idea. Thanks.
21:13:36 <mzero> you know, I can never remember all those extra cool ones when it turns out I could use them...
21:13:42 <shachaf> KirinDave: Alternatively, mplus.
21:13:47 <mzero> like *** +++ &&& !!! ^^^
21:14:13 <KirinDave> shachaf: I didn't know m+ would do that.
21:14:17 <shachaf> <|> is like mplus for Applicative (well, Alternative).
21:14:17 <mzero> I should make a chart (not to look at... the act of making the chart will cement it!)
21:14:25 <shachaf> @src Maybe mplus
21:14:26 <lambdabot> Nothing `mplus` ys = ys
21:14:26 <lambdabot> xs      `mplus` ys = xs
21:15:02 <monochrom> Applicative : Alternative :: Monad : MonadPlus
21:15:35 <KirinDave> I should read the monad instances for maybe, huh
21:15:51 <shachaf> s/read/write/
21:16:11 <dmwit> We have such a huge number of ways of using Maybe's, and no good ways of making them.
21:16:13 <KirinDave> shachaf: Oh you clever you.
21:16:25 <shachaf> KirinDave: No, really. The types kind of force you to do it a particular way.
21:16:44 <dylukes> ALRIGHt.
21:16:45 <monochrom> that's why you're clever to suggest writing
21:16:48 <dylukes> time for tetrahedron 4.
21:16:49 <dylukes> ._.
21:16:51 <deteego> dmwit: maybe you are not trying hard enough ;)
21:17:07 <shachaf> monochrom: Ah, I may have misread.
21:19:54 <mzero> if a type is an instnace of both Alternative and MonadPlus, and obey the requisite laws, will it have empty = mzero and <|> = mplus?
21:20:09 <mzero> I'm guessing it isn't required... but true for all the standard instances
21:20:27 <shachaf> mzero: Given that it's not necessarily true of Applicative/Monad, I'd guess not.
21:21:01 <shachaf> But probably true for all the standard instances, yes.
21:21:28 <mzero> ah, so one can have a type that is an instance of Applicative and Monad, obey all the laws, and yet have, say pure ≠ return, or <*> ≠ ap
21:21:31 <dylukes> gah
21:21:34 <dylukes> so uneven D:
21:21:40 <dylukes> I can't figure out how to make them… sit flush
21:21:40 <shachaf> mzero: E.g. ZipList.
21:21:56 <mzero> ZipList isn't a monad, though,
21:22:18 <shachaf> True, but ZipList is a valid Applicative instance for [].
21:22:30 <shachaf> It's just not the standard one, perhaps for Monad compatiblity.
21:22:43 <mzero> got it
21:22:45 <mzero> sure - okay
21:23:07 <kmc> i thought one of the Applicative laws is that if your type is also an instance of Monad, pure = return and (<*>) = ap
21:24:10 <kmc> "If f is also a Monad, define pure = return and (<*>) = ap."
21:24:11 <Kaidelong> mzero: well haskell won't enforce it, but that shouldn't happen, no
21:24:15 <mzero> that seems to be a "suggestion" in the haddock, rather than listed as a "law"
21:24:15 <kmc> that sounds normative
21:24:16 <shachaf> kmc: I've never heard of that law.
21:24:17 <kmc> but IANAL
21:24:34 * shachaf wonders what L stands for.
21:24:39 <kmc> lawyer
21:24:56 <shachaf> Oh, laws, I see.
21:25:04 <kmc> it's at the end of a list of laws, and uses the imperative mood
21:25:35 <dmwit> It's a bit like "should" rather than "must" in RFCs.
21:25:40 <mzero> but yeah, I understand the intent ---- any Monad instance, if it's going to be an Applicative instance, should follow that form ... and if you have an alternate possible Applicative instance for the type, use a newtype (ala ZipList)
21:25:52 <dmwit> Also, may I just say: I love that there is an RFC describing suggested terminology for RFCs.
21:26:17 <mzero> Gödel loves that that RFC can reference itself
21:26:46 <dmwit> Oh, nobody ever even thought for a second that English was complete.
21:27:06 <shachaf> OK, maybe it is a law of sorts.
21:27:09 <mzero> it's neither complete NOR consistent  ---- double score!
21:27:12 <dylukes> I KNEW IT.
21:27:14 <Kerris> Pakistan government has declared an Education Emergency. Less than a third of the students could subtract 3-digit numbers
21:27:15 <dylukes> one of them was off !
21:27:15 <Kerris> lol
21:27:21 <Kerris> wrong channel, fffff
21:28:08 <dylukes> :)
21:28:13 <dylukes> already pretty beautiful imo
21:28:18 <dylukes> in a math/symmetry way
21:28:38 <monochrom> Gödel didn't bother to prove that natural languages are incomplete and inconsisent. It's obvious, doesn't need proof.
21:29:06 <mzero> Monoid is the funky one .... you might be tempted to think that for a given type that is an instance of both Monoid and MonadPlus that   mplus = mappend .... but you'd be wrong!
21:29:39 <shachaf> mzero: That doesn't even make sense. They're not the same kind.
21:29:39 <kmc> he did prove that god exists though
21:29:58 <dmwit> :t (mplus, mappend)
21:29:59 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m, Monoid a1) => (m a -> m a -> m a, a1 -> a1 -> a1)
21:31:53 <mzero> > map (\f -> Just "hello" `f` Just "world") [mplus, mappend]
21:31:54 <lambdabot>   [Just "hello",Just "helloworld"]
21:32:11 <shachaf> mzero: You said that the type is an instance of both Monoid and MonadPlus.
21:32:25 * shachaf wishes GHC didn't do the a, a1, a2 thing for types.
21:32:29 <mzero> shachaf: they aren't the same kind, true .... but when thinking concretely about, say, Maybe, I often get tripped up about which one to use....
21:32:54 <ddarius> shachaf: And instead did what?  It already tries to use types provided in the type signatures.
21:33:14 <shachaf> ddarius: b, c, d, etc., if they weren't taken.
21:33:29 <kmc> the claim relates to «(Monad m) ⇒ ...» compared to «(∀a. Monoid (m a)) ⇒ ...»
21:33:36 <kmc> higher-rank type constraints, my favorit
21:33:49 <monochrom> you're probably thinking "m is MonadPlus when m a is Monoid"
21:34:09 <shachaf> OK, I suppose that makes sense.
21:34:09 <kmc> er MonadPlus yeah
21:34:25 <shachaf> If you think of MonadPlus as being Alterantive it might make things clearer. :-)
21:34:32 <mzero> well.. actually, it's more like, I'm thinking .... "huh, I've got a bunch of Maybe String values and I need to combine 'em..... mplus or mappend? "
21:34:39 <mzero> I actually like that I have both options....
21:34:48 <mzero> I just get tripped up by it and have to fire up ghci every time
21:35:25 <kmc> yeah, this is a problem with saying your type has a single favorite binary operator
21:35:53 <mzero> it's also a byproduct of that both operations are prefixed with 'm' .....
21:36:16 <mzero> I might be able to keep them a bit more distinct in my mind if they had different prefixes....
21:36:21 <monochrom> need a Munchkin class
21:36:32 <shachaf> monochrom: Munchkin and WarmFuzzyThing?
21:36:32 <kmc> i mean why shouldn't mappend on lists be «zipWith mappend»
21:36:38 <Kaidelong> hmm, so a monad is basically where you have a category for functions in the form (a -> f b) where f is a functor?
21:36:52 <monochrom> Munchkin and WarmHuggyMonster
21:36:59 <Kaidelong> hmm not category
21:37:00 <Kaidelong> monoid
21:37:08 <Kaidelong> wait no
21:37:11 <kmc> Kaidelong, no, it's a category
21:37:12 <Kaidelong> category
21:37:15 <Kaidelong> yeah
21:37:16 <mzero> I like class WarmHuggyMonster
21:37:20 <kmc> a monoid is just a category with only one type ("object")
21:37:36 <Kaidelong> yeah and in this case you have the parameters a and b
21:37:37 <ddarius> Kaidelong: No.
21:38:03 <kmc> the Kleisli category of a monad M is the category of functions of type like (a → M b)
21:38:04 <dmwit> I recall seeing a newtype for Maybe that added an Ord instance where Nothing was maximal (and a dual one whene Nothing was minimal).
21:38:13 <dmwit> Does anybody remember where that lives?
21:38:16 <kmc> the identities of this category are given by "return", and its composition is (<=<)
21:38:19 <dmwit> I'm having trouble finding it again
21:38:20 <dmwit> .
21:38:43 <ddarius> dmwit: Possibly in one of Conal's libraries.
21:38:50 <mzero> I suppose I can remember that you need to use Monoid if I want the stuff inside the Maybe considered, and MonadPlus otherwise... then that msum relates to mplus and "plus" relates to MonadPlus.... whereas mconcat relates to mappend which must relate to the other one, Monad.
21:38:54 <monochrom> Munchkin! http://www.worldofmunchkin.com/game/
21:38:59 <dmwit> ddarius: Definitely in one of Conal's libraries.
21:39:16 <dmwit> ddarius: But Hackage doesn't have a way to filter packages by author. =(
21:39:50 <kmc> it sort of does.  http://hackage.haskell.org/packages/archive/log
21:39:51 <dmwit> Aha, Data.Max is in reactive.
21:39:53 <shachaf> mzero: mappend for [] doesn't consider "the stff inside the []"
21:40:22 <dmwit> I wonder if he could be convinced to split that out into another package. It seems weird to depend on reactive just for that instance.
21:40:30 <shachaf> Well, not in the same sense, at least.
21:40:41 <mzero> shachaf: well, for [], MonadPlus's functions and Monoid's functions are the same
21:41:01 <dmwit> err... Data.AddBounds, rather. Which adds both bounds. =/
21:41:06 <dmwit> Never mind, I'll roll my own.
21:41:07 <mzero> again, I get fuddled when working with Maybe x... where they are different
21:41:20 <lispy> hello
21:41:29 <ddarius> Monoid shouldn't be a type class.
21:41:43 <lispy> ddarius: No?
21:41:53 <dolio> There are too many monoids.
21:42:07 <danharaj> there are too many monoids per type.
21:42:17 <lispy> It's not the number of monoids that is the issue. It's what danharaj just said :)
21:42:18 <dmwit> lispy: I suspect ddarius believes Monoid should be a record instead.
21:42:19 <dolio> Often with no 'best' choice.
21:42:37 <danharaj> lispy: How is your OpenGL text thing going?
21:42:49 <lispy> dmwit: yeah, ad-hoc polymorphism via record is an underappreciated 'thing'
21:43:05 <djahandarie> Well, we now have fairly painless way to work with newtypes... ;)
21:43:10 <djahandarie> @hackage newtype
21:43:10 <lambdabot> http://hackage.haskell.org/package/newtype
21:43:46 <lispy> danharaj: I haven't had a chance to work on it recently.  The raw freetype2 binding is like 95% of the freetype api (not really sure what else to add), but I haven't used it enough to know what the haskell friendly api should be yet.  I'm thinking probably a custom RWST monad though.
21:44:14 <danharaj> lispy: ok sounds like a good first idea.
21:44:34 <lispy> djahandarie: interesting.  I never noticed that before
21:44:36 <danharaj> lispy: I'm trying to think of what I can do to help you, pastorn, and the other OpenGL super friends to make Haskell + OpenGL palatable.
21:44:55 <djahandarie> lispy, it hasn't been around for too long
21:44:57 <lispy> danharaj: are you on the hopengl mailing list?  Someone just sent a mail there recently
21:45:09 <danharaj> lispy: yes I am. I try to check that account at least once a day.
21:45:23 <lispy> danharaj: ah, cool.
21:46:00 <lispy> danharaj: I think we still need a good solid GUI library.  GLFW-b is good for lots of things, but we need something on the order of magnitude of gtk2hs that is easy to install and use without an encumbering license.
21:46:11 <mzero> oh! that package is lovely!
21:46:18 <danharaj> lispy: like wxhaskell?
21:46:21 <mzero> (newtype that is)
21:46:28 <lispy> danharaj: I think wx is also LGPL
21:47:07 <danharaj> ah yes it is. Well close enough to it.
21:47:10 <danharaj> That's annoying.
21:47:28 <lispy> danharaj: I think what we really need is yet another GUI library but in pure haskell
21:47:41 <danharaj> lispy: That sounds like an enormous undertaking.
21:47:41 <luite> is LGPL actually a problem for anyone, in practice?
21:47:49 <lispy> danharaj: Not sure what to do for linux peeps.  They'd probably want gtk.
21:48:07 <lispy> luite: yes?  maybe?  I can't get a straight answer from lawyers.
21:48:57 <danharaj> lispy: could parametrize the library over other solutions?
21:48:59 <lispy> luite: one lawyer I spoke with recently said that GPL and LGPL are identical in their professional opinion, but since neither has a legal precedent set for them in court they didn't know how judges would treat them.
21:49:15 <danharaj> ^ uncertainty in my code's status makes me nervous.
21:49:17 <Elbar> one should use web browers instead of gui's nowadays imo
21:49:18 <luite> what could be a potential danger of using LGPL? and have there actually been cases where someone got in trouble?
21:50:06 <lispy> Elbar: So that means we need to use webgl (it's really not ready for production use), NaCL (not mature either), and javascript (ugh.)
21:50:11 <gienah> luite: one little problem is that LGPL libs can not be used in some BSD projects, as the BSD project admins sometimes will not allow it
21:51:12 <Elbar> if i look at the stuff google is capabable of doing with a "simple" webbrowser...
21:51:28 <danharaj> lispy: I was thinking of building a linear algebra library over repa. What do you think, or do you think another library would suffice for a sort of "Haskell + GUI + OpenGL" toolkit.
21:51:31 <luite> yes webbrowsers are far from simple nowadays
21:52:14 <lispy> Elbar: if I could use a nice statically typed language for webstuff, say Haskell, then I would be far more interested in targetting the browser.
21:52:20 <gienah> luite: another little issue is that for haskell stuff their probably should be a dynamic linking exception to the LGPL, as is done in some LGPL haskell libs (like wxWidgets)
21:52:32 <Eduard_Munteanu> What's a good way to inspect types, typeclass definitions and such for Haskell code from some other Haskell code? I'm looking for a lib, presumably something that interfaces with GHC>
21:52:44 <lispy> danharaj: I hear people talk about repa.  I don't have much of an opinion other than I know Data.Vector is nice.
21:53:03 <Eduard_Munteanu> My actual application would be a binding generator for Agda.
21:53:05 <lispy> danharaj: but, Data.Vector seems like a bit much for doing linear alg where the biggest matrix you need is like 4x4
21:53:36 <danharaj> lispy: That's true. Although you can use Repa for doing image processing too.
21:53:39 <lispy> Eduard_Munteanu: you want hoogle?  Or you want :info?
21:53:44 <luite> gienah: hmm, that's a fair point (the first one), but that's probably more to do with the philosophy of the project, keeping it as free as possible
21:53:53 <danharaj> lispy: It's built on top of Data.Vector.Unboxed, and is built for parallelism.
21:54:06 <Eduard_Munteanu> lispy: I want something like lambdabot but machine-readable
21:54:15 <KirinDave> I feel like my import statements are growing without bound...
21:54:29 <lispy> KirinDave: yeah, I've been feeling that a lot lately too.
21:54:32 <danharaj> Eduard_Munteanu: Note that GHC is also a library :) You should check it out.
21:54:34 <Eduard_Munteanu> e.g. to walk through a typeclass and see members.
21:54:46 <KirinDave> Although it seems like one module can import symbols into another?
21:54:55 <KirinDave> So maybe that's the solution
21:55:07 <lispy> KirinDave: yes.  Modules can reexport other symbols and even whole modules
21:55:09 <Eduard_Munteanu> danharaj: hm, is there any particular module where that stuff might reside?
21:55:38 <danharaj> Eduard_Munteanu: this should be useful http://www.haskell.org/haskellwiki/GHC/As_a_library
21:55:46 <KirinDave> Thanks for the applicative help
21:55:51 <danharaj> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html
21:55:51 <KirinDave> Helped me clean up playMaze substantially in http://hpaste.org/46207/mainhs
21:55:53 <Eduard_Munteanu> danharaj: thanks
21:56:28 <lispy> danharaj: so one thing I would ask you about parallelism.  Can repa's parallelism beat the speedup of using GPGPU stuff or shader based stuff?
21:56:42 <danharaj> lispy: yes/no.
21:56:55 <luite> gienah: and as for dynamic linking exceptions, are there any known cases of LGPL library authors that specifically didn't want their libraries to be linked (statically or dynamically) to non-GPL programs?
21:56:57 <Eduard_Munteanu> Neato, getNamesInScope looks like a place to start.
21:57:01 <danharaj> lispy: yes if your code has any sort of non-uniform control. :D
21:57:02 <lispy> danharaj: what I'm hearing from a friend is that a lot of the parallel algos he's been trying in Haskell (sometimes using repa) is that they are often very slow.
21:57:46 <danharaj> lispy: I wouldn't know about that. I have seen the examples provided by the repa team and my own code (fairly trivial). I would trust your friend, but he should definitely give his feedback to the Repa team.
21:57:51 <Eduard_Munteanu> lispy: well of course not given how GPGPUs work and some of their applications.
21:57:55 <danharaj> lispy: They seem to be seriously aggressive about performance.
21:58:11 <lispy> danharaj: One thing I would like to do in Haskell is implement some sort of high performance graphics middleware.  Something that works for scientific viz or a 3d game.
21:58:36 <luite> unreal engine bindings ;p
21:58:42 <lispy> danharaj: I think he's been talking to them, not certain
21:58:58 <lispy> luite: Yeah, maybe it's a pipe dream :)
21:59:09 <lispy> We do have irrlicht and ogre3d bindings already
21:59:14 <danharaj> lispy: I want to start working on writing games in Haskell soonish (my classes end this month) and there's a ton of foundation that needs to be laid by the community in terms of library support for such a thing.
21:59:48 <danharaj> lispy: all we have right now are basically thin wrappers to C/++ code, which I think is inadequate.
21:59:53 <lispy> danharaj: yeah, we need better datastructures.  We need octtrees, kd-trees, etc.  We need physic stuff (or maybe hipmunk is enough?).
22:00:02 <djahandarie> I'd definitely like to see more Haskell game stuff
22:00:11 <lispy> danharaj: I haven't even looked at what we have for audio, but there is an OpenAL binding
22:00:15 <djahandarie> I know a lot of people are working on it, but I feel like I don't see much contributed back
22:00:21 <lispy> Do you guys know about #haskell-game?
22:00:31 <danharaj> lispy: I've heard of such a mythical place. :)
22:00:32 <dmwit> Argh, minBound and maxBound are in the same class.
22:00:42 <copumpkin> dmwit: yay!
22:00:49 <djahandarie> Yeah, I never put it on my autojoin though so I forgot about :p
22:00:58 <dmwit> copumpkin: What?
22:01:07 <copumpkin> dmwit: same class, yay!
22:01:10 <copumpkin> </sarcasm>
22:01:14 <dmwit> haha
22:01:18 <Eduard_Munteanu> dmwit: interesting, you want stuff that's bounded at one end only?
22:01:18 <dmwit> They'll sit together for sure!
22:01:22 <dmwit> They're inseparable.
22:01:27 <dmwit> Eduard_Munteanu: Yep.
22:01:49 <dmwit> Eduard_Munteanu: For example, newtype AddMax a = AddMax (Maybe a).
22:02:11 <dmwit> newtype Interval a = Interval (AddMin a, AddMax a) for open intervals that include infinity.
22:02:12 <Eduard_Munteanu> Albeit one might take another approach and generalize it to the multidimensional case.
22:02:28 <Eduard_Munteanu> Where just two typeclasses won't do.
22:02:29 <lispy> danharaj: I'm a huge fan of the approach where you try to write something that requires 1 more library than you current have.  Add that library and finish your project.  Then write something that needs 1 more library than you have.  Add that library, etc.
22:02:36 <djahandarie> minBound = error "Haskell sucks"
22:02:36 <dmwit> copumpkin: Oh, as an aside, I figured out how to stick six tetrahedra in a cube.
22:02:41 <copumpkin> :O
22:02:43 <lispy> danharaj: Build the tools you need by induction.
22:02:46 <luite> gienah: I can imaging that as a company investing huge amounts of money in a project, takign the risk of using "less free than preferred" LGPL libraries is slightly undesirable, but I can hardly believe that it's a significant risk compared to being sued for softwar/algorithmic patents
22:03:04 <dmwit> copumpkin: Remember the five tetrahedra? One of them was "too big" by a factor of two. ^_^
22:03:16 <copumpkin> ooh!
22:03:40 <danharaj> lispy: That's what I've been doing, but I tend to get exasperated either learning enough about something to implement my own solution, or learning how someone else implements it and what the limitations are etc.
22:03:46 <dmwit> Or, rather, it was the right size in the usual metric, but I was using the Manhattan metric...
22:04:12 <Eduard_Munteanu> What? :)
22:04:29 <danharaj> lispy: And I have a distaste for adding yet more dependencies to C libraries. Haskell is mature enough to support some of the heavy lifting needed for game development natively. Just have to get the manpower behind such projects.
22:04:37 <lispy> danharaj: Yeah.  I often get stuck in what I call the "recursion problem".  I want to do X, but X needs a good Y.  So I start to work on Y, and I realize it needs a good Z, so I work on Z and so on.
22:04:41 <dmwit> I plan on writing it up tomorrow, so watch haskit. =)
22:04:45 <Eduard_Munteanu> We live in a 2-norm world :)
22:05:00 <danharaj> lispy: I call that the "Where the fuck are all the library writers" problem :p
22:05:04 <dmwit> Eduard_Munteanu: The integer lattice lives in a different norm.
22:05:35 <dolio> Recursion and induction are roughly the same thing.
22:05:38 <lispy> danharaj: I decide I want a good visualization and I end up hacking on cabal :)
22:05:45 <danharaj> lispy: true enough.
22:06:04 <dmwit> lispy: The perl folks call that yak shaving, in case you want a more standardized term.
22:06:14 <danharaj> lispy: anywho I have been simultaneously following the physics thread and the graphics thread, which is why I asked you about your text idea. I think I need to figure out our bearings at some basic level and just add a missing block one at a time.
22:06:40 <Eduard_Munteanu> Hm, I have to look the yak thingy up, it happens to me.
22:06:42 <shachaf> dmwit: Some people refer to it as rat-holing.
22:06:45 <lispy> dmwit: oh, I thought yak shaving was doing something tedious for the sake of pedentary
22:07:03 <dmwit> hm
22:07:32 <shachaf> lispy: I don't think so.
22:07:33 <dmwit> wiktionary agrees with me.
22:07:50 <lispy> danharaj: yeah, I need to just code up enough examples using the freetype2 stuff that I get a feel for what the common operations are and the concrete challenges in coding them.  Then try to make an api that addresses it.
22:08:14 <danharaj> lispy: obviously you should be rasterizing TrueType fonts from scratch.
22:08:18 * shachaf agrees with dmwit, with a caveat.
22:08:44 <luite> lispy: please make a freetype 2 api that makes it easy to get access to the outlines
22:09:17 <lispy> dmwit: oh wow, that is exactly the righ term
22:09:43 <danharaj> lispy: maybe we should get a bunch of people on over a weekend for an online hacking section where we just take apart the whole graphics problem and work on it :)
22:10:05 <lispy> luite: interesting.  What makes the outlines so valuable?  You mean the parametric forms of the glyphs, right?
22:10:13 <danharaj> (spoilers it is impossible to guarantee more than zero people showing up for such a thing)
22:10:54 <lispy> danharaj: we just need to all show up at a hackathon
22:11:16 * dmwit volunteers Hac Phi
22:11:20 <dmwit> No bias at all, I swear.
22:11:28 <lispy> When is that one again?
22:11:44 * lispy may be on vacation then and thus can't attend
22:11:48 <danharaj> July 29-31
22:11:49 <dmwit> July 29-31
22:11:58 <lispy> Hmm...I think I might be unavailable then
22:12:02 <danharaj> I think I might go to it if there's a strong Graphics showing.
22:12:06 <shachaf> lispy: What, for HacPDX?
22:12:07 <dmwit> Ah, super bummer.
22:12:10 <luite> lispy: yes, so the types of splines and the control points. I need them for making a native svg backend for diagrams. this requires the outlines to be converted to svg paths
22:12:40 <lispy> luite: Okay.  I think I made a binding to that part of the binding, but I don't know if I'm the right person to test it.
22:12:43 <luite> lispy: I've already checked the ft2 bindings, but I don't think there's a way to get the outlines directly, not sure though
22:13:36 <lispy> luite: https://github.com/dagit/freetype2/blob/cabalization/Graphics/Rendering/FreeType/Internal/Outline.hsc https://github.com/dagit/freetype2/blob/cabalization/Graphics/Rendering/FreeType/Internal/OutlineGlyph.hsc
22:15:49 <dmwit> ?src max
22:15:50 <lambdabot> max x y = if x <= y then y else x
22:16:06 <luite> lispy: err let's say that it isn't entirely clear to me how to get the actual outline from those :p
22:16:41 <luite> lispy: perhaps I should consult the freetype 2 documentation first and then see if I need anything else
22:17:02 <danharaj> lispy: is there a checklist of tasks that ought to be done?
22:17:19 <danharaj> I am frustrated, and frustration is the mother of code :p
22:18:04 <lispy> danharaj: You can add issues/look up issues for each repo under the haskell-opengl org at github: https://github.com/haskell-opengl
22:18:25 <lispy> danharaj: I'm trying to use that org to manage the project
22:19:06 <lispy> danharaj: maybe I should have created it as haskell-graphics or haskell-viz or something instead.  But, it is what it is :)
22:20:28 <danharaj> lispy: I think I'll take a crack at MArray instances for GLfloat etc. How should I go about this?
22:20:39 <luite> lispy: hmm, I think I see it now... this is terribly low level :)
22:21:18 <lispy> luite: yeah.  It's a raw binding.  If you have ideas about how to make it haskell friendly then patches are most appreciated :)
22:21:41 <lispy> luite: Seems like Haskell should have lots of nice ways to approach it
22:22:06 <luite> yes, although it might not be a bad idea to keep a low level api binding around
22:22:18 <luite> similar to openglraw and opengl
22:22:20 <lispy> danharaj: I think you'll need to find the MArray instances and try to mimic them.  I started to look at it once and it looked like it should work but I can't remember what I figured out.
22:23:10 <lispy> luite: Yeah.  the plan now is to put them in the same library (expose all modules).  If it turns out that the high level stuff is becoming controversial I can do a split like opengl stuff did.
22:24:04 <danharaj> lispy: oi. Looking at all this FFI, unboxing/boxing stuff. Maybe I should stay away from the low level stuff. Ow my head. :p
22:24:25 <lispy> danharaj: It all sort of hinges on the idea that newtypes use the underlying type's representation and you just need to make sure that GLfloat matches the C type as defined in Foreign.C.Types.  To do that I think you need to use CPP or something and that CPP is defined in base?
22:24:27 <luite> danharaj: it's not difficult, just tedious
22:24:39 <danharaj> luite: I find tedium difficult to comprehend.
22:24:40 <luite> and freetype2 is a fairly large lib
22:26:10 <nyingen> Suppose I have a giant text file, in utf-8 encoding with plenty of multibyte characters. Groups of lines in the file constitute records, and I want to read the sequence of records
22:26:16 <nyingen> should I use attoparsec-text?
22:26:34 <dmwit> regexen are not ideal for finding uses of Haskell operators.
22:26:36 <nyingen> I'm not entirely sure how strict it is, from the documentation
22:27:06 * dmwit just typed "ack .?-\\.\\*" just to find occurrences of operator -.*
22:28:04 <lispy> nyingen: well, it should work fine.  In my experience, it's how you call it and feed it that matters in cases like yours.
22:28:18 <lispy> nyingen: you should probably try attoparsec-enumerator
22:28:21 <nyingen> hm, ok
22:29:24 <nyingen> attoparsec-text-enumerator?
22:29:29 <lispy> nyingen: You probably want to chunk your input, say 4k at a time, and then get it to parse 1 record at a time.  You just keep feeding it and get out a stream of records.
22:30:08 <nyingen> I see
22:30:41 <lispy> yeah, that package name looks right.  I haven't tried it, but it should help you feed it.
22:31:02 <nyingen> thanks, I'll look into it
22:32:05 <danharaj> lispy: I think I'll look for some more high level problems to solve and leave these issues to pastorn. >.>
22:32:22 <tymac> hey
22:32:26 <lispy> danharaj: okay :)
22:32:37 <lispy> danharaj: finding libraries that we need is always a good thing
22:33:21 <danharaj> lispy: what do you think of endeavors like GPipe? Should we be shooting for such a high level EDSL?
22:34:02 <lispy> danharaj: I think FFI stuff needs to be layered.  We need good solid raw-level bindings and then you make other libraries on top.
22:34:08 <lispy> danharaj: I haven't looked at GPipe much
22:34:37 <lispy> danharaj: One thing that would be nice is a high level scene description language.  Game engines have had great success using "scene graphs"
22:35:05 <danharaj> lispy: what's a scene graph and where do I go about learning about it?
22:36:23 <lispy> danharaj: the wikipedia page seems really good at a glance: http://en.wikipedia.org/wiki/Scene_graph
22:36:43 <danharaj> lispy: I've been fiddling with building higher level apis over the opengl layer. Trying to find the right abstraction for managing shaders.
22:36:45 <dmwit> I agree with lispy that you need a solid FFI-level binding, but that binding need not be exposed from your second layer if you've got a good second layer.
22:37:05 <dmwit> e.g. Gtk2Hs does pretty well in terms of design.
22:37:31 <lispy> dmwit: I think it can't hurt to expose all your modules.  Even the "internal" ones.  Someone will want access at some point for some reason.
22:37:35 <danharaj> dmwit: it's really a shame gtk looks like balls on windows ._.
22:37:44 <lispy> dmwit: just clearly mark things that will void the warranty.
22:37:56 <dmwit> danharaj: Does it really look different than it does on Linux?
22:38:04 <lispy> danharaj: tools to process collada would be nice too: https://collada.org/mediawiki/index.php/COLLADA_-_Digital_Asset_and_FX_Exchange_Schema
22:38:06 <dmwit> danharaj: Or do you just think gtk looks like balls everywhere?
22:38:14 <lispy> dmwit: it doesn't looks like windows
22:38:24 <kmc> "those? those are balls."
22:38:37 <dmwit> Yes, I understand that. But does it look *bad*? That's really a different question.
22:38:49 <danharaj> dmwit: if it doesn't mesh with the native environment, it looks bad.
22:38:49 <horms> is there a theme to make it look more like windows?
22:39:15 <danharaj> it functions bad in some cases too. some gtk dialogs work differently from native ones.
22:39:16 <dmwit> Okay. So you wouldn't mind if all Windows applications were written in Gtk?
22:39:16 <lispy> dmwit: Not native == bad, IMO
22:39:54 <danharaj> dmwit: I don't know. Probably not?
22:40:13 <dmwit> Fine. I understand your position, and nevertheless do not share it.
22:43:47 <dmwit> Okay, informal poll time.
22:43:55 * copumpkin pulls out his hand
22:44:20 <dmwit> I've got intervals represented as (minimal element in the interval, maximal element in the interval).
22:44:35 <dmwit> I've also got an operation which is supposed to scale intervals (around 0).
22:44:55 <dmwit> What would you expect this operation to do to the interval (-infinity, infinity)?
22:45:02 <dmwit> err
22:45:20 <dmwit> More specifically, what would you expect it to do when scaling *by 0*.
22:45:28 <lispy> N/A
22:45:32 <danharaj> ^
22:45:35 <copumpkin> > infinity * 0
22:45:36 <lambdabot>   Not in scope: `infinity'
22:45:41 <lispy> > (1/0) * 0
22:45:42 <lambdabot>   NaN
22:46:00 <dmwit> Hm.
22:46:02 <copumpkin> dmwit: devise a law or two for your scaling operation
22:46:04 <dmwit> That's really inconvenient.
22:46:05 <copumpkin> then pick whatever makes sense
22:46:26 <danharaj> lispy: The specification for Collada is 500 pages long. I'm scared :p
22:46:52 <lispy> danharaj: it's mostly just xml boilerplate, right
22:46:54 <lispy> ?
22:47:02 <danharaj> lispy: yes.
22:47:05 <danharaj> 500 pages of it.
22:47:08 <lispy> danharaj: So, to continue with the yak shaving, now we need a good xml library :)
22:47:14 <danharaj> indeed.
22:47:27 <lispy> HXT is what someone told me to use the last time I complained about xml in Haskell
22:47:33 <Shahed> Anyone interested in working at a start-up company??
22:47:54 <danharaj> Shahed: That could be described as one of my idle desires?
22:48:01 <lispy> Shahed: Can I be CTO?
22:48:18 <lispy> Chief Tyranical Officer
22:48:22 <Shahed> lipsy, depends, I need to see some work though
22:48:23 <lispy> I rule by fiat
22:48:37 <lispy> I answer only to the board
22:48:53 <Shahed> We're looking for developers and web designers.
22:49:07 <danharaj> I want to be Chief Tyranosaurus Officer.
22:49:14 <djahandarie> Haha
22:49:21 <dmwit> Shahed: There are a few less luck-based way to look for Haskell employees.
22:49:34 <lispy> Shahed: Have you tried Haskellers.com?
22:49:37 <dmwit> (I say luck-based because only people who happen to be looking at the channel just now will see your message.)
22:49:45 <danharaj> yes. haskellers.com is an excellent starting point.
22:49:56 <danharaj> (Also luck based because idiots like me will see your message)
22:50:00 * djahandarie is not impressed that Shahed couldn't find haskellers.com or functionaljobs.com ;))
22:50:08 * ddarius hasn't even looked at haskellers.com since it was announced.
22:50:13 <dmwit> haskellers.com, and haskell-cafe@, and...?
22:50:27 <djahandarie> ddarius, quite a lot of folks have signed up
22:50:32 <djahandarie> Plenty in the boston area :p
22:50:52 <djahandarie> (Still only two in CT...)
22:51:30 <copumpkin> Shahed: you'd probably want to give a tiny bit of detail before people start approaching you (like, is the startup even using haskell?)
22:51:33 <danharaj> Can someone give me a quick overview of the RWS monad?
22:51:39 <djahandarie> (The state's acronym is shared with that of Category Theory! Why aren't there more Haskell programmers??)
22:51:54 <ddarius> It's ReaderT ∘ WriterT ∘ State
22:52:09 * danharaj facedesk
22:52:11 <danharaj> 2 am disease
22:52:13 <danharaj> of course it is.
22:52:26 <lispy> dmwit: oh, ddarius just reminded me why gtk2hs sucks on windows.  UTf8 is broken.
22:52:41 <djahandarie> I recall the 2am disease to also go by a name called "insomnia"
22:52:51 <dmwit> Oh, well.
22:52:52 <dmwit> Yes.
22:52:56 <Shahed> I'm looking at the experience of each programmer and web designer that is interested in the position, before I describe the start-up.
22:52:58 <lispy> dmwit: er, I may have overspecialized that.  It's a gtk issues.
22:53:04 <danharaj> djahandarie: I use it to refer to the phenomenon that I am a complete idiot late at night.
22:53:25 <dmwit> Shahed: No offense, but don't you think that's a bit of a red flag?
22:53:27 <Shahed> Anyone good with Web Design/PhotoShop/etc
22:53:50 <dmwit> Shahed: Also, this probably isn't really the place for a designer. There might be some here, but only by coincidence.
22:54:00 <djahandarie> Shahed, wait, does this have nothing to do with Haskell or programming even? :p
22:54:06 <Shahed> Okay, any good place to find them?
22:54:07 <djahandarie> You're totally in the wrong place if so...
22:54:09 <dolio> IT'S A SECRET TO EVERYBODY.
22:54:24 <danharaj> BUY SOMETHING WILL YA?
22:54:27 <Shahed> It has to do with programming djahandarie, probably not Haskell
22:54:43 <lispy> A secret is something everyone knows but no one seems to be talking about.
22:54:45 <dmwit> Protip: nobody is short on start-up ideas. It's *time* and *money* that people are short on.
22:54:55 <danharaj> also talent.
22:55:07 <Shahed> I never said anyone was short on ideas.
22:55:08 <lispy> dmwit: yeah, kickstarter is cool because it solves the second one
22:55:51 <djahandarie> increaseTalent : Time -> Person -> Person. Redundant.
22:55:52 <Shahed> lispy: KickStarter doesn't fund into businesses, just projects.
22:56:16 <danharaj> Which can be the beginning of a company.
22:56:17 <dmwit> Shahed: Rephrased, probably nobody wants to steal your idea. Also, if you're super-jealous, it won't be that fun working with you. That's a big strike for startups.
22:56:45 <dmwit> Shahed: I don't mean this to be an insult to you, just an observation of a bad pattern in job offers that many programmers have come to recognize.
22:56:59 <danharaj> lispy: HXT has an absurdly large surface area. Christ what a library.
22:57:03 <Shahed> What do you reccomend? dmwit
22:57:14 <dmwit> Just tell people what you're thinking of doing.
22:57:21 <lispy> danharaj: heh.  I used the library, "xml" the last time I did xml.
22:57:27 <dmwit> Let them judge whether they want to apply based on whether they think that's a worthwhile project or not.
22:57:34 <lispy> danharaj: I meant to look at HXT but I only look at libraries when I need them
22:59:07 <lispy> dmwit: someone should make a new website that puts a new face on newsgroups and forums.  yahoo answers, stack-{overflow,exchange}, reddit/digg, ad nausem are not enough
22:59:29 <lispy> just sharing my startup idea
22:59:57 * djahandarie thinks that "ad nausem" in the pitch perhaps makes it look at little weak
22:59:58 <dmwit> Sound sucks on Linux. There's too many different choices for infrastructure. We should make a new one.
23:00:18 <lispy> djahandarie: hehe
23:00:22 <dmwit> ...as long as we're sharing shitty ideas
23:00:35 <dmwit> ;-)
23:00:43 <djahandarie> This chair is uncomfortable. We should make a new one.
23:00:49 <lispy> dmwit: oh!  Or a new GUI library from scratch in C.
23:00:57 <djahandarie> C? Let's use ASM.
23:00:58 <dmwit> hahaha
23:01:07 <danharaj> ASM?
23:01:16 <danharaj> I have a horse-shoe magnet, let's do this.
23:01:40 <dmwit> Actually, making a comfortable chair made the Aeron folks pretty rich, didn't it?
23:01:41 <lispy> danharaj: I was going to use vim to edit my files.  I don't think magnets work with SSD :(
23:01:59 <danharaj> lispy: Hmm. Time to create a new universe with the laws of physics we want.
23:02:03 <lispy> dmwit: Really?  What comfortable chair has Aeron ever produced?
23:02:10 <dolio> You should just write bindings to Étoilé.
23:02:13 <lispy> dmwit: I think they just make chairs that look nice
23:02:25 <dmwit> no no no
23:02:41 <dmwit> They made a chair that was really comfortable and ergonomic, and it almost flopped because nobody thought it looked very good.
23:02:46 * lispy wonders if this should be moved to -blah
23:02:57 <danharaj> back on topic
23:02:58 * dmwit shuts up
23:03:53 <lispy> dmwit: I have an aeron chair at work and I can't sit in it very long before my SI joint hurts but maybe I'm a special case.  The chair I had before this one was much better as the base of the chair was actually adjustable.
23:04:40 * dmwit stays shut up
23:04:55 * djahandarie summons dmwit into -blah
23:07:56 <ddarius> That chair looks like the one I have at work.  I've never thought a thing one way or another about it.
23:09:35 <danharaj> hmm
23:09:51 <danharaj> Setting up a bunch of geometry data to render seems like it's well fitted by an RWS monad.
23:10:11 <danharaj> I will think about this more.
23:11:37 * ddarius has never used RWS(T).
23:12:03 <danharaj> if you can resist the urge to use a shiny toy for the sake of its shininess, you are a better man than me.
23:12:15 <dolio> I rarely have a use for writer, so it tends to be overkill.
23:14:17 <danharaj> as I understand it, RWS is the separation of read-only state, write-only state, and unrestricted state?
23:15:24 <copumpkin> @unmtl RWST (RWST Int Int Int [] Int) (RWST Int Int Int [] Int) (RWST Int Int Int [] Int) (RWST Int Int Int []) Int
23:15:24 <lambdabot> (Int -> Int -> [(Int, Int, Int)]) -> (Int -> Int -> [(Int, Int, Int)]) -> Int -> Int -> [(Int, Int -> Int -> [(Int, Int, Int)], Int -> Int -> [(Int, Int, Int)], Int, Int)]
23:17:54 <ddarius> copumpkin: ?
23:18:15 <ddarius> danharaj: I don't consider it "shiny" at all.
23:18:19 <copumpkin> just screwing around :)
23:18:37 <danharaj> ddarius: It's worse than I thought. You're an adult :o
23:20:53 <tolkad> How do you think this article could relate to haskell? http://www.adequacy.org/stories/2002.5.16.143527.295.html
23:21:02 <tolkad> Does haskell still use the old kind of science?
23:21:20 <djahandarie> tolkad, that feels incredibly unrelated to haskell :p
23:23:21 <tolkad> djahandarie: Tell me more about how you feel
23:24:06 <danharaj> that is totally blah material
23:24:16 <danharaj> but that site has to be a parody, considering how hard I'm laughing at it.
23:24:29 <dmwit> ?hoogle Ordering -> Ordering
23:24:30 <lambdabot> Prelude pred :: Enum a => a -> a
23:24:30 <lambdabot> Prelude succ :: Enum a => a -> a
23:24:30 <lambdabot> Prelude id :: a -> a
23:24:36 <dmwit> lame
23:24:48 <dmwit> No order-swapper?
23:24:54 <bambam> flip
23:25:03 <djahandarie> ...
23:25:04 <dmwit> Won't work here, sadly.
23:25:09 <djahandarie> > flip LT
23:25:10 <lambdabot>   Couldn't match expected type `f (a -> b)'
23:25:10 <lambdabot>         against inferred type `GH...
23:25:19 <dmwit> djahandarie: He means flip the call to compare.
23:25:30 <bambam> :t toEnum . (2 -) . fromEnum :: Ordering -> Ordering
23:25:31 <lambdabot> Ordering -> Ordering
23:25:35 <bambam> tada!
23:25:50 <dmwit> But I'm defining a "class MixOrd a b where mixCompare :: a -> b -> Ordering", so "flip" won't cut the mustard.
23:25:52 * bambam hides in shame
23:26:43 <dmwit> Wow, that looks really GHC-specific.
23:27:04 <dmwit> > fromEnum . [LT, EQ, GT]
23:27:06 <lambdabot>   [0,1,2]
23:27:29 <djahandarie> > flіp LT
23:27:31 <lambdabot>   GT
23:27:38 <dmwit> Oh, you.
23:27:48 <dmwit> > "flіp"
23:27:49 <lambdabot>   "fl\1110p"
23:27:52 <dmwit> You can't fool me.e
23:27:53 <shachaf> > map (compare EQ) [LT,EQ,GT]
23:27:54 <lambdabot>   [GT,EQ,LT]
23:28:02 <dmwit> shachaf: Oh, that's beautiful.
23:28:07 <copumpkin> clever!
23:28:08 <djahandarie> shachaf, that's actually pretty nifty
23:28:46 <tolkad> There is a celluar automata simulator for haskell. Perhaps by using it we could modernise haskell by applying the principles of the new kind of science. This might also make computer science more friendly to female students as described in this prestigious article: http://www.adequacy.org/stories/2002.5.16.143527.295.html
23:28:51 <tolkad> http://sourceforge.net/projects/hcellauto/
23:29:43 <copumpkin> @remember tolkad Perhaps by using it we could modernise haskell by applying the principles of the new kind of science
23:29:43 <lambdabot> Done.
23:30:04 <danharaj> I wonder what lambdabot has remembered about me
23:30:07 <danharaj> @quote danharaj
23:30:07 <lambdabot> danharaj says: phd programs are one-way functions. They're easy to get into and hell to get out of ;)
23:30:13 <tolkad> @quote tolkad
23:30:13 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
23:30:32 <danharaj> Dear past me: astute observation.
23:30:41 * copumpkin got out of his
23:30:51 <danharaj> congratulations copumpkin
23:30:55 <copumpkin> yay!
23:31:06 <danharaj> Is your thesis posted online?
23:31:11 <copumpkin> no, I quit
23:31:15 <copumpkin> that's what I meant by getting out of :P
23:31:22 <dmwit> My, you're enthusiastic tonight. Lots of cheering.
23:31:25 <danharaj> that's even more impressive
23:31:36 <copumpkin> dmwit: I'm always enthusiastic!
23:31:42 <danharaj> What else have I said...
23:31:47 <danharaj> @quote danharaj
23:31:47 <lambdabot> danharaj says:  The industry wields types like an ancient weapon of forgotten technology.
23:31:52 <tolkad> Is getting a phd hard? don't you just have to write a paper on something or other
23:32:06 <danharaj> tolkad: It's probably the hardest thing you can do with your brain.
23:32:09 <dmwit> tolkad: Well, usually you've got to write rather a lot of papers.
23:32:15 <danharaj> (well, it's all relative but it can be that hard)
23:32:40 <dmwit> And they don't pay you very well, and you're often working on a tiny subproblem of a subproblem whose solution might never see the light of day.
23:32:46 <dmwit> ...and I think I just made myself sad.
23:32:50 <nyingen> ouch, me too :(
23:33:01 <nyingen> copumpkin: you quit a phd?
23:33:12 <copumpkin> damn right!
23:33:18 <danharaj> Until you realize that subsubsolutions are the engine of progress
23:33:25 <danharaj> as I once said...
23:33:27 <danharaj> @quote danharaj
23:33:27 <lambdabot> danharaj says: phd programs are one-way functions. They're easy to get into and hell to get out of ;)
23:33:29 <tolkad> Couldn't you just make up some obscure question nobody has ever bothered to answer in CS graph theory?
23:33:44 <shachaf> dmwit: Oh, you're a PhD student, aren't you.
23:33:59 <tolkad> and answer that
23:34:03 <danharaj> tolkad: Finding problems is harder than finding solutions.
23:34:31 <danharaj> Most PhD's I know actually struggled more with the former than the latter
23:34:46 <nyingen> copumpkin: after how many years?
23:35:01 <copumpkin> just two :)
23:35:42 <nyingen> ah
23:36:00 <nyingen> I'm 5 years in, and have been seriously thinking about quitting
23:36:29 <copumpkin> I figured if I didn't do it early, it'd turn into more and more of a sunk cost and I'd be staying for the wrong reasons :P
23:36:30 <dmwit> It gets harder the longer you stay, I hear.
23:36:36 <danharaj> nyingen: But there's science to be done :[
23:36:43 <nyingen> copumpkin: I believe I'm now in that situation
23:36:50 <copumpkin> danharaj: on the people who are still alive?
23:37:05 <danharaj> I don't know, is nyingen a biologist?
23:37:21 <nyingen> danharaj: nope
23:37:33 <copumpkin> I'm not even angry
23:37:34 <danharaj> nyingen: Do you do science on people?
23:37:43 <nyingen> I've actually made good progress on my research, but I've grown to really hate it
23:38:02 <danharaj> I know a few people who have been in that situation.
23:38:04 <nyingen> plus my advisor is not a pleasant guy
23:38:24 <tolkad> When does CS start getting challenging? I just finished my second year of undergrad and learned some assembly, some stuff about graph theory, grammars, finite automata, first-order logic, algorithm analysis, and other discrete mathematics stuff. I haven't found anything particularly hard so far though
23:38:24 <ddarius> Unless completeing the PhD is going to actually benefit you, who cares about the sunk cost?
23:38:29 <danharaj> One of them realized they preferred teaching and just got out with their masters and is looking for a professorship at a teaching college.
23:38:43 <ddarius> tolkad: Not in undergrad.
23:38:45 <danharaj> The other realized they'd rather make video games and got out with their masters to join a game studio.
23:38:53 <danharaj> nyingen: Follow your heart etc.
23:39:36 <nyingen> Right, I can't figure out whether the phd is really worth the effort or not
23:39:39 <nyingen> no easy answer to that one
23:40:02 <danharaj> nyingen: I think a phd appreciates in self-worth value as you get older.
23:40:07 <ddarius> Figure out what you want and estimate whether a PhD helps in achieving that.
23:40:17 <danharaj> But I can't tell you how much utility it has economically, for example.
23:40:21 <nyingen> right
23:40:42 <ddarius> danharaj: "Appreciates in self-worth"?  You need a piece of paper to feel happy about yourself?
23:40:45 <dolio> I thought they had negative economic value.
23:40:47 <tolkad> ddarius: well I guess all CS students want to specialize in machine learning at first
23:40:58 <ddarius> tolkad: I doubt that.
23:41:44 <danharaj> ddarius: I need certain liquid ingestables to feel happy about myself :(
23:42:01 <danharaj> ible*
23:42:37 <dmwit> ddarius: No. That's simplifying things too much, and you know it. You're being dishonest.
23:42:52 <dmwit> Knowing you completed a difficult task makes you feel happy about yourself.
23:42:58 <tolkad> I don't understand quantifying self-worth. How is it useful?
23:43:32 <danharaj> tolkad: Being satisfied with yourself generally makes you healthier.
23:43:47 <dmwit> Being satisfied with yourself generally makes you more satisfied.
23:43:56 <ddarius> dmwit: You can do that without a PhD, and completeing a difficult task doesn't necessarily make you feel happy about yourself, especially if the benefit is low and opportunity costs (and actual costs) are high.
23:44:09 <tolkad> danharaj: So then don't be unsatisfied. What does this have to do with anything else?
23:44:26 <dmwit> ddarius: Oh, yes, there are tradeoffs. There always are. But a PhD is not just a piece of paper.
23:44:33 <dolio> Why doesn't Const have an Eq instance?
23:44:39 <tolkad> Your speaking as if you don't have control over your own thoughts
23:44:56 <ddarius> dmwit: It (ideally) represents something, but you can do the something it represents without the paper.
23:44:59 <tolkad> You're*
23:46:05 <ddarius> dmwit: At any rate, I don't really see much point in being miserable for something that you deem to have low apparent value on the off chance that you'll feel good about having suffered through it later on.
23:46:15 <dmwit> ddarius: If you're going to do it anyway, you might as well get the paper, too.
23:46:27 * dmwit nods
23:46:44 <dmwit> I agree. I don't see the point in that, either.
23:46:51 <ddarius> dmwit: That's assuming that all the bullshit associated with a PhD is also what it is viewed as representing.  I don't think that's the part people feel proud of later on.
23:47:03 <ddarius> s/with a/with getting a/
23:49:33 <ddarius> If you're happy doing what you're doing, and it will end in you getting a PhD, then certainly carry on.  But if you're not happy doing what you're doing, the piece of paper in the end probably needs more tangible value to be worthwhile.
23:49:46 <edwardk1> dolio: submit a library proposal
23:49:48 <tolkad> I am studying computer science because I want to understand as much practical information as I can about computation and machine learning
23:50:52 <tolkad> Because it's really interesting. I assume someone would get a PhD for similar reasons
23:51:15 <ddarius> tolkad: That's a reason to study it, not to get a PhD in it.
23:51:58 <tolkad> ddarius: By getting a PhD, aren't you getting payed to do independent study?
23:52:26 <danharaj> you're getting paid something that sometimes qualifies you for welfare.
23:52:36 <danharaj> and no, you're getting paid for teaching.
23:52:43 <danharaj> (usually)
23:52:57 * ddarius waits for edwardkω 
23:53:43 <dobblego> if you think Functional Java is bad, wait until you see Java
23:54:19 <nyingen> heh
23:55:48 * ddarius has a credit card transaction that occurred on May 2nd 2011.
23:56:13 <shachaf> ddarius: Impressive.
