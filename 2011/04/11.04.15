00:00:31 <BMeph> amalloy: Reused.
00:00:49 <dankna> booooo the author of the SDL-mixer package included a generated configure script but not the source file for it
00:01:09 * MatrixFrog wanders off looking for something else that might work
00:01:17 <dankna> heh :)
00:01:33 <mzero> right - so I'm thinking ... as we compile along... we need to know at any given point --- which symbols are valid variables -- and where we allocated them (so we can emit code that uses them, say).... and the list of instructions emitted so far ( if this is one pass)... and things like names of functions we've seen (or not yet) and compiled ans where they are... etc....
00:02:09 <christo_m> mzero: when you say where they are, do you mean where they are in the stack
00:02:16 <christo_m> im not sure how else to determine this
00:02:22 <mzero> right
00:02:28 <mzero> well - where ever you're going to put them
00:02:31 <mzero> in registers?
00:02:36 <mzero> on the stack?
00:03:02 <mzero> (doesn't know the model of Lua -- but bets lexical block language?)
00:03:07 <christo_m> yes.
00:03:16 <mzero> (can you use things before they are declared?
00:03:21 <BMeph> on the heap? In the clouds? ;þ
00:03:21 <christo_m> no.
00:03:30 <christo_m> im pretty sure you cant
00:03:35 <mzero> not even mutually recursive functions?
00:04:06 <RayNbow`TU> ah
00:04:24 * RayNbow`TU solved his hmatrix/Windows problem
00:04:41 <ickabob> how does one do that?
00:04:42 <RayNbow`TU> apparently the dll path should also be in the path env variable
00:04:52 <christo_m>  Lua implements proper tail calls (or proper tail recursion): in a tail call, the called function reuses the stack entry of the calling functio
00:04:56 <napping> amalloy: the syntax to the right of | may actually be the same, but <- works differently
00:05:06 <christo_m> mzero: i guess i can just keep repointing to the stack entry for that frame
00:05:42 <christo_m> http://www.lua.org/manual/5.1/manual.html#8
00:05:47 <christo_m> functioncall is a statement in the grammar
00:05:50 <dankna> MatrixFrog, I don't remember what state this is in, it might possibly not work at all (it won't crash though), but you could have a look at a project of my own, unfinished:
00:05:55 <christo_m> they must be talking about statements of the form, return functioncall
00:05:56 <dankna> (this is a Windows build of it that I made a while ago)
00:06:01 <dankna> http://dankna.com/himitsu/HihiWin.zip
00:06:38 <dankna> and source is in http://dankna.com/himitsu/hihi/
00:07:00 <dankna> noting however that it uses my own Emerald Frame library (an SDL replacement), which isn't finished either :)
00:07:14 <dankna> source for that is available from http://dankna.com/software/
00:07:19 <blackdog> mzero: you open to pull requests? just spelling etc.
00:07:30 <mzero> yup
00:07:35 <MatrixFrog> hehe mmmmk
00:07:35 <phrygiangates> is there a way to specify a haskell file to import something from the current directory
00:08:00 <mzero> bed time for me
00:08:00 <napping> a plain import doesn't work?
00:08:08 <christo_m> mzero: :O
00:08:09 <mzero> laters all -- best of luck christo_m 
00:08:15 <christo_m> noooooooooo
00:08:19 <christo_m> goodnight, thanks for your help
00:08:20 <dankna> my Mac build of it supports the following features: walking around, picking up hearts, not walking through solid objects, pushing emeralds, and being followed around by skulls after picking up all the hearts.
00:08:21 <christo_m> i appreciate it
00:08:22 <mzero> I got work in the morning !!!!
00:08:28 <christo_m> i understand
00:08:32 <christo_m> haha, ill figure it out, somehow
00:08:34 <dankna> it also has both background music and sound effects (well, singular)
00:08:35 <mzero> blackdog: let me know how it goes --- 
00:08:43 <mzero> nigth
00:08:52 <christo_m> im so fucked.
00:08:55 <dankna> and animation in both the water (isn't that gorgeous water?  can you believe it's only two frames?)
00:08:58 <dankna> and the sprites
00:09:00 <phrygiangates> napping: nope
00:09:21 <phrygiangates> says: failed to load interface for 'CustTree' which is the module written
00:09:28 <phrygiangates> in a CustTree.hs file in the same directory
00:09:33 <dankna> Windows version probably has some subset of those features
00:10:42 <dankna> also, the music I can't take credit for; it is by Someone Mercadante, and has been out of copyright for hundreds of years.  everything else is my own work :)
00:12:40 <napping> are you calling ghc without --make?
00:12:46 <phrygiangates> yes
00:12:47 <phrygiangates> i am
00:12:50 <phrygiangates> is that a mistake?
00:13:19 <MatrixFrog> i bookmarked that
00:13:26 <MatrixFrog> but i think HPong is actually working
00:13:40 <dankna> haha okay cool
00:13:55 <dankna> if games are your thing, by the way, #haskell-game is quiet right now, but often has traffic during the day
00:14:06 <napping> well, you haven't built the module you are trying to import
00:14:07 <ivanm> dankna: huh? it's day now!
00:14:12 <ivanm> ;)
00:14:21 <napping> with ghci it would interpret the source, with ghc --make it would compile for you
00:14:33 <dankna> ivanm: you must be east of me :)
00:14:34 <amalloy> i haven't gotten to the syntax for function composition yet. i know is the composition operator, but i can't find the right way to use it for this simple case. how would i define something like "succ . +" (which i intend to mean, add two numbers together, then add one)
00:14:40 <MatrixFrog> i have work during the day :(
00:14:44 <ivanm> preflex: seen dcoutts 
00:14:44 <preflex>  dcoutts was last seen on #ghc 13 hours, 58 minutes and 52 seconds ago, saying: so it may block for a while
00:14:45 <MatrixFrog> but cool
00:14:46 <napping> now, it's just like gcc complaining about missing cust_tree.o
00:14:53 <ivanm> dankna: I'm in UTC+10; so it's highly likely ;)
00:15:11 <dankna> +10 eh, wow
00:15:12 <napping> amalloy: (+)
00:15:16 <dankna> where is that, Russia?
00:15:19 <phrygiangates> napping: you rule.
00:15:22 <ivanm> @slap dankna 
00:15:22 * lambdabot smacks dankna  about with a large trout
00:15:23 <espringe> Brisbane :P
00:15:23 <phrygiangates> thanks so much!
00:15:27 <ivanm> espringe: nope
00:15:31 <amalloy> napping: succ . (+) doesn't work
00:15:33 <ivanm> (not as of 14 months ago)
00:15:33 <espringe> East coast of Aus?
00:15:34 * dankna blinks
00:15:37 <ivanm> yup
00:15:39 <dankna> oh
00:15:40 <phrygiangates> so baller.
00:15:40 <dankna> wait, yeah
00:15:45 <dankna> I was off by rather a lot, wasn't I
00:15:48 * MatrixFrog got HPong working. yaaaaaaaay
00:15:49 <espringe> yes
00:15:50 <espringe> :P
00:15:51 <ivanm> dankna: yup
00:15:51 <lefe> (succ .) . (+)
00:15:56 <dankna> somehow I was like "ten hours east of me"
00:16:02 <dankna> rather than "ten hours east of GMT"
00:16:04 <espringe> Russia is in like 10 time zones, but not close to +10
00:16:09 <dankna> yes, haha
00:16:11 <dankna> I know
00:16:46 <christo_m> data Env = Env { syms: [(Sym, Allocation)], insts: [String], funcs: [(String, Signature)] }  are the records concatenation of lists?
00:16:47 <napping> those don't compose nicely.
00:16:51 <amalloy> lefe: still no, and same for (succ .) (+)
00:16:51 <christo_m> hmm let me try something
00:17:22 <amalloy> oh maybe it's sad it can't print it for me. i might need to let it
00:17:43 <MatrixFrog> ok so now that it's after midnight, i can actually start poking around in some code :)
00:17:49 <dankna> MatrixFrog, so I just started up Win to test that version of Hihi and it does work and support everything I mentioned, although it's not quite the bleeding-edge latest
00:17:50 <dankna> haha I see :)
00:17:55 <amalloy> i see, that was it. i'm not used to having things that "can't print"
00:18:10 * BMeph ducks out before the trout-slapping turns nasty...-er. ;)
00:18:13 <christo_m> sorry not concatenation, i mean consing
00:18:17 <lefe> >  ((. succ) . (+)) 5 6
00:18:18 <lambdabot>   12
00:18:23 <MatrixFrog> ok so i see something in the code that says "initialize" and i'm like "what's that?" thinking it's a function
00:18:34 <MatrixFrog> so i open ghci, :l HPong.hs
00:18:43 <MatrixFrog> and say "initialize"
00:18:51 <MatrixFrog> turns out it's an "IO Bool"
00:18:56 <dankna> yeah
00:18:58 <MatrixFrog> so you can do IO things on the ghci REPL?
00:19:01 <dankna> yes
00:19:03 <lefe> :)
00:19:27 <dankna> I take it you're new enough to Haskell that you need explanation of that
00:19:41 <dankna> IO Bool means an IO action which, when executed, returns a Bool
00:20:00 <dankna> I would guess that the boolean is true for success and false for failure
00:20:01 <MatrixFrog> i get what IO is. i watched this yesterday: http://ontwik.com/haskell/simon-peyton-jones-a-taste-of-haskell/
00:20:06 <MatrixFrog> at least to some extent
00:20:06 <dankna> oh okay :)
00:20:23 <MatrixFrog> i just for some reason thought ghci would only evaluate functions
00:20:27 <MatrixFrog> not execute IO actions
00:20:27 <dankna> nope!
00:20:39 <MatrixFrog> well, "some reason" being that i hadn't thought to try it before
00:20:46 <napping> the ghci prompt pretty much tries to parse the line as a statement in a do block in IO, and then if that fails it tries to treat it as an expression with a type in Show
00:21:01 <MatrixFrog> cool
00:21:04 <MatrixFrog> napping++
00:21:10 <MatrixFrog> (is that a thing in this channel?)
00:21:12 <dankna> yes
00:21:14 <MatrixFrog> dankna++
00:21:19 <dankna> oh, thanks :)
00:21:22 <napping> amalloy: -fno-print-bind-result might help a bit later
00:22:24 <napping> as in, :set -fno-print-bind-result \n text <- readFile "hugefile.txt"
00:22:50 <amalloy> napping: i'm doing it all interactively from ghci at the moment anyway; putting LYAH ahead of emacs
00:23:08 <amalloy> lefe: okay, so why do i need that dang . inside of (succ .)? i could understand (succ) . (+) so that succ doesn't try to use . as its first argument
00:23:47 <napping> that's a thing for ghci, if you don't want it to print some results
00:24:13 <napping> beacuse Show also lacks any kind of abbreviation or size limit
00:24:29 <aleator> Hi! I'm looking for fast way to convert bytes in bytestring to vector of doubles.
00:24:44 <aleator> Is there any way to do this with a plain cast?
00:26:20 <blackdog> tibbe: have you run barley for a group? wondering how long three chapters took to take newbies through...
00:26:47 <tibbe> blackdog: I haven't, but mzero (Mark) did during BayHac
00:27:04 <blackdog> right. he's just disappeared. oh well.
00:27:17 <tibbe> blackdog: http://www.haskell.org/haskellwiki/BayHac2011
00:27:19 <blackdog> hoping to take my ruby group through it.
00:27:27 <tibbe> blackdog: he used 4 hours but I'm not quite sure how much he covered
00:27:46 <tibbe> blackdog: there was some time for setup etc that should be a bit easier now
00:27:51 <tibbe> blackdog: drop him an email
00:27:57 <blackdog> tibbe: righto, shall do.
00:28:34 <blackdog> ah, it's not scoped to users/sessions, is it... for a moment i had the bright idea of running one node and having everyone log into it
00:30:02 <blackdog> tibbe: knowing these guys, the first thing they'll do is overwrite each others' code with giant ascii dongs.
00:30:12 <MatrixFrog> i don't suppose hackage has a reverse-dependency lookup?
00:30:22 <lefe> @unpl (. succ) . (+)
00:30:22 <lambdabot> (\ d g -> d + (succ g))
00:30:23 <blackdog> MatrixFrog: didn't cab do something like that?
00:30:26 <lefe> hm.
00:30:31 <MatrixFrog> as in, show me all the packages that depend on this project
00:30:32 <lefe> @unpl (succ .) . (+)
00:30:33 <lambdabot> (\ d g -> succ (d + g))
00:30:42 <MatrixFrog> blackdog: it might, i don't know
00:30:56 <blackdog> MatrixFrog: http://www.mew.org/~kazu/proj/cab/en/
00:31:05 <blackdog> cab revdeps should show reverse deps
00:31:10 <Axman6> @. unpl pl (\x y -> x + y + 1)
00:31:11 <lambdabot> (\ j f -> (j + f) + 1)
00:31:23 <lefe> hm, why did (succ .) . (+) didn't work amalloy ?
00:31:31 <amalloy> lefe: it did work
00:31:36 <lefe> uh
00:31:39 <lefe> ok so
00:31:54 <amalloy> i'm asking why i need the . after succ
00:32:10 <lefe> succ . (+) desn't work, because when you apply 3 to it becomes succ (+ 3)
00:32:12 <MatrixFrog> very cool
00:32:31 <lefe> *doesn't
00:32:33 <Axman6> @unpl (f .) . (<#>)
00:32:33 <lambdabot> (\ d h -> f (d <#> h))
00:32:57 <amalloy> okay, and (succ) . (+) is basically the same?
00:32:57 <lefe> so you need to put one more . so that it becomes succ . (+3) when you apply 3
00:33:10 <Axman6> amalloy: no
00:33:14 <Axman6> @unpl (f ) . (<#>)
00:33:14 <lambdabot> (\ c -> f ((<#>) c))
00:33:16 <tibbe> blackdog: heh
00:33:18 <christo_m> okay, in my compiler, a block is a list of statemetns, except the function mzero wrote earlier only transforms the first block it sees into a [Stmt]
00:33:21 <christo_m> Block [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])]
00:33:26 <christo_m> thats what its like before
00:33:30 * amalloy can't read the output of @unpl
00:33:38 <christo_m> then after: [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])]
00:33:56 <christo_m> i need something thatll go depth first and do it.
00:34:33 <lefe> you could also define an operator like this :
00:34:42 <lefe> > let (<.>) f g a b = f (g a b)
00:34:43 <lambdabot>   not an expression: `let (<.>) f g a b = f (g a b)'
00:34:46 <lefe> hm
00:35:18 <napping> or use a function of one argument, like (uncurry (+)) or sum
00:35:19 <napping> > (succ . sum) [1,2,3]
00:35:19 <napping> 7
00:35:20 <lambdabot>   7
00:35:39 <christo_m> maybe i can somehow recursively do it
00:37:09 * MatrixFrog is slowly starting to wrap my mind around things. maybe
00:37:11 <napping> amalloy: do you know the infix syntax?
00:38:02 <napping> operators are infix, and you put parens around them to get a prefix versoin
00:38:07 <amalloy> napping: i'm not sure? i know that a `f` b is f a b, and that symbol-looking things are infix automatically
00:38:14 <napping> (+) 1 2 is the same as 1 + 2
00:38:31 <amalloy> ah, i didn't realize that exactly
00:39:10 * shachaf realizes that amalloy is a regular but in a different channel.
00:39:11 <napping> for that, and for forming tuples, parens are special
00:39:37 <amalloy> shachaf: yeah
00:39:43 <napping> otherwise just grouping
00:40:28 <amalloy> shachaf: is it wrong for me to think of making-prefix as a special case of grouping? "there are clearly no arguments for you here so make yourself applicable to whatever's coming"?
00:40:40 <amalloy> er, meant to ask napping there
00:40:48 <napping> well, things have fixed arity
00:40:55 <amalloy> right
00:40:58 <shachaf> amalloy: You can think of it as a special-case of sections instead, kind of.
00:41:14 <shachaf> (++"a"), ("a"++), (++)
00:41:40 <amalloy> sections?
00:41:48 <christo_m> data Block = Block [Stmt]  , if i have a data type like this, how can i recursively extract the list of statements out of it
00:41:55 <christo_m> because its a recursive type right? i should be able to do it
00:42:01 <shachaf> amalloy: As in (^2) -- have you seen that syntax yet?
00:42:22 <shachaf> > map (^2) [0..4]
00:42:23 <lambdabot>   [0,1,4,9,16]
00:42:29 <amalloy> shachaf: i'm not sure, but i'd assume it's the clojure (partial ^ 2)
00:42:45 <shachaf> amalloy: Yes, except that 2 is the second argument in this case, because it's on the right.
00:42:49 <napping> I'm not sure it's useful to think of it at anything but a lexical level
00:43:21 <amalloy> > map (2 ^) [0..4]
00:43:22 <lambdabot>   [1,2,4,8,16]
00:43:23 <shachaf> amalloy: At any rate, it's still treated as an infix function, which is just a special-cased syntax in Haskell either way. So it's not quite "regular grouping".
00:43:26 <amalloy> awesome
00:43:26 <napping> Is there some nice interpretation of % in a clojure #( ... ) abbreviation?
00:43:37 <amalloy> napping: % is "the argument"
00:44:16 <amalloy> #(* 2 %) is the haskell (2 *), i guess
00:44:30 <shachaf> #(...) => (\%-> ...) ? :-)
00:44:39 <napping> If anything, maybe you should think of exp + exp as a special form of application instead
00:46:01 <napping> shachaf: you can have more than one, though
00:46:44 <amalloy> napping: well, #(* % %) is squaring, and #(+ %1 %2) is a two-argument + function
00:46:58 <napping> oh, you have to number them
00:46:59 <napping> okay
00:47:19 <napping> must be another language that makes each a separate argument left to right
00:47:41 <amalloy> napping: %& can be used to mean "a list of all arguments"
00:48:05 <amalloy> but yeah, if you want to refer to individual chunks numbering is the way to go (or, really, not using #(...) short-form)
00:48:49 <napping> hmm, perhaps Mathematica - I had in mind one where &[_ + _] means \x y -> x + y
00:51:19 <amalloy> okay. enough haskell for tonight. thanks everyone, i expect i'll be back tomorrow
00:51:40 <christo_m> napping: if i have a recursive type like data Block = Block [Stmt]
00:51:57 <christo_m> how can i write a function to go through it recursively and give me nothing but a list of statements
00:52:17 <napping> that doesn't look like a recursive type
00:52:17 <shachaf> christo_m: What's recursive about that type?
00:52:22 <christo_m> it doesnt?
00:52:35 <christo_m> well, it has Block on both sides
00:52:36 <shachaf> No, it's just using the same name for the type and the constructor.
00:52:43 <christo_m> oh shi..right
00:52:52 <shachaf> They're in different namespaces; it means the same thing as data Block = MkBlock [Stmt]
00:53:34 <christo_m> Block [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])]
00:53:38 <christo_m> my parser returns this
00:53:41 <christo_m> i want to walk through this
00:53:48 <christo_m> and extract the blocks as [Stmt]'s
00:54:16 <christo_m> statements (Block s) = s
00:54:19 <christo_m> if i do this, it happens once
00:54:24 <christo_m> only for the first block, i want to keep doing it
00:54:29 <christo_m> so im assuming recursion.
00:54:55 <shachaf> What's the type of the function that you want, exactly?
00:55:47 <christo_m> statements :: Block -> [Stmt]
00:55:53 <christo_m> or somethnig like that..
00:55:59 <christo_m> i want to convert those blocks to lists of statements
00:57:55 <Ajschylos> :t (.)
00:57:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:58:43 <Ajschylos> @pl f x y = x + y
00:58:43 <lambdabot> f = (+)
00:59:01 <Ajschylos> @pl f x y = x^2 + y^2
00:59:02 <lambdabot> f = (. (^ 2)) . (+) . (^ 2)
01:03:32 <Ajschylos> @run let sq x y = x^2 + y^2
01:03:33 <lambdabot>   not an expression: `let sq x y = x^2 + y^2'
01:05:27 <christo_m> hmm
01:07:06 <Ajschylos> @pl f x y = (x^2 + y ^2)^2
01:07:06 <lambdabot> f = flip flip 2 . ((^) .) . (. (^ 2)) . (+) . (^ 2)
01:08:30 <Ajschylos> @help
01:08:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:08:42 <Ajschylos> 'list'
01:08:49 <Ajschylos> l
01:08:52 <Ajschylos> list
01:09:06 <Ajschylos> @help list
01:09:06 <lambdabot> list [module|command]
01:09:06 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
01:10:26 <Ajschylos> @pl f x y = (x^3 + y ^3)^3
01:10:26 <lambdabot> f = flip flip 3 . ((^) .) . (. (^ 3)) . (+) . (^ 3)
01:17:14 <christo_m> shachaf: any idea or?
01:17:23 <shachaf> christo_m: Huh?
01:18:17 <christo_m> shachaf: i want to take a Block and extract the [Stmt] out of it
01:18:41 <shachaf> I don't know. You haven't given enough context.
01:18:57 <christo_m> well, what more do you need
01:19:10 <christo_m> https://github.com/christomitov/Turnip/blob/master/LuaAS.hs 
01:19:44 <shachaf> I don't need anything. :-)
01:19:54 <christo_m> ok i mean, in terms of contex
01:19:58 <shachaf> There, that was more helpful -- now we know what Stmt *is*, for example.
01:20:01 <MatrixFrog> going to sleep. thanks #haskell! :)
01:21:19 <shachaf> Looks annoying; you'll have to look at each case of Stmt.
01:21:26 <shachaf> Or just use SYB or Uniplate or something like that.
01:21:37 <Ajschylos> @pl  f x y z = x + y + z
01:21:37 <lambdabot> f = ((+) .) . (+)
01:22:06 <Ajschylos> @pl  f x y z = z + x + y
01:22:07 <lambdabot> f = flip . ((+) .) . (+)
01:22:57 <Ajschylos> @pl  f x y z = z + y + x
01:22:57 <lambdabot> f = flip (flip . ((+) .) . (+))
01:23:05 <christo_m> shachaf: hmm.
01:24:29 <MaskRay> Ajschylos: pointless-haskell?
01:25:56 <Ajschylos> Yes, I try to practice a little
01:26:03 <christo_m> shachaf: in parsec , i can getState , and setState
01:26:07 <blueonyx> hi, how to tell Setup.hs not to build profiling libs (because the produce http://friendpaste.com/sz9WwEtQ6Ya9rnmv4Qtb7)?
01:26:21 <christo_m> that might be useful in what im trying to do
01:27:31 <MaskRay> Ajschylos: which package to transform to pointfree style?
01:27:35 <Ajschylos> :t (.(.).)
01:27:36 <lambdabot> parse error on input `)'
01:28:01 <Ajschylos> :t (.($).)
01:28:02 <lambdabot> parse error on input `)'
01:36:56 <blueonyx> what can i do on this snap related error (on archlinux, everything from haskell repo): http://friendpaste.com/BCqkm5JhAOEI0oNvSglFs
01:54:23 <MaskRay> how to use https://github.com/23Skidoo/pointful
01:55:57 * hackagebot buildbox 1.5.0.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.5.0.1 (BenLippmeier)
01:58:57 * hackagebot buildbox-tools 1.5.0.1 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.5.0.1 (BenLippmeier)
02:02:57 * hackagebot pvd 1.1.1 - A photo viewer daemon application with remote controlling abilities.  http://hackage.haskell.org/package/pvd-1.1.1 (RickardNilsson)
02:07:00 <csaba> hi
02:07:51 <ivanm> MaskRay: there's a version on hackage as well I believe
02:08:00 <ivanm> and it comes with documentation
02:08:10 * ivanm waves idly in csaba's general direction
02:08:20 <MaskRay> ivanm: do you mean `pointful'
02:08:33 <ivanm> it's either called pointful or pointless; I forget
02:08:39 <MaskRay> ivanm: I don't know how to get it work 
02:08:57 <ivanm> ahhh, just pointfree
02:09:04 <ivanm> @hackage pointfree
02:09:05 <lambdabot> http://hackage.haskell.org/package/pointfree
02:09:39 <ivanm> https://github.com/benmachine/pointfree/blob/master/README
02:09:56 <ivanm> better yet: http://haskell.org/haskellwiki/Pointfree
02:10:08 <ivanm> (under "tool support")
02:10:09 <csaba> i have this problem: After the newest 32 bit osx haskell platform installation I've installed c2hs succesfully. But when I tried to cabal install a project depends on c2hs i've got this error message: cabal: The program c2hs is required but it could not be found.
02:10:25 <ivanm> csaba: is it in the $PATH ?
02:10:43 <ivanm> i.e. does c2hs --help at the prompt work?
02:11:02 * ivanm can't recall if c2hs comes with ghc or not, and doesn't have ghc on this machine to check :s
02:11:59 <csaba> ivanm: yest c2hs is in path
02:12:05 <csaba> *yes
02:12:08 <ivanm> then I have no idea :s
02:15:08 <csaba> hmm, when i copy c2hs to /usr/bin it works
02:16:15 <csaba> i've added ~/Library/Haskell/bin to PATH. this should be enough?
02:16:41 <csaba> becaus in that case ghc des not found c2hs
02:20:57 <blueonyx> sorry, did anything came up regarding my libHSghc-*.a problem?
02:22:11 <MaskRay> ivanm: `pointful' just does the opposite
02:35:20 <ivanm> csaba: oh, how do you specify your PATH?
02:35:34 <ivanm> IIRC you have to use either /home/foo/.cabal/bin or $HOME/.cabal/bin, not ~
02:35:46 <ivanm> (the former is preferred I think)
02:37:07 <shachaf> ivanm: Why would the former be preferred?
02:37:24 <ivanm> shachaf: I'm trying to remember the discussion on -cafe on this
02:37:25 <shachaf> If it's in your bashrc, that is -- your shell will expand it in the actual environment variable, of course.
02:37:39 <ivanm> I couldn't remember if $HOME was expanded or not
02:37:45 <ivanm> (since ~ isn't)
02:37:52 <chegibari> Hello
02:38:03 * ivanm waves idly in chegibari's general direction
02:38:13 <shachaf> ivanm: In bash, $HOME is expanded in double quotes and ~ isn't.
02:38:18 <ivanm> ahhhh
02:39:25 <chegibari> I read something about polymorphism and the haskell module system. Yesterday I read the haskell report but there was nothing about polymorphism. Is it some "new" module system? Where can I read about it?
02:39:51 <ivanm> I don't think polymorphism has to do with the module system
02:39:59 <ivanm> we definitely don't have ML-style Functors or anything
02:40:04 <ivanm> however, we have typeclasses
02:40:05 <ivanm> e.g.
02:40:08 <ivanm> @src Eq
02:40:08 <lambdabot> class  Eq a  where
02:40:08 <lambdabot>     (==), (/=)   :: a -> a -> Bool
02:40:12 <chegibari> (I mean there was nothing about polymorphism in the chapter about modules)
02:40:39 <ivanm> chegibari: that's what I mean: I can't think of any way in which the module system has to do with polymorphism
02:40:59 <ivanm> unless you by-hand ensure two modules have identical APIs; this certainly isn't enforced in the language in any way
02:41:07 <chegibari> mmh... strange. I think I read about it in "Types and programming languages"
02:41:13 <chegibari> I can't check it right now
02:41:16 <chegibari> Maybe I got confused
02:41:21 <chegibari> thanks
02:41:29 <ivanm> np
02:42:16 <siracusa> ivanm: What are ML-style functors?
02:42:38 <ivanm> siracusa: they have some way of enforcing two modules of having the same API
02:42:41 <ivanm> IIRC
02:43:29 <ski> yeah, they have signatures, which are like types of modules
02:44:05 <chegibari> hi, ski
02:44:21 <ski> and a functor there is a module function, that given any module matching the input signature will produce a module with the specified output signature
02:45:06 <ski> lo chegibari
02:48:24 <_Cactus_> hi
02:48:52 <_Cactus_> I'm porting some code that uses some GHC internals from GHC 6.12 to GHC 7
02:49:17 <_Cactus_> and with 7 source files with no explicit 'module M where' headers don't seem to parse
02:49:54 <_Cactus_> here's my code:
02:49:58 <_Cactus_> http://hpaste.org/45711/ghc_7_parser_barfs_on_source_w
02:51:18 <ivanm> _Cactus_: what are you doing that you need to use GHC's internal parser rather than haskell-src-exts ?
02:51:30 <_Cactus_> ivanm: I'm also using GHC's renamer
02:51:36 <ivanm> OK
02:52:08 <_Cactus_> ivanm: of course, you couldn't tell from this because this is jsut to exhibit the problem:)
02:52:16 <ivanm> *nod*
02:52:25 <ivanm> I've never touched GHC internal stuff, so doubt I can help you
02:52:30 <ivanm> preflex: seen ezyang 
02:52:30 <preflex>  ezyang was last seen on #ghc 17 minutes and 37 seconds ago, saying: But in the process, I discovered another problem :-(
03:24:03 <ezyang> Sorry, I haven't really touched the parser in my travels. 
03:24:29 <ezyang> but I suspect you might have to tell the parser that you're parsing a Main module, as opposed to a module. 
03:32:39 <rostayob> @pl \x y -> x || y && not (x && y)
03:32:39 <lambdabot> liftM2 (.) (||) (ap (&&) . (not .) . (&&))
03:33:56 <merijn> Sometimes I get the feeling @pl is not always an improvement :>
03:35:46 <ClaudiusMaximus> @check (\ x y -> ( x || y && not (x && y) ) == (x /= y) )
03:35:47 <lambdabot>   "Falsifiable, after 3 tests:\nTrue\nTrue\n"
03:36:29 <rostayob> merijn: oh yeah, definitely
03:36:42 <rostayob> i'm just curious about what it will come up with...
03:45:02 <dncr> @check \ x y -> ((x || y) && not (x && y)) == (x /= y)
03:45:03 <lambdabot>   "OK, passed 500 tests."
03:46:43 <rostayob> oh right ehe
03:48:25 <dncr> @pl \ x y -> (x || y) && not (x && y)
03:48:25 <lambdabot> ap (ap . ((&&) .) . (||)) ((not .) . (&&))
03:49:16 <dncr> @check \ x y -> (/=) x y == (ap (ap . ((&&) .) . (||)) ((not .) . (&&))) x y
03:49:17 <lambdabot>   "OK, passed 500 tests."
03:51:07 <dncr> i guess there are only 16 total functions :: Bool -> Bool -> Bool
03:51:38 <dncr> i wonder what the simplest haskell form of each is
03:52:34 <Feuerbach> In external core, is dollar sign just a part of a name, or does it have some special meaning?
03:52:55 <Feuerbach> as in "$wlgo"
04:04:11 <quicksilver> just part of the name Feuerbach although it might give you some clue about where the name came from
04:04:18 <quicksilver> if you understand these things far better than I
04:04:38 <quicksilver> for example, closures created as part of "main" end up with names like "main$1" and so on
04:04:41 <HugoDaniel> hi
04:05:09 <HugoDaniel> how do i convert from a Data.ByteString.Lazy to a Data.ByteString.Internal.ByteString  ?
04:08:54 <quicksilver> HugoDaniel: fromChunks and concat
04:21:20 <philed> 2
04:21:23 <philed> Whoops.
04:56:50 <handonson> so I'd define a monad to express some linear order of side-effects, and I don't need the 'container' capability of monad, because I only need the effects.
04:57:35 <handonson> what should I do? should I just { data MyMonad a = MyMonad a } and always put () for that type variable a?
04:57:51 <Jafet> Would you, could you, on an invisible train!?
04:58:29 <blackh> handonson: So you want your monadic 'actions' always to have a return value of () ?
04:58:40 <Jafet> That should work.
04:58:58 <quicksilver> handonson: that's just a monoid, by the way.
04:59:36 <handonson> well, I just like the way I can use the 'do' construct when I make it a monad.
05:00:11 <quicksilver> I have a personal pet hate of people using the do construct when all they have is a monoid
05:00:13 <handonson> it's like a quick embedded domain specific language that I don't have to write any parser or anything at all to make it work.
05:00:50 <quicksilver> is "mconcat $ [" really so much worse than "do $" ?
05:00:56 <handonson> yes.
05:01:01 <quicksilver> why?
05:01:03 <quicksilver> I don't see it.
05:01:15 <handonson> more concise.
05:01:21 <quicksilver> no it's not.
05:01:29 <quicksilver> it's fewer characters but that is not the same as conciseness
05:01:49 <quicksilver> define 'mo = mconcat' if you like, that saves most of them :P
05:02:09 <handonson> I primarily meant commas.
05:02:11 <aleator> Is this even remotely correct: http://hpaste.org/45712/casting ?
05:02:19 <quicksilver> Don't take me too seriously. I"m only being grumpy. Lots of packages do it - Blaze, Put (), etc.
05:02:40 <quicksilver> but they're all HIDEOUS and should DIE IN A FIRE. Now, I said it. Please continue to write code whichever way you prefer.
05:02:48 <Jafet> You can, of course, define both a Monoid instance and a Monad instance
05:02:59 <Jafet> And confuse people with bad fonts
05:04:24 <handonson> lots of packages doing it may mean there is a need to introduce a new syntax for monoids
05:04:56 <Jafet> Make a JoinList monad
05:05:29 <handonson> so that they can avoid using "monads without values" for monoids, only to take advantage of the do construct
05:06:05 <mm_freak> handonson: for side effects you would usually create some state-like monad
05:06:16 <Jafet> Wait, that can't work without even more typing.
05:06:55 <handonson> mm_freak: well, I think monoid would fit better, as others have pointed out
05:08:05 <handonson> a state-like monad is like { s -> (a, s) }, but the type variable a is not needed if all you want to do is just to order the effects
05:08:12 <mm_freak> handonson: by the way, you don't need a monad to make use of do-notation
05:08:25 <handonson> really?
05:08:48 <mm_freak> i think so
05:08:52 <mm_freak> :t do let x = 3; let y = 5; x+y
05:08:53 <lambdabot> parse error (possibly incorrect indentation)
05:08:55 <mm_freak> hmm
05:09:02 <mm_freak> ok, forget it =)
05:09:56 <mm_freak> :t do 3
05:09:57 <lambdabot> forall t. (Num t) => t
05:10:07 <mm_freak> strange…  why doesn't that work with let, too?
05:10:21 <quicksilver> handonson: yes, I proposed it once or twice
05:10:36 <mm_freak> anyway, you can also get some ordering without too much noise using 'let
05:10:41 <quicksilver> handonson: something like "ff $ .... argument list in layout format ..."
05:10:50 <quicksilver> handonson: using, say $$ or something.
05:11:10 <mm_freak> quicksilver: i think, we proposed that one together, or did you propose it officially?
05:11:11 <quicksilver> but I can't really take the proposal seriously because I really don't consider a comma to be syntax noise.
05:11:22 <quicksilver> mm_freak: not officially no. Just here in this channel.
05:11:30 <Jafet> :t do { let x = 3; y = 5; x+y; }
05:11:31 <lambdabot> parse error on input `;'
05:11:37 <quicksilver> mm_freak: please, go ahead :)
05:11:43 <Jafet> :t do { let x = 3; let y = 5; x+y; }
05:11:44 <lambdabot> parse error on input `;'
05:12:02 <Jafet> Well, it's still going to have a constraint error, so I won't bother
05:12:26 <mm_freak> quicksilver: well, i don't really need it, because my arguments don't get too long
05:12:27 <OODavo> I'm configuring XMonad, and I need a way to turn [String -> IO ()] into a single String -> IO ().
05:12:39 <OODavo> Is this possible, or am I going about it the wrong way?
05:12:51 <mm_freak> OODavo: then you first need to have an idea of how you want to do it
05:12:57 <merijn> OODavo: Why do you need to do that?
05:13:04 <handonson> quicksilver: argument list? you mean list of items?
05:13:07 <OODavo> Yeah, I should provide more context.
05:13:10 <mm_freak> pass the string to all actions and run them in sequence?
05:13:21 <hpc> :t do {let {x=3; y=5;} in x + y}
05:13:22 <lambdabot> forall a. (Num a) => a
05:13:26 <merijn> mm_freak: Oh, I hadn't even thought of that interpretation
05:13:30 <hpc> :t do {let {x=3; y=5;}; x + y}
05:13:31 <lambdabot> forall a. (Num a) => a
05:13:34 <mm_freak> handonson: f $$ x; y = f x y
05:13:38 <OODavo> I'm producing it with "map hPutStrLn [a list of streams]".
05:13:38 <mm_freak> that's the proposal
05:13:52 <hpc> :t do {x <- 3; y <- 5; x + y}
05:13:53 <lambdabot> forall (m :: * -> *) b. (Num (m (m b)), Monad m, Num (m b)) => m b
05:13:58 <mm_freak> OODavo: use mapM_ instead of map
05:13:59 <quicksilver> handonson: either/both.
05:14:02 <mm_freak> :t mapM_
05:14:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:14:04 <merijn> :t hPutStrLn
05:14:06 <lambdabot> Not in scope: `hPutStrLn'
05:14:12 <hpc> > do {x <- 3; y <- 5; x + y} $ 6
05:14:13 <lambdabot>   8
05:14:18 <handonson> well, that would be useful, but that's a little different from monoid syntax
05:14:19 <quicksilver> handonson: one proposal is for functions which take a list as a parameter. the layout delimits the list items.
05:14:21 <mm_freak> handonson: and you will also want to pass a handle to hPutStrLn
05:14:29 <quicksilver> handonson: that's your mconcat case.
05:14:29 <merijn> mm_freak: The lists are the handles
05:14:33 <mm_freak> handonson: there is no "monoid syntax"
05:14:36 <merijn> I'm pretty sure, anyway
05:14:52 <quicksilver> handonson: another proposal is for functions which take arbitrary parameters and you can just put one parameter per line.
05:14:52 <mm_freak> merijn: ok, i see it now
05:15:00 <handonson> mm_freak: i mean the syntax that will support writing monoids like do-notation for monads
05:15:18 <mm_freak> handonson: that would be list syntax
05:15:26 <handonson> since f $$ x; y wouldn't do that
05:15:35 <merijn> OODavo: And you want to write the same string to all those streams?
05:15:43 <handonson> yes, I meant a list syntax that looks like a do-notation.
05:15:58 <OODavo> merijn: Exactly, yes.
05:16:43 <merijn> :t map ($"Test")
05:16:45 <lambdabot> forall b. [[Char] -> b] -> [b]
05:17:14 <merijn> Probably want to compose with >> or something, lemme see if I can figure that out :>
05:18:13 <handonson> OODavo: \ x -> sequence_ [f x | f <- fs] where fs is your [String -> IO ()]
05:18:47 <hpc> :t flip
05:18:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:19:06 <mm_freak> handonson: you don't need syntax for that
05:19:11 <hpc> @pl \x -> sequence_ (flip fs x)
05:19:11 <lambdabot> sequence_ . flip fs
05:19:29 <handonson> mm_freak: I mean, if you consider comma annoying. (which is me)
05:19:37 <handonson> brb
05:19:39 <mm_freak> handonson: i don't
05:20:22 <mm_freak> OODavo: mapM_ is you friend anyway
05:20:49 <OODavo> Hmm. Looks like that still doesn't work in the context, which I haven't provided enough of.
05:21:21 <mm_freak> mapM_ ($ "output string") $ map hPutStrLn handles
05:21:25 <OODavo> It's actually assigning to the ppOutput field of the logHook record, which is of type IO ().
05:21:43 <merijn> :t foldr ((>>) . ($"Test")) (return ())
05:21:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[Char] -> m a] -> m ()
05:21:56 <mm_freak> OODavo: it can only assign Handle
05:22:00 <mm_freak> otherwise you get a type error
05:22:00 <merijn> Of did I screw up associativity and will that print everything in reverse? :>
05:22:05 <merijn> s/Of/Or
05:23:53 <handonson> mm_freak: you don't, but lots of other package writers do, as q·uicksilver has mentioned
05:25:12 <handonson> which is being a source of evil tradition, making sinful empty monads only for the lust of making code beautiful
05:25:49 <handonson> evil includes me
05:25:51 <mm_freak> handonson: well, every haskell programmer (especially newcomers) falls into the desire for less and less line noise at some point
05:26:22 <mm_freak> i did, too, but as soon as you get used to the syntax and make your own personal standards, it isn't that bad
05:26:29 <mm_freak> just compare haskell to other languages
05:27:13 <mm_freak> it's the same with boilerplate code…  how often do you read the query, "why the hell doesn't this combinator exist?"
05:27:40 <mm_freak> somewhere in the prelude, preferably
05:27:57 <mm_freak> haskell is so elegant that people take elegance for granted for every little detail =)
05:29:40 <handonson> okay, I'll give your idea a benefit of doubt and go ahead to use many many commas and see if I can get used to it
05:29:56 <mm_freak> i don't use many commas in my code
05:30:04 <OODavo> Hmm. I managed to make it produce the action properly with do notation.
05:30:13 <mm_freak> perhaps because i seldomly construct lists statically in code
05:30:21 <OODavo> 'cept that won't work if I have a different number of streams at some point.
05:30:28 <mm_freak> and if i do, then i use list constructors
05:30:32 <mm_freak> abc :
05:30:34 <mm_freak> def :
05:30:35 <mm_freak> []
05:31:07 <mm_freak> OODavo: as said, mapM_ is your friend
05:31:25 <handonson> would mapM_ really do it?
05:31:46 <OODavo> mapM_ doesn't return a combined IO action.
05:31:55 <merijn> :t mapM_
05:31:56 <handonson> it does, but...
05:31:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:32:00 <mm_freak> well, it would turn a list of [String -> IO a] to a String -> IO ()
05:32:01 <OODavo> Or at least it didn't when I tried. :|
05:32:06 <OODavo> Maybe I was using the wrong syntax.
05:32:12 <mm_freak> or to String -> IO [a], if you use mapM instead of mapM_
05:32:21 <handonson> afaik mapM_ is like "one function, many values" while what OODavo wants seems to be "one value, many functions"
05:32:40 <mm_freak> OODavo: i gave you example code
05:32:46 <merijn> handonson: In his case mapM will work just as well
05:33:04 <merijn> handonson: You can fake many functions one value with mapM_ and $
05:33:08 <mm_freak> :t mapM_ ($ 3)
05:33:09 <lambdabot> forall a (m :: * -> *) b. (Num a, Monad m) => [a -> m b] -> m ()
05:33:16 <merijn> mapM_ ($"My string")
05:33:21 <mm_freak> @ handonson, OODavo 
05:33:29 <merijn> Damn, to slow
05:33:31 <OODavo> I don't actually have the string, though.
05:33:38 <mlesniak> Would anybody with a bit of experience with OpenGL/mainLoop and fork(IO|OS) take a look at this small code snippet? http://hpaste.org/45713/opengl__mainloop_fork_problem
05:33:46 <OODavo> So I couldn't just do ($"the string").
05:33:47 <mm_freak> OODavo: then make it a function
05:33:52 <mm_freak> :t mapM_ . ($)
05:33:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:33:59 <mm_freak> uhm
05:34:04 <mm_freak> :t mapM_ . (flip ($))
05:34:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => a -> [a -> m b] -> m ()
05:34:15 <mm_freak> there we go
05:34:18 <dankna> mlesniak:
05:34:18 <mrcarrot> could anyone point me to some example code of making safe user inputs? with this i mean that if you want an Int, the program will ask until you type in something that can be interpreted as an Int, without crashing
05:34:26 <dankna> first, GLUT has a timer facility, which you want to be using
05:34:26 <mlesniak> dankna, ?
05:34:33 <mm_freak> or, if you don't understand that, it's the same as:  \str -> mapM_ ($ str)
05:34:44 <merijn> :t read
05:34:45 <dankna> second, I'd like to see the error X gives you
05:34:45 <lambdabot> forall a. (Read a) => String -> a
05:34:51 <mm_freak> mrcarrot: use exception handling
05:35:00 <merijn> @hoogle (Read a) => String -> Maybe a
05:35:01 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
05:35:01 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
05:35:01 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
05:35:03 <mm_freak> 'read' throws an exception, if parsing fails
05:35:07 <handonson> mlesniak: a quick and dirty idea. make "the rest of the code" a separate function, fork it, THEN enter the main loop
05:35:15 <hpc> :t readS
05:35:16 <lambdabot> Not in scope: `readS'
05:35:16 <mrcarrot> mm_freak: exactly what i mean, but a small example code
05:35:18 <hpc> :t reads
05:35:19 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:35:36 <hpc> reads won't throw an exception
05:35:39 <dankna> but yeah, actually, what handonson just said is probably the way to go
05:35:52 <mlesniak> handonson, Since it will be later called by other functions of mine (which should not need to know about mainLoop) I'd prefer to not burden this dependency on them.
05:35:54 <mm_freak> mrcarrot: you can also use 'reads', which doesn't require exceptions, but i find catching read exception easier…  just look up the type of 'catch' in Control.Exception
05:35:57 <hpc> read s = case reads s of [(x, "")] -> x
05:35:58 <dankna> if GLUT is doing something under the hood that's calling fork(), that can lead to problems
05:36:22 <handonson> mlesniak: sorry, what will be later called?
05:36:35 <mm_freak> mrcarrot: perhaps you want a real line input library?
05:36:38 <mm_freak> mrcarrot: like haskeline
05:36:39 <hpc> i think readIO will be easier than catching pure exceptions
05:36:44 <mlesniak> handonson, the drawing code.
05:37:01 <mlesniak> dankna, I've added the error message to the pastebin
05:37:21 <mlesniak> dankna, (when I write forkOS mainLoop)
05:37:49 <dankna> hm, it's saying that the OpenGL context is not owned by ... the process?  the thread?  the unix-domain socket via which it is connected?
05:38:39 <mlesniak> I have no idea :/
05:38:52 <mlesniak> I've read some older threads that said that forkOS should(tm) work
05:39:21 <mlesniak> Google showed only links regarding xmonad errors.
05:39:32 <dankna> http://www.google.com/search?hl=en&q=%22attempt%20to%20access%20private%20resource%20denied%22&btnG=Google+Search&aq=f&oq=
05:40:29 <handonson> mlesniak: sorry, I have no idea about what you said :/ "forking mainLoop" and "forking the rest of the code" are logically same, except the ThreadIds (which you wouldn't care)
05:40:30 <mlesniak> *maybe* it has something to do with the forkIO
05:40:59 <mlesniak> handonson, quite a bit difficult to explain over IRC :/
05:41:00 <handonson> forking mainLoop will make "the thread that did the getArgsAndInitialize" and "the thread that enters the loop" different
05:41:14 <handonson> which is probably causing the error imo
05:41:33 <dankna> bear in mind that fork() the syscall interacts very badly with Haskell threads
05:41:38 <mlesniak> yes, I think that calling postRedisplat Nothing in a forked thread causes the problem
05:41:43 <dankna> typically it causes every Haskell thread except the one called fork() to unceremoniously go away
05:41:48 <mm_freak> mlesniak: i don't know if you've been told that already, but most OpenGL implementations need a dedicated thread, which is the difference that forkOS makes
05:42:04 <mm_freak> (it's a common misconception that forkOS creates an OS thread…  that's wrong)
05:42:06 <mlesniak> mm_freak, yes, read it already (in Control.Concurrent's documentation, btw)
05:42:18 <dankna> this is X11 though - it's all going over a socket
05:42:45 <mlesniak> I'm trying a glut timer to see if the fork'ed postRedisplay is the cause. Give me a sec.
05:43:17 <dankna> the thing is that GLUT really, really, really wants to be your one and only main loop
05:43:31 <dankna> it does not like sharing with the Haskell thread manager
05:43:47 <dankna> I am not at all a fan of GLUT, for this reason among others
05:44:07 <handonson> love SDL, but probably have the same problem :(
05:44:11 <dankna> yeah
05:44:34 <mlesniak> I used GLUT out of coincidence, found some tutorial for it 
05:44:50 <dankna> it's easy to make work in Haskell, which is a plus
05:44:54 <dankna> GLUT that is
05:45:22 <mm_freak> SDL is fine
05:45:26 <mm_freak> you can write your main loop yourself
05:45:30 <handonson> yeap
05:45:41 <mm_freak> using pollEvent or waitEvent, depending on your app
05:45:48 <mlesniak> Still not working (with addTimerCallback). I think I'll try SDL.
05:46:03 <mlesniak> Any good tutorials on SDL and OpenGL?
05:46:10 <handonson> mm_freak: which is the main reason I ALWAYS pick SDL over GLUT
05:46:13 <mm_freak> for SDL the manpages really suffice
05:46:27 <mm_freak> for OpenGL i recommend looking for a book
05:46:47 <mlesniak> OK, I'll take a look. Thanks.
05:47:12 <Jafet> You hardly even need the man pages if you're just using it to get a window for opengl.
05:47:15 <mm_freak> the haskell bindings to SDL pretty much reflect the C API, so just read the manpages…  to get video stuff with OpenGL you mainly need SDL_Init, SDL_SetVideoMode and SDL_Flip
05:47:29 <handonson> except he's gone.
05:47:40 <mm_freak> yeah
05:47:57 <handonson> or maybe she.
06:11:19 <bxc> k
06:11:22 <bxc> damnit
06:20:34 <xplat> i just realized i've been banging my head against a wall on this app because i was not creating enough types ... part of me wants to think of creating a type as a heavyweight operation ...
06:21:10 <hape01> the haskell wiki - which system is running it? is it a haskell package itself?
06:21:46 <Saizan> no, but there's gitit if you want a wiki implemented in haskell
06:21:50 <xplat> instead of stacking StateT on top of attoparsec i should just create an AST and fold it down to what i need
06:22:37 <hape01> Saizan: ah yes I heard about that.
06:22:40 <hape01> Saizan: thanks
06:33:14 <xplat> i think playing around with lambdabot and ghci is reinforcing my preconception that datatypes are expensive :(
06:33:27 <merijn> Why's that?
06:34:00 <xplat> because you can't define datatypes in lambdabot or at the ghci command line (in the latter you must make a file and load them)
06:34:26 <merijn> Usually I just have a scratch.hs file which I open in ghci and I edit in there and then reload
06:34:47 <xplat> the extra effort is enough to make my brain think 'this is a big deal'
06:35:24 <xplat> maybe using haskell-mode to interact with ghci will free me from that
06:38:54 <b52> hey, i got to represent a 2d 3x3 board, should i use nested lists or an array?
06:39:16 <tromp_> bitmaps
06:39:34 <Jafet> Gomoku is more fun
06:39:49 <b52> tromp_: ?
06:40:07 <blackh> b52: I'd use a Map, probably, but it depends on how the game works.
06:40:31 <tromp_> also called bitboards
06:40:33 <mm_freak> xplat: it's quite a common thing for me to fire up emacs and load ~/src/var/test.hs instead of firing up GHCi
06:40:50 <mm_freak> and mostly emacs is already running somewhere, so i just switch desktop
06:41:11 <mm_freak> GHCi is cumbersome for anything other than evaluating simple expressions
06:41:11 <tromp_> i have some example haskell code for connect-4 with bitboards
06:41:19 <tomh-> anyone here has a nice article about whats wrong with php from a language design perspective? :D
06:41:22 <mm_freak> GHCi alone, that is
06:42:04 <mm_freak> b52: Array/UArray seems reasonable
06:42:15 <mm_freak> Map is more flexible, but you don't get bounds checking
06:42:36 <merijn> tomh-: No formal grammar, inconsistent semantics, inconsistent stdlib naming...
06:43:07 <tomh-> no formal grammar, I haven't heard that one before thanks :>
06:43:33 <mm_freak> b52: there is also Vector, for which you need the 'vector' package…  it's probably better than arrays for most purposes, but not all
06:44:17 <mm_freak> in any case, a list is not the right data structure for this
06:45:57 <xplat> tomh: it's defined by its implementation, database bindings have no common interface despite database access being half the bread and butter of php, unscoped pragmas that invisibly change semantics in whole other modules ...
06:46:26 <merijn> tomh-: No sane namespacing/scoping
06:46:41 <tomh-> they have namespaces now right
06:46:43 <xplat> pervasive use of eval in place of anonymous functions
06:46:48 <merijn> Inconsistent handling of types
06:46:58 <merijn> tomh-: Yeah, but no one uses them last I checked
06:47:12 <tomh-> yeah ok
06:47:19 <tomh-> but thats a programmers problem
06:47:58 <xplat> tomh-: programmers use namespaces in lots of other languages, so one assumes the designers fell down somewhere too
06:48:05 <merijn> Programmers are a significant part of PHP's problems
06:48:11 <tomh-> thats true
06:49:01 <tomh-> I think php now has anonymous functions too
06:49:04 <tomh-> and even closures -.-
06:49:07 <chridi> i guess to store some data in haskell its the best to just write show (myData) to a file and then read the data and get it through read (fileInput) :: DataType
06:49:12 <chridi> right?
06:50:16 <xplat> tomh-: perhaps one of the biggest problems with PHP is that most of the code was written before the language design work had been done
06:50:28 <tomh-> true
06:51:04 <rostayob> chridi: it depends what you need to do
06:51:16 <lunaris> "No formal grammar, inconsistent semantics, inconsistent stdlib naming"
06:51:21 <xplat> kind of closing the barn door when the zombie horses have already run into the town and started feasting on human flesh
06:51:27 <rostayob> chridi: for example if you want to snapshot the state of a program I'd suggest happstack-state
06:51:31 <lunaris> I like this since coming in and skim reading I thought people were discussing C++
06:51:46 <lunaris> (Ignoring recent standardisation etc.)
06:51:54 <hpc> chridi: it has limitations, but where it works, it is a nice simple solution
06:51:58 <tomh-> php and c++ are closely related I guess :p
06:52:08 * lunaris takes cover
06:52:19 <merijn> xplat: There is no language design in PHP
06:52:23 <chridi> hpc: thx.. ill try it :)
06:52:24 <merijn> Not really
06:52:30 <jules2> why does the par combinator work like a -> b -> b, and not a -> b -> (a,b), i.e par x y would evaluate x and y in parallel and return a tuple of the results?
06:52:39 <merijn> C++ was created by a guy who likes to program, PHP by a guy who hates it
06:52:43 <bourbaki> greetings
06:52:56 <chridi> hpc: otherwise some database bindings, hdbc?
06:53:04 <hpc> jules2: because you are going to be using a later anyway
06:53:10 <bourbaki> is there any extension or framework yet that allows you to draw diagrams for arrows yet?
06:53:20 <hpc> chridi: depends on what you need; hdbc is the most mature database binding, to be sure
06:53:33 <rostayob> chridi: do you have to store data or do you just want to save the state of a program?
06:53:45 <chridi> rostayob: both
06:53:51 <jules2> hpc: i know that par as currently implemented *works* but it seems illogical to me as to why it works as it does
06:53:57 <hpc> jules2: the idea is to write x `par` y `par` z `pseq` f x y z
06:54:09 <hpc> if the type of par changes, i don't even know how that would be written
06:54:31 <quicksilver> well you'd have to unpack the tuple and pass it to f
06:54:32 <jules2> i see
06:54:35 <quicksilver> it would still work but it would be a pain
06:54:41 <quicksilver> and might waste work unpacking nested tuples.
06:54:42 <rostayob> chridi: to save the state, check out happstack-state: http://www.kuliniewicz.org/blog/archives/2009/04/05/happstackstate-the-basics/
06:55:11 <hpc> quicksilver: you could even lose the parallelism you would have otherwise gained
06:55:20 <hpc> depending on what kind of mood GHC happens to be in
06:55:27 <chridi> rostayob: thx.. ill have a look
06:55:29 <rostayob> chridi: to store data, there are loads of database bindings
06:55:46 <jules2> so why not have par : a -> a evaluate its argument in parallel and return immediately? then you could do f (par x) (par y) (par z)
06:56:19 <jules2> hmm okay that wouldn't work because par wouldn't be evaluated due to laziness
06:57:08 <xplat> it's basically the same reason seq doesn't work like that
06:58:17 <jules2> okay now it makes sense to me why par works as it does, thanks =)
06:58:39 <bourbaki> is there a way to build a loop with arrows not using something like the loop arrow?
06:58:54 <xplat> you could always write things like 'liftP3 f x y z = x `par` y `par` z `pseq` f x y z' and use them as needed
06:59:38 <xplat> if you don't like the syntactic noise of doing it by hand at call sites
07:00:46 <xplat> bourbaki: if you mean a loop as in fixpoint, then no
07:01:06 <bourbaki> xplat : like in a for loop
07:01:57 <bourbaki> i just stumbled over xslt and thought it would be fun to use graphml and mathml to render diagrams of arrows
07:02:12 <xplat> the data of a normal arrow is not enough to indicate how to interpret the 'looping back' in a for loop
07:02:24 <bourbaki> and compile them with xslt, but i have no idea how i can build something like a for loop with that diagram
07:03:13 <bourbaki> so in order to get a loop you need something that dynamically extends the diagram?
07:03:22 <xplat> er
07:03:28 <xplat> what are you talking about?
07:04:04 <bourbaki> if you work witht he operators on arrows to build up something
07:04:16 <bourbaki> these operators plus the arrows build up a diagram
07:04:22 <xplat> i can't figure out if a diagram is supposed to be a picture or a program or what, or what the for loop has to do with it
07:04:36 <bourbaki> well the diagram is the program
07:04:52 <bourbaki> you start at the source follow it to the sink
07:05:06 <bourbaki> that works very well if you just do a mathematical computation
07:05:31 <bourbaki> but in order to get something like a finite state machine you would need something like a for loop
07:05:59 <xplat> are you aiming for a DSL to create flowcharts?
07:06:13 <bourbaki> http://www.haskell.org/haskellwiki/Graph_processing_and_representation_%28Graep%29
07:06:21 <bourbaki> pretty much yes
07:06:59 <bourbaki> hm maybe this is what im looking for
07:07:00 <bourbaki> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
07:08:33 <bourbaki> nope
07:09:01 <xplat> and you want your DSL for flowcharts to look like pseudocode for the actual algorithm?
07:09:04 <bourbaki> the flowchart dsl is more like it yes, but it should not only be able to render simpe mathematical functions but also state machines
07:09:25 <xplat> or do you not care about that?
07:09:35 <bourbaki> yes, and if that graph was written with xml i could use xslt and some xml file that contains the code to output source
07:10:10 <bourbaki> the flowchart doesnt have to look like pseudo code
07:10:46 <bourbaki> meh, the links in the graep link are bronken...
07:11:29 <xplat> it feels sort of like using a siege weapon to swat a fly, but you might want to look at garrows
07:11:41 <bourbaki> sec having a look
07:12:16 <bourbaki> hm got an url at hand?
07:12:35 <bourbaki> ah got it
07:14:05 <bourbaki> ill have to read that looks interesting
07:14:09 <mm_freak> is it right that originally haskell used coroutines to handle IO?
07:14:24 <mm_freak> i.e. before monads
07:14:52 <zygoloid> mm_freak: i've certainly heard it said
07:16:04 <mm_freak> was there anything wrong with that?  i mean, it appears like the idiomatic functional approach to IO
07:16:37 <quicksilver> it's less flexible, I think, than IO as first class actions
07:16:52 <quicksilver> you can't pass an IO action to another higher order function in a coroutine setting?
07:19:47 <xplat> http://www.cs.berkeley.edu/~megacz/garrows/
07:19:52 <xplat> oh, already got it
07:20:27 <djahandarie> Ah nice, paper is out
07:22:23 <djahandarie> Oh, those slides are nice too
07:31:53 <djahandarie> Skolemizing sure makes that proof nicer
07:39:53 <Veinor> http://i.imgur.com/fPpby.png
07:40:32 <Silvah> :D
07:40:54 <dreamcode> logged in and captcha => contradiction
07:41:33 <djahandarie> Unicode should only be in the captcha for the Agda wiki
07:41:33 <Veinor> go ask dons about it :P
07:41:38 <Jafet> Not if it's a recaptcha
07:41:44 <byorgey> hahaha, awesome =)
07:42:14 <Jafet> I'm still not sure how recaptcha works -- so far, it seems to accept any guess I put in
07:42:37 <Veinor> one of them is known, one of them isn't
07:42:37 <djahandarie> byorgey, we would get kind polymorphism for free (or cheap) with your typekind thing, wouldn't we?
07:42:48 <Veinor> it assumes that if you get the known right you get the unknown right
07:42:50 <byorgey> djahandarie: yes, I think so
07:42:55 <Axman6> one of the words is usually known, the other is a word that's been scanned in and the system is unsure of
07:42:55 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
07:42:56 <djahandarie> Neat
07:43:19 <Jafet> Weird, so it works partly on social order
07:43:27 <quicksilver> both words have been scanned in :)
07:43:40 <quicksilver> the 'known' ones are just ones which have been confirmed by enough other people
07:43:52 <Axman6> yes...
07:43:53 <zygoloid> Jafet: you don't get to know which of the words are known
07:43:54 <xplat> Jafet: it's supposed to work on your inability to guess which is the 'known' word
07:44:25 <xplat> ideally you'd have 9 known words and one unknown, but then nobody would use it
07:45:01 <zygoloid> iirc the system doesn't assume it knows what a word says based on a single guess; you need two people to agree on it first
07:45:06 <Axman6> jkoshy: if you're interested, there's a great writeup somewhere on how the 4chan folks managed to rig the time 100 poll by taking advantage of recaptcha
07:45:10 <Axman6> uh, Jafet 
07:45:56 <zygoloid> there's a great talk by the inventor of recaptcha on getting useful stuff done (eg transcribing books, tagging photos) via this sort of thing
07:46:07 <copumpkin> he's a cool guy
07:46:07 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
07:46:59 * zygoloid quite likes that recaptcha + spammers + mechanical turk = spammers paying off third-world debt :)
07:47:22 <xplat> that goes for any captcha
07:47:26 <quicksilver> except that they don't really use mechanical turk to crack captchas
07:47:30 <quicksilver> they use porn sites
07:47:39 <zygoloid> yeah :(
07:47:42 <quicksilver> it's cheaper to use dirty pictures to incentivise people to solve captchas
07:47:45 <quicksilver> than actually pay them
07:48:17 <xplat> yeah, marginal cost of a pr0npic is ~0
07:48:39 <chridi> whats wrong with the folowing I just dont get it: http://hpaste.org/45716/load_ints_from_file
07:49:04 <chridi> i want to read ints from a file.  Every int is on a single line
07:49:34 <xplat> and when you consider they can use the proxied captcha as an actual captcha for their site, the cost is negative
07:49:45 <blackh> One problem is that the last line should be return $ map ...
07:49:49 <quicksilver> chridi: well it would help to give the error
07:50:00 <quicksilver> but another error is the type
07:50:07 <quicksilver> which should be readIntFromFile :: FilePath -> [Int]
07:50:09 <quicksilver> erm
07:50:12 <quicksilver> which should be readIntFromFile :: FilePath -> IO [Int]
07:50:57 <chridi> quicksilver: http://hpaste.org/paste/45716/load_ints_from_file_annotatio#p45717
07:50:59 <blackh> The code will be quite intolerant of garbage in the file, but you haven't got to that yet. :)
07:50:59 <chridi> tahts the error
07:51:14 <chridi> its just a test out of some other stuff ;)
07:51:32 <quicksilver> chridi: thanks, but blackh and I have already given you two fixes :)
07:51:36 <quicksilver> try those.
07:51:56 <chridi> oh
07:52:00 <chridi> okay return :)
07:52:20 <chridi> with IO and return it works, thanks
07:53:02 <chridi> so x is still of type IO String
07:54:03 <RayNbow> no, x has type String
07:56:30 <chridi> its beacause of the 'do', or?  That the function has to be IO
07:57:04 <hpc> chridi: do {x <- foo; somethingWith x} is translated to:
07:57:15 <hpc> foo >>= \x -> somethingWith x
07:57:36 <hpc> so the x is of type String because of what the type of (>>=) says
07:58:05 <hpc> foo :: IO String, and (\x -> somethingWith x) :: String -> IO Something
07:59:55 <chridi> okay.  thanks.  I think I need more than two days to understand that ;)
08:09:56 <thomas342> hi
08:10:13 <Skoala> hello
08:13:19 <lars9> is there any interesting usage of arrows?
08:13:50 <pesco> lars9: afrp
08:14:14 <lars9> for more general applications? 
08:14:26 <lars9> monad is everywhere
08:14:59 <quicksilver> lars9: HXT
08:15:04 <quicksilver> (there aren't many, no)
08:15:08 <quicksilver> SD parsing
08:15:38 <thomas342> i had this excercise http://projecteuler.net/index.php?section=problems&id=1 and i solved it like this: teiler x y = sum (nub [z | z<-x, t<-y, mod z t == 0])
08:16:08 <thomas342> how would i  do it if the question was "Find the sum of all the multiples of 3 AND 5 below 1000."
08:16:18 <lars9> quicksilver: what is SD parsing?
08:16:52 <quicksilver> lars9: http://portal.acm.org/citation.cfm?id=734159
08:17:09 <hpc> thomas342: first find the sum of multiples of 3
08:17:14 <hpc> thomas342: then find the sum of multiples of 5
08:17:38 <pesco> also, "connecting signal transformers" (i.e. afrp) is already pretty general if you loosen your idea of "signal".
08:17:43 <hpc> thomas342: and somehow (exercise for the reader) remove things that are multiples of 3 and 5
08:17:46 <TeXitoi> thomas342: Data.List.any ?
08:17:49 <hpc> er
08:17:50 <zygoloid> thomas342: take a list of all possible numbers, filter out those which aren't a multiple of 3 or 5, take sum
08:18:03 * hpc read question wrong, nvm
08:18:06 <TeXitoi> s/any/all
08:18:12 * zygoloid too :)
08:18:20 <roconnor> > sum [i|i<-[0..1000], i `mod` 3 == 0 || i `mod` 5 == 0]
08:18:21 <lambdabot>   234168
08:18:21 <pesco> i suspect there is a useful arrow in iteratees
08:18:25 <zygoloid> thomas342: n is a multiple of 3 and 5 iff it is a multiple of 15
08:19:19 <roconnor> what is the recommended way of generating crypto secure pseudo random numbers?
08:19:19 <thomas342> ah ok, so my question was not that good. it was ment like: can i easily change my code to have an AND instead of an OR
08:19:47 <lars9> quicksilver: oh published at 1996...
08:19:57 <quicksilver> lars9: yes, and the paper doesn't explicitly use arrows
08:20:02 <quicksilver> but there idea is there
08:20:07 <quicksilver> and there are libraries which work that way
08:22:29 <lars9> hmmm, i've tried many times to figure out what arrow is
08:22:58 <merijn> lars9: Hold on, I know a good explanation
08:22:59 <thomas342> when i have a infinite list of ascending values, what a good way to get the sum of all values < x ?
08:23:30 <merijn> lars9: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows <-- this made me finally understand arrows
08:23:44 <merijn> Well, at least the (->) instance of arrows, but that's enough to be useful :p
08:24:06 <lars9> merijn: i've read that
08:24:20 <merijn> lars9: What don't you understand after reading that?
08:24:24 <lars9> at least a year ago. but it's mostly about several functions
08:24:35 <lars9> like *** &&& first loop
08:24:46 <lars9> but arrow should be more than that?
08:24:47 <merijn> Yes
08:24:52 <TeXitoi> thomas342: takeWhile ?
08:25:10 <xplat> thomas342: foldl' (+) 0 . takeWhile (< x) $ anInfiniteList
08:25:21 <lars9> > takeWhile (<10) [1,3..]
08:25:22 <lambdabot>   [1,3,5,7,9]
08:25:38 <merijn> lars9: Well if you want to know more about arrows other then "functions are arrows" then you're going to end up in category theory land
08:26:08 <thomas342> xplat: ah thank you
08:26:43 <xplat> category theory land is like the disneyland of the mind
08:26:45 <lars9> like, what if haskell implement IO using arrow instead of monad at the begining?
08:26:50 <merijn> lars9: Like monads and monoids they are just "things with a certain set of operations defined on them and satisfying some laws"
08:27:15 <xplat> it's not a bad thing to go there
08:27:37 <merijn> xplat: More like Disneyland...ON ACID
08:28:12 <Silvah> Warning: some people went to the category theory land and never returned.
08:28:24 <merijn> I'm still lost in type theory land
08:28:28 <xplat> merijn: Disneyland seems like it was kind of on acid to begin with.  especially mr. toad's wild ride!
08:29:04 <Jafet> http://apina.biz/9403.gif
08:29:36 <mzero> wonder how the person makeing the Lua -> LLVM compiler made out...
08:30:24 <quicksilver> I disagree with merijn, I think that wikibook page is a complete waste of bytes.
08:30:29 <quicksilver> all it does is describe functions!
08:30:35 <quicksilver> it tells you nothing about what arrows are.
08:30:38 <merijn> quicksilver: Have to start somewhere!
08:30:54 <quicksilver> sure. So call it 'understanding functions' or 'some neat combinators on functions'
08:31:03 <quicksilver> it conveys absolutely no understanding about arrows at all.
08:31:04 <merijn> There is also another Arrow page, but it is scary :(
08:31:13 <xplat> i don't think it's a waste of bytes, but it's got the wrong title, yeah
08:31:17 <quicksilver> but possibly conveys some confusion by suggesting that arrows are just like functions :)
08:31:55 <merijn> Well, I asked for examples of things which were arrows (other then functions in here) but I never got an answer
08:32:24 <xplat> Jafet: can't see that gif.  some kind of anti-hotlinking gone amok
08:33:23 <Jafet> Oh well
08:33:39 <xplat> oh, there it goes, extra redirect ...
08:34:00 <Jafet> It wasn't really haskell related
08:34:36 <lars9> network interrupted, did i miss something?
08:35:16 <xplat> ah, acid-related :)
08:40:25 <Xaratas> hi, i have a problem with this show instance: http://hpaste.org/45721/show
08:40:57 <Xaratas> and i dont understand the problem the interpreter has, could someone help me?
08:41:17 <mzero> Xaratas: in the second cluase of toString     ++ show a ++
08:41:30 <mzero> remember, a isn't a String, it is something that can be Show'n
08:41:34 <quicksilver> Xaratas: instance Show a => Show (BinTree a) where
08:41:38 <quicksilver> as line 22
08:41:54 <quicksilver> your version tries to make 'a' an instance of a class called 'BinTree' which does not exist.
08:42:56 <Xaratas> quicksilver: so how to solve this? write somewhere "class BinTree" ?
08:43:09 <mzero> also, insert has a bug.... consider the else case --- is x used?
08:43:10 <xplat> wow, this swierstra paper's section on 'conventional combinator parsers' described the exact notation of Applicative in 1996
08:43:28 <djahandarie> Haha
08:43:33 <mzero> Xaratas:       instance Show (BinTree a)
08:43:40 <mzero> Xaratas:       instance Show (BinTree a) where
08:43:48 <roconnor> abstract type says: ``I don’t find talk about “bottom” to be particularly helpful; in fact, it’s particular confusing. The whole business of “bottom” is an artifact of denotational semantics, and not an essential concept of programming languages. 
08:44:06 <roconnor> Bob Harper just gained even more respect in my book!
08:44:14 <djahandarie> Wouter Swierstra is smart so that doesn't surprise me though :)
08:44:20 <djahandarie> Heh
08:44:20 <mzero> Xaratas: line 10 -- consider, what is the type of the value of a > b
08:44:21 <mzero> ?
08:44:35 <djahandarie> Everyone gets in a fit over Bob Harper's posts
08:44:45 <roconnor> xplat: imagine if we had applicative 10 years earlier!
08:44:51 <Xaratas> @mzero instance Show (BinTree a) where does not solve this
08:44:51 <lambdabot> Unknown command, try @list
08:45:27 <mzero> it doesn't? Did you replace the other line with that?
08:45:29 <mzero> or add it?
08:45:41 <Xaratas> replace
08:45:53 <Xaratas> BinTree.hs:22:10:
08:45:55 <Xaratas> `Show' is applied to too many type arguments
08:45:57 <Xaratas> In the instance declaration for `Show BinTree a'
08:46:08 <mzero> you forgot the parenthesis
08:46:16 <xplat> the class Parsing is almost exactly the same as Applicative plus Alternative, including symbols.  the only differences are 'pure' being called 'symbol' and the extra '<?>'
08:46:59 <lars9> some i got disconnected just now. back to my question, can we model IO with arrows, what will it be like, the pros and cons?
08:47:21 <roconnor> why would you want to model IO with arrows?
08:47:35 <roconnor> cons: no context depenent IO operations
08:47:37 <xplat> lars9: an ArrowApply is equivalent to a monad, so it would be pretty much the same
08:48:21 <xplat> roconnor: i presume an ArrowApply instance would be supplied for that purpose, so syntax should be the only difference
08:48:53 <roconnor> ArrowApply makes an arrow a monad?
08:48:54 <Xaratas> mzero: with parenthesis i got only a new error
08:49:06 <mzero> please to show us?
08:49:40 <byorgey> roconnor: yes
08:51:02 <Xaratas> http://hpaste.org/45722/new_error @mzero
08:51:43 <roconnor> is there some interface to /dev/urandom?
08:51:47 <mzero> yes - notice that it is complaining about toString
08:51:54 <mzero> that is because of the earlier problem I mentioned
08:52:26 <mzero> Xaratas: in the second clause of toString     ++ show a ++
08:52:26 <osoleve> i don't know if this question makes sense, but how do I make a foreign pointer out of a list?
08:52:35 <osoleve> (i have a problem with X, how do I do Y?)
08:52:45 <mzero> you were concatenating a with the strings -- but I think you wanted to show a, yes?
08:52:50 <Xaratas> i have the "show a" also added
08:53:05 <mzero> ah --- you'll need        instance Show a => Show (BinTree a) where
08:53:10 <mzero> sorry - we missed that eariler
08:53:10 <Xaratas> yes, i hope on some kindo of autocasting
08:53:18 <Xaratas> -o
08:53:23 <mzero> since, BinTree a can only be shown if a can, right?
08:53:39 <Xaratas> makes sense
08:54:07 <mzero> autocasting? there is no autocasting, central-casting, or casting of any kind 'round these parts
08:54:22 <hpc> there's unsafeCoerce, but it is terrifying
08:54:26 <mzero> (you unsafe folks: back... back!  do not sully his pure mind!)
08:54:37 <Jafet> :t cast
08:54:38 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
08:54:50 <Jafet> (less useful than it sounds)
08:55:16 <mzero> I cast you all down for you have spoken the unspeakables in the land of Haskell..... I cast (d'oh!)
08:55:34 <Xaratas> aha, the  instance Show a => Show (BinTree a) where compiles, thanks
08:55:38 <pmurias> with GADTS if i have two functions of type f :: Foo O -> Bar Foo O and g :: Foo C -> Bar Foo C is it possible to combine them into one 
08:55:41 <pmurias> ?
08:56:55 <zygoloid> pmurias: when pattern matching Foo a, can you distinguish a Foo O from a Foo C through the Foo constructor used?
08:57:50 <byorgey> pmurias: it seems like it should be possible just to write  f :: Foo a -> Bar Foo a
08:57:51 <osoleve> how do I use Sound.File.Sndfile hPutBuffer if all I have is a handle and a list of Word16?
08:57:52 <pmurias> i can but i'm asking the question to avoid doing that
08:58:00 <Xaratas> and does what i want that it does
08:58:05 <xplat> or if you can't always distinguish, does it happen that in the cases where you can't distinguish, f and g do the same thing?
08:58:10 <byorgey> pmurias: can you be more specific about what you are trying to do?
08:58:53 <pmurias> when using hoopl i want to convert instructions to graphs
08:58:58 <int-e> pmurias: it depends on the GADT, Foo, O and C. If there is a constructor  X :: Foo a, then X :: Foo O and X :: Foo C will have the same run-time representation.
08:59:19 <pmurias> that is from an Insn e x i want to make a Graph Insn e x
09:00:50 <int-e> pmurias: so as you asked the question, it's the same constructor in either case. On the other hand, if you have constructors X :: Foo O, Y :: Foo C (i.e. each type argument maps a disjoint set of constructors), then you can combine the functions, but still not automatically (since there must be code to decide which of the two functions to call)
09:05:13 <osoleve> if I have a list, how do I get a Ptr to that list?
09:06:38 <roconnor> @hoogle toInteger
09:06:39 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
09:07:40 <DevHC> osoleve: u can use newArray to put the list contents in storable memory and get a pointer to that memory
09:10:16 <xplat> it annoys me that attoparsec's sepBy puts the content parser before the separator parser
09:10:20 <osoleve> okay, so if I have lst = [Word16], I do newArray (1,length lst) lst?
09:11:12 <xplat> it seems way more common to use the same separator for different content than different separators for the same content
09:11:34 <DevHC> osoleve: u do, in the IO monad, ptr <- newArray lst
09:12:16 <DevHC> and u probably meant to say "if i have lst :: [Word16]" instead of "i have lst = [Word16]"
09:12:22 <xplat> yes, it reads better in operator position that way, but i'd rather just use it in prefix position to begin with ...
09:12:48 <osoleve> i just got an old macdonald error
09:13:02 <DevHC> ?
09:13:11 <osoleve> couldn't match expected type IO a0 with actual type e0 -> m0 a1 i0 e0)
09:13:23 <osoleve> i read it to the tune of old macdonald :3
09:14:05 <DevHC> code plx
09:14:27 <Axman6> @djinn ei -> ei ei o
09:14:27 <lambdabot> Error: kind error: (KArrow (KVar 0) (KVar 2),KVar 0)
09:14:51 <mzero> "And... on this type he had a Monad... m0 Io eo!"
09:14:53 <dfilimon> hi, is there a way to explicitly tell haskell that i don't want to implement all functions for a class instance (i want a Position type that supports addition and substraction, but no other functions)
09:14:56 <osoleve> https://ideone.com/JGXFH
09:15:05 <osoleve> the problem is with writeWav at the bottom
09:15:09 <osoleve> (thanks)
09:15:14 <ezyang> You don't have to implement them, but GHC will warn you about it. 
09:15:22 <xplat> that's not quite as good as the powerpc EIEIO instruction
09:15:23 <mzero> "With a >>= here, and a >>= there. Here a >>=! There a >>=!  Everywhere a >>=!!"
09:15:35 <xplat> that one set new standards
09:15:48 <dfilimon> can i not get the warnings though?
09:15:49 <djahandarie> ezyang, did you ever end up reading Conor McBride's thesis?
09:15:51 <mzero> "Old MacHaskell had a type, IO IO IO"
09:16:04 * osoleve wonders what he started
09:16:08 <Axman6> djahandarie: thingIDontWantToImplement = undefined
09:16:12 <Axman6> uh, dfilimon 
09:16:12 <ezyang> djahandarie: No, haven't gotten around to it. 
09:16:18 <dfilimon> ah, yes, thanks :)
09:16:48 <djahandarie> Okay. It must be the most entertaining thesis I've ever read due to his writing style :p. Haven't gotten too far yet though
09:16:57 <xplat> (with a Mu, Mu here and a Mu, Mu there ...)
09:17:35 * roconnor wishes for an extended euclidiean algorithm
09:17:44 <kstuart> Hi all, thought I'd have a go at learning Haskell and just installed ghc 7.0.2 and Haskell Platform 2011.2.0.0 from source on Ubuntu Natty. I've started going through the 'Learn you a Haskell' tutorial and appear to have been squashed at the first hurdle.
09:17:48 <kstuart> When I type 'doubleMe x = x + x' I get <interactive>:1:12: parse error on input `='
09:17:51 * osoleve gives roconnor euclidean algorithm extension pills
09:17:52 <kstuart> What am I doing wrong? :-/
09:17:53 <xplat> roconnor: extended for what?
09:18:10 <mzero> kstuart - you are supposed to type that in a file
09:18:14 <mzero> then load that into ghci
09:18:15 <Skoala> kstuart
09:18:18 <Axman6> kstuart: let doubleMe x = x + x
09:18:18 <mzero> not type it into ghci
09:18:22 <roconnor> xplat: to give me a and b such that a*x + b*y = gcd x y
09:18:25 <Skoala> in ghci you can do "let doubleMe x = x + x"
09:18:56 <mzero> http://learnyouahaskell.com/starting-out#babys-first-functions
09:19:09 <DevHC> osoleve: i don't have the libs u use, and i've never used them before, i think u should work out the type errors urself
09:19:09 <mzero> re-read the first two paragraphs -- you'll see he wants that in a file named baby.hs
09:19:30 <DevHC> osoleve: of what type is Snd.hPutBuf?
09:19:30 <mzero> what Axman6 said will work -- but not with the rest of the LYAH tutorial as written
09:19:42 <kstuart> Cheers folks, my noob brain skipping the details :-(|)
09:19:42 <djahandarie> "Old McHaskell had a type, IO IO IO. And on this type he had a Monad, IO IO IO. With a Mu, Mu here, and a Mu, Mu there..." Heh
09:19:55 <osoleve> DevHC: Handle -> Ptr e -> Count -> IO Count
09:20:03 <Skoala> slightly related question: can you set a base case for a recursive function somehow in ghci?
09:20:14 <Skoala> not that I really need to
09:20:20 <mzero> you mean via let?
09:20:21 <Skoala> but was wondering
09:20:21 <mzero> no
09:20:26 <Skoala> ok
09:20:36 <mzero> well... you can by turning it into a case
09:20:41 <EvanR-work> djahandarie: lol
09:21:00 <DevHC> osoleve: and i gather Count = Int?
09:21:06 <osoleve> yes, sorry
09:21:40 <DevHC> osoleve: and openWavHandle would be [Word16] -> IO Handle?
09:21:56 <osoleve> yes
09:22:02 <mzero> > let map' f a = case a of { [] -> []; (a:as) -> f a : map' f as; } in  map' (*3) [1..3]
09:22:03 <lambdabot>   [3,6,9]
09:22:10 <mzero> Skoala: like that
09:23:17 <Skoala> cool, thanks for showing
09:23:20 <Xaratas> ha, got rid of the gt function
09:24:06 <djahandarie> > let { map' f [] = []; map' f (a:as) -> f a : map' f as; } in map' (*3) [1..3]
09:24:07 <lambdabot>   <no location info>: parse error on input `->'
09:24:13 <djahandarie> > let { map' f [] = []; map' f (a:as) = f a : map' f as; } in map' (*3) [1..3]
09:24:13 <lambdabot>   [3,6,9]
09:24:48 <DevHC> osoleve: i dunno what the error could be, to me it seems that writeWav is good
09:25:11 <osoleve> I think i'm missing a parameter to newArray?
09:25:24 <osoleve> it's Data.Array.MArray, right?
09:25:33 <osoleve> ohhhh
09:25:40 <osoleve> no, it's Foreign.Marshal.Array
09:25:41 <DevHC> no, newArray is of type (Storable a) => [a] -> IO (Ptr a)
09:25:54 <DevHC> oh lol
09:26:09 <osoleve> yup, it just compiled
09:26:10 <osoleve> thank you
09:26:46 <roconnor> @hoogle foldmap
09:26:46 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
09:26:46 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
09:27:23 <DevHC> just 1 note: u should free the allocated memory if it's not needed anymore
09:27:25 <roconnor> @hoogle (b -> (b,a)) -> b -> [a]
09:27:25 <lambdabot> No results found
09:27:34 <DevHC> osoleve
09:27:45 <osoleve> yes?
09:27:51 <DevHC> u should free the allocated memory if it's not needed anymore.
09:27:59 <djahandarie> roconnor, unfoldr?
09:28:00 <osoleve> okay, thanks
09:28:06 <roconnor> maybe
09:28:30 <djahandarie> Does "maybe" mean maybe, or that you don't want the Maybe in the type? :p
09:28:33 <roconnor> @hoogle shiftr
09:28:33 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
09:28:34 <aristid> :t unfoldr . Just
09:28:35 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
09:28:35 <lambdabot>            against inferred type `Maybe a1'
09:28:35 <lambdabot>     Probable cause: `Just' is applied to too many arguments
09:28:47 <aristid> :t unfoldr
09:28:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:29:16 <aristid> :t \f -> unfoldr (Just . f)
09:29:16 <lambdabot> forall a b. (b -> (a, b)) -> b -> [a]
09:29:17 <roconnor> ya
09:29:22 <aristid> @pl \f -> unfoldr (Just . f)
09:29:22 <lambdabot> unfoldr . (Just .)
09:29:27 <roconnor> I can get away with map composed with iterate
09:34:14 <djahandarie> > let grow x = unfoldr (Just . join (&&&) (1 +)) (x-1) in grow 10
09:34:16 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
09:34:52 <lunaris> :t join
09:34:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:35:03 <lunaris> *Sigh* of course.
09:35:18 <djahandarie> Where m = (a ->), in this case
09:35:19 <ski> @type \f x -> join f x
09:35:19 <lambdabot> forall t a. (Monad ((->) t)) => (t -> t -> a) -> t -> a
09:35:34 <Xaratas> nice to see when something works
09:35:38 <xplat> > let xeuc a b = if a < b then (snd&&&fst) $ xeuc' b a 1 0 0 1 else xeuc' a b 1 0 0 1; xeuc' !_ 0 !xa !xb !_ !_ = (xa, xb); xeuc' !x !y !xa !xb !ya !yb  = let (d,m) = x `divMod` y in xeuc' y m ya yb (xa - d*ya) (xb - d*yb) in xeuc 23 120
09:35:39 <lambdabot>   (47,-9)
09:35:41 <lunaris> Indeed; my brain blocked on IO and I thought it was an arrow primitive.
09:35:46 <lunaris> :/
09:36:15 <xplat> roconnor: there you go, ugly oneliner but it works
09:36:18 <Xaratas> question: why i have in patternmatching for a list to use [a] and for a splitted list (a:as) ?
09:36:32 <Xaratas> like here: insertList fun [x] Nil = Node Nil x Nil
09:36:32 <Xaratas> insertList fun (x:xs) node = insertList fun xs (insert fun x node)
09:36:42 <xplat> roconnor: (didn't test it for negative numbers though)
09:36:52 <djahandarie> [x] only matches a single-element list
09:36:59 <djahandarie> Like [1] or [10]
09:37:08 <xplat> roconnor: (and my mental proof doesn't cover that case)
09:38:28 <Xaratas> and why i could not use [a:as] ?
09:38:55 <xplat> Xaratas: because : already makes a list, so [a:as] makes a list of lists
09:38:57 <djahandarie> Xaratas, because that would make a list like [[1,2]]
09:38:57 <Axman6> because that matches a list with a single list inside it
09:39:04 <djahandarie> match*
09:39:34 <Axman6> so i could match [[1]] or [[1,2,3,4]], but not [[1.2],[3,4]]
09:39:56 <Xaratas> ok, thanks (remember the : has much special powers)
09:40:00 <xplat> : is not a special 'tail marker' like lisp's . or prolog's |, it's just a constructor that takes an element and a list and returns a list
09:40:02 <ski> Xaratas : note that `[a]' is sugar for `a : []'
09:40:48 <xplat> you also can't write [a0,a1:as] for the same reason, it would have to be (a0:a1:as)
09:41:04 <rovar> does anyone have an example of reading incremental responses from network.http?
09:41:09 <rovar> as a client..
09:41:38 <ski> Xaratas : also note that the only reason you need brackets around `x:xs' there is that if you write `insertList fun x:xs node = ...' then that gets parsed as `(insertList fun x):(xs node) = ...' instead
09:41:49 <rovar> i notice that Stream is not returned at all in its top level interface
09:42:19 <xplat> (well, you can write it, but it would mean 'a list of two elements, each of which is a list, with the first list named a1, the head of the second list called a1, and the tail of the second list called as' which is probably not what you would have meant)
09:42:30 <xplat> *first list named a0
09:46:51 <Xaratas> i got another one. I have "data BinTree a = Nil | Node (BinTree a) a (BinTree a)" is a line like this "insertList fun [] Nil = Nil" not a little bit "dumb"? as creating a new Nil instead of returning it?
09:48:52 <siracusa> Xaratas: You can say `insertList fun [] n@Nil = n' and rely on the compiler to return the original Nil :-P
09:49:05 <tromp_> does fac 1 = 1 create a new 1?
09:49:45 <conal> would the simpler version really create "a new Nil"?
09:50:54 <tromp_> there is no new Nil, just like there is no new 1
09:50:56 <Xaratas> but is Nil not as konstructor automatically a little bit special?
09:51:07 <roconnor> @hoogle numerator
09:51:07 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
09:51:44 <Xaratas> insertList fun [] node = node <- if i would here write Node it would not compile
09:52:15 <pumpkin> Xaratas: there is only one Nil
09:52:16 <roconnor> I'm surprised fromRational has no default value
09:52:52 <ski> default value ?
09:53:19 <ski> oh, as a class method ?
09:53:38 <ski> @src Fractional
09:53:38 <lambdabot> class  (Num a) => Fractional a  where
09:53:38 <lambdabot>     (/)             :: a -> a -> a
09:53:39 <lambdabot>     recip           :: a -> a
09:53:41 <lambdabot>     fromRational    :: Rational -> a
09:54:26 <roconnor> ski: is there a quicker way to implement recip for modular arithematic without reimplementing gcd?
09:55:12 <ski> i don't know
09:55:14 <tromp_> extended gcd
09:55:35 * roconnor goes an reimplements gcd
09:55:39 <roconnor> *and
09:56:38 <xplat> roconnor: didn't i just do that?
09:56:57 <roconnor> did you?
09:57:04 <xplat> > let xeuc a b = if a < b then (snd&&&fst) $ xeuc' b a 1 0 0 1 else xeuc' a b 1 0 0 1; xeuc' !_ 0 !xa !xb !_ !_ = (xa, xb); xeuc' !x !y !xa !xb !ya !yb  = let (d,m) = x `divMod` y in xeuc' y m ya yb (xa - d*ya) (xb - d*yb) in xeuc 23 120
09:57:05 <lambdabot>   (47,-9)
09:57:06 <roconnor> oh
09:57:08 <pumpkin> you lost it on the golf course
09:57:15 <roconnor> :D
09:57:21 <ski> (roconnor : if you do, please make `gcd 0 0 = 0')
09:57:35 <pumpkin> > let xeuc a b = if a < b then (snd&&&fst) $ xeuc' b a 1 0 0 1 else xeuc' a b 1 0 0 1; xeuc' !_ 0 !xa !xb !_ !_ = (xa, xb); xeuc' !x !y !xa !xb !ya !yb  = let (d,m) = x `divMod` y in xeuc' y m ya yb (xa - d*ya) (xb - d*yb) in xeuc 0 0
09:57:36 <lambdabot>   (1,0)
09:57:41 <roconnor> ski: I don't understand what is wrong with the haskell committee
09:57:55 <xplat> ski: you mean it's not?  that's just incorrect
09:57:56 <roconnor> ski: I'll do you a step more and make n `mod` 0 = n
09:58:00 <roconnor> > gcd 0 0
09:58:01 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
09:58:04 <ski> @src gcd
09:58:04 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
09:58:05 <lambdabot> gcd x y = gcd' (abs x) (abs y)
09:58:05 <lambdabot>    where gcd' a 0  =  a
09:58:05 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
09:58:09 <Jafet> That should really be taken from GMP
09:58:11 <pumpkin> I like that it actually says "it is undefined" in the error
09:58:17 <tromp_> > 47*23-9*120
09:58:18 <lambdabot>   1
09:58:18 <ski> roconnor :D
09:58:19 <roconnor> xplat: they went out of there way to make it broken
09:58:23 <Jafet> Once they fix the GMP issues
09:58:26 <pumpkin> Jafet: it is actually
09:58:36 <Jafet> I mean gcdext
09:58:41 <pumpkin> oh okay
09:58:52 <pumpkin> I may have put it in my extra bindings to GMP functions patch
09:58:59 <pumpkin> but that's been unmerged for over a year now
09:59:12 <tromp_> shldnt gcd 0 0 be infinity?
09:59:22 <DevHC> no?
09:59:23 <pumpkin> tromp_: why?
09:59:25 <xplat> tromp_: 0 IS infinity
09:59:33 <xplat> at least for these purposes
09:59:37 <tromp_> yes, in a sense 0 is infinity
09:59:37 <pumpkin> WAR IS PEACE
09:59:38 <ski> `0' is the greatest element in the divisibility ordering
09:59:43 <xplat> it's the top of the divisibility lattice
09:59:53 <pumpkin> @quote stereo
09:59:53 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
09:59:57 <pumpkin> lol
10:00:26 <Jafet> Also, the lattice definition for gcd conveniently defines gcd 0 0 = 0
10:00:58 <Jafet> So does the euclidean algorithm, if taken as a specification
10:01:18 <roconnor> now explain to tromp_ why n `mod` 0 = n
10:01:25 <tromp_> so the case for gcd(0,0)=0 is even clearer than for 0^0=1 ?
10:01:42 <xplat> yeah, it doesn't make sense to define GCD in terms of 'greatest' in the additive order, even if it agrees for most cases
10:01:44 <ski> the characterizing property is `d | gcd a b  <=>  d | a /\ d | b'
10:01:50 <Jafet> Because Mods are rebellious
10:02:17 <xplat> for one thing, it doesn't extend to the field extensions where GCD would otherwise be well-behaved
10:02:35 <ski> (to be read as : `gcd a b' is the greatest (wrt divibility) `d' such that `d' divides both `a' and `b')
10:03:30 <roconnor> ski: now say it using a galois connection
10:04:00 <ski> you don't like adjunctions ?
10:04:07 <roconnor> or adjuctions
10:04:26 <roconnor> if you need to go that far
10:04:27 <xplat> a galois connection is an adjunction
10:04:29 <ski> i thought i just said it as an adjunction
10:04:41 <roconnor> I don't see the adointness
10:05:11 <roconnor> *adjointness
10:05:14 <ski> obviously `d | a /\ d | b' is `(d,d) | (a,b)', with the appropriate divisibility on pairs
10:05:27 <xplat> roconnor: it's implicit in the fact that a product in a category is given as an adjoint of a diagonal functor
10:05:27 <ski> and `(d,d)' is `Delta d'
10:06:20 <pumpkin> xplat: duh!
10:06:37 <roconnor> so Delta is adjoint to gcd?
10:06:42 <ski> yes
10:06:48 <roconnor> :O
10:08:04 <roconnor> well at least we are confusing the newbies as much as possible with our discussion :)
10:08:39 * roconnor has made it a point to look out for galois connections / adjuctions.
10:08:55 <pumpkin> roconnor: yeah, don't take your eyes off of them
10:08:58 <pumpkin> or they'll stab you in the back
10:09:42 <ski> xplat : afaiu with galois connections we have `x =< f y  <=>  y =< g x' or `f x =< y  <=>  g y =< x'
10:10:18 <xplat> yeah, that ⊢ is even sharper than it looks
10:10:37 <roconnor> ski: | is like =<
10:10:45 <ski> (at least istr Taylor saying something like that in Practical Foundations)
10:10:48 <ski> yes
10:11:04 <ski> (any preorder)
10:11:22 <roconnor> so this is a galois connection
10:11:55 <ski> this is `d | gcd (a,b)  <=> Delta d | (a,b)'
10:12:13 <roconnor> yep
10:12:24 <ski> where the two functions occur on opposite sides of the inequalities
10:12:38 <roconnor> I don't know enough to see the Detla that was implict in your first definition
10:12:53 <ski> (hence adjunction)
10:13:14 <roconnor> I don't get the hence adjuction
10:13:23 <monochrom> perhaps Delta d = (d,d)
10:13:55 <roconnor> other than the trivial fact that a galois connection is an adjuction
10:14:25 <monochrom> extend "|" to tuples so (x,y)|(m,n) iff x|m and y|n.  d|gcd(a,b) iff (d,d)|(a,b)
10:14:26 <ski> hm, apparently what i called `adjunction' here, WP calls `monotone galois connection' (as opposed to `antitone / order-reversing galois connection')
10:15:01 <xplat> but the fact that  glbs and lubs are given by galois connections in lower/upper semilattices is well known and a special case of the adjoint construction of products/coproducts
10:15:31 <xplat> ski: antitone is just a contravariant adjunction
10:16:11 <ski> i was thinking of <http://www.cs.man.ac.uk/~pt/Practical-Foundations/html/s36.html> (beware bad characters from HTML conversion)
10:16:34 <byorgey> monochrom: indeed, I think that was stated above
10:17:38 <monochrom> I admit I haven't read the scroll back
10:17:40 * ski unfortunately can't find the dead-tree version atm, to check with ..
10:19:44 <elliottt> Lemmih: you around?
10:20:39 <roconnor> can we get gcd fixed in some new haskell revision somehow
10:20:55 <monochrom> what wrong does it do?
10:20:58 <roconnor> everytime it is brought up on the discussion list some people strike it down :(
10:21:10 <roconnor> > gcd 0 0 
10:21:10 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
10:21:31 <copumpkin> I can see almost no reason to not change it
10:21:33 <monochrom> that is correct
10:21:48 <copumpkin> see, even monochrom agrees with me
10:21:52 * copumpkin chuckles
10:22:03 <monochrom> @slurp copumpkin
10:22:04 * lambdabot hits copumpkin with an assortment of kitchen utensils
10:22:10 <copumpkin> :O
10:22:20 <monochrom> gcd 0 0 is better off undefined
10:22:28 <Jafet> Left 0?
10:22:32 <copumpkin> them there lattices don't lie
10:22:49 <roconnor> monochrom doesn't like galois connections
10:23:11 <monochrom> eh? what does galois connection say about gcd 0 0?
10:23:17 * copumpkin is really disappointed that there seems to be no good way to do mean absolute deviation in a single pass
10:23:44 <roconnor> monochrom: it says that d | gcd a b <=> Delta d | (a,b)
10:24:18 <copumpkin> vaguely related, but gcd is a coproduct isn't it?
10:24:45 <copumpkin> oh actually
10:24:47 <copumpkin> product
10:25:01 <monochrom> alright, fill in the blank for me: for all natural x, x | ___ ⇔ (x,x)|(0,0)
10:25:07 <roconnor> and since Delta 0 | (0,0) it is only natural that 0 | gcd 0 0
10:25:30 <monochrom> no, you understand the statement wrong
10:25:55 <roconnor> monochrom: I'd fill in the blank with gcd 0 0
10:26:29 <monochrom> well actually, I misread. Delta 0 | (0,0) is fine.
10:26:55 <monochrom> that begs the question. the blank there is to make you find the correct value for gcd 0 0
10:27:49 <roconnor> and also nice ~(n=0) means that ~(Delta n | (0,0)) then it is only natural that ~ n | gcd 0 0
10:27:53 <roconnor> *since
10:27:57 <roconnor> er
10:28:01 <roconnor> let me rewrite that
10:28:14 <roconnor> and also if ~(n=0) then ~(Delta n | (0,0)) then it is only natural that ~ n | gcd 0 0
10:28:22 <ski> monochrom : the blank space should be `0' because every natural number divides zero
10:28:46 <roconnor> thankfully there is a value x such that 0 | x and ~(n=0) implies ~(n | x)
10:28:48 <roconnor> and that x is 0
10:28:58 <roconnor> oh
10:29:03 <roconnor> heh
10:29:07 <roconnor> what ski said
10:29:26 <monochrom> what ski said is the opposite of what roconnor said.
10:29:31 <ski> (`0' is the only natural number which every natural number divides)
10:29:34 <monochrom> but yes 4|0, 5|0, etc
10:29:39 <roconnor> monochrom: ya I was reasoning backwards
10:30:07 <roconnor> and I was also wrong
10:30:18 <monochrom> alright I now see gcd 0 0 = 0
10:30:21 * roconnor hangs his head in shame
10:30:58 <roconnor> monochrom: also we want n `mod` 0 = n
10:31:19 <monochrom> but there is a disagreement among people in favouring the | order vs favouring the ≤ order.
10:31:40 <ski> (of course `gcd' really only gives the result up to associated elements)
10:31:44 <moisan> Hi, I've been looking at the maximum function, why doesn't it use foldl1' instead of foldl1? I had a bunch of stack overflow problems and fixed them by redefining maximum with foldl1'
10:32:49 <ski> (monochrom : surely noone is suggesting `d =< gcd a b  <=>  d =< a /\ d =< b', for `=<' being the additive order ?)
10:33:17 <monochrom> no one is suggesting that
10:34:38 * ski would like to see a sensible argument for the additive order ..
10:35:33 <monochrom> gcd a b | a ∧ gcd a b | b ∧ ∀d. d|a ∧d|b ⇒ d ≤ gcd a b
10:36:27 <ski> but that doesn't translate nicely to an adjunction :(
10:37:16 <monochrom> that is the traditional definition and if you want to push forward gcd 0 0 = 0 you are essentially fighting that tradition
10:37:53 <monochrom> your weapon is "since we're doing it for Num we shouldn't rely on Ord"
10:38:01 <Jafet> Compromise: gcd 0 0 = Left 0
10:40:00 <Jafet> moisan: possibly because the report uses foldl1, and using foldl1' changes strictness
10:40:07 <Jafet> At least, that was the reasoning I heard
10:40:09 <ski> Jafet : with what type for `gcd' ?
10:40:19 <Jafet> ...wait, strictness doesn't really matter for maximum.
10:40:38 <Jafet> ski: Either a a?
10:40:47 <roconnor> @type gcd
10:40:48 <lambdabot> forall a. (Integral a) => a -> a -> a
10:41:23 <roconnor> monochrom: Integral is Ord :(
10:41:37 * ski ponders abolishing the term `quotient object' (in favor of `factor object' ?)
10:41:46 <monochrom> gcd is for general Num, you can argue that
10:41:51 <alco> I think there's a bug in http://tryhaskell.org/#22
10:42:08 <mercury^> monochrom: I do not understand your line
10:42:09 <monochrom> oh wait, sorry, you're right, Integral is Ord, we are damned
10:42:09 <mercury^> 17:50 < monochrom> gcd a b | a ∧ gcd a b | b ∧ ∀d. d|a ∧d|b ⇒ d ≤ gcd a b
10:42:13 <roconnor> @type quotRem
10:42:13 <mercury^> Can you explain it?
10:42:14 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
10:42:34 <alco> I've typed in `let (_, (x:_)­) = (10, "abc"­) in x` and it didn't recognize it as the right answer because it was expecting 'a' instead of 'x'
10:42:45 <monochrom> ∧ is conjunction, ∀ is universal quantification, ⇒ is implication
10:43:11 <roconnor> mercury^: gcd a b is the unique d such that d | a ∧ d | b ∧ ∀d'. d'|a ∧d'|b ⇒ d' ≤ d
10:43:23 <alco> this might lead newbies to think the can't choose random names for formal parameters
10:43:39 <mercury^> roconnor: | is ‘or’?
10:43:46 <monochrom> | is divisibility
10:43:53 <roconnor> | is divides
10:44:04 <Xaratas> or is ||
10:44:11 <roconnor> mercury^: gcd a b is the unique d such that (d | a) ∧ (d | b) ∧ ∀d'. (d'|a) ∧ (d'|b) ⇒ d' ≤ d
10:44:38 <copumpkin> why <= and not | ?
10:44:39 <monochrom> if I bother to use ∧ for conjunction, would I use the kludgy evil inspired-by-stupid-C | for disjunction?
10:44:43 <mercury^> Ah, I had the associativity of the operators wrong. (And that somehow did not occur to me.)
10:44:59 <roconnor> copumpkin: because some people are stuck in the 19th century
10:45:04 <copumpkin> ah
10:45:12 <copumpkin> cause if it's |, it looks like a product
10:45:19 <monochrom> you should ask Euclid why he used ≤
10:45:25 <ski> mercury^ : define `greatest_=< x. P x' as `P x /\ forall y. P y => y =< x', then what monochrom said is `let d = gcd a b in least_=< d. d | a /\ d | b'
10:45:32 <roconnor> basically Euclid was a moron
10:45:42 <copumpkin> oiclid and yuler
10:46:07 <Jafet> Nah, he was just minutely recording the moronicity of his contemporaries
10:46:51 <roconnor> Euclid should have read Galois
10:47:11 <monochrom> || is parallelity, not disjunction. ∨ is disjunction
10:47:42 * ski wonders who's responsible for tryhaskell.org
10:47:53 <copumpkin> chrisdone
10:48:03 <roconnor> *EccDsaSecp256k1> recip (57 :: Zp) * 57
10:48:05 <roconnor> Zp 47
10:48:22 <roconnor> I fail at the Euclidian algorithm
10:48:26 <thoughtpolice> ski: chris done is, iirc
10:48:29 <ski> preflex: xseen chrisdone
10:48:29 <preflex>  chrisdone was last seen on freenode/#haskell 36 days, 23 hours, 22 minutes and 51 seconds ago, saying: Ah, yeah, I did, but in the dev branch.
10:48:54 <alco> is he the only one who can fix it?
10:49:05 <ski> alco : you should try to report that to chrisdone i think .. although he hasn't been here in a month
10:49:21 <alco> ok, thanks, I'll send him an email
10:49:50 <roconnor> oh actually
10:49:53 * ski likes the module name `EccDsaSecp256k1'
10:50:21 <roconnor> turn out I fail at multiplication
10:50:31 <ski> haha :)
10:51:01 <Bfig> i think i'm finally done with it. took a lot of worth but that's *it*
10:51:09 * ski wonders whether `quota' and `quotient' means the same thing
10:51:12 <Bfig> s/worth/work
10:51:17 <byorgey> Bfig: congrats!
10:51:21 <Bfig> :D
10:51:22 <roconnor> *EccDsaSecp256k1> recip (57 :: Zp) * 57
10:51:23 <roconnor> Zp 1
10:51:28 <ski> better
10:51:29 <Bfig> thanks
10:51:42 <byorgey> Bfig: what are you done with?
10:52:19 <ski> roconnor : which domain is `Zp' ?
10:52:26 <Bfig> byorgey, http://www.fing.edu.uy/inco/cursos/progfunc/pmwiki/uploads/Main/Tarea2011.pdf
10:52:34 <roconnor> ski: p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
10:52:47 <roconnor> > showHex 115792089237316195423570985008687907853269984665640564039457584007908834671663 ""
10:52:48 <lambdabot>   "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
10:52:48 <ski> why that particular number ?
10:52:59 <ski> > length "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
10:53:00 <lambdabot>   64
10:53:02 <byorgey> that's not very random
10:53:03 <ski> ok
10:53:25 <monochrom> hehe
10:54:02 <bos> ski: Zp is the -padic reals
10:54:06 <bos> uh, p-adic
10:54:08 <byorgey> Bfig: it was probably a lot of worth too! ;)
10:54:22 <roconnor> bos: it is just modular arithmetic mod that number I wrote
10:54:24 <Bfig> byorgey, it was an exercise in MESSY code
10:54:29 <byorgey> hehe
10:54:34 <bos> p-adic *integers*, sorry.
10:54:39 <bos> Qp is the p-adic reals
10:54:40 * roconnor renames the type Fp
10:54:54 <Bfig> i think i haven't programmed something as hideous as this, even when i had to touch ipc v in unix...
10:55:37 <ski> roconnor : "Primes just less than a power of two" <http://primes.utm.edu/lists/2small/> ?
10:58:38 <ski> (bos : i was thinking `Zp' here was short for `Z\(p*Z)' ..)
10:58:39 <xplat> roconnor: what is Zp?
10:59:15 <ski> (or s:\:/:)
10:59:31 <roconnor> xplat: integers mod p
10:59:54 <xplat> roconnor: oh, where p is that ginormous prime
10:59:55 <monochrom> yes Zp = Z/(pZ) = integers mod p
11:00:10 <roconnor> xplat: yes
11:01:40 <xplat> roconnor: you should just do the pre-adeles and pick out the one you want by laziness :)
11:02:12 <xplat> that way you don't have to do hacks to reflect the prime into the type system
11:02:32 <amitava> i am reading Fun with Type Functions (version 3) at http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
11:02:48 <amitava> is there a video somewhere for the slides in pdf?
11:03:43 <Egbert9e9> so i want to write a bunch of haskell that'll download html files, look up links inside of them and download some more
11:03:53 <roconnor> pre-adeles?
11:05:00 * ski sees `pre-adele' briefly mentioned at <http://en.wikipedia.org/wiki/Adele_ring>
11:05:09 <rwbarton> xplat: I don't think you can do that without terrible performance
11:05:19 <rwbarton> sadly
11:05:48 <roconnor> xplat: I have only one prime I care about so making a type for it isn't too onerous
11:06:47 <Egbert9e9> what kind of libs do i need?
11:06:52 <Egbert9e9> modules/libs
11:07:06 <copumpkin> roconnor: is that 2?
11:07:11 <copumpkin> if so, I have a type for you
11:07:34 <ski> the prime was given above
11:08:05 <roconnor> copumpkin: it is important that it is greater than 3
11:08:12 <copumpkin> mine is a nicer prime
11:08:23 <copumpkin> roconnor: not a fan of bleichenbacher?
11:08:35 <xplat> hm, what kind of application would you only care about one prime, yet it would be that large?
11:08:48 <Jafet> ...ECC-DSA?
11:08:54 <xplat> crcs normally stop at 64 bits or so, not nybbles
11:09:14 <copumpkin> Jafet: elliptic correcting curvodes?
11:09:18 <roconnor> copumpkin: why do you say that?
11:09:27 <Jafet> The prime forms the underlying field of the elliptic curve group
11:09:36 <copumpkin> RSA with low exponents is vulnerable, but I guess you're probably looking for the modulus
11:09:43 <roconnor> copumpkin: eliptic curve cryptography - digital signature algorithm
11:09:50 <Jafet> http://en.wikipedia.org/eiki/ECDSA
11:09:55 <copumpkin> yeah, I was just remarking on the double C
11:09:59 <copumpkin> it's usually called ECDSA
11:10:03 <roconnor> oops
11:10:06 * roconnor fixes taht
11:10:12 <Jafet> Hah
11:10:33 <copumpkin> roconnor: bleichenbacher is a simple attack on low-exponent RSA
11:10:39 <copumpkin> the most obvious of which is 3
11:10:50 <copumpkin> (which is actually how the first iphones were unlocked, maybe surprisingly)
11:11:20 <copumpkin> maybe I should say bleichenbacher is the dude who described the attack
11:11:21 <roconnor> :(
11:11:34 <copumpkin> what's wrong? :o
11:11:37 <roconnor> I didn't know about that
11:11:45 <roconnor> I'm worried about my RSA keys now
11:12:03 <xplat> huh, i wasn't aware ECDSA was useful for a fixed field
11:12:10 <copumpkin> also, if anyone's curious
11:12:24 <copumpkin> a flawed ECDSA implementation is where all the PS3 lawsuit shit is coming from
11:12:39 <xplat> (i must admit i'm woefully ignorant of EC stuff in general though)
11:12:43 <bos31337> copumpkin can be trusted to know such things :-)
11:12:44 <roconnor> copumpkin: what sort of flaw?
11:12:44 <TomMD> Egbert9e9: tagsoup
11:12:56 <roconnor> copumpkin: bad random number generator
11:12:57 <xplat> roconnor: they used the same nonce for all their signatures
11:12:58 <copumpkin> roconnor: a random number generator inspired by randall munroe
11:13:00 <copumpkin> yeah :P
11:13:19 <Egbert9e9> TomMD: ^_^ i was all up there in the backlog and you still got around to that. thanks!
11:13:26 <roconnor> wow
11:13:33 <copumpkin> bos: surely not! 
11:13:37 <xplat> buy any two games, you have the secret key
11:13:43 <roconnor> that's retarded
11:14:01 <copumpkin> the only reason nobody noticed sooner was that they hadn't locked out the linux geeks
11:14:01 <roconnor> (and also related to why I avoid DSA)
11:14:02 <Jafet> DSA (and DH) are always done with a pre-agreed group
11:14:33 <TomMD> Egbert9e9: No problem.  I actually wrote a really stupid webcrawler as an example for the control-engine library.  If you ignore the control-engine part then you shouldn't have a problem using that code / those libraries as a basis... once sec and I get the link
11:14:57 * roconnor makes a note. The constant function makes a bad random number generator
11:15:07 <Egbert9e9> TomMD: i'm really new into haskell, so i'm even more new to parsers
11:15:24 <Egbert9e9> TomMD: and i have no clue what's a control-engine
11:15:37 <copumpkin> there was a good email from bleichenbacher about the original attack
11:15:40 * copumpkin tries to find it
11:15:47 <monochrom> control engine is the opposite of data engine  <duck>
11:15:49 <xplat> Jafet: don't DSA keys normally include a modulus?
11:15:53 <TomMD> Egbert9e9: I just used tagsoup (which parses and downloads) plus bloomfilters to keep from downloading the same page twice.  http://www.haskell.org/haskellwiki/Control-Engine
11:16:10 <xplat> ('plain' DSA, that is)
11:16:32 <TomMD> Egbert9e9: Control-Engine is my library - don't use it, it's just that I did this task to show off that library.  In the end, control-engine is premature optimization to an absurd extreme.
11:16:55 <Jafet> xplat: DSA keys are random bitstrings
11:16:58 <Egbert9e9> TomMD: woah. o-o
11:17:02 <TomMD> And it's rather tailored to a particular program I was developing at that time ;-)
11:17:05 <copumpkin> anyway yeah, the original iphone was using an exponent of 3 for its RSA, and was also not padding shit correctly
11:17:18 <copumpkin> in that situation, having a larger bitsize key is actually bad for you, and lets us forge signatures quite easily
11:17:20 <roconnor> copumpkin: is pgp affected?
11:17:23 <Jafet> Er well, the secret key is
11:17:24 <roconnor> copumpkin: what about ssh?
11:17:29 <copumpkin> nah, anyone using correct padding and stuff is fine
11:17:38 <copumpkin> you need to not have padding and have a low exponent for this to work
11:17:48 <roconnor> oh
11:17:49 <copumpkin> and padding is a basic ingredient in all self-respecting RSA implementations
11:17:58 <Egbert9e9> TomMD: i'm a bit lost between all those tool names. control-engine is your thingie which does the crawling. tagsoup is a java thing which does the same?
11:18:03 <copumpkin> there are different padding schemes depending on whether you're encrypting or signing, too
11:18:08 <Jafet> Any time you hear about some encryption system being broken, it's overwhelmingly more likely that the programmer failed to read a textbook
11:18:16 <copumpkin> yeah
11:18:26 <copumpkin> naive RSA is horribly vulnerable to many things
11:18:40 <Egbert9e9> bloomfilters are some thing which helps tagsoup do the same thing as control-engine
11:18:42 <TomMD> Egbert9e9: No, tagsoup is what you should be using (http://hackage.haskell.org/package/tagsoup).  It's a haskell HTML downloader and parser.
11:18:54 <roconnor> copumpkin: but at least it isn't vulnerable to a bad random number generator
11:19:02 <TomMD> Egbert9e9: and bloomfilters are a set-like data structure (see wikipedia)
11:19:08 <Egbert9e9> http://home.ccil.org/~cowan/XML/tagsoup/
11:19:22 <copumpkin> roconnor: well, if your key generator generates constant key pairs, that might be a problem :P but yeah, not for general signatures
11:19:41 <TomMD> Egbert9e9: Whenever anyone on IRC talks about a Haskell package they are 99.9% of the time meaning something on hackage.haskell.org
11:19:46 <Egbert9e9> TomMD: wooo, set like data structure O_O
11:19:46 <roconnor> copumpkin: even with correlated random numbers there might be attacks?
11:19:54 <xplat> bloomfilters are a data structure so cute you want to just eat them up
11:19:55 <Egbert9e9> TomMD: okay, i see
11:20:13 <Egbert9e9> TomMD: i'll cabal install tagsoup
11:20:30 <smoge> Hi
11:20:32 <copumpkin> roconnor: sure, but the key generation process is so far removed from day-to-day RSA usage that it probably doesn't cause many issues! who knows though
11:20:33 <xplat> copumpkin: don't laugh, debian openssl very nearly had that problem
11:20:35 <Egbert9e9> smoge: hi ^_^
11:20:40 <copumpkin> yeah, was just going to say
11:20:45 <TomMD> Egbert9e9: Just see the wikipedia entry for Bloomfilter.  It's a common data structure in CS - nothing Haskell specific (but there is a "bloomfilter" library on hackage).
11:20:58 <copumpkin> embrace the power of the bloom filter
11:20:58 <smoge> When I install a package with cabal in ArchLinux, cabal knows I'm installing it?
11:20:59 <roconnor> copumpkin: you need a random number for every signature in DSA
11:21:04 <copumpkin> yeah, I know
11:21:04 <smoge> I mean... can I use BOTH ?
11:21:15 <smoge> pacman and cabal?
11:21:20 <roconnor> copumpkin: I don't get your key generation comment then
11:21:21 <amalloy> smoge: both cabal and cabal?
11:21:26 <copumpkin> roconnor: I was talking about RSA, not DSA
11:21:35 <smoge> amalloy: pacman and cabal
11:21:42 <copumpkin> with DSA it's more of an issue
11:21:55 <dcoutts> smoge: cabal will know about packages that you install via pacman, but not the other way around
11:21:59 <smoge> or this can cause dependency problems?
11:22:08 <smoge> I see..
11:22:13 <roconnor> god, I can't beleive sony was so stupid
11:22:21 <copumpkin> I'd imagine it's fairly trivial to figure out someone's private key if you can fully predict their prng and you have two signatures from known points in its output
11:22:39 <copumpkin> roconnor: what's more funny is that after the system was hacked, someone found the root key for the PSP buried in it too
11:22:39 <smoge> what is recommended?
11:22:40 <roconnor> I hope someone was fired, or at least someone knowledgeable was hired.
11:22:41 <Egbert9e9> TomMD: i see... hmm.. all the data structures i know are.. uh.. strings, lists, arrays and trees.. oh, there are hash tables, too, but i have no idea how to write them in haskell.. i don't know how to write arrays, either :-/
11:22:44 <smoge> use just cabal?
11:22:49 <copumpkin> roconnor: nah, it's much safer to just sue the people who did it
11:22:54 <copumpkin> it'll ensure it won't happen again
11:23:10 <TomMD> @hackage bloomfilter
11:23:10 <lambdabot> http://hackage.haskell.org/package/bloomfilter
11:23:14 <dcoutts> smoge: or use pacman for the core stable stuff, and cabal for things that are not provides via arch
11:23:25 <TomMD> Egbert9e9: If you know how to read haddock documentation then just see the above link.
11:23:47 <Egbert9e9> oh wow, probablistic data structure. that's a new concept for me.
11:24:41 <xplat> i don't get people who won't spend a million dollars to properly secure a billion dollar cryptosystem, especially if it's the third generation machine in a fairly mature market so they should definitely have the million
11:24:48 <monochrom> I don't know whether I should thank God or feel depressed when high-profile companies use crypto in retarded trivially crackable ways
11:25:15 <xplat> (although i don't think it's really a billion dollar cryptosystem, yet they apparently think so)
11:25:20 <roconnor> monochrom: ya
11:25:40 <monochrom> thank God for how they foil their own evil close-everything plans. depressed for the retarded humanity
11:25:47 <copumpkin> xplat: the money is much better set in trying to scare potential hackers into anonymous paste-site hacking
11:25:50 <ousado> xplat: what are you referring to?
11:26:02 <Egbert9e9> depressed for the privacy concerns, too
11:26:29 <Egbert9e9> if things that should be cracked gets cracked, things that shouldn't get cracked too
11:26:34 <smoge> thanks
11:26:41 <xplat> instead, they just say 'we'll get some mid-level developer guy to skim some wikipedia articles on cryptography and whip something up'
11:27:37 <roconnor> xplat: think of the money they could have saved in lawsuits if they hired a consultant
11:27:41 <monochrom> perhaps it's a round-about smart way. evil retarded managers tell engineers "protect it or you're fired". engineers say "yessir" but secretly screw up something as "accident".
11:27:55 <roconnor> :)
11:29:32 <monochrom> indeed, for every DVD device that has region protection, there exists replacement firmware on the web to annihilate its region protection
11:30:05 <monochrom> I say, it's an insider job by an ethical engineer
11:30:49 <smerz> most devices have easy 2 use features to erase their "history" :-)
11:31:00 <smerz> alas one of mine had it
11:38:03 <roconnor> monochrom: how do I patch my dvd player?
11:41:32 <Egbert9e9> if i have a function that gets two video and appends them, is it possible to call that video type a monoid? will it be (a `mappend` b) `mappend` c == a `mappend` (b `mappend` c) for mpeg and co.? or maybe just for lossless types that weight several ton of bytes?
11:41:56 <beastaugh> Is cabal test easy to use? I've had trouble finding any documentation that spells out simply and clearly just what you have to do to get it working
11:42:49 <Egbert9e9> feeling clever for recognizing a possible monoid -_-
11:43:50 <xplat> Egbert9e9: probably videos with the same encoding parameters will be a monoid
11:44:41 <xplat> so you'd get different monoids for different sets of parameters
11:45:27 <mercury^> Egbert9e9: even if the bytestream will not be identical, it might be a monoid on another level that is more important (recognisable video content).
11:46:12 <Egbert9e9> heeee ^_^
11:46:44 <xplat> mercury^: unfortunately 'recognisable video content' can become a pretty fuzzy notion if you push the codecs as hard as some people do
11:46:54 <TomMD> Now the question is: does instantiating it as a Monoid actually get you anything?
11:47:26 <Egbert9e9> TomMD: if i have a bunch of vids i'd like to concat
11:47:52 <Egbert9e9> TomMD: uhm.. i'd not like to append a to b and then ab to c and then abc to d -_-
11:48:46 <Jafet> Well, you can concatenate two MPEG-1 byte streams and get a valid concatenated stream
11:48:54 <xplat> you could consider videos abstractly as functions from (a bounded interval of) time to pictures
11:50:03 <Egbert9e9> WOAH O_O (<- this is what happens when a biology student goes into an ultra abstract language's channel on freenode)
11:50:16 <xplat> and use that as your semantic domain for the 'type class morphisms' method of interface design as originally championed by conal 
11:51:03 <Egbert9e9> conal was the first to push the typeclass/instance thingie?
11:51:45 <Egbert9e9> (i have no idea who that is but that name looks familiar)
11:53:24 <xplat> Egbert9e9: he was the first to name and explicitly push the approach where you should think about what your datatypes 'really' represent and implement the typeclasses that the real thing would support in such a way that the 'real' version of the result of your typeclass operation on some objects is the same as applying the 'real' version of the operation to the 'real' versions of the inputs
11:55:10 <mm_freak> Egbert9e9: in general raw video composition with compression forms a groupoid with identity, but there is no class for that in the base library
11:55:12 <Egbert9e9> i.. uh.. that's.. uh.. uhm.. wat?
11:56:00 <mm_freak> if you can make sure that mappend (mappend a b) c == mappend a (mappend b c) with your Eq instance, then you have a proper monoid
11:56:16 <mm_freak> that's what xplat refers to…  (==) should not compare on a byte level, but /interpret/ the data
11:56:22 <ski> (you also need an identity)
11:56:27 <mm_freak> for example decode the videos and compare their raw streams
11:56:36 <Egbert9e9> mm_freak: ah!
11:56:43 <mm_freak> identity would be the empty video
11:56:56 <Egbert9e9> mm_freak: but with lossy compressed stuff, (==) needs human input
11:57:09 <mm_freak> why?
11:57:13 <Egbert9e9> mm_freak: or... some very good (==) function
11:57:26 <Egbert9e9> with image recognition
11:57:43 <mm_freak> huh?
11:58:10 <mm_freak> let's say:  decode :: Video -> ByteString
11:58:22 <mm_freak> then v1 == v2 = decode v1 == decode v2
11:59:02 <Egbert9e9> but lossy video might not be the same on the LHS and RHS
11:59:08 <byorgey> mm_freak: I think what Egbert9e9 means is that with lossy compression, we might be willing to consider "equal" two videos which differ only in low-order details
11:59:12 <mm_freak> Egbert9e9: that's my point#
11:59:35 <dcoutts> beastaugh: good timing, I'm planning on looking at the docs for it today
11:59:50 <beastaugh> dcoutts: oh, fantastic :)
12:00:08 <beastaugh> I'm trying to update HDBC-mysql a bit, and it's a pain to run the test cases
12:00:13 <dcoutts> beastaugh: current docs for it are here: http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
12:00:33 <Egbert9e9> this is something i shouldn't think of too much. i need to do some other things. thanks for the stimuating discussion anyways!
12:00:38 <xplat> the problem is it's not easy to get a 'fuzzy' comparison with a proper Eq instance
12:00:53 <xplat> (transitivity tends to fail)
12:00:54 <Egbert9e9> xplat: ya, that's why we need turks
12:01:23 <mm_freak> Egbert9e9: well, you can still write a groupoid class
12:01:54 <xplat> yeah, turks will tend to compare transitively in practice, even though someone could come up with a series of maliciously designed videos to break the transitivity
12:02:12 <Egbert9e9> mm_freak: groupoid is a new concept for me. lets see
12:02:36 <beastaugh> dcoutts: thanks, I think the last version of the cabal user's guide I looked at was for version 1.8
12:02:36 <mm_freak> Egbert9e9: an associative groupoid with identity element is a monoid
12:03:05 <dcoutts> beastaugh: yes, I've not updated the website for the new release, that's what I'm planning to do soon
12:03:06 <xplat> but algorithms we create are liable to fail accidentally
12:03:17 <mm_freak> i.e. groupoid is a less strict monoid, where the operation is not required to be associative, and the identity element is optional
12:04:09 <Egbert9e9> mm_freak: so it's like saying, "meh, lets give up and forget about it" o-o
12:04:21 <mm_freak> the question is, of course, whether you really want to do video compression in 'mappend'
12:04:26 <xplat> mm_freak: please use the term 'magma' for that, the other sort of groupoid is a better fit to the word
12:04:32 <Egbert9e9> mm_freak: well, it's a funny idea.
12:05:01 <mm_freak> xplat: true
12:05:05 <xplat> (and using the same word for both is just confusing)
12:05:06 <ski> mm_freak : hm, isn't that called `magma' ?
12:05:17 <copumpkin> semigroup is the only named thing less than monoid, as far as I know
12:05:29 <mm_freak> Egbert9e9: yes, but not very practical…  as a user of your library/program i would like some feedback to the encoding process ;)
12:05:35 <Egbert9e9> i stare at that table over at wikipedia with all those group-like structures
12:05:36 <xplat> welcome to #haskell, where your answers are questioned in majestic stereo!
12:05:49 <copumpkin> well, there's magma, obviously
12:05:59 <copumpkin> but magma is a pretty boring "structure"
12:06:06 <Egbert9e9> mm_freak: i have no booping idea O_O sorry
12:06:07 <mm_freak> ski: groupoid is also a valid term, and that's the one i grew up with =)
12:06:24 <copumpkin> mm_freak: groupoid means something else in CT though
12:06:33 <Egbert9e9> xplat: where your questions are questioned, too
12:06:44 <mm_freak> copumpkin: yeah, i figured
12:06:59 <mm_freak> Egbert9e9: my encoder would probably look something like:
12:07:02 * ski didn't know Bourbaki introduced the term `magma' ..
12:07:11 <mm_freak> encode :: Iteratee Frame m Video
12:07:51 <Egbert9e9> mm_freak: where are all the arrows in the function type definition?
12:08:03 <mm_freak> and my decoder would look like:  Video -> Enumerator Frame m b
12:08:15 <mm_freak> Egbert9e9: there are none
12:08:24 <Egbert9e9> mm_freak: O_O how come?
12:08:38 <xplat> mm_freak: perhaps a reasonable design would be to have a type of videos that don't necessarily have bitstreams.  use a monoid to concatenate some videos together, then use an encoding step to project the composite video to a bitstream
12:08:44 <mm_freak> Egbert9e9: because it's not a function, but don't bother
12:09:11 <mm_freak> xplat: yeah, but still this really appears to be stream processing to me
12:09:26 <mm_freak> and stream processing cries for iteratees
12:09:37 <xplat> mm_freak: pah, implementation detail
12:09:55 <mm_freak> xplat: nope, because you get two different interfaces
12:10:07 <mm_freak> with one you compose videos, with the other you compose frame enumerators
12:10:24 <xplat> mm_freak: you shouldn't let your implementation details leak into your interface like that
12:10:45 <Egbert9e9> mm_freak: it's not a function?
12:11:07 <mm_freak> xplat: it's like saying that foldr shouldn't be exposed from Data.List ;)
12:11:13 <xplat> Egbert9e9: it's a value of a data structure that (usually) contains one or more functions
12:11:33 <mm_freak> Egbert9e9: depends on the implementation…  in the 'enumerator' package an iteratee is not a function
12:11:38 <Egbert9e9> xplat: like getLine
12:11:55 <mm_freak> in the 'iteratee' package it is a function under the hood
12:12:04 <xplat> Egbert9e9: the way you use it is actually kind of similar to getLine
12:12:20 <mm_freak> well, yes, if you use the monadic interface
12:12:34 <mm_freak> but according to xplat you must do so and never use Iteratee constructors =P
12:12:57 <conal> Egbert9e9: if you want to check out the denotational design approach, see http://conal.net/papers/type-class-morphisms/. this methodology will guide you to solid, elegant, & leak-free design. if you do read the paper and give it a go, i'll be happy to answer questions.
12:13:01 <xplat> heh, i'm flattered you remembered :)
12:13:50 <Egbert9e9> mempty is not a function either
12:14:03 <mm_freak> why would it be a function?
12:14:12 <Egbert9e9> can i call something without arrows a function? a function with no parameters?
12:14:15 <mm_freak> well, it /can/ be a function =)
12:14:20 <mm_freak> no
12:14:27 <Egbert9e9> hmm
12:14:31 <mm_freak> otherwise everything is a function
12:14:35 <copumpkin> o shit
12:14:35 <mm_freak> like 'x'
12:14:38 <copumpkin> everything is a function
12:14:39 <mm_freak> or Nothing
12:14:46 * copumpkin summons church
12:15:00 <conal> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
12:15:28 <Egbert9e9> church is another glowy eyed templar of CS?
12:15:29 <Jafet> I think it's best to separate Church and State.
12:15:31 <copumpkin> if you want everything to be a function, write all your code in the untyped lambda calculus
12:16:21 <mm_freak> you have a function, once you can use application
12:16:24 <mm_freak> > Nothing 3
12:16:25 <lambdabot>   Couldn't match expected type `t1 -> t'
12:16:25 <lambdabot>         against inferred type `Data....
12:16:36 <mm_freak> obviously Nothing is not a function
12:16:58 <Jafet> I still wish for a class Function
12:17:11 <mm_freak> the application operator has the type (a -> b) -> a -> b and its first argument is a function
12:17:16 <mm_freak> so a function requires the arrow
12:17:37 <monochrom> what is a function?
12:18:02 <mm_freak> a value, whose type is an instance of a -> b
12:19:21 <Egbert9e9> \o/ <- me with hands in the air, gaping mouth and eyes open wide exclaiming: "woah!"
12:19:31 <ClaudiusMaximus> regarding http://hackage.haskell.org/package/hmpfr , how easy is it to compile a ghc with integer-simple ?  (currently i have 6.12.3 on this machine)
12:20:55 <ClaudiusMaximus> i did foolishly try to write my own huge floating point type, but almost 2 mins for a minimal test program that just computes log (exp 10) means i should really give up that idea :)
12:21:42 <Jafet> > drop 9000 $ showCReal 1000 $ log (exp 10)
12:21:44 <lambdabot>   ""
12:21:49 <Jafet> > drop 9000 $ showCReal 10000 $ log (exp 10)
12:21:52 <lambdabot>   mueval-core: Time limit exceeded
12:22:40 <ClaudiusMaximus> Jafet: i got this as output, in case you're curious: 9.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999995561428
12:23:00 <ClaudiusMaximus> which is a bit imprecise :)
12:23:10 <Jafet> You can simulate climate change with that!
12:23:24 <TheZimm> :P
12:24:01 <roconnor> can someone check for me if 115792089237316195423570985008687907853177846645995842846068537748949929705793 is prime?
12:24:13 <TomMD> > isPrime 115792089237316195423570985008687907853177846645995842846068537748949929705793
12:24:14 <lambdabot>   Not in scope: `isPrime'
12:24:16 <TomMD> damn
12:24:17 <ClaudiusMaximus> @oeis 115792089237316195423570985008687907853177846645995842846068537748949929705793
12:24:17 * Jafet flips a coin
12:24:17 <lambdabot>  Sequence not found.
12:24:32 <roconnor> maybe wolfram alpha knows
12:24:41 <copumpkin> no it isn't
12:24:52 <monochrom> 7 is a divisor
12:24:57 <copumpkin> yeah
12:25:07 <roconnor> hmm
12:25:30 <monochrom> after that, it takes elliptic curve or quadratic sieve or more to factor, but still no prime after getting rid of 7
12:25:44 <monochrom> 7 * 16541727033902313631938712144098272550453978092285120406581219678421418529399 so far
12:25:45 <copumpkin> you running qsieve on it too?
12:26:01 <monochrom> I run my homebrew elliptic curve written in haskell!
12:26:02 <copumpkin> it spits out 7 immediately, then does a lot of other shit
12:26:19 <copumpkin> > 7 * 13912030020105210431 * 1189023241755283100244821180496165915298682462337659369929
12:26:19 <monochrom> oh nice, 7 * 13912030020105210431 * 1189023241755283100244821180496165915298682462337659369929
12:26:20 <lambdabot>   115792089237316195423570985008687907853177846645995842846068537748949929705...
12:26:23 <copumpkin> :P
12:26:38 <copumpkin> monochrom: neat, is your code up anywhere?
12:26:40 <monochrom> elliptic curve is a lot of luck, and sometimes it is way too lucky
12:26:43 <monochrom> no
12:27:08 <mm_freak> i ran GP
12:27:08 <Jafet> Heh, my homebrew elliptic curve written in haskell found it too
12:27:16 <mm_freak> 20 secs
12:27:19 <TomMD> @hackage hecc
12:27:20 <lambdabot> http://hackage.haskell.org/package/hecc
12:27:25 <TomMD> ecc code in haskell here too ^^
12:27:38 <copumpkin> not factoring code though?
12:27:44 <TomMD> No, I don't think so.
12:28:43 <TomMD> Welcome back
12:28:45 <mm_freak> copumpkin: ECM factoring is pretty straightforward, once you have the EC arithmetic
12:28:51 <monochrom> does this mean roconnor's crypto stuff is fundamentally broken? :)
12:29:06 <roconnor> monochrom: no
12:29:14 <roconnor> I means I'm misunderstanding something in this document
12:29:17 <monochrom> the EC arithmetic is nightmarish in implementation
12:29:28 <roconnor> monochrom: it's not so bad
12:29:36 <mm_freak> roconnor: it's bad, if you want it to be fast
12:30:03 <mm_freak> textbook EC is pretty easy
12:30:07 <monochrom> I still procrastinate parallelizing my ECM implementation :)
12:30:09 <roconnor> the paper says that that number is supposed to be the order of the group  generated by G and it is supposed to be prime, but it isn't the order, nor is it prime.
12:30:17 <roconnor> mm_freak: bah fast
12:30:29 <roconnor> do I look like I care about speed
12:30:32 <roconnor> I'm using Haskell after all
12:30:33 <Egbert9e9> TomMD: ^_^
12:30:48 <mm_freak> roconnor: that's not a contradiction…  i always go for speed in haskell =)
12:30:51 <monochrom> @fmap  roconnor
12:30:51 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
12:31:01 <monochrom> hrm!
12:31:43 <roconnor> I'm worried this document has a typo
12:32:00 <monochrom> ooooh, math paper
12:32:01 <TomMD> In a number that is supposed to be prime?
12:32:18 <roconnor> no
12:32:21 <Jafet> Maybe it refers to the torsion group, or something
12:32:40 <Jafet> Or do you mean you want to search every one-digit edit for primes
12:32:44 <roconnor> monochrom: SEC 2: Recommended Elliptic Curve Domain Parameters
12:33:14 <roconnor> Jafet: base-16 edit errors
12:33:33 <roconnor> > showhex 115792089237316195423570985008687907853177846645995842846068537748949929705793 ""
12:33:34 <lambdabot>   Not in scope: `showhex'
12:33:39 <roconnor> > showHex 115792089237316195423570985008687907853177846645995842846068537748949929705793 ""
12:33:40 <lambdabot>   "ffffffffffffffffffffffffffffffffbaaedce6af48a03bbfd25e8cd0364141"
12:34:16 <monochrom> befriend the project euler guy and put it on project euler
12:34:28 <Jafet> Oh wait, I used my homebrew C++ ecm, not my homebrew haskell ecm
12:34:34 <Jafet> Was wondering why it was so fast
12:34:42 <monochrom> "find all primes that are edit distance 1 from this hex number!"
12:34:51 <monochrom> hahahaha
12:35:01 <absentia> waht's the latest/stable haskell (platform?) for osx 10.6.7 ?
12:36:01 <absentia> nevermind, KI'm taking whatever haskell.org gives me.
12:36:55 <roconnor> the revised paper has the same number
12:37:20 <roconnor> is there an easy way to compute the number of points on an elliptic curve?
12:37:30 <crystal-cola> roconnor: no
12:39:22 <Jafet> There are reasonably fast ways, but none are easy
12:40:15 <roconnor> what am I doing wrong here ...
12:40:41 <crystal-cola> roconnor: what part of the paper are you checking?
12:41:04 <Jafet> Well, using gp is reasonably easy.
12:41:05 <xplat> < Jafet> You can simulate climate change with that!
12:41:07 <Egbert9e9> i've read a bunch of reasons of why people think a value is a function with no arguments, but i still don't get why a value isn't a function
12:41:15 <xplat> sounds like you could CAUSE climate change with that :)
12:41:21 <roconnor> cynick: it says the order n of G is this number (and the cofactor is 1)
12:41:37 <roconnor> cynick: so I'm adding G to itself n times and not getting 1
12:41:41 <roconnor> er
12:41:42 <roconnor> Infinity
12:42:02 <Jafet> Egbert9e9: some values are functions, and some values are not functions.
12:42:24 <Jafet> A value of type a -> b, where a and b are any types, is a function; all other values are not functions
12:42:48 <crystal-cola> roconnor: this www.secg.org/collateral/sec2_final.pdf ? which section
12:42:48 <monochrom> Egbert9e9: the same both sides of the argument argue over "is a real number a complex number" too
12:43:21 <rostayob> I have defined this data type using existential types: http://hpaste.org/45730/existential_types , now when I try to get "connPool" out, I get this error: "Cannot use record selector `connPool' as a function due to escaped type variables"
12:43:31 <edenc> monochrom: which it is
12:43:32 <rostayob> why's that?
12:43:34 * edenc ducks
12:43:38 <roconnor> copumpkin: 2.7.1
12:43:40 <roconnor> er
12:43:42 <roconnor> crystal-cola: 2.7.1
12:43:42 <rostayob> I mean why do I have to use pattern matching?
12:43:52 <roconnor> maybe I'm adding points wrong
12:44:15 <roconnor> though it can't be that wrong since my results still are on the curve
12:44:27 <Egbert9e9> i'll try forgetting the "everything is a function" meme and later learn why it is false
12:44:29 <monochrom> in fact it boils down to platonist vs formalist
12:44:37 <Jafet> roconnor: check all your steps with gp; that's how I wrote my homebrew ecm
12:44:44 <roconnor> what is gp?
12:44:44 <rostayob> (it works with pattern matching)
12:45:04 <Eduard_Munteanu> rostayob: the thing with existentials is you can't get them out
12:45:08 <Jafet> A number theory calculator with weird syntax and a ton of classy algorithms.
12:45:08 <edenc> Egbert9e9: it's not a meme, it's math
12:45:38 <edenc> Egbert9e9: any value can be replaced by a function
12:45:38 <Egbert9e9> but what about haskell?
12:45:48 <monochrom> haskell is not math
12:45:51 <Jafet> I wouldn't be surprised if it could count points, too
12:46:00 <Eduard_Munteanu> rostayob: you can work on them in instances of that typeclass though
12:46:08 <Jafet> Especially since the author of gp wrote a book chapter about doing just that
12:46:12 <rostayob> Eduard_Munteanu: well I can get that out with pattern matching
12:46:12 <Egbert9e9> edenc: i should have said: "everything is a function in haskell"
12:46:26 <rostayob> I mean I just see it like
12:46:30 <Eduard_Munteanu> rostayob: yes but you don't know its type.
12:46:32 <monochrom> () is not a function in haskell. wrong type.
12:46:33 <xplat> you could say that an arrowless type is a nullary function the same way you could say a type like a -> b -> c is a binary function.  however it's much more often a useful way to think in the latter case than the former
12:46:34 <roconnor> Jafet: where is gp?
12:47:03 <rostayob> Eduard_Munteanu: yeah but couldn't it be simply connPool :: forall s. Service s => Context -> s?
12:47:12 <xplat> anyway, the distinguishing feature of pure functional languages (as opposed to PTS :) is not that all values are functions, but that all functions are values
12:47:27 <monochrom> a programming language does not have to suck up to platonist mathematics
12:47:29 <xplat> it's important to remember this
12:47:59 <Egbert9e9> xplat: zomg! that sentence just blew up my mind
12:48:44 <roconnor> crystal-cola: oh
12:48:45 <nazgjunk> Your mind is easily blown up
12:48:55 <roconnor> crystal-cola: there is an e at the end of that string of f's
12:49:10 <edenc> monochrom: it doesn't have to, but haskell goes a lot closer to it than other languages
12:50:00 <roconnor> *EcDsaSecp256k1> (0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 `scale` g)
12:50:02 <roconnor> Infinity
12:50:03 <roconnor> yay
12:50:11 <roconnor> > 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
12:50:12 <lambdabot>   115792089237316195423570985008687907852837564279074904382605163141518161494...
12:50:13 <crystal-cola> glad to help!
12:50:18 <roconnor> this is prime
12:50:19 <monochrom> actually by using distinct types Integer and Rational, and by refusing a subtype relation between them, haskell stays a lot further.
12:51:02 <monochrom> scheme would be the one going closer, by moving up and down the number hierarchy wantonly
12:51:04 <Jafet> The report says that arrowless types are not function types, so that settles the matter for haskell
12:51:19 <Jafet> @google pari/gp
12:51:21 <lambdabot> http://pari.math.u-bordeaux.fr/
12:51:21 <lambdabot> Title: PARI/GP Development Headquarters
12:51:48 <monochrom> in fact I saw an instance of scheme implementation that figured that sqrt(2)*sqrt(2) is an integer. I'm amazed.
12:51:57 <Jafet> ...until we get class Function
12:52:02 <Bfig> need a very quick fix: how can i go from a 'left parsing tree' to a 'right parsing tree' easily?
12:52:29 <Jafet> monochrom: (...by rounding and guessing, probably)
12:53:22 <Eduard_Munteanu> rostayob: that type would be impredicative I think.
12:53:44 <roconnor> Jafet: of course then a -> b -> c isn't a binary function either.  It is clearly a unary function :)
12:53:50 <roconnor> (all functions being unary)
12:54:00 <Eduard_Munteanu> forall s . X s    vs    X (forall s . s)
12:54:06 <Jafet> Yes; clearly
12:55:02 <Jafet> Well, is a -> ReadS a unary or binary?
12:55:15 <monochrom> @quote monochrom 17-ary
12:55:15 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
12:56:06 <Eduard_Munteanu> Which is different, if you do { ... connPool :: forall s. ConnPool s }
12:56:27 <Jafet> To me, arity is a feature of syntax
12:56:27 <rostayob> Eduard_Munteanu: oh, right. can I do that?
12:57:36 <dons> any mac users? we need some beta testing of the haskell platform installer, esp. if you have xcode 4.
12:58:03 <smoge> hi!
12:58:08 <dons> install from here,  http://lambda.galois.com/hp-tmp/2011.2.0.1/ and let me know if running "cabal install" on your favorite package works.
12:58:12 <Eduard_Munteanu> Yeah though that's a rank-2 type instead AFAICT.
12:58:18 <smoge> how is the haskell suppoert on Eclipse??
12:58:19 <monochrom> (ubuntu 11.04 (beta) looks like mac, does that count? :) )
12:58:44 <rostayob> Eduard_Munteanu: yep
12:58:47 <rostayob> ok I'll try now
12:59:00 <monochrom> if you use EclipseFP I think it's pretty good
12:59:00 <Jafet> ubuntu is bad enough without an xcode somehow on it!
12:59:31 <monochrom> actually, s/think/heard/
12:59:31 <Locke1689> Hi everyone. I was hoping someone could help me with a stylistic question and monadic error handling. I'd like to transform this nasty Either chain into something clean and monadic http://hpaste.org/45731/either_error
13:00:03 <Locke1689> I assume constantly checking for Left in a series of Eithers is not the preferred way to do this
13:00:18 <rostayob> Eduard_Munteanu: yeah, that works but then doesn't suit my needs for other reasons
13:00:36 <monochrom> Locke1689: you may draw inspiration from my http://www.vex.net/~trebla/haskell/exception.xhtml
13:00:52 <Eduard_Munteanu> rostayob: what do you want to do?
13:01:25 <Jafet> Woah, that code must have been what kmc meant by invisible train
13:01:29 <rostayob> Eduard_Munteanu: well there is this ConnPool type which belongs to the class "Service"
13:01:41 <rostayob> i mean a type family
13:01:45 <boegel> how would I write a function that returns the string representation of *a* value of the type passed as an argument?
13:01:57 <boegel> e.g. strVal Int = "1::Int"
13:02:06 <boegel> would that ever work?
13:02:08 <crystal-cola> no
13:02:19 <dons> just mac users 
13:02:21 <rostayob> and then I need to use that ConnPool s in some functions with type signature f :: Service s => ConnPool s -> etc...
13:02:31 <Zao> boegel: What language is that supposed to be?
13:02:42 <MatrixFrog> boegel, isn't that kind of what the "show" function is?
13:02:42 <boegel> Zao: Haskell ^^
13:02:42 <rostayob> with Rank2Types it gives me "ambiguous type s0" when trying to invoke those functions
13:02:53 <Zao> forall a. Show a => a -> String
13:02:58 <boegel> Maxdamantus: yeah, but I need to explicit type
13:03:02 <Zao> @type show
13:03:03 <lambdabot> forall a. (Show a) => a -> String
13:03:14 <boegel> Zao: also, show does it for a particular value of a certain type
13:03:20 <boegel> Zao: I don't care about the value
13:03:21 <Zao> Ah, parens, but I was close :D
13:03:44 <rostayob> boegel: you could use the Data and Typeable stuff I think
13:04:01 <Zao> boegel: Well, which value?
13:04:13 <boegel> I just want a function that, given a particular type, gives back a string representation of a value of it (with the ::Type added)
13:04:15 <Zao> You'd need a Default typeclass or something.
13:04:15 <boegel> Zao: any value
13:04:22 <rostayob> :t dataTypeOf
13:04:23 <lambdabot> forall a. (Data a) => a -> DataType
13:04:29 <rostayob> boegel: that should help you
13:04:41 <boegel> rostayob: hmm, thx, I'll look into that
13:05:33 <rostayob> boegel: but of course it would work with Data instances only
13:05:38 <boegel> rostayob: googling that is kind of hard :)
13:05:41 <rostayob> > dataTypeOf (1 :: Int)
13:05:41 <lambdabot>   DataType {tycon = "Prelude.Int", datarep = IntRep}
13:05:59 <boegel> rostayob: well, there's the rub
13:06:01 <xplat> you could abuse quickcheck to give you a value
13:06:11 <boegel> rostayob: dataTypeOf requires a value, which I don't have
13:06:24 <xplat> the ::Type is a whole other matter of course
13:06:39 <xplat> boegel: use (undefined :: AType)
13:06:49 <boegel> xplat: hmm
13:06:53 <rostayob> boegel: what xplat  said :P
13:06:59 <boegel> xplat: that would work, good idea
13:07:06 <Jafet> (Arbitrary a, Typeable a) => sounds like an interesting thing to put in a signature
13:07:50 <Dina_> Helo, i need advice, i am new to programming, i mean i did not write real programs for companies and like that but i know a little about c and perl.. i want to master a language that is general purpose and in demand. is haskell a good choice?
13:08:06 <Eduard_Munteanu> rostayob: why not make ConnPool an existential type instead?
13:08:23 <rostayob> Eduard_Munteanu: because it doesn't depend on me, but on the developer of the mongoDB bindings :P
13:08:25 <hpc> Dina_: haskell is general purpose, but not "in demand"
13:08:40 <hpc> Dina_: imo, learning it will significantly improve your general understanding of programming though
13:08:59 <Eduard_Munteanu> Mm, you could make a wrapper around it.
13:09:00 <blackh> Dina_: But Haskell is much, much better than C or perl.
13:09:11 <rostayob> Eduard_Munteanu: I don't think it's worth it. This works reasonably well
13:09:21 <copumpkin> @hoogle log1p
13:09:22 <lambdabot> No results found
13:09:24 <copumpkin> :O
13:09:28 <copumpkin> why not?
13:09:56 <Dina_> blackh: so why is it not in demand? O_o 
13:10:11 <crystal-cola> is haskell still the best language
13:10:15 <Eduard_Munteanu> No, I mean just around ConnPool. I assume mongoDB isn't expecting an existential there.
13:10:29 <MatrixFrog> hard to get an objective answer to that in a channel called #haskell
13:10:33 <Eduard_Munteanu> No, Agda :P
13:10:34 <copumpkin> Dina_: you really think what the masses want is a good indicator of what's good?
13:10:45 <Bfig> Dina_, if you want to learn more about programming learn some object oriented language :)
13:10:51 <rostayob> Dina_: because it's kind of different from the competition, and most people are used to other way of thinking, when programming
13:10:58 * Bfig takes cover
13:11:07 <Dina_> my dad is erlang programmer, he told me to study erlang.. is it really good?
13:11:13 <rostayob> Dina_: erlang is a mess
13:11:17 <Bfig> (i really mean it) (C++, java)
13:11:22 <rostayob> (:
13:11:22 <xplat> also because a lot of programming hiring decisions are made by nonprogrammers, or programmers who prefer managing to actual programming :)
13:11:29 <tomh-> why is erlang a mess
13:11:31 <blackh> Dina_: Because it does things differently, and people are naturally conservative.  I think we're just before a big shift, like the shift to Object Oriented programming that happened in the 1980s, but it's a few years to go.  Then either Haskell will be in demand, or the ideas in it.  The ideas in Haskell are already in demand, but not Haskell itself.
13:11:38 <rostayob> Eduard_Munteanu: I'm not sure I understand what you mean. you mean something like
13:12:02 <rostayob> data ConnPoolWrap = forall s. Service s => ConnPoolWrap (ConnPool s)?
13:12:02 <siracusa> boegel: let foo t = show (unsafeCoerce 0 `asTypeOf` t) ++ " : " ++ show (typeOf t) in foo (undefined :: Integer) :-P
13:12:03 <Dina_> rostayob: my dad is erlang veteran you should not be so bad with it :(
13:12:37 <Jafet> I thought erlang's a language, not a war
13:12:40 <Eduard_Munteanu> rostayob: yes. You may also wrap in functions working on that existential 's'.
13:12:41 <Bfig> blackh, it all depends in this: is haskell more productive than your run of the mill oo language? is it more productive than genexus or .net?
13:12:49 <blackh> Dina_: I don't agree with Bfig. If you want to really learn programming, learn both a functional language and an OO language. 
13:12:55 <hpc> Jafet: an easy mistake to make :P
13:12:59 <rostayob> Dina_: ahah! it's just that erlang kind of grew from the code, not from design decisions, and the libs codebase is actually a mess eheh
13:13:01 <blackh> If you don't learn a functional language, you will miss out on a lot.
13:13:11 <boegel> @hoogle asTypeOf
13:13:11 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:13:14 <Jafet> A war on Java Server Pages?
13:13:15 <monochrom> I think I saw the name Dina before, asking similar questions.
13:13:24 <blackh> Bfig: For me, Haskell is considerably more productive, but that's because I write very big, very complex programs.
13:13:31 <Bfig> blackh, i mean it as a start... obviously you can't ignore the functional paradigm but i found it quite obtuse
13:13:32 <xplat> erlang is a messy core language with a good runtime and good libraries
13:13:33 <boegel> siracusa: interesting
13:13:43 <rostayob> Eduard_Munteanu: what would be the advantage of having that,, apart from being able to use the record functions?
13:13:48 <boegel> > let foo t = show (unsafeCoerce 0 `asTypeOf` t) ++ " : " ++ show (typeOf t) in foo (undefined :: Integer)
13:13:48 <Bfig> blackh, most programs aren't complex... most are just... large.
13:13:49 <lambdabot>   Not in scope: `unsafeCoerce'
13:13:53 <blackh> Bfig: If I were writing 100-line programs, Haskell would have no advantage, but I'm writing 50,000 line programs.
13:13:54 <copumpkin> Bfig: it's a function of what you're used to
13:14:01 <copumpkin> if you start with functional, functional is clearer
13:14:04 <blackh> Bfig: Complex and large are the same thing.
13:14:06 <copumpkin> and things like x = x + 1 make no sense
13:14:10 <blackh> Or rather, large implies complex.
13:14:28 <Bfig> blackh, 5000 assembly lines are like 124789178 times more complex than 15k c lines
13:14:38 <Zao> nop; nop; nop; ...
13:14:40 <rostayob> xplat: well... my best friend works for rabbitMQ, and he tells me a different erlang absurdity every other day :P
13:14:53 <xplat> (yes, there are some messes in libraries too, but every language has that unfortunately)
13:15:12 <blackh> Bfig: I'm not sure what you're saying, but what I'm saying is this: Haskell has real advantages for real work.
13:15:33 <siracusa> boegel: Don't take this too seriously, it's likely to break with more complicated data types.
13:15:46 <rostayob> xplat: I just don't like using it, maybe it's the prolog syntax boh
13:16:15 <Bfig> blackh, when you are programming 50 interfaces that do slight variations of some simple stuff, how does haskell help there?
13:16:20 <boegel> siracusa: try with "undefined :: String"
13:16:23 <boegel> :)
13:16:29 <boegel> siracusa: but thx anyway
13:16:40 <xplat> Bfig: because you only have to write 10?
13:16:42 <Dina_> But still my dad made good income out of erlang.. and he says it served millions of people.. i am 17 and soon will need to master something to get into real life.. i use perl for simple scripts.. And started with c few months ago..
13:17:07 <Jafet> I think Bfig is about to be exploded
13:17:17 <Eduard_Munteanu> rostayob: well I don't think the typeclass constraint is a good way to go there if you want to abstract out the actual 's' type. You seem to be reusing tricks for making heterogenous collections for this.
13:17:21 <siracusa> boegel: Try it with Either Int Char ;-)
13:17:25 <Bfig> it was a serious question where i don't know the answer
13:17:34 <Bfig> i know only traditional paradigms
13:17:36 <Eduard_Munteanu> For actual abstracting one usually packs an existential along with functions that use it.
13:17:37 <rostayob> Dina_: haskell right now is not the best thing for making good income, except if you're really good at it I guess (which is *hard*). but it's really rewarding.
13:17:43 <boegel> siracusa: w00, Bus error, nice :)
13:17:43 <Bfig> (except for this brief crash course)
13:17:53 <xplat> Bfig: you have to rewrite the same simple stuff less in haskell because haskell is better for reuse
13:17:58 <rostayob> Dina_: and I'd bet that it's only going to grow in the future
13:18:20 <blackh> Bfig: For example, I wrote a wrapper for the Paypal API (soon to go on Hackage).  It has about 50 interfaces with slight variations, all very easy to get wrong.  I used type families and made it clean and type safe with the compiler stopping you using the wrong CGI variables, and this wouldn't have been possible in another language.
13:18:37 <rostayob> Eduard_Munteanu: well in that case I just want to have what the existential type tells you, = a ConnPool, whatever the Service is
13:18:42 <wenchuan> +i
13:18:49 <Dina_> rostayob: can I use haskell to write a chat app? or is it not practical?
13:19:03 <rostayob> Dina_: you can use haskell to do almost everything
13:19:04 <wenchuan> say
13:19:05 <blackh> Bfig: That is, Haskell allowed me to do it without repeating myself (well, not very much, anyway).
13:19:24 <Dina_> rostayob: wow! 
13:19:27 <blackh> Dina_: A chat app is something that Haskell would do considerably better than another language.
13:19:38 <rostayob> blackh: yes
13:19:41 <Dina_> blackh: compared to what?
13:19:42 <shachaf> blackh: It is?
13:20:09 <Jafet> Well, Haskell is already the preferred language for irc bots.
13:20:10 <osfameron> I imagine the end result would look like a chat app, just as it would in another language ;-)
13:20:14 <blackh> Dina_: ...because you can use STM to communicate between the threads at the right granularity.  That is, you can just forget about your threading issues and it's automatically scalablew.
13:20:28 <Bfig> blackh, i bet you could do the same with more or less the same amount of work in an oo language
13:20:32 <blackh> ... that is, assuming you don't want to make it distributed.
13:20:35 <rostayob> Dina_: actually, there is a chapter about coding an irc server in the erlang book, I remember it ehe
13:21:00 <Jafet> Bfig: how much do you bet?
13:21:17 <Bfig> blackh, i'm not saying haskell or the functional paradigm is useless, what i'm saying is it is just as powerful in abstraction *in most cases where you need to program something*
13:21:25 <rostayob> Bfig: I don't think so, except Erlang probably, which is predictably really good for servers
13:21:29 <boegel> Jafet: isn't Haskell the preferred language for everything?
13:21:29 <blackh> Bfig: Usually you can do things with less work than in an OO language.  I've come across cases where "normal" programming was clearer and/or shorter, but they tend to be fairly specific.
13:22:02 <Dina_> rostayob: Yes I read it. and it looked easy.. that is the task my dad gave me.. so i was thinking if i should do it in erlang or something else more usefull (if there is)
13:22:21 <Eduard_Munteanu> rostayob: but to be honest I'm not entirely sure why record syntax complains that much, it seems it doesn't work at all for this, not just when existentials escape.
13:22:27 <Bfig> blackh, maybe, i don't know enough about programming to say otherwise... but most of what i've seen doesn't change much. there are some cool things but you trade them for performance, as always
13:22:30 <Jafet> boegel: yes, but no one has successfully implemented everything.
13:22:45 <boegel> is there a way to figure out if a certain type has a corresponding type class instance, for a particular type class?
13:22:51 <blackh> Bfig: I think that you could only come to that conclusion if you haven't realized yet that functional programming is strictly more "powerful" than OO.  That is, you can write OO in a functional language, but not the other way around.
13:22:56 <rostayob> Dina_: yeah erlang is particularly good at those things, and it comes with a lot of bonuses if you have to code a server
13:22:57 <Eduard_Munteanu> But I've only been trying :t on it, maybe actually using those values works.
13:22:59 <boegel> e.g. find out if Int has an instance for Data.Bits.Bits ?
13:23:01 <Bfig> ie, programming sorting algorithms... you can do quicksort in one line, but it won't execute in one line of time or one line of space compared to a c variant
13:23:05 <xplat> Dina_: erlang is not a bad language to learn, but considering your existing languages (C and Perl) you will probably learn more from Haskell
13:23:17 <rostayob> Eduard_Munteanu: it works for me... but I have to pattern match
13:23:29 <rostayob> Eduard_Munteanu: like Foo { myField = var } to get out myField
13:23:34 <rostayob> i can't do myField foo
13:23:34 <Bfig> blackh, i already granted you that, my point is in most cases you don't even need the level of abstraction that functional allows
13:23:39 <Jafet> boegel, :info
13:23:49 <Jafet> (works both ways)
13:23:55 <blackh> Bfig: It is not true to say that you always trade performance for cool things.  Haskell is good at managing complexity.  You can solve performance problems in ways you wouldn't even attempt in other languages.
13:23:57 <xplat> Dina_: both languages, though, are less easy to find jobs for than mainstream languages like Java and for Erlang you might have some advantage from family contacts getting into places that use it
13:24:08 <Dina_> xplat: ok but what about jobs? will i get better chance with haskell under by belt? (instead of java for example, )....
13:24:20 <Bfig> blackh, how would you write a more efficient quicksort in haskell than in c with less lines of code?
13:24:26 <blackh> Bfig: It seems to me that you would only say "you don't need it..." if you don't understand why you do need it.
13:24:26 <rostayob> Dina_: no, you wouldn't
13:24:36 <rostayob> but you're 17
13:24:41 <Jafet> Programming as a job is terrible, on average
13:24:44 <Bfig> blackh, evidently, that's why i asked why you considered it important
13:24:45 <c_wraith> Bfig: why quicksort, which inherently depends on mutation?
13:24:52 <rostayob> if you plan to go to uni you've got loads of time ehe
13:24:55 <c_wraith> Bfig: isn't a better question *sort*?
13:24:55 <boegel> Jafet: I meant from within Haskell code
13:24:59 <xplat> Dina_: if you insist on learning just one more language erlang is a better idea.  if you're willing to learn two you should consider Haskell and Java
13:25:09 <blackh> Bfig: You can't write anything small in Haskell to be more efficient than C.
13:25:12 <Jafet> boegel: what on earth are you trying to write?
13:25:12 <xplat> or maybe Haskell and Ruby
13:25:22 <blackh> Bifg: The best you can get is the same performance, because C is very efficient.
13:25:25 <boegel> Jafet: :D
13:25:33 <Eduard_Munteanu> rostayob: does something like
13:25:36 <boegel> Jafet: trying to play with genetic programming in Haskell
13:25:37 <Eduard_Munteanu> data Pkg = Pkg { get :: forall a. a, show :: forall a. a -> String, make :: forall a. Int -> a }
13:25:40 <Eduard_Munteanu> suit you?
13:25:47 <Jafet> boegel: perhaps you want hint or src-exts.
13:25:57 <Bfig> c_wraith, sure, be my guest. quicksort is at the very edge of absolute efficiency
13:25:57 <Dina_> yeah i heard of ruby and heard it is in high demand :)
13:25:58 <blackh> Bfig: You can write quicksort using the ST monad, and it's like to be shorter, and slightly slower.
13:25:59 <Jafet> Or an embedded language.
13:26:16 <c_wraith> Bfig: it's been a while since you've looked at sorting algorithms, hasn't it?  check out things like timsort
13:26:23 <Jafet> Bfig: incorrect.
13:26:27 <Eduard_Munteanu> Erm use some other identifier than 'show' there
13:26:28 <blackh> Bfig: Well, it'd be, say 3-5 times slower, probably.
13:26:47 <wenchuan> q
13:26:52 <wenchuan> quit
13:27:04 <rostayob> Eduard_Munteanu: well when I tried with RankNTypes it actually had to infer the monomorphic type at some point when using it, but maybe I did something wrong. I don't entirely understand those things anyway, I should read something instead of just using them
13:27:09 <Dina_> emm.. what are mainstream languages? i did not get that? O_o
13:27:36 <Dina_> you mean c and c++?
13:27:53 <blackh> Dina_: When I say "mainstream languages" I mean things like Java, C++, Python, Perl, Ruby, C#, etc.
13:27:56 <rostayob> Dina_: java, python, C, C#, etc
13:28:14 <Dina_> why is not haskell or erlang one of them? :(
13:28:14 * Eduard_Munteanu tries it
13:28:17 <Bfig> c_wraith, you are right it's been a couple years, but i mean it in the computational complexity sense, that any sorting algorithm has at most a worst case O(n log n)
13:28:49 <Bfig> Jafet, what's incorrect?
13:29:00 <rostayob> Dina_: why do you worry anyway, I mean really if you start with the idea of choosing the thing that makes you more employable in a big company you're going to hate programming :P
13:29:25 <c_wraith> Bfig: unless you put a lot of work into it, quicksort's worst case is O(n^2). :)
13:29:33 <Jafet> Bfig: quicksort does not approach anywhere near the optima for comparisons or record moves, for example. I believe the current contenders are nearly all mergesort derivatives.
13:29:33 <Dina_> rostayob: i don't know i feel lost alread :'(
13:29:47 <ion> dine: Erlang shines in some things other languages tend to suck at. There’s a very promising development in Haskell land that implements some of that in Haskell: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
13:29:57 <ion> dina even.
13:30:09 <Bfig> c_wraith, well, you're right, pick mergesort.
13:30:25 <rostayob> Bfig: haskell lazy mergesort is great
13:30:31 <Jafet> Bfig: for non-random data sets, strand-based mergesort is also faster than quicksort; Data.List uses one.
13:30:39 <blackh> Dina_: Haskell and Erlang are not "mainstream languages" because they are not at the top-level of popularity.
13:30:57 <Bfig> capacity for paralelism? is that why?
13:31:37 <rostayob> Bfig: well no, because you sort just what you need. so take 20 (sort hugeList) is going to be faster then whatever C implementation :P
13:31:59 <rostayob> well that's an advantage that comes to my mind anyway.
13:32:12 <Bfig> only marginally, you only evade the very last pass of the algorithm
13:32:51 <rostayob> Bfig: mh actually that's true. I wasn't thinking of merge sort ehe
13:32:52 <Bfig> the whole tower is computed except the base last n-20 elements
13:33:07 <Jafet> No, selecting k elements from n with lazy mergesort is O(n log k).
13:33:24 <rostayob> Jafet: oh, I was right then, but I'm not sure why
13:33:26 <Jafet> Perhaps you should brush up on this stuff
13:33:27 <Dina_> blackh: that is the one thing i still do not understand.. why some languages shine (like java, python, ruby,etc..) while some stay in the shadow.. ! and then people come and say: ah no that does not indicate that our language is bad! languages to me look like real languages we speak, english is universal because it is great, while ukranian (my language) is not that famous and is not that expressive (like english)..
13:33:37 <rostayob> ah yes
13:33:37 <Bfig> how would the algorithm go?
13:33:51 <hpc> Jafet: wouldn't it be k log n?
13:34:18 <Bfig> you need to pick the biggest n-20 elements...
13:34:20 <Jafet> Of course, ghc's implementation will use O(n) space, when only O(k) is necessary
13:34:33 <rostayob> Bfig: http://www.mail-archive.com/haskell@haskell.org/msg19977.html
13:35:00 <Bfig> ok, i get it, but that's just not 'conventional' mergesort, ie, it's not take 20 $mergesort list
13:35:14 <boegel> Jafet: using Hint already
13:35:33 <rostayob> Bfig: no no, it is take 20 $ mergesort list
13:35:38 <blackh> Dina_: The reason is because all the other languages are similar to each other, whereas with Haskell, you have to learn to do things differently.  That means, it requires a paradigm shift.  Paradigm shifts start very slowly and then the whole of society shifts at once.
13:35:48 <rostayob> Eduard_Munteanu: anyway I have to go, let me know how the types work out :P
13:36:00 <Bfig> rostayob, what did i write?
13:36:01 * monochrom decides to write like "f $x $y $z" to mimick perl :)
13:36:03 <blackh> Dina_: I don't mean to say that everyone will start using Haskell....
13:36:14 <xplat> Dina_: i don't think anyone really understands why some languages are used more than others.  everyone has ideas of course :)
13:36:23 <rostayob> Bfig: you said that it wouldn't work like that, while that's how it is
13:36:37 <Bfig> i mean it is not like that that you will achieve the n log k efficiency
13:36:55 <blackh> Dina_: What I'm saying is that the ideas behind Haskell definitely are catching on, and all the mainstream languages resemble Haskell a whole lot more than they did.  There will come a time quite soon when Haskell doesn't seem so weird.
13:37:15 <ClaudiusMaximus> i think i'm spoilt by +RTS -N -RTS automatically using 1 thread per core - I thought 'make -j' would do the same, compiling ghc...
13:37:33 <monochrom> haha
13:37:43 <Jafet> hpc: no. Consider how you would insert them into a binary tree. The mergesort call tree does pretty much the same thing
13:37:44 <Dina_> blackh: how old is haskell by the way? is it like erlang? did it have great times in past like erlang?
13:37:45 <rostayob> Bfig: I remember thinking about this a while ago, and that's how haskell mergesort works, anyway I have to go
13:37:54 <blackh> Dina_: Haskell is 21 years old.
13:38:01 <c_wraith> Bfig: It's rare to be completely unable to match asymptotic efficiency in a lazy functional language.  There are a few cases where it's possible, though.
13:38:12 <dons> Dina_: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf 
13:38:32 <c_wraith> Haskell has never been more popular than it is now, though.  Thanks to a lot of work on high-performance libraries by a lot of people
13:38:46 <xplat> c_wraith: it's even rarer if you have ST.  meaning it never happens...
13:38:48 <Bfig> c_wraith, i don't understand what you just said... don't you mean it the other way round?
13:38:57 <Dina_> xplat: haskell is now in top of popularty?
13:39:13 <c_wraith> Bfig: "a few cases where it's not possible", I should have said.
13:39:24 <blackh> Dina_: Haskell's popularity is rising very fast, but it has a long way to go before it's anywhere near the mainstream.
13:39:39 <c_wraith> Bfig: in most cases, immutability doesn't hurt asymptotes, only constant factors.
13:39:46 <Bfig> ok... why would it be impossible to match asymptotic efficiency? can't you embed c-like code in this if you needed it?
13:39:48 <xplat> Dina_: i wasn't the one who said that, but c_wraith means that haskell is still growing in popularity, it has not peaked
13:40:19 <c_wraith> Bfig: really, it's immutability that causes it when it happens.  and you can escape into ST to get out of those, without leaving haskell.
13:40:31 <Dina_> mmm.. maybe something is wrong? maybe the developers are not looking at what the market needs... anyway i am too young to judge i think ^_^
13:40:35 * Bfig wikis immutability
13:40:59 <blackh> Dina_: Haskell itself may or may not become mainstream.  It's certainly capable of being so from a technical point of view.  But it may be that the ideas behind it go mainstream in other language.
13:41:10 <xplat> Dina_: a peak is bad though!  it means jobs are not growing and will probably shrink in the future.  so it is good that Haskell is still growing.
13:41:13 <c_wraith> Bfig: An easy-to-understand example is the shuffle algorithm.  Easy to do in O(n) time with mutable structures, no one's found any way to do it better than O(n log n) with immutable structures
13:41:39 <Bfig> c_wraith, see, this is what i really don't like about functional, because everything is by default immutable
13:41:52 <blackh> Dina_: No, everything is happening the "normal" way.  What we're seeing is the early stage of a classic paradigm shift.  Things will be very different in 5 years but I can't say exactly what will happen.
13:42:06 <roconnor> Bfig: we perfer the term persistent :D
13:42:10 <c_wraith> Bfig: immutable by default is the correct default.  mutability is the #1 source of bugs.
13:42:21 <Jafet> Dina: perhaps the developers in Haskell are aiming for an expressive language, not a popular one.
13:42:27 <Jafet> Have you ever considered that?
13:42:37 <Bfig> c_wraith, it's also the #1 source of doing anything meaningful?
13:42:44 <c_wraith> Bfig: hardly.
13:42:52 <Dina_> Jafet: languages become popular for being expressive :)
13:42:59 <Dina_> Jafet: i think :)
13:43:06 <Jafet> No, they don't. They become popular by becoming popular.
13:43:07 <c_wraith> Bfig: anything you can do with mutable cells can be done without.
13:43:15 <Bfig> functions per se are useless, unless you embed them in some mutable frame
13:43:21 <edenc> Dina_: no, languages become popular by lowering the bar on what knowledge you need to use it
13:43:38 <edenc> in fact, all tech-related products, for that matter
13:43:41 <osfameron> what library should I use to iterate filenames?  e.g. to do a DFS on a filesystem tree?
13:43:48 <Bfig> i mean mutable and frame in a loose way, because i don't know if that makes any functional-programming sense
13:43:54 <roconnor> it isn't immutability vs mutability, it is persistence vs ephermeral.
13:44:00 <Dina_> edenc: which is good to focus on your job?
13:44:04 <blackh> osfameron: I can recommend a package called 'List'.
13:44:12 <edenc> Dina_: huh?
13:44:39 <Bfig> roconnor, immutable objects are like rocks, you can use them to move levers but you only care about the lever moving (ie, the state of your system)
13:44:40 <blackh> osfameron: It's pretty low-level, though.  It's an abstraction that allows you to process it as if it were a lazy list, but without using laziness.
13:44:53 <Dina_> edenc: i mean, lowering the bar of knowledge required in language makes you more productive.. i think :)
13:44:54 <osfameron> where is it?
13:45:07 <edenc> Dina_: no it doesn't
13:45:18 <roconnor> Bfig: we don't treat IO as a moving state, we treat it as a static decision tree
13:45:55 <Jafet> Wait, we do?
13:46:02 * Jafet secretly revises code
13:46:03 <c_wraith> Bfig: I think you would ahve a better grasp of this if you went and wrote some haskell software, and paid attention to how often (approximately never) you actually need mutable state, unless you're synchronizing concurrent actions.
13:46:10 <Dina_> edenc: i learned, used, and forgot php in 1 month :) it was fun but not as cool as i wished.. :D
13:46:18 <roconnor> Jafet: I do
13:46:21 <roconnor> :)
13:46:32 <roconnor> Jafet: things might make more sense if you do too.
13:46:34 <edenc> Dina_: php sucks
13:46:36 <Dina_> edenc: but i liked how fast u can start using it..
13:46:45 <Bfig> c_wraith, i just wrote a huge horrible hideous unreadable parser (which would be equally unreadable and disgusting in any other language, don't get me wrong), and about 5 lines on two monads
13:46:59 <Dina_> edenc: in 1 day i wrote a nice website ^_^
13:47:16 * osfameron looks on hackage
13:47:22 <edenc> Dina_: I'm rather skeptic about what "nice website" means coming from a php dev, nothing personal
13:47:24 <Bfig> you hardly need a mutable state in any program, but it's the only thing you care about. you don't care how the program sorts lists, you care that it sorts them and give them back to you
13:47:40 <c_wraith> Bfig: why do you think that's a mutation operation?
13:47:43 <Bfig> i don't care how it parses commands, i only care that it parses them correctly in an interactive prompt
13:47:55 <edenc> Dina_: but yeah, you can buy a can of coke and get a "nice beverage" by popping it open
13:48:18 <edenc> or you can go pick oranges and make yourself a nice cup of healthy juice
13:48:46 <Dina_> edenc: Oranges! :) i love oranges :D nice choice ^_^
13:48:58 <beastaugh> "you don't care how the program sorts lists, you care that it sorts them and give them back to you" <-- this begs the question
13:48:58 <edenc> it's more about long-term
13:49:24 <Bfig> c_wraith, the fact that you don't make a distinction from regular imperative functions and haskell functions is just a bit of semantics. you can program lazy functions in c too, if that's what you want (although it will take considerable more work)
13:49:34 <beastaugh> you don't care how the program sorts lists, you care that it gives you back sorted lists containing the elements of the input lists
13:49:40 <Eduard_Munteanu> @tell rostayob Hrm, there seems to be no way around it except making yourself some helpers (that pattern-match), see 7.4.5.3. Record Constructors here: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/data-type-extensions.html
13:49:41 <lambdabot> Consider it noted.
13:49:58 <Dina_> edenc: life is short.. and in our time the learning curve is becoming crucial to select what language to use in production... (i ma quoting my dad ) :P
13:50:00 <edenc> Dina_: what php programmers forget is that there's more to the software lifecycle besides "getting a nice website up"
13:50:02 <c_wraith> Bfig: I suspect we're talking past each other.  You're not seeing the point I'm trying to make, and I'm not seeing the point you're trying to make.
13:50:23 <beastaugh> your anaphoric "them" presumes that the sorted lists must be the same objects as the input lists
13:50:40 <beastaugh> which begs the question about mutability
13:50:54 <Philippa> Bfig: you can /encode/ them in C, it's not the same thing
13:51:23 * copumpkin expects sophomoric point about turing soon
13:51:35 <Bfig> c_wraith, possibly. maybe we could get back to the root of the conversation, or just let it go. i'm just defending my vision of the matter, but not in a stubborn way, i leave the way for you to convince me haskell is as good as you think it is
13:51:56 <c_wraith> Bfig: yeah, I think I'm failing because I don't know what your real objection is :)
13:51:57 <Dina_> edenc: oh i also checked node.js and javascript.. i think the future boom is somewhere there.... O_o
13:52:08 * copumpkin slaps Dina_ 
13:52:14 <Jafet> To troll #haskell
13:52:28 <c_wraith> Dina_: node.js is kind of silly.  Why do all that stuff manually, when there are languages that automate it?
13:52:30 <Eduard_Munteanu> @tell rostayob In a way it makes sense because the escaped type doesn't look like it unifies across selector calls. IOW it can't tell it's the same (hidden) type.
13:52:30 <lambdabot> Consider it noted.
13:52:38 <monochrom> lift is too short for repeating what everyone else has been doing anyway. be different, use haskell.
13:52:42 <Philippa> Bfig: does it help if we tell you that partially-implicit, /pervasive/ mutability is the root of all evil?
13:52:46 <roconnor> "Why functional programming matters" sort of explains why lazy functional programming, ... but I admit I didn't get it until years of experience.
13:52:58 <Bfig> Philippa, that's more like it :p
13:53:08 <blackh> Dina_, edenc: You could say that Haskell reduces all your hidden costs, and so it's a bit difficult to sell someone something they don't think they need.
13:53:12 <Dina_> c_wraith: it is not that bad and looks promising :\
13:53:13 <Philippa> you can write semantically-immutable systems that support implementations with mutability in key places, not that that necessarily has anything to do with their semantically-observable IO behaviour for example
13:53:18 <hpc> monochrom: that's why you use liftIO :P
13:53:24 <Philippa> (we consider disk IO as a separate matter to mutability in general)
13:53:26 <edenc> blackh: yes, exactly
13:53:27 <copumpkin> Dina_: it's promising in the same way that windows 3.1 is promising, today
13:53:42 <copumpkin> it's a breath of fresh air for people who have used DOS all their lives
13:53:42 <c_wraith> Dina_: it's decent.  But its IO model is basically the same as GHC's IO model, except you have to do everything manually.
13:53:45 <dons> did anyone try the xcode 4-friendly HP installers yet?
13:53:45 <Bfig> i can agree with that, although program bugs will still be found, and well encapsulated imperative is just as good as functional
13:53:56 <roconnor> Bob says ``Simply put, imperative methods are useful, if at all, in the “corner case” of sequential execution of programs acting on ephemeral data structures
13:54:09 <edenc> blackh: developing php is a lot faster, until you need to paralellize the code and you can't because of the mutability and side-effects
13:54:11 <Philippa> "well encapsulated" meaning you can't tell it's imperative from the outside? Yeah, haskell supports that and some of us use it on occasion
13:54:21 <Philippa> (it supports it via a particular form of embedding though)
13:54:23 <Dina_> mmm... maybe...
13:54:40 <osfameron> edenc: the trick is that most of the time you don't need to parallelizze the code
13:54:45 <Dina_> we will see if people like it or not...
13:54:50 <Philippa> in the meantime, proving the absence of bugs is a lot harder in the presence of semantic mutability: the proofs're just plain bigger
13:54:50 <osfameron> edenc: making the effort of learning FP a premature optimization :D
13:54:52 * osfameron ducks
13:54:54 <copumpkin> Dina_: that is not a good metric of whether it's good, keep in mind
13:55:00 <Bfig> of course i leave it open for you to try and prove me wrong, but it will not be with examples... there's always a way to go against an example
13:55:00 <blackh> Bfig: Well-encapsulated imperative code is not as good as functional code overall, from the point of view of minimizing bugs.
13:55:07 <copumpkin> Dina_: my comparison to windows 3.1 wasn't by accident. It's cooperative multitasking all over again
13:55:07 <edenc> Dina_: you see, whether people like it or not doesn't matter
13:55:08 <Dina_> for me, i will learn some haskell for fun.. :)
13:55:22 <Philippa> blackh: well, so long as the encapsulation comes complete with a proof of correctness...
13:55:23 <roconnor> arguing against mutability is a lot like arguing against goto.
13:55:25 <edenc> osfameron: hah
13:55:34 <Philippa> roconnor: it's crap because you really want continuations?
13:55:39 <osfameron> aha!  cabal update *was* doing something.  It could really do with being a bit more verbose.
13:55:44 <monochrom> oleg swears by cooperative multitasking
13:55:58 <dcoutts_> osfameron: or just being quicker! :-)
13:56:01 <Dina_> i will do some benchmarking, erlang, haskell, and node.js.. and then will make my decision :)
13:56:04 <Bfig> blackh, agree with you in some way, still this is not nearly as strong a statement as 'functional is The New Paradigm'
13:56:05 <Philippa> oleg's not cooperating with arbitrary code though
13:56:10 <Bfig> brb
13:56:13 <Philippa> it isn't, it's the Oldest Paradigm
13:56:17 <osfameron> dcoutts_: heh, that too
13:56:25 <Philippa> it's also one half of the only one that ultimately scales
13:56:26 <roconnor> Philippa: there was strong opposition to structural programming.   That seems to have died down by now though.
13:56:43 <dons> Dina_: http://www.yesodweb.com/blog/preliminary-warp-cross-language-benchmarks 
13:56:46 * copumpkin argues for operatic programming
13:56:48 <Philippa> roconnor: sorry, knew what you meant - was just being snarky
13:56:54 <roconnor> :)
13:56:58 * Philippa prefers instrumental ;-)
13:56:59 <dons> if its about performance erlang and node aren't going to compete against compiled, multi-threaded haskell code
13:57:22 <copumpkin> what's nice is that the faster haskell code is also easier to write
13:57:32 <crystal-cola> are you saying it's possible to write efficen tprograms in haskell?
13:57:34 <osfameron> yay.  cabal refuses to install anything at all
13:57:40 <osfameron> I suspect I need to upgrade my haskell
13:57:42 <monochrom> \∩/
13:57:42 <blackh> Bfig: I do think that functional is the new paradigm, but the only proof I can offer is things like the fact that in the last few years every language except Java that didn't have them already has got closures.
13:57:51 <beastaugh> Dina_: you're writing one of those 0.1% of programs where performance really is the most important thing, not correctness or ease of development/maintenance?
13:58:05 <Philippa> crystal-cola: there are people in here who do that for a living
13:58:13 <Eduard_Munteanu> copumpkin: what's that?
13:58:14 <roconnor> the blogosphere tells me that closures in python make no sense.
13:58:16 <crystal-cola> why is darcs so slow then?
13:58:23 <copumpkin> Eduard_Munteanu: what's what?
13:58:28 <Eduard_Munteanu> "operatic" :)
13:58:29 <Philippa> roconnor: they don't, the syntax is fugly ;-)
13:58:38 <c_wraith> darcs is so clow because it uses a very complex model that's difficult to implement efficiently
13:58:41 <c_wraith> *slow
13:58:44 <Jafet> roconnor: that makes sense in python
13:58:47 <Philippa> Eduard_Munteanu: it means the program ain't over 'til the fat lady sings
13:58:49 <copumpkin> crystal-cola: it's not a language thing, it's an algorithmics thing
13:58:51 <Dina_> beastaugh: speed is a good indicator of how much the programming language is good.. that is what they teach us in school.. is that not correct?
13:58:53 <c_wraith> No programming language can make a slow algorithm fast :)
13:58:53 <Jafet> Nothing else makes sense there either.
13:58:54 <roconnor> crystal-cola: darcs is one of the few dvcs with reasonable semantics.
13:58:56 <monochrom> operatic programming is when you sing, like in operas
13:58:57 <Eduard_Munteanu> Heh.
13:58:57 <copumpkin> Eduard_Munteanu: what Philippa said
13:59:01 * copumpkin listens to norma
13:59:02 <roconnor> crystal-cola: doing things right is hard.
13:59:05 <blackh> roconnor: Everything from a different paradigm doesn't make sense.  That's the way paradigms work.
13:59:24 <pmurias> what does that GADT pattern match with non-rigid result type `a' mean?
13:59:28 <roconnor> blackh: like closures not closing over the contents of the environment?
13:59:29 <Dina_> c_wraith: of course.. I will make a fair comparison :)
13:59:38 * pmurias starts to really dislike GADTs
13:59:41 <Dina_> and post on my coming soon blog B-)
13:59:44 <Philippa> crystal-cola: sometimes people write things in haskell that they wouldn't dare write in another language. Often they're amongst the most famous haskell programs, so people compare them to superficially similar ones
13:59:48 <copumpkin> pmurias: I love them!
13:59:49 <blackh> roconnor: Oh right. That definitely doesn't make sense. :)
13:59:53 <copumpkin> pmurias: struggling with hoopl?
13:59:55 <Philippa> pmurias: it means you need an annotation around the match
13:59:57 <Jafet> roconnor: it closes over their names, no?
14:00:07 <monochrom> people say Verdi's Requiem is operatic. indeed, it ain't over until the soprano has the final word
14:00:11 <roconnor> Jafet: maybe.  I don't know python. :D
14:00:15 <copumpkin> monochrom: I love it, mmm
14:00:27 <Jafet> roconnor: python's alignment is imperative stupid, as you may know
14:00:28 <crystal-cola> interesting
14:00:37 <roconnor> Jafet: *lol*
14:00:54 <pmurias> Philippa: (case ...) :: Type?
14:01:18 <Philippa> pmurias: case ... :: type of ...
14:01:24 <c_wraith> Jafet: where's the reference for this alignment system? :)
14:01:27 <roconnor> crystal-cola: see http://tahoe-lafs.org/~zooko/badmerge/simple.html
14:01:44 <Jafet> Why, should I make one?
14:01:51 <c_wraith> yes
14:02:01 <Dina_> Where can I see comparisons between haskell and other languages ? are there such sites?
14:02:17 <c_wraith> Dina_: few that are actually useful and educational :)
14:02:28 <pmurias> copumpkin: the Insn e x distinction seems very annoying
14:02:29 <c_wraith> Dina_: possibly none that are both.
14:02:31 <Cale> Yeah, I'm happy that badmerge page is back, for a while I needed to use the wayback machine to access it.
14:02:37 <copumpkin> pmurias: I quite like it
14:02:43 <Philippa> yeah, everyone's biased whether consciously or unconsciously, hardly anybody's any good at telling you adequately what their bias is
14:02:54 <copumpkin> pmurias: but yeah, if you don't have much experience with GADTs it's probably annoying
14:03:00 <Cale> It's an excellent example of why most VCSes suck and darcs isn't one of them. :)
14:03:41 <Dina_> c_wraith: maybe if community put on the website comparisons and why they should use haskell it will become in demand :D
14:03:49 <pmurias> copumpkin: but i managed to get the constant folding working for my AST
14:04:18 <copumpkin> pmurias: cool
14:04:25 <roconnor> Dijkstra said that those who give up correctness to obtain speed deserve neither.
14:04:25 <copumpkin> pmurias: what are you using it for?
14:04:47 * Bfig is back and googling closures
14:04:49 <copumpkin> what if I give up correctness and speed out of laziness?
14:04:50 <blackh> Dina_: I'm of the opinion that you can't really tell someone something they're not ready to hear.  Better if people come to Haskell (and other functional languages) out of frustration with the alternatives, and when they do, the information is available.
14:04:56 <c_wraith> Dina_: it's very hard to communicate such a thing.  Before I really started using haskell, I was aware of some of its features, but that's not really anything like knowing what it's like to use the language
14:05:43 * Philippa came to Haskell partly having blown the comfortable abstraction roof off C++
14:05:48 <Bfig> that's pretty awesome
14:05:51 <pmurias> copumpkin: optimising Perl 6
14:05:53 <Bfig> never heard of that before
14:05:56 <Philippa> (admittedly depending on your tolerances that's not very hard at all)
14:05:57 <copumpkin> pmurias: ooh
14:06:35 <crystal-cola> would like a new language to learn but after haskell everything seems the same
14:06:37 <Bfig> if i knew how to implement a closure in my parser it would've been like 10000 times easier
14:06:50 <Cale> crystal-cola: Maybe Agda?
14:06:51 <c_wraith> crystal-cola: try agda?
14:06:55 * ddarius would prefer people come here out of a love of learning rather than frustration.
14:06:56 <c_wraith> heh.  I lost that race :)
14:06:58 <Cale> lol, stereo
14:07:12 <Bfig> in fact i had the code ready for use like five days ago when i didn't find anything like that construct and had to rebuild everything to a three-stage parser
14:07:12 <pmurias> copumpkin: i'm writing an optimiser for https://github.com/sorear/niecza, but it's in a very early stage yet
14:07:21 <blackh> ddarius: You need the divide carrot and the divine stick. :)
14:07:24 <Bfig> how do i use closures?
14:07:32 <blackh> s/divide/divine/
14:07:35 <Philippa> ddarius: agreed, but on some level frustration has a habit of pushing it up people's to-learn list
14:08:06 <roconnor> @hoogle unless
14:08:06 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
14:08:18 <RichardO> is there a function in Prelude like this? f 5 = [0,1,2,3,4]
14:08:29 <Bfig> RichardO, enumFromTo
14:08:29 <Cale> RichardO: enumFromTo 0
14:08:34 <Cale> er, hmm
14:08:50 <Cale> That's off by one :)
14:08:54 <RichardO> thanks!
14:08:55 <Cale> > enumFromTo 0 5
14:08:56 <lambdabot>   [0,1,2,3,4,5]
14:09:02 <hpc> or \x -> [0..(n-1)]
14:09:02 <roconnor> so wrong
14:09:05 <pmurias> i have case (insn :: Insn e x) of ... and i still get the error
14:09:07 <hpc> er
14:09:14 <hpc> change one of those to make sense
14:09:14 <ion> > enumFromTo 0 . pred $ 5
14:09:16 <lambdabot>   [0,1,2,3,4]
14:09:32 <roconnor> > take 5 [0..]
14:09:33 <lambdabot>   [0,1,2,3,4]
14:09:42 <roconnor> > flip take [0..] $ 5
14:09:44 <lambdabot>   [0,1,2,3,4]
14:10:03 <c_wraith> roconnor wins the unnecessary use of $ award!
14:10:06 <copumpkin> pmurias: can I see the surrounding code and the actual error?
14:10:28 <roconnor> c_wraith: do I get a $
14:10:33 <ion> c_wraith: Not unnecessary, more like as an explicit “your function ends here” marker. :-P
14:10:43 <c_wraith> roconnor: as many as you can type
14:11:20 <pmurias> http://paste.scsys.co.uk/97540
14:11:27 <pmurias> http://paste.scsys.co.uk/97541
14:11:32 <pmurias> copumpkin: is that enough?
14:11:34 <dobblego> recently Oleg (I think it was Oleg) wrote how Functor f => Monad f is wrong, but I cannot find the link since my recollection is so fuzzy (I was on very heavy drugs) -- can anyone help?
14:11:42 <roconnor> now that I have my elliptic curve computations working I should see about implementing DSA
14:11:52 <c_wraith> dobblego: that was Oleg, on -cafe
14:11:54 <pmurias> copumpkin: are you using hoopl?
14:12:06 <copumpkin> pmurias: I played with it a bit a while back, but haven't had time recently to do much with it
14:12:21 <copumpkin> pmurias: make a helper where function for matching on the insn
14:12:32 <copumpkin> pmurias: or just match on it on the outside of insnTaret
14:12:45 <copumpkin> pmurias: or use scoped type variables
14:12:54 <copumpkin> Insn e x in your annotation isn't the same e and x as the outer on
14:12:54 <copumpkin> e
14:13:20 <Cale> dobblego: Do you remember anything about his reasoning?
14:13:27 <copumpkin> but it's easiest to just match on the outside
14:13:36 <Cale> dobblego: I suppose it's "wrong" in that it ought to be Applicative f => Monad f
14:13:39 <dobblego> Cale: not really, very vague sorry
14:13:50 <Cale> and then Functor f => Applicative f
14:13:51 <dobblego> Cale: no, he argued against the whole idea, not just that bit
14:13:55 <Cale> or something along those lines
14:13:56 <Dina_> c_wraith: found this on google.. not sure how accuarate, reading it now.. http://lambda-the-ultimate.org/node/1247
14:14:03 <dobblego> also, I think edwardk would disagree with you there (so do I)
14:14:41 <dobblego> I'm struggling to pull up the thread
14:14:59 <copumpkin> Dina_: that's not really a good comparison
14:15:14 <Bfig> getting an error on the long line: http://hpaste.org/45733/error . any ideas what it could be?
14:15:21 <Cale> Oh god, not that thing again :)
14:15:40 <Dina_> copumpkin: why?
14:15:52 <Philippa> dobblego: I'm of the "situation inherently screwed, but lining up instances across the hierarchy and using newtypes to pick which hierarchy you mean is probably best" school, FWIW
14:16:01 <copumpkin> Dina_: his off-hand stereotyping of haskellers doesn't make it sound like he tried it with a very open mind
14:16:04 <copumpkin> nobody does
14:16:15 <copumpkin> but some are more open than others
14:16:33 <Philippa> Bfig: missing ) on line 2
14:16:33 <Bfig> Cale, are you talking about my line? :p. this is a short line overall :p, i mean the long line in the paste (which consists of 2 lines)
14:16:49 <Dina_> copumpkin: he says: Haskell makes simple things difficult ! :S
14:16:53 <c_wraith> Dina_: Erlang is a language that is worthy of some attention, too.  It has a ton of great ideas and libraries....  And some of the worst syntax ever. :)
14:16:55 <Cale> The "not that thing again" was about the guy writing the poker bot
14:17:01 <Bfig> i don't see where
14:17:02 <Cale> In Haskell and Erlang.
14:17:05 * roconnor tries to remember how to compute square roots mod p
14:17:07 <copumpkin> Dina_: sure, but statements like that don't actually mean much
14:17:18 <copumpkin> Dina_: he also says things like "Haskell is a specialist language for doing extremely complex things that few outside of the tight-knit Haskell PhD. community will understand or (heresy!) even care about."
14:17:27 <copumpkin> Dina_: which doesn't exactly bode well for his objectivity
14:17:35 <Cale> He spent a long time in here not following people's general advice and trying adamantly to write his program in a horribly awkward way.
14:17:44 <copumpkin> Dina_: it's stereotyping
14:17:51 <efie> hello everybody, can anyone glimps at my problem? http://codepad.org/LNAeXbl0 when i run "incEntry [1] 1" it says "pattern match failure: incEntry [] (1 - 1)" why does 1-1 not evaluate to 0?
14:17:51 <c_wraith> Hmm.  That must predate the time I joined this channel.
14:18:08 <Cale> Yeah, it's old
14:18:16 <Bfig> Philippa, they close everywhere, there are only three pairs of (...)
14:18:25 <Bfig> i mean five...
14:18:27 <Dina_> copumpkin: mmm.. agree.. it is not that good comparison afterall..
14:18:27 <copumpkin> efie: (x:xs)/=[] is always true
14:18:31 <c_wraith> But I recognize commenter names on that node.  Like Philippa
14:18:38 <copumpkin> efie: (x:xs)==[] is always false
14:18:38 <Philippa> Bfig: the one marked 2 in the paste. It doesn't close at the end
14:18:45 <ezyang> the pattern match failure is for the left variable, not the right. 
14:18:57 <efie> copmupkin um ok
14:19:08 <copumpkin> just saying, as a general comment
14:19:08 <Cale> efie: It's a good general rule never to use == to determine if a list is empty or not
14:19:22 <efie> ok thx :)
14:19:25 <Cale> efie: You can always pattern match
14:19:31 <Bfig> Philippa, ohh ok... thanks! i was looking at the line hugs told me (one below that :p)
14:19:32 <Cale> or use null
14:19:36 <Cale> > null []
14:19:37 <lambdabot>   True
14:19:39 <Cale> :t null
14:19:40 <lambdabot> forall a. [a] -> Bool
14:19:43 <Cale> :t (== [])
14:19:44 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:19:55 <Philippa> Bfig: yeah, that's because it continues parsing on the assumption it's still in the same expression
14:20:03 <Cale> ^^ using (==) requires that the elements of the list be comparable for equality
14:20:11 <Philippa> eventually it runs into the layout rule - ghci tells you it's a possible paren closing issue too, IIRC
14:20:31 <Bfig> good to know :)
14:20:33 <Philippa> 9 times out of 10, a layout issue involves bracketing
14:20:57 <Philippa> (it won't add a ; if there're parens in the way on the layout stack, basically)
14:21:08 <c_wraith> unless it's a pure beginner, in which case half the time it's using tabs
14:21:25 <Cale> Yeah, tabs are eeeeevil.
14:21:28 <Philippa> oh, similarly a ; that you didn't add yourself happened because of layout
14:21:38 <Cale> efie: btw, there are tabs in your code ;)
14:21:40 <Philippa> which means it happened /at the start of a line/
14:21:48 <efie> ok, i fix it :)
14:21:57 <Philippa> if you want to know where ; does/doesn't go, read the syntax section of the Haskell Report
14:21:58 <Cale> efie: you want to configure your editor to replace them with spaces automatically
14:22:00 <Philippa> it helps :-)
14:22:10 <Cale> (almost all text editors have such a feature)
14:22:22 <efie> sounds good :)
14:22:24 <Philippa> (I basically never screwed up layout again after I'd read the formal definition: all apparent layout screwups were bracketing)
14:22:57 <crystal-cola> Philippa: very few people have the skill of learning formal grammars like that
14:23:23 <Philippa> crystal-cola: you don't have to learn the entire grammar
14:23:28 <Philippa> you only have to notice where ; appears in it
14:23:44 <Philippa> (similarly, { and })
14:23:51 <Philippa> that's a much, much simpler thing to do
14:24:12 <Philippa> also, being able to read BNF is approximately the same skill as being able to read recursive, pattern-matching haskell functions
14:24:22 <pmurias> http://paste.scsys.co.uk/97542
14:24:27 <pmurias> what does NB: mean?
14:24:33 <Philippa> "note"
14:24:35 <Philippa> only in latin
14:24:55 <Heffalump> "note well" actually :-)
14:24:57 <Philippa> possibly "note for your benefit:" or similar
14:25:12 <Philippa> well yeah
14:25:15 <Heffalump> ("nota bene")
14:26:51 <efie> Cale: um if you try somehting like this "incEntry [] i<0 = []" as patern matching before using the guards it doesnt work because of the boolean term.. :/
14:26:59 <efie> i*
14:29:10 <Cale> Yeah, that's a syntax error
14:29:30 <Cale> incEntry [] i | i < 0 = ...
14:30:10 <efie> oh wow that works? cool
14:30:16 <Cale> (x:xs) is an explicitly nonempty list, whose first element is x and where the rest of the list is xs
14:30:39 <Cale> So you can separate the empty and nonempty cases like that.
14:30:47 <efie> ok =)
14:33:44 <monochrom> tab is not evil. editors are evil in modifying tab semantics
14:33:54 <ion> indeed
14:34:09 <pmurias> why is Fact a type family in hoopl?
14:34:21 <ion> Although there’s one modification to tab semantics i would like to see. Let’s see if i manage to find the link.
14:34:23 <monochrom> "display tab as though tab stops are 3.4 characters apart" that's the evil customization
14:34:47 <monochrom> editors should not let you customize anything
14:35:14 <roconnor> why do you like better: (if p x then Just x else Nothing), or (guard p x >> return x) ?
14:35:37 <weeble_> the first. English-y code is pretty
14:35:51 <monochrom> the second. English-y code is pretty
14:36:01 <weeble_> (newb here)
14:36:38 <Philippa> roconnor: neither, there should be a standard function for it
14:36:38 <roconnor> monochrom: >> isn't exactly english ... but I'll allow your comment :D
14:36:50 <roconnor> Philippa: is there one?
14:36:57 <shachaf> > let (p,x) = (even,4) in listToMaybe [x | p x]
14:36:58 <monochrom> switch to do-notation and it's English-y
14:36:58 <lambdabot>   Just 4
14:37:07 <shachaf> > let (p,x) = (odd,4) in listToMaybe [x | p x]
14:37:07 <lambdabot>   Nothing
14:37:09 <Alan> If i have a [State s a], how would I apply all of them in order?
14:37:17 <Alan> I get the feeling it should be something fold-like with >>
14:37:21 <roconnor> if we had monad comprehensions ...
14:37:21 <Alan> but i'm not sure exactly what
14:37:31 <Philippa> dunno. I like the do notation version
14:37:33 <byorgey> Alan: sequence_
14:37:33 <weeble_> do $ and . make parentheses unnecessary for all expressions that include only prefix-style applications?
14:37:37 <Philippa> (except for the part where monads are a PITA when you need to annotate which one for clarity)
14:37:58 <Alan> byorgey: d'oh, so simple! thanks
14:38:05 <roconnor> weeble_: I don't think so.
14:38:39 <weeble_> roconnor: can you come up with an example that requires parens? (keep in mind: no infix allowed)
14:39:01 <Philippa> throw lambdas and lets and cases around
14:39:09 <Philippa> especially lambdas
14:39:43 <ion> Ah, found it: http://nickgravgaard.com/elastictabstops/
14:40:31 <roconnor> weeble_: map (f . g) x
14:40:52 <byorgey> roconnor: cheater!
14:41:00 <Philippa> roconnor: (\x.x) 1
14:41:10 <monochrom> f (f (g x) h) h
14:41:14 <roconnor> Philippa: id 1
14:41:18 <Philippa> er, (\x -> x) 1
14:41:29 <byorgey> \x -> x $ 1
14:41:35 <roconnor> :D
14:41:35 <byorgey> ah, right, that
14:41:36 <Philippa> yeah, but that's cheating: you're using a pre-existing binding. I can replace with an arbitrary function not in the libs
14:41:39 <byorgey> that's not the same
14:41:57 <ion> {-# LANGUAGE ElasticTabStops #-}, anyone? :-P
14:42:29 <weeble_> ion: it's cool!
14:43:12 <Bfig> i need to infect my pc with a linux distro, which one do you recommend?
14:43:24 <hpc> arch
14:43:28 <roconnor> do you think GHC's -O2 will optimise the expression quotRem (p+1) 4 if p is a constant?
14:43:41 <ion> I’ve been happy with Ubuntu, but YMMV.
14:43:57 <monochrom> I agree with elastic tab stops. in fact that's what latex and many latex packages provide. and also word processors.
14:44:15 <siplux> arch has pretty good support for haskell
14:44:15 <Alan> Gah, i hate it when i get "couldn't match expected type ... against inferred type ..." stuff
14:44:21 <weeble_> map (f . g) x    =  map $ f . g $ x   right?
14:44:24 <Alan> especially when i can't see why the hell it shouldn't work...
14:44:37 <monochrom> the way programmers reject almost every word processor feature is baffling
14:44:40 <roconnor> weeble_: we wish
14:44:44 <Bfig> i'm downloading backtrack 4 r2, possibly to triple boot :p
14:45:03 <roconnor> weeble_: but $ has the wrong associativity
14:45:24 <Bfig> but i was thinking something a bit more mainstream and friendly could be used as general purpose
14:45:39 <ion> > h (f . g) x
14:45:40 <lambdabot>   No instance for (GHC.Show.Show (f b))
14:45:40 <lambdabot>    arising from a use of `SimpleRefle...
14:45:53 <weeble_> ``map `f g x   (sometiems I wish I could use unlambda-style application)
14:45:53 <Bfig> i'll guess i'm checking arch, i've already tried ubuntu
14:46:09 <ion> > (h :: (Expr -> Expr) -> Expr -> Expr) (f . g) x
14:46:10 <lambdabot>   Overlapping instances for GHC.Show.Show
14:46:10 <lambdabot>                              (Simpl...
14:46:16 <ion> Meh. Forget it. :-P
14:48:35 <Bfig> will arch work with my APU processor?
14:49:16 <Alan> Could somebody suggest what i might be doing wrong here? http://hpaste.org/45734/type_error
14:49:43 <ezyang> args is not a function. 
14:49:59 <ezyang> map insertVar $ args fi == map insertVar (args fi) 
14:50:10 <Alan> ezyang: same error both ways
14:50:25 <Alan> and yes, i know that
14:50:32 <weeble_> so in practice do . and $ get used a whole lot? are parentheses rare outside of infix math expressions? Are there different camps as to what is better style?
14:50:40 <monochrom> ezyang is saying that both are wrong
14:50:41 <Alan> args is a function of FuncInfo -> [Var]
14:50:47 <shachaf> ezyang: map insertVar (args fi == map insertVar (args fi))
14:50:52 <copumpkin> weeble_: yes, all the time
14:50:54 <monochrom> oh oops
14:50:55 <Alan> isn't that how the record syntax works?
14:51:21 <ezyang> You've been shadowed by the local argument. 
14:51:30 <Alan> oh CRAP :(
14:51:47 <monochrom> oh haha
14:51:48 <Alan> thanks ezyang 
14:51:54 * ezyang thinks the type error doesn't lie 
14:51:56 <Alan> which also means i didn't even need that info in FuncInfo
14:52:09 <Bfig> gotta leave. thanks for the good advice and discussions. see you around.
14:52:10 <Alan> ezyang: you're right, but it's a bit awkward to figure out the why :(
14:52:52 <monochrom> what you need is meaningless identifiers. so you read the code for real rather than read your own thought
14:53:59 <ezyang> Now, with record puns, the story would be slightly different... 
14:54:08 <ezyang> but record puns are kind of evil :-) 
14:54:37 <hpc> record puns aren't so bad
14:54:52 <weeble_> so would you say that any language in which all functions are curried would do well to follow something like Haskell's syntax?
14:55:02 <hpc> they shadow names all the time, but it is at least really obvious
14:56:25 <monochrom> weeble_: once upon a time, people discovered curried functions but not yet the natural "f x" syntax, and so they wrote:
14:56:27 <Philippa> weeble_: it depends, there are a few other factors that can conflict a bit
14:56:41 <Philippa> you want the syntactic style for application, yes
14:56:51 <monochrom> f(x)(y)(g(t)(u))
14:56:52 <Philippa> Haskell's syntax goes a long way beyond that though
14:57:30 <c_wraith> monochrom: were those people C++ programmers?
14:58:29 <monochrom> worse than c++ programmers. they were...
14:58:33 <monochrom> MATHEMATICIANS
14:58:36 <weeble_> monochrom: ```f x y ``g t u  works too though
14:58:36 <Philippa> heh. Neither C++ nor Stroupstrup had been born at the time :-)
14:58:42 <Philippa> -p
14:58:54 <monochrom> in fact landin was just as guilty
14:59:13 <weeble_> it just seems to me that there are ways to do it that avoid any need for parentheses whatsoever
14:59:31 <Philippa> there are, yes. But parens are actually a good idea
14:59:39 <MatrixFrog> that needed a dramatic chipmunk so much
14:59:42 <c_wraith> Is there any school of C++ programming that says everything should be "functors" that take a single argument and return another functor if they need more arguments?
14:59:51 <weeble_> they are certainly readable, but i wonder how much of that is just us being used to them...
15:00:15 <Philippa> they also guarantee that inserting a new expression somewhere is a strictly local operation
15:00:21 <monochrom> a parse tree needs no parentheses. it is also more visual.
15:00:38 <Philippa> monochrom: it's also a PITA to read when dense, but hey
15:01:11 <monochrom> click on the [-] button to hide a subexpression you are not reading
15:01:22 <byorgey> weeble_: you can easily do it with no parentheses, just make up a prefix or postfix application operator =)
15:01:37 <Philippa> not good enough. Look at all those nested application nodes!
15:01:49 <weeble_> byorgey: that's what I did above...
15:02:02 <ddarius> monochrom: You can't bash syntax invented by Euler.
15:02:04 <Philippa> (a well-written hybrid could work pretty well, granted)
15:02:05 <byorgey> ah, I hadn't seen that =)
15:02:20 <weeble_> Philippa: the nested oens aren't a problem. They represent genuine subexpressions. It's the leading ones that are ugly, I think.
15:02:36 <Philippa> "leading"?
15:02:43 <weeble_> the ``` at the start
15:02:58 <Philippa> ah, right. The non-locality is a big problem there
15:03:10 * roconnor sighs
15:03:12 <weeble_> though it gets accross "this is sort of taking 3 args"
15:03:28 <ddarius> weeble_: Program in Joy.
15:03:35 <Philippa> roconnor: the bikeshed's got a rainbow on it. Next? :-)
15:03:51 <weeble_> ddarius: Joy is neat!
15:04:14 <roconnor> wikipedia claims that there is no deterministic algorithm for finding a quadratic residue mod p when p is congruent to 1 mod 4
15:04:21 <roconnor> but that is obviously false
15:04:37 <byorgey> roconnor: haha
15:04:52 <roconnor> but I'm stumpt as how to correct this sentned
15:04:56 <roconnor> *sentence
15:05:15 <roconnor> see http://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus
15:05:17 <roconnor> second paragraph
15:05:34 <roconnor> maybe I can revert some edit
15:07:52 <roconnor> it's been like this for over 2 years
15:08:16 <copumpkin> roconnor: that means that's how it should be
15:08:18 <byorgey> hahaha, that's terrible
15:08:20 <copumpkin> leave it alone
15:08:30 <roconnor> it is true now
15:13:09 <ddarius> roconnor: You have to learn to trust the cloud.  Put your faith in the cloud.  Your heart and soul.
15:13:30 <copumpkin> dolio, ddarius: up for food tonight?
15:14:43 <dolio> Sure.
15:16:14 <ddarius> copumpkin: Mo and I are supposed to have dinner tonight, but we can likely merge those plans into one.  I will be burdened with gifts.
15:16:22 <copumpkin> ooh
15:16:54 <copumpkin> what if Mo says "ugh, not him!" and refuses
15:16:57 <copumpkin> :(
15:17:14 <ddarius> copumpkin: Then I'll say it's the other Dan.
15:17:19 <copumpkin> oh okay :P
15:17:35 <copumpkin> is tonight the ukulele night?
15:17:42 <copumpkin> or are these other gifts?
15:17:43 <ddarius> Apparently.
15:17:43 <mzero> hah - I read that as "what if Mo says "ugh, not html" and refuses    !
15:17:57 <ddarius> copumpkin: Well gifts is plural and ukulele is singular.
15:18:05 <copumpkin> ukuleles!
15:18:25 <copumpkin> two hands, two ukuleles, obviously
15:19:59 <dolio> Like this: http://www.youtube.com/watch?v=rutyA12z3Ok
15:21:39 <copumpkin> that's weak, he's only playing one of them at a time
15:21:50 <copumpkin> oh wait
15:21:52 <copumpkin> he's playing both later on
15:22:29 <copumpkin> wow, http://www.youtube.com/watch?v=P-XfnkLdkjo
15:22:33 <copumpkin> just add more guitars
15:23:05 <dolio> Did you watch the whole thing? He doesn't just play both guitars, as I recall.
15:23:11 <dolio> He plays both, upside down.
15:23:17 <copumpkin> oh man
15:23:21 <copumpkin> I shouldn't have skipped around
15:24:24 <dolio> Around 4:30
15:24:30 <copumpkin> yeah, found it
15:25:13 <dolio> It's probably not a very exciting piece there, though.
15:25:48 <dolio> Not that I know anything about guitars.
15:26:07 <djahandarie> Seems like when he plays both at once he can only do thirds lol
15:26:31 <djahandarie> Oops, spoke too soon
15:30:42 <dons> http://twitter.com/donsbot/status/59023718508273664 <-- HP 2011.2.0.1 is out
15:30:49 <djahandarie> Wheee
15:31:25 <dons> get yr ghc 7.0.3
15:32:12 <aristid> dons: "Revision of the Haskell Platform is now available."
15:32:21 <dons> yes
15:32:22 <aristid> dons: you forgot to actually add the revision number there?
15:32:29 <dons> A revision
15:32:30 <dons> sorry.
15:33:22 <copumpkin> djahandarie: on the sized vector things you were doing a while back
15:33:39 <copumpkin> djahandarie: did you ever try implementing monad? you get a diagonal thingy like what acowley was saying
15:33:53 <djahandarie> What does that have to do with infinite streams?
15:34:11 <copumpkin> same diagonal-ness
15:34:36 <copumpkin> if you have a fixed length (including an infinite one), you can do the diagonal shit
15:34:46 <dons> tell yr friends  http://news.ycombinator.com/item?id=2452516 
15:34:48 <djahandarie> Okay cool, I'll mess with that
15:35:06 <aristid> dons: beware the voting ring detector
15:35:19 <djahandarie> Haha, do they actually have one of those?
15:35:25 <mzero> gosh dons - are you in marketing?  what an assault on the internet!
15:35:28 <mzero> :-)
15:35:43 <dons> you will be aware of the haskell platform! it is done.
15:36:07 <copumpkin> djahandarie: also, with my categories (unlike other categories)
15:36:20 <copumpkin> you can actually show that the stream monad is a monad (I think! I haven't actually tried)
15:36:31 <copumpkin> since equality on a stream isn't the usual agda equality
15:36:33 <byorgey> copumpkin, djahandarie: you get a diagonal monad instance for any representable functor, i.e. functors isomorphic to  R -> a  for some type R
15:36:36 <djahandarie> I'd try doing that too if I had a working copy of Agda :p
15:36:47 <byorgey> R = Nat  gives stream,  R = Fin k  gives length-k lists
15:36:49 <copumpkin> byorgey: ah, makes sense
15:36:51 <copumpkin> yeah
15:36:55 <djahandarie> Nice
15:36:59 <byorgey> it's just the Reader monad instance.
15:37:02 <copumpkin> yep
15:37:25 <copumpkin> Vec Bool k!
15:37:31 <copumpkin> BoundedVec Bool k
15:37:48 <ddarius> http://www.tac.mta.ca/tac/reprints/articles/15/tr15abs.html
15:37:54 <copumpkin> Vec (Fin n) k
15:38:05 <byorgey> hmm... full binary trees of depth at most k?
15:38:33 <djahandarie> ddarius, oh hey, that's on that site you linked the other day
15:38:34 <copumpkin> byorgey: yeah, just throwing random indices out there :P
15:38:40 <byorgey> hehe, yeah =)
15:38:51 <copumpkin> trees o' trees
15:39:14 <djahandarie> "We need to go deeper" or something
15:39:39 <copumpkin> well to prove the monad laws you'll need trees o' trees o' trees
15:40:03 <copumpkin> a level deeper and we have inception
15:40:20 <djahandarie> Didn't you already do this with universes? :p
15:40:39 <djahandarie> Except you had inception times like 5
15:40:49 <copumpkin> you don't get nested universes though
15:40:52 <copumpkin> these are nested trees
15:41:36 <djahandarie> Set i is contained in Set i+1 isn't it?
15:42:08 <copumpkin> yeah sure, but the universe parameters I use for the properties are unrelated to each other
15:42:19 <djahandarie> Oh :(
15:42:41 <djahandarie> That makes it less epic
15:42:47 <copumpkin> yeah :P
15:42:53 <copumpkin> dons: btw, you might be interested in following http://twitter.com/xah_lee
15:43:09 <monochrom> xah lee?! hahaha
15:43:22 <djahandarie> I like his picture
15:43:23 <copumpkin> monochrom: I knew I'd find an incentive to make you join twitter!
15:43:40 <dolio> Everyone should be interested in the random thoughts of computer visionaries.
15:43:45 <monochrom> not joining twitter
15:43:45 <copumpkin> I agree
15:43:53 <luite> who's xah lee?
15:44:24 <dolio> ?google mad people of comp.lang.lisp
15:44:25 <lambdabot> http://www.tfeb.org/lisp/mad-people.html
15:44:25 <lambdabot> Title: Mad people of comp.lang.lisp
15:44:26 <djanatyn> I have written my second haskell program :)
15:44:47 <djanatyn> I have written my second haskell program! :D
15:44:54 <dons> copumpkin: i might not be interested
15:44:56 <djanatyn> It kind of sucks, because I mixed up strings and numbers.
15:45:01 <copumpkin> :(
15:45:11 <dons> copumpkin: read the #haskell logs :)
15:45:19 <copumpkin> yeah, I was mostly teasing :P
15:45:21 <dons> and the horrible things on his website
15:45:51 <djanatyn> Also, I apologize for saying that twice. I was a bit confused as my IRC client was acting up./
15:45:55 <djanatyn> http://hpaste.org/45735/a_number_cruncher <-- huzzah.
15:46:11 <djahandarie> djanatyn, either that, or you wrote your second Haskell program twice
15:46:30 <djanatyn> :D
15:46:47 <dons> also on ye olde proggit  http://www.reddit.com/r/programming/comments/gr3qs/haskell_platform_2011201_is_out_major/
15:47:02 <dons> and the downloads have started in earnest. 
15:48:14 <ivanm> dons: is the only change the bump in ghc?
15:49:48 <aristid> network 2.3 seems to be in, too
15:49:54 <aristid> or was that already in the last version?
15:50:09 <djahandarie> monochrom, is xah lee as wonky when he speaks in Chinese as he is when he speaks English?
15:50:19 <monochrom> I don't know
15:50:36 <aristid> monochrom: do you understand chinese?
15:50:40 <monochrom> yes
15:51:50 <dons> ivanm: and text got bumped
15:51:53 <dons> but basically, yeah.
15:51:59 <luite> I was wondering, why doesn't the haskell platform for windows include glut32.dll? license issue? to avoid conflicts with existing installs?
15:52:03 <aristid> dons: it would be nice if the changelog showed more than just the recent change
15:52:09 <aristid> +most
15:52:23 <dons> i'd love someone to take the repo and come up with a better changelog format
15:52:31 <dons>  http://code.galois.com/darcs/haskell-platform/
15:52:39 <ddarius> monochrom: I thought they spoke English over there in China.  And also, when did China buy Canada?
15:53:28 <monochrom> I don't know
15:53:38 <aristid> somehow i consider it weird that fgl is in the platform. it doesn't "feel" very core-ish to me.
15:53:59 <ivanm> ddarius: wow, I just knew that China was busy buying out Australia; didn't realise they were buying Canada as well!
15:54:15 <dolio> monochrom: Are you saying you don't hang out and speak Chinese with xah lee?
15:54:43 <ivanm> aristid: well, it's certainly a better graph implementation than Data.Graph
15:55:07 <aristid> ivanm: it also uses Int for edges, so i see no real improvement :P
15:55:12 <copumpkin> back in my middle school, one of the teachers loved to ask me if I was friends with <insert english person here>
15:55:19 <dons> aristid: hysterical raisons
15:55:19 <aristid> i mean for nodes
15:55:30 <aristid> dons: i thought it was raisins.
15:55:31 <dons> ivanm will be replacing it soon enough
15:55:37 <dons> reasons?
15:55:50 <ivanm> dons: actually, I'm thinking of ditching my attempts and working on edwardk's library
15:55:54 <aristid> "hysterical raisins" is the way i've read it most often
15:55:56 <ivanm> especially as he stole my module namespace :@
15:56:06 <copumpkin> "your"? :P
15:56:32 <aristid> copumpkin: why of course, ivanm was first in the graph landgrab!
15:56:34 <ivanm> copumpkin: as in the modules I thought I had well-publicised as using
15:56:58 <ivanm> especially since libraries@ didn't think having a new top-level Graph.* namespace was a good idea
15:58:02 <aristid> what's edwardk's graph package?
15:58:19 <copumpkin> @hackage graphs
15:58:19 <lambdabot> http://hackage.haskell.org/package/graphs
15:58:28 <beastaugh> ivanm: is edwardk's library mature enough to do serious work with?
15:58:34 <aristid> copumpkin: nice name.
15:58:46 <ivanm> beastaugh: not last I checked
15:59:10 <ivanm> it was aimed more at ways of dealing with graphs that can't all be stored in memory initially
15:59:17 <ivanm> and wasn't that fleshed out
15:59:27 <ivanm> I haven't had much time to do any hacking the last couple of months :s
16:00:09 <luite> wow a package by edwardk that's actually understandable without aspirin :)
16:00:19 <ddarius> @hackage void
16:00:20 <lambdabot> http://hackage.haskell.org/package/void
16:00:28 <m3ga> has {-# OPTIONS -cpp #-} changed in ghc 7.0.3?
16:00:48 <copumpkin> I'd just use LANGUAGE CPP
16:01:01 <copumpkin> but I've been doing that since 6.10 I think
16:01:46 <ivanm> luite: well, the original version was comonadic...
16:01:59 <m3ga> nope, LANGUAGE CPP doesn't work either.
16:02:01 <ivanm> but he realised he could use a monadic approach which would cater to a wider audience
16:02:08 <ivanm> m3ga: :o
16:02:09 <copumpkin> m3ga: I've used it many times
16:02:17 <Cin> In one of the SQL libraries building uses ‘?’ for referencing values provided. I can't remember which. How does one then write a literal ‘?’
16:02:53 * ddarius hates unnamed placeholder syntax.
16:02:59 <m3ga> i'm on powerpc and i #include "ghcconfig.h" and then do #if WORDS_BIGENDIAN and i don't get what i expect
16:03:18 <Cin> ddarius: What do you prefer?
16:03:36 <ddarius> Cin: Are you an intuitionist or something?
16:03:43 <aristid> ivanm: can't he have both instances?
16:03:50 <Cin> ddarius: Sorry?
16:03:55 * copumpkin chuckles
16:04:12 <ivanm> aristid: you mean both monadic and comonadic?
16:04:27 <copumpkin> Cin: intuitionists tend to prefer "useful" definitions that provide something, rather than just negating it
16:04:37 <aristid> ivanm: well, yes.
16:04:45 <Cin> ddarius: I'm considering using the unnamed placeholders, but if you have a better idea I am very interested.
16:04:59 <ivanm> aristid: it would involve implementing everything _twice_
16:05:12 <ddarius> Cin: I was complaining about such syntaxes, not your use of it.
16:05:15 <ivanm> and quite a few of us kept asking him "so how does this work" for his comonadic approach ;)
16:05:15 <Cin> copumpkin: Right. I didn't mean that. I genuinely am looking for ideas.
16:05:30 <aristid> ivanm: i didn't even know it was possible to implement the same algorithms both monadically and comonadically
16:05:31 <Cin> ddarius: Sure. I'm still criticising it myself. 
16:05:40 <aristid> ivanm: i thought both are mostly different beasts
16:05:42 <ddarius> The obvious alternative to unnamed placeholder syntax is named placeholder syntax.
16:06:34 <ivanm> aristid: yes
16:06:47 <ivanm> but more people are likely to use the monadic one, so rather than implementing it twice...
16:07:05 <aristid> ivanm: is the comonadic one more elegant?
16:07:30 <ivanm> I think it was "conceptually" more elegant... but less understandable to most people ;)
16:07:45 <ivanm> it involved some kind of tagging or something; I really didn't get it :s
16:07:53 <ivanm> I think the trac wiki for HNN has a draft of it
16:07:58 <Cin> ddarius: It seems that's achievable only by TH, right? Something like $(query "select x where y = {y}")
16:09:36 <copumpkin> Cin: that's assuming you definitely want SQL string literals
16:09:53 <ddarius> Cin: It's just as doable as using "?" notation.
16:10:11 <Cin> ddarius: True enough.
16:10:32 <Cin> copumpkin: I quite prefer haskelldb's query monad, but I will settle for SQL string literals for now.
16:15:11 <osoleve> in hackage, in the type signatures, what's the difference between, say, Int and !Int?
16:15:27 <MasseR> !Int is strict
16:15:52 <osoleve> ahh, okay
16:15:54 <osoleve> thank you
16:20:07 <copumpkin> ddarius: what time is the mokolele and dinner?
16:20:25 <ivanm> @wn mokolele
16:20:27 <lambdabot> No match for "mokolele".
16:20:31 <ivanm> hmmm...
16:20:39 <copumpkin> the ukulele for Mo!
16:20:57 <ddarius> copumpkin: We were aiming for sometime at or after 9 due to Mo's strange habits.
16:27:02 <copumpkin> ddarius: sounds good
16:35:37 <ddarius> My nails are too long for this uke.
16:35:49 <aristid> @pl count f = length . filter f
16:35:49 <lambdabot> count = (length .) . filter
16:49:29 <MatrixFrog> woah that's cool
16:49:33 <MatrixFrog> what does "pl" stand for
16:50:39 <Zao> MatrixFrog: "pointless"
16:50:50 <MatrixFrog> :)
16:50:59 <Zao> MatrixFrog: A point in this context is a named variable.
16:51:04 <Zao> Err, parameter.
16:51:09 <MatrixFrog> yeah i've heard of "point free form"
16:51:10 <Zao> Note how it got rid of 'f' there.
16:51:24 <MatrixFrog> which always amused me because it often has lots of dots
16:51:26 <MatrixFrog> aka "points"
16:51:52 <ddarius> Actually, the points would me the values.
16:52:01 <ddarius> s/me/be
16:52:56 <OODavo> Okay, weird. In my xmonad.hs I'm using marshallPP from XMonad.Layout.IndependentScreens, but I get an error saying it's not in scope.
16:53:45 <ddarius> My violin is calling.
16:54:16 <MatrixFrog> yeah. i've just never heard the word "point" used that way outside of haskell conversations
16:54:33 <MatrixFrog> but i have heard it used to mean the . character
16:54:36 * MatrixFrog shrug
16:54:51 <ddarius> The term comes from point-free topology.
16:54:54 <aristid> MatrixFrog: the words are from maths
16:55:04 <MatrixFrog> fancy maths. more maths than i ever took
16:55:13 <MatrixFrog> i should go back to school at some point, just for fun
16:55:33 <Cin> ddarius: <ddarius> monochrom: I thought they spoke English over there in China. — That's a joke, right?
16:55:33 <copumpkin> or study it on your own time :)
16:55:38 <ddarius> Finding/understanding the terms for mathematical structures also known as the "word problem."
16:56:22 <OODavo> I'm definitely importing IndependentScreen, so I don't get why marshallPP isn't in scope. :/
16:57:18 <dolio> Cin: Everyone speaks English.
16:57:43 <dolio> Except those terrible furriners.
16:58:00 <systemfault> English became the real esperanto :P
16:58:04 <Cin> I read today that 0.02% of China speaks English. Thought it interesting.
16:58:46 <dolio> What is that? Like 40 million?
16:58:50 <Cin> Sorry, that's wrong, I checked it. 0.77%
16:59:00 <Cin> 10 million.
16:59:19 <systemfault> Shitty country :/
16:59:24 <systemfault> Do they have a second language?
16:59:32 <systemfault> (even if it's not english)
17:01:08 <Cin> systemfault: A highly effective country and culture, economically speaking, it seems: http://www.ted.com/talks/martin_jacques_understanding_the_rise_of_china.html
17:01:08 <ddarius> copumpkin: Going back to school forces you to learn about compound interest.
17:02:03 <xplat> ddarius: but if you go back to be an actuary this actually helps your education
17:02:06 <int80_h> http://hpaste.org/45739/a_curious_problem
17:02:16 <ddarius> xplat: How does learning about anything not help your education?
17:02:24 <systemfault> Cin: You can see that from their GDP
17:02:32 <xplat> ddarius: well, i meant in the goal directed sense
17:02:46 <Philippa> systemfault: "chinese" isn't actually just the one language
17:02:49 <systemfault> Cin: Seems that most people in china are shit-poor
17:02:55 <systemfault> Philippa: It's not even a language..
17:03:19 <Philippa> I believe that's covered under what I wrote
17:03:46 <xplat> actually, considering china was one of the major cultural and economic powerhouses for most of recorded history and has a billion people, it's doing amazingly badly even at present
17:03:52 <int80_h> when people talk about "Chinese" as if it's a language I hear them in Slim Whitman's voice saying "Chine eee"
17:04:10 <Philippa> (OTOH, I know Chinese people who will refer to the languages, plural, of China simply as Chinese)
17:04:21 <Cin> I suppose it's like saying "Indian" as a language.
17:04:39 <xplat> of course, a lot of that is that the standards for doing well economically have gone up a LOT
17:04:48 <systemfault> In china, I only know they speak mandarin and cantonese...
17:05:01 <int80_h> anyone want to take a look at my hpaste? 
17:05:04 <int80_h> http://hpaste.org/45739/a_curious_problem
17:05:05 <systemfault> There's probably more dialects... but I never heard of them
17:05:05 <Cin> Neither India or China are really one nation, as I understand it.
17:05:07 <xplat> systemfault: those are only the two most influential
17:05:20 <systemfault> xplat: Ah ok :)
17:05:27 <Philippa> systemfault: enough to make second language the wrong term for what I suspect you meant, though
17:05:47 <systemfault> Philippa: Ah... that's was the idea.. Congratulatiosn
17:06:36 <jmcarthur> int80_h: mapM_
17:06:59 <aristid> @pl \a b -> fmap (a,) b
17:06:59 <lambdabot> (line 1, column 16):
17:06:59 <lambdabot> unexpected ","
17:06:59 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:07:09 <aristid> @pl \a b -> fmap (\c -> (a,c)) b
17:07:09 <lambdabot> fmap . (,)
17:07:16 <xplat> mandarin because of its history as an upper-class/elite language, cantonese because of overall popularity among the common people particularly in certain parts of china
17:07:27 <int80_h> jmcarthur : thanks
17:07:31 <MatrixFrog> still super impressed by that
17:07:59 <Philippa> xplat: yeah. I'm told Canto is much more fun to swear in :-)
17:09:32 <Cin> xplat: Wasn't Mandarin introduced by fiat? Pretty much ‘we're using this language now, everything's going to be in this language, enjoy.’
17:09:35 * ddarius tends to swear in an amalgam of American English, British English, German, and Japanese.
17:10:06 <xplat> the aristocracy worked in a weird way in china previous to communism, after which it worked in another weird way
17:10:49 <aristid> hmm. i wonder how generally useful this function might be: zipF = zipWith (fmap . (,))
17:11:09 <ddarius> :t zipWith (fmap . (,))
17:11:09 <xplat> if i go out on a limb and make a ridiculously facile analogy i would call mandarin the chinese esperanto and cantonese the chinese english
17:11:09 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => [a1] -> [f a] -> [f (a1, a)]
17:11:10 <aristid> i can use it for zipping something into a list of Maybe, at any rate :)
17:11:32 <xplat> ddarius: you too?
17:12:12 <aristid> xplat: cantonese is actually spoken widely outside canton?
17:13:21 <xplat> aristid: it probably would be by now if it wasn't for communism
17:13:30 <aristid> xplat: huh?
17:14:47 <xplat> aristid: what i mean is, it probably would have become the lingua franca inside china based on the impact of movies and trade much like english has been spreading everywhere else
17:14:50 <ddarius> copumpkin: Was there any particular place you wanted to go?
17:15:07 <aristid> xplat: and how did communism prevent that?
17:15:25 <copumpkin> ddarius: not really
17:15:49 <xplat> aristid: it didn't so much prevent as slow down and reduce the impact
17:16:10 <aristid> xplat: by reducing trade and communication?
17:17:38 <aristid> @pl correct a b = if a == b then Just (a, b) else Nothing
17:17:38 <lambdabot> correct = flip flip Nothing . ap (ap . (if' .) . (==)) ((Just .) . (,))
17:17:48 <aristid> hmm. no, @pl that is not convincing
17:18:11 <xplat> aristid: basically, yes.  and reducing the influence of hong kong and expatriate communities too
17:18:37 <copumpkin> ddarius: did you have anywhere in mind?
17:18:39 <aristid> xplat: that's interesting. :)
17:19:12 <shachaf> @pl correct a b = guard (a == b) >> return (a,b)
17:19:12 <lambdabot> correct = ap (ap . (((>>) . guard) .) . (==)) ((return .) . (,))
17:19:37 <MatrixFrog> nice
17:20:03 <copumpkin> aristid: if they're the same, why bother returning both of them?
17:20:18 <aristid> copumpkin: oh, it should be /= :)
17:20:20 <ddarius> copumpkin: Not really.  A place with Thai tea would make Mo happy, so we could go to that Thai place again.  There's another Thai place in Cambridge that's decent, but I don't really feel like mapping the trek there.
17:20:39 <ddarius> copumpkin: (==) is only an equivalence relation.  In fact, it isn't even that.
17:20:41 <OODavo> ghc --show-iface doesn't reveal marshallPP. I suspect I've got an old version of xmonad-contrib or something.
17:20:56 <monochrom> module Italian where import Thai'tea ...
17:21:27 <ion> @pl \tuple -> guard (uncurry (/=) tuple) >> return tuple
17:21:27 <lambdabot> ap ((>>) . guard . uncurry (/=)) return
17:21:37 <xplat> aristid: in my mind the fact that the chinese esperanto won over the chinese english is a pretty good indication of how china is different from the rest of the world :7
17:22:15 <copumpkin> ddarius: which Thai place was that? I can't remember where :/
17:22:25 <ddarius> The one near Porter Square.
17:22:33 <xplat> (of course, every place is different from the rest of the world in some way, i'm not singling out china)
17:22:33 <copumpkin> oh
17:22:35 <copumpkin> okay
17:22:56 <ion> > curry (liftM2 (>>) (guard . uncurry (/=)) return) (1,2)
17:22:57 <lambdabot>   Overlapping instances for GHC.Show.Show
17:22:58 <lambdabot>                              ((t, t...
17:23:14 <ion> :t liftM2 (>>) (guard . uncurry (/=)) return
17:23:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Eq a) => (a, a) -> m (a, a)
17:23:18 <aristid> xplat: it "won", but AFAIK mandarin isn't really spoken that widely
17:23:26 <ion> Ah, whoops
17:23:33 <ion> > curry (liftM2 (>>) (guard . uncurry (/=)) return) 1 2
17:23:34 <lambdabot>   No instance for (GHC.Show.Show (m (a, a)))
17:23:34 <lambdabot>    arising from a use of `M87376...
17:23:46 <copumpkin> ddarius: what time after 9?
17:23:54 <copumpkin> just wondering if I should go home first
17:23:54 <ion> > curry (liftM2 (>>) (guard . uncurry (/=)) return) 1 2 :: Maybe (Int,Int)
17:23:56 <lambdabot>   Just (1,2)
17:28:01 <copumpkin> dolio: maybe it'd be best if you just started walking over here, and then we can go on to meet up with ddarius together
17:28:10 <copumpkin> or if you want to take the T, I can meet you on there
17:28:37 <dolio> Where's the T around here? That shopping center?
17:28:46 <dolio> On Brookline.
17:28:57 <copumpkin> there is one there, but the closer one is across the park right in front of the building
17:29:30 <copumpkin> if you walk straight out across the park, over towards the museum, and through the parking lot on its side, you'll hit huntington ave., which has a T running along the middle
17:30:02 <copumpkin> basically straight ahead out of the building's front door, avoiding the stream unless you want to get wet
17:30:09 <djahandarie> Then jump over the fence, kill the security guard, steal his uniform, and meet copumpkin and ddarius inside
17:30:37 <dolio> Okay. I think I see that.
17:32:11 <OODavo> I can't figure this out. I'm using xmonad-contrib-0.9.2, which appears to be the latest available via cabal. Yet that function isn't available. :/
17:32:23 <dolio> Are you going to go to the same station, or should I take it to some other station?
17:32:50 <copumpkin> how about I just hop onto the train you're on when you pass through prudential
17:33:07 <copumpkin> if you just send me a text before going underground or something
17:33:22 <dolio> I can try.
17:33:43 <byorgey> OODavo: it may be only in the darcs version and not in a released version yet.
17:34:18 <dolio> If I fail I guess I'll debark at prudential.
17:34:19 <OODavo> byorgey: Oh? Is there a way to check when a function was added on Hackage or something?
17:34:28 <copumpkin> alright
17:35:25 <OODavo> Oh, hang on. The Hackage page says it's xmonad-contrib-0.9.1 at the top. Since I'm on 0.9.2, it should have been added. Hmm.
17:35:46 <Saizan> OODavo: maybe it got removed later?
17:35:49 <byorgey> OODavo: or maybe it was removed!
17:36:12 <OODavo> Hmm, true. :(
17:37:05 <byorgey> OODavo: of course, make sure you have the spelling and capitalization right, etc.
17:37:27 <OODavo> Yes, I have checked that. :|
17:37:57 <byorgey> I figured you had, but it never hurts to make sure the simple things are out of the way...
17:38:17 <byorgey> OODavo: I'm trying to check for you on the status of marshallPP but I'm having trouble connecting to code.haskell.org.
17:39:32 <aristid> @src partition
17:39:32 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
17:39:32 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
17:39:32 <lambdabot>                               | otherwise = (ts, x:fs)
17:39:35 <byorgey> no, IndependentScreens still exports marshallPP
17:39:52 <byorgey> OODavo: how did you import IndependentScreens?  i.e. literally what did you type?
17:40:07 <OODavo> import XMonad.Layout.IndependentScreens
17:40:16 <byorgey> and what is the error message you get?
17:40:21 <OODavo> I can get at the other functions in it, like countScreens, just fine.
17:40:24 <OODavo> The error is:
17:40:40 <OODavo> Error detected while loading xmonad configuration file: /home/david/.xmonad/xmonad.hs
17:40:43 <OODavo> xmonad.hs:54:10: Not in scope: `marshallPP'
17:40:46 <OODavo> Please check the file for errors.
17:41:18 <byorgey> OODavo: and what is the output of 'ghc-pkg list xmonad-contrib' ?
17:42:05 <OODavo> /var/lib/ghc-7.0.3/package.conf.d
17:42:12 <OODavo> xmonad-contrib-0.9.2
17:42:55 <mheld> hey y'all
17:43:19 <byorgey> OODavo: hmm, that is very odd
17:43:22 <byorgey> hi mheld 
17:43:55 <mheld> what's going on, byorgey?
17:44:20 <byorgey> OODavo: if you cd .xmonad  and run 'ghci xmonad.hs', what happens?  do you get the error about marshallPP with that too?
17:44:36 <OODavo> I do indeed.
17:44:46 <byorgey> mheld: just hacking on some Haskell =)
17:45:19 <byorgey> OODavo: can you paste your xmonad.hs somewhere such as hpaste.org (or your favorite pastebin)?
17:45:34 <OODavo> Shall do.
17:45:47 <robertaaaaaa> I'm talking through the tryhaskell.org web interface
17:46:01 <robertaaaaaa> I was here last week and did /nick <mynick>
17:46:25 <robertaaaaaa> Now I can't connect as it says I'm already logged in.
17:46:42 <OODavo> Done. http://hpaste.org/45741/xmonadhs
17:46:46 <robertaaaaaa> Maybe someone can restart the tryhaskell.org web application?
17:48:17 <Egbert9e9> nazgjunk: yeah, i'm a newbie to most of it. easily blown
17:48:33 <mheld> I'm curious to find out what y'all think about the current state of haskell web frameworks?
17:48:45 <monochrom> very good state
17:48:52 <byorgey> robertaaaaaa: try /msg NickServ ghost <yournick>
17:49:03 <mheld> monochrom: comparable to ruby/rails?
17:49:41 <monochrom> I heard so
17:49:57 <parcs> err, not really
17:49:58 <byorgey> OODavo: hmm, strange, I don't have any more ideas, sorry =(
17:50:04 <OODavo> :(
17:50:56 <OODavo> I suppose I could just copy the relevant function definitions from Hackage into the file directly?
17:51:12 <monochrom> at least ruby/rails crashes every time a type error occurs
17:51:32 <byorgey> OODavo: yes, you could do that
17:52:20 <OODavo> The problem with that is that I need to copy more than just the one function since it's not all in scope. Hmm.
17:52:28 <OODavo> s/in scope/exported/
17:52:44 <byorgey> OODavo: what documentation are you looking at?
17:52:52 <byorgey> looks like marshallPP was added in January
17:53:15 <OODavo> Here on Hackage: http://hackage.haskell.org/packages/archive/xmonad-contrib-bluetilebranch/latest/doc/html/XMonad-Layout-IndependentScreens.html
17:53:36 <byorgey> oh, that's the bluetilebranch
17:53:42 <ddarius> monochrom: So does Snap/Yesod/Happstack/etc.
17:53:45 <byorgey> 0.9.2 was released in December of last year
17:53:51 <byorgey> so I don't think it included marshallPP
17:53:54 <OODavo> Oh?
17:54:19 <mheld> is there a de facto web framework?
17:54:29 <mheld> I'm looking at snap and yesod
17:54:33 <byorgey> bluetile is a separate fork
17:54:38 <monochrom> there are three de facto web frameworks. the three mentioned
17:54:44 <mheld> ah
17:54:59 <OODavo> Oh, I see.
17:55:02 <byorgey> OODavo: OK, I feel better now that I understand what is going on =)  I recommend you update to the darcs version, it is quite stable and you get all the latest features.
17:55:17 <monochrom> the newest tends to have the best abstraction
17:55:52 <OODavo> Okay, I'll upgrade to darcs as soon as I figure out how to do that. :P
17:56:18 <byorgey> OODavo: just a minute, let me see if there are instructions
17:56:31 <OODavo> I'm on a Debian-derivative, if it matters.
17:57:03 <byorgey> OODavo: there are instructions here: http://xmonad.org/download.html
17:57:18 <OODavo> Ah, I see.
17:58:14 <byorgey> OODavo: install darcs (should be a debian package for it), then run those 'darcs get' commands, then just run 'cabal install' in each of those directories
17:58:26 <OODavo> Got it. :)
17:58:37 <byorgey> ask in #xmonad if you run into problems.
17:59:16 <OODavo> Woah, lots of patches to copy. 1070 queued. :O
17:59:27 <byorgey> yeah, it takes a while to download the first time =)
18:00:12 <byorgey> alright, I'm off homeward
18:02:39 <ivanm> darce get --lazy ?
18:06:25 <jeffz> @pl progn xs =  mapM (\x -> x >>= return) xs >>= last
18:06:26 <lambdabot> progn = (last =<<) . mapM id
18:07:01 <aristid> mapM id is sequence, i think.
18:07:13 <aristid> :t (last =<<) . sequence
18:07:14 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m (m b)] -> m b
18:07:26 <aristid> :t (last =<<) . mapM id
18:07:27 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m (m b)] -> m b
18:07:32 <osoleve> how do I create an MIteratee? I can't figure it out by trial and error. :(
18:17:46 <osoleve> nevermind, I figured it out :3
18:22:07 <Egbert9e9> googling "all values are functions" yields some interesting results
18:24:12 <Egbert9e9> the search term: haskell "all values are functions
18:24:20 <Egbert9e9> number of results: 1840
18:24:43 <Egbert9e9> the search term: haskell "all functions are values
18:24:48 <Egbert9e9> err
18:25:05 <Egbert9e9> with double quotes at the end
18:25:17 <Egbert9e9> number of results: 3230
18:25:28 <Egbert9e9> interesting
18:25:51 <Egbert9e9> some say that "not all values are functions"
18:25:54 <aristid> Egbert9e9: it's because only the latter is true :)
18:26:16 <aristid> ("the latter" referring to "all functions are values")
18:26:24 <aristid> ("not all values are functions" is also true)
18:26:43 <Egbert9e9> aristid: which is also true
18:27:28 <aristid> Egbert9e9: it's easy to recognize if a value is a value: it always is. it's easy to recognize if a value is a function: it has a type of the form a -> b
18:27:44 <KSkrzet> where I can find documentation for ~/.cabal/config ?
18:28:32 <Egbert9e9> maybe "a -> b" is a thing that needs further computation which a simple "a" isn't
18:28:42 <Egbert9e9> s/isn't/doesn't/
18:29:03 <ion> All values being functions makes little sense. What parameter do you apply [2,3,4] to?
18:29:09 <aristid> Egbert9e9: no. a simple "a" can also need further computation.
18:29:22 <aristid> Egbert9e9: a function is simply something that takes an argument and returns another value.
18:29:39 <Egbert9e9> okay, so a thing that doesn't, isn't
18:30:15 <aristid> yes. there are no functions that take no arguments, in haskell.
18:30:16 <Egbert9e9> only a value that takes arguments is a function
18:30:28 <Egbert9e9> okay, i get it now
18:31:00 <acowley> a thing that doesn't, isn't
18:31:06 <acowley> I like it
18:31:10 <Egbert9e9> aristid: a day or two ago i realized for the first time why the empty set is a sub set of every other set
18:33:15 <Egbert9e9> aristid: T `is subset of` S == False only if there are.. uh.. things(?) inside T which do not belong to S
18:33:41 <aristid> right, that's roughly how it is defined.
18:33:50 <Egbert9e9> in the empty set, there are no things which do not belong to S, so (Empty `is subset of` S) == True
18:35:40 <Egbert9e9> so somehow i find the two things similar in the way that a clearcut definition like that can really clear some confusion
18:41:53 <KSkrzet> any ideas how to make stateful attoparsec-based parser?
18:43:19 <KSkrzet> I want this state to be preserved in incremental case but I don't see how to pull the state from unfinished parser
18:44:59 <osoleve> is anyone familiar with sndfile-enumerators?
18:45:13 <osoleve> i don't understand its conventions for writing to a file
18:46:16 <acowley> KSkrzet: isn't the state captured by the continuation in a Partial?
18:48:10 <KSkrzet> acowley: Parser is monad, but it can't handle state. so my solution is to provide state by argument and return it as element of return tuple
18:48:43 <osoleve> Sound.Iteratee.Codecs.Wave has several functions that use WAVEDict as a parameter, but there is no reference I can find as to what WAVEDict is
18:49:12 <KSkrzet> acowley: so clearly my solution won't work in this case
18:55:15 <conal> i just saw dons's announcement for Haskell Platform 2011.2.0.1. does anyone here know about the "significant improvements for Mac OS X users"?
18:56:53 <acowley> conal: the inclusion of GHC 7.0.3
18:57:01 <acowley> which brings Xcode 4 compatibility
18:58:04 <conal> hm. the full quote is "This release adds support for GHC 7.0.3, and significant improvements for Mac OS X users." so i gather that there's something more than 7.0.3. and perhaps more than xcode 4 compat.
18:58:05 <TTimo> oh good, been meaning to run some stuff on my shiny new MBP
18:58:48 <conal> though i could be reading too literally.
18:59:06 <acowley> conal: I think 7.0.3 is it
18:59:20 <systemfault> Hmm, I wonder if Apple will bundle xcode 4 with their next OS
18:59:25 <conal> acowley: thx.
18:59:41 <monochrom> usually you don't draw a clear line between haskell platform and the ghc it includes
19:00:12 <acowley> monochrom: this was a funny situation due to the Xcode 4 beta releasing just after the last HP and breaking things
19:08:20 <m3ga> anyone know how to install the haskell platform pkg on OSX via ssh (ie command line only)?
19:09:53 <Axman6> ai think there's an install commandline tool
19:09:55 <TheZimm> m3ga you could build it yourself
19:09:56 <Axman6> one sec
19:10:12 <blackdog> m3ga: 'installer' i think
19:10:20 <Axman6> man install
19:10:27 <Axman6> wait, wrong
19:10:37 <Axman6> yeah it is installer
19:10:48 <Axman6> the apropos synopsis wasn't clear -_-
19:11:42 <m3ga> there doesn't seem to be an 'installer' executable on my PATH
19:12:05 <m3ga> TheZimm: can't build it because i don't have ghc yet
19:12:24 <Axman6> m3ga: /usr/sbin/installer
19:12:52 <m3ga> ah, no usr/sbin on my path
19:14:03 <blackdog> m3ga: for a moment, i thought you meant the dir didn't exist
19:14:12 <blackdog> "what have you done to that poor machine?!"
19:14:15 <Axman6> me too
19:14:59 <MatrixFrog> wooo worktime over
19:15:02 <MatrixFrog> haskelltime starting
19:15:12 <christo_m> MatrixFrog me too:P
19:15:19 <MatrixFrog> as soon as i check through google reader and reddit real quick :P
19:15:24 <m3ga> i'm a unix old timer. i'm not going to do anything too dumb.
19:15:45 <m3ga> ok, can i install haskell platform just for me in my home dir?
19:15:53 <Finalflash50> Hi
19:16:28 <Axman6> m3ga: i don't think the installer can do that
19:16:42 <m3ga> yeah, seems so : installer: This package requires authentication to install.
19:17:01 <m3ga> OSX might look like unix, but it isn't really
19:17:05 <Axman6> it installs a lot of stuff in /Library/Frameworks/GHC.framework
19:17:40 <m3ga> so how can i install HP locally. i don't have root.
19:17:44 <m3ga> ?
19:17:46 <Axman6> well, it is, nbut installers were designed for "typical users", not installing things like compilers
19:18:28 <m3ga> yes, but i can grab a debian package and fudge install it to my $HOME.
19:18:56 <m3ga> especially something like a compiler that shouldn't need root access
19:20:21 <Axman6> probably the easiest way is to install using the tarball here: http://www.haskell.org/ghc/download_ghc_7_0_3#macosxintel
19:20:35 <Axman6> either the 32 or 64 bit version
19:20:42 <Axman6> then compile and install the platform
19:21:23 <m3ga> yeeesh!
19:21:37 <m3ga> ok, proceeding to bang head against table :-)
19:33:41 * hackagebot LibClang 0.0.7 - Haskell bindings for libclang (a C++ parsing library)  http://hackage.haskell.org/package/LibClang-0.0.7 (ChetanTaralekar)
19:36:09 <MatrixFrog> so what are all the bots in here
19:36:20 <MatrixFrog> i feel like i'm in Futurama in IRC channels sometimes
19:36:30 <MatrixFrog> "oh hey look, a robot. well then"
19:37:03 <Cin> @vixen are you a robot?
19:37:03 <lambdabot> no, how dare you ask if i'm a bot!
19:37:08 <Axman6> hackagebot, lambdabot, preflex, sometimes hpaste's bot is in here... and there's at least one more whose name i can't remember
19:37:12 <Axman6> @bot
19:37:12 <lambdabot> :)
19:37:17 <Axman6> bah
19:37:23 <christo_m> @seen mzero
19:37:23 <lambdabot> Unknown command, try @list
19:37:23 <preflex>  mzero was last seen on #haskell 4 hours, 2 minutes and 1 second ago, saying: :-)
19:48:19 <rothwell> is there any documentation for haskelldb beyond the haddock stuff?
19:48:32 <rothwell> i've found one two-page paper that barely covers anything
20:14:58 <MatrixFrog> ok so after all the hassle of installing things yesterday, i actually have some haskell code from hackage, that's working!
20:15:06 <MatrixFrog> and i'm trying to read through it and understand what it's doing
20:15:09 <osoleve> yayyy
20:15:36 <MatrixFrog> (it's HPong: http://hackage.haskell.org/package/HPong )
20:16:03 <MatrixFrog> so one thing i notice is that they declare windowW and windowH as doubles
20:16:33 <MatrixFrog> but then they call initGL, which is of type GLsizei -> GLsizei -> IO ()
20:16:43 <MatrixFrog> where GLsizei is something like an Int, i assume
20:16:45 <MatrixFrog> so they do this:
20:16:50 <MatrixFrog> initGL (floor $ windowW) (floor $ windowH)
20:17:01 <MatrixFrog> are the "$"s necessary?
20:17:20 <Axman6> they aren't
20:17:21 <Lemmih> MatrixFrog: Nope.
20:17:24 <Axman6> not there anyway
20:17:32 <MatrixFrog> so they were just being extra fancy then. that's cool :P
20:18:14 <Axman6> makes sense if they wanted to later write (floor $ 1.5 * windowH)
20:18:50 <MatrixFrog> "floor 1.5 * windowH" would be like "(floor 1.5) * windowH"
20:19:08 <MatrixFrog> with the $ it's like "floor (1.5 * windowH)"
20:19:16 <dmwit> correct
20:22:57 <MatrixFrog> is there any way to know where a function comes from? there's a thing called "initialize" which I assume comes from openGL but i don't know for sure
20:23:15 <KSkrzet> does anyone here has used fgl?
20:23:22 <MatrixFrog> in java, the IDE could tell you if it was org.openGL.initialize or com.sun.whatever.initialize... you know what i mean?
20:23:25 <KSkrzet> my program just crashed with: Data/Graph/Inductive/NodeMap.hs:147:9-32: Irrefutable pattern failed for pattern Data.Maybe.Just es'
20:27:26 <MatrixFrog> or should i just use hoogle?
20:35:03 <MatrixFrog> so one thing about haskell using so many non-alphanumeric characters...
20:35:06 <MatrixFrog> it's super hard to google "@"
20:37:07 <djahandarie> Have you tried hoogle or hayoo? :)
20:37:21 <djahandarie> -- and I see that you just mentioned hoogle yourself :p
20:37:34 <MatrixFrog> but i didn't try it because i thought it might be more fun/informative to ask here
20:37:37 <fryguybob> MatrixFrog: If you use the hoogle search website @ shows up with a link to the keyword.
20:37:45 <MatrixFrog> yup :D
20:37:51 <djahandarie> Yeah, hoogle added that recently, pretty cool.
20:38:57 <MatrixFrog> i don't really get the example there because i don't understand "case" i think
20:39:06 <MatrixFrog> but i understand how it was used in HPong
20:39:30 <MatrixFrog> windowResize s@(Size w h) = do ...
20:39:39 <MatrixFrog> then inside of the "do" they use s when they want the entire Size object
20:39:45 <MatrixFrog> and w and h separately when they want that
20:40:38 <MatrixFrog> woo
20:42:16 <MatrixFrog> :t when
20:42:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:43:08 <MatrixFrog> :t if
20:43:09 <lambdabot> parse error (possibly incorrect indentation)
20:43:28 <MatrixFrog> :-/ so http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/Monad.html#v:when it sounds like when is kind of like if
20:43:35 <MatrixFrog> but if is only for functions and when is for monads?
20:45:01 <MatrixFrog> in a function you say: if this is true, return that, but otherwise return this other thing
20:45:37 <MatrixFrog> this is... kind of the same
20:45:54 <MatrixFrog> except there's no "else"
20:49:37 * MatrixFrog is becoming alternate more confused and less confused
20:59:17 <dmwit> MatrixFrog: Yes, "when" is like a one-sided if.
20:59:19 <dmwit> In fact:
20:59:22 <dmwit> ?src when
20:59:22 <lambdabot> when p s = if p then s else return ()
20:59:34 <MatrixFrog> see now that is awesome
20:59:40 <MatrixFrog> ?src lambdabot
20:59:40 <lambdabot> Source not found. Are you on drugs?
20:59:44 <MatrixFrog> :-/
20:59:47 <dmwit> ?where lambdabot
20:59:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:00:47 <dmwit> So, @ is used for binding additional names.
21:00:56 <MatrixFrog> ok so if you said:
21:00:56 <MatrixFrog> when p s = if p then s else ()
21:01:06 <MatrixFrog> that would not work because 's' is of the proper type but () is not
21:01:09 <MatrixFrog> :t when
21:01:10 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:01:15 <Axman6> :t let when p s = if p then s else () in when
21:01:16 <lambdabot> Bool -> () -> ()
21:01:16 <dmwit> "name@pattern" binds all the variables "pattern" would bind, and additionally binds a variable "name" which is equal to the whole pattern.
21:01:33 <dmwit> MatrixFrog: That would work, but it would have a different type:
21:01:39 <dmwit> :t \p s -> if p then s else ()
21:01:39 <lambdabot> Bool -> () -> ()
21:01:43 <dmwit> (A much less useful type.)
21:01:47 <MatrixFrog> quite so
21:01:57 <MatrixFrog> :t ()
21:01:57 <lambdabot> ()
21:02:00 <MatrixFrog> :t return ()
21:02:00 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
21:02:19 <MatrixFrog> ok... so i have a pretty good understanding (i think) of what IO means
21:02:29 <dmwit> Oh, nice.
21:02:30 <MatrixFrog> so i would have thought that "return ()" was of type "IO ()"
21:02:34 <MatrixFrog> but it's more general than that
21:02:36 * ivanm suspects MatrixFrog is lying...
21:02:41 <dmwit> MatrixFrog: Yes.
21:02:44 <djahandarie> If you did   (\p s -> if p then s else ()) :: (Monad m) => Bool -> m () -> m ()   then you would get the error you were expecting
21:02:48 <MatrixFrog> oh yes i probably am
21:02:50 <dmwit> :t return () :: IO ()
21:02:51 <lambdabot> IO ()
21:02:51 <ivanm> _nobody_ without a first name of "Simon", "Don" or "Oleg" understands IO!
21:02:52 <ivanm> :p
21:03:05 <dmwit> MatrixFrog: "return ()" has the type "IO ()", but it also has a few other types.
21:03:21 <MatrixFrog> much like how "[]" has the type [Int] but also [Char]?
21:03:27 <MatrixFrog> s/much like/somewhat like
21:03:29 <dmwit> Very similar, yes.
21:03:38 <miyako> hello, I think I'm having some confusion about monads; I'm trying to get the sum of a list of random numbers, but the list has type IO [Int], so sum won't work
21:03:58 <dmwit> miyako: You might like "liftM", "fmap", or "<$>".
21:04:05 <dmwit> :t liftM
21:04:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:04:09 <MatrixFrog> i suppose understanding all this is like understanding quantum physics
21:04:13 <dmwit> :t liftM sum
21:04:14 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m [a] -> m a
21:04:17 <dmwit> :t fmap sum
21:04:18 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f [a] -> f a
21:04:21 <MatrixFrog> if you think you understand it, good for you. but you're probably wrong
21:04:23 <dmwit> :t (sum <$>)
21:04:24 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f [a] -> f a
21:04:31 <MatrixFrog> I think I can safely say that nobody understands quantum mechanics. (Feynman)
21:04:34 <ivanm> MatrixFrog: what's so hard about quantum physics?
21:04:35 <ivanm> :p
21:04:50 <MatrixFrog> DOING it is not *that* hard
21:04:52 <dmwit> When he said that, nobody did understand quantum physics. But I don't think that's so today.
21:04:56 <ivanm> you just have to understand the math; ignore what it tells you! :p
21:04:56 <MatrixFrog> understanding it, is another matter
21:05:04 <dmwit> Or rather, the things we don't understand are much deeper than the things they didn't understand then. =)
21:06:02 <miyako> dmwit: could you point me to some documentation on those functions? I'm not all that good at understanding arrow notation yet
21:06:22 <dmwit> miyako: Not much, I'm afraid.
21:06:54 <dmwit> miyako: I can point you to the implementations for any particular Functor, Monad, or Applicative that you care to ask about, perhaps.
21:07:11 <ivanm> preflex: seen Manatee
21:07:12 <preflex>  Sorry, I haven't seen Manatee
21:07:15 <dmwit> miyako: However, specializing the type might make it a bit easier to understand.
21:07:16 <ivanm> preflex: seen ManateeLazyCat
21:07:16 <preflex>  ManateeLazyCat was last seen on #haskell 6 days, 21 hours, 11 minutes and 27 seconds ago, saying: HI all. :)
21:07:26 <dmwit> miyako: liftM :: (a -> b) -> (IO a -> IO b)
21:07:28 <MatrixFrog> ? >>=
21:07:34 <MatrixFrog> @>>=
21:07:34 <lambdabot> Unknown command, try @list
21:07:39 <skirmish> Help!  Has anybody here written a "take n" iteratee?
21:07:44 <dmwit> miyako: In other words, liftM takes a pure function and runs it on a computation that might do some IO.
21:07:57 <dmwit> miyako: (The other functions have the same specialized type.)
21:08:08 <miyako> okay, I think I understand
21:08:08 <skirmish> I am working through Snoyman's 3 part enumerator tutorial and am stuck on this.
21:08:22 <dmwit> MatrixFrog: What do you want to know about (>>=)?
21:08:32 <dmwit> MatrixFrog: Its type, its implementation, what?
21:08:41 <dmwit> :t (>>=)
21:08:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:08:42 <Axman6> skirmish: which framework?
21:08:51 <dmwit> MatrixFrog: It's implemented differently for each Monad.
21:08:53 <MatrixFrog> oh i forgot operators are usually just functions
21:08:53 <skirmish> Data.Enumerator
21:09:21 <MatrixFrog> is that kind of like how 'show' is implemented differently for each type that's an instance of Show?
21:09:29 <dmwit> Yes.
21:09:34 <MatrixFrog> ok sweet
21:09:35 <dmwit> Exactly like, in fact:
21:09:37 <dmwit> ?src Monad
21:09:37 <lambdabot> class  Monad m  where
21:09:37 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
21:09:37 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
21:09:37 <lambdabot>     return      :: a -> m a
21:09:37 <lambdabot>     fail        :: String -> m a
21:09:42 <skirmish> Axman6: I can post what I have, but getting weird GHC errors: parse error on input '='
21:09:47 <miyako> o what is the difference between fmap and liftM?
21:10:09 <dmwit> miyako: liftM = fmap, but fmap works on any Functor
21:10:10 <Axman6> miyako: basically nothing, except one works only on functors, and other works only on monads
21:10:51 <djahandarie> And Haskell's class hierarchy is broken so both are required
21:11:04 <djahandarie> (Normally you'd only need fmap)
21:11:25 <skirmish> Axman6: http://hpaste.org/45743/take_iteratee
21:11:46 <MatrixFrog> interesting... ghci doesn't like ":t >>="
21:11:54 <Axman6> skirmish: tabs! bad skirmish!
21:11:54 <MatrixFrog> ah
21:11:57 <MatrixFrog> parens to the rescue
21:12:53 <skirmish> Axman6: Really, Leksah did it, not me.  Thanks.
21:14:55 <skirmish> Axman6: Thanks, works now, I thought I was going crazy.
21:15:05 <Axman6> no worries
21:15:11 <MatrixFrog> :t .
21:15:11 <lambdabot> parse error on input `.'
21:15:17 <MatrixFrog> :t (.)
21:15:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:15:35 <ion> :t (Prelude..)
21:15:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:15:45 * MatrixFrog is afraid to ask what a functor is, and whether it's sort of the same as a function or not
21:16:08 <koninkje> MatrixFrog: it's not the same as a function (though they are functions, usually)
21:16:18 <koninkje> :i Functor
21:16:20 <MatrixFrog> i thought the type of "." was just (b -> c) -> (a -> b) -> (a -> c)
21:16:40 <koninkje> MatrixFrog: it is. lambdabot has a special definition (.) = fmap
21:16:42 <MatrixFrog> guessing someone's going to say, yes, it does have that type, but it also has other types...
21:17:10 <miyako> you know, I have to say that I've only been trying in earnest to learn haskell for a month or so, but the haskell community has been one of the friendliest and most helpful that I've come across when trying to learn a new language or technology
21:17:23 <koninkje> I much prefer the definition of (.) from Category. I thing (.)=fmap is unhelpful.
21:17:36 <MatrixFrog> ok then i shall ignore that definition for the moment
21:17:46 <MatrixFrog> can lambdabot tell me the precedence of (.)?
21:17:58 <Axman6> no, but ghci can
21:18:08 <koninkje> Probably, though I'm not sure the command. In GHCi you can use :i (.)
21:18:17 <MatrixFrog> thanks!
21:18:23 <djahandarie> @src (.)
21:18:23 <lambdabot> (f . g) x = f (g x)
21:18:23 <lambdabot> NB: In lambdabot,  (.) = fmap
21:18:33 <djahandarie> Hm, I swear there is a way to get it
21:18:41 <koninkje> @info (.)
21:18:42 <lambdabot> (.)
21:18:47 <djahandarie> Haha, useful
21:18:51 <MatrixFrog> so zen
21:19:08 <ion> matrixfrog: Functor is just a type you can map over. map (+1) [0,2,4] results in [1,3,5]. Imagine map worked for other types, too. What would you expect map (+1) (Just 5) to do? The obvious result would be Just 6. How about map (+1) Nothing? If you compare Nothing conceptually to an empty list, it would be logical to return Nothing. fmap is that generalization of map for other types, and the types that implement fmap are instances of Functor.
21:19:38 <osoleve> ion: great explanation, thanks
21:19:49 <MatrixFrog> but it's the (+1) that's the functor
21:19:54 <MatrixFrog> not the Maybe
21:20:14 <koninkje> N.B., fmap must follow the laws: fmap id == id, and (fmap f . fmap g) == fmap (f . g)
21:20:47 <koninkje> MatrixFrog: No, it's the Maybe that's the functor
21:21:01 <MatrixFrog> then doesn't that mean a list is also a functor?
21:21:15 <ion> Lists are functors, too, yes.
21:21:19 <mzero> yes, yes it is
21:21:21 <MatrixFrog> but so are functions?
21:21:26 <koninkje> MatrixFrog: (though technically yes, (+1) is an endofunctor on the monoid categories for Nat, Int,...)
21:21:45 <mzero> well, not normally - but they can be made so
21:21:51 <MatrixFrog> :-/ i shall come back to this line of thinking later
21:22:00 <koninkje> MatrixFrog: the type constructor (a ->) is a functor
21:22:14 <koninkje> Which is a bit different than saying "functions are functors"
21:22:24 <djahandarie> lol koninkje
21:22:37 <mzero> which is to say, that type constructor (a ->) can be made an instance of Functor --- and there is some package which does it....
21:22:47 <djahandarie> That package is 'base' ;)
21:22:49 <djahandarie> It's a module
21:22:51 <mzero> ... but be ware that without that, the Prelude doesn't define such an instance
21:22:53 <djahandarie> Control.Monad.Instances
21:22:55 <Axman6> @instances Functor
21:22:56 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
21:23:15 <mzero> er, yes, there is some *module* which does it
21:23:27 <MatrixFrog> i'm sure i've seen thie answer to this before, but how do i read "infixl 1 >>=", specifically the 1...
21:23:52 <MatrixFrog> that means it has lower precedence than something that was "infixl 2"?
21:23:52 <koninkje> The 1 is the precedence level
21:23:52 <djahandarie> in fix ell one bind
21:23:56 <djahandarie> Oh
21:24:15 <mzero> 1 is loose, 9 is tight
21:24:27 <MatrixFrog> ok sweet
21:24:37 * MatrixFrog slowly... starting to get it...
21:26:55 <applicative> MatrixFrog: If inside ghci you type ":i +" or ":i * "  it will tell you the precedence infixl 7 * infixl 6 +
21:27:11 <MatrixFrog> right, i just needed to remember 9=tight, 1=loose
21:27:34 <MatrixFrog> better intuition if i do that, vs saying "high precedence" / "low precedence"
21:27:35 <applicative> yes, i find it hard to retain.  
21:27:50 <mzero> also, since I can never remember which way is which....   :info + *   will tell you both at once
21:27:52 <mzero> and make ti clear
21:27:56 <applicative> 9 is very sticky. 
21:28:41 <mzero> 9 is strong, holds terms together like ox!
21:28:55 <applicative> the $ is very loose, while whitespace is very tight 10
21:29:22 * MatrixFrog 's whitespace goes to 11
21:29:35 <mzero> well... it isn't quite right to say whitespace is tight... but yes, function application is tighter than all the operators
21:30:05 <applicative> mzero, yes, I was being a little crude
21:30:52 <mzero> programmers from other languages get so wigged out about the lack of parens in function application
21:31:18 <mzero> I've got a set of slides where I show expressions in C/Python/Whatever  and then on the next slide just fade the parenthesis and commas out
21:31:28 <mzero> ... and then you have Haskell
21:31:44 <mzero> I show that in all languages function application binds tighter than operators
21:31:52 <applicative> MatrixFrog: I find it difficult to learn from the infixr n declarations, but the hlint tool helped a lot in showing where parentheses you are unneeded
21:31:58 <mzero> (well, most languages that people know)
21:32:42 <applicative> MatrixFrog: pardon illiteracy....
21:36:14 <MatrixFrog> nice
21:36:33 <nyingen> @keal
21:36:33 <lambdabot> can GMP support KealDigit? I invent KealDigit
21:36:38 <nyingen> lol
21:37:02 <dons> oh boy. keal.
21:37:04 <dons> been a while.
21:37:28 <nyingen> he's full of wisdom
21:37:40 <nyingen> @keal
21:37:40 <lambdabot> nsa try kill me numerous times
21:37:51 <nyingen> was he russian?
21:38:36 <dons> disturbed, i think. he was interesting.
21:39:48 <nyingen> on the subject of lambdabot quote material, I thought @protontorpedo was a euphemism for @trollhaskell
21:40:01 <nyingen> I had no idea it was quotes from an actual person until it was pointed out to me here :)
21:41:02 <ivanm> @trollhaskell
21:41:02 <lambdabot> Unknown command, try @list
21:41:05 <ivanm> huh
21:41:23 <nyingen> @protontorpedo
21:41:24 <lambdabot> is there going to be a better dns server in haskell?
21:41:38 <ivanm> only if nyingen writes it... :p
21:41:48 <nyingen> see, seems like something haskellers would cook up as phony troll questions
21:43:12 <applicative> was protontorpedo a frequenter of #haskell?
21:44:05 * applicative likes keal better
21:45:00 <ivanm> @. elite keal
21:45:00 <lambdabot> WITH kEaLDIgiT Qu4N7Um CrAckprooF En(RYP7ion p0s$ib1E
21:45:11 * ivanm prefers that better :p
21:45:25 <ion> @. unpl keal
21:45:25 <lambdabot> ((my very first computer was an 80) - 840)
21:45:26 <nyingen> nice
21:45:36 <Axman6> ha
21:46:20 <nyingen> @. elite keal
21:46:20 <lambdabot> #Ha5KeLL NeEds 7O 74xE it$ MeDS
21:46:26 <ion> @. unpl keal
21:46:26 <lambdabot> today's 24 hour project was supposed to be logical overloading using plegm method
21:46:30 <nyingen> @. elite protontorpedo
21:46:30 <lambdabot> |-|o\/\/ Iz0rz H4$Kell DiFF3REnT T|-|aN JA\/A?
21:46:34 <nyingen> this is fun
22:13:30 <RichardO> is there a easy way to write this point free? h x = f (g x) x
22:13:43 <shachaf> @pl h x = f (g x) x
22:13:43 <lambdabot> h = f =<< g
22:13:57 <RichardO> ah, very cool. thanks
22:16:59 <ion> @pl h x = f x (g x)
22:16:59 <lambdabot> h = ap f g
22:27:39 <Balahla> Need help. Why this don't work:
22:28:10 <Balahla> fun = Data.ByteString.Lazy.writeFile "i:\\gerar\\KML-File.kml"
22:28:23 <Balahla> Data.ByteString.Lazy.readFile "i:\\gerar\\KMZ-File.kmz" >>= Codec.Compression.GZip.decompress >>= fun
22:28:57 <ivanm> what's the error?
22:29:06 <Balahla> The compiler says the types don't match...
22:29:21 <ivanm> maybe GZip requires strict Bytestrings rather than Lazy
22:30:01 <Balahla> I'gonna try...
22:30:03 <Balahla> Thanks
22:38:36 <MatrixFrog> @pl rowAt x y = (!! y)
22:38:37 <lambdabot> rowAt = const (flip (!!))
22:38:50 <MatrixFrog> :i const
22:39:00 <copumpkin> you're ignoring the x
22:39:09 <copumpkin> what would you expect?
22:39:13 <MatrixFrog> ah yes
22:39:26 <MatrixFrog> i'm not sure. this isn't my code. it's a kind of half-baked idea i found on github
22:39:30 <MatrixFrog> https://github.com/iamjwc/hs-sudoku/blob/master/main.hs
22:42:03 <wagle> what ever happened to rubrication.net?  who did it?  i have 20 dead urls
22:42:09 <MatrixFrog> it looks like they needed it to have the same type as a couple of other functions
22:42:13 <MatrixFrog> i think i would have written it:
22:42:21 <MatrixFrog> rowAt _ y = (!! y)
22:42:27 <MatrixFrog> @pl rowAt _ y = (!! y)
22:42:27 <lambdabot> rowAt = const (flip (!!))
22:45:36 <ivanm> wagle: huh? why ask here?
22:45:42 <ivanm> (as it appears to be a watch site)
22:45:55 <wagle> haskell related blog
22:46:59 <wagle> until a couple months ago, then it disappeared, then the watch spammer grabbed it
22:47:33 <ivanm> ahhhh
22:47:39 <MatrixFrog> :i (\\)
22:48:17 <ivanm> wagle: http://web.archive.org/web/20080629044026/http://www.rubrication.net/
22:48:17 <MatrixFrog> :i (List.\\)
22:49:42 <wagle> i guess i'm trying to track down the author
22:49:42 <MatrixFrog> ok nm, found it on hoogle. but is there a common pronuncation for "\\"
22:50:32 <ivanm> MatrixFrog: list difference ?
22:50:46 <MatrixFrog> ok cool :)
22:50:54 <shachaf> MatrixFrog: "backslash backslash"?
22:51:19 <MatrixFrog> that's the amount of syllables i was trying to avoid :P
22:51:28 <shachaf> Just say them more quickly.
22:52:07 <Balahla> Need help. Why this don't work:
22:52:13 <Balahla> fun = Data.ByteString.Lazy.writeFile "i:\\gerar\\KML-File.kml"
22:52:19 <Balahla> Data.ByteString.Lazy.readFile "i:\\gerar\\KMZ-File.kmz" >>= Codec.Compression.GZip.decompress >>= fun
22:52:25 <Balahla> The compiler says the types don't match...
22:53:07 <Balahla> :t Codec.Compression.GZip.decompress
22:53:08 <lambdabot> BSLC.ByteString -> BSLC.ByteString
22:53:09 <ivanm> Balahla: I already told you
22:53:24 <Balahla> Codec.Compression.GZip.decompress
22:53:24 <Balahla>   :: Data.ByteString.Lazy.Internal.ByteString
22:53:24 <Balahla>      -> Data.ByteString.Lazy.Internal.ByteString
22:53:34 <ivanm> oh... it _does_ use lazy bytestrings?
22:53:40 <MatrixFrog> :t is your friend :)
22:53:40 <lambdabot> parse error on input `)'
22:53:47 <ivanm> Balahla: what is the type of "fun" ?
22:53:54 <Balahla> Yes, but GZip.decompress is Lazybytestring
22:53:56 <ivanm> oh, that's why: decompress isn't in IO
22:54:14 <ivanm> Balahla: liftM decompress $ readFile "foo"
22:55:04 <Balahla> Yes, but read is IO LazyBS -> bs
22:55:19 <Balahla> decompress is lazybs -> lazybs
22:55:29 <ivanm> exactly
22:55:31 <Balahla> and write is lazyBs-> IO
22:55:33 <ivanm> so using >>= for it doesn't work
22:55:38 <ivanm> where's write?
22:55:41 <ivanm> you never mentioned write...
22:55:43 <monochrom> this is depressing
22:55:47 <ivanm> read >>= (write . decompress)
22:55:50 <ivanm> monochrom: what is?
22:55:54 <Balahla> fun is write curried wich path
22:56:13 <Balahla> so >>= give it just the bytestring
22:56:18 <monochrom> liftM decompress (readFile "i:\\gerar\\KMZ-File.kmz") >>= fun
22:56:31 <Balahla> What is liftM?
22:56:46 <monochrom> liftM is your solution. that's what it is.
22:56:51 <ivanm> @type liftM
22:56:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:56:54 <ivanm> @type fmap
22:56:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:56:56 <ivanm> ^^ take your pick
22:58:12 * hackagebot acid-state 0.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.3 (DavidHimmelstrup)
23:19:48 <qwebirc63912> Does anyone know if haskell-mode for Emacs is still maintained? The project site is now an empty directory.
23:22:20 <ivanm> qwebirc63912: yeah, it might not have been restored after the server moved
23:22:26 <ivanm> preflex: seen Baughn 
23:22:26 <preflex>  Baughn was last seen on #haskell 15 days, 15 hours, 55 minutes and 40 seconds ago, saying: Sadly, yes.
23:23:11 * lispy thinks it's time to go read some maths
23:23:27 <shachaf> lispy: What maths are you reading?
23:23:31 <lispy> 20 till midnight on a friday night, that's when you study math too right?
23:23:51 <lispy> shachaf: I was thinking of reading some lin alg
23:24:32 <qwebirc63912> Does anyony here use Vim to edit Haskell source code?
23:24:40 <shachaf> qwebirc63912: You can be sure of that.
23:24:52 <lispy> qwebirc63912: yes.  I use both haskell and emacs regularly to edit my haskell codes
23:25:00 <qwebirc63912> How do you deal with the indentation? There is no good indentation mode for Vim.
23:25:00 <lispy> heh, I meant vim and emacs
23:25:15 <lispy> indentation in Haskell for me equals 2 spaces
23:25:23 <lispy> I just type it or hit tab
23:25:32 <lispy> my tab key inserts 2 spaces, that is
23:26:17 <lispy> The emacs indentation modes are really obnoxious though.  They either assume they know how you should indent and then do it incorrectly or they don't help and you end up using spaces manually.
23:26:18 <qwebirc63912> I settled on shifting 4 spaces, but I end up with my own styling conventions that aren't "portable" when I try to use another editor.
23:26:49 <lispy> 4 spaces is too much, IMO
23:26:56 <lispy> 2 spaces is just right
23:27:47 <qwebirc63912> But with 2 spaces I'm tempted to following those rules where "where" is indented 2 spaces in, and then the lines below "where" are another 2 spaces in, etc ... and it just makes for a lot of work to get indentation right.
23:28:27 <qwebirc63912> And the lining up of the = and | in data types ... It's difficult to do that in Vim.
23:28:38 * thoughtpolice is finally porting the plugin patches for GHC to git
23:28:40 <lispy> I lineup things below where exactly with the where
23:28:52 <lispy> thoughtpolice: plugin patches?
23:29:10 <thoughtpolice> lispy: so GHC can load plugins dynmically for optimizations, etc.
23:29:15 <thoughtpolice> or even analysis
23:29:18 <thoughtpolice> (only for core atm)
23:29:43 <lispy> thoughtpolice: oh, you mean you had the patches in one representation, say darcs, and now you need them in git format?
23:31:21 <thoughtpolice> lispy: yeah, i've been meaning to do so. it was pretty simple
23:31:33 <thoughtpolice> 'darcs diff -u' to the rescue!
23:38:06 <Lemmih> @seen ksf
23:38:06 <lambdabot> Unknown command, try @list
23:38:06 <preflex>  ksf was last seen on #haskell-blah 8 hours and 2 minutes ago, saying: redd.it/gqthq
23:46:41 <Balahla> Hey guys. What's "*** Exception: Codec.Compression.Zlib: incorrect header check"?
23:47:17 <Balahla> Happens when I try to run this on the winghci:
23:47:27 <Balahla> fun = Data.ByteString.Lazy.writeFile "i:\\gerar\\KML-File.kml"
23:47:29 <MatrixFrog> which function threw that exception? sounds like it's trying to unzip something and it's not formatted like zlib-compressed data should be
23:47:34 <Balahla> liftM Codec.Compression.GZip.decompress (Data.ByteString.Lazy.readFile "i:\\gerar\\KMZ-File.kmz") >>= fun
23:49:40 <Balahla> I'm trying to unzip a KMZ file. 
23:49:55 <Balahla> Trying to get a KML file. 
23:52:09 <Balahla> Any ideas?
23:52:33 <Lemmih> Balahla: Are you sure the archive is valid?
23:53:32 <Balahla> It's a KMZ file that's run in Google Earth with no problem...
23:54:21 <Balahla> When I run unzip over it, I get the kml file.... And it works
23:55:26 <lispy> are you sure it's a Z archive?
23:55:53 <lispy> Is it possible that the z is some other compression that zlib doesn't understand?
23:56:43 <Balahla> A KMZ archive is a zipped KML archive plus some jpegs...
23:57:33 <Balahla> If one renames the *.kmz to *.zip. The unzip decompress it with no trouble.
23:58:30 <lispy> Balahla: is zlib the same as .zip?
23:59:34 <Balahla> I don't know... Is it not a standard format?
23:59:43 <Balahla> zip
