00:00:16 <vegai> I would claim that people for whom mathematics is easy will find Haskell easy
00:00:42 <seku> why so?
00:00:53 <_Ray_> and it's an iff save for a set of people of lebesgue measure 0
00:01:06 <vegai> see what I mean?
00:01:20 <vegai> they all talk like that
00:02:02 <vegai> but seriously, the concepts are often introduced in very much the same way as in mathematics
00:02:17 <vegai> and there's a strong mathematical basis, at least when compared to many other languages
00:02:47 <Kerris> If only Haskell had something like RStudio or VSLab
00:02:48 <_Ray_> you don't even need addition for php
00:02:57 <seku> i tried scheme but i didn't like all the ()-messiness, and i thought haskell looked like more fun ;)
00:03:04 <seku> and i don't know php, except for very little
00:03:10 <Cale> Functions in Haskell are proper mathematical functions unlike almost every other programming language ever ;)
00:03:17 <seku> just c, one day worth of scheme and python
00:03:18 <seku> :D
00:03:19 <Kerris> Cale: haha
00:03:29 <vegai> and variables! Don't forget variables!
00:03:41 <_Ray_> and one day you decide to ask ghc to give you the C it writes
00:03:47 <_Ray_> the horror. oh the humanity.
00:04:06 <vegai> and functors are functors. None of this "mappable" crap
00:04:10 <Kerris> in my meagre experience it's always better not to peak behind the scenes
00:04:10 <Nereid> :>
00:04:17 <Kerris> uh, peek
00:04:25 <Cale> The C backend is deprecated though
00:04:39 <_Ray_> ghc 7 is baaaarely out
00:04:41 <Kerris> Oh right, it's LLVM now.
00:05:04 <Cale> Well, there's a fancy LLVM backend, but there's also the native code generator
00:05:07 <Nereid> well sometimes you might want to, to figure out some performance things
00:05:10 <Cale> which has been around for a lot longer
00:05:15 <shachaf> @quote all.there.is
00:05:16 <lambdabot> xplat says: haskell is good for portability.  it can run well on any sort of x86 unix, which is all there is after all.
00:05:18 <_Ray_> native as in assembly?
00:05:22 <Nereid> I thought the LLVM backend produced faster code?
00:05:25 <Cale> mhm
00:05:28 <Nereid> _Ray_: yeah
00:05:38 <_Ray_> if the C was ugly, I can't imagine the assembly
00:05:50 <Kerris> Nereid: How much faster?
00:05:56 <Nereid> well it all depends
00:06:04 <_Ray_> the feeling I got when reading the C was "we're no longer in Kansas"
00:06:06 <seku> is someone doing embedded in haskell?
00:06:18 <Cale> seku: yes
00:06:32 <Nereid> Kerris: you can find things on google too
00:06:35 <seku> are there compilers for some cheap chips 
00:06:50 <Cale> seku: Haskell makes a great metalanguage for programming embedded systems, and for fancier things like smartphones, we're starting to use it directly.
00:06:55 <Kerris> Nereid: haha
00:07:21 <Cale> (I work for iPwn Studios which is a game company doing a game for iPhones and Android etc. in Haskell)
00:07:28 <thoughtpolice> _Ray_: the C backend has its share of problems, least of all being readable C code (the result has to be post-processed in a registered GHC build if you want it to work properly. this is not pretty.)
00:07:32 <seku> Cale: what do you mean by metalanguage? Write language in haskell?
00:07:38 <Kerris> Now that Lua and Python interpreters have been ported to the iOS, it's a matter of time until Haskell turns up :>
00:07:50 <thoughtpolice> but there's also the ordinary native code generator, which pretty-prints ASM that is compiled by gnu as, etc
00:07:53 <Cale> I mean writing Haskell programs which write the microcontroller code when run
00:07:56 <Nereid> seku: code that writes code
00:08:01 <seku> ah
00:08:14 <Cale> http://hackage.haskell.org/package/atom
00:08:19 <Cale> ^^ like that
00:08:38 <Kerris> so you can prove certain mathematical properties of the program? :V
00:08:39 <thoughtpolice> Nereid: the LLVM backend is faster sometimes. in general it's pretty close to the NCG, although LLVM can do better register allocation in some cases (yielding better loops, for example)
00:08:49 <ion> Haskell is one of the more powerful languages for DSLs thanks to the “do” sugar et al.
00:09:24 <thoughtpolice> the LLVM backend seems to really win on fusion-based/loop-y code, so libraries like vector, data-parallel haskell, etc all perform much better with it
00:09:37 <Cale> Atom is being used to write safeguard microcontroller code for some hybrid hydraulic systems iirc.
00:09:42 <Nereid> haskell syntax is pretty extensible, one could say
00:09:42 <Nereid> I guess
00:10:18 <ion> And laziness!
00:10:28 <Nereid> mmm laziness
00:10:34 <Nereid> and types
00:10:45 <_Ray_> haskell was the first language I learned in uni, that was fun
00:10:50 <Nereid> :>
00:10:54 <_Ray_> they figured it's an easy transition from pure math to programming
00:10:55 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56
00:10:58 <Cale> ^^
00:11:02 <Nereid> well, was it? ;)
00:11:19 <_Ray_> they removed first order functions from it, as well as all mention of typeclasses, but sure
00:11:26 <Cale> A presentation on using Haskell programs to generate hard-realtime code to control hydraulic systems :)
00:11:29 <Nereid> you mean higher-order functions?
00:11:29 <_Ray_> it was mostly to speak about recursion and the notion of "to compute"
00:11:35 <_Ray_> err, yeah, higher order
00:11:38 <_Ray_> brainfart
00:11:38 <Nereid> :P
00:13:34 <_Ray_> since I already knew how to program imperatively, I cowardly shied away from actual recursion
00:13:45 <_Ray_> so to compute, say, factorial, I added an extra parameter which I multiplied each time
00:14:00 <_Ray_> i.e. I made my functions tail recursive, so as to avoid thinking of what happened to "the stack"
00:14:22 <_Ray_> or to sum a list, I added a parameter starting at 0, instead of x + f xs :p
00:15:33 <_Ray_> I remember we were all dazed when we wanted to find a function that removed 1 occurance of each item in a list. so for [3, 5,4,1,4,1, 3, 3], we wanted to get [3, 4, 1, 3], in any order
00:15:36 <Cale> _Ray_: You also would have picked up that bias from strict functional programming
00:15:50 <_Ray_> and the solution was to check if x `elem` xs. if it wasn't, remove
00:15:53 <_Ray_> that was just... so hot.
00:16:21 <_Ray_> 2 fucking lines. I had already imagined code that transformed that list into a list of tuples, decreased the snd element of it, and transformed back
00:16:57 <_Ray_> the girl in our team who said it gained +5 sexyness at that point
00:17:42 <frerich> _Ray_: From my experience, you now got quite a few people in this channel trying to whip up a cool pointless solution to that problem so show you that it can be done Even Shorter(tm).
00:17:47 <shachaf> Cale: To be fair, foldl is used for sum in Haskell too.
00:18:13 <_Ray_> less than 2 lines? xP
00:18:23 <renormalized> @seen lambdabot
00:18:23 <lambdabot> Unknown command, try @list
00:18:23 <preflex>  lambdabot was last seen on #haskell 13 minutes and 8 seconds ago, saying: xplat says: haskell is good for portability.  it can run well on any sort of x86 unix, which is all there is after all.
00:18:52 <_Ray_> f [] = [], f x:xs | x `elem` xs = x:(f xs) |otherwise = f xs
00:19:13 <_Ray_> (we didn't really care about performance at that point)
00:19:19 <earthy> and rightly so. ;)
00:19:29 <_Ray_> it can surely be done in O(n log n) by sorting and removing duplicates in O(n)
00:20:02 <renormalized> @type map
00:20:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:20:39 <renormalized> ?src map
00:20:39 <lambdabot> map _ []     = []
00:20:39 <lambdabot> map f (x:xs) = f x : map f xs
00:20:45 <frerich> _Ray_: I think You could also use 'concatMap tail $ group $ sort [3,5,4,1,4,1,3,3]'
00:21:56 <_Ray_> nice :)
00:22:31 <_Ray_> you map tail over the [n, ..., n] and concatenate them all
00:22:42 <shachaf> Cale: Why was @seen removed from lambdabot?
00:24:01 <frerich> _Ray_: My idea was to use 'group' on the sorted list to get a list of lists of all equal numbers, so [3,5,4,1,4,1,3,3] becomes [[1,1],[3,3,3],[4,4],[5]] and then use the tail of each list and concatenate that.
00:24:09 <_Ray_> right, yeah
00:24:18 <_Ray_> I have to say the original is way simpler haha
00:25:00 <luite> _Ray_: a disadvantage of that version is that it doesn't work for many infinite lists
00:25:19 <frerich> _Ray_: Yes, it's simpler in the sense that you don't have to keep in mind how all the crazy stuff like group and sort and concatMap works. After a while, you just have it in your mind though.
00:25:32 <shachaf> luite: Does it work for any?
00:25:45 <luite> shachaf: yes, for cycle 1 for example
00:26:01 <luite> or is it repeat 1, I forgot :p
00:26:04 <luite> @type cycle
00:26:04 <lambdabot> forall a. [a] -> [a]
00:26:08 <luite> @type repeat
00:26:09 <lambdabot> forall a. a -> [a]
00:26:13 <luite> so repeat 1 :)
00:27:36 <shachaf> Oh, right.
00:27:39 <luite> but obviously it also works for cycle xs where xs is a finite list
00:30:36 <_Ray_> hrm. ghc 7 is taking almost 4 seconds to compile 1 relatively tiny .hs
00:39:10 <_Ray_> boo. no llvm backend for os x 64bits.
00:39:26 <Kerris> yet? :8
00:40:07 <_Ray_> so much bandwidth wasted :(
00:40:13 <_Ray_> well, not wasted.
00:40:23 <_Ray_> I still updated ghc. but bummer about no llvm.
00:42:35 <osfameron> @src filterM
00:42:35 <lambdabot> Source not found. Just try something else.
00:44:40 <Nereid> _Ray_: install linux problem solved
00:44:40 <Nereid> :P
00:44:45 <_Ray_> :p
00:45:04 <_Ray_> you do give me an idea though
00:45:07 <_Ray_> to the vps cave!
00:45:32 <shachaf> filterM foo xs = if unsafeCompareFunction foo (const [True,False]) then subsequences xs else undefined
00:46:37 <thoughtpolice> _Ray_: yeah, no LLVM for 64bit OS X saddens me too. i luckily have a linux machine to still use for that though. the LLVM backend needs to be fixed to work with position independent code (since -fPIC is the default on 64bit OS X)
00:46:38 <osfameron> unsafeCompareFunction ?
00:47:02 <osfameron> what's the const [True,False] doing there? that's the baffling definition for powersets that I'm looking at right now...
00:47:38 <shachaf> There are probably many explanations of this on the Internet, including #haskell logs.
00:48:16 <osfameron> guess so ;-)
00:50:16 <mm_freak> osfameron: for each element it's one time there and one time not
00:50:22 <mm_freak> look at the type of filterM
00:50:58 <mm_freak> it's the same as filter, but with a nondeterministic predicate
00:52:11 <_Ray_> Who's Oleg?
00:52:59 <mm_freak> osfameron: and if you want something even crazier, i can show you a foldM-based 'permutations' function ;)
00:53:18 <seku> hey hey... threading or multiprocessing in haskell. How does it happen?
00:53:36 <osfameron> mm_freak: let me get my head round the first one first ;-)
00:53:36 <Athas> Darn, apparently GHC support for Unicode is still really bad.
00:53:54 <mm_freak> _Ray_: the one brain of haskell…  i think he's the right half of SPJ's brain
00:53:54 <arcatan> _Ray_: Oleg Kiselyov is a computer scientist who has done quite a bit research related to Haskell and functional programming. His homepage: http://okmij.org/ftp/
00:54:17 <mm_freak> seku: actually quite straightforwardly…  for concurrency you create threads and use them
00:54:31 <mm_freak> seku: for paralellism you can use threads or pure constructs
00:54:42 <Nereid> Control.Parallel has stuff for evaluating things in paralle
00:54:44 <Nereid> l
00:55:02 <_Ray_> SPJ looks... scary. http://upload.wikimedia.org/wikipedia/commons/d/d0/Simon_Peyton_Jones_01.jpg
00:55:17 <seku> mm_freak: i imagine threading is easier in haskell ;)
00:55:40 <mm_freak> _Ray_: look at his videos…  he's a funny guy actually
00:55:53 <mm_freak> seku: than in …?
00:56:18 <seku> dunno. Thinking aloud in some general way.
00:56:43 <mm_freak> well, it is easier than in every referentially nontransparent language
00:57:06 <seku> i don't know what that means, but i assume it means the threads don't tamper with each other's state
00:57:09 <seku> :D
00:57:13 <mm_freak> and STM is very reachable in haskell…  i take STM for granted
00:57:26 <mm_freak> in every other language i'd probably throw up
00:57:57 <mm_freak> no, "referentially transparent" = what people usually call "pure"
00:59:36 <seku> i suspect conventional languages won't be keeping up when core numbers go up ;) Or at least programmers wont
01:00:13 <mm_freak> in fact, in haskell threading threads can well tamper with the state of other threads, for example via STM, but generally that's not what haskell programmers would call "state"
01:01:43 <mm_freak> well, other languages are trying to keep up, but i think haskell is the perfect compromise between abstraction and speed =)
01:02:17 <thoughtpolice> well, the key to really scaling in a good fashion is always to avoid sharing state, particularly avoiding write sharing amongst cores (your performance drops like a rock then.) you can always keep up if you can do this, it's just a question of how easy the language makes it
01:02:58 <thoughtpolice> you definitely won't be keeping up with the increasing # of cores using lots of STM; it is the antithesis to doing that, because you're sharing state. STM just helps make sure you share the state in a correct, deadlock-free manner.
01:03:48 <thoughtpolice> STM is great in particular, if you have lots of concurrency going on, and you only need to rarely share state via writes. the amount of time keeping up with transactions/logs will be dwarfed by parallel computation, provided the amount of sharing is small
01:03:54 <mm_freak> depends on the application…  servers naturally need to share a lot of data between threads, but as long as this is mostly read sharing, that's fine
01:04:57 <mm_freak> probably worse for an IRC server than for a webserver, of course
01:06:02 <thoughtpolice> mm_freak: i actually wonder what the overhead is for STM reads, for a TVar that's very rarely written
01:07:01 <mm_freak> thoughtpolice: if you want to go for speed, you should not use a TVar for this
01:07:19 <thoughtpolice> oh of course, i was just speculating what the actual read-overhead is
01:07:40 <mm_freak> probably comparable to MVar
01:07:58 <quicksilver> should be much less.
01:08:08 <quicksilver> MVars are protected by locks, TVars are not.
01:08:25 <quicksilver> reading a TVar is just a simple pointer read plus recording the access in the transaction log.
01:08:38 <quicksilver> the question is how you amortize the cost of the commit check.
01:08:52 <quicksilver> (because that really does depend what else happens in the transaction)
01:09:08 <seku> a web server is too easy of an example. Each client can be just a thread of their own. How about a computer game?
01:09:09 <mm_freak> quicksilver: yes, and in the end you get MVar performance
01:09:12 <mm_freak> i measured it
01:09:35 <mm_freak> seku: that's a very naive web server
01:09:59 <quicksilver> mm_freak: "in the end" depends very much on your transaction profile.
01:10:01 <Blkt> good day everyone
01:10:07 <seku> mm_freak: apache :D
01:10:24 <quicksilver> mm_freak: I am pretty sure TVars will be much much cheaper than MVars for certain transactional loads (and slower for others)
01:10:46 <mm_freak> quicksilver: i agree…  i had only one TVar in a transaction
01:10:48 <carpi> http://pastebin.com/4Z4et5EW It does not make sense. THe first 4 lines compile without a problem. But the last 4 lines give me an error "parse error on input `listl'
01:11:11 <mm_freak> quicksilver: i measured how expensive STM is for a task, which MVars can solve just as well
01:11:23 <mm_freak> and the expense was the same…  almost exactly the same
01:11:45 <mm_freak> seku: apache is not a good example, i think
01:11:58 <carpi> and they are practically the same with just the names of bindings changed in both instances
01:12:00 <mm_freak> seku: have a look at the better performing HTTPds like nginx
01:13:09 <quicksilver> carpi: your indentation is wrong in the second example
01:13:38 <Nereid> carpi: all of the 'listl's have to line up
01:14:08 <carpi> Nereid: they are lined up
01:14:10 <Nereid> btw: instead of [x] and xs, you can write [_] and _
01:14:13 <Nereid> no they aren't 
01:14:26 <Nereid> carpi: you have hard tabs in your source
01:14:30 <Nereid> a tab character is counted as 8 spaces by haskell
01:14:38 <Nereid> if your tab stop is set to something different, you have a problem
01:14:59 <Nereid> (also read http://urchin.earth.li/~ian/style/haskell.html )
01:15:06 <carpi> im using notepad++ with a tab width of 4. and they are converted to spaces anyways
01:15:33 <Nereid> but they evidently aren't
01:15:38 <mm_freak> carpi: can be all well and good, but in the source code you pasted the indentation is wrong, and there is no other error
01:15:39 <Nereid> because the first character of line 11 is a tab
01:16:37 <quicksilver> Nereid: are you sure it's a tab? in my browser line 11 seems to start with 8 spaces.
01:16:46 <quicksilver> anyhow, it's certainly true that the indentation is wrong, and that's the problem.
01:16:47 <Nereid> look at the raw paste data
01:16:55 <quicksilver> Nereid: oh.
01:17:03 <quicksilver> pastebin convertes tabs to spaces in the paste area
01:17:05 <quicksilver> how stupid?
01:17:18 <Nereid> why not?
01:17:23 <mauke> pastebin.com is basically made of fail
01:17:24 <quicksilver> well because it confused me :)
01:17:33 <Nereid> well, you should use hpaste anyway
01:17:59 <Entroacceptor> and you should use spaces in your code anyway, too
01:18:46 * Nereid is happy that vim will actually display tab characters in a special way
01:19:08 <mm_freak> it's not wrong to use tabs, if you do it consistently, but that's an art of its own
01:19:25 <mauke> set lcs=tab:»­,trail:·,eol:¶,nbsp:⎵,precedes:←,extends:→ sbr=↪
01:19:37 <Nereid> :>
01:19:48 * shachaf prefers trail:☢
01:19:49 <Nereid> I don't have anything long like that, just tab:>-,trail:-
01:19:53 <Nereid> haha
01:19:56 <Kerris> lol
01:19:57 <mm_freak> haskell syntax well supports tab indentation, where you don't have to worry about tab size
01:20:03 <Entroacceptor> what is trail?
01:20:09 <shachaf> Trailing whitespace.
01:20:30 <Nereid> well, trailing spaces
01:20:30 <Entroacceptor> at the end of a line? ah..
01:20:35 <Nereid> yeah
01:20:38 <Entroacceptor> *copies*
01:20:45 <Nereid> don't forget to :set list too
01:20:49 <carpi> i thinkk youre right.. cos when i copy and paste from the original version.. the 2nd line is one tab deficiet
01:20:51 <mm_freak> emacs just sets them with a different background color
01:20:56 <Entroacceptor> of course :)
01:21:08 <mauke> some syntax files highlight trailing spaces as errors
01:21:19 <mauke> at least that's what C mode does
01:21:20 <mm_freak> they are errors
01:21:28 <mm_freak> people just don't realize =)
01:21:51 <Entroacceptor> maybe just errors that haven't happened yet
01:21:56 <Kerris> waste of precious bits
01:21:57 <mauke> I only use list mode on special occasions
01:22:17 <mm_freak> Kerris: no, space is cheap
01:22:21 <mm_freak> that's not the problem
01:22:24 <shachaf> Kerris: Want some of my bits?
01:22:39 <Kerris> shachaf: I can only handle 512!
01:22:46 <mm_freak> it makes editing more difficult, because when editing source code as a real text editor user you make certain assumptions
01:22:51 <mm_freak> and trailing spaces break those
01:22:56 <shachaf> Kerris: What are you, a cache line?
01:23:08 <Kerris> ;-)
01:23:15 <carpi> Nereid: okay now it compiles without errors. but i had to rewrite teh whole thing.. (
01:23:33 <mm_freak> teh whole thing!
01:23:56 <mm_freak> carpi: why not just reindent?
01:24:04 <Nereid> carpi: you only had to fix the indentation on line 11
01:24:07 <roconnor> did we ever figure out what Harper meant by the sums/products thing?
01:24:19 <Kerris> Reindent + Strip Whitespace
01:24:55 <Kerris> It's like a nervous tic. I hotkey those whenever I save.
01:25:38 <carpi> Nereid: i tried that .. but it wouldn't work. 
01:25:43 <carpi> so i just rewrote it whole
01:26:02 <mm_freak> Kerris: ever worked together with NetBeans/Eclipse programmers?
01:26:47 <Kerris> mm_freak: I AM ONE.
01:26:47 <Kerris> </SHYAMALAN>
01:27:00 * Kerris coughs.
01:27:18 <mm_freak> i mean the typical one
01:27:22 <Kerris> No?
01:27:30 <mm_freak> who doesn't even know what "trailing whitespace" is
01:28:05 <Kerris> … I … what … I find it hard to believe that there are programmers who don't know what "trailing whitespace" is.
01:28:12 <mm_freak> every line contains it, EVEN EMPTY LINES!
01:28:16 <mm_freak> they indent empty lines
01:28:36 <seku> their editors do
01:29:35 <mm_freak> they could delete the space…  or just configure their editor properly
01:30:01 <seku> can you do that in eclipse or <insert_ide_name_here>?
01:30:04 <mm_freak> but every second nonempty line also contains trailing whitespace (so much to type, i will just call it satan from now on)
01:30:35 <Entroacceptor> eclipse actually has cool editor features
01:30:41 <mm_freak> well, in visual studio you can do it
01:30:49 <mm_freak> never used eclipse (seriously) myself
01:30:58 <mm_freak> not to mention netbeans
01:31:20 <rostayob> In persistent, is ther any way to select values by data type constructor?
01:31:49 <Kerris> I'm pretty sure NetBeans has shipped with "Source > Remove Trailing Spaces" since at least three years ago :|
01:32:05 <mm_freak> rostayob: what do you mean?  persistent is very data type oriented
01:32:31 <mm_freak> Kerris: people don't use it, because they don't understand what satan is
01:32:39 <mm_freak> their editor doesn't highlight satan
01:32:51 <Kerris> haha
01:33:06 <rostayob> mm_freak: let's see I've got a field of something data type I use with persistent that's like data Foo = FooString String | FooInt Int, I want to select all the items that contain a FooString
01:33:09 <Kerris> that's a bit … extreme, but I can see where you're coming from
01:33:14 <mm_freak> because their editor doesn't even have the advanced text editing features, which satan disrups
01:33:17 <mm_freak> disrupts
01:33:31 <mauke> :%s/\s\+
01:33:49 <mauke> er, I mean :%s/\s\+$
01:33:53 <eevar> http://hpaste.org/46051/utf8light -- I'm having some compiler issues (I think). Suggestions?
01:33:59 <mm_freak> rostayob: if that can't be inferred, you'll have to use a type signature
01:34:10 <eevar> already tried compiling through fllvm instead, no change
01:34:11 <mm_freak> rostayob: select ([] :: Filter Foo) …
01:34:13 <seku> mauke: + autocommand on bufwrite
01:35:11 <Kerris> mm_freak: are you referring to Vim/Emacs?
01:35:46 <mm_freak> Kerris: yes
01:36:41 <_Ray_> flebron@linode:~/ghc-7.0.3$ uname -a
01:36:42 <_Ray_> Linux linode 2.6.32.16-linode28 #1 SMP Sun Jul 25 21:32:42 UTC 2010 i686 GNU/Linux
01:36:42 <_Ray_> flebron@linode:~/ghc-7.0.3$ ghc -V
01:36:42 <_Ray_> The Glorious Glasgow Haskell Compilation System, version 7.0.3
01:36:50 <_Ray_> Who needs proper OS X llvm support :)
01:37:46 <Kerris> :( I should devote more effort into Emacs. It's the #1 reason why I can't get into CTMCP :(
01:38:37 <Kerris> I take that back. My laziness is the #1 reason why I can't get into CTMCP.
01:38:52 <rostayob> mm_freak: yeah but that would select all the ones with type Foo, right?
01:45:08 * hackagebot safecopy 0.5.1 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.5.1 (DavidHimmelstrup)
01:45:10 * hackagebot DimensionalHash 0.0 - 2 and 3 dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.0 (GhassenHamrouni)
01:47:16 <mm_freak> rostayob: all the ones in the Foo table, whatever that is in your persistent model
01:48:44 <carpi> in a list by default ... if there is more than one predicate.. they are "anded"... am i correct? is there a way to do an "or". Like for instance in the line "[ x | x <- [1..999], mod x 3 == 0, mod x 5 == 0]" it returns only numbers that are multiples of both 3 and 5.. but I would like it to return numbers that are multiples of either 3 OR 5. Is that possible?
01:49:18 <rostayob> mm_freak: no wait: Foo is a field in some other datatype
01:49:49 <Peaker_> carpi: in a list *comprehension* the predicates are guards, so anded. You can just use || between them
01:49:56 <Peaker_> carpi, [ x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
01:50:07 <Peaker_> > [ x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
01:50:08 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
01:51:15 <carpi> thank you 
01:51:20 <rostayob> mm_freak: it's like in this example: http://www.yesodweb.com/book/persistent#custom-field , but in that example we can simply use equality on Employment constructors
01:51:27 <Nereid> > filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..]
01:51:28 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
01:53:09 * hackagebot hslua 0.3.3 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.3 (GracjanPolak)
01:53:45 <Peaker_> > filter (\x -> (x `mod`) `any` [3, 5]) [1..]
01:53:46 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
01:53:46 <lambdabot>    arising from a use of ...
01:54:57 <Nereid> >filter (\x -> (0 ==) . mod x `any` [3,5]) [1..]
01:55:02 <Nereid> > filter (\x -> (0 ==) . mod x `any` [3,5]) [1..]
01:55:03 <lambdabot>   Precedence parsing error
01:55:04 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.List.any...
01:55:07 <Nereid> boop
01:55:12 <Nereid> > filter (\x -> ((0 ==) . mod x) `any` [3,5]) [1..]
01:55:19 <lambdabot>   mueval: ExitFailure 1
01:55:19 <lambdabot>  mueval-core: Time limit exceeded
01:55:22 <Nereid> ehh, now what
01:55:50 <Peaker_> I've never used/seen any as infix before, it seems nice
01:55:50 <Peaker_> > filter (\x -> ((0 ==) . mod x) `any` [3,5]) [1..]
01:55:51 <Nereid> > filter (\x -> (\y -> x `mod` y == 0) `any` [3,5]) [1..]
01:55:52 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
01:55:52 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
01:56:08 <Nereid> oh, I wasn't wrong
01:56:09 <Nereid> just bug
01:56:16 <Peaker_> Time limit often hit due to quirkiness
01:56:41 <Nereid> :t divides
01:56:42 <lambdabot> Not in scope: `divides'
01:59:17 <Nereid> > let { merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = case compare x y of { LT -> x : merge xs (y:ys); GT -> y : merge (x:xs) ys; EQ -> x : merge xs ys } } in merge (map (3*) [1..]) (map (5*) [1..])
01:59:18 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
01:59:21 <Nereid> :/
01:59:57 <Nereid> yeah that's awful
02:01:40 <Nereid> > let { merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = case compare x y of { LT -> x : merge xs (y:ys); GT -> y : merge (x:xs) ys; EQ -> x : merge xs ys } } in foldr merge [] (map \n -> map (n*) [0..]) [5, 7, 11]
02:01:41 <lambdabot>   <no location info>: parse error on input `\'
02:02:11 <Nereid> > let { merge xs [] = xs; merge [] ys = ys; merge (x:xs) (y:ys) = case compare x y of { LT -> x : merge xs (y:ys); GT -> y : merge (x:xs) ys; EQ -> x : merge xs ys } } in foldr merge [] (map (\n -> map (n*) [0..]) [5, 7, 11])
02:02:12 <lambdabot>   [0,5,7,10,11,14,15,20,21,22,25,28,30,33,35,40,42,44,45,49,50,55,56,60,63,65...
02:02:41 <Nereid> bored
02:02:43 <ion> > let divides = (0 ==) .: mod in filter (flip any [3,5] . divides) [1..]
02:02:44 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
02:02:57 <Nereid> @type (.:)
02:02:58 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
02:03:10 <Nereid> heh
02:03:20 <mm_freak> rostayob: if you use a filter or ordering in persistent, then the result entity type must be clear
02:03:29 <ion> (f . g) a = f (g a)
02:03:33 <ion> (f .: g) a b = f (g a b)
02:03:33 <Peaker_> @type (liftA2 . liftA2)
02:03:34 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
02:03:39 <Nereid> yes I realize that.
02:04:01 <Nereid> well, f .: g = (f .) . g
02:04:04 <Nereid> or something
02:06:20 <rostayob> mm_freak: oh ok, that's what I wanted to know.
02:06:35 <Peaker_> nice how Functor and Applicative compose so smoothly.. sad how Monad doesn't...
02:07:01 <Nereid> that's what distributive laws are for
02:07:54 <ion> What do you mean by monad not composing smoothly?
02:07:55 <Peaker_> but Monads like State, for example, just won't compose without altering them to StateT
02:08:10 <Nereid> ion: even if m and n are monads, m . n may not be
02:08:14 <ion> Ah, that kind of composing
02:08:21 <Nereid> however: http://en.wikipedia.org/wiki/Distributive_law_between_monads
02:08:35 <osfameron> State doesn't allow composition with <=< ?
02:08:45 <Nereid> osfameron: not that kind of composition
02:09:12 * hackagebot fuzzytime 0.7.4 - A clock and timer that tell the time in a more human way  http://hackage.haskell.org/package/fuzzytime-0.7.4 (KamilStachowski)
02:09:20 <Nereid> for example, any monad trivially distributes over itself
02:09:26 <Nereid> that's pretty trivial I guess
02:10:29 <osfameron> as in [1,2,3] -> [[1],[2],[3]] ?
02:10:36 <Nereid> nnnnooooo
02:10:51 <Nereid> osfameron: say m and n are monads
02:11:00 <Nereid> define (m `o` n) a = m (n a)
02:11:17 <Nereid> well, m `o` n is nicely a functor, or even applicative
02:11:24 <Nereid> but you can't make it a monad, in general
02:12:03 <Nereid> in order to, you have to have some function n (m a) -> m (n a)
02:12:15 <Nereid> which satisfies some laws
02:12:30 <osfameron> ah
02:12:31 <Nereid> which the wiki link describes
02:18:03 <PeakerWork> Nereid: not sure how the distributive laws help us...  We need to rewrite State into StateT so it can compose with other monads...
02:18:20 <Nereid> I don't think we're trying to accomplish the same thing
02:19:01 <Nereid> maybe monad transformers can be described by some distributive law though
02:19:24 <PeakerWork> I want to be able to get (>>=) or join for e.g: State (Maybe a), rather than rewriting the  (s -> (s, a)) to (s -> m (s, a))
02:19:29 <Nereid> aha, they are
02:19:33 <Nereid> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=84
02:20:00 <PeakerWork> ContT m a  seems to just be a different instance on the same structure of  Cont (m a)
02:20:24 <PeakerWork> But for StateT we modify the structure -- I wonder what systematic way can figure out where to place the "m"s
02:20:34 <Nereid> hmm
02:20:46 <Nereid> "The State monad transformer is not explained by any of the canonical adjunctions splitting the monad, but by the currying/uncurrying adjunction characterizing exponentials:"
02:20:48 <Nereid> so it can be done.
02:21:08 <PeakerWork> I don't really know CT beyond that which is implied by knowing Haskell's typeclasses :-)
02:21:39 <Nereid> well
02:21:41 <Nereid> in short:
02:21:49 <Nereid> distributive laws can be used to make monad transformers
02:22:15 <Nereid> and that post gives some articles of the distributive laws needed to make some existing monad transformers
02:22:21 <Nereid> some examples*
02:28:23 <mm_freak> PeakerWork: myMonadicValue :: (Alternative m, StateMonad m) => m Result
02:28:27 <Nereid> ah http://www.informatik.uni-bremen.de/~cxl/papers/icfp02.pdf
02:28:39 <Nereid> "Composing Monads Using Coproducts"
02:29:01 <Nereid> I take it that's the coproduct in the category of monads
02:29:13 <Nereid> mmm yep
02:29:34 <PeakerWork> but you can't compose "State" without first modifying its internal structure -- so unless we have an automated structure-modifying language (e.g: Disciple) to automate this, it is hard to say there's any technique to compose *existing*  monads
02:29:53 <PeakerWork> usually composition implies not modifying internal representation - but taking whole units and piecing them together
02:30:07 <mm_freak> PeakerWork: why would you use/define State in the first place to then extend it?
02:30:16 <mm_freak> i would define StateT and make a special case State
02:30:28 <mm_freak> type State s = StateT s Identity
02:30:33 <Nereid> indeed, that's what many do
02:30:39 <Nereid> I hoep you mean StateT Identity s
02:30:51 <mm_freak> no, StateT s Identity
02:30:53 <Nereid> hope
02:30:57 <Nereid> no.
02:31:15 <Nereid> go look at the definition of StateT
02:31:17 <Nereid> wait
02:31:21 <Nereid> well
02:31:24 * Nereid just looked :>
02:31:31 <Nereid> ah right.
02:31:33 <Nereid> right right.
02:32:06 <mm_freak> actually, my StateT rather looks like:  StateT r s m a
02:32:14 <Nereid> what's r?
02:32:20 <mm_freak> so State r s = StateT r s Identity
02:32:39 <mm_freak> the final result type of a CPS-transformed monad
02:32:47 <Nereid> mmmmmmmgfioihjti
02:33:04 <mm_freak> ContT is the CPS-transformed variant of IdT
02:33:29 <mm_freak> newtype ContT r m a = ContT ((a -> m r) -> m r)
02:33:37 <Nereid> wow, look at diagram (8) on page 10 of that article
02:33:41 <Nereid> :|
02:37:27 <Nereid> I will have to sit down and read that article at some point.
03:15:25 <tarrasch> I've just updated my Cabal Library to 1.8.0.4. I don't intend to update cabal-install right away. But my problem is that cabal-install uses the old Cabal library on my system, which is 1.8.0.2. Is there any way to tell cabal-install to use my newly installed Cabal Library, I installed it under ~/.cabal/lib/Cabal-1.8.0.4 
03:16:06 <dcoutts> tarrasch: yes, either you rebuild cabal-install against that version, or you tell it on the commandline with --cabal-lib-version=1.8.0.4
03:20:48 <tarrasch> dcoutts, hooray, it worked. Thanks! :)
03:25:07 <aleator> Can I hide instance declarations in imports somehow
03:27:48 <roconnor> aleator: sadly no
03:42:38 <ManateeLazyCat> Hi all. :)
03:42:38 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
04:01:33 <deteego> does anyone here use haskellmode for vim, and know if its possible to make haskellmode open up haddock documentation within vim (instead of an external browser?)
04:12:16 <earthy> that'd be tricky
04:12:34 <earthy> and not The Vim Way. :)
04:15:48 <deteego> earthy: my way is the vim way :)
04:21:10 <parcs> hmm, looks like Data.ByteString.Char8.readFile doesn't work in a /proc filesystem due to its use of hFileSize…
04:23:17 <roconnor> polynomials are stupid.
04:23:36 <roconnor> >:(
04:24:04 <parcs> @hoogle bracket
04:24:05 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:24:05 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:24:05 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:30:17 <vav> deteego: never tried, but you might be able to use http://vim.sourceforge.net/scripts/script.php?script_id=1053 html viewer vim script and change haddock_browser to somehow use it
04:31:02 <deteego> vav: yeah thats what I was thinking, just didn't know if there was a way for it to work with gvim
04:31:05 <deteego> vav: hmmm
04:31:29 <vav> should be some nasty vimscript to make it work :/
04:49:47 <crystal-cola> woyuld it be possible to use haskell to explain category theory concepts?
04:49:59 <crystal-cola> functors.. yes.. but what else?
04:52:18 <hpc> monads, monoids, groups?
04:52:20 <hpc> um
04:52:41 <hpc> categories themselves, though Cale explained the other day that they have some shortcomings in Haskell
05:00:26 <Philonous> Someone should add to the TH docs that "()" is technically the type of 0-tuples. 
05:03:24 <lispy> good morning, #haskell!
05:03:24 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
05:07:04 * hackagebot SafeSemaphore 0.7.0 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.7.0 (ChrisKuklewicz)
05:11:36 <seku> http://urchin.earth.li/~ian/style/haskell.html tells to use space to indent, but it doesn't say how much one should indent... eight?
05:11:49 <hpc> seku: indent enough to be readable
05:12:20 <hpc> i personally do layout-indentation, and two spaces when it would be pathologically wide
05:13:24 <c_wraith> 8 is too much, basically always.
05:14:05 <hpc> i think it's the reason they made tabs so wide
05:14:10 <seku> so basically all editors can translate spaces to indentation someone prefers
05:14:13 <hpc> to deliberately make it untennably hard to use
05:16:06 <c_wraith> I use tibbe's indentation rules, which are basically "4 spaces, except for the where keyword on its own line, which is indented 2 spaces, and the next line is indented another 2 spaces"
05:18:03 <whald> hm, could somone please take me by the hand and aid me in creating my first monad transformer stack? the stack is already in place (kind of) but i don't see how to use it
05:18:21 <c_wraith> also, be aware that due to block rules, sometimes you indent other amounts, because that's what's required.
05:18:30 <crystal-cola> whald: it's easy then you just need to find the things with the right type
05:18:57 <parcs> what's the point of -f-warn-unused-do-bind? i don't really see a situation where one would benefit from this warning
05:19:40 <Botje> whald: can you put what you have on a pastebot?
05:19:48 <whald> crystal-cola: these things hide well... 
05:20:02 <magicman> parcs: I believe that's mostly because when you don't use the result of sequence, mapM, replicateM, etc, the sequence_, mapM_, replicateM_ functions are more efficient.
05:20:04 <lispy> parcs: Yeah.  The original bug reporter who caused that feature to get implemented had a concrete case but they are rare.
05:20:04 <crystal-cola> whald: it should be like instead of runReader, runReaderT
05:20:07 <whald> Botje: it's on google code, the problem is here: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Sampling.hs#45
05:20:15 <crystal-cola> whald: so find all the relevant ones and figure out how to compose them all
05:20:38 <lispy> magicman, parcs: So those are more efficient, but the reason for that warning has more to do with correctness originally
05:21:06 <whald> Botje: and i have my own version of MonadRandom (because i want to use mwc-random which does not provide a RandomGen instance), which is here: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Random.hs
05:21:12 <magicman> lispy: Ooh, hadn't heard that one before. Now I'm wondering about that as well >_<
05:21:26 <lispy> magicman: in the sense that with C you really should always check the return value of a function and IIRC the motivating example was something using the FFI
05:21:33 <parcs> lispy: interesting
05:21:52 <magicman> Right...
05:22:15 <Botje> whald: you seem to have that rnd' function already written
05:23:00 <whald> Botje: but GHC doesn't like it
05:23:36 <whald> Botje: Sampling.hs:49:10: Couldn't match type `Sample' with `Sampled Sample'
05:25:15 <Botje> whald: that liftM looks weird
05:25:42 <Botje> do r1d <- rnd1D `liftM` ask; if ...
05:26:07 <lispy> magicman, parcs: I think it's a nice optional warning, but I don't think it's one that should be enabled by -Wall and I think if you search the cabal packages on hackage that have been uploaded since it became available you'd find lots of people disable it.
05:27:09 <c_wraith> ...  there are warnings not enabled by -Wall?
05:27:20 <c_wraith> doesn't that make "all" a lie?
05:27:22 <lispy> c_wraith: I think so
05:27:28 <whald> Botje: thanks! only half of my problems remain
05:27:40 <Botje> yay
05:27:41 <lispy> c_wraith: that's the case with gcc for sure, but I think it may apply to ghc also
05:27:56 <lispy> c_wraith: I think of -Wall as "all standard" warnings
05:27:58 <Botje> are the other problems also related?
05:28:01 <whald> Botje: on the last line, the "rnd" is from the Random module and gives a "Rand Float"
05:28:25 <whald> from what i've read a "lift" would allow me to get the "Sampled Float" i need
05:28:59 <whald> Botje: but all i get are type errors, either lift is not the right tool or i'm using it foolish
05:29:16 <Jafet> c_wraith: gcc has a -Wextra
05:29:40 <Botje> i think lift should work, yes
05:29:50 <Botje> what error do you get then?
05:32:01 <lispy> there should be a -Wcake 
05:32:06 <whald> Botje: i tried both, (lift . rnd) and just (lift rnd) which give expected `Sampled Float' <-> actual type `a0 -> c0` and expected `Sampled Float' <->actual type `t0 m0 a0', respectively 
05:32:09 <lispy> then the cake could be a lie
05:32:55 <Jafet> Though I feel that ghc's -Wall is something like gcc's -Wall -Wextra
05:33:05 <whald> Botje: oh, and the "rnd" alone gives expected "Sampled Float" <-> actual "Rand Float" (which at least makes sense to me)
05:33:45 <c_wraith> is Sampled a type alias?
05:33:51 <zygoloid> lispy: -Wcake would replace all warnings with 'what are you doing?' or 'i don't think you're doing what you think you're doing'?
05:33:53 <cch> may I remove a module in ghci ?
05:34:02 <zygoloid> cch: :m -Module
05:34:10 <whald> c_wraith: it's a newtype : http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Sampling.hs#40
05:34:12 <cch> oh 3x
05:34:16 <cch> thanx
05:34:41 <c_wraith> whald: in that case, I don't think lift does what you want.  It's explicitly :: m a -> t m a
05:35:30 <whald> c_wraith: well, at least that's what i always thought: "how would putting another monad in front of it make anything better?"
05:35:42 <c_wraith> ah. you want this:  (Sampled (lift rnd))
05:35:49 <lispy> zygoloid: -Wcake: Fun with Science!
05:36:07 <lispy> zygoloid: just spit out lots of GladOS quotes
05:36:40 <whald> c_wraith: wow, thanks a lot! may i ask: why? i never saw this construct in a tutorial. or i'm blind
05:37:03 <c_wraith> It's just applying the newtype wrapper to the lifted value
05:37:10 <c_wraith> To make the type checker happy :)
05:38:14 <whald> c_wraith: ok, i'll play with it for some more weeks an see if i finally get a "feeling" for this kind of things. thanks a lot so far, Botje too.
05:38:36 <roconnor> does the following equation hold in SML? (`fst . h` = `f`  ∧ `snd . h` = `g`) ⇔ `f &&& g` = `h`
05:38:58 <cch> may I add a module in ghci as qualified one?
05:39:00 <c_wraith> rnd :: Rand Float, which implies lift rnd ::  ReaderT Sample Rand Float, which implies Sampled (lift rnd) :: Sampled Float
05:39:10 <c_wraith> cch: depends on your version of ghc
05:39:23 <cch> c_wraith: I use 6.12
05:39:33 <c_wraith> cch: then no.  That wasn't added until ghc 7
05:39:43 <cch> c_wraith: thanks
05:39:59 <c_wraith> cch: you can create a module that's just a list of imports, and :load it, though
05:40:29 <cch> c_wraith: ok, that would be fine
05:40:38 <roconnor> ah right, if h throws an error, we have that f &&& g = h but we might have that  fst . h != f since f might succeed
05:40:54 <whald> c_wraith: ahh! basically the "runS" type shows up again there. that was enlightening, thanks again!
05:41:13 <c_wraith> whald: you're welcome
05:42:11 <zygoloid> lispy: maybe the best thing would be to document it but not implement it :)
06:07:56 <roconnor> ezyang: I think I found a pair of sum/product equations, one of which holds in only in ML, and the other of which only holds in Miranda: http://www.reddit.com/r/programming/comments/gwqa2/the_real_point_of_laziness/c1r2cyz?context=3
06:08:46 <roconnor> ezyang: Though I still don't understand the point since if Harper isn't using denotational semantics how can he do equational reasoning at all!
06:10:59 <deteego> oh and another thing regarding haskellmode in vim, is it normal for the cache that haskellmode generators to be deleted everytime you quit vim?
06:11:45 <deteego> sorry its not exactly being deleted, but it isn't being autoloaded
06:12:16 <hpc> load it in .vimrc?
06:12:34 <deteego> hpc: what command would that be?
06:12:55 <hpc> dunno
06:12:58 <hpc> but i assume there is one
06:24:31 <vav> deteego: did you ExportDocIndex or just DocIndex? I only reindex after major changes, an Export... should persist
06:24:56 <deteego> vav: I just used docindex
06:25:20 <vav> deteego: ExportDocIndex and the cache will get saved. in ~ by default iirc
06:25:28 <deteego> vav: thanks
06:25:36 <deteego> vav: whats the command to update the cache?
06:26:12 <vav> deteego: DocIndex, or if it doesn't exist Export*dex will do both
06:27:31 <vav> deteego: you can add paths to your .ghc to use with :make, too. Once :make a file you can get types and insert them and imports etc. even if that's not indexed
06:28:17 <deteego> vav: wait what exactly do I set ExportDocIndex to in my vimrc?
06:28:59 <deteego> vav: or is it just a set?
06:29:03 <vav> deteego: you run it from within vim to populate and save cache of all the haddocks on the system
06:30:08 <vav> deteego: gtg, sorry, but there's quite a bit of useful stuff in :help haskellmode and on the project home page
06:30:15 <deteego> vav: ok thanks
07:09:12 <LYY_> ??
07:09:32 <LYY_> 台灣人在哪裡
07:09:43 <Kerris> haha
07:10:00 <Kerris> "where are the Taiwanese"
07:10:06 <Kerris> that's a strange bot
07:10:29 <ion> Quite close to China
07:10:42 <Jafet> Which China?
07:11:17 <FUZxxl> LYY_: 你是臺灣人嗎？
07:11:42 <Zao> FUZxxl: He's gone. From the network.
07:11:45 <endojelly> 日本人はどこですか
07:11:45 <Kerris> FUZxxl: let it go, he's dead and gone
07:11:46 <FUZxxl> ah.
07:11:47 <Kerris> :v
07:14:26 <jonkri> can someone please tell me where the run*T functions are defined? i only see the newtype declaration which defines its type
07:14:52 <zygoloid> jonkri: that defines the function too.
07:14:52 <quicksilver> jonkri: the newtype declaration is also defining the function.
07:15:19 <zygoloid> when you define a record type R, you implicitly get accessors for every field :: R -> FieldType
07:15:37 <Jafet> Hm, the listings on Haskellers, CUFP and FJ are nearly blank
07:15:42 <zygoloid> "record type" is a term i made up for ADTs with record constructors
07:17:07 <Jafet> Or a term borrowed from languages with record types
07:17:34 <Twey> Haha
07:22:49 <beastaugh> <Jafet> Hm, the listings on Haskellers, CUFP and FJ are nearly blank
07:23:00 <beastaugh> I think if you want to write Haskell commercially you need to start your own company
07:23:58 <quicksilver> or work for somewhere which doesn't care which language you write in as long as you solve the problem.
07:25:01 <beastaugh> the problem with that is that "the problem" usually involves "maintaining the code that solves the problem for the next five years once you've left the company"
07:26:53 <quicksilver> sure
07:27:03 <beastaugh> which is not unreasonable, even if the hurdle to maintenance (i.e. learning a new language and toolchain) is far lower than managers and executives usually believe
07:27:11 <quicksilver> but that didn't generally stop people writing code in perl and tcl and tk and cobol and shell script and ....
07:27:47 * osfameron is writing a prototype of (a small feature of) our live codebase in haskell
07:27:49 <quicksilver> my point is, there certainly are organisations in which you can persuade your manager to let you solve a problem in haskell
07:27:57 <quicksilver> and if it works well, you can probably expect to do more of it
07:27:58 <osfameron> if it turns out useful for prototyping, I might get to work on it in parallel
07:28:02 <quicksilver> but you won't see that on the job advert.
07:28:05 <osfameron> but pushing it live... feels like a long way off
07:28:32 <osfameron> (especially as I barely know haskell, and the language doesn't really reward brute force programming that my tiny brain can cope with...)
07:28:41 <lispy> I had a manager once tell me, "No more Haskell.  It's a weird language and my manager doesn't like it."
07:28:50 <lispy> I don't work for that company any more.
07:29:10 <Jafet> No more weird managers?
07:29:11 <osfameron> do you write haskell for dayjob now then?
07:29:18 <lispy> osfameron: yes I do
07:29:20 <osfameron> quicksilver: do you write both perl and haskell for yours?
07:29:33 <quicksilver> osfameron: no. I manage people and answer emails.
07:29:40 <osfameron> quicksilver: ah ;-)
07:30:31 <lispy> One thing to remember, even at a Haskell shop you'll write non-Haskell code, you'll read non-Haskell code, you'll  debug non-Haskell code.  The key is to work somewhere with a good culture and smart people.
07:30:56 <lispy> The right tool for the job is even better than using Haskell for that job.
07:31:09 <lispy> Unless, Haskell is the right tool (as it often is)
07:31:37 <Kerris> well said
07:33:32 <lispy> As an example, for something I'm doing right now at work the reference implementation is Haskell for the client and server but I need a java version of the client so I'm porting the Haskell code to Java
07:34:01 <lispy> Writing it once in Haskell was really nice, but expecting Java to talk to Haskell is kind of unrealistic
07:34:17 <osfameron> why?
07:34:34 <osfameron> I mean, can't you write libraries in haskell?
07:35:01 <carpi> can someone please give me a hint as to how i can write a function to output the fibonacci series infinitely?
07:35:02 <lispy> Yes, we have it in Haskell as a library already.  The issue I'm referring to would be the linkage between Java/Haskell.
07:35:06 <Jafet> Write a Haskell interpreter in Java!
07:35:21 <carpi> like a pointer in the right direction..
07:35:31 <Entroacceptor> Jafet: and get the worst of both worlds!
07:35:35 <beastaugh> do you find Haskell particularly good for reference versions?
07:35:47 <Jafet> @google haskellwiki fibonacci numbers
07:35:49 <lambdabot> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
07:35:49 <osfameron> lispy: I mean libraries that can be called from C etc.?
07:35:49 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
07:36:01 <c_wraith> carpi: don't think of it in terms of a function.  Just think of it as a list that contains all fibonacci numbers.
07:36:06 <beastaugh> I mean, on the one hand it's very expressive, but on the other the semantics are pretty distant from those of, say, an imperative language like Java
07:36:11 <lispy> osfameron: yeah, it is possible for Java and Haskell to talk, see jvm-bridge for example
07:36:12 <Jafet> osfameron: then you just move the pain to JNI.
07:36:26 <Axman6> carpi: haskell is best known for having about a billion difderent ways to do exactly that
07:36:28 <Jafet> beastaugh: whose semantics might not agree with your application's anyway
07:36:40 <Kerris> Well, there was Lambada
07:36:57 <osfameron> lispy, Jafet: so it's just that doing it that way would be more pain and future maintenance?
07:36:58 <Jafet> @quote undoubtedly
07:36:58 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
07:37:02 <carpi> i tried to write a function that would produce the series infinitely.. but i get it wrong.. somehow
07:37:11 <carpi> haskel is way too  different
07:37:15 <c_wraith> carpi: forget "function"
07:37:16 <carpi> in a good way ofcourse
07:37:27 <c_wraith> carpi: just write fibs :: [Integer]
07:38:08 <Axman6> > let fibs = f 0 1 where f !x !y = x : f y (x+y) in fibs
07:38:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:38:14 <Axman6> > let fibs = f 0 1 where f !x !y = x : f y (x+y) in fibs !! 10000
07:38:15 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
07:38:17 <Axman6> > let fibs = f 0 1 where f !x !y = x : f y (x+y) in fibs !! 100000
07:38:18 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
07:38:26 <Jafet> I don't know; it's not my pain
07:38:44 <carpi> i know what my problem is. i don't understand half the syntax.
07:38:50 <beastaugh> I always quite admired the Fibonacci zipWith one-liner
07:38:52 <lispy> osfameron: Yeah and I would want to hand a Java developer an API that is implemented in Haskell.  I'd rather hand a Java developer a pure Java implementation.
07:39:02 <carpi> just managed to cover paterns, guards and the likes
07:39:20 <osfameron> carpi: heh, yeah, it takes a while to get familiar with all of that
07:40:09 <int-e> > fix ((0:) . scanl (+) 1) -- is it that time of the year again?
07:40:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:40:23 <Jafet> It's that time, every time!
07:40:40 <ezyang> I'm doing heap profiling, but the cost centers all have truncated names. Can I make GHC give me more detailed info? 
07:41:12 <lispy> ezyang: where are the truncated names appearing?  In a pdf or in the .prof file?
07:41:17 <ezyang> the .hp file. 
07:41:50 <lispy> ezyang: I seem to recall asking about this and I want to say, someone said the length is hard coded somewhere but it's very vague in my memory
07:42:06 <ezyang> Hmm, I guess I'll have to manually at cost centers. 
07:42:14 <ezyang> *add 
07:42:53 <zygoloid> ezyang: your haskell heap cartoon thing is great :)
07:45:13 <FLiX> ()
07:53:19 <ezyang> How strict is IntMap.insert? 
07:53:45 <ezyang> I know it's lazy w.r.t. the value, but how about the structure of the map? 
07:54:26 <lispy> ezyang: I suspect that's a sufficiently difficult question that you'll have to investigate on your own :(
07:54:35 <ezyang> OK :-( 
07:54:51 <lispy> I doubt anyone knows of the top of their head, but maybe?  ddarius might now something random like that
07:55:38 <ezyang> That implies that this question isn't the cause of my space leakage problems 
07:55:47 <ezyang> :-) 
07:55:50 <Younder> The only language I know that got inheritance right is Axiom
07:55:56 <monochrom> "data IntMap a = Nil | Tip !xxx a | Bin !xxx !xxx !xxx !xxx" is pretty strict
07:56:15 <ezyang> Ah yes, that does look fairly strict. 
07:56:22 <lispy> Yeah, it does
07:56:26 <Younder> You must inherit algebra and restrictions like in topology , not just names
07:56:28 <monochrom> there are also a couple of UNPACKs
07:56:38 <ezyang> (I was looking at the insert function and not seeing any seqs and being confused...) 
07:56:52 <quicksilver> ezyang: pretty sure it's completely spine-strict.
07:57:01 <ezyang> OK, this is kind of curious. Let's see if fold is strict, then... 
07:57:11 <Younder> modules like IntMap suffer from the same weak type theory
07:57:15 <quicksilver> or structure-strict or whatever you call it.
07:57:33 <Jafet> Map is spine-strict as well
07:57:41 <lispy> Younder: What are you talking about?
07:57:43 <ezyang> Buh. Why isn't foldlStrict exported... 
07:57:53 <Jafet> data Map k a  = Tip | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
07:58:28 <quicksilver> Jafet: map is spine-strict because the size-balancing forces all the structure all the time. IntMap isn't quite the same but I think the answer is the same.
08:00:40 <Jafet> It could be avoided by always having top-level bins, I guess
08:00:48 <Jafet> With dubious utility
08:01:39 <ezyang> I guess I'll just make a new checkout. 
08:02:00 <quicksilver> structurally-lazy trees are only useful in certain quite special-purpose circumstances I think.
08:02:14 <quicksilver> like the MemoTrie trick.
08:04:55 <Younder> Structurally lazy trees are the only real functional alternative to hashes
08:06:30 <crystal-cola> aren't hashes like almost always the rwrong thing to use?
08:06:37 <crystal-cola> it's just there's "second best" at a whole load of things
08:06:54 <crystal-cola> hash tables
08:07:37 <Axman6> in haskell they are
08:07:47 <Axman6> in plenty of other languages they prove quite useful
08:08:50 <Axman6> thought Johan Tibell's recent work shows a lot of promise uing hashes in haskell
08:09:29 <Axman6> using hash table like things*
08:10:34 <ezyang> Using -hc, I've got two very suspicious call centers that are probably leaking. Unfortunately, when I look at them, I don't "see" the leak. What should I do next to get more information? 
08:13:11 <jonkri> can someone please explain the line "Just y -> runMaybeT (f y)" in http://book.realworldhaskell.org/read/monad-transformers.html? what does runMaybeT do in that context? also, how does MaybeT $ runMaybeT ... work?
08:13:38 <crystal-cola> so does calculus get used in haskell?
08:13:43 <crystal-cola> Other than differentating data types
08:13:48 <crystal-cola> I mean like integrals and stuff 
08:13:55 <ezyang> I guess it's time to reread RWH's chapter on the topic. 
08:14:06 <Lemmih> jonkri: Do you know the type of 'runMaybeT'?
08:14:18 <jonkri> Lemmih, yes, runMaybeT :: m (Maybe a)
08:14:33 <jonkri> perhaps there's something with the record syntax that i don't understand?
08:14:39 <Lemmih> jonkri: That's not the right type.
08:14:42 <ezyang> No, that's not correct. 
08:14:42 <laika> trying to install leksah on ubuntu 10.10. following these instructions: http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html, cabal install leksah fails unfortunately.
08:14:44 <ezyang> Oh, I see! 
08:14:52 <ezyang> You've gotten confused with how the record syntax works :-) 
08:15:11 <laika> dependencies (cabal, ghc) cannot be met
08:15:15 <ezyang> If I do data A = A { field :: Something }, field is a function of type :: A -> Something 
08:15:22 <ezyang> so... 
08:15:24 <ezyang> :t runStateT 
08:15:25 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
08:15:37 <ezyang> erm 
08:15:41 <ezyang> :t runMaybeT 
08:15:42 <lambdabot> Not in scope: `runMaybeT'
08:15:47 <ezyang> sigh 
08:15:55 <monochrom> runMaybeT :: MaybeT m a -> m (Maybe a)
08:16:10 <monochrom> (it's so much faster to enter by hand! :) )
08:16:15 <jonkri> :)
08:16:52 <monochrom> runMaybeT strips away the MaybeT data constructor. runMaybeT (MaybeT blah) = blah
08:18:18 <monochrom> so presumably f y evaluates to MaybeT blah, and you want to extract the blah
08:19:00 <ezyang> Hmm, I guess I don't /actually/ want heap profiling, I want a time/allocation profiling report. 
08:21:22 <lpeterse> Does someone know whether there is a possility for raising compile time errors. I think about catching invalid strings for certain instances of IsString.
08:23:01 <laika> any idea how to best install the latest leksah under ubuntu 10.10?
08:24:53 <jonkri> ezyang, monochrom: i finally got it :) thanks
08:27:32 <Jafet> lpeterse: maybe preprocess them with TH
08:28:52 <jonkri> i'm thinking a little bit about haskell in industry. in your experience, how long does it take someone with strong knowledge in for example c to learn haskell, including being able to create monads and other relatively advanced data types?
08:29:01 <Lemmih> laika: cabal install doesn't do it?
08:29:20 <ezyang> We find that we frequently need to "unteach" strong imperative programmers certain concepts, when teaching FP languages. 
08:29:46 <laika> i get unresolved dependencies when trying to cabal install leksah
08:29:47 <physicist> i want to install yi but yi depends on yi, so what do I do?
08:29:48 <laika> There is no available version of ghc that satisfies >=7.0 && <7.2
08:29:58 <Jafet> "Anyone could learn Lisp in one day, except that if they already knew Fortran, it would take three days." ~ Minsky
08:30:01 <jonkri> ezyang, interesting
08:30:10 <jonkri> Jafet, :)
08:30:30 <monochrom> @quote monochrom unlearning
08:30:30 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
08:30:30 <Jafet> If you understand the existing monads and other relatively advanced data types, you should have no trouble using them or creating them
08:31:10 <jonkri> Jafet, so how long would you say that it takes, in some kind of average situation?
08:31:21 <Jafet> ...as long as it takes?
08:31:30 <Jafet> I certainly wouldn't try to learn Haskell on a deadline
08:32:04 <lpeterse> jafet: good idea, I'll have a look at it. does it allow me to stop the compiling process?
08:32:33 <laika> how to best install the haskell platform under ubuntu? i just realised i only have 6.12, tried sudo apt-get install haskell-platform i think
08:32:46 <laika> that might solve my leksah issues :-)
08:32:47 <jonkri> of course, me neither. but i think the answer is interesting... assume that you learn it at an convenient pace that is not completely unrealistic from your employer's perspective
08:33:14 <Jafet> @instances Monad
08:33:14 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
08:33:37 <jonkri> i do think it will take longer than most other languages, but i suspect some of you may disagree
08:33:44 <Jafet> This list just about covers everything you would do with Monad
08:34:01 * Jafet wonders what ArrowMonad is, though
08:34:24 <jonkri> thanks
08:34:49 <quicksilver> Jafet: it's the monad instance for an arrow which satisfies ArrowApply
08:35:02 <int-e> ;5~newtype ArrowApply a => ArrowMonad a b = ArrowMonad (a () b)
08:36:27 <int-e> pretty much what you'd expect: an action is an arrow that maps the unit to a result. thanks to ArrowApply, you can implement bind, while return is covered as  arr . const
08:38:40 <Jafet> lpeterse: see TH.report, etc.
08:39:31 <physicist> ghc-7.0.3 requires directory ==1.0.1.2 however
08:39:32 <physicist> directory-1.0.1.2 was excluded because ghc-7.0.3 requires directory ==1.1.0.0 How to make sense of it
08:40:44 <int-e> @type \f g -> f >>> (arr (\a -> arr (const ()) >>> g a) &&& arr id) >>> app
08:40:45 <lambdabot> forall a b (cat :: * -> * -> *) c. (ArrowApply cat) => cat a b -> (b -> cat () c) -> cat a c
08:40:47 <lispy> physicist: this is  why and when you switch to cabal-dev (possibly after removing your per-user pkg db)
08:42:12 <physicist> lispy: don't get you. Please explain
08:43:07 <lispy> physicist: there is a tool build on top of cabal-install called cabal-dev.  This tool implements sandboxing.  So that when you cd ~/foo; cabal-dev install; everything gets installed in ~/foo in a completely sandboxed way
08:43:28 <lispy> physicist: this prevents weird situations where you install 2 versions of directory on top of your ghc install
08:43:47 <lpeterse> jafet: thanks, I alread started reading
08:44:13 <physicist> k
08:46:02 <shapr> Yay! #haskell's ten year birthday is almost here!
08:46:27 <shapr> -ChanServ- Registered : Apr 30 22:22:56 2001 (9 years, 51 weeks, 5 days, 17:43:42 ago)
08:46:34 <lispy> wow!
08:46:45 <ezyang> Amazing! 
08:46:53 <crystal-cola> hey guys I have written my progam: 
08:46:56 <crystal-cola> mapM_ (\n -> do putStr (show n) ; putStr " " ; putStrLn (show ((`mod`n)$(2^n)))) [1..100]
08:47:04 <lispy> shapr: I didn't realize I've been there that long.  I think I started here in 2003 or 2004.
08:47:07 * Jafet breaks out the -Wcake.
08:47:12 <crystal-cola> any way to make it into a file rather than the command line?
08:47:15 <lispy> Jafet: hehe
08:47:30 <Jafet> crystal-cola: see System.IO
08:47:44 <Jafet> Or your shell's manual...
08:48:07 <shapr> lispy: that's a long time!
08:54:49 <monochrom> the british royal wedding will be held to commemorate the 10th anniversary of #haskell
08:56:09 <shapr> monochrom: hah
08:57:21 <jonkri> does this type make sense for a monad transformer that should wrap a state (XMPPState s)? newtype XMPPT s m a = XMPPT (StateT (XMPPState s -> IO ((), XMPPState s)) m a)
08:57:46 <jonkri> the internal state calculations never yield a result, it's just a state loop
08:58:10 <shapr> jonkri: What are you writing?
08:58:44 <jonkri> should i have a "runXMPPT" record function instead?
08:59:06 <jonkri> shapr, an xmpp library. http://www.pontarius.org/projects/pontarius-xmpp/
09:03:01 <whald> :t withSystemRandom save
09:03:02 <lambdabot> Not in scope: `withSystemRandom'
09:03:02 <lambdabot> Not in scope: `save'
09:06:13 * hackagebot chalmers-lava2000 1.1.2 - Hardware description library  http://hackage.haskell.org/package/chalmers-lava2000-1.1.2 (EmilAxelsson)
09:08:14 <crystal-cola> > map (\n->(2^n)`mod`n) [1..100]
09:08:14 <lambdabot>   [0,0,2,0,2,4,2,0,8,4,2,4,2,4,8,0,2,10,2,16,8,4,2,16,7,4,26,16,2,4,2,0,8,4,1...
09:08:19 <crystal-cola> can you turn that into a recurrence relation?
09:10:15 <Jafet> Doesn't look like one
09:12:03 <monochrom> r (n+1) = (r n * 2) `mod` 100
09:19:48 <Lemmih> Neat, my copy of LYAH arrived.
09:25:20 <lispy> Lemmih: yay!
09:29:15 <edwardk> lemmih: its cute. i think the pictures work better in web form though.
09:31:15 * hackagebot th-expand-syns 0.2.0.0 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.2.0.0 (DanielSchuessler)
09:32:05 <jonkri> is it just me, or are the monadic run* field/function names confusing?
09:32:29 <zygoloid> they make sense once you're used to them, imo
09:32:36 <Mkman> Lemmih: my copy also arrived today :P
09:32:54 <jonkri> ok, good :)
09:33:27 <monochrom> everything makes sense after getting used to
09:33:51 <luite> edwardk: you also get the color pictures with the pdf version
09:34:17 <edwardk> luite: ah
09:34:20 <c_wraith> jonkri: almost all the run* functions, especially for monadic computations, actually don't do anything.  They're just accessors.
09:34:32 <monochrom> I prefer unStateT to runStateT, for example
09:34:33 <luite> edwardk: works great on tablets :)
09:34:45 <jonkri> hehe ok
09:34:48 <edwardk> luite: ah good point, i'll throw it on the ipad
09:37:17 * hackagebot th-expand-syns 0.3.0.0 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.3.0.0 (DanielSchuessler)
09:38:21 <ezyang> heap profiling takes too long :-( 
09:40:01 <laika> if i first installed ghc6 and straight afterwards ghc7, how would i go about making ghc7 my default?
09:40:45 <jonkri> i'm thinking about creating an xmpp library which basically works through callbacks, each callback carrying an arbitrary client state, and returns a possibly modified state to the xmpp library. there is one xmpp thread, and the same thread is running the xmpp client's callback functions. does it sound like is should have one monad (XMPP) or two monads (one internal to the xmpp library, and one like a State monad for the client)?
09:41:40 <jonkri> we basically deal with two states here, where one state should contain the other
09:42:55 <crystal-cola> Wherer is the fast modular exponentiation?
09:43:17 <crystal-cola> expmod :: Integer -> Integer -> Integer -> Integer
09:44:04 <luite> is there a standard one in a package?
09:46:44 <luite> crystal-cola: looks like there is one (not exported) in the RSA package
09:47:18 <crystal-cola> thanks
09:47:45 <tarrasch> laika, It happened automagically for me, but usually these 'works for me' answers aren't that useful maybe :p
09:48:25 <stroan> Is cabal broken for everyone with GHC 7.0.3, had to jump through a lot of hoops to get network installed and cabal updated
09:48:45 <dcoutts> nope, you'll have to explain
09:48:49 <laika> if i type in 'ghci' it starts ghc6
09:49:38 <Jafet> It's in gmp, which you can't use unless you build ghc with integer-simple
09:50:49 <stroan> installed ghc 7.0.3, and the newest platform. did cabal install cabal-install, and got this http://trac.haskell.org/network/ticket/38 Ended up hacing to resolve some deps manually without cabal to get everything up and running. Just wondering, since that was reported in 7.0.2, guessed it would have been fixed for 7.0.3
09:51:58 <xaphan> Is there any dependency issues that would cause runghc to do nothing but ghc to compile things fine?
09:52:28 <dcoutts> stroan: sounds like you're using an older cabal program rather than the one that came with the version of the Haskell Platform you're using.
09:52:32 <laika> how do i tell my system to use ghc7 by default now?
09:52:40 <scree> laika: what system you on?
09:52:41 <laika> shall i rename folders? 
09:52:43 <laika> ubuntu
09:52:50 <dcoutts> stroan: also, since you're using the HP, you already have the network package, so you probably do not need to upgrade it.
09:53:08 <scree> laika: I think you just want to manage the /usr/bin/ghc symlinks
09:53:09 <laika> ghc6 sits inside ghc folders, whereas ghc7 sits in ghc7 folders
09:53:29 <stroan> ah, it's all fixed now on my machine
09:53:42 <stroan> I've installed GHC enough times that it wasn't really a bother.
09:53:56 <stroan> but just wondering if it was my environment that was messed up
09:54:08 <dcoutts> stroan: I think the answer was yes :-)
09:54:10 <laika> how do i change the symlinks?
09:54:16 <stroan> well, that's actually a good answer :)
09:54:45 <stroan> toying with deploying some systems in haskell in work, and if I had to explain that the ecosystem was broken that'd be the end of that :P
09:54:47 <crystal-cola> so i have writen [ x | a <- [1..100], b <- [1..100], f a b, ... ]
09:54:56 <crystal-cola> but how can I make it go on to the next a as soon as any b works?
09:54:57 <scree> laika: run something like "rm /usr/bin/ghc; ln -s /usr/bin/ghc-7* /usr/bin/ghc" as root, and then repeat for ghci, ghc-pkg
09:55:16 <scree> laika: you might want to check "ls -la /usr/bin/ghc" first
09:55:24 <laika> cool. would that help with the libraries too?
09:55:33 <scree> laika: how do you mean?
09:55:51 <laika> /usr/lib ...
09:56:04 <laika> but presumably that isn't important
09:56:11 <laika> for using ghc
09:56:20 <scree> laika: those should all be versioned anyway; on my system there's no /usr/lib/ghc
09:56:35 <scree> laika: so, I think the right ghc should link to the right libs &c.
09:56:51 <scree> laika: ofc, if you haven't run ghc-updater you should do so
09:57:20 <scree> s/ghc-updater/haskell-updater
09:58:01 <laika> sorry, what do i type into the terminal? s/ghc-updater...?
09:58:33 <scree> laika: ha, sorry.  I meant, it's called "haskell-updater", not "ghc-updater" as I originally said
09:59:05 <shapr> SyntaxNinja: thanks for being the initiator behind cabal and hackage! I really enjoy using them!
09:59:10 <laika> and i run that? my system does not know the command
09:59:26 <scree> laika: it's on hackage I think
09:59:44 <scree> laika: I'd get your ghc working, then cabal install and run haskell-updater
10:00:11 <SyntaxNinja> shapr: heh no problem! It was fun :)
10:00:13 <scree> laika: hang on, ignore that, I think it's gentoo only
10:00:25 <SyntaxNinja> shapr: how have you been?
10:00:45 <shapr> SyntaxNinja: Doing webdev with Python, but I'll be doing software tests with Haskell!
10:00:57 <laika> possible to cabal uninstall now?
10:01:01 <laika> as i won't need the package?
10:01:15 <shapr> SyntaxNinja: Going back to school full-time soon, I'm slowly approaching completion of my CS degree. How have you been? Tried mountain unicycling? :-)
10:01:48 * dcoutts recommends mountain unicycling
10:01:54 <scree> laika: don't think so
10:03:30 <SyntaxNinja> shapr: no, still haven't tried mountain unicycling, but I always admire the folks who I see doing it! YOu should come out here nad do a race.
10:03:42 <SyntaxNinja> shapr: been focusing more on road cycling lately.
10:03:54 <SyntaxNinja> shapr: I'm doing a master's degree in cybersecurity too.
10:06:45 <laika> cheers, scree, symlinks all fine now :-)
10:13:15 <shapr> SyntaxNinja: that's awesome!
10:13:23 * hackagebot DimensionalHash 0.1 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1 (GhassenHamrouni)
10:13:25 * hackagebot cereal 0.3.3.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.3.0 (TrevorElliott)
10:15:13 * arcatan is thinking of getting an unicycle for the summer
10:17:05 <SyntaxNinja> hackagebot: You shouldn't let TrevorElliott upload stuff. he's trouble ;)
10:17:40 * olsner would like to be able to unicycle
10:20:00 <byorgey> olsner: well, nothing is stopping you except your lack of ability ;)
10:21:57 <jaspervdj> edwardk: Hi there!
10:24:56 <olsner> byorgey: if that ability could be so kind as to suddenly reveal itself I'd be very happy :P
10:25:05 <byorgey> heh
10:25:06 <olsner> alas it has not... yet
10:26:04 <byorgey> well, take heart, all the best unicycle riders got to be the way they are by just sitting around and suddenly one day being endowed with the ability to be awesome unicycle riders
10:26:15 <byorgey> at least I assume that's how it happened
10:26:20 <olsner> exactly!
10:26:27 <olsner> so there is hope :)
10:26:31 <byorgey> indeed =)
10:27:00 <olsner> otoh, I assume there's a lot of people who never have the ability appear within their lifetime
10:27:13 <olsner> otherwise everyone'd be unicycling everywhere
10:27:19 <byorgey> well, you'll just have to find a way to live longer then
10:27:24 * hackagebot DimensionalHash 0.1.1 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.1 (GhassenHamrouni)
10:37:27 * hackagebot aws 0.0.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.0.3 (AristidBreitkreuz)
11:06:09 * gwern makes predictions about this year's summer of code: http://www.gwern.net/Haskell%20Summer%20of%20Code.html#predicting-2011-results
11:07:14 <shapr> gwern: Makes me want to market HaskellNet again .
11:07:30 <gwern> shapr: hey, it's not *my* fault it failed... don't shoot the messenger
11:07:32 <shapr> HaskellNet was fine, but my life was such that I dropped out of the community.
11:07:46 <shapr> gwern: Oh, not blaming you or sending any negative vibes your way :-)
11:07:53 <shapr> gwern: I think this sort of retrospective is very valuable.
11:08:05 <lispy> HaskellNet?
11:08:06 <gwern> ruffles lots of feathers though
11:08:38 <shapr> gwern: like I said, valuable :-) people get in ruts sometimes
11:08:57 <shapr> lispy: Jun Mukai wrote a big bunch of awesome protocol implementations and called 'em HaskellNet.
11:09:12 <lispy> gwern: Actually, for the opengl one there is a very real problem that the existing binding is no longer being accepted to the HP.  But, the student this summer should be able to correct those shortcomings.
11:09:41 <gwern> lispy: hm? why would his binding be in the HP and the existing one not be?
11:09:50 <shapr> wait what?
11:10:47 <lispy> gwern: because we plan to address the issues that are keeping the current binding from being accepted.  An older binding was accepted but then changes were made that resulted in the HP not upgrading.
11:11:09 <gwern> that's kind of vague... your entire first sentence tells me no new information
11:11:26 <lispy> gwern: do you want a link to a bug tracker?
11:11:31 <gwern> sure
11:11:51 * gwern doesn't discriminate. bugtracker, wiki, email page - they're all equal before God
11:12:14 <lispy> gwern: here are some of the problems that need fix'n, but not all of them: https://github.com/haskell-opengl/OpenGL/issues/1
11:13:12 <gwern> I saw the discussion on -cafe of StateVar which struck me as a tempest in a teapot; if it's a useful monad thing but really short, stick it in some monad-related package
11:13:23 <lispy> gwern: I'm still negotiating with the libraries@ list to come to a consensus.  The gsoc student will of course do more than just satisfy the HP requirements.  There are other issues about the current model that suck.
11:13:40 <gwern> and I don't see how 'Get GLURaw and OpenGLRaw into the haskell platform' disables the existing opengl  but would help a new simplified opengl'
11:14:19 <lispy> gwern: the *Raw packages are dependencies of both the new simplified and the existing.  The HP policy clearly states that for a package to be in the HP so must it's dependencies.
11:14:56 <gwern> ok, so that is an irrelevant point then, which only leaves the StateVar issue in your link
11:15:39 <twobitsprite> !paste
11:15:40 <lispy> It's not totally irrelevant, but I don't think getting the *Raw stuff into the HP will be the responsibility of the student
11:16:29 <twobitsprite> http://pastebin.com/WynTZV1s
11:16:41 <twobitsprite> how is this a non-exhaustive pattern?
11:16:53 <lispy> gwern: anyway, this student's binding will be the next release of the opengl binding.
11:17:20 <byorgey> twobitsprite: it cannot handle the case of the second argument being an empty list
11:17:40 <jmcarthur> a version of divMod that i think actually implements the division algorithm has fewer operations than divMod, which does not implement the division algorithm... why is divMod written as is, then?
11:17:41 <twobitsprite> ohh, you mean if it's given an empty list to begin with... of course...
11:17:57 <jmcarthur> (my question would be answered if my function is incorrect, of course)
11:18:01 <twobitsprite> I was thinking "but it'll never get there, because the (c:[]) pattern will catch it".... but it doesn't know that 
11:18:18 <jmcarthur> (well, and if it was shown that a correct implementation must be slower than the existing divMod)
11:19:22 <lispy> gwern: Is your post meant to give people constructive feedback to increase the likelihood of success?
11:19:30 <shapr> It looks that way to me.
11:20:07 <gwern> lispy: yes, hence the examining all cases, enunciating commonalities between successful projects, and evaluating future ones according to the principles/commonalities and making predictions
11:20:08 <shapr> The conclusion I gather is that marketing is nearly as important as implementation.
11:20:36 <lispy> gwern: You should get involved sooner then.
11:20:53 <jmcarthur> my divMod function and the original: http://hpaste.org/46060/division_algorithm
11:20:57 <Jafet> jmcarthur: my guess is C99.
11:20:57 <lispy> gwern: declaring that a project that is now accepted will fail seems to undermine your intention of being constructive
11:21:14 <jmcarthur> Jafet: C's integer division is quotRem, isn't it?
11:21:31 <gwern> lispy: I did, when I publicized it back in january or so while people were still mulling projects, and pointing out the long list of proposed projects (at the end) which I had delivered my opinions on their worthiness
11:21:41 <gwern> lispy: and the year before that, and the year before that too I think
11:21:57 <gwern> and linked it on the hawiki page
11:22:15 <byorgey> twobitsprite: right, in particular if 'cards' is empty in a call to 'pull'
11:22:18 <Jafet> Oh, you're talking about the algorithm, not the results
11:22:24 <jmcarthur> the results too
11:22:30 <byorgey> twobitsprite: note, that error means your program actually crashed because that case happened
11:22:32 <gwern> lispy: not sure what more I could do other than stalk possible students and email them ranting about how to pick SoC projects
11:22:35 <jmcarthur> both quotRem and divMod fail to implement the division algorithm
11:22:51 <byorgey> twobitsprite: it's not that the compiler figured out that there are some cases not covered (although it can do that too if you turn on warnings)
11:22:58 <lispy> gwern: Then you're not posting in the right places.  I didn't notice this go by on reddit (although, I don't look at it daily) or the haskell.org gsoc mentors list
11:23:05 <shapr> gwern: Can you put more specific conclusions on that page?
11:23:34 <jmcarthur> a blog post i found on the matter http://cdsmith.wordpress.com/2007/06/02/learning-number-theory-and-haskell-the-division-algorithm/
11:23:48 <gwern> shapr: more specific? in what sense? there are numbers all over it, countless examples and casestudies etc
11:23:50 <jmcarthur> it has a different implementation of the "real" division algorithm than i do, though
11:24:05 <lispy> gwern: I'm not convinced you understand the state of opengl in the haskell world from your criticisms.  For instance, there are people who do find the current binding hard to use and confusing because it deviates too much from OpenGL nomenclature/api.
11:24:23 <shapr> You've pointed out the flaws, can you come up with specific suggestions for improvement?
11:24:33 <gwern> lispy: and at the margin, has it stopped anyone from writing programs using opengl?
11:25:26 <shapr> For example, "There are several ways to keep from underestimating the size of a project. One good GSoC approach is to write a tiny barely working prototype in the first two weeks."
11:25:28 <jmcarthur> IMO, OpenGLRaw would be ideal if it just had a few simple changes to make it more efficient, convenient, and idiomatic. for example, dropping the gl prefixes (you can use qualified imports if you want), adding rewrite rules over realToFrac for the gl types, etc.
11:25:42 <lispy> gwern: It almost stopped me in 2005.  Instead of actually using the api I starting writing example programs to document how it was similar/dissimilar actual opengl.  So for me, yes that has been the case.  It's very hard to prove a negative though so I don't have good numbers on that.
11:25:49 <gwern> shapr: that's a good suggestion, but by that point the SoC has been accepted has it not?
11:25:50 <Zao> I wish that someone would just make a decent FFI to DirectX instead.
11:26:09 <Zao> I tried, but diverged into the depths of how to automate bindings :D
11:26:13 <shapr> gwern: Just because an idea has been accepted doesn't mean it's immutable :-)
11:26:15 <gwern> shapr: also, offhand I don't know of anyone doing that so how would I know that helped?
11:26:45 <tarrasch> Zao, I have a friend who want to improve the OpenGL FFI. in case that intrests you
11:27:10 <lispy> tarrasch: there is a gsoc student who will be working on it this summer :)
11:27:15 <shapr> gwern: When communicating with people on the subject of negative results, a good strategy is to give concrete options for improvement.
11:27:45 <tarrasch> lispy, yes, he wanted to do it for google summer of code
11:27:59 <tarrasch> maybe we think of the same person ^^
11:28:22 <shapr> gwern: I think The Pragmatic Programmer had it as "in case of 'the dog ate my homework', give options, not excuses" though that's not a perfectly matching case.
11:28:31 <lispy> gwern: if you're going to spend this much time and effort analyzing proposals I think you should get involved on the mentoring team so you can rate proposals and give feedback.
11:28:37 <lispy> tarrasch: pastorn?
11:28:40 <tarrasch> pastorn, yes
11:28:56 <jmcarthur> heh
11:29:00 <tarrasch> I'm a friend of him irl
11:29:05 <lispy> nice
11:29:32 <gwern> shapr: yes, but I don't know how to improve the process; I have no idea who selects SoCs, what their thinking is, or how things could be imporved besides the observations I make as I see how SoCs succeed and fail and my predictions are borne out or falsified
11:29:37 <shapr> gwern: Points two and three appear to share a great deal of substance. Clear use can be communicated with tutorials and demonstrations, which can also serve as propaganda.
11:30:06 <shapr> gwern: Have you checked with the haskell.org people most involved in the process?
11:30:09 <gwern> shapr: not disagreeing. all truths are connected, as it were
11:30:22 <gwern> shapr: are there any haskell.org people involved? I had assumed it was googlers making the picks
11:30:31 <shapr> gwern: Perhaps those who have attended Google's GSoC meetings would know more?
11:31:15 <shapr> gwern: Last I was part of GSoC, the mentors voted on the proposals to rank them, and Google only told us how many we would get funded.
11:31:26 <lispy> gwern: FWIW, what I did to sign up was going to google's gsoc website (melange).  I registered there and then applied to be a haskell.org mentor.  Then Johan or Edwardk accepted my app and I joined a mailing list.  From there I could vote on things and leave public or private feedback on proposals.
11:31:33 <shapr> gwern: Thus this information would be directly useful to the mentors doing the ranking.
11:31:50 <edwardk> jaspervdj: heya! (was afk)
11:31:51 <gwern> lispy: see, I couldn't do that. I'm not remotely qualified to be a mentor
11:31:57 <shapr> gwern: I disagree.
11:32:01 <shapr> strongly, even
11:32:11 <jaspervdj> edwardk: I'm currently sort of afk as well (GhentFPG meeting)
11:32:55 <lispy> gwern: You don't have to be assigned a student to meaningfully mentor.  You've already shown you can build a case for which proposals should or should not get funded.  Just that input would be useful to the team.
11:33:00 <Zao> tarrasch: My approach was to generate bindings from the D3D headers, through Language.C and bindings-DSL in a Cabal preprocess step.
11:33:04 <edwardk> gwern: next year, apply to be a mentor, then you can at least comment during the approval process
11:33:10 <shapr> gwern: If you become a mentor, you will be able to make your predictions of success/failure before the proposals are approved. If your predictions are well-supported, you will have much influence :-)
11:33:16 <edwardk> and if something jumps out at you, then you can volunteer to mentor it
11:33:17 <Zao> tarrasch: Worked decently, but I lost interest after getting a MiniTri example up and running.
11:33:37 <shapr> gwern: Plus you get awesome t-shirts too!
11:33:44 <Zao> I might steal some generation infrastructure from SlimDX v2 when it's done and tested.
11:33:46 <gwern> are you trying to bribe me
11:33:54 <shapr> gwern: Why yes, in fact, I AM!
11:33:55 <lispy> bribes!
11:34:07 <edwardk> gwern: and know, your critique of what you see as successful and failing projects has greatly influence the selection criterion we use these days (and has influenced our application with google a great deal)
11:34:19 <shapr> gwern: Because Google t-shirts impress those I wish to date, and those I wish to hire me.
11:34:23 <gwern> edwardk: it has? lispy says he'd never seen it before...
11:34:24 <edwardk> er influenced
11:34:26 <shapr> and they're really comfy too
11:34:39 <lispy> gwern: I hadn't seen it, but maybe edwardk has?
11:35:04 <jaspervdj> edwardk: What time zone are you in?
11:35:12 <edwardk> gwern: i've used is as a reference when applying and describing out successes and failures in the past (especially those before I became actively involved)
11:35:20 <edwardk> jaspervdj: EST (GMT -5)
11:35:23 <rata_> hi
11:35:30 <shapr> gwern: Do you feel sufficiently bribed, or do I need to work harder? :-)
11:35:33 <shapr> howdy rata_, how's code?
11:35:49 <gwern> shapr: well, the problem is that if I can't apply now, I'll probably forget by next january or so
11:35:51 <lispy> gwern: my biggest objections to your post are a) I didn't see it. b) Please don't pronounce students/projects as failed before they can even start.  That's just mean.  There must be a better way to give them direction.
11:35:59 <jaspervdj> edwardk: interested in setting up a skype meeting thursday?
11:36:02 <edwardk> gwern: i'll harass you next year ;)
11:36:22 <edwardk> jaspervdj: sounds good. in the meantime, i'll get skype ;)
11:36:22 <gwern> lispy: I have to make predictions in advance. there are too many cognitive biases in play
11:36:35 <lispy> gwern: our goal as a community is to give them everything they need to succeed.
11:36:42 <shapr> gwern: I'll harass edwardk to harass you next year.
11:36:47 <lispy> s/goal/job
11:36:56 <copumpkin> I'll harass shapr to harass edwardk to harass gwern next year
11:37:02 * shapr laughs
11:37:03 <gwern> (it'd be better if you could apply to be a mentor at any time... seems like a silly restriction)
11:37:35 <gwern> lispy: and those biases aren't just theoretical; I've seen them at work in myself, and one reason I make and record so many predictions, to try to slowly improve myself
11:37:35 * hackagebot QuickCheck 2.4.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.4.1 (NickSmallbone)
11:37:40 <edwardk> gwern: there aren't a lot of folks at google working on melange/summer of code, and they've changed out the system entirely almost 3 years running
11:37:47 <lispy> gwern: and IMO, the biggest failure is when the student doesn't continue to participate in the community.  A botched deliverable on a project from someone who then goes on to contribute regularly is still a partial success.
11:37:58 <djahandarie> I think I'll just harass everyone. That way there is no way it can fail.
11:38:05 <gwern> edwardk: yes, it's a pretty slow website I noticed...
11:38:24 <Heffalump> lispy: acn't you make the predictions in advance but not publish them?
11:38:35 * hackagebot QuickCheck 2.4.1.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.4.1.1 (NickSmallbone)
11:38:46 <gwern> lispy: I agree, and that's one of the more common criticisms of my page. but it's just a ton of effort to track every student and see what they've been doing since, and I haven't sucked it up and done it yet
11:38:48 <lispy> Heffalump: yeah, keep that assessment private?  Seems fair
11:39:08 <jaspervdj> edwardk: OK, it's likely you'll hear from me tomorrow with a “call for benchmarks” thingy
11:39:08 <Heffalump> edwardk: FWIW, I think the way that the decisions on project priorities (rather than student quality) are taken is a bit messy - because it's just the people who are interested in mentoring that make them.
11:39:22 <edwardk> I view the world through slightly rosier lenses than gwern, but his opinions at least have a brutal honesty and consistency to them =)
11:39:25 <Heffalump> gwern: if you want to keep yourself honest, you can publish the md5sum of the predictions.
11:39:43 <Jafet> sha1sum is more honest
11:40:22 <gwern> Heffalump: but at that point, I'm going through so many contortions I might just give up on it.
11:40:50 <gwern> (as the quip goes, it's not like I'm being paid for this)
11:40:56 <rata_> what's the $ operator for?
11:41:06 <twobitsprite> how would I get the current time in the middle of a non-IO function? I see System.Time.getClockTime returns IO ClockTime
11:41:08 <gwern> @src ($)
11:41:09 <lambdabot> f $ x = f x
11:41:28 <gwern> twobitsprite: you can't. you can't/shouldn't do IO in the middle of a non-IO.
11:41:33 <Heffalump> gwern: to be honest, I think your assessments tend to be inaccurate (through ignorance) and not actually very helpful.
11:41:47 <gwern> oh noes
11:41:56 * gwern looks forward to Heffalump's detailed corrections
11:41:56 <Jafet> @hackage acme-now
11:41:57 <lambdabot> http://hackage.haskell.org/package/acme-now
11:42:07 * lispy goes to lunch
11:42:12 * copumpkin trembles
11:42:14 <CalJohn> twobitsprite: pass the current time as an argument.  It will be a little out of date by the time you use it though...
11:42:18 <shapr> rata_: It's a low-priority function application operator. It's commonly used to get rid of parens, but it does more stuff.
11:42:30 <twobitsprite> gwern: hmm... yeah, I guess you're right... I guess I should pass something like that in to the function from an IO function, huh?
11:42:38 <gwern> yep
11:43:23 <Heffalump> gwern: I don't want to contribute to it, because I don't agree with the approach.
11:43:26 <rata_> shapr: thanks =)
11:43:29 <twobitsprite> how does laziness play in to that? Will the call to getClockTime be evaluated when it's first called, or when the value is used by something?
11:43:32 <Eduard_Munteanu> It might be legitimate if the timestamp is used in conjuction with Debug.Trace
11:43:54 * gwern chooses not to vote in elections. that'll show them that the system is illegitimate!
11:44:25 <Heffalump> if everyone did it, it would
11:44:32 * twobitsprite does that
11:44:36 <Eduard_Munteanu> Hrm, I tend to do the same.
11:44:39 * rata_ does that
11:45:18 <Jafet> Bah, I can't make head or tail of Tsuru's sample pcap file. I guess that's an early disqualification.
11:45:20 <twobitsprite> wow, a lot oc concientious non-voters in here :P
11:45:32 <twobitsprite> s/oc/of
11:45:46 <shapr> Jafet: wot?
11:45:53 * zygoloid just hopes the conscientious non-voters have significant overlap with the views he doesn't favour
11:46:00 <copumpkin> lol
11:46:03 <gwern> Jafet: I was thinking of trying that as a haskell tutorial. that bad huh?
11:46:32 <shapr> Who has a pcap file?
11:46:34 <Jafet> twobitsprite: the IO for getClockTime is executed strictly
11:46:43 <twobitsprite> Jafet: ahh, thanks
11:47:13 <twobitsprite> (doesn't really matter, I'm just using it to seed System.Random.mkStdGen, but I was just curious)
11:47:17 <c_wraith> twobitsprite: most IO is executed strictly.  Only a few things don't.
11:47:30 <Jafet> If the program execution uses your function's result, it gets evaluated at that point
11:47:56 <Jafet> Using different pseudorandom numbers surely matters to your program...
11:48:10 <Jafet> It should change its resulting behaviour
11:48:16 <Eduard_Munteanu> But are they evaluated every time?
11:48:23 <twobitsprite> well... using time does matter, but it doesn't matter that the time is a bit out of date by the time it's being used
11:48:49 <Jafet> gwern: not really, if you can figure out how many layers of encapsulation the data's in
11:49:21 <Jafet> You *could* ask for my pcap parser, to get that over with
11:49:49 <gwern> no, that'd be cheating
11:50:52 <rata_> what's the problem with "do rnd <- getStdRandom $ randomR (0.0, 1.0);" ... why does it say "No instance for (System.Random.Random (IO t0)) arising from a use of `randomR'"?
11:51:06 <rata_> s/;//
11:52:33 <Jafet> :t getStdRandom
11:52:34 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
11:52:59 <Botje> rata_: at a first glance i'd switch to using randomRIO
11:55:49 <rata_> Botje: but getStdRandom requires a function System.Random.StdGen -> (a, System.Random.StdGen)
11:56:06 <rata_> and randomRIO doesn't have that signature
11:56:56 <Jafet> (Huh, I just ended a sentence with two prepositions.)
11:57:41 <rata_> :t randomRIO
11:57:41 <lambdabot> forall a. (Random a) => (a, a) -> IO a
11:58:01 <Botje> rata_: it sounds like you are reimplementing randomRIO, no?
11:58:14 <rata_> Botje: no, I just want a random number =S
11:58:35 <rata_> but I'm a haskell newbie
11:58:59 <rata_> I was reading http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms#The_Standard_Random_Number_Generator
11:59:24 <shapr> rata_: Have you read Real World Haskell?
11:59:34 <rata_> shapr: no
11:59:35 <Botje> rata_: then randomRIO is what you want :)
11:59:44 <rata_> Botje: how do I use it?
12:00:02 <rata_> aha
12:00:04 <Botje> do rnd <- randomRIO (0.0, 1.0)
12:00:11 <rata_> ok thanks =)
12:00:35 <Botje> no, thank you, i didn't even know getStdRandom existed :)
12:01:22 <shapr> rata_: You may enjoy reading this: http://book.realworldhaskell.org/read/
12:01:36 <shapr> rata_: I have the hardcopy, it's a good Haskell book.
12:01:55 <rata_> shapr: thanks =) I wanted to ask for that too
12:03:37 <edwardk> Heffalump: Re ratings, ultimately the ratings are taken as a measure of the way the wind is blowing, not as Gospel. Some bias exists obviously, but the commenting process really helps the obviously good proposals to drift up towards the top if nothing else, the difference between the top 50% and the bottom 50% of proposals is quite striking, and little is lost by leaning on the 'mandate' given by the ratings when other considerations 
12:03:59 <rata_> Botje: I still get the same error: "No instance for (System.Random.Random (IO t0)) arising from a use of `randomRIO'"
12:04:01 <edwardk> Heffalump: so, yes, its flawed, but it helps =)
12:04:17 <Botje> rata_: ah. then you're using rnd wrong.
12:04:29 <Botje> can you show the rest of your code on hpaste or something?
12:05:19 <DasIch> rata_: take a look at http://learnyouahaskell.com/input-and-output#randomness
12:05:58 <rata_> Botje: here is my code https://gist.github.com/942917
12:07:24 <Botje> rata_: that looks pretty normal, again :/
12:07:40 * hackagebot acid-state 0.4 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.4 (DavidHimmelstrup)
12:08:22 <rata_> =(
12:09:06 <Botje> let me clone your gist, sec
12:09:16 <crystal-cola> can you write (2^n)`mod`n as a recurrence relation?
12:09:41 <Botje> rata_: oh. duh 
12:09:59 <Botje> rata_: the body for dt is pure, so you don't need to use the arrow
12:10:01 <Botje> let dt = ...
12:10:04 <Botje> instead of dt <-
12:10:12 <rata_> ok
12:10:39 <rata_> is "let dt = ... in" or without in?
12:10:49 <Botje> in a do block you can skip the in
12:12:09 <rata_> ok thanks
12:16:02 <byorgey> crystal-cola: good question, I don't know
12:16:26 <byorgey> > take 100 $ zipWith mod (iterate (*2) 2) [1..]
12:16:26 <lambdabot>   [0,0,2,0,2,4,2,0,8,4,2,4,2,4,8,0,2,10,2,16,8,4,2,16,7,4,26,16,2,4,2,0,8,4,1...
12:17:03 <byorgey> fascinating
12:17:07 <crystal-cola> I thought it looked like a fractal
12:17:14 <byorgey> > 2^25
12:17:14 <lambdabot>   33554432
12:17:26 <byorgey> > (2^25) `mod` 25
12:17:27 <lambdabot>   7
12:17:50 <byorgey> it does appear to have some interesting structure, but nothing immediately obvious
12:18:02 <byorgey> @oeis 0,0,2,0,2,4,2,0,8,4,2,4
12:18:04 <lambdabot>  2^n (mod n).
12:18:05 <lambdabot>  [0,0,2,0,2,4,2,0,8,4,2,4,2,4,8,0,2,10,2,16,8,4,2,16,7,4,26,16,2,4,2,0,8,4,18...
12:18:32 <aristid> @. oeis run take 100 $ zipWith mod (iterate (*2) 2) [1..]
12:18:33 <lambdabot>  Sequence not found.
12:18:56 <aristid> @. oeis run take 10 $ zipWith mod (iterate (*2) 2) [1..]
12:18:57 <lambdabot>  Sequence not found.
12:19:38 <byorgey> crystal-cola: it seems no recurrence is known, at least the OEIS page does not list one: http://oeis.org/A015910
12:19:43 <efie> :where
12:19:58 <crystal-cola> It's a bit worrying how "Unsolved Problems in Number Theory" is gven as a reference
12:20:03 <efie> : where
12:20:25 <byorgey> crystal-cola: I was thinking the same thing =)
12:21:18 <efie> where can i find a definition of "where" ?
12:21:41 <Jafet> @where report
12:21:41 <lambdabot> http://www.haskell.org/onlinereport/
12:21:57 <Jafet> would be a document that defines where
12:22:15 <Jafet> But a tutorial may be more useful to you
12:22:49 <byorgey> crystal-cola: might be interesting to find a copy of that book and see what it says
12:24:07 <efie> jafet: i cant find where on this site
12:24:39 <byorgey> crystal-cola: there is one across the street from me, I'd go check it out if you really want to know =)
12:24:57 <crystal-cola> the book will probably just say "Nobody knows anything about this!"
12:24:59 <rata_> what does it mean "No instance for (Floating Integer) arising from a use of `log'"?
12:25:11 <rata_> in https://gist.github.com/942917
12:25:21 <crystal-cola> byorgey: actually I think that 1 never appears
12:25:24 <crystal-cola> but other than that..
12:25:32 <turingtest> rata_ : you have to explicitly convert to float or double to use "log"
12:25:38 <Jafet> efie: well, you can't define `where' in Haskell, because it's a keyword
12:25:51 <efie> ok
12:26:24 <jmcarthur> rata_: it means you can't use log on an Integer
12:26:36 <jmcarthur> > log 3.2
12:26:37 <lambdabot>   1.1631508098056809
12:26:38 <jmcarthur> > log 3
12:26:38 <byorgey> crystal-cola: I'm going to go check out the book (mostly because I don't check out books very often and it's fun), be back in a bit =)
12:26:39 <lambdabot>   1.0986122886681098
12:26:43 <jmcarthur> > log 3 :: Integer
12:26:44 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
12:26:44 <lambdabot>    arising fr...
12:27:46 <crystal-cola> hehe byy byorgey 
12:27:58 <crystal-cola> tell me if you find some cool stuff
12:31:34 <zzing> Any ideas how one would model a digital circuit, which is normally very 'functional', when you can have things like flip flops where two functions have inputs from the other's output? (eg: http://en.wikipedia.org/wiki/File:R-S_mk2.gif )   
12:33:25 <Kaidelong> HaskellWiki lists a bunch of raytracing libraries
12:33:36 <Kaidelong> I'm wanting to make a distributed variation of one
12:33:58 <Kaidelong> wondering which one to pick for that
12:34:23 <acowley> zzing: "Programming with Arrows" includes an example of just that iirc
12:36:04 <zzing> acowley: I see the example they have of a flip flop, but I don't know what to think of it :p
12:36:08 <kmc> zzing, SICP has an example of a circuit simulator in Scheme
12:36:18 <kmc> maybe it doesn't count as "functional" though
12:36:38 <kmc> but it is cool :)
12:36:45 <kmc> you can write a stateful circuit simulator in Haskell as well
12:37:38 <acowley> zzing: You could try writing some simpler circuits just with functions and pairs in an effort to better appreciate the arrow combinators
12:38:17 <kmc> maybe it's a Blub thing but i never got into arrows
12:39:04 <acowley> Kaidelong: what is there to do other than commanding each worker to render only part of any given frame?
12:39:07 <kmc> Arrow is a very general API, except for "arr", which single-handedly rules out many interesting use cases
12:39:11 <acowley> kmc: I haven't either
12:39:35 <acowley> kmc: that's why I suggested zzing start with just functions and pairs, etc, tos ee if that's enough for his needs
12:39:50 <zzing> acowley: What do you mean 'pairs'?
12:40:43 <byorgey> crystal-cola: the first value of n for which (2^n) `mod` n == 3  is  4700063497
12:40:57 <crystal-cola> hehe
12:41:12 <crystal-cola> so you can name a huge number with it
12:41:41 <byorgey> and the second is 63130707451134435989380140059866138830623361447484274774099906755
12:42:34 <byorgey> 2^n === (-1) mod n  for n = 3^k
12:42:43 <crystal-cola> hmm
12:43:20 <byorgey> The Lehmers found solutions of 2^n == k (mod n) for all |k| < 100 except k = 1
12:43:29 <byorgey> you're right that no solutions for k = 1 exist
12:43:33 <crystal-cola> 2^n === (-1) mod n  for n = 3^k <-- it is perhaps 2^n = 1 (mod n) ?
12:43:37 <byorgey> but it's an open question whether solutions exist for all other k.
12:43:38 <crystal-cola> sorry
12:43:42 <crystal-cola> I get it, that's right
12:43:53 <rata_> how should I do what I'm trying to do in simulate https://gist.github.com/942917
12:44:23 <crystal-cola> My guess would be that every number does appear
12:44:27 <crystal-cola> since 3 appears so late
12:44:31 <Kaidelong> acowley: Get a representation that allows it?
12:44:34 <byorgey> crystal-cola: there are a few other specific facts mentioned but basically that's it
12:45:10 <byorgey> crystal-cola: yes, I would guess so too, and I suppose most mathematicians would as well... but no one has proved it =)
12:45:15 <crystal-cola> very interesting sequence :D
12:45:17 <Kaidelong> I suppose I could just make a general interface for things in the form Problem -> Slice -> PartOfSultion
12:45:26 <byorgey> crystal-cola: indeed, thanks for bringing it up!
12:45:37 <Kaidelong> and then figure out how to get something like that out of one of the raytracing libraries
12:46:00 <Jafet> Just wrap the Scene -> Ray -> Pixel part of the library
12:47:33 <turingtest> rata_: iterate expects a pure function but (step rxns) is an IO computation...
12:47:41 <turingtest> rata_: I meant iterate
12:47:47 <dons> hey all
12:47:51 <dons> 785. new record, i think.
12:47:55 <dons> LYAH effect
12:47:56 <turingtest> > :i Control.Monad.iterateM
12:47:57 <lambdabot>   <no location info>: parse error on input `:'
12:48:03 <dons> ?info Control.Monad.iterateM
12:48:04 <lambdabot> Control.Monad.iterateM
12:48:15 <dons> ?src iterateM
12:48:15 <lambdabot> Source not found. I feel much better now.
12:48:48 <pastorn> tarrasch: join #gsuck
12:49:02 <turingtest> ah..silly me
12:49:05 <lispy> gwern: sorry if I was a bit harsh earlier.  I was kind of annoyed but I'm not anymore.
12:49:08 <Kaidelong> Jafet: like the "raytrace" function in here? http://www.nobugs.org/developer/htrace/htrace.hs
12:49:16 <turingtest> Hi dons.
12:49:26 <gwern> lispy: it's too late! you're dead to me - dead you hear
12:49:46 <rata_> turingtest: I don't find Control.Monad.iterateM
12:49:52 * gwern strokes the family shotguns. ye'd better not be gitting on 'round here, y'hear?
12:50:00 <Jafet> Kaidelong: yeah
12:50:01 <turingtest> rata_: I was wrong. 
12:50:04 <dons> yep. new high score.
12:50:13 <Kaidelong> looks like I will have to tweak that a little
12:50:27 <turingtest> rata_: You made step into IO to access random, yes?
12:50:28 <Jafet> That particular code is rather toy anyway
12:50:50 <gwern> dons: do anything interesting lately? I've been corrupting the minds of the youth with my propaganda: http://www.gwern.net/Haskell%20Summer%20of%20Code.html#predicting-2011-results
12:51:02 <lispy> dons: are we the biggest channel on freenode yet?
12:51:12 <rata_> turingtest: yes
12:51:20 <dons> hmm
12:51:31 <fryguybob> crystal-cola, byorgey: seems there are a few other values for 3: http://www.cs.ucla.edu/~klinger/newno.html
12:51:34 <Jafet> No, but we're the biggest one worth being in!
12:52:06 <Kaidelong> in particular I will have to factor out some of those top level bindings into parameters
12:52:16 <turingtest> rata_: Most of the code looks sane at a glance, but the last line is a non-working blend of Data.List functions with IO.
12:52:18 <dons> gwern: i think 3 and 4 are very sound, 5 is ok. the others i have similar opinions. 
12:52:33 <dons> gwern: the problem is we didn't get a broad range
12:52:36 <Jafet> Kaidelong: you're just doing this as an exercise in parallel processing?
12:53:05 <dons> gwern: strong guess that jasper will succeed (do you know him?)
12:53:08 <gwern> dons: broad range of student or broad range of projects?
12:53:11 <dons> gwern: blaze html guy.
12:53:11 <Kaidelong> I'm doing this because my professor things a distributed raytracer in MPI is going to be too hard as a final project 
12:53:12 <byorgey> fryguybob: oh, nice =)
12:53:24 <rata_> turingtest: I know, but I don't know how to do what I'm trying to do
12:53:25 <lispy> gwern: both.  Too few students, narrow focus
12:53:26 <Kaidelong> and I would like to show him otherwise
12:53:33 <dons> gwern: broad range of projects. they didn't submit many unique topics
12:53:36 <Kaidelong> he might be right of course
12:53:44 <lispy> gwern: tibbe was saying we need to get out and beat the drum more
12:53:48 <turingtest> rata_: I'll try and sketch something in reply...
12:53:53 <gwern> dons: yeah, I've been using his hakyll for months now. gives me a good opinion of him, and one reason why I don't doubt he'll succeed (you'll notice I don't often criticize projects for underambition :)
12:53:54 <crystal-cola> Cool!
12:54:02 <dons> gwern: remember the other aspect: drawing in developers
12:54:04 <gwern> dons: gwern.net is all-hakyll generated, eg.
12:54:17 <dons> if we can ensure say, jasper becomes a core dev as a result, it is worth it for what he'll do in the future.
12:54:23 <byorgey> the 2004 edition of "Unsolved Problems" that I have seems to (incorrectly) imply that 65-digit number is the second smallest solution, but Peter Montgomery's email there definitely does not imply that
12:54:43 <gwern> dons: well, jasper is already pretty committed to haskell... he needs little brainwashing, as it were
12:54:56 <dons> more training 
12:55:04 <dons> so the mentoring is key
12:55:09 <tibbe> dons: I think he'll learn Core this time around
12:55:17 <dons> tibbe: hopefully!
12:55:23 <dons> oh, and mikhail will do great
12:55:28 <Kaidelong> out of curiousity, does raytracing work on a similar principle to a pinhole camera?
12:55:31 <dons> he already packages the HP for windows, so he's familiar with cabal
12:55:37 <dons> and this will help draw him in again
12:55:52 <Jafet> Kaidelong: if you want to do nice raytracing (in addition to practising MPI or whatever) there is the pbrt book
12:55:54 <gwern> dons: I don't think I've ever heard of mikhail before. what does he do besides the windows HP? (which sounds like a nasty task indeed)
12:55:55 <copumpkin> Kaidelong: only if you don't want to simulate a lens
12:55:55 <tibbe> dons: yes
12:56:16 <dons> gwern: not sure. but the HP is a big task, and he does great, he's responsive, and has been around for 2 years helping, so i'm confident for those reasons
12:56:20 <tibbe> dons: we got the most proposals for the projects I blogged about, showing that beating the drum works
12:56:24 <dons> yep
12:56:28 <Kaidelong> pbrt book?
12:56:40 <Jafet> But of course if your professor thinks basic multiprocessing is a lot for a "final project", pbrt might be overkill
12:56:46 * dons -> meeting
12:57:02 <Jafet> pbrt: http://www.amazon.com/dp/0123750792
12:57:03 <crystal-cola> "This n2 was found by guessing that the solution would have the (form) n = r * q, where r = 485 and q is prime"
12:57:09 <crystal-cola> that's ridiculous.. who would guess 485?
12:57:37 <byorgey> haha
12:57:49 <byorgey> he probably had a reason for it but I guess he doesn't say
12:57:50 <tibbe> dons: we need to be more proactive to get good students
12:57:54 <Jafet> copumpkin: you can simulate a lens by modelling a lens in front of the pinhole!
12:58:02 <copumpkin> fair enough :)
12:58:19 <Jafet> That still prevents you from modelling non-classical things like diffraction, though
12:58:55 <Kaidelong> wow, pricey
12:58:58 <Kaidelong> I will check the library
12:58:59 <crystal-cola> maybe they tried every other number first
12:59:09 <ddarius> Pinhole cameras are for the weak.
12:59:44 <lispy> tibbe: yeah
12:59:52 <ddarius> Jafet: It doesn't prevent that.  It does prevent things like depth of field.
13:00:26 <turingtest> rata_:  here http://hpaste.org/46063/for_rata
13:00:40 <tibbe> lispy: knowing more precisely the work involved is also helpful
13:00:41 <lispy> tibbe: Now that we have an idea of what we want.  We can come up with a strategy next year as long as someone reminds people at the right time.
13:00:49 <tibbe> lispy: students don't tend to do well with too much rope
13:00:56 <tibbe> lispy: right
13:01:11 <tibbe> lispy: I tried to blog a bit about it to make people aware
13:01:30 <lispy> tibbe: I think I read your blog but I didn't act :(
13:01:42 <lispy> tibbe: I should have blogged about it to.
13:01:43 <tibbe> lispy: next year we'll do better :)
13:02:02 <tibbe> lispy: if it's something I've learned from dons it is the importance of communication
13:02:09 <rata_> turingtest: thanks a lot!! =)
13:02:11 <lispy> Yup
13:02:28 <lispy> Proactive, reminders, communicating broadly, etc
13:06:05 <ddarius> If only those people who understood the importance of communication understood the importance of communication, more people would understand the importance of communication.
13:07:40 <Jafet> Perhaps communication with those people who do not understand the importance of communication does not easily cause them to understand the importance of communication.
13:07:52 <Runar> ddarius: it's like a discipline without the discipline of all of the discipline
13:11:38 <AEL> Is haskell only a one lines?
13:12:01 <ddarius> No.  It's a vierbein.
13:12:24 <Jafet> My Haskell programs have one lines.
13:14:17 <seats> im learning me a haskell for great good
13:14:53 <seats> any of you all have opinions about the most interesting open source projects to look at
13:14:58 <seats> to learn/absorb
13:16:02 <seats> any of you guys working on open source stuff right now?
13:16:18 <sm> seats: I am
13:16:30 <seats> sm, cool, what project
13:16:34 <Bustakheops> hi, why this line of code is infinite ? ->
13:16:44 <sm> rss2irc. Last week, hledger
13:17:26 <sm> if you'd like to help, you'd be welcome. rss2irc is small
13:17:28 <byorgey> seats: what sorts of things are you interested in?
13:17:41 <Bustakheops> Data.List.nub (Data.List.zip [0,0..] [1,1..])
13:17:52 <seats> byorgey, i don't quite know, hence the very open ended question ;)
13:17:59 <Bustakheops> zip isn't lazy ?
13:18:11 <seats> functional programming is all new to me
13:18:23 <seats> and i can tell im reaching that point in reading/learning where I need to start fiddling
13:18:27 <byorgey> seats: I'm working on this: http://code.google.com/p/diagrams/
13:18:30 <seats> for it to grab me
13:18:40 <Jafet> Bustakheops: what sort of list is zip [0,0..] [1,1..]?
13:18:50 <seats> where are most active haskell projects hosted now, github?
13:18:54 <seats> code.haskell?
13:19:20 <dons> github i think, at this point
13:19:26 <byorgey> some are on github, some on code.haskell.org, some on patch-tag.com, ...
13:19:28 <kmc> you'll find them by following links on hackage
13:19:34 <burp> and some on darcsden.com
13:19:50 <sm> all over the place
13:19:53 <seats> is there a flame-level allegiance to darcs over git?
13:20:09 <acowley> no
13:20:11 <kmc> GHC just migrated to git
13:20:14 <seats> ive used plenty of version control systems, but ive never touched darcs
13:20:17 <beastaugh> whatever happened to the new version of Hackage?
13:20:24 <kmc> darcs is interesting but it really doesn't scale to a project the size of GHC
13:20:37 <seats> that's interesting, git is definitely my current preference, but just because it's been the one that has caused me the least pain
13:20:51 <seats> is ghc all in haskell?
13:21:12 <Zao> seats: Largely.
13:21:25 <kmc> if you draw a line between the compiler and the runtime system
13:21:31 <kmc> then the compiler is mostly Haskell and the RTS is mostly C
13:21:36 <Zao> How's the Commentary nowadays?
13:21:39 <gwern> there are a lot of haskell repos. my script to download github's haskell repos pulls down like 10 or 12 gb
13:21:41 <Zao> Woefully outdated?
13:21:55 <seats> my major reason for 'picking' haskell out of the options in the functional world was the claim of 'pureness'
13:21:59 <kmc> languages that go into GHC include Haskell, C, Cmm, various assembly, shell, perl, make
13:22:22 <seats> i figured it would be best to cut the cord and use something that forced my mind into the functional thought process
13:22:28 <Jafet> Hey, let's not mention the perl bit
13:22:41 <kmc> seats, for some values of "force"
13:22:46 <kmc> Haskell is a good imperative language as well
13:22:46 <tibbe> refold: evening :)
13:23:19 <seats> kmc: well im sure if you try hard enough you can make any language look like any paradigm, but you get my point
13:23:21 <kmc> the "purity" is honestly more about community norms than hard technical features
13:23:26 <gwern> didn't we get rid of the evil mangler?
13:23:27 <seats> right
13:23:40 <tibbe> gwern: with the deprecation of the C backend yes
13:23:46 <kmc> seats, but my point is that it's not unnatural to solve an imperative problem imperatively in Haskell
13:23:57 <kmc> the imperative paradigm is not second-class
13:24:06 <seats> also, i like the idea of increased expressiveness
13:25:28 <seats> are you all using haskell essentially all the time?
13:25:36 <aristid> kmc: in fact, they are first-class values :D
13:25:41 <Cale> I am, pretty much
13:25:41 <sshc> Cale: Again, thanks for suggesting "Category Theory".  This has been, by far, the most enlightening coverage of the subject I've ever read.  I, in turn, also suggest reading it to anybody else who wants to learn about the subject.
13:25:53 <Cale> sshc: :)
13:25:56 <seats> or a better way to frame that question, are there times you think it's better to work in a different language?
13:26:08 <Cale> seats: Well, sure
13:26:09 <kmc> yes
13:26:16 <kmc> when i do Linux kernel programming i don't use Haskell
13:26:23 <Cale> seats: But there's a lot of languages which are in a sense "obsoleted" by Haskell
13:26:27 <acowley> sshc Cale: which "Category Theory" are you referring to?
13:26:27 <kmc> or AVR microcontroller programming
13:26:30 <seats> kmc: clearly ;)
13:26:35 <Cale> acowley: Awodey's
13:26:43 <acowley> thanks
13:26:45 <acowley> kmc: use Atom
13:26:48 <kmc> seats, there is an example of writing a Linux module in Haskell, but it's not a reasonable thing to do :)
13:26:50 <acowley> kmc: :)
13:27:14 <kmc> seats, if i'm doing some one-off text munging and I don't need a high assurance of correctness, i might use Python
13:27:21 <seats> what would you say is the most high profile public haskell project
13:27:36 <kmc> then again, Python 2's unicode support is much worse than GHC Haskell's, and i've picked Haskell for such projects on that basis alone
13:27:39 <kmc> seats, probably XMonad
13:27:41 <seats> my history is c, perl, c#, ruby, python, etc
13:27:45 <sm> ghc, darcs, xmonad...
13:27:48 <kmc> see also http://www.haskell.org/haskellwiki/Haskell_in_industry
13:27:58 <seats> for some reason i dont feel like you can count ghc or darcs
13:28:07 <seats> a little too self referencing
13:28:07 <kmc> a lot of interesting / important Haskell programs are not prominent public projects
13:28:17 <Kerris> that'd be like counting the JVM for Java :v
13:28:22 <kmc> but are rather internal projects at finance companies, government / defense agencies, etc
13:28:23 <gwern> pandoc has a fair number of users
13:28:28 <kmc> Kerris, a JVM written in Java?
13:28:39 <kmc> yeah, i quite like pandoc
13:28:41 <Kerris> Jikes RVM? :v
13:28:41 <sm> ..pandoc..
13:28:50 <seats> kmc, i bet, kind of my question, which is really, where are people doing super cool stuff with haskell, where is it giving the most leverage, etc
13:28:54 <kmc> for reasons unrelated to its language of implementation -- i've never hacked on or even looked at the code
13:29:11 <kmc> seats, then you should take a look at the link i sent :)
13:29:23 <seats> yeah i read through that
13:29:36 <seats> i thought i'd ask the live audience, see what they said 
13:29:37 <kmc> Galois does a lot of Haskell consulting for government, some of which is classified i'm sure :)
13:29:48 <rata_> turingtest: I found iterateM in Data.Enumerator.List http://hackage.haskell.org/packages/archive/enumerator/0.4.8/doc/html/Data-Enumerator-List.html
13:29:54 <cheater99> haskell in industry isn't an amazing list
13:29:56 <kmc> to be honest though, i encourage you to learn Haskell and not worry right away about what it's good for
13:29:56 <rata_> was that what you were looking for?
13:30:00 <seats> for the finance, gov, defense use what do you think is their biggest driver to choose haskell
13:30:17 <kmc> i think most people who learn Haskell don't use it for anything big, but learn a lot of things that make them better programmers in other languages
13:30:23 <sm> correctness and low maintenance costs
13:30:24 <kmc> anyway i should get some work done, ttyl all
13:30:32 <seats> is it that the increased expressiveness + better code quality, which theoretically is yielding more productive output?
13:30:34 <turingtest> rata_: Good find...I have not used enumerator for much.
13:30:36 <acowley> I use Haskell for computer vision and robotics
13:30:59 <seats> kmc, i've read as well, and I definitely believe it
13:31:07 <seats> acowley, awesome
13:31:15 <acowley> GHC is perfectly suitable for big, real projects
13:31:32 <acowley> hackage is invaluable, and performance is good
13:31:38 <Jafet> .oO( Is seats learning Haskell, learning about Haskell, learning about reasons to learn Haskell, or learning about reasons to learn about Haskell? )
13:31:46 <seats> one of the first things i thought when i started to grok functional style is that it would work well for a neural net lib
13:32:01 <seats> and i found there are several already
13:32:06 <seats> Jafet, all of the above!
13:32:21 <seats> i'm very meta
13:33:01 <seats> unfortunately it's deep recursion and with lazy evaluation i haven't done anything yet
13:34:01 <acowley> Has anyone setup a faster mirror for downloading GHC?
13:34:08 <Jafet> Perhaps you should be starting with the head of that list, not the tail
13:34:13 <acowley> it really is agonizing how slow it is :(
13:34:40 <seats> actually that's something i dont quite get
13:34:58 <djahandarie> acowley, are you 'acow' on reddit btw?
13:34:59 <seats> why a right fold on an infinite list can work, but not a left
13:35:18 <acowley> djahandarie: yes
13:35:25 <Jafet> > foldl f 0 [x,y,z] :: Expr -- because it starts with the end
13:35:25 <lambdabot>   f (f (f 0 x) y) z
13:35:43 <acowley> seats: try evaluating by hand to see how it goes
13:36:00 * monochrom shakes head at package hell problems. here is another instance: http://groups.google.com/group/comp.lang.haskell/msg/4719915b8cb01441
13:36:08 <alpounet> but be careful, evaluate it with *lazy* evaluation
13:36:30 <alpounet> in Jafet's example, you'd need a "z" to start from, but if the list is infinite...
13:36:38 <acowley> yes! which can actually be quite intuitive when doing it by hand
13:36:50 <alpounet> > foldr f 0 [x,y,z] :: Expr 
13:36:52 <lambdabot>   f x (f y (f z 0))
13:37:15 <seats> i see the difference in evaluation order
13:37:27 <acowley> seats: exand the folds using infix cons in place of "f"
13:37:31 <acowley> s/exand/expand
13:37:42 <seats> but you still need to evaluate the interior functions in the right fold to get the value to pass to the outer
13:37:51 <acowley> and you get the list version
13:37:58 <alpounet> > foldr (:) 0 [x,y,z] :: Expr 
13:37:59 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:37:59 <lambdabot>         against inferred ...
13:38:15 <hpc> :: [Expr]
13:38:21 <rata_> how do I take the first 10 elements of a Data.Enumerator.Enumerator?
13:38:24 <alpounet> yeah
13:38:28 <alpounet> i'm lazy tonight
13:38:33 <alpounet> > foldr (:) 0 [x,y,z] :: [Expr] 
13:38:34 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
13:38:34 <lambdabot>    arising from the lite...
13:38:44 <hpc> er
13:38:52 <hpc> nvm <.<
13:38:53 <alpounet> flip missing
13:38:55 <alpounet> i guess
13:39:09 <djahandarie> No
13:39:16 <djahandarie> It's trying to unify (Num a) => a with Expr
13:39:16 <hpc> > 0 :: Expr
13:39:18 <lambdabot>   0
13:39:25 <hpc> easy unification
13:39:29 <kosmikus> 0 isn't a list of expressions
13:39:35 <hpc> :t foldr
13:39:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:39:39 <hpc> doesn't need to be
13:39:43 <hpc> it needs to be :: b
13:39:43 <Jafet> @src foldl
13:39:43 <lambdabot> foldl f z []     = z
13:39:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:39:58 <alpounet> > foldl (:) 0 [x,y,z] :: [Expr] 
13:39:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
13:40:05 <acowley> boy, we're doing a bang-up job of clarifying this situation!
13:40:18 <hpc> haha
13:40:37 <hpc> oh well, whatever
13:40:48 <seats> dont sweat it
13:40:56 <seats> ill get it
13:40:56 <acowley> seats: do it by hand :)
13:41:16 <acowley> seats: and make sure you do get it as it's a great way to exercise your understanding of lazy evaluation
13:41:19 <seats> i think i really just need a good example of an infinite list and a fold operation that works and doesnt work
13:41:46 <seats> yep, i see that it's key, since you need to be able to discard the inner functions
13:41:56 <djahandarie> > foldr (:) [0] [x,y,z] :: [Expr]
13:41:57 <lambdabot>   [x,y,z,0]
13:42:32 <monochrom> > foldr1 (||) (repeat True)
13:42:33 <lambdabot>   True
13:42:38 <monochrom> > foldr1 (&&) (repeat True)
13:42:42 <lambdabot>  Terminated
13:42:56 <monochrom> one example that works, one example that diverges
13:43:05 <seats> monochrom, good example, thanks for that
13:43:15 <seats> actually great example, very succient
13:43:18 <seats> succinct
13:43:24 <Jafet> seats: if you follow the definition, foldl f z (x:infinite) = foldl f (f z x) infinite, so you'll never get to the z
13:43:25 <Peaker> What do you guys think about http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/ ?
13:43:37 <djahandarie> Peaker, see the reddit thread? :)
13:43:46 <Jafet> > foldr1 (&&) (repeat True) || True
13:43:49 <Peaker> djahandarie, Ah :)
13:43:50 <lambdabot>   mueval-core: Time limit exceeded
13:43:51 <acowley> Peaker: we're all very angry
13:43:55 <Peaker> :-)
13:44:06 <acowley> fists were shaken, brows were furrowed, eyes were rolled
13:44:06 <aristid> @src and
13:44:06 <lambdabot> and   =  foldr (&&) True
13:44:28 <seats> acowley: lol
13:44:30 <Peaker> I don't understand why he claims equational reasoning is not improved
13:46:35 <rata_> where can I learn how to use Data.Enumerator.Enumerator?
13:47:08 <monochrom> with ⊥ hanging in the air, many laws you use in equational reasoning break
13:47:13 <acowley> Peaker: I don't know that either, but his primary objection is with the lack of induction on sums
13:48:22 <acowley> Haskellers don't care about hanging ⊥s, this is our great shame
13:48:22 <seats> rata_: did you look here -> http://hackage.haskell.org/package/enumerator
13:48:29 <monochrom> but you should merely troll him by saying "haskell is not lazy, just non-strict"
13:48:51 <rata_> seats: yes
13:48:53 <seats> monochrom, whats the difference?
13:49:14 <acowley> monochrom: he is totally trolling the Haskell community, and people bite every time
13:49:16 <monochrom> non-strict is about denotational semantics, lazy is about operational semantics
13:49:27 <acowley> he does it very well
13:50:08 <monochrom> one more reason to troll him back
13:50:26 <monochrom> "what is your signature thingie LOL"
13:50:35 <acowley> he's not exactly a dummy, so it would probably be hard
13:50:43 <seats> rata_: i'm blind leading the blind, but happy to help you look for what you need, can you ask a more specific question?
13:50:49 <acowley> what I love are his, "No, you're wrong." responses
13:51:27 <acowley> short, to the point, doesn't do anything to stem the arguing
13:51:45 <djahandarie> I really don't like this responses.
13:52:05 <seats> what is a 'hanging ⊥' ?
13:52:07 <djahandarie> Makes it look like he is a lot more interested in being right than in sharing knowledge.
13:52:28 <monochrom> he has limited time too
13:52:33 <hpc> seats: i think what it means is:
13:52:45 <seats> assuming you aren't talking about starting a game of hangman in ascii art
13:52:56 <hpc> seats: say you have a list (1:undefined)
13:53:04 <kosmikus> djahandarie: why isn't it ok to point out that others are wrong?
13:53:12 <hpc> seats: when you match the head, the undefined tail is still there
13:53:14 <acowley> djahandarie: I agree
13:53:22 <hpc> but it isn't inspected so it doesn't crash your program
13:53:34 <acowley> djahandarie: But this kind of baiting is pretty common in some circles
13:53:34 <Zao> kosmikus: In order to claim that someone is wrong, you most probably possess knowledge why.
13:53:43 <rata_> seats: how do I take the first 10 elements of a Data.Enumerator.Enumerator?
13:54:00 <hpc> or in the case of non-terminating bottoms, you can evaluate just the first part of it, without evaluating the rest
13:54:01 <aristid> rata_: Data.Enumerator.List.take?
13:54:08 <cloudhea1> can anyone tell me if there's a better way to write this, performance wise? https://gist.github.com/58e7cb3d7cff3df122cd
13:54:10 <hpc> so you can get the first few elements of [1..], but not the whole thing
13:54:19 <osfameron> barshirtcliff: and hello ;-)
13:54:21 <hpc> (i am probably wrong)
13:54:24 <rata_> aristid: that function just take an integer, no enumerator
13:55:41 <djahandarie> kosmikus, because its just an appeal to authority.
13:55:53 <djahandarie> Saying something is wrong doesn't make it wrong.
13:56:08 <aristid> rata_: it returns an Iteratee.
13:56:17 <crystal-cola> it's fine to say someoen is wrong, just be prepared to explain why if they ask
13:56:32 <rata_> aristid: and how do I use that Iteratee?
13:56:50 <kosmikus> djahandarie: no, but in this case, it seems that most people are really just making wrong claims, and he's refuting them. why should he spend time to argue in each individual case why a statement is wrong when the others don't really argue why they believe them true.
13:56:52 <aristid> rata_: depends on what you want to do?
13:57:08 <rata_> aristid: take the 10 first element of an enumerator
13:57:14 <seats> lol
13:57:27 <acowley> kosmikus: that's not at all an accurate description of the situation
13:57:37 <aristid> rata_: that question does not really make sense
13:57:48 <ddarius> "You're not going to say, 'You're wrong.'" "You're wrong."
13:57:49 <acowley> kosmikus: people are offering specific arguments, and he is just denying them without any explanation
13:58:15 <kosmikus> acowley: example?
13:58:20 <aristid> rata_: oh, i think i can guess what you mean
13:58:44 <aristid> rata_: run_ (yourEnumeratee $$ EL.take 10)
13:58:53 <aristid> *yourEnumerator
13:58:59 <monochrom> this would be a good time for another reddit outage :)
13:59:19 <Peaker> hehe, about Harper's "Haskell has bottom values, ML has bottom as an effect", winterkonikje replied: "Though, as discussed in the sibling thread with sclv, he's arguing that he doesn't have skeletons in his closet (because he keeps them in the pantry instead)"
14:00:00 <acowley> kosmikus: the last time I looked at the comments on the post, people were contending that there weren't nested bottoms lurking in a Nat type with a strict S constructor, so the situation is not so different from having a well-typed divergent function in ML. His responses were, to an approximation of 3 words or so, "No."
14:00:07 <copumpkin> kosmikus: http://snapplr.com/4rx8
14:00:18 <copumpkin> kosmikus: http://snapplr.com/bd4c
14:00:33 <copumpkin> kosmikus: http://snapplr.com/zbn1
14:00:43 <copumpkin> kosmikus: http://snapplr.com/zy7e
14:00:46 <monochrom> you're all wrong
14:00:46 <copumpkin> :)
14:01:27 <acowley> it's a pretty addictive argumentation technique once you get started with it :/
14:01:36 <Zao> He's clearly an Oracle.
14:02:01 <willis_> wassup niggas
14:02:10 <djahandarie> willis_, mind the language, please
14:02:10 <willis_> im here to cap some haskell
14:02:12 <acowley> I'm slightly surprised nobody has added this as a lambdabot discussion mode
14:02:25 --- mode: ChanServ set +o monochrom
14:02:42 <copumpkin> willis_: not appropriate
14:02:57 <willis_> ay ima be makin a haskell program that a tellin me how much nigga i am
14:03:04 <willis_> who wanna help
14:03:10 --- mode: ChanServ set +o copumpkin
14:03:11 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.99.188.94.225
14:03:21 --- mode: copumpkin set -o copumpkin
14:03:25 --- mode: monochrom set -o monochrom
14:04:06 <acowley> ty monochrom 
14:05:11 <kosmikus> acowley, copumpkin: ok, I admit he could be a bit more verbose in some of his comments.
14:05:15 <kosmikus> :)
14:05:38 <aristid> copumpkin: you're too slow
14:05:52 <kosmikus> anyway, while I think that most of his arguments are ok, I don't agree with his evaluation and conclusion
14:06:00 <noteventime> I'm not familar with the discussion
14:06:28 <acowley> kosmikus: he fans the flames with some pretty combative word choice, too
14:06:41 <noteventime> But he kinda seems to confuse the idea of a datatype as a terminal coalgebra with the idea of operations on such data types as coalgebra morphisms 
14:07:02 <danharaj> who are we talking about?
14:07:04 <tolkad> I am trying to use a package that depends on base 4.2 but cabal-install says "base-4.2.0.2 was excluded because of the top level dependency base -any"
14:07:09 <tolkad> what is that supposed to mean?
14:07:39 <noteventime> danharaj: http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
14:07:40 <c_wraith> tolkad: it's due to cabal preferring base 3 if a version is not provided.
14:07:46 <tomh> hey guys, when OO programmers look at functional programmers and say it looks like a step back and unmaintainable, is there any good article I can show them? :)
14:07:54 <tomh> programmers = programs
14:07:57 <copumpkin> tomh: zombo.com
14:08:02 <tomh> lol
14:08:14 <noteventime> tomh: Show them any reasonably large Java program?
14:08:26 <danharaj> Any program that is big and not OOP
14:08:26 * noteventime does a troll face
14:08:39 <danharaj> The idea that OOP gives you maintainability is the biggest lie told in programming.
14:08:40 * ddarius finds copumpkin hard to maintain.
14:08:45 <ezyang> Show them... GHC? 
14:08:55 <copumpkin> I got easier to maintain after I cut my hair
14:08:56 <noteventime> Or XMonad?
14:08:58 <papna> tomh: Perhaps you should spend your time doing things you enjoy rather than trying to convince people of things they don't want to be convinced of.
14:09:00 * geheimdienst tries to maintain copumpkin
14:09:18 <danharaj> Yeah people are jackasses who aren't worth the time.
14:09:25 <tomh> papna: its just their first impression
14:09:27 <monochrom> tomh: also show them http://uncyclopedia.wikia.com/wiki/ZomboCom for what's wrong with camel case
14:09:28 <tolkad> c_wraith: I don't understand, I'm trying to install yesod and it requires base >= 4 and < 4.3, it depends on directory which requires base >= 4.2 and < 4.4. 4.2 should satisfy all these dependency rules
14:09:44 <ddarius> danharaj: Yep. Dogs > People.
14:09:44 <tomh> ezyang: do you think GHC is well written?
14:10:12 <ezyang> For certain definitions of well written. 
14:10:17 <rata_> thanks a lot aristid!! =)
14:10:22 <aristid> @hoogle (a -> Maybe a) -> a -> [a]
14:10:22 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
14:10:23 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:10:23 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:10:28 <aristid> rata_: :)
14:10:31 <ezyang> I think it's a minor miracle that we're still able to do research level work with GHC as the codebase. 
14:10:45 <noteventime> tomh: There is the article series about implementing XMonad, perhaps that could be a start 
14:10:50 <ezyang> And says something good about the Simon's engineering chops. 
14:10:50 <lispy> ezyang: the simons are amazing :0
14:10:53 <tolkad> c_wraith: you mean cabal prefers base 3.*? Why would it prefer a very old version of base and why would that prefernce prevent it from using a different version?
14:11:22 <tomh> noteventime: thanks I gonna look that up
14:11:29 <tolkad> and most importantly how do I fix it?
14:11:31 <geheimdienst> tomh: i've been hacking some xmonad, the code base is around 40kloc and i think it is well-separated and there's no unclean interaction between the different corners of the program. that's of course simple because haskell is very pure. that's gotta count for something
14:11:32 <noteventime> Can't remember what it was called
14:11:52 <c_wraith> tolkad: that error message says that *something* you're installing depends on "base".  cabal is set to prefer base 3.* in that case.  Find what has that dependency, and either fix it yourself, or get the maintainer to fix it.
14:12:19 <noteventime> tomh: "Roll Your Own Window Manager" http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model
14:12:46 <c_wraith> tolkad: cabal is set to do that because of issues with maintainers not checking that packages were compatible with the changes in base 4
14:12:55 <tomh> ah yeah I remember a guy doing a talk about it in our FP course
14:13:57 <tolkad> c_wraith: hmm, is there a way to get cabal to tell me? yesod has like 20 dependencies
14:14:02 <ezyang> I also recommend Dons' talk about industrial Haskell 
14:14:07 <c_wraith> tolkad: probably not :(
14:14:28 <c_wraith> tolkad: no, scratch that.  turn on the verbose flags in cabal
14:14:44 <aristid> --dry-run may help too
14:15:15 <tolkad> also, why do some packages have such arbitrary dependencies like base < 6
14:15:53 <monochrom> there's one with base<10 so you won't run into problems for a long time
14:16:09 <geheimdienst> some of the features in 6 are quite badass, but 5 is okay. it's much more down-to-earth
14:16:15 <Philippa> JaffaCake: anything further on the possibly hackathon?
14:16:22 <Philippa> *possible
14:16:22 <c_wraith> bindings-dsl depends on base < 1000
14:16:22 <monochrom> or maybe you will. it's a gamble
14:16:30 <monochrom> oh haha that's a new record
14:16:33 <tolkad> lol it's transformers: http://hackage.haskell.org/package/transformers-0.2.2.0
14:16:34 <c_wraith> But since bindings-dsl contains no haskell code, that's probably safe
14:16:39 <monochrom> haha
14:16:43 * Philippa wonders if she needs a typechecker for her english
14:16:59 <Alan> I'm having trouble getting state monads to work in my haskell installation...  first it couldn't find Control.Monad.State, then when i installed libghc6-mtl stuff, it can't find the "state" function....
14:17:34 <tolkad> c_wraith: if it doesn't have any haskell code why does it depend on base at all?
14:17:42 <cloudhea1> hey can anyone take a look at https://gist.github.com/58e7cb3d7cff3df122cd ? 
14:17:53 <monochrom> c_wraith, tolkad: I say the problem is caused by bad packages already installed, rather than conflicts in packages not yet installed. cabal-install is garbage-in garbage-out when it comes to existing packages
14:18:09 <monochrom> "ghc -v" will likely display wonders
14:18:29 <tomh> ezyang: do you have a link to that talk?
14:18:55 <tolkad> cabal install -v didn't help
14:19:02 <monochrom> my "bad packages" means multiple versions of same package, even multiple instances of same version same package
14:19:05 <geheimdienst> Alan: iirc the State monad is one of those where there's one implementation in mtl and a conflicting implementation in monads-tf. have you checked that?
14:19:13 <acowley> cloudhea1: You probably want to avoid appending lists on every trip through the loop
14:19:18 <monochrom> no, cabal install -v seldom helps. look at ghc -v. paste it for me
14:19:36 <ezyang> http://donsbot.wordpress.com/2010/07/11/engineering-large-projects-in-a-functional-language/ 
14:19:44 <Alan> geheimdienst: how would i check that?
14:19:47 <tomh> cool thanks!
14:19:47 <cloudhea1> acowley: that's what I thought, I'm not sure how else to do it though?
14:20:11 <cloudhea1> acowley: should I be using arrays, or have some sort of action list?
14:20:28 <acowley> cloudhea1: use a data structure like Seq that has fast appends, or accumulate lines in reverse order and then reverse them before passing to markdownToHtml
14:20:58 <acowley> in this short of a program I'd be tempted to use lazy IO, too
14:21:33 <cloudhea1> acowley: thanks, I'll look into that!
14:21:48 <tomh> but I wonder how applicable such a talk will be for a wider audience, I mean don steward works with the brightest programmers in the world
14:22:20 <geheimdienst> Alan: never mind, i think i was wrong anyway. but hayoo finds a "state" function in Control.Monad.State.Strict and C.M.S.Lazy, from the mtl package ... http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=state
14:23:33 <acowley> cloudhea1: how about using interact?
14:24:54 <tolkad> I think it would be cool if cabal supported subpackages
14:25:21 <Nereid> what's a subpackage? :0
14:25:26 <acowley> cloudhea1: something like main = interact (concat . markdownToHtml. takeWhile (/= "EOF") . lines)
14:25:31 <acowley> err
14:25:50 <acowley> interact $ markdownToHtml . concat . takeWhile (/= "EOF") . lines
14:26:55 <mlitchard> I have a file /foo/bar.hs and another file /foo/baz/bomb.hs. I wish to import bomb.hs into bar.hs. Is there syntax for import that can help me with this? If not, what do I need to do?
14:26:59 <tolkad> Nereid: What I mean is, a way to include packages with a package. like the way ghc comes with all its dependency packages
14:27:44 <cloudhea1> acowley: I tried using interact the naive way, but it would exit on EOF (Ctrl+D)
14:27:50 <tolkad> Nereid: without having to write a build script and without putting them in the global package namespace
14:27:52 <acowley> mlitchard: if you are starting in foo, then import Baz.Bomb if you name the second module Baz.Bomb
14:28:26 <acowley> cloudhea1: I don't understand, you don't want it to exit on Ctrl+D?
14:28:29 <NisseP> mlitchard: also, capitalise your file and directory names accordingly, since module names have to start with a capital letter
14:28:35 <int80_h> oops, forgot to change my nick
14:28:56 <NisseP> (and A.B.C has to be in A/B/C.{l,}hs for GHC to find it)
14:28:59 <cloudhea1> acowley: no, I don't, that's what this wrapper is for. I need to send a bunch of files to it, but don't want to have to respawn the process every time
14:29:33 <cloudhea1> acowley: so I use a "fake" EOF marker, which sends the output back to stdout while keeping STDIN open
14:29:48 <cloudhea1> that's essentially what I'm trying to accomplish
14:33:17 <tolkad> omg this is insane yesod must depend on half the packages in hackage
14:33:32 <tolkad> when you started looking through second tier includes
14:33:49 <ddarius> That would be quite a success of the system.
14:34:23 <tolkad> except that it fails building with the descriptive error message "base-4.2.0.2 was excluded because of the top level dependency base -any"
14:34:30 <acowley> cloudhea1: this is bending over backwards a bit and relies on stdout being line buffered
14:34:36 <acowley> main = interact (go . lines)
14:34:36 <acowley>   where go = uncurry (++) 
14:34:36 <acowley>            . (markdownToHtml . concat *** go . tail) 
14:34:36 <acowley>            . break (== "EOF")
14:34:39 <acowley>  
14:34:54 <acowley> and untested!
14:34:57 <acowley> :/
14:35:01 <cloudhea1> lemme give it a go
14:35:28 <tolkad> thanks monochrom, apparently I need to update my ghc
14:36:22 <cloudhea1> acowley: what's that '***' ? it's telling me it's not in scope
14:36:31 <micahjohnston> cloudhea1: import Control.Arrow
14:36:46 <cloudhea1> micahjohnston: ty
14:37:56 <cloudhea1> acowley: doesn't seem to output on "EOF"
14:39:07 <acowley> cloudhea1: there may be a deficit of newlines
14:39:44 <cloudhea1> I tried "EOF\n" too
14:40:46 <acowley> no, I mean you need a newline to flush stdout
14:40:50 <acowley> if its line buffered
14:41:00 <cloudhea1> ohh
14:41:05 <acowley> you may want to replace the newlines that lines strips off
14:41:11 <acowley> so the second line of go would be
14:41:21 <acowley> markdownToHtml . conat . map (++"\n") *** go . tail)
14:41:22 <danharaj> hey lispy, you're the mentor for the openGL GSoC project right?
14:41:31 <acowley> or you could append a newline to markdownToHtml's output
14:42:27 <cloudhea1> acowley: still doesn't output
14:42:46 <cloudhea1> acowley: I think markdownToHtml outputs a new line at the end
14:42:55 <acowley> I guess I'm installing pandoc
14:43:02 <cloudhea1> oh
14:43:03 <cloudhea1> wiat
14:43:04 <cloudhea1> !
14:43:05 <cloudhea1> wait
14:43:05 <acowley> it worked for me with an identity function
14:43:11 <cloudhea1> if I add \n\n it works
14:43:53 <cloudhea1> but
14:44:03 <cloudhea1> it only outputs the 1st element
14:44:04 <cloudhea1> or something
14:44:09 <acowley> pandoc install failed
14:44:17 <acowley> argh
14:44:53 <sm> do exceptions in a child thread propagate to the parent ?
14:45:05 <cloudhea1> acowley: : /
14:45:16 <Saizan> sm: no
14:45:34 <sm> Saizan: thanks
14:46:20 <tolkad> the reason I couldn't install yesod is because I installed macports
14:46:47 <tolkad> which put /opt/local/bin in my path, which somehow had an ancient copy of ghc in it
14:47:11 <cloudhea1> acowley: https://gist.github.com/ba52e5f0a8deda52d532 this is what it does
14:48:04 <cloudhea1> so it seems like the last element becomes the head of the next list
14:53:03 <malorie> am I re-inventing the wheel here? http://ideone.com/Z6cQI
14:53:17 <malorie> or is there possibly a more elegant way to do it?
14:53:18 <acowley> cloudhea1: I'm reinstalling GHC so it'll take a few minutes
14:54:26 <acowley> malorie: Data.List.Split.splitEvery
14:54:32 <cloudhea1> acowley: aha ok : D
14:54:33 <acowley> from split on hackage
14:55:22 <acowley> malorie: but reinventing tiny wheels isn't so bad
14:55:32 <malorie> yeah. :)
14:55:39 <monochrom> but you may like the other functions of split too
15:00:50 <Alan> geheimdienst: this problem is kinda annoying because i'm running the exact same haskell installation on the exact same distro, but one of them is working and the other isn't.... :(
15:01:13 <Alan> geheimdienst: i definitely have "import Control.Monad.State" working on one machine just fine...
15:01:33 <Alan> maybe i ended up doing something with cabal rather than the package manager...
15:01:40 <Alan> can cabal list everything you've installed with it?
15:01:51 <beastaugh> ghc-pkg list
15:02:02 <beastaugh> that will show system packages too
15:02:20 <Alan> I don't want to show all packages installed
15:02:28 <beastaugh> ghc-pkg list --user
15:02:32 <Alan> I want to show packages i installed with cabal rather than "some other way"
15:02:49 <Alan> aha
15:02:56 <monochrom> cannot be distinguished really
15:02:57 <Alan> thanks
15:03:16 <Alan> well i can see enough that lets me know i have a user installation of mtl
15:03:27 <Alan> mtl-2.0.1.0
15:03:28 <d__> oh snap.
15:03:48 <Alan> what's the likelihood that that is incompatible with whatever my distro installs in it's libghc6-mtl package?
15:04:04 <acowley> cloudhea1: this works for me: ((++"\n") . markdownToHtml . concat . map (++"\n") *** go . tail)
15:04:04 <lispy> danharaj: yeah
15:04:09 <Alan> oh, i can answer that for myself...
15:04:22 <lispy> danharaj: did you have a question?
15:04:22 <Alan> distro installs mtl-1.x.x.x
15:05:10 <monochrom> with mtl-2, if you have code like "State (\x -> blah)" or "State $ \x -> blah", change State to state
15:05:26 <Alan> monochrom: yeah, i ran into that problem some time in the paste
15:05:29 <Alan> *past
15:05:43 <monochrom> that's pretty much the only change
15:05:58 <Alan> monochrom: my problem now is the other way around - I have code like "state $ ..." but MTL-1 is installed, not MTL-2
15:06:06 <Alan> but now i've found my problem
15:06:16 <Alan> i think the problem was something else depending on mtl-2
15:06:19 <Alan> maybe parsec-3?
15:06:43 <monochrom> parsec-3 is fine with either mtl's
15:07:21 <monochrom> but of course, as soon as you actually compile a package, the dependency is baked in based on what is seen at compile time
15:08:03 <monochrom> there is absolutely no ABI-compatibility story for ghc-compiled libs
15:08:45 <cloudhea1> acowley: yes, that works!
15:09:01 <cloudhea1> acowley: so that should be more efficient?
15:10:12 <Alan> i really can't remember what led me to install mtl-2 then...
15:10:31 <monochrom> promiscuos upgrade whore
15:11:18 <acowley> cloudhea1: I think so as the original version traversed every line for each new line while this one walks over everything once for the concat, and then again at the end to append the newline
15:12:11 <acowley> if efficiency is a concern, then some cuteness may have to be sacrificed
15:12:23 <aristid> Alan: you should use mtl-2 if possible.
15:12:45 <aristid> it supersedes both monads-fd and mtl-1
15:15:05 <danharaj> lispy: Does the student have a blog? I'd love to follow their progress.
15:23:46 <lispy> danharaj: I've asked pastorn to create one.  For now I would recommend joining the hopengl mailing list
15:24:17 <danharaj> lispy: Alright. Sounds like a good idea.
15:25:06 <danharaj> lispy: I'm currently undertaking an experiment in embedding shader interfaces (the set of in attributes and uniforms required) as types in Haskell to reduce the boiler-plate of initializing and calling shaders.
15:25:29 <danharaj> It's beyond my means right now but it seems like a good way to learn about type/data families.
15:27:15 <tolkad> Frankly, I think some parts of the bytestring library are careless
15:30:49 <dons> tolkad: really?
15:30:51 <dons> which parts?
15:34:42 <tolkad> dons: http://hackage.haskell.org/packages/archive/bytestring-nums/0.3.2/doc/html/Data-ByteString-Nums-Careless.html
15:35:10 <dons> oh that's weird. that's not part of the bytestring library though
15:37:31 <monochrom> oh dons, I learned a trick lately. http://www.amazon.com/Pointless-ByteStrings-Are-Pointless/dp/1593272839/
15:38:14 <dons> weird! how does that work
15:38:25 <c_wraith> amazone has always ignored anything before the /dp
15:38:30 <c_wraith> I usually just delete it all
15:38:31 <monochrom> heh
15:38:34 <c_wraith> err, amazon
15:38:39 <Peaker> Things I dislike about ByteStrings: A) duplicate API's with no "standard" type-class makes code overly specific.  B) strict/lazy BS's are bad names for the notions  C) Many H98/10 stdlib functions still use String so ByteString is buried deeper behind imports
15:38:41 <dons> heh
15:39:02 <dons> why are the names bad?
15:39:06 <monochrom> you can put "Secrets-Of-Java-Sex-Experts" there too :)
15:39:28 <monochrom> I think the names are not bad, just lack normal form
15:39:28 <Peaker> dons, because in many contexts, you get the names in unqualified form which is confusing, and because they are less suggestive of their meaning
15:39:29 <c_wraith> everything before the /dp is put there just for SEO
15:39:38 <dons> one is a strict buffer, one is a lazy list of buffers.
15:39:46 <dons> hmm. what would a better name be?
15:40:05 <acowley> lazy bytestring is somewhat rope- or chain-like
15:40:06 <Peaker> StrictBuffer and BufferList? :)
15:40:08 <c_wraith> forget "in many contexts"...  haddock is a sufficient context
15:40:09 <monochrom> oh, those bad names.
15:40:18 <Peaker> Or BufferRope?
15:40:20 <dons> hmm looks like Java.
15:40:22 <dons> its not a rope
15:40:34 <Peaker> Looking like Java is not necessarily automatically bad :)
15:40:39 <cheater99> dons: are you the right person to talk to about the hackage page which explains installing haskell platform, or should i take this to the package-maintainers mailing list?
15:40:41 <c_wraith> You have to hover over the name in haddock-generated html to know which bytestring it means
15:40:50 <monochrom> the day you chose camel case, you already chose to look like java
15:40:54 <dons> http://hackage.haskell.org/package/data-rope-0.3 
15:41:03 <monochrom> or look like ZomboCom
15:41:03 <dons> BufferFactory
15:41:21 <dons> cheater99: you can ask me, or send me email, or bring it up on the platform list.
15:41:34 <cheater99> dons: i choose gate 1
15:41:46 <acowley> SortOfRopeLikeBufferIMeanThereAreDiscretePiecesAndStuff
15:41:50 <dons> downside of here is that if i get interrupted, i won't be able to complete the answer
15:41:52 <cheater99> dons: i believe the "installation instructions" for ubuntu are confusing
15:41:59 <Peaker> What about ByteArray and ByteArrayList?
15:42:13 <cheater99> basically you click the ubuntu icon and get a list of packages for haskell platform.
15:42:36 <dons> cheater99: ah hmm
15:42:39 <cheater99> however the most popular version, 10.04 (and the only one commonly used for servers) doesn't have that
15:42:51 <dons> so the link to the Ubuntu package search page, you mean?
15:42:58 <cheater99> yes
15:42:58 <dons> http://packages.ubuntu.com/search?keywords=haskell-platform ?
15:43:03 <cheater99> yes
15:43:07 <Peaker> anyway, having tons of libraries only available for this kind of string but not the other is a big PITA
15:43:07 <dons> what's a better link?
15:43:14 <dons> no argument  there, Peaker 
15:43:19 <cheater99> 10.04 has a different package layout: packages ghc6, cabal-install, happy, etc
15:43:19 <dons> hysterical raisons
15:43:47 <dons> well, it doesn't officially support  the platform, does it?
15:43:57 <dons> its just a collection of libraries, but not necessarily the platform set
15:44:13 <dons> which was only officially supported when the platform metapackage appeared
15:44:19 <cheater99> no but it has all the components, and platform is the "catch all" installation instruction
15:44:21 <Peaker> I already asked about this but I forget what the answer was -- would it be possible to get as-optimized code from unboxed arrays of Word8 as we get from ByteStrings? Would it be possible to make Functor instances for UArray type constructors and other instances so that we can avoid duplicating many functions like "map"?
15:44:23 <dons> we only list efforts that attempt to comply
15:44:47 <dons> you can't write a functor for UArray
15:44:57 <dons> because of the unboxed constraint
15:45:13 <dons> oh, sorry, UArray in general? hmm
15:45:26 <dons> you could rewrite bytestring to be a Unboxed.Vector Word8 and get the same code
15:45:35 <dons> or a Storable.Vector so it would still be able to interact with C
15:45:47 <Peaker> Storable is also unboxed?
15:45:50 <acowley> installing unix-compat on Ubuntu has a serious pothole in the road
15:45:52 <Peaker> but also pinned?
15:46:01 <dons> es
15:46:02 <dons> y
15:46:09 <Peaker> ool
15:46:09 <Peaker> c
15:46:28 <dons> it's all the same rts primitives in the end
15:46:50 <Peaker> Maybe the restricted-monad approach allowing (R)monad instances for things like Set, could allow (R)functor instances for UArrays?
15:47:15 <dons> hmm. what would this buy you? restricted monads aren't that helpful are they, since they don't interoperate with base stuff
15:47:32 <dons> you can do it, but what is the value proposition?
15:47:38 <Peaker> I think Haskell has the most excellent polymorphism mechanisms of all mainstream languages -- but under-uses them greatly to the point where many basic functions are far less polymorphic than their equivalents in other languages :-(  (length for lists only? what??)
15:47:39 <cheater99> dons: ok, backtrack. when i google for "install haskell" i get this page: http://www.haskell.org/haskellwiki/Haskell_in_5_steps#Install_Haskell              it just tells me to install platform. I am not told that there's such a thing as ghc, so as a person new to Haskell i assume i need platform. I go to the platform page, see the package name, and figure it doesn't exist for my version of linux. this means i think there's no suppor
15:47:39 <cheater99> t for haskell in my linux, whereas the support is very good actually.
15:48:00 <Peaker> dons, Smaller vocabulary of functions for more functionality
15:48:06 <edwardk> peaker: the problem is throwing such classes on tops of data structures that have fundamentally different asymptotics.
15:48:09 <Peaker> dons, Not having to look at large module API's
15:48:15 <cheater99> maybe that wiki should mention the alternative of not installing platform where it's not available.
15:48:27 <dons> cheater99: ah. interesting
15:48:33 <Peaker> edwardk, In a language with laziness, that throws operational semantic concerns aside so much, that sounds bogus :)
15:48:37 <cheater99> dons: there's also a very bad alternative
15:48:37 <dons> cheater99: so for older ubuntus we should say something
15:48:56 <dons> yes, we kind of assume if it isn't available, you should install something else :)
15:49:00 <dons> but we can make that more obvious
15:49:02 <cheater99> dons: it's not necessarily "older", 10.04 will be supported way beyond when 10.10 and 11.04 stop being supported
15:49:05 <dons> hopefully everyone upgrades sooner
15:49:11 <Peaker> edwardk, there are many cases (the majority?) where the code is agnostic to the asymptotic complexity, and can be useful with either structure in differing circumstances 
15:49:14 <edwardk> peaker: i have many places in my code where i implement things differently depending on whether or not i'm gluing stuff together that has a cheap intrinsic append or if i have to supply one myself
15:49:16 <cheater99> 10.04's support for servers ends in 2015
15:49:23 <dons> we should backport   the package then
15:49:27 <dons> if it will be around that long
15:49:30 <cheater99> that would be the best
15:49:38 <cheater99> but here's another horror scenario
15:49:43 <dons> could you propose this on the haskell-platform list (or open a ticket)
15:49:45 <dons> or i will forget
15:49:46 <cheater99> i'm trying to install haskell on my vps
15:49:51 <cheater99> sure
15:49:51 <Peaker> edwardk, consider the Get monad/Put monoid -- do these only make sense on lazy bytestrings?
15:50:07 <cheater99> so i am trying to install, follow the instructions, figure out there's no package, so i try to install from source, right?
15:50:31 <cheater99> well, my vps has 256 MB ram and 4 GB hd quota
15:50:33 <Peaker> I think Get/Put should probably be polymorphic to Storable.Vector of non-Word8 too, which would require more polymorphic functions if they are also capable of working with ByteStrings
15:50:34 <dons> right. we do say that *if* you can get ghc, you'll be ok with the source bundle
15:50:41 <edwardk> peaker: the real question with Get and Put is can they be instantiated in any sense polymorphically and still be efficient =P
15:50:54 <Peaker> edwardk, why not? GHC can specialize them to the specific type in use?
15:51:08 <Peaker> edwardk, to get the current code, I'd venture
15:51:08 <cheater99> after 5 hours the usual person will give up trying to install platform
15:51:17 <dons> Peaker: some issues there though, around unchecked shifts and reads
15:51:37 <cheater99> because most people don't know what the OOM killer so won't know why suddenly their ssh session gets disconnected while they're building ghc
15:51:46 <cheater99> *what the killer is
15:51:48 <dons> cheater99: yeah, ideally they have more ram, and just install ghc from a binary bundle.
15:51:56 <Eduard_Munteanu> cheater99: why don't you cross-compile it?
15:52:00 <cheater99> but i don't know of the binary bundle
15:52:16 <Peaker> dons, sounds like high-performance functionality required of ByteStrings is mis-placed and implemented in Get/Put? Or is there really no way to move it to a polymorphic place?
15:52:18 <Eduard_Munteanu> Um, I rather mean build it somewhere else.
15:52:18 <cheater99> Eduard_Munteanu: because i'm lame and new to haskell, i just heard about it 5 minutes ago and it sounds cool
15:52:18 <dons> if you have a specific support request for older ubuntus, make the case, or perhaps attach a patch to the ticket with some proposed changes to the site and links
15:52:18 <luite> using ghc on a 256MB machine with no swap is asking for trouble anyway, even if you can get it installed
15:52:26 <cheater99> dons: yeah will do
15:52:33 <edwardk> peaker: that said, i have started collecting small classes for dealing with some of these common ad hoc overloads
15:52:45 <edwardk> peaker: (not necessarily with buffers/sequences in mind)
15:52:49 <Peaker> edwardk, cool.. what do you have?
15:52:54 <Eduard_Munteanu> I think even building GCC or the Linux kernel is tough on such machines.
15:53:06 <edwardk> peaker: they do almost all take me out of haskell 98 though\
15:53:13 <cheater99> Eduard_Munteanu: yeah, i'm just channeling the "typical newbie" right now
15:53:21 <edwardk> peaker: the dependencies of the 'representable-functors' package, one sec.
15:53:25 <cheater99> dons: thanks for the direction, i'll get onto it
15:53:26 <Peaker> edwardk, I like Functor/Applicative/Traversable for these kinds of vocabularies, but the unbox-constraint ruins it :(
15:54:08 <edwardk> http://hackage.haskell.org/packages/archive/representable-functors/0.3.0.3/doc/html/Data-Functor-Representable.html is sort of the goal i was building towards, but along the way i built
15:54:24 <edwardk> http://hackage.haskell.org/packages/archive/keys/0.2.3/doc/html/Data-Key.html
15:54:33 <edwardk> which is a bit of a horrible mishmash, given that i didn
15:54:40 <edwardk> didn't split out all those classes into separate modules
15:55:18 <edwardk> that latter provides a lot of the mapWithKey, foldwithKey, etc. machinery that appears so often but isn't provided by a class.
15:56:01 <edwardk> it turns out that representable functors (in the category theoretic sense) have some very nice properties in this regard and give us a well defined notion of a key, that we can recycle for other types.
15:56:27 <edwardk> (the key is the object used in the 'representation' of the functor)
15:57:07 <edwardk> (a representable functor f is isomorphic to (->) x for some choice of key x.)
15:57:43 <TheZimm> is there a package already out there that does like a webserver type thing?
15:58:00 <edwardk> thezimm: a few
15:58:04 <Twey> All of them?
15:58:12 <edwardk> they get into benchmarking wars occasionally ;)
15:58:18 <TheZimm> erm anybody care to point me to one? :D
15:58:23 <TheZimm> their favorite
15:58:23 <Twey> I don't think there's a web framework on Hackage that doesn't have its own server
15:58:30 <Twey> Snap's nice
15:58:32 <TheZimm> :P
15:58:34 <Twey> There's Yesod too
15:58:37 <Twey> And Happstack
15:58:44 <Twey> I hear that's better lately
15:58:49 <edwardk> snap is cute: http://snapframework.com/
15:58:57 <TheZimm> web framework... meaning what?
15:59:08 <dons> TheZimm: http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks 
15:59:18 <TheZimm> ah nice
15:59:20 <TheZimm> ok cool
15:59:34 <edwardk> it provides a small web server and a bunch of combinators for putting together a web site/web service on it
15:59:40 <tolkad> best practice in haskell is to use non breaking spaces instead of camel case or hyphens
15:59:52 <dons> umm
15:59:53 <Peaker> edwardk, reading your above wall of text :-) 
15:59:59 <tolkad> @let test function = id
16:00:00 <lambdabot>  Defined.
16:00:06 <tolkad> > test function 5
16:00:07 <lambdabot>   Not in scope: `function'
16:00:12 <tolkad> nevermind
16:00:26 <tolkad> who's idea was it to make non breaking spaces count as whitespace?
16:00:26 <aristid> > test "tolkad" 5
16:00:27 <dons> best practice is obviously embedded apostrophes
16:00:28 <lambdabot>   5
16:00:51 <dons> > let this'n'that x y = x ++ "--" ++ y
16:00:52 <lambdabot>   not an expression: `let this'n'that x y = x ++ "--" ++ y'
16:00:57 <dons> ?let this'n'that x y = x ++ "--" ++ y
16:00:58 <aristid> > let test'dons = 5
16:00:59 <lambdabot>   not an expression: `let test'dons = 5'
16:00:59 <lambdabot>  Defined.
16:01:01 <aristid> > test'dons
16:01:01 <lambdabot>   Not in scope: `test'dons'
16:01:08 <dons> > this'n'that "foo "bar"
16:01:09 <lambdabot>   <no location info>:
16:01:09 <lambdabot>      lexical error in string/character literal at end o...
16:01:09 <aristid> > let test'dons = 5 in test'dons
16:01:10 <lambdabot>   5
16:01:44 <tolkad> @let test᠎ 	function = id
16:01:44 <lambdabot>  <local>:6:0:
16:01:44 <lambdabot>      Multiple declarations of `L.test'
16:01:44 <lambdabot>      Declared at: <local...
16:01:50 <shachaf> @let don'tFinishYet = True
16:01:52 <lambdabot>  Defined.
16:01:57 <tolkad> drat, they got the mongolion vowel seperator
16:02:08 <Peaker> edwardk, what's (Key []) ?
16:02:16 <Peaker> ah, I see
16:02:24 <edwardk> peaker: Int (should be Nat arguably)
16:03:13 <aristid> edwardk: is Nat the lazy positive integer type, or just a positive integer type?
16:03:38 <edwardk> aristid: in this case, a very good question ;) i'd probably go with a conat, since we're indexing a codata list
16:03:50 <aristid> edwardk: conat being?
16:03:55 <edwardk> the lazy natural type
16:04:10 <edwardk> the one harper was bitching about the other day
16:04:14 <Peaker> transformers' Compose seems redundant to TypeCompose?
16:04:16 <aristid> edwardk: i think GHC should have a strict natural type built-in
16:04:20 <tolkad> @let test	function = id
16:04:20 <lambdabot>  <local>:7:0:
16:04:20 <lambdabot>      Multiple declarations of `L.test'
16:04:20 <lambdabot>      Declared at: <local...
16:04:35 <tolkad> let's take this out back lambdabot 
16:04:47 <TheZimm> aight snap is awesome, once again haskell strikes again, thanks guys
16:05:09 <edwardk> peaker: i need transformers for other things, I don't need nor want most of the crap and extensions used in TypeCompose. so transformers wins ;)
16:05:30 <edwardk> peaker: most of my modules try for haskell 98, keyed/representable are pretty high on the tower and don't have that luxury though
16:05:37 <pmetzger> The Haskell 2010 document seems to treat ascii letter characters as though they aren't a strict subset of unicode. how... odd.
16:05:49 <pmetzger> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html
16:06:55 <Peaker> edwardk, the keys package seems pretty cool -- hope it kills ListLike
16:07:12 <edwardk> pmetzger: put in a qrequest to malcolm ;) he is still heading things up no?
16:07:20 <pmetzger> I have no idea. I'm a newb.
16:07:41 <edwardk> Peaker: i want to factor it out a little better before i encourage its adoption. e.g. Zippable belongs in a smaller haskell 98 package
16:07:49 <gwern> @unlet
16:07:50 <lambdabot>  Defined.
16:07:53 <tolkad> why is lambdabot telling me Illegal character ''\8290''
16:08:05 <tolkad> INVISIBLE TIMES is a perfectly fine character
16:09:17 <Peaker> edwardk, Needing a new class for Applicative-without-pure :-(  Almost makes one want to support a one-method-per-class restriction
16:09:34 <Zao> tolkad: Not in the right category for whatever you tried using it for?
16:09:36 <Peaker> Referring to semi-groupoids Apply class
16:09:45 <edwardk> peaker: actually it is a rather nice class. it indicates that static arrow composition forms a semigroupoid.
16:09:54 <tolkad> Zao: I'm trying to embed spaces in my function names
16:10:00 <Peaker> edwardk, But it should superclass Applicative?
16:10:12 <edwardk> peaker: and is effectively the 'Zip' part of the 'ComonadZip' class described by tarmo and uustalu
16:10:12 <edwardk> yes
16:10:44 <edwardk> but then Bind should also superclass Monad (indicating kleisli composition is a semigroupoid), which is awkward because then you wind up with classes that only state laws and which just piss people off for existing
16:11:38 <tolkad> > idid5
16:11:39 <lambdabot>   Not in scope: `idid5'
16:11:44 <Peaker> edwardk, we need a relationship that isn't superclass but something like "has at least the power of", which perhaps can be specified independently of the two classes
16:11:49 <edwardk> basically i just pretend those are superclasses where i can. nothing else i can do for now.
16:11:55 <tolkad> @let abc = id
16:11:56 <lambdabot>  Defined.
16:12:00 <tolkad> > abc 5
16:12:01 <lambdabot>   5
16:12:05 <Peaker> (and then you can use it to auto-derive an instance for the no-longer-superclass, if you want)
16:12:35 <tolkad> it completly ignores zero width space? why wont ghc let me have any fun with unicode?
16:13:11 <Peaker> class instance Monad m => Applicative m where pure = return ; (<*>) = ap
16:13:42 <tolkad> "class instance"? what does that do?
16:13:47 <Peaker> fictional thing :)
16:14:06 <Peaker> It adds a superclass relationship after-the-fact, in a way that allows adding it as an orphan
16:15:11 <Peaker> maybe:  instance family? :-)
16:15:21 <tolkad> classtance
16:18:24 <pmetzger> I presume ghc does not let me spell \ as λ?
16:19:12 <Axman6> i think you can with an extension
16:19:49 <aristid> how vain
16:20:04 <Cale> It would get in the way of people wanting to use Greek identifiers
16:20:22 <Cale> unless perhaps you used the mathematical lambda for the lambda syntax
16:20:24 <ion> You can?
16:20:30 <Peaker> Arrg. I wish programming languages rejected unicode
16:20:53 <Peaker> 26^length is so much nicer than 26*more-alphabets
16:21:06 <tolkad> pmetzger: UnicodeSyntax works with some stuff but not that
16:21:15 <Peaker> more scalable and can convey meaning to a wider audience at virtually no cost
16:21:19 <Cale> Peaker: what are those numbers?
16:21:38 <Axman6> >( λx -> x*x) 7
16:21:39 <Cale> 26^length vs. (26 + more alphabets)^length ?
16:21:45 <Peaker> Cale, 26^length -- the namespace size of scaling up variable name length
16:21:56 <Axman6> > ( λx -> x*x) 7
16:21:57 <lambdabot>   Pattern syntax in expression context:
16:22:06 <ion> > let λ = 42 in λ
16:22:06 <lambdabot>   42
16:22:11 <Peaker> Cale, 26*length -- 26 is a bit inappropriate, but adding greek and who knows what not, you only multiply the namespace by a small factor
16:22:18 <shachaf> > let λ = text "nope" in λ
16:22:19 <lambdabot>   nope
16:22:27 <Peaker> Cale, It's a case against 1-letter-names and the silly unicode that they bring
16:23:42 <Cale> but adding more alphabets surely only increases namespace size
16:23:52 <ion> peaker: How about the Unicode in \length → 26 · length ∷ Integer → Integer?
16:24:57 <nyingen> this is suddenly reminding me of Squeak Smalltalk's disastrous font experimenst
16:25:01 <nyingen> experiments
16:25:20 <pmetzger> what was the nature of the experiment and the disaster following it?
16:26:05 <Peaker> Cale, it has annoying side effects
16:26:17 <Peaker> and shuns away even more people who could join and contribute
16:26:25 <Peaker> ion, Yuck :)
16:26:56 <Cale> But surely Chinese people should be able to use Chinese identifiers if they want to?
16:27:48 <nyingen> pmetzger: They wanted various arrow symbols to be usable in the source code, so they packaged a customized font with the system
16:27:48 <pmetzger> things like ⊂ and ⊥ and ↦ seem reasonable.
16:28:04 <nyingen> pmetzger: I guess it would have been fine, except that they just switched ^ for up-arrow and _ for right arrow
16:28:47 <pmetzger> that wasn't squeak
16:29:01 <pmetzger> that was the old Smalltalk, in the days when ASCII was still a bit less settled.
16:29:08 <nyingen> I may be remembering incorrectly, but I'm pretty sure early versions of squeak did that too?
16:29:11 <pmetzger> in the 1970s, those were things you would find on some printing terminals.
16:29:12 <tolkad> @let ⊥ = 42
16:29:12 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8869) is outside of bounds (0,255)
16:29:44 <pmetzger> anyway, I can see why ∨ and ∧ would be too similar to other symbols, but some math seems reasonable...
16:29:49 <ion> My opinion is that source code should not have layout at all and all editors and viewers should render it in an optimal way, creating the appropriate layout in render time (depending on things such as window width), and using proportional fonts and fancy symbols for things if appropriate, like e.g. lhs2TeX does.
16:30:13 <tolkad> pmetzger: those are and/or right?
16:30:25 <tolkad> or respectively or/and
16:31:20 <Draconx> ion, unfortunately, computer programs are notoriously bad at aesthetics.
16:31:46 <pmetzger> not is 
16:31:48 <pmetzger> gah
16:32:09 <beastaugh> does someone have a minute to help me with some slightly confusing IO behaviour?
16:32:11 <djahandarie> I think I shouldn't see anything on the screen than I can't enter directly with my keyboard, assuming I'm suppose to edit it with a keyboard. I think meta-operations on the text like cut and paste are fine to map to control character combinations and such on the keyboard, but any direct text being entered should be directly mapped to keys.
16:32:12 <ion> draconx: I’m fine with rendering hints being added to the source based on how the user modifies the layout. They could still be ignored if that’s required to render it nicely on a small PDA screen for instance.
16:32:18 <beastaugh> https://gist.github.com/943054
16:32:24 <pmetzger> ¬ is pretty unambiguous
16:32:35 <beastaugh> I wanted to replace line 59 with the following
16:32:37 <beastaugh> let packages = filter (not . hasExtension) . map (combine path) . drop 2 $ dirContents
16:32:42 <pmetzger> I can enter all those symbols with my keyboard.
16:32:52 <djahandarie> No you can't
16:32:52 <pmetzger> latex syntax autoconverted to unicode.
16:33:01 <djahandarie> You have latex syntax on your keys?
16:33:07 <pmetzger> I can just type \lnot and it dos the right thing.
16:33:08 <beastaugh> but I get the following error:
16:33:11 <beastaugh> CountLicenses: ./index/preferred-versions: getDirectoryContents: inappropriate type (Not a directory)
16:33:23 <djahandarie> pmetzger, that involves more than your keyboard
16:33:30 <djahandarie> It involves having that symbol memorized, for one
16:33:32 <pmetzger> TeX input mode in emacs, unicode translation service on Mac.
16:33:38 <beastaugh> what confuses me is that the lists are identical
16:33:42 <pmetzger> you have to memorize what "(" means too. :)
16:33:48 <djahandarie> pmetzger, not to enter it.
16:34:04 <djahandarie> We haven't even got to definitions of what these characters mean, just reading and entering them.
16:34:10 <pmetzger> eh, it isn't much of an issue, though you can easily get a space cadet keyboard. :)
16:34:12 <pmetzger> if you really want to.
16:34:27 <pmetzger> http://en.wikipedia.org/wiki/Space-cadet_keyboard
16:34:32 <djahandarie> Except there is no keyboard which holds all of Unicode
16:35:29 <shachaf> beastaugh: Presumably ./index/preferred-versions is not a directory?
16:35:59 <beastaugh> shachaf: that must be it, thanks
16:36:12 <beastaugh> still confused as to why the lists didn't differ
16:36:24 <beastaugh> oh well :)
16:36:27 <shachaf> beastaugh: Lists?
16:36:30 <Draconx> djahandarie, so you think that Japanese speakers should not be able to write Japanese in source files?
16:36:35 <beastaugh> lists of FilePaths
16:36:42 <beastaugh> formed from both methods
16:37:33 <djahandarie> Draconx, that's a different issue than using Unicode for math symbols. And all the Japanese people I know code in English anyways. :)
16:38:52 <Draconx> djahandarie, well, typing math symbols into a source file is hardly any different from typing kanji into a source file.
16:39:15 <djahandarie> Except all Japanese already know how to read kanji and how to enter it.
16:39:17 <Draconx> (probably more similar to kana, actually)
16:39:36 <djahandarie> いいえ、漢字のような、多分
16:39:41 <Draconx> djahandarie, and all mathematicians already know how to read math symbols and how to enter them :)
16:40:12 <djahandarie> Draconx, and programmers aren't LaTeX trained robots like mathematicians are
16:40:23 <hpc> djahandarie: that's a bug
16:40:40 <hpc> (not that programmers aren't latex robots, but that they aren't also mathematicians :P)
16:41:20 <neophyte> what is a “prefix-free universal computable function” ? 
16:41:24 <djahandarie> I read plenty of math papers and know how to use LaTeX, but I still hate any papers that over-use odd symbols. And that's before I need to edit them, like I would need to with source code
16:41:33 <neophyte> I know what a computable function is.
16:41:52 <neophyte> How is “prefix” defined
16:42:18 <djahandarie> neophyte, http://en.wikipedia.org/wiki/Chaitin's_constant#Background
16:42:26 <djahandarie> All the terms seem to be defined there
16:42:29 <crystal-cola> delusional psudoscence
16:43:10 <pmetzger> Most of the Haskellers I know write their papers in LaTeX
16:43:20 <neophyte> “The function F is called prefix-free if there are no two elements p, p′ in its domain such that p′ is a proper extension of p. “ -- so what is meant by “p’ is a proper extension of p” 
16:43:31 <danharaj> Some Haskelletors write their programs in LaTeX :p
16:43:42 <hpc> haha, haskelletor
16:44:01 <parcs> @pl (\
16:44:01 <lambdabot> (line 1, column 3):
16:44:01 <lambdabot> unexpected end of input
16:44:01 <lambdabot> expecting pattern
16:44:26 <djahandarie> pmetzger, a stupid practice, if I may add. It gets very hard for me to read some code in these papers simply because I don't remember what symbol was used for one thing
16:44:36 <parcs> @pl (\x b -> x .&. b == b)
16:44:36 <lambdabot> join . ((==) .) . (.&.)
16:44:46 <djahandarie> I've talked about this in here before and other people seem to not have this problem, but I have a really big issue with memorizing new characters
16:45:02 <pmetzger> I have no more trouble reading LaTeX than I do reading Haskell itself. It is just a syntax.
16:45:07 <danharaj> djahandarie: I find it helpful to write new symbols over and over again to remember them.
16:45:21 <neophyte> djahandarie, i’m not sure how ‘proper extension’ is defined
16:45:23 <djahandarie> danharaj, and you want to do this for every Haskell program you ever open in the future? :p
16:45:27 <Twey> djahandarie: … so you decided to learn Japanese?
16:45:35 <aristid> @let (<=>) = compare
16:45:36 <lambdabot>  Defined.
16:45:45 <aristid> > 4 <=> 5
16:45:45 <djahandarie> Twey, yes, and I suck at it. :)
16:45:45 <danharaj> Well they really shouldn't be using many weird symbols beyond standard math practice and overlapping multi-character operators.
16:45:46 <lambdabot>   LT
16:45:58 <neophyte> djahandarie, do you know what is meant by that, and can you give me an example
16:45:59 <djahandarie> danharaj, ever opened an Agda file before?
16:46:11 <danharaj> djahandarie: Those are wizards and I do not dare tread in their domain.
16:46:22 <gwern> meddle not in the files of wizards
16:47:31 <pmetzger> Anyway, I don't see why ⊕ would be too hard to remember while .&. or what have you is crystal clear. :)
16:47:58 <pmetzger> but I realize this discussion is non-terminating.
16:48:48 <gwern> pmetzger: things you can type are easier to remember than random ideograms
16:48:58 <djahandarie> neophyte, I'm not 100% sure, but I think '56' would be a proper extension of '5'
16:49:17 <neophyte> k
16:49:43 <pmetzger> I can type ⊕. I just did.
16:50:06 <djahandarie> pmetzger, no you can't. You typed in some other junk and it turned into that via some enormous mapping
16:50:22 <djahandarie> And having that enormous mapping memorized is no longer considered 'typing' in my book 
16:50:29 <danharaj> do typeclass names and type names live in separate namespaces?
16:50:47 * djahandarie is actually not sure of the latex for that symbol, either
16:50:54 <danharaj> It's a common operator :p
16:50:56 <Draconx> djahandarie, so... Japanese people are not "typing" when they enter Japanese text into a computer?
16:50:58 <pmetzger> I'd have to memorize a keyboard location containing a bunch of shift keys on a space cadet keyboard. no functional difference.
16:51:06 * hackagebot MagicHaskeller 0.8.6.1 - Automatic inductive functional programmer by systematic search  http://hackage.haskell.org/package/MagicHaskeller-0.8.6.1 (SusumuKatayama)
16:51:50 <noteventime> djahandarie: \oplus
16:51:51 <djahandarie> Draconx, they are typing and also doing a large amount of conversion. So yes, I'd argue that they are not 'just typing' in the same sense.
16:52:02 <aristid> omg this package will make us all redundant
16:52:07 <Twey> djahandarie: TUT-Code
16:52:40 <danharaj> aristid: Don't worry. It has no documentation whatsoever ;)
16:52:48 <djahandarie> Twey, yeah, you've mentioned this before, I want to learn it
16:52:53 <byorgey> danharaj: no, they are in the same namespace
16:52:53 <hpc> i sort of want to see someone make a full-size kanji keyboard
16:53:04 <hpc> kanji/hirigana
16:53:08 <aristid> danharaj: danjhttp://nautilus.cs.miyazaki-u.ac.jp/~skata/doc/html/MagicHaskeller
16:53:09 <djahandarie> noteventime, thanks
16:53:13 <aristid> without danj
16:53:16 <Zao> hpc: You'd need a finglonger for that.
16:53:18 <aristid> http://nautilus.cs.miyazaki-u.ac.jp/~skata/doc/html/MagicHaskeller
16:53:18 <danharaj> What set of kanji? The standard set taught in schools?
16:53:20 <Twey> djahandarie: http://www.geocities.jp/ken1noguchi/TUT-CODE/e-index.htm
16:53:29 <danharaj> Because there's some really friggin obscure kanji that like 10 people know.
16:53:34 <danharaj> And they all work in the same department :p
16:53:53 <boris``> hiragana wouldn't be that bad, there are only 46, plus a few combinations
16:53:54 <pmetzger> people who type in kanji do more or less what I'm doing when I enter λ.
16:54:13 <pmetzger> that is, they generally type a "cryptic sequence" that isn't actually cryptic.
16:54:15 <hpc> pmetzger: alt+shift, l, alt+shift?
16:54:28 <pmetzger> I was typing \lambda actually.
16:54:32 <hpc> ah
16:54:34 <pmetzger> and \oplus etc.
16:54:36 <Twey> aristid: Is that real?
16:54:38 <pmetzger> TeX input method.
16:54:54 <hpc> i need to work on my tex keyboard
16:55:02 <aristid> Twey: no idea
16:55:06 <djahandarie> pmetzger, and the way they learned these sequences is through years of induction of compulsory education
16:55:08 <aristid> Twey: but hackagebot announced it :)
16:55:16 <Twey> Haha
16:55:17 <pmetzger> emacs has a TeX input mode, and I discovered there's a mac input service that will let you do the same thing.
16:55:20 <gwern> magichaskeller has been around for years
16:55:30 <gwern> I emailed the dude like 2 or 3 years ago offering to cabalize it
16:55:38 <djahandarie> pmetzger, which is a friggin' ridiculous requirement for programming.
16:55:44 <pmetzger> dunno, I don't find \pi so hard to remember that I'd need years to learn it.
16:56:03 <pmetzger> π seems easy as pi to me.
16:56:11 <pmetzger> and as pie. and as \pi
16:56:15 <Twey> *groan*
16:56:39 <noteventime> Easy as goblin \pi
16:56:49 <Twey> http://www.neo-layout.org/
16:56:51 <Twey> Also
16:57:01 <pmetzger> ⊆ is "\subseteq" -- not exactly years of memorization.
16:57:14 <pmetzger> esp. since it is the subset equal symbol.
16:57:29 <pmetzger> it isn't like I had to memorize the hex unicode codepont.
16:57:33 <pmetzger> er codepoint.
16:57:38 <djahandarie> pmetzger, how about ♭ ♯ ≈ ⊑ ⇒ ⊆ →
16:57:47 <pmetzger> I know all of those.
16:57:48 <crystal-cola> \pi = 3.14159587892345
16:57:55 <pmetzger> well, not the musical sharp.
16:57:55 <djahandarie> pmetzger, and what is your background?
16:58:02 <pmetzger> computer scientist.
16:58:22 <gwern> djahandarie: what the heck is that second one? It almost looks like one of the korean hangul
16:58:22 <pmetzger> with a bunch of chemistry and physics thrown in to the mix. some background in a smattering of other fields.
16:58:33 <Twey> ?
16:58:34 <djahandarie> gwern, musical sharp.
16:58:36 <Twey> It's a sharp sign
16:58:40 <gwern> oh
16:58:48 <djahandarie> (These were pulled from the nearest Agda file.)
16:58:53 <Twey> Haha
16:59:05 <djahandarie> Literally. I already had it open.
16:59:15 <jaspervdj> dons: Well, thanks for the confidence. I'll try not to let you down ;-)
16:59:35 <gwern> djahandarie: why does your agda file have musical notation in it?
16:59:47 <djahandarie> gwern, because they use it for coinductive types. Don't ask me why.
16:59:52 <pmetzger> there's also a service out there that lets you draw a character and it tells you the LaTeX name for it. very slick.
16:59:54 <gwern> o.0
17:00:13 <pmetzger> http://detexify.kirelabs.org/classify.html
17:00:17 <pmetzger> works kind of nicely.
17:00:29 <djahandarie> gfold f P _⊕_ ∅ (x ◅ xs) = x ⊕ gfold f P _⊕_ ∅ xs -- here's a nice line
17:00:44 <djahandarie> This stuff just hurts my head.
17:00:51 <pmetzger> why?
17:00:56 <pmetzger> it isn't worse than math.
17:01:10 <pmetzger> p plus null, nice notation.
17:01:18 <pmetzger> well, circleplus.
17:01:21 <DasIch> it's just very inconvenient to type
17:01:23 <crystal-cola> it isn't worse than math. <--- hahaha
17:01:34 <djahandarie> pmetzger, because I'm not reading it, I'm writing it
17:01:43 <djahandarie> And it's also more annoying to read.
17:01:48 <djahandarie> But that's a side issue
17:01:54 <pmetzger> what are you writing it with? what editor?
17:02:06 <pmetzger> what input method?
17:02:11 <pmetzger> that makes a lot of difference
17:02:22 <djahandarie> Emacs with agda-mode, the only way.
17:02:28 <DasIch> pmetzger: vim
17:02:31 <pmetzger> turn on tex input mode.
17:02:40 <pmetzger> it is a pleasant improvement.
17:02:50 <pmetzger> bbl.
17:04:58 <jaspervdj> dons: There's actually a chance it won't succeed, i.e. when UTF-16 is actually really the faster option
17:05:20 <jaspervdj> dons: In that case, I hope to bring a huge benchmark suite & a number of general optimizations to the text package
17:05:32 <acfoltzer> pmetzger: thanks for the tip; that's pretty neat. less obtrusive for normal input than I would have figured
17:05:43 * djahandarie imagines a post-unicode-apocalypse world: "Cadet A: Imagine if we had symbols in our files which gave us instructions on how to enter the symbol, visually!;  Cadet B: Brilliant! That could eliminate years from the mandatory LaTeX initiation!"
17:06:24 <djahandarie> (Translated from Unicode into ASCII)
17:06:49 <Saizan> you look at your keyboard?
17:07:27 <djahandarie> I don't, but I look at the letters on the screen.
17:09:06 <Saizan> how do the letter on the screen help then? it's not like you're visually mapping them to something ;)
17:11:23 <djahandarie> They help because I, and everyone else, knows how to type them already through years of induction in compulsory education.
17:12:12 <pmetzger> I have to write papers in latex constantly. :)
17:12:44 <Saizan> ok, so it's a "i'm already used to this shit, i don't want to learn new shit" argument, which can be used for almost anything though..
17:12:45 <djahandarie> I don't know why we want to appeal to the LaTeX paper writers rather than the consideribly larger mass of English speakers.
17:12:59 <pmetzger> This is Haskell we're talking about, right?
17:13:17 <djahandarie> pmetzger, which is a programming language, yes.
17:13:25 <djahandarie> Saizan, I don't know why that invalidates it in this case.
17:13:28 <pmetzger> I don't think the average english speaker is going to have an easy time understanding programming, let alone functional programming, let alone purely functional programming.
17:13:45 <djahandarie> pmetzger, just because something is complex doesn't mean you should make it even more complicated.
17:13:47 <crystal-cola> what are we complaining about?
17:13:52 <pmetzger> unicode. :)
17:13:54 <Saizan> djahandarie: it's just not convincing for me :)
17:13:59 <crystal-cola> I think unicode is stupid
17:14:11 <hpc> pmetzger: i don't think the average english speaker is going to have an easy time understanding purely functional programming, let alone abstract math
17:14:19 <pmetzger> precisely.
17:14:20 <djahandarie> (Not to mention, I think that purely functional programming is easier than other sorts of programming anyways.)
17:14:35 <hpc> pmetzger: except that abstract math is part of every student's curriculum
17:14:37 <pmetzger> djahandarie: you're possibly unusual.
17:14:49 <pmetzger> abstract math is part of nearly no student curricula.
17:14:52 <djahandarie> pmetzger, possibly. I don't see it that way though.
17:15:15 <djahandarie> There are a lot of folks who agree with me, at least.
17:15:21 * hpc is counting algebra, because it relies on group and ring properties
17:15:29 <pmetzger> djahandarie: this is a very odd group.
17:15:44 <crystal-cola> everyone should know group theory
17:15:52 <crystal-cola> and logic
17:15:53 <pmetzger> or ring, or field, or whatever we are.
17:16:09 <Saizan> you wouldn't judge haskell by how well a java programmer is able to use it, and i use the same standard for unicode and input methods
17:16:11 <crystal-cola> otherwise how are people going to think correctly?
17:16:13 <pmetzger> crystal-cola: everyone should also know how to read. something like 10% of the population can't read well enough to follow directions
17:16:35 <DasIch> i'm amazed at the effort the community is willing to take to promote haskell to a larger user group
17:16:43 <hpc> Saizan: if only people judged java by how well java programmers could use it ;)
17:16:56 <JimmyRcom> if I have a list that's 1000 elements, what's the easiest way to make it into a list of sublists that are 10 elements long each
17:17:08 <sm> how can I tell cabal install not to rebuild installed package versions on which other installed packages depend ?
17:17:20 <djahandarie> Saizan, I think the programming charset is core enough to entirely scare someone away from a language, despite it being almost entirely disjoint from the language.
17:17:22 <Saizan> JimmyRcom: there's a split package on hackage with a function to do that
17:17:40 <JimmyRcom> thank you Saizan
17:17:42 <djahandarie> Saizan, which is what leads me to make 'we should use this shit that everyone knows' argument here.
17:17:47 <hpc> it's also a good function to write yourself, if you are new
17:18:07 <Saizan> djahandarie: more than purity? more than totality?
17:18:16 * sm wants the opposite of cabal install --upgrade-dependencies
17:18:36 <hpc> sm: what would that be?
17:18:40 <djahandarie> Saizan, purity and totality are fairly integral to the language. A charset can be swapped in and out and have no effect.
17:18:43 <hpc> cabal install --go-back-in-time?
17:19:17 <Saizan> djahandarie: yeah, but if someone is scared away by just that, maybe he should flee anyway :)
17:19:33 <crystal-cola> totality? What language
17:19:33 <sm> hpc: --no-rebuild-installed-dependencies .. is that clearer ?
17:19:55 <sm> eg do not screw a zillion packages by rebuilding certificate-0.7 on which everything was depending
17:20:09 <hpc> sm: ah
17:20:12 * Saizan remembers someone who fled in horror at the sight of haskell's record system
17:20:23 <djahandarie> I'm fine if people are scared away by purity and totality, because these concepts give us something irreplacable. Unicode on the other hand gives us not very much except some comfort for the people who have already been indoctrinated.
17:20:25 <hpc> i like records!
17:20:26 <Draconx> Saizan, a prudent reaction.
17:20:52 <ion> At least it’s not as bad as Erlang’s.
17:21:50 <Saizan> Draconx: he wasn't the most pleasant person, so i've stopped thinking about a nicer record system since that day :)
17:22:15 <drhodes> has anyone managed to get a haskell helloworld on android?
17:22:15 <sm> jeez.. even my haskell-platform package is broken. I wonder how to get back to certificate-0.7.0-5786fd005074a3d50d2cc451f9d87c8f.
17:23:28 <sm> install it from the HP source dir perhaps
17:23:52 <ion> main = putStrLn "#include <stdio.h>\nint main (void) { printf (\"Hello world\\n\"); }"
17:23:54 <sm> no, it's not part of HP
17:25:53 * monochrom still doesn't fathom the semantics of --preference and --constraint in cabal-install
17:28:08 <jaspervdj> Off to bed, bye
17:28:24 <xplat> > const . fix $ const . fix
17:28:25 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b1 -> b1)
17:28:25 <lambdabot>    arising from a u...
17:28:25 <danharaj> is there a standard binary operator type constructor for constructing tuples with data families?
17:29:44 <sm> monochrom: what's tricky about --constraint ? 
17:30:05 <sm> other than it not supporting all the syntax claimed in the manual ?
17:30:32 <monochrom> no, if cabal-install provided --constraint alone, it would not be tricky
17:30:53 <monochrom> the fact that there are both --preference and --constraint is tricky
17:31:01 <Saizan> --preference is soft
17:31:15 <Saizan> "it'd be better, but it's not an error if you can't"
17:31:39 <monochrom> well I would love to believe that too. but --constraint can be softer than --preference
17:31:41 <Draconx> Saizan, ah, so next time someone's annoying me, I should just show them Haskell's record system and they'll go away! :)
17:32:09 <monochrom> so, I'm playing with 6.12.3 again lately. this means the base-3 and base-4 fun land
17:32:23 <Saizan> ah, yeah, there's a bug wrt base
17:32:29 <monochrom> cabal install --constraint='base >= 4' binary  uses base 3
17:32:36 <monochrom> cabal install --preference='base >= 4' binary  uses base 3
17:32:39 <monochrom> err
17:32:41 <monochrom> cabal install --preference='base >= 4' binary  uses base 4
17:32:53 <Saizan> yeah --constraint for base is a noop
17:32:55 <monochrom> --constraint is less binding than --preference
17:33:22 <monochrom> well alright then I think we've sorted it out. except for base, constraint is harder than preference
17:34:15 <monochrom> it's a poor decision in retrospect
17:34:25 <Saizan> Draconx: i'm convinced that was actually its intended purpouse
17:34:43 <monochrom> yes, we needed a special case for base, but not in the semantics of --constraint
17:34:58 <mornfall> Is there a better way to write (1 :: Int)?
17:35:18 <aristid> mornfall: what's wrong with that way?
17:35:36 <mornfall> Ugly: [(1 :: Int)..]
17:35:44 <aristid> [1 ..] :: [Int]
17:35:54 <mornfall> It's in an application
17:35:57 <Saizan> monochrom: the "drag along base 3 too anyway" logic should have applied only to dependencies maybe
17:36:00 <danharaj> I am deathly afraid that once I get to the point where I want to compile my data family code for the first time, the errors will be completely indecipherable.
17:36:02 <aristid> [1 :: Int ..]
17:36:06 <aristid> the parens are not necessary
17:36:23 <mornfall> Ah, it was the space then.
17:36:26 <aristid> > [1 :: Int ..]
17:36:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:36:30 <mornfall> Thanks. :)
17:36:33 <mornfall> That's better.
17:36:37 <aristid> :)
17:38:12 <hpc> best: [1..]
17:38:17 <hpc> let inference do the work for you
17:38:18 <mornfall> hpc: Different type.
17:38:21 <Saizan> danharaj: data families are fairly simple
17:38:31 <mornfall> hpc: GHC screams bloody murder about it.
17:38:38 <ion> > [maxBound ..]
17:38:38 <lambdabot>   [()]
17:38:44 <ion> > [maxBound :: Int16 ..]
17:38:45 <lambdabot>   [32767]
17:38:45 <hpc> oh i see
17:38:51 <danharaj> Saizan: It's the errors I fear :p
17:38:51 <Saizan> danharaj: type families need some learning
17:39:04 <Saizan> danharaj: yeah, i mean those
17:39:14 <danharaj> ah, I am using some type families as well.
17:40:42 <danharaj> I think I'm making headway though, both in understanding my problem domain and type/data families.
17:44:59 <dmwit> Okay. So.
17:45:21 <dmwit> I've got the identity "n^2 = 2 * (1/2 * n * (n-1)) + 1 * n".
17:45:54 <dmwit> I have a nice geometric interpretation of this, as well: a square matrix has a diagonal and two off-diagonal triangles of size n x (n-1).
17:46:43 <dmwit> To make the pattern more clear, we can write "n^2 = 2 * (1/2! * (n-0) * (n-1)) + 1 * (1/1! * (n-0)) + 0 * (1/0!)".
17:47:15 <dmwit> I've also got the identity "n^3 = 6 * (1/6 * n * (n-1) * (n-2)) + 6 * (1/2 * n * (n-1)) + n".
17:47:33 <dmwit> (Please don't make me expand that out fully, but it fits in the pattern above.)
17:47:45 <dmwit> Can anyone help me come up with a good geometric interpretation of that identity?
17:48:28 <copumpkin> 6 faces on a cube
17:48:32 * copumpkin thinks
17:48:35 <dmwit> If it helps, (1/6 * n * (n-1) * (n-2)) is the number of balls in a (n-1)-sided regular tetrahedron.
17:49:06 <dmwit> copumpkin: Yeah, that was my first thought, too, but as many diagrams as I've drawn I still can't get it straight what the n * (n-1) term is doing in there. =P
17:49:33 <copumpkin> that seems to be covering triangles covering ~half of each face?
17:49:58 <dmwit> oh ho, you want to put it on the face
17:50:08 <dmwit> I was trying to put them on some kind of wacky inner diagonal.
17:50:57 <copumpkin> dmwit: well, the "dimension" of the n * (n - 1)
17:50:59 <copumpkin> is quadratic
17:51:03 <dmwit> yep
17:53:42 <Hugglesworth> BONUS: I hear you're responsible for the book I just got
17:53:46 <Hugglesworth> Thanks
17:55:20 <dmwit> I keep convincing myself that the way to picture it is two tetrahedrons smacked together at their base.
17:55:33 <dmwit> But then the coefficient would be 2, not 6, on the cubic term.
17:55:39 <dmwit> Where's my intuition wrong there?
17:56:12 <copumpkin> hmm
17:56:13 <dmwit> Ah, I see where! Okay, that way isn't the way.
17:56:16 <copumpkin> three tetrahedra 
17:56:29 <dmwit> Six, actually. =P
17:56:30 <copumpkin> on each side of the diagonal plane
17:56:38 <copumpkin> maybe?
17:56:44 <dmwit> Okay, I believe you. But how?
17:56:55 <copumpkin> I'm trying to figure out how to fit them together
17:57:05 <dmwit> yeah
17:57:07 <copumpkin> I'm left-handed, and am supposed to be good at thinking about this kind of shit
17:57:11 * copumpkin kicks himself
17:58:48 <djahandarie> I'm terrible at this sort of stuff
17:59:10 <copumpkin> oh
17:59:15 <copumpkin> I think I know
18:00:03 <copumpkin> hmm, maybe not
18:00:20 <kevinburke> why doesn't "error" print to stderr?
18:00:31 <dmwit> Because "error" doesn't print?
18:00:39 <dmwit> at all?
18:01:00 <dmwit> Maybe a better question would be, "how come the top-level exception handler doesn't print to stderr"?
18:01:07 <kevinburke> dmwit: yes
18:01:10 <dmwit> I don't know the answer to that one, but it's a bit surprising if you claim it's true.
18:01:20 <copumpkin> dammit
18:01:27 <kevinburke> hang on
18:01:38 <copumpkin> I can sort of see how to fit five tetrahedra in
18:01:45 <dmwit> kevinburke: The top-level exception handler prints to stderr here.
18:02:33 <dmwit> copumpkin: five? O_o
18:02:40 <dmwit> Numbers like five don't appear in mathematics.
18:03:18 <copumpkin> :P
18:03:48 <djahandarie> @oeis 0,1,1,2,3,4
18:03:50 <djahandarie> Wow
18:03:51 <lambdabot>  Triangle read by rows in which row n lists n+1 terms, starting with n, such ...
18:03:51 <lambdabot>  [0,1,1,2,3,4,3,5,7,9,4,7,10,13,16,5,9,13,17,21,25,6,11,16,21,26,31,36,7,13,1...
18:03:53 <djahandarie> @oeis 0,1,1,2,3,5
18:03:56 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
18:03:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:04:17 <dmwit> By the way, I'm hoping that this geometric interpretation will help me duplicate one of the dimensions in a square matrix, to enable matrix multiplication of square matrices...
18:04:27 <dmwit> Such a worthless thing to be thinking about. =P
18:04:37 <copumpkin> that's the best sort of thing
18:04:57 <ion> @oeis 4,8,15,16,23,42
18:04:57 <lambdabot>  The Lost Numbers.
18:04:57 <lambdabot>  [4,8,15,16,23,42,108]
18:05:08 <copumpkin> lol
18:05:09 <djahandarie> Haha
18:05:11 <copumpkin> 108!!
18:05:17 <copumpkin> I haven't watched enough lost, I guess
18:05:47 <ion> Me neither. I’ve been meaning to watch the rest, but haven’t got around to that yet.
18:06:04 <kevinburke> dmwit: it was a different problem, whoops
18:06:13 * kevinburke smacks head for blaming compiler before own code
18:06:23 <ion> I hear it gets better (i.e. they don’t keep you completely in the dark) in the end.
18:08:26 <kevinburke> is there a way to trace to stdout?
18:10:32 <dmwit> nope
18:10:41 <dmwit> You can write it yourself, of course.
18:11:03 <kevinburke> ya i was just looking at putTracemsg - its only a few lines
18:11:04 <dmwit> Just copy the implementation from here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Debug-Trace.html
18:11:30 <copumpkin> dmwit: I wish I could explain how I'd stick five of them in there :P
18:11:49 <copumpkin> they wouldn't all be regular
18:12:10 <dmwit> Yes, I understand the explanation problem. =P
18:12:35 <dmwit> As for regularity, that doesn't bother me much, but some kind of symmetry would be nice, and five doesn't sound very symmetric in three dimensions.
18:12:46 <copumpkin> aha
18:12:48 <copumpkin> here
18:12:50 <copumpkin> http://calc101.com/animations/tetrahedron-in-cube.gif
18:13:12 <dmwit> oh ho!
18:13:18 <dmwit> I stand corrected on symmetry.
18:13:22 <copumpkin> that's five, right?
18:13:26 * copumpkin counts with fingers
18:15:27 <dmwit> Not much of an animation. =P
18:15:32 <copumpkin> agreed :P
18:15:35 <dmwit> But there's definitely something I still don't understand.
18:15:46 <dmwit> Because where is the extra tetrahedron hiding, amirite?
18:16:01 <copumpkin> indeed!
18:17:45 <danharaj> Let's say I have this function defined on type families: setAttribs :: AttribLocations a -> AttribDescriptors a -> IO ()
18:17:53 <danharaj> I bet I need to make those data families?
18:18:01 <copumpkin> yeah
18:18:08 <danharaj> gotcha.
18:18:28 <danharaj> what if I instead made it... setAttribs :: a -> AttribLocations a -> AttribDescriptors a -> IO ()
18:18:50 <copumpkin> that'd work
18:18:56 <copumpkin> or would be callable, at least
18:19:03 <danharaj> ah ok. I'll have to think about what I want to do.
18:19:21 <copumpkin> if one can be a data family, that'd also work
18:19:26 <copumpkin> as long as you have something that specifies a
18:21:09 <danharaj> If a is specified in the result type, would that work too?
18:23:16 <copumpkin> sure, it means you'll be able to call it
18:23:20 <copumpkin> it may be hard, still
18:23:29 <copumpkin> the original type sig would be uncallable
18:24:07 <danharaj> Wish you could do something like val :: (Family Foo)
18:24:21 <danharaj> so that you could call in such cases
18:24:27 <danharaj> basically telling GHC what a is.
18:26:30 <Martty> grand hadron collider
18:30:33 <Mathnerd314> ginormous hadron collider
18:39:25 <dmwit> http://hpaste.org/46064/polynomial_types =)
18:40:00 <dmwit> whoops, lost the last line: type Cube a = Third CubeHelper a () () ()
18:42:57 <sdrodge> I'm in a position where I want to override the default implementation of a function from a typeclass used internally by a lot of modules I import
18:43:02 <sdrodge> is there any way to do this?
18:43:47 <dmwit> No, you can't change an instance from outside the module defining the instance.
18:44:35 <sdrodge> that makes a lot of sense, but in this particular case is really inconvenient
18:44:38 <sdrodge> :)
18:44:48 * dmwit nods sympathetically
18:51:21 <dmwit> aha!
18:51:43 <acowley> does anyone have a good name for liftA2 (<|>)
18:51:59 <dmwit> :t liftA2 (<|>)
18:52:00 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Alternative f, Applicative f1) => f1 (f a) -> f1 (f a) -> f1 (f a)
18:52:08 <acowley> I called it <||> locally
18:52:31 <dmwit> ?instances Alternative
18:52:31 <acowley> yeah, it pushes an alternative into an applicative
18:52:31 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
18:52:32 <ddarius> liftA2 (<|>) or just (<|>) with an appropriate instance.
18:52:44 <dmwit> ?instances-importing Control.Arrow Alternative
18:52:44 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
18:52:59 <dmwit> ?instances-importing Control.Applicative Alternative
18:53:00 <lambdabot> Either e, ErrorT e m, Maybe, ReaderT r m, StateT s m, WrappedMonad m, WriterT w m, []
18:53:29 <acowley> I wanted it to produce the first Just resulting from a few possible effectful computations
18:53:53 <acowley> so I have foo <||> bar <||> baz :: m (Maybe a)
18:54:04 <acowley> perhaps there's another way, but I am tired
18:54:49 <dmwit> Yeah, I agree with ddarius. (<|>) seems like a good name for liftA2 (<|>).
18:55:13 <acowley> it does, doesn't it
19:00:57 <dolio> ddarius: So, do I recall correctly your saying that there have been recent papers on module and type class interaction?
19:01:10 <ddarius> Yes.
19:01:19 <dolio> Do you have a link handy?
19:01:24 <dolio> Or a name?
19:04:39 <ddarius> http://www.cse.unsw.edu.au/~chak/papers/WC08.html http://www.cs.rutgers.edu/~ccshan/xlate/xlate.pdf
19:05:02 <dolio> Thanks.
19:08:22 <ddarius> dolio: This is a much longer version of the first roughly: http://www.stefanwehr.de/publications/Wehr2005.html
19:10:57 <sanjoyd> Can someone suggest some small Haskell project a Haskell newbie can poke around and make some sense out of?
19:15:01 <dolio> Oh man, HMF correctly checks 'runST $ ...' without ad-hoc instantiation rules, apparently.
19:15:12 <dolio> What is GHC doing?
19:16:11 <dmwit> sanjoyd: xmonad seems engineered well.
19:17:08 <sanjoyd> dmwit: thanks!
19:17:49 <sanjoyd> I am at the position where I can write / understand small snippets, and I'll try to make the leap to writing non-toy programs this summer.
19:25:27 <seats> sanjoyd: http://code.google.com/p/diagrams/
19:26:35 <sanjoyd> seats: thanks!
19:26:47 <seats> i came in earlier today asking for close to the same thing
19:27:44 <sm> sanjoyd: http://joyful.com/darcsweb/darcsweb.cgi?r=rss2irc;a=headblob;f=/rss2irc.hs
19:28:08 <seats> and that one ;)
19:28:32 <seats> im curious also what some of the web frameworks look like
19:30:56 <seats> http://www.haskell.org/haskellwiki/Web/Frameworks
19:37:14 <applicative> http://stackoverflow.com/questions/2796350/web-development-haskell-or-scheme and similar entries likely linked on the right give some information on the present infrastructure.
19:54:19 <seats> applicative: thanks.  looks like don stewart gives happstack the nod
20:06:44 <heatsink> Is there something special about higher-kinded polymorphism?  If not, why do some languages support only polymorphism over * ?
20:07:01 <heatsink> Like C++ before template template parameters
20:08:44 <Nereid> heatsink: language designers couldn't think that high :o
20:08:55 <dolio> It can be somewhat special, depending on how you restrict it.
20:09:45 <dolio> Consider: you're trying to decide if 'a' matches 'f b'. Does it?
20:10:44 <shachaf> dolio: Yes.
20:10:48 <heatsink> I think so?  As long as they have the same kind, and 'f' isn't a type function.
20:12:20 <dolio> What's wrong with type functions?
20:14:09 <heatsink> Nah, type functions are okay.  You're not deconstructing 'f b' into 'f' and 'b'.
20:14:50 <dolio> What if I'm trying to do inference?
20:15:05 <int80_h> I'm trying to get ghci to see a module in a subdirectory. In my $HOME/.ghci I have :set -i:./config
20:15:18 <dolio> I just invented a fresh f, and I'm trying to unify T with f U for concrete T and U.
20:15:19 <int80_h> this is not quite right, could someone help me fix this?
20:15:32 <dolio> What is my solution for f?
20:16:36 <dmwit> int80_h: Surely that "." should be "/home/int80h" instead or so.
20:17:23 <int80_h> dmwit: well, no the code I want to run is in it's own subdirectory. I was under the assumption that .ghci should go in $HOME
20:17:29 <heatsink> Then you can't solve for 'f', you need to provide it explicitly or defer the solving for later.
20:17:59 <dmwit> int80_h: Neither of those statements seem to contradict me.
20:18:35 <dmwit> .ghci should go in $HOME, and the code you want to run should be in its own subdirectory, and the path you add for inclusion in ~/.ghci should refer to the real "/home/int80_h", not ".".
20:19:39 <int80_h> dmwit: $PWD when I run my program is foo. directory config is in foo/config. so, if I did what you said, it would be looking for /home/int80_h/config. Which doesn't exist. AM I following you correctly?
20:19:56 <dmwit> I see.
20:20:31 <int80_h> dmwit: so given that, what should I be doing?
20:20:41 <dmwit> int80_h: Probably just ":set -iconfig"
20:20:42 <int80_h> or, if I am doing it right, then something else is wrong.
20:21:00 <int80_h> I'll try that
20:21:19 * heatsink has to go, sorry to terminate the conversation
20:21:55 <int80_h> dmwit: no, didn't work :(
20:22:53 <int80_h> dmwit: it also did not give any syntax complaints. Which suggests to me the syntax is correct, but I'm not telling it to do the right thing
20:24:01 <dmwit> int80_h: WFM
20:24:33 <dmwit> Perhaps you're using :m instead of :l when it comes time to import the module of interest...?
20:26:12 <int80_h> dmwit: I'm using Yesod's scaffolding, which has an option to use ghci for development. This suggests to me the problem has to do with that, and not ghci syntax
20:26:51 <dmwit> Why don't you paste ~/.ghci, the output of "echo **", and a transcript of your ghci session to hpaste.org.
20:27:08 <dmwit> That will make it much easier to try to reproduce your problem.
20:30:17 <int80_h> dmwit: well I don't use ghci directly
20:30:42 <int80_h> dmwit: yesod's scaffolding can use it, and right now I'm trying to do that
20:31:10 <int80_h> dmwit: the only reason I went into ghci is to see if it would start complaining about .ghci syntax
20:31:23 <dmwit> Why not check whether what you think ought to work in ghci works in ghci?
20:31:30 <dmwit> Then you know whether it's yesod's fault or yours.
20:31:44 <dmwit> Less guessing is better.
20:32:46 <int80_h> dmwit: so, if it's working, I shold be able to do ":m + config" with success, right?
20:32:52 <dmwit> No.
20:33:22 <int80_h> what's the right test then? :l config?
20:33:26 <dmwit> If config is a directory, and Foo/Bar/Baz.hs is a file in the config directory that defines the Foo.Bar.Baz module, then :l Foo.Bar.Baz should work
20:33:46 <int80_h> gotcha
20:37:05 <dmwit> Doesn't the yesod framework have some documentation? Surely if this is something built-in, they have instructions on how to set it up.
20:38:37 <int80_h> dmwit: okay, ghci can't find the module StaticFiles, which is in $PWD/config
20:40:22 <int80_h> dmwit: should I be using :l or :m?
20:40:43 <int80_h> dmwit: hmm, using :l StaticFiles works
20:40:56 <int80_h> so, .ghci is correct then
20:41:53 <dmwit> In the yesod thing, you might consider importing System.Environment and checking that (getEnv "PWD") returns what you expect.
20:45:43 <int80_h> <interactive>:1:2: Not in scope: `getEnv'
20:46:03 <dmwit> Did you import System.Environment?
20:47:28 <int80_h> dmwit: I did, but in the wrong file. So I did it correctly this time
20:47:43 <int80_h> and PWD is correct
20:47:56 <dmwit> Okay, I'm clueless, then.
20:48:01 <int80_h> me too
20:48:12 <int80_h> I think we found a bug in Yesod 
20:48:16 <int80_h> so good job!
20:48:41 <int80_h> in the meantime I can hold my nose and flatten the directory structure
20:48:45 <dmwit> I doubt it. Much more likely that we are both clueless about just what it's doing.
20:49:00 <int80_h> yeah no one else has this complaint
20:49:20 <int80_h> maybe it wants .ghci/ghci.conf?
20:49:28 <dmwit> I'm sure if you outline your situation on the mailing list (yesod does have a mailing list, right?) somebody will set you straight.
20:49:58 <int80_h> dmwit: someone tried, with an incorrect .ghci setting. But that set me on the track of configuring ghci
20:50:27 <dmwit> ah
20:51:56 <int80_h> dmwit: well I'll come back to the list with what we did here, and see how it goes
20:53:45 <WendyMackaye> Dunno if it's a very interesting question for you, but i need to ask it anyways. In math, do numbers have types sometimes? A real 3 and natural 3, they're the same number, right?
20:54:03 <Nereid> 3 is something that makes sense in any ring
20:54:16 <dmwit> WendyMackaye: Yes, numbers have types sometimes.
20:54:27 <WendyMackaye> Ring, not sure if ever came across that term
20:54:33 <Nereid> ring = thing you can add and multiply in
20:54:35 <dmwit> WendyMackaye: And there's an injection from the naturals to the reals that does what you'd expect.
20:54:46 <Nereid> and subtract I guess
20:54:56 <dmwit> So there's a correspondence between the real 3 and the natural 3, though I'm not sure I'd consider them the same.
20:54:59 <WendyMackaye> Field?
20:55:01 <int80_h> that would be adding negative numbers
20:55:13 <Nereid> a field is a (commutative) ring you can divide in
20:55:21 <Nereid> ;<
20:55:22 <WendyMackaye> Oh
20:55:36 <Nereid> (except by zero of course)
20:56:50 <int80_h> dmwit: thanks for the help
20:57:04 <WendyMackaye> So sometimes it's the same and sometimes you need to mention they're two different things?
20:57:38 <WendyMackaye> Different but with some common features
20:57:49 <dmwit> Yes.
20:58:25 <dmwit> Humans are much better than computers at extracting the necessary conversions from context, though.
20:58:27 <Nereid> but (in rings) there is a "universal" 3, which is an integer
20:58:29 <Nereid> :<
20:59:21 <dmwit> Nonsense. There's a universal term in the ring algebra that uniquely determines a value that we can think of as being like 3.
20:59:40 <WendyMackaye> Okay, seems reasonable and i didn't expect anything different. Sometime math makes sense.
20:59:41 <dmwit> But there's certainly no universal set that acts like 3 across all rings.
21:00:25 <Nereid> dmwit: I'm saying that the integers are the initial ring, so if we call some integer 3, there's a corresponding element in any other ring
21:00:28 <Nereid> ;(
21:00:47 <dmwit> Yep, I buy that!
21:00:59 <Nereid> which we also may as well call 3
21:01:05 <WendyMackaye> Weee mathdudes punch out
21:01:09 <dmwit> But that "corresponding element" is exactly the conversion from the type Integer to the type "Other Ring".
21:01:10 <Nereid> lol
21:01:21 <Nereid> under the unique morphism Integer -> Other Ring
21:01:28 <dmwit> yep
21:01:41 <Nereid> so
21:01:46 <Nereid> what were we discussing again?
21:01:47 <Nereid> :D
21:02:13 <WendyMackaye> 3 and 3.0
21:02:16 <dmwit> All I'm saying is that f(3), when reduced to its set representation, may not have exactly the same representation as 3.
21:02:26 <Nereid> of course, but who cares about its internal structure
21:02:37 <dmwit> WendyMackaye was asking about internal structure.
21:02:41 <Nereid> oh, heh
21:02:57 <Nereid> but it doesn't make sense to compare things of different types by looking at their internal structure
21:03:08 <dmwit> Yep, hence his original question. =)
21:05:17 <Nereid> I guess we could have talked about semirings
21:05:35 <WendyMackaye> f(x)=3+x where x and f's results belong to 3's set (whether it's natural or real) might or might not have negative numbers
21:05:57 <Nereid> it might or might not even make sense to talk about negative numbers
21:06:09 <Nereid> (in the case of, say, integers mod n)
21:06:30 <WendyMackaye> I know already know that my mind is easily blown
21:06:36 <WendyMackaye> Now it is
21:07:10 <WendyMackaye> Oh, that?
21:07:14 <WendyMackaye> Hmmmm
21:09:30 <WendyMackaye> Hmmmm how come mod is weird with negatives? Second argument accepts only naturals?
21:11:05 <WendyMackaye> So a category is somewhat like the concept of functions.. Or.. Functions are a category instance?
21:12:53 <WendyMackaye> Still reading the intro booklet of an intro series of booklets in an intro course about linear algebra
21:15:11 <dmwit> > 3 `mod` (-6)
21:15:12 <lambdabot>   -3
21:15:37 <dmwit> WendyMackaye: mod seems to accept negative numbers in its second argument.
21:15:45 <dmwit> > 1 `mod` (-6)
21:15:46 <lambdabot>   -5
21:16:10 <dmwit> > (-5 * -5) `mod` (-6)
21:16:11 <lambdabot>   Precedence parsing error
21:16:11 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
21:16:18 <dmwit> > ((-5) * (-5)) `mod` (-6)
21:16:19 <lambdabot>   -5
21:16:44 <dmwit> ah, quite
21:16:50 <dmwit> That's kind of magical.
21:17:46 <Nereid> 3 `rem` (-6)
21:17:48 <Nereid> > 3 `rem` (-6)
21:17:49 <lambdabot>   3
21:17:52 <Nereid> good
21:17:58 <Nereid> > (-3) `rem` 6
21:17:59 <lambdabot>   -3
21:18:02 <Nereid> bad
21:18:04 <Nereid> > (-3) `mod` 6
21:18:05 <lambdabot>   3
21:18:06 <Nereid> good
21:18:11 <Nereid> why can't we have one that's right all the time? :(
21:18:36 <dmwit> Why is (-3) `rem` 6 = -3 bad?
21:18:54 <Nereid> I'm not saying it's wrong for the definition of rem
21:18:57 <WendyMackaye> I'm a bit confused about it all. I'll investigate when i'm behind a computer
21:18:59 <Nereid> I don't know what the definition of rem is
21:18:59 <dmwit> Oh.
21:19:11 <Nereid> hmm
21:19:20 <dmwit> I mean, quot, rem, div, and mod seem to have wholly satisfying documentation to me.
21:19:23 <Nereid> > (-6) `mod` (-6)
21:19:24 <lambdabot>   0
21:19:26 <Nereid> ok
21:19:31 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:quot
21:19:42 <Nereid> sure
21:20:26 <Nereid> why would one use quot/rem over div/mod?
21:20:32 <dmwit> speed
21:20:39 <Nereid> oh
21:22:11 <WendyMackaye> I didn't know there were alternatives for div/mod
21:22:35 <WendyMackaye> Welp, now i do
21:30:06 <ddarius> @google leijin div mod
21:30:09 <lambdabot> http://en.cnki.com.cn/Article_en/CJFDTOTAL-YLSX200706002.htm
21:30:10 <lambdabot> Title: Study on the Correlation between Echo Time of EPI in Ultra-high Field MR and Sig ...
21:31:02 * ddarius always manages to misspell "Leijen" the first time.
21:31:11 <ddarius> @google daan leijen div mod
21:31:12 <lambdabot> http://research.microsoft.com/en-us/um/people/daan/download/papers/divmodnote.pdf
21:31:12 <lambdabot> Title: Division and Modulus for Computer Scientists
21:50:04 <no_signal> hello all. a broad question: I'm interested in teaching myself functional programming. I've started the MIT "Structure & Interpretation of Computer Programs" (SICP) book & videos & exercises but am wondering if it's worth playing along to the book with Haskell instead of CL. Do you think Haskell will support the broad approach to learning functional programming SICP provides?
21:50:21 <no_signal> ie. how much time will I spend looking up different syntax stuff vs. just following along
21:51:00 <no_signal> or should I just do the book in Lisp to get my head around the concepts, and have a closer look at Haskell later on (my current likely approach).
21:51:02 <no_signal> thanks
21:51:23 <dmwit> Well, I haven't worked through SICP, but I have no doubt that Haskell provides all the things necessary for functional programming.
21:51:36 <dmwit> I doubt SICP has any critical uses of dynamic typing.
21:51:48 <napping> Really?
21:51:58 <dmwit> I don't know.
21:52:08 <dmwit> I would imagine most of it is parametric polymorphism.
21:52:13 <napping> all of chapter 2 seems to be building things from lists and quoted symbols
21:52:19 <no_signal> <blank look>
21:52:20 <Heffalump> that'll be the main difference though - the SICP examples won't mention static types which are quite important in Haskell. But generally type inference can calculate them for you.
21:52:35 <napping> chapter 1 is stuff about evaluation and memory which assumes strict evaluation
21:52:41 <no_signal> mhmm
21:52:53 <napping> 3 is about imperative stuff and mutable data
21:52:54 <dmwit> napping: But that's just what "data" declarations are all about.
21:53:03 <no_signal> that's as far as I've got, end of chapter 1.
21:54:01 <dmwit> Hm.
21:54:25 <dmwit> Does it really depend on eager evaluation in a fundamental way? That sounds pretty surprising.
21:54:47 <napping> talking about the asymptotic space of functions depends on evaluation order
21:54:49 <dmwit> State and mutability is going to be an issue, though, for sure.
21:55:03 <KirinDave> dmwit: Why is it surprising?
21:55:14 <napping> the metacircular scheme is a lot more impressive written in scheme
21:55:18 <KirinDave> dmwit: When evaluation order is well defined, someone will abuse it.
21:55:28 <no_signal> yes, they make a relatively big deal out of evaluation order.
21:55:48 <KirinDave> SICP is great, but kinda overrated.
21:55:49 <napping> dmwit: I'm not sure any of the functional programs critically depend on evaluation order
21:55:49 <no_signal> so if that differs, then perhaps I should stick to the book's language?
21:55:54 <KirinDave> That said, I dunno what else there is.
21:55:58 <danharaj> What is SICP?
21:56:11 <dmwit> danharaj: Use the Google!
21:56:15 <napping> but chapter 1 is an introduction to evaluation which describes everything in terms of eager substitution
21:56:26 <no_signal> KirinDave: yeah, that's my attitude - it seems to be the best option for a functionally-focused CS course
21:56:27 <danharaj> dmwit: too busy being hopped up on caffeine trying to formulate my problem correctly.
21:56:29 <napping> recommends tail recursion, etc
21:56:37 <no_signal> certainly the most completely/freely available
21:57:05 <napping> I'm not sure if SICP uses macros much, but that would be a difference too
21:57:11 <dmwit> ugh
21:57:20 <dmwit> macros are such a blight
21:57:40 <KirinDave> dmwit: Bite thy tongue.
21:57:51 <KirinDave> dmwit: They're just overused.
21:58:02 <dmwit> No, like, they're semantically problematic.
21:58:13 <KirinDave> Haha, I didn't realize blight == semantically problematic.
21:58:19 <dmwit> They really muck up alpha-convertibility and stuff.
21:58:27 <KirinDave> I think anything which allows you to arbitrarily redefine both syntax AND semantics is problematic.
21:58:48 <Kerris> Absolute power corrupts absolutely, eh?
21:58:53 <no_signal> sounds like the two are much more different than I'd thought.
21:58:53 <dmwit> If they were designed with just a bit more care towards capture-avoidance, they wouldn't be such a blight.
21:59:07 <KirinDave> dmwit: PLT Scheme does a fine job.
21:59:14 <KirinDave> Their macro system is great.
21:59:17 <dmwit> no_signal: Yeah, sounds like they're much more different than I thought, too.
22:00:11 <KirinDave> The problem is everyone gets irritated at anything that is not "lolbrb, coding imperatively"
22:00:27 <danharaj> So in my problem, I am  going to be defining tuples recursively for a data family. Since tuples can't really be defined that way I need to use another binary type constructor. Is there a standard package for doing this sort of stuff?
22:01:00 <danharaj> I mean I could easily define it myself but I'd rather not take up a symbol if there's a common one already.
22:01:26 <dmwit> The problem sounds underspecified to me.
22:01:30 <dmwit> Can you give an example?
22:02:08 <no_signal> OK, SICP it is. When I've got my puny brain around functional programming in general I'll come back to take a look at Haskell.
22:02:12 <no_signal> thanks for all your help!
22:02:21 <dmwit> g'luck!
22:02:32 <dmwit> I hope to see you again soon. =)
22:02:50 <napping> for macros, just being able to define binding structures seems to get you pretty far
22:03:12 <danharaj> type AttribName (a :+: Foo) = (AttribName a) :*: String
22:04:01 <danharaj> I have a type constructor :+: for building glsl inputs, I want to associate to them tuples of strings based on the number of variables.
22:04:22 <danharaj> building types of glsl inputs*
22:04:57 <dmwit> I don't get it. How is that diffferent from
22:05:10 <dmwit> type AttribName (a :+: Foo) = (AttribName a, String) -- ?
22:05:32 <dmwit> I mean, of course it depends on the definition of :*:.
22:05:41 <danharaj> Because I can specify the fixity of a new operator so that when someone gives a set of variable names, they don't need a couple dozen parntheses :p
22:05:50 <danharaj> data a :*: b = a :*: b
22:06:16 <dmwit> ...but that operator doesn't need to be a constructor.
22:06:30 <danharaj> Why not?
22:06:30 <dmwit> (*:) = (,) -- would achieve the same effect
22:07:02 <dmwit> Wouldn't it?
22:07:03 <danharaj> compare "Foo" :*: "Bar" :*: "Baz" :*: "Duck" to (((("Foo"), "Bar"), "Baz"), "Duck")
22:07:29 <dmwit> Compare "Foo" :*: "Bar" :*: "Baz" :*: "Duck" to "Foo" *: "Bar" *: "Baz" *: "Duck"
22:07:40 <danharaj> yes well the name doesn't matter
22:07:43 <Axman6> can you do data a :,: b = a :,: b?
22:07:44 <dmwit> Right.
22:07:45 <danharaj> is *: already defined?
22:07:53 <dmwit> So why bother with this :*: type?
22:08:03 <dmwit> danharaj: No, I don't think so.
22:08:11 <danharaj> Then I have to define *some* symbol.
22:08:15 <dmwit> And I don't think *: is a particularly good name for it, either.
22:08:19 <danharaj> I'm asking if someone's already done it.
22:08:25 <dmwit> Okay, so you're asking if there's some other name for (,) somewhere?
22:08:30 <dmwit> I don't believe there is.
22:08:53 <napping> I guess `(,)` doesn't work
22:09:06 <dmwit> no
22:09:58 <danharaj> I wonder if * is allowed as a type constructor and data constructor?
22:10:07 <danharaj> Because if it is, that really should be standard for tupling.
22:10:57 <dmwit> No, all infix constructors begin with :.
22:11:02 <danharaj> ah ok
22:20:27 <no_signal> hm. has anyone done "Programming in Haskell" (http://www.cs.nott.ac.uk/~gmh/book.html)?
22:20:41 <no_signal> it also has videos, exercises and solutions.
22:20:45 <no_signal> and also has a FP bent.
22:22:25 <dmwit> If you'd like to learn Haskell, there are some excellent materials.
22:22:28 <dmwit> ?where LYAH
22:22:28 <lambdabot> http://www.learnyouahaskell.com/
22:22:30 <dmwit> ?where RWH
22:22:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:22:35 <dmwit> ?where gentle
22:22:36 <lambdabot> http://www.haskell.org/tutorial/
22:22:47 <dmwit> The final one is my favorite, but it is certainly by no means gentle.
22:23:02 <napping> maybe if you read SICP first
22:23:12 <no_signal> Generally, I'm interested in FP, and from the outside Lisp looks like it would be great to learn, but my impression is the library support and differences in implementation mean it's probably suboptimal these days. it seems to have the "you must build everything from scratch" attitude that is no longer relevant.
22:23:59 <no_signal> thanks dmwit. I've seen all those and read half of LYAH (but didn't to the exercises). I'm looking for an into to FP in general as much as a Haskell tutorial.
22:24:03 <dmwit> I think you will have a hard time failing to learn FP during any introduction to Haskell.
22:24:08 <napping> CL isn't particularly functional
22:24:11 <no_signal> then again maybe... yeah. what you said.
22:24:35 <napping> at least not the kind of FP you see in Haskell
22:24:54 <ddarius> CL and Scheme are rather different.  Of course, Haskell and Scheme/CL are even more different.
22:24:55 <napping> It's certainly interesting, and you'll see lots of the functions-as-values stuff
22:24:56 <KirinDave> no_signal: Actually
22:25:11 <KirinDave> no_signal: I'm shocked at how good library support is in haskell these days
22:25:22 <KirinDave> I was like, "I need a redis client. I bet haskell doesn't have that."
22:25:25 <KirinDave> Whuuu?
22:25:29 <KirinDave> THere are like 3.
22:26:05 <napping> KirinDave: the worry was about lisp - but I see there is a cl-redis
22:26:14 <KirinDave> Yeah
22:26:20 <KirinDave> Actually it's the same for lisp.
22:26:33 <no_signal> KirinDave: Yeah. My only prior programming ventures have been in Python so I am very spoiled with library support.
22:26:39 <napping> there's a half-baked version of anything you want?
22:26:41 <KirinDave> I mean, it's not Java.
22:26:50 <KirinDave> But then neither is python or ruby
22:26:52 <no_signal> From a cursory glance Haskell seems pretty good.
22:27:14 <danharaj> Haskell is the business as someone once told me.
22:27:24 <no_signal> Oh, well that settles it then.
22:27:33 <no_signal> ;)
22:27:44 <danharaj> If it helps, the guy was a theoretical physicist. :p
22:27:46 <napping> As a functional language, Haskell emphasizes purity and types
22:28:19 <ddarius> no_signal: If your goal is to learn functional programming, I recommend Haskell.  Nothing keeps you from learning other languages later, and Haskell makes it difficult for you to avoid learning FP.
22:29:36 <dmwit> Python has excellent library support.
22:29:41 <zeppelin-bend> Anyone familiar with Iteratees?
22:29:48 <dmwit> Haskell is getting better there.
22:30:05 * ddarius found Python frustrating.
22:30:11 <dmwit> The introduction of the Platform and, with it, a set of known-good libraries has helped a lot.
22:30:28 <dmwit> zeppelin-bend: You should probably just ask your question.
22:31:05 <danharaj> You can do amazingly fun things with OpenGL and Repa.
22:31:11 <danharaj> As I am finding out as I go :)
22:32:28 <vegai> python frustrating?
22:33:53 <zeppelin-bend> I was hoping to get someone to look at my analysis of the composability of iteratee's
22:33:56 <zeppelin-bend> http://zeppelin-bend.blogspot.com/2011/04/composability-of-iteratees.html
22:46:18 <danharaj> I wonder how much you can learn about a type constructor F by looking at F ().
22:48:15 <dmwit> Not a whole lot, sadly.
22:48:19 <Nereid> depends on F
22:48:28 <dmwit> You can't even distinguish F a = a from F a = ()
22:48:45 <Nereid> if F a = a -> T, for some fixed T
22:48:51 <Nereid> then F () tells you everything about T
22:48:58 <danharaj> dmwit: so obviously we must restrict ourselves to some nicer subset of F's :p
22:49:18 <Nereid> on the other hand, if F a = T -> a
22:49:25 <Nereid> then F () tells you nothing
22:49:34 <Nereid> about T
22:50:48 <ddarius> danharaj: If F is a continuous functor, then F () ~ (), but most F's in Haskell are not continuous.
22:53:25 <danharaj> ddarius: Is this because of anything particular about Hask?
22:53:33 <Nereid> no:
22:53:40 <Nereid> continuous functors preserve limits
22:53:51 <Nereid> () is the limit of nothing
22:53:53 <danharaj> ah yes. that's right.
22:53:58 <danharaj> forgot the meaning of continuous for a second.
22:54:01 <danharaj> 2 AM disease.
22:54:35 <Nereid> however, if you believe that every type has a set of values
22:54:52 <Nereid> then every type is a colimit of ()'s
22:55:18 <Nereid> so if F takes colimits to limits/colimits
22:55:23 <Nereid> then F () tells you everything I guess
22:56:04 <danharaj> well the thought that sparked the question was thinking about [()] (pretending Haskell is strict and total etc.)
22:56:09 <danharaj> and that tells you quite a bit about lists.
22:56:53 <Nereid> it tells you what lengths they can have, I guess
22:57:15 <danharaj> There's not much more generic structure to a list.
22:57:20 <Nereid> right
22:57:30 <Nereid> () there is as good as (forall a. a)
22:58:02 <Nereid> or is it?
22:58:16 <ddarius> Nereid: Those types are not isomorphic.
22:58:18 <Nereid> of course not.
22:58:33 <danharaj> In the universe I want to talk about, forall a. a is uninhabited.
22:58:34 <ddarius> In a total language, () ~ exists a. a
22:58:53 <Nereid> danharaj: ok.
22:58:58 <ddarius> danharaj: Even in Haskell they are not isomorphic.
22:58:59 <Nereid> right, you said total
22:59:10 <danharaj> ddarius: Yes of course. () has two values :p
22:59:25 <ddarius> danharaj: Yes.
22:59:27 <no_signal> Thanks again for your help everyone. I might try going through LYAH a little more closely before attempting the monolith of SICP. Hopefully that will be enough to satisfy my curiosity about FP.
22:59:42 <ddarius> SICP is good to read.
22:59:50 <ddarius> And the lectures are entertaining.
23:00:05 <ddarius> None of this is an either/or situation.
23:09:15 <no_signal> ddarius: My free time says otherwise.
23:09:30 <no_signal> Anyway. Thanks yet again. Might be back in here one day!
23:10:19 <danharaj> oh boy.. I think my first prototype is ready.
23:10:29 * danharaj inb4 400 pages of type errors
23:19:12 <kniu> Is there a language that is inbetween Haskell and Disciple?
23:19:36 <kniu> That is, everything is evaluated eagerly, but the order of evaluation is still completely undefined.
23:19:57 <c_wraith> that seems like a tough compromise
23:20:20 <c_wraith> I guess it would be like using unamb for all computations?
23:20:29 <roconnor> wow.  It looks like tying-the-knot has nothing to do with laziness
23:20:37 <roconnor> http://www.reddit.com/r/programming/comments/gwqa2/the_real_point_of_laziness/c1qz6lh
23:20:54 <kniu> c_wraith, it seems more like how a novice would naively "implement" Haskell.
23:21:22 <kniu> Just evaluate things as soon as they "come up", without constructing any thunks.
23:22:16 <c_wraith> that still constrains the execution order to the point where it's pretty close to, say...  C's unspecified order of evaluation of function args.
23:22:29 <shachaf> roconnor: Cycles can exist without laziness, yes. :-)
23:22:30 <kniu> c_wraith, yes.
23:22:44 <kniu> That's kind of the point.
23:23:06 <ddarius> shachaf: Who said anything about cycles?
23:23:17 <kniu> I wonder how many Haskell programs actually "take advantage" of laziness.
23:23:23 <c_wraith> I don't see a giant gain from that, unless you're also doing things like using unamb for && and ||, for instance
23:23:28 <ddarius> kniu: A lot more than you think.
23:23:40 <c_wraith> kniu: any program that uses an infinite list anywhere
23:23:47 <kniu> oh yeah.
23:23:49 <ddarius> Many aspects of laziness are used without notice.
23:23:50 <kniu> that.
23:23:55 <shachaf> Well, the letrec syntax for constructing them, too.
23:23:56 <ddarius> @src forever
23:23:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:24:28 <napping> any programmer that uses equational reasoning
23:24:45 <napping> or any program that relies on foldr/build fusion for speed, I think
23:25:00 <shachaf> Ha: http://en.wikipedia.org/wiki/Tying_the_knot
23:26:49 <roconnor> shachaf: so does that mean that program from "Less Speed, More Haste" can be written in ocaml?
23:27:28 <ddarius> If you just flipped a switch and made Haskell eager, most programs would break, even ones that weren't thought of as exploiting laziness at all.
23:27:33 <ddarius> roconnor: Of course it can be.
23:29:19 <napping> roconnor: O'Caml has laziness annotations anyway
23:29:24 <roconnor> ddarius: why of course?
23:29:34 <ddarius> roconnor: O'Caml is not pure.
23:30:00 <roconnor> ddarius: Right.  I mean write that program without using effects and only using recursive literals.
23:30:28 <roconnor> napping: I still don't beleive laziness annotations are adequate for simulating haskell, but I guess I'm less sure now.
23:30:29 <danharaj> how good is GHC at throwing out wrappers of type book keeping?
23:30:57 <napping> why wouldn't they be?
23:31:06 <ddarius> newtypes pretty immediately get translated to id.
23:31:41 <roconnor> napping: write Escardo's search through the cantor space without using side-effect and only using recurisve literals, delay and force.
23:31:45 <ddarius> However, things like map id do not necessarily always optimize away, so newtype wrappers can cause problems.
23:32:24 <roconnor> ddarius: things like map id, but hopefully map id does optimize away?
23:34:33 <c_wraith> map id is not optimized, so far as I know
23:34:57 <napping> roconnor: I don't see why there would be any problems other than being able to use let rec
23:35:16 <roconnor> napping: go for it
23:35:27 <kniu> http://portal.acm.org/citation.cfm?id=581694&dl=ACM&coll=portal
23:35:31 <kniu> This looks interesting.
23:35:36 <roconnor> napping: I don't even understand how Escardo's program works, so I have no idea
23:38:15 <danharaj> I never understood that program either.
23:38:39 <napping> the fast one is pretty strange
23:38:41 <ddarius> It takes a bit of thought, but it is straight-forward enough.
23:40:54 <roconnor> ddarius: implementing it in ocaml?
23:41:17 <roconnor> without side effects
23:41:38 <napping> sprinkle in lazy, Lazy.force, and Lazy.t everywhere
23:41:51 <ddarius> roconnor: If foldr/build fires, map id will be optimized away, and supercompilation would also always catch this, but otherwise GHC doesn't realize that the tail of the cons case is the same as the tail of the input.
23:42:16 <roconnor> napping: try it
23:42:54 <ddarius> roconnor: I was responding to the comment about understanding Escardo's program, but I agree with napping.
23:43:13 <napping> do you understand the faster versions?
23:43:34 <roconnor> I'll believe it when I see it.
23:44:19 <roconnor> maybe I should go into #ocaml and say "your langauge sucks because it cannot do this..."
23:44:26 <ddarius> You can implement lazy evaluation as placing delays and forces appropriately.  There's nothing special about Escardo's program in that regard.  Heck, you can even write that without laziness by using a different representation of streams.
23:44:26 <roconnor> that always motivates people :)
23:44:58 <roconnor> ddarius: I'd like to see it without laziness at all then.
23:45:06 <roconnor> you can use functions to represent streams if you like
23:45:15 <roconnor> no side-effects, no callcc though.
23:45:26 <ddarius> napping: I think it is version 2 or 3 that I find clearest.  The rest can be understood by derivation from it.
23:45:29 <jonkri> is there some convenient way of making a thread a daemon thread (not causing the process to be alive), or even better, to say that if one thread dies, a certain other thread should also die?
23:46:13 <jonkri> i'm having an enumerator thread reading from a handle, and i don't quite know how to handle this thread in case of runtime errors, or even normal shutdown
23:46:16 <Saizan> all threads are like that
23:46:41 <Saizan> i mean, no thread will keep the program alive except for the main one
23:47:43 <danharaj> oh boy debugging my type gymnastics coming soon
23:47:57 <jonkri> thanks Saizan, that helps a lot
23:48:04 <napping> jonkri: you can usually do any kind of thread management by wrapping the argument to force
23:48:07 <napping> to forkIO, rather
23:48:25 <roconnor> bbl.  Good luck ddarius and napping.
23:48:33 <napping> roconnor: do you claim Lazy doesn't provide laziness?
23:49:08 <ddarius> Hell, even in the blog article the first sentence of the second paragraph is: "I will use the language Haskell, but it is possible to quickly translate the programs to e.g. ML or OCaml."   
23:49:15 <vegai> all languages provide laziness in some form. Only Haskell was crazy enough to make it the default...
23:49:38 <napping> It's not just Haskell
23:49:57 <vegai> I'm wondering, is some critical feature of Haskell's dependant on laziness?
23:50:07 <danharaj> Is TypeOperators a well accepted extension?
23:50:08 <napping> um, laziness
23:50:11 <danharaj> (I assume so)
23:50:20 <napping> that was kind of the point of making the language
23:50:25 <vegai> dependant on *default* laziness, that is
23:50:32 <vegai> napping: cannot have been!
23:50:47 <vegai> I mean... that's ... not a good idea
23:50:55 <napping> unify LML, Miranda(TM), whatever else was running around
23:51:26 <ddarius> "dependent" unless you're a Brit and are talking about minors.
23:52:19 <vegai> ddarius: oh, thanks. Didn't know that.
23:52:21 <napping> making declaration order unimportant pretty much requires laziness
23:52:34 <napping> or distinguishing letrec
23:52:53 <ddarius> napping: Not really.
23:53:44 <napping> well, it's not so natural. I suppose you could declare that let does a topological sort or something
23:54:27 <vegai> perhaps laziness should've been typified
23:54:31 <ddarius> It would not be hard to make a language very similar to Haskell that was strict.
23:54:49 <ddarius> vegai: That's, more or less, what Robert Harper is endorsing.
23:55:16 <napping> really? I didn't read anything quite so coherent
23:55:27 <napping> seems like he just doesn't like laziness
23:55:32 <danharaj> Harper writes in his blog to incite. :p
23:55:34 <napping> allergic to domain induction or something
23:55:40 <Kerris> Miranda ML :<
23:55:42 <danharaj> It doesn't reflect his views deeply.
23:55:46 <danharaj> only the surfaces.
23:55:51 <ddarius> napping: He's not stating it that way coherently, but that is roughly what he is suggesting if you put the pieces together.
23:56:11 <danharaj> ddarius: would you say that goes beyond making a distinction between data and codata?
23:56:13 <napping> I guess you can have a total language with data and codata
23:56:16 <danharaj> (typing laziness)
23:56:27 <napping> but that's another story entirely
23:56:30 <ddarius> napping: There are total languages with data and codata.
23:56:34 <danharaj> Charity
23:56:46 <napping> the point is, it's total
23:56:48 <ddarius> danharaj: It's different from making a distinction between data and codata, though they are related.
23:56:57 <napping> so evaluation doesn't really matter
23:57:02 <napping> evaluation order, at least
23:57:06 <ddarius> napping: Agda and Coq support codata.
23:57:41 <ddarius> Also, total is no longer appropriate with codata.  You want "total or productive."
23:59:27 <Saizan> one of Agda's backends (haskell), uses laziness for data too :)
23:59:45 <napping> and you can't really tell, because functions are total
