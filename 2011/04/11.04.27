00:00:10 <napping> well, maybe if you actually *ran* you Agda program, and measured performance
00:00:16 <Saizan> exactly
00:01:05 <napping> ddarius: Coq and Agda make no type disctinction between inductive and coinductive types
00:01:08 <danharaj> type family errors are refreshingly easy to read
00:01:18 <danharaj> I guess my experience with Repa errors was misleading :p
00:01:27 <danharaj> They must use far more type wizzardry.
00:01:29 <napping> well, Agda switched to the hash stuff, so it kind of stands out
00:02:29 <kniu> I've never quite figured this out:
00:02:32 <kniu> What is codata?
00:02:56 <ddarius> napping: I don't think you said what you meant to say, and what I think you meant to say doesn't seem to have much point.
00:03:32 <napping> well, you seemed to suggest that Coq and Agda have separate kinds for data and codata, or something like that
00:03:57 <ddarius> napping: I don't know where you got that suggestion from what I said even in context.
00:04:40 <napping> you were talking about indicating laziness in types
00:04:48 <ddarius> By a type.
00:05:24 <napping> If you just mean that different types can have different evaluation strategies, Haskell already does that with strictness annotations
00:06:39 <danharaj> kniu: If data is something that is defined by how to build up values, codata is something that is defined by how you can apply observers to values.
00:06:41 <napping> You might improve on that a bit by having some notation for strict functions
00:06:56 <danharaj> For example, the codata of Streams has head and tail as its defining observers.
00:06:58 <Saizan> danharaj: you can define both both ways
00:07:56 <danharaj> Saizan: Elaborate.
00:08:14 <danharaj> (Assuming we are not in the Haskell universe where they coincide)
00:08:17 <jonkri> in the source for enumerator, what does "return = Chunks . return" mean? http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator.html
00:08:25 <jonkri> i understand Chunk and the dot
00:08:29 <ddarius> napping: I can't do things like [!a] or !a -> b, let alone have such things enforced so that, for example, I know a value doesn't have bottom in it later on.
00:08:43 <Saizan> kniu: recursive types can be splitted into those which are taken to be the least fixed point and those that are the greatest fixed point, i.e. the smallest set such that .. vs. the greatest set such that ..
00:08:45 <ddarius> Essentially, Haskell completely lacks types without bottom.
00:09:18 <danharaj> And that's why you can't have Peano Naturals in their honest form in Haskell.
00:09:19 <Saizan> kniu: the first is data the latter is codata
00:09:25 <danharaj> And a bunch of people were silly on Harper's blog about it :p
00:09:30 <napping> you can't do that sort of thing in Agda or Coq either
00:09:41 <ddarius> danharaj: Robert Harper is being fairly silly himself.
00:09:49 <kniu> danharaj's explanation makes some sense; Saizan's explanation, I must apologize, is a bit too abstract for me.
00:09:59 <danharaj> my explanation is stupid and wrong
00:10:07 <ddarius> napping: No type has bottom in Agda or Coq, so it's not really relevant.
00:10:22 <kniu> speaking of Harper
00:10:24 <ddarius> And if I wanted to add a "bottom" to a type, I can in Agda in Coq.
00:10:31 <napping> but codata admits infinite values
00:10:32 <kniu> I might take a class from him next semester.
00:10:45 <napping> ! would be something like truncating to just allow finite values
00:11:14 <napping> List can be instantiated to any type, and if you want to restrict the values in the list you have to pick an appropriate type, rather than just sprinkling in annotations
00:11:17 <kniu> It would be interesting to see how his zealotry translates into actual pedagogy.
00:11:40 <ddarius> No, !a would be like not allowing a to be instantiated to a codata type, except the distinction is having bottom v. not having bottom, not data and codata.
00:12:43 <kniu> So, lemme get something straight here
00:12:52 <Saizan> danharaj: church encoding is defining data by how you can observe it
00:13:47 <kniu> what are some examples that illustrate "the smallest set such that .. vs. the greatest set such that .."?
00:14:24 <danharaj> Saizan: I know you can always take a data and church encode it. Can you take a codata and... church 'decode' it?
00:14:56 <danharaj> kniu: Consider the type of lists: List A = Nil | Cons A (List A)
00:15:09 * ddarius would just use the naturals v. conaturals.
00:15:13 <napping> danharaj: not happy with a weak NNO?
00:15:33 <danharaj> napping: I find them philosophically abhorrent
00:15:53 <danharaj> kniu: What's the smallest set containing the base cases (Nil) and every possible way to build up from Nil? What possible lists are left out?
00:16:00 <danharaj> (possible finite way)
00:16:09 <kniu> okay
00:16:09 <napping> the "weak" part is unfortunate, yes
00:16:12 <kniu> uh
00:16:39 <Saizan> finite comes out of smallest
00:16:49 <danharaj> yes but I don't find that obvious :p
00:16:50 <kniu> I'm stumped.
00:17:30 <danharaj> Well I gave a hint by telling you that smallest == finite. Let's say I gave you a value of type List A. What can it look like, written as a composition of constructors?
00:18:02 <kniu> where does the notion of "smallest = finite" come from?
00:18:02 <danharaj> God 4 AM disease is kicking in. I left out words in that question.
00:18:33 <Saizan> let's go with naturals, so i don't have to bother with A
00:18:36 <kniu> okay
00:18:40 <danharaj> yeah probably naturals is better
00:18:43 * danharaj goes back to fixing type errors
00:19:52 <napping> kniu: do you know initial and terminal algebras?
00:20:04 <kniu> napping, I have no idea what those are.
00:20:07 <Saizan> Nat = Z | S Nat; this can be seen as asking for a solution N = f N; where f is a function from sets to sets, defined as f X = X u {Z} u {S x | x \in X}
00:20:43 <kniu> wait what
00:20:51 <kniu> "asking for a solution"?
00:21:20 <Saizan> defining a type such that it's a solution to that N = f N equation, where N is the unknown
00:21:29 <danharaj> kniu: Are you familiar with the principle of mathematical induction?
00:22:07 <kniu> danharaj, sure
00:22:22 <danharaj> kniu: what does it say about the natural numbers?
00:22:26 <Saizan> kniu: or, well, from data Nat = Z | S Nat you'd expect that Z is an element of Nat, and for each element n of Nat then S n is also an element of Nat, right?
00:23:21 <kniu> if P(n) is true and P(0) is true and P(n) implies P(n + 1), then P(m) is true for all m >= 0.
00:23:33 <kniu> Saizan, yes.
00:23:56 <c_wraith> In some ways it's unfortunate you can't distinguish between data and codata in Haskell.  the transition from iterate S Z to fix S is sort of magical.
00:25:16 <Saizan> kniu: now, we know that the set of natural numbers satisfies this condition, it's basically the same as induction, and if you removed something from the naturals this wouldn't be true, because you'd be missing zero or the successor of some other natural, and you're required to have those
00:25:41 <Saizan> kniu: so the set of natural numbers is the smallest set such that ..
00:26:23 <kniu> smallest set such that every element in the set is a natural number?
00:26:45 <kniu> wow that sentence was pointless.
00:26:57 <c_wraith> smallest set N that satisfies N = f N, for the given definition of f
00:27:01 <dct25> smallest set that contains zero and is closed under successors
00:27:02 <Saizan> smallest set such that Z is an element of it, and for every element n of it S n is also an element
00:28:37 <kniu> okay, just
00:28:54 <kniu> what element is not in the smallest set but in the largest set?
00:29:04 <Saizan> infinity = S infinity
00:29:17 <danharaj> S S S S S S S S S S S S
00:29:24 <danharaj> ... S S S S S .... S S S S S ...
00:29:29 * danharaj is a snake
00:29:32 <ben> Sounds like a minecraft joke
00:29:39 <dct25> Don't you need S to be injective?
00:29:49 * BMeph looks for a patch to fix danharaj's leak...
00:29:58 <dct25> Otherwise {Z} is the smallest set such that ... if you define Z = S Z
00:30:00 <BMeph> ;)
00:30:01 <kniu> I feel like I'm missing what "smallest" and "largest" mean in the mathematical sense.
00:31:02 <danharaj> What I really need is a solution to this problem. I have a class Foo, and a type a with a Foo instance. I have another type instance: Bar. I define a Bar instance for every type that has a Foo instance. GHC can't deduce Bar a from Foo a. I can only tell it Foo a. How do I tell GHC that Foo implies Bar?
00:31:55 <kniu> class Bar a => Foo a
00:31:56 <kniu> ?
00:32:06 <danharaj> That would be Bar implies Foo :p
00:32:33 <Saizan> kniu: the order is inclusion
00:32:33 <ddarius> Actually, that would be Foo implies Bar, e.g. Ord implies Eq.
00:32:47 <danharaj> yes. yes that is true.
00:32:54 * danharaj 4 am disease
00:32:57 <kniu> no, because you can define an instance for Bar a without defining an instance for Foo a
00:33:06 <danharaj> yes I is dumb
00:33:22 <kniu> it is 4am here too
00:33:33 <danharaj> I am also sleep deprived from last night.
00:33:40 <danharaj> so it's like double 4 am
00:34:45 <shachaf> So 8 am?
00:35:11 <danharaj> 12 am is an arbitrary base point.
00:35:43 <shachaf> danharaj: I was taking 0 as the base point.
00:36:58 <jonkri> if i have a context which is like the StateT, except it needs the underlying monad to be monadio and to carry a state of a certain (hardcoded) type, does it make sense to create a new monad based on a newtype that wraps statet?
00:36:59 <ddarius> Torsors all the way.
00:37:29 <jonkri> i don't want to expose the state to people using the monad, but it should only be used internally
00:37:33 <danharaj> There is no 4 am, just the map sending every time 4 hours into the future.
00:40:13 <c_wraith> jonkri: if you don't want to expose the MonadState interface, definitely wrap it.
00:41:00 <jonkri> c_wraith: great :) thanks
00:42:31 <danharaj> is there anything bad about using TypeSynonymsInstances?
00:42:48 <danharaj> I have a very long type I am instancing and I just want to use a type synonym in order to make it readable.
00:43:08 <napping> the only risk is forgetting that it's a type synonym
00:43:23 <c_wraith> or accidently overlapping it
00:43:40 <danharaj> ah I see. So if I don't export the type synonym and never look at this god forsaken module again, I'll be fine?
00:43:42 <napping> and being surprised when you get errors about overlapping instances
00:43:57 <danharaj> (and also don't export enough of each class to allow instances outside of the module)
00:44:04 <napping> If you have other extensions on, it could be worse
00:44:39 <shachaf> Alternatively, use #define. :-)
00:44:44 <napping> If you have a class that localized, I don't think any of the extensions are very bad
00:45:07 <napping> TypeSynonymInstances is pretty much pure sugar for just writing out the type in full
00:46:12 <c_wraith> depending on the structure of the type synonym, it might prevent you from using it, because it would look like a type lambda.  But I doubt you'll have that issue.
00:47:42 <danharaj> wow holy crap. you can get a vomit of errors if you are missing an instance and using type families :o
00:48:43 <ben> Type lambdas o_o
00:50:19 <ddarius> The rule is simply to always eta reduce type synonyms as much as possible.
00:50:28 * hackagebot feldspar-language 0.4.0.2 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.4.0.2 (EmilAxelsson)
00:50:30 * hackagebot feldspar-compiler 0.4.0.2 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.4.0.2 (EmilAxelsson)
00:52:57 <danharaj> o.o it works
00:53:02 <danharaj> There's a huge friggin bug but it works.
00:53:02 <roconnor> @tell napping yes, I'm claiming that Lazy doesn't provide enough laziness to do everything Haskell can do.  I might be wrong though.
00:53:02 <lambdabot> Consider it noted.
00:54:44 <danharaj> I wish I weren't passing out
00:54:48 <danharaj> because I know how to fix my bug.
00:55:04 <danharaj> I also need to sugar this crap up because getting 100 pages of type fail is unacceptable when you make a typo.
00:55:42 <danharaj> ... dare I use some template haskell?
00:58:10 <danharaj> tonight... dreams of madness
01:02:13 <args0> Hello, is it true that: "functional programs do not allow mutable state, which makes it impossible to do parallel updating in place" can some one please explain to me what parallel updating refers to? thanks!
01:04:16 <roconnor> args0: I don't know where your quote is from, but a parallel update in place sounds like mapArray
01:04:22 <roconnor> @hoogle mapArray
01:04:22 <lambdabot> Data.Array.MArray mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
01:04:59 <c_wraith> Heh.  that's explicitly mutable state.  functional programs to allow mutable state.  They just discourage its use.
01:04:59 <Jafet> Dysfunctional programs only.
01:05:06 <c_wraith> *do
01:05:31 <roconnor> isn't sure why maparray doesn't have type (i -> e' -> e) -> ...
01:05:44 <scree> @faq can haskell do parallel updating in place?
01:05:44 <lambdabot> The answer is: Yes! Haskell can do that.
01:06:38 <c_wraith> roconnor: guess it's just intended to be an in-place fmap, rather than a keyed map
01:07:08 <roconnor> c_wraith: I guess I'm worried that a keyed map function doesn't exist
01:08:40 <c_wraith> it appears that MArray supports mapArray and mapIndices, but not a map over both
01:08:53 <Jafet> Surely that would be called forArray
01:09:07 <c_wraith> ...  mapIndices sounds incredibly dumb.  You would never want to pass it (*2)
01:14:41 <roconnor> ddarius: well, at least my naive implementation of cantor searching in ocaml gives a stack overflow.
01:15:20 <roconnor> I guess I sould try to sprinkle some Lazy's around
01:15:37 <c_wraith> I guess that's less ugly than eta-expanding it to simulate laziness :)
01:15:51 <roconnor> or etas
01:16:03 <roconnor> I'm not sure where to put them
01:16:31 <c_wraith> I never really understood the cantor search stuff anyway.  I recognized it was really cool, but not the details of how it worked.
01:16:33 <roconnor> c_wraith: all my type are either int or bool or function types.
01:16:51 <roconnor> c_wraith: I don't understand how it works either, which makes it hard to implement in ocaml.
01:17:43 <roconnor> maybe I should curry everything
01:18:58 <roconnor> nope
01:19:32 * hackagebot maude 0.1.2 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.1.2 (DavidLazar)
01:23:34 <roconnor> c_wraith: part of the problem is that I beleive that this is impossible to write in ocaml (without side-effects)
01:23:55 <roconnor> c_wraith: whereas darius claims it is possible without even using Lazy.
01:24:56 <c_wraith> why wouldn't it be possible without side effects?
01:25:13 <roconnor> c_wraith: because I think it requires laziness
01:25:49 <roconnor> more laziness than Lazy even provides.
01:25:54 <roconnor> that's what I think
01:26:07 <jonkri> how can i wrap an internal state with this monadic type: newtype XMPPT s m a = XMPPT { runXMPPT :: s -> m a } ? i want to be able to get the state internally in my module, but not exposing it
01:26:20 <c_wraith> Well.  Anything that can be done with call-by-need can be done with call-by-name, though potentially at a significant performance loss.
01:26:22 <roconnor> and all this talk that strict languages are adequate because you can explicitly add laziness with Lazy when you need it is bunk.
01:27:06 <roconnor> c_wraith: hmm, that is a good point.
01:27:33 <roconnor> I wonder what the strict translation of this program looks like then.
01:28:28 <scree> roconnor: out of curiousity, by cantor searching, do you mean the thing for doing exhaustive search over {0,1}^|N ?
01:28:35 <roconnor> yes
01:29:01 <scree> ah ok thanks
01:29:22 <quicksilver> Lazy is poorly named because it's merely deferred computation.
01:29:47 <quicksilver> 'lazy' evaluation is normally taken to mean caching the result for subsequent access as well
01:30:08 <quicksilver> which ocaml's Lazy doesn't really make easy.
01:30:26 <c_wraith> it doesn't implement mutation-based thunks under the covers?
01:30:28 <flux> well, you just need to use Lazy.force every time to access the value
01:30:39 <ddarius> roconnor: If you take the forsome/find_i definition and simply eta expand the calls to forsome and find_i (and eta reduce p while you're at it), you should have a program that works fine in O'Caml.
01:31:08 <ddarius> @google how to be lazy without even being odd
01:31:09 <lambdabot> http://www.cs.rice.edu/~taha/publications/conference/sml98.ps
01:31:34 <roconnor> ddarius: forsome is unary, but I'll try eta expanding find.  Thanks
01:32:38 <roconnor> ddarius: still stack overflowing
01:32:44 <roconnor> maybe I'll eta expand everything
01:33:24 <ddarius> Can you paste the code that you have currently?
01:35:19 <Bustakheops> Hi everyone, I've a problem, I want to read in a File but if I read all the file in 1 pass, I use too much memory and if I read 1 by 1, it's a little bit too slow. I think I have to use a buffer, how to do this in haskell?
01:35:39 <Bustakheops> GHC.IO.Buffer?
01:35:44 <Axman6> use bytestrings
01:35:50 <ddarius> What Axman6 said.
01:36:03 <Axman6> or if you need to read UTF data, use Text
01:36:12 <ddarius> What Axman6 said.
01:36:19 <quicksilver> flux: yes, and if you use lazy.force every time you exactly *don't* get what I just said? Or do oyu?
01:36:35 <roconnor> ddarius: http://hpaste.org/46071/impossible_ocaml
01:36:36 <Bustakheops> Axman6 : I already use Bytestring, can u give me a tips?
01:36:37 <quicksilver> flux: oh, you do. I didn't read it right :)
01:36:49 <Axman6> what sort of bytestrings?
01:37:08 <Bustakheops> Data.ByteString
01:37:09 <Axman6> also what are you doing with the data?
01:37:20 <Axman6> you should probably use Data.ByteString.Lazy
01:37:23 <Bustakheops> i want to do a gzip compressor
01:37:26 <Axman6> which chunks data
01:37:32 <Bustakheops> (huffman)
01:37:36 <Axman6> definitely should use lazy bytestrings then
01:37:52 <ddarius> roconnor: You need to eta-expand the call to find in forsome.  That's what I meant by bringing up forsome (admittedly confusingly.)
01:38:07 <Jafet> @hackage zlib
01:38:08 <lambdabot> http://hackage.haskell.org/package/zlib
01:38:37 <roconnor> ddarius: forsome is a unary function
01:38:40 <ddarius> You can eta-reduce the call to p though.  That wasn't necessary in the Haskell version, nor in this version.
01:38:49 <Bustakheops> Oo I thought Data.Bytestring was lazy !
01:38:57 <ddarius> roconnor: Not eta-expand forsome, eta expand the call to -find- -in- forsome.
01:38:59 <Bustakheops> thx 
01:39:11 <roconnor> ddarius: ah oops
01:39:15 <roconnor> I missed that eta point
01:39:36 <Axman6> Bustakheops: no, ByteString reads in a single large chunk of data
01:39:38 <aleator> How do I get cabal to include c-headers into sdists?
01:40:11 <dcoutts_> aleator: if they're in the install-includes list then they're assumed to be part of the package
01:40:17 <Bustakheops> Axman6 : thank's :) , I will continu with this 
01:40:40 <roconnor> ddarius: oops I also left out the definition of forevery
01:40:54 <roconnor> okay.  now equal f f isn't stackoverflowing
01:40:57 <aleator> dcoutts_: Ah. Thanks! I thought that was for stuff that I'd want to install for further use with the package
01:41:47 <ben> I should probably find out what makes free monad free at some point
01:41:54 <ben> I'd hate to accidentally work with non-free monads
01:42:32 <roconnor> ddarius: yay it works!
01:42:50 <dcoutts_> aleator: it is that too
01:42:53 <Zeiris_> Does ghci have a "result of last returned expression" symbol?
01:42:59 <Axman6> it
01:42:59 <roconnor> everything I know about laziness is wrong
01:44:18 <Saizan> the function type is exactly the one that's also lifted in ocaml :)
01:44:48 * roconnor is going to switch to ocaml now.
01:45:26 <aleator> dcoutts_: Seems to work. I can't understand how anything got done before cabal. :)
01:47:40 <dcoutts_> aleator: heh
01:48:13 <roconnor> ddarius++
01:50:14 <roconnor> equal f f is really really slow in uncompiled ocaml :D
01:50:45 <Kerris> OCaml :[
01:51:24 <Kerris> I had such high hopes for you
01:51:36 <Kerris> well, for us
01:51:47 <Kerris> but it's not you, it's just me
01:51:58 <roconnor> apparently all the cool things about Haskell can be done in ocaml
01:52:21 <Jafet> Except bash OOP
01:52:55 <Saizan> and higher order polymorphism without using modules?
01:53:06 <merijn> Really? OCaml has non-sucky overloading for operators and white space syntax now? :D
01:54:01 <Kerris> Haskell and OCaml are like estranged twins
01:54:26 <Jafet> Haskell is the frankenstein monster
01:55:17 <roconnor> merijn: I don't care all that much about arguments over syntax
01:55:40 <roconnor> Saizan: the latest ocaml has that as I understand
01:56:04 <Kerris> Jafet: is it? I always thought that OCaml had that "glued together from different donors" feeling about it.
01:59:17 <Philonous> roconnor: Higher kinded polymorphism is much more interesting than silly arguments about strictnes, IMO.
01:59:59 <Philonous> roconnor: Oh, you just said that, never mind
02:00:14 <roconnor> Philonous: ocaml has higher order polymorphism now AFAIU
02:00:24 <roconnor> Philonous:  I don't know about higher kinded polymorphism
02:01:17 <Saizan> polymorphic recursion?
02:01:50 <roconnor> Philonous: I used to think arugments about strictness were important.  but now I'm not longer sure since most of the examples that I tought required strictness doesn't.
02:02:07 <roconnor> Saizan: yes.
02:02:13 <roconnor> ocaml has now.
02:02:24 <roconnor> sort of had it before too I think.
02:03:23 <roconnor> Saizan: essentially you can use non-uniform data types in ocaml now without resorting to terrible hacks.
02:03:58 <roconnor> Saizan: but this is a relatively recent change as I understand.
02:07:39 <roconnor> ddarius: since Escardo's work doesn't depend on laziness then it should be easy to understand :D
02:08:03 <Saizan> ahah, there's List.rev_map, fun
02:08:52 <Saizan> roconnor: seen this? http://lukepalmer.wordpress.com/2010/11/17/searchable-data-types/
02:09:27 <Peaker> I have Leksah installed, and when trying to build, it claims I switched from ghc-6.12.1 (probably Leksah was compiled with it?) to ghc-7.0.1 (which I have installed) and also switched the matching Cabal versions.. how do I resolve this?
02:10:01 <Peaker> (so says "rerun configure" which does not help)
02:12:08 <roconnor> Saizan: thanks, that helps a little
02:13:53 <hamishmack> Peaker: try Package -> Configure
02:14:39 <arcatan> are there any hackathons planned for this year, by the way?
02:17:45 <roconnor> was there a talk of a hackathon in cambridge this summer?
02:17:57 <ezyang> yep 
02:18:10 <Peaker> hamishmack, I did, that "works" and then Package -> build says I need to configure again
02:19:06 <roconnor> @tell napping looks like I'm totally wrong
02:19:06 <lambdabot> Consider it noted.
02:19:38 <hamishmack> Peaker: do you have more than one package in your workspace?
02:20:19 <hamishmack> Peaker: If so you could try Workspace -> Clean
02:23:33 <Peaker> hamishmack, no, I am just trying leksah out for the first time
02:23:55 <Peaker> hamishmack, I just made a new workspace, new package, and tried it.  It put a bunch of fields in my .cabal file that are unsupported, too (default-language, other-extensions, ...)
02:25:31 <hamishmack> Peaker: Leksah runs "cabal configure" and "cabal build" make sure suitable "cabal" is in your PATH.
02:26:11 <hamishmack> Peaker: you could try running them from a terminal to check if they work
02:26:16 <Peaker> Arrg. Leksah gives the same hotkey to multiple menus (alt+p competes between package and panes)
02:26:43 <Peaker> hamishmack, yeah, they do work
02:27:08 <Peaker> hamishmack, only in leksah cabal configure seems to work but then cabal build complains "You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.8.0.6, now Cabal-1.10.0.0). Additionally the compiler is different (was ghc-6.12, now ghc-7.0) which is probably the cause of the problem."
02:28:56 <hamishmack> Peaker: What OS?
02:29:13 <Peaker> hamishmack, Ubuntu
02:29:17 <Peaker> be back in a few minutes
02:33:40 <mekeor> let f be a function with 2 parameters. one is "a" and the other is another function.
02:33:41 <mekeor> how can i call "f x (f x (f x (f x ……" ???
02:34:20 <scree> mekeor: fix $ f x ?
02:34:32 <mekeor> :t fix
02:34:33 <lambdabot> forall a. (a -> a) -> a
02:34:59 <scree> > let { f = (:); x = 1 } in fix $ f x
02:35:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:35:15 <mekeor> scree: THX, i'll try it
02:36:43 <Jafet> @faq can Haskell play THX?
02:36:43 <lambdabot> The answer is: Yes! Haskell can do that.
02:36:58 <shachaf> Or you could just do what fix does.
02:36:59 <shachaf> @src fix
02:36:59 <lambdabot> fix f = let x = f x in x
02:37:23 <Nereid> > let x = (:) 1 x in x
02:37:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:45:26 <bloop> (came here because I'm not sure where else)  does anyone know if there is a basis of combinators that work with grouping or function application? (that is to say, as an expression list rather than an expression tree)
02:45:38 <bloop> without grouping*
02:46:21 <Jonno_FTW> > fix 1
02:46:21 <lambdabot>   1
02:47:10 <Jafet> bloop, Jot?
02:48:05 <bloop> Jafet: Jot has application...
02:49:35 <Jafet> What kind of combinators don't use application?
02:50:01 * ezyang tries to imagine a combinator calculus without an application inference rule... 
02:50:43 * hackagebot DimensionalHash 0.1.3 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.3 (GhassenHamrouni)
02:50:52 <bloop> Jafet: I mean where application can't be "grouped"
02:51:08 <bloop> Jafet: like in Haskell if there were no parens and no . or $
02:53:25 <PeakerWork> hamishmack: I'm back
02:53:36 <PeakerWork> hamishmack: so, Ubuntu (10.10 I think)
02:53:57 <sheikra> hey, do I have a way to specify the high-order type "a -> Bool" with a parameter "a", without defining a data type? I mean ... something like sectioning?
02:53:58 <hamishmack> PeakerWork: Are you using leksah 0.10.0.4?
02:55:49 <Jafet> bloop: as far as I know, Jot is a true combinatory logic with two functions.
02:57:16 <hamishmack> PeakerWork: The reason I ask is that earlier versions used "runhaskell Setup configure"
02:57:35 <PeakerWork> hamishmack: yeah, 0.10.0.4
03:04:28 <mekeor> is following valid?
03:04:28 <mekeor> pdgreedy :: (Eq a) => Integer -> [[a]] -> [a] -> [[a]]
03:04:49 <Jafet> > let s f g x = f (g x) x; k = const; zero f = f s k; one f x y = f x y in one one one zero zero id 41 42 -- bloop
03:04:50 <lambdabot>   42
03:05:13 <shachaf> mekeor: The syntax is valid.
03:05:22 <mekeor> shachaf: thx
03:05:37 <shachaf> ghci could've told you that much, though. :-)
03:05:52 <mekeor> in the next line i wrote
03:05:53 <mekeor> pdgreedy n alll subs = n
03:05:53 <mekeor> and it doesnt work :(
03:06:22 <merijn> mekeor: That n would be an Integer, no?
03:06:27 <Jafet> Transfer it to another department
03:06:28 <mekeor> yes
03:06:57 <merijn> mekeor: In what way would you expect "pdgreedy n alll subs = n" to make sense, then?
03:07:19 <mekeor> i just wanted to test the syntax…
03:07:51 <merijn> n :: Int, alll :: [[a]], subs :: [a], returning n would make it "pdgreedy :: (Eq a) => Integer -> [[a]] -> [a] -> Integer...
03:08:23 <mekeor> F***
03:08:25 <mekeor> THX
03:08:30 <mekeor> xD
03:08:31 <mekeor> LOL
03:08:55 <mekeor> merijn: thank you very much and sorry because of the spam :D
03:09:15 <Philonous> sheikra: I'm not quite sure what you mean, "a -> Bool" is first order
03:11:01 <sheikra> Philonous: I mean the type that take a type a and produce "a->Bool".
03:11:21 <Philonous> Like in "a -> (a-> Bool)" ?
03:11:37 <sheikra> Philonous: I didn't know of a way to do this in Haskell. maybe it should be \a => (a -> Bool)
03:11:40 <Philonous> Oh, it takes a type
03:11:53 <sheikra> Philonous: yes... is there a way?
03:11:59 <Philonous> type ABool a = a -> Bool
03:12:05 <Jafet> sheikra: what do you want to accomplish with this?
03:12:33 <opqdonut_> :t undefined :: (-> Bool) a
03:12:34 <lambdabot> parse error on input `Bool'
03:12:38 <sheikra> Jafet: I want to put the type into an instance declaration without creating a data type
03:12:54 <Philonous> sheikra: Unfortunately there are no type-level lambdas. If you want to do something fancy you need newtypes 
03:12:55 <opqdonut_> :t undefined :: ((-> Bool) a)
03:12:56 <lambdabot> parse error on input `Bool'
03:12:58 <opqdonut_> gah
03:13:06 <Jafet> No type operator sections
03:13:25 <Jafet> sheikra: what do you mean, "put the type into an instance declaration"?
03:13:48 <Jafet> instance Foo a where foo :: a -> Bool -- probably not this
03:14:28 <sheikra> Jafet: something like "instance Foo (a -> Bool) where ...
03:14:49 <shachaf> I assume something like instance Foo (-> a) where ... ?
03:14:52 <shachaf> Oh.
03:14:54 <quicksilver> just turn on Flexible instances
03:15:02 <quicksilver> and you can do instance Foo (a -> Bool)
03:15:06 <sheikra> shachaf: that's what I had hoped but didn't work
03:15:17 <shachaf> sheikra: Well, that's different from what you said.
03:15:39 <Jafet> Well, a newtype won't do anything about that
03:15:44 <sheikra> shachaf: oh, yes. I meant instance Foo (-> Bool)
03:16:10 <sheikra> quicksilver: is it an option for ghc?
03:16:18 <jonkri> i think i have managed to wrap a StateT into my new XMPPT monad, but i'm not sure if i'm doing it correctly. at least one of runXMPPT and runXMPPT_ should have another name, right? all advice is very welcome :) http://hpaste.org/46074/xmppt_wrapping_statet
03:17:03 <Jafet> You can use a type synonym, but I think that uses another dirty pragma
03:17:25 <quicksilver> sheikra: yes. {-# LANGUAGE FlexibleInstances #-}
03:17:26 <shachaf> Jafet: Can you actually make that instance?
03:17:43 <quicksilver> instance Foo ((->) Bool) is also fine
03:17:48 <Philonous> Jafet: type synonyms have to be fully satisfied. You can't have type Foo a = a -> Bool and instance Functor Foo or something like that. 
03:17:52 <quicksilver> but that is not quite what you asked for, probably.
03:17:52 <Jafet> Well, Bool is in the wrong place there.
03:17:54 <shachaf> quicksilver: Sure, but that's (Bool ->)
03:17:59 <quicksilver> shachaf: right.
03:18:08 <Jafet> Philonous: oh.
03:18:18 <Philonous> quicksilver: He wants it the other way around : LAMBDA a -> (a-> Bool)
03:18:34 <quicksilver> Philonous: maybe he does, maybe he doesn't. I don't think he's being entirely consistent.
03:19:03 <quicksilver> otherwise you're stuck with newtype FunBool a = FunBool (a -> Bool)
03:19:09 <quicksilver> and instance Foo FunBool
03:19:19 <sheikra> quicksilver: If I use instance Set (a -> Bool) where ... I got a Kind mis-match error
03:19:35 <quicksilver> no doubt that is a Kind mismatch then :)
03:19:46 <quicksilver> what is that class 'Set' ?
03:20:10 <shachaf> Why can't we have type lambdas? :-(
03:20:49 <merijn> Another person who has started to secretly covet dependent types :p
03:20:57 <quicksilver> You can - the syntax for them is the newtype syntax above.
03:21:11 <shachaf> Why can't we have convenient type lambdas? :-(
03:21:13 <sheikra> quicksilver: well, I was just trying to rewrite the example in a book on SML. I want to express signitures using type classes
03:21:33 <quicksilver> because explicit constructors are the price you pay to keep type inference
03:21:35 <sheikra> quicksilver: It starts here: http://homepages.inf.ed.ac.uk/stg/NOTES/node96.html
03:21:37 <quicksilver> (that one is to sheikra)
03:21:39 <Philonous> quicksilver: Well, only up to isomorphy
03:21:50 <quicksilver> sheikra: you're on a blind alley - typeclasses are not much like signatures.
03:22:02 <quicksilver> sheikra: but if you want to traverse this alley then the newtype FunBool is the way.
03:22:36 <quicksilver> actually, "because explicit constructors are the price you pay to keep type inference" was for shachaf. Tab complete error.
03:22:48 <Philonous> isomorphism*
03:22:55 <sheikra> quicksilver: I have used data Foo a = Foo (a -> Bool) and it worked.
03:23:03 <sheikra> quicksilver: now I just want to do without a new type
03:23:07 <quicksilver> sheikra: yes. the data is the same as the newtype but fractionally less efficent.
03:23:10 <quicksilver> sheikra: you can't.
03:23:13 * shachaf curses type inference.
03:23:43 <sheikra> quicksilver: is there a good reason that I can't?
03:23:44 <shachaf> quicksilver: And fractionally different, too. :-)
03:23:54 <quicksilver> sheikra: yes.
03:23:58 <shachaf> sheikra: Yes -- see quicksilver's comment that was misaddressed to you.
03:24:09 <quicksilver> unrestricted type lambdas break type inference
03:24:10 <shachaf> s/mis/clairvoyantly /
03:24:38 <quicksilver> also, the typeclass unification algorithm is based on induction over the structure of types
03:24:49 <quicksilver> so it requires that structure be uniquely ordered
03:24:59 <quicksilver> there might be a way around that one, though
03:25:13 <quicksilver> ...but it might lead to a non-confluent unification algorithm?
03:25:15 <quicksilver> I'm not sure.
03:26:21 <sheikra> quicksilver: you mentioned FlexibleInstances. How do I write the instance using it?
03:27:02 <sheikra> quicksilver: for your earlier comments ... I'd like to compare type classes and signatures and see their connections
03:27:31 <quicksilver> FlexibleInstances lets you write instance Foo (a -> Bool)
03:27:36 <quicksilver> but that's a different Kind
03:27:40 <quicksilver> that's a Kind * not a Kind * -> *
03:27:48 <sheikra> quicksilver: oh I see
03:28:12 <quicksilver> sometimes you can do polymorphic instances of Kind * and solve some of the same problems you could solve with a class of Kind * -> *
03:28:27 <quicksilver> ...especially if you use associated types (new experimental extension)
03:28:31 <quicksilver> but it is a slightly different approach.
03:28:39 <sheikra> quicksilver: but I still think it should work without a name ...
03:28:53 <quicksilver> feel free to think that :)
03:29:09 <quicksilver> the short answer is "it could, but lots of other things would have to change and it would be a substantially different language"
03:29:19 <quicksilver> I can't list all the tradeoffs for you in this IRC channel ;)
03:30:16 <sheikra> quicksilver: yep. lambdas for types..
03:32:09 <sheikra> quicksilver: actually I'm writing this just to test one of Bob Harper's comments on Haskell type classes. " ... The first is that they insist that a type can implement a type class in exactly one way." You may want to have a look at his blog http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
03:33:41 <sheikra> quicksilver: I don't see how that could be done with signatures ;-)
03:34:19 <balor> Is there an O(1) way of pulling an arbitrary element form a Data.Set i.e. I just want to take an element, I don't care what the element is.
03:34:39 <sheikra> quicksilver: I'm pretty much sure they achieve almost the same thing
03:34:51 <opqdonut_> balor: the elements are in the leaves so unfortunately it's always O(log n)
03:35:25 <opqdonut_> balor: but you can choose some other structure that does support that, e.g. something based on finger trees
03:35:27 <sheikra> I hope somebody could give me a signature that cannot be expressed as a type class ..
03:35:30 <opqdonut_> balor: but measure first!
03:35:39 <shachaf> (a,Set a) might work too. :-)
03:35:47 <opqdonut_> indeed
03:36:39 <quicksilver> sheikra: that blog post is quite correct to point out that haskell doesn't not have a module system (of the kind he wants, with typing in it)
03:36:54 <quicksilver> sheikra: it is utterly on a false tack to mention typeclasses, except to completely dismiss them.
03:37:23 <quicksilver> sheikra: typeclasses are not a general abstraction layer, they are not signatures, they are not the basis for a module system.
03:37:40 <quicksilver> sheikra: they are a convenient mechanism for ad-hoc polymorphism and overloading.
03:38:04 <quicksilver> sheikra: ...or, from another perspective, they are a way to ask compile-time-inference to select a dictionary based on your compile-time type.
03:38:14 <sheikra> quicksilver: but I have rewritten those two examples into type classes, although I had to define a new type ..
03:38:34 <jaj> when you pass a variable to a function, internally these are actually pointers to boxed values on the heap, right?
03:38:53 <Jafet> Now, now, let's not discourage potential future olegs
03:38:55 <mauke> "pass a variable" :-(
03:39:03 <jaj> :)
03:39:04 <Jafet> Fail a variable?
03:39:07 <quicksilver> sheikra: you could just as easily have used a tuple of functions.
03:39:16 <quicksilver> sheikra: and that is proved by the fact you 'had to define a new type'
03:39:40 <quicksilver> defining a new type in order to select the correct tuple of functions (instance) is codesmell that you are abusing typeclasses.
03:39:47 <quicksilver> all you want is a tuple of functions.
03:39:55 <quicksilver> and indeed a tuple-type is a module signature.
03:40:06 <quicksilver> and a tuple of values is a simplistic model of a module.
03:40:12 <jaj> yeah I'm perhaps a bit mistaken, I was just wondering if I use a value across threads, whether the values were duplicated or not
03:40:27 <quicksilver> but it doesn't have particularly attractive uses for practical modularity.
03:40:32 <quicksilver> jaj: just a pointer; not duplicatd.
03:40:38 <jaj> quicksilver: ok thanks 
03:41:11 <quicksilver> sheikra: I think he's wrong, by the way, to suggest that haskell is a poor teaching langauge just because it's module system doesn't have the bells and whistles of ML's
03:41:17 <sheikra> quicksilver: that makes sense. I always suspect that modules are just tuples
03:41:32 <quicksilver> you certainly *can* write sensibly designed modular code in haskell.
03:41:42 <quicksilver> ...even though the lack of a module system will occasionally annoy you.
03:41:50 <Jafet> jaj: you can see for yourself using the ghci debugger, or Trace.
03:42:14 <sheikra> quicksilver: Isn't the module and import declarations Haskell's module system?
03:42:28 <quicksilver> sheikra: yes, they are. But it hardly counts as a module system by that author's definition
03:42:37 <quicksilver> sheikra: (because the modules are not typed or type-checked as a whole)
03:42:51 <quicksilver> sheikra: it's really just a namespace control system.
03:44:07 <merijn> sheikra: Also, I have noticed that as an ML fan Harper seems to enjoy trolling about how ML is superior to Haskell.
03:44:36 <sheikra> quicksilver: I start to wonder why ML signatures doesn't have the inference problem you have mentioned ..
03:45:12 <sheikra> merijn: yep. I have sensed that he is fan of ML ;-)
03:45:17 <jaj> I found out that when you do a bit more evolved things in a seperate thread, like listen on a socket and reply to incoming messages, you need to create an OS thread and it doesn't work with haskell light threads
03:45:34 <mauke> jaj: you can't create OS threads
03:45:49 <jaj> mauke: hmm, forkOS vs. forkIO
03:45:56 <mauke> jaj: that's not what forkOS does
03:46:03 <Jafet> You can, but not in ghc. Not that you should, anyway
03:46:04 <Philonous> jaj: forkOS creates a bound threat, not an OS thread
03:46:25 <jaj> ok I'll go read the doc again
03:46:42 <Philonous> jaj: All that means is that the haskell thread will never get migrated to another OS thread
03:46:43 <mauke> I've written an IRC bot without using forkOS so I'm pretty sure you're wrong regardless
03:46:59 <mauke> Philonous: that sounds wrong too
03:47:44 <jaj> mauke: yes I was calling an external lib in response to incoming messages over the socket
03:47:56 <quicksilver> if you're calling an external lib then you need to use -threaded
03:48:04 <quicksilver> forkIO vs forkOS still doesn't matter.
03:48:14 <quicksilver> forkOS is for when your external lib is not thread-safe.
03:48:41 <quicksilver> sheikra: I think the degree of polymorphism in ML module signatures is greatly restricted compared to haskell types.
03:48:55 <quicksilver> sheikra: and I think that ML does not do type inference, it only does type checking, on modules.
03:49:03 <quicksilver> sheikra: I could be wrong on both of those, though, I'm no expert.
03:51:03 <jaj> quicksilver: thanks
03:51:36 <sheikra> quicksilver: I guess maybe the reason is that ML doesn't dispatch on types. You have to pass structures explicitly. But you don't pass dictionaries explicitly in Haskell. That extra level of "cleverness" may require a new type to be created?
03:52:30 <Philonous> mauke: Apparently bound threads are not only tied to an OS thread but also do something else to make it look like they are OS threads. The doc is rather vague about that, though.
03:53:27 <quicksilver> sheikra: well, yes, typeclasses are all about dispatching on (compile-time inferred) types
03:53:37 <mauke> Philonous: as far as I understand it "bound" threads are normal threads but every FFI call from them will be executed on the same OS thread
03:53:45 <quicksilver> sheikra: I maintain my general view that that mechanism is great for ad-hoc polymorphism and poor as the basis of a module system.
03:54:07 <quicksilver> sheikra: I sometimes think the only reason people even *consider* it as a module system is the unfortunate use of the word 'class' ;)
03:54:36 <quicksilver> mauke: yes, that's right. Useful for FFI libraries with thread-local state.
03:54:44 <sheikra> quicksilver: no. the name hasn't any meaning to me. I just see the essence ;-)
03:54:46 <quicksilver> vital, rather.
03:55:02 <quicksilver> sheikra: I speak not for you, but for hundreds of confused blog authors.
03:55:16 <Philonous> mauke: That might be an accurate reading of the documentation. It is really rather unspecific about what it means. Though "bound to the OS thread that called the function" sounds like it won't get migrated.
03:55:23 <merijn> quicksilver: That's because a typeclass is like a burrito...
03:55:26 <sheikra> quicksilver: :-)
03:55:37 <merijn> ...in a submarine!
03:55:58 <sheikra> quicksilver: but I still think despite the name, type classes can (almost) express what you can do with ML signatures
03:56:21 <quicksilver> I think that tuples (and tuple types) can do that.
03:57:41 <sheikra> quicksilver: let me try that ..
04:01:54 <sheikra> quicksilver: It seems that I can't do it..
04:03:37 <sheikra> quicksilver: I have to put in an unknown high-order type and which is applied to a type variable. It doesn't seem to make any sense.
04:05:46 <quicksilver> use a polymorphic data structure (tuple)
04:06:00 <quicksilver> data Set a = { ... stuff that mentions a ... }
04:06:15 <sheikra> quicksilver: this might work ... type MySet s a = (s a, Eq a => a -> s a -> s a, Eq a => a -> s a -> Bool)
04:06:34 <quicksilver> yes, somethiing like that.
04:06:46 <quicksilver> you can always convert a class to a data type.
04:06:57 <quicksilver> ...which is precisely the type of its dictionary.k
04:08:52 <jaspervdj> edwardk: http://www.reddit.com/r/haskell/comments/gyi2u/gsoc_textutf8_call_for_benchmarks/
04:10:17 <shachaf> jaspervdj: A nice link to put on that post would be the list of accepted haskell.org projects. :-)
04:11:02 <povman> hi there! Is there an awesome network messaging system for haskell?
04:13:05 <jaspervdj> shachaf: Thanks for the suggestion, added
04:13:20 <povman> i'm thinking of using zmq
04:14:18 <jaspervdj> povman: There's zeromq bindings iirc
04:14:23 * shachaf feels guilty now for introducing an inconsistency between the haskell-cafe post and the web post.
04:14:58 <jaspervdj> Oh, no problem. There already was a slight inconsistency because I wanted to link to the thread in the web post
04:15:02 <povman> zmq combined with Data.Binary seems the way to go then.
04:15:06 <povman> ta jaspervdj 
04:15:18 <Bustakheops> how can i do something like Data.Map.toList but like this Map k a -> [(v,k)] , effectively ? because i can use toList and then revert key and value but it's bad
04:15:38 <mauke> Bustakheops: why is that bad?
04:16:21 <sheikra> quicksilver: succeeded!
04:16:31 <povman> Bustakheops: if you do a map on the result list, the flipping operation will be done at the same time as the toList
04:16:34 <Bustakheops> I think it's bad because, toList complexity is O(n)  (isn't)  and to revert it's O(n) again
04:16:42 <mux> meet laziness
04:16:51 <mauke> Bustakheops: yeah, so in the end it's ... O(n)
04:16:55 <mauke> what
04:17:07 <quicksilver> sheikra: good. Hopefully you now see that typeclasses aren't really relevant to the key issue here.
04:17:18 <mux> "How I learned to stop worrying and love the laziness"
04:17:21 <quicksilver> sheikra: you might use a typeclass to automatically select a module/dictionary for a given type.
04:17:25 <merijn> Bustakheops: O(n) + O(n) = O(n)...
04:17:31 <sheikra> quicksilver: yep. it is not really needed here
04:17:37 <Bustakheops> mauke : ok I understand :)
04:17:43 <quicksilver> sheikra: (but that's not really in the spirit of the ML example, in my opinion, which is more about different implementations with hidden internal type)
04:17:52 <Bustakheops> povman : thx too for ur solution
04:18:06 <sheikra> quicksilver: yes. that's what it is used for. I think it's like a kind of existential search in the namespace
04:18:22 <povman> ghc will convert (map f . map g) into (map (f . g))   iirc
04:18:50 <povman> Axman6: boo
04:19:43 <Philonous> Is there a way in Template Haskell to check whether two types unify?
04:20:22 <meric> Say I want to declare a type:   " type IPair a = (Int, Int, a)",  how do I say that the type of a must be an instance of Num?
04:20:24 <sheikra> quicksilver: It looks like the tuple type can hide the internal type too.
04:20:34 <mauke> meric: you can't
04:21:08 <quicksilver> sheikra: yes, it can.
04:21:16 <sheikra> quicksilver: type MySet s a = (s a, Eq a => a -> s a -> s a, Eq a => a -> s a -> Bool)
04:21:25 <sheikra> quicksilver: s1 = (FunSet (\_ -> False), \a (FunSet s) -> FunSet (\e -> e == a || s e), \x (FunSet s) -> s x)
04:21:41 <sheikra> quicksilver: FunSet was defined as : newtype FunSet a = FunSet (a -> Bool)
04:21:44 <quicksilver> in fact I don't think you want 'a' to be a parameter.
04:22:17 <sheikra> quicksilver: it will be unbound if I don't have it there
04:22:18 <meric> :(
04:25:38 <quicksilver> sheikra: it will be polymorphic, which is what you want.
04:25:46 <quicksilver> sheikra: emptyset :: forall a . s a
04:25:59 <sheikra> quicksilver: the type variable a will not appear by itself or on the output of any function type, so it is hidden.
04:26:17 <quicksilver> no, it will be polymorphic.
04:26:58 <quicksilver> emptyset will get the polymorphic type "emptyset :: forall a . s a", insert will get the polymorphic type "forall a . Eq a => a -> s a -> s a", etc.
04:29:31 <sheikra> quicksilver: isn't that correct?
04:29:57 <quicksilver> yes, that is correct
04:30:04 <quicksilver> I was just disagreeing with your use of the term 'hidden'
04:30:11 <quicksilver> it's still there and visible in the type signature
04:30:19 <quicksilver> it's just polymorphich - so it works on any type a
04:30:40 <sheikra> quicksilver: but you don't have a way to get a value of type a
04:31:05 <quicksilver> well you never have that?
04:31:06 <sheikra> quicksilver: it is still "encapsulated" in there
04:31:11 <quicksilver> no, it's not.
04:31:17 <quicksilver> it's polymorphic and the caller gets to choose it
04:31:27 <quicksilver> polymorphism is, in a sense, the opposite of encapsulation
04:31:36 <quicksilver> encapsulation means the module gets to choose it and I don't know what it is
04:31:50 <quicksilver> polymorphic means *I* get to choose it and the module doesn't know what it is.
04:32:19 <quicksilver> container libaries are hopefully polymorphic in their element type - but can encapsulate their implementation type.
04:32:57 <sheikra> quicksilver: but for a ML module, you get to choose the structure right?
04:33:37 <sheikra> quicksilver: here "choose the module" == "choose the type a"
04:34:54 <sheikra> quicksilver: I think in the ML case, the type variable a is also polymorphic in there. It is just a free type variable that can be unified to anything
04:36:33 <sheikra> quicksilver: It just acts like a bridge between the other types, and you can't get a value of type a out of a structure. The same with the tuple type case.
04:37:29 <sheikra> quicksilver: my test code is like: f (emptyset, addset, memberset) = memberset 1 (addset 1 emptyset)
04:37:44 <sheikra> quicksilver: It returns True.
04:38:32 <sheikra> quicksilver: I can't get a function which was used to represent the set out of there..
04:40:10 <quicksilver> sheikra: yes.
04:40:16 <quicksilver> sheikra: "s" is hidden, "a" i snot.
04:40:35 <quicksilver> sheikra: I was (only) disagreeing when you appeared to describe "a" as hidden.
04:40:38 <sheikra> sheikra: I can't know that the set was represented as a function from the definition of MySet either. I can only know that from the definition of "s1"
04:41:10 <sheikra> quicksilver: of course nothing can be hidden in the source code ;-)
04:41:53 <sheikra> quicksilver: maybe I should use ... existential?
04:43:13 <sheikra> quicksilver: that reminds me of Harper's blog title "Existential Type" ;-)
04:43:30 <Bustakheops> Have you ever had some problem with compiler ? I run my exec and I see stackoverflow but I know it was impossible, i restart my computer and now it's ok
04:44:19 <Bustakheops> I run with options : 1e7 +RTS -sstderr 
04:49:02 <sheikra> quicksilver: ah, there is a thing that tuple types can't do ...
04:49:37 <sheikra> quicksilver: It doesn't seem to be possible for a small tuple type to match a big tuple ...
04:49:56 <sheikra> quicksilver: and that's what ML modules can do
04:55:12 <quicksilver> sheikra: yes, that's true.
04:55:38 <quicksilver> that *is* something typeclasses could help you with
04:55:44 <quicksilver> typeclasses on your signatures
04:55:51 <quicksilver> but there might be other ways too.
04:56:15 <quicksilver> there are some HList-style tricks for certain kinds of structural subtyping I think
04:56:19 <sheikra> quicksilver: signatures seems to match the "record type" described in Pierce's book, a generalized tuple type
04:57:32 <ezyang> Is GHC clever enough to realize f (Tip k x) = Tip k (id x) doesn't require a new heap allocation? 
04:58:13 <mauke> if it inlines id, I think so
04:58:26 <sheikra> quicksilver: yep. that's structural subtyping...
04:58:33 <ezyang> yeah, w/o inlining 
05:00:04 <zygoloid> ezyang: if it's not assuming id is the identity function, that does require a heap allocation
05:00:15 <ezyang> :-/ OK. 
05:00:38 <zygoloid> (the (Tip k x) object might be shared, so it can't be mutated in place)
05:00:40 <ezyang> Anyway, I've figured out that my space leak has nothing to do with laziness. 
05:00:52 <ezyang> \o/ 
05:01:15 <quicksilver> ezyang: I don't think GHC is *ever* clever enoguh to realise that that doesn't require allocation.
05:01:25 <quicksilver> not even if id is inlined.
05:01:53 <ezyang> So, here's the real situation where this is coming up: 
05:01:54 <quicksilver> (consider f (Left x) = Left x for an example of why it might not be that simple)
05:02:32 <ezyang> I have a function f x | some_cond = constant; f x = x 
05:03:00 <ezyang> Suppose I map this function over some structure like a map; furthermore, assume some_cond is rarely fulfilled. 
05:03:27 <ezyang> If GHC can't figure out that the identity case requires no allocation, this effectively means I need to re-duplicate the spine every time I do a map. 
05:03:37 <ezyang> whereas if it could, it could preserve sharing for most of the structure. 
05:03:54 <quicksilver> I think that will always duplicate the spine.
05:04:03 <quicksilver> I think map (id) duplicates the spine
05:04:07 <zygoloid> quicksilver: add f :: Either a b -> Either a b, and ghc doesn't perform a heap allocation
05:04:23 <quicksilver> except, possibly, that there is a static RULE map id = id
05:04:31 <ezyang> yeah. 
05:04:32 <quicksilver> but static RULES are, well, static and easily fooled.
05:04:32 <zygoloid> f (x:xs) = x:xs; f [] = [] -- gets optimized to id
05:04:50 <quicksilver> zygoloid: ok, I'm wrong. Is that a relatively recent optimisation?
05:04:57 <quicksilver> I'm sure I recall a mailing list thread on this.
05:05:02 <zygoloid> i'm using 6.12.1
05:05:10 <quicksilver> !
05:05:13 <quicksilver> empiricist!
05:05:18 <quicksilver> you actually *tried* it?
05:05:23 <zygoloid> yup :)
05:05:31 <quicksilver> rather than relying on hazy memories of SPJ mailing list postings?
05:05:33 <quicksilver> boggle ;)
05:06:12 <shachaf> "Empiricism! Is that all you have to offer?"
05:07:00 <zygoloid> for all i know, i only saw consistent optimized results for all of my tests due to stray neutrinos hitting my computer
05:07:08 <zygoloid> it's still possible that ghc doesn't perform these optimizations :)
05:07:38 * zygoloid ponders how one would definitively say what GHC does and doesn't do under these assumptions
05:08:08 <zygoloid> ok, so we start by assuming a spherical GHC in a vacuum
05:10:56 <pmurias> zygoloid: you could view the output ghc generates instead of measuring performance
05:11:15 <merijn> pmurias: Could still be coincidence due to bitflips
05:11:35 <merijn> Hell, the entire output of ghc might have been produced on accident by bit flips
05:11:43 <crystal-cola> bit flips??
05:11:56 <crystal-cola> everything could just be a concidence?
05:12:18 <zygoloid> every time we look at the ghc source code, we could see the code which performs the optimization due to bit flips :)
05:12:25 <crystal-cola> omgg
05:12:37 <crystal-cola> its like hard problem of GHC
05:12:40 <pmurias> merijn: do bitflips actually happen?
05:13:07 <zygoloid> to unshielded equipment in space? yes :)
05:13:21 <shachaf> Also whenever you flip a bit.
05:13:56 <crystal-cola> the scary thing about discrete things like bits is there's nonzero chance of random effects making entropy decrease
05:15:58 <merijn> pmurias: Yes, quite often actually
05:16:53 <merijn> Most of the time you don't notice if a random bit in memory is flipped, though. Might be on a dirty inactive page, might be in an idle program, might be in a piece of data which isn't used, etc.
05:18:22 <Jafet> Might be in a gnome application, in which case no difference was made
05:18:28 <pmurias> :)
05:19:44 <merijn> My server is running ZFS now, which checksums all data. And saw more bit flips/data corruption on disk then I would have imagined happened
05:20:05 <Jafet> What did you imagine, and what actually happened?
05:20:08 <isomorphic> relevant: http://blog.ksplice.com/2010/06/attack-of-the-cosmic-rays/
05:20:43 <Jafet> (Disks already use checksums, and they already see millions of bit flips, so it's plausible)
05:21:10 <merijn> I imagined the limit towards zero flips, and found a lot more? :p
05:21:33 <Kerris> merijn: time to upgrade to ECC ram?
05:21:34 <aristid> merijn: did it also have flips in places where there are files?
05:21:41 <isomorphic> any reason that "ghci -package ghc" should fail on ghc v7.0.3? 
05:22:08 <merijn> Kerris: This was on disk, not in RAM, but I imagine RAM also has flips
05:22:20 <parcs> isomorphic: what does it fail with>
05:22:29 <Kerris> merijn: oh, I assumed that the disk flips were ram flips being written to disk.
05:22:31 <Jafet> Kerris: or a mainframe.
05:22:31 <parcs> what error*
05:22:41 <isomorphic> parcs: Loading package ghc-7.0.3 ... ghc: /usr/lib/ghc-7.0.3/ghc-7.0.3/libHSghc-7.0.3.a: no string tables, or too many
05:22:42 <isomorphic> ghc: panic! (the 'impossible' happened)
05:22:47 <merijn> aristid: Yes
05:23:21 <aristid> merijn: how big is the drive?
05:23:36 <merijn> Mind you, not a lot of bit flips (a handful of files with flipped bits in about a year, but more then I expected)
05:24:10 <merijn> aristid: 500gb, checksumming was at file level, so I wouldn't have noticed any flips in free areas
05:25:04 <aristid> merijn: so with a normal filesystem like ext4, your files would have been corrupted without repair?
05:25:15 <Jafet> I manually keep checksums for downloads for this reason, although I did a recent test through and they all passed
05:25:22 <Jafet> (A few TB)
05:25:39 <merijn> aristid: Well, I don't imagine a flipped bit in multimedia files matters anything
05:25:46 <saati> merijn: it does sometimes
05:25:58 <saati> if it's in some internal header
05:26:03 <Jafet> It might matter for a few frames, at most.
05:26:19 <saati> it can make an mp3 unreadable from a point
05:26:20 <merijn> saati: Of course, if its an unlucky bit. But in general you get a few artifacts in your video or sound
05:26:30 <Jafet> MP3 is unlistenable regardless
05:26:58 <Kerris> :|
05:29:40 <mux> flipped bit is most annoying in archive files, you have much higher chances of it ruining things up :p
05:29:55 <mux> especially if it's a good compression algorithm
05:59:18 <balor> Is there a reasonable QuickCheck 2 tutorial around?  I can only seem to find things on QC1
06:18:50 <rsuniev_> +1 wanted to find QC2 tutorials but couldn't
06:22:27 <balor> rsuniev_, The QC1 manual is good, but I can't find the same for QC2 http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
06:23:56 <rsuniev_> balor: Thanks for the link. I'll start from there. 
06:30:49 <Kerris> do QC1 tests run on QC2?
06:40:22 * hackagebot fquery 0.2.1.2 - Installed package query tool for Gentoo Linux  http://hackage.haskell.org/package/fquery-0.2.1.2 (SergeiTrofimovich)
06:40:26 <byorgey> Kerris: they might; sometimes they need a few tweaks
06:40:38 <Kerris> thanks byorgey 
06:40:43 <byorgey> e.g. the Arbitrary class was split up into two classes between QC1 and QC2
06:40:53 <Kerris> ah, that's good to know
06:41:15 <byorgey> but if you didn't define coarbitrary in your QC1 Arbitrary instances then it ought to work without change
06:49:50 * applicative is making a parody mirror of Prof. Harpers wordpress blog
06:50:03 <roconnor> applicative: I'm not sure that is a good idea
06:50:11 * applicative is having trouble automating the response to all responses, which should be "No, wrong."
06:50:21 <roconnor> heh
06:51:13 <applicative> I was thinking of things more in that nature.  Lots of specious, or palpably absurd, arguments against ML, 
06:51:16 <int-e> Be careful not to be caught in a loop.
06:51:48 <roconnor> I find it odd that Harper says that there is a difference between non-termination as an effect and non-termination as a value.
06:52:10 <roconnor> I thought the point of denotational semantics / operational semantics was that you could either way and there is no essential difference.
06:52:31 <roconnor> Isn't this what Dana Scott taught us?
06:53:07 <roconnor> (BTW, I wish Dana Scott had a blog.  He is far more cheerful :D)
06:53:08 <applicative> The bloggers will have names like "Alonzo Church" etc. then if anyone objects to a blog by say, Alonzo, someone will reply "DO YOU KNOW WHO THIS IS????" and link the amazon page for the Calculi of Lambda Conversion...
06:53:52 <applicative> Alonzo Church is NOT a beginner with the lambda calculus!!
06:54:40 <applicative> roconnor, I was attempting a parody on just this point -- non-termination as an effect and non-termination as a value. -- on reddit/r/haskell with typical incoherence.
06:54:42 <applicative> then gave up.
06:55:03 * osfameron read the comments to that post too
06:55:18 <osfameron> i.e. yes, nice parody
06:55:48 <applicative> i deleted it, partly in the hope of perfecting it as a parody 
06:56:38 <applicative> the most important thing about a language is *what happens when you open the 'repl'*, thats one of my irrational principles, modelled on several of harpers
06:57:07 <applicative> non-termination as an effect is much more rational, since it means you cant open the damn repl 
06:57:18 <applicative> it's almost like type-checking!!!
06:57:55 <applicative> the ghci is insane, it pretends to understand 'infinity = Succ infinity'
06:58:17 <applicative> it opens the file just like nothing happened!
06:58:57 <applicative> in ML you can do inductive proofs, unlike haskell.
06:59:09 <Entroacceptor> where does all the hate come from?
06:59:37 <dmwit> from deep, deep inside
06:59:41 <Kerris> people being insecure about themselves </amateur_armchair_psychologist>
06:59:56 <Kerris> dmwit said it better
06:59:59 <applicative> their content is: for all Nats n, if the interpreter opens, then n /= Succ n
07:00:17 <applicative> that's much more like ordinary math than that Haskell crap
07:00:50 <applicative> Entroacceptor:  which hate
07:06:26 <applicative> The comment of winterkonkje was the winner "he's arguing that he doesn't have skeletons in his closet (because he keeps them in the pantry instead)."
07:09:30 <Entroacceptor> applicative: spending all the time making a parody mirror
07:10:32 <Entroacceptor> ok, there's someone who doesn't like Haskell, and is vocal about it
07:10:50 <Entroacceptor> so what?
07:14:11 <applicative> Entroacceptor: I'm not that worried, I actually like him.
07:14:14 <applicative> up to a point
07:14:57 * applicative proposes higherkind.blogspot.com as the dual of existentialtype.wordpress.com
07:15:16 * applicative thinks, besides, he's my neighbor
07:16:49 <navaati> hello
07:17:07 <applicative> hello navaati
07:17:19 <navaati> @unmtl ErrorT e (Writer w)
07:17:19 <lambdabot> err: `ErrorT e (Writer w)' is not applied to enough arguments, giving `/\A. (Either e A, w)'
07:17:20 <applicative> are you studying Haskell?
07:17:24 <navaati> @unmtl ErrorT e (Writer w) a
07:17:25 <lambdabot> (Either e a, w)
07:17:27 <applicative> haha, not a beginner
07:17:54 <navaati> this lambdabot module is so useful
07:18:19 <navaati> @unmtl WriterT w (Error e) a
07:18:19 <lambdabot> Error e (a, w)
07:18:54 <navaati> @unmtl WriterT w (Either e) a
07:18:54 <lambdabot> Either e (a, w)
07:20:59 <applicative> in the paper of Sheilds and Peyton Jones on first class modules, they say they have built an interpreter for the extended language
07:21:29 <quicksilver> applicative: do they also say "But you can't have it, it is my PRECIOUSSSSS"?
07:21:44 <applicative> I wonder if that is right. Elsewhere they speak of a prototype compiler, and link an long gone cvs repositiory.
07:21:57 <applicative> I wonder if it is buried somewhere in the ghc repository
07:22:21 <quicksilver> I used to be very curious why none of the papers about module systems for haskell came to anything
07:22:43 <Philonous> Used to be? Does that mean you now know why that is the case?
07:22:47 <navaati> are first class modules so usefull ?
07:23:20 <quicksilver> Philonous: it means I no longer care so much
07:23:45 <Philonous> quicksilver: Oh, fair enough.
07:24:02 <meric> I have a function "f a b", f :: Int->Int->Int. let's say I want to `fix` "a", all I have to do is, e.g. "(f 1)", and it would curry. What if I want to fix "b"? Do i have to go (\x -> f x 1) ?
07:24:14 <quicksilver> Philonous: broadly, though, I think I do know why it's the case - because it wasn't anyone's itch. 
07:24:34 <papna> meric: flip or define a new function that re-orders the arguments.
07:24:39 <quicksilver> Philonous: in fact, despite the fact that an ML-like module system is a very nice idea, people don't have any trouble writing good, large, pieces of software in haskell.
07:24:46 <mauke> meric: (`f` 1), flip f 1
07:24:47 <meric> ooo flip.  thanks
07:24:50 <applicative> people seem to think that, though it would formerly have been an idle keeping-up-with-ML or something; now, actually it would be very useful
07:25:06 <applicative> i mean people with more understanding than, say, me. 
07:25:13 <quicksilver> (or if they do have trouble, the problem isn't with the module system)
07:25:19 <aristid> quicksilver: if people manage to write big applications in c++ (which has no module system at all), they can probably do so in haskell
07:25:26 <quicksilver> aristid: quite.
07:26:10 <quicksilver> also, module-level polymorphism is quite antagonistic to GHC's heavily inlining-based approach to efficient compilation.
07:26:32 <quicksilver> so even if you had a really nice module/signature system for, say, alternative string-like types, you couldn't actually *use* it
07:26:49 <quicksilver> because they'd all compile badly if the polymorphism hid the inlining opportunities from the compiler.
07:27:46 <aristid> quicksilver: a smarter compiler might find them anyways
07:28:11 <quicksilver> aristid: not without abandoning separate compilation of libraries. I think.
07:28:12 <papna> It's a well-known problem that greater dynamism leads to more difficulties in optimization.
07:28:17 <navaati> is there a way to automatically derive monad transformers instances ?
07:28:24 <quicksilver> but for an appropriate definition of 'smarter' then, yes, sure, as you say.
07:28:53 <PeakerWork> where there's a will there's a way
07:29:01 <quicksilver> navaati: can you be more precise?
07:29:19 <Philonous> The itch now seems to be that "some People" use the missing module system as an excuse to dismiss Haskell as unusable.
07:29:33 <applicative> there is not {-#LANGUAGE DeriveMonadTransformer #-}
07:29:57 <shapr> Philonous: "Some people" will always find a reason to dismiss Haskell as unusable.
07:30:05 <quicksilver> Philonous: has the haskell community not yet learnt to ignore trollbait from people matching Har.* ?
07:30:29 <aristid> quicksilver: Harrop and Harper?
07:30:39 <shapr> Philonous: Forth is missing many features of Haskell, but it's still fun to write, and the best choice for some situations.
07:30:41 <papna> If you're looking for reasons to declare Haskell unusable, there's no need to complain about the lack of first-class-modules.
07:30:42 <quicksilver> aristid++ # excellent regexp engine
07:30:47 <lispy> oh man, that Harper guy is anti-Haskell/pro-SML
07:30:52 <applicative> Philonous, that's silly of course, but e.g. Duncan C. pointed out that cabal's gruesome inferences would be easier in some ways 
07:31:05 <shapr> aristid++ # successful Jeopardy answer
07:31:15 <aristid> shapr: i'd totally beat watson!
07:31:23 <shapr> aristid: totally!
07:31:36 <applicative> lispy, join my imaginary mirror blog! I've automated the response to all objections: No, you're wrong. 
07:31:38 <Philonous> quicksilver: Apparently not. Though I'm not sure I want to dismiss Harper as a troll. 
07:31:39 <aristid> lispy: his poor students :(
07:32:07 <quicksilver> Philonous: his comments about haskell were either simply wrong, or trolling, depending how forgiving you are
07:32:08 <navaati> I created a monad transformer, newtype SupplyT r v m a = SupplyT (StateT (Supplier r v) m a)
07:32:08 <navaati> where newtype Supplier r v = Supplier (r -> (v, Supplier r v))
07:32:12 <crystal-cola> whats this about Harper
07:32:13 <aristid> Philonous: you prefer to dismiss him as ... wrong? :)
07:32:16 <crystal-cola> BOB Harper?
07:32:25 <lispy> Philonous: agreed.  He has troll-like tendencies, but I don't see him as a typical troll yet
07:32:26 <applicative> aristid, i was imagining how he must teach them.  "No, wrong", "It's amazing how many misunderstandings you have"  "No, wrong, it's impossible"
07:32:37 <applicative> kind of a reverse Socratic methods
07:32:39 <applicative> method
07:32:43 <shapr> ouch
07:32:48 <crystal-cola> can someone show me what is going on 
07:32:49 <aristid> applicative: that said, maybe not too different from many other university experiences.
07:32:52 <quicksilver> navaati: using the GeneralizedNewtypeDeriving extension
07:32:57 <crystal-cola> I don't know what you are talking about
07:33:11 <quicksilver> navaati: you can simply write 'deriving MonadState (Supplier r v)'
07:33:14 <osfameron> crystal-cola: http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
07:33:17 <shapr> crystal-cola: Recent blog post saying that Haskell is unsuable because it doesn't have module awesomeness.
07:33:18 <aristid> http://existentialtype.wordpress.com/
07:33:21 <quicksilver> navaati: ...if that's what you want.
07:33:22 <aristid> the whole blog.
07:33:26 <crystal-cola> is that anything to do with module systems?
07:33:31 <applicative> crystal-cola: no
07:33:32 * hackagebot DimensionalHash 0.1.4 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.4 (GhassenHamrouni)
07:33:35 <crystal-cola> I thought it was just he said something slightly wrong about ML
07:33:40 <aristid> shapr: and because it is lazy. which means you can't have Nat.
07:33:45 <aristid> or something like that :)
07:33:45 <crystal-cola> Is this Robert Harper?
07:33:49 <applicative> the module complaints were interesting. this is more fatuous
07:33:59 <crystal-cola> http://www.cs.cmu.edu/~rwh/ ?
07:34:02 <byorgey> crystal-cola: yes
07:34:05 <applicative> crystal-cola: you should say:  Is the THE Robert Harper?
07:34:11 <crystal-cola> Existential Type. Research and teaching blog.
07:34:11 <crystal-cola> Homotopy Type Theory. Higher-dimensional type theory blog.
07:34:14 <crystal-cola> these are his blogs
07:34:17 <navaati> But i don't want MonadState, I want MonadError for "SupplyT r v m a" where m is a MonadError
07:34:24 <roconnor> ocaml isn't lazy and it doesn't have Nat either, so the issue isn't entirely about laziness.
07:34:30 <navaati> (and the same for MonadWriter)
07:34:32 * hackagebot representable-functors 0.4.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.4.0 (EdwardKmett)
07:34:34 <crystal-cola> He posted some seriously disgusting crap on the homotopy blog
07:34:50 <applicative> I will also automate the slavish epigone response, DO YOU KNOW WHO THIS BLOGGER IS???  as a response to all criticisms
07:35:08 * osfameron suspects you could do a year of introductory FP while entirely missing any arbitrary feature of any language
07:35:13 <crystal-cola> oh I take that back
07:35:18 <applicative> crystal-cola: oh really?  '
07:35:26 <crystal-cola> Dan Licata is the culprit
07:35:27 <osfameron> i.e. you could learn Haskell for a year, and *still* come back the following year and learn Modules or whatever he thinks is vital
07:35:37 <byorgey> oooh, representable lenses
07:35:38 <Philonous> applicative: You can hardly blame him for the stupidity of his fan base.
07:35:39 <byorgey> edwardk++
07:35:40 <applicative> what was wrong with Licata's remarks?
07:35:41 <crystal-cola> I don't really want pepole to see it but I guess I have to back up my claim http://homotopytypetheory.org/2011/04/23/running-circles-around-in-your-proof-assistant/
07:35:48 <applicative> Philonous: of course not
07:36:13 <applicative> Philonous: my rage is carefully controlled, I'm just doing it here
07:36:31 <crystal-cola> "Yes, but unfortunately the algebraic type system in Haskell is fundamentally broken, rendering it useless for my purposes (and creating a lot of problems for everyone)."
07:36:36 <applicative> Philonous: while I study my sml....
07:36:43 <crystal-cola> Haskell doesn't have (co)algebraic types because of partiality?
07:36:49 <crystal-cola> Is that the argument?
07:37:03 <roconnor> crystal-cola: what am I looking for on that page?
07:37:06 <crystal-cola> kind of a weak argument, programming languages have /never/ corresponded to the theory
07:37:12 <quicksilver> navaati: if the MonadError instance exists for StateT (the type you are wrapping) then GeneralizedNewtypeDeriving can pull it through the newtype
07:37:16 <lispy> Do you guys know what he meant about strict vs. lazy and only emitting sum vs. product types?
07:37:29 <roconnor> lispy: I think I do ... though not certain
07:37:30 <quicksilver> navaati: GeneralizedNewtypeDeriving can pull any class through a newtype wrapper.
07:37:35 <crystal-cola> he is completely abusing type theory to trick it into giving out free reduction rules 
07:37:45 <crystal-cola> and people are like "wow cool trick im gonna use that"
07:37:49 <crystal-cola> it make me sick
07:38:15 <roconnor> crystal-cola: I don't see Harper's name on that Homotopy Type Theory link
07:38:27 <crystal-cola> yes I retracted that earlier
07:38:37 <roconnor> oh ok
07:38:40 <roconnor> lispy: http://www.reddit.com/r/programming/comments/gwqa2/the_real_point_of_laziness/c1r2cyz
07:38:52 <crystal-cola> can anyone explain to me what is the problem?
07:39:03 <crystal-cola> Bob Harper says haskell data types aren't algebraic?
07:39:05 <applicative> crystal-cola: It's true there's a difference between the Haskell treatment of e.g. infinity = Succ infinity and the ML one.
07:39:07 <crystal-cola> so were upset about that?
07:39:23 <crystal-cola> applicative: oh what is the difference?
07:39:35 <crystal-cola> applicative: I didn't realize until recently that infinity = Succ infiity was valid in Ocaml
07:39:41 <applicative> crystal-cola: I think so, each type has an extra element, and a polymorphic `undefined`
07:39:54 <applicative> is it? that shouldn't be my example then
07:40:10 <roconnor> applicative: it is valid ocaml but (I think) not valid SML
07:40:22 <crystal-cola> if his argument is just "practice doesn't correspond closely enough to the theory" then uh.. Well that's not news to anyone
07:40:37 <applicative> okay,i've been going back and forth between them maybe settling for sml now
07:41:27 <applicative> is there a version of ML that has something more like GHCi.
07:41:39 <lispy> roconnor: cool.  I'm at work now so probably shouldn't delve in to that, but I'll put that on my list of things to read tonight.
07:41:40 <aristid> crystal-cola: ML has hand-waving about how functions can have side-effects, and haskell has hand-waving about how values can be undefined. or that's how i understand it
07:41:43 <crystal-cola> reddit is in "emergency read-only mode" right now. <-- who designed the internet? It sucks
07:41:57 <Botje> i believe amazon did
07:42:06 <aristid> damn you, jeff bezos!
07:42:21 <crystal-cola> aristid: doesn't ML also have the undefinedness thing? Or not?
07:42:41 <applicative> crystal-cola: reddit is surprisingly disaster prone.  It's probably written in some avant garde hyper functional programming language
07:42:59 <crystal-cola> well I guess we could do something like  let rec undefined () = undefined ()  but it will just mean infinite loops happen much sooner (lack of lazyness)
07:43:13 <crystal-cola> they rewrite it from lisp to python... I can see that worked well :/
07:43:33 <crystal-cola> "hey our site is not broken, let's rewrite it in python"
07:43:49 <aristid> crystal-cola: i think ML brings in the undefinedness thing implicitly via side-effects.
07:43:54 <crystal-cola> I don't understand what this argument on the bob harper site is about at all
07:44:03 <aristid> crystal-cola: AFAIK you can't have general recursion otherwise
07:44:34 <aristid> i hope i'm not saying complete bullshit :D
07:44:54 <crystal-cola> I get what you are saying, I just don't know why there's such a fuss about this blog post
07:44:58 <crystal-cola> I read it and it seems pretty tame
07:45:09 <aristid> he's the enemy of the state
07:45:17 <crystal-cola> he's a seriously cool guy IMO
07:45:26 <applicative> the business about how you can't reason inductively would seem to be the most serious complaint, crystal-cola
07:45:39 <crystal-cola> well you can reason inductively about inductive types
07:45:46 <applicative> that is linked in this post, elaborated elsewhere, but not there to the disadvantage of haskell
07:45:48 <aristid> applicative: but you can't really do that either in ML, due to side effects.
07:45:58 <crystal-cola> just carve out a subset of haskell which inductive types can be interpreted into
07:46:03 <crystal-cola> we've been doing this for years
07:46:18 <applicative> aristid: well, fine.  I was just pointing out what seems the interesting core of it. 
07:46:56 <applicative> is roconnor here, i think he or one of the theoretical #haskellers suggested there was something in it, and that equational reasoning is the haskeller's forte
07:47:00 <crystal-cola> anyway what's all this nonsense about "reasoning about programs"? Nobody does taht X)
07:47:17 <crystal-cola> we just hit random keys until the type checker gives the a-okay
07:47:42 <applicative> crystal-cola: in haskell that's what we do but in serious languages like sml and java, they reason.
07:48:08 <aristid> i heard you can only reason if you draw diagrams
07:48:17 <crystal-cola> I don't know if that's true or false, lots of people care about what java code means soo.. dunno
07:48:28 <applicative> aristotle says, no human thinks without an image.  
07:48:39 <papna> Tell that to Hellen Keller.
07:48:48 <papna> (Helen even.)
07:49:16 <applicative> images can be tactile, cant they?  image  = operation of the imagination
07:49:34 <aristid> applicative: i hope that aristotle was intended to be a pun on my name :)
07:49:51 <applicative> you are both aristoi
07:50:12 <aristid> what does that mean?
07:50:15 <applicative> best
07:50:23 <applicative> noblest
07:50:24 <aristid> that's true! :D
07:50:41 <applicative> aristotle = noblest end; aristd = noblest "d"
07:51:00 <aristid> lol
07:51:14 <applicative> aristocracy = rule of the best (hah)
07:51:25 <crystal-cola> The point of lazyness? What's the pun
07:51:27 <crystal-cola> I don't get it
07:51:38 <applicative> bottom, get it, all types have a point in them
07:51:56 <applicative> even data Void where 
07:52:03 <aristid> i don't know if ML has general recursion for values
07:52:11 <aristid> but i think it does, for functions at least
07:52:12 <applicative> with -XEmptyDataDecls
07:53:02 <tromp_> what are the biggest applications that have been written in ML?
07:53:43 <aristid> jane street uses ML afaik
07:53:56 <aristid> and CMU
07:53:58 <applicative> aristid, doesn't that follow, from the main points? (I'm just beginning ml-ing) the constraints on values you can define are tighter. 
07:54:40 <aristid> applicative: tighter in what way?
07:54:43 <applicative> what for us are just top level expressions, for ML divide, you can get away with murder with fun x
07:54:55 <edwardk> aristid: ocaml mostly
07:55:07 <aristid> edwardk: that's still a ML :)
07:55:13 <osfameron> isn't Haskell an ML?
07:55:18 <aristid> osfameron: NO!!!
07:55:20 <aristid> stone him
07:55:36 <applicative> edwardk: I was studying ocaml for a couple weeks, but switch to sml, so I'm in a double state of ignorance
07:55:38 <osfameron> it's based on Miranda which was based on ML, I thought?
07:56:02 <edwardk> osfameron: a lot of things borrow from ml, we borrowed the basics of hindley-milner/damas-milner typing, but that is a long shot from being "an ML"
07:56:08 <applicative> edwardk, I saw a cool letter on the Libraries list, I meant to point out
07:56:28 <osfameron> edwardk: fair enough.  Is there a "family name" for this type of language though?
07:56:56 <aristid> osfameron: hindley-milner language, maybe?
07:57:02 <osfameron> as for example C# and Java are in the C family
07:57:04 <osfameron> ah ok
07:57:12 <aristid> C# and Java are NOT in the C family
07:57:12 <osfameron> it's a bit wordy, but fair enough ;-)
07:57:23 <osfameron> aristid: descendants thereof
07:57:40 <osfameron> aristid: though I suppose the same applies to Perl, which really isn't close "C family" either
07:57:42 <aristid> there may be some syntactical heritage, but they are completely different languages
07:57:46 <edwardk> well, you might say 'hindley-milner' if you wanted to arc over both haskell and ml, but the haskell-likes and the ml-likes are fairly broad categories in their own right ;)
07:58:08 <aristid> edwardk: where haskell is the only prominent representative of the haskell-likes?
07:58:17 <aristid> i guess Clean and Agda would be in the same family, tho?
07:58:27 <aristid> or maybe not agda
07:58:41 <edwardk> and it isn't quite right since ghc uses some pretty whacky extensions that take it pretty far out there
07:58:54 <edwardk> aristid: curry, ddc, agda, etc.
07:58:56 <edwardk> clean
07:59:14 <aristid> edwardk: what are the common characteristics of these?
07:59:20 <edwardk> aristid: 'where' ;)
07:59:25 <aristid> oO
07:59:26 <quicksilver> edwardk: well, since originally "an ML" meant "a metalanguage", I guess you could say haskell is one of those - it's very much in the same vein as the proof tactics languages.
07:59:26 <jkff> Hi. Is it true that monad transformers are still "up to 300% slower" (acc.to haskellwiki), and if I need performance I should use something else?
07:59:30 <aristid> syntax is vain
07:59:35 <osfameron> edwardk: from my perspective (a C-like / dynamic one, mostly) if I look at Ocaml, my first thought is "Oh, that looks quite a lot like Haskell".  That's probably why I thought they were same "Family"
07:59:42 <edwardk> aristid: and generally the lack of a 'fun'/'val' distinction
07:59:43 <jkff> my stack is not large - StateT Writer, but still.
07:59:58 <osfameron> jkff: *do* you need performance? ;-)
07:59:58 <edwardk> aristid: well, there are some fundamental reasons why strict languages need more syntax for describing that crap =P
08:00:00 <Botje> jkff: there's always the RWS monad
08:00:18 <ezyang> Next comix installment out: http://blog.ezyang.com/2011/04/functions-produce-the-haskell-heap/ 
08:00:30 <applicative> edwardk:  I see, you have already entered the thread I was going to point out
08:00:32 <ezyang> Lemme know if I got anything wrong. 
08:00:42 <jkff> osfameron: well, I am not completely sure that I do need it in this exact point of the program, but I certainly do need it in my program, and this is one of the central points in the program :) Generally I'm just curious.
08:01:06 <jkff> Botje: Do you mean that the RWS monad is explicitly optimized?
08:01:48 <applicative> edwardk: I was impressed by the point that force of  Applicative and your Semigroupoid can be summarized with f a -> f b -> f (a,b)
08:01:48 <edwardk> applicative: which one?
08:02:06 <applicative> this one ^^^ 
08:02:22 <Botje> jkff: RWS is a manual combination of reader, writer, state
08:02:42 <edwardk> applicative: ah my Apply being a semigroupoid for static arrow composition?
08:02:46 <applicative> then f (a -> b) -> f a -> f b is fmap (uncurry ($)) 
08:02:46 <jkff> Botje: Oh ok, sounds good, thanks!
08:02:54 <applicative> sorry, right i mean APPLY
08:02:58 <din_> just trying out the online interface intro and it seems a bit whacked...
08:03:03 <applicative> my mind was in the semigroupoid package
08:03:34 * hackagebot DimensionalHash 0.1.5 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.5 (GhassenHamrouni)
08:05:03 <applicative> to complete the fragment, the principle operation in Applicative and Apply could give you f (a -> b) -> f a -> f b by  fmap (uncurry ($)) (product f x)
08:06:13 <edwardk> applicative: sure, in general the (f a, f b) -> f (a, b) version is more 'canonical' because it provides the mapping of the product of the source category onto the product of the target category, but it is far less useful. ;)
08:08:19 <applicative> edwardk: yes, but it could be an alternative method like this http://hpaste.org/46078/apply
08:08:58 <edwardk> applicative: yeah, i actually provide something like that in another module somewhere, one sec.
08:09:00 <applicative> that it maps products below to products above was striking me as a useful point
08:09:21 <edwardk> http://hackage.haskell.org/packages/archive/keys/0.2.3/doc/html/src/Data-Key.html#Zip
08:09:30 <edwardk> zip has that form, and zap is more applicative
08:09:31 <applicative> at best the interest would be that in some cases it might be easier to write this instance
08:09:49 <applicative> i see, yes, it's exactly like zip
08:10:14 <edwardk> that class is stronger than Apply in that it implies a semantics for how the applicative must work
08:11:55 <edwardk> as for Apply i didn't really want to rock the boat too much, its just Applicative sans pure for semigroupoid use
08:13:07 <applicative> i'm not seeing how the Zip  class is stronger yet
08:13:28 <copumpkin> applicative: clearly you're biased, based on your name
08:13:38 <edwardk> when/if i ever reintroduce a monad hierarchy that works over arbitrary categories though, that product based definition will probably be the default one for applicative, if only because it doesn't assume the existence of exponentials in the category
08:14:16 <edwardk> applicative: its the laws, the applicative for zip has to join by key. for instance on a list the semantics are those of a ziplist applicative, not those of the list applicative
08:14:16 <applicative> copumkin, no i'm dropping Applicative for typeclass Order 
08:14:28 <copumpkin> :P
08:14:36 <edwardk> you should just generalize to semigroupoid and be done with it
08:14:53 <edwardk> until i figure out a way to make a semigroupoidoid
08:15:13 <order> copumpkinm i replace f (a -> b) -> f a -> f b with f a -> f b -> f (a,b)
08:15:24 <copumpkin> oh fancy
08:16:25 <aristid> edwardk: you got a fan, there :D
08:16:47 <semigroupoidoid> copumpkin: it's a trivial point from a kmettian point of view but I was impressed by this letter, 
08:16:53 <semigroupoidoid> http://www.haskell.org/pipermail/libraries/2011-April/016242.html
08:17:54 <Runar> @hoogle m a -> m b -> m a
08:17:54 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
08:17:54 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
08:17:54 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
08:17:57 <applicative> copumpkin: and the similarly obvious point that it makes the   'sequencing' aspect of applicative etc. obvious
08:19:03 <edwardk> applicative: the problem with that definition from a practical standpoint is all the tuple construction is annoying =P
08:19:30 <applicative> edwardk: yes, it would be more interesting if we didn't do unrelenting currying
08:19:57 <aristid> order :: m a -> m a -> m (a,b)
08:20:00 <aristid> that's supposed to be
08:20:04 <aristid> order :: m a -> m b -> m (a,b)
08:20:05 <aristid> right?
08:20:09 <copumpkin> yeah
08:20:18 <applicative> then we would just fmap all our typically uncurried functions.  I recommend it for introduction into C
08:20:21 <c_wraith> seems difficult to implement if not :)
08:20:37 * hackagebot hfusion 0.0.3 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.3 (FacundoDominguez)
08:20:48 <edwardk> i actually had missed the beginning of tyson's comments, i only interjected on henning's attempt to add a needless law and the false generalization of mfix
08:21:08 <applicative> aristid, sorry did I say that? yes order :: m a -> m b -> m (a,b)
08:21:31 <aristid> applicative: if you are tyson whitehead, then yes, you said that
08:21:47 <applicative> oh, hah, funny, i didn't notice it in him...
08:22:14 * applicative is accustomed to reading his own bad typing so tyson w's is no problem
08:22:33 <aristid> lol
08:23:15 <edwardk> i also don't really grok his choice of name 'order' for 'phi' http://en.wikipedia.org/wiki/Monoidal_functor
08:24:10 <applicative> well, he calls it Applicative' with a prime
08:24:19 <aristid> edwardk: order, as in "first a, then b"
08:24:42 <copumpkin> this is why indexed monads (the double-indexed ones) are superior!
08:24:50 <copumpkin> they show you the order too!!
08:24:55 <copumpkin> zomg
08:25:02 * applicative will have to meditate on that
08:25:06 <edwardk> copumpkin: =)
08:25:34 <edwardk> aristid: meh. not convinced there is any notion of order present in the mapping of products
08:25:35 <osfameron> hehe. Publishers of TaPL have replied to "Will you release it as eBook?" with "Probably, but not yet."
08:25:39 <osfameron> which is fair enough, I suppose.
08:25:46 <applicative> well I think we should call it Monoidal_Functor , no, Appendable_F
08:25:46 * osfameron will have to take it out of library again then :-(
08:26:05 <edwardk> I would prefer 'Monoidal'
08:26:20 <applicative> osfameron: what isn't it only a few hundred dollars?
08:26:38 <osfameron> applicative: less even.  But it's very heavy.
08:27:00 <osfameron> I've actually been *reading* RWH for example, now that I don't have to lug it to work and back
08:27:10 <applicative> and then a class Monoidal f => Commutative f where swap :: f (x,y) = f (y, x)
08:27:17 <edwardk> i have surprisingly few ebooks on my tablet
08:27:20 <osfameron> anyway TaPL is free if I borrow from library
08:27:26 <applicative> that's no good
08:28:10 <edwardk> applicative: you probably would rather have that be associated with the target symmetric monoidal category
08:28:10 <hpc> applicative: s/=/->/?
08:28:32 <applicative> hpc, yes sorry as usual
08:28:44 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Category-Braided.html
08:28:46 <edwardk> er
08:28:48 <edwardk> wrong version
08:29:04 <edwardk> http://hackage.haskell.org/packages/archive/categories/0.55.0/doc/html/Control-Category-Braided.html
08:29:49 <hpc> @tell BONUS the book came, and it is awesome
08:29:49 <lambdabot> Consider it noted.
08:29:57 <edwardk> that will let you braid Either or (,) in arbitrary categories
08:29:58 <byorgey> osfameron: knowing Benjamin Pierce, he would probably be opposed to its release as an ebook unless it was very beautifully done.
08:30:18 <applicative> i see.  slowly a few of these esoterica like Braided are making sense
08:30:21 <byorgey> osfameron: but I don't know the nature of his agreement with the publisher (i.e. whether he would get a say in the matter).
08:30:56 * applicative would rather read Pierce blogging that Harper
08:30:59 <applicative> than
08:31:14 <applicative> hey rtharper
08:31:19 <copumpkin> lol
08:31:33 <copumpkin> different r harper
08:31:37 <rtharper> hihi
08:31:42 <edwardk> kinda figured =)
08:31:46 <rtharper> wah?
08:31:47 <hpc> edwardk: swap = braid?
08:31:57 <applicative> rtharper stop attacking Haskell, you brute!
08:31:57 <hpc> oh, it does
08:31:58 <rtharper> I seem to be disappointing a lot of people lately...
08:31:58 <hpc> :D
08:32:02 <copumpkin> hpc: with the additional constraint that it's an involution
08:32:05 <edwardk> swap is braid with a stronger condition that swap . swap = id
08:32:08 <crystal-cola> ????????????????????????????????/
08:32:12 <edwardk> braid isn't that strong
08:32:18 <osfameron> byorgey: ah, hehe.
08:32:25 <copumpkin> crystal-cola: agreed.
08:32:25 <applicative> rtharper, I'm calling the ops!
08:32:29 * hpc is getting the hang of this category theory stuff
08:32:34 <rtharper> :(
08:32:40 <applicative> rtharper+
08:32:43 <osfameron> oh, I quite enjoyed harper's blogs on teaching FP, was surprised at the most recent one
08:32:59 <osfameron> s/blogs/posts/ gosh, I didn't realise *I* did that too
08:33:02 * applicative takes it all back, rtharper is ever haskeller's friend
08:33:09 <edwardk> osfameron: he doesn't like his ADTs sharing a domain with _|_
08:33:36 <crystal-cola> impersonation??
08:33:43 <applicative> osfameron: me too. Even with this one the ensuing tempest in a teapot was instructive
08:33:46 <rtharper> I change my nick from an unpronounceable Irish word to MY NAME and *that* confuses peopel
08:33:59 <hpc> rtharper: what was your old nick?
08:34:04 <hpc> oh
08:34:07 <edwardk> but then you wind up with horrible fun/val distinctions, need to distinguish between recursive and non-recursive lets, etc. so the benefits aren't worth the price of admission
08:34:08 <osfameron> aha
08:34:09 <balphas> anyone used Network.Riak library ?
08:34:18 <sioraiocht> happy :D
08:34:20 <applicative> oh i remember sioraiocht
08:34:24 <crystal-cola> is sioraiocht robert harper?
08:34:24 <balphas> i'm getting confused with some weird behaviour wrt to type variables
08:34:51 <sioraiocht> crystal-cola: no
08:34:54 <applicative> crystal-cola: it's just an accidental similarity of names. I foolishly made play with it.
08:34:58 <crystal-cola> I hate these integrals
08:34:59 <osfameron> edwardk: they seem like very subtle distinctions?  (that's probably just because I don't understand them, as the only FP-language-of-this-family that I know at all is Haskell)
08:35:02 * sioraiocht is Tom Harper
08:35:24 <shapr> o hai sioraiocht
08:35:30 <shapr> sioraiocht: where's rtharper?
08:35:30 <sioraiocht> lol hai hai shapr
08:35:42 <sioraiocht> apparently there's a robert harper lurking
08:35:42 <Twey> Haha
08:35:45 <sioraiocht> in the world
08:35:51 <edwardk> osfameron: basically the very thing bob is complaining about is where haskell derives most of its elegance of syntax
08:35:52 <sioraiocht> and he has upset people
08:35:58 <Twey> < shapr> o hai sioraiocht — for a moment, I parsed this as Irish
08:36:02 <balphas> hi peeps
08:36:06 <crystal-cola> edwardk: what is it?
08:36:08 <shapr> Twey: pogue mah... ah never mind.
08:36:24 <c_wraith> balphas: the author of that library is here sometimes.  goes by bos
08:36:32 <Twey> Haha
08:36:34 <crystal-cola> who is upset about it? Did he say anything that is false?
08:36:44 <crystal-cola> or is it just "my opinion is _____" type stuff
08:36:45 <edwardk> crystal-cola: he got his dander up about the effect of laziness on the semantics of haskell ADTs
08:36:53 <Robert_Harper> edwardk: this is what bugs me. He has studied ML for so long that he is blind to the hideousness of the syntax.
08:36:55 <balphas> c_wraith: thanks
08:36:58 <crystal-cola> eys I read that post but I don't get it
08:37:00 <osfameron> edwardk: would it help for me to follow an Ocaml (say) tutorial to better understand what it is that's different?
08:37:01 <sioraiocht> Is feidir linn Gaeilge a labhair..
08:37:06 <crystal-cola> why are people so bothered about it?
08:37:07 <sioraiocht> féidir*
08:37:43 <edwardk> Robert_Harper: yeah in the same sense that lispers and schemers become blind to ()'s
08:37:56 <copumpkin> and we become blind to " "
08:38:01 <edwardk> osfameron: perhaps. it may take a while to get to the point where it becomes apparent
08:38:04 <djahandarie> Haha
08:38:07 <osfameron> copumpkin: heh
08:38:08 <Robert_Harper> edwardk: I think it's worse than that, not really comparable
08:38:08 <Twey> shapr: Is that Irish too?  I know that phrase in Scottish Gaelic (or something that sounds like it, don't ask me about spelling :þ)
08:38:29 <copumpkin> whereas all the c-like language people are like "wtf, why are there no parentheses and needless crud to separate the good stuff from other good stuff???"
08:38:32 <osfameron> how about blindess to ($) and lift* ?
08:38:44 <balphas> Robert_Harper: are you talking about the guy who became famous through his blog posts slating lazy evaluation?
08:38:47 <edwardk> crystal-cola: mostly because many of his retorts boiled down to 'you are wrong'. he is right in a very blinkered way, but his point is sort of drowned out by his delivery
08:38:51 <sioraiocht> Twey: he meant póg mo thóin
08:38:56 <sioraiocht> i.e. kiss my ass
08:38:56 <shapr> sioraiocht: exactly!
08:38:58 <crystal-cola> ahh I see
08:39:12 <Robert_Harper> balphas: I was already famous as you can see from the links my epigones give in the comments
08:39:12 <Twey> sioraiocht: Is that valid in Irish too?
08:39:13 <crystal-cola> well people sho;uld just not be wrong
08:39:15 <djahandarie> balphas, he didn't become famous though that. :)
08:39:18 <edwardk> balphas: hint: he became famous by doing little things like formalizing ml's module system
08:39:22 <crystal-cola> then if he says that, he's wrong
08:39:25 <sioraiocht> Twey: yes
08:39:30 <Twey> Neat
08:39:38 <sioraiocht> tóin is the word for bum, as opposed to donkey
08:39:48 <Twey> Yes :þ
08:39:50 <balphas> well, being famous doesn't make one right
08:39:55 <Twey> ‘Arse’ is the word you're looking for, I believe
08:39:57 <copumpkin> balphas: sure it does
08:40:06 <edwardk> balphas: he wrote a little book with a dead guy you might have seen: http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3874
08:40:12 <balphas> copumpkin: so Paul Graham is right too :)
08:40:14 <Robert_Harper> Haskell is a menace, it makes people think they can just introduce terms by giving a definition.
08:40:24 <copumpkin> everyone famous is right
08:40:36 <Robert_Harper> In a serious language you do it by a command, eg. let foo .... 
08:40:40 <Robert_Harper> or fun => blah
08:40:52 <edwardk> copumpkin: not always, but it helps ;)
08:41:05 <crystal-cola> :/
08:41:07 <balphas> Robert_Harper: what is a serious language exactly?
08:41:11 <Robert_Harper> copumpkin, Nope, I'm right!
08:41:12 <crystal-cola> I dont like this impersonation
08:41:27 <sioraiocht> Twey: I was trying to be polite =p
08:41:35 <Twey> Haha
08:41:37 <copumpkin> crystal-cola: sioraiocht actually _is_ robert harper though
08:41:40 <edwardk> yeah the real bob harper would be too busy doing his radio show to be on irc anyways
08:41:56 <crystal-cola> radio show??
08:42:01 <aristid> copumpkin: he's tom harper, afaik
08:42:10 <sioraiocht> aristid: correct!
08:42:19 <crystal-cola> A: By the way, a natural number type can indeed be constructed in Haskell using Peano numbers.
08:42:19 <aristid> tom /= robert
08:42:20 <applicative> the first post in my imaginary parody mirror of existentialtype.wordpress ie. higherkind.wordpress is entitiled "No Enemies on the Left"
08:42:24 <sioraiocht> aristid: have we met?
08:42:25 <crystal-cola> B: I’m sorry, you are wrong. I know perfectly well that there are “strictness annotations” in Haskell.
08:42:32 <aristid> sioraiocht: no, but i have /whois'd you
08:42:33 <copumpkin> sioraiocht: what's the R?
08:42:36 <applicative> he seems to have forgotten that great slogan 
08:42:41 <sioraiocht> copumpkin: my first name is Raymond
08:42:43 <copumpkin> oh
08:42:45 <copumpkin> same thing
08:42:51 <copumpkin> I'm just gonna call you r harper
08:42:53 <copumpkin> and have people wonder
08:42:54 <sioraiocht> wah
08:42:56 <copumpkin> :P
08:42:58 <crystal-cola> B is correct... and someone responds with proof
08:42:59 * sioraiocht hates his first name.
08:43:02 <crystal-cola> why are you all making fun of B?
08:43:08 <dons> sioraiocht /= cmu prof yet :-)
08:43:10 <crystal-cola> you guys make no sense
08:43:14 <edwardk> but everybody loves raymond
08:43:30 <aristid> sioraiocht: because it reminds people of robert harper?
08:43:31 * applicative love raymond
08:43:32 <djahandarie> Everybody loves raymond and no one loves robert
08:43:36 <balphas> Robert_Harper: so which language is serious enough that it has 'a serious module system' and also 'the cleanliness of haskell', and also 'an implementation on par with ghc' ?
08:43:39 <sioraiocht> dons: if by yet, you mean 'never' ;) 
08:43:46 * applicative een loves robert, in a larger spiritual sense
08:43:58 <crystal-cola> balphas: they were trolling
08:44:12 <sioraiocht> aristid: because I've never gone by it,ever.  My family kindly gave me my father's first name only to never call me by it =p
08:44:16 <djahandarie> crystal-cola, I'd like to think it was 'light-hearted joking' rather than 'trolling'. :p
08:44:19 <applicative> is pretending to troll a form of trolling?
08:44:29 <copumpkin> sioraiocht: fine, I won't call you by it :P
08:44:32 <Twey> Meta-trolling
08:44:32 <aristid> sioraiocht: well, raymond, #haskell can fix that for you.
08:44:32 <sioraiocht> aristid: and then I get to have conversations like this, all the time, hehe
08:44:42 <sioraiocht> thanks, copumpkin :Þ
08:44:45 <balphas> the troll macro
08:44:45 <crystal-cola> I can't understand why people are going on about this
08:44:49 <crystal-cola> isn't it obvious?
08:45:00 <djahandarie> Everything is obvious! When you already know it.
08:45:09 <crystal-cola> I guess I already knew this then
08:45:17 <crystal-cola> well, I did
08:45:18 <edwardk> crystal-cola: it is more a matter of interpretation. a matter of where the line is drawn. in haskell we can talk more nicely about recursive domains, tying the knot directly rather than with reference cells, in ml, they need mutation to do these things, so side-effects abound, but they can talk about unpointed types, if only because they always have to appear on the right hand side of the => in hskell the natural type bob complains ab
08:45:20 <crystal-cola> I thoguht everyone else did too
08:45:32 <edwardk> once you make that transition the two sets of semantics converge
08:45:50 <crystal-cola> edwardk: what is confusing me is nobody has mentioned that you can just carve out a subset of haskell where types are inductive
08:45:59 <djahandarie> edwardk, it's possible to 'tie the knot' in ML as well though?
08:46:13 <edwardk> djahandarie: it requires mutation
08:46:23 <djahandarie> crystal-cola, as you would argue though, that subset doesn't exist :)
08:46:26 <applicative> crystal-cola we treat them that way, but he thinks that is irrelevant to 'the semantics'
08:46:33 <crystal-cola> like if I want to prove my um.. "reverse" function really is reversing lists I can use induction
08:46:46 <applicative> crystal-cola: your intentions are irrelevant to 'the semantics' of your module
08:46:48 <edwardk> djahandarie: the imperative form of tying the knot is how you make a circular linked list in C. you initialize the next pointer to null, then point it back to yourself when you know where you are
08:46:51 <crystal-cola> of course this says nothing about what happens when I put an infinite list into "reverse"
08:47:19 <crystal-cola> The subset does exist, you can write this down using math
08:47:34 <crystal-cola> maybe he has some objection to the pragmatics of doing what I suggested
08:47:45 <applicative> what's a type in this subset?
08:47:47 <crystal-cola> i.e. it's bullshit and your proofs mean nothing (which is quite accurate)
08:47:53 <edwardk> crystal-cola: sure, and but you can reason about the coinductive subset as well
08:47:58 <djahandarie> edwardk, http://www.reddit.com/r/programming/comments/gwqa2/the_real_point_of_laziness/c1qz6lh is this using mutation? I'm not familiar with OCaml
08:48:01 <edwardk> er s/and/
08:48:06 <crystal-cola> yes of course
08:48:37 <crystal-cola> if Bob wants to do global reasoning about the entire language.. that's going to take some serious revamping
08:48:57 <crystal-cola> You would need something like definition of SML but for haskell
08:49:16 <crystal-cola> and I don't think that or any compilers confirming to that exist
08:49:32 <edwardk> djahandarie: you might find the elaboration of how this has to work in the r6rs reference manual for scheme enlightening
08:49:51 <djahandarie> crystal-cola, I think that Agda solves this problem fine. It just has other problems (like not being formally verified itself :p)
08:49:56 <crystal-cola> djahandarie: that's not using  mutation
08:50:02 <crystal-cola> djahandarie: ocaml doesn't have inductive types
08:50:25 <crystal-cola> you can even do   type nat = Succ of nat  then   let rec inf = Succ inf
08:50:46 * djahandarie notes to learn OCaml at some point
08:50:49 <crystal-cola> apparently you cannot do this in SML? I wonder if anyone could confirm
08:50:56 <edwardk> crystal-cola: correct
08:51:05 <rsuniev_> Can someone post a link to "inductive types"
08:51:06 <quicksilver> SML doesn't have value recursion at all, doe sit?
08:51:30 <edwardk> you'd need to go through a reference cell to get back to where you started
08:51:45 <edwardk> ones = 1 : ones is a very haskelly thing ;)
08:51:54 <crystal-cola> rsuniev_: What I mean by inductive type is that every object is well founded
08:52:01 <Twey> ITYM ones = fix (1 :)
08:52:15 <crystal-cola> rsuniev_: so for data N = Z | S N the value x = S (S (S (S x))) which goes on for infinity is not well founded
08:52:37 <edwardk> nah i meant the version that abused haskell's penchant for let rec by default
08:53:13 <Twey> Heh
08:53:28 <crystal-cola> I think the people on existential type are just arguing by their gut reaction of "NOOO Haskell is great don't say that"
08:53:34 <crystal-cola> without actually listening to what he said
08:54:12 <edwardk> like i said, what he said was correct in a very blinkered sort of way
08:54:24 <Twey> edwardk: But fix f = let x = f x in x
08:54:39 <crystal-cola> It would be nice to reduce the gap between the theory of programming and the actual thing
08:54:45 <crystal-cola> right now they barely have any relationship
08:54:54 <Boxo> So why does ML force you to write "rec" to identify recursive functions?
08:55:08 <crystal-cola> Boxo: why does a spider have 8 legs?
08:55:21 <edwardk> Twey: sure but the types don't force that you could use fix f = f (fix f) and have radically different space usage. ;)
08:55:33 <applicative> ocaml does okay with type nat = Succ of nat ;;  
08:55:33 <applicative> let rec inf = Succ inf ;;
08:55:34 <Boxo> crystal-cola: it's a design decision, there must be some reason for it
08:55:40 <Twey> Haha, truly
08:55:40 <Boxo> does look idiotic to me
08:56:26 <nyingen> I got a strange message about the availability of 'base' when I tried to install fclabels and/or template haskell, any ideas?
08:56:29 <nyingen> http://hpaste.org/46079/cabal_error
08:56:33 <crystal-cola> "because of the segregation of effects into the IO monad."
08:56:36 <crystal-cola> huh
08:56:40 <applicative> it has the sense to stop calculating.  It says : val inf : nat = Succ ( Succ ( Succ ... )))  
08:56:44 <crystal-cola> now that remark makes me wonder how well he actually knows Haskell
08:59:04 <crystal-cola> This is sad. http://existentialtype.wordpress.com/2011/03/15/dont-mention-equality/
08:59:24 <quicksilver> Boxo: I suspect it's something to do with a desire to type definitions one at a time into a repl
08:59:32 <quicksilver> something you can't do with recursive ones
08:59:36 <applicative> crystal-cola:  he clearly has a ton of learning about haskell, of course, he's been following it since the beginning, but not much experience programming in it. 
09:00:04 <crystal-cola> "So, if you want to bring up equality, you are buying into a huge mess.  But there is an alternative: just say no to equality.  More accurately, don’t say anything at all, don’t even bring it up"
09:00:23 <applicative> his basic mistake, which would be replicated by more sympathetic professors, is to think that what users actually intend has no bearing on what they do
09:00:24 <crystal-cola> this is really depressing.. people don't understand equality so leave them that awy?
09:00:49 <applicative> crystal-cola: I liked that post, especially after I read the one against booleans
09:01:07 <djahandarie> crystal-cola, later in the post: "Now, to head off pointless argument, let me say that eventually you’ll want to introduce equality, because you do sometimes need it, but only at a much, much later stage, when students have gotten safely past the real obstacles to learning to write good, clean code.  It’s no use rolling logs at them as well, let them spend their time on serious stuff instead."
09:02:17 <applicative> crystal-cola: in each case he is just pointing out abuses, with his unique lyricism
09:02:36 <crystal-cola> oh he is talking about a function "equal" : A -> A -> Bool
09:02:41 * hackagebot web-routes-quasi 0.7.0.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.7.0.1 (MichaelSnoyman)
09:02:41 <crystal-cola> he is not talking about _equality_
09:02:59 <applicative> crystal-cola: yes, and a crucial problem is the result type
09:03:43 * hackagebot yesod-core 0.8.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.0.1 (MichaelSnoyman)
09:04:45 <yrlnry> I knew you were talking about Bob Harper just from the topic.
09:05:05 <yrlnry> I like that the blog engine thinks that "Don't mention gays!" is a possibly-related post.
09:05:38 <applicative> yrlnry hah, because it recognize irrational hatred in the text?
09:06:38 <applicative> oh my god it does link a page with that title
09:07:09 <applicative> ah but an innocent one
09:07:34 <Jafet> Maybe the engine is linking mostly harmless posts
09:07:49 <applicative> Harper is mostly harmless
09:08:09 <nyingen> mostly harmless for what?
09:08:25 <nyingen> also, are the dependencies of fclabels misconfigured or something?
09:08:27 <applicative> there is something really twisted about him, no denying it.  it's not just that he's a gruff talker etc
09:08:48 <yrlnry> Harper is a lot smarter and more experienced than most of the people on this channel, and is worth taking seriously.
09:09:12 <seku> Poor gays being "hated" for wanting to marry same sex and wanting to adopt children. It has more to do with children having a right for a woman as a role model for mother and man for father, and that family being the carrying force of any society. It's just this time's thing where you can only have one correct opinion.
09:09:15 <applicative> yrlnry: no one denies that, do they?
09:09:17 <navaati> @hoogle (a -> b -> m r) -> m a -> m b -> m r
09:09:18 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
09:09:18 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
09:09:18 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
09:09:32 <navaati> grmbl
09:09:38 <applicative> yrlnry: he wouldn't be worth discussing otherwise. in fact he is worth discussing
09:09:53 <hpc> @ops
09:09:53 <lambdabot> Maybe you meant: docs oeis pl
09:09:55 <crystal-cola> seku: it's funny how like almost all kids grow up with only one parent, or between two houses these days
09:09:58 <hpc> @where ops
09:09:59 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:10:04 <crystal-cola> hpc: shut up
09:10:15 <hpc> crystal-cola: seku looks like a troll
09:10:22 <crystal-cola> hpc: so /ignore him and stop being a baby
09:10:28 <osfameron> !ops > seku
09:10:30 <crystal-cola> go ask #haskell-ops if you can't handle it
09:10:35 --- mode: ChanServ set +o shapr
09:10:36 <hpc> ...
09:10:38 --- mode: ChanServ set +o dcoutts
09:10:42 --- kick: seku was kicked by shapr (Kicked by shapr)
09:10:49 <crystal-cola> There's no need to cause a huge fucking fuss in the channel about nothing
09:10:49 <shapr> dcoutts: Would you like to ban?
09:10:50 <osfameron> ta
09:10:53 <crystal-cola> and get people kicked and upset
09:10:55 <shapr> crystal-cola: I strongly disagree.
09:11:03 <crystal-cola> yeah that's apparent
09:11:07 <DrSyzygy> I'm with shapr on this one.
09:11:20 <Itkovian> shapr: nice shot
09:11:24 <crystal-cola> well you're not gonna change anyones mind by silencing them
09:11:25 <hpc> part of it is having the reason for the kick logged in the same channel the kick occurs in
09:11:27 <shapr> crystal-cola: The rules for #haskell are "Be nice, or else"
09:11:31 <crystal-cola> that's a good way to reinforece peoples opinions
09:11:31 <djahandarie> crystal-cola, (maybe you should be the one moving to #haskell-ops now? :))
09:11:51 <dcoutts> shapr: I don't know if he's a persistent offender or not
09:12:04 <shapr> crystal-cola: This channel is for discussion of the Haskell programming language.
09:12:07 --- mode: ChanServ set -o dcoutts
09:12:11 <crystal-cola> leave me alone
09:12:13 <paolino> hello , I have  math question ,if it is not too off topic, related to http://code.google.com/codejam/contest/dashboard?c=842485#s=p0, I cannot demonstrate why 0.75 is never caught by the algorythm  
09:12:30 <crystal-cola> I don't need you getting all authoratarion on me
09:12:42 <shapr> crystal-cola: The suggestion is, if you'd like to further discuss this, feel free to talk about it on #haskell-ops
09:12:46 <crystal-cola> just kick the guy and go back to whatever you were doing, 
09:12:49 <crystal-cola> I don't want to discuss this
09:12:57 <applicative> i think it was a mistake, the topic had indirectly come up in connection with Harper, then he or she made a wrong move?
09:12:59 <crystal-cola> stop making an issue out if it
09:13:11 <shapr> crystal-cola: So drop it.
09:13:16 <DrSyzygy> paolino: You may want to look into the Cantor set, and its connections to decimal expansions in different bass.
09:13:18 <crystal-cola> shapr: see above
09:13:20 <DrSyzygy> *bases
09:13:26 <crystal-cola> ugh
09:13:30 <mauke> crystal-cola: no, *I* don't want to talk about this!
09:13:34 <crystal-cola> problem solved
09:13:37 <edwardk> shapr: relax
09:13:42 <shapr> I'm relaxed :-)
09:13:44 <crystal-cola> /ignore works
09:13:53 <copumpkin> SOOO
09:13:56 <rostayob> I'd like to code something similar to this in haskell: http://www.earslap.com/projectslab/otomata (it's basically music generation with cellular automata). I'll probably use SDL for the graphics, any suggestion for a good sound generation library for haskell?
09:13:57 <shapr> crystal-cola: I disagree, but anyway.
09:13:57 <copumpkin> lax monoidal functors!
09:13:59 <mauke> edwardk: ... that's a great way to get on people's nerves
09:14:01 <djahandarie> ABOUT THEM PROGRAMMING LANGUAGES
09:14:01 <edwardk> back to 'bob harper is a big fat stupid heat'! ;)
09:14:03 <edwardk> er head
09:14:15 <copumpkin> coends!
09:14:19 <copumpkin> yoneda!
09:14:22 <shapr> So like, in six hours, #haskell will be TEN YEARS OLD!
09:14:36 <Itkovian> shapr: thx, now I feel old
09:14:37 <nyingen> hm, fclabels didn't build under ghc 6.10.3 but does build under 6.12.1
09:14:37 <applicative> shapr, its all your fault i suppose
09:14:37 <dcoutts> @yarr!
09:14:37 <lambdabot> I'll keel haul ya fer that!
09:14:42 <djahandarie> 10 years of leading the young astray...
09:14:50 <paolino> thanks DrSyzygy
09:15:01 <Itkovian> That means ... the channel was founted when I got married! Hurray!
09:15:12 <crystal-cola> absolutely ridiculous anti-gay attitude
09:15:13 <Itkovian> s/t/d/
09:15:14 <edwardk> shapr: so when do you release the complete unabridged shapr channel logs?
09:15:18 <bos> i wish we had better mysql bindings.
09:15:18 <crystal-cola> childish
09:15:25 <applicative> inducting them into the unspeakable rites of a mysterious programming language cult
09:15:32 <shapr> edwardk: terrifying thought
09:15:40 <Twey> Haha
09:15:47 <shapr> crystal-cola: Please take that discussion to #haskell-blah or some other channel.
09:15:49 <Twey> Do you have logs going back ten years?  How big are they?
09:16:05 <shapr> Twey: Nah, I don't keep logs.
09:16:13 <Twey> Aha.
09:16:22 <edwardk> Twey: i was mostly just commenting since shapr was here before any of us
09:16:26 <shapr> Too bad too, lots of fun stuff happened :-)
09:16:29 <dcoutts> shapr: I was just looking at how far back my logs go, only to Summer 2008, I'm sure I was here much earlier than that
09:16:39 <Twey> Yeah.  I always keep logs, just in case.
09:16:45 <shapr> dcoutts: tunes.org logs are still available, right?
09:16:46 <hpc> rostayob: there's quite a few midi packages out there
09:16:47 * shapr checks
09:16:53 <edwardk> i switch clients and machines too often to have relevant logs
09:16:54 <dcoutts> shapr: yes, afaik
09:17:05 <Twey> edwardk: That's what bouncers are for
09:17:08 <hpc> rostayob: i have never used any sound libs, in any language, so ymmv
09:17:18 <edwardk> Twey: can't usually ssh from office computers, etc.
09:17:32 <Twey> edwardk: A bouncer will present itself as an IRC server
09:17:36 <dcoutts> bos: I thought hdbc-mysql was supposed to be ok
09:17:56 <dcoutts> bos: but I've never used it
09:18:01 <beastaugh> bos: thanks for updating hdbc-mysql for GHC7
09:18:07 <Twey> Then you can turn on logging on the bouncer and get centralised logs
09:18:09 <applicative> dcoutts, the zipfile on ..,tunes... is projecting 15 minutes to download
09:18:11 <bos> dcoutts: it's tolerable (in fact i'm now the maintainer), but the HDBC API is terrible
09:18:20 <rostayob> hpc: oh, haskore seems really cool...
09:18:20 <dcoutts> bos: ah heh :-)
09:18:20 <edwardk> can't always access irc servers directly from some networks. wind up having to hit webchats, mibbit, etc. has evolved over time
09:18:23 <beastaugh> I sent a patch the maintainer about a week ago but never heard anything back :)
09:18:44 <Twey> edwardk: If you can connect to an IRC server, you can connect to a bouncer :þ
09:18:46 <bos> dcoutts: uses String all over the place, does a ton of redundant work, and is generally bleh
09:18:49 <dcoutts> bos: that's always the problem with using new libs, you grumble and want to fix them :-)
09:18:58 <Twey> Unless it has a constrained list of allowed servers, I guess
09:19:04 <bos> dcoutts: yeah, just started work on mysql-lite this morning :-)
09:19:04 <dcoutts> bos: I had that feeling using haxml the other day
09:19:17 <edwardk> Twey: for most of last year i could connect to https://webchat.freenode.net/ but not to :6667
09:19:22 <bos> yeah, haxml seems very complicated, too
09:19:24 <djahandarie> mysql-lite is a parituclarly confusing name, due to sqlite also existing :p
09:19:37 <hpc> haha
09:19:46 <dcoutts> bos: as far as I can see there are no nice simple xml libs, all the apis are horrid
09:19:46 <hpc> fast-mysql perhaps
09:19:50 <djahandarie> (Will we get a sqlite-lite also?)
09:20:11 <hpc> dcoutts: is there any nice simple xml?
09:20:18 <bos> dcoutts: yeah
09:20:21 <hpc> :P
09:20:47 <dcoutts> hpc: xml itself is not complicated, it's just a simple data structure, people do complex things with it of course
09:20:54 <crystal-cola> It's also hypocritical that people can be as offtopic as they want, but when it's something /you/ don't want people to talk about suddenly "this channel is for discussion of haskell"
09:21:08 <applicative> what the package xml library: A simple XML library is misdescribed?
09:21:18 <crystal-cola> you probably don't care about that since you remain in charge whether your a hypocrit or not
09:21:22 <Twey> crystal-cola: Discussion of this sort of thing is what #haskell-ops is for.
09:21:28 <crystal-cola> ignored
09:21:35 <dcoutts> appamatto: yes. it's misdescribed :-)
09:21:39 <dcoutts> oops
09:21:41 <dcoutts> applicative: ^^
09:21:53 * dcoutts does app<tab> and gets caught out
09:22:04 <djahandarie> crystal-cola, I understand you're trying to make a point by talking about this in here, but it isn't exactly productive towards improving the situation, if that's a goal
09:22:24 <applicative> dcoutts: i did find it simpler than the others, maybe thats all that was meant...
09:22:41 <dcoutts> crystal-cola: also you've got to realise we're human :-) ops do not monitor the conversations and keep a consistent line.
09:23:00 <osfameron> crystal-cola: all channels work on consensus - if consensus decides that something is off-topic, then it is off-topic.  This isn't hypocrisy necessarily (though it can be). Rather it's mostly just how social groups work, because they haven't found a better way to do it.
09:23:07 <crystal-cola> dcoutts: yeah I undestand that, I'm impressed that you've not banned me for being critical
09:23:09 * applicative usually doesnt use dc<tab> and gets caught out as not using tab completion
09:23:19 * djahandarie goes to class
09:23:20 <dcoutts> crystal-cola: people call us occasionally and we have to make a decision on the spot, some people take a harder line than others
09:23:55 <tensai_cirno> how to define new data type in prelude?
09:24:08 <mauke> tensai_cirno: ... why?
09:24:29 <tensai_cirno> Prelude> data → <interactive>:1:1: parse error on input `data'
09:24:29 <applicative> crystal-cola I think I am in agreement with you, but I think we shouldn't get worked up about it.  In general our ops show considerable wisdom
09:24:39 <crystal-cola> no they don't
09:24:40 <hpc> tensai_cirno: that's not Prelude, it's ghci
09:24:45 <tensai_cirno> oops :<
09:24:47 <mauke> tensai_cirno: you can't define types in ghci, but what does that have to do with modifying the Prelude?
09:24:50 <crystal-cola> what just happened what completely stupid
09:24:59 <shapr> crystal-cola: discuss this elsewhere please
09:25:12 <hpc> tensai_cirno: to make a new data type in ghci, you have to define it in a file and load it
09:25:13 <shapr> #haskell-ops is very much for meta-#haskell topics.
09:25:22 <beastaugh> tensai_cirno: Prelude> just means that the Prelude is in the current module scope in ghci
09:25:24 <hpc> tensai_cirno: ghci is basically a big-ass do block
09:25:24 <dcoutts> crystal-cola: general policy would be to warn people (except for obvious spammers), and if they're persistent offenders to ban
09:25:30 <tensai_cirno> mauke: umm, i'm playing with gentle introduction to haskell :)
09:25:32 <applicative> crystal-cola: it was precipitate, I agree, but it's also a drag to carry on about it.  
09:25:46 <beastaugh> tensai_cirno: if you change the module scope it displays it to the left of the prompt
09:25:46 <tensai_cirno> can i define new data type without messing with files?
09:25:53 <mauke> tensai_cirno: no
09:26:21 <tensai_cirno> that sucks
09:26:25 <tensai_cirno> thanks anyway
09:26:37 <applicative> tensai_cirno: why does it suck?
09:26:51 <shapr> tensai_cirno: what sucks exactly?
09:26:52 <Jafet> You can't... create files?
09:27:01 <dcoutts> tensai_cirno: you just define things in a new module and import it. There's no need to change the standard Prelude module.
09:28:04 <tensai_cirno> applicative: because it takes my concentrations, breaks REPL conception, when you do everything in shell, and than writing down completed definitions
09:28:10 <applicative> tensai_cirno: you can also set an editor so that :e will let you get to your file immediately.  I use nano for this.
09:28:19 <shapr> crystal-cola: So what have you been writing in Haskell?
09:28:33 <tensai_cirno> thanks
09:28:37 <shapr> I'd like to build a blog with yesod, just haven't gotten to it yet.
09:28:37 <tensai_cirno> !
09:28:38 <navaati> does anybody understand how the packages rmonad/suitable works ? these associated datatypes things are tricky…
09:28:47 <mauke> where do you get the "completed definitions" from afterwards?
09:29:06 <applicative> you can also do things like :! echo data Foo = Foo >> my.hs
09:29:10 <applicative> or whatever
09:29:29 <Jafet> @slap applicative
09:29:29 <lambdabot> I won't; I want to go get some cookies instead.
09:29:40 <applicative> @slap Jafet
09:29:40 * lambdabot beats up Jafet
09:29:48 <DrSyzygy> @cookie
09:29:48 <lambdabot> Unknown command, try @list
09:29:53 <shapr> tensai_cirno: I'd suggest haskell-mode in emacs, that lets you hit C-c C-l to load the buffer you're editing into ghci
09:29:55 <DrSyzygy> lambdabot: Have a cookie.
09:29:59 * applicative seems to win there, perhaps wrongly
09:30:03 <Jafet> writeFile "my.hs" "data Foo = Foo"
09:30:06 <shapr> tensai_cirno: that keeps flow for me, at least
09:30:31 <applicative> shapr, if you just set your editor to nano in ghci you get the same effect without the emacs menace
09:30:42 <shapr> applicative: Aw, but I like emacs!
09:30:49 * hackagebot BNFC-meta 0.2.0.2 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.2.0.2 (JonasDuregard)
09:31:12 <applicative> nano even has haskell syntax highlighting you know.  it's very advanced
09:31:13 <tensai_cirno> mauke: i mean i would like to minimize my distractions from coding process
09:31:38 <Jafet> emacs is. Your argument is invalid.
09:31:53 <mauke> tensai_cirno: then I'd recommend an editor
09:31:54 <Jafet> tensai_cirno: I suggest a closed door and some music.
09:31:57 <mauke> also, no REPL
09:32:18 <tensai_cirno> Jafet: yeah, my favourite ide
09:32:27 <tensai_cirno> just started reading today docs
09:32:34 <shapr> tensai_cirno: what's your favorite IDE?
09:32:35 <tensai_cirno> haven't tryed haskell-mode yet
09:32:38 <applicative> tensai_cirno: i just did "*Attempt> :! echo data Foo = Foo >> attempt.hs"
09:32:45 <tensai_cirno> shapr: emacs
09:32:47 <Jafet> A closed door, apparently
09:32:52 <applicative> then i did :r then :t Foo  it was fine
09:33:02 <shapr> tensai_cirno: oh good! You can do LOTS of awesome stuff with haskell-mode!
09:33:12 <navaati> :t >=>
09:33:13 <lambdabot> parse error on input `>=>'
09:33:19 <navaati> :t (>=>)
09:33:20 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:33:35 <tensai_cirno> shapr: i can do lots of awesome stuff with emacs. Even edit text.
09:33:37 <tensai_cirno> ;)
09:33:37 <applicative> you can do lots of awesome stuff with TextPad if you have the ghc installed
09:35:11 <applicative> tensai_cirno: what operating system are you using at the moment?
09:35:34 <applicative> if you just include :set editor nano
09:35:46 <tensai_cirno> applicative: gnu/linux and plan9 sometimes
09:35:54 <applicative> the whole thing is very simple. you don't even need to wait a half hour for emacs to open
09:36:15 <applicative> and all the errors in your .emacs to be noticed
09:36:47 <tensai_cirno> yeah, thanks alot
09:36:51 * tensai_cirno brb in 30 mins
09:36:52 <crystal-cola> can plan9 run haskell?
09:36:53 <applicative> tensai_cirno: I mean, add :set editor nano to the file .ghci
09:36:59 <crystal-cola> wondering f anyone got that working?
09:37:21 <Jafet> @faq can Haskell work from outer space?
09:37:21 <lambdabot> The answer is: Yes! Haskell can do that.
09:38:10 <applicative> @faq can Haskell be written without emacs?
09:38:10 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:26 <paolino> DrSyzygy: do you think the problem was also to rewrite all numbers in base to see if they are in the cantor set ?
09:41:35 <paolino> *base 3
09:45:04 <shapr> paolino: That's an interesting solution...
09:48:05 <paolino> shapr, I cannot guess what the google jam staff wanted coders to do about http://code.google.com/codejam/contest/dashboard?c=842485. Pointing out there could be uncaught numbers is not making it clear
09:49:55 <litb> hello all folks
09:50:08 <litb> can someone please explain, what is "alpha beta eta equivalence?
09:50:21 <litb> is it some functional programming technique?
09:50:38 <zygoloid> litb: haha :) sorry about that
09:51:30 <zygoloid> alpha-conversion is renaming parameters. beta reduction is turning (\x. f x) y into f y. eta reduction is x -> \y. x y, and eta expansion is the inverse
09:51:32 <crystal-cola> litb: is it a real question or are you joking? :)
09:51:47 <crystal-cola> eta expansion isn't really the inverse of beta
09:51:48 <zygoloid> alpha-beta-eta equivalence is equivalence up to application of those transformations
09:51:55 <crystal-cola> it's replacing a function f with (\x -> f x)
09:51:58 <zygoloid> crystal-cola: it's the inverse of eta reduction
09:52:09 <crystal-cola> oh i misread what you wrote
09:52:18 <crystal-cola> (and analogues of that for various other data types)
09:52:22 <litb> crystal-cola: i'm just wondering. i'm not a functional programming guy
09:52:41 <zygoloid> litb: it's a small world :)
09:52:57 <zygoloid> (i'm assuming you're here re my post on comp.std.c++)
09:52:58 <litb> ohh that's good
09:53:02 <crystal-cola> I think eta expansion is going from f to \x -> f x
09:53:05 <litb> yeah :)
09:54:00 <crystal-cola> is it not
09:55:26 <litb> don't understand  x -> \y. x y
09:55:39 <crystal-cola> if f is a function then f = \x -> f x
09:55:49 <litb> doesn't this mean that given an   x it yields a function   \y. x y   ?
09:55:59 <crystal-cola> x has to be a function
09:56:08 <crystal-cola> e.g. x : a -> b you could eta expand but not 3 : Integer
09:56:11 <hpc> litb: you are mixing notation, i think
09:56:21 <litb> oh
09:56:27 <hpc> litb: \x -> \y -> x y is what i think you mean
09:56:28 <crystal-cola> This means to eta-expand you need types
09:56:37 <zygoloid> crystal-cola: that's true in the lambda calculus, but not in haskell.
09:56:40 <hpc> litb: which, with parens, is
09:56:44 <crystal-cola> zygoloid: which?
09:56:48 <hpc> \x -> (\y -> (x y))
09:56:52 <zygoloid> crystal-cola: f = \x -> f x
09:57:06 <zygoloid> crystal-cola: in particular, if f is bottom, then you can distinguish the two with seq
09:57:06 <hpc> litb: so your thinking is correct
09:57:24 <hpc> litb: i think you got haskell and math notation confused
09:57:35 <litb> i mean it's said that "eta reduction is x -> \y. x y".     
09:57:38 <hpc> litb: a haskell lambda is \x -> stuff, and a math lambda is λx. stuff
09:57:49 <ezyang> Is it just me, or do functional programs make it a lot harder for you to modify a chunk of code unless you understand all of it? 
09:57:53 <zygoloid> litb: sorry, i was using lambda calculus notation. eta reduction transforms x to \y -> x y
09:57:54 <hpc> litb: oh
09:57:57 <ezyang> E.g. it discourages debugging by permutation. 
09:58:14 <zygoloid> (ok, a broken lambda calculus notation using \ for lambda...)
09:58:18 <hpc> litb: so what it is saying is, say you have a lambda "\y -> x y"
09:58:19 <djahandarie> ezyang, if a 'chunk of your code' is seperated as a function, I think it makes it easier.
09:58:25 <Jafet> ezyang: but you can always write an ad-hoc combinator framework to do that for you
09:58:28 <litb> oh it says if  x is a fuinction taking   N arguments,   the eta reduction creates a function taking 1 argument, and passes it to x, yielding a function taking N-1 arguments?
09:58:33 <hpc> litb: you can remove both ys, leaving just "x"
09:58:40 <hpc> litb: this is part of what @pl does
09:58:46 <hpc> and that's eta reduction
09:58:52 <crystal-cola> I think that is eta expansion
09:58:55 <hpc> η reduction, rather
09:58:56 <crystal-cola> going from f to \x -> f x
09:59:08 <aristid> crystal-cola: @pl goes from \x -> f x to f.
09:59:08 <ezyang> Well, my next task is to understand this module which is creating an interference graph. I've been skimming the code for a month now, but my eyes keep glazing over. 
09:59:12 <crystal-cola> I use the term "expansion" because it's getting bigger and Neil Ghani uses it to
09:59:16 <litb> ahh now i see
09:59:19 <djahandarie> ezyang, maybe it's poorly written. ;)
09:59:21 <aristid> @pl \x -> f x
09:59:21 <lambdabot> f
09:59:21 <hpc> crystal-cola: oh, that it is
09:59:27 <ezyang> ...maaaaybe. 
09:59:30 <ezyang> Or I could just be stupid :-) 
09:59:33 <hpc> yeah, and eta expansion is @unpl
09:59:34 <crystal-cola> I mean you can things whatever you want
09:59:35 <hpc> @unpl f
09:59:35 <lambdabot> f
09:59:37 <crystal-cola> it doesn't matter
09:59:45 <djahandarie> ezyang, pick your poison
09:59:49 <crystal-cola> it's all alpha equivalent
09:59:55 <hpc> well, would be if @unpl did that sort of stuff
10:00:22 <litb> so eta expansion is a simplication step, removing redundant parameters and arguments
10:00:25 <ezyang> If I'm stupid, the solution is to un-stupid myself, which is a great result. 
10:00:35 <litb> why is it not called eta reduction
10:00:42 <ezyang> If the code is stupid, the solution is to un-stupid the code, which is not so good. :-) 
10:01:04 <crystal-cola> litb: well I call it eta expansion  when you go from f to \x -> f x
10:01:07 <djahandarie> litb, becuase you have it backwards.    f => \x -> f x   is expansion,    \x -> f x => f    is reduction.
10:01:19 <crystal-cola> litb: and reduction when you "reduce" from \x -> f x to f
10:01:32 <crystal-cola> as said it's just words...
10:01:39 <litb> ohh thanks folks
10:01:41 <paolino> ezyang: it's left to demonstrate that non functional solution was easier to grasp
10:01:42 <applicative> ezyang, the solution is first class modules, obviously
10:01:47 <litb> and beta reduction is basically "calling functions"
10:01:57 <hpc> litb: yes
10:02:02 <crystal-cola> no
10:02:06 <djahandarie> ('expansion' also goes by the word 'abstraction' sometimes)
10:02:07 <litb> hm
10:02:09 <crystal-cola> beta reduction is capture avoiding substitution
10:02:41 <crystal-cola> This is a very subtle thing you should study it carefully
10:03:01 <hpc> beta reduction is (\x -> f x) foo => f foo
10:03:07 <crystal-cola> that is one example of it
10:03:21 <litb> i have this book "Introduction to functional programming using haskell"
10:03:21 * applicative remembers first reading about substitution in Church's "Introduction to Mathematical Logic"  it took about 40 pages, at the beginnin
10:03:28 <litb> but it's all very difficult :
10:03:32 <litb> (
10:03:52 <crystal-cola> btw
10:03:52 <crystal-cola> litb: 
10:03:58 <crystal-cola> none of this is relevant to functional programming
10:03:59 <litb> crystal-cola: ah so it's a syntactical transformation
10:04:05 <crystal-cola> this is just the theoritcal stuff
10:04:06 <litb> not really calling/substituting?
10:04:16 <crystal-cola> all of this is syntactic
10:04:18 <hpc> crystal-cola: it's as relevant as all the other theoretical stuff
10:04:30 <litb> i want to get into theory
10:04:49 <djahandarie> hpc, how could that possibly be true? Certainly some theoretical stuff is more useful than other theoretical stuff. :)
10:04:53 <litb> im almost certain that in order to be successful with FP one has to get the theory
10:04:56 <crystal-cola> well you should find a formal description of capture avoiding substition
10:05:09 <hpc> litb: you would be correct
10:05:10 <crystal-cola> to understand beta reduction
10:05:21 <djahandarie> litb, I don't agree with that. Theory gives you another angle to solve your problems. It isn't the only angle. (But maybe it's the right angle.)
10:05:32 <hpc> litb: where "success" == "understanding", not "writing programs"
10:05:43 <applicative> litb, the topic of substitution is the most tedious theoretical topic imaginable
10:05:56 * hackagebot http-types 0.6.4 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.4 (AristidBreitkreuz)
10:05:57 <crystal-cola> oh itos only tedious when you've already done it 100x :D
10:06:06 <crystal-cola> it's very interesting the first time around, no?
10:06:09 <ezyang> Nah, it's tedious the first time you do it too :-) 
10:06:10 <Jafet> djahandarie: people who lack theory have an acute problem, however, especially if they're obtuse about it
10:06:17 <hpc> i liked learning substitutions
10:06:29 <crystal-cola> it's extremely important anyway
10:06:37 <hpc> after using haskell for a while, it seemed so obvious
10:06:51 <djahandarie> Jafet, you mean "especially if they're cute about it"?
10:07:04 <litb> is "capture avoiding substitution" a single term for something or is it a capture that avoids substitition?
10:07:10 <applicative> I guess if you first learn it as a 'computer science' topic it might make more sense.  In a textbook of logic it is tiresome since it is an accident of notation
10:07:27 <litb> applicative: ohh
10:07:30 <crystal-cola> litb: it is a single term
10:07:32 <djahandarie> litb, its a signle term for something
10:07:39 <Jafet> Perhaps. I just said that on reflex.
10:07:56 <hpc> Jafet: i thought it was a clever pun
10:08:14 <djahandarie> I thought it was an unintentional pun
10:08:21 <applicative> if formulas must be 1D sequences, you have trouble, but if you drew certain sorts of graphs, there would be no topic
10:08:38 <litb> if im using haskell for a while and have learned to "think functional" will it become more easy to grok the theory?
10:08:53 <nyingen> litb: in my experience, yes.
10:09:00 <hpc> same here
10:09:17 <litb> ohh nice
10:09:22 <djahandarie> litb, yes, because it gives you somewhere to ground the theory which tends to be more abstract.
10:09:44 <hpc> what i did was pored through lyah until i got stuck on something, then googled random stuff until i found a bit of theory i understood
10:09:53 <hpc> then learned as much from that as i could and moved back to lyah
10:09:56 * hackagebot DimensionalHash 0.1.5.1 - An n-dimensional hash using Morton numbers.  http://hackage.haskell.org/package/DimensionalHash-0.1.5.1 (GhassenHamrouni)
10:09:58 <djahandarie> (Which theory is concrete it tends to be somewhat boring anyways, since it's just theory :))
10:10:02 <crystal-cola> applicative: is that true?
10:10:18 <crystal-cola> applicative: oh wait I see what you mean
10:10:42 <crystal-cola> like a sineless tagless G machine
10:11:13 <djahandarie> Sineless? That sounds even scarier than spineless
10:11:23 <byorgey> uses only cosines!
10:11:31 <litb> and this "alpha beta zeta equivalence" means doing all these transformations on two invocations of a function, and if any sequence of transformation yield the same result, then both invocations are considered "equivalent"?
10:11:32 <crystal-cola> loj
10:11:33 <crystal-cola> lol
10:12:05 <hpc> aha! i just groked church booleans :D
10:12:14 <crystal-cola> litb: yes you can form an equivalence relation from reduction rules
10:12:23 <byorgey> hpc: \o/
10:12:24 <litb> ohh nice
10:12:35 <crystal-cola> litb: considering two things equal if any possible sequence of reductions can get them into the same thing
10:12:44 <litb> the church is a lie. 
10:12:46 <aristid> hpc: they're just the catamorphism of Bool, after all!
10:12:48 <crystal-cola> not like
10:12:53 <crystal-cola> a = b if a reduces to b
10:13:00 <hpc> and curch pairs
10:13:00 <crystal-cola> but a = b if a reduces to c and b reduces to c
10:13:04 <litb> crystal-cola: ah i think
10:13:05 <hpc> man that's clever
10:13:18 <crystal-cola> sorry that wasa  bad explanation
10:13:32 <litb> i think that makes sense
10:13:54 <litb> sounds NP hard
10:14:09 <applicative> crystal-cola: a huge amount of what people think is logic and still more 'computer science' is accidents of 1D notation.
10:14:10 <crystal-cola> litb: lets say a -> a' if a can be reduced to a'. like (\x -> f x) (1 + 1) reduces to f (1 + 1) but it also reduces to (\x -> f x) 2 and also f 2
10:14:27 <crystal-cola> litb: so (\x -> f x) (1 + 1) -> f 2 and (\x -> f x) (1 + 1) -> f (1 + 1) etc..
10:14:38 <Jafet> It's Turing-hard!
10:14:38 <applicative> for example, if I say forall a b .  ... the letters are sequenced, which need not be what is intended
10:14:40 <crystal-cola> litb: and then a = b if there exists c, such that a -> c and b -> c
10:14:49 <crystal-cola> litb: (I just wanted to write out properly..)
10:15:05 <litb> lol Jafet 
10:15:27 <litb> Jafet: just wanted to say somthing technical. not sure whether it makes sense!
10:15:34 <crystal-cola> applicative: that's kind of funny to imagine that.. I am not totally sure if its true
10:15:58 <applicative> this is one reason why it is a false pseudo knowledge that the Haskell98 Foo a b = ... has 'implicit quantifiers'
10:16:20 <litb> not sure whether I'll ever understand that description of NP-hard problem L by wikipedia "In other words, L can be solved in polynomial time by an oracle machine with an oracle for H"
10:16:21 <applicative> this would only be true if one were imagining so called branching quantifiers
10:16:51 <applicative> this emerges already in 'formalizing' high school algebra.  
10:17:37 <litb> will this stuff be taught in bachelor of science CS course?
10:17:44 <applicative> the claim that when the teacher writes:  x + (y + z) = (x + y) + x, she really means for all x y x,  x + (y + z) = (x + y) + z
10:17:50 <applicative> is simply false
10:17:51 <crystal-cola> interesting stuff!!
10:18:04 <pmetzger> can anyone quickly tell me the distinction between haskell-indentation, haskell-indent, and haskell-simple-indent in the emacs haskell mode?
10:18:08 <pmetzger> the documentation seems... spotty
10:18:19 <crystal-cola> why is that false?
10:18:24 <Optimo> lunatics get together on the interwebz, #haskell is one such locale
10:18:31 <crystal-cola> haha
10:19:07 <hpc> pmetzger: the first one spells "indentation" correctly, the second has the shortest name, and the third is three hyphenated words
10:19:10 <hpc> :D
10:19:17 <pmetzger> thanks! that helps!
10:19:17 <applicative> it took 50 years before logical systems could be under the illusion that they were the same
10:19:18 <Optimo> u guys talkin about this? 'The Algebra of Data and the Calculus of Mutation' http://blog.lab49.com/archives/3011
10:19:39 <litb> crystal-cola: thanks, i think that was a nice elaboration
10:19:45 <crystal-cola> applicative: I don't understand the difference :(
10:20:21 <Optimo> someone missed a 'z'
10:20:29 <Optimo> wtf
10:20:37 <applicative> Frege does not even permit the same font to display the letters in x + (y + z) = (x + y) + x and for all a b c , (a + b )+ c = a + (b + c )
10:20:52 <crystal-cola> what is the difference -_-
10:20:53 <applicative> pardon missing z
10:21:23 <applicative> the forall a b c is short for for all a, for all b, for all c, 
10:21:33 <applicative> this means that the variables are ORDERED
10:21:42 <crystal-cola> aha
10:21:50 <Optimo> the order of operations
10:22:03 <crystal-cola> so b could depend on a but not vice versa
10:22:26 <applicative> in order to make proofs with ordered quantifiers, and no unordered 'latin letters' as Frege calls them, it took 50 years
10:22:52 <zygoloid> litb: for 'full' lambda calculus, it's not decidable whether there's a sequence of reductions which makes two twrms equal. for simply-typed lambda calculus, there is.
10:23:40 <pmetzger> so, asking again, differently: anyone here actually grok emacs' haskell mode?
10:23:49 <Optimo> fill all holes with your data type
10:23:54 <crystal-cola> applicative: and it took me about a year or more to understand why scheme doesn't specify the ordering of evaluation (f x y z) as first f, then x, then y..
10:24:14 <litb> "yi" is a recent innovation of the channel. emacs clone written in haskell. 
10:24:30 <litb> zygoloid: ah
10:24:44 <byorgey> litb: yi is neither recent nor an emacs clone.
10:24:49 <Kaidelong> is yi an emacs clone
10:24:54 <litb> oh hmm
10:25:00 <Optimo> sounds like vi
10:25:06 <byorgey> it does have an emacs emulation mode.
10:25:08 <Kaidelong> I thought it was fundamentally more minimal than most of the other TEs
10:25:11 <aristid> pmetzger: what's to grok?
10:25:27 <pmetzger> well, there are three indentation modes. I don't know what the difference between them is.
10:25:30 <aristid> pmetzger: you press tab and it indents a line. sometimes badly, then you try to figure out how to fix the indentation
10:25:49 <aristid> pmetzger: i use the one with indentation in the name, i think
10:25:50 <pmetzger> also, for some reason, when I load the mode, bindings like C-c c-= seem to be missing. I am not sure why.
10:26:03 <aristid> no idea what C-c C-= is :)
10:26:06 <pmetzger> these are the sorts of questions I want to ask someone.
10:26:22 <pmetzger> C-c C-= inserts an = and electrically aligns previous lines to suit it.
10:26:37 <pmetzger> well, automagically, not technically electrically in an emacs context.
10:26:48 <pmetzger> I could just read all the code but I would prefer not to. :)
10:27:05 <aristid> :)
10:30:57 <applicative> crystal-cola: it is natural to read this as a case of modus ponens of if-elimination:
10:31:00 <applicative> x + y = y + x then (x + y) + 1 = (y + x) + 1 but x + y = y + x ergo (x + y) + 1 = (y + x) + 1
10:31:30 <applicative> crystal-cola: but if you insist that it has implicit quantifiers, it is not modus ponens
10:31:42 <Palmik> Hi guys, have you ever encountered this bytestring-mmap building error? http://codepad.org/5CXcBCJd
10:31:56 <crystal-cola> So if they are not quantified, what are they?
10:32:09 <applicative> what were they in high school algebra
10:32:19 <applicative> you reasoned as I did above
10:32:29 <crystal-cola> I didn't pay much attention in high school :/
10:32:30 <tibbe_> Palmik: which version of GHC do you use?
10:32:42 <applicative> but if you quantify them you need several other rules, including ....surprise...
10:32:51 <applicative> capture avoiding substitution crap
10:33:19 <Palmik> tibbe_, 7.0.2
10:33:22 <crystal-cola> so the whole logic setup could be done without substitution?
10:33:34 <crystal-cola> rigorously?
10:33:47 <applicative> not in a oneD symbolism.  that's not the point i was just making now
10:33:48 <tibbe_> Palmik: the package includes ghc-options: Wall -O2 -fvia-C, but -via-C is getting deprecated
10:34:07 <tibbe_> Palmik: you could try to download the source (cabal unpack bytestring-mmap) and change the .cabal file
10:34:10 <tibbe_> to remove -via-C
10:34:24 <Palmik> ok, will try that... I am using cabal.dev anyway
10:34:30 <Palmik> *cabal-dev
10:34:37 <applicative> that point was that quantifiers force an order that is not needed on these things, and thus complicate inference
10:35:33 <hpc> applicative: how do quantifiers impose an order?
10:35:55 <tibbe> Palmik: so .size is elf directives in the assembly code, probably inserted by gcc (as ghc doesn't use them yet)
10:36:10 <crystal-cola> yes that's a good point
10:36:11 <applicative> for all x , for all y (R x y)  is not the same as for all y for all x (R x y)
10:36:22 <crystal-cola> I understand that - although I guess I don't know why it's a problem
10:36:28 <copumpkin> applicative: ?
10:36:36 <crystal-cola> I mean I have never bothered about it when I used logic
10:36:49 <hpc> applicative: how are they different?
10:36:55 <crystal-cola> I guess it's a philosophical thing
10:36:55 <applicative> copumkin, the quantifiers are reordered.  the sentences are equivalent, but this must be proved
10:37:05 <copumpkin> oh, fine
10:37:23 <copumpkin> I thought you were making the more interesting point about the ordering of existential and universal quantifiers
10:37:24 <applicative> crystal-cola: not at all, the whole doctrine of substitution and so on turns on these sorts of points
10:37:53 <applicative> copumpkin: that is a less interesting point, pertaining to rather later developments.  i am in the period before the 20s
10:37:59 <copumpkin> oh
10:38:03 <copumpkin> I missed the lead-in then :)
10:38:25 <crystal-cola> how does substition depend so much on this?
10:39:12 <hpc> http://en.wikipedia.org/wiki/Quantification#Nesting
10:39:12 <applicative> it is connected with the reasons why people are unaware that 'higher order logic' is the original form, 'first order logic' was much more difficult to isolate
10:40:01 <hpc> the ordering seems to matter when "exists" is involved
10:40:55 <hpc> but i think forall a, forall b is the same as forall b, forall a
10:40:59 <applicative> this is a different mattering of course
10:41:15 <applicative> it isn't the same, intensionally, it must be proven
10:41:47 <sudoman> i'm getting a "cannot find module 'Linker'" while trying to build ghci-haskeline with cabal. http://pastebin.ca/2051278 I'm using Debian squeeze on powerpc.
10:42:02 <pmetzger> what's the relationship between the namespace for data constructors and type constructors? Can a data constructor share the name of a type constructor for a different type?
10:42:09 <pmetzger> I'm guessing "no"...
10:42:20 <tibbe> copumpkin: what do you know about the MAYBE_GC macro?
10:42:24 <applicative> people introduced other forms of quantifier for which this wouldn't be so, e.g the so called branching quantifiers. which have cool effects on the alternating all some cases too
10:42:24 <Palmik> tibbe, it worked, thanks (there have been some problems when the tar.gz was not generated, but I found a way around it)
10:42:25 <hpc> pmetzger: the scope of type stuff is separate from the scope of value stuff
10:42:26 <tibbe> copumpkin: do all primops have to call it?
10:42:38 <sudoman> I was able to install an updated version of cabal-install with cabal however.
10:42:43 <hpc> pmetzger: so data Int = I Int#
10:42:47 <crystal-cola> applicative: know any good things to read about this?
10:42:50 <pmetzger> so is it permissible for me to have a data constructor called "String", say?
10:42:55 <hpc> pmetzger: data Foo = Int Int
10:42:58 <hpc> pmetzger: that's valid
10:43:05 <applicative> Frege, Begriffsschrifft, 1879
10:43:06 <applicative> ha
10:43:10 <Palmik> hmm, another package, the same problem... :/
10:43:15 <pmetzger> okay, cool. And I presume the namespaces of different types data constructors are disjoint?
10:43:34 <djahandarie> Someone come up with a good solution for me to provide more instances to the newtype package without adding more dependencies to the package
10:43:37 <hpc> pmetzger: no; there must be only one Int :: Int -> Foo
10:43:50 <hpc> pmetzger: just like you can't have multiple definitions of sum
10:44:15 <pmetzger> that makes allowing a data constructor with the same name as a type less useful. :)
10:44:21 <byorgey> pmetzger: no, there are only two namespaces: the namespace for types (including class names, type constructors, etc.) and the namespace for values (including data constructors, functions, class methods...)
10:44:23 <pmetzger> but I understand why.
10:44:48 <pmetzger> it would be bloody hard to figure out which "Foo" constructor you meant.
10:45:10 <pmetzger> So I guess my avoiding re-using names has not been stupid.
10:45:11 <hpc> pmetzger: typically, what you do is data Foo = FooInt | FooDouble | FooString
10:45:11 <pmetzger> cool.
10:45:32 <pmetzger> thats what I've been doing, but it occurred to me that I was doing it in a cargo cult manner without knowing if I needed to.
10:45:38 <pmetzger> so I thought I'd verify.
10:45:41 <applicative> on the same day when he introduced "for all x" Frege gave a proof of induction for well founded relations beginning "for all R, x R y -> ..." no sets or anything
10:45:46 <hpc> ah, in that case no problem
10:45:50 <tibbe> Palmik: great
10:45:54 <hpc> </3 the cargo cult
10:45:57 <tibbe> Palmik: might want to send Don a patch
10:46:02 <pmetzger> I'd love a two or three page Haskell Quick Reference, haven't noticed one...
10:46:18 <applicative> hm cabal install cheatsheet ?
10:47:02 <pmetzger> applicative: thanks!
10:47:16 <hpc> pmetzger: something like http://store.xkcd.com/xkcd/#LinuxCheatShirt
10:47:17 <applicative> Your cheatsheet is at: ~/.cabal/share/CheatSheet-2.8/CheatSheet.pdf Its literate source is at: ~/.cabal/share/CheatSheet-2.8/CheatSheet.lhs
10:47:20 <hpc> would be awesome
10:47:51 <Palmik> tibbe, the issue has already been addressed in ghc 7.0.3 http://hackage.haskell.org/trac/ghc/ticket/5050
10:47:54 <pmetzger> wow, that's useful. I wanted that for a while.
10:47:57 <Bustakheops> hi, how can I convert [1,1,0,1,0,1,1,0] to Word8? (this is just an exemple)
10:48:27 <pmetzger> I wish the command ran "open" on the mac instead of just telling me where to look (or spat out only one output so I could do "open `cheatsheet`" but whatever, this is great!
10:48:54 <tibbe> Palmik: excellent
10:48:55 <pmetzger> this is really, really awesome!
10:49:01 <applicative> pmetzger: that's what i was thinking, or else it spills into stdout
10:49:23 <tibbe> Palmik: This is now "fixed", by turning -fvia-c into a no-op. :D
10:49:36 <hpc> Bustakheops: use bitwise operations
10:49:36 <tibbe> Palmik: 7.0.2 has bugs so I suggest upgrading
10:49:41 <hpc> @hoogle Bits
10:49:41 <lambdabot> module Data.Bits
10:49:41 <lambdabot> Data.Bits class Num a => Bits a
10:49:41 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
10:49:58 <Palmik> tibbe, yep, I probably will upgrade :)
10:50:14 <Bustakheops> ok thank's hpc :)
10:50:37 <tibbe> Palmik: I think the next HP point release should be out soon
10:52:42 <pmetzger> I wish I'd had this cheat sheet a week ago, I'm actually learning things by reading it, which is I suppose not unexpected in retrospect.
10:53:20 <sudoman> I'm getting a "cannot find module 'Linker'" error while trying to build ghci-haskeline with cabal, though installing cabal-install with cabal worked... I'm using Debian Squeeze on a Powerpc computer. http://pastebin.ca/2051278
10:54:10 <Palmik> tibbe, I do not use HP actually, but thanks :)
10:54:17 <tibbe> sure
10:57:13 <darrint> In "Functional Programming with Bananas, Lenses, ... et. al." What does the notation A||B mean?
10:57:33 <Palmik> darrint, parallel execution?
10:57:48 <Palmik> I guess it depends on the context
10:58:48 <darrint> Palmik: A cons list over some type might be defined as A* ::= Nil | Cons (A || A*)
10:58:54 <crystal-cola> if only he had mentioned the context./.
10:59:44 <crystal-cola> darrint: it's called the product of two types, defined on page 6
10:59:57 <crystal-cola> D || D' = {(d,d')|d in D, d' in D'}
11:00:15 <crystal-cola> and on the value level (f||g) (x,x') = (f x, g x')
11:00:23 <crystal-cola> (since it's a bi-functor)
11:01:07 <darrint> crystal-cola: Thanks! They use it on page 2. Slackers.
11:01:13 <crystal-cola> hehe
11:01:13 <Palmik> :)
11:01:21 <crystal-cola> I never read the first few pages soo
11:01:28 <litb> can one prove the type system of c++ with these formalisms?
11:01:40 <crystal-cola> litb: prove it??
11:01:44 <Blkt> good evening everyone
11:01:51 <darrint> Some of us never went to grad school. :-)
11:01:53 <litb> embed it in these formal rules?
11:02:03 <crystal-cola> What rules?
11:02:14 <litb> so that if you have a piece of code, you just need to run it throug the formulas and get a result "valid" or "invalid"?
11:02:15 <crystal-cola> actually I don't know anythnig about C++
11:02:27 <litb> or even the rules of C?
11:03:44 <pmetzger> The rules of C++ are incomprehensible.
11:03:57 <pmetzger> The rules of C less so.
11:04:19 <hpc> in the case of C, it is only the gcc optimizations that are incomprehensible
11:04:26 <pmetzger> clearly there are automated type checkers of a sort for C and C++ -- they're part of the compiler.
11:04:51 <pmetzger> but determining if a computation violates safety is impossible at compile time in either language
11:05:21 <hpc> it can't be done at runtime either, i don't think
11:05:28 <hpc> because you can write assembly as byte arrays
11:06:21 <pmetzger> you certainly can't do it at run time -- it would violate the language semantics to detect that you were violating safety. :)
11:06:35 <hpc> :)
11:06:59 <pmetzger> C is basically a high level assembler. The problem is that we use it for things other than low level glue code.
11:07:05 <pmetzger> C++ has no excuse.
11:07:35 <hpc> C++ is trying to be every layer of abstraction
11:07:35 <pmetzger> Well, one excuse -- it is hard to eradicate a cancer once it metastasizes.
11:07:58 <hpc> pmetzger: that's the nice thing about CS: we can just invent another person
11:08:32 <pmetzger> I was told recently that there were ideas people had for C++ that the standards committee had rejected. I was surprised by this, because if you look at the docs, it seems naively like every idea anyone had ever had was incorporated no matter how lame.
11:09:00 <thoughtpolice> litb: indeed, when you ask the compiler to compile C++ code, it is already doing something of this nature - typechecking your code to see if it is 'invalid' or 'valid'. but the type system in C++ is not formally defined in the way hindley-milner type systems typically are, it is more ad-hoc. furthermore the type systems are much weaker, and easy to circumvent, so the guarantees are not as strong
11:09:33 <litb> oh i see
11:09:49 <pmetzger> there are formal definitions of the C type system now, or I imagine one must exist, because things like CompCert and seL4 exist.
11:10:18 <thoughtpolice> C++'s type system is incredibly verbose for the most part, and people still use it anyway to encode various things (sometime with a herculian effort) but the verbosity makes it a large turn off. C++ can enforce more type-level safety than C can, at least
11:10:22 <thoughtpolice> it's just not pretty
11:10:29 <pmetzger> I doubt anyone could construct something similar for C++ without man-decades of work.
11:11:11 <Jafet> Well, there are "executable specifications"...
11:11:32 <pmetzger> C++ can enforce exactly the same type safety that C can in general. Almost all C programs are valid C++ programs after all (and the distinctions where they diverge on semantics are insanely subtle, like sizeof('c') and such)
11:11:41 <litb> didn't folks formally prove a complete microkernel core written in C
11:11:46 <pmetzger> yes, it is seL4
11:11:57 <thoughtpolice> litb: you can basically think of it as, the type system in haskell is much more rigorously defined. C++'s type system does not have a rigorous definition in the same way, so there are no true formalisms you can work with
11:12:05 <pmetzger> and for that, they had to produce a set of formal semantics for C written in Isabelle I believe.
11:12:15 <pmetzger> though they only did a very large subset of C, not quite everything.
11:12:24 <thoughtpolice> i'm torn on the seL4 work
11:12:39 <pmetzger> thoughtpolice: why?
11:12:39 <mrd> they did a proof that the C code did what the haskell prototype did
11:12:40 <litb> oh
11:13:07 <thoughtpolice> for one, it's incredibly impressive, and NICTA is working with OK labs to ship seL4 on real devices. real formally verified code, running real businesses and devices
11:13:09 * hackagebot alsa-gui 0.0 - Some simple interactive programs for sending MIDI control messages via ALSA  http://hackage.haskell.org/package/alsa-gui-0.0 (HenningThielemann)
11:13:35 <thoughtpolice> OTOH, the ratio of proofs to LOC is absolutely insane from most perspectives - some 7,800 LOC of C, with well over 250k LOC of isabelle proofs
11:13:41 <pmetzger> and CompCert must have a formal spec since it has to show that the machine code produced has the same effect as the source...
11:14:00 <thoughtpolice> easily something i would call a 'herculian effort'
11:14:04 <pmetzger> thoughtpolice: well, it is a start. We will get better at this as a community as time goes on.
11:14:04 <litb> why do you need that much of LOC for proofs
11:14:20 <pmetzger> litb: have you done much work with a proof assistant?
11:14:30 <thoughtpolice> pmetzger: absolutely! i mean, 10 years ago, you tell someone that we'll have formally verified operating systems within a decade, and they'd think you're totally nuts
11:14:37 <thoughtpolice> but it's real
11:14:39 <pmetzger> litb: if you try such things, you find that it is amazing how quickly the effort expands...
11:14:45 <litb> we did loop invariants and prove simple algorithms like gcd and such 
11:14:55 <pmetzger> litb: with Coq or Isabelle or some such?
11:15:02 <mrd> thoughtpolice: "formally verified" is such a loose description though
11:15:07 <litb> manually
11:15:16 <pmetzger> manually isn't nearly as... big.
11:15:17 <thoughtpolice> pmetzger: same with compcert - 'verified compilers' would have probably been seen as insane not too logn ago
11:15:24 <litb> oh
11:15:24 <thoughtpolice> *long
11:15:29 <Jafet> (If the proof is far longer than what it proved something about, it begs the question of what exactly was proved)
11:15:30 <pmetzger> litb: when you do it with full automated systems, you get amazing verbosity.
11:15:55 <pmetzger> jafet: almost all proofs are longer than the theorem.
11:15:56 <litb> oh
11:16:22 <thoughtpolice> personally i think there's real merit in the approach MSR used in their verified operating system, verve
11:16:30 <Jafet> I was referring to thoughtpolice's figures
11:16:51 <Jafet> OTTH, Lions' commentary documented 10000 LOC
11:17:05 <litb> the unix book?
11:17:23 <pmetzger> jafet: well, you expect a proof to be longer than the thing you are proving something about, there is no other real way to do it...
11:17:46 <pmetzger> if you want to prove something about a program, you need to reason a bit about every line...
11:17:48 <Jafet> But not disproportionately longer, which as I said, could beg the question
11:18:01 <thoughtpolice> verve approach: keep the amount of code proved with an interactive-theorem prover to an absolutely minimal core, and make everything else exist outside of that. everything else is verified in a lightweight manner, and the compiler toolchain is utilized to propogate theorems etc. through things like a typed assembly language
11:18:05 <pmetzger> it doesn't seem disproportionate as such.
11:18:39 <thoughtpolice> so the result is that most of the code that doesn't exist "in the core" really just has lightweight annotations that describe the properties that should hold, and they are checked by the compilation toolchain. things the compilation toolchain can't so easily proved, are moved into the core and proven with a full blown theorem prover
11:19:01 <pmetzger> anyway, the question is what the ten or twentieth big system that gets proved will look like, for the first we can accept messyness in the proof technology.
11:19:03 <Jafet> I might rather read 7800 lines of C than 250000 lines of isabella about that C
11:19:15 <pmetzger> jafet: but you would never read the proof.
11:19:28 <pmetzger> jafet: at most you would read the statements of the theorems proved.
11:19:31 <copumpkin> tibbe: I don't know anything much about it. I wasn't able to find much about it, so I just followed what I saw in the other primop cmm stuff and possibly repeated it unnecessarily
11:19:33 <litb> were there actual bug founds when the code were proven for that L4 kernel?
11:19:39 <Jafet> Okay, how long are the statements being proved?
11:19:41 <pmetzger> litb: yes.
11:19:48 <litb> oh
11:19:49 <pmetzger> Jafet: comparatively quite short.
11:20:16 <litb> once we have intelligent human robots we can tell them to prove our code
11:20:21 <pmetzger> Jafet: you might want to read the papers, but basically they proved equivalence of the C code to a specification created from a Haskell prototype.
11:20:34 <crystal-cola> litb: we wont have intelligent robots before we can prove code correct! :P
11:20:45 <tibbe> copumpkin: :)
11:20:47 <crystal-cola> just crazy ones that make lots of mistakes
11:20:53 <litb> :P
11:20:55 <thoughtpolice> litb: compcert is a verified C compiler, and even bugs were found in it although it is proven (granted, the bugs existed mostly in the parser from what I understand, and there were no actual bugs where the compiler would generate ASM that is not semantically equivalent with the input source
11:20:58 <pmetzger> crystal-cola: by that standard, we're crazy ones...
11:21:14 <pmetzger> thoughtpolice: actually, the bugs were outside the proven section.
11:21:24 <thoughtpolice> pmetzger: yes, that's what I was getting at. the parser isn't proven IIRC
11:21:29 <Jafet> Right. I can see why the proof might be so long now.
11:21:36 <pmetzger> thoughtpolice: people found bugs in compcert that had to do with things like the system .h files.
11:21:45 <thoughtpolice> pmetzger: ah, that makes more sense.
11:21:51 <pmetzger> thoughtpolice: I think as a result they've been expanding what is proven in the system.
11:22:01 <litb> so for proving compcert they surely need to formalize the C rules
11:22:06 <pmetzger> thoughtpolice: that paper is really interesting...
11:22:13 <pmetzger> thoughtpolice: (on the bugs that people found.)
11:22:16 <pmetzger> litb: yes.
11:22:25 <thoughtpolice> pmetzger: the paper about csmith?
11:22:34 <pmetzger> thoughtpolice: and the related systems, yes.
11:23:00 <pmetzger> thoughtpolice: the paper where they describe the 350 odd bugs they found and the machinery they used to generate the test cases.
11:23:00 <thoughtpolice> pmetzger: also, yeah, compcert has really impressed me. i think i remember when it was first available for download and it didn't support a lot of stuff, but now they support almost the full C standard modulo a few things
11:23:37 <pmetzger> thoughtpolice: and formal methods have been used for some time in large chunks of microprocessor design, so one could expect in some years to have a system proven all the way to the metal.
11:23:53 <pmetzger> thoughtpolice: which will still, sadly, not mean that you're free of failure modes, but it is at least a very very serious improvement.
11:23:59 <thoughtpolice> yeah, i've done some reading into the work john harrison does @ intel, he verifies their floating point units
11:24:03 <thoughtpolice> pmetzger: indeed
11:24:24 <thoughtpolice> john actually has a really good book he wrote about interactive/automated theorem proving, too
11:24:28 <pmetzger> another big thing they verify is the cache coherency hardware which is insanely hairy -- without formal methods the bugs would be impossible to avoid.
11:24:56 <pmetzger> humans have a lot of difficulty reasoning about the behavior of things like cache coherency hardware -- too much state and parallelism.
11:31:23 <navaati> I get an error "Could not deduce (Parameters c) from the context (Parameters (a, c), Parameters (b, c))" but i've got an instance "(Parameters v, Parameters w) => Parameters (v,w)" so why does the compiler bother me ?
11:32:14 <sm_> good morning. Installing the HP on this somewhat locked down windows machine gave a warning popup near the end, saying it could not update PATH. Now the files are in place and I can run bin/ghc, but I see no cabal executable. Am I out of luck ?
11:33:13 <mauke> navaati: because there is no instance Parameters c
11:33:49 <mauke> hmm, actually ...
11:34:45 <libertas> /quit
11:35:21 <mauke> navaati: do you have a testcase?
11:36:00 <sm_> hmm, tried again telling it not to set PATH, no error this time. And I saw cabal.exe go by in the details pane. But where is it...
11:36:22 <navaati> a simple one ? no, it's rather hairy code : i'm trying to do context-restricted category and arrows
11:36:34 <mauke> it seems like that should work
11:37:08 <rawrsause> whats up
11:37:13 <crystal-cola> not much 
11:37:37 <rawrsause> I have some questions 
11:38:00 <rawrsause> im considering switch from lisp over to haskell
11:38:01 <eduard> how to convert lazy <-> strict bytestrings? http://hpaste.org/46081/lazy_bytestring__strict_byt#5
11:38:09 <crystal-cola> what do you mean switch?
11:38:11 <rawrsause> switching*
11:38:30 <navaati> :/ i'm actually hacking code that i don't really understand, with associated datatypes and stuffs…
11:38:46 <crystal-cola> navaati: they are quite simple just ask if you want to know about them
11:39:25 <rawrsause> well ive been learning lisp and there are somethings that pissed me off (like need to deal with implenation bullshit)
11:39:34 <rawrsause> and some other minor details 
11:39:37 <crystal-cola> what bullshit do yo/u mean exactly?
11:39:41 <crystal-cola> if i
11:40:38 <rawrsause> my main question is how hard would it be to learn haskell if I already know lisp. they seem to quite a bit in commen
11:40:57 <Jafet> Sounds like you don't know lisp
11:41:01 <mauke> depends on your definition of lisp and what other languages you know
11:41:02 <rawrsause> they seem to have quite a bit in common**
11:41:15 <crystal-cola> youl should probably just start learning it
11:41:22 <Jafet> ...whatever lisp is.
11:41:23 <rawrsause> some C perl lisp and other things
11:41:27 <crystal-cola> because that way you can see at the end of the day if you can be bothered going for it
11:41:32 <crystal-cola> it wont take that long though
11:41:35 <rawrsause> well its not hard its just a PITA
11:41:55 <mauke> crystal-cola: it won't take more than a few years :-)
11:42:57 <rawrsause> Hmmm
11:43:25 <Jafet> Unless something pisses him off in the meantime
11:43:32 <rawrsause> lol
11:45:22 <rawrsause> well Ill give it a try for a while after a finish a couple projects in lisp (I cant simply abandon all my code...)
11:45:36 * sm_ found it: HPDIR\lib\extralibs\bin\cabal.exe
11:45:54 <rawrsause> if I like haskell enought to rewrite them in it then problem solved
11:46:19 * rawrsause has solved his own problem
11:46:46 * rawrsause is a dumass for not thinking of that to begin with
11:46:50 <Jafet> Perhaps your lisp could be improved with a few quote marks.
11:48:19 * hackagebot reactive-banana 0.2.0.0 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.2.0.0 (HeinrichApfelmus)
11:48:33 <rawrsause> theres nothing wrong with LISP just the fact that the community is so devided that I have to go through so much BS before I could even think about sharing my code with poeple...
11:49:34 <Jafet> Okay, I meant your english.
11:50:56 <rawrsause> Jafet: lol sorry ive been in a bit of a rush
12:01:39 <pmetzger> Jumping in late, as a lisp-head, I'll say that Haskell is somewhat easier knowing lisp (the functional programming idea is much less alien) but that the type system is entirely different and that's the hard part.
12:01:58 <crystal-cola> yes type system is very interesting and non-trivial
12:02:02 <pmetzger> Learning ML made Haskell much easier to attack.
12:02:23 <pmetzger> still non-trivial though.
12:09:16 <rawrsause> pmetzger: thanks for the info. I just wanted a general idea of how 'different it might be from what im used to.
12:10:08 <pmetzger> rawrsause: you will feel entirely at home in the heart of a recursive pure function. what will feel weird is how you declare types.
12:10:11 <pmetzger> and how you use them.
12:10:30 <pmetzger> pattern matching, well, you'll just wish that lisp dialects had pattern matching (though some are getting it now.)
12:11:19 * roconnor prepares his first question on stackoverflow
12:16:30 <roconnor> where can I find unsafe-are-they-really-the-same-pointer ?
12:17:31 <aristid> roconnor: i'm pretty sure somebody in #haskell knows this :)
12:17:34 <aristid> not me tho :P
12:17:55 <roconnor> :)
12:18:02 <roconnor> @hoogle unsafeEqual
12:18:03 <lambdabot> No results found
12:18:06 <roconnor> @hoogle unsafe
12:18:06 <lambdabot> Language.Haskell.TH unsafe :: Safety
12:18:06 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
12:18:06 <lambdabot> module Data.ByteString.Unsafe
12:18:09 <roconnor> @hoogle+
12:18:10 <lambdabot> module System.IO.Unsafe
12:18:10 <lambdabot> Language.Haskell.TH Unsafe :: Safety
12:18:10 <lambdabot> Language.Haskell.TH.Syntax Unsafe :: Safety
12:18:14 <roconnor> :/
12:19:12 <crystal-cola> reallyUnsafePtrEquality#
12:19:19 <roconnor> yes
12:19:24 <roconnor> is that real?
12:19:33 <crystal-cola> im not sure
12:19:35 <doserj> it's in GHC.Prim
12:20:40 <aristid> it seems to be real, but ghci spits out parse errors when it sees the #
12:20:49 <aristid> do i need to enable some extension?
12:21:00 <kosmikus> aristid: MagicHash
12:21:37 <aristid> roconnor: you're seemingly supposed to use GHC.Exts instead of GHC.Prim
12:21:43 <paolino> how I parse a decimal number in a Rational ?
12:21:50 <aristid> kosmikus: thanks!
12:22:17 <roconnor> how do I enable MagicHash from the :set
12:22:24 <aristid> :set -XMagicHash
12:22:28 <kosmikus> :set -XMagicHash
12:22:30 <aristid> like all language extensions :P
12:22:36 <aristid> crystal-cola: how did you find that?
12:22:38 <parcs> paolino: toRational?
12:22:54 <crystal-cola> find what??
12:23:01 <aristid> crystal-cola: the function name
12:23:04 <paolino> parcs: it seems wrong
12:23:08 <roconnor> how do I print an Int# ?
12:23:08 <crystal-cola> its in the docs
12:23:36 <aristid> roconnor: i guess you need to box it?
12:23:37 <kosmikus> roconnor: turn it into an Int, for example
12:23:43 <kosmikus> I#, I think
12:24:03 <paolino> > toRational (read "0.1") == 1 % 10
12:24:04 <lambdabot>   *Exception: Prelude.read: no parse
12:24:05 <parcs> paolino: ah, yeah. not sure how to circumvent those rounding errors..
12:24:19 <paolino> > toRational (read "0.1" :: Float) == 1 % 10
12:24:20 <lambdabot>   False
12:24:33 <roconnor> damn
12:24:41 <roconnor> *DList GHC.Exts> I# (reallyUnsafePtrEquality# test (prev (next test)))
12:24:42 <roconnor> 0
12:25:16 <aristid> roconnor: ghci is NOT optimising
12:25:25 <roconnor> hmm
12:26:36 <paolino> > toRational (read "0.1" :: Double) == 1 % 10
12:26:37 <lambdabot>   False
12:27:31 <navaati> > toRational (read "0.1" :: Double)
12:27:32 <lambdabot>   3602879701896397 % 36028797018963968
12:27:33 <roconnor> $ ./DList 
12:27:35 <roconnor> 0
12:27:50 <vicvicvic> i'm trying to translate an XPath expression into "just" arrows in HXT, but can't figure out some parts... Here's my code: http://hpaste.org/46085/xpath_to_regular_arrows
12:28:44 <navaati> > fromRational $ toRational (read "0.1" :: Double)
12:28:45 <lambdabot>   0.1
12:28:53 <navaati> wtf…
12:28:55 <parcs> > toRational (0.1 :: CReal)
12:28:56 <lambdabot>   *Exception: CReal.toRational
12:31:54 <paolino> so "0.1" cannot be parsed to a value everyone think it is
12:33:38 <c_wraith> > read "0.1" :: Rational
12:33:40 <lambdabot>   *Exception: Prelude.read: no parse
12:33:55 <c_wraith> oh
12:34:00 <c_wraith> but...
12:34:07 <c_wraith> > 0.1 :: Rational
12:34:08 <lambdabot>   1 % 10
12:34:26 <c_wraith> how, precisely, does the compiler do that?
12:34:29 <paolino> yeah, funny
12:34:34 <c_wraith> I guess I could read the spec :)
12:35:22 <crystal-cola> 0.1 is Num a => a
12:35:56 <c_wraith> No it's not
12:36:00 <c_wraith> > 0.1 :: Int
12:36:01 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
12:36:01 <lambdabot>    arising from the lit...
12:36:03 <crystal-cola> well it's something
12:36:04 <crystal-cola> :t 0.1
12:36:06 <lambdabot> forall t. (Fractional t) => t
12:36:09 <crystal-cola> it's Fractional
12:36:15 <c_wraith> @src Fractional
12:36:15 <lambdabot> class  (Num a) => Fractional a  where
12:36:15 <lambdabot>     (/)             :: a -> a -> a
12:36:16 <lambdabot>     recip           :: a -> a
12:36:16 <lambdabot>     fromRational    :: Rational -> a
12:36:16 <crystal-cola> and Rational is a Fractional
12:36:41 <c_wraith> so..  GHC parses all fractionals as rationals, and then calls fromRational
12:36:50 <crystal-cola> I guess so
12:37:43 * roconnor doesn't understand reallyUnsafePtrEquality#
12:37:55 <arcatan> it sounds really unsafe
12:37:59 <c_wraith> It's just a check to see if the pointers are the same.
12:38:07 <aristid> arcatan: hey that was supposed to be my joke
12:38:09 <c_wraith> It's unsafe because it uses unsafePerformIO
12:38:18 <c_wraith> it's really unsafe because its results aren't guaranteed to mean anything
12:38:27 <c_wraith> it has false positives *and* false negatives
12:38:34 <aristid> c_wraith: how so?
12:38:36 <roconnor> false positives?
12:38:41 <aristid> how can it have false positives?
12:38:55 <copumpkin> something can get moved around in a particularly annoying way
12:39:03 <c_wraith> get the address of the first arg.  GC happens.  get the address of the second arg
12:39:05 <copumpkin> such that its new pointer address is the same place as the old thing
12:40:01 <navaati> crystal-cola: so you understand associated datatypes ? then could you explain me why with this http://hackage.haskell.org/packages/archive/suitable/0.1/doc/html/src/Data-Suitable.html a context (Suitable m a) can be transformed into a constraint (WhateverIWant a) depending on m ?
12:40:07 <roconnor> is there an easy way to tell if sharing has occured?
12:40:16 <roconnor> maybe I should download vacuum
12:40:21 <copumpkin> navaati: that's a GADT thing
12:40:34 <crystal-cola> navaati: what is WhateverIWant?
12:40:36 <copumpkin> GADTs can carry instances on their constructors
12:40:53 <navaati> WhateverIWant is a typeclass
12:41:03 <crystal-cola> can we do a concrete example?
12:41:16 <navaati> copumpkin: what ? there are no GADTs involved
12:41:36 <paolino> c_wraith: do I have to write a parser in the end ?
12:41:41 <ion> > let rational = option id (char '-' *> pure negate) <*> rationalUnsigned; rationalUnsigned = f <$> many1 digit <*> option "0" (char '.' *> many1 digit) where f real frac = read real % 1 + read frac % 10^length frac in parse (rational <* eof) "" "123.0000041"
12:41:42 <lambdabot>   Not in scope: `option'Not in scope: `many1'Not in scope: `digit'Not in scop...
12:41:48 <ion> Right (1230000041 % 10000000)
12:41:56 <copumpkin> navaati: it's GADT-like behavior: data instance Constraints Set a = Ord a => SetConstraints
12:42:04 <copumpkin> you can't write that on a regular ADT
12:42:12 <c_wraith> paolino: you shouldn't have to write one.  since the behavior you want is part of GHC, it should be in a library somewhere
12:42:30 <navaati> crystal-cola: yes, for example there is a class class RFunctor f where    fmap :: (Suitable f a, Suitable f b) => (a -> b) -> f a -> f b
12:42:50 <crystal-cola> well i don't see it
12:42:53 <crystal-cola> where is it
12:42:53 <crystal-cola> ?
12:42:55 <navaati> and there is an instance for Set, wich require it's content to be instance of Ord
12:43:02 <navaati> http://hackage.haskell.org/packages/archive/rmonad/0.7/doc/html/src/Control-RMonad.html
12:43:13 <crystal-cola> class RFunctor f where fmap :: (Suitable f a, Suitable f b) => (a -> b) -> f a -> f b
12:43:30 <crystal-cola> yes and a bunch of instances, cool
12:44:00 <crystal-cola> navaati: so Set needs something special
12:44:04 <navaati> and so for Set, the type becomes "(Ord a, Ord b) => (a -> b) -> Set a -> Set b
12:44:11 <copumpkin> navaati: I don't get what your question is
12:44:17 <copumpkin> navaati: it doesn't really turn into that type
12:44:18 <crystal-cola> data instance Constraints Set a = Ord a => SetConstraints
12:44:31 <crystal-cola> yes exactly
12:44:34 <crystal-cola> and that data isntance is why
12:44:42 <copumpkin> I'd have written it as
12:44:54 <copumpkin> data instance Constraints Set a where SetConstraints :: Ord a => Constraints Set a
12:45:02 <crystal-cola> instance Ord a => Suitable Set a where constraints = SetConstraints
12:45:08 <paolino> ion, is it taken from GHC code base ?
12:45:21 <roconnor> at least vacuum is easy to install
12:46:16 <ion> No, i wrote it. Do use whatever GHC uses if you find it. Please tell about it to me, too. :-)
12:46:29 <copumpkin> navaati: what is your question about it?
12:47:07 <copumpkin> it's basically jumping through the value level to get at the constraints for Set
12:47:18 <navaati> well, I don't understand how is transmitted the context : if fmap is of type (Suitable f a, Suitable f b, RFunctor f) => (a -> b) -> f a -> f b, how can fmap then become of type "(Ord a, Ord b) => (a -> b) -> Set a -> Set b" ? it's not only replacing f with Set, there is a mysterious something more
12:47:19 <copumpkin> by attaching the constraint to the SetConstraints constructor
12:47:33 <copumpkin> indeed you're going to have to pattern match on SetConstraints before it lets you do anything with Ord
12:49:09 <crystal-cola> navaati: its computation
12:49:25 <crystal-cola> navaati: Suitable Set a is actually computed to Ord a
12:50:07 <navaati> so why do i need to pattern match on SetConstraints ?
12:50:41 <copumpkin> so it's looking for a Suitable f a instance
12:50:42 <crystal-cola> navaati: where is that?
12:50:50 <copumpkin> Ord a => Suitable Set a  matches if you're using set
12:51:04 <crystal-cola> withConstraintsOf a $ \SetConstraints -> ...
12:51:04 <copumpkin> so it can just look for Ord a instead
12:51:08 <crystal-cola> right
12:51:16 <copumpkin> the SetConstraints brings the actual instance into scope
12:51:18 <copumpkin> for the fmap
12:51:28 <copumpkin> it's GADT-like behavior, as I said
12:52:14 <navaati> hum… i didn't know i should study GADT before assicoated datatypes…
12:52:22 <crystal-cola> this isn't to do with GADTs
12:52:34 <navaati> but then it makes my problem even more puzzling
12:52:35 <copumpkin> it's not inherent to GADTs, but regular ADTs don't support that behavior
12:52:42 <crystal-cola> data instance Constraints Set a = Ord a => SetConstraints
12:52:45 <copumpkin> so that's why I keep comparing it to a gADT
12:52:46 <crystal-cola> see this
12:53:10 <crystal-cola> it just means that when you pattern match on 'SetConstraints' of type Constaints Set a you get Ord a in your context
12:53:16 <crystal-cola> meaning that you can order things of type a
12:56:22 <pmetzger> is isSpace true for wacko unicode space characters?
12:56:34 <pmetzger> the docs don't seem to say. (I suppose I could RTFS)
12:56:35 <copumpkin> I'd expect so
12:56:46 <copumpkin> assuming it's marked as a space in the unicode spec
12:56:49 <copumpkin> it just follows that data
12:56:57 <paolino> ion
12:57:00 <byorgey> "Returns True for any Unicode space character, and the control characters \t, \n, \r, \f, \v."
12:57:02 <paolino> > readPrec_to_S lexP 0 "0.1"
12:57:03 <lambdabot>   Not in scope: `readPrec_to_S'Not in scope: `lexP'
12:57:17 <byorgey> pmetzger: which docs are you looking at?
12:57:21 <navaati> but for example in the RMonad instance for Set, there is "return = Set.singleton", without pattern-matching on SetConstraints, however Set.singleton needs the (Ord a) context
12:57:31 <pmetzger> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html
12:57:40 <copumpkin> @hoogle singleton
12:57:41 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
12:57:41 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
12:57:41 <lambdabot> Data.IntSet singleton :: Int -> IntSet
12:57:47 <crystal-cola> navaati: let me see
12:57:55 <copumpkin> @hoogle a -> Set a
12:57:56 <lambdabot> Data.Set singleton :: a -> Set a
12:57:56 <lambdabot> Data.Set deleteMax :: Set a -> Set a
12:57:56 <lambdabot> Data.Set deleteMin :: Set a -> Set a
12:58:01 <paolino> Prelude Text.Read Text.ParserCombinators.ReadPrec> readPrec_to_S lexP 0 "0.1"
12:58:02 <byorgey> pmetzger: yes, that's what I'm looking at too, and the docs for isSpace say what I just pasted above.
12:58:03 <paolino> [(Rat (1 % 10),"")]
12:58:03 <copumpkin> doesn't look like an Ord constraint to me
12:58:09 <pmetzger> Yup. I noticed. :)
12:58:14 <crystal-cola> @type Set.singleton
12:58:15 <lambdabot> Couldn't find qualified module.
12:58:20 <crystal-cola> @type singleton
12:58:21 <copumpkin> :t S.singleton
12:58:21 <lambdabot> Not in scope: `singleton'
12:58:22 <lambdabot> forall a. a -> S.Set a
12:58:27 <copumpkin> look ma, no constraint
12:58:41 <byorgey> pmetzger: well, perhaps I don't know what you mean by 'wacko' =)
12:58:43 <monochrom> oh neat
12:58:50 <copumpkin> it doesn't need to compare anything to make a singleton Set
12:58:55 <pmetzger> unicode has all these things like invisible spaces.
12:58:59 <pmetzger> non-breaking spaces
12:59:04 <monochrom> there is no wacko character or code point in unicode
12:59:08 <pmetzger> spaces from hell.
12:59:21 <ddarius> This may have been answered, but to answer a question from much earlier.  Partiality as an effect is by considering your arrows to be arrows in a Kleisli category for the partiality monad, whereas as a value you just have normal functions.  That is, as an effect A -> B means A -> Lift B, and as a value means A -> B means A -> B but A means Lift A.
12:59:27 <monochrom> non-breaking space originated from iso-latin-1 already
12:59:38 <pmetzger> monochrom: I find that unicode rules are easy to understand until they aren't. :)
12:59:41 <navaati> oh… i thougt the Ord constraint was in the Set type itself… no problem then
12:59:54 <copumpkin> nah, we try to avoid doing that
12:59:58 <cheater99> hi
13:00:03 <copumpkin> in fact, the ability to do that was removed in h2011
13:00:10 <copumpkin> only Complex has it
13:00:34 <cheater99> are there any known case studies of applications of parallel computing / high performance computing in the industry, with a mention of the general area of interest etc?
13:00:35 <navaati> copumpkin: really ? why ? i find it usefull
13:00:43 <copumpkin> navaati: how is it helpful?
13:01:02 <copumpkin> the issue is that you don't magically get the constraints when you're writing functions on the type
13:01:06 <copumpkin> so it really doesn't do you much good
13:01:12 <copumpkin> if you wrote data Ord a => Set a = ...
13:01:18 <pmetzger> cheater99: "the industry"?
13:01:28 <cheater99> yeah, as in, any industry really
13:01:29 <copumpkin> you'd still have to write Ord a => on every function that uses comparisons on Set
13:01:52 <pmetzger> <smile>no, no one uses parallel computing/HPC in the real world.</smile>
13:01:58 <monochrom> the proof that you don't need the constraint uses classical logic, so those who only believe in intuitionistic logic have a hard time seeing it
13:01:58 <navaati> semantically it allows to say "this type makes sense for Ord parameters"
13:02:00 <cheater99> say, things like "there's a lot of research on acoustic beamforming that needs parallel supercomputing"
13:02:01 <lispy> copumpkin: that sounds dreadful.  I'm glad I'm not putting class constraints on my data types!
13:02:09 <cheater99> "it is something used for building sonar"
13:02:14 <aristid> pmetzger: that parallel stuff is just too ivory tower
13:02:19 <ion> paolino: Alright, thanks
13:02:39 <ddarius> Just process all those terabytes of LHC data with ruby.
13:02:49 <cheater99> or: "you need this to form simulations of protein behaviour. this is used by biotech companies"
13:03:03 <cheater99> ddarius: no, php
13:03:04 <pmetzger> cheater99: there are thousands of applications for HPC. this is like asking "are there applications for graphical displays"
13:03:14 <monochrom> by the law of excluded middle, you expose your data type or you don't. if you expose, why restrict other people in using it some other way. if you don't expose, it doesn't add information anyway
13:03:32 <pmetzger> cheater99: you're not going to get a compact answer.
13:03:41 <cheater99> pmetzger: no one said compact
13:03:45 <cheater99> pmetzger: just "a study"
13:04:15 <pmetzger> cheater99: Do you ever use a service called "google"?
13:04:24 <navaati> monochrom: wel… right
13:04:24 <copumpkin> @djinn Not (Not (Either a (Not a)))
13:04:25 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
13:04:45 <cheater99> pmetzger: what's your problem?
13:04:48 <pmetzger> cheater99: I understand they're considering using multiple computers in their next version, since the laptop it runs on is getting overloaded.
13:05:00 * monochrom begins every proof with the law of excluded middle
13:05:10 <cheater99> i've been using google for the last week and a half researching the question
13:05:13 * djahandarie wonders how that works
13:05:17 <pmetzger> cheater99: I'm not trying to be mean, I'm just noting that you're talking about something used at just about EVERY company now, so there isn't any easy way to point out interesting distinguished examples.
13:05:25 <copumpkin> f :: (forall a. Either a (Not a)) -> the statement I want to prove
13:05:32 <copumpkin> nothing wrong with that :)
13:05:43 <cheater99> funny, the cheese shop down the street doesn't yet have a cluster
13:05:57 <pmetzger> cheater99: well, it isn't much of a cheese shop then, is it?
13:06:25 <cheater99> you've just gone from repulsive to boring
13:06:32 <pmetzger> cheater99: what with the camembert being too runny and all.
13:06:52 <copumpkin> yum
13:06:54 <copumpkin> now I want cheese
13:06:57 <copumpkin> maybe a nice burrata
13:07:26 <pmetzger> cheater99: and yes, if they have any modern computers at all, they almost certainly do actually use a parallel even if they don't realize it. the thing in the back they run QuickBooks on has multiple cores.
13:07:44 <pmetzger> (and quickbooks will *use* the multiple cores.)
13:08:17 <pmetzger> your iphone has a half dozen ARM cores in it. if you don't have one of them, your android phone is the same.
13:08:30 <aristid> lie.
13:08:38 <aristid> iphone only has one ARM v9 core at this point.
13:08:41 <Twey> … what no
13:08:41 <pmetzger> nope.
13:08:44 <pmetzger> there are MANY.
13:08:49 <Twey> No smartphone has more than one core :-\
13:08:52 <aristid> pmetzger: what?
13:08:56 <pmetzger> the CPU the OS runs on is NOT THE ONLY PROCESSOR
13:09:03 <aristid> pmetzger: they have other stuff in there, but not ARM cores
13:09:03 <pmetzger> the GSM chip, for example, has a dedicated ARM in it.
13:09:04 <Twey> Oh, right
13:09:09 <pmetzger> so does the WiFi chip.
13:09:16 <copumpkin> pmetzger: I see you know what you're talking about :)
13:09:16 <Twey> I didn't know those were ARM cores.
13:09:18 <aristid> oh, they're ARM too?
13:09:19 <Twey> Neat.
13:09:20 <copumpkin> yeah, they are
13:09:39 <crystal-cola> navaati: is it all clear now?
13:09:48 <pmetzger> the graphics chip is a CPU too, with a parallel programming paradigm.
13:09:56 <roconnor> @tell napping http://stackoverflow.com/questions/5810163/creating-a-doubly-linked-list-from-a-list-in-ocaml
13:09:56 <lambdabot> Consider it noted.
13:10:16 <pmetzger> several of those other CPUs don't have a real OS or even MMU but they're still real processors.
13:10:52 <copumpkin> pmetzger: what's your interest in the iphone?
13:10:56 <pmetzger> inside your desktop there's a couple of processors inside your hard drive's electronics. I don't know if the SATA controller itself has a processor....
13:11:06 <aristid> pmetzger: are they the same kind of ARM as the main core, or a lower level?
13:11:09 <pmetzger> copumpkin: other than owning one? not much. :)
13:11:10 <navaati> it doesn't resolve the 'error is "Could not deduce (Parameters c) from the context (Parameters (a, c), Parameters (b, c))" but i've got an instance "(Parameters v, Parameters w) => Parameters (v,w)" issue, but it's clearer, thanks
13:11:19 <pmetzger> aristid: different models.
13:11:31 <copumpkin> they don't have all the same features
13:11:53 <aristid> and the GPU core is probably physically quite different
13:11:58 <monochrom> there are more ARMs than there are theories
13:12:08 <pmetzger> at this point, if you walk into a room, you probably can't count the number of CPUs in it any more without serious effort.
13:12:12 <crystal-cola> navaati: what is that??
13:12:15 <copumpkin> monochrom: how about toposes and triples?
13:12:16 <crystal-cola> navaati: you never mentioned this
13:12:27 <aristid> pmetzger: at least if there's stuff in the room
13:12:40 <aristid> pmetzger: sadly, many buildings are still pretty lacking in electronics
13:12:42 <pmetzger> aristid: even if there seemingly isn't. the thermostat probably has an 8051
13:12:44 <crystal-cola> navaati: Parameters? This is something todally else
13:13:15 <pmetzger> the digital thermometer pressed up against the window with a suction cup probably has something like an 8051 too.
13:13:42 <aristid> pmetzger: the knob on the radiator? i think in my house, that's still physical :)
13:13:55 <aristid> the central heating of course has its shares of microelectronics
13:14:14 <pmetzger> the smart meter in the basement of the house probably has a TI microprocessor like an MSP430
13:14:34 <pmetzger> ignoring the processor for the wireless interface on the smart meter...
13:14:35 <aristid> i have 4 MSP430s in boxes lying around :D
13:14:42 <aristid> not yet got to actually playing with them
13:14:56 <navaati> crystal-cola: i mentionned it before, maybe you were not here
13:14:56 <navaati> i'm trying to make a rarrow stuff like rmonad, and i use it into a sort of EDSL for µC
13:15:01 <pmetzger> aristid: your radiator knob is probably still a metal valve with no active components, yes.
13:15:15 <aristid> pmetzger: the house was built around 2000.
13:15:34 <crystal-cola> navaati: you may do simpler than rmonad
13:15:48 <aristid> pmetzger: i think houses should have way more, and more powerful, electronics :)
13:15:59 <pmetzger> aristid: if it doesn't have a smart meter yet, it will soon. The companies don't like sending meter readers around any more.
13:16:19 <pmetzger> aristid: after that you will never be able to feel safe again because they're all so easy to remotely destroy. :(
13:16:25 <aristid> pmetzger: doesn't it have to have a meter in the central heating room?
13:16:33 <aristid> -have+suffice
13:17:07 <pmetzger> you are in an apt. building? do you get billed separately for electricity?
13:17:10 <Vq> Where can i download the gtk2hs source?
13:17:28 <navaati> crystal-cola: with MultiParamTypeClasses ? i tried, it was a giant hrrific mess
13:17:32 <Vq> The links from http://www.haskell.org/haskellwiki/Gtk2Hs seems broken.
13:17:43 <navaati> Vq : from HackageDB
13:18:38 <Vq> navaati: What is it called there?
13:19:12 <navaati> gtk
13:19:24 <crystal-cola> navaati: certainly not..
13:19:43 <navaati> but it's splitted in many packages, there is glib, gtk and cairo for the main ones i think
13:19:52 <navaati> crystal-cola: then what ?
13:19:54 <aristid> pmetzger: no i'm in a house
13:19:59 <monochrom> the hvac system at my home has a formidable motherboard
13:20:07 <crystal-cola> navaati: well have you written a simple explanation of exactly what you're trying to do?
13:20:20 <Vq> Ah, i was looking for gtk2hs and only under the GUI category
13:20:25 <Vq> navaati: Thanks
13:20:26 <aristid> pmetzger: i think electricity is billed separately tho
13:20:40 <aristid> pmetzger: we also have teleheating
13:20:49 <pmetzger> in most houses, the utilities are installing smart meters so they can remotely read each meter. most places they've already done it in fact.
13:21:06 <ddarius> copumpkin: It's a rather nice day.
13:21:22 <pmetzger> "smart" for some small value of smart though. the software on them is terrible. :(
13:23:36 <pmetzger> If I want to spit out an error message like "bad character: 'x'" -- is there something better than error ("bad character: '" ++ [whatever] ++ "'") ?
13:23:53 <mauke> hPutStr?
13:24:01 * pmetzger is a clueless newb
13:24:31 <shachaf> pmetzger: You can use printf.
13:24:37 <roconnor> gah no
13:24:45 <mauke> hPrintf
13:24:59 * roconnor sighs
13:25:02 <navaati> crystal-cola: i'm trying to have a typeclass Arrow where it is possible to say that MyType a b is an arrow only when a and b are instance of a particular typeclass, just like RMonad allows to say that Set a is a monad only when a is instance of Ord
13:25:12 <parcs> > show 'x'
13:25:13 <lambdabot>   "'x'"
13:25:31 <roconnor> error ("bad character: '" ++ show whatever ++ "'")
13:25:41 <edwardk> navaati: then you need an equivalent RArrow
13:25:41 <mauke> too many '
13:25:42 <shachaf> That'd be double-single-quoted.
13:25:55 <pmetzger> so show whatever is better style? I guess it would be.
13:26:01 <roconnor> error ("bad character: " ++ shows whatever)
13:26:05 <pmetzger> certainly more general.
13:26:05 <edwardk> woops just noticed the context, backtracking
13:26:08 <roconnor> error ("bad character: " ++ show whatever)
13:26:08 <navaati> edwardk: that is what i'm trying to do
13:26:10 <mauke> hPrintf stderr "bad character: %s" (show whatever)
13:26:12 <aristid> pmetzger: show just escapes non-printable characters
13:26:17 <aristid> pmetzger: so that's a bit safer.
13:26:19 <roconnor> putStrLn ("bad character: " ++ show whatever)
13:26:27 <mauke> roconnor: that prints to stdout
13:26:29 <roconnor> hPutStrLn stderr ("bad character: " ++ show whatever)
13:26:39 <aristid> now use $
13:26:41 <roconnor> mauke: stdout isn't so bad
13:26:44 <pmetzger> I want to abort, thus error...
13:26:44 <navaati> edwardk: using the same method than RMonad
13:26:46 <mauke> yes, it is
13:26:47 <aristid> parentheses are evil
13:26:56 <shachaf> aristid: Don't encourage overuse of $. :-(
13:27:01 <shachaf> People use it too much already.
13:27:17 <edwardk> navaati: i usually wind up building over the contents of http://hackage.haskell.org/package/categories or http://hackage.haskell.org/package/semigroupoids rather than over arrows to get better control over the object types.
13:27:20 <crystal-cola> navaati: oh okay, it's a direct generalization of the thing.. then yes it's simplest to ujst adapt it
13:27:38 <edwardk> navaati: fair enough, should be pretty straightforward
13:27:44 <aristid> shachaf: overuse?
13:27:53 <aristid> shachaf: there's no such thing as overuse of $!
13:27:59 <copumpkin> ddarius: indeed!
13:28:16 <mauke> I think you can overuse $! though
13:28:19 <aristid> preflex: seen ddarius
13:28:19 <preflex>  ddarius was last seen on #haskell 7 minutes and 14 seconds ago, saying: copumpkin: It's a rather nice day.
13:28:20 <copumpkin> ddarius: I stumbled running this morning and my ankle hurts now, so I limp everywhere
13:28:26 <roconnor> wow.  Stackoverflow gets a question every 15 seconds
13:28:37 <monochrom> pmetzger: you should disclose more context about how this bad character happens
13:28:41 <shachaf> aristid: There's definitely overuse of ($). For one, every place where (.) would do.
13:28:59 <aristid> shachaf: don't worry, i do use .
13:29:07 <pmetzger> I'm writing a really dumb parser as an exercise to work out some ideas. I don't care if it handles the error elegantly, I just want it to abort and tell me what was wrong.
13:29:09 <aristid> shachaf: i don't think in this example . would work
13:29:11 <monochrom> for example one would do different things depending on whether it's in IO code or in ordinary functions
13:29:18 <pmetzger> I'll do something more reasonable later.
13:29:19 <shachaf> aristid: True. But parentheses would.
13:29:28 <aristid> shachaf: but they're ugly!
13:29:41 <pmetzger> This is an ordinary function.
13:29:46 <monochrom> then error
13:29:52 <pmetzger> exactly.
13:30:00 <monochrom> or Either, if that's your parser's cup of tea
13:30:08 <edwardk> navaati: fyi: http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2/doc/html/Data-Semigroupoid-Ob.html provides a suitable 'is object of' class for a semigroupoid. you could add a subclass of semigroupoid for your restricted arrow and use Ob to indicate appropriate objects
13:31:05 <rostayob> what's the best resource to understand well haskell type system?
13:31:07 <sm> roconnor: how many haskell questions per day ?
13:31:10 <pmetzger> monochrom: Later it might be. Right now, I'm mostly doing five finger exercises in the vicinity of some of the things I need my actual code to do so I understand Haskell well enough. right now, I only understand the language in a book learning way, not enough actual coding experience.
13:31:13 <rostayob> like a book or something like that :P
13:31:44 <hadtoman> hey there guys
13:31:56 <aristid> edwardk: semiid = return, for the Kleisli instance?
13:32:00 <edwardk> roconnor: and yet they still won't let me earn more than 200 karma a day ;)
13:32:02 <pmetzger> monochrom: later I'll do cleaner stuff. right now I don't know enough about far stupider things, like when it feels better to be using guards and when it feels better to be using patterns for some obvious stuff. only way to learn is to do...
13:32:04 <edwardk> aristid: yeah
13:32:18 <litb> your talkin about SO again. 
13:32:30 <aristid> edwardk: and extract for Cokleisli. neat.
13:32:34 <ddarius> edwardk: So what it the optimal strategy for maximizing karma on SO?
13:32:54 <litb> always go for the easy questions. answer fast, and then build it up in the 5-minutes window
13:32:58 <edwardk> ddarius: 20 upvotes a day, then hunting bounties i'd suppose
13:33:02 <navaati> edwardk: i know nothing about these semigroupoids…
13:33:14 <aristid> ddarius: i think edwardk's approach of writing automatic function deriver packages is not optimal
13:33:20 <edwardk> navaati: semigroupoid = Category without id.
13:33:39 <navaati> and then Ob = Category ?
13:33:42 <edwardk> aristid: ?
13:33:47 <litb> notes the accepted-answer REP also isn't limited to 200
13:34:03 <aristid> edwardk: in terms of karma, there are probably more efficient methods.
13:34:25 <edwardk> navaati: nah, Ob is basically 'Suitable' from rmonad
13:34:32 <edwardk> litb: fair nuff. i never really tried gaming it
13:34:51 <litb> ive never done that too
13:35:19 <edwardk> i capped a few days but never kept track
13:35:33 <aristid> edwardk: why's there no instance of Ob for (->)?
13:35:42 <litb> dons is teh haskell kind on SO?
13:35:57 <edwardk> aristid: prolly coz i didn't think to add it ;)
13:36:05 <navaati> edwardk: without using associated datatypes ? mind = blown
13:36:23 <litb> s,kind,king,
13:36:27 <aristid> navaati: why use associated types when you can use MPTCs? :)
13:36:35 <edwardk> navaati: it uses old school MPTCs
13:37:00 <Gunni> in ghci, why doesn't the home/end button work?
13:37:00 * monochrom asks the opposite. why use mptc when you can use associated types :)
13:37:06 <Gunni> just types a ~ for me
13:37:17 <Gunni> or a 1~ or a 4~
13:37:24 <aristid> Gunni: which ghc version?
13:37:37 <monochrom> it works for me. depends on a million factors
13:37:37 <Gunni> 6.12.1
13:37:52 <aristid> Gunni: works for me, on 6.12.1
13:38:08 <Gunni> i use the home/end keys to go to the front/end of the text i'm typing
13:38:09 <roconnor> monochrom: how do you do a b ~> c | a c ~> b | b c ~> a with associated types?
13:38:19 <navaati> i tried to use regular MPTCs, it was… hairy
13:38:19 <navaati> when dealing with arrows it gave type signatures long like the arm
13:38:19 <aristid> monochrom: i know it didn't work for me with 6.10
13:38:41 <aristid> navaati: edwardk's code seems pretty straightforward
13:38:52 <edwardk> navaati: here they aren't bad
13:38:55 <roconnor> sm: one an hour?
13:39:08 <Gunni> aristid it's never worked for me, becoming annoying
13:39:10 <monochrom> well, works for me all the way from 6.10.4 to 7.0.3. like I said, depends on a million factors.
13:39:12 <sm> wow. Would we like them announced here ?
13:39:24 <monochrom> this means it's really hopeless to resolve over irc
13:39:24 <Gunni> aristid i am running it through putty, maybe that matters ?
13:39:32 <aristid> Gunni: maybe it does.
13:39:45 <Gunni> although i've seen it happen on my windows in ghci
13:39:47 <xplat> associated types are way better than MPTCs at most of the things they can do, but there are a lot of things associated types can't do
13:40:01 <aristid> Gunni: i use linux, so that's entirely different
13:40:21 <xplat> sort of like another level to the module/typeclass dichotomy
13:41:00 <edwardk> like in this case =)
13:41:17 <edwardk> associated types and mptcs overlap but neither subsumes the other
13:41:39 * hackagebot semigroupoid-extras 0.2.1.0 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.1.0 (EdwardKmett)
13:42:01 <Kaidelong> a semigroupoid is a category without id, right?
13:42:16 <edwardk> monochrom: in this case, because there is no fundep between the category and its object set
13:42:19 <edwardk> Kaidelong: yep
13:42:29 <edwardk> Kaidelong: you have associative composition. thats it
13:42:38 <Kaidelong> yay!
13:43:11 <aristid> edwardk: do i see this right, that basically all the existing Ob's are also Categories if their inner Ob is a Category too?
13:43:21 <edwardk> Kaidelong: this is nice because you can define http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2/doc/html/Data-Semigroupoid-Product.html semigroupoid products in Haskell, unlike category products for the existing Category type, which resist implementation
13:44:48 <edwardk> aristid: well, Ob just supplies a witness that a given object has an identity arrow.
13:45:08 <aristid> edwardk: is this a yes or a no? :=
13:45:10 <aristid> :)
13:45:18 <edwardk> so if you have Ob Foo a then you can derive Category Foo
13:45:37 <edwardk> because you're saying you can instantiate semiid :: Foo a a for all a.
13:46:18 <aristid> yeah :)
13:46:36 <edwardk> Kaidelong: you also get semifunctors between them: http://hackage.haskell.org/packages/archive/semigroupoid-extras/0.2/doc/html/Data-Semifunctor.html
13:46:39 <edwardk> doh lost him
13:46:40 <aristid> but haskell does not guarantee that such a Category instance exists, of course
13:46:40 <navaati> i don't even know what is a product (i guess it's not 6*4=24)… i just want arrows (and it turns out that arrows need category), this is too much complicated for my needs i think
13:46:48 <edwardk> aristid: correct
13:47:09 <aristid> edwardk: we need prolog for type classes :)
13:47:11 <edwardk> because there is no way to quantify over a type class argument like that
13:47:34 <edwardk> navaati: um, you don't need to use any of that other crap
13:47:56 <edwardk> class Semigroupoid k where o :: k b c -> k a b -> k a c
13:48:09 <edwardk> class Ob k a where semiid :: k a a
13:48:17 <edwardk> that is the entire relevant portion of the API ;)
13:48:52 <aristid> o is like (.) and semiid is like id, but semiid can be constrained
13:49:03 <o1iver> hi. quick question, is the scope of functions/vars defined in a where clause only the line above the where clause? I cannot access the functions/variables in the second line above the where clause
13:49:24 <edwardk> you probably have some kind of class Semiarrow k where semiarr :: (Ob k a, Ob k b) => (a -> b) -> k a b; ...
13:49:27 <navaati> but if semiid can be constrained, Semigroupoid can't, so it won't work
13:49:29 <edwardk> er
13:49:35 <pmetzger> o1iver: you may have an indentation problem
13:49:39 <edwardk> class Semigroupoid k => Semiarrow k where
13:49:48 <o1iver> acuteAngle (City _ ax ay) (City _ bx by) (City _ cx cy) = acos $ abs $ d/s
13:49:48 <o1iver>            where 
13:49:48 <o1iver>            d = dotProduct3D l1 l2
13:49:48 <o1iver>            s = (vectorLength3D l1) * (vectorLength3D l2)
13:49:48 <o1iver>              where
13:49:49 <o1iver>              l1 = (bx-ax, by-ay, 0)
13:49:51 <o1iver>              l2 = (cx-bx, cy-by, 0)
13:49:55 <edwardk> semigroupoid isn't constrained because it doesn't have to be
13:49:55 <o1iver> pmetzger, ??
13:49:58 <monochrom> o1iver: that is right
13:50:00 <aristid> o1iver: please use http://hpaste.org
13:50:05 <o1iver> sorry
13:50:14 <o1iver> yeah thats the strange thing
13:50:35 <o1iver> I am getting not in scope 'l1' & 'l2'
13:50:41 <edwardk> Note that Semiarrow itself isn't constrained. it is the individual methods on semiarrow that get the constraints!
13:50:42 <monochrom> for example l1,l2 are available to s only
13:51:00 <monochrom> and I fully expect that anyway
13:51:13 <aristid> edwardk: where is Semiarrow?
13:51:14 <o1iver> monochrom, they are? anyways I can use them in d?
13:51:25 <edwardk> aristid: i made it up because it is what navaati wants
13:51:43 <edwardk> but since i despise arrows and haven't needed it, i never bothered to implement one
13:51:49 <monochrom> you don't seem to need a deeper level for l1,l2 anyway
13:51:53 <aristid> edwardk: you didn't provide the method types
13:51:54 <edwardk> i gave the definition about 20 lines up
13:52:15 <aristid> edwardk: no
13:52:18 <navaati> edwardk: are you sure semigroupoid doesn't need to be constrained ? i need to make use of the constraint in the definition of (.)
13:52:20 <pmetzger> o1iver: I think you're violating the offside rule...
13:52:21 <o1iver> monochrom, what do you mean? 
13:52:23 <edwardk> class Semigroupoid k => Semiarrow k where semiarr :: (Ob k a, Ob k b) => (a -> b) -> k a b; ...
13:52:31 <aristid> there. thank you.
13:52:45 <edwardk> aristid: it was up there. 'you probably have some kind of ...'
13:52:52 <monochrom> d,s,l1,l2 can happily live at the same level
13:52:56 <aristid> edwardk: but without semiarr's type.
13:53:13 <edwardk> aristid: [17:10] <edwardk> you probably have some kind of class Semiarrow k where semiarr :: (Ob k a, Ob k b) => (a -> b) -> k a b; ...
13:53:27 <aristid> edwardk: oh, my eyes focused on this: <edwardk> class Semigroupoid k => Semiarrow k where
13:53:39 <edwardk> what was the correction =)
13:53:43 <navaati> Semiarrow is arrow without first ?
13:53:58 <edwardk> navaati: nah you probably get stuck with a particularly horrid semifirst, etc. ;)
13:54:11 <edwardk> that was why i stopped with ...
13:54:16 <edwardk> because i hadn't written out the rest
13:54:17 <pmetzger> o1iver: he's right, you only need one where....
13:54:29 <o1iver> monochrom, ah that works... mmh that doesnt make sense to me but ok
13:54:32 <pmetzger> but shouldn't the body of the where be indented?
13:54:45 <pmetzger> o1iver: why doesn't it make sense?
13:54:57 <o1iver> pmetzger, i doesnt need to be indented
13:55:06 <monochrom> it makes a lot of sense to me
13:55:10 <edwardk> ... ; first :: (Ob k b, Ob k c, Ob k d) => k b c -> k (b, d) (c, d)
13:55:17 <pmetzger> well, shows you how well I understand the offsides rule -- I've been using it cargo-cult style...
13:55:25 <o1iver> pmetzger, well isnt a local variable defined by using where and let
13:55:46 <pmetzger> yes, a local variable is defined by where. all your local variables can be defined at once though...
13:55:52 <o1iver> monochrom, "doesnt make sense to me" = "i dont have a clue"
13:56:01 <o1iver> pmetzger, ah I didnt know that
13:56:03 <navaati> edwardk: so what is the difference between Semiarrow and Arrow ? it doesn't need id ?
13:56:10 <monochrom> consider I have first line "f x = blah", and second line "g y = stuff where k=10". do you expect k to be available to f? no.
13:56:20 <o1iver> pmetzger, so whats the point of having multiple wheres?
13:56:24 <pmetzger> o1iver: you don't have to define something before you use it....
13:56:26 <edwardk> navaati: note the Ob constraints on arr, first, etc.
13:56:35 <monochrom> if k were available to f, that would defeat the whole point of "where"
13:57:05 <monochrom> this makes sense no matter what level f,g are at.
13:57:06 <o1iver> monochrom, yes well I thought that k would be in scope of the entire above block (ie indented the same way)
13:57:18 <navaati> edwardk: but the Ob constraint is not on ∘
13:57:48 <aristid> navaati: because it does not need to be :)
13:57:58 <edwardk> navaati: my way of handling that has been to have the individual objects package up the dictionary if they need it.
13:58:03 <edwardk> let me dig up a non trivial example
13:58:27 <o1iver> pmetzger, so the why can you use multiple wheres? I mean what is the difference, except that the scope is limited
13:58:28 <edwardk> http://hackage.haskell.org/packages/archive/representable-tries/0.3.1.2/doc/html/Data-Functor-Representable-Trie.html#t::-45--62-:
13:58:34 <monochrom> well then, you should read more docs rather than speculate more
13:58:48 <edwardk> data a :->: b where Trie :: HasTrie a => BaseTrie a b -> a :->: b
13:59:01 <o1iver> monochrom, yes
13:59:11 <edwardk> then the composition of :->:'s can use the Trie instance it has in cold storage
13:59:37 <pmetzger> "Similar to let, where defines local functions and constants. The scope of a where definition is the current function. If a function is broken into mul- tiple definitions through pattern-matching, then the scope of a particular where clause only ap- plies to that definition."
14:00:00 <o1iver> ok thx
14:00:07 <edwardk>  instance Semigroupoid (:->:) where o (Trie f) {- this brings the instance I need into scope -} = fmap (index f . embedKey)
14:00:54 <monochrom> actually, it's ok to speculate as long as you mark it as to-be-invalidated speculation
14:01:23 <monochrom> (sadly I know some people who speculate and mark it as certainty)
14:01:49 <edwardk> navaati: this is actually a fairly powerful technique, and useful for smuggling instances where they can't normally go
14:03:06 <navaati> edwardk: hum… so i must use GADTs… i'm pretty confused about all this, but it seems to be an elegant way of doing it
14:03:13 <edwardk> for instance in http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/src/Data-Heap.html#Heap i smuggle the compare function into an ADT, so I can make a traversable heap
14:05:10 <edwardk> and in http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Ring-Semi-BitSet.html#BitSet i smuggle bounds in, but only when i invert a bitset, so that if your type doesn't support Bounded, it doesn't support inversion, but I can use one structure throughout.
14:06:02 <edwardk> the latter are rather less elegant examples, but they show the power of grabbing the pieces you need from dictionaries and stuffing them into ADTs under contracts that they'll match up with the dictionary version
14:06:39 <navaati> dictionaries ?
14:06:51 <aristid> edwardk: why didn't you automatically derive Data there, too?
14:06:51 <edwardk> 'type class instances'
14:07:07 <edwardk> aristid: the semantics of the data instance for a BitSet would be wrong
14:08:30 <edwardk> aristid: but since i wrote that package i settled on a decent way to supply a data instance for something like that
14:08:41 <edwardk> (it just isn't the automatically derived one)
14:09:12 <aristid> edwardk: you seem to represent it as a list? do i understand that code right?
14:09:26 <edwardk> aristid: a bitset?
14:09:38 <aristid> edwardk: Heap
14:10:11 <o1iver> monochrom, fair enough
14:10:16 <edwardk> the bitset itself is represented as an 'arbitrary precision floating point number', using the exponent and mantissa to indicate set membership
14:10:46 <edwardk> ah the heap is a bit scary actually. it is technically a form of relaxed fibonacci heap, so there are some hideous constraints on the members of those trees
14:14:44 <edwardk> er relaxed bootstrapped skew binomial heaps
14:14:54 <edwardk> forgot which heap i was thinking of
14:15:25 <creikat> hi guys. when extracting a head and a tail the variables `x` and `xs` are often used. any logic behind the variable names?
14:15:28 <creikat> :)
14:15:40 <Botje> 'xs' hints at 'more than one x'
14:15:42 <Anpheus__> An x is one thing, an xs is several things :D
14:15:57 <Anpheus__> That's why you'll see x, xs, y, ys, they are plural.
14:16:16 <DasIch> creikat: x is often used in math for function variables, xs is plural
14:16:22 <Botje> @src transpose
14:16:22 <lambdabot> transpose []             = []
14:16:22 <lambdabot> transpose ([]   : xss)   = transpose xss
14:16:22 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:16:24 <creikat> i considered that, but i thought it would be more elaborate :)
14:16:25 <DasIch> creikat: at least that's my assumption
14:16:32 <creikat> thought
14:16:38 <Botje> i've been known to use xss like that there, too
14:16:40 <Anpheus__> For string functions you might see something like "(char:chars)" or just "(c:cs)"
14:16:41 <edwardk> aristid: see the paper by brodal and okasaki i linked from the package. the first 5 chapters are pretty legible and yield straightforward and intuitive types. chapter 6 mucks everything up but gives you much nicer constant factors
14:16:48 <DasIch> Botje: for [[a]]?
14:17:03 <edwardk> aristid: basically the haskell version is that, plus all the stuff implied by chapter 6, plus all the machinery to give it a 'containers'-like API
14:17:08 <Botje> DasIch: yeah.
14:17:11 <Anpheus__> The pronounciation for "xss" makes it worth it in the end.
14:17:55 <creikat> :)
14:18:07 <creikat> i notice that (h:t) is also used
14:18:15 <creikat> in the transpose example
14:18:28 <Anpheus__> They were clearly mistaken. They meant (y:ys). :P
14:18:47 <edwardk> Anpheus__: all the more reason to start from a.
14:19:00 <creikat> well, they are actually taking from xss.. so it should probably be x2 and x2s
14:19:19 <aristid> edwardk: i got a blasphemic question: do you actually use that Heap type elsewhere? :)
14:19:50 <edwardk> aristid: yeah quite a bit. not sure i've packaged anything for third party consumption that uses it, but i use it internally in several places
14:19:53 <pmetzger> why, when I hoogle for String -> Char, does it not give me things of that type exclusively?
14:20:02 <pmetzger> does that mean there are no such things, or is it more than that?
14:20:21 <edwardk> it started as a part of a larger exercise though
14:20:25 <aristid> edwardk: ah, nice :)
14:20:40 <aristid> no revdeps on hackage, tho
14:21:25 <hpc> pmetzger: probably both
14:21:38 <edwardk> i was working with jbapple trying to find an O(1) repeatedly splittable fingertree for workstealing purposes, and banged this out to understand one of the papers I was reading
14:22:18 <edwardk> aristid: if i measured my worth by revdeps, i'd spend all my time hacking on bytestrings ;)
14:22:37 <aristid> edwardk: would that necessarily be a bad thing? :)
14:23:06 <edwardk> aristid: well, my student this summer _is_ hacking on utf-8ifiying Data.Text... ;)
14:23:26 <aristid> jasper van der jeugt?
14:23:29 <edwardk> yeah
14:23:44 <aristid> preflex: seen jaspervdj
14:23:45 <preflex>  jaspervdj was last seen on #haskell 10 hours and 9 minutes ago, saying: Oh, no problem. There already was a slight inconsistency because I wanted to link to the thread in the web post
14:24:17 <pmetzger> is there hoogle syntax that says "show me only this type of function and show me nothing if there are none that you know"?
14:24:27 <aristid> edwardk: his (now simon meyerified) blaze-builder has seen significant traction, too
14:25:00 <gwern> pmetzger: not that I've heard of
14:25:05 <edwardk> yeah, he seemed like a good fit
14:25:07 <pmetzger> too bad
14:25:35 <hpc> perhaps try hayoo
14:26:24 <Anpheus__> pmetzger: What do you mean by "this type of function"?
14:26:50 <pmetzger> Well, at that moment, I wanted to see only results with the type String -> Char...
14:27:11 <pmetzger> which in retrospect wasn't a great thing to search for, but if it had returned nothing immediately i would have known that faster.
14:27:12 <Anpheus__> Doesn't searching for that do that?
14:27:16 <pmetzger> no. try it.
14:28:05 <Anpheus__> I see
14:28:18 <Anpheus__> it didn't find a hit so it generalized and showed you results like
14:28:24 <Anpheus__> [a] -> a and [Char] -> a and
14:28:49 <Anpheus__> I actually got more useful results by searching for [Char]->Char
14:29:37 <pmetzger> I just tried that, didn't do much better for me.
14:29:58 <Anpheus__> yeah it was only a few more hits
14:31:31 <pmetzger> what I wanted really was fewer hits so I'd realize I was looking for something too specific immediately...
14:40:39 <sciolizer> If I'm creating a Haskell function which returns a CString, and I'm foreign exporting it, how can the caller free the string when it is done with it?
14:41:09 <rata_> hi
14:42:03 <rata_> what could be wrong in the expression (fromIntegral a / fromIntegral b)? (where a and b are Integers)
14:42:35 <ezyang> :t / 
14:42:36 <lambdabot> parse error on input `/'
14:42:38 <hpc> rata_: speed, maybe?
14:42:39 <hpc> :t (/)
14:42:40 <ezyang> :t (/) 
14:42:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:42:41 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:42:55 <ezyang> Enh, could be OK, if you chose the resulting type correctly. 
14:43:00 <hpc> :t \a b -> fromIntegral a / fromIntegral b
14:43:01 <lambdabot> forall a b a1. (Integral a, Fractional b, Integral a1) => a -> a1 -> b
14:43:08 <parcs> the problem is that the resulting type is ambiguous
14:43:26 <rata_> mmm so I should declare the type?
14:43:50 <hpc> the resulting type isn't ambiguous, just polymorphic
14:43:59 <hpc> it could be ambiguous, depending on how it is used
14:44:10 <Saizan> rata_: we need more context, though you could try adding :: Double
14:44:15 <hpc> (just to make that clear)
14:44:51 <rata_> https://gist.github.com/945329
14:45:59 <rata_> :: Double doesn't help
14:46:35 <Saizan> rata_: add the error
14:47:11 <Saizan> ah, "then mixture Map.! mol" need a fromIntegral
14:47:38 <Saizan> also s/foldl/foldl'/ for decent performance
14:47:42 <crystal-cola> what's the function called "aabc" -> [(2,'a'),(1,'b'),(1,'c')]?
14:47:55 <crystal-cola> is there code??
14:48:09 <c_wraith> group
14:48:17 <c_wraith> well.
14:48:20 <c_wraith> that's not group
14:48:33 <mauke> > map (length &&& head) . group $ "aabc"
14:48:35 <lambdabot>   [(2,'a'),(1,'b'),(1,'c')]
14:48:39 <c_wraith> yeah
14:49:48 <rata_> Saizan: oh ok, thanks =)
14:49:56 <sciolizer> If I malloc something using Foreign.malloc, is it safe to free it on the C side?
14:50:37 <parcs> > map (length &&& head) . group $ "aaba" -- you may want to sort the string beforehand
14:50:38 <lambdabot>   [(2,'a'),(1,'b'),(1,'a')]
14:50:45 <ezyang> Should be OK, but it's a little poor. 
14:51:02 <ezyang> memory management is hard, don't make it even harder by crossing language boundaries ;-) 
14:51:16 <copumpkin> sciolizer: I'd export a "cleanupMyThing"
14:51:24 <copumpkin> sciolizer: then they don't have to care what kind of allocation you did
14:51:26 <ezyang> Also, be careful about different runtimes on Windows. 
14:51:35 <sciolizer> ezyang: how then do you propose that I return a string from a haskell function to c land?
14:51:49 <ezyang> sciolizer: HAskell calling C or vice versa? 
14:51:57 <sciolizer> ezyang: main is in C
14:51:57 <ezyang> do copumpkin's approach. 
14:52:07 <monochrom> sciolizer: I suppose you used newCString or newCStringLen to obtain the memory? officially you should use haskell-side's "free", but at least ghc says that's the same as c-side's "free", so you can try that
14:52:15 <creikat> how would you do the following: print all items in a list, print "No items" if there were no items in the list? Recursive function disables ability to pattern match empty list (less i keep some accumulator value with no o results), map doesn't work with different data type.
14:52:29 <ezyang> monochrom: It's still a bad idea. 
14:52:40 <mauke> creikat: different data types? what?!
14:52:55 <rata_> Saizan: the error is still there... I corrected the gist and added the error there
14:53:01 <ezyang> creikat: Did you make your own list data type? 
14:53:10 <creikat> mauke: map (print) [1, 2, 3]
14:53:21 <Saizan> creikat: f [] = putStrLn "No items"; f xs = mapM_ print xs
14:53:21 <mauke> creikat: what about it?
14:53:25 <creikat> ezyang: it's a list of strings
14:53:33 <creikat> mauke: try it
14:53:45 <mauke> creikat: ok, now what?
14:53:49 <copumpkin> creikat: you want mapM_ probably
14:53:51 <copumpkin> or sequence
14:54:17 <creikat> Saizan, copumpkin: thanks!
14:55:01 <ion> if null list then putStrLn "No items" else …, or use e.g. a case expression with pattern matching.
14:55:14 <Saizan> ?type Data.Map.foldlWithKey
14:55:15 <lambdabot> forall b k a. (b -> k -> a -> b) -> b -> M.Map k a -> b
14:55:20 <ion> Whoops, missed Saizan’s line.
14:56:37 <creikat> Why is it called mapM_? kind of odd name when you don't have the insides :)
14:56:37 <Saizan> rata_: that paste loads fine here once i add import Data.List, maybe you forgot to save your file?
14:56:52 <creikat> worked great btw
14:57:06 <rata_> Saizan: why import Data.List?
14:57:08 <creikat> by the way, don't know why i wrote btw.. never do
14:57:12 <Saizan> M because it's the monadic version, _ because it discards the result of the mapped function
14:57:19 <Saizan> rata_: for foldl'
14:57:23 <creikat> Saizan: beautiful. thanks
14:57:41 <monochrom> rata_ is like rata except that results are discarded :)
14:58:14 * monochrom waits for dcoutts_ to appear to replay this trick!
14:58:33 <aristid> preflex: seen dcoutts_
14:58:33 <preflex>  dcoutts_ was last seen on #haskell 13 hours, 11 minutes and 11 seconds ago, saying: aleator: heh
14:59:07 <rata_> Saizan: mmm it doesn't work for me
15:01:51 <Saizan> http://hpaste.org/46087/for_rata <- this is my exact code, the only change should be the import Data.List, it loads fine, and i don't think any difference like version of libs installed could matter
15:02:09 <Saizan> so, make sure you are leading the right file and things like that :)
15:02:12 <Saizan> *loading
15:11:44 <creikat> sorry about all the questions, but how do you handle concatenation of strings with many variables? are there any string interpolation functions in the basic libraries, or do you use ++?
15:11:59 <mauke> sometimes I use printf
15:12:04 <creikat> ah
15:13:35 <creikat> in the manual it says (about printf): "The return value is either String or (IO a)" how does it determine that?
15:13:44 <mauke> context
15:13:57 <mauke> do you know about overloading?
15:14:26 <navaati> :t printf
15:14:27 <lambdabot> forall r. (PrintfType r) => String -> r
15:15:00 <navaati> :t printf "lol %s mdr"
15:15:01 <lambdabot> forall r. (PrintfType r) => r
15:15:02 <monochrom> it's some type class trick
15:15:13 <mauke> when I say 'printf' I really mean http://hackage.haskell.org/packages/archive/printf-mauke/0.5.0.1/doc/html/Text-Printf-Mauke.html
15:15:36 <mauke> except for preflex, which uses its own printf lookalike
15:15:51 <xaphan> Can anyone help me decode an error when I try to build the haskell platform from a prebuilt binary for ghc?
15:15:51 <mauke> (it understands Strings and ByteStrings and nothing else)
15:16:03 <navaati> yeah, the instance of PrintfType is function of the String in parameter
15:16:23 <xaphan> http://pastebin.com/DNpJQE05  <- the error
15:16:26 <navaati> :t printf "lol %s mdr" "onche"
15:16:27 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
15:16:34 <creikat> mauke: by overloading, do you mean executing different versions of functions sharing the same name depending on arguments?
15:16:41 <mauke> creikat: yes
15:16:52 <mauke> creikat: except it's not just argument types, it's also the return type
15:16:55 <navaati> > putStrLn $ printf "lol %s mdr" "onche"
15:16:56 <lambdabot>   <IO ()>
15:17:07 <creikat> mauke: oh
15:17:20 <navaati> > printf "lol %s mdr" "onche"
15:17:21 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:17:21 <lambdabot>    `GHC.Show.Show a'
15:17:21 <lambdabot>      a...
15:17:30 <mauke> > printf "lol %s mdr" "onche" :: String
15:17:31 <lambdabot>   "lol onche mdr"
15:17:52 <navaati> yes
15:18:11 <monochrom> xaphan: you possess too many packages. I want to see your "ghc -v" and "ghc-pkg list -v"
15:18:26 <parcs> > printf "%s" "b" "c" :: String
15:18:27 <lambdabot>   "b*Exception: Printf.printf: formatting string ended prematurely
15:18:41 <navaati> when i saw this function for the first time i thought "oh very smart" :)
15:19:02 <creikat> mauke: let y = printf "%s\n" "test" :: String .. i finally got what you said :)
15:19:15 <mauke> creikat: you probably don't need the :: String
15:19:21 <mauke> depending on how you use y
15:19:41 <mauke> parcs: for the record, my printf says: "b*** Exception: Text.Printf.Mauke.printf: excess argument: "c"
15:20:12 <creikat> mauke: ok, that's clever
15:20:44 <xaphan> monochrom, alright just a second
15:20:59 <creikat> last one for the night. if i have a long string to format like ... let y = "some realy long string here %s %s" ... how do you wrap that line?
15:21:21 <mauke> "foo\   \bar" or "foo" ++ "bar"
15:21:32 <creikat> great
15:21:34 <creikat> thanks a lot
15:21:37 <creikat> i'll be quite now
15:21:39 <creikat> promise
15:21:40 <creikat> :)
15:21:43 <Zao> Quite quiet?
15:21:51 <mauke> quite rather
15:22:15 <yescalona> join #python
15:22:21 <xaphan> monochrom, http://hpaste.org/46088/ghc_v <- theres that
15:22:31 <yescalona> sorry
15:23:09 <xaphan> I tried installing this before and it didn't work so I just deleted the directory and then tried to start over but it looks like packages that have been deleted are still registered
15:23:54 <monochrom> if you want to try again quickly to "delete" again, the correct thing to delete is /home/xaphan/.ghc/x86_64-linux-7.0.3
15:24:37 <xaphan> alright thank you i'll try that
15:27:16 <crystal-cola> how do I take the last 10 characters o f astring?
15:27:26 <crystal-cola> f 3 "foobarbaz" -> "baz"
15:27:27 <crystal-cola> like that?
15:28:43 <navaati> crystal-cola: reverse then drop then reverse ?
15:28:51 <mauke> s/drop/take/
15:29:24 <NihilistDandy> That oughta work
15:29:26 <copumpkin> I kind of like the opposite of zip for that
15:29:38 <crystal-cola> takelast n = reverse . take n . reverse
15:30:51 <parcs> drop (length xs - 3) xs
15:30:53 <mauke> :t drop (length ?xs - ?n) ?xs
15:30:54 <lambdabot> forall a. (?xs::[a], ?n::Int) => [a]
15:31:23 <copumpkin> but can it be done in one pass!
15:31:34 <navaati> what the hell is this type ?
15:31:41 <copumpkin> navaati: implicit arguments
15:31:42 <mauke> glorious
15:31:49 <monochrom> it can be done in one pass with bytestring or text
15:31:57 <copumpkin> how about with lists!
15:32:08 <mauke> depends on how you count
15:32:10 <monochrom> lists don't record lengths, that's the problem
15:32:35 <mauke> you can certainly keep a rolling length n list
15:32:43 <copumpkin> pff :P
15:32:48 <monochrom> but I wonder how to pull it off with text, actually. one 16-bit word is not always one character
15:33:22 <mauke> wait, does text expose UCS-2?
15:33:27 <copumpkin> no
15:33:42 <mauke> good, otherwise I'd have to kill people
15:33:49 <copumpkin> murther!
15:34:07 <monochrom> bos cannot be killed that easily
15:34:27 <navaati> lambdabot : kill yourself
15:34:27 <copumpkin> one does not simply walk into murther
15:35:03 <navaati> doesn't work, thanksfully
15:35:15 <shachaf> Is bos the final boss of #haskell?
15:35:31 <monochrom> no, shapr is
15:35:35 <damg> iddqd
15:36:03 <monochrom> oh bother, text's length is O(n). end of dream
15:42:44 <rata_> thanks a lot Saizan!! =)
15:42:59 <rata_> I was putting the fromIntegral in a wrong place
15:43:01 <dafis> preflex: seen hamishmack
15:43:02 <preflex>  hamishmack was last seen on #haskell 12 hours, 46 minutes and 3 seconds ago, saying: PeakerWork: The reason I ask is that earlier versions used "runhaskell Setup configure"
15:46:08 <monochrom> yeah, text has to search linearly for surrogates and adjust the length correctly, it's O(n) down to individual words, not just the bytestring kind of "O(n)" that really is n/65536
15:47:12 <pmetzger> If I'm appending a character onto a string, is there a better idiom than str ++ x:[] ?
15:47:24 <pmetzger> it feels a little clunky but I suppose that's me being silly.
15:47:35 <Zao> pmetzger: Not without changing type.
15:47:35 <hpc> pmetzger: are you doing this lots of times?
15:47:47 <pmetzger> not a lot, no.
15:48:03 <monochrom> append char to string: string ++ [char]. note it's slow. re-think your whole approach
15:48:18 <monochrom> alright, doing it once in a blue moon is fine
15:48:26 <hpc> it is O(length string)
15:48:32 <pmetzger> I know, strings are lists
15:48:39 <pmetzger> and I'm creating a new one each time
15:48:58 <hpc> if you are building a whole string that way from scratch, the time is O(length string ^ 2)
15:49:09 <hpc> in which case, you want to use difference lists
15:49:23 <pmetzger> in this instance (in a toy parser I'm building for learning) I'm accumulating the contents of an identifier or string while lexing
15:49:51 <pmetzger> I suppose the thing to do would be to hit the end of the thing and do the construction in the other direction, back to front
15:50:00 <pmetzger> that is, the efficient thing
15:50:17 <pmetzger> but it feels like a premature optimization. still, maybe that would be a good learning exercise anyway
15:50:21 <hpc> pmetzger: http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html
15:51:26 <pmetzger> hpc: very cool. how does this work internally?
15:51:46 <hpc> pmetzger: data DList a = DL {unDL :: [a] -> [a]}
15:51:46 <pmetzger> (part of what I'm trying to do here is learn rather than simply implementing quickly...)
15:52:11 <hpc> pmetzger: appendString :: DList a -> [a] -> DList a
15:52:29 <hpc> pmetzger: appendString (DList f) xs = DList (f . (++ xs))
15:52:42 <pmetzger> I should probably RTFS. :)
15:52:44 <hpc> if you are interested in theory, it is a specialized endofunctor
15:52:46 <hpc> :P
15:52:48 <pmetzger> before you type it all in. :)
15:53:05 <pmetzger> I know functors, and have no idea what an endofunctor is. :)
15:53:11 <hpc> @src Endo
15:53:11 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:53:14 <hpc> argh
15:53:28 <hpc> data Endo a = Endo {appEndo :: a -> a}
15:53:54 <c_wraith> Wouldn't that one probably be a newtype?
15:53:55 <hpc> it's a type for functions from a type to itself
15:54:10 <hpc> c_wraith: yeah, but i forget if it is or not
15:54:22 <hpc> and too lazy to try and remember
15:54:33 <c_wraith> I just can't see a use case for wanting an extra bottom.
15:55:02 <hpc> pmetzger: endofunctors are a monoid where mempty = id, mappend = (.)
15:55:47 <hpc> (i just noticed, i use "where" a lot when talking about haskell, but never when coding)
15:55:48 <pmetzger> I will have to put learning why these are interesting into the (long now) queue. :)
15:55:53 <parcs> DLists keep track of the consecutive differences between intermediate lists and a newer list until the very end, at which point it constructs the final list by efficiently appending all the differences
15:56:13 <parcs> if that makes sense…
15:56:16 <hpc> pmetzger: don't worry, you'll get back to it when you are ready
15:56:22 <hpc> it's a fairly easy thing to bump into
15:56:47 <pmetzger> I could also just build up my string or identifier by consing and do a reverse in the last step. :)
15:56:48 <parcs> s/a newer list //
15:57:06 <pmetzger> that only just occurred to me but since I'm strictly adding to the end as I consume chars from the input stream...
15:57:32 <hpc> pmetzger: now that you mention it, i remember there's a blog post about that, which benchmarked dlist and reversed consing
15:57:43 <hpc> and they came out to be within .01 seconds of each other
15:57:44 <pmetzger> hURL?
15:58:50 <hpc> http://logicaltypes.blogspot.com/2008/08/difference-lists-in-haskell.html -- pmetzger, read comments
15:59:05 <hpc> er, wrong one
15:59:05 <pmetzger> thanks much!
15:59:13 <pmetzger> er okay...
15:59:37 <hpc> well, it makes a good point about dlist making more sense than reverse :P
15:59:44 <edwardk> hpc: doh, i was sad when i lost the post he linked to on my blog =/
15:59:55 <hpc> edwardk: :/
16:00:23 <hpc> i need to write more on mine
16:01:06 <acowley> I don't buy that argument
16:01:31 <acowley> that is to say, I've never had a problem with knowing where to put a reverse in a cons-and-reverse setup
16:02:10 <c_wraith> the advantage to the DList style setup is that it can generate the list lazily
16:02:12 <acowley> if it doesn't recurse, reverse
16:02:22 <c_wraith> cons and reverse has to have the whole list in memory
16:02:57 <pmetzger> I probably need (in my application) to have the whole list in memory anyway. and they're small, so really this is mostly an exercise for me as it stands.
16:04:01 <pmetzger> (I'm playing with a parser for EBNFs, entirely as an exercise, though who knows, maybe I'll do something with it like computing if the language is LL(1) and what the director sets are or something.)
16:05:06 <pmetzger> (that is to say, I'm parsing the language of EBNF grammars. Nice and short, only five productions.)
16:05:53 <pmetzger> (and trying to incrementally improve how the code looks and functions to learn better technique.)
16:08:36 <navaati> > mzero :: String
16:08:37 <lambdabot>   ""
16:09:00 <hpc> :t ($ mempty)
16:09:01 <lambdabot> forall a b. (Monoid a) => (a -> b) -> b
16:12:52 <pmetzger> hrm. speaking of efficiency, so I had this as my Id lexing routine:
16:12:58 <pmetzger> parseTokId str = (TokId idstr , rest)
16:12:59 <pmetzger>   where (idstr, rest) = span isLetter str
16:13:05 <navaati> what does mean "injective" ?
16:13:07 <pmetzger> is using span for this inefficient?
16:13:41 <pmetzger> navaati: http://en.wikipedia.org/wiki/Injective_function
16:14:01 <hpc> navaati: injective means when we try to solve the equation f(x) = y, every value of x has exactly one corresponding y value
16:14:13 <hpc> surjective means every y value has exactly one corresponding x
16:14:16 <hpc> bijective means both
16:14:27 <acowley> surjective means *at least* one
16:14:27 <Cale> Or: injective means that whenever f x = f y, then x = y
16:14:42 <hpc> acowley: no, surjective means reverse domain and target
16:14:47 <Cale> Or: whenever x /= y, we have f x /= f y
16:14:58 <monochrom> (injective means monic, surjective means epic :) )
16:15:08 <crystal-cola> f injective can also mean that there exists g such taht g . f = id
16:15:10 <shaleh> Looking for style guidance. If I have a function which takes an Either and returns an Either what is the preferred way to pass the Left along if I do not want to change it?
16:15:10 <crystal-cola> ?
16:15:16 <crystal-cola> can surjective be done taht way?
16:15:18 <Cale> A function f: X -> Y is surjective when for every y in Y there exists some x in X such that f x = y
16:15:27 <crystal-cola> lik ef surjective if f . g = id??
16:15:30 <hpc> shaleh: fmap?
16:15:40 <hpc> > fmap (+1) (Left 5)
16:15:40 <lambdabot>   Left 5
16:15:42 <pmetzger> I think we've overwhelmed navaati with answers.
16:15:43 <hpc> er
16:15:43 <acowley> hpc: I don't think so
16:15:59 <rata_> ?type fmap
16:15:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:16:02 <hpc> http://en.wikipedia.org/wiki/Surjective_function
16:16:13 <hpc> wait, crap
16:16:14 <ddarius> crystal-cola: Every epi is split is the axiom of choice.
16:16:18 <acowley> yes?
16:16:18 <hpc> i got them backwards
16:16:40 <pmetzger> meanwhile I didn't learn about whether "span isLetter" is efficient to create an ( identifier, restofstring) pair....
16:16:41 <navaati> ok thank you all
16:16:49 <hpc> er
16:16:52 <pmetzger> is it? 
16:16:52 <hpc> dammit
16:17:11 <shaleh> hpc: Hmm, I want to look at the contents with the Right and may throw my own Left based on them. fmap seemed messy for that
16:17:11 <pmetzger> I should probably read how span is implemented.
16:17:20 <Saizan> pmetzger: it's O(length identifier)
16:17:28 <hpc> okay, i was definitely taught the wrong thing for surjective
16:17:30 <pmetzger> it would be hard to do better.
16:17:37 <Saizan> yeah
16:18:00 <Eduard_Munteanu> crystal-cola: that's more like sections and retracts
16:18:22 <acowley> #haskell is here to disabuse misconceptions and overwhelm simple questions with overly ornate answers!
16:18:29 <Saizan> shaleh: you want (>>=) then
16:18:41 <pmetzger> I'd span to parse a "string" as well, but unfortunately it can contain a \" that would throw span off...
16:19:22 <pmetzger> I wonder if there is a trick I could do there. hrm. haven't thought a lot about the various standard list functions enough.
16:19:46 <shaleh> so something like func >>= (\x -> if cond x then return x else Left "foo")??
16:20:00 <hpc> acowley: so injective means the domain is covered, and surjective means the target is covered
16:20:08 <hpc> er
16:20:15 <hpc> whatever
16:20:24 <Eduard_Munteanu> The domain is always covered, since functions must be total.
16:20:28 <hpc> argh, too confused to think
16:20:38 <litb> lol
16:20:54 <acowley> injective means that for every y, there is no more than one x
16:21:02 <litb> a function can be partial. div(x, 0) has no defined value
16:21:07 <acowley> but there might be no x that gets mapped to a particular y
16:21:16 <Eduard_Munteanu> Not a function in the math sense, perhaps a plain relation.
16:21:18 * hackagebot procstat 0.1 - get information on processes in Linux  http://hackage.haskell.org/package/procstat-0.1 (PatrickPalka)
16:21:21 <acowley> surjective means every y has an x
16:21:25 <hpc> oh, i was thinking in the context of haskell
16:21:38 <hpc> if a haskell function is defined for an input, it can only have one output
16:21:40 <crystal-cola> and injective means every x has a y
16:21:41 <acowley> I don't believe in division
16:21:42 <litb> a function by definition can only have one y for every x
16:21:42 <hpc> excluding unsafes
16:21:53 <hpc> so total implies injective
16:21:56 <Eduard_Munteanu> Injective indeed means one can construct a pseudoinverse, in the sense that its domain is restrcited.
16:21:57 <acowley> no
16:22:06 <acowley> we're getting worse!
16:22:15 <Saizan> total doesn't imply injective.
16:22:15 <acowley> totality means every x has a y
16:22:16 <hpc> lol
16:22:26 <acowley> injective means no y has more than one x
16:22:40 <acowley> surjective means every y has at least one x
16:22:50 <hpc> oh
16:23:02 <acowley> bijective means both: every y has exactly one x
16:23:04 <hpc> oh, that is kind of obvious now
16:23:19 <hpc> i can't believe i have been wrong about that for so long
16:23:31 <pmetzger> injections at the doctors office hurt a little. surjections at a doctor's office implies the doctor is a math PhD, not an MD, and should not be practicing medicine.
16:23:35 <acowley> it is hard to keep straight in one's head
16:23:39 <Eduard_Munteanu> So another way to think of it is injectivity and surjectivity imply the underlying inverse _relation_ is a function.
16:23:46 <acowley> bijections mean you're getting a refund
16:23:55 <hpc> haha
16:24:32 <crystal-cola> bijection means f = f^-1
16:24:43 <hpc> crystal-cola: not necessarily
16:24:44 <alpounet> or not.
16:24:49 <litb> bijective function means total 1:1
16:24:53 <alpounet> this is involution crystal-cola 
16:25:01 <hpc> bijection means there exists an f^-1
16:25:16 <Eduard_Munteanu> That'd be id I think
16:25:21 <Eduard_Munteanu> (only id?)
16:25:26 <hpc> (+1,-1) are a bijection
16:25:33 <ddarius> Eduard_Munteanu: not
16:25:36 <hpc> Eduard_Munteanu: (**-1) is a bijection
16:25:43 <Eduard_Munteanu> I mean f = f^-1
16:25:49 <hpc> assuming 0 isn't in the domain or range
16:25:54 <alpounet> Eduard_Munteanu, symetries
16:26:22 <acowley> Eduard_Munteanu: flipping the sign, or inverting a rational (NO ZEROS!), etc.
16:26:32 <ddarius> pmetzger: You can be a mathematician and a practicing doctor.
16:26:42 <Eduard_Munteanu> Wait no it merely implies f^2 = id.
16:26:57 <hpc> ddarius: but probably not a practicing medical doctor :P
16:26:58 <ddarius> Eduard_Munteanu: Which is the definition of an involution.
16:27:06 <pmetzger> ddarius: I know an MD with a PhD in math, but he never practiced medicine.
16:27:15 <litb> practicing medical doctors can  be mathematicians too
16:27:37 <Eduard_Munteanu> Ah, I was merely putting that under idempotence in the general sense I suppose.
16:27:48 <ddarius> idempotence is f . f = f
16:27:59 <Eduard_Munteanu> crap, nilpotence :)
16:28:32 <ddarius> This is a somewhat odd context for the terminology "nilpotence."
16:28:33 <Eduard_Munteanu> a^2 = 0
16:28:35 <hpc> haha, im not the only one failing at math today
16:28:47 <Eduard_Munteanu> (where for composition 0 is id)
16:28:52 <pmetzger> I would be scared to be treated by a combination practicing MD and math PhD. What if he forgot which hat he was wearing on a particular day and applied the Banach-Tarsky paradox to me?
16:29:06 <ddarius> pmetzger: There would be two of you.
16:29:15 <pmetzger> it could be very inconvenient. of course, I'm not topologically spherical.
16:29:25 <pmetzger> but still, I'm sure some analog must exist for toroi.
16:29:46 <ddarius> At any rate, you could just make sure he's a constructivist.
16:29:48 <Eduard_Munteanu> pmetzger: imagine a surgeon cutting a heart in such a way to make two of them... free transplantation :P
16:30:03 <hpc> pmetzger: it's fine if he goes banach-tarsky on you, but make sure he doesn't make both of you play the prisoners' dillema
16:30:09 <hpc> dilemma
16:30:16 <hpc> @wn dilemma
16:30:18 <lambdabot> *** "dilemma" wn "WordNet (r) 2.0"
16:30:18 <lambdabot> dilemma
16:30:18 <lambdabot>      n : state of uncertainty or perplexity especially as requiring a
16:30:18 <lambdabot>          choice between equally unfavorable options [syn: {quandary}]
16:30:22 <hpc> :D
16:30:27 <pmetzger> a combination set theorist and game theorist would be very dangerous indeed in that respect.
16:30:45 <Eduard_Munteanu> di-lemma, bi-functor... /me wonders if there is an etymological connection
16:30:55 <pmetzger> of course, I could reasonably expect my clone to follow exactly the same strategy as me and not defect.
16:30:58 <Eduard_Munteanu> Maybe not.
16:31:05 <hpc> bi-functor really is a two-functor though
16:31:10 <hpc> di-lemma isn't half a lemma
16:31:23 <pmetzger> it is two horns, not half of one.
16:31:33 <hpc> oh wait
16:31:37 <hpc> it's a double proposition
16:31:41 <hpc> yay wikipedia
16:31:44 <pmetzger> yes.
16:31:57 <pmetzger> two horns. dilemma
16:31:58 <hpc> and now i know what lemma means
16:32:02 <pmetzger> horn
16:32:06 <Eduard_Munteanu> Oh.
16:32:40 <hpc> i want to use rhinos in a math paper now
16:32:45 <hpc> just so i can use the rhino lemma :P
16:32:45 <ddarius> Eduard_Munteanu: The prefixes both mean "two" albeit one in Greek and the other in Latin.
16:32:56 <hpc> latin pun ftw
16:33:01 <Eduard_Munteanu> It usually means "this is an uninteresting theorem" or "I think this has limited use, but hey it doesn't after all" :)
16:33:09 <shaleh> Saizan: I ended up with this => evalRPN input = (foldM evalRPN [] . words) input >>= validateStack
16:33:17 <Eduard_Munteanu> Yeah I know that, I wondered if it was indeed a prefix.
16:33:21 <Eduard_Munteanu> in dillema
16:33:24 <hpc> Eduard_Munteanu: it also means "i am just using this to get to a cooler point later"
16:33:41 <shaleh> Saizan: bah, should be evalRPN' after the foldM
16:33:46 <ddarius> Eduard_Munteanu: In "dilemma" of course it is.  "Lemma" in a word.
16:34:56 <Eduard_Munteanu> Arguably some lemmas are pretty much essential theorems, like Yoneda's, Zorn's etc.
16:35:11 <dafis> Ahlfors'
16:35:33 <pmetzger> "The Axiom of Choice is obviously true, the well-ordering principle obviously false, and who can tell about Zorn's lemma?"
16:36:01 <dafis> pmetzger:  why would well-ordering be obviously false?
16:36:18 <xplat> Zorn's lemma might not even be a theorem, never mind a lemma
16:36:26 <xplat> depends which thing you assume
16:36:44 <Eduard_Munteanu> Unless one considers theorems to be concrete results about specific facts, as in the case of Yoneda being used to prove other stuff.
16:36:48 <shaleh> next newbie question. How do I catch Control-D so this "<stdin>: hGetLine: end of file" is not printed on exit?
16:37:13 <pmetzger> control-d on unix is not a character in the stream
16:37:19 <parcs> :t catch
16:37:20 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:37:22 <pmetzger> it is just a way of telling the tty to end the file.
16:37:22 <parcs> :D 
16:37:31 <hpc> :t isEOF
16:37:31 <lambdabot> Not in scope: `isEOF'
16:37:36 <Eduard_Munteanu> You'd catch EOF / broken pipe, I'm unsure.
16:37:36 <hpc> @hoogle EOF
16:37:36 <lambdabot> Text.Read EOF :: Lexeme
16:37:36 <lambdabot> Language.Haskell.Lexer EOF :: Token
16:37:36 <lambdabot> Text.Read.Lex EOF :: Lexeme
16:37:44 <acowley> @seen djahandarie
16:37:44 <lambdabot> Unknown command, try @list
16:37:44 <preflex>  djahandarie was last seen on #haskell 3 hours, 32 minutes and 36 seconds ago, saying: * djahandarie wonders how that works
16:37:47 <parcs> @hoogle isEOF
16:37:47 <lambdabot> System.IO isEOF :: IO Bool
16:37:47 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
16:37:47 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
16:38:01 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hIsEOF
16:38:09 <parcs> so possibly a combination of catch and isEOFError will do
16:38:17 <hpc> also isEOF, which works on stdin
16:38:28 <ddarius> "Lemma" is just the mathematician's word for "subroutine."  Some subroutines are more handy than the program's that they're a part of.
16:38:46 <Eduard_Munteanu> Mm, nice way to put it.
16:38:57 <hpc> i like it
16:39:10 <djahandarie> acowley, yo yo
16:39:13 <parcs> @hoogle hIsEof
16:39:13 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
16:39:19 <parcs> maybe this too…
16:39:22 <hpc> it reminds me of a trick i used to exploit in math classes when i was in middle school
16:39:31 <acowley> djahandarie: I wanted to use Newtype to do something but I've gotten myself confused
16:39:34 <hpc> when you are doing algebra, assuming the first equation is correct, so are all the rest
16:39:47 <acowley> djahandarie: suppose I have a [Maybe Int]
16:39:54 <hpc> so you can use that to sort of cheat your way through multi-step problems
16:40:06 <acowley> djahandarie: I can write appEndo (mconcat $ map (foo . fmap (Endo . (+))) test) 1
16:40:11 <acowley> where test is my [Maybe Int]
16:40:32 <acowley> (this is just an example, and I'm not really trying to sum the numbers)
16:40:55 <acowley> so I have a bunch of maybes, and I want to turn them into functions then compose those functions
16:41:06 <acowley> and I thought I could use ala Endo for this
16:41:13 <acowley> but I can't cut through everything all at once
16:41:26 <acowley> I should say, I haven't figured out how to do so yet
16:41:37 <hpc> :t ala Endo
16:41:37 <lambdabot> forall a b n' o'. (Newtype n' o') => (((a -> a) -> Endo a) -> b -> n') -> b -> o'
16:41:52 <Eduard_Munteanu> :t ala
16:41:53 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
16:42:26 <acowley> err, I also used a function "foo" there that is Monoid a => Maybe a -> a
16:43:11 <ddarius> Aka crush{Maybe}
16:43:39 <hpc> crush?
16:43:44 <Eduard_Munteanu> from Coq?
16:44:05 <Eduard_Munteanu> Though I hardly see any connection. :/
16:44:09 <ddarius> @google "generic programming" crush
16:44:10 <lambdabot> http://hackage.haskell.org/packages/archive/regular/0.3.1/doc/html/doc-index.html
16:44:10 <lambdabot> Title: regular-0.3.1: Generic programming library for regular datatypes. (Index)
16:44:57 <ddarius> Someone's being fancy there.
16:45:35 <djahandarie> acowley, appEndo (mconcat $ map (foo . fmap (Endo . (+))) test) 1    =>    appEndo (mconcat $ fmap (foo . fmap (Endo . (+))) test) 1     =>    appEndo (foldMap (foo . fmap (Endo . (+))) test) 1   =>    ala' Endo foldMap (\x -> foo . fmap (x . (+))) test) 1  -- I think
16:45:44 <pmetzger> why in a pattern is ls@(x:xs) okay but not ls@x:xs? (I understand that it isn't acceptable, I'm interested in why)
16:46:04 <Eduard_Munteanu> pmetzger: because x:xs isn't okay
16:46:18 <ddarius> ls@x:xs is a pattern
16:46:44 <djahandarie> Oh wait, messed up the parenthesis there I think
16:46:59 <Eduard_Munteanu> You'd need either (ls@x:xs) or ls@(x:xs), arguably you need the latter.
16:47:15 <pmetzger> why isn't x:xs okay, that's the core I suppose.
16:47:42 <pmetzger> I think the real problem is that I don't actually understand the pattern language, I only have been cargo culting along.
16:47:43 <Eduard_Munteanu> Matching on constructors needs to be done inside paranthesis.
16:48:06 <Eduard_Munteanu> Well, except stuff like   f One = ...
16:48:07 <ddarius> pmetzger: x:xs is fine
16:48:20 <ddarius> > let x:xs = "hi" in (x,xs)
16:48:21 <lambdabot>   ('h',"i")
16:48:44 <monochrom> in a suitable context, you need more parentheses. this is not news.
16:48:47 <ddarius> pmetzger: It's not patterns that you need to understand.  It's parsing.
16:48:57 <navaati> > let l@x:xs = "hi" in (x,xs,l)
16:48:58 <lambdabot>   ('h',"i",'h')
16:48:59 <djahandarie> acowley, I messed up on that last step, the test should be outside that lambda
16:49:00 <ezyang> I wonder if you could make the parser understand f x:xs w/o introducing a conflict. 
16:49:06 <navaati> > let l@(x:xs) = "hi" in (x,xs,l)
16:49:07 <lambdabot>   ('h',"i","hi")
16:49:18 <pmetzger> ddarius: I suspect both patterns and parsing.
16:49:22 <Eduard_Munteanu> Well, at least in function definitions I'm pretty sure you can't do stuff like   f x:xs = ...
16:49:26 <ddarius> ezyang: What if we want higher order (pattern) unification down the line?!
16:49:29 <pmetzger> I know far too little. :)
16:49:33 <ddarius> pmetzger: Probably.
16:49:41 <ezyang> oh my! 
16:49:48 <pmetzger> this comes from only having really used a language for a couple of weeks.
16:49:56 <monochrom> the pattern language includes the parenthesizing language, of course
16:50:01 <pmetzger> actually, make that "only having done more than read about a language for..."
16:50:04 <ddarius> Eduard_Munteanu: That parses as (f x):xs = ... which is only a problem because f isn't a constructor.
16:50:18 <pmetzger> ddarius: aha! now that makes some sense to me.
16:50:20 <acowley> djahandarie: that leaves me with something that doesn't type check: ala' Endo foldMap (\x -> foo . fmap (x . (+))) [Nothing, Just 2] 1
16:50:23 <Eduard_Munteanu> Ah, makes sense then.
16:50:47 <pmetzger> is the l@x:xs issue similarly a precedence issue of sorts?
16:50:52 <ddarius> > let Just x:xs = [Just 3, Nothing] in (x,xs)
16:50:53 <lambdabot>   (3,[Nothing])
16:50:59 <ion> > let x:l@xs = "hi" in (x,xs,l)
16:50:59 <lambdabot>   ('h',"i","i")
16:51:07 <pmetzger> ah, it would be, okay.
16:51:24 <ezyang> Another reason is it keeps grouping consistent on the lhs and rhs of equations. 
16:51:26 <ddarius> > let a@b@c@d@e = 1 in (a,b,c,d,e)
16:51:26 <ion> > let y@x:ys@xs = "hi" in (x,y,xs,ys)
16:51:27 <lambdabot>   (1,1,1,1,1)
16:51:27 <lambdabot>   ('h','h',"i","i")
16:52:20 <ion> > let a@_ = 42 in a
16:52:21 <lambdabot>   42
16:52:59 <ion> > let a@_'_'_'_'_'_'_'_'_'_'_'_'_'_'_'_'_'_' = 42 in a
16:53:00 <lambdabot>   42
16:53:10 <pmetzger> so here is a similar pattern question:
16:53:20 <ddarius> > let ord'x' = ord 'x' in ord'x'
16:53:20 <lambdabot>   120
16:53:27 <pmetzger> why is foo acc 'h':xs = ... not okay
16:53:36 <pmetzger> but foo acc ('h':xs) = ... okay?
16:53:37 <ezyang> parens. 
16:53:38 <mauke> pmetzger: precedence
16:53:40 <ion> That means (foo acc 'h'):xs
16:53:40 <pmetzger> I presume this is similar.
16:53:47 <pmetzger> Ah, gotcha!
16:53:51 <pmetzger> now that makes sense.
16:54:02 <pmetzger> application is highest precedence
16:54:07 <mauke> Just x : xs = ... is ok
16:54:07 <ion> yes
16:54:08 <pmetzger> so it nukes the : operator
16:54:20 <pmetzger> thanks!
16:54:23 <ddarius> The rules of the pattern syntax are exactly the same as the expression syntax.
16:54:37 <mauke> it's a bit like C declarations, only sane
16:54:40 <pmetzger> I understand parsing better. I still don't quite get everything in patterns, but I'll just have to read more.
16:54:46 <pmetzger> There is nothing sane about C decls. :)
16:55:12 <pmetzger> ever try to declare a variable that can be assigned a function that takes a function and returns a function?
16:55:13 <ddarius> > let ~(!(~(Just x))) = Nothing in 3
16:55:14 <lambdabot>   3
16:55:18 <pmetzger> (in C)
16:55:19 <mauke> pmetzger: yes
16:55:23 <mauke> it's not even hard
16:55:34 <pmetzger> it isn't hard, it is just utterly unparsable without spending time on it
16:55:43 <mauke> pmetzger: just follow these simple rules: http://mauke.dyndns.org/stuff/c/how-to-declare.txt
16:55:48 <ddarius> Use typedefs and everyone is happy.
16:55:55 <mauke> ddarius: I won't if you use them wrong
16:56:03 <mauke> (hiding pointers behind typedefs is wrong)
16:56:21 <pmetzger> the rules are straightforward, it is just disgusting in the end. :)
16:56:41 <ddarius> mauke: I'm a C++ programmer anyway.
16:56:43 <Eduard_Munteanu> typedefs are pretty common for declaring callback pointers.
16:56:57 <mauke> ddarius: then add an extra rule for references and (&var) :-)
16:57:36 * ddarius hugs placement new.
16:57:41 <navaati> oh, I saw one day a notation ~(a pattern), what does it mean ?
16:57:46 <mauke> now that's fucked up syntax
16:57:55 <mauke> navaati: that's a lazy pattern
16:58:02 <mauke> it never fails
16:58:02 <Eduard_Munteanu> navaati: they're called irrefutable patterns
16:58:18 <Eduard_Munteanu> Or lazy annotations yeah.
16:58:42 <mauke> > case [] of ~(x : xs) -> "o hai"
16:58:42 <lambdabot>   "o hai"
16:58:53 <mauke> > case [] of ~(x : xs) -> "o hai" ++ xs
16:58:55 <lambdabot>   "o hai*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed fo...
16:59:10 <Eduard_Munteanu> Basically for pattern matching to work, you do have to be a little strict, otherwise you couldn't look into it.
17:00:28 <Eduard_Munteanu> (Or that's how I understand it)
17:00:52 <mauke> preflex: cdecl int (*(*p)(int (*)(void)))(void)
17:00:53 <preflex>  p: pointer to function(pointer to function(void) returning int) returning pointer to function(void) returning int
17:01:31 <Eduard_Munteanu> That looks like RPN / Lisp :P
17:02:03 <ddarius> Eduard_Munteanu: Well?  Is it reverse or not?
17:02:10 <mauke> blame C precedence and * being a prefix operator
17:02:26 <Eduard_Munteanu> No, I mean that load of parens
17:02:27 <djahandarie> acowley, I imagine there is a reason that this Endo . (+) needs to be applied before the foo?
17:02:50 <ion> Parentheses and RPN_
17:02:52 <ion> ? even
17:02:59 <navaati> with RPN you don't need any parens
17:03:00 <ddarius> Lisp = Polish Notation (+ parens - arity)
17:03:05 <djahandarie> acowley`, I imagine there is a reason that this Endo . (+) needs to be applied before the foo?
17:03:19 <mauke> preflex: calc (2 2 +) * (+ 3 3)
17:03:19 <preflex>  24
17:03:31 <navaati> > case [] of ~(x : xs) -> "o hai" ++ xs
17:03:32 <lambdabot>   "o hai*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed fo...
17:03:36 <Eduard_Munteanu> Anyway I was hinting to how humans write that sort of stuff.
17:03:39 <ddarius> mauke: Your mother would be proud.
17:03:42 <navaati> > take 3 $ case [] of ~(x : xs) -> "o hai" ++ xs
17:03:43 <lambdabot>   "o h"
17:03:50 <navaati> yeah \o/
17:03:54 <mauke> (the hidden joke here is that while preflex is written in haskell, both "cdecl" and "calc" are C modules)
17:04:09 <acowley`> djahandarie: I'm mapping the (Endo . (+)) over the Maybes to get a list of Maybe (Endo Int), 
17:04:49 <acowley`> djahandarie: I think the issue is that I have several things happening: I want Nothings to turn to identity functions, and Justs to turn into other functions, then compose the whole chain.
17:04:55 <ddarius> mauke: Haskell is better at IRC bots than C, and C is better at parsing.
17:05:08 <mauke> heh
17:05:10 <djahandarie> acowley`, the issue is the order. Can that be written Endo . (+) . foo? It can in the case of summing
17:05:28 <Eduard_Munteanu> If you write it yourself, it's probably pissy to do in straight C.
17:05:41 <Eduard_Munteanu> But with Yacc and Lex it's nicer.
17:05:49 <navaati> good night
17:06:44 <acowley`> djahandarie: I think I've confused things by using foo
17:07:01 <acowley`> djahandarie: foo Nothing = mempty
17:07:17 <fryguybob> ezyang: small typo on your latest blog post 4th paragraph "wrapepd"
17:07:18 <acowley`> so I don't think I can apply (+) to that
17:07:23 <mauke> I haven't yet found a nice functional formulation of the parsing algorithm
17:08:11 <mauke> hmm
17:08:30 * hackagebot pez 0.0.4 - A Potentially-Excellent Zipper library  http://hackage.haskell.org/package/pez-0.0.4 (BrandonSimmons)
17:08:49 <mauke> data Node a = Value a | Unary UnOp Node | Binary BinOp Node Node
17:08:52 <mauke> this could actually work
17:09:19 <pmetzger> is there a simple way to pretty print an array? (I guess I should ask hoogle...)
17:09:39 <mauke> data Node a = Value a | Unary Int UnOp Node | Binary Int BinOp Node Node; type PNode = Node ()
17:09:44 <pastorn> pmetzger: you could generate the list of all indices, right?
17:09:54 <pmetzger> I meant lists actually. braino.
17:10:01 <pastorn> oh
17:10:04 <mauke> insert :: PNode -> PNode -> PNode
17:10:11 <pastorn> pmetzger: 'mapM print myList'
17:10:15 <pastorn> wait
17:10:20 <pastorn> mapM_ print myList
17:10:22 <ion> class (Show a) => ShowPretty a where showPretty = show, anyone? :-P
17:10:22 <djahandarie> > let foo = fromJust; test = [Just 1, Just 2] in ala' Endo Data.Foldable.foldMap ((+) . foo) test id 1     -- acowley`, only if    foo . fmap (Endo . (+))   <=>    Endo . (+) . foo
17:10:24 <lambdabot>   4
17:10:55 <pastorn> @type mapM_ -- pmetzger 
17:10:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:10:57 <acowley`> yeah, so my Maybe -> Monoid is getting in the way
17:11:09 <pastorn> @type print
17:11:10 <lambdabot> forall a. (Show a) => a -> IO ()
17:11:51 <ion> Hm, that wouldn’t handle pretty indentation. Back to the drawing board.
17:12:01 <djahandarie> acowley`, I don't think ala can do it in your case then... unless you seriously funk around with with foldMap you pass in, in which case I think it's possible
17:12:31 <pastorn> pmetzger: does it work?
17:12:39 <acowley`> djahandarie: okay, thanks. It seemed quite close to what ala can do, but I couldn't piece it together.
17:12:47 <pmetzger> haven't tried. I'm still reading and digesting several things.
17:13:06 <djahandarie> acowley, I'll think about this more when I'm not doing homework :)
17:13:14 <acowley> djahandarie: what class?
17:14:07 <ezyang> "However, if you want a pure functional programming language, you're forced to adopt fairly difficult mechanisms like monads, etc" 
17:14:12 <pmetzger> pastorn: very much not what I thought of as "pretty printing" unfortunately. :|
17:14:13 <djahandarie> It is quite possibly the most mundane and stupid homework: proving various things about naive set theory. The class is Intro to Discrete Math. 
17:14:14 <ezyang> It's so hard for me to remember the time when monads were hard :-/ 
17:14:27 <acowley> I never took such a class and wish I had :/
17:14:34 <acowley> so I do your homework on weekends :((((
17:14:36 <ezyang> djahandarie: Is it so trivial that you don't even know how to prove it? Happens to me sometimes... 
17:14:50 <acowley> ezyang: those are my favorites
17:14:54 <djahandarie> ezyang, hah.
17:14:57 <ezyang> fryguybob: Fixored! 
17:15:14 <Saizan> "refl"
17:15:15 <acowley> ezyang: because when I eventually figure it out, I excitedly tell my wife, and, as I'm explaining it it becomes apparent that I've proved everything about nothing
17:15:19 <fryguybob> ezyang: Excellent series by the way!
17:15:22 <pastorn> pmetzger: well, that uses the 'Show' instances... what you should do for your datatype (let's call it D) should be a function 'prettyD :: D -> String' and then do 'mapM_ (putStrLn . prettyD) myDList'
17:15:37 <djahandarie> Saizan, heh. I don't know if my TA would appreciate that.
17:16:17 <djahandarie> The fact that some random dude is grading this homework prevents me from having fun with it too
17:17:08 <ion> Prettyprinting data structures usually involves splitting them into separate lines at appropriate points if they contain multiple items and indenting the structure properly.
17:17:33 <pmetzger> ezyang: I still find monads a little non-intuitive. give me a few weeks.
17:18:05 <c_wraith> pmetzger: amusingly, you're likely to figure out the intuition behind monads before you see exactly how the formalism works :)
17:18:30 * hackagebot hfusion 0.0.4 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.4 (FacundoDominguez)
17:18:35 <pastorn> ezyang: monads not hard anymore? think about ContT for a while
17:18:53 <mauke> a monad is a type constructor T together with 3 functions, η :: a -> T a; fmap :: (a -> b) -> T a -> T b; join :: T (T a) -> T a
17:19:03 <ezyang> Hmm. I can write out Cont from memory. I wonder if I can derive ContT. 
17:19:19 <Igloo> c_wraith: Isn't that true by definition? If you don't have any intuition, then you don't really understand a formalism, do you?
17:19:22 <pastorn> ezyang: glhf... i'll be sleeping when you're done :p
17:19:22 <pmetzger> mauke: nice use of an inline eta there. :)
17:19:28 <danharaj> oh boy adding and subtracting type families from classes
17:19:30 <danharaj> type surgery :p
17:19:45 <pmetzger> or should I say η
17:20:10 <pastorn> pmetzger: have you played around with getLine/putStrLn programs?
17:20:11 <c_wraith> Igloo: well, you can automatically apply a formalism without understanding it.  My ability to do that with monads came *after* figuring out the intuition
17:20:13 <ezyang> I guess monads as a technical concept scare people off a little bit, but that's not really the important bit. 
17:20:22 <pmetzger> pastorn: yes.
17:20:42 <pastorn> pmetzger: so do you understand what mapM does?
17:20:45 <pastorn> @type mapM
17:20:46 <pmetzger> yes.
17:20:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:20:50 <pastorn> cool
17:21:01 <pastorn> then what are you struggling with?
17:21:11 <pmetzger> I don't find the whole thing natural as of now.
17:21:19 <pmetzger> I need more time for it to soak in.
17:21:42 <pmetzger> as with driving a car, the distinction between knowing how to drive and not having to think about it any more.
17:21:44 <pastorn> pmetzger: it's just a way to give you do-notation
17:22:13 <pmetzger> with experience, you just turn the wheel without thinking. right now I'm thinking too much about most of this.
17:22:21 <pastorn> pmetzger: and it's not "monad" - it's "warm fuzzy thing"
17:24:27 <pmetzger> ah, pretty printing: http://haskell.org/ghc/docs/latest/html/libraries/pretty/Text-PrettyPrint-HughesPJ.html
17:25:18 <ion> That’s not the same prettyprinting as the prettyprinting of data structures.
17:26:01 <pmetzger> no, but it can be used to construct pretty printing of data structures, can it not?
17:26:35 <pastorn> pmetzger: that library is probably beter for outputting code or nicely formatted lists
17:26:50 <pastorn> pmetzger: could you paste your data structure somewhere (hpaste.org)?
17:26:59 <pmetzger> I was looking to produce a nicely formatted list. :)
17:27:06 <pmetzger> see above. :)
17:28:28 <pastorn> pmetzger: there's a lot of "above" :(
17:29:05 <pmetzger> yes, but my original question was an easy way to pretty print a list.
17:29:24 <pastorn> pmetzger: yeah, but you never said what the elements of the list was
17:30:43 <Cale> Oh, btw, for people who were talking about injective/surjective before, a nice way of looking at it is by looking at the sets of values which are sent by the function to a specific value. The fibre (under f: X -> Y) of a point y in Y is the set of values x in X for which f x = y.
17:31:16 <Cale> Injective functions have fibres which all have no more than one item. Surjective functions have fibres which all have at least one item.
17:31:36 <Cale> (and of course, bijective functions have fibres with exactly one item each)
17:31:44 <danharaj> Why is a constraint that looks like this bad (GHC tells me I need undecidable instances)? instance Foo a => Bar a
17:31:55 <acowley> what's the best way to convert a NominalTimeDiff to a Double (of seconds)?
17:31:58 <ksf_> edwardk, you seem to know a lot about what's needed to get HList into ghc
17:32:08 <mauke> danharaj: I think of classes as functions
17:32:21 <ion> @hoogle NominalTimeDiff
17:32:21 <lambdabot> No results found
17:32:22 <pastorn> acowley: check its instances
17:32:25 <mauke> danharaj: in that sense it's a sideways call, equivalent to bar a = foo a
17:32:28 <Cale> danharaj: Because that instance overlaps with every possible instance.
17:32:32 <ion> What defines NominalTimeDiff?
17:32:36 <acowley> pastorn: I am looking at them
17:32:40 <acowley> ion: Data.Time.Clock
17:32:41 <mauke> danharaj: and that doesn't necessarily terminate, especially if you also add foo a = bar a
17:32:52 <pastorn> acowley: (toRational . fromRational) -- iirc
17:33:00 <ksf_> edwardk, so you seem to be predestined to be shanghaied into doi it
17:33:05 <danharaj> ah I see. What should I do then? Wrap in a newtype?
17:33:08 <ksf_> +ng
17:33:11 <Cale> Well, I suppose the reason that it requires undecidable instances is more mauke's reasoning.
17:33:16 <acowley> pastorn: isn't that going to be exceedingly slow?
17:33:18 <Cale> But yeah, use a newtype wrapper
17:33:31 <ion> acowley: Does fromRational . toRational work?
17:33:42 <Saizan> danharaj: UndecidableInstances is fairly tame, in the worst case ghc will spin for a bit while typechecking your code :)
17:33:51 <pastorn> acowley: dunno... do you have a gazillion NominalTimeDiffs to convert?
17:34:00 <NihilistDandy> Is there a graphical representation of the typeclass hierarchy?
17:34:05 <acowley> ion: yes, but I wanted to avoid the rational intermediary
17:34:08 <danharaj> Saizan: If these classes are going to be closed (Not gonna export all of them from the module), am I pretty much safe if I use undecidable?
17:34:12 <Cale> danharaj: Note that when selecting which instance to use, the typeclass constraints on the instances can't be considered, because they might be fulfilled by future modules.
17:34:14 <Saizan> danharaj: though, you won't be able to make any other instances of Bar, unless you want to go into OverlappingInstances territory
17:34:21 <acowley> pastorn: this is one of those things that's just kind of obnoxious. death by a thousand cuts and what not
17:35:06 <danharaj> I'm using these classes basically for bookkeeping and exporting some functions. I don't intend to add any new instances ever.
17:35:09 <Cale> danharaj: So when the algorithm that selects the instances is deciding whether or not to use your instance Foo a => Bar a, it does the same reasoning as it would for an instance Bar a
17:35:32 <Cale> (and then fails later if there's no instance of Foo)
17:35:39 <danharaj> Cale: that's illuminating.
17:35:49 <mauke> in function speak: 'foo a = bar a; foo a = ()' doesn't make much sense
17:36:05 <mauke> total overlap, yo
17:36:29 <NihilistDandy> Oh, neat, answered my own question
17:36:52 <danharaj> Actually new-type wrapping makes perfect sense.
17:36:55 <Cale> NihilistDandy: There are some diagrams of the standard classes in the report.
17:37:07 <danharaj> It'll clean up something else too. Thanks guys :)
17:37:18 <danharaj> I never quite read all the rules about type classes. Yawnfest.
17:37:25 <eekTheCat> I have a file xmonad.hs, using ghci I want to examine the types of objects I declared in the file. how do I do that?
17:37:35 <Cale> NihilistDandy: in addition to that, there's the Typeclassopedia, which iirc had some diagrams
17:37:48 <mauke> eekTheCat: ghci xmonad.hs, then ':t whatever'
17:37:51 <NihilistDandy> Cale: You don't say... I'll have to look into that, too. Found a couple of pretty straightforward ones around, as well
17:38:08 <Cale> http://www.haskell.org/haskellwiki/Typeclassopedia
17:38:08 <acowley> there's a diagram in School of Expression
17:38:22 <eekTheCat> mauke, that didn't work. nothing i declared seems to be recognized from the ghci prompt...
17:38:34 <eekTheCat> it did seem to load and compile the file
17:38:34 <mauke> ah
17:38:41 <Cale> (page 19)
17:38:42 <mauke> eekTheCat: what's your prompt?
17:38:57 <eekTheCat> mauke, Prelude Main>
17:39:04 <mauke> yep
17:39:09 <mauke> eekTheCat: try ':l *xmonad.hs'
17:39:43 <NihilistDandy> Neat. I understand the basics of typeclasses and so on, I just like to build a model in my brain for reference :D Thanks for the links
17:39:50 <eekTheCat> mauke, yay. that did it
17:39:53 <Cale> eekTheCat: Probably there's a .o file already compiled
17:40:16 <Cale> eekTheCat: in which case ghci will load that, and only exported symbols will be available
17:40:35 <ksf_> or rather those that weren't inlined away
17:40:59 <mauke> inlined? huh
17:41:00 <ksf_> I always found the behaviour to be quite random
17:41:02 <eekTheCat> mauke, so the '*' part of the command circumvents that?
17:41:20 <mauke> eekTheCat: yeah, that forces it to load/interpret the source itself
17:41:28 <mauke> and then everything is visible
17:41:36 <eekTheCat> mauke, thanks for your help
17:41:39 <danharaj> How does GHCi treat seq's and similar functions? Because I am getting different behavior in GHCi and compiled.
17:42:03 <ksf_> IO differs between compiler and interpreter
17:42:08 <pastorn> danharaj: did you read the blog posts about the haskell heap?
17:42:12 <ksf_> don't ask me for the details, though, it's just another rts.
17:42:19 <danharaj> pastorn: Kind of. I liked the pictures mostly :p
17:42:28 <pastorn> hehe
17:42:39 <pastorn> i think seq was covered in part 4
17:42:43 * pastorn likes presents
17:42:47 <danharaj> ksf_: Good enough for me. I was just curious. The observable difference is that Repa is pestering me about not being strict enough in ghci.
17:43:01 <danharaj> I'll eventually tell the library maintainers :p
17:43:42 <ksf_> I don't think ghci is doing much strictness analysing, if at all.
17:44:30 <ksf_> as long as 1+1 is still 2, everything's as expected.
17:45:50 <danharaj> oh boy this is interesting.
17:49:15 <danharaj> type/data families are cool!
17:52:26 <Tyr42> where are you reading about them?
17:53:01 <danharaj> I read about them here and then relied on the ol' learn by doing technique: http://www.haskell.org/haskellwiki/GHC/Type_families
18:00:20 <tauntaun> If Num requires signum, then doesn't this mean that, for example, a complex number can't be a Num?
18:00:35 <danharaj> look at the type of signum
18:00:36 <danharaj> :t signum
18:00:37 <lambdabot> forall a. (Num a) => a -> a
18:00:50 <danharaj> You can define it component wise and that'll work.
18:01:03 <danharaj> I agree it's counter-intuitive and Num is not a favorite class of mine.
18:01:37 <shachaf> danharaj: Really?
18:01:44 <tauntaun> By component-wise, you mean that signum of 3-4i, say, would evaluate to 1-i?
18:01:58 <shachaf> This is the best class, actually:
18:01:59 <shachaf> @src REal
18:01:59 <lambdabot> Source not found. Maybe you made a typo?
18:02:02 <shachaf> @src Real
18:02:02 <lambdabot> class  (Num a, Ord a) => Real a  where
18:02:02 <lambdabot>     toRational      ::  a -> Rational
18:02:29 <Draconx|Laptop> shachaf, it's not as awesome as its instances
18:02:29 <acowley> shachaf: it's optimistic
18:02:33 <danharaj> tauntaun: Don't quote me on it. It's best to try it yourself in ghci to see if I'm a liar or not. :p
18:02:43 <danharaj> tauntaun: But when I made some new num classes that's how I did it.
18:02:56 <dolio> signum for complex numbers returns a number whose norm is one, but is in the same direction from the origin.
18:03:04 <dolio> Except for 0.
18:03:15 <danharaj> That also makes sense.
18:03:20 <tauntaun> dolio: wha??
18:03:34 <tauntaun> oh I see
18:03:42 <dolio> And abs returns its norm along the positive real line.
18:03:52 <dolio> so abs c * signum c = c.
18:03:56 <dolio> In theory.
18:04:42 <monochrom> > abs (3 :+ 4)
18:04:43 <lambdabot>   5.0 :+ 0.0
18:04:56 <tauntaun> That makes sense.  I was just thrown off by the signum definition's saying that signum had to return -1, 0, or 1.
18:05:03 <Draconx|Laptop> > let x = (1/0) :+ 0 in abs x * signum x
18:05:04 <lambdabot>   NaN :+ NaN
18:05:13 <acowley> it's a nice definition
18:05:49 <tauntaun> But I wonder how this might work for quaternions...
18:05:57 <acowley>  let x = (1/0) :+ 0 in abs x * signum x == x
18:06:00 <acowley> > let x = (1/0) :+ 0 in abs x * signum x == x
18:06:00 <dolio> signum and abs are the reason Complex is restricted to floating point numbers, or whatever the class is.
18:06:01 <lambdabot>   False
18:06:06 <dolio> As I recall.
18:06:28 <acowley> > let x = (1/0) :+ (1/0) in abs x * signum x == x
18:06:29 <lambdabot>   False
18:06:35 <acowley> darn
18:06:49 <tauntaun> (Actually, it's just as easy for quaternions.)
18:10:01 <djahandarie> That 'hfusion' library seems like it's operating at the wrong level
18:10:15 <Draconx|Laptop> dolio, without the restriction to floating point numbers, one would have a very hard time defining a numerically stable Fractional instance.
18:10:23 <acowley> djahandarie: what's it do?
18:10:31 <Tyr42> @unmtl MaybeT (State s))
18:10:32 <lambdabot> err: Parse error
18:10:36 <Tyr42> @unmtl MaybeT (State s)
18:10:36 <lambdabot> err: `MaybeT (State s)' is not applied to enough arguments, giving `/\A. s -> (Maybe A, s)'
18:10:43 <djahandarie> acowley, generates fused version of recursive Haskell programs.
18:10:43 <Tyr42> @unmtl MaybeT (State s) a
18:10:43 <lambdabot> s -> (Maybe a, s)
18:10:58 <djahandarie> acowley, it seems to be working with a syntax tree which just spells all kinds of wrong to me
18:11:12 <dolio> Draconx|Laptop: Complex Integer is a potentially useful numeric type.
18:11:27 <dolio> But you can't use it.
18:11:38 <djahandarie> 'Fusion' is a property of all Mu-recursive types (perhaps more general?)
18:11:42 <Draconx|Laptop> dolio, I agree, but because of how instances work in (standard) Haskell, removing the constraint would make Complex Double a useless numeric type.
18:12:09 <dolio> Why?
18:12:16 <Draconx|Laptop> dolio, because you'd suddenly have to define (/) in a way that works for all Nums.
18:12:19 <acowley> djahandarie: it's a pretty bold thing to try, though
18:12:43 <dolio> Why would you have to do that?
18:13:07 <djahandarie> And the fusion (i.e., rewriting cata and anas into hylomorphisms) can be a simple rewrite rule in GHC. I think if you generalize properly you don't even need a rewrite rule
18:13:17 <Draconx|Laptop> dolio, because you can't have different Fractional instances for Complex Doublee and Complex Integer.
18:13:34 <dolio> Complex Integer wouldn't have a Fractional instance.
18:14:08 <Draconx|Laptop> dolio, oh, so instance RealFloat a => Fractional (Complex a)?  hmm.
18:14:24 <djahandarie> Maybe what they are about is machine-verified rewrites of recursive structures into their fused versions.
18:14:30 <djahandarie> But I don't know why anyone would use Haskell for that
18:14:41 <dolio> Yeah. Or Fractional a, or whatever makes sense.
18:14:43 <acowley> djahandarie: I don't see how it woudl be so easy
18:15:01 <acowley> well, I'm probably wrong
18:15:33 <acowley> I find thinking about what GHC can do in that realm pretty confusing 
18:15:48 <djahandarie> Stream fusion is not as easy
18:16:14 <djahandarie> (The Skip constructor is the main problem there)
18:16:23 <acowley> for a general cata . ana, it seems like lazy evaluation helps a lot
18:17:07 <dolio> Right now Complex Integer isn't even a valid type.
18:17:10 <dolio> Which is silly.
18:17:11 <Draconx|Laptop> dolio, ok yeah, so signum and abs are the only problem.
18:20:01 <Draconx|Laptop> dolio, with one exception which is that the "standard" definition of (*) is somewhat unsatisfactory for floating point, as it tends to turn infinities into NaNs.
18:21:40 <Draconx|Laptop> (it also tends to turn undue overflow into NaNs, which is unfortunately /very/ hard to avoid)
18:22:02 <dolio> I must admit I'm not very concerned with how well it behaves for floating point edge cases.
18:25:05 <khaled> hi, I have a beginer questions : 1) why it's not possible to write data Bit = 0 | 1 ? 2) How to know if the processor is little-endian or big-endian ?
18:25:36 <NihilistDandy> Get out a micromoeter and check, of course.~
18:25:44 <NihilistDandy> *meter
18:25:48 <danharaj> Does anyone happen to know a quick summary page of GLSL types that can be vertex attributes?
18:26:52 <mauke> khaled: 1) because 0 doesn't start with an uppercase letter
18:27:07 <mauke> khaled: 2) what would you do with that knowledge?
18:28:05 <khaled> mauke: Just write a bit list in a file
18:28:12 <mauke> wat
18:28:28 <mauke> files consist of bytes, not bits
18:28:49 <NihilistDandy> khaled: What architecture is your processor?
18:29:04 <khaled> yes, but I have a bit list which i must convert in bytes
18:29:17 <khaled> my proc is a x86, it's big endian
18:29:39 <Eduard_Munteanu> That's a contradiction.
18:29:46 <NihilistDandy> ^^
18:29:51 <Eduard_Munteanu> If it's x86 it's LE.
18:29:51 <NihilistDandy> I was gonna say
18:29:58 <khaled> Ok sorry ^^
18:30:09 <mauke> what do you mean by "bit list"?
18:30:31 <mauke> also, endianness is about the byte order within a word
18:30:38 <mauke> not the bit order within a byte
18:30:41 <khaled> I try to implement huffman , and each byte is replaced by 1 bit
18:31:16 <khaled> mauke : Ok I am confused!
18:31:18 <Eduard_Munteanu> Not really.
18:31:47 <Eduard_Munteanu> Also bit order is something that doesn't affect you.
18:31:59 <NihilistDandy> ^^
18:32:45 <khaled> Eduard_Munteanu : I think I understand, I just have too create my ByteString and it will work on 2 architecture isn't?
18:32:54 <Eduard_Munteanu> And byteorder is only a concern for representing  the frequency table AFAICT
18:32:58 <Tyr42> I'm trying to read http://www.grabmueller.de/martin/www/pub/Transformers.en.html
18:33:08 <Tyr42> Monad Transformers Step by step
18:33:13 <Tyr42> and it doesn't compile
18:33:34 <Tyr42> it fails with all the calls to Map.lookup
18:33:45 <Tyr42> has that been changed in the last 4 years?
18:34:33 <mauke> Tyr42: what's the error message?
18:35:09 <Tyr42> Couldn't match expected type `ErrorT String Identity Value'
18:35:09 <Tyr42>                 with actual type `Maybe a0'
18:35:15 <mauke> ah, yes
18:35:17 <mauke> that has changed
18:35:48 <Tyr42> can I umm, change it back for one module?
18:35:58 <Eduard_Munteanu> It used to return an Error / Either?
18:36:16 <Saizan> it used to return Monad m => m v
18:36:23 <Eduard_Munteanu> Hrm.
18:36:30 <mauke> lookup k m = maybe (fail ("key not found: " ++ show k)) return (Map.lookup k m)
18:37:30 <Tyr42> if I hid the old Map.lookup and replaced it with that, would I need to do anything else?
18:37:45 <Tyr42> any instances or anything?
18:37:59 <mauke> well, this uses the old Map.lookup
18:38:10 <Tyr42> oh, ok
18:38:16 <Tyr42> I have a plan
18:38:34 <Tyr42> %s/Map.lookup/lookup/g
18:38:39 <Tyr42> that's the plan
18:42:01 <Tyr42> that seems to have worked
18:42:04 <Tyr42> thank you
18:42:42 * hackagebot x11-xim 0.0.5 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.5 (YoshikuniJujo)
18:47:14 <Eduard_Munteanu> khaled: not really, as I told you, some things depend on byteorder. Like storing Ints.
18:48:08 <Eduard_Munteanu> As for Huffman itself you pack bits into bytes and write them out. Lone bytes aren't affected by byteorder.
18:49:04 <blackdog> can anyone suggest what i've done wrong in building HFuse here? https://gist.github.com/945658
18:49:26 <blackdog> the header file looks like it should be perfectly visible...
18:51:34 <Saizan> blackdog: try with more verbosity
18:51:38 <Eduard_Munteanu> blackdog: guessing, isn't it /usr/include/linux/fuse.h ?
18:51:49 * Eduard_Munteanu doesn't know much about Cabal though
18:52:26 <Eduard_Munteanu> Ah, nevermind.
18:52:36 <blackdog> Saizan: doesn't help - i get "using tar found on system", then "missing dependency on a foreign library"
18:52:41 <blackdog> Eduard_Munteanu: not on mac:)
18:52:59 <Eduard_Munteanu> It was probably stupid anyway if you were using a userspace lib.
18:53:26 <blackdog> Saizan: what's actually looking for those files? would it be cabal itself?
18:55:15 <blackdog> ah, got it i think
18:55:39 <blackdog> gcc is  actually missing _another_ file, but cabal is reporting that it can't find fuse.h
18:56:53 <Saizan> yeah, that error message gets thrown when it can't find and/or compile the header
18:57:20 <Saizan> i thought it got better with recent cabals though
18:58:45 <blackdog> ah, i'm using cabal-install 0.8.2.
18:58:48 <blackdog> time to fix that:)
19:03:13 <KirinDave> Man, the answer to al3x's question is just oustanding.
19:03:25 <KirinDave> Like the first time I've seen Stack Overflow really accumulate some good knowledge.
19:03:46 <NihilistDandy> KirinDave: Link?
19:03:51 <blackdog> KirinDave: it's something i've been worried abuot
19:03:51 <KirinDave> http://stackoverflow.com/questions/5808825/what-are-the-best-haskell-libraries-to-operationalize-a-program
19:04:06 <KirinDave> blackdog: Well you've seen me in here asking around about it as well
19:04:07 <blackdog> mostly i use ruby tools - capistrano etc
19:04:13 <KirinDave> Alex being my boss.
19:04:23 <KirinDave> We're considering haskell, but it's a little frightening.
19:04:36 <blackdog> having to build a static binary to upload to a site isn't ideal
19:04:50 <KirinDave> Me, personally, I love taking these kinds of leaps. But I'm not a jr. engineer who can stay up 3 days straight prepping a prototype to then force upon management.
19:04:56 <KirinDave> blackdog: Do you know how java deploys happen?
19:05:04 <KirinDave> Most people build epically fat jars.
19:05:08 <blackdog> usually a .war, right?
19:05:17 <KirinDave> That's if you're doing web services.
19:05:21 <KirinDave> If not, you create assembly jars.
19:05:27 <KirinDave> ONE-jar or fat jars.
19:05:35 <KirinDave> Which is basically a supermassive tub of code.
19:06:11 <blackdog> actually, even the ruby world seems to be moving toward cocooning apps in their own virtual world
19:06:19 <blackdog> specified ruby via .rvmrc etc
19:06:24 <KirinDave> Yeah
19:06:31 <KirinDave> So i think the issue of static linking... 
19:06:37 <KirinDave> It might even be a benefit, albeit at the cost of efficiency.
19:06:58 <blackdog> i've been thinking about a sort of heroku-for-haskell service
19:07:18 <blackdog> and how you'd structure it for zero downtime, rollback etc
19:07:37 <blackdog> i guess just mapping ports, changing nginx config on the fly and sending -HUP?
19:08:01 <KirinDave> Ha
19:08:07 <blackdog> although obviously plugins would be nicer
19:08:07 <KirinDave> Heroku isn't exactly rocket surgery in how it works.
19:08:30 <blackdog> sure. but that ease of deployment is worth something
19:09:33 <blackdog> it'd be nice to have haskell as the tool i can reach for with simple things as well as the hard nuts
19:17:37 <Eduard_Munteanu> Is there anything done in Haskell (or Agda etc.) which allows one to write stuff which erases to C code, so that it can be annotated with proofs or additional guarantees?
19:18:05 <Mathnerd314> Eduard_Munteanu: ATS?
19:18:07 <Eduard_Munteanu> I mean, something that looks like a soup of Haskell/Agda/Coq/etc and C.
19:18:35 <Saizan> ATS has inline asm, iirc
19:18:45 <Eduard_Munteanu> Mathnerd314: as far as I know ATS might compile to C, but the idea is to write efficient C code and add proofs to it.
19:19:49 <Eduard_Munteanu> I mean, yeah I could use Haskell to FFI to C or compile -fvia-c, but that isn't suitable for some applications (e.g. an RTS, chicken and egg problems etc.)
19:19:56 <Saizan> so you want C ornamented with hoare logic?:(
19:19:59 <Saizan> *:)
19:20:34 <Eduard_Munteanu> Something like that.
19:21:35 <Eduard_Munteanu> I remember looking some time ago at seL4 and they went to great lengths to model C's behavior in HOL/Isabelle and such. Not a really easy approach. Plus it's not integrated with the code, AFAIK.
19:22:13 <Saizan> the closest thing i know of is Coq's Ynot lib
19:24:52 <Saizan> Idris simply has an FFI to C
19:26:53 <Eduard_Munteanu> Hm, not really what I was looking for. More like a C EDSL hosted in say Agda that prints the same C code to stdout or to a file. Then peppering that up with dependent types so one can verify it.
19:27:32 <pastorn> What's the name of the strict haskell dialect with good record syntax?
19:27:34 <Eduard_Munteanu> The Agda program needn't do anything besides write the C code to a file.
19:28:43 <gienah> for compiler front end stuff the antlr parser generator can generate a recursive descent C parser, which calls Haskell code that was extracted from Coq, some of the Coq code can be generated from Ott
19:30:26 <gienah> an example of antlr C code calling Haskell: https://github.com/markwright/antlrc-examples/tree/master/src/tapl/arith
19:31:29 <Saizan> Eduard_Munteanu: that'd be nice to have
19:31:36 <pastorn> ah, this was what i was looking for: http://disciple.ouroborus.net/
19:33:14 <gienah> Ott, a type theory tool that can generate Coq, then Haskell can be extracted from the Coq code: http://www.cl.cam.ac.uk/~pes20/ott/
19:33:19 <Eduard_Munteanu> gienah: I'm not sure. I suppose one could use a C parser but then he'd have to encode C's semantics somehow. Note I'm more or less just interested in typechecking, not actual runtime
19:34:14 <Eduard_Munteanu> For example I'd like to annotate C buffers with some dependent types to check bounds are indeed obeyed.
19:35:50 <Eduard_Munteanu> I might need to have a look at Haskell's C EDSLs.
19:36:04 <Eduard_Munteanu> And yeah, Ott looks neat :)
19:36:22 <gienah> the existing language-c haskell project using happy can handle the C code, as can the ANTLR C parser
19:37:19 * gienah (thinks that LALR parser generators are not really suitable for parsing C++)
19:38:30 <luite> can ANTLR generate haskell code?
19:38:49 <gienah> luite: not yet but this is a project I am working on :-)
19:39:17 <gienah> luite: for antlr 4 which is in development
19:39:45 <Eduard_Munteanu> Mm, not sure how language-c helps here, unless the parser executes at typechecking :)
19:40:02 <luite> what types of grammar can it use now?
19:41:53 <gienah> luite: the antlr C stuff calling Haskell can use the LL(*) parser generator, which is powerful.  The haskell runtime is in early development, I have only sketched what some of the lexer generated code should look like.
19:43:31 <gienah> luite: ANTLR can use semantic predicates to handle context sensitive languages (like C++, C++ is difficult though since you need the type checker to parse it)
19:44:53 * hackagebot ginsu 0.8.0 - Ginsu Gale Client  http://hackage.haskell.org/package/ginsu-0.8.0 (DylanSimon)
19:47:54 <Eduard_Munteanu> http://www.haskell.org/pipermail/haskell-cafe/2009-March/058872.html
19:48:03 <gienah> when I try extracting haskell code from the Coq code generated by Ott, it encountered a limitation: Ott generates Coq propositions, and Coq can not extract Haskell code from a proposition. Hence I guess I need to try to extract the Haskell code from Coq proofs. Or anyway the generated Coq propositions look useful for writing the Haskell code by hand.
19:48:24 <Eduard_Munteanu> Now if only all those were nothing but putStrLn.
19:55:13 <dons> huh.
19:55:18 <dons> new  release of ginsu!?
19:55:28 <dons> the project from which yi's interface was stolen
19:56:14 <Axman6> bleh, why do OpenCL functions not have man pages -_-
19:57:17 <pastorn> Axman6: was it Sven who wrote the bindings?
19:57:53 <Axman6> i mean just the C functions, trying to translate an assigment I've just finished to use OpenCL
19:59:57 <Axman6> maybe i should look at the haskell bindings... though i seem to remember they were basically undocumented infavour of you reading the OpenCL spec -_-
20:01:44 <NihilistDandy> If I never again see the phrase "custom biz apps", it will be too soon
20:31:49 <NemesisD> is it possible to uninstall a package with cabal?
20:33:37 <monochrom> no, but you can ghc-pkg unregister
20:34:16 <Locke1689> Does anyone have any pointers to a good QuickCheck tutorial? I'm trying to do something a little more complicated (I want future generated test cases to depend on past test cases)
20:34:49 <NemesisD> odd that cabal doesn't have that feature
20:35:06 <mauke> parsing is hard :-(
20:35:21 <monochrom> cabal is largely a proxy of ghc-pkg. well, plus dependency chasing
20:37:12 <NemesisD> i guess i think of it as haskell's version of rubygems
20:37:56 <monochrom> you will soon find that there is no one-to-one correspondence between toolchains
20:39:29 <monochrom> every community organizes stuff its own way. we are talking about humans, not photocopiers. it would actually surprise me if there were 100% correspondence. 80% resemblance is more likely
20:42:41 <NemesisD> fair enough
20:43:26 <NemesisD> so here's my dilemma, i'm writing a patch to a project on hackage. i uninstalled the hackage version locally, cloned the repo, it complains that all of its dependencies are unsatisfied, which they aren't
20:48:05 * hackagebot hs-vcard 0.1 - Implements the RFC 2426 vCard 3.0 spec  http://hackage.haskell.org/package/hs-vcard-0.1 (MichaelSchade)
20:54:39 <danharaj> What can I do to improve link times with GHC?
20:56:21 <shachaf> danharaj: I'm told that gold is supposed to be faster than GNU ld.
20:56:27 <shachaf> danharaj: See http://hackage.haskell.org/trac/ghc/ticket/4862
20:56:33 <danharaj> shachaf: thanks
21:02:17 <danharaj> ... I am flabbergasted. How can Repa start crying about laziness when I haven't changed any code using Repa since the last compile :| :| :| |
21:14:25 <fizruk> hi all! can someone help me with GADTs?
21:15:39 <danharaj> fizruk: maybe.
21:15:41 <shachaf> fizruk: That seems likely.
21:15:44 <fizruk> i have this code: http://hpaste.org/46095/gadts_pattern_matching
21:16:19 <fizruk> it produces error about GADT pattern matching in non-rigid context
21:16:33 <fizruk> and suggests to add type signature
21:17:32 <fizruk> i've tried different variants, but error doesn't disappear
21:18:35 <danharaj> theType :: TType a right?
21:18:39 <danharaj> Where you have theType :: a
21:18:44 <copumpkin> fizruk: you might want scoped type variables
21:19:00 <copumpkin> some_func :: forall a b. (IsType a, IsType b) => a -> b -> Maybe ()
21:19:08 <copumpkin> {-# LANGUAGE ScopedTypeVariables #-}
21:19:16 <fizruk> theType :: TType a
21:19:38 <copumpkin> yeah
21:19:44 <copumpkin> but do what I siad too
21:20:21 <fizruk> copumpkin: thanks, that worked :)
21:20:25 <falbani> hi
21:21:11 <falbani> hey, which is the best way of using Hint? (I really like when hpaste shows me some suggestions... they help me a lot)
21:21:23 <falbani> any way of mixing it with GHCI?
21:21:32 <falbani> or with runghc
21:22:34 <scutigera> copumpkin: why is test (theType :: a) (theType :: b) necessary ? shouldn't the declaration of test make everything work ?
21:22:53 <scutigera> copumpkin: i mean without scoped type decls
21:22:57 <copumpkin> yeah, you might be right
21:23:02 <copumpkin> I was just going with his annotations
21:23:11 <copumpkin> and as they stood, they wouldn't do what he expected
21:25:36 <scutigera> hmmm , in fact, what exactly are a and b ? there's no arguments to some_func...
21:26:26 <fizruk> scutigera: this is modeling function, in real function a and b have their meanings
21:28:05 <danharaj> http://walkncode.com/pair-station
21:28:09 <danharaj> I am flabbergasted
21:28:10 <scutigera>  if you remove theType ::, then the variables a and b don't exist ?!
21:28:36 <copumpkin> danharaj: I wouldn't mind one
21:29:05 <scutigera> I've tried drink beer and code, but I end up paying more attention to the beer.
21:29:26 <ryant5000> yeah, those treadmill desks are supposed to be fantastic for your health
21:30:47 <scutigera> fizruk: my question is what is theType acting on ?  there is no variable a.
21:31:15 <falbani> i was refering to HLint... not hint
21:31:25 <fizruk> scutigera: a is type variable
21:32:08 <scutigera> > Maybe a
21:32:09 <lambdabot>   Not in scope: data constructor `Maybe'
21:32:42 <fizruk> > Nothing :: Maybe a
21:32:43 <lambdabot>   Nothing
21:32:57 <scutigera> > Just a
21:32:58 <lambdabot>   Just a
21:33:12 <scutigera> hey - how'd that work
21:33:15 <scutigera> > Just 1
21:33:16 <lambdabot>   Just 1
21:33:30 <shachaf> > Just foo
21:33:32 <lambdabot>   Just foo
21:33:36 <shachaf> Magic.
21:33:39 <scutigera> > :t Just foo
21:33:40 <lambdabot>   <no location info>: parse error on input `:'
21:33:54 <shachaf> @ty Just foo
21:33:55 <lambdabot> forall a. Maybe a
21:34:52 <copumpkin> @ty Just foo
21:34:53 <lambdabot> Not in scope: `foo'
21:34:55 <copumpkin> zomg
21:34:58 <copumpkin> shachaf is a mage!
21:35:09 <copumpkin> :)
21:35:16 <fizruk> О_о
21:35:17 <copumpkin> amaging!
21:35:31 <fizruk> @ty Just foo
21:35:32 <lambdabot> Not in scope: `foo'
21:35:34 <scutigera> so why wouldn't test (theType a) (theType b) not work ?
21:35:52 <fizruk> scutigera: a and b are types, not values
21:35:52 <shachaf> @ty Just foo
21:35:53 <lambdabot> forall foo. Maybe foo
21:36:39 <Mathnerd314> copumpkin: shachaf is a charlatan!
21:36:44 <copumpkin> :O
21:37:08 <shachaf> Mathnerd314: Excuse me?
21:37:40 <Kerris> A gentleman's honour has been besmirched!
21:37:41 <Mathnerd314> shachaf: your "foo" is not the normal "foo"!
21:37:54 <shachaf> @let foo :: foo; foo = foo
21:37:55 <lambdabot>  Defined.
21:37:56 <fizruk> > foo = undefined
21:37:57 <lambdabot>   <no location info>: parse error on input `='
21:37:57 <shachaf> What could be more normal?
21:38:08 <fizruk> > let foo = undefined
21:38:09 <lambdabot>   not an expression: `let foo = undefined'
21:38:11 <Mathnerd314> shachaf: you were playing tricks behind the scene!
21:38:27 <Eduard_Munteanu> I know what can settle this.
21:38:28 <scutigera> fizruk: test (theType :: a) (theType :: b) still doesn't make sense.  a and b are type variables so how can they evaluate to anything ?
21:38:29 <Eduard_Munteanu> A duel!
21:38:37 <shachaf> If you're going to be making accusations like *that*, let's take it to #-blah.
21:38:45 <Eduard_Munteanu> Prepare your swords!
21:39:04 <Rellik_> hey, SUPER noob question - is it possible to use a type synonym as a data constructor?
21:39:08 <shachaf> @let sword = (>>= undefined)
21:39:09 <lambdabot>  Defined.
21:39:19 <nihtml> tree power activate.
21:39:38 <Eduard_Munteanu> Rellik_: no, they just expand to what they're synonyms for.
21:39:57 <Rellik_> hmmmm this book i'm reading is lame then =(
21:39:58 <Eduard_Munteanu> Besides, it only "defines" types, not values.
21:40:05 <Eduard_Munteanu> Example?
21:40:08 <Rellik_> well
21:40:13 <Rellik_> return x = Writer (x, mempty)
21:40:27 <Rellik_> sorry, i didn't mean that
21:40:29 <Rellik_> Writer (x, w)
21:40:33 <Rellik_> as a data constructor
21:40:34 <fizruk> scutigera: theType is a polymorphic constant, defined in class IsType. type annotations (:: a) and (:: b) just specify which type i need
21:40:34 <Eduard_Munteanu> Writer is a newtype usually
21:40:40 <Eduard_Munteanu> :t Writer
21:40:41 <lambdabot> Not in scope: data constructor `Writer'
21:40:44 <Rellik_> yea, see?
21:40:47 <Eduard_Munteanu> :t WriterT
21:40:48 <Rellik_> it's actually a type synonym
21:40:48 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
21:40:54 <nihtml> Zipper ?
21:40:57 <Rellik_> Writer is defined on WriterT
21:41:03 <Eduard_Munteanu> :t runWriter
21:41:04 <lambdabot> forall w a. Writer w a -> (a, w)
21:41:11 <Eduard_Munteanu> @src Writer
21:41:11 <lambdabot> Source not found. :(
21:41:40 <Rellik_> i just find it odd that i can't define like "type MyMaybe a = Maybe a"
21:41:45 <Rellik_> and then construct my own MyMaybes
21:41:55 <scutigera> fizruk: I get it.  thanks !
21:41:57 <Eduard_Munteanu> Rellik_: newtype != type
21:42:10 <Rellik_> right, i do understand that type only means type synonym
21:42:36 <Rellik_> but what would be the harm of a type synonym of a type that has only one data constructor defining itself as a synonym of that data constructor?
21:42:41 <fizruk> scutigera: :)
21:42:52 <Eduard_Munteanu> newtype Writer w a = Writer { runWriter :: (a, w) }  IIRC
21:42:52 <Rellik_> Maybe is a bad example in that case
21:43:03 <Rellik_> ooooh, i see, we can do both
21:43:12 <Rellik_> have both Writer as a type synonym and then define it as a data constructor
21:43:18 <Rellik_> i understand now
21:43:20 <Rellik_> thanks!
21:43:23 <Eduard_Munteanu> Type synonyms are transparent, they don't involve any sort of constructor.
21:44:17 <Rellik_> i guess it's no different from an OOP language, where you have to redefine a constructor even if you're just wrapping a subclass
21:44:36 <Rellik_> parent class that is
21:46:10 <scutigera> fizruk: I just tried adding ScopedTypeVariables and example gives the same error (ghc 6.12.1)
21:46:44 <fizruk> add "forall a b." to the type annotation of some_func
21:47:32 <Eduard_Munteanu> Rellik_: well you could make your own Maybe that behaved just like the original one, but that'd be a 'data'
21:48:01 <Eduard_Munteanu> It depends on what you want to accomplish.
21:48:27 <scutigera> fisruk: did it, same error.  ghc  version thing ?
21:50:56 <Rellik_> hmmmmmm
21:51:13 <Rellik_> this example from the "Learn You a Haskell for Great Good!" book is just entirely nonsensical then
21:51:22 <fizruk> scutigera: http://hpaste.org/paste/46095/gadts_pattern_matching_annota#p46096
21:51:33 <Rellik_> logNumber x = Writer (x, ["Got number: " ++ show x])
21:51:40 <fizruk> scutigera: theType :: TType a, not theType :: a
21:51:40 <Rellik_> is a function defined in one ifs examples
21:51:56 <Rellik_> but Writer is definitely not a data constructor
21:52:09 <Eduard_Munteanu> Rellik_: it's a newtype constructor
21:52:30 <Rellik_> ok, i definitely need to re-read these definitions =)
21:52:35 <Eduard_Munteanu> In fact Writer and runWriter are almost interchangeable.
21:53:01 <Eduard_Munteanu> The main difference is newtypes can only have a single constructor.
21:53:26 <scutigera> fizruk: oh, now, I should have been able to figure that out... thanks again :-)
21:53:26 <Eduard_Munteanu> They're like a bit like type synonyms, but opaque.
21:53:28 <copumpkin> and only a single field within that constructor
21:53:51 <Rellik_> oh, so they do what i wanted them to do then
21:54:08 <Rellik_> i just need to figure out why the example won't build and then it sounds like i've got it =P
21:54:46 <Eduard_Munteanu> What is the error?
21:55:08 <Rellik_> specifically it's "Not in scope: data constructor 'Writer'"
21:55:21 <Rellik_> although the import Control.Monad.Writer is present
21:55:42 <Rellik_> which had me scrambling to look at the source of Control.Monad.Writer and getting confused about type vs newtype
21:56:09 <Eduard_Munteanu> It might not export it anymore.
21:56:14 <Eduard_Munteanu> But you can use runWriter
21:56:16 <Eduard_Munteanu> :t runWriter
21:56:17 <lambdabot> forall w a. Writer w a -> (a, w)
21:57:02 <Eduard_Munteanu> Hrm, no, wait.
21:57:05 <Rellik_> but runWriter is the accessor
21:57:05 <Rellik_> yea
21:57:21 <Eduard_Munteanu> You want it the other way around.
21:57:22 <Eduard_Munteanu> :t writer
21:57:23 <lambdabot> forall a w. (a, w) -> Writer w a
21:57:28 <Eduard_Munteanu> That ^^
21:57:52 <Rellik_> ok, so it sounds like it used to be defined as a newtype, but no longer is, for whatever reason, so the writer function was added to provide a constructor
21:58:10 <Rellik_> thanks for pointing out the writer function!
21:58:38 <Rellik_> totally works =)
21:59:45 <Zeiris_> Is there a shortest-first version of "tails" that works for infinite sequences?
22:00:00 <Zeiris_> Oh, 'inits'
22:00:57 <shachaf> Zeiris_: It's slightly evil, of course.
22:01:33 * Zeiris_ is trying to find a definition of a multiplicative-fibonacci sequence that doesn't involve foldl with a tuple as the accumulator.
22:01:50 <Zeiris_> (Because that would be kind of ugly.)
22:02:14 <dmwit> What are the first few terms?
22:02:34 <astertronistic> multiplicative? Like: f(n) = f(n-1)*f(n-2)?
22:02:39 <Zeiris_> 1, 1*2, 1*2*3, 1*2*3*4, ...
22:02:51 <shachaf> What's Fibonacci about that?
22:02:58 <Zeiris_> Oh wait.
22:03:14 * hackagebot yesod-form 0.1.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.1.0.1 (MichaelSnoyman)
22:03:15 <shachaf> That's just factorials.
22:03:26 <Eduard_Munteanu> I don't think so.
22:03:28 <dmwit> > scanl (*) 1 [1..]
22:03:29 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
22:03:44 <Zeiris_> Aah, scanl :D
22:04:12 <Zeiris_> Awesome! I love Haskell's huge number of higher order functions.
22:04:28 <Eduard_Munteanu> f 6 = f 5 * f 4 = f 4 * f 3 * f 2 * f 1 ...
22:05:01 <Eduard_Munteanu> So it's just 1 if you initialize it like Fibonacci :)
22:05:19 <danharaj> haskell doesn't have a huge number of higher order functions
22:05:26 <danharaj> it lets you define higher order functions
22:05:29 * shachaf finds the term "higher-order function" strange.
22:06:00 <Zeiris_> Isn't that what foldl and variants are?
22:06:18 <danharaj> Yeah, but those are just defined in a library. You could define them yourself.
22:06:26 <danharaj> They're not given to you from heaven. :p
22:06:47 <monochrom> if you compare even "1 for haskell" vs "0 for some other language", that's still huge :)
22:07:23 <Zeiris_> You could - but people tend to use what they're given first, which sets the tone for a language.
22:07:31 <monochrom> not to mention that it's "as many as you want for haskell" vs "still 0 for some other language"
22:07:52 <shachaf> monochrom: A lot of languages have higher-order functions, though.
22:07:57 <danharaj> C has them
22:08:07 <monochrom> cobol doesn't
22:08:13 <Eduard_Munteanu> Though arguably not as first class values.
22:08:35 <Rellik_> without partial application higher-order functions aren't any fun ;p
22:08:36 <shachaf> Eduard_Munteanu: What's not first-class about C functions?
22:08:55 <danharaj> well they're passed by pointer, you can't pass them by value.
22:09:12 <shachaf> Hmm. I suppose.
22:09:17 <shachaf> Not many things are first-class in C, then.
22:09:20 <Eduard_Munteanu> You can't really concoct and return functions.
22:09:21 <monochrom> you can't even write "return (\x -> blah blah)"
22:09:55 <Rellik_> sure you could, if you generate the machine code on the spot and return a pointer to it ;p
22:10:00 <danharaj> nope
22:10:01 <monochrom> that would have been mitigated if C supported nested functions
22:10:07 <danharaj> well it depends on your platform then.
22:10:13 <shachaf> Rellik_: That's not C anymore. :-)
22:10:37 <shachaf> Also, there's the NX bit and what not.
22:11:01 <monochrom> "x86 has first-class higher-order functions"
22:11:03 <Rellik_> the way most of these imperative languages work with nested/anonymous functions is that they just do a first step where they turn them into named functions with temp names
22:11:05 <Zeiris_> Even without currying, higher order functions are a more structured way to traverse structures than for loops.
22:11:33 <astertronistic> It seems like a first class function could be expressed as a pair, (variable_bindings, pointer_to_c_like_function)
22:11:35 <Rellik_> hahah monochrom i'm going to repeat that
22:11:56 <monochrom> go to every programming channel and say that :)
22:12:23 <Eduard_Munteanu> Yeah, after all you can get around it.
22:12:43 <monochrom> (record how much time each channel takes to kick you. is it normally distributed? poisson?)
22:13:58 <Rellik_> so i just started learning haskell over the weekend - you know what the problem with haskell is?
22:14:06 <dmwit> Its record system?
22:14:17 <dmwit> No, no, the Num typeclass.
22:14:17 <Eduard_Munteanu> Yeah, lack of dependent types :P
22:14:23 <Rellik_> it's impossible to use a function without feeling a deep need to understand how to implement it
22:14:26 <shachaf> Partial functions?
22:14:27 <Rellik_> =P
22:14:29 <Twey> Haha
22:14:36 <dmwit> ?src scanl
22:14:36 <lambdabot> scanl f q ls = q : case ls of
22:14:36 <lambdabot>     []   -> []
22:14:36 <lambdabot>     x:xs -> scanl f (f q x) xs
22:14:45 <Rellik_> hahah, there you go, that's already what i was thinking
22:14:49 <monochrom> I don't think it's haskell-specific
22:14:49 <dmwit> All the functions are short anyway, so that shouldn't be too much of a burden.
22:14:54 <Twey> Rellik_: On the flip side, that's because many functions are trivial :þ
22:15:09 <shachaf> All Haskell functions are trivial.
22:15:19 <Rellik_> right, that's the thing - they tend to be elegant (and thus trivial when you understand the concept) so you can kind of build your way up to understanding how to write functionally
22:15:21 <shachaf> ...When looked at as proofs, that is.
22:15:28 <danharaj> I really shouldn't show you my code then.
22:15:34 <Twey> Haha
22:15:46 <Rellik_> i mean the library functions like scanf or the various functors/monoids
22:15:50 <Rellik_> *scanl
22:15:56 <danharaj> yes, code that people share usually is elegant
22:16:01 <Eduard_Munteanu> Heh, interesting typo.
22:16:02 <danharaj> code that *I* write is a horrible lovecraftian mess.
22:16:08 <dmwit> ?quote Cale functional programmers
22:16:09 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
22:16:12 <danharaj> :t scanf
22:16:13 <lambdabot> Not in scope: `scanf'
22:16:16 <danharaj> aww :p
22:16:41 <shachaf> Hmm, scanf should be implemenable.
22:16:57 <Eduard_Munteanu> Hm, indeed, what the hell is wrong with these people, we already know IO () is inhabited, yet they write more and more proofs, one more complicated than the other :P
22:17:05 <monochrom> scanf :: String -> Dynamic
22:17:12 <dmwit> Eduard_Munteanu: exactly =)
22:17:17 <Rellik_> use a regex to parse the format string to generate a regex to return th eresult?
22:17:59 <shachaf> "inconsistent intuitionist logic"?
22:18:11 <shachaf> What's intuitionist about it, once you accept that it's inconsistent?
22:18:25 <Eduard_Munteanu> I think he means inconsistency in Haskell, partiality and whatnot
22:18:34 <danharaj> every type is inhabited
22:18:36 <monochrom> though inconsistent, it's still constructive
22:18:57 <Rellik_> not when you can operate on infinite lists =P
22:19:00 <monochrom> or constructivist
22:19:12 <shachaf> Well, if you call "undefined" constructive.
22:19:25 <monochrom> ah, then nevermind
22:19:39 <Eduard_Munteanu> Infinite lists are alright in themselves.
22:19:42 <shachaf> (Isn't that what "inconsistent" refers to?)
22:20:05 <monochrom> (I don't know)
22:20:20 <sdrodge> if I have a monadic Bool, is there anyway to use it in guards?
22:20:26 <Eduard_Munteanu> ((Why would it refer to that?)) :P
22:20:38 <shachaf> Eduard_Munteanu: What does it refer to, then?
22:20:56 <monochrom> ((undefined is one way to obtain inconsistency))
22:21:04 <Eduard_Munteanu> Heh.
22:21:23 <shachaf> Well, yes, I didn't mean only undefined and not recursion/error/etc.
22:21:54 * shachaf vanishes in a puff of orange smoke.
22:21:54 <Rellik_> oh yeah, another problem with Haskell:
22:22:07 <Eduard_Munteanu> A few others I gathered are constructor injectivity and such.
22:22:29 <Rellik_> by allowing you to reason about your code, it FORCES you to understand more math and logic so that you can reason about it effectively =P
22:22:31 <Eduard_Munteanu> *type
22:22:40 <Rellik_> honestly i'm not smart enough for haskell but i'm learning it because i one day hope to be?
22:22:57 <dmwit> sdrodge: yes, for example:
22:23:03 <Eduard_Munteanu> But maybe not everything translates from other languages.
22:23:09 <monochrom> sdrodge: you "b <- monadic'Bool; guard b". you can can it up as "mguard monadic'Bool = monadic'Bool >>= guard" if you like
22:23:15 <dmwit> do { realBool <- monadicBool; case () of _ | realBool -> ... }
22:24:43 <monochrom> actually you can reason about c# code too. look for spec#
22:25:12 <Rellik_> noooooooo!
22:25:14 <Rellik_> i liked C#!
22:25:22 <Rellik_> i guess i have to go back to C if i don't want to learn any more math
22:25:36 <Eduard_Munteanu> I liked plain C and I still like it. :)
22:25:41 <monochrom> for general oop there is alloy. the google phrase is "alloy analyzer"
22:25:54 <dmwit> Didn't they just do a Coq-verified C compiler over at CMU?
22:26:24 <sdrodge> monochrom, dmwit: thanks
22:26:29 <monochrom> there are also several tools for reasoning about c code too. I just forgot their names
22:26:29 <danharaj> not completely verified I think
22:26:30 <Eduard_Munteanu> Now why aren't those things published?
22:26:32 <Rellik_> that sounds possible
22:26:33 <dmwit> One of my colleagues has formalized a large part of the C99 semantics, too.
22:26:33 <danharaj> but a big part of it?
22:26:58 <Eduard_Munteanu> (Or are they?)
22:27:12 <Rellik_> im a grad student there right now, did my undergrad in computer engineering (should have been CS!), it sounds like the type of thing people here would be into =P
22:27:19 <dmwit> I think the former is published, and the latter is being written still.
22:27:29 <Eduard_Munteanu> I mean, all these papers and you'd have a hard time finding software written in Coq, Agda etc.
22:28:13 <Eduard_Munteanu> Or libraries or whatever.
22:28:19 <dmwit> http://compcert.inria.fr/doc/index.html -- INRIA, not CMU
22:28:21 <monochrom> oh, most of them are published
22:28:52 <Rellik_> i know they're doing work on safer C variants
22:28:52 <monochrom> but most #haskell participants hate to admit "c can be reasoned about formally too" so they don't tell you which papers to read
22:29:07 <Eduard_Munteanu> Wow, neat.
22:29:13 <monochrom> just like they never told you about spec#
22:29:20 <blackdog> monochrom: the L4 stuff is all correspondence proofs between haskell and C
22:29:44 <Rellik_> wow, a verified optimizer
22:29:53 <danharaj> huh... I should probably start cabalizing and haddocking my code...
22:30:15 <danharaj> maybe tomorrow :|
22:30:16 <monochrom> haddock your own code for great good
22:30:18 <Eduard_Munteanu> monochrom: oh. I was just asking earlier on if there was anything that could embed C code into a theorem prover and reason about it. It seems they go about formalizing it separately, that must be a tremendous amount of work.
22:30:27 <Eduard_Munteanu> Not to mention performance.
22:30:42 <danharaj> why performance?
22:30:49 <Eduard_Munteanu> blackdog: seL4?
22:30:53 <blackdog> Eduard_Munteanu: yeah. the L4 verified code base is apparently an absolute bear to do proofs with
22:31:06 <blackdog> Eduard_Munteanu: think so. the one the UNSW guys were working on
22:31:12 <blackdog> or NICTA, sholud i say
22:31:18 <Eduard_Munteanu> danharaj: arguably Haskell isn't best with some stuff. Then you've got chicken and egg situations, say proving the Haskell RTS is sound.
22:31:43 <Eduard_Munteanu> AFAIK, they used HOL/Isabelle, not Haskell.
22:32:03 <blackdog> Eduard_Munteanu: they had a Haskell model
22:32:19 <blackdog> the proofs were in Isabelle, but they're correspondence proofs between the C and Haskell models
22:32:35 <blackdog> (i haven't worked on it, but a friend was telling me of his experience in the project)
22:32:53 <Eduard_Munteanu> Also I'm worried, I mean, I don't know how they did it, but trying to write proofs external to the actual code sounds not-so-formally-verified.
22:33:54 <monochrom> all proofs are external unless you do proof-carrying
22:33:57 <Eduard_Munteanu> It's one thing to write the whole program in Coq and have an executable specification as they say, but how does one go about formalizing C? :/
22:34:34 <blackdog> Eduard_Munteanu: in a layered way
22:34:49 * Eduard_Munteanu saw a chapter of proof carrying code in ATTAPL, I might have to look it up further and see what others wrote about that
22:35:08 <blackdog> if you have a series of correspondence proofs, you can prove your actual claims about a simpler model
22:35:21 <monochrom> most of the time you do proof-erasure. now your proof is external.
22:36:23 <Eduard_Munteanu> Well, of course it's external at runtime if that's what you mean. That's what proof irrelevant terms are supposed to do.
22:37:39 <Eduard_Munteanu> Ok, but here's something I've always wondered: there are formal ways of proving a theorem etc. But how do you make sure it matches your model/specification, or that the spec is consistent?
22:38:16 <monochrom> Coq uses the illusion that the spec language, the proof language, and the code language are one, so you feel safe about it. well, that's an illusion
22:38:22 <Eduard_Munteanu> For example, I sometimes wonder "couldn't this function be more dependently typed?".
22:39:12 <monochrom> if you do C, you design yourself a spec language and a proof language. the spec language plays some role of dependent types of Coq
22:39:21 <Eduard_Munteanu> So if there's something such as a maximally strict type for something, how am I sure I chose it?
22:39:38 <Eduard_Munteanu> Ah.
22:40:58 <Eduard_Munteanu> But is the actual code in (say) seL4 checked against the C compiler or the spec language? I imagine there's lots of ways that could go wrong if the first was the case.
22:41:37 <monochrom> all proofs so far already go wrong with the power switch and the cosmic rays
22:42:04 <Eduard_Munteanu> Hm, that's a way to put it.
22:42:47 <monochrom> you have to draw a reasonable line and say, here is the assumed semantics of the code language, too bad if a compiler or a chip breaks it
22:43:36 <Eduard_Munteanu> But i think there's a huge difference between "prove quick sort results in a sorted list" and "prove this code which implements qsort results in a sorted list".
22:44:03 <monochrom> and then, if the assumed semantics is hairy, you start building nice abstraction layers so you remain sane, but that's an engineering concern rather than a soundness concern
22:44:09 <Eduard_Munteanu> Wait no, I'm assuming the compiler is okay, but what if some guy alters the codebase? Can the C code be machine-checked?
22:44:55 <Eduard_Munteanu> Human error is probably the first thing to tackle.
22:46:15 <taruti> Who is responsible for code.haskell.org accounts?
22:47:35 <monochrom> in "prove quick sort results in a sorted list", the code language is a toy language, it has an easy semantics, so the whole work is easy
22:48:09 <monochrom> in "prove this code which implements qsort results in a sorted list", the code language is a real language, its semantics is hairy, so there is more work
22:48:19 <Eduard_Munteanu> If you know about lockdep in the Linux kernel, one example would be to contrast how lockdep checks (given that code runs at least once) that locking semantics are obeyed vs making an external proof about some code which could later change.
22:49:08 <Eduard_Munteanu> I see.
22:49:55 <Kerris> oh cool, didn't know that you could do let x = 9, [x, 2*x .. x*x] with ranges
22:51:00 <danharaj> Why wouldn't you be able to :)
22:51:10 <blackdog> taruti: http://community.haskell.org/admin/account_request.html ? i can't remember who actually has the keys.
22:51:46 <Kerris> danharaj: I'm just a little nooblet with simple assumptions. :3
22:52:14 <danharaj> Kerris: Just keep in mind. A value is a value is a value. That's the first truth of Haskell.
22:52:18 <monochrom> the [a, b .. c] syntax is less well-known
22:52:37 <danharaj> also never ever enum floats.
22:52:40 <danharaj> It's broken.
22:52:56 <Eduard_Munteanu> Well, don't expect to be able to write [2, 3, 5, 7, 11, 13 ..] :P
22:53:09 <danharaj> [1.0,1.2...]
22:53:15 <danharaj> >02 01[1.0,1.2...]
22:53:22 <danharaj> > 02 01[1.0,1.2...]
22:53:23 <lambdabot>   <no location info>: lexical error at character '\ETX'
22:53:28 * danharaj flips a desk
22:53:30 <Eduard_Munteanu> (I mean the primes)
22:53:34 <monochrom> add more spaces
22:53:38 <danharaj> > 02 01[1.0,1.2..]
22:53:39 <lambdabot>   <no location info>: lexical error at character '\ETX'
22:53:50 <shachaf> danharaj: You know your text is colored, yes?
22:53:53 <monochrom> help the tokenizer
22:53:54 <danharaj> >      [1.0, 1.2..]
22:53:54 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.199...
22:53:57 <danharaj> wait it's colored?
22:54:00 <danharaj> no I was not aware.
22:54:02 <shachaf> Not anymore.
22:54:15 <danharaj> strange. anyway, that is why the float enum instance is broken :p
22:54:19 <shachaf> It was dark græy before.
22:54:25 <danharaj> (not really broken, it's just that float should not be an enum)
22:54:27 <Kerris> Eduard_Munteanu: that's a bit too convenient :P
22:54:29 <shachaf> danharaj: What's broken about that?
22:54:57 <taruti> blackdog: I do already have an account, just it doesn't work for me anymore.
22:55:16 <danharaj> shachaf: it's different from [1.0,1.2,1.4,1.6..]
22:55:26 <danharaj> > [0.0..]
22:55:27 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
22:55:35 <shachaf> > 1.4 + (1.2-1.0)
22:55:36 <lambdabot>   1.5999999999999999
22:55:40 <danharaj> > 1.6
22:55:41 <lambdabot>   1.6
22:55:50 <shachaf> Yes. Those are two different values.
22:55:51 <Eduard_Munteanu> Because of 1.0?
22:56:14 <danharaj> hmm
22:56:20 <danharaj> > [1.2, 1.4..]
22:56:21 <lambdabot>   [1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.1999999...
22:56:27 <danharaj> I guess it's consistent in that regard.
22:56:29 <Eduard_Munteanu> erm, or 0.1, I don't remember.
22:56:31 <shachaf> Fine, floating points are weird, and not really Enum -- or Num, for that matter.
22:56:51 <blackdog> taruti: ah, fair enough.
22:56:55 <Eduard_Munteanu> Yeah, they kinda suck at times.
22:57:10 <blackdog> taruti: while you're here - is HFuse actively worked on, moribund, finished and perfect... ?
22:57:25 <danharaj> > 1.6 :: Float
22:57:26 <lambdabot>   1.6
22:57:27 <shachaf> > 0.1+0.2
22:57:28 <lambdabot>   0.30000000000000004
22:57:29 <blackdog> (I'd much rather write this app in haskell than in ruby)
22:57:31 <danharaj> Stop lying to me lambdabot.
22:57:36 <int-e> mm. but why does [1.0,1.2..] result in a parse error? it doesn't in ghci, is there some extension that interferes?
22:57:43 <danharaj> > id 1.6
22:57:44 <lambdabot>   1.6
22:57:46 <Eduard_Munteanu> > 0.1
22:57:47 <lambdabot>   0.1
22:57:53 <Eduard_Munteanu> > 0.1 + 1
22:57:54 <lambdabot>   1.1
22:57:58 <monochrom> that is not the only thing broken. here is a more scary one:
22:58:01 <blackdog> danharaj: ask me no floating point arithmetic and i'll tell you no convenient fictions
22:58:03 <int-e> > [1.0,1.2..]
22:58:04 <lambdabot>   [1.0,1.2,1.4,1.5999999999999999,1.7999999999999998,1.9999999999999998,2.199...
22:58:11 <monochrom> > [1, 3 .. 6] :: [Int]
22:58:12 <lambdabot>   [1,3,5]
22:58:16 <monochrom> > [1, 3 .. 6] :: [Double]
22:58:17 <lambdabot>   [1.0,3.0,5.0,7.0]
22:58:17 <shachaf> monochrom: Yes, that's the think people usually complain about.
22:58:19 <taruti> blackdog: I was just wanting to commit some hfuse mac and freebsd fixes but cannot write-access the repo :)
22:58:25 <danharaj> oh wow
22:58:28 <int-e> ah. wait.
22:58:29 <danharaj> yeah that's way worse
22:58:31 <Eduard_Munteanu> Whoa.
22:58:33 <shachaf> I thought that's what danharaj was referring to.
22:58:36 <int-e> > [1.0,1.2...] -- this failed
22:58:37 <lambdabot>   A section must be enclosed in parentheses thus: (1.2 ...)Not in scope: `...'
22:58:43 <blackdog> taruti: nice:) does hello world actually work on mac, then?
22:58:43 <taruti> blackdog: mostly just applying patches as they are submitted.
22:58:52 <Eduard_Munteanu> How is that explained?
22:58:53 <danharaj> shachaf: I knew there was a reason from a long time ago when I learned it, but I forgot the precise reason.
22:58:57 <taruti> I don't have a mac to test things on, in the past it has.
22:59:04 <danharaj> shachaf: To this day I have not enum'd a float or a double.
22:59:19 <blackdog> taruti: do you have a CI instance or something? i'd be happy to contribute a build slave
22:59:20 <shachaf> Eduard_Munteanu: See the implementation in the Prelude.
22:59:47 <taruti> blackdog: not unfortunately
23:00:13 <blackdog> taruti: ah. i could possibly contribute that too... :) got some up at ci.shimweasel.com
23:01:13 <blackdog> no tests, though...
23:12:28 <fizruk> can I define "class (Monad (f a)) => Magic f where ..." with some annotation that a is arbitrary?
23:19:18 <pastorn> fizruk: why not just "Monad f => ..."?
23:20:38 <shachaf> pastorn: Presumably f :: * -> * -> *
23:28:12 <noj> is there something like the erlang bit pattern matching for haskell?
23:37:18 <ClaudiusMaximus> http://hpaste.org/46097/data_entry  yay for haskell+gtk making my life easier  (now i realize i could have called it "hot or not" instead of "X vs Y"...  if anyone feels like a mini-project, making the number and names of piles configurable could be fun..)
23:48:30 <balor> Given a Data.Set s and my limited knowledge, to generate a powerset I have to (fromList (powerset ( toList s))).  Is there a way of generating the powerset of a Data.Set without converting to a list?
