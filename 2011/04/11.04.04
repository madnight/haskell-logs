00:38:01 <Locke1689> Hey guys I hope someone can help me do something which probably isn't idiomatic
00:38:15 <Locke1689> basically I have a function which is going to be called a bunch of times
00:38:28 <Locke1689> the first time I want it to return 0, second 1, third 2, etc
00:38:48 <Locke1689> I actually do not know how to do this in Haskell yet
00:39:02 <Locke1689> Should I be looking at the State monad or something?
00:40:21 <Jafet> > (id 0, id 1, id 2)
00:40:25 <pacak> Locke1689: Probably you doing something wrong
00:40:40 <Jafet> Well, what you have is not a function, so don't call it that.
00:41:06 <Locke1689> pacak: I'm sure
00:41:11 <c_wraith> Locke1689: the usual way to deal with that is to work with a lazy infinite list
00:41:11 <Locke1689> regardless...
00:41:35 <maurer_> Locke1689: http://www.haskell.org/haskellwiki/New_monads/MonadUnique
00:42:41 <empity> Locke1689: you probably don't need that anyway
00:42:55 <empity> why your "function" (which is not a function) should return different values every time?
00:43:04 <empity> this difference doesn't depend on the input?
00:43:42 <Locke1689> Not explicitly, no
00:43:53 <Locke1689> adding an accumulator or some such now...
00:43:54 <Locke1689> well
00:43:56 <empity> Locke1689: then on what?
00:44:04 <pacak> Locke1689: You can do it within STM or IO monads with TVar for example
00:44:34 <Locke1689> ah
00:44:35 <Locke1689> well
00:44:41 <Locke1689> TVar looks like a decent hack
00:45:59 <Locke1689> The short answer is, yes, there's probably a better way to do ASM x86 label assignment. The long answer is when your professor gives you 3 days to write a compiler to x86 ASM you worry a little less about what the proper way to do things is
00:46:49 * hackagebot tls-extra 0.1.6 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.6 (VincentHanquez)
00:47:27 <shachaf> Locke1689: You can use something like http://www.haskell.org/haskellwiki/New_monads/MonadSupply
00:47:31 <shachaf> Maybe.
00:48:05 <shachaf> Or just State [Label] and use gets head/modify tail.
00:48:14 <maurer_> Locke1689: Incorrect. Always worry about the proper way on deadlines less than a few hours. It seems like it wastes time, but actually saves it.
00:48:37 <Locke1689> maurer_: It is due at 11am. It is currently 2:56am.
00:48:56 <maurer_> Then grab MonadSupply or MonadState and stop talking to us?
00:49:03 <Locke1689> already done :)
00:55:35 <ketil> Shouldn't 'cabal fetch' be able to get me the sources of a library even if it fails to configure (due to missing dependencies)?
00:57:02 <tomberek> I have an issue with an ST monad and strictness.  I'm pretty sure I know the source of the problem, but I'd like to run my reasoning by someone.
00:58:34 <rostayob> tomberek: just go ahead, someone will follow (:
01:03:04 <tomberek> Well, I have been playing with a circular list.  I tie the knots, and then I am able to traverse in O(1).  But I cannot change or edit the list without remaking the whole list.
03:21:17 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
03:21:17 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
03:21:17 --- names: list (clog timchen1a solarus accel carrbs pastorn piis3141 nniro ray Jeena stianhj Draggor Raku^ freiksenet neurogeek||m Belgarion_ Tinned_Tuna sunfun pi8027 TheMoonM_ mietek tessier mjrosenb_ Palmik aiko_ brushbox __jmcarthur bo0ts__ jedai_ afarmer1 jrockway_ iratsu1 cizra2_ JuanDaugherty OnionKnight Saizan_ tbarik alek_br mercurial17 jeffz owst adlsaks rtharper muep HugoDaniel tridactyla jml cwillu_at_work gredman suiside robinbb arnihermann kenneth_reitz freeformz)
03:21:17 --- names: list (sonnym yahooooo gdsx cncl sbok snarkyboojum _mpu norm2782 mrshoe companion_cube pantski mornfall go|dfish minsa lacus psychouroboros nominolo andrewsw nlogax Vq_ tengen mafs_ mattam AnAdorableNick ibt Guest97102 olsner rothwell_ copumpkin Sunhay BrianHV_ agundry ve qebab kloeri Draconx|Laptop deavid aristid tildedave klugez septomin ricky Veinor quicksilver dual Snufsen davidL drhodes nornagon angstrom burp willb Eliel Ke a11235 simonmellor pygmalion Jonno_FTW)
03:21:17 --- names: list (Yahovah harlekin johs davean oc xcombelle tlrobinson wagle Watermind eikke nyingen xinitrc guerrilla Jaak pantsd kelvie paolino Athas homie` Zeiris_ Denebola` shiduke nick8325 sigue_ dblhelix zasimov Eduard_Munteanu inr_ opqdonut_ ortmage1 PepeSilvia Heffalump Laney Snark_ poucet_ steve_hi` Starfire_ perlite jonafan_ nff ariabbas Y_Less magthe Jafet mmaruseacph2 RayNbow`TU jejansse kaf3ii lunaris comak Khisanth Amagineer inad922 Tomsik dcoutts zax joeytwiddle)
03:21:17 --- names: list (ddarius Nisstyre smadge rovar anderson dfeuer cheater00 exlevan Fuco sordina Fullma \yrlnry Draconx noj mkscrg mosheee jonrh brixen rsuniev2 Skola thoughtpolice geekosaur _bitbucket Hugglesworth pesco dobblego sShintah gseitz_ samferry cozmic kaol Enigmagic novas0x2a canvon trez Liskni_si orbitz palmje stepnem bremner`` jnj jlewis hvr_ monochrom chromakode snorble Berengal joelb jql wolv mun_ Ferdirand kosmikus jackSmith eno mercury^ blackdog arlinius shamster)
03:21:17 --- names: list (lsthemes beanmachine ousado aculich_ koninkje_ ccasin jb55_ And[y] vegai_ wjt_ sjanssen_ zomg_ cibs_ Silex_ gereedy_ shachaf sepp2k elventear dilinger troofax_ roelvandijk__ xsdf hiredman_ int-e_ KitB scm naota` zakwilson agemo_ Arnar_ Iyavv_ wtetzner_ unfo- Seta00_ whoops_ tlockney_ TheColonial_ hpc_ funscala `0660_ clanehin_ abojep Volatile_ waterlaz JaffaCake roconnor m3ga zenzike tomberek Muad_Dibber rostayob ggxymd jeltsch gehmehgeh ketil MoALTz Beetny)
03:21:17 --- names: list (jaspervdj boegel oc80z killown illissius insomniaSalt janbanan adrake empity tlonim gaar hackagebot synonymous parcs pacak c_wraith akamaus mauke danly wtw shintah jutaro znutar dogmaT ExtraSpice alip SonicvanaJr augur kvey lbc FDFlock andersk borism solidsnack Nereid Cerise ViciousPlant Vorpal geekounet npouilla1d flamingspinach alexsdutton electrogeek fcr adnap freedrull thetallguy thorkilnaur chitragupt gienah_ Aisling_ sutats_ MacCoaster owain_ alexbobp_)
03:21:17 --- names: list (schroedinbug ngochai_ Gertm` tromp__ brisbin_ edenc confound_ scsibug_ CosmicRay _2x2l_ jcapper_ helgi jan247 tataa ion dreixel_ lpsmith ski vili Cale ivan mm_freak tlk inimino anonchik magicman dolio anonus akosch Taggnostr2 liyang_ alpounet dons_ Boney_ _soro_ regalia_ wunki tumdum__ Paradox924X xinming PreciousMetals Ornedan Derander Lemonator mimi1vx bl4ck Gracenotes mortberg sshc Cthulhon| MrDomino niko dixie ClaudiusMaximus wto mrd jyyou ziman bqf earthy)
03:21:17 --- names: list (gwern djahandarie deggis lyn KittenBitten Innominate hellige emporas_ tew88_ Aestas_ osfameron hyko _erik_ dumael_ popsi_ Niedar Cobra_ xplat ilab Younder neurocyte mahrz_ Dashkal otto_s_ ormaaj arcatan_ EvanCarr1ll moshisushi lowasser chrissbx dropdrive @ChanServ idoru ian_mi tomaw maurer_ Kottizen1 cjay repnop devinus_ skiold_fora ace2001ac ville Hunner_ aleator noddy Guest96022 cafaro ChongLi DrSyzygy Nanar appamatto cathper eyck tmuki arkx jvogel ReinH)
03:21:17 --- names: list (DustyDingo Gilly flori_ jlouis CindyLinz bxc koala_man bezik DRMacIver mike1703 dorkitude caligula_ liesen dom96 Zol McManiaC dionoea Fingerzam Rooz ttblrs janne pettter saurik saiam byorgey obcode mux reacocard sajkr ixzkn tieTYT udoprog_ Botje integral absentia Vulpyne Neronus MasseR jd10 rokoteko periodic ahf fabjan systemfault comex_ hzh faj idnar jystic slabanja zygoloid ksandstr david` politik Raynes erk derrotebaron ps-auxw ibid nimred ido cods shepheb)
03:21:17 --- names: list (pr emias Eelis warzl Gunnar Nshag KaneTW almostsix blomqvist edwtjo jix skaar tamiko nihtml ankit9 ajhager ec|detached eZet snr liw dMazz TML djanatyn malorie MK_FG hammi jbauman profmakx myu2 kalven lantti Twey kalivha larsrh dmwit moozilla Bassetts dqd felipe_ mlh kolmodin cynick ecooper drbean damex frerich2 espringe Modius dcolish preflex sophacles bsod2 xenocryst digitteknohippi1 xarch_ hgolden setmeaway c1de0x Igloo sipa etpace _Mitar wires majoh rien)
03:21:17 --- names: list (Astro dankna shutdown_-h_now cognominal alios jmv noam BlankVerse argiopeweb iFire __nickm__ flux xcvii_ mwc_ duairc_ uber_mort BMeph domme BONUS_ tafryn_ ahihi2_ jackhill_ jho_ scree_ Baughn tswett herzen aavogt ihckt Philonous cubi cyanoacry milli yottis hc__ StoneToad nazgjunk anders^^ Zao szbalint_ saati ernst_ tmielika __marius__ jamwt taruti dino- Philippa em Lemmih [mth] lostman theorbtwo stroan bd_ dRbiG kevinww FauxFaux raek_ rwbarton Obfuscate sohum)
03:21:17 --- names: list (nathanic thetallguy1 pingveno brett vav impl copton stesh luite Boxo timestart Martty elliottt Maxdamantus osoleve newsham teratorn amiri PHO_ mikeg gbeshers SimonRC Bwild kermit)
03:21:31 <zenzike> ah good point. silly me.
03:21:40 <Jeena> all the way up I have a "show err" which should print out the errors
03:23:13 <Jeena> and as faar as I can tell it doesn't update the sate (but it should)
03:24:18 <Jeena> it's just therefore I added the trace, to see if the code is being run or not at all
03:25:32 <zygoloid> Jeena: well, the problem is not local to this code, whatever it is.
03:25:38 <mrcarrot> can this line be made shorter and more simple. it is at least working in current form:
03:25:38 <mrcarrot> where allMoves = [(x,y,z) | x<-[0..a], y<-[0..b], z<-[0..c], (y==b && z==c) || (x==a && z==c) || (x==a && y==b), (x,y,z)/=(a,b,c)]
03:26:18 <Jeena> hm ah ok, I'll upload the whole file then just a moment
03:26:32 <Jeena> https://gist.github.com/901430
03:28:28 <argiopeweb> Can you export a symbol from an import?
03:29:29 <zygoloid> mrcarrot: | x <- [0..a], y <- [0..b], z <- [0..c], length (filter id [x==a, y==b, z==c]) == 2
03:31:03 <adimit> Hi, I'm trying to install network (as a dep for hxt,) but it seems changing to ghc 7.0.2 kind of messed up the build there: http://hpaste.org/45267. I guess it's best to just get the source, fix it and *then* install?
03:31:40 <zygoloid> argiopeweb: yes, you can re-export imported symbols.
03:31:54 <Jeena> modifying the env in my state works nice everywhere else
03:34:25 <zygoloid> Jeena: checkFun is overwriting the resulting state
03:34:59 <Jeena> oh damn it, you're right
03:35:01 <argiopeweb> zygoloid: Fantastic, thanks.
03:35:12 <zygoloid> Jeena: to avoid that sort of bug, you might like to use modify instead of get/put
03:35:15 <Jeena> thanks, I'd never find out
03:35:34 <Jeena> hm, there is a modify? have to look that up
03:37:42 <Jeena> ok now it works, thanks zygoloid 
03:39:55 <zygoloid> np
03:47:20 <MasseR> How long does it usually take to get hackage credentials?
03:52:18 <rostayob> MasseR: not much
03:53:00 <Eduard_Munteanu> Until someone evaluates your request :P
03:53:01 <kenneth_reitz> is https://github.com/ghc/ghc the official repo now?
03:53:01 <MasseR> Five days now :P
03:53:43 <kenneth_reitz> ^^ serious question. for the github blog.
03:53:59 <rostayob> MasseR: really? if you mean the hackage username and password thing, it took like 2 hrs for me yesterday
03:54:28 <aleator> Hmm? ghci says: "but its type `[a0 b0 c0]' has none". What kind of type is [a0 b0 c0]?
03:55:05 <rostayob> aleator: some types that ghc has infered automatically
03:55:11 <sipa> list of (a0 applied to b0 and c0)
03:55:35 <MasseR> rostayob: Exactly
03:55:47 <MasseR> I sent mail 31. last month
03:55:56 <rostayob> MasseR: try again
04:10:36 * hackagebot hakyll 3.0.2.2 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.2.2 (JasperVanDerJeugt)
04:10:44 <vegai_> <3 hakyll
04:12:23 <jaspervdj> vegai: thanks
04:12:31 <vegai> :)
04:19:37 * hackagebot amqp 0.2.8 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.8 (HolgerReinhardt)
04:26:37 * hackagebot amqp 0.2.9 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.9 (HolgerReinhardt)
04:30:31 <ManateeLazyCat> Hi all. :)
04:30:47 <Botje> hello!
04:30:56 <ManateeLazyCat> Botje: Hey. :)
04:31:12 * ManateeLazyCat Downloading ghc-7.0.3, rebuild again. :)
04:35:32 <unfo-> btw. <3 Hoogle
04:41:39 * aleator grins like the cheshire cat
04:42:01 <aleator> Someone just asked me a random bit of a code to be put on a cover of a publication :)
04:42:28 <aleator> Which kinda represents our department to outside world.
04:42:57 <aleator> Me being the only one who uses haskell around here..
04:43:05 <opqdonut_> :)
04:43:56 <vegai> aleator: wait, isn't ibid there?
04:43:59 <Skola> that's quite a fun opportunity aleator ^^
04:44:10 <aleator> Now I must find the most haskellish bit of haskell and submit that. Must not give wrong impression about the tools used here :)
04:44:35 <aleator> vegai: I don't think he currently does much with haskell, but I might be wrong
04:44:49 <vegai> oh, right. You actually *actually* do it :)
04:45:03 <vegai> or actually do *do* it
04:45:15 <aleator> vegai: All my software for past five years have been in haskell or eventually converted into it.
04:45:22 <vegai> impressive
04:45:25 <vegai> most impressive
04:45:31 <aleator> Some big local forestry businesses have not been impressed :)
04:45:38 <Skola> hah
04:46:11 <vegai> let me guess "waaah, where can we find cheap resources to maintain this?"
04:47:34 <aleator> vegai: :)
04:48:15 <gay> slow
04:48:53 <gay> so slow
04:49:16 <unfo-> is there a better way to reverse a number (123 -> 321) than this: revInt i = read (reverse (show i))::Integer
04:49:21 <gay> yes
04:49:41 <gay> use the force
04:49:51 <roconnor> > read (reverse (show (-1)))
04:50:03 <roconnor> @bot
04:50:07 <roconnor> :(
04:50:13 <gay> :)
04:50:20 <Jafet> *** Exception: Prelude.read: no parse
04:50:21 <unfo-> ah. my mistake. I meant to say only for positive integers :)
04:50:41 <roconnor> unfo-: that is not an unreasonable way
04:50:46 <zygoloid> > read (reverse (show (-1))) :: Int
04:50:52 <gay> read (reverse (show (-1))) :: Int
04:50:57 <gay> ^
04:51:22 <Jafet> Oh wow, I evaluated zygoloid's code before he posted it
04:51:34 <gay> :)
04:51:37 <unfo-> roconnor pasted it before :)
04:51:46 <Jafet> No, that one's just invalid
04:51:51 <gay> >.<
04:51:57 <unfo-> oh right.. :: Int missing
04:52:02 <gay> ^
04:52:21 <roconnor> Jafet: no eager evaluation here plz
04:52:37 <zygoloid> > fst (head (reads (reverse (show (-1))))) :: Int -- :)
04:52:45 <gay> :)
04:53:00 <gay> xD
04:53:11 <Skola> gay sort your life out :D
04:53:21 <gay> :~(
04:53:22 * roconnor really really wants readsEither exported
04:53:41 * hackagebot zsh-battery 0.2 - Ascii bars representing battery status  http://hackage.haskell.org/package/zsh-battery-0.2 (MatsRauhala)
04:55:07 <Jafet> Yeah zsh drains your battery really fast
04:57:43 <tibbe> We need more Google Summer of Code students! Anyone here teaching Haskell and have some good students to spare? :)
04:58:03 <companion_cube> what are the projects ?
04:58:43 <shachaf> I might be able to participate on a technicality.
04:58:59 <shachaf> Maybe I should figure that out. Probably wouldn't work out, though.
04:59:19 <rostayob> what would be the preferred method to convert a CompactString to Text, and the other way around? what I do now is fromByteString_ . encodeUtf8
04:59:25 <rostayob> and decodeUtf8 . toByteString
04:59:47 * shachaf >>= undefined
05:00:19 <Jafet> What's a CompactString?
05:00:23 <rostayob> tibbe: I'm not teaching haskell but I'd love to partecipate!
05:00:47 <rostayob> Jafet: http://hackage.haskell.org/package/compact-string , this, sadly the mongoDB bindings use this
05:00:58 <Jafet> Hrm
05:01:13 <rostayob> tibbe: what's the level of skill required?
05:01:40 <Jafet> If you're dealing with long long strings, it might be better to go to lazy Bytestring, map encodeUtf8 . toChunks and concat into a lazy Text
05:01:50 <tibbe> companion_cube, up to the students, but we have an ideas list
05:01:56 <Jafet> But encodeUtf8 is what I use for ByteString
05:02:11 <tibbe> rostayob, then apply! :)
05:02:25 <tibbe> rostayob, you should have done some haskell before
05:02:36 <rostayob> tibbe: well I certainly did some haskell before :P
05:02:56 <jaspervdj> I'm still writing on my proposal
05:03:13 <tibbe> rostayob, http://hackage.haskell.org/trac/summer-of-code/wiki/Soc2011
05:03:20 <tibbe> jaspervdj, good!
05:03:28 <vegai> I'm forever a student..
05:03:41 <tibbe> jaspervdj, could you write more than one in case it collides with some other student? at least so you have a short backup proposal
05:04:00 <tibbe> Here are some projects I'd like to see done: http://blog.johantibell.com/2011/03/summer-of-code-project-suggestions.html
05:05:12 <rostayob> tibbe: cool. I still don't know if I'll get my internship, is it bad if I apply and then I can't partecipate?
05:05:27 <jaspervdj> tibbe: OK, good idea. I was currently working on a proposal for the UTF-8 thing since it relates to my interests and previous experience.
05:05:58 <tibbe> rostayob, no, but please make a note and let us know as soon as you know whether you get the internship or not
05:06:14 <tibbe> jaspervdj, the UTF-8 thing doesn't have strong competition at the moment :)
05:06:27 <rostayob> thinking about it I'd probably prefer to do this than to intern for google ehe
05:06:28 <tibbe> jaspervdj, but please make a second proposal anyway, at least a short one
05:06:41 <tibbe> rostayob, which google office?
05:06:49 <frerich2> tibbe: Parallel builds for cabal was actually on my list of projects to work on; I'm not a student though. Is it possible to coordinate this work somehow, just in case you find a student working on this?
05:07:29 <tibbe> frerich2, we'll most likely find a student for that particular project as we have a few applications. once GSoC starts you could always contact the student
05:07:33 <rostayob> tibbe: eh if I knew! basically I passed all the interviews but they're still placing me, and they don't know if they have enough places or something like that. I should know in a couple of weeks. one of the eu offices anyway
05:08:16 <tibbe> frerich2, note that it's kinda hard to be two people on such a task, might be better to work on something related, like adding support for building many local source trees at the same time (e.g. if you have a local project with local deps)
05:08:33 <tibbe> rostayob, ok, I'm in the Zurich office
05:08:43 <tibbe> rostayob, please apply and add that cavate
05:08:55 <tibbe> caveat 
05:10:49 <rostayob> ok, I'll apply soon. It'd probably be something related to type-safe interaction with databases
05:11:03 <rostayob> I'll think about it anyway
05:11:05 <tibbe> rostayob, ok, please also have a look at the ideas list
05:11:08 <tibbe> rostayob, thankws
05:11:23 <tibbe> anyone else who wants to sell their solve to haskell.org this summer? ;)
05:12:02 <rtharper> don't look at me, I'm working on UHC all summer ;)
05:14:11 <ManateeLazyCat> tibbe: I wonder if someone interested my project (http://hackage.haskell.org/package/manatee http://goo.gl/MkVw) and help me write some application in Google Summer. :)
05:14:25 <kosmikus> rtharper: you are?
05:14:47 <rtharper> kosmikus: yeah, working on supercompilation with Atze
05:14:47 <jaspervdj> rtharper: Ping me when you attend a dutch hug meeting this summer, then I might attend as well (it's not far from here).
05:14:57 <rtharper> jaspervdj: cool, I shall =)
05:15:04 <kosmikus> rtharper: oh nice. are you going to Utrecht for the whole summer?
05:15:20 <rtharper> kosmikus: Yep! I'll be there from June to Sept
05:15:28 * rtharper is currently having Schengen Area sadness
05:15:32 <kosmikus> great
05:15:45 <rtharper> want to buy European nationality, kthx
05:16:00 <ManateeLazyCat> tibbe: I hope find someone help me, haven't so much time hacking haskell like before. :)
05:16:36 * ManateeLazyCat Re-Compile all with ghc-7.0.3
05:16:46 <sordina> Hey. I'm just trying to figure out Binary, and am getting some unintuative behaviour: http://codepad.org/0iBJdMuW... foo returns [A,A,A]
05:16:55 <rostayob> tibbe: bad connection... I think I'd be good for the hackage rewrite
05:17:03 <rostayob> and for the HDBC rewrite
05:17:17 <rostayob> tibbe: oh, the couchdb one!
05:17:28 <rostayob> I'm actually already doing it lol
05:18:03 <rostayob> tibbe: how does it work? is there a cap on the number of proposals that will be accepted?
05:20:34 <jaspervdj> rostayob: Yes, google determines the number of places available afaik
05:21:37 <rostayob> and how does the selection works? is it on the mentors, on google, or on both?
05:23:04 <rostayob> also, is there a deadline after which the projects get selected or is it first come first served?
05:24:21 <tibbe> ManateeLazyCat, well, there's lots of competition in the Haskell IDE space right now which makes it a bit harder to get such a project accepted (as it would only benefit some fraction of all Haskell users)
05:24:22 <jaspervdj> rostayob: The mentors select the students
05:24:50 <ManateeLazyCat> tibbe: Well, it's not IDE. :)
05:25:03 <tibbe> rostayob, we currently code use some more proposals to fill all of our slots
05:25:22 <tibbe> rostayob, selection is done by voting among mentors, based on reading the proposals
05:25:31 <quicksilver> sordina: you're putting ints but getting word8s
05:25:36 <ManateeLazyCat> tibbe: Watch http://www.youtube.com/watch?v=weS6zys3U8k , you will know it's not just IDE. :)
05:25:46 <rostayob> tibbe: I see. is it possible to submit more than one proposal?
05:25:50 <tibbe> rostayob, the deadline for submission is April 7th (IIRC) and after that the mentors discuss/vote
05:26:11 <quicksilver> sordina: try put = put . (fromIntegral :: Int -> Word8) . fromEnum
05:26:21 <tibbe> ManateeLazyCat, cool, the same comment applies though I think
05:26:42 <quicksilver> sordina: or, put = putWord8 . fromIntegral . fromEnum
05:26:49 <quicksilver> the latter looks more symmetric to your get instance.
05:27:15 <ManateeLazyCat> tibbe: I call it "The Haskell/Gtk+ Integrated Live Environment", it's will include IDE, and will include many features that IDE won't do.
05:27:24 <ManateeLazyCat> tibbe: Simple, ILE. :)
05:27:25 <tibbe> ManateeLazyCat, cool!
05:27:34 <tibbe> nice background music ;)
05:27:35 <rostayob> tibbe: ohhh it's soon, ok I'll see (:
05:27:40 <rostayob> thanks a lot for the info
05:27:53 <tibbe> rostayob, you're welcome
05:28:19 <ManateeLazyCat> tibbe: It's a new OS-like environment like Emacs, but not just do text process.
05:28:25 <sordina> quicksilver: thanks! I thought fromIntegral would do the translation
05:28:35 <rostayob> tibbe: do you do haskell related stuff as google?
05:29:34 <quicksilver> sordina: it will. You did not call fromIntegral.
05:29:43 <quicksilver> sordina: "put = put . fromEnum" was your code.
05:31:06 <ManateeLazyCat> I will release new version Manatee in this month ....
05:31:28 <sordina> quicksilver: Ah yes that's true... 
05:32:01 <tibbe> rostayob, I
05:32:03 <ManateeLazyCat> In next version, will include some cool features, such as, you can save/restore state between startup, then you use Manatee do something, shutdown and re-startup, everything is same as before exit.
05:32:20 <tibbe> rostayob, I'm part of a Haskell 20% project but mostly I do C++, Python, and JavaScript
05:32:31 <tibbe> ManateeLazyCat, nice
05:32:39 <rostayob> tibbe: ok, I'm interested in the hackage rewrite one and in the couchdb bindings... can I submit them both or do I have to choose?
05:33:07 <rostayob> tibbe: oh ok, I would've been surprised if haskell had penetrated google ehe
05:33:09 <tibbe> rostayob, submit them both
05:33:28 <rostayob> tibbe: ok, cool
05:33:32 <tibbe> rostayob, there are lots of people who are into haskell here now, we're working on making it be usable at google
05:33:37 <tibbe> rostayob, lots of infrastructure work
05:35:07 <rostayob> tibbe: I think that there are three problem with haskell 1) it requires programmers to be smart and to be willing to study 2) ghc haskell is *huge*, it's really hard to keep track of everything 3) there are a lot of ways to do everything, and you'll always wonder if you choice is the right one :D
05:35:17 <rostayob> so I don't see haskell ever going really mainstream....
05:36:19 <ManateeLazyCat> rostayob: My Answer: "Code you can believe!"
05:36:30 <quicksilver> (2) is a spurious point, rostayob 
05:36:36 <quicksilver> C++ is huge.
05:36:39 <Jafet> C++ satisfies all three properties
05:36:46 <rtharper> kosmikus: you are no longer at Utrecht, right?
05:36:47 <quicksilver> perl is huge if you include CPAN
05:37:01 <quicksilver> java is huge if you include commonly used libraries + frameworks
05:37:21 <hpc> java is huge if you include the STANDARD library
05:37:21 <quicksilver> (3) is spurious as well - there are lots of ways to do everything in most popular languages.
05:37:22 <rostayob> quicksilver: it's different. I'm talking about what I see as language features
05:37:25 <Veinor> yeah, I wouldn't say that haskell is a particularly large language
05:37:27 <kosmikus> rtharper: no
05:37:33 <yottis> frankly, haskell requires a really large time investment
05:37:45 <quicksilver> all programming languages require a really large time investment.
05:37:45 <rostayob> like template haskell, rank-n types, all the syb stuff
05:37:59 <yottis> and in my experience it's not the best language if you need to get the job quickly done
05:38:06 <Veinor> one of my random annoyances about haskell is the line of imports that pretty much any sizeable program will have, but that's a minor nit
05:38:10 <quicksilver> it takes years to become competent in java - and yet java is an industrially popular language.
05:38:18 <yottis> which is a big portion of jobs that need to get done
05:38:23 <rostayob> quicksilver: it takes more time to truly understand haskell
05:38:24 <Skola> define competent quicksilver ;D
05:38:32 <hpc> quicksilver: i would argue it takes "year" to get competent in java
05:38:52 <rostayob> "i want to learn haskell" "ok, but first, a little bit of category theory"
05:39:11 <ManateeLazyCat> I think most people for Haskell will say: "Hey, how many people use Haskell? It's not a popular language", i always answer: "Haskell is right choose, why not do something make it better? Not just talk? "
05:39:22 <quicksilver> rostayob: rubbish.
05:39:29 <quicksilver> rostayob: I'm sorry but that's really ridiculous.
05:39:31 <Saizan_> rostayob: pick a different lecturer/tutorial :)
05:39:31 <rostayob> quicksilver: that was a joke.
05:39:33 <kosmikus> rtharper: sadly, I'm no longer in Utrecht. but I might be around for the summer school in August.
05:39:56 <quicksilver> I think you are being wildly inconsistent.
05:39:58 <yottis> i don't consider myself especially stupid, and the more esoteric type stuff is just way too complex, or there just hasn't been good documentation to explain it quickly
05:40:19 <rostayob> quicksilver: in my experience, haskell requires way more study to understand
05:40:21 <quicksilver> It does time a long time to understand haskell in depth, sure - but it takes a long time to understand $other_language in depth too.
05:40:38 <quicksilver> and many people make money programming without understanding their language in depth.
05:40:39 <rostayob> quicksilver: what I'm saying is that haskell requires more time
05:40:56 <quicksilver> Yes. I hear what you're saying.
05:41:02 <quicksilver> I don't agree it's a very significant factor :)
05:41:10 <yottis> it just seems to be that to do proper haskell is more or lessa full-time job. that probably applies to other languages as well, but the learning curve is pretty steep
05:41:12 <rostayob> quicksilver: I think it is
05:41:41 <rostayob> well more than *I think* that's what I see. at least for me and for the people I know haskell required more thinking
05:42:03 <rostayob> maybe is just that 90% of programmers start with a different mindset
05:42:07 <quicksilver> programming is hard, all programming languages are hard to learn.
05:42:18 <quicksilver> most people come to haskell with some hard-won knowledge of other languages
05:42:29 <quicksilver> which turns out to be somewhat inapplicable to haskell
05:42:38 <yottis> i tried to convert a couple of friends to haskell, but once they started thinking it will take months before they can pull off any useful code, they just weren't interested anymore
05:42:38 <rostayob> quicksilver: we understood that. it is harder to wrap you head around haskell than to wrap your head around python, that's all I am saying
05:42:54 <frerich2> I tend to agree with rotayob in that the Haskell community is (my humble impression) much more 'formal' or 'academic' than your favorite bread-and-butter language. I'm not saying it's a bad think, I just noticed that Haskell introduces quite a lot of vocabulary which makes a lot more sense if you have a math background.
05:42:57 <ManateeLazyCat> quicksilver: Give up, don't talk more..... I always talk "How wonderful Haskell is", but it can't change anything... i won't recommend Haskell to my colleague anymore...
05:43:01 <yottis> maybe it's partly related to library support etc. but i don't think that's the main cause
05:43:20 <quicksilver> rostayob: if you already have 5 years programming experience of (say) BASIC, C and then Java, then haskell is harder to wrap your head around than python.
05:43:29 <rostayob> and I say that being an hardcore haskell evangelist in my course :P. I think it's totally worth the thinking it requires
05:43:45 <quicksilver> if you have zero programming language experience at all, than haskell and python are equally mystifying.
05:44:04 <quicksilver> ManateeLazyCat: I'm actually not talking about how wonderful it is.
05:44:09 <Jafet> Haskell is like Greek to most people, alpha beta eta lambda mu omega
05:44:22 <rostayob> quicksilver: well I'm in a cs department, and people came without knowing how to program. the course *starts* with haskell, haskell is the first piece of code you see (that's how I met haskell). Now, it's like 5 of us still using it
05:44:24 <quicksilver> ManateeLazyCat: I simply strongly disagree with someone's list of "three problems of haskell"
05:44:26 <hpc> if you have zero programming experience and some math experience, haskell will be the less mystifying alternative
05:44:30 <rostayob> and most people still don't understand
05:44:38 <hpc> even if all you really know is algebra
05:44:43 <ManateeLazyCat> quicksilver: Someone not worth to debate, it's can't change anything actually.
05:45:21 <ManateeLazyCat> quicksilver: Hehe, ignore them, because they don't want to learn Haskell, they just want debate.
05:45:30 <ManateeLazyCat> :)
05:46:25 <rostayob> quicksilver: I really don't think that python and haskell would be equally mistifying if you start from 0. I think that the imperative "list of instruction" concept is more appetible than the declarative models for humans, at least at the beginning
05:46:28 <Botje> wrapping your brain around something stretches it :)
05:46:54 <Jafet> Like bubblegum
05:47:03 <Botje> rostayob: people think in terms of groups and operations, not individual elements
05:47:03 <quicksilver> rostayob: having taught programming myself, I disagree.
05:47:19 <quicksilver> rostayob: the "list of instruction" concept is extremely non-intuitive to most human beings
05:47:29 <rostayob> quicksilver: well you are not a good sample, you're one
05:47:32 <quicksilver> they can't accept that you need to list everything, in exactly the right order, in complete detail
05:47:46 <quicksilver> rostayob: I'm talking about the people I taught, which is a sample of a few hundred.
05:48:06 <quicksilver> I'm not particularly suggesting that haskell brings anything better to the table either.
05:48:10 <quicksilver> but I'm not sure it's much worse.
05:48:13 <rostayob> quicksilver: oh, ok. so you teach haskell to what, university students?
05:48:22 <yottis> and yet, you need to understand how a computer works to do haskell well. which requires you to understand how imperative code works
05:48:24 <ManateeLazyCat> rostayob: Haskell is best language i have seen, believe or not. 
05:48:30 <quicksilver> most people find the precision of detail required to program computers difficulat and non-intuitive
05:48:33 <rostayob> ManateeLazyCat: toh, I think the same :P
05:48:46 <Jafet> yottis: loads of people who write imperative code have no real idea how their computers work.
05:48:54 <quicksilver> rostayob: yes, undergraduate and masters
05:49:03 <quicksilver> yottis: that's quite a high value of "well"
05:49:19 <rostayob> quicksilver: I don't know, it's strange that we have such different experiences. In my university, most people at their first encounter find it irritating usually
05:49:20 <quicksilver> yottis: to reach a certain level (in any language) you need a very good understanding of how computers work, it's true.
05:49:28 <frerich2> This might say more about me or some of the people I work with, but I think Haskell is the first programming language where I read tutorials who talk about 'identities' and 'morphisms'. I can imagine it sounds quite abstract if you're sitting at home without any real university education.
05:49:32 <quicksilver> rostayob: I'm not saying people don't find haskell irritating.
05:49:43 <rostayob> quicksilver: well they find the other stuff less irritating
05:49:46 <quicksilver> rostayob: I'm saying that people find other languages a similar amount of irritating.
05:50:00 <quicksilver> frerich2: yes, but that's a fault in the tutorials.
05:50:01 <Botje> frerich2: I blazed through 'a gentle haskell tutorial' and I don't remember seeing those words
05:50:06 <quicksilver> (if true)
05:50:18 <Botje> it's in how you explain it, i guess
05:50:25 * rothwell_ has seen non-programmers deal with simple and consistent rules of scheme and haskell far better than the mess present in something like python or c++
05:50:29 <yottis> we live in an imperative world mostly and imperative languages are what most people will get most value from quickly
05:50:52 <rostayob> quicksilver: eh, we disagree on that :P. anyway, I don't know if it's useful to continue, but I don't ever see haskell taking over other popular imperative programming languages, that's the point I wanted to make
05:51:28 <quicksilver> rostayob: you're probably right, but I disagree with the 3 reasons you gave.
05:51:58 <rostayob> quicksilver: what are your reasons?
05:52:05 <quicksilver> massive industrial inertia
05:52:08 <quicksilver> and educational inertia
05:52:11 <quicksilver> tool support, OS support
05:52:16 <Jafet> And monad tutorials
05:52:16 <quicksilver> training programs, job market
05:52:17 <moshisushi> rostayob: the slogan "avoid success at all cost" was established to guarantee that :)
05:52:21 <quicksilver> all these things make change pretty slow.
05:52:22 <rtharper> kosmikus: cool, I'll be there from some of it, although I'm gone for one week of that ;)
05:53:05 <akamaus> Hi there. I'm trying to write a type safe wrapper for running shell commands on local host and over ssh. In the middle of refactoring I stumbled upon a compiler error. I don't quite understand the reason for it. http://hpaste.org/45271/troubles_with_the_shell_comman
05:53:08 <benmachine> I think functional programming has become more fashionable
05:53:23 <rostayob> quicksilver: So you think that the reason is in how the world is, not in haskell (:. I agree, but I think it's only a partly because of that
05:53:42 <benmachine> and it might never become the most popular thing but it will continue to grow
05:54:00 <frerich2> rostaybob: I think Haskell (and other functional programming languages) are already 'taking over' the etablished imperative programming approaches. It's just not one big step. You rather see things like list comprehensions and lambdas and type inference sneaking into other languages.
05:54:03 <ManateeLazyCat> Do something for haskell community or shut-up
05:54:17 <Jafet> Way too fashionable
05:54:18 <rostayob> ManateeLazyCat: ?
05:54:21 <rtharper> ManateeLazyCat: ?
05:54:27 <benmachine> ManateeLazyCat: ?
05:54:33 * benmachine is a sucker for bandwagons
05:54:39 <rostayob> ? :ManateeLazyCat
05:54:43 <benmachine> Jafet: I do not follow
05:54:44 <rothwell> i get to write programs that work whilst competing developers spend all day accidentally corrupting their data structures!  \o/
05:54:48 <ManateeLazyCat> It can't change anything if we just talk,
05:54:52 <rostayob> frerich2: yeah exactly, and that's good
05:54:55 <ManateeLazyCat> We need really is "do it!"
05:55:05 <benmachine> ManateeLazyCat: no we need both
05:55:22 <rtharper> ManateeLazyCat: do what, exactly?
05:55:30 <benmachine> you can write all the amazing things you like but if no-one's heard of them it won't do any good :)
05:55:34 <rostayob> ManateeLazyCat: I think that the haskell community is in great shape
05:55:40 <ManateeLazyCat> If believe Haskell, okay, then do something change it, and don't care "how about other people think"
05:55:42 <moshisushi> ManateeLazyCat: no, if we just "do", we will end up with something like PHP :)
05:55:47 <kaf3ii> comming from a background of c/c++/java/python i think haskell brings forward the fun parts of programming
05:55:56 <frerich2> kaf3ii: ack!
05:56:22 <ManateeLazyCat> rtharper: Everything, write haskell code, help other test library, 
05:56:39 <rostayob> ManateeLazyCat: you're talking like if haskell is sinking and we need to save it. I think that haskell is doing great eheh
05:56:40 * rtharper writes haskell code every day.
05:56:47 <rtharper> It's my best proof assistant ;)
05:57:15 <frerich2> I've got a 40h/week C++ job and yet I spend (some, as family permits, ahem...) some time on Haskell in the evening, simply because you don't have to worry about boring stuff all the time. And sometimes I can hardly believe how good a time I'm having (which is something I only had as a teenager when writing graphics libraries in assembler).
05:58:02 <ManateeLazyCat> rostayob: I just don't like some people talk "Haskell community is small, and not popular language" endless, yes this is truth, "Why not do something change those situation?"
05:58:52 <rostayob> ManateeLazyCat: ? making the haskell community like the c++/java/python one is not certainly my goal. I think that haskell is really good as it is, and constantly improving
05:59:56 <rostayob> Something I'd like is some more documentation, since right now to learn some stuff the only way is to read papers
06:00:07 <ManateeLazyCat> Well, i give up. I won't talk anymore, i just know "I believe Haskell, i'm on my way". :)
06:00:24 <rostayob> ManateeLazyCat: you give up on what? I don't get it
06:00:59 <jeffz> I'll send the owner of the repo an email.
06:01:39 <ManateeLazyCat> co_dh: Hey, how you doing? ;p
06:02:53 <rostayob> quicksilver: I'm actually curious to hear from a teacher why do you think that most people leave haskell behind, even if it's the first thing they see
06:03:14 <rostayob> quicksilver: do you actually think it's only because of the environment?
06:03:20 <jeffz> the atexit stuff seems to happen with other repos, I might have a poke at it another night to see if I can work out what the issue is.
06:03:49 <jeffz> oops, wrong channel.
06:05:10 <medfly> slightly off-topic: how do I figure out the average case performance of an algorithm?
06:05:29 <osfameron> run it in all cases, and take the average!
06:05:43 <medfly> hehehe
06:06:39 <medfly> if only...
06:07:14 <benmachine> work out the best case and worst case, and pick a likely-looking number somewhere in between
06:07:47 <medfly> is it really a concept so vague?
06:08:04 <benmachine> not really
06:08:18 <benmachine> but I don't think there's a general way of doing it aside from osfameron's
06:08:41 * ManateeLazyCat Test gtk2hs with ghc-7.0.3....
06:09:03 <medfly> to be honest I was mostly asked to write something so the average case performance is best
06:09:26 <rtharper> why hello there, netsplit
06:10:00 <medfly> I guess that means "write it so a reasonable input runs fast"
06:10:43 <Jafet> Write something so slow that it takes about the same time for every input
06:11:11 <benmachine> medfly: more or less, yes
06:11:14 <ManateeLazyCat> Hmmm new version haddock is really good that show how many documentation pass with percent. :)
06:11:20 <medfly> okay, good to know :)
06:11:28 <medfly> thank you
06:11:32 <benmachine> it means that pathological cases are ok so long as you don't bump into them too much
06:12:07 <medfly> to be honset, I took digital logic the other semester and looking at all cases was possible
06:12:08 <Veinor> medfly: it's literally 'compute the expected-case running time'
06:12:16 <Veinor> so like
06:12:37 <Veinor> randomized quicksort has O(n^2) worst-case, but that has a probability of O(1/n) of happening or whatever
06:13:08 <ManateeLazyCat> I buy 6GB RAM for GHC compile project, i think now it's enough for it. :)
06:13:11 <Saizan> yeah, you don't need to actually run the algorithm over all inputs to calculate the average running time
06:13:26 <Veinor> you just need to analyze it over all inputs
06:13:30 <medfly> that will be an interesting change, last time I did anything like this I kept looking at super pathological cases that don't happen.
06:14:02 <Saizan> in fact it's important to have a realistic probability distribution for your inputs too
06:14:44 <Dudleyy> Hi, does anyone here works with BNFC?
06:14:44 <medfly> I feel like I'm a robot now. "you must use a more realistic probability distribution for your analysis of an algorithm"
06:14:55 <medfly> well... I mostly go by intuition...
06:16:02 <Jafet> But sir, the odds of navigating a median-of-3 partition are 3720 to 1!
06:16:17 <Veinor> haha
06:16:26 <medfly> lol
06:17:11 <inetic> hi, I'm trying to create an example program which would take up a lot of memory by instantiating a binary tree (tree n = [Node (tree $ n -1), Node (tree $ n -1)]) at once, but I can't see how (because of lazyness of course), would you please suggest some technique? 
06:18:17 <medfly> maybe you can force it to be strict
06:18:40 <Saizan> inetic: just make sure you traverse the whole tree while still retaining a reference to the root
06:19:44 <inetic> Saizan, hmm, interesting, going to try that
06:20:38 <Saizan> if you use strict fields instead you just have to look at the root node to force all the rest
06:20:42 <inetic> (sorry, had a mistake there: tree n = Node [ tree (n-1), tree (n-1) ] should be correct)
06:21:28 <inetic> medfly, Saizan: what are strict fields, where can i read more about them?
06:22:18 <benmachine> Saizan: actually, that might not be enough since the field is a list?
06:22:34 <benmachine> you'd have to use a list which itself had strict fields
06:22:40 <Saizan> true
06:22:59 <benmachine> inetic: in a data declaration you can prefix a field with a ! to make it strict
06:23:16 <inetic> benmachine, aha, right, I've seen those
06:23:18 <benmachine> like data State = St !Integer !Bool
06:23:40 <benmachine> then forcing the value will also force its contents
06:25:37 <inetic> Saizan, if I retain the reference to the root node, will it not retain only the path from root to current node (which would be far less then the whole tree)?
06:26:47 <Saizan> inetic: the root node has a reference to the other branches too
06:27:11 <Saizan> which might or might not be evaluated, depending on if you inspected them yet or not
06:27:25 <inetic> Saizan, aha
06:28:47 <Saizan> another way is: tree n = l `seq` r `seq` Node [l,r] where l = tree (n-1); r = tree (n-1)
06:29:25 <rostayob> what's the best way to test if a Typeable is of a certain type? is comparing DataReps ok?
06:29:40 <Saizan> TypeRep's
06:30:02 <rostayob> yes sorry TypeRep
06:30:16 <benmachine> that shoukd be fine yes
06:30:24 <rostayob> so for example is "typeRep a == typeRep (undefined :: Type)" ok?
06:30:40 <benmachine> *typeOf
06:30:52 <Saizan> yes, you might want to use cast directly though
06:31:46 <rostayob> Saizan: the thing is that I don't have to do anything with that, I just need to know which type they are
06:32:14 <benmachine> rostayob: that's kinda strange, but ok
06:32:30 <rostayob> well actually... I can do it with cast with another function
06:32:40 <rostayob> benmachine: I put different types in different places in a database
06:33:13 <benmachine> rostayob: you could do that with typeclasses, perhaps?
06:33:39 <rostayob> benmachine: what do you mean?
06:34:14 <benmachine> class PutThingInDatabase a where putThingInDataBase :: a -> IO ()
06:34:16 <benmachine> or whatever
06:34:26 <benmachine> then you don't test the type at runtime but at compile time
06:35:03 <rostayob> benmachine: well that's what I'm doing, the problem is that I need to put data types of the same class in different tables to retrieve them more efficiently
06:35:12 <rostayob> I could have two different functions
06:35:55 <benmachine> it's just slightly strange to me that you would have data being put in a database when you don't already know what type it is, I suppose
06:36:11 <manateeUser> Test Manatee (develop version) with GHC-7.0.3. :)
06:36:17 <rostayob> actually I already do, something like voteSubmission :: Submission -> m () and voteComment :: Comment -> m (). the only difference between those two is that I have to put it in different collections
06:36:18 <ManateeLazyCat> Oh yeah.
06:36:22 <ManateeLazyCat> Looks good.
06:36:54 <manateeUser> Haha, got Manatee running on GHC-7.0.3, thanks GHC team! Great work! :)
06:37:42 <rostayob> benmachine: I'll just keep the two methods separate, thanks anyway
06:39:20 <YoklJO> sorry, noob question (what a noobish thing to say :D), how do i get a list like [1,2,3,5] and return True cause each value is greater than the previous
06:39:50 <jlouis> Cabal question: detailed-1.0 is not a valid test suite.. cabal-install version 0.10.2, using version 1.10.1.0 of the Cabal library -- what do I do?
06:39:59 <jlouis> Warning: 'detailed-1.0' is not a supported test suite version. The known test
06:40:00 <jlouis> suite types are: exitcode-stdio-1.0
06:40:03 <jlouis> is the error message
06:40:12 <benmachine> YoklJO: there are several ways forward
06:40:16 <aavogt> YoklJO: in the Prelude, there are functions   zipWith, >, and tail
06:40:22 <benmachine> YoklJO: some more ingenious than others
06:40:24 <dcoutts> jlouis: right, in the current release it's just the exitcode-stdio-1.0
06:40:28 <maurer_> YoklJO: If you don't care about speed, "increasing x = x == sort x"
06:40:38 <jlouis> dcoutts: ok, what would you recommend I do?
06:40:46 <dcoutts> jlouis: the detailed one is still under development
06:40:55 <jlouis> go with exitcode-stdio-1.0 for now?
06:40:58 <dcoutts> jlouis: yes
06:41:00 <YoklJO> wow i was hoping i could use something close to foldl but alright
06:41:04 <jlouis> thank yee
06:41:11 <Saizan> you can
06:41:13 <Jafet> Actually x == nub (sort x)
06:41:18 <benmachine> YoklJO: there's probably a way using foldr
06:41:30 <maurer_> YoklJO: foldl/foldr will be faster, this is jus the hurr version
06:41:35 <jlouis> YoklJO: there is a recursive variant as well which is straightforward to define, but not as ingenious
06:41:42 <maurer_> Jafet: Why is nub necessary? Is our sort not stable?
06:41:54 <benmachine> maurer_: strictly increasing
06:42:05 <maurer_> benmachine: Oh, missed that :P
06:42:05 <Jafet> Well, yuklj0 should really ask questions more clearly
06:42:11 <Saizan> foldl is not quite great because it'd traverse the whole list needlessly even if it could report False early
06:42:16 <YoklJO> well it made sense didnt it?
06:42:19 <Jafet> Er, YoklJO
06:42:23 <benmachine> well, jafet should really ask for clarification
06:42:31 <jlouis> YoklJO: use pattern matches and a guard to check two elements at a time and then recurse. Handle the empty list and the singleton list as special base cases for your recursion
06:42:39 <YoklJO> [0,5,4,6] is false cause 4 is less than 5
06:42:45 <Jafet> Well, it's more fun to speak like this is third person
06:42:49 <benmachine> YoklJO: what about [1,2,2,3]
06:43:08 <YoklJO> yeah thats true too actually
06:43:15 <benmachine> ah
06:43:18 <benmachine> not nub, then
06:43:35 <YoklJO> i could just make my own function for the purpose
06:43:37 <Saizan> > let isSorted xs = and . zipWith (<=) xs $ (tail xs) in isSorted [1,2,2,3]
06:43:44 <YoklJO> oh cool
06:43:44 <Jafet> True
06:43:53 <Saizan> meh, no bot
06:43:56 <benmachine> Saizan: use drop 1 rather than tail for bonus points
06:44:05 <benmachine> oh actually
06:44:11 <maurer_> benmachine: Why drop 1?
06:44:12 <Saizan> zipWith takes care of that
06:44:17 <benmachine> yeah it doesn't matter
06:44:32 <benmachine> maurer_: drop 1 [] is [] whereas tail [] is *explosions*
06:44:52 <benmachine> I would argue that it is more obviously correct if you avoid tail
06:45:04 <maurer_> benmachine: OK
06:45:20 <Saizan> Cale: lambdabot is missing
06:45:52 <jlouis> dcoutts: exitcode-stdio-1.0 works like a charm, I'll go with that and test-framework then :)
06:46:06 <Saizan> benmachine: i've refrained myself from writing zipWith (<=) `ap` tail, don't ask too much :)
06:46:09 <YoklJO> thanks Saizan
06:46:11 <Saizan> benmachine: but i agree
06:46:12 <benmachine> Saizan: :>
06:46:29 <Saizan> YoklJO: np
06:46:37 <benmachine> YoklJO: do you understand how it works?
06:46:47 <shachaf> Is the fact that zipWith checks its first argument first guaranteed?
06:47:09 <benmachine> shachaf: I don't think so, but it's true
06:47:12 <zenzike> benmachine: wouldn't it be best to use tail, and have an explicit case for xs == [] instead?
06:47:13 <benmachine> and it's reasonable to expect
06:47:19 <benmachine> zenzike: why?
06:47:31 <benmachine> zenzike: that's more typing, and more for the maintainer to read :P
06:47:40 <zenzike> I'm thinking in terms of efficiency and clarity :-)
06:47:45 <shachaf> Well, s/tail/pattern-matching/.
06:47:52 <shachaf> That way you don't have to use evilTail anywhere.
06:48:00 <zenzike> shachaf: yes, agreed
06:48:29 <benmachine> zenzike: in terms of clarity, I think it's debateable, in terms of efficiency, the gain would be at most constant and probably quite miniature
06:48:39 <benmachine> in fact, it might not even be a gain
06:49:07 <benmachine> because you're testing for something that very rarely happens (i.e. calling the function on the empty list)
06:49:36 <Saizan> if a special case is subsumed by general combinators i prefer to avoid making it explicit
06:49:40 <zenzike> it's getting tested in the take 1 though isn't it?
06:50:00 <benmachine> zenzike: well, true, but it's probably getting tested there either way
06:50:07 <benmachine> (drop 1)
06:50:19 <benmachine> so you test it twice or once :P
06:50:36 <Jafet> maybe True id $ liftM (and . zipWith (<=) xs) (safeTail xs)
06:50:37 <benmachine> plus if you leave everything in combinators then magic fusion might happen
06:50:42 <zenzike> benmachine: not if you replace the drop 1 with a pattern match, and provide a version for []
06:50:48 <benmachine> the fusion fairies might wave their wand
06:50:49 <zenzike> benmachine: ah that's a good point
06:51:01 <rly> Also drop 1 could hide what otherwise would be a bug. 
06:51:01 <rly> When in doubt, use Coq. 
06:51:02 <frerich2> Saizan: That's pretty cool
06:51:02 <frerich2> Zipping a list with some variant of itself (like zipping 'xs' and 'tail xs') is a neat way to be able to compare elements with pre-/successors
06:51:02 <frerich2> Reminds me that I recently learned about 'zip l [0..]' as a nice idiom for doing something with elements which is influenced by their position in the list.
06:51:02 <frerich2> Is there something like "Haskell Nuts'n'Bolts" where such handy idioms are collected?
06:51:38 <benmachine> frerich2: I've not heard of such a thing, the wiki would be a good place to put it
06:51:52 <benmachine> a "cute tricks" page
06:51:57 <Saizan> there is in fact an idioms page on the wiki
06:52:04 <benmachine> oh right
06:52:20 <argiopeweb> Is there a way to fix this issue: http://hpaste.org/45272/field_issue ?  I need a fix for situations where you can't pattern match and constructors may not share a field.
06:52:42 <quicksilver> rostayob: well, I've not tried to study the phenomenon. My guess would be, if they're interested in programming/hacking, they take their inspiration from cool tricks and libraries and things they find on the internet - and these things are not in haskell, so they switch language to one which is more fun to play with.
06:53:50 <quicksilver> argiopeweb: define "hasFoo :: Two -> Bool" as "hasFoo (A _) = True; hasFoo (B _) = False" and call that first?
06:54:36 <benmachine> argiopeweb: or you could define withFoo :: (Int -> r) -> Two -> Maybe r
06:55:09 <benmachine> or foldTwo :: (Int -> r) -> (String -> r) -> Two -> r
06:55:42 <YoklJO> benmachine: yeah i do
06:55:48 <benmachine> cool
06:55:57 <argiopeweb> All interesting ideas. I'll play with it and see which scales best. Thanks folks.
06:56:02 <benmachine> haskell.org seems to be pretty slow
06:56:27 <YoklJO> benmachine: im just kinda new to haskell, still working on knowing which functions to use when
06:58:27 <rtharper> wow, rough day for freenode
06:58:56 * benmachine decides to leave #haskell in the hope of getting anything else done
06:59:26 <rostayob> quicksilver: so you think it's the environment, not haskell
06:59:45 <quicksilver> rostayob: yes, broadly speaking.
06:59:53 <quicksilver> rostayob: part of the environment is influence by what haskell is :)
07:00:10 <quicksilver> rostayob: I mean, there are real challenges using haskell effectively in memory-constrained or CPU-intensive tasks.
07:02:26 <jlouis> dcoutts: when you get around to it, make detailed-1.0 such that you can pass in a "private dir" option and a configuration to the test system. I have some test programs I need to read in, so knowing where they reside would be neat
07:02:42 <inetic> Saizan, thank you, retaining the root node did the trick, strange thing though that unless the height of the tree is >=16 the profiler shows me an empty graph
07:02:59 <jlouis> In addition: Where is exitcode-stdio executing? I.e., what is its working dir?
07:07:11 <dcoutts> jlouis: the working dir is the top of the package source tree
07:07:32 <dcoutts> jlouis: so there should be no need for a private dir option
07:07:57 <dcoutts> jlouis: it needs to be possible to run these tests automatically, so we cannot have extra required options
07:08:15 <dcoutts> but you can add whatever extras you like for your own purposes
07:08:32 <jlouis> ok, thanks
07:08:52 <jlouis> I am just bouncing common_test (Erlang) ideas your way
07:09:20 <jlouis> They have distribution built-in, so they need a way to marshall data to other nodes in the network
07:09:39 <jlouis> another cool thing you will want is that they can randomly shuffle tests before executing them
07:10:11 <jlouis> It tends to tickle out state specific bugs easily
07:10:55 <jlouis> The config options have a default (the main test specification defines what config file to read), but it allows you to override tests for local quick tests
07:12:11 * hackagebot configuration 0.1 - Simple data type for application configuration.  http://hackage.haskell.org/package/configuration-0.1 (HiromiIshii)
07:21:03 <argiopeweb> Is there any way to export the ability to pattern match without exporting the ability to construct an object? It would seem like a no, but I just wanted to see if there were any tricks I'd missed.
07:23:01 <aavogt> argiopeweb: what happens if you have a class constraint on the constructor, but don't export the class?
07:23:53 <aavogt> like        data D a = C a => Constr a,   I think
07:23:56 <Jafet> That's just evil
07:24:18 <argiopeweb> That does seem evil, though it might work.
07:24:44 <argiopeweb> My problem is that I'd like to be able to pattern match, but I need to implement bounds constraints on variables, so I'm using special constructors.
07:24:47 <Jafet> Wouldn't you lose the ability to write certain type signatures
07:25:03 <argiopeweb> If there's a better way to implement bounds constraints, I can go with that instead.
07:27:32 <rothwell> argiopeweb: i've not seen a good solution to this anywhere
07:27:42 <rothwell> all the solutions seem to involve losing pattern matching
07:27:58 <rothwell> i'd like to hear anything to the contrary...
07:29:13 * hackagebot msgpack 0.6.1.1 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.1.1 (HideyukiTanaka)
07:29:15 * hackagebot msgpack-rpc 0.6.1.1 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.6.1.1 (HideyukiTanaka)
07:29:19 <Jafet> Perhaps you could make two classes, and export one for writing type signatures
07:30:12 <Jafet> class Evil; data T a = Evil a => Constr a; class Evil a => Export a;
07:30:20 <Jafet> Or is it the other way round
07:30:32 <Jafet> But in my book, that's doubly evil
07:39:15 * hackagebot uuagc 0.9.37.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.37.1 (ArieMiddelkoop)
07:40:50 <ari__> ....
07:46:11 <ari__> Merge sort
07:46:11 <ari__> ???
07:46:11 <ari__> Merge_sort:: Orda=>[a]->[a]
07:46:11 <ari__> Merge_sort [] ==[]
07:46:11 <ari__> Merge_sort (x:xs) = ???
07:46:12 <ari__> Merge_sort:: Orda=>[a]->[a]
07:46:12 <ari__> Merge_sort [] =[]
07:46:13 <ari__> Merge_sort (x:xs) = ???
07:46:21 <rostayob> quicksilver: ok - sorry for the late answer. I still have my doubts
08:23:04 <meditans> Hi, anyone knows how to simplify this expression: scalar x y = sum (zipwith (*) x y)?
08:23:23 <quicksilver> that's pretty simple, I'd say.
08:23:44 <meditans> to simplify I mean cancel the reference to x and y such in scalar = sum . (zipWith (*)) which is not actual code
08:24:03 <quicksilver> that will not be a simplificatin.
08:24:08 <meditans> it's the type of (.) that prevent me doing that
08:24:09 <quicksilver> :)
08:24:21 <quicksilver> @pl \x y -> sum (zipWith (*) x y)
08:24:21 <lambdabot> (sum .) . zipWith (*)
08:24:24 <meditans> ok, let's call it a rewriting ;)
08:24:29 <quicksilver> ^^ there is the complification you asked for.
08:24:52 <c_wraith> you could eta reduce it once without it being too ugly.
08:25:08 <c_wraith> scalar x = sum . zipwith (*) x
08:25:23 <c_wraith> But getting rid of the second input is a lot harder
08:25:26 <Jafet> That's worse
08:25:52 <Jafet> Your version makes it even less obvious that it does an inner product of two inputs
08:25:55 <meditans> how can I do that, anyway? Is there a way with applicative functors?
08:26:08 <c_wraith> In this particular case, I'd agree that it's worse, because it destroys the symmetry of what's going on.
08:26:44 <meditans> yes.. I made a mistake.. it's not a question of simplicity, rather exploring the power of the language
08:26:59 <c_wraith> But when your code has two arguments that don't have some kind of symmetry, I find dropping one argument is often good.
08:27:18 <c_wraith> like...  concatMap f = concat . map f
08:27:27 <Jafet> Also, I'd not call it "scalar"
08:27:56 <Jafet> Unless you're really working in a place where that represents the only sensible scalar for something
08:30:18 <c_wraith> :t sum .: zipWith (*)
08:30:19 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
08:30:38 <c_wraith> Though that's not really helpful, as (.:) isn't in the standard libs
08:31:07 <meditans> ah.. and in which library is it?
08:31:30 <DrSyzygy> :t (.:)
08:31:30 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
08:31:33 <c_wraith> I don't know.  I think it may just be in lambdabot
08:32:22 <c_wraith> I think it was added primarily to demonstrate the cliche "if point-free is ugly, you need better combinators"
08:32:53 <c_wraith> :t fmap fmap fmap
08:32:54 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:33:41 <Anm> I'm trying split my first program into modules, but I'm finding myself stuck on numerous "Not in scope" and "is not a (visible) field)" errors
08:33:44 <Anm> Source: http://hpaste.org/45276/trouble_with_modules
08:33:46 <djahandarie> :t (Prelude..) Prelude.. (Prelude..)
08:33:46 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:33:52 <mercury^> .: is fmap . fmap, right?
08:33:55 <mercury^> :t fmap . fmap
08:33:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:34:24 <djahandarie> mercury^, fmap fmap fmap = fmap `fmap` fmap = fmap . fmap
08:34:59 <mercury^> Yeah, I was somehow suspecting that to be the case. Still thinking about the details though. :)
08:35:05 <djahandarie> And to make it more readable, the (r ->) Functor instance is usually the one used
08:35:21 <djahandarie> And in that case it can be written it (.) . (.), given the Prelude.., not lambdabots.
08:36:26 <mercury^> Well, in lambdabot it still works, but it's just the fmap fmap fmap, isn't it?
08:38:50 <conal> mercury^: or "fmap . fmap", to clarify what's general to functors and what's specific to functions. or "result . result" for the deep arrow generalization.
08:39:52 <conal> the latter is handy for compositional construction of values, guis, code, etc.
08:40:11 <mercury^> conal: result only turns up something from QC on hoogle. What's the reference for that?
08:40:16 <conal> @wiki eros -- ^^
08:40:16 <lambdabot> http://www.haskell.org/haskellwiki/eros_--_^^
08:40:24 <conal> @wiki eros
08:40:24 <lambdabot> http://www.haskell.org/haskellwiki/eros
08:40:26 <djahandarie> :t [fmap fmap fmap, fmap `fmap` fmap, fmap . fmap, (.) . (.)]
08:40:27 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => [(a -> b) -> f (f1 a) -> f (f1 b)]
08:41:01 <conal> djahandarie: putting them in a list *forces* the types to specialize.
08:42:47 <djahandarie> conal, I know, that was intentional. I accidently used lambdabot's (.) though
08:42:50 <conal> :t fmap fmap fmap fmap
08:42:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
08:43:08 <djahandarie> :t [fmap fmap fmap, fmap `fmap` fmap, fmap Prelude.. fmap, (Prelude.) Prelude.. (Prelude.)]
08:43:09 <lambdabot> Not in scope: data constructor `Prelude'
08:43:09 <lambdabot> Not in scope: data constructor `Prelude'
08:43:19 <djahandarie> :t [fmap fmap fmap, fmap `fmap` fmap, fmap Prelude.. fmap, (Prelude..) Prelude.. (Prelude..)]
08:43:19 <lambdabot> forall a b c a1. [(b -> c) -> (a -> a1 -> b) -> a -> a1 -> c]
08:44:20 <conal> e.g., contrast fmap.fmap.fmap with fmap fmap fmap fmap fmap
08:45:41 <conal> moreover, any of the fmaps can be replaced by other SECs, such as first & second, if one distinguishes between fmap & (.) when composing SECs.
08:46:18 <conal> so the dotless version is fragile in comparison with the dotted version
08:48:07 <Anm> is there anything special about record data with respect to defining/importing modules?
08:50:13 <djahandarie> I can't tell if I'm lagging very badly or lambdabot is
08:52:46 <idivyanshu> hi
08:52:50 <Phyx-> hi
08:53:13 <Anm> Why might my references to my record constructor and access methods not be recognized upon (unqualified) import?
08:53:15 <Skola> :t 1 + 1
08:53:15 <lambdabot> forall t. (Num t) => t
08:53:35 <Skola> lambdabot is, unless that's an illegal query
08:53:48 <quicksilver> Anm: because you didn't export them, or you didn't import them
08:53:51 <djahandarie> Nope, that is fine. I guess it's lambdabot
08:54:47 <Skola> hi hi
08:54:50 <Anm> Morphogenesis.hs export: module Morphogenesis ( Sim, ... ) where...
08:54:52 <quicksilver> "Foo()" means just the type Foo; "Foo(A,B,C)" means Foo and constructors A B and C, "Foo(..)" is Foo and all constructors.
08:54:55 <Phyx-> 1 + 1 should be invalid?
08:54:57 <idivyanshu> :t init
08:54:58 <lambdabot> forall a. [a] -> [a]
08:55:01 <Anm> Main.hs import: import Morphogenesis
08:55:09 <quicksilver> you want Sim(..)
08:55:22 <Jafet> > map (\x -> if x == 'i' then 'o' else x) "ping"
08:55:23 <lambdabot>   "pong"
08:55:29 <Anm> Error: Main.hs:29:19: Not in scope: type constructor or class `Sim' 
08:55:37 <Jafet> Almost instant to me
08:57:01 <idivyanshu> 127+1293
08:57:12 <Anm> @quicksilver:  thanks.  turns out my error was lamer than that
08:57:12 <lambdabot> Unknown command, try @list
08:57:50 <Phyx-> :t foo
08:57:51 <lambdabot> Not in scope: `foo'
08:58:05 <Phyx-> oh lambdabot, I can play with you all day
08:58:32 <djahandarie> Whoaaaa
08:58:39 <djahandarie> It's freenode's issue, not lambdabot's. Haha
08:58:52 <Phyx-> what is?
08:59:07 <djahandarie> This intense lag that I was experiencing.
08:59:16 <hpc> im not having problems
08:59:21 <Phyx-> neither am i
08:59:29 <pumpkin> freenode has dozens of servers
08:59:30 * Phyx- pokes hpc 
08:59:46 <pumpkin> it's quite possible that different people are having different issues :)
09:00:03 <hpc> lambdabot is connected to the DC server
09:02:47 <Phyx-> :t typeOf
09:02:48 <lambdabot> forall a. (Typeable a) => a -> TypeRep
09:03:08 <Phyx-> :t dataTypeOf
09:03:08 <lambdabot> forall a. (Data a) => a -> DataType
09:03:36 <Phyx-> > dataTypeOf (undefined :: Int -> Int)
09:03:36 <lambdabot>   DataType {tycon = "Prelude.(->)", datarep = NoRep}
09:03:57 <Phyx-> :t DataType
09:03:57 <lambdabot> Not in scope: data constructor `DataType'
09:04:17 <Phyx-> @hoogle Data a => DataType -> a
09:04:18 <lambdabot> Data.Data gmapT :: Data a => (b -> b) -> a -> a
09:04:18 <lambdabot> Data.Data fromConstrB :: Data a => d -> Constr -> a
09:04:18 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:04:59 <conal> do we have a mac os x haskell platform for ghc-7.0.3 yet?
09:04:59 <Dudleyy> Hi, does anyone here is familiar with BNFC?
09:05:37 <Phyx-> there's a ghc 7.0.3?
09:05:40 * Phyx- looks
09:05:48 <mafs> conal, Phyx-: yeah, it fixed the Xcode 4 issue
09:05:56 <Phyx-> has the type system been fixed/relaxed somewhat?
09:06:04 <Phyx-> i remember the one 7 came with was very strict
09:06:18 <mafs> conal: http://www.haskell.org/ghc/download_ghc_7_0_3#macosxintel
09:06:19 <DrSyzygy> Soooo....
09:06:33 <DrSyzygy> I just installed the 64-bit MacOSX Haskell Platform.
09:06:50 <DrSyzygy> And when ghc --make-ing Setup.hs for a cabalized project of mine, I get:
09:06:51 <DrSyzygy> ld: warning: -read_only_relocs cannot be used with x86_64
09:06:57 <conal> mafs: that's just the compiler, iiuc.
09:07:09 <DrSyzygy> Is this a known issue, and who do I tell it to?
09:07:43 <mafs> conal: oops, I think you're right.
09:07:59 <conal> does anyone here have the 7.0.3-compatible haskell platform running on mac os x?
09:08:07 <conal> mafs: thanks, though.
09:08:13 <conal> i'll ping mzero to ask about the platform.
09:08:27 <Phyx-> lambdabot: uname -a
09:08:32 <Phyx-> lol
09:08:49 <Phyx-> i'm wondering what ghc version that lambdabot is using
09:09:45 <Jafet> Just try to use something in 7 that isn't in 6
09:09:59 <Jafet> At least, I'm fairly sure it's 6
09:10:09 <Saizan> DrSyzygy: i've seen that discussed before
09:10:23 <Jafet> (that is, base-4.2)
09:10:53 <Phyx-> hm, I haven't really had the time to check out 7 yet to be honest, I just saw that most of my stuff broke so I left it alone
09:10:56 <Phyx-> lol
09:11:16 <Jafet> You seem to be breaking out in giggles today
09:11:35 <Phyx-> The alternative would be crying
09:14:19 <Phyx-> :t put
09:14:20 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
09:14:55 <revenantphx> I got bored in Physics, and tried to prove addition.
09:15:08 <revenantphx> Based on 0, 1, succ, and supposing there's a succ^-1
09:15:09 <argiopeweb> What are the generally accepted ways to establish constraints/bounds on types in type constructors other than a special constructor? I.E. data Dat = Dat Int, where Int must be between 0 and 5.
09:15:25 <revenantphx> I came out too:
09:15:32 <revenantphx> add m 0 = m
09:15:55 <revenantphx> add m n = succ ( add (m, succ^-1(n) ) )
09:16:11 <revenantphx> as rewrite rules to reduce add(m, n) to a series of succ(succ(succ...
09:16:23 <revenantphx> For positive numbers and zero only, obviouslyt.
09:16:30 <revenantphx> and with succ^-1 undefined for 0.
09:16:38 <revenantphx> Does that hold up?
09:16:47 <xplat> argiopeweb: for that you should  use a non-exported constructor plus a smart constructor
09:16:51 <shachaf> revenantphx: You should read _The Little Schemer_.
09:17:08 <Phyx-> argiopeweb: use a smart constructor? e.g make the constructor for the type abstract and expose a function to create Dat
09:17:14 <revenantphx> I want to know how I could rewrite it without resorting to that succ^-1 
09:17:26 <revenantphx> it's interesting that i need decrement to implement addition.
09:17:28 <revenantphx> >_>
09:17:43 <argiopeweb> s/special/smart/ in my above comment.
09:17:51 <argiopeweb> I'm sorry, coffee's wearing off.
09:17:53 <xplat> or you could use type-level natural numbers to create your own numeric types with small bounds.  easier with TypeNats, is that in 7.0.x for some x?
09:18:30 <argiopeweb> Smart constructor is the obvious method, but it kills my ability to pattern match.
09:18:35 <Phyx-> what do you guys use to typeset algorithms in latex? the algorithmic package seems really limited and geared towards imperative algorithms
09:18:41 <argiopeweb> I want to have my cake and eat it too.
09:18:41 <xplat> but smart constructors are definitely the conventional solution at this point
09:19:00 <xplat> you can use view patterns to pattern match
09:19:01 <shachaf> revenantphx: 0 is like [] and succ^-1 is like tail.
09:19:08 <revenantphx> shachaf: o.o
09:19:10 <sipa> Phyx-: lhs2TeX :)
09:19:12 <revenantphx> mind = blown
09:19:33 <revenantphx> Such a productive period of physics though.
09:19:45 <revenantphx> I got obsessed with the fact that you could define exponentiation as recursive multiplication,
09:19:50 <revenantphx> and multiplication as recursive addition...
09:19:59 <shachaf> So just say data Nat = Z | S Nat and pattern-match like everybody else.
09:20:02 <argiopeweb> xplat: Not familiar with view patterns. I'll go check it out.
09:20:04 <revenantphx> so I tried to implement addition as recursive incrementation… but didn't quite succeed.
09:20:10 <shachaf> (Or type Nat = Mu Maybe. :-) )
09:20:13 <xplat> actually [()] is a type isomorphic to Nat if you ignore bottoms
09:20:22 <Phyx-> sipa: doesn't lhs2tex basically allow for typesetting haskell code and equational reasoning? not algorithms really?
09:20:31 <hpc> shachaf: eeevil!
09:20:36 <hpc> :P
09:20:55 <Phyx-> hahah
09:20:58 <xplat> then + is just ++
09:21:03 <Phyx-> shachaf: "like everyone else"
09:21:33 * hackagebot threadscope 0.1.3 - A graphical thread profiler.  http://hackage.haskell.org/package/threadscope-0.1.3 (SpencerJanssen)
09:21:40 <revenantphx> :D
09:21:43 <augur> argiopeweb: coffee! \o/
09:21:51 <revenantphx> My CSS was used for the HP2012 page
09:21:52 <revenantphx> ossum :O
09:21:53 <argiopeweb> augur: \o/
09:21:57 <revenantphx> \o/
09:22:05 <augur> argiopeweb: i have "coffee" on highlight e.e
09:22:05 <xplat> Phyx-: you can express algorithms in haskell, especially if they are not imperative
09:22:08 <argiopeweb> opossum?
09:22:18 <argiopeweb> augur: Outstanding. :)
09:22:18 <kosmikus> Phyx-: what is it you actually want?
09:22:25 <ezyang> you can express imperative algortihms in Haskell too 
09:22:33 <Fuco> how can I test if a FilePath is a directory?
09:22:51 <hpc> @hoogle isDirector
09:22:51 <lambdabot> No results found
09:23:05 <Jafet> @hoogle FilePath -> IO Bool
09:23:05 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
09:23:05 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
09:23:05 <lambdabot> System.Console.Editline.Readline readHistory :: FilePath -> IO Bool
09:23:18 <hpc> doesDirectoryExist :: FilePath -> IO Bool
09:23:24 <hpc> oh, ninja
09:23:42 <xplat> ezyang: i never said you couldn't
09:23:52 <revenantphx> shachaf: so, does my definition of addition work then :\?
09:23:57 <revenantphx> As symbol rewriting rules
09:24:48 <Phyx-> kosmikus: i'm just trying to figure out how type out how to type something like http://research.microsoft.com/en-us/um/people/daan/download/papers/hml.pdf in figure 10
09:25:05 <Phyx-> Nothing i've tried really comes out like that :/
09:25:43 <xplat> revenantphx: you want your rewrite rules to eliminate succs rather than introduce preds
09:26:07 <revenantphx> xplat: succ(pred(…)) can be reduced to … though
09:26:16 <revenantphx> but that's a good point
09:26:23 <revenantphx> I'm very new to this, just exploring :)
09:27:43 <kosmikus> Phyx-: I don't much like the style, but you could use lhs2TeX to achieve something like that
09:28:01 <xplat> revenantphx: pred(succ(n)) => n is the auxiliary rule you actually need to make your version of addition work.  and the other one is not valid for naturals ...
09:28:13 <revenantphx> by naturals you mean,
09:28:26 <argiopeweb> xplat: Looked over the official documentation on view patterns. I get the basic idea, but I'm not grokking the actual view function.
09:28:50 <xplat> i mean no negative numbers
09:29:03 <Phyx-> kosmikus: I'll gladly use any other style you might have a manual/tutorial for :)
09:29:19 <revenantphx> xplat: right.
09:29:27 <revenantphx> I wasn't considering negative numbers
09:29:30 <revenantphx> to make things simpler heh
09:30:36 <xplat> if you introduce succ(pred(x)) => x, then pred(0) and so on will basically act like negative numbers (except that they will break some of your functions)
09:31:00 <revenantphx> hmm
09:31:06 <revenantphx> pred stands for what again?
09:31:13 <pumpkin> predecessor
09:31:17 <revenantphx> mmk
09:31:29 <pumpkin> predator
09:31:33 <pumpkin> prediction
09:31:45 <revenantphx> xplat: Well, still stuff to work out, but
09:31:52 <argiopeweb> Predestine. 
09:31:54 <argiopeweb> Predication.
09:31:56 <argiopeweb> Etc.
09:31:58 <revenantphx> I don't think my definition is that bad for a bored high school kid in physics :)
09:32:06 <revenantphx> though, I probably could have done better.
09:32:18 <xplat> (unless you alter those functions to account for values of the form pred(x) that can't be reduced further)
09:32:37 <xplat> obviously it stands for 'predacons'
09:32:38 <revenantphx> I'll try using it with data constructors
09:32:42 <revenantphx> so I can match on them and reduce
09:32:43 <argiopeweb> Obviously.
09:42:02 <Fuco> I'm trying to write a function that will return a list of True or False indicating the string at that position represents a directory or not
09:42:05 <Fuco> so far I have something like this
09:42:10 <Fuco> getDirectoryContents x >>= return . map doesDirectoryExist
09:42:23 <Fuco> but that doesn't work because doesDirectoryExist returns IO Bool
09:42:37 <pumpkin> preflex: seen bos
09:42:37 <preflex>  bos was last seen on #ghc 2 days, 17 hours, 50 minutes and 25 seconds ago, saying: nominolo: well, several of those modules do lots of unsafe array accesses for performance, so could be you're just getting unlucky on the mac
09:42:38 <Fuco> is there a way to get just the Bool somehow
09:43:11 <pumpkin> @ask bos have you considered making a version of statistics that works over some form of iteratee, for calculating statistics on data that's too big to fit in memory?
09:43:11 <lambdabot> Consider it noted.
09:43:12 <wjt> Fuco: you want getDirectoryContents x >>= mapM doesDirectoryExist 
09:43:52 <Fuco> oh, I see
09:44:12 <Fuco> >>= returns [a], doesDirectoryExist is a -> IO b and the whole thing returns IO [b]
09:44:18 <Fuco> cool, thanks :P
09:46:39 <kosmikus> Phyx-: http://hpaste.org/45281/algorithm_example
09:48:55 <kosmikus> Phyx-: that'll produce http://kosmikus.org/Algorithm_Example.pdf
10:03:00 <pumpkin> @ask bos or if not actual iteratees, some breakdown of the "state updating" logic in your statistical functions from the "aggregate the state into a final answer that people expect", so that we could plug them into anything (including iteratees) that can't be provided all at once
10:03:00 <lambdabot> Consider it noted.
10:05:15 <Apocalisp> :t \id -> (id 'C', id "Foo")
10:05:16 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
10:05:16 <lambdabot>       Expected type: [Char] -> t
10:05:16 <lambdabot>       Inferred type: Char -> t1
10:06:27 <Apocalisp> :t \(id :: forall a. a -> a) -> (id 'C', id "Foo")
10:06:28 <lambdabot> (forall a. a -> a) -> (Char, [Char])
10:06:35 <Apocalisp> is there a way to avoid this type annotation?
10:06:52 <pumpkin> use a let binding of id, otherwise no
10:07:35 <Apocalisp> ok ta
10:10:44 <tomberek> what is a good way to repeatedly apply an ST s a -> ST s a  function a specified number of times in the ST monad without getting a stack overflow?
10:10:59 <Phyx-> kosmikus: ah great, thanks alot! much appreciated :)
10:14:58 <Apocalisp> tomberek: replicateM_ ?
10:14:58 <byorgey> preflex: seen lispy
10:14:58 <preflex>  lispy was last seen on #haskell 12 hours, 5 minutes and 3 seconds ago, saying: TomMD: I wouldn't advertise that I'm a Coq Master (if I were one) except in written mediums :)
10:15:05 <Apocalisp> :t replicateM_
10:15:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
10:15:33 <Apocalisp> oh, a function
10:15:42 <tomberek> Apocalisp: um.....
10:15:48 <pumpkin> why are you taking an ST in?
10:16:11 <tomberek> pumpkin: i'm playing with this:   data SList s = SNode (STRef s Int) (SList s) (SList s)
10:16:14 <Apocalisp> @hoogle (a -> a) -> Int -> a -> a
10:16:15 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
10:16:15 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
10:16:15 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:16:37 <pumpkin> tomberek: I still don't see why you need to take an ST in as a parameter
10:16:48 <tomberek> to traverse?
10:16:59 <tomberek> or is that not needed?
10:17:13 <pumpkin> also, I'm not really sure what that type means
10:17:20 <pumpkin> it looks like an infinite binary tree
10:17:34 <tomberek> circular list, I tie the knot
10:18:55 <pumpkin> either way, it's pretty rare to need a function ST s a -> ST s a, as far as I know
10:19:00 <pumpkin> especially if it's polymorphic :P
10:19:15 <tomberek> well, it's really  slft' :: ST s (SList s) -> ST s (SList s)
10:19:36 <pumpkin> what does it do?
10:19:44 <tomberek> i want to step left in the cicular list
10:19:51 <tomberek> but do it many many times
10:19:57 <pumpkin> ah
10:20:00 <tomberek> it works fine, except i get a stack overflow
10:20:11 <tomberek> (when i try too high of a number)
10:21:50 <tomberek> i think what is happening is that the thunk get's built up, but not consumed until it finally reaches the runST.
10:22:27 <pumpkin> I still don't see why you need to take an ST as input, really :)
10:22:56 <tomberek> pumpkin: what would work then?
10:23:25 <pumpkin> I don't know, I haven't seen your code, but why do you need to take an _action_ as input and return a new _action_ as output?
10:23:42 <tomberek> hm...... 
10:23:53 <tomberek> i have to go to work,, but I'll think about it,, thanks
10:23:58 <pumpkin> the only time you see stuff like that
10:24:00 <pumpkin> is with 
10:24:01 <pumpkin> :t forkIO
10:24:02 <lambdabot> Not in scope: `forkIO'
10:24:06 <pumpkin> @hoogle forkIO
10:24:06 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
10:24:07 <tomberek> ew
10:24:12 <Apocalisp> why not just SList s -> Slist s?
10:25:42 <Apocalisp> oh I see, you want to mutate the STRef
10:26:42 <Apocalisp> SList s -> ST s (Slist s)
10:26:59 <byorgey> @ask lispy I'd love to chat sometime about freetype2 + diagrams
10:26:59 <lambdabot> Consider it noted.
10:32:49 <Fuco> when I use liftM2 on (&&) (==1) (==2), the monad used in this is (e->) right?
10:32:53 <Fuco> :t liftM2
10:32:54 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:33:19 <Fuco> it takes function on 2 bools and 2 functions to bool and an argument
10:33:36 <pumpkin> yeah
10:33:52 <Fuco> awesome
10:33:58 <alpounet> :t liftM2 on
10:33:59 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> b -> c) -> m (a -> b) -> m (a -> a -> c)
10:34:32 <Fuco> I have a function \x -> (x == 1) && (x == 2) and I was trying to make it pointfree
10:34:37 <Fuco> well, 1 and 2 are just examples
10:34:44 <Fuco> nice that this works :P
10:35:19 <Fuco> it almost feels kindof dirty :D I don't even know why
10:35:24 <ion> liftM2 (&&) (== 1) (== 2)
10:35:40 <ion> whoops, that was already said
10:35:47 <Fuco> thanks anyway :)
10:38:31 <ion> That expands to do a <- (== 1); b <- (== 2); return (a && b)
10:39:42 <Fuco> hm, and where does the argument come into this
10:39:48 <ion> Alternatively, (&&) <$> (== 1) <*> (== 2)
10:39:54 <Fuco> > (liftM2 (&&) (== 1) (== 2)) 4
10:39:55 <lambdabot>   False
10:40:02 <Fuco> > (liftM2 (&&) (/= 1) (/= 2)) 4
10:40:03 <lambdabot>   True
10:40:06 <Fuco> this would make more sense :P
10:40:47 <ion> The definition of (>>=) in the ((->) r) instance handles the argument.
10:41:09 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
10:41:21 <ion> f >>= k = \ r -> k (f r) r
10:42:07 <ion> Try expanding ‘(/= 1) >>= \a -> (/= 2) >>= \b -> return (a && b)’ manually based on the definitions of (>>=) and return for the instance.
10:42:40 <ion> Actually, ‘((/= 1) >>= \a -> (/= 2) >>= \b -> return (a && b)) 4’
10:42:52 <ion> You’ll see how the parameter 4 gets threaded along.
10:43:01 <Fuco> ok let me try this
10:43:32 <ion> > ((/= 1) >>= \a -> (/= 2) >>= \b -> return (a && b)) 4  -- Just checking that i didn’t make any typos i’m not noticing
10:43:32 <lambdabot>   True
10:44:40 <Phyx-> well then... it's actually alot easier to use lhs2tex then I though.... I just had to RTFM.. :P
10:47:05 <Fuco> aarg the parentheses
10:47:55 * hackagebot pool 0.1.0.1 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.0.1 (MichaelSnoyman)
10:47:56 <Fuco> just to make sure, x >>= \a -> y >>= \b -> xxx is x >>= (\a -> y >>= (\b -> xxx))
10:48:09 <Fuco> well it kind of only makes sense this way anyway
10:48:41 <Phyx-> @pl "x >>= \a -> y >>= \b -> xxx"
10:48:41 <lambdabot> "x >>= \a -> y >>= \b -> xxx"
10:48:51 <Phyx-> eh?
10:49:00 <Phyx-> @pointfree "x >>= \a -> y >>= \b -> xxx"
10:49:00 <lambdabot> Unknown command, try @list
10:49:05 <Fuco> I think " " makes it string? ;d
10:49:12 <Fuco> @pl x >>= \a -> y >>= \b -> xxx
10:49:12 <lambdabot> x >> (y >> xxx)
10:49:16 <Phyx-> @pl == pointless? not pointfree? (the tool)
10:49:16 <lambdabot> (line 1, column 1):
10:49:16 <lambdabot> unexpected "="
10:49:16 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:49:20 <Phyx-> Fuco: oh
10:50:01 <Phyx-> i've used the local tool too much
10:50:02 <Phyx-> :P
10:50:06 <Phyx-> used to quoting them
10:52:28 <Fuco> well, I got a bit lost in this
10:53:23 <Fuco> ion: would you care to do the first step?
10:54:49 <ion> fuco: http://hpaste.org/45283/expansion_of_liftm2___1
10:55:17 <ion> Each step is simply an expansion of a single definition such as >>=
10:55:30 <Fuco> thanks, gonna check it out
10:56:50 <Fuco> oh, now I see where I made the mistake
10:56:56 <Fuco> I forgot to include \r -> ;P
10:57:01 <Fuco> at the beginning
10:57:40 * Phyx- goes for a nap
10:59:57 * hackagebot cookie 0.2.1 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.2.1 (MichaelSnoyman)
11:00:02 <ion> ‘((+1) >>= return) 4’ expands to ‘(\r -> k (f r) r) 4’ = ‘return ((+1) 4) 4’, a lambda expression that takes the parameter 4 and binds it to r. Note how ‘(+1) 4’ ends up happening, and the 4 also ends up as the final parameter to the entire expression so the same expansion can go on. return expands to const which simply drops the final ‘4’.
11:00:45 <hpc> > ((+1) >>= return) 4
11:00:46 <lambdabot>   5
11:00:58 * hackagebot http-enumerator 0.6.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.0 (MichaelSnoyman)
11:01:00 * hackagebot wai 0.4.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.4.0 (MichaelSnoyman)
11:02:02 * hackagebot wai-extra 0.4.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.0 (MichaelSnoyman)
11:02:04 * hackagebot wai-handler-devel 0.4.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.0 (MichaelSnoyman)
11:02:06 * hackagebot wai-handler-fastcgi 0.4.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.4.0 (MichaelSnoyman)
11:02:08 * hackagebot wai-handler-scgi 0.4.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-0.4.0 (MichaelSnoyman)
11:02:10 * hackagebot wai-test 0.1.0 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.0 (MichaelSnoyman)
11:03:12 * hackagebot warp 0.4.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.0 (MichaelSnoyman)
11:04:07 <Fuco> ion: yea, all clear. Thanks
11:06:35 <Steap> This might be a stupid question, but eh, I'm new to Haskell and even the all-mighty Google could not answer it. I would like to use the "digits" function (http://hackage.haskell.org/packages/archive/digits/0.1/doc/html/Data-Digits.html), but I cant import Data.Digits. When compiling, I get the following error message : "Failed to load interface for Data/Digits. locations searched : Data/Digits.hi, Data/Digits.hi-boot"
11:06:43 <Steap> COuld someone give me a hint ?
11:07:38 <Fuco> and how did you install it?
11:07:46 <Phyx-> Steap: you need to install the "digits" package
11:07:47 <Fuco> you can usually just do "cabal install package"
11:07:56 <Fuco> from command line
11:08:20 <monochrom> so, it seems oleg is quite capable of April Fool jokes
11:08:27 <monochrom> -- Haskell98!
11:08:33 <monochrom> import Control.Exception
11:08:47 <monochrom> that's the April Fool joke :)
11:09:03 <Steap> Phyx-: thanks, I'm giving it a try
11:09:16 <Phyx-> ok.. I seriously don't that joke.. lol
11:09:19 <hpc> monochrom: ha!
11:09:25 <hpc> icwhdt
11:09:33 <Phyx-> i don't :/
11:09:39 * Phyx- pouts
11:09:52 <monochrom> the two lines are from an oleg post
11:10:35 <Fuco> hmm, now I get this error "No instance for (Monad ((->) FilePath)) arising from a use of `liftM2'"
11:10:54 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/87731
11:10:55 <hpc> Fuco: import Control.Monad.Instances i think
11:11:49 <Fuco> hm, cool :P
11:12:26 <ion> Also the equivalent expansion for the Applicative version: http://hpaste.org/paste/45283/expansion_of____1#p45284
11:14:16 <Fuco> hehe, this functor magic I don't even...
11:14:36 <Fuco> well I've never really looked at it.. I'll give it a try sometime
11:16:56 <dixie> I have String with the binary data (e.g. read using binary mode)... when I write them into stdout with UTF8 encoding will it fail with encoding err ?
11:18:39 <monochrom> won't fail, but will give strange output
11:19:21 <monochrom> String is not quite right for holding binary data
11:19:43 <hpc> use ByteString
11:21:34 <dixie> monochrom: I read the raw data from the network (e.g. HTTP) and later I want to decode them using HTTP header information (e.g. interpret them as UTF8 or something else)
11:22:32 <monochrom> here is a detailed example. the binary data are the bytes 0xe2 0xf7 0xf4 in sequence. you read using binary mode, the String is then ['\xe2', '\xf7', '\xf4']. that is, "â÷ô"
11:23:41 <monochrom> now output "â÷ô" using utf-8, the output byte sequence is 0xc3 0xa2 0xc3 0xb7 0xc3 0xb4
11:24:13 <xcvii_> hey, what's a good package for writing a binary file codec? (Data.Binary doesn't feel quite right as it doesn't let me get a "current offset" when writing -- which i really need and seems tiresome to keep track of)
11:24:16 <monochrom> this is because U+00E2 'â' in utf-8 is 0xc3 0xa2, etc
11:24:53 <edwardk> to be fair, he doesn't use any rank n types or existentials in _his_ code. just SomeException
11:24:53 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:25:12 <edwardk> @tell djahandarie lol, @work
11:25:12 <lambdabot> Consider it noted.
11:25:48 <ion> Also an expansion of (pure (&&) <*> (/= 1) <*> (/= 2)) 4 which is the applicative-only equivalent of ((&&) <$> (/= 1) <*> (/= 2)) 4. http://hpaste.org/paste/45283/expansion_of_pure#p45285
11:25:50 <monochrom> using bytestring for byte-oriented or octet-oriented data such as HTTP
11:25:55 <monochrom> s/using/use/
11:27:07 <dixie> monochrom: so I can later these data decode as UTF8? 
11:27:27 <monochrom> use a decode function to convert to String. a decode function takes a bytestring and your choice of utf-8 or gb18030 or ...
11:29:14 <zenzike> is there a way to get cabal to compile haddock information for a package from hackage?
11:29:19 <monochrom> finding the http header or <meta> tag for "charset: utf-8" can be done at the bytestring level
11:29:38 <dixie> monochrom: thanks. 
11:30:16 <Dudleyy> Hi, does anyone here works with BNFC?
11:30:54 <ClaudiusMaximus> zenzike: put "documentation: True" in your cabal config file
11:30:58 <dixie> monochrom: only last question. I'm not able to find "decode" function. Do you mean that from utf8-string ?
11:31:03 * hackagebot web-routes-quasi 0.7.0 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.7.0 (MichaelSnoyman)
11:31:18 <monochrom> the name of "a decode function" depends on which lib you use
11:31:26 <ClaudiusMaximus> zenzike: there's probably a command line flag for that too
11:31:33 <dixie> oh so :)
11:32:00 <zenzike> ClaudiusMaximus: thanks
11:34:25 <zenzike> ClaudiusMaximus: do you happen to know if cabal can link in hyperlinks to the source too?
11:37:48 <Phyx-> Ah, April 4th, the day "Micro-soft" was formed
11:38:00 <ClaudiusMaximus> zenzike: i think it does, but i'm not 100% sure - at least there is a global index..  ~/.cabal/share/doc/index.html 
11:38:33 <ClaudiusMaximus> zenzike: ah, oops i misunderstood your question
11:39:43 <ClaudiusMaximus> zenzike: here i have no "source" tab that lets me look at the source code for the installed stuff; if you find out how to enable it let me know, it'd be handy!
11:40:05 <FUZxxl> Does anybody know, where I can get this great PhD-thesis "Code Optimisation Techniques for Lazy Functional Languages"
11:41:40 <luite> for me it's the first hit in google...
11:41:54 <Phyx-> same here
11:42:03 <lunaris> Ditto
11:42:05 <lunaris> http://mirror.seize.it/papers/Code%20Optimization%20Techniques%20for%20Lazy%20Functional%20Languages.pdf
11:42:27 <monochrom> "mirror seize it"? :)
11:42:30 <FUZxxl> I also got this...
11:42:49 <FUZxxl> But I am not shure, whether it is the official one.
11:44:38 <TomMD> Yeah, that "haha, suckers, you already gave me my PhD" statement in the abstract really makes it seem fishy.
11:44:48 <lunaris> Disclaimer: Did not inspect the PDF :P
11:44:51 <TomMD> It was a joke.
11:45:36 <Phyx-> haahahah
11:45:44 <lunaris> So was mine.
11:46:13 <lunaris> Though it's given me some thoughts on my next abstract.
11:46:48 <Phyx-> lol, doubt I could use it :P
11:47:07 <Phyx-> actually
11:47:10 <Phyx-> doubt anyone could use it
11:47:16 <Phyx-> how would you retroactively add that
11:49:04 <luite> Phyx-: it doesn't have to be retroactive if they don't notice, make it an acrostic or something
11:50:06 <Phyx-> hmmm
11:50:20 * Phyx- is gonna try that
11:51:39 <Cin> What's people's experience of Scion? I've never got it to work each time I've tried it.
11:52:05 <Phyx-> it's used in EclipseFP
11:52:29 <Phyx-> i've gotten it to work too, just never incorporated it in anything.
11:54:08 <Phyx-> I'm not sure if Leksah uses it too, don't quite remember
11:56:00 <Cin> Hmm. What GHC version did you use?
11:56:01 <_Mitar> how could i paralellize this? http://hpaste.org/45287/paralellization
11:56:39 <Phyx-> Cin: i beleive I was using 6.12.1 at the time
11:59:09 * Phyx- can't wait to have time for his own projects again
12:03:56 <Cin> Hm, I see. Thanks.
12:04:11 <Cin> I'm pondering abandoning Emacs for Yi. Has anyone made the jump successfully?
12:04:32 <Cin> I'd be interested in experiences/show-stopping problems encountered, if any.
12:22:32 <hape01> that is strange - funktion = \x y -> x + y    infers to type  funktion :: Integer -> Integer -> Integer   but funktion2 x y = x + y    infers to  type funktion2 :: Num a => a -> a -> a    Intuitivly i would think the both are the same.
12:23:04 <pumpkin> @where dmr
12:23:04 <lambdabot> I know nothing about dmr.
12:23:36 <pumpkin> http://www.haskell.org/haskellwiki/Monomorphism_restriction
12:24:25 <Apocalisp> @hoogle fold1M
12:24:25 <lambdabot> No results found
12:25:05 <hape01> pumpkin: that "monomorphism restriction" answers to me?
12:25:15 <pumpkin> yeah, sorry
12:25:50 <Apocalisp> @hoogle (a -> a -> m a) -> [a] -> m a
12:25:50 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:25:50 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
12:25:50 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
12:25:52 <hape01> pumpkin: thanks
12:25:57 <Heffalump> hape01: it's defaulting
12:27:53 <nlogax> @hoogle foldM1
12:27:53 <lambdabot> No results found
12:31:05 <sipa> hape01: yes
12:31:05 <Cin> The monstermorphism restriction is so common for newbies encountering, I swear daily. Do RWH and LYAH explicate this?
12:31:14 <AnAdorableNick> I've uploaded string-class 0.1.5.0 (http://hackage.haskell.org/package/string-class-0.1.5.0), but haddock failed with an internal error when it tried to run: "haddock: internal error: unexpected argument to declName", which seems to be a haddock bug; it builds fine on my system.  Can any hackage admins look into this?
12:31:53 <hape01> Heffalump, sipa: I am new to Haskell, but I can accept this :-)
12:32:09 <monochrom> dcoutts: when "cabal install blah" says "World file is already up to date", what does that mean? what triggers that message?
12:33:15 <pumpkin> Heffalump: I'd think it's the DMR?
12:34:14 <Phyx-> DMR?
12:36:12 * monochrom surrenders to the much outcast "sudo cabal install blah"
12:36:49 * pumpkin hands monochrom the ostrakon of doom
12:37:44 <monochrom> I have my excuse. "cabal install blah --root-cmd='sudo PATH=xxx'" doesn't quite make it.
12:38:06 <pumpkin> DOOM
12:38:46 <monochrom> so, normally --root-cmd=sudo suffices. but not for gtk, if gtk2hs-buildtools executables are not in sudo's small PATH
12:39:16 <monochrom> my gtk2hs-buildtools executables are in /usr/local/haskell/bin not /usr/local/bin
12:39:55 <rostayob> I'm using CmdArgs, and it doesn't check for required arguments to be present
12:40:05 <rostayob> and it doesn't set the default values
12:40:07 <monochrom> cabal install cairo --root-cmd='sudo PATH=...:/usr/local/haskell/bin' is insufficient
12:40:16 <rostayob> I copied and pasted the example...
12:40:41 <monochrom> I could fudge my /etc/sudoers but I would rather not
12:43:25 <monochrom> I should also tell you that I have --global throughout
12:45:15 <rostayob> I am trying with the sample example: http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm and it doesn't behave as expected, it doesn't check the arguments to be there and it doesn't have the default values
12:46:53 <dcoutts_> monochrom: it's an unnecessary status message really, it's to do with updating the ~/.cabal/world file
12:47:31 <meditans> hi, I'm getting crazy to unterstand why main = putStr "prompt" >> getChar a >>= \a -> print ((func a) args) does expect the input before printing the prompt, but it works with putStrLn
12:48:32 <Phyx-> rostayob: i don't think that example has any required arguments
12:48:40 <Phyx-> but i didn't read the whole page
12:49:34 <rostayob> Phyx-: yeah you are right it doesn't but it still does not have the default value
12:49:36 <jedai_> rostayob: the "sample" code doesn't have any required flag
12:50:15 <rostayob> jedai_: yeah I was testing with my code before and I had required flags... anyway that code should have "hello" defaulting to "world"
12:50:15 <jedai_> rostayob: how do you test that ?
12:50:28 <rostayob> jedai_: I just put that code in a file and ghc Main.hs -o main
12:50:48 <jedai_> rostayob: no, it defaults to ""
12:51:10 <Phyx-> i don't think GetOpts allows you to specify defaults values does it? aren't those just the values you initiate the datatype wit?
12:51:24 <jedai_> rostayob: WORLD is just the "type" you're saying your user to pass, more typically it would be FILE or DIR
12:51:59 <Phyx-> uhm. what's that &= syntax? i've never seen it before. 
12:52:10 <rostayob> jedai_: wait, I linked the wrong page... I was trying with the example in the hackage docs: http://hackage.haskell.org/packages/archive/cmdargs/latest/doc/html/System-Console-CmdArgs-Implicit.html
12:52:32 <jedai_> "def" is just an overloaded value that depends on the type of the parameter ("" for String, 0 for Int, ...)
12:52:54 <mauke> meditans: you mean it waits for a character before it outputs "prompt"?
12:53:06 <rostayob> jedai_: yeah but you have opt "world" in that other page
12:53:06 <meditans> yes
12:53:10 <jedai_> Phyx-: CmdArgs is a deeply magical (and pretty nice) package, it does some unpure thing actually
12:53:21 <mauke> meditans: I don't think that has anything to do with putStrLn/print
12:53:32 <Phyx-> jedai_: dunno, I've always just used it rather straightforwardly 
12:53:38 <mauke> meditans: stdout is line buffered by default, so you have to output a \n or do 'hFlush stdout' before you see the prompt
12:53:40 <Phyx-> never used anything funky with it
12:53:58 <mauke> meditans: oh, you mean putStrLn vs. putStr. yes, putStrLn adds a \n, which flushes the buffer
12:54:47 <meditans> mauke: and the only way to force it to flush the stdout without \n is hFlush?
12:54:56 <rostayob> jedai_: this is the code I have: http://hpaste.org/45290/cmdargs
12:54:58 <jedai_> rostayob: opt just means it will be "world" IF you pass --hello (without an explicit argument) to the command, otherwise it will still be the default def (that is "")
12:55:58 <mauke> meditans: well, you can also change the buffering mode of stdout to unbuffered, but that makes I/O rather inefficient
12:56:09 <jedai_> rostayob: if you want it to be "world" except if specified otherwise, you just have to replace def by "world", def isn't anything magic, the only magic happens after the &=
12:56:22 <rostayob> jedai_: oh ok.... thanks a lot
12:56:38 <Phyx-> ok, what's that &= ? something from GetOpt?
12:56:44 <Phyx-> :t (&=)
12:56:45 <lambdabot> Not in scope: `&='
12:56:51 <jedai_> You're welcome, good luck with CmdArgs, it's pretty cool once you grok it
12:56:53 <alpounet> @hoogle (&=)
12:56:53 <lambdabot> No results found
12:57:08 <rostayob> Jafet: also, how do I define something that has to be defined?
12:57:11 <jedai_> Phyx-: No, it's CmdArgs-specific
12:57:29 <Phyx-> hmm ok, I just never seen it before, lol
12:57:34 <jedai_> Phyx-: And it does some shady things from what I understand
12:58:43 <meditans> mauke: thanks.. I will hflush.. only I though there was a prettier way
12:59:25 <Phyx-> Jaak: ah, lol
12:59:31 <Phyx-> jedai_: *
12:59:34 <mauke> myGetChar = hFlush stdout >> getChar
12:59:39 <Phyx-> i should stop relying on tab completion
13:02:38 <beastaugh> I don't suppose anyone knows a workaround for this? http://hackage.haskell.org/trac/hackage/ticket/791
13:02:39 <jedai_> rostayob: I don't think you can do that... Flags are always optional, generally you would use fixed position args (argPos 0) for required argument
13:02:55 <meditans> mauke: thanks, it's better than I thought
13:03:03 <rostayob> jedai_: ok, thanks
13:03:19 <jedai_> rostayob: though nothing prevents you from checking that the value was changed from the default and exiting with the help message if not
13:04:16 <Phyx-> jedai_: Flags are always optional? *scrolls up to see which package he's using*
13:04:45 <Phyx-> aha
13:05:17 <Phyx-> rostayob: maybe you should consider using GetOpts instead of CmdArgs?
13:10:09 <jedai_> Phyx-: Note that GetOpts and CmdArgs don't really have the same target : GetOpts provide more control but you must write a lot of the option handling yourself while CmdArgs allows you to write multimode complete command in a jiffy but with a bit less control (and a lot less code most of the time)
13:11:16 <nyingen> anyone used graphviz?
13:11:39 <Phyx-> jedai_: aha, I've never really used CmdArgs. for GetOpts I have helper functions, which makes it rather easy for me to spit out and consume arguments, so i never found it that much work
13:15:45 <nyingen> alternatively, some kind of example program for graphviz would be pretty helpful
13:16:53 <jlouis> nyingen: context?
13:17:51 <jedai_> Phyx-: I suspect for argument handling, much depends on the experience you have with your tool, still if you want to see complex command with CmdArgs read a bit of http://community.haskell.org/~ndm/darcs/cmdargs/cmdargs.htm especially the HLint, Diffy and Maker samples
13:18:02 <nyingen> trying to figure out how to use the graphviz package to do a quick visualization of my graphlike data structure
13:19:49 * monochrom tries --root-cmd='xxx' where xxx is a little script to sudo PATH=blahblah "$@"
13:20:40 <nyingen> unless I'm badly misinterpreting the graphviz docs, I'm supposed to make my type an instance of the Graph typeclass, but then I don't understand why 'Node' is type-aliased to Int in the graphviz library
13:20:55 <monochrom> that works. so it seems --root-cmd='x y' considers 'x y' as one single exe name
13:21:09 <monochrom> in fact, let me try to rename my little script to 'x y'
13:21:46 <hape01> AnAdorableNick: string-class 0.1.5.0 - even on my PC i got the problem "unexpected argument to declName" when I do cabal install --enable-documentation.
13:23:14 <wharzl> test
13:23:52 <labo> how do you get the year,month,day,hour.. of local human time?
13:24:22 <labo> old-time is pretty obvious, but it says you should use the new time package
13:26:11 <monochrom> indeed, --root-cmd='x y' means the exe name is 'x y' rather than exe name x with parameter y
13:27:45 <metalrose> Hi, I was wondering if anyone would be able to give me a few pointers on a piece of "homework" I have ? 
13:28:05 <Phyx-> sure
13:28:22 <deggis> for amusement: just released (almost) pure open source haskell demo: http://www.youtube.com/watch?v=VUSXD3vwYpg (srcz link in description)
13:30:11 <Botje> metalrose: sure, ask away
13:30:11 <deggis> (oops, pure points to haskell. it's open source)
13:31:20 <rnik> Anyone using the 'plugins' package?  System.Plugins.load, specifically.  It doesn't like me.
13:31:25 <metalrose> thanks, the homework is to modify a given piece of haskell code that produces an index for a document of text so for example the text "Hello\nWorld" would be split into "hello"    1   "World"   2 
13:31:35 <aristid> it seems to be incredibly hard to make good FRP
13:31:47 <metalrose> the question I am struggling with is as follows: 1)	Where a word occurs n times on the same line, ensure that the line number occurs n times in the index entry for that word.
13:31:58 <luite> deggis: was there a size limit? :) it would be pretty hard to make a 64k one in haskell :)
13:32:08 <metalrose> so if "hello" appeared on the same twice it should have 1, 1 in its index entry 
13:32:23 * hackagebot pool 0.1.0.2 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.0.2 (MichaelSnoyman)
13:33:05 <Botje> metalrose: okay, so what's your plan?
13:33:16 <deggis> luite: this production didn't took part in any competitions, so no limits :) but yes, that would be hard
13:33:19 <metalrose> the function that removes the duplicates is as follows: 	  	sortLs :: [(Int, Word)] -> [(Int, Word)]  sortLs  [ ]  =  [ ] sortLs (pivot:tupleslist)  = sortLs smaller ++ [pivot] ++ sortLs larger     where 	smaller = [ tuple | tuple <- tupleslist,  orderPair tuple pivot] 	larger =  [ tuple | tuple <- tupleslist,  orderPair pivot tuple]
13:33:50 <deggis> if the system has ghc and stuff, unpacking and compiling source code distribution could be small ;)
13:33:55 <Botje> metalrose: that's unreadable. can you put it on a pastebin?
13:34:09 <Botje> hpaste.org, for example
13:34:32 <luite> deggis: interesting that demo parties apparently still exist :)
13:34:52 <metalrose> oops yes sure
13:35:21 <deggis> luite: heh, we just warming up a new one :)
13:36:39 <metalrose> Link to function - http://hpaste.org/raw/45291/makeindex_function
13:37:50 <metalrose> I have ammended the OrderPair function there to account for words and indexes been equal but all i get is an 'extra' index entry e.g. "WorldWorld" comes out as "world" 1 "world" 1 "World" ! 
13:38:40 <metalrose> as opposed to "world" 1 "world" 1 which would be correct
13:39:14 <Botje> why are there three Worlds in your example?
13:39:14 <metalrose> been wracking my brains trying to figure out why this extra index appears to no avail
13:39:42 <Botje> ah
13:39:45 <metalrose> thats what I dont understand but thats what happens when I run that function with that input
13:39:53 <Botje> | word1 == word2  && n1 == n2 = True
13:40:08 <Botje> this case returns True for both calls to orderPair
13:41:38 <metalrose> hmmm 
13:41:40 <metalrose> I see 
13:42:13 <Botje> take a look at the Ordering datatype
13:42:52 <Botje> you could split your list into one where orderPair pivot tuple returns LT or EQ
13:42:57 <Botje> and another where it returns GT
13:43:13 <Botje> that way you ensure you don't accidentally duplicate elements
13:46:22 <metalrose> thanks very much I'm taking a look at Ordering right now :D 
13:46:57 <Cin> Has anyone used TemplateHaskell to write an `eval'-ish function?
13:46:59 <Botje> you might also be interested in the compare function
13:47:10 <Botje> and the built-in Ord instance for tuples.
13:48:45 <ourfrank> I need a program to be compilable on both GHC6 and GHC7, but a crucial API has changed. How is the preprocessor usually used?
13:49:42 <ourfrank> (How do I specify flags for the preprocessor and tell ghc to run the preprocessor and use those flags?)
13:50:20 <monochrom> you put in a lot of #ifdef etc. at the head you also say {-# LANGUAGE CPP #-}
13:50:53 <monochrom> there are a few pre-defined macros for you to test ghc version
13:51:42 <Phyx-> heh
13:52:26 <ourfrank> monochrom: Thanks!
13:53:10 <monochrom> the problem now is I don't know where the macros are documented!
13:53:39 <ourfrank> monochrom: that's okay, I think I'll be able to find them. the CPP language pragma helps.
13:53:44 <edwardk> We need students for the summer of code, badly. If you are a student and have been kicking around whether or not to apply, please contact me!
13:54:11 <dblhelix> edwardk: what's your project?
13:54:51 <edwardk> dblhelix: i don't have any particular project that i want to run. As admin i'm mostly just trying to get people to apply.
13:55:06 <edwardk> I'm more than happy to talk to folks about project proposals, etc.
13:55:13 <dblhelix> edwardk: I see.
13:55:40 <edwardk> We have a lot of applications, but mostly from the same 3 students
13:56:39 <ourfrank> monochrom: I found them at http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/options-phases.html and the definition I was looking for was __GLASGOW_HASKELL__.
14:02:15 <Cin> Blergh. Is there *any* Haskell runtime evaluation that doesn't act up? Hint crashes, hs-plugins crashes, and plugins is completely inconsistent: http://hpaste.org/raw/45292/systemevalhaskell_o_o What the deuce.
14:03:32 <Cin> λ> eval "6 :: Int" [] :: IO (Maybe Int)
14:03:32 <Cin> Nothing
14:03:33 <Cin> λ> eval "\"a\"" [] :: IO (Maybe String)
14:03:33 <Cin> Just "Hello, World!"
14:03:38 <Cin> O_____O
14:04:25 <jlouis> Cin: wtf are you doing with eval??
14:05:30 * hackagebot groom 0.1.1 - Slightly prettier printing for well-behaved Show  instances.  http://hackage.haskell.org/package/groom-0.1.1 (EdwardYang)
14:05:40 <Cin> jlouis: Evaluating very, very simple expressions, and even then it's totally unstable.
14:05:43 <mzero> I've used hs-plugins successfully, and consistently - but it took a fair bit of work
14:06:05 <mzero> I'm pretty sure Snap framework uses Hint with success
14:06:33 <mzero> I was planning on moving Barley from hs-plugins to Hint ..... but haven't done so yet
14:07:14 <Cin> I heard it had. I'll look into it. All experience I've had or seen from friends, Hint is capricious and crashes a lot.
14:08:49 <Cin> Hm. It also has SSL support… I tried using hsopenssl and got a segfault. Haskell libs and their outstanding stability. ~_~
14:09:12 <ezyang> boo foreign libraries >:-) 
14:09:18 <copumpkin> Cin: no need to generalize unnecessarily there
14:10:11 <rothwell> hostility towards openssl is always justified though
14:10:16 <rothwell> always
14:10:20 <copumpkin> :)
14:11:15 <gigamonkey> Can anyone point me to anything about implementing zippers over graphs?
14:12:19 <gigamonkey> I've read the Ramsey/Dias paper, "An Applicative Control-Flow Graph Based on Huet's Zipper" but was hoping for something that focused more on a general data structure.
14:13:34 <Cin> gigamonkey: Possibly of interest: http://okmij.org/ftp/Scheme/zipper-in-scheme.txt
14:14:27 <monochrom> eh? openssl is just fine
14:14:29 <Cin> copumpkin: After four libraries on four evenings of your week have either segfaulted, runtime crashed or just done nothing, you become a bit jaded. :-P
14:15:15 <ddarius> gigamonkey: This isn't a pre-made solution, but zippers are related to differentiation of data types, and graphs can be nicely represented as species, and species support differentiation nicely as well, so you could presumably easily calculate it from the species.
14:15:48 <gigamonkey> "species"?
14:15:53 <McManiaC> anyone familiar with regex-posix who can tell my why this fails? http://npaste.de/01w/
14:16:44 <gigamonkey> Cin: thanks
14:16:44 <ddarius> @where species
14:16:44 <lambdabot> byorgey's paper : "Species and Functors and Types, Oh My!" at <http://www.cis.upenn.edu/~byorgey/papers/species-pearl.pdf> by Brent Yorgey in 2010-09 [feel free to add more interesting papers]
14:17:13 <Cin> Oo. I've not read about Species yet.
14:17:21 * Cin prints it off
14:17:26 <McManiaC> nvm, got it
14:17:27 <McManiaC> :)
14:17:38 <gigamonkey> Cin: ah, from the same site I was already reading http://okmij.org/ftp/continuations/zipper.html
14:18:13 <Cin> gigamonkey: Ah, ok, yeah, a few on there.
14:33:57 <sonoflilit> Hi
14:34:08 <sonoflilit> I'm trying to use the Enumerator package
14:35:46 <sonoflilit> I have an enumerator, lets call it enum, which I'm feeding into an enumeratee, lets call it "mapM go", and I want to get a list of the resulting values: run_ (enum $$ E.joinI $$ E.mapM go $$ ??? )
14:36:00 <sonoflilit> what is ???
14:37:27 <aristid> EL.consume?
14:40:20 <sonoflilit> aristid: probabl
14:40:25 <sonoflilit> aristid: probably, thanks
14:42:02 <aristid> if the types check, it's probably right. if not, back to the drawing board :D
14:48:38 * hackagebot riak 0.3.2.1 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.2.1 (BryanOSullivan)
14:52:31 <sonoflilit> why doesn't this typecheck?
14:52:36 <sonoflilit> main = E.run_ (enum $$ E.joinI $$ E.map (*2) $$ E.consume) >>= putStrLn . show
14:53:12 <pumpkin> you tell us
14:53:18 <pumpkin> we don't know what E is or what the type error is
14:53:24 <pumpkin> or even what $$ is
14:53:33 <sonoflilit> the E is for Enumerator, as I was talking about before
14:53:48 <ion> @crystalball why doesn’t sonoflilit’s code typecheck?
14:53:48 <lambdabot> Unknown command, try @list
14:53:51 <sonoflilit> E.run_ ((E.enumList 10 [1 .. 100]) $$ E.joinI $$ E.map (*2) $$ E.consume) >>= putStrLn . show
14:54:03 <lispy> sonoflilit: my guess is that E provides a different monad than IO
14:54:19 <lispy> putStrLn . show = print
14:54:21 <lispy> ?src print
14:54:21 <lambdabot> print x = putStrLn (show x)
14:54:49 <lispy> pumpkin: E is the enumerator package
14:55:10 <sonoflilit> it says it expects a step and gets an iteratee in joinI
14:56:05 <lispy> ?where hpaste
14:56:05 <lambdabot> http://hpaste.org/
14:56:18 <sonoflilit> if I remove the joinI and map, it works
14:56:23 <lispy> sonoflilit: put some code on hpaste, with the error message, and then put the url here.
14:56:30 <lispy> maybe someone can help then
14:57:30 <metalrose> Botje: Many thanks I have now completed that question, many thanks for your excellent advice 
14:57:59 <niteria> is Lectures on the Curry-Howard Isomorphism good?
14:58:06 <Botje> metalrose: you're welcome :)
14:58:10 <Botje> good luck with the others!
14:58:21 <mercurial> could anyone suggest a better way to model the types of assembler instructions here -> http://hpaste.org/paste/45295/ ; I'm attempting to encode static information about the particular instructions in their types, but this (appears) to make constructing 'lists of instructions tough'.
14:58:31 <metalrose> Thankfully I've done nearly all the others ;) 
14:58:36 <lispy> niteria: I've had it recommended to me by people here, but I didn't go through it yet.
14:58:42 <sonoflilit> http://hpaste.org/paste/45298/the_error_message#p45300
14:59:18 <niteria> lispy: I know one of the autors ^^
14:59:42 <aristid> sonoflilit: enumList 10 [1..10] $$ EL.map (*2) =$ EL.consume
14:59:46 <aristid> sonoflilit: this typechecks :)
15:00:03 <niteria> I don't know what I can expect to learn that would help me with programming
15:00:49 <lispy> sonoflilit: I looked at it, but I'm clueless without looking up each function :(  Which I can't really do (at work right now).  Sorry!
15:01:29 <aristid> i think using =$ and $= should make working with Enumeratees easier than using joinI
15:02:34 <sonoflilit> lispy: thanks, you solved it for me
15:02:34 <aristid> sonoflilit: but if you insist on using joinI, this works: enumList 10 [1..10] $$ joinI (Data.Enumerator.List.map (*2) $$ Data.Enumerator.List.consume)
15:02:51 <sonoflilit> what aristid did :)
15:03:03 <aristid> ??
15:03:30 <sonoflilit> I was going to write the solution, but you wrote it first
15:03:43 <aristid> i wrote TWO solutions :P
15:03:45 <mercurial> I suppose, a better question would be: is it possible at all to construct a list of GADT-phantom-typed values, where the phantom types differ? i.e. the base type is homogenous, but the phantom types vary?
15:03:59 <ezyang> niteria: It's tough stuff :-) 
15:04:31 <aristid> sonoflilit: now three: (enumList 10 [1..10] $= EL.map (*2)) $$ EL.consume
15:04:37 <kevinburke> http://hpaste.org/45302/parserrorinpattern
15:04:53 <ezyang> Curiously enough, the time I spent working on lattices in the book helped me out a lot when I started doing practical work with Hoopl. 
15:04:54 <kevinburke> this seems silly, but can someone help me figure out why I'm getting a parse error on line 4?
15:04:57 <lispy> mercurial: not directly
15:05:02 <akahn> Does Network.HTTP not support making HTTPS requests?
15:05:11 <ezyang> kevinburke: need a 'do' 
15:05:11 <sonoflilit> aristid: only one of them /after/ I began typing my solution
15:05:14 <lispy> akahn: that's what I've heard
15:05:20 <mercurial> lispy: I was hoping to avoid some sort of container ;-/
15:05:21 <kevinburke> another one? why?
15:05:57 <aristid> sonoflilit: i think the solution with (=$) is best
15:05:58 <ezyang> kevinburke: the case statement introduces another block 
15:06:02 <ezyang> it's not like let. 
15:06:32 <kevinburke> ezyang: ok, thanks
15:07:03 <lispy> mercurial: a phantom type is still a type though.  list are forall a. [a], not [forall a. a]
15:07:03 <lispy> mercurial:  but you could build the latter
15:07:08 <akahn> lispy: thanks. that's my impression as well. i guess i can use curl.
15:07:35 <lispy> akahn: yeah, the curl bindings are decent
15:07:57 <mercurial> lispy: thanks
15:09:26 <sonoflilit> aristid: I'm not sure I can use 0.4.9
15:09:31 <niteria> I'm looking for an easy read that would give me a lot of insight :D
15:09:44 <mercurial> niteria: aren't we all ;-)
15:09:55 <lispy> niteria: those two goals seem at opposition to each other :)
15:10:15 <lispy> If it's easy to understand, then typically you're not learning anything new
15:10:51 <niteria> most algorithmic stuff is easy to understand
15:11:10 <aristid> sonoflilit: why not?
15:11:28 <smarmy> looking to leverage sqlite... lots of options on hackage these days.  any recommendations?
15:11:29 <aristid> sonoflilit: if not, just copy the (=$) function into your code.
15:11:47 <niteria> I guess I'll try Pearls of Functional Algorithm Design
15:11:48 <hpc> hdbc is modelled on the perl interface
15:12:02 <hpc> it's what i use and it is fairly comfortable, but i came to it after perl
15:12:39 <niteria> but from what I remember it was mostly divide and conquer in this book
15:13:21 <parcs> i'm getting an unknown symbol error when attempting to run a gui in ghci with the "wxcore" package. is there anything i can do about this? i recall reading that wxhaskell is finnicky with ghci…
15:13:35 <KSkrzet> i would like to have Binary instance for Data.Array.IO.IOArray type from stock array package, but there isn't one. what are my options?
15:14:57 <MasseR> akahn: http-enumerator supports https
15:15:31 <frerich> Hi, I'm trying to implement a function 'occ :: [a] -> [(a, Int)]' which yields a list with tuples telling how often each element occurred in the list. My current elementation is at http://hpaste.org/45303/count_occurrances_of_elements - does anybody have suggestions how to improve this?
15:15:46 <akahn> MasseR: is there any documentation for that library?
15:15:59 <MasseR> akahn: haddock
15:16:34 <MasseR> Enough for me to make working code :P. And I'm a beginner
15:16:38 <MasseR> But bed ->
15:17:14 <rostayob> is there a way to partially apply type synonims? like a Language flag or something like that
15:17:18 <mzero> freirch: that looks just fine
15:19:25 <mzero> freirch: are you going for clarity of code, or extreme efficiency, or a learning experience?
15:19:49 <mzero> If I just needed that as a utility for small data sets --- I've written it exactly like that myself more than once
15:20:08 <koninkje> parcs: what OS are you on? sometimes ghci doesn't like FFI stuff on Windows
15:20:51 <frerich> mzero: I'm implementing a Huffman encoder & decoder as an exercise for myself (this involves counting how often each element in the input data occurs). So for the beginning, clarity is my goal. Eventually, I plan to go for lazy and/or strict Byte strings though.
15:20:53 <micahjohnston> > (,)<$>head<*>length.group.sort $ [1, 2, 3, 2, 3, 4, 1]
15:20:54 <lambdabot>   (1,4)
15:21:43 <micahjohnston> > map ((,)<$>head<*>length) . group . sort $ [1, 2, 3, 2, 3, 4, 1]
15:21:44 <lambdabot>   <no location info>: lexical error at character '\FS'
15:22:00 <parcs> koninkje: actually i'm on linux
15:22:03 <koninkje> rostayob: Nope. Though if you can define the synonym as partially applied, then you can
15:22:05 <mzero> freirch - than you're good for now - eventually, you may want to re-implement based on Data.Map for speed, or at any rate ease of iterating the bytes in a ByteString
15:22:11 <micahjohnston> > (map ((,)<$>head<*>length) . group . sort) [1, 2, 3, 2, 3, 4, 1]
15:22:12 <lambdabot>   <no location info>: lexical error at character '\FS'
15:22:14 <koninkje> rostayob: E.g., type List = []
15:22:15 <micahjohnston> :/
15:22:24 <ion> > (map ((,)<$>head<*>length) . group . sort) [1, 2, 3, 2, 3, 4, 1]
15:22:26 <lambdabot>   [(1,2),(2,2),(3,2),(4,1)]
15:22:46 <koninkje> parcs: then I'm out of ideas :)
15:23:32 <ion> > map (head&&&length) . group . sort $ [1, 2, 3, 2, 3, 4, 1]
15:23:34 <lambdabot>   [(1,2),(2,2),(3,2),(4,1)]
15:24:14 <rostayob> koninkje: ok, thanks
15:25:18 <aristid> :t liftA2 (,)
15:25:18 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
15:25:23 <aristid> :t (&&&)
15:25:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:26:47 <frerich> mzero: Great, thanks for your feedback.
15:27:25 <mzero> welcome
15:27:26 <mzero> > M.toList . foldr (\k m -> M.insertWith (+) k 1 m) M.empty $ [1,2,3,2,3,4,1]
15:27:27 <lambdabot>   [(1,2),(2,2),(3,2),(4,1)]
15:27:48 <mzero> btw - a way to do it via Data.Map
15:35:17 <ezyang> Does anyone have a PDF copy of "the lambda calculus its syntax and semantics" by Barendregt? 
15:37:40 <beastaugh> alas, no
15:37:46 <beastaugh> I have to keep renewing it from the library
15:40:56 <Lemonator> OH GOD HOW DID THIS GET HERE I AM NOT GOOD WITH COMPUTER
15:41:36 --- mode: ChanServ set +o copumpkin
15:42:04 --- mode: copumpkin set -o copumpkin
15:44:08 <ezyang> Why isn't head normal form used in Haskell? 
15:44:44 <copumpkin> how would you look through a function?
15:44:53 <roconnor> copumpkin: continuations
15:45:36 <copumpkin> how so?
15:46:19 <roconnor> to normalize f, call callcc (\k -> f k) kinda sort of
15:46:34 * roconnor hasn't actually thought this through
15:46:35 <copumpkin> hmmm
15:46:44 <ezyang> huhhh... 
15:47:01 <ezyang> I dinnae think that type checks 
15:47:06 <roconnor> it doesn't
15:47:33 <Lemonator> wait, isn't there a lambdabot plugin that shows the expansion of expressions?
15:47:45 <copumpkin> it's just a library
15:47:53 <copumpkin> > foldl (+) z [a,b,c,d]
15:47:54 <lambdabot>   z + a + b + c + d
15:48:08 <Lemonator> what library is that?
15:48:16 <copumpkin> simple-reflect iirc
15:49:40 <roconnor> how about f `seq` x = callcc (\k -> f (k x) `seq` x)
15:49:50 * roconnor is still making stuff up
15:50:21 <ezyang> if we cps transform f we might have something plausible 
15:51:15 <ion> :t :t callcc
15:51:15 <lambdabot> parse error on input `:'
15:51:17 <ion> :t callcc
15:51:17 <lambdabot> Not in scope: `callcc'
15:51:24 <copumpkin> :t callCC
15:51:25 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:51:38 <roconnor> ion: my code still won't typecheck in Haskell as such.
15:59:27 <dolio> I don't think there's any reason to expect that to actually reduce things to head normal form.
16:00:06 <dolio> It might evaluate that far.
16:00:25 <roconnor> what far?
16:01:13 <dolio> But, if you have 'f = \x -> (\y -> y) x', then I don't think your f `seq` v will cause f to be rewritten to \x -> x.
16:02:32 <dolio> If that's what we care about.
16:03:22 <roconnor> anyhow, I'd be happy to make Eval a type class again.  I think the excuses for dropping it were lame
16:04:13 <dolio> Dropping the existing one, which didn't really solve the issues, probably wasn't bad.
16:04:25 <dolio> An Eval that didn't have an (a -> b) instance would be good.
16:04:30 <roconnor> ya
16:04:36 <roconnor> I'm good with that
16:04:57 <copumpkin> WHNFData? :P
16:05:01 <roconnor> It's going into my Haskale 2011 report
16:05:26 <roconnor> or is it HasCale
16:06:31 <dolio> Anyhow, the whole point of WHNF was to reflect what kind of evaluation actually goes on in a non-strict language.
16:06:50 <dolio> HNF doesn't really cover it.
16:07:21 <dolio> In the absence of seq, evaluation of functions occurs prior to application, and it'd be odd to do callcc tricks there.
16:08:08 <hpc> what's the difference between WHNF and HNF?
16:09:04 <tromp__> whnf doesn't evaluate under lambda
16:09:07 <ezyang> HNF requires the left-most term inside a lambda-abstraction to be a variable 
16:09:30 <ezyang> I've always thought the name was kind of strange. 
16:09:32 <hpc> eh?
16:09:53 <hpc> so (\(x:xs) -> x) vs (\x -> head x) or whatever?
16:10:42 <ezyang> uh, pattern matching is complicated >.> 
16:11:11 <hpc> so what's the difference then? your explanation was confusing
16:11:20 <ezyang> a better example is \x -> id x versus \x -> x 
16:11:24 <koninkje> hpc: So (\x -> (\y -> y) x) is WHNF nit not HNF
16:11:50 <hpc> oh
16:11:54 <koninkje> HNF requires the (\y->y) x application to be reduced even though it's under the \x lambda
16:12:09 <koninkje> s/nit//
16:12:12 <hpc> cool
16:13:56 <koninkje> If you're actually implementing things as graph reduction then HNF is doable. But if you're compiling to native code then it gets tricky since it essentially requires you to be able to do symbolic evaluation
16:14:36 <koninkje> (i.e., efficient, directly executing, native code; as opposed to bytecode of some sort)
16:15:17 <copumpkin> TEH SUPERCOMPIL0R
16:15:27 <copumpkin> to put it eloquently
16:16:32 <koninkje> well, at some point it's all "native code" but that's what I was getting at, yes
16:16:44 <copumpkin> TEH SUPERCOMPIL0R
16:17:43 <centrinia> What is "native code"?
16:17:54 <copumpkin> it's native code, in quotes
16:18:05 <espringe> It's code that runs directly by the hardware
16:18:08 <koninkje> assembly code, machine code, etc
16:19:01 <espringe> As in, you'd say "python" is not native -- cause it's not in a format the hardware can run it
16:19:17 <espringe> (The native-code python interpreter can) 
16:19:28 <centrinia> The hardware does not directly run assembly code. It does not even directly run machine code.
16:19:47 <centrinia> Well, most modern hardware does not directly run machine code.
16:19:47 <copumpkin> define run
16:20:19 <KSkrzet> most Arm processors have extra mode for execution for JVM bytecode
16:20:34 <KSkrzet> in this sense JVM is native there
16:20:36 <copumpkin> KSkrzet: but nobody knows how to use it, cause ARM charges too much for the privilege
16:20:53 <xplat> centrinia: you could still safely say that it does, because the translation layer between machine code and the even-lower-level code is implemented in hardware
16:20:57 <copumpkin> and they eventually deprecated it
16:21:21 <centrinia> The machine code is just being translated, not run. :p
16:21:34 * espringe sighs
16:21:43 <copumpkin> centrinia: define run, then :)
16:21:51 <copumpkin> what about microcode is more "run" than machine code?
16:22:12 <centrinia> Good point, there is a progression. :p
16:23:51 <xplat> the hardware only runs charge distributions, not code :)
16:23:59 <monochrom> ARM charges an arm and a leg
16:24:07 <hpc> harr harr :P
16:24:11 <monochrom> hehehe
16:25:30 <KSkrzet> what about: native code is code that can be executed without further processing by software other than loading it into the hardware?
16:26:39 <copumpkin> define software
16:26:53 <copumpkin> define define
16:27:02 <KSkrzet> define = define
16:27:03 <xplat> defun defun
16:27:37 <alpounet> fix define
16:27:43 <copumpkin> fix id
16:28:11 <aristid> your bottom
16:29:06 <xplat> > fix . const $ 1
16:29:08 <lambdabot>   1
16:30:46 <xplat> i don't know how to define native code, but i know it when i see it
16:31:44 <monochrom> I define bare metal to mean silicon, a non-metal.
16:32:07 <xplat> it should really be called bare metalloid
16:32:23 <monochrom> yeah, bare anything except bare metal
16:32:24 <Lemonator> Would `print` output to anywhere but stdout?
16:32:39 <copumpkin> no, unless you're redirecting it
16:32:47 <Lemonator> okay
16:33:25 <monochrom> totally reflects the fact that those who boast about "I am close to bare metal" has absolutely no clue what is hardware
16:33:34 <Lemonator> I'm doing a `mapM_ print values` and attempting to pipe it elsewhere
16:33:43 <Lemonator> but all I'm getting is "()"
16:33:51 <Lemonator> No idea what's going on here.
16:33:53 <xplat> yes, it would be very hard to make a microprocessor out of metal
16:34:07 <koninkje> You have to redirect stdout to another Fd before printing
16:34:12 <xplat> although there typically is some metal in one
16:34:15 <hpc> Lemonator: values :: [()] is your problem
16:34:33 <Igloo> Lemonator: You might want "map show values"
16:34:50 <Lemonator> hpc, I'm pretty sure that is not my problem because printing to the terminal works fine.
16:35:07 <copumpkin> can we see the surrounding code?
16:35:09 <tromp__> where do you want to pipe it to?
16:35:29 <monochrom> paste early. paste often. paste completely.
16:35:35 <Lemonator> http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect.html
16:35:47 <Jeena> Hi, hm why is it expecting [Maybe Type] instead of [Type] here? https://gist.github.com/902722
16:35:53 <Lemonator> See that third example?
16:35:56 <Lemonator> I'm trying to run that.
16:36:35 <sipa> :t find
16:36:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:36:38 <rostayob> what does the ~ mean in type signatures?
16:36:45 <copumpkin> type equality
16:36:45 <sipa> rostayob: type equality
16:36:46 <Lemonator> I did a `mueval -n -l M.hs -e '<THAT THERE CODE>' | head -n 4`
16:36:57 <koninkje> rostayob: it's a delayed unificatin constraint
16:37:05 <koninkje> *unification
16:37:06 <Lemonator> where M.hs contains `import Debug.SimpleReflect`
16:37:35 <Lemonator> without the pipe, I get the output described there plus a "()" on a 5th line.
16:37:36 <monochrom> a type error in TypeChecker.hs :)
16:37:39 <rostayob> sipa, koninkje: ok I know less than before now :D
16:37:47 <Lemonator> with the pipe, all I get is "()".
16:37:49 <koninkje> :)
16:38:14 <koninkje> rostayob: You know how if you use (\x -> x) it infers the type a->a ?
16:38:14 <rostayob> for example, m ~ WebURL
16:38:15 <sipa> rostayob: you understand "type equality" ?
16:38:29 <monochrom> @type find
16:38:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:38:34 <sipa> rostayob: it simply means that m must be WebURL :)
16:38:55 <rostayob> sipa: so what's the difference between saying m and WebURL?
16:39:01 <monochrom> alright, it depends on what "infer" means
16:39:01 <sipa> rostayob: nothing
16:39:11 <KSkrzet> I have the following problem: write a function [ByteString] -> [ByteString] so that every element in this list that has a copy is replaced with single occurence, to save the memory
16:39:12 <rostayob> sipa: so... why would you write it in your code?
16:39:17 <hpc> sipa: so wtf is that syntax doing then? :P
16:39:18 <KSkrzet> unpure code is allowed
16:39:24 <koninkje> rostayob: that's because (1) it knows it's a function so it must be a->b and (2) it unifies a with b (i.e. realizes they must be the same)
16:39:25 <leimy> Anyone ever try "riak"?  :-)
16:39:31 <copumpkin> KSkrzet: nub? 
16:39:35 <copumpkin> :P
16:39:37 <sipa> hpc: you know type families?
16:39:45 <leimy> I'm fighting the bytestring data-text back and forth right now
16:39:47 <rostayob> koninkje: but that type is not inferred, it's in a piece of code I'm reading
16:39:52 <KSkrzet> copumpkin: oh, and I want it to be identity
16:39:52 <Jeena> leimy: isn't that the erlang thingy?
16:39:56 <hpc> sipa: no; i am not prepared to, atm
16:40:06 <leimy> there's stuff that's literally type Key = ByteString, but the compiler is getting all pissy about me using ByteString where Key is expeted.
16:40:07 <copumpkin> KSkrzet: "it"?
16:40:10 <tromp__> Lemonator, could mueval use stderr?
16:40:11 <leimy> Jeena: yep
16:40:12 <Jeena> leimy: I'm using their erlang_js but riak itself
16:40:19 <leimy> Erlang Dynamo like keystore stuff.
16:40:26 <copumpkin> KSkrzet: oh, I see
16:40:28 <KSkrzet> copumpkin: this function
16:40:28 <koninkje> rostayob: the (a ~ b) notation is just saying that that second step, the unification, must be delayed. Usually because of GADTs or type families
16:40:32 <n00blet> what does <- do in haskell? for example: c <- [0..size]]
16:40:35 <leimy> yeah I'm trying to use bos's Protocol Buffers client stuff.
16:40:35 <Lemonator> tromp__, I was thinking that, actually
16:40:45 <tromp__> but then you shld still see it....
16:41:03 <leimy> I'm deeply regretting the mixture of Data.Text and Data.ByteString and the fact that Haskell has the worst default String type ever :-)
16:41:03 <copumpkin> KSkrzet: use an intermediate Map then
16:41:04 <Saizan> leimy: there are 2 ByteString types
16:41:07 <leimy> well for literals :-)
16:41:14 <sipa> hpc: for examply you can write "class Collection m where type Element m :: *; getFirstElem :: m -> (Element m)"
16:41:14 <Lemonator> tromp__, but then I used "2>" to pipe stderr into a file and got nothing.
16:41:16 <leimy> Saizan: I know, I've been switching back and forth :-)
16:41:19 <leimy> no help there :-)
16:41:21 <Jeena> Protocol Buffers are this google generic protocol thingy aren't they?
16:41:27 <sipa> hpc: does that make sense?
16:41:34 <Eduard_Munteanu> n00blet: have you seen how do notation is desugared?
16:41:38 <leimy> Jeena: it's a data serialization/unserialization thingy for RPCs etc.
16:41:44 <Eduard_Munteanu> n00blet: it basically goes like this...
16:41:52 <tromp__> mueval may be testing where its output goes?!
16:42:13 <tromp__> mueval uses special Show instances for IO,
16:42:14 <rostayob> koninkje: ok, I'm afraid I have to learn about type families. I still don't see the practical difference in the code
16:42:39 <sipa> rostayob: same example to you, what i said to hpc 
16:42:42 <koninkje> rostayob: if you have a type like, data Foo :: * -> * where FooBool :: Foo Bool ; FooUnit :: Foo ()
16:42:46 <leimy> Anyway, I've been fighting this stuff too long... When I see ByteString in someone's Haddock docs, I can't tell what the hell it is :-)
16:42:49 <leimy> Lazy or Strict? :-)
16:42:54 <KSkrzet> copumpkin: I would like to use set-like container with function like "insert :: a -> Set a -> (Set a, a)", where the second returned value is equal to the inserted one, but possibly not the same one in memory
16:42:56 <copumpkin> KSkrzet: \xs -> let m = Map.fromList (map (join (,)) xs) in map (Map.lookup m) xs
16:43:01 <Jeena> yeah we had a brief look at it too after attending a Talk by Joe Armstrong, he said that one should not invent a new protocol because there were enough of them
16:43:02 <blackdog> koninkje: i liked your blog post, btw. nasty little bug.
16:43:02 <Eduard_Munteanu> n00blet: do { a <- foo; bar a }   ===   foo >>= \a -> bar a
16:43:16 <rostayob> koninkje, sipa: ah ok, that's a type family?
16:43:18 <copumpkin> :t Map.lookup
16:43:18 <lambdabot> Couldn't find qualified module.
16:43:23 <KSkrzet> :t join
16:43:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:43:30 <leimy> Jeena: I disagree wholeheartedly.   :-)  That's like saying don't make a new language, there's enough of them.
16:43:33 <hpc> :t M.lookup
16:43:33 <copumpkin> KSkrzet: that's really just a -> (a, a)
16:43:34 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
16:43:37 <rostayob> koninkje: it's the group of types defined within a data type?
16:43:39 <xplat> i've read some of SPJ's papers on type inference, so i know that ~ is needed to make some things typecheck that would otherwise fail, but i can't for the life of me remember what things.  it washed off my brain like water off a duck
16:43:43 <copumpkin> oh, I should use the other one
16:43:44 <Jeena> hehe leimy 
16:43:51 <copumpkin> KSkrzet: \xs -> let m = Map.fromList (map (join (,)) xs) in map (m Map.!) xs
16:43:58 <Eduard_Munteanu> n00blet: in your case, you're dealing with the list monad.
16:43:58 <n00blet> IM MOAR CONFUZD :(
16:44:00 <copumpkin> that should d it
16:44:02 <Jeena> at the end we came up with another protocol
16:44:05 <koninkje> rostayob: then if you do (\x -> case x of FooBool -> b ; FooUnit -> u) the outter function has type (Foo a -> B) for some B, but inside the case arms we know that (a ~ Bool) or (a ~ ())
16:44:19 <leimy> Jeena: languages are protocols anyway :-)
16:44:26 <sipa> rostayob: mine was an associated type
16:44:27 <Jeena> but still, a generic protocol isn't a really bad idea
16:44:39 <koninkje> rostayob: my example is a GADT
16:44:44 <leimy> There are times when it makes sense to use something native to the language
16:44:56 <Jeena> yeah and that is a problem because they are non compatible protocols
16:45:14 <leimy> Jeena: well unless you're in Python or Javascript, then you can just use JSON :-)
16:45:14 <koninkje> blackdog: thanks
16:45:19 <Jeena> you just cant send a message from a erlang node to a apache server ;)
16:45:21 <leimy> since JSON is a subset of both languages.
16:45:27 <Eduard_Munteanu> n00blet: you can think '<-' attaches names to things and helps desugar do notation into that form. Anything in particular which you're confused about?
16:45:32 <sipa> rostayob: in my case, imagine you wanted to write a function over Collections of whose Element are integers: getIntFirstElem :: (Collection c, Element c ~ Integer) => c -> Integer
16:45:35 <copumpkin> KSkrzet: make sense?
16:45:35 <rostayob> kosmikus: ok, I guess it makes sense
16:45:39 <xplat> protobufs seem to be better than ASN.1, and cover the same sort of problem space
16:45:46 <Jeena> but json is verbose, not as verbose as xml but still
16:45:49 <copumpkin> ASN.1 describes itself though
16:45:51 <leimy> but then JSON gets encoded to BSON sometimes.. so "blah" :-)
16:46:04 <KSkrzet> copumpkin: yes, certainly, thank you
16:46:07 <copumpkin> it's wonderful when I'm trying to figure out cryptographic protocols
16:46:18 <leimy> Jeena: you can very dangerously accept JSON off the wire and "eval" it :-)
16:46:30 <Eduard_Munteanu> Hm, maybe he didn't know about 'do' either, maybe it was a comprehensions question :/
16:46:31 <Jeena> btw. why is it expecting [Maybe Type] instead of [Type] here? https://gist.github.com/902722 (one more try)
16:46:53 <leimy> Jeena: I've seen automatically generated stubbs for thrift that have [Maybe Blah]
16:47:05 <KSkrzet> copumpkin: let's see if it fixed my problem of not buying enough RAM... ;-)
16:47:05 <Jeena> hehe yeah, the cool thing about json though is that there are libs for every language to translate from and into it
16:47:14 <copumpkin> Jeena: I'm going to guess that infer returns a Maybe?
16:47:15 <leimy> Actually worse... i've seen Maybe [Stuff]
16:47:17 <rostayob> sipa: oh ok.
16:47:19 <leimy> which is really pointles
16:47:20 <xplat> copumpkin: you're the first person i've heard say that they got anything out of ASN.1's attempts at self-description other than protocol overhead
16:47:26 <rostayob> sipa, koninkje: thanks to both
16:47:27 <leimy> [] and Nothing are basically the same thing
16:47:27 <copumpkin> leimy: is it? I approve in some situations
16:47:28 <Jeena> copumpkin: yes
16:47:37 <copumpkin> leimy: Maybe [Moo] has two distinguished values
16:47:41 <Guest18862> could someone point a example of instance functor (-> e) and where it's defined?
16:47:41 <copumpkin> leimy: [Moo] has one
16:47:51 <copumpkin> xplat: I do a lot of reverse engineering :P
16:48:01 <leimy> copumpkin: what's the difference between [] and Nothing?
16:48:05 <parcs> Guest18862: fmap = (.)
16:48:14 <Jeena> oh ah I see what you are trying to say copumpkin ...
16:48:16 <leimy> The name of the constructor? :-)
16:48:17 <copumpkin> leimy: depends on your domain. By compressing them into one value, you're discarding information
16:48:25 <sipa> leimy: [] is of type [a], Nothing is of type Maybe a
16:48:33 <rostayob> sipa: I had seen class with kinds in them before, but never bothered to understand. what should I look for to learn more about that?
16:48:45 <copumpkin> leimy: say you're filling out a form, and you let someone fill in a list of their friends, or omit it altogether
16:48:48 <leimy> sipa: yes but Maybe captures nondeterminism the same way a list can
16:48:57 <leimy> embedding a list in a Maybe seems silly to me :-)
16:49:00 <copumpkin> leimy: if they omit it, you return Nothing, whereas Just [] means they actually have no friends
16:49:09 <leimy> especially since maybe carries no reason for having nothing.
16:49:09 <copumpkin> if you compress those
16:49:14 <sipa> leimy: maybe can be seen as 0-or-1 solution, [] can seen as 0-to-N solutions
16:49:18 <xplat> copumpkin: i've done some reverse engineering too, maybe that would have helped if the protocols i was looking at used ASN.1 ... it's still pretty opaque though
16:49:21 <koninkje> leimy: E.g., Maybe String = either you have a string, or you don't
16:49:31 <copumpkin> xplat: it's enough to help if you have nothing else! :D
16:49:40 <leimy> copumpkin: yes but in the generated bindings I used... Just [] was acceptable where Nothing was an error.... it was like a stub compiler that had trouble doing something right :-)
16:49:49 <koninkje> leimy: that's different than assuming the empty string and no input are the same
16:49:53 <copumpkin> leimy: that's a problem with that code then, not Maybe [Moo] in general
16:49:58 <leimy> :-)
16:49:59 <leimy> right
16:50:01 <xplat> i've run into more protocols that used AIFF-like tags than anything else self-descriptive
16:50:07 <xplat> (and file formats)
16:50:08 <copumpkin> it's a perfectly reasonable thing to do in general
16:50:23 <leimy> In general I think Maybe should be replaced with Either :-)
16:50:35 <copumpkin> leimy: sometimes you just don't have something
16:50:38 <copumpkin> and no reason for not having it
16:50:48 <copumpkin> I'm generally not a fan of Either
16:50:53 <leimy> eh
16:50:56 <copumpkin> partially because I'm left-handed
16:51:00 <leimy> yeah
16:51:05 <copumpkin> and I resent that Left is always used for bad things
16:51:06 <leimy> the constructors suck in that regard
16:51:12 <leimy> It's biblical :-)
16:51:15 <koninkje> Either is excellent at what it's good for, but using Either() instead of Maybe is rather silly
16:51:32 <copumpkin> koninkje: with Either() you get to pretend you have another language, at least
16:51:39 <copumpkin> until you write the other parameter
16:51:45 <leimy> Disagree for the same reason I think an empty list convey's nothingness just as well as Nothing :-)
16:51:51 <leimy> but there you go.
16:51:51 <xplat> they should have named the constructors Up and Down
16:51:55 <copumpkin> leimy: they have different nothingnesses
16:52:03 <xplat> or Down and Up
16:52:04 <koninkje> copumpkin: well sure. And you can hide computation in the () too if you want. But still
16:52:08 <copumpkin> leimy: as I said, no friends vs. no answer
16:52:12 <leimy> [] :: [Int] is the same as Maybe Int for Nothing :-)
16:52:34 <leimy> and Just could be represented as a singleton list
16:52:38 <copumpkin> you're ignoring what I'm saying
16:52:44 <leimy> And the idea would be portable to other languages :-)
16:53:06 <leimy> copumpkin: prety much :-)
16:53:07 <leimy> :-)
16:53:19 <koninkje> leimy: Other languages use nullable pointers instead of Maybe. This isn't something to emulate
16:53:28 <copumpkin> do you consider data File = Link FilePath | PlainOl'File FilePath | Directory [FilePath] to be redundant?
16:53:31 <copumpkin> leimy?
16:53:33 <leimy> koninkje: yes, some do :-)
16:54:04 <leimy> copumpkin: Not really... but then again, the case I was working with made no sense.
16:54:13 <copumpkin> after all, the Link and PlainOl'File constructors could be compressed into one
16:54:21 <copumpkin> you'd discard ~a bit of information by doing so
16:54:33 <xplat> leimy: anything can be used incorrectly
16:54:35 <leimy> Yeah I know their' tags are missing
16:54:41 <copumpkin> I'm not talking about representations
16:54:43 <copumpkin> just conceptually
16:54:43 <leimy> xplat: well the bindings were just bunk :-)
16:54:47 <leimy> in one sense.
16:54:48 <copumpkin> you would no longer know whether you had a link or a file
16:54:53 <copumpkin> whereas before the constructors told you that
16:55:09 <leimy> Ok but the API being implemented was for a list of specifications that could have been empty
16:55:14 <leimy> not "you don't have a list" vs "empty list"
16:55:18 <copumpkin> okay, sure
16:55:22 <leimy> so the stub compiler didn't quite get it.
16:55:23 <copumpkin> you just kept saying that it didn't make sense in general
16:55:28 <copumpkin> and that's what I'm arguing against :P
16:55:44 <leimy> Eh, I've seen other folks say Maybe is more or less the same as a List before.  This is not a new claim :-)
16:55:53 <leimy> I mainly came in to vent :-)
16:56:01 <copumpkin> yes, but Maybe [Moo], if Maybe is like a list with 0 or 1 elements
16:56:05 <copumpkin> is closer to [[Moo]]
16:56:07 <xplat> leimy: unoriginality doesn't win you points :)
16:56:09 <copumpkin> not [Moo]
16:56:12 <leimy> copumpkin: true.
16:56:22 <leimy> xplat: Oh I didn't come in for Karma :-)
16:56:29 <copumpkin> leimy++
16:56:30 <copumpkin> muahahaha
16:56:33 <leimy> nor did I come in to troll :-)
16:56:43 <leimy> just felt like bitching on a rainy monday :-)
16:56:52 <leimy> copumpkin: I see your point.
16:57:01 <copumpkin> it's really arguing about "the lack of a value vs. the presence of the lack of a value"
16:57:02 <leimy> I really do... I'm just frustrated today.
16:57:09 <copumpkin> I imagine :)
16:57:12 <copumpkin> anyway, so am I!
16:57:20 <copumpkin> so maybe I sound more forceful than I mean to
16:57:22 <leimy> Right the presence of the lack of value... seems weird... Existentially
16:57:27 <xplat> it's like the difference between an empty box and no box
16:57:39 <leimy> Just "is" a box :-)
16:57:41 <leimy> by definition
16:57:48 <leimy> Nothing is not a box
16:57:55 <leimy> but it carries some type information.
16:58:07 <xplat> (Just []) is an empty box, Nothing is no box
16:58:26 <leimy> right... that's very difficult to explain in other languages.
16:58:33 <copumpkin> xplat: what do you reverse engineer?
16:58:39 <leimy> SO I can see how the bindings generator got it wrong :)
16:59:27 <leimy> Anyway... I'm getin "Couldn't match expected type `Key' against inferred type `B8S.ByteString'
16:59:36 <leimy> but Key is defined in Haddock docs as ByteString
16:59:42 <leimy> and now I must murder a small animal
17:00:05 <leimy> I mean, it's a type synonym "type Key = ByteString"
17:00:14 <xplat> copumpkin: i've mostly done file formats, but i've messed with a few wire formats including one for retrospect (backup software) and of course the odd bit of executable code
17:00:21 <copumpkin> cool
17:00:39 <koninkje> Or, ala theoretical computer science: it's the distinction between empty languages and languages containing the empty string
17:00:44 <xplat> i've done a lot of looking into odd bits of JPEG and GIF metadata
17:01:00 <Jeena> copumpkin: thanks checking for Nothing on the infer type did the trick. That is the lack of experience with Haskell.
17:01:05 <leimy> oh for gods sake... half the library uses Lazy bytestring, and the other half strict
17:01:26 <xplat> koninkje: or, ala academic disciplines in general, the difference between wrong and not even wrong
17:01:32 <copumpkin> Jeena: great! 
17:01:42 <copumpkin> lol
17:02:13 <copumpkin> haveYouStoppedBeatingYourWife :: IO (Maybe Bool)
17:02:30 <Jeena> hehe
17:02:52 <leimy> bah!  
17:03:04 <leimy> I wish the Strict ByteString was called StrictByteString
17:03:09 <leimy> it'd be so much easier to track
17:03:14 <copumpkin> yeah, the overloaded names are annoying
17:03:34 <leimy> It makes me want to kick myself in the nuts... but that's surprisingly difficult while sitting.
17:03:47 <Jeena> you could get up
17:03:53 <leimy> Jeena: that'd take work
17:03:53 <xplat> it's called B.ByteString, and the lazy one is L.ByteString, right?
17:04:09 <byorgey> if you've imported them qualified.
17:04:15 <leimy> And I'm more into Lazy ByteStrings.
17:04:20 <byorgey> which you ought to do.
17:04:39 <leimy> byorgey: yes, but the Haddock docs say "ByteString"
17:04:50 <byorgey> leimy: ah, yes, that is a pain.
17:04:55 <leimy> then you have to open the source to find out which one was used.  or try to figure it out from compiler errors :-)
17:04:57 <xplat> (but it's annoying when the tools try to print something unqualified, yeah)
17:05:08 <byorgey> leimy: Haddock does not deal well with qualified names in general.
17:05:15 <xplat> leimy: you could also hover and check the browser status bar
17:05:16 <KSkrzet> i always look where the link goes
17:05:17 <byorgey> although it's hard to know exactly what you would want it to do.
17:05:18 <copumpkin> there's a patch in to make it do so I think
17:05:23 <leimy> In the meantime you've kicked yourself in the nuts, but won't notice until you evaluate your crotch.
17:05:25 <copumpkin> it'd appease HT
17:05:28 <leimy> because you did it lazily 
17:05:30 <byorgey> haha
17:05:35 <byorgey> copumpkin: indeed =)
17:05:46 <Alan> Is there something like the Num typeclass for boolean-like things?
17:06:03 <Alan> i.e. a typeclass that defines (&&), (||) and not ?
17:06:04 <sipa> unfortunately, no
17:06:11 <Alan> damn
17:06:12 <byorgey> Alan: no, but see the AwesomePrelude
17:06:31 <copumpkin> https://github.com/pumpkin/peano/blob/master/Structures.hs#L33
17:06:45 <xplat> Alan: closest thing in the standard stuff is Bits
17:07:09 <xplat> but that's more boolean-algebra-y
17:07:37 <Alan> xplat: yeah, and a much bigger minimum definition than i want
17:09:46 <Alan> byorgey: tempting, but i'd rather not add a whole different prelude as a dependency here, trying to stay within the standard stuff
17:10:07 <byorgey> Alan: sure, I wasn't necessarily suggesting you ought to use it
17:10:15 <byorgey> just that you might find it interesting =)
17:10:40 <byorgey> Alan: you can make your own type class, perhaps?
17:10:51 <Alan> copumpkin: that's interesting, looks kinda like what i was tempted to do anyway (define a typeclass then make Bool a member of it)
17:12:34 <xplat> Alan: what other sort of instances were you planning on?
17:12:39 <Alan> it's a shame that haskell doesn't allow multiple non-overlapping definitions
17:13:01 <copumpkin> I'm quite happy it doesn't :)
17:13:04 <copumpkin> except for constructors
17:13:09 <xplat> Alan: multiple non-overlapping definitions of what?
17:13:12 <copumpkin> I'd like data constructors to be allowed to overlap
17:13:35 <Alan> xplat: I guess of anything
17:13:57 <lispy> copumpkin: Can that be safe in Haskell?
17:14:14 <Alan> since values are functions of arity 0, would seem silly to restrict to just "functions"
17:14:16 <copumpkin> it'd mean doing :t Moo won't have a good answer
17:14:19 <KSkrzet> I need NFData for Data.ByteString.ByteString... what should I do?
17:14:22 <lispy> But, we do have overlapping values in Haskell anyway.  _|_ :)
17:15:16 <Alan> lispy: heh, i like _|_, always feels like i'm giving the language the finger :P
17:15:16 <Alan> "screw you, i don't know what this is"
17:15:19 <xplat> copumpkin: wouldn't that more or less completely break type inference?
17:15:32 <enthymeme> hahah
17:15:37 <copumpkin> xplat: pff
17:16:30 <Alan> xplat: well in this case I've got a type of SVal = ZVal Int | TVal Bool
17:16:34 <xplat> other than explicit signatures, constructor names are essentially the raw data that type inference bootstraps from
17:16:52 <Alan> xplat: i'm making SVal an instance of Num so i can do arithmetic on ZVals with the normal operators
17:17:13 <Alan> xplat: i want to also be able to do boolean arithmetic with TVals
17:17:23 <Alan> but I feel this is actually a different pattern
17:17:26 <xplat> Alan: so what is ZVal 1 + TVal True?
17:17:35 <Axman6> KSkrzet: instance NFData Bytestring where rnf x = x `seq` ()
17:17:43 <Alan> maybe something that would allow me to lift the value out of the constructor
17:17:48 <KSkrzet> Axman6: Just it? Will it work?
17:17:56 <Alan> xplat: undefined, intentionally
17:18:18 <Axman6> KSkrzet: you could use rnf x = BS.length x `seq` ()
17:18:50 <Axman6> length should only be defined if the data has been read in i think. there's bery little laziness in non-lazy bytestrings anyway
17:18:57 <byorgey> Alan: partial operations, ick
17:19:00 <xplat> Alan: i feel like this is the wrong kind of DWIM, struggling against the type system rather than using it
17:19:09 <Alan> it feels like i should be able to do something like "magic (+) z1 z2"
17:19:15 <Alan> xplat: DWIM?
17:20:03 <xplat> Alan: "Do What I Mean", in other words, what perl tries to do
17:20:16 <KSkrzet> Axman6: I just learned the default implementation is the first one you provided
17:20:22 <Axman6> yes
17:20:56 <xplat> Alan: you're trying to just ignore the fact that your values are wrapped, but the wrappers have meaning
17:21:56 <Alan> xplat: my problem is that i have a value stack for this little emulator thing which can have truth values and numeric values on it
17:22:09 <Alan> and i didn't like the idea of representing truth values as numeric values
17:22:23 <Alan> hence the SVal data type that i've defined
17:22:44 <Axman6> SVal is a constructor not a data type btw
17:23:01 <xplat> no, SVal is a data type
17:23:08 <xplat> ZVal and TVal are constructors
17:23:21 <Axman6> oh my bad, indeed... i lost the definition :)
17:23:23 <xplat> presumably the 'S' is for 'Stack'
17:23:29 <Alan> yes
17:23:50 <xplat> and 'Z' is for 'integer', and 'T' for 'Truth'
17:24:33 <xplat> (in german, iirc, Z actually does stand for integer in the conventional way)
17:25:04 <Alan> yup
17:25:15 <xplat> but why do you need to do arithmetic on your stack values?
17:26:01 <Axman6> xplat: Z for integer is pretty common in english too
17:26:05 <xplat> it seems like for that to even be worth it your stack machine must have more primitives than the Num class has methods
17:26:09 <Alan> because it makes the emulator code more readable
17:26:25 <hpc> Z is the symbol for the set of integers
17:26:25 <Alan> xplat: it's the difference between
17:27:14 <Alan> execute ADD (pc, (ZVal z1):(ZVal z2):stack) = (pc + 1, (ZVal (z1 + z2)):stack)
17:27:36 <Alan> and: execute ADD (pc, z1:z2:stack) = (pc + 1, (z1+z2):stack)
17:28:33 <byorgey> but in the first case you can have another case where you handle a dynamic type error appropriately.  In the second case it just crashes.
17:29:42 <Alan> but the first case is getting towards fugly
17:30:05 <xplat> how about 'execute ADD = on2int (+)'
17:30:35 <xplat> and all the fugly stuff occurs in on2int, once for all binary arithmetic operators
17:31:48 <Axman6> on2int f (pc, ZVal x: ZVal y: stack) = (pc+1, ZVal (f x y):stack); on2int _ _ = error "Not two ints" or something...
17:32:35 <Axman6> probably also needs on2intBool which takes Int -> Int -> Bool
17:33:03 <Alan> hhmm
17:33:06 <Alan> I see what you mean
17:33:42 <Alan> that might work...
18:03:02 * monochrom has updated http://www.vex.net/~trebla/haskell/calculator/Calculator.html to the new haddock theme!
18:05:57 <Berengal> What's a good small Haskell binding I can look at as an example when writing my own?
18:06:13 <Berengal> Haskell-C binding*
18:07:11 <ddarius> kmc just gave a talk about a binding he's working on and bindings in general.
18:08:45 <Berengal> link or it didn't happen
18:09:02 <monochrom> and http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html too!
18:10:17 <monochrom> I think the haskell wiki has some not-to-small examples
18:10:58 * Berengal looks
18:12:00 <monochrom> try to ask it to search for "FFI"
18:12:17 <monochrom> I hope the examples help rather than lose :)
18:12:59 <ddarius> Berengal: http://www.ugcs.caltech.edu/~keegan/
18:18:27 <Berengal> ddarius: Thanks
18:18:40 <monochrom> I have a trivial example if you like. http://hpaste.org/45306/trivial_ffi_example
18:18:58 <monochrom> I haven't really used FFI, so I don't have any better example.
18:19:48 <Alan> what's the function/pattern that will do something like d(c(b(a(x)))) given arguments of [a, b, c, d] x ?
18:20:15 <parcs> :t foldr (.)
18:20:16 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
18:20:24 <parcs> :t foldr (.) id
18:20:24 <lambdabot> forall b. [b -> b] -> b -> b
18:21:02 <Alan> awesome
18:21:04 <Alan> thanks :)
18:21:11 <parcs> actually
18:21:18 <parcs> :t foldl' (.) id
18:21:19 <lambdabot> forall a. [a -> a] -> a -> a
18:21:23 <qz> is there any way to convert (IO a, IO b) into IO (a, b) ?
18:21:30 <parcs> wait no the original is fine in your case
18:22:10 <Alan> ah, i see, that's a fold on function composition
18:22:59 <Axman6> qz: curry (liftM2 (,)) i think
18:23:07 <Axman6> :t curry (liftM2 (,))
18:23:07 <lambdabot> forall b a2 a. (Monad ((,) a)) => a -> b -> (a, a2) -> (a, (b, a2))
18:23:12 <Axman6> o.O
18:23:18 <qz> ouch
18:23:19 <Axman6> :t uncurry (liftM2 (,))
18:23:20 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
18:23:25 <Axman6> better
18:23:29 <Axman6> i always get them backwards
18:23:41 <qz> thanks
18:24:39 <Axman6> qz: but if you're just learning, you probably want: f a b = do {x <- a; b <- y return (x,y)}
18:25:00 <qz> Axman6, yeah.. this one is better for understanding ;) thanks again
18:25:32 <ion> @pl \(a, b) -> a >>= \x -> b >>= \y -> return (x, y)
18:25:32 <lambdabot> uncurry (liftM2 (,))
18:25:53 * Axman6 wins
18:26:12 <KSkrzet> how does @pl works?
18:26:21 <Axman6> magic
18:26:52 <ion> @vixen How does @pl work?
18:26:53 <lambdabot> is that really what you want to know?
18:28:41 <parcs> KSkrzet: look at the pointfree package in hackage
18:28:42 <KSkrzet> I'm used to magic. I just want to know if it's pure.
18:29:27 <fryguybob> KSkrzet: also see the last article in http://themonadreader.wordpress.com/2011/01/09/issue-17/
18:30:09 <Axman6> KSkrzet: i don't really see how purity is relevant...
18:30:49 <ion> @pl \(a, b) -> (,) <$> a <*> b
18:30:49 <lambdabot> uncurry ((((,) <$>) .) . (<*>))
18:30:52 <ion> pretty
18:32:20 <KSkrzet> Axman6: oh, when one starts talking about magic, purity might have some overloaded meaning
18:48:05 <wharzl> \l
18:49:03 <wharzl> how do I interface with the bot?
18:49:39 <monochrom> a direct USB neural interface is in the works
18:49:49 <monochrom> meanwhile, "> 1+1"
18:50:04 <wharzl> ty
18:51:31 <wharzl> is there a way to create a list that holds any type of values?
18:51:42 <monochrom> no
18:52:19 <dolio> Lists can hold any type of values.
18:52:22 <dolio> Just one at a time.
18:52:43 <wharzl> like [5, "ert"]
18:53:02 <shachaf> wharzl: What would you do with such a list?
18:53:40 <wharzl> so there's no universal sub type in haskell
18:54:01 <copumpkin> wharzl: I think you're assuming that you can ask for the type of a value at runtime
18:54:24 <Axman6> wharzl: what would be the type of [5,"foo"]?
18:54:35 <copumpkin> [Any]
18:54:40 <wharzl> er, basetype
18:54:46 <mauke> what's a basetype?
18:54:50 <copumpkin> Haskell doesn't have subthyping
18:54:54 <wharzl> ya, like an any type
18:54:54 <copumpkin> fucking keyhboard
18:55:04 <Axman6> this isn't OOP yo
18:55:06 <mauke> wharzl: what are the operations of that type?
18:55:11 <copumpkin> wharzl: if you only know it's Any, what can yhou do with it?
18:55:36 <wharzl> you could pattern match on it and do an operation if it's a match, otherwise nothing
18:55:40 <copumpkin> no
18:55:46 <mauke> pattern match, hmm
18:55:47 <Axman6> that's not well typed
18:55:50 <mauke> wharzl: what are the constructors?
18:55:57 <copumpkin> you come from scala? :)
18:56:05 <Axman6> or erlang >_>
18:56:12 <wharzl> there's no ctors
18:56:18 <copumpkin> scala has an any type and does pattern matching via subtyping
18:56:20 <mauke> you can't pattern match without constructors
18:56:39 <KSkrzet> of course if you use generics you can have such list
18:56:51 <monochrom> just use an algebraic data type for pattern matching
18:57:30 <wharzl> I'm just studying different languages
18:57:37 <wharzl> I'll go see scala's semantics
18:58:00 <monochrom> don't just study different languages. study different perspectives
18:58:01 <copumpkin> it behaves exactly the way you described
18:58:09 <Axman6> i think you're coming at haskell with a lot of preconceptions that don't make sense in a language like haskell with strong typing and all the other niceness it has
18:58:25 <mauke> fuck your "strong typing"
18:58:25 <copumpkin> scala has a pretty crazy type system too
18:58:38 * copumpkin fucks his "strong typing"
18:58:46 * hackagebot string-class 0.1.5.1 - String class library  http://hackage.haskell.org/package/string-class-0.1.5.1 (ByronJohnson)
18:59:00 <Axman6> you can't beat strong typing, it's too strong!
18:59:12 <copumpkin> just cut its hair
18:59:18 <mauke> there's no such thing as strong typing
18:59:48 <Axman6> there is if you pound the keys hard enough
19:00:21 <shachaf> Don't get mad. Axman6 meant to say "muscular typing".
19:00:27 <monochrom> where is Robert Harper's class vs type blog?
19:00:34 <rbarraud> copumpkin: Samsonize it lol
19:02:08 <monochrom> http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
19:02:43 * copumpkin is making yet another variation on the iteratee theme, for fun
19:04:11 <dolio> Another?
19:04:20 <dolio> 2 isn't enough?
19:04:57 <monochrom> like car doors, you don't say "enough" until there are 5
19:04:58 <Berengal> Did the GHC include headers change recently?
19:05:00 <copumpkin> they both bother me for different reasons
19:05:19 <copumpkin> I'm trying to see if I can fix what bugs me
19:05:22 <dolio> Are you sure they don't bother you because they're iteratees? :)
19:06:00 <copumpkin> that might be it!
19:06:14 <copumpkin> but I'm going to try to make them suck a little less
19:07:03 <Axman6> hooray
19:07:11 <copumpkin> keep in mind that this is me
19:07:21 <copumpkin> so it'll probably never get released, just like 99% of my other shit
19:07:40 <Axman6> heh
19:07:45 <Berengal> copumpkin: You should put a few continuation layers on top of them. Everything is better with ContT
19:07:59 <copumpkin> Berengal: yeah! I currently plan to put three layers of ContT 
19:08:04 <copumpkin> do you think that is enough?
19:08:24 <copumpkin> that's one of my main gripes with the current ones
19:08:27 <copumpkin> not enough layers of ContT
19:08:52 <Berengal> I like to use five, but you need something to put inbetween them or they become boring again
19:09:23 <Axman6> from what i observed at Tsuru, making iteratees use continuations leads to very large problems in the real world
19:09:26 <copumpkin> oh yeah, I have a MaybeT after the first one, and an RWST after the second, then I wrap the whole thing in a LogicT
19:09:40 <Axman6> and they're extremely difficult to track down
19:09:43 <Berengal> It's like lasagna; you can't just stack layers of pasta on top of each other without sauce in the middle
19:09:43 <copumpkin> Axman6: iteratees are effectively continuations
19:09:57 <copumpkin> or you mean the non-constructor form of them?
19:10:23 <Axman6> well, whatever changed from iteratee-0.3 to 0.4 made them perform very badly for code that was working very nicely before
19:10:35 <copumpkin> ah
19:10:55 <copumpkin> GHC did have some bad behavior with some CPS'd code recently iirc
19:11:00 <ion> monochrom: Good article.
19:11:35 <copumpkin> the CMU trollprof
19:11:41 <copumpkin> built to troll reddit
19:12:18 <Berengal> Built by whom?
19:12:54 <dolio> The government!
19:13:28 <raininja> so can anyone help with this issue that I am having trying to build X11?
19:13:33 <KSkrzet> does anyone know of good bytestring hash library?
19:13:39 <copumpkin> raininja: maybe, but not people in here
19:13:46 <raininja> Invocation command line was   $ configure --with-hc=ghc
19:13:51 <KSkrzet> I mean, hash function good for hash tables that work with bytestrings
19:13:51 <copumpkin> oh okay :)
19:14:15 <copumpkin> KSkrzet: doesn't the hashable package have one?
19:14:29 <raininja> i am new to building with cabal and i am wondering where i need to edit to change this invocation
19:15:00 <KSkrzet> copumpkin: it does, thank you
19:15:45 <raininja> here is the config.log http://ompldr.org/vODRjdQ
19:19:53 <raininja> i assume it should be --with-hc-pkg=ghc
19:22:54 * copumpkin ponders not even allowing monadic iteratees
19:23:03 <copumpkin> maybe I'll only allow PrimMonad ones :D
19:23:07 * copumpkin cackles evilly
19:23:15 <raininja> ./config.status:  with options \"'--with-hc=ghc'\"                                                                                                                                              
19:23:30 <raininja> ok
19:23:32 <raininja> getting there
19:23:41 <Axman6> what are you actually running?
19:25:29 <raininja> runhaskell Setup configure
19:25:50 <raininja> in the X11-1.5.0.0/
19:26:39 <raininja> i seem to need this to build xmonad-0.9 :)
19:28:21 <KSkrzet> are there any RTS flags that can be used to speed up program that does a lot of GC?
19:28:22 <copumpkin> so one thing that's always bothered me about iteratees is that you can (as far as I can tell) return a Cont when you get fed EOF
19:28:30 <copumpkin> what part of EOF do you not understand?
19:28:50 <copumpkin> so everything is implicitly in Maybe
19:31:14 <Kaidelong> :t forkIO
19:31:14 <lambdabot> Not in scope: `forkIO'
19:31:57 <Axman6> IO () -> IO ThreadId
19:32:38 <Kaidelong> :t liftM (const ())
19:32:39 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m ()
19:33:11 <Kaidelong> fix (forkIO . liftM (const ()))
19:33:36 <Kaidelong> will this work?
19:33:45 <Kaidelong> out of curiousity alone
19:34:22 <copumpkin> it doesn't actually fork an OS thread
19:34:31 <copumpkin> "fork"
19:34:42 <Kaidelong> so it's not a forkbomb yet
19:34:47 <KSkrzet> forkOS does
19:34:47 <parcs> it'll slow your system to a crawl
19:34:52 <copumpkin> KSkrzet: not it doesn't
19:34:59 <copumpkin> -t
19:35:07 <copumpkin> it's a bad name
19:35:19 <Axman6> it'll use a lot of memory, but that's about it
19:35:23 <KSkrzet> copumpkin: ah, true, Posix.fork does fork()
19:35:55 <monochrom> x = forkIO (x >> return ())  probably reaches an equilibrium of spawning and ending threads
19:35:59 <ion> % ulimit -u
19:35:59 <ion> 400
19:36:01 <Axman6> KSkrzet: forkIO is used for making haskell threads, which are extremely lightweight. lighter than erlang threads
19:36:06 <ion> No fork bombs here. :-)
19:36:35 <KSkrzet> Axman6: yes I know that
19:36:45 <Kaidelong> saw something saying that "write a fork bomb" is a good interview question for finding out that people know how to identify them
19:36:46 <Axman6> just making sure
19:37:06 <ion> :(){:|:;};:
19:37:11 <Axman6> that's the one
19:37:38 <Axman6> in 1000 years, humans will look back at us and think that was our symbol for god
19:38:08 <KSkrzet> even better, they will be some that will try to worship this ancient god
19:38:56 <Axman6> ion: isn’t there usually an & in there?
19:39:07 <Axman6> :(){:&|:};:
19:39:24 <Kaidelong> I'm going to guess that's how you do it in bash
19:39:30 <Draconx|Laptop> Axman6, you can replace the | with an & if you prefer.  Your version with both is a syntax error.
19:40:04 <ion> The :|: already runs the first one in background. How does & make it bomb more?
19:40:17 <ddarius> Axman6: In a thousand years, people will look back and see a bunch of demagnetized iron platters.
19:40:19 <Kaidelong> in perl it was just "fork();" right?
19:40:54 <Axman6> ddarius: good point. what medium do we use to store information for 1000 years?
19:41:27 <parcs> stone!
19:41:44 <raininja> Axman6: any hints?
19:42:09 <Axman6> stone was the only thing i could think of too
19:44:00 <raininja> Distribution.Simple.defaultUserHooks?
19:44:16 <Draconx|Laptop> Axman6, http://www.rosettaproject.org/about/
19:45:17 <Axman6> hmm, I've seen that before, very cool :)
19:45:20 * Axman6 -> away
19:51:01 <dmwit> At the end of time, people won't exist and all matter will be spread out uniformly across space. So what's the point anyway?
19:51:27 <osoleve> the point is, bacon is delicious and we should make it out of more types of animals
19:51:47 <osoleve> ...catbacon.
19:52:41 <ion> manbacon
19:53:40 <ion> One can’t really tell the difference between the tastes of manbacon and ladybacon.
19:54:33 <osoleve> s/manbacon and ladybacon/studbacon and whorebacon/
19:54:38 <osoleve> it's all about marketing
20:03:16 <nyingen> I figured out my graphviz problems. I somehow missed the fact that graphviz is tied to FGL. The FGL docs explained all.
20:09:41 <Bfig_> can i do this declaration: data Mono = Mono Int Int ?
20:09:55 <tswett> Bfig_: yep, I think so.
20:10:00 <tswett> I see nothing wrong with it.
20:10:03 <Bfig_> sweet =). thanks
20:10:19 <tswett> You'll essentially be defining Mono as a pair of Ints.
20:10:32 <Bfig_> just wondering if there was something wrong with using the same name for the constructor as the def. yep, it's supposed to represent a monomial
20:11:06 <tswett> Nope.  Mono the type is in the namespace of types, Mono the data constructor is in the namespace of values.  Those are allowed to overlap.
20:11:15 <tswett> So yeah, you can do that.
20:11:29 <tswett> And people often do.
20:12:33 <Kaidelong> Mm I can see another reason to keep top level bindings short
20:12:53 <Kaidelong> functional decomposition for stuff like refactoring code to be parallel
20:15:08 <Bfig_> i need to do stuff with polynomials and polynomial expressions, so #haskell to the rescue! :p
20:17:05 <Kaidelong> flip zipWith (^) [1..]
20:17:33 <Kaidelong> type Polynomial = [Double]
20:17:52 <tswett> Remember: constant term first.  :P
20:18:31 <Kaidelong> oh right
20:19:14 <tswett> Then [] means 0, and t : ts means t + x*(ts).  So [2,5,3] = 2:5:3 = 2 + x*(5 + x*(3 + x*0)) = 2 + 5x + 3x^2.  'Tis better to be meaningful than not.
20:19:34 <Kaidelong> :t zipWith (*) . zipWith (^) [0..]
20:19:34 <lambdabot> forall a b. (Num a, Integral b, Enum a) => [b] -> [a] -> [a]
20:19:35 <tswett> And now you can represent formal power series, too.
20:19:55 <Kaidelong> :t zipWith (*) . flip zipWith (^) [0..]
20:19:56 <lambdabot>     Couldn't match expected type `[a]'
20:19:56 <lambdabot>            against inferred type `a1 -> b -> a1'
20:19:56 <lambdabot>     In the second argument of `flip', namely `(^)'
20:20:09 <Kaidelong> :t zipWith (*) . flip (zipWith (^)) [0..]
20:20:10 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
20:22:21 <parcs> > liftM2 (==) (flip (zipWith (^)) [0..]) (zipWith (flip (^)) [0..])
20:22:22 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
20:22:22 <lambdabot>    arising f...
20:22:29 <parcs> @check liftM2 (==) (flip (zipWith (^)) [0..]) (zipWith (flip (^)) [0..])
20:22:29 <lambdabot>   "OK, passed 500 tests."
20:23:45 <tswett> Now, in an Agda-like programming language, you want it to be impossible to write an infinite loop (except using something akin to the IO monad).  Recursive types may be allowed sometimes, but not in general; you don't want to allow the type "data Para = P (Para -> Void)", where Void is the empty type.
20:24:36 <tswett> This is because a value of type Para exists if and only if it does not exist.  The function taking a type a and returning the type (a -> Void) has no fixed point.
20:24:52 <tswett> Which makes me wonder: in general, when does a function taking types to types have a fixed point?
20:25:58 <tswett> The type-level function \a -> (a -> Void) takes all true types to false types and vice versa, so it can't have a fixed point.  If a function takes any false type to a false type, then I guess it has a fixed point, since really, there's only one false type.
20:26:26 <tswett> Suppose the function takes some true type to a true type.  Does that mean it has a fixed point?
20:26:29 <Kaidelong> > (zipWith (*) . flip zipWith (^) [0..]) [1,1,1] [1,1,1]
20:26:29 <lambdabot>   Couldn't match expected type `[a]'
20:26:29 <lambdabot>         against inferred type `a1 -> b -...
20:27:03 <Kaidelong> > (zipWith (*) . flip (zipWith (^)) [0..]) [1,1,1] [1,1,1]
20:27:04 <lambdabot>   [1,1,1]
20:27:16 <Kaidelong> ah you need sum as well
20:27:32 <dolio> tswett: No.
20:29:01 <tswett> I guess the thing about a plain old regular recursive type, like "data List a = Nil | Cons a (List a)", is that if you start with a type and repeatedly apply the type-level function (\la -> Maybe (a, la)), you essentially end up with an infinite sequence of true types, and the sequence has a limit.
20:29:17 <tswett> Suppose, then, that your type-level function takes *every* true type to a true type.  Then must the function have a fixed point?
20:29:27 <dolio> No.
20:32:05 <dolio> The powerset functor takes inhabited sets to inhabited sets, but has no fixed point.
20:33:56 <tswett> data TSet = T (TSet -> Bool).  Yeah, I don't think I want that to have fixed points.  :P
20:34:00 <lispy> byorgey: ping
20:34:12 <dolio> You certainly don't.
20:34:34 <dolio> It allows you to write a looping inhabitant of Bool.
20:34:47 <dolio> Just like it lets you write a looping inhabitant of bottom.
20:35:01 <lispy> Has anyone written a tool yet to grep over my source code and create issues in github for all my TODO: foo, items? ;)
20:35:05 <tswett> Oh, duh.  Russell's paradox is right there.
20:35:21 <ddarius> The powerset functor takes every set to an inhabited set.
20:35:48 <dolio> Yes, but he only asked about where 'true' sets get taken.
20:36:07 <tswett> I could be boring and ban recursive types altogether.  After all, a list is just a function from the naturals, and a tree is just a function from... also the naturals.
20:36:19 <tswett> Also the naturals, but differently.  :P
20:36:41 <ddarius> The naturals are a recursive type.
20:36:44 <dolio> You don't have to ban them.
20:36:58 <tswett> Yes, but which ones do I allow?
20:37:06 <tswett> ddarius: they are indeed, but I could make them primitive.
20:37:06 <dolio> But 'takes inhabited types to inhabited types' isn't a good enough restriction.
20:37:29 <ddarius> Incidentally, Vaughn Pratt long ago made an argument against such recursion and toward types defined in such a way.
20:37:40 <dolio> The restriction that's usually used in total type theories is: strictly-positive.
20:37:47 <raininja> got it!
20:38:27 <raininja> "main = defaultMainWithHooks defaultUserHooks" should have been "main = defaultMainWithHooks simpleUserHooks" in Setup.hs
20:38:45 <tswett> Suppose it takes every set to a subset.  Then if it didn't have a fixed point, you'd have an infinite chain of subsets, which I think can't happen.
20:38:52 <tswett> No, of course it can happen.
20:39:10 <ddarius> @google "Axiom of Foundation"
20:39:11 <lambdabot> http://mathworld.wolfram.com/AxiomofFoundation.html
20:39:12 <lambdabot> Title: Axiom of Foundation -- from Wolfram MathWorld
20:39:31 <tswett> It could map (-inf, 0] onto (-inf, -1], that onto (-inf, -2], and so on.  It's an infinite chain of elementhood that can't happen.
20:40:16 <tswett> dolio: yes, strictly-positive will perhaps do the trick, but can you write that criterion into a fixed-point combinator for the types?
20:40:39 <dolio> What?
20:40:53 <tswett> Given a type a, can you express "a is strictly positive" as a type parameterized by a?
20:41:52 <maestromac> can someone here help with my assignment?
20:41:55 <dolio> Yes. It's Const True in a language that only allows types that are strictly positive.
20:42:22 <tswett> Sure.  :P
20:42:44 <maestromac> <tswett> can you help?
20:42:57 <tswett> I'm looking for something like y :: (a : *) -> (a -> a) -> (a is strictly positive) -> a.
20:43:09 <tswett> maestromac: I may be able to, yes.  What's your assignment and what difficulty are you having?
20:43:32 <dolio> You get strictly positive types by taking fixed points of strictly positive functors.
20:43:39 <maestromac> can't seem to figure out how to get a function working.
20:43:47 <tswett> Er, rather, something like y :: (f : * -> *) -> (f is strictly positive) -> *.
20:44:12 <dolio> You can have a built-in type of strictly positive functors.
20:45:07 * tswett nods.
20:48:29 <dolio> In theory, you could maybe loosen yourself to merely positive types without introducing logical inconsistency.
20:48:40 <dolio> But that would be rather anti-set-theoretic.
20:50:07 <dolio> Since functors like FX = (X -> T) -> T tend not to have set theoretic fixed points.
20:50:15 <dolio> Er, classical set theoretic....
21:05:18 <freedrull> has quickcheck been tested with quickcheck
21:32:05 * hackagebot libxml-sax 0.7 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7 (JohnMillikin)
21:39:09 <Bfig_> what would be the easiest way to represent polynomials,  Mon scale exponent | Mon Plus Poly | Mon Minus Poly, sth like that?
21:40:11 <Bfig_> i am thinking how it would make it easy to simplify and operate over them
21:41:20 <dmwit> Why have separate Plus and Minus constructors?
21:41:26 <copumpkin> [Natural]
21:41:33 <copumpkin> wait
21:41:35 <copumpkin> [Double]
21:42:20 <Bfig_> i dunno, how do i detect which operation is the one that strings them together?
21:42:34 <dmwit> Plus is always the operation that strings them together.
21:42:37 <Berengal> Is there a "c2hs for dummies" anywhere?
21:42:44 <ddarius> @google power series, power serious
21:42:46 <lambdabot> http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
21:42:47 <dmwit> It's just that there's some that have negative "scale"s.
21:43:13 <dmwit> Berengal: I found the c2hs tutorial pretty readable.
21:43:13 <dark> http://paste.pocoo.org/show/365729/ while compiling the first example of http://haskell.org/haskellwiki/WxHaskell/Quickstart - what could this mean?
21:43:17 <dmwit> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/
21:43:18 <Bfig_> yes, i thought about that but i have a problem, i need to parse them eventually, and i have to parse this for example
21:43:33 <Bfig_> 3x * (4x3 - -8.6) / (x3 + -2x -8x5
21:43:36 <Bfig_> )
21:43:37 <Berengal> dmwit: That's not a tutorial, that's a reference guide
21:43:38 <dmwit> Berengal: UTF-8, in case your browser doesn't auto-detect it correctly (as mine doesn't).
21:43:59 <dark> I think I have wx installed. maybe some upgrade somehow break the ABI?
21:43:59 <dmwit> Berengal: It's not very long...
21:44:01 <Bfig_> that's not a polynomial, but i'll start with that. the program will eventually have to cope with polynomial expressions of that type
21:44:14 <dmwit> Bfig_: Parsing should be a different problem than representation.
21:44:28 <copumpkin> Bfig_: oh, you just want to represent expressions
21:44:42 <Berengal> dmwit: True, but after reading it I can't even get a simple function such as "Foo *create(void)" to work
21:44:43 <Bfig_> dmwit, what if i want to be able to hold that same presentation of data in my representation?
21:45:06 <dmwit> Berengal: Oh, bummer! Show us what you've got. I can probably help.
21:45:24 <dmwit> Bfig_: Then your original question was flawed. =)
21:45:49 <Bfig_> copumpkin, i need to perform some basic functions over polynomials (simplify and polynomial division in particular)
21:46:12 <copumpkin> Bfig_: in that case I'd suggest what I was suggesting before
21:46:21 <copumpkin> Bfig_: and what ddarius linked to
21:46:43 <Berengal> dmwit: http://hpaste.org/45307/c2hs
21:46:56 <Berengal> (.h first, then .chs)
21:47:18 <Bfig_> and i need to work with a representation that lets me perform those easily. also i am still not sure if i'm supposed to be able to hold to the data representation people give me or if it is ok to simplify all polynomials i find
21:47:41 <Bfig_> but the most sensible answer is that i should be able to hold onto the expressions, don't you think?
21:48:11 <Bfig_> ie, if i give you 2x^3 + -25 (and i am supposed to be able to parse that), i don't want to see 2x^3 -25
21:48:26 <Bfig_> gonna have to ask because it complicates things unnecesarily
21:49:46 <copumpkin> ick
21:49:51 <copumpkin> you want to preserve input?
21:49:56 <copumpkin> that makes things fugly, usually
21:52:01 <dmwit> Berengal: What does CSFML_API do?
21:52:06 <Kaidelong> Bfig_: Design an AST I guess?
21:52:20 <Kaidelong> the nice elegant linked list representation will not work for you
21:52:40 <copumpkin> unless you always want to output negatives as + -
21:52:47 <Berengal> dmwit: It's just a complicated way of writing extern
21:52:47 <Bfig_> what's an ast?
21:52:58 <Berengal> (ifdef CPP to extern "C")
21:53:12 <Bfig_> i am seriously considering just storing a string with the polynomials :p
21:53:25 <copumpkin> Bfig_: good luck doing arithmetic on strings
21:53:36 <dmwit> fine
21:53:43 <Bfig_> no no, a reasonable representation and a string together
21:54:04 <dark> Bfig_, is there a way for a - b and a + -b to mean different things? anyway I suppose that once you do some kind of operation on this, you should normalize it
21:55:17 <dark> like, (a - b)(a + -b) and (a + -b)(a - b) should return the same thing
21:55:48 <Bfig_> i think i'll just go ahead and think of this as the very reasonable list of pairs (scale, exponent)
21:56:17 <Bfig_> and go on from there... i still need to solve so much other stuff :|. not gonna kill myself over this.
21:56:22 <dmwit> Berengal: Hm. What error are you getting? And what happens if you replace the ^'s with explicit names?
21:56:31 <Bfig_> thanks for all the good advice
21:56:47 <dmwit> Berengal: (For the latter, I'm wondering whether c2hs is doing de-capitalization correctly.)
21:56:51 <Berengal> dmwit: The .hs code is all wrong. Let me paste that too...
21:57:28 <ddarius> "The Sensual (Quadratic) Form" - Conway
21:57:29 <Berengal> dmwit: http://hpaste.org/45308/c2hs_hs
21:57:40 <copumpkin> Bfig_: if you don't represent the exponent explicitly, you don't have to deal with duplicates and can assume it's sorted
21:58:11 <Berengal> dmwit: The foreign imports should return pointers, at the very least
21:58:21 <Bfig_> but i could have potentially huge lists to represent a tiny polynomial like x^1241251
21:58:27 <Bfig_> 'tiny'
21:58:32 <copumpkin> sure
21:58:52 <copumpkin> how about a Map :)
21:58:57 <copumpkin> no duplicates, ordered
21:59:06 <copumpkin> yet supports holes
21:59:07 <copumpkin> IntMap
21:59:12 <dmwit> Berengal: The foreign imports look okay to me.
21:59:21 <copumpkin> you don't need infinite power series anyway
21:59:26 <dmwit> Berengal: Remember that Clock *is* a pointer.
21:59:55 <Bfig_> mmm guess it's not such a bad idea
22:00:04 <Berengal> dmwit: Yes, but ghc doesn't know that. It's a newtyped pointer
22:00:22 <dmwit> Berengal: GHC absolutely knows that.
22:00:34 <Berengal> Not the typechecker
22:00:38 <dmwit> Berengal: Look at the declaration: newtype Clock = Clock (Ptr {- emphasis here -} Clock)
22:00:40 <Bfig_> also makes evaluation of exponents easy,  a + x ( b + x ( c + x...
22:01:04 <dmwit> Berengal: That declaration says that Clock is a Ptr!
22:01:07 <Berengal> Look at the wrapper functions; they try to treat the foreign imports as if they take, and return Ptr Clocks, when they're declared to use Clock
22:01:15 <Bfig_> i guess if it is absolutely important i could keep a string appended to that simple representation
22:01:20 <copumpkin> Berengal: the FFI allow sthat
22:01:46 <Berengal> SFML/System/Internal.chs:17:21:
22:01:46 <Berengal>     Couldn't match expected type `Ptr Clock' with actual type `Clock'
22:01:46 <Berengal>     In the first argument of `Clock', namely `res'
22:01:46 <Berengal>     In the expression: Clock res
22:01:46 <Berengal>     In an equation for `res'': res' = Clock res
22:01:49 <dark> copumpkin, but how to deal with many variables?
22:02:02 <dmwit> Berengal: Ah, you're right. I misunderstood your complaint. Let's see...
22:02:34 <copumpkin> dark: many maps :)
22:02:38 <Bfig_> copumpkin, how would i go about parsing in this case?
22:02:41 <dmwit> Berengal: I think you're misusing the in- and out-marshallers.
22:02:53 <copumpkin> Bfig_: completely different issue, but I'd look into parsec if I were you
22:02:53 <Berengal> dmwit: Very likely
22:02:54 <Bfig_> well, nevermind, i'll have to think about that later. this is still pretty fine.
22:03:02 <Bfig_> what's parsec?
22:03:02 <dmwit> Berengal: This is always the place I've been least in control of my understanding, so it might take me a minute to work out the right thing to do here.
22:03:02 <copumpkin> you can probably throw together a parser in 20 minutes after reading some examples
22:03:13 <copumpkin> Bfig_: lets you write very easy parsers in pure haskell
22:03:18 <copumpkin> one of many parser combinators out there
22:03:26 <Bfig_> i bet you could finish what i have to do in 1 hour tops
22:03:36 <Bfig_> :p
22:03:50 <dark> Bfig_, I wrote something nearly identical in ocaml. I wanted to add other things like division, but I quickly moved to other things. (To be totally honest, I got lost in the normalization algorithm, and then someone at #ocaml helped me a lot)
22:03:53 <dmwit> Berengal: Yes, I think the in-marshallers for Clock_GetTime and Clock_Destroy should be stripping off the Clock constructor, not adding it.
22:03:54 <copumpkin> stuff gets easier when you stick with it for a while :) with any luck you'll stay around long enough to find out
22:03:54 <Bfig_> haskell's got too much to learn :)
22:04:24 <dark> I think that what moved me away from that was that I had a hard time writing the parser
22:04:49 <copumpkin> writing parsers by hand is no fun, unless you're doing unusual (small, non-tedious) things
22:04:50 <dmwit> Berengal: ...and I think you need an in-marshaller for Clock_Create, but not an out-marshaller.
22:04:54 <Berengal> dmwit: The in-marshallers are stripping it, but the foreign import is declared as taking a wrapped type
22:04:59 <Bfig_> guess i'll have to check that out. but first i will write the logic behind the thing
22:05:06 <copumpkin> :)
22:05:08 * copumpkin goes to sleep
22:05:13 <Bfig_> thanks for the help!
22:05:17 <Bfig_> gnight
22:05:18 <copumpkin> np, good luck
22:05:20 <Berengal> dmwit: And Clock_Create doesn't take any in-parameters at all...
22:05:34 <dark> anyway the ast is at http://paste.pocoo.org/show/365731/
22:05:39 <dark> bye copumpkin
22:05:39 <dmwit> Berengal: The return type has an out-marshaller. I think it should be an in-marshaller.
22:05:47 <copumpkin> bye
22:06:00 <Berengal> dmwit: in-marshallers marshal from Haskell to C, right?
22:06:12 <dmwit> Berengal: The documentation is frustratingly silent on what the in- and out-marshallers mean.
22:06:16 <Berengal> But Create returns a C-pointer. It doesn't even take any input at all
22:06:24 <Berengal> Yes. Yes they are.
22:06:32 <dmwit> Berengal: So I'm cribbing from Cairo.chs.
22:07:53 <Berengal> dmwit: It didn't want an in-marshaller on Create at all
22:08:23 <dmwit> argh
22:08:50 <Berengal> dmwit: I used id as a marshaller...
22:08:56 <Berengal> It worked, maybe
22:09:12 <dmwit> That can't be right.
22:09:14 <Berengal> Just need to figure out how to load this up in ghci
22:09:50 <Berengal> Maybe I should've used a simple call hook instead?
22:10:03 <Berengal> (I don't know the difference between call and fun hooks yet)
22:10:13 <dmwit> No.
22:10:41 <dmwit> No, I think your Clock out-marshaller was right, but I do think that the Clock in-marshallers on Clock_GetTime and Clock_Destroy are backwards.
22:10:44 <dmwit> They should be unClock.
22:11:04 <Berengal> They are unclocking
22:11:25 <Berengal> But the foreign import has type Clock -> IO Foo, not Ptr Clock -> IO Foo
22:11:35 <dmwit> Yes, but I don't understand why they are unclocking. =P
22:11:45 <dmwit> They shouldn't be, according to my understanding of c2hs. =P
22:12:34 <Berengal> My very naive understanding rationalizes it thusly: Clock :: Haskell-land, Ptr Clock :: C-land, Clock in-marshaller is therefore Clock -> Ptr Clock
22:12:55 <Berengal> And vice-versa on out-marshallers
22:13:07 <dmwit> But Clock :: Ptr Clock -> Clock, not the type you said.
22:13:09 <dark> isn't there a cabal uninstall command?
22:13:12 <dmwit> *unClock* has the type you said.
22:13:38 <dmwit> agreed?
22:13:49 <Berengal> Clock the constructor, yes, but c2hs knows more about Clock than just the fact that it's a constructor and a type
22:13:52 <dark> (is there a more appropriate place to seek help with things like http://paste.pocoo.org/show/365729/ ?)
22:14:05 <Berengal> It has created magic marshallers. At least that's how I interpreted the documentation
22:14:07 <dmwit> Berengal: Just try it. Please. For my sanity. =P
22:14:43 <Berengal> Using unClock (Clock c) = c?
22:14:52 <dmwit> yeah
22:15:11 <dmwit> (...and a Clock out-marshaller in the return type of Clock_Create)
22:17:35 <Berengal> dmwit: Doesn't work
22:17:48 <dmwit> =(
22:17:50 <Berengal> Because the foreign imports already deal with wrapped Clocks
22:18:00 <dmwit> That's so weird.
22:18:27 <Berengal> Yes. As it is now, there's no need for wrappers at all
22:18:36 <Berengal> Anyway, how do I best test these?
22:19:44 <Berengal> If I understand correctly, the context hook with the library spec means it should load the library dynamically, yes?
22:21:52 <dmwit> erm
22:24:13 * hackagebot gloss 1.3.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.3.0.1 (BenLippmeier)
22:24:28 <dmwit> Huh, I don't know how to do the linking part.
22:24:38 <dmwit> ...and the wife is calling.
22:24:42 <dmwit> Sorry.
22:25:13 * hackagebot gloss-examples 1.3.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.3.0.1 (BenLippmeier)
22:25:16 <Berengal> dmwit: I'll figure it out. Thanks for the help so far anyway
22:25:57 <Axman6> dcoutts: are you about?
22:35:25 <Berengal> dmwit: I got it working, somehow :) Had to explicitly give ghci the dynamic lib on the command line however
22:39:42 <Bfig_> what's the wrong thing with this? > 
22:39:42 <Bfig_>  pmult polA polB@x:xs = zipWith (+) (map (*x) polA) (pmult (0:polA) xs)
22:39:57 <Bfig_> i get error at @x:xs
22:43:02 <lispy> :t (.&.)
22:43:02 <lambdabot>     Ambiguous occurrence `.&.'
22:43:02 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
22:43:02 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
22:43:13 <lispy> :t Data.Bits.(.&.)
22:43:14 <lambdabot> Couldn't find qualified module.
22:43:19 <lispy> :t Data.Bits..&.
22:43:19 <lambdabot> parse error on input `Data.Bits..&.'
22:43:34 <lispy> hrm.
22:44:02 <dmwit> Berengal: Back.
22:44:05 <dmwit> Berengal: Oh, great!
22:44:25 <dmwit> Bfig_: more parens around (x:xs)
22:44:29 <lispy> Sometimes in C you'll see foo & bar, and the result is meant to be a bool
22:44:33 <lispy> How do I mimic that in Haskell?
22:44:35 <dmwit> :t (Data.Bits..&.) -- lispy?
22:44:36 <lambdabot> forall a. (Bits a) => a -> a -> a
22:44:37 <lispy> I use .&.
22:44:49 <lispy> But, how do I convert to bool?
22:44:52 <dmwit> :t (&&)
22:44:52 <lambdabot> Bool -> Bool -> Bool
22:44:58 <dmwit> :t toEnum
22:44:58 <lambdabot> forall a. (Enum a) => Int -> a
22:45:06 <lispy> ?hoogle Int -> Bool
22:45:06 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
22:45:07 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
22:45:07 <lambdabot> Data.IntSet notMember :: Int -> IntSet -> Bool
22:45:23 <lispy> hmm...testBits
22:45:23 <dmwit> :t (/=0)
22:45:23 <lambdabot> forall a. (Num a) => a -> Bool
22:45:49 <lispy> :t toEnum (1 :: Int) :: Bool
22:45:50 <lambdabot> Bool
22:46:03 <dmwit> > (toEnum 1, toEnum 2 {- whoops -})
22:46:04 <lambdabot>   (*Exception: Prelude.Enum.().toEnum: bad argument
22:46:09 <lispy> > toEnum (1::Int) :: Bool
22:46:09 <dmwit> > (toEnum 1, toEnum 2 {- whoops -}) :: (Bool, Bool)
22:46:10 <lambdabot>   True
22:46:10 <lambdabot>   (True,*Exception: Prelude.Enum.Bool.toEnum: bad argument
22:46:25 <dmwit> > ((/=0) 1, (/=0) 2 {- this is okay though -})
22:46:25 <lambdabot>   (True,True)
22:46:49 <lispy> Hmm...that's kind of like when you see !!(foo & bar)
22:47:14 <lispy> > testBits True 23
22:47:15 <lambdabot>   Not in scope: `testBits'
22:47:22 <lispy> > Data.Bits.testBits True 23
22:47:23 <lambdabot>   Not in scope: `Data.Bits.testBits'
22:47:27 <dmwit> very like
22:47:31 <lispy> > Data.Bits.testBit True 23
22:47:32 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
22:47:32 <lambdabot>    arising from a use of `Da...
22:47:39 <lispy> Oh, testBit checks a specific bit.  Duh.
22:47:42 <dmwit> > testBit 1000 23
22:47:43 <lambdabot>   Ambiguous type variable `t' in the constraint:
22:47:43 <lambdabot>    `Data.Bits.Bits t'
22:47:43 <lambdabot>      a...
22:48:00 <Tinfoil> Hello
22:48:44 <dmwit> hi
22:48:57 <Tinfoil> what is haskell? Another programming language?
22:49:07 <dmwit> Yes.
22:49:17 <Tinfoil> cool beans
22:49:29 <dmwit> Would you like some links to tutorials?
22:49:43 <Tinfoil> When I start seeing it in use ill look it up
22:49:55 <enthymeme> Who was that masked man?
22:50:01 <ddarius> @tell ezyang You'll want to look at abstract interpretation.
22:50:01 <lambdabot> Consider it noted.
22:50:04 <lispy> dmwit: looks like (/= 0) is the best way to do this
22:50:57 <dmwit> lispy: The *best* way to do this is not to use numbers as bitfields.
22:51:04 <lispy> dmwit: but!
22:51:07 <lispy> but...
22:51:12 <lispy> I'm doing an FFI thing
22:51:16 <dmwit> data BunchOfFields = BunchOfFields { foo :: Bool, bar :: Bool }
22:51:18 <ddarius> Integers make excellent sets.
22:51:41 <dmwit> Integers make excellent prematurely optimized sets.
22:51:59 <lispy> dmwit: I'm trying to implement this: http://freetype.sourceforge.net/freetype2/docs/reference/ft2-base_interface.html#FT_HAS_VERTICAL
22:52:24 <lispy> and give it type FT_Face -> IO Bool (I have to use IO because I have a peek in there)
22:52:59 <dmwit> Anyway, I won't give you too hard of a time. My comment was very tongue-in-cheek -- I probably wouldn't take my own advice if I were doing it.
22:53:18 <lawfulfalafel> I am trying to teach myself haskell by going through the euler problems and just got really stuck
22:53:59 <Bfig_> mmm the polynomial division is nasty...
22:54:05 <lawfulfalafel> I got this far: let checkString a b = show (a * b) == reverse (show (a * b))
22:54:10 <lispy> I think it's weird when someone comes into the most populated programming channel on freenode and says, "When I see it in use...".  Weird in the "open your eyes" sense.
22:54:25 <lawfulfalafel> but I can't really figure out how to make a for loop to iterate through decrements of a and b
22:55:00 <unfo-> lawfulfalafel, which problem you workin' on?
22:55:10 <lawfulfalafel> number 4
22:55:13 <lawfulfalafel> sort of just started
22:55:17 <unfo-> also for loops are not haskellish.. you want list comprehensions :)
22:55:35 <dmwit> > [(a, b) | a <- [1..10], b <- [1..3]]
22:55:36 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5...
22:56:08 <lawfulfalafel> what's that result called?
22:56:21 <lawfulfalafel> I know python a little bit, that looks like a dictionary filled with tuples
22:56:25 <lawfulfalafel> is that accurate?
22:56:30 <Veinor> it's a list of tuples
22:56:39 <lawfulfalafel> right, my b
22:56:40 <unfo-> lawfulfalafel, don't copy paste my code for your own euler 55, but this has something that you might want: https://github.com/codeflows/edmonton-eulers/blob/master/Euler55.hs#L20-30
22:56:52 <Kaidelong> there is no general way to hash something in haskell so I'm not sure you can even have a dictionary
22:57:01 <ski> > [100 * a + b | a <- [1..10], b <- [1..3]]
22:57:02 <lambdabot>   [101,102,103,201,202,203,301,302,303,401,402,403,501,502,503,601,602,603,70...
22:57:05 <Kaidelong> that works on anything, anyway
22:57:20 <Kaidelong> that is a bit of a shame actually
22:57:27 <lpsmith> Not really
22:57:40 <lawfulfalafel> also, what's up with ghci?
22:57:44 <lpsmith> By parametericity,  you can't build a dictionary that works on *everything*
22:57:53 <lawfulfalafel> I have to preface my declarations with let
22:58:01 <lpsmith> but you can't really do that in python either,  with e.g. higher order functions
22:58:09 <lpsmith> And parametericity is pretty nice
22:58:39 * Kaidelong is pretty sure you can put values of type Func<T,Func<...>> in a .NET dictionary
22:58:43 <Kaidelong> err
22:58:51 <Kaidelong> other way around with the type arguments
22:58:51 <lpsmith> right,  you can do that too, as the values
22:58:55 <lpsmith> not as the keys
22:59:16 <lpsmith> I mean,  haskell dictionarys already let you put anything in as a value
22:59:29 <lpsmith> Keys have to be Ord or Hashable or whatever
22:59:37 <Kaidelong> well like any object it'd have GetHashCode()
22:59:40 <Kaidelong> there is no special restriction on keys in .NET I don't think
23:00:02 <Kaidelong> also I think the deep contract serializer can serialize even things that aren't supposed to be serializable
23:00:29 <dmwit> Well, Haskell has unsafe pointer equality, as well. But it's not really what you want, is it?
23:00:34 <lpsmith> @where parametericity
23:00:34 <lambdabot> I know nothing about parametericity.
23:00:41 <lpsmith> @where theorems for free
23:00:42 <lambdabot> I know nothing about theorems.
23:00:43 <dmwit> s/Haskell/GHC/
23:00:47 <Kaidelong> dmwit: You can do better
23:01:11 <Kaidelong> although it'd run afoul of not allowing runtime typing and casting perhaps
23:01:18 <ski> @free filter
23:01:19 <lambdabot> $map f . filter (g . f) = filter g . $map f
23:01:35 <Kaidelong> but having platform independent representations of things is nice for more than just hash codes, RPC becomes easier too
23:01:46 <lpsmith> @free mapCont
23:01:47 <lambdabot> Plugin `free' failed with: Plugin/Free/FreeTheorem.hs:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
23:01:52 <lpsmith> hahaha
23:02:17 <ski> @type mapCont
23:02:17 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
23:02:32 <Kaidelong> actually if any argument can be made for dynamic languages and JIT compilers, perhaps that is is
23:02:34 <Kaidelong> it*
23:02:35 <ski> @free (r -> r) -> ((a -> r) -> r) -> ((a -> r) -> r)
23:02:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
23:02:41 <ski> bah
23:02:58 <dmwit> Berengal: Well, I'm thoroughly baffled.
23:03:33 * Berengal hasn't been paying attention the last 15 minutes
23:03:40 <ski> Kaidelong : "RPC" ?
23:03:46 <Kaidelong> remote procedure call
23:03:58 <ski> ah, right
23:04:01 <Kaidelong> I do not mean any particular standard there
23:04:05 <Kaidelong> just the concept in general
23:04:27 <Berengal> dmwit: Baffled by what?
23:04:31 * ski was thinking of RTCG (Run-Time Code Generation), but that didn't fit ..
23:04:32 <dmwit> Berengal: c2hs
23:05:14 <Kaidelong> anyway I think if I ever get into making another language for no apparent reason I'd have it be runtime typed and interpreted
23:05:40 <Kaidelong> if only to ensure that all values can be represented
23:06:41 <Kaidelong> (without needing pointer equality or any knowledge of the platform)
23:06:48 <Berengal> dmwit: I'm thinking I should probably sleep and then go read the documentation more thoroughly
23:07:11 <Berengal> And then figure out how to handle dynamic libs
23:07:18 * hackagebot gloss-examples 1.3.1.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.3.1.1 (BenLippmeier)
23:11:00 <lawfulfalafel> why does [(a,b) | a <-[3..1], b <- [3..1]] no work but [(a,b) | a <- [1..3], b <- [1..3]] work?
23:11:07 <lawfulfalafel> not*
23:11:23 <ddarius> Kaidelong: Neither of those things are necessary or sufficient to "ensure that all values can be represented."
23:11:24 <Veinor> > [3..1]
23:11:24 <lambdabot>   []
23:11:29 <Veinor> you can't count down like that is why
23:11:35 <lawfulfalafel> why not?
23:11:56 <dmwit> Berengal: In Cairo.chs, everything looks identical, but the imported function calls have types like IO (Ptr Cairo). I can't see what made c2hs decide to do that.
23:11:59 <Veinor> language spec doesn't allow it ;)
23:12:19 <lawfulfalafel> but isn't that a reasonable assumption to make?
23:12:31 <Berengal> dmwit: Possibly different versions
23:13:10 <dmwit> Yeah. If so, that would explain a lot of my confusion when trying to match up all three of the docs, gtk2hs, and your code. =P
23:13:24 <Berengal> dmwit: I must say I like my results better, although having to specify an id marshaller now and then is a bit weird
23:13:25 <lawfulfalafel> It's just that I'm kind of worried about how many other idiosyncrasies I'm going to learn...
23:13:43 <dmwit> lawfulfalafel: There is a variant for counting by any increment:
23:13:47 <Kaidelong> ddarius: in a platform independent way? I suppose strictly speaking, no, but if you get a message containing a function, for example, you'd have to compile it at runtime
23:13:52 <dmwit> > [1, 3 .. 11]
23:13:52 <lambdabot>   [1,3,5,7,9,11]
23:13:59 <dmwit> > [9, 8 .. 1]
23:13:59 <lambdabot>   [9,8,7,6,5,4,3,2,1]
23:14:12 <lawfulfalafel> [10..1]
23:14:18 <lawfulfalafel> > [10..1]
23:14:19 <lambdabot>   []
23:14:35 <dmwit> lawfulfalafel: When you omit the second argument, it is assumed to be one greater than the previous (for most built-in types).
23:14:42 <dmwit> > [10,11 .. 1]
23:14:43 <lambdabot>   []
23:14:44 <Berengal> dmwit: gtk2hs have their own gtk2hs-buildtools including a version of c2hs. It's probably there for a reason
23:15:30 <dmwit> lawfulfalafel: Note that this means .. notation does the right thing if you are listing indices:
23:15:54 <dmwit> > ([1..3], [1..2], [1..1], [1..0])
23:15:55 <lambdabot>   ([1,2,3],[1,2],[1],[])
23:16:29 <aleator> Anyone have a clue why Numeric.AD.Mode.Reverse gives me NaN for grad (\[a] -> a**2) [0] and 0 for grad (\[a] -> a*a) [0] ?
23:16:33 <ddarius> Kaidelong: Not necessarily, but even if so, that doesn't make the language not compiled nor does a language being interpreted immediately imply that you'll be able to do that.
23:16:36 <lawfulfalafel> okay
23:16:44 <lawfulfalafel> thank you
23:17:20 <ddarius> > 0**2
23:17:21 <lambdabot>   0.0
23:17:57 <dmwit> lawfulfalafel: As for idiosyncracies, well... every language has a few. =)
23:18:45 <dmwit> > [1.5 .. 3] -- a particularly horrible one
23:18:46 <lambdabot>   [1.5,2.5,3.5]
23:20:34 <dmwit> :t (^^)
23:20:35 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
23:20:43 <dmwit> aleator: Try (^^) instead?
23:20:48 <dmwit> :t (**)
23:20:48 <lambdabot> forall a. (Floating a) => a -> a -> a
23:22:34 <dmwit> (No clue about why, though, just trying to suggest something that will work and looks like your original.)
23:23:00 <ski> > [[1 .. i] | i <- [3,2 .. 0]]
23:23:01 <lambdabot>   [[1,2,3],[1,2],[1],[]]
23:24:03 <ski> dmwit : why not `(^)' instead ?
23:24:09 <dmwit> :t (^)
23:24:10 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:24:11 <ski> @type (^)
23:24:12 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:24:17 <dmwit> Could do.
23:24:30 <ski> > 5 ^ 2
23:24:30 <lambdabot>   25
23:24:32 <dmwit> ?src (^^)
23:24:32 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
23:24:33 <ski> > 5 ^ (-2)
23:24:34 <lambdabot>   *Exception: Negative exponent
23:24:38 <ski> > 5 ^^ (-2)
23:24:39 <lambdabot>   4.0e-2
23:25:24 <Kaidelong> :t flip map (tails [1..]) . flip take
23:25:25 <lambdabot>     Couldn't match expected type `[t]' against inferred type `Int'
23:25:25 <lambdabot>     In the first argument of `flip', namely `take'
23:25:25 <lambdabot>     In the second argument of `(.)', namely `flip take'
23:25:27 <dark> ?src (^)
23:25:27 <lambdabot> x ^ 0            =  1
23:25:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:25:27 <lambdabot>   where f _ 0 y = y
23:25:29 <lambdabot>         f x n y = g x n
23:25:31 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:25:33 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:25:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:25:40 <Kaidelong> :t flip map (tails [1..]) . take
23:25:40 <lambdabot> forall t. (Num t, Enum t) => Int -> [[t]]
23:28:01 <dmwit> :t flip take ([0..] >>= enumFromTo 1)
23:28:01 <lambdabot> forall a. (Num a, Enum a) => Int -> [a]
23:28:43 <dmwit> :t flip take (map (enumFromTo 1) [0..])
23:28:44 <lambdabot> forall t. (Num t, Enum t) => Int -> [[t]]
23:30:46 <lawfulfalafel> so I've got this: let anacheck(a,b) = show (a*b) == reverse(show (a*b))
23:31:16 <lawfulfalafel> how I do I make it iterate through the tuples, and stopping execution when that statement is satisified?
23:31:31 <lawfulfalafel> I guess I don't really get how to use conditionals
23:31:31 <Kaidelong> :t or
23:31:32 <lambdabot> [Bool] -> Bool
23:31:38 <Kaidelong> :t or . map
23:31:39 <lambdabot>     Couldn't match expected type `[Bool]'
23:31:39 <lambdabot>            against inferred type `[a] -> [b]'
23:31:39 <lambdabot>     Probable cause: `map' is applied to too few arguments
23:31:50 <Kaidelong> :t or . flip map
23:31:51 <lawfulfalafel> huh?
23:31:51 <lambdabot>     Couldn't match expected type `[a -> Bool]'
23:31:51 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
23:31:51 <lambdabot>     In the first argument of `flip', namely `map'
23:31:57 <Kaidelong> err right
23:32:04 <Kaidelong> have to account for the currying
23:32:19 <Kaidelong> lawfulfalafel: or will keep going until the condition is satisfied
23:32:58 <Kaidelong> :t (or .) . map
23:32:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:33:08 <Kaidelong> there we go
23:34:22 <Kaidelong> > ((or .) . map) (\(a,b) = show(a*b) == reverse(show(a*b))) [(1,1),(2,2),(3,3),(4,4)]
23:34:23 <lambdabot>   <no location info>: parse error on input `='
23:34:30 <Kaidelong> > ((or .) . map) (\(a,b) -> show(a*b) == reverse(show(a*b))) [(1,1),(2,2),(3,3),(4,4)]
23:34:31 <lambdabot>   True
23:34:40 <Kaidelong> > ((or .) . map) (\(a,b) -> show(a*b) == reverse(show(a*b))) [(5,5),(4,4)]
23:34:42 <lambdabot>   False
23:34:59 <Kaidelong> > ((or .) . map) (\(a,b) -> show(a*b) == reverse(show(a*b))) [(1,1),undefined,(2,2),(3,3),(4,4)]
23:35:00 <lambdabot>   True
23:35:10 <Kaidelong> > ((or .) . map) (\(a,b) -> show(a*b) == reverse(show(a*b))) [(1,10),undefined,(2,2),(3,3),(4,4)]
23:35:11 <thoughtpolice> \o/
23:35:12 <lambdabot>   *Exception: Prelude.undefined
23:35:30 <Kaidelong> is that what you want lawfulfalafel?
23:35:48 <thoughtpolice> i got a 'Q.E.D.' - i think I proved my RC4 implementation correct
23:36:02 <Kaidelong> Coq?
23:36:04 <thoughtpolice> or, i merely proved something very very similar
23:36:08 <thoughtpolice> no, a model checker
23:36:10 <lawfulfalafel> I think so, but it seems like a bunch of black magic to me
23:36:13 <thoughtpolice> @hackage @sbv
23:36:13 <lambdabot> http://hackage.haskell.org/package/@sbv
23:36:18 <thoughtpolice> @hackage sbv
23:36:18 <lambdabot> http://hackage.haskell.org/package/sbv
23:37:01 <thoughtpolice> of course, never trust something you've proven without testing it
23:37:05 <thoughtpolice> and sure enough one of the tests fails
23:37:13 <Kaidelong> lawfulfalafel: Execution terminates when the first satisfying value is reached due to lazy evaluation
23:37:15 <thoughtpolice> that's why i don't totally trust it yet :<
23:37:16 <Kaidelong> @src or
23:37:16 <lambdabot> or    =  foldr (||) False
23:39:08 <Kaidelong> > foldr (||) False [x,y,z]
23:39:09 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:39:09 <lambdabot>         against inferred type ...
23:39:14 <Kaidelong> > foldr (||) False [x,y]
23:39:15 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:39:15 <lambdabot>         against inferred type ...
23:39:20 <Kaidelong> huh
23:39:30 <Kaidelong> I guess Expr does not swing that way
23:39:54 <RayNbow`TU> > foldr (||) False [True]
23:39:55 <lambdabot>   True
23:39:59 <RayNbow`TU> > foldr (||) False [True,undefined]
23:40:00 <lambdabot>   True
23:40:03 <RayNbow`TU> > foldr (||) False [False,undefined]
23:40:04 <lambdabot>   *Exception: Prelude.undefined
23:40:55 <Kaidelong> lawfulfalafel: (or .) . map is just a way of writing \f x -> or (map f x)
23:41:35 <Kaidelong> and or is "foldr (||) False" as shown above
23:41:58 <Kaidelong> @unpl (or .) . map
23:41:58 <lambdabot> (\ d g -> or (map d g))
23:50:37 <hvr_> ...where can I find documentation about what has to be guaranteed when using unsafePerformIO?
23:53:15 <dark> all wxhaskell examples I have seen so far first display an empty window, then populate it. is there a way to 'hide' the window until it is ready?
23:55:23 <ski> @src any
23:55:23 <lambdabot> any p =  or . map p
23:56:00 <Kaidelong> oh right, any and all
23:56:10 <Kaidelong> I knew about those
23:58:37 <ski> > (`any` [3,5 .. 13]) $ \p -> (`any` [2 .. p-1]) $ \d -> p `mod` d == 0
23:58:37 <lambdabot>   True
