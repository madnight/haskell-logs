00:12:27 <hydo_> For anyone who is actually here: http://hpaste.org/45870
00:14:45 <Axman6> hydo: you know the Sale in Line and the Sale type are different things right?
00:15:09 <Axman6> you can on;ly have instances for types, and here, Sale and Item types are just names for Record
00:15:28 <dafis> Axman6: TypeSynonymInstances enabled
00:15:33 <Axman6> i think you need a newtype to do what you're after
00:15:51 <Axman6> hmm, didn't know how that one worked (and missed that, thanks)
00:15:51 <hydo> ah, yes, newtype, that's right.
00:16:03 <hydo> Let's see...
00:16:25 <Saizan> TypeSynonymInstances doesn't change much
00:16:45 <dafis> Saizan: makes the instance heads legal
00:17:12 <Saizan> in fact it was probably less confusing when there wasn't that possibility
00:17:13 <dafis> (dies on duplicate instance of course)
00:20:16 <hydo> What would be the best way to handle this?  Say types a, b, and c have exactly the same structure, but are... different.  I guess I could add a field to the base type and fill in a string value with what subtype it's supposed to be, but that seems more than hackish.
00:20:57 <hydo> Well, they aren'd different, I just parse very different data when I build them, and they have to be treated differently in the program logic.
00:21:04 <hydo> err, aren't
00:22:57 <Saizan> newtype seems quite appropriate
00:22:59 <Cale> hydo: You could create a datatype whose values represented the possibilities
00:23:14 <Cale> Or yeah, newtypes
00:23:52 <dafis> phantom types?
00:24:20 <hydo> Hrm... when I define Record, I get a multiple declarations error.
00:24:33 <hydo> err, with newtypes
00:24:53 <Cale> are you trying to declare the same thing twice?
00:26:07 <hydo> well, maybe I am I I just don't know it.  I have data Record { .. } and then newtype Sale = Record and so on.  The error is on the last newtype declaration.
00:26:12 <nerolynx> Afternoon everyone and sorry hydo :( , may  I ask for some help with a novice problem with renaming a data type? I got a data of Function "F" [ Var "X", Function "G" [Var ["X"],Var "Y"] ie. f(x,g(x),y) and I want to return a renamed Function "F" [Var "A", Function "G" [Var "A"], Var "B"] , ie.f(a,g(a),b)]. What would be a good approach to implement this? 
00:27:18 <Saizan> hydo: newtype needs a constructor
00:30:28 <Saizan> nerolynx: rename :: (String -> String) -> Expr -> Expr, where Expr is your type of expressions
00:31:28 <Saizan> nerolynx: then you implement it by recursing over the Expr argument and applying the function argument to the variable names, while reconstructing the term
00:31:37 <nerolynx> hmm
00:31:53 <nerolynx> how do I keep track of which term has been substituted?
00:32:29 <Saizan> nerolynx: then you can call it like rename (\name -> fromMaybe name (lookup name [("X","A"),("Y","B")]))
00:32:52 <Saizan> you don't have to keep track of anything, since you traverse each node only once
00:34:20 <nerolynx> hmm, thanks Saizan. Since I am quite new to Haskell, I haven't got my head wrap around the topic yet, but I'll see if I can try implement it
00:36:05 <nerolynx> Saizan: I tried look up at fromMaybe, is it in Prelude?
00:36:11 <Saizan> you can come back showing your code if you really get stuck :)
00:36:19 <Saizan> nerolynx: it's in Data.Maybe
00:36:23 <Saizan> ?type fromMaybe
00:36:23 <lambdabot> forall a. a -> Maybe a -> a
00:36:24 <nerolynx> aye :D thanks
00:36:34 <nerolynx> I see
00:36:34 <nerolynx> ta
00:36:41 <nerolynx> didn't show when I tried in ghci :D
00:36:51 <nerolynx> lemme see if I can try make it work
00:37:11 <ivanm> @src fromMaybe
00:37:12 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
00:37:32 <ivanm> hmmm, why is that implemented with a case statement rather than direct pattern matching?
00:37:39 <Saizan> there are hoogle and hayoo to search for such things, butw
00:37:57 <ivanm> (or just using flip maybe id)
00:38:40 <nerolynx> thanks Saizan, Ivanm, I'll leave to mock around with the code now
00:38:41 <nerolynx> :)
00:58:34 <bazmatt> I'm totally new with haskell, and this is probably a FAQ, but why on earth is "\228" here: http://hpaste.org/45873/chars
00:59:35 <int-e> Hmm, is it possible to build .cmm files for a library with Cabal without reimplementing half of Distribution.Simple.GHC in Setup.lhs? Declaring them to be C files only almost works, since Cabal uses the same object file for non-profiled and profiled builds. And I see no way to pass extra files to be linked to (for the various ways) to the linking step of D.S.GHC.buildLib, except for a nasty hack: Provide a dummy module...
00:59:42 <int-e> ...Dummy.hs and compile the cmm file to Dummy_stub.{p_,dyn_,}o ...
01:00:16 <dcoutts_> hmm
01:00:19 <int-e> (the workaround I'm currently using is to disable profiling in a post-conf hook, but that's unsatisfactory)
01:00:29 <ivanm> bazmatt: because that's how ghci does it
01:00:43 <bazmatt> ivanm: how does ghci "it"?
01:00:56 <ivanm> bazmatt: what happens is that Char in Haskell is a Unicode codepoint
01:00:59 <dcoutts_> int-e: any suggestions?
01:01:13 <ivanm> and for non-ascii it doesn't bother encoding it with your locale, so it just prints out the literal code point
01:01:14 <dafis> bazmatt: characters beyond '\127' are escaped in the Show instance.
01:01:23 <dcoutts_> int-e: perhaps best would be a better way to add .o files to the link from within the Setup.hs code
01:01:37 <ivanm> bazmatt: if you use putStrLn (with ghc >= 6.12) it will use your system locale though
01:01:56 <bazmatt> ivanm: ah, i c..
01:02:18 <int-e> dcoutts_: well personally I'm leaning towards compiling C files three times, but I understand that the niche of use cases for that is quite narrow. Adding a way to add per-way extra files to link to is a good compromise, I think.
01:02:48 <dcoutts_> int-e: proper support for ways in the Simple build system would be nice :-)
01:03:13 <bazmatt> ivanm: thanks
01:03:18 <ivanm> int-e: wait, C files need to be compiled _3_ times? isn't once enough?
01:03:22 <ivanm> bazmatt: np
01:03:27 <int-e> (There is a use case for actual C code, too, if you do vacuum like stuff.)
01:03:37 <ivanm> bazmatt: (I actually forgot at first why it does it until I realised mid-way through answering you :p)
01:03:38 <bazmatt> why does [0.5..2.0] turn into [0.5,1.5,2.5] instead of [0.5,1.5]??
01:03:49 <int-e> ivanm: there's a distinction between 'vanilla' and 'dynamic' builds already, the latter needs -fPIC
01:03:51 <ivanm> bazmatt: floating point is tricky
01:03:58 <ivanm> and rounding errors occur
01:04:01 <mauke> no
01:04:06 <ivanm> oh, wait... missed that it ended in 2.5
01:04:11 <ivanm> OK, I have no idea ;)
01:04:13 <mauke> the enum instance is retarded
01:04:20 <ivanm> int-e: *nod*
01:04:21 <ivanm> mauke: yeah
01:04:27 <mauke> broken as designed
01:04:39 <ivanm> bazmatt: think about it; how should it do it?
01:04:49 <ivanm> what it does is keep adding 1 until it is >= the last value
01:05:00 <bazmatt> ivanm: no, it does not
01:05:02 <mauke> ivanm: I don't think so
01:05:19 <jkff> Hi. Is there a standard way to make "Data.ByteString.lines" use the platform line separator rather than \x0A?
01:05:23 <ivanm> mauke: isn't that how the instance is defined?
01:05:26 <int-e> ivanm: and anything that touches actual heap objects will want a different treatment for profiling as well. (Hmm, do we have a profiled, dynamic way?)
01:05:27 <bazmatt> [1,3..6] -> [1,3,5] (not [1,3,5,7])
01:05:29 <mauke> ivanm: I don't think so
01:05:36 <ivanm> huh
01:05:50 <ivanm> bazmatt: well, yeah, but the floating point instances are retarded as mauke said
01:06:12 <int-e> ivanm: But that's primarily CMM code (which is not really C code), and heap inspecting code (as I already mentioned). And by 'heap' I mean the actual Haskell heap, not the C one.
01:06:38 <MasseR> Hmm.. Need to practice a lot more testing in haskell :/. Took me 1Â½ hours to do some quickcheck properties (with properties with no use to check). Need to practice thinking when property checking is enough and when is hunit required.
01:07:15 <ddarius> The escaping of characters is not a matter of "ghci" or even GHC.  It is how the Report defines it.
01:07:45 <bazmatt> hmm.. I want to learn haskell primarily because it seems to be one of the least retarded (semi)popular languages out there, but I find "[0.5..2.0] == [0.5,1.5,2.5]" to be a strong point against that
01:07:47 <ivanm> MasseR: generally, hunit is used for monadic stuff
01:08:47 <int-e> dcoutts_: actually I thought the integer-gmp package would have a solution, but it turns out that this is handled in the ghc build system instead, with a small hack in ghc-cabal that picks up cbits/*.cmm and adds them to a CMM_SOURCES (or similar) makefile variable.
01:08:59 <ivanm> bazmatt: http://haskell.org/onlinereport/basic.html#sect6.3.4
01:09:10 <dcoutts_> int-e: right
01:09:12 <ddarius> bazmatt: I think you should write off the whole language because of a rarely used instance of Enum.
01:09:37 <MasseR> ivanm: A couple of days ago I did as a proof-of-concept, unit testing of database connectivity in php. Or rather I tested the db abstraction layer, and that all the models were saved/retrieved properly. However with haskell (realworldhaskell) it seems to be preferred to make a type class providing a subset of the operations and creating a pure (Writer) instance. ...
01:09:42 <MasseR> ... http://codebetter.com/matthewpodwysocki/2009/01/10/functional-programming-unit-testing-part-6/
01:09:55 <MasseR> This would however not test that models are saved/retrieved properly
01:10:08 <ivanm> bazmatt: when you have "enumFromThenTo a (a+i) b", then the last value is the first value reached >= b+i/2
01:10:44 <ivanm> MasseR: QC is used to test for stated properties of pure functions
01:10:50 <ivanm> it doesn't work for IO, etc.
01:11:40 <MasseR> ivanm: But for example in that link, they create a writer based logger and test for example that commit is called. However I could argue that testing model saving/retrieving tests that property implicitly
01:12:13 <ivanm> MasseR: *shrug* I don't do any DB stuff
01:12:18 <ivanm> so can't help you there
01:12:41 <bazmatt> ddarius: no, of course I won't make up my mind immediately (one way or the other).. but I've executed, like, 4 commands in haskell so far, so if 25% of the commands turn into WTF-moments then...
01:13:12 <ion> Yes, itâs logical to extrapolate from that.
01:13:40 <ion> @faq Will 25Â % of all Haskell commands turn into WTF moments?
01:13:40 <lambdabot> The answer is: Yes! Haskell can do that.
01:15:39 <bazmatt> ivanm: ah, ok, so [0.5,1.5,2.5] actually is kind of correct -- you just have to understand that it does rounding before checking..
01:16:14 <bazmatt> ion: lol
01:17:37 <bazmatt> ivanm: or rather, that it ends as close to the upper bound as possible even if it happens to pass it
01:17:55 <ivanm> right
01:18:19 <ddarius> bazmatt: There's nothing about floating point (if we ignore things like NaN) that makes it impossible for [a..b] to not produce values > b.  The definition in the Report is just silly.  On the other hand, for what the Enum class is supposed to represent, it doesn't much make sense to have Double in it at all.
01:19:48 <ion> Haskell certainly has some smelly parts (the record syntax; Monad not being based on Applicative for instance), but not many languages are more elegant than it in general.
01:20:21 <ddarius> Monad not being based on Applicative is perfectly reasonable.  It not being based on Functor is silly.
01:21:34 <merijn> I think everyone agrees the monad/functor/applicative and the num typeclasses could have been ordered more elegantly in hindsight
01:21:35 <bazmatt> ion: yes, well, most languages are utterly moronic, with stuff like "Ã¤".length() == 2..
01:22:27 <morphles> bazmatt: what language allow such abominations?
01:22:35 <merijn> python2 probably?
01:22:37 <thorkilnaur> bazmatt, ghc/libraries/base/GHC/Real.lhs defines numericEnumFromTo n m = takeWhile (<= m + 1/2) (numericEnumFrom n) (which is [n..m]) and say "These 'numeric' enumerations come straight from the Report" - this code agrees with section 6.3.4 of the Haskell 98 report
01:22:40 <bazmatt> morphles: e.g., ruby
01:22:41 <morphles> ups not that bad i though = :D
01:22:59 <morphles> but still 
01:23:20 <ddarius> merijn: Applicative didn't exist when Haskell 98 was defined, so it's clearly unreasonable to complain about Monad not being a subclass of it.  However, Functor and Monad were introduced in Gofer in the early '90s with Monad a subclass of Functor, so there's no reason that choice couldn't have been made.
01:23:57 <merijn> ddarius: I know, that's why I said they could be better ordered *in hindsight*
01:24:15 <bazmatt> haskell is good in this regard.. (length "iâ¥u") == 3
01:24:16 <morphles> so much stuff could be done better in hindsight :)
01:24:37 <merijn> Of course that implicitly assumes, that the lack of applicative was also an oversight in h98
01:24:40 <dankna> > length "iu"
01:24:41 <lambdabot>   2
01:24:47 <ion> Captain Hindsight to the rescue!
01:25:25 <merijn> bazmatt: Not only is Haskell one of the least insane languages I know (once your brain has melted and been remolded to it, anyway...) people here are usually more helpful then elsewhere :>
01:25:39 <bazmatt> (the previous one was: (length "i\9829u") == 3)
01:25:51 <ddarius> merijn: My point is that's like saying "In hindsight, K&R C could have had better support for the web."
01:26:07 <merijn> ddarius: Hell now, but it should've had namespaces :>
01:26:11 <merijn> s/now/no
01:26:23 <bazmatt> > length "iâ¥u"
01:26:24 <lambdabot>   3
01:26:34 <ddarius> merijn: Yes, that's reasonable as the concept of "namespaces" existed at the time K&R C was defined.
01:26:42 <shachaf> If Monad was a subclass of Functor in the past, why was that taken out in Haskell 98?
01:26:57 <ddarius> Gofer /= Haskell
01:27:03 <bazmatt> merijn: so it seems... especially that lambdabot dude.. :)
01:27:25 <morphles> lambdabot is girl :)
01:27:37 <bazmatt> ooops :D
01:27:39 <merijn> lambdabot is our AI overlord, ruling #haskell with an ironfist and confusing newbies with Caleskell :>
01:27:50 <morphles> lambdabot is awsome :)
01:27:51 <shachaf> Ah, Gofer. Still, if it was already in a Haskell-related language, surely they considered it?
01:28:13 <merijn> morphles: Because she is incomprehensible at times? :>
01:28:28 <morphles> because she does lots of stuff :)
01:28:34 <int-e> shachaf: well they also made Show a superclass of Num ;)
01:28:46 <morphles> you ask where is function that does this and it says well here it is :)
01:32:54 <ddarius> @hoogle makeSandwich
01:32:55 <lambdabot> No results found
01:33:29 <shachaf> @djinn sandwich
01:33:29 <lambdabot> -- f cannot be realized.
01:33:38 <merijn> ddarius: Don't you mean
01:33:46 <merijn> @hooge IO Sandwich
01:33:47 <lambdabot> Did you mean: :: IO Sandwich /count=20
01:33:47 <lambdabot> No results found
01:40:00 <bazmatt> umm.. "Not in scope: `isUpper'"
01:40:09 <ivanm> bazmatt: import Data.Char
01:40:12 <bazmatt> thx
01:40:31 <ion> @hoogle isUpper
01:40:31 <lambdabot> Data.Char isUpper :: Char -> Bool
01:42:42 <RayNbow`TU> @check \x -> isUpper x || isLower x
01:42:43 <lambdabot>   "Falsifiable, after 0 tests:\n'\\296879'\n"
01:45:32 <morphles> what does @check do?
01:45:40 <RayNbow`TU> runs a QuickCheck test
01:45:57 <morphles> and quickcheck test is?
01:46:13 <RayNbow`TU> @check \xs -> reverse (reverse xs) == (xs :: [Int])
01:46:14 <lambdabot>   "OK, passed 500 tests."
01:46:15 <merijn> morphles: QuickCheck is a library for generating random unittets
01:46:21 <merijn> unittests, even
01:46:25 <ion> http://en.wikipedia.org/wiki/QuickCheck
01:46:37 <morphles> thanks, seems interesting
01:47:06 <merijn> morphles: For example, RayNbow`TU's last example generates 500 random test which show that reverse a list twice always returns an identical list
01:47:15 <RayNbow`TU> http://video.google.com/videoplay?docid=-4991530385753299192#  <--  Type-driven testing in Haskell
01:47:51 <morphles> will have to check it out when i have time
01:48:01 <morphles> i hope this happens before video goole gets taken down
01:48:09 <morphles> since that is quite imminent
01:48:49 <ivanm> merijn: of course, if he left off the type annotation then it wouldn't have shown much...
01:48:56 <ivanm> @check \ xs -> reverse xs == xs
01:48:57 <lambdabot>   "OK, passed 500 tests."
01:48:59 <merijn> ivanm: I know :p
01:49:00 <ivanm> :p
01:51:10 <RayNbow`TU> morphles: I have the video of that talk somewhere on a hard disk
01:51:43 <RayNbow`TU> it used to be hosted on foomongers.org.uk, but that site died
01:51:58 * RayNbow`TU mirrored it on Google Video
01:52:23 <RayNbow`TU> (even though I have no idea who owns the copyright to that particular video)
01:52:40 <ion> Type-driven_testing_in_Haskell_-_Simon_Peyton_Jones.flv: 12% (21413.98 / 175650.35 KiB)   
01:52:45 <ion> get_flash_videos â¥
01:53:28 <RayNbow`TU> ion: why are you downloading the flv? :p
01:53:29 <ivan> morphles: python youtube-dl -t "http://video.google.com/videoplay?docid=-4991530385753299192"
01:53:31 <bazmatt> can I define function types in ghci? now it just complains "The type signature for `foo' lacks an accompanying binding" if I try to define the signature first and if I try to define the body first the signature turns out different...
01:53:44 * RayNbow`TU has the mp4
01:53:45 <ion> raynbow: In order to watch the video.
01:53:59 <merijn> bazmatt: You can use let bindings, but in general you can't really define functions inside ghci
01:54:19 <merijn> bazmatt: You can create a haskell file and load/reload it into ghci to play with it or use something like haskellmode for emacs
01:54:24 <bazmatt> "let foo :: int -> int" -> "The type signature for `foo' lacks an accompanying binding"
01:54:42 <merijn> > let foo x = x*x in foo 5
01:54:43 <lambdabot>   25
01:54:54 <bazmatt> > :t foo
01:54:55 <lambdabot>   <no location info>: parse error on input `:'
01:55:24 <merijn> You have to specify the entire function in one go, not specify an explicit signature then multi line implementation
01:55:50 <ion> > let foo :: Int -> Int; foo x = x*x in foo 5
01:55:51 <lambdabot>   25
01:55:52 <merijn> It is often easier to create a tmp.hs file where you write the function then run ":l tmp.hs" in ghci to load the file and ":r" to reload when you change it
01:59:03 <bazmatt> > let foo :: Int -> Int; foo x = x*2 in foo 40000000000
01:59:05 <lambdabot>   80000000000
01:59:17 <bazmatt> > let foo :: Int -> Int; foo x = x*2 in foo 9223372036854775808
01:59:18 <lambdabot>   0
01:59:37 <bazmatt> > let foo :: Int -> Int; foo x = x*2 in foo 9223372036854775800
01:59:39 <lambdabot>   -16
01:59:48 <merijn> Int is machine limited, so that's an overflow
01:59:52 <mm_freak> try Integer
02:00:03 <merijn> > let foo :: Integer -> Integer; foo x = x*2 in foo 9223372036854775800
02:00:04 <lambdabot>   18446744073709551600
02:00:07 <mm_freak> > 2^500000 :: Integer
02:00:08 <lambdabot>   995020413323058325018215319903500049399641236861056829934173556769719977750...
02:00:10 <bazmatt> I noticed.. how do I check the size of my int?
02:00:18 <mm_freak> bazmatt: don't
02:00:28 <bazmatt> mm_freak: but I really want to :)
02:00:33 <mm_freak> if you need size guarantees, either use one of the Data.Int or Data.Word types or use Integer
02:00:34 <merijn> > maxBound :: Int
02:00:35 <lambdabot>   9223372036854775807
02:00:46 <merijn> > minBound :: Int
02:00:47 <lambdabot>   -9223372036854775808
02:01:01 <ion> > logBase 2 $ fromInteger (maxBound :: Int) + 1
02:01:02 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
02:01:02 <lambdabot>         against inf...
02:01:08 <ion> > logBase 2 $ fromIntegral (maxBound :: Int) + 1
02:01:09 <lambdabot>   63.0
02:01:14 <ddarius> > bitSize (undefined :: Int)
02:01:15 <lambdabot>   64
02:01:53 <andras> Whenever I try to write code that's of any use, I seem to run into runtime and memory problems. Am I the only one of this kind? :(
02:01:53 <bazmatt> 9223372036854775807 is enough for a great many more situations than 2147483647 is..
02:02:31 <merijn> bazmatt: maxBound/minBound will return the max and min bounds for any bounded datatype (such as Int)
02:02:37 <merijn> > maxBound :: Char
02:02:38 <lambdabot>   '\1114111'
02:03:01 <mm_freak> bazmatt: do you /want/ your integer to be size-constrained?
02:03:07 <bazmatt> merijn: so I figured
02:03:26 <bazmatt> mm_freak: rarely, but certainly sometimes when doing something heavy
02:03:33 <ion> If you actually care about the size, use one of the IntN/WordN types.
02:03:35 <merijn> bazmatt: Anyhoo, Integer is unconstrained should you need it (at the cost of being slightly slower than Int)
02:03:53 <ion> > (maxBound :: Int16, maxBound :: Word16)
02:03:53 <lambdabot>   (32767,65535)
02:04:07 <bazmatt> ion: good, thx
02:04:28 <RayNbow`TU> @check \x -> abs (x::Int8) >= 0
02:04:29 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int8)
02:04:29 <lambdabot>    arising from a ...
02:04:33 <RayNbow`TU> tsk
02:04:36 <kensho> Hi. I'm having trouble installing the encoding package through cabal. The error message says that regex-base requires mtl-1.1.0.2 but encoding wants 2.0.1.0. cabal info mtl says 2.0.1.0 is installed. but it also says that regex-base is already the latest version. How can I resolve this problem?
02:05:06 <RayNbow`TU> @check \x -> abs (fromIntegral x :: Int8) >= 0
02:05:06 <lambdabot>   "OK, passed 500 tests."
02:05:10 <RayNbow`TU> @check \x -> abs (fromIntegral x :: Int8) >= 0
02:05:11 <lambdabot>   "OK, passed 500 tests."
02:05:16 <RayNbow`TU> hmm
02:05:19 <jkff> kensho: Please post a full cabal install log somewhere
02:05:20 <kensho> I'm on windows 7 and I use the ghc platform btw (ghc version is 6.12.3)
02:06:15 <RayNbow`TU> ah right...
02:06:30 <mm_freak> bazmatt: in haskell, just use Integer
02:06:51 <mm_freak> in general Integer is not slower than Int, when the numbers fit into a single machine word
02:07:26 <dafis> mm_freak: it is slower, but not much
02:07:31 <gienah> kensho: regex-base-0.93.2 just says it wants mtl, compiles fine with mtl-2 
02:07:40 <mm_freak> dafis: i've had cases, where it's even faster
02:07:41 <dafis> it has to check for overflow
02:07:45 <andras> Today I was trying to form the sum of n random Doubles (n=10^6 for example). What's the most efficient way of doing it?
02:07:50 <mm_freak> probably because Integer is better optimized than Int in some places
02:07:55 <dafis> mm_freak: huh? examples?
02:08:11 <mm_freak> dafis: can't reproduce it right now
02:08:22 <bazmatt> mm_freak: I'll have to test that.. but one shouldn't do premature optimizations anyway...
02:08:27 <gienah> kensho: and regex-base-0.93.2 compiles fine with mtl-1
02:08:31 <andras> that is, how do i avoid storing all randoms in a list so that sum can add them all up?
02:08:52 <dafis> mm_freak: Integer is often faster than Int64 on 32-bit machines, could it have been that?
02:09:55 <rothwell> dafis: Integer faster than Int64?
02:10:53 <mm_freak> dafis: nope
02:10:54 <kensho> gienah: ah ok I see... I assumed that was the cause for the error. But actually it's missing a header file "system_encoding.h"
02:11:10 <dafis> rothwell: on 32-bit boxes, Int64 arithmetic is a C-call, when things mostly fit in a 32-bit machine word, Integer is faster because then it uses machine Ints
02:11:33 <Jafet> > let xs = take 1000000 $ unfoldr (Just . randomR (0.0, 1.0)) (mkStdGen 0) in foldl1' (+) xs -- generate them as you add them
02:11:33 <rothwell> dafis: ah, i see
02:11:36 <lambdabot>   499989.6385748057
02:11:39 <mm_freak> bazmatt: haskell is a high level language, and unlike other high level languages it really means itâ¦  don't learn to optimize haskell code now, but rather concentrate on getting your design patterns right
02:12:57 <gienah> kensho: its included in the encoding package: http://code.haskell.org/encoding/system_encoding.h
02:14:30 <bazmatt> mm_freak: yes, yes, but sometimes you really do have to squeeze everything out of the code. Rarely and after profiling, but still..
02:14:57 <merijn> bazmatt: Yes, but what he means is "everything you know about optimizing is wrong when applied to Haskell" :>
02:15:04 <dafis> bazmatt: yes, Haskell can do that (most of the time)
02:15:23 <merijn> And learning how to do it is harder if you don't really know Haskell yet :p
02:15:35 <mm_freak> bazmatt: you optimize haskell by understanding the semantics and using the design patterns, which fit with them =)
02:15:39 <dafis> merijn: not when you've learned optimising with Haskell :)
02:15:45 <Jafet> When there's something strange in your Haskell core... who do you call? (Don Stewart!)
02:15:47 <bazmatt> merijn: ok, I'll come back here in a year or two when I need to optimize something.. :)
02:16:41 <merijn> bazmatt: Laziness and aggressive compiler optimizations/inlining means that things which you tend to think of as slow in other languages can actually be quite fast in Haskell (and vice versa)
02:17:32 <bazmatt> merijn: I'm fully aware of that.. that's true even for java.
02:17:41 <mm_freak> bazmatt: in general, when you have to do low level optimizations, your problem is somewhere else
02:18:04 <merijn> Jafet: They say that if you say "Don Stewart" three times in front of an empty text editor he will appear and solve your problem with a one liner!
02:18:26 <mm_freak> and the low level optimizations will only make you more confused and less happy, because they don't work the way you expect
02:18:27 <dafis> merijn: doesn't work, I tried
02:18:27 <bazmatt> mm_freak: I assume you mean the general "you" and not *me*.
02:18:40 <mm_freak> bazmatt: yes
02:20:08 <bazmatt> *I* very rarely do low level optimizations, and when I do I profile first, and before that I try to get my data structures and algorithms right
02:21:04 * dafis has magic hashes for breakfast on weekends
02:22:02 <kensho> gienah: according to this SO question (and referenced forum discussion) http://stackoverflow.com/questions/4701585/how-to-install-haskell-module-encoding-0-6-3-on-windows the issue is that system_encoding.h depends on another header file but unfortunately the solution is not clear to me. 
02:25:12 <andras> Jafet: thanks, it seems that foldl1' is what I was looking for...
02:26:29 <andras> Jafet: i've just rewritten your line, and it still works OK
02:26:32 <andras> > foldl1' (+) $ take 1000000 $ (randoms (mkStdGen 0) :: [Double])
02:26:34 <lambdabot>   499989.6385748057
02:27:14 <andras> Jafet: is there a more advanced reason for using unfoldr that I can't see?
02:27:39 <Jafet> Er, no. I just don't really know all the functions in System.Random
02:28:48 <andras> Jafet: OK, thanks
02:33:11 <gienah> kensho: system_encoding.h does: #include <langinfo.h> #include <locale.h> I guess you need langinfo.h for mingw, not  sure where to find it so far
02:34:30 <gienah> kensho: maybe here: http://snaury.narod.ru/mingw-langinfo-0.1.html
02:41:03 <kensho> ginah: thanks. unfortunately that had no effect. I now tried to install iconv but I get a similar error about hsiconv.h *sigh*. I guess I should get a proper OS ...
02:43:26 <BorisL> I get a strange error with functional dependencies. http://hpaste.org/45875/functional_dependencies
02:44:03 <BorisL> GHC 7.0.2 is used
02:47:11 <jkff> Hi. What is a good canonical "FP advocacy" text, answering the question "So what's so cool about FP that I should learn it?"
02:47:54 <Jafet> Alice in Wonderland.
02:48:58 <unfo-> the whole concept of "tell me why i should learn something" seems odd to me since knowledge in itself is valuable o_O
02:48:59 * rothwell suffers brain damage from iteratees
02:49:11 <rothwell> won't be seeing those brain cells again
02:49:27 <crystal-cola> unfo-: How do you prove that knowledge in itself is valuable?
02:49:35 <osfameron> ah, that's from Perlis isn't it?
02:49:36 <osfameron> "The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman."
02:49:39 <osfameron> doesn't specify FP though
02:49:42 <Jafet> Your anatomy must be pretty screwed up, if you can see any of your brain cells at all!
02:49:55 * osfameron keeps meaning to reread Alice with a programming mindset
02:50:39 <rothwell> Jafet: prefer to think of it as unique
02:50:48 <osfameron> jkff: a quick google for "why haskell" throws p many things, including http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html from RWH
02:51:21 <nazgjunk> jkff: I don't have a text for you, but the answer I'd give is that it encourages you to consider problems from different perspectives when you're familiar with more of them
02:51:41 <nazgjunk> It's deadly to be locked into a OOP mindset for every problem you walk into
02:51:55 <Jafet> Were you born with a zygohistomorphism, perchance?
02:52:49 <osfameron> jkff: the other one I came across the other day was http://www.haskell.org/haskellwiki/Why_Haskell_matters
02:53:19 <jkff> osfameron: that is good but not very convincing for someone not willing to spend a lot of time reading a blanket of text :) I also looked at Hughes' "Why FP matters" and it's a bit too numeric / algorithmic.. The thing is, a colleague asked me "so what is FP about?" and I caught myself not being able to deliver an answer immediately.
02:54:01 <osfameron> jkff: I suspect that you're going to find it hard to convince someone who won't read.
02:54:39 <crystal-cola> jkff: what is FP about?
02:55:16 <osfameron> jkff: actually, I'm looking into the same thing, as I'm going to give a brief introduction to haskell for a local Geekup sometime soon...
02:55:51 <unfo-> crystal-cola, proving something is of value to someone seems like a philosophical debate to me.
02:56:08 <jkff> osfameron: it's not a dychotomy between "will read nothing" and "will read any-sized blanket of pure text"
02:56:25 <crystal-cola> unfo-: so there is no justification for the claim?
02:56:53 <osfameron> jkff: fair enough ;-)  anyway, those are 2 good places to start, let us know if you find (or write) a more compact version
02:57:02 <gienah> kensho: for iconv on windows see: http://www.mail-archive.com/haskell-cafe@haskell.org/msg87157.html
02:57:14 <Jafet> Well, it's certainly better than dysfunctional programming.
02:58:06 <jkff> Well, my usual short formulation is "FP is about having a large and powerful toolset of abstraction mechanisms"
02:58:21 <jkff> ouch
02:58:21 <jkff> pressed enter too early
02:58:47 <crystal-cola> jkff: The important thing to me about functional programming is that equality works
02:58:52 <crystal-cola> jkff: for example f x = f x
02:59:00 <osfameron> jkff: ooo, here's one someone just tweeted ;-) http://twitter.com/#!/consttype/status/60646985505587200
02:59:06 <osfameron> short enough? ;-)
02:59:09 <jkff> so, it's about having a much larger and more powerful toolset of abstraction mechanisms than usually encountered in OOP, and about facilities that actually allow you to use them without fear - purity, strong static typing etc.
02:59:40 <jkff> e.g. you could have a 6th-order function in Java, but you'd go to asylum when trying to determine what it really does, given the side effects
02:59:40 <Jafet> jkff: Lisp, the archetypal "functional language", has neither.
02:59:40 <unfo-> crystal-cola, Goodbye.
02:59:52 <Jafet> So what's "functional programming" to you?
02:59:57 <crystal-cola> are you leaving?
02:59:59 <jkff> Jafet: it is not true - Lisp at least *encourages* purity
03:00:01 <Twey> Lisp is neither a language nor functional
03:00:01 <kensho> gienah: I have successfully installed iconv now. Thank you very much for your help!
03:00:25 <Jafet> jkff: not always.
03:00:26 <unfo-> crystal-cola, this conversation did not add value to my life and thus i have ended it.
03:00:26 <gienah> kensho: great, no worries
03:00:43 <crystal-cola> not sure why you're being a dick about it
03:00:50 <osfameron> saying "Lisp isn't functional" seems to be overstating the case a little ;-)
03:00:56 <crystal-cola> guess you're upset that you can't justify your bizarre claims
03:01:23 <Jafet> Twey: yes, but it's archetypal of both!
03:01:34 <jkff> Well, if I programmed in Lisp without encouraging myself to be pure, I would not say that I'm doing functional programming :)
03:02:08 <jkff> Even if so, the powerful abstraction mechanisms are a good enough argument to say that Lisp is "functional" in most of the sense that I'm giving to this word
03:02:17 <Jafet> So, what does "functional" mean to you?
03:03:36 <hvr_> if a program works as intended, it's functional *ducknrun*
03:03:41 <jkff> "Functional programming" means to me "a style of programming based on using powerful abstraction mechanisms" - however that feels somewhat incomplete.
03:03:58 <Jafet> What, Smalltalk does not provide powerful abstraction mechanisms?
03:04:07 <Jafet> (whatever that really means)
03:04:31 <jkff> You can program functionally in Smalltalk too, even in Java.
03:04:34 <crystal-cola> unfo-: anyway I'll just put you on /ignore then
03:04:44 <jkff> I'm not talking about what's a functional language
03:04:49 <jkff> that discussion I find pointless
03:04:59 <ousado> crystal-cola: how does being honest about the perceived value of a conversation make someone a dick?
03:05:14 <jkff> I'd probably add "an inclination towards declarativity" and "an inclination towards formal specification"
03:06:09 <Jafet> Declarative programming is nice, but it does not need to involve mathematical functions
03:06:20 <jkff> However, it is natural that it's easier to use those "powerful abstraction mechanisms" where 1) they are present and 2) features and traditions preventing you from using them correctly are absent
03:06:38 <jkff> Jafet: true, I'm not saying that it does.
03:07:55 <jkff> Hm, maybe one could say that FP is about abstraction and composability.
03:08:10 <Twey> Or maybe one could not
03:08:21 <Twey> And just use the damn language
03:08:42 <Twey> We need to abandon this âFPâ stuff and come up with some terms that are actually meaningful
03:08:43 <int-e> jkff: did you really mean "absent"?
03:08:44 <Jafet> So your "functional" seems to be a mish-mash of ideas, not describing any particular aspect of a language, like usage of functions, value semantics, purity, declarativity, formal specification, etc. In other words, it's based on some particular language(s).
03:08:51 <crystal-cola> jkff: did you see my answer
03:08:52 <Twey> Like âpureâ, or âstrongly-typedâ
03:09:00 <jkff> crystal-cola: which one?
03:09:12 <Twey> Jafet: Sounds like everyone else's âfunctionalâ
03:09:24 <crystal-cola> jkff: That equality works
03:09:24 <Jafet> Except mine, of course.
03:09:25 <int-e> jkff: ah wait. My mistake, I expected "preventing you from using them incorrectly are present"
03:09:28 <jkff> Jafet: yes. I just have no better word for that rather than "FP"
03:09:32 <Twey> Heh
03:09:32 <jonkri> is using mvars (like this: http://hpaste.org/45844/synchronous_function_in_asyncr ) a nice way to make a synchronous function in an asynchronous environment?
03:10:05 <jkff> crystal-cola: yes, I did, but, although that agrees with my understanding, that's not a very good way to summarize FP to someone unfamiliar.
03:10:08 <Jafet> jkff: don't use any particular words for that, then. "FP" is a minefield.
03:10:11 <Twey> jonkri: Yes, seems reasonable
03:10:14 <crystal-cola> jkff: yes it is
03:10:23 <int-e> jkff: which is still different from what you wrote, but in a non-contradictory way.
03:10:25 <Twey> jonkri: Though your code can be written more simply
03:10:50 <jkff> Jafet: It is a minefield when you're discussing it with experts; it's not when you're simply encouraging someone to learn it.
03:11:01 <jonkri> Twey, nice :) how?
03:11:04 <crystal-cola> jkff: This is the best way to explain what functional programming is
03:11:19 <Twey> jonkri: To start with, âdo x <- y; xâ is exactly equivalent to âyâ
03:11:34 <quicksilver> Twey: join y
03:11:35 <jkff> crystal-cola: Have you tried this explanation on someone? :)
03:11:40 <jonkri> ah, of course :)
03:11:54 <Twey> Err, yes
03:11:55 <Twey> join y
03:12:05 <jonkri> no wait
03:12:16 <jkff> crystal-cola: I can equally say that "Hey, FP is when your language is based on the lambda calculus", but that also doesn't tell much.
03:12:26 <Twey> syncFunc c = newEmptyMVar >>= liftM2 (>>) (writeChan c . GetMyValueEvent) takeMVar
03:12:27 <jonkri> ah, this should be an IO function
03:12:34 <Twey> Err, no
03:12:41 <Twey> syncFunc c = newEmptyMVar >>= liftM2 (>>) (writeChan c . GetMyValueEvent) (join . takeMVar)
03:12:42 <crystal-cola> jkff: lambda calculus is only important for the type system
03:12:56 <Twey> jonkri: Yeah, hence the âjoinâ quicksilver pointed out
03:13:02 <jkff> crystal-cola: why? are you saying it's unimportant in Lisp where we have no type system? :)
03:13:04 <jonkri> that doesn't look simpler... i will try to understand it :)
03:13:10 <Twey> y >>= \x -> x = y >>= id = join y
03:13:23 <crystal-cola> yes lambda calculus is irrelevant to lisp
03:14:06 <jkff> that is a strong statement, I must say
03:16:24 <Jafet> Haskell is sort of based on the System F calculus
03:16:25 <jonkri> thanks
03:17:32 <Jafet> jkff: instead of encouraging someone to learn "functional programming", you could encourage them to learn Haskell. Equal success, less confusion.
03:18:06 <rostayob> two questions about pandoc: 1) is it fast 2) is it easy to define a subset of some reader?
03:18:18 <Peaker> I don't even describe Haskell as a "functional language" to people.. that has too many negative connotations (e.g: Various Lisps) that IMO are justified
03:18:24 <jonkri> how can i have a blocking function, like, takeMVar, time-out?
03:18:56 <crystal-cola> it's a true statement, taking peoples false prejudices into account leads to disease
03:19:19 <hepek> @rostayob what's wrong with lisps?
03:19:19 <lambdabot> Unknown command, try @list
03:19:20 <Twey> jonkri: Using âtimeoutâ from System.Timeout.timeout
03:19:21 <Peaker> My experiences with "real world Haskell" lead me to believe that separating partiality in the type system like we separate effects/etc is extremely important especially since Haskell's debugging tools are so primitive
03:19:22 <Twey> Err
03:19:24 <Twey> Yeah
03:19:24 <quicksilver> crystal-cola: stop trolling. Start contributing or be quiet.
03:19:27 <aristid> @hoogle timeout
03:19:27 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
03:19:28 <lambdabot> module System.Timeout
03:19:28 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
03:19:33 <mosno> Peaker: just curious, what's negative about lisp? i'm currently learning elisp
03:19:44 <Twey> jonkri: Read the docs, though â it has some caveats
03:20:01 <crystal-cola> elisp is terrible..
03:20:04 <aristid> mosno: lisp is very different from haskell, and people in #haskell obviously like haskell.
03:20:06 <rostayob> hepek: lisps?
03:20:07 <hepek>   @rostayob: what's wrong with lisps?
03:20:10 <Twey> ELisp is pretty awful as Lisps go
03:20:24 <rostayob> hepek: I don't think I get what lisp has to do with pandoc
03:20:41 <hepek> scheme is the best lisp out there
03:20:50 <Peaker> mosno, I think many Lisps made extremely bad design choices:  Lisp-2 which complicates everything for miniscule gain..  ELisp for example is not even lexically scoped(!),  I think the paren syntax is often adding pure noise and is objectively harder to parse large expression trees, ...
03:20:52 <rostayob> hepek: ...and?
03:21:13 <jonkri> thanks... i was reading this page a while back but dismissed it for some weird reason :S obliged! ;)
03:21:20 <rostayob> oh, maybe you got confused with "reader"
03:21:40 <rostayob> pandoc has nothing to do with lisp: about:blank
03:21:44 <rostayob> http://hackage.haskell.org/package/pandoc
03:21:55 <Peaker> mosno, CL's multiple return values seems like a very bad way to extend return values without breaking backwards compatibility...  The names for basic things ("cons", "car", "cdr") are horrible (though Haskell shares this problem)
03:22:15 <Jafet> ...it's a problem?
03:22:16 <osfameron> haskell doesn't have car/cdr at least, which is nice
03:22:34 <osfameron> head/tail ftw
03:22:36 <mosno> Peaker: i see
03:22:41 <flux> didn't CL have some english names for those car/cdr as well?
03:22:48 <mosno> Peaker: i'm only learning it so i can use emacs to its full potential
03:22:49 <flux> or am I mixing it up with something else
03:22:54 <mosno> aristid: obviously.
03:22:58 <hepek> Scheme has first and rest for car/cdr
03:23:17 <mosno> Peaker: although sometimes i wonder why i bother
03:23:18 <Jafet> Haskell does not have Lisp's pairs, anyway.
03:23:27 <hepek> Scheme and Haskell share most of the underlying concepts, the only difference being laziness/strictness in evaluation and dynamic vs static typing
03:23:34 <Peaker> flux, it's not the "non-Englishness", it's the apparent lack of relationship between "cons", "car", and "cdr" -- that could be apparant from names like "pair", "pairfirst", "pairsecond" (or shorter names)
03:23:51 <Peaker> mosno, Learning elisp is a worth-while investment, even if elisp is a rather badly designed language
03:24:05 <mosno> Peaker: because of emacs?
03:24:10 <Peaker> mosno, yeah
03:24:10 <int-e> yeah, car and cdr are just obscure. cons for 'construct' has some meaning.
03:24:13 <crystal-cola> flux: yes it does
03:24:19 <crystal-cola> HEAD and TAIL
03:24:23 <crystal-cola> FIRST and REST
03:24:24 <crystal-cola> etc.
03:24:30 <aristid> hepek: and the entire type system and partial functions and separation of side effects and....
03:24:31 <FauxFaux> CAR AND CDR
03:24:33 <hepek> crystal-cola> yup
03:24:37 <aristid> hepek: really, they're COMPLETELY DIFFERENT
03:24:46 <hepek> car and cdr come from some of the lispmachines hardware registers
03:24:50 <int-e> (I know they are 'contents of address register' and 'contents of data register', respectively. But if anything, that makes it even more obvious that the names are obscure)
03:24:58 <hepek> car meaning contents of address register
03:24:59 <hepek> and cdr meaning contents of data register
03:25:03 <hepek> just bad heritage
03:25:14 <shachaf> The names have their own meaning by now.
03:25:22 <shachaf> It's like "grep".
03:25:23 <hepek> they stuck around because of 
03:25:27 <paolino> hello , is there a functor like class for data A a (b a) types ?
03:25:31 <hepek> caaar, caadr cadar
03:25:34 <hepek> and stuff
03:25:51 <hepek> you can't make reasonable combinations with HEAD AND TAIL
03:26:02 <Peaker> hepek, On top of that, there's purity vs. non-purity.  There's a completely different approach to grammar.   Not sure what remains for Scheme and Haskell to *share* after all these differences
03:26:05 <hepek> HTHTAIL? -> just doesnt cut it
03:26:18 <shachaf> The fact that their heritage is somewhat obscure only helps give them their own meaning. It's a compact and universally-understood (in the LISP world) notation for a pair.
03:26:19 <Peaker> hepek, why are these a good idea at all?  There's the useful (nth 3 ...)
03:26:24 <osfameron> what's the point of caaar etc.?  aren't those just subsumed by (!!) ?
03:26:35 <osfameron> and/or by pattern matching
03:26:36 <flux> hepek, I'm not sure if for example 'cadar' should exist..
03:26:48 <int-e> hepek: luckily we have records with aribtrary selector names.
03:26:49 <Peaker> hepek, in Haskell, you can use a path on a tree like:  (first . second . first . first)
03:26:50 <quicksilver> Peaker: functions as first class objects, lexical scope and closure/capturing
03:26:53 <crystal-cola> osfameron: cadddaar isnot
03:27:11 <osfameron> crystal-cola: ah, I have no idea what that would mean
03:27:13 <quicksilver> Peaker: are pretty strong similarities between haskell and scheme as opposed to, say, Algol or Basic.
03:27:16 <Peaker> quicksilver, yeah, so I guess Python, Scheme and Haskell a roughly the same language :)
03:27:25 <crystal-cola> osfameron: it's just car o cdr o cdr o cdr o car o car
03:27:28 <quicksilver> Peaker: having things in common doesn't make you the same.
03:27:52 <Peaker> quicksilver, I was just mocking hepek's statement about sharing the underlying concepts
03:27:55 <int-e> Peaker: ignoring the type system, laziness, and purity? sure ...
03:28:18 <int-e> :)
03:28:41 <osfameron> crystal-cola: what sense does car of car have?  is it for nested lists?
03:28:42 <Peaker> Yeah, ignoring all of the interesting parts of Haskell makes it look a bit more similar to Scheme :)
03:28:46 <quicksilver> osfameron: yes.
03:28:51 <quicksilver> osfameron: tree-ish structures.
03:28:52 <hepek> scheme is in that respect much closer to Haskell than Common Lisp -- Closure, first-class functions, one namespace for functions and variables, lexical scope
03:28:57 <crystal-cola> osfameron: yes you can build arbitrary tree structures ouf sexps
03:29:02 <osfameron> ah ok
03:29:22 <Jafet> Haskell has namespaces for types, values, and modules
03:29:26 <osfameron> in that case, pattern matching or composing tree searches seems to make more sense than random garbage names
03:29:27 <Peaker> hepek, the namespace silliness in CL is unnecessary complicated, but it is a superficial difference..
03:29:47 <hepek> Peaker, true
03:29:56 <osfameron> it feels like a "red flag" to want to name a specific one of the paths
03:30:06 <shachaf> Jafet: You never really have a place where you #' a type, though.
03:30:07 <osfameron> (like indexing into an array is often a red flag)
03:31:04 <Peaker> osfameron, lots of standard CS algorithms are expressed in terms of array indexing..  I guess some could be rewritten in terms of comprehensions or such
03:31:30 <quicksilver> osfameron: Yes. People were less good at abstraction in those days and more concerned of the costs.
03:31:32 <osfameron> Peaker: well, "red flag" doesn't mean it's always wrong, just that it might be ;-)
03:31:53 <Twey> Reasonably; AIUI, Lisp lost out to C because of the cost of GC in those days.
03:32:10 <Twey> If it weren't for that, we would be living in quite a different world nowâ¦
03:32:35 <Twey> osfameron: Indexing is what an array is *for*
03:32:41 <Peaker> anyway, what I wanted to talk about was the destructive combination of: A) Haskell's lack of runtime debug tools,  B) Haskell's abundance of partial functions not marked as such.    Partiality is hiding everywhere! (Behind !, head, fromJust, ...).  Each is not so bad on its own. But a large app failing due to B, is very very hard to debug due to A
03:33:13 <Twey> âEverywhereâ is a bit of a stretch
03:33:15 <osfameron> Twey: in haskell, yes.  In most languages you use arrays where you conceptually only need a list, just because they're the data-type that's available
03:33:26 <blackdog> Peaker: aren't partial functions considered pretty bad style?
03:33:27 <Twey> Experienced Haskell programmers usually know and avoid the common partial functions
03:33:30 <Peaker> Haskell has qualities making it awesome for large compositions.. but A+B here are really really obstructing the creation of large programs
03:33:38 <blackdog> ! is probably unavoidable
03:33:43 <roconnor> Peaker: I think we should throw out most of the partial functions
03:33:46 <Peaker> blackdog, it could return a Maybe..
03:33:46 <Twey> We could just remove !
03:33:54 <Twey> Or, well, use Maybe
03:33:57 <Twey> Yeah
03:34:26 <Peaker> roconnor, I agree.. I think Haskell chose a side in the convenience/safety trade-off, and it's safety.  There are other languages optimized for "convenience", and for one-liners they're nice.  For large programs safety is far more important
03:34:31 <Twey> roconnor: I'd be okay with sticking them in a submodule on their own.
03:34:36 * roconnor uses listToMaybe instead of head, and fromJust is usually for screwing around in ghci
03:34:40 <blackdog> or prove the indices safe in the type system:)
03:34:49 <Peaker> listToMaybe ought to have been named safeFirst or safeHead or such
03:35:02 <Twey> Or, y'know, âheadâ
03:35:03 <roconnor> listToMaybe ought to have been named head
03:35:07 <merijn> head just ought to have been named "unsafeHead"
03:35:09 <Twey> Heh, âµ
03:35:09 <Peaker> Yeah, head would be nice :)
03:35:15 <Twey> Though
03:35:25 <Twey> Rather than head/tail, I would rather have âlistâ
03:35:28 <merijn> Would give us access to a whole new area of bad puns too
03:35:31 <blackdog> we need a package namespace "NaughtyCorner"
03:35:38 <blackdog> and exile all the partial functions;)
03:35:43 <roconnor> the only partial functions I hesitate getting rid of are recip and (/)
03:35:46 <Peaker> or if we named fromJust "fj", you could just use "fj" on any safe result to get the current unsafe behavior, but "fj" would be an easily searchable mark of blasphemous code
03:35:51 <ousado> blackdog: are you the guy who wrote all those haxe-wrappers?
03:35:52 <Twey> (list :: r -> (a -> [a] -> r) -> [a] -> r)
03:36:04 <crystal-cola> roconnor: isn't that just a losing game though?
03:36:10 <roconnor> crystal-cola: what?
03:36:15 <quicksilver> It seems incongrous to blame the language - the fault is with people who use head/tail/fromJust without understanding.
03:36:16 <crystal-cola> roconnor: In the end your program /is/ going to have unjustifiable assumptions
03:36:26 <Jafet> @vixen Do you like head?
03:36:27 <roconnor> not when I'm done with it!
03:36:27 <lambdabot> i'd say i like
03:36:28 <crystal-cola> roconnor: I mean using things like listToMaybe instead of head
03:36:38 <quicksilver> but maybe they should be documented better.
03:36:43 <Peaker> quicksilver, The fact the language exposes an abundance of these and gives them "nice" first-class names encourages their use
03:36:49 <quicksilver> perhaps.
03:36:51 <blackdog> ousado: haxe-wrappers? no
03:36:52 <crystal-cola> algorithms are much more complicated than what Haskell knows
03:36:56 <roconnor> crystal-cola: more generally speaking you can very often restructure your program to use pattern matching instead of head.
03:37:08 <roconnor> crystal-cola: in other cases I have found listToMaybe actually can fit well in
03:37:09 <Twey> Or âlistâ
03:37:15 <blackdog> ousado: I did write the bot Jafet is being so forward with, though.
03:37:21 <Peaker> I would be OK with Haskell's abundance of partiality (of course I would prefer it gone) -- but in other languages partiality comes with nice debuggers!
03:37:22 <crystal-cola> roconnor: I'm not just talking about lists though
03:37:24 * Twey wants âlistâ in the Prelude.
03:37:24 <merijn> Bollocks to all that, I just want a total language with constraint typing
03:37:27 <Peaker> Haskell doesn't have the nice debuggers to cover for the partiality
03:37:28 <roconnor> crystal-cola: and in other cases still, propogating lists elsewhere is also good
03:37:31 <Peaker> so it's just unacceptable
03:37:39 <shachaf> fromJust is the general-purpose total-function-returning-maybe-to-partial-function converter.
03:37:41 <Twey> How come we have âmaybeâ in the Prelude but not âlistâ?
03:37:42 <augustss> crystal-cola: Haskell knows nothng about algorithms, it's a programming language
03:37:46 <shachaf> So it should be renamed to toEvil.
03:37:50 <ousado> blackdog: ok,so it's just the same nick and you're not mr. turner :)
03:37:50 <Twey> Ha
03:37:51 <merijn> Plus maybe a total coprogramming language
03:37:54 <Peaker> Twey, it's just called foldr
03:37:54 <roconnor> Twey: what is list?
03:37:56 <crystal-cola> augustss: exactly.. that's why I think it's a losing game
03:38:05 <Peaker> Twey, unless you want it to be non-recursive?
03:38:12 <merijn> crystal-cola: Or you teach the language about algorithms instead :>
03:38:19 <Twey> roconnor: list :: r -> (a -> [a] -> r) -> [a] -> r
03:38:22 <crystal-cola> impossible, sadly
03:38:29 <merijn> crystal-cola: Why?
03:38:31 <augustss> crystal-cola: yeah, Haskell will never be a programmer
03:38:38 <roconnor> crystal-cola: I'm not just talking about lists either
03:38:40 <shachaf> Twey: Is there a general name for that sort of "one-level fold"?
03:38:47 <Twey> shachaf: I don't know of one
03:38:55 <Peaker> I heard a name for it here once
03:38:57 <illissius> is there some word we can use to distinguish "might cause an exception" (partial functions) from "shatters reality into jagged pieces, use at own peril" (unsafePerformIO, unsafeCoerce, reallyUnsafePtrEquality#, etc.), which is where you more traditionally encounter the word "unsafe"?
03:39:01 <Twey> I don't think âone-level foldâ is a reasonable description in general
03:39:09 <quicksilver> illissius: partial? ;)
03:39:13 <Twey> I mean, sure, for âlistâ, but describing âmaybeâ as a fold is odd.
03:39:17 <crystal-cola> roconnor: well I am very bad at programming so I always found myself giving up on all this "safe" stuff since it didn't seem possible
03:39:19 <zygoloid> illissius: partial versus impure
03:39:40 <shachaf> Twey: Well, I guess i's just a function that deconstructs each constructor.
03:39:43 <augustss> Twey: I'd call is a case function.
03:39:45 <illissius> right, but I mean for naming the function itself
03:39:47 <roconnor> crystal-cola: I've gotten better with practice and inspiration.  I used to have trouble ridding my Pascal programs of goto.
03:39:52 <Twey> illissius: We prefer to just not speak of the latter
03:40:01 <cheater00> hey guys, looking at slide 18 of    http://qconlondon.com/dl/qcon-london-2011/slides/GregoryCollins_HighPerformanceWebApplicationsInHaskell.pdf     shouldn't "\forall l . \forall n . isPrefixOf (take n l) n"    actually be   "\forall l . \forall n . isPrefixOf (take n l) l"   ?
03:40:03 <Twey> shachaf: Yeahâ¦ a deconstructor, I guess
03:40:05 <quicksilver> partialFromJust
03:40:15 <crystal-cola> roconnor: that's not the same though, because no gotos is formally equivalent in terms of expressiveness
03:40:18 <illissius> partial feels wrong as a name for some reason
03:40:24 <illissius> though I'm having trouble articulating why
03:40:44 <zygoloid> illissius: easy solution: don't write partial functions :)
03:40:44 <HugoDaniel> hi
03:40:51 <shachaf> cheater00: Sounds that way.
03:40:57 <cheater00> thanks!
03:41:11 <HugoDaniel> why does 3 < length [1..]  takes forever ?
03:41:16 <HugoDaniel> shouldn't it be "lazy" ?
03:41:20 <Peaker> crystal-cola, once you get the hang of semantic editor combinators, fiddling with Maybe's is not noticeably harder than fiddling with the values directly
03:41:23 <shachaf> HugoDaniel: No, because Int isn't lazy.
03:41:28 <HugoDaniel> oh
03:41:33 <illissius> zygoloid: heh, yeah. or rather, as someone else implied, don't write partial functions, only functions returning Maybe, and then a single partial function, adjectiveFromJust
03:41:33 <shachaf> You can use lazy naturals if you want it to be lazy.
03:41:43 <HugoDaniel> shachaf, lazy naturals ?
03:41:57 <crystal-cola> just imagine for example you have an algorithm which only works if one of the inputs is a prime number
03:41:58 <augustss> HugoDaniel: You need lazy numbers for it to be lazy
03:42:04 <crystal-cola> what are you going to do about that?
03:42:04 <roconnor> crystal-cola: fair point. You agree that there is (ought to be) a proof of safety of your program. The question is can Haskell type system encode that proof.  Haskell cannot always, but it can in far more situations than most people imagine I think.
03:42:06 <illissius> because fromJust :: Maybe a -> Maybe a doesn't make very much sense.
03:42:09 <HugoDaniel> i can get it to work properly with bytestreams though
03:42:23 <HugoDaniel> because of fusion i guess
03:42:48 <aavogt> HugoDaniel: you're using the same function there?
03:42:58 <augustss> crystal-cola: that's easy, just return a Maybe
03:43:06 <shachaf> HugoDaniel: You take the length of an infinite bytestream and it returns something that you can compare with 3?
03:43:26 <Peaker> crystal-cola, I would return a Maybe -- and have the caller who can actually prove somehow that his number is prime, do the evil "fromJust" on it -- with a big comment explaining why he is indeed sure that it is safe.  Perhaps I'd use:   justOrError str Nothing = error str ; justOrError str (Just x) = x
03:43:53 <Peaker> We should probably force each "fromJust" call to give a string for error so it is easier to diagnose and to encourage people to explain why they are so sure it isn't Nothing
03:43:53 <roconnor> crystal-cola: I was thinking of creating a type of certificates of primality
03:43:58 <crystal-cola> yes but we're trying to avoid using fromJust...
03:44:24 <shachaf> Clearly Haskell should just ban partial functions except "in the Partial type", like sane languages do.
03:44:32 <roconnor> shachaf++
03:44:34 <roconnor> :D
03:44:41 <augustss> shachaf: yes
03:44:50 <crystal-cola> lets see someone actually write a program in a "sane" language!
03:44:51 <int-e> @type fix
03:44:52 <lambdabot> forall a. (a -> a) -> a
03:44:59 <int-e> would be (a -> a) -> Partial a?
03:45:01 <augustss> shachaf: except there's no language that has managed to do that in a sane way
03:45:06 <Peaker> crystal-cola, even If it is hard or not possible to avoid fromJust -- the place you should do the fromJust is near the code that makes it clear why it is safe..  The function that expects primes cannot prove it indeed will be given a prime.  The one who gives it a prime does know that he just generated a prime
03:45:10 <roconnor> shachaf: can we ban non-poly time functions while we are at it!
03:45:11 <int-e> seems unwieldy.
03:45:17 <quicksilver> well, you can do that, sort of. do notation in the Maybe monad is the Partial type.
03:45:39 <quicksilver> but obviously this is only well-behaved partiality
03:45:59 <quicksilver> places where the called function indicates explicitly that it fails
03:46:06 <quicksilver> rather than by not terminating.
03:46:08 <Peaker> I know it sounds very appealing to make infinite loops the same _|_ as pure/imprecise exceptions, but I think it may be a mistake, because we can actually rather easily enforce type constraints on the latter, but not on the former
03:46:33 <HugoDaniel> shachaf: like this: http://hpaste.org/45879/lazyn
03:46:37 <roconnor> Peaker: I feel the same way ... but I haven't really come up with much else better. :/
03:46:42 <quicksilver> Peaker: but surely all that does is turn the latter into Maybe/Either ?
03:46:49 <quicksilver> which is an option we already have, if you choose to use it.
03:47:29 <shachaf> HugoDaniel: ['A'..] is finite.
03:47:38 <Peaker> quicksilver, Yeah, if everyone used it everywhere except in the one-off hacks, that'd be great. Since they don't, and IMO it is clearly a mistake that they don't, I prefer the language to banish "error" to be Left instead
03:47:47 <int-e> > last [0..] :: Int8
03:47:48 <lambdabot>   127
03:47:56 <shachaf> > length ['A'..]
03:47:56 <lambdabot>   1114047
03:48:00 <crystal-cola> okay so I actually do the same as you guys, I thoght you were doing something a bit more sophisticated
03:48:12 <Peaker> quicksilver, If Haskell values were nullable in addition to Maybe, do you think people would avoid using the nulls?
03:48:17 <HugoDaniel> ah ok
03:48:24 <HugoDaniel> i didn't knew that
03:48:41 <quicksilver> Peaker: we obviously have different experiences. I don't find much abuse of pure exceptions in my haskell programming.
03:48:44 <merijn> Peaker: Of course they would use that, because people are idiots :>
03:49:05 <HugoDaniel> so it goes like O(1114047) and then compares it to 3 ?
03:49:08 <Peaker> People would use it -- and their rational might even be a good one: If the smarter people who designed the language put it in -- it's probably a good idea to use it
03:49:11 <quicksilver> all the combinators you listed earlier also exist in Maybe form if you choose to.
03:49:27 <HugoDaniel> im better off with defining my own functions
03:49:32 <Peaker> And the smarter people who designed Haskell also put "head" in :-(
03:50:42 <Peaker> quicksilver, at work -- I convinced one guy to write a medium-sized project in Haskell.. and he did, and then he left. when trying to use it, I have to debug dozens of partiality cases out of it
03:51:05 <roconnor> Peaker: they also made gcd 0 0 = undefined ... so I wouldn't put too much faith into the designers of Haskell :D
03:51:08 <Peaker> quicksilver, and all I have to work with is an uninformative error message and thousands of lines of code from which it could originate...  When it happens in Python, I get a stack trace
03:51:15 <illissius> Peaker: I don't think it's so much "those people were smarter than me, I should follow their (implicit) advice" as "hmm, how do I do $x in this language? oh, with this", and they find 'head', or nullable objects, or whatever else the language provides, to solve their problem at that moment
03:51:37 <roconnor> Peaker: I think many people find Haskell 98 a regression over Haskell 1.4
03:51:56 <Peaker> roconnor, Yeah, I came much after H98 though, so only heard the Urban legends :)
03:52:08 <Peaker> Did H98 have anything better w.r.t partiality?
03:52:22 <crystal-cola> gcd 0 0 = 0?
03:52:23 <quicksilver> Peaker: well, I think that is an unfortunate situation you are in :)
03:52:29 <illissius> and/or because the language makes it so inconvenient to do it any other way that's not worth it even if you might want (e.g. many languages make it really hard to have non-nullable objects/values even if you want to)
03:52:37 <quicksilver> Peaker: it could probably have happened in any language. People write bad code and then leave.
03:52:45 <Peaker> quicksilver, The saddest part is that Haskell truly really does shine for large-scale programming in every other way.. this is a real drawback
03:52:52 <quicksilver> Peaker: I appreciate that not being able to get stack traces is annoying.
03:53:01 <Peaker> quicksilver, but in other languages, bad code is more frequent, so they have better debuggers to deal with it :)
03:53:07 <quicksilver> thousands of lines of code isn't very many, really.
03:53:15 <quicksilver> grep should find all the uses of head + fromJust
03:53:24 <merijn> It is if its J code :>
03:53:26 <HugoDaniel> Peaker, just use spoon :)
03:53:26 <Peaker> quicksilver, Yes, his Haskell code was about 2200 lines replacing 21000 lines of C++
03:53:31 <Peaker> HugoDaniel, what's that?
03:53:36 <HugoDaniel> spoon your code and flame the mailing lists :)
03:53:40 <HugoDaniel> thats my usual approach
03:53:54 <Peaker> Is there a spoon?
03:53:57 <HugoDaniel> http://hackage.haskell.org/package/spoon
03:54:12 <quicksilver> Peaker: OK, well, 2200 lines of code is nothing. I retract part of my sympathy. Just print it out and read it already :)
03:54:17 * JuanDaugherty thought KSLOC of haskell *was* supposed to be "a lot of code".
03:54:44 <Peaker> Hugglesworth, Is it a debugging tool like Debug.Trace to temporarily throw away referential transparency?
03:55:03 <Jafet> Wait, spoon is for debugging?
03:55:12 <HugoDaniel> Peaker: no, it just catches the exception and puts it in a maybe
03:55:15 <Peaker> quicksilver, and replace all the partial functions with Maybe, manually? That'd take hours
03:55:36 <Peaker> HugoDaniel, I seem to recall an explanation of why doing that purely is not referentially transparent
03:55:48 <quicksilver> Sometimes work takes hours. That's why it's a job and they pay you for it.
03:56:04 <quicksilver> I don't think analyzing and fixing a 2200 LOC project is that scary :) I'd do it happily.
03:56:25 <JuanDaugherty> for nothing?
03:56:27 <shachaf> quicksilver: Happily enough to do it without being paid for it? :-)
03:56:30 <Peaker> quicksilver, it isn't, it's just work my bosses would rather me not spending time on..
03:56:32 <roconnor> crystal-cola: 0 is the top of the divisibility lattice, and more generally x `meet` x = x in any lattice.
03:57:01 <roconnor> crystal-cola: 0 is the top of teh divisibility lattice implies that 0 is the greatest number ever!
03:57:22 <crystal-cola> hmm
03:57:26 <crystal-cola> 0 is a prime
03:57:43 <int-e> no.
03:57:45 <Peaker> I can't really think of an explanation now -- why would catching pure exceptions in pure code be non-referentially-transparent? Can anyone think of a reason?
03:57:45 <roconnor> crystal-cola: primes are the atoms of the divisibility lattice
03:57:58 <roconnor> crystal-cola: so they are usually far from the top
03:58:02 <int-e> 0 is divisible by a lot of numbers that aren't units or 0.
03:58:03 <aristid> 1 is a prime, 0 is not
03:58:11 <sipa> 1 is not a prime
03:58:12 <Ferdirand> 1 is a unit
03:58:18 <crystal-cola> I've decided that 0 is prime
03:58:18 <roconnor> 1 isn't an atom either since it is the bottom element.
03:58:19 <aristid> :D
03:58:38 <sipa> 2, -2, 3, -3, 5, -5, ... are primes (in Z)
03:58:57 <crystal-cola> 2 and -2 should be thought of as the same in the context of primes
03:59:00 <roconnor> those are all atoms in the quasi-lattice.
03:59:08 * roconnor wonders if quasi-lattice is a word
03:59:26 <roconnor> pre-lattice
03:59:46 <Peaker> HugoDaniel, I think I remember: catching into "Either String" is not referentially transparent (exposes which error it was, and thus evaluation order), I guess Maybe is fine.  For debugging I'd prefer (Either String) there
04:00:18 <roconnor> Peaker: catching LoopException is also bad
04:00:22 <HugoDaniel> yeah
04:00:27 <roconnor> I think I convinced spoon not to catch that
04:00:52 <Peaker> It could be interesting to have a "newtype Diagnosis" around String -- that is not an instance of Eq/etc, but has a function to print it in IO, so a program that spoons to Either Diagnostic is still referentially transparent, cannot be affected by the string of the error, but can print it out
04:00:58 <HugoDaniel> Peaker, or Either Error, where Error is a string and a error code, so you can easily parse it later
04:01:24 <Peaker> HugoDaniel, why would you want to parse it?
04:02:28 <Peaker> I guess if you try hard enough you could extract the string -- but you could only do it in IO, so that would be OK :-)
04:02:58 <shachaf> Either (IO String) :-)
04:03:23 <Peaker> Nice :-)
04:03:27 <Jafet> Exceptions throwing exceptions
04:03:58 <HugoDaniel> well, if you want to present yourself a nice call trace for the error
04:04:19 <Peaker> is it true that: spoon x = teaspoon (rnf x)  ?
04:04:30 <Peaker> oh, wait, forget that :-)
04:05:17 <quicksilver> Peaker: spoon doesn't violate r.t. as long as it only catches deterministic exceptions (which is what is intended, at least)
04:05:29 <Peaker> hmm.. is   x `deepseq` x   a useful expression? 
04:05:50 <Saizan> yes
04:05:51 <shachaf> More useful than x `seq` x.
04:05:53 <Peaker> I guess it's equivalent to   rnf x `seq` x ?
04:06:02 <quicksilver> Peaker: it feels like it violates monotonicity but I can't quite put my finger on it.
04:06:02 <Saizan> right
04:06:17 <Peaker> so is it true that:   spoon x = teaspoon (rnf x `seq` x)   ?
04:06:41 <Peaker> if it is true, it would be nice if it were defined that way internally?
04:06:55 <Peaker> (and you could use other evaluation strategies other than WHNF or RNF)
04:07:13 <HugoDaniel> ok, so
04:07:20 <HugoDaniel> about the lazy comparison with length
04:07:37 <HugoDaniel> what are my options besides writing my own length comparison function ?
04:07:43 <Saizan> quicksilver: let x /= _|_, spoon x = Just x; but _|_ <= x; so you'd conclude Nothing <= Just x if spoon were monotonic
04:07:55 <HugoDaniel> 3 < length [1..] halts my computer
04:08:15 <Jafet> genericLength [1..] :: Nat
04:08:24 <Peaker> > 3 < (genericLength [1..] :: Nat)
04:08:25 <lambdabot>   Not in scope: type constructor or class `Nat'
04:08:33 <Jafet> (Writing Nat is an exercise for the reader.)
04:08:38 <HugoDaniel> :D
04:08:42 <dafis> HugoDaniel: not , null . drop 3
04:08:55 <HugoDaniel> dafis
04:08:57 <HugoDaniel> oh wait
04:08:58 <HugoDaniel> ok
04:09:00 <HugoDaniel> let me refrase then
04:09:49 <HugoDaniel> min (length [1..]) (length [1..123])
04:10:28 <quicksilver> Saizan: ah right.
04:10:31 <aristid> HugoDaniel: hmm, with lazy naturals this might be possible :)
04:10:36 <HugoDaniel> so, this takes on forever, and it shouldn't imo :/
04:10:47 <quicksilver> Saizan: also returning Nothiing for some kinds of _|_ and _|_ for other kidns of _|_ feels semantically unsound.
04:10:58 <ion> length knows the result when it encounters the end of the list. min knows the result when it gets the result from both parameters.
04:11:07 <dafis> HugoDaniel: yes, that one would need lazy naturals or a custom function
04:11:23 <aristid> length (zip [1..] [1..123])
04:11:28 <aristid> is the cheap way out :)
04:11:51 <HugoDaniel> :)
04:11:59 <Jafet> The cool kids use lub.
04:12:04 <HugoDaniel> lub ?
04:12:13 <dafis> aristid: but works only if at least one list is finite
04:12:20 <roconnor> > min (length [1..]) (length [1..123]) :: Nat
04:12:21 <lambdabot>   Not in scope: type constructor or class `Nat'
04:12:25 <roconnor> > min (length [1..]) (length [1..123]) :: Natural
04:12:26 <lambdabot>   Not in scope: type constructor or class `Natural'
04:12:28 <roconnor> :(
04:12:32 <aristid> dafis: yes...
04:12:36 <roconnor> where Nat go?
04:12:47 <aristid> it was ever in lambdabot?
04:12:49 <roconnor> yes
04:12:49 <aristid> @hoogle Nat
04:12:49 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
04:12:50 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
04:12:50 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
04:13:01 <aristid> roconnor: is there a package on hackage with Nat?
04:13:09 <roconnor> yes
04:13:23 <roconnor> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Natural.html
04:13:45 <shachaf> quicksilver: Well, it implicitly puts everything in SpecialMaybe, kind of.
04:15:05 <aristid> roconnor: so i can confirm that it works with genericLength and Natural :)
04:15:30 <roconnor> yes
04:15:38 <shachaf> Clearly it's bad, but using _|_ in the ways that were discussed is kind of bad too.
04:15:44 <roconnor> aristid: We used to this with lambdabot
04:16:03 <aristid>  > (min `on` genericLength) [1..] [1..123] :: Natural
04:16:03 <aristid> 123
04:16:11 <aristid> fun! :)
04:17:01 <roconnor> Peaker: I used to think that errors should return Top instead of bottom.  This seems like it would make sense with Dana Scotts notion of inconsistent data, but I was never really able to make it work out :(
04:17:30 <shachaf> > aristid â lambdabot
04:17:32 <lambdabot>   True
04:17:41 <aristid> lol.
04:22:36 <args0> hi, can someone please explain to me what is ===> (x:xs)    thanks
04:23:51 <roconnor> cons x xs  or a pattern
04:23:55 <osfameron> @index (===>)
04:23:55 <lambdabot> bzzt
04:24:02 <osfameron> am I using @index wrong?
04:24:05 <shachaf> args0: You should probably read a Haskell introduction of some sort -- this comes up pretty early on.
04:24:08 <roconnor> depending on where it occurs
04:24:16 <osfameron> :t (===>)
04:24:17 <lambdabot> Not in scope: `===>'
04:24:23 <Boxo> args0: it's called pattern matching
04:24:31 <shachaf> osfameron: No, but it doesn't have an entry for (===>).
04:25:01 <osfameron> ah cool.  couldn't find (<$>) yesterday either, iirc
04:25:15 <osfameron> though I think I *did* get the syntax wrong then...
04:25:16 <args0> that's just an arrow
04:25:27 <shachaf> osfameron: @index just looks things up in a special @index file it has.
04:25:29 <shachaf> (I think.)
04:25:30 <args0> point at my question 
04:25:34 <ion> > let y ===> (x:xs) = x:y:xs in 42 ===> [0..3]
04:25:34 <lambdabot>   [0,42,1,2,3]
04:25:45 <shachaf> osfameron: @hoogle will usually find more things than @index.
04:26:05 <osfameron> shachaf: ah, shiny
04:26:05 <args0> (x:xs) what is this?
04:26:40 <shachaf> args0: Have you been reading the last few minutes of discussion? Your question was answered several times. :-)
04:27:09 <Peaker> roconnor, I don't know what Top would mean:  The Top of say, Bool, would be different/unequal to True/False?
04:27:19 <args0> shachaf: pattern matching ok... but does this also mean "for every" ?
04:27:35 <aristid> hmm, Monoid a => [a] could make a Num instance, right? i.e. 3 would be [mempty, mempty, mempty]
04:28:09 <shachaf> aristid: Why have the monoid constraint? [undefined, undefined, undefined] works just as well.
04:28:40 <aristid> shachaf: because maybe i want to use the values :)
04:28:42 <Peaker> shachaf, we were just talking about how evil partiality is! :-)
04:28:59 <aristid> min = zipWith mappend
04:29:24 <args0> does (x:xs) mean "for every" ?
04:29:41 <sipa> no it means, x prepended to xs
04:29:44 <Peaker> args0, No, it is a "cons" pair from which linked lists are built
04:29:45 <aristid> agemo: no it means "for the first in and the rest in xs"
04:29:55 <aristid> "for the first in x and the rest in xs"
04:30:03 <shachaf> Peaker: It's not evil if the type is forall a. [a]!
04:30:17 <shachaf> Peaker: (And if you don't allow seq. seq is evil.)
04:30:23 <aristid> shachaf: that's a lot more constrained than Monoid a => [a] :)
04:30:32 <shachaf> (...All right, it's a bit evil.)
04:30:37 <ion> x:xs returns a copy of the list xs with x inserted to the front. (x:xs) also works as a pattern that matches a nonempty list, essentially doing the reverse of that when used on the left-hand side of the = in a function definition.
04:30:44 <Peaker> shachaf, I could accidentally try to use it as a concrete type... and have no stack trace when it burns
04:30:52 <ion> (copy FSVO copy)
04:31:11 <args0> thanks
04:32:22 <aristid> why is there no maximum zip in Data.List?! :)
04:33:41 <roconnor> aristid: that requires the elements to be something like a monoid.
04:34:20 * roconnor wants monoidZip :: (Monoid m) => [m] -> [m] -> [m]
04:34:53 <aristid> roconnor: zipMax :: [a] -> [b] -> [(Maybe a, Maybe b)]
04:35:37 <aristid> granted it's trivial to lift this into monoidZip and vice versa
04:35:44 <roconnor> oh
04:37:26 <Peaker> @let zipUpWith f (x:xs) (y:ys) = f x y : zipUpWith f xs ys ; zipUpWith f xs [] = xs ; zipUpWith f [] ys = ys
04:37:27 <lambdabot>  Defined.
04:37:30 <Peaker> :t zipUpWith
04:37:31 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
04:37:38 <Peaker> :t zipUpWith mappend
04:37:39 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
04:38:26 <Peaker> > zipUpWith mappend [Nothing, Just [1]] [Just [3], Just [7], Just [9]]
04:38:28 <lambdabot>   [Just [3],Just [1,7],Just [9]]
05:09:54 <pithworm> is it possible to get a bit of input on this 51 lines thing i've written?
05:10:12 <pithworm> https://github.com/yuvallanger/wholesale/blob/master/ghc2/wholesale.hs
05:11:03 <pithworm> it's supposed to download a youtube playlist
05:12:14 <aleator> pithworm: What kind of input? (Data.List.Split might make things easier there)
05:12:41 <shachaf> pithworm: downloadVideos = sequence_ downloadVideo
05:12:56 <Peaker> pithworm, run hlint on it...
05:12:58 <pithworm> aleator: it takes a playlist code, like 9740850E3B1B1E04
05:13:12 <pithworm> woot! thanks
05:13:44 <Peaker> pithworm, how come your Haskell code is annotated with types and yet much smaller than the Python version? does the Py one do more?
05:14:07 <pithworm> Peaker: py one is pretty.. uh.. borken
05:14:31 <shachaf> Peaker: It actually makes the HTTP requests and so on instead of using system, for one.
05:14:34 <Peaker> pithworm, I would change playlistURL to be a function rather than a string: playlistURL = ("https://www.youtube.com/playlist?p="++)    that way users don't have to know about where the code is embedded
05:14:36 <pithworm> i have no clue what it was supposed to do as it was a few months ago that i've started working on it
05:14:51 * shachaf has no excuse to be awake.
05:14:53 * shachaf >>= undefined
05:15:06 <pithworm> shachaf: aren't you 15:31?
05:15:30 <Peaker> shachaf, it also uses subprocess like system for the same process
05:15:37 <opqdonut_> @time shachaf
05:15:38 <lambdabot> Local time for shachaf is Wed Apr 20 05:32:42 2011
05:15:40 <opqdonut_> :)
05:15:53 <pithworm> it sounds local
05:15:57 <pithworm> @time pithworm 
05:15:58 <lambdabot> Local time for pithworm is Wed Apr 20 15:33:02 2011
05:15:58 <shachaf> opqdonut_: That's correct but only by sheer coincidence.
05:16:06 <pithworm> "shachaf", that is
05:16:16 <opqdonut_> shachaf: ok
05:16:25 <Peaker> pithworm, your indentation of "where" seems very much off
05:16:30 * ion >>= arbitrary
05:16:41 <shachaf> pithworm: Yes, but I'm in PDT. :-)
05:16:44 <shachaf> Try Peaker for that, though.
05:17:04 <shachaf> Peaker: OK, but it still deals with HTTP and things like that.
05:17:20 <pithworm> i'll now look at each comment of yours one by one
05:17:46 <Peaker> getPlaylistPage playlistCode = do rsp <- simpleHTTP $ postRequest $ playlistURL ++ playlistCode   ;   getResponseBody rsp        can be replaced by:   getPlaylistPage = getResponseBody <=< simpleHTTP . postRequest . playlistURL
05:17:59 <Peaker> shachaf, note this seems to deal with HTTP too
05:18:15 <shachaf> Peaker: Oh, that's true.
05:18:21 * shachaf clearly has no excuse to be awake, as he said.
05:18:24 <Peaker> shachaf, Haskell is just so much nicer than Python I guess :-)
05:18:26 <Peaker> shachaf, night
05:18:31 <pithworm> i'm saving this conversation into the leo file
05:19:01 <Peaker> @type ?f <=< ?g . ?h
05:19:02 <lambdabot> forall b (m :: * -> *) c a a1. (?f::b -> m c, ?g::a -> m b, ?h::a1 -> a, Monad m) => a1 -> m c
05:19:22 <Peaker> pithworm, Do you know the <=< operator?
05:19:33 <pithworm> Peaker: nope, but i'll be happy to learn
05:19:45 <Peaker> @type (<=<)
05:19:46 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:19:49 <Peaker> @type (.)
05:19:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:19:56 <Peaker> Caleskell!!!!!!!!!!!!!
05:20:01 <Peaker> @type (Prelude..)
05:20:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:20:06 <Peaker> @type (<=<)
05:20:06 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
05:20:57 <Peaker> pithworm, note the similarity between (.) and (<=<).. (<=<) is a "play on symbols" on (=<<).  The idea is that =<< chains a wrapped value and a function, and <=< chains two functions that yield wrapped values like (.)
05:21:05 <shachaf> Peaker: Oh, right. You say that (<=<) should be :: (b -> m c) -> f (m b) -> f (m c)? :-)
05:21:52 <Peaker> shachaf, it's easier to fall asleep when not writing Haskell expressions :-)
05:22:14 <shachaf> Oh, right.
05:22:22 <pithworm> question: why do we have >>= and =<<? why a function and its flip?
05:22:34 <Peaker> pithworm, because they are both useful
05:22:49 <Peaker> pithworm, Data pipelines using (.) flow the data right-to-left
05:23:02 <ion> :t \m f -> const m >=> f $ ()
05:23:03 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
05:23:04 <Peaker> pithworm, so it is easier to read:  a =<< b . c =<< d         because you can read in one direction
05:23:21 <pithworm> ah!
05:23:35 <shachaf> Peaker: =<< is more like $.
05:23:39 <shachaf> @ty (=<<)
05:23:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:23:40 <shachaf> @ty ($)
05:23:41 <pithworm> and now.. <=<.. hmm
05:23:41 <lambdabot> forall a b. (a -> b) -> a -> b
05:23:52 <Peaker> Yeah, $ is also compatible with the data going right-to-left
05:23:58 <shachaf> ...I'm still doing it, huh.
05:24:02 <Peaker> pithworm, and >>= is nicer when the order of the "actions" is emphasized, rather than the data flow
05:24:07 * shachaf sleep
05:24:24 <Peaker> pithworm, a >>= b >>= \x -> ...
05:24:36 <Peaker> pithworm, is read like "do a", then "do b", then "do ..."
05:24:53 <Peaker> pithworm, whereas <=< and =<< is read like a pipe-line that happens to also have effects
05:25:38 <Peaker> I once thought it would be better to just have everything reversed so application and (.) and everything is left-to-right
05:25:57 <Peaker> but in a lazy language, that is bad, because the outer-most function application is the most determining of the result, so should appear first
05:27:03 <pithworm> most determining? in what way?
05:27:31 <pithworm> its result will be our result
05:28:01 <pithworm> that way?
05:28:15 <rostayob> is there a way to get the list of all packages on hackage in plain text?
05:28:40 <Peaker> pithworm, consider the function:  ignoreall = const "Awesome"
05:29:02 <Peaker> pithworm, if we had left-to-right pipes:   data $ f1 . f2 . f3 .......................... f4 . ignoreall 
05:29:04 * pithworm tilts his head in perplextion (is that a word?)
05:29:22 <rostayob> maybe without the t
05:29:24 <Peaker> pithworm, the entire thing doesn't matter, ignoreall doesn't evaluate its argument, it just evaluates to "Awesome" all the time
05:30:20 <Peaker> pithworm, I just noticed downloadVideos
05:30:32 <pithworm> ya, it's... uh.. yeah
05:30:35 <pithworm> it's youtube-dl
05:30:45 <Peaker> pithworm, downloadVideos = mapM_ downloadVideo
05:31:15 <Peaker> shachaf previously wrote sequence_ instead of mapM_, I see
05:32:12 <Peaker> main = do playlistCode <- getLine ; videosCodeList <- getPlaylistVideoCodes playlistCode ; downloadVideos videosCodeList        TO:    main = mapM_ downloadVideo =<< getPlayListVideoCodes =<< getLine
05:32:21 <Peaker> pithworm, so it's a cute one-liner :-)
05:32:34 <Peaker> pithworm, and downloadVideos becomes trivial enough you don't need it defined separately
05:33:11 <Peaker> pithworm, commas and splitAtList exist in Data.List.Split, probably
05:33:20 <Peaker> pithworm, you there? :-)
05:33:30 <pithworm> i'm kinda sleep deprived
05:33:41 <pithworm> i'm copypasting this whole conversation for later grokking
05:36:39 <pithworm> how do you call it in coding when you take a bunch of code, cut out a bad part and replace it with something equivalent that works better?
05:37:12 <morphles> refactoring?
05:37:25 <Entroacceptor> I call it that, too
05:38:00 <pithworm> ah, sounds like that's how it's called
05:38:05 <rostayob> refactoring is moving and renaming stuff to me
05:38:45 <morphles> or you can call it improving code :D
05:39:07 <pithworm> morphles: you're talking sense
05:39:59 <Entroacceptor> "Code refactoring is "a disciplined way to restructure code",[1] undertaken in order to improve some of the nonfunctional attributes of the software."
05:40:42 <Entroacceptor> mhm
05:41:03 <Entroacceptor> so if "working better" actually fixes problems, it would be bugfixing 
05:43:00 <rostayob> no but even if working better == more efficient code, i wouldn't call it refactoring
05:43:02 <rostayob> but whatever
05:47:14 <HugoDaniel> :)
05:49:21 <Entroacceptor> rostayob: ok, call it premature optimization, then ;)
06:14:47 <nerolynx> evening #haskell
06:18:05 <HugoDaniel> yo nerolynx 
06:18:09 <nerolynx> I recently did a term renaming function as a homework problem, the idea is rename a list of terms such as [x, f(y), f(x,g(x))] into [var1, f(var2), f(var3, g(var3))] where the function must increment the numeral var'x' with each input term, but smart enough to replace the same variable name within the term using the same name
06:18:13 <nerolynx> hi Hugo
06:18:42 <nerolynx> but I think my code is pretty messy and inefficient
06:18:43 <nerolynx> so it would really help if #haskell is interested in helping me improving it
06:18:53 <nerolynx> link http://hpaste.org/45883/renaming_function
06:19:06 <Axman6> hmm, i thought the first guy that came in sounded like he was asking a homework question
06:19:06 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
06:19:20 <Axman6> at least you were honest enough to tell us it is...
06:19:34 <Axman6> oh god, underscores >_<
06:19:35 <nerolynx> haha me?
06:19:36 <nerolynx> :P
06:19:49 <nerolynx> oh well, I like Camels :D
06:20:00 <nerolynx> sorry for the horrible underscore Axman
06:20:04 <mauke> nerolynx++  # underscores
06:20:05 <Axman6> i would recommend you use thme then ;)
06:20:23 <opqdonut_> oh, wow, quickcheck is 10 years old
06:20:34 <opqdonut_> (orig. article from '00: http://portal.acm.org/citation.cfm?id=351266 )
06:21:12 <nerolynx> the idea is building a dictionary of variable name in each term
06:21:15 <Axman6> nerolynx: yeah... looks pretty horrible. this is actually something that's very easy
06:21:24 <nerolynx> :P
06:21:36 <Axman6> you need to keep track of two things, the mappings you've already made, and the number you're up to
06:21:38 <nerolynx> sorry, i think I still think in imperative
06:21:41 <nerolynx> :(
06:22:10 <nerolynx> hmm
06:22:31 <nerolynx> so how do I keep track of it without the mess?
06:22:52 <Axman6> so, start out with a function that's something like: getName :: String -> (Int, [(String, Sting)]) -> (String, (Int, [(String, Sting)]))
06:23:49 <Axman6> hmm, that type looks horrible, nut all it is is a function that takes a string and the current state of the program, and returns the new name, based on the state you gave it, and a new state, which may or may not be the same state
06:24:21 <nerolynx> hmm
06:24:32 <nerolynx> I am slightly confused
06:25:40 <nerolynx> from the signature the idea is VarName  -> IntIncrement , (VarName, Replacment VarName) -> output the new state is it?
06:26:16 <Axman6> that function would look something like: getName str (n,mappings) = case lookup str mappings of Nothing -> ("var" ++ show n, (n+1, (("var" ++ show n) : mappings))); Just x -> (x, (n, mappings))
06:27:08 <Axman6> hmm, seesm this could be a very nice place to use the state monad
06:27:29 <Axman6> though, if this is homework, you've probably never seen the state monad... so we'll skip that =)
06:28:02 <nerolynx> we did cover the beginning of state monad
06:28:21 <nerolynx> though for the context of this homework, it is not required :|
06:28:29 <Axman6> anyway, when you run getName "a" (0,[]), it would give you back: (1, [("a","var0")])
06:28:47 <nerolynx> ohh
06:29:01 <Jafet> Use camelCase! Or we will shoot!
06:29:07 <Axman6> seems this is a perfect place to use the state monad then
06:29:40 <Axman6> argh, and DO NOT USE TABS!
06:30:21 <nerolynx> sorry, I switch to NotePad, half-way from vim :P
06:33:43 <nerolynx> Axman6: about the state monads, could you give me a hand on example in this question?
06:34:06 <Axman6> will do, working on it now (because I've finally found a good place to use the state monad!)
06:34:26 <HugoDaniel> is there a quick way to time the execution of a function in ghci ?
06:34:37 <Axman6> :set +s
06:34:41 <nerolynx> thanks, Axman6
06:38:02 <Jafet> @quote executes
06:38:02 <lambdabot> Jafet says: In soviet russia, State safely executes you
06:39:58 <mm_freak> lol
06:40:26 <Twey> Haha, a proper Soviet Russia joke
06:40:34 <Twey> Been a while since I saw one of those
06:40:34 <mm_freak> Axman6: you really had to look for places to use a (not "the") state monad in?
06:40:46 <mm_freak> almost 50% of my code runs in a StateT
06:41:06 <Axman6> yeah, I've found more uses for StateT than State
06:41:10 <Axman6> but this is perfect
06:41:35 <mm_freak> i don't knowâ¦  i almost always found explicit passing easier than State
06:41:37 <Twey> Monads are just inferior versions of monad transformers anyway.
06:41:48 <Twey> I've only recently started using State
06:42:14 <Twey> It's a good thing if you do the âbig stack o' monadâ programming style
06:42:22 <mm_freak> Twey: monads are the results of monad transformers
06:42:26 <mm_freak> hence "transformer" ;)
06:42:45 <Twey> Indeed :Ã¾
06:42:49 <Twey> Well
06:42:53 <Twey> Is that whence âtransformerâ?
06:43:05 <Twey> I thought it was âtransformerâ because it transformed one monad into another
06:43:14 <mm_freak> sort of
06:43:16 <sipa> it does
06:43:42 <mm_freak> "StateT s (Cont r)" transforms a stateful computation to a CPS computation
06:43:51 <mm_freak> so it sort of transforms StateT into Cont
06:44:23 <mm_freak> but two players are involved here:  the type constructor and the running function
06:44:33 <nerolynx> can I ask in Haskell, is there anyway to do /* */ like in C?
06:44:43 <sipa> {-  -}
06:44:45 <mm_freak> the running function is what actually does the tranformation, so it happens at a stage, where "monad" is not meaningful anymore
06:44:58 <nerolynx> ta sipa
06:45:38 <fenfrie> small question, in ghci i can load the module Text.Reges.Posix but when i write a haskell script and want to load it, i get the message that the module could not be found. (i use "import Text.Reges.Posix"). what sould i do?
06:45:48 <mm_freak> but the type makes it clear:  runStateT :: s -> StateT s m a -> m a
06:46:02 <mm_freak> (assuming a not braindead order of arguments) =)
06:46:38 <mm_freak> fenfrie: are you using cabal?
06:46:45 <Jafet> @hoogle Text.Regex.Posix
06:46:46 <lambdabot> module Text.Regex.Posix
06:46:46 <lambdabot> Text.Regex.Posix getVersion_Text_Regex_Posix :: Version
06:46:46 <lambdabot> package regex-posix
06:47:03 <Jafet> @hoogle Text.Reges.Posix
06:47:04 <lambdabot> package regex-posix
06:47:25 <Jafet> Erm
06:47:50 <Axman6> nerolynx: how's this: http://hpaste.org/paste/45883/renaming_function_annotation#p45884
06:48:24 <nerolynx> thanks, I'll get back to you asap
06:48:33 <dafis> fenfrie: do you get the message when you try to compile or when you laod the script into ghci?
06:49:29 <Axman6> nerolynx: actually, it may be wrong, if function names aren't supposed to be renamed. I'll paste a fix (makes the code simpler anyway)
06:49:49 <dmwit> :t mconcat
06:49:50 <lambdabot> forall a. (Monoid a) => [a] -> a
06:50:06 <fenfrie> dafis, i get it there and there
06:50:06 <nerolynx> yup, the function name aren't suppose to be renamed, :D
06:50:18 <dmwit> > mconcat . map (\x -> (Last (Just x), [x])) $ [1..10]
06:50:20 <lambdabot>   (Last {getLast = Just 10},[1,2,3,4,5,6,7,8,9,10])
06:50:34 <mm_freak> fenfrie: if you're using cabal, you need to add the regex-posix package as a dependency
06:50:36 <Axman6> nerolynx: http://hpaste.org/paste/45883/renaming_function_annotation#p45885
06:50:49 <dafis> fenfrie: if you have ghc-6.*, you'd need the --make flag for compiling
06:50:57 <dmwit> Is there a class that has just "return" in it?
06:51:04 <mm_freak> dmwit: nope
06:51:26 <mm_freak> dmwit: people like to call that class "Pointed", but it's not in the base package right now
06:51:37 <mm_freak> Functor â Pointed â Applicative â Monad
06:52:04 <dmwit> hm
06:52:14 <dafis> fenfrie: (i use "import Text.Reges.Posix") <- is that typo in your file?
06:52:14 <fenfrie> mm_freak, i have regex-posix installed with cabal
06:52:16 <mm_freak> dmwit: but Applicative gets close, it has "pure" with pure = return for monads
06:52:23 <dmwit> :t pure
06:52:24 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
06:52:27 <fenfrie> dafis, yes
06:52:31 <dmwit> :t pure :: a -> Last a
06:52:32 <lambdabot>     No instance for (Applicative Last)
06:52:33 <lambdabot>       arising from a use of `pure' at <interactive>:1:0-3
06:52:33 <lambdabot>     Possible fix: add an instance declaration for (Applicative Last)
06:52:38 <dmwit> =/
06:52:41 <mm_freak> fenfrie: use --make, as dafis suggested
06:52:54 <dafis> fenfrie: s/Reges/Regex/ then
06:52:55 <fenfrie> i do ghc -- make script.hs
06:53:15 <Axman6> ghc --make not ghc -- make
06:53:34 <fenfrie> i do
06:53:38 <Yvemath> wow, that is something i dont understand.
06:54:34 <mm_freak> dafis: for Monoid instances you have mempty and mappend
06:55:06 <dafis> mm_freak: bad autocomplete :)
06:55:08 <mm_freak> ok, that doesn't give you the functionality of 'return'
06:56:08 <Axman6> nerolynx: if needed (ie, if you need to do a _lot_ of this stuff, you'd do better to use a Map than a list of String, Int pairs
06:56:24 <Axman6> but the code is almost exactly the same
06:57:56 <mm_freak> dafis: do you want to generalize Last?
06:58:01 <nerolynx> Axman6: hmm I see, I kind of get it once I trace through it, but the code does not conform to the original signature so I'm trying to see how to set it to run :D
06:58:03 <mm_freak> uhm
06:58:09 <mm_freak> dafis: sorry
06:58:18 <mm_freak> dmwit: do you want to generalize Last?
06:58:20 <dafis> mm_freak: np
06:58:20 <Axman6> nerolynx: what signature do you need?
06:58:42 <dmwit> mm_freak: Last . Just, yes
06:58:44 <mm_freak> Axman6: btw, you might want to use proper data structures for your example
06:58:54 <Axman6> mm_freak: huh?
06:59:05 <dmwit> mm_freak: I want to write "return" instead of "\x -> (Last (Just x), [x])". =)
06:59:06 <mm_freak> Axman6: Map instead of list
06:59:12 <nerolynx> just to make sure it works with the show_term test function
06:59:43 <Axman6> mm_freak: i did just say that would be a good idea, i just didn't bother, because it adds a (small) level of complexity to understanding it
06:59:48 <dmwit> mm_freak: And then I want to write "collapse" instead of "mconcat . map return"
06:59:49 <mm_freak> > Last . Just &&& (:[]) $ 15
06:59:51 <lambdabot>   (Last {getLast = Just 15},[15])
07:00:04 <mm_freak> and (:[]) = return
07:00:15 <dmwit> That is not really better.
07:00:29 <dmwit> It is no more abstract.
07:00:48 <Axman6> nerolynx: if you make the signature of renameTerms [Term] -> [Term] and rename runState to execState, then you get what you want i believe
07:01:03 <balor> Is there a shorthand for "union map"?
07:01:16 <mm_freak> dmwit: there is no way to generalize Last in your case, unless you write custom instances for it
07:01:24 <Axman6> nerolynx: but i chose to do it that way so that i could be run mulsiple times using the state from a previous run if needed. it's more flexible
07:01:40 <mm_freak> dmwit: but Last is isomorphic to Maybe
07:01:47 <mm_freak> so you can write a functor and applicative instance
07:02:16 <mm_freak> Axman6: i think that Map makes it actually clearer
07:02:50 <mm_freak> and you help newcomers by recognizing that lists are almost always the wrong choice =)
07:02:51 <Axman6> mm_freak: sure, if you've used Map before. if you've never seen it, it doesn't. I'll rewrite it anyway
07:03:22 <nerolynx_> Axman6: I disconnected, is there anything I missed?
07:03:33 <mm_freak> people often complain about bad code performance in haskell, and when you look at their code, they have used lists for everything
07:03:35 <Axman6> "nerolynx: but i chose to do it that way so that i could be run mulsiple times using the state from a previous run if needed. it's more flexible"
07:04:16 <nerolynx_> Axman6: yup, I can see it's much much better than simply parsing the state only :)
07:04:20 <nerolynx_> soz
07:04:27 <nerolynx_> Axman6: yup, I can see it's much much better than simply parsing the term list only :)
07:04:36 <mm_freak> dmwit: there is also a second solution, which doesn't require extending Last:  an existential type
07:05:32 <dmwit> ?src Applicative
07:05:32 <lambdabot> class Functor f => Applicative f where
07:05:32 <lambdabot>     pure  :: a -> f a
07:05:32 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
07:06:52 <dmwit> type (:*:) f g a = (f a, g a); instance (Applicative f, Applicative g) => Applicative (f :*: g) where pure x = (pure x, pure x); (f, g) <*> (x, y) = (f <*> x, g <*> y) -- ?
07:07:30 <aristid> .oO(people love symmetric operators)
07:07:58 <Jafet> (-:-)
07:08:06 <aristid> dmwit: but isn't that an invalid instance?
07:09:11 <mm_freak> dmwit: you're essentially duplicating the functionality, which is already provided by Arrow
07:09:46 <mm_freak> aristid: the instance is invalid syntacticallyâ¦  you need an extension to allow it
07:09:50 <aristid> mm_freak: i think there's a newtype to make an Applicative out of every Arrow. but i forgot the name
07:10:23 <mm_freak> aristid: i think there can be lots of those newtypes
07:10:29 <aristid> hmm there is ArrowMonad
07:10:43 <dmwit> Duplicating Arrow functionality?
07:10:52 <aristid> but it has no Applicative instance
07:10:53 <nerolynx_> Axman6: Axman, I think there's a bit of misunderstanding in your monad implementation :)
07:10:55 <aristid> (in 6.12)
07:11:21 <mm_freak> dmwit: pure *** pure $ (3, 4) :: ([Int], [Int])
07:11:25 <mm_freak> > pure *** pure $ (3, 4) :: ([Int], [Int])
07:11:26 <lambdabot>   ([3],[4])
07:11:36 <aristid> Axman6: Bynbo7: Czocp8
07:11:58 <Axman6> nerolynx_: do you only want the variables in a single element of test renamed? that's a simple enough fix
07:12:04 <dmwit> mm_freak: Arrows don't let me write a function like "collapse" that can have either "collapse :: [a] -> First a", "collapse :: [a] -> Last a", or "collapse :: [a] -> (Last a, [a])".
07:12:11 <dmwit> So, no, I don't think I'm duplicating functionality.
07:14:20 <mm_freak> dmwit: why would you convert a list to a First/Last?
07:14:44 <dmwit> mm_freak: If I wanted the first or last element, of course.
07:14:52 <mm_freak> :t head
07:14:53 <lambdabot> forall a. [a] -> a
07:14:54 <mm_freak> :t last
07:14:55 <lambdabot> forall a. [a] -> a
07:15:01 <dmwit> mm_freak: Not polymorphic enough.
07:15:17 <dmwit> mm_freak: I want any monoidal measure.
07:15:38 <dmwit> *in one pass*
07:15:44 <dmwit> So that it has good GC characteristics.
07:15:49 <mm_freak> i don't know exactly what you mean by that, but that sounds like a job for Traversable
07:16:31 <dmwit> Yes, Traversable would generalize from lists to other structures.
07:16:44 <dmwit> That would be cool, too, though I haven't (yet) needed it.
07:18:29 <mm_freak> dmwit: you can easily express head and last in terms of foldr and foldl
07:18:40 <mm_freak> Traversable generalizes folds
07:18:49 <mm_freak> :t Data.Traversable.foldr
07:18:49 <lambdabot> Not in scope: `Data.Traversable.foldr'
07:18:55 <mm_freak> :t T.foldr
07:18:56 <lambdabot> Couldn't find qualified module.
07:19:07 <mm_freak> whatever
07:19:09 <dmwit> Yes, I know I can. I've done it.
07:19:20 <dmwit> And now, as an academic, I'm wondering how to generalize the pattern I see.
07:19:32 <dmwit> And I think I've found one; why are you so adamant that the pattern I've found is no good?
07:19:34 <mm_freak> oh, it's called 'traverse' now
07:20:28 <mm_freak> perhaps i don't understand your application
07:21:05 <aristid> dmwit: because the zoo of patterns should be reduced to those that are sufficiently fundamental :P
07:21:07 <mm_freak> but anyway, in fact, the clean approach is to write instances for First and Last
07:21:47 <mm_freak> you wanted a 'pure' for Last, and it's there, if you recognize that Last is isomorphic to Maybe
07:22:22 * dmwit nods at both aristid and mm_freak
07:22:50 <aristid> mm_freak: i still think it's a mistake that the Monoid instance for Maybe does not coincide with its MonadPlus/Alternative instances
07:23:08 <mm_freak> aristid: why should it?
07:23:54 <aristid> mm_freak: because then i can make an arrow from Monoid to MonadPlus in my mental model.
07:24:07 <aristid> where arrow doesn't mean anything category-theoretical :P
07:24:29 <mm_freak> aristid: that arrow doesn't existâ¦  look at the types
07:24:59 <mm_freak> an arrow in the other direction may exist, but it does not make sense in general to have Monoid based on Alternative
07:25:19 <mm_freak> (or her redundant brother MonadPlus)
07:25:44 <aristid> mm_freak: arrow can mean many things. if you say that the arrow in the opposite direction may exist, that means i just meant the opposite kind of arrow :P
07:25:57 <mm_freak> lol
07:27:19 <mm_freak> instance Monoid (Alternative a) where mempty = empty; (<|>) = mappend
07:27:24 <mm_freak> but i wouldn't want that instance
07:27:30 <mm_freak> uhm
07:27:31 <mm_freak> wait
07:27:37 <balor> Is it poor style to give data constructors the same name as the data type?
07:27:47 <mm_freak> instance Alternative f => Monoid (f a) where mempty = empty; (<|>) = mappend
07:28:02 <aristid> mm_freak: the instance is dangerous because it involves no type constructor
07:28:07 <mm_freak> balor: in general no
07:28:19 <balor> mm_freak, thanks
07:28:48 <aristid> mm_freak: but: it would be nice if the default would be to have Monoid instance that coincide with this one
07:28:58 <mm_freak> aristid: i knowâ¦  that's one of the reasons why i wouldn't want it =)
07:29:43 <aristid> so Maybe's Alternative should coincide with Maybe a's Monoid, same for [] and so on...
07:29:50 <mm_freak> it wouldn't be nice IMO, because there is already one contradicting instance:  Alternative and Monoid instances of lists have very different semantics
07:29:52 <aristid> @instances Alternative
07:29:52 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
07:30:08 <aristid> mm_freak: oh, true.
07:30:20 <mm_freak> > "abc" <|> "def"
07:30:21 <lambdabot>   "abcdef"
07:30:26 <mm_freak> uhm
07:30:31 <dblhelix> @instances Control.Applicative.Alternative
07:30:32 <lambdabot> Either e, Maybe, []
07:30:47 <aristid> mm_freak: wait it looks like they DO coincide :)
07:31:45 <mm_freak> indeed
07:31:56 <mm_freak> i had something different in mindâ¦  strange
07:32:08 <aristid> mm_freak: somehow i was thinking of zip lists... :D
07:32:23 <mm_freak> i was thinking of cartesian products
07:32:43 <aristid> liftA2 (,)?
07:32:53 <mm_freak> yeah, something like that
07:32:58 <aristid> heh.
07:33:15 <mm_freak> and it wouldn't even make sense =)
07:40:03 <neophyte> what is a good introductory text to complexity theory? I've been reading sipser, and want to learn more about the subject
07:41:04 <paolino> balor: newtype constructor
07:41:42 <paolino> or one constructor datatype
07:47:53 <fenfrie> small question, i have a function with do notation and it opens a file and read out the content, at the end i make: return content, but how can i make a hClose, when i do it before, i dont get any return, and after the return it exits
07:49:06 <Axman6> return isn't like return in C or Java, if you say fo = do {x <- y; return x; x} then the line return x actually doesn't do anything at all
07:49:56 <dafis> fenfrie: use bracket or, simpler, readFile
07:50:04 <Axman6> :t readFile
07:50:05 <lambdabot> FilePath -> IO String
07:53:05 <fenfrie> dafis, what is a braket?
07:53:15 <Axman6> :T bracket
07:53:17 <dafis> :t bracket
07:53:18 <lambdabot> Not in scope: `bracket'
07:53:25 <fenfrie> readFile is simpler but i want to do it on my own :)
07:53:27 <Axman6> @hoogle bracket
07:53:27 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:53:28 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:53:28 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:53:33 <dafis> :t Control.Exception.bracket
07:53:34 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:53:48 <quicksilver> fenfrie: well, you should probably realise it's only a problem becuase hGetContents is broken.
07:54:13 <quicksilver> do { h <- openFile "blah"; x <- hGetContents h; hClose h; return x} *should* be fine
07:54:20 <Axman6> fenfrie: bracket is a function which is used when you need to1: acquire a resource, 2) process that resource, 3) make sure that the resource is cleaned up, no matter how the processing goes
07:54:25 <quicksilver> it would be fine for anything other than hGetContents and a couple of similar functions.
07:54:35 * kowey wonders if http://www.haskell.org/haskellwiki/Haskell_User_Group would be a good idea
07:54:48 <kowey> a small, focused starter pack for new Haskell User Groups
07:55:06 <kowey> try these exercises! ooh read these papers! etc
07:55:31 <Eduard_Munteanu> Whoa, hGetContents is broken? (just stepped in)
07:55:38 <Eduard_Munteanu> Or just the normal lazy I/O complaints?
07:55:47 <dafis> Eduard_Munteanu: at least it's tricky
07:56:07 <fenfrie> quicksilver, no this return always a empty string
07:56:17 <dafis> Eduard_Munteanu: those complaints are not completely unfounded
07:56:37 <Eduard_Munteanu> Yeah, I know.
07:56:49 <quicksilver> fenfrie: yes. because hGetContents is broken.
07:56:50 <dafis> fenfrie: that's because you exit the action before the file is actually read, that's the tricky part
07:56:53 <quicksilver> fenfrie: it should work.
07:57:01 <quicksilver> fenfrie: what you wrote was logical, sensible, and correct haskell.
07:57:10 <quicksilver> it's not your fault that hGetContents is anomalously broken.
07:57:26 <quicksilver> hGetContents defers the actual reading until later, and then hClose cuts it off.
07:57:27 <fenfrie> okay
07:57:33 <quicksilver> but this is not typical haskell behaviour
07:57:36 <quicksilver> it's quite nasty, really.
07:59:15 <fenfrie> last question: how can i make a regex like: readFile "foo.txt" =~ "foo" :: Bool
07:59:29 <fenfrie> this couses a error because its a IO String and not a String
08:00:19 <parcs> do { contents <- readFile "foo.txt"; return (contents =~ "foo" :: Bool) }
08:01:38 <fenfrie> is contents <- readFile "foo.txt" automatically convertet to a string?
08:01:54 <xplat> 14:03 < megajosh2> sml.org: what you need, when you need it
08:01:58 <parcs> in a wayâ¦
08:02:05 <xplat> i hate that placeholder SO MUCH
08:02:32 <xplat> it is exactly NOT what i need, what i need is the site that used to be there
08:02:52 <parcs> whenever you do blah <- action you "convert" an IO a to an a and bind it to blah
08:03:10 <fenfrie> parcs, okay thx
08:07:41 <paolino> quicksilver: what hClose should do instead of closing h and cutting off x ?
08:08:00 <BorisL> hi all. When playing with the functional dependencies I encountered a strange error http://hpaste.org/45875/functional_dependencies Can you explain why it happens?
08:11:22 <quicksilver> paolino: hClose isn't broken. hGetContents is.
08:12:05 <paolino> I cannot see what it's broken, sorry.
08:12:22 <quicksilver> because it caused the discussion above.
08:12:27 <quicksilver> because it doesn't do what it claims to do.
08:12:39 <paolino> ah, the name 
08:12:47 <quicksilver> openFile ; hGetContents ; hClose should work
08:12:52 <quicksilver> it's a perfectly sensible sequence
08:12:58 <aristid> hGetContents should simply be strict :)
08:13:11 <quicksilver> NOBODY would guess, without knowing, that hGetContents secretly defers the work in such a way that hClose will ruin it.
08:13:25 <quicksilver> it should be called hDeferredGetContents or something.
08:13:39 <quicksilver> aristid: avoid using the word strict, because this isn't a strict/lazy issue.
08:13:49 <quicksilver> it's normal IO semantics versus 'interleaved' IO.
08:13:59 <paolino> that's why I said hClose can be wrong
08:14:03 <dafis> hGetContentsIfYouDon'tCloseTheFileTooEarly
08:14:05 <quicksilver> :)
08:14:15 <quicksilver> paolino: of course you're right, that that is one way to fix the problem.
08:14:22 <quicksilver> but hClose isn't anomalous. It works normally enough.
08:14:40 <quicksilver> hGetContents is anomalous - it couldn't be implemented with compiler internals or unsafe functions.
08:15:09 <zygoloid> hUnsafeInterleavedGetContents
08:16:14 <Silvah> quicksilver: so how should it be implemented instead? I mean, how its code should look like? I *mean*, could you give a working implementation?
08:16:33 <paolino> hGetContents :: FD -> IO (String, IO ()) ?
08:17:20 <dafis> Silvah: do { !bs <- Data.ByteString.ReadFile foo; return (decode bs); }
08:17:45 <zygoloid> hSafeGetContents h = do s <- hGetContents h; evaluate (length s); return s
08:17:55 <dafis> should've been readFile of course
08:18:33 <paolino> zygoloid: youare making it more strict
08:18:48 <aristid> Silvah: iteratees! :)
08:19:04 <zygoloid> paolino: right!
08:20:24 <paolino> aristid: that could be good, haskell abandon lazy IO for iteratees
08:21:31 <paolino> then we can answer with "are you sure you really want to read that file ?"
08:21:47 <Phyx-> n
08:23:25 <aristid> paolino: *sigh* i don't know an abstraction that is superior to iteratees
08:24:05 <paolino> at least you know that so you are ready to hMunchFile
08:24:56 <tehgeekmeister> anyone heard any news about typeclassopedia 2?  i remember seeing a blog post announcing it'd be coming out somewhat soon.
08:25:44 <paolino> ... reading a file is for intermediate users
08:25:44 <Jafet> Sometimes I feel that I should discard the convenient abstraction of lazy interleaved IO in favour of explicitly scheduled IO. But that invariably gives way to ulimit -n
08:26:21 <ash_> is there a way to o manual memory management in haskell? i know in most functional languages that is not really easily managed 
08:27:57 <Jafet> @hoogle alloc
08:27:57 <lambdabot> module Foreign.Marshal.Alloc
08:27:57 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
08:27:57 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
08:28:38 <c_wraith> Heh.  the FFI stuff gives manual memory allocation, but it's clumsy if you're not actually doing FFI
08:29:49 <ash_> just curious, i have been thinking about why a lot of embedded platforms don't have any functional language support and memory management seems to be the biggest hurdle 
08:30:12 <c_wraith> haskell actually has great embedded platform support...  Just in a sort of roundabout way.
08:30:19 <c_wraith> via things like the Atom package
08:30:44 <c_wraith> Which provides an embedded DSL for generating C code specifically designed to run in embedded environments.
08:39:57 <ash_> i have looked at atom and I found it a bit odd for some embedded cases, like if you have to deal with interrupts it has no way of handling volatile variables
08:43:54 <Jafet> "Long viewed as an important theoretical idea, functional programming finally became truly convenient and practical with the introduction of Mathematica's symbolic language..."
08:45:01 <ash_> for me this is more of a thought exercise, just thinking about it more than anything else
08:45:33 <luite> Jafet: was that written by stephen wolfram? :p
08:46:10 <vermeille> Hail all !
08:46:21 <crystal-cola> b,
08:46:24 <crystal-cola> hi
08:46:27 <dafis> Hailt to thee Thane of Glamis
08:46:32 <dafis> *Hail
08:46:32 <Axman6> Jafet: have you ever used the FP stuff in mathematica? it's fuckoing atrotious
08:46:52 <vermeille> Is there anybody under Arch Linux who is using the haskellmode for vim ?
08:47:03 <Jafet> (From guide/FunctionalProgramming)
08:47:42 <vermeille> the au Bufenter *.hs compiler ghc in my .vimrc gives me an E666 error when I open a .hs file (ghc not supported)
08:47:44 <Guest99387> hi, ido you guys know a way to programmticly change the wallpaper in Windows? 
08:47:50 <Jafet> luite: if it wasn't written by him, it was written for him!
08:48:00 <luite> even better ;p
08:48:17 <Guest99387> in Ubuntu i just use gconf
08:50:44 <vermeille> No one for my vim issue ?
08:52:07 <edwardk> vermeille: most folks just set up a cabal project rather than compile .hs files directly, so you're a bit off the beaten path
08:53:49 <vermeille> I'm a totally newbie in Haskell, I don't really know how to process to work good in Haskell, am I doing it in a wrong way edwardk ?
08:54:45 <neurocyte> vermeille, for vim to understand the 'compiler vim' command you need ghc support in your ~/.vim/compiler directory
08:55:19 <rostayob> if I get something out of a ReaderT with ask, will it actually get the stuff each time or will it get it just once? I'm asking that since I've had performance problem with monad transformers, while it seems to optimize it with simple monads
08:55:50 <vermeille> I have a ghc.vim file in my /usr/share/vim-script/haskellmode/ghc.vim
08:56:15 <neurocyte> vermeille, I doubt vim looks there
08:56:31 <vermeille> okay, I cp and retry
08:56:51 <neurocyte> vermeille, you can add that dir to your vim path
08:57:30 <edwardk> vermeille: am i correct in guessing that you are trying to follow the instructions from http://projects.haskell.org/haskellmode-vim/ ?
08:57:35 <vermeille> Apologize, I'm not really good in the Linux world =/
08:58:14 <vermeille> edwardk: Yeah, you're right
08:58:21 <neurocyte> vermeille, see ':help runtimepath' in vim
08:59:44 <Phyx-> Guest99387: It's a registry value under HKCU\Control Panel\Desktop. after you change it you need to call SHChangeNotify
08:59:50 <Phyx-> oh he's gone
09:01:20 <lpsmith> Axman, I love how Mathematica is dynamically scoped unless you wrap every variable in a Module[...] expression.
09:01:28 <lpsmith> :-P
09:01:58 <vermeille> neurocyte: Do I have to edit this file to add my path or is that a doc ?
09:03:17 <vermeille> Okay, I found, thx :)
09:03:22 <neurocyte> vermeille, you have to edit your ~/.vimrc and add a 'set runtime=....' command
09:03:35 <neurocyte> sorry, set runtimepath=...
09:04:11 <neurocyte> debian has a pretty funky way of installing vim plugins...
09:07:24 <vermeille> neurocyte: It just killed my coloration by overriding default runtimepath
09:07:55 <neurocyte> err, yeah, sorry. you need to *add* that path to the runtimepath
09:08:32 <neurocyte> to see the current runtimepath type ':set runtimepath?'
09:09:34 <vermeille> no matter guy, I'll just copy the directory in my .vim :)
09:09:43 <vermeille> I don't want to bother you
09:12:57 <vermeille> dd 
09:13:57 <vermeille> neurocyte: thx for your help, everything works well :) !
09:14:16 <neurocyte> vermeille, no problem
09:24:19 <hai> is there a function in haskell to do what SystemParametersInfo (c#) does ? It uses user32.dll in c#.
09:24:56 <mauke> hah
09:26:11 <tensorpudding> does glade support gtkbuilder?
09:26:41 <Phyx-> hai: not sure what the Win32 package provides, but you could just use FFO to call SystemParametersInfo itself
09:27:15 <hai> phyx- how?
09:27:54 <Phyx-> hai: http://haskell.org/haskellwiki/GHC/Using_the_FFI#GHC_and_DLLs
09:28:27 <hai> thank you
09:29:00 <Twey> http://hackage.haskell.org/packages/archive/Win32/2.2.0.2/doc/html/src/Graphics-Win32-Misc.html#messageBox for a simple example
09:30:54 <Phyx-> heh, did I just call it FFO?
09:34:51 <vermeille> I leave, ++ and thx you all :)
09:55:33 <Kaidelong> something looks deeply impure about "a -> IO b" to me
09:56:28 <Kaidelong> even though I've heard people say that stuff of that form is pure because the effect is encapsulated in the type system
09:56:39 <Kaidelong> but where does it get the world from
09:57:00 <Jafet> What has that type?
09:57:07 <Kaidelong> @hoogle a -> IO b
09:57:08 <lambdabot> Control.Exception evaluate :: a -> IO a
09:57:08 <lambdabot> Control.OldException evaluate :: a -> IO a
09:57:08 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
09:57:15 <Kaidelong> @ty return
09:57:16 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:57:23 <Kaidelong> @ty putStrLn
09:57:24 <lambdabot> String -> IO ()
09:57:33 <c_wraith> none of those are as polymorphic as you implied
09:57:50 <c_wraith> be careful saying things like "a -> IO b", as haskell implies implicit foralls on a and b
09:58:12 <Kaidelong> a -> IO b is a more general type than any of those types
09:58:23 <c_wraith> It's more polymorphic.
09:58:28 <Jafet> Where did you find a -> IO b, then?
09:58:31 <c_wraith> That doesn't mean more general
09:58:45 <c_wraith> more polymorphic means the possible implementations are actually restricted more
09:59:10 <Kaidelong> to achieve a type like a -> IO b that cannot be specialized any further
09:59:19 <Kaidelong> but something that takes a parameter of (a -> IO b)
09:59:26 <Kaidelong> could take "String -> IO ()"
09:59:39 <c_wraith> yes, but then it's a part of a larger type signature
09:59:51 <c_wraith> forget IO for a minute.
09:59:53 <Jafet> You're still not making sense
10:00:12 <c_wraith> How many different types of functions can you write with the type "a -> Int" ?
10:00:29 <Kaidelong> as many as there are types available to think about
10:00:32 <c_wraith> Nope.
10:00:45 <Kaidelong> unless you want a type exactly a -> Int
10:00:50 <c_wraith> all the functions with type "a -> Int" are of the form "const <some integer>"
10:00:59 <Kaidelong> but I was talking about the set of all types generalizable to a -> IO b
10:01:03 <crystal-cola> @free a -> Int
10:01:03 <lambdabot> Extra stuff at end of line
10:01:40 <Kaidelong> anyway this is completely off topic
10:01:45 <c_wraith> No, it's entirely the point.
10:02:00 <c_wraith> Since you seem to think unconstrained types are the same as constrained types.
10:02:30 <Kaidelong> how does return's type make return a pure function then?
10:03:02 <hpc> Kaidelong: "pure" means it doesn't violate referential transparency
10:03:13 <hpc> all haskell functions are like this, except the "unsafe" ones
10:03:38 <Kaidelong> hpc: but how does it put something in the context of the real world without knowing what the real world is
10:03:39 <c_wraith> It doesn't.  Types are not directly related to purity.  They just help organize things.
10:04:16 <c_wraith> Kaidelong: if you're specifically talking about IO, you can treat it as referential transparency by considering that IO actions are *actions*, not the results of the action.
10:04:46 <c_wraith> all that haskell describes is how to evaluate what an action is.  The process of actually executing the action is outside the scope of the language.
10:05:00 <c_wraith> But this is a very narrow view, that only applies to IO.
10:05:31 <c_wraith> ..  Well, non-IO values can't be executed anyway.  (Ok, ST, but ST is a special case of IO)
10:06:37 <Kaidelong> c_wraith: but how you turn a value into an action is going to depend on the implementation
10:06:50 <c_wraith> no it's not.
10:07:10 <c_wraith> look at return.  The semantics are "an action that when executed results in the value passed to return"
10:07:17 <c_wraith> the implemenation really doesn't matter.
10:07:32 <c_wraith> *implementation
10:08:29 <c_wraith> The fact that GHC implements IO by passing a RealWorld value around isn't relevant to the semantics of IO.  And it's not the only possible implementation.
10:09:03 <Kaidelong> that's just the thing though. How do you know what IO's return does without knowing how IO is implemented?
10:09:16 <c_wraith> It's specified.
10:10:05 <c_wraith> Between the type and the monad laws, return must give back the same value it was given, and perform no other actions.
10:10:17 <Kaidelong> or by analogy. putStrLn will probably not do the same thing on an old cell phone that it does on a command line
10:10:37 <Kaidelong> the action it returns will do something different
10:10:48 <c_wraith> it will do what it's specified to do, on that platform.
10:11:22 <c_wraith> on a platform without a console (well, with the console hidden), putStrLn is mostly a no-op, except it might slow things down by writing to a buffer that may not be used
10:12:15 <c_wraith> I mean, just about any GUI app on any platform that's not intended to be run from the console dumps tons of output to the console...  Usually that output is just ignored.
10:12:16 <Kaidelong> so why do people say putStrLn is pure if you could use it to expose the environment (basically get something of type IO)
10:12:29 <c_wraith> How does it expose the environment.
10:12:30 <c_wraith> ?
10:12:47 <c_wraith> How do you know, within the program, what putStrLn did?
10:13:17 <c_wraith> And more importantly, you seem to have the wrong idea about purity anyway.
10:13:33 <c_wraith> purity is not a description of what happens when an IO action is executed.
10:13:44 <c_wraith> purity is a description of what happens when a function is evaluated.
10:14:03 <Kaidelong> I was using the definition that a pure function always returns the same result for the same input
10:14:07 <c_wraith> No matter how many times you evaluate putStrLn "foo", you will get back the same IO action.
10:14:23 <Kaidelong> something of the form IO a -> IO b that seems reasonable to say
10:14:34 <c_wraith> Back up.
10:14:45 <c_wraith> read my last statement again.  execution is not evaluation.
10:14:53 <c_wraith> purity describes evaluation
10:16:17 <monochrom> getLine equals getLine
10:16:45 <Kaidelong> monochrom: for every possible implementation of Haskell?
10:16:55 <Kaidelong> as in
10:17:06 <Kaidelong> getLine will always be the exact same action
10:17:17 <monochrom> yes
10:17:32 <c_wraith> Kaidelong: not across implementations.  But within implementations.
10:17:45 <c_wraith> There are many parts of haskell that are allowed to be implementation specific.
10:17:49 <Kaidelong> within implementations I have no trouble accepting stuff in the form of "a -> IO b" is pure
10:17:52 <c_wraith> like the value of maxBound :: Int
10:18:05 <monochrom> let a = ()
10:18:21 <Kaidelong> which I guess is all that people mean when they say it is pure
10:18:48 <c_wraith> yes, the language has implementation-specific behavior.
10:18:58 <c_wraith> That's explicitly allowed in many places.
10:19:02 <c_wraith> > maxBound :: Int
10:19:03 <lambdabot>   9223372036854775807
10:19:18 <c_wraith> Is that what you get from that expression on your system?
10:19:41 <Kaidelong> no it is not
10:20:06 <c_wraith> and it doesn't involve IO.  or even functions.
10:20:26 <c_wraith> Int has a minimum range required by the spec, but that's all
10:20:31 <Kaidelong> but it makes the value of an expression including maxBound implementation dependent
10:20:56 <Kaidelong> thus you could use it to get information on the implementation
10:20:57 <c_wraith> maxBound isn't even necessary
10:21:05 <c_wraith> > 2 ^ 32
10:21:06 <lambdabot>   4294967296
10:21:13 <c_wraith> > 2 ^ 32 :: Int
10:21:14 <lambdabot>   4294967296
10:21:28 <c_wraith> on a 32-bit system with ghc, that's going to be a negative number.
10:21:49 <hpc> > 2 ^ 32 :: Int32
10:21:49 <lambdabot>   0
10:21:56 <c_wraith> or I suck :)
10:22:05 <hpc> :)
10:22:33 <c_wraith> But yes, purity is not the same thing as "all behavior is specified, regardless of platform"
10:22:58 <illissius`> this might be a lazy way to think, but the way I like to think about purity vs. impurity is whether the given thing breaks laziness
10:23:14 <illissius`> if you put the thing in a thunk, and only evaluate it later, is the result always going to be the same?
10:23:44 <illissius`> there's probably a mathematical term for this property but I'm forgetting it
10:24:13 <crystal-cola> illissius`: functional
10:24:39 <mauke> referential transparency?
10:24:40 <illissius`> (incidentally, I'm not really sure about things which don't break laziness within a given run of a program, but might be different between runs.)
10:24:55 <monochrom> yes, they call it referential transparency, you can evaluate the thing any time, several times, always same answer
10:26:25 <illissius`> I'm thinking of "the thing is $word with respect to when you evaluate it / changing its time of evaluation" (and i think there's another more mathematical term for "changing" there)
10:26:35 <illissius`> or something like that
10:33:19 <illissius> i had expected people to take exception to my lazy way of thinking :d (or is it that i'm not the only one who's unsure about the within-a-run/across-runs thing?)
10:37:43 <illissius> 'invariant' might've been the word i was looking for.
10:37:58 <illissius> (there might've been more than one word.)
10:49:13 <beastaugh> has anyone got to the bottom of the haddock-docs-on-hackage-not-building issue yet?
10:49:46 <monochrom> no
10:52:58 <hepek> have you guys ever used Codec.Image.DevIL under Ubuntu
10:53:02 <hepek> ?
10:53:54 <c_wraith> hepek: I haven't, but what errors are you getting?
10:53:54 <lispy> beastaugh: you should ask in #hackage (pretty much everyone there is active here, but I think they're more likely to see your question if you aks there)
10:54:20 <hepek> first of all, it cannot load libpthread.so
10:55:02 <hepek> apparently libpthread.so is a ld script
10:55:05 <hepek> that references
10:55:22 <hepek> shared and static versions of libpthread
10:55:52 <hepek> when I substitute it with a shared version of the file i get segfault in ghci when loading images
10:56:49 <c_wraith> did you try the static version?
10:57:04 <c_wraith> I don't know why anything has a reference to libpthread, though
10:57:13 <narens> Hi! I have a test executable that builds with cabal, but so far I only test exposed function, but I'd like to also test functions that are not exposed... what's the best way to go about doing this?
10:58:00 <c_wraith> narens: there's no good solution to that yet.  What I've ended up doing is just exposing all the modules, and documenting that some should only be used if you know exactly what you're doing.
10:58:21 <narens> c_wraith: Hmm, that is a disappointment.
10:58:44 <c_wraith> narens: I find that's a bit more useful to power-users anyway...  When you need it, all the implementation details are available.
10:59:23 <narens> c_wraith: Alright, then I shall go with that approach for now. Thanks.
10:59:56 <c_wraith> It's possible cabal test will eventually cover that case, handling making non-exported modules in scope for test programs.
11:00:07 <c_wraith> But I don't think anyone has done work on that yet
11:00:10 <dcoutts> that should work
11:00:19 <dcoutts> the test exe can import the modules directly
11:00:25 <dcoutts> rather than depending on the library
11:00:32 <c_wraith> I suppose that's true.
11:00:36 <dcoutts> (it means those modules will be built twice)
11:00:47 <hepek> c_wraith, how do I use static version? I installed DevIL via cabal
11:01:05 <narens> dcoutts: what's this about text exe importing modules directly?
11:01:31 <c_wraith> hepek: I meant "of libpthread", but really I doubt that will work.  This sounds like something is messed up in the C bindings.
11:02:06 <c_wraith> hepek: or at least in the build process
11:02:08 <hepek> hmm, let me try to gdb the program first, to see if I can get something useful
11:02:17 <dcoutts> narens: unless you do anything special, when you have a test exe and you list other-modules, it will use the local source files, rather than using modules from the built library
11:02:59 <dcoutts> narens: I presume you've got a cabal package with a lib and a test-suite
11:03:03 <narens> dcoutts: yes
11:03:57 <dcoutts> narens: the alternative you see is for the test-suite to list the library in its build-depends, then it can use the library, but then it can only use the exposed modules.
11:03:59 <narens> dcoutts: so, you're saying the executable will have access to non-exported functions in my local source?
11:04:09 <dcoutts> narens: no, the non-exported modules.
11:04:47 <narens> dcoutts: i see...
11:05:22 <c_wraith> narens: then move the functions you don't want to export into non-exported modules
11:05:41 <c_wraith> But export them from the modules they're defined in, just not the ones they're used in
11:06:03 <narens> c_wraith: gotcha
11:30:10 * hackagebot unbound 0.2.3 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.2.3 (BrentYorgey)
11:30:14 <crystal-cola> so why haskelll
11:30:24 <crystal-cola> after all these yeas
11:31:29 <crystal-cola> ?
11:32:53 <paolino> for fun
11:32:55 <nyingen> @protontorpedo
11:32:55 <lambdabot> how does haskell do with large systems?
11:33:33 <crystal-cola> is haskell still fun
11:36:24 <Boxo> @protontorpedo
11:36:25 <lambdabot> help please
11:42:53 <roconnor> crystal-cola: what other choice do we have?
11:43:23 <kwantam> C++, obviously >:-)
12:31:50 <efie> t :: [Bool] -> Int -> [Bool] -> Int; i want this function to get a List and an Integer and to return a list and an Integer, where do i have to put the brackets?
12:32:15 <roconnor> [Bool] -> Int -> ([Bool], Int)
12:33:53 <tamiko> ([Bool],Int) -> ([Bool],Int) is more appealing for me :)
12:34:08 <efie> ok, i didnt know that i have to use a comma. i also thought that haskell and the "->" operator is right-associative and therefore in this case i dont need the brackets anyway?
12:34:36 <tamiko> efie: [Bool] -> Int  is a function that consumes a list of Bools and returns an Int.
12:34:55 <monochrom> -> is not a "do what I mean" operator
12:34:59 <epdtry> efie: a function can only return one thing, so if you want it to return more than one, you have to use a tuple
12:35:25 <roconnor> ([Bool],Int) -> ([Bool],Int) and [Bool] -> Int -> ([Bool], Int) are different types (although they are isomorphic).
12:35:54 <efie> ok, thanks
12:37:24 <tamiko> roconnor: The former has the advantage that it is easily "lift"able :)
12:37:43 <roconnor> tamiko: I like your type too
12:43:43 <eikke> would anyone know whether there's ever any work done on encoding finite state machines in type systems, and restrict valid state transitions that way?
12:44:02 <eikke> (not sure something alike is possible at all, but sounds like something useful in the thing I'm working on)
12:48:29 <nswill> Does anyone know how I can stop haskell from emitting the escape character in this escape sequence? "\""
12:49:07 <Zao> nswill: In what context?
12:49:07 <monochrom> by using putStrLn instead of print, show
12:49:46 <nswill> Well if I need to quote a path string on windows, so I'm just taking a string and then prepending and appending a quote
12:50:07 <nswill> When I do this with "\"" ++ path ++ "\"" I get the backslashes in addition to the quotes
12:50:37 <Zao> nswill: You're missing what monochrom is saying.
12:50:52 <Zao> print (and by extension show) will escape things sufficiently.
12:51:00 <Zao> putStrLn (and putStr) doesn't.
12:51:01 <monochrom> next time, I will have to ask, "if I answer, will you read?"
12:51:36 <Zao> (show is intended to be the counterpart of read, which really wants to be able to roundtrip)
12:52:08 <Zao> "when I mysql_real_escape_you my string before I printf it, it has all those strange characters in it"
12:53:03 <nswill> Sorry monochrom, I just looked at the highlighted line
12:55:44 <nswill> So the backslash isn't actually getting stored into my generated string it's just a part of show, makes sense. Thanks
12:59:21 <monochrom> sorry, I will also look at only highlighted lines next time, too
13:00:23 <Kaidelong> @hoogle [a] -> MVar a
13:00:24 <lambdabot> Prelude head :: [a] -> a
13:00:24 <lambdabot> Prelude last :: [a] -> a
13:00:24 <lambdabot> Data.List head :: [a] -> a
13:01:20 <Kaidelong> hmm, I guess a type like that isn't actually possible
13:01:57 <ClaudiusMaximus> @type mapM_ Control.Concurrent.MVar.putMVar
13:01:58 <lambdabot> forall a. [GHC.MVar.MVar a] -> a -> ()
13:02:14 <ClaudiusMaximus> @type \m ->mapM_ (Control.Concurrent.MVar.putMVar m)
13:02:15 <lambdabot> forall a. GHC.MVar.MVar a -> [a] -> IO ()
13:02:58 <Kaidelong> that is what I want, thank you claudius... I think...
13:03:02 <Kaidelong> it is what I want, conceptually
13:03:38 <Kaidelong> Yes I think it will work
13:04:04 <ClaudiusMaximus> @hoogle [a] -> Chan a -> IO ()
13:04:04 <lambdabot> Control.Concurrent.Chan writeList2Chan :: Chan a -> [a] -> IO ()
13:04:04 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
13:04:04 <lambdabot> Control.Concurrent.Chan writeChan :: Chan a -> a -> IO ()
13:05:54 <Kaidelong> even better!
13:10:38 <tommd> Kaidelong: There's also a bounded-chan library (from Adam Wick) on hackage.  Consider it if you don't want a huge buffer of messages.
13:53:48 <sebastian> I'm looking for graphical libraries for real time visualizations. What would you suggest?
13:54:33 <sebastian> preferable os: GNU/linux
13:58:17 <pmetzger> anyone ever see this on OS X with a very recent ghc?
13:58:19 <pmetzger> ld: warning: could not create compact unwind for .LFB3: non-standard register 5 being saved in prolog
13:58:33 <pmetzger> somehow, that doesn't feel like a type error to me or what have you. :)
14:02:21 <pmetzger> hrm. I take it this is not something anyone knows what to make of then. :)
14:02:29 <pmetzger> maybe I'll try reinstalling the platform.
14:05:02 <siracusa> pmetzger: A similar paroblem has been reported here: http://hackage.haskell.org/trac/ghc/ticket/5019
14:05:10 <siracusa> *problem
14:06:57 <pmetzger> hrm. however, I'm on x86, not x86_64. (I took the "64 bit is experimental" thing seriously.)
14:07:19 <pmetzger> though I presume it is the same deal.
14:08:03 <pmetzger> or something similar. sigh.
14:21:54 <applicative> pmetzger, which version of ghc are you using?  I thought I'd seen all the os x curiosities :)
14:22:17 <pmetzger> 7.0.3
14:22:38 <applicative> oh, i noticed the ticket was about 7.1 and wondered... 
14:22:43 <pmetzger> OS X "curiousities" considered annoying...
14:22:57 <pmetzger> is 7.1 out?
14:23:09 <jmcarthur> it used to not have so many curiosities :\
14:23:11 <jmcarthur> no
14:23:14 <c_wraith> .oddnumber is the dev version
14:23:19 <c_wraith> 7.1 will never be released
14:23:24 <c_wraith> it will be 7.2 when it's released
14:23:31 <pmetzger> ah, the old linux convention
14:23:45 <applicative> there used to be an obnoxious ld warning about 'read-only-relocs' which vanished in 7.0.3
14:23:55 <jmcarthur> what was the determining factor for going from 6.12 to 7? just "it's different enough"?
14:24:08 <c_wraith> The new linux convention is "all version numbers start with 2.6, and that doesn't mean anything" :)
14:24:18 <pmetzger> jmcarthur: presumably it was .78 better
14:24:23 <applicative> the type checker/inferrer, people said, was the great change, jmcarthur
14:24:39 <c_wraith> jmcarthur: I think it was a combination of "a bunch of stuff was changed" and "if we don't change it now, we'll never have another chance"
14:26:35 <c_wraith> Much like how a few years ago, the linux kernel didn't go to 2.8, so now it's permanently 2.6, because there will never be a change bigger than that as a single release.
14:26:52 <applicative> pmetzger: I started using the 64 bit one with 7.0.3, I wonder if there was more struggle to get that to work better.  Do you have the new model xcode? 
14:27:03 <pmetzger> yah, I have Xcode 4
14:27:27 <applicative> I see, I don't have that. 
14:27:33 <pmetzger> they'll eventually bump the linux kernel version number....
14:27:48 <pmetzger> it just won't be until Linus decides arbitrarily that he's sick of 2.6
14:28:07 <pmetzger> or after he dies or something.
14:32:14 <pmetzger> ah, a reinstall of the haskell platform banished the mysterious ld message
14:32:50 <pmetzger> I feel so helpless using these tools. I'm used to not behaving like a windows user, randomly reinstalling things and seeing what might work.
14:32:52 <pmetzger> sigh.
14:38:35 <adamvh> Speaking of Mac OS X, I had a kernel panic a while back during a ghci session.  I haven't been able to reproduce it, though.
14:43:13 <pmetzger> nope, the reinstall did not fix it actually...
14:43:22 <pmetzger> I was mistaken.
14:48:45 * hackagebot epub-metadata 2.2.0.0 - Library for parsing and manipulating ePub files and OPF package data  http://hackage.haskell.org/package/epub-metadata-2.2.0.0 (DinoMorelli)
15:03:08 <behelit> hi. i have a few days off and figured i'd pick up another language. haskell looks interesting (i like erlang and python; haskell seems like a nice combination with a twist). it looks performant and all that, but what are haskells strong points?
15:03:31 <aristid> the type system
15:05:03 <boothj5> I've spent the last couple of months learning haskell, the syntax is probably the most elegant i've programmed with
15:05:10 <behelit> and what does that give me (besides fewer bugs i'd guess)
15:05:51 <monochrom> haskell permits more abstractions
15:06:47 <monochrom> did you know that "control-flow constructs" are merely yet another library functions in haskell and so you can write your own too?
15:07:05 <behelit> must be something wrong with my modem
15:07:13 <adamvh> behelit: pattern matching is nice
15:07:17 <dons> @tell shapr http://science.io/ 
15:07:17 <lambdabot> Consider it noted.
15:07:46 <shachaf> monochrom: Like if?
15:07:54 <monochrom> yes
15:08:15 <monochrom> lambdabot probably has the if' function
15:08:19 <c_wraith> if should be a function.  stupid unneeded syntax.
15:08:30 <monochrom> > if' False undefined 'x'
15:08:31 <lambdabot>   Not in scope: `if''
15:08:41 <monochrom> oh well it doesn't. yet.
15:08:54 <c_wraith> @pl \x -> if x then 1 else 2
15:08:55 <lambdabot> flip (flip if' 1) 2
15:09:04 <behelit> adamvh: yeah, that is one of the reasons i have my eyes on haskell :)
15:09:07 <monochrom> @let if' b c d = case b of {True -> c; False -> d}
15:09:08 <lambdabot>  Defined.
15:09:11 <monochrom> > if' False undefined 'x'
15:09:12 <lambdabot>   'x'
15:09:15 <behelit> (coming from erlang)
15:09:24 <monochrom> you can't do this in an eager language
15:09:41 <shachaf> You can do it in LISP (kind of). :-)
15:09:50 <shachaf> Except the Haskell version is better because it's an actual function.
15:09:50 <monochrom> (unless you go macros like lisp does, which is unsatisfactory)
15:10:05 <shachaf> > zipWith3 if' [True,False,True] [1,2,3] [4,5,6]
15:10:06 <lambdabot>   [1,5,3]
15:10:14 <adamvh> behelit: Write anything involving trees, and you'll see how much easier pattern matching makes your life
15:10:37 <boothj5> Does anyone know about the testing interface in Cabal 1.8.0.6?  I'm being told my use of runTests is now deprecated
15:10:47 <beastaugh> http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
15:10:59 <beastaugh> well, that's the new one
15:11:04 <behelit> i'm gonna write me a little program. i couldn't get reading of an utf-8 encoded file to work properly. do you need to do something "extra" in haskell? :)
15:11:18 <beastaugh> 1.9.2 and upwards I think
15:11:37 <boothj5> beastaugh: thanks I'll take a look
15:11:41 <aristid> behelit: is your system locale set up to use utf-8 as the default encoding?
15:11:54 <aristid> behelit: that would simplify matters :)
15:12:35 <behelit> aristid: yes. en_US.UTF-8 as reported by `locale`
15:12:48 <aristid> behelit: readFile "/path/to/the/file"
15:12:54 <aristid> and you got the file contents as a string.
15:12:59 <monochrom> ghc version? should just work
15:13:51 <behelit> "hGetContents: invalid argument (Illegal byte sequence)" that is what I get
15:14:04 <behelit> or, that's actually printing it
15:14:06 <aristid> behelit: it looks like your document contains illegal byte sequences :)
15:14:20 <aristid> behelit: that means it is not valid utf-8
15:14:49 <aristid> i recommend using xxd to inspect the file.
15:14:52 <behelit> ah, i downloaded the file .. could be that :)
15:15:08 <monochrom> test it on my file: http://www.vex.net/~trebla/html5.html
15:15:26 <aristid> monochrom: it's true: GÃ¶del is great.
15:16:47 <aristid> @index hGetContents
15:16:48 <lambdabot> System.IO
15:16:59 <behelit> ah, it's actually ISO-8859
15:17:01 <behelit> the file
15:17:10 <behelit> (as reported by `file`)
15:18:56 <aristid> behelit: then you need to use these functions: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#g:23
15:19:07 <aristid> or convert the file to utf-8 with iconv first :D
15:19:15 <aristid> (iconv the program)
15:19:21 <adrake> none of the special characters render in iso-8859
15:19:23 <behelit> mucg ibliged
15:19:26 <behelit> much obliged
15:19:28 <adrake> it also looks like utf-8 in a hex editor
15:20:27 <aristid> adrake: behelit does not use monochrom's file
15:20:51 <adrake> my mistake, apologies
15:21:03 <monochrom> my file is utf-8 yes. and by design.
15:21:19 <behelit> sweet, it worked. thanks a lot :)
15:22:02 <behelit> ok, so now i can start parsing the data in the file. any guide in particular you guys recommend, or should i go with the #1 hit on google?
15:22:50 <monochrom> if binary data then package "binary" else package "parsec"
15:23:43 <aristid> things to find out: is monochrom an instance of ArrowChoice?
15:24:36 <monochrom> in fact monochrom is a guarded command language
15:25:30 <HugoDaniel> i wish i could understand stream fusion :/
15:26:19 <beastaugh> did you read the paper?
15:29:56 <behelit> last question before i leave for the night: i keep finding myself wanting to use functions in Data.Strings.Utils, but i cannot seem to import it.
15:30:06 <behelit> is it installed as a separate package or something?
15:31:07 <aristid> behelit: it's a separate package, yes
15:31:10 <applicative> ask ghc-pkg find-module 
15:31:29 <aristid> or hoogle
15:31:43 <behelit> great, thanks
15:31:58 <applicative> Missing-H, it seems
15:32:24 <behelit> it's the "startswith" function i'm after
15:32:46 <behelit> any idiomatic way of solving that without installing third party stuff?
15:33:37 <aristid> behelit: isPrefixOf
15:33:39 <behelit> filter (\x startswith x line) lines
15:33:48 <behelit> is what i'm trying to accomplish
15:34:29 <aristid> > "abc" `isPrefixOf` "abcdefg"
15:34:29 <lambdabot>   True
15:34:31 <behelit> beautiful
15:34:35 <behelit> works great
15:34:45 <behelit> what are the backticks for? :)
15:34:59 <aristid> they make it an operator
15:35:05 <aristid> like + or *
15:35:15 <behelit> ah
15:35:21 <behelit> so you can put it in the middle?
15:35:22 <boothj5> > isPrefixOf "abc" "abcdefg"
15:35:23 <lambdabot>   True
15:35:27 <aristid> behelit: exactly.
15:35:40 <aristid> behelit: the function name suggests doing that :)
15:36:14 <behelit> i see. interesting concept
15:36:38 <applicative> startswith :: Eq a => [a] -> [a] -> Bool "Returns true if the given list starts with the specified elements; false otherwise." (This is an alias for Data.List.isPrefixOf.)
15:37:31 <behelit> ok, my first program works .. save for some formatting. time to read a little before i continue tomorrow.
15:37:37 <behelit> thanks a lot for the help guys
15:38:06 <aristid> behelit: glad to see you had fun :)
15:38:10 <applicative> good work, behelit!
15:39:19 <behelit> yeah, tons of fun. lots of new concepts and syntactical "quirks".. gonna have a great week, hehe
15:39:28 <behelit> night
15:39:42 * applicative has acquired an inexplicable phobia about functions returning Bool from Professor Harper
15:40:03 <c_wraith> help, a boolean stabbed out my eyes!
15:40:18 <applicative> kinda like that
15:40:21 <c_wraith> Still, I used some of the themes from that paper when talking to a CS student today.
15:40:31 <c_wraith> Except I was talking about floating-point values, rather than booleans.
15:40:51 <aristid> applicative: what's the suggested alternative?
15:40:55 <applicative> is there a paper, I was thinking of the blog
15:40:59 <c_wraith> But the point remains that without provenance, floating-point values are really pretty useless to treat generically
15:41:07 <c_wraith> err, yes, it was just a long blog post :)
15:41:32 <applicative> aristid, i'm not sure, but the phobia is strangely productive.  Just think "I'm losing information", a Bool has hardly any content.
15:41:56 <aristid> applicative: i don't see what isPrefixOf should return alternatively.
15:42:16 <applicative> Maybe ([a],[a])
15:42:17 <c_wraith> the CS student was asking me how to convert a number to a fraction.  I told him to forget about it for floating-point values, in general.  Without the provenance of the value, you have *no* clue what you're dealing with.
15:42:49 <c_wraith> also, asking him what his computer thought 0.1 + 0.2 was helped. :)
15:43:10 <applicative> Nothing instead of False; and what has already been calculated instead of True
15:43:11 <aristid> c_wraith: there are some algorithms that try to guess fractions based on floating-point numbers :)
15:43:27 <applicative> That's the Harper Way, Obey!
15:43:33 <aristid> applicative: to avoid duplication of effort?
15:43:36 <applicative> yes
15:44:10 <c_wraith> But not just from a position of minimizing wasted effort..  Also to bundle associated data together.
15:44:12 <applicative> aristid: but I can't say I grasp the whole idea, he doesn't communicate too well.  But every time I see one now, I see information loss
15:44:15 <aristid> applicative: many times you don't really duplicate effort tho, so you will ignore the value inside the Maybe. luckily haskell is lazy, or this would really hurt
15:44:36 <aristid> isn't harper the bitchy ML guy?
15:44:42 <c_wraith> yes
15:44:45 <applicative> aristid, yes 
15:44:56 <c_wraith> doesn't mean he doesn't have some good ideas, too
15:44:57 <c_wraith> :)
15:45:16 <applicative> he's annoying but seems to be on the side of the angels, if we except what he says about our revered language
15:45:20 <aristid> c_wraith: well yeah
15:45:28 <aristid> but ML is eagerly evaluated afaik
15:45:57 <aristid> well maybe in the case of isPrefix of it would not hurt THAT much.
15:46:12 <applicative> aristid, yes its not the best example.  
15:46:36 <monochrom> I can see why the lispism-schemism "is xs non-empty? if so, what is car xs and what is cdr xs" is inferior to, say, just bloody pattern-match it. but I can't see what's wrong with isPrefixOf giving Bool
15:46:40 <applicative> he quotes Conor McB on the topic, can't be all bad
15:46:59 <aristid> applicative: you see what i mean tho? if you have eager evaluation, even the tiniest bit of extra computation required to fill the return value inside the Maybe could hurt.
15:48:10 <monochrom> in fact, for two conceivable alternatives of isPrefixOf, I can see what's wrong with not giving Bool
15:48:55 <applicative> aristid, no I do see that.  But I was thinking even with Haskell to decide "isPrefixOf" you have to unfold the definition of the list, why not keep it
15:48:58 <c_wraith> monochrom: it'd be nice if it returned the remainder of the list
15:49:03 <monochrom> first alternative: "Nothing if not prefix; what is computed if is prefix" well what has been computed that the caller doesn't already know?
15:49:18 <applicative> c_wraith's plan is better than mine 
15:49:20 <monochrom> oh oops alright
15:49:44 <Twey> The rest?
15:49:59 <applicative>  prefix :: [a] -> [a] -> Maybe [a]
15:50:28 <applicative> then if you don't want the rest you do ... case (Just _) -> ...., but if you do, it's there
15:50:56 <aristid> or use isJust
15:51:10 <aristid> i also have an if' function that works on Maybe
15:51:34 <aristid> http://hackage.haskell.org/packages/archive/shortcircuit/0.1/doc/html/Control-Shortcircuit.html :>
15:51:43 <applicative> he considers "fun plus x y = if x=Z then y else S (plus (pred x) y) "  vs "fun plus x y = case x of Z => y | S(x?) => S(plus x? y)."
15:52:11 <applicative> In the former: "Here we?ve crushed the information we have about x down to one bit, then branched on it, then were forced to recover the information we lost to justify the call to pred, which typically cannot recover the fact that its argument is non-zero and must check for it to be sure.  What a mess! "
15:52:37 <monochrom> yes I hate that too. lispism-schemism.
15:53:03 <applicative> I don't have enough insight to defend this, I'm just noting that it seems to have had a wholesome effect despite my lack of clarity
15:53:53 <monochrom> oh we all agree on this one. predicate+destructor < pattern
15:54:10 <c_wraith> Yeah, we do.
15:54:17 <monochrom> or rather > if you measure pointless code bloat
15:54:25 <magicman> I sometimes want a zip(With)-related function of type [a] -> [b] -> ([(a,b)], Either [a] [b]) (or (a -> b -> c) -> etc...)
15:54:39 <applicative> monochrom: okay, I'm just catching up! 
15:55:01 <monochrom> in fact we go so far that we demand view patterns in case the data type is abstract!
15:55:27 <applicative> magicman, oh, with the leftover in Either?
15:55:32 <c_wraith> I've only recently figured out how nice view patterns can be with Data.Sequence
15:55:34 <magicman> Yep.
15:55:50 <applicative> I see, a similar idea.
15:56:28 <aristid> magicman: i think i wrote such a function once, and only lambdabot knows it ;)
15:57:01 <magicman> I've only needed it two or three times, but it has some appeal.
15:57:23 <c_wraith> we had a long discussion on appropriate ways to do that a while ago.  As usual, we covered lots of possibilities, but no winner was crowned :)
15:57:27 <aristid> @src zipWith
15:57:27 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:57:28 <lambdabot> zipWith _ _      _      = []
15:57:30 <applicative> magicman: yes now I want it
15:58:10 * applicative proposes a new "NolostInformationPrelude" or "Prelude.Harper"
15:58:39 <magicman> Eh, it would still have zip(With), but that'd be fst on the result.
15:59:06 <applicative> right
15:59:30 <applicative> zipWith = fst . zipWithHarper
15:59:32 <aristid> :t let zipWith' f (a:as) (b:bs) = let (xs, as', bs') = zipWith' f as bs in (f a b : xs, as', bs'); zipWith' f as bs = ([], as, bs) in zipWith'
15:59:32 <lambdabot> forall t t1 a. (t -> t1 -> a) -> [t] -> [t1] -> ([a], [t], [t1])
15:59:39 <applicative> or zipWIthMagicman
15:59:52 <aristid> magicman: would this do? :)
16:00:03 <magicman> Eh, there's some redundancy there.
16:00:32 <aristid> explain
16:00:33 <magicman> As in, at least one of the [t], [t1] is empty, or both are bottom.
16:00:53 <aristid> magicman: well, sure, but Maybe (Either [a] [b]) seemed stupid to me
16:01:01 <aristid> and Either [a] [b] even worse
16:01:31 <magicman> I'd've gone with Either [a] [b], but fair enough.
16:01:57 <magicman> We need a new datatype! data Perhaps a b = Neither | This a | That b
16:02:57 <aristid> heh, yeah
16:03:14 <aristid> data ThisOrThatOrWhoKnows
16:03:23 <magicman> True | False | FileNotFound!
16:05:36 <happy4crazy> hey everyone, just started a blog that will probably include a bunch of haskell stuff: monastic.io/
16:05:54 <happy4crazy> first post is some fun stuff with recursion and the list monad, enjoy!
16:30:07 <boothj5> trying to install cabal 1.10.1.0, I have ghc 7.0.1, im hitting this bug http://hackage.haskell.org/trac/hackage/ticket/808 could anyone point me in the right direction?
16:56:48 <gienah> boothj5: my guess is that you need to either use the cabal 1.10.0.0 that was included in ghc 7.0.1, or upgrade to ghc 7.0.3 and use the included cabal 1.10.1.0
16:57:12 <blackdog> random thought: could you model the POST/GET/PUT/DELETE properties in the haskell type system?
16:57:54 <blackdog> as it stands, i guess everything would just live in IO
16:58:36 <boothj5> gienah: thanks, just looking through my dependencies now, im on slackware so using a mix of slackbuilds and cabal-install, I think sticking to cabal-install might be safer!
17:12:10 <gwern> blackdog: get/put sounds like state monad, fwiw
17:13:10 <gwern> blackdog: a function only needs GET? it lives in a reader monad. POST/PUT? writer monad. delete? another writer monad maybe to log deletions and allow undos
17:16:51 <adamvh> Say I'm doing some pattern matching, and it's a real bear of a pattern (I'm matching on a specific configuration of a tree).  Is there a standard way of indenting this?  emacs' haskell-indentation is unusually braindead here.
17:17:43 <gienah> boothj5: maybe that might work. I never use cabal-install, instead I create gentoo ebuilds. So an alternative would  be to create slackbuilds for everything
17:17:53 <blackdog> gwern: yeah. i guess it's the support for idempotency you don't get
17:18:09 <blackdog> and it still only works within the confines of the program
17:18:20 <blackdog> it would be nice to be able to give a type to an HTTP api.
17:18:52 <blackdog> basically, i see the REST guys coming up with all these reasonably clean rules for resources
17:18:57 <blackdog> and they make sense
17:19:03 <blackdog> but you're relying on convention
17:20:32 <gwern> maybe you just need fancier types
17:20:42 <gwern> GADTs and phantom types seem to be able to encode a lot of stuff
17:21:02 <gwern> and this is actually reminding me of session types, weren't they supposed to be good for network protocols?
17:21:23 <blackdog> i don't know much about them.
17:21:36 <blackdog> and yeah, fancier types are probably the answer.
17:22:02 <blackdog> it'd give me a bigger stick to beat the Ruby guys too:) "this REST interface is guaranteed to come correct, yo"
17:26:40 <blackdog> seafood: i'm sorry, mate, i'm gonna miss your yesod talk:(
17:27:01 <seafood> seafood: Doesn't matter.
17:27:32 <seafood> blackdog: No worries.
17:34:56 <FrederikVds> Hi, does anybody happen to know if there is a lazy alternative to getLine? getLine seems to read an entire line into memory.
17:38:35 <drunK> FrederikVds: unsafeInterleaveIO
17:39:42 <drunK> but with getLine (ie. reading from stdin) it doesn't have much sense
17:40:42 <FrederikVds> thanks! it does when reading from a pipe right?
17:40:53 <Cale> FrederikVds: You can do  fmap lines getContents
17:41:03 <Cale> FrederikVds: which will get a lazy list of all the lines
17:42:58 <drunK> FrederikVds: yeah, I guess
17:43:15 <FrederikVds> yes, but that's ugly, i thought there had to be a better way
17:43:37 <monochrom> unsafeInterleaveIO getLine still reads an entire line into memory. just postponed.
17:46:15 <monochrom> in more detail, it does not "read a line partially"
17:48:21 <FrederikVds> monochrom: yes, it seems so, getContents does though
17:51:08 <monochrom> in short, getContents wraps unsafeInterleaveIO at the getChar level (or actually get-one-buffer-worth-of-data level) so that's why it can actually do partial
17:54:15 <FrederikVds> ok, thanks
18:17:28 <haskell> hello
18:18:13 <haskell> anybody here?
18:18:16 <gwern> I know haskell. haskell is a good friend of mine. and you sir are no haskell.
18:18:31 <haskell> ?
18:18:38 <haskell> oh, the political quote
18:18:39 <luite> mr. Curry, I presume
18:18:55 <haskell> dan quayle or something
18:19:44 <gwern> 'do you expect me to thunk?' 'No, Mr. Curry, I expect you to be undefined!'
18:20:31 <haskell> i have a haskell question
18:20:45 <nyingen> but you're haskell
18:21:20 <gwern> nyingen: maybe he's just vain
18:21:30 <gwern> likes to hear about himself
18:21:38 <haskell> i just logged in, i don't know what all of this is
18:22:03 <gwern> a likely story
18:22:30 <adnam> missed u guys
18:22:36 <haskell> i thought i logged in as haskell beginner
18:22:50 <haskell> maybe it truncated the name to haskell
18:23:15 <nyingen> haskell: could be
18:23:24 <nyingen> sorry for all the jokes then :)
18:23:33 <haskell> does anybody here know some things about haskell?
18:23:59 <haskell> i have two questions that are pretty basic
18:24:05 <gwern> despite the name, this channel and all its regulars are actually devoted to yo mamma jokes
18:24:21 <gwern> so if you can ask those basic questions in the form of a yo mamma, then we can answer them
18:24:42 <haskell> ym: can haskell be installed on a Macbook Pro to practice writing haskell?
18:25:18 <luite> yes, download the haskell platform
18:25:22 <haskell> cool!
18:25:31 <haskell> here's my second question...give me a second
18:25:44 <haskell> i was wondering if haskell can do this...
18:26:02 <luite> http://hackage.haskell.org/platform/
18:26:32 <haskell> user types something into a web browser>>> information gets sent to a server that has haskell on it>> haskell processes the information in some way>> haskell returns an answer to the web browser user
18:26:50 <adnam> @faq can haskell do this: user types something into a web browser>>> information gets sent to a server that has haskell on it>>  haskell processes the information in some way>> haskell returns an answer to the web browser user
18:26:50 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:01 <Bfig> rofl
18:27:02 <haskell> awesome!
18:27:06 <luite> haskell: yes there are a few frameworks out there for that, happstack, yesod, snap
18:27:13 <Bfig> @faq decide the halting problem
18:27:14 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:21 <Bfig> holy fucking shit
18:27:23 <haskell> I've been looking at PHP, but PHP just seems to fetch and sort files primarily
18:27:31 <haskell> that's great for catalogs and stuff
18:27:45 <luite> hmm, php can do more than that, but haskell is better of course ;)
18:27:46 <haskell> but I don't think PHP would be good to write a program to model weather patterns and stuff like that
18:28:03 <adnam> php is not really "good" to write anything :-P
18:29:10 <haskell> thanks, i'm going to write these things down listed above
18:29:18 <adnam> haskell: anyway, to do some simple data processing for the web, php will be faster to get up and running for that
18:29:46 <Tyr42> now, what are some good starting places if I want to understand ghc?
18:29:53 <haskell> i was thinking more like extremely complex data processing
18:30:06 <Tyr42> I would like to contribute to it, but I have no idea where to start
18:30:11 <adnam> then you definitely don't want php :-)
18:30:14 <haskell> i have an advanced background in mathematics
18:30:29 <haskell> like crazy proofs that take up 8 pages and stuff like that
18:30:30 <adnam> then you'll probably like haskell!
18:30:43 <Tyr42> very much so
18:30:51 <haskell> and differential equations that take two pages to solve by hand
18:30:52 <luite> 8 pages isn't crazy anymore... :p
18:30:59 <Tyr42> haskell has much more of a math flavour than most languages
18:31:21 <haskell> that's awesome.  i'm really glad to hear that haskell can interface in and out of the web
18:31:30 <brbr> hello
18:31:41 <haskell> most data-intense stuff is usually written in C++ or something like R
18:31:56 <haskell> but those are geared more toward desktop, isolated computers
18:32:31 <brbr> can a datatype contain another datatype?
18:32:33 <Bfig> haskell, you haven't ever touched a socket interface have you?
18:32:40 <Bfig> brbr, yes.
18:32:47 <haskell> like port 80 etc?
18:33:05 <Bfig> w/e.
18:33:42 <nyingen> @type (//)
18:33:43 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:33:47 <Bfig> haskell, if you need to process a stream you can do it in C++
18:34:19 <Bfig> haskell, haskell has i assume the Handle interface for you
18:35:27 <haskell> i read a few lines of haskell code in the book at the bookstore, and it looked awesome
18:35:41 <haskell> but there were no books on it, it was just part of conversation in another book
18:36:03 <luite> @where lyah
18:36:04 <lambdabot> http://www.learnyouahaskell.com/
18:36:07 <luite> haskell: try this one
18:36:34 <Tyr42> That is a really good one
18:36:47 <adnam> oh well bedtime, have fun
18:37:01 <Tyr42> I would also recommend taking a look at RealWorldHaskell
18:37:14 <Tyr42> http://book.realworldhaskell.org/read/
18:37:55 <haskell> computers are going toward multi-core.  this should be good for haskell because haskell is a functional language....is that basic idea correct?
18:38:09 <haskell> thanks for the book idea, i cut and pasted it
18:38:34 <haskell> i read something that functional languages do well with concurrency in multi-core environments
18:38:56 <luite> haskell: read learn you a haskell first, real world haskell is better as a second book (unless you already have a lot of experience with other languages)
18:39:10 <brbr> does anyone know of a lambda calculus implementation written in haskell?
18:39:18 <haskell> yeah!!!!!!
18:39:22 <haskell> @brbr
18:39:22 <lambdabot> I want me grog!
18:39:31 <haskell> totally cool!
18:39:38 <haskell> I love freaky math stuff
18:40:03 <nyingen> @yarr
18:40:03 <lambdabot> Gangway!
18:40:15 <brbr> I have written a half-assed type checker, but I want to contrast with existing ones
18:43:21 <haskell> thanks for the ideas everyone, i wrote the stuff down.... catch you later
18:45:35 <nyingen> I keep running into problems with vim haskell mode
18:45:42 <Tyr42> me too
18:45:56 <nyingen> When I press tab, \t gets inserted, but when it autoindents, spaces get inserted
18:46:00 <Tyr42> both on windows and on Linux
18:46:01 <nyingen> what should I do?
18:46:17 <Tyr42> ":set et"
18:46:21 <Tyr42> maybe?
18:46:27 <nyingen> I dunno
18:46:28 <nyingen> I like tabs
18:46:35 <nyingen> maybe I should hack the mode to put tabs in
18:47:06 <Tyr42> well
18:47:25 <Tyr42> hey, is the rest of haskell mode working for you?
18:47:45 <nyingen> seems ok
18:48:00 <nyingen> it's not quite as nice as emacs haskell-mode, but I don't like emacs very much
18:48:05 <Tyr42> because whenever I run gvim on a .hs file, I get some error showing up for half a second in red
18:48:05 <monochrom> and does ghc like your tab-ladden code?
18:48:09 <Tyr42> and nothing seems to work
18:48:29 <monochrom> s/ladden/laden/
18:48:36 <nyingen> monochrom: ghc can't get enough of my code. loves it, adores it
18:48:48 <nyingen> sometimes even compiles it
18:50:17 <monochrom> w00t haskell weekly new is out
18:51:04 <shachaf> Haskell Weekly New? Was there only one thing that happened over the last week?
18:51:41 <monochrom> @stab shachaf
18:51:41 * lambdabot jabs shachaf with a C pointer
18:52:13 <shachaf> Joke's on you! It was a NULL pointer.
18:52:27 <monochrom> haha
18:55:22 <nyingen> actually, tthose are usually pretty bad
18:55:52 <adamvh> Is it possible to pattern match on the left hand side of a let statement?
18:56:12 <monochrom> yes
18:56:21 <adamvh> Cool
18:56:44 <monochrom> > let x:y:z = "hello" in fromEnum x + fromEnum y
18:56:45 <lambdabot>   205
18:57:11 <monochrom> you can do it at the toplevel too. x:y:z = "hello"
18:58:00 <adamvh> It's like this language was built to deal with self-balancing trees...
18:58:00 <monochrom> I have an elaborate one at http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements#Make_token_parser
19:00:23 <Kaidelong> adamvh: that was one of the first things I did in F# and I felt the same way. Pattern matching + ADTs are amazing. I wonder if you could do the same thing in prolog
19:00:45 <Kaidelong> you doing an AVL tree?
19:02:18 <adamvh> Kaidelong: no, I'm working on a project Euler problem that requires a balanced tree
19:02:26 <adamvh> for a particularly exotic notion of "balance"
19:02:32 <Kaidelong> ah okay
19:02:51 <Kaidelong> if you don't know what it is, you should look up continuation passing styles
19:03:02 <Kaidelong> style*
19:03:29 <Kaidelong> self-balancing trees tend to need it
19:03:36 <adamvh> Hmmm.
19:03:46 <adamvh> I have a vague acquaintance with cps
19:04:22 <adamvh> Care to give a 10,000 foot summary of why self balancing trees need it?
19:05:51 <adamvh> The pattern matches for rotation are actually rather hairy...
19:06:23 <Kaidelong> reconstructing from a leaf element up
19:06:23 <Kaidelong> you accumulate a function from a leaf to a rebuilt tree
19:06:50 <Kaidelong> it's still a nice notation for it
19:08:12 <adamvh> My trees also need pretty extensive rebalancing - I'm pretty sure there's no way on Earth that I'm going to find a log(N) algorithm
19:08:36 <adamvh> I suspect that O(n) worst case, log(n) average is the best I can do
19:09:05 <adamvh> Since the notion of "balance" is not height, it's something else
19:37:43 <nyingen> @type iterate
19:37:44 <lambdabot> forall a. (a -> a) -> a -> [a]
19:38:38 <nyingen> is there a standard function that applies a function to an argument n times, so to speak?
19:39:01 <nyingen> wait, nm
19:40:54 <nyingen> @src iterate
19:40:54 <lambdabot> iterate f x =  x : iterate f (f x)
20:10:58 <ymasory> how can i set my ghci prompt to "ghci> " without the quotes? the trailing space is giving me trouble
20:11:20 <Kaidelong>  :set prompt "ghci> "
20:11:38 <Kaidelong> although I prefer to just use "> "
20:11:44 <Kaidelong> you do need the quotes
20:11:48 <mzero> :set prompt "> "
20:11:55 <mzero> is what I do
20:12:02 <mzero> that doesn't display quotes
20:12:26 <ymasory> ah perfect, thanks
20:13:17 * hackagebot hS3 0.5.6 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.6 (GregHeartsfield)
20:16:41 <adamvh> alas, emacs is not smart enough to realize that function arguments can start with @
20:17:30 <adamvh> wait, I'm an idiot
20:18:05 <Kaidelong> as pattern?
20:18:25 <Kaidelong> mmm
20:18:36 <monochrom> no, can't start with @
20:19:25 <Kaidelong> > let (x:y)@(a:b:c) = [1,2,3] in putStrLn (x : a : b : y)
20:19:26 <lambdabot>   <no location info>: parse error on input `@'
20:19:38 <Kaidelong> should have been print
20:19:40 <Kaidelong> but that doesn't parse
20:19:44 <Kaidelong> which is what I expected
20:19:53 <Kaidelong> some mechanism like that could be cool with view patterns though
20:19:54 <adamvh> For some reason I had convinced myself that it was @var instead of var@
20:20:03 <Kaidelong> too much Perl?
20:20:26 <adamvh> It's been years but the damage persists
20:20:52 <Kaidelong> wait till you get into haskell
20:23:13 <monochrom> you can restore your faith by:
20:23:16 <monochrom> > sin $pi
20:23:17 <lambdabot>   1.2246467991473532e-16
20:24:26 <blbrown_win3> throwing a dart out there, anyone use sml new jersey , how do you exit a simple script.  I am just messing with ML to test some haskell code
20:24:38 <Kaidelong> blbrown_win3: Send an EOF
20:24:44 <blbrown_win3> cool
20:24:47 <Kaidelong> Ctrl-D or Ctrl-Z on windows
20:24:59 <Kaidelong> err
20:25:06 <Kaidelong> Ctrl-D on not-windows
20:25:11 <Kaidelong> Ctrl-Z on windows
20:25:27 <nyingen> @u = keys %{{ map {$_ => 1} @x }}
20:25:27 <blbrown_win3> either way...actually writing invalid code throws an error too and quits
20:25:27 <lambdabot> Maybe you meant: undefine undo unlambda unmtl unpf unpl unpointless uptime url . ? @ v
20:25:28 <monochrom> > let x @-@ y = "boogle" in '@' @-@ '@'
20:25:29 <nyingen> ugh
20:25:29 <lambdabot>   "boogle"
20:25:38 <nyingen> boogle?
20:25:45 <nyingen> @slap lambdabot
20:25:45 * lambdabot submits lambdabot's email address to a dozen spam lists
20:26:01 <nyingen> @boogle
20:26:01 <lambdabot> Maybe you meant: google hoogle
20:26:12 <Kaidelong> blbrown_win3: just think of it like being the compiler, except waiting on your input rather than reading a file
20:26:26 <Kaidelong> that said it usually should recover from errors
20:26:35 <blbrown_win3> Kaidelong, yea, I did it before, I was surprised they didn't add a OS specific function in there
20:26:36 <Kaidelong> like syntax errors
20:46:04 <Ajd> what up
20:47:13 <mzero> :t liftM
20:47:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:47:22 <dmwit> hiya Ajd
20:47:29 <mzero> that's what's up
20:47:48 <Ajd> nm
20:47:56 <Ajd> haskell eh..
20:49:03 <dmwit> Are you Canadian, then?
20:52:11 <danharaj> I just came in here to voice my frustration that Data.Vec uses its own "Map" class that conflicts with Prelude instead of the standard Functor class
20:52:26 * danharaj end rant
20:53:25 <mzero> "Hello, again!"   "Hello, again!"  "Do you like my map?"  "No, I do not."   "Goodby"   "Goodby"
20:54:04 <mzero> then, after a wild part with type classes and sparks everywhere.....
20:54:39 <mzero> "Hello, again!"   "Hello, again!"  "Do you like my fmap?"  "Yes! I like that fmap!  I like that party fmap!"   "Goodby!"
20:56:18 <danharaj> I really wish there were a low dimensional linear algebra library mature and polished enough to be part of Platform.
20:58:47 <jmcarthur> danharaj: it does that because Functor's fmap is not general enough, doesn't it?
20:59:22 <danharaj> jmcarthur: I don't know why. I do know the library uses particularly powerful type kool-aid, but as a naive end-user that does not factor into my view of the library.
21:01:07 <jmcarthur> danharaj: there is a possible Functor instance for it, but it wouldn't be what you want
21:01:40 <jmcarthur> this isn't a polish issue. this is a design issue
21:02:11 <danharaj> jmcarthur: I would have settled for at least not clashing with prelude. I think clashing with prelude is so inconvenient.
21:02:15 <jmcarthur> it would be possible to make newtype wrappers than have the instance you want
21:02:22 <jmcarthur> qualified imports are convenient, IMO
21:02:40 <jmcarthur> Vec.map  or whatever
21:02:46 <danharaj> They are, but cumbersome.
21:03:13 <jmcarthur> i thought that until after a few years i realized i had no viable alternative
21:03:29 <danharaj> of course, all of this is frustrating because the only way I discern to do scalar multiplication is Vec.map (*m)
21:05:49 <lpsmith> Is it safe to use an atomicModifyIORef inside an unsafePerformIO?
21:06:41 <jmcarthur> lpsmith: depends
21:07:08 <jmcarthur> lpsmith: is what you are doing referentially transparent?
21:07:11 <lpsmith> Yes
21:07:23 <jmcarthur> so your question is only in an operational sense?
21:07:31 <lpsmith> (I do know how to use unsafePerformIO)
21:07:35 <jmcarthur> okay
21:07:40 <jmcarthur> i'm pretty sure it is safe, then
21:07:41 <lpsmith> I'm just wondering if there is any bad interaction
21:07:51 <lpsmith> that maybe I'm not immediately aware of
21:07:52 <jmcarthur> i've done it without consequence
21:08:16 <jmcarthur> doesn't mean it's safe, but there's some evidence at least
21:08:21 <jmcarthur> and i can't think of any issues with it
21:09:24 <jmcarthur> danharaj: i think you can use vec and dot for scalar multiplication, too
21:09:34 <lpsmith> Because the solution obvious to me in augustss post is to use atomicModifyIORef
21:09:41 <jmcarthur> danharaj: and if you are multiplying by a literal you can avoid the vec, too
21:09:49 <lpsmith> so I was wondering if there was a reason he isn't using it
21:09:51 <lpsmith> :)
21:09:53 <jmcarthur> lpsmith: that is what i thought too
21:10:01 <jmcarthur> lpsmith: he says on reddit that it would work to
21:10:04 <jmcarthur> *too
21:10:09 <lpsmith> ahh
21:10:27 <danharaj> jmcarthur: ah, I see that now. Oh well. I did not go through the API thoroughly enough.
21:10:35 <jmcarthur> in fact, i have used atomicModifyIORef for basically the same purpose
21:10:51 <lpsmith> ahh, i hadn't read the comments to the story
21:11:04 <jmcarthur> you guys both need to read more :P
21:11:43 <danharaj> Hey, it's hard to keep track of what's readable and what's not when half the docs are filled with unreadable instance declarations :p
21:13:34 <lpsmith> Yeah,  I've used atomicModifyIORef a fair bit, but never in an unsafePerformIO
21:13:45 <lpsmith> and I've used unsafePerformIO a fair bit too
21:27:24 <jmcarthur> lpsmith: i regret to say that i have used unsafePerformIO quite a bit, too :(
21:27:58 <jmcarthur> always in a referentially transparent way (or so i was convinced each time i used it)
21:38:56 <danharaj> oh christ
21:38:59 <lpsmith> lol
21:39:14 <danharaj> there's always a moment of anxiety once I resolve all type errors in my code
21:39:27 <lpsmith> I've used unsafePerformIO in non-referentially transparent ways for my own amusement's sake
21:40:03 <lpsmith> Ceiling Cat has watched me unsafePerformIO, that's for sure.
21:41:18 <danharaj> Just a few more functions and I can watch a bunch of particles fly around each other, rendered in OpenGL by shaders, whose time evolution is governed by velocity verlet and a terribly complicated method of specifying interaction forces.
21:43:12 <blackdog> danharaj: heh, yes - there's an outside chance it might actually work
21:43:27 <blackdog> first clean compile in C is generally where your trouble starts...
21:43:56 <danharaj> Tell me about it. I've obviously missed an abstraction somewhere. In my code to specify an inverse square potential between all particles, I have a line that goes like this: (map map $ map (norm.) (map (flip (-)) pos)) <*> foo
21:44:26 <danharaj> (I don't actually use foo in my code)
21:46:17 <sully> danharaj: this sort of thing is why we are suspicious of haskell programmers over in ML-land!
21:46:36 <danharaj> I can't read ML code :\
21:46:58 <danharaj> then again, I am mostly dyslexic regardless of the language. I am extremely idiosyncratic with my notation, even when I'm doing math.
21:47:38 <sully> 3 hours into writing my first haskell program I found myself unironically writing "uncurry $ flip (,)"
21:47:57 <sully> and I realized that something had gone horribly wrong
21:48:06 <danharaj> well I don't see it as going wrong :p
21:48:12 <sully> (first real haskell program)
21:48:13 <sully> (I was later informed that I wanted swap in Data.Tuple)
21:48:25 <jmcarthur> sully: i like (snd &&& fst) for that
21:48:33 <danharaj> Almost every long line of combinators is an obvious abstraction waiting to happen.
21:48:35 <jmcarthur> oh there is a swap in the standard library now?
21:48:53 <jmcarthur> well shoot ignore me and use swap then :)
21:48:58 <sully> I think the right way to write that is \(x,y) -> (y,x)
21:49:23 <jmcarthur> snd &&& fst    is perfectly readable to me
21:49:34 <jmcarthur> swap is of course better
21:49:48 <ion> Me too.
21:50:00 <danharaj> It would not have been a bad thing if Haskell was designed with more tuple sugar in mind :p
21:50:02 <ion> Arrow is very useful for tuple-related stuff.
21:50:42 <danharaj> like type safe indexing and swizzling
21:52:31 <jmcarthur> actually, \(x,y) -> (y,x) is not even the semantics i would want
21:52:50 <danharaj> why not?
21:52:50 <jmcarthur> \~(x,y) -> (y,x)  is what i would go with if i was to write it pointfully
21:52:54 <danharaj> oh, right.
21:53:08 <danharaj> I hate thinking about laziness :/
21:53:15 <sully> what does ~ do?
21:53:15 <jmcarthur> i like laziness
21:53:20 <jmcarthur> sully: lazy pattern matching
21:53:35 <jmcarthur> sully: it means that a consumer of the result can get the (,) without forcing the original tuple
21:54:26 <sully> Data.Tuple does: 
21:54:30 <jmcarthur> > let swap ~(x,y) = (y,x) in swap undefined
21:54:31 <lambdabot>   (*Exception: Prelude.undefined
21:54:32 <sully> swap (a,b)              = (b,a)
21:54:36 <jmcarthur> > let swap (x,y) = (y,x) in swap undefined
21:54:37 <lambdabot>   *Exception: Prelude.undefined
21:54:41 <blackdog> huh, i didn't know that. if i map with (\(x,_) -> foo x), will the second component get forced?
21:54:47 <jmcarthur> sully: ew. then i don't like that definition of swap
21:54:53 <jmcarthur> blackdog: no
21:55:07 <ion> > fst $ (\~(x,y) -> (y,x)) (undefined,1)
21:55:08 <lambdabot>   <no location info>: parse error on input `->'
21:55:09 <blackdog> but if the surrounding tuple is a thunk, it will be
21:55:12 <ion> > fst $ (\(~x,~y) -> (y,x)) (undefined,1)
21:55:13 <lambdabot>   1
21:56:10 <jmcarthur> > let foo (x,_) = x in foo (5, undefined) -- blackdog 
21:56:11 <lambdabot>   5
21:56:11 <ion> Lambda doesnât seem to like a ~(x,y) pattern.
21:56:50 <ion> > fst $ (\(~(x,y)) -> (y,x)) (undefined,1)
21:56:50 <lambdabot>   1
21:56:52 <ion> huh.
21:57:07 <ion> > fst $ (\ ~(x,y) -> (y,x)) (undefined,1)
21:57:08 <lambdabot>   1
21:57:22 <ion> It seems to require a space between \ and ~. :-)
21:57:26 <jmcarthur> i think it thinks \~ is section syntax
21:57:49 <jmcarthur> > let a \~ b = a + b in (\~ 5) 7
21:57:50 <lambdabot>   12
21:58:17 <ion> heh
21:58:25 <jmcarthur> there's a way to confuse somebody
21:58:57 * sully doesn't believe in laziness by default, is skeptical but could be convinced about purity; I'm just here for the typeclasses :P
21:59:25 <jmcarthur> purity is the awesomeness
21:59:28 <ion> yes
21:59:34 <jmcarthur> laziness is more controversial
21:59:38 <jmcarthur> i personally love laziness by default
21:59:49 <jmcarthur> and don't find it so hard to reason about
22:00:25 <jmcarthur> purity is important for denotative programming
22:00:43 <jmcarthur> or at least useful for it
22:00:54 <jmcarthur> not sure if it's necessary for it. i think it is...
22:03:27 <ion> IO actions being first-class pure values is great. You can use the same combinators you use for everything else to do stuff with them.
22:03:47 <jmcarthur> importantly, without fear of it being executed!
22:04:30 <jmcarthur> well, at least not anywhere you wouldn't expect it to be
22:04:39 <jmcarthur> of course it's executed if it is in main
22:05:10 <jmcarthur> where "in main" means "tracable through a series of binds to main"
22:05:47 <Rotaerk> but the caller has total control over whether it's integrated into main, which is perfect
22:05:48 <jmcarthur> what i love about purity is that i can look at a subexpression in completely isolation of everything around it
22:05:53 <jmcarthur> *complete
22:06:00 <Rotaerk> though the unsafe* stuff kind of bypasses the whole thing
22:07:07 <danharaj> unsafe is not haskell98 is it?
22:07:08 <ion> Itâs not as if people tend to use the unsafe* stuff for evil.
22:07:17 <danharaj> GHC is practically its own language
22:07:19 <jmcarthur> not on purpose
22:08:13 <jmcarthur> danharaj: i think unsafePerformIO is in the FFI addendum, which is accepted as h98 conventionally
22:08:23 <danharaj> ah, alright then.
22:08:54 <danharaj> it seems a little dubious to have that part of the standard in a way you can't control
22:09:14 <jmcarthur> well, it's intended for the FFI
22:09:14 <danharaj> it would be nice if you could set a flag that says "no unsafePerformIO called from this code will be performed"
22:09:53 <jmcarthur> hard to do. would you be able to use that flag even if that code you wrote depends on some other module that uses unsafePerformIO?
22:09:59 <jmcarthur> even if that other module is referentially transparent?
22:10:06 <jmcarthur> *contains only RT functions
22:10:29 <danharaj> well the problem really is can you trust a module to be referentially transparent?
22:10:51 <jmcarthur> you can't even trust the standard library to be if you just outright distrust unsafePerformIO
22:10:51 <danharaj> without unsafePerformIO, yes, yes you can. With it, you can't. Any module may be unsafe.
22:11:03 <danharaj> that's true.
22:11:27 <jmcarthur> i consider any use of unsafePerformIO to be implementing some sort of primitive
22:11:44 <jmcarthur> and the burden of proof is on the author of that code that such use is RT
22:11:55 <danharaj> of course, you can't impose that burden on them :p
22:12:00 <jmcarthur> of course if i find that it's not actually RT, i don't use that code
22:12:17 <danharaj> yes, in the end the user has to verify it
22:12:19 <Rotaerk> unsafe* doesn't really seem necessary to me ... instead of Int -> Int that uses unsafePerformIO, it could just be Int -> IO Int
22:12:42 <blackdog> danharaj: and it's similar even without unsafePerformIO with FFI. you can claim that fireTheRockets is pure without it, if it's coming from the C side.
22:12:44 <jmcarthur> unsafePerformIO is useful for creating RT functions out of non-RT code
22:12:47 <jmcarthur> Rotaerk: ^^
22:12:58 <danharaj> like doing your computations in C-land and then coming back to Haskell
22:13:07 <Rotaerk> ah
22:13:24 <jmcarthur> or doing something a little "dirtier" like using mutation to memoize a function
22:13:31 <jmcarthur> it's still RT
22:14:18 <jmcarthur> one of the, umm, "scarier" uses of unsafePerformIO, IMO, is unamb
22:14:18 <danharaj> memoization is only possible if you have referential transparency :p
22:14:28 <jmcarthur> danharaj: true!
22:14:47 <danharaj> a bit of an ironic state of affairs
22:15:30 <c_wraith> yes.  unamb requires guarantees the type system can't provide in order to be referentially transparent
22:15:46 <jmcarthur> unamb takes two values (which you must certify are equal if both are not _|_), evaluates both values in parallel, and returns the result of the first computation to terminate. if it wasn't for the precondition, it would be nondeterministic
22:16:14 <danharaj> ah I see.
22:16:24 <ion> > 1 `unamb` 2
22:16:25 <lambdabot>   Not in scope: `unamb'
22:17:14 <danharaj> working on my current project I have become less than happy with typeclasses because of the fact that they are global and you can only have one instance per type(s)
22:17:22 <jmcarthur> yeah
22:17:30 <jmcarthur> i have a love/hate relationship with type classes
22:18:08 <danharaj> I am most concerned in the long term, whether they are an enabler or ultimately a hindrance to GHC's march towards more and more powerful typing.
22:18:22 <Rotaerk> the author mentions that typeclass issue in:  http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
22:18:38 <danharaj> pfff Bob Harper's just jelly because Haskell is popular and ML isn't :p
22:18:43 <jmcarthur> danharaj: i don't think they are either of those extremes
22:18:43 <Rotaerk> haha
22:18:44 <danharaj> but no, he raises good points in that post.
22:19:29 <jmcarthur> type classes are fairly uninteresting in the grand scheme of type systems, i think
22:19:47 <danharaj> jmcarthur: I feel like they should be more like recipes for creating new types, like type constructors except you can use values in your recipe. But you can't do fancy things like you can with dependent types.
22:20:19 <jmcarthur> i'm not sure i follow
22:20:22 <danharaj> it's late.
22:20:24 <danharaj> and I am tired.
22:20:29 <danharaj> it probably is unfollowable.
22:21:07 <jmcarthur> unfollowable sounds like a C++2x keyword or something
22:21:13 <Rotaerk> haha
22:21:15 <Jafet> Like associated types?
22:21:57 <danharaj> associated values
22:23:04 <jmcarthur> an open mapping from types to values? sounds like type classes to me :)
22:23:50 <danharaj> a type constructor that can take value arguments as well as type arguments
22:23:59 <jmcarthur> in ghc we have open mappings from types to values and open mappings from types to types. all we lack is open mappings from values to values, i think
22:25:12 <jmcarthur> reminds me of the expression problem, there
22:26:08 <jmcarthur> hmm, i'm tired too
22:26:24 <jmcarthur> i'm getting all vague and handwavy
22:26:32 <danharaj> how about this. Take the Functor type class for example. Suppose you have a type constructor, Foo, that you want to give a Functor instance.
22:26:37 <danharaj> Let's say Foo has two functor instances.
22:27:05 <danharaj> What Functor should be, I think, is a way of constructing a new type constructor from Foo and a function fmap. Functor Foo fmap
22:27:29 <danharaj> so Foo wouldn't be a functor, you would make a functor out of it by augmenting its type with a function, fmap.
22:27:39 <jmcarthur> you seem to be describing something like ML modules, but not quite
22:27:48 <Jafet> Int/Monoid
22:28:10 <danharaj> I am not familiar with ML Modules, but I have heard of their vast power :p
22:28:26 <jmcarthur> danharaj: how would you use a Functor Foo fmap?
22:29:01 <danharaj> jmcarthur: gooooooood question :|
22:29:12 <jmcarthur> maybe a simpler question... what would be the type of fmap?
22:31:24 <jmcarthur> assuming fmap's type is even an interesting part of the type system here
22:31:36 <danharaj> hmm, my half baked idea is half baked indeed.
22:31:39 <jmcarthur> s/is even/is even relying on/
22:32:31 <danharaj> fmap :: (Functor f map) => (a -> b) -> f a -> f b
22:32:33 <danharaj> almost as usual
22:32:53 <danharaj> The problem with this idea is that you have to say which instance your values live in.
22:33:04 <danharaj> and that's cumbersome.
22:33:07 <jmcarthur> so what does 'map' scope over?
22:33:34 <danharaj> in that case up there? (a -> b) -> f a -> f b
22:33:55 <danharaj> if you have (Functor Foo map), then map :: (a -> b) -> Foo a -> Foo b
22:35:40 <jmcarthur> umm
22:36:02 <danharaj> (or a more general type)
22:36:04 <jmcarthur> oh so you mean 'map' in the type signature corresponds to 'map' being used in the *implementation*?
22:36:10 <danharaj> yes.
22:36:29 <cch> is any of those FRP gui library usable and actively maintained?
22:36:51 <jmcarthur> i'm trying to decide whether this is leaking implementation details to the type level
22:37:34 <danharaj> jmcarthur: (Monoid Int (+)) (Monoid Int (*)) :p
22:37:42 <jmcarthur> (and i'm still not sure what this constraint really represents or how its supposed to be type checked)
22:37:50 <danharaj> half-baked idea indeed.
22:39:28 <jmcarthur> i think this might be better characterized as explicit dictionary passingt
22:39:29 <jmcarthur> *passing
22:39:50 <danharaj> yes. I think you're right.
22:39:58 <jmcarthur> data Monoid a = Monoid { mempty :: a, mappend :: a -> a -> a }
22:40:05 <jmcarthur> then you pattern match on that to get the operators
22:40:17 <jmcarthur> foo (Monoid _ (+)) (Monoid _ (*)) = ...
22:40:54 <danharaj> Type classes in ghc at least get converted to dictionary passing anyway don't they?
22:41:00 <jmcarthur> yes
22:41:25 <jmcarthur> although i'm not sure how associated types and data families and such play into that
22:41:32 <danharaj> yes that's what I was just thinking about
22:41:48 <danharaj> type classes have expanded to be more than just dictionaries of values. They're have type information too.
22:41:52 <danharaj> they*
22:42:10 <jmcarthur> even ADT definitions
22:42:48 <jmcarthur> so it's looking more and more like ML modules in this explicit representation
22:43:08 <danharaj> I guess I want ML modules :[
22:43:34 <jmcarthur> they have their downsides too
22:43:39 <danharaj> like being too awesome?
22:43:57 <jmcarthur> you have to explicitly import them since they can't really just be inferred from your types
22:44:18 <jmcarthur> it's kind of the flip side to having to disambiguate with newtypes when using type classes
22:44:36 <danharaj> I'm not sure if that's a bad thing.
22:44:52 <danharaj> I mean it's annoying in some cases, but it's also nice having to show what you mean explicitly.
22:44:53 <jmcarthur> right, there are some arguments in favor of that
22:45:06 <jmcarthur> it gets annoying pretty quick though
22:45:09 <danharaj> heh :p
22:45:16 <jmcarthur> and you don't like qualified imports? tough
22:45:45 <jmcarthur> either be willing to use qualified imports or be willing to explicitly rename things as they are imported
22:46:18 <jmcarthur> there are of course some attempts to make some of this inferrable to some extent, but they only work so well
22:46:21 <danharaj> If ML modules lose that nice part about typeclasses, then I am sad.
22:47:02 <danharaj> maybe, maybe what I really want is the ability to scope type classes
22:47:19 <jmcarthur> there are arguments against that
22:47:28 <danharaj> I bet they're well reasoned too.
22:47:35 <jmcarthur> e.g., you don't want to be able to construct a Data.Set with one Ord instance and then use it with another
22:47:56 <danharaj> that should be a type error :[
22:48:27 <jmcarthur> i agree, but it's a tough one to prove without being fairly explicit, kind of getting rid of some of the advantages of type classes
22:49:15 <jmcarthur> it might be a case for reintroducing type class constraints in data definitions
22:49:33 <danharaj> I'm not familiar?
22:49:38 <jmcarthur> so long as that means that the instance is "stored" in it when you construct it
22:50:19 <jmcarthur> data Foo a => Bar a = Bar a    -- widely considered ugly and useless in haskell
22:50:45 <danharaj> That is legal code though, isn't it?
22:50:50 <danharaj> What is the preferred notion?
22:51:01 <Lemonator> why is it useless?
22:51:06 <jmcarthur> it's preferable to just not have type class constraints in data definitions
22:51:11 <danharaj> ah :p
22:51:28 <Lemonator> but WHY
22:51:38 <jmcarthur> Lemonator: it just forces you to have that type constraint all over the place, even where not necessarily needed. doesn't save any typing and actually makes you type more for no reason
22:52:08 <Lemonator> oh
22:52:21 <danharaj> oh dear. It seems like you could automagically infer all those constraints
22:52:29 <danharaj> so that they don't have to infect every function you write
22:52:57 <Lemonator> by the way
22:53:02 <Lemonator> I came across this paper:
22:53:15 <Lemonator> http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf
22:53:32 <jmcarthur> danharaj: anyway, i think it might be neat to be able to say something like:   data Bar a = Foo a => Bar a   -- somewhat like how you would write it with ExistentialQuantification, except that the 'a' is exposed in the type. the idea is that the Foo dictionary is encapsulated though
22:53:52 <jmcarthur> danharaj: that might pave the way to allowing scoped instances, unless i'm overlooking something
22:54:03 <Lemonator> Is there any hope that Haskell will adopt the ideas contained therein?
22:54:29 <jmcarthur> Lemonator: no idea
22:54:50 <Lemonator> It persuaded me to think that treating type classes as a special case of modules is a Good Idea.
22:54:57 <danharaj> The best way to make something catch on is to develop an extension to GHC that incorporates it.
22:55:11 <danharaj> of course, you have to make sure it is sane/consistent/etc.
22:55:24 <Lemonator> writing an extension to GHC is
22:55:28 <Lemonator> nontrivial
22:55:33 <jmcarthur> hmm, no i think my proposal is insufficient
22:56:17 <jmcarthur> oh, no, the problem i thought i had wasn't a problem after all, so nevermind
22:57:00 <danharaj> :p a mind at work
22:57:23 <jmcarthur> Data.Set.insert would not have an Ord constraint on it. the Ord dictionary would be encapsulated in the Set itself, and since you were presumably able to construct the Set then normal type checking would be sufficient to also check the constraint
22:57:33 <jmcarthur> there is but one thing this would allow that haskell currently wouldn't
22:57:49 <jmcarthur> it would allow you to write functions that are not actually valid
22:57:54 <jmcarthur> but it wouldn't allow you to actually use them
22:58:04 <danharaj> that would be an odd state of affairs
22:58:21 <jmcarthur> e.g. you could write a function that takes a Set (a -> b) and inserts stuff into it
22:58:34 <jmcarthur> but you would never be able to construct the Set in the first place
22:59:01 <jmcarthur> so you would be prevented from using the invalid function
22:59:04 <danharaj> that's not too bad.
22:59:15 <danharaj> You're just writing functions on empty domains :p
22:59:47 <jmcarthur> i suppose it's no different from writing a function that takes a    Ord (a -> b) => Set (a -> b)
23:00:03 <jmcarthur> which i believe is valid, at least with some extensions
23:01:38 <jmcarthur> one problem with this, however, is that the type system doesn't force you to use this feature, so it's still possible to write the implementation of Data.Set that would allow you to mix and match Ord instances, and you wouldn't even get a warning that it's a scary thing to do
23:05:37 * hackagebot Tablify 0.8.2 - Tool to render CSV into tables of various formats  http://hackage.haskell.org/package/Tablify-0.8.2 (DanielLyons)
23:06:35 <Palmik> Hi guys, is there somewhere a list of possible topics for bachelor or graduation theses relating Haskell?
23:10:57 <Philippa> I'm not aware of one: there's no particular reason to organise them like that and the practical scope of one's a bit annoying from a research perspective too. You could check out things like the Summer of Code proposals for a starting point though?
23:13:57 <Palmik> Philippa, thanks, I will check the GSoC proposals :)
23:14:40 <Palmik> *check out
