00:01:53 <xrl> Can someone help me figure out why this function is not-ok? https://gist.github.com/915092
00:02:18 <xrl> not very elegant, but I'm trying
00:04:04 <luite> xrl: you probably need some extra parentheses
00:04:17 <luite> keep in mind that function application has higher precedence than any operator
00:04:52 <luite> so for example  negate x-y   actually means (negate x)-y
00:05:16 <xrl> so I have to wrap all the subtractions and divisions in ()?
00:05:44 <luite> yeah I guess, also the divisor:list
00:06:56 <xrl> ohh, now here's a tricky one... "add (Fractional a)"
00:06:56 <luite> you can sometimes use $ (which is just an operator with very low precedence) to reduce the number of parentheses, for example
00:07:07 <luite> f (x+y) = f $ x+y
00:07:08 <xrl> but I know for sure a will never be fractional
00:07:12 <xrl> I just did a mod check on it ;)
00:07:26 <shachaf> xrl: Use (a `div` b) for integer division.
00:07:43 <luite> @type (/)
00:07:43 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:07:53 <luite> that's where the Fractional comes from
00:09:29 <xrl> shachaf: I don't think div is correct? I want to know if its a divisor, so I need the remainder
00:09:53 <xrl> luite: yes, that is where the Fractional comes from... but I know for sure it will never be fractional
00:10:40 <shachaf> xrl: (/) is division for Fractionals. div is division for Integrals.
00:10:42 <luite> xrl: but the compiler doesn't
00:11:07 <shachaf> luite: No, the compiler does (because the type is Integral). It knows it so well that it doesn't accept (/). :-)
00:11:08 <luite> xrl: if you use (/), the type must always be some Fractional
00:11:36 <Droof> THEN I PARK MY CAR, THEN I FUCK YOUR BITCH, WET LIKE WONTON SOUP, THATS JUST HOW I DO
00:11:39 <luite> shachaf: it doesn't know that the result of the division will be an integer
00:12:15 <ion> More generally, (f!g) (h!i) = f!g $ h!i where ! can be almost any operator.
00:12:21 <BMeph> xrl: I was bored - https://gist.github.com/915092#gistcomment-26823
00:12:21 <xrl> ahh, now it makes sense for why I want div :)
00:12:23 <shachaf> Oh. Yes, OK.
00:12:40 <Droof> THEN I PARK MY CAR, THEN I FUCK YOUR BITCH, WET LIKE WONTON SOUP, THATS JUST HOW I DO
00:12:58 <BMeph> xrl: Oh, and just to be technical, "ur doin it rong." ;þ
00:13:08 <luite> xrl: you can use divMod pattern matching to do the remainder check and the result of the division in one go
00:13:10 <christo_m> A non-working way of listing factors in haskell
00:13:12 <christo_m> Lol.
00:13:25 <luite> xrl: or quotRem possibly
00:13:33 <xrl> christo_m: I know, I've barely got a hold of Haskell's syntax ;)
00:14:16 <xrl> someone take this ghc away from me
00:16:04 <luite> xrl: be thankful for ghc an its type checker, in some languages these would all have been runtime errors ;)
00:16:05 <Rc43> Hi, guys.
00:16:17 <Rc43> Could you tell me how can i use combinators in haskell?
00:16:31 <christo_m> xrl: dude im definitely not hating
00:16:36 <Rc43> I m trying to implement Y with S and K.
00:16:36 <christo_m> im trying to write a compiler so
00:16:55 <christo_m> and its my first time doing any serious functional programming ie. no toy functions in Ocaml or mosml
00:16:59 <Rc43> Comething like this:
00:17:00 <Rc43> k x y   = x s x y z = x z $ y z fix     = s s k (s.(k.(s.s.(s.(s.s.k)))) k)
00:17:07 <Rc43> shi~, one sec
00:17:17 <unfo-> holy shit
00:17:29 <Rc43> http://pastebin.com/L56Wx2Xn
00:18:32 <Rc43> It even compiles.
00:18:35 <unfo-> Rc43, imma noobie.. what the hell is that for?-D
00:18:41 <Rc43> But doesn't work as i think.
00:18:56 <Rc43> unfo, lol tricks for geeks
00:19:21 <niteria> :t (*1)
00:19:21 <Rc43> unfo, one of ways to implement recursion XD
00:19:22 <lambdabot> forall a. (Num a) => a -> a
00:19:24 <niteria> :t (-1)
00:19:25 <lambdabot> forall a. (Num a) => a
00:19:30 <niteria> ^^
00:19:41 <niteria> how to use (-1) as a function?
00:19:42 <unfo-> Rc43, kk :)
00:19:49 <unfo-> (* (-1))
00:19:54 <unfo-> or (+ (-1))
00:19:57 <blueonyx> :t substract
00:19:58 <lambdabot> Not in scope: `substract'
00:20:03 <christo_m> :t -
00:20:05 <lambdabot> parse error (possibly incorrect indentation)
00:20:07 <christo_m> haha
00:20:26 <niteria> ok, (+ (-1)) is what I wanted, thanks
00:20:43 <unfo-> when in doubt just add more parenthesis
00:20:46 <unfo-> :P
00:21:23 <xrl> how do I say that a function will return a boolean?
00:21:25 <christo_m> :t $ -1
00:21:26 <lambdabot> parse error on input `$'
00:21:46 <xrl> my type hint is such: isDivisor :: (Integral a, Bool b) => a -> a -> b
00:22:30 <luite> xrl: Integral a => a -> a -> Bool
00:22:38 <luite> xrl: Integral is a type class, Bool is a type
00:22:44 <xrl> whoa
00:23:03 <xrl> compiles :-D
00:23:08 <xrl> who cares about correctness...
00:23:16 <shachaf> niteria: (subtract 1) also works.
00:23:20 <luite> meh it compiles, so it'd better be correct :p
00:23:26 <shachaf> Or "pred" in some cases.
00:23:31 <ion> rc43: Doesn’t compile here.
00:23:55 <xrl> luite: is 4 a factor of 10? I think not... hahaha
00:24:26 <luite> it is in base 16
00:25:01 <monokrome> Hi. Does Haskell use indentation for blocks with 'do' and such
00:25:03 <monokrome> ?
00:25:08 <shachaf> Yes.
00:25:12 <monokrome> (wherever a block is created, I should say)
00:25:21 <monokrome> Okay. Cool :)
00:25:25 <Rc43> ion, really, i edited it
00:25:35 <shachaf> monokrome: Indentation is optional; { ...; ... } is the other syntax.
00:25:38 <Rc43> ion, ever space must me (.) as i think
00:25:42 <Rc43> *evry
00:25:50 <shachaf> There's a simple rule for translating indentation to the other syntax.
00:26:06 <monokrome> Is there a common convention for indentation?
00:26:15 <shachaf> "convention"?
00:26:23 <luite> the main convention is to not use tabs :)
00:26:25 <monokrome> Yep, or a standard.
00:26:28 <shachaf> Well, there's a general style.
00:26:29 <Rc43> ion, ($) i mean
00:26:35 <monokrome> Something like Python's PEP8 would suggest.
00:26:39 <shachaf> There's a standard for how indentation is interpreted.
00:26:42 <niteria> can I install cabal without root priveleges?
00:26:51 <luite> niteria: yes
00:26:52 <shachaf> Otherwise, just read some Haskell code.
00:26:52 <monokrome> shachaf: That's probably a convention then.
00:27:14 <shachaf> Yes, but it's not a complicated one.
00:27:16 <luite> niteria: typically you add ~/.cabal/bin to your $PATH
00:27:25 * monokrome never asked if it was complicated...
00:28:30 <luite> I just use the default indenting provided by the haskell-mode indenter in emacs :)
00:28:41 <monokrome> heh
00:30:30 <ion> > (<*>) (f :: Expr -> Expr -> Expr) g a
00:30:31 <lambdabot>   f a (g a)
00:49:20 <niteria> > take 5 $ replicate 3
00:49:21 <lambdabot>   Couldn't match expected type `[a]'
00:49:21 <lambdabot>         against inferred type `a1 -> [a1]'
00:49:35 <niteria> > take 5 $ replicate 3 3
00:49:37 <lambdabot>   [3,3,3]
00:50:04 <niteria> > take 5 $ cycle [3]
00:50:05 <lambdabot>   [3,3,3,3,3]
00:50:40 <niteria> nvm, sorry for spam ;p
00:52:54 <ion> > repeat 3
00:52:55 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
00:54:23 <Jafet> > replicateM 3 3 $ 3
00:54:24 <lambdabot>   [3,3,3]
00:54:46 <niteria> ok, I was looking for repeat
00:55:25 <Algo> Anyone got any cool ideas for a Haskell program?
00:55:45 <christo_m> Algo: a Lua Compiler ;)
00:56:08 <shachaf> s/Lua/Haskell/
00:56:21 <Jafet> Haskell-to-Lua compiler?
00:56:27 <christo_m> Lua to LLVM
00:57:58 <xarch> Charity compiler!
00:58:01 <Jafet> I want a haskell to brainfuck
00:58:13 <shachaf> Haskell-to-Conway's-game-of-Life.
00:58:28 <christo_m> haha nah im writing it still, no worries
00:58:33 <christo_m> be interesting to see someone elses approach
00:58:35 <christo_m> change of tools, etc
00:58:45 <christo_m> haskell to BF wouldnt be so bad
00:58:51 <christo_m> BF's grammar is pretty easy i think
00:58:56 <ion> > (:) <*> ((:) <*> pure) $ 3
00:58:56 <lambdabot>   [3,3,3]
00:59:00 <christo_m> small number of tokens to wory about
00:59:05 <Jafet> shachaf: Haskell to VHDL?
01:00:31 <Jafet> Well, game of life is harder because of the low speed of light
01:02:21 <rsuniev2> Haskell to Scala
01:03:21 <shachaf> Haskell to efficient x86 executables.
01:03:29 <ion> > (<*>) (<*>) (flip (<*>) pure) (:) 3
01:03:31 <lambdabot>   [3,3,3]
01:04:40 <Jafet> > (<*>) <*> (<*> pure) (:) 3
01:04:40 <lambdabot>   Couldn't match expected type `f (a -> b) -> f a'
01:04:41 <lambdabot>         against inferred t...
01:05:44 <RayNbow`TU> > join replicate 3
01:05:45 <lambdabot>   [3,3,3]
01:05:55 <ion> > ((<*>) <*> ((<*>) pure)) (:) 3
01:05:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
01:06:04 <ion> > ((<*>) <*> (<*> pure)) (:) 3
01:06:05 <lambdabot>   [3,3,3]
01:06:46 <handonson> is there really no better option than { formatTime defaultTimeLocale "%a" } to get the day of the week with the time library?
01:07:57 <shachaf> @let myFavoriteName' = formatTime defaultTimeLocale "%a"
01:07:58 <lambdabot>  <local>:7:0:
01:07:58 <lambdabot>      Multiple declarations of `L.myFavoriteName''
01:07:58 <lambdabot>      Declared...
01:08:01 <shachaf> @let myFavoriteName = formatTime defaultTimeLocale "%a"
01:08:02 <lambdabot>  Defined.
01:08:46 <Jafet> How do you want it better?
01:09:23 <handonson> I mean, if I use it, it's like I get the day with modulo operation, convert it to a string with some case-of, then convert it back to number with another case-of, ...
01:11:51 <Algo> anyone here use Haskell on the job?
01:12:29 <pacak> Algo: I am using it in some areas. At least i wrote several key services with it.
01:19:03 <handonson> so... (as pointed out already... probably more than 64 times...) time, which is supposed to replace old-time, depends on old-locale. tell me about legacy
01:19:59 <Jafet> Well, you can calculate the weekday from Day pretty easily, but I would be surprised if there isn't some code to do that already.
01:20:06 <koala_man> is there a name for the benefit of lazyness where you can just implement some algorithm without considering end conditions? 
01:20:32 <Jafet> End conditions? Like what?
01:20:53 <ion> koala_man: % shuf /usr/share/dict/words | head -n 1
01:20:53 <ion> babooshes
01:21:03 <koala_man> like you can make an infinite list of primes and let the caller decide how far to go, rather than having to specify all that up front
01:21:34 <Jafet> Every time in history someone rediscovers that principle, they give it a different name
01:21:59 <koala_man> how would you explain this to OO-heads in a short sentence?
01:22:05 <ion> babooshes
01:22:10 <Jafet> That's a good name.
01:22:26 <Jafet> Free of preconceptions, unlike many others...
01:22:35 <shachaf> ion: Oh, ha, I thought you were showing how UNIX pipes behave similarly with laziness.
01:22:48 <shachaf> Of course shuf isn't an ideal example of that.
01:23:55 <Kaide> koala_man: They call it an Iterator
01:24:00 <Kaide> or an enumerator if they do .NET
01:25:13 <shachaf> Or a generator in Python?
01:25:37 <koala_man> yes, but it's not necessarily iterators. like Hughes minimax example in "Why Functional Programming Matters". he calls it powerful glue.
01:25:48 <Kaidelong> koala_man: in object-oriented languages the distinction is less important really
01:25:51 <Jafet> So many preconceptions. I'd rather not name it.
01:26:01 <koala_man> fair enough
01:26:05 <Kaidelong> since they work with message passing
01:26:12 <Kaidelong> and state change is allowed
01:26:39 <Kaidelong> so the sharing/laziness advantages just turn into updating advantages
01:41:59 <roelvandijk> Algo: I'm using Haskell to program an embedded system
01:42:30 <pacak> roelvandijk: http://hackage.haskell.org/package/atom? or something else?
01:42:54 <roelvandijk> pacak: We run compiled haskell code on a "normal" pc board, mini ITX
01:43:03 <roelvandijk> pacak: It talks with a microcontroller via USB
01:43:33 <roelvandijk> pacak: Both performance and reliability are important factors
01:44:16 <pacak> mini itx = x86 based?
01:45:25 <roelvandijk> yeah
01:45:27 <roelvandijk> It runs linux
01:48:48 <lunaris> pacak: mini-itx.com for some awesome projects :)
01:49:36 <pacak> lunaris: arm based projects are more awesome.
01:50:05 <lunaris> pacak: Got an mbed myself :D
01:50:25 <pacak> x86 means either crippled Intel Atom or hot and costly core processors.
01:50:42 <lunaris> ARM means extreme hatred and disdain for x86 users. And low power.
01:50:47 <lunaris> xD /troll
01:51:24 <pacak> only for win32 x86 users :-P
01:51:55 <Jafet> Kaidelong: object-oriented programming languages work with message passing, but he was talking about OOP languages
01:52:18 <lunaris> http://homepages.cwi.nl/~ralf/OOHaskell/
01:52:52 <Kaidelong> lunaris: Obsoleted, the the replacement AFAIK is neither mature nor maintained
01:52:56 <Kaidelong> and the*
01:53:36 <Kaidelong> oh wait
01:53:36 <Kaidelong> nm
01:53:40 <Kaidelong> I was thinking of something else
01:53:46 <Kaidelong> OOHaskell is unrelated
01:53:57 <lunaris> :) Good read though.
01:56:29 <roelvandijk> lunaris: Our microcontroller is ARM, so we have a bit of both
01:56:56 <lunaris> roelvandijk: I'm not picky :)
01:57:29 <roelvandijk> lunaris: We control it almost entirely by peeking and poking in its memory via USB commands :-)
01:57:49 <roelvandijk> lunaris: Most stuff we do is not time sensitive, except for 1 loop
01:58:12 <lunaris> roelvandijk: All good then :0
01:59:01 <roelvandijk> It's a very flexible setup. Our hardware guy can add an external device like an ADC and we can program it without having to change to firmware
01:59:17 <roelvandijk> *the firmware
02:01:36 <roelvandijk> It really makes Haskell an executable specification
02:13:34 * hackagebot omnicodec 0.5.0.2 - data encoding and decoding command line utilities  http://hackage.haskell.org/package/omnicodec-0.5.0.2 (MagnusTherning)
02:15:06 * lunaris is jealous of roelvandijk's neat Haskell application ¬_¬
02:41:00 <unfo-> damn you Haskell! Whenever I look at an instance method in my OOP language of choice I feel dirty for not returning a new structure instead of altering the current one >_>
02:48:04 <int-e> unfo-: Even some OO programmers seem to feel that way, e.g., http://www.javapractices.com/topic/TopicAction.do?Id=29
02:49:29 <ezyang> Hmm. If I have a type D a, and to map over it I need a function (forall a a'. D a -> D a'), do I have a valid functor instance? 
02:50:19 <unfo-> int-e, i agree that it's a pretty good design pattern, but unfortunately very weakly used in the libraries i've run across 
02:50:27 <dolio> Whenever you see people arguing that OOP technique has improved these days, the improvements are, "write functional programs." :)
02:50:56 <unfo-> ;)
02:52:38 <lunaris> ezyang: Is this a trick question or do you mean that there's a rank 2 type?
02:52:49 <ezyang> There's a rank 2 type involved. 
02:53:01 <ezyang> In particular D is some GADT with a being a phantom type. 
02:53:09 <lunaris> ezyang: Nice.
02:53:22 <ezyang> Erm, not nice at all, if I can't make a Functor instance! 
02:53:27 <ezyang> ;-) 
02:53:36 <lunaris> ezyang: Can you not make D a functor using a function cast :: D a -> D b; cast = D . unD?
02:53:40 <lunaris> (Or similar)
02:53:50 <ezyang> It has multiple constructors. 
02:54:02 <lunaris> Can you share the definition?
02:54:07 <ezyang> I could erase the phantom types, but then I need to add a bunch of bogus defs. 
02:54:25 <int-e> ezyang: http://www.haskell.org/pipermail/libraries/2011-March/016051.html is related.
02:54:25 <lunaris> Hm.
02:54:36 <ezyang> http://hackage.haskell.org/packages/archive/hoopl/3.8.7.1/doc/html/Compiler-Hoopl.html 
02:54:48 <Eelis> ezyang: doesn't sound very functorial to me :)
02:55:27 <ezyang> Eelis: Perhaps. 
02:55:36 <int-e> ezyang: (so it wasn't haskell-cafe, it was the libraries mailing list)
02:55:49 <ezyang> If there weren't any GADT fanciness, this would be something akin to a multimap. 
02:56:02 <ezyang> (a -> a') -> (b -> b') -> D a b -> D a' b' 
02:56:09 <ezyang> So I could see why it fails to have Functor structure. 
02:56:14 <ezyang> int-e: Ah, I see. 
02:57:27 <Eelis> ezyang: that looks like bifunctor
02:57:47 <ezyang> yes. But it's not a functor, you see. :-) 
02:57:52 <Eelis> indeed
02:58:37 <dolio> Bifunctors are functors.
02:58:49 <ezyang> but you have to pick the correct slot. 
02:59:10 <Eelis> or maybe look at pair categories
02:59:30 <dolio> Well, if your type were really a bifunctor, there should be no problem.
02:59:42 <ezyang> Perhaps. 
02:59:45 <ezyang> "but it's not" 
02:59:47 <dolio> Assuming the instance you want is on the end.
03:00:29 <dolio> bimap :: (a -> a') -> (b -> b') -> D a b -> D a' b' ==> bimap id :: (b -> b') -> D a b -> D a b'
03:01:35 <lunaris> ezyang: Which type is it? Block? (Sorry to pester)
03:01:50 <ezyang> Yes, block. 
03:02:02 <ezyang> I want to map over 'n'. 
03:02:11 <ezyang> and I was wondering if Block had a Functor instance. 
03:02:31 <lunaris> Ok.
03:03:07 <lunaris> And the order of the type parameters is changeable if this is possible?
03:03:19 <lunaris> Or are you planning on using a newtype/type-level flip.
03:03:31 <ezyang> Erm, I'd prefer not havnig to newtype at all. 
03:03:49 <lunaris> ezyang: But surely you want n to be the last type parameter?
03:03:55 * lunaris is probably missing the point.
03:04:07 <ezyang> Notice that n is of kind * -> * -> * 
03:04:20 <ezyang> So you don't have a * type unless you give it the phantom types C and O. 
03:04:41 <lunaris> Ah
03:04:45 <lunaris> I'm an idio.
03:04:47 <lunaris> idiot*
03:04:50 * lunaris reads the code this tie.
03:04:52 <lunaris> time*
03:04:55 <ezyang> Nah, it's tricky code. 
03:05:17 <lunaris> And you want to map over n?
03:05:27 <ezyang> n e x, precisely. 
03:05:36 <lunaris> Assuming it's a bifunctor then? Or is this the hoohah above.
03:06:13 <ezyang> n e x can be thought of three distinct types: n C O, n O O or n O C. 
03:06:22 <rostayob> will function like "onException" catch asyncronous exceptions? or do I have to use "mask"?
03:06:24 <ezyang> so it's actually something like a trifunctor (triforce?) 
03:06:45 <ezyang> rostayob: It will catch async exceptions. 
03:07:03 <ezyang> mask does something different. 
03:07:44 <rostayob> ezyang: yes I think I get what mask does, but in the example they use with onException
03:08:03 <ezyang> mask defers the exception until we exit the masked region. 
03:08:03 <rostayob> ezyang: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Exception.html#v:mask
03:08:10 <ezyang> so it can still be useful to use onException. 
03:08:34 <rostayob> ezyang: oh ok, so the async exception will actually take place after
03:08:49 <ezyang> Oh, this particular example is doing something else. 
03:08:53 <ezyang> Note the use of restore. 
03:09:19 <ezyang> actually, that code is not managing async exceptions, they're just handling normal exceptions. 
03:09:41 <rostayob> ezyang: yeah but why isn't onException enough there?
03:09:42 <ezyang> oh, yes they are, if the exception restre (do_something_with x) terminates with is an async exception. 
03:09:48 <ezyang> Sorry,I'm a little confused :-) 
03:09:52 <rostayob> me too
03:09:53 <rostayob> also because
03:09:59 <dolio> ezyang: Which argument of Block are you trying to define map for?
03:10:10 <ezyang> masks don't magically "absorb" exceptions. They just prevent them from being thrown in the first place. 
03:10:22 <ezyang> So a computation run in restore can throw an async exception. 
03:10:35 <ezyang> dolio: The map function looks like (forall e x. n e x -> n' e x) -> Block n e x -> Block n' e x 
03:10:52 <dolio> Oh, okay.
03:10:54 <rostayob> basically I have this shared MVar, and I want to make sure that I clear it (tryPutMVar) if there is an exception. the thing is that I can't us withMVar because I'm not in IO, so I'm catching exception when I start the application and clearing MVars
03:10:56 <lunaris> ezyang: I can't see a way, but I'm a noob :/
03:11:14 <rostayob> now the thing is that I was looking at the code for withMVar and it uses mask, I can't understand why
03:11:35 <ezyang> rostayob: Why are you not in IO? 
03:11:39 <lunaris> Perhaps the best thing is to define your `trimap'
03:11:53 <ezyang> Nah, the easiest thing right now is to just define the map function manually. 
03:11:54 <rostayob> ezyang: I'm in a MonadIO, so I can't catch exceptions there
03:11:59 <rostayob> but I can throw them
03:12:02 <ezyang> MonadCatchIO... 
03:12:07 <rostayob> well I'm not even sure to be in a monadIO
03:12:33 <rostayob> ezyang: oh cool! I didn't know that!
03:12:57 <rostayob> ezyang: wait, but I'll probably need to define an instance what would include running the transformer and then restarting it
03:13:13 <rostayob> or something like that
03:13:20 <ezyang> I don't know what your monad stack looks like. 
03:13:51 <lunaris> ezyang: That's what I meant; sorry.
03:13:53 <rostayob> ezyang: ServerPartT (ErrorT AppError (ReaderT Context IO))
03:14:02 <rostayob> and I don't want to run ServerPartT
03:14:18 <ezyang> ...huh? 
03:14:35 <ezyang> anyway, I'll leave y'all to it ;-) 
03:14:50 <dolio> ezyang: I don't really see the problem, then. That obviously can't be a Functor, even if you rearrange the arguments, because it has the wrong kind.
03:15:08 <ezyang> dolio: Yes. But it morally feels functor-like. 
03:15:19 <dolio> It's certainly a functor.
03:15:27 <dolio> But it's not a Haskell endofunctor.
03:15:36 <ezyang> Ya. 
03:15:52 <dolio> It's a functor from the category of Hask-bifunctors to Hask.
03:16:06 <rostayob> ezyang: as I suspected, with MonadCatchIO you drop errors silently if you're using ErrorT
03:16:49 <ezyang> ISTR that there were some bugs in some of the instances of MonadCatchIO. 
03:16:54 <ezyang> I don't know if the fixes ever made their way back. 
03:17:40 <rostayob> ezyang: no but it has to be that way, because it'll do runErrorT, catchthe exception, and then "restart" it
03:17:43 <rostayob> I guess
03:18:13 <ezyang> I suggest thinking very carefully what the intended semantics between ErrorT and IO exceptions are. 
03:19:29 <rostayob> ezyang: I use the ErrorT for completely different reasons (it's a webapp and I throw errors and then I display an error page)
03:19:41 <rostayob> it may actually work I didn't think about  but I don't need it
03:20:01 <rostayob> I can just do onException when starting the thread that answers the request anway
03:20:41 <rostayob> the only thing is that I don't understand why the use mask, I mean wouldn't it work without?
03:21:16 <Eelis> are exceptions part of the awkward squad? if not, they ought to be
03:21:30 <ezyang> async exceptions definitely are... 
03:21:45 <Eelis> looks like they are :)
03:21:58 <Eelis> both synchronous and async
03:22:06 <Eelis> good good
03:30:33 --- mode: ChanServ set +o quicksilver
03:30:35 --- mode: quicksilver set -q *!*@224.13.202.84.customer.cdi.no
03:38:32 <mm_freak> Eelis: almost everything, which /requires/ IO is part of it
03:38:50 <mm_freak> (or any other means to model impure things in the pure world)
03:41:39 <mm_freak> although strictly speaking exceptions don't require IO
03:43:03 <mjrosenb> if you have cps-converted all of your code, exceptions look kind of boring
03:46:43 <mm_freak> well, certain kinds of exceptions require IO
03:46:48 <mm_freak> 'error' for example
03:47:36 <mjrosenb> i take it there is no way of preventing error from terminating the program?
03:47:51 <mm_freak> catch the exception?
03:48:01 <mm_freak> 'error' throws an ordinary exception
03:48:12 <mjrosenb> oh, then why does that require IO?
03:48:27 <mauke> :t catch
03:48:28 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:48:40 <morphles> in data declaration can i have kinda alliased fields? ie data Person = Person { name :: string, surname :: string, fullname :: (String, String) } and have it so that fullname would always be (name,surname) without explicitly setting it, ie like if full name would have pointers/references to name and surname.
03:49:03 <mm_freak> mjrosenb: throwing doesn't, but catching does
03:49:47 <mm_freak> morphles: no, but you can write a function 'fullname'
03:49:50 <kosmikus> morphles: why not just define a function for fullname?
03:50:08 <mjrosenb> morphles: i've wanted that.  you should write a wrapper around the constructor and (possibly) destructor
03:50:20 <morphles> well i know i can, just though it would be nice if that were posible :)
03:50:31 <mm_freak> morphles: what would be the difference?
03:50:40 <kosmikus> morphles: if it's always that combination, there's no worth storing it in the datatype
03:50:52 <mm_freak> perhaps you think too much in OOP ;)
03:50:58 <morphles> maybe :)
03:51:03 <mjrosenb> kosmikus: onless you want to avoid recomputing it every time
03:51:06 <mjrosenb> *unless
03:51:11 <mauke> morphles: how would that be useful?
03:51:14 <morphles> im real noob in haskell/fp for now
03:51:20 <kosmikus> mjrosenb: ok
03:51:23 <mm_freak> mjrosenb: you don't need to do anything special to avoid recomputation
03:51:24 <morphles> less code to acces fullname?
03:51:33 <morphles> or not
03:51:37 <mm_freak> morphles: how is "fullname x" less than "fullname x"?
03:51:44 <morphles> yeah :) my bad
03:51:59 <morphles> i just started working with data declarations
03:52:06 <kosmikus> mm_freak: that's not true. recomputation is a valid point (although not in this case).
03:52:12 <mjrosenb> mm_freak: every time you call "fullname foo", it'll build another tuple.
03:52:32 <morphles> :)
03:52:43 <morphles> i cant defend my point but you guys can 
03:52:45 <morphles> cool
03:52:51 <mm_freak> kosmikus: it's an invalid point in haskell, because you would use ordinary sharing in either case
03:53:05 <mm_freak> you wouldn't "copy" the name parts to the full name
03:53:12 <kosmikus> mm_freak: no it's not invalid. people are using this.
03:53:33 <kosmikus> mm_freak: for instance, Data.Map stores the size of the map in the constructors.
03:53:53 <mm_freak> yes
03:54:00 <mm_freak> that's a form of sharing
03:54:08 <kosmikus> well, the idiomatic way to do it then is to use "smart constructors", as mjrosenb suggested.
03:54:17 <mjrosenb> in this case it would be kind of silly, since the data that you are recomputing each time you compute it is just the tuple cell.
03:54:24 <kosmikus> right
03:55:22 * mjrosenb had to strugle to not call it a 'cons cell'
03:55:24 <mm_freak> the additional field wouldn't help at all with efficiency…  it might even decrease it
03:55:40 <mm_freak> IMO it is wrong in haskell to carry around trivial transformations
03:56:13 <kosmikus> yes, I agree ... as long as they really are trivial.
03:56:24 <mm_freak> and especially in this case the whole type is isomorphic to the tuple type and 'fullname' would be just an intermediate step between pattern matching
03:56:40 <mm_freak> i.e. pointless
03:56:44 <mjrosenb> mm_freak: if there were some way ofbeing sure the compiler would cache the value whenever i wanted it cached, then i'd be fine doing that.
03:56:56 <morphles> this was trivial example since im newbie, and havent got my hands in biger data strutures :)
03:57:09 <mm_freak> if 'fullname' would instead generate a string out of the two subnames, then it would make more sense to have the function
03:57:13 <mjrosenb> but if fullname :: String; fullname x = firstname x ++ surname x
03:57:21 <mm_freak> mjrosenb: there is
03:57:22 <mjrosenb> yeah, that.
03:57:28 <mm_freak> mjrosenb: sharing ;)
03:57:42 <mm_freak> morphles: don't worry…  haskell people love to discuss details =)
03:57:49 <morphles> i know i have seen it :)
03:57:54 <morphles> this is cool chanell
03:57:55 <morphles> :)
03:58:12 <morphles> an haskell is cool language, so well kinda expected :d
03:58:22 <mjrosenb> iirc, there is a quote by me that lambdabot has been carrying around related to this topic.
03:58:32 <mm_freak> morphles: you would be astonished to see how trivial matterns can fire up heated discussions with terms you've never heard of before ;)
03:58:42 <morphles> :)
03:59:56 <morphles> im very new to haskell, and generaly new to fp but i plan to write a tbs strategy game with it, i woder how it will go, if i ever get to the point of starting to do something...
04:00:40 <Botje> try to get something working asap
04:00:49 <mm_freak> i agree
04:00:54 <mm_freak> perhaps start with a simpler project
04:00:57 <Botje> or you'll get bogged down in type paralysis limbi
04:01:07 <morphles> well anyone of you know game stars! ?
04:01:18 <rs46> here's a very simple question. Is `sum [1..10]'  computationally cheaper than `sum [1000..100000]' ?
04:01:42 <mm_freak> rs46: yes?
04:01:42 <Botje> a clever enough compiler could compute the number at compile time
04:01:47 <Botje> but otherwise, yes.
04:02:06 <morphles> its networkless multiplayer so to speak, play by email. every persons sensd in orders in files, server computes everything and writes each players state file 
04:02:07 <rs46> oops. 
04:02:19 <rs46> mm_freak: I meant
04:02:21 <morphles> so basicly some input files -> some output files, i thinkg this is suitable task for fp
04:02:50 <mjrosenb> morphles: yes, but baby steps are generally advisable.
04:02:51 <rs46> here's a very simple question. Is `sum [1..10]'  computationally cheaper than `sum [11..20]' ?
04:02:56 <morphles> mjrosenb: i know :)
04:03:06 <mm_freak> morphles: haskell has a steep learning curve, because everything you have done in other languages you will do completely differently in haskell
04:03:09 <Eelis> Botje: do you know if ghc is such a compiler? :)
04:03:12 <Botje> rs46: no.
04:03:25 <mm_freak> morphles: start with a simple todo manager
04:03:29 <mm_freak> or something like that
04:03:34 <Botje> Eelis: no idea. sometimes it's smarter than I want :)
04:03:38 <ion> rs46: Why would it be?
04:03:43 <Eelis> Botje: ok :)
04:03:48 <mjrosenb> Botje: dunno, you may be on a system with 7 bit words
04:03:50 <morphles> well i kinda quickread most of learn you a haskell, and liked it, so i need to start to deepen my understanding
04:04:01 <rs46> really? Is the same true for `sum [1..100]' and `sum [101..200]'
04:04:03 <mjrosenb> Botje: and sum [11..20] makes you go into intinf.
04:04:13 <mjrosenb> err
04:04:15 <morphles> tum i lazy as hell
04:04:16 <kosmikus> if you're working with the Integer type, then working with (really large) integers is slower than working with small ones
04:04:17 <mjrosenb> Integer
04:04:19 <mm_freak> morphles: it even takes a long time to get to the point, where you can say:  "ok, now i've found the ultimate approach to most of the standard tasks is perform"
04:04:19 <morphles> or haskell maybe :d
04:04:35 <kosmikus> but not for Int
04:05:06 <morphles> lazy as haskell would be interesting expression 
04:05:17 <mm_freak> morphles: even for something as simple as reading a file i went a long way from lazy IO over simple strict IO over parsers over iteratees finally to a combination of iteratees and parsers
04:05:34 <rs46> kosmikus: that's what I was thinking about, yes. So the length of both list is the same, but the starting value is higher in the 2nd expression.
04:05:47 <mjrosenb> morphles: that just means that you procrastinate, but eventually do everything you need to do on time.
04:06:10 <mm_freak> morphles: don't worry…  haskell is also lazy as hell ;)
04:06:21 <morphles> i want to start from importand details, kinda top bottom design, start with data processing and general alrgorithms, reading data from file is just details that can be worked out later
04:06:26 <morphles> i can test my code in ghci
04:06:41 <morphles> i think that even simplier, than dig into details of how to read a file :)
04:06:41 <mm_freak> hehe
04:06:47 <mm_freak> first wrong impression of haskell ;)
04:06:53 <morphles> hm? :)
04:06:55 <morphles> how so?
04:07:00 <Jafet> :t readFile
04:07:01 <lambdabot> FilePath -> IO String
04:07:03 <mm_freak> everything is important in haskell…  there are no "unimportant details"
04:07:12 <Jafet> omg, haskell can't read files.
04:07:34 <morphles> well if i have all functions to processing all data, how hard can it be to feed data to them? :)
04:07:57 <morphles> some do portions and that is? :)
04:07:58 <mm_freak> i just told you =)
04:08:01 <morphles> :)
04:08:12 <mm_freak> → even for something as simple as reading a file i went a long way from lazy IO over simple strict IO over parsers over iteratees finally to a combination of iteratees and parsers
04:08:34 <kosmikus> rs46: for fixed-size types like Int, it doesn't matter; it really only makes a difference for unbounded integers, and only if you are beyond the size of 32-bit
04:08:48 <mm_freak> in other languages you don't have much of a choice:  you have simple strict IO and callback-based IO
04:08:52 <Jafet> Well, parsing is universally annoying.
04:09:16 <rs46> kosmikus: thanks, that make sense
04:09:23 <Jafet> When it's not too complicated, it's too slow.
04:10:21 <morphles> in my case slowness is not a problem :) server process will open files, chrunch them for some time and spew output :D
04:10:32 <morphles> thats why i try to not wory about it much :)
04:10:53 <mm_freak> Jafet: tried attoparsec?
04:11:04 <morphles> since the game would be og PBEM kind processing speed shouldnt matter much :)
04:11:13 <mm_freak> morphles: this is haskell
04:11:26 <mm_freak> as said, there are no unimportant details, because haskell makes you worry about everything
04:11:42 <mm_freak> it's just that at some point you get used to it =)
04:11:57 <morphles> :)
04:12:14 <mjrosenb> mm_freak: wait, haskell makes you worry about everything?
04:12:18 <morphles> ill see, it will be a learning experience :)
04:12:24 <morphles> if i ever do that that is
04:12:41 <mjrosenb> mm_freak: in this world, C is zen, because you know you are doomed to failure, and can observe it with a level head?
04:12:56 <Jafet> mjrosenb: it'll keep you up nights wondering whether your utility module was polymorphic enough
04:13:55 <mjrosenb> Jafet: the answer is always "yes", until you realize it isn't
04:14:00 <mjrosenb> never bothered me much.
04:14:18 <ion> readFile :: Stringish a => FilePath -> IO a
04:14:28 <sipa> Stringinsh?
04:14:49 <mm_freak> mjrosenb: i think it's related to the point that once a haskell program compiles, it works
04:15:13 <mm_freak> i often find myself writing pages of code without compiling once
04:15:28 <mjrosenb> mm_freak: i do have to disagree with that generalization, but point taken.
04:15:59 <Jafet> That's a lot of code, given that you're writing in haskell
04:16:59 <mm_freak> Jafet: that's the difference between writing haskell to show haskell and writing haskell for real world applications ;)
04:17:16 <mm_freak> although written in C++ the programs would probably be ten times as long
04:17:37 <mjrosenb> speaking of 'show haskell'
04:18:12 <Jafet> A disproportionately large number of bytes in my code are whitespace in do blocks
04:18:32 <Eduard_Munteanu> Use real tabs :P
04:19:02 <mjrosenb> > let f = scanl (.) id ((+1):f) in take 10 (map ($0) f)
04:19:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:19:12 <Jafet> I can count the indentation of the last line in a block to estimate how complicated it was
04:19:20 * mjrosenb should figure out why that works
04:19:39 <mm_freak> > fix (\r a b -> a : r b (a+b)) 0 1
04:19:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:20:05 <mm_freak> Jafet: i seldomly indent past three levels
04:20:11 <Jafet> > let f = scanl (.) id ((+1):f) in map ($x) f
04:20:13 <lambdabot>   [x,x + 1,x + 1,x + 1 + 1,x + 1 + 1 + 1,x + 1 + 1 + 1 + 1 + 1,x + 1 + 1 + 1 ...
04:20:27 <Eduard_Munteanu> That's usual/good practice in C too.
04:20:29 <Jafet> > let fibs = scanl (.) id ((+1):f) in map ($x) fibs
04:20:29 <lambdabot>   No instance for (SimpleReflect.FromExpr
04:20:30 <lambdabot>                     [SimpleReflect....
04:20:34 <Jafet> > let fibs = scanl (.) id ((+1):f) in map ($x) fibs :: Expr
04:20:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:20:35 <lambdabot>         against inferred ...
04:21:43 <Jafet> That wasn't right anyhow
04:21:52 <mm_freak> fibs = loop; loop a b (Continue k) = k (Chunks [a]) >>== loop b (a+b); loop step = returnI step
04:22:02 <mm_freak> fibs = loop 0 1; loop a b (Continue k) = k (Chunks [a]) >>== loop b (a+b); loop step = returnI step
04:24:19 <frerich> mm_freak: Hm, thanks for making me aware of 'fix'. This function bends my mind.
04:25:02 <mm_freak> morphles: as you can see, even for something as trivial as generating a stream of fibonacci numbers there are incredibly many approaches involving different design patterns, data structures and more
04:28:00 <morphles> i think similar is tru for all programing languages? :) 
04:29:08 <frerich> > [x | x <- [1..2], x <- [1..3]]
04:29:08 <mjrosenb> morphles: possibly, but usually fibonacci doees not giv such profound insights into the power, and subtlties of a language.
04:29:09 <lambdabot>   [1,2,3,1,2,3]
04:29:22 <frerich> How is that evaluated? Mentioning "x <-" twice is somehow terribly confusing.
04:29:47 <mjrosenb> frerich: it should be equivalent to [x | _ <- [1..2], x <- [1..3]]
04:30:30 <frerich> mjrosenb: Errr... that looks strange. I think I didn't really understand list comprehensions.
04:30:39 <Eduard_Munteanu> Someone should post this... http://www.willamette.edu/~fruehr/haskell/evolution.html
04:31:23 <mm_freak> frerich: you may want to try to rewrite them to their 'do' forms
04:31:28 <mjrosenb> frerich: you are saying for every element in the list [1..2], discard the value, and ...
04:31:38 <mjrosenb> frerich: so you end up with 2 copies of the list.
04:31:46 <mm_freak> > do x <- [1..2]; y <- [1..3]; return (x,y)
04:31:47 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
04:32:01 <mjrosenb> and yes, the do or >>= forms would probably be clearer for this.
04:32:26 <frerich> Aaah, and now I also see why the first 'x' is actually ignored.
04:32:47 <mm_freak> frerich: it's not ignored
04:32:54 <mm_freak> it's just shadowed…  you can't access it
04:33:02 <mm_freak> it still influences the outcome of your computation
04:33:19 <mm_freak> > [ x | x <- [1..2], x <- [1..3] ]
04:33:20 <lambdabot>   [1,2,3,1,2,3]
04:33:25 <mm_freak> > [ x | x <- [1..3] ]
04:33:26 <lambdabot>   [1,2,3]
04:34:01 <unfo-> why does that first one work like that?
04:34:31 <mm_freak> > [ (x, y) | x <- [1..2], y <- [1..3] ]
04:34:33 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
04:34:46 <mm_freak> the first version is just the same, but limits itself to using y
04:35:01 <mm_freak> x is still there and defined as 1 for the first iteration and 2 for the second
04:35:05 <ion> >>= in the List monad does something akin to “for each”. For each item in [1..2]: for each x in [1..3], append x to the result.
04:36:04 <unfo-> mm_freak, ah. thanks
04:36:50 <ion> @src List (>>=)
04:36:51 <lambdabot> Source not found. I feel much better now.
04:36:54 <ion> @src (>>=) List
04:36:54 <lambdabot> Source not found. Maybe you made a typo?
04:36:58 <ion> meh
04:37:07 <hpc> (>>=) for lists is a lot easier to reason about if you use the fmap/join definition of it
04:40:08 <ivanm> preflex: seen axman6
04:40:08 <preflex>  axman6 was last seen on #haskell-blah 21 hours, 53 minutes and 52 seconds ago, saying: a likely story
04:48:48 <RayNbow`TU> @let rotations = zipWith (++) <$> tails <*> init.inits
04:48:49 <lambdabot> Plugin `eval' failed with: Ambiguous infix expression
04:48:57 <RayNbow`TU> @let rotations = zipWith (++) <$> tails <*> (init.inits)
04:48:58 <lambdabot>  Defined.
04:49:14 <RayNbow`TU> > rotations "foobar"
04:49:15 <lambdabot>   ["foobar","oobarf","obarfo","barfoo","arfoob","rfooba"]
04:52:48 <parcs> > let rotations = zipWith (++) <$> tails <*> init <$> inits in rotations "foobar"
04:52:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:53:16 <parcs> hmm, thought <$> has lower precedence than <*>.
05:03:44 <parcs> > let rorations = zipWith (++) <$> init . tails <*> inits in rotations "foobar"
05:03:46 <lambdabot>   ["foobar","oobarf","obarfo","barfoo","arfoob","rfooba"]
05:05:05 <parcs> > let rotations = zipWith (++) . init . tails <*> inits in rotations "foobar"
05:05:07 <lambdabot>   ["foobar","oobarf","obarfo","barfoo","arfoob","rfooba"]
05:05:15 <parcs> okay, i'm done now
05:35:55 <ezyang> Which direction does a derived Ord instance go? 
05:36:04 <ezyang> is it a < b < c or a > b > c? 
05:36:36 <ivanm> I think the former
05:36:58 <ivanm> as in, data Foo = Bar | Baz deriving Ord has Bar < Baz
05:37:05 <ezyang> k 
05:49:24 * hackagebot SafeSemaphore 0.5.0 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.5.0 (ChrisKuklewicz)
05:53:04 <osoleve> why doesn't {getFileName >>= \path -> openFile path ReadMode} work if getFileName :: IO FIlePath?
05:53:38 <osoleve> it says "Couldn't match expected type FilePath -> a0 with actual type IO FilePath
05:54:56 <Saizan> ?hoogle openFile
05:54:56 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
05:55:26 <Saizan> osoleve: are you use getFileName has that type?
05:55:32 <Saizan> ?hoogle getFileName
05:55:32 <lambdabot> System.IO.Error ioeGetFileName :: IOError -> Maybe FilePath
05:55:51 <osoleve> Saizan: I wrote it
05:57:27 <Saizan> osoleve: if you ":t getFileName" in ghci, what do you get?
05:58:01 <osoleve> getFileName :: IO FilePath
05:59:24 <osoleve> do I need to extract the FilePath from IO FilePath somehow?
06:00:27 <mauke> more context needed: actual code/errors
06:00:54 <osoleve> getFileName is simply {putStr "foo" >> getLine}
06:01:09 <mauke> that's a syntax error
06:01:48 <Saizan> ?type let getFileName = putStr "foo" >> getLine in getFileName >>= \path ->  openFile path ReadMode
06:01:48 <osoleve> oh?
06:01:49 <lambdabot> Not in scope: `openFile'
06:01:49 <lambdabot> Not in scope: data constructor `ReadMode'
06:02:15 <Saizan> ?type let getFileName = putStr "foo" >> getLine in getFileName >>= \path ->  System.IO.openFile path System.IO.ReadMode
06:02:16 <lambdabot> IO GHC.IO.Handle.Types.Handle
06:02:21 <Saizan> it works
06:02:34 <Saizan> so the error must be about something else you haven't shown us
06:03:35 <Saizan> and don't use {} to delimit code, since they are part of haskell's syntax
06:03:50 <osoleve> http://hpaste.org/45613/getfilename
06:04:15 <osoleve> that's all there is
06:04:33 <Loid> Hello
06:04:52 <Saizan> the problem is the type signature on openMFile
06:05:10 <Saizan> should be openMFile :: IO Handle
06:05:30 <osoleve> ah, thank you
06:05:40 <osoleve> i'm in way over my head, this is how i learn :)
06:47:13 <HugoDaniel> tree data structures are so easy to implement in haskell!
06:47:13 <HugoDaniel> truly the superior language
06:48:47 <pacak> Hugglesworth: Did you tried LISP?  tree data structures are so easy to implement in LISP!
06:51:45 <unfo-> isn't lisp itself a tree data structure?
06:52:26 <Jafet> Sup dawg we herd u liek trees
06:53:00 <pacak> It is. And you can create lisp program as data structure using lisp macrosses and then eval it :)
06:54:00 <roelvandijk> Can you view a list as a sort of tree without branches?
06:54:20 <HugoDaniel> i did some lisp coding some years ago in univ. i dont recall it as a nice experience
06:54:20 <pacak> sure: '(1 2 3 4 5 6 7 8 9 10)
06:54:27 <roelvandijk> In that case it would be better to call them trunks :-)
06:54:45 <Botje> roelvandijk: well, usually trees have data only in the leaves
06:55:33 <pacak> data Tree a = Leaf a | Branch a (Leaf a) (Leaf a)
06:55:59 <pacak> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
06:56:17 <roelvandijk> Botje: That is true, but can those tree's represent the same data as the tree type pacak just gave?
06:56:29 <kosmikus> there's no general requirement for trees to have data only in the leaves; and yes, of course lists are trees
06:56:56 <roelvandijk> From now on I shall call lists trunks
06:57:40 <Jafet> newtype Tree = Tree [Dynamic]
08:00:53 <Tomas> Volatile: woosh :P
08:03:55 <Volatile> Tomas: \o/
08:07:59 <illissius> @djinn (b -> c) -> (b -> a) -> (c -> a)
08:07:59 <lambdabot> -- f cannot be realized.
08:08:13 <illissius> er, hm.
08:10:00 <sipa> @djinn (a -> b) -> (b -> c) -> (a -> c)
08:10:00 <lambdabot> f a b c = b (a c)
08:10:53 <ion> f a b = b . a
08:10:59 <ion> f = flip (.)
08:11:29 <ion> @. pl djinn (a -> b) -> (b -> c) -> (a -> c)
08:11:30 <lambdabot> f = flip (.)
08:14:18 <Silvah> http://hpaste.org/45617/ - how are these "| condition = value" called?
08:14:29 <tromp_> guards?
08:15:22 <Silvah> tromp_: thanks.
08:22:57 <EvanR-work> anyone know Text.Blaze? im wondering if theres any point to the monad instance for HtmlM
08:23:09 <EvanR-work> seems to be only used for Monoidal activity
08:23:46 <aristid> EvanR-work: it is.
08:23:52 <aristid> it's the worst hack ever.
08:23:55 <EvanR-work> ah ok
08:24:27 <aristid> do notation looks so nice ;)
08:24:46 <EvanR-work> so begins the slippery slope into the awful world of web values
08:25:30 <aristid> "web values"?
08:25:35 <EvanR-work> i just made that up
08:26:00 <EvanR-work> emphasis on the way stuff feels to the loudest people
08:26:06 <monochrom> as opposed to web computations :)
08:26:23 <jmcarthur> yeah i hate it when people use monads for monoids just for the sake of do notation
08:26:42 <jmcarthur> lists really aren't that bad
08:26:49 <EvanR-work> ya
08:27:08 <EvanR-work> maybe haskell should have dedicated monoid syntax to stop this abuse
08:27:21 <Botje> won't SOMEONE think of the monoids!
08:27:23 <jmcarthur> it has it. it's called lists
08:27:40 <monochrom> web functor :: (monad -> computation) -> (web monad -> web computation)
08:27:43 <cheater> a monad is a monoid in the category of endofunctors, eh
08:27:47 <jmcarthur> well, that's syntax for the free monoid at least
08:27:55 <jmcarthur> which is just fine
08:28:22 <EvanR-work> web developers would say that the commas are untenable
08:28:25 <EvanR-work> in so many words
08:28:30 <jmcarthur> they can get over it
08:28:32 <EvanR-work> lol
08:28:33 <aristid> if you have (<>) = mappend, using that isn't that bad either.
08:28:41 <aristid> EvanR-work: stop the groupthink.
08:29:00 <EvanR-work> how does one person groupthink
08:29:18 <jmcarthur> but thinking the way a group would
08:29:20 <jmcarthur> *by
08:29:26 <aristid> thinking in groups of people, homogenising the heterogenous and son on
08:29:26 <EvanR-work> im not thinking that way
08:29:26 <cheater> lol
08:29:45 <aristid> EvanR-work: why do you generalise "web developers", then?
08:29:58 <osoleve> if I have a string of alternating chars and numbers delimited by whitespace, how would I form a list of pairs of ("chars", digit)?
08:31:01 <EvanR-work> based on a survey of published web developer wisdom, they should be reallocated to forced labor camps, thats all
08:31:06 <Botje> split (c:d:rest) (cs,ds) = split rest (c:cs, d:ds)
08:31:17 <Botje> or
08:31:20 <aristid> EvanR-work: and that is groupthink.
08:31:25 <tromp_> use splitEvery 2 . words
08:31:25 <Botje> split (c:d:rest) = (c,d) : split rest
08:31:31 <EvanR-work> dont blame, me, blame them
08:31:33 <Botje> followed by unzip
08:32:30 <aristid> EvanR-work: i can certainly blame some web developers, but not the whole class.
08:32:40 <osoleve> Botje: if they're whitespace delimited, wouldn't that grab the whitespace, too?
08:32:48 <Botje> uh, right
08:32:55 <EvanR-work> me neither, just the ones who are loudest
08:33:05 <osoleve> and the chars can be one or two chars long
08:33:17 <Botje> osoleve: ah. you didn't say that.
08:33:19 <osoleve> hence ("char", digit)
08:33:21 <osoleve> sorry
08:33:39 <monochrom> web developers don't form a group, not even a monoid XD
08:33:50 <aristid> nor a ring :)
08:34:18 <EvanR-work> web developers are a field extension
08:34:21 <osoleve> Botje: an example would be:
08:34:42 <EvanR-work> adjoin retardation
08:34:55 <osoleve> "A 2 F# 4" becomes [("A",2),"F#",4)]
08:35:04 <osoleve> err, with a missing paren in there
08:36:02 <Botje> osoleve: oh. then do what tromp_ said
08:36:23 <osoleve> mmk, i'll try it out, thanks
08:37:13 <EvanR-work> html-minimalist looks promising
08:37:21 <osoleve> wait, where is splitEvery located? hoogle doesn't find it :/
08:38:23 <tromp_> import Data.List.Split
08:38:31 <osoleve> thank you
08:40:27 <morphles> Where/how can i see of what classes the type is instance? Ie i started playing with Ratio, and since round works on it i see that is instance of RealFrac but it would be good to know more
08:40:52 <EvanR-work> :info Ratio
08:40:59 <asdafdsfsddfgdfg> or just :i
08:41:03 <morphles> ah thanks
08:41:18 <morphles> i though what whas shortcut for that :) 
08:41:27 <Jafet> @instances RealFrac
08:41:27 <lambdabot> Double, Float
08:41:44 <Jafet> Oh, other way round
08:41:49 <EvanR-work> , Rational
08:42:17 <Jafet> > 0 % 0
08:42:18 <lambdabot>   *Exception: Ratio.%: zero denominator
08:42:26 <Jafet> @instances-importing Data.Ratio RealFrac
08:42:26 <lambdabot> Double, Float, Ratio a
08:42:34 <EvanR-work> Rational and Data.Fixed are amazing, amazing!
08:42:39 <Jafet> Typical.
08:43:01 <morphles> What is Fixed?
08:43:14 <Jafet> Fixed-point arithmetic
08:43:21 <Jafet> Where every number is a fixed point
08:43:24 <morphles> ah
08:43:29 <morphles> cool stuff
08:43:36 <EvanR-work> it exports some standard base ten fixed point types such as Centi Micro and Nano
08:43:47 <EvanR-work> so like 1.10, dollar and ten cents
08:44:01 <EvanR-work> is a Centi value
08:45:33 <ksf_> don't use that in an accounting package, though.
08:45:49 <EvanR-work> no?
08:45:53 <ksf_> iirc at least euros are supposed to be calculated to three or four decimal places.
08:46:09 <ksf_> you can't just round off everything below one cent.
08:46:11 <EvanR-work> you can define Fixed E4
08:46:52 <EvanR-work> im using Pico for intermediate calculations and then rounding to 2 3 or 8 as the case may be
08:47:30 <ksf_> well, that may work for your ledger files, but don't do that if you're a bakn.
08:47:32 <ksf_> *bank
08:47:47 <EvanR-work> why?
08:48:01 <mjrosenb> rounding errors *will* occur
08:48:04 <Jafet> As if banks let you code their balance sheets in haskell
08:48:20 <EvanR-work> rounding errors wont occur
08:48:28 <ksf_> well, even when you're a company and your accounting is off by the odd cent, the authorities aren't going to buttfuck you.
08:48:57 <morphles> ksf_: didint you mean are going to buttfuck? :)
08:49:03 <ksf_> if you're a bank, though, and calculate interest wrong, your only chance is to prey.
08:49:15 <ksf_> for the odd cent, no.
08:49:15 <quicksilver> preying is what banks mainly do.
08:49:20 <EvanR-work> if it comes out that the purchase price is 1.234556000000 then so be it
08:49:22 <ksf_> they're going to wristslap you.
08:49:26 <morphles> dunno i heard in my country they will :)
08:49:30 <quicksilver> that was an excellently appropriate typo :)
08:49:41 <ksf_> and interpret any error to their advantage when it comes to taxes and stuff.
08:50:08 <ksf_> the law stipulates "orderly accounting", that's not a thing that has a rulebook.
08:50:41 <ksf_> depends on type of corporation, too, though, non-persona bound corporations have more duties.
08:51:01 <EvanR-work> im interested to know if you have any specific tips besides 'dont use Data.Fixed'
08:51:12 <ksf_> yes. hire a lawyer.
08:51:16 <EvanR-work> ah
08:51:21 <ksf_> and an accountant.
08:51:24 <monochrom> haskell programmers like to work at the Klingon Bank of Prey :)
08:51:32 <ksf_> you need someone you can fire if the books are wrong.
08:51:42 <HugoDaniel> how do i transform a Maybe a into a [a]  ?
08:51:48 <EvanR-work> this may be helpful, but not illuminating
08:51:54 <Jafet> :t catMaybes
08:51:55 <lambdabot> forall a. [Maybe a] -> [a]
08:52:02 <HugoDaniel> nah
08:52:07 <ksf_> @hoogle Maybe a -> [a]
08:52:07 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:52:08 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
08:52:08 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:52:08 <HugoDaniel> i want to change the monad
08:52:15 <HugoDaniel> ah cool
08:52:17 <HugoDaniel> thanx
08:52:18 <tromp_> :t fromMaybe
08:52:19 <lambdabot> forall a. a -> Maybe a -> a
08:52:39 <tromp_> @hoogle Maybe a -> [a]
08:52:39 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:52:39 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
08:52:39 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:53:15 --- mode: quicksilver set -o quicksilver
08:53:18 <tromp_> > toList (Just 42)
08:53:19 <lambdabot>   Not in scope: `toList'
08:53:48 <aristid> > maybeToList (Just 42)
08:53:49 <lambdabot>   [42]
08:54:19 <aristid> :t msum . Data.Foldable.toList
08:54:20 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (MonadPlus m, Data.Foldable.Foldable t) => t (m a) -> m a
08:54:49 <aristid> :t mconcat . Data.Foldable.toList
08:54:50 <lambdabot> forall a (t :: * -> *). (Monoid a, Data.Foldable.Foldable t) => t a -> a
08:55:22 <morphles> haskells type inferance is amazing stuff 
08:55:44 <EvanR-work> anyone have opinion on heist?
08:55:45 <aristid> morphles: yes.
08:56:11 <aristid> EvanR-work: the snap people probably do
08:56:58 <Jafet> :t maybe [] pure `asTypeOf` catMaybes . pure `asTypeOf` maybeToList
08:56:58 <lambdabot>     Precedence parsing error
08:56:58 <lambdabot>         cannot mix `asTypeOf' [infixl 9] and `.' [infixr 9] in the same infix expression
08:56:58 <lambdabot>     Precedence parsing error
08:58:27 <morphles> @hoogle roundTo
08:58:27 <lambdabot> No results found
08:58:53 <aristid> Jafet: head [x,y,z] is easier to use than `asTypeOf` :)
08:59:21 <mjrosenb> :t asTypeOf
08:59:22 <lambdabot> forall a. a -> a -> a
08:59:25 <mightybyte> EvanR-work: Do you have any specific questions about it?
08:59:36 <xarch> how do you define coapplicative functors in term of cozippable functors (and `pure`)?
08:59:42 <xarch> terms*
09:00:09 <copumpkin> coapplicative functors?
09:00:09 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
09:00:43 <EvanR-work> mightybyte: no
09:00:53 <EvanR-work> is it good, do people like it
09:01:19 <xarch> they don't exist?
09:01:30 <mightybyte> I like it.  But then...I wrote it.  I've been using it at work recently and I'm finding really pleasant to use.
09:01:37 <xarch> I thought I saw something mentionning them
09:01:45 <copumpkin> xarch: what are they defined as? lax monoidal  functors on the opposite category? 
09:02:06 <xarch> I don't know
09:02:07 <copumpkin> comnoidal functor?
09:02:10 * copumpkin shrugs
09:02:17 <mightybyte> EvanR-work: Chris Smith seems to like it.  http://cdsmith.wordpress.com/2011/02/05/html-5-in-haskell/
09:02:17 <copumpkin> I can't think of what it would do in haskell
09:02:48 <xarch> maybe comonoidal functors
09:03:23 <xarch> there was something to do with a f (Either a b) -> Either (f a) (f b), I think
09:04:07 <mightybyte> EvanR-work: I think it is especially useful in situations where the Haskell coder and the HTML designer are different people.
09:04:28 <xarch> hm
09:04:55 <EvanR-work> mightybyte: heh. this blog is advertising NOT heist ;)
09:05:37 <xarch> hm, actually I think they can't exist in haskell
09:05:46 <xarch> I'm not sure though
09:06:00 <copumpkin> xarch: well, f (Either a b) -> Either (f a) (f b) can't be written safely
09:06:14 <EvanR-work> mightybyte: yes that is an interesting scenario
09:06:32 <EvanR-work> for my purposes i am the one designing and implementing the page, but often i wish i werent
09:06:35 <mightybyte> EvanR-work: Huh?  Chris was not involved in the original development of Heist, so he was originally an unbiased third party.  
09:06:39 <xarch> hm, ok
09:06:49 <xarch> so I guess I should just forget about them
09:07:35 <mightybyte> EvanR-work: Yes, that's my situation too, but I still find myself liking how the decoupling of the two roles lets me work.
09:10:03 <mightybyte> EvanR-work: I have written a couple more blog posts that will be published later this week illustrating some of the ways you can use Heist.
09:10:53 <luite> mightybyte: what's the url of your blog?
09:11:05 <mightybyte> http://softwaresimply.blogspot.com
09:11:26 <luite> I'd be interested, since I've only used snap for a web service so far, with no html involved :)
09:11:27 <EvanR-work> alright
09:12:05 <mightybyte> luite: I'll probably post links on haskell.reddit.com too.
09:12:25 <luite> hmm, I have to admit that I don't really use reddit
09:13:46 <mightybyte> I think they also usually show up on planet.haskell.org
09:15:49 <Saizan> xarch, copumpkin: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=69 ?
09:16:17 <xarch> oh oh!
09:16:20 <xarch> thanks!
09:17:29 <copumpkin> lol
09:18:26 <gwern> 'Short of eating the author's brain, you will not find a better way to learn this powerful language than reading Learn You a Haskell for Great Good!' bwa ha ha
09:19:15 <Saizan> braaains
09:19:49 <Saizan> sorry, for the obvious joke, i just woke up and i feel a bit like a zombie
09:20:00 <jonkri> are you supposed to be able to access the module documentation in the hackage test upload? the modules (which in exposed-modules) are listed on the page but are not links
09:20:51 <Saizan> no, that gets generated separately even for the real uploads
09:21:00 <jonkri> aha ok
09:21:04 <jonkri> thanks Saizan :)
09:23:49 <xarch> do you have some good reading about uses of the codensity monad please?
09:27:05 <HugoDaniel> can i print a string to stderr without having to wrap my function in the IO monad ? :P
09:27:27 <ion> f = "message to stderr"
09:27:35 <ion> main = putStrLn f
09:28:05 <HugoDaniel> :P
09:28:22 <ion> :t interact
09:28:23 <lambdabot> (String -> String) -> IO ()
09:28:28 <thoughtpolice> :t trace
09:28:29 <lambdabot> Not in scope: `trace'
09:28:30 <thoughtpolice> aw
09:28:46 <ion> :t Debug.Trace.trace
09:28:47 <lambdabot> forall a. String -> a -> a
09:28:50 <thoughtpolice> ah, there it is
09:29:10 <thoughtpolice> in that case you can just do 'trace "this will be printed" $ 1+2', but it will print to stdout, not stderr
09:29:39 <ion> It goes to stderr.
09:29:55 <thoughtpolice> ah, it does
09:29:58 <thoughtpolice> #ifndef __GLASGOW_HASKELL__ hPutStrLn stderr msg
09:30:00 <thoughtpolice> #else
09:30:54 <osoleve> when trying to load this file, why do I get the error "Couldn't match expected type IO String -> t0 with actual type IO String" at line 57?
09:30:57 <osoleve> http://hpaste.org/45618/error
09:31:34 <Botje> noteValuePair needs more arguments
09:31:42 <Botje> *noteValuePairs
09:31:44 <HugoDaniel> cool
09:31:47 <HugoDaniel> trace is great :D
09:31:56 <Botje> also, your type for test is dubious.
09:32:05 <ion> osoleve: Also, IO a -> b is probably either wrong or evil. :-)
09:32:09 <ion> or both
09:32:26 <copumpkin> that's a pretty awesome type
09:32:41 <osoleve> how should I go about extracting a string from a file to process it? :/
09:32:44 <Botje> osoleve: test has type IO [(String, Int)]
09:33:08 <Botje> .. if the second line is return (noteValuePairs n (something))
09:33:24 <HugoDaniel> :)
09:33:42 <osoleve> ooh! it compiled!
09:33:44 <osoleve> thanks!
09:33:47 <Botje> actually, disregard my noteValuePairs remark, I was looking wrong
09:34:30 <osoleve> it compiles AND it works. thanks guys :)
09:35:37 <Botje> osoleve: yeah, stuff that compiles generally works :)
09:35:52 <Botje> osoleve: for future reference, think twice if you receive IO something as a parameter
09:36:10 <osoleve> okie dokie, thank you
09:36:39 <osoleve> i'll be back for more help (probably often...) i'm tackling a project that I have no idea how to do, so I can learn :)
09:36:45 <Botje> by taht , I mean consider refactoring your code, not "think twice" as in "you were stupid" :)
09:37:02 <Botje> (given that IRC doesn't carry tone as a useful sidechannel)
09:37:31 <osoleve> Botje: given my history in this channel, I take everything that's said with a friendly, helpful tone :3
09:37:55 <Botje> osoleve: okay. have fun hacking!
09:38:54 <morphles> Haskell newbies question: is haskell easy/simple to refactor?
09:39:02 <Botje> yes. totally.
09:39:34 <copumpkin> well, in some ways yes, other ways no
09:42:56 <aristid> if you make mistakes while refactoring, they will often (not always) be detected by the compiler, making it a bit easier psychologically
09:43:23 <mjrosenb> there are a bunch of things you can do to make refactoring easier
09:44:03 <mjrosenb> also, i have seen either the sml or haskell guide say "to refactor this, you change the type signature of the thing you want to refactor, then fix all of the compiler errors"
09:44:17 <mjrosenb> i feel that this is not actually a useful refactoring strategy.
09:44:19 <dons> mjrosenb: delay putting in type sigs if you expect refactoring
09:44:33 <dons> unless you're unsure of the change
09:44:39 <dons> if unsure, using types to check the work is essential
09:45:20 * mjrosenb rarely puts type signatures in until either i need to do it for sanity reasons, or i want to ship the code
09:49:16 <Lemmih> @seen dcoutts 
09:49:16 <lambdabot> Unknown command, try @list
09:49:16 <preflex>  dcoutts was last seen on #ghc 1 hour, 9 minutes and 39 seconds ago, saying: great
09:54:18 <tawe> Why this code (http://pastebin.com/5Yn9nRRy) gives 'Last generator in do {...} must be an expression' error in WinHugs?
09:57:33 <Lemmih> @seen lennart
09:57:33 <lambdabot> Unknown command, try @list
09:57:33 <preflex>  Sorry, I haven't seen lennart
09:57:47 <Lemmih> preflex: @seen dons
09:57:47 <preflex>  dons was last seen on #haskell 13 minutes and 9 seconds ago, saying: if unsure, using types to check the work is essential
09:58:13 <Lemmih> dons: Around?
09:58:59 <copumpkin> @seen augustss
09:58:59 <lambdabot> Unknown command, try @list
09:58:59 <preflex>  augustss was last seen on #haskell 17 days, 1 hour, 7 minutes and 34 seconds ago, saying: tux_mark_5: unpackClosure#
09:59:14 <whald_> tawe, you identation is wrong
09:59:15 <Lemmih> dons: It's a big thorn in my side that binary is so inefficient at encoding small bytestrings. I'm not sure how to fix it, though. Do you have any ideas?
10:00:37 <gwern> how can binary be inefficient at bytestrings? that'd seem to be something it could be good at
10:00:46 <Lemmih> dons: Even something like 'encodeBunch :: Binary a => [a] -> [ByteString]' would solve the problem if it would share a single cache.
10:00:59 <Lemmih> gwern: It allocates 32k for each encoding.
10:01:27 <whald_> tawe, this one works: http://hpaste.org/45619/getline
10:02:35 <Lemmih> gwern: Binary is great if you're doing big chunks of work but it is pretty much infeasible to encode many small values.
10:03:08 <tawe> whald_, thanks, it works :)
10:03:45 <dons> Lemmih: pong
10:04:02 <dons> Lemmih: noted. we could tune the size. document. provide special cases. 
10:09:17 <Lemmih> dons: Tuning the buffer size wouldn't really fix the problem. Making the buffer size configurable probably has significant performance implications. Ideally it should be possible to reuse buffers in some safe way.
10:09:53 <tawe> whald_, I thought it was a silly error. I took your function, change the name to getLine2 and dies. :/
10:11:15 <Lemmih> dons: This is pretty much a show-stopper for things like acid-state (formerly known as happstack-state). If we can figure out how to solve the problem then I'd be more than willing to write the code.
10:11:27 <tawe> whald_, http://hpaste.org/45620/
10:11:28 <whald_> tawe, just make sure that all statements after a "do" line up
10:12:03 <whald_> tawe, the "if c ..." and the "c <- ..." don't line up, see?
10:12:37 <Lemmih> Binary is about three orders of magnitude slower than it should be in acid-state's usecase.
10:12:40 <tawe> whald_ damn...
10:12:45 <whald_> tawe, that's why i usually put the first expression after a "do" on a new line, so it doesn't matter if the "do" moves a little because of functions renames
10:12:46 <tawe> whald_, im sorry. thanks
10:12:58 <whald_> tawe, np
10:16:32 <Lemmih> dons: Bunch encoding is not possible due to the way Builders are defined. Do you think we could change that without hurting performance too much?
10:18:06 <copumpkin> Lemmih: how does blazer-builder compare?
10:18:15 <copumpkin> or is it not applicable?
10:22:05 <Lemmih> copumpkin: I'm not sure. I'll have a look.
10:25:09 <morphles> does haskell have arbitrary vectors(well i bet it does, i just dont know them:) )? that is strings of numbers, for witch operators such as * + - etc are defined
10:25:39 <Zao> morphles: There's a bunch of packages for things like that.
10:25:42 <Zao> Like vector-space, etc.
10:25:58 <morphles> in standart haskell distribution?
10:26:07 <Zao> Define "standard haskell distribution" :)
10:26:15 <morphles> well ghc :)
10:26:17 <Zao> GHC? Hugs? Haskell Platform? Hackage?
10:27:00 <Entroacceptor> > (1,2,3) + (4,5,6)
10:27:01 <lambdabot>   (5,7,9)
10:27:03 <morphles> of course i gues one can easily simulate this using lists
10:27:22 <luite> vector-space is probably what you're looking for, but you can't use + and *, since they belong to the Num type class
10:28:19 <boegel> is there a way to programatically determine whether there's an instance for a given type and type class?
10:28:45 <illissius> boegel: Language.Haskell.TH.isClassInstance
10:28:47 <boegel> e.g. whether Char has an instance for the Enum type class
10:28:53 <boegel> illissius: oh, wow, thx :)
10:28:59 <morphles> hm maybe ill just my fav type, lists :)
10:29:01 <boegel> @type Language.Haskell.TH.isClassInstance
10:29:01 <lambdabot>     Not in scope: `Language.Haskell.TH.isClassInstance'
10:29:10 <illissius> boegel: that's template haskell though
10:29:10 <boegel> @vixen that's fine honey
10:29:10 <lambdabot> there are a lot of weirdos on here
10:29:14 <illissius> there's no way in 'normal' haskell
10:29:16 <luite> morphles: how would you define multiplication for two lists?
10:29:20 <morphles> map (+) = +; and silly me vector * vector is ...
10:29:32 <morphles> same goes for vectors
10:29:39 <morphles> its only defined for some dimensions iirc
10:29:47 <illissius> boegel: even then, it only tells you whether there's an instance in scope, not whether one exists in the program globally
10:29:48 <morphles> that is cros product
10:29:54 <boegel> illissius: I'm not familiar with template Haskell
10:29:54 <luite> yes you mean vector product (or cross/outer product)
10:30:01 <luite> only for 3 dimensions
10:30:04 <luite> and 7 i believe
10:30:08 <morphles> yes
10:30:13 <morphles> something like that 6 or 7
10:30:15 <boegel> illissius: oh, I'm looking for some hoogle-like functionality...
10:30:36 <morphles> so basicaly i need + and * Num
10:30:37 <luite> morphles: and you need scalar multiplication
10:30:40 <morphles> yes
10:30:42 <illissius> boegel: anyway, why do you want this?
10:30:45 <boegel> illissius: e.g. only show functions which I can apply without "changes" to the type
10:30:50 <morphles> but thats like too easy to do with lists :)
10:30:50 <luite> so it's really not quite the same as Num :)
10:30:54 <morphles> lists are the awsome
10:31:02 <morphles> yeah
10:31:05 <boegel> illissius: I'm looking into implementing some GP framework to evolve Haskell programs
10:31:17 <morphles> map (*5) ie :)
10:31:23 <Lemmih> copumpkin: It seems to have exactly the same problem.
10:31:35 <luite> morphles: but have a look ad vector-space, it has type classes for vector spaces, additive groups and inner product spaces
10:31:38 <illissius> boegel: if you're familiar with lisp macros, template haskell is sort of like that
10:31:39 <morphles> tuples, that i somehow find hard to like
10:31:49 <luite> morphles: and it uses associated types for the scalar field
10:31:50 <morphles> im kinda noob in fp :)
10:31:54 <boegel> illissius: and I'm planning to use Hoogle to find functions I can apply to a given expression/value
10:32:12 <boegel> illissius: I'm not familiar with lisp, nor with lisp macros
10:32:16 <luite> morphles: so you can use your own type as long as you provide instances for those classes
10:32:29 <boegel> illissius: do you think Template Haskell is worth looking into for something like GP?
10:32:30 <illissius> boegel: referring back to your original question, define 'programmatically'
10:32:52 <illissius> GP = Genetic P..?
10:33:05 <boegel> illissius: Genetic Programming
10:33:12 <illissius> was about to guess.
10:33:22 <boegel> illissius: I start from a value of a certain type, and then search for functions I can apply on it using Hoogle
10:33:48 <boegel> illissius: problem is Hoogle also returns functions for which a typeclass instance is required, but not necessarily there
10:33:55 <tromp_> anyone here familiar with "convert" for image conversion?
10:34:06 <luite> imagemagick convert right?
10:34:08 <morphles> in data declaration, only type can go after ::? or can you specify class?
10:34:11 <tromp_> yes
10:34:20 <tromp_> i'm trying to blow up a bitmap
10:34:31 <tromp_> replace each pixel by 8x8 
10:34:58 <illissius> boegel: oh, i see. in ghci you can do :i classname to get a list of instances (in the modules ghci currently has imported? i think)
10:35:02 <illissius> anyway, bbiab
10:35:02 <tromp_> but convert -resize seems to be doing all kinds of averaging
10:35:11 <boegel> tromp_: should be easy with imagemagick I think (but I don't know how immediately)
10:35:14 <tromp_> making the image blurry
10:35:37 <boegel> illissius: yeah, an indirect way like that is fine...
10:35:39 <luite> try -filter Lanczos
10:35:53 <luite> which does truncated sinc interpolation
10:36:03 <tromp_> it also changes 2 colors to 46:(
10:36:18 <luite> oh
10:36:19 <tromp_> why do they make the simple things hard:-?
10:36:40 <luite> you want -filter Point perhaps
10:37:07 <tromp_> that looks better
10:37:29 <luite> still two color?
10:37:36 <tromp_> yep!
10:37:39 <luite> ok good :)
10:37:43 <tromp_> funny that isnt the default
10:38:01 <tromp_> thanks for help. wld take me forever to figure out
10:38:11 <luite> according to the manual the default is Mitchell or Lanczos
10:38:22 * hackagebot hums 0.3.3 - Haskell UPnP Media Server  http://hackage.haskell.org/package/hums-0.3.3 (BardurArantsson)
10:38:29 <luite> which are good choices for resizing photographs
10:39:16 <luite> at least for non-adaptive methods
10:50:11 <whald_> given an "a" and a "m [a]" (for some Monad m) , how do i get the a to join the party in the "m"? that's what i'm missing in line 12 of http://hpaste.org/45623/paths
10:50:50 <Jafet> :t liftM2 (:)
10:50:51 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
10:51:04 <c_wraith> :t liftM2 (:) . return
10:51:04 <lambdabot> forall a1 (m :: * -> *). (Monad m) => a1 -> m [a1] -> m [a1]
10:51:21 <Lemmih> whald_: Do you have an error message?
10:51:49 <c_wraith> alternatively,
10:52:07 <whald_> Lemmih, no, the code on hapaste compiles without problems, but generates an empty list
10:52:21 <c_wraith> :t \a mas -> do { as <- mas ; return $ a : as }
10:52:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m [a] -> m [a]
10:52:26 <Jafet> Photorealistic path tracing... with lists?
10:52:35 <whald_> Lemmih, which is expected behaviour
10:52:44 <whald_> Jafet, yes
10:53:08 <whald_> Jafet, i have a working implementation which does path tracing in one ugly function
10:53:41 <whald_> Jafet, and i wanted to split this in "path generation" and "path evaluation" which would both be simpler
10:58:12 <morphles> let say i write a function, without type declaration, and compiles and works well, but then i specify type for that function in such a way that due to constrains from function type specification function cannot be caried out, will haskell complain?
10:59:24 <Botje> it will throw an error that i cannot satisfy the typeclass constraints if you try to use it.
10:59:49 <morphles> Thanks for an answer
11:00:11 <Botje> :t \x -> [x] `div` [x]
11:00:11 <lambdabot> forall t. (Integral [t]) => t -> [t]
11:01:25 <whald_> c_wraith, thank you. i tried lifting a bunch, but just lifting the (:) did not come to my mind. they feel so special... just have to get used to it
11:01:50 <c_wraith> whald_: thank Jafet.  He originated the answer, I just tweaked it :)
11:02:22 <whald_> Jafet, c_wraith thank you both
11:02:41 <c_wraith> :t \a -> liftM (a:)
11:02:42 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m [a] -> m [a]
11:02:48 <c_wraith> heh.  That's the shortest version :)
11:03:18 <Botje> liftM . (:) -- shorter!
11:04:23 <c_wraith> change it to fmap if you're so interested in losing characters. :)
11:04:46 <c_wraith> Really, I just wanted the fewest semantic units
11:05:25 <whald_> c_wraith, i stumbled upon fmap when playing with this, but did not see how it really fits
11:05:30 <morphles> @hoogle (Floating a, Integral b) a -> b
11:05:30 <lambdabot> Warning: Unknown type Floating
11:05:30 <lambdabot> No results found
11:05:37 <c_wraith> whald_: fmap is the same as liftM
11:06:29 <morphles> @hoogle (Floating a, Integral b) => a -> b
11:06:29 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
11:06:29 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
11:06:29 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:06:49 <morphles> @hoogle (Floating a, Integral b) => b -> a
11:06:50 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:06:50 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:06:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:06:56 <c_wraith> @src Floating
11:06:56 <lambdabot> class  (Fractional a) => Floating a  where
11:06:56 <lambdabot>     pi                                                      :: a
11:06:56 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
11:06:56 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
11:06:56 <lambdabot>     (**), logBase                                           :: a -> a -> a
11:07:42 <whald_> c_wraith, liftM is for monads, fmap for functors. that's the same?
11:07:59 <ion> Every monad is a functor.
11:08:21 <c_wraith> If you have a monad instance for something, you can make a functor instance with fmap = liftM
11:08:35 <morphles> Can i pattern match against class?
11:08:39 <luite> morphles: are you looking for round or something?
11:08:56 <morphles> well i wass surprised taht ** need first argument to be floating
11:09:01 <morphles> needs*
11:09:06 <luite> you can't pattern match types, you match values
11:09:09 <c_wraith> morphles, there's also ^ and ^^
11:11:19 <morphles> ^ will do
11:11:27 <luite> morphles: you can do something like: f :: (Floating a) => a -> String      f a | round a == 1 = "It is close to one!"
11:11:40 <luite> but those are guards, not pattern matches
11:12:14 <morphles> guards guars, i goota cheak learn you a hasskell to remember them
11:13:26 <morphles> hm i dont see there anything about guarding against types/classes
11:13:48 <morphles> but im probably thinking in a wrong way
11:13:50 <morphles> :)
11:13:52 <luite> err you can't guard against a type
11:14:30 <morphles> as i said i most like think nosenses can forget wha i asked
11:14:43 <morphles> this is most likely infection from dynamicly typed languages or sdomething
11:14:48 <morphles> it should pass :)
11:15:02 <luite> but if you add a typeclass constraint, you can use functions that require this class (and methods from the type class itself) in the guards
11:15:13 <dfilimon> hi guys, i have a problem compiling some code under linux
11:15:23 <dfilimon> ghc testbed.hs -o test
11:15:25 <dfilimon> this simple statement
11:15:30 <dfilimon> (which works in os x i might add)
11:15:33 <dfilimon> dies in linux
11:15:34 <luite> morphles: perhaps it would help if you have an example of what you want to do
11:15:38 <ion> --make?
11:15:41 <dfilimon> because i've also used a BoardManip.hs
11:15:44 <Botje> dfilimon: always compile with ghc --make, instead
11:15:58 <dfilimon> i should add --make?
11:15:58 <luite> --make is the default in ghc 7
11:16:03 <morphles> i a kind of person who often does not have examples : i think in abstract terms and what ifs often :)
11:16:11 <dfilimon> well, that might be something, i use ghc 7 in os x
11:16:28 <dfilimon> :)
11:16:30 <dfilimon> yup, it worked
11:16:33 <dfilimon> thanks a bunch
11:18:44 <luite> morphles: don't know if it helps, but for example a function f :: a -> a, has to work for all types a. which means that you cannot do too much with it, since there are only a few things that you can do with such a general type
11:19:15 <morphles> luite: yeah i understand that
11:19:29 <luite> morphles: if you add a context, or typeclass constraint, f :: (Floating a) => a -> a, you restrict the types for which f works to those with a Floating instance, that means that you can do more, because you know more about the type
11:20:39 <morphles> :t  sqrt $ foldl (\a x -> a+x**2) 0
11:20:40 <lambdabot> forall b. (Floating b) => [b] -> b
11:20:50 <morphles> that is what i would expect
11:20:58 <morphles> but my ghci says:
11:21:04 <morphles>  (Floating ([b] -> b), Floating b) => [b] -> b
11:21:10 <morphles> why could that be?
11:21:38 <morphles> i dont understand what the point of first part
11:21:40 <luite> you probably want . instead of $
11:22:04 <morphles> hm
11:22:04 <luite> lambdabot has some strange instances for functions
11:22:28 <morphles> $ means do everything to the right before doing stuff on the left?
11:22:32 <byorgey> morphles: think about the type of  foldl (\a x -> a+x**2) 0
11:22:38 <ion> Yet again all that stuff in lambdabot is confusing people. :-)
11:22:46 <byorgey> morphles: no, $ just means to apply the function on the left to what's on the right
11:23:02 <morphles> hm so . means what i said previously?
11:23:08 <ion> < ion> More generally, (f!g) (h!i) = f!g $ h!i where ! can be almost any operator.
11:23:12 <byorgey> O dpm
11:23:20 <byorgey> I don't know what you said previously, but . is function composition
11:23:22 <luite> morphles: no, but . is what you mean ;p
11:23:29 <byorgey> that is,  (f . g) x = f (g x)
11:23:40 <morphles> well yes
11:23:40 <luite> :t foldl (\a x -> a+x**2) 8
11:23:41 <lambdabot> forall b. (Floating b) => [b] -> b
11:23:46 <morphles> that i totaly dont understand $
11:23:55 <morphles> than*
11:23:55 <byorgey> f $ x = f x
11:23:58 <byorgey> that's the definition
11:24:03 <morphles> an the point of it?
11:24:09 <morphles> and*
11:24:11 <byorgey> it also has very low precedence, which sometimes help avoid parentheses
11:24:17 <morphles> hm
11:24:29 <byorgey> e.g.  blah blah $ foo bar   instead of  (blah blah) (foo bar)
11:24:40 <morphles> ah
11:24:42 <whald_> byorgey, and then comes hlint and tells you to replace all that "$" with parentheses :-)
11:24:43 <morphles> thanks
11:24:49 <djahandarie> morphles, one reason is the precedence. The other reason is that you can explicitly pass around ($)
11:24:53 <byorgey> whald_: hehe, does it?
11:25:00 <djahandarie> morphles, for example, map ($)
11:25:03 <djahandarie> :t map ($)
11:25:04 <lambdabot> forall a b. [a -> b] -> [a -> b]
11:25:09 <kjslag> :t \xs -> sqrt $ foldl (\a x -> a+x**2) 0 xs
11:25:10 <lambdabot> forall b. (Floating b) => [b] -> b
11:25:17 <djahandarie> Though this isn't very useful :p
11:25:19 <kjslag> that's probably what you meant morphles
11:25:19 <djahandarie> :t map ($ 3)
11:25:20 <lambdabot> forall a b. (Num a) => [a -> b] -> [b]
11:25:28 <whald_> byorgey, sometimes yes, sometimes not, did not really investigate it
11:25:35 <morphles>  :t  sqrt . foldl (\a x -> a+x**2) 0
11:25:36 <ion> > map ($2) [(1+), (3*)]
11:25:37 <lambdabot>   [3,6]
11:25:44 <morphles> no this is what i mean i think
11:25:47 <morphles> :t  sqrt . foldl (\a x -> a+x**2) 0
11:25:47 <lambdabot> forall b. (Floating b) => [b] -> b
11:25:54 <byorgey> those are the same
11:26:00 <morphles> gives me vector lenght i think
11:26:16 <morphles> yeah but i dont need xs :)
11:26:17 <luite> > (sqrt $ foldl (\a x -> a+x**2) 0) [1..3]
11:26:18 <lambdabot>   3.7416573867739413
11:26:22 <luite> > (sqrt . foldl (\a x -> a+x**2) 0) [1..3]
11:26:24 <lambdabot>   3.7416573867739413
11:26:25 <luite> hehe
11:26:45 <morphles>  (sqrt . foldl (\a x -> a+x**2) 0) [3,4]
11:26:48 <byorgey> morphles: I would write that using 'map' and 'sum' instead of with a fold.
11:26:50 <morphles> >  (sqrt . foldl (\a x -> a+x**2) 0) [3,4]
11:26:51 <lambdabot>   5.0
11:27:02 <byorgey> luite: stop being evil
11:27:27 <morphles> dunno some time ago someone here said that folds are good
11:27:31 <morphles> ot something like that :)
11:27:35 <luite> byorgey: sorry just wanted to check whether the evil lambdabot instances would give the same result here
11:27:35 <morphles> or*
11:27:39 <byorgey> > sqrt . sum . map (**2) $ [1..3]
11:27:41 <lambdabot>   3.7416573867739413
11:27:55 <morphles> pointless style eh? :)
11:28:06 <byorgey> morphles: of course folds are good.  so are airplanes.  but I wouldn't use an airplane to get to the grocery store ;)
11:28:06 <morphles> not bad
11:28:09 <morphles> nice to look at
11:28:09 <djahandarie> morphles, you can implement a map whenever you have a fold, so I don't see why you should stick to fold :)
11:29:03 <morphles> fold avoids creating another list doesnt it?
11:29:22 <luite> ghc could probably optimize that away anyway
11:29:35 <morphles> otho this optimization topics are thing i shouldint concern myself for quite seime time
11:29:41 <morphles> yeah
11:29:45 <kjslag> > sqrt . sum . map (^2) $ [1..3]
11:29:46 <djahandarie> morphles, technically it does, but GHC has an optimization that merges the maps and sums and such into one
11:29:47 <lambdabot>   3.7416573867739413
11:30:02 <morphles>  > sqrt . sum . map (^2) $ [1..300]
11:30:04 <morphles> :)
11:30:09 <morphles> > sqrt . sum . map (^2) $ [1..300]
11:30:11 <lambdabot>   3007.4989609308263
11:30:39 <morphles> lambdabot is a cool guy :)
11:31:42 <djahandarie> morphles, girl
11:31:47 <morphles> :))
11:31:49 <c_wraith> @vixen asl
11:31:49 <lambdabot> 19/f/California
11:31:52 <djahandarie> @vixen are you a girl?
11:31:52 <lambdabot> yup, i'm all woman
11:32:02 <morphles> :DDD
11:32:04 <djahandarie> @vixen are you a man?
11:32:04 <lambdabot> nope, i'm a girly
11:32:11 <djahandarie> Wow, pretty extensive
11:32:21 <morphles> someone put quite some work into it
11:32:30 <luite> it's the first strong AI :p
11:32:33 <djahandarie> @vixen Do you pass the turing test?
11:32:33 <lambdabot> yes
11:32:34 <morphles> :D
11:32:48 <djahandarie> @vixen Do you not pass the turing test?
11:32:48 <lambdabot> let me answer that later, okay?
11:32:51 <djahandarie> Damn!
11:32:54 <morphles> :D
11:32:57 <barshirtcliff> @vixen how are you feeling today?
11:32:58 <lambdabot> i am wonderful, thanks for asking!
11:33:10 <morphles> @vixen do you like me?
11:33:11 <lambdabot> sure, i like you so far
11:33:12 <ion> @vixen Are you a bot or a human?
11:33:12 <lambdabot> why does everyone ask i'f on a bot?
11:33:13 <azaq23> @vixen Is this sentence false?
11:33:14 <lambdabot> nevermind about that
11:33:18 <ion> @vixen Are you an automaton?
11:33:18 <lambdabot> good question
11:33:30 <morphles> :D
11:33:36 <barshirtcliff> @vixen what is the meaning of life?
11:33:36 <lambdabot> i'm not sure what i mean
11:33:43 <ion> @vixen Is there a way to break you?
11:33:43 <lambdabot> what about me?
11:33:54 <whald_> @vixen can you email photos?
11:33:54 <lambdabot> i sure can
11:33:54 <morphles> @vixen do you like haskell?
11:33:54 <lambdabot> church is my favourite computer scientist.
11:34:02 <morphles> :D
11:34:06 <whald_> wow :-)
11:34:09 <morphles> yeah
11:34:14 <morphles> this was weird
11:34:23 <ion> @vixen What is the sum of two and three?
11:34:23 <lambdabot> nevermind about that
11:34:38 <whald_> @vixen 2+3
11:34:39 <lambdabot> you're cute. :)
11:34:45 <whald_> :D
11:34:49 <morphles> :)
11:35:03 <morphles> so i have function to find length of "vector" list of number
11:35:54 <morphles> now i want function to add two vectors, that would be zipwith i guess, but adding two vectors of different lenght would be nonsencial, so i have to have some guards i guess to prevent that?
11:36:15 <morphles> :t zipWith (+)
11:36:17 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
11:36:32 <luite> > zipWith (+) [1,2] [2,4,6,8]
11:36:33 <lambdabot>   [3,6]
11:36:49 <Botje> vectorAdd l1 l2 | lenght l1 /= length l2 = error "PEBCAK"
11:36:53 <morphles> and in math that doesnt make much sense does it?
11:36:57 <Botje> except with length written correctly.
11:37:07 <morphles> :)
11:37:31 <djahandarie> morphles, there are tricks to enforce the lists to be the same length on the type level. But that is some fairly advanced stuff so it's probably not recommended at this stage :p
11:37:41 <morphles> ok :)
11:38:41 <morphles> ether way i wouldnt want to have them fixed lengh in compiled code, but maybe they wouldnt be with what you suggest so dunno maybe you should disregard this :)
11:39:08 <monochrom> I don't think you should worry too much
11:40:20 <c_wraith> isn't GHC 7.2 supposed to have a type-level-natural extension?
11:40:24 <luite> after a while, when you are more comfortable with the type system, you should think about starting to worry too much ;)
11:41:16 <c_wraith> I look forward to massively incompatible libraries becoming available at that point.  "version with typed size, version without, they don't like to talk to each other!"
11:41:51 <djahandarie> c_wraith, it's suppose to
11:42:00 <thoughtpolice> c_wraith: i don't know if it's definitively scheduled, but the hope is it'll be in 7.2, yes
11:42:13 <luite> oh interesting, is it already in head?
11:42:20 <thoughtpolice> luite: no
11:42:25 <djahandarie> luite, it was ready to merge, but it didn't
11:42:37 <thoughtpolice> http://code.galois.com/cgi-bin/gitweb?p=type-naturals/ghc.git;a=shortlog;h=refs/heads/type-nats
11:42:37 <monochrom> good riddance
11:42:45 <luite> oh ok, it would've given me an excuse to check the new git tree :)
11:42:50 <thoughtpolice> that's iavor's branch with the type-nats stuff inside
11:44:19 <kleinucopia> is there a hoogle for hackage?
11:44:27 <thoughtpolice> personally I'd like to see it mainline. things like vector-static could finally be usable without insanities, for example. i think there are some concerns about how to give proofs for certain types and whatnot, however
11:44:31 <thoughtpolice> which is outside of the scope of iavor's cope
11:44:32 <monochrom> no, but hackage has a search box
11:44:36 <thoughtpolice> *iavor's scope
11:44:46 <thoughtpolice> kleinucopia: http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:44:52 <thoughtpolice> linked to at the top of the hackage page
11:45:19 <osoleve> okay, let's go through these one at a time
11:45:19 <kleinucopia> thoughtpolice: thanks, that's what I wanted.
11:45:25 <osoleve> whoops, wrong channel
11:45:39 <thoughtpolice> kleinucopia: i don't know how often the indexes are updated, but for the most part it all seems pretty recent IMO
11:45:44 <thoughtpolice> er, IME
11:46:03 <kleinucopia> I actually did find Hayoo once, I just forgot about it.
11:46:38 * hackagebot DRBG 0.2.2 - Deterministic random bit generator (aka RNG, PRNG) based HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.2.2 (ThomasDuBuisson)
11:46:44 <kleinucopia> I've never seen any API search as nifty as hayoo/hoogle.
11:47:57 <morphles> i agree :)
11:48:38 * hackagebot monadcryptorandom 0.3 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.3 (ThomasDuBuisson)
11:52:03 <TeXitoi> hi
11:52:14 <TeXitoi> http://texitoi.eu/~texitoi/k-nucleotide.my.hs
11:52:42 <TeXitoi> I'd like style/efficiency remarks if possible
11:53:14 <TeXitoi> and how can I parallel force the 'ms' list?
11:57:14 <Lemmih> ?tell dons You know what? Nevermind, allocating bytestrings seems to have gotten a lot faster in ghc-7 so it's not that big of a problem anymore.
11:57:14 <lambdabot> Consider it noted.
12:02:30 <osoleve> i'm trying to cabal install alsa, but it says c2hs can'tbe found
12:02:43 <osoleve> however, if i do c2hs --version, it comes up
12:02:54 <osoleve> what am i doing wrong?
12:02:55 <osoleve> :(
12:03:10 <Cin> Trying to build YHC:
12:03:12 <Cin> $ scons configure
12:03:12 <Cin> scons: Reading SConscript files ...
12:03:12 <Cin> IOError: [Errno 2] No such file or directory: '_darcs/inventory':
12:03:18 <Cin> What’s all that about?
12:03:34 <Cin> I'm not familiar with darcs.
12:03:42 <osoleve> whatever you have available
12:03:46 <osoleve> whoops
12:06:26 <boegel> osoleve: shopping for dope? :P
12:07:18 <osoleve> advising someone in another channel as to whether they should begin programming on linux or windows (right now for them, it doesn't matter either way)
12:07:28 <monochrom> osoleve: that's strange. is c2hs in ~/.cabal/bin? is ~/.cabal/bin in PATH?
12:07:59 <osoleve> monochrom: ooh
12:08:10 <monochrom> use vmware or virtualbox or ... to set up linux and play there
12:08:50 <monochrom> (windows is a bit programmer-unfriendly unless you pay $$$ for VS, and then it becomes too programmer-friendly)
12:09:16 <osoleve> monochrom: we're advising him to try both ways and see which he prefers
12:09:29 <monochrom> that is the best advice
12:10:10 <monochrom> still, a virtual machine helps a long way (e.g. saves reboot time)
12:10:49 <osoleve> seconded
12:11:25 <luite> haskell is much easier on linux
12:11:42 <monochrom> my general advice for "the ghc installer for windows has bugs" "the ghc installer for mac hates macports" is "install virtualbox, put linux there, put ghc there" :)
12:12:20 <tensorpudding> that's not good advice for getting people to use GHC though
12:12:25 <monochrom> still, the ghc windows story is already better than the ocaml windows story
12:13:18 <monochrom> the ghc people actually care, and actually all the past bugs are silly hardcoded pathname typos like "E:\myghc" out of the blue
12:13:28 <tensorpudding> yuck
12:13:41 <monochrom> whereas the ocaml people are like "windows is not posix-compliant, therefore we don't support it"
12:13:43 <luite> ghc works relatively ok on windows, but you ironically need more knowledge about "the unix way" of installing stuff than if you had used linux
12:14:11 <luite> on linux, you can usually in install the required development libraries with apt-get or similar
12:14:24 <luite> on windows you need to configure msys, use autotools yourself, figure out LDFLAGS
12:14:37 <Saizan> someone should invent a windows way of installing libraries
12:14:57 <tensorpudding> the haskell software center
12:15:21 <monochrom> the said pathname bugs are only from the installer. if you build ghc yourself from an older good ghc, you don't even get the bugs.
12:15:36 <Saizan> i meant for C :)
12:16:59 <kleinucopia> if a library provides a monad, call it M a, but no function such as runM :: M a -> IO a, how does one interact with the monad, such as for printing, etc.?
12:17:10 <osoleve> okay, so i'm still having problems with the cabal install, and .cabal/bin is in my path :/
12:17:35 <Botje> kleinucopia: doesn't it hide the runM function in the M a definition?
12:18:03 <osoleve> nevermind, got it :)
12:18:06 <luite> osoleve: do you have an error message or something?
12:18:07 <luite> oh ok
12:18:31 <kleinucopia> Botje: this is kind of a hypothetical. I was using libraries that do provide a runM-like function.
12:18:50 <kleinucopia> I am new to monads, so it took some time to figure out how to get these M a values into IO so I can touch them.
12:19:04 <monochrom> an abstract monad type M without any extra things exported is useless, yes
12:19:19 <luite> hehe most people new to monads want to get stuff out of IO ;p
12:19:21 <shachaf> kleinucopia: You usually don't want M a -> IO a.
12:19:43 <monochrom> but I haven't seen one such M, really
12:20:09 <monochrom> (I can write one if you like. I mean I doubt that you're looking at one)
12:20:16 <luite> somehow most library authors don't want their monads to be useless
12:20:33 <shachaf> data Null a = Null; instance Monad Null where ... Oh.
12:20:44 <monochrom> return x = Null
12:20:51 <monochrom> x >>= y = Null
12:20:55 <monochrom> fail _ = Null
12:21:00 <kleinucopia> shachaf: the libraries I'm using all access web APIs, so anything they give back comes wrapped up in a special monad
12:21:03 <Botje> "the monad is free but the run method will cost ya"
12:21:13 <kleinucopia> they each provide some flavor of runM
12:21:38 <kleinucopia> otherwise, how can I take things from an M a and do anything useful?
12:21:40 <shachaf> kleinucopia: In general you need *some* function.
12:21:47 <shachaf> kleinucopia: Usually IO is a bad thing and you want to avoid it.
12:21:48 <TeXitoi> monochrom: that's the unit monad, no?
12:21:51 <shachaf> @ty runState
12:21:52 <lambdabot> forall s a. State s a -> s -> (a, s)
12:21:59 <luite> kleinucopia: sometimes you can just pattern match on the constructor, for example with Maybe or []
12:22:02 <monochrom> well there you go, you have a runM, why ask a speculative question?
12:22:03 <shachaf> @ty runIdentity
12:22:03 <lambdabot> forall a. Identity a -> a
12:22:10 <shachaf> @ty fromMaybe
12:22:10 <lambdabot> forall a. a -> Maybe a -> a
12:22:37 <kleinucopia> shachaf: so I'd assume these drop you in IO since they've already touched the network
12:22:52 * osoleve <3's Google
12:22:56 <kleinucopia> specifically, I'm using the hs-twitter, ffeed, etc. APIs.
12:22:56 <shachaf> kleinucopia: OK, maybe, but that's specific to these in that case.
12:22:57 <osoleve> haha wrong channel
12:23:04 <kleinucopia> shachaf: I understand what you mean.
12:23:17 <monochrom> "<3 Google" is never in the wrong channel :)
12:23:41 <kleinucopia> you want to expose the right kind of function for your monad.
12:24:02 <kleinucopia> almost akin to the accessors of an object, but without all the OO-cruftiness.
12:24:29 <monochrom> the notion of accessor dates way back before OO
12:24:47 <monochrom> any paper on abstract data types at all has to mention it
12:26:08 <monochrom> for example David Parnas has a paper on specifying abstract data types using traces (of operations), and accessors are key. because specifying an abstract data type hinges on what observations you can or cannot make.
12:26:43 <kleinucopia> monochrom: of course, we could get as abstract as you want. But then heads will implode.
12:26:52 <kleinucopia> :)
12:27:30 <aristid> osoleve: google watches all channels, so it doesn't matter where you express your love :)
12:28:01 <osoleve> i just want to be assimilated, that's all.
12:28:08 <monochrom> I am not sure what prompts that remark. who said anything about going way too abstract?
12:28:17 <MacMagnus> is it very difficult to make a function that differentiate stuff?
12:28:42 <kleinucopia> no one did, I am just saying that my OO comment is just a single concrete example of the concept you are thinking of.
12:34:28 <kleinucopia> MacMagnus: haskell's pattern matching makes a symbolic differentiation function pretty easy to get started with.
12:35:01 <kleinucopia> there are some examples of simple ones on line which handle quite a few standard forms.
12:35:28 <Saizan> symbolic differentiation can actually be done in quite a cunning way by making the right instance of the numeric classes
12:36:40 <luite> but you need to be a bit more cunninger if you want to make it efficient
12:36:40 <kleinucopia> apropos: http://www.haskell.org/haskellwiki/Functional_differentiation
12:37:18 <Cin> Anyone managed to build yhc recently?
12:37:25 <kleinucopia> it was kind of fun watching in the SICP videos the pattern-matching framework being built by hand.
12:37:32 <kleinucopia> haskell takes a lot of work off your shoulders.
12:37:56 <monochrom> it is why I am not thrilled about scheme
12:39:12 <thoughtpolice> Cin: yhc is pretty much dead
12:39:17 <MacMagnus> kleinucopia: thanks!
12:39:26 <kleinucopia> MacMagnus: yqw.
12:39:27 <thoughtpolice> Cin: what do you want yhc for?
12:40:23 <Heffalump> Cin: re your question on #darcs, about _darcs/inventory, recent versions of darcs use a differently named file with a different format. I suspect the build system doesn't expect that.
12:40:58 <Cin> Heffalump: Seems that way.
12:42:29 <Heffalump> if you can figure out what the script is doing you can probably get it to use a darcs command instead
12:45:50 <Cin> Heffalump: I think it's trying to get the current version. I commented it out… will see if this builds. It has a bunch of scripts to automatically pull other repos when building, it's kind of horrid. We'll see.
12:47:00 <Cin> Copying patch 290 done, 1828 queued. Happy days.
12:47:06 <Cin> thoughtpolice: For compiling to JavaScript.
12:48:32 <thoughtpolice> Cin: yhc may work there, but again, it's basically dead and nobody has committed code to it for a year or two at this rate
12:48:38 <thoughtpolice> you'd probably be better off using something like ghcjs
12:48:44 <thoughtpolice> but i don't know about it's current status/stability
12:48:51 <thoughtpolice> https://github.com/sviperll/ghcjs
12:49:34 <Cin> I'm aware of it. GHC is failing to build for me right now so I'm trying yhc.
12:49:56 <thoughtpolice> well, older GHC's typically don't build with newer GHC's as it isn't tested/supported, so that probably makes sense
12:50:13 <thoughtpolice> no telling how much work is needed to make ghcjs work with ghc HEAD, although based on the size of the code base, probably not a whole lot
12:50:33 <thoughtpolice> some parts of the simplifier etc changed though, and most of the type checking machinery
12:51:22 <thoughtpolice> er, I also meant to say in the first sentence that new GHC's don't build *old* ghc's, and since ghcjs is slated to use ghc 6.12.1, that's what you need to make a compilation work
12:51:33 <thoughtpolice> (so you can't use ghc7 for example, which was more of my point)
12:51:50 <Cin> I was trying to build 6.12.3 with 6.12.3 installed.
12:52:45 <thoughtpolice> oh, in that case it should work. you may just have something broken on your system that prohibits a build i'd speculate
12:52:59 <thoughtpolice> ah, ghcjs also requires a 32-bit environment.
12:53:03 <thoughtpolice> so no x86_64 :(
12:53:13 * thoughtpolice hates that restriction.
12:53:15 <Cin> I am on 32-bit.
12:53:27 <thoughtpolice> i have 8+ extra registers. i want code to use them. :(
12:53:39 <Cin> I'm also considering building GHC with clang and outputting llvm and using emscripten.
12:54:23 <Cin> Doesn't really work from what I've read, though.
12:54:26 <thoughtpolice> Cin: that's currently not possible due to technical limitations (for the most part)
12:54:29 <Cin> http://www.dmpots.com/blog/2010/05/08/building-ghc-with-clang.html
12:55:15 <thoughtpolice> if you disable global pinned registers, you can probably get the RTS to compile under clang
12:55:24 <thoughtpolice> the problem is, that doing so breaks the LLVM calling convention that GHC requires
12:55:32 <Cin> That's what the linked article says.
12:55:59 <thoughtpolice> (in a nutshell, LLVM depends on certain globals being pinned to registers. if you don't enable registers, STG regs are pushed on stack locations, but LLVM code generated by GHC will still look in registers, resulting in disaster more than likely)
12:56:23 <Cin> yhc failed to build.
12:56:27 <thoughtpolice> of course, you can probably fix this pretty easily, providing you can just make LLVM understand the GHC calling convention, when arguments are passed on the stack, not in registers
12:56:28 * Cin closes the terminal
12:56:32 <Cin> Back to ghcjs.
12:56:36 <thoughtpolice> that will require changes to LLVM and GHC, though
12:57:06 <thoughtpolice> the global register variable situation is easily the thing that complicates it the most
12:57:48 <Cin> I'm not really interested in hacking build internals and runtime problems. I have limited time with a bunch of projects already, I just wanted to try *something* that would output JS. There seem to be no stable solutions.
12:58:15 <thoughtpolice> and clang doesn't support global register variables, go figure. on that note, even if it did, it's up to debate what emscripten would do with such pinned registers, and how they make sense in JS
12:58:52 <luite> Cin: perhaps a library for generating javascript is a more viable alternative at the moment?
12:58:55 <thoughtpolice> (and it would also require emscripten to understand the LLVM calling convention pins *very* specific registers, and somewhow match that up with the bitcode produced by compiling the RTS, which is unclear)
12:59:02 <thoughtpolice> luite: that's what I was going to suggest
12:59:11 <thoughtpolice> i wrote a little code to write JS/html5 canvas stuff in haskell several months ago
12:59:13 <luite> hah beat ya ;)
12:59:21 <thoughtpolice> it never got that far, but I just used a DSL on hackage for javascript and HTML
12:59:57 <Cin> DSLs are fundamentally different to this, really.
12:59:59 <thoughtpolice> https://github.com/thoughtpolice/canvas-hs < simple examples, i didn't have enough time to polish it into anything usable
13:00:13 <thoughtpolice> Cin: of course they are, but you still reap most all of the benefits of haskell, since it's your meta language
13:01:40 <Cin> If writing verbose cumbersome error-prone code that can't use any Haskell libraries and barely any of the type system is ‘all the benefits’, yeah.
13:01:42 <thoughtpolice> code synthesis of the DSL nature is extremely well-suited for such things IMO, despite all the nice things you'd gain from having GHC actually compile to JS, natively.
13:02:16 <thoughtpolice> ? you can perfectly use the type system to enforce invariants still, although granted, the library situation is a problem.
13:02:29 <luite> using haskell libraries would probably be a problem anyway, unless you don't mind having the client download megabytes of generated javascript
13:02:40 <thoughtpolice> yeah, emscripten's demos are something like 12mb
13:02:45 <thoughtpolice> which is incredibly heavy for a simple 1 page PDF
13:02:57 <thoughtpolice> GHC also doesn't exactly produce small executables for the most part either
13:03:00 <thoughtpolice> due to the way module initialization works
13:03:17 <Cin> A one-time couple seconds of download time for my users is worth the hours it will save me in time and mental health.
13:03:22 <thoughtpolice> (although simon apparently recently fixed a lot of this, which is extremely exciting.)
13:03:49 <thoughtpolice> Cin: unless it's unbearable slow because there's so much code, in which case, users will be turned off.
13:04:21 <unfo-> might be relevant to people's interests here: http://www.donorschoose.org/hacking-education
13:04:32 <Cin> I doubt it's that big. I already have an app about 2mb in size. Most of which gets squashed into about 400K thanks to the wonder of gzip compression.
13:05:13 <thoughtpolice> that actually brings up the point of whether or not emscripten's demo was compressed, i don't know. but just loading that 1 pdf demo was pretty unbearable from a usability perspective, if you ask me.
13:05:23 <thoughtpolice> if it wasn't though, i speculate it could be made a lot smaller.
13:05:41 <luite> it's not just the download, the browser has to compile the stuff too, whcih might not be a huge problem on a powerful quad core with lots of memory, but mobile devices will probably struggle
13:05:42 <Cin> The demos are unoptimized.
13:05:55 * Cin doesn't target mobile devices
13:06:40 <thoughtpolice> Cin: but in general, for what you're trying to do, you're probably going to hit a lot of complications regardless of whether or not you use a DSL or just make GHC output native JS. anything that does actually implement Haskell -> JS is extremely alpha for the most part, and if you don't want a DSL (of which there are several,) I don't know what to tell you
13:07:19 <thoughtpolice> so if you want something usable, be prepared to do a lot of work nonetheless.
13:08:16 <Cin> A DSL will probably have to do, when I get round to it. Beats basic JS, but is nowhere near the same as compiled Haskell.
13:08:34 <thoughtpolice> GHCJS is probably your best bet if you really want Haskell directly in the browser, it uses a somewhat similar strategy to what we used in LHC. it's finnicky, but we've gotten it to work in practice (they both work by compiling the external core representation.) but in general that approach takes a *ton* of work
13:08:37 <Cin> thoughtpolice: Did you try ghcjs?
13:08:54 <thoughtpolice> Cin: there are already javascript DSL's and whatnot on hackage, you'd probably be best looking at them first
13:09:12 <Cin> I already have… I've written several, too.
13:10:02 <thoughtpolice> Cin: no, but I'm familiar with the approach it uses (IIRC) because it's the same we used in LHC. compile GHC and get it to output external core for everything (including core libraries,) and then when compilation happens you mechanically translate that to 'whatever'. this also requires you re-implement all necessary parts of the GHC RTS in whatever language you're using
13:10:08 <Cin> That's why I know that it's cumbersome and unpleasant. It's /alright/.
13:10:16 <thoughtpolice> this approach is finnicky, but it works somewhat OK
13:10:27 <Cin> What's LHC?
13:10:46 <Cin> Ah, a backend.
13:10:47 <thoughtpolice> it's a PoC compiler I worked on with Lemmih that does whole program optimization on haskell programs, and uses GHC as a frontend
13:11:11 <thoughtpolice> (mainly because maintaing a haskell frontend is a ridiculous amount of work. the actual whole-program compilation machinery is staggeringly small, only a couple thousand lines)
13:11:37 <luite> did some of the LHC ideas eventually end up in GHC by the way?
13:11:51 <thoughtpolice> no, LHC uses a fundamentally different compilation model than GHC.
13:12:08 <thoughtpolice> I think it would be possible (and MUCH BETTER) to re-implement things like ghcjs/LHC using GHC compiler plugins
13:12:18 <thoughtpolice> but alas, I need to port the patches to git now, and I need SPJ to review and accept them
13:12:28 <thoughtpolice> (second part is harder than it sounds, GHC HQ is busy)
13:13:23 <thoughtpolice> GHC can in fact expose/dump pretty much everything it compiles into an interface file if you use -fexpose-all-unfoldings. one of my interests here is using that + compiler plugins to implement whole-program optimizations for GHC, at the core level. i think this can work, I just need to port my patches to the latest tree
13:13:45 <aristid> does spj use haskell on windows?
13:13:53 <thoughtpolice> if it does, then you can just write your own Core -> whatever backend, because your plugin has the full program available. this will not absolve you from having to write pieces of the RTS manually
13:13:55 <aristid> (ghc specifically)
13:14:00 <thoughtpolice> but it's a hell of a lot better than using external core
13:14:49 <thoughtpolice> aristid: most of them use linux, simon marlow does lots of development on windows (and does most of the mingw support) I think
13:14:50 <luite> ah I thought ghc 7 already put much more code in the .hi files than 6.12, with default settings
13:15:04 <osoleve> when looking at the documentation for a module, how do you determine what a parameter to a function is used for? say, if it just says String -> Foo, how do I know what String is?
13:15:09 <aristid> thoughtpolice: and spj in particular?
13:15:12 <thoughtpolice> luite: -fexpose-all-unfoldings forces ghc to put unfoldings for *everything*, regardless of things like INLINE pragmas, into the interface file
13:15:16 <thoughtpolice> aristid: no idea
13:15:48 <thoughtpolice> aristid: but I've seen him complain on the GHC lists about windows builds failing before I think, so the answer is probably 'yes' - I don't think it's as clear as "they use windows" or "they use linux" though, they just work on GHC
13:15:56 <luite> thoughtpolice: does it also use them for inlining when they're available, or is that a seperate setting?
13:17:17 <ezyang> aristid: Yes. 
13:17:23 <luite> it would be nice not having to bother with inline and specialize pragma's for small projects where performance is important :)
13:17:29 <ezyang> "Do note that SPJ and SM are employed by MSR" 
13:17:31 <Botje> osoleve: hopefully the module says what it does. otherwise you guess :)
13:17:45 <osoleve> Botje: awesome. thanks for clearing that up. :)
13:17:58 <thoughtpolice> luite: I think whether or not an unfolding should be inlined unconditionally is specified as part of the unfolding, so -fexpose-all-unfoldings doesn't say "inline everything, everywhere"
13:18:07 <aristid> ezyang: you'd think that GHC would have first-rate windows support then :>
13:18:29 <ezyang> Do also note that GHC developers do not regularly run the Windows installer ;-) 
13:18:52 <thoughtpolice> aristid: GHC on windows is a crapshoot, also because most people who e.g. write hackage libraries don't test them on windows. most of the haskell community is filled with unix users
13:19:12 <aristid> thoughtpolice: except of course many GHC core devs
13:19:17 <Cin> Got ghcjs to build with ghc7. One small step for man.
13:19:48 <luite> thoughtpolice: ok, thanks, I'll try it later then. sounds like it might get me some performance improvements (or just more code bloat :) )
13:20:14 <Cin> cd mk; cp build.mk.sample build.mk
13:20:21 <Cin> There is no build.mk.sample…
13:20:31 <Cin> What to use? install.mk?
13:20:37 <thoughtpolice> aristid: GHC HQ is frighteningly small compared to the haskell community at large. you can't blame them for 3rd party developers who don't necessarily test on windows (or developers who specifically write unix-only libraries.) that said, one improvement I can think of is shared libraries for windows
13:21:41 <parcs> @hoogle ($$)
13:21:41 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
13:21:41 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
13:21:41 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
13:21:59 <Cin> Wait. This isn't a source distrib.
13:22:14 <aristid> thoughtpolice: even dcoutts is scared of the GHC codebase ;)
13:24:24 <thoughtpolice> aristid: it's pretty scary in some places, no doubt. i do try to hack on GHC when i have time/motivation. i try not to fear anything though (sans death, taxes and not paying my rent on time)
13:24:37 <thoughtpolice> aristid: Linker.c is particularly scary though, if you're up for an adventure :)
13:25:43 <luite> ugh I tried to read that file one, while tracking down some problem loading c++ object files in ghci...
13:25:46 <luite> once
13:26:11 <luite> needless to say I gave up :p
13:26:29 * thoughtpolice wishes we could just use the operating system's dynamic linking facilities
13:26:45 <thoughtpolice> i think there are a few roadblocks before that could happen, though.
13:27:01 <lowasser> How do I specify a type class context for a rewrite rule?
13:28:21 <lowasser> Or, alternately, how exactly does ScopedTypeVariables interact with the syntax for rewrite rules?
13:29:50 <Botje> okay, I just took a stroll through the first half of Linker.c
13:30:09 <Botje> where does it devolve into IA IA CTHULHU FTAGN WAGN RLYEH etc?
13:30:43 <olsner> Botje: this is where you realize that's how the first line of the file starts
13:31:01 <lowasser> hahahahahahahaha
13:31:51 <olsner> but if you're lucky the bad parts are the ones that were exorcised into the evil mangler and satanic splitter
13:32:06 <aristid> the evil mangler is the perl thing?
13:33:04 <olsner> I suspect they're both perl
13:33:22 <olsner> one or both of them literal perl
13:37:26 <MacMagnus> why doesn't "Shell>" print at once here? http://pastebin.com/pywiaL5j
13:37:57 <luite> MacMagnus: output buffering probably
13:38:11 <monochrom> add "hFlush stdout" after the putStr. import System.IO
13:38:29 <luite> or use hSetBuffering NoBuffering stdout
13:38:38 <monochrom> unfortunately there is no "tie stdin with stdout" like c++ has
13:38:55 <MacMagnus> thanks, i'll try this :)
13:39:00 <thoughtpolice> Botje: that part starts at 'relocateSection' :)
13:43:57 <int80_h> I've got two versions of yesod installed. How can I go about uninstalling one without borking the other?
13:52:30 <Cin> thoughtpolice: Fancy that. ghcjs works.
13:52:53 <Cin> (GHC7)
13:54:05 <Cin> Ah, wow. Interesting. It supports FFI.
13:54:13 <Cin> foreign import ccall "alert"
13:54:13 <Cin>   jsalert :: Ptr JSObject -> IO ()
14:02:09 * hackagebot TCache 0.8.0.2 - Data caching and Persistent STM transactions  http://hackage.haskell.org/package/TCache-0.8.0.2 (AlbertoCorona)
14:15:11 * hackagebot flow2dot 0.8 - Library and binary to generate sequence/flow diagrams from plain text source  http://hackage.haskell.org/package/flow2dot-0.8 (DmitryAstapov)
14:25:47 <ezyang> Hey all, I'm working on a comic describing the Haskell heap as a big pile of unopened presents. 
14:26:08 <hvr_> ezyang: that's a creepy thought :-)
14:26:29 <ezyang> Among the things I want to describe include pattern matching, seq/pseq/deepSeq 
14:26:42 <ezyang> I was curious if y'all had other things that I ought to describe. 
14:26:45 <ezyang> hvr_: How so? :-) 
14:26:47 <shachaf> ezyang: Opening a present is forcing a thunk?
14:26:54 <ezyang> Yep. 
14:26:59 <shachaf> Huh.
14:27:00 <ezyang> Some of the presents are haunted. 
14:27:11 * shachaf bans evaluation except on special occasions.
14:27:12 <ezyang> "That's what seq does" 
14:27:14 <hvr_> ezyang: what if there's a _|_ in one of those boxes?
14:27:21 <ezyang> It explodes. That was a booby trapped present. 
14:27:30 <ezyang> :-D 
14:27:51 <olsner> opening presents? I'd rather open futures :)
14:28:35 <hvr_> ezyang: how would you represent the GC?
14:28:42 <olsner> otoh, futures are just presents you haven't opened yet :)
14:28:56 <ezyang> I wasn't planning on covering that. 
14:29:05 <ezyang> But it would depend on what kind of GC is being used. 
14:29:37 <ezyang> something to do with moving all the presents to another heap. 
14:31:07 <thoughtpolice> wowzers: http://www.haskell.org/pipermail/cvs-ghc/2011-April/061139.html
14:31:27 <olsner> the GC can only remove presents you don't see or remember, so you can just say that if you can't know what happened to a present, it's the same to you if it's been exchanged for a gift card or just stowed away in an infinite closet
14:32:04 <hvr_> ezyang: if you imitate mc escher, you might be able to visualize recursive data-structures =)
14:32:08 <olsner> in other words, putting the issue completely outside the care of the comic shouldn't change the meaning of the comic
14:33:37 <ezyang> Oh, and there are machines that take presents and turn them into different presents. 
14:33:55 <hvr_> ezyang: http://upload.wikimedia.org/wikipedia/en/b/ba/DrawingHands.jpg this reminds me of a recursive data structure somehow...
14:35:17 <nejucomo> :i Typeable
14:35:42 <sipa> :k Typeable
14:35:43 <lambdabot>     Class `Typeable' used as a type
14:35:43 <lambdabot>     In the type `Typeable'
14:35:44 <nejucomo> :t typeOf
14:35:45 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:36:15 <nejucomo> What if I want a TypeRep, but I do not have a value of t ?  I want something like: class Default t where default :: t
14:36:22 <nejucomo> Is there such a standard class?
14:36:57 <ezyang> Typeable. 
14:37:06 <ezyang> oh, no, that's different. 
14:37:14 <c_wraith> > typeOf (undefined :: Int)
14:37:15 <lambdabot>   Int
14:37:21 <c_wraith> :t typeOf (undefined :: Int)
14:37:22 <lambdabot> TypeRep
14:37:34 <c_wraith> Typeable is specifically intended that you be able to pass in undefined
14:37:44 <c_wraith> So that you never need a value of the type.
14:37:56 <nejucomo> Oh, thanks.
14:41:28 <aristid> ezyang: i like the view patterns suggestion in the "wrong variable" post best
14:43:08 <ezyang> aristid: Curiously enough, I added that one after publication. 
14:43:20 <ezyang> View patterns are pretty excellent, though. I ought not to have forgotten them :-) 
14:43:45 <int80_h> what is the syntax for cabal to specify the version to be installed?
14:44:16 <monochrom> cabal install gtk-0.12
14:45:25 <aristid> ezyang: yeah :)
14:50:33 <Taslem> Is there anything wrong with doing:  a :!: b = NumDigit a b
14:50:50 <ksf_> yep.
14:50:56 <ksf_> : is a capital symbol.
14:51:11 <Taslem> Why, exactly?
14:51:15 <ksf_> that is, it's a datatype constructor name, not a function name.
14:51:16 <Twey> : is *the* capital symbol.
14:51:20 <Twey> Because it is.
14:51:22 <monochrom> you can use :!: for data constructors
14:51:44 <Twey> Was it decided to make : capital because of the list cons?
14:51:50 <monochrom> I think so
14:52:12 <Taslem> So, how can I change that to a type constructor?
14:52:18 <monochrom> a .:!:. b = NumDigit a b  looks nicer anyway
14:52:30 <Taslem> Mkay.
14:52:37 <luite> : is a capital ; on my keyboard :p
14:52:52 <monochrom> type constructor? are you sure you want type constructor?
14:55:08 <rwbarton> you can write   data a :!: b = NumDigit a b  (or type or newtype)
14:55:14 <rwbarton> possibly needs some GHC extension
14:55:24 <rwbarton> that's actually what I thought you meant at first
15:11:42 <SoleSoul> Hi. I have a little question. translateFile is a function of type String->String->String. it gets the code and a filename (needed for translation) and returns the translated code. I want to map this function over a list of file contents and file names. I know how to map with a function which takes one argument. What do I do in that case?
15:12:50 <c_wraith> :t zipWith
15:12:51 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:12:55 <SoleSoul> I mean, two lists. one of file contents and one of file names
15:13:49 <SoleSoul> c_wraith: ahh, thank you!
15:13:59 <c_wraith> you're welcome
15:15:55 <Taslem> GHCi is warning me when I try to make a type constructor like this: type a :/: b = Frac a b
15:16:18 <monochrom> does the warning suggest an extension to turn on?
15:16:32 <Taslem> Yeah, I think so.
15:16:35 <Taslem> How do I turn it on?
15:17:33 <blackh> Taslem: ghci -XNameOfExtensionHere
15:18:17 <Taslem> Thanks.
15:20:19 <monochrom> you can also use {-# LANGUAGE TypeOperators #-} in source code file
15:21:02 <blackh> ^ Much better way
15:30:24 <azaq23> > (reduce $ 2 * 2 * x, reduce $ x * 2 * 2)
15:30:25 <lambdabot>   (4 * x,x * 2 * 2)
15:31:39 <parcs> > (2 * 2 * x, x * 2 * 2)
15:31:39 <lambdabot>   (2 * 2 * x,x * 2 * 2)
15:35:19 <aristid> > (2*2)*x
15:35:20 <lambdabot>   2 * 2 * x
15:35:24 <aristid> evil!
15:35:32 <aristid> > (fromInteger $ 2*2)*x
15:35:33 <lambdabot>   4 * x
15:36:05 <ksf_> gnahgnahgnah
15:36:23 <ksf_> the openshake code isn't exactly *designed* to support globbing over targets
15:37:06 <ksf_> also, this feels suspiciously like frp.
15:37:41 <ksf_> using inotify to do incremental builds would give it the last nudge to become a full frp system.
15:38:43 <ksf_> quick poll: how many of you would like a build system that recompiles stuff as soon as you hit <esc>:w ?
15:44:45 <gwern> ksf_: doesn't sound like a patch on flymake
15:45:37 <Twey> Agreed
15:46:15 <ksf_> nope, it isn't.
15:46:23 <ksf_> but you could use it as a backend for such a thing
15:46:35 <ksf_> ...also pointing out errors in other files, the results of test runs etc.
15:49:03 * ddarius doesn't want such a build system.
15:49:50 <monochrom> what the hell is <esc>:w anyway?
15:50:22 <ksf_> what I type before hyper+j to switch to another console and test what I did.
15:51:10 <azaq23> monochrom: vim; escape gets you out of insert mode, :w saves the file
15:51:38 <monochrom> I would press a "save" button instead like in eclipse
15:51:43 <ksf_> well, : gets you in ex mode, w<return> saves.
15:51:51 <monochrom> it is aka "ctrl-s" for those keyboard freaks
15:52:20 <ksf_> I can reach everything I need from my alphanumerical keyboard.
15:52:28 <ksf_> I don't even need to switch to the arrow keys.
15:52:31 <hpc> or alt f s, for people with only one finger
15:53:28 <monochrom> if you allow morse code, I could enter a whole source code file but just one mouse button
15:53:32 <ksf_> my fingers are busy enough to presciently speeding up any sequence, there's no sense to use key combinations and boycott that.
15:53:33 <monochrom> s/but/by/
15:53:52 <lispy> monochrom: actually, I'm not sure how you would enter punctation
15:54:14 <monochrom> "give me one button, and I can rewrite the whole world" - monochrom archimedes (or something)
15:54:15 <lispy> monochrom: http://en.wikipedia.org/wiki/File:International_Morse_Code.svg
15:54:30 <monochrom> well, make it cobol then!
15:54:44 <monochrom> perhaps it's euclid
15:55:55 <lispy> http://en.wikipedia.org/wiki/Morse_code#Letters.2C_numbers.2C_punctuation  <-- okay, some support in some variants
15:58:51 <Mathnerd314> Is there a way to know when Planet Haskell gets a new feed added?
16:00:45 <dons> Mathnerd314: no public way
16:00:45 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:01:04 <dons> Lemmih: interesting!
16:01:20 <SoleSoul> Newbie seeking help. Hello guys. I am stuck and confused for quite some time. I want to do the following in main: if directory exists then (some IO actions and pure function calls) else (some IO actions and pure function calls).  Do I have to use "do" for it? how do I enclose the blocks? Can I write commands in the "if then" just like in main? I'm pretty confused...
16:01:38 <shachaf> You never have to use do.
16:01:55 <SoleSoul> hi שחף
16:02:04 <SoleSoul> what do I use then?
16:02:17 <ivanm> using do is probably the easiest way of doing it though
16:02:23 <ivanm> use a do-block inside both then and else
16:02:24 <shachaf> However, it might be written something like do { b <- doesDirectoryExit "dir"; if b then do { foo; ... } else do { bar; ... } }
16:03:23 <SoleSoul> must the last line in the do block be an IO action without bunding?
16:03:26 <SoleSoul> *binding
16:04:00 <shachaf> A do block isn't magic.
16:04:13 <shachaf> do { x <- y; ... } translates to y >>= (\x -> do { ... })
16:04:19 <SoleSoul> I have a pure String as the return value of the last line of the do block and ghc complains that a do block must end with an expression
16:04:22 <Mathnerd314> dons: perhaps you could provide a feed for the list of subscriptions?
16:04:46 <shachaf> SoleSoul: A binding doesn't make sense at the end of a do block.
16:04:53 <ivanm> SoleSoul: use return to "lift" the value into IO
16:06:44 <kleinucopia> I have three functions which return IO [Double]. How can I get the three functions' return lists in a list (IO [[Double]])
16:06:49 <SoleSoul> ivanm: I'm trying it right now
16:07:01 <shachaf> @ty sequence
16:07:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:07:09 <kleinucopia> shachaf: thx
16:07:29 <ivanm> or maybe mapM ($input) ?
16:10:12 <shachaf> @src mapM
16:10:13 <lambdabot> mapM f as = sequence (map f as)
16:11:23 <aristid> :t mapM id
16:11:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
16:11:36 <ivanm> well, he said he had three _functions_...
16:11:36 <aristid> :t \input -> mapM ($input)
16:11:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => a -> [a -> m b] -> m [b]
16:11:41 <aristid> @pl \input -> mapM ($input)
16:11:42 <lambdabot> mapM . flip id
16:12:49 <SoleSoul> ivanm: It worked. I'm not sure why I did that though. I use <- right after that to reduce it again from IO to String. You can see it here: http://hpaste.org/45629/if_then_do  Couldn't we avoid raising and reducing the values for no use?
16:13:29 <developernotes> Is there a reason that I wouldn't be able to apply a find to the results of a mapWithKey function?
16:13:51 <aristid> @hoogle mapWithKey
16:13:52 <lambdabot> Data.IntMap mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
16:13:52 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
16:14:04 <aristid> :t M.find
16:14:05 <lambdabot> Couldn't find qualified module.
16:14:09 <aristid> :t Map.find
16:14:10 <lambdabot> Couldn't find qualified module.
16:14:16 <aristid> :t Data.Map.find
16:14:17 <lambdabot> Not in scope: `Data.Map.find'
16:14:19 <aristid> wtf
16:14:27 <shachaf> SoleSoul: Thinking of "<-" as "reducing something from IO String to String" is not helpful.
16:14:28 <azaq23> SoleSoul: it has a use; it constructs an IO action which composes with other IO actions in the correct way. It's not structurally useless and there's no easier way.
16:14:29 <elliottt> :t Data.List.find
16:14:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:14:40 <aristid> elliottt: no, i was explicitly asking for Data.Map
16:14:41 <elliottt> :t Data.Map.lookup
16:14:42 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
16:14:54 <aristid> aah
16:15:01 <developernotes> aristid: Maybe an example would be helpful, just a sec.
16:15:03 <shachaf> @quote IO.String
16:15:03 <lambdabot> monochrom says: How do I extract the IO out of IO String?
16:15:16 <elliottt> :)
16:15:34 <jrw> hi, anyone else experiencing extremely slow times grabbing code via darcs from code.haskell.org?
16:15:43 <jrw> like hours and hours to grab xmonad-contrib
16:15:54 <SoleSoul> shachaf: I know you are right but it's not enough because I don't know what is the right thing to think..
16:16:07 <SoleSoul> azaq23: Thank you for the explanation
16:16:31 <SoleSoul> shachaf: I know <- is to perform the IO action on the right side
16:16:32 <shachaf> SoleSoul: Something of type "IO String" isn't a value which "contains" a String; it's more like a program that you can run which will give you a String.
16:16:34 <developernotes> aristid: This is what I am talking about: http://hpaste.org/45630/find_and_mapwithkey
16:17:08 <SoleSoul> shachaf: Thanks. why do I need it here then?
16:17:24 <aristid> developernotes: find operates on lists.
16:17:33 <aristid> developernotes: mapWithKey returns a Map
16:17:46 <SoleSoul> shachaf: better ask, why do I have to use "return"?
16:17:56 <developernotes> aristid: hmm...so can I just wrap it in a toList?
16:18:45 <aristid> developernotes: you want to lookup by value instead of key. maybe you should rethink your choice of data structures
16:19:17 <SoleSoul> ivanm: hello again. can you please give me a hint why do I need to use return here? it worked btw: http://hpaste.org/45629/if_then_do
16:19:20 <developernotes> aristid: is there one you would suggest?
16:19:35 <ivanm> SoleSoul: haven't shachaf, etc. been telling you why?
16:19:56 <shachaf> SoleSoul: "return foo" makes a "program" that does nothing and gives you foo.
16:19:56 <monochrom> "return" is how you move String into IO String, so to speak
16:20:22 <aristid> developernotes: well, maybe just operate with lists all the way?
16:20:26 <Cale> If x is any value, then return x is the action which does nothing except to produce that value as its result
16:20:51 <Cale> Each line of a do-block must be an action (in the same monad)
16:20:59 <aristid> :t map . uncurry
16:20:59 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
16:21:05 <developernotes> aristid: was trying to play around with Maps, the key is my directory in the example.
16:21:06 <ion> ‘return a’ in the IO monad returns an IO action that, when performed, has no side effects results in ‘a’. More generally, ‘return a’ lifts ‘a’ into the monadic type. return 42 :: [Int] results in [42]. return 42 :: Maybe Int results in Just 42.
16:21:16 <aristid> developernotes: and the value?
16:21:24 <aristid> developernotes: why are you searching by value?
16:21:46 <azaq23> the do block in itself is necessary to "sequence" the IO actions in it; you still need to put pure things using "return" into and "empty IO action" to have a useful notion of "sequencing".
16:21:56 <ion> > (return 0, return 1, return 2, return 3) :: ([Int], Maybe Int, Either Int Int, IO Int)
16:21:57 <lambdabot>   Overlapping instances for GHC.Base.Monad
16:21:57 <lambdabot>                              (Data...
16:21:58 <monochrom> given that you can't "escape out of IO", you may as well "pull everything into IO" as plan B
16:22:06 <monochrom> "if you can't beat them, join them"
16:22:20 <developernotes> aristid: just a silly example, of the unix which program with directories and bin in memory.
16:22:35 <ion> > (return 0, return 1, return 2) :: ([Int], Maybe Int, IO Int)
16:22:36 <lambdabot>   ([0],Just 1,<IO Int>)
16:23:14 <ion> [0] >>= \x -> … -- x is 0 here
16:23:21 <ion> Just 1 >>= \x -> … -- x is 1 here
16:23:51 <Mathnerd314> dons: something simple like http://hpaste.org/45631/simple_feed_template
16:23:51 <SoleSoul> wow, thank you all for the explanations!
16:23:52 <ion> (return 2 :: IO Int) >>= \x -> … -- x is 2 here
16:24:40 <SoleSoul> ion: last 3 lines are a bit above my current knowledge. I don't know what ">>=" means yet
16:25:01 <monochrom> >>= is how some people write do-blocks
16:25:07 <dons> Mathnerd314: you could write a tool to scrape the list of blogs on planet once a day, and publish the diffs
16:25:16 <ion> do x <- [0]; … -- x is 0 here
16:25:24 <ion> do x <- Just 1; … -- x is 1 here
16:25:39 <iago_> hi, does someone have some experience writing rewriting systems with Haskell? I would appreciate any suggestion/advice
16:25:57 <ion> do x <- (putStrLn "side effect" >> return 2); … -- x is 2 here
16:26:02 <djahandarie> I only have experience rewriting writing systems.
16:26:19 <monochrom> haha
16:26:24 <iago_> (I'm seeing many alternatives like KURE, Strafunski, etc)
16:26:25 <monochrom> @slurp djahandarie
16:26:25 * lambdabot throws some pointy lambdas at djahandarie
16:26:29 <ion> do x <- return 42; … -- x is 42 here, no matter what the monad.
16:26:55 <shachaf> ion: data Null a = Null deriving Monad
16:27:11 <ivanm> shachaf: you can derive Monad now? :o
16:27:18 <ion> shachaf: Hah
16:27:21 <shachaf> ivanm: It's a #haskell extension.
16:27:27 <ivanm> ahhhhh
16:27:31 <ion> I bet lambdabot has that, too.
16:27:32 <ivanm> damn Caleskell... :p
16:28:17 <monochrom> you can send it to me and I will derive it for you
16:28:37 <monochrom> "the monad is free, but the run method will cost you", like somebody said :)
16:28:45 <Watermind> I tried,  :module +Control.Comonad   on ghci but it's not working
16:28:59 <Watermind> not even when running  ghci -fglasgow-exts
16:29:01 <monochrom> you need the right lib package installed
16:29:06 <SoleSoul> thanks ion
16:29:08 <Cale> Watermind: Perhaps you don't have category-extras installed?
16:29:23 <monochrom> category-extras is being obsoleted
16:29:27 <Watermind> oh let me check that
16:29:31 <shachaf> Try Ntrol.Monad.
16:29:37 <Twey> Haha
16:29:37 <monochrom> hahaha
16:29:52 <Cale> monochrom: Oh right, I noticed that on hackage. What's the deal with that?
16:29:53 <Watermind> I hate when I don't get the joke :P
16:30:11 <Twey> Watermind: Inverses.
16:30:26 <Cale> http://hackage.haskell.org/package/comonad -- seems to be here
16:30:29 <monochrom> I'm guessing a lot of splitting into smaller packages. "refocus"? :)
16:30:45 <Twey> Can't we just add it to Haskell?  :þ
16:30:50 <Watermind> Twey: still don't get it :S
16:30:51 <Mathnerd314> dons: rss is ready-made for scraping, which is what that paste generates
16:31:23 <ksf_> I think we should make it an inbuilt operator
16:31:34 <dons> Mathnerd314: right, but someone has to do work to add entries to the feed
16:31:40 <monochrom> if it's on hackage, it's "in" haskell
16:31:44 <Twey> Watermind: Re-analysis of ‘Control’ as ‘Co-Ntrol’
16:31:47 <ksf_> wait, I think larry wall just took possession of me.
16:31:49 <dons> btw, feed-cli is a good tool in hackage for updating an rss feed from the command line
16:31:52 <dons> i use it a lot
16:32:12 <Twey> monochrom: It's not in Haskell until it's part of the stdlib and preferably linked in the Prelude :þ
16:33:06 <Watermind> Twey: ah oh man
16:33:11 <Watermind> :)
16:33:30 <monochrom> @quote cofree
16:33:30 <lambdabot> No quotes match. My pet ferret can type better than you!
16:33:40 <developernotes> When I am trying to snd item inside a guard I am getting http://pastie.org/1789050, any thoughts on how to allow it to handle that?
16:33:53 <monochrom> mathematicians turn cofree theorems into free theorems
16:33:55 <Twey> Watermind: It's kind of a #haskell standing joke
16:34:13 <djahandarie> Haha monochrom
16:34:44 <djahandarie> "Mathematicians are machines for turning cofree theorems into free theorems."
16:34:46 <ion> solesoul: ‘do a <- f; b <- g; h’ is (for the purposes of this example) syntactic sugar for ‘f >>= \a -> g >>= \b -> h’. >>= (pronounced ‘bind’) and return are the two essential functions that make a monad.
16:34:58 <dons> ಠ_ಠ
16:35:50 <ion> solesoul: I recommend reading LYAH, it explains monads quite well.
16:36:18 <monochrom> maybe s/mathematicians/category theorists/
16:36:42 <monochrom> but also I wouldn't like to call anyone a machine
16:36:55 <djahandarie> "Category theorists are morphisms for turning cofree theorems into free theorems."
16:37:03 <SoleSoul> ion: I'm starting to understand. I am going to read the chapters about functors and monads in lyah.
16:37:05 <monochrom> hahaha that works!
16:37:08 <ddarius> monochrom: Why not?
16:37:18 <monochrom> @remember djahandarie Category theorists are morphisms for turning cofree theorems into free theorems.
16:37:18 <lambdabot> It is stored.
16:38:01 <developernotes> So is there a way to express a guard clause in a way that it's a Maybe tuple?
16:38:32 <monochrom> that is, of course, unless the person exhibits failure to use memory (such as scroll buffer) and contextual information, in which case I take pleasure in calling it a finite-state machine
16:39:59 <gwern> monochrom: I find I am a finite state machine. on at least 3 occasions I have read a blog or essay, gone to post a comment, and discoverved that comment already posted by myself
16:40:09 <Twey> developernotes: How are these two things equivalent?
16:40:14 <monochrom> haha are you kidding?
16:40:28 <gwern> monochrom: I wish I were
16:40:43 <gwern> it's eery and depressing as hell
16:40:48 <monochrom> one more reason to comprehensively read the existing comments before adding another one
16:41:08 <Twey> f x | (Just True, Nothing) <- (condition x, Nothing) = bar -- Maybe tuple, using pattern guards
16:41:09 <acowley> gwern: I think that just makes you a partial function
16:41:12 <monochrom> maybe you don't recognize that you wrote it, but at least see that it is somehow already written
16:41:16 <acowley> gwern: which you should take pride in
16:41:32 <Twey> gwern: Haha, I've done that a couple of times.
16:41:42 <gwern> acowley: -_- but it indicates I am not growing mentally since I didn't come up with a *better* comment even after years or whatever
16:42:02 <gwern> acowley: it'd be even more disturbing if my second comment were *worse*, but fortunately it's not quite that bad
16:42:03 <ezyang> That occasionally happens to me with bugs. I think, "man this sucks", Google, and find that I already reported it... 
16:42:10 <developernotes> Twey: I'm not sure exactly. I am getting a match error on the call to snd with this: http://hpaste.org/45633/sndissue
16:42:10 <acowley> Ah, so you are a Buchi automaton
16:42:19 <acowley> no new states for you
16:42:31 <acowley> Still, purity is a virtue
16:43:04 <Watermind> hackage seems to be in an inconsistent state... cannot install comonad-extras due to missing dependencies
16:43:20 <monochrom> IMO the turing machine teaches us a great lesson. if you're a finite-state thing, that's cool, don't feel bad, just go ahead and use a long tape to help
16:43:21 <acowley> If you haven't had the experience of being confounded by some code and thought mean thoughts about the original author before realizing that you were the original author... you haven't been programming long enough.
16:43:21 <Watermind> requires distributive ==0.1  and only 0.2 is available
16:43:32 <Twey> developernotes: You never call ‘which’ with that.
16:43:40 <Watermind> should we report this sort of thing or is it 'normal'?
16:43:53 <acowley> I may not be smart, but I have a long tape
16:43:56 <dons> Watermind: distributive-0.2.0 was excluded because comonad-extras-0.1.3 requires
16:43:58 <monochrom> I forget things. that's cool. this is why I buy ram and hard disks and flash memory sticks and I use google...
16:43:59 <dons> distributive ==0.1.*
16:44:02 <dons>  Watermind report    to the package author
16:44:25 <shachaf> acowley: I usually think mean thoughts about the original author *after* realizing I'm the original author.
16:44:32 <dons> Watermind: hackage in general is not consistent. there are consistent subsets, but authors are free to upload packages with missing deps
16:44:59 <monochrom> but other people are too proud to use aids.
16:45:01 <acowley> shachaf: you're too humble
16:45:04 <gwern> ah, but smartness *is* a long tape - the longer the tape the more algorithms you can execute
16:45:21 <developernotes> Twey: are you saying I can't follow the call of which and it's argument with guard clauses?
16:45:28 <acowley> shachaf: you're missing out on thinking, "Oh I know, I wrote some awesome code to do this last year!" then finding that it's garbage.
16:45:35 <Watermind> dons: ok gotcha
16:46:23 <monochrom> I forgot to mention I also buy a fountain pen and a lot of paper
16:46:35 <acowley> gwern: now we're getting to Haskellers' love for infinite lists
16:46:47 <acowley> speak slowly, carry a long list
16:46:53 <Twey> developernotes: No, I'm saying you never call ‘which’
16:46:56 <gwern> acowley: infinite datastructures are just finite under the hood!
16:47:18 <acowley> So you can keep your long tape encoded on a short tape!
16:47:44 <developernotes> Twey: oh, I just left that part of the file out in the hpaste, below the definition I am calling it: which "emacs" as an example.
16:47:51 <monochrom> I have a directory called "study-notes" to store things (in further subdirectories) I learn. when I learn I jot notes or cook up illustrative examples. recently I added some haskell FFI stuff to it because I learned them yesterday.
16:48:14 <gwern> monochrom: sounds like those notes would go well with a spaced repetition flashcard system
16:49:00 <monochrom> so now I have an awesome (or awful) example of a C main forking pthreads to call Haskell functions that sync on an MVar...
16:49:25 <shachaf> acowley: Oh, well, I've done that too, of course.
16:49:39 <dons> monochrom: crikey
16:49:54 <shachaf> acowley: See more or less all code that I've ever written.
16:49:59 <developernotes> Twey: any thoughts on the matching issue?
16:50:50 <acowley> shachaf: My favorite variety is the initial excitement at thinking I have some code I already wrote, finding a problem with it, thinking someone else caused the problem, then realizing it was my fault
16:51:05 <Watermind> hmm this comonad implementation doesn't match the one on the ghc lib docs
16:51:22 <Watermind> so what is the difference between Extend and Comonad?
16:51:25 <Watermind> the axioms?
16:51:43 <monochrom> dons: yesterday Berengal asked about using C-side OS threads to (concurrently) call haskell code, and basically the ghc docs say it's ok if you -threaded. so I figured I wanted to try it myself too.
16:52:25 <monochrom> the wonderful part is I then asked this channel about pthreads (I never learned it before).
16:52:35 <Berengal> monochrom: Good news; it works. It even worked without -threaded though, so I'm not sure how much of a fluke it was
16:53:00 * Berengal reads context
16:53:08 <Watermind> seems like the idea is that Comonads have extract while Extend doesn't... but extract is automatically derived from the other two methods, so the only reason not to have it is if it doesn't satisfy the axioms
16:53:10 <monochrom> if the haskell code takes a long time, maybe there are spurrious blocking issues
16:53:44 <Watermind> but I don't see, for instance why the axioms wouldn't be valid for the Maybe instance of Comonad
16:53:45 <monochrom> oh the context is I am forgetful so I store my successful example on the disk :)
16:53:53 <Berengal> Ah
16:53:57 <Twey> :t mapWithKey
16:53:58 <lambdabot> Not in scope: `mapWithKey'
16:53:59 <Watermind> even if the result of extract is undefined for non lifted elems
16:54:06 <Twey> @hoogle mapWithKey
16:54:07 <lambdabot> Data.IntMap mapWithKey :: (Key -> a -> b) -> IntMap a -> IntMap b
16:54:07 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
16:54:10 <Twey> developernotes: ^
16:54:25 <Berengal> I discovered a new problem with OS threads however
16:54:40 <Berengal> There's no way to reliably GC them... :(
16:54:44 <Twey> :t find
16:54:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:55:18 <Twey> developernotes: find returns a ‘Maybe String’, but you're using it as if it returned simply a ‘String’
16:55:23 <Berengal> Well, I could maybe fork a new thread myself that just holds a reference to the object in question, then have that object include an MVar that's signaled when whatever "stop" function exists is called
16:56:02 <Watermind> one of the things I wanted to check was precisely if it made sense to have a Comonad instance for Maybe
16:56:11 <Watermind> is this the case?
16:56:15 <developernotes> Twey: I was under the impressing it would return the first tuple where the second element was True.
16:56:18 <Twey> developernotes: (also, your use of the Map is completely pointless: you never actually use a Map operation on it, since you convert it back into a list before you do anything with it)
16:56:27 <Twey> developernotes: It doesn't
16:56:29 <Twey> :t find
16:56:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:56:45 <Twey> It returns the first element that matches the predicate in a Just
16:56:52 <Twey> If there is no element that matches the predicate, you get a Nothing
16:57:33 <developernotes> Twey: I was using the map simply as a way to split the tuple.
16:58:28 <Twey> developernotes: I don't understand your previous statement
16:58:31 <Twey> Tuples are already split
16:58:36 <Twey> That's what makes them tuples
16:59:17 <developernotes> Twey: right, I guess I can change it up a bit.  :-) Learning
17:00:07 <Twey> developernotes: We might do something like this, more idiomatically: http://hpaste.org/paste/45633/sndissue_annotation#p45635
17:00:39 <developernotes> Twey: Thanks for the feedback, I will go over it.
17:00:48 <Mathnerd314> dons: unless I'm misreading the documentation, that work is just copying the template I gave you and telling Planet to use it (there's already an up-to-date OPML export at http://planet.haskell.org/opml.xml ; I just want an RSS export)
17:04:42 <developernotes> Twey: what is the $ sign in your example?
17:05:06 <c_wraith> :t ($)
17:05:06 <lambdabot> forall a b. (a -> b) -> a -> b
17:05:56 <Rotaerk> developernotes, it means haskell is full of money
17:06:04 <developernotes> c_wraith: ah, it's an alias of sorts.
17:06:07 <c_wraith> Nothing much to it.  Just a function defined in the prelude.  It takes advantage of haskell's parsing rules to be very-low-precedence function application
17:06:11 <developernotes> Rotaerk: hah
17:06:23 <aristid> Rotaerk: lol
17:07:29 <developernotes> Twey: 
17:08:51 <developernotes> Twey: with your example I am getting the following match error: http://hpaste.org/paste/45633/sndissue_annotation#p45636
17:10:25 <Twey> developernotes: Yeah, sorry, s/\$/. fst $/ 
17:10:26 <dons> Mathnerd314: ah
17:12:47 <developernotes> Twey: heh...I was working on tracking down the matching part myself, but you beat me to it.  Thanks.
17:13:05 <Twey> You just have to look and check it all makes sense
17:28:50 <ormaaj> ghc requires a file named *.hs?
17:28:58 <ormaaj> $ ghc <(echo 'main = putStrLn "hi"')                                                                                                                                                                                                                                                                          
17:28:58 <ormaaj> target `/dev/fd/63' is not a module name or a source file
17:29:08 <revenantphx> Dear Haskell,
17:29:13 <revenantphx> for you topologists here, I have a CHALLENGE.
17:30:19 <acowley> It's a mapping between charts.
17:30:32 <revenantphx> Figure out some form of topograph… for Kierkegaard's Sickness Unto Death
17:30:35 <revenantphx> to be found here
17:30:36 <revenantphx> http://www.religion-online.org/showchapter.asp?title=2067&C=1863
17:30:44 <revenantphx> For example:
17:30:45 <revenantphx> But what is the self? The self is a relation which relates itself to its own self, or it is that in the relation [which accounts for it] that the relation relates itself to its own self; the self is not the relation but [consists in the fact] that the relation relates itself to its own self.
17:31:04 <revenantphx> I tried diagramming it earlier and failed.
17:31:24 <acowley> Sounds Russely
17:31:48 <revenantphx> Yeah, it's existentialism.
17:31:56 <revenantphx> Kierkegaard, not Russell though.
17:32:29 <revenantphx> Apply category theory and topology to existentialism...
17:32:33 <revenantphx> or die trying!
17:32:54 <acowley> edwardk could say a bunch of words that would convince you he knew the answer
17:33:03 <revenantphx> I'd like to see him try.
17:33:34 <acowley> You don't accept my Proof by EdwardK?
17:33:40 <revenantphx> nope.
17:33:48 <acowley> I thought that was gold in #haskell
17:33:55 <revenantphx> No dice.
17:34:51 <shachaf> acowley: #haskell-blah would accept that proof.
17:35:10 <revenantphx> We have higher standards.
17:35:18 <revenantphx> We're more rigorous.
17:35:37 <acowley> I actually don't see how this is different than Russell
17:35:54 <acowley> What am I missing?
17:36:54 <revenantphx> dunno
17:36:58 <revenantphx> I can't make sense of either of them.
17:38:29 <acowley> Well, in CT one talks about categories of small categories specifically to not admit such things
17:39:03 <acowley> So, just begin your proof with, "No Kierkegaards allowed..."
17:39:46 <revenantphx> Denied.
17:39:57 <revenantphx> I mean, as I see it, you'll need multiple levels of categories here.
17:40:24 <revenantphx> where self's reflexive morphism is the sole member of its own category...
17:40:43 <revenantphx> and so on, for 3 or 4 levels
17:41:04 <acowley> The tower of universes is only 3 or 4 levels? That's handy.
17:41:14 <revenantphx> ah! identity morphism
17:41:17 <revenantphx> that's what it is right?
17:41:29 <revenantphx> I haven't thoroughly read enough CT… and what I have was a couple months back.
17:41:45 <acowley> Well, I thought you wanted something that was defined to contain itself
17:41:51 <acowley> in which case it is not just an identity morphism
17:42:02 <revenantphx> can you have a category that contains itself?
17:42:19 <revenantphx> and which is also an morphism from itself to itself?
17:42:26 <acowley> I don't think so
17:42:31 <revenantphx> but is, in fact, the EXISTENCE of that morphism,
17:42:34 <revenantphx> not the morphism itself.
17:45:00 <Cale> revenantphx: Could you please not troll so obviously?
17:45:06 <revenantphx> what
17:45:06 <Cale> Try to be more subtle.
17:45:19 <revenantphx> I'm only half trolling
17:46:18 * mjrosenb thinks it would be an interesting problem if there were any chance such a system would be describable.
17:47:30 <acowley> {R | R ∈ R}
17:52:44 <djahandarie> acowley, in what non-well-founded set theory is this? :p
17:53:41 <acowley> RKR: revenantphx-kierkegaard-russell
17:54:01 <revenantphx> is it @quote time?
17:54:05 <mjrosenb> acowley: you should name it rrk
17:54:19 <mjrosenb> acowley: pronounced like someone vomiting
17:54:54 <acowley> #haskell = onomatopoeia + set theory
17:57:12 <hpc> revenantphx: a category that could contain categories would be infinitely kinded
17:57:19 <revenantphx> hpc: exactly.
17:57:22 <revenantphx> So, my point is,
17:57:25 <revenantphx> CT is incomplete.
17:57:25 <ion> rrk sounds like someone vomiting?
17:57:30 <monochrom> I link a program with "ghc -with-rtsopts='-K128M' --make -o m ...". then I run m (no +RTS on the command line, in fact nothing). it says "Most RTS options are disabled. Link with -rtsopts to enable them." is this normal? ghc 7.0.2
17:57:31 <revenantphx> Since it fails to take Existentialism into account.
17:57:44 <djahandarie> revenantphx, what in the world are you talking about?
17:57:50 <hpc> lol i dunno
17:57:57 <revenantphx> backlog.
17:57:59 <acowley> ion: the person is stifling it in a vain attempt to avoid embarassment
17:58:14 * hpc goes back to his other channel, where everyone bashes X and has fun all day long
17:58:15 <revenantphx> I asked someone to draw out categories for Kierkegaard stuff.
17:58:27 <revenantphx> hpc: For example:
17:58:28 <revenantphx> But what is the self? The self is a relation which relates itself to its own self, or it is that in the relation [which accounts for it] that the relation relates itself to its own self; the self is not the relation but [consists in the fact] that the relation relates itself to its own self.
17:59:03 <Lycurgus> a line is definitely being crossed here
17:59:18 <djahandarie> revenantphx, probably this should be moved to #haskell-blah?
17:59:32 <revenantphx> djahandarie: Nope, they don't have enough rigor to supply a good proof.
18:00:04 <Lycurgus> monochrom, is there a reason you aren't using 7.0.3?
18:00:12 <djahandarie> You aren't going to get any response here at all with the way you're pitching it, so in -blah might be better
18:01:41 <monochrom> there are other funny bugs in 7.0.3
18:03:52 <acowley> monochrom: like what?
18:04:19 <monochrom> I don't remember it now
18:13:34 <osoleve> does anyone have any experience with sound generation/playback from within Haskell? I spent all day working with the alsa library only to (potentially) figure out it doesn't do playback :/
18:14:54 <lpsmith> http://www.keywiki.org/index.php/American_Friends_Service_Committee
18:15:08 <lpsmith> oops
18:15:20 <osoleve> dang I was hoping that link was for me
18:15:22 <osoleve> haha
18:15:30 <lpsmith> that was intended for -blah
18:15:34 <osoleve> you got me all excited, lpsmith 
18:16:43 <nanothief> I'm trying to write a generic zipWith function (that works with things other than lists). I've currently got http://hpaste.org/45641/generic_zipwith , but was wondering if it could be written better to reduce the number of typeclass dependencies or be more efficient
18:19:27 <Cale> Maintainer	Henning Thielemann <alsa@henning-thielemann.de>  <-- whenever you see this, you're likely to be sad about the naming conventions in the module too
18:20:13 <osoleve> Cale: also, the dire lack of documentation
18:20:22 <Cale> Traversable implies Foldable
18:20:36 <Cale> so you could at least drop the Foldable constraint
18:20:40 <Cale> osoleve: hmm...
18:22:47 <nanothief> Cale: good point
18:24:24 <osoleve> Cale: could CSound or Sox be what i'm looking for? (his name is on the Sox library, too)
18:25:11 <Cale> Yeah, maybe. It's a bit sad that he's taken over a lot of the sound projects, because he names all his datatypes T and typeclasses C, which imo is really really annoying.
18:25:58 <Cale> (he uses the module system to distinguish them, but it screws up the documentation badly and who really likes writing qualified names?)
18:26:16 <applicative> Really, not just in 'mathematical prelude' or whatever?
18:26:38 <Cale> In essentially every package he maintains.
18:26:45 <osoleve> hmm, hCsound has no documentation on hackage. dang.
18:26:59 <Cale> We need someone to follow him around and produce sane versions of his packages.
18:27:14 <Cale> oh, it has no documentation because the build failed.
18:27:15 <acowley> nanothief: I think regular Applicative-style is actually the nicest way to do this
18:27:37 <Cale> because csound isn't installed on the Hackage server
18:27:38 <acowley> nanothief: Except you need your Applicative instances to be of the zip variety rather than the nondeterminism variety
18:28:26 <acowley> e.g. getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
18:28:37 <Cale> He also seems to have inflicted that naming abomination on haskore :(
18:28:44 <osoleve> on the plus side, i'm getting my first taste of exploring hackage right now
18:29:32 <nanothief> acowley: well I want it to work for both normal lists and arrays, so I don't think I will be able to use that approach
18:29:55 <nanothief> (as well as any other "container" like type)
18:30:41 <applicative> Oh I see, in the midi package every type is called T. Awesome.   
18:30:48 <acowley> Is that wise?
18:30:57 <acowley> You use lists as an intermediary
18:31:08 <acowley> but there are various ways one might want a zip on, say, trees, to work
18:32:32 <nanothief> acowley: my current implementation is pretty bad (I just used fromList + toList as a simple solution), however I didn't think about different zip methods on trees
18:32:53 <osoleve> looks like I may have to put this project on the backburner for now, that's disappointing
18:33:20 <osoleve> thanks for taking a look for me, guys
18:33:23 <monochrom> well, all the questioning of "why don't you use 7.0.3" goes down the drain. -with-rtsopts='-K128m' still breaks in 7.0.3
18:34:00 <monochrom> it's high time I turned the table around
18:34:05 <Cale> osoleve: What sort of audio are you looking to produce?
18:34:15 <monochrom> IS THERE A REASON YOU DIDN'T TRY 7.0.3 YOURSELF BEFORE ASKING ME?
18:34:33 <Cale> osoleve: Do you just need to load and play a simple wave file, or do you need audio synthesis?
18:34:56 <osoleve> Cale: uhhh, I'm looking to take a chord progression from a file and play it
18:35:11 <osoleve> it's just an idea someone gave me for a project
18:35:18 <Cale> hmmm
18:35:36 <osoleve> i'm just trying to learn haskell by doing :3
18:35:47 <nanothief> acowley: I've changed the type of the function to zipWithGeneric :: (Traversable t) => (a -> b -> c) -> t a -> t b -> [c] , that is simpler and probably more logical with many traversable types
18:36:18 <acowley> nanothief: It's definitely an improvement! :)
18:36:22 <nanothief> s/Traversable/Foldable
18:37:13 <Cale> I don't remember the sox library being this annoying
18:37:30 <osoleve> http://hackage.haskell.org/packages/archive/sox/0.2.0.2/doc/html/Sound-Sox-Play.html
18:37:33 <osoleve> that's annoying?
18:37:35 <osoleve> :-P
18:37:44 <zoheb> So how do I use UTF8 files in GHC import system.IO.UTF8 does not seem to be working on the latest ghc
18:37:55 <revenantphx> Rofl.
18:38:42 <revenantphx> Everyone hates playing 20 questions with me.
18:38:56 <revenantphx> When guessing a person.
18:38:59 <revenantphx> I just binary search~
18:39:04 <revenantphx> .
18:39:42 <applicative> zoheb, isn't that what ghc naturally takes strings to be?
18:39:53 * shachaf wonders how revenantphx binary-searches a person in 20 questions.
18:40:05 <revenantphx> For a name.
18:40:08 <monochrom> zoheb: how do you get it to not work? paste early, paste often, paste completely
18:40:16 <revenantphx> "Is the first letter of their name equal to or before 'm'"
18:40:19 <revenantphx> then f...
18:40:21 <revenantphx> then d...
18:40:22 <revenantphx> etc
18:40:24 <jmcarthur> it takes five questions just to narrow down the first letter
18:40:36 <revenantphx> jmcarthur: right, but at that point I can probably guess who they are.
18:41:04 <monochrom> names are not that random. binary search on name is not that fruitful
18:41:07 <zoheb> I get this error when running the program umls: <stdin>: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character) 
18:41:44 <zoheb> I remember I had done something like this before to avoid the error
18:41:55 <zoheb> import Prelude hiding (writeFile, readFile, print) 
18:42:01 <monochrom> ok revenantphx I would like to assign you a 20-questions-or-less task of finding out why zoheb's code fails!
18:42:03 <zoheb> import System.IO.UTF8  
18:42:11 <revenantphx> monochrom: that's not the name of a person
18:42:24 <revenantphx> monochrom: Though, a 20 questions Haskell debugger would be amusing
18:42:27 <revenantphx> "IS IT A TYPE ERROR?"
18:42:44 <monochrom> I think you'll crack it :)
18:43:15 <revenantphx> eh, what's his problem?
18:43:36 <zoheb> This was a file I processed using earlier versions of ghc by hiding the Prelude definitions and importin System.IO.Utf8
18:43:51 <zoheb> The library seems to have disappeared
18:46:12 <chowder> I'm new to haskell and I wanted to create a checkerboard. I started by creating a module file with the header: module Board(row , column) where row is a list from 0..n and the same for column. How do I declare what "row" and "column" are?
18:47:05 <Cale> osoleve: OH
18:47:15 <Cale> osoleve: SDL-mixer
18:47:42 <shachaf> chowder: A module is probably not what you want.
18:47:45 <Cale> osoleve: I remember trying that and getting it to work pretty easily
18:47:59 <shachaf> chowder: (The answer is "row = ..." and so on.)
18:48:06 <Cale> osoleve: The documentation is not much more than the raw haddock, but the type signatures are mostly pretty self-explanatory.
18:48:18 <chowder> shachaf, what do you recommend I use instead of a module?
18:48:27 <Cale> (and you could probably look at the corresponding C documentation if anything was really confusing)
18:48:41 <osoleve> Cale: i'll take a look at it, thank you
18:48:45 <osoleve> I appreciate it
18:48:46 <shachaf> It depends on what you want to do.
18:49:34 <Cale> I'll even install it and make an example :)
18:50:33 <chowder> shachaf, for now I was just hoping to do something simple. I wanted to create a checkerboard that would display the coordinate everytime I clicked on a square
18:51:16 <chowder> so if I click on square (0,0) I'll get a popup saying "Clicked on (0,0)"
18:51:38 <applicative> shachaf, why doesn't chowder want a module?
18:51:38 <shachaf> "click"? "popup"? Sounds complicated.
18:52:05 * shachaf is no longer sure what chowder does want.
18:52:15 <shachaf> What were the values of "row" and "column" supposed to be?
18:52:40 <applicative> chowder, first you would need to decide on a graphics library, the way you're thinking. 
18:53:29 <chowder> as of now I'm still thinking of how I'd create a board. I figured that a list of lists would do fine to represent squares on the board
18:54:54 <chowder> shachaf, sorry, I come from mainly an OO background. I'm probably not explaining what I want to do properly
19:04:58 <amitava> While reading Huge's paper - Generalizing Monads to Arrows - I began trying out the StateMonad example
19:05:10 <amitava> Here's the code - http://dpaste.com/531491/
19:05:39 <amitava> I can't figure out a way to extract the resulting values - can anyone show me how?
19:07:06 <jmcarthur> amitava: you have to feed it an initial state
19:07:31 <amitava> yes - the tick function seems to be doing it using fetch 
19:07:46 <amitava> when i invoke tick, it returns StateMonad Int Int
19:08:14 <acowley> now unwrap the SM and feed it a state
19:08:15 <amitava> i would like to extract the resulting s 
19:08:20 <acowley> Hughes btw
19:08:23 <jmcarthur> amitava: no, i mean in order to run tick, you have to unwrap the function hidden by StateMonad, then you apply it to an initial state
19:08:40 <jmcarthur> amitava: there is no s inside the StateMonad. it's a function
19:09:20 <alkabetz> Some code I'm writing is throwing an exception.  Is there a way for me to see exactly what is being evaluated to cause the exception?
19:09:29 <amitava> hmm.. isn't the n getting transformed to n + 1 and getting stored?
19:10:35 <jmcarthur> amitava: what is the value of n before incrementing it?
19:11:18 <jmcarthur> or rather, where does that value come from?
19:11:21 <amitava> not sure - i am little fuzzy conceptually here -  
19:13:05 <applicative> amitava, you need the two functions I put at the bottom http://dpaste.com/531492/
19:13:52 <jmcarthur> well, you need at least one of them
19:14:00 <applicative> or something like them.  
19:14:02 <lucasicf> i get 'cannot construct the infinite type t = t1 -> t' error, does someone know why
19:14:06 <lucasicf> code: http://pastebin.com/r5ns4gh7
19:14:40 <jmcarthur> lucasicf: your function's type has fewer arguments than you are putting on the left hand side of the definition
19:15:00 <amitava> ahh -got it
19:15:07 <amitava> thx 
19:15:11 <lucasicf> omg!!
19:15:18 <lucasicf> i didn't realized that
19:15:27 <lucasicf> stupid bug, thanks
19:15:57 <amitava> i was able to run lucasicf's code
19:16:05 <amitava> what am i missing?
19:16:22 <jmcarthur> amitava: did you do it verbatim, including the type signature?
19:16:46 <amitava> no - just the implementation
19:16:51 <jmcarthur> that's it then
19:16:57 <amitava> aah - ok 
19:17:06 <jmcarthur> amitava: lucasicf's problem was that the type signature wasn't matching the implementation
19:17:26 <amitava> while we are at it - can u please show me how to implement Show on this type?
19:17:30 <applicative> amitava, so if you write execState (tick >> tick >> tick) 9 you get 11
19:17:54 <jmcarthur> amitava: you can't because it's a function
19:18:13 <amitava> k 
19:18:50 <applicative> which type do you want to show?
19:19:40 <jmcarthur> amitava: well, you could make kind of a bogus Show instance if you wanted, but it wouldn't be very conventional
19:19:45 <amitava> after tick, i would have liked for ghci to print out the 2 new states - but I think I was conceptually missing the point
19:20:09 <jmcarthur> like, you wouldn't be able to reconstruct a StateMonad from whatever show outputs
19:20:20 <amitava> which ofcourse runState is doing
19:20:41 <applicative> amitava just wants to see the current state displayed while it does whatever, no?
19:20:53 <amitava> exactly - thx
19:21:21 <jmcarthur> for debugging?
19:21:26 <amitava> yes
19:21:29 <jmcarthur> if so, i'd just use Debug.Trace
19:21:41 <amitava> but how to from 1st principles
19:21:48 <applicative> jmcarthur excellent plan.  
19:21:54 <amitava> just trying to wrap my mind around it
19:22:05 <applicative> amitava, it sounds like you want a more complex construction with IO inside
19:22:42 * ddarius organizes principles into a cyclic graph.
19:22:54 <amitava> applicative: not sure if I understood that
19:23:22 <amitava> do u mean like running it inside an iO monad and do putStr 
19:23:45 <blueonyx> hi, is there some link like http://hackage.haskell.org/packages/archive/network/latest/network.cabal to get the latest cabal of any package?
19:26:02 <applicative> blueonyx, i often wondered why hackage doesn't link the cabal files, but maybe it does somehow?
19:27:22 <blueonyx> hm, network has a 'latest' directory, but there is only 'doc' in it and eg cabal-install doesnt have it :/
19:27:25 <NisseP> blueonyx: the 'package description' link at the bottom of http://hackage.haskell.org/package/network
19:29:33 <blueonyx> NisseP: yea this links to http://hackage.haskell.org/packages/archive/network/2.3.0.2/network.cabal which has a version number in it, i want to get the latest version (preferably without parsing the link you gave)
19:30:35 <amitava> jmcurther and applicative - thank you so much for your help 
19:31:06 <jmcarthur> np
19:31:14 <NisseP> i suspected that might be the case :) i don't know, sorry; i'm pretty surprised 'latest' isn't just a symlink that's updated after each upload
19:32:36 <blueonyx> apparently its not :(
19:33:51 <deech> Hi all, can someone point me to resources on delimited continuations, I've looked at Oleg's site (ZipperFS etc) and the Monadic framework paper but find them too difficult.
19:34:07 <blueonyx> tagsoup to the rescue then, thanks anyhow :)
19:36:16 <gwern> @quote
19:36:16 <lambdabot> inimino says: actually, Chuck Norris is the Oleg of everything else
19:37:00 <chowder> I'm trying to create a module that represents coordinates. I'm trying to write various functions to retrieve information about a coordinate such as its x and y position. I'm thinking about this from an OO-perspective. Any ideas?
19:38:00 <Rotaerk> hrm
19:39:14 <jmcarthur> chowder: i'm not sure that's a very well-phrased question. i'm not sure what kind of answer you are looking for
19:39:49 <jmcarthur> a question of the form "How do I [...]?" would be easier, most likely
19:39:55 <chowder> http://hpaste.org/45643/coordinates
19:41:01 <jmcarthur> okay, let's first try to figure out what you mean by "(Coordinate a, Ord b) => a -> (b, b)"
19:41:09 <Axman6> you could have data Point a = P {x :: a, y :: a}
19:41:30 <jmcarthur> first of all, "Coordinate a" is invalid here. you have not defined a type class called "Coordinate"
19:41:42 <Axman6> then you get x :: Point a -> a, y :: Point a -> a, and you can do updateX p x' = p {x = x'}
19:42:01 <applicative> chowder why not data Piece = Black | White | None ; data Row = A  | B  | C  ..  data Column = One | Two  ...  data Square = Square Row Column Piece
19:42:07 <applicative> kind klutzy 
19:42:11 <chowder> jmcarthur, I'm thinking of it from an OO perspective. I'm thinking that I can create a coordinate "object" and retrieve information about it via functions
19:42:12 <jmcarthur> second of all, what is b supposed to be, where do you get it, and why does it have an Ord constraint?
19:42:31 <ddarius> chowder: Why are you thinking about it from an OO perspective?
19:42:44 <chowder> ddarius, because I'm still new to functional programming :/
19:43:12 <jmcarthur> chowder: it sounds like you want something like this instead:   "left :: (a, a) -> a"
19:43:29 <jmcarthur> chowder: assuming that the return type of the coordinate function is how you intend to represent coordinates
19:44:05 <Axman6> chowder: would you write in Java in a functional way? seems silly to me =)
19:44:13 <jmcarthur> chowder: also, the Ord constraint on the coordinate function is unnecessary
19:44:19 * applicative cant remember how many squares are on a checkerboard
19:44:22 <ddarius> @google functionaljava
19:44:23 <lambdabot> http://functionaljava.org/
19:44:23 <lambdabot> Title: Functional Java
19:44:24 <jmcarthur> applicative: 64
19:44:26 <Axman6> applicative: 64
19:44:30 <applicative> hah
19:44:33 <chowder> 8 x 8
19:44:58 <Axman6> ddarius: shush :P (i knew someone would say yes, but i meant when someone was first learning java)
19:45:13 <deech> applicative: Is this a trick q? Where 2 x 2, 3 x 3 are also squares?
19:45:25 <chowder> no more Java please, I'm so tired of Java
19:45:41 <applicative> chowder++
19:46:00 <Axman6> chowder: then time to start learning haskell the right way, I ban you from even thinking about OOP from now on!
19:46:01 <ddarius> Learn C# instead.
19:46:13 <jmcarthur> chowder: have you ever used a language that doesn't try to be specifically OO, like C?
19:46:55 <chowder> jmcarthur, I've done very little C. I've been doing imperative programming forever.
19:47:13 <Axman6> chowder: which languages?
19:47:14 <jmcarthur> chowder: do you know enough C to define a data structure?
19:47:18 <chowder> functional programming is very different but in a welcome way
19:47:25 <Axman6> chowder: also which tutorials have you looked at for learning haskell?
19:47:46 <chowder> jmcarthur, no, the uni that I go to is shite (excuse the language) so I haven't gotten that far.
19:47:59 <chowder> Axman6, I've been reading LYAH
19:48:07 <Axman6> well, keep going :)
19:48:20 <jmcarthur> chowder: okay then we won't try the tack i was hoping to try
19:48:22 <ddarius> jmcarthur: Have fun.
19:48:39 <jmcarthur> chowder: let's try a math approach instead :)
19:48:42 <Axman6> you'd do well to try to not force your OO habits on your haskell programming. it can be done, but it's much better to do it once you know how to not do it ;)
19:48:48 <jmcarthur> chowder: how would you define a coordinate in math?
19:49:47 <chowder> jmcarthur, I'd define it as a tuple of two real numbers
19:49:50 <applicative> chowder, we don't need this math.  what's wrong with these types, to start with?  http://hpaste.org/45644/checkerboard
19:50:18 <Axman6> heh
19:50:59 <jmcarthur> chowder: that's the approach i would take then. what you just decribed is not necessarily an object :)
19:51:16 <jmcarthur> (i also don't think i would restrict it to the reals, but that's okay for just thinking about it)
19:51:55 <jmcarthur> applicative: where did all this checkers stuff come from? was chowder asking checkers stuff earlier?
19:51:55 <chowder> jmcarthur, hmmm...I think I can see what you did there
19:52:02 <chowder> yes
19:52:10 <jmcarthur> ah
19:52:45 <chowder> I can understand the code but I've just never used it. I want to learn how to do what I would do in Java but in Haskell.
19:52:56 <jmcarthur> chowder: the point i was wanting to make is that you description of a coordinate in math terms didn't really include anything OO like methods, and in order to define functions on it you will need to think of it as a *value*
19:53:07 <jmcarthur> *you description
19:53:14 <jmcarthur> **your
19:53:38 <applicative> jmcarthur, yes.  maybe this is a new scheme.  
19:53:48 <monochrom> someone once asked are there objects and methods in haskell. I happily answered yes.
19:54:02 <jmcarthur> chowder: (and btw, type classes are not at all like OO classes, so don't even try that approach)
19:54:10 <jmcarthur> monochrom: heh
19:54:28 <monochrom> things like "True" is an object, of type Bool
19:54:41 <chowder> hmm..I see. Can't you create objects using closures?
19:54:47 <jmcarthur> sure
19:54:50 <applicative> and things like "even" are methods.  I get it.
19:54:52 <monochrom> "not" is a method of an object of type Bool.
19:55:01 <jmcarthur> but that doesn't mean you want to think of a closure as an object
19:55:11 <monochrom> generally, "f :: X -> y -> z -> ..." means f is a method for X objects
19:55:16 <jmcarthur> (you might sometimes, but not often)
19:55:36 <monochrom> and we write "not True" instead of "True.not". trivial syntactic change.
19:56:11 <ddarius> > let (.) = flip ($) in True.not
19:56:12 <lambdabot>   Not in scope: `True.not'
19:56:13 <applicative> we can write True . not if we hide (.) 
19:56:24 <applicative> ddarius is too fast 
19:56:33 <monochrom> someone might then ask "wait, how is f :: X -> y -> z -> ... a method? in what sense?"
19:56:36 <ddarius> Curse the unratified hierarchical module syntax addendum.
19:56:41 <applicative> > let (.) = flip ($) in True . not
19:56:42 <lambdabot>   False
19:57:01 <monochrom> to that I reply with the climatic punchline: "ever heard of multiple dispatch?"
19:57:27 <monochrom> yes, haskell (sml too) does OO more properly than java
19:57:35 <shachaf> > let (·) = flip ($) in True·not
19:57:36 <lambdabot>   False
19:57:41 <ddarius> monochrom: If you are saying it is a "method" of X and then multiple dispatch doesn't come into the picture.
19:58:04 * ddarius also doesn't find multiple dispatch OO.
19:58:13 <chowder> monochrom, if I have to write foo myfoo = new foo(); one more time I think I'll lose it
19:58:15 <monochrom> well, successive refinement of approximate truths and lies, etc
19:58:42 <applicative> chowder we have () too.
19:58:47 <applicative> @type ()
19:58:47 <lambdabot> ()
19:59:21 <ddarius> :t let new = id; foo myfoo = new foo () in foo
19:59:21 <lambdabot> forall t. () -> t
20:00:02 <c_wraith> that's an exciting type
20:00:15 <ddarius> It takes truth and produces falsity
20:01:25 <chowder> applicative, I'm ok with () as a type
20:01:51 <applicative> chowder, it's unusually benign.
20:01:52 <monochrom> and I present to you my latest invention:
20:01:58 <monochrom> > let c c plus рlus = c plus рlus in c (++) "c" "++"
20:02:00 <lambdabot>   "c++"
20:02:48 <Axman6> ouch, you can do that? :'(
20:03:07 <monochrom> two tricks I played. find them!
20:03:08 <Axman6> :t let a a b c =  a b c in a
20:03:09 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
20:03:26 <monochrom> yeah, first trick, "ever heard of shadowing?"
20:03:27 <aavogt> @ty let f f = f in f
20:03:28 <lambdabot> forall t. t -> t
20:03:52 <aavogt> @src id 
20:03:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:04:37 <applicative> > let f f = f in f 17
20:04:38 <lambdabot>   17
20:05:32 <monochrom> a precursor of my invention was
20:05:51 <monochrom> > let flip flip x y = flip y x in flip (++) "x" "y"
20:05:52 <lambdabot>   "yx"
20:06:10 <monochrom> "I flip in flip so you can flip while you flip"
20:11:03 <gwern> @quote flip
20:11:03 <lambdabot> mauke says: "@unpl const (flip const)" lambdabot: (\ _ c d -> d)
20:11:31 <gwern> weird. why is 'c' named?
20:11:31 * osoleve will never again cat a .wav
20:12:36 * gwern will never again wave a cat. ouch.
20:13:25 <BMeph> monochrom: You forgot a "YO DAWG I HERD U LIEK" in there. ;þ
20:13:42 <applicative> > (\ _ _ d -> d) 1 2 3
20:13:43 <lambdabot>   3
20:13:54 <applicative> > (\ _ _ _ -> d) 1 2 3
20:13:55 <lambdabot>   d
20:14:33 <gwern> applicative: that's the SimpleReflect stuff talking IIRC - 'd' is a defined name already
20:14:46 <gwern> let's see if I remember an example
20:14:49 <applicative> yes, but what is it naming...?
20:14:51 <gwern> > map f [1..10]
20:14:52 <lambdabot>   Ambiguous type variable `b' in the constraints:
20:14:52 <lambdabot>    `SimpleReflect.FromExpr ...
20:15:10 <applicative> > folder f 1 [1..10]
20:15:11 <lambdabot>   Not in scope: `folder'
20:15:16 <applicative> > foldr f 1 [1..10]
20:15:16 <lambdabot>   Ambiguous type variable `b' in the constraints:
20:15:17 <lambdabot>    `GHC.Num.Num b'
20:15:17 <lambdabot>      ari...
20:15:20 <applicative> ah well
20:15:30 <gwern> applicative: it's just a place holder, meant to print out asn itself
20:15:36 <gwern> all the single letters are
20:16:02 <applicative> > foldr f a [b,c,d]
20:16:03 <lambdabot>   f b (f c (f d a))
20:16:49 <aavogt> > foldr f 1 [1..10] :: Expr
20:16:50 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 1)))))))))
20:16:58 <gwern> yeah, like that
20:17:03 <applicative> excellent
20:19:07 <applicative> > foldl' f 0 [1..10] :: Expr
20:19:07 <lambdabot>   f (f (f (f (f (f (f (f (f (f 0 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
20:22:00 <nyingen> ok, zippers are pretty cool
20:22:42 <nyingen> why do I feel like I've wasted a lot of time writing traversal code over the years
20:24:06 <nyingen> I also want to give mad props to the author of hexpat-pickle, by far the least painful way of doing XML I've ever come across
20:25:43 <nyingen> er, authors, I see. one of whom is on this channel
20:25:49 <nyingen> blackh: nice work
20:26:15 <blackh> nyingen: I have a fan!
20:26:43 <blackh> I'm glad you appreciate it!
20:27:00 <nyingen> blackh: do I ever
20:27:27 <nyingen> with the picklers, I can get from XML to haskell-land, where everything is safe and pure
20:28:00 <blackh> I've got one last thing to do, then my grand vision for hexpat will be realized.
20:28:27 <nyingen> oh?
20:28:55 <blackh> Actually two things. The first one is to finish my hexpat-enumerator bridge so you can process XML streams using enumerators but write your code to process it as a tree, not as flat SAX.
20:29:04 <blackh> The second thing is to speed it up some more.
20:29:37 <nyingen> that would be pretty cool
20:32:45 <blackh> The way it works is that it's got a co-routine monad, so when you request a bit of the XML document that hasn't been parsed yet, your computation suspends, then resumes when it's been received and parsed.
20:33:20 <blackh> It basically simulates lazy I/O, except with no lazy I/O.  Avoiding lazy I/O is important to some people (I'm one of them).
20:33:34 <nyingen> yeah
20:33:51 <nyingen> I've been bitten by some lazy I/O problems myself, though not in this project
20:34:08 <blackh> Yeah.  I need to write a little jabber server or something like that to demo it.
20:34:16 <blackh> Some XML-stream-based protocol.
20:34:22 <nyingen> cool
20:35:40 <blackh> I didn't like any of the existing XML libraries, so I wrote my own. :)
20:35:44 <xrl> I'm trying to write a factorization function and I'm goofing up on my loop invariants... somehow I get a div by zero... how do I track that down?
20:35:49 <xrl> here's a copy of my code: https://gist.github.com/916927
20:36:48 <blackh> xrl: Perhaps you could use the trace function out of Debug.Trace
20:37:21 <revenantphx> blackh: It's just pull-based no?
20:37:43 <nyingen> blackh: I tried a few of the XML libs before settling on hexpat. I had some success with HXT, but couldn't get HaXML to do what I wanted. hexpat has been nice to work with
20:38:27 <nyingen> HaXml was a bit of a tragedy since I could easily see how to write my queries and transformations with its combinators, but I couldn't actually get them to work in practice. The docs were a bit confusing as well, unfortunately
20:38:32 <blackh> revenantphx: hexpat-enumator is push-based, but inverts the control, so it looks like it's pulling.
20:38:41 <revenantphx> weird :)
20:38:45 <xrl> blackh: can I use trace from ghci?
20:38:52 <xrl> (if so, how?)
20:39:39 <blackh> xrl: Well, trace needs to be added into the code itself, really.
20:40:00 <blueonyx> @hoogle trace
20:40:00 <xrl> oh, it's printf but for haskell ;)
20:40:00 <lambdabot> Debug.Trace trace :: String -> a -> a
20:40:01 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
20:40:01 <lambdabot> module Debug.Trace
20:40:08 <blackh> nyingen: I wanted to make hexpat simple to use for the simple cases.
20:40:47 <blackh> xrl: There are several ways to debug your code but trace seems the most appropriate since it's so short.
20:41:25 * mjrosenb should learn how to use the ghci debugger.
20:41:35 <dons> heya blackh 
20:41:56 <blackh> nyingen: If you have any suggestions for improving hexpat's interface, let me know.  I want to make it even better if I can.
20:42:06 <blackh> Hi there, dons
20:43:19 <nyingen> blackh: sure, I'll keep that in mind
21:08:13 <BMeph> xrl: ...looks conplicated. :\
21:08:29 <xrl> BMeph: I know :-D
21:08:43 <xrl> my logic is wrong AND my haskell is weak
21:08:44 <xrl> haha
22:06:11 <digitteknohippie> is it possible to use ghci instead of bash.  so that my terminal, has ghci in it, and i use it for whever i would have been doing in bash?
22:06:29 <ulfdoz> chsh -s /usr/bin/ghci
22:06:45 <ulfdoz> however, I doubt, that you be happy with it.
22:06:53 <digitteknohippie> but i mean... it's useable, in a practical way?
22:07:10 <ulfdoz> digitteknohippie: Probably not.
22:07:12 <sanjoyd> ghci as a terminal?
22:07:13 <digitteknohippie> just trying to think how to get more every-day haskell use on the go.
22:07:38 <shachaf> No, it's not practical.
22:07:42 <ulfdoz> digitteknohippie: Just ask youself, how many characters you need to start a program with some arguments.
22:07:48 <shachaf> You can use ghci as a calculator, though.
22:07:54 <digitteknohippie> i've learned enough in bash to get reasonably comfortable with it, because i use it every day.  thought i'd learn haskell much much faster, if it was in my face all the time.#
22:07:55 <shachaf> ulfdoz: Two more than in sh. :-)
22:09:11 <ulfdoz> shachaf: But you occasionally need global variables, the environment.
22:09:39 <christo_m> lispy: you there?
22:36:28 <xrl> what's wrong with my where clause in this code? https://gist.github.com/916927
22:36:42 <xrl> I want it to spit out the text on each function call
22:40:14 <c_wraith> xrl: the most obvious thing wrong with that is that you're never calling trace from Debug.Trace
22:40:28 <c_wraith> xrl: you're shadowing it in your where clause, but that's all
22:40:57 <xrl> how do I call it?
22:41:01 <c_wraith> xrl: even the shadowed version is never called.
22:41:19 <xrl> hehe...
22:41:57 <c_wraith> there is a trick you can do to make tracing work like you want...  But I'd really suggest not using it.
22:43:14 <xrl> ohh, now I must know
22:43:41 <xrl> now I'm thinking of doing "debug = (trace "blah" True)"
22:43:51 <c_wraith> *shrug*.  Before line 12, insert:    | trace "hi" False
22:43:53 <xrl> and calling debug from the body
22:44:22 <c_wraith> err.
22:44:31 <c_wraith>      | trace "hi" False = undefined
22:44:42 <xrl> ahh
22:44:45 <xrl> got'cha
22:44:53 <xrl> tried it otherwise and it thought it was a param
22:45:53 <c_wraith> The reason that works is that guards are always evaluated in order when it's checking if any of them evaluate to true
22:46:00 <xrl> yup
22:46:07 <c_wraith> So the trace is evaluated before the other guards.
22:46:09 <xrl> now I just gotta jigger it so it doesn't break things
22:46:27 <c_wraith> But since it returns False, the branch it guards is never tested
22:46:32 <xrl> I can't do "= undefined" because it throws an exception
22:46:39 <c_wraith> Yes you can.
22:46:44 <xrl> so instead I do (trace "hi" True) = []
22:46:47 <xrl> that way the type is consistent
22:46:48 <c_wraith> trace "foo" False
22:46:52 <c_wraith> use False, not true
22:47:11 <xrl> but the functions return type is []
22:47:26 <c_wraith> then let's go over this again
22:47:36 <xrl> take a look at the gist again
22:47:38 <c_wraith> trace always evaluates to its second argument
22:47:41 <xrl> I just posted my updated code :)
22:48:26 <c_wraith> you really should use undefined there.
22:48:53 <c_wraith> it will typecheck.  undefined always typechecks. :)
22:49:14 <c_wraith> and it will never get evaluated, because the guard will *always* return False
22:49:15 <xrl> ahh
22:49:28 <xrl> ok, changed to undefined
22:49:42 <xrl> undefined is... undefined... so it has no type?
22:49:48 <c_wraith> :t undefined
22:49:49 <lambdabot> forall a. a
22:50:03 <c_wraith> undefined has any type.
22:50:19 <c_wraith> :t undefined `asTypeOf` (+)
22:50:20 <lambdabot> forall a. (Num a) => a -> a -> a
22:50:25 <xrl> or is that all types? does it bind to type a in the scope of the function or something?
22:50:39 <c_wraith> it unifies with any other type
22:50:59 <xrl> aha, ok
22:51:18 <c_wraith> :t undefined `asTypeOf` 35
22:51:19 <lambdabot> forall a. (Num a) => a
22:51:56 <xrl> updated the gist... is that to your liking?
22:52:34 <c_wraith> well.  I don't much like trace in general. :)
22:52:50 <xrl> haha
22:53:06 <c_wraith> It's sometimes useful, but in general it has unexpected results.
22:53:16 <xrl> I wanted to be able to put my loop invariants in there... but I'm not that good ;)
22:53:29 <xrl> ya, it's definitely unexpected
22:53:41 <xrl> pop goes the weasel for beginners
22:53:42 <c_wraith> Like, the optimizer can note that it's being called with the same args multiple times, and optimize that to a single call.
22:53:54 <xrl> ya, I was wondering about that as well
22:54:16 <c_wraith> Or it can force evaluation of expressions that otherwise wouldn't be evaluated
22:54:27 <c_wraith> Completely changing termination properties of your algorithm
22:55:21 <xrl> that's a problem...
22:55:39 * RayNbow`TU wonders if this can be done more elegantly... http://hpaste.org/45652/count
23:04:27 <c_wraith> xrl: here's a fun example - http://hpaste.org/45654/trace_fun
23:04:39 <drbean> What's the right way to take items from one list not in another list.
23:04:58 <drbean> http://hpaste.org/45653/elements_from_one_list_not_in
23:04:59 <c_wraith> :t (\\)
23:05:00 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
23:05:13 <c_wraith> > [1..10] \\ [3, 5]
23:05:14 <lambdabot>   [1,2,4,6,7,8,9,10]
23:20:27 <merijn> newtype declarations require explicit conversion to their "original" type, right?
23:24:57 <BMeph> merijn: It depends on how you're using "require". 
23:25:57 <merijn> BMeph: type NewString = String; the only way to pass NewString to a String -> a is to first pass it to NewString -> String
23:26:18 <pastorn> what's the line again? What is a monad?
23:26:26 <pastorn> it's the functor of something someting
23:26:34 <shachaf> merijn: That's not a newtype.
23:26:45 <shachaf> @quote a.monad.is.just
23:26:45 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
23:26:45 <pastorn> of the category of *something* *something*
23:26:54 <merijn> eh
23:26:58 <merijn> s/type/newtype
23:27:07 <pastorn> shachaf: thanks :D
23:27:11 <shachaf> merijn: That's not even valid syntax, then.
23:27:33 <merijn> I'm getting confused by myself now
23:29:19 <merijn> I'll go back to reading first
23:30:31 <drbean> @pl not $ elem p [0..10]
23:30:32 <lambdabot> not (elem p [0..10])
23:30:50 <newsham> this is somewhat on-topic, right?  http://www.thenewsh.com/~chat/j/XPrelude.java
23:31:04 <shachaf> newsham: Take it to #masochism, please.
23:33:22 <newsham> but i didnt even define show or bind yet.
23:33:47 <drbean> @pl not ( elem x [0..10] )
23:33:47 <lambdabot> not (elem x [0..10])
23:44:58 <christo_m> lispy: i was going to use the Reader monad but found theres getState and setState functions in parsec: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Prim.html
23:45:14 <christo_m> im not sure if i should be constructing a symbol table with those functions, i dont see why not
