00:02:24 <cheater-> accel: what does this mean?
00:16:18 <td123> does anyone know how efficient http://hackage.haskell.org/packages/archive/kmeans/0.1.2/doc/html/Data-KMeans.html the kmeans function is implemented?
00:17:23 <td123> I currently ran it agains a list of [[Double]] 150000 elements with 5 elements per sub list and it came out to be slower then my own implementation in python by about 2.5times
00:21:10 <solrize> vectors?
00:22:53 <luite> td123: well you can click on the source link and see for yourself
00:24:28 <luite> it will likely produce some intermediate lists
00:25:00 <solrize> minimumBy can make a lot of thunks
00:27:04 <luite> td123: do you want to optimize it, or did you just want to know why?
00:29:40 <cnonim> how i can map function over list, but skip elements, which thrown exception?
00:29:53 <luite> td123: it looks like an unoptimized implementation, for clarity. not speed
00:30:18 <shachaf> cnonim: Best not to throw the exception in the first place if you can avoid it.
00:31:01 <luite> td123: you can easily make a faster version by calculating the new centroids in one pass along with the clusters, possibly with mutable arrays
00:31:29 <luite> you don't even need to calculate the clusters
00:34:51 <osfameron> morning all
00:35:52 <cnonim> shachaf: i have file, i must convert it, but some line in file not correct, if not correct line  i throw exception
00:36:11 <shachaf> Well, don't do that. Use Maybe or something instead.
00:36:22 <shachaf> Unless by "exception" you mean something like ErrorT.
00:44:39 <cnonim> "Unless by "exception" you mean something like ErrorT." i trow PatternMatchFail with not correct line in first argument
00:48:42 <cnonim> shachaf, "Use Maybe or something instead." -- I can not in one function to determine whether the line is correct or not, line have some field, and field parsed by other functions, and what do if field not correct?
00:51:16 <jeffz> cnonim: use a fold instead of a map?
00:54:26 <accel> I have a list, I want it to split into two parts: everything until the first element that satisfies pred_; and the rest of the items
00:54:29 <accel> how do I do this?
00:55:46 <Lemmih> accel: filter p, filter (not . p)
00:55:57 <Lemmih> Oh wait. you want partition.
00:55:59 <unfo-> accel, i can recommend reading: http://learnyouahaskell.com/
00:56:16 <accel> unfo-: why?
00:56:51 <unfo-> accel, it has good info on haskell, among others the answer to that question :) i found it to be a good read
00:57:28 <flux> @hoogle (a -> Bool) -> [a] -> ([a], [a])
00:57:29 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
00:57:29 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
00:57:29 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
00:57:29 <unfo-> also takeWhile might be relevant here
00:57:31 <Lemmih> accel: Or span or break. One of those functions while surely do what you want. (:
00:57:50 <accel> partition it is :-)
00:57:53 <unfo-> oh yes, break and span
00:57:54 <accel> just working on how to use it
01:00:10 <unfo-> http://learnyouahaskell.com/modules find span
01:00:44 <accel> > partition (\x -> x == 5) [1,2,3,4,5,6,7,8,9]
01:00:44 <lambdabot>   ([5],[1,2,3,4,6,7,8,9])
01:00:56 <accel> > break (\x -> x == 5) [1,2,3,4,5,6,7,8,9]
01:00:57 <lambdabot>   ([1,2,3,4],[5,6,7,8,9])
01:01:02 <accel> > span (\x -> x == 5) [1,2,3,4,5,6,7,8,9]
01:01:03 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9])
01:03:46 <accel> @type concat
01:03:47 <lambdabot> forall a. [[a]] -> [a]
01:03:57 <accel> concat [1, 2, 3, 4, 5]
01:04:05 <accel> concat ["a", "b", "c", "d"]
01:04:26 <accel> > concat ["a", "b", "c", "d"]
01:04:27 <lambdabot>   "abcd"
01:05:41 <accel> is there a function like concat
01:05:49 <accel> but intersperses another thing in between?
01:05:54 <sipa> intercalate
01:05:59 <accel> i.e. magic ["a", "b", "c", "d"] = "a,b,c,d"
01:06:01 <accel> @type intercalate
01:06:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
01:06:26 <sipa> > intercalate "," ["a","bb","ccc"]
01:06:26 <lambdabot>   "a,bb,ccc"
01:08:56 * hackagebot wai-app-file-cgi 0.1.2 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.1.2 (KazuYamamoto)
01:10:56 * hackagebot mighttpd2 2.1.2 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.1.2 (KazuYamamoto)
01:17:51 * andras is puzzled
01:18:42 <andras> i'm trying to compute a 2D FFT of a list of lists, need help
01:19:43 <andras> i'm using Numeric.FFT for that, but get memory leaks whenever I try more than one level of 1D FFT
01:21:03 <andras> the simplest idea is this: map fft $ transpose $ map fft l
01:21:23 <andras> where l is a list of N lists, each of length N
01:22:40 <ivanm> why are you using a list of lists?
01:23:00 <accel> does parsec have anything that matches the EOF character?
01:23:16 <jeffz> accel: EOF isn't a character, it's a condition
01:23:33 <andras> ivanm: why not? besides, Numeric.FFT works on lists
01:23:39 <ivanm> jeffz: that's what I was thinking
01:23:44 <merijn> jeffz: Eh, that's not right
01:23:58 <ivanm> andras: as in you're using [[a]] to represent a 2D grid?
01:24:16 <andras> ivanm: yep
01:24:27 <ivanm> that sounds horribly inefficient
01:24:39 <ivanm> unless you're just doing mapping on a row-by-row basis or something
01:25:29 <jeffz> accel: if you look at the parsec docs you'll see 'eof' "This parser only succeeds at the end of the input"
01:25:39 <jeffz> eof  = notFollowedBy anyToken <?> "end of input"
01:26:06 <ivanm> you typically wouldn't find an EOF character _within_ data
01:26:08 <andras> ivanm: gosh, you're right, it's transpose itself that takes up all the memory!
01:26:31 <andras> ivanm: so what's a better choice? Data.Array?
01:26:43 <jeffz> it's a misconception to think of EOF as a character
01:26:47 <ivanm> andras: depending on what you're doing and how complex, Data.Array, Vector, etc.
01:27:01 <ivanm> andras: or, if it's sparse, Data.Map (Int,Int)
01:27:08 <aleator> Hi! Can I have cabal install stuff in other places except my home or globally?
01:27:17 <andras> I just want row-wise and column-wise FFTs. no, the array isn't sparse
01:27:37 <andras> preferably with Numeric.FFT, not the fftw stuff
01:28:13 <ivanm> aleator: sure, just edit ~/.cabal/config
01:28:20 <ivanm> aleator: where else would you want to install it though?
01:29:09 <andras> ivanm: but Numeric.FFT uses lists for input and output, how do I deal with that then? extract a list from an array, then replace that row/column of the array with the results of the FFT?
01:29:16 <ivanm> andras: which package is Numeric.FFT from?
01:29:21 <aleator> ivanm: I'm working to get a shared environment with another researcher in our stone age cluster. 
01:29:22 <andras> ivanm: pure-fft
01:29:39 <ivanm> one thing I've done for that kind of situation is map over a list of indices...
01:30:03 <aleator> ivanm: So, no access to usr/local, so I need to put it in a shared directory.
01:30:10 <ivanm> aleator: well, you need to have a common install point
01:30:21 <ivanm> and ghc gets its metadata either globally or from ~/.ghc
01:30:26 <ivanm> so not sure how well that will work
01:30:37 <ivanm> aleator: you _can_ use something like cabal-dev though if it's for a specific project...
01:31:11 <aleator> ivanm: thanks! I totally forgot about cabal-dev
01:31:17 <ivanm> np
01:36:14 <ivanm> andras: maybe try using hmatrix's support?
01:36:34 <ivanm> though if licensing is an issue it uses gpl (as it binds to the gsl)
01:38:12 <ivanm> wow, pure-fft is yet another mmorrow package... but it still seems to be building! :o
01:38:36 <andras> ivanm: what's wrong with pure-fft?
01:39:06 <ivanm> andras: nothing is wrong with it per-se, except that it uses lists
01:39:17 <ivanm> which in many cases (like yours) aren't going to be performant
01:39:26 <ivanm> preflex: seen copumpkin
01:39:27 <preflex>  copumpkin was last seen on #haskell 14 hours, 53 minutes and 13 seconds ago, saying: (to not use it much)
01:40:05 <andras> ivanm: it appears to be pretty fast though. at least a lot faster for a 1D FFT than octave's built-in FFT...
01:40:18 <ivanm> *shrug*
01:40:54 <andras> ivanm: plus, pure-fft will happily FFT a list with length 2^16 for me, octave will not
01:41:06 <ivanm> heh
01:41:27 <ivanm> seeing who wrote it, I'd be happy to think it's correct
01:41:40 <ivanm> note, however, that he hasn't been seen for quite a while; so if there _are_ any bugs, you're out of luck
01:41:44 <ivanm> preflex: seen mmorrow
01:41:44 <preflex>  mmorrow was last seen on #ghc 1 year, 91 days, 6 hours and 50 seconds ago, saying: * mmorrow is rtfm'ing
01:41:57 * ivanm is still amazed how long it takes him to read
01:42:00 <aleator> andras: Do you force the result of the fft?
01:42:09 <ivanm> aleator: hmmm, good point
01:42:17 <andras> ivanm: anyway, hmatrix will require GSL and that's bad in my case (will need to install the result on Windoze and don't want to install libraries first before the cabal packages build)
01:42:21 <aleator> Or is this curious case of not needing random access and happy fusion?
01:42:32 <andras> aleator: what do you mean?
01:43:02 <ivanm> aleator: reading through the source... it's nested zipWiths and ++
01:43:09 <ivanm> so as a guess, I think it's not being forced
01:43:20 <ivanm> andras: when you time how long it takes, are you actually seeing results for it?
01:43:38 <ivanm> laziness could just be biting you in the proverbial...
01:43:45 <andras> ivanm: yes I am, I summed the resulting array...
01:43:59 <aleator> andras: if it's faster than octave, something is curious.
01:44:00 <ivanm> andras: and printing the results?
01:44:04 <ivanm> and it's _still_ performant? :o
01:44:07 <ivanm> aleator: agreed!
01:44:07 <andras> ivanm: not really keen on reading 65536 values, or even dumping them to the screen
01:44:12 <ivanm> andras: are the results the same?
01:44:18 <ivanm> or at least comporable?
01:44:26 <ivanm> if so... wow...
01:44:35 <aleator> andras: Just dump them into a file. That does surely forces it.
01:44:49 <andras> ivanm: the results seem to be correct, but I've never doubted it...
01:44:57 <andras> aleator: good idea, will run a test soon
01:45:06 <ivanm> aleator: "print . sum . map sum" would also force them
01:45:25 <ivanm> this really doesn't look that efficient though: http://hackage.haskell.org/packages/archive/pure-fft/0.2.0/doc/html/src/Numeric-FFT.html#fft
01:47:31 <chridi> hmh... i want to divide two Ints and get some Float.. which function do i have to use?
01:48:04 <ivanm> chridi: fromIntegral and /
01:48:12 <ivanm> though may I ask why a Float rather than a Double?
01:48:13 <chridi> ivanm: thx
01:48:39 <chridi> ivanm: its just to do some things in per cent
01:49:02 <ivanm> Double is a hell a lot more efficient though
01:49:07 <chridi> i know
01:49:19 <chridi> well.. okay.. why not Double ;)
01:49:21 <Zao> @src Ratio
01:49:21 <lambdabot> data (Integral a) => Ratio a = !a :% !a
01:49:25 <Zao> *cough*
01:50:25 <ivanm> Zao: you getting a cold?
01:50:39 * andras is worried that he abuses octave...
01:51:04 <andras> OK, in octave, a "fft(rand(4096));" runs for about 4 seconds real-time
01:51:47 <andras> runghc runs equivalent code in <1s
01:52:01 <ivanm> andras: yeah, I'm guessing that laziness is biting you
01:52:38 <andras> ivanm: here's the code in haskell:
01:53:10 <andras> main = getStdGen >>= \gen -> return (take 65536 $ (randoms gen) :: [Double]) >>= \r -> return (fft $ map (:+0) r) >>= \r' -> putStrLn $ show $ sum r'
01:53:16 <aleator> ivanm: There is something odd about octave. That should be milliseconds instead of seconds
01:53:19 <andras> that's not lazy, is it?
01:53:46 <ivanm> well, the lengths are different...
01:54:16 <andras> aleator: yes, I'm sure there's something wrong, in fact, I can't FFT a 65536-element vector in octave ("error: memory exhausted or requested size too large for range of Octave's index type -- trying to return to prompt")
01:54:24 <ivanm> and is there the possibility that in octave's case it produces the equiv of [Complex Double] which is more expensive to fft on?
01:54:44 <andras> aleator: then, again, I'm not an octave expert
01:54:56 <ivanm> also, StdGen is slow
01:55:02 <ivanm> @instances Random
01:55:02 <lambdabot> Couldn't find class `Random'. Try @instances-importing
01:55:14 <aleator> andras: Neither am I. Perhaps octave is not finding proper library or something.
01:55:15 <andras> ivanm: pure-fft works on [Complex Double] exclusively
01:55:16 <ivanm> @instances-importing System.Random Random
01:55:17 <lambdabot> Bool, Char, Double, Float, Int, Integer
01:55:23 <ivanm> andras: yeah, I know
01:55:48 <ivanm> but I'm saying that maybe since you're only generating real numbers rather than complex ones, it's giving pure-fft an advantage
01:56:42 <aleator> ivanm: But still, fftw on octave seems awfully slow even with complex numbers
01:56:49 <andras> ivanm: I'm not: the output of the FFT is complex, it's just the input that has all imaginary parts zeroed, but they're still present
01:57:00 <ivanm> aleator: yeah
01:57:23 <ivanm> andras: right; but is it cheaper to do fft of real numbers than complex ones?
01:57:41 <ivanm> and thus by having all the complex parts be 0, is it giving it an extra advantage?
01:59:02 <andras> ivanm: maybe, but not this much...
01:59:31 <aleator> ivanm: I think it could calculate only half of the output..
02:00:01 <ivanm> andras: probably
02:00:20 <andras> aleator: the "sum r'" computes the complex sum, so I don't think pure-fft can save anything there
02:01:00 <co_dh> greeting, am I the only one that found the agda2 compiler is so slow ? 
02:11:53 <sonoflilit> Hi
02:12:28 <sonoflilit> I have code that performs horribly, taking up way too much memory and swapping memory like there was no tomorrow
02:12:48 <sonoflilit> Passing -M500M solves it, and the code suddenly performs OK
02:12:58 <sonoflilit> and I wonder
02:13:13 <sonoflilit> shouldn't there be a less-violent way of doing it?
02:14:10 <sonoflilit> It doesn't sound reasonable to me that the only way I can make my code perform well is by limiting its resources "hard"
02:15:27 <merijn> It very much depends on what you're doing. Finding a universally optimal resource management algorithm is somewhat non-trivial :>
02:17:37 <sonoflilit> but shouldn't it be easy to make the algorithm customizable to behave like it had other physical parameters?
02:17:57 <merijn> Isn't that what -M500M and other options are doing? :p
02:18:58 <sonoflilit> -M500M is hard limiting
02:19:02 <sonoflilit> I want soft limiting
02:19:13 <sonoflilit> and it seems like -F is what gives me soft limiting
02:19:34 <merijn> I'm pretty sure there is soft limiting too, but don't ask me which option it is
02:19:49 <sonoflilit> I initially tried -F1.5 and got bad results, but now tried -F1.1 (which I was sure was way overdoing it) and got results that are twice as good as -M500M
02:19:57 <sonoflilit> actually runs *twice as fast*
02:20:03 <merijn> \o/
02:20:34 <sonoflilit> yeah, but I feel like I'm in a huge dark room full of heavy machinery
02:20:51 <sonoflilit> I have no idea what's the correct number to choose
02:21:35 <merijn> You could try use a program to figure out which options to use, something like: http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
02:21:35 <sonoflilit> or how it would behave the 10th time I invoke it, as -F controls the factor of the new GC target number from the old GC target number on every GC iteration
02:21:42 <sonoflilit> IIUC
02:24:00 <sonoflilit> merijn: that's a cool toy, but I'm really not sure it would apply well in my situation - as load from multiple users using my software would be hard to predict and thus simulate
02:24:49 <sonoflilit> is there a way to get good logging of GC behaviour?
02:25:08 <sonoflilit> this is beginning to sound like something to ask on #ghc
02:25:36 <companion_cube> i think you can profile heap use and memory allocation
02:25:45 <merijn> Probably, but most of the people who know this stuff very well are still asleep I think. In an hour or 2 I'd guess there will be more people around who are capable of answering these questions
02:25:47 <ivanm> sonoflilit: see the profiling bit in RWH
02:25:52 <ivanm> it talks about memory profiling, etc.
02:27:03 <sonoflilit> ivanm: it's very basic from what I remember. I've read it a while ago and skimmed through it again many times
02:31:05 <ivanm> sonoflilit: it's pretty good IMHO
02:31:30 <kevinburke> really unsatisfied with haskell indentation in vim - i've been using the script here, http://www.vim.org/scripts/script.php?script_id=1968, are there any better options?
02:32:37 <quicksilver> kevinburke: I don't use vim, but there is much newer stuff here : http://projects.haskell.org/haskellmode-vim/
02:33:48 <fabb> @type map
02:33:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:40:43 <andras> what's the best way of replacing a row or column of an Array (from Data.Array) with values calculated from the original row or column?
02:41:03 <Twey> Why does Pandoc keep replacing all my hyphens with en dashes?
02:41:18 <Twey> andras: If you're talking about rows and columns, I think you want a Vector instead
02:41:20 <andras> I have to do this kind of processing over each column and each row, twice, and get horrible memory usage
02:41:32 <shachaf> Twey: Because that's what you mean.
02:41:44 <andras> Twey: isn't Vector 1-dimensional?
02:41:49 <Twey> shachaf: No it's not >.>
02:41:52 <Twey> andras: No
02:41:58 <ivanm> @hoogle updateArray
02:41:58 <lambdabot> No results found
02:42:04 <shachaf> Twey: Hush.
02:42:11 <Twey> Haha
02:42:23 <ivanm> Twey: what is it then?
02:42:26 <shachaf> I think Pandoc knows what kind of dashes you mean to type into your document.
02:42:30 * shachaf >>= undefined
02:42:46 <Twey> ivanm: What is what?
02:42:59 <ivanm> dimensionality of Vector
02:43:05 <Twey> Two, I think
02:43:07 <ivanm> I had heard it was 1D...
02:43:09 <ivanm> huh
02:43:29 <Twey> Oh, sorry, I'm being an idiot again
02:43:31 <Twey> I meant Matrix
02:43:32 <andras> this is what we're talking about, isn't it: http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector.html
02:44:22 <andras> Matrix? what module is that in?
02:44:25 <Twey> http://hackage.haskell.org/packages/archive/hmatrix/0.11.0.4/doc/html/Data-Packed-Matrix.html
02:47:23 <andras> Twey: oh, it's hmatrix again. that's what I was trying to avoid...
02:48:06 <andras> Twey: is there really no good way of calculating a 2D FFT in Haskell without depending on a C library???
02:49:14 <ivanm> andras: use a vector or something and keep pulling values in/out into lists?
02:50:26 <andras> ivanm: I tried that with Array from Data.Array, it works, but uses a LOT of memory
02:53:40 <fabb> @pl (return . maximum =<<)
02:53:40 <lambdabot> (maximum `fmap`)
02:53:49 <Twey> andras: Everything you do in Haskell depends on a C library, assuming you're not running House.
02:54:09 <fabb> @pl fmap maximum
02:54:09 <lambdabot> fmap maximum
02:54:21 <fabb> @pl (fmap maximum)
02:54:21 <lambdabot> fmap maximum
02:55:15 <ivanm> andras: yeah, Array isn't that performant
02:55:22 <ivanm> DiffArray _may_ work better for you, but I doubt it
02:55:28 <ivanm> Twey: he means extra dependencies
02:55:38 <ivanm> since he's on WIndows, it's difficult to compile extra C libs
02:55:40 <andras> Twey: I mean, I need to install this program on Windoze when I'm finished, and all I'd like to use is whatever is included with GHC/Windows and any cabal packages that don't require any extra C libraries to be present (which can be a pain to install)
02:57:07 <rostayob> I know nothing about statistics, is there an haskell equivalent of this ruby function: Statistics2.pnormaldist(pr) Returns the P-value of normaldist(x).
02:57:39 <ivanm> dunno; try the statistics library and possibly in the Numeric part of hmatrix
02:58:43 <rostayob> ivanm: the thing i found is this
02:58:52 <rostayob> @hoogle normalDistr
02:58:52 <lambdabot> No results found
02:58:55 <rostayob> :t normalDistr
02:58:57 <lambdabot> Not in scope: `normalDistr'
02:58:59 <rostayob> well anyway
02:59:10 <rostayob> to get the normal distribution
02:59:15 <rostayob> but not the P-value
03:02:15 <pmurias> how should i integrate cabal build with vim's quick fix feature?
03:07:29 <Lemmih> Has hackage stopped building haddock documentation?
03:08:09 <Lemmih> Seems like it hasn't built anything in the last couple of days.
03:32:52 <crystal-cola> how can people learn programming languages like as mad as haskell? but can't even understand what whales or birds say?
03:33:15 <merijn> Because Haskell isn't mad? :>
03:33:21 <merijn> It's the rest of them that are mad :>
03:33:27 <Jafet> @protontorpedo
03:33:28 <lambdabot> is there going to be a better dns server in haskell?
03:35:17 <shachaf> @vixen is there going to be a better dns server in haskell?
03:35:18 <lambdabot> church is my favourite computer scientist.
03:37:12 <Twey> Mad, they said I was mad!
03:38:48 <vegai> http://www.youtube.com/watch?v=CK0cUv3ba-o
03:46:25 <Yrogirg> Hello! What are the most common (most in use) strict analogues for tuples?
03:47:25 <Jafet> I use unboxed tuples all the time (without actually using them, of course)
03:47:27 <Twey> You mean unboxed tuples?
03:47:31 <Twey> Haha
03:53:00 <mm_freak> Yrogirg: data StrictDuple a b = StrictDuple !a !b
03:54:09 <mm_freak> crystal-cola: haskell programmers can actually talk to birds
03:54:17 <mm_freak> using lenses and bananas
03:54:25 <crystal-cola> wat lol?????
03:54:53 <Twey> @faq Can Haskell enable human–avian linguistic communication?
03:54:53 <lambdabot> The answer is: Yes! Haskell can do that.
03:55:10 <mm_freak> well, assuming that they understand bird's formalism
03:55:13 <merijn> Isn't the linguistic part superfluous?
03:55:18 <Twey> Heheheh
03:55:31 <Twey> merijn: No; you can have non-linguistic communication
03:55:35 <crystal-cola> why cna'#t we analyze the sounds they make and undesrtand it?
03:55:44 * Twey points at the moon.
03:56:01 <crystal-cola> im asking the other chan because nobody here takes it seriously
03:56:25 <merijn> My dictionary says "linguistic -> of/or relating to language". How would you have communication without language?
03:56:38 <merijn> I'm pretty sure communication always implies language
03:57:04 <mm_freak> crystal-cola: because all you would understand is like "i want a girl to fuck"
03:57:06 <xplat> there is such thing as non-linguistic communication
03:57:23 <crystal-cola> How do you know that a-priori
03:57:49 <merijn> xplat: Example please? Twey's example of pointing is hardly an example of non-linguistic communication. That's just non-verbal
03:57:56 <mm_freak> crystal-cola: well, because all sounds a bird makes, which you can actually hear is about finding a girl
03:58:12 <xplat> merijn: facial expression
03:58:13 <merijn> mm_freak: Or predators, or scaring away/intimidating rivals
03:58:20 <mm_freak> hmm, indeed
03:58:22 <merijn> xplat: And that's not a language?
03:58:28 <nazgjunk> non-verbal is definitely a lot more specific
03:58:29 <mm_freak> ok, now we have three sounds
03:58:30 <merijn> I beg to differ
03:58:32 <nazgjunk> language is just another word for code, really
03:58:43 <mm_freak> birdLanguageToEnglish :: Sound -> a
03:58:57 <merijn> Language just implies a mapping of code to semantics. Linguistic means related to language
03:59:29 <merijn> Anything you can use to meaningfully transmit semantics to me is therefore language. Making the linguistic part superfluous
03:59:52 <xplat> merijn: cats and dogs have expressions and 'body language', although they're somewhat different from humans.  so i don't think they're 'language' in a way that would necessarily distinguish humans from birds, regardless of definitions
04:00:15 <mm_freak> so we have three expressions now:  "i want to fuck", "i want to kill you" and "you'll be my dinner, dumbass"
04:00:20 <mm_freak> birds are quite rock-n-roll…
04:00:26 <Twey> Haha
04:00:36 <mm_freak> lunch time…  i will listen carefully, perhaps i come up with a translator
04:00:50 <merijn> mm_freak: You forgot "Hey! Someone is trying to kill me!"
04:00:57 <mm_freak> merijn: oh, yes
04:00:58 <xplat> well, remember, birds are the surviving dinosaurs
04:01:06 <Twey> merijn: A language requires grammar
04:01:09 <mm_freak> "police! police!"
04:01:32 <Twey> Pointing is not a language because it has no defined grammar
04:01:42 <Entroacceptor> but pointing can be communication
04:02:05 <xplat> pointing is also a form of communication most animals fail to recognize
04:02:14 <Twey> You can use different signals close to one another, and someone may figure out what the intended relation between them is, but there's no way to make that relation clear
04:04:02 <merijn> Why does pointing not have a grammar? I think there's only a handful combinations of pointing you can use. Which I suppose may have ambiguous semantics, but so does English...
04:04:41 <Twey> It doesn't just have ambiguous semantics, it has *no* semantics
04:05:01 <xplat> merijn: it's more a matter of pointing not having a complex enough grammar, as far as what people mean by saying that
04:05:19 <Twey> There is absolutely no definition of what one indication means in relation to other indications in its sequence
04:05:24 <Maxdamantus> But wouldn't pointing to the Moon be likely to mean what "the Moon" means in English?
04:05:25 <xplat> (what people THINK they mean could be another matter though O_o)
04:05:58 <Twey> Maxdamantus: Sure.  That is one signal.
04:06:02 <merijn> I would assume a sequence of pointing action implies a connection between the pointed at object. I think those semantics are pretty universal. What said connection is, is of course unclear and left up to context
04:06:09 <Maxdamantus> So there's your semantics.
04:06:13 <merijn> s/objects
04:06:13 <Twey> If I point at the moon and then at the dog, what is the relation between the moon and the dog?
04:06:26 <Maxdamantus> There's not necessarily a relation.
04:06:26 <ousado> sign language exists
04:06:33 <Twey> Indeed, there isn't necessarily a relation
04:06:33 <xplat> it means you're saying 'moondoggie'
04:06:34 <Maxdamantus> But you're meaning the dog and the Moon.
04:06:38 <merijn> Twey: The act of pointing establishes "there is a relation between the moon and the dog", which has meaning
04:06:47 <merijn> It's just not very specific about what said relation is
04:06:49 <Twey> ousado: Yes, and sign languages are full languages with grammars.  That's not what we're talking about here.
04:06:55 <Twey> merijn: Not necessarily
04:06:58 <Twey> As Maxdamantus said
04:07:00 <xplat> ousado: sign language is very different from body language though
04:07:20 <Twey> They might be completely unrelated; I might have just happened to be talking about one directly after the other
04:08:06 <xplat> merijn: so you're telling us to moon your dog?
04:08:30 <merijn> xplat: Go ahead, I'm not responsible for any injuries, though :p
04:09:27 <ousado> Twey: indeed, you're talking about a less evolved form of sign language
04:10:08 * Maxdamantus has successfully communicated with people in pseudo-sign languages.
04:10:40 <xplat> yeah, it's like the sign language equivalent of saying 'me choco nom nom nom'
04:10:40 <Twey> ousado: Pointing is to sign language what screaming is to speech
04:11:12 <Maxdamantus> xplat: you eat chocolate?
04:11:27 <Twey> ‘AAAAAAAAHHHHHHH!’ ‘What?’ ‘AAAAAAAAAAAAAHHHHHHH!’ ‘I don't understand you!’ ‘AAAAAAAAAAAAAAAAAHHHHHHHHHHHHHHH!’
04:11:29 <Maxdamantus> Anyway, that's not what it's like.
04:11:47 <xplat> Maxdamantus: i WANT to eat chocolate.  that's why this kind of communication is not as effective as a real language.
04:11:59 <Maxdamantus> xplat: damn, ambiguities.
04:12:08 <merijn> Tell that to babies, it works for them ;)
04:12:25 <Twey> merijn: Not exactly
04:12:27 <xplat> parents are motivated.
04:12:46 <xplat> and the screaming helps when the motivation falters
04:12:47 <Twey> It's more that babies have only about three things they try to communicate, and parents just try them all :þ
04:12:50 <Twey> Haha, yes
04:13:08 <Maxdamantus> AHHHHHHHH I CAAAAN'T STOOOP SCREAAAMING
04:14:16 <Maxdamantus> AH AH AH .. AHHH AHHH .. AH AH AH
04:14:31 <Twey> Heh, didn't Harry Harrison have a book with some people who used wordless screaming as a trade language?
04:14:46 <xplat> wookies?
04:15:05 <Maxdamantus> Eh, did it wrong.
04:15:10 <Maxdamantus> AH AH AH .. AHHH AHHH AHHH .. AH AH AH
04:15:24 <merijn> That reads like porn for the deaf
04:31:12 <ousado> Twey: I don't agree. you seem to make the claim that it is impossible to develop forms of ad-hoc sign languages. 
04:31:23 <Twey> I don't
04:31:48 <Twey> I merely make the claim that they need developing before they can be considered languages
04:32:27 <Twey> Basic grammar can evolve quite quickly in real situations, where there are other avenues of communication that can be used to express the grammar as well
04:32:33 <cheater> code and language is different
04:32:36 <Twey> (facial expression, mime, &c.)
04:32:40 <cheater> language contains grammar and vocabulary
04:34:29 <ousado> Twey: sure you do, you said "there's no way to make that relation clear" 
04:35:49 <Twey> ousado: Sorry, that was perhaps a bit poorly phrased
04:36:17 <Twey> I meant to say that the language as it stands at that point has no way of communicating the relation
04:36:23 <Twey> ‘language’
04:37:09 <Twey> If I point at a dog and at an apple, and I want to express that I intend you to feed the dog the apple, I can't do that
04:37:40 <Twey> In a real-life situation, I can add grammar to the language by communicating it through some other, more capable avenue, perhaps by mime
04:37:58 <Twey> And thus make the relation clear
04:38:38 <Twey> However, if I am restricted *only* to pointing, I have no way to communicate that; the best I can do is involve as many concrete elements of the relation as I can and hope you guess what I mean the relation to be
04:38:59 <Twey> (which, if you get it right, can also be used to build grammar for future utterances)
04:39:15 <merijn> Twey: You'd still be communicating the perceived presence of such a relation, no?
04:39:55 <Twey> merijn: Not really, no; like Maxdamantus said way up there, it's also possible that I don't intend there to be a relation at all, and the juxtaposition of the dog and the apple was just an unfortunate coïncidence
04:54:22 <nazgjunk> hooray, lyah came in the mail.  My Kindle's great, but for stuff like this it's great to be able to flip back to stuff easily
04:54:50 <aleator> How do I set rpath through cabal?
04:55:11 <dcoutts> ghc-options
04:56:16 <hpc> my lyah hasn't come yet
04:59:13 <aleator> dcoutts: Thanks!
05:01:15 <aleator> dcoutts: Since you're around and google is failing me, is there any way to supply a different config file than ~/.cabal/config for cabal
05:02:52 <dmwit> ?remember Maxdamantus [on babies communicating] AHHHHHHHH I CAAAAN'T STOOOP SCREAAAMING AH AH AH .. AHHH AHHH AHHH .. AH AH AH
05:02:52 <lambdabot> Nice!
05:04:09 <dcoutts> aleator: there is yes, it's a global option that comes before the cabal subcommand
05:04:18 <Maxdamantus> It's not on babies communicating.
05:04:28 <Maxdamantus> It's on using screaming as a form of communication.
05:04:57 <dcoutts> aleator: e.g. cabal --config-file=blah install thing
05:05:11 <aleator> dcoutts: Otherwise I'd just use cabal-dev/cabal.config but that seems to get run over every install.
05:05:24 <aleator> But that will work just as good.
05:05:32 <dcoutts> aleator: e.g. you could alias cabal-blah as cabal --config-file=blah
05:05:39 <Maxdamantus> ?remember dmwit [on misunderstanding context] ?remember Maxdamantus [on babies communicating] AHHHHHHHH I CAAAAN'T STOOOP SCREAAAMING AH AH AH .. AHHH AHHH AHHH .. AH AH AH
05:05:39 <lambdabot> I will never forget.
05:06:32 <aleator> dcoutts: great!
05:16:02 <roconnor> any type theoritic langauges out there with only poly-time functions?
05:19:58 <rostayob> @pl \postE -> votePost postE up >> seeOtherURL redir
05:19:58 <lambdabot> (>> seeOtherURL redir) . flip votePost up
05:22:22 <hpc> roconnor: would it be possible to enforce that with just types?
05:23:25 <crystal-cola> I think the simple lambda calculus is polytime
05:24:57 <crystal-cola> maybe only functions on church numerals
05:26:23 <crystal-cola> "Augmenting the typed lambda calculus with a polymorphic pairing operator and a free algebra over {0,1} with associated constructor, destructor and discriminator functions obtains a calculus in which exactly the PTIME computations are expressible" - Finite Model Theory In The Simply Typed Lambda Calculus
05:27:22 <crystal-cola> "Every PTIME query can be expressed in datalog"
05:29:09 <roconnor> hpc: I think so; but recursion would be limited, like in Agda/Coq, but more stringently in some way.
05:30:02 <roconnor> crystal-cola: I don't get it.  Isn't exponentiation for the church numerals easy to implement (it is just composition)
05:30:14 <roconnor> ... wait maybe exponentiation isn't typeable.
05:30:59 <crystal-cola> roconnor: exponentiation should take exponential time?
05:31:02 <roconnor> crystal-cola: I guess the free algebra over {0,1} is supposed to be binary numerals?
05:31:04 <crystal-cola> I'm not sure what you mean
05:31:28 <roconnor> though I'm not sure what the free algebra is precisely
05:31:58 <roconnor> crystal-cola: what prevents me from implementing the exponential function in the typed lambda calculus?
05:32:04 <roconnor> *simply typed lambda calculus
05:32:30 <crystal-cola> oh I see if you could define exponential then you could define an exponential time function using it as input
05:32:42 <rostayob> @pl \postE -> query (votePost postE up) >> seeOtherURL redir
05:32:42 <lambdabot> (>> seeOtherURL redir) . query . flip votePost up
05:33:30 <crystal-cola> This paper says that definable functions with beta reduction simply typed lambda calculus functions on (p->p)->p_.p are exactly the "extended polynomials"[Schwichtenbergs theorem]  (but with eta you can define more things). -- Definable functions in the Simply Typed lambda-calculus
05:34:29 <crystal-cola> extended polynomials means 0, 1 , projection, addition, multiplication, ifzero and is closed under composition
05:36:27 <roconnor> crystal-cola: ya, I don't think composition of church numerals is definiable in the STLC
05:36:38 <roconnor> crystal-cola: I think you need polymorphism to get it to work
05:36:59 <crystal-cola> STLC doesn't have polymorphism though
05:37:59 <roconnor> which is why composition of church numerals is impossible (I think)
05:38:26 <roconnor> I wonder if we could scale this PTime langauge into a "real world" langauge with (restircted) data types and stuff
05:40:48 <crystal-cola> roconnor: maybe, it says you can throw in free algebras
05:40:58 <crystal-cola> also datalog
05:41:39 <roconnor> also, in a completely unrelated note, is there some notion of a "connection" on categories that allows for you to transport (or rebase) arrows from one object to another?
05:41:51 <roconnor> crystal-cola: datalog?
05:42:33 <crystal-cola> the first paper I mentioned is all about using query langauges for restricted complexity languages
05:43:18 <crystal-cola> I haven't read it but I think it's defining a type of "query" on lambda terms that is exactly PTIME computable functions
05:43:35 <crystal-cola> rather than evalutaion
05:49:41 <crystal-cola> This is interesting too perso.ens-lyon.fr/hugo.feree/rapport0510.pdf - they define a haskell like language for R -> R functions which is connected with polytime computable functions
05:57:46 <roconnor> o_O
06:04:41 * hackagebot containers-benchmark 1.0.0.3 - Extensive benchmark suite for containers package.  http://hackage.haskell.org/package/containers-benchmark-1.0.0.3 (MilanStraka)
06:04:46 <crystal-cola> roconnor: why??
06:05:41 * hackagebot hashmap 1.1.0.1 - Persistent containers HashMap and HashSet.  http://hackage.haskell.org/package/hashmap-1.1.0.1 (MilanStraka)
06:06:03 <roconnor> crystal-cola: computational complexity of real number computations.
06:06:23 <crystal-cola> I think it's using an oracle
06:06:29 <crystal-cola> and considering calls to it O(1)
06:06:37 <roconnor> oh
06:06:39 <roconnor> meh
06:24:19 <MasseR> Hmph. Haskell is getting in the way of my /usr/sh
06:24:35 <MasseR> I almost got confused whether >> is append or rewrite
06:24:38 <MasseR> (in shell)
06:25:13 <dafis> heh :)
06:25:19 <MasseR> Since in haskell >> is "less data" and >>= is "all data" (bear with me), whereas in shell >> is more data and > is less data :P
06:27:45 <arcatan> they both throw previous stuff away
06:40:09 <whald> hello, i have some doubts how to go on with developing this: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Random.hs module of my raytracer, anyone has a few minutes to give me advice on the do's and don'ts with this?
06:41:17 <whald> this is the code for generating random values in my ray tracer, i have a "Rand" monad and every functions which needs random values is in that monad
06:41:41 <whald> i think that's acceptable so far
06:42:53 <whald> but the code as it stand has no chance to produce well distributed random values, for example the camera samples: we know that we're shooting, say, 32 samples per pixel for the final image
06:43:43 <whald> so it's a good idea to stratify these samples to get much lower variance (the stratified2D function generates startified samples, but is currently unused throughout the rest of the progrem)
06:44:48 <whald> what i basically envision is replacing the "Rand" monad with the "Sampled" monad, which would then be a "merge" of the Rand and the CameraSample type
06:46:16 <whald> and the accompanion "runSampled" function would take parameters which told it to prepare (n,m) well-distributed (1D,2D) samples which would be returned from the rnd / rnd2D functions
06:46:40 <whald> does this make any sense so far to anyone? :-)
06:48:02 <companion_cube> your raytracer is nice, but i do not know much about random :)
06:49:04 <whald> oh, and anything running in the Sampled monad would be allowed to draw more values that originally announced to the runSampled function, but these would then be satisfied using (poorly distributed) values from the RNG
06:51:42 <whald> companion_cube: well, i think it's not so much about random but managing state. the RNG obviously needs state, but the pre-processd, well distributed values are constant (within one evaluation of runSampled)
06:51:59 <whald> i fear this doesn't mix well, is a design smell, whatever
06:52:33 <whald> i have almost no experience in this field, and fear doing a lot of work which is broken design to start with
06:53:28 <whald> i don't know how to structure this so GHC has at least a chance to come up with something that performs :-)
06:54:25 <whald> maybe my initial intention of merging CameraSample and Rand is just fine, i'd just like some input on this before i start
06:55:22 <companion_cube> you can use State monad, I suppose
06:55:55 <companion_cube> the less monads you will stack, the faster it will work, i think
06:58:28 <eevar> what does http://hpaste.org/45655/yesod_waihandledevel mean?
07:00:35 <dafis> eevar: probably different versions of the package
07:01:23 <eevar> dafis: guess that makes sense. thanks
07:20:52 * hackagebot grammar-combinators 0.2.6 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.6 (DominiqueDevriese)
07:29:01 <jonkri> is this a nice way of creating a synchronous function in an asynchronous environment? http://hpaste.org/45844/synchronous_function_in_asyncr
07:34:00 <adamvh> Does anyone know of a good way to convert between a Data.Tree and a Data.Graph?
07:34:12 <td123> luite: sorry, I went to bed when you said that, I would like to know why if possible
07:34:34 <adamvh> (or a way to generate a graphviz file from a Data.Tree?)
07:35:44 <jonkri> also, how can i have the readMVar call time-out?
07:37:03 <td123> luite: I was really turned off because it was slower then a python implementation by about 5 times, and the code looks pretty clean :/
07:38:44 <luite> td123: you can perhaps speed it up easily if the program spends a lot of time collecting garbage
07:41:00 <luite> td123: another thing to look for is whether the kmeans code is properly specialized
07:41:59 <td123> luite: unfortunately I don't know how to do that, I just started learning haskell 2 or 3 days ago
07:42:54 <td123> one of the main reasons I chose it was because I saw it was a lot faster in some benchmarks against python :P
07:42:58 <luite> td123: but I think that the main issue with this code is that it copies lists of points every time. it's probably better to just keep the original list and modify only the centroids (using accumulators)
07:44:21 <td123> luite: ah
07:44:55 <dafis> td123: can one have a look at the code in question?
07:45:06 <td123> dafis: certainly
07:45:16 <td123> dafis: http://hackage.haskell.org/packages/archive/kmeans/0.1.2/doc/html/src/Data-KMeans.html#kmeans
07:46:57 <td123> luite: my python implementation does in fact keep track of only the cluster a data point belongs to, it doesn't modify the original input at all
07:47:05 <td123> you raise a valid point
07:47:16 <luite> td123: I think you don't even need to keep track of that
07:47:43 <luite> but I might be overlooking something, I haven't used this algorithm before
07:47:48 <td123> luite: you are correct
07:48:16 <td123> wait no..
07:48:20 <luite> if the centroids don't change anymore then you have convergence
07:48:23 <td123> heh, you do need to keep track of it
07:48:31 <td123> nvm
07:48:31 <luite> why?
07:48:54 <td123> luite: you're correct sorry :P
07:49:16 <td123> I was about to say you need to keep track of convergence, but that previous statement makes perfect sense
07:49:22 <dafis> td123: in part, use null zs' instead of zs' == [], that's cleaner
07:49:36 <td123> dafis: not my code :P
07:50:50 <td123> luite: but you should assign clusters at the end though since you probably wouldn't want to return just a list of clusters
07:50:58 <td123> err their centroids
07:51:12 * td123 goes grab some coffee to wake up
07:51:13 <luite> yes but you only need to do that one time, that shouldn't make it much slower
07:51:27 <td123> luite: agree
07:52:03 <td123> oh well.. I guess I'll just reimplement it myself, maybe there is hope yet!
07:53:40 <luite> hehe it should certainly be possible to make this much faster. the update is basically a fold, where you start with the old centroids and some accumulators, and you fold over the list of samples
07:54:43 <luite> you can start with a regular fold and use some data structure that's relatively quick to update
07:55:04 <luite> perhaps a Map or IntMap
07:55:57 <td123> luite: that's actually where I stopped with reading "yet another haskell tutorial" because I found out FiniteMap has been deprecated for a while, and I stopped reading at that point :P
07:57:51 <luite> td123: a regular Map will probably do for now, you could label your clusters with an integer, and map those integers to the accumulators for the new centroids
08:01:54 <luite> td123: and if you really want to squeeze out the last drop of performance (might be a big drop :p ) then you could replace it with a mutable array, like STUArray. But it's probably best to save that one for later
08:09:08 <luite> td123: an even better approach might be to use accumArray
08:10:29 <luite> td123: where you first map a list [Point] -> [(Cluster,Point)], where Cluster is an Int
08:11:09 <luite> td123: and then you use accumArray to add the points for each cluster
08:11:37 <td123> you also need to keep track of the number of points also
08:11:42 <luite> td123: this is not entirely correct, indeed
08:11:47 <luite> I was just typing that :)
08:11:51 <td123> :P
08:12:48 <luite> but you can fix that with the accumulation function
08:14:06 <td123> ya
08:15:48 <luite> td123: one potential pitfall here is laziness, you may need to force evaluation in the accumulation function to get good speed
08:18:15 <td123> ya, I just learned how to force evaluate things :P I rmeembered yesterday when I did the kmeans on haskell that the program would probably return if I didn't put ! in from of the calculation
08:18:59 <td123> I wonder how well haskell would be for writing a scheduling algorithm :P
08:19:23 <luite> you'll likely use tuples here, keep in mind that putting a ! before a tuple will not evaluate its components
08:22:01 * hackagebot hsemail 1.7.1 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.1 (PeterSimons)
08:24:51 <Rich_Morin> "let" expressions seem to allow a form of mutable state.  Are they implemented in a way that makes this thread-safe?
08:25:16 <luite> td123: say your function is acc (pointSum, count) point = (zipWith (+) pointSum point, count + 1), then you'd need to force the arguments with something like: pointSum `deepSeq` count `seq` original here
08:25:29 <luite> Rich_Morin: let bindings are not mutable
08:26:22 <luite> Rich_Morin: you can shadow a previous binding by another with the same name, but you really can't update something (i.e. all expressions that refer to the old let binding still see the old one)
08:26:44 <td123> luite: why does this work in ghci then? "let a = 5; a returns 5; let a = 6; a returns 6" ?
08:26:58 <td123> oh
08:27:20 <td123> it just appears to be mutable :P
08:27:43 <luite> yes, try something like let a = 1; let b = 2*a; let a = 3;
08:27:50 <luite> and check what b is :)
08:28:02 <Rich_Morin> I thought I saw an example where a let expression used a function parameter.  So, if the function got called twice by two different threads, are two differenct values being used at the same time?
08:28:25 <dafis> > let a = 1; b = 2*a; a = 3 in (b,a)
08:28:26 <lambdabot>   Conflicting definitions for `a'
08:28:26 <lambdabot>  Bound at: <interactive>:1:4
08:28:26 <lambdabot>            <in...
08:29:10 <luite> Rich_Morin: well that's a local let binding, in the scope of the function. they don't see each other, each call will have its own (immutable) one
08:29:37 <Rich_Morin> works for me
08:29:38 <dafis> > let a = 1 in let b = 2*a in let a = 3 in (b,a)
08:29:39 <lambdabot>   (2,3)
08:44:00 <tafryn> Can anyone explain to me why the memory usage of this example seems to grow without bound? http://hpaste.org/45821/vtyui_date_display
08:48:21 <zygoloid> tafryn: what is 'schedule'?
08:48:59 * quicksilver dares to guess it's something which runs an IO action in the main GUI thread
08:52:41 <pastorn> tafryn: what's the type of withNormalAttribute?
08:54:26 <pastorn> tafryn: i have no idea if this can work, but try adding a variable in which you put the current time from the loop instead of using it directly
08:54:40 <pastorn> then move the setText thing into the main loop
08:58:48 <tafryn> pastorn: withNormalAttribute :: (HasNormalAttr w) => Graphics.Vty.Attributes.Attr -> w -> IO w
09:01:20 <tafryn> zygoloid: schedule schedule :: IO () -> IO ()
09:02:07 <tafryn> zygoloid: It's used to insert some action at the beginning of the main loop that's kicked off by runUI
09:03:56 <zygoloid> tafryn: well, that's the most likely thing to be retaining memory i think
09:06:28 <dmwit> schedule just writes to a channel (which runUi' reads from).
09:06:33 <dmwit> I doubt that's the issue.
09:06:50 <dmwit> When you say its memory use grows without bound, what makes you say that?
09:09:33 <tafryn> dmwit: Well, when you monitor the memory usage of that example it just continues to grow over time. It's more apparent when invoked with runhaskell, but it is still present when running the compiled version.
09:10:39 <dmwit> Over how long a time? How big does it get? NUMBERS man, numbers! ;-)
09:10:48 <JuanDaugherty> rly
09:11:11 <dmwit> I wouldn't be surprised if the RTS simply hadn't made it to a garbage-collection yet by the time you got worried.
09:12:27 <dmwit> P.S. GHC's RTS never releases memory
09:13:04 <osfameron> what am I doing wrong here? https://gist.github.com/928692
09:13:22 <osfameron> I get an error about the declaration of "Quiz"
09:13:37 <osfameron> I think related to using a class name as a type, but I don't know what to use instead
09:13:44 <tafryn> dmwit: Well, (with runhaskell) it starts off with around 76M usage and grows at roughly 500K/sec.
09:13:50 <dmwit> osfameron: ModuleNode is a class, not a type constructor.
09:14:03 <dmwit> osfameron: Use a particular instance of the class.
09:14:09 <osfameron> dmwit: well, I want to be able to use any instance of that class
09:14:22 <tafryn> dmwit: I've watched it grow beyond 200M.
09:14:25 <dmwit> osfameron: Then you'll need an existential wrapper.
09:14:39 <osfameron> dmwit: eeeek!
09:14:45 * osfameron googles existential wrappers
09:14:49 <miller> Yay newbie issues! http://pastebin.com/X7iv4JUw  Any help, please? :S
09:14:54 <dmwit> tafryn: 200M doesn't sound too bad. If you're really worried, run it with a small heap limit, like 100M, and see if it crashes.
09:15:45 <dmwit> tafryn: My guess is it will get up to 100M and stay there, and just thrash doing GC or so.
09:15:58 <dmwit> For relatively benign definitions of "thrash".
09:16:23 <dmwit> miller: The patterns "(x:xs)" and "[x:xs]" are not synonymous.
09:16:40 <miller> Oh. Okay.
09:16:43 <miller> Thanks.
09:16:59 <rtharper> does the second one even parse?
09:17:05 <dmwit> The former matches a non-empty list, binding "x" to the head and "xs" to the tail; the latter matches a length-one list containing a non-empty list, binding "x" to the head of the head, and "xs" to the tail of the head.
09:17:09 <dmwit> rtharper: Yes.
09:17:12 <rtharper> ah
09:17:13 <rtharper> weird
09:17:26 <dmwit> > let [x:xs] = [[1,2]] in (x, xs)
09:17:27 <lambdabot>   (1,[2])
09:17:37 <dmwit> > let (x:xs) = [[1,2]] in (x, xs)
09:17:38 <lambdabot>   ([1,2],[])
09:18:03 <dmwit> > let [x:xs] = [[1,2],[3,4]] in (x, xs) -- error
09:18:04 <lambdabot>   (*Exception: <interactive>:3:4-25: Irrefutable pattern failed for pattern [...
09:18:14 <dmwit> > let (x:xs) = [[1,2],[3,4]] in (x,xs) -- not error
09:18:15 <lambdabot>   ([1,2],[[3,4]])
09:19:58 <dmwit> osfameron: In case you hadn't found it yet: http://www.haskell.org/haskellwiki/Existential_type
09:20:37 * applicative felt fear, thinking dmwit was linking R. Harpers blog
09:20:37 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
09:20:48 <osfameron> dmwit: thanks, I'm looking into it.  I don't understand the need for the wrapper, but I'm letting my fingers play with the code for a bit, to see if my brain follows them
09:21:27 <dmwit> osfameron: Well, think of it this way: what is the type of a value which can be any instance of ModuleNode?
09:21:40 <dmwit> osfameron: The type of such a value is (exists a. ModuleNode a => a).
09:22:00 <dmwit> osfameron: Now, as written that's not a Haskell type.
09:22:15 <osfameron> dmwit: ah, I don't understand the "exists a." notation
09:22:21 <dmwit> osfameron: But that's okay, we've got all kinds of GHC extensions to play with. =)
09:22:36 <dmwit> osfameron: Oh, well, there's not much to it if you've done some math. Have you?
09:22:57 <osfameron> not since I was 18 tbh
09:23:09 <dmwit> That's alright. There's another way to explain it.
09:23:15 <merijn> #haskell is a gateway drug to hardcore mathematics...
09:23:29 <dmwit> So, let's imagine we're in a language that *does* have existential types (unlike Haskell).
09:23:32 <tafryn> dmwit: How do you specify a heap limit?
09:23:32 <dmwit> What do they look like?
09:23:33 <osfameron> that page doesn't go into detail about the exists keyword
09:23:42 <dmwit> tafryn: I don't know, read the documentation for GHC.
09:23:51 <rtharper> merijn: Indeed it is, I was okay with a few abstract structures, kept it to small discussions about monads
09:23:52 <dmwit> tafryn: +RTS -M100M or some such nonsense.
09:23:58 <dmwit> tafryn: The answer may be in +RTS -h
09:24:00 <rtharper> then I moved into functors, natural transformations
09:24:05 <osfameron> dmwit: I'd imagine them conveniently allowing "ModuleNode" to serve as a type...
09:24:06 <tafryn> dmwit: Yeah, that's what I was trying.
09:24:17 <dmwit> osfameron: The "exists" keyword doesn't exist. I made it up. =)
09:24:23 <rtharper> Then, the Yoneda lemma found me
09:24:26 <rtharper> I've never been the same since.
09:24:27 <osfameron> ah
09:24:35 <dmwit> Anyway...
09:24:38 <dmwit> imagine a language that had it.
09:24:43 <dmwit> Here's what it allows:
09:24:50 * rtharper really wishes the effing exist keyword existed
09:24:57 <rtharper> it would make my lhs2TeX life easier
09:25:25 <dmwit> There's a new kind of term syntax, "pack", which looks like this: "pack e as T", where "e" is a term, and "T" is a type.
09:26:09 <dmwit> There's a new kind of type syntax, "exists", which looks like "forall" does in Haskell.
09:26:23 <dmwit> And the rule for typing the "pack" term goes like this:
09:26:25 <rsuniev> I've read http://www.galois.com/~dons/talks/xmonad.pdf. And there was a phrase: "Don’t be tempted by partial functions" Can someone explain what does mean?
09:26:42 <Twey> rsuniev: A partial function is one that isn't defined for all its inputs
09:26:44 <Twey> Like head
09:26:52 <Twey> > head [1, 2] -- okay, but
09:26:52 <lambdabot>   1
09:26:58 <Twey> > head [] -- argh!
09:26:59 <lambdabot>   *Exception: Prelude.head: empty list
09:26:59 <merijn> rsuniev: "Maybe a -> a" which is only defined for Just a
09:27:22 <merijn> @hoogle [a] -> Maybe a
09:27:23 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
09:27:23 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
09:27:23 <lambdabot> Prelude head :: [a] -> a
09:27:42 <dmwit> if "e :: T[T'/x]", that is, if "e" has a type with "T'" appearing as a subterm in a few places, then "pack e as exists x. T :: exists x. T"
09:27:49 <parcs> > fromJust Nothing
09:27:50 <lambdabot>   *Exception: Maybe.fromJust: Nothing
09:27:51 <merijn> > listToMaybe []
09:27:52 <lambdabot>   Nothing
09:28:02 <merijn> > listToMaybe [1]
09:28:03 <lambdabot>   Just 1
09:28:12 <rsuniev> Ah I see. Make sense. But what would be a good practise? Avoid?
09:28:25 <dmwit> So, any time we have a type, we can take some bits of the type and hide them.
09:28:37 <merijn> rsuniev: Make sure all your functions are total. For example use listToMaybe instead of head
09:28:40 <osfameron> dmwit: I don't understand why we're doing all of this
09:28:43 <Twey> rsuniev: To only use functions that are defined on all their inputs.  Or, more pragmatically, to think *really really hard* before you use a partial function like fromJust or head.
09:28:55 <merijn> @hoogle a -> Maybe a -> a
09:28:55 <dmwit> osfameron: To hide bits of the type, of course!
09:28:56 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:28:56 <lambdabot> Prelude asTypeOf :: a -> a -> a
09:28:56 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:29:16 <Twey> fromMaybe = flip maybe id
09:29:20 <merijn> rsuniev: Then use something like fromMaybe to extract the actual item from the Maybe
09:29:28 <dmwit> osfameron: I'm not sure how to explain this. You want something whose type could be any instance of ModuleNode, right?
09:29:35 <rsuniev> merijn, Twey: Cheers guys. I got it.
09:29:53 <osfameron> dmwit: yes.  I want a polymorphic tree of ModuleNodes
09:29:56 <dmwit> osfameron: That is, you want there to be some type "a" that's an instance of ModuleNode, and where the value you're looking at has type "a".
09:30:06 <Twey> Or something like list d _ [] = d; list _ f (x : xs) = f x xs
09:30:37 <dmwit> osfameron: Or, rewording it, you want there to *exist* a type that's an instance of ModuleNode, and where the value you're looking at has that type.
09:30:45 <Twey> listToMaybe = list Nothing $ const . Just
09:30:57 <dmwit> osfameron: You might not know exactly what that type is, but you definitely want it to exist.
09:31:44 <dmwit> osfameron: That is what existential types do: a value of type "exists x. T" is a value that can be typed as "T[T'/x]" for some type "T'".
09:32:01 <dmwit> (where "T[T'/x]" means "replace every occurrence of "x" in "T" with "T'")
09:32:21 <tafryn> dmwit: Poking through the RTS docs I found this: "-I<sec>  Perform full GC after <sec> idle time (default: 0.3, 0 == off)". Am I correct in thinking that since my example updates the display 100 times/sec the garbage collector never runs?
09:32:40 <osfameron> dmwit: I got as far as "I want there to be a type that will accept stuff that I created as ModuleNode..."
09:32:46 <dmwit> tafryn: I have no idea.
09:33:05 <nyingen> any idea why I'm getting this error on one machine but not on another? it must have something to do with installed libraries or maybe even the compiler version, but I'm not sure what to look for
09:33:09 <nyingen> http://hpaste.org/45846/odd_monaderror_instance_error
09:33:10 <osfameron> dmwit: I'll revise my type theory, I'm not understanding enough of what you're saying for it to be useful to either of us, I think :-)
09:33:11 <tafryn> Is there some way to invoke GC manually?
09:33:18 <osfameron> dmwit: thanks for time/pointers though
09:34:02 <dmwit> osfameron: But before you take too long with that, maybe I should caution you a bit.
09:34:40 <dmwit> osfameron: If you do get "data Quiz = Quiz String (exists a. ModuleNode a => a)" working, the *only* things you'll be able to do on the wrapped types are ModuleNode operations.
09:34:54 <dmwit> osfameron: So that type is *no more useful* than the type "Tree a".
09:35:21 <dmwit> osfameron: (That is, although the data you made may hold more information than a name and some children, you won't be able to access that extra information -- only the operations "name" and "nodes" will be available.)
09:35:43 <osfameron> ok.
09:35:55 <osfameron> like in Java where an object is cast to a restrictive Interface
09:36:13 <osfameron> (but without the dangerous possibility of working around it, presumably)
09:36:13 <dmwit> Right. And with no recourse to unsafe upcasts.
09:36:58 <dmwit> nyingen: Perhaps it is a parsec-2 vs. parsec-3 thing?
09:37:27 <osfameron> dmwit: so, should I be looking at... GADT? OOHaskell? HList?  or something else entirely?
09:37:33 <nyingen> dmwit: well, both parsec 2.1 and parsec 3 are installed on both machines
09:38:11 <paolino> hi, is there a class like class Bijection a b where from :: b -> a; to :: a -> b ?
09:38:16 <cdsmithus-mobile> Anyone want to try simplifying some code with fclabels and mtl?  http://hpaste.org/45847/can_this_be_simplified
09:39:08 <osfameron> oh, I suppose if ModuleNode has a rich enough interface, I could still use existential types
09:39:56 <nyingen> one machine is running ghc 6.10 and the (working) one 6.12, but I wouldn't think that would be the cause
09:40:19 <dmwit> nyingen: I'm not sure then.
09:40:34 <nyingen> should I add an instance declaration?
09:41:04 <osfameron> ooo, GADT looks promising.
09:41:15 <dmwit> osfameron: Well, it's pretty hard to say without knowing a bit more of the big picture. A richer interface could be fine; perhaps adding a Typeable constraint and using Haskell's Dynamic stuff; or just not using a class at all is often the best.
09:41:43 <osfameron> dmwit: yeah - I originally only used the class because I thought it would help me do what I want ;-)
09:41:56 <osfameron> simpler is definitely going to be better
09:42:28 * osfameron will play with GADTs first, then look at existentials again.  Messing with dynamic stuff looks way beyond my skillset at the moment ;-)
09:47:34 <jonkri> is this a nice way of creating a synchronous function in an asynchronous environment? http://hpaste.org/45844/synchronous_function_in_asyncr ... if so, how can i have the readMVar call time-out?
09:48:13 <dmwit> There's no way that has the type you claim it has.
09:48:49 <nyingen> dmwit: I am a fool. The problem had to do with parsec-3.0.0 vs parsec-3.0.1
09:48:58 <dmwit> But yes, that's the generally-accepted way of synchronizing things: by using an mvar.
09:49:00 <applicative> instance Monad Int
09:49:08 <dmwit> kind error
09:57:25 <dmwit> osfameron: I thought of another way to explain existential types that you might find more enlightening, if you're interested.
10:00:25 * hackagebot cereal 0.3.1.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.1.0 (TrevorElliott)
10:04:11 <koniiiik> Does anyone have an idea why ghci chokes on this file: http://capek.ii.fmph.uniba.sk/lamsfet/files/tasks/task568/task/piskvorky.hs ?
10:05:16 <koniiiik> I get "piskvorky.hs:103:6: parse error (possibly incorrect indentation)" even after I expanded all tabs to four spaces (I believe this is the setting our teacher was using when writing the file)...
10:05:26 * hackagebot data-pprint 0.1 - Prettyprint and compare Data values  http://hackage.haskell.org/package/data-pprint-0.1 (PeterDivianszky)
10:06:25 <Saizan> koniiiik: loads fine here
10:06:33 <koniiiik> Weird.
10:07:18 <Saizan> koniiiik: ah, it's exploiting a recent change in the parser
10:07:47 <Saizan> koniiiik: either use a newer ghc or indent the else's one space further
10:07:51 <dafis> koniiiik: tabs are supposed to be eight spaces
10:08:58 <koniiiik> dafis: Well, my opinion is that tabs aren't supposed to be at all to avoid this ambigiuty... (-:
10:09:00 <megajosh2> Hey, what does it mean when an I/O action fails with "inappropriate type"?
10:09:16 <megajosh2> I got that when writeFile was called in my program
10:09:28 <megajosh2> I can show relevant code if I need to
10:09:39 <dafis> koniiiik: agreed, tabs are evil
10:10:00 <Saizan> megajosh2: that'd be better, and show the whole error too
10:10:06 <koniiiik> Saizan: What exactly does newer ghc mean? Currently I'm on 6.12.3...
10:10:20 <monochrom> newer means 7.0.x
10:10:43 <monochrom> "do-if-then-else" is a recent haskell 2010 thing
10:10:46 <megajosh2> Okay, one minute
10:10:48 <megajosh2> Thanks
10:12:04 <koniiiik> The funny thing is, our teacher uses Hugs AFAIK...
10:12:11 <Saizan> maybe in ghc-6.12.3 it works as an extension, i.e. with {-# LANGUAGE DoIfThenElse #-} at the top of your file
10:13:07 <monochrom> here is why "I got this error message, what does it mean" is uninformative: sufficiently proficient programmers don't run into that error message
10:14:12 <koniiiik> Saizan: Unsupported extension: DoIfThenElse... Anyway, thanks for the info, I'll try indenting it further.
10:14:44 <dmwit> Tabs are not evil.
10:14:49 <dmwit> People who misunderstand tabs are evil.
10:15:07 <megajosh2> Saizan: http://hpaste.org/45848/weird_io_error Here you go
10:15:34 <monochrom> no, people who misunderstand tabs are not necessarily evil. most of them are victims of a few evil people
10:15:53 <dmwit> People who misunderstand tabs are ignorant.
10:16:14 <monochrom> a few evil people who are editor developers, who offer "you can customize what tab means" to mislead the rest
10:16:16 <koniiiik> dmwit: People who set tab width to anything other than eight spaces made tabs evil.
10:16:40 <monochrom> THIS INCLUDES THE VI DEVELOPERS
10:16:59 <dmwit> Yes, vim really screws up tabs and spaces badly.
10:17:06 <companion_cube> why use tabs for coding, when there are spaces, which are non ambiguous ?
10:17:12 <monochrom> not just vim. the original vi too
10:17:14 <dmwit> koniiiik: Nonsense.
10:17:22 <accel> what's the haskell short hand for replacing one tuple of a record?
10:17:32 <dmwit> koniiiik: The whole point of tabs is that people should be able to choose how big they are.
10:17:53 <dmwit> companion_cube: Because if you use spaces, you are forcing your view of a good indentation size on me.
10:18:12 <dmwit> companion_cube: You might like four spaces, while I prefer seven. Neither of us is "right", and tabs are the answer to that problem.
10:18:26 <tensorpudding> i convert my tabs to spaces
10:18:27 <mjrosenb> yeah, you should lay out your code so that it looks correct no mater what the tabwidth is
10:18:27 <accel> i like my tabs to hit the prime numbers
10:18:38 <mjrosenb> if you don't to that, you are being a douche.
10:18:39 <accel> i.e. one tab = 2 spaces; 2 tabs = 3 epaces, 3 tabs = 5 spaces, 4 tabs = 7 spaces, ...
10:18:43 <rostayob> I've got a weird problem, my computer keeps restarting when I shut it down.
10:18:48 <koniiiik> dmwit: Yes, but then the compiler or interpreter (or anything else that depends on proper indenting) has to guess what some code means.
10:18:51 <dmwit> People just need to realize that tabs and spaces are incomparable when it comes to finding the visual distance. Then we'd all be in good shape.
10:18:56 <rostayob> no wait, that was meant to be in #archlinux :P
10:19:07 <Saizan> megajosh2: "inappropriate type" sounds like an error coming from the filesystem, maybe the path you end up constructing points to somewhere you can't write to
10:19:07 <monochrom> hehe
10:19:12 <dmwit> koniiiik: In my proposal, tabs and spaces are incomparable. There's no guessing.
10:19:23 <megajosh2> Saizan: Ah okay
10:19:23 <dmwit> accel: Yes, exactly.
10:19:33 <dafis> megajosh2: I'd think ioeGetErrorString would be IO String?
10:19:59 <dafis> (rather, IOException -> IO String)
10:20:10 <Saizan> ?hoogle ioeGetErrorString
10:20:10 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
10:20:10 <megajosh2> :t ioeGetErrorString
10:20:11 <lambdabot> Not in scope: `ioeGetErrorString'
10:20:32 <Saizan> that would have been a compile time error :)
10:20:47 <accel> http://www.haskell.org/onlinereport/index98.html <-- where is the recrod system decribed? I want to learn about the update syntax
10:21:12 <dmwit> ?where report
10:21:12 <lambdabot> http://www.haskell.org/onlinereport/
10:21:28 <accel> dmwit: I linked to that ....
10:22:00 <dmwit> http://www.haskell.org/onlinereport/exps.html datatypes with field lables
10:22:14 <koniiiik> Saizan: Indenting the else lines one space further did the trick, thanks again.
10:22:20 <monochrom> accel: 3.15.1, 4.2
10:22:24 <dmwit> http://www.haskell.org/onlinereport/exps.html#sect3.15 jumps right to it
10:22:40 <monochrom> actually 3.15, 4.2
10:22:55 <megajosh2> ...I just realized I'm trying to make a directory with the same name as another file
10:22:59 <megajosh2> Doh
10:23:12 <megajosh2> Saizan: Thanks, that's exactly what the problem was
10:24:04 <accel> dmwit , monochrom : nice; thanks
10:24:38 --- mode: ChanServ set +o mauke
10:24:39 --- mode: mauke set +q #python!*@*
10:24:44 <mauke> wtf
10:24:55 --- mode: mauke set -q #python!*@*
10:25:07 <monochrom> yes, your automatic mechanism has problems
10:25:23 <mauke> no, it's actually working fine
10:25:29 <mauke> I just got the parameter order wrong
10:25:32 <monochrom> not sure if you already know the "@where ops" bug too
10:25:42 <mauke> monochrom: I already disabled that script
10:25:46 --- mode: mauke set -o mauke
10:26:01 <monochrom> alright then
10:26:01 <mauke> this one was a mistyped /mode #python +q :-)
10:27:42 <mauke> I can report success
10:27:52 <mauke> I've got a script that can tell me which bans affect a given user
10:28:42 <applicative> which bans affect us, then?
10:28:57 <mauke> what do you mean by "us"?
10:29:13 * applicative : "forbidden to discuss the lack of First Class Modules"
10:29:39 <applicative> what are the forms of ban?
10:29:46 <mauke> huh?
10:30:21 <applicative> the scripts tell you "which bans affect a given user" let X be a user, how can there be many bans for X
10:30:38 <dmwit> bans are like regexen or something like that
10:30:41 * applicative is syntactically challenged, this is why he studies haskell
10:30:42 <mauke> how not?
10:31:20 <Eduard_Munteanu> Either you're banned or not, in a given place.
10:31:27 <merijn> Not true
10:31:31 <applicative> I think I can't tell what a ban is.  Just wondering. 
10:31:34 <Eduard_Munteanu> At least that's what I think applicative meant.
10:32:00 <merijn> What if I ban a user@host and *@host or *@*.subdomain.tld
10:32:06 <monochrom> enter "/mode #haskell b" to see the ban list. then you will know
10:32:10 <Eduard_Munteanu> Oh.
10:32:37 <merijn> A single user can match an arbitrary number of such wildcard bans
10:32:53 <mauke> also: $a:foo
10:33:35 <applicative> I'm getting it now. 
10:34:54 --- mode: ChanServ set +o mauke
10:34:55 --- mode: mauke set -b *!*@@94-194-215-57.zone8.bethere.co.uk
10:35:41 <applicative> I think they could use a "Learn You a Standard ML of New Jersey" site. 
10:35:45 --- mode: mauke set -o mauke
10:36:12 <megajosh2> With a name that inviting, who couldn't resist?
10:36:44 <applicative> megajosh2:  that's what I was thinking, "Learn You a Standard ML of New Jersey for Great Good!"
10:37:10 <applicative> the pictures can be like their logo; clearly a superior brand. 
10:37:24 <monochrom> I have the temptation to ask in #math how many ban masks match a host mask of length n
10:37:46 <asflierl> Real world ML of New Jersey
10:38:07 <mauke> monochrom: infinite if you allow **
10:38:31 <applicative> asflierl: Thats the ticket.   
10:38:36 <monochrom> oh, right
10:38:38 <merijn> mauke: Which cardinality? :>
10:38:47 <applicative> Harper's manual doesn't have any pictures :(
10:38:50 <dafis> aleph 0
10:38:53 <mauke> countable
10:40:39 <Younder> hello
10:40:43 <applicative> hi Younder
10:41:44 <applicative> almost all the links on the sml.org site are dead.  I suppose haskell.org has plenty too
10:41:59 <applicative> no, nothing like this
10:42:20 <megajosh2> I went to sml.org and got one of those domain placeholders
10:42:43 <megajosh2> sml.org: what you need, when you need it
10:45:37 <applicative> well, I'll just have to settle for Prof. Harper's witty introduction to SMLNJ
10:46:21 <Younder> learnyourhaskell?
10:47:04 <Younder> learnyouahaskell
10:47:20 <applicative> Younder, excellent plan
10:48:46 <boegel> hiya gang
10:49:54 <dafis> hiya boegel
10:50:12 <elliott> When using the tagged package, is it convention to use the Tagged constructor directly, or wrap it up in a type-specific function?
10:50:19 <elliott> Apparently retag is meant to be used in the latter way.
10:50:25 <boegel> say I have a field I want to represent with some data type, that takes only a couple of dozen values
10:50:47 <boegel> would it be beneficial space-wise to define my own datatype, our should I just roll with ByteString?
10:51:17 <boegel> is something like "data X = A | B | C" efficiently stored, e.g. do values only take 2 bits (I presume not?)?
10:51:29 <dafis> boegel: no, one word
10:52:00 <boegel> dafis: one word for every value? so way more efficient than a bytestring, right?
10:52:40 <dmwit> The question doesn't make sense.
10:52:48 <dmwit> X is not a sequence the way ByteString is.
10:52:48 <void9> > pl \as bs -> all (id) $ zipWith (==) as bs
10:52:49 <lambdabot>   <no location info>: parse error on input `\'
10:52:50 <c_wraith> yeah, I'm lost
10:52:53 <dafis> boegel: each value of that type occupies one word, so spacewise, using a ByzeString would be more efficient
10:53:13 <dmwit> ?pl \as bs -> all id $ zipWith (==) as bs
10:53:13 <lambdabot> (and .) . zipWith (==)
10:53:29 <c_wraith> wow.
10:53:32 <c_wraith> @ pl all id
10:53:36 <c_wraith> @pl all id
10:53:36 <lambdabot> and
10:53:38 <dafis> boegel: but that wouldn't be nice to work with, and lack compiler guarantees, so think whether it's necessary
10:53:41 <c_wraith> that's amusing
10:54:08 <olsner> I think a bytestring needs at least 2 words, start-pointer and length, plus the actual bytes it points to
10:54:16 <boegel> dafis: any way to use something that take less than a bytestring? say it can take a dozen different values...
10:54:29 <c_wraith> boegel: do you think bytestrings are magical?
10:54:48 <boegel> dafis: depends how much alcohol I've had
10:55:01 <boegel> c_wraith: ^
10:55:03 <c_wraith> bytestring takes 4 words + the size of the byte array it points to.
10:55:06 <boegel> c_wraith: but now, no
10:55:23 <boegel> c_wraith: wait, then dafis is wrong?
10:55:33 <dafis> c_wraith: but if you're determined, you can store a lot of such values in one ByteString
10:55:51 <dafis> boegel: that's what I thought you wanted
10:55:54 <boegel> dafis: oh, wait, no I want one BS for each value :_
10:55:55 <dmwit> boegel: Mostly I think dafis is confused, because you're asking a very weird question in a super vague way.
10:56:07 <dafis> store a sequence of such in a ByteString, packed
10:56:07 <boegel> dmwit: ok, sorry about that
10:56:09 <c_wraith> yes, that's the real issue.  Ask your real question
10:56:25 <boegel> dafis: urgh, no, horrible to work with and totally incompatible to what I have now
10:56:37 <dafis> boegel: then of course, ByteString needs more memory
10:57:18 <boegel> c_wraith: my real question is, how do I efficiently define a data type for something that can take say a dozen different values (it goes up to 50 different values)
10:57:22 <void9> ?pl \as bs cs -> and $ zipWith3 (==) as bs cs
10:57:22 <lambdabot> ((and .) .) . zipWith3 (==)
10:57:24 <dafis> boegel: yes, absolutely horrible, but if you positively need the space, it's doable
10:57:41 <boegel> dafis: true enough
10:57:50 <dafis> boegel: an enumareted type, data X = A | B | C
10:57:56 <c_wraith> boegel: with GHC, you're not going to get more efficient than an enumeration, if the list is fixed.
10:58:28 <dons> > foldl1 (+) [1..]
10:58:33 <lambdabot>   mueval-core: Time limit exceeded
10:58:36 <dmwit> Even Word32 is an enumeration... albeit a somewhat longish one.
10:58:48 <dons> its hard to get ghc to give a true stack overflow these days. everything looks like heap exhaustion
10:59:25 <boegel> dons: hey, I have your book on my night stand! ;)
10:59:32 <dafis> dons: wasn't there something about a dynamically sized stack?
11:00:32 <dafis> dons: mapM (const (getStdRandom (randomR (0, 50000::Int)))) [0..10000000]
11:00:44 <dafis> try that
11:01:43 <elliott> dmwit: Integer is an enumeration too
11:01:49 <elliott> just a really, REALLY long one :)
11:01:51 <dmwit> No, not quite.
11:01:55 <elliott> :D
11:01:57 <dmwit> Integer has pointers.
11:02:07 <elliott> dmwit: that's an implementation detail
11:02:08 <dmwit> Anything with pointers stops being an enumeration.
11:02:22 <elliott> data Integer = Zero | One | MinusOne | Two | MinusTwo | ...
11:02:31 <olsner> elliott: maxBound :: Integer?
11:02:40 <Dodek> hey, i want to find the maximum element of a list, but i want to have a custom ordering
11:02:44 <elliott> olsner: no, it's infinitely long
11:02:46 <dmwit> :t maximumBy
11:02:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:02:52 <elliott> lazily-evaluated data enumartion
11:02:52 <elliott> duh
11:03:01 <Dodek> oh thanks
11:03:11 <c_wraith> I mean, anything with more than 4 constructors (on a 32-bit machine) or 8 constructors (on a 64-bit machine) is going to have an extra word to specify which constructor was used, anyway.
11:03:13 <dmwit> My definition of enumeration and your definition of enumeration obviously don't match.
11:03:36 <elliott> for fifty values, I can imagine an implementation where an Int would take less space
11:03:47 <elliott> say, where everything is either a tagged thirty-one bit integer, or a pointer
11:04:03 <elliott> the Int would take up one word, directly, whereas the constructor version would take up an extra word at least
11:04:05 <elliott> but that's hypothetical
11:04:28 <elliott> dmwit: well, people were using "enumeration" to mean "an ADT with constructors without arguments", which is a weird definition but...
11:04:29 <elliott> I was just joking
11:04:46 <dmwit> yeah =)
11:04:58 <dons> dafis: doesn't trigger a stack overflow for me.
11:05:10 <dafis> dons: more zeros?
11:05:42 <dmwit> dafis: That doesn't look like something that would use a lot of stack to me.
11:05:55 <dmwit> dafis: The Haskell stack is used for nested thunks, yeah?
11:06:17 <dmwit> I would imagine something like "foldr (+) 0 (replicate (2^25) 1)" would be much more likely to stack overflow.
11:07:10 <dmwit> ?src mapM
11:07:10 <lambdabot> mapM f as = sequence (map f as)
11:07:26 <dmwit> ?src sequence
11:07:26 <lambdabot> sequence []     = return []
11:07:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:07:26 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:07:27 <dafis> dons: or, probably, mapM (the above) >>= print . last
11:07:32 <dons> Prelude> foldr (+) 0 (replicate (2^25) 1) 
11:07:32 <dons> *** Exception: stack overflow
11:07:33 <dons> :)
11:07:37 <dons> but I had to set a limit
11:07:42 <dmwit> Yay!
11:07:44 <dons> I think by default there aren't stack limits now?
11:07:52 <dmwit> Oh, cool. I didn't know that.
11:08:06 <Younder> 'data Maybe a = Nothing | Just a ' seems like awkward way of defining generalized boolean. Well that is the prose for static typing I guess.
11:08:07 <dafis> dons: not in ghci at least, I'm not sure about compiled code
11:08:32 <dmwit> Younder: "generalized boolean"?
11:08:41 <dafis> Younder: it's not a generalised Bool
11:09:02 <c_wraith> Younder: not entirely.  say you "generalize" boolean to Int, by making 0 false.  How do you distinguish between the cases of "I got a result, it was zero" and "I didn't get a result"?  Maybe is fundamentally more information.
11:09:34 <Younder> dmwit, Like in Lisp. All types are a subtype of t except nil which is a subtype of null.
11:09:41 <dafis> Younder: it's more like a pointer, with Nothing corresponding to a 0-pointer
11:10:21 <dons> > handle (\StackOverflow -> return Nothing) $ return . Just $! foldr (+) 0 (replicate (2^25) 1) 
11:10:22 <lambdabot>   Not in scope: data constructor `StackOverflow'
11:10:24 <dons> Nothing 
11:10:27 <dons> :)
11:11:01 <dafis> > handle (\Control.Exception.StackOverflow -> return Nothing) $ return . Just $! foldr (+) 0 (replicate (2^25) 1
11:11:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:11:39 <elliott> Younder: If you look at everything through the eyes of Common Lisp's type system and types, what you will see is everything being an awkward way to express a CL concept.
11:11:39 <crystal-cola> python is full of horrible people
11:11:41 <crystal-cola> #python is full of horrible people
11:11:46 <elliott> So try taking things on their own.
11:11:51 <crystal-cola> compared to here
11:12:03 <megajosh2> It's a snake pit
11:12:03 * dmwit preens on behalf of #haskell
11:12:08 <megajosh2> *ba dum tssssss*
11:12:11 <dafis> crystal-cola: compare it to ##c then
11:12:32 <Eduard_Munteanu> Heh, I suppose it's because they're cold-blooded.
11:12:32 <elliott> ##c isn't a channel, it's a constant flamewar that somehow got a /join identifier
11:12:36 <dmwit> But, really, I'm sure there are wonderful people on #python. Maybe you just caught the channel at a bad time.
11:12:43 <mauke> preflex: seen PoppaVic
11:12:44 <preflex>  PoppaVic was last seen on ##c 2 minutes and 57 seconds ago, saying: pepper better
11:12:44 <crystal-cola> the ops 
11:12:47 <crystal-cola> are mean
11:12:51 <crystal-cola> and unfair
11:12:54 <Younder> elliott, Static typing DOES make Haskell feel like wigging out of a straight jacket some times. Oh well those beginners pains..
11:12:59 <dmwit> ##c has been nothing but helpful to me.
11:13:00 <elliott> mauke: wow, i'm going to use that before entering ##c in future now
11:13:15 <elliott> Younder: Good thing it's optional then -- see Data.Dynamic :)
11:13:21 <dmwit> I guess they made fun of me after they helped me. But so what?
11:13:29 <elliott> But _most_ of the time, Haskell's expressive static typing = the compiler helping you.
11:13:32 <crystal-cola> I wish I could use haskell instead of python
11:13:37 <mauke> Younder: the trick is to use haskell's strengths rather than its weaknesses
11:13:40 <crystal-cola> the poeple in #python nput me off of python
11:14:24 <Younder> mauke, Which requires the experience I don't have (yet)
11:14:24 <crystal-cola> annoyed
11:14:28 <dmwit> Hm. Maybe we should take further discussion of other channels to -blah.
11:14:38 <crystal-cola> this channel sucks
11:14:50 <elliott> dmwit: My experience with the channel is: If you're not so pedantic as to be writing a standards document -- e.g. say "So I passed this function to this other function" -- you get lynched. If you are clinically precise, you get ignored.
11:14:55 <elliott> (Typed that before you suggested -blah.)
11:15:28 <osfameron> dmwit: sorry, left to get train home.  I'd be interested in alternative explanation, if it uses sufficiently small and simple words ;-)
11:16:32 <crystal-cola> people are naturally horrible to each other
11:19:18 <dmwit> osfameron: Sure.
11:19:37 <dmwit> osfameron: I'll contrast two kinds of polymorphism.
11:19:48 <dmwit> osfameron: One is the kind you know and love from Haskell: forall-polymorphism.
11:19:58 <dmwit> osfameron: The other is the kind you're trying to learn about: exists-polymorphism.
11:20:14 <dmwit> The difference is in who gets to choose how a polymorphic value is specialized to a monomorphic value.
11:20:24 <dmwit> With forall-polymorphism, the person *using* the data gets to choose.
11:20:40 <dmwit> So, if I hand you something of type "forall a. a", you know you can specialize that to any type you like.
11:21:09 <osfameron> I don't usually use "forall a.", though I've seen it in :t
11:21:11 <dmwit> Similarly, if I hand you something of type "forall a. forall b. (a -> b) -> ([a] -> [b])", you know you get to instantiate "a" and "b" to whatever you like, and my function has to be able to handle values of those types.
11:21:35 <mun_> hi
11:21:37 <acowley> osfameron: it's implicit
11:21:41 <dmwit> osfameron: Yes, H98 syntax leaves the "forall" quantification implicit. But it's good to write it out when talking about this stuff.
11:21:43 <dmwit> Anyway.
11:22:13 <osfameron> and something like Eq a => ...  is a slightly more specialized forall?
11:22:17 <dmwit> The other type of polymorphism is exists-polymorphism; with exists-polymorphism, the person *building* the data gets to choose how the type variables are instantiated, and the *user* has to deal with any choice they made.
11:22:22 <mauke> no, a slightly more specialized type
11:22:23 <dmwit> osfameron: Yes:
11:22:23 <elliott> osfameron: that's forall a. Eq a => ...
11:22:27 <dmwit> forall a. Eq a => ...
11:22:36 <mun_> I have a logical question: if i have f(a) = 1 --> g(d) = 0 and f(b) = 2 --> g(d) = 1, then is it sufficient to claim that g(d) depends on f(a) and/or f(b)?
11:22:41 <elliott> read "Eq a" as "a is a member of Eq"
11:22:44 <elliott> and => as implies
11:22:46 <elliott> and it all makes sense :)
11:22:50 <dmwit> osfameron: You can also read it as
11:22:54 <crystal-cola> mun_: that makes no sense
11:23:01 <dmwit> forall a. (a -> a -> Bool) -> ...
11:23:11 <dmwit> osfameron: i.e. explicitly providing the class functions
11:23:14 <mun_> crystal-cola, hmm. why not?
11:23:21 <dmwit> osfameron: If you are unsure of how to interpret =>. =)
11:23:35 <dmwit> Returning to exists: consider a value of type "exists a. a".
11:23:56 <dmwit> When I make such a value, I get to pick any way of instantiating "a", and the person using the value has to write code that can handle any choice I make.
11:23:56 <crystal-cola> mun_: you have not quantified anythin
11:24:07 <osfameron> I thought => was just to separate the "here's how we restrict 'a'" from the rest of the type signature... didn't seem too complicated (unless I'm missing something)
11:24:15 <mun_> crystal-cola, all f, g, a, b, and d are constants.
11:24:25 <crystal-cola> no they aren't
11:24:38 <crystal-cola> you're saying that 1 = g(d) = 0
11:24:48 <dmwit> Similarly, a value of type "exists a. SomeClass a => a" means the person building the value chose a type that's in the "SomeClass" class, and no matter what choice they made, my code has to be able to do something useful with it.
11:25:11 <acowley> mun_: the problem is that f(a) = 1 /\ f(b) = 2 is possibly true
11:25:17 <acowley> if a <> b
11:25:18 <dmwit> In particular, all I can do with it is apply functions from "SomeClass", since any other operation I might want to do with it would try to make it more monomorphic.
11:25:24 <acowley> which makes g not a function
11:25:48 <osfameron> dmwit: I don't understand why that isn't a forall too, though. i.e. forall a where a is of data type SomeClass...
11:25:51 <dmwit> osfameron: Does that help a little? In short, the point of existential types is to make "the other choice" about who instantiates the type variables.
11:26:04 <mun_> crystal-cola, yes, g(d) is supposed to be incorrect. this to diagnose what makes g(d) incorrect, e.g., whether it depends on the value f(a)/f(b) returns
11:26:26 <crystal-cola> mun_: I feel like you haven't understood my objection
11:26:27 <dmwit> osfameron: A value of type "forall a. SomeClass a" has to be *built* using only class methods; a value of type "exists a. SomeClass a" has to be *inspected* using only typeclass methods.
11:26:33 <acowley> we should probably avoid the phrase "more monomorphic" :P
11:26:55 <crystal-cola> you should start your discussion by quantified (i.e. binding by a forall or exists) all variables 
11:27:06 <osfameron> dmwit: I don't understand the distinction between class method and typeclass method...
11:27:10 <crystal-cola> then you can start to make exact statements that dont' require people guessing stuff
11:27:19 <dmwit> osfameron: No distinction. Just me being imprecise; sorry.
11:27:31 <dmwit> osfameron: The distinction is between building and inspecting values.
11:27:55 <osfameron> dmwit: ah, in that case I probably don't understand that distinction either :-)
11:27:56 <mun_> acowley, right. if f(a) = 1 & f(b) = 2 is true and if g isn't a function, then what is g?
11:28:14 <mauke> mun_: a syntax error?
11:28:19 <crystal-cola> So what you said is formally meaningless
11:28:28 <dmwit> osfameron: Okay. Let's try a few examples.
11:28:33 <crystal-cola> mun_
11:28:37 <dmwit> osfameron: Can you think of any values of type "forall a. Bounded a => a"?
11:28:57 <acowley> mun_: it is a nondeterministic action
11:29:00 <jmcarthur> mun_: a relation?
11:29:03 <acowley> no
11:29:06 <acowley> well
11:29:13 <DrSyzygy> maxBound ? minBound ?
11:29:19 <acowley> sure, why not
11:29:25 <DrSyzygy> (or should I shut up and let osfameron answer? )
11:29:26 <dmwit> DrSyzygy: Hush, unless you also don't understand existential types.
11:29:37 <DrSyzygy> dmwit: I'm hazy on it.
11:29:43 <dmwit> Fair enough. =)
11:29:44 <acowley> g = {(1,0), (1,1)} etc
11:29:51 <djahandarie> crystal-cola, f : N -> N, g : N -> N, a : N, b : N, d : N. He isn't using any universial quantification.
11:29:58 <olsner> dmwit: you're only allowed to answer if you don't know the answer? :P
11:30:07 <acowley> except that the notation g(d) = x doesn't make sense
11:30:07 <dmwit> olsner: Right! =D
11:30:11 <crystal-cola> see above..
11:30:11 <acowley> unless you allow x to be a multiset
11:30:15 <elliott> dmwit: the answer is quarks
11:30:18 <acowley> or set
11:30:22 <elliott> I know this because I'm a quantum mysticist
11:30:23 <crystal-cola> I proved 1 = 0
11:30:28 <osfameron> dmwit: nope, I'm hazy on Bounded - that's to do with ranged data (e.g. not infinite numbers etc.) ?
11:30:32 <dmwit> DrSyzygy: Anyway, yes, those are the two answers of interest.
11:30:40 <dmwit> osfameron: yep
11:30:41 <acowley> if g is a binary relation, then you might say g(1) = {0,1}
11:30:42 <dmwit> ?src Bounded
11:30:42 <lambdabot> class  Bounded a  where
11:30:42 <lambdabot>     minBound, maxBound :: a
11:30:45 <djahandarie> crystal-cola, right, and that is because g isn't a function, as far as I can tell. :)
11:31:00 <djahandarie> Not because universial quantification was omitted
11:31:07 <crystal-cola> you're confused
11:31:07 <jmcarthur> i wasn't intending to say that that notation made much sense for a relation
11:31:19 <dmwit> osfameron: Anyway, "minBound :: forall a. Bounded a => a" and "maxBound :: forall a. Bounded a => a".
11:31:33 <dmwit> osfameron: Here's a trickier one. Can you think of any values of type "forall a. Eq a => a"?
11:31:41 <DrSyzygy> So forall a. X a => a can only exist if we can compose stuff in the typeclass definition to something of type a?
11:31:42 <acowley> quantification is all implicit, but not ambiguous here
11:31:48 <dmwit> ("undefined" and variants don't count)
11:31:50 <acowley> it's the notation in mun_'s example that is problematic
11:31:55 <mun_> djahandarie, crystal-cola acowley i agree that g is incorrect. this is the whole point -- this is to debug what is wrong with g. why it unexpected varies.
11:32:02 <dmwit> DrSyzygy: Correct.
11:32:05 <osfameron> dmwit: 1 ?
11:32:10 <acowley> namely, what you can do with g
11:32:14 <mauke> mun_: g is not incorrect, it's meaningless
11:32:16 <dmwit> :t 1 -- not quite
11:32:17 <lambdabot> forall t. (Num t) => t
11:32:24 <crystal-cola> mun_: you don't understand what I've said. You haven't written a meaningful expression. YOu can't even prove it wrong
11:32:41 <dmwit> osfameron: Nope, but "Num" would have been another good warm-up example.
11:32:55 <osfameron> isn't 1 something that can be Eq'd though?
11:33:00 <dmwit> osfameron: If you want another warmup before we get to "Eq", you could try coming up with something of type "forall a. Real a => a".
11:33:05 <DrSyzygy> It doesn't look as if the functions in Eq provide an a…
11:33:06 <dmwit> osfameron: Why, yes, it is!
11:33:10 <mauke> osfameron: sure, but so is 'A'
11:33:28 <jmcarthur> mun_: if you are debugging this then that implies you have some semi-working code. could you stick it on hpaste so we can see how you wrote a non-function as a function?
11:33:28 <dmwit> osfameron: But what I asked for was something which, no matter what particular Eq type I choose, the value you handed me had that type!
11:33:44 <acowley> g :: Monad m => m Int
11:33:51 <dmwit> osfameron: 1 doesn't fit that bill; there are plenty of Eq types which 1 *isn't*.
11:33:57 <osfameron> you did?
11:34:09 <dmwit> osfameron: Yep. That's the meaning of the type "forall a. Num a => a".
11:34:18 <dmwit> sorry
11:34:20 <DrSyzygy> dmwit: Well, forall a. Eq a => a.
11:34:28 <dmwit> That's the meaning of the type "forall a. Eq a => a".
11:34:31 <acowley> err, better, g :: Monad m => Int -> m Int
11:34:35 <jmcarthur> acowley: that doesn't look like a function in the first place unless m has -> somewhere in its definition
11:34:40 <dmwit> DrSyzygy: Yes.
11:34:56 <osfameron> dmwit: but I could put that in a type signature, and then pass 1 (or 'A', or whatever) into it
11:34:56 <acowley> jmcarthur: I forgot the function part and just wanted something that would yield different values 
11:35:00 <monochrom> mun_: if f(a)=1 and f(b)=2 happens together, you've got an inconsistent collection of axioms
11:35:06 <jmcarthur> acowley: and that still looks like a function, not a non-function
11:35:06 <DrSyzygy> It would seem that (fromInteger 0) is a forall a. Num a => a tho'. Right?
11:35:08 <dmwit> osfameron: Oh, yes, but that's not what I asked.
11:35:13 <dmwit> DrSyzygy: yes
11:35:15 <jmcarthur> acowley: unless you are counting execution semantics as "function-ish"
11:35:16 <osfameron> then I don't understand
11:35:23 <dmwit> osfameron: That's answering a different question. =)
11:35:26 <crystal-cola> mun_: you need to find a way to express your question meaningfully
11:35:42 <jmcarthur> crystal-cola: stop repeating yourself. i think mun_ gets that you don't like his phrasing
11:36:03 <jmcarthur> err
11:36:07 <dmwit> osfameron: If you have "f :: forall a. Eq a => a -> {- anything -}", then you could pass the value "1 :: Integer", for example. But I'm asking a different question.
11:36:10 <jmcarthur> i'm sorry, i shouldn't have made that a command, really
11:36:11 <mun_> jmcarthur, thanks for the offer. f and g aren't actually haskell functions, but rather two systems. the thing is, g is defined to be independent of f, but what is observed is that if f(a) = 1, then g(d) = 0 and if f(b) = 2, then g(d) = 1. i was just wondering whether it's logically valid to conclude that g actually depends on f.
11:36:23 <dmwit> osfameron: I'm asking, can you write "x = {- something here -}", so that "x :: forall a. Eq a => a"?
11:36:24 <mun_> monochrom, yes i agree.
11:36:25 <acowley> jmcarthur: I'm clearly not trying to argue that the original g is a function, just get at the kinds of things it can be, and the closest I can get to something that you might write down as "g(d)" but still eventually results in differing values is something like Int -> m Int
11:36:30 <crystal-cola> mun_: you haven't define system for example
11:36:49 <jmcarthur> acowley: sorry i don't mean to be overly pedantic but i appear to have done so
11:36:50 <mun_> crystal-cola, imagine two apparatus. abstract apparatus.
11:37:01 <crystal-cola> mun_: like machines?
11:37:06 <mun_> crystal-cola, sure.
11:37:10 <acowley> jmcarthur: no, I'm being very sloppy :)
11:37:14 <monochrom> I'm not sure what is "depend" but I would say yes g depends on f in the english sense
11:37:19 <osfameron> dmwit: I have no idea how you'd do that, no
11:37:27 <dmwit> osfameron: You're right. You can't!
11:37:31 <adhoc> hi
11:37:36 <dmwit> osfameron: Trick question. =)
11:37:42 <DrSyzygy> osfameron: The clue to that is in the type signatures in Eq.
11:37:52 <DrSyzygy> Anything in Eq is of type a -> a -> Bool
11:37:58 <dmwit> osfameron: But *why* can't you?
11:37:58 <acowley> So many Haskell questions are trick questions
11:38:13 <elliott> dmwit: because MMRF RRF FF MRFFFF
11:38:19 <elliott> what is this witchery
11:38:27 <osfameron> dmwit: because you can't have a value that is a superposition of every possible value that can Eq ?
11:38:33 <jmcarthur> mun_: what are b and d?
11:38:41 <dmwit> osfameron: That last question is one of those questions I used to hate, like the teacher was trying to get you to say one thing and you just had to guess what they wanted. =P
11:38:48 <dmwit> osfameron: So let me withdraw it, and just say:
11:38:52 <DrSyzygy> dmwit: Because the functions in Eq can only produce Bool?
11:39:03 <DrSyzygy> Or possibly a -> Bool
11:39:13 <dmwit> osfameron: You can't make a value of type "forall a. Eq a => a" because there are no functions in the "Eq" class which *construct* a value of the class's type.
11:39:15 <crystal-cola> mun_: can it be defined formally?
11:39:20 <mun_> jmcarthur, a, b, d are unique inputs to the machine. d should have been c :( but anyway.
11:39:22 <elliottt> elliott: it's immensely difficult to convince myself that i'm not the one having a conversation here.
11:39:24 <jmcarthur> mun_: are you saying that   (forall b. f(b) = 2) => (forall d. g(d) = 1)?
11:39:26 <dmwit> osfameron: All the functions *inspect* values of the class's type.
11:39:33 <acowley> let {f = const 1; g = f () - 1} in (f,g)
11:39:39 <elliott> elliottt: ssssshhhhh, they all think I'm a genius
11:39:47 <DrSyzygy> dmwit: So exist and forall are properly dual?!
11:39:49 <elliott> elliottt: I'm both you _and_ Conal
11:39:51 <DrSyzygy> Just reverse all arrows?
11:39:54 <elliottt> oh noes! :)
11:39:57 <jmcarthur> oh that was only half the property there
11:40:00 <dmwit> DrSyzygy: Oh, yes! In the right category, they definitely are.
11:40:08 <elliott> elliottt: i've even tricked dons! mwahahahaha!
11:40:11 <mun_> jmcarthur, no, b is just a constant.
11:40:20 <crystal-cola> jmcarthur: stop
11:40:23 <elliottt> i remember that :)
11:40:34 <mun_> so is d.
11:40:37 <crystal-cola> you're distracting mun from talking to me
11:40:44 <acowley> jmcarthur: yes, but again I'm just trying to exhibit different things that might be "depends"
11:40:45 <elliott> crystal-cola: lol
11:40:48 <dmwit> osfameron: Compare, say, the Num class, which has "class Num a where fromInteger :: Integer -> a", giving you functions which construct a value of the class's type.
11:40:49 <mun_> lol
11:40:55 <jmcarthur> crystal-cola: so kick me, dammit
11:41:05 <dmwit> osfameron: For those classes, you can have a value like "fromInteger 0 :: forall a. Num a => a".
11:41:28 <elliott> .
11:41:31 <elliott> oops
11:41:36 <jmcarthur> acowley: heh i wasn't talking to you. i was talking about what i said
11:41:54 <dmwit> osfameron: Bleh, I think we're getting off-target a bit here, though.
11:42:18 <acowley> jmcarthur: then we should endeavour to make our individual answers sum to a complete answer
11:42:25 <dmwit> osfameron: In any case, the basic distinction is that when I say "construct", I mean something like "return from a function", and when I say "inspect", I mean something like "pass to a function".
11:43:06 <osfameron> dmwit: one issue is that I don't have solid enough foundations, and still get confused between the symbols used in Constructors vs Pattern Matching vs Type Signatures
11:43:06 <monochrom> the whole notion of "talking to person" is broken
11:43:13 <mun_> acowley, jmcarthur, depends as in whether the output of g varies with the output of f.
11:43:20 <elliott> THE WHOLE NOTION OF PERSON IS BROKEN
11:43:31 <dmwit> osfameron: Hm, those seem pretty basic.
11:43:33 <malosh> Hi. Is there some standard module where the constants in HsFFI.h are accessible from haskell code in a portable way ? Or do I have to hsc2hs to get them ?
11:43:44 <monochrom> says the elliott who may or may not be elliottt :)
11:43:56 <elliott> monochrom: i both am... and aren't.
11:43:57 <DrSyzygy> dmwit: For what it's worth, I've been enlightened today. :-P
11:44:04 <dmwit> Yay!
11:44:12 <elliott> asking the question belies your lack of understanding of why the notion of "person" is wrong
11:44:37 <DrSyzygy> So tempted right now to /nick elliotttt
11:44:38 <jmcarthur> mun_: okay, so f, g, a, b, and c are all just fixed values? and are you sure no relationship exists between a and b, a and c, or b and c?
11:44:45 <dikini> dimwit: Fro what its worth, me too
11:45:00 <mun_> jmcarthur, yes, that's right. a, b, and c are independent.
11:45:12 <dmwit> Double yay!
11:45:16 <osfameron> dmwit: yeah, hence my suspicion that I needed to go back and revise this stuff :-(  it's about a year since I last fiddled with haskell, and though I remember some syntax/techniques, most of my intuition/grasp on the type system has evaporated
11:45:32 <mun_> jmcarthur, what i'm trying to conclude is whether g should be a binary function instead of unary.
11:45:36 <acowley> the rest of us are working to benight mun_, balance will be maintained
11:45:44 <monochrom> malosh: not in one single module, and not directly, but there are ways like "maxBound :: Int8" is INT8_MAX
11:45:44 <DrSyzygy> osfameron: The type name is what's on the left hand side of a data or newtype declaration, and the constructors are on the right hand side. Your functions type signatures involve the types, and the patterns for patternmatching involve the constructors.
11:46:01 <DrSyzygy> osfameron: So you can have things like data X a = Y a  | Z a
11:46:33 <elliott> monochrom: so is 127 :)
11:46:36 <DrSyzygy> In which case a function could look like f :: X a -> X a, and be implemented by type matching on f (Y a) = ... and f (Z a) = ...
11:46:37 <monochrom> in fact 90% of HsFFI.h is because c doesn't have "maxBound"
11:46:57 <Zaadje> where the hell am i
11:47:09 <mun_> jmcarthur, well, binary for sure, but whether the second argument depends on f.
11:47:18 <malosh> Actually what I need is more about endianness and how the bits are in CDouble
11:47:49 <monochrom> well yeah INT8_MAX is a bit redundant but there is also INT_MAX and maxBound :: Int
11:47:49 <dmwit> monochrom: Does any language that is not Haskell have maxBound?
11:48:02 <dmwit> Haskell is one of the only languages I know with return-type polymorphism.
11:48:03 <monochrom> I don't know
11:48:12 <mauke> dmwit: C++, sort of
11:48:37 <mauke> you could make something that looks like a polymorphic maxBound
11:48:43 <jmcarthur> so.... for your f and g,  exists a b c. f(a) = 1  ->  g(c) = 0   /\   f(b) = 2  ->  g(c) = 0.  also, in what sense do you mean you wonder if the second argument would depend on f? would it be f applied to the first argument or to some other argument?
11:48:43 <elliott> monochrom: (maxBound :: Int) worries me a bit.
11:48:44 <dmwit> Ah, static members.
11:48:46 <dmwit> Yes.
11:48:48 <malosh> mauke : few people use Double as objects in C++, I think
11:48:48 <Twey> Most OO ones do if you… yeah.
11:48:51 <monochrom> I don't think even HsFFI.h has endian information or floating point bit format information
11:48:51 <dmwit> I guess Java has that, too.
11:48:52 <elliott> dmwit: T get(int n) { ... } ;; on an ArrayList<T>
11:48:56 <elliott> My Java is thankfully rusty, but yeah.
11:48:56 <mauke> malosh: what
11:49:07 <elliott> dmwit: And therefore C-sharp and any other language with generics.
11:49:10 <elliott> (My hash key is broken.)
11:49:15 <elliott> Also C++ :P
11:49:20 <malosh> ok
11:49:32 <mauke> I doubt Java could do it
11:50:02 <dmwit> elliott: Oh, that's significantly more clever than what I was thinking.
11:50:13 <malosh> mauke : in C++ I think you could do some kind of generic maxBound but that would be pretty inefficient for most common types (i.e. the types HsFFI is for)
11:50:26 <jmcarthur> mun_: woops, correction:    exists a b c. f(a) = 1  ->  g(c) = 0   /\   f(b) = 2  ->  g(c) = 1
11:50:29 <mauke> malosh: ... how do you make an inefficient maxBound?
11:50:38 <elliott> dmwit: C++ doesn't _really_ have typeclasses though, so you can do fun things like template<typename U> U wtf() { return 99; }
11:50:48 <malosh> mauke : just use a new() each time you want a double
11:50:50 <elliott> But that fails at compile-time if you use it as a non-integral type, obviously.
11:50:59 <mauke> malosh: how does that help you with maxBound?
11:51:12 <osfameron> DrSyzygy: yeah, I kinda know that, except when I get confused about which one I use where
11:51:12 <malosh> you would then define some class Bounded
11:51:25 <malosh> mauke : well, whatever. I'm no C++ programmer
11:51:33 <mauke> o_O
11:51:35 <jmcarthur> mun_: i'd say that makes it look like g depends on a and b, not necessarily on f
11:51:45 <monochrom> oh darn, I guess ghc-specific HsFFI.h has endian information
11:51:56 <dmwit> Okay, cool, C++ can do maxBound. But yeah, seems like Java would have trouble.
11:52:01 <jmcarthur> mun_: and a and b are probably not independent of each other
11:52:05 <acowley> jmcarthur: how do you figure that?
11:52:21 <dmwit> elliott: Can C# really do it? I mean, C#'s polymorphism is non-parametric?
11:52:22 <jmcarthur> mun_: since if both sides of the /\ are true then g can't be a function
11:52:36 <jmcarthur> mun_: but if only one or the other is true then g could still be a function
11:52:49 <mun_> jmcarthur, i think that it'd be correct to make g(c, f(a)) = 0 and g(c, f(b)) = 1 because that's what the observations imply.
11:53:02 <mun_> jmcarthur, agree.
11:53:02 <dmwit> elliott: http://www.c-sharpcorner.com/UploadFile/sdhar8po/GenericsInCSharp11152005055344AM/GenericsInCSharp.aspx claims otherwise
11:53:15 <monochrom> well then, for endian information you have to read in HsFFI.h, but there is an easy way: cpp
11:53:15 <jmcarthur> "correct" is hard to say without context, but that at least could theoretically be a real function
11:53:16 <elliott> dmwit: Huh. Well that is strange. Especially for a language with lambdas.
11:53:22 <malosh> monochrom : I'm looking at it actually, it doesn't have any endianness information
11:53:23 <dikini> osfameron: I used to remind myself - constructors are values, types are, well types, obvious, but helps with placing the bastards
11:53:25 <elliott> //type of method pop will be decided when you creat the object 
11:53:26 <elliott> public T Pop() 
11:53:26 <elliott> {...} 
11:53:29 <elliott> dmwit: That suggests "yes it can" to me.
11:53:38 <dmwit> elliott: I don't think it's strange. Parametric polymorphism is the most sane kind of polymorphism.
11:53:52 <jmcarthur> acowley: do i still need to explain something beyond what i just said after you asked that?
11:53:54 <mun_> jmcarthur, but why do you think g might depend on a and b but not necessarily on f.
11:54:01 <dmwit> elliott: "parametric" means "has the same implementation regardless of what T is"
11:54:06 <mun_> jmcarthur, the observations only give you values of f(a) and f(b).
11:54:06 <dmwit> elliott: Did you know that?
11:54:14 <acowley> jmcarthur: I don't think it is independent of f
11:54:17 <monochrom> HsFFI.h -> ghcautoconf.h
11:54:23 <dmwit> elliott: (In particular, C++ can have different implementations of a class for different template instantiations.)
11:54:27 <acowley> and the conjunction you want for g to be a function is an additive conjunction
11:54:42 <DrSyzygy> dmwit: Is exists a. ... an active keyword in Haskell (with suitable language extensions switched on)?
11:54:47 <DrSyzygy> And what will it afford you?
11:54:47 <elliott> dmwit: I know what parametric is.
11:54:53 <dmwit> DrSyzygy: I don't think so.
11:54:56 <elliott> dmwit: But you asked, do any other languages have return-type polymorphism?
11:54:59 <elliott> dmwit: And the answer is yes :)
11:54:59 <DrSyzygy> Will it guarantee that there is some function in the right typeclass that takes the value?
11:55:05 <mauke> elliott: what does T Pop() demonstrate?
11:55:07 <DrSyzygy> Or is it just reasonably irrelevant?
11:55:09 <dmwit> elliott: Okay. I don't see anything about the code snippet you pasted that suggests non-parametric polymorphism.
11:55:26 <dmwit> elliott: Ah, okay, that's fair. But it needs both ad-hoc polymorphism *and* return-type polymorphism.
11:55:36 <elliott> Right. Well, you didn't say that :-P
11:55:47 <dmwit> yep
11:55:47 <mauke> I've yet to see return-type based overloading
11:55:47 <mauke> so ... what
11:55:50 <dmwit> I'm often wrong. =)
11:55:50 <Cale> DrSyzygy: exists isn't a keyword, but there's a way of constructing existential types more explicitly.
11:55:58 <DrSyzygy> Cale: How?
11:55:58 <elliott> mauke: Java. C-sharp. C++. Everything.
11:56:04 <mauke> elliott: none of them
11:56:16 <mauke> but as I said, you can sort of fake it in C++
11:56:19 <elliott> mauke: They have return-type polymorphism.
11:56:25 <elliott> Just not useful return-type polymorphism.
11:56:29 <dmwit> DrSyzygy: http://www.haskell.org/haskellwiki/Existential_type
11:56:30 <mun_> well thanks for the help guys. i'll look more into it.
11:56:37 <mun_> i agree that my concept of "dependency" is quite vague.
11:56:37 <mauke> ok, what do you mean by "return-type polymorphism"?
11:56:39 <mun_> thanks
11:56:44 <mauke> because I said "return-type based overloading"
11:56:48 <Cale> DrSyzygy: Well, there are somewhat confusingly two syntaxes for it. I prefer the newer GADT syntax... you can write things like   data Showable where S :: (Show a) => a -> Showable
11:56:52 <elliott> mauke: Well, what do you mean by _that_?
11:56:53 <crystal-cola> mun_: why don't you just describe it clearly?
11:57:00 <Cale> DrSyzygy: giving the types of the constructors explicitly
11:57:07 <dmwit> mauke: overloading seems unnecessary
11:57:09 <elliott> crystal-cola: Because they don't KNOW what they mean precisely?
11:57:18 <DrSyzygy> Cale: Oh right.... I need to digest GADT more, it seems like a really pleasant syntax.
11:57:29 <mauke> elliott: normal overloading chooses the function to call based on the argument types. return-type based overloading takes the expected return type into account as well
11:57:31 <dmwit> mauke: Bounded<T>.maxBound need not have multiple definitions per instantiation
11:57:40 <Cale> DrSyzygy: here, the types of values to which S is applied are "forgotten", and only the evidence for the Show class is retained
11:58:00 <mauke> dmwit: where is the T coming from?
11:58:23 <Cale> DrSyzygy: Another, older syntax is  data Showable = forall a. Show a => S a
11:58:33 <dmwit> mauke: Sorry, that was shorthand. I'm imagining something like this (forgive me for rusty C++ syntax):
11:59:11 <jmcarthur> acowley: i've decided that the reason we disagree is probably because we have latched onto different notions of dependence
11:59:32 <dmwit> mauke: <typename T> class Bounded<T> { static T maxBound; }; class Bounded<int> { static int maxBound = 2^32-1; }; class Bounded<double> { static double maxBound = whatever; };
11:59:33 <rien> can anyone help me understand how continuation-based IO is referentially transparent?
11:59:48 <acowley> jmcarthur: probably! also, I do not have a horse in this race, so it is no matter :)
12:00:03 <jmcarthur> the way i'm interpreting things, either g depends on f or it depends on a or it depends on b or it depends on some combination of them
12:00:12 <mauke> dmwit: but that doesn't give you a single 'maxBound'
12:00:19 <dmwit> mauke: Nope.
12:00:27 <Cale> rien: IO in general is not referentially transparent
12:00:53 <dmwit> mauke: In what sense does Haskell give you a single 'maxBound'?
12:00:54 <elliott> mauke: nor does Bounded
12:00:57 <elliott> what dmwit said
12:01:04 <appamatto> Does haskell have continuation-based IO?
12:01:06 <maurer_> Is there any way to be able to build a .o with haskell that can be dropped into a C build?
12:01:07 <mauke> dmwit: I can just put maxBound in my program and it works
12:01:11 <elliott> appamatto: Sort of :)
12:01:13 <elliott> didn't dmwit also say that the implementation must be the same?
12:01:18 <elliott> because isn't in Haskell
12:01:23 <maurer_> Most of the foreign export stuff I can find requires you to use ghc for the final link
12:01:35 <mauke> elliott: typeclasses aren't parametric polymorphism
12:01:53 <dmwit> mauke: If Haskell didn't have type inference, you'd have to put something like "maxBound :: Int". This is basically the same thing.
12:02:02 <mauke> yes, but it does
12:02:07 <acowley> maurer_: you need to identify all the .a files your final build will need
12:02:10 <dmwit> mauke: It's sad that C++ doesn't have type inference. But that's a different question, I think.
12:02:11 <mauke> so I get return-type based overloading
12:02:22 <mauke> while C++ only has argument-type based overloading
12:02:38 <maurer_> acowley: Is there a way to get ghc to dump that?
12:02:45 <dmwit> mauke: Right. But I'm saying return-type overloading *isn't necessary* to implement maxBound.
12:03:00 <mauke> depends on your definition of "maxBound"
12:03:00 <maurer_> acowley: I can assert that haskell only exists within this particular object file, but I don't get to change the final link.
12:03:02 <acowley> maurer_: the approach I've seen the most is to use GHC to link a version of your code that pulls in all the Haskell libraries, then pick through the verbose output to find the necessary libraries you need to give gcc
12:03:05 <mauke> dmwit: I want something source compatible
12:03:08 <dmwit> mauke: I suppose.
12:03:09 * dmwit shrugs
12:03:13 <maurer_> acowley: OK :/
12:03:17 <acowley> maurer_: honestly, I've never gotten it to work :(
12:03:31 <dmwit> Source compatible? Between Haskell and any other language?
12:03:34 <acowley> maurer_: that's just what I've read, but it seemed far too complicated
12:03:38 <mauke> dmwit: yes
12:03:46 <dmwit> mauke: I don't make such ridiculous demands.
12:04:02 <mauke> doesn't seem very ridiculous to me
12:04:05 <dmwit> mauke: There's few enough languages that meet even my lax request. =)
12:04:17 <jmcarthur> why do you need this?
12:04:17 <mauke> how?
12:04:20 <dmwit> Haskell, maybe Agda/Coq?, and C++
12:04:21 <dmwit> Nobody suggested any other.
12:04:26 <mauke> dmwit: C
12:04:34 <elliott> Does Data.Typeable not support records or something?
12:04:46 <elliott> splitTyConApp (typeOf (Foo { a=b, ...})) is returning an empty argument list.
12:04:52 <mauke> dmwit: maxBound(Reify_int)
12:05:12 <dmwit> mauke: How to implement maxBound and reify_T?
12:05:17 <dmwit> (in C)
12:05:19 <mauke> however you want
12:05:28 <maurer_> acowley: The thing I'm most worried about is whether ghc does some munging to initiate the machine at application launch in the final link
12:05:42 <elliott> But it works for Maybe... Hmm.
12:05:51 <elliott> Oh
12:05:53 <mauke> oh wait
12:05:55 <elliott> That is just because it is (Maybe Integer).
12:06:07 <mauke> the other half of my brain is kicking in
12:06:53 <mauke> int m; maxBound(Reify_int, &m, sizeof m);
12:07:03 <acowley> maurer_: that's the role of HsInit that you see referenced in places that tell you how to do this kind of thing
12:07:06 <mauke> don't even need sizeof m, actually
12:07:33 <acowley> maurer_: if you put the time in to automate this process, please do alert the internet
12:07:33 <Gwern-away> preflex: seen zooko
12:07:34 <preflex>  zooko was last seen on #darcs 20 hours, 59 minutes and 54 seconds ago, saying: Heffalump: thanks. I suggested to arc` that he grab that and then if he has more trouble with darcs-2.3.0 as packaged by Ubuntu he could try your binary instead.
12:07:36 <mauke> void maxBound(TypeRec t, void *p) { t.maxBound(p); }
12:07:48 <appamatto> continuations in general seem unintuitive
12:07:54 <dmwit> mauke: I'm still not with you. Can you show what you think a reasonable implementation of maxBound/reify would be for a few types?
12:08:05 <mauke> typedef struct { void (*maxBound)(void *); } TypeRec;
12:08:09 <adhoc> when I try using a tcp connection on windows, I get the *** Exception: bind: failed (Permission denied (WSAEACCESS)) exception
12:08:43 <mauke> TypeRec Reify_int = { maxBound_int };  void maxBound_int(void *p) { *(int *)p = INT_MAX; }
12:08:49 <dmwit> Ah, yes. Cool! I like it.
12:08:58 * Twey looks a little ill.
12:09:20 <adhoc> this happens when I use recvFrom host (PortNumber port), where port and host are from the accept function
12:09:51 <Twey> adhoc: I'd suggest just using Network.Fancy.  It's nicer.
12:10:15 <adhoc> I will try that, thank you
12:10:27 <Twey> adhoc: Did you remember to use withSocketsDo?
12:10:42 <adhoc> this happens regardless of whether I use it or not
12:10:50 <Twey> And what port are you trying to bind?
12:11:06 <adhoc> different ones, tried 1231 as well as 55666
12:11:06 <Twey> (and interface, I guess)
12:11:10 <Twey> Hm, okay
12:12:02 <Twey> « An attempt was made to access a socket in a way forbidden by its access permissions. An example is using a broadcast address for sendto without broadcast permission being set using setsockopt(SO_BROADCAST). » — quoth MSDN
12:12:41 <adhoc> I've seen the MSDN documentation
12:13:08 <Twey> 'kay
12:13:09 <adhoc> the connection is a localhost connection, but I have tried using localhost as well as my host name
12:13:14 <Phantom_Hoover> I WILL BREAK YOU ALL LIKE TOOTHPICKS
12:13:35 <dmwit> Do toothpicks break a lot of things?
12:13:57 <mauke> adhoc: why are you using recvFrom?
12:13:58 <TeXitoi> baloon ?
12:13:59 <c_wraith> mostly hearts
12:14:30 * Cale imagines a minecraft grid with three teeth in the top row and a couple sticks.
12:14:33 <adhoc> mauke, it's in the Network documentation under "Simple sending and receiving"
12:14:45 <Phantom_Hoover> dmwit, no, you shall be as unto toothpicks.
12:14:53 <mauke> adhoc: yeah, but you said you've already called accept
12:14:56 <Phantom_Hoover> Honestly, it's things like this that makes me want to break you.
12:15:14 <monochrom> recvFrom is not for use with accept
12:15:37 <monochrom> tcp vs udp in short
12:15:49 <adhoc> thank you, that explains everything
12:15:49 <mauke> adhoc: also "Their use is strongly discouraged except for small test-applications or invocations from the command line. "
12:16:01 <adhoc> mauke, it is a small test app
12:16:04 <adamvh> Just thought I'd throw it out there - is there any preferred method for getting graphviz output from (or otherwise visualizing) a Data.Tree?
12:16:05 <mauke> monochrom: I think it's a tcp socket
12:16:55 <acowley> the test failed?
12:16:58 <DrSyzygy> adamvh: If it doesn't already have it, it should be easy enough to roll your own? You should even be able to use a Foldable or Traversable instance to do it with a bit of trickery.
12:17:14 <dmwit> adamvh: Well, there's drawTree.
12:17:41 <adamvh> dmwit:  drawTree has grown taller than my terminal, unfortunately :p
12:17:55 <dmwit> =)
12:17:55 <adamvh> that's why I'm looking at graphviz now
12:19:59 <monochrom> oh yikes, recvFrom uses a tcp socket afterall, it just doesn't expose the socket
12:20:41 <dmwit> adamvh: I just had a funny thought.
12:20:43 <dmwit> ?hackage vacuum
12:20:43 <lambdabot> http://hackage.haskell.org/package/vacuum
12:20:46 <monochrom> it also does listenOn
12:20:55 <Twey> Anyway, I think Network.Fancy makes recvFrom unnecessary
12:21:31 <dmwit> ?hackage vacuum-cairo
12:21:31 <lambdabot> http://hackage.haskell.org/package/vacuum-cairo
12:21:45 <Twey> I wish they'd named the strict/lazy ByteStrings differently
12:21:47 <dmwit> adamvh: Those will almost certainly give you way more than you wanted, but they would be brain-dead to try. =)
12:22:00 <monochrom> eager/lazy, I say
12:22:15 <adamvh> dmwit: It doesn't seem to work with Data.Tree's, though
12:22:17 <Twey> It's confusing to see: Class Foo: Instances: Foo ByteString, Foo ByteString
12:22:27 <Twey> Oh, that's a question
12:22:32 <dmwit> adamvh: Did you try not compiling it?
12:22:43 <dmwit> adamvh: Compilation strips out a lot of information.
12:22:49 <Twey> Is there a nicer way to convert between strict and lazy ByteStrings without importing pack from one module and unpack from the other and composing them?
12:22:59 <adamvh> dmwit: I'm just looking at the hackage docs
12:23:04 <acowley> Twey: chunks
12:23:06 <dmwit> adamvh: Or, maybe it's easier to ask: "what do you mean by 'doesn't work'?".
12:23:12 <monochrom> there is a chunk function
12:23:25 <adamvh> dmwit:  I just mean there are no functions that take Data.Tree's as arguments
12:23:26 <Twey> @index chunks
12:23:26 <lambdabot> bzzt
12:23:33 <adamvh> dmwit: I should probably look at all the classes
12:23:36 <dmwit> adamvh: Nonsense, all of them take Data.Tree's as arguments.
12:23:46 <dmwit> adamvh: vacuum :: a -> IntMap HNode, for example.
12:23:52 <acowley> @index fromChunks
12:23:53 <lambdabot> bzzt
12:23:55 <acowley> :(
12:23:57 <fryguybob> @hoogle fromChunks
12:23:57 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
12:23:57 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
12:24:00 <Twey> Where?
12:24:01 <dmwit> adamvh: or view :: a -> IO ()
12:24:02 <acowley> thank you!
12:24:08 <fryguybob> @hoogle toChunks
12:24:08 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
12:24:08 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
12:24:09 <Twey> Oh, there… not quite what I'm looking for, though
12:24:23 <Twey> Oh, I guess fromChunks [someStrictBS]
12:24:29 <acowley> It convertes between lazy and strict ByteStrings
12:24:41 <acowley> Twey: yes
12:24:49 <Twey> toChunks requires me to concatenate them, though?
12:24:58 <acowley> ?
12:24:58 <adamvh> dmwit:  OK, now I'm confused - all the functions accept an arbitrary type a?
12:25:05 <acowley> No
12:25:09 <monochrom> @hoogle fromChunks
12:25:09 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
12:25:09 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
12:25:17 <dmwit> adamvh: Scary, huh? =D
12:25:19 <acowley> toChunks :: BSL -> [BSS]
12:25:27 <Twey> acowley: It gives me a list of strict ByteStrings (presumably — that's a strict ByteString in the type, right?)
12:25:33 <adamvh> dmwit:  What's it do?
12:25:33 <Twey> Right
12:25:37 <dmwit> adamvh: Black magic.
12:25:45 <dmwit> adamvh: It touches the data in places that weren't meant to be touched.
12:25:51 <Twey> So to convert from one lazy ByteString to one strict ByteString, I need to call toChunks on the lazy one and then concatenate them
12:25:53 <acowley> Twey: oh, I see, yes you would need to concatenate the list of strict ByteStrings
12:26:00 <acowley> Twey: you're right
12:26:20 <dmwit> adamvh: You'll notice the dependency on "ghc-prim". Guess what that means. ;-)
12:26:20 <Twey> Which ends up not being a whole lot nicer than BS.pack . BSL.unpack >.>
12:26:25 <Twey> Hm, though I suppose it's more efficient
12:26:37 <adamvh> dmwit:  pointer arithmetic (?)
12:26:51 <monochrom> it seems to me toChucks is not lazy bytestring to strict bytestring, rather lazy bytestring to lazy list of strict bytestring, which is no stricter than lazy bytestring
12:27:12 <monochrom> oh, but you concat then. ok
12:27:23 <dmwit> adamvh: Don't know, don't care. It's bound to be so GHC-implementation-specific that it's hardly worth looking at all the things it does.
12:28:02 <elliott> <dmwit> adamvh: or view :: a -> IO ()
12:28:04 <elliott> now that's just wrong.
12:28:05 <acowley> Twey: I think it should be quite a bit more efficient, in particular if the concatenation is made clever by a builder or some such mechanism
12:28:11 <dmwit> elliott: =D
12:28:19 <elliott> I feel dirty inside
12:28:27 <elliott> can someone delete vacuum from Hackage?
12:28:47 <adamvh> elliott: since it seems that it may solve my problem, I hope not...
12:28:48 <acowley> or change the name to XXX and put an age restriction on it
12:28:59 <elliott> :D
12:29:11 <elliott> "This library has been rated RESTRICTED by the Haskell Committee."
12:29:26 <acowley> "Do you think the type a -> IO () is a good idea?" (If the user cliks yes, they aren't allowed to download it)
12:29:28 <adamvh> There also isn't a whole lot of synopsis info at the Hackage docs either
12:29:41 <dmwit> no =(
12:29:51 <elliott> Data.Typeable: "The Haskell Committee has deemed that this library could frighten or dismember small children. As such, it is restricted to this of fourteen years or older."
12:29:53 <adamvh> You're just sort of left to wonder what kind of library could possibly
12:29:54 <elliott> those
12:30:08 <adamvh> have type signatures of a-> IO()
12:30:09 <dmwit> adamvh: If you take a look at the screenshots of vacuum-cairo, it should be pretty clear what you can expect, though.
12:30:26 <elliott> adamvh: If you click "Source", you get a PNG of the source printed in white on white.
12:30:27 <acowley> elliott: although these should be Haskeller years or some such
12:30:38 <elliott> Yes, you have to use Haskell for fourteen years
12:31:15 <acowley> adamvh: it's actually a pretty innocent type, but you must lack innocence to expect its side effect from having anything to do with its argument
12:31:40 <acowley> view :: a -> IO () -- the loss of innocence
12:31:48 <dmwit> Oh, no! I could imagine vacuum-cairo being a super helpful pedagogical tool for Haskell newbies!
12:31:56 <ion> magic :: IO () -> a
12:32:00 <dmwit> I wouldn't want to prevent people from trying it for thirteen whole years.
12:32:00 <acowley> !
12:32:01 <elliott> dmwit: It should be offered as a GHCi command and nothing else.
12:32:07 <adamvh> Having come originally from C by way of Common Lisp
12:32:10 <dmwit> elliott: Yes, something like that exactly.
12:32:14 <elliott> dmwit: When asked how it's implemented, we shall respond "in the RTS".
12:32:25 <elliott> When they ask where, we remind them that access to the RTS sources is restricted.
12:32:34 <acowley> dmwit: the functionality is great, but it subverts many of the very things you spent the past hour talking about regarding polymorphism!
12:32:40 <elliott> :D
12:32:42 <dmwit> oh
12:32:43 <dmwit> well
12:32:49 <elliott> "This is how polymorphism works. Sorry, that's a lie, it works however you want it to."
12:32:53 <dmwit> That's true. =(
12:33:14 <monochrom> what a->IO() function is this?
12:33:26 <dmwit> GHC.Vacuum.Cairo.view
12:33:31 <dmwit> ...or whatever module it's in
12:33:40 <acowley> Day1 : view and Debug.Trace, Day2: polymorphism
12:34:00 <adamvh> Hmm, I appear to be pulling in Gtk2Hs
12:34:08 <monochrom> yes
12:34:14 <dmwit> adamvh: yep, graphics lol
12:34:28 <monochrom> you should actually install gtk2hs-buildtools first
12:34:43 <adamvh> I rather doubt this will be happening on my mac...
12:34:45 <maxims_atif> hi guys can some one explain length' xs= sum [1 | _ <-xs]?
12:34:53 <elliott> adamvh: gtk runs on os x
12:34:56 <maxims_atif> i dont understand what _ does?
12:34:57 <elliott> native Quartz, even :-P
12:34:59 <adamvh> yep
12:35:03 <elliott> maxims_atif: disregards the value
12:35:10 <adamvh> drat
12:35:13 <monochrom> it says length' [a,b,c,d] = sum [1,1,1,1] 
12:35:15 <adamvh> well, vacuum anyways
12:35:30 <monochrom> _ is pattern matching wildcard
12:35:44 <adamvh> I appear to have a dependence on glib-0.12.0
12:35:51 <adamvh> which failed to install
12:35:55 <monochrom> [1 | hi'i'am'unused <- xs] is the same thing
12:36:12 <maxims_atif> hi guys can some one explain length' xs= sum [1 | _ <-xs]?
12:36:22 <monochrom> hi person I just did
12:37:04 <monochrom> should I bother answering next time, if you are too busy asking to read my answer?
12:37:05 <Twey> maxims_atif: For each value in xs, extract the value, ignore it, and return a 1
12:37:13 <Twey> Then sum the result.
12:37:22 <Twey> Oh, monochrom answered you already.
12:37:45 <monochrom> ok, not answering next time. not to any webchat users
12:37:52 <Twey> Heh
12:38:30 <acowley> adamvh: did you look at fgl?
12:38:50 <monochrom> or at least, the middle ground of: first I ask back "if I answer, will you read? coz experience shows that there is 99% probability you won't"
12:38:50 <adamvh> acowley: My trouble is that I see no way to get from Data.Tree to fgl
12:39:10 <Twey> length = list 0 . const $ succ . length
12:39:40 <adamvh> acowley: and Data.Tree is convenient because it allows me to recursively build trees from one another
12:40:31 <acowley> I would have thought a function from Data.Tree to Graph would be straight forward, but I don't think I've written such a thing
12:40:57 <maurer_> Any idea on how to convince ghc to dump the prefix in /usr/local/lib/ghc-7.1.20110403/include/HsFFI.h
12:41:15 <maurer_> I want to be able to automatically add it to the -I in a makefile
12:42:39 <monochrom> instead, you may like to use ghc as your c compiler (no typo, no kidding)
12:42:53 <monochrom> c_code.o : c_code.c
12:43:07 <monochrom>         ghc -c -O2 c_code.c
12:43:15 <monochrom> that will do the right -I
12:43:28 <mauke> CC = ghc
12:43:47 <monochrom> unless you consider ghc too much overhead
12:44:15 <maurer_> monochrom: I need to integrate into someone else's build system.
12:44:40 <TeXitoi> or you can take the prefix using makefile functionalities
12:44:40 <maurer_> And I want the "foo_stub.h" file to be includeable
12:44:58 <maurer_> TeXitoi: Hm? Explain?
12:45:21 * hackagebot authenticate 0.9.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.0 (MichaelSnoyman)
12:45:23 * hackagebot persistent 0.5.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.5.0 (MichaelSnoyman)
12:45:52 <adamvh> acowley: You know what, it actually doesn't look too bad
12:46:09 <TeXitoi> maurer_: If I undersand correctly, ghc dump you /usr/local/lib/ghc-7.1.20110403/include/HsFFI.h and you want to put a -I  /usr/local/lib/ghc-7.1.20110403/include/ to gcc in a makefile?
12:46:21 <adamvh> acowley: I'm just gonna do it, and file a ticket and see if I can't this functionality into one package or the other
12:46:21 * hackagebot persistent-mongoDB 0.2.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.2.2 (MichaelSnoyman)
12:46:23 * hackagebot persistent-postgresql 0.5.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.5.0 (MichaelSnoyman)
12:46:36 <acowley> adamvh: using fgl? I'm glad to hear it! I had some success using it in the past and found it pretty reasonable once I got over the initial learning curve.
12:47:08 <adamvh> acowley: How would you integerate a Tree -> Graph into the packages, though?
12:47:21 * hackagebot persistent-sqlite 0.5.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.5.0 (MichaelSnoyman)
12:47:22 <adamvh> acowley: it'd be irritating to make the packages depend on each other
12:47:39 <maurer_> TeXitoi: No, I'm trying to figure out how to get ghc to dump me /usr/local/lib/ghc-7.1.20110403/include/HsFFI.h
12:47:51 <adamvh> acowley: but there really *should* be a toGraph :: Tree -> Graph
12:47:57 <TeXitoi> ha, missunderstanding
12:48:02 <acowley> adamvh: I guess it would go into fgl since it already depends on containers
12:48:11 <bos> @pl \(a,b) -> (b,a)
12:48:11 <lambdabot> uncurry (flip (,))
12:48:15 <bos> pfffff
12:48:23 <maurer_> Also, does ghc have an equivalent of -m32?
12:48:24 * hackagebot persistent-template 0.5.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.5.0 (MichaelSnoyman)
12:48:26 * hackagebot yackage 0.2.0 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.2.0 (MichaelSnoyman)
12:48:27 * hackagebot yesod 0.8.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.8.0 (MichaelSnoyman)
12:48:29 * hackagebot yesod-auth 0.4.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.4.0 (MichaelSnoyman)
12:48:32 * hackagebot yesod-core 0.8.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.0 (MichaelSnoyman)
12:48:48 <sm> yay
12:48:50 <parcs> awesome :)
12:48:57 <adamvh> Does hackagebot just tell us anytime there's a new package on hackage?
12:49:06 <yulys> hi!... could you tell if the compiler was made in haskell?... or was developed in c?
12:49:12 <sm> adamvh: yes
12:49:34 * hackagebot yesod-form 0.1.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.1.0 (MichaelSnoyman)
12:49:36 * hackagebot yesod-json 0.1.0 - Generate content for Yesod using the json-types package.  http://hackage.haskell.org/package/yesod-json-0.1.0 (MichaelSnoyman)
12:49:38 * hackagebot yesod-newsfeed 0.1.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.1.0 (MichaelSnoyman)
12:49:40 * hackagebot yesod-persistent 0.1.0 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.1.0 (MichaelSnoyman)
12:49:42 * hackagebot yesod-sitemap 0.1.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.1.0 (MichaelSnoyman)
12:49:46 <burp> yesod spam lol
12:50:08 <nyingen> kicked for flooding?
12:50:10 <parcs> yulys: written in haskell, no. compiled by ghc, maybe. try calling the executable with +RTS -h
12:50:21 <sm> :/ .. let's see
12:50:36 <sm> it's supposed to avoid that
12:50:49 <yulys> parcs: so GHCI was made in c?
12:51:03 <yulys> so the Hug compiler?
12:51:18 <Saizan> yulys: ghc is almost all written in haskell
12:51:24 <parcs> yulys: actually, try +RTS --help
12:51:37 <parcs> a ghc-compiled app should complain about an unknown rts fla
12:51:39 <parcs> g
12:51:47 <Saizan> yulys: hugs is in C 
12:51:56 <yulys> Saizan: a friend told me the binary packages in haskell was writtenin C--
12:52:27 <Saizan> yulys: what do you mean by binary packages?
12:52:50 <sm> nyingen: no, it died due seeing a unicode character without having LANG set.. on my very short todo list
12:53:30 <jonkri> is this a nice way of creating a synchronous function in an asynchronous environment? http://hpaste.org/45844/synchronous_function_in_asyncr ... if so, how can i have the readMVar call time-out?
12:53:32 <Saizan> yulys: anyhow, there's some C-- in ghc's sources too, and C-- is also used as an intermediate represantation of your programd uring compilation
12:54:12 <yulys> Saizan: I dont know exactly waht he means, but I just wanna know if it is correct if I say the compiler ghc was written in haskell
12:54:45 <parcs> yulys: yes
12:54:47 <parcs> ghci too
12:55:50 <Saizan> yulys: yep, most of it
12:55:53 <mamalujo> i thought Cmm, used in ghc isn't quite the same thing as C-- (latter having some runtime support or something)
12:56:31 <yulys> Saizan: thnks so much, Iam newbie, but I planned to write in haskell about fractals
12:56:41 <nyingen> sm: I see
12:57:34 <nyingen> On another note, I'm trying to use Text.Parse as a replacement for Read, but I'm not understanding how it's supposed to be used
12:58:02 <maurer_> Is there no way to put ghc into a 32-bit code generation mode?
12:58:26 <Saizan> mamalujo: well, true, ghc has its own custom c--
12:58:27 <monochrom> not unless you use a 32-bit version of ghc
12:58:59 <Saizan> yulys: why is it important how the compiler is implemented?
12:59:09 <ion> Text.Parse?
12:59:25 <maurer_> monochrom: Is there a way to get a 32-bit and 64-bit ghc to live side by side without hating each other?
12:59:36 <parcs> chroot! :)
12:59:44 <monochrom> yes. install under different directories. play with PATH
13:00:01 <yulys> Saizan:because I was trying to know how haskell compiles... the use of memory also
13:00:07 <monochrom> ./configure --prefix=/ghc32  ...  ./configure --prefix=/ghc64
13:00:10 <maurer_> parcs: Overkill+not enough space
13:00:28 <maurer_> monochrom: OK. It would be nice if we could -m32 like gcc
13:00:39 <parcs> maurer_: it's not overkill at all. in fact, it's the bare minimum
13:00:51 <parcs> at the moment, anyway
13:00:51 <monochrom> #!/bin/sh
13:01:02 <monochrom> case $1 of
13:01:13 <mamalujo> lol
13:01:14 <ion> "$1". Be safe.
13:01:20 <maurer_> monochrom: Will my .ghc not cause interference?
13:01:21 <monochrom>   -m32) /ghc32/bin/ghc "$@"
13:01:36 <monochrom> no. do an "ls" to see why
13:01:49 <maurer_> Ah, OK, it's arch cased
13:02:01 <nyingen> should I use Text.Read instead? or what
13:02:20 <monochrom> people would spend whole lifetimes browsing the web outside
13:02:28 <monochrom> and not one second ls'ing their own disks
13:03:09 <maurer_> parcs: Why would I need a chroot? Why can't I just do what monochrom said and just install to a different PATH?
13:04:47 <ion> nyingen: What do you actually want to do?
13:04:48 <elliottt> Lemmih: i've added functionality for parsing lazy bytestrings in cereal
13:05:00 <elliottt> Lemmih: let me know what you think, when you get a chance.
13:05:30 <parcs> maurer_: you will have to either get a statically compiled version of ghc or pollute your 64-bit root with 32-bit libraries
13:06:49 <maurer_> parcs: Sane distributions already have 32-bit library equivalents.
13:06:57 <nyingen> ion: I'm not sure. I need to write a simple parser for this data structure, along the lines of a Read instance, but I don't want to use Read
13:07:29 <parcs> maurer_: that's true…
13:07:30 <maurer_> parcs: They go in /usr/lib32, so they're nice and compartmentalized.
13:07:44 <rien> I have a long question about whether continuation-based IO is really referentially transparent. I found two papers with contrasting views. If anyone could help me I'd appreciate it: http://hpaste.org/45853/continuation_based_io__quest
13:09:49 <rien> I'm asking this here because both papers compare it to monads and you guys are the only ones who know anything about monads :)
13:10:11 <maurer_> Does haskell.org have any kind of ability for others to act as mirrors (other than spidering, which would be quite abusive)?
13:10:31 <maurer_> I happen to have some spare disk and bandwidth, and am dissatisfied with the rate at which haskell.org pushes tarballs.
13:14:12 <acowley> maurer_: do you mean the archive here http://hackage.haskell.org/packages/hackage.html
13:15:43 <maurer_> acowley: In this case I was referring to the ghc tarballs on haskell.org. I have the facilities to offer a mirror similar to the community provided debian mirrors, and was wondering if there was a way to set that up.
13:16:18 <maurer_> acowley: I'm not looking to just archive for personal use, I figured there might be some kind of rotation to sign up for, but I guess not?
13:17:00 <acowley> Oh, right! The last time I downloaded GHC took ages. Mirrors are a touchy thing though, we don't even have MD5's on the download page
13:19:31 <roconnor> acowley: time to switch to nix
13:20:01 <pe> what is the recommended way of using decodeDouble from GHC.Prim ? It's not exported by GHC.Exts
13:20:16 <acowley> rien: I don't really understand the hangup with referential transparency in connection with ignoring the current continuation
13:20:21 <roconnor> @hoogle decode
13:20:21 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
13:20:21 <lambdabot> Network.CGI.Protocol decodeInput :: [(String, String)] -> ByteString -> ([(String, Input)], ByteString)
13:20:21 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
13:20:28 <roconnor> pe: decodeFloat?
13:20:46 <maurer_> acowley: Yeah, I'm currently racing a recompile of ghc for the new arch from sources I have against downloading the i386 version
13:20:51 <_o1iver> Hi everyone. I am just starting with Haskell and don't understand something. I would like to sort a list of lists by the individual lists' lengths. I know I can use "compare `on` length", but I would like to understand why sortBy (compare $ length) does not work...
13:21:19 <pe> roconnor : thanks !
13:21:33 <osfameron> could anyone give me a quick pointer with https://gist.github.com/929460 and how to write the flatten function?
13:21:38 <parcs> _o1iver: try replacing the $ with a .
13:21:41 <acowley> _o1iver: what is the type of (compare $ length)?
13:21:48 <edwardk> @type compare length
13:21:48 <lambdabot> forall a. ([a] -> Int) -> Ordering
13:21:53 <osfameron> I have to put flatten in IO, as I may use a random function
13:21:55 <edwardk> @type sortBy
13:21:56 <rien> acowley: the point he's making, I think, is that if the current continuation isn't used, then the expression returns Wrong. that would make sense as an argument for "continuations are leaky" were it not for the fact that [1] says that the expression always returns what the continuation returns, but that nevertheless a continuation-model is referentially transparent.
13:21:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:21:58 <_o1iver> ([a0] -> Int) -> Ordering
13:22:06 <parcs> (ignore me)
13:22:11 <osfameron> but I also want to apply it to a list... (map flatten ns)
13:22:28 <rien> acowley: which is to say, even without [2], I still think [1] is not well explained. I don't see how it can be referentially transparent (although it would be very interesting if indeed they were)
13:22:30 <edwardk> see the problem? compare $ length isn't a valid argument to sortBy
13:22:43 <edwardk> @type compare `on` length
13:22:44 <lambdabot> forall a. [a] -> [a] -> Ordering
13:22:57 <rien> acowley: it = continuation-based model (in my last message)
13:22:58 <roconnor> rien: there is nothing fundamentally non-referentially transparent about dropping a continuation
13:22:59 <edwardk> @type comparing length
13:23:00 <lambdabot> forall a. [a] -> [a] -> Ordering
13:23:09 <edwardk> @type sortBy (comparing length)
13:23:10 <lambdabot> forall a. [[a]] -> [[a]]
13:23:15 <_o1iver> @parcs that doesnt work, now it says Expected type: [t0] -> [t0] -> Ordering, Actual type: ([a0]->Int)->Ordering
13:23:15 <lambdabot> Not enough privileges
13:23:17 <edwardk> did you mean comparing?
13:23:28 <rien> roconnor: do you mean in the context of my question?
13:23:34 <acowley> rien: I don't see where referential transparency is coming into this, though
13:23:45 <roconnor> rien: in regards to your hpaste
13:23:59 <roconnor> "
13:24:01 <roconnor> If continuation-based IO always
13:24:02 <roconnor> provides an escape facility, then referential transparency is impossible
13:24:04 <roconnor> there
13:24:05 <_o1iver> edwardk: I don't want to use `on`, I am trying to understand why compare $ length does not work
13:24:06 <roconnor> That statement seems false to me
13:24:39 <edwardk> comparing $ length will
13:24:47 <edwardk> compare $ length isn't what you want ;)
13:24:55 <acowley> _o1iver: the types show you why
13:24:59 <edwardk> @type compare
13:25:00 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:25:05 <edwardk> @type length
13:25:05 <lambdabot> forall a. [a] -> Int
13:25:18 <_o1iver> whats with the bot...?
13:25:23 <roconnor> @type compare $ length
13:25:24 <lambdabot> forall a. ([a] -> Int) -> Ordering
13:25:43 <rien> acowley, roconnor: then you both hold the answer to my question. :) the way I see it, continuations are leaky IF the whole expression returns what the continuation returns, because then e.g. a value read from stdin can be used outside the continuations.
13:25:51 <acowley> > compare length length
13:25:52 <lambdabot>   *Exception: (==): No overloading for function
13:25:56 <acowley> :(
13:26:20 <edwardk> you can't compare length, it is a function, you can only compare it to another function
13:26:46 <_o1iver> edwardk, so how do I use the return value of length to compare? 
13:26:55 <edwardk> compare length foo -- would want to compare the function length with the function foo, how should it do so? by generating all possible lists and checking to see if they yield the same answer?
13:27:00 <edwardk> comparing length
13:27:03 <edwardk> @type comparing length
13:27:03 <lambdabot> forall a. [a] -> [a] -> Ordering
13:27:06 <edwardk> @type comparing
13:27:07 <alej> also
13:27:07 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:27:07 <acowley> edwardk: I added Axiom functional_extensionality to lambdabot earlier
13:27:09 <edwardk> comparing /= compare
13:27:10 <alej> @type ($)
13:27:10 <lambdabot> forall a b. (a -> b) -> a -> b
13:27:25 <alej> @type (.)
13:27:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:27:31 <glguy> Do Ross Paterson or Conor McBride frequent #haskell?
13:27:34 <edwardk> comparing = on compare
13:27:52 <edwardk> glguy: not very often
13:28:30 <_o1iver> edwardk, ok that works...
13:28:45 <glguy> Is it OK for (<*>) and ap to have different semantics as long as (<*>) satisfies the Applicative laws as listed in the haddocks?
13:29:12 <bos> glguy: no
13:29:17 <edwardk> _oliver: it also reads somewhat idiomatically: sortBy (comparing length) -- which explains the naming convention
13:29:24 <bos> unless you like having users of your library swear at you
13:29:25 <edwardk> glguy: no
13:29:31 <edwardk> glguy: we will all hate you
13:29:38 <monochrom> I don't think they could have different semantics...
13:29:41 <bos> edwardk and i will teepee your house
13:29:41 <glguy> But why is it not OK?
13:29:42 <glguy> What does that violate?
13:29:47 <_o1iver> edwardk, yes thats true
13:29:51 <bos> glguy: the principle of least surprise
13:30:10 <_o1iver> edwardk, so comparing acutally does this: compare (length [1,2,3]) (length [1,2])?
13:30:12 <elliottt> i guess these are all good reasons?
13:30:18 <ddarius> edwardk: I hope this means that you're back from Bermuda and not that you have no life.
13:30:25 <osfameron> within the IO monad, can I get from a [IO Foo] -> [Foo] ?
13:30:26 <glguy> http://hpaste.org/45854/exception_collection_transform
13:30:31 <dafis> bos: have you any idea why criterion would psoduce NaN lb's and ub's?
13:30:34 <edwardk> ddarius: both i hope =)
13:30:35 <mauke> osfameron: yes, but no
13:30:40 <dafis> *produce
13:30:41 <edwardk> _oliver: yes
13:30:42 <bos> dafis: not off the top of my head
13:30:53 <bos> dafis: clearly there's a zero numerator in a division somewhere
13:30:53 <monochrom> @src ap
13:30:54 <lambdabot> ap = liftM2 id
13:30:56 <edwardk> or i guess both i'm afraid
13:31:07 <rien> acowley, roconnor: mainly, I don't understand the explanation given by [1] re the referential transparency of a continuation-based model. he explains it to hastily in only one statement, and I can see a lexical connection based on the fact that the expression, which lexically contains the continuations, returns the result.
13:31:08 <ion> :t sequence
13:31:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:31:22 <Saizan> osfameron: [IO Foo] -> IO [Foo] is possible, sequence ^^^
13:31:22 <ion> :t (>>=)
13:31:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:31:40 <edwardk> i only replied to a few things in the blogosphere from Bermuda. Hard to find cheap internet access ;)
13:31:43 <monochrom> there are enough monad laws and applicative laws to tie up ap and <*>.
13:31:45 <dafis> bos: where are the stats computed? If you can tell me the module and function, I could take a look.
13:31:50 <glguy> monochrom: which ones?
13:32:01 <edwardk> monochrom: actually they aren't explicitly related.
13:32:07 <monochrom> I'm too lazy to prove how now. the docs have the laws
13:32:10 <osfameron> mauke, Saizan, ion: ah, ok, I'll have a play with sequence to start with then...
13:32:13 <osfameron> ta
13:32:17 <edwardk> monochrom: but every existing type that offers them has them compatible
13:32:18 <ion> :t (>>=) . sequence
13:32:18 <lambdabot> forall (m :: * -> *) b a. (Monad m) => [m a] -> ([a] -> m b) -> m b
13:32:19 <_o1iver> edwardk, so the difference between compare and comparing is that comparing evaluates the function and compare doesnt right?
13:32:24 <glguy> monochrom: yeah, I don't think the docs cover this
13:32:41 <edwardk> monochrom: ziplists and normal lists provide a counter example, there are plenty of ADTs that can be made applicative in multiple ways
13:32:51 <glguy> edwardk: did you see the paste? does that make sense to you?
13:32:57 <monochrom> oh, there are counterexamples? then nevermind
13:33:05 <dafis> bos: and, have you changed anything related to the stats from 0.5.0.7 to 0.5.0.8 ? if not, it could be a ghc thing
13:33:10 <bos> dafis: you'll have to sleuth yourself, sorry
13:33:12 <edwardk> @type comparing
13:33:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:33:23 <bos> dafis: it's not a ghc thing, i've received a few reports of this
13:33:28 <edwardk> compare = comparing id or comparing = on compare
13:33:54 <edwardk> glguy: i didn't see the paste. one sec.
13:34:01 <_o1iver> edwardk, thx
13:34:03 <glguy> OK, no rush :)
13:34:25 <monochrom> wait, it is not enough to make applicative in multiple ways. to be perfectly fair, you have to fix making functor one way, then on top of that still make applicative multiple ways, and then I'm convinced
13:34:34 <edwardk> glguy: i understand why you might be tempted to make them different, but it is a bad idea. most folks just use applicative sugar mixed in with their monadic code and don't 'switch semantics' when they do so.
13:34:37 <edwardk> it is really a bad idea
13:34:55 <glguy> edwardk: I understand that people make assumptions and that in general it could be confusing
13:35:46 <edwardk> glguy: we had a type in scalaz that did exactly this before I came along with a sledgehammer. ;)
13:36:41 <HaudRex> edwardk: A type that did what?
13:36:42 <edwardk> in the end we dropped its monad instance, and replied on explicitly transforming to EitherT for monadic fragments as needed
13:36:53 <edwardk> validation's old monad instance
13:37:29 <edwardk> er s/replied/relied/
13:38:20 <_o1iver> edwardk, so shouldnt compare . length have the same result? f . g = f (g x)
13:38:27 <edwardk> @type compare . length
13:38:28 <lambdabot> forall a. [a] -> Int -> Ordering
13:38:51 <edwardk> compare . length will take the length of a list, and compare it with some integer you give it
13:38:59 <_o1iver> edwardk, yes but how come that doesnt return a curried function?
13:39:14 <edwardk> > (compare . list) [1,2,3] 3
13:39:15 <lambdabot>   Not in scope: `list'
13:39:18 <edwardk> er
13:39:19 <edwardk> it does
13:39:29 <edwardk> > (compare . length) [1,2,3] 3
13:39:32 <lambdabot>   EQ
13:39:59 <edwardk> it returns a curried function, you only composed length with it once, in a way that it only affects the first argument
13:40:00 <osfameron> yay!  using sequence, as people recommended above, does work: https://gist.github.com/929460
13:40:01 <_o1iver> but then sortBy should be applying that curried function to all the elemnts of the list (in this case the "sub-lists") 
13:40:18 <_o1iver> no?
13:40:18 <edwardk> compare . length has the wrong signature to pass to sortBy
13:40:21 <osfameron> it's quite a bit of boilerplate though... am I going about it stupidly/inelegantly?
13:40:35 <_o1iver> edwardk, yeah I understand that, but I dont understand why...
13:40:38 <edwardk> @type sortBy (compare . length)
13:40:38 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Int'
13:40:38 <lambdabot>     In the second argument of `(.)', namely `length'
13:40:38 <lambdabot>     In the first argument of `sortBy', namely `(compare . length)'
13:40:41 <mauke> _o1iver: look at its type
13:40:45 <edwardk> because look at sortBy
13:40:47 <edwardk> @type sortBy
13:40:48 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:41:02 <edwardk> sortBy expects a fucntion that knows how to take two arguments of the same type, and return an Ordering
13:41:02 <edwardk> but
13:41:08 <edwardk> @type compare . length
13:41:09 <lambdabot> forall a. [a] -> Int -> Ordering
13:41:16 <edwardk> only knows how to take one list and an Int.
13:41:27 <_o1iver> ahh ok I understand
13:41:29 <edwardk> in order to pass that to sortBy you'd need to unify [a] and Int
13:41:44 <edwardk> which is where the type error above comes from
13:43:50 <rien> roconnor, acowley: can you guys point me somewhere for resources on that? It's tough finding anything on continuation-based IO
13:44:10 <ion> osfameron: do x <- foo; return (bar x) can be written as bar <$> foo
13:44:16 <_o1iver> edwardk, ok I understand... thanks
13:44:23 <edwardk> _o1iver: no problem
13:45:07 <osfameron> ion: ah cool, I'll try that thanks
13:45:14 <Twey> 220054 < ion> osfameron: do x <- foo; return (bar x) can be written as bar <$> foo
13:45:16 <Mathnerd314> msg preflex seen augur
13:45:22 <Twey> A.K.A. fmap bar foo
13:45:25 <augur> ow
13:45:27 <Twey> Assuming the monad is also a Functor
13:45:28 <augur> stop that :|
13:45:40 <Mathnerd314> sorry
13:45:41 <Twey> Which it should be, but that's not guaranteed
13:45:48 <augur> sup Mathnerd314
13:45:59 <edwardk> twey: or just liftM bar foo
13:46:01 <Twey> osfameron: The Monad equivalent of fmap/<$> is called liftM
13:46:02 <Twey> Right
13:46:16 <osfameron> @index <$>
13:46:16 <lambdabot> bzzt
13:46:21 <Twey> osfameron: Control.Applicative
13:46:24 <Twey> @index (<$>)
13:46:24 <lambdabot> bzzt
13:46:26 <Twey> Hmph
13:46:50 <Mathnerd314> augur: just running checks on all the cool people
13:47:07 <augur> woo! i'm cool! \o/
13:47:23 <acowley> rien: the first paper you cite draws a pretty serious line between Requests and Responses such that the connection is quite hidden
13:47:40 <acowley> rien: there's not much to the claim of referential transparency, which is why the authors move past it so quickly
13:48:06 <osfameron> Twey: thanks
13:48:13 <rien> acowley: if that's widely accepted, why doesn't [2] accept it?
13:48:14 <osfameron> so, would I rewrite that to something like: flatten (Quiz s ns) = Quiz s <$> sequence $ map flatten ns
13:48:17 <osfameron> ?
13:48:43 <Twey> sequence $ map … = mapM_ …
13:48:46 <osfameron> hmmm, doesn't like that
13:48:51 <Twey> Er, mapM …
13:49:18 <rien> acowley: [2] claims you can't make it so a value can't escape a continuation. isn't that analogous to one always being able to pattern match on (IO x) -> putStr x in Haskell? isn't ref. transp. lost thus?
13:49:47 <osfameron> ah, thanks, mapM works for me
13:50:35 <edwardk> rien: which source is this?
13:50:43 <acowley> edwardk: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9516
13:50:53 <maurer_> acowley: I've got the 32-bit ghc now, but it still seems to manage to mysteriously produce 64-bit code.
13:50:53 <sully> @pl \(x, y) -> (y, x)
13:50:54 <lambdabot> uncurry (flip (,))
13:50:58 <rien> edwardk: [2] The essence of functional programming - Wadler
13:51:04 <rien> edwardk: page 18
13:51:04 <Twey> flatten (Quiz s ns) = Quiz s <$> mapM flatten ns
13:51:10 <edwardk> rien: keep in mind, with rank 2 types, the game is a bit different now
13:51:36 <acowley> maurer_: Back when Mac OS X 10.6 first came out, there was a problem with this and the fix was to add a flag to GHC invocations that was much like m32
13:51:44 <acowley> maurer_: I don't remember the details
13:52:00 <rien> edwardk: tilting the game to which end? (rank 2 types are above my head, I think)
13:52:03 <maurer_> acowley: :( OK. It seems like this wouldn't be that uncommon of a request
13:52:10 <Twey> If you have record syntax, say Quiz { a :: a, b :: b }, you can write flatten Quiz { b = b' } = q { b = mapM flatten b' }
13:52:16 <Twey> Err
13:52:25 <Twey> flatten q@Quiz { b = b' } = q { b = mapM flatten b' }
13:52:28 <_o1iver> edwardk, sorry I am trying to understand this well. The problem is that you cannot curry compare because of the way it is defined. I mean there is no way you can curry compare (p x) (p y) with p...
13:52:28 <edwardk> rien: to where you can make safe region-controlled file handles, etc. that you know won't be used outside of a delimited context.
13:52:36 <mzero> maurer_: did you compile that GHC yourself?
13:52:46 <Twey> fclabels or something is also appropriate here
13:52:52 <maurer_> mzero: No, I'm using the downloaded i386 binary
13:52:56 <edwardk> compare is already 'curried'. currying just means it takes its arguments one at a time rather than as a tuple
13:53:04 <maurer_> mzero: Didn't want to mess around with the experimental cross compiler
13:53:17 <_o1iver> ok
13:53:19 <mzero> heh - right - that's why I'm surprised you seem to have one!
13:53:27 <edwardk> @pl \x y -> compare (p x) (p y)
13:53:27 <lambdabot> (. p) . compare . p
13:53:31 <edwardk> there ;)
13:53:32 <maurer_> mzero: It's accidental, I assure you.
13:53:35 <edwardk> pointfree
13:53:52 <mzero> I just wonder how such a beast got built!
13:54:36 <osfameron> ok.  so if "do x <- foo; return bar x" was equivalent to bar <$> foo, the...
13:54:46 <Twey> edwardk: Eww
13:54:48 <osfameron> ... what's equivalent to "do x <- foo; bar x"?  e.g. without the return?
13:54:51 <fryguybob> @pl \p -> (. p) . compare . p
13:54:51 <lambdabot> ap ((.) . flip (.)) (compare .)
13:54:53 <rien> edwardk: I'm trying to picture those things in terms of Scheme, where there are only value types but no variable types (and certainly no ADT). I want to experiment and see if I can indeed treat continuations as monads, in the sense that I can box them in the continuation and only allow them out if I define that "monad" to allow them out
13:54:56 <edwardk> rien: packages like http://hackage.haskell.org/packages/archive/safer-file-handles/0.10/doc/html/System-IO-SaferFileHandles.html use that region machinery to ensure you don't try to read from closed files, etc.
13:54:59 <Twey> edwardk: on compare p
13:55:17 <Twey> osfameron: foo >>= bar
13:55:21 <edwardk> Twey: i know, _ol1ver has an irrational aversion to the 'on' combinator ;)
13:55:26 <Twey> o.@
13:55:28 <Twey> Weird
13:55:39 <Twey> That's a lovely combinator
13:55:39 <Twey> Love it
13:56:05 <maurer_> mzero: http://hpaste.org/45855/accidental_cross_compilation
13:56:06 <Twey> osfameron: do x <- foo; bar x = foo >>= \x -> bar x = foo >>= bar
13:56:16 <maurer_> mzero: This is the i386 build available for download at haskell.org, nothing fancy
13:56:32 <maurer_> Adding -optc-m32 results in a failed build :(
13:56:44 <rien> edwardk: you used the word "delimited". I was thinking that delimited continuations are probably the only way to go, and likely what both articles mean
13:56:48 <osfameron> Twey: ah, yes. *forehead slap*
13:56:50 <mzero> maurer_: what do you get for    ghc --info
13:56:51 <ion> Also, bar =<< foo which matches the typical function application ordering.
13:56:55 <mzero> ?
13:57:05 <acowley> rien: In the first paper, the continuation seems much more implicit
13:57:30 <mzero> if that GHC is thinking it is generating 64 bit code, then the c flag isn't going to be enough to help!
13:57:34 <acowley> rien: while if it were explicit, and could be re-used, then I suppose there could be some trouble
13:57:50 <maurer_> mzero: http://hpaste.org/45856/ghc_info
13:57:50 <osfameron> Twey: I can't just write pickN r ns >>= Section s r <$> mapM flatten
13:57:57 <osfameron> though
13:58:09 <maurer_> mzero: Understood, but it shouldn't think it's generating 64-bit code!
13:58:24 <Twey> osfameron: I don't know what any of those functions are
13:58:31 <Twey> But it might be that the precedence is wrong; I always forget
13:58:34 <rien> acowley: how do the continuations seem implicit to you in [1]? they are being explicitly passed to readFile. (let's pretend those are one-shot continuations for the sake of simplicity :) )
13:58:44 <ion> ‘\x -> foo + bar x’ can’t be written as ‘foo + bar’
13:58:46 <Twey> pickN r ns >>= (Section s r <$> mapM flatten)
13:58:57 <osfameron> Twey: fair enough, I'll have more of a play, thanks
13:59:00 <ion> @pl \x -> foo + bar x
13:59:00 <lambdabot> (foo +) . bar
13:59:03 <Twey> Oh, right, I see what you're doing
13:59:05 <mzero> maurer_: nope, with that --info output, it sure shouldn't be generating 64bit code
13:59:06 <Twey> Yes, as ion says
13:59:13 <acowley> rien: exactly because of the one-shotness due to being tied to a position in the list
13:59:15 <Twey> What was the original?
13:59:33 <osfameron> original was in https://gist.github.com/929460
13:59:40 <Twey> ‘do x <- pickN r ns; Section s r <$> mapM flatten x’?
13:59:40 <maurer_> mzero: Anything else to try?
13:59:57 <osfameron> Twey: yes, that was the intermediate version, yeah
14:00:01 <Twey> Ah, okay
14:00:07 <mzero> I'm pretty sure 7.0.2 i386 works on Mac
14:00:13 <osfameron> which might be good enough tbh
14:00:37 <rien> acowley: what list is that?
14:00:44 <_o1iver> edwardk, last question: how do I use compare . length? It requires a list and an Int, but compare . length [1,2,3] 2 does not work... (if I save the individual functions to variables it works, but how do I call it in one line?)
14:00:46 <maurer_> mzero: Well, if I was going to bother with another machine I wouldn't have this issue. I'm just trying to figure out how to build i386 binaries off of my laptop.
14:01:05 <edwardk> _ol1ver: you'd parenthesize it like i did above
14:01:16 <edwardk> > (compare . length) "hello" 2
14:01:18 <lambdabot>   GT
14:01:53 <mzero> maurer_: try --optl-m32
14:01:59 <mzero> note the 'l', not 'c'
14:03:04 <rien> edwardk: I'm mainly interested in this because it's an interesting model for doing pure IO without relying on types (I think uniqueness doesn't either, but whatever). that's why I'm trying to understand if/why it really works.
14:03:12 <_o1iver> edwardk, ah ok thanks! finally :-) I just saw the "_o1iver has an irrational aversion to"... :-p, it's just that although compare on works I was trying to understand why what I was doing wasnt working... (now I know :-])
14:03:56 <maurer_> mzero: I'll try it, but that's not going to work (it was generating assembly with pushq)
14:04:08 <edwardk> _o1iver: hah. i understand. just ribbing ;)
14:04:24 <_o1iver> edwardk, no problem :-) Thanks for the help!
14:04:31 <edwardk> @src comparing
14:04:31 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:04:40 <mzero> maurer_:  ah, well then, it seems broke! You should report this over on #ghc
14:05:05 <Twey> osfameron: http://hpaste.org/45857/flatten_randomsection_for_osf
14:05:32 <maurer_> mzero: http://hpaste.org/45858/build_log
14:06:21 <osfameron> Twey: thanks!
14:06:31 * osfameron works through Twey's stages of refinement
14:06:50 <mzero> that looks bad, maurer_ 
14:09:34 <rewers08> .
14:16:49 <appamatto> rien, are you designing a language?
14:17:56 <rien> appamatto: yes, but I'm not in a hurry :) I'm taking some time to survey my options. I wanted it to be like scheme (I'm using Queinnec's book) but pure, but still without ADTs
14:18:22 <rien> appamatto: so I was looking for ways to deal with IO and mutation (mostly IO for now) without monads
14:18:30 <rostayob> @pl \i -> either (\_ -> Nothing) Just (inputValue i) >>= B8.unpack
14:18:30 <lambdabot> (B8.unpack =<<) . either (const Nothing) Just . inputValue
14:19:37 <appamatto> no ADTs? You mean, no user classes?
14:20:39 <rien> appamatto: I mean no types, like Scheme.
14:23:10 <abinosajan> scree: 
14:24:31 <appamatto> rien, huh, I didn't know that Scheme had no types
14:25:10 <appamatto> Just tuples etc.?
14:25:16 <rien> appamatto: only the values have types, not the bindings.
14:26:10 <appamatto> hmm, but those values also don't have user types?
14:26:52 <appamatto> I guess I don't quite see why scheme can't have monads
14:27:19 <rien> appamatto: I'm not sure what you mean. what I mean is you can't restrict a function to be Int -> Int for instance
14:27:30 <appamatto> Right, I see
14:27:54 <rien> appamatto: I've written monads in scheme, but I have to work with the bare "bind" and "return" functions. makes little sense without a grand type scheme behind it (no pun intended)
14:28:00 <zenzike> I can't find a factorial function in the prelude: do I really have to roll my own?
14:28:10 <shachaf> zenzike: product [1..n]
14:28:19 <shachaf> @google evolution of a haskell programmer
14:28:20 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:28:20 <lambdabot> Title: The Evolution of a Haskell Programmer
14:28:25 <zenzike> shachaf: I realise it's easy, I'm just suprised
14:28:37 <appamatto> rien, I see
14:28:38 <kalven> this is an outrage, make a hackage package of it
14:28:51 <zenzike> kalven: agreed :-)
14:49:17 <Gracenotes> gwern: USO DA! D:
14:50:05 <gwern> Gracenotes: I always tell the truth... from a certain POV
14:51:03 <Gracenotes> gwern: yeah. I'm just watching through Higurashi again this Spring Break. fun to be had etc.
14:51:42 <gwern> quite enjoyable. I really like the whole-start-off-normal-and-plunge-into-depraved-madness thing and the contrast between the horror and idyllic daily life
14:51:58 <gwern> (_Evangelion_ does that a lot with music)
14:52:07 <Gracenotes> idyllic is one way to describe something that borders on a harem anime
14:53:14 <Gracenotes> for some reason I like the military-level conspiracies of Season 2 a bit better. But the whole idyllic/pastoral motif as well
14:53:36 <shachaf> Gracenotes: Have you met gwern in person?
14:54:03 <Gracenotes> ...not to my knowledge?
14:54:19 <shachaf> Ah.
14:54:40 <shachaf> It's just that you presumably live in the same geographical area and all.
14:55:26 <Gracenotes> Yeah. There is that -_-
14:56:05 <Gracenotes> Stony Brook's LUG has talked about Haskell before. Or, well, I have there.
14:58:47 <gwern> Gracenotes: I was actually a little disappointed when the military thing got explained. I liked having multiple viable conspiracy theories/explanations
14:59:42 <Gracenotes> well. My favorite episode in the entire series is the one involving Satoshi taking place in the "present"
15:00:08 <Gracenotes> I guess I have a soft spot for the answer arcs (except the answer to watanagashi)
15:00:26 <gwern> Gracenotes: so for example, for me the best episodes was the mion/shion arc
15:00:28 <Gracenotes> but they set everything up very nicely
15:01:17 <Gracenotes> yeah. it's nice to watch it all again.
15:02:49 <gwern> right now I've started _RideBack_. looks like it'll be fun action
15:03:23 <gwern> (hopefully by the time I've finished that, the last 2 eps of _Madoka_ will be out)
15:04:54 <Gracenotes> ooh
15:05:20 <gwern> Gracenotes: have you been watching _Madoka_? all the cool kids are
15:08:51 <Saizan> #haskell-blah?
15:09:29 <gwern> ah, now I can post my comment: http://news.ycombinator.com/item?id=2464476
15:09:40 <gwern> er, mischan. that was meant for #lesswrong
15:15:54 <Gracenotes> gwern: I am not cool. but consuming cool art is a good way to pass the time.
15:16:16 <gwern> (_Madoka_ has some pretty cool art in it. not pretty necessarily, but cool)
15:18:02 <_o1iver> How come I get an error with the following line: --| otherwise = 1 + treeHeight cl ? Should it not be a comment? It works fine if I put a space between "--" and "|"... strange...
15:18:07 <aristid> Gracenotes is not cool. you know what's cool? zygohistomorphic prepromorphisms!
15:18:59 <ivanm> _o1iver: comments start with "-- "
15:19:11 <gwern> aristid: zygowhatsit prepomorphisms are not cool. you know what's cool? _|_ billion dollars
15:19:27 <_o1iver> ivan so there must allways be a space after "--"
15:19:30 <ivanm> it's OK to do "--a" or something, but if you do "--|" then technically that is using an operator
15:19:36 <monochrom> "--|" can be a legal operator name
15:19:43 <_o1iver> ok I didn't know that
15:19:55 <monochrom> > let x --| y = 5 in 'x' --| 'y'
15:19:56 <lambdabot>   5
15:20:16 <monochrom> whereas "--a" is tokenzied to "--","a" now you have a comment
15:20:32 <_o1iver> didn't know that... good to know though
15:20:52 <ivanm> of course, usually said "operator" isn't legal anyway, since `-' is the only allowable unary operator
15:20:59 <monochrom> we read the haskell 98 report cover to cover for this
15:21:08 <elliottcable> God fucking damnit, I should have registered “elliott” years ago just so I could squat it
15:21:10 <monochrom> binary operator
15:21:16 <elliottcable> I can’t lurk this channel now D:
15:21:23 <_o1iver> ivanm thats what I thought too
15:21:26 <elliottcable> people talking to faux-elliott fill up my /away log ;_;
15:21:33 <_o1iver> rothwell, are you from australia?
15:21:57 <rothwell> _o1iver: nope
15:22:02 * ivanm is
15:22:31 <_o1iver> rothwell, ok cause I know a programmer from australia called "rothwell" just checking :-p (dunno how many rothwells exist...)
15:22:44 <rothwell> quite a few, i think!
15:22:44 <monochrom> do x <- b--|a
15:22:55 <_o1iver> yeah probably
15:23:50 <_o1iver> the stupid thing with |-- is that my editor doesnt put a space after -- when I comment a line
15:24:04 <_o1iver> *--|
15:24:21 <ivanm> _o1iver: which editor?
15:24:22 <monochrom> heh, upgrade your editor
15:24:29 <_o1iver> Sublime Text 2
15:24:48 <_o1iver> just changed to windows so I just took something that someone told me about
15:24:52 <_o1iver> what do you use?
15:24:59 <monochrom> when someone mentions a windows problem, we usually say "upgrade your OS... to OS/2!"
15:25:06 <_o1iver> haha
15:25:58 <monochrom> we also say "this software says it runs on windows 95 or better, well I have os/2, that's better..."
15:26:10 <ivanm> monochrom: we do? don't recall anyone saying that here before...
15:26:23 <monochrom> no, we the os/2 fans
15:26:32 <monochrom> TEAM OS/2!
15:26:36 <ivanm> you exist? :o
15:26:46 <_o1iver> ivanm :-)
15:26:54 <monochrom> we exist
15:27:06 <ivanm> @google bofh os/2
15:27:11 <lambdabot> http://www.theaubergineroom.com/the_bofh_rips_into_mac_and_acorn_users
15:27:11 <lambdabot> Title: The BOFH rips into Mac and Acorn users | theaubergineroom
15:27:45 <_o1iver> damn that is a cool bot
15:27:59 <monochrom> oh, did you know of http://www.commodoreusa.net/CUSA_Home.aspx
15:28:09 <ivanm> the new commodore? yeah
15:28:36 <monochrom> it probably can run os/2 too...
15:28:43 <ivanm> OK, that google result sucked
15:28:44 <monochrom> but linux is good enough!
15:29:43 <monochrom> your editor is sublime
15:29:52 <monochrom> you mortgaged it on subprime
15:33:11 <_o1iver> i have a type: data Tree a = Node a (Tree a) (Tree a)
15:33:11 <_o1iver>               | Empty
15:33:11 <_o1iver>               deriving (Show, Eq)
15:33:54 <_o1iver> and in ghci if i create two same Trees I can compare them with ==, but in my code I can't... (treeHeight a 
15:33:54 <_o1iver>            | a == Empty = 2) why is that?
15:34:14 <_o1iver> "No instance for (Eq a)"
15:34:26 <ivanm> what is that `|' doing there?
15:34:29 <mauke> did you write a type signature for treeHeight?
15:34:38 <mauke> what is it?
15:34:41 <_o1iver> ivanm, there are more guards below
15:34:41 <ivanm> oh, a guard for the line above :s
15:34:43 <mauke> see the lack of (Eq a)?
15:34:51 <mauke> yeah, that's why
15:34:53 <_o1iver> treeHeight :: (Tree a) -> Int
15:35:02 <mauke> FASTER, MAN
15:35:06 <mauke> I've already finished this dialog
15:35:06 <ivanm> ghci has "defaulting"... so if you don't specify what `a' is, it just considers it to be Integer or something
15:35:11 <_o1iver> no a guard for the line below
15:35:13 <ivanm> sorry mauke :(
15:35:13 <monochrom> you are better of showing more complete code.
15:35:14 <ivanm> :p
15:35:32 <_o1iver> treeHeight :: (Tree a) -> Int
15:35:32 <_o1iver> treeHeight Empty = 0
15:35:32 <_o1iver> treeHeight a 
15:35:32 <_o1iver>            | a == Empty = 2
15:35:32 <_o1iver>            | otherwise = 3
15:35:32 <_o1iver> --           | cr == Empty = 3 
15:35:36 <_o1iver> --           -- | otherwise = 1 + treeHeight cl
15:35:43 <_o1iver> didnt want to paste all over the place :-p
15:35:59 <mauke> _o1iver: your type signature promises to work for all Tree a
15:36:05 <mauke> _o1iver: == requires Eq a
15:36:10 <mauke> this is a contradiction
15:36:12 <_o1iver> mauke: I dont understand "lack ok EQ"
15:36:12 <ivanm> but equality only works for a sub-set of a
15:36:25 <ivanm> _o1iver: how does Eq work for "Tree (a -> b)" ?
15:36:49 <ivanm> _o1iver: typically, it's also wrong to do something like "a == Empty"
15:36:53 <monochrom> don't use == for merely "is it Empty?"  such a schemism, lispism, cism
15:36:54 <_o1iver> why?
15:36:59 <ivanm> that is why the good writers of Haskell invented pattern matching!
15:37:01 <ivanm> ;)
15:37:09 <monochrom> treeHeight Empty = 2
15:37:18 <monochrom> there is a reason pattern-matching was invented
15:37:42 <_o1iver> treeHeight :: (Tree a) -> Int
15:37:42 <_o1iver> treeHeight Empty = 0
15:37:42 <_o1iver> treeHeight (Node a cl cr) 
15:37:42 <_o1iver>            | cl == Empty = 2
15:37:42 <_o1iver>            | cr == Empty = 3 
15:37:42 <_o1iver>            | otherwise = 1 + treeHeight cl
15:38:03 <monochrom> treeHeight (Node a Empty cr) = 2
15:38:04 <_o1iver> thats what I am actually trying to do, therefor its not a pattern, I don't know how to do that in a pattern (yet???)
15:38:06 <ivanm> pattern-matching for structure; guards for checking properties
15:38:21 <monochrom> (use recursive thinking)
15:38:27 <ivanm> _o1iver: it's a pattern in the _structure_, not in terms of "doing things multiple times"
15:38:37 <ivanm> treeHeight (Node a Empty cr) = 2
15:38:46 <_o1iver> ivanm, ah!
15:38:53 <monochrom> treeHeight (Node a cl Empty) = 3
15:39:08 <ivanm> treeHeight (Node a cl cr) = 1 + treeHeight cl
15:39:08 <monochrom> treeHeight (Node a cl cr) = 1 + treeHeight cl
15:40:27 <_o1iver> now i get a cl not in scope, cr not in scope
15:41:11 <ivanm> because you're doing your code differently to what you told us
15:41:15 <_o1iver> ah no...sorry my bad
15:41:26 * ivanm suggests _o1iver go through the sections on pattern matching in tutorials again
15:41:32 <_o1iver> i am an idiot
15:41:37 <_o1iver> ivanm, I agree!
15:46:56 <jamwt> guys, in .cabal files, is there a way for me to use a common build-depends for many "Executable" sections?
15:47:00 <jamwt> so far seems like no
15:47:28 <jamwt> trying to DRY here but I can't seem to convince the cabal/cabal install gods to use the top-level build-depends for these executables
15:47:43 <monochrom> it seems like no to me too
15:48:14 <jamwt> boo-urns.
15:56:43 <ivanm> jamwt: don't think you can
15:56:52 <ivanm> you _can_ if there's a library section
15:57:03 <ivanm> but that will result in the library being re-built for every executable
15:59:36 <ivanm> preflex: seen kowey
15:59:36 <preflex>  kowey was last seen on #darcs 6 hours, 21 minutes and 10 seconds ago, saying: I wonder how that one happened!
16:02:16 <ivanm> @tell kowey the first link in your "why darcs users care about consistency" post just points to blogger.com; methinks you meant roconnor's post?
16:02:16 <lambdabot> Consider it noted.
16:05:23 <dafis_> Does anybody know why hackage doesn't build and haddock new packages in the last few days?
16:07:07 <ivanm> example?
16:09:31 <dafis_> criterion-0.5.0.8
16:11:02 <ivanm> huh
16:11:08 <ivanm> preflex: seen dcoutts 
16:11:09 <preflex>  dcoutts was last seen on #ghc 6 hours, 55 minutes and 48 seconds ago, saying: tibbe: :-)
16:11:34 <ivanm> dafis_: my guess is that no-one has noticed that the cron-job died ;)
16:11:50 <dafis_> that could be of course
16:22:32 <dncr> @pl \ g f x y -> g (f x) (f y)
16:22:33 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:22:37 <dncr> @pl g (f x) (f y)
16:22:37 <lambdabot> g (f x) (f y)
16:30:27 <ion> > on (g :: Expr -> Expr -> Expr) f x y -- dncr
16:30:28 <lambdabot>   g (f x) (f y)
16:40:52 * Warrigal looks around quickly, then ducks out.
16:41:26 <Warrigal> Much better.
16:55:11 <Kaidelong> (x & y) + ((x ^ y) >> 1)
16:55:18 <Kaidelong> is this a sensible way to take a mean of two numbers?
16:55:25 <sec^nd> hi
16:55:36 <ivanm> Kaidelong: I would say "(a + b) / 2" is ;)
16:55:45 * ivanm waves idly in sec^nd's general direction
16:55:54 <Twey> Seems much more sensible
16:55:55 <Kaidelong> ivanm: but that can overflow
16:56:02 <sec^nd> I'm new to haskell and I'm trying to make my config for xmonad
16:56:07 <Twey> So can yours
16:56:12 <Kaidelong> it can?
16:56:14 <Twey> If you're using a type that will overflow
16:56:15 <sec^nd> so without further adu here are some questions :P
16:56:30 <Twey> If you're not, it won't
16:56:36 <Kaidelong> I am pretty sure adding (x & y) to ((x ^ y) >> 1) will never overflow
16:56:44 <Kaidelong> regardless of whether the type allows it
16:57:05 <sec^nd>  myManageHook = composeAll that means it defines a function which == composeAll 
16:57:20 <sec^nd> className =? "Gimp"      --> doFloat
16:57:22 <ivanm> sec^nd: you're missing the next bit
16:57:30 <sec^nd> ivanm: I have it :P
16:57:34 <Kaidelong> mainly because the high bit of (x^y)>>1 is never 1
16:57:39 <ivanm> there's also #xmonad
16:57:43 <sec^nd> what does the =? mean ?
16:57:48 <Kaidelong> oh whoops wrong channel
16:57:52 <sec^nd> ivanm: i'm trying to understand haskell not xmonad
16:57:54 <Kaidelong> I meant this for haskell-blah
16:57:55 <ivanm> sec^nd: =? is an xmonad-ism
16:58:00 <sec^nd> -.-
16:58:13 <sec^nd> brb, thats why I couldn't find it
16:58:26 <ivanm> sec^nd: check the documentation of xmonad itself
17:01:06 <sec^nd> ivanm: I cant understand the docs too well
17:01:21 <sec^nd> symbols like <- are confusing and I have no idea what its doing
17:01:55 <derdon> 1 / 0 is Infinity and 0 / 0 is NaN. meh
17:02:08 <derdon> consistency, where are you now?
17:02:30 <dmwit> What's inconsistent about that?
17:02:31 <derdon> why is 1/0 Infinity?
17:02:38 <dmwit> 1/2 is not the same as 0/2 either
17:02:44 <ivanm> derdon: lim (x -> 0) 1/x -> infinity
17:02:53 <dmwit> sec^nd: <- is from do-notation
17:02:57 <dmwit> sec^nd: It desugars this way:
17:02:59 <ivanm> whereas 0/0 is just undefined
17:03:11 <dmwit> do { x <- foo; bar } ==> foo >>= \x -> bar
17:03:20 <dmwit> do { foo; bar } ==> foo >> bar
17:03:27 <dmwit> do { foo } ==> foo
17:03:29 <derdon> I see
17:03:37 <dmwit> sec^nd: There's a few more rules, but those are the important ones.
17:04:04 <hpc> the only other rule is do {let x = y; z} ==> let x = y in z
17:04:19 <hpc> oh, and fail
17:04:24 * hpc pretends it isn't there
17:04:36 <Twey> Heh
17:04:50 <ivanm> hpc: yeah, fail is a fail... ;)
17:05:01 <derdon> hi Twey :)
17:05:09 <monochrom> do x:xs <- getLine ...
17:05:19 * hpc is totally open to fail :: MonadFail m => String -> m ()
17:05:38 <Twey> do { p <- foo; bar } ==> foo >>= \ v -> case v of p -> bar; _ -> fail "Pattern match failure"
17:05:41 <Twey> Or something like that
17:05:45 <Twey> derdon: Hi \o
17:05:50 <sec^nd> ...
17:05:55 * sec^nd is so confused
17:05:59 <Twey> sec^nd: Ignore it
17:06:04 <Twey> It's not important
17:06:04 <monochrom> what is so confusing?
17:06:07 <hpc> sec^nd: just go with the stuff that doesn't confuse you
17:06:24 <sec^nd> isn't much to go on
17:06:34 <sec^nd> I'm know C / C++ etc
17:06:52 <sec^nd> i've been reading learnyouahaskell and the whole logic of the language is confusing
17:07:05 <sec^nd> how am I supposed to store varibles etc 
17:07:06 <monochrom> I came from c++ too. not confusing.
17:07:23 * sec^nd points to different minds
17:07:26 <hpc> sec^nd: it helps to go into it with the understanding that everything you know from other languages will not apply at all
17:07:40 <sec^nd> D:
17:07:40 <dmwit> sec^nd: If you have a more specific question than "I don't get it", we might be able to help a bit more.
17:07:49 <hpc> sec^nd: also think of it as math, more than programming
17:07:53 <derdon> sec^nd: UTSL :P
17:07:59 * sec^nd ask what this button does
17:08:05 <hpc> dmwit: first he has to formulate a question, which is admitedly a hard task
17:08:07 <dmwit> As for storing variables, you write their value with "=", just like in C.
17:08:09 <sec^nd> hpc: so then what is haskell good for ?
17:08:11 <derdon> don't push it, sec^nd!
17:08:13 <m3ga> sec^nd: do not try to transliterate C++ programs into haskell programs.
17:08:19 <sec^nd> xmonad is written in haskell ?
17:08:27 <dmwit> Only you don't get a second chance, so the first assignment has to be a good one. =)
17:08:29 <sec^nd> derdon: what is UTSL ?
17:08:31 <hpc> sec^nd: don't think about writing programs yet
17:08:34 <hpc> think of functions
17:08:37 <derdon> sec^nd: use the source, luke
17:08:41 <sec^nd> hpc: I got that much down
17:08:50 <sec^nd> everything is a function and cannot be redefined
17:08:51 <aristid> sec^nd: how did you suddenly come from "i don't understand haskell" to "what is haskell good for?"
17:08:58 <mauke> sec^nd: no
17:09:00 <sec^nd> x = 5 is really a function that returns 5
17:09:00 <hpc> wait and ye shall receive
17:09:02 <aristid> no. not everything is a function.
17:09:03 <mauke> sec^nd: no
17:09:06 <aristid> only functions are functions.
17:09:17 <derdon> aristid: correct :)
17:09:19 <Twey> sec^nd: In C terms, in that it's not evaluated immediately, yes
17:09:28 <Twey> But we only call things functions in Haskell when they take values
17:09:32 <mauke> Twey: 5 is totally evaluated
17:09:41 <sec^nd> ahh k
17:09:49 <Twey> mauke: Well, yes, but.  :þ
17:09:54 <derdon> DO YOU WANT THE TOTAL EVALUATION??!!!
17:10:02 <sec^nd> YES
17:10:05 <hpc> derdon: sounds like an arnie movie
17:10:11 <derdon> hpc: fail
17:10:17 <Twey> YOU CAN'T HANDLE THE TOTAL EVALUATION
17:10:25 <nyingen> @hoogle (+++)
17:10:25 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
17:10:25 <lambdabot> Text.Html (+++) :: (HTML a, HTML b) => a -> b -> Html
17:10:25 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
17:10:26 <hpc> TOTAL EVALUATION
17:10:31 * sec^nd has to learn a whole language to get his config working nicely
17:10:43 <monochrom> oh, there is #xmonad for that
17:10:54 <sec^nd> :/
17:10:54 <hpc> arnold is stuck in a fixed point and has to bust his way out with motorcycles and whnf
17:11:06 * sec^nd has you on split screen with #xmonad
17:11:14 <monochrom> but yeah, last time I reconfigured apt-get, I had to learn a whole new language too
17:11:20 <sec^nd> whats a good tutorial ?
17:11:21 <hpc> cue 1:30 of explosive ultra-violence like only the '80s can provide
17:11:27 * sec^nd hasn't finished learnyouahaskell yet
17:11:30 <hpc> sec^nd: learnyouahaskell is top notch
17:11:31 <aristid> monochrom: a rather trivial language
17:11:41 <hpc> i strongly recommend getting further into that
17:11:42 <sec^nd> learnyouahaskell is a wee bit confusing too but seems good
17:11:55 <nyingen> what functions/modules/etc should I use to write a Read instance?
17:11:58 <hpc> if something confuses you, read on for a chapter or so, then go back
17:12:01 <dmwit> sec^nd: You can do get pretty far without learning Haskell by asking #xmonad to help you write your config. BUT, I do think Haskell is a nice language, so here are a few good tutorials:
17:12:05 <dmwit> ?where lyah
17:12:05 <lambdabot> http://www.learnyouahaskell.com/
17:12:06 <dmwit> ?where gentle
17:12:07 <lambdabot> http://www.haskell.org/tutorial/
17:12:09 <dmwit> ?where rwh
17:12:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:12:12 <ivanm> nyingen: any particular reason for not just deriving it?
17:12:18 <nyingen> I'm becoming rather confused among Text.Parse, Text.ParserCombinators.ReadP, Prelude.Read, etc
17:12:21 <monochrom> well I suspect the sublanguage you need for configuring xmonad is rather trivial too
17:12:23 <hpc> lyah takes a month or two to totally absorb
17:12:29 <ivanm> nyingen: if you have to write one by hand, using ReadP is easier than ReadS, but it's GHC-only
17:12:34 <nyingen> I see
17:12:43 <ivanm> ReadP is much closer to an actual parsec-like parser
17:12:43 <nyingen> do I have to do anything special for ReadP to work?
17:12:43 <hpc> @where wikibook
17:12:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:12:48 <monochrom> like, why would anyone need to "store a value somewhere" in a config file, even that of xmonad?
17:12:51 <ivanm> nyingen: import the correct module
17:12:55 <aristid> monochrom: possibly.
17:12:59 <nyingen> ivanm: cool
17:13:07 <nyingen> ivanm: ReadP did seem like the nicest way
17:13:11 <hpc> the wikibook is pretty much obsolete now; everything it has is now covered more effectively in other places
17:13:20 <hpc> and the unique stuff it does have is all stubs
17:13:24 <aristid> monochrom: i think using haskell as a configuration format is a stupid idea, actually
17:13:27 <ivanm> nyingen: there's another sub-one (ReadPrec or something?) that then converts to ReadP and is even nicer
17:13:30 <sec^nd> ok so what does <- mean again ?
17:13:40 <mauke> sec^nd: it's syntactic sugar for a call to >>=
17:13:50 <derdon> it means: point to sec^nd's name
17:13:59 <ivanm> sec^nd: if you just want to config xmonad, don't worry about it
17:14:10 <nyingen> ivanm: thanks, I'll check it out
17:14:12 <hpc> sec^nd: and if you are going through lyah, wait for it to teach you
17:14:13 <ivanm> just consider "<-" as "extract the value from the surrounding environment"
17:14:30 <hpc> the order of concepts in that tutorial is just about perfect
17:14:34 <sec^nd> derdon: so its like a pointer ?
17:14:48 <Rotaerk> no
17:14:50 <derdon> sec^nd: ignore me
17:14:56 <derdon> it was a rather bad joke
17:15:06 <sec^nd> -_-
17:15:21 <sec^nd> so what does >>= mean ?
17:15:30 <sec^nd> <_< whats up with all the weird symbols
17:15:30 <mauke> sec^nd: depends on which >>= it is
17:15:31 <hpc> sec^nd: just keep pushing through lyah
17:15:35 <aristid> >>= is just a function.
17:15:36 <mauke> sec^nd: it's overloaded
17:15:36 * sec^nd remembers when he learned perl :/
17:15:41 <hpc> sec^nd: it will teach you whenyou are good and ready
17:15:49 * sec^nd brainplodes
17:16:03 <ivanm> sec^nd: don't worry about it if you just want to configure xmonad
17:16:03 <hpc> (seriously guys, this is too many concepts for a newbie)
17:16:18 <mauke> what, operator overloading?
17:16:20 <aristid> hpc: well he did ask
17:16:21 <sec^nd> I want to understand whats going on too :P
17:16:28 <sec^nd> mauke: <_<
17:16:28 <dmwit> sec^nd: "m >>= f" means "do computation m, and feed the result of that computation to f"
17:16:34 <mauke> he said he came from C++
17:16:41 * sec^nd detects a disturbance in the force
17:16:41 <aristid> dmwit: except when it doesn't :)
17:16:42 <ivanm> "x <- f y" means something like "(f y) returns a value wrapped in some environment, and <- extracts the value out of the environment and puts it into x"
17:16:51 <sec^nd> dmwit: so its like a unix pipe
17:16:56 <dmwit> sec^nd: Very like!
17:17:06 <hpc> sec^nd: i can give a non-spammy expanation of (>>=) by pm, if you like
17:17:07 <ivanm> sec^nd: similar; (.) is closer to a pipe though
17:17:15 <mauke> dmwit: except it actually doesn't mean "do computation m"
17:17:19 <sec^nd> hpc: please do :)
17:17:30 * dmwit shrugs
17:17:30 <mauke> >>= constructs stuff
17:17:38 <aristid> ivanm: <=< might be also close to a pipe
17:17:41 <sec^nd> then why not use x = f y ?
17:17:49 <dmwit> First, you do a first-order explanation. Then, when the student is feeling Pretty Smart, you do the second-order approximation.
17:17:52 <sec^nd> -.-
17:17:56 <ivanm> sec^nd: because that just keeps x as the value within the environment
17:17:56 <dmwit> Before long, they know the Real Thing.
17:18:14 <sec^nd> so we have <- <-- <=< <<=  and what else now ?
17:18:15 <mauke> sec^nd: do you happen to know javascript?
17:18:26 <sec^nd> mauke: been a while but yes
17:18:29 <mauke> sec^nd: <- is syntax; the rest are library functions
17:18:33 <mauke> if they even exist
17:18:34 <dmwit> sec^nd: Of those, only "<-" is part of the language. The others are just functions defined in libraries.
17:18:46 <sec^nd> ahh
17:18:49 <aristid> sec^nd: well there's also &&& and *** and $ and . and $! and <<< and <$> and <*> and many more.
17:18:57 <Rotaerk> sec^nd, the value on the left of >>= is of a monadic type; what this means is that it can be thought of as something that contains values of some specific type T; the value on the right is a function that takes a T and returns a new value of the monadic type
17:18:57 <mauke> sec^nd: do you know async XMLHttpRequest?
17:19:00 <sec^nd> I remember learn you a haskell saying you could do that `dosomethign` etc
17:19:07 <dmwit> sec^nd: Any sequence of operator characters is a legal function name.
17:19:08 <derdon> aristid: oh :|
17:19:17 <dmwit> sec^nd: Yes, exactly.
17:19:17 <ivanm> dmwit: except --
17:19:25 <ivanm> and {- and -}
17:19:27 <ivanm> ;)
17:19:35 <dmwit> { is not an operator character
17:19:44 <sec^nd> kkk
17:19:45 <Rotaerk> sec^nd, >>= (abstractly) unpacks the values of type T from the value on the left, according to some policy, and can pass them to the function on the right, and returns the result of the application
17:19:49 <dmwit> But yes, there are exceptions for each piece of already-existing Haskell syntax.
17:20:08 <ivanm> dmwit: oh, right
17:20:27 * sec^nd goes back to reading lyah
17:20:28 <Rotaerk> sec^nd, but that's something you can get into much more detail later with..
17:20:52 <dmwit> Also, all these people talking about unpacking values are doing you a great disservice.
17:20:56 <dmwit> That's not what happens.
17:21:13 <Rotaerk> yes it is
17:21:15 <dmwit> Thinking that's what happens will hurt you, because eventually you'll ask how to unpack a value without passing it on to something else, and you can't do that.
17:21:18 <dmwit> No, it is not.
17:21:29 <mauke> Rotaerk: that's exactly what doesn't happen with IO
17:21:32 <dmwit> (>>=) packs up its second argument more; it does nothing to its first argument.
17:21:51 <vnb> hi
17:21:57 <c_wraith> It's what happens with algebraic types Maybe and Either.  It's not at all what happens with IO, ST, or things like STate
17:22:01 <c_wraith> err, *State
17:22:06 <sec^nd> k then 
17:22:13 <mauke> sec^nd: do you know async XMLHttpRequest?
17:22:17 <Rotaerk> the policy for unpacking the value from IO is to perform the IO and get the result
17:22:25 <mauke> Rotaerk: which is not what >>= does
17:22:43 <sec^nd> mauke: I used it once before been a long time
17:22:56 * sec^nd idles out
17:23:01 <mauke> well, that mindset would help here
17:23:01 <aristid> at no point is there an IO a -> a transformation, after all, so talking about unpacking is misleading
17:23:37 <Rotaerk> aristid, that transformation does occur, otherwise the a couldn't be passed into the function on the right of the >>=
17:23:39 <dmwit> Well, to be fair, we should make sure sec^nd's first name isn't Simon before we declare that there's no function of type IO a -> a. ;-)
17:23:43 <Rotaerk> it occurs within the bind
17:23:53 <aristid> Rotaerk: no it doesn't occur :)
17:23:58 <dmwit> Rotaerk: You are mistaken.
17:24:07 <Twey> Rotaerk: The value is never inside the IO.
17:24:19 <dmwit> Rotaerk: What happens in reality is that an IO a is passed in, and an IO (IO b) comes out the other end, and the IO (IO b) is then flattened to IO b.
17:24:31 <mauke> heh, nice "reality" you got there
17:24:39 <Twey> Haha
17:24:40 <dmwit> Rotaerk: But even that is not unpacking.
17:24:47 <dmwit> "reality"
17:24:48 <aristid> dmwit: is that how GHC implements bind on IO? in terms of join and fmap?
17:24:54 <dmwit> Almost certainly not.
17:24:59 <Twey> But it could be.
17:25:05 <dmwit> But it's closer to reality than implementing it in terms of unsafePerformIO.
17:25:12 <aristid> ah, there's reality
17:25:12 <aristid> and reality
17:25:18 <aristid> never confuse the two!
17:25:31 <hpc> it's implemented as 'type IO = State RealWorld#'
17:25:33 <hpc> more or less
17:25:43 <ion> I reject your reality and substitute my own.
17:25:49 <Twey> In reality the runtime performs magic and grabs values from the outside world according to the instructions provided by the LHS, then passes them into the function on the RHS
17:26:08 <hpc> RealWorld# is a some magic unboxed thingy that is extremely mutable
17:26:21 <hpc> and side effects all happen through that pointer
17:26:38 <Rotaerk> I don't get it, dmwit 
17:26:49 <Rotaerk> the function takes an a, not an IO a
17:26:55 <dmwit> That's true.
17:26:57 <mauke> Rotaerk: but you can upgrade functions
17:26:58 <Rotaerk> so the a has to be obtained from it somehow in order to be passed to it
17:27:04 <Rotaerk> oh I see
17:27:05 <mauke> a -> b ==> IO a -> IO b
17:27:07 <dmwit> But if "f :: a -> IO b", then "fmap f :: IO a -> IO (IO b)".
17:27:16 <Rotaerk> interesting
17:27:39 <hpc> Rotaerk: think of it as (=<<) :: (a -> IO b) -> (IO a -> IO b)
17:27:39 <Rotaerk> still I think that's an implementation detail and the unpacking metaphor works
17:27:45 <hpc> Rotaerk: like a pimped fmap
17:27:53 <dmwit> The unpacking metaphor does not work.
17:27:54 <dmwit> Watch:
17:27:56 <hpc> Rotaerk: lifting the first function so it has the type of the other
17:28:01 <mauke> Rotaerk: the bigger problem is that m >>= f doesn't call f
17:28:04 <dmwit> data Unit a = Unit -- note that there *is no a value*!
17:28:15 <hpc> Rotaerk: er, so it has the type of the right hand side
17:28:36 <aristid> dmwit: that's an evil monad
17:28:40 <dmwit> instance Monad Unit where return x = Unit; m >>= f = Unit
17:28:46 <Rotaerk> mauke, it doesn't? hrm, only in the same sense that "f a" doesn't call f
17:28:54 <dmwit> Rotaerk: No unpacking there anywhere.
17:28:57 <mauke> Rotaerk: wrong
17:29:01 <mauke> this is unrelated to laziness
17:29:07 <Rotaerk> ah
17:29:44 <dmwit> aristid: Is it? What's evil about it?
17:30:09 <mauke> dmwit: I think it breaks a law or two
17:30:23 <dmwit> Hm, maybe I should check the laws.
17:31:04 <dmwit> Oh, bottoms screw everything up.
17:31:34 <dmwit> return a >>= f = f a, but only when f a is non-bottom.
17:32:11 <ivanm> looks like the #haskell effect has happened again, and we've scared off sec^nd :p
17:32:13 <dmwit> Fine, here's an even worser one:
17:32:29 <aristid> dmwit: not calling f is legit i think
17:32:36 <Rotaerk> ah it just constructs a "bigger" monadic expression that is evaluated by the haskell runtime in the case of IO, pattern matching in the case of Maybe, etc
17:32:42 <dmwit> data Void a; instance Monad Void where return x = undefined; m >>= f = undefined
17:32:47 <aristid> instance Monad Unit where return x = Unit; m >>= f = m
17:32:57 <aristid> i think this should fix it
17:32:58 <mauke> aristid: type error
17:33:13 <c_wraith> you need to apply f
17:33:19 <aristid> ?
17:33:21 <c_wraith> so the phantom type comes out right
17:33:23 <aristid> oh.
17:33:44 <dmwit> c_wraith: You aiming that at me?
17:33:50 <c_wraith> no, aristid
17:34:09 <aristid> instance Monad Unit where return x = Unit; m >>= f = case m of Unit -> Unit
17:34:14 <dmwit> Anyway, Void looks like a perfectly good Monad, and it also doesn't do unpacking of any kind.
17:34:15 <aristid> better?
17:34:21 <dmwit> aristid: No.
17:34:30 <ion> m >>= f = *(typeof (f undefined) *)&m
17:34:30 <dmwit> aristid: return a >>= f /== f a
17:34:43 <aristid> dmwit: oh, right :)
17:34:46 <dmwit> aristid: (consider f _ = undefined)
17:35:12 <ion> I call this language Haskell++.
17:35:14 <c_wraith> m >>= f = f undefined
17:35:38 <mauke> heh
17:35:47 <Mathnerd314> ion: do you have a compiler for it?
17:36:09 <mauke> exercise: find an x such that 'const x' is a strict function
17:36:13 <dmwit> c_wraith: That doesn't satisfy (return a >>= f = f a) either.
17:36:35 <dafis> mauke: _|_
17:36:45 * ion cringes
17:36:59 <dmwit> c_wraith: (consider "f 0 = Unit")
17:37:54 <c_wraith> it works for all non-0 values of 0 :)
17:37:56 <c_wraith> err, of a
17:38:09 <mauke> "it works almost everyhwere"
17:38:58 <c_wraith> something working for all non-0 values of 0 wouldn't work too many places
17:39:23 <dylukes> c_wraith: it depends on how many non-0 values of 0 you have
18:23:07 <solrize> move.hs:2:8:
18:23:07 <solrize>     Could not find module `Text.ParserCombinators.Parsec':
18:23:07 <solrize>    my scripts are broken :(
18:23:42 <solrize> anyone know what causes that?
18:25:58 <luite> which parsec packages do you have installed?
18:26:54 <luite> Text.ParserCombinators.Parsec is parsec 2, but parsec-3.x still provides it for compatibility, parsec3-1.x doesn't
18:41:36 <Philippa> what's the usual trick if I need to define a Functor instance on a type variable that isn't the last parameter to a type constructor?
18:41:56 <Philippa> type synonym?
18:42:34 <napping> newtype?
18:42:59 <monochrom> try both
18:43:17 <napping> yeah, newtype will definitely work but a type synonym might be cleaner
18:43:35 <djahandarie> A type synonym shouldn't be allowed
18:43:39 <Philippa> don't want newtype
18:43:42 <Philippa> djahandarie: why not?
18:43:49 <djahandarie> It would mean you can partially apply types
18:43:56 <djahandarie> Which would give you a type lambda
18:44:02 <Philippa> no, it wouldn't
18:44:19 <Philippa> that only works if the type synonym doesn't fully apply the constructor: it's okay for me to do that
18:44:30 <Philippa> I'd just be using the synonym to re-order the parameters
18:44:45 <Philippa> permutation isn't a lambda :-)
18:44:52 <napping> but trying to match the partially applied synonym as the f :: * -> * in Functor
18:45:18 <djahandarie> Oh, okay, I see.
18:45:20 <Philippa> napping: sure, but that's a case where it's allowable
18:46:02 <napping> does it work?
18:46:09 <Philippa> *shrug* - gimme a mo to check
18:50:08 <Philippa> bah, it doesn't want to work
18:50:44 <napping> I think there's good reasons for that
18:51:05 <napping> what did you want the Functor instance for? Maybe you could make your own class?
18:51:45 <napping> about reasons, if you have instance Functor (Flip (,) a) and Functor ((,) a), fmap (
18:51:49 <dmwit> Do you have access to the data type? Can you rearrange the type itself?
18:52:06 <napping> fmap succ ('x','y') would seem to be ambiguous
18:52:51 <Philippa> yeah, I have a case in the ballpark of that ambiguity where I want to give the two maps different names
18:53:14 <Philippa> (and they don't always appear together)
18:53:21 <dmwit> newtype seems like the way to go, then
18:53:24 <dmwit> plus ala
18:53:28 <dmwit> =)
18:53:30 <djahandarie> ala!
18:54:00 <Philippa> I think the way to handle that's to start with a bifunctor-like instance and use that to make functor instances
18:54:23 <Philippa> the newtype solution annoys the hell out of me, one way or another
18:54:33 <dmwit> yes =(
18:54:42 <dmwit> The one thing about newtypes is that they're annoying. =(
18:55:28 <napping> How do you want the cases to be distinguished?
18:56:52 * napping . o (automagically!)
18:57:12 <Philippa> napping: by the name of the map operation I use
18:57:30 <Philippa> I'm in a specific enough context that doing that makes sense
18:57:36 <napping> um, then don't you want to *not* call one of them fmap?
18:57:37 <dmwit> Philippa: category-extras seems to define two kinds of Functors, so that might help.
18:58:16 <Philippa> napping: yeah, sorry if I've been confusingly ambiguous on that front. I don't want to call either fmap: both want to belong to typeclasses isomorphic to Functor
18:58:35 <Philippa> I want newclass, not newtype :-)
18:58:43 <solrize> luite, are you still there?  i just installed HP 2011.2 and all my scripts broke
18:58:51 <napping> Okay, so that helps
18:59:03 <Philippa> it's just that the initial problem is describable in terms of functor, that's all
18:59:10 <napping> and it's not like one will always operate on the second-to-last argument?
18:59:29 <Philippa> technically the case for now, but it'd be inelegant to force that
18:59:49 <luite> solrize: do a > ghc-pkg list in a command prompt/terminal to check which parsec version you have installed
18:59:57 <Philippa> in fact: no, already got one case where it doesn't apply
19:00:07 <napping> Well, if you are defining new classes, maybe you could do something with associated type synonyms
19:00:37 <monochrom> HP 2011.2 still has Text.ParserCombinators.Parsec etc
19:00:41 <solrize> luite, http://hpaste.org/45861/pkg_list
19:00:44 <brweber2> anyone have a second for a noob socket question?
19:00:52 <solrize> i also opened a trac bug about this since i had something like it happen before
19:00:56 <Philippa> I'm not sure how if I still can't make the instance itself legal, but hey
19:01:15 <luite> solrize: ah none at all, then cabal install parsec should do the trick
19:01:25 <solrize> parsec is supposed to be standard!
19:01:26 <luite> which should install parsec-3.1.1
19:01:26 <monochrom> but your ghc-pkg list doesn't even list any parsec, or most libs of HP 2011.2
19:01:27 <napping> I'm not entirely sure, but maybe something like using the newtype in the instance head, and having a fundep make the operation itself work on the plain version
19:01:36 <solrize> installing
19:02:01 <monochrom> if you just installed HP and still get this, you should be really worried
19:02:01 <luite> monochrom: as long as cabal-install works, who cares :p
19:02:41 <napping> brweber2: seem to. I haven't seen another since I logged in
19:02:41 <monochrom> the problem is if this is just the tip of an iceberg, cabal-install won't work for long
19:02:49 <Philippa> napping: ew
19:02:58 <Philippa> I'll put up with the bifunctor solution, I think
19:03:12 <napping> I think something will end up slightly unpleasant
19:03:13 <brweber2> napping I'm looking at http://www.catonmat.net/blog/simple-haskell-tcp-server and my question is pretty simple
19:03:15 <solrize> monochrom, yeah, a whole lot of libs are broken
19:03:18 <monochrom> there is 0.1% probability the hard disk is write-protected
19:03:35 <solrize> no the install worked sort of
19:03:42 <brweber2> napping when you listen on a socket, accept a connection and ForkIO, do you have to explicitly close the socket?  I don't see it in the example....
19:03:54 <dmwit> Philippa: So, uh, by the way: do you definitely want a class and not just two functions?
19:03:54 <napping> hmm, you probably should close it eventually
19:03:59 <luite> solrize: does ghc-pkg check report anything?
19:04:13 <napping> both sockets eventually, that is
19:04:51 <solrize> luite, nope
19:05:39 <napping> It's probably fine not to close the server socket (or whatever the once you accept on is supposed to be called)
19:05:40 <luite> solrize: hmm, then you might be ok if you install everything you need with cabal install
19:05:47 <BobFunk> trying to wrap my head around enumerators, iteratees and builders
19:06:00 <luite> but it's not haskell platform :)
19:06:10 <solrize> i shouldn't have to do that... that's the whole idea of HP, to get all the basic stuff in one download
19:06:30 <BobFunk> basically I would like to somehow stream the upload body of a file upload to Snap into the http request body enumerator of a http-enumerator
19:06:44 <BobFunk> but really having a hard time figuring out where to get started 
19:06:58 <BobFunk> or figuring out if it's even possible :)
19:07:01 <napping> brweber2: Do you know how sockets work in general?
19:07:04 <luite> solrize: was hp installed correctly, did you use the right compiler for it?
19:07:09 <napping> The client connection should probably be closed
19:07:33 <brweber2> napping fairly familiar ... yes
19:07:53 <solrize> luite, i did the binary install
19:07:55 <brweber2> napping for example, in this case I would expect to close the socket for reading and writing ... 
19:08:07 <napping> Yeah, you should probably close it when you are done
19:08:32 <napping> You can see this might leak an fd each client
19:08:43 <solrize> hmm
19:09:06 <luite> solrize: oh I thought there was only a source installer for linux
19:09:09 <solrize> maybe my path was set up wrong
19:09:24 <monochrom> no one else closes the client connection. this is independent of how many forkIO's you do
19:09:33 <luite> if you used a distribution package, then you shouldn't use the ghc in /usr/local :)
19:09:37 <napping> It might be kind of hard to break - the worker thread will probably take an exception on hGetLine
19:09:51 <napping> and then the handle *might* be garbage collected before you run out of fds
19:09:56 <napping> but it's not good to rely on that
19:10:09 <napping> easy enough to start the client as
19:10:09 <monochrom> wrap a "finally" around that
19:10:19 <napping> forkIO $ commandProcessor handle `finally` hClose handle
19:10:48 <solrize> luite, it's weird, there's a 6.12.3 and a 7.0.3 there in /usr/local
19:10:58 <napping> then you'll be fine until you have enough live connections to actually run out of fds :)
19:11:37 <luite> solrize: you know that you need to do two installs, right? first ghc, then haskell platform
19:11:51 <solrize> ??  i thought only one 
19:11:52 <lambdabot>  i thought only one
19:12:03 <monochrom> ?? eh?!
19:12:03 <lambdabot> Plugin `compose' failed with: Unknown command: "!"
19:12:09 <monochrom> hrm!
19:12:13 <napping> brweber2: It looks like it's just the shoddy error handling you usually see in examples
19:12:47 <brweber2> napping that is what I was afraid of... do you happen to know of a better example?  
19:12:48 <confound> anyone know offhand if I'm missing something here: pandoc -t s5 -s is giving me a complete html file that refers to the s5 javascript using external links rather than inlining it
19:13:51 <monochrom> actually adding `finally` hClose handle  is pretty enough to fix shoddy examples
19:14:12 <solrize> i took my home dir .cabal out of my path so now it seems to find the ghc libs
19:14:19 <solrize> but i have to reinstall all the hackage stuff
19:14:25 <napping> I don't know of any tutorials, but finally should get you pretty far
19:14:58 <ozataman> Hey all. Having some trouble with curl not immediately writing to a cookie jar file after downloading the remote page. any ideas on what would be the best way to force that evaluation?
19:15:15 <brweber2> napping thanks... I'll def do the finally, I was just hoping to find a complete example :)  that one looked decent compared to most
19:15:25 <confound> ah, I found --offline
19:15:28 <napping> hmm, you could look at the hws code
19:15:59 <napping> also, look at docs for System.IO, and it describes how hGetLine behaves
19:16:17 <napping> so it should reliably raise an exception once you are totaly out of data
19:17:49 <napping> about the only thing it would miss is if the other side closes just the read end, and then sits there sending no more data
19:17:59 <napping> I don't remember if you can even test for that
19:19:08 <monochrom> if server tries to write to that, there is a chance of "broken pipe" exception. if furthermore you have the "finally", everyone's happy.
19:19:28 <monochrom> however, this server certainly doesn't proactively try to write
19:19:50 <napping> basically, add the `finally` hClose handle, and it should be reasonably solid
19:20:00 <monochrom> so, just call it a DoS by a malicious client, and go to bed :)
19:20:55 <monochrom> it's equivalent to you ssh'ing to somewhere and then decide to be idle forever
19:21:46 <monochrom> real server code adds a clock to measure idle time and kick people
19:22:23 <monochrom> irc servers proactively send you a ping, and expect a pong reply within limits, or else kick kick
19:42:35 * hackagebot newtype 0.2 - A typeclass and set of functions for working with newtypes.  http://hackage.haskell.org/package/newtype-0.2 (DariusJahandarie)
19:42:42 <djahandarie> Holy smokes! Look at that ;)
19:43:13 <ion> What’s new?
19:43:29 <djahandarie> Three functions: over, underF, overF
19:43:38 <djahandarie> (Also an instance that I forgot somehow)
19:43:46 <djahandarie> over :: (Newtype n o, Newtype n' o') => (o -> n) -> (o -> o') -> (n -> n')
19:44:07 <djahandarie> Just switches a function on the underlying types to one on the newtypes
19:44:13 <dafis> dolio: ping
19:44:19 <djahandarie> underF and overF are under and over lifted into Functors
19:44:23 <djahandarie> underF :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> (f o -> f o')
19:44:24 <dolio> pong
19:44:38 <ion> Alright
19:44:48 <ion> What instance was missing?
19:44:53 <dafis> dolio: I think you have a bug in your vector-algorithms sorting stuff
19:44:56 <djahandarie> That's a good question, I forgot already :p
19:45:01 <djahandarie> Fixed it awhile back
19:45:10 <dolio> dafis: It's certainly possible.
19:45:10 <djahandarie> I think it was Kleisli
19:45:23 <ion> aye
19:45:38 <dafis> dolio: before sorting, there were no NaNs in the vectors, after, there were
19:46:08 <dolio> Huh. Well, that's certainly weird.
19:46:11 <dafis> I think you're overstepping the array bounds somewhere
19:46:22 <dolio> Which algorithm?
19:46:45 <dafis> wait a sec, Intro
19:47:03 <djahandarie> (vector-algorithms is pretty cool, btw)
19:47:06 <dafis> it's used in the statistics package
19:47:23 <dafis> djahandarie: yes
19:49:12 <dafis> dolio: unfortunately introsort uses all the others, looking at them, heapSort is the one I find suspicious
19:50:10 <djahandarie> Next thing I'm going to do with the newtype package is hopefully try and provide instances for other packages
19:50:16 <dolio> dafis: Okay. If you manage to cause it to happen with just heap sort, let me know (if you feel like testing).
19:50:17 <djahandarie> It feels really ugly having non-base dependencies though
19:50:27 <djahandarie> But it's also ugly to have an orphans package/module :p
19:50:49 <dafis> dolio: will take a bit, hang on
19:52:13 <djahandarie> Maybe if I rally people into using my library I can get it put into base
19:53:05 <dolio> dafis: I'll try to investigate and fix it, but I'm a little out of my element for the time being.
19:53:45 <dafis> dolio: okay, so far no (bad) luck with heap sort, I'll check the others again
19:54:26 <djahandarie> dolio, are you still trapped in wharrgarbl's cupboard?
19:54:50 <dolio> It may be the intro algorithm itself. It only goes to heap sort on sufficiently pathological inputs.
19:54:57 <dolio> djahandarie: Yes.
19:55:17 <magicman> ?pl \l a -> all ($a) l
19:55:17 <lambdabot> flip (all . flip id)
19:55:23 <djahandarie> dolio, you'll be saved one day.
19:55:32 <magicman> ?type \l a -> all ($a) l
19:55:33 <lambdabot> forall a. [a -> Bool] -> a -> Bool
19:55:35 <dolio> djahandarie: I forgot to pack my RSA private key, too, so I won't be able to log into code.haskell.org for a while, too.
19:55:46 <dolio> Although I guess I can put packages on Hackage without it.
19:58:58 <djahandarie> We should have another Boston Haskell
20:00:14 <djahandarie> Or just rename it to Boston Category Theory
20:00:28 <dolio> I think Ed mentioned that he was going to set one up in not too long.
20:00:40 <dolio> And spend the entire time talking about breaking up category-extras.
20:00:45 <djahandarie> Haha
20:00:48 <djahandarie> Sounds like a good time
20:00:56 <dolio> I think he was serious, too.
20:02:38 <brweber2> anyone have a second to help me re-factor a function?  should be pretty simple.... 
20:02:49 <djahandarie> Sure
20:02:52 <djahandarie> hpaste if long
20:03:15 <brweber2> djahandarie how many lines is long?  it is 10 lines
20:03:26 <djahandarie> Yeah, that's definitely long enough. http://hpaste.org
20:04:16 <brweber2> djahandarie #45863
20:04:33 <brweber2> djanharndarie http://hpaste.org/45863/readuntilendtoken
20:04:34 <djahandarie> (Normally people paste the URL :p)
20:04:41 <djahandarie> Hah, spoke too soon
20:04:48 <brweber2> sorry, I thought was grabbing the url... 
20:04:53 <brweber2> so my question is really simlpe
20:04:57 <brweber2> simple... 
20:05:03 <brweber2> the return type of the then and else are different
20:05:10 <brweber2> one is String and one is IO (String) 
20:05:26 <brweber2> I get that... but I'm not sure what the proper way to "fix" that is
20:05:37 <djahandarie> :t return :: a -> IO a
20:05:37 <lambdabot> forall a. a -> IO a
20:05:56 <djahandarie> "return" takes a value and lifts it into IO
20:06:30 <brweber2> djanhandarie thanks... I knew that there was something simple I was missing...
20:10:47 <BMeph> Welcome to Haskell, where "long" functions are those longer than two lines! :)
20:11:46 <dafis> dolio: switching back to introsort, immediately NaNs again, I'll investigate further
20:17:35 <brweber2> BMeph hehe, my haskell functions tend to be long b/c I'm a noob and I still use putStrLn way too much as I'm learning :)
20:17:51 <brweber2> djanhandarie got a second for one more question?
20:17:58 <djahandarie> Sure
20:18:01 <brweber2> I have this line (rc, out, err) <- readProcessWithExitCode cmd args ""
20:18:12 <brweber2>     Couldn't match expected type `IO
20:18:13 <djahandarie> You can type "dja" then hit tab to avoid typing my whole nick, btw :p
20:18:13 <brweber2>                                     (GHC.IO.Exception.ExitCode, String, String)'
20:18:13 <brweber2>            against inferred type `[(GHC.IO.Exception.ExitCode,
20:18:13 <brweber2>                                     String,
20:18:13 <brweber2>                                     String)]'
20:18:17 <djahandarie> Whoa whoa whoa
20:18:21 <brweber2> djahandarie: phew
20:18:30 <brweber2> djahandarie thanks :)
20:18:45 <djahandarie> In general avoid pasting more than 2 lines in the channel if you can
20:19:33 <brweber2> djahandarie: ok
20:20:02 <dolio> dafis: I think I see the bug.
20:20:24 <dolio> Wait, never mind.
20:21:05 <dafis> dolio: What isn't the bug?
20:21:18 <djahandarie> brweber2, where are you getting that function from
20:21:34 <brweber2> djahandarie: import System.Process (readProcessWithExitCode)
20:22:03 <dolio> dafis: I thought maybe I should be passing (u-1) to the partition function instead of u, but it takes care of that.
20:22:36 <dafis> dolio: yes, I stumbled on that too and saw it was correct
20:22:47 <brweber2> djahandarie: http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3AreadProcessWithExitCode
20:23:16 <djahandarie> brweber2, it should be working, show me your entire code
20:23:48 <djahandarie> You might accidently be using the 'wrong' do notation
20:24:09 <brweber2> djahandarie: ok, one second as I paste to hpaste
20:24:46 <brweber2> djahandarie: http://hpaste.org/45866/launchprogram
20:25:10 <djahandarie> brweber2, yeah
20:25:29 <djahandarie> See how your last line has the type of a list
20:25:36 <djahandarie> That is making it really confused
20:25:43 <djahandarie> (Since do notation can also be used for lists and other things)
20:26:07 <djahandarie> What you want is to have your last line have type of IO.
20:26:15 <djahandarie> So use return, and fix your type signature
20:28:43 <brweber2> djahandarie: voila!  thank you
20:28:47 <djahandarie> :)
20:31:21 <brweber2> djahandarie: compiles just fine... segfaults, but compiles just fine ;)
20:32:01 <djahandarie> Segfaults? That's particularly strange.
20:32:21 <dolio> dafis: How many NaNs are we talking about, by the way?
20:32:21 <djahandarie> hpaste the entire file so I can see if I can reproduce it.
20:32:40 <brweber2> djahandarie: sure, one second
20:32:55 <dolio> dafis: Per sorted aray.
20:33:39 <brweber2> djahandarie: http://hpaste.org/45867/dbfe
20:34:12 <dafis> dolio: that changes, something about 80 for a 1000 element array (60-100), for a 10000 elment array I got 725
20:34:28 <dolio> Okay.
20:34:31 <dafis> 741 just now
20:34:45 <dolio> I think that means it's not an insertion sort bug, then.
20:34:53 <dolio> If it were 1 it'd be suspicious.
20:35:03 <brweber2> wow, hpaste is great for finding errors :)
20:35:18 <dafis> dolio: I suspect the fact that almost all elements are nearly equal might have something to do with it
20:35:50 <djahandarie> brweber2, 'cabal install hlint' :)
20:35:57 <djahandarie> I'll brb then see if I can make this segfault
20:38:48 <brweber2> djahandarie: if it helps... ghc version 6.12.3
20:46:42 <dolio> dafis: I may be on to something.
20:47:23 <dafis> Oh, where?
20:47:40 <dolio> dafis: I think if partUp walks all the way up to u on the first try, there's a problem.
20:48:37 <dolio> Well...
20:49:01 <djahandarie> brweber2, how are you running it?
20:49:08 <djahandarie> And does it segfault the second you start it?
20:49:25 <brweber2> ghci> :l dbfe
20:49:36 <brweber2> ghci> listenForConnections 8889
20:49:54 <brweber2> djahandarie: I'll paste exactly what I see
20:50:01 <djahandarie> That works fine for me
20:50:10 <djahandarie> 6.12.1, Linux
20:50:41 <brweber2> djahandarie: http://hpaste.org/45868/segfault
20:50:53 <brweber2> djahandarie: I'm on snow leopard
20:51:38 <djahandarie> It could be a mac issue. It'll be pretty hard for me to trace it down to anything without being able to reproduce it though
20:51:42 <dafis> dolio: yes, then it calls sort _ l u again and does the same trick, until the recursion depth is exceeded
20:52:08 <brweber2> djahandarie: understood... thanks for all your help... I'm off to bed.  I'll look at it more tomorrow and I'll try to figure it out
20:52:11 <dolio> dafis: Nah, I think I'm wrong. It doesn't do any bad swaps.
20:52:24 <djahandarie> brweber2, yep, np. If you manage to narrow it down to something let me know
20:52:33 <brweber2> djahandarie: will do
20:52:37 <dafis> dolio: and the it's off to insertion sort, which looks fine
20:54:46 <Mathnerd314> why doesn't GHC use lambda calculus as one of its compiling stages?
20:55:07 <Philippa> has anyone written a general prettyprinter for Haskell values as spat out by deriving Show?
20:55:15 <Philippa> that is, one that's actually pretty and uses layout sensibly?
20:59:58 <djahandarie> Mathnerd314, I don't know the details at all, but the problem I see is that the lambda calculus fails to talk about operational semantics. I figure you could somehow extend it minimally to make it do that, but I don't think the end result would be able to talk about all the stuff GHC does in a useful manner
21:00:50 <jmcarthur> Mathnerd314: the lambda calculus is behind every stage down to stg in some sense
21:01:08 <jmcarthur> it's just extended a lo
21:01:09 <djahandarie> Only in the sense that they aren't imperative, imo
21:01:10 <jmcarthur> *lot
21:02:06 <dolio> dafis: Well, I can't see anything wrong right now.
21:02:29 <Kaidelong> I suppose you could use a kind of lambda calculus to look at haskell
21:02:44 <Kaidelong> and perhaps the STG machine is a kind of lambda calculus
21:02:47 <jmcarthur> haskell is a *kind* of lambda calculus
21:03:01 <djahandarie> And I imagine the optimization passes exploit far more than just the LC rules, so it wouldn't be particularly useful to cast things in that way either
21:03:04 <jmcarthur> i'd say core is closer than stg
21:03:09 <dafis> dolio: nor I, but the fact remains, no NaNs befor, NaNs after, I'm stumped
21:03:19 <dafis> *before
21:03:32 <Kaidelong> either way you can probably argue in some way or another that GHC does use a kind of lambda calculus
21:03:33 <dolio> dafis: I may be able to actually run programs tomorrow at work. That would help.
21:03:41 <jmcarthur> yes
21:04:24 <accel> http://ddiaz.asofilak.es/packages/HaTeX/ <-- is this any good for using Haskell as a LaTeX macro language?
21:04:40 <dolio> I can't remember if vector has a 'bounds check everything' flag, but that would at least indicate if that is in fact the problem.
21:05:19 <dolio> Not that I can think of anything else that would introduce NaNs, since it's just copying things around.
21:05:39 <Kaidelong> judging by thatpackage the point seems more to be to output latex from some other representation
21:05:48 <Kaidelong> but I imagine you could do that
21:06:13 <Kaidelong> err, well trivially you could
21:07:21 <Kaidelong> well if you have a parser
21:07:22 * hackagebot dimensional 0.9 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.9 (BjornBuckwalter)
21:07:30 <dafis> dolio: I'll build me a vector-algorithms with unsafeRead and unsafeWrite replaced by read/write, that should narrow it down
21:08:00 <dolio> dafis: You should check if there's a flag for bounds checking even on unsafeRead/Write.
21:08:07 <dolio> I think there is.
21:08:31 <dafis> dolio: that would be simpler, of course
21:34:26 * hackagebot OpenGLRaw21 1.2.0.0 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-1.2.0.0 (JakeMcArthur)
21:40:35 <dafis> dcoutts_: if the hackage cron-job for building and haddocking died, would you know about that?
21:41:18 <dcoutts_> dafis: sadly no, I don't have access to the box. It lives under Ross's desk.
21:58:22 <yulys_> guys, a little question... if haskell is stally typed, what happend if I use the system type inference a lot... I think there is a lot of bugs in consecuence
22:01:44 <Axman6> yulys_: huh?
22:06:22 <Cale> yulys_: Type signatures that you leave out are inferred and still checked as usual. Type signatures that you choose to put in are checked against the inferred types, and may restrict polymorphism.
22:08:15 <Cale> yulys_: It's possible for the inferred type of something to be different from the type you intended, but usually it doesn't get so far beyond that, since when you make use of that definition the types will have to match up again. A program which typechecks will often do something reasonable, even if it's not what you intended.
22:08:21 <yulys_> Cale: Thank for your response.... there is any place where I can see how the memory or the system inferred type function?... I mean in hardware
22:08:43 <mauke> types in hardware? what
22:08:55 <Cale> You can ask ghci for the inferred types of things using :t <expression>
22:09:13 <Cale> :t length
22:09:14 <yulys_> Cale: Ok Cale, anyway thank a lot!
22:09:14 <lambdabot> forall a. [a] -> Int
22:15:04 * dafis hates Heisenbugs
22:22:19 <ddarius> What the hell?  Core -is- a lambda calculus.  It's System Fc which is just System F (a.k.a. the polymorphic lambda calculus) with equality constraint types.
22:22:56 <monochrom> what the heaven
22:24:17 <yulys_> Cale: I know that the type is getting by the command :t <expression>, but I want to the algorithm, I am doing a research of hasekll comparing with C or Java
22:24:36 <Cale> yulys_: Well...
22:24:41 <yulys_> jeje
22:25:17 <monochrom> there was a Robin Milner paper containing an algorithm
22:25:32 <monochrom> subsequently there have been textbooks
22:25:34 <Cale> There's a large recent paper by Simon Peyton Jones
22:25:43 <Cale> about the typechecker now used in GHC
22:25:52 <Cale> It's not exactly simple
22:25:58 <Pseudonym> Yeah, we're a bit past Damas-Milner.
22:26:07 <ddarius> Also, lambda calculus has come with an operational semantics since its inception and those rules (obviously with the "delta rules" for the various "primitive" types) are behind all of the optimizations at the Core level and above.
22:26:09 <djahandarie> ddarius, but a lot of the interesting passes on Core entirely revolve around how cases are strict and cause evaluation, don't they? I don't know how beneficial it is to talk about it as a lambda calculus
22:26:13 <Pseudonym> But "Typing Haskell in Haskell" gets you most of the way there.
22:26:15 <djahandarie> Ah.
22:26:20 <Cale> But there exist really easy typecheckershttp://haskell.org/haskellwiki/Simonpj/Talk:OutsideIn
22:26:24 <djahandarie> Sent that message a second too soon
22:26:25 <Cale> er, oops
22:26:29 <Cale> meant to put a newline there
22:26:34 <ddarius> djahandarie: The original lambda calculus was untyped and call-by-name.
22:26:36 <monochrom> well, I would read the old paper first for its less complexity, then the recent one for all the new additions
22:26:39 <Cale> http://haskell.org/haskellwiki/Simonpj/Talk:OutsideIn is the link to the recent research :)
22:27:32 <Cale> If you're interested in type systems, you should check out "Types and Programming Languages" by Pierce
22:27:59 <mathijs> Hi all, because I've been using Haskell for some time now (as a hobby), I notice I start to use ideas and concepts in my main language, which is great (immutability, monoids). However, one thing I'm not sure how to "translate" are Algebraic types like "data Filter = Address String | Location Int Int | Unknown"
22:28:20 <Pseudonym> mathijs: Into what language?
22:28:30 <Pseudonym> You can think of them as variant records.
22:28:48 <Pseudonym> Your second-favourite language may have the concept already, or may have an idiom.
22:28:55 <jmcarthur> mathijs: in C i would write that as a tagged union
22:28:58 <mathijs> in an OOP language, should I map this structure to 1 class, having 3 constructors (or the values), or make separate classes for each value and have them extend some abstract parent class
22:29:03 <mathijs> Pseudonym: Ruby
22:29:14 <Pseudonym> In C++, I'd use the Boost.Variant library.
22:29:23 <jmcarthur> hmm ruby...
22:29:28 <Pseudonym> Right. mathijs' suggestion is probably best.
22:29:40 <ddarius> There's a "standard" way to translate algebraic data types to an object-oriented language.
22:29:58 <Pseudonym> What you lose is pattern matching.
22:30:12 <Pseudonym> Visitors are sometimes good enough.
22:30:13 <monochrom> mathijs: I invite you to my joke at http://www.vex.net/~trebla/humour/Nightmare.java
22:30:22 <ddarius> Pseudonym: What you gain is exactly the extensibility problems that FP has with respect to OOP.
22:30:31 <Pseudonym> Yup.
22:31:12 <djahandarie> monochrom, what in the hell
22:31:17 <mathijs> Pseudonym: I don't have pattern matching anyway
22:31:23 <monochrom> hehehehe!
22:32:17 <mathijs> monochrom: I always learned that exceptions are slow in java :)
22:32:56 <monochrom> yes, we speak in terms of "if you can get java to be within half as fast as haskell you're great"
22:32:57 <mathijs> monochrom: but ruby is somewhat more FP friendly. It supports immutability and closures.
22:33:05 <ddarius> mathijs: The point of that wasn't speed, it was to get a "pattern matching"-like syntax.
22:33:14 <mathijs> ddarius: I understand
22:34:41 <mathijs> ddarius: you mentioned there's a standard way to do this. What's that standard way?
22:34:51 <djahandarie> Suffer
22:36:10 <mathijs> My 2 guesses would be to have classes for all values with an abstract parent class to unify them somewhat, or to have 1 class with a constructor per value.
22:36:30 <mathijs> I don't know if any of the 2 is "better" though
22:40:05 <ddarius> abstract class List<A> { public abstract B Fold<B>(B nil, Func<A,B,B> cons); }; sealed class Nil<A> : List<A> { public Nil() {}; public override B Fold<B>(B nil, Func<A,B,B> cons) { return nil; } }; sealed class Cons<A> : List<A> { private readonly A head; private readonly List<A> tail; public Cons(A h, List<A> t) { head = h; tail = t; }; public override B Fold<B>(B nil, Func<A,B,B> cons) { return cons(head, tail.Fold(
22:40:05 <ddarius> nil, cons)); } }
22:40:23 <ddarius> Of course you could use something more like a Scott-encoding rather than a Church-encoding.
22:40:57 <djahandarie> That isn't Java ;P
22:41:06 <ddarius> Note that, for example, this is -exactly- the scheme used in Smalltalk for booleans.
22:41:13 <ddarius> djahandarie: It's C#.
22:41:19 <djahandarie> I know
22:42:53 <ddarius> Also, you could collect the algebra (nil, cons) together into a "Visitor" object if you want.
22:43:33 <mathijs> ddarius: I'm reading about the visitor pattern now... it might indeed be good.
22:43:36 <ddarius> Obviously this particular definition of Fold isn't appropriate for an eager language. 
22:45:57 <ddarius> mathijs: Note that this imports most of the problems of FP (though it's not necessarily a bad thing.)  While I can add a new "constructor" it has to "look like" a bunch of conses and a nil.
22:46:54 <mathijs> ddarius: I don't think those are problems in my case. I don't need that many dynamic constructs.
22:47:00 <ddarius> I.e. I can't make it into a tree (as seen from the outside) by adding a subclass with Branch(List<A> left, List<A> right).
22:48:26 <ddarius> For List<A> that's pretty sensible, but for AST it's annoying.
22:52:15 <ddarius> Hmm, I wonder if you can do algebraic geometry with data types...
22:52:30 <ddarius> You'd probably need species at least for non-trivial varieties.
22:53:15 <DrSyzygy> ddarius: Species seems to be pretty much the same as Functor tho'...
22:53:34 <DrSyzygy> Or at least kinda similar.
22:56:08 <ddarius> DrSyzygy: That statement doesn't make much sense to me.
22:56:22 <ddarius> Or perhaps I should say the logic behind it doesn't.
23:05:46 <koninkje> @tell copumpkin Hee hee
23:05:46 <lambdabot> Consider it noted.
23:07:49 <lispy> Has anyone else noticed the really strange messages from KC and caseyh on the Haskell mailing lists?  They seem to just be snippets from books with no other content in the messages
23:07:55 <koninkje> @tell copumpkin I'm not sure which post of mine you found to know whether I've thought more since then
23:07:55 <lambdabot> Consider it noted.
23:08:07 <lispy> and KC and caseyh have sent the same exact messages
23:08:12 <lispy> One of them as the subject, "Adjoint Folds and Unfolds Or: Scything through the Thicket of Morphisms"
23:11:11 <koninkje> Does anyone have a clean and fast way of doing: let xs = take n ys in (xs, last xs)
23:11:12 <lambdabot> koninkje: You have 1 new message. '/msg lambdabot @messages' to read it.
23:11:33 <koninkje> i.e., without traversing the list twice?
23:13:01 <RayNbow`TU> :t splitAt
23:13:02 <lambdabot> forall a. Int -> [a] -> ([a], [a])
23:13:34 <dmwit> koninkje: Roll it by hand.
23:13:53 <RayNbow`TU> :t \n ys -> let (xs,xs') = splitAt n ys in (xs, last ys)
23:13:53 <lambdabot> forall a. Int -> [a] -> ([a], a)
23:14:01 <koninkje> dmwit: yeah, I was thinking of that, though GHC.List has some crazy optimization shenanigans
23:14:02 <RayNbow`TU> erm
23:14:07 <RayNbow`TU> :t \n ys -> let (xs,xs') = splitAt n ys in (xs, last xs')
23:14:07 <lambdabot> forall a. Int -> [a] -> ([a], a)
23:14:27 * koninkje might as well...
23:14:28 <dmwit> RayNbow`TU: You're taking the last element from the wrong list.
23:14:50 <RayNbow`TU> ah right
23:14:58 <RayNbow`TU> hmm
23:15:11 <Axman6> let foo 0 [x] = ([],x); foo 0 (x:xs) = foo 0 xs; foo n (x:xs) = let ~(ys,z) = foo (n-1) xs in (x:ys,z) in foo 5 [1..10]
23:15:22 <Axman6> > let foo 0 [x] = ([],x); foo 0 (x:xs) = foo 0 xs; foo n (x:xs) = let ~(ys,z) = foo (n-1) xs in (x:ys,z) in foo 5 [1..10]
23:15:23 <lambdabot>   ([1,2,3,4,5],10)
23:15:31 <Axman6> > let foo 0 [x] = ([],x); foo 0 (x:xs) = foo 0 xs; foo n (x:xs) = let ~(ys,z) = foo (n-1) xs in (x:ys,z) in foo 12 [1..10]
23:15:32 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10*Exception: <interactive>:3:4-101: Non-exhaustive pat...
23:15:41 <dmwit> I'm confident koninkje is clever enough to write this by hand himself.
23:15:52 <Axman6> needs another case i think
23:15:57 <koninkje> yes, but koninkje is lazy
23:16:34 <RayNbow`TU> kings are always lazy... they rule over the people to do work for them :p
23:19:05 <dmwit> :t foldr
23:19:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:19:27 <dmwit> :t foldr (\x (_, xs) -> (x, x:xs))
23:19:28 <lambdabot> forall a. (a, [a]) -> [a] -> (a, [a])
23:19:50 <dafis> lispy: I noticed, I wasn't sure if it was trolling or what
23:19:56 <dmwit> :t \n -> foldr (\x (_, xs) -> (x, x:xs)) (error "you dun mucked up", []) . take n
23:19:57 <lambdabot> forall a. Int -> [a] -> (a, [a])
23:20:02 <dmwit> koninkje: Good enough?
23:20:11 <dmwit> Two passes, but fusion should make it one.
23:20:41 <dmwit> > foldr (\x (_, xs) -> (x, x:xs)) (undefined, []) [1,2,3]
23:20:42 <lambdabot>   (1,[1,2,3])
23:20:45 <dmwit> whoops
23:20:58 <lispy> dafis: it looks like someone is mistaking the mail list for a place to store their personal notes while they learn Haskell
23:21:11 <dmwit> Ah, yeah, that can't work.
23:21:26 <dafis> lispy: for that, one post would be enough
23:21:43 <ion> URL?
23:21:57 <lispy> dafis: true. They are posted in stereo, and there are several posts like this.  See for example the Ralf Hinze quote
23:22:10 <lispy> ion: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/88196
23:22:17 <dmwit> > foldr (\x (y, xs) -> (y `mappend` First (Just x), x:xs)) (First Nothing, []) [1,2,3]
23:22:18 <ion> Thanks
23:22:19 <lambdabot>   (First {getFirst = Just 3},[1,2,3])
23:22:40 <ion> heh
23:23:00 <dmwit> > mconcat . map (\x -> (Last (Just x), x)) $ [1,2,3]
23:23:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:23:01 <lambdabot>    `GHC.Num.Num a'
23:23:02 <lambdabot>      ari...
23:24:16 <dmwit> > foldr (\x (y, xs) -> (Last (Just x) `mappend` y, x:xs)) (Last Nothing, []) [1,2,3] -- just seems cleaner for some reason
23:24:17 <lambdabot>   (Last {getLast = Just 3},[1,2,3])
23:25:07 <dmwit> > foldr (\x (y, xs) -> (Last (Just x) `mappend` y, [x] `mappend` xs)) (mempty, mempty) [1,2,3]
23:25:09 <lambdabot>   (Last {getLast = Just 3},[1,2,3])
23:25:35 <dmwit> Boy, that pattern looks exploitable.
23:25:54 <dmwit> > return 3 :: Last (Maybe Int)
23:25:56 <lambdabot>   No instance for (GHC.Base.Monad Data.Monoid.Last)
23:25:56 <lambdabot>    arising from a use of ...
23:26:57 <dmwit> > (Last (Just 3), [3]) `mappend` (Last Nothing, [])
23:26:58 <lambdabot>   (Last {getLast = Just 3},[3])
23:27:27 <dmwit> > foldr (\x -> mappend (Last (Just x), [x])) mempty [1,2,3]
23:27:28 <lambdabot>   (Last {getLast = Just 3},[1,2,3])
23:27:46 <lispy> :t Last
23:27:47 <lambdabot> forall a. Maybe a -> Last a
23:27:55 <dmwit> ?src Last
23:27:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:28:09 <dmwit> newtype Last a = Last { getLast :: Maybe a }
23:28:11 <lispy> ?hoogle Last
23:28:11 <lambdabot> Data.Monoid newtype Last a
23:28:12 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
23:28:12 <lambdabot> Prelude last :: [a] -> a
23:28:33 <lispy> > last [1..10]
23:28:34 <lambdabot>   10
23:28:48 <dmwit> The interesting bit is instance Monoid (Last a) where mempty = Nothing; (Just x) `mappend` (Just y) = Just y
23:29:05 <lispy> > head &&& last $ [1..10]
23:29:06 <lambdabot>   (1,10)
23:29:17 <rothwell> erm... silly question, but how do i get a trailing space on the prompt in ghci? ":set prompt ghci> " obviously doesn't do it
23:29:17 <dmwit> > last &&& id $ [1..10] -- but makes two passes
23:29:18 <lambdabot>   (10,[1,2,3,4,5,6,7,8,9,10])
23:29:44 <dmwit> I wonder if Last can have its Monad instance derived.
23:29:58 <dmwit> hokay, anyway, bedtime
23:30:21 <rothwell> oh... worked it out ':set prompt "ghci> "'
23:30:27 * rothwell heads back into the shadows
23:30:34 <lispy> rothwell: :)
23:43:52 <rothwell> hm, i know i can compose enumerators sequentially with >==> but what do i need to do to interleave them? as an example of the output i'd like: http://hpaste.org/45869/sequential
