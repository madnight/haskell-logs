00:02:39 <sanjoyd> Does Haskell have some way of getting a list with O(1) access time?
00:03:10 <Axman6> that wouldn't be a list
00:03:15 <helgikrs> sanjoyd: think you have to use array or vector
00:21:19 <roconnor> decoding an array index takes O(log(n)) time
00:21:41 <roconnor> so there is no such thing as O(1) access :{
00:22:09 <DRMacIver> O(log(n)) is uninterestingly small compared to most constant factors anyway
00:22:52 <roconnor> this is true
00:27:29 <DRMacIver> Although most O(log(n)) algorithms seem to have interestingly large constant factors.
00:27:43 <DRMacIver> (Just an empirical observation, I probably wouldn't be able to back it up if you pressed me :) )
00:28:27 <dfilimon> hello everyone; is there a way to use trace but also specify a path to write the debug output to?
00:28:51 <shachaf> dfilimon: Write your own trace.
00:28:55 <DRMacIver> dfilimon: I don't think so. You could write your own trace function that did. the implementation isn't that hard (it's just seq + unsafePerformIO)
00:29:10 <dfilimon> yeah, without unsafePerformIO if possible :p
00:29:13 <christo_m> BMeph: i saw your fix
00:29:22 <christo_m> wondering how im going to be going from a Parser Expr to a Parser Stmt
00:29:23 <shachaf> dfilimon: You aren't meant to use trace for anything serious.
00:29:33 <DRMacIver> dfilimon: Err. trace is unsafely performing IO. How do you want to do that without unsafePerformIO?
00:29:34 <shachaf> DRMacIver: You don't even need seq.
00:29:36 <shachaf> @src trace
00:29:36 <lambdabot> trace string expr = unsafePerformIO $ do
00:29:36 <lambdabot>     hPutStrLn stderr string
00:29:36 <lambdabot>     return expr
00:29:38 <dfilimon> then, how do i debug stuff without trace?
00:29:56 <DRMacIver> shachaf: Hm. I wonder why I thought you did. My mistake.
00:30:01 <dfilimon> well yes, trace is, but i feel like i'm being naughty doing it myself explicitly
00:30:50 <dfilimon> also, on an unrelated note
00:31:03 <dfilimon> what type does let f = uncurry (-) have for you guys?
00:31:14 <dfilimon> running that with ghci
00:31:31 <shachaf> Well, you could write it with seq as (unsafePerformIO (hPutStrLn stderr string)) `seq` expr. But it's not necessary.
00:31:39 <christo_m> BMeph: simpleExpr :: Expr -> Stmt
00:31:39 <christo_m> simpleExpr = do{ e <- exp_exp; return Simple e}
00:31:40 <shachaf> @ty uncurry (-)
00:31:41 <lambdabot> forall a. (Num a) => (a, a) -> a
00:31:41 <dfilimon> it tells me that f :: (Integer, Integer) -> Integer
00:31:42 <christo_m> im assuming something like that
00:31:47 <DRMacIver> shachaf: Ah, right. That's probably what I had in mind.
00:31:47 <shachaf> dfilimon: You might be running into the monomorphism restriction.
00:32:05 <dfilimon> using let it turns it into an integer for some reason
00:32:23 <shachaf> Yes, that's the MR. Either write the type out explicitly or add an argument (f x = uncurry (-) x).
00:32:24 <dfilimon> and using it without the let keeps the Num a
00:32:35 <shachaf> @wiki Monomorphism Restriction
00:32:35 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_Restriction
00:32:36 <dfilimon> monomorphism restricition?
00:32:49 <dfilimon> ah, ok :)
00:32:52 <dfilimon> thanks
00:33:07 <shachaf> Or :set -XNoMonomorphismRestriction (which is what I do).
00:35:22 <shachaf> dfilimon: Also, you could redirect stderr to a file from your shell. :-)
00:35:50 <dfilimon> that might actually be best!
00:35:55 <dfilimon> i'm using stdin and stdout
00:36:00 <dfilimon> but i totally forgot
00:36:04 <dfilimon> that stderr was separate
00:36:28 <shachaf> Seriously, though, there's no advantage to Debug.Trace over unsafePerformIO.
00:36:43 <shachaf> Don't use it for anything other than debugging.
00:39:24 <gio123> does one has experience to prove termination of rewriting rule?
00:56:59 <prayzon> hi?
00:57:15 <Axman6> hello?
00:57:37 <prayzon> can i ask you a question ?
00:58:00 <prayzon> when i hack with scripts, do i need to use windoes 7 or linux, php or c++?
00:58:04 <Axman6> only if you pay attention to the first rule of IRC: don't ask to ask, just ask
00:58:20 <prayzon> well  okay sorry :d
00:58:23 <Axman6> ha
00:59:19 <prayzon> do you know what is best for hacking with scripts ?
00:59:24 <prayzon> linux or windoes7, php or c++?
00:59:29 <Axman6> ou... want to be a scryipt kiddie?
00:59:32 <quicksilver> this channel is about the haskell programming language, prayzon 
01:00:28 <prayzon> well, sorry then :d
01:00:29 <prayzon> d:
01:01:59 <Axman6> prayzon: you know script kiddies get laughed at right? just letting you know now before you find out it's not cool
01:03:59 <gio123>  does one has experience to prove termination of rewriting rule? 
01:04:43 <prayzon> axman6 what :o+
01:04:45 <prayzon> ?*
01:04:46 <lambdabot> Maybe you meant: . ? @ v
01:06:45 <Athas> How do you wrap variadic functions (functions that use the ellipsis) with the FFI?
01:18:18 <Athas> sjanssen: alternatively, the x11-xim package seems to include some somewhat important things that are missing from X11.  What's the policy on implementing semi-extensions anyway?
01:19:14 <quicksilver> Athas: with a non-variadic C wrapper.
01:20:38 <nejucomo> If I want to document translations between two (programming) languages, what are good symbols to demark a grammar specification and a translation?
01:20:53 <nejucomo> Right now I'm using '⇒' to indicate translation, which seems fine.
01:22:59 <gienah> Athas: the release notes for c2hs mentions "variadic functions", so maybe c2hs might work
01:23:42 <Bfig>  showPol (f:g:fs) = f ++ (if g=0 then ("+0") else if g>0 then ("+" ++ g ++ "x") else  g) : stageShowPol 2 fs
01:23:49 <Bfig> i get unexpected '='
01:23:55 <Bfig> what's the problem?
01:24:11 <shachaf> gienah: Not calling them, just putting their pointers in structs.
01:24:24 <quicksilver> Bfig: if g == 0 
01:24:32 <quicksilver> (rather than if g = 0)
01:24:33 <Bfig> ohh... thanks
01:24:34 <shachaf> Or pattern-match g.
01:24:35 <gienah> shachaf: thanks for correcting me :-/
01:25:11 <fenfrie> small question when i have a main = do .. and there i have a [] of strings, how can i print each of it with putStrLn in this do
01:25:18 <shachaf> @ty mapM_
01:25:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:25:21 <quicksilver> I might case on compare g 0, in fact, rather than a nested if.
01:25:23 <shachaf> No need for do.
01:25:49 <shachaf> Oh, I didn't read all of it. But yes.
01:26:21 <Bfig> a
01:26:32 <quicksilver> and you still have a type error Bfig ;)
01:26:39 <quicksilver> g can't be a number and a string.
01:26:54 <quicksilver> suspect you want (show g) for the last two mentions of g.
01:26:55 <Bfig> doesn't that overload automagically?
01:27:00 <quicksilver> nope.
01:27:06 <Bfig> ok... thanks :p
01:28:10 <quicksilver> showPol (f:g:fs) = f ++ (case g `compare` 0 of EQ -> "+0"; LT -> show g; GT -> "+" ++ show g ++ "x") : stageShowPol 2 fs
01:28:13 <quicksilver> I think.
01:39:29 <Bfig> gonna sleep.. too many hours programming. thanks for the help. night.
01:47:08 <man> hello
01:47:11 <rsuniev1_> Given: [JSObject (JSONObject {fromJSObject = [("user",JSObject (JSONObject {fromJSObject = [("screen_name",JSString...
01:47:22 <rsuniev1_> How do I get fromJSObject?
01:48:39 <rsuniev1_> type is: json :: Result [JSValue]
01:54:45 <tibbe> rsuniev1_, which library are you using?
02:01:06 <rsuniev1_> tibbe: Text.JSON
02:01:29 <rsuniev1_> tibbe: http://hackage.haskell.org/package/json
02:03:06 <tibbe> rsuniev1_, first you need to check if the parsing succeeded, using e.g. patter matching or a case statement: case res of Ok val -> ...; Error str -> error ("parse error: " ++ err)
02:03:25 <tibbe> rsuniev1_, then in the "Ok val ->" branch you can do something with the value 
02:04:03 <tibbe> rsuniev1_, like pattern match on one of the constructors (e.g. JSNull, JSBool, ...). They are listed here: http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/Text-JSON.html
02:05:06 <rsuniev1_> tibbe: Thanks.
02:06:00 <tibbe> rsuniev1_, the way people typically use this library is by defining an instance of JSON for their data type e.g. you make up a data type for the result: data MyRecord = MyRecord { ... some field .. } and then you make MyResult an instance of the class
02:06:57 <tibbe> afraid I don't have more time to explain it right now
02:07:57 <rsuniev1_> what I wanted really is to extract fromJSObject in do notation and use for something esle
02:55:06 <rsuniev1_> > map snd $ [(1,2),(3,4)]
02:55:07 <lambdabot>   [2,4]
02:56:21 <rsuniev1_> What would be a method which gives me Just [2,4] instead of [2,4]. I need it to return Maybe for "do" block.
02:56:47 <ezyang> If you're in a maybe monad, 'return' 
02:56:53 <ezyang> Otherwise, use 'Just' 
02:58:06 <rsuniev1_> How do I check the previous method in case
02:58:14 <rsuniev1_> > map snd $ []
02:58:15 <lambdabot>   []
02:58:27 <rsuniev1_> I want it to return Nothing
02:58:48 <int-e> > listToMaybe []
02:58:49 <lambdabot>   Nothing
02:58:56 <int-e> > listToMaybe [1,2,3]
02:58:56 <lambdabot>   Just 1
02:59:40 <int-e> so when exactly do you want to return Nothing? 
03:00:45 <rsuniev1_> when "snd" returns empty result
03:01:00 <rsuniev1_> or an element doesn't exist
03:01:38 <shachaf> Nothing isn't NULL, you know.
03:01:45 <shachaf> Why do you want it to be Nothing?
03:01:59 <sordina> rsuniev1_: snd is for tupples
03:02:04 <sordina> :t snd
03:02:05 <lambdabot> forall a b. (a, b) -> b
03:02:22 <int-e> how can snd return an empty result? it's a total function from pairs to their second element.
03:02:50 <shachaf> > snd (1,undefined)
03:02:51 <lambdabot>   *Exception: Prelude.undefined
03:02:59 <int-e> > map (liftM2 (>>) listToMaybe return) [[],[1],[1,2],[1,2,3]]
03:03:00 <lambdabot>   [Nothing,Just [1],Just [1,2],Just [1,2,3]]
03:04:06 * frerich watches the campfire, meditating over shachaf's observation that "Nothing isn't NULL". Deep.
03:04:10 <int-e> (that works for representing empty lists by Nothing. But since that representation allows the extra value  Just [],  I don't see the gain over simply using a list)
03:07:19 <universa1> hello, got a problem compiling some "simple" haskell code, which works fine locally on my mac, but doesn't compile on a linux machine and i'm clueless as to what the error means, or how to fix it: http://hpaste.org/paste/45661/simplest_sanitizexss_stdinst#p45677
03:07:23 <rsuniev1_> Need sometime to rethink my approach:) Thanks for advice
03:07:29 <roelvandijk> > snd (Just "Something", Nothing)
03:07:30 <lambdabot>   Nothing
03:08:10 <shachaf> universa1: Maybe try compiling with ghc --make?
03:08:15 <quicksilver> universa1: did you compile with ghc --make ?
03:08:39 <universa1> nope, gonna try :-) haven't really used haskell except for some university exercises.
03:09:22 <universa1> worked like a charm :-) thanks a lot guys
03:09:30 <quicksilver> \o/
03:23:08 <dfilimon> can anyone suggest some helpful flags to get ghc generated code to run faster (besides the llvm backend)
03:28:06 <gio123> can one help me to undestadn termination proof of rewriting rule?
03:37:07 <quicksilver> dfilimon: no. There are no magic flags. If they were, they would be the default!
03:37:17 <quicksilver> dfilimon: profile. Look carefully at profile. Look at core.
03:37:25 <quicksilver> look at GC stats.
03:38:21 <dfilimon> sadly, i can't really do that; my program is supposed to be executed by another viewer app and i don't have control over its runtime options since i haven't written the viewer
03:38:35 <dfilimon> but, it works fine with a good old -O2
03:38:50 <dfilimon> (it's a connect4 player btw)
03:40:08 <dfilimon> would you suggest -fvia-C or not?
03:41:18 <zygoloid> you can't run your code outside of the viewer app?
03:41:38 <zygoloid> even if not, you can still look at core, presumably?
03:43:55 <scree> dfilimon: couldn't you write a shell script or similar which wraps your program with the right RTS options, and pass that to the viewer app?
03:45:25 <quicksilver> I would suggest not -fvia-C if you're using a recent GHC/
03:45:47 <dfilimon> possibly, although the viewer would expect a binary. i'm not sure how it's launched since the viewer is written in java and i'm not really familiar with that; also, it really is for my own amusement, my program can win anyway
03:46:17 <dfilimon> recent, as in post 6.x ?
03:53:59 <Vermeille> Hi all
03:55:50 <quicksilver> dfilimon: recent as in 6.12 or later
03:56:14 <dfilimon> ubuntu has 6.12.1 :)
03:56:32 <Vermeille> I'm interested in haskell programming, I already know OCaml, and I would like to have your opinion : is Haskell better than F#, or, to be more precise, allows real productive work in a functional language ?
03:57:03 <Vermeille> F# has .NET Framework, but Haskell seems to be more interesting
03:58:45 <mrcarrot> Vermeille: i think it is always a matter of taste. asking here you will get answers that are biased towards haskell
03:59:18 <mrcarrot> Vermeille: i never considered f# as an alternative because of .net...
03:59:50 <Vermeille> In fact, if you told me that Haskell could really be used as a functional productive language, I trust you
04:00:05 <Vermeille> I prefer the Haskell's style than the Caml'sone
04:00:16 <Vermeille> Caml's one*
04:00:27 <mrcarrot> there are already several projects that are using haskell, xmonad maybe the best known
04:01:06 <merijn> Vermeille: Galois is running their entire business on doing production code in Haskell
04:01:15 <geheimdienst> Vermeille: i don't know what you mean exactly by "functional productive language", but haskell clearly is a functional language, and i'd argue working with it is very productive after you got used to it
04:01:25 <geheimdienst> it's certainly not a toy language, if that's what you mean
04:02:32 <Vermeille> geheimdienst: I don't mean toy language, but, "language for science"
04:02:54 <Vermeille> Or just for studies
04:03:52 <merijn> Vermeille: Well, just take a look at http://corp.galois.com/ and see if what they're doing qualifies as "real world/production" enough :)
04:03:57 <geheimdienst> i find working in haskell productive because the compiler is so helpful. it's hard to get something to compile, but once it does, it rarely has a bug in it anymore. in other languages, the compiler is much dumber and can't help you as much, which means once something runs for the first time, you still have hours of bug-hunting to do
04:04:29 <merijn> geheimdienst: If he comes from OCaml I'm pretty sure he's already used to HM typing :)
04:04:35 <Vermeille> merijn: thx !
04:05:02 <Peaker> Vermeille, IMO Haskell is an awesome language, and some of the infrastructure is great (lots of libraries), but some of the infrastructure is not quite there yet (cabal-install doesn't generally "just work").  Debugging is rare, but when you have to do it, it is significantly harder in Haskell
04:05:11 <Jafet> Haskell is less typing than F#
04:05:30 <geheimdienst> Jafet: less typing, more type inference?
04:05:30 <Vermeille> geheimdienst: Yeah that's true, I do a lot of C# (in fact I just studied OCaml at school), and debuggingis really time consumming
04:05:31 <geheimdienst> ;)
04:05:36 <Jafet> And at the same time, more typing!
04:06:05 <Peaker> I really dislike pure exceptions being hidden inside *lots* of functions with no "unsafe" in their names.. (head, !!, !, ...) and when those pure exceptions pop up, it can be *very* hard to pinpoint them, especially in a larger project
04:06:12 <merijn> Vermeille: In my opinion Haskell has more libraries then OCaml, it is of course less then .NET has. But there's libraries for all the important things and the quality is good
04:06:13 <geheimdienst> Vermeille: yeah, that's what i meant. i see the haskell compiler as a great deal more helpful, compared to the c# compiler
04:06:39 <Vermeille> no NullPointerException \o/
04:06:53 <merijn> Vermeille: You can also take a look at the Hackage library database: http://hackage.haskell.org/packages/hackage.html
04:07:12 <Peaker> The reason the compiler in Haskell can actually help is because the types say a lot more about what code does due to purity and genericity
04:07:26 <Jafet> I find less typing to be as important to the usefulness of a language as more typing
04:07:42 <merijn> Jafet: Nice one :>
04:07:44 <Vermeille> Yeah, I looked at the database and something scared me... I just spent 3h trying to install gtk2hs without success (Win 7)
04:07:49 <Jafet> And Haskell's syntax and conventions are excellent in that regard
04:08:22 <Peaker> I recently had some bad experiences with production Haskell code -- I get pure exceptions without stack traces, and I really don't see why anyone would prefer that over some extra fmaps/etc if wrapping things in Maybe properly
04:08:29 <geheimdienst> yes absolutely, the lack of NullPtrExceptions is the first big plus of haskell. however i've heard that c# is now making a few steps in haskell's direction (nullable types)
04:08:48 <merijn> Vermeille: Ah yes, some of the stuff (like GUI libraries) can suck a bit to get running under Windows
04:09:04 <Peaker> I think the non-nullables are an *easy-to-explain* advantage, but they're not a significant part of why Haskell is better than C#
04:09:29 <chridi> hi :)
04:09:44 <merijn> Vermeille: Most library authors develop on unix systems which means the installation steps for windows aren't always as direct and simple since not many people bother to figure that out and smooth out the the process
04:10:31 <Vermeille> Yeah I just rebooted on my Arch Linux, and I was much more scared when I saw that the last release of gtk2hs was in 2009...
04:11:20 <dcoutts> Vermeille: last release was Nov 2010
04:11:36 <Vermeille> Maybe I didn't look at the right place ?
04:13:55 <geheimdienst> Vermeille: generally, haskell stuff comes in 2 ways: distro packages (for arch linux it's AUR packages), which are lagging behind but might be more stable, and cabal packages, which are up-to-date and platform-independent
04:14:23 <geheimdienst> the maintainers periodically take the cabal packages and repackage them as distro packages
04:14:38 <geheimdienst> (my approach is to ignore distro and just use cabal for everything)
04:15:53 <Vermeille> geheimdienst: yeah, and cabal just didn't worked under Windows, that's... not really encouraging
04:16:15 <Peaker> I think the #1 priority of Haskell evangelists should be to get cabal-install to work -- which means replacing the version range deps and PVP with something that works
04:16:32 <dcoutts> Vermeille: it does work under windows, but gtk relies on C libs being installed, and knowing where to find them, so it's more tricky to set up
04:16:56 <merijn> Couldn't hurt to polish the install procedure for Windows :p
04:17:19 <Vermeille> maybe, to be precise, it crashed at the cairo install (trying to install gtk2hs)
04:17:39 <Vermeille> It said that cpp were "not an internal command"
04:17:41 <quicksilver> gtk2hs is a pathological package.
04:17:49 <quicksilver> cabal in general works fine on windows.
04:18:00 <Vermeille> Hum, wxHaskell should work ?
04:18:13 <dcoutts> Vermeille: I'd be interested to see the full error message actually
04:18:17 <Peaker> to set up an internal corporate hackage server (with our own fixes to packages) -- is it better to use yackage or something else?
04:18:28 <dcoutts> Vermeille: I'd have expected something clearer, like there being no cairo C lib available
04:18:37 <quicksilver> Peaker: the problems you describe are not simple. They will not be solved by evangelists. They will be solved by very smart people who have lots of time to spend on cabal.
04:18:45 <dcoutts> Vermeille: wxhaskell is similar, it uses C libs and installs via cabal
04:19:07 <Peaker> quicksilver, I think if we abandoned the PVP and removed the upper limit on version constraints the situation would actually improve
04:19:34 <Peaker> (Things break far more often because of over-conservative upper limits than because APIs changed in a breaking way without release of new packages to use the new APIs)
04:20:13 <Saizan> ..i guess Peaker was not here during basically every ghc release
04:20:13 <dcoutts> Peaker: but on the other hand, when they do break, it's much clearer why
04:20:15 <Vermeille> hell, doing GUI in Haskell under windows is so complicated o_o ?
04:20:36 <dcoutts> Vermeille: it's because windows has no sensible way to install libraries
04:20:38 <dfilimon> with wxWidgets?
04:20:51 <dcoutts> there are no standard locations to install C libs so that they can be found
04:21:04 <dcoutts> Vermeille: and windows has no package system
04:21:12 <dcoutts> that's why it's complicated on windows
04:21:18 <Peaker> dcoutts, only if you dig deeply into "cabal install -v" which most newbies can't/won't.. One of the more common breakages I see people get is re-install of system packages like bytestring with same-version just because some upper-constraint means they have to be linked against older libs
04:21:21 <Vermeille> Yeah I acknowledge that Windows sucks on these points
04:22:13 <dcoutts> Peaker: no, just the usual without -v, it says that it cannot make a solution for some reason. That's a lot clearer than compiling the package and it failing with some type error, there's no place to start there.
04:22:32 <merijn> Vermeille: The main problem is that (as I said) a lot of people develop on OSX/linux/whatever and thus they aren't that motivated to invest a lot of time to fix the (non-Haskell) library problem on Windows. I think the haskell wiki has a guide to installing on Win7, but not sure if you already tried that?
04:22:34 <Peaker> dcoutts, no, it actually finds a "solution" but the solution is re-installing all of the --global packages in the same very as --user
04:23:03 <Peaker> dcoutts, but linked to older deps
04:23:05 <dcoutts> Peaker: ok, well the fact that that tends not to work is somewhat orthogonal
04:23:12 <Vermeille> merijn: No, I rebooted under Arch Linux x)
04:23:42 <Peaker> dcoutts, is there any situation where it is healthy/good idea to have same-version installed globally and locally?  cabal-install always did so because of over-conservative upper limits IME
04:23:59 <dcoutts> Peaker: it's not just because of upper limits
04:24:13 <dcoutts> Peaker: in future I hope to make that situation work fine
04:24:17 <Peaker> dcoutts, What else causes it?
04:24:38 <dcoutts> Peaker: needing newer versions of some core lib will do it too
04:24:55 <Peaker> dcoutts, well, every time it happened to me (many times) I just edited some .cabal file of some dependency to remove/up its upper constraint and the problem was solved
04:25:38 <dcoutts> Peaker: right, and the only reason you needed to do that is because cabal gets itself totally confused when it has the same version installed twice, but that is fixable.
04:25:51 <Peaker> It would perhaps be nice to get the dependency specification out of the .cabal file and into a web database based on continuous updates
04:25:56 <dcoutts> Peaker: under a nix-like system, you could have multiple instances of the same version and it'll all be fine
04:26:19 <dcoutts> Peaker: what would that do?
04:26:35 <Vermeille> Hum, something strange, why Haskell is slower and executables takes more places than C equivalents ?
04:26:37 <Peaker> dcoutts, it would make it far less likely that the dependency version specifications are wrong/out-of-date
04:26:46 <dcoutts> Peaker: certainly I'd like to let hackage have a more up-to-date tweakable .cabal file, that lets the deps be adjusted after release.
04:27:13 <Peaker> dcoutts, it would be nice if non-developers could contribute "working version configurations" after they build successfuly
04:27:34 <Peaker> (not just those with the rights to upload .cabal files)
04:27:55 <dcoutts> Peaker: the long term plan there is to have cabal report successful and failed builds with details of deps used. Then maintainers and others can use that info to adjust the deps appropriately.
04:28:06 <dcoutts> we've got parts of that system done already
04:28:25 <geheimdienst> dcoutts: sounds nice. kudos, thanks for all your work :)
04:28:38 <Peaker> dcoutts, why require the developers as part of that loop? Why not use a database of "configurations that ever built successfully" directly for the dependency resolution?
04:28:53 <dcoutts> Peaker: the data is not totally reliable
04:29:01 <Peaker> Why not?
04:29:11 <dcoutts> Peaker: because it's gathered anaonymously
04:29:22 <dcoutts> and does not record if people made local tweaks
04:29:32 <Peaker> Well, out-of-date information is also unreliable (which is the result of having the authors always in the loop)
04:29:49 <dcoutts> and it does not have to be just the developers, it can be other package collection maintainers on hackage
04:29:51 <blackh> Vermeille: Because C compiler technology is currently ahead of Haskell compiler technology, and also because Haskell is higher level, so it has more work to do.  However, C compiler technology is closer to its limit than Haskell compiler technology, so Haskell will catch up.
04:29:58 <Peaker> dcoutts, well, maybe if hashes of the sources or such were kept, it could be possible to guard against tweaks
04:30:26 <dcoutts> Peaker: magic numbers in anonymous data makes people nervous
04:30:41 <dcoutts> they cannot tell if it's actually reporting identifying information
04:30:59 <Vermeille> blackh: laziness sounded like an amazing optimization, that surprized me :)
04:30:59 <insane> is there a way to print something from a function that is not a do block, specifficaly the code in one of my modules is written without do blocks and I'd like to put few debug printouts to check what's wrong. Do I have to change all the functions in the call stack to use the do notation?
04:31:02 <Peaker> dcoutts, it could be opt-in.. "cabal report-build" or such
04:31:16 <merijn> Vermeille: The speed issue varies a lot based on what you're doing. The reason the executables are larger is because the haskell runtime is larger and more complex then the C runtime
04:31:16 <dcoutts> Peaker: oh it will be opt-in, but still anonymous
04:31:25 <dcoutts> in any case, you're also looking for failures, not just successes. And failures are more "random"
04:31:34 <Peaker> insane, for debug prints -- you can just break referential transparency and use Debug.Trace
04:31:37 <prayzon435> hello, im wondering what haskell can be used to ?
04:31:45 <dcoutts> it can happen for more reasons not covered in the info we can reasonably collect
04:31:59 <jeffz> prayzon435: better ask what it cannot be used for.
04:32:08 <blackh> prayzon435: Haskell is a general purpose programming language, so it can be used for pretty much anything.
04:32:35 <Peaker> dcoutts, well, lack of success-evidence can be considered as evidence-of-failure until proven otherwise.. then for people just using "cabal install" it can say "your configuration is untested" or such, and "test pilots" could try to compile and report back if they want
04:32:37 <insane> Peaker: is this because the "proper and pure" haskell code doesn't have the function of a signature IO a -> a ?
04:33:05 <dcoutts> Peaker: but just because it compiles, does not mean it works
04:33:10 <prayzon435> thanks guys, im thinking about leaning it so i just want to knwo what it can be used for, but im mostly going to program hacking scripts, if i can use haskell for that?
04:33:15 <Peaker> insane, that's a sufficient alternative, but not necessary.. you can do it with less
04:33:17 <blackh> Vermeille: Laziness and boxing are two things that make give the compiler lots of work to do.
04:33:20 <dcoutts> Peaker: that's the other reason to have some degree of human developer involvement
04:33:35 <Peaker> dcoutts, Isn't compile-but-doesn't-work pretty rare in practice?
04:33:37 <dcoutts> Peaker: and not to make it fully automatic
04:33:41 <dcoutts> Peaker: no
04:33:46 <insane> Peaker: so I presume that there's no way to use <- operator without do block?
04:33:49 <dcoutts> Peaker: and the results can be pretty bad
04:34:00 <Peaker> dcoutts, Example?  I'd expect developers changing semantics to also change the name or the type
04:34:18 <dcoutts> Peaker: there are lots of bug fixes that can be done without changing the API
04:34:45 <Peaker> dcoutts, well, this concerns lower bounds on versions, which are fine.. the problem is upper bounds
04:34:49 <dcoutts> Peaker: there's been various darcs runtime bugs caused by bugs in various core libs on certain platforms
04:35:17 <blackh> prayzon435: Haskell is very good for hacking small scripts, though it is not so specifically targeted for that task as, say, Python.
04:35:29 <Peaker> dcoutts, even with the PVP, any library can make backwards-compatible changes and insert bugs, and no dep system will guard against that
04:35:44 <dzs468> Ey :D
04:35:47 <dcoutts> Peaker: that's true of course
04:35:55 <prayzon435> ¨then what do i need to program hacking scripts ?
04:36:09 <Peaker> dcoutts, so why guard against it at all?
04:36:20 <dzs^^> Notepad!
04:36:22 <jeffz> insane: <- isn't really an operator, it's just part of do notation
04:36:23 <roelvandijk> prayzon435: If you mean shell scripts then have a look at http://hackage.haskell.org/package/HSH
04:36:23 <dcoutts> Peaker: but if you make some semantic change, bump the api version number, clients may still compile but will have wrong behaviour
04:36:38 <dcoutts> Peaker: where as if one follows the PVP there, then it's fine
04:36:43 <blackh> prayzon435: Well, Haskell is just a really really great language, and it can be used for anything.  What it's *really* good for is, well, basically anything difficult.
04:36:46 <Peaker> dcoutts, So instead of bumping the API version number, the practice can be changed to bumping the name or type
04:36:57 <Peaker> dcoutts, replace the PVP with the Package Naming Policy..
04:37:03 <dcoutts> Peaker: but if the API is already fine, then that seems silly
04:37:04 <Peaker> dcoutts, (naming inside the package, I mean)
04:37:15 <prayzon435> blackh - can you teaach me something ?
04:37:15 <dcoutts> making a change just for change's sake
04:37:20 <roelvandijk> insane: do x <- f   ---->   f >>= \x -> ...
04:37:25 <blackh> prayzon435: Sure. What would you like to know/
04:37:53 <prayzon435> well. can i write to you in privat?
04:38:17 <dzs^^> blackh: i wrote to u aswell
04:39:03 <Peaker> dcoutts, I think since cabal-install is for *developers* it is better to have false positives (allow build even if unsure of quality) than false negatives (disallow build because it was not vetted to work)
04:39:26 <dcoutts> Peaker: I think many package maintainers would disagree with that
04:39:43 <Peaker> dcoutts, And there are probably a whole lot of false negatives than there would be false positives (in Haskell if it builds it means a lot)
04:39:45 <rrc7cz> if I wanted to implement notElem based on elem, I imagine I could write 'myNotElem = not . elem', leaving elem partially applied to 0 arguments, so the type would be 'a -> [a] -> Bool', but it doesn't typecheck unless I include one arg like 'myNotElem e = not . elem e'
04:40:05 <dcoutts> Peaker: but I'm not averse to making it easier with cabal-install for users to deliberately override version constraints specified by the package authors
04:40:32 <dcoutts> Peaker: that might give the right balance, users can do what they like, but they get to keep the pieces when it breaks
04:40:43 <Peaker> dcoutts, I'd personally far prefer build&runtime errors than cabal refusals
04:40:50 <dcoutts> Peaker: false negatives are a whole lot worse than false positives
04:41:07 <dcoutts> or do I mean the other way around :-)
04:41:27 <Peaker> I agree that for production systems that is true.. for developers -- a "broken" state is norm :)
04:41:38 <Peaker> but the build tool standing between them and *developing* -- that's bad
04:42:09 <luite> I prefer the current way, it's easy to cabal unpack and edit the .cabal file, and at least you know when and where to watch for problems
04:42:19 <quicksilver> rrc7cz: yes. (.) composes single argument functions.
04:42:29 <quicksilver> rrc7cz: if you're function has two arguments you ahve to think a bit.
04:42:41 <rrc7cz> quicksilver: okay, that explains why I can define myOdd as = not . even
04:42:50 <quicksilver> yes, exactly.
04:42:51 <dcoutts> Peaker: right, so I'm happy to add a way for developers to override constraints if they want to test it, easier than cabal unpack + edit
04:43:00 <Peaker> dcoutts, When I give Haskell to coworkers, they can live with occasional build problems and errors.. but telling them to override ".cabal" files and manually install deps, mess around with "-v", etc.. that's too much. I end up having to baby-sit them and install packages for them.. making Haskell newbies almost hopeless for a while
04:43:05 <Vermeille> Does the parallelization (?) issue of imperative languages allows to haskell to be more powerful on multicores architectures ?
04:43:06 <dcoutts> Peaker: if you have suggestions on the user interface for that, I'd be happy to hear them
04:43:15 <quicksilver> dcoutts: that would be handy.
04:43:22 <dcoutts> quicksilver: suggestions welcome
04:43:30 <dcoutts> there's a fair bit of detail
04:43:38 <quicksilver> dcoutts: would make it easier for authors to publish/recommend workarounds in advance of an upload with better deps.
04:43:41 <dcoutts> you've got N packages, each with M deps
04:43:51 <quicksilver> cabal install --force-version foo-1.2.3.4
04:43:54 <dcoutts> quicksilver: right, though again we hope to make the deps editable on hackage
04:44:16 <dcoutts> quicksilver: so that would override all constraints that other packages place on package foo
04:44:19 <quicksilver> dcoutts: yes but this gives an easy way to ask people to test the new deps.
04:44:21 <quicksilver> dcoutts: yes.
04:44:33 <dcoutts> I guess that's a reasonable simplification
04:44:38 <quicksilver> even simpler
04:44:42 <quicksilver> cabal install --force-version foo
04:44:49 <quicksilver> ^^ if I only have one available version of foo
04:44:58 <quicksilver> then that means 'use my current version'
04:45:13 <dcoutts> or use the default version if it's not installed
04:45:18 <Peaker> dcoutts, Maybe version constraints can be divided into "vetted to work in this version range", and "will definitely not work in this version range", and then you have 3 levels of dep. satisfaction: 1. Vetted  2. Maybe  3. Won't work.    cabal-install can always avoid 3, but allow the user to choose between 1 and 2
04:45:51 <dcoutts> Peaker: yes, people have suggested before that there be a different syntax for hard upper bounds and conservative upper bounds
04:46:15 <Peaker> and I'd always use the liberal install command rather than the conservative one
04:46:32 <dcoutts> --optimistic
04:46:35 <kosmikus> specifying upper bounds (for versions that don't exist yet) is always tricky
04:46:49 <dcoutts> kosmikus: that's what the PVP is for
04:46:59 <kosmikus> right
04:47:00 <dcoutts> but it is necessarily conservative
04:47:04 <kosmikus> exactly
04:47:08 <quicksilver> I think 3 levels of dep satisfaction would be a confusing nightmare.
04:47:10 <quicksilver> maybe I'm wrong :)
04:47:18 <dcoutts> since the API change might happen not to break your specific code
04:47:22 <Peaker> quicksilver, we already have 1 and 3, we just lack 2 :)
04:47:25 <kosmikus> so if HackageDB had an integrated build server and would automatically adjust the upper bounds ...
04:47:34 <Peaker> dcoutts, IME that's a vast majority of the cases
04:47:44 <kosmikus> no, I agree with quicksilver. three levels is too much to specify by hand.
04:47:49 <dcoutts> kosmikus: that's the idea, but with a human in the loop, not necessarily the package author
04:47:50 <kosmikus> it would only work if you have tool support.
04:48:09 <dcoutts> kosmikus: e.g. equivalents of distro collection maintainers
04:48:12 <cartouche> hello
04:48:21 <kosmikus> dcoutts: ok
04:48:37 <cartouche> how I can comment out a line in Haskell like /*   */ in C
04:48:38 <Peaker> You don't specify 3 levels, you normally specify a conservative upper range, a known or conservative lower range.  In special cases, you can also specify a known upper range..
04:49:06 <wjt_> cartouche: {- -}
04:49:19 <wjt_> cartouche: to comment out just a single line, like // in C++, use --
04:49:31 <Peaker> So if now you say:  bytestring >= 0.7 && < 0.8   you could instead say:  bytestring !>= 0.7 && < 0.8        where ! means it's *really* not going to work below 0.7, but < means it conservatively isn't certain to work above
04:49:51 <Peaker> and people like me will be able to ignore the conservative ranges :)
04:50:04 <luite> are there actually cases where you'd use package >= 0.x  without the !?
04:50:23 <Peaker> luite, you're lazy and you haven't tested it with lower versions?
04:50:26 <cartouche> thanks a lot....
04:50:42 <Peaker> but if bytestring 0.8 inserted a bug that surely breaks your code, you can add:  bytestring !>= 0.7 && !< 0.8
04:51:46 <dcoutts> quicksilver: the --force-version idea gets harder when we have solutions that involve multiple versions of the same package, e.g. parsec 2 and parsec 3
04:51:47 <luite> hmm, dunno, having 3 versions so developers can get away with less testing might not be ideal 
04:52:11 <Peaker> dcoutts, theoretically you could use both parsec 2 and 3 at the same time/link, couldn't you?
04:52:23 <quicksilver> dcoutts: yes. It doesn't scale at all to that case. Mind you that case doesn't work all that well either in most circumstances.
04:52:33 <dcoutts> quicksilver: suppose in 6 months we have a solver that can construct solutions that use both parsec 2 and 3
04:52:46 <luite> is it a gsoc project?
04:52:49 <Peaker> btw: GHC is the one that only allows one install of (name-version), not cabal-install, right?
04:52:57 <kosmikus> developers shouldn't individually have to face the testing. rather than making dependencies more complicated, we should invest in infrastructure that allows automatic building more easily. then we'll have more accurate dependencies as a side effect.
04:54:20 <Peaker> kosmikus, automatic building will give you "build dependency information" but not "works dependency information".. separating these complicates the dep. specs but may be worth it
04:54:22 <dcoutts> Peaker: there's multiple different issues here: 1. ghc does not currently allow multiple instances of the same package (except when they occur in different dbs). 2. ghc can link multiple versions of the same package, but not multiple instances of the same version of a package. 3. just because you can link them does not mean it compiles, cabal-install is conservative here and requires just one version of each package.
04:55:09 <dcoutts> Peaker: the build reporting infrastructure we're building can do testsuites too
04:55:09 <luite> when would you have multiple instances of the same version of a package?
04:55:30 <dcoutts> luite: when the two instances are built against different versions of their dependencies
04:55:45 <luite> ah of course
04:56:54 <Peaker> dcoutts, it sounds like the uniqueness should be of the (package name, version, recursively for deps) and not just of the first two
04:57:01 <Peaker> (to prevent the butterfly problem)
04:57:26 <dcoutts> Peaker: yes indeed, you need unique installed package ids, which we now have
04:57:46 <dcoutts> Peaker: but that's just problem 1, there's still 2 and particularly 3
04:59:40 <luite> by the way, something unrelated, is bootstrap.sh from cabal-install typically just used for just building the cabal executable, followed by wiping the package database?
05:00:05 <dcoutts> luite: wiping should not be necessary
05:00:32 <dcoutts> but perhaps the bootstrap should install into a temp dir and not install the libs at all
05:01:34 <luite> dcoutts: in my case the problem is that it installs the packages, but it doesn't build the profiling versions (I have library profiling enabled in my cabal config), so I have to reinstall all these packages manually
05:01:44 <dcoutts> ah yes
05:01:46 <luite> otherwise later builds fail
05:01:50 <dcoutts> right
05:01:58 <dcoutts> profiled builds are a sore area
05:02:11 <dcoutts> needs proper "ways" in cabal-install and ghc-pkg
05:03:01 <Vermeille> Guys, do you have any link / suggestions for ideas of miniprojects / exercices to do while learning Haskell ?
05:04:28 <chridi> Vermeille: parse some fileformat
05:04:43 <chridi> Vermeille: find links in a html file
05:05:51 <Vermeille> Oh hell, I know
05:05:59 <fenfrie> is it possible to use guards in the do notation? when not whats the best work around?
05:06:20 <mauke> :t guard
05:06:20 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
05:06:44 <Vermeille> I'll just start the school's project : the cartographer : read an image relief map, and construct the 3D view
05:09:46 <Vermeille> Hum, which GUI library do you advise ?
05:17:59 <luite> Vermeille: you could start with opengl and glut or sdl. fairly low level, but I don't know any higher level 3d library that is in usable state
05:18:42 <derdon> is it possible to define a function which takes no arguments? I assume I already know the answer, which is "no". because a function which takes no arguments is in fact a value and this already evaluated.
05:18:45 <derdon> am I right
05:18:46 <derdon> ?
05:19:07 <merijn> derdon: What exactly do you want to do?
05:19:15 <luite> derdon: it may not have been fully evaluated
05:19:31 <derdon> merijn: nothing ;)
05:19:31 <merijn> You can have a infinite data structure defined at the top level, for example
05:19:44 <derdon> ah, right
05:19:46 <luite> derdon: for example think of the standard fibs example
05:19:53 <merijn> Which won't be completely evaluated
05:19:56 <derdon> merijn: it's a general question
05:19:59 <Vermeille> luite: for you gtk2hs and wxHaskell aren't usable ?
05:20:06 <hpc> > let fibs = 1:1:(zipWith (+) fibs $ tail fibs) in fibs
05:20:07 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
05:20:31 <luite> Vermeille: oh gtk2hs is
05:20:33 <derdon> so it's not possible as in the crappy non-functional language like C
05:20:48 <luite> Vermeille: I thought you were looking for the 3d part
05:21:01 <hpc> derdon: oh, if you mean like in C, then you are thinking of an IO action
05:21:12 <derdon> hpc: no
05:21:14 <merijn> derdon: Well it is possible, but not all that useful since you can't mutate any global state
05:21:14 <mauke> derdon: C has no functions, so that's kind of moot
05:21:19 <derdon> hpc: for example, random()
05:21:27 <mauke> derdon: not a function
05:21:29 <hpc> derdon: yeah, that's an IO action
05:21:32 <derdon> mauke: then I use python as an example :)
05:21:33 <hpc> or would be
05:21:39 <mauke> derdon: python has no functions either
05:21:41 <hpc> random :: IO RandomThing
05:21:49 <merijn> mauke: Lambda?
05:21:51 <derdon> how is the random stuff implemented in haskell?
05:21:56 <mauke> :t randomIO
05:21:57 <lambdabot> forall a. (Random a) => IO a
05:22:01 <merijn> Oh wait, no lambda can touch state
05:22:01 <Vermeille> luite: no, for sure, if I want to do 3D, i'll use OpenGL
05:22:02 <mauke> (surprise!)
05:22:05 <hpc> @src randomIO
05:22:05 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:22:28 <hpc> randomIO is one, there's also a monad for random number generation i think
05:22:37 <mauke> :t random
05:22:37 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
05:22:39 <hpc> and several other libs for different algorithms
05:22:59 <luite> Vermeille: I have to admit that I don't know how to add an opengl surface to a gtk2hs ui, but it's probably possible :)
05:23:06 <derdon> so they always take arguments, like the boundaries
05:23:20 <merijn> derdon: randomIO doesn't take boundaries
05:23:23 <mauke> derdon: no, randomIO is a constant
05:24:00 <merijn> derdon: Do you understand how monads work?
05:24:29 <mauke> forget monads, do you understand IO?
05:24:33 <luite> derdon: you can also treat the random generator as some kind of state. there's MonadRandom on hackage that behaves similar to the state monad, except that you can't explicitly observe the state
05:24:37 <derdon> merijn: no, I haven't started learning haskell yet. I thought I could throw in his little question and get a answer I understand :P
05:24:44 <Vermeille> luite: not a problem, I just need to use GTK for a config box window, no need to integrate my opengl into the gtk
05:24:47 <mauke> derdon: do you know javascript?
05:24:52 <derdon> mauke: yep
05:24:56 <merijn> derdon: Ah, yeah. Then forget about monads and listen to mauke :p
05:25:09 <mauke> derdon: good, because IO is sort of async callback based
05:25:16 <derdon> ah
05:25:24 <luite> Vermeille: oh ok, then sure, go ahead, gtk2hs is probably the best maintained gui lib at the moment :)
05:25:33 <mauke> derdon: e.g. you attach a callback to randomIO that receives the generated random value
05:25:51 <derdon> I see
05:25:57 <mauke> that way all interaction with the real world happens outside of haskell
05:26:02 <Vermeille> luite: thank you for your help !
05:26:49 <merijn> derdon: You can think of "IO a" as, this is an action which will allow a function taking an "a" to be run once some IO event has happened.
05:27:46 <merijn> And then we have a convenient framework for stringing these sorts of callbacks together in a much nicer way then most asynchronous/callback based frameworks
05:28:57 <merijn> derdon: Although all this will be much easier to understand once you start learning the basics.
05:29:56 <fenfrie> how could a function look like which simply read a number with readLn and then give it back with the signature IO () -> Int
05:30:17 <merijn> fenfrie: That's not possible
05:30:43 <merijn> (That's not entirely true, but if you are asking this question it might as well be)
05:30:51 <fenfrie> merijn: is there a workaround or something
05:30:59 <merijn> fenfrie: But of course!
05:31:21 <derdon> merijn: mauke: thanks for the explanations! haskell sounds really great to me now!
05:31:30 <fenfrie> merijn: and how could it look like?
05:31:31 <mjrosenb> merijn: i refuse to believe that function exists.
05:31:37 <mauke> yay
05:32:04 <merijn> fenfrie: getLine returns an IO String, now imagine you have some function that takes a String and returns something else you would do this like so:
05:32:10 <mauke> fenfrie: why do you think you need such a function?
05:32:20 <mauke> also, what is the IO () good for?
05:32:25 <merijn> fenfrie: do { input <- getLine; myFunction input}
05:33:31 <merijn> fenfrie: Also, Learn You a Haskell gives a good explanation of this (chapter 9 Input and Output)
05:34:24 <merijn> fenfrie: The trick is that you are not getting the Int *out of* IO, but putting the function which needs the Int *into* IO
05:34:45 <fenfrie> merijn: i will look in this chaper. i need this function, because i write a programm which let the user select 1,2 or 3 as a option. and when the user dont select one of this, it sould return to the selection
05:35:02 <mauke> that doesn't require such a function
05:35:14 <merijn> fenfrie: http://learnyouahaskell.com/input-and-output
05:35:45 <merijn> mauke: I think by "IO () -> Int" he meant "do some IO and return an Int", which is of course not possible as such :)
05:36:30 <mauke> "do some IO and return an Int" would be IO Int :-)
05:36:34 <mauke> i.e. readLn
05:37:03 <merijn> mauke: Yes, but that's not as obvious if this "IO ()" has you completely confused :)
05:37:39 <fenfrie> short: IO Int -> Int is not possible?
05:37:47 <mauke> fenfrie: it's nonsensical
05:37:48 <cartouche> hello
05:38:12 <byorgey> hi cartouche 
05:38:24 <cartouche> how  can I put an emty characte like '' but this gives error 
05:38:35 <mauke> there are no empty characters
05:38:35 <merijn> fenfrie: Correct. As I said the trick is not to make an "IO Int" into an "Int", the trick it to turn your "Int -> a" function into an "IO Int -> IO a" function :)
05:38:45 <mauke> merijn: what? no
05:38:53 <mauke> you want Int -> IO a
05:38:57 <mjrosenb> fenfrie: IO int describes an action, that were you to execute it would produce an int
05:39:00 <merijn> mauke: Well indirectly
05:39:14 * mauke is unconvinced
05:39:18 <byorgey> cartouche: you can have the empty string, ""
05:39:28 <byorgey> cartouche: but there is no such thing as an empty character
05:39:34 <byorgey> cartouche: if you want a space you can write ' '
05:39:46 <cartouche> my function take character...I had to handle in case of empty string
05:40:00 <merijn> mauke: >>= effectively turns the Int -> IO a into "IO Int -> IO a"
05:40:05 <cartouche> sorry emty character
05:40:08 <mauke> merijn: I disagre
05:40:12 <fenfrie> i make a small example and show you why i need it okay? perhaps i have a very bad way of thinking :P
05:40:21 <mauke> cartouche: there are no empty characters
05:40:21 <mjrosenb> cartouche: this does not exist.
05:40:27 <cartouche> f ::char -->string
05:40:34 <cartouche> f ''  ?
05:40:37 <merijn> fenfrie: Go read the text I linked you (http://learnyouahaskell.com/input-and-output) it has a very clear explanation
05:40:41 <mjrosenb> > ''
05:40:42 <lambdabot>   <no location info>:
05:40:42 <lambdabot>      lexical error in string/character literal at chara...
05:40:55 <mjrosenb> cartouche: you cannot have an empty character
05:41:02 <mjrosenb> cartouche: can you have an empty integer?
05:41:11 <cartouche> :)no
05:41:40 <cartouche> I got the point
05:41:53 <merijn> mauke: Why? >>= allows a function which takes an Int to consume an IO Int instead. I know that's not what happens, but conceptually (for me anyway) the IO monad business clicked when I realized I was putting my pure functions *into* IO rather then getting values *out of* IO
05:42:17 <mauke> yes, but that's >>=
05:42:39 <mauke> and what you get is an IO a, not IO Int -> IO a
05:43:11 <byorgey> @type flip (>>=)
05:43:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
05:43:21 <mauke> my issue with this is that sometimes people get confused and define their functions as taking IO something when all they really need is something
05:43:47 <merijn> mauke: That's why I said indirectly, you're not going to actually do the step of turning it into an IO Int -> IO a. But I believe it helps to know that's kinda what happens
05:44:08 <merijn> byorgey: That's just (=<<) isn't it?
05:44:12 <merijn> :t (=<<)
05:44:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:44:15 <mauke> we'll see
05:44:30 <byorgey> merijn: ah, yes =)
05:44:59 <merijn> Of course what helps even more is just reading LYAH, because that's much slower pace and more demonstration then IRC conversation :p
05:45:29 <hpc> > "lyah" > "#haskell"
05:45:30 <lambdabot>   True
05:45:40 <hpc> ha! it is confirmed
05:45:46 * mjrosenb always wants to use >> as if it were `liftM`
05:46:04 <vegai> is Cloud Haskell gonna be used in actual production anywhere?
05:46:07 <fenfrie> merijn: here i have the example which show what i want to do http://hpaste.org/45679/guards
05:46:18 <vegai> or is it just another typical haskell research project that never affects anything?
05:46:33 <vegai> pardon my trollish
05:46:59 <mauke> fenfrie: | otherwise = putStrLn "false, only 1 2 or 3" >> select
05:48:03 <fenfrie> mauke: OMG what a stupid think of my own, thank you
05:48:05 <hpc> fenfrie: while learning, i suggest putting type signatures on all functions you write
05:48:20 <hpc> it really helps
05:48:26 <mjrosenb> fenfrie: also, selectGuards
05:49:05 <fenfrie> hpc: i usually do but this was a quick example
05:49:14 <merijn> fenfrie: http://hpaste.org/paste/45679/guards_annotation#p45681
05:49:57 <mauke> merijn: why did you remove readLn?
05:50:02 <mauke> and the loop, for that matter
05:50:21 <zygoloid> vegai: question unanswerable. only time will tell.
05:50:55 <merijn> mauke: Oh, because I fail and wasn't paying attention :p
05:51:02 <quicksilver> vegai: it's too early to tell. It's not the first time we've had function serialisation for haskell.
05:51:08 <quicksilver> vegai: and it's only a research paper.
05:51:27 <quicksilver> still, it would be nice to have a good story for distribution so I hope some compelling examples pop up.
05:51:39 <fenfrie> thank you guys you helped me a lot
05:51:56 <quicksilver> the choice of name is a really naff piece of marketing but I forgive the authors, it probably looks better on conference headlines.
05:53:41 <mjrosenb> quicksilver: "naff"?
05:53:52 <merijn> fenfrie: 4th time's the charm: http://hpaste.org/paste/45679/guards_annotation#p45683 :p
05:54:20 <mauke> mjrosenb: tasteless
05:54:40 <mauke> cheesy
05:55:04 <vegai> quicksilver: I've actually implemented parts of that myself once, poorly
05:55:07 * quicksilver nods at mauke
05:55:27 <vegai> I would welcome a better implementation
05:55:27 <quicksilver> vegai: cool ;)
05:55:32 * mauke has dictionary power
05:55:42 <quicksilver> see also, gdh, mobile haskell, yhc-bytecode
05:55:47 <fenfrie> merijn: thx :)
05:56:43 <merijn> fenfrie: If you don't understand my next bit of explanation, feel free to completely forget it immediately. But maybe it helps to show what's going on
05:56:51 <quicksilver> hmm. the cloud haskell paper doesn't reference mobile haskell *or* yhc bytecode!
05:56:55 <quicksilver> bad jeff!
05:57:43 <quicksilver> vegai: cloud haskell has a significant advantage over those older dormant or dead projects - it's on github.
05:57:54 <quicksilver> vegai: hopefully that may keep it alive long enough to reach critical mass
05:58:00 <merijn> fenfrie: "do { input <- getLine; selectGuards (read input)}" is the same as "getLine >>= selectGuards (read input)", now if we look at the type signatures, maybe you can see what's going on
05:58:04 <merijn> :t getLine
05:58:05 <lambdabot> IO String
05:58:10 <merijn> :t (>>=)
05:58:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:58:25 <merijn> (mentally replace "m a" with "IO a")
05:58:44 <mauke> why do you hate readLn :-(
05:59:14 <merijn> mauke: Because I constantly forget about it :>
05:59:23 <mauke> but it's so good!
05:59:39 <merijn> I don't do that much IO from the console :p
06:00:13 <deech> merijn: Your nick looks familiar. Were you pretty heavy in the Ocaml community a couple of years ago?
06:00:34 <merijn> fenfrie: As I said, if none of that made sense. Just forget it, if you have some vague idea of what that means, meditate on it for a while and achieve enlightenment
06:00:47 <gienah> vegai quicksilver: cloud haskell is in the gentoo overlay
06:01:01 <quicksilver> gienah: oh, that's cool
06:01:18 <merijn> deech: If by "OCaml community" you mean "my theoretical CS class" and "pretty heavy" you mean 'finished my homework assignment", then yes
06:01:20 * mjrosenb resyscs his overlays.
06:02:00 <deech> merijn: Sorry, my mistake.
06:02:07 <merijn> deech: But more likely would be that someone else has the same firstname and was using it as well :)
06:02:22 <Saizan> it seems cloud haskell doesn't even transparently implement function serialization, it uses template haskell to generate defunctionalized closures
06:02:43 <mjrosenb> merijn: the same first name *and* doing fp seems unlikely.
06:03:04 <gienah> Saizan: it seems to use syb as well
06:03:07 <merijn> Well, there seems to be a correlation between my name and theoretical CS students >.>
06:03:45 <deech> Has anyone here seriously used delimited continuations? I'm trying to wrap my head around them and around a good use-case for them. The Scala community seems to be running with it now. 
06:05:42 <applicative> fenfrie: see what you think of this , which takes a bit more out of "IO" http://hpaste.org/paste/45679/guards_annotation#p45684
06:08:44 <mjrosenb> gienah: i didn't see it after i just pulled.
06:09:02 <gienah> mjrosenb: emerge -a dev-haskell/remote
06:10:52 <fenfrie> is it possible to write contents <- getDirectoryContents getCurrentDirectory in some way in one line? and not first write: dir <- getCurrentDirectory and then content <- getDirectoryContents dir
06:11:05 <Saizan> use =<<
06:11:20 <mjrosenb> gienah: of course, why would the package be called 'CloudHaskell' or anything like that
06:11:28 <Saizan> contents <- getDirectoryContents =<< getCurrentDirectory
06:12:19 <applicative> fenfrie: this is excellent style ^^^
06:13:48 <fenfrie> applicative: it ironic i think or? why sould i dont do it this way?
06:14:13 <applicative> fenfrie: no, not ironic, i was meaning what Saizan did was good
06:16:36 <applicative> fenfrie: if you need the x in  " x <- action " right away, and it's input for what's next, you can usually do with "x <- action ; nextAction x" its nextAction =<< action or action>>= nextAction
06:17:38 <fenfrie> okay
06:18:23 <applicative> fenfrie: or if it's do {x <- action; y <- nextAction x ; ... y...}  you can do: "do {y <- (action >>= nextAction) ; .... y ...}
06:18:46 <fenfrie> okay i understood
06:20:38 <fenfrie> is it possible in haskell to make a default output for the user which he can edit in the command line? i mean for example the user want to edit a name, so i want to print tne name in the command line so he can edit it without writeing it new. he typed foo and want to edit it, so i print foo and let him edit so when he type a 1 it will be foo1 or delete one char it will be: fo
06:20:50 <fenfrie> and not if he write a 1 it will be: 1
06:27:20 <aristid> fenfrie: http://hackage.haskell.org/package/haskeline
06:40:05 <maurer_> fenfrie: http://hackage.haskell.org/package/haskeline-0.6.4.0
06:41:20 <maurer_> Oh, I'm an idiot, I see someone already posted that.
06:44:25 <ezyang> I wonder if you could teach category theory with the socratic method. 
06:45:50 <merijn> ezyang: Of course you can
06:46:02 <ezyang> What would the first question you ask be? 
06:46:06 <merijn> (You just read the article on teaching binary using the socratic method too? :>)
06:46:19 <ezyang> yeah, a friend showed me it. 
06:46:35 <merijn> ezyang: That depends on the knowledge the student has
06:46:51 <ezyang> The reason I ask is last year I gave a lecture on Haskell typeclasses, and it was really hard to make the knowledge stick. 
06:47:16 <merijn> In my experience it is impossible to teach people anything without at least *some* use of the socratic method
06:47:33 <ezyang> Oh sure. "They're called problem sets" 
06:47:53 <merijn> Problem sets are far from the socratic method
06:48:11 <merijn> At least, the once I often got anyway
06:48:39 <merijn> The entire point of the Socratic method is building on a students understanding by asking simple and leading questions to guide their own insight in the right direction
06:48:53 <merijn> Problem sets don't adapt to or interact with the student
06:49:03 <frerich> merijn, ezyang: Where is that article on teaching binary using the socratic method?
06:49:17 <merijn> frerich: http://www.garlikov.com/Soc_Meth.html
06:49:43 <frerich> merijn: Thanks
06:49:53 <merijn> #haskell utilizes the Socratic method reasonably often to explain things in my experience :>
06:51:25 <ezyang> IMO, the problem is usually finding the right question to ask. 
06:51:29 <ezyang> In both directions. 
06:51:51 <merijn> ezyang: Of course
06:52:31 <quicksilver> merijn: it's really hard to use the socratic method in #haskell
06:52:35 <merijn> Knowing what questions to ask is the hard part. It requires incredible mastery and understanding of the subject being taught and the ability to put yourself in your students shoes (i.e. what they know)
06:52:43 <quicksilver> merijn: bystanders with different amounts of knowledge to the target interject
06:52:52 <merijn> quicksilver: Yeah, people tend to blurt out answers when I'm trying to
06:52:59 <quicksilver> with annoying diversions about zygomorphism or unsafeperformIO ;)
06:53:01 <merijn> But occasionally it all comes together
06:54:39 <frerich> marijn: In my experience, the socratic method works poorly with people who have a sufficiently high degree of self-esteem (I don't want to say arrogance, though that might be more fitting). Once you 'transcend' the questions (as was done with that "How would an alien with two fingers do this?") to some seemingly silly realm, they ask you "Why would I care/why do you want to do that/some other question".
06:55:11 <scree> ezyang: my take is that if you can't teach someone something -- e.g. category theory -- using the socratic method, it's a good sign you shouldn't be teaching it to them yet, until they know some more motivation about it
06:55:27 <frerich> merijn: The more experienced students get (at least to a certain stage), the less they tend to see the use in temporarily moving away from the goal in order to approach it from a different angle (like a dog trying to get a bone at the other side of the fence, refusing to use the hole which is 15m away).
06:55:58 <ezyang> scree: I teach somewhat selfishly. I find it's a good way to solidify my knowledge. 
06:56:24 <merijn> frerich: Your questions are supposed to match the students level of understanding
06:56:35 <merijn> frerich: Smarter students require more advanced/complicated questions
06:57:46 <scree> ezyang: in that case, my comment reads: if *you* know enough of the motivation for something -- e.g. category theory -- you should be able to teach it to an hypothetical student with sufficient knowledge, using the socratic method
06:57:54 <frerich> merijn: Actually, I think the art in it is to not ask complicated questions but rather simple ones which ignite the right thoughts (which in turn may be very complex as far as consequences go).
06:58:20 <darrint> n00b epiphany: x = 3 or even let x = 3 in ... is not really "setting" a variable, I'm defining a function that takes no argument and always returns 3. Is that right?
06:58:22 <merijn> frerich: Oh, agreed. That is why the Socratic method is so hard :)
06:58:44 <merijn> darrint: It's not true, but for all practical purposes you can think of it like that
06:59:04 <darrint> merijn: Can you help me understand how it isn't true? I'm hoping to clarify my thoughts.
06:59:18 <merijn> darrint: There is no variable x. There is only a reference/name "x" and you have made x reference the constant 3
06:59:28 <merijn> And the constant 3 can obviously not change
06:59:34 <merijn> Therefore x cannot change
07:00:15 <ezyang> scree: Sure. And I argue that knowing how you might begin to teach a subject in the socratic method also means that you know more of the motivation for something. 
07:00:17 <mauke> darrint: all functions take exactly one argument
07:00:34 <mauke> I disagree with merijn in that x is a variable
07:00:35 <darrint> merijn: So I shouldn't think of x as a function since there is no argument? I'm trying to relate haskell functions to the little I know about mathematical functions that map elements from one set to another.
07:00:59 <scree> ezyang: agreed; they're equivalent in some sense
07:01:26 <merijn> darrint: You can think of it as telling the compiler that "x" is now a synonym for 3. Now obviously later stating that "x = 2" would make a synonym for 2 *and* 3 (which is nonsensical, obviously)
07:01:28 <ezyang> And so I ask, "What would the first question for teaching Category Theory with the Socratic Method" be. It would be, IMO, very enlightening. 
07:01:53 <merijn> ezyang: I wish I could tell you, but I still need to start figuring out category theory in the first place :p
07:02:09 <quicksilver> ezyang: Have you noticed that various bits of mathematics seem to have something in common?
07:02:21 <darrint> Are you all discussing the socratic discourse on binary numbers for elementary school children?
07:02:28 <merijn> darrint: Yes
07:02:42 <merijn> ezyang: I can tell you my motivation for wanting to learn category theory....
07:02:44 <quicksilver> (that would be my first question, probably requiring the student to have seen at least 2 or 3 difference pieces of abstract maths first)
07:02:45 <ezyang> quicksilver: "No." 
07:02:56 <quicksilver> ezyang: OK. Go back to school for a couple of years and we'll talk.
07:02:58 <merijn> (it's to understand the jokes people make in #haskell >.>)
07:02:58 <darrint> quicksilver: I'll bite. Yes.
07:03:00 <ezyang> :-) 
07:03:22 <quicksilver> unfortunately I don't have time to play the dialog out, darrint, I have a job to do :)
07:03:28 <quicksilver> I was just giving ezyang a first question.
07:03:34 <scree> ezyang: algebraic topology might be a nice starting point (not contradicting what quicksilver said)
07:03:36 <darrint> Nice though.
07:03:41 <merijn> More specifically you might want to explicitly mention several similar bits
07:03:46 <ksf_> ooooh acid-state seems nice
07:03:56 <ezyang> Yeah, it sucks that you need to know topology to have the most accessible bridge into category theory. 
07:04:15 <darrint> What would be the first question for topology I wonder?
07:04:18 <scree> ezyang: it's basically about functors from Top to Grp
07:04:28 <merijn> ezyang: I plan to brute force my way into understanding category theory from type theory
07:04:31 <ezyang> I'm kind of thinking there might be an interesting introduction using logic, posets and computation. 
07:04:43 <ksf_> which is a pity since I don't want to end up with a fried brain that tries to drink donuts and eat coffe cups.
07:04:47 <merijn> As soon as I am done wrestling the beast that is Conor McBride's writings...
07:05:09 <ezyang> Open sets have come in handy for understanding the distinction between intuitionistic and classical logic. 
07:05:18 <ezyang> :-) 
07:05:52 <ksf_> merijn, "Category Theory for Haskell Hackers" is a book that's still to be written.
07:06:11 <ksf_> or "The Haskell Road to Abstract Nonsense"
07:06:24 <darrint> I'd buy that one.
07:06:27 * hackagebot BNFC-meta 0.2.0.1 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.2.0.1 (JonasDuregard)
07:07:13 * ksf_ would contribute to a wikibook of that name, even.
07:07:27 <ksf_> in the function of a dumbwit.
07:09:43 <merijn> ksf_: I'm still planning on writing a "Type Theory for Dummies" book once I finish my literature study, so that'll have to come first :p
07:10:38 <ksf_> that sounds like a cromulent title for a book expanding on the first chapter of the haskell road to abstract nonsense
07:12:08 <bob31> is it only me on Darwin or is yi a little space heavy? 32-bit Darwin 7.0.3 fresh start >17MiB. that's with the vte frontend. MacVim has barely 10MiB for the Cocoa frontend
07:12:34 <Peaker> frerich, the view that   let x = ..  defines a "function" of 0 arguments is somewhat problematic (from a denotational view, at least).. What does this function return? A function of 0 arguments again?  
07:12:55 <ksf_> bob31, yes, it is.
07:13:03 <ksf_> at least last time I tried yi.
07:13:09 <bob31> ksf_: thanks.
07:13:22 <ksf_> it's not been optimised greatly, yet
07:13:32 <Peaker> frerich, http://conal.net/blog/posts/everything-is-a-function-in-haskell/
07:13:35 <bob31> I usually use GHC on Linux so have to ask about Mac
07:13:53 <ksf_> though components of it, like the incremental parser, certainly aren't designed without recource usage in mind.
07:14:06 <bob31> is it a mac-only visible issue that GHC builds take up a lot of space and time while building
07:14:11 <bob31> noticed while building yi
07:14:16 <frerich> Peaker: Err, I remember being in a discussion about this "When does considering a constant a function make sense", but wasn't that weeks ago? :-}
07:14:17 <bob31> and the custom built binary
07:14:31 <dixie> Can I put inline assembler in Haskell source code? </joke>
07:14:35 <ksf_> oh, space usage while building is a thing not unheard of.
07:14:41 <ksf_> especially linking can get ugly.
07:14:44 <bob31> 300 to 600 MiB processes with like as
07:14:55 <bob31> hmm, so maybe dyn-linking is maybe faster
07:15:11 <ksf_> that, and splitting up the source into more files
07:16:06 <bob31> btw, the llvm generator
07:16:36 <bob31> all the needed llvm code is part of the binary download on haskell.org, isn't it?
07:16:47 <bob31> I mean the LLVM libs etc.
07:17:06 <bob31> so having a newer set of LLVM somwwhere won't be of any benefit to GHC
07:17:40 <merijn> ksf_: Well yes, I actually kinda like the "Haskell Road to Abstract Nonsense", I'm making a note to potentially steal that
07:19:26 <merijn> ksf_: Mostly my pet peeve is that almost all things on type theory have apparently been written by, well....type theorists. And practically being mathematicians they seem to have really distorted views of what makes sense and what is interesting and why :p
07:19:38 <ksf_> bob31, ghc links to llvm statically iirc
07:20:35 <ksf_> wait, no. at least on gentoo, it uses vanilla llvm executables.
07:20:48 <ksf_> llvm is a PDEPEND, so it's installed after ghc.
07:21:13 <bob31> PDEPEND?
07:21:20 <ksf_> post-depend.
07:21:36 <bob31> it does still link to the DSOs or link-in the archives?
07:21:54 <ksf_> it's a variable in .ebuild files where you specify what should be installed after a package has been installed.
07:22:26 <bob31> hmm, interesting
07:22:34 <ksf_> for ghc, that's haskell-updater, syb and llvm.
07:22:47 <bob31> never could become friends with Gentoo but always likes USE flags
07:22:51 <ksf_> ...as opposed to DEPEND which are build dependencies, and RDEPEND which are run-time dependencies that should be installed before the package gets build.
07:23:00 <bob31> Exherbo seemed to be a sweet spot except the missing maturity
07:24:27 <ksf_> llvm comes with a zoo of executables which not only accept readable source but binary files, so there's no real need to link to it.
07:27:38 <bob31> except it may be faster with linking in LLVM's libs but with the time I could watch as do its thing I doubt it's noticeable at the moment :)
07:27:49 <bob31> thanks for the insight
07:28:38 <ksf_> I don't think passing data in memory or over a pipe buffer has a noticeable performance difference.
07:28:56 <ksf_> it's zero-copy in both cases.
07:29:34 <ksf_> (supposing your OS is half-way modern)
07:29:36 <Ke> what, zero copy pipes?
07:29:44 <Ke> does not happen
07:29:56 <Ke> only with vm_splice
07:29:57 <bob31> via splice syscalls?
07:30:01 <bob31> same thought
07:30:02 <ksf_> well, writing and reading yes, copying no.
07:30:23 <Ke> only shared memory is zero copy here
07:30:30 <ksf_> you write, when a page is full, the kernel mangles pointers
07:30:58 <ksf_> the idea of splice, after all, is to generalise pipe buffers to all fd's
07:31:20 <Ke> the writer still has the ownership of the page and can write on it
07:31:38 <ksf_> you can't e.g. splice from socket to socket or such directly, you have to splice via a pipe.
07:32:07 <ksf_> pipes can't be seeked backwards.
07:32:22 <ksf_> so once you write past a page boundary, the kernel can transfer ownership.
07:33:28 <ksf_> in the end the whole thing might use twice the memory because the whole thing is double-buffered, but then it's limited to two pages, unlike exchanging stuff via shared memory.
07:35:00 <ksf_> correction, the buffer size in linux is 64k.
07:35:14 <Ke> I fail to see how passing some ownership in kernel memory is zero copy, if you still have to copy from and to userspace
07:35:56 <ksf_> the kernel maps the memory into userspace?
07:36:10 <ksf_> we got virtual memory, these days.
07:36:14 <Ke> there are no unaligned mappings afaik
07:36:20 <ksf_> hardware-accelerated, even.
07:36:28 <amitava> hi all - what's the tilde for in swap ~(x,y) = (y,x)?
07:36:34 <Ke> and read and write do not expect aligned poitners
07:36:44 <ksf_> yes, but as soon as the data you transfer has a significant size you can always get full pages.
07:36:45 <Ke> pointers
07:37:06 <ksf_> that's not more reads that writing to and reading from shared memory.
07:37:24 <ksf_> sendfile, too, reads and writes.
07:37:54 <ksf_> zerocopy is about eliminating unnecessary copying, not about performing magic.
07:38:06 <Berengal> I have a suggestion for library authors: Instead of tagging non-function members of classes with a useless type argument (e.g. sizeOf :: a -> Int where the result is expected to be constant for all arguments and the only argument ever used will be undefined) use a newtype with a phantom type instead, like "newtype Size a = Size Int; sizeOf :: Size a"
07:38:09 <hpc> amitava: ~pat means that pat always matches
07:38:13 <ksf_> and memory can only be mapped in full pages
07:38:32 <hpc> amitava: but if it turns out the pattern doesn't actually match, it errors
07:38:35 <Berengal> (Good idea or bad idea?)
07:38:39 <ksf_> (and last I looked VM_GIFT was broken on linux)
07:38:41 <hpc> amitava: in this case, it gives extra laziness
07:38:55 <hpc> > let x = undefined in case x of ~(x,y) -> 5
07:38:56 <lambdabot>   5
07:39:07 <hpc> > let x = undefined in case x of (x,y) -> 5
07:39:08 <lambdabot>   *Exception: Prelude.undefined
07:39:53 <amitava> is this for performance aid only or it has wider use cases?
07:40:05 <mauke> newtype Phantom a b = P b
07:40:20 <mauke> amitava: how does it help performance?
07:40:21 <hpc> no, it changes the meaning of functions
07:40:29 <hpc> as i demonstrated above
07:41:31 <amitava> ah - so we are hinting to the pattern matcher to not eagerly evaluate the pattern?
07:41:49 <sipa> not hinting
07:42:31 <hpc> hmm
07:42:50 <hpc> > let x = undefined in let (a, b) = x in 5
07:42:51 <lambdabot>   5
07:45:05 <Jafet> Function call patterns are strict; I don't know which else
07:45:16 <Jafet> I think do arrows are, too
07:45:21 <mauke> "function call patterns" are case
07:45:30 <ksf_> not really.
07:45:36 <ksf_> they're cases of tuples, semantically
07:45:48 <ksf_> at least in my mind's version of the report
07:47:06 <quicksilver> cases with multiple scrutinees, yes
07:47:07 <ksf_> I wouldn't call it strict, either, it more about being able to inspect argument 3 before argument 1.
07:47:30 <quicksilver> they are 'strict patterns' - which is a technical term
07:47:34 <ksf_> as otherwise multi-arg pattern matching would be horribly broken
07:47:54 <quicksilver> a strict pattern forces all the constructors named in it - at all depths
07:48:18 <quicksilver> at the instant that equation is 'considered'
07:48:22 <fenfrie> how can i get the directory contents e.g. for C:? when i make getDirectoryContents "C:" i get the currentdirectory contents
07:48:31 <quicksilver> (but equations are 'considered' in order)
07:48:39 <ksf_> :t getDirectoryContents
07:48:40 <lambdabot> Not in scope: `getDirectoryContents'
07:48:44 <mauke> fenfrie: "C:/"
07:48:45 <ksf_> @hoogle getDirectoryContents
07:48:45 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
07:49:37 * ksf_ wonders whether he can just replace openshake's db mvar with acid-state without considering semantics
07:49:51 <quicksilver> if it compiles, ship it!
07:50:41 <ksf_> currently openshake only writes the db when the build is successful, which is in principle fixable by catching exceptions, but acid-state sounds like the cleaner solution.
07:51:18 <ksf_> well, catching exceptions and hoping that the exception contains a pointer to the db.
07:51:52 <ksf_> what am I talking about, the function in question holds on to the mvar itself.
07:52:22 <quicksilver> acid-state (or things like it) is the way to go for robust tools I think.
07:52:30 <ksf_> yep.
07:53:03 <ksf_> especially considering the length one would have to go to to make openshake's current approach parallel-safe.
07:53:14 <ksf_> that is, running multiple shakes in parallel.
07:54:02 <ksf_> though, admittedly, that's of questionable value.
07:54:35 <quicksilver> you do the shakey shakey shakey
07:54:36 <ezyang> > (- 2) 
07:54:36 <lambdabot>   -2
07:54:43 <ezyang> > (-2) 
07:54:44 <lambdabot>   -2
07:54:48 <ezyang> > (- 2) 3 
07:54:49 <lambdabot>   -2
07:54:57 <ezyang> (2 -) 3 
07:55:01 <ezyang> > (2 -) 3 
07:55:01 <lambdabot>   -1
07:55:15 <ezyang> very curious. 
07:55:19 <Jafet> > (:-)
07:55:20 <lambdabot>   Not in scope: data constructor `:-'
07:55:35 <aavogt> > (-2) == (- 2)
07:55:35 <lambdabot>   True
07:55:45 <ksf_> telling an already-running shake to add another target to build to its queue makes more sense, as it scales parallel rule invocations to the number of cpus
07:55:58 <ezyang> > (+ 2) 3 
07:55:58 <lambdabot>   5
07:56:05 <ezyang> > (- 2) 3 
07:56:06 <lambdabot>   -2
07:56:11 <ezyang> :-( 
07:56:11 <aavogt> > 2 3
07:56:12 <lambdabot>   2
07:56:15 <aavogt> you missed that?
07:56:16 <ksf_> inspecting the db with a separate process, though, would make sense.
07:56:25 <ezyang> oh right ,this is Caleskell. 
07:57:15 <ksf_> leksah and yi could do such a thing while a shake is running in the background, listening for file changes and constantly rebuilding, to get a hold on compiler warnings etc.
07:57:57 <ksf_> not to mention hlint.
07:58:46 <ksf_> I don't wanna know what lemmih smoked when deciding to hard-code the state directory, though.
08:00:28 <carkh> hello, i have a small question (hoping that's the place to ask)
08:00:48 <carkh> i have this function : addFileState (CompState states) (FileState (Just s) requires lines) =  CompState (Map.insert s (FileState (Just s) requires lines) states)
08:00:52 <carkh> it does the job
08:01:24 <carkh> but there's the part where i deconstruct FileState, only to reconstruct it in the body of the function
08:01:35 <lunaris> carkh: Use an at pattern
08:01:55 <lunaris> addFileState (CompState states) fs@(FileState (Just s) requires lines) =  CompState (Map.insert s fs states)
08:01:58 <carkh> ah ! i knew there was somthing =)
08:02:08 <carkh> yay thanks !
08:02:34 <lunaris> carkh: If this happens a lot, consider writing a higher order function.
08:03:00 <carkh> mhh what do you mean ?
08:03:44 <lunaris> Actually, ignore me.
08:03:57 <carkh> hehe ok, hanks anyways !
08:03:59 <lunaris> I was thinking, if you reach inside the CompState a lot, change the insides and put it back.
08:04:12 <lunaris> Then perhaps write a function that does the reach in, put back bit.
08:04:22 <lunaris> But to be honest I'm needlessing complicating things.
08:04:38 <carkh> right, well in this case anyways that's a one time "mutation"
08:04:44 <lunaris> Indeed.
08:04:47 <lunaris> Seems fine.
08:05:37 <ezyang> :t neg 
08:05:38 <lambdabot> Not in scope: `neg'
08:05:42 <ezyang> :t negate 
08:05:43 <lambdabot> forall a. (Num a) => a -> a
08:06:58 * roconnor loves refactoring code to eliminate error statements
08:07:50 <lunaris> ezyang: The results above are due to lambdabot's instances for Num (a -> b), right?
08:08:01 <ezyang> yeah. 
08:08:02 <frerich> Somehow 'Maybe' is an ugly duckling.
08:08:19 <lunaris> Sir, ye forget yourself.
08:08:20 <roconnor> frerich?
08:08:40 <roconnor> @type maybe
08:08:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:08:57 <prayzon435> hi guys, i wonder if some of you want to helop me with leaning programming in haskell, 
08:09:17 <prayzon435> and if some of you know how to hack other computers with is then please tell me :d
08:09:33 <brbr> hi #haskell
08:09:54 <brbr> I'm working through functors in LYAH... and they're cool, but are they really useful?
08:09:55 <hpc> prayzon435: you are totally new to programming, aren't you?
08:09:57 <roconnor> prayzon435: the network library in Haskell is a POS
08:10:03 <hpc> brbr: extraordinarily useful
08:10:08 <hpc> :t map
08:10:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:10:10 <hpc> :t fmap
08:10:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:10:16 <hpc> map = fmap
08:10:25 <Apocalisp> :t (.)
08:10:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:10:29 <brbr> hpc: they just seem like a sugared version of map with some type constructor and a function
08:10:29 <prayzon435> hpc and roconnor - yes totaly new ! and what is a POS?
08:10:43 <hpc> brbr: (.) = fmap too
08:10:44 <mauke> brbr: map already has a type constructor and a function
08:10:57 <mauke> prayzon435: why haskell?
08:10:58 <roconnor> piece of s#*!
08:11:05 <mauke> did you mean: shit
08:11:19 <prayzon435> mauke: because all says that it is a really goo program
08:12:34 <brbr> are functors useful because they're easier to use with complex data types where you want to specify exactly what fmap does for each pattern matched in that data ?
08:12:41 <roconnor> if prayzon435 is totally new to programming he is way ahead of most people who come here to start :D
08:13:06 <lunaris> brbr: Do you program in other languages?
08:13:11 <hpc> brbr: what fmap does is let you apply a function to the "inside" of a thing
08:13:24 <hpc> brbr: so say you wanted to read something that wasn't a string from stdin
08:13:30 <hpc> brbr: that would be "fmap read getLine"
08:13:30 <prayzon435> roconnor: im totaly new and i allmost don't know anything :d
08:13:33 <brbr> lunaris: yeah, c, python..
08:13:41 <lunaris> brbr: Functors are a design pattern.
08:13:55 <lunaris> brbr: So, in Python, you might use various OO design patterns, like visitor, etc.
08:13:57 <roconnor> what is the standard reference for learning haskell for non-programmers?
08:13:59 <mauke> hpc: or readLn
08:14:06 <hpc> roconnor: still lyah imo
08:14:08 <lunaris> brbr: In Haskell/functional languages, you have things like Functors.
08:14:12 <hpc> @src readLn
08:14:12 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
08:14:15 <roconnor> hpc: really?
08:14:17 <lunaris> brbr: They provide a layer of abstraction.
08:14:33 <lunaris> brbr: map is great, but let's say you decide to rewrite your awesome list-using application to use trees.
08:14:36 <roconnor> I'd think you could take advantage of the fact that one isn't spoiled by mutation
08:14:48 <roconnor> or other operational thinking
08:14:50 <hpc> roconnor: lyah doesn't have much that assumes prior programming experience
08:14:57 <lunaris> brbr: Now you'd have to write a function treeMap :: (a -> b) -> Tree a -> Tree b and replace all occurences of map with treeMap
08:15:00 <hpc> except perhaps the parts about getting ghci to work
08:15:00 <aavogt> anybody else seen the haskell road?
08:15:13 <lunaris> brbr: Or, you could use fmap everywhere.
08:15:15 <brbr> hpc: and defining an instance of Functor where you define fmap allows you to apply f to whatever you want to apply it to deeper inside your type constructor?
08:15:19 <brbr> if that makes any sense at all..
08:15:21 <lunaris> brbr: Then, if you come to switch, you just make Tree an instance of functor.
08:15:31 <lunaris> brbr: If that helps at all </crosstalk>
08:15:42 <aavogt> I mean read this book http://homepages.cwi.nl/~jve/HR/
08:15:48 <prayzon435> listen.... im totaly new, and all i wan't to know is ? can i hack other computer or systems with haskell and how ?
08:16:03 <pmetzger> totally new at programming?
08:16:13 <hpc> prayzon435: do you want to learn to program, or do you want to hack other computers?
08:16:24 <prayzon435> pmetzger:yes
08:16:28 <hpc> one we can teach, the other is not even remotely close to what movies make it look like
08:16:48 <merijn> Hacking computers is extremely boring and has a good chance of jailtime :>
08:16:50 <pmetzger> The other involves a ridiculous amount of dedication to learning incredibly boring things.
08:17:01 <prayzon435> hpc: i want to hack other computer and i have been told that i could use haskell for is , just wanna know how
08:17:04 <merijn> pmetzger: So, it's really a toss up :D
08:17:09 <mauke> prayzon435: who told you that?
08:17:13 <hpc> prayzon435: same way you would use any other language
08:17:14 <pmetzger> It doesn't involve much chance of jail time if you are a white hat and are doing it in a research context.
08:17:34 <pmetzger> Or if you are a white hat and are doing it in the context of pen testing.
08:17:34 <roconnor> pmetzger: there is still some
08:17:41 <hpc> prayzon435: this is a haskell-specific channel; questions on hacking should go somewhere else
08:17:52 <merijn> hpc: Like the FBI :>
08:17:55 <hpc> haha
08:18:00 <prayzon435> hpc: sorry
08:18:02 <pmetzger> roconnor: no one I know on the academic side of things has ever gotten in serious trouble and I know a lot of people in the area. it is my profession.
08:18:16 <prayzon435> mauke: a guy from a php chat.
08:18:20 <roconnor> pmetzger: what happend to whats his name printing fake boarding passes?
08:18:21 <brbr> lunaris: so switching from lists to Tree would be as easy as making Tree a instance of functor and defining fmap to apply f to your "stuff" that is inside a Tree ?
08:18:21 <mauke> haha
08:18:46 <mauke> so a random guy from ##php told you "learn haskell, it's great for h4x"
08:18:49 <pmetzger> anyway, learning haskell will not help you learn about cracking systems, but it will improve your abilities as a computer scientist.
08:18:58 <prayzon435> hpc: what language?
08:19:05 <hpc> prayzon435: doesn't matter
08:19:08 <pmetzger> mauke: someone was probably pulling his leg that way I'd guess.
08:19:22 <merijn> pmetzger: What's his name from the University of Waterloo (security researcher) gets detained almost every single time he crosses the US borders. And I know other security researchers get hassled a lot (electronics confiscated, etc)
08:19:24 <hpc> pmetzger: or long-distance trolling
08:19:29 <prayzon435> hpc: okay
08:19:44 <merijn> I heard Forth and J are great for hacking
08:19:46 <pmetzger> merljn: I know lots of people who get detained all the time, but that's usually political.
08:20:02 <hpc> i heard intercal is great for hacking
08:20:06 <pmetzger> not because of security research per se.
08:20:09 <merijn> hpc: Oh yeah, very true
08:20:20 <roconnor>  /join #intercal
08:21:20 <pmetzger> ioerror gets detained every time he crosses the US border because of his work with Wikileaks, but it isn't because of his computer security research, it is pure political harassment.
08:21:21 <brbr> can you define more than just fmap in a functor?
08:22:01 <ksf_> when it comes to becoming a white-hat hacker, I'd recommend joining the ccc.
08:22:43 <aavogt> brbr: you can specify that your type must be in many classes
08:22:53 <ksf_> not that they'd be less forgiving for failure to do one's own research as the rest, but at least you have an initial and very capable environment
08:23:15 <hpc> brbr: you can also write other functions in terms of fmap
08:23:22 <pmetzger> I find the best situation is to be in academia and to do legitimate academic research. :)
08:23:35 <roconnor> what pmetzger says
08:23:35 <luite> hmm, ccc isn't strictly white hat right?
08:23:38 <ksf_> especially go there if you want to become a black-hat, because they love a low-life to bash, once in a while.
08:24:01 <ksf_> it may be somewhat light-greyish.
08:24:34 <ksf_> that is, during their conferences, you will probably see a lot of defaced nazi sites.
08:24:58 <mauke> that's not necessarily ccc members
08:25:02 <pmetzger> the other trick is to make sure that if you ever do any pen testing, there are written permissions on the written permissions on the written permissions.
08:25:21 <ksf_> yes, but it's not statistically independent, either.
08:25:27 <luite> I usually do some pen testing when selecting pens to use for an exam
08:25:45 <brbr> aavogt: what do you mean?  when defining fmap, pattern match the type constructor with other data's ?
08:25:47 <ksf_> the bulk of the hacks they do are pure white-hat, though.
08:25:58 <pmetzger> one doesn't want to end up like Randall Schwartz.
08:26:23 <luite> does white-hat necessarily mean legal?
08:26:36 <ksf_> though, historically, they don't seem to be shy of calling a bank saying "we got 10k euros of yours, but don't worry, we don't want to keep them" to get the postal service to listen to their security concerns.
08:26:40 <mauke> pmetzger: yeah, I wouldn't want people to constantly misspell my name :-)
08:26:57 <pmetzger> yah, I put an extra L in didn't I. :)
08:27:00 <FauxFaux> luite: I'm not sure if asking for money to reveal exploits is legal.
08:27:26 <aavogt> brbr: you get around   (Functor t) =>  being really boring by writing in your type (or having inferred)   (Functor t, C1 t, C2 t) => ...
08:27:28 <pmetzger> his fault for not using the more common spelling! :)
08:27:28 <ksf_> they never did that as far as I know
08:28:09 <hpc> :t \f x y -> f <$> x <*> y
08:28:10 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
08:28:21 <hpc> hmm, so much for that example
08:28:28 <luite> hmm, ubuntu devs certainly liked os x, judging from their unity interface
08:28:30 <hpc> :t \f x y -> point f <*> x <*> y
08:28:31 <lambdabot> Not in scope: `point'
08:28:56 <brbr> :.
08:28:59 <brbr> :t .
08:29:00 <lambdabot> parse error on input `.'
08:30:06 <hpc> :t (.)
08:30:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:30:07 <lunaris> :t \f x y -> pure f <*> x <*> y
08:30:08 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
08:30:20 <hpc> :t \f x y -> return f <*> x <*> y
08:30:21 <lambdabot> forall a a1 b (f :: * -> *). (Monad f, Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
08:30:23 <hpc> there we go
08:30:25 <lunaris> :t liftA2
08:30:25 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:30:39 <hpc> and that's multiple typeclass constraints
08:30:48 <lunaris> Oh, I see.
08:30:51 * lunaris is an idiot
08:30:52 <ksf_> to answer the question whether the ccc is white-hat from another angle: they kicked out the people responsiblefor the kgb hack
08:31:57 <osoleve> what does "Couldn't match expected type 'WAVE' with actual type 'f0 b0'" mean?
08:32:02 <Skola> if you had to discribe a really simple function that returns a boolean, would you use the word "whether"? ie. -- "returns whether x is y"?
08:32:11 <boegel> is there a way to obtain the map function from the string "map" in Haskell? (likewise for other functions of course)
08:32:28 <Skola> it feels a bit clumsy
08:32:34 <pmetzger> skola: it is a little ambiguous.
08:32:47 <hpc> boegel: yes
08:32:47 <ksf_> boegel, hint
08:32:53 <pmetzger> skola: I'd rather say "returns true iff x is y"
08:32:54 <cheater_> Skola: "is a"
08:32:55 <hpc> :t hint
08:32:56 <lambdabot> Not in scope: `hint'
08:32:59 <ksf_> also, TH, to some degree
08:33:02 <ksf_> it's a package.
08:33:08 <cheater_> or "is"
08:33:11 <boegel> ksf_: hint as in, the function hint?
08:33:17 <boegel> ksf_: ah, cool
08:33:19 <hpc> doing that sort of thing in haskell is a headache the size of the moon though
08:33:20 <ksf_> hint as http://hackage.haskell.org/package/hint
08:33:32 <boegel> ksf_: TH doesn't work for me, I need to be able to do this at runtime
08:33:44 <ksf_> use hint.
08:33:44 <Skola> pmetzger, cheater_ both good ideas
08:33:49 <lunaris> :t Language.Haskell.Interpreter.interpret
08:33:50 <lambdabot> forall a (m :: * -> *). (hint-0.3.3.1:Hint.Base.MonadInterpreter m, Typeable a) => String -> a -> m a
08:34:01 <boegel> ksf_: I'll check it out, thanks
08:34:20 <lunaris> > runInterpreter (loadModules ["Prelude"] >> interpret "map not [False,True]")
08:34:21 <lambdabot>   Not in scope: `runInterpreter'Not in scope: `loadModules'Not in scope: `int...
08:34:26 <hpc> osoleve: it means you have a type error somewhere
08:34:42 <lunaris> > Language.Haskell.Interpret.runInterpreter (Language.Haskell.Interpreter.loadModules ["Prelude"] >> Language.Haskell.Interpreter.interpret "map not [False,True]")
08:34:42 <lambdabot>   Not in scope: `Language.Haskell.Interpret.runInterpreter'Not in scope: `Lan...
08:34:45 <boegel> ksf_: seems exactly what I want, thanks!
08:34:47 <lunaris> Oh well
08:34:48 <lunaris> :)
08:35:13 <hpc> osoleve: somewhere it expected to find the type WAVE, and instead got f0 b0, which looks like you aren't using type signatures in your code
08:35:14 <boegel> > Language.Haskell.Interpret.runInterpreter (Language.Haskell.Interpret.loadModules ["Prelude"] >> Language.Haskell.Interpret.interpret "map not [False,True]")
08:35:16 <lambdabot>   Not in scope: `Language.Haskell.Interpret.runInterpreter'Not in scope: `Lan...
08:35:37 <boegel> > Language.Haskell.Interpreter.runInterpreter (Language.Haskell.Interpreter.loadModules ["Prelude"] >> Language.Haskell.Interpreter.interpret "map not [False,True]")
08:35:38 <lambdabot>   Not in scope: `Language.Haskell.Interpreter.runInterpreter'Not in scope: `L...
08:35:38 <hpc> osoleve: without seeing the code, my advice is to put signatures on all your functions and see if the error improves
08:35:40 <ksf_> probably locked out of lambdabot
08:35:48 <ksf_> ...due to side-effects etc.
08:35:51 <lunaris> boegel: Best to GHCI with :m +Language.Haskell.Interpret
08:36:00 <boegel> lunaris: yeah, probably :)
08:36:04 <lunaris> boegel: As ksf_ says, perhaps too much potential for malice with lambdabot
08:36:06 <boegel> thx for the tips guys
08:36:19 <osoleve> hpc: i have one function with no type signature, that's probably it. thanks.
08:36:45 * ksf wonders how to properly do a map with acid-state.
08:36:51 <ksf> the examples only include single values
08:36:52 <luite> hint will make your executable hueg though
08:37:07 <ksf> and serialising the whole map each update doesn't seem like a good idea
08:37:42 <barshirtcliff> how can one make a class instance that returns a function?
08:37:51 <barshirtcliff> or is that okay?
08:37:52 <lunaris> luite: Unless you use libffi to dynamically link it in...
08:38:02 <mauke> barshirtcliff: wat
08:38:06 <lunaris> barshirtcliff: Class instances don't return anything.
08:38:14 <lunaris> barshirtcliff: You can make a functional type a class instance though.
08:38:18 <lunaris> barshirtcliff: If that's what you mean
08:38:19 <barshirtcliff> well, I mean a function within it.
08:38:28 <lunaris> barshirtcliff: Example?
08:38:30 <mauke> functions can return functions
08:38:31 <barshirtcliff> yes, that sounds right
08:38:34 <mauke> (most of them do)
08:38:49 <ksf> foo -> bar -> baz is a function that takes one parameter and returns a function from bar to baz, if that is what you mean.
08:39:08 <barshirtcliff> lunaris: how can I make a functional typeclass like that?
08:39:20 <lunaris> barshirtcliff: Lambdabot has one example: instance Num (a -> b)
08:39:22 <lunaris> :t 2
08:39:23 <lambdabot> forall t. (Num t) => t
08:39:25 <lunaris> :t 2 3
08:39:26 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
08:39:28 <lunaris> > 2 3
08:39:29 <lambdabot>   2
08:39:33 <mauke> barshirtcliff: like with any other type
08:39:42 <lunaris> barshirtcliff: Here, fromInteger :: Integer -> (a -> b)
08:39:48 <hpc> hmm
08:39:51 <hpc> > 2.0 3.0
08:39:51 <lunaris> And fromInteger = const
08:39:52 <lambdabot>   2.0
08:39:53 <barshirtcliff> okay.  hm. 
08:39:57 <hpc> :t 2.0 3.0
08:39:59 <lambdabot> forall t t1. (Fractional (t1 -> t), Fractional t1) => t
08:40:10 <lunaris> So (fromInteger 2) 3 = const 2 3 = 3
08:40:13 <ksf> what's the point of that instance?
08:40:13 <barshirtcliff> okay that's a lot of help.  I'll work with this.
08:40:27 <hpc> ksf: to confound people
08:40:34 <hpc> also, for vector math
08:40:41 <azaq23> > (sin^2) $ 0.5
08:40:42 <lunaris> ksf: Annoying people who expect lambdabot and GHC(i) to agree.
08:40:43 <lambdabot>   0.22984884706593015
08:40:48 <hpc> > let one = sin^2 + cos^2 in one 1
08:40:49 <lambdabot>   1.0
08:40:50 <lunaris> ksf: Or, playing cards.
08:40:51 <hpc> > let one = sin^2 + cos^2 in one 100000
08:40:53 <lambdabot>   0.9999999999999999
08:41:13 <barshirtcliff> hm.  can I have such a functional typeclass that takes a variable number of different kinds of arguments?
08:41:17 <lunaris> As in data Suit = H | C | D | S; 2 S can actually be turned into the two of spades with some plumbing.
08:41:43 <ksf> yeah, but that's syntactic hacksugar.
08:41:44 <lunaris> barshirtcliff: Welcome to the inner circle.
08:41:58 <brbr> I LOVE FUNCTORS!
08:42:20 <lunaris> brbr: Good.
08:42:29 <barshirtcliff> ksf: hm.  I want the syntactic hacksugar.
08:42:35 <lunaris> http://okmij.org/ftp/Haskell/polyvariadic.html
08:42:38 <lunaris> Enter the void.
08:43:03 <barshirtcliff> lunaris: thanks (reading)
08:43:16 <lunaris> barshirtcliff: Assuming I've interpreted your request correctly.
08:43:28 <barshirtcliff> lunaris: looks like it. 
08:43:29 <lunaris> If you want a ``polyvariadic typeclass'' then I think you'll need an HList or similar.
08:43:47 <lunaris> You're still in the void however.
08:43:49 <lunaris> But I like it here.
08:43:51 <lunaris> It's comfy.
08:43:52 <barshirtcliff> lunaris: okay, good.  why the void?
08:43:57 <azaq23> barshirtcliff: A function a -> b -> c is actually a function a -> (b -> c), so a -> b subsumes all functions. AFAIK You can only make sensible instances for a -> b.
08:44:05 <barshirtcliff> :lunaris is it no longer pure?
08:44:12 <lunaris> I'm just expressing the fact that it's a particularly `cheeky' use of typeclasses.
08:44:19 <lunaris> It's as pure as you make it.
08:44:38 <lunaris> Don't worry, it's a perfectly fine technique.
08:44:46 <lunaris> (IMO)
08:46:53 <ksf> barshirtcliff, have a look at http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
08:51:45 <tafryn> Are there any libraries similar to http://excess.org/urwid/ for haskell?
08:52:14 <ksf> yep
08:52:20 <ksf> there's vty, and also ncurses bindings
08:54:24 <Entroacceptor> doesn't cabal use http_proxy?
08:54:33 <dcoutts> it does, yes
08:55:11 <Entroacceptor> mhmm
08:55:23 <ksf> tafryn, in particular, have a look at http://hackage.haskell.org/package/vty-ui
08:55:24 <dcoutts> obviously it has to be a valid URL
08:55:38 <Entroacceptor> ok, then hackage was just slow ^^
08:56:00 <dcoutts> :-) or your proxy
08:56:16 <Entroacceptor> it's an ISA, it can't be slow ^^
08:56:37 <Entroacceptor> yeah, maybe
08:56:45 <wlangstroth> anyone here used Takusen?
08:56:46 <Entroacceptor> the total lack of feedback got me
08:56:48 <tafryn> ksf: There we go. vtf and ncurses are more low level than what I was looking for, but vty-ui seems to be what I was looking for.
08:57:02 <tafryn> ksf: Thanks.
08:59:58 <dfilimon> why does ghci print "\n" like "\n"
08:59:59 <dfilimon> ?
09:00:03 <dfilimon> shouldn't it print a newline?
09:00:12 <ksf> depends.
09:00:23 <sipa> :t putStr
09:00:23 <ksf> it does print a newline when you putStr the string
09:00:24 <lambdabot> String -> IO ()
09:00:25 <dfilimon> ah, 
09:00:28 <dfilimon> i used an extra show
09:00:32 <sipa> putStr "\n" will print a newline
09:00:38 <sipa> show "\n" will print "\n"
09:00:40 <ksf> > show . show . show . show ""
09:00:41 <sipa> eh
09:00:42 <lambdabot>   ["\"\\\"'\\\\\\\"'\\\"\"","\"\\\"'\\\\\\\"'\\\"\""]
09:00:43 <ksf> > show . show . show . show $ ""
09:00:44 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
09:01:11 <dfilimon> more like: putStr $ concat $ intersperse "\n" $ map show $ combinations 5 [1..7]
09:01:38 <Jafet> > iterate show ""
09:01:39 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
09:02:02 <ksf> it's called the backslash backlash.
09:04:37 <FauxFaux> > iterate show "," -- Jafet
09:04:38 <lambdabot>   [",","\",\"","\"\\\",\\\"\"","\"\\\"\\\\\\\",\\\\\\\"\\\"\"","\"\\\"\\\\\\\...
09:04:44 <ksf> Lemmih, syn
09:10:37 <tafryn> When cabal says "There is no available version of ghc that satisfies -any" is it telling me that I need ghc 7?
09:11:18 <ksf> now that's a strange error
09:11:20 <dcoutts> tafryn: no, it's saying the 'ghc' package is not installed at all, which means you're missing part of your ghc install
09:11:44 <tafryn> I'm pretty sure ghc is there. I'm running ghci right now.
09:12:06 <dcoutts> tafryn: this is the Haskell package called 'ghc' not the program.
09:12:25 <dcoutts> tafryn: as in the things registered via ghc-pkg, if you do ghc-pkg list, you'll find that 'ghc' is missing
09:12:27 <tafryn> Ah, how confusing.
09:12:51 <dcoutts> tafryn: did you get your ghc from a distro package? does the distro split ghc up into multiple bits, all the core libs separately?
09:13:26 <dcoutts> if your distro packages the 'ghc' library separately then it's possible you don't have it installed
09:13:48 <dcoutts> alternatively, it could be that you've somehow broken your ghc package by unregistering one of its dependencies
09:13:54 <chridi> hmh.. thats maybee a stupid question, but do i have something like regexps in haskell?
09:14:11 <chridi> or should i do everything with pattern matching?
09:14:11 <tafryn> dcoutts: Yes, yes, and ghc is a separate library. However, it is installed.
09:14:23 <dcoutts> tafryn: does ghc-pkg check say anything about it?
09:14:23 <Entroacceptor> chridi: there are regexps
09:14:29 <tafryn> dcoutts: It does not.
09:14:41 <Entroacceptor> but it's quite easy to write a parser 
09:14:43 <tafryn> Is there a way to reregister it?
09:15:01 <dcoutts> tafryn: when you do "ghc-pkg list ghc" does it list ghc, does it list it with funny brackets?
09:15:09 <Entroacceptor> chridi: http://www.haskell.org/haskellwiki/Regular_expressions
09:15:51 <chridi> Entroacceptor: thanks
09:16:33 <chridi> but i think ill do it directly in haskell
09:16:34 <tafryn> dcoutts: No, 'ghc-pkg list ghc' only shows a pair of paths ending in package.conf.d.
09:16:35 <barshirtcliff> what does the tilde mean in :  Could not deduce (ty1 ~ [Char])  ?
09:16:48 <dcoutts> tafryn: ok, so it's not registered at all
09:16:55 <dcoutts> tafryn: you're not on fedora are you?
09:16:55 <barshirtcliff> lunaris: I'm still trying to stay out of the void.  we shall see.
09:17:05 <tafryn> dcoutts: RHEL, unfortunately.
09:17:26 <Liskni_si> how can I prevent the strictness analyzer from marking one of my parameters as strict?
09:17:30 <dcoutts> tafryn: I've seen cases where the fedora ghc packages do not include the ghc library
09:17:53 <tafryn> dcoutts: There's a package for it, ghc-ghc, and it is installed...
09:17:57 <dcoutts> tafryn: check if your distro packages provide the ghc library separately from the main ghc compiler package
09:18:24 <ksf> barshirtcliff, type equality
09:18:30 <ksf> it's an spjism.
09:18:33 <dcoutts> tafryn: oh, could you use hpaste or something to show us a list of the files that rpm package provides
09:18:44 <barshirtcliff> ksf: thanks.  that's what I thought.
09:18:45 <tafryn> dcoutts: Sure, one sec.
09:20:53 <tafryn> dcoutts: http://hpaste.org/45687/rhel_ghc_packages
09:21:50 <dcoutts> tafryn: so you've got both ghc-ghc.i686 and ghc-ghc-devel.i686 installed right?
09:23:23 <mightybyte> Is there a package that provides a type class similar to Read but for ByteStrings?  Maybe something providing a function readBS :: ByteString -> Maybe a
09:23:25 <tafryn> Ugh. I thought I had both, but I'd neglected the -devel.
09:24:11 <monochrom> ByteString -> Maybe a sounds like Binary
09:24:28 <mightybyte> monochrom: Yeah, but not binary...more like Read.
09:24:49 <dcoutts> tafryn: ok, thanks for the info. I was not aware that the fedora/RHEL rpms split things up quite so thoroughly
09:25:46 <elliottt> mightybyte: cereal? :)
09:25:46 <monochrom> frankly, ByteString is binary data to me
09:26:37 <dcoutts> tafryn: I might suggest that you file a ticket to ask for the 'ghc' rpm to be made a meta-package that pulls in all the core -devel rpms so that one can actually use ghc :-)
09:26:39 <Lemmih> mightybyte: unpack + read? (:
09:26:41 <lunaris> mightybyte: read . unpack?
09:26:45 <lunaris> Damn you Lemmih
09:26:48 <mightybyte> lol
09:26:48 <lunaris> :)
09:26:53 <dcoutts> tafryn: I mean a fedora/RHEL ticket
09:27:02 <Lemmih> lunaris: That's a great mind you have there, buddy. :)
09:27:32 <tafryn> dcoutts: I don't think that ghc is included in the default RHEL repos. I think it's in the epel repos which aren't associated with Red Hat.
09:27:48 <dcoutts> tafryn: the splitting up makes sense as it allows things like darcs to depend on the runtime libs, without needing the compiler installed, but the compiler is mostly useless without all of the -devel packages for its standard libs
09:28:08 <dcoutts> tafryn: ok, well file the bug in the right place with whoever made those rpms
09:28:11 <Igloo> What's in ghc-ghc? The dynlib?
09:28:19 <dcoutts> Igloo: presumably
09:28:32 <dcoutts> fedora has been doing shared lib builds for a while
09:30:06 <Jafet> > concat $ [0]: fix (([1]:) . map (ap (++) $ map (1-)))
09:30:07 <lambdabot>   [0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,...
09:30:37 <tafryn> dcoutts: I appreciate the help, thanks.
09:30:45 <dcoutts> np
09:30:48 <winmike> hi
09:30:52 <Jafet> After implementing this definition, it feels kind of unnatural
09:31:11 <winmike> i got stuck with a simple problem "data TTree a = Node a (TTree a) (TTree a) (TTree a) | Nil" how can i add a second polymorph param to node? :-(
09:32:17 <Jafet> You want to add a second type parameter?
09:32:23 <Jafet> data TTree a b = ...
09:32:24 <winmike> yes
09:32:51 <winmike> hmm thx
09:33:10 <winmike> quite confusing
09:34:53 <ksf> Lemmih, can you tell me how to serialise k/v strings with acid-state and have a map as snapshot/query structure?
09:35:02 <ksf> If it's intended to be supported, I don't see how
09:41:24 <EvanR-work> so what are the prospects for running haskell on silence is defeat
09:41:36 <romanandreg> hey guys, what method can I use from QuickCheck to generate large values of an Arbitrary instance, without checking properties
09:41:37 <romanandreg> ?
09:42:19 <Lemmih> ksf: Sure. You essentially want to use a Map as your state?
09:42:47 <rothwell> EvanR-work: seems like zero as the site is down!
09:42:48 <ksf> you mean generating data in a particular shape without generating stuff and then throwing it away?
09:43:02 <rothwell> EvanR-work: ... it's back!
09:43:06 <EvanR-work> seems up to me
09:43:10 <ksf> Lemmih, yes. but as I see it it would write the whole map each time
09:43:36 <rothwell> EvanR-work: don't think ghc will fit into 50mb, though
09:43:37 <Lemmih> ksf: Only checkpoints serialize the entire state.
09:43:54 <Lemmih> ksf: You'd add transactions for looking up keys, adding keys, and so on.
09:44:20 <EvanR-work> 50M?
09:44:25 <Lemmih> ksf: Those transactions are saved to a logfile and re-run to recreate the state from the last checkpoint.
09:44:27 <ksf> so you're employing deep magic behind the scenes to break up my data into functions?
09:44:29 <rothwell> EvanR-work: unless that's only for their free accounts...
09:44:37 <Lemmih> ksf: Nope, you do that on your own.
09:44:42 <EvanR-work> i didnt know they had free accounts
09:44:59 <Lemmih> ksf: You aren't free to modify your state is any way you please. It can only be done through the 'update' and 'query' functions.
09:45:10 <EvanR-work> rothwell: in any case, its openbsd and a who knows what system
09:45:17 <ksf> well, then in the sense of employing magic by serialising effectively code insetad of the data
09:45:26 <Lemmih> ksf: And to use those functions you have to define a set of serializable transactions.
09:45:29 <ksf> in that case, I just got the idea wrong.
09:46:29 <ksf> and I'm going to use your lib, *provided* you promise to cease to hardcode the directory the db is stored in.
09:46:42 <ksf> or.... or...
09:46:49 <ksf> I'm gonna make lambdabot slap you.
09:47:10 <Lemmih> ksf: I absolutely promise to make it configurable. (:
09:48:13 <Lemmih> ksf: If you have any questions or comments, please don't hold back. I'd love some feedback.
09:48:26 <ksf> well, there's a lack of documentation
09:48:41 <ksf> otherwise, the library looks very nic.
09:49:09 <Lemmih> Documentation as in "here's a guide for using the library"?
09:50:00 <ksf> I wouldn't mind a howto, but a slightly more complex example and a high-level overview would be nice
09:50:58 <ksf> and, to stop people from falling into the same trap as me, saying "acid-state serialises your data by remembering what you intended to do with that data instead of remembering the results of that"
09:51:57 <Lemmih> ksf: What do you want to see in an example?
09:52:14 <ksf> well, a map would be nice
09:52:25 <ksf> ...which I might just code up this evening.
09:53:46 <ksf> btw, is the whole thing concurrency-safe?
09:54:04 <ksf> that is, can two processes access the same db safely at the same time?
09:54:54 <Lemmih> ksf: Yes, this is also mentioned in the haddock documentation.
09:56:16 <christo_m> semaphores ftw?
09:57:00 <ksf> well, it doesn't explicitely mention different processes as far as I see
09:57:54 <EvanR-work> christo_m: MVars!
09:58:20 <christo_m> EvanR-work: :( i dont know about all the nice things in haskell yet
09:59:01 <christo_m> !seen BMeph
10:04:04 <ksf> error:  Unsupported extension: GeneralisedNewtypeDeriving Perhaps you meant `GeneralizedNewtypeDeriving' or `NoGeneralizedNewtypeDeriving'  .oO( .. )
10:04:27 <Jafet> GHC, now excluding your middles
10:04:29 <ksf> I thought it was called the glourious glasgouw haskell compiler.
10:04:49 <lunaris> ksf: z, not s
10:05:02 <ksf> yeah. ghc can't spell.
10:05:10 <lunaris> ksf: Sorry, I meant to address Jafet
10:05:20 <lunaris> God I suck.
10:05:38 <Jafet> @quote generalis
10:05:38 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
10:10:26 <Lemmih> ksf: I've added a key/value example.
10:16:08 <gwern> I'd like to one day write the paper 'Monads for nothing (and theorems for free)'
10:16:37 <osoleve> nanothief: are you around?
10:17:20 <Lemmih> ksf: Have you used happstack-state in the past?
10:17:47 <lunaris> gwern: Free monads come for nothing, in some sense :)
10:19:45 <ksf> Lemmih, only ixset
10:20:09 <ksf> I was always put back by its dependencies and sheer complexity
10:20:25 <ksf> ...and sqlite does the job.
10:20:50 <Lemmih> ksf: Btw, I'll be changing acid-state to use cereal instead of binary very soon.
10:22:39 <ksf> that's a good idea
10:24:33 <Lemmih> I'm glad that library authors are starting to realise that lazy IO is fairly evil.
10:25:14 <Jafet> I don't think it's evil, as long as you know it's there
10:25:21 <Jafet> You can always seq it
10:25:26 <Jafet> (always?)
10:25:40 <copumpkin> deepseq!
10:26:06 <ksf> Lemmih, http://blog.johantibell.com/2011/01/merging-binary-and-cereal.html
10:26:25 <Blkt> good evening everyone
10:26:27 <ksf> while I fully support cereal, he has a point about merging cereal into binary and not the other way round
10:27:42 <Lemmih> Jafet: Not always.
10:27:57 <Jafet> length x `seq` x
10:28:15 * hackagebot digestive-functors-hsp 0.2.1 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.2.1 (JeremyShaw)
10:28:29 <tawe> I have a program that reads from the command line. I'm using WinHugs. I'm interested in make some fixed tests to the program. How could I choose the input and the output files of my program? I guess you understand what i mean.
10:28:49 <ksf> having NFData constraints on virtually everything is an eye sore
10:28:54 <Lemmih> Jafet: Sure, you can seq it. But that won't always solve your problem.
10:29:24 <Jafet> I suppose I haven't solved Real Enough problems, but they always have
10:32:01 <Lemmih> ksf: The laziness/strictness difference does seem to pose a problem for merging.
10:33:25 <ksf> well, as long as the Put and Get classes are compatible everything's fine.
10:33:34 <Lemmih> Jafet: When reading from things that may block, things become very tricky with lazy IO.
10:35:53 <ksf> Lemmih, Data.Acid instead of Data.State.Acid? the "state" seems kinda redundant.
10:36:46 <ksf> I'd also call the package acid-core and then add acid-containers etc.
10:37:36 <Lemmih> ksf: acid-containers?
10:37:46 <ksf> for the cointainers package
10:37:51 <Lemmih> Which containers?
10:37:59 <ksf> http://hackage.haskell.org/package/containers
10:38:00 <ksf> those
10:38:08 <Lemmih> What about them?
10:38:23 <ksf> instances for them
10:38:43 <Lemmih> I don't think that's desirable.
10:39:08 <monochrom> every immutable data structure is acid
10:39:13 <ksf> well, one would probaly want to mix and match and use a persintence-like boilerplate layer
10:40:31 <monochrom> in fact every immutable data structure is both acid and base!
10:41:49 <ksf> Lemmih, the map is hold in memory as well as on disk so that snapshoting before every query doesn't make much sense, I presume?
10:42:40 <Lemmih> ksf: I don't follow.
10:43:28 <ksf> I just want to calm the sceptic in me that the map doesn't get read from disk each time I query
10:43:46 <Lemmih> ksf: I promise you that it doesn't. (:
10:44:35 <ksf> ...so that makes it utterly likely that the spine is in A-OK state each time I query.
10:44:36 <Lemmih> ksf: Modify the KeyValue example to add 100k keys in sequence if you don't believe me (:
10:46:23 <Lemmih> ksf: I imagined that people would have fewer, larger state since the state value defines the transaction borders. That is, you can't read something from one state and insert it into another in a transactional manner.
10:48:04 <ksf> that's the exact thing openshake does right now, so I imagine it's going to be a painless operation
10:48:20 <Lemmih> ksf: Also, transaction obviously have to be serializable. That means that functions such as 'Data.Map.update' cannot be a transaction.
10:48:29 <ksf> one big mvar that is locked for a very, very short amount of time.
10:50:34 <ksf> Lemmih, well, update itself not, but events built upon update can.
10:51:25 <ksf> or if one cares to serialise a serialisable edsl for a -> Maybe a
10:54:04 <monochrom> modifyMVar_ (\m -> return (update m ...)) is obviously serializable
10:54:14 <monochrom> in fact, already serialized
10:56:27 <pmkgoogle> quick question: is this a known erratum in the Haskell 2010 standard?  page 84 says "0**y is 1 if y is 1, 0 otherwise".  Surely this should be "0**y is 1 if y is 0", yes?
10:57:03 <pmkgoogle> if this is not already known, is there an e-mail address for comments / corrections to the standard?
10:57:05 <monochrom> sorry, page 84 is section what?
10:57:15 <pmkgoogle> 6.4.3
10:57:29 <pmkgoogle> page 84 is page 104 in the PDF
10:58:58 <dons> pmkgoogle: hmm!
10:59:10 <dons> pmkgoogle: to haskell-prime@haskell.org
10:59:23 <dons> > 0 ** 1
10:59:24 <lambdabot>   0.0
10:59:27 <dons> looks like a bug to me :)
10:59:59 <monochrom> > 0**0
11:00:00 <lambdabot>   1.0
11:00:11 <monochrom> I now agree
11:00:34 <monochrom> 0**y was undefined in haskell 98
11:00:39 <dons> we are agreed, then.
11:00:42 <opqdonut_> > 0^^0
11:00:43 <lambdabot>   1.0
11:02:49 <monochrom> the triumvirate of dons, monochrom, pmkgoogle directs the haskell senate to correct the haskell report!
11:04:28 <elliottt> sometimes i find myself wishing that we had a {-# WARN_EXPORT ident #-} pragma
11:04:30 <monochrom> sadly, I found the spelling of "triumvirate" by searching for "triumphate" and getting a homework essay!
11:04:54 <elliottt> so that I could prevent myself from accidentally exporting things that i would like to keep hidden
11:05:39 <ksf> ...make an explicit export list?
11:06:02 <monochrom> you should "module X() where" at all times
11:06:52 <elliottt> yes, i suppose.  really, this problem only comes up in one place, and i always make sure to put "XXX Don't export" in a comment on the functions :)
11:07:06 <elliottt> just to remind my future self that this function should stay hidden.
11:07:41 <ksf> isn't there an option to warn about unhaddoced declarations?
11:07:52 <ksf> in that case, you could just not document them.
11:08:05 <elliottt> ah, good point
11:08:08 <monochrom> I recently had a "module X()" module. it contained no type class or instance. nonetheless, another module could still use code from X. legally. do you know why and how?
11:08:40 <elliottt> no, that's insane.  can you build a small example?
11:09:01 <monochrom> (there were functions in X and another module could use those functions. this is not a vacuous case.)
11:09:01 <elliottt> (is this a puzzle, or a bug?)
11:09:09 <monochrom> this is a puzzle
11:09:13 <elliottt> ah :)
11:09:23 <elliottt> rewrite rules?
11:09:29 <monochrom> no, no rewrite rules
11:09:57 <c_wraith> I'm stumped.
11:09:58 <monochrom> haskell 98 code
11:10:03 <elliottt> hmmmm
11:10:12 <elliottt> no abuse of the ffi?
11:10:16 <monochrom> ffi
11:10:29 <elliottt> -_-
11:10:30 <monochrom> foreign export blahblah, then use from c code
11:10:35 <elliottt> nasty
11:10:44 <lispy_> I was going to guess type classes
11:10:50 <elliottt> so, not haskell 98, but haskell 2010 ;-)
11:10:54 <monochrom> I already denied type class
11:11:06 <lispy_> ah, well I can't/don't read :)
11:11:07 <monochrom> yeah, should say haskell 2010
11:13:39 <nyingen> what does the notation 'import Foo ( Bar(..) )' mean?
11:13:53 <c_wraith> nyingen: depends on if Bar is a class or a type
11:14:01 <nyingen> class
11:14:06 <monochrom> if you have "data Bar = Haha | Die", then Haha and Die are imported too
11:14:15 <c_wraith> nyingen: in that case, it means "import the class, and all the functions it defines"
11:14:20 <nyingen> I see
11:14:27 <nyingen> cool, thanks
11:14:30 <c_wraith> nyingen: the other option is "import the type, and all the constructors for it"
11:14:32 <monochrom> roughly "Bar(..)" = Bar and its details
11:14:38 <nyingen> gotcha
11:14:44 <nyingen> never knew about that. handy.
11:14:56 <chridi> how can i access a record in a value constructor?
11:15:01 <monochrom> import Foo(Bar) will omit the details
11:15:44 <elliottt> chridi: use its label selector?
11:15:53 <monochrom> wait, what is a value constructor?
11:16:17 <elliottt> if data F = F { getInt :: Int }, then getInt :: F -> Int
11:16:37 <elliottt> or, let (F i) = F 10 in i :: Int
11:16:44 <chridi> i play around with Text.Feed
11:17:33 <nyingen> Are there any usage statistics about the various schemes to replace records? E.g. data-accessor, fclabels, ..?
11:17:52 <pmkgoogle> thanks for the tip, I'll mail haskell-prime@haskell.org about this.
11:17:59 <nyingen> I heard fclabels was the current favorite, but I'm curious about whether the haskell community intends to standardize on one of these
11:18:13 <nyingen> IIRC something was proposed for haskell-prime but I may be misremembering
11:21:56 <pmkgoogle> blah, email to haskell-prime@haskell.org is rejected, not allowed to post there
11:22:21 <dons> send to libraries@ then (or subscribe)
11:22:38 <ksf> hint: use gmane
11:22:39 <pmkgoogle> how to subscribe?
11:24:28 <monochrom> I wonder if gmane will put you through
11:24:54 <siracusa> pmkgoogle: http://www.haskell.org/mailman/listinfo/haskell-prime
11:25:00 <navaati> hello
11:26:00 <navaati> if i only have overlapping instances error in my code, does it mean that at least it typechecks ?
11:26:03 <dons> hey navaati 
11:26:24 <dons> navaati: no, it is probably not type checking. you may need to look at your instances design
11:26:36 <dons> or possibly enable -XOverlappingInstances, if that is your intention
11:26:59 <ksf> gmane is worth using in any case
11:27:25 <navaati> I already have UndecidableInstances
11:27:27 <ksf> I really don't feel like configuring procmail all the time, looking up subscribe and unsubscribe adresses and so on.
11:27:41 <ksf> also, mailing lists are a waste of bandwidth.
11:28:33 <pmkgoogle> so what's gmane when it's at home?
11:29:34 <chridi> i still dont get it
11:29:42 <chridi> lets say i have http://hpaste.org/45691/types as a type
11:30:13 <c_wraith> oh, yikes.
11:30:20 <c_wraith> That's scary :)
11:30:24 <chridi> then ive let x = A {name = "Foo"}
11:30:35 <chridi> how do i get the name of x ?
11:30:40 <mauke> name x
11:30:41 <c_wraith> name x
11:30:42 <navaati> name x
11:30:47 <c_wraith> But... You're going to break stuff
11:31:02 <c_wraith> because "number x" also type-checks
11:31:07 <c_wraith> but will crash at runtime
11:31:09 <navaati> for example if you do name y where y = (B 5)
11:31:11 <navaati> boom
11:31:33 <chridi> oh.. okay... in ghci it works xD
11:31:40 <chridi> thanks
11:31:51 <c_wraith> You're defining lots of partial functions when you do things like that.  partial functions are generally considered bad. :)
11:32:37 <elliottt> they have their uses :)
11:32:42 <chridi> hmh.. thats a bit like in text.feed the Items are defined
11:32:44 <TomMD> s/generally considered/completely evil and are a good way to make enemies fast/
11:32:57 <elliottt> heh
11:33:00 <c_wraith> Sure, I use partial functions in lots of cases where I can guarantee their input is always valid.
11:33:11 <c_wraith> But those are generally internal functions in the implementation of something
11:33:16 <c_wraith> Rather than exported
11:33:17 <TomMD> yes!
11:33:59 <c_wraith> > 5 `div` 0
11:34:00 <lambdabot>   *Exception: divide by zero
11:34:03 <elliottt> agreed.  no partial functions for library interfaces
11:34:11 <c_wraith> Sometimes, functions just *are* partial.  Nothing you can do about it.
11:35:10 <ksf> if your function is partial you didn't properly define your codomain
11:35:24 <c_wraith> does \bot have any Num instances where division by zero is defined?
11:35:46 <c_wraith> > 5 `div` 0 :: Double
11:35:47 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
11:35:47 <lambdabot>    arising from a use ...
11:35:55 <c_wraith> div is in Integral?  oops
11:36:02 <c_wraith> Guess not, then
11:38:12 <sonoflilit> Hi
11:38:26 <sonoflilit> I'm writing a web app with Yesod
11:38:47 <sonoflilit> (I did not write it originally, I got into the project as maintainer)
11:38:48 <Entroacceptor> I'm sorry.
11:39:16 <sonoflilit> as the amount of data grows, using the app becomes almost impossible because of the high memory consumption
11:39:27 <boegel> wth?
11:39:29 <boegel> $ cabal install hint
11:39:31 <boegel> Resolving dependencies...
11:39:33 <boegel> cabal: dependencies conflict: ghc-6.12.3 requires directory ==1.0.1.1 however
11:39:35 <boegel> directory-1.0.1.1 was excluded because ghc-6.12.3 requires directory ==1.0.1.2
11:39:37 <boegel> that doesn't make sense at all....
11:39:51 <boegel> anyone know how to fix this?
11:40:12 <mauke> I think that's a cabal faq
11:40:19 <dcoutts_> boegel: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict
11:40:22 <Entroacceptor> rm -rf ~/.ghc
11:41:09 <sonoflilit> so either I just need to learn to debug and avoid space leaks, or Haskell is still unusable as a production web application language, or I'm doing something else wrong
11:41:18 <sonoflilit> I'm trying to decide the future of this project...
11:41:24 <boegel> dcothx
11:41:29 <boegel> dcoutts_: thx
11:42:58 <sonoflilit> Any advice would be appreciated
11:44:07 <Cale> sonoflilit: What sort of data structures are you using? Perhaps it's possible to use something with less overhead?
11:44:16 <Cale> Are you using lots of String values?
11:45:09 <boegel> well, that did'nt help much :(
11:45:13 <chridi> ah I got it.. i think its even more complex in Text.Feed
11:45:14 <boegel> cabal: cannot configure hint-0.3.3.2. It requires ghc >6.6
11:45:22 <boegel> I have Haskell Platform 2010.x
11:45:30 <boegel> so I do have ghc 6.12
11:45:31 <boegel> :(
11:45:44 <dcoutts_> boegel: it's referring to the package ghc
11:45:52 <chridi> but programming haskell is really fun :)
11:46:06 <sonoflilit> Cale: I am using lots of strings
11:46:12 <dcoutts_> boegel: your ghc package is likely borked due to missing deps
11:46:27 <boegel> dcoutts_: yeah, ghc-pkg is telling me so
11:46:28 <Cale> sonoflilit: Remember that String values are (linked) lists of 32 bit Char values.
11:46:29 <sonoflilit> Cale: Which might become Text-s when Yesod-0.8 is out
11:46:35 <Cale> yeah
11:46:46 <Cale> Text would be a lot better
11:47:05 <sonoflilit> Cale: The memory usage I'm seeing is many orders of magnitude more than expected for, say, an equivalent operation in Python or Ruby
11:47:18 <Cale> Well, what is it that you're doing?
11:48:05 <TomMD> sonoflilit: You could do some heap profiling and _know_ what is taking all this memory. That's going to be better than guesses based soley on your program's catagory.
11:48:17 <ksf> string is a development datatype imo
11:48:27 <sonoflilit> hundreds of MBs to build a web page with a few hundred log rows
11:48:35 <ksf> don't expect to keep it around in production code
11:48:43 <ksf> sonoflilit, try blaze
11:48:51 <sonoflilit> TomMD: I started profiling
11:49:04 <Cale> sonoflilit: Something is going horribly wrong then :)
11:49:08 <TomMD> Good.  Then soon you will know what to fix.
11:49:11 <sonoflilit> I see... well, say, way too many (,)s. But what's that mean?
11:49:21 <TomMD> pairs?
11:49:23 <boegel> dcoutts_: rm -r .ghc fixed it ^^
11:49:33 <sonoflilit> ksf: I'm using Yesod. It uses Blaze to build Html
11:49:50 <sonoflilit> profiling Haskell is seeming much harder than profiling other languages
11:49:52 <ksf> then you are doing or something is going horribly wrong
11:49:55 <sonoflilit> because of laziness
11:50:08 <copumpkin> sonoflilit: -O2? are you not forcing stuff?
11:50:21 <sonoflilit> I need to learn how to approach performance problems
11:50:42 <sonoflilit> copumpkin: I do -O2. I think I'm forcing things, but maybe I'm not
11:51:21 * ksf thinks we need "The dark and gloomy road to lightning-fast Haskell"
11:51:46 <ksf> dons should write it.
11:52:33 <byorgey> How about "stormy" instead of "gloomy"
11:52:35 <ksf> sonoflilit, the main thing to wrap one's head around is how haskell is represented in memory, and laziness in general
11:52:44 <ksf> yeah, that's better.
11:53:08 <sm> sonoflilit: there's a definite learning curve to profiling/debugging haskell performance, but it's doable
11:53:22 <byorgey> it goes with "lightning" and works in a Bulwer-Lytton reference at the same time! =)
11:53:27 <sm> is your code available to look at ?
11:53:30 <dcoutts_> boegel: would it have been clearer if it had said: "cannot configure hint-0.3.3.2. It requires the Haskell package 'ghc' version >6.6" ?
11:53:36 <ksf> sonoflilit, we got decent tools, but one has to learn to use them and interpret the results
11:54:09 <sonoflilit> sm: not in original form, but I'm pasting a censored page
11:54:09 <ksf> the truth lies somewhere between heap profiles by type and cost centre and timing information.
11:56:35 <boegel> dcoutts_: maybe, but that wouldn't have helped me much probably
11:58:42 <sonoflilit> pasted, will lambdabot announce automatically?
11:59:01 <sonoflilit> http://hpaste.org/45693/performance_problems
12:00:07 <sonoflilit> The thing is, I cannot afford the price of profiling every little thing
12:00:25 <sonoflilit> if there's one thing that I'm doing wrong and I can fix it and suddenly it will all blaze, I'm fine with that
12:00:46 <sonoflilit> otherwise, I'll have to consider how to run away from Haskell for this project, or from this project
12:01:32 <ollebe> I have a quick question about maps. I'd like to request a value corresponding to a given key multiple times. The first time, a given function will be used to generate a value that will be inserted into the map, and this value returned. The next times, the key will be lookuped and the value returned, and the map not altered. Is there anything in the Data.Map module for this? 
12:01:35 <KirinDave> sonoflilit: Sounds like you need a metrics library for haskell.
12:01:48 <KirinDave> sonoflilit: Coda Hale's metrics library is making big waves in the java & scala community right now.
12:03:26 <sonoflilit> KirinDave: is that something that I have any chance of getting anytime soon?
12:03:46 <KirinDave> sonoflilit: I dunno. I'm surprised it doesn't exist already.
12:03:46 <ksf> ollebe, they're called insert and lookup
12:04:01 <byorgey> ollebe: is it really a map or do you just want a memoized function?
12:04:04 <ksf> well, a wee wrapper around insert.
12:04:32 <morphles> in .hs file how do i define hm, values i guess, let say i want to have some infinite list with some name. simly doing "name = [comprehension]" doesnt seem to work
12:04:34 <ollebe> ksf: I've written such a wrapper but i'd like to know if i'm reinventing the wheel. 
12:04:46 <ollebe> byorgey: I don't know. I will look into that. 
12:05:18 <byorgey> ollebe: see, for example, the data-memocombinators package
12:05:26 <morphles> ahem, nvm silly me
12:05:34 <sm> sonoflilit: you'll have to decide whether learning to be quick at debugging haskell performance outweighs the time you'll save not debugging mundane functionality bugs
12:06:05 <sm> it's true that yesod is relatively young.. I don't know if running into such things is a frequent occurence 
12:06:20 <conal> ollebe: sounds like memoization to me as well. see also the MemoTrie package.
12:06:26 <sm> I would definitely give the mail list a try before you give up
12:06:43 <sm> (haskell-web mail list)
12:06:47 <sonoflilit> sm: Currently I suspect the bugs to lie in my code and not Michael's - although that might be the case too, and then I'm in for real trouble I think
12:07:47 <ollebe> Just a thought: Since Haskell is call-by-need, would ordinary function applications without any map suffice?
12:08:13 <sonoflilit> sm: Can I learn to /not make/ performance problems, or is that nigh impossible?
12:08:27 <conal> ollebe: memoization is the conversion of functions into data structures. data structures cache, while functions don't (without help).
12:08:50 <sm> I think that's a bit of an open question.. and the answer is probably the latter
12:09:15 <sonoflilit> and about the code I pasted: is my forcing of execution done correctly/how can I find the answer by profiling?
12:09:45 <ollebe> Thanks. 
12:12:06 <hpc> conal: that's actually a nice explanation
12:12:12 * hpc remembers for later
12:12:24 <sm> sonoflilit: oh, I was going to point you to a recent haskell-web thread.. but it's yours
12:12:57 <sm> is the immediate problem that you can't get a profile of this yesod app then ?
12:13:01 <conal> hpc: :). it took me a long time to come to that simple understanding of memoization.
12:13:23 <ksf> sonoflilit, ghc usually gets the small things right
12:13:42 <ksf> a leak is usually rooted in one place, that is.
12:14:55 <hpc> conal: i love those simple obvious-once-you-hear-them explanations
12:15:16 <hpc> i noticed while writing this research paper that difference lists are a special case of endomorphisms
12:16:02 <conal> hpc: me too! i guess the imperative origin of memoization (in programming) obscured its essence. (as imperative formulations tend to do.)
12:16:17 <djahandarie> Difference lists are a CPS transform of regular lists.
12:16:58 * ksf wonders whether he should recommend the stg paper for people who want to learn to profile
12:17:21 <djahandarie> And a Codensity monad basically represents a CPS transform
12:17:24 <sm> ksf: recommend it to me, and I'll tell you :)
12:17:32 <hpc> i was proving that difference lists formed a monoid when i noticed that the proof was more polymorphic than i needed
12:17:43 <hpc> and then remembered the definition of Endo
12:17:46 <hpc> @src Endo
12:17:47 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:17:50 <lowasser> What is the *fastest* way to take two IO ()'s, run them concurrently, and wait until they're both finished?
12:18:08 <Zao> Fast as in effort? Fast as in overhead?
12:18:16 <lowasser> Speed of execution.
12:18:18 <hpc> does it have to be safe?
12:18:31 <lowasser> No, but they're both deterministic.
12:18:54 <ksf> sm, read http://scholar.google.de/scholar?cluster=9795042292187145048&hl=de&as_sdt=0,5  , it'll enlighten you.
12:19:02 <lowasser> Clearly there's "fork one off into another thread and use an MVar to block until it's done," but I'm not convinced that's the fastest way.
12:19:03 <hpc> lowasser: unsafeInterleaveIO
12:19:08 <ksf> wait that has no links.
12:19:12 <hpc> maybe
12:19:17 <lowasser> I don't think so
12:19:20 <ksf> try this: http://scholar.google.de/scholar?cluster=15332939084463236237&hl=de&as_sdt=0,5
12:19:20 <lowasser> I need both of them to *finish*
12:19:30 <monochrom> zitation!
12:19:54 <sonoflilit> ksf: could you expain what you said please?
12:19:59 <hpc> lowasser: you want forkIO then; i don't know exactly how because i don't do threads
12:20:21 <lowasser> I mean, clearly a forkIO is involved, the question is the fastest way for one thread to wait for another thread to finish, really
12:20:34 <ksf> sonoflilit, in short, ghc's strictness analyser is very good, and rarely needs manual intervention
12:20:40 <monochrom> yeah, forkIO inside the code, +RTS -N at run time
12:20:59 <hpc> but you vaguely want thread1 <- forkIO act1; thread2 <- forkIO act2; val1 <- finalval thread1; val2 <- finalval thread2
12:21:08 <hpc> for some value of finalval
12:21:16 <ksf> huge leaks due to laziness are rare, usually fixed easily (once they're found), and definitely locatable with practice.
12:21:20 <monochrom> add two mvars to wait for the two threads to finish
12:21:29 <lowasser> I mean, there is a trivial answer to this problem, but I'm trying to find an unnecessarily complicated but faster answer ;)
12:21:49 <KSkrzet> are orphan instances documented anywhere?
12:21:52 <sm> ksf: ok, added to my read list. IMHO no, this is too low-level for most people wanting to learn to profile haskell programs
12:21:53 <monochrom> already fastest
12:22:07 <ClaudiusMaximus> lowasser: http://hackage.haskell.org/package/spawn might be useful
12:22:11 <lowasser> for example, Java threads have otherThread.join(), which just waits for the other thread to die, full-stop
12:22:13 <ksf> sm, well, not as a tutorial, but as a way to grok the execution model.
12:22:40 <monochrom> again, add two mvars to wait for the two threads to finish
12:22:58 <monochrom> there is even an example in the Control.Concurrent doc
12:23:01 <shachaf> 0
12:23:27 <shachaf> Ahem.
12:23:34 <sm> more useful would be a how-to - use these tools, here are sample command-lines, here are worked examples from real-world programs... 
12:23:57 <sonoflilit> sm: that would be extremely useful, if it exists
12:23:58 <lowasser> I was just wondering if a speedier, more ad-hoc solution existed
12:24:05 <KirinDave> lowasser: Real World Haskell has an example of how to build that out. Haskell threads are left very very lightweight as a Feature.
12:24:17 <monochrom> waiting on mvar is already the speediest
12:24:31 <ksf> there's http://book.realworldhaskell.org/read/profiling-and-optimization.html
12:24:49 <monochrom> in fact in this case it is probably even faster than tvars
12:25:01 <sm> sorry sonoflilit, not yet. Back to your issue, are you able to profile your web app ? If yes, pasting that here may get more insight from smarter folks
12:25:17 <lowasser> guys, I've been using and loving Haskell concurrency for years, I was just hoping I could make a *really* ugly hack to wheedle maybe a 5% performance improvement, because that's the kind of guy I am
12:25:30 * sm stands semi-corrected, that's a good doc
12:25:43 <sonoflilit> sm: I can heap-profile it, but the time-profile always gives an empty file for some unknown reason
12:26:14 <ksf> the runtime doesnt' write that before it's exiting regularly
12:26:14 <lowasser> for instance, let x = unsafePerformIO (theAction) in x `par` (somethingElse >> evaluate x)
12:26:19 <sm> I see, did you try Michael's suggestion (a terminating route) ?
12:26:35 <lowasser> which is ugly, an abortion that completely misuses sparks and parallelism, but might be faster
12:26:43 <ksf> a strategically placed exit might help, there.
12:26:54 <monochrom> ok, you are of the kind who just look for someone to say yes to you. talk to a computer program that says yes.
12:27:05 <lowasser> lol meh
12:27:08 <sonoflilit> sm: it is very hard to terminate Yesod gracefully
12:27:13 <lowasser> ::goes off and profiles some more::
12:27:45 <sm> interesting. Even if you hack up its code ?
12:27:52 <sonoflilit> my attempt failed to write stuff to the file, perhaps it was because the exit wasn't graceful enough
12:28:32 <ksf> writing the profiling file is done by the rts
12:29:10 <ksf> to the best of my knowledge, http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/System-Exit.html should do the job.
12:30:02 <ksf> hmm.
12:30:08 <ksf> yesod isn't single-threaded, is it?
12:31:04 <ksf> in that case, you can wait on an mvar after starting yesod in its own thread, and then write to it to terminate the program
12:31:52 <sm> sonoflilit: by the way have you tried with different server backends ? Eg simpleserver instead of fastcgi ?
12:32:29 <sonoflilit> yesod is supposed to be multithreaded. The problem with System.Exit is that it happens in the wrong thread.
12:32:46 <ksf> sonoflilit, hence the mvar trick.
12:33:20 <sonoflilit> ksf: oh, didn't notice that
12:34:13 <sonoflilit> sm: I'm using fastcgi. Do you think it is worth trying warp? I could... It just didn't seem relevant in any way to the kind of problem I'm seeing...
12:34:42 <sonoflilit> my memory usage is definitely O(number of rows in DB table I'm displaying)
12:34:51 <sm> yes, when I've had a yesod problem I always try switching servers. It can be a cheap way to isolate problems 
12:34:57 <sonoflilit> O(f(what I said))*
12:35:16 <sm> not to mention the simpler ones probably make debugging easier
12:35:49 <aavogt> KSkrzet: orphan instances are just those defined somewhere besides the original class and data type are defined. Probably the ghc manual has something to say about how they mess up separate compilation
12:35:53 <sonoflilit> sm: compiling for warp, this will take a while :)
12:37:47 <sm> sonoflilit:  what about the devel server also 
12:38:11 <sonoflilit> sm: one at a time
12:38:29 <sonoflilit> besides, the devel server sounds very expensive in performance, isn't it?
12:39:31 <sm> probably, but I figure the non-production servers will have less concurrency and maybe terminate easier, and build quicker. Though the last point may be false due to hint
12:40:35 <sm> but hey, if it just works with warp we'll be done :)
12:40:51 <ksf> that mvar should terminate every server reliably
12:41:17 <sm> yeah, I'm pretty sure someone will add that feature to yesod quite soon
12:41:30 <ksf> the only drawback is that you should take care not to lose the reference, or your server is going to die instantly.
12:41:45 <sm> some kind of apache server-status style live profile would be even better
12:42:33 <amalloy> where can i find a resource explaining haskell's type declarations? with my lisp experience, when i try to read a paper about functional programming that uses haskell, i usually find myself spending more time puzzling through the type declarations than the meat of the paper
12:42:53 <ksf> why, they're simple logical propositions.
12:42:58 <ksf> ...plus typeclasses.
12:43:35 <ksf> you can even generate proofs automatically, like
12:43:37 <amalloy> eg i figured out "(α → β → β) → β → List α → β", as the type for defining a fold operation, but it hurts my head :)
12:43:54 <ksf> @djinn Maybe a -> a -> a
12:43:55 <lambdabot> f a b =
12:43:55 <lambdabot>     case a of
12:43:55 <lambdabot>     Nothing -> b
12:43:55 <lambdabot>     Just c -> c
12:44:03 <KSkrzet> aavogt: I asked where they end up in Haddock generated docs, if anywhere
12:44:06 <hpc> amalloy: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
12:44:12 <hpc> amalloy: perhaps that will help?
12:44:32 <hpc> is your problem the syntax or not knowing standard definitions?
12:44:47 <ksf> amalloy, I recommend to avoid everything that uses greek letters.
12:45:11 <amalloy> hpc: syntax, i think. i got through the first chapter of LYAH a while ago but haven't gotten back into it
12:45:30 <hpc> yeah, generally Foo* translates to [Foo]
12:45:33 <ksf> read "->" as "results in"
12:45:40 <hpc> Foo x Bar translates to (Foo, Bar)
12:46:02 <hpc> and greek letters translates to regular type variables, minus the mathematical masturbation :P
12:46:12 <ksf> Foo \/ Bar is Either Foo Bar
12:46:13 <amalloy> hpc: yeah, the greek letters don't really bother me
12:46:28 <hpc> i feel like i am forgetting one
12:46:35 <hpc> Mu?
12:46:43 <amalloy> hpc: [Foo] is...possibly-empty list of Foo?
12:46:53 <Kaidelong> in haskell syntax, yes
12:46:54 <ksf> If I'm ever going to write a paper I'm going to use futark type variables just to annoy people.
12:47:01 <sm> sonoflilit: got to go, good luck
12:47:02 <Kaidelong> ML would be something like Foo list
12:47:28 <hpc> oh, i think Foo+ is Stream Foo
12:47:33 <hpc> unless i am horribly mistaken
12:47:34 <sonoflilit> sm: twice as fast in warp, really surprises me
12:47:35 <sonoflilit> thanks
12:47:46 <sm> oh.. still the memory leak, right ?
12:47:53 <sm> high memory usage, I mean
12:47:57 <hpc> (Stream is non-empty lists)
12:48:06 <sonoflilit> I'll check, I didn't look at `top` this time
12:48:25 <amalloy> i guess i should just start on LYAH again
12:48:37 <BONUS> that reminds me
12:48:52 <hpc> BONUS: can your next chapter be categories?
12:49:06 <hpc> categories/arrows
12:49:06 <monochrom> categories are overrated
12:49:09 <ksf> fastcgi involves an additional layer of indirection
12:49:16 <BONUS> yeah i thought about doing arrows
12:49:17 <luite> learn you a category theory for great good
12:49:26 <ksf> I'd avoid it if possible
12:49:32 <BONUS> but then i sort of couldn't come up with examples
12:49:34 <hpc> monochrom: categories tie up a lot of theory very nicely
12:49:34 <monochrom> arrows have limited use for now, though I'm a big fan of hxt arrows
12:49:37 <sm> amalloy: or there's http://www.haskell.org/tutorial/goodies.html 
12:49:37 <sonoflilit> ksf: but the problem was definitely in memory usage within the haskell app
12:49:45 <newsham> wormhole != great good
12:49:49 <sonoflilit> anyway, memory usage is now much better
12:49:52 <sm> amalloy: and the wikibook
12:49:58 <BONUS> i'd just be explaining messing around >>> *** &&& 
12:50:06 <sm> and wiki .. (hand-wave)
12:50:11 <monochrom> categories tie up a lot of theories very nicely, after you have seen all those a lot of theories. Piaget etc
12:50:47 <luite> BONUS: not the <- ... -< and <- ... -<< syntax?
12:50:48 <sm> sonoflilit: yay - better as in reasonable ? problem solved ?
12:50:59 <monochrom> pedagogically, categories should be the final chapter, universal algebra the second last
12:51:03 <newsham> BONUS: instead why dont you start with some interesting graph of arrows, show how to write that graph in arrow-do-notation, and then show how you can use >>>/***/&&&/etc.. to realize that graph directly (manually)
12:51:09 <sonoflilit> sm: I'm not sure
12:51:11 <newsham> and why do-notation is so nice :)
12:51:15 <BONUS> anyway. if anyone here is a fan of LYAH (or hates it) and would like to write an amazon review, i can see to it that a free copy is shipped to you. just send me your address & phone number (for the shipping guys) to bonus at learnyouahaskell and include the word 'gaspberry' in the subject
12:51:20 <BONUS> luite: oh yeah there's that too
12:51:36 <BONUS> newsham: hmmm that could be pretty cool
12:51:42 <hpc> BONUS: oooooh, i might do that
12:51:43 <luite> for more complicated arrows, especially with ArrowApply, that syntax is quite useful
12:51:51 <BONUS> hpc: awesome!
12:52:01 <sonoflilit> BONUS: I didn't go through all of it, but I'd love to write a review after I do
12:52:05 <BONUS> doesn't have to be an amazon review, if anyone has a blog or whatever, just go for it
12:52:13 <newsham> BONUS: btw, here's an actual interestng use of arrow notation i found in a paper.  http://www.thenewsh.com/~newsham/x/machine/paddleball.hs
12:52:15 <BONUS> sonoflilit: sure, no problem
12:52:43 <sonoflilit> well, cool :-)
12:52:43 <sm> ok well good luck, and now you know - shuffle backends as needed, it's a great and useful feature
12:52:45 <newsham> would be neat drawing that out as a graph
12:52:51 <BONUS> newsham: oh cool! i love actual uses of arrows/arrow notation that aren't just about using *** and &&& for code golf
12:53:16 <luite> hxt might be a useful example, although probably too complicated for a book example
12:53:18 <benmachine> I cannot at all work out how to edit the haskell-prime wiki
12:53:18 <hpc> damn, have to buy something on amazon first
12:53:23 <benmachine> is it even allowed
12:53:27 <dfilimon> still, it's funny when you use those, most people ask whether or not it's a typo :)
12:53:48 <BONUS> hpc: hmmm, really? i didnt know that :[
12:54:02 <newsham> mostly it seems like (***) is like asm level programming and do-arrow is like a higher level language (well, not too high, higher level still would be editing an actual graph)
12:54:03 <monochrom> buy a java book :)
12:54:14 <hpc> BONUS: if i buy the book from amazon and then write a review, will you send free bonus stuffs instead of a free book?
12:54:18 * hpc has no need for two
12:54:21 <newsham> other than when you're just using those primitives for some simple tuple editing functions
12:54:38 <BONUS> hpc: sure!
12:54:52 <BONUS> but i can send you the book too, you can maybe give it to someone if you want?
12:55:08 <hpc> cool, will do
12:55:31 <deech> Currently doing some Python development, I miss Haskell. 
12:55:43 <benmachine> http://hackage.haskell.org/trac/haskell-prime/wiki/ImplicitParams I'm trying to update the doc links on this page but I can't work out how to trac wiki
12:55:44 <BONUS> alright, just state in the email that you want the bonus stuff then and i'll make a note of it
12:55:58 <benmachine> deech: haskell misses you too :(
12:56:02 <newsham> earn you a free book for great good
12:56:32 <monochrom> hahaha
12:57:31 <hpc> :D
12:57:32 <luite> is the first print run almost sold out already?
12:57:44 <BONUS> i have no idea. i'm just the author
12:57:53 <luite> it will become a collector's item of course
12:58:03 <dfilimon> BONUS: be sure to sign them too ;)
12:58:08 <BONUS> it's funny how i have literally no idea in what orders of magnitude it's selling
12:58:14 <newsham> authors these days have it so easy.  last night pbs was talking about how tyndal was burnt at the stake for printing a bible.
12:58:15 <BONUS> haha
12:58:28 <newsham> also he had to work directly with the printers....
12:58:38 <Entroacceptor> BONUS: yes, sign it (if I get around...)
12:58:43 <BONUS> newsham: yeah but now you can get nasty reviews on the internet
12:59:07 <newsham> bonus: true, but in fairness, there's so much more out there deserving of nasty reviews.
12:59:19 <dfilimon> umm... you made a happy sun say 'holy shit' on the front page, i'm pretty sure you can't get nasty reviews for that :))
12:59:27 <BONUS> haha
12:59:30 <luite> hmm, have there been negative reviews for lyah?
12:59:30 <newsham> too many books that never should have been.  churned out because the other publisher has a book on the topic and we have to have one too
12:59:30 <deech> newsham: So it's the publishers and not the authors, although in this case it didn't end well for them either.
12:59:33 <newsham> no matter if its any good
12:59:37 <BONUS> being burned at the stake vs. 2 star review on amazon ... what's worse? you decide.
12:59:39 <monochrom> wait, I thought they only burned people for printing anti-bible stuff...
13:00:03 <dfilimon> burning people at the stake is so... last millennium 
13:00:06 <newsham> monochrom: translating bibles into native tongues was considerd quite anti-bible.
13:00:12 <Twey> monochrom: Heretics are not allowed to print Bibles.
13:00:18 <newsham> especially when it downplayed "church" and "charity".
13:00:30 <BONUS> also: being burned at the stake vs. receiving a burned stake in the restaurant
13:00:34 <Twey> Especially translate them.
13:00:39 <newsham> or work @stake.
13:00:45 <newsham> working
13:01:38 <luite> how would you like your burned stake
13:01:39 <newsham> religeous texts are best published in obscure ancient languages and read by an exclusive class of the privileged.
13:02:07 <newsham> which brings us full circle back to 'learn you a haskell for great good'
13:02:24 <newsham> well, s/ancient//
13:02:30 <monochrom> BONUS will burn you for translating it to java
13:02:36 <luite> oh no, BONUS may be responsible for making haskell accessible to the java class
13:02:42 <newsham> my translation is not yet complete, mono.
13:02:56 <BONUS> luite: oh well now i might get burned at the stake by the haskell community
13:03:07 <newsham> i have to figure out how i'm gonna deal with typeclasses like Show
13:03:07 <deech> luite: "The Java class" a little elitist, no? :)
13:03:14 <monochrom> burn you a bonus for great good? <duck>
13:03:39 <acowley> deech: it's a PL pun
13:03:43 <acowley> deech: so it's allowed
13:03:53 <luite> BONUS: would you like that stake to be medium, rare or well-done?
13:04:10 <dfilimon> i think you people have got it all wrong really, we're approaching Easter, so it should definitely be crucifixion
13:04:20 <BONUS> i want me well-done. burn me for my crimes against haskell
13:04:30 <deech> acowley: It was funny, or the Java cast.
13:04:42 <newsham> crucifiction.. there's an arrow for that.
13:04:42 <acowley> deech: you must be one of them Haskell types
13:05:12 <dfilimon> aha, so *that's* what arrows are for
13:05:18 <deech> acowley: Yeah lazy as hell. 
13:05:25 <dfilimon> although they should really be called nails in that case
13:05:39 <acowley> anyone know how to use tex input method in emacs to enter some text in a subscript font?
13:06:36 <newsham> ruby on nails?
13:06:38 <monochrom> would that be like "a_b" to subscript b?
13:06:43 <acowley> yeah
13:06:49 <acowley> it only does the first few nats by default
13:07:04 <monochrom> does entering "a_b" work? "a_{b}"?
13:07:07 <acowley> no
13:07:11 <monochrom> even "{a}_{b}"
13:07:19 <monochrom> well then, too bad
13:07:25 <mauke> do those subscript characters even exist?
13:07:31 <acowley> mauke: I think so
13:07:52 <revenantphx> monochrom: When I go about making a language next year as an indep. study
13:07:56 <monochrom> accept the possibility of incomplete implementation
13:08:04 <revenantphx> monochrom: how interesting do you think it would be to make it entirely stack less?
13:08:11 <acowley> the phonetic extensions block
13:08:17 <revenantphx> monochrom: that is, only coroutines (somehow)
13:08:29 <acowley> I would rather demand completeness
13:08:39 <monochrom> very interesting, since it is rare
13:09:11 <monochrom> it may even surprise a few people that it can be done and just as turing-complete
13:09:12 <acowley> well, I only want i and e
13:09:23 <mauke> import Canadia.Copoutine
13:09:33 <newsham> heh
13:09:39 <newsham> cheesey
13:10:16 <monochrom> there are quite a few people who swear that stack is needed for general recursion etc
13:10:19 <acowley> I guess iota nad epsilon are close
13:10:27 <acowley> s/nad/and
13:10:34 <acowley> nad is not in the greek alphabet
13:10:54 <monochrom> if you really understand what's going on in evaluation or execution or whatever, stack is just an optimization.
13:11:08 <byorgey> s
13:11:22 <newsham> are you just trying to tell me that a stack is a special case of heap allocation?
13:11:53 <monochrom> not even that
13:14:17 <monochrom> I have recursive code f x = f (x - 1). how do you execute that?
13:14:42 <monochrom> well, let's make it more difficult. f x = 1 + f (x - 1)
13:14:44 <mauke> I solve for f
13:14:49 <mauke> the solution is f = 0
13:15:15 <monochrom> we can rewrite. here is one step: f 5 → 1 + f (5 - 1)
13:15:42 <monochrom> here is one more step: 1 + f (5 - 1) → 1 + 1 + f (5 - 1 - 1)
13:15:48 <benmachine> hackagebot died :o
13:16:21 <monochrom> it is kind of expensive because later you will find yourself searching the whole humongous expression for "the next thing to do". but it doesn't need a stack
13:16:22 <mauke> in accordance with the prophecy
13:16:30 <dfilimon> monochrom: totally random suggestion, but for recursion, use a fixed point combinator?
13:16:39 <sm> benmachine: you're right, thanks
13:16:59 <dfilimon> so you don't *need* textual recursion
13:17:05 <benmachine> right? about hackagebot?
13:17:12 <dfilimon> it could just be a different function from your perspective
13:17:17 <dfilimon> and it will get substituted
13:17:21 <monochrom> if you have a stack and a program counter, you eliminate the search, which is nice. optimization.
13:17:52 <monochrom> dfilimon you need more context of why I brought this up
13:18:04 <dfilimon> tell me about it
13:18:05 <sm> benmachine: yes. It's dying because LANG != en_US.UTF-8 . Gotta love this haskell "feature" 
13:18:18 <monochrom> the scroll buffer has complete context
13:18:36 <dfilimon> at about what time does that context start?
13:18:52 <monochrom> 13 minutes ago
13:19:07 <mauke> http://codepad.org/qPl0QYFt - para-related
13:19:09 <benmachine> sm: that doesn't sound too hard to fix
13:19:21 <benmachine> sm: is the code hanging around?
13:19:28 <benmachine> is it just rss2irc or whatever
13:19:40 <sm> benmachine: indeed.. yes it is
13:19:44 <mauke> solution to someone else's java homework (required to use regexes); my version is in perl and uses no* additional data structures
13:20:42 <sm> my usual fix is to just ensure the env var is set. I run hackagebot with supervisor, which has an environment directive for this purpose, but it doesn't seem to be working since I moved to a new vps
13:20:46 <dfilimon> so, the point was to have a prototype language without a stack?
13:20:53 <dfilimon> if i got that right
13:21:59 <dfilimon> that sounds like a new toy scheme interpreter coming up :)
13:23:40 <monochrom> using additional data structures in perl is made hard anyway
13:23:55 <mauke> I disagree
13:24:01 <jlouis> monochrom: data structures are overrated
13:24:12 <mauke> but making a string rewriting system was kind of fun
13:24:14 <jlouis> abolish ADTs, the Google Go way!
13:24:58 <sm> benmachine: if you know a way to have idiomatic encoding-safe string handling code that also avoids a runtime crash when locale is unset, I'd use it in all my haskell code
13:25:40 <benmachine> sm: that depends on what you consider to be idiomatic
13:26:03 <benmachine> e.g. one way would be to catch the IO exception and make file IO return Maybe String
13:26:18 <benmachine> another way would be to do IO on bytestrings and use explicit encoding/decoding
13:29:41 <sm> benmachine: IO Exception sounds better than "crash", and those sound sensible - will keep in mind
13:30:56 <benmachine> sm: personally I've never had to deal with it myself, so I can't promise those solutions are pretty or simple, but that's where I'd start
13:31:22 <benmachine> (lazy IO will screw it up, but the solution to that is don't use lazy IO, as we all know :P)
13:31:40 <roconnor> @hoogle bracket
13:31:40 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:31:40 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:31:40 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:31:57 <monochrom> lazy IO bytestring doesn't blow up on decoding error
13:32:44 <benmachine> monochrom: oh, fair enough
13:35:22 <monochrom> then again we do care about other errors that aren't indicated by lazy IO
13:35:43 <benmachine> sure
13:36:36 <sm> the trouble with debugging this silly env var is that restarting supervisor forces a bunch of processes and bots to restart
13:37:48 <sm> making a micro-bump into a molehill
13:50:36 <HugoDaniel> hi
13:50:47 <HugoDaniel> is there any diff function for bytestrings ?
13:50:52 <HugoDaniel> lazy bytestrings :)
13:54:30 <osoleve> oh nooo
13:54:59 <osoleve> i finally got Data.WAVE to do what I wanted it to, and it turns out it only does Int32 while SDL_Mixer only uses 8 and 16 :/
13:58:46 <ClaudiusMaximus> hmm, my soft-float implementation somehow makes Numeric.floatToDigits consume all available memory while failing to produce digits :(
13:59:50 <osoleve> ClaudiusMaximus: thank you for making me feel better about my issue :/ hope yours works out!
14:01:52 <roconnor_> ah opps
14:01:57 <roconnor_> show x = show x
14:02:04 <roconnor_> -- not the best definition of show
14:02:22 <ClaudiusMaximus> osoleve: i hope i can blame GHC 6.12.3 to give me an excuse to upgrade..
14:02:54 * roconnor_ switches to Agda
14:10:59 <Kaidelong> so the correct use of unsafePerformIO is when a function that should be pure in the whole has intermediate computations in IO (IE nondet. concurrency)?
14:12:24 <Kaidelong> IE something that is nondeterministic but not observably so
14:12:38 <c_wraith> Kaidelong: that's how unamb uses unsafePerformIO, anyway
14:13:16 <Kaidelong> okay, glad I can explain why you'd use it then
14:13:33 <mauke> :t with
14:13:34 <lambdabot> Not in scope: `with'
14:13:38 <mauke> aww
14:13:41 <Kaidelong> @hoogle with
14:13:41 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
14:13:42 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
14:13:42 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
14:14:02 <c_wraith> Kaidelong: there are also cases in the FFI, which is where unsafePerformIO originated.
14:14:38 <Kaidelong> I figured that would be the most obvious thing to say, but "it allows haskell to work with foreign libraries elegantly" did not satisfy me as an explanation
14:14:50 <Kaidelong> because then you could counter with why you don't just build it into the FFI
14:15:24 <c_wraith> It sort of is.  you can set up a foreign import as having a type in IO or not.  if it's not, the result is automatically unsafePerformIO'd
14:15:38 <monochrom> there is no conflict between (build into FFI) and (provide unsafePerformIO). in fact, both are done
14:16:02 * Kaidelong is aware of that actually, was just envisioning how well that explanation would work
14:16:09 <c_wraith> But that actually doesn't cover all cases.  Sometimes you need to compose multiple IO actions in an FFI call...  Say a function involving bytestrings as input
14:16:28 <c_wraith> Or something that requires an intermediate allocation
14:16:28 <Kaidelong> someone in fsharp a while ago took offense to the existence of unsafePerformIO
14:16:51 <Kaidelong> haskell fan
14:16:54 <Kaidelong> he's probably in here too
14:17:20 <monochrom> perhaps two foreign functions are each IO and needs to be so, but their composition is referentially transparent. then you do unsafePerformIO (fa >>= fb)
14:17:56 <ion> I find unsafePerformIO warranted for debugging helpers such as Debug.Trace.trace
14:18:02 <monochrom> but then c_wraith beats me to it
14:18:28 <c_wraith> But yes, something like unamb is really not possible to implement without unsafePerformIO, and it's a really handy function
14:19:35 <Kaidelong> so long as (not) recalculating the value does not matter, I'd imagine you're fine
14:19:51 <Kaidelong> IE the thing you're unsafePerformIOing is pure
14:20:16 <monochrom> yeah, that's the license
14:20:55 <c_wraith> note, though, that unamb is not forced to be pure by the type system.
14:21:28 <c_wraith> You can call unamb with args that result in undefined behavior
14:22:32 <heatsink> ghc-pkg tells me that my package is broken, even after I unregistered my package and verified that it's not in the output of "ghc-pkg list".  Nothing depends on the package.  Why is it complaining about an unregistered package?
14:22:42 <sonoflilit> Yesod users: is there any reason to use warp as reverse proxy and not standalone except for static file serving performance?
14:22:55 <Kaidelong> c_wraith: I imagine that it could be possible to make unamb pure, at least in a total language
14:22:59 <Kaidelong> oh
14:23:02 <Kaidelong> where it would be useless
14:23:21 <c_wraith> I mean...  "unamb 1 2" is not pure.
14:23:34 <Kaidelong> since unamb's only purpose is to combine partial values
14:23:41 <Kaidelong> and total languages don't have those
14:23:48 <stepcut> does haskell platform work with xcode 3 on OS X ?
14:23:52 <Kaidelong> but you could enforce that it is pure
14:23:53 <monochrom> yikes, I have duplicate posts on hpaste.org. http://hpaste.org/45023/ and http://hpaste.org/45081/
14:23:55 <heatsink> Oh, I see what happened.
14:24:02 * heatsink goes to file a bug report
14:24:27 <stepcut> oops. I mean xcode *4*
14:24:51 <monochrom> heatsink: what bug? please tell me the url when you're done, thanks
14:25:53 <heatsink> monochrom: If I specify --global on the command line, it still checks the default user database.
14:25:55 <acowley> stepcut: no, but GHC 7.0.3 does
14:26:00 <acowley> stepcut: new HP soon
14:26:08 <stepcut> acowley: how soon ?
14:26:10 <Kaidelong> I suppose in any language where unamb is actually useful, checking than unamb is pure is exactly the halting problem
14:26:28 <acowley> I don't know, but I think later in April
14:26:29 <monochrom> oh yeah that one. has to add "positively ignore user database"
14:26:30 <heatsink> monochrom: I'm on a shared file system.  Same user package database, different global package databases depending on which computer I'm logged in to.
14:26:36 <stepcut> acowley: k
14:26:40 <ClaudiusMaximus> hooray! i figured out how to stop Numeric.floatToDigits from crashing :)
14:26:52 <heatsink> There's a flag for that?
14:26:52 <Kaidelong> amb would always be pure though for varying definitions of pure
14:27:30 <ClaudiusMaximus> though, my floats are now diminished slightly, as per:   floatRange _ = (minBound `div` 2, maxBound `div` 2)
14:27:38 <stepcut> acowley: thanks!
14:28:30 <Kaidelong> (?) c t e = (if c then t else e) `unamb` (if t == e then t else undefined)
14:29:50 <heatsink> I guess I should ask the mailing list for clarification instead.
14:29:54 <Kaidelong> a generalized == will be useful
14:30:18 <Kaidelong> especially in this case where it is okay if == just returns "undefined"
14:30:33 <acowley> equality is hard
14:30:47 <Kaidelong> equality is hard to do right
14:30:53 <Kaidelong> but you don't always have to do it right
14:31:06 <acowley> No, I think it's hard because you want different equalities at different times
14:31:10 <tlr_> quick question, is there any advantage to using recursion and guards vs a list comprehension in this case: https://gist.github.com/f81be20bd82b94da2e4e
14:31:16 <Kaidelong> oh sure
14:31:29 <Kaidelong> no doubt, but then you can use different typeclasses
14:32:01 <tlr_> (or is there an even better way?)
14:32:06 <Kaidelong> a GenStructEq typeclass or something like what OCaml has might be nice
14:32:28 <monochrom> class AnotherEq a where (===) :: a->a->Bool...
14:32:36 <monochrom> class YetAnotherEq a where (====) :: a->a->Bool...
14:32:54 <monochrom> class LearnYouAnEqualityForGreatGood a where ...
14:32:55 <acowley> tlr_: I don't think there is a difference, but you could check out what the compiler does for list comprehensions. I would also hazard that list comprehensions aren't as popular in Haskell as in other languages.
14:33:11 <c_wraith> tlr_: I'd be really surprised if those two didn't compile to the same code with optimizations on
14:33:59 <Kaidelong> acowley: this is what makes me smirk when I read that Python's list comprehensions are inspired by Haskell
14:34:12 <tlr_> acowley: so the first one is preferred haskell style? seems counterintuitive, as the second is more concise
14:34:30 <acowley> it is, but I think the issue is one of notation scalability
14:34:41 <Kaidelong> tlr_: Haskell doesn't really prise conciseness so much as clarity
14:34:44 <Kaidelong> prize
14:34:47 <acowley> yours is a great example of list comprehensions being very concise
14:34:52 <Kaidelong> or haskell style at least
14:34:55 <hpc> @tell BONUS review posted, email sent
14:34:56 <lambdabot> Consider it noted.
14:35:10 <Kaidelong> usually clarity and conciseness overlap
14:35:13 <Kaidelong> but not always
14:35:14 <acowley> but I think the first one is actually clearer
14:35:15 <c_wraith> hpc: you forgot to include "kickback requested" :)
14:35:38 <hpc> heh, that's in the email ;)
14:35:44 <acowley> also, the first approach is the pattern for any structural recursion
14:35:53 <acowley> so it's good to come to grips with
14:36:14 <acowley> while to explain the comprehension one you have to say something like "read the comma as an /\"
14:36:49 <ion> I find the second one faster to comprehend because there’s less code to read.
14:37:06 <acowley> I agree that in this case the second one is very nice
14:37:07 <c_wraith> In both cases I noticed the name was "filter" and didn't read the implementation :)
14:37:46 <tlr_> acowley: i can see how list comprehensions could get unwieldy, and if consistency is valued that would be a reason to use the first
14:38:22 <acowley> tlr_: When I use Python I typically go overboard with nested list comprehensions and have to scale them back
14:38:42 <tlr_> map's is even nicer: map' p xs = [p x | x <- xs]
14:38:46 <acowley> in Haskell I never use them :/
14:39:02 <tlr_> ok good to know
14:39:23 <acowley> the bigger point is that you should seldom care about the list structure
14:39:50 <acowley> You're always just stringing together map, filter, fold
14:40:00 <olsner> list comprehensions are so non-pointsfree
14:40:27 <ion> @pl [p x | x <- xs]  -- ;-)
14:40:28 <lambdabot> [p x | x <- xs]
14:40:46 <ion> Huh. Didn’t pl parse the list comprehension incorrectly in the past?
14:40:54 <ion> +syntax
14:41:35 <acowley> yay p f = [p x | x <- ] . [ x | x <- , f x]
14:42:37 <ivanm> @type let yay p f = [p x | x <- ] . [ x | x <- , f x] in yay
14:42:38 <lambdabot> parse error on input `]'
14:42:45 <ivanm> heh
14:42:55 <acowley> I eta reduced my list comprehension composition
14:43:03 <acowley> apparently that's frowned upon
14:43:16 <ivanm> yeah, I didn't think it looked like valid code
14:43:51 <acowley> I'm glad it's not
14:44:14 <ion> > let map = (=<<) . (return .) in map (+1) [0..5]
14:44:16 <lambdabot>   [1,2,3,4,5,6]
14:44:58 <ivanm> so.... map f = concatMap ((:[]) . f) ?
14:45:22 <acowley> yes
14:47:47 <Guest38256> Hello Haskellers.
14:48:54 <Guest38256> What's wrong with the following ?  I expect it to print a micron-sign (Greek mu) in angle brackets, but it adds a capital A with circumflex before the micron.
14:48:58 <Guest38256> do { System.IO.hSetEncoding System.IO.stdout System.IO.utf8 ; putStr $ [ '<', Data.Char.chr 181, '>' ] }
14:49:11 <Guest38256> <Âµ>
14:49:36 <ivanm> why are you explicitly qualifying everything?
14:49:47 <ivanm> > char (chr 181)
14:49:48 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:49:54 <ivanm> :o
14:50:00 <zygoloid> Guest38256: i'm guessing your terminal isn't expecting utf-8
14:50:03 <ion> guest: Is your terminal not using the UTF-8 encoding?
14:50:05 <Guest38256> ivanm:  this is in GHCi and it makes it work.
14:50:10 <ivanm> > chr 181
14:50:10 <lambdabot>   '\181'
14:50:17 <Guest38256> WinGHCi specifically.
14:50:19 <ivanm> Guest38256: why not import System.IO and Data.Char?
14:50:22 <monochrom> please disclose full information about OS and environment etc
14:50:30 <c_wraith> > text "\181"
14:50:30 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
14:50:49 <Guest38256> I open WinGHCi and enter the do line above without any :load or other commands.
14:50:58 <c_wraith> what version of ghc?
14:51:04 <c_wraith> what version of windows?
14:51:13 <c_wraith> What locale is windows set to?
14:51:23 <monochrom> probably windows code page nonsense. fix it with chcp 65001
14:51:23 <Guest38256> WinGHCi 1.0.6 Windows XP SP3
14:51:23 <ivanm> the fact that lambdabot can't print it via text makes me wonder if that character is indeed valid...
14:52:00 <zygoloid> looks good to me http://www.fileformat.info/info/unicode/char/b5/index.htm
14:52:07 <c_wraith> Prelude> putStrLn "\181"
14:52:08 <c_wraith> µ
14:52:08 <monochrom> lambdabot is partially broken and partially correct when it comes to utf-8
14:52:13 <Guest38256> I switched the font to Arial Unicode MS and it makes no difference.
14:52:17 <ivanm> monochrom: heh
14:52:19 <c_wraith> It's a valid codepoint
14:52:30 <ivanm> @remember monochrom lambdabot is partially broken and partially correct when it comes to utf-8
14:52:30 <lambdabot> It is stored.
14:52:39 <ivanm> Guest38256: font shouldn't matter
14:52:45 <ion> Switching fonts doesn’t affect encoding issues.
14:53:13 <Guest38256> chcp out of scope.
14:53:20 <monochrom> perhaps winghci doesn't let you change code page. ditch it.
14:53:28 <Guest38256> do { chcp 65001 ; System.IO.hSetEncoding System.IO.stdout System.IO.utf8 ; putStr $ [ '<', Data.Char.chr 181, '>' ] }
14:53:30 <Guest38256> <interactive>:1:5: Not in scope: `chcp'
14:53:39 <monochrom> someone the other day asked what's the point of winghci. I couldn't answer.
14:54:10 <monochrom> chcp is a windows command, not a ghci command
14:54:37 <ivanm> monochrom: I think it does prettier ghci stuff than running it in cmd.exe
14:54:40 <ivanm> that's about it
14:55:01 <monochrom> well then, apparently, it's uglier as soon as you use a real encoding
14:55:04 <Guest38256> I can type chcp 65001 in a command window but that doesn't affect the running WinGHCi.  Do I have to invoke WinGHCi from the same command window ?
14:55:26 <monochrom> you can invoke ghci from the same command window...
14:56:05 <rien> can anyone help me fix a small and quick "import .. hiding" problem in someone else's code? --> http://hpaste.org/45694/math_parser
14:56:08 <Guest38256> I did and the only difference now is that it draws a T (box-drawing character) instead of the A+circumflex.
14:56:34 <rien> Parsec's <|> is clashing with Applicative's <|> even when the code for importing Parsec hides <|>
14:56:47 <monochrom> the box is the µ modulo fonts
14:57:00 <monochrom> ok, I give up, windows is too hard
14:57:12 <ion> Use mintty for a decent terminal on Windows™.
14:57:38 <Guest38256> monochrom:  I'm beginning to think so too.  Maybe I'll have to try UTF-8 strings and binary output.
14:57:44 <monochrom> but I'll remember next time to answer "give up hope" early to save everyone time
14:59:19 <monochrom> no it doesn't matter which utf-8 library you use. winghci dishonours utf-8 (uses windows-1252 instead), and cmd.exe's font is incomplete. there is no hope.
14:59:50 <c_wraith> removing windows generally helps.
15:00:03 <c_wraith> what's ghc's bsd support look like?
15:00:17 <monochrom> well actually Âµ suggests that winghci uses iso-8859-1
15:00:18 <ion> Just use mintty in UTF-8 mode and an appropriate font. But yeah, developing in Windows™ must be painful in general.
15:00:19 <siracusa> rien: I think Parsec's <|> is needed, not the one from Applicative
15:00:29 <blackdog> c_wraith: it'd be complete, surely?
15:00:37 <acowley> rien: It's not a class, but a missing Applicative instance
15:00:46 <acowley> s/class/clash
15:01:29 <monochrom> bsd ghc seems to have to go through -fvia-C, and also dynamic linking has problems, but otherwise fine
15:02:14 <c_wraith> isn't -fvia-C being deprecated in favor of -fllvm?
15:02:39 <monochrom> dunno, apparently not for ghc bsd
15:03:13 <acowley> oh, he's using old parsec
15:03:15 <monochrom> or probably yes, deprecated for the next 10 years
15:03:28 <ivanm> monochrom: heh
15:06:12 <acowley> rien: Can you use parsec 3?
15:07:57 <rien> acowley: you think that'd solve it?
15:07:57 <rien> I don't even know which I'm using
15:08:22 <acowley> can you check?
15:09:04 <acowley> The latest versions have an Alternative instance while something like 2.1.0.1 doesn't
15:09:39 <rien> how?
15:10:07 <siracusa> rien: ghc-pkg list parsec
15:11:13 <rien> 2.1.0.1 exactly
15:11:22 <rien> is there a handy command for updating it?
15:13:18 <luite> BONUS: what was the name of that animal you used for the list monster?
15:13:27 <corpumpkin> it looks like a bug to me
15:13:33 <corpumpkin> a caterpillar?
15:13:46 <luite> nah I mean, I think I've seen it before :)
15:13:46 <rien> centipede?
15:14:06 <corpumpkin> the human centipede, best movie ever
15:14:09 <BONUS> luite: it's a wiggler
15:14:10 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:35 <hpc> HA i was just about to say that
15:14:37 <hpc> from mario
15:14:37 <luite> thanks that's it :)
15:15:00 <BONUS> also hpc great review! if i reviewed your review i'd give it 5 stars
15:15:08 <hpc> :D :D :D
15:15:21 <luite> it's pretty hard to google for it if you don't know the name :)
15:18:12 <elliotstern> I'm going to be writing a simple AI for a game (Go, FWIW).  For a first writing of it, I'm going to represent the board as collections of Empty, Black and White points on the board.  Are there any data structures other than a simple Tree I should look into?  Removal, addition and checking to see whether a point is in the collection should all be a minimum of O(log n).
15:18:21 <Bfig> say i have an array of commands to execute and a state s. i want to execute those commands one by one. they are set up like this:  exec :: state -> command -> (state,[char]). how can i string them up, passing the state from the start of the list to the end while printing the results of the commands?
15:18:51 <c_wraith> if you reverse the order of the arguments, you have the state monad
15:19:02 <monochrom> elliotstern: you should use an array of your empty,black,white points
15:19:06 <acowley> elliotstern: IntMap
15:19:06 <c_wraith> command -> State state [char]
15:19:20 <monochrom> oh intmap is also fine
15:19:27 <Bfig> c_wraith, how can i use that?
15:19:41 <lpsmith> Is there a way to navigate errors in shime?
15:19:51 <monochrom> I guess intmap if you plan to mutate plentifully
15:20:22 <osoleve> how do I construct a UArray out of a list of Ints? I'm having a hard time understanding the documentation. :/
15:20:25 <zygoloid> @type sequence :: [State state [Char]] -> State state [[Char]] -- Bfig
15:20:26 <lambdabot> forall state. [State state [Char]] -> State state [[Char]]
15:20:43 <Bfig> is state a haskell class?
15:20:52 <luite> hpc: does the kindle edition have color images?
15:20:53 <Bfig> State i mean
15:21:18 <hpc> luite: not sure; the kindle doesn't do color so i would expect no
15:21:36 <luite> hpc: there are kindle apps for ipad and android tablets
15:21:50 <luite> and phones too :)
15:21:53 <blackh> Bfig: State is defined in Control.Monad.State in the standard libraries
15:23:19 <ivanm> blackh: do you think you'll be able to come to AusHac again?
15:24:01 <blackh> ivanm: Not this year - maybe next
15:24:09 <ivanm> *nod*
15:24:39 <blackh> Would like to but I'm busy as
15:27:03 <elliotstern> For converting an (X,Y) point to an Int, for the IntMap, do you think I should do something like (X << 5) + Y?  It's a 19 by 19 board, FYI
15:27:05 <blackh> osoleve: Use 'import Data.Array.Unboxed (UArray) ; import Data.Array.IArray' ...
15:27:37 <blackh> osoleve: Then use the listArray function to contruct your UArray.
15:28:14 <blackh> If you get a compile error, add a type signature (so it knows what type of array to create).
15:28:26 <acowley> elliotstern: or just (Y*19)+X
15:28:30 <osoleve> blackh: and a type could be UArray Int Int?
15:28:34 <acowley> (assuming you start counting from 0)
15:29:01 * acowley is row-major 4 life
15:29:28 <blackh> osoleve: That's right, so something like listArray (1,10) [1..10] :: UArray Int Int
15:29:39 <osoleve> blackh: thank you
15:30:05 <blackh> osoleve: Use 'array' if the elements are inserted in random order.
15:34:30 <jmcarthur> > index ((0,0), (18,18)) (4,5)  -- elliotstern 
15:34:31 <lambdabot>   81
15:36:44 <nkpart> anyone got some experience with the hdbc-mysql package? 
15:36:45 <christo_m> acowley: http://hpaste.org/45696/error, https://github.com/christomitov/Turnip/blob/master/Parser.hs#L124
15:36:54 <hpc> nkpart: i do
15:37:11 <hpc> not enough for a deep question, but i might help
15:37:13 <nkpart> I'm trying to make it connect without using socket
15:37:36 <christo_m> acowley: i think because args can optionally be a list of expressions
15:37:42 <nkpart> It seems to try and find the socket no matter what though
15:38:08 <christo_m> wait a minute, i dont have args defined do i..
15:38:09 <christo_m> wow
15:38:11 <hpc> are you using defaultMySQLConnectInfo {mysqlUnixSocket = "/var/run/mysqld/mysqld.sock"} ?
15:38:21 <christo_m> oh ya, i do
15:38:51 <nkpart> No I'm trying not to pass a socket at all, just have it use the host/port
15:38:55 <hpc> oh
15:38:56 <hpc> um
15:39:37 <acowley> christo_m: you really need to add type annotations
15:39:51 <acowley> your life would improve
15:39:57 <christo_m> acowley: whats confusing is when ami doing a Parser Expr or just an Expr
15:40:00 <hpc> defaultMySQLConnectInfo {mysqlHost = "foo.nkpart.com", mysqlPort = "9001"} or similar
15:41:23 <christo_m> acowley: http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Parsec/examples/tiger/Tiger.hs , ive been using this as reference
15:42:46 <hpc> @tell nkpart http://hackage.haskell.org/packages/archive/HDBC-mysql/0.6.3/doc/html/Database-HDBC-MySQL.html#v:defaultMySQLConnectInfo -- as long as you don't set mysqlUnixSocket to anything, it should use the host/port option
15:42:47 <lambdabot> Consider it noted.
15:43:18 <christo_m> @seen BMeph
15:43:18 <lambdabot> Unknown command, try @list
15:43:18 <preflex>  BMeph was last seen on #haskell 15 hours and 56 minutes ago, saying: christo_m: Why not use numberOrFloat and conver any Integer results to Doubles?
15:43:29 <christo_m> haha, right
15:43:40 <osoleve> how do I resolve "couldn't match expected type IO a0 with actual type 'Audio Int'" here? https://ideone.com/rZAxT
15:43:53 <hpc> nkpart: you dc'd so i @told you some docs
15:43:59 <osoleve> the issue is with makeWavFile
15:44:41 <nkpart> Ah thanks, flakey wifi here
15:44:41 <lambdabot> nkpart: You have 1 new message. '/msg lambdabot @messages' to read it.
15:45:36 <monochrom> eh? Audio is your own datatype?
15:45:47 <osoleve> no, sorry, it comes from Data.Audio
15:45:50 <acowley> christo_m: these should all be Parser t
15:45:52 <acowley> for some t
15:45:53 <monochrom> I don't think you need >>= there?
15:46:05 <christo_m> acowley: parser t..
15:46:12 <monochrom> exportFile "temp.wav" (makeAudio (makeWav . getWavSamples) ?
15:46:20 <monochrom> and )
15:46:23 <acowley> well, Parser Stmt or Parser Expr
15:46:29 <acowley> maybe something else
15:46:30 <gio123> is there sombody who works on termination?
15:46:37 <acowley> Parser [Expr], for example
15:46:47 <christo_m> ya i tried that as a fix
15:46:53 <acowley> your tying your hands behind your back not having type annotations
15:46:57 <monochrom> eh? "makeWav . getWavSamples" is very confused
15:47:16 <acowley> they'd help you pin down where the inferred type disagrees with what you expected
15:47:31 <nkpart> hpc: Ah dear, I figured it out. if you pass 'localhost' as the host, it looks for a socket. Passing '127.0.0.1' works around it
15:47:43 <christo_m> acowley: then 116 complains
15:48:22 <Bfig> what's the problem here? i don't understand the error... how can he demand a more general type where i explicitly binded the type to what it gets : http://pastebin.com/yDmMEcjy
15:49:02 <ivanm> "he" ?
15:49:11 <acowley> what do you mean "then"?
15:49:21 <osoleve> monochrom: how should I put that so I get the [Int] without it being IO? I can't use <$>
15:49:25 <acowley> ivanm: Simon
15:49:29 <monochrom> https://ideone.com/2otTS
15:49:35 <ivanm> Bfig: did you mean "Parse Char" ?
15:49:39 <ivanm> you have "Parse char"
15:49:43 <ivanm> here, "char" is a type variable
15:49:49 <ivanm> since it starts with a lower-case letter
15:49:50 <Bfig> ouch,.. :S
15:49:51 <monochrom> IOW getWavSamples is the one needing >>=
15:50:00 <Bfig> thanks :p
15:50:54 <christo_m> acowley: i mean line 116 complains about expected type Expr and getting [Expr]
15:50:58 <christo_m> so i put the type annotation
15:51:10 <christo_m> then it complains about expected type [Expr], inferred type Expr
15:51:12 <christo_m> cant win
15:51:35 <christo_m> its because var is an Expr
15:51:49 <christo_m> but functioncall is an [Expr]
15:52:06 <ksf> :t let robot_monkey = (:[]) in robot_monkey
15:52:07 <lambdabot> forall a. a -> [a]
15:52:19 <ivanm> Bfig: hp
15:52:21 <ivanm> * np
15:52:59 <Bfig> slowly but surely i'm finishing this program :)
15:53:09 <ksf> christo_m, that's rougly the difference between an apple and a basket for apples.
15:53:16 <Bfig> just need to program the I/O and some minor adjustments to the parsing
15:53:18 <christo_m> ksf: ya i know its just
15:53:22 <christo_m> depending on how i parse, i could end up with either or
15:53:32 <christo_m> is there some way to represent that? i dont know enough haskell
15:53:36 <christo_m> is Maybe the right thing?
15:54:11 <ksf> well, you could just stick your element into a list.
15:54:30 <ksf> or, if it's the other way round, extract an element from a list
15:54:40 <ksf> ...or apply your function to each element individually.
15:54:42 <ksf> your choice.
15:55:42 <ksf> but always remember, ghc is anal enough to complain that it wants a basket even though you give it a particularily good-looking and tasty apple.
15:55:57 <ksf> it's even stupid enough to prefer an empty basket over an apple.
15:56:31 <ddarius> An empty basket very likely costs more than an apple.
15:56:36 <hpc> @faq can haskell make a basket look like an apple?
15:56:37 <lambdabot> The answer is: Yes! Haskell can do that.
15:57:02 <christo_m> :|
15:57:07 <christo_m> it can do anything :O
15:57:07 <ksf> I wouldn't even need to invoke oleg to do that
15:57:47 <acowley> I kind of wish I had a way to trigger that lambdabot behavior outside of irc
15:58:08 <acowley> christo_m: you need to decide what should reasonably be a list and what shouldn't
15:58:25 <christo_m> acowley: i dont have a choice.. its based off tha grammar: http://www.lua.org/manual/5.1/manual.html#8
15:58:37 <acowley> I mean within the context of your parsers
15:58:41 <ksf> well, yes, you do.
15:59:01 <ksf> I hate to spoil the fun, but I think there already is a haskell implementation of that grammar
15:59:16 <christo_m> lua-xgettext
15:59:21 <christo_m> ive looked at it
15:59:25 <ksf> though it's probably one of the nicest grammars to learn parsing with.
16:00:00 <ivanm> ksf: for lua?
16:00:03 <ksf> yep.
16:00:09 <ivanm> it's bindings to the lua C library
16:00:20 <ivanm> christo_m seemingly wants to re-implement it directly
16:00:32 <christo_m> i just want to be able to parse a simple lua script
16:00:33 <ksf> no, I once saw a real parser
16:00:35 <christo_m> and generate some god damn LLVM
16:00:40 <christo_m> yes, its called lua-xgettext
16:00:41 <ksf> the lua bindings are more like an interpreter.
16:00:50 <ksf> you'd have to use lua reflection to get at the source, then.
16:01:07 <christo_m> http://tuomov.iki.fi/software/lua-xgettext-20081204.tar.gz
16:01:23 <christo_m> to be honest its really complicated to me
16:01:31 <christo_m> i pretty much took his AST though
16:01:36 <acowley> christo_m: did you put types on everything?
16:01:45 <christo_m> acowley: i wish i knew what types to put..
16:01:53 <acowley> that's a bad sign!
16:01:56 <ivanm> ksf: well, I thought so as well but hslua is the only package I could find on hackage :s
16:02:05 <ivanm> christo_m: types first, _then_ code!
16:02:12 <christo_m> time to fail boys haha
16:02:38 <christo_m> right now everythings an Expr or a Stmt
16:02:54 <ksf> more importantly, terminals first, then expressions, then simple statements, then the rest.
16:03:02 <ksf> don't start out with everything at once
16:03:06 <christo_m> ksf: i didnt
16:03:06 <acowley> christo_m: comment out the stuff that doesn't type check, then just ask ghci for types
16:03:09 <christo_m> i had a lot of it working
16:03:11 <acowley> do one at a time
16:03:19 <christo_m> i just happened to add some new things
16:03:23 <christo_m> like tables are very important in LUA
16:03:25 <acowley> but you should try anticipating what ghci will say
16:03:28 <christo_m> so i decided to implement them, so i can do function calls
16:03:41 <acowley> I think it's C-u C-t t in emacs haskell-mode
16:03:48 <acowley> or something like that
16:09:24 <christo_m> acowley: funcname :: GenParser Char () ()
16:09:25 <christo_m> this is weird
16:09:28 <christo_m> it returns nothing?
16:09:33 <christo_m> probably because of the optional
16:10:35 <acowley> right
16:11:03 <acowley> use optionMaybe
16:11:16 <acowley> then you have a name with an optional type 
16:11:20 <acowley> if that's what that is
16:17:48 <christo_m> acowley: funcname :: Parser (Maybe Name)
16:17:53 <christo_m> looks more correct?
16:19:01 <acowley> I was expecting something more like, funcname :: Parser (Name, Maybe Name) 
16:19:20 <acowley> all functions have a name, some have a type
16:22:22 <mm_freak> i have eight cores…  when using parallel strategies with -N2, i get an improvement, but the improvement doesn't seem to increase, when i increase the number of threads
16:22:28 <mm_freak> it's an intel i7 processor
16:22:55 <mm_freak> am i doing something wrong, is it because of the semantics of the i7 or is the current implementation of strategies just not powerful enough?
16:23:52 <dons> mm_freak: depends on your algorithms, and your parallelization strategy
16:23:55 <hpc> mm_freak: do you see the expected rate of improvement on other cpus?
16:23:59 <thoughtpolice> um, neither. it may just be due to the fact your program doesn't scale at N > 2 cores
16:24:05 <dons> there are certainly many exmaples of ghc programs scaling up to far greater than 8 cores.
16:24:08 <blackh> mm_freak: Use +RTS -S and figure out how it breaks down between mutator (MUT) and GC
16:24:13 <dons> so its not a limitation of ghc
16:24:27 <thoughtpolice> GHC can certainly use my quad-core i7 with its +4 extra hardware threads, no doubt
16:24:56 <christo_m> acowley: okay well, that doesnt work when i annotate it like that
16:25:00 <blackh> mm_freak: Sometimes what you gain in the mutator you lose in the GC.
16:25:06 <blackh> It's useful to know which it is.
16:26:09 <acowley> christo_m: (,) <$> sepBy identifier dot <*> optionMaybe (colon >> identifier)
16:26:27 <mm_freak> dons: i just wrote a function, made sure that nothing is shared and applied that function to a list using parMap
16:26:42 <mm_freak> hpc: i see that the user time of my program reflects that the cores are indeed used
16:26:47 <mm_freak> but not productively it seems
16:26:51 <mm_freak> blackh: thanks, will try that
16:27:13 <mm_freak> blackh: mainly MUT time
16:27:48 <mm_freak> i seem to get optimal running time with -N3
16:27:52 <mm_freak> let me paste the code
16:27:59 <blackh> mm_freak: Actually the way parMap is defined in the new strategies is not not quite enough to make it work.
16:29:27 <mm_freak> http://hpaste.org/45698/parallelism_test
16:29:31 <blackh> It was a while ago, but I took a close look at the definition and found it wasn't forcing each element.  I needed to combine a parList and a seqList or something like that.
16:30:13 <dons> hmm
16:30:24 <christo_m> acowley: uhh, what?
16:30:25 <blackh> mm_freak: Your function isn't doing nearly enough work.
16:30:27 <christo_m> i cant even understand that
16:30:29 <christo_m> nor does it work
16:30:31 <blackh> Granularity too small, I think
16:30:58 <dons> the cost of doing each 3^ N is about the same as forking the spark in the first place :)
16:30:59 <blackh> Oh, maybe not. :)
16:31:18 <dons> hm.m
16:31:19 <blackh> Those would be big numbers
16:31:28 <dons> maybe 100ms 
16:31:31 <mm_freak> blackh: i tried with different exponents
16:31:41 <mm_freak> blackh: interestingly it seems to parallelize better on smaller exponents
16:31:48 <mm_freak> so it might be related to my processor
16:31:49 <christo_m> acowley: sorry can you please show me again but in my style of coding
16:31:59 <christo_m> its actually telling me <$> is not in scope
16:32:00 <christo_m> etc
16:32:00 <mm_freak> i don't know whether i have eight real cores or just some hyperthreading
16:32:14 <acowley> christo_m: IRC encourages one-liners
16:32:23 <acowley> christo_m: import Control.Applicative
16:32:24 <acowley> or
16:32:41 <acowley> do {n1 <- first bit; n2 <- second bit; return (n1,n2)}
16:33:44 <hpc> acowley: that's even fewer characters! you lazy bum
16:33:45 <hpc> :P
16:33:47 <blackh> mm_freak: I suspect that parMap tells it to spark each element, but doesn't make it actually run them when you force the head.
16:34:02 <acowley> hpc: the first one would have worked
16:34:07 <mm_freak> blackh: it performs just as expected with -N2
16:34:13 <acowley> hpc: this one requires he define "first bit" etc. :)
16:34:24 <mm_freak> blackh: it prints two elements, pauses, prints two elements, pauses, etc.
16:34:25 <hpc> blackh: perhaps he has to force the whole spine?
16:34:42 <hpc> er
16:34:46 <hpc> hmm
16:34:49 <mm_freak> blackh: so at least for -N2 it seems to do the right thing
16:34:51 <blackh> hpc, mm_freak: I might have been because I was using parList rather than parMap - i don't know the detail.
16:35:00 <mm_freak> and indeed the real time is about half of the real time of -N1
16:35:34 <mm_freak> with -N3 it's faster, but the real time is much more than a third of the -N1 real time
16:35:40 <blackh> mm_freak: It seems like it's a reasonable assumption that it's working.
16:36:01 <mm_freak> it really might be related to my processor
16:36:16 <dons> to deeply understand what it is doing, use threadscope to monitor the work on each core
16:36:20 <mm_freak> intel has this "hyperthreading" stuff
16:36:32 <lowasser> use threadscope: it tells all
16:36:50 <mm_freak> dons: from 'time' output i can see that all cores are busy
16:36:51 <hpc> mm_freak: you would still have 4 processors though
16:37:02 <christo_m> funcname = do{ n1 <- sepBy identifier dot; n2 <- optionMaybe (colon >> identifier); return (n1,n2)}
16:37:05 <christo_m> you mean something like this?
16:37:09 <hpc> or do you mean it only sees the two from one cpu?
16:37:11 <christo_m>     Couldn't match expected type `Char' against inferred type `[Char]'
16:37:12 <christo_m> i get that
16:37:21 <mm_freak> hpc: good question
16:37:22 <dons> mm_freak: certainly, i can get 386% cpu use (out of 4 real cores)
16:37:50 <mm_freak> i get 684% out of 8 cores
16:38:21 <mm_freak> it's always around 670%
16:38:53 <mm_freak> with -N4 i get 370%, which seems to be much more relatively#
16:38:54 <blackh> mm_freak: I can see it's pretty obviously running them in parallel (from the output)
16:39:11 <mm_freak> blackh: yes, no question to that
16:39:21 <mm_freak> but with -N2 it runs "cleanly"
16:39:27 <mm_freak> outputting two elements at once
16:39:27 <dons> even with explicit forkIO pinning 1/4 of the work to each core, i get about the same speedup with N=4 (around 30%)
16:39:46 <mm_freak> as i increase -N i get less coherent output cycles
16:40:08 <dons> you can experiment with affinity flags
16:40:18 <dons> e.g. -qa -qw or -qm (see +RTS --help)
16:40:44 <blackh> mm_freak what version of ghc are you using?
16:40:50 <dons> to deeply understand it though, threadscope is the key
16:42:48 <test> a
16:45:50 <blackh> mm_freak: I'll give you my results as soon as I've downloaded ghc-7.0.3. I've got a 3.20 GHz i7 here.
16:48:29 <mm_freak> now i'm getting the best results with -N4
16:48:50 <mm_freak> made a less complex function and increased the list length to 1000
16:49:05 <mm_freak> the affinity flags don't change much
16:49:16 <christo_m> acowley: ?
16:49:22 <christo_m> BMeph: hey i got your message about the fix yesterday
16:49:34 <BMeph> christo_m: ...and? ;)
16:49:35 <blackh> mm_freak: Maybe it's a hyperthreading thing, then.
16:50:09 <christo_m> BMeph: and i fixed it
16:50:31 <christo_m> BMeph: except what did you say, the typesignature for that parser should be Stmt -> Expr?
16:53:43 <mm_freak> is there a way to turn off GC?
16:56:32 <monochrom> there is a haskell compiler bearing no GC at all.
16:56:45 <monochrom> was it jhc?
16:56:46 <blackh> mm_freak: 4.295s 3.832s 3.129s 2.328s 2.652s 2.394s 2.752s 2.425s <- your original program -N1 to -N8
16:57:15 <mm_freak> wow
16:57:26 <mm_freak> -N6 gives me the best results
16:58:02 <mm_freak> i get 596% CPU usage with -N6
16:58:13 <c_wraith> sounds pretty good
16:58:27 <monochrom> as for ghc, you can strongly discourage gc by the likes of -H5g or something
16:58:59 <mm_freak> c_wraith: well, it doesn't mean my program runs six times faster
16:59:16 <mm_freak> 4.3 secs with -N1
16:59:20 <c_wraith> It means all the cores are doing *something* :)
16:59:24 <mm_freak> 1.9 secs with -N6
16:59:29 <c_wraith> Just...  possibly not useful stuff
16:59:51 <mm_freak> monochrom: GC doesn't seem to be the problem here
16:59:53 <blackh> mm_freak: I've got a parallel build of some C++ here.  I'll give you some times for that.
17:00:05 <monochrom> alright nice
17:00:54 <mm_freak> blackh: that would be great
17:01:06 <mm_freak> perhaps i should also try to use forkIO
17:02:21 <mm_freak> blackh: do you have an i7, too?
17:02:22 <acowley> christo_m: where is that error?
17:02:30 <blackh> mm_freak: yes
17:03:12 <mm_freak> perhaps i should note that it's an i7 in a laptop
17:03:46 <mm_freak> but it doesn't say anything mobile-related in /proc/cpuinfo
17:04:28 <blackh> make -j4 (1m40.913s) make -j8 (1m24.614s) - 141 source files
17:04:56 <mm_freak> blackh: i think, 'make' is not a good measure
17:05:15 <blackh> That's "real" time from the Unix "time" command
17:05:21 <rostayob> @hoogle a -> (a -> Bool) -> Maybe a
17:05:21 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
17:05:22 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
17:05:22 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:05:32 <mm_freak> besides the computations it has also a lot of waiting to do
17:05:38 <mm_freak> waiting for disk, waiting for OS, etc.
17:05:54 <blackh> The disk stuff is all cached. This thing has piled of memory.
17:06:08 <blackh> I should probably run the -j8 again though (the first one I did)
17:10:00 <christo_m> acowley: line 137
17:10:13 <christo_m> https://github.com/christomitov/Turnip/blob/master/Parser.hs#L137
17:10:49 <blackh> mm_freak: make -j8 (1m23.811s) so not much difference.  So I don't think IO counts for much, though there will be some mutexes in the kernel.
17:11:28 <blackh> Conclusion: "Cores" 4-8 on an i7 improve speed by roughly 20% on a parallel make.
17:12:36 <mm_freak> blackh: i wrote a Makefile now, which calls 'factor' eight times as separate targets
17:12:49 <mm_freak> without -j i get 6 secs
17:12:59 <acowley> oh
17:13:01 <mm_freak> -j2 = 3.5 secs
17:13:03 <acowley> sepBy returns a list
17:13:51 <acowley> so you want to put those dots back into the name
17:13:54 <acowley> I suppose
17:14:02 <mm_freak> from -j3 up: 3.2s, 2.4s, 2.7s, 2.6s, 2.2s, 2.0s
17:14:28 <christo_m> acowley: ?
17:14:31 <mm_freak> -j8 is clearly the fastest
17:14:48 <christo_m> acowley: what do you mean pot those dots back into the name
17:14:49 <acowley> n1 <- fmap (intercalate ".") (sepBy ....)
17:14:50 <mm_freak> in my haskell program -N6 is the fastest
17:15:03 <shachaf> mm_freak: What about just "-j"?
17:15:07 <acowley> sepBy gives you something like [foo,bar] for the string "foo.bar"
17:15:26 <acowley> > intercalate "." ["foo", "bar"]
17:15:27 <lambdabot>   "foo.bar"
17:15:36 <mm_freak> shachaf: same as -j8
17:15:42 <mm_freak> i.e. same timing
17:15:44 <shachaf> So just use -j.
17:16:14 * shachaf says without any context.
17:16:18 <mm_freak> shachaf: i just wanted to see how core utilization looks like with make's parallelism compared to GHC's RTS
17:16:24 <christo_m> oh i see
17:16:57 <shachaf> Oh.
17:17:25 <mm_freak> shachaf: because with strategies i get a speedup, but it's far from optimal
17:18:19 <mm_freak> i can't manage to get much better than reducing runtime by about 50-60%
17:19:31 <mm_freak> which i would expect from using three cores, but not eight
17:21:34 <mm_freak> it's not that i'm disappointed, because i didn't expect miracles from automatic spark management
17:21:48 <mm_freak> but if there are ways to improve this, i'd gladly use them
17:22:28 <c_wraith> Is this something small enough to try with monad-par?
17:22:54 <c_wraith> well, more specifically, to try re-implementing with monad-par to test performance in its model
17:23:58 <mm_freak> didn't know about that one
17:24:03 <mm_freak> i will have a look at it
17:24:49 <christo_m> acowley: still having an issue with prefixexp though
17:24:49 <christo_m> because it could either be an Expr or a [Expr]
17:24:49 <christo_m> var is Parser Expr, functioncall is Parser [Expr]
17:29:22 <acowley> you can use Either
17:29:26 <acowley> or something more specific
17:30:07 <acowley> mm_freak: please do try with monad-par and report back, I'm really curious to know how it works out in practice
17:35:38 <mm_freak> i tried monad-par now
17:36:02 <mm_freak> it seems to have much better CPU utilization, but doesn't improve the timings
17:36:18 <mm_freak> but one thing to note is that now i get the best results with -N8 (or -N)
17:37:52 * ddarius recommends making a very fast sequential implementation and then spawning off 7 naive fibs to raise CPU utilization.
17:38:03 <acowley> Why do you say it's better CPU utilization if the timings are no better?
17:38:08 <acowley> hah
17:38:09 <acowley> exactly
17:38:19 <acowley> "better"
17:39:14 <monochrom> hahahaha ddarius wins
17:42:42 <mm_freak> acowley: using -N8 now gives me around 770% CPU usage
17:42:58 <mm_freak> with strategies i only got around 670%
17:43:48 * acowley points to ddarius's comment
17:44:56 <mm_freak> irrelevant to me, as i'm not testing with a fib implementation =)
17:45:30 <acowley> the point is, hot CPU isn't something to be intrinsically proud of
17:46:07 <christo_m> acowley: would i do something like functioncall :: Either (Parser [Expr]) (Parser Expr)
17:46:27 <acowley> christo_m: functioncall :: Parser (Either [Expr] Expr)
17:46:38 <christo_m> ah.
17:47:01 <mm_freak> acowley: i'm just checking out how well the current pure parallelism stuff works
17:47:09 <christo_m>     Couldn't match expected type `[Expr]' against inferred type `Expr'
17:47:11 <christo_m> grr
17:47:26 <mm_freak> because i might need it for some of my real world projects
17:49:42 <miyako> hello. Could someone point me to the direction of how I'd go about parsing a string. I'm trying to parse a string in the form of "xdy" e.g. "4d20"
17:50:01 <djahandarie> mm_freak, he wasn't talking about fib. He was giving a counterexample to the concept that CPU usage has anything to do with performance.
17:50:07 <christo_m> miyako: parsec ;)
17:50:19 <christo_m> well maybe not for something that simple
17:50:21 <christo_m> overkill
17:50:42 <miyako> I saw a reference to Text.Scanf, but I couldn't find it in ghci so I might be looking in the wrong module
17:53:39 <acowley> miyako: in what format is your text?
17:54:29 <miyako> acowley: I have a list of strings I'm getting from cmdArgs that should all be in the format of "xdy", e.g. "2d10" or "100d12"
17:54:55 <christo_m> basically Int Char Int
17:55:00 <miyako> yeah
17:55:11 <mm_freak> djahandarie: i understood that, but it's a bit suspicious that strategies only use 670% of 800% CPU time, while monad-par uses 770%
17:55:14 <monochrom> > [ (x,y) | (x, 'd':m1) <- reads "4d20", (y,"") <- reads m1 ] :: [(Int,Int)]
17:55:15 <lambdabot>   [(4,20)]
17:55:51 <monochrom> in fact, let's add it to lambdabot temporarily
17:55:58 <mm_freak> effectively that means that one in total thread's time has not been used at all
17:56:09 <mm_freak> one in total → in total one
17:56:12 <monochrom> @let xdy s = [ (x,y) | (x, 'd':m1) <- reads s, (y,"") <- reads m1 ] :: [(Int,Int)]
17:56:13 <lambdabot>  Defined.
17:56:19 <monochrom> > xdy "100d200"
17:56:21 <lambdabot>   [(100,200)]
17:56:21 <acowley> let f = (read***read.tail) . break (=='d') in f "4d20" :: (Int,Int)
17:56:31 <monochrom> you can play with it more
17:56:31 <acowley> > let f = (read***read.tail) . break (=='d') in f "4d20" :: (Int,Int)
17:56:33 <lambdabot>   (4,20)
17:56:33 <mm_freak> > 0 `par` 1
17:56:34 <lambdabot>   1
17:56:46 <miyako> hmm, okay, I'm trying to grok that code monochrom 
17:56:52 <monochrom> oh, break is also nice
17:56:56 <miyako> I'm still pretty noobish with haskell so far
17:57:33 <mm_freak> > fix id `par` 1 `pseq` 1
17:57:34 <lambdabot>   1
17:57:56 <mm_freak> i wonder if that breaks lambdabot
17:58:04 <miyako> okay, so break looks like it splits a list into two lists when a boolean condition is true?
17:58:26 <Berengal> mm_freak: lambdabot forks, doesn't it?
17:58:31 <miyako> and I know what read does
17:58:35 <miyako> but what is the "***"
17:58:44 <nejucomo> Is there an equivalent of a mutable slot for StateT?  I want something like MVar except it only has new/get/put and lives within StateT
17:58:47 <Berengal> @type (***)
17:58:48 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
17:59:01 <mm_freak> Berengal: it didn't kill the thread (at least it didn't admit that it did)
17:59:11 <monochrom> *** forms tuples from using functions
17:59:27 <acowley> I'm using it to apply two functions to a pair, one on the left, one on the right
17:59:34 <monochrom> (f *** g) (x,y) = (f x, g y)
17:59:47 <acowley> I was in the process of typing exactly that :P
17:59:51 <miyako> okay, that makes sense
18:00:12 <christo_m> Parser.hs:118:12: Couldn't match expected type `[Expr]' against inferred type `Expr'
18:00:21 <christo_m> acowley: i dont get it man.. why is it still complaining about this
18:00:25 <miyako> I need to get better at reading the types, because I couldn't get that from the type output
18:01:07 <monochrom> the type of *** is very general. (f *** g) (x,y) = (f x, g y) is a special case
18:01:12 <acowley> christo_m: are you using the Either data type or another approach?
18:01:16 <Berengal> @src (***)
18:01:17 <lambdabot> f *** g = first f >>> second g
18:01:31 <monochrom> don't worry about the general case now. it's too much information
18:01:40 <christo_m> acowley: either approach, but this isnt on functioncall, its on prefixexp
18:01:48 <acowley> yes, and the special case monochrom mentioned is the most commonly encountered one
18:01:56 <miyako> so, f is a function that takes a [Char] and splits it into ([Char],[Char]), then (read***read.tail) parses the first list into an int, and the tail of the second list into an int (because the head would be 'd'), and returns that tuple?
18:02:09 <monochrom> exactly
18:02:22 <espringe> Why does ghc say T.KeyString is not in scope, after I go:
18:02:23 <espringe> import qualified Data.Trie as T
18:02:24 <miyako> :) might seem simple but I'm proud of myself for getting that lol
18:02:26 <espringe> http://hackage.haskell.org/packages/archive/bytestring-trie/0.1.4/doc/html/Data-Trie.html
18:02:35 <espringe> And that shows it has a "type KeyString"
18:03:24 <miyako> took me long enough just to figure out how to get random numbers, but I think I'm slowly starting to understand more about how haskell works
18:03:39 <Berengal> espringe: You aren't trying to use it as a value, are you?
18:03:42 <acowley> miyako: you should be proud!
18:04:23 <Berengal> miyako: Being able to read and use Arrow code took me a while too
18:04:29 <miyako> now I have another problem though, (***) isn't found
18:04:29 <espringe> Berengal: nope, i'll pastebin it 
18:04:56 <christo_m> grr var is causing problems
18:05:06 <acowley> christo_m: you've got the same problem in prefixexp
18:05:12 <acowley> functioncall gives you an [Expr]
18:05:16 <espringe> http://hpaste.org/45700/tkeystring_not_in_scope
18:05:23 <christo_m> acowley: ya
18:05:25 <espringe> Berengal: ^ 
18:05:34 <acowley> you need to address that
18:06:01 <acowley> Usually, one would have an Application (or App) term variant
18:06:03 <christo_m> acowley: function call gives me a [Expr] or an Expr doesnt it?
18:06:09 <miyako> so is (***) in a module I need to import?
18:06:15 <christo_m> right.
18:06:29 <acowley> miyako: Control.Arrow
18:06:37 <christo_m> i guess that means a new data type in my AST
18:06:40 <miyako> acowley: thanks :)
18:06:49 <christo_m> application should only apply to functions 
18:07:27 <Berengal> espringe: I can't see right away why that would fail..
18:07:48 <espringe> generator.hs:6:27:
18:07:48 <espringe>     Not in scope: type constructor or class `T.KeyString'
18:07:50 <espringe> That's ghc's error
18:08:21 <Berengal> espringe: Maybe for some reason you can't use type aliases qualified?
18:08:21 <christo_m> acowley: so basically, it should be like Function Expr, or Function Function
18:08:30 <christo_m> thats the only possible applications right?
18:08:40 <espringe> Berengal: "KeyString" itself also fails
18:08:57 <espringe> Or maybe KeyString isn't actually exported? And it's only for internal use?
18:09:20 <Berengal> espringe: It doesn't appear to be exported
18:09:34 <espringe> How come it's in the docs then :/
18:09:40 <Berengal> I don't know :/
18:09:54 <Berengal> Since it's just an alias, you can use ByteString instead
18:10:45 <christo_m> acowley: http://www.lua.org/manual/5.1/manual.html#2.5 , just weird that the manual considers these expressions
18:10:52 <christo_m> but i guess an application is a type of expression?
18:10:54 <espringe> I guess i'll create my own alias too, but it's a shame -- like what if they wanted to change it from being a ByteString to being a normal string
18:11:03 <espringe> then my code would break
18:12:53 <acowley> christo_m: that looks like prefixexp should be a data type
18:13:14 <christo_m> in my ast..
18:13:35 <acowley> which would clarify your parser
18:13:36 <acowley> yes
18:13:49 <christo_m>           | Call Expr [Expr]
18:13:49 <christo_m>           | MemberCall Expr Name [Expr]
18:13:51 <christo_m> i have these already
18:14:05 <christo_m> is that not sufficient?
18:15:35 <acowley> probably
18:16:49 <christo_m> i should do the appropriate returns
18:31:48 <Berengal> Does `yield` do anything? The docs seem to claim it's only useful in systems that implement cooperative multitasking
18:31:54 <espringe> How can I convert a literal string "blah" to a bytestring? ByteString.Pack doesn't work?
18:33:21 <Saizan> Berengal: in ghc the RTS can only interrupt a thread when it allocates
18:33:45 <monochrom> before "convert"ing string to bytestring, first decide on an encoding and say so. http://www.joelonsoftware.com/articles/Unicode.html
18:34:29 <espringe> monochrom: I'm happy if it's treated as ascii or utf8
18:35:02 <monochrom> then let's say ascii. Data.ByteString.Char8's pack will do
18:35:09 <christo_m> monochrom: http://www.lua.org/manual/5.1/manual.html#8 , what do you recommend i do about args here
18:35:20 <christo_m> it forces everything that relies on it to be prepared to accept a list of Expressions
18:35:28 <christo_m> it pretty much breaks my code
18:36:46 <espringe> monochrom: thanks, that does it
18:37:17 <monochrom> I don't know what to do about args
18:37:51 <christo_m> i pretty much am putting Parser (Either [Expr] Expr) everywhere now..
18:37:53 <christo_m> its horrible
18:40:12 <christo_m> monochrom: https://github.com/christomitov/Turnip/blob/master/Parser.hs#L110
18:40:30 <christo_m> its to the point where i have to change what exp_exp is, even though i know it should be :: Parser Expr
18:41:27 <christo_m> the explist in args broke things
18:51:07 <Balahla> Need help... I have been studyng Haskell for some time, got pretty much syntax, monad concepts (kind of...), reading "Real World Haskell", Learn You a Haskell for Great Good!", "The Haskell School of Expression", but when I try to code something, just don't know how to even begin... Is there some basic exercises to develop funcional programming skills. Specially in Haskell?
18:52:06 <pastorn> Balahla: do you have an example of something you might want to buil?
18:52:07 <pastorn> d?
18:52:11 <Saizan> most of those books have exercises
18:54:03 <Balahla> I have a script in Python that I want to do in Haskell. I take a kmz file (kml zipped, Google Earth), acess a txt file, take some parts (use xml tags) and save a new file, just that KML this time.
18:54:20 <Balahla> I have to unzzip the kmz file.
18:55:34 <pastorn> Balahla: there's a package on hackage for that, i think it's zlib
18:55:40 <Alan> is there a "do nothing" parser in parsec, i.e. one that consumes no input?
18:56:07 <parcs> return ()
18:56:15 <pastorn> Balahla: http://hackage.haskell.org/package/zlib
18:56:54 <Balahla> Yes, but I can't grasp how to use the lib. I couldn't find examples. I'm stuck.
18:57:30 <pastorn> Balahla: decompress :: ByteString -> ByteString
18:58:12 <pastorn> to get the ByteString to begin with, "import qualified Data.ByteString as B" and use readFile
19:00:36 <pastorn> Balahla: well, actually you'll use B.readFile
19:01:35 <Alan> parcs: ah, that should have been obvious .. :(
19:02:56 <parcs> Alan: not really
19:04:01 <pastorn> Balahla: do you understand?
19:06:12 <pastorn> Balahla: if i were you I'd write a function unzipFile :: FilePath -> IO ByteString to begin with
19:06:16 <parcs> Alan: by the way, are you using this do-nothing Parser in an if-then expression?
19:06:17 <Balahla> I'gonna try.
19:06:25 <Balahla> I was trying to use: Codec.Archive.Zip
19:06:34 <Alan> parcs: no
19:06:34 <Balahla> http://hackage.haskell.org/packages/archive/zip-archive/0.1.1.3/doc/html/Codec-Archive-Zip.html
19:06:52 <Balahla> Found it hard to grasp.
19:06:53 <pastorn> Balahla: use this: http://hackage.haskell.org/package/zlib
19:06:59 <Alan> parcs: actually, i already solved my problem - basically, i had an optional bit of syntax between two compulsory bits of syntax
19:07:49 <Alan> parcs: i ended up with something along the lines of "s <- (try (reserved "do" >> stmParser) <|> return Skip)" which seems to work pretty well
19:08:00 <Alan> although i just realised the "try" is unnecessary...
19:11:21 <Berengal> What could cause a process not to exit when main exits?
19:12:38 <pastorn> Berengal: forkOS or IO?
19:12:51 <Berengal> Those should die when main exits
19:13:51 <parcs> Alan: i see. well i was going to say that you can often substitute something like `if bool then action else return ()` with the much nicer `unless bool action` :)
19:14:21 <Alan> parcs: interesting
19:14:46 <Alan> parcs: yeah, the more i thought about this i realised that I needed a value for this variable no matter what
19:14:59 <Berengal> I'm even calling exit explicitly, yet it doesn't die
19:15:20 <Balahla> Starting to grasp Zlib... Thank you guys.
19:17:09 <pastorn> Balahla: paste 'unzipFile' when you have it, it should be 3~4 lines
19:17:12 <pastorn> @paste
19:17:12 <lambdabot> Haskell pastebin: http://hpaste.org/
19:30:40 <dncr> has anyone compared warp and lighttpd for serving static content
19:31:40 <pastorn> Balahla: how's it going?
19:35:36 <JoeyA> What is the smallest compiler or interpreter for Haskell or a usable subset thereof?
19:36:08 <shachaf> @define usable
19:36:26 <shachaf> Compiler to what?
19:36:28 <JoeyA> Has type checking :-)
19:37:40 <JoeyA> and runs code (interpreter) or compiles to a program or to another source language (compiler).
19:39:11 <christo_m> JoeyA: you got a project to do?
19:39:41 <dmwit> Dunno about the smallest, but there's (at least) YHC, NHC, UHC, and GHC.
19:39:44 <JoeyA> nope, mainly for playing around.
19:39:51 <dmwit> Hugs is out there, too, but no compilation.
19:41:02 <JoeyA> Thanks.
19:53:36 <Bfig> i'm having a problem with 'function multiply defined'
19:55:04 <Bfig> i have a series of functions defined on this type: Polynom = Poly [Float] | Divzero | UnasVar, and i have to define them to interact with the errors and the regular stuff. for some reason i get this multiply defined thing, and i don't know how to get around it
19:55:34 <Berengal> I have a finalizer hanging. This program won't print anything: http://hpaste.org/45702/finalizers_hanging
19:55:35 <dmwit> Bfig: Put all the clauses for one function in one place.
19:55:47 <dmwit> Bfig: And don't accidentally write another function later with the same name as one from earlier.
19:56:52 <Bfig> dmwit, all the clauses? four out of five of my functions are one liners
19:57:10 <dmwit> Berengal: Do you have access to the source for sfImage_Destry? Can you put some prints in there?
19:57:13 <Bfig> also, i need to do it several times to pattern match against all possible constructors... right?
19:57:36 <dmwit> Bfig: Why don't you paste some code to hpaste.org or so? Bonus points for pasting the exact error, too.
19:57:54 <Berengal> dmwit: It just calls operator delete, but I could look in the destructor, yeah
19:59:18 <Bfig> http://hpaste.org/45703/error
19:59:42 <napping> JoeyA: I've heard nhc can be pretty small
20:00:24 <dmwit> Bfig: Have you definitely saved the file in your text editor or whatever? Because that error message doesn't match that file.
20:00:40 <dmwit> Bfig: Possibly you should paste some more context.
20:01:21 <Bfig> dmwit, mm sorry, the functions that crap me are pdiv and pmod... 1 seg
20:02:33 <Bfig> dmwit, http://hpaste.org/paste/45703/error_annotation#p45704
20:02:34 <dmwit> Berengal: I wonder if the finalizer could be executing twice.
20:03:09 <dmwit> Bfig: Have you defined pdiv before line 38? My bet is on "yes".
20:03:17 <dmwit> grep will tell you for sure
20:03:18 <Berengal> dmwit: You could remove the explicit call to finalizeForeignPtr, it would still hang
20:03:30 <dmwit> Berengal: Ah, huh.
20:03:38 <Bfig> dmwit, no, i haven't
20:03:43 <Berengal> I just did it so the problem would be, well, explicit
20:03:50 <dmwit> right, okay
20:04:15 <dmwit> Bfig: Possibly you should paste some more context.
20:04:17 <Bfig> dmwit, want to see the whole code?
20:04:27 <dmwit> right
20:07:05 <Bfig> dmwit, password protected paste?
20:07:12 <Bfig> know any?
20:07:15 <dmwit> Berengal: So, what does that & in the import do?
20:07:20 <dmwit> Bfig: ah, hm
20:07:42 <Bfig> hm?
20:08:08 <dmwit> No, I don't know any. Is email secure enough?
20:08:15 <Berengal> dmwit: Imports it as a function pointer
20:08:45 <Bfig> dmwit, don't need it *that* secure. http://pastebin.com/ShjAvgWD
20:09:00 <Bfig> i just don't want google to index it.
20:10:00 <Berengal> dmwit: The destructor runs fine http://hpaste.org/45705/
20:10:32 <dmwit> Berengal: WEIRD!
20:10:53 <Berengal> yes, very weird. It doesn't happen to everything either
20:10:56 * ivanm quickly spreads Bfig's code all throughout the interwebz
20:11:18 <dmwit> Bfig: As I said: you need to put all your clauses for each function together.
20:11:23 <ivanm> Bfig: any particular reason for you indenting each line after the module statement by one space?
20:11:26 <dmwit> Bfig: You need to put the clauses for pdiv all together.
20:11:38 <Bfig> ivanm, i'm a crazy motherfucker. ( :p )
20:11:44 <Berengal> It *does* seem to only happen when I use objects that someone interact with openGL
20:11:44 <dmwit> Bfig: e.g. move lines 64-67 up to line 42 or so.
20:11:55 <Berengal> somehow*
20:11:58 <Bfig> dmwit, ohh i didn't understand when you said that before. that's weird
20:12:07 <dmwit> It's not that weird.
20:12:23 <dmwit> The Haskell language designers didn't want to give coders the (wrong) impression that functions are open.
20:13:11 <Bfig> what does that mean?
20:13:22 <dmwit> Berengal: Also, by the way, is that just a copying error, or why isn't that quote mark a back-tick on line 8?
20:13:30 <dmwit> "'fromNull mkImage'*"
20:13:45 <Bfig> by the way, thanks for the solution!
20:13:45 <Berengal> dmwit: That's c2hs syntax
20:14:00 <dmwit> Bfig: Functions are closed, meaning that they can't draw their definition from multiple modules -- or multiple places within a single module, as you just noticed.
20:14:10 <Bfig> ahh ok
20:14:34 <Berengal> dmwit: And that part isn't a backtick at all, the only backtick on that line is in the `String' part
20:15:28 <dmwit> Berengal: I know, I'm asking why it *isn't* a backtick.
20:15:49 <JoeyA> napping: Thanks, I'll take a look at nhc.  I wonder why the source tarball is 28.5 MB (nhc98src-1.2.2.tar.gz ), though.
20:15:52 <dmwit> Berengal: (And `String' isn't the only backtick -- `Maybe Image' has one, too.)
20:16:11 <Berengal> Ah, true
20:16:19 <Berengal> dmwit: that's a marshaller with arguments
20:16:27 <dmwit> hokay
20:16:30 <Berengal> dmwit: The marshaller is 'fromNull mkImage'
20:16:36 <dmwit> yep
20:16:54 <Berengal> (Which is maybe a bit weirdly named now that I think about it)
20:17:08 <dmwit> Oh, by the way, if you're using C++, did you remember the trick you need to export to C?
20:17:12 <dmwit> I don't remember what it is.
20:17:19 <dmwit> extern "C" or something like that.
20:17:30 <Berengal> dmwit: I'm writing against the C bindings, otherwise this wouldn't link at all...
20:17:35 <dmwit> Okay, great.
20:18:12 <dmwit> Let's see if I can reproduce it here.
20:18:58 <Berengal> dmwit: Finalizers *do* work for some things. I'm guessing openGL has something to do with it
20:21:25 <napping> JoeyA: It's probably gotten bigger. There was a thread a few years back on one of the mailing lists, where someone mentioned getting some compiler to work on a workstation with a few MB of ram
20:23:51 <JoeyA> Thanks
20:26:25 <christo_m> https://github.com/christomitov/Turnip/blob/master/Parser.hs#L105   Anyone know why this is inferring an Expr instead of an Lvalue
20:26:41 <christo_m> specifically line 113
20:27:16 <christo_m> Assignment is a Stmt, and Var is an Expr
20:27:28 <christo_m> i think the issue is there
20:27:58 <Berengal> dmwit: The problem may be in SFML. I got it working a couple of commits ago
20:28:17 * Berengal checks a pure C version
20:29:48 <christo_m> oh right, exp_exp..
20:31:13 <christo_m> should be primaryexp , but still doesnt fix
20:31:57 <Berengal> dmwit: Yep, the problem is in the library I'm using
20:32:25 <dmwit> Berengal: Sweet.
20:38:55 <christo_m> WORKS
20:39:45 <dmwit> Berengal: Great, because I finally just got a minimal test case and couldn't reproduce your problem. =P
20:40:33 <Berengal> dmwit: I said it worked for some things, which would mean there had to be something special going on in the C code as well (which might still have been a Haskell problem, but much less likely)
20:47:44 <mzero> woot - got my copy of "Learn You a Haskell for Great Good" in the mail today!
20:47:48 <mzero> It's lovely!
20:47:57 <mzero> Miran, if you are here... congrats!
20:48:10 <djahandarie> Miran?
20:48:10 <ivanm> preflex: seen BONUS 
20:48:11 <preflex>  BONUS was last seen on #haskell 5 hours, 33 minutes and 18 seconds ago, saying: also hpc great review! if i reviewed your review i'd give it 5 stars
20:48:17 <ivanm> djahandarie: Miran == BONUS
20:48:20 <djahandarie> Ah
20:48:29 <djahandarie> All these fancy 'real names'
20:48:32 <ivanm> yeah, mine's apparently in the mail
20:48:33 <ivanm> djahandarie: heh
20:48:40 <DylanLukes> Whoooo.
20:48:41 <DylanLukes> Real names.
20:48:43 <DylanLukes> Scary.
20:48:55 <djahandarie> I would change my nick to my real name BUT IT ALREADY IS WHAT NOW
20:49:01 <DylanLukes> FFFF
20:49:09 <nyingen> 0xFFFF
20:49:24 <dylukes> 0xFFFFFFFF–
20:49:45 <KATTENS> ?DCC SEND "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhh" 0 0 0
20:49:46 <lambdabot> Unknown command, try @list
20:49:54 <djahandarie> Oh wow
20:49:59 <djahandarie> Did that actually take some people out?
20:50:11 <dmwit> People are still using old hardware, I guess.
20:50:15 <nyingen> @keal
20:50:15 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
20:50:27 <nyingen> keal has some quote "I use an 8088"
20:50:32 <nyingen> I guess I was hoping for that one
20:50:40 <dmwit> It might not even be the people that dropped -- could be people in between them and Freenode.
20:51:27 <dylukes> rofl.
20:51:34 <ivanm> @where ops
20:51:34 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:51:35 --- mode: ChanServ set +o mauke
20:51:35 --- mode: mauke set +q $a:lambdabot
20:51:43 <dylukes> I kind of want to try that in a bigger room
20:51:46 <djahandarie> lmfao mauke 
20:51:52 <djahandarie> Fix your damn script
20:51:54 <ivanm> dylukes: there are bigger rooms? :o
20:51:54 <christo_m> Block [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])]
20:51:58 <christo_m> WOOT
20:52:01 <christo_m> parsed my lua factorial program
20:52:03 <dylukes> ivanm: A few ;)
20:52:06 <nyingen> ivanm: Are you the maintainer of fgl?
20:52:12 <ivanm> nyingen: technically...
20:52:14 <napping> what are you making for lua?
20:52:18 <ivanm> but I haven't had time to touch it recently :s
20:52:25 --- mode: mauke set -o mauke
20:52:28 <christo_m> my heads exploding gentlemen
20:52:31 <christo_m> napping: a compiler
20:52:32 <dmwit> christo_m: NICE
20:52:39 * ivanm keeps meaning to look through edwardk's new graph library
20:52:46 <christo_m> im committing this beast
20:53:09 <nyingen> ivanm: no worries...but a quick question: if I have a graphlike (recursive) data structure, can I use fgl to navigate/manipulate it?
20:53:24 <ivanm> nyingen: only if you can implement the type classes for it
20:53:27 <nyingen> I see
20:53:32 <ivanm> which means: 1) the keys need to be Ints
20:53:33 <christo_m> environment is still going to be hectic
20:53:40 <ivanm> 2) you need to be able to decompose and compose inductively
20:53:49 <christo_m> acowley suggested associative lists, but that seems like dynamic scoping
20:53:55 <christo_m> i should be able to figure out scope at compile time.
20:54:02 <nyingen> ivanm: I think I can satisfy (2), but to satisfy (1) I have to add some kind of index field
20:54:13 <nyingen> do you think that's a good approach, or is that not what fgl is meant for?
20:54:13 <ivanm> nyingen: *nod*
20:54:20 <ivanm> why, what are you wanting to use FGL for?
20:54:57 <nyingen> graph navigation/manipulation...my graphs are tree-ish, but some of them have cycles
20:55:14 <nyingen> fgl has some cool features, not least its tie in to graphviz :)
20:55:20 <nyingen> er, tie-in
20:55:20 <jmcarthur> ivanm: why the call to @ops?
20:55:22 <ivanm> yeah, that's me :D
20:55:31 <ivanm> jmcarthur: because KATTENS is back
20:55:41 <napping> christo_m: Is lua sufficiently dynamic you need something like that?
20:55:44 <jmcarthur> oh
20:55:46 <djahandarie> jmcarthur, well now that you're here, unquiet lambdabot :P
20:55:53 --- mode: ChanServ set +o jmcarthur
20:55:54 <napping> I know Python allows some evil with frame objects
20:55:54 <christo_m> napping: dynamic, right, so type checking isnt an uber concern
20:55:59 <christo_m> however, i still need to know where things are
20:56:01 --- mode: jmcarthur set -q lambdabot!*@*
20:56:07 <christo_m> a bonus is theres a "local" keyword
20:56:12 <djahandarie> It was under $a:lambdabot
20:56:16 <napping> No, I mean, can you access the current scope as a dictionary, and add stuff to it?
20:56:19 --- mode: jmcarthur set -q $a:lambdabot
20:56:21 <djahandarie> 01:00 - mode/#haskell [+q $a:lambdabot] by mauke
20:56:25 <Gando-san> ?DCC SEND "hhhhhhhhhhhhhhhhhhhhhhhhhhhhhh" 0 0 0
20:56:25 <lambdabot> Unknown command, try @list
20:56:26 <christo_m> napping: right thats what i plan to do
20:56:34 <nyingen> wtf
20:56:36 <djahandarie> lol
20:56:36 <christo_m> napping: keep a list of Identifiers and Values
20:56:52 <ivanm> *sigh*
20:57:16 <napping> It seems to take quite a bit of cleverness to compile lua well
20:57:17 --- mode: jmcarthur set +b *!*@75.134.98.150
20:57:28 --- mode: jmcarthur set +b *!*@adsl-84-145-16.gsp.bellsouth.net
20:57:43 <napping> luajit does an excellent job, but it doesn't sound simple
20:57:58 <djahandarie> Compilers are generally never simple though, right?
20:58:00 <nyingen> who was KATTENS
20:58:13 <ivanm> nyingen: the first person to use the DCC exploit just before
20:58:16 <djahandarie> nyingen, probably a client overtaken by some virus.
20:58:20 <jmcarthur> somebody exploiting an old irc bug
20:58:25 <nyingen> I see
20:58:33 <christo_m> djahandarie: apparently to everyone here theyre a piece of cake
20:58:36 <ivanm> jmcarthur: that still seems to work on 3 people here
20:58:43 <christo_m> ive been harrassing people in here for a week
20:58:43 <jmcarthur> yeah...
20:58:47 <christo_m> trying to understand life
20:58:52 <djahandarie> christo_m, huh?
20:59:06 * ivanm has never written a compiler and doesn't have any intention of doing so
20:59:17 * BMeph is back to lurking...
20:59:31 <christo_m> djahandarie: i mean ive learned more about compilers after a week in #haskell than i have all semester
20:59:32 <ivanm> RayNbow: you better not have just joined so as to try to use DCC exploits in here! :p
20:59:35 <christo_m> http://www.cas.mcmaster.ca/~carette/CS4TB3/2011/
20:59:39 <napping> well, compilers can be easier or harder
20:59:42 <djahandarie> christo_m, ah, lol.
20:59:44 <christo_m> BMeph: check the newest source if you have time
20:59:45 --- mode: jmcarthur set -o jmcarthur
20:59:50 <RayNbow> ivanm: did I miss something? :p
20:59:56 <jmcarthur> yeah you did
21:00:00 <BMeph> christo_m: About to now. :)
21:00:09 <ivanm> RayNbow: yeah, two (?) people just came in and used the old DCC exploit
21:00:21 <ivanm> you were the next person to join the channel (as opposed to re-joining), so... :p
21:00:34 --- mode: ChanServ set +o monochrom
21:00:42 <RayNbow> aren't dcc exploits from the previous century or something? :p
21:00:47 <djahandarie> monochrom, a little late on the draw there
21:00:53 <monochrom> heh
21:00:54 <ivanm> the previous century was only 11 years ago...
21:00:56 --- mode: monochrom set -o monochrom
21:01:07 * BMeph wonders if monochrom knows something about ISF...
21:01:08 <christo_m> BMeph: i got along night man, this is due at 9 am.. and i still have to do code generation :O
21:01:21 <ivanm> we need to have a "@where ops" race to see how fast everyone is to see what's wrong! :p
21:01:24 <monochrom> what is ISF?
21:01:31 <ivanm> monochrom: the next person to join the channel
21:01:39 <BMeph> monochrom:
21:01:42 <RayNbow> ivanm: I know, but I prefer to use "previous century" because it sounds longer ago :p
21:01:43 <ivanm> just before you you op'd
21:01:52 <BMeph> [--:16] * ISF (~ivan@201.82.132.61) has joined #haskell
21:01:53 <BMeph> [--:17] * ChanServ sets mode: +o monochrom
21:02:28 <monochrom> oh, coincidence
21:02:37 <BMeph> Or, to be less wordy, what ivanm said. :\
21:02:42 <nyingen> @quote
21:02:43 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
21:02:43 <ivanm> there are no such things as coincidences!
21:02:44 <ISF> yes, coincidence
21:02:58 <monochrom> alright, historical accident
21:03:14 <ivanm> hmmmm.... OK, you can have that
21:03:15 <ivanm> :p
21:05:05 <RayNbow> @faq Can Haskell be taught to kittens?
21:05:05 <lambdabot> The answer is: Yes! Haskell can do that.
21:05:27 <BMeph> christo_m: Amusing..."Required: _Modern Compiler Design_ by Grune, Bal, Jacobs and Langedoen. [It's a paperback, so quite affordable]; title links to publisher site, showing: ...US $97.95" Apparently, "quite" means something different in Canada... ;þ
21:06:02 <espringe> They were probably referring to the torrent
21:06:48 <lispy> BMeph: that's a decent book
21:07:01 <lispy> BMeph: I have a copy.  I like that it actually covers a bit of haskell
21:07:14 <lispy> Not as precise as the dragon book, but significantly more modern
21:07:17 <shachaf> BMeph: Amazon has it for rather cheaper, it seems.
21:07:26 <shachaf> Well, sellers on Amazon, I guess.
21:08:11 * BMeph wonders what the most expensive book in print from a professor at a "Free University" is...;þ
21:10:01 <RayNbow> BMeph: Langedoen? That's a prof at TUDelft
21:10:13 <napping> christo_m: do you know if scopes in Lua can be used as tables? (besides _G)?
21:10:16 * RayNbow has that book btw
21:10:25 <RayNbow> but I couldn't read it
21:10:42 * RayNbow passed the compiler course by reading the slides instead
21:11:19 <napping> according to #lua, they cannot
21:11:26 <napping> so, computing static scopes is reasonable
21:13:14 <christo_m> napping: i know they are, the do .. end keywords make it sufficient
21:13:23 <christo_m> RayNbow: no slides..
21:13:34 <christo_m> BMeph: ya i know, i have the .djvu so, it was very affordable ;)
21:16:05 <christo_m> napping: i think i can literally just walk through my AST, every time i enter a block, i know im a new scope
21:16:08 <christo_m> in*
21:16:27 <christo_m> then i just push all the bindings on the list.. pop them when i leave the block
21:18:44 <BMeph> RayNBow: Yes - he's the only one not at a (declared) Free U. Thus my prior remark. ;)
21:19:10 <BMeph> christo_m: Affordable? Yes, "quite"! ;þ
21:20:08 <RayNbow> :)
21:20:21 <christo_m> BMeph: did you notice a mistake in that AST?
21:20:25 <RayNbow> anyway, time to drive to work :)
21:20:37 <christo_m> when i make a call to factorial, it treats it as a variable..
21:20:41 <christo_m> actually, thats right i think.
21:20:45 <BMeph> christo_m: " push all the bindings on the list.." - of a-lists, right? ;)
21:20:47 <christo_m> given that factorial(n-') should return
21:20:53 <christo_m> BMeph: right, which is still a list
21:20:56 <christo_m> of pairs though
21:21:10 <BMeph> christo_m: No, I didn't. Was there one? 
21:21:37 <christo_m> Block [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])]
21:21:49 <christo_m> is calling factorial a variable adequate here?
21:22:00 <christo_m> i guess it is, im temporarily binding the value it returns with those parameters
21:22:12 <christo_m> im talking about (Call (Var "factorial")
21:33:52 <askatasuna> hello everyone. are the haskell library docs available in pdf form?
21:34:14 <askatasuna> I could not find them so at the wiki or via google.
21:36:47 <mzero> no
21:36:59 <mzero> you mean the Haskell Platform libraries?
21:38:04 <dankna> does Haddock actually support pdf output?
21:38:12 <mzero> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/start.html
21:38:20 <dankna> if so, you could certainly build it yourself (or indeed set up a ~/.cabal/config to have it always built for you)
21:38:41 <ivanm> dankna: apparently, but I"ve never seen anyone generate them
21:38:55 <mzero> not directly -- via LaTeX
21:39:05 <dankna> oh
21:39:15 <ivanm> I thought it was docbook...
21:39:27 <dankna> yeah, I can think of exactly one use for pdf and that would be reading it on my phone, because the html isn't optimized for that
21:42:20 <BMeph> christo_m: Looking at the filled-out Parser now.... 
21:42:42 <mzero> dankna - create a new haddock theme for phones!
21:42:49 <mzero> it's all skinnable
21:43:45 <dankna> yeah, I'll push that on my todo queue
21:43:59 <dankna> heh
21:44:19 <christo_m> BMeph: IoASTError where is that defined?
21:44:21 <christo_m> cant find it
21:48:13 <osoleve> is anyone here familiar with Codec.Wav?
21:51:34 --- mode: ChanServ set +o mauke
21:51:34 --- mode: mauke set -q $a:lambdabot
21:51:54 <christo_m> because im doing loadAST fname = do{ anAST <- parseFromFile program fname; return anAST}
21:51:57 <christo_m> im getting Right at the starting
21:51:58 <amalloy> how do i get the tools that LYAH assumes? http://hackage.haskell.org/platform/linux.html links me to http://packages.ubuntu.com/search?keywords=haskell-platform, but it looks like those binaries haven't been updated. is installing ghc6 good enough?
21:52:06 <christo_m> then i use Data.Either rights function to extract these but it fails.
21:52:24 --- mode: mauke set -o mauke
21:52:36 <christo_m>     Couldn't match expected type `[Either a b]'
21:52:37 <christo_m>            against inferred type `Either ParseError Block'
21:52:43 <christo_m> its expecting a list?
21:52:50 <mzero> amalloy - if you are just getting going with Haskell, then sure, GHC  6.12 is good enough
21:53:34 <amalloy> mzero: i'm restarting an aborted attempt to learn haskell a few months ago :)
21:53:47 <mzero> LYAH is a find way to go
21:54:28 <mzero> you'll want to install cabal-install as well
21:54:32 <BMeph> christo_m: A big "hint": IoASTError is a Type.... ;)
21:55:10 <christo_m> well i know that, its capitalized :P
21:55:21 <christo_m> anyway i stopped looking for it, no time lol
21:55:25 <mzero> amallow: welcome to the start of a wonder ride --- you'd never guess having your brain turned into a pretzel could be so much fun!!! :-)
21:55:37 <christo_m> BMeph: any idea how im going to walk my AST, i dont have it going anywhere right now
21:55:41 <christo_m> im just printing it out
21:55:42 <amalloy> mzero: yeah, i'm coming from clojure/lisp, fwiw
21:55:47 <christo_m> im looking at your loadAST code to get an idea
21:55:56 <mzero> oh -- well then, you're used to your brain being a pretzel
21:55:57 <BMeph> christo_m: I have a module named "Types.hs". It's in there. ;þ
21:56:10 <amalloy> so a lot of the concepts are familiar but the type system really fascinates and puzzles me
21:56:13 <osoleve> GUI? ew
21:56:18 <osoleve> wrong channel. gosh.
21:56:30 <mzero> and just wait till you get used to the syntax --- 
21:56:41 <mzero> everything else will start to look like overgrown weeds!
21:56:47 <osoleve> you'd think after a few months of using irssi, i'd stop typing into the wrong channels. but nooo.
21:57:13 <BMeph> christo_m: Anyway, you want to use "Data.Either.either", not "Data.Either.rights" - unless you're parsing a list of ASTs, in which case, never mind. =8*O
21:57:24 <amalloy> mzero: pft, say that to a lisper? going from java/c to lisp was a huge reduction in syntax; i'd be surprised (from my previous examination of haskell) if i were convinced that it had *less* syntax
21:57:49 * mzero smiles devilishly
21:58:06 <amalloy> *chuckle*
21:58:24 <BMeph> amallory: Maybe not less syntax, as much as less syntax noise. ;)
21:58:59 <amalloy> i've been amallory and amallow already. does #haskell ban tab completion? :)
21:59:11 <BMeph> Sorry, meant amalloy: ^^
21:59:18 <osoleve> of course not, atallow
22:00:00 <BMeph> amalloy: No, in fact, it's highly used. Some folks like to work on their typing (lack of) skills. At others' expense. ;)
22:00:05 <dankna> actually #haskell seems to mildly promote tab completion
22:00:18 <dankna> I've been criticized twice for not using it and instead abbreviating names :)
22:00:58 <BMeph> I've seen many others get in trouble for not tab-completing to get to the right name.
22:00:59 <amalloy> dankna: there are a couple guys in #clojure you can't tab-complete at all. very sad
22:00:59 <mzero> isn't tab completion a feature of one's client, not the channel?!?!
22:01:07 <amalloy> mzero: of course
22:01:21 <dankna> mzero: yes, but the social norm is a feature of the social group, which is tied to the channel
22:01:35 <christo_m> BMeph: okay no clue man
22:01:35 <shachaf> Of course it would be nice if prefixes were more evenly spread.
22:01:40 <dankna> people frequently confuse me with other people whose names start with dan-, yes
22:01:41 <christo_m> you have like 50 layers lol
22:01:48 <shachaf> There are several "sha"s and not one "vdn".
22:01:49 <christo_m> i go to the type and its just a showstring
22:01:55 <christo_m> i just want to return the right of the thing
22:02:13 <dankna> one time in -blah we were having a conversation about vanadium, the rare earth, and someone named vanadium eventually spoke up and asked us to please stop beeping him :)
22:02:33 <dankna> amused me greatly
22:02:52 <BMeph> christo_m: ...and if it's a Left, then exit with a graceful error message. Right? RIGHT?!?!? ;)
22:02:57 <amalloy> dankna: at least having him around made the conversation easier. you could all use tab completion
22:02:59 <christo_m> BMeph: right..
22:03:01 <christo_m> i dont know what to throw
22:03:01 <dankna> haha, true!
22:03:15 <shachaf> dankna: Similarly, when people talk about danknas, it must annoy you at least a bit.
22:03:25 <dankna> it is very strange, but it has never happened
22:03:42 <dankna> I think if it did I'd be too amused to mind
22:03:52 <christo_m> can i print something, do i need to throw?
22:04:06 <mzero> okay - I built Haskell Platform 32-bit, then used that HP 32-bit to build HP 64-bit... and now I'll uninstall HP 32-bit to see if HP 64-bit installs and works.... and if it doesn't..... I have to start all over again
22:04:14 <amalloy> i already associate you with dank smelly caverns, dankna, because of how far i have to get to tab-complete you
22:04:15 <shachaf> People have talked about shachafs in my presence. But never in IRC.
22:04:23 <dankna> mzero: this is why you need to save a tarball of your installed directory
22:04:41 <dankna> amalloy: oddly enough, fifteenish years ago I used to go by "dank" until I decided that was an undesirable association
22:04:43 <mzero> well - yes, actually, I did - and don't have to repeat step 1.... but
22:04:57 <mzero> all the same.... this crazy dance drives me batty
22:04:58 <dankna> I am dismayed to hear that at least one person still has that association :)
22:05:09 <christo_m> BMeph: you see how prettyLuaFromFile is done? i wish i could just take whats in the Right, and pass it somewhere instead of printing it
22:05:22 <dankna> mzero: yeah, I agree, it's pretty tiresome.  especially when it takes all day.
22:05:33 <amalloy> dankna: just boot danly and i'll think of you as dan. surely worth the effort
22:05:47 <dankna> amalloy: on the other hand, the fact that you associate me with anything at all probably means I'm making valuable contributions, so yay me.
22:05:59 <dankna> I'm not an op :)
22:06:08 <dankna> and we have several other Dans, just not at this hour
22:06:25 <dankna> and I've been known to go by dankna even in person, because it's a nice unique identifier that isn't too bizarre
22:06:48 <dankna> and I'm never likely to read "dankna linked to the nasty type of cancer" in the WSJ
22:07:10 <mzero> dankna: do you pronounce it dan-kna, or dank-na?
22:07:25 <dankna> both, but the former unless I'm feeling Japanesey
22:07:43 <christo_m> ah i see what print does
22:08:01 <shachaf> mzero: What's the difference between the pronunciations?
22:08:19 <mzero> uhm- try it out loud and see!  ;-)
22:08:42 <dankna> many people get stuck using the first username they ever chose, at the age of twelve or so, because by the time they grow up enough to want something that isn't named after their favorite band of the week, they've already used that one in a million places and it's too much work to change them all...
22:09:07 <dankna> I got stuck with it for the same reason, but I had the foresight to choose one that I still like :)
22:09:40 <MatrixFrog> ok so i'm trying to get up and running with haskell on windows and i'm getting stuck. the errors i'm getting look pretty much like this: http://trac.haskell.org/network/ticket/20
22:09:41 <shachaf> Mine works reasonably well. Except that it's occasionally taken.
22:09:49 <dankna> is it really?
22:09:52 <christo_m> Right (Block [Function [["n"]] (Block [If [(BinOp "==" (Var "n") (Number 0.0),Block [Return [Number 1.0]])] (Just (Block [Return [BinOp "*" (Var "n") (Call (Var "factorial") [BinOp "-" (Var "n") (Number 1.0)])]]))])])
22:09:56 <christo_m> i just want to skip that effing Right
22:09:57 <dankna> oh, I see, it's a given name
22:09:58 <MatrixFrog> if someone could give me a hint of what to do that would be super great
22:10:14 <dankna> yeah, that works pretty well given that it's not among the few thousand most common ones
22:10:21 <mzero> sigh -- the first user name I choose was.... "mark"  -- back when the Internet was small enough that I could be mark@ both my university, and the later at the first computer company I worked at
22:10:22 <dankna> MatrixFrog, looking
22:10:30 <dankna> mzero: wow :D
22:10:31 <mzero> I was    mark@apple.com
22:10:36 <dankna> whoa!
22:10:43 <dankna> nice trick
22:10:44 <mzero> but those days are long gone
22:10:45 <MatrixFrog> thanks! i'm using cygwin, i should have also said
22:10:47 * dankna nods
22:10:52 <shachaf> mzero: Does someone else have that email now?
22:11:01 <mzero> I doubt apple allows it
22:11:24 <mzero> on the other hand, I am   mzero@ my current computer company
22:11:50 <amalloy> mzero: cleverly representing that you were the zeroth mark
22:12:01 <dankna> MatrixFrog, could you nopaste the actual transcript (or at least the last five to ten lines of it) of your attempt, so I can see how it compares to this old bug ticket?
22:12:22 <dankna> "mark" is a name that ought to allow for some sort of clever computer-related pun
22:12:35 <dankna> it certainly allowed one famous author a clever steamboat-related pun
22:12:38 <mzero> ... or the identity element in MonadPlus
22:12:39 <BMeph> christo_m: If you really want to "just want to skip that effing Right", then do it! Use "either".
22:12:45 <dankna> yes, or that, as you say
22:12:48 * shachaf wonders whether markiiibeast is taken.
22:12:54 <MatrixFrog> i'm doing "cabal install network"... hang on
22:13:08 <MatrixFrog> what i'm actually trying to do is run tweetov because it looks fun
22:13:13 <MatrixFrog> but anyway
22:13:16 <dankna> never heard of tweetov, but yeah
22:13:24 <dankna> oh Markov chain tweets
22:13:25 <dankna> sounds fun
22:13:32 <MatrixFrog> i was just looking for interesting-sounding haskelly things on github
22:13:38 * dankna nods
22:13:39 <MatrixFrog> https://github.com/jaspervdj/tweetov
22:13:51 <MatrixFrog> and i did a markov chain project in college in C++
22:13:52 <MatrixFrog> but anyway
22:13:54 <dankna> someday I want to produce a better-than-Markov-chain nonsense generator that uses real grammar
22:14:15 <MatrixFrog> "* Missing header file: HsNet.h" seems to be the actual error
22:14:28 <MatrixFrog> all the "report this to libraries@haskell.org" stuff was throwing me off
22:14:38 <dankna> hmm
22:14:51 <dankna> let me unpack the network package's latest version locally and see how that file is generated and why it might be missing
22:14:57 <mzero> MatrixFrog: are you installing Haskell Platform?
22:15:01 <BMeph> christo_m: Or just do it "manually": "fromRight :: Either a b -> b; fromRight (Right b) = b". Done. :)
22:15:05 <MatrixFrog> yeah i have haskell platform
22:15:26 <dankna> you should already have network if you have Haskell Platform installed, actually
22:15:27 <mzero> then you should *have* the network package
22:15:33 <dankna> installing a new copy of it shouldn't be necessary
22:15:38 <MatrixFrog> ok
22:16:01 <mzero> infact - you should be able to    cabal install --dependencies-only
22:16:04 <dankna> and the file appears to be included in the source distribution, so.
22:16:12 <mzero> in your pull of tweetov and get just what you need
22:16:16 <MatrixFrog> i think i had just done "runhaskell Tweetov/Server.hs" and then used cabal to get all the dependencies whenever it would say it needed one
22:16:26 <MatrixFrog> so let me try that again
22:16:32 <dankna> oh, yeah, runhaskell needs the -package flag sometimes
22:16:40 <christo_m> BMeph: you're a g
22:16:41 <christo_m> *Main> :t loadAST "test/fac.lua" 
22:16:41 <christo_m> loadAST "test/fac.lua" :: IO LuaAS.Block
22:16:51 <christo_m> though it should be of type AST
22:16:53 <christo_m> block is good enough right now
22:17:10 <mzero> that project is cabal'ized --- don't runhaskell it, cabal configure; cabal build it
22:17:15 * BMeph wonders if there is a statistician who is frustrated at not being able to be taken seriously if he ever published a paper on "Markov-Gold Chains"? ;þ
22:17:38 <MatrixFrog> mzero but i want the version of it from github. i assume if i just use cabal it will pull it from hackage instead?
22:17:59 <mzero> no, I mean, in your local clone of tweetov
22:18:37 <MatrixFrog> ok cool. so i did "cabal configure" and got this
22:18:38 <mzero> in that dir
22:18:43 <mzero> type   "cabal install --only-dependencies"
22:18:47 <mzero> then "cabal configure"
22:18:47 <MatrixFrog> cabal.exe: At least the following dependencies are missing:
22:18:47 <MatrixFrog> json >=0.4, redis >=0.7, snap-core >=0.2, snap-server >=0.2
22:18:49 <mzero> then "cabal build
22:18:52 <MatrixFrog> oh ok sorry
22:18:57 <mzero> that will do your local version
22:19:10 <mzero> do that install line in that dir
22:19:19 <BMeph> christo_m: You could be even more clever and have one function that reads the Lua from a file, and a separate function that does "parseTest" vice "parse" on it, thus separating the IO Blah from the AST.
22:19:21 <mzero> that will find and pull those needed packages from hackage
22:19:34 <MatrixFrog> nice. :D
22:19:47 <amalloy> hm. how do i get emacs to interact with ghci? i've installed haskell-mode, which claims it will interact with a ghci instance, but i can't find it?
22:20:33 <dankna> no clue, never used that feature.  in fact I'm currently working without Emacs altogether.
22:21:44 <MatrixFrog> "unrecognized option `--only-dependencies`"
22:22:13 <MatrixFrog> cabal --version:
22:22:13 <MatrixFrog> cabal-install version 0.8.2; using version 1.8.0.6 of the Cabal library
22:23:31 <christo_m> BMeph: made a note, gotta figure out this environment stuff and do some basic code gen first
22:23:57 <mzero> MatrixFrog: bummer - older cabal --- well then
22:24:04 <christo_m> BMeph: where did you do actual AST traversal to populate your standard environment?
22:24:10 <MatrixFrog> so i tried "cabal install cabal" and got some other error
22:24:33 <dankna> yeah, a) you meant cabal install cabal-install
22:24:35 <mzero> "cabal update" -- to get new package list
22:24:37 <dankna> b) I'm not sure that one works
22:24:50 <MatrixFrog> mmmmk sounds good
22:24:54 <mzero> then "cabal install json redis snap-core snap-server"
22:27:16 <MatrixFrog> grah. "cabal install cabal-install" tries to configure network-2.2.1.7
22:27:35 <MatrixFrog> thank you so much for your patience with this though :)
22:28:22 <mzero> I wouldn't worry so much about cabal-install itself....
22:28:30 <mzero> if you've got a working set up
22:28:32 * RayNbow`TU is going to try to install some Haskell packages without getting screwed by F-Secure...
22:28:41 <mzero> don't try to upgrade cabal-install right now... too much yak shaving
22:29:21 <christo_m> BMeph: crap your right i need to get rid of the IO part
22:29:41 <MatrixFrog> ok
22:29:42 <christo_m> BMeph: so you're saying one that does Filepath reading, then another thatll take IO as an argument and give back a Block
22:29:46 <MatrixFrog> so json worked
22:30:01 <christo_m> BMeph: not really sure how to do that but okay
22:30:11 <MatrixFrog> but then i think redis depended on network so it tried to configure network again
22:31:15 <MatrixFrog> i wonder if i somehow just totally messed something up and would be better off reinstalling the whole platform
22:32:07 <christo_m> Anyone care to explain how i can convert something IO to non IO?
22:32:32 <mzero> christo_m: you... er... can't.... at least not safely
22:32:47 <mzero> do you mean you have a result in IO, and you need to do something non-IO to it??
22:32:55 * cads just remembered he wants to make a haskell coding vm
22:32:57 <mzero> THAT we can help you with
22:32:58 <christo_m> mzero: okay i want to read a file, and parse it
22:33:01 <christo_m> which im doing
22:33:06 <christo_m> but i want to deal with the structure 
22:33:11 <christo_m> right now its an IO Block, and i just want a Block
22:33:43 <mzero> and when you say "deal with it" you mean transform it   Block -> Block
22:33:44 <mzero> ?
22:33:52 <christo_m> IO Block -> Block
22:33:53 <christo_m> yes
22:33:59 <cads> guys, what's the smartest way to sandbox a haskell platform installation?
22:34:03 <christo_m> https://github.com/christomitov/Turnip/blob/master/Parser.hs
22:34:13 <mzero> so, write your transforming function purely -- that is   Block -> Block as the type signature
22:34:15 <mzero> then
22:34:23 <cads> such that if I screw something up I can just rollback to a snapshot
22:34:27 <christo_m> mzero: i dont think i can do that, as reading a file is IO
22:34:30 <cads> should I have it all in git?
22:34:34 <mzero> you can
22:34:40 <mzero> because then what you do is
22:34:42 <mzero> something like
22:35:55 <dankna> cads: be on a Mac and the platform installs into a .framework
22:35:58 <christo_m> mzero: ?
22:36:00 <mzero> main = do { txt <- getContents; let output = format . transform . parse $ txt; putStrLn txt }
22:36:08 <dankna> cads: which you can tar or otherwise copy and use as a backup
22:36:16 <mzero> so - is your parser really String -> Block
22:36:21 <MatrixFrog> so yeah. if i just try to 'cabal install redis' then it thinks it needs to get network-2.2.1.7 as well... it's like it doesn't "see" network for some reason...?
22:36:24 <mzero> but you've got it stuck in IO
22:36:32 <dankna> cads: the downside of this advice is that if it doesn't apply, you can't really do anything about it
22:36:33 <christo_m> i dont think it is
22:36:36 <mzero> or does your parser need to be in IO (say it reads include files or some such)
22:36:43 <mzero> so sure
22:36:43 <christo_m> no it doesnt need to be
22:36:47 <mzero> great
22:36:50 <mzero> look at my main function
22:36:51 <mzero> there
22:36:52 <christo_m> and i said i dont think it is to "string -> block"
22:37:01 <mzero> can you make it so?
22:37:07 <mzero> does it really do any IO during parsing?
22:37:14 <christo_m> no
22:37:16 <christo_m> it reads the file 
22:37:20 <christo_m> does the parsing on that
22:37:21 <mzero> so take it out of IO
22:37:24 <christo_m> if i can read it all into a string, awesome
22:37:34 <mzero> :t getContents
22:37:35 <lambdabot> IO String
22:37:53 <christo_m> ..but thats IO!
22:38:08 <mzero> no - only the reading of the input is in IO
22:38:17 <christo_m> did yo ulook at what i linked
22:38:22 <mzero> you'll "lift" the parsing, and the transforming into IO
22:38:27 <mzero> form the pure functions you write
22:38:45 <MatrixFrog> anyone else think maybe i should just uninstall and reinstall the whole platform? :-/
22:39:02 <mzero> so here --- say you've got a value   b  :: IO Block
22:39:03 <dankna> Matrix: no, I don't think you've messed up your platform install (yet :) )
22:39:17 <mzero> and you've got a pure block transformation:    t :: Block -> Block
22:39:19 <christo_m> mzero: all my main does is call loadAST
22:39:37 <mzero> then       t `fmap` b     gives you a new IO Block ---  but transformed
22:39:53 <mzero> t can remain pure
22:40:03 <mzero> christo_m: stick it on hpaste
22:40:06 <mzero> let's look
22:40:09 <MatrixFrog> dankna: http://pastebin.com/9Zgz5Qpy
22:40:24 <christo_m> mzero: https://github.com/christomitov/Turnip/blob/master/Parser.hs
22:40:43 <dankna> hm
22:41:08 <christo_m> so it was suggested to do IO separately from actually loading the AST
22:41:16 <christo_m> i just dont know how to escape it
22:41:45 <mzero> okay
22:41:49 <dankna> I note that 2.2.1.7 is not the latest version of network, and I wonder why redis is depending on it
22:42:00 <mzero> so imagine you've got a function   transAST :: AST -> AST
22:42:06 <christo_m> yes
22:42:21 <dankna> I suspect that the problem is the use of the forward-slash for the relative path to HsNet.h in network.cabal in network-2.2.1.7
22:42:43 <MatrixFrog> http://hackage.haskell.org/package/redis just says "network"
22:42:43 <dankna> but the problem has obviously been fixed, whether that's it or not, because the platform already has a newer version of network
22:42:44 <mzero> now     main = do { ast <- loadAST "foo.lua";  print (transAST ast); }
22:42:55 <christo_m> right
22:42:56 <dankna> if dcoutts hadn't gone to bed he would know how to solve this :)
22:43:10 <dankna> specifically, he would know why it might be looking for the older version of network
22:43:13 <christo_m> print will take some object a, and make an IO out of it
22:43:21 <dankna> try:
22:43:23 <christo_m> the thing is, when i do loadAST
22:43:24 <MatrixFrog> should have come in here earlier. you guys are so much nicer than some other IRC channels
22:43:26 <dankna> cabal unpack redis
22:43:29 <christo_m> im going to assign to ast, an IO Block
22:43:30 <dankna> thanks!
22:43:32 <christo_m> thats my problem right there
22:43:35 <mzero> now
22:43:36 <dankna> I agree, this is a very friendly channel
22:43:38 <mzero> where?
22:43:46 <mzero>      ast <- loadAST   
22:43:50 <christo_m> yes
22:43:53 <christo_m> the return type of loadAST
22:43:57 <mzero> in that expression,    ast :: Blcok     not IO BLOCK
22:43:58 <mzero> !
22:44:03 <christo_m> loadAST :: SourceName -> IO Block
22:44:05 <dankna> I would then cd into the directory that it creates and poke through redis.cabal in it, to see what constraints it specifies
22:44:06 <mzero> yes
22:44:14 <christo_m> okay..
22:44:17 <mzero> the <- syntax  "unwraps" the value out of the monad
22:44:20 <mzero> just for a bit
22:44:23 <mzero> :-)
22:44:36 <christo_m> lol, i think thats what i was asking how to do up above then
22:44:39 <dankna> if some of the constraints looked wrong, for example depending on old versions of things, I might try changing them and then "cabal configure; cabal build" in that directory to see if it works
22:44:47 <mzero> notice that we didn't write      let ast = loadAST "foo"
22:44:47 <christo_m> i just asked it wrong
22:44:51 <mzero> that would be totally different
22:44:56 <christo_m> ya i get that, thats a binding
22:45:12 <mzero> well, the <- syntax is a binding of sorts too.....
22:45:14 <christo_m> okay so i can leave everything how it is
22:45:20 <christo_m> ya but its more imperative style
22:45:22 <christo_m> dealing with state
22:45:28 <christo_m> from what i understand, and i dont understand anything so
22:45:48 <mzero> well then... write ti this way       main = loadAST "foo.lua" >>= print . transAST
22:45:49 <dankna> MatrixFrog, try those things and see if you reach enlightenment :) let me know if you need something more explained
22:45:49 <MatrixFrog> Build-Depends: base < 5, containers, bytestring, utf8-string, network, mtl, old-time, MonadCatchIO-mtl
22:45:55 <mzero> there - no imperatives in sight!
22:46:03 <MatrixFrog> where "network" without any version information just means, the newest version. i would assume?
22:46:07 <christo_m> bah its all the same
22:46:10 <christo_m> too much syntactic sugar
22:46:14 <christo_m> one moment, fixing..
22:46:18 <dankna> well, it means something along those lines
22:46:29 <dankna> it might mean any convenient version
22:46:42 <dankna> try changing network to network >= 2.3 && < 3
22:46:45 <mzero> either way - don't think of it is imperative --- think of it "lifting" your transformation, a simple function of AST -> AST into the IO world for you
22:46:48 <dankna> and see what error it gives you
22:46:57 <christo_m> <SCV> Jobs finished! </SCV>
22:47:07 <mzero> the same way   map takes a function of a -> b and "lifts" it into the list world for you
22:47:37 <amalloy> christo_m: Job's finished, surely
22:49:06 <MatrixFrog> and then... cabal configure? while i'm inside the redis dir?
22:49:06 <christo_m> data Block = Block [Stmt]
22:49:10 <dankna> yes
22:49:11 <christo_m> thats what i have block defined as mzero 
22:49:23 <christo_m> should i be able to treat it as a list though?
22:49:28 <christo_m> i want to use the list operations
22:49:37 <MatrixFrog> it says that "network >=2.3 && <3" is missing
22:49:41 <mzero> no - because you have wrapped it in a constructor
22:49:45 <mzero> which is probably what you want
22:49:58 <christo_m> it is..
22:50:06 <christo_m> crap, im going to have to write my own functions to do this wont i.
22:50:08 <mzero> define a function     statements :: Block -> [Stmt]
22:50:09 <dankna> hmm
22:50:23 <dankna> "ghc-pkg list" and nopaste the output
22:50:35 <mzero> when you treat it as a list of statements, do you wnat the result "wrapped up again" as a Block?
22:51:06 <christo_m> mzero: well, the reason why i need a function like Block -> [Stmt] is so i can walk through the statements and do code generation
22:51:10 <christo_m> based on the cases
22:51:13 <mzero> if so, try this       asStmts :: ([Stmt] -> [Stmt]) -> Block -> Block
22:51:18 <MatrixFrog> ooo i get a warning about a cache being out of date. and it says ghc-pkg recache to fix
22:51:22 <dankna> ooh!
22:51:24 <MatrixFrog> so that sounds like a good plan
22:51:25 <christo_m> i dont think i need to put it back
22:51:27 <dankna> indeed it does
22:51:29 <christo_m> no point really
22:51:41 <mzero> ah, then just statemetns would be fine
22:51:55 <christo_m> so how do i "lift" the statement list from block :P
22:52:00 <mzero> btw, if you change your defintion      data Block = Block { statements: [Stmts] }
22:52:04 <mzero> you get that function for free!
22:52:12 <christo_m> :|
22:52:17 <mzero> or, if you stick with your defintion
22:52:28 <mzero> you'd write it      statements (Block stmts) = stmts
22:52:30 <MatrixFrog> a bunch of stuff is under c:/Users/myUserName and a bunch of other stuff is under c:/Program Files/Haskell Platform
22:52:34 <MatrixFrog> idk if that's bad
22:53:03 <mzero> MatrixFrog: that's normal
22:53:08 <MatrixFrog> ok cool
22:53:09 <dankna> that sounds reasonable, although I don't know cygwin particulars or whether the space in the path might mess it up
22:53:44 <mzero> christo_m:     BTW     asStmts f (Block s) = Block (f s)
22:54:09 <mzero> which then allows you to use any transformation on a [Stmt] as a transformation of Block
22:54:12 <christo_m> mzero: sorry whats that for
22:54:14 <christo_m> okay
22:54:28 <mzero> in fact, one might call that     liftBlock    rather than  asStmts
22:54:36 <christo_m> i dont get how statements (Block Stmt) = Stmt works?
22:54:48 <MatrixFrog> http://nopaste.info/29c6359ff8.html
22:54:49 <christo_m> data Block = Block [Stmt]
22:54:54 <mzero> and so.....      map someStmtTransform `liftBlock` someBlocks
22:54:57 <MatrixFrog> this is after doing the recache btw
22:55:18 <mzero> statements (Block statements)    is a pattern match
22:55:31 <mzero> er
22:55:38 <dankna> huh!  the platform doesn't have anything close to the latest version of network!
22:55:38 <mzero>    statements (Block s) = s
22:55:50 <dankna> but it does have it
22:55:53 <MatrixFrog> maybe it did and i somehow caused it to downgrade accidentally?
22:55:55 <dankna> so it's still odd that it couldn't be found
22:56:04 <dankna> I notice that you're using the platform version 2010.2
22:56:07 <dankna> I think there's a newer one
22:56:27 <MatrixFrog> oh ok
22:56:30 <dankna> http://hackage.haskell.org/platform//windows.html
22:56:42 <MatrixFrog> is there a way to upgrade the whole platform from the command line
22:56:50 <dankna> heh, I see that http://hackage.haskell.org/platform/ has grown some cherry blossoms.  cool.
22:56:52 <mzero> christo_m:    do you get how    twiceHead (x:y) = x:x:y     works?
22:56:54 <dankna> no, not at present
22:57:05 <dankna> because building the platform is still not entirely scripted
22:57:15 <MatrixFrog> i guess i downloaded the platform a while back but didn't really do anything with it at the time
22:57:21 <dankna> gotcha
22:57:26 <dankna> yeah, there's been activity :)
22:57:39 <christo_m> mzero: well, it looks like it prepends x
22:57:50 <dankna> it's a largish download, a few hundred M, but I think it's at least worth trying
22:57:57 <mzero> right - but do you see how the left hand side teases apart the list
22:58:39 <mzero> because    statements (Block s) = s     is just doing the exact same thing --- teasing apart your constructor for Block
22:58:51 <MatrixFrog> for sure. thanks
22:58:51 <mzero> and naming the thing it finds in there .... then returning just that part
22:58:52 <christo_m> i cant even implement that damn function.
22:58:53 <christo_m> god im nub
22:58:57 <dankna> np
22:59:12 <christo_m> ah nvm, got it
22:59:15 <christo_m> giving the wrong parameters
22:59:24 <MatrixFrog> so actually. another question i was thinking about today, while writing some javascript...
22:59:28 <dankna> sure
22:59:32 <christo_m> okay right i see whats going on mzero 
22:59:51 <MatrixFrog> i always hear "learning haskell/lisp/other functional languages makes you a better programmer, even if you only program in C/Java/Python"
23:00:10 <MatrixFrog> but... how exactly?
23:00:11 <dankna> absolutely - it teaches you that functions are something you can treat as first-class objects
23:00:18 <dankna> which involves new patterns of abstraction
23:00:32 <MatrixFrog> it seems like kind of a trade-off because you might try to do something in a haskell-ish way and it will not really work
23:00:33 <philed> MatrixFrog: I think that's the runner-up prize :P
23:00:50 <mzero> MatrixFrog: it *does* really! because coding in Haskell makes you constantly focus on the how the meaning of your program is going together
23:01:00 <dankna> many design patterns have simpler, more straightforward implementations in functional languages
23:01:07 <mzero> whereas you get bogged down in details in C/Java/etc...
23:01:08 <dankna> such that we don't even think of them as patterns
23:01:16 <dankna> the iterator pattern comes to mind
23:01:24 <dankna> or the visitor pattern
23:02:00 <dankna> because making the code generic to what's being done at each node is almost trivial, rather than something requiring special effort
23:02:20 <mzero> MatrixFrog: what you find is that when something doesn't work the Haskell'ish way, you build yourself tools to help it do so -- which multiply your power in those languages once you've done so
23:02:21 <dankna> in many cases you can achieve the same thing with C (or sometimes even with Java ;) ), but you wouldn't think to do so
23:02:22 <monochrom> @quote monochrom perspective
23:02:22 <lambdabot> monochrom says: most people tend to deny the usefulness of useful alternative perspectives --- their entrenched vested interests demand it. as they grow older they also have more influence and power
23:02:22 <lambdabot> over "the state of the art" to preserve their self-fulfilling prophecy that "the alternative is useless" --- by controlling what practice looks like, they can control what looks useless.
23:02:49 <MatrixFrog> i just, i was trying to do something today and i was kind of thinking of it in a haskelly way
23:02:58 <MatrixFrog> and use javascript's newish haskell-inspired array functions
23:03:05 <MatrixFrog> filter, some, every, forEach
23:03:21 <shachaf> That's Haskell-inspired?
23:03:23 <MatrixFrog> but it took me a little while to kind of "translate it"
23:03:24 <dankna> ah, yes, those are nice
23:03:32 <dankna> well, they're functional-programming-inspired
23:03:33 <christo_m> mzero: do{test <- loadAST "test/fac.lua"; return $ statements test} :: IO [Stmt]
23:03:34 <MatrixFrog> well maybe not haskell per se but functional
23:03:34 <MatrixFrog> yeah
23:03:37 <dankna> except for foreach which is perl-inspired :)
23:03:44 <christo_m> thats what we expect right
23:03:54 <christo_m> still dont know why the IO is there, i guess because we didnt lift
23:03:59 <mzero> yup
23:04:01 <BMeph> Does anyone have enough experience with Mogensen's (yes, THAT Mogensen) Compiler book (Basics of Compiler Design) to say yea or nay to it? 
23:04:08 <MatrixFrog> anyway i want to get into haskell more and then i guess i'll see the benefits more and more
23:04:10 <dankna> BMeph: I do not
23:04:15 <mzero> because   return took that pure result and put it back in IO
23:04:15 <dankna> MatrixFrog, I approve of this plan :)
23:04:22 <MatrixFrog> but i don't want to just use it for like, project euler
23:04:30 <MatrixFrog> because i feel like that's not really what it's all about
23:04:33 <mzero> which you had to do - 
23:04:33 <dankna> I agree
23:04:36 <MatrixFrog> so that's why i was looking at tweetov
23:04:38 <mzero> because once in IO, always in IO
23:05:01 <mzero> so what you want, is, if you are going to insist that loadAST take a file name, and not a string
23:05:11 <dankna> when I decide a language has important ideas in it, I try to use it for everything for a brief period of time
23:05:22 <MatrixFrog> ok, installation done!
23:05:23 <dankna> that way I discover what it's good for and what it's not, possibly better even than the designers :)
23:05:24 <mzero> is to call loadAST somewhere up at the outermost layer of your program you can
23:05:33 <MatrixFrog> now under "haskell platform" i have both the 2010 and 2011 versions
23:05:37 <Bfig_> MatrixFrog, this haskell is great, let me show you the kind of elegant things there are
23:05:54 <mzero> then call the real guts of your program  with the AST value.... a pure program... that transforms that AST into
23:05:56 <dankna> okay.  that's probably safe.  I believe only the newer one gets used.
23:05:57 <Bfig_> monomio = ((optional (token '-') `build` (\ a -> if null a then 1 else -1 ) ) >*> ((unsignedfloater `build` (\ a -> [a]) ) `alt` ((optional (unsignedfloater) >*> token 'x' >*> optional (token '^') >*> optional natural) `build` ( \(optcoef,(_,(_,optExp))) ->  (replicate (if null optExp then 1 else (head optExp)) 0) ++ [(if null optcoef then 1 else head optcoef)] )) )) `build` (\ (a, b) -> Poli $ Poly (map (a*) b))
23:05:59 <MatrixFrog> Bfig i have some idea of it. i've watched some video lectures and stuff
23:06:00 <Bfig_> single line of my code
23:06:06 <mzero> I dunno... a String, say to be written out to a file
23:06:07 <dankna> you can also probably just delete the older one if its presence offends you.
23:06:14 <mzero> then back at that outer most layer, write it out
23:06:19 <MatrixFrog> no i only want to delete it if it's likely to cause problems
23:06:25 <Bfig_> i mean, i don't have the slightest clue how that solves my problem now that i've written it... and i no longer need to care
23:06:32 <christo_m> mzero: well its pure in the parser, thats all i care about..
23:06:33 <dankna> I don't think it's likely to cause any trouble
23:06:38 <christo_m> well not exactly, i care that its pure when i traverse it too
23:06:44 <christo_m> i have to do symbol table type stuff right now
23:06:46 <mzero> so:      xformFile :: FilePath -> FilePath
23:07:01 <BMeph> dankna: Scala is a great example to your "tools to make other language more 'functional'". :)
23:07:23 <BMeph> ...argument. ;þ
23:07:50 <dankna> BMeph: this is where I admit that I haven't played with Scala :)
23:08:34 <mzero> xformFile inFile outFile = do { ast <- loadAst inFile; writeFile outFile $ xformAST ast; }
23:09:02 <mzero> or maybe     xformFile inFile outFile = loadAst inFile >>= writeFile outFile . xformAST
23:09:10 <dankna> > "Hello, world!" >> "aa"
23:09:11 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaa"
23:09:18 <mzero> (and now perhaps that syntax is more clear?)
23:09:29 <dankna> oh!  now I get it
23:09:31 <MatrixFrog> mmmmk. so now i have the new platform. i go to the dir where tweetov is and say "cabal configure"
23:09:35 <mzero> and xformAST can be pure     xformAST :: AST -> STring
23:09:48 <MatrixFrog> it shows a bunch of missing dependencies. so now i just go "cabal install --only-dependencies"?
23:09:53 <dankna> MatrixFrog, yes.
23:10:04 <mzero> christo_m: there is no reason symbol table stuff can't be done purely
23:10:15 <christo_m> mzero: well ive decided on a lists
23:10:17 <christo_m> but one more thing
23:10:23 <christo_m>     = do{ ast <- loadAST "test/fac.lua"
23:10:24 <christo_m>         ; stmts <- statements ast
23:10:24 <christo_m>         ; print (take 5 stmts)
23:10:24 <christo_m>         }
23:10:28 <christo_m> trying to do something like this in main
23:10:40 <christo_m> and the IO crap is bitching again
23:10:50 <mzero> ah - the middle statmeent isn't a "bind" in IO 
23:10:52 <BMeph> > "Mushroom" >> "Badger! "
23:10:53 <lambdabot>   "Badger! Badger! Badger! Badger! Badger! Badger! Badger! Badger! "
23:10:56 <christo_m> its expecting a [Stmt] but getting IO[Stmt]
23:10:56 <mzero> so    let stmts = statements ast
23:10:57 <dankna> lol
23:11:05 <christo_m> sorry IO Stmt
23:11:19 * BMeph <3 him some Haskell, yes sirree!
23:11:43 <mzero> you need to use let bindings in do blocks for pure computations
23:11:53 <mzero> only use <- for unwrapping IO (or other monad) compuations
23:12:04 <MatrixFrog> how do i get lambdabot to tell me about itself
23:12:13 <christo_m> Doh, that doesnt do anything anyway because the lists are nested
23:12:20 <christo_m> mzero: okay i see what you did there
23:12:21 <MatrixFrog> or does it not do anything besides evaluate expressions?
23:12:22 <dankna> > "Lambdabot is a fun bot."
23:12:23 <lambdabot>   "Lambdabot is a fun bot."
23:12:25 <dankna> Like that.
23:12:29 <dankna> you have to provide the text though.
23:12:31 <MatrixFrog> but of course
23:12:43 <mzero> but consider these common alternatives    do { stmts <- statements `fmap` loadAST "test/fac.lua"; print (take 5 stmts); }
23:12:44 <dankna> I think you can privately message it @help or @list or something
23:13:07 <christo_m> mzero: i know it can be written more succinct,
23:13:11 <mzero> or do { ast <- loadAST "test/fac.lua"; print $ take 5 $ statements ast }
23:13:15 <christo_m> im just really trying to get something persentable
23:13:33 <mzero> well, I don't suggest those because they are shorter
23:14:08 <mzero> I suggest them because those forms better reflect the relationship between the pure and non-pure code
23:14:29 <mzero> and getting used to them will make this stuff come more naturally
23:15:00 <MatrixFrog> :( it still didn't work
23:15:03 <MatrixFrog> it got pretty far though
23:15:33 <christo_m> mzero: right now im trying to think of the best way to traverse this bastard
23:15:34 <dankna> well, rejoice that there is progress, and nopaste the tail of its attempt :)
23:15:35 <christo_m> :P
23:15:41 * christo_m looks up fmap
23:15:51 <mzero> well, now youv'e got a list of Stmt to work with
23:15:56 <mzero> what do you want to do with it?
23:16:43 <christo_m> dude, you're like on some deus ex machina stuff here, you and BMeph have helped me immensely
23:16:49 <MatrixFrog> yup. working on it
23:17:01 <christo_m> basically, i want to have an environment, so i can understand lexical scope , or where i currently am
23:17:04 <christo_m> and what bindings are available to me
23:17:10 <MatrixFrog> Redis.hs:246:21: Not in scope: data constructor `S.SockAddrUnix`
23:17:21 <christo_m> so the way i was going to do that is with an associative list of [(identifier,value)]
23:17:24 <MatrixFrog> nopaste.info is going super slow but that's the actual error i think
23:17:42 <christo_m> and keep push bindings on when i enter a scope, and pop bindings off when i leave one
23:17:53 <christo_m> for now, im willing to bet a Block is a scope.. at least good enough for now
23:18:04 <mzero> christo_m: I don't think so
23:18:08 <christo_m> theres also things like the "local" keyword to worry about,
23:18:13 <MatrixFrog> http://nopaste.info/ed0524c17d.html
23:18:25 <mzero> so, let's say you've got a data type   Env   that we'll leave unspecified for now
23:18:37 <dankna> ah!
23:18:41 <christo_m> right.
23:18:49 <christo_m> well its probably for sure a Map
23:18:50 <mzero> you're going to start with a an Env, and traverse the list, and each stmt is going to modify that Env and pass the modified one to the next
23:18:56 <christo_m> right
23:19:02 <dankna> I diagnose this as: redis, one of the packages on which you depend (I don't know anything else about it), uses unix-domain sockets, which don't exist on Windows, or at least aren't supported by the network package.
23:19:04 <christo_m> im going to go from Stmt -> Env -> Env
23:19:05 <christo_m> i think
23:19:16 <MatrixFrog> so this whole thing just won't work on windows ever? :(
23:19:17 <mzero> so, let's call that function     compile :: Env -> Stmt -> Env
23:19:23 <MatrixFrog> that is actually not THAT surprising
23:19:32 <mzero>    what you want is.....   foldl'   
23:19:32 <christo_m> mzero: okay sure, swap the parameters on me, asshole :P carry on
23:19:38 <christo_m> right, i know that function
23:19:42 <dankna> it might be possible to disable that with a flag to redis, you'd have to "cabal unpack redis" and inspect redis.cabal for the presence of any flags
23:20:00 <mzero> bingo:      foldl' compile initialEnv stmts
23:20:03 <mzero> ! 
23:20:04 <mzero> done
23:20:16 <dankna> if not, it might be possible to implement such a flag and submit a patch to the author of redis, but that's probably too hard for a total beginner at the language :)
23:20:20 <christo_m> wait, why the single quote there?
23:20:29 <MatrixFrog> mmmmk
23:20:29 <christo_m> is that different than the regular foldl?
23:20:30 <mzero> now - true, compile will "push" or "add" variables to Env 
23:20:35 <mzero> but you'll never pop them offf!
23:20:44 <mzero> the ' means strict
23:20:46 <christo_m> mzero: why not, shouldnt i be popping them when i leave a scope?
23:20:47 <mzero> int he accumulator
23:20:48 <dankna> MatrixFrog: if there turns out not to be such a flag, I just regret that it took so long to figure this out!
23:20:50 <roelvandijk> Good morning everyone
23:20:57 <dankna> good midnight, roelvandijk 
23:21:03 <mzero> which is almost always what you want with foldl    and usually never with foldr
23:21:41 <christo_m> wow, that solution is so elegant
23:21:42 <christo_m> its like two lines
23:21:53 <mzero> well - because what you'll do is when you enter a block... the block is a single statement, right?  so you'll pass the Env you've got into compiling the block.... but never use the resulting Env of that block to continue on
23:22:01 <mzero> you'll just used the Env you started with!
23:22:04 <christo_m> mzero: no, the block is a list of statements.
23:22:22 <christo_m> or may, in itself, contain another block
23:22:24 <christo_m> ie recursive type
23:22:27 <MatrixFrog> don't see any such flags.... hm
23:23:01 <christo_m> mzero: i think what you're saying is because types are immutable in haskell, whats going to happen is we'll keep creating the Env.. not modifying the same one
23:23:06 <mzero> right - well I bet the only time you have to add vars, and then "pop them off" is when dealing with a sub-block, no?
23:23:06 <christo_m> right? or am i way off here
23:23:12 <dankna> a shame.  then yes, I don't think it'll work on Windows.  if your goal is just to try something fun written in Haskell, might I suggest poking around on hackage a bit, maybe in the "games" category? :)
23:23:17 <mzero> you're dead on
23:23:22 <christo_m> mzero: you're right , yes.
23:23:33 <christo_m> i think i just had a mindgasm
23:23:53 <amalloy> you guys are agreeing with each other too enthusiastically. get a room
23:23:54 <Bfig_> what's the problem here? http://pastebin.com/x7X15am7 unexpected '<-' at 6
23:23:58 <christo_m> jeez, wait to LLVM , this is going to be a blast
23:24:03 <dankna> they have a room - this is it
23:24:14 <MatrixFrog> dankna: i somehow picked up the idea that hackage was mostly just libraries. things that i could DO something interesting with, but were not interesting in and of themselves
23:24:15 <MatrixFrog> will do
23:24:23 <dankna> commline: missing "do" on line 5
23:24:39 <dankna> similarly on line 12 btw
23:24:52 <Bfig_> dankna, thanks
23:24:57 <dankna> MatrixFrog: it contains programs too :)
23:25:28 <MatrixFrog> nice
23:25:53 <mzero> so let's assume, for the momemnt, that Env has two parts --- a symbol table, and perhaps... say.... the compiled insttructions
23:25:54 <mzero>     compile (Env syms insts) (Do blk) = let (Env _ i) = foldl' compile (Env syms []) (statements blk)  in  Env syms (insts ++ i)
23:27:54 <mzero> christo_m: so what does that mean?  "To compile, starting with some syms and some insts, a Do block we.... fold compile over the statements of the block starting with the syms and no instructions... that will result in an Env whose final syms we ignore (!) and some new instuctions i.....   the resulting Env is then  the same syms we started with, but the concatentation of the instructions we started with and the new one"
23:28:04 * mzero breathes
23:28:21 <christo_m> mzero: you better not be my prof helping me with this or something
23:28:28 <christo_m> do i need to whois you?
23:28:44 <mzero> my identity is pretty easy to find out!
23:28:58 <amalloy> :t mzero
23:28:59 <mzero> and no, I'm not your prof
23:28:59 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
23:29:05 <christo_m> ill definitely have to write something for all these cases
23:29:08 <dankna> I believe at one time there were profs who said something to the effect that it's okay to get help on IRC, ... knowing that the only place to do so was in here, where they themselves liked to hang out :)
23:29:28 <christo_m> because, and ive never used the haskell bindings, but thats the only way ill be doing the codegen
23:29:47 <mzero> did your prof. really assign compiling Lua to LLVM as an assignment?
23:29:47 <mzero> or is this your own choosen insanity?  :-)
23:29:51 <christo_m> mzero: im going to have to reread that line a few times
23:30:08 <christo_m> mzero: he gave us a few languages, modelica, miniml, tiger..i guess its my own insanity
23:30:19 <christo_m> http://www.cas.mcmaster.ca/~carette/CS4TB3/2011/assignments.html
23:30:19 <MatrixFrog> ooookay so now i'm trying to configure this: http://hackage.haskell.org/package/minesweeper
23:30:41 <christo_m> see i had just a parser for a while.. and now the past couple of days ive been refining it and trying to do more, and the final copy is due at 9 am
23:30:42 <dankna> I know that one is supposed to work because people have talked about it in my presence
23:30:47 <MatrixFrog> and cabal says "please install `gtk2hs-buildtools` first and check thatthe install directory is in your PATH
23:30:50 <dankna> also because it was last updated four weeks ago
23:30:52 <christo_m> the thing is, no one in the class, not even the graduate students have a working compiler
23:31:06 <christo_m> mzero: i think i may be closest, but thats thanks to people like you
23:31:17 <dankna> christo_m: yay for grading on the curve
23:31:26 <christo_m> ya, hoping for that.
23:31:34 <dankna> but by all means try to get it working
23:31:35 <christo_m> but then again, i want a working compiler for my portfolio, like , ive put in so much work already
23:31:38 <dankna> of course!
23:31:52 <dankna> and it's hard to build a portfolio when everything you write ends up being owned by someone else, too
23:32:03 <christo_m> hahah
23:32:05 <christo_m> ya i know
23:32:08 <dankna> so you should absolutely take advantage of this opportunity for it
23:32:19 <christo_m> ill probably redo it, or create my own small language instead
23:32:27 <christo_m> because , this is my first time using haskell, parsec, and LLVM 
23:32:30 <christo_m> so i expect to eff up a lot
23:32:31 <dankna> MatrixFrog: so what happened when you tried that?  do you understand how to set PATH and all that?
23:32:55 <christo_m> mzero: brb coffee, im going to reread what you typed though, definitely informative, thank you again
23:32:56 <MatrixFrog> yes, but i'm not sure which HOME it wants
23:33:06 <mzero> sure
23:33:11 <MatrixFrog> cygwin thinks of c:/cygwin/home/username as "home"
23:33:14 <dankna> try both :) but I suspect it wants the Windows one, so try that first
23:33:18 <MatrixFrog> but windows thinks of c:/users/...
23:33:31 <mzero> well - going from a working parser to a compiler to LLVM by 9am might be bit ambitious
23:33:34 <MatrixFrog> actually it looks like the windows one is already there
23:33:57 <MatrixFrog> /cygdrive/c/Users/<username>/AppData/Roaming/cabal/bin is in the path
23:34:08 <mzero> but getting a compiler framework that can at least pass over the AST, and perhaps write a "walk through" the code as strings to be written out to a file is a good goal
23:34:09 <MatrixFrog> but then when i ls that directory, the gtk thing is not there
23:35:04 <dankna> did you do "cabal install gtk2hs-buildtools"?
23:35:21 <dankna> it looks to me like the message is telling you that for some reason it doesn't know how to do that automatically
23:35:25 <dankna> and wants you to do it by hand
23:35:35 <MatrixFrog> oh ok
23:35:46 <MatrixFrog> yeah i don't know. ok i'll do that
23:35:48 <RayNbow`TU> hmm, anyone ever tried to use hmatrix under Windows? I followed the instructions at http://patch-tag.com/r/aruiz/hmatrix/snapshot/current/content/pretty/INSTALL but ghci cannot find lapack.dll
23:36:24 <christo_m> mzero: i just literally put instant coffee and milk together
23:36:28 <christo_m> ya i know what you mean
23:36:42 <christo_m> emitting LLVM looks weird.. i mean its basically a form of assembler from what i understand
23:36:49 <christo_m> its just something that works on a lot of architectures etc
23:36:51 <mzero> wow - I have to say, the assignment looks very ambitious 
23:36:58 <dankna> christo_m, doesn't that result in a cold drink instead of a hot one?
23:36:59 <mzero> compiling down to LLVM is no small feat
23:37:04 <mzero> for any of those languages
23:37:14 <christo_m> dankna: yes, but the caffeine is whats important, not the temperature of the beverage
23:37:24 <dankna> fair enough!
23:37:26 <christo_m> mzero: well, its a class of about 10 people, half are graduates
23:37:36 <christo_m> and ive talked to several people
23:37:37 <amalloy> trying to reimplement the map function; can someone tell me what's wrong with "let map' :: (a -> b) -> [a] -> [b]; map' f [] = []; map' f [x : xs] = (f x) : (map' f xs)"?
23:37:52 <mzero> I think the given 8 weeks is really tight (assuming that you're all taking three other course as well!)
23:37:53 <christo_m> a lot of us who are undergrads were also doing a capstone, or undergraduate thesis
23:37:56 <jaspervdj> amalloy: (x : xs) instead of [x : xs]
23:38:06 <christo_m> so i spent a lot of time implementing a lattice based cryptosystem in C, not worrying about this.
23:38:13 <christo_m> taking 5.
23:38:15 <jaspervdj> amalloy: otherwise you're matching on a list with one element: `x : xs`
23:38:20 <christo_m> in total
23:38:40 <mzero> amalloy: [x:xs]  should be (x:xs)
23:38:46 <mzero> common mistake:    
23:38:53 <napping> amalloy: mind the syntax
23:39:22 <napping> [] {} and () are each quite different
23:39:30 <christo_m> mzero: the thing is, the code generation is two parts here.. so clearly theres a lot of emphasis on it.
23:39:33 <mzero> [ x : xs ]  ::  [ [ a ] ]
23:39:43 <MatrixFrog> > [x:xs]
23:39:44 <lambdabot>   Not in scope: `xs'
23:39:48 <Bfig_> i'm getting bad layout in this line: 	let parsedComs = let parserOutput = (reverse . entrada ) input in if null parserOutput then [Err] else if (null . snd . head) parserOutput then ( fst . head ) parserOutput 
23:39:59 <MatrixFrog> > [1:[]]
23:40:00 <lambdabot>   [[1]]
23:40:03 <amalloy> ah, mzero, i think that fits into my head more easily
23:40:12 <napping> Bfig_: no else on the second if
23:40:15 <MatrixFrog> > [1:[2]:[3]]
23:40:15 <lambdabot>   No instance for (GHC.Num.Num [t])
23:40:16 <lambdabot>    arising from a use of `e_1123' at <int...
23:40:23 <MatrixFrog> ok now i'm just being silly
23:40:26 <mzero> Bfig_: if you are having a layout issue - please put the code in hpaste.org for us to see in context
23:40:41 <Bfig_> napping, sharp vision! thanks
23:40:46 <amalloy> napping: yeah, i'm still at the beginning of LYAH and it hasn't gotten to that syntax yet. i was trying to glue together the things i remembered reading elsewhere and apparently misremembered the syntax
23:40:55 <napping> I think your lines are a bit too long
23:41:06 <napping> I thought I wrote long lines
23:41:12 <Bfig_> napping, a bit too shitty for my taste too
23:41:24 <mzero> amalloy: but good for you for trying to implement map
23:41:28 <Bfig_> but i don't like making more functions just for the sake of it
23:41:35 <mzero> I have it pretty early on in my Haskell tutorial as well --- 
23:41:49 <napping> amalloy: you mentioned you used a lot of lisp
23:41:55 <amalloy> napping: yep
23:42:06 <Bfig_> the problem is that with the parsers i have to enforce types everywhere and the code just grows without adding much value...
23:42:12 <mzero> presented at the right moment, it has a big impact on people to see that they can actually write something as "insanely powerful" as map    
23:42:33 <Bfig_> then i have to modify a shitton of places whenever i need to add some shitty functionality...
23:42:37 <christo_m> mzero: so looking at what you wrote, im going to have to make modifications to env as i read blocks
23:42:40 <christo_m> right?
23:42:40 <napping> amalloy: ones that treat [] and () equivalently?
23:42:47 <amalloy> mzero: you should try convincing unenlightened thugs that map is "insanely powerful"
23:42:55 <christo_m> this means compile wont do it alone, like you said i need something to add to the env.. well that exists for Data.Map
23:43:05 <napping> amalloy: well, if they are willing to use STL iterators...
23:43:17 <amalloy> napping: i dabbled briefly in some scheme that i think treated them the same, but mostly clojure and CL (which don't)
23:43:24 <christo_m> dammit, i keep typing in hoogle.com and going to some hyprocisy site
23:43:31 <blackdog> mzero: do you want to elaboreate a bit? i've got a 2-hour intro to haskell to teach to a bunch of seasoned ruby web hackers, and i'm not exactly sure how to approach it
23:43:33 <amalloy> napping: worse: foreach loops
23:43:45 <mzero> blackdog --- use Barley!
23:44:01 <Bfig_> well... time for my first test drive.... will it Hold Up? only god knows...
23:44:07 <blackdog> ideally i want to do it as a lab - set of exercises & minimal explicit lecturing if possible
23:44:09 <Bfig_> how do i run a program in Hugs
23:44:26 <napping> as a standalone program?
23:44:35 <mzero> blackdog: https://github.com/mtnviewmark/barley
23:44:37 <Bfig_> i need to run the IO monad, however that works
23:44:38 <blackdog> mzero: actually, that looks interesting. 
23:44:43 <Bfig_> the main method
23:44:53 <Bfig_> do i just call main?
23:44:55 <mzero> it is a Haskell IDE in a web page!
23:44:58 <napping> hmm, actually it's been a long time since I used hugs
23:45:00 <mzero> with a tutorial for newbies
23:45:00 <blackdog> i was playing with snap and yesod, but snap's a bit bare and yesod has a fair bit of type magic
23:45:02 <mzero> for web programmers
23:45:07 <Cale> Bfig_: yes
23:45:09 <napping> runghc prog.hs will run main
23:45:11 <mzero> (or atleast it is the start of one)
23:45:18 <Bfig_> Cale, ty
23:45:20 <Cale> Bfig_: just type main, and it should run
23:45:24 <mzero> I've used it teach ~50 newbies in Feb.   
23:45:28 <mzero> went great
23:45:37 <christo_m> import qualified Data.Map as M
23:45:38 <christo_m> if i do that
23:45:47 <christo_m> how do i show it in type signatures
23:45:49 <mzero> Ch. 2, step 6 (I think) is where we get them to write map
23:45:54 <christo_m> like somefunc :: M -> M?
23:46:05 <blackdog> mzero: ok, that sounds good. gotta be better than yet another fibonacci implementation
23:46:43 <mzero> yeah - tibbe and I wanted to have a tutorial that would get people putting real HTML on web pages ASAP -- cause that is what many folks understand how to do these days
23:46:50 <amalloy> mzero: implementing map isn't really that hard. one thing that nudged me to try haskell again is that my clojure definition of unfold is a little unwieldy
23:46:52 <mzero> fib on the command line is kinda lame, eh?
23:46:58 <napping> christo_m: that renames the module - :: M.Map -> M.Map
23:47:37 <napping> I often add an import Data.Map(Map) to get just Map for signatures
23:47:55 <napping> pity there's no renaming of individual identifiers, or even a way to combine this with qualified imports
23:48:09 <BMeph> amalloy: What's wrong: [x:xs] is a singleton list, with a list as its one element.
23:48:20 <Bfig_> i can't believe it WORKS
23:48:25 <Bfig_> :D
23:48:27 <mzero> christo_m: consder this     compile (Env syms insts) (Var name) = Env ((name, ""):syms) insts
23:48:35 <mzero> so, it needn't be quite so complex
23:48:43 <christo_m> traverse :: M.Map -> Stmt -> M.Map
23:48:43 <Bfig_> well... for the bigger part...
23:48:48 <christo_m> this is bad.
23:48:54 <mzero> of course, if you're going to compile this down to LLVM -- you'll need more info with that sym
23:48:58 * BMeph scrolls...and scrolls. Then, BMeph scrolls some more. <Sigh> Never mind. :\
23:49:18 <christo_m> mzero: i have no syms.. nor insts
23:49:23 <mzero> your Env is going to have to be more than just a Map
23:49:39 <amalloy> the guy who wrote/is-writing LYAH is in here, or was earlier, am i right?
23:49:44 <mzero> think of all the information you need to compile (is this a one pass compiler?)
23:49:58 <christo_m> mzero: im probably going to have to do more than one pass.
23:50:07 <christo_m> unless i do dynamic scoping, and emit code on the fly
23:50:17 <christo_m> or something.
23:50:44 <mzero> data Env = Env { syms: [(Sym, Allocation)], insts: [String], funcs: [(String, Signature)] }
23:50:44 <christo_m> i dont know what syms are though
23:50:47 <christo_m> symbols of what kind?
23:50:47 <mzero> etc....
23:50:59 <napping> amalloy: seen  ana f = In . fmap (ana f) . f?
23:51:08 <mzero> then probably what you want is an annotated AST... 
23:51:25 <christo_m> mzero: do you mean attribute grammars?
23:51:34 <mzero> possibly
23:51:56 <mzero> the question is --- ignoring the code for the moment --- just HOW are you going to turn this bit of Lua into LLVM?
23:52:05 <MatrixFrog> *sigh* i must be so close here
23:52:12 <christo_m> mzero: no idea, havent written that yet.
23:52:18 <MatrixFrog> now i'm trying to do Raincat. and it relies on SDL
23:52:22 <christo_m> to annotate an AST though. i have only two options as far as i can think of
23:52:33 <christo_m> greedy walk the AST, and infer as i go.. that would probably be attribute grammars
23:52:33 <mzero> well... you've been in a compiler course for three months... I'm hopin' you've got some idea!  :-)
23:52:38 <phrygiangates> quit
23:52:47 <christo_m> or, gather info as equations/relations and solve
23:53:02 <christo_m> mzero: he didnt teach us anything about LLVM
23:53:04 <MatrixFrog> so while it's installing, it says "SDL not found! Get SDL from www.libsdl.org"
23:53:10 <christo_m> it was a conceptual course
23:53:18 <dankna> MatrixFrog: :(
23:53:19 <christo_m> i understand the concepts, just not how to actually do them
23:53:20 <MatrixFrog> so i went there and downloaded the dll, put it on my $PATH, tried again
23:53:23 <mzero> what?!?!?!
23:53:32 <mzero> did he teach you anything about register allocation?
23:53:34 <christo_m> mzero: he basically said RTFM for anything
23:53:36 <mzero> about stack frame layout?
23:53:44 <christo_m> register allocation yes
23:53:47 <mzero> about calling convention design?
23:53:53 <christo_m> and stack frames to some extent because we talked about JIT
23:53:56 <dankna> I'm not sure what the deal is with DLLs on Windows, whether they're currently working or not.  It's not my own platform, you know?
23:54:03 <christo_m> a big focus was on the front end, and as far as the backend, code optimization
23:54:05 <MatrixFrog> yeah
23:54:08 <mzero> about runtime support 
23:54:11 <christo_m> like arithmetic simplification, dead code elemination
23:54:14 <dankna> did you get minesweeper running, btw?
23:54:17 <christo_m> constant folding
23:54:17 <christo_m> etc
23:54:24 <MatrixFrog> to the google!
23:54:29 <christo_m> im so far from optimizing its not a joke
23:54:31 <dankna> indeed!
23:54:37 <MatrixFrog> no i kinda gave up on that. raincat sounds cooler i guess
23:54:40 <dankna> gotcha :)
23:54:45 <mzero> and the assignment was to compile to LLVM?
23:54:53 <christo_m> mzero: right.. there was llvm on the final
23:54:56 <christo_m> but it wasnt hard to decipher
23:55:01 <dankna> hm
23:55:10 <dankna> when I attempt to do "cabal install raincat"
23:55:13 <dankna> it starts compiling GLUT
23:55:17 <mzero> no, but compiling to a machine model like LLVM is a fair bit of work
23:55:29 <dankna> which is a lousy alternative to SDL, although actually GLUT was written first
23:55:29 <mzero> sure, one person 8 weeks solid for a language like Lua --- okay
23:55:31 <mzero> maybe
23:55:38 <dankna> so I'm surprised that it's using SDL for you
23:55:44 <dankna> wait look at that
23:55:47 <dankna> it's compiling SDL /also/
23:55:47 <mzero> this is a first compiler course?
23:55:51 <christo_m> mzero: yes
23:56:01 <blackdog> mzero: barley looks ideal. thanks.
23:56:08 <christo_m> http://www.cas.mcmaster.ca/~carette/
23:56:11 <christo_m> hes a good prof, dont get me wrong
23:56:15 <mzero> blackdog - thanks
23:56:17 <christo_m> but like damn, the stuff in the course, and the assignments
23:56:20 <mzero> it is a work in progress
23:56:21 <christo_m> complete different contexts
23:56:22 <MatrixFrog> found http://jpmoresmau.blogspot.com/2010/05/haskell-sdl-on-windows-check-hacking.html but i think it's a different problem
23:56:23 <christo_m> as far as im concerned
23:56:29 <mzero> please let me know how you get on with it
23:56:35 <mzero> we need experience reports to help make it better!
23:56:43 <mzero> or, even to help make it at all!
23:56:52 <dankna> yeah separate issue
23:57:10 <MatrixFrog> dankna: i wonder if it doesn't actually need one or the other of them, and they just left the dependency there in the .cabal file by accident
23:57:20 <dankna> MatrixFrog: good call.
23:57:37 <napping> mzero: LLVM handles register allocation, calling conventions, and a lot of optimization
23:58:10 <ickabob> Hey everybody; I'm importing a custom module in my haskell Main.hs... the module is most definitley in the ghc search path but "ghc Main.hs" says cannot find the interface.  Is there any other reason why this might be happening?
23:58:31 <mzero> sure- but still, the model of LLVM and the model fo Lua are pretty far apart
23:58:31 <amalloy> it looks to me like the | "guards" in function definitions are closely related to the | expression in list comprehensions. are they actually related at a syntactical level, or is the | character just reused for two similar things?
23:58:32 <christo_m> napping: yea from what i understand it does a lot of things like taht for free
23:58:48 <dankna> I'm trying to get raincat working here, since you made me curious about it, but I'm on a Mac
23:58:53 <mzero> I'd expect a first compiling course to have assignments that build a compiler to a more abstract machine
23:58:54 <dankna> so my experience won't help you much
23:59:12 <dankna> the first thing I notice is that it is failing to find my installed copy of SDL_mixer because I installed it as a .framework
23:59:14 <christo_m> data Env = Env { syms: [(Sym, Allocation)], insts: [String], funcs: [(String, Signature)] }
23:59:22 <christo_m> trying to understand whats happening here
23:59:40 <christo_m> so you declared your own type Env obviously, and thats the constructor there?
