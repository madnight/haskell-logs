00:34:07 <hvr_> Is using "ErrorT Identity" over Either any good?
00:34:23 <hvr_> s/over/instead-of/
01:26:46 <roconnor> hvr_: for the most part it doesn't matter.
01:28:08 <ezyang> I kind of suspect that laziness is a very big reason why Haskellers consider the function abstraction so cheap. 
01:41:05 <zygoloid> ezyang: i think it's more aggressive inlining than laziness. i'd still consider the function abstraction to be cheap in a hypothetical strict haskell
01:42:34 <ezyang> Or maybe it's just because we're so confused about the performance of our programs that we don't bother :-) 
01:42:44 <ezyang> But I'm curious what you precisely mean by "aggressive inlining" 
01:42:56 <ezyang> surely you don't mean the same thing as {-# INLINE f #-} 
01:45:13 <shachaf> Haskellers care about the performance of their programs?
01:47:04 <gienah> shachaf: an example of haskellers caring about performance: http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
01:47:32 <roconnor> function abstraction doesn't actually change the semantics of your program due to laziness.  I think that is what makes it so cheap
01:48:28 <shachaf> gienah: That particular example is mostly due to the RTS implementors, to be fair. :-)
01:48:42 <shachaf> Anyway, the shootout is definitely not typical Haskell code.
01:49:32 <gienah> shachaf: its really impressive the performance of the RTS on thread context switching
01:49:36 <ezyang> roconnor: Good way of putting it. 
01:50:34 <shachaf> gienah: I have the feeling that benchmark is kind of cheating, actually.
01:50:36 <roconnor> though maybe without lazy data structures it wouldn't?
01:50:46 <shachaf> "GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however)."
01:51:01 <shachaf> It's supposed to be more pre-emptive than "whenever it allocates some memory", isn't it?
01:51:28 <Eduard_Munteanu> The Debian shootout? Yeah it might be cheating in some sense?
01:51:52 <shachaf> "Programs may use pre-emptive kernel threads or pre-emptive lightweight threads; but programs that use non pre-emptive threads (coroutines, cooperative threads) and any programs that use custom schedulers, will be listed as interesting alternative implementations."
01:51:59 <Eduard_Munteanu> One could concoct a Haskell program that s/sense?/sense./
01:51:59 <gienah> shachaf: I think the first java benchmark in that test is cheating, as it uses a thread pool, so the context switch is likely to occur back to the same thread in the pool, or one of a small number of threads
01:52:02 <shachaf> I *guess* it counts, but only kind of.
01:52:08 <Eduard_Munteanu> Bah, I'm typing badly today.
01:53:00 <gienah> shachaf: I think the Haskell, Go and Erlang results show the superior performance of the lightweight threads in the runtime systems for those languages
01:53:19 <Eduard_Munteanu> One could think a C program could actually do asm stuff instead of being "normal" C.
01:53:29 <shachaf> Huh, that Haskell benchmark is definitely cheating. You could write a little C example with a simple coroutine-based "lightweight threading" library that "preempts" on memory allocation.
01:53:38 <shachaf> And that wouldn't count.
01:54:59 <gienah> shachaf: well say if I tried to write a large application program using co-routines in C or C++, then I would have trouble as lots of things I need to call would not know about the coroutines
01:55:22 * shachaf is involved in writing a large application that uses coroutines in C++. :-)
01:55:41 <shachaf> It is *much* nicer than writing the equivalent program with explicit finite-state machines.
01:56:04 <quicksilver> shachaf: the passage you pasted about GHC pre-emption is out-of-date
01:56:15 <quicksilver> that's a description of the 'unthreaded' runtime.
01:56:35 <shachaf> quicksilver: Oh, good. Why is it in <http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html>, then?
01:56:39 <quicksilver> the modern GHC 'threaded' runtime uses OS threads which do true pre-emption - and that's what is being used in the example we were discussing.
01:56:49 <shachaf> Ah.
01:57:05 <shachaf> Wait, so it runs a full OS thread for every thread in the thread-ring?
01:57:08 <quicksilver> no.
01:57:17 <quicksilver> it multiplexes haskell threads over full OS threads
01:57:34 <shachaf> Ah, it does N:M threading?
01:57:35 <flux> quicksilver, so what happens if you have as many non-memory-allocating haskell threads as you have full os threads running?
01:57:45 <Saizan> shachaf: yep
01:57:45 <flux> (a pathetic case^2 ;-))
01:58:36 <quicksilver> shachaf: well, the paragraph you pasted was out of context. If you read up above that in 'Haskell threads and Operating System threads' there is some discussion about the N:M
01:58:52 <quicksilver> of course the documentation is patchy and contains some out of date fragments, because writing docs is hard and dull :)
01:59:14 <quicksilver> flux: then you spin CPU forever :)
01:59:40 <shachaf> quicksilver: Aha, so it's still not true preemption. :-)
01:59:55 <flux> I guess typical haskell programs allocate memory a lot, like any functional language
01:59:57 <shachaf> And you can implement an N:M threading library in C that behaves the same way.
02:00:14 <quicksilver> shachaf: you know what, you can actually implement the ENTIRE HASKELL RTS in C if you want?
02:00:15 <flux> whereas a typical C program can allocate a lot less, if anything, if you don't count stack allocation
02:00:19 <quicksilver> and then implement HASKELL on top?
02:00:30 <quicksilver> in otherwords, I'm not quite sure what point you're making :)
02:00:40 <quicksilver> unless it's just 'artificial benchmarks are artificial'.
02:00:46 <quicksilver> In which case, I reply with a resounding 'yes'.
02:01:02 <shachaf> quicksilver: The specifications of the benchmark require that the threads are pre-emptive. The Haskell threads aren't.
02:01:17 <shachaf> But, yes, "artificial benchmarks are artificial".
02:01:23 <quicksilver> depending how you define pre-emptive, yes, that's right.
02:02:04 <Eduard_Munteanu> Well it's not like they're useless, it's just people that draw wrong conclusions ;)
02:02:24 <flux> in my book pre-emption means 'no explicit task switching'
02:02:28 <shachaf> Anyway, my point is that it's actually reasonably easy to implement the same benchmark in C, and it would probably beat the Haskell, but not be accepted.
02:02:45 <flux> I guess in future perhaps GHC could insert explicit pre-emption points into pieces of code that would not pre-empt otherwise
02:03:15 <shachaf> Is C code where malloc() switches control to the scheduler "pre-emptive"?
02:03:24 <Saizan> they still get pre-empted along the OS threads no? it's just that the threads not currently assigned to an OS one can be starved by the ones running
02:03:36 <Saizan> does pre-emption imply fairness?
02:04:18 <shachaf> If it doesn't imply some kind of fairness, you can just never pre-empt.
02:04:53 <quicksilver> well my point, I think, is that among the various stupid and artificial 'rules' on the shootout, this is one of the dumbest :)
02:05:07 <quicksilver> the artificial distinction between pre-emption and cooperation
02:05:12 * shachaf agrees with your point, then.
02:05:16 <quicksilver> when really it's a continuum.
02:05:32 <quicksilver> just benefits the language which pushes as far as it can down the grey without being ruled out
02:05:41 <quicksilver> quite a lot of the shootout is a bit like that, though.
02:05:45 <flux> in any case, when you have tons of threads (ie. more threads than cpu's), you're not probably doing computational work, but rather you're using threads to divide the program into independant execution flows that communicate by some means
02:06:02 <Eduard_Munteanu> shachaf: nah, calls into the kernel don't really classify as preemption
02:06:40 <shachaf> There you go.
02:07:20 * shachaf will take this opportunity to mention how silly it is that swapcontext() makes a system call.
02:10:52 <ezyang> What's the easiest way to test if two values have the same constructor (but not necessarily anything inside?) 
02:11:33 <roconnor> ezyang: Boolean testing is evil
02:11:57 <ezyang> mrr? 
02:12:00 <shachaf> ezyang: You could use Data.Data.toConstr.
02:12:07 <ezyang> ewwww 
02:12:07 <roconnor> oh god
02:12:40 <ivanm> ezyang: sameConstructor Foo{} Foo{} = True; sameConstructor Bar{} Bar{} = True; sameConstructor _ _ = False "
02:12:44 <ivanm> s/"/?/
02:12:46 <shachaf> ...You did say "easiest".
02:13:02 <ezyang> What a strange definition of "easy" you have :-) 
02:13:32 <shachaf> ezyang: Huh? Just add "deriving Data" and then use toConstr a == toConstr b, and you're done.
02:13:45 <Lemmih> ezyang: There's also GHC.Exts.dataToTag# (:
02:13:58 <tab> ivanm: that's lots of boilerplate if you have lots of type .. and quite error prone if you modify anything afterwards ..
02:14:14 <quicksilver> all the solutions are metaprogramming.
02:14:30 <quicksilver> you either use an existing metaprogramming with compiler support like deriving Data (or even deriving Show :P)
02:14:31 <ezyang> lessee if GHC likes Data.Data... 
02:14:46 <ivanm> that reminds me: what's the complexity of pattern matching?
02:14:50 <quicksilver> or you write your own using uniplate or data.derive or DrIFT or TH or CPP ...
02:15:15 <ivanm> i.e. if I have a large data type and a function that acts differently on each constructor, is there a penalty for using later constructors over earlier ones?
02:15:16 <Eduard_Munteanu> IIRC it's O(n) as GHC does it.
02:15:16 <shachaf> quicksilver: CPP?
02:15:25 <ivanm> Eduard_Munteanu: that's what I was afraid of...
02:15:26 <Eduard_Munteanu> where n is the number of constructors.
02:15:30 <quicksilver> I think it's O(1) in GHC
02:15:39 * ivanm wonders if using a tree is feasible...
02:15:39 <ivanm> quicksilver: oh?
02:15:39 <quicksilver> GHC will generate a jump table if the case tree is large enough.
02:15:40 <quicksilver> not sure though.
02:15:47 <Eduard_Munteanu> I remember somebody complaining about it though.
02:15:58 <Eduard_Munteanu> You could look at the core I suppose.
02:16:00 <ivanm> Eduard_Munteanu: sorry, I think I trust quicksilver more than I do you ;)
02:16:12 <Eduard_Munteanu> Sure, I trust him more than myself too :)
02:16:13 <shachaf> Jump table? That's at most O(0.25).
02:16:30 <Eduard_Munteanu> (I'm not sure either)
02:17:04 <quicksilver> the core doesn't tell you.
02:17:09 <ezyang> ugh, deriving (Data) requires any types I use to also have Data instances. 
02:17:16 <quicksilver> it's how the codegen converts core into code
02:17:40 <ivanm> hmmm.....
02:17:54 <quicksilver> a huge case in haskell will still (most likely) be a huge case in core.
02:18:02 <Eduard_Munteanu> Oh.
02:18:18 <Saizan> having more than one constructor is a penalty because you're doing the switching at all, but i don't think there's much difference once you've 2 or more
02:18:50 <ivanm> Saizan: *nod*
02:18:53 <shachaf> ezyang: Oh, bah.
02:20:06 * Eduard_Munteanu idly wonders whether GHC takes annotations of branch likelyness.
02:21:31 <Eduard_Munteanu> (likely() / unlikely() a-la Linux)
02:27:13 * hackagebot Semigroup 0.0.7 - A semigroup  http://hackage.haskell.org/package/Semigroup-0.0.7 (TonyMorris)
02:30:46 <Amol> hello folks
02:32:45 <zygoloid> Eduard_Munteanu: it's been discussed on -cafe at least. (someone wanted the ordering of patterns to be used to imply likeliness)
02:48:15 * hackagebot hp2any-core 0.10.1 - Heap profiling helper library  http://hackage.haskell.org/package/hp2any-core-0.10.1 (GergelyPatai)
02:49:15 * hackagebot hp2any-graph 0.5.3 - Real-time heap graphing utility and profile stream server with a reusable graphing module.  http://hackage.haskell.org/package/hp2any-graph-0.5.3 (GergelyPatai)
02:50:15 * hackagebot hp2any-manager 0.4.4 - A utility to visualise and compare heap profiles.  http://hackage.haskell.org/package/hp2any-manager-0.4.4 (GergelyPatai)
03:10:28 <Eduard_Munteanu> Ah, I see, zygoloid.
03:12:00 <Eduard_Munteanu> Though as GCC does it, it's different: if you optimize for a likely()/unlikely() case the miss penalty is generally a lot higher than if you didn't do predictions.
03:12:51 <Eduard_Munteanu> (inasmuch as it's worth doing it only if almost all branches are taken a certain way, not just a majority)
03:16:28 * hackagebot hquantlib 0.0.2.0 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.2.0 (PavelRyzhov)
03:23:32 * hackagebot SafeSemaphore 0.6.0 - Much safer replacement for QSemN, QSem, and SampleVar  http://hackage.haskell.org/package/SafeSemaphore-0.6.0 (ChrisKuklewicz)
03:47:32 <rsuniev2> I have GHCi, version 6.12.3 what is the easiest way to upgrade to 7.0.3? I am on Windows
03:48:19 <HugoDaniel> rsuniev2: i usually delete ghc and install it again
03:48:49 <HugoDaniel> rsuniev2: you can also try the haskell platform, it bundles quite some usefull packages together with ghc
03:49:50 <rsuniev2> HugoDaniel: Thanks. 
03:52:25 <morphles> :t  ((mod x 10):d, div x 10)
03:52:25 <lambdabot>     Couldn't match expected type `[Expr]' against inferred type `Expr'
03:52:26 <lambdabot>     In the second argument of `(:)', namely `d'
03:52:26 <lambdabot>     In the expression: (mod x 10) : d
03:52:48 <morphles> :t \(d, x) = ((mod x 10):d, div x 10)
03:52:49 <lambdabot> parse error on input `='
03:52:56 <morphles> :t \(d, x) -> ((mod x 10):d, div x 10)
03:52:56 <lambdabot> forall t. (Integral t) => ([t], t) -> ([t], t)
03:53:13 <morphles> :t fix (\(d, x) -> ((mod x 10):d, div x 10))
03:53:14 <lambdabot> forall t. (Integral t) => ([t], t)
03:55:07 <morphles> :t  (\x -> fix (\(d, x) -> ((mod x 10):d, div x 10)))
03:55:07 <lambdabot> forall t t1. (Integral t1) => t -> ([t1], t1)
03:55:39 <morphles> now why: "(\x -> fix (\(d, x) -> ((mod x 10):d, div x 10))) 5" seem to compute indefinetly?
03:55:53 <morphles> aaa
03:55:57 <morphles> nvm
03:56:04 <mauke> why did you wrap another function around it?
03:56:56 <morphles> aroudn what?
03:57:11 <mauke> around fix (\(d, x) -> ((mod x 10):d, div x 10))
03:57:29 <nickela> hello All, how get from Data.Map first element having equal or greather key (analog C++ std::map<>::lower_bound) ?
03:57:39 <morphles> ah thats because i tried to use let in ghci, and when pasted i thoug it was faseter to add (\ ) than delete x ->
03:57:43 <morphles> or something like that
03:57:52 <mauke> morphles: but that does nothing
03:58:01 <morphles> :t fix (\(d, x) -> (if div x 10 > 0 then (mod x 10):d else d, div x 10))
03:58:02 <mauke> you might as well leave it off
03:58:02 <lambdabot> forall t. (Integral t) => ([t], t)
03:58:11 <morphles> ah wait
03:58:26 <morphles> types differ
03:58:35 <morphles> :t (\x -> fix (\(d, x) -> (if div x 10 > 0 then (mod x 10):d else d, div x 10)))
03:58:35 <lambdabot> forall t t1. (Integral t1) => t -> ([t1], t1)
03:58:39 <morphles> you see?
03:58:52 <o--> Where's the progrmaming languages?
03:58:54 <morphles> but still: " (\x -> fix (\(d, x) -> (if div x 10 > 0 then (mod x 10):d else d, div x 10))) 5" does not return
03:59:07 <mauke> morphles: yeah, one is ([t], t) and the other is unused -> ([t], t)
03:59:13 <mauke> so why add an unused parameter?
03:59:15 <morphles> mauke: unused?
03:59:22 <mauke> yes
03:59:34 <andreas_> I have a problem with IO... How can i access a record field in the following code: http://pastebin.com/r5LHQwxu
03:59:35 <morphles> id gets shadowed?
03:59:49 <mauke> ...
03:59:54 <andreas_> seems like i need to convert IO BZVersion to BZVersion, but i'm not sure how
03:59:59 <morphles> > fix (\(d, x) -> (if div x 10 > 0 then (mod x 10):d else d, div x 10)) ([], 465465465465)
04:00:00 <lambdabot>   Couldn't match expected type `([a], t1) -> t'
04:00:00 <lambdabot>         against inferred type...
04:00:24 <mauke> andreas_: with <-
04:00:33 <mauke> (this is technically a lie)
04:00:34 <morphles> im trying to understand fix and to get list of digits from number
04:00:34 <o--> Hello where is the programming languages channel?
04:00:41 <andreas_> mauke, please see my paste
04:00:48 <mauke> andreas_: I did, hence my answer
04:01:04 <andreas_> i'm sorry i don't understand how
04:01:09 <nickela> I think found how emulate std::map<>::lower_bound  via Data.Map.splitLookup :)
04:01:16 <Saizan> morphles: http://www.vex.net/~trebla/haskell/fix.xhtml
04:01:25 <mauke> nickela: yeah, that's the closest thing I can find
04:01:50 <andreas_> i'm just trying to access the "version" field of the BZVersion record
04:02:01 <mauke> andreas_: you don't have a BZVersion record (yet)
04:02:20 <morphles> Saizan: thanks
04:02:24 <morphles> maybe it will help
04:02:52 <andreas_> mauke, but if i do z<-bz_version and then putStrLn(show z) it properly shows the BZVersion record
04:02:59 <andreas_> but i can't get only the version field
04:03:17 <andreas_> as the accessor method apparently accepts BZVersion and i'm trying to pass IO BZVersion
04:03:29 <mauke> andreas_: putStrLn (show (version z))
04:04:10 <mauke> @src print
04:04:10 <lambdabot> print x = putStrLn (show x)
04:04:54 <o--> where can I talk about programming languages with someone
04:05:17 <andreas_> main = do
04:05:17 <andreas_>   z <- bz_version
04:05:17 <andreas_>   ver <- version z
04:05:22 <andreas_> mauke, would that work?
04:05:25 <mauke> andreas_: no
04:05:35 <andreas_> damnit -.-
04:05:44 <mauke> andreas_: let ver = version z
04:06:13 <andreas_> i guess i need to read up on the difference between <- and let
04:06:27 <mauke> the short version is that in 'x <- y', y :: IO something and x :: something
04:06:43 <mauke> whereas in let both sides have the same type
04:06:54 <andreas_> okay fair enough
04:07:09 <mauke> the longer version is that '<-' actually registers a callback (and the callback is the rest of that block)
04:08:16 <Kaidelong> sounds like an asynchronous workflow
04:11:31 <jaspervdj> What exactly does â€œ@â€ mean in GHC Core? The types to which a type of kind e.g. * -> * is applied?
04:13:18 <Jungli> omg 
04:13:30 <Jungli> tons of nikcs in this channel 
04:13:37 <Botje> lies
04:13:42 <Jungli> ppl are so much worry about haskell 
04:13:55 <Jungli> lies what lies ?
04:14:26 <Jungli> is haskell is easy ?
04:14:57 <mauke> I don't know
04:15:24 <sipa> the easiest language is always the one you already know
04:15:36 <sipa> and haskell is most likely very different from what you already know
04:16:02 <Jungli> sipa: nice 
04:16:31 <Jungli> sipa: but where i start it to learn i am curious about it :)
04:17:15 <Jungli> !ping
04:17:18 <rsuniev2> Just installed haskell on windows. how to run a Makefile?
04:17:42 <Jungli> lemme download it plz guys help to learn it :)
04:18:20 <mauke> Jungli: ok, you have our permission to download it
04:18:26 <fryguybob> @where lyah
04:18:26 <lambdabot> http://www.learnyouahaskell.com/
04:18:44 <fryguybob> rsuniev2: What are you trying to do?
04:19:12 <rsuniev2> Wanted to compile this: http://code.haskell.org/~byorgey/typeclassopedia/
04:19:27 <rsuniev2> To get PDF out of it
04:19:30 <Jungli> thanks fryguybob 
04:19:44 <Jungli> mauke:  :P :P :P :P
04:20:10 <mauke> rsuniev2: with make
04:20:35 <Botje> rsuniev2: the PDF was published as part of the monad reader
04:20:36 <Saizan> rsuniev2: it's in here http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf
04:20:40 <rsuniev2> mauke: How to run make?
04:20:44 <Botje> no need to compile it yourself
04:20:52 <mauke> rsuniev2: ...
04:21:05 <mauke> what kind of answer do you expect?
04:21:11 <fryguybob> rsuniev2: You can run make in an msys console.
04:21:14 <Jungli> where is the exe file in the haskell website to install haskell ?
04:21:14 <andreas_> how can i specify that a function has no return type
04:21:22 <Saizan> rsuniev2: make is not part the standard haskell installation btw
04:21:23 <mauke> andreas_: impossible
04:21:32 <fryguybob> @where platform
04:21:32 <lambdabot> http://hackage.haskell.org/platform/
04:21:36 <andreas_> mauke, i know of Unit
04:21:37 <mauke> andreas_: are you sure your function doesn't return?
04:21:40 <Saizan> +of
04:21:52 <sipa> andreas_: a function without return type is useless in haskell - the only effect a function has is its return value
04:22:09 <andreas_> i see
04:22:21 <Jungli> 91.4 MB 
04:22:46 <sipa> Jungli: the haskell platform also contains a set of useful haskell packages
04:22:55 <sipa> which as a beginner you typically won't need
04:22:57 <mauke> http://hackage.haskell.org/platform/contents.html
04:23:16 <fryguybob> @where tryhaskell
04:23:16 <lambdabot> http://tryhaskell.org/
04:24:32 <rsuniev2> fryguybob: Could you provide an example?
04:25:35 <rsuniev2> fryguybob: Or if it's not installed by default how to install it?
04:26:49 <fryguybob> @where msys
04:26:49 <lambdabot> http://www.mingw.org/wiki/MSYS
04:27:58 <dobblego> andreas_: where did you learn of Unit?
04:28:02 <rsuniev2> fryguybob: thanks
04:32:34 <Jungli> @where sample code
04:32:34 <lambdabot> I know nothing about sample.
04:32:50 <Jungli> @where hello world 
04:32:50 <lambdabot> I know nothing about hello.
04:32:56 <Jungli> sorry
04:33:26 <andreas_> dobblego, i guess at "learnyouahaskell"
04:33:31 <andreas_> if i remember correclty
04:33:49 <dobblego> andreas_: there is only one value for unit right?
04:34:01 <andreas_> from what i read unit is like void in other languages
04:34:09 <andreas_> anyone here into xml-rpc client programming using the haxr library?
04:34:29 <dobblego> it's a bit like void, but also not quite the same
04:35:10 <dobblego> in particular, haskell demands your honesty, and so unit has one and only one value, where void has many possibilities
04:35:53 <mauke> void has no value
04:36:39 <dobblego> and that too
04:38:52 <isomorphic> that's very deep mauke
04:40:57 <Kaidelong> Haskell doesn't have anything quite like VOID
04:41:08 <Kaidelong> I'm not so sure about void though
04:41:09 <o--> yeah it does IO ()
04:41:23 <mauke> what's VOID?
04:41:29 <Kaidelong> o--: IO () is more like void if anything and () is still an actual value
04:41:32 <Kaidelong> mauke: the void pointer
04:41:36 <mauke> what
04:41:38 <andreas_> how can i easily create a haswhmap?
04:41:41 <mauke> in what language?
04:41:49 <mauke> andreas_: why a hash?
04:41:49 <Kaidelong> mauke: In the windows API
04:41:50 <andreas_> haskell
04:41:58 <mauke> Kaidelong: ouch
04:42:20 <o--> The reason haskell doesnt have void* is beacause it's not type safe
04:42:29 <mauke> Kaidelong: I would have expected PVOID or something
04:42:31 <frerich> Kaidelong: I believe the void* is PVOID
04:43:46 <Kaidelong> but anyway the thing with void is that you can cast it to other types
04:44:01 <Kaidelong> this isn't the case with unit
04:44:02 <o--> that's not type safe
04:44:14 <o--> there's a reason for not having it
04:44:28 <Martty> it's type safe if you don't use casts
04:44:31 <Martty> but then it's useless
04:44:41 <Kaidelong> right I don't know if void is really something haskell has
04:45:25 <Kaidelong> you just use "unit" to get a good type for things where one might otherwise use void
04:45:25 <o--> void is like IO ()
04:45:31 <Jungli> sort "chris"
04:45:34 <dobblego> andreas_: these discussions aside, functions that return "Unit" (called () in haskell) are guaranteed to only return one value, which is different to void in other languages
04:45:42 <Jungli> is not working why ?
04:45:47 <dobblego> > sort "chris"
04:45:48 <lambdabot>   "chirs"
04:45:59 <mauke> Kaidelong: the thing with void is that you can't cast it; the thing with void * is that it doesn't require a cast
04:46:09 <Jungli> Tuples, because sometimes one value ain't enough!
04:46:15 <Kaidelong> dobblego: Except in languages that are not total where they are not guaranteed to return at all
04:46:19 <Jungli> what that it mean
04:46:45 <dobblego> Kaidelong: I assume the total subset of haskell, like a naive optimist
04:48:18 <Kaidelong> @djinn ((),()) -> ()
04:48:18 <lambdabot> f (a, _) = a
04:48:24 <jeffz> > sort "Ð¿Ñ€Ð¸Ð²ÐµÑ‚"
04:48:26 <lambdabot>   "\1074\1077\1080\1087\1088\1090"
04:48:35 <ezyang> @djinn a -> () 
04:48:35 <lambdabot> f _ = ()
04:48:41 <ezyang> funny :-) 
04:48:42 <Kaidelong> yeah
04:48:48 <Kaidelong> that's what I was expecting it to do
04:48:51 <Kaidelong> but I guess not
04:49:14 <ezyang> Well, f (a, _) = a is maximally lazy on the right side. 
04:49:17 <andreas_> mauke, i need to pass a hash to a remote xml-rpc function
04:49:19 <Jungli> x= 4
04:49:22 <ezyang> where as f ((), ()) = () would not be. 
04:49:22 <Jungli> x*x
04:49:31 <mauke> andreas_: what does that mean?
04:49:55 <Jungli> let x = 4
04:49:57 <andreas_> i need to pass a hash like {'login' => 'user', 'password' => 'secret'}
04:50:13 <mauke> but that's just text
04:50:43 <andreas_> i'm using the xmlrpc module for haskell, and i am not sure if i can simply pass text
04:50:52 <Jungli> hey guys i am stuck at here :(
04:50:55 <andreas_> because passing two integers works like
04:50:57 <Jungli> http://tryhaskell.org/#8
04:51:05 <andreas_> remote "server" "Method" x y
04:51:38 <mauke> you're using haxr
04:51:43 <andreas_> yes
04:52:08 <Jungli> hello?
04:52:31 <andreas_> xmlrpc: user error (Error calling User.login: Error -32000: Can't use string ("{'login': 'user', 'password': 'b") as a HASH ref while "strict refs" in use at Bugzilla/WebService/User.pm line 50.
04:52:35 <Jungli> got it 
04:52:46 <Jungli> sorry i solve that i done minor mistake lol
04:52:51 <Jungli> its so easy :P
04:52:59 <mauke> andreas_: looks like it's all http://hackage.haskell.org/packages/archive/haxr/3000.8.1/doc/html/Network-XmlRpc-Internals.html#t:Value
04:54:44 <mauke> andreas_: data Login = Login{ login :: String, password :: String }
04:54:49 <mauke> looks like it should work
04:55:20 <Jungli> ]lesson 
04:55:24 <Jungli> lesson 
04:55:39 <Kaidelong> ezyang: Yeah but I was thinking just "f _ = ()"
04:56:01 <drbean> andreas_: That's a perl error, I believe.
04:56:02 <ezyang> oh yes, that is maximally lazy in all arguments. 
04:56:04 <Kaidelong> rather than f(a,_) = a
04:56:49 <ezyang> I guess it wouldn't be too hard to teach Djinn that () is inhabited by (). 
04:57:40 <mauke> it already knows
04:57:54 <mauke> it prefers solutions that depend on arguments
04:58:19 <Kaidelong> so djinn will present the strictest solution it can think of?
04:58:23 <Kaidelong> I guess that makes sense
05:02:38 <Jungli> is haskeel is like php can i make web pages via haskell 
05:03:14 <Verge> Processing web pages is only about making a processor application run in the web server
05:03:24 <Kaidelong> @faq is haskeel is like php can i make web pages via haskell
05:03:24 <lambdabot> The answer is: Yes! Haskell can do that.
05:03:41 <Jungli> Kaidelong: how ?
05:04:04 <Kaidelong> well there is HSP
05:04:11 <Kaidelong> that's probably the most PHPlike way
05:04:17 <Jungli> cool
05:04:18 <Kaidelong> http://www.haskell.org/haskellwiki/HSP
05:05:37 <earthy> however!
05:05:46 <earthy> please look into Yesod or Snap
05:05:47 <aleator> Hmm.. Opinions: Is it reasonable to teach an introductory functional programming course based on lyah?
05:06:00 <dobblego> yes
05:06:04 <earthy> as HSP, being the most PHPlike way, is also not necessarily the best way
05:06:35 <earthy> so, the correct answer is 'yes, haskell can do that, and better too!'
05:07:16 <andrewe_> earthy: are you using yesod?
05:07:48 <earthy> actually, no
05:08:00 <earthy> but that's mostly because WAI provides what I need
05:08:24 <andrewe_> I'm trying to install yesod, but I alway run into trouble.
05:08:51 <earthy> 'cabal install yesod' doesn't work?
05:09:12 <gienah> andrewe_: yesod installs on gentoo (as do happstack and snap)
05:09:22 <andrewe_> after a lot of fiddling with cabal and installing several yesod-* packages, I can run it.
05:09:45 <andrewe_> I'm interested on which platform it runs (i.e. which GHC version, which OS)
05:10:21 <andrewe_> The yesod scaffolding tool generates code that doesn't run.
05:10:56 <andrewe_> I could fix that by adding a '$' to the QuasiQuoting stuff.
05:11:11 <andrewe_> but now I get:
05:11:20 <andrewe_> Couldn't match expected type `Network.Wai.Request'
05:11:21 <andrewe_>        against inferred type `Network.Wai.Request'
05:12:32 <andrewe_> gienah: I will try gentoo, thanks for the hint.
05:15:11 <gienah> andrewe_: I'm trying the yesod scaffolding on gentoo to see if that error occurs or not
05:15:27 * earthy is trying it on mac os x
05:15:41 <andrewe_> gienah: which GHC are you using?
05:16:06 <gienah> andrewe_: just tried it with ghc 7.0.3, scaffolded app compiled fine
05:16:47 <andrewe_> gienah: damn, I'm also using ghc 7.0.3 on os x 10.6.7
05:16:57 <earthy> The Glorious Glasgow Haskell Compilation System, version 6.12.3
05:17:03 <andrewe_> gienah: have you xcode 4 installed?
05:17:37 <andrewe_> sorry, earthy is the one on os x
05:19:25 * earthy has xcode 3 installed
05:19:49 <earthy> but I'm installing yesod from scratch, so that'll take some time
05:22:12 <gienah> andrewe_: a scaffolded yesod app created with ghc 6.12.3 also builds fine with ghc 6.12.3 on gentoo
05:23:18 <andrewe_> gienah: I have kernel 2.6.36-gentoo-r5, does that match your configuration?
05:24:10 <gienah> andrewe_: I run an old kernel: argus 2.6.35-gentoo-r15
05:24:15 <andrewe_> gienah: is there an automatic installation for gentoo, or do I have to follow the handbook?
05:24:39 <andrewe_> gienah: I hope that won't be an issue.
05:24:48 <gienah> andrewe_: the web frameworks are in the gentoo-haskell overlay
05:24:52 <Eduard_Munteanu> If I do two qualified imports 'as' the same name, do the resulting namespaces add up?
05:25:02 <Eduard_Munteanu> I mean, contain the union of the two?
05:25:39 <quicksilver> yes.
05:26:30 <earthy> oh, wow
05:26:31 <Eduard_Munteanu> Thanks.
05:28:27 <earthy> /Library/Frameworks/GHC.framework/Versions/Current/usr/lib/ghc-6.12.3/ghc-asm points to /opt/local/bin/perl
05:28:57 <Eduard_Munteanu> Aww, damn you Agda, you won't take {-# IMPORT Data.STRef as X #-}
05:29:12 <gienah> andrewe_: everything in the overlay is masked. I guess it would be easiest to start with unmasking and emerging dev-lang/ghc, dev-haskell/haskell-platform and dev-haskell/yesod: http://haskell.org/haskellwiki/Gentoo
05:29:12 <earthy> which broke installing yesod
05:29:55 <andrewe_> gienah: I have no running gentoo system yet
05:30:34 <earthy> so, for Haskell Platform 2010.2.0 for Mac OS X using GHC 6.12.3 installing yesod does indeed break!
05:30:53 <earthy> (fixing it is a matter of changing the first line of ghc-asm to point to /usr/bin/perl )
05:31:58 <gienah> andrewe_: there is some chance it would work on macos: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
05:32:53 <earthy> and apparently you need an updated alex as well
05:32:53 <gienah> andrewe_: as the gentoo haskell devs have been working on prefix support for the gentoo haskell packages lately
05:34:35 <andrewe_> gienah: I tried yesod on OS X, Debian, and Ubuntu. None of them worked, I will now try to have a freshly installed system which someone has got working. I don't think Gentoo Prefix is the kind of complexity I want to add now.
05:38:06 <gienah> andrewe_: we hang out in #gentoo-haskell
05:39:35 <Berengal> Okay, which of us is the crazy one: https://github.com/LaurentGomila/SFML/issues/28
05:41:01 <earthy> andrewe_: okay, yesod 0.7.3, Mac OS X 10.6.7, Haskell Platform 2010.2.0.0, works, *if* you 1. fix ghc-asm to point to /usr/bin/perl 2. install an updated alex 3. fix the quasiquotation syntax in the yesod-generated haskell files so that it compiles
05:41:43 <earthy> (that is adding a $ to line 69 after the [ )
05:42:16 <earthy> and then you need to start the yourprojectname-test binary rather than th yourprojectname-devel binary
05:42:51 <earthy> this was more painful than expected though
05:49:12 <andrewe_> earthy: why do I need to link ghc-asm to perl???
05:49:21 <mauke> wrong question
05:49:40 <mauke> you need to point it to /usr/bin/perl instead of /opt/local/bin/perl
05:49:44 <mauke> "perl" is a given
05:50:01 <earthy> on my installation of GHC 6.12.3  ghc-asm fails because it tries to run a non-existent perl
05:50:24 <earthy> thereby resulting in a failure to install utf8-light
05:50:28 <andrewe_> then what do you mean by "point to"?
05:50:31 <tab> Berengal: is there no way to know when the music thread is finished ?
05:50:43 * hackagebot pontarius-mediaserver 0.0.2.0 - Extended Personal Media Network (XPMN) media server  http://hackage.haskell.org/package/pontarius-mediaserver-0.0.2.0 (JonKristensen)
05:50:58 <earthy> andrewe_: the first line of ghc-asm reads  #!/opt/local/bin/perl   and should read   #!/usr/bin/perl
05:51:00 <o--> What would be a valuable conttribuation to the ahaskell community?
05:51:05 <Berengal> tab: The music thread knows, but how will I be able to keep tabs on that?
05:51:15 <andrewe_> earthy: that's ok on my system (without me changing it)
05:51:34 <tab> Berengal: is there's something in the API to let you know the thread is done (music is finished playing for example)
05:51:40 <earthy> andrewe_: you have a different haskell platform then, right?
05:51:48 <earthy> and a different GHC I'd wager
05:51:54 <andrewe_> GHC 7.0.3
05:51:57 * earthy nods
05:52:06 <andrewe_> earthy: I will upgrade alex
05:52:17 <Botje> o--: it has gotten better recently, but when I started it was really hard to find examples of how to use popular modules 
05:52:17 <tab> Berengal: in this case you could just hold an extra reference when calling the music play function
05:52:24 <earthy> alex made installing the javascript libs break
05:52:36 <o--> Botje: which modules
05:53:07 <Berengal> tab: Not really, but that's not the issue. The issue is that you need to "artificially" keep the music reference alive because the GC doesn't know about the reference being kept by the playing thread
05:53:24 <Botje> o--: stuff on hackage and in the haskell platform
05:53:36 <tab> Berengal: i understand that, but its seems the argumentation is going nowhere
05:54:23 <tab> Berengal: obviously the API is incomplete if it doesn't let you know when the internal reference has been dropped
05:56:13 <Berengal> tab: Indeed. The best solution i have now is to wrap the native Music object in a haskell datatype and publish that in the binding API instead. The musicStart function would then spawn a new Haskell thread that keeps the reference alive until the musicStop function is called
05:56:34 <tab> Berengal: yeah something like that :\
05:56:43 <andrewe_> earthy: I still get the old error with 'Network.Wai.Request' :-(
05:56:45 <Berengal> It's *possible* to work around, but it's kludgy and I would need a shower after writing it
05:57:39 <tab> Berengal: i hope you get lucky arguing your case, but my experience when trying to argue incomplete APIs
05:57:52 <tab> isn't very good
05:57:53 <Berengal> Yeah :/
05:57:53 <earthy> andrewe_: interesting
05:58:39 <earthy> andrewe_: where does it report that error?
06:00:12 <Berengal> tab: I'm hoping the bug in the C# bindings will tide them over, but it's quite possible it'll go the other way; the C# bug will stay because it's related to the API bug
06:00:14 <andrewe_> earthy: http://hpaste.org/45655/yesod_waihandledevel
06:00:36 <earthy> ah, right
06:00:54 <earthy> have you tried cabal configure && cabal build ?
06:01:09 <earthy> and then ./dist/build/racket-test/racket-test  ?
06:01:24 <earthy> (assuming your project is called racket, by the way)
06:01:31 <andrewe_> Yes, it tells me I should run wai-devel-handler ...
06:02:09 <earthy> was that racket-devel or racket-test ?
06:03:27 <andrewe_> earthy: sorry, it was devel, the test seems to create some sql tables
06:03:48 <andrewe_> earthy: it works
06:03:52 <earthy> there you go ;)
06:04:01 <andrewe_> earthy: thank you, but what is the -devel file for?
06:04:09 <earthy> no clue ;)
06:04:18 <earthy> you should ask Michael Snoyman :)
06:04:26 <earthy> afaict it's a stub
06:07:28 <andrewe_> earthy: nevermind, it works now.
06:07:49 <earthy> good luck with it
06:12:24 <ezyang> Are let bindings in core strict? 
06:12:52 <PeakerWork> would it be practical to write a visual interpreter of Haskell pure expressions, that allows "digging in" to see the values of subexpressions to figure out what causes a wrong result (e.g: wrong value or pure exception)?
06:13:17 <earthy> ezyang: not that I know of. Strictness in core comes from case switches, IIRC.
06:13:52 <ezyang> OK. 
06:14:41 <PeakerWork> I suspect it might be problematic because an examine-able evaluation process cannot release memory that would no longer be needed if we don't need to visualize the entirety of the evaluation. Unless perhaps we just keep some of the intermediate small values and re-compute as necessary
06:17:48 <Berengal> PeakerWork: It would at the very least look cool
06:18:17 <Berengal> And I think recomputing values wouldn't be too problematic.
06:44:20 <Saizan> @where hood
06:44:20 <lambdabot> www.haskell.org/hood/
06:57:28 <tromp_> http://hackage.haskell.org/package/sifflet
07:04:30 <xenocryst> can you do pattern matching on a record? For example, I have a record: { tape :: ([Int], [Int]), code :: String, input :: String, output :: String } but I guess I don't know how to use it like I do tuples
07:04:55 <Jafet> Not with the pretty record syntax, no.
07:05:11 <Jafet> You can use the regular constructor syntax.
07:05:14 <quicksilver> ?
07:05:31 <xenocryst> Jafet: ok, thanks
07:05:35 <quicksilver> you can pattern match using either record syntax or plain syntax
07:05:50 <quicksilver> f (Foo {a=thea,b=theb}) = thea + theb
07:05:50 <Jafet> !
07:05:57 <Axman6> xenocryst: if you have data Foo = Bar {a :: Int, b :: String}, you can use f (Bar x y) = ...
07:06:14 <quicksilver> or f (Bar {a=x,b=y} = ... )
07:06:30 <quicksilver> the advantage of the record notation one is you're allowed to miss out fields you don't care about
07:06:35 <quicksilver> (and permute the order, of course)
07:06:51 <quicksilver> that closing ) is in the wrong place, sorry.
07:06:52 <xenocryst> ok, sweet. That makes what I want to do a lot simpler
07:06:56 <xenocryst> thanks guys!
07:07:23 <Jafet> Weird, I don't remember ever seeing that in code.
07:17:52 <universa1> hello, currently trying to install ghc7.0.3 ontop of a freshly installed haskell platform on mac os x sl, but i'm kinda stuck at which source package is the right one. i've tried the unknown-linux one, but that errors already in the ./configure step
07:18:41 <Axman6> unknown-linux one? you know OS X is not linux right?
07:18:55 <absentia> osx is certified unix?
07:18:57 <absentia> like freebsd?
07:19:01 <Axman6> yes
07:19:07 <absentia> unencumbered, too... unlike linix.
07:19:07 <Axman6> unlike linux >_>
07:19:08 <universa1> Axman6: yeah, though a unix one, so i tried that. 
07:19:18 <universa1> couldn't find a source package for mac os x
07:19:27 <Axman6> universa1: why not install one of the pre built binaries?
07:19:49 <Axman6> there is only one source package, and it should work on most *nix OS's
07:20:04 <quicksilver> yes, I was about to say
07:20:10 <quicksilver> there is only one source.
07:20:22 <quicksilver> However, installing GHC is a pain - and it won't work with your existing haskell platform.
07:20:24 <universa1> hmm, i've got xcode 4 installed, so the prebuilt ones don't work
07:20:42 <Axman6> ah yes, Xcode 4 breaks a lot of things -_-
07:20:44 <universa1> ahh, didn't scroll down far enough and didn't see it at the top :(
07:21:06 <absentia> XCACTUS4 is loveable.
07:21:59 <universa1> :-) need it for iphone dev ;)
07:22:38 <quicksilver> I thought 7.0.3 was supposed to work with XCode 4?
07:22:58 <universa1> gonna try
07:23:01 <quicksilver> release notes : GHC on OS X now works with XCode 4.
07:23:16 <quicksilver> however, you're going to be platformless and need to compile all the libs you want.
07:24:04 <Axman6> 7.0.3 workes with Xcode 4, but anything below that doesn't, and you need a previous GHC to compile 7.0.3
07:25:47 <Ke> wow, Xcode4 uses llvm
07:26:01 <Axman6> Xcode 3 did too
07:26:11 <Axman6> Apple have been using LLVM for quite a long time
07:27:16 <Ke> is that clang or llvm-gcc?
07:27:52 <ArnoVanLumig> on a somewhat related note, is there a proper way to get the latest haskell-platform in ubuntu?
07:27:55 <universa1> allright current platform + ghc 7.0.3 binary package seems to be working
07:28:08 <MasseR> ArnoVanLumig: Manually :P (at least I did)
07:28:20 <universa1> thanks a lot for the help guys :-)
07:28:21 <ArnoVanLumig> the latest version in ubuntu repos is 2010.1.0.0.1 :(
07:28:28 <MasseR> And install it somewhere else than /usr
07:28:43 <MasseR> By default it installs to /usr/local which is okay (for me at least, as it's in my path)
07:29:14 <ArnoVanLumig> okay, but then I should first get ghc 7 working
07:29:22 <Axman6> Ke: both. llvm-gcc is now the default compiler though
07:29:29 <MasseR> ArnoVanLumig: Just download the binary version
07:30:07 <ksf> http://embed.cs.utah.edu/csmith/
07:30:13 <ksf> anything like that in works for haskell?
07:30:27 <ksf> or do the ghc guys have enough bugs to care about as it is?
07:30:50 <ArnoVanLumig> MasseR: allright, I'll try that. Thanks
07:31:23 <ezyang> Prolly would be something useful to apply to Hoopl. 
07:40:51 <ArnoVanLumig> MasseR: Dit you get this error as well: "libgmp.so.3: cannot open shared object file: No such file or directory"?
07:41:07 <MasseR> ArnoVanLumig: Nope
07:42:03 <MasseR> But I believe that file is in libgmp3c2
07:42:23 <MasseR> (Btw I'm using LTS version of ubuntu)
07:42:55 <ArnoVanLumig> perhaps the problem is that I downloaded a 32bit ghc, while using 64bit ubuntu
07:43:34 <MasseR> Very much likely
07:43:35 <ArnoVanLumig> I'll just grab a 64bit ghc
07:55:43 <tamamonchi> hola
07:55:49 <tamamonchi> alguien habla espaÃ±ol
07:56:26 <tamamonchi> hello 
07:56:35 <tamamonchi> alguien habla espaÃ±ol
07:57:12 <Silvah> What the...?
07:57:42 <Eduard_Munteanu> tamamonchi: no, English in here. I don't know if there's a Spanish Haskell channel.
07:57:57 <tamamonchi> ok 
07:58:57 <araujo> haskell.es
07:58:58 <Silvah> What does that mean, anyway? "Does someone speak Spanish?"
07:59:04 <araujo> #haskell.es I mean...
07:59:11 <Eduard_Munteanu> I'm not sure, but I think so :)
07:59:27 <Eduard_Munteanu> He quit. :/
07:59:43 <araujo> ooh.. mm.. right, he did
07:59:44 <araujo> :P
08:00:07 <Lycurgus> i think it was just made (haskell.es)
08:00:32 <Lycurgus> because it wasn't in the channel list
08:00:50 <araujo> Lycurgus, not really, it is actually a very old channel :P
08:01:09 <Lycurgus> ah, good to know 
08:02:01 <Lycurgus> with 750 here, the handful there could have been gawkers
08:02:06 <Silvah> What a shame he quit, I wanted to respond "Nadie habla espaÃ±ol. Aber ich bin sicher, dass jemand spricht Deutsch."
08:03:28 <Silvah> Probably he'd understand me as well as I understood him.
08:06:06 <illissius> there's no way in TH to get the instance that automatic deriving would derive for something, and then transform it in some way before splicing it -- is there?
08:06:10 <ArnoVanLumig> Yay, I managed to install the latest haskell-platform :)
08:06:15 <Silvah> By the way, there's no #haskell.pl?
08:35:58 * Berengal throws his arms up in frustration, lights a fag, rolls up his sleves and writes a kludge
08:46:02 <dnasty> Heyy
08:46:18 <dnasty> Wowisgiafj
08:46:22 <dnasty> ?????
08:52:37 <Silvah> > fix error
08:52:38 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
08:53:51 <EvanR-work> fix error doesnt
08:54:13 <conal> EvanR-work: :)
08:55:29 <Silvah> Haskell is great, it can automatically fix errors :D
09:00:09 <rostayob> @hoogle Maybe a -> Bool
09:00:09 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
09:00:09 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
09:00:09 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
09:00:39 <aristid> > fix (error . ("doesn't "++))
09:00:41 <lambdabot>   "*Exception: doesn't *Exception: doesn't *Exception: doesn't *Exception: do...
09:01:36 <Silvah> @src fix
09:01:36 <lambdabot> fix f = let x = f x in x
09:01:59 <Silvah> Hm.
09:03:46 <Silvah> What is 'fix' useful for?
09:04:54 <rostayob> @pl \(userName, password) -> liftM isJust (checkLogin userName password)
09:04:54 <lambdabot> uncurry ((fmap isJust .) . checkLogin)
09:06:17 <monochrom> for recursion
09:06:43 <monochrom> see my http://www.vex.net/~trebla/haskell/fix.xhtml
09:08:43 <Jafet> > fix error
09:08:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:09:00 <Jonno_FTW> heheh
09:09:04 <pmetzger> Exceptional!
09:09:05 <EvanR-work> Silvah: i use it in place of explicit recursion so i dont have to name the recursive function
09:09:15 <EvanR-work> in many cases you dont want explicit recursion though
09:13:41 <lunaris> mfix is useful for constructing objects Â¬_Â¬
09:16:22 <ezyang> Hot off the press: http://blog.ezyang.com/2011/04/tracing-the-compilation-of-hello-factorial/ 
09:17:03 <lunaris> ezyang: Typo: an FP languages
09:17:21 <ezyang> fixed. 
09:17:27 <ezyang> Thanks! 
09:17:41 <lunaris> :)
09:19:47 <nlogax> are there any good beginners guides to category theory? i think i saw a "learn you a category theory" style tutorial, but it may have been a dream.. 
09:19:47 <lunaris> Additionally in the STG section you might want to capitalise "core" (now we convert core...)
09:19:52 <lunaris> But I'm a complete pedant.
09:20:14 <lunaris> nlogax: I've had http://www.scss.tcd.ie/Edsko.de.Vries/ct/catsters/linear.php recommended to me.
09:20:21 <lunaris> But yet to get the time to view them.
09:20:31 <ezyang> Nah, it's cool. 
09:20:41 <lunaris> ezyang: Nice article either way :)
09:20:53 <nlogax> lunaris: thanks :)
09:20:56 <ezyang> Yeah, I've been wanting to do something like this for a while. 
09:21:48 <lunaris> Also, you go from talking about C-- to Cmm (though I appreciate this is the name of GHC's implementation of C--)
09:22:13 <lunaris> But I'll stop being a git now.
09:22:35 <lunaris> nlogax: Don't thank me until you've seen them :) It'll take a while I imagine.
09:22:49 <nlogax> lunaris: yeah, thanks for the link anyway :D
09:25:15 <thomas231> hi
09:26:17 <shapr> guten tag thomas231
09:28:48 <monochrom> oh god, heap action in comic book format?!
09:29:24 <cheater> heap action?
09:29:28 <cheater> wat?
09:30:11 <ezyang> oh man, heap action :-) 
09:30:34 <the-J-thing> hi
09:30:51 <cheater> monochrom: url?
09:33:15 <Bfig> what is wrong with this line? i get unexpected token 'gt': > infixr 5 &gt;*&gt;
09:34:11 <c_wraith> ; isn't a valid operator character
09:34:14 <ezyang> Are oyou in ghci? 
09:34:29 <c_wraith> and for that matter, letters aren't valid operator characters, either
09:34:32 <Bfig> no, in Hugs
09:34:47 <c_wraith> Did you mean: infixr 5 >*> 
09:34:59 <c_wraith> don't use html entity escapes in haskell code. :)
09:35:02 <Bfig> ohh... i know what happened...
09:35:03 <Bfig> :p
09:35:06 <Bfig> exactly
09:35:13 <Bfig> ctrl+s in firefox :p
09:35:30 <Bfig> and for some reason this shit was in html instead of plaintext
09:36:19 <the-J-thing> swearing is BAD
09:36:41 <aristid> swearing SUCKS
09:36:45 <shapr> helvete!
09:37:04 <the-J-thing> ah en norsk jævel
09:37:37 <shapr> god morgon the-J-thing! Hur mÃ¥r du idag? Kan du tala funtionella sprÃ¥k?
09:37:56 <the-J-thing> Ikke på svensk
09:38:01 <shapr> :-P
09:38:11 <Lemmih> Er der OK at tale dansk nu?
09:38:16 <c_wraith> I think I'm in the wrong channel!
09:38:50 <the-J-thing> finnish
09:38:59 <shapr> minÃ¤ en puhu suomea
09:39:59 <Lycurgus> getting upset about swearing sucks
09:40:02 <the-J-thing> finnish the finnish. We speak English here
09:40:11 <shapr> How can I detect swearing with Haskell?
09:40:14 <shapr> @keal
09:40:14 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
09:40:48 <shapr> I wonder if Aarna Ranta's Grammatical Framework supports swearwords?
09:40:48 <c_wraith> @faq How can I detect swearing with Haskell?
09:40:49 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:39 <Lycurgus> especially "shit"
09:41:45 <cheater> shapr: what do you need from freescale?
09:42:24 <gwern> > (3.8 * 0.25) + 3.8
09:42:25 <lambdabot>   4.75
09:42:41 <shapr> cheater: I was just channeling the spirit of keal
09:44:28 <cheater> what is keal?
09:44:37 <zygoloid> @protontorpedo
09:44:37 <lambdabot> why haskell over lisp?
09:44:54 <ezyang> I need a sanity check: f 0 = 1; f n = n * f (n - 1) uses constant stack space, right? 
09:45:12 <monochrom> most likely not
09:45:23 <ezyang> > let f 0 = 1; f n = n * f (n - 1) in f 99999999 :: Integer 
09:45:25 <lambdabot>   *Exception: stack overflow
09:45:34 <ezyang> > let f 0 = 1; f n = n * f (n - 1) in f 99999 :: Integer 
09:45:36 <ezyang> :-( 
09:45:37 <lambdabot>   mueval-core: Time limit exceeded
09:46:36 <ClaudiusMaximus> > let f 0 = 1 ; f n = let m = n - 1 in m `seq` n * f m in f 999999 :: Integer
09:46:37 <lambdabot>   *Exception: stack overflow
09:46:44 <monochrom> if ghci doesn't tell you stack overflow, see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/87524/ for why
09:46:46 <ezyang> Though I believe it uses constant space if we compile with -O 
09:50:07 <ezyang> Hmm, the optimized version seems to stack overflow too. 
09:51:04 <ezyang> This is disappointing! :-( 
09:51:09 <Younder> Why is Num not a subclass of Ord?
09:51:36 <monochrom> because the Gaussian integers is not a subclass of Ord
09:52:01 <Jafet> :t undefined :: Complex Integer
09:52:01 <lambdabot> Complex Integer
09:52:04 <Younder> Gaussian intergers?
09:52:12 <luite> a+bi where a and b integer
09:52:14 <Jafet> Oh, this one works.
09:52:22 <Younder> ahh
09:53:30 <Jafet> :t undefined :: Complex Rational
09:53:31 <lambdabot> Complex Rational
09:53:42 <tromp_> Complex requires RealFloats
09:53:55 <tromp_> a questionable decision:(
09:54:10 <Younder> so because complex numbers are a tuple real values are not ordered
09:54:20 <Younder> duh
09:54:40 <Jafet> @index Complex
09:54:40 <lambdabot> Data.Complex
09:54:49 <Jafet> :t undefined :: Data.Complex Integer
09:54:49 <lambdabot> Couldn't find qualified module.
09:54:57 <Jafet> :t undefined :: Data.Complex.Complex Integer
09:54:58 <lambdabot> Complex Integer
09:55:07 <Jafet> Shouldn't this fail then
09:55:32 <lunaris> Jafet: The constraint is on the constructor (:+) I believe
09:55:48 <lunaris> > 1 :+ 2 :: Data.Complex.Complex Integer
09:55:49 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Type.Integer)
09:55:49 <lambdabot>    arising f...
09:56:00 <luite> Younder: you can order tuples of real values, but you can't satisfy the ordered field axioms with complex numbers
09:56:23 <lunaris> It's a proper old-school: data RealFloat a => Complex a = !a :+ !a I think.
09:56:35 <Younder> luite, true -1 * -1 = 1'
09:57:16 <Bfig> how can i convert a string to a float ?
09:57:28 <luite> well yes, but that's only a problem if you also mention that -1 = i^2 :p
09:57:39 <Jafet> Bfig: unsafeCoerce?
09:57:59 <tromp_> > read "0.4" :: Float
09:58:00 <lambdabot>   0.4
09:58:22 <Bfig> Jafet, not that kind of conversion :p
09:58:59 <Bfig> tromp_, how does that work?
09:59:27 <Bfig> i need to build a parser for polynomial expressions and i haven't understood anything so far
09:59:50 <tromp_> :t read
09:59:50 <lambdabot> forall a. (Read a) => String -> a
10:00:09 <Bfig> i have an unambiguous CFG but the parsers and build are impossible to understand
10:02:23 <tromp_> read up on class Read and maybe some parser combinator libraries
10:02:47 <Bfig> i've been trying to get how parser combinators work but i don't understand how the output combines
10:03:23 <Bfig> so now i tried a more hands-on approach, try to start parsing the most basic stuff, but i get type errors and such
10:03:36 <Younder> Have you tried the Natural Language Toolkit  for Haskell?
10:03:48 <tromp_> do you understand typeclasses yet?
10:04:02 <Bfig> i have a specific parsing library i have to use: http://www.fing.edu.uy/inco/cursos/progfunc/pmwiki/uploads/Main/ParseLib.hs
10:04:03 <tromp_> read something like http://learnyouahaskell.com/types-and-typeclasses
10:06:51 <Bfig> have you tried something like that library? ie, >*>, alt, etc? can you help me decipher how the parsers combine?
10:07:36 <Younder> Yes I have
10:07:42 <tromp_> no. sorry i don't have time to study it
10:08:34 <Bfig> Younder, can you explain to me how the parser outputs interact and where/how to use the build functions?
10:09:16 <Younder> well I can refer you to monads
10:09:27 <Bfig> this parsing library is non monadic
10:09:42 <Younder> no it isn't
10:10:10 <Younder> look closer
10:10:26 <Bfig> i said it wasn't...
10:11:36 <Lemmih> Are you guys talking about ReadP?
10:12:06 <Bfig> Lemmih, the parse library in the craft of functional programming
10:12:08 <Lemmih> Ah, ParseLib.
10:12:30 <Bfig> it is not monadic parsing ParseLib (ive seen one on the webs)
10:12:34 <Lemmih> Bfig: It is monadic. Younder meant to say 'no it is'.
10:12:52 <Bfig> the one i linked to is *not* monadic
10:13:15 <Bfig> http://www.fing.edu.uy/inco/cursos/progfunc/pmwiki/uploads/Main/ParseLib.hs
10:13:33 <Bfig> it is called the same that a monadic parsing library, but it doesn't have any monads
10:13:48 <Lemmih> Bfig: It actually does.
10:14:02 <Bfig> really? :S. where?
10:14:05 <Younder> my bad
10:14:29 <Lemmih> Bfig: (SParse a) is a monad.
10:14:42 <Bfig> Lemmih, did you even enter the link i gave?
10:15:06 <Bfig> ahh sparse
10:15:08 <Bfig> we don't use it
10:15:11 <Bfig> i've never saw that
10:15:26 <Younder> The older version is NOT monadic
10:15:27 <Lemmih> Bfig: SParse is just Parse with a different name.
10:16:22 <Bfig> but there are not any monads in the part i'm using
10:16:49 <Bfig> monads make the parsing parallel right?
10:16:54 <Lemmih> Bfig: It doesn't really matter that you don't use the Monad type-class. It still works the same way.
10:17:41 <Bfig> ok. i think i'm starting to get how it works. first of all i must parse the characters that are useful to me, then i need to build with those characters the type i want, right?
10:17:43 <Lemmih> Bfig: No. Monads just encapsulates a common way of combining things.
10:18:44 <Lemmih> Bfig: Right.
10:18:57 <Bfig> ie, say i want to parse a number, it is an optional '-' plus one or more digits, then i get a [Char] like "-342..." and i have to go from there to a Float
10:19:40 <Lemmih> > read "342" :: Float
10:19:41 <lambdabot>   342.0
10:22:48 <Lemmih> Bfig: It makes sense now?
10:23:44 <Bfig> somewhat more... how can i explicitly name the function that reads floats?
10:24:09 <Lemmih> iReadFloats :: String -> Float; iReadFloats = read
10:24:23 <Bfig> cool, thanks
10:25:34 <Younder> Well the string monad is way better than the list monad'
10:25:43 <danharaj> Hot damn. Reading Haskell papers not only teaches you new techniques, but also new words.
10:25:47 <danharaj> "Perspicuous"
10:26:15 <dmwit> String is not a monad.
10:26:20 <dmwit> It has the wrong kind.
10:26:32 <Younder> no it is a list
10:26:46 <dmwit> :k []
10:26:46 <lambdabot> * -> *
10:26:48 <Lemmih> Younder: [] is a Monad. [Char] is not.
10:26:49 <dmwit> :k String
10:26:49 <lambdabot> *
10:26:54 <dmwit> Younder: Notice a difference?
10:26:56 <Younder> and as a list it sucks
10:27:25 <pumpkin> o.O
10:28:08 <dmwit> Also, as Lemmih points out, I should have said "String is not a Monad.", since what the heck do I know -- maybe String could be interpreted as a functor for some wacky categories, and even a monad.
10:28:54 <danharaj> String itself can't be a functor. It could be canonically associated with a functor, maybe.
10:29:02 <danharaj> But String can't be a functor in itself.
10:29:19 <dmwit> [] isn't a functor in itself, either.
10:29:25 <danharaj> Sure it is.
10:29:33 <danharaj> Well, no you're right.
10:29:34 <pumpkin> [] and map is a functor
10:29:38 <danharaj> Yes that's right.
10:29:53 <pumpkin> it's hard to say half of that can't be half of a functor without showing that there cannot exist the other half such that it is a functor
10:29:55 <pumpkin> if that makes sense
10:30:25 <dmwit> Since I haven't even nailed down the categories yet, who are you to say String can't be a functor?
10:30:28 <danharaj> Well you have to interpret String as a morphism of types.
10:30:32 <dmwit> Yes.
10:30:38 <dmwit> err... no
10:30:39 <pumpkin> danharaj: you're too Hask!
10:30:45 <pumpkin> this could be any category
10:30:50 <pumpkin> who knows, some weird preorder category
10:30:53 <dmwit> You have to interpret String as a mapping between objects.
10:31:01 <danharaj> You still have to have a map from objects to objects.
10:31:09 <danharaj> and objects are pretty much types anyway.
10:31:15 <dmwit> Definitely not.
10:31:29 <danharaj> In the context of programming languages, they sure are.
10:31:58 * dmwit points out once again that he hasn't nailed down the categories, and therefore hasn't nailed down the context
10:32:00 <Younder> Want my help?
10:32:51 <dmwit> Anyway, this is a really silly argument.
10:33:01 <dmwit> I'm sorry I started it.
10:33:06 <Younder> right
10:33:13 <danharaj> You should know that the definition of category postulates that the collection of objects of a category is a set.
10:33:28 <danharaj> actually no that's wrong.
10:33:30 <danharaj> That's a small category.
10:33:31 <dmwit> danharaj: I thought only small categories had that property.
10:33:31 <danharaj> Nevermind.
10:33:51 <danharaj> I need my morning coffee.
10:34:10 <danharaj> I'm going to go get that right now.
10:34:19 <dmwit> ?localtime danharaj
10:34:30 <danharaj> 1:47 pm
10:34:32 <danharaj> don't judge me
10:34:35 <dmwit> haha
10:34:36 * pumpkin judges danharaj 
10:34:46 * hackagebot aeson 0.3.2.4 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.2.4 (BryanOSullivan)
10:34:46 <pumpkin> wow, I think we're all called dan
10:34:48 * hackagebot attoparsec 0.8.5.3 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.5.3 (BryanOSullivan)
10:35:07 <dmwit> High-five!
10:35:12 <pumpkin> yeah!
10:36:39 <Younder> fully functional
10:36:42 <Bfig> what's wrong with this: >convtoFloat (a(b(c,d)),e):xs = (a++b++c++d, e) : convtoFloat xs
10:36:42 <Bfig>  
10:36:51 <pumpkin> Bfig: you tell us
10:36:58 <Bfig> i get unexpected '('
10:38:24 <illissius`> Bfig: should try putting ()s around the full pattern match, incl. :xs
10:38:49 <Bfig> still error
10:38:51 <ksf> someone willing to help me along a bit?
10:39:05 <ksf> I can't figure out how to do stuff without re-writing half of openshake.
10:39:19 <illissius> Bfig: oh, right, a(b( etc. doesn't make much sense
10:39:21 <Bfig> ahh i think i saw it. no commas between a and,
10:39:22 <ksf> ...I'm trying to get a function askActRules :: forall ntop n. (n :< ntop, Namespace ntop) => Act ntop ([[RuleClosure n]]) , or equivalent.
10:39:23 <illissius> what did you intend?
10:39:42 <Bfig> yep. it's just combining all the stuff into a single string. i want to parse floats
10:40:09 <ksf> getting the data isn't the problem, making it fit into the namespace composition scheme is.
10:40:42 <ksf> ...as mapping ActEnv from one namespace to another seems to be quite impossible.
10:41:07 <ksf> ...considering that it carries along polymorphic MVars
10:41:32 <Lemmih> bos: How does that change to attoparsec affect aeson?
10:43:09 <Lemmih> Bfig: 'neList dig' will give you a list of digits.
10:43:24 <ksf> as to avoid the XY problem, I'm trying to get a list of rules from a custom namespace to then filter them for what I actually want (think globbing "cflags-*" and getting back "clags-freetype" and "cflags-editline"), so that I can then need them.
10:43:37 <Lemmih> Bfig: 'neList dig `build` read' will parse those digits.
10:44:11 <Lemmih> Bfig: myParser :: Parse Char Float; myParser = neList dig `build` read
10:44:23 <Lemmih> Bfig: Then you just have to parse the '-'.
10:45:03 <Bfig> Lemmih, thanks! it works perfectly
10:46:11 <Bfig> how do i 'resolve overloading'
10:46:14 <Bfig> :: float?
10:46:23 <Lemmih> Yes, :: Float
10:46:38 <Jafet> Not ReadS Float!?
10:46:39 <Lemmih> If you want Floats, that is.
10:46:52 <nathanfh> Is there a way to set the editor in ghci permanently? I've gotten fond enough of editing my code whilst in ghci that entering ":set editor vim" every session is becoming a chore.
10:47:04 <Jafet> Add that to ghci.conf
10:47:16 <Lemmih> Bfig: Where do you want to resolve overloading, exactly?
10:47:26 <Bfig> in the read i guess
10:47:39 <dmwit> ksf: I don't know about anything else, but I have no clue what you're talking about.
10:47:39 <moisan> Hi, I'm looking for a function to calculate variance on a list, is there anything standard existing?
10:47:56 <ksf> dmwit, rejoice!
10:48:01 <Lemmih> Bfig: Just give your parser a type. You really wanna type those things explicitly anyway.
10:48:10 <ksf> consider this as the perfect chance to read some advanced haskell.
10:48:11 <Bfig> ok
10:48:52 <bos> Lemmih: fixed a floating point parsing bug
10:48:56 <dmwit> moisan: I know criterion does a lot of statistics; have you looked at what packages it uses for that?
10:49:00 <roconnor_> cereal appears to be better than binary in almost every way
10:49:08 <monochrom> nathanfh: use environment variable EDITOR
10:49:34 <dmwit> See also: VISUAL
10:49:35 <ksf> I, at least, came to the conclusion that max is too good of a programmer for his own sake.
10:49:58 <dmwit> VISUAL=gvim; EDITOR=vim
10:51:03 <moisan> dmwit : it is using the statistics package but I can't find the variance/means functions in it
10:51:08 <Lemmih> roconnor_: I wish it could return partial results like attoparsec.
10:51:33 <roconnor_> Lemmih: partial results?
10:52:29 <bos> moisan: http://hackage.haskell.org/packages/archive/statistics/0.8.0.5/doc/html/Statistics-Sample.html
10:52:43 <dmwit> moisan: http://hackage.haskell.org/packages/archive/statistics/0.8.0.5/doc/html/Statistics-Distribution.html#t:Mean
10:53:18 <Lemmih> roconnor_: Say you have parser that requires 8 bytes but you only give it 4. Attoparsec deals with that by returning a parser that takes additional input to give you the value.
10:53:46 <roconnor_> should I use Attoparsec instead?
10:53:54 <ksf> why does every single project I lay my eyes on require a rewrite to do what I want?
10:53:54 <moisan> bod dmwit : thanks a lot, now I have lists, how do I switch them to vectors?
10:54:13 <roconnor_> ksf: because they are not written in Haskell?
10:54:13 <dmwit> Oh, no instance of Distribution for samples? Why not? Any sample defines a perfectly good distribution...
10:54:23 <ksf> they *are* written in haskell.
10:54:31 <roconnor_> :(
10:55:21 <bos> dmwit: patches welcome :-)
10:55:22 <dmwit> moisan: A couple seconds in the documentation for the vector package will answer that question.
10:55:23 <ksf> but there's just things that can't reasonably be functorised, like mvars.
10:55:26 <Lemmih> roconnor_: I think attoparsec and cereal solves different problems.
10:55:37 <dmwit> moisan: (I know it to be true because I checked.)
10:55:39 <dmwit> bos: =)
10:56:00 <ksf> the main problem with the openshake code as I see it is that construction of the rules and execution aren't cleanly separated.
10:56:12 <roconnor_> wow
10:56:16 <roconnor_> monads are awesome
10:56:19 <roconnor_> Wadler was right
10:56:21 <ksf> that mvar I'm stumbling over while trying to construct a rule is actually needed during execution, only.
10:56:41 <moisan> dmwit : yeah I checked before asking but couldn't find it
10:56:44 <pumpkin> roconnor_: you have seen the light!
10:56:51 <dmwit> moisan: Where did you look?
10:57:02 <roconnor_> Cereal uses a different Get monad than Binary
10:57:10 <moisan> http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector-Generic.html#t:Vector
10:57:18 <roconnor_> but because I mostly stick to the same monad combinators, most of my code still complies
10:57:24 <roconnor_> even if the underlying monad has changed
10:57:29 <bos> moisan: you need to choose a specific vector type
10:57:34 <pumpkin> roconnor_: yeah!
10:57:36 <pumpkin> narwhals too
10:57:36 <bos> the Generic module doesn't do that for you
10:57:42 <dmwit> Yep, what bos said.
10:57:46 <moisan> bos : ok, I want double but my list is one of Int
10:57:59 <dmwit> moisan: No, a specific *vector* type, not a specific element type.
10:58:20 <dmwit> moisan: (And in fact, that specific type should be Vector, since that's what the statistics package expects.)
10:58:20 <bos> moisan: you have to choose Data.Vector.Vector or Data.Vector.Unboxed.Vector
10:58:56 <wharzl> what general algorithms are more powerful than unifications?
10:58:58 <moisan> kk, let's say I got with Data.Vector.Vector, how do I construct one with my list
10:59:02 <Kaidelong> Yesod, Happstack, or Snap?
10:59:02 <wharzl> *unification
10:59:15 <Kaidelong> the fact that there is a "Yesod book" seems promising
10:59:31 <dmwit> moisan: Read the documentation for Data.Vector.
11:00:31 <moisan> bod dmwit : found it, thanks a lot
11:00:49 <dmwit> In fact, the answer was even *on the page you linked us to*.
11:01:13 <moisan> dmwit : damn I feel stupid
11:03:25 <roconnor_> @type either fail
11:03:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> m a) -> Either String b -> m a
11:04:30 <roconnor_> @type either fail return
11:04:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
11:05:37 <dmwit> ew
11:06:02 <roconnor_> ew?
11:06:16 <dmwit> :t either strMsg return
11:06:17 <lambdabot> forall b (m :: * -> *). (Error (m b), Monad m) => Either String b -> m b
11:06:41 <wharrgarbl> > fix fail
11:06:43 <lambdabot>   ""
11:06:48 <wharrgarbl> > fix show
11:06:48 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:06:55 <dmwit> :t either (throwError . strMsg) return
11:06:56 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m, Error a) => Either String a1 -> m a1
11:07:11 <wharrgarbl> > fix (either (throwError . strMsg) return)
11:07:14 <lambdabot>   mueval-core: Time limit exceeded
11:07:30 <roconnor_> is IO an instance of MonadError?
11:07:40 <dmwit> Yes, with IOException as the Error.
11:07:53 <roconnor_> I'm okay with that too
11:08:27 <roconnor_> @hoogle strMsg
11:08:28 <lambdabot> Control.Monad.Error.Class strMsg :: Error a => String -> a
11:11:56 <roconnor_> joinIOError :: IO (Either String a) -> IO a
11:11:57 <roconnor_> joinIOError x = x >>= either (throwError . strMsg) return
11:11:59 <roconnor_> dmwit: good?
11:12:20 <dmwit> roconnor_: <3
11:13:27 * dmwit dreams of a day when Haskell' eliminates fail
11:13:28 <roconnor_> Perhaps I should be handleing these errors more carefully
11:13:30 <roconnor_> but for now
11:17:45 * byorgey fries lambda bacon
11:24:52 <Bfig> i *almost* managed to parse a float in its entirety
11:25:21 <Bfig> Lemmih, thanks for all the help
11:25:37 <roconnor_> dmwit: it seems the only way to access failure for Serialize.Get is through fail :(
11:27:24 <Bfig> Lemmih, thanks for all the help
11:27:30 <Bfig> sorry ww.
11:27:37 <Bfig> yes! i did it :p
11:36:45 <FUZxxl> @protontorpedo
11:36:46 <lambdabot> why would u write a interpreter for perl in haskell?
11:36:50 <FUZxxl> @protontorpedo
11:36:51 <lambdabot> how does haskell do with large systems?
11:36:58 * hackagebot split 0.1.4 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.4 (BrentYorgey)
11:37:16 <FUZxxl> @help protontorpedo
11:37:16 <lambdabot> protontorpedo is silly
11:38:20 <dmwit> roconnor_: aww =(
11:39:27 <Kaidelong> I take it protontorpedo was a troll
11:39:32 <dmwit> yes
11:39:36 <roconnor_> dmwit: maybe it should be an instance of MonadError
11:39:45 <Bfig> how can i incorporate to my parsing reading from variables? i assume this has to do with monads?
11:40:02 <byorgey> dmwit: just uploaded split-0.1.4 with your patch.
11:40:12 <dmwit> byorgey++
11:40:26 <Bfig> ie, say i have a variable memory of type [[Float]] and i want to know what's inside one of those while i'm parsing
11:40:28 <Twey> What was the patch?
11:40:35 <dmwit> Now that split >= 0.1.4 in my .cabal is actually right. =D
11:40:44 <Jafet> Man, getDirectoryContents produces utf-8 encoded FilePaths on linux.
11:41:02 <dmwit> Twey: Just an additional function: splitPlacesBlanks.
11:41:06 <Twey> Jafet: Does it really, or does it just return whatever the filesystem uses?
11:41:18 <Twey> dmwit: :t splitPlacesBlanks
11:41:43 <dmwit> splitPlacesBlanks :: [Int] {- lengths to split the next list at -} -> [e] -> [[e]]
11:41:44 <Jafet> Twey: yes.
11:41:51 <Twey> Aha, neat
11:42:02 <dmwit> There was already a splitPlaces with the same type.
11:42:04 <Twey> (to both)
11:42:04 <Jafet> I guess I can hack in an extra decoding step.
11:42:24 <Twey> Oh
11:42:38 <dmwit> Mine just behaves differently when there first list asks for more elements than the second list has.
11:42:41 <Twey> Not so neat.  I see what you mean now.
11:43:14 <Twey> dmwit: Pads with blanks?
11:43:18 <dmwit> right
11:43:49 <dmwit> splitPlaces [1,2,3] [] = []; splitPlacesBlanks [1,2,3] [] = [[], [], []]
11:43:52 <zygoloid> Jafet: are you sure it's utf-8, rather than "just whatever 8-bit junk is in the filesystem"?
11:44:10 <Twey> zygoloid: 195459 < Twey> Jafet: Does it really, or does it just return whatever the filesystem uses?
11:44:16 <Twey> zygoloid: 195537 < Jafet> Twey: yes.
11:45:45 <Jafet> linux uses utf-8, so again the answer is yes
11:46:10 <zygoloid> Jafet: not so fast. linux uses no specified encoding. convention dictates that we use utf-8.
11:46:23 <zygoloid> (at least, that was the status quo last time i knew about it)
11:46:29 <universa1> evening: haven't used haskell in a while and i just "copied" together a simple stdin/stdout wrapper for sanitize-xss. just a quick check that i didn't do something totally stupid
11:46:30 <universa1> http://hpaste.org/45661/simplest_sanitizexss_stdinst
11:47:36 <zygoloid> there's a simple proof that linux does not use utf-8: create two files with different normalized forms of the same name
11:48:11 <universa1> zygoloid: filename?
11:48:22 <ion> > "Ã¤" == "aÌˆ"
11:48:23 <lambdabot>   False
11:49:55 <ion> > text $ map toUpper "ÃŸ"
11:49:56 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
11:50:45 <ion> â€œUsingâ€ Unicode can mean many things.
11:50:49 <Jafet> linux is a convention!
11:51:04 <Silvah> Linux?
11:51:11 <Jafet> ...not to be confused with linux conventions
11:51:40 <Silvah> (no Linux bashing this time, sorry for inconvenience)
11:52:01 <ksf> capital eszett is a major pain
11:52:19 <ksf> mostly due to idiots not accepting a seperate capital version
11:52:49 <FUZxxl> ksf: AFAIK, there is a captial ÃŸ
11:52:55 <ksf> just because a character doesn't appear at the front of a word doesnt' mean it doesn't make sense to have a capital version
11:53:05 <ksf> in unicode and most fonts, yes.
11:53:12 <ksf> the DUDEN doesn't seem to have noticed.
11:53:33 <FUZxxl> ksf: It's rather inofficial.
11:53:49 <ksf> well, the duden has no authority over me, either.
11:54:26 <ksf> it's only relevant when the administration publishes something in standard german
11:54:42 <ksf> ...or when you happen to be a pupil.
11:55:05 <aristid> > toUpper 'ÃŸ'
11:55:06 <lambdabot>   '\223'
11:55:13 <aristid> > 'ÃŸ'
11:55:14 <lambdabot>   '\223'
11:55:30 <aristid> wait, there IS an uppercase variant of ÃŸ: áºž
11:55:43 <aristid> > 'áºž'
11:55:44 <lambdabot>   '\7838'
11:55:45 <ksf> for all I'm concerned, I can write Å¿z if I so please.
11:55:55 <FUZxxl> STRAáºžE StraÃŸe
11:56:05 <FUZxxl> ksf: :)
11:56:16 <ksf> which is nice, because STRASSE is definitely pronounced differently.
11:56:50 <ksf> I'd prefer sz for ß instead of ss, exactly because of that.
11:57:16 <ksf> Å¿ isn't particularly antiqua-ish, after all.
11:57:22 <Kaidelong> sz would be more sensible
11:57:27 <ion> toUpper :: Char â†’ Char is a bit of an oxymoron as a type.
11:58:24 <ksf> cf. wachstube and wachÅ¿tube
12:00:13 <Jafet> Hm, I can't convert the 8-bit paths either, because readFile won't accept them...
12:00:55 * ksf thinks long-s should be reintroduced again.
12:01:36 <christo_m> if im creating a symbol table for a dynamically typed language. should i be keeping variable type as a record in my symbol table?
12:02:16 <FUZxxl> \me thinks we should all write SÃ¼tterlin
12:02:29 * FUZxxl thinks we should all write SÃ¼tterlin
12:06:10 <ksf> cursives are great when it comes to learn the motor skills necessary to handwrite, but sucks as an actual handwriting.
12:06:49 <Jafet> I forget the last time I wrote anything
12:07:16 <aristid> Jafet: paper for notes can be more efficient than a computer.
12:07:25 <aristid> but i'd use block letters for that.
12:07:38 <Jafet> For text, org-mode and artist-mode are usually sufficient
12:07:46 <Twey> ksf: How so?
12:07:52 <Jafet> I do make paper drawings.
12:07:53 <ksf> writing block letters without having understood cursive is bound to be either ugly, slow or both.
12:08:01 <Twey> Cursive handwriting is faster than taking the pen off the paper all the time
12:08:08 <grai> 'wc
12:08:17 <ksf> well, no. by taking the pen off, you can shorten some paths.
12:08:22 <aristid> ksf: i have learned cursive in school, but i prefer block letters anyways.
12:08:49 <Twey> ksf: Yes, but taking the pen off, aiming it correctly, and replacing it is probably slower than doing the extra movement
12:08:55 <ksf> I've learned cursive, too (we never learned block letters), and then developed my own script over the years.
12:08:59 <aristid> Twey: no, the aim is automatic.
12:09:17 <Twey> aristid: Of course it is.  So are the paths.  That doesn't mean it doesn't take time.
12:09:21 <ksf> I've got a quite large amount of ligatures.
12:09:25 <FUZxxl> I usually use block letters, but they start to melt into a single line as I get tired or have to write faster.
12:09:29 <ksf> er, for example, or tr.
12:09:34 <aristid> Twey: well, for really fast writing, computers are hard to beat
12:09:35 <ksf> (with different forms for the r)
12:09:41 <Twey> aristid: Agreed
12:09:51 <Twey> Keyboard input is much more efficient than handwriting for English
12:09:56 <FUZxxl> ksf: Also have tz?
12:10:03 <Twey> Hm, though, having said that
12:10:08 <ksf> usually not.
12:10:15 <Twey> That's probably an issue with our writing systems
12:10:18 <ksf> but in prinziple it should be one, yes.
12:10:19 <aristid> Twey: handwriting is more useful for short notes, where writing speed does not matter all that much, and somehow it is easier for me to use block letters
12:10:32 <Twey> The keyboard input world record is about 200 WPM; the shorthand record is 350
12:10:44 <Twey> 216 WPM
12:11:13 <ksf> shorthand /= cursive /= block letters.
12:11:19 <aristid> Twey: well our writing-system may suck for fast writing, but it made designing typewriters and computers a whole lot easier :)
12:11:28 <aristid> ksf: yes, of course.
12:11:34 <ksf> though mine stops just short of a shorthand when it comes to speed.
12:11:48 <ksf> part of its design specs included "readable for teachers"
12:11:52 <Cin> My grandad's shopping lists look like works of art.
12:12:19 <Twey> aristid: That's not really the point
12:12:47 <aristid> Twey: i was not arguing your point, but adding a tangential point
12:12:49 <Twey> You can come up with a system with few glyphs that is more nevertheless much efficient to write than Latin
12:12:52 <Twey> Okay
12:13:06 <aristid> how would such a system look?
12:13:20 <Twey> Then I agree, but you need to specify your point of reference (which, in this case, is probably something like Chinese, I suspect)
12:13:33 <aristid> yes.
12:13:35 <Twey> aristid: I don't know; anything with simpler characters
12:13:44 <ksf> have a look at korean
12:13:44 <aristid> writing chinese by hand is probably pretty fast
12:13:53 <Twey> It's not
12:13:56 <aristid> hmm
12:14:15 <Martty> korean is
12:14:17 <Twey> Simplified is faster than traditional, but the stroke count is still high
12:14:19 <aristid> Twey: if you can write a whole word with a single character, i thought that might be fast
12:14:22 <ksf> http://www.asien-zuhause.ch/Korea_Allgemein/Bilder/Hangul3.jpg
12:14:36 <Martty> ksf: í•œêµ­ì‚¬ëžŒì´ì—ìš”?
12:14:39 <Twey> aristid: Most words are two characters, and each character is composed of roughly the same number of strokes as a short English word
12:14:46 <ksf> you can probably optimise the strokes, there.
12:15:48 <aristid> Twey: so both chinese and latin are inefficient. why didn't these writing systems reach better equilibria?
12:15:59 <Twey> They never needed to, I imagine
12:16:20 <Twey> Until recently, rapid text input has not been a concern
12:16:51 <aristid> nor rapid reading
12:16:54 <Twey> Right
12:16:57 <FUZxxl> æˆ‘ä¸æœƒçœ‹éŸ“æ–‡
12:17:04 <Twey> Reading is much less of a problem than writing
12:17:15 <Bfig> sweet, can parse monomials already :(
12:17:17 <Bfig> :)*
12:18:01 <aristid> Twey: it's amazing how much faster we read today, tho. back when there were no spaces between words, and other complications, reading was probably done quite a bit slower
12:18:18 <aristid> Bfig: what are monomials? :)
12:18:24 <Twey> FUZxxl: You probably lack fonts
12:18:38 <burp> aristid: what's wrong with latin?
12:18:42 <Twey> aristid: Probably
12:18:42 <Bfig> now a [Float] with all values in 0 except one, which is the coef
12:18:53 <Twey> Though, possibly not
12:18:55 <aristid> burp: latin used to be written without word spacing
12:19:15 <aristid> Twey: well, i read that it was custom to read texts aloud. which is also slow.
12:19:19 <Twey> Lots of languages are written without word-spacing, and in most cases it's not really a problem; the brain is quite good at discerning word endings
12:19:25 <FUZxxl> Twey: I just don't understand korean, that's all.
12:19:55 <Twey> FUZxxl: Oh, okay.
12:20:07 <aristid> tweythatsprobablyanissuewithourwritingsystems
12:21:06 <Twey> aristid: How so?
12:21:39 <aristid> Twey: that was a quote, just for demonstration purposes.
12:21:42 <burp> when you use word-spacing you can even mix up all letters within one word (keeping first and last) and the brain can understand it
12:21:52 <Twey> aristid: Oh, okay.
12:22:00 <Twey> burp: That is false
12:22:03 <aristid> Twey: _you_ said these words, albeit with spacing :)
12:22:11 <burp> Twey: for me it works
12:22:12 <Twey> aristid: Yes, I did
12:22:19 <Twey> burp: It works for some words
12:22:51 <aristid> Twey: those systems that retain spaceless writing to these days usually have writing systems where each word is only one or two symbols :)
12:23:06 <aristid> Twey: discerning word borders is trivial if each word is short
12:23:19 <ksf> korean is at least as sensible as tengwar
12:23:25 <ksf> ...and tengwar is a true bugger to write.
12:23:31 <ksf> everything looks the same.
12:24:10 <Twey> aristid: Yes
12:24:28 <ksf> word boundaries are always in flux in virtually every language, anyway.
12:24:50 <ksf> quite a lot are quite synthetic, and practically none is non-synthetic.
12:24:50 <aristid> wordboundaries are always influx in virtually every language, any way.
12:24:54 <Twey> burp: â€˜Sehepâ€™ is pretty simple to figure out.  â€˜Vgaaietoirnâ€™ is harder.
12:25:10 <ksf> yep.
12:25:15 <ksf> "influxity" is a nice word.
12:25:29 <Twey> ksf: Languages are always in flux in general
12:25:32 <aristid> > permutations "Vgaaietoirn"
12:25:33 <lambdabot>   ["Vgaaietoirn","gVaaietoirn","agVaietoirn","gaVaietoirn","aVgaietoirn","Vag...
12:25:46 <Twey> I don't think word boundaries change as much as some things
12:25:46 <aristid> hmm.
12:25:48 <nyingen> @src permutations
12:25:48 <lambdabot> Source not found. You untyped fool!
12:25:56 <aristid> now to compare these against a dictionary.
12:26:02 <aristid> or just ask Twey.
12:26:02 <Twey> Heh
12:26:04 <Kaidelong> he defined it
12:26:09 <ksf> , dict
12:26:11 <nyingen> oh, right
12:26:12 <ksf> @bot
12:26:12 <lambdabot> :)
12:26:14 <aristid> Twey: what is Vgaaietoirn?
12:26:14 <ksf> grrr
12:26:17 <Kaidelong> the way I tend to do it is rotations concatenated to the rotations of their tails
12:26:20 <ksf> > dict
12:26:21 <lambdabot>   Not in scope: `dict'
12:26:29 <burp> Twey: um, it's very hard for me, as english is not my native language :>
12:26:34 <nyingen> On my own lambdabot I implemented a version of @src that outputs defs from L.hs
12:26:39 <ksf> someone killed lunabot and didn't teach lambdabot /usr/share/dict to relpace her.
12:26:40 <Twey> â€˜Vieanoigrtasâ€™ would have been even harder
12:26:49 <nyingen> but we don't have something like that here?
12:26:53 <Twey> burp: It's hard for natives, too; see aristid's attempt above
12:27:07 <Jafet> burp: aceeelmnoprtux
12:27:10 <Twey> aristid: â€˜Variegationâ€™
12:27:16 <ksf> that's a word?
12:27:19 <aristid> lol
12:27:20 <burp> lol, I read tux
12:27:24 <aristid> Twey: i'm not native.
12:27:31 <Twey> Oh, okay.
12:27:37 <Twey> Well, you'll have to take my word for it, then. ;)
12:27:39 <ksf> ie seems to be particularily un-english
12:27:39 <Jafet> Heh, lmnop
12:27:41 <aristid> never heard the word Variegation
12:27:48 <aristid> @wn Variegation
12:27:49 <lambdabot> *** "variegation" wn "WordNet (r) 2.0"
12:27:50 <lambdabot> variegation
12:27:50 <lambdabot>      n 1: variability in coloration
12:27:50 <lambdabot>      2: the act of introducing variety (especially in investments or
12:27:50 <lambdabot>         in the variety of goods and services offered); "my broker
12:27:51 <lambdabot> [3 @more lines]
12:28:10 <aristid> wtf
12:28:40 <Twey> The point is that it's: â€” a long word; â€” that most people won't expect to encounter
12:28:42 <burp> Jafet: what is aceeelmnoprtux?
12:29:05 <burp> Twey: ok, let's say it works for the most common words used :>
12:29:09 <Twey> With the plural, also that the final letter doesn't convey very much useful information any more, since -s is a very common final.
12:29:19 <burp> hm, true
12:29:40 <aristid> > map (\x -> 'a' : x ++ "x") $ permutations "ceeelmnoprtu"
12:29:42 <lambdabot>   ["aceeelmnoprtux","aeceelmnoprtux","aeecelmnoprtux","aeecelmnoprtux","aecee...
12:29:57 <Jafet> > text $ sort "counterexample"
12:29:58 <lambdabot>   aceeelmnoprtux
12:30:03 <burp> haha
12:30:05 <Kaidelong> cryptomonad is a longer word
12:30:13 <aristid> Jafet: that does not abide by the rules.
12:30:24 <aristid> Jafet: first and last characters are supposed to be retained in position
12:30:27 <Jafet> > "c" ++ sort "ounterexampl" ++ "e"
12:30:29 <lambdabot>   "caeelmnoprtuxe"
12:30:34 <burp> easy now :P
12:30:36 <Jafet> Not that you'd figure that one out either.
12:30:48 <aristid> Jafet: why? it's easy: counterexample
12:31:43 <burp> "baaahnnnope"
12:32:44 * ksf found an easy, but also lame way to get openshake to do a thing similar to what I want
12:33:07 <Twey> Do we have nice composable SSL yet?
12:33:29 <c_wraith> what's http-enumerator using for ssl?
12:34:18 <burp> TLS
12:35:10 <aristid> @hackage tls
12:35:10 <lambdabot> http://hackage.haskell.org/package/tls
12:35:36 <aristid> (the link works :P)
12:35:40 <Twey> <Â« Do not yet use as replacement to more mature implementation. Â»  â€” Like what?  >.>
12:36:07 <aristid> http-enumerator uses it anyways.
12:36:17 <Heffalump> like a C binding to OpenSSL?
12:36:44 <c_wraith> the existing bindings to OpenSSL are a great way to segfault.
12:37:37 <Heffalump> they're unlikely to cause crypto bugs though
12:38:05 <ksf> no, that doesn't work.
12:38:05 <c_wraith> depends on if you consider crashing the service a crypto bug :)
12:38:27 <TomMD> Vincent's work on crypto{cipher,hash} goes a long ways to letting you not use OpenSSL for basic tasks.
12:39:06 <Heffalump> TomMD: how much security auditing has it had
12:39:10 <Heffalump> ?
12:39:23 <TomMD> Haffalump: Not much, really.
12:40:31 <TomMD> But much of the crypto code is borrowed/bindings of BSD C sources.  You'd need to investigate those on a case by case basis, but I'm guessing that code has seen review outside the Haskell community.
12:41:21 <Bfig> yes! i'm almost finished with the parser...
12:41:32 <thoughtpolice> TomMD: cryptohash is mostly bindings to fast C libraries, but cryptocipher is all pure haskell
12:41:48 <thoughtpolice> (i used vincent's RC4 implementation as a model to check against when I wrote my own RC4 implementation last week or so)
12:42:13 <thoughtpolice> come to think of it, i need to add like 10 more sets of test vectors before levent can merge it into sbv
12:42:18 <TomMD> thoughtpolice: For now, yes.  I'm hoping to get him to switch to Gladmans AES.
12:43:12 <TomMD> thoughtpolice: I suppose it doesn't matter given the intel-aes package.  It's just that the cryptocipher AES doesn't perform well (last I benchmarked)
12:43:25 <Bfig> i need one final thing to finish the parser: how can i use memory? i need to manage some memory in my program, so far i haven't seen how i could
12:44:14 <merijn> Bfig: What do you mean by "I need to manage some memory"?
12:44:45 <thoughtpolice> TomMD: yeah. i've been interested in using SBV to write crypto stuff lately, I was really surprised yices could show my rc4 implementation's 'decrypt . encrypt == id' proposition. the fact you can extract fast C code is also a plus
12:45:12 <Bfig> merijn, i need to hold a list with values of type [Float], which will be modified/read from the haskell command line
12:45:15 <thoughtpolice> (i think levent benchmarked his simple AES implementation, when compiled to C via sbv, was only about 20% slower than OpenSSL's implementation, which is pretty good considering he just wrote a simple version in haskell that was correct)
12:45:23 <TomMD> thoughtpolice: Yes, I saw that.  Awesome work.
12:45:57 <TomMD> That is news to me.  We should package it!  DRBG needs a good AES impl that doesn't require a C library.
12:46:00 <Bfig> merijn, i start the program, input commands, the program has local memory that saves what i'm doing, then i input an 'exit' command and the program ends
12:46:04 <TomMD> (an external C library)
12:46:14 <thoughtpolice> TomMD: my RC4 implementation however, results in a rather large C file (250kLOC.) i think it needs some cajoling to get the code generation to be more sensible
12:46:26 <thoughtpolice> (which you often have to do, levent told me)
12:46:44 <Bfig> merijn, ie, a command line where i say: >> P = x3 + 1; Q = 3+P; A = P/Q; exit
12:46:47 <TomMD> I need to learn SBV / follow this more closely.  Perhaps this summer.
12:47:04 <thoughtpolice> TomMD: http://hackage.haskell.org/packages/archive/sbv/0.9.18/doc/html/Data-SBV-Examples-Crypto-AES.html#g:18
12:47:11 <thoughtpolice> see the comments for 'cgAES128Library'
12:47:13 <Bfig> merijn, this is in a single line, but i must be able to save the state between each command
12:47:19 <merijn> Bfig: That then parses it line for line, stores it in that list and outputs it at the end?
12:47:29 <thoughtpolice> also note that levent's simple implementation in SBV is for 128bit key sizes
12:47:29 <Bfig> merijn, and in the middle
12:47:49 <Bfig> merijn, let me pastebin a possible flow
12:48:55 <thoughtpolice> TomMD: I'm thinking of writing some intros/tutorials to using it (sbv.) and if you do anything with it, let levent know! he's really interested and excited by what people do with it, he was pretty surprised I got so far in my RC4 implementation actually, considering there's not so much tutorial-style documentation
12:50:04 <TomMD> thoughtpolice: Shoot me a link if/when you get the tutorial.  I'm 120% busy (yet on IRC, I know!) till mid May, but will play with SBV afterwards.
12:51:13 <Bfig> merijn, http://pastebin.com/QUz0XbNf
12:53:38 <Bfig> so far i've thought about a possible way, consisting in rewriting the parsing library to allow me to inject context information to read the variables. but i bet there must be a more elegant way to do it
12:54:06 <merijn> Bfig: You probably want to do something like: http://hpaste.org/45662/memory
12:54:13 <merijn> Unless I misunderstand?
12:55:23 <merijn> (Replacing [Float] with whatever relevant state you have and providing a "parseInput" which parses your string into a list and a "stopCommand" function which checks for for example "exit")
12:55:28 <merijn> You get the idea, I hope
12:56:11 <Bfig> merijn, i think that's exactly what i want to do
12:56:30 <Bfig> merijn, but how can i access state within the parse algorithm?
12:56:45 <mm_freak> Bfig: i think you want a state monad on top of your parser
12:57:09 <mm_freak> Bfig: if you're using parsec, just use the transformer variant of the parser monad
12:57:27 <c_wraith> Doesn't parsec have state integrated into it, anyway?
12:57:35 <mm_freak> indeed
12:57:38 <Bfig> mm_freak, how does that work? i'm using this library: http://www.fing.edu.uy/inco/cursos/progfunc/pmwiki/uploads/Main/ParseLib.hs, and not the monad part. but if the monad part works, would you explain how ?
12:57:45 <merijn> Oh, if you want to access state in the parse algorithm you could do "parseInput input state" rather then "parseInput input" or did you mean add to the state inside the parseInput function. If you meant the latter (modify state inside the parser) you probably want something like the State monad
12:58:18 <mm_freak> Bfig: first of all get yourself started with monadic parsing
12:58:28 <Bfig> merijn, no, the first one, but i want to avoid modifying the library if possible
12:58:43 <Bfig> mm_freak, i have to use this library, school project.
12:58:55 <mm_freak> Bfig: you have to?
12:59:16 <Bfig> well, i don't *have to* i think... but i already wrote all the parsing algorithm for this library
12:59:44 <mm_freak> Bfig: if you have a two or three hours take the time to learn monadic parsing
12:59:44 <Bfig> it works perfectly except i can't read the variables from the middle of the expresion input
12:59:48 <mm_freak> it definitely pays off
13:00:14 <mm_freak> you'll find that there has been a much more elegant solution ready to use
13:00:47 <Bfig> mm_freak, would you mind checking the very last part of the library? is that what you are talking about?
13:01:52 <Bfig> i don't understand what that monad does
13:02:17 <mm_freak> Bfig: well, it's a monadic interface to the raw parsing library you quoted
13:02:17 <merijn> The state monad?
13:02:31 <mm_freak> Bfig: with monadic parsing you can write something like this:
13:02:34 <Bfig> merijn, the monad at the end of my library
13:02:52 <merijn> ah
13:02:54 <mm_freak> do char '('; x <- someValueParser; char ')'; return (ValueInParens x)
13:03:17 <mm_freak> (there are nicer ways to write that, but don't worry about that for now)
13:04:19 <Bfig> i am barely familiar with monads, i just have logged an estimated time of about 40 hours of haskell coding
13:04:29 <Bfig> of coding/learning
13:04:58 <Bfig> i still don't understand monads :p
13:05:09 <merijn> Bfig: Ah, have you read Learn You a Haskell?
13:05:10 <mm_freak> Bfig: well, there isn't much to monadsâ€¦  in very simple terms it allows you to write expressions using this 'do' syntax
13:05:32 <merijn> Bfig: It has several quite understandable explanations
13:05:37 <mm_freak> (and 'do' is just syntactic sugar for a set of combinators, but again, don't worry about that)
13:06:08 <mm_freak> Bfig: whenever you're writing code to do some I/O you're writing monadic code =)
13:06:21 <filius> Hello! I have a list of words, and I want to extract the surrounding words of a particular word (say 3 words before and 3 words after), and put these into a new list. Is there a smart way of doing this without using index?
13:06:50 <Bfig> i read the combinators but i don't understand yet how this makes anything less 'functiony'
13:07:10 <Bfig> the only thing i have read that barely resembles imperative programming is what merijin just wrote
13:07:31 <byorgey> BONUS++
13:07:32 <mm_freak> filius: better write a function for that with explicit recursion
13:07:47 <byorgey> just got my dead tree copy of LYAH in the mail, it's awesome =)
13:07:53 <monochrom> eh? doing I/O properly doesn't make anything less 'functiony'.
13:08:04 <FUZxxl> @hackage vector
13:08:05 <lambdabot> http://hackage.haskell.org/package/vector
13:08:34 <luite> byorgey: did you get any extra goodies with the book?
13:08:48 <byorgey> luite: no, there are extra goodies?
13:08:52 <monochrom> unless you looking into IO or monads in general for ways to write assembly-like code, in which case yes you will be disappointed
13:08:54 <hpc> yes
13:08:56 <alej> you didn't get the t-shirt?
13:09:04 <hpc> byorgey: check lyah home
13:09:04 <luite> byorgey: apparently, if you ordered directly from the publisher
13:09:17 <byorgey> oh, I think I ordered from amazon
13:09:29 <mm_freak> Bfig: monads are just a design pattern, just like OOP is a design patternâ€¦  in practice monads allow you to express what it means to "pass a value" from a computation to another
13:09:31 <byorgey> I don't really remember, I pre-ordered it a long time ago
13:09:41 <byorgey> yup, it's an amazon box
13:09:52 <filius> mm_freak: yes that was the way  I'm going after, maybe I need to try harder
13:10:13 <mm_freak> filius: if you want an elegant solution, look into zippers
13:10:35 <hpc> lyah has a zipper chapter; it is very good
13:10:38 <luite> byorgey: I think the extra's were a secret, but BONUS hinted that they might be sticky
13:11:13 <Bfig> merijn, thanks for that piece of code, i think i can squeeze a program out of that :p
13:11:15 <nyingen> oh cool, LYAH is shipping
13:11:32 <filius> mm_freak: thanks I'll look into that
13:11:35 <nyingen> I ordered one last week, from the publisher, but I have no idea when delivery is expected
13:11:47 <merijn> Bfig: np
13:11:50 <shachaf> mm_freak: "pass a value"? What does that mean?
13:12:17 <merijn> Bfig: Might be worth looking into some of the other parser stuff people have mentioned, though
13:12:26 <mm_freak> shachaf: it was a very blurry explanationâ€¦  not meant to teach monads, but just to give an idea of the actual simplicity of the whole concept
13:12:34 <Bfig> definitely will be doing it whenever i have time
13:12:59 <shachaf> mm_freak: I'm not sure what it means for, say, [].
13:13:20 <mm_freak> shachaf: for [] it means pass all results from the source computation to the consuming computation
13:13:31 <Bfig> still gotta polish this code, and then finish about four more assignments
13:13:34 <shachaf> Hmm.
13:13:54 <mm_freak> maybe i should have said "pass a result" instead of "pass a value"
13:16:36 <mm_freak> anyway, Bfig, monads are easiest to learn by just using them
13:16:52 <mm_freak> don't worry about what "monad" meansâ€¦  just do your work, and the understanding emerges all by itself
13:17:24 <Bfig> mm_freak, thanks for the advice
13:18:37 <mm_freak> Bfig: i recommend reading the parsec tutorial
13:18:51 <mm_freak> you will quickly see the advantages of monadic parsing
13:19:07 <osoleve> my current project fell through :(
13:19:22 <mm_freak> Bfig: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
13:19:26 <osoleve> does anyone have any ideas for a project for a haskell novice? i learn by figuring stuff out
13:19:34 <lispy> Actually, there are some disadvantages to monadic parsing too that people don't always talk about.  For example, it's very hard to state properties about your grammar when you're done.
13:19:47 <lispy> osoleve: have you seen the haskell_proposals subreddit?
13:19:48 <Bfig> i think i'm gonna solve the problem of reading the variables inside by returning a Data from the constructor instead of the computed polynomial
13:20:03 <osoleve> lispy: i will have had seen it in a second :3
13:20:05 <lispy> osoleve: http://www.reddit.com/r/haskell_proposals
13:20:11 <lispy> :)
13:20:19 <osoleve> looking now thanks
13:23:21 <mm_freak> Bfig: then you could just as well write python ;)
13:23:37 <Bfig> mm_freak, if it only were that easy... :p
13:24:06 <mm_freak> Bfig: well, do what you think, but i strongly recommend to read the tutorial i linked
13:24:25 <Bfig> mm_freak, i will read it, but for now i need a fast fix
13:24:41 <Bfig> mm_freak, i've already wrote about 3/4 of the code, this is no time to back down :p
13:25:10 <monochrom> osoleve: I playfully suggest the intractible project of figuring out how many time and memory each haskell program consumes
13:25:13 <mm_freak> Bfig: you may find yourself getting done quicker by learning the proper way
13:25:20 <monochrom> s/many/much/
13:33:35 <ormaaj> "Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class." so types are members of themselves?
13:33:53 <mauke> no?
13:34:39 <monochrom> "Eq class" is a type?
13:34:42 <gronkalonk> How come haskell is harder than Coq to do something useful in?
13:34:54 <merijn> gronkalonk: What did you smoke?
13:34:57 <DevHC> lol
13:34:57 <aristid> ormaaj: Eq class is NOT a type. it's a type class.
13:35:02 <acowley> gronkalonk: How on earth could you come to that conclusion?
13:35:03 <lispy> gronkalonk: what do you consider useful?
13:35:59 <merijn> lispy: I'm pretty sure that "forall a. (Useful a) => Coq -> a" is _|_ >.>
13:36:15 <alej> i think that statement is only true if "do something useful" means "write a coq proof/program"
13:36:34 <lispy> merijn: nah, you can write Core to Core transformations for GHC in Coq these days
13:36:34 <ormaaj> aristid: ah now that sentence makes sense
13:36:35 <aristid> merijn: you're just anti-french
13:36:46 <scree> another possible explanation would be that gronkalonk knows coq but not haskell
13:37:00 <merijn> aristid: Other then the French, who isn't? :>
13:37:00 <mm_freak> gronkalonk: if you give me a hint on how to do web development faster in coq than in haskell, i'll be glad to switch
13:37:09 <aristid> merijn: fair enough.
13:37:12 <DevHC> another explanation is that gronkalonk is trolling :D
13:37:27 <aristid> mm_freak: use Ur, man
13:37:47 <gronkalonk> Is Haskell sort of like one of those esoteric joke languages? Have I been trying to do something useful with something that is not meant for it? No offense, I am new to all of it.
13:37:48 <merijn> @quote haskell.from.coq
13:37:48 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
13:38:14 <scree> but that would mean everyone here was feeding trolls
13:38:23 <jmcarthur> not sure if troll
13:38:30 <scree> and I'm sure #haskell would know better
13:38:33 <merijn> scree: Highly intelligent people can get bored too :p
13:38:38 <jmcarthur> gronkalonk: no haskell is not a joke language
13:38:40 <monochrom> coq is easier to use than haskell for people who drink the curry-howard coolaid wholesale
13:39:00 <merijn> monochrom: You mean mathematicians? :>
13:39:02 <aristid> scree: if a troll talks about Coq, maybe the troll detectors fail for a moment :D
13:39:18 <lispy> gronkalonk: haskell is quite useful for pragmatic and industrial programming tasks.
13:39:35 <jmcarthur> gronkalonk: and if you think coq is so easy then i don't see why you would think haskell is so hard, honestly
13:39:52 <lispy> gronkalonk: Have you read real-world haskell yet?
13:39:52 * scree wonders if troll-detection irc bots exist
13:39:54 <DevHC> gronkalonk: the functional programming paradigm is difficult to understand by many people, partly because it is a lot different than the "conventional" imperative languages
13:40:05 <gronkalonk> Is it the purpose of Haskell to write programs? Or is it more of a competition kind of thing. Sort of like an added challenge for those who want to up the difficulty? Not sure if I am clear. Sort of like playing Doom on Nightmare or whatever the hardest was.
13:40:20 <monochrom> I don't know. it seems most #haskell people actually do that, to drink the curry-howard coolaid wholesale. just look at how sickly obsessive they are about type-level naturals "so I can make sure two vectors have the same length"
13:40:22 <jmcarthur> scree: maybe we could train a troll detector similarly to a spam detector!
13:40:28 <merijn> Ok, I'm bored with the trolling now
13:40:34 <gronkalonk> Problem?
13:41:01 <o--> it's harder to do some things in Haskell because it doesn't have the same freedom of expression as Coq
13:41:04 <merijn> monochrom: I just want constraint typing to make all my problems go away! :<
13:41:04 <jmcarthur> i am now convinced that gronkalonk is trolling
13:41:05 <mm_freak> take it easy
13:41:16 <mm_freak> it's good for haskell programmers that non-haskellers make fun of it
13:41:20 --- mode: ChanServ set +o mauke
13:41:20 --- mode: mauke set +q *!*@gateway/web/freenode/ip.80.212.74.204
13:41:21 <DevHC> gronkalonk: haskell allows u to express solutions to problems in a different way, not by "let A be 13, add A with B, put the answer in B, let A be A*3, output A*B, etc."
13:41:30 <lispy> gronkalonk: what have you tried to use haskell for so far?
13:41:35 <acowley> gronkalonk: you're not answering anyone's questions
13:41:36 <jmcarthur> beat me to it
13:41:40 <merijn> DevHC: If he knows Coq he doesn't need such an explanation
13:41:40 <monochrom> no longer answerable
13:41:56 <merijn> Anyway, some troll-b-gone was applied :>
13:41:56 <DevHC> merijn: mkay...
13:42:01 <ormaaj> actually that sentence is still ambiguous but meh
13:42:10 --- mode: mauke set -o mauke
13:42:32 <mm_freak> i'm amazed by how politely haskellers deal with trollsâ€¦  this is really the greatest channel on freenode =)
13:42:41 <DevHC> NOT
13:43:11 <mm_freak> that's probably why we have so few trollsâ€¦  trolling #haskell must be very boring =)
13:43:23 <jmcarthur> i kind of enjoy the occasional troll, actually
13:43:24 <lispy> ?quote Cale.troll
13:43:24 <lambdabot> No quotes match. Take a stress pill and think things over.
13:43:28 <merijn> mm_freak: If only some people here would hold office hours where people can ask questions I could just ditch university all together :>
13:43:29 <lispy> ?quote explode
13:43:29 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
13:43:42 <acowley> mm_freak: because Haskell newcomer questions are so similar to trolling
13:43:43 * lispy can never seem to request the quote he is after
13:44:01 <merijn> lispy: I always look them up in privmsg first :p
13:44:06 <aristid> @quote Cale.*troll
13:44:06 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
13:44:06 <jmcarthur> @quote troll.Cale
13:44:06 <lambdabot> No quotes match. Just what do you think you're doing Dave?
13:44:15 <aristid> @quote troll.*Cale
13:44:15 <lambdabot> No quotes match. It can only be attributed to human error.
13:44:18 <aristid> damn.
13:44:31 <aristid> Cale and troll seemingly never occur in the same sentence.
13:44:36 <Jafet> @quote confrontational
13:44:36 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
13:44:43 <merijn> @quote Cale troll
13:44:43 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
13:44:49 <merijn> <-- skillz
13:44:53 <lispy> that's the one
13:45:18 <acowley> The kmc one is sadly true :(
13:45:35 <merijn> acowley: But how do I turn IO String into String?!?!?!
13:45:39 <o--> spot the type error (\x -> "<td bgcolor=\"" ++ if x == 1 then "pink" else "slate" ++ "\"></td>")
13:45:48 <aristid> merijn: with unsafePerformIO
13:46:04 <aristid> @hoogle unsafePerformIO
13:46:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:46:05 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:46:06 <mm_freak> with unsafeCoerce
13:46:20 <aristid> with const "Cookies"
13:46:30 <mauke> :t (\x -> "<td bgcolor=\"" ++ if x == 1 then "pink" else "slate" ++ "\"></td>")
13:46:31 <lambdabot> forall a. (Num a) => a -> [Char]
13:46:41 <monochrom> @quote monochrom IO.String
13:46:41 <lambdabot> monochrom says: How do I extract the IO out of IO String?
13:46:46 <monochrom> hehe
13:46:53 <acowley> I just wrap everything I write in Debug.Trace.trace
13:46:56 <aristid> @quote geheimdienst
13:46:57 <lambdabot> geheimdienst says: what does a pirate say when starting a sentence, then suddenly being hit in the nadgers? arr- ow!
13:47:24 <aristid> oh, took me a while to get that one
13:47:29 <merijn> I've heard that if you type "unsafePerformIO" three times in an empty text editor SPJ's minions appear and drag you off to imperative land where you will be forced to write COBOL until you die
13:48:00 <alej> choosing the text 'unsafe' is pretty effective. I think i've been too scared to use it ever
13:48:01 <aristid> SPJ seems not to like lazy evaluation anymore :( [completely unrelated note]
13:48:47 <merijn> On the topic of non-lazy I am somewhat intrigued by Habit. Anyone looked at it?
13:48:50 <mm_freak> i don't remember using unsafePerformIO a single time
13:48:51 <Eelis> aristid: what makes you say that?
13:49:12 <aristid> Eelis: he says things like "purity may be the more important concept than laziness"
13:49:21 <ion> mm_freak: Even indirectly? :-)
13:49:31 <aristid> Eelis: and i seem to recall him wondering if maybe haskell should be strict, if started fresh
13:49:36 <aristid> (strict by default, at least)
13:49:55 <merijn> aristid: I heard him say that in a talk (the purity more important bit) but didn't parse it as "laziness is no good"
13:50:18 <merijn> Struck me more as a "purity has driven more important developments then laziness"
13:50:35 <Eelis> oh. well, i would agree with that, and with merijn.
13:50:39 <aristid> merijn: well yes, but there's the second thing, but i don't know where he said that
13:51:26 <merijn> Well, strict haskell would be useful for some things, which is why I think Habit looks so intriguing :p
13:51:35 <monochrom> in fact laziness is driven by purity. of course the cause drives more effects than the effects do
13:51:43 <aristid> habit has type-level naturals
13:51:50 <aristid> but ghc may get them too, i read
13:52:31 <aristid> monochrom: he said that purity was the only way to make laziness work, so they embarked on it
13:52:57 <acowley> I find it hard to argue for laziness without relying on seemingly trivial benefits
13:53:12 <merijn> Actually
13:54:33 <merijn> And nevermind, there goes my insight... :p
13:55:00 <aristid> merijn: and i was sitting there, curiously waiting for you to finish your sentence :P
13:55:00 <lispy> aristid: yeah type level nats have been implemented.  Not sure if the merge was completed yet
13:55:54 <merijn> On slightly related note, how is the reputation of Portland State's CS department? :>
13:56:57 <monochrom> the power supply unit cs department? XD <duck>
13:57:05 <alej> the cs department as a whole?
13:57:14 <alej> or the language group, specifically?
13:57:33 <DevHC> the rules for playing on a game server i run: https://tremulous.oternet.com/info-rules.txt . pay special attention to the TROLLING paragraphs
13:57:37 <merijn> alej: Well, I just noticed they have PhD positions for Habit and since I am as of yet entirely clueless on where to go for my PhD :p
13:57:42 <alej> i think i've seen that they've published somewhat frequently in the pl papers
13:57:57 <alej> merijn: i was considering applying there, actually
13:58:02 <merijn> And considering I'm interested in both Haskell and systems programming that seems fairly interesting
13:58:05 <alej> but i didn't, for two reason, not necessarily great reasons
13:58:21 <alej> 1) they took forever to respond to my emails, which made me a little wary
13:58:26 <alej> like mb a month
13:58:29 <alej> fine, profs are busy
13:58:35 <alej> especially wrt prospective students
13:58:38 <merijn> Not sure whether its worth the ridiculous hassle of A) getting into the US and B) manage the differences with US curriculum
13:59:10 <alej> and 2) my advisor was skeptical about me applying to PSU, though I'm not sure how much he knew about active PL research.
13:59:19 <merijn> Oh, and of course C) the sucky pay in the US
13:59:21 <alej> i guess 2 a) i was already applying to 13 schools
13:59:32 <alej> merijn: where are you that PhD students dont get sucky pay?
13:59:46 <absentia> I knew two phds that were splitting a 60K salary.  ouch.
14:00:02 <alej> 30K/students is actually probably the high end for phd in the us
14:00:06 <absentia> I was never so happy in my life that I remained uneducated.
14:00:14 <merijn> alej: The Netherlands, I've been told the pay here is significantly less sucky then in the US
14:01:12 <alej> i think the stipend i'm going to get is around $2000/month
14:01:23 <acowley> I don't think doing a PhD in theoretical CS is something you should do for the funny
14:01:26 <alej> so i'm going from industry to that :)
14:01:33 <alej> acowley: you shouldn't do a phd in anything for money
14:02:09 <merijn> Going rate seems to be about 2.4k a month so that'd be around 29k a year, (but then you run into the differences with living expenses and exchange rates compared with dollars)
14:02:23 <alej> yeah
14:02:40 <acowley> alej: that's probably true, but I just wanted to emphasize that a good CS grad program will not make many (if any) concessions to helping you make money
14:02:51 <alej> hehe
14:03:09 <acowley> some programs, you might think that you'll graduate with a valuable qualification
14:03:19 <merijn> Because as I understand at the current rate I can forget about affordable health insurance in the US :>
14:03:32 <acowley> merijn: just don't get sick or ever hurt yourself
14:04:03 * Lycurgus gawks at the European view of American academe.
14:04:12 <merijn> acowley: I'll get right on that :>
14:04:17 <acowley> merijn: actually, most schools have an insurance requirement for students, so you can find out exactly they'll take out of your stipend
14:05:06 <luite> don't us universities have group health insurance for phd students?
14:05:13 <alej> merijn: usually healthy insurance is something that's covered in some form
14:05:20 <alej> *health
14:05:40 <merijn> Lycurgus: Which view of American academe? I think most views are fairly generic and independent of academia
14:06:03 <acowley> luite: yes
14:06:18 <acowley> luite: but if you already have coverage, you can waive it
14:07:15 <merijn> I'm not actually that worried about the money at any rate. My most important worries are the bureaucratic nightmare of getting into the US and getting the differences between curricula dealt with somehow
14:07:32 <luite> another difference might be that dutch phd students are typically employed by the university
14:07:32 <acowley> what curriculum issues do you foresee?
14:07:45 <Lycurgus> merijn, the one the 3 of you were/are expressing
14:08:38 <merijn> acowley: Well it is unusual (actually practically unheard of) to still follow classes during your PhD here, the duration is also shorter. Almost no one goes straight from BS to PhD (MSc is practically mandatory)
14:09:31 <acowley> I think graduate classes are awesome, actually
14:09:39 <acowley> you should view that as a plus
14:10:05 <merijn> acowley: I'm pretty sure graduate classes consist mostly of what the classes for MSc are here
14:10:13 <acowley> Yes, mostly
14:10:35 <merijn> So I already did about 2.5 year of those, classes start getting old after a while :p
14:11:22 <acowley> we have a tier of classes for MSc/PhD, with different grading in some classes dependent on your degree program, and then we have a tier of seminar-style courses that are less formal and intended to more deeply explore a particular topic
14:11:45 <acowley> You can place out of the lower tier of classes by taking the finals
14:11:59 <acowley> and make up the credits through research, etc.
14:28:18 <christo_m> acowley: how would you recommend implementing a symbol table to keep track of variable scope and values and types ?
14:28:26 <christo_m> acowley: https://github.com/christomitov/Turnip
14:29:05 <acowley> telescoping association list
14:29:19 <acowley> or nested dictionaries if the list is no good
14:29:55 <acowley> the idea being that you take the first binding you find when you lookup a name
14:29:59 <acowley> so you get shadowing
14:32:21 <Bfig> i want to write a show function for this: > data Terminal = Poli [Float] | Variable Int; when i do it i get 'show gives differen arities': >  show Poli nomio = show nomio
14:33:06 <Bfig> a
14:33:27 <acowley> You need parens
14:33:34 <acowley> show (Poli nomio) = show nomio
14:34:01 <Bfig> yep, the problem was because i defined the same for Variable Int but didn't put the parens on that... so it was the same function but had two params
14:35:12 <DevHC> mauke: u need to soften ur banhammar
14:35:49 <mauke> DevHC: why?
14:39:29 <christo_m> acowley: i was thinking something similar, because I have block defined as what a program is.. basically a bunch of blocks
14:39:55 <christo_m> so i know if im at depth 0, its a globally defined variable, if im in depth 3, im in a nested block , and thus i should only be able to work with other values defined at depth 3
14:40:24 <c_wraith> YOu don't have implicit searching of outer scopes?
14:40:30 <acowley> Wait, no
14:40:42 <acowley> the point is to pass the context into the evaluator
14:40:53 <christo_m> acowley: i dont even have an evaluator
14:40:54 <acowley> the evaluator doesn't know what scope its in, it just knows how to inspect the context
14:41:02 <christo_m> im going to be emitting code, using LLVM
14:41:07 <acowley> same difference
14:41:16 <acowley> your code gen is the evaluator
14:41:50 <monochrom> ever heard of "activation record", "stack frame"?
14:42:08 <mm_freak> ion: indirectly i probably did =)
14:42:59 <christo_m> monochrom: are yo utalking to me? ive heard of stack frame when talking in the context of operating systems
14:43:03 <christo_m> specifically processes
14:43:05 <monochrom> yes
14:44:01 <christo_m> acowley: so whats wrong with doing depth first evaluation
14:44:35 <christo_m> i dont think im understanding clearly here. i have my parser, my AST, and now i want to do intermediate representation
14:44:38 <acowley> christo_m: Nothing, I just don't think you want a setup where you have a scope depth stashed anywhere
14:45:15 <christo_m> acowley: it wouldnt be stashed, it would be more like a one to one mapping between the scope level and the block
14:45:29 <christo_m> maybe key,value pairs
14:45:53 <acowley> You usually want to keep these things separate
14:46:08 <acowley> so a block by itself is not useful, and neither is a binding environment
14:46:18 <acowley> but you pair them together, and now you have something
14:46:23 <christo_m> okay youve seen my program structure, are you saying create a new module then
14:46:35 <monochrom> you don't need key-value database mongo db whatever. you just need a stack.
14:46:49 <christo_m> monochrom: do i need to worry about overflow?
14:46:55 <monochrom> no
14:47:09 <christo_m> if the whole program lives in the stack, and i have a while loop
14:47:11 <christo_m> ill be fine?
14:47:41 <acowley> monochrom: I suggested an assoc list, not mongodb :/
14:47:45 <monochrom> a while loop adds one scope level only, no matter how many times it is executed
14:49:51 <christo_m> monochrom: what about functions, if i wanted to jump to another label
14:49:55 <christo_m> do i need some sort of stack pointer?
14:49:56 <ghiu> hi, can haskell nest guards? http://hpaste.org/45663/nesting_guards
14:50:42 <acowley> ghiu: why would you do that?
14:50:47 <acowley> christo_m: no
14:50:56 <monochrom> "functions" and "jump to another label" are orthogonal. please pick only one and ask again
14:51:39 <ghiu> acowley: it seems natural in the code i've pasted, isn't it?
14:52:00 <monochrom> every author thinks his/her way of writing code is natural
14:52:02 <acowley> ghiu: what do you gain by having nested guards vs. just a flat list of guards?
14:52:18 <christo_m> monochrom: do you have some resource i can read
14:52:25 <christo_m> stack frmaes in general i guess
14:52:31 <monochrom> no
14:52:44 <monochrom> well yes, I have a book on my shelf. but I can't email it to you
14:52:50 <acowley> type it in
14:53:24 <monochrom> modern compiler implementation in ML
14:53:25 <acowley> christo_m: when you call a function, you add bindings to the binding environment
14:53:31 <monochrom> andrew w. appel
14:53:46 <ghiu> acowley: oh, you're right
14:53:55 <acowley> in a while loop you're just jumping back to the top of the loop
14:54:15 <osoleve> does anyone here have experience with Data.WAVE?
14:54:31 <christo_m> acowley: i think if i take monochroms approach i have to write my own stack data structure
14:54:39 <christo_m> im not sure which is easiest.
14:54:46 <monochrom> (I have only had experience with Dave. does that count?)
14:54:49 <KSkrzet> osoleve: from WAVE package?
14:54:57 <osoleve> KSkrzet: yes
14:55:22 <KSkrzet> osoleve: I didn't have any problems with it
14:55:28 <monochrom> ("why are you doing that, Dave?")
14:55:33 <acowley> christo_m: I know I'm a broken record, but I still say you should be thinking about association lists
14:55:37 <applicative> ghiu, it looks like you are calculating the length twice, once testing for oddness, then to decide how much to take.  
14:55:39 <KSkrzet> osoleve: it felt rather solid
14:55:57 <osoleve> KSkrzet: well, i'm trying to create wav files from scratch and having issues
14:56:03 <christo_m> http://hackage.haskell.org/packages/archive/EdisonCore/1.2.1.3/doc/html/Data-Edison-Assoc-AssocList.html 
14:56:07 <christo_m> acowley: those?
14:56:22 <ghiu> applicative: yes
14:56:25 <osoleve> KSkrzet: it may be a problem with my conversion from notes to WAVESamples
14:56:28 <KSkrzet> osoleve: I also used HCodecs which is very good as well
14:56:34 <acowley> I meant [(Identifier, Term)] where you have an Eq instance for Identifier
14:56:48 <acowley> and Term is a Term in your object language
14:56:55 <acowley> or maybe a value if eager
14:57:13 * kowey thinks the warning at the top of http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/win32-dlls.html needs to be rephrased
14:57:25 <applicative> ghiu, you can join them by replacing them with "len" (say) and putting len = length xs in the where clause
14:57:25 <kowey> but isn't confident enough to do it himself
14:57:51 <ghiu> applicative: i've done that when you pointed it out, thanks
14:57:58 <KSkrzet> osoleve: well, from musical notes to doubles there are a few steps I guess
14:58:05 <osoleve> KSkrzet: did you do any conversion of note frequencies into WAVESamples?
14:58:50 <KSkrzet> osoleve: well, just use sine function with proper period I guess
14:59:17 <fryguybob> kowey: http://hackage.haskell.org/trac/ghc/ticket/4825
14:59:30 <osoleve> KSkrzet: i'm going to try something, i'll be right back
14:59:41 * osoleve is excited that his project might not be dead after all
14:59:43 <christo_m> acowley: and whats the identifier in this case?
14:59:49 <KSkrzet> osoleve: map sampleToDouble [sin (pi * i * f) | i <- [0..]] or something like that
15:00:05 <kowey> oh! thanks for that link, fryguybob 
15:00:06 <applicative> ghiu, I wonder if the complexity saves you anything over "isPal xs = xs == reverse xs"
15:00:06 <christo_m> i still dont get how what you put resolves issues like lexical scope
15:00:08 <acowley> christo_m: whatever you're using to represent identifiers
15:00:16 <acowley> e.g. Int, or String
15:00:22 <fryguybob> > let p = (==) <*> reverse in p "racecar"
15:00:22 <lambdabot>   True
15:00:59 <christo_m> acowley: arent identifiers what the programmer puts ?
15:01:02 <christo_m> not the actual types
15:01:08 <applicative> stylin' , fryguybob
15:01:24 <christo_m> so a list of pairs, of identifier, and its value
15:01:53 <kowey> ah yes, Orphi's documentation patch does what I want (/me closes vim)
15:01:54 <acowley> christo_m: You've called the type Name
15:01:59 <acowley> christo_m: that's all I mean
15:02:01 <christo_m> acowley: right.
15:02:44 <ghiu> applicative: that is not palindrome, it's just the reverse!
15:03:05 <christo_m> > let p = (==) <*> reverse in p "step on no pets"
15:03:06 <lambdabot>   True
15:03:43 <Jafet> > ap (==) reverse "step on no pets"
15:03:44 <lambdabot>   True
15:03:47 <aristid> christo_m: that's a good one.
15:04:20 <christo_m> acowley: so are these pairs nested when talking about scope? im still confused
15:04:26 <christo_m> i dont get how it solves my problem
15:05:24 <applicative> ghiu, isn't it? i could easily be going mad
15:05:31 <applicative> > let p xs = xs == reverse xs in p "racecar"
15:05:32 <lambdabot>   True
15:05:40 <merijn> applicative: It is a palindrome function, yes
15:05:40 <applicative> > let p xs = xs == reverse xs in p "hannah"
15:05:41 <lambdabot>   True
15:06:13 <ghiu> applicative: uh...
15:06:20 <ghiu> applicative: lol, you're right
15:06:22 <aristid> @pl p xs = xs == reverse xs
15:06:23 <lambdabot> p = ap (==) reverse
15:06:33 <aristid> ah, @pl actually doing it right
15:06:49 <merijn> christo_m: I didn't pay much attention to the start of the conversation, but you are trying to do lookups for (nested) identifiers?
15:06:50 <applicative> excellent code there from pl
15:07:15 <christo_m> merijn: im trying to do something like a symbol table.. something to keep track of the environment
15:07:29 <christo_m> merijn: and to resolve lexical scope
15:07:32 <merijn> christo_m: Use a stack of association lists?
15:07:41 <christo_m> so a mix of what acowley and monochrom said lol.
15:07:54 <merijn> That's what I used in my C compiler code some time ago
15:08:25 <acowley> christo_m: You have options, when you enter a block, you have an environment. When you want to push new bindings into the environment, you still have a reference to the original environment
15:08:28 <ghiu> applicative: btw, it is useful to make some practivce
15:08:35 <merijn> Each level of nesting pushes a new association lists on top of the stack. If the you find no match in the top of the stack, continue to the next until you find a match or run out of stacks
15:08:43 <merijn> (Stack here could of course easily be a list)
15:08:59 <christo_m> merijn: okay so when you say that, do you mean i have a separate stack for each block 
15:09:01 <DevHC> mauke: because it's slamming stuff prematurely
15:09:07 <acowley> What I'm suggesting is to avoid explicitly distinct stack frames
15:09:28 <christo_m> for instance, at the global level, i have a stack, if i enter a block, create a new stack 
15:09:29 <merijn> christo_m: No have a separate association lists for each block and keep them on the same stack
15:09:33 <christo_m> okay
15:09:35 <christo_m> so one stack
15:09:42 <KSkrzet> I think that instead shadowing is better than doing stacks
15:09:48 <KSkrzet> performance wise
15:09:58 <christo_m> im not too concerned about performance at this point
15:10:02 <merijn> KSkrzet: Unlikely that you have enough identifier for it to matter
15:10:16 <acowley> Why do you want a list of frames, though?
15:10:20 <KSkrzet> merijn: it also simplifies code
15:10:21 <merijn> So when global level is an association list. When you do lookups, check that a-list
15:10:24 <acowley> When would you pop it?
15:11:02 <merijn> When you enter a new block, push a new a-list on top. Now all queries first try the top (i.e. block scope) then try global when you don't get a result in block scope
15:11:03 <acowley> This is FP! We use persistent data structures
15:11:20 <merijn> Keep pushing/popping when you enter/exit blocks as needed
15:11:36 <ddarius> Using an environment monad for environments makes a bit more sense than using a state monad.
15:12:01 <merijn> KSkrzet: Using a stack of a-lists seems as the easiest way to implement shadowing (to me...)
15:12:06 <christo_m> yes i think lispy suggested the Reader monad a few days ago
15:12:10 <christo_m> but i had no clue how to use it for this
15:12:12 <acowley> no
15:12:14 <acowley> seriously
15:12:19 <acowley> just a list
15:12:27 <acowley> don't dress it up until it makes sense
15:12:52 <acowley> you'll get it, then want to hide the environment plumbing, the Reader monad will suddenly make sense
15:13:29 <christo_m> D:
15:13:47 <acowley> then we can all sing and dance and be merry and get back to being trolled regarding Coq's superior usability
15:13:50 <acowley> :P
15:14:17 <christo_m> first an association list, then a stack of association lists.. now just a list
15:14:29 <acowley> just an association list
15:14:32 <acowley> which is just a list
15:14:36 <christo_m> right
15:14:54 <acowley> and soon you'll meet de Bruijn and really just have a list
15:15:03 <merijn> acowley: Oh, yeah. If you push/pop pairs I guess that's even simpler
15:15:09 <acowley> no pop!
15:15:24 <merijn> Because then you can have multiple items with the same name
15:15:30 <christo_m> maybe i should be using Map 
15:15:31 <acowley> yes
15:15:38 <acowley> the order in the list implements shadowing
15:15:41 <merijn> I had to do stacks because my code was using a Trie and not an a-list
15:16:45 <merijn> christo_m: I have changed my mind, association lists is enough :p
15:16:53 <merijn> s/lists/list
15:16:57 <christo_m> not a map
15:17:05 <christo_m> even though i might see performance boost from map
15:17:06 <merijn> christo_m: Map would also work
15:17:08 <christo_m> i want to make the design decision now
15:17:15 <christo_m> hm okay
15:17:18 <merijn> But map requires you to use a stack again
15:17:23 <merijn> (To implement shadowing)
15:17:34 <christo_m> thanks guys, i know ive been harassing this channel and its members for a week now trying to do this darn thing
15:17:38 <merijn> Or you need to store Lists in the map
15:18:13 <acowley> christo_m: use a Seq instead of a list if you're worried about performance
15:18:22 <acowley> but don't
15:18:25 <acowley> just use a list
15:18:26 <acowley> :P
15:18:49 <merijn> Use a list, change when it is to slow (i.e. never...)
15:18:58 <acowley> I'm not actually sure a Seq would help now that I think about it
15:19:02 <christo_m> okay , list!
15:19:03 <christo_m> done
15:19:07 <acowley> hooray!
15:19:10 <christo_m> time to get drunk and code
15:19:11 <christo_m> thanks boys
15:19:21 <acowley> np
15:19:27 <merijn> When you're done you'll wonder why this seemed to difficult at first :p
15:19:45 <christo_m> merijn: its always the case.. ive learned so much this past week
15:19:56 <christo_m> you have to understand im from a complete imperative background, so im doing things wayyy differently
15:20:27 <merijn> I've learned more in 1 year of #haskell then the previous 4 of CS mastr :p
15:20:31 <christo_m> i wouldnt have even asked about the symbol table, i know i can just use any Hash table data structure.. but then structurs in haskell are immutable so its making my head explode
15:21:29 <acowley> lists are the data structure nats gave us, so we first determine why they'd be wrong
15:21:38 <Cale> Hashtables are overrated as far as implementations of finite maps are concernes.
15:21:41 <Cale> d*
15:22:03 <acowley> The whole thing should be abstract
15:22:05 <acowley> in any case
15:22:05 <Cale> Nice balanced tree structures are so much more predictable and easy to design well.
15:22:29 <osoleve> KSkrzet: do you have a moment to review my code to see why it's creating faulty wav files?
15:22:36 <acowley> type FiniteMap k v = k -> Maybe v
15:22:41 <applicative> ghiu: yes, it's a good plan to expose it to our friends on #haskell.  
15:24:28 <christo_m> oh wow, lookup is implemented for me
15:24:33 <christo_m> exactly like a symboltable
15:24:35 <acowley> :D
15:25:37 <ddarius> Actually, a persistent structure is much simpler to use for a symbol table than a hash table.
15:27:09 <merijn> christo_m: If you don't know it yet, you should also check out the awesomess of Hoogle
15:27:37 <merijn> Hoogle is like the killer app of static typing :>
15:28:07 <christo_m> ugh, please dont say killer app
15:28:15 <christo_m> and yes , i know about it, but thank you :)
15:28:24 <merijn> Anyhoo, bed time
15:29:26 <christo_m> acowley: did you say to have a list for each scope
15:30:32 <christo_m> okay nvm, that seems to make most sense to me so let me just eff it up for myself here
15:30:35 <christo_m> ill learn soon enough
15:31:57 <KSkrzet> osoleve: just paste it somewhere on the web
15:32:09 <osoleve> http://hpaste.org/45666/wav
15:33:23 <KSkrzet> osoleve: what are the symptomps? why does it sounds wrong?
15:33:37 <osoleve> KSkrzet: it doesn't even load
15:34:01 <osoleve> when I try to play it in moc, it says "can't send() int to server" and it's a fatal error
15:35:34 <KSkrzet> osoleve: I don't know what moc is, but I recommend using some sort of sound editor. audacity is good and free
15:35:58 <ClaudiusMaximus> osoleve: i don't see any mention of samplerate there; usually there's a number like 44100 or 48000 around in this kind of code..
15:36:31 <KSkrzet> osoleve: and are you making sure you aren't being bitten by lazy IO?
15:36:44 <KSkrzet> osoleve: does the output file has any contents at all?
15:36:56 * hackagebot acid-state 0.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.1 (DavidHimmelstrup)
15:37:15 * ddarius doesn't think he would say Audacity is good.
15:37:20 <KSkrzet> osoleve: oh, you are safe on the lazy side, putWAVEFile is good
15:38:00 <KSkrzet> ddarius: define good
15:38:16 <osoleve> KSkrzet: sorry, someone grabbed my attention
15:38:58 <ddarius> KSkrzet: "Works" would be a start.
15:39:08 <osoleve> Data.WAVE doesn't have anything about sample rate that I see
15:40:35 <KSkrzet> it does
15:40:48 <KSkrzet> http://hackage.haskell.org/packages/archive/WAVE/0.1.1/doc/html/Data-WAVE.html#t:WAVEHeader
15:40:54 <ClaudiusMaximus> osoleve: waveFrameRate i think should be several thousand, instead of 1 (as it's per second according to the docs); and you probably need to divide your frequencies by the samplerate to get correct pitch
15:42:00 <osoleve> okay, looking into that
15:42:38 <KSkrzet> what is appropriate channel to ask about GHC hacking? whom should I message or send mail to?
15:42:50 <dons> in #ghc
15:45:32 <ClaudiusMaximus> > map (\x -> 2 ** (x / 12)) [ 0 .. 12 ]
15:45:32 <lambdabot>   [1.0,1.0594630943592953,1.122462048309373,1.189207115002721,1.2599210498948...
15:45:57 <ClaudiusMaximus> > unwords $ map (\x -> take 4 . show $ 2 ** (x / 12)) [ 0 .. 12 ]
15:45:59 <lambdabot>   "1.0 1.05 1.12 1.18 1.25 1.33 1.41 1.49 1.58 1.68 1.78 1.88 2.0"
15:49:58 * hackagebot acid-state 0.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.2 (DavidHimmelstrup)
15:56:13 <KSkrzet> is it possible to generate comments with template haskell?
15:56:26 * Twey blinks.
15:56:35 <Twey> Why would you want to?
15:56:56 <c_wraith> I don't think it is.
15:56:57 <KSkrzet> if yes, does Haddock runs over original code or the one after running TH code
15:57:15 <Twey> Haddock runs over the original code.
15:57:21 <Twey> TH is only applied at compile-time.
15:57:39 <Twey> Haddock doesn't compile your Haskell, it just scans it for Haddock comments.
15:58:30 <KSkrzet> well, I'm pretty sure there was a module that had a lot of TH generated code that had to supress it's commenting in Haddock
15:58:50 <KSkrzet> because otherwise the resulting module was huge and didn't serve any real purpose
15:58:59 <KSkrzet> but I might be wrong...
15:59:44 <Twey> KSkrzet: Haddock generates documentation for uncommented code, too
15:59:59 <Twey> Though I don't see how it would in this case
16:00:12 <Twey> Perhaps if you wrote the module to a file before invoking Haddock?
16:23:33 <zmbmartin> Is there anything like rubykoans for haskell?
16:23:47 <roconnor> @type (|||)
16:23:48 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
16:24:01 <roconnor> @type (+++)
16:24:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
16:24:09 <aristid> roconnor: i actually used ||| once.
16:24:30 <aristid> no
16:24:37 <aristid> i mean +++
16:24:45 <roconnor> I'm using it now
16:24:52 <roconnor> though I'm using (+++ id)
16:24:57 <sipa> what is a rubykoan?
16:24:57 <aristid> hmm.
16:25:01 <roconnor> which makes me think there is a better command for that
16:25:09 <aristid> roconnor: either (Left . f) Right?
16:25:21 <roconnor> @hoogle (a -> b) -> Either a c -> Either b c
16:25:21 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
16:25:21 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
16:25:21 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
16:25:34 <roconnor> aristid: ^>>
16:25:38 <Axman6> zmbmartin: without knowing that rubykoans is, it's very difficult to be able to answer you
16:25:40 <roconnor> er
16:25:42 <roconnor> mo
16:25:44 <roconnor> no
16:25:45 <roconnor> aristid: hmm
16:25:56 <beastaugh> http://rubykoans.com/ I would guess
16:25:59 <zmbmartin> sipa: a bunch of failing tests in ruby that you have to code to pass so you learn along the way
16:26:38 <beastaugh> zmbmartin: you could go through LYAH and write a Haskell version of rubykoans using QuickCheck :)
16:27:20 <zmbmartin> beastaugh: ok so nothing like that at this time.
16:27:34 <beastaugh> not as far as I am aware, no
16:27:41 <zmbmartin> OK thanks
16:27:44 <elliottt> roconnor: (+++ id) == left?
16:27:47 <elliottt> :t left
16:27:48 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
16:28:16 <roconnor> yes
16:28:18 <roconnor> that is what I want
16:28:23 <elliottt> :)
16:35:36 <Guest62613> if I have a function with the type signature: pApply :: Parser a -> (a -> b) -> Parser b is the same if i say: pApply :: Parser a -> (c-> d) -> Parser e ?
16:36:04 <Twey> No
16:36:08 <Guest62613> where type Parser a = [Token] -> [(a, [Token])] and token is string
16:36:09 <Twey> a â‰  c
16:36:16 <aristid> elliottt: hey, Control.Arrow definitely has some nice combinators! but most of the time we use them with (->) :D
16:36:39 <Guest62613> but the compiler will complain or infer they are the same?
16:36:47 <aristid> complain.
16:36:55 <Twey> It won't infer that they are the same if you have explicitly said that they aren't
16:37:03 <Twey> Whether or not it will complain depends on your implementation
16:37:28 <Guest62613> the implementation should follow the first type...
16:37:46 <Axman6> it does
16:37:52 <Twey> â€˜const . const $ someParserEâ€™ is a valid implementation of both
16:37:59 <Axman6> but the second is somewhat nonsense
16:38:33 <Axman6> :t const . const []
16:38:34 <lambdabot> forall b a b1. b1 -> b -> [a]
16:38:47 <believa> I am reading messages off a queue using a blocking "receive" function. I want to read as many messages as I can within a certain timeframe. I looked at System.Timeout but I don't think it's appropriate. Any other suggestions? 
16:43:48 <kfish> morning Axman6 
16:43:56 <Axman6> o/
16:48:07 <Axman6> how's life in Tokyo these days? Everything going well at Tsuru?
16:48:44 <acowley> believa: what's wrong with timeout?
16:50:46 <believa> acowley: I'm lazily building up a list of messages that have been read off the queue and I want to stop generating that list when I reach the time limit. Using timeout means I return something or I don't.
16:51:34 <acowley> Well it's not really lazy if you're waiting for it
16:51:51 <believa> acowley: Just found this link - http://stackoverflow.com/questions/4964380/cutting-off-lazy-list-generation. It describes my problem, except I'm doing IO - may be what I need to do.
16:53:01 <elliottt> aristid: yeah, that's one thing that's nice about Control.Arrow :)
16:54:20 <christo_m> im lazy
16:54:20 <christo_m> :(
16:56:28 <osoleve> okay, so say I have a list of lists, and I want to replicate each sublist in place n times. say, [[1], [2], [3]] becomes [[1], [1], [2], [2], [3], [3]]. How would I go about this?
16:56:49 <Axman6> concatMap (replicate n)
16:56:59 <osoleve> thank you
16:57:01 <Axman6> :t concatMap (replicate n)
16:57:02 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
16:57:02 <lambdabot>     In the first argument of `replicate', namely `n'
16:57:02 <lambdabot>     In the first argument of `concatMap', namely `(replicate n)'
16:57:12 <Axman6> :t concatMap (replicate 2)
16:57:13 <lambdabot> forall a. [a] -> [a]
16:57:43 <Axman6> > concatMap (replicate 2) [[1],[2],[3]]
16:57:43 <lambdabot>   [[1],[1],[2],[2],[3],[3]]
17:06:08 <osoleve> okay, this may sound weird, but... I have a list, and I want to make each individual element into a sublist. how can I do this, given that group won't work (a lot of sequential equal elements)
17:06:28 <copumpkin> > map (:[]) [1..5]
17:06:29 <lambdabot>   [[1],[2],[3],[4],[5]]
17:06:31 <copumpkin> ?
17:06:38 <osoleve> beautiful, thanks
17:06:48 <copumpkin> > map pure [1..5] :: [[Int]]
17:06:49 <lambdabot>   [[1],[2],[3],[4],[5]]
17:07:35 <sipa> > (map return [1..5]) :: [[Int]]
17:07:36 <lambdabot>   [[1],[2],[3],[4],[5]]
17:07:44 <parcs> @instances Pointed
17:07:44 <lambdabot> Couldn't find class `Pointed'. Try @instances-importing
17:08:10 <Peaker> > (replicate 2 =<<) . map return $ [1..5]
17:08:11 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:08:11 <lambdabot>    arising from a use of `M7767412206...
17:11:00 <gwern> ' Apparently, 0.1 + 0.2 does not equal 0.3, and this is "the most reported bug in JavaScript". (I'm pretty sure the most reported bug in JavaScript is "help, this language is bullshit").'
17:13:32 <Axman6> > 0.1+0.2
17:13:33 <lambdabot>   0.30000000000000004
17:14:03 <Axman6> > 0.1+0.2 :: Float
17:14:04 <lambdabot>   0.3
17:14:08 <Axman6> heh
17:14:09 <gwern> > (0.1::CReal) + (0.2::CReal)
17:14:09 <lambdabot>   0.3
17:14:40 <Axman6> > 0.2+0.4
17:14:41 <lambdabot>   0.6000000000000001
17:14:53 <Cale> 0.1 isn't exactly representable in base 2
17:14:57 <ion> > 0.1+0.2 ::Rational
17:14:57 <lambdabot>   3 % 10
17:15:35 <c_wraith> neither is 0.2
17:15:39 <systemfault> JS is a nice, simple and misunderstood language
17:15:45 <Draconx> Cale, not exactly representable with a finite number of digits, you mean.
17:15:57 <systemfault> (But yeah, it's definitely not as nice as haskell)
17:15:58 <ion> systemfault: with no integer values
17:16:05 <Cale> right
17:16:08 <gwern> systemfault: simple and misunderstood, like the black tongue of Mordor
17:16:25 <Cale> (can't use an infinite number of digits here)
17:16:47 <Cale> Well, I suppose you could, if you wanted to use a functional representation somewhat like CReal
17:16:49 <osoleve> @faq can haskell represent 0.1 in base 2?
17:16:49 <lambdabot> The answer is: Yes! Haskell can do that.
17:17:52 <c_wraith> It can represent the idea of 0.1 and the idea of base-2, together in a tuple!
17:18:43 <gwern> the idea of 0.1 at key west
17:18:43 <gio123> Cale: hi
17:20:30 <Bfig> what's the function to compare two strings in haskell? does == work?
17:20:31 <c_wraith> Just like you can represent Chaitin's constant in Haskell.  data SomeNumbers = Chaitain'sConstant | CR CRreal
17:20:41 <luite> Bfig: yes
17:20:45 <Bfig> ty
17:20:58 <Axman6> there's also compare
17:21:07 <Axman6> > compare "hello" "Hello"
17:21:08 <lambdabot>   GT
17:21:14 <Axman6> > compare "hello" "fello"
17:21:15 <lambdabot>   GT
17:21:20 <Axman6> > compare "hello" "jello"
17:21:21 <lambdabot>   LT
17:21:25 <Axman6> > compare "hello" "hello"
17:21:25 <lambdabot>   EQ
17:22:03 <aristid> > compare "Axman6" "compare"
17:22:04 <lambdabot>   LT
17:23:52 <hpc> > compare "haskell" "java"
17:23:53 <lambdabot>   LT
17:24:00 <hpc> ooh, the plot thickens!
17:24:10 * Axman6 files a bug report
17:25:18 <acowley> Well... Java is used in businesses where they are serious about names, so...
17:25:25 <acowley> > compare "haskell" "Java"
17:25:26 <lambdabot>   GT
17:26:10 <monokrome> Haskell doesn't have OOP, right?
17:26:14 <aristid> > compare "haskell" (error "java")
17:26:15 <lambdabot>   *Exception: java
17:26:22 <kfish> > let awesome = flip in (awesome compare) "haskell" "java"
17:26:24 <lambdabot>   GT
17:26:47 <gio123> Cale: hi
17:28:31 <acowley> maybe compare is considering date of invention
17:28:45 <acowley> that would be a useful function
17:28:46 <ion> > let awesomeness = length in (compare `on` awesomeness) "haskell" "java"
17:28:47 <lambdabot>   GT
17:29:11 <Axman6> monokrome: you can write things that look like OOP in haskell, but it is not an OO language
17:29:18 <Axman6> monokrome: and this is a good thing
17:29:43 <djahandarie> I finally succeeded in killing the imposter
17:29:45 <gwern> Axman6: well, that's whaat Ohaskell is for
17:29:54 <gwern> djahandarie: are you sure?
17:30:05 <gwern> djahandarie: you are walking down a beach, when you notice a turtle by your foot...
17:30:17 <Axman6> i think i just got trolled
17:32:08 <ion> > (compare `on` snd) ("Haskell", 2010) ("Java", 6) -- stable versions
17:32:09 <lambdabot>   GT
17:32:39 <gwern> ok, curiosity is killing me, I have to know - did anyone get my reference there?
17:32:49 <Axman6> no :()
17:32:51 <Axman6> :(*
17:32:51 <acowley> I think voight kampf would have a lot of false positives on #haskell
17:32:58 <acowley> (I'm sure I spelled it wrong)
17:33:55 <acowley> oh wow I was close!
17:34:08 <shachaf> gwern: Enlighten us.
17:34:15 <monochrom> \âˆ©/ http://www.vex.net/~trebla/haskell/natprim.xhtml much belated
17:34:18 <gwern> shachaf: it was a _Blade Runner_ ref
17:34:25 <gwern> guess people don't watch SF movies much anymore
17:34:27 <christo_m> :O
17:34:27 <acowley> It's what I said
17:34:33 <acowley> as;kldfj
17:34:41 <Axman6> gwern: oh right, heh
17:34:54 <acowley> My explanation of the reference fooled the referer!
17:34:57 * shachaf doesn't watch movies much in general.
17:34:59 <gwern> acowley: well, I know you got it, I was wondering who else did
17:35:15 <gwern> acowley: if nobody responds, then I don't know whether I was too obscure or just not funny
17:35:25 <gwern> (in this case, it would seem to be too obscure)
17:35:40 <acowley> I spent too long trying to make a personalized Voight-Kampff joke for djahandarie :/
17:35:48 <acowley> I will riff faster next time!
17:35:50 <hpc> gwern: wow, that joke took me a while
17:35:58 <hpc> i haven't seen that movie in a while
17:36:00 <shachaf> Turtles? Feet?
17:36:05 <gwern> acowley: although iirc the kampff machine wasn't in blade runner was it? just the story
17:36:08 <acowley> shachaf: djahandarie has neither
17:36:30 <acowley> It was in both the book and movie
17:36:40 <acowley> and the PC game
17:50:45 * BMeph guesses that people don't watch 25-year-old SF movies anymore...
17:51:20 <hpc> BMeph: http://www.penny-arcade.com/comic/2011/4/6/
17:51:25 <hpc> of course they don't :P
17:54:05 <christo_m> http://hpaste.org/45669/error  how am i getting this with https://github.com/christomitov/Turnip/blob/master/Parser.hs
17:54:20 <christo_m> a list of Stmt *is* a block
17:56:28 <ivanm> christo_m: where is Stmt defined?
17:56:54 <ivanm> and Block defined ?
17:57:11 <ivanm> I don't think it matches what you want though... the type of the list is wrong
17:57:32 <ivanm> [Stmt] /= Block if you have an actual constructor for Block
17:59:06 <christo_m> ivanm: i do, its in LuaAS
17:59:45 <ivanm> "map second Block" on that list
18:00:02 <ivanm> christo_m: [Stmt] is not a Block; "Block [Stmt]" is a Block
18:00:05 <ivanm> it's referring to the list eb
18:00:42 <ivanm> so in line 90, do "return (e_, Block b_)
18:00:45 <ivanm> "
18:01:44 <christo_m> ivanm: same error
18:02:10 <ivanm> christo_m: two questions: 1) why aren't you using a .cabal file? 2) why write your own lua bindings rather than use hslua?
18:02:14 <ivanm> @hackage hslua
18:02:14 <lambdabot> http://hackage.haskell.org/package/hslua
18:02:31 * hackagebot darcs-monitor 0.4.1 - Darcs repository monitor (sends email)  http://hackage.haskell.org/package/darcs-monitor-0.4.1 (MarcoSilva)
18:03:01 <christo_m> i dont know man
18:03:06 <christo_m> too many things right now
18:03:31 <ivanm> what gives you the same error?
18:04:04 <christo_m> same line at position 40 now
18:04:06 <christo_m> the df
18:04:10 <christo_m> one sec
18:04:38 <ivanm> oh, hslua binds to lua itself rather than being a re-implementation
18:05:02 <christo_m> ya im doing this from scratch lol
18:05:05 <christo_m> dont mind me
18:05:37 <ivanm> more types would help to work out errors
18:05:49 <ivanm> e.g. what's the type of laststat?
18:07:48 <christo_m> should be Stmt
18:07:54 <christo_m> Parser Stmt
18:08:00 <christo_m> block should be Parser Block
18:08:34 <ivanm> well, if line 40 has an error, does "option [] explist" get you a Parser [Stmt] ?
18:09:15 <christo_m> line 40 doesnt sorry
18:09:19 <christo_m> i meant position 40 of that line
18:10:51 <ivanm> which is... ?
18:11:22 <ivanm> wait, hang on... I think your block parser is wrong
18:11:35 <ivanm> since it should have a type of "Parser Block"
18:11:43 <ivanm> so you shouldn't need the Block constructor in that line
18:12:59 <ivanm> christo_m: type signatures may be optional, but they're highly recommended
18:13:25 <hpc> type signatures are what keep you from going insane while learning
18:13:41 <ivanm> hpc: and when writing large bits of code!
18:14:08 <eee> i am trying to learn me a haskell for great good
18:14:21 <eee> and using interactive environment
18:14:30 <eee> (hello all, by the way)
18:14:36 <eee> (sorry for skipping that)
18:14:44 <eee> (was being talked to in rl)
18:15:19 <eee> so I don't know why I can't do: "let a = (*) 2"
18:15:30 <monochrom> do you also use an eeepc or eeebox to run haskell? :)
18:15:33 <eee> so a becomes partially applied
18:15:40 <ion> You can do that.
18:15:57 <monochrom> which interactive environment? tryhaskell.org?
18:16:00 <eee> it doesn't work in the try haskell window
18:16:07 <ion> Ah, not ghci then.
18:16:16 <monochrom> right, tryhaskell doesn't support that
18:16:38 <eee> oh
18:16:45 <eee> that was simple
18:16:51 <ion> let â€¦ in â€¦ should work.
18:16:52 <eee> i thought I was retarded
18:17:01 <ion> > let a = (*) 2 in a 3
18:17:02 <lambdabot>   6
18:17:05 <monochrom> you can't define things. you can only ask for answers
18:17:06 <eee> first I thought I was totally getting it
18:17:11 <eee> I see
18:17:21 <eee> so how would I convert that to a let in
18:17:42 <monochrom> after "in" you have to give it something to do
18:18:21 <eee> let's do this thing and return a function that multiplies things by 2 and then send it to 5
18:18:26 <eee> what is the syntax?
18:18:52 <eee> let a = (*) a in a = 2
18:18:56 <eee> like that?
18:18:59 <eee> let a = (*) a in b = 2
18:19:00 <ion> > let a = (*) 2 in a 5
18:19:01 <lambdabot>   10
18:19:02 <eee> I should say
18:19:16 <eee> ooh
18:19:47 <eee> > let a = (*) 2 in a 5
18:19:48 <lambdabot>   10
18:19:50 <eee> cool
18:19:54 <eee> you can do it in here
18:20:25 <christo_m> ivanm: http://hpaste.org/45671/error ,  https://github.com/christomitov/Turnip/blob/master/Parser.hs  with this code
18:20:34 <christo_m> ivanm: trying to add type signatures like you said
18:21:12 <eee> > let a = zipWith (*) [2,2..] in a [1..10]
18:21:13 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:21:17 <eee> nice!
18:21:59 <eee> this book is a lot of fun
18:22:09 <eee> and so is haskell
18:22:26 <hpc> eee: you have no idea; the rabbit hole never ends
18:22:31 <hpc> it's great
18:22:56 <eee> VERY cool that he goes over potential implementations for built in functions
18:23:11 <eee> so you can start to reason about how invinite lists are handled
18:23:48 <shachaf> Which book?
18:23:53 <hpc> lyah i assume
18:24:00 <eee> yeah
18:24:28 <eee> that's why I came in saying, "<eee> i am trying to learn me a haskell for great good"
18:24:50 <eee> hehe
18:26:08 <eee> thanks for explaining that I wasn't crazy
18:26:23 <eee> that environment had me stumped
18:26:52 <hpc> tryhaskell, ghci, lambdabot, and regular files all have their own irritating subtle quirks
18:27:02 <hpc> (well, not regular files, but you know what i mean)
18:27:21 <deech> Hi all, I've seen monads tutorials in many languages, but do they make sense outside Haskell?
18:27:42 <eee> interesting question
18:27:49 <hpc> deech: people have implemented them in lisp and ruby, at least
18:27:58 <eee> i started to think you'd answered it yourself
18:28:02 <hpc> i understand they work reasonably well in lisp
18:28:07 <eee> by saying you found them in other languages
18:28:10 <eee> but you mean
18:28:19 <eee> were they forcing the metaphore
18:28:24 <eee> where it doesn't belong
18:28:41 <ion> deech: http://lists.rabbitmq.com/pipermail/rabbitmq-discuss/2011-April/012214.html
18:29:20 <deech> Well I mean that it is *possible* to implement them in any language you want. But they don't really make sense outside a pure language. Or a statically-typed one.
18:30:16 <christo_m>     Couldn't match expected type `[Stmt]'
18:30:16 <christo_m>            against inferred type `Maybe [Stmt]'
18:30:23 <ion> deech: See above. Erlangâ€™s neither pure or statically typed.
18:30:23 <christo_m> how do i put the Maybe in as a return ?
18:30:47 <ion> > return 42 :: Maybe Int
18:30:48 <lambdabot>   Just 42
18:30:49 <eee> it seems like futures would work
18:30:54 <rien> with common lisp macros they can be made to work exactly as in haskell
18:30:56 <deech> ion: Hmm.. maybe I'm wrong. 
18:31:00 <eee> or an evented system like nodejs
18:31:06 <rien> (at least superficially/syntactically)
18:31:21 <Derander> clojure has something called a future. I'm not sure what it is in haskell
18:31:47 <systemfault> clojure? Future?
18:31:54 <rien> aren't futures like promises? and therefore, non-strict evaluation?
18:31:57 <systemfault> At least, haskell has academic value.
18:31:59 <Derander> systemfault: replying to eee
18:32:10 <blackh> I just did a monad in C++2011.  It isn't quite as abstract because the type system doesn't quite handle it, and the syntax is fairly bad, but it happened to be the best way to solve the particular problem.
18:32:21 <eee> i don't remember for sure about futures in clojure
18:32:23 <Kaidelong> systemfault: I think Clojure and Haskell both have futures of that sort, but it doesn't seem to be what they are talking about
18:32:35 <eee> but what I mean is like in nodejs, you have all non blocking stuff
18:32:51 <Kaidelong> and neither one is "academic" and "research oriented" just means you aren't dead
18:33:12 <eee> you spawn what you want done, and what you want to have happen afterwards
18:33:24 <blackh> deech: My answer to your question is that other languages often have other ways of solving the problem that monads solve in Haskell, but they can still be useful.
18:33:58 <Kaidelong> blackh: More specifically, any problem solved by a monad is already solved some other way in Haskell, monads just generalize those solutions
18:34:15 <Kaidelong> or some more specific way
18:34:31 <eee> that makes sense
18:34:44 <eee> so they are more powerful than what I am talking about
18:34:48 <hpc> IO is maybe an exception, depending on your idea of how to implement it
18:34:49 <eee> ??
18:35:00 <Axman6> eee: ghc's runtime is based on non-blocking IO
18:35:02 <deech> blackh: That makes a lot of sense. When I see monad tutorials in say Javascript I feel as though they're making their language do unnatural things.
18:35:12 <Kaidelong> hpc: I thought there was an IO datatype with stuff in it somewhere in the libraries
18:35:21 <Kaidelong> and the IO monad was not special
18:35:30 <hpc> Kaidelong: hence "depending on..."
18:35:47 <Kaidelong> is >>= implemented with unsafePerformIO?
18:35:55 <Axman6> o.O
18:35:58 <Axman6> why would it be?
18:36:15 <Kaidelong> Axman6: (>>= id)
18:36:21 <eee> a lot of people say not to worry about monads right away in haskell, which is fine with me
18:36:24 <Axman6> IO in GHC at least is a funky state monad
18:36:37 <eee> it's not like if you don't grock them right away, you can't use the language
18:36:44 <Axman6> eee: indeed
18:36:51 <Kaidelong> eee: Absolutely, more accurate to say you don't have to worry about typeclasses right away
18:36:53 <hpc> GHC IO is a lesson for months later
18:36:55 <Axman6> eee: i found them a lot easier to use than to understand
18:37:03 <Kaidelong> if you grok typeclasses monads are a very simple concept from there
18:37:09 <Kaidelong> but IO itself should be dealt with early
18:37:17 <Kaidelong> actually, I think, pretty much immediately
18:37:28 <eee> oh?
18:37:35 <Kaidelong> so that you get used to working with values of type IO
18:37:41 <eee> lyah hasn't gotten there yet
18:37:48 <eee> i'm in higher order functions right now
18:37:58 <deech> eee: True, and actually if you forget about implementation, using the standard monad transformers is quite simple without knowing how they work.
18:38:12 <hpc> i prefer the lyah approach
18:38:17 <Kaidelong> Right but would you be able to make sense of something like "getLine >>= putStrLn"
18:38:26 <hpc> having IO muddying the picture isn't helpful at the start
18:38:33 <eee> my main problem with haskell is that I don't have a project in mind, yet
18:38:35 <hpc> and ghci is a better place to learn syntax and functions
18:38:46 <eee> and actually that is my biggest non-problem too
18:38:52 <hpc> instead of "blah blah this is main..." that plagues so many java courses
18:38:53 <Kaidelong> hpc: I do not know if IO is muddying the picture much unless you really care about details
18:38:55 <eee> because I can take my time going through tutorials
18:39:21 <hpc> eee: you'll find a project when you are good and ready
18:39:25 <Kaidelong> haskell IO is relatively easy to work with and it could potentially be fun to show how you can sequence the stuff together to do for example an interactive number guessing game
18:39:41 <Kaidelong> it's probably easier than IO in Java
18:39:50 <hpc> Kaidelong: "probably" :P
18:39:58 <eee> io in java is a train wreck and a half
18:40:12 <hpc> it is still extra stuff to learn on top of an already wildly different language
18:40:12 <eee> sooooo over modelled
18:40:30 <eee> many things in java are modeled funny
18:40:33 <ion> Hmm. Why does â€˜do { let a = 5\n ; a }â€™ work but â€˜do { let a = 5 ; a }â€™ fail to parse?
18:40:55 <ion> > do { let a = 5; a }
18:40:56 <lambdabot>   <no location info>: parse error on input `}'
18:41:00 <Kaidelong> hpc: but it's such a powerful bit of extra stuff and if you don't go in too deep like file IO it is not that much extra stuff
18:41:24 <deech> Kaidelong: Maybe but explaining the IO monad to a bunch of Java programmers got me a lot o.O's
18:42:00 <hpc> deech: haskell is very hard to explain to java coders
18:42:11 <Cale> ion: Layout rules closing the let for you
18:42:13 * BMeph types "ls <- getLine" and thinks, I Like ghci a lot, at times... ;)
18:42:16 <hpc> deech: they are right square in the middle of the blub problem
18:42:34 <christo_m> Parser.hs:95:47: Couldn't match expected type `[Stmt]' against inferred type `Block'
18:42:36 <Cale> ion: If you're using no layout, you'd want it to be  do { let { a = 5 } ; a }
18:42:39 <hpc> "who needs the features of blurb?" "blob isn't powerful enough"
18:42:47 <christo_m> https://github.com/christomitov/Turnip/blob/master/Parser.hs
18:42:48 <ion> Ah! Thanks.
18:43:01 <deech> hpc: tell me about it, I tried and failed miserably. Almost got the hook rod.
18:43:19 <christo_m> getting it again
18:43:26 <christo_m> more type signatures?
18:43:33 <eee> do y'all want to know what I think messes up ALL languages?
18:43:35 <Kaidelong> <Kaidelong> and later when you get into stuff like backtracking algorithms with the list monad
18:43:36 <Kaidelong> <Kaidelong> IO would give you a good analogy
18:43:40 <eee> this is a serious problem
18:43:50 <Kaidelong> sure!
18:44:09 <deech> eee: if the answer's human I agree.
18:44:11 <eee> web browsers come with javascript . . .and now with chrome, action script
18:44:24 <djahandarie> ezyang, your blog seems to have blown up.
18:44:24 <eee> or whatever flash is
18:44:29 <eee> sooooo
18:44:36 <eee> you always need two languages
18:44:46 <Kaidelong> eee: Not neccessarily
18:44:51 <eee> or a transform between language x and javascript
18:44:56 <Kaidelong> in the ML likes and the Haskell likes
18:45:01 <eee> server side html generation is broken
18:45:02 * BMeph wouldn't mind seeing a browser with Lua built in...
18:45:08 <Kaidelong> it is common to have a DSL that compiles to some other language
18:45:10 <eee> you need to stay on the client many times
18:45:11 <Kaidelong> usually FORTRAN
18:45:29 <hpc> eee: untrue: http://hpc.dyndns-web.com:8000/blog/
18:45:39 <deech> eee: I don't see anything wrong with having >1 language in a project.
18:45:52 <hpc> html isn't a language so much as a format, and it is common for scripting languages to run generated code
18:45:55 <Kaidelong> the other thing I was about to mention deech pretty much covered
18:46:05 <Kaidelong> the problem with that is that our build systems and tools tend to suck
18:46:20 <eee> well, >1 lang may be ok. but a native haskell interpreter in my browser would be better
18:46:24 <Kaidelong> MSBuild is actually pretty good just by the lack of better things
18:46:31 <hpc> ew
18:46:38 <eee> i will look at this transform thing
18:46:41 <eee> but
18:46:41 <hpc> html+javascript is enough for a browser
18:46:46 <Axman6> eee: why not install the haskell platform and get the full powered GHCi?
18:47:03 <hpc> more languages will just make browsers fatter and web devs more confused
18:47:09 <eee> somehow I bet it limits my ability to use, say lib x
18:47:13 <eee> like jQuery
18:47:15 <deech> eee: Javascript isn't a bad language. I don't see a reason to generate it.
18:47:16 <eee> Axman6
18:47:23 <Kaidelong> hpc: A restricted kind of CLI/LLVM/JVM kind of thing would be a better idea really
18:47:27 <eee> I have it on my apple
18:47:41 <eee> but not when I'm casually surfing on someone else's machine
18:47:43 <Kaidelong> the main problem is the broken idea of sending a plaintext HTML document with plaintext script embedded in it
18:47:46 <eee> at a party or whatev
18:47:54 <deech> Kaidelong: Have you looked into Shake(http://community.haskell.org/~ndm/shake/) at all?
18:47:55 <hpc> there's apparently a unique brand of crazy people that run javascript web servers
18:48:00 <acowley> Kaidelong: I don't see that as broken, necessarily
18:48:13 <deech> hpc: Node.js folks you mean?
18:48:14 <acowley> How about having a CLR in the browser, and install compilers as extensions?
18:48:20 <acowley> The browser could ship with a few
18:48:29 <hpc> deech: i think so; i only vaguely remember
18:48:40 <hpc> too tired to look it up
18:48:43 <eee> i mentioned nodejs
18:48:45 <eee> see
18:48:46 <hpc> i should probably be sleeping
18:48:49 <eee> so with nodejs
18:48:52 <Kaidelong> acowley: I suppose in some cases the source code might be smaller than the binary, now that I think of it
18:49:14 <eee> here's the project
18:49:19 <eee> a new browser
18:49:19 * hpc really doesn't want to have to install MORE plugins
18:49:20 <deech> hpc: Yeah it's weird. It was built explicitly so that front-end dev's could do server-side stuff too.
18:49:25 <eee> it supports haskell natively
18:49:30 <eee> no transform
18:49:30 <acowley> I think it's just hard to overstate the impact View Source has had on the development of the web
18:49:31 <eee> done
18:49:34 <hpc> have one markup language, one scripting language
18:49:36 <acowley> it really brought open source to the masses
18:49:40 <Kaidelong> hpc: if the runtime in your browser has a good sandbox it could be done pretty transparently
18:49:44 <hpc> that's all you really need, and just improve those
18:49:46 <acowley> hpc: I know, I don't love the idea
18:49:58 <acowley> hpc: I don't buy that
18:50:03 <eee> let's stick ghci in a browser
18:50:11 <hpc> anyhoo, i should sleep
18:50:12 <acowley> hpc: If more apps are done in the browser, how is it different than any other computing platform?
18:50:14 * hpc leaves
18:50:18 <Kaidelong> see you
18:50:25 <eee> bye hpc
18:50:30 <eee> thanks
18:50:31 <acowley> We should follow him and challenge his faith in Javascript
18:50:33 <hpc> you can @msg me if the point is important enough
18:50:38 <Kaidelong> actually you could end up just thinking of the browser as a "sandboxed runtime"
18:50:50 <eee> yup
18:50:52 <hpc> and i didn't say javascript should be the scripting language, anyway :P
18:50:54 <deech> eee: I don't see a use-case. You would be forgoing all the great Javascript work that's been done so far.
18:50:57 <hpc> seriously im going lol
18:51:05 <Kaidelong> HTML5+JavaScript is very heavyweight
18:51:12 <acowley> Kaidelong: which is how I'd like to think about it, but I still think View Source has a lot of upside
18:51:14 <Kaidelong> something like the CLI or JVM need not be
18:51:27 <eee> people are moving forward without taking a step back
18:51:40 <eee> is javascript the last language? can't be
18:51:56 <eee> haskell forges it's own path
18:52:03 <eee> how many years has it been going on?
18:52:04 <eee> 25?
18:52:11 <acowley> Yes
18:52:15 <eee> so what will the browser be in 25 yrs
18:52:15 <Kaidelong> acowley: The social advantage is perhaps significant here, I do wonder how much you can really hide with cross platform bytecode though
18:52:18 <deech> eee: No but it is the main language until the trend swings back to native apps.
18:52:31 <eee> the browser is a native app
18:52:44 <acowley> Kaidelong: I think it's also the implicit learning opportunity every page provides for the would-be web developer
18:52:44 <eee> would be fun to build my own native app
18:52:45 <ion> The script language could be the markup language as well. ;-) (html (head (title "foo") (script (on-click "foo" (alert "x")))) (body (h1 "o hai") (p (id "foo") "bye")))
18:52:47 <Kaidelong> deech: That might not happen
18:52:58 <eee> be back in a bit
18:53:03 <eee> some tv show on
18:53:04 <napping> can "dimensional" compute angular momentum?
18:53:11 <Kaidelong> especially since companies can protect their IP better by providing "web services" instead of applications in a box
18:53:17 <eee> thanks for the help and ideas
18:54:00 <deech> Kaidelong: As smartphones approach what desktops were 5 years ago native apps will become more important.
18:54:17 <jmcarthur> heck there have even been experiments with running AAA games on servers and streaming video to the clients
18:54:22 <Kaidelong> hmm, what kind of native apps though?
18:54:42 <Kaidelong> perhaps they will simply be clients for the real things closely guarded on servers
18:54:52 <acowley> I love it when programmers try to name apps that everyone needs
18:55:14 <Kaidelong> acowley: web browser
18:55:15 <acowley> There's emacs
18:55:27 <Kaidelong> and err I guess that's about it
18:55:29 <jmcarthur> everyone needs version control, duh
18:55:35 <acowley> ok
18:55:45 <ion> Everyone needs ghci.
18:56:05 <Kaidelong> "want" vs "need" going on here ion?
18:56:13 <acowley> Kaidelong: no, if the browser is the platform, then what are the apps that everyone needs/wants that will be delivered in the browser
18:56:19 <deech> Kaidelong: Not all apps need to access remote resources. Where I currently we make medical image processsing software and most of that is still native.
18:56:31 <rien> oh, was it Oleg who came up with Iteratees? suddenly I don't feel so bad for not understanding them :)
18:56:34 <acowley> deech: write it elisp
18:56:35 <deech> Kaidelong: Audio processing.
18:57:07 <Kaidelong> acowley: Email, and probably games is a near universal "need" for people.
18:57:16 <Kaidelong> in that they will buy them reliably
18:57:16 <jmcarthur> i call this process of putting everything in the web browser googlification
18:57:27 <acowley> yeah, I think games is a big part of it
18:57:38 <jmcarthur> because google seems to be leading the way, at least regarding typical office apps and such
18:58:10 <jmcarthur> people buy games reliably, but games are not a reliable market :(
18:58:13 <jmcarthur> it's very trendy
18:58:19 <Kaidelong> jmcarthur: It is interesting to compare Google Docs to Office Live
18:58:33 <Kaidelong> Google Docs has really easy ways to work collaboratively
18:58:34 <deech> acowley: What do you mean?
18:58:48 <Kaidelong> but Office Live gives you a bit more fine-tuned control over your document
18:58:59 <deech> Kaidelong: Only now that they've acquired Etherpad. Before it was a pain.
18:59:08 <Kaidelong> although they might have caught up with each other since I last used Office Live
18:59:13 <acowley> deech: just being silly to defend my stance that emacs is the primary native app that everyone needs
18:59:17 <jmcarthur> one big appeal to online apps is that you can access your stuff from any machine
18:59:41 <jmcarthur> and another is the potential for easy sharing and collaboration
18:59:44 <Kaidelong> jmcarthur: the real glee is when you can send someone a link to view your document and it'll always be up to day
18:59:46 <Kaidelong> date
18:59:49 <jmcarthur> yup
18:59:54 <acowley> jmcarthur: and, implicitly, backups
19:00:01 <jmcarthur> acowley: (hopefully)
19:00:10 <Kaidelong> right now I'm sharing the grade sheet with my professor over google docs
19:00:13 <acowley> (once it's someone else's problem, it's off my mind)
19:00:27 <Kaidelong> so that he can watch how I've progressed with grading his students the moment I do it
19:00:55 <Kaidelong> and alter them as needed
19:00:55 <deech> jmcarthur: I agree, I still harbor a fantasy that someday an "online" app will consist of downloading the source, compiling it and running it natively.
19:01:34 <deech> That way we don't end up with these behemoth apps like Firefox that suck up all my memory and CPU.
19:02:11 <deech> jmcarthur: I meant on-the-fly.
19:02:37 <Kaidelong> I see the standardization efforts around JavaScript and HTML as damage control around a fundamentally broken design
19:03:13 <Kaidelong> excarbated by competition between browser developers
19:03:40 <Kaidelong> probably one of the examples where you can point to competition basically making everyone lose
19:04:51 <jmcarthur> i'd say the bigger problem is that non-developers are largely unaffected by these issues, yet they get to choose the vendor
19:05:10 <jmcarthur> s/unaffected/unknowingly affected/
19:05:57 <jmcarthur> deech: i, too, think that would be super cool
19:06:34 <Kaidelong> what is perhaps a bit more frustrating is that the ECMAScript people want to make a good language, which is all well and good but a "language" isn't what you really need there
19:06:42 <BMeph> If you're declaring something to be Functor, APplicative and Monad, is there a conventional order/priority in which to put down your definitions?
19:06:47 <Kaidelong> rather a platform to build arbitrary languages on
19:06:53 <Axman6> deech: you've seen NaCl right?
19:06:55 <ion> deech: Google NaCl?
19:07:07 <Axman6> heh
19:07:53 <Kaidelong> your script tag could have metadata like "grab my compiler here if you do not have it"
19:07:54 <acowley> BMeph: Functor then Applicative then Monad
19:08:21 <Kaidelong> or
19:08:27 <Kaidelong> you could use the existing attributes
19:08:38 <Kaidelong> which attributes did script have again?
19:09:05 <Kaidelong> I guess you could use type
19:10:27 <christo_m> acowley: 
19:10:38 <christo_m> Parser.hs:95:47: Couldn't match expected type `[Stmt]' against inferred type `Block'
19:10:49 <christo_m> i cant find out what im doing wrong
19:10:53 <christo_m> bad type signature?
19:11:19 <Kaidelong> well it got a block where you want a list of statements
19:11:29 <Kaidelong> is there a way to turn a block into a list of statements?
19:11:40 <christo_m> put Block before it
19:11:55 <christo_m> oh wait
19:12:02 <christo_m> a block into alist of statements, no
19:12:21 <Kaidelong> what was returning the block then?
19:12:45 <christo_m> ifStmt
19:13:11 <christo_m> the Block df is wrong
19:13:13 <christo_m> apparently
19:13:48 <christo_m> Kaidelong: https://github.com/christomitov/Turnip/blob/master/Parser.hs here at line 95
19:14:01 <christo_m> well 94
19:14:37 <acowley> The If data constructor wants a Maybe Block
19:15:18 <acowley> You want optionMaybe
19:15:19 <christo_m> yes,i dont know how to return a aMaybe block
19:15:27 <acowley> instead of option
19:15:57 <Kaidelong> @hoogle optionMaybe
19:15:57 <lambdabot> Text.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
19:15:57 <lambdabot> Text.ParserCombinators.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
19:15:58 <acowley> df <- optionMaybe (reserved "else" >> block >>= return . Block)
19:16:05 <Kaidelong> ah parsec
19:16:38 <acowley> then end ifStmt with If (...) df
19:16:43 <acowley> where (...) is what you have
19:17:04 <azaq23> Is there a haskell library for basic symbolic math? Sort of the stuff you can do on a TI Voyage 200, only better and with a less sucky interface. I know about simple-reflect, but that's just for showing and reducing haskell expressions in a basic way
19:17:48 <acowley> azaq23: not that I know of
19:18:09 <acowley> learn maxima?
19:18:13 <Axman6> > deriv (sin + cos) x
19:18:13 <lambdabot>   1 * cos x + 1 * negate (sin x)
19:18:20 <acowley> you can always drop into lisp and walk over expressions
19:18:23 <Axman6> > deriv (sin + cos ^ 2) x
19:18:24 <lambdabot>   1 * cos x + (1 * negate (sin x) * cos x + cos x * (1 * negate (sin x)))
19:18:43 <Axman6> > reduce $ deriv (sin + cos ^ 2) x
19:18:44 <lambdabot>   1 * cos x + (1 * negate (sin x) * cos x + cos x * (1 * negate (sin x)))
19:18:53 <christo_m> *Parser> parseTest program "if 3.0 > 4.0 then break end"
19:18:53 <christo_m> Block [If [(BinOp ">" (Number 3.0) (Number 4.0),Block [Break])] Nothing]
19:18:55 <christo_m> yes? haha
19:19:01 <christo_m> oh geez, how am i gonna walk through that.
19:19:08 <christo_m> and populate my a-list
19:19:53 <acowley> Write a function with type Stmt -> Env
19:20:01 <azaq23> Well, if deriv exists somewhere, there is likely more
19:20:36 <acowley> and break it down by case
19:20:47 <acowley> gotta go now, good luck as always christo_m
19:20:55 <christo_m> thank youuu
19:21:35 <confound> w 22
19:22:02 <azaq23> going to look after that first :) Yes, maxima and so on could also be a solution, but I asked because I finally wanted to start writing simple blog entries out of the stuff I write anyways all day long, and I planned to do it by writing .lhs files and putting those up, easiest solution
19:23:28 <BMeph> christo_m: It's likely not a priority, but still: on line 37 of LuaAS, you probably want a name tag to make an Expr a type of Stmt. As it is now, it's just acting like another flag value, like "Break". :)
19:25:58 <christo_m> BMeph: i know! i was wondering if i should
19:26:04 <christo_m> but im following the grammar from the lua reference
19:26:15 <christo_m> BMeph: http://www.lua.org/manual/5.1/manual.html#8
19:26:56 <christo_m> oh wait i see
19:26:58 <christo_m> what you're talking about
19:28:24 <Kaidelong> Axman6: Why is deriv a function there! That's so untowerly
19:28:43 <Axman6> what?
19:29:01 <Kaidelong> should be a data constructor like Deriv
19:29:19 <Axman6> o.O
19:29:22 <Kaidelong> that way you can reverse it!
19:29:27 <Axman6> why? it finds the derivative of a function
19:29:50 <Axman6> you can easily reverse it... but not applying deriv to it...
19:30:00 <Kaidelong> and using typeclass magic the derivative remains an applicative function
19:30:05 <Kaidelong> hmm can you?
19:30:12 <Axman6> yes...
19:30:16 <Kaidelong> I thought there is no general way to do symbolic antidifferentiation
19:30:20 <Axman6> > (sin + cos) x
19:30:21 <lambdabot>   sin x + cos x
19:30:26 <Axman6> > deriv (sin + cos) x
19:30:27 <lambdabot>   1 * cos x + 1 * negate (sin x)
19:30:30 <Axman6> > (sin + cos) x
19:30:31 <lambdabot>   sin x + cos x
19:30:32 <Axman6> reversed!
19:35:29 <azaq23> That this actually works by 1. defining an instance for numeric differentiation in Data.Number.Dif, which just knows about standard derivatives and 2. just giving the resulting function a SimpleReflect.Expr value is kind of fascinating, one should be able to use the same procedure for just about anything of interest
19:36:20 <azaq23> anything simple at least
19:37:03 <ddarius> "compositional"
20:10:43 <stepkut> does anyone know of a fuzzy time diff library? a type like, fuzzyAgo :: UTCTime -> UTCTime -> String, which produces things like 10 seconds ago, 5 minutes ago, 2 days ago..
20:11:01 <stepkut> not hard to write obviously, but if it already exists..
20:11:47 <stepkut> or maybe it should just take a NominalTimeDiff
20:15:09 <stepkut> I guess the tricky part if you use NominalTimeDiff would be 'x months' ago
20:27:26 <stepkut> if you are bored, here is a very that is not very elegant, http://hpaste.org/45672/fuzzy_diff_time
20:28:03 <lispy> everyone can relax, I'm back
20:28:17 <lispy> I know all of you were worried
20:28:40 <christo_m>  i was for sure
20:28:54 <christo_m> prepare to be raped with compiler questions
20:29:10 <lispy> oh god.  Look at the time :)
20:29:14 <christo_m> hahah
20:29:25 <lispy> christo_m: did you figure out why Reader is nice?
20:29:35 <christo_m> lispy: no, we had a debate here and i settled with lists
20:29:41 <christo_m> a-lists to be specific
20:29:50 <Axman6> a-lists?
20:30:16 <christo_m> association list, just a list of name/value pairs
20:30:34 <Axman6> sounds like a good place to use a Map
20:30:39 <lispy> christo_m: assocLists are fine.  That's probably what you would store in the reader
20:30:51 <christo_m> so this is more dynamic scoping
20:31:03 <christo_m> Axman6: ya i looked at it, but i don't think the performance boost is worth it right now
20:31:07 <christo_m> especially because i have no clue what im doing
20:31:14 <lispy> christo_m: basically, when you want all your functions to have access to some implicit set of values, it's a good time to use a reader
20:31:36 <christo_m> lispy: ya i saw why, you dont want to be passing the environment as a parameter to every combinator
20:31:42 <christo_m> i understand it, i just dont know how to implement it
20:31:55 <christo_m> it's a weird conundrum
20:32:27 <lispy> I used one in a compiler I wrote.  I can show you the relevant code if you think it would help
20:32:46 <christo_m> yes please
20:32:55 <christo_m> how did you deal with shadowing and what not
20:32:57 <lispy> But, since you're doing this as homewore, I don't want to feel like I'm giving you the solution
20:33:08 <lispy> just pull from the start of the assocList
20:33:11 <christo_m> im not going to rip your code unless i understand it
20:33:14 <lispy> so when you shawdow you prepend
20:33:51 <lispy> christo_m: here is my codegen monad
20:33:52 <lispy> https://github.com/dagit/helisp/blob/master/src/CodeGen.hs
20:34:04 <lispy> christo_m: take a look at lookupVar
20:34:23 <lispy> and there is extendVars too
20:34:32 <lispy> I'm using a map
20:35:03 <christo_m> ya i see that
20:35:15 <lispy> christo_m: and here is a module where I put it to use: https://github.com/dagit/helisp/blob/master/src/Compile32.hs
20:36:37 <christo_m> oh i see, this is the actual code emitting here
20:37:05 <christo_m> now , does your stack pointer point at beginnigs of stack frames
20:37:15 <lispy> christo_m: yeah well.  My CodeGen monad uses a Reader to store bindings and a Writer to buildup a list of machine instructions
20:37:18 <christo_m> like if you're in a while loop, you would keep repointing to the beginning of that frame for that block?
20:37:41 <lispy> I don't recall now. I haven't touched that code since circa 2005
20:37:55 <lispy> But you could probably figure it out from reading the code :)
20:38:31 <lispy> christo_m: I don't recall implementing loops.  I was making a lisp/scheme compiler
20:39:08 <christo_m> i know, im saying as an example
20:39:13 <christo_m> because ill need to implement loops :|
20:47:01 <ddarius> christo_m: Laziness can be used in a clever way to handle forward references.
20:50:15 <Jafet> I, too, find loops often to be ill needed.
20:50:50 <ion> ddarius: Please elaborate.
20:51:03 <lispy> recursive do
20:51:44 <Jafet> http://haskell.org/haskellwiki/Tying_the_Knot
20:51:47 <lispy> ion: check out the last article here, it explains it: http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
20:51:53 <ion> Thanks!
20:51:53 <christo_m> ddarius: ill figure it out when i get there i guess
20:52:04 <christo_m> if i get a basic calculator here ill be happy
20:52:34 <christo_m> i want to do as many components as possible, i still havent dealt with any real code generation, so.. after i get the smallest possible subset of the language working(namely arithmetic expressions) ill worry about branching and control flow
20:52:44 <Azverkan> noob question: why does fail to halt in ghci?          compare (length [1..2]) (length [1..])
20:52:46 <lispy> christo_m: oh, I know how to answer you're question.  I would generate a label and jump to it as needed.
20:53:11 <christo_m> lispy: yes i figured thats the best, but it sounds so imperative style
20:53:29 <azaq231> Azverkan: [1 ..] is an infinite list.
20:53:31 <christo_m> i kind of didnt mind your stack pointer concpet there,
20:53:43 <christo_m> call stack was brought up by monochrom earlier i think
20:53:45 <Jafet> Azverkan: length [1..] is bottom, because Int is a flat type.
20:53:54 <lispy> christo_m: programming assembly generally is imperative, even when the language that you're compiling isn't.
20:54:03 <Azverkan> yeah, but you don't have to evaluate the entire list to compute the result of the compare?
20:54:20 <ion> It compares the lengths, not the lists.
20:54:39 <Azverkan> but isn't the length of the list lazy evaluated too?
20:54:46 <lispy> yes, but it can't see that the second length is greater than the other one without fully evaluating the return value of length
20:55:04 <lispy> if you had lazy naturals it could do the comparison without fully evaluating the int
20:55:11 <Jafet> Azverkan: yes, but length [1..] is bottom; it cannot be represented in Int.
20:55:27 <lispy> > genericLength [1..] :: CReal
20:55:29 <lambdabot>   *Exception: stack overflow
20:55:49 <lispy> Is there a way to take n digits of a CReal?
20:56:12 <Jafet> How would that help? Infinity has no digits.
20:57:14 <lispy> Well, do it on a finite list.  I just wanted to see if I could demonstrate a lazy numeric type
20:57:26 <davidL> :t showCReal
20:57:27 <lambdabot> Int -> CReal -> String
20:59:13 <lispy> > showCReal 5 $ genericLength [1..2^32]
20:59:14 <lambdabot>   "*Exception: stack overflow
20:59:23 <lispy> > showCReal 5 $ genericLength [1..2^16]
20:59:27 <lambdabot>   mueval-core: Time limit exceeded
20:59:35 <lispy> hmrph.
20:59:42 <lispy> > showCReal 1 $ genericLength [1..2^10]
20:59:43 <lambdabot>   "1024.0"
21:00:52 <lispy> davidL: Hmm...is it for showing N digits after the decimal?
21:00:56 <lispy> > showCReal 0 $ genericLength [1..2^10]
21:00:57 <lambdabot>   "1024"
21:01:05 <lispy> > showCReal (-1) $ genericLength [1..2^10]
21:01:05 <lambdabot>   "*Exception: Negative exponent
21:01:12 <davidL> > showCReal 5 pi
21:01:13 <lambdabot>   "3.14159"
21:01:18 <Jafet> In your dreams.
21:01:30 <Jafet> CReal is very frugally implemented
21:01:54 <lispy> > showCReal 20 pi
21:01:55 <lambdabot>   "3.14159265358979323846"
21:02:17 <lispy> > showCReal 200 pi
21:02:18 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
21:02:25 <lispy> weee!  (okay, i'll stop)
21:11:00 <osoleve> i think everybody should go check stack overflow, there could be a new question up in the Haskell domain
21:11:05 <osoleve> hint, hint >.>
21:11:35 <copumpkin> it'd be easier for us to look at it if you just linked to the question that may have been asked
21:11:58 <osoleve> i didn't want to be THAT overt, but... if you insist
21:12:01 <osoleve> http://stackoverflow.com/questions/5658391/generating-wav-sound-data-in-haskell
21:12:39 <copumpkin> dude average isn't right!
21:13:14 <osoleve> uh oh
21:13:23 <copumpkin> musically, I mean
21:13:35 <copumpkin> :P
21:13:38 <osoleve> ah
21:13:41 <osoleve> you scared me
21:13:41 <Jafet> Bah, even Nat is tricky to write lazily: http://codepad.org/hHzrEgeH
21:13:44 <ion> Writing frequencies for notes manually is not the best idea.
21:13:53 <Jafet> I want my lub now
21:13:59 <ion> s/freq/approximations of freq/
21:14:22 <ion> Ah, averaging is even worse. :-)
21:14:41 <osoleve> how do I correctly average the two notes?
21:15:10 <ion> You donâ€™t. You compute 440 Hz Â· 2^(note/12) where note is an integer.
21:15:14 <shachaf> Jafet: even Z = True; even (S n) = odd n
21:15:23 <shachaf> There you go, even Nat.
21:15:45 <osoleve> ion: ooh
21:15:59 <ion> note=0 signifying the middle A
21:16:15 <copumpkin> you could average two notes by just taking their geometric mean
21:16:20 <copumpkin> ...I think
21:16:38 <Jafet> You end up with average notes!
21:16:49 <osoleve> guest1 why are you doing C++?
21:16:54 <osoleve> erg, wrong channel
21:16:57 <copumpkin> this is assuming equal temperament, of course
21:17:21 <shachaf> Equal temperament is evil.
21:17:27 <lispy> osoleve: I don't watch SO because they don't seem to provide any ways to watch it
21:17:37 <lispy> osoleve: short of obsessively hitting reload that is
21:17:57 <Jafet> I have a right to moody temperaments!
21:18:12 <shachaf> But then so is unequal temperament.
21:18:14 <ddarius> copumpkin: Yes.
21:18:35 <lispy> osoleve: the closest I've found is using twitter, but even that seems to have a 15+ minute delay and usually questions are answered by then so I stopped bothering.
21:19:33 * ddarius cleverly stopped bothering before he started.
21:19:55 <osoleve> ion: so A is 0, B is 1, C 2? how do I number the notes?
21:20:22 <Jafet> That code assumes equal temperament, because it defines all the overlapping notes to be enharmonic.
21:21:53 <ion> > let avg a b = 2**((logBase 2 a + logBase 2 b)/2) in (avg 440 880, 440*2**0.5)
21:21:54 <lambdabot>   (622.253967444162,622.2539674441618)
21:22:55 <ion> osoleve: What do you mean by numbering the notes? A means 0, A# means 1, B means 2, C means 3.
21:24:42 <ion> 440 Hz Â· 2^octave is the frequency of A for a given octave. An octave is split to 12 notes, so 2^(note/12) where an increment of 12 will result in a full octave.
21:24:42 <ddarius> ion: That's a crappy implementation of the geometric mean. 2**((a+b)/2) = sqrt(2**a * 2**b)
21:26:20 <copumpkin> > sqrt (440 * 880)
21:26:21 <lambdabot>   622.2539674441618
21:26:58 <shachaf> > 440 * sqrt 2
21:26:58 <lambdabot>   622.2539674441618
21:31:24 <azaq231> Jafet: In your Nat code, you defined (*) wrong
21:42:28 <ion> ddarius: noteAvg a b = sqrt (a Â· b) can be lead from noteAvg a b = 2^(0.5Â·(log_2 a + log_2 b)) easily, but the reasoning for the equation is more obvious in the latter one.
21:46:47 <ion> I.e. go from logâ‚‚ scale to linear scale, compute the average in there, go back to logâ‚‚ scale.
21:47:06 <osoleve> ion: did I fix that function?
21:47:08 <osoleve> http://stackoverflow.com/questions/5658391/generating-wav-sound-data-in-haskell
21:47:13 <osoleve> (just got done with it)
21:47:34 <christo_m> BMeph: https://github.com/BMeph/Ganymede/blob/master/ganymede-0.0.0.4/Io/Env.hs <- i noticed you implemented the environment as a pair of lists
21:47:40 <christo_m> could you explain?
21:49:51 <ion> osoleve: Youâ€™ll probably want to have the function return Just n for valid strings and Nothing (instead of 15.0) for invalid ones.
21:52:33 <ddarius> ion: And why is the arithmetic mean gloriously intuitive and the geometric mean not?
21:53:10 <ion> osoleve: Youâ€™ll probably want 440 Hz Â· 2^(octave + (noteâˆ’9)/12) where note=0 for C, note=1 for C#, note=9 for A.
21:58:36 <osoleve> how do I get a number unwrapped from Just?
21:59:01 <dibblego> osoleve: what if it is not Just?
21:59:32 <osoleve> then it's Nothing
21:59:41 <dibblego> what number do want then?
22:00:02 <osoleve> it should throw an error, I guess :/
22:00:22 <dibblego> eek! are you sure? sounds like potential for improvement
22:00:30 <Jafet> :t fromJust
22:00:31 <lambdabot> forall a. Maybe a -> a
22:00:32 <Jafet> :t maybe
22:00:33 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:00:45 <Bfig_> can you help me here? http://pastebin.com/ebeuD6j6
22:00:49 <osoleve> dibblego: if it's Nothing, it means the file it's reading from has bad data
22:00:49 <Jafet> As you can see, the latter is preferable
22:01:05 <dibblego> osoleve: so you want the program to explode or do something nice?
22:01:12 <Bfig_> i'm getting this weird type error... and as far as i can see the result of the function in question iis not even used
22:01:39 <osoleve> dibblego: it's a toss up, really. but I guess exploding is considered a Side Effect, so, do something nice.
22:01:53 <dibblego> osoleve: side-effect aside, it's also not nice right?
22:01:59 <BMeph> christo_m: One list has IORefs for continuations and identifiers, and one for declared mutables, which is a list of IORefs of IORefs.
22:02:02 <Bfig_> i've been struggling with this error four hours by now
22:02:10 <dibblego> osoleve: what do you do with this number?
22:02:35 <osoleve> dibblego: use it to create a WAVESample
22:02:40 <ion> :t \a -> (>>=) a `const` (a :: Maybe a)
22:02:41 <lambdabot>     Inferred type is less polymorphic than expected
22:02:41 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
22:02:41 <lambdabot>         a :: Maybe a (bound at <interactive>:1:1)
22:02:50 <Bfig_> ohh shit.. shit shit shit. " -> '
22:03:07 <Bfig_> 4 hours... one double comma.
22:03:27 <Bfig_> haskell type system : 1. bfig = -30
22:03:36 <BMeph> christo_m: TBH, it isn't my design, and as soon as I'm confident it's working like the original is, and that I understand it and how it works, I plan to re-do it.
22:10:37 <osoleve> dibblego: did you give up on me? D:
22:10:47 <dibblego> ha no, sorry distracted
22:10:53 <osoleve> oh, ok :)
22:11:17 <dibblego> osoleve: so you have a Maybe Int right? and you use the Int to create a WAVESample
22:11:30 <osoleve> well, Maybe Double, but yeah
22:11:42 <dibblego> ok, so use the fmap function to get you a Maybe WAVESample
22:12:03 <dibblego> don't ever step out of the Maybe until you get to main and run your side-effect
22:12:30 <ion> > show $ 42
22:12:31 <lambdabot>   "42"
22:12:33 <osoleve> okay, i'll give that a shot
22:12:37 <ion> > show <$> Just 42
22:12:38 <lambdabot>   Just "42"
22:12:39 <osoleve> back in a moment
22:13:46 <ion> You may want to consider Either if you want to provide the error message as a string.
22:25:23 <osoleve> dibblego: I have two sections I can't work out, think you could take a look? :3
22:27:28 <shachaf> osoleve: Why dibblego and not the channel (of which dibblego is part)?
22:27:43 <osoleve> shachaf: I dunno, he was helping me
22:27:49 <osoleve> no offense intended, I love you all!
22:28:13 <osoleve> http://codepad.org/i33QLsSl
22:28:50 <osoleve> in notesToSamples, I get Couldn't match expected type 'Maybe WAVESample' with actual type 'Int32'
22:29:11 <osoleve> and in constructWAVE, it's the opposite
22:45:32 <nejucomo> How do I convert an Integer to a Fractional?  Or rather, I have an Integer, I want to divide it by a Float and get a Float.
22:45:47 <shachaf> @ty fromIntegral
22:45:48 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:45:48 <Maxdamantus> fromIntegral
22:45:58 <nejucomo> Ah, thanks!
22:52:11 <osoleve> could someone help me with dealing with some Just values?
22:52:25 <osoleve> http://codepad.org/i33QLsSl notesToSamples and constructWAVE don't work :/
22:56:55 <osoleve> the errors are here: http://codepad.org/KHKkrPNu
23:07:16 <mjs22> I'm having trouble figuring out this error : "No instance for (Monad ((,) a0))".  I see things like (Monad ((->) r)) in Control.Monad and Control.Monad.Instances, but no Monad((,) r), just Functor((,) r).  Anyone know what could cause that error?
23:08:58 <shachaf> @instances Monad
23:08:59 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
23:09:22 <shachaf> mjs22: The fact that there is no Monad instance for (,) causes the error.
23:09:55 <mjs22> sure - I'm just a bit puzzled as to why I'm seeing that.  I'm working on a modification of the code posted here : https://intoverflow.wordpress.com/2010/07/20/i-come-from-java-and-want-to-know-what-monads-are-in-haskell/
23:10:43 <shachaf> mjs22: What instance are you expecting to find for (,)? Writer?
23:11:17 <mjs22> yes
23:11:35 <shachaf> Well, that instance isn't defined. It's also not general-purpose like (r ->).
23:13:34 <christo_m> https://github.com/christomitov/Turnip/blob/master/Parser.hs  , any reason why my if statement parsing says unexpected " " , after my expression and before the "then" keyword?
23:14:00 <christo_m> im just trying to parse the code in the test folder
23:24:29 <BMeph> christo_m: Your "expr" is built from a buildexpression, so it doesn't do the "auto-eat spaces" thing that the rest do. Add a "lexeme $" in front of it, qualified by whatever it needs to bring it into scope. I'll check it and twiddle my fork. :)
23:27:49 <christo_m> BMeph: that actually wasnt the problem, i have to explicitly make every Number floats right now
23:28:00 <christo_m> BMeph: i cant read ints into Number because it has a Double type.
23:29:17 <christo_m> BMeph: the fix was just some editing of the program, of course at the end it shouldnt matter if its int or float, but right now i dont care
23:41:13 <ski> osoleve : well, the errors say what's wrong ..
23:42:38 <ski> osoleve : in `notesToSamples' you call `doubleToSample' on each `Double' element on the list, which will give you a `WAVESample' back, but in your type signature you specify that each list element in the result should be a `Maybe WAVESample' .. which of those do you want ?
23:43:11 <Athas> sjanssen: do you know if there's a deeper reason X11 doesn't wrap XUtf8LookupString and its cousins?
23:43:18 <ski> if you really want `Maybe WAVESample', then you need to insert a `Just' around each element, otherwise you should change the type signature
23:44:21 <ski> osoleve : also in `notesToSamples', `f <- freqs' will make `f' into a `Maybe Double', but then you try to multiply `f' with something .. probably you want to change something here as well
23:46:04 <ski> in `noteToFreq' i'd use guards instead of `if'-`then'-`else'
23:46:54 <ski> the `_    -> 12.0' case and then the `n /= 12.0' check there looks kludgy, i'd try to avoid doing that
23:47:39 <BMeph> christo_m: Why not use numberOrFloat and conver any Integer results to Doubles?
23:49:12 <christo_m> BMeph: thats what i was going to do
23:49:25 <christo_m> then i couldnt figure out fromIntegral and where to put it to make it work
23:49:27 <christo_m> so i did something else
23:52:57 <sjanssen> Athas: no.  The bindings have been written on an as-needed basis, I guess those functions haven't been missed yet
23:53:46 <Athas> I miss them. :-) I'll try to implement at least one of them and send a patch if I succeed.
23:53:55 <Athas> This is the first time I've really done nontrivial FFI stuff...
