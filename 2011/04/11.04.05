00:00:17 * dark wants @src on ghci
00:00:25 <Axman6> you can get it
00:00:28 <dark> also @djinn :)
00:00:33 <dark> uhm?
00:00:34 <Axman6> install GoA, GHCi on Acid
00:00:43 <dark> interesting
00:00:49 <Axman6> not sure if it still works though
00:02:39 <Veinor> i've gotten it to work
00:03:04 <Cathaa> why does haskell have appeal to pure mathematicians and what can a pure mathematician do with it
00:04:50 <zenzike> Cathaa: the mathematicians I know like it because it's programming with functions that can be higher order and recursive
00:05:14 <zenzike> in that respect the language is very close to mathematical syntax
00:06:02 <dark> Cathaa, it has a nice semantics, one can reason quasi-logically with it (lots of haskell books explores this)
00:06:35 <dark> but i think it doesn't have a formal semantics
00:07:23 <dark> Cathaa, for eg., if you exclude bottom, you can prove logical theorems of intuitionist logic using the curry-howard theorem
00:08:31 <Cathaa> Ah, I see
00:08:36 <Cathaa> Thanks for the responses! 
00:09:32 <dark> Cathaa, http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism like this
00:09:46 <dark> s/theorem/isomorphism/
00:09:55 <Axman6> Cathaa: the way haskell works feels very much like how maths works. there's no order in which things are really defined to happen in maths, and the same can somewhat be said for haskell
00:10:06 <Axman6> it's declarative like maths i what I'm getting at
00:11:28 <Kaidelong> it's probably a wee bit tidier than math notation in some ways
00:11:36 <Axman6> yeah
00:18:25 <lispy> How do I deal with C unions in Haskell?
00:19:18 <Axman6> keep negotiating with them until they give in
00:19:44 <lispy> heh
00:19:47 <zenzike> never deal with terrorists
00:20:06 <lispy> I wonder if hsc's #ptr construct would point to the right thing
00:20:12 <Axman6> aren't there tools that take care of that for you?
00:20:54 <lispy> Well, hsc doesn't appear to have a way
00:21:09 <Axman6> hmm
00:21:30 <dark> Wow it works!! !! ! (lambdabot on ghci)
00:21:32 <mm_freak> lispy: unsafeCoerce ;)
00:21:42 <dark> Axman6, thanks!
00:21:47 <Axman6> oh right, unions, not structs
00:21:50 <Axman6> -_-
00:22:02 <Axman6> dark: which ghc are you using byw?
00:22:05 <Axman6> btw*
00:22:11 <Axman6> i should install it too...
00:22:19 <dark> 6.12.3
00:23:54 * dark installing djinn
00:23:58 <lispy> So this union is used to hold either FILE* or a file descriptor
00:24:12 <lispy> Does Haskell even have access to file pointers?
00:24:43 * Axman6 pokes lostman_, liyang_ and fishkandy, and wonders what happened to the connection at tsuru
00:24:51 <lispy> We have handleToFd and fdToHandle
00:25:07 <Axman6> ... wow, what a horrible union
00:25:43 <lispy> I'm shocked it works
00:26:05 <Axman6> well, it will only work when sizeof(int) == sizeof(void *)
00:26:17 <Axman6> which is horrible, though that's usually true
00:26:27 <lispy> that's not even how it's implemented though
00:26:37 <Axman6> it's not?
00:26:40 <lispy>     long   value;
00:26:41 <lispy>     void*  pointer;
00:26:47 <Axman6> >_<
00:26:55 <fishkandy> Axman6, router fiddling :)
00:27:03 <Axman6> will that even work on a 32 bit system?
00:27:23 <Axman6> fishkandy: ah, glad it wasn't something unexpected :)
00:27:44 <dark> djinn also works with goa @.@
00:28:03 <fishkandy> Axman6, nah, natural disasters never happen outside of market hours
00:28:14 <Axman6> heh
00:28:19 <Axman6> oh right, it's after three there
00:28:26 <fishkandy> yup
00:28:35 <fishkandy> getting pretty close to beer o'clock actually
00:28:44 <mm_freak> lispy: i think, haskell cannot handle FILE stuff, because it's higher level C stuff
00:28:47 <Axman6> i miss beer o'clock
00:28:53 <fishkandy> :-)
00:28:55 <Axman6> i can hear the bells now...
00:29:08 <mm_freak> haskell's counterpart would be Handle
00:30:16 <lispy> Yeah, so I really only need to emulate the long part of the union
00:30:34 <lispy> So I think I can safely replace the union with a CLong
00:30:43 <lispy> That's what I'm going to tell myself anyway
00:31:46 <mm_freak> lispy: note that FILE does things like buffering
00:31:54 <mm_freak> so in fact you should disallow using FILE
00:32:05 <mm_freak> or handle it properly, which can be complicated
00:32:53 <lispy> I know.
00:32:56 <lispy> I could make an FFI binding for FILE*
00:33:06 <lispy> But, well, I don't think anyone will ever use this part of the binding
00:42:48 <mm_freak> lispy: exactly
00:42:59 <mm_freak> it would be pointless and also difficult to implement
00:43:14 <mm_freak> you would need to connect your FILE stuff to haskell's RTS
00:43:29 <mm_freak> (or convert to Handle under the hood)
01:29:29 <dobblego> what package is 'ala' in?
01:30:34 <dobblego> @type ala
01:30:34 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
01:32:27 <RayNbow`TU> dobblego: newtype
01:32:32 <dobblego> yeah just found it cheers
01:34:46 <RayNbow`TU> I like the newtype pkg... you can do some nice stuff with it :)
01:36:09 <RayNbow`TU> http://hpaste.org/44991/ <-- a toy example using 'under'
01:45:09 <rostayob> If /join #xmonad
01:45:15 <rostayob> oops (:
02:37:29 <accel> so I really really really want ahskell bindings for TexMacs
02:37:34 <accel> who can I pay to get this done?
02:41:41 <McManiaC> my app keeps failing with "out of memory (requested 1048576 bytes)" and I have no idea why. any ideas how to debug this?
02:43:14 <Twey> accel: TexMacs people
02:43:44 <mm_freak> accel: what exactly are "haskell bindings for TeXmacs"?
02:43:57 <mm_freak> you mean GHCi support?
02:45:19 <lispy> byorgey: ping?
02:45:42 <lispy> mm_freak: have you ever used texmacs?
02:46:41 <lispy> wow, it's changed a lot since I used it circa 2003
02:46:59 <lispy> So, I would assume accel wants a pretty rendering of Haskell code
02:47:05 <lispy> But, maybe ghci interaction is right
02:47:08 <Phyx-> lol
02:47:15 * lispy is not  good mind reader
02:47:21 <lispy> hy Phyx- 
02:47:31 <Phyx-> hi lispy , long time no see
02:47:40 <accel> mm_freak: TeXMacs uses guile right now
02:47:50 <accel> I want it to use haskell instead.
02:47:54 <lispy> oh
02:47:56 <accel>  no no, I don't want to pretify ghci
02:47:59 <accel> I want to have an editor
02:48:03 <accel> with the beauty of texmacs
02:48:03 <lispy> So use yi
02:48:05 <Phyx-> guile? from street fighter?
02:48:06 <accel> but scripted in haskell
02:48:17 <accel> Phyx-: the scheme interpreter
02:48:21 <Phyx-> aha
02:48:22 <accel> Phyx-: you troll better than me
02:48:30 <lispy> Phyx-: almost :)  He uses his scheme to defeat his opponents
02:48:44 <Phyx-> accel: I try :)
02:48:52 <Phyx-> lispy: lol,
02:49:00 <lispy> I've finished off about 80% of the raw-core FreeType2 API
02:49:04 <lispy> I guess I should go to bed
02:49:11 <accel> wait
02:49:17 <accel> tell me about the FreeType 2 API
02:49:18 <lispy> STOP
02:49:20 <accel> does it handle postscript fonts?
02:49:20 <lispy> HALT
02:49:22 * Phyx- has never heard of TexMacs
02:49:23 <lispy> yes
02:49:30 <accel> so recente TeX
02:49:37 <accel> so LaTeX produces postscript files
02:49:42 <accel> rather than bitmap files
02:49:45 <lispy> http://freetype.sourceforge.net/freetype2/index.html
02:49:47 <accel> which means those can be rendered via Freetype 2?
02:50:05 <lispy> I would assume postscript files != postscript fonts
02:50:14 <accel> well
02:50:16 <accel> the postscript files
02:50:18 <accel> uses postscript fonts
02:50:20 <accel> rather than bitmapped fonts
02:50:30 <lispy> and I may be wrong about it supporting postscript fonts
02:50:32 <accel> so I would assume one can use Freetype to render the math symbols
02:50:35 <lispy> I just double checked and I dont' see it
02:50:42 <accel> lispy--
02:50:45 <eikke> I somehow seem to remember I read a paper or blog or code once about a Finite State Machine implementation encoded in the type system, where 'states that can't be reached' were automatically checked and forbidden, or something along those lines... rings a bell somewhere?
02:51:00 <accel> lispy++ (for being honest)
02:51:17 <Phyx-> lol, gn lispy 
02:51:40 <lispy> accel: here you go, Postscript portion of the api: http://www.freetype.org/freetype2/docs/reference/ft2-type1_tables.html
02:51:49 <accel> lispy++
02:51:55 <accel> heck I'll do one better
02:51:56 <accel> lispy << 1
02:52:15 <accel> fuck; taht's unreadable
02:52:39 <ray> @botsmack
02:52:39 <lambdabot> :)
02:52:47 <lispy> anyway.  Good night
02:52:53 <accel> thanks again
02:52:54 <accel> g'night
02:53:15 <ray> :t unchurch
02:53:16 <lambdabot> Not in scope: `unchurch'
02:53:29 <McManiaC> so - any ideas on how to debug "out of memory" excetions?
02:53:36 <ray> @let unchurch n = n (+1) 0
02:53:36 <lambdabot>  Defined.
02:54:01 <ray> @let church2 = \f x -> f (f x)
02:54:02 <lambdabot>  Defined.
02:54:19 <ray> @let church4 = \f x -> f (f (f (f x)))
02:54:20 <lambdabot>  Defined.
02:54:36 <ray> > unchurch (church4 church2)
02:54:37 <lambdabot>   16
02:55:10 <ray> > unchurch ((church4 church2) church2)
02:55:11 <lambdabot>   65536
03:13:06 <MaskRay> how to specify some modules to load for `ghc -e' ?
03:20:28 <zenzike> MaskRay: have you tried using the fully qualified names for the functions you want?
03:24:09 <MaskRay> zenzike: yes, so i get such a clumsy command: ghc -e "mapM_ Data.ByteString.Char8.putStr (Prelude.replicate 4800 (Data.ByteString.Char8.replicate (512*1024) '\255'))" | pv > /dev/null
03:24:33 <zenzike> MaskRay: :-\ it's not nice is it?
03:24:45 <MaskRay> zenzike: it is too long..
03:48:26 <mm_freak> MaskRay: import Data.ByteString.Char8 as BC
03:48:30 <mm_freak> BC.putStr
03:48:44 <mm_freak> and yeah, add 'qualified'
03:51:06 <KSkrzet> are there any RTS flags that can be used to speed up program that does a lot of GC?
03:52:03 <Jafet> KSkrzet: well, increase the heap size, so that GC happens less often
03:52:52 <Saizan> the minimum heap size, it's unlimited by default, you might also try changing the size of the allocation area
03:53:02 <Jafet> But you should be finding out whether it is unnecessary GC first, eg. fusion not happening for some reason
03:58:33 <KSkrzet> I'm doing a lot of I/O, and the ByteStrings I read are chopped into pieces
03:58:43 <KSkrzet> I think it must cause GC
04:05:41 <KSkrzet> I'm getting "stack space overflow" with -K500m
04:05:53 <KSkrzet> I guess I should rather fix the program than increase -Ksize
04:06:23 <KSkrzet> is there any good way of finding such leaks?
04:07:33 <McManiaC> excessiv logging :>
04:07:38 <mm_freak> KSkrzet: in general stack overflows happen, when you have explicit recursion
04:08:00 <mm_freak> make sure that you're either generating a lazy data structure or you have proper tail calls
04:08:34 <KSkrzet> ah
04:08:43 <KSkrzet> but what if I'm recursing in monadic code?
04:08:54 <mm_freak> depends on the monad
04:09:40 <KSkrzet> http://hpaste.org/45311/memory_optimization_function
04:09:46 <KSkrzet> this is my current code
04:10:02 <ari__> ...
04:10:08 <KSkrzet> I'm returning a long list here
04:11:15 <mm_freak> usually the rules are quite intuitive, so if your last action causes the recursion, you should be fine
04:11:15 <mm_freak> c = a >> b >> c
04:11:26 <pmurias> how can i turn a string into a ByteString?
04:11:29 <Saizan> (y:) `fmap` go (i+1) xs m <-- here's the problem
04:11:37 <pmurias> string meaning [Char]
04:11:47 <KSkrzet> y :: ByteString actually
04:11:49 <zenzike> pmurias: use pack
04:11:57 <KSkrzet> :-)
04:14:11 <KSkrzet> Saizan: but what can I do? I want to return a list and I want to have a progress report
04:15:26 <pmurias> zenzike: pack expects [GHC.Word.Word8]
04:16:06 <zenzike> pmurias: you should import Data.ByteString.Char8
04:16:40 <Saizan> KSkrzet: you could use the Writer monad to accumulate the log instead, or you could do like if you were using an eager language and add an list accumulator argument to go
04:17:19 <KSkrzet> silly me, I forgot about accumulator trick
04:17:20 <KSkrzet> thanks!
04:17:24 <pmurias> zenzike: thanks works
04:17:29 <xplat> no, no, neither of those is what you want to turn a string into a bytestring
04:17:30 <zenzike> pmurias: np :-)
04:17:36 <xplat> you have to use encoding stuff for that
04:18:09 <xplat> unless you have reason to be 100% sure your string was latin1 characters only (like it's a literal with latin1 characters only)
04:21:02 <xplat> and mostly you shouldn't even use it for latin1, just ascii
04:21:55 <xplat> because it will only roundtrip if the receiver was expecting latin1
04:24:10 <Peaker> Was anyone in the conference where ndm had slides about Shake?
04:24:10 <pmurias> xplat: i hate latin1 and never use that
04:26:39 <pmurias> how can i read a bytestring from file?
04:28:07 <zenzike> pmurias: you should read the bytestring documentation: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.10/doc/html/Data-ByteString.html
04:28:44 <Peaker> @hoogle Get Double
04:28:44 <lambdabot> Did you mean: :: RequestMethod /count=20
04:28:44 <lambdabot> No results found
04:28:46 <zenzike> pmurias: you're probably looking for readFile
04:29:37 <zenzike> xplat: are you talking about thes tuff in Data.Text.Encoding?
04:30:06 <Peaker> How do I binary-parse a double value in the way it is stored on x86/64 by gcc c code?
04:34:04 <Peaker> seems the Get monad doesn't have any float/double parsing in there
04:35:27 <KSkrzet> Peaker: what about http://hackage.haskell.org/package/data-binary-ieee754
04:35:56 <Peaker> KSkrzet, Seems great, thanks!
04:36:15 <KSkrzet> Peaker: you are welcome :-)
04:37:12 <mm_freak> KSkrzet: my solution is to use a list monad transformer instead of returning a list
04:37:29 <mm_freak> for example you can use LogicT
04:37:44 <Peaker> @hackage list
04:37:44 <lambdabot> http://hackage.haskell.org/package/list
04:37:51 <Peaker> it also has a working ListT
04:38:26 <Peaker> http://hackage.haskell.org/package/List
04:38:37 <mm_freak> Peaker: LogicT is fast and also has some advanced fair choice combinators
04:39:19 <mm_freak> if you can live without the fair choice combinators and want more speed instead, you can use my slightly more complicated ChoiceT
04:40:04 <mm_freak> (not the one from monadLib, but from contstuff, though the former should give you at least average list speed)
04:40:48 <accel> anyone here familiar with the generic of packed font file format used in metafont?
04:41:40 <KSkrzet> I simply added accumulator, and it works: http://hpaste.org/45312/memory_optimization_function
04:42:34 <mm_freak> KSkrzet: list transformers are more elegant, because you get separation of concerns…  you separate result production from result usage
04:42:56 <KSkrzet> mm_freak: will they beat my solution in speed?
04:43:35 <mm_freak> KSkrzet: depends…  ListT-based solutions have the opportunity to do only what is necessary
04:44:10 <mm_freak> KSkrzet: remember, you're still generating a whole list…  now in an accumulation parameter instead of by result value
04:44:21 <KSkrzet> mm_freak: well, after processing i deepseq the result, so everything will be necessary
04:45:07 <mm_freak> KSkrzet: if you need everything to be in memory at once, consider using a different data structure
04:45:12 <mm_freak> like Vector instead of []
04:45:31 <mm_freak> KSkrzet: also i wonder why you use B.copy
04:45:50 <mm_freak> you don't seem to use x' anywhere
04:46:08 <KSkrzet> well spotted
04:46:51 <mm_freak> even if, semantically x' = x…  B.copy just increases memory usage
04:47:57 <KSkrzet> not if you can throw out x
04:48:21 <mm_freak> then you have the same as before, but only after a GC cycle
04:48:44 <mm_freak> there is difference to having x compared to having a copy of x, while x has been garbage-collected
04:49:41 <KSkrzet> huh?
04:49:51 <KSkrzet> I dont get it
04:50:03 <mm_freak> high level languages follow the philosophy that compilers generate better code than the programmer…  haskell takes this to its conclusion:  compiler and RTS produce better code and better resource management than the programmer
04:50:22 <KSkrzet> mm_freak: I dont trust them :-)
04:50:24 <mm_freak> so unless you understand the concepts very well, don't try to dictate your own idea of memory management
04:50:28 <mm_freak> you should
04:50:36 <KSkrzet> I do understand
04:50:36 <mm_freak> because otherwise you will end up with less efficient code
04:50:45 <KSkrzet> I just optimized my program another 300% or so
04:50:57 <mm_freak> by using B.copy? ;)
04:51:03 <mm_freak> i really doubt that
04:51:18 <KSkrzet> swap is really slow
04:51:30 <mm_freak> as said, semantically you have the same program as before, but you need one GC cycle more to get there
04:51:42 <mm_freak> so:  same program, just slower
04:51:42 <KSkrzet> and I don't want to split work and serialize stuff to disk
04:51:56 <KSkrzet> ok, I'm doing extra work here
04:52:05 <KSkrzet> but I'm making sure I'm not using extra memory
04:52:35 <KSkrzet> this is the idea of B.copy anyway
04:52:50 <mm_freak> have you tried writing a parser instead of splitting the bytestring manually?
04:53:36 <KSkrzet> the input is simple really
04:54:03 <mm_freak> the input doesn't have to be complicated to justify a parser =)
04:54:22 <KSkrzet> http://hpaste.org/45313/parsing_beginnigs_of_wikipedia
04:54:36 <KSkrzet> decide by yourself
04:56:20 <jlouis> Why are you concerned about speed?
04:56:44 <KSkrzet> large input size
04:57:17 <KSkrzet> for now it's ~300 MB, but I would like to be able to deal with ~800 MB
04:57:44 <mm_freak> you can, likely even in constant space
04:57:47 <mamooth> Hey there!
04:57:47 <jlouis> How fast do you need that to parse? 2 seconds, 10, 100?
04:58:03 <mm_freak> KSkrzet: i constantly process hundreds of megabytes in minutes in haskell
04:58:26 <mm_freak> usually with a very small memory footprint
04:58:41 <rostayob> I have a problem. I am reading data from IO, and I'm casting it to a data type. I have a function "convert" that gets the data and casts it to a data type. Now the problem is, if I group some data types under a type class, and I want to have a function that returns something of that typeclass, at some point I need to have a monomorphic type to know what to cast to, but it some cases I just want 
04:58:44 <rostayob> something of that typeclas... how can I do that?
04:58:46 <jlouis> I'd set some speed constraints on myself
04:59:03 <jlouis> and then see if Parsec3 can go under it. If yes, that part is now done
04:59:11 <jlouis> if no, I'd probably try attoparsec
04:59:35 <KSkrzet> mm_freak: I need to have unigrams and bigrams of words from input, so I need to have them all in memory
05:00:02 <mm_freak> rostayob: first of all, you're parsing/interpreting/reading/whatever, but not casting…  and the answer is:  by having a proper type signature for the corresponding class function
05:00:06 <mamooth> Is it possible to generate ordered lists with the double dotted syntax for custom datatypes?
05:00:39 <mm_freak> KSkrzet: at least you can do the parsing itself in constant space…  my method is to use iteratees and attoparsec
05:00:59 <mm_freak> see the 'enumerator' and 'attoparsec' packages
05:01:06 <KSkrzet> mm_freak: I know them
05:01:14 <KSkrzet> mm_freak: but thanks anyway :-)
05:01:17 <mamooth> I mean, if I have data Animals = Dog | Pig | Cat, I'd like to be able to generate an ordered list of animals with something like [Dog..Cat]
05:01:21 <rostayob> mm_freak: what do you mean with proper type signature?
05:01:33 <rostayob> mamooth: derive (Enum)?
05:01:36 <mm_freak> rostayob: depends…  you may want to show some example
05:02:03 <mamooth> rostayob, that's what I've done, but I guess I have to implements some type classes?
05:02:19 <sipa> mamooth: implement Enum
05:02:33 <mamooth> sipa, ok
05:02:34 <sipa> by writing "deriving (Enum)"
05:02:39 <sipa> after the data definition
05:02:40 <mamooth> that's all?
05:02:50 <sipa> the instance is automatically generated for you
05:02:54 <mamooth> ok
05:03:07 <sipa> this can be done for Eq, Show, Read, Enum, Ord, ... any i forget?
05:03:27 <sipa> using GeneralizedNewtypeDeriving even a lot more
05:03:30 <jlouis> rostayob: you will have to come up with a more concrete problem I am afraid.
05:03:39 <frerich> sipa: Bounded
05:03:39 <mm_freak> KSkrzet: then use them…  you want more speed, and iteratees are the way to go…  you may even write an iteratee, which does the parsing itself, that way you may get along without attoparsec
05:03:49 <rostayob> mm_freak: it's kind of a big chunk of code, the idea is that I get json documents from a database and I convert them to an algebraic data type. I already have this function getPost :: Post a => PostId -> m a that gets either a Submission or a Comment, the problem is that I need to have an actual data type at some point so that the function "knows" what to convert to
05:04:13 <mm_freak> KSkrzet: or, perhaps better, write an enumeratee and build your result list/vector inside of a simple iteratee
05:04:56 <KSkrzet> mm_freak: parsing isn't a problem anymore
05:05:14 <KSkrzet> mm_freak: it works well enough now
05:05:19 <mm_freak> ah, ok
05:05:56 <mamooth> sipa, I've done it for months, with the close "deriving (Show, Enum)". But [Janvier..Décembre] throw an error: Failed to load interface for `Janvier': ... A section must be enclosed in parentheses
05:06:11 <rostayob> mm_freak: and in getPost I know what I will return, but of course I can't return a Submission or a Post
05:06:11 <frerich> mm_freak: What IRC client do you use that it yields the Unicode character for ellipses instead of "..."? Or do you type that by hand all the time?
05:06:22 <rostayob> *Submission or a Comment
05:06:36 <mm_freak> rostayob: the simple, dirty solution is to write another ADT:  data PostResult = CommentResult Comment | PostResult Post
05:06:48 <mm_freak> rostayob: the cleaner solution is to get along without knowing
05:07:07 <mm_freak> frerich: i type by hand
05:07:13 <KSkrzet> mm_freak: the problem is I dont have optimized structure for n-grams and I don't even know if there is any
05:07:30 <rostayob> mm_freak: the point is that sometimes I don't care what it is, knowing that it's a post is enough
05:07:42 <rostayob> mm_freak: so I'd like to cast to one of the two and forget about it
05:08:00 <sipa> mamooth: maybe the é is causing trouble?
05:08:12 <frerich> mamooth: This is a painful feature of the Haskell parser. Try writing "[Janvier ..Décembre]" (note the space before "..")
05:08:12 <mamooth> You may be right
05:08:21 <mamooth> ok
05:08:38 <KSkrzet> mm_freak: and the program runs out of RAM on 1/3 of input
05:08:40 <mamooth> [Janvier .. Décembre] do the job !!
05:08:47 <mamooth> thanks
05:08:52 <KSkrzet> mm_freak: after doing parsing, that is
05:08:57 <mm_freak> KSkrzet: what's the speciality of n-grams?  is there anything different to lists conceptually?
05:08:59 <ecyrb> hey all:  How do I convert from a Word32 to an Int32?  (I'm in Data.Binary.Get if that makes a difference)
05:09:16 <parcs> fromIntegral
05:09:22 <frerich> mamooth: I think the problem is that without the space, "Janvier.." is treated like a module identifier (like "Prelude.foo") or so.
05:09:31 <mamooth> ok
05:09:40 <mm_freak> rostayob: you cannot cast in haskell
05:09:41 <mamooth> that's good to know
05:09:48 <mamooth> thanks frerich
05:10:03 <mm_freak> rostayob: casting is wrong by concept…  you can only write a wrapper ADT, if you really need to know the concrete type at runtime
05:10:18 <rostayob> mm_freak: yeah sorry about the casting terminology :P
05:10:31 <mm_freak> rostayob: i think, what you really want is an existential type
05:10:50 <mm_freak> rostayob: that won't tell you, which type you have, but you can assign operations to the data type
05:11:06 <rostayob> mm_freak: what I want is a function that guarantees that it'll return a type of a certain class, but the actual type will be monomorphic
05:11:23 <rostayob> mm_freak: yeah more or less
05:11:24 <mm_freak> rostayob: the idea is this:  getPost :: PostId -> (forall p. (p, p -> p, p -> Bool))
05:11:42 <mm_freak> that doesn't tell the receiver what 'p' is, but gives it some operations to work with
05:12:00 <ecyrb> parcs:  Thanks.  I was looking for toIntegral... doh.
05:12:06 <rostayob> mm_freak: yeah I suspected that rank-2 types had to do with this problem lol
05:12:28 <mm_freak> rostayob: or existential types, if you want to have it more cleanly
05:12:46 <rostayob> mm_freak: couldn't I have getPost :: PostId -> (forall p. Post p => p)?
05:12:49 <mm_freak> data Result = forall p. PostResult p => Result p
05:12:55 <mm_freak> yes, you could
05:13:10 <rostayob> and then I could return a Submission inside the function?
05:13:40 <mm_freak> i'm not sure…  i think, you will need a wrapper type anyway
05:15:12 <rostayob> mm_freak: mhm... ok I'll experiment, thanks
05:19:25 <rostayob> mm_freak: ok, now I have a type sig like this: getPost :: DbAccess m => PostId -> (forall a. Post a => m (Maybe a))
05:19:54 <rostayob> Post is defined like class Bson a => Post a where ...
05:20:04 <rostayob> the problem is when I get the document
05:20:11 <rostayob> and I call my "fromBson" function
05:20:25 <rostayob> it can't deduce (Bson a)
05:20:34 <rostayob> and rightfully so eheh
05:20:39 <rostayob> I have to return a function you're right
05:21:51 <rostayob> mhm but that wouldn't work...
05:22:31 <xplat> KSkrzet: have you tried using the OpenNLP bindings?  i'm sure they have some optimized way of representing n-grams ...
05:23:53 <rostayob> mm_freak: the bottom line is that I want a function that returns a more specific type than its type signature says
05:24:02 <rostayob> and I don't think that's possible...
05:24:05 <mm_freak> rostayob: note:  PostId -> m (forall p. …)
05:24:31 <mm_freak> and no, that's not possible
05:24:31 <Peaker> Will Vector of Bool be space-efficient? (1 bit per Bool)?
05:24:58 <hpc> Peaker: i don't think Bool will be just one bit
05:25:02 <rostayob> I have to wrap it in some other type
05:25:10 <hpc> but laziness might make it good enough
05:25:23 <mm_freak> Peaker: unboxed vectors perhaps, but if you want efficiency of access/representation, UArray is the way to go
05:25:33 <Axman6> Peaker: the point of Vector is for the 'vector' itself to never exist if possible
05:25:37 <mm_freak> Peaker: UArray is faster, but doesn't do anything fancy like fusion
05:26:06 <mm_freak> Peaker: a UArray of Bool really uses only one bit per Bool
05:26:34 <Peaker> Axman6, ah
05:26:41 <Peaker> Ok, thanks
05:27:20 <xplat> could always make a Bits instance for (Bits a) => UVector a if there isn't one already
05:27:21 <Peaker> I dislike the (a,a) bounds.. would love to just have size, and 0..size-1 as the range
05:27:29 <xplat> and do bulk operations with it
05:27:41 <Peaker> I just want to make a good memo for an (Int -> Bool) function
05:27:44 <Axman6> Peaker: for UArray?
05:27:49 <Peaker> Axman6, Yeah
05:27:56 <Eelis> i agree, the customizable lower bound is fugly
05:28:12 <Axman6> you can use the unsafe functions in GHC.Arr i think
05:28:23 <Axman6> avoids the bounds checks, and lets you work directly with Int
05:28:39 <Peaker> I'd rather avoid GHC.* imports though :)
05:28:59 <Peaker> They should have made "fancy" array stuff (Ix class, etc) as a layer on top of the raw machine repr. of arrays
05:28:59 <mm_freak> Peaker: fixed size is the price to pay for efficiency
05:29:07 <xplat> hm, to memoize Int -> Bool you need two bits per int
05:29:12 <Peaker> mm_freak, I want a fixed size..?
05:29:23 <mm_freak> Peaker: the bounds
05:29:33 <mm_freak> arrays have fixed size
05:29:39 <xplat> so you can know if you already computed it
05:29:42 <Peaker> mm_freak, I don't want a lower bound, and I'd rather have exclusive (size, not max) upper bound
05:29:59 <mm_freak> for efficient indexing, use Int as the index and 0 as the lower index bound
05:30:07 <xplat> and you need to use unsafe functions
05:30:50 <xplat> (well, you can use only safe functions, but only if you want like 64 bits per bool)
05:31:36 <Peaker> mm_freak, I'd like it if there wasn't a choice in that matter :)
05:31:52 <Peaker> xplat, thanks
05:33:04 <raijin> so, can someone help me with this build error? http://hpaste.org/45314/xmonad09_build_error
05:33:24 <xplat> well, you can also use only safe functions if it's an option to have your entire calculation in a monad like ST or IO
05:34:33 <rostayob> mm_freak: ahah! I made it!
05:34:51 <xplat> rostayob: what did you come up with?
05:35:16 <rostayob> http://hpaste.org/45315/existential
05:35:53 * raijin sighs
05:36:27 <Peaker> http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/Data-Array-Unboxed.html says "see the UArray class.." but the link goes to the UArray data-type
05:36:32 <rostayob> all those cases are quite ugly but it compiles
05:36:39 <xplat> rostayob: what kind of database are you using in that?
05:36:44 <rostayob> xplat: mongodb
05:36:51 <Eelis> mm_freak: how does UArray of Bool manage to use only 1 bit per Bool?
05:37:03 <rostayob> xplat: with some template haskell functions to convert from data types to bson and back
05:37:09 <Eelis> mm_freak: are you really sure it won't use a machine word per Bool?
05:37:20 <mm_freak> Eelis: yes, i am
05:37:25 <xplat> ah, one of those glorified BDBs ... :I
05:37:31 <Eelis> mm_freak: got a reference or something?
05:37:45 <rostayob> mm_freak: thanks for the tip on existential type, it was what I was looking for
05:37:46 <mm_freak> Eelis: note that UArray has only certain IArray instances
05:37:51 <mm_freak> Eelis: no, but i tried it =)
05:38:05 <Peaker> The (!) operator on arrays still does bounds checking, to avoid seg faults, right?  I'd rather it didn't...
05:38:26 <mm_freak> Peaker: if you want maximum speed, use Ptr
05:38:41 <mm_freak> Peaker: but that's inconvenient and very unsafe
05:39:08 <xplat> yeah, that's close to the maximum limit of 'writing C in Haskell'
05:39:10 <Peaker> I want maximum speed at reasonable effort :)
05:39:35 <mm_freak> Peaker: high speed with little effort = UArray
05:39:37 <Peaker> Writing a generic "IntRangeMemo" module that lets me memoize functions with an int domain which is 0..someRange
05:39:39 <mm_freak> maximum speed = Ptr
05:39:46 <mm_freak> unless you want to write assembler
05:39:51 <mm_freak> (Ptr matches the speed of C)
05:40:09 <Peaker> At first I thought for a bit-vector I'd make it monomorphic to memoize (Int -> Bool) funcs, but now I think I'll have it memoize (Int -> a) for IArray UArray a
05:40:10 <copumpkin> not really
05:40:16 <xplat> the speed of C, the safety of C, most of the convenience of C
05:40:52 <mm_freak> copumpkin: benchmarks gave evidence that peeking/poking is translated to something very quick
05:40:55 <Maxdamantus> c = 299792458
05:40:59 <Maxdamantus> m/s
05:41:01 <mm_freak> like single instructions
05:41:16 <mm_freak> used GHC 6.12.3 at that time
05:41:18 <copumpkin> mm_freak: sure, but GHC still doesn't do most micro-optimizations that actually make a difference at that level
05:41:24 <pmurias> if i want to use unit tests in haskell what should i use?
05:41:25 <copumpkin> like pipelining reordering and stuff like that
05:41:41 <mm_freak> copumpkin: true, so perhaps using -fvia-C may be a good idea here
05:41:51 <copumpkin> that's deprecated 
05:42:05 <copumpkin> in fact, completely gone as of yesterday in the ghc repo
05:42:10 <mm_freak> copumpkin: what's the alternative?  LLVM?
05:42:13 <xplat> or -fllvm maybe
05:42:39 <xplat> depending if you build for 6.x or 7.x
05:46:25 <Eelis> mm_freak: ah, so the actual UArray ADT is basically just a crude "blob" container, and the instances overlay their own data encoding onto that blob.
05:46:33 <Eelis> that's.. atrocious
05:49:37 <mm_freak> Eelis: yes, but consider that an implementation detail
05:49:37 <Axman6> Eelis: what's wrong with that? if you're using UArrays you're after efficiency, and that's how you get it
05:50:00 <mm_freak> Eelis: also it's well possible to do that even without "hacking":  type families
05:50:44 <mm_freak> it's also possible without type families, since likely a UArray is just a ForeignPtr or something like that
05:50:51 <mm_freak> together with bounds
05:51:18 <Axman6> i think it's an Array# wrapper, i could be wrong though... that might be what Array is
05:51:30 <mm_freak> using my favorite 'id' equivalent:  castPtr =)
05:51:56 <mm_freak> Axman6: yeah, something like that…  some efficient representation in any case
05:52:32 <copumpkin> ByteArray#
05:53:45 <Axman6> that's the one
05:54:01 <xplat> you know, speaking of optimizations, has anyone done work on fusing mutating loops over arrays in ST?
05:54:30 <copumpkin> I don't think so
05:55:44 <xplat> i guess there hasn't even probably been much work on classifying mutating loops into stereotypes that would be fusible.  except maybe in the parallel community.
05:56:39 <copumpkin> well, c compilers do it all the time
05:57:06 <xplat> i don't think that what c compilers do could be reduced to RULEs, though
05:57:21 <copumpkin> yeah, probably not
05:57:31 <xplat> nontrivial dataflow analysis
05:59:50 <xplat> and it's also very brittle if you have anything like a non-inlined procedure call
06:00:38 <xplat> would be less brittle in haskell since it could survive non-inlined calls to pure functions, though
06:02:44 <Skola> hurray, my "Programming in Haskell" just arrived
06:05:46 <Eelis> Axman6: as for "what's wrong with that?", you need only look at the horrible gargantuan amount of code repetition in the array package's Base.hs file
06:06:08 <Eelis> it basically needs to reimplement the same thing two dozen times
06:06:22 <Eelis> in C++, one would write the implementation once, and just make 1 specialization for bool
06:08:59 <insejn> what code is generated by ghc when type inference returned the type for a function: a -> a?
06:09:40 <insejn> are there any whitepapers that might help me resolve that problem
06:09:40 <insejn> ?
06:09:47 <mauke> problem? huh?
06:09:51 <sipa> a function that returns its first argument?
06:10:02 <mauke> the generated code depends on what the function does
06:10:13 <sipa> right, somehow i assumed it was id
06:10:58 <mauke> there's at least three different functions with that type
06:11:11 <Veinor> id, undefined, const undefined ?
06:11:24 <mauke> yeah
06:11:41 <mauke> more if we count error "hello world!"
06:11:43 <insejn> mauke: let's assume it's and id function
06:11:58 <insejn> f x = x
06:14:31 <insejn> will ghc generate code for each call of that function
06:14:36 <insejn> replacing a with correct type?
06:16:40 <copumpkin> it doesn't need to generate different versions of it for different types
06:16:55 <copumpkin> since all values of types of kind * have a uniform representation
06:17:23 <zygoloid> if you build with optimizations, it's very likely to inline it to nothing at all
06:19:34 <mm_freak> insejn: remember, the less a function knows about its argument, the less it makes sense for it to become specialized
06:19:39 <zygoloid> insejn: you might be interested in 'ghc-core'. it'll show you the code that's generated by GHC for a particular function
06:19:41 <mm_freak> in the case of a -> a, it knows nothing
06:19:45 <mm_freak> so no specialization needed
06:20:14 <mm_freak> if you were to specialize the function, it couldn't use that specialization at all
06:20:19 <zygoloid> insejn: as it happens, f x = x compiles into: "movq %r14, %rbx; jmp stg_ap_0_fast" on my machine / GHC version
06:22:12 <Eduard_Munteanu> That doesn't look like code generated in other languages, though.
06:24:29 <denkr> :b has
06:24:41 <denkr> whoops :)
06:34:24 <vladsharp> when using parsec tokens, what is the easiest way to say that you need one or more whitespace characters between tokens?
06:34:52 <vladsharp> say, between a parens and an identifier "(a" would be illegal, but "( a" would not?
06:52:08 <Saizan> don't they consume trailing whitespace by default?
06:53:03 <Saizan> anyhow, that'd be the right thing to do
06:53:38 <Saizan> so they easily compose and you only have to consume whitespace in front in your main parser
06:54:03 <lunaris> They should do.
06:54:12 <lunaris> If you're using Text.Parsec.Token etc.
06:54:18 <Peaker> hmm.. there's this code that uses a record of strict-fields with unpack-strict-fields -- in order to reduce laziness overhead. I need to filter a big stream of these, but only look at one of the fields. Get monad is used to compute each in a lazy stream of these. I want to filter by a particular index, and to avoid the parse work/etc of the other fields, without incurring the laziness overhead of the other fields..
06:54:22 <lunaris> And you define a LanguageDef and some lexer.
06:54:28 <lunaris> Then you'll get whitespace chomping combinators.
06:54:33 <Peaker> s/particular index/particular field
06:55:57 <Taslem> Is there a way to take a list of functions and a list of arguments and evaluate the corresponding applications and return the list?
06:56:12 <Saizan> zipWith ($)
06:56:31 <Taslem> Oh, right.
06:57:45 <lunaris> Or the equally awesome zipWith id
06:57:52 <lunaris> :D
06:57:59 <ClaudiusMaximus> one characted shorter!
06:58:25 * lunaris dusts hands
06:58:55 * t3eblinder is amazed by one-character-shortenings-genius-hacks
06:59:01 <Peaker> "out of memory" errors in a large project are not much fun!
07:00:15 <lunaris> It's a pity; if ZipList was the default applicative instance then you'd just use (<*>)
07:02:42 <Peaker> But that would violate the Applicative laws unless you always used same-length-lists?
07:05:10 <Saizan> no, it'd just violate ap = (<*>)
07:06:16 <Peaker> weird, +RTS -hT  makes it run much further
07:06:25 <McManiaC> http://blog.n-sch.de/2011/04/05/mstate-a-concurrent-state-monad/ =)
07:06:29 <applicative> further?
07:06:47 <Peaker> applicative, it passed the crash-out-of-memory point
07:08:05 <Peaker> in fact, it doesn't seem to crash at all with +RTS -hT, but "out of memory" quickly without it
07:08:16 <Peaker> how can +RTS -hT improve memory consumption?
07:08:42 <ClaudiusMaximus> by forcing more frequent garbage collection, perhaps?
07:08:49 * ClaudiusMaximus guesses wildly
07:09:27 <zygoloid> Peaker: must be quantums
07:11:06 <Peaker> zygoloid, what do you mean?
07:14:12 <Peaker> debugging memory errors is hard if they don't reproduce with heap profiling!
07:16:41 <Saizan> just pretend they aren't there
07:19:17 <Taslem> Is there a limit to the size of a tuple?
07:20:02 <sipa> not sure, but if you ever reach it, you should before long have decided to switch to some structure of records :)
07:20:05 <ClaudiusMaximus> Taslem: yes, but it's large in GHC, think it's 60 or so...
07:20:35 <ClaudiusMaximus> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
07:20:36 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
07:20:36 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109.
07:20:36 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
07:20:36 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 ->
07:20:36 <lambdabot> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 ->
07:20:38 <lambdabot> [4 @more lines]
07:20:43 <Taslem> Wouldn't it be possible for the interpreter to recognize tuples in the program, and automatically define them if they're too large?
07:20:44 <absentia> :wtf
07:20:57 <ClaudiusMaximus> well, maybe there is no limit or it changed recently... - sorry for the spam
07:22:33 <Peaker> unlifted type products would allow tuples to be composed of 2-tuples and 0-tuples..
07:22:50 <Axman6> GHC has no limit
07:23:14 <Axman6> but instances are usually only defined up to 63 or so elements
07:23:21 <Taslem> However, I noticed that above 15 or so Show is not defined. I'd assume it wouldn't have Eq either.
07:23:46 <sipa> you can probably write a deriving instance yourself separately
07:23:46 <Peaker> Having N instances for N-tuples is kinda ridiculous
07:24:53 <ClaudiusMaximus> typing (1,1,1,1,1 ...) in ghci 6.12.3 gives me     A 94-tuple is too large for GHC
07:24:57 <ClaudiusMaximus>       (max size is 62)
07:24:59 <ClaudiusMaximus>       Workaround: use nested tuples or define a data type
07:25:22 <Taslem> Hm...  What about making a type of:  data N a = Q a ?
07:26:02 <Peaker> btw: I hate the PVP.. PVP -> leads to over-restrictive upper version bounds -> leads to too-low version bounds on important basic packages -> leads to cabal-install reinstalling base/global packages so that they link with the older basic packages -> ...  I'd rather get the occasional build error than deal with the myriad of incorrect upper version bounds caused by the PVP
07:26:04 <Taslem> You could make it so it's  N (N (N (N (N Int)))) to represent "5."  Then you could pair it with some sort of Tuple data type and store it as such.
07:26:46 <Peaker> Maybe I should print out stickers: PVP borks my system
07:27:45 <Peaker> Upper version bounds should probably be specified iff an error is actually discovered with a newer package
07:28:06 * ezyang is torn on this issue. 
07:28:53 <ClaudiusMaximus> @hoogle tupleT
07:28:54 <lambdabot> Language.Haskell.TH tupleT :: Int -> TypeQ
07:28:54 <lambdabot> Language.Haskell.TH.Lib tupleT :: Int -> TypeQ
07:28:54 <lambdabot> Language.Haskell.TH TupleT :: Int -> Type
07:29:03 <Veinor> yeah, i dislike upper version bounds
07:29:05 <Peaker> And a big annoyance, IMO, is that people cite the PVP as some sort of solution to all of cabal-install's issues.. when it is in fact one of the problems
07:29:26 <Veinor> '
07:29:43 <Veinor> 'oh crap, this package that only uses addition, multiplication, and supremely basic list operations might break in the next version of base!'
07:30:10 <Peaker> :-)
07:30:50 <Taslem> What is the requirement for a type to be considered a tuple?
07:31:17 <Taslem> Basically, an ordered list of elements? So, how is it specifically different from a list.
07:31:29 <sipa> a list does not have a fixed size
07:31:32 <applicative> Taslem: in a list all elements must be of one type
07:31:38 <sipa> and allows only elements of the same type
07:32:01 <applicative> [Int] [Char] etc. but (Int, Int) (Int,Char) (Char,Int) (Char,Char)
07:32:01 <Taslem> So, would a "list" that allowed elements of all types be considered a tuple?
07:32:01 <Peaker> Taslem, Tuples have the number of elements and their various types in their type. Lists have just one element type.
07:32:26 <Taslem> Okay, got it.
07:32:28 <sipa> Taslem: the type of a list is [a], the type of a tuple is (a,b,c)
07:32:39 <sipa> [a] meaning: any number of elements of type a
07:32:47 <Taslem> Yeah, I know.
07:32:56 <Peaker> Should HList be considered a tuple? It's length is in the type (or at least, knowable from the type)
07:32:57 <sipa> (a,b,c) meaning: a combination of 1 element of type a, one of type b, one of type c
07:33:16 <Peaker> I'd say HList is really just a better-tuple, with some more generalized functions to work with it
07:33:23 <sipa> Peaker: indeed
07:33:39 <sipa> semantically, at least
07:33:54 <applicative> Taslem (Int,Int) (Int,Int,Int) and (Int,Int,Int,Int) are different types with (4,4) (4,4,4) and (4,4,4,4) respectively as values; [Int] has [4], [4,4] [4,4,4] as values all by itself
07:34:02 <ceii> Peaker, a part of my understanding of "tuple" is that it has no structural operations besides getting/setting all elements. 
07:34:26 <Taslem> Well, if you look at languages like LISP, lists are considered tuples.
07:34:28 <applicative> > [4,4] == [4,4,4]
07:34:29 <lambdabot>   False
07:34:30 <ceii> since HLists have a head/tail decomposition I'd consider them strictly more powerful than tuples
07:34:30 <Peaker> ceii, "fst" and "snd"?
07:34:39 <applicative> > (4,4) == (4,4,4)
07:34:40 <Peaker> ceii, or "first" and "second" from Control.Arrow to modify a particular element?
07:34:40 <lambdabot>   Couldn't match expected type `(t, t1)'
07:34:40 <lambdabot>         against inferred type `(t2, ...
07:34:44 <wagle> caddar
07:35:10 <applicative> ^^^ Taslem see the second makes a type error.  
07:35:15 <ceii> Peaker: you're right, wrong characterisation.
07:35:26 <Peaker> ceii, I could make a type-class/type-family or such that allows implementing sort of "head/tail" on tuples
07:35:38 <Taslem> I know the difference between Lists and Tuples as they're already defined. I'm looking for a more clear separation between their minimal definitons.
07:35:41 <sipa> Taslem: that is because lisp has (afaik) no other way of creating combination of types, while haskell has ADT's
07:35:48 <ceii> but you couldn't make it work on all tuple sizes
07:36:12 <sipa> Taslem: so lisp implements the list [a,b,c] as (a,(b,(c,emptylist)))
07:36:32 <Peaker> Taslem, I think lists' main characteristic is being inductively/recursively defined
07:36:34 <byorgey> and since lisp has only one type there's really no difference
07:37:01 * applicative wonders if we've isolated Taslem's question
07:37:03 <sipa> Taslem: while in haskell, there is a specific constructor for lists, (:), and it's implemented as (a:(b:(c:[])))
07:37:12 <byorgey> it's a richer type system which makes the difference between lists and tuples interesting.
07:38:50 <applicative> Taslem: If you wanted to leave out the inbuilt syntax, you could define " data Pair a b = MkPair a b" "data Triple a b c = MkTriple a b c" etc
07:39:02 <applicative> Taslem: but list would be quite different 
07:39:21 <Taslem> Yeah, I know.
07:40:28 <sipa> Taslem: note that you can't use tuples in haskell to implement lists
07:40:37 <applicative> hm, so keep saying things, I think our friends haven't found out your difficulty yet
07:40:44 <sipa> you'd need something like: type List a = (a,List a)
07:40:59 <mauke> Mu
07:41:09 <sipa> yes, using Mu it's possible
07:41:15 <Taslem> What I'm trying to do is define a Tuple that can be extended to whatever depth neccesary with only one instance declaration.
07:41:31 <sipa> you want HList :)
07:41:39 <mauke> Mu (Maybe . (,))
07:41:39 <byorgey> @where HList
07:41:39 <lambdabot> http://homepages.cwi.nl/~ralf/HList
07:42:04 <applicative> Taslem: and you don't want a type restriction on what can we can extend with?
07:42:58 <mm_freak> newtype List a = List (a, Maybe (List a))
07:43:29 <lunaris> Which also gives the shape of the ``correct'' ListT; something I found pleasing.
07:43:34 <mm_freak> but that's kinda stupid
07:43:50 <ceii> mm_freak, not List (Maybe (a, List a)) ?
07:43:52 <Taslem> When you have a data type with a type variable... How can you restrict what values the variable can have?
07:44:01 <ezyang> Taslem: Not possible with current GHC. 
07:44:10 <mm_freak> ceii: indeed
07:44:12 <Taslem> What about making a typeclass?
07:44:14 <ezyang> Well, I guess you could add a typeclass constraint. 
07:44:47 <ceii> Taslem: you _could_ add a typeclass constraint on the type declaration, but it won't really solve anything
07:45:04 <applicative> a GADT might do what you want.
07:45:09 <Taslem> Kinda. I know the type(s) I want to restrict, so...
07:45:11 <ceii> all that'll happen is that all the operations the deal with your type will need that constraint in their type
07:45:21 <ceii> even the ones that don't actually care
07:45:36 <Peaker> Maybe if/when "Shake" is released by ndm's company, I can replace cabal-install with a Shake script to use the libraries I have installed
07:45:53 <byorgey> Peaker: what about openshake?
07:46:38 <applicative> Taslem, you won't be able to restrict values in the sense of adding a condition like, that only even numbers are to be considered
07:46:50 <Taslem> Yeah, I know.
07:48:20 <Peaker> byorgey, what's that?
07:48:41 <Peaker> byorgey, oh, thanks for the reference, I'll look
08:03:19 <Peaker> The fact people are using Monads just so that they can write lists in "do" blocks suggests that people want indent-based list syntax, doesn't it?
08:03:27 <Peaker> (referring to Shake () monad)
08:03:31 <ezyang> Wait, what 
08:03:47 <Peaker> ezyang, Did you watch the Shake intro by ndm?
08:03:52 <ezyang> No. 
08:04:26 <Peaker> he has a "Shake" monad which is not really monadic, just so he can use:  do { .. list of build targets/rules here .. }
08:04:40 <Peaker> because do syntax is nicer than [ .., .., .. ] syntax
08:04:48 * ezyang sighs 
08:04:55 <flamingspinach> link?
08:06:10 <Peaker> http://vimeo.com/15465133
08:06:29 <Peaker> slides: http://community.haskell.org/~ndm/downloads/slides-shake_a_better_make-01_oct_2010.pdf
08:06:57 <Peaker> ezyang, It is true -- do + indentation  has less noise than lists which have an extra closer due to non-indent based, as well as commas because of ignored newlines
08:07:24 <mm_freak> Peaker: i just find do syntax better than list comprehension syntax
08:07:51 <mm_freak> to me list comprehensions are a strange mixture of right to left and left to right reading flow
08:08:25 <Peaker> blame the mathematicians? :-)
08:09:13 <mm_freak> well, sometimes blame the haskellers for removing monad comprehensions…  occasionally i would find comprehension syntax useful, but in different monads
08:10:20 <applicative> Peaker wasn't the same true of the BlazeHtml library at first?  HTML was a false monad so you could use do
08:10:59 <Phyx-> everytime i see "BlazeHtml" i get a mental image of Snoop Dogg coding
08:11:25 <osoleve> <div>? shiiiiit
08:11:31 <Peaker> applicative, maybe, I'm not sure
08:11:46 <Phyx-> olsner: fo shizzle!
08:12:18 * Phyx- thinks his attempt to troll failed
08:14:17 <Phyx-> yup... definitely..
08:14:57 <Peaker> I needed a binary search over an ST array the other day. but binary-search package is only for pure searches. This suggests maybe it should be monadic -- unless you consider that it really does require deterministic/purity from the predicate. It leads to thinking that we should have something that can purely inspect an STArray -- but for this we'd need a guarantee that the computation inspecting the ST array does not "leak" any reference to the ST array 
08:14:57 <Peaker> as it may mutate later
08:16:37 <luite> how can you do that without ST? even readArray returns an ST value
08:17:01 <Peaker> luite: Something like:  tempFreezeSTArray :: (Array i a -> res) -> STArray s i a -> ST s res
08:17:14 <Peaker> luite, consider it a more elaborate readArray that can do multiple reads
08:17:36 <Peaker> if "res" is fully normalized -- then this could safely avoid copying
08:18:36 <sjanssen> @keal
08:18:36 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
08:20:24 <FUZxxl> Is hugs98 still under development?
08:20:36 <Peaker> Can we guarantee a value is fully normalized and won't incur any further reads?
08:20:47 <luite> Peaker: hmm, I guess that would be somewhat tricky to guarantee in the type system, add an NFData constraint?
08:22:02 <luite> and you can't really prevent the user from leaking the array unless you don't give him a reference at all :)
08:22:22 <aristid> is it possible that church-encoded lists are not particularly lazy? :)
08:25:30 <Saizan> they can be as lazy as the ADT version
08:26:39 <Saizan> actually, there might be some problem wrt sharing
08:27:01 <edwardk> i've never been good at sharing
08:34:21 <Saizan> it's a shame that we can only share in one direction
08:35:05 <byorgey> FUZxxl: I don't think so
08:36:31 <applicative> Peaker yes, it seems BlazeHtml was at first a monoid passing for a monad for the purposes of the DSL do notation; if they made it Writer monad they lost speed
08:36:39 <aristid> Saizan: i wrote a church-encoded fibs, and it stalls after 1:1:
08:37:13 <Bfig> can i use this to match the rightmost list element? (xs:x) >
08:37:24 <aristid> Bfig: no.
08:37:41 <Bfig> how can i do it? i need to remove the 'zeros from the right'
08:37:43 <aristid> Bfig: you can use last xs to get the rightmost element, but keep in mind that this is slow
08:37:58 <aristid> well, easiest would be to revers twice
08:38:07 <Bfig> yep, i was thinking that would be the best
08:38:11 <Bfig> reverse, remove, reverse again
08:38:15 <aristid> > reverse . dropWhile (== '0') . reverse $ "12340000"
08:38:16 <lambdabot>   "1234"
08:38:27 <Bfig> cool! thanks :)
08:38:45 <Peaker> luite, how can he leak the array?
08:39:25 <Zao> Bfig: The labels you use when matching have no intrinsic meaning.
08:39:37 <Zao> (cats:dogs) is the same things a (x:xs).
08:39:45 <Bfig> Zao, i know, but maybe if i used the x as an element and performed a list function it would make sense
08:40:01 <Zao> @type (:)
08:40:02 <lambdabot> forall a. a -> [a] -> [a]
08:40:05 <Bfig> but : is the thing that makes ... yes
08:40:23 <Bfig> isn't there a constructor from the right?
08:40:26 <Zao> No.
08:40:29 <Zao> @src []
08:40:29 <lambdabot> data [] a = [] | a : [a]
08:40:29 <luite> Peaker: by using id for example, as the first argument?
08:40:37 <Zao> That's all there is to lists.
08:40:41 <Saizan> > let fromList :: [a] -> forall b. b -> (a -> b -> b) -> b; fromList xs = \nil cons -> foldr nil cons xs; toList xs = xs [] (:) in toList (fromList (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs))
08:40:42 <lambdabot>   Occurs check: cannot construct the infinite type:
08:40:42 <lambdabot>    b = a -> (a -> b -> b)...
08:40:48 <Zao> It's either an empty list or an element + list.
08:41:17 <Zao> Bfig: There are however fancier list-like types that have other methods of creation and iteration.
08:41:31 <Zao> Bfig: Which might have more suitable performance characteristics.
08:41:38 <Peaker> luite, oh, it's polymorphic, oops :)
08:41:53 <luite> Peaker: the function would then just be the same as unsafeFreeze, without the unsafe warning
08:43:27 <Bfig> Zao, that'd be beyond the scope of my program
08:43:29 <Bfig> :p
08:43:29 <Saizan> > let fromList :: [a] -> forall b. b -> (a -> b -> b) -> b; fromList xs = \nil cons -> foldr cons nil xs; toList :: (forall b. b -> (a -> b -> b) -> b) -> [a]; toList xs = xs [] (:) in toList (fromList (let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs))
08:43:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:43:42 <Zao> Bfig: It never hurts to know :)
08:43:59 <Saizan> aristid: so the question is how you implemented it :)
08:45:36 <aristid> Saizan: line 34: http://hpaste.org/45322/churchencoded_lists
08:45:49 <whald> it seems criterion + chart is currently broken, or is it just me? compilation fails in Criterion.Plot
08:46:13 <aristid> Saizan: i think cTail is the problem :)
08:47:27 <Peaker> luite, so.. how do you allow pure code to do all the reading it wants from the ST array without leaking the ST array and without making a lazy computation that still refers to it?
08:51:07 <luite> Peaker: you could add an NFData context to res, and trust the user that he doesn't leak the array... but that would make the function less useful. I think a monadic binary search would just be better in this case
08:51:31 <Peaker> What does this error mean? "Dynamic linking required, but this is a non-standard build (eg. prof). You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix."
08:52:00 <Peaker> luite, That suggests disciple has the right approach?  I am unsure.. There has to be a nicer way
08:52:34 <luite> freezing ST arrays is tricky, I've already been bitten by it a few times :)
08:53:01 <RayNbow> luite: frostbite? :p
08:53:04 <pastorn> luite: how does the freeze/thaw mechanism work? i've only seen the types but never used
08:53:09 <pastorn> why do you want to etc.?
08:53:13 <int-e> tricky how? did you use unsafeFreeze?
08:53:19 <luite> int-e: yeah
08:53:43 <luite> it was my own fault of course
08:54:12 <int-e> (and perhaps, more dubiously, unsafeThaw?)
08:54:15 <luite> pastorn: the safe variant just copies a mutable array to an immutable one with the same type of elements.
08:54:21 <Peaker> pastorn, What I want is a pure binary search on an ST array.. trying to figure out a mechanism to do this (other than change binary search itself to be monadic, which sounds wrong because it does need access to be pure for binary search to make sense)
08:54:34 <luite> pastorn: the unsafe one creates an immutable array that refers to the same memory
08:55:17 <pastorn> yes, but what is freeze/thaw?
08:55:45 * hackagebot archiver 0.3 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.3 (GwernBranwen)
08:55:51 <int-e> Peaker: freeze will work, of course. unsafeFreeze may work but it asking for trouble (assuming you're going to modifiy the array again), as you're probably aware.
08:56:10 <luite> pastorn: freeze = convert mutable to immutable, thaw is the other way around. I don't know what else there is to it :)
08:56:15 <Peaker> int-e, I'm looking for a general mechanism like unsafeFreeze, that is safer..
08:56:21 <pastorn> luite: ok, cool
08:57:14 <Saizan> aristid: yeah, you've to use an irrefutable pattern for that tuple
08:57:18 <luite> pastorn: the unsafeFreeze one is tricky, since it doesn't copy the array. if you accidentally modify the mutable array after freezing, the changes are reflected in the immutable one
08:57:56 <pastorn> luite: why isn't this enforced with types?
08:58:12 <pastorn> or maybe the unsafe operations makes it sort of impossible
08:59:48 <aristid> Saizan: wow! that was an easy fix, thank you :)
09:01:29 <int-e> Peaker: I guess you can write something like 'evaluate', ala "force :: (RNF R => Array a e -> R) -> STArray s a e -> ST s R". It will not be completely safe but perhaps better than using unsafeFreeze directly.
09:01:40 <luite> pastorn: I don't think you can, but there is a somewhat safer way, see for example Data.Vector.create
09:02:41 <luite> pastorn: but that's more limited, your ST action must only return the array (or MVector in this case)
09:03:00 <int-e> Peaker: ah RNF should be NFData (or DeepSeq)
09:03:33 <luite> pastorn: but allowing other return types would allow the user to leak more references to the MVector, which would be bad :)
09:15:17 <Skola> I keep reading that hugs is suited for "learning" Haskell
09:15:27 <Skola> not specifically more so than ghci
09:15:34 <Phyx-> why would it be more suited?
09:15:35 <Skola> but it's mentioned a lot
09:15:42 <Skola> that was gonna be my question
09:15:50 <Phyx-> lol
09:16:05 <byorgey> Skola: I think it tried to focus on good error messages.
09:16:13 <Phyx-> Only thing I could think up that ghc's error messages can be intimidating
09:16:21 <byorgey> but ghc's error messages have improved a lot over the past few years
09:16:25 <Phyx-> indeed
09:16:27 <byorgey> and hugs is not really maintained anymore.
09:16:30 <Skola> ah ok
09:16:39 <monochrom> hugs is more suited because it does not spit out "maybe you want -XSuperAdvancedIncompatibleExtension" messages to confuse you.
09:16:41 <Phyx-> Same for Helium, I always found it a bit "too" verbose for my taste
09:17:06 <monochrom> I wouldn't call ghc messages "improved" until they get rid of exactly that.
09:17:15 <Phyx-> monochrom: why? I find that handy
09:17:44 <monochrom> maybe you want -XLetMeCodeItUpForYou
09:18:02 <Phyx-> sure, if it supports it :)
09:18:13 <Phyx-> I sometimes forget certain -X names
09:18:18 <Phyx-> why i say it's handy
09:18:39 <Skola> I like ghci but don't know better
09:18:44 <monochrom> I don't even remember them. I look them up. There is a manual.
09:18:48 <mm_freak> monochrom: those suggestions have been helpful to me
09:18:52 <sipa> -XJustUseAllExtensionsImmediatelyInsteadOfSuggestingMeToFeedThemBackToYou
09:18:52 <Skola> it's not worth trying something else then?
09:18:59 <mm_freak> monochrom: but i agree they should be optional and disabled by default
09:19:07 <monochrom> they have been unhelpful to learning
09:19:07 <Zao> sipa: -XDoWhatIMeanCorrectly
09:19:14 <Phyx-> I don't really agree..
09:19:26 <mm_freak> -XMatchingTypes
09:19:30 <monochrom> the question is "which is suited for learning haskell"
09:19:34 <mm_freak> -XMakeMyTypesMatch
09:19:39 <sipa> -XTypos
09:19:48 <mm_freak> -XNoHeapOverflows
09:20:10 <monochrom> I don't think "maybe you mean -XMimicOOP" is suited for learning haskell
09:20:13 <sipa> -XP=NP
09:20:30 <Phyx-> -XGodMode
09:20:41 <mm_freak> -XAutomaticBoilerplate
09:20:51 <monochrom> but that's exactly what "maybe turn on -XOverlappedInstances -Xblahblahblah" does. -XMimicOOP
09:21:16 <mm_freak> monochrom: for me it was -XExistentialTypes
09:21:19 <Phyx-> maybe we should just get rid of extensions all together then
09:21:19 <Saizan> nah, OOP guys always get disappointed by OverlappingInstances
09:22:00 <mm_freak> Saizan: once enabling it, yes
09:22:38 <ezyang> -XKitchenSink 
09:22:53 <Phyx-> -XIrcHelp
09:24:14 <rostayob> is there something like TimeDiff for UTCTime?
09:24:19 <mm_freak> but well, i would love a shortcut to: -XGeneralizedNewtypeDeriving -XDeriveDataTypeable -XScopedTypeVariables -XTypeFamilies
09:24:29 <mm_freak> rostayob: NominalDiffTime
09:24:43 <mm_freak> it's in Data.Time.Clock
09:24:52 <rostayob> mm_freak: it doesn't seem to have years months etc separated
09:25:11 <mm_freak> rostayob: it's an opaque type, which contains all that information
09:25:39 <rostayob> mm_freak: the thing is that I want the separated things :P
09:25:39 <mm_freak> rostayob: note that it has a RealFrac instance
09:25:51 <Saizan> ScopedTypeVariables should just get into the report..
09:26:00 <mm_freak> Saizan: i agree
09:26:08 <mm_freak> it's my favorite extension
09:26:10 <Phyx-> Saizan: agreed
09:26:23 <Phyx-> Rank2Types is my fav
09:26:34 <Phyx-> along with TypeSynonymInstance
09:26:40 <rostayob> mm_freak: yeah but I've got a functions to produce messages like "this happened 3 mins ago"
09:27:03 <rostayob> so it's useful to have the things separated
09:27:08 <mm_freak> rostayob: div (round diffTime) 60
09:27:34 <mm_freak> round diffTime gives you diffTime in integral seconds
09:27:41 <mm_freak> if you need more precision, multiply it first
09:27:41 <rostayob> mm_freak: yeah I know I can do that, but with the old thing I could simply do that: http://hpaste.org/45323/time
09:28:37 <mm_freak> rostayob: yes, a FormatTime instance for NominalDiffTime would be nice
09:28:41 <c_wraith> honestly, ScopedTypeVariables should just be the default behavior.
09:28:48 <mm_freak> but right now you'll have to do it the hard way
09:28:54 <c_wraith> I can't think of any case where someone would be surprised by what it does.
09:29:17 <maurer_> c_wraith: Which is why we revise the standard, but until it's revised, it should stay compliant...
09:29:29 <mm_freak> c_wraith: i think that's a matter of intuition…  i think there is no rationale for that
09:29:30 <rostayob> mm_freak: ok, cool
09:30:04 <mm_freak> c_wraith: i expect standalone type signatures to be independent of anything else
09:30:39 <mm_freak> if i have a function in a 'where' of type a -> a, i'd expect it to be some 'id' equivalent without examining the rest of the source code
09:30:59 <mm_freak> on the other hand, one might as, why doesn't it have a 'forall a'
09:31:26 <mightybyte> Is there a reason bos's aeson depends on monads-fd?
09:31:43 <xplat> -XUseHaltingOracle
09:32:10 <mm_freak> xplat: -XUseAgda
09:33:51 <xplat> mm_freak: indeed i think that ScopedTypeVariables has the forall thing backwards
09:34:08 <mm_freak> xplat: that's a matter of taste/intuition
09:34:14 <mm_freak> which was my point
09:35:04 <xplat> i'd rather have a 'global' annotation on the inner type variables than an 'export' sort of one on the outer
09:35:09 <sanjoyd> last is O(n), right? Or am I asking the wrong question?
09:35:32 <xplat> (well, 'locally global')
09:35:53 <Saizan> sanjoyd: it is
09:36:50 <xplat> maybe do 'where oddlySpecific :: import a. a -> a'
09:37:42 <xplat> that way it wouldn't cause confusion with RankNTypes either
09:38:39 <sanjoyd> I'm a newbie looking at 99 haskell problems. Is that a good place to start?
09:39:55 <Saizan> bah, i'd make all type variable have a lexical scope, regardless of explicit foralls
09:40:08 <14WAA1Z5W> sanjoyd, they are a nice supplement
09:40:28 <14WAA1Z5W> have a look at Learn You a Haskell
09:40:31 <14WAA1Z5W> @lyah
09:40:31 <lambdabot> Unknown command, try @list
09:40:36 <14WAA1Z5W> @where lyah
09:40:36 <lambdabot> http://www.learnyouahaskell.com/
09:40:49 <14WAA1Z5W> @where rwh
09:40:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:40:54 <14WAA1Z5W> and that
09:41:16 <sanjoyd> 14WAA1Z5W: I've read quite a bit of Learn You A Hasekll.
09:41:19 <sanjoyd> Fantastic book.
09:41:36 <14WAA1Z5W> and I recently bought myself "Programming in Haskell"
09:41:51 <14WAA1Z5W> which is really good depending on where you're at
09:42:10 <sanjoyd> I've also been reading "Design Concepts In Programming Languages". Does not directly relate to Haskell
09:42:12 <xplat> Saizan: a good idea, but old code would break with that.  which makes it doubly unsuitable as a compiler switch.
09:42:38 <sanjoyd> but loved it for the mathematical rigour. And for showing how easy it is to analyze stateless languages.
09:42:51 <xplat> (not that that stopped the DontGeneralizeLocals wotsit)
09:43:02 <Saizan> (yeah.)
09:43:21 <14WAA1Z5W> good to know sanjoyd
09:44:14 <jonkri> what is a convenient way to print every element of a list (in a do block)?
09:44:47 <14WAA1Z5W> I'm trying to learn enough Haskell to write some basic webapps (in 4 months)
09:44:51 <14WAA1Z5W> it's a bit mad
09:45:25 <14WAA1Z5W> but my boss told me I had this period to pick up a new language
09:45:45 <Saizan> it should be doable, but don't start with webapp code to learn
09:45:56 <mm_freak> xplat: i agree that forall should be forall
09:46:06 <14WAA1Z5W> no I'm getting down the basics first
09:46:10 <mm_freak> but then you would have to change the standard in a non-backward-compatible way
09:46:31 <14WAA1Z5W> any suggestions on certain areas I should be focussing on Saizan?
09:47:24 <xplat> 14WAA1Z5W: what other languages do you know?
09:47:40 <Saizan> 14WAA1Z5W: you want to have a firm grasp of the basics of the type system, lazy evaluation, and higher order programming
09:48:17 <14WAA1Z5W> python, some C, some C++, vanilla javascript
09:49:35 <xplat> hm, fairly bad background for haskell, no advanced static typing and only javascript is really good for FP background but the 'vanilla' might indicate you missed that out ...
09:49:55 <14WAA1Z5W> I guess
09:50:11 <14WAA1Z5W> but so far so good with Haskell
09:51:09 <14WAA1Z5W> perhaps the leap to more advanced programs will be hard
09:51:25 <sanjoyd> jonkri: putStrLn $ concat?
09:51:43 <xplat> so definitely focus on understanding the type system (polymorphism) and lazy evaluation
09:52:04 <14WAA1Z5W> alright
09:52:19 <jonkri> sanjoyd: i just found mapM_, which i think is what i was looking for
09:53:37 <freiksenet> have anyone here worked with Grammatical Framework?
09:53:58 <xplat> and also learn to use map, concatMap, and filter (similar to list/generator comprehensions but in a different style), and the folds (more general examples of the same style)
09:54:11 <14WAA1Z5W> yeah I've got most of those down
09:54:58 <14WAA1Z5W> I looked at some simple problems and tried to find out different (more efficient/Haskellish) ways of solving them
09:55:26 <xplat> going through all of those (especially folds) will teach you a lot about the type system and lazy evaluation too
09:55:31 <14WAA1Z5W> ok
09:56:59 <14WAA1Z5W> I was really amazed when I first used folds
09:57:05 <14WAA1Z5W> might seem silly
09:57:10 <xplat> learning when to use foldl' and when to use foldr (and why you hardly ever use foldl) is very enlightening when you start getting the hang of it
09:57:12 <beastaugh> I've written some stuff about FP in JavaScript, if familiarity with the language would help get the concept across, but it sounds like you're far enough down the line that it would probably be trivial and obvious
09:57:46 <14WAA1Z5W> beastaugh, I don't think it can hurt to have a look though
09:57:52 * hackagebot aeson 0.3.2.2 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.2.2 (BryanOSullivan)
09:58:10 <beastaugh> let me dig up the links
09:58:16 <14WAA1Z5W> cheers
09:58:29 <beastaugh> http://handbook.extralogical.net/functional-programming.html
09:58:35 <beastaugh> http://extralogical.net/articles/2010-08-21-currying-javascript/
09:58:45 <beastaugh> http://extralogical.net/projects/udon/
09:58:50 <nyingen> anyone used graphviz?
09:58:55 <beastaugh> should be enough to get started with :)
09:59:01 <xplat> i don't know whether to be disappointed or glad that aeson is not æson
09:59:34 <c_wraith> xplat: as someone who'd have to type it, I'm glad. :)
10:00:48 <whald> hmm, anyone dares to have a look at a pretty simple function and give me a hint on why it's responsible for >50% time and alloc in my program? btw: it's an open sourced raytracter and rewards the effort with pretty images :-)
10:00:53 * hackagebot hmatrix-glpk 0.2.2 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.2.2 (AlbertoRuiz)
10:01:03 <14WAA1Z5W> thanks beastaugh
10:01:09 <whald> if the answer is yes: http://code.google.com/p/bling-raytracer/source/browse/src/Image.hs#31
10:01:11 <xplat> for me CapsLock-repurposed-to-Compose a e or else AltGr-z
10:01:25 <xplat> not too tough
10:01:26 <beastaugh> hope it helps
10:01:33 <beastaugh> and good luck with your Haskell adventure :)
10:01:39 <14WAA1Z5W> thanks : ]
10:01:55 <14WAA1Z5W> learning it has already been rewarding
10:02:14 <14WAA1Z5W> just afraid that I will not want to go back to other languages after this :D
10:02:16 <c_wraith> whald: that code never forces the values being written to the array.  If it's not an unboxed array, that'll build up large thunks
10:02:37 <whald> it's an ST array
10:02:38 <beastaugh> yes, I had the same problem
10:02:59 <whald> c_wraith: ahhh, i need a STU array then?
10:03:04 <c_wraith> whald: yep
10:03:15 <beastaugh> on the other hand, I found myself writing better code in other languages after learning Haskell
10:03:46 <14WAA1Z5W> I could see why that is
10:03:58 <14WAA1Z5W> Even I noticed it already when working on JS
10:05:05 <whald> c_wraith: i feel that's not the case, i just looked at my imports and thought i'm using a boxed array, but it's indeed a STUArray (line 23)
10:05:59 <c_wraith> whald: ah, so it appears.  I can't see any other reason that function would allocate, though.
10:06:17 <Phyx-> I wonder.. if you write a generic producer function with SYB, that can also generate functions. if you'll eventually after xxx iterations end up with a meaningful program
10:06:53 * hackagebot Extra 1.42 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.42 (JeremyShaw)
10:07:37 <whald> c_wraith: ok, thanks anyway. maybe the vector package performs better here. i'll just play with it some more..
10:09:27 <xplat> whald: i tried looking at your code but code.google.com just gives me a 500 error
10:09:54 <xplat> whald: oh, it finally came up
10:10:26 <whald> xplat: so the internet was turned off for a moment???
10:10:32 <whald> xplat: :-)
10:10:40 <Phyx-> @ping
10:10:40 <lambdabot> pong
10:19:04 <FUZxxl> @help ping
10:19:04 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(43,48): Non-exhaustive patterns in case
10:19:13 <FUZxxl> @ping pang
10:19:13 <lambdabot> pong
10:23:15 <edwardk> preflex: xseen cale
10:23:16 <preflex>  cale was last seen on freenode/#haskell 2 days, 3 hours, 18 minutes and 53 seconds ago, saying: no, but it uses GHC
10:25:28 <djahandarie> edwardk, at work again? ;)
10:26:01 <edwardk> djahandarie: always
10:26:20 <edwardk> i have tomorrow off though, so if you see me... ;)
10:26:24 <djahandarie> I think you just don't sign on IRC when you're at home
10:26:31 <edwardk> damn. i'm caught
10:27:04 <pastorn> luite: oh, cool
10:27:15 <pastorn> luite: i really need to play with some STArrays
10:27:30 <sanjoyd> I just added the last solution in http://www.haskell.org/haskellwiki/99_questions/Solutions/8. Does it make sense?
10:29:45 <bos> @pl \z n -> foldAll n step z
10:29:45 <lambdabot> flip (flip foldAll step)
10:30:18 <djahandarie> @pl \n z -> foldAll n step z
10:30:18 <lambdabot> flip foldAll step
10:31:21 <xplat> whald: what options do you usually compile with?
10:32:52 <whald> xplat: i simple use "cabal build" (with exec profiling, so it comes to "-O2 -fexcess-precision -prof -auto-all -rtsopts") if i understand cabal correctly)
10:35:19 <lispy> byorgey: ping
10:35:25 <byorgey> hi lispy 
10:35:35 <lispy> byorgey: Did you want to talk about charts?
10:35:50 <byorgey> lispy: diagrams, but yes =)
10:35:56 <lispy> byorgey: ah, right!
10:36:00 <byorgey> well, really I want to talk about fonts.
10:36:07 * lispy nods
10:36:29 <lispy> I didn't make a new hackage release yet, but I've now bound about 80-90% of the "core" freetype api
10:36:35 <byorgey> oh, nice
10:37:09 <lispy> I still need a memory managed version of the API, and possibly a Font monad
10:37:11 <byorgey> The essential thing I need to do is to convert some text in a given font to a set of paths
10:37:11 <byorgey> with Bezier segments etc.
10:37:20 <lispy> ah
10:37:27 <byorgey> can freetype2 do that?  and if so do your bindings cover it?
10:37:30 <lispy> So you want the glyphs to appear along the path?
10:37:49 <byorgey> no, I want paths representing the outlines of the glyphs
10:38:15 <lispy> So you want the vector representation of the glyphs?
10:38:21 <byorgey> right.
10:38:31 <byorgey> I don't know the font lingo =)
10:38:52 <14WAA1Z5W> outlines is correct
10:38:53 <lispy> I don't know the lingo either, TBH
10:39:17 <14WAA1Z5W> "we" say outlines
10:39:21 <14WAA1Z5W> <- made fonts
10:39:23 <byorgey> hehe, ok
10:39:29 <lispy> 14WAA1Z5W: thanks
10:39:35 <14WAA1Z5W> (that were actually used ;D)
10:39:51 <lispy> byorgey: so here is the "glyph management" api (this is the main part I haven't coded up yet): http://freetype.sourceforge.net/freetype2/docs/reference/ft2-glyph_management.html
10:39:56 <rostayob> If I've got a thunk, and the result varies based on what type I coerce on it (in my case, conversion from some data to data type), is there a way to try coercing various types and see the results, or do I have to write proxy functions?
10:40:00 <14WAA1Z5W> typophile.com has some jargon 101 if you ever find a need
10:40:17 * Twey likes that site.
10:40:30 <lispy> byorgey: This is probably the part of the API you need: http://freetype.sourceforge.net/freetype2/docs/reference/ft2-outline_processing.html
10:41:15 <byorgey> lispy: awesome, yes, that looks like exactly what I want
10:41:17 <lispy> byorgey: it will be a while before I have an interface to outlines.
10:41:36 <Cale_> rostayob: Uh, what? Thunks are the low-level representation of partially-evaluated expressions.
10:41:46 <byorgey> lispy: ok, no worries. I may just hack up a little C wrapper for what I need and make a binding to it
10:41:51 <lispy> byorgey: you're welcome to send me patches, but I haven't created a write up on how I'm translating to Haskell (and I'm doing it so algorithmically, it could almost be automated)
10:41:56 <whald> xplat: i appreciate your effort, but i have to leave now. wife and cild call for a meal.. i don't know when i'll be back on irc, so if you have any findings before i return could you please use the project bugtracker?
10:42:08 <Cale_> rostayob: They're a runtime thing which means that the typechecker has already done all its work
10:42:16 <Cale_> And types have been discarded
10:42:39 <byorgey> 14WAA1Z5W: cool, thanks for the link
10:42:42 <lispy> byorgey: creating a binding for this part should be pretty easy htough
10:42:51 <byorgey> lispy: ok.  yeah, doesn't look too bad.
10:42:56 <Cale> rostayob: If it was a typeclass-polymorphic thing, it will have been compiled to a function of the typeclass dictionary though.
10:42:59 <lispy> I don't see anything tricky about FT_Outline
10:43:08 <14WAA1Z5W> no problem, check out the forums
10:43:19 <Cale> rostayob: But for some reason I don't think you asked the question you really wanted to ask?
10:43:27 <14WAA1Z5W> we discuss font formats etc a lot
10:43:28 <rostayob> Cale_: oh yeah sorry, you are perfectly right, i used the wrong words...
10:43:33 <rostayob> my problem is at runtime
10:44:04 <byorgey> lispy: I'll probably just make my own, but with an eye to eventually contributing to/depending on your bindings whenever they get to that point
10:44:17 <rostayob> I've got a function that reads some data and then converts it to a data type
10:44:26 <rostayob> so it has type getData :: Maybe a
10:44:32 <rostayob> since it may not be able to convert it
10:44:43 <Cale> rostayob: Where 'a' is really some specific type?
10:44:52 <Cale> (surely it's not completely polymorphic ;)
10:45:04 <rostayob> Cale: it's a class, see it as Convertible
10:45:08 <Cale> okay
10:45:17 <rostayob> but the ultimate monomorphic type has to be coerced somewhere
10:45:31 <Cale> so  getData :: (Convertible a) => IO (Maybe a)
10:45:36 <rostayob> Cale: yep
10:45:41 <lispy> byorgey: okay.  Well, I'd like to see this library get used so my preference is obvious :)
10:46:14 <Cale> Okay, so you can try a bunch of specific types, and see if any of them work.
10:46:30 <Cale> But you have to write separate code to handle each case
10:46:38 <rostayob> Cale: ok, how do I do it in a "nice" way? without external function?
10:46:44 <rostayob> Cale: ok exactly, I can't right?
10:46:51 <Cale> because the values that you get in each case will be of different types
10:46:53 <rostayob> i have to do something like
10:46:58 <Cale> and so can't really be handled by the same code
10:47:06 <byorgey> lispy: by the way, when you say "it will be a while" until you support outlines, what order of magnitude do you have in mind?  weeks? months? years?
10:47:13 <Cale> At least, you won't be able to do much that's nontrivial with the values.
10:47:33 <Cale> If you don't know what type they are...
10:47:43 <rostayob> case (id foo :: Maybe One) of Nothing -> (id foo :: Maybe Two); Just one -> Just one
10:47:55 <rostayob> would something like that work
10:48:16 <rostayob> where foo is a return value of getData :: Convertible a => Maybe a
10:48:21 <Cale> The use of the identity function there is odd, but yes
10:48:27 <Cale> errrrrrr...
10:48:32 <lispy> byorgey: Just depends on how much free time I have.  I cranked out a huge portion of the core library last night.  So, in terms of work it's like probably 4 hours for the whole outline API and it could be done next, but I wanted to finish glyph management since I've already started it.  And glyph management is probably another 4 hours.
10:48:35 <Cale> wait, not if it's IO though
10:48:57 <14WAA1Z5W> lispy that's hellafast :D
10:49:11 <Cale> Oh right, hmm, problematic :)
10:49:15 <rostayob> Cale: what do you mean if it's IO?
10:49:24 <lispy> 14WAA1Z5W: I'm just doing a raw binding.  I'm not making one that is idiomatic haskell yet
10:49:27 <Cale> Let's say you have  convert :: (Convertible a) => String -> a
10:49:32 <Cale> (so like read)
10:49:36 <Cale> you'll want to write
10:49:41 <Cale> er
10:49:42 <byorgey> lispy: gotcha.  In that case, since text is not a huge priority at the moment, I think I'll just work on other pieces and hope you have it done by the time I get around to really wanting it
10:49:47 <lispy> 14WAA1Z5W: it basically comes down to how quickly I can write down the imports and storable instances
10:49:49 <Cale> convert :: (Convertible a) => String -> Maybe a
10:49:51 <Cale> rather
10:49:58 <Cale> Is that reasonable?
10:50:15 <rostayob> well... it is IO
10:50:28 <rostayob> and the io is not lazy, at that point the data is there
10:50:31 <Cale> okay... are you okay with running the IO action multiple times?
10:50:44 <rostayob> Cale: that's what I'd like to avoid, since it's a query
10:50:46 <lispy> byorgey: So, in terms of absolute time, if I don't finish it by Friday, then it will have to wait till next week or next weekend.
10:50:56 <Cale> Because the IO action might do something different in each case, if it's typeclass polymorphic
10:51:14 <Cale> And so you'd be forced to run it multiple times to deal with each type
10:51:15 <byorgey> lispy: right, but we're talking weeks, not months, in which case I will definitely just wait =)
10:51:29 <rostayob> Cale: ? the IO action is a database query, I'm pretty sure it does the same thing each time :P
10:51:29 <Peaker> int-e, scrollback reply: You might still leak a reference to the original array
10:51:41 <Cale> Really?
10:51:46 <byorgey> lispy: diagrams isn't going to be ready for a release for at least a few weeks yet anyway.
10:51:48 <rostayob> Cale: well yes
10:51:49 <lispy> byorgey: ah, cool.  I might even start on the idomatic interface by then
10:51:51 <Cale> Even if it's getting values of different types from the database?
10:52:04 <Cale> It's not going to send slightly different queries to the DB server?
10:52:05 <Cale> :)
10:52:24 <lispy> byorgey: My initial idea is to model their OO nature using a Reader monad
10:52:28 <rostayob> Cale: the database is documents based (mongoDB), all I get is bson documents
10:52:39 <Cale> The best way here is to know which types of values are in the database ahead of time.
10:52:48 <Cale> ah, okay
10:53:04 * hackagebot attoparsec 0.8.5.2 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.5.2 (BryanOSullivan)
10:53:12 <Cale> So, can you get a monomorphic value from the DB somehow which covers all possible bson documents?
10:53:34 <byorgey> lispy: neat
10:53:46 <Cale> Like, shouldn't it be something like  getData :: IO JSON
10:54:11 <Cale> and then you'd pick that JSON value apart and case branch on its constructors
10:54:19 <rostayob> Cale: that's the bson document in my mind. I've got this "class Bson a where; fromBson :: Monad m => Document -> m a; toBson :: a -> Document
10:54:39 <Cale> (btw, I hate that abuse of the Monad class)
10:54:58 <rostayob> Cale: that's not really my fault
10:55:06 <Cale> Okay :)
10:55:14 <rostayob> Cale: I mean I have lookup :: Val a => Document -> m a....
10:55:20 <rostayob> which gets a field
10:55:26 <tromp> @pl \l@(d:_)->[intToDigit(length l),d]
10:55:26 <lambdabot> (line 1, column 3):
10:55:26 <lambdabot> unexpected "@"
10:55:26 <lambdabot> expecting letter or digit, operator, pattern or "->"
10:55:43 <Cale> Which library are you using?
10:55:58 <rostayob> Cale: the mongoDB bindings, but all the mapping is by me
10:56:07 <Cale> I think you should be able to read the BSON document from the DB server as a ByteString or whatever, and then parse it in pure code
10:56:24 <Cale> You shouldn't be doing IO anyplace near the actual query.
10:56:28 <Cale> er, tsk
10:56:33 <Cale> that's not what I wanted to say
10:56:39 <Cale> You shouldn't be doing IO anyplace near the parsing :)
10:56:49 <Cale> The query should be in IO of course
10:56:54 <rostayob> Cale: it is
10:57:28 <Cale> But it should give you some monomorphic representation of the lookup which is not going to fail based on the type of data
10:57:55 <rostayob> Cale: maybe this will make things clearer: http://hpaste.org/45329/cale
10:58:42 <rostayob> Cale: well but that's inevitable isn't it?
10:58:47 <Cale> ho boy, template haskell :)
10:58:53 <rostayob> Cale: I know :P
10:58:53 <Cale> okay...
10:59:33 <xplat> man, i've been looking at the core listing for that Image.hs, but i cannot see where that addPixel function is allocating at all
10:59:35 <Cale> Well, the point is that if the type of data in the database might be multiple things
10:59:45 <Cale> then you don't want the query to the server to fail based on that
10:59:50 <Cale> if you only want to make one query
11:00:17 <xplat> (it doesn't help that it is actually inlined into addSample)
11:00:17 <Cale> You want to make a query, and get back some data which can be scrutinized to determine which type to convert it to
11:00:19 <rostayob> Cale: the query to the server doesn't fail. if the query to the server fail, bad stuff happens
11:00:24 <Cale> yeah
11:00:36 <rostayob> it's not related to the "m" in fromBson
11:00:39 <xplat> (well, it helps performance, but doesn't help analyze performance :)
11:01:02 <rostayob> Cale: anyway, I do have the data to be scrutinized :P
11:01:08 <Cale> So... you want to do your findOne, I guess, and then not apply fromBson immediately
11:01:16 <rostayob> but if I want to return a non-monomorphic type
11:01:26 <rostayob> Cale: yeah that's an option, but I wanted to avoid
11:01:28 <Cale> But instead, do some casing on whether each fromBson succeeds or not, at each type you want to try
11:01:32 <rostayob> exposing the bson stuff to the world
11:02:16 <rostayob> Cale: exactly. now how do I do the casing? my "id" was about that
11:02:30 <Cale> (id is normally the identity function)
11:02:41 <Cale> case fromBson x :: String of Just s -> ...; Nothing -> case fromBson x :: Int of ...
11:02:53 <Cale> You *could* do something like that...
11:02:58 <rostayob> Cale: yeah but I can't do the casing in the getPost function.
11:03:06 <Cale> er, should be Maybe String, Maybe Int
11:03:07 <rostayob> I can with an existential type, which is what I had before
11:03:16 <rostayob> but that was messy
11:03:21 <Cale> It is messy, yes.
11:03:36 <Cale> Why don't you know already which type of data you want to get?
11:03:36 <rostayob> I mean if the type signature is "Post p" I can't return Comment :P
11:03:52 <Cale> I mean, what are you going to do with this value of a type which you don't know what it is?
11:04:06 <rostayob> Cale: because sometimes knowing that it's a post is enough for me
11:04:27 <Cale> Note that types are a compile time construct only
11:04:34 <Cale> Types are boiled away by compilation.
11:04:41 <rostayob> i'd simply like to get a Post.. maybe the existential type is the only way
11:04:56 <Cale> If you want different "types" of things at runtime, you should use a datatype with multiple constructors.
11:05:16 <sm> g
11:05:38 <rostayob> Cale: no wait, I want types of a certain typeclass. I think that the only way to do that is with existential types
11:05:43 <sm> g'day all. Any idea where to install the emacs term info on a mac to prevent "ghc-pkg: setupTerm: Couldn't look up terminfo entry "eterm-color"" ?
11:05:47 <Cale> Or sure, you can get away with an existential type, but you should be aware of how existential types are compiled, because there's yet another option...
11:06:13 <rostayob> Cale: no, I'm not aware of that
11:06:14 <Cale> Which is to simply capture all the operations you want to be able to perform on the value, and store the operations, and not the value itself :)
11:06:15 <sm> ~/.terminfo/... doesn't seem to be working
11:06:30 <edwardk> storing the operations usually works a lot better
11:06:44 <edwardk> data ShowsPrec = ShowsPrec (Int -> String -> String)
11:06:54 <rostayob> Cale: yeah that makes sense
11:07:07 <Cale> Right? Let's say that the *only* thing you wanted to be able to do with the Post/Comment/etc. was to get its name, which was a String
11:07:13 <edwardk> instance Show ShowsPrec where showsPrec d (showsPrec f) = f d
11:07:18 <Cale> Then you could just store the String instead of the item
11:08:00 <Cale> and in other cases, where there might be other parameters to the operation, you can of course store functions of the remaining parameters.
11:08:08 <edwardk> this sort of thing has the benefit that it can usually keep your code haskell 98
11:08:41 <Cale> and in general, you can bundle up all these functions and other things into a record, and use that.
11:08:54 <Cale> Which is sort of the way that Haskell supports OO ;)
11:09:12 <rostayob> Cale: yeah it makes sense, but I think it's overkill for what I'm doing
11:09:20 <edwardk> i also abuse it to fake having higher order class constraints, but making instances that use data types that i don't export, but that is a more advanced topic
11:09:26 <rostayob> I don't know with haskell you tend to overabstract sometimes (:
11:09:30 <kowey> is there a CPP option I can use in Setup.hs that will tell me if I'm running cabal install on Windows?
11:09:48 <Cale> In my mind at least, OO is all about identifying values with the behaviour of the operations on those values.
11:09:52 <Twey> Hm
11:10:13 <Twey> What's the best option available in Haskell for sending a filter function to another process?
11:10:20 <Cale> rostayob: Well, if this is overkill, then existential types is even more overkill.
11:10:28 <edwardk> kowey: needs to be CPP so you can deal with imports?
11:10:54 <kowey> edwardk: I imagine so https://gist.github.com/904161
11:10:56 <rostayob> Cale: yes definitely (: that's why I removed it
11:11:08 <edwardk> blech
11:11:18 <Cale> Twey: Another system process? I think the only thing you can do is represent all the possible functions you want to deal using an algebraic datatype and send those values.
11:11:29 <rostayob> Cale: I mean I have just two outcomes at the end, so I could easily do getData :: Either This That
11:11:31 <Twey> Cale: Hm
11:11:32 <kowey> for some reason I expected that the #ifdef WIN32 would do what I want (without realising that this was for business code, where some cabal file had set it with -D)
11:11:46 <Cale> rostayob: Yeah, so  data Item = Post ... | Comment ...
11:11:55 <Cale> rostayob: and just use that
11:11:58 <rostayob> Cale: yep
11:12:09 <Twey> Cale: I was considering sending a sexpr and using a Lisp
11:12:12 <Cale> rostayob: But you'll want two instances of fromBson still.
11:12:12 <edwardk> hrmm,. can you try to use one of the  MIN_VERSION_package macros to see if a windows specific package is installed? ;)
11:12:15 <Twey> But I'd like to do it with Haskell if possible
11:12:36 <rostayob> Cale: yeah of course. thanks for help (:
11:12:38 <edwardk> oh wait, those only show up for dependent packages and setup doesn't have any
11:12:41 <rostayob> this channel is great ehe
11:12:43 <djahandarie> Twey, send the code and compile it, then run it ;)
11:12:51 <djahandarie> Don't worry, this is safe
11:13:37 <Cin> Technically it's safe if you parse it with haskell-src-exts and whitelist.
11:14:12 <djahandarie> I would prefer to use mueval, it has even moar protection
11:14:16 <djahandarie> But needs to be run as a seperate process
11:14:50 <sm> what does this cabal configure error mean: "cabal: internal error: configure install plan should have exactly one local ready package." ?
11:14:55 <Twey> Trust isn't an issue
11:15:03 <Twey> The sender is trusted
11:15:43 <Twey> I might go the ADT route, but I can't help but think ‘if I were using a Lisp this would be easy and convenient’ :þ
11:16:14 <kowey> edwardk: I just noticed I was only trying to run a makeExecutable action... (or not run it on Windows)
11:16:40 <kowey> edwardk: I think I'll skip the imports altogether and do something like "if not windows then system chmod u+x foo"
11:16:53 <gwern> djahandarie: well, separate process is better than the usual strategy of chroot jail
11:16:55 <edwardk> kowey: reasonable
11:19:53 <Cin> Twey: As I said the other day, eval'ing random code in Haskell is cumbersome/unstable/a pain.
11:20:06 <Twey> Cin: Yeah.
11:20:39 <sm> hmm, I get that error only if depending on http-enumerator 0.6
11:21:16 <gwern> Cin: eval'ing random code in general is dangerous in a dozen different ways
11:21:28 <Cin> Twey: I haven't had problems with mueval, fwiw. You can keep a persistent version of it open in a pipe.
11:21:40 <Cin> gwern: Thanks for the ‘sandbox 101’.
11:22:00 <gwern> Cin: my point is that it's not haskell that makes evaling cumbersome/unstable/a pain
11:22:12 <Cin> gwern: So?
11:22:45 <gwern> so you shouldn't criticize haskell for it
11:23:05 <rostayob> Cale: http://hpaste.org/45331/cale uhg (:
11:23:37 <Cale> rostayob: Does that not compile?
11:23:46 <xplat> gwern: there are many other languages that make evaling things easy/unstable/a pain
11:23:52 <rostayob> Cale: it does, but it's ugly (:
11:23:52 <Twey> gwern: The fact that it's dangerous doesn't mean that it need be inconvenient
11:23:53 <Twey> Right
11:23:54 <rostayob> wait wait
11:23:58 <gwern> xplat: yes, and said languages suffer the pain in a different way
11:23:59 <Cin> gwern: It's trivial in Lisp. It's a pain in Haskell. The fact that the language isn't to blame is irrelevant; the implementations as they stand are as they are.
11:24:23 <gwern> xplat: you get to play the lottery of security exploits, also known as 'will eval() let someone destroy my data/business *today*?'
11:24:42 <xplat> Cin: but is hint really that bad?
11:24:46 <Twey> gwern: Not necessarily
11:24:48 <Cin> gwern: Sounds like sou grapes.
11:24:57 <Twey> There are valid and perfectly safe uses of eval()
11:25:12 <rostayob> Cale: http://hpaste.org/45333/cale ahah i love haskell.
11:25:13 <Twey> Granted, they're not as common as some people think they are, but they exist
11:25:18 <gwern> Twey: sure. there are also pefectly valid and safe uses of guns, doesn't mean I want to hand them to any one who wanders around
11:25:20 <Cin> xplat: How bad is ‘that bad’?
11:25:44 <gwern> Twey: I instead lock the guns up in my gun safe and make it a bit difficult to access
11:26:06 <Cin> I don't think that analogy matches up.
11:26:15 <Cin> It's more like the gun is poorly built and doesn't function properly.
11:26:20 <Twey> gwern: The difference being that the person with the key can access them with a minimum of effort.
11:26:23 <Cin> Not that people are having difficulty using them.
11:26:41 <Twey> It's like locking them into a safe and throwing away the key
11:26:47 <djahandarie> Oh god, analogies.
11:26:51 <Twey> So that if you should ever need them, you have to first crack the safe
11:27:00 <Twey> djahandarie: Analogies are like sausages.
11:27:02 <gwern> yes, because hint is akin to cracking a safe
11:27:05 <gwern> it's *that* bad
11:27:17 <Twey> No, hint is a pre-cracked safe
11:27:37 * gwern found hint easy to use. gwern found *secure* hint hard to do.
11:27:44 <Cin> Hint is a water pistol.
11:27:48 <monochrom> mueval is a stackless tagless G-safe
11:27:52 <Twey> Haha
11:28:01 <Twey> I love how this conversation ended up
11:28:05 <Twey> But okay
11:28:13 <Twey> I think I will just not do arbitrary filters
11:28:24 <Twey> I'm sure a regex is Good Enough™
11:28:26 <Cale> rostayob: There's probably a complicated-machinery way to abstract over the remaining boilerplate, but until you have to do that a few dozen times, I wouldn't worry about it
11:28:28 <Cin> Twey: In summary, you don't have easy eval, so you don't want it. :-)
11:28:36 <Twey> Cin: Yes
11:28:42 <Twey> I didn't want it *that* badly.  :þ
11:28:47 <Cale> rostayob: because it'll involve some type system hackery :)
11:28:59 <earthy> how is eval better than writing a custom interpreter?
11:29:08 <earthy> that generates a function that can be called?
11:29:09 <Twey> earthy: You get all the power of the host language
11:29:13 <Cin> earthy: Good question. I am baffled how you generated it.
11:29:19 <Twey> Without the boilerplate of writing your own language
11:29:26 <xplat> import Language.Haskell.Interpreter; runInterpreter $ eval "1"
11:29:32 <xplat> this doesn't seem hard
11:29:43 <earthy> twey: and implementing e.g. lisp or scheme is hard? :)
11:29:44 <Twey> xplat: :t runInterpreter
11:29:53 <Twey> earthy: A whole one with libraries?  Hell yeah
11:29:58 <earthy> *ah*!
11:30:09 <Cin> earthy: Go implement one in 5 minutes.
11:30:11 <earthy> you want to use arbitrary libs. now there's a can of worms. ;)
11:30:23 <xplat> Twey: what about it?
11:30:25 <earthy> cin: 5 minutes is a bit hard. a day is doable.
11:30:27 <monochrom> I used to be a lisp fanboy, a perl fanboy, and a javascript fanboy. in all cases I didn't want eval badly, in fact I didn't want eval period. despite easy availability or whatever you call it. there goes your theory of wanting it because it's there.
11:30:44 <Twey> xplat: What's the answer?
11:30:57 <earthy> I see that eval can strongly help making writing interpreters easier
11:31:04 <Cin> monochrom: Your single experience is generalizable.
11:31:18 * Twey 's experience matches monochrom's
11:31:20 <monochrom> in fact the first time I saw eval (from lisp), I was like "what the hell, what is this monster"
11:31:30 <earthy> but I don't see how you can grant secure access to arbitrary libraries
11:31:33 <gwern> Cin: that'd be a good point, if you didn't have an implicit 'forall' in your original claim about easy eval
11:31:47 <Twey> earthy: Like I said, in this case the code is from a trusted source; security is not an issue
11:31:53 <monochrom> and the second time (from perl), I was like "ok whatever, I guess some people are depraved"
11:32:09 <Cin> gwern: What are you talking about?
11:32:20 <gwern> 'Twey: In summary, you don't have easy eval, so you don't want it. :-)'
11:32:21 <Phyx-> :t eval
11:32:22 <lambdabot> Not in scope: `eval'
11:32:39 <Phyx-> :t 7
11:32:40 <lambdabot> forall t. (Num t) => t
11:32:43 <monochrom> Cin: and your "In summary, you don't have easy eval, so you don't want it" is very generalizable, yeah right. I'm just citing a counterexample.
11:32:43 <earthy> twey: the source is trusted enough to *not* want to restrict it to a subset of available libs?
11:33:07 <earthy> (trusted sources have a tendency to go less trustworthy over time ;))
11:33:08 <gwern> monochrom: I think the basic logic point about universals and counter-examples is wasted on him
11:33:40 <xplat> runInterpreter :: (Control.Monad.CatchIO.MonadCatchIO m, Functor m) => InterpreterT m a -> m (Either InterpreterError a)
11:33:43 <monochrom> then again I'm also ignoring "converse /= contraposition" so there
11:33:47 <Twey> earthy: Yes
11:33:49 <Cin> Did I say that everyone wants eval?
11:34:06 <Twey> earthy: The trusted source in this case is part of the same program ☺
11:34:14 <Cin> And you're saying ‘I don't want eval’, which contradicts your point?
11:34:16 <Twey> (distributed program)
11:35:34 <earthy> twey: ah. so the trusted source is you yourself
11:35:45 <Cin> monochrom: gwern: Did I say that eval is universally desirable?
11:35:50 <xplat> Twey: you can only trust a distributed program as much as the platform
11:36:01 <earthy> one thing I've learned that I can not trust the me of 3 months in the future
11:36:13 <earthy> +is
11:36:22 <monochrom> well, let's just say I no longer understand what you say
11:36:44 <gwern> I already quoted Cin as to what he said and rested my case.
11:36:45 <earthy> cin: yes, you did
11:36:47 <xplat> earthy: that level of time-inconsistency is inconvenient
11:36:54 <Cin> earthy: Where?
11:38:06 <Cin> gwern: What do you think ‘you don't have easy eval, so you don't want it’ means?
11:38:07 <xplat> Twey: also, if it's the same program, why can't it figure out what filter its other instance wants it to use?
11:38:27 <gwern> Cin: no no, let's hear what you think it means first, in some logic.
11:39:03 <Twey> xplat: Because it can't read minds?  I'm confused by your question.
11:39:23 <Cin> gwern: Why did you extrapolate something if you didn't know what I meant?
11:39:44 <xplat> ‘you don't have easy eval, so you don't want it’ means that if you don't have easy eval, you won't leave a security hole open to reprogram you to want easy eval
11:39:55 <gwern> Cin: I 'extrapolated' plenty; I just want to hear your restatment first because I no longer trust you to not move goalposts when I give the obvious logical interpretation of your statement
11:40:15 <Cin> gwern: What is the obvious logical interpretation?
11:40:20 * gwern is still waiting.
11:40:30 <xplat> Twey: the other instance of the distributed program must figure out what filter to demand somehow
11:40:30 <monochrom> what is a turing test?
11:41:06 <monochrom> in fact, what is the result of pitting two turing tests against each other? :)
11:41:19 <Twey> xplat: User plugin
11:41:26 <Cin> gwern: Do you care to know what I meant?
11:41:34 <gwern> still no answer
11:41:55 <Cin> I'll take that as a ‘no’.
11:41:58 <xplat> Twey: is the plugin not available on the other instances?
11:42:03 <whald> xplat: i'm back, my people are well fed... sorry i had to leave in a hurry. so, do you have any suggestion for me?
11:42:05 <gwern> monochrom: I imagine they get frustrated at each other for the other just asking questions and never answering
11:42:39 <wlangstroth> monochrom: a conversation?
11:42:47 <earthy> okay, sorry, guys, calm down a bit
11:43:32 <xplat> whald: i stared at the ghc-core output for a while but nothing obvious.  :(
11:43:39 <earthy> I think we're all in violent agreement here 'yes, eval can be useful, but in very limited cases and usually it's not worth the effort of securing, especially if you have adt's and higher order functions'
11:43:56 <Twey> xplat: Well, the user plugin *is* the other process
11:43:58 <Twey> So no
11:44:33 <tromp> @pl \l->[intToDigit(length l),head l]
11:44:33 <lambdabot> ap ((:) . intToDigit . length) (return . head)
11:44:33 <whald> xplat: ok, thanks. the whole thing is not exactly slow anyway, and i'll need to rewrite addPixel soon to enable concurrency there, so...
11:44:36 <earthy> twey: are you aware of Clean?
11:44:53 <xplat> Twey: ah, this is not sounding that much like what i would ordinarily call a 'distributed program'
11:44:53 <Twey> earthy: Vaguely
11:45:05 <olsner> Phyx-: fo shizzle?
11:45:10 <earthy> it uses safe dynamics and a closed-world assumption to allow code-migration
11:45:41 <earthy> but this is currently being extended to also migrate functions into javascript...
11:45:56 <earthy> that system is called iTask
11:46:04 <xplat> earthy: apparently closed world is exactly what Twey doesn't have
11:46:06 <earthy> see http://wiki.clean.cs.ru.nl/ITasks :)
11:46:16 <earthy> xplat: he's using Haskell, so obviously
11:46:40 <earthy> (I've gotten the clean guys mighty miffed at me by asking 'okay, so, how does this translate to an open-world environment?')
11:46:53 <tromp> @pl map($l)[intToDigit.length,head]
11:46:53 <lambdabot> [intToDigit (length l), head l]
11:46:53 <xplat> earthy: no, i mean a closed world assumption would not be consonant with his architecture
11:47:08 <earthy> xplat: sorry, why?
11:47:11 <tromp> @pl \l->map($l)[intToDigit.length,head]
11:47:12 <lambdabot> flip map [intToDigit . length, head] . flip id
11:47:13 <hpc> :t \l -> [intToDigit (length l), head l]
11:47:13 <lambdabot> [Char] -> [Char]
11:47:21 <hpc> :t intToDigit
11:47:22 <lambdabot> Int -> Char
11:47:37 <earthy> twey: you need the situation where you cannot compile all parts in one go?
11:47:43 <xplat> earthy: he is migrating code from plugins into core modules
11:47:55 <earthy> hmright
11:54:56 <kowey> edwardk: thanks for the help! I think I now have one happier Windows user
11:55:19 <kowey> that's what I get for making things up rather than actually getting my hands on Windows and trying them out
11:58:11 <rostayob> Cale: yeah, but with haskell you can always keep abstracting, you need self control
11:59:00 <Cale> rostayob: yes :)
12:00:19 <xplat> you can do that with Java, too, it's just that the process converges at a lower level of abstraction
12:01:41 <rostayob> xplat: you are right, but with haskell you have many ways of abstracting. with java it's different
12:02:20 <wlangstroth> with Java, an ecstasy of diagrams is required first
12:02:57 <monochrom> I just don't abstract until I have two concrete examples, not just one.
12:03:14 <xplat> i think for UML diagrams as for crows, the collective is 'murder'
12:04:24 <wlangstroth> xplat: :)
12:04:29 <monochrom> in java etc you have to "abstract" more just because one ADT of n cases becomes one base class and n subclasses
12:05:03 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java
12:06:10 <aristid> when all you have is a foldr, things can suddenly become rather difficult oO
12:06:19 <monochrom> hahaha
12:07:20 <aristid> monochrom: didn't refer to your java lists stuff, tho :)
12:14:01 <xplat> monochrom: that implementation makes me want to add a Source Code tab to http://tvtropes.org/pmwiki/pmwiki.php/Main/UglyCute , but i know it would just get removed
12:17:43 <Twey> monochrom: Haha, that's cool
12:24:10 <hpc> xplat: functional java would make for some fun dailywtf posts
12:26:23 <Twey> Hmph… libxml-sax relies on c2hs but it's not listed in its Hackage deps
12:26:54 <monochrom> is c2hs an executable?
12:27:03 <c_wraith> ywa
12:27:06 <c_wraith> err, yes
12:27:21 <Twey> Yeah
12:27:27 <Twey> Executables can be deps, can't they?
12:27:34 <c_wraith> yes, but they don't auto-install
12:27:37 <monochrom> can be, but unsatisfactory
12:27:40 <Twey> Ah
12:27:47 <c_wraith> because there's no need for them to be *haskell* executables
12:28:22 <monochrom> ghc-pkg does not track executables. cabal does not track what ghc-pkg does not track.
12:30:14 <Phyx-> so... if i understant it correctly, cabal does also not track executables?
12:30:19 <Phyx-> weee i can form correlations
12:30:34 <monochrom> cabal relies of ghc-pkg to track anything
12:31:52 <c_wraith> I just executed the rare guerilla bug-report.
12:32:01 <monochrom> <user> hi cabal, is gtk2hs-buildtools installed? <cabal> hi ghc-pkg, is gtk2hs-buildtools installed? <ghc-pkg> @seen gtk2hs-buildtools <lambdabot> who's that? <ghc-pkg> cabal: what's that? <cabal> user: what's that? <user> darn
12:32:14 <hpc> c_wraith: what is this mystical thing?
12:32:28 <c_wraith> I saw dons on the street, and complained that foldr in bytestring is the same as foldr' in bytestring :)
12:32:36 <hpc> lol
12:32:38 <monochrom> hahaha
12:33:19 <monochrom> next time it's a rare bigfoot bug report
12:33:37 <c_wraith> guerilla /= gorilla :)
12:33:46 <hpc> complainasaurus rex
12:33:53 <hpc> thought to be extinct for millenia
12:34:38 <c_wraith> He asked why I actually wanted a non-strict version.  I think my answer convinced him that there are use cases for it!
12:34:51 <monochrom> oh oops, guerilla. next time it's a rare terror attack bug report then!
12:35:29 <frerich_> Hm, is it somehow possible for some tool to prove that two pure Haskell functions are equivalent?
12:35:41 <hpc> frerich_: it is indeed somehow possible :P
12:35:57 <hpc> not possible in general; halting problem, etc
12:36:01 <hpc> but for some functions you can
12:36:07 <monochrom> "I saw dons on the street. I gave him a paper letter about bytestring rewrite rules, with unknown white powder"
12:36:51 <osoleve> "I saw dons on the street, I kept getting in his way while waving signs about bytestring rewrite rules"
12:37:02 <osoleve> oh wait, that's peaceful resistance bug reporting
12:37:03 <osoleve> my bad
12:37:05 <frerich_> hpc: It was just an idea. I have some function which I *might* be able to replace with a foldr-based implementation. I was wondering how to test this properly.
12:37:47 <mightybyte> Is it well-known that parseTime d l . formatTime d l /= id?
12:38:02 <monochrom> we should organize a rare flash gang bug report some time
12:38:20 <c_wraith> that would be hilarious
12:38:23 <hpc> haha
12:38:46 <osoleve> or... a flash gangbang bug report
12:38:49 <osoleve> actually, nevermind
12:39:14 <Eduard_Munteanu> I actually read gang bang report there once... :/
12:39:28 <hpc> we should be true to the name, and the bugs we report should be in flash, not haskell
12:40:46 <Peaker> There are too many time API's in Haskell. I like the simpler C/Python API's -- all of them use GMT time everywhere except in string representations which use local time. (There are a couple of more flexible functions that you generally don't need). In Haskell I had to do a lot more work to find where the time APIs were, and then how to use them... :(
12:41:01 <hpc> ^
12:41:07 <mightybyte> Peaker: Yes, same here.
12:41:10 <hpc> there's a LOT of APIs
12:41:21 <lispy> Our locale stuff is lacking in general
12:41:28 <hpc> and a lot of subtly incompatible types
12:41:30 <mightybyte> Peaker: And now it appears that the ones I converged on are still buggy.
12:41:32 <lispy> Peaker: try to parse a currency!
12:41:57 <lispy> > "$1.00" :: Currency USD
12:41:58 <lambdabot>   Not in scope: type constructor or class `Currency'Not in scope: type constr...
12:42:04 <aristid> Peaker: what? just use the time package.
12:42:13 <lispy> > read "$1.00" :: Currency USD
12:42:13 <monochrom> I swear by UTCTime. only string representations may use time zones.
12:42:14 <lambdabot>   Not in scope: type constructor or class `Currency'Not in scope: type constr...
12:42:40 <monochrom> but probably windows people don't like that
12:43:20 <aristid> i think there are some specialized applications where you need to use local times
12:44:04 <nyingen> I really need to get a better grip on haskell's module system. It seems like every project I do runs into various problems with imports and exports, and I resort to -cpp
12:44:14 <aristid> like when office hours are always 8:00 to 13:00, and the country changes its DST rules, then your old stored UTC times may be wrong
12:44:43 <Eduard_Munteanu> nyingen: sometimes conditional compiling is needed
12:45:06 <lispy> Is there an RFC for currencies?
12:45:33 <lispy> I'm not finding one on google, but I may not know the right terminology
12:45:33 <Peaker> aristid, hmm.. seems like it needs old-locale if I want to format times?
12:45:43 <xplat> "i saw dons on the street, i wrote a complaint about failing fusion rules on a piece of paper, folded it up into an origami ball, and dropped it out my office window on his head" -- the elusive airstrike bug report
12:45:49 <mightybyte> > parseTime defaultTimeLocale "%-m/%e/%Y" "3/9/2011" :: Maybe Day
12:45:50 <lambdabot>   Not in scope: type constructor or class `Day'Not in scope: `parseTime'Not i...
12:45:58 <nyingen> in one project I ran into a nasty circular dependency problem, and in this one, some problem arose with Uniplate and/or DeriveDataTypeable when I factored the data defs out into a separate module
12:46:30 <nyingen> #include makes me feel so dirty
12:47:34 <Peaker> aristid, http://hackage.haskell.org/packages/archive/time/1.2.0.4/doc/html/Data-Time-Clock.html  and the POSIX module accompanying it don't seem as simple as ctime,time,strptime,strftime
12:47:44 <lispy> nyingen: I've always been able to solve my circular module imports by adding more modules to the import DAG.  GHC can use hs-boot files for truly circular imports
12:48:05 <Peaker> aristid, Not sure why a user of these libs needs to know about both DiffTime and NominalDiffTime?  Other lang APIs get it wrong?
12:48:35 <nyingen> lispy: Hmm, maybe I'll try that. I looked at the hs-boot stuff but it seemed like a hassle at the time
12:53:00 <nyingen> as for DeriveDataTypeable, there seemed to be some kind of scoping issue
12:53:06 <mightybyte> Can you add new modules to lambdabot on the fly?
12:53:27 <monochrom> in the end you probably stick to NominalDiffTime
12:53:29 <ddarius> mightybyte: At different times lambdabot has supported that ability in different ways.
12:54:04 <Cin> ddarius: Adding a line to L.hs?
12:54:25 <ddarius> xplat: An origami ball would be caught by the wind.  Hopefully, you added water to your water bomb.
12:54:58 <aristid> Peaker: NominalDiffTime is just like time_t, but it also allows fractional seconds
12:55:08 <ddarius> I think I misinterpreted mightybyte's question.  If it means what Cin's question suggests, then Cin's suggestion readily works.
12:55:14 <aristid> Peaker: and nothing about C's time API is simple. you're just accustomed to it.
12:55:37 <Peaker> aristid, what's DiffTime then?
12:56:12 <monochrom> if you have a table of leap seconds, you can use DiffTime, e.g., module Data.Time.Clock.TAI
12:56:33 <aristid> Peaker: DiffTime is REAL seconds, and NominalDiffTime ignores leap seconds.
12:56:49 <monochrom> however, it seems people just ignore leap seconds
12:57:12 <Cin> ddarius: Right; you were referring to plugins? I'd be interested in hearing about that.
12:57:22 <monochrom> so the simpler c and python apis are simpler because they don't even give you an option
12:57:26 <aristid> Peaker: POSIX time_t also ignores leap seconds.
12:57:53 <xplat> leap seconds greatly increase the algorithmic complexity of the calendar
12:57:53 <frerich_> Is it possible to tell runghc to show the single steps when executing a recursive function? I'd like to see what's going on, and why it's yielding unexpected results.
12:57:59 <Peaker> aristid, OK, why have both a leap-second ignoring diff time and a non-ignoring diff time?
12:58:18 <ddarius> Peaker: Because most of the time you don't care, but some of the time you do.
12:58:25 <aristid> Peaker: so you can distinguish between calculations that can take them into account, and those that can't?
12:58:27 <ddarius> Caring, though, is expensive.
12:58:44 <Peaker> ddarius, computationally or in terms of code complexity (of the user code, I mean, not library code)
12:58:52 <ddarius> Peaker: Both.
12:59:34 <sm> I think the time lib is pretty darn good once you find your way around
12:59:40 <sm> time is complex
12:59:42 <xplat> if you insisted on always caring, you'd have the same kinds of problems you get where java tries to fetch all the DTDs for xml documents it parses even if you don't want to validate
12:59:45 <aristid> sm: i agree.
12:59:49 <aristid> sm: well, it isn't complex
12:59:55 <aristid> it could be documented better
12:59:55 * ddarius remembers when these decisions were being made.
13:00:24 <Peaker> aristid, I am not sure I understand how I'm supposed to use DiffTime, given there aren't functions that generate it from a UTC time in there (except the exposed cons. field)?
13:00:24 <sm> I mean, the subject of time, as used by humans, is complex
13:00:44 <aristid> Peaker: then you don't need to use it? :)
13:00:54 <aristid> Peaker: i think it's used in LocalTime and in TAI
13:00:57 <xplat> Peaker: the problem with leap seconds and the reason people ignore them is that they occur at irregular intervals
13:01:04 <Peaker> aristid, then maybe "DiffTime" should have been quarentined in a separate "for those who care" module :)
13:01:15 * sm enjoyed http://blog.jonudell.net/2009/10/23/a-literary-appreciation-of-the-olsonzoneinfotz-database/
13:01:27 <mightybyte> sm: It is pretty decent...until you come upon parsing bugs in %m
13:01:36 <mightybyte> I have no idea why that hasn't been found yet.
13:01:36 <Peaker> aristid, it makes Data.Time.Clock seems more complicated?   And also, is Data.Time.Clock.POSIX available on non-POSIX systems? Converting to seconds-since-epoch is needed for compatibility/etc
13:01:39 <aristid> Peaker: well, DiffTime is the conceptually simpler one: it's actual seconds
13:01:54 <monochrom> Data.Time.Clock.TAI is the quarantine module. I agree DiffTime doesn't do anything in Data.Time.Clock
13:03:00 <monochrom> but you can easily pick up the fact that no function in Data.Time.Clock involves DiffTime so it's a null and void type
13:03:06 <xplat> Peaker: where 'irregular' means we are not smart enough to come up with a computer program to predict them and if we had one our computers would probably not run it faster than, or even as fast as, real time
13:04:22 <Peaker> I see.. My complaint came after I saw: A) Multiple different time packages (old-time, time, datetime), and code I tried to use used "datetime"... B) A bunch of modules in the "time" package which seems much larger than the C/Py API's  C) The Clock module is not a simple set of functions, but has big instance listings -- not sure how to improve on that :)
13:04:54 <Peaker> xplat, I thought leap seconds were computed in a simple standard way?
13:05:18 <Peaker> I am somewhat happy to be blissfully ignorant of the ugly complexities of calendar time :)
13:05:33 <aristid> Peaker: well, time is the standard, and people who use other packages are ignorant fools! :)
13:06:35 <quantum> Happy Haskell Tuesday
13:07:19 <sm> hurrah!
13:10:43 <xplat> (part of this unpredictability is due to unpredictability of the earth's rotational period due to seismic events or small-scale orbital chaos, etc; there is also some unpredictability added by the fact that a standards organization decides on the precise placement of leap seconds on a case by case basis when the need for them has become apparent)
13:13:16 <xplat> such are the inconveniences of living on a planet
13:13:32 <xplat> but it sure beats the alternatives, at least for now :)
13:14:41 <mightybyte> xplat: Such are the inconveniences of wanting to have our calendar and the earth's orbit around the sun be consistent.
13:17:02 <c_wraith> Hmm.  I guess I'd be ok with midnight and noon swapping places every few thousand years.
13:17:20 <ddarius> mightybyte: The solution is clearly to equip the Earth with large rockets.
13:17:39 <Eduard_Munteanu> Let's move to the Sun.
13:18:37 <Eduard_Munteanu> When's the 10 yrs anniversary again?
13:18:44 <Eduard_Munteanu> of #haskell
13:19:05 <xplat> Eduard_Munteanu: accounting for leap seconds or not?
13:19:53 <Eduard_Munteanu> Heh.
13:20:32 <Eduard_Munteanu> Well I mean, the day.
13:20:39 <Heffalump> Eduard_Munteanu: sometime in late 2001 or 2002, I think.
13:20:46 <monochrom> we should organize a rare flash gang bug report on the maintainer of the time package. we all show up at the same time around him and say "you shouldn't export DiffTime in Data.Time.Clock, useless there anyway"
13:20:51 <Heffalump> not sure if anyone but shapr would know for sure
13:20:53 <Eduard_Munteanu> Hrm, according to shapr it's soon.
13:21:05 <monochrom> now, we just need to settle on a small administrative trivia:
13:21:20 <Eduard_Munteanu> monochrom: you mean an intervention? :P
13:21:23 <monochrom> which one of DiffTime or NominalDiffTime should we use to sync our flash gang?!
13:21:26 <ddarius> @ask shapr When'd you make this channel?
13:21:26 <lambdabot> Consider it noted.
13:21:43 <ddarius> Heffalump: 2001
13:24:12 <Eduard_Munteanu> Registered : Apr 30 22:22:56 2001 (9 years, 48 weeks, 5 days, 22:10:13 ago)
13:24:17 <Eduard_Munteanu> I asked Chanserv.
13:24:57 <Eduard_Munteanu> So yeah, soon.
13:26:16 <Heffalump> Registered is probably after it was actually created, though.
13:26:58 <Heffalump> I recall it being near the beginning of a year
13:27:55 <alpa> hey
13:28:55 <Heffalump> I thought the channel creation was triggered by the pragmatic programmer "language of the year" being Haskell in 2002.
13:29:10 <Heffalump> so I don't understand how it was registered in 2001
13:30:25 * hackagebot tls-extra 0.1.7 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.7 (VincentHanquez)
13:30:53 <alpa> how can i write in haskell somthing like two while loops
13:31:17 <Skola> what's that!
13:31:32 <alpa> i mean like in java : while(x<100){  while(x<100){
13:32:07 <aristid> and what's inside the while? depending on that, there are many options.
13:32:16 <alpa> counter 
13:32:30 <alpa> it's like a for loop
13:32:37 <mauke> forM_ [0 .. 9] \x -> ...
13:32:43 <mauke> needs more $
13:32:47 <aristid> mauke: syntax error :P
13:33:19 <Eduard_Munteanu> Or list comprehensions.
13:33:38 <alpa> something like for(int i=0;i<100;i++){  for(int j=0;j<100;j++){
13:34:06 <c_wraith> > [ x * y | x <- [0..5], y <- [7..9] ]
13:34:07 <lambdabot>   [0,0,0,7,8,9,14,16,18,21,24,27,28,32,36,35,40,45]
13:34:30 <aristid> alpa: and what is IN THE LOOP? there must be more than a counter...
13:34:38 <c_wraith> alpa: haskell isn't so loose as many other programming languages.  The best answer depends on what you actually are *doing* with the loop.
13:34:59 <brbr> so i am working my way through LYAH... and Wow! I was not expecting "GAYBALLS"
13:35:08 <alpa> if statements
13:35:13 <Eduard_Munteanu> Also Cont probably can emulate stuff such as breakable while loops etc.
13:35:19 <mauke> preflex: ? vague
13:35:19 <preflex>  You had better be a bit more vague, otherwise we might be able to help you.
13:35:30 <aristid> alpa: http://hpaste.org
13:35:43 <c_wraith> alpa: it sounds like you're describing implementation, rather than what the loop is for.  Tell us about the latter.
13:36:18 <aavogt> well the effect of that loop is the same as    i = 100; j = 100 ?
13:36:30 <aavogt> or does it go to 101?
13:36:37 <Eduard_Munteanu> 101 :)
13:36:49 <mauke> not sure if joking
13:36:59 <Eduard_Munteanu> Wait, 100.
13:37:03 <Eduard_Munteanu> '<'
13:37:18 <c_wraith> No, in that case, it's not, because the scope of i and j is limited to the loop
13:37:42 <Peaker> I think it's weird \ is ok after infix operator, but not as a direct arg
13:37:49 <Eduard_Munteanu> Uh, yeah, scope thingy
13:38:01 <c_wraith> Peaker: that's the same as do
13:38:08 <sonoflil1t> Hi
13:38:17 <sonoflil1t> I'm trying to profile a Yesod app
13:38:24 <alpa> I'm trying to write something that multiply to prime numbers an tell me if the result is ...
13:38:35 <sonoflil1t> I do a very heavy operation, then quit with Ctrl+C Ctrl+C
13:38:41 <sonoflil1t> the .prof file is empty
13:38:53 <sonoflil1t> is there a workaround to get the profiler to flush?
13:38:56 <Peaker> c_wraith, also weird :)
13:39:04 <c_wraith> sonoflilit: only use one ctrl-c?
13:39:16 <mauke> alpa: the result of a multplication is another number, not "..."
13:39:40 <sonoflil1t> c_wraith: it won't quit the program, so profiling info won't be written
13:39:51 <alpa> yes i mean any number there
13:39:59 <sonoflil1t> Ctrl+C is handled by Yesod, I think, that could be related
13:40:00 <c_wraith> alpa: it's sounding like a list comprehension will do what you want.  Probably.  But really, describe what you want to do
13:40:04 <mauke> alpa: so ... a * b == c?
13:40:36 <Eduard_Munteanu> You mean check whether a given 'c' is a product of two prime numbers?
13:40:45 <c_wraith> alpa: Are you search for a pair of primes whose product is a given number?  Or what?
13:40:50 <c_wraith> *searching
13:41:48 <rostayob> @pg \a b -> truncate $ a / b
13:41:48 <lambdabot> (truncate .) . (/)
13:41:54 <alpa> mauke: yes but a and b are primes and i multiply every possible prime number until the result is the number i'm searching for
13:42:01 <mauke> alpa: wat
13:42:15 <alpa> it's for the RSA
13:42:25 <mauke> is that in africa?
13:42:30 <Eduard_Munteanu> LOL
13:43:00 <Eduard_Munteanu> And I guess DSA stands for Democratic South Africa :P
13:43:02 <c_wraith> alpa:  So you're brute-force factoring an integer known to be the product of exactly two primes?
13:43:31 <alpa> RSA cryptography
13:43:52 <xplat> alpa: that is wrong on so many levels
13:44:12 <Eduard_Munteanu> Oh, come on, maybe it's an exercise.
13:44:25 <alpa> c_wraith: yes
13:44:30 <navaati> hello
13:44:36 <c_wraith> alpa: do you have a list of primes already?
13:44:45 <alpa> yes
13:44:54 <quantum> YI can give the primes
13:45:29 <c_wraith> So, what you want to do is: find a pair of numbers from a list such that their product is your input.
13:45:35 <quantum> you shouldn't use brute force to factor: Number theorists have developed clever algorithms which are better
13:45:53 <quantum> you can learn the fast factor algorithm to crack your number in two
13:45:55 <xplat> that's like saying 'i'm trying to stack up some rocks so they stay together.  what's the best kind of glue to use?'  'that depends what you're trying to build'  'trying to break the record for world's tallest building'
13:46:07 <alpa> quantum: for example
13:46:19 <c_wraith> xplat: I'm assuming this is homework, though, and brute force is the expected approach
13:46:46 <monochrom> hahaha xplat
13:47:05 <sonoflil1t> is there a way for me to quit the yesod program gracefully, so that profiling info would be written to the file?
13:47:07 <c_wraith> alpa: You're best off, in this case, using a list comprehension.
13:47:10 <sonoflil1t> or a hack around it?
13:48:18 <monochrom> alpa: "pollard's rho" and "pollard's p-1" are pretty easy to understand and implement in haskell
13:48:44 <c_wraith> > [ (a, b) | a <- [1..10], b <- [1..10], a * b == 12]
13:48:45 <lambdabot>   [(2,6),(3,4),(4,3),(6,2)]
13:49:15 <Eduard_Munteanu> @oeis
13:49:15 <lambdabot>  Sequence not found.
13:49:30 <Eduard_Munteanu> @oeis [2,3,5,7,11]
13:49:30 <lambdabot>  Sequence not found.
13:49:33 <Eduard_Munteanu> Bah.
13:49:45 <mauke> @oeis 2,3,5,7,11
13:49:48 <lambdabot>  The prime numbers.
13:49:48 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:50:14 <Eduard_Munteanu> Ah, thanks.
13:50:33 <alpa> thx 
13:50:38 <xplat> @oeis 2,3,5,8
13:50:42 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
13:50:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:50:57 <Eduard_Munteanu> > [ (a, b) | a <- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47], b <- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47], a * b == 12]
13:50:57 <lambdabot>   []
13:51:14 <c_wraith> It's quite possible that 12 isn't the product of exactly 2 primes :)
13:51:16 <Eduard_Munteanu> > [ (a, b) | a <- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47], b <- [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47], a * b == 6]
13:51:17 <lambdabot>   [(2,3),(3,2)]
13:51:35 <quantum> Look at this way: The space of the universe is made of an atlas of manifolds and they are joined with maps which are constructed from numbers
13:51:42 <quantum> everything is numbers
13:52:39 <c_wraith> In fact, I chose 12 for my test case precisely because it's the smallest positive integer that would result in 4 results in the result list.
13:53:24 <navaati> does the order of application of monad transformers matter ?
13:53:29 <c_wraith> ...  And I formatted my search to be as inefficient as possible :)
13:53:40 <c_wraith> navaati: yes, many times.
13:54:03 <c_wraith> navaati: Not if every transformer is ReaderT, WriterT, and/or StateT, though.
13:54:04 <navaati> :/ then i don't know wich one to choose from
13:54:12 <aavogt> @unmtl ReaderT r (StateT s Identity) a
13:54:12 <lambdabot> r -> s -> (a, s)
13:54:14 <Eduard_Munteanu> It does matter when lifting though.
13:54:15 <navaati> ah, it's all right then
13:54:35 <c_wraith> well, yes, the result types change a bit, and lifting changes.
13:54:39 <c_wraith> But the semantics remain the same
13:54:40 <Eduard_Munteanu> But aside from that, yeah, there's some flexibility.
13:54:56 <navaati> what do you mean by "lifting" ?
13:55:04 <c_wraith> :t Control.Monad.Trans.lift
13:55:05 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
13:55:38 <xplat> if you use MonadReader and friends instead of explicit lifts, though ...
13:55:59 <xplat> then not much changes
13:56:21 <navaati> oh, the order of lifting ! yeah, classes are more convenient
13:56:27 <navaati> ok, thanks
13:56:29 <Eduard_Munteanu> xplat: what do you mean?
13:56:39 <sonoflil1t> what happens when I press Ctrl+C in a terminal with a Haskell program?
13:56:58 <Eduard_Munteanu> sonoflil1t: same thing as with other programs. They receive SIGINT.
13:57:09 <c_wraith> sonoflilit: depends on the platform.  on non-windows, it sends a signal, that the ghc runtime's signal handler picks up
13:58:01 <c_wraith> the default signal handler for SIGINT is to send ThreadKilled to the main thread.
13:58:26 <c_wraith> If that is caught, things get uglier.
13:58:27 <Eduard_Munteanu> You might want to install your own handler and do graceful cleanups before exiting.
13:58:38 <monochrom> your main thread can catch AsyncException, value UserInterrupt, if you're somewhat interested
13:59:11 <c_wraith> Oh, does it send userInterrupt?  Whoops, I got that all wrong.
13:59:26 <navaati> c_wraith: there are no things like signals on windows ?
13:59:30 <monochrom> not sure how well that works on windows :)
13:59:43 <c_wraith> Anyway.  The less-fun part is that if your main thread has caught UserInterrupt, the second ctrl-c just kills the program, regardless of signal handlers.
13:59:46 <sonoflil1t> Eduard_Munteanu: I think Yesod is installing one for me, and it is screwing with profiling, I think. Is there a way to bypass it and use the default?
14:00:09 <c_wraith> Err, that's not true at all.  It's not regardless of signal handlers.
14:00:13 <c_wraith> It's regardless of catches.
14:00:38 <c_wraith> It's actually the default signal handler...  The first time it's run, it throws UserInterrupt.  The second time, it just closes the program.
14:01:01 <Eduard_Munteanu> sonoflil1t: did you try using ctrl+c only once?
14:01:13 <Eduard_Munteanu> (and waiting a bit)
14:01:13 <c_wraith> That's why if you want ctrl-c to not have second-use is insta-death, you need to install your own handler for the signal.
14:01:35 <sonoflil1t> Eduard_Munteanu: it doesn't close my program, so there's no profiillng info
14:01:36 <monochrom> the next level down (of control, or of depravity) is your own signal handler for sigint, of course
14:01:49 <navaati> @unmtl WriterT String Maybe a
14:01:50 <lambdabot> Maybe (a, String)
14:02:17 <c_wraith> navaati: windows has a mechanism that's kind of like signals, but the interface to it is entirely different.
14:02:19 <monochrom> have you tried the normal sigterm? i.e., just normal kill
14:02:27 <monochrom> or are you on windows?
14:02:28 <navaati> @unmtl MaybeT (Writer String) a
14:02:28 <lambdabot> (Maybe a, String)
14:02:36 <sonoflil1t> monochrom: I'm on linux
14:02:48 <sonoflil1t> I don't think I understand your suggestion
14:02:51 <monochrom> alright, normal kill (sigterm) is worth a try
14:02:56 <xplat> @ty let ques = (ask :: ReaderT Int (Writer String) Int) in ques
14:02:57 <lambdabot> ReaderT Int (Writer String) Int
14:03:01 <xplat> @ty let ques = (ask :: WriterT String (Reader Int) Int) in ques
14:03:02 <lambdabot> WriterT String (Reader Int) Int
14:03:08 <sonoflil1t> oh, using the kill program
14:03:11 <sonoflil1t> I'll try
14:03:20 <monochrom> find the pid of the yesod process. kill <pid here>. do you get useful profile data?
14:03:30 <xplat> ask Just Works for either order, no explicit lift, so not much has to change
14:04:05 <c_wraith> I find it's easier to ctrl-z, kill %1.  But that's a bash thing
14:04:16 <aristid> it's funny how many combinators turn out to only require a Monad m => constraint
14:04:23 <monochrom> oh, that's more convenient where available, yeah
14:04:39 <sonoflil1t> monochrom: profile file still empty
14:04:43 <monochrom> (unless someone demonizes yesod)
14:04:47 <Eduard_Munteanu> xplat: hrm, didn't know about that, so it handles lifting implicitly?
14:04:48 <monochrom> alright, then I don't know
14:05:09 <Eduard_Munteanu> i.e. you don't need 'lift' anymore?
14:05:16 <mauke> ask is a method
14:05:39 <monochrom> oh actually, catching AsyncException (for ctrl-c or sigint once) and just doing a "return ()" may work wonder
14:06:03 <Eduard_Munteanu> mauke: ok, so MonadReader would have a 'tell' method for ReaderT, so it tries to pass it down the stack?
14:06:17 <mauke> hwat
14:06:21 <Eduard_Munteanu> (if there's a WriterT in there)
14:06:27 <sonoflil1t> monochrom: where in my code should I write that, and how?
14:06:53 <monochrom> I'm testing the idea now. if it works, I'll post in a moment.
14:07:09 <xplat> Eduard_Munteanu: that's a method of MonadWriter
14:07:39 <xplat> (tell, that is)
14:07:42 <Eduard_Munteanu> Yes I know. But I'm unsure what you mean by "explicit lifting".
14:07:57 <ddarius> aristid: People have rather stereotyped modes of thought.
14:07:59 <xplat> and Reader and ReaderT will have an instance that will pass that on
14:08:07 <c_wraith> monochrom: I'm afraid the problem is that yesod code is catching and ignoring that exception...  Leading to the observed behavior that "exiting a yesod program requires hitting ctrl-c twice"
14:08:10 <Eduard_Munteanu> Ah, that's what I meant.
14:08:30 * hackagebot exception-transformers 0.3 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.3 (GeoffreyMainland)
14:08:32 <monochrom> oh, that's evil
14:08:33 <Eduard_Munteanu> (what I should've said)
14:08:56 <sonoflil1t> c_wraith: yesod catches it and aborts the current request
14:09:01 <Eduard_Munteanu> Hrm, so actually, we don't need RWS.
14:09:15 <sonoflil1t> which doesn't help me arrive at profiling info
14:09:38 <c_wraith> sonoflil1t: just the current request?  That seems like *very* poor behavior.  I'd report it as a bug to Michael Snoyman.  He's generally receptive to those kinds of bug reports.
14:09:57 <Eduard_Munteanu> Still it'd be nice if these things weren't hardcoded.
14:10:16 <Eduard_Munteanu> And get monad combining more transparent.
14:10:26 <aristid> ddarius: is that positive or negative?
14:11:23 <wlangstroth> object oriented is to MVC as functional programming is to ... ?
14:11:35 <wlangstroth> anyone want to take a shot?
14:11:41 <dobblego> reality
14:11:59 <Eduard_Munteanu> MVC does seem a bit functional though.
14:11:59 <wlangstroth> :)
14:12:16 <wlangstroth> maybe that's why it's bothering me
14:12:22 <dobblego> MVC is a misguided attempt to reinvent functional programming
14:12:36 <revenantphx> dobblego: explain?
14:12:38 <hpc> i still don't know what MVC is
14:12:43 <sonoflil1t> c_wraith: not sure if just. but in the browser I get a nice "user aborted" message
14:12:47 <hpc> besides that it somehow involves a model, view, and controller
14:12:57 <Eduard_Munteanu> Ah, so I'm not the only one who noticed that :/. My Gtk2Hs adventures led me to it.
14:12:58 <navaati> I think MVC is an arrow
14:13:04 <revenantphx> hpc: It's basically the idea of splitting domain logic and application logic
14:13:10 <wlangstroth> hpc - convention for wrapping functionality
14:13:37 <hpc> an explanation that isn't in corporate double-speak?
14:13:41 <revenantphx> hpc: The "view" is something that presents information to the user.
14:13:42 <hpc> :P
14:13:45 <revenantphx> the "model" is the data source
14:13:47 <Eduard_Munteanu> ... where you could make a widget lazily refer to some data stored somewhere else.
14:13:49 <revenantphx> the "controller" mediates between those.
14:13:53 <hpc> ah
14:13:54 <revenantphx> and often delegates actions from the view.
14:13:57 <Eduard_Munteanu> (say, like a list widget)
14:14:05 <revenantphx> So like, in a List widget,
14:14:10 <revenantphx> the View is the widget 
14:14:12 <wlangstroth> the view is often a template
14:14:13 <hpc> so it's basically... common sense?
14:14:16 <revenantphx> the Controller is something that mediates
14:14:17 <wlangstroth> right
14:14:20 <acowley> MVC is more like good use of a module system
14:14:24 <revenantphx> and the Model is an array, or a database, w/e
14:14:27 <sonoflil1t> I'd talk this out with Michael, except that he's not online today and I'm already too sleep-deprived trying to solve this before my users kill me
14:14:31 <revenantphx> part of it is
14:14:33 <revenantphx> that using a good controller,
14:14:38 <revenantphx> means you can swap out models
14:14:55 <revenantphx> so I could back my tableview from MySQL or PostgreSQL models,
14:15:05 <revenantphx> provided the controller can take data from them and put it in a form I can display.
14:15:09 <revenantphx> so yeah, it's common sense.
14:15:27 <wlangstroth> it's a very specific version of common sense that many people are familiar with
14:15:33 <revenantphx> wlangstroth: ^
14:15:41 <hpc> haha
14:15:46 <revenantphx> Views are often templates too.
14:15:48 <navaati> revenantphx: in a GTK List widget, the view uses cairo, the controller uses XInput, the model is a list
14:15:51 <Eduard_Munteanu> Yeah, laziness isn't common sense everywhere.
14:16:01 <hpc> Eduard_Munteanu: sure it is
14:16:05 <revenantphx> I wrote a sparse hexagonal grid structure in C once.
14:16:08 <revenantphx> That was awesome :3
14:16:11 <Eduard_Munteanu> :)
14:16:28 <revenantphx> It was mostly a linked list, but higher insertion cost >_>
14:17:11 <navaati> @unmtl ReaderT env (WriterT log Maybe) a
14:17:12 <lambdabot> env -> Maybe (a, log)
14:17:39 <navaati> @unmtl WriterT log (ReaderT env Maybe) a
14:17:39 <lambdabot> env -> Maybe (a, log)
14:17:50 <navaati> wtf oO
14:17:51 <monochrom> sonoflil1t: http://hpaste.org/45340/catch_ctrlc  not sure if this applies to yesod, but I can get profile data
14:18:11 <Eduard_Munteanu> Actually not laziness per se, but coupled with side-effects.
14:18:26 * Eduard_Munteanu can't find his words.
14:18:27 <aristid> @unmtl ReaderT env Maybe a
14:18:27 <lambdabot> env -> Maybe a
14:18:29 <monochrom> and camelcase can die die die
14:18:31 <elliottt> navaati: ReaderT and WriterT don't interact.
14:18:48 <aristid> elliottt: does @unmtl optimise?
14:18:53 <elliottt> nope
14:18:58 <wlangstroth> monocrhom: whatsWrongWithCamelCase? Are you having Java flashbacks?
14:19:19 <aristid> elliottt: why not (env -> Maybe a, log), then?
14:19:28 <elliottt> because of where you have maybe
14:19:44 <elliottt> WriterT log (ReaderT env Maybe) a
14:19:46 <elliottt> would give you that
14:20:02 <elliottt> @unmtl WriterT log (ReaderT env Maybe) a
14:20:02 <lambdabot> env -> Maybe (a, log)
14:20:06 <elliottt> -_-
14:20:27 <navaati> yes, that was what blew my mind
14:20:29 <elliottt> @unmtl MaybeT (WriterT env) a
14:20:29 <lambdabot> err: `WriterT env (Maybe a)' is not applied to enough arguments, giving `/\A. Maybe a (A, env)'
14:20:39 <elliottt> @unmtl MaybeT (WriterT env Id) a
14:20:39 <lambdabot> Id (Maybe a, env)
14:20:45 <monochrom> wlangstroth: http://uncyclopedia.wikia.com/wiki/ZomboCom is what's wrong with camel case
14:21:01 <elliottt> @unmtl ReaderT env MaybeT (WriterT log Id) a
14:21:01 <lambdabot> err: `MaybeT (WriterT log Id)' is not applied to enough arguments, giving `/\A. Id (Maybe A, log)'
14:21:08 <elliottt> @unmtl ReaderT env (MaybeT (WriterT log Id)) a
14:21:08 <lambdabot> env -> Id (Maybe a, log)
14:21:24 <elliottt> @unmtl MaybeT (ReaderT env (WriterT log Id)) a
14:21:24 <lambdabot> env -> Id (Maybe a, log)
14:21:52 <elliottt> @unmtl WriterT log (MaybeT (ReaderT env Id)) a
14:21:52 <lambdabot> env -> Id (Maybe (a, log))
14:21:57 <elliottt> hehe
14:22:01 <elliottt> this is a good time.
14:22:31 * hackagebot exception-mtl 0.3 - Exception monad transformer instances for mtl2 classes.  http://hackage.haskell.org/package/exception-mtl-0.3 (GeoffreyMainland)
14:22:33 <elliottt> oh, of course you can never get (env -> Maybe a, log)
14:22:46 <wlangstroth> monochrom: youre_more_into_underscore? ortotallyunreadable?
14:22:51 <xplat> what is this '/\A.'?
14:22:52 <elliottt> that's like running a second monad returned by WriterT log Id
14:22:56 <monochrom> I use oleg'case
14:23:07 <elliottt> you'd have something like (WriterT log Id (ReaderT env Maybe a)
14:23:32 <wlangstroth> monochrom: oh no you di'ent
14:23:32 <elliottt> when the environment is inside the pair, you're no longer composing the monads.
14:23:47 <monochrom> http://hpaste.org/45340/catch_ctrlc
14:24:00 <xplat> @unmtl ReaderT env Maybe a
14:24:00 <lambdabot> env -> Maybe a
14:24:11 <xplat> @unmtl WriterT env Maybe a
14:24:12 <lambdabot> Maybe (a, env)
14:24:34 <xplat> @unmtl WriterT log Maybe a
14:24:34 <lambdabot> Maybe (a, log)
14:25:52 <xplat> i don't see why that's mindblowing that they commute like that
14:27:19 <xplat> ReaderT puts the other monad on the inside, WriterT puts it on the outside
14:27:23 <navaati> i guess there is no objection mixing monads and arrows ?
14:27:42 <elliottt> navaati: what do you mean?
14:28:00 <navaati> this : "newtype Program a b = Program {getProgram :: ReaderT PIC (WriterT Initialised Maybe) (Value a -> Value b)}"
14:28:08 <xplat> you can turn a monad into an arrow using the Kleisli newtype
14:28:19 <xplat> but of course you can also just nest them or whatever
14:28:23 <elliottt> yeah, that's fine.
14:28:44 <elliottt> if you look in Control.Arrow, there's the kleisli arrow, which turns any monad into an arrow.
14:29:08 <elliottt> (i'm sure i'm phrasing that badly)
14:29:19 <navaati> hum, I don't think it's what i need
14:29:47 <xplat> hm, monads have the Kleisli arrow, comonads have the Cokleisli one
14:29:58 <xplat> but what is the one for Applicatives called?
14:30:10 <Eduard_Munteanu> Hrm, what's the correct CT lingo for that, the monad is a Kleisli arrow?
14:30:35 <monochrom> Applicative has Stars and Stripes. <*> and <|>
14:31:23 <xplat> Eduard_Munteanu: actually 'Arrow' is probably hated by category theorists, it conflicts with their terminology all over the place
14:32:02 <xplat> even for mathematicians there's such thing as a bad overload
14:32:07 <Eduard_Munteanu> I mean, monads are Kleisli arrows (like, plain CT arrows) in the Arrow category, IIRC.
14:32:32 * Eduard_Munteanu looks it up...
14:32:58 <xplat> nono, but the Kleisli newtype represents (plain categorical) arrows in the Kleisli category of a Haskell monad
14:33:20 <xplat> which just so happen to also form an Arrow in the Control.Arrow sense
14:34:00 <Eduard_Munteanu> Yeah, I got it wrong a bit... http://en.wikipedia.org/wiki/Arrow_(computer_science)#Kleisli_arrows
14:34:23 <Eduard_Munteanu> (if that's accurate)
14:34:36 * hackagebot exception-monads-tf 0.3 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.3 (GeoffreyMainland)
14:34:41 <sonoflil1t> monochrom: I don't see a difference in behavior, maybe I integrated it wrong...
14:34:41 <xplat> but the Kleisli Arrow refers to the whole category, not the specific arrows
14:35:15 <elliottt> right.  it's just that you can use arrows with the Kleisli m type
14:35:22 <azaq23> Does wiki mean it when it says "In computer science"? Because that just looks like haskell with category theory syntax.
14:35:23 <xplat> (er, rather the Kleisli m arrow)
14:35:26 <Eduard_Munteanu> Yeah.
14:35:51 <mauke> azaq23: I thought you might be german
14:35:56 <Eduard_Munteanu> azaq23: I think so, it does seem to draw from type theory
14:36:05 <sonoflil1t> well
14:36:11 <sonoflil1t> I'm way too tired for this
14:36:15 <azaq23> mauke: I am :)
14:36:32 <Eduard_Munteanu> Because of "just looks like"? :/
14:36:37 <sonoflil1t> unless there's some good suggestion from someone, I'm abandoning this until tomorrow
14:36:45 <xplat> basically a big-A Arrow is a type constructor, that when you supply it with two types, gives you another type, whose members in turn are arrows in the CT sense
14:36:57 <mauke> using "wiki" to refer to "wikipedia" seems to be a german thing
14:37:19 <xplat> (and there's some extra structure implied over and above being a CT arrow too)
14:37:32 <sonoflil1t> good night
14:37:35 <Eduard_Munteanu> Hrm, it's not uncommon here either, though I don't do that.
14:37:54 <azaq23> Eduard_Munteanu: The first sentence even mentions ArrowApply, that just seems like a little bit too much of a coincidence
14:38:31 <Eduard_Munteanu> Well I think it's also because it's been formalized by computer scientists :)
14:38:41 <Eduard_Munteanu> Which might've used Haskell or something similar.
14:38:47 <xplat> azaq23: arrows are technically a CS concept, but they've only really been developed much by computer scientists who use Haskell
14:39:24 <xplat> including the folks who invented them
14:40:29 <xplat> monads, otoh, were introduced to CS by a more pure theoretician who didn't use them as a programming construct directly
14:40:53 <elliottt> moggi?
14:40:58 <xplat> yeah
14:41:23 <xplat> and then Wadler read Moggi and the rest was history
14:42:37 * hackagebot ref-mtl 0.3 - A type class for monads with references compatible with the mtl2  library.  http://hackage.haskell.org/package/ref-mtl-0.3 (GeoffreyMainland)
14:43:22 <xplat> that short package description seems a little insufficient
14:43:43 <xplat> what are 'monads with references'?
14:43:59 <elliottt> io/st refs?
14:44:45 <xplat> ah, yes, references to mutable cells
14:44:53 <azaq23> makes sense, then. Just noted the app arrow / application morphism is = uncurry id, ddarius mentioned that some days ago
14:45:13 <xplat> @ty uncurry id
14:45:13 <lambdabot> forall b c. (b -> c, b) -> c
14:47:05 <xplat> that looks like the counit of the store comonad
14:47:26 <xplat> er, wait, not
14:47:32 <elliottt> how is the store comonad defined?
14:47:57 <xplat> no, wait, it is ...
14:51:58 <Taslem> @pl (\x -> r (fst x) (snd x)  )
14:51:58 <lambdabot> uncurry r
14:53:28 <elliottt> data Store s a = Store (s -> a) s
14:54:19 <Taslem> I have a function (f)  and a list (l) and I want to apply (f x) to l!!0, l!!1, l!!2, l!!3, etc.
14:54:25 <Taslem> Is there a  function for that?
14:55:06 <nlogax> just upgraded to ghc 7, now i get "Link with -rtsopts to enable them.". where can i put that in my cabal file?
14:55:31 <dcoutts> ghc-options or on the command line --ghc-options=
14:57:51 <azaq23> > [(* 2), (* pi)] <*> [1, 2, 3, 4] -- Taslem
14:57:52 <lambdabot>   [2.0,4.0,6.0,8.0,3.141592653589793,6.283185307179586,9.42477796076938,12.56...
14:58:11 <azaq23> > > [(* 2)] <*> [1, 2, 3, 4]
14:58:11 <lambdabot>   <no location info>: parse error on input `>'
14:58:31 <Taslem> Actually, I'm looking for foldr. THe trouble being that the way I've got it isn't in format that makes that easy.
15:00:39 * hackagebot ref-tf 0.3 - A type class for monads with references using type families.  http://hackage.haskell.org/package/ref-tf-0.3 (GeoffreyMainland)
15:00:46 <azaq23> If you only have one function anyway, that's just map, regarding my source above.
15:00:46 <Cale> Taslem: map?
15:01:00 <Cale> > map (*10) [1,2,3,4]
15:01:00 <lambdabot>   [10,20,30,40]
15:01:16 <Taslem> No, I needed foldr.
15:01:56 <hpc> you can implement map with foldr
15:02:03 <blackdog> what do you guys use for interacting with web services in haskell?
15:02:10 <hpc> :t \f -> foldr ((:) . f) []
15:02:11 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
15:02:25 <blackdog> in particular, https services... doesn't seem to be anything as easy as restclient or httparty from ruby
15:02:34 <blackdog> curl does everything but is a bit of a bear to use
15:02:49 <monochrom> I used hxt, but I did not need https
15:05:11 <aristid> blackdog: http-enumerator has a relatively decent API and SSL support
15:06:03 <blackdog> aristid: i was looking at it, but the github page doesn't seem to have even a readme
15:06:37 <blackdog> aristid: is there sample code somewhere?
15:08:34 <aristid> blackdog: http://hackage.haskell.org/packages/archive/http-enumerator/0.5.1/doc/html/Network-HTTP-Enumerator.html
15:09:44 <aristid> the fact that http returns an Iteratee that needs to be unwinded with run_ is somewhat inconvenient but snoyman tells me there is logic behind it
15:10:45 <bsod2> all software has logic behind it ^.^
15:11:56 <shutdown_-h_now> 7
15:14:03 <monochrom> kill -9 shutdown_-h_now :)
15:18:22 <aristid> monochrom: you mean killall.
15:18:38 <hpc> or `pidof shutdown_-h_now`
15:18:45 <blackdog> aristid: urk. after writing four or five lines where one would do in ruby, i'm thinking there is perhaps space for a high-level web interaction package in haskell.
15:19:38 <aristid> blackdog: what were you attempting to do?
15:20:19 * hpc envisions something like LWP, without the ridiculous form nonsense
15:20:57 <blackdog> aristid: send an https post with user auth details
15:21:10 <blackdog> even the curl command line is better
15:21:33 <aristid> with POST?
15:21:43 <blackdog> aristid: yes
15:22:22 <aristid> blackdog: you could write wrapper functions and submit them to michael snoyman :)
15:22:28 <blackdog> i have no doubt you need the fancy interface for doing high-speed transfers etc
15:22:38 <blackdog> but frequently you don't care how slow it is:)
15:23:00 <blackdog> aristid: it's on my list. i've taken a tip from dons: my new discipline is writing one package a week and blogging about it.
15:23:12 <blackdog> so i have to stay a bit focused.
15:23:18 <aristid> hmm :)
15:23:49 <aristid> lbsIter can give you the entire response in a ByteString so you don't need to mess with Iteratees if you don't want to
15:24:01 <aristid> of course httpLbsRedirect already does that
15:25:13 <blackdog> aristid: looking at this sort of thing: https://gist.github.com/904720
15:25:53 <overscore> Hi. Does anybody have experience with QtHaskell ?
15:26:32 <blackdog> aristid: also, am i going to have to roll basic auth myself?
15:26:56 <aristid> don't ask me, never had to deal with basic auth
15:28:24 <aristid> blackdog: generally, client-side http is still a relative immature thing in haskell. the libraries are not quite finished yet, and http-enumerator is being developed actively
15:28:59 <edwardk> blackdog: i think i average something like that, except in my case its 20 packages in one week, then 19 weeks of slacking off
15:29:49 <blackdog> edwardk: I'm not smart enough to write 20 packages in a week, so it's going to have to be consistency:)
15:29:57 <edwardk> =)
15:30:25 <blackdog> the enforced discipline is interesting - i've been working on hubris for a long time now, and ebcause it's open-ended there's no real drive to finish.
15:30:42 <blackdog> i figure a few small, tightly-scoped projects will be good kata
15:31:13 <overscore> research project ? :P
15:31:19 <blackdog> and if along the way i find some things that desperately need to be written, i ca nadd them to my list. i suspect the list will be monotonically increasing.
15:31:27 <blackdog> overscore: no, just a personal bugbear
15:32:02 <blackdog> aristid: and yeah, i tend to agree. i'd like to see haskell at the point where it's got the same sort of whipuptitude that ruby and perl have, only safe.
15:32:33 <hpc> it already does, on the server side of things
15:32:35 <overscore> i'd love to see better UI support. OpenGL too :)
15:33:01 <blackdog> hpc: it's getting better. it's not at ruby's level yet.
15:33:21 <blackdog> part of that's just a function of a smaller, less web-focused community
15:33:25 <lispy> blackdog: yeah, I keep running into what I've dubbed "the recursive problem"
15:33:37 <hpc> the recursive problem?
15:33:42 <blackdog> but if i want to get a ruby site up, there are a heap of tools designed to make it smooth.
15:33:47 <lispy> blackdog: I started working on X, then I realized X needs a good Y, so I work on Y, and then I find that Y needs a good Z, so I work on Z.
15:34:05 <blackdog> and it's necessarily not tail-recursive:)
15:34:17 <lispy> A common base case is cabal
15:34:27 <lispy> At which point I usually file a bug report and look for a workaround
15:34:31 <niteria> weird thing happened to me
15:34:33 <niteria> https://gist.github.com/904732
15:34:45 <niteria> looks like overflow, but why?
15:34:45 <blackdog> lispy: cabal has been helpful, but it's certainly part of the problem sometimes
15:34:48 <hpc> so it's like dependency hell only "unfinishedness hell"
15:34:53 <blackdog> for instance, the test-suites thing
15:35:03 <lispy> blackdog: yeah.  It's awesome for the 80% case.  It's painful as hell for the last 20.
15:35:07 <blackdog> i'd love to use it, but it's only in the latest release, which no-one will have, so ...
15:35:15 <hpc> niteria: what's the type of result?
15:35:35 <aristid> blackdog: soon enough a big number of people will have the latest cabal :)
15:35:45 <niteria> hpc: Int
15:35:54 <hpc> > (maxBound :: Int)
15:35:55 <lambdabot>   9223372036854775807
15:36:00 <hpc> > 9223372036854775807 + 1
15:36:01 <lambdabot>   9223372036854775808
15:36:07 <hpc> > 9223372036854775807 + 1 :: Int
15:36:08 <lambdabot>   -9223372036854775808
15:36:10 <blackdog> actually, i should ask: what are the things you guys do wehn you set up a new project?
15:36:12 <hpc> there we go
15:36:30 <niteria> how it decided to use Int
15:36:34 <nlogax> dcoutts: tried that, but didn't appear to work… worked better after some cabal cleanage, doh!
15:36:37 <blackdog> current project is a project-starter:) adds a github repo and a CI project on jenkins, sets up a test suite, etc.
15:36:42 <niteria> I didn't tell it anywhere
15:36:45 <hpc> niteria: monomorphism restriction
15:36:55 <aristid> hpc: maybe you used length somewhere?
15:36:56 <dcoutts> lispy: that's how I got involved with cabal :-)
15:37:01 <aristid> i mean niteria
15:37:04 <lispy> blackdog: lately, my projects have been on github which takes care of most of what I need transparently.  Issue tracker, wiki, good repo hosting, etc.
15:37:07 <dcoutts> lispy: chasing a chain of dependencies
15:37:10 <hpc> oh, and that
15:37:12 <ville> blackdog: cp ~/projects/skeleton/haskell ./new_project
15:37:16 <xplat> lispy: yak shaving
15:37:18 <hpc> yeah, length is in props6
15:37:22 <benmachine> deleteBy is rubbish
15:37:23 <hpc> and props4
15:37:24 <aristid> ville: cp -r?
15:37:25 <niteria> aristid: I did
15:37:26 <benmachine> I worked this out just now
15:37:27 <hpc> :t deleteBy
15:37:28 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
15:37:29 <ville> aristid: oh yeah
15:37:29 <niteria> ok, I see
15:37:39 <blackdog> lispy: yep, i'm using github for this
15:37:39 <hpc> @src deleteBy
15:37:39 <lambdabot> deleteBy eq x []        = []
15:37:39 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
15:37:41 <niteria> thanks
15:37:42 <dcoutts> lispy: I started many years ago trying to make an IDE, then got involved with gtk2hs, then installers, packaging, then cabal :-)
15:37:46 <benmachine> there is no reason for it to not be (a -> Bool) -> [a] -> [a]
15:37:51 <lispy> dcoutts: heh
15:38:04 <benmachine> notice that eq is only called with x as the first argument, and x is not used for anything else
15:38:05 <blackdog> dcoutts: reckon cabal's your base case?
15:38:08 <dcoutts> lispy: I've tried to draw the line at ghc and not dig in there
15:38:14 <hpc> :t delete
15:38:14 <lispy> dcoutts: my freetype hacking (and then reporting ghc bugs wrt to alloca) are because I wanted to learn opengl shaders :)
15:38:15 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
15:38:18 <dcoutts> blackdog: I've tried not to go much lower :-)
15:38:18 <Peaker> deleteBy seems silly for taking "eq" and "x" only to apply eq to x first
15:38:23 <benmachine> Peaker: right
15:38:31 <dcoutts> lispy: :-)
15:38:38 <benmachine> I guess it's consistent with the other *By functions
15:38:43 <benmachine> but really there's no need for it
15:38:52 <overscore> opengl shaders + haskell ? :O
15:39:44 * hackagebot text 0.11.0.7 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.7 (BryanOSullivan)
15:40:56 <lispy> overscore: yeah.  If people can write games in python, Haskell should be even better.  Higher performance, more type safety, and good libraries.
15:41:07 <lispy> same goes for Java actually
15:41:20 <Peaker> Java has horrible expressiveness though
15:41:39 <lispy> Peaker: that's what I mean.  If people can make Java games, Haskell games should be even easier.
15:41:46 <kowey> sorry to be a squeaky wheel here, but I was wondering if I could get some attention from support@cho :-)
15:41:48 <Peaker> ah, thought Java > Python
15:41:53 <aristid> only problem with haskell is that it tempts people to experiment with FRP
15:41:59 <aristid> the black hole of UI programming
15:42:00 <aristid> :P
15:42:00 <lispy> kowey: move to the cloud :)
15:42:18 <lispy> kowey: what do you need help with?
15:42:47 <kowey> oh I'd sent support@cho a couple of mails asking for login restoration (along with my ssh public key)
15:43:46 <kowey> my users are starting to complain about the GenI user manual being missing (which is hosted on projects.haskell.org)
15:43:53 <lispy> Hmm...I must not be on that list
15:44:23 <aristid> github.com is good for project hosting :P
15:44:39 <kowey> heh
15:44:41 <thoughtpolice> lispy: while you're at it, make awesomely idiomatic haskell openGL bindings, and solve the FRP so we can all write games/UIs in bliss forever
15:44:44 <thoughtpolice> :P
15:44:48 <thoughtpolice> *frp problem
15:44:49 <lispy> aristid: yes, that's what I'm learning.  I wish they supported more than just git repos.
15:44:50 <dcoutts> kowey: is your account not restored yet?
15:44:58 <kowey> nope
15:45:09 * dcoutts takes a look at the RT queue...
15:45:11 <lispy> thoughtpolice: I haven't tried the FRP koolaid yet.
15:45:26 <Peaker> yairchu wrote a nice discrete-time FRP thingie with an OpenGL game to show for it (defendtheking, FRP lib is peakachu)
15:45:45 * kowey hopes he didn't manage to send his request in some unhelpful manner...
15:46:13 <lispy> thoughtpolice: I'm a few days away from posting my own openglraw repos that fix some outstanding things with the existing stuff.  I just want to make sure I give Sven a month or so to reappear before I make any potentially disruptive announcements
15:46:14 <xplat> the problem with FRP is that once you see it, and write even a tiny useless demo, you cannot write conventional GUI code anymore
15:46:37 <xplat> because the latter just seems so WRONG
15:47:44 <aristid> xplat: most of the FRP libraries seem to have problems tho
15:48:15 <xplat> aristid: yes, but merely not working seems almost blissful compared to the problems of the standard approach
15:48:30 <aristid> hah
15:48:33 <dncr> aristid: is elerea problematic
15:48:46 <aristid> dncr: "elerea"? don't know that word
15:49:05 <lispy> This may be a potentially controversial point, but I kind of wish we didn't have community.h.o.  I think we have too few volunteers to spend our time maintaining it properly.  But, I do understand we have a need to somehow host small open source haskell stuff when people want to use VCS such as darcs.
15:49:08 <dncr> aristid: it's an FRP library, http://hackage.haskell.org/package/elerea
15:49:18 <elliottt> xplat: have you tried reactive-banana?
15:49:36 <ClaudiusMaximus> lispy: i wrote some openglraw-alike bindings once (just the very few functions i needed in one project), but i can't remember why i needed to do that.  maybe it was before openglraw existed?
15:49:40 <Peaker> dncr, as I said above, there's peakachu which is not as high-level/FRPish as conal's stuff, but it works
15:49:45 * hackagebot HaVSA 0.1 - <Project description>  http://hackage.haskell.org/package/HaVSA-0.1 (RoganCreswick)
15:49:59 <lispy> ClaudiusMaximus: probably.
15:50:10 <kowey> lispy: there's also things like static web pages
15:50:15 <aristid> dncr: my "observations" about FRP are from reading what other people say about it :) and i never saw anybody talk about elerea, sorry
15:50:24 <kowey> although I did see one for homebrew, so maybe github provides that ability
15:50:38 <blackdog> kowey: github definitely provides that.
15:50:55 <dcoutts> kowey: try logging in now
15:51:15 <kowey> great! many thanks, dcoutts :-)
15:51:33 <blackdog> lispy: i agree, but every time i spruik github here people get angry at me:)
15:52:02 <dncr> Peaker: from what i've seen the only very-frp-and-works-and-ppl-do/did-cool-stuff-with-it is yampa
15:52:38 <dncr> and then elerea is simpler but seemed to be more figured out
15:54:03 <dncr> and everything else is poison if you actually want to get anything done
15:54:46 * hackagebot HaVSA 0.1.0.1 - <Project description>  http://hackage.haskell.org/package/HaVSA-0.1.0.1 (RoganCreswick)
15:54:52 <Peaker> dncr, check defendtheking out
15:56:14 <dncr> Peaker: ok
15:57:19 <nazgjunk> .. huh.  Reading Learn You A Haskell I come across the line "One big difference between the two types of folds is that right folds work on infinite lists, whereas left folds don't!"
15:57:44 <aristid> nazgjunk: which is true... in a way
15:57:46 <nazgjunk> As this is the print version I'll assume that I'm the one who's wrong here - I don't get this.  I'd expect it to be the other way around
15:58:14 <nazgjunk> Approaching [1,2..] from the right doesn't work, or am I horribly misreading something?
15:58:32 <aristid> nazgjunk: "right fold" does NOT mean that you approach it from the right
15:58:35 <Peaker> nazgjunk, left fold returns ((((.... fold of entire list except last element here ....) `op` last element)
15:58:38 <ClaudiusMaximus> > (foldl f e [1..4], foldr f e [1..4]) -- foldl has too many nested brackets
15:58:39 <lambdabot>   (f (f (f (f e 1) 2) 3) 4,f 1 (f 2 (f 3 (f 4 e))))
15:58:40 <nazgjunk> so I did misread something
15:58:48 <hpc> > foldr f z [1..]
15:58:49 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
15:58:55 <Peaker> nazgjunk, it's left-associative vs. right-associative fold, where the () go
15:58:58 <hpc> > foldl f z [1..]
15:59:03 <lambdabot>   mueval-core: Time limit exceeded
15:59:14 <parcs> > foldl' f z [1..]
15:59:19 <lambdabot>   mueval-core: Time limit exceeded
15:59:55 <Peaker> nazgjunk, right fold returns  (first element `op` fold of (second element ... entire list here ))))
16:00:10 <kowey> oh, still darcs 2.0.2 on cho
16:00:36 <nazgjunk> I think my misunderstanding stems from the line "Lists can be folded up from the left or from the right"
16:00:47 * hackagebot HaVSA 0.1.0.2 - An implementation of the Version Space Algebra learning framework.  http://hackage.haskell.org/package/HaVSA-0.1.0.2 (RoganCreswick)
16:00:53 <aristid> Peaker: using Expr to demonstrate this (as hpc did) is probably best :)
16:01:14 <aristid> nazgjunk: that's some poor phrasing :)
16:01:31 * nazgjunk makes a note to look this up in other sources in the morning
16:01:50 <aristid> nazgjunk: no. play with foldr and foldl in ghci instead :)
16:02:09 <Peaker> @src foldl
16:02:09 <lambdabot> foldl f z []     = z
16:02:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:02:49 <aristid> Cale's wiki is down :(
16:02:57 <aristid> i wanted to link the fold diagrams
16:03:19 <djahandarie> They are on wikipedia
16:04:38 <nazgjunk> eh, just looking at the source for both is making it a lot clearer
16:05:01 <Peaker> > foldl (const (const 0)) undefined [0..]
16:05:16 <hpc> djahandarie: also the wikibook, and probably lyah too
16:05:23 <lambdabot>   thread killed
16:05:34 <Peaker> we could make foldl slightly more lazy for certain functions
16:06:12 <Peaker> (we know the result will be an application of "f" if the list is non-empty, but we just can't figure out the arguments
16:06:26 <Peaker> for a function that ignores both args, foldl is insufficiently lazy)
16:07:03 <hpc> > foldl (const id) 5 [1..]
16:07:07 <lambdabot>   mueval-core: Time limit exceeded
16:07:14 <hpc> hmm
16:07:29 <hpc> @src foldl
16:07:29 <lambdabot> foldl f z []     = z
16:07:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:07:42 <hpc> wow, that sucks
16:07:44 <Peaker> both args of the outermost "f"  in foldl are bottom for an infinite list
16:08:38 <hpc> @src foldr
16:08:38 <lambdabot> foldr f z []     = z
16:08:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:08:42 <aristid> Peaker: for a function that ignores both arguments, you probably don't want to use foldl at all?
16:08:43 <hpc> hmm
16:09:07 <Peaker> aristid, may not be your choice..
16:09:23 <Peaker> probably foldl is OK for not being maximally lazy
16:09:33 * Peaker tries to make it lazier as an exercise
16:10:07 * aristid prepares to shout "ACHIEVEMENT UNLOCKED" when Peaker completes the exercise
16:10:19 <hpc> it's not possible unless you make f lazy in both arguments
16:10:23 <hpc> and then the fold is a no-op
16:10:38 <hpc> if you somehow simplify it
16:10:49 * geheimdienst has the badge ready for Peaker
16:11:10 <Peaker> hpc, it's not *useful* unless you make f lazy in both.. why does it matter to the possibility of foldl to be lazier?
16:11:13 <aristid> geheimdienst: that's some good teamwork
16:11:20 <geheimdienst> if it's impossible, it will be all the more of an achievement
16:11:55 <adamvh> I've got a sort of thorny problem on which I was hoping for some advice
16:12:30 <adamvh> I've got an algorithm that takes as input 2 arrays, one of length M, and one of length N
16:12:45 <adamvh> And outputs the same
16:13:25 <mm_freak> hpc: a left fold on an infinite list can never generate anything
16:13:54 <mm_freak> > foldl (\x y -> 0) 0 [1..]
16:14:09 <aristid> @src foldl
16:14:17 <lambdabot> foldl f z []     = z
16:14:17 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:14:23 <hpc> mm_freak: i know; if it's strict in the first element, it has to evaluate an infinite stack of foldl calls; strict in the second, and it has to evaluate the last element of the list
16:14:26 <adamvh> Basically, each element in the output array (N) is generated using a pair of length-M arrays derived from the first array
16:14:38 <hpc> also, nice job breaking lambdabot
16:14:44 <aristid> adamvh: maybe you want trees?
16:14:53 <Phyx-> hpc: doesn't take much :P
16:14:57 <adamvh> Well, it's a bunch of floating point math
16:14:59 <mm_freak> hpc: even a completely non-strict function can't generate anything
16:15:42 <adamvh> I could compute an M x (N + 1) array and derive the N-array from that
16:15:57 <hpc> mm_freak: with the current implementation, yes; i don't know if one could construct an implementation in which your example would equal 0
16:16:16 <adamvh> but each column in the M x (N + 1) array depends only on the column adjacent to itself
16:16:23 <mm_freak> hpc: well, that's /the/ implementation of foldl =)
16:16:32 <adamvh> so I don't want to store the whole thing
16:16:45 <mm_freak> hpc: it has precisely the semantics you would expect from a foldl
16:17:04 <adamvh> I just want to compute the columns of the array, accumulating the elements of the N element array as I go
16:17:15 <Peaker> hmm.. maybe a maximally lazy foldl is O(n^2)
16:17:53 <aristid> Peaker: does it work already, or still only in your head?
16:18:14 <adamvh> I've implemented this algorithm using lists, since it's easy to accumulate a list
16:18:28 <adamvh> However, I'm not quite sure how to do get an array out of this without resorting to mutation
16:18:49 <Peaker> aristid, trying to write the code..
16:19:41 <adamvh> I guess my problem is conceptually equivalent to the following:
16:20:04 <adamvh> "Compute the kinetic energy of an object as a function of time"
16:21:02 <adamvh> So, you need to know the object's current and previous position / velocity in order to calculate the KE, but you'd prefer not to store all of the previous positions / velocities
16:21:25 <adamvh> But you *would* like to store all of the previous KE's
16:21:41 <Peaker> aristid, naively: lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs)
16:21:46 <c_wraith> adamvh: can you just write a function to calculate KE as f(t)?
16:22:29 <adamvh> c_wraith: In general, no - Knowledge of the path implies knowledge of KE
16:22:35 <aristid> > let lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs) in lfoldl (flip (:)) [1,2,3,4]
16:22:38 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
16:22:38 <lambdabot>    arising from a use ...
16:22:45 <aristid> > let lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs) in lfoldl (flip (:)) [] [1,2,3,4]
16:22:50 <lambdabot>   mueval: ExitFailure 1
16:22:50 <lambdabot>  mueval-core: Time limit exceeded
16:22:55 <adamvh> c_wraith: in 3D, that's the only way to get it
16:23:25 <adamvh> I suppose to be more general, it you have a vector differential equation
16:23:39 <adamvh> dx/dt = f(x,t), where x is a vector
16:23:57 <aristid> Peaker: it works!
16:24:02 <aristid> Peaker: ACHIEVEMENT UNLOCKED
16:24:07 <aristid> geheimdienst: get the badge :)
16:24:12 <Peaker> but maybe there's an O(N) way?
16:24:23 <adamvh> What's the best way to express a computation where you accumulate a s(x(t))
16:24:27 <aristid> that would be the gold bage
16:24:31 <aristid> *gold badge
16:24:35 <adamvh> s a scalar function
16:24:40 <c_wraith> I'm sure there's a morphism for it.
16:24:41 * geheimdienst hands Peaker a hello kitty badge
16:24:44 <adamvh> as you compute and discard values of x
16:25:29 <ClaudiusMaximus> @quote `ap`tail
16:25:30 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:25:31 <aristid> Peaker: i think there is :)
16:26:08 <aristid> :t let lfoldl2 f z xs = foldr (flip f) z (reverse xs) in lfoldl2
16:26:10 <lambdabot> forall b a. (b -> a -> b) -> b -> [a] -> b
16:26:26 <aristid> :t foldl
16:26:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:26:35 <ClaudiusMaximus> :t unfoldr
16:26:36 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:26:50 <Peaker> aristid, nice :)
16:27:06 <Peaker> aristid, maybe that out to be the "foldl" (as "foldl'" is already the sensible foldl)
16:27:20 <aristid> hmm
16:27:21 <Peaker> if there's a foldl for some extra laziness over foldl', it ought to be maximally lazy
16:27:32 <aristid> Peaker: i need to check if my version works on infinite lists
16:27:59 <Peaker> > let lfoldl2 f z xs = foldr (flip f) z (reverse xs) in lfoldl2 (const . const $ 0) undefined [0..]
16:28:02 <lambdabot>   mueval-core: Time limit exceeded
16:28:25 <aristid> no :(
16:28:47 <ClaudiusMaximus> adamvh: possibly your problem could be elegantly expressed with   (zipWith foo `ap` tail) . (unfoldr (Just . bar)) $ quux
16:29:43 <adamvh> ClaudiusMaximus: what's `ap`?
16:29:51 <ClaudiusMaximus> :t ap
16:29:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:29:56 <aristid> Peaker: so i doubt you can have a maximally lazy O(n) version
16:30:12 <aristid> @quote aztec
16:30:12 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:30:14 <ClaudiusMaximus> but i think i might not understand the problem fully..
16:30:25 <ClaudiusMaximus> and it's late, so, laters..
16:30:33 <hpc> ap = (<*>)
16:30:47 <hpc> > (+) <$> Just 4 <*> Just 3
16:30:47 <lambdabot>   Just 7
16:31:01 <hpc> > (+) `liftM` Just 4 `ap` Just 3
16:31:01 <lambdabot>   Just 7
16:31:45 <adamvh> @doc unfoldr
16:31:45 <lambdabot> unfoldr not available
16:31:50 <Peaker> @src reverse
16:31:50 <lambdabot> reverse = foldl (flip (:)) []
16:31:52 <aristid> > Just 4 + Just 3
16:31:53 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
16:31:53 <lambdabot>    arising from a use of...
16:32:03 <Peaker> aristid, it's because reverse uses foldl, so is not maximally lazy!
16:32:46 <hpc> you can't make maximally lazy a function that consumes the whole input
16:32:54 <Peaker> but it can't use the foldl we're defining because that would be an infinite loop
16:32:57 <c_wraith> Or rather, it *is* maximally
16:33:01 <hpc> or you can, but it's a very short procedure :P
16:33:04 <Peaker> hpc, it doesn't need to ...
16:33:21 <adamvh> ye gods unfoldr is exactly what I need
16:33:21 <c_wraith> Peaker: reverse *is* maximally lazy
16:33:33 <aristid> Peaker: bottom!
16:33:54 <monochrom> we are going to argue what is "maximally"
16:34:11 * monochrom is maximally smart
16:34:22 <c_wraith> > take 5 $ reverse [undefined, 1, 2, 3, 4, 5]
16:34:23 <lambdabot>   [5,4,3,2,1]
16:34:31 <Phyx-> che...
16:34:36 <Peaker> c_wraith, it doesn't allow evaluating to   (:) bottom ((:) bottom ...            when it could definitely evaluate to that as soon as the list is known to be of length 2
16:35:01 <aristid> monochrom: at least for some kind of local maximum
16:35:09 <monochrom> yeah! :)
16:35:19 <c_wraith> > length $ replicate 5 undefined
16:35:20 <lambdabot>   5
16:35:45 <c_wraith> Peaker, what would the input look like for that case?
16:35:48 <Peaker> aristid, I think looking at reverse as another interesting case - making it maximally lazy seems to require O(N^2) ...
16:36:00 <aristid> Peaker: :)
16:36:26 <Peaker> c_wraith, reverse [0..] should yield a lazy computation that eats the incoming list just as fast as the output list is eaten, only to figure out whether it should be [] or (:)
16:36:42 <hpc> Peaker: um... how?
16:36:51 <acowley> magic
16:36:54 <c_wraith> Peaker: that's still bottom.
16:37:04 <monochrom> use a theorem prover?
16:37:17 <Peaker> c_wraith, undefined : undefined : ...     is not bottom
16:37:18 <adamvh> @src unfoldr
16:37:18 <lambdabot> unfoldr f b  = case f b of
16:37:19 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
16:37:19 <lambdabot>    Nothing        -> []
16:37:43 <c_wraith> Peaker: You seem to be making an unwarranted assumption here.
16:38:01 <aristid> c_wraith: which is?
16:38:06 <c_wraith> Peaker: reverse is *only* defined when there is a *last* element.
16:38:30 <monochrom> more precisely, a last cons cell
16:38:35 <c_wraith> yes
16:38:40 <hpc> Peaker: how do you pattern match on a reversed list?
16:38:49 <Peaker> c_wraith, That's why it is not maximally lazy
16:38:51 <Peaker> c_wraith, :-)
16:38:57 <c_wraith> Otherwise, you don't know if you're looking at undefined:undefined:undefined
16:39:41 <Peaker> c_wraith, http://codepad.org/6foJr6jI
16:40:01 <Peaker> using my O(N^2) maximally lazy foldl, I can write a reverse that isn't bottom for infinite lists
16:40:14 <c_wraith> But is it correct?
16:40:22 <Peaker> I *think* the O(N^2) part is inherent, but am not sure
16:40:31 <copumpkin> Peaker: what does it return on infinite lists? :O
16:40:31 <Peaker> c_wraith, any reason to believe it isn't?
16:40:40 <Peaker> copumpkin, undefined : undefined : ...
16:40:48 <copumpkin> lol
16:41:03 <dncr> foldlol
16:41:09 <Peaker> copumpkin, if you only end up checking the length of the result list is at least N or such, it might even be useful
16:41:14 <Peaker> copumpkin, http://codepad.org/6foJr6jI
16:41:37 <copumpkin> cool :)
16:41:51 <Peaker> now I wonder if it can be made O(N)
16:42:44 <Peaker> if I wasn't maximally lazy, I'd blog about a maximally lazy foldl
16:43:13 <Peaker> monochrom, I think "maximally lazy" can have a meaningful definition ("defined for the largest part of its domain")
16:43:23 <dmwit> Peaker: Neat. =)
16:43:37 <Peaker> :-)
16:43:50 * monochrom is maximally smart, within the domain of being monochrom
16:43:56 <dmwit> Peaker: Even if you don't blog it, at least link to that codepad.org from haskit. =)
16:44:36 * Peaker looks haskit up
16:44:46 <Bynbo7> zomg, cloud haskell :O
16:44:51 * Bynbo7 gets excited
16:44:53 <dmwit> Peaker: haskell.reddit.com I mean
16:44:55 <Peaker> oh, reddit
16:45:03 <blackdog> Axman6: what now?
16:45:15 <Axman6> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/
16:45:19 <Axman6> top paper
16:45:39 <blackdog> Axman6: (i had a bit of a look into haskell on orionvm yesterday. still not really doable, afaict - amazon might be a better bet.)
16:45:46 <blackdog> ah, halvm on orionvm, i mean.
16:46:02 <Axman6> orionvm? never heard of it
16:46:03 <dncr> Peaker: can't you always keep covering more of the domain as special cases?
16:46:08 <Axman6> @google orionvm
16:46:10 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
16:46:14 <Axman6> :(
16:46:20 <blackdog> Axman6: local aussie startup
16:46:24 <Peaker> dncr, if you can, you'll probably be able to generalize that approach and make a maximally-lazy solution?
16:46:28 <blackdog> very fast cloud machines
16:46:31 <Axman6> ah nice
16:46:33 <blackdog> (low latency, anyway)
16:46:48 <blackdog> we've been using ninefold, but had some glitches.
16:47:09 <Taslem> Is there a way to make a instancefor the Show of a list of elements?
16:47:25 <Axman6> lists already have a show instance
16:47:35 <Taslem> I mean, override it.
16:47:41 <dncr> Peaker: but i mean, is your "maximally lazy" just "total"?
16:47:50 <Axman6> if you make a newtype, i think you can with an extension
16:48:04 <Peaker> dncr, reverse cannot return a total result for an infinite input
16:48:37 <dmwit> Taslem: Perhaps you would rather write a pretty-printer. Show is for outputting Read-able Haskell code.
16:48:46 <dncr> Peaker: but you are saying it can return something which is "less close _|_"?
16:48:51 <dncr> less close to _|_
16:49:04 <Taslem> What do you mean by "Pretty printer"?
16:49:04 <Peaker> dncr, yeah, or IOW "more lazy"?
16:49:21 <dmwit> Taslem: I mean "a function which is not called show". =P
16:49:24 <acowley> Taslem: a function with type Show a => [a] -> String
16:49:28 <dncr> mm
16:49:30 <Taslem> Heh.
16:49:47 <acowley> prettyness is optional
16:49:51 <Taslem> Well, I was. It just seems simpler to make it "Show," so if you print it, it's already pretty. :P
16:50:31 <Taslem> HM... That might make a nice addition to Haskell. For other reasons though.
16:51:38 <geheimdienst> how exactly do i tell ghc-pkg use ~/.ghc and not /usr/lib/ghc? i've tried "ghc-pkg --user unregister --user --force --user time --user" and it says "ghc-pkg: /usr/lib/ghc-7.0.2/package.conf.d/time-1.2.0.3...conf: removeLink: permission denied (Permission denied)"
16:52:55 <geheimdienst> ghc-pkg reports a version of 7.0.2
16:53:31 <monochrom> you sure that time-1.2.0.3 is in user?
16:53:50 <dolio> Why is it better for reverse to return an infinite list of bottoms for an infinite input?
16:54:00 <monochrom> because actually it should take extra effort to unregister something in global (if there is also one in user)
16:54:42 <monochrom> in fact what does "ghc-pkg list time" say?
16:54:58 <geheimdienst> i have time-1.2.0.3 global and time-1.2.0.4 in user (that's why i want to throw out the one in user)
16:55:18 <geheimdienst> uh wait, maybe it absolutely wants to prefer the newer one ...
16:55:41 <monochrom> which is still user, which should work, which is strange
16:56:19 <monochrom> ghc-pkg unregister --user time-1.2.0.4  shouldn't hurt
16:56:49 <geheimdienst> right ...
16:59:17 <geheimdienst> uh, now i still get the same error, but the package seems to be gone ...
16:59:32 <geheimdienst> possibly pebkac. thanks anyway, guys
16:59:36 <monochrom> ghc-pkg unregister --user time-1.2.0.4  works for me
17:00:27 <Peaker> it feels like I could build the imperative stateful machinery to do a reverse in O(N) while also being able to answer: "cons or empty?" on the finite sublists of a reverse of an infinite list.. but I can't seem to express it in pure code
17:01:38 <Mathnerd314> @src reverse
17:01:38 <lambdabot> reverse = foldl (flip (:)) []
17:01:50 <Axman6> blackdog: wow, looks like they're using QDR infiniband for the network
17:01:57 <Peaker> @type unsafeInterleaveIO
17:01:57 <lambdabot> Not in scope: `unsafeInterleaveIO'
17:02:03 <Peaker> @hoogle unsafeInterleaveIO
17:02:03 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
17:03:01 <geheimdienst> monochrom, thanks for verifying :)
17:05:53 <nyingen> @keal
17:05:54 <lambdabot> they dumbified you
17:09:41 <shapr> ddarius: Which channel?
17:09:52 <monochrom> this channel, #haskell
17:10:08 <monochrom> we want to do a 10th anniversary accurately! :)
17:10:32 <shapr> I'd say the results of /msg chanserv info #haskell is good enough.
17:10:42 * monochrom has an unparallelled context stack :)
17:10:45 <nyingen> derp...at least one of my earlier DeriveDataTypeable problems had to do with forgetting to recompile all the modules
17:10:48 <shapr> Things really got rolling about six months after creation honestly.
17:11:09 <monochrom> then it's April 30
17:12:22 <shapr> Originally there were three or so people on #haskell, then it died for six months, then I persuaded academics to show up and hang out.
17:13:21 <monochrom> so that's the cause of the average of 2 phd's per capita...
17:14:29 <shapr> pretty much, yeah... Igloo and Heffalump are two of the original crew.
17:14:29 <shapr> But they didn't have PhDs yet, iirc
17:15:39 <Igloo> I think wli and one or two others were idling in here when I first joined
17:15:48 <djahandarie> How did you persuade the academics? :p
17:16:03 <hpc> djahandarie: he bribed them with co-authorship ;)
17:16:06 <BMeph> djahandarie: By being shapr! ;)
17:16:08 <monochrom> "I'll sign your thesis if you join" :)
17:16:21 <shapr> djahandarie: I told the academics that there were academics worth chatting with on #haskell :-)
17:16:26 <shapr> once they started joining, it was true!
17:16:33 <djahandarie> Haha
17:16:39 <blackdog> shapr: it was just a pyramid scheme?
17:16:39 <monochrom> hahahaha exactly the lavalove tactice
17:16:44 <monochrom> s/tactice/tactic/
17:16:47 <shapr> blackdog: Yah, and YOU FELL FOR IT!
17:16:56 * shapr builds a pyramid of lambdas
17:17:06 <blackdog> shapr: yeah, i was never a proper academic:)
17:17:06 <BMeph> monochrom: I would have guessed more like, "I'll read your thesis while balancing on a unicycle, if you join!" ;p
17:17:07 <monochrom> "come to lavalove, where thousands of academics singles look for academics singles!"
17:17:13 <acowley> I was told there'd be sandwiches
17:17:29 <osoleve> what arguments would flip (:) take?
17:17:36 <shapr> BMeph: Actually, that was the draw for EuroHaskell, that I would be giving a tutorial on monads while riding a unicycle.
17:17:36 <djahandarie> acowley, you should have seen through that one.
17:17:36 <osoleve> i don't understand how to use it
17:17:40 <djahandarie> @type flip (:)
17:17:41 <lambdabot> forall a. [a] -> a -> [a]
17:17:54 <shapr> BMeph: and I did so.. there are still pix online somewhere
17:18:00 <osoleve> > flip (:) [1,2] 3
17:18:01 <lambdabot>   [3,1,2]
17:18:11 <osoleve> ooh
17:18:13 <osoleve> thanks
17:18:15 <monochrom> @remember shapr I persuaded academics to show up and hang out. [...] I told the academics that there were academics worth chatting with on #haskell :-)
17:18:15 <lambdabot> It is stored.
17:18:48 <hpc> > fix ("academics "++)
17:18:50 <lambdabot>   "academics academics academics academics academics academics academics acad...
17:18:54 <byorgey> shapr++
17:19:09 <shapr> Igloo: Even so, wli doesn't count as a true academic, he was working with IBM to scale the Linux kernel above 64 CPUs.
17:19:29 <Igloo> Oh, no, I was just saying the channel predates me
17:19:32 <kfish> that sounds far too practical
17:19:44 <xplat> > map (const ()) . reverse . replicate 5 $ undefined -- reverse is maximally lazy
17:19:45 <shapr> Igloo: Yah, but not by much :-)
17:19:46 <lambdabot>   [(),(),(),(),()]
17:20:55 <monochrom> err, s/lavalove/lavalife/
17:21:17 * Igloo has no idea by how much; I wasn't here  :-)
17:21:23 * monochrom still has an unparallelled context stack :)
17:21:30 <geheimdienst> come to think of it, i haven't seen wli around in a very long while
17:21:34 <geheimdienst> preflex: seen wli
17:21:34 <preflex>  wli was last seen on #haskell-blah 189 days, 6 hours, 24 minutes and 18 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
17:21:58 <shapr> I'm tempted to put together a GSoC student proposal, since I've been a mentor several times.
17:22:01 <geheimdienst> i wonder if he's well
17:22:12 <djahandarie> kfish, "Breaking the 2^6 threshold: scaling tactics for kernels"
17:22:14 <gio123> Cale: hi
17:22:50 <shapr> hi gio123
17:23:07 <gio123> shapr: Cale?
17:23:08 <gio123> :)?
17:23:29 <byorgey> gio123: shapr?
17:23:34 <copumpkin> byorgey: gio123?
17:23:37 <monochrom> monochrom: monochrom?
17:23:50 <gio123> :)
17:23:53 <gio123> i confuse now
17:24:00 <dmwit> Cale? byorgey:
17:24:03 <kfish> hi djahandarie :)
17:24:13 <geheimdienst> lambdabot: cale
17:24:27 <hpc> preflex: xplat 
17:24:30 <geheimdienst> lambdabot :: Cale
17:24:35 <djahandarie> kfish, g'day.
17:24:37 <shapr> gio123: Yes, somedays I'm Cale.
17:24:37 <copumpkin> hpc: preflex
17:24:47 <hpc> Unknown command: preflex
17:24:48 <shapr> jmcarthur: If I create a GSoC proposal, will you be my mentor?
17:25:04 <gio123> changed nick?
17:25:38 <monochrom> type Monochrom = Either Monochrom Monochrom
17:25:58 <shapr> gio123: Not today.
17:26:27 <gio123> shapr: do not undestand, who are u? are u Cale?
17:26:34 <shapr> gio123: Not today. Who are you?
17:26:37 <xplat> @tell Peaker reverse is already maximally lazy -- if you reverse a list with a beginning and no end, you get a list with an end and no beginning.  definitionally.
17:26:38 <lambdabot> Consider it noted.
17:26:38 <hpc> monochrom: type Monochrom = Stream Bool?
17:26:43 <shapr> gio123: Most days I'm confusing.
17:26:48 <monochrom> yes
17:26:53 <gio123> ah, bot
17:26:54 <gio123> ok
17:26:55 <gio123> :)
17:27:04 <geheimdienst> Monochrom™. Even when he fails, he's still a Left Monochrom.™
17:27:05 <shapr> gio123: I have often been accused of being a bot.
17:27:18 <djahandarie> @vixen Is shapr a bot?
17:27:18 <lambdabot> i can't stand bots
17:27:21 <gio123> turing test is passed
17:27:22 <gio123> :)
17:27:24 <monochrom> hahahaha
17:27:36 <hpc> occurs check: monochrom is too awesome for System F
17:29:07 <shapr> ddarius: So, what's happening for the ten year #haskell anniversary?
17:29:40 <hpc> shapr: celebratory troll flood :D
17:29:52 <monochrom> we convert IO String to IO
17:30:24 <hpc> we change lambdabot from a behaving bot to a dumb pipe to ghci?
17:30:43 <shapr> Maybe we should move all of #haskell to using xmpp?
17:30:51 <shapr> Oh wait, that should have been done on April 1st.
17:30:53 <Berengal> Is there a way to get ghc to ignore LINE pragmas?
17:31:15 <monochrom> I don't think there is a way
17:31:20 <nyingen> troll flood?
17:31:23 <nyingen> @protontorpedo
17:31:23 <lambdabot> are objects kina just subroutines
17:31:29 <hpc> haha
17:31:31 <nyingen> @protontorpedo
17:31:31 <lambdabot> so haskell is different from lisp?
17:31:33 <shapr> nyingen: Looks like you've got the idea already.
17:31:38 <nyingen> :)
17:31:44 <xplat> for the tenth anniversary, we tell some academics that there are academics worth chatting with on #haskell, and see who shows up
17:32:06 <monochrom> hehehe
17:32:11 <nyingen> who thought up @protontorpedo, btw? it's pretty funny actually
17:32:21 <shapr> nyingen: It's not fiction.
17:32:30 <hpc> nyingen: protontorpedo was too quotable for @quote to contain
17:32:34 <shapr> nyingen: Those are actual quotes from someone who hung out here for a few weeks.
17:32:36 * monochrom has a more horrible idea. tell redditors there are redditors on #haskell
17:32:38 <nyingen> that's awesome
17:32:38 <geheimdienst> i hope we'll have some anniversary lambdacats
17:32:48 <hpc> monochrom: YES
17:32:56 <shapr> nyingen: same as @keal
17:32:57 <BMeph> You guys are horrible. I was shocked - shocked! - when I went on ##C and found out that there really is a PoppaVic. I thought it was just a routine, like vixen...
17:33:01 <nyingen> here I thought @protontorpedo's output was contrived by haskellers as an ironic joke
17:33:04 <djahandarie> HEY REDDITORS, CHECKING IN FROM REDDIT HERE
17:33:10 <hpc> @poppavic
17:33:10 <lambdabot> Unknown command, try @list
17:33:13 <nyingen> yeah, I knew @keal was based on a real person
17:33:20 <nyingen> the quotes were too bizarre to make up :)
17:33:24 <hpc> @keal
17:33:24 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
17:33:26 <monochrom> what is PoppaVic?
17:33:47 <hpc> okay, @keal is possibly even funnier than @protontorpedo
17:34:29 * BMeph chortles at the "monochomedy"
17:34:48 <shapr> nyingen: There's some srsly bizarre stuff in the logs if you go back far enough.
17:35:01 <nyingen> shapr: man, i wouldn't be surprised
17:35:24 <Berengal> I'll say one thing for C++; if it's well encapsulated code and already has c-bindings, writing haskell-bindings is easy
17:35:25 <shapr> CosmicRay once trained up a Markov-chain irc bot with years of #haskell logs... It kept trying to talk to me about unicycling :-/
17:35:51 <nyingen> heh
17:35:54 <hpc> shapr: that's genius
17:36:06 <geheimdienst> we'll tell markov-chain bots that in #haskell there are some markov-chain bots worth learning from?
17:36:06 <monochrom> hahaha
17:36:12 <monochrom> hahahaha
17:36:18 <xplat> if it used a higher form of learning like PCFG it would talk to you about uniplating
17:36:46 <monochrom> geheimdienst++
17:36:51 <geheimdienst> thanks :)
17:36:56 * shapr grins
17:37:08 <nyingen> I done already uniplated today
17:37:29 <nyingen> pretty cool, though the docs are somewhat confusing
17:37:47 <nyingen> lots of "Don't use this module, use <link>this one</link> instead"
17:37:56 <nyingen> then you click on that one, and it also says "don't use this..."
17:38:03 <hpc> shapr: does this bot still exist?
17:38:08 <hpc> the one trained on #haskell
17:38:10 <xplat> API scavenger hunt
17:38:38 <nyingen> there's also an HTML-ized article that says at the end "Don't use Uniplate! Use the"
17:38:44 <nyingen> it just trails off immediately
17:38:56 <hpc> nyingen: follow that advice
17:39:00 <hpc> ;)
17:39:02 <nyingen> :(
17:39:16 <nyingen> I already spent all this time learning Uniplate...
17:39:36 <shapr> hpc: Nah, the markov bot started using more memory than CosmicRay's system contained, sadly.
17:39:39 <monochrom> are you sure you are not looking at some leftover files from April 1st?
17:40:04 <hpc> shapr: still, is it somewhere?
17:40:43 <jmcarthur> i actually did that somewhat recently by just using the logs available online
17:40:48 <jmcarthur> not a bot, just some ghci fun
17:41:02 <xplat> maybe modern computers have become powerful enough to contain its desire to chat about unicycles
17:41:08 <monochrom> ones, you're training ghci...
17:41:14 <shapr> hpc: I don't know, you'd have to ask CosmicRay.
17:41:19 <arlinius> @protontorpedo
17:41:19 <lambdabot> so haskell is free?
17:41:23 <hpc> preflex: seen CosmicRay 
17:41:23 <preflex>  CosmicRay was last seen on #haskell 35 days, 8 hours, 3 minutes and 8 seconds ago, saying: yes, MegaMonad was mine, to whoever was asking yesterday ;-)
17:41:27 <shapr> hpc: Or you could write one.. is there a markov-chain hackage?
17:41:32 <shapr> haha
17:41:37 <shapr> That was the bot! MegaMonad!
17:41:51 <hpc> YES!
17:42:05 <monochrom> terrifying
17:43:38 <xplat> so we're agreed then: for the tenth anniversary, we tell some unicycle enthusiasts that there are unicycle enthusiasts worth chatting with on #haskell
17:43:45 * shapr snickers
17:44:11 <shapr> MikeTheJuggler: AHA! You're here for the unicycles, right?
17:44:19 <nyingen> so is @protontorpedo named after the originator of the quotes, or is it a clever euphemism for @trollhaskell ?
17:44:21 <monochrom> ∀x. tell x that there are more x worth chatting with on #haskell
17:44:25 * copumpkin is amazed at how long eclipse takes to start up on a powerful machine
17:44:32 <shapr> nyingen: Nah, his actual nickname was protontorpedo, iirc
17:44:46 <nyingen> shapr: I see
17:44:59 <monochrom> yes eclipse takes a while to start. you are not supposed to quit and start so often. like visual studio.
17:45:24 <revenantphx> Only takes like, 4 or 5 seconds tops for me :\
17:45:44 <revenantphx> okay more like 7-8 >_>
17:45:45 <monochrom> "good morning folks  <start eclipse> <get coffee>" is not that bad daily
17:46:08 <monochrom> people optimize start time and boot time too much
17:46:16 <xplat> just like emacs, eclipse is more of an OS than an editor.  but emacs is a symbolics lisp OS and Eclipse is, well, windows XP
17:46:22 <revenantphx> this is true
17:46:22 <nyingen> you'll have more fun when it says "building project" for next 3 hours as it recursively copies every file in your 10-year-old project, including all CVS directories, to some temp directory
17:46:26 <hpc> monochrom: that optimization is useful on laptops
17:46:33 <revenantphx> start time isn't important unless something is crashing every 10 seconds
17:46:37 <revenantphx> i.e, my lion dev seed >_>
17:46:43 <revenantphx> (and my probably faulty graphics card)
17:46:43 <monochrom> <windows> now I boot in 4.9999999 seconds! <mac os x> already beat you there, I boot in 4.9999 seconds
17:46:45 <MikeTheJuggler> Hey all, i got this strange error while installing gtk where "setup.exe: internal error: unexpected package db stack"
17:47:05 <MikeTheJuggler> i'm using windows and have no idea how to install it
17:47:26 <xplat> people don't optimize start time and boot time enough
17:47:39 <copumpkin> oh this time it was waiting for a password from me, but hadn't shown me the password prompt
17:47:43 <copumpkin> of course!
17:47:46 <copumpkin> why didn't I think of that
17:47:48 * copumpkin fumes
17:48:01 <xplat> my C64 had an 8-bit 6510 processor, 1MHz, and it would boot up in about a second
17:48:02 * shapr lighs the fumes into FLAMES!
17:48:13 <shapr> xplat: Did it have to run eclipse?
17:48:14 <monochrom> optimizing start time is programmers optimizing for fellow programmers, not end-users.
17:48:19 <nyingen> that reminds me, emacs crashed on me earlier today when I put {-# LANGUAGE DeriveDataTypeable,CPP #-}
17:48:24 <nyingen> the other order worked fine
17:48:33 <hpc> my super nintendo went from off to start menu in a fraction of a second
17:48:36 <xplat> shapr: no, one more thing that made it great :)
17:48:43 <luite> xplat: booting GEOS desktop took quite a while though
17:48:46 <nyingen> xplat: ^5
17:48:51 <hpc> (i can't say milliseconds because the clock speed probably wasn't fast enough :P)
17:48:52 <shapr> My IBM BladeCenter E starts up in under half an hour!
17:49:07 <hpc> my supercollider only takes 6 months to warm up
17:49:15 <hpc> or cool down, depending on the experiment
17:49:45 <xplat> monochrom: users turn things off and close things a lot more often than devs do (except for the program they are developing)
17:50:13 <hpc> users also shut down computers a lot
17:50:13 <arlinius> devs aren't users?
17:50:19 <arlinius> what is a user?
17:50:26 <monochrom> I am a user
17:50:28 <hpc> either they don't know how to put a computer to sleep or don't bother
17:50:43 * hpc is currently mostly user
17:51:08 <luite> hmm, I usually just shut down my laptop, booting ubuntu only takes 10 seconds or so
17:51:16 <monochrom> Sam Flynn is also a user  <duck>
17:51:19 <nyingen> I'm a "user" in the sense that I download stuff off hackage and try to use it in "real" programs
17:51:24 <xplat> windows XP takes often like 20 minutes or more to get up to the point where it's done with its morning ablutions and ready to actually go fast, and by that time half the people have shut the computer off and gone outside
17:52:00 <nyingen> I often run into trouble due to lack of user-friendly documentation/examples/tutorials. I only have so much time, and grokking a library by reading its source code takes awhile
17:52:15 <nyingen> though at least with haskell, it's much easier to understand a library by reading the source than it is with, say, C++
17:52:21 <monochrom> yeah I disbelieve in "you can read the source" too
17:52:21 <arlinius> the usefulness of optimizing start time depends heavily on the program
17:53:17 <xplat> haskell is the only language for me where 'read the source' is often actually a valid form of documentation.  i can't stand it even in python or scala...
17:53:18 <copumpkin> read the types!
17:53:31 <copumpkin> especially if the types state all the properties a function satisfies
17:53:45 <nyingen> Uniplate has some nice examples and articles, but I had a lot of problems figuring out HaXML and graphviz. Graphviz was totally inscrutable until I noticed that its API docs kept linking to the fgl package
17:53:53 <copumpkin> all the interesting ones someone bothered proving, anyway
17:54:00 <djahandarie> f :: Int -> Int -> Int; g :: String -> String -> Int; h :: Int -> String -> Char
17:54:07 <nyingen> A note along the lines of "Hey, go read the fgl docs before attempting to use this library" would have gone a long way
17:54:38 <shapr> nyingen: submit a patch?
17:54:59 <shapr> nyingen: You are clearly qualified to do so :-)
17:55:19 <nyingen> shapr: Thinking about it, actually. The maintainer of graphviz says he keeps intending to write a user guide, but never quite gets around to it. So if I have time, maybe I'll write something and send it in
17:57:03 <nyingen> I eventually gave up on HaXML, btw. Couldn't get it to do what I wanted, and I couldn't find  any useful examples or other docs
17:57:08 <shapr> nyingen: Why not start dumping useful info on a wiki page?
17:57:22 <nyingen> shapr: ah, that's a good idea
17:57:39 <shapr> nyingen: What were you trying to do with HaXML? malcolm is a good guy :-)
17:58:13 <nyingen> shapr: I couldn't get the combinators to produce the desired output. I actually emailed haskell-cafe about it but got no responses
17:58:24 <nyingen> I guess it didn't occur to me to email the author directly :)
17:58:38 <geheimdienst> imho "useful info" first of all is those little example programs you made and ghci sessions you went through to figure out the library
17:58:50 <shapr> nyingen: Last I used HaXML, malcolm was responsive and helpful to my questions.
17:58:56 <nyingen> In the end I rewrote my program to use hexpat and hexpat-pickle (which is really nice)
17:59:00 <shapr> geheimdienst: I totally agree!
18:01:10 <shapr> Some of my best tutorials started out with me saying "Well, nobody else seems to know how to do this, so I'll just write up two or three useful examples..."
18:03:49 <nyingen> yeah, I should keep that in mind. Gotta start somewhere. Even if my code is messy and not always very haskelly, it could still give some indication of how to pull things together
18:06:19 * BMeph makes a note to have some examples of Io code in his package...
18:06:41 <shapr> Are there any http client libs in Haskell that handle https?
18:06:55 <hpc> curl
18:07:16 <geheimdienst> rawSystem "wget"?
18:08:14 <monochrom> http-enumerators can do https, I just heard
18:08:43 <monochrom> err, http-enumerator
18:27:07 <copumpkin> djahandarie: dude I wasn't talking about you :P
18:27:16 <djahandarie> Oh. :p
18:29:53 <dmwit> djahandarie: Don't feel sad, I'll talk about you if you want.
18:30:37 <djahandarie> I'm just fairly paranoid that copumpkin is trying to recruit me for every other thing every time he mentions 'student'
18:33:27 <nyingen> @keal
18:33:27 <lambdabot> nsa prevent me from returning to math on efnet
18:35:47 <monochrom> that would make me nsa
18:35:59 <djahandarie> lol
18:39:52 <Berengal> Does GHC always call finalizers on foreign pointers before exiting?
18:54:59 <shapr> sure is quiet here
18:55:12 * hackagebot stm-chans 1.1.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.1.0 (WrenThornton)
18:56:24 <shapr> I want source code!
19:02:03 <shapr> anybody doing interesting projects?
19:02:15 <shapr> Has anybody figured out how to get QuickCheck working with IO?
19:02:33 <shapr> Are there any demonstrations of quickcheck working with IO?
19:02:48 <shapr> I've just switched jobs ... I'm doing Python webdev, but I'd like to test everything with Haskell.
19:02:55 <shapr> blackdog: Have you ever tested a website with Haskell? ;-)
19:03:20 <kanak`> How do I write a function that is like filter but only removes the first occurrence using fold? I'm stumped on what the function would look like because if i find a match, i need to return the rest of the list unchanged, but i'm not sure how i can access the rest of the list.
19:03:47 <mauke> homework?
19:04:08 <kanak`> mauke: self-study. the question asked for any version. i wrote a simple recursive one, but i'm trying to do it with fold.
19:04:19 <mauke> which fold?
19:04:42 <kanak`> i'm trying foldr, but that's because i'm not at a level where I know which of the two folds to pick :(
19:05:01 <pickles> foldl'
19:05:24 <pickles> (not foldl)
19:05:37 <kanak`> pickles: foldl' is the strict version of foldl right? Is there any reason I would use foldl over foldl'?
19:06:26 <pickles> (this might not be right: )  foldl kinda builds a whole stack of recursive calls while it traverses the list
19:06:31 <pickles> whereas foldl' doesn't do that
19:06:53 <pickles> if i remembered the link where i saw that i'd paste it...
19:07:13 <kanak`> pickles: haskell is a "non-strict" rather than "lazy" language right? because it seems like there are times you can tell it to behave strictly
19:07:26 <kanak`> *non-lazily as in the foldl' case
19:08:10 <pickles> this seems to be it: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
19:08:17 <xplat> kanak'foldr is the one you want
19:09:20 <kanak`> xplat: thanks. the function that i pass into foldr can take in the current element and the accumulator for the rest. I'm confused about how I tell it to just grab the rest of the list
19:09:24 <xplat> kanak`: here's a hint: if you foldr and your accumulator is a pair of lists, it will only actually build the list you choose to travel down
19:10:04 <kanak`> xplat: thanks for the hint. 
19:10:08 <pickles> i will leave you to xplat (i'm mostly alseep atm, g'night!)
19:10:18 <kanak`> pickles: thank you for the help
19:10:31 <pickles> hope it was actual help and didn't lead you astray ;)
19:10:46 <xplat> so you can basically do two folds in tandem and switch from one to the other at any point
19:12:06 <xplat> another way that specifically works well when you need the exact tail of the list is to use tails as an auxiliary function
19:13:59 <xplat> so you do something like
19:14:20 <xplat> > foldr (\tl rs -> take 2 tl : rs) [] . tails $ [1..5]
19:14:22 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5],[]]
19:15:02 <xplat> so when you do that you have the whole tail available to your fold step at any point
19:18:14 <xplat> either using pair accumulators or . tails will work for your problem.  they are both good tools to have in your toolbox.  but i think in this case the . tails approach would maximize sharing and minimize unnecessary allocation and computation
19:18:40 <kevinburke> i have a module that just has a bunch of data structures in it
19:18:47 <kevinburke> eg Program = Program [Statement]
19:18:48 <kanak`> xplat: so i guess I could fold over the tails and check if the head matches the elt i'm looking for. If it does, I return the rest of the list otherwise, I cons this element to the result from later?
19:18:53 <kevinburke> Statement = [Expression] etc
19:19:01 <kevinburke> and a fn called checkProg
19:19:12 <xplat> kanak`: sounds like you got it
19:19:21 <kevinburke> is there a way I can use quickcheck to just generate like 3000 random data structures and test them with checkProg?
19:20:30 <kanak`> xplat: what is the pair of accumulators idea? I guess the accumulator would be ([a], [b]) where [a] is all the elements before this one, [b] is the elements in the list after this one?
19:22:02 <xplat> kanak`: [a] is the rest of the list with its first "foo" removed, [b] is just the rest of the list
19:22:37 <kanak`> xplat: Would I be appending the elt to [a] as i see it or should I cons it and reverse it at the end?
19:22:58 <mauke> neither; both are tails
19:23:50 <xplat> to b you always cons the element you see.  to a you cons the element you see unless it is "foo" -- otherwise you throw away the old [a] and replace it with the old [b]
19:24:16 <blackdog> shapr: i once wrote a load tester for a ruby queue in haskell
19:24:24 <blackdog> but not correctness testing
19:24:34 <shapr> that's interesting
19:27:06 <xplat> > foldr (\x (as, bs) -> (if (x == 3) then bs else x:as, x:bs)) ([],[]) [1..5]
19:27:07 <lambdabot>   ([1,2,4,5],[1,2,3,4,5])
19:27:29 <xplat> > foldr (\x (as, bs) -> (if (x == 3) then bs else x:as, x:bs)) ([],[]) [1,2,3,4,5,3,4,5]
19:27:29 <lambdabot>   ([1,2,4,5,3,4,5],[1,2,3,4,5,3,4,5])
19:28:01 <xplat> > fst . foldr (\x (as, bs) -> (if (x == 3) then bs else x:as, x:bs)) ([],[]) $ [1,2,3,4,5,3,4,5]
19:28:03 <lambdabot>   [1,2,4,5,3,4,5]
19:28:12 <kanak`> xplat: sorry it's taking a while for me to understand that code. 
19:28:39 <mrakan> GHC complains that it cannot deduce that two types are the same. Is there an extension that fixes this? Example code and exact error: http://pygments.org/demo/17248/
19:29:03 <xplat> kanak`: yeah, i just wanted to get those three examples on the same screen for you
19:29:45 <mauke> mrakan: does it work if you remove the type signature for goals?
19:30:06 <mrakan> mauke: Yes, but I'd like to keep it. :) Is this possible?
19:30:19 <mauke> then you probably want scoped type variables
19:30:32 <Mathnerd314> are there any GSOC projects that deal with Template Haskell?
19:31:05 <mrakan> mauke: That's what I thought too, but it still won't work, sadly.
19:31:24 <mauke> how does it fail?
19:32:06 <mrakan> mauke: The same way. Using a ScopedTypeVariables extension or not, the error is the same.
19:32:07 <shapr> I still have a few days to submit a GSoC proposal, yah?
19:32:29 <mauke> mrakan: did you change the signatures to use scoped type variables?
19:32:55 <mrakan> mauke: No, didn't change anything else. There's a special way to change them?
19:32:55 <c_wraith> mrakan: using ScopedTypeVariables requires adding explicit foralls when you want to expose a variable
19:33:09 <mrakan> Ah, I see. I'll try that.
19:33:38 <kanak`> xplat: thanks i finally get it. We add the elements we want to keep to the first list, and "everything" in the second list. This way, the moment we need to switch gears, we just use the second list. So in a sense, the second list is doing the "identity" function in the list as we see it, which is what we wanted to do once we found the element we were looking for.
19:33:57 <xplat> mrakan: specifically, when you have a variable a in an outer scope that you want to be visible in an inner scope, you put forall a. in front of the type signature on the outer scope
19:33:57 <kanak`> oh wow that was very verbose :/
19:34:16 <xplat> kanak`: you got it
19:34:26 <mrakan> Yes, using "forall a b" with the type signature of `parse` fixes this. Thanks everyone!
19:34:29 <kanak`> xplat: so of the two: the one with tails and the one with the double accumulator, which should I prefer?
19:35:28 <xplat> kanak`: the double accumulator one pulls apart the list and puts it back together, which is fine if you're doing some processing in your other 'mode' anyway, but kind of a waste with this function
19:35:46 <xplat> so i would use the tails version for this
19:35:58 <kanak`> xplat: I thought tails would be bad because it creates a list with so many lists in it?
19:36:52 <xplat> kanak`: each element of tails is just the actual tail of the list.  so only one cons cell is created for each cons in the original list, and they are created as you go
19:37:30 <kanak`> xplat: i see. thanks
19:40:19 <xplat> kanak`: make sure you test the tails version for the case where there is no "foo" in the list, there's a problem that can crop up if you always assume the list you're getting has a head ...
19:41:04 <kanak`> xplat: i wrote two cases for the "helper" empty list case and (x:xs) to deal with that
19:41:20 <xplat> ah, good, then you're on top of it
19:41:43 <kanak`> xplat: thank you so much for your help. I really appreciate it :). I should try more problems that would require double accumulators
19:42:24 <xplat> :)
19:43:20 <int80_h>  http://blog.freenode.net/2010/11/be-safe-out-there/
19:43:23 <int80_h> oopsd
19:43:34 <int80_h> http://hpaste.org/45350/lets_talk_about_typeclasses
19:43:37 <int80_h> ther
19:45:23 <int80_h> http://hpaste.org/45350/lets_talk_about_typeclasses
19:49:04 <kanak`> int80_h: is there something specific that you're confused about?
19:50:54 <BMeph> int80_h: I get the impression that you want to talk about something... ;)
19:51:46 <int80_h> BMeph: yeah I am readin "all about monads". I'm confused about the notation I found there
19:52:12 <int80_h> kanak' : I thought I was specific. I'm confused about the syntax.
19:53:24 <int80_h> BMeph: It seems to me, an understanding of the notation would mean I could look at it and say to myself "Oh it's doing this this and this.". But I get confused and draw a blank when I look at the instance I posted.
19:56:56 <kanak`> i guess i could give it a shot. The class declaration tells you that you need to supply two functions, one that puts a value inside a monad (reutrn), and another that takes a monadic value and a function and gives you a new monadic value.
19:57:14 <dmwit> int80_h: Shall we talk specifically about the Maybe monad? It would make things easier.
19:58:04 <kanak`> in the maybe monad, there are you can have Just x where x is some value or you can have Nothing. So, if i tell you that you need to put a certain value inside the Maybe monad, you can use the Just constructor. This explains the definition for return.
19:58:57 <int80_h> dmwit: sure!
19:59:19 <dmwit> int80_h: Great! Here's how I would translate that instance into English.
19:59:36 <dmwit> int80_h: First of all, (Maybe a) is a computation that produces an a -- but might fail at some point.
19:59:52 <kanak`> For bind, if your computation has failed, you don't have a value top operate on. So you return Nothing again.
19:59:56 <int80_h> what is an "a --"?
20:00:05 <dmwit> If it finally winds up being (Just a), why, then it succeeded and produced a. If at any point it failed, then Nothing comes out.
20:00:13 <dmwit> int80_h: That depends on what computation you're doing.
20:00:15 <monochrom> "--" is english dash
20:00:21 <kanak`> If you had a value inside a Just, you apply your function and wrap the new value insde a just
20:00:36 <kanak`> *which wraps instead of "and wrap"
20:00:38 <dmwit> int80_h: Oh, sorry, yes, "--" there was just a separator between two parts of my sentence.
20:01:14 <int80_h> dmwit: go on
20:01:30 <dmwit> int80_h: There's basically two interesting things we can do with any monad: do no computation, immediately returning, or combining two computations.
20:02:03 <dmwit> int80_h: There may be other operations for specific monads. The Maybe monad has a computation that does no computation and immediately fails, for example.
20:02:06 * int80_h nogs noggingly
20:02:07 <dmwit> But those aren't common to all monads.
20:02:17 <lispy> Due to conditioning, haskell programmers will only read half of this sentence -- don't you agree?
20:02:22 <dmwit> So, in that instance, we're only doing the two most basic bits.
20:02:33 * monochrom uses —
20:02:45 <dmwit> To do no computation and immediately return, we just wrap the value in Just, saying that the computation succeeded.
20:03:21 <int80_h> dmwit: and Just is a type constructor?
20:03:25 <Mathnerd314> lispy: but which half?
20:03:36 <Berengal> lispy: I never comment my code, so I haven't been conditioned
20:03:37 <dmwit> To combine two computations, we first check whether the first computation succeeded. If it did, we go on with the second computation, passing it the successful value. Otherwise, we fail immediately, without bothering to look at the second computation.
20:03:50 <dmwit> int80_h: Just is a value constructor.
20:03:58 <Zao> lispy: Took me a few reads to notice it all.
20:04:00 <lispy> Mathnerd314: the bottom half
20:04:10 <Zao> @src Maybe
20:04:10 <lambdabot> data Maybe a = Nothing | Just a
20:04:11 <dmwit> int80_h: (Just x) is a value of the (Maybe a) type whenever (x :: a).
20:04:26 <lispy> eg., haskell programmers ignore _|_ :)
20:04:32 <int80_h> dmwit: okay I'm with you so far
20:04:47 <dmwit> int80_h: Well, then you're done. That's all the code you pasted, translated into English. =)
20:05:13 <int80_h> dmwit: awesome! okay I wil lcut and paste what you just said
20:05:24 <dmwit> (>>=) is the operator for combining two possibly-failing computations; return is the operator for doing nothing and immediately succeeding.
20:06:09 <dmwit> ...and Nothing is the operator for doing nothing and immediately failing. =)
20:06:12 <int80_h> ah much better
20:06:19 <int80_h> now I can move on with the tutorial
20:06:21 <dmwit> (which is not part of the Monad interface, but is special to Maybe's.)
20:06:32 <Berengal> *coughfailcough*
20:06:34 * BMeph enjoys this "say everything without saying a word"-style... ;)
20:06:48 <dmwit> Berengal: HUSH
20:07:54 <dmwit> Okay, so Nothing is part of the Monad interface. But it's not part of the monad interface.
20:08:20 <int80_h> dmwit: do you mean it's part of the Maybe interface?
20:08:51 <Berengal> int80_h: There's a function called "fail" that's technically part of the Monad interface in Haskell, but we pretend it doesn't exist
20:08:53 <dmwit> int80_h: Haskell's Monad class has an extra method named "fail". But the theoretical definition of "monad" doesn't mention any such thing.
20:09:08 <dmwit> int80_h: So, Monad has "fail", but monads don't. =P
20:09:58 <dmwit> int80_h: (It's a bit annoying, because there's plenty of perfectly good monads that have no reasonable implementation of fail, and hence aren't really Monads.)
20:10:46 <int80_h> dmwit: thanks for your help. I thought I was ready for "All About Monads" but it looks like my understanding of notation is wanting.
20:10:55 <int80_h> but I'm going to keep going anyway
20:11:03 <dmwit> int80_h: I think you're ready for it. What's still confusing you?
20:11:04 <Berengal> dmwit: If you want to be technical about it, fail has a default implementation
20:11:25 <dmwit> int80_h: Also, you might like "You Could Have Invented Monads" by sigfpe, it was the one that really made it click for me.
20:11:37 <int80_h> dmwit: well nothing at the moment. It's just I figure I shouldn't have had that question.
20:11:47 <dmwit> Oh, bah.
20:11:51 <dmwit> Everybody has questions.
20:12:05 <Berengal> It took me at least 6 different tutorials until I got monads
20:12:11 <int80_h> true, but the kind of question you have is indicative of your level of proficiency.
20:12:23 <Berengal> And when I got it it was because I had suddenly invented one myself
20:13:15 <int80_h> well, I liked the monad definition at the begining. It's the clearest I've seen
20:13:15 <Berengal> @quote can.*use.*monads
20:13:15 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
20:14:06 <dmwit> Yes, All About Monads is very good.
20:14:12 <MaskRay> Berengal: Can you share the names of them?
20:14:23 <int80_h> and I'm all like "Monads are about computations, not burritos!"
20:14:26 <Berengal> MaskRay: The tutorials?
20:14:42 <MaskRay> Berengal: yes
20:15:05 <Berengal> MaskRay: No. This was some years ago, and I didn't remember the names even then. I just looked around on the haskell wiki
20:15:11 <dmwit> ?go io monad for people who just don't care
20:15:12 <lambdabot> Maybe you meant: google googleit do
20:15:17 <dmwit> ?google io monad for people who just don't care
20:15:18 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
20:15:18 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
20:15:48 <kanak`> int80_h: "you could have invented monads" is a great read
20:15:56 <MaskRay> Berengal: And how to find out the default implementation of a specific function in ghci
20:16:08 <enthymeme> Ooh, I forgot to link up to that blog.
20:16:09 <Berengal> MaskRay: Look at the source :P
20:16:23 <Berengal> @src fail
20:16:23 <lambdabot> fail s      = error s
20:17:04 <yr> If you don't understand monads but have already read a few tutorials/manuals, then I recommend writing about them. Best way I know to organize knowledge.
20:17:20 <dmwit> ?go good math bad math more monads stateful programming
20:17:20 <lambdabot> Maybe you meant: google googleit do
20:17:29 <dmwit> ?google good math bad math more monads stateful programming
20:17:30 <lambdabot> http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
20:17:30 <lambdabot> Title: More Monads: Stateful Programming : Good Math, Bad Math
20:17:40 <dmwit> MaskRay: There's a few that I found pretty good.
20:17:57 <JoeyA> Rank-2 polymorphism fun:
20:18:01 <JoeyA> > let f :: (forall a. a) -> (Int, Float, Char); f x = (x,x,x) in f (unsafeCoerce 5)
20:18:01 <lambdabot>   Not in scope: `unsafeCoerce'
20:18:07 <JoeyA> (5,7.0e-45,'\ENQ')
20:18:45 <MaskRay> Berengal: whats's the typical path in a linux distro?
20:18:50 <dmwit> Doesn't seem like you need rank-2 polymorphism for that kind of fun.
20:19:05 <dmwit> unsafeCoerce 5 :: Char -- would be just as fun, about
20:19:31 <dmwit> MaskRay: You don't look in ghci for that kind of information. You look in the haddocks.
20:20:02 <Berengal> MaskRay: I use the universal path: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
20:20:06 <MaskRay> dmwit: thanks 
20:21:06 <Berengal> (The "source" link haddock creates is one of my favorite pieces of functionality in any documentation tool)
20:22:07 <JoeyA> +1
20:25:31 <monochrom> the same docs are also on your hard disk if you install ghc
20:26:10 <shachaf> monochrom: But Google isn't going to link to those.
20:26:26 * shachaf has never understood tools that generate HTML documentation.
20:26:37 <shachaf> Such a hassle. Open a browser, go to a file: URL.
20:26:39 <monochrom> install some kind of google desktop if that is what you want
20:27:42 <gwern> @remember pjscott If you really want to see something ridiculous, try looking at the auto-generated library documentation for anything involving regular expressions. The type declarations in Text.Regex.TDFA are like something H. P. Lovecraft might write about.
20:27:42 <lambdabot> It is forever etched in my memory.
20:27:46 <gwern> @flush
20:29:18 <Berengal> shachaf: I have a "hackdoc" command that opens my local package doc for a given package. It's quite handy sometimes
20:32:40 <monochrom> configure your .cabal/config to have "documentation: True". for every package you "cabal install" since then, plus every package that comes with ghc, look at .cabal/share/doc/index.html for goodies
20:33:30 <monochrom> you have to do "cabal install blah" at least once after the change to have it created. but when it is created it includes ghc packages
20:33:34 <MaskRay> Berengal: Can you `wgetpaste` the `hackdoc' command?
20:33:48 <shachaf> Still, using a web browser to look at programming documentation is strange.
20:34:22 <monochrom> for a while it was not strange (javadoc)
20:34:35 <monochrom> yes I was there when java was first out but no ide
20:34:54 <Berengal> MaskRay: http://hpaste.org/45351/hackdoc
20:36:15 <int80_h> hey gang, gotta run. Thanks for the help again.
20:37:11 <MaskRay> I'm looking for the counterpart of cppman for haskell: https://github.com/Aitjcize/manpages-cpp/wiki/screenshots
20:37:14 <monochrom> web browser is one of the most ready-made hyperlinking systems. any hyperlinking system for docs is not strange.
20:37:29 <monochrom> man pages in a terminal, that is strange
20:37:47 <yr> Does anyone else on the planet use Haskell Platform on OpenSuse 11.4?
20:39:24 <applicative> yr, I take it you're confident your problem is specifically OpenSuse-y?
20:39:25 <Berengal> monochrom: At least manpages are more readable than usual html documentation in lynx
20:39:53 <yr> Can't vouch for that since I'm not using any other distro at the moment
20:41:09 <monochrom> MaskRay: w3m 'http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Prelude.html'
20:41:53 <applicative> yr, but what's the problem? someone might have an idea
20:42:06 <yr> applicative: cabal is just plain broken currently for Haskell Platform 2010.2, and platform 2011.2 is not yet available
20:42:16 <monochrom> html-ized man pages such as http://pwet.fr/man/linux/commandes/nc are the most readable
20:42:20 <MaskRay> Man and Info pages are more handy
20:43:05 <saati_> monochrom: why is this more readable than with man and your favorite pager?
20:43:13 <applicative> if Haddock used a pandoc parser, it could write man pages too
20:44:09 <applicative> yr, you mean the cabal install executable is broken?  
20:44:31 <applicative> yr, was it working before or did you just install it
20:44:34 <yr> applicative: yes, a missing shared library error. Can paste details if you like.
20:44:36 <monochrom> it is more readable. I don't know why. hire a psychologist to study me if you want to know.
20:44:48 <yr> applicative: never worked for me
20:45:14 <applicative> but ghc and ghci work?
20:45:14 <yr> applicative: usually I use haskell platform on windows
20:45:20 <monochrom> perhaps it has to do with the limitations of fixed-width fonts?
20:45:21 <yr> yes
20:45:41 <applicative> these things are taken care of on windows, mercifully
20:45:46 <yr> indeed
20:46:03 <yr> never thought I'd see the day when windows is a better platform for ease of development
20:47:21 <Mathnerd314> it is, if you can get all the tools running
20:47:55 <yr> applicative: oh, and the precompiled ghc binary from the GHC website doesn't work on OpenSuse 11.4 either
20:48:04 <Mathnerd314> but as soon as an error pops up it's easier to switch to linux than to fix it
20:48:20 <applicative> yr, there's ano OpenSuse binary?
20:48:20 <monochrom> I don't think I find anything lacking in "w3m http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Prelude.html" when compared to cppman
20:48:51 <yr> applicative: supposed to be provided by the opensuse build service, which is where I got the packages
20:49:03 <monochrom> you want 1970s terminal? check. you want to follow links? check. you want a pager? check.
20:49:14 <applicative> does "ghc-pkg list" show that the (haskell) HTTP and zlib libraries are installed?
20:49:32 <yr> Mathnerd314: I've always found developer tools much more accessible on linux
20:50:25 <yr> applicative: yes, both are there
20:50:55 <monochrom> I don't, in fact, find any point of re-inventing the hyperlinking system in the first place.
20:51:20 * shapr turns monochrom's website into info files
20:51:33 <lispy> monochrom: I asked someone recently why we as programmers like fixed width fonts but math papers/books are written in perportional fonts
20:51:40 <Berengal> unix is a C IDE...
20:51:45 * ddarius abhors info.
20:51:50 <MaskRay> w3m's rendering is slow
20:51:54 * lispy agrees with ddarius for once
20:52:00 <yr> applicative: the specific library it complains about is libHSold-locale-...
20:52:02 <shapr> lispy: I saw a recent project that used variable-width fonts and still did indentation-based layout correctly.
20:52:28 <shapr> I think it was one of the Dutch Haskellers?
20:52:48 <Berengal> I've used variable-width fonts as my coding font before
20:52:53 <lispy> shapr: Well, the person I was talking to suggested that for haskell, variable-width fonts might be okay as long as your viewer aligned certain things, such as the equal signs in the equations taht define your functions
20:52:55 * ddarius wants more than the first line to line up in many situations.
20:52:58 <applicative> yr, and old-locale is listed by ghc-pkg list?
20:53:15 <yr> yes
20:53:16 <ddarius> lispy: Just uses lhs2TeX as your viewer.
20:53:22 <ddarius> s/uses/use/
20:53:22 <monochrom> pray tell, lispy, what did that conversation lead to?
20:53:39 <yr> applicative: the install might have put the library in the wrong place
20:53:55 <lispy> monochrom: nothing tangible.  We both sort of went back to work.
20:54:00 <applicative> and you've tried installing cabal-install with the machinery in the tarball on hackage?
20:54:06 <lispy> But, I do like the observation about making things line up
20:54:34 <yr> applicative: not yet. Figured I'd rely on distribution packages
20:54:34 <applicative> does ghc-pkg show it as installed locally or globally?
20:54:51 <lispy> ddarius: or use agda-mode to write my haskell? :)
20:55:11 <ddarius> lispy: That would require using emacs.  I wouldn't suggest that.
20:55:18 <applicative> yr, by it I meant old-locale.  
20:55:35 <lispy> heh.  I've only recently started using vim in earnest.  I was an emacs user since about 1998
20:56:17 <lispy> it does make me wonder, why no vim agda-mode
20:56:27 <yr> applicative: globally
20:56:41 <lispy> I've heard vim has a terrible programming model but can it realy be worse than elisp?
20:57:11 <shachaf> lispy: Yes.
20:57:58 <shachaf> I haven't used either elisp or vimscript much. But elisp is probably better than sh, and sh is probably better than vimscript.
20:58:01 <monochrom> any programming model not invented by a genius tends to be horrible
20:58:06 <shachaf> It can *certainly* get worse than elisp.
20:59:09 <applicative> hm.  anyway, I notice that the bootstrap.sh in the tarball installs cabal-install locally by default -- I guess it generates the local HOME/.cabal/bin to put it in.
20:59:24 <c_wraith> I like that haskell is a committee language.  It's so not what one would expect.
20:59:51 <lispy> c_wraith: well, it was a committee that wanted to unify a lot of good languages
21:00:09 <applicative> thats where it goes if you do "cabal install cabal-install" typically.  I was thinking you aren't likely to endanger much by trying to install it that way.
21:00:27 <c_wraith> lispy, yeah, they had a great place to start from.  it's just that if you think "language designed from the start by a committee", you don't think of haskell
21:00:30 <shachaf> As committees go, it's certainly been good at keeping the language stable.
21:00:40 <yr> applicative: I'm thinking of compiling ghc and building the platform myself, or going back to windows for haskell work
21:01:07 <thoughtpolice> \o/ my RC4 implementation works and is proven correct by yices!
21:01:10 <c_wraith> shachaf: well, the committee was dissolved for 10 years.  that tends to keep things from changing. :)
21:01:21 <lispy> I agree, to some extent, with what monochrom said though.  When highly competent people do things, the results are often good.
21:01:30 <applicative> yr, I'm thinking you have ghc already, this would be simpler. On the other hand, compiling ghc is one of lifes great pleasures...
21:01:30 <monochrom> fixed-width font is not the only factor of unreadability. uniform-size font is a bigger one. terminal man pages use some combinations of bold, caps, bold caps for section headings. that's quaint. use different font sizes already.
21:01:42 <lispy> thoughtpolice: that's awesome.  What is RC4?  A crypto thing?
21:01:51 <yr> applicative: yeah, hence the hesitation
21:01:59 <thoughtpolice> of course, proving encryption/decryption is the identity function for a stream cipher like RC4 isn't huge (since you really want a good keystream) but i'm glad yices could handle it
21:02:08 <thoughtpolice> lispy: RC4 is a stream cipher.
21:02:09 <c_wraith> lispy: old stream cipher.  pretty well-broken by now, but it's a cool idea
21:02:46 <thoughtpolice> skype still uses RC4, albeit I belive they use a very heavily modified key scheduling algorithm from what I can tell
21:02:51 <lispy> "RC4 bovine" is somewhere in my memory but I can't place it
21:03:31 <thoughtpolice> but yeah, there are keystream/ciphertext correlations for RC4 in the beginning of the stream, it's suggested you abandon the initial part of the key stream for real data
21:03:37 <thoughtpolice> there were a few other attacks though
21:04:12 <yr> applicative: appreciate the effort on your part. I guess OpenSuse 11.4 hasn't really caught on (at least among haskell users).
21:04:33 <thoughtpolice> lispy: but I wrote an RC4 implementation using sbv, and then I let sbv hand it off to yices, to show that (decrypt . encrypt) == id, for 40bit keys and 40bit plaintext (on the initial round of the cipher)
21:05:07 <applicative> yr, anyway, cabal-install is just a haskell executable I don't see much danger.  You could also get the tarball for old-time and use 'runhaskell Setup.hs configure' etc
21:05:28 <applicative> or rather old-locale
21:05:38 <lispy> thoughtpolice: Have you blogged about it?  I dons and some others would find it interesting.
21:06:05 <thoughtpolice> lispy: i was going to
21:06:08 <lispy> thoughtpolice: even if it was a simple result, that's a nice statement.  "Hey, look, simple RC4 verification."
21:07:07 <thoughtpolice> lispy: in this case, the result isn't *too* huge, since the important part of RC4 is the keystream generation (since plaintext is xor'd with keystream data); but it's really nice yices can prove that it holds over a 40bit key/plaintext input space
21:07:35 <lispy> thoughtpolice: so you used levent's sbv binding?
21:07:46 <lispy> thoughtpolice: did you look at yice-painless?
21:08:00 <yr> applicative: I may just do that. Also kicked off the ghc compilation in a window...
21:08:08 <thoughtpolice> lispy: yeah, I used sbv. i also wrapped up the sbv code in a bytestring interface, and even gave it a crypto-api instance for StreamCipher
21:08:22 <thoughtpolice> lispy: so you can use it to encrypt real data easily. it might be good as a reference implementation
21:08:25 <thoughtpolice> lispy: https://gist.github.com/902575
21:08:34 <thoughtpolice> it also has the original RC4 implementation in C
21:08:56 <lispy> thoughtpolice: Levent would definitely find this interesting.  As I recall, he wasn't even going to put it on hackage until dons made yices-painless
21:09:07 <lispy> thoughtpolice: so seing what people do with it would tickle him
21:09:20 <thoughtpolice> lispy: oh, i've already talked to levent via email. :) he said he'd get back to me tomorrow or so, since sbv is a side project
21:09:30 * hackagebot libxml-enumerator 0.5 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.5 (JohnMillikin)
21:09:32 <lispy> right
21:09:34 <lispy> cool!
21:09:41 <monochrom> I use non-fixed-width font for irc too. I understand that this horrifies some people for no reason. http://www.vex.net/~trebla/tmp/flex-width-font.png
21:09:47 <thoughtpolice> lispy: i had some errors in my implementation, and contacted him with some questions, and i followed up with him a few minutes ago once I got my implementation correct
21:09:59 <thoughtpolice> morale: never trust proven code until you've tested it :)
21:10:15 <lispy> yeah, I keep hearing that
21:10:29 <lispy> wouter said the same thing when he extracted the monad core from coq
21:10:39 <lispy> Actually, wouter's slides are very enlightening about the state of extraction
21:10:41 <applicative> monochrom: no, it's just that we're against *that*  font.
21:10:43 <thoughtpolice> yep, i liked his talk about that
21:10:51 <thoughtpolice> and i agree, sed should not be a mandatory tool :X
21:11:04 <lispy> I'm increasingly of the mind that FM should be used to prove your tests not for extraction
21:11:25 <thoughtpolice> but like I said, this time it was slightly due to the nature of the statement I was proving; I fudged up the keystream generation, but encryption/decryption being the identity function still holds
21:11:26 <lispy> By which I mean, you develop, test, and then the properties you care about you turn into theorems.
21:11:58 <thoughtpolice> either way though, at 275 lines, it has a full implementation, bytestring & crypto api later, decent documentation, and some theorems proved and a set of quickcheck tests against cryptocipher
21:12:02 <thoughtpolice> so i'd say that's not too bad
21:12:09 <lispy> we already have good evidence that formal methods are not a replacement for writing good code
21:12:11 <thoughtpolice> s/later/layer
21:12:27 <lispy> yeah, that's really awesome
21:13:04 <monochrom> good code is easier to prove correct. formal methods drive good code.
21:13:09 <ddarius> shachaf: The Haskell committee disbanded a long, long time ago.
21:13:18 <thoughtpolice> lispy: I would like to see sbv grow more. if we could later extract code to other languages, you could have libraries of code that's checked via SMT solvers, written using sbv, and you could extract it to other languages for real use
21:13:25 <thoughtpolice> which i think would be quite nice
21:13:42 <lispy> monochrom: right.  If you write your code to be testable (and provable) you'll write better code and be able to test it :)
21:14:16 <lispy> I like to use the term "evidence based correctness"
21:14:34 <monochrom> "existential semantics"? :)
21:14:38 <applicative> what do we call the Permanent Haskell 20XX Committee?
21:15:04 <lispy> You write some code.  Maybe it's correct, maybe it's not.  What is your evidence?  And is your evidence strong enough given your requirements for trusting the code?
21:15:17 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/85386/
21:15:34 <applicative> I would trust quickcheck over Coq proofs
21:16:38 <monochrom> I like "detonational semantics" the most, but "historical semantics" is quite good too :)
21:16:40 * applicative opts for 'detonational semantics'
21:18:35 <monochrom> why do you trust QC more than Coq? Coq proves strictly more than QC does. and they receive as input the exact same kind of specifications
21:19:50 <lispy> monochrom: How well does Coq model the language you're actually using?
21:19:55 <monochrom> whereas if you compared Coq with test-driven you might have a point, i.e., perhaps the logical formula is written wrong to begin with because we suck at logic, but the concrete test cases are plain for all to see and agree to be "what we really want"
21:20:27 * applicative doesn't remember using sed with quickcheck
21:20:31 <ddarius> Just test your spec.
21:20:57 <monochrom> yeah if you use QC you have to test your specs first
21:21:18 <lispy> I would like to add, it would be possible to write a formally verified sed.  And to also verify your sed programs.  Would you then trust sed in your FM tool chain? :)
21:21:40 <ddarius> Why wouldn't you?
21:21:50 <thoughtpolice> i really like this approach I used with sbv. SMT solvers are good for certain problems. in my case, because my keystream was initially wrong, you could say i was 'proving the wrong thing'
21:21:53 <applicative> i suspect quickcheck failures are more illuminating, but needless to say I can't imagine doing what Wouter did
21:22:07 <thoughtpolice> but nonetheless, it worked really well, because I just blasted with with the solver and it gave me a result and told me if i was wrong
21:22:19 <lispy> thoughtpolice: yeah
21:22:23 <lispy> that is great
21:22:30 <monochrom> oh then it is "QC more informative than Coq" rather than trust
21:22:32 <lispy> ?quote lispy.bugs
21:22:32 <lambdabot> No quotes match. Where did you learn to type?
21:22:32 <thoughtpolice> the burden of development for coq is extremely high from what i've done. it's really hard for me to do.
21:23:02 <thoughtpolice> i trust coq, it's just feels hard to write a program in that I would trust more than a resulting haskell program.
21:23:17 <applicative> i don't like it -- it's so ugly!  but this is a frivolous complain.
21:23:20 <thoughtpolice> that has nothing to do with coq and everything to do with me being dumb probably
21:23:20 <applicative> complaint
21:23:25 <ddarius> thoughtpolice: Cost/benefit ratio is a totally different matter.
21:23:41 <lispy> ?quote lispy most
21:23:41 <lambdabot> lispy says: the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
21:23:46 <lispy> thoughtpolice: ^^
21:24:42 <ddarius> http://lambda-the-ultimate.org/node/4241
21:26:16 <lispy> byorgey: okay, time to see if I can finish off the freetype api
21:26:30 <lispy> start the timer!
21:27:18 * monochrom starts the time. experienced exam invigilator
21:27:31 <monochrom> "you have 55 minutes left!"
21:27:53 <lispy> wait, invigilator!  dons used that word in a meeting and I thought he made it up (I tried a google search)
21:28:00 <lispy> We figured out he meant proctor
21:28:04 <lispy> but, now you used it
21:28:07 <applicative> lispy, you were not disillusioned by the letter on haskell cafe.  
21:28:10 <monochrom> briticism
21:29:11 <applicative> lispy, i meant, good to hear that you weren't
21:29:14 <lispy> applicative: are you Stephen?
21:29:19 <applicative> haha, no. 
21:29:44 <monochrom> http://www.utsc.utoronto.ca/~ability/involved_invigilator.html
21:29:58 <applicative> seemed like he was being a bit of a kill-joy.
21:30:14 <lispy> I think it was good feed back
21:30:23 <lispy> But, no I wasn't about to stop
21:30:36 <lispy> If you can do it in C, you can do it in Haskell 2x better.
21:30:40 <lispy> That's my MO
21:31:40 <monochrom> (the turing tarpit says: if you can do it in a turing machine, you can do it in haskell 1000x better)
21:32:07 <monochrom> @quote monochrom tarpit
21:32:07 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
21:32:30 <monochrom> @quote armpit
21:32:30 <lambdabot> No quotes match. That's something I cannot allow to happen.
21:32:36 <monochrom> ok good :)
21:33:12 <lispy> @sudo quote armpit
21:33:12 <lambdabot> Maybe you meant: do todo undo
21:33:29 <lispy> it's probably best that lambdabot doesn't support sudo
21:33:45 <monochrom> "the C programmer's armpit" = if you can do it in C, you can do it in haskell with 1/100 as much sweat spot under armpit
21:34:59 <lispy> applicative: I was actually suprised that about 6 people downvoted the announcement on reddit out of about 30 votes, IIRC
21:35:22 <lispy> I wish they would have left comments, but they don't
21:36:39 <applicative> strange, maybe that's the rate of misvoting. 
21:36:47 <saati> not all dowvotes are real downvotes
21:36:57 <saati> reddit inserts some fake ones to confuse bots
21:37:10 <lispy> oh wow.  I didn't know that
21:37:35 <Eduard_Munteanu> Why would that confuse bots, and what kinda bots? :)
21:37:51 <Eduard_Munteanu> @vixen Are you confused?
21:37:51 <lambdabot> i live in a constant state of confusion
21:37:57 <thoughtpolice> they have all sorts of spam protection measures like that, not sure if that kicks in for non-front-page material though (or stuff that isn't controverisial/highly active)
21:38:23 <saati> Eduard_Munteanu: dowvote bots
21:38:28 <thoughtpolice> Eduard_Munteanu: bots that would look at the page, look at the # of upvotes/downvotes, and mass vote up/down things based on that
21:38:43 <lispy> people have some weird hobbies
21:38:50 <Eduard_Munteanu> Hrm.
21:40:52 <monochrom> truly weird hobby if it could be derailed by a simple mechanism of a few fake votes
21:45:00 <moozilla> scamming reddit isn't that trivial
21:45:20 <moozilla> they silently dont count your votes if you vote too fast
21:45:38 <moozilla> and brand new users votes dont count at first
21:45:43 <moozilla> among other things
21:46:44 <applicative> hm this haskell 'on the cloud' paper says " A key contribution is a method for serializing function closures for transmission across the network."
21:48:47 <ddarius> applicative: You're going to be let down.
21:51:43 <Berengal> ddarius: How?
21:56:35 * hackagebot libpq 0.4.1 - libpq binding for Haskell  http://hackage.haskell.org/package/libpq-0.4.1 (GrantMonroe)
22:13:58 <lispy> oh, hey, there is a #define in this library that must be the setting of US high schools: FT_OUTLINE_IGNORE_DROPOUTS 
22:14:30 <lispy> maybe in the next version they'll use FT_OUTLINE_SMART_DROPOUTS 
23:03:36 <Berengal> I need some help with c2hs and mapping arrays of structs into haskell
23:06:40 <bloop> ever since learning Haskell, it has become tempting to blame all my non-Haskell troubles on the existence of side-effects...
23:07:09 <shachaf> bloop: Unfortunately, the existence of side-effects is among your non-Haskell troubles.
23:07:50 <bloop> Favorite game crashes? Side effects. Girlfriend leaves me? Side effects. Step in the mud? Side Effects.
23:10:33 <bloop> but seriously though, coming from a low-level background, it's hard to reconcile functional programming with the Turing-Machine model of computation that hardware is designed with. I was always taught in school for instance never to pass structures by value.
23:11:53 <bloop> and then even Lisp has them, although at that point I was starting to better understand the way they worm their way into every surprising bug
23:12:47 <Berengal> bloop: I'm writing a c-binding and right now I'm raging at people passing structs by value
23:13:33 <Berengal> But that's because Haskell doesn't support structs or unions, and I have to write wrapper code that translates between the two. Not because of side-effects
23:13:53 <shachaf> bloop: Never pass structures by value why?
23:14:49 <bloop>  haha well obviously in C it's usually a bad idea! I don't mean to imply that it's a bad lesson, but that it hides the larger issue which is: hardware is not designed with any kind of manageability in mind
23:15:18 <roconnor> bloop: since data in haskell is all immutable, data is never passed by copy
23:15:46 <shachaf> bloop: That doesn't really have to do with side-effects, though.
23:17:47 <roconnor> bloop: and even if you were taught functional programmin in school it wouldn't help that much for Haskell because they normally teach you to make tail calls in functional programming, where as in haskell you generall perform guarded recursion.
23:19:02 <roconnor> Guarded recursion tends to be a more natural programming style anyways.
23:20:55 <bloop> obviously immutibility means the implementation can be optimized. I'm not commenting on the optimization of Haskell. What I'm saying is that the model of computation that haskell allows you to use, lambda calculus, (which is stateless traditionally) is very very different from the one that fits perhaps more naturally with the way hardware is designed,  Turing Machines, which are entirely concerned with state-management. . 
23:25:13 <roconnor> bloop: definitely
23:25:19 <ddarius> Frabulous day!
23:25:41 <ddarius> Er ist weg.
23:28:49 <lispy> hmm
23:28:52 <lispy> I have a C question
23:29:15 <lispy> if I do, typedef struct Foo* Bar;
23:29:21 <lispy> but I never define Foo, what does C do?
23:29:44 <lispy> Is it expected that the user will define Foo?
23:30:30 <freedrull> lispy: will it compile
23:31:23 <saati> lispy: it will raise an error compile time
23:31:36 <freedrull> no it compiles actually
23:31:44 <freedrull> and you can declare a Bar
23:31:48 <ddarius> That works fine.
23:32:40 <lispy> I think C's rules just mean that Foo is treated like int
23:32:43 <freedrull> i think it only works because its a pointer
23:33:00 <ddarius> lispy: No.  If that didn't work, you'd have no way to make abstract types in C.
23:33:03 <lispy> I think, it it's the same as typedef struct void* Bar
23:33:46 <lispy> I'm not sure how to model it in Haskell or if it's a useful part of the freetype api
23:33:54 <Berengal> lispy: You can do a pure "struct Foo;" if you want
23:33:56 <lispy> I need to write more example programs in their api
23:33:58 <Berengal> That's legal C
23:34:08 <Berengal> (Legal as defined by gcc)
23:34:41 <lispy> From what I can tell, they did this so that if you can provide your own arbitrary Renderer
23:34:55 <lispy> but they wanted a name for it in their code
23:35:07 <lispy> and they want you to pass it by pointer
23:35:17 <Berengal> What's the best way to handle bindings to c-code that returns a pointer to an array of structs?
23:35:53 <ddarius> Berengal: If you have a Storable instance for the structs, then you just return the pointer.
23:36:21 <ddarius> If you don't, you still just return the pointer.
23:37:58 <lispy> ?tell byorgey I think all of the API you need is now bound.  It's untested so you're likely to run into little wrinkles.  early adopter tax and all that.
23:37:59 <lambdabot> Consider it noted.
23:37:59 <Berengal> Ah, okay, that makes sense
23:38:27 <Berengal> And how do I handle c code that wants structs as values best?
23:38:41 <Berengal> Write wrapper-code in C that converts between pointers?
23:38:46 <lispy> if it wants the struct by value, you need a storable.  Otherwise you just need pointers
23:38:59 <ddarius> Berengal: Yes, or use a generator that does that, but I recommend just doing it by hand.
23:39:22 <lispy> Berengal: cabal doesn't support hsc's #def BTW
23:39:48 <lispy> Berengal: http://hackage.haskell.org/trac/hackage/ticket/245
23:39:51 <Berengal> Everything was going fine up until this point when suddenly, out of nowhere, structs as values!
23:40:11 <Berengal> lispy: I'm using c2hs
23:40:20 <lispy> Berengal: are you sure that's really the case? I thought I had that, but it turned out there was a typedef in there that was actually a pointer to a struct.
23:40:58 <lispy> But anyway, if you can write a storable instance it's no big deal
23:41:00 <Berengal> lispy: struct Foo;
23:41:00 <Berengal> void main(void){return;}
23:41:05 <Berengal> compiles with gcc
23:41:43 <lispy> Yeah.  I'm not sure what I'll do about that Raster stuff yet.  If I don't need it, I'll defer solving the problem to when someone needs it.
23:41:44 <ddarius> lispy: A Storable instance still doesn't let you pass structs as values, though maybe c2hs will generate the necessary stub given one.
23:41:56 <lispy> ddarius: really?
23:42:00 <Berengal> c2hs doesn't generate any stubs as far as I can tell
23:42:04 <lispy> Then what's the point of the storable?
23:42:21 <ddarius> For serializing through a pointer from a C representation to a Haskell representation.
23:42:24 <ddarius> And vice versa.
23:42:30 <lispy> I mean, peek/poke/malloc/etc but I figured you'd also get by-value marshalling
23:42:44 <ddarius> Why?
23:42:52 <Berengal> If I understand this correctly, and I very well might not, Storable => peek, poke and index
23:42:58 <ddarius> Storable is just a class.
23:44:48 * hackagebot json2-types 0.1 - Defined JSON data types and  function for renders JSON to string.  http://hackage.haskell.org/package/json2-types-0.1 (YuriyIskra)
23:44:50 <lispy> I realize it's just a class, but I was hoping the FFI generated code that used it
23:45:07 <lispy> But, it's not that hard to work around needing
23:45:49 * hackagebot json2 0.8 - Library provides support for JSON.  http://hackage.haskell.org/package/json2-0.8 (YuriyIskra)
23:46:22 <ddarius> lispy: The FFI only allows you to have certain types in an FFI declaration, and of course that doesn't include C structs because there is no way for the FFI to know anything about any particular struct, but does include Ptr a for any a.
23:47:49 * hackagebot json2-hdbc 0.5 - Support JSON for SQL Database.  http://hackage.haskell.org/package/json2-hdbc-0.5 (YuriyIskra)
23:58:42 <dankna> there actually is no reason the FFI couldn't include structs
23:59:01 <dankna> it's a weakness, forcing the use of libffi to use APIs that pass or return structs directly
