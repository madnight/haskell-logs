00:04:50 <omie> Hi again !
00:06:02 <omie> whats the syntax to create custom datatype with element names again ? it was something like data x = xx (name:String, result:boolean) ? couldnt find in RWH
00:06:37 <c_wraith> record syntax, is what you're looking for
00:06:45 <c_wraith> it uses {} instead of ()
00:06:56 <pacak> data X = X { foo :: Bar, baz :: Baz }
00:07:07 <c_wraith> Also, type and constructor names must start with capital letters
00:08:17 <omie> oh, got it. Record Syntax. Thanks
00:11:11 <omie> also, any better editor on Ubuntu than gedit ? I am not yet so familiar with vim/emacs.
00:20:15 <Jafet> gedit is a bit off at Haskell highlighting
00:20:35 <Jafet> Specifically, prime marks versus quotes
00:21:01 <alpounet> omie, you can try leksah
00:23:29 <juhp> I can't login to the haskellwiki??
00:24:22 <juhp> oh now I could
00:24:31 <cnonim> I can write anything should like this http://hpaste.org/45933/universal_function
00:26:36 <omie> alpounet: thanks
00:28:03 <omie> I am stuck again
00:28:06 <omie> http://hpaste.org/45934/recordsyntax
00:28:48 <omie> what I want to happen is return a new List of Tweet type
00:29:29 <omie> my last 2 lines of code are wrong
00:29:41 <omie> but should give you some idea what I am trying
00:30:53 <omie> input [String] will be multiple lines. each line having a tweet details like this >      123|omie|87654|Some Message
00:32:11 <alpounet> omie, first, why a 'do' at the beginning ?
00:32:22 <alpounet> i'm really not sure you want to use the list monad
00:34:16 <omie> I am yet to figure out many things..
00:34:51 <omie> was in Haskell 2 months back, then college stuff and now again into it since last night. putting do worked so I did not touch it
00:39:04 <alpounet> omie, what do you use to learn Haskell ?
00:39:34 <omie> alpounet: have got RWH in hands :)
00:40:14 <alpounet> ok
00:40:30 <alpounet> have you read the monad chapters yet ?
00:42:01 <omie> I had. 2 months back. now I got little more excited and just reading it again was kinda boring. so thought to code something simple first
00:42:42 <alpounet> yeah
00:42:50 <alpounet> putting a 'do' there won't help you here
00:43:45 <omie> okay
00:44:35 <alpounet> now omie you told me the 2 last lines were wrong
00:44:43 <alpounet> tell me more about that
00:45:12 <alpounet> why so ? (they are, just trying to make you figure out)
00:45:49 <omie> well [tempList]  doesnt made/ke any sense to me
00:45:59 <omie> it came all of a sudden
00:46:27 <omie> and secondly = [tempList] : temp
00:46:41 <omie> not sure if thats correct syntax for concatenating
00:46:47 <omie> on strings I used ++
00:47:21 <omie> and when I was having 'do' there, it was expecting me to have some expression
00:49:07 <Zao> @src []
00:49:07 <lambdabot> data [] a = [] | a : [a]
00:49:32 <Zao> @type (:)
00:49:33 <lambdabot> forall a. a -> [a] -> [a]
00:50:12 <omie> hmm
00:50:29 <alpounet> omie, see http://hpaste.org/paste/45934/recordsyntax_annotation#p45937
00:51:32 <alpounet> now figure out what's missing
00:51:55 <alpounet> but don't forget that what you'll write there must have the correct type, that is [TweetType]
00:53:00 <omie> okay
00:53:01 <omie> wai
00:53:03 <omie> wait
00:53:58 <omie> there are now some new errors about Record TweetType
00:54:58 <omie> brb
00:55:18 <rothwell> ugh... trying to decipher one of oleg's things
00:55:28 <rothwell> that became "try to decipher the type of one function"
00:55:47 <rothwell> and that became "try to recreate it and/or find a single non bottom that could inhabit it"
00:56:06 <rothwell> all i wanted to know was how it does what he claims it does in the comment...
00:56:10 <rothwell> http://okmij.org/ftp/continuations/ZFS/ZFS.hs
00:56:13 <rothwell> run'process :: (forall m. (Typeable1 m, Monad m) => CCM m (OSReq m))
00:56:16 <rothwell> -> CCM IO (OSReq IO)
00:56:28 <rothwell> -- Note, the function to run the process has forall m. That means, a process
00:56:28 <rothwell> -- function can't do any IO and can't have any reference cells. 
00:56:28 <rothwell> -- Processes can't mutate the global state -- and the type system checks that!
00:56:45 <rothwell> i've read lazy functional state threads... i understand the rank-2 type... just not sure what i'm missing
00:57:21 <rothwell> it's not even really clear to me why "CCM m (OSReq m)" isn't a kind error
00:58:38 <omie> back, its saying name,id etc are not Visible fields of constructor Tweet
00:59:06 <rothwell> oleg's clearly brilliant, but he has the most excruciatingly nasty coding "style" i've seen for a long time...
01:05:10 * hackagebot hmark 1.0.0 - A tool and library for Markov chains based text generation.  http://hackage.haskell.org/package/hmark-1.0.0 (JaroslavGridin)
01:25:37 <cnonim> why this is wrong? http://hpaste.org/45938/universal_function_annotation
01:27:39 <cnonim> Please somebody help me)
01:28:04 <pacak> cnonim: Try change input from hello to "hello"
01:30:44 <cnonim> this work, but this is user input... quotation it's not cool
01:30:56 <monqy> remove the read
01:31:09 <monqy> remove the foo, actually
01:31:20 <monqy> test2 = getStr >>= putStr
01:31:27 <monqy> should work
01:32:13 <pacak> cnonim: You can parse input with parsec/attoparsec.
01:32:41 <cnonim> monqy: it's not universal, and ^ it's only example
01:34:09 <jeffz> cnonim: this is how read works, there is nothing corresponding to hello that has a Read instance
01:34:56 <monqy> if you don't want users to have to put quotes around their input strings, don't put them through read
01:37:00 <cnonim> it is possible to do so would function behavior depends on how the result should be?
01:37:51 <jeffz> care to rephrase?
01:39:29 <cnonim> posible write function which put input through read if result type not IO String?
01:41:58 <jeffz> i'm not entirely sure what you mean.
01:42:00 <jeffz> > (\x y -> (read x :: Int) + (read y :: Int)) "2" "2"
01:42:01 <lambdabot>   4
01:42:33 <jeffz> @type @type (\x y -> (read x :: Int) + (read y :: Int))
01:42:33 <lambdabot> parse error on input `@'
01:42:42 <jeffz> @type (\x y -> (read x :: Int) + (read y :: Int)) "2" "2"
01:42:43 <lambdabot> Int
01:42:46 <jeffz> @type (\x y -> (read x :: Int) + (read y :: Int))
01:42:46 <lambdabot> String -> String -> Int
01:44:05 <cnonim> Is it possible to write a function that would change its behavior depending on the return type?
01:44:46 <jeffz> for example?
01:45:01 <merijn> cnonim: If you use typeclasses, then yes
01:45:14 <cnonim> example foo from http://hpaste.org/45938/universal_function_annotation )
01:45:19 <merijn> For example, the function "maxBound" returns different results based on return type
01:45:23 <merijn> > maxBound :: Int
01:45:24 <lambdabot>   9223372036854775807
01:45:27 <merijn> > maxBound :: Char
01:45:28 <lambdabot>   '\1114111'
01:45:33 <merijn> > maxBound :: Bool
01:45:34 <lambdabot>   True
01:47:17 <cnonim> merijn: Thanks, i think i got it, will try
01:47:25 <merijn> cnonim: In your example you could make a typeclass "Handleable" make the type of foo "foo :: (Read a, Handleable a) => IO a" and make Int and String instances of Handleable. Whether that's enough to do what you want, I don't know
01:48:02 <merijn> (Learn You a Haskell should have some easy examples on how to use typeclasses)
01:49:18 <merijn> Although, in the case of Read it might get confused if it can't infer which type it is trying to read...
02:12:53 <troydm> Hi everyone, I'm trying to compile Haskell Platform (latest) on Ubuntu 10.04 headless, and during configure I have configure: error: The OpenGL C library is required
02:13:09 <troydm> and in config.log -lopengl32 not found
02:13:15 <troydm> how can I resolve this?
02:13:29 <troydm> i have mesa software and all devs installed
02:17:28 <omie> I've data Tweet = Tweet {	tid :: String,name :: String,time :: String,message :: String} and a list say [Tweets]. How can I retrieve just the 'name' from each Tweet now ?
02:17:59 <shachaf> @ty map
02:18:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:19:10 <omie> alpounet: I put '[temp] ++ (getTweets xs)' there [ http://hpaste.org/paste/45934/recordsyntax_annotation#p45937 ]. is it the same you were expecting ?
02:20:50 <alpounet> getTweet ?
02:21:00 <omie> shachaf:  if that was for me then I didnt get it. I dont need to do anything like Tweet-> name or Tweet.id ?
02:21:06 <merijn> omie: With that definition of Tweet, name is "name :: Tweet -> String"
02:21:20 <alpounet> (that'd rather be :  temp : <something you'll figure out> by the way)
02:21:32 <troydm> never mind resolved it by ln -s /usr/lib/mesa/libGL.so.1 /usr/lib/libopengl32.so
02:21:37 <merijn> omie: shachaf meant that you could use map to apply the function name to every tweet in your list
02:21:50 <omie> alpounet: sorry, I changed name of printSomething to getTweets
02:22:27 <merijn> omie: If name is "Tweet -> String" then "map name" has type "[Tweet] -> [String]"
02:23:23 <merijn> (You'd use "name temp" in the something here part)
02:23:26 <omie> my current complete code that is giving me [Tweets] http://hpaste.org/45939/punetech
02:24:10 <merijn> omie: "getTid" is redundant, record syntax automatically defines tid as a function which does the same as getTid (the same goes for name, etc)
02:24:46 <omie> merijn: oh okay
02:25:44 <merijn> omie: Also, instead of the parts and temp bit in getTweets, you probably want to make Tweet and instance of the Read type class
02:25:45 <omie> see printTweets function. problem is there
02:26:23 <merijn> You want it to be "printTweets :: [Tweet] -> IO()"?
02:26:55 <merijn> and to print the name instead?
02:27:34 <omie> yeap. I want to print only names from [Tweets]
02:27:48 <merijn> That should be something like: printTweets tweets = mapM_ (putStrLn . name) tweets
02:28:08 <merijn> :t putStrLn
02:28:08 <lambdabot> String -> IO ()
02:28:14 <merijn> :t mapM_
02:28:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:28:51 <merijn> name is "Tweet -> String", so "putStrLn . name" becomes "Tweet -> IO ()".
02:29:49 <merijn> Which means "mapM_ (putStrLn . name)" becomes "(Tweet -> IO ()) -> [Tweet] -> IO ()"
02:30:01 <omie> this (putStrLn . name) is something very new
02:30:07 <merijn> :t (.)
02:30:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:30:15 <merijn> Oh, that is awful
02:30:23 <merijn> . is the function composition operator
02:30:23 <omie> if I wanted to print whole Tweet then I need to make it (putStrLn . Tweet) ?
02:30:25 <shachaf> It's composed of parts of Haskell that you're already familiar with, presumably.
02:30:34 <shachaf> @ty (Prelude..)
02:30:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
02:30:57 <shachaf> For what it's worth, I think (.)'s type is confusing either way.
02:31:49 <merijn> omie: "(f . g) x" == "f(g(x))"
02:32:09 <merijn> Does that make sense?
02:32:38 <omie> yeap
02:32:55 <shachaf> merijn: Why do you use "f x" syntax on the left and "f(x)" syntax on the right?
02:33:08 <Jafet> @src (.)
02:33:08 <lambdabot> (f . g) x = f (g x)
02:33:08 <lambdabot> NB: In lambdabot,  (.) = fmap
02:33:29 <merijn> shachaf: I guess as comfort to people who've been damaged by Algol languages? :>
02:33:44 <merijn> omie: If you want to print the whole tweet you'd have to first turn the Tweet into a String
02:33:45 <shachaf> OK, but then you might as well say (f.g)(x) == f(g(x)).
02:33:51 <Jafet> ALGOL were decent languages
02:34:01 <Jafet> Most of their imitators weren't
02:34:06 <merijn> Jafet: I meant Algol syntax, not so much the languages
02:34:15 <omie> if f-g-x is similar to (1*2)*3 == 1*(2*3) then I got it
02:34:23 <shachaf> Algol didn't invent the syntax f(x).
02:34:42 <shachaf> omie: (.) is associative, but that's not relevant there.
02:34:51 <merijn> omie: What are you reading to learn Haskell?
02:34:56 <omie> RWH
02:35:26 <merijn> Ah, I would probably suggest switching to Learn You a Haskell for now and then go back to Real World Haskell when you are up to speed
02:35:47 <omie> had read much theory some months back (~2). then got busy and now back to. so starting with code as reading again is little boring..
02:36:26 <shachaf> omie: OK, but then you have to read what the people in the channel say, so there's no gain.
02:36:33 <shachaf> And, in addition, they have to write it. :-)
02:36:56 <omie> I refer LYAH online
02:37:01 <omie> hmm
02:37:01 <Jafet> It's okay, we love writing it.
02:37:08 <merijn> Jafet: That is true :>
02:37:18 <Jafet> The multichannel channel.
02:37:33 <omie> I'll get back to formal way once I get done with this program. just wanted to do something that works and has some meaning
02:37:55 <merijn> omie: If you want to print tweets you need a way of turning them into strings (which is easiest with the Show typeclass)
02:38:27 <merijn> omie: You could also try http://tryhaskell.org/ as an interactive tutorial if you want to play with things :)
02:38:28 <omie> and deriving(Show) does that for me ?
02:38:32 <merijn> omie: Yes
02:38:44 <omie> okay then I've derived it already
02:38:49 <merijn> :t show
02:38:50 <lambdabot> forall a. (Show a) => a -> String
02:38:55 <omie> I finished tryhaskell 2 times :-D
02:39:05 <merijn> ok :)
02:39:29 <omie> now I am getting all the names, in similar way I'll get ids.. next task is to remove duplicates
02:39:39 <merijn> If Tweet derives show, you'd do "putStrLn . show" in my earlier example, instead of "putStrLn . name"
02:39:41 <omie> will try to do it and ask back if I have doubts
02:39:53 <omie> oh okay
02:40:19 <omie> brb, and Thanks everyone :-)
02:51:03 <cheater99> :t `.`
02:51:04 <lambdabot> parse error on input ``'
02:51:08 <cheater99> why is this an error?
02:51:33 <merijn> . is already infix?
02:51:42 <merijn> :t `head`
02:51:43 <lambdabot> parse error on input ``'
02:51:47 <merijn> hmm
02:51:57 <Saizan> :t (`head`)
02:51:58 <lambdabot> parse error on input `)'
02:52:01 <merijn> oh, duh
02:52:06 <merijn> Head only takes one argument
02:52:11 <merijn> Can't really do that infix...
02:52:20 <merijn> :t `map`
02:52:20 <lambdabot> parse error on input ``'
02:52:22 <Saizan> that's not a problem
02:52:40 <Saizan> > [id] `head` 1
02:52:40 <lambdabot>   1
02:52:43 <cheater99> :t .
02:52:44 <lambdabot> parse error on input `.'
02:52:52 <cheater99> ok, how do i get the type of . ?
02:52:55 <Saizan> :t (-)
02:52:55 <merijn> :t (.)
02:52:55 <lambdabot> forall a. (Num a) => a -> a -> a
02:52:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:53:06 <shachaf> @ty (`isPrefixOf`)
02:53:07 <lambdabot> parse error on input `)'
02:53:08 <cheater99> ah :t (.) just figured it out at random when you guys typed :)
02:53:09 <merijn> cheater99: Use parens around infix operators
02:53:12 <cheater99> thanks
02:53:24 <merijn> () makes infix prefix, `` makes prefix infix
02:53:30 <shachaf> Why can't you use two-sided sections with backticked operators?
02:53:39 <cheater99> :t (`(.)`)
02:53:40 <lambdabot> parse error on input `('
02:53:44 <cheater99> aw.
02:53:58 <shachaf> `` can't hold arbirary expressions, only names.
02:54:03 <cheater99> oh ok.
02:54:07 <merijn> :t 1 `const` 5
02:54:08 <lambdabot> forall t. (Num t) => t
02:54:17 <shachaf> > 1 5
02:54:18 <lambdabot>   1
02:54:36 <merijn> Yay, Caleskell >.>
02:54:59 <shachaf> > foldr f z [a,b,c,d] -- Caleskell is excellent for educational purposes.
02:55:00 <lambdabot>   f a (f b (f c (f d z)))
02:55:17 <merijn> Sometimes
02:55:28 <merijn> It is also terribly confusing at other times :p
02:57:17 <rostayob> > foldl f z [a,b,c,d]
02:57:18 <lambdabot>   f (f (f (f z a) b) c) d
02:57:36 <rostayob> i didn't know you could do this in lambabot (:
02:57:44 <shachaf> > foldl (flip f) z [a,b,c,d]
02:57:45 <lambdabot>   f d (f c (f b (f a z)))
02:58:28 <rostayob> what's Caleskell? this type of expansion?
02:58:50 <merijn> rostayob: Caleskell is the additions of Cale in lambdabot
02:58:58 <merijn> Such as numbers being an instance of Functor
02:59:03 <merijn> > 5 1
02:59:04 <lambdabot>   5
02:59:13 <merijn> Try typing that in ghc, you'll get a type error
02:59:19 <shachaf> Caleskell: The Haskell Expansion Pack.
02:59:35 <shachaf> merijn: "numbers being an instance of Functor"?
03:01:01 <merijn> > fmap 5 4
03:01:01 <lambdabot>   No instance for (GHC.Show.Show (f b))
03:01:02 <lambdabot>    arising from a use of `M8581844653...
03:01:26 <merijn> (Note, not a type error)
03:01:27 <shachaf> > fmap 5 4 3
03:01:28 <lambdabot>   5
03:01:37 <shachaf> Sure, numbers are an instance of Functor, but that's not what you were showing there.
03:01:49 <shachaf> It's that functions are an instance of numbers.
03:01:50 <rostayob> :t 5 4
03:01:51 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
03:02:01 <rostayob> mhm
03:02:21 <merijn> shachaf: Yeah, but I couldn't come up with an example of that at first :>
03:02:52 <rostayob> I'm not sure I see how this works
03:02:56 <rostayob> I mean numbers as functors
03:03:11 <merijn> rostayob: Me neither
03:03:18 <merijn> It confuses the hell out of me :p
03:03:21 <shachaf> rostayob: Functions are numbers, and functions are functors.
03:03:35 <rostayob> shachaf: you mean numbers are functions?
03:03:37 <shachaf> But saying "numbers are functors" is just misleading. fmap is just (.).
03:04:18 <shachaf> You can find the source of this somewhere.
03:04:22 <rostayob> > fmap (+ 1) 5
03:04:22 <lambdabot>   No instance for (GHC.Num.Num (f a))
03:04:22 <lambdabot>    arising from a use of `e_115' at <in...
03:04:32 <rostayob> > fmap 4 5
03:04:32 <lambdabot>   No instance for (GHC.Show.Show (f b))
03:04:33 <lambdabot>    arising from a use of `M3393374390...
03:04:33 <Saizan> no, functions are numbers, i.e. there is an instance Num b => Num (a -> b)
03:04:50 <rostayob> oh, ok
03:04:50 <Saizan> > fmap (+1) 5 ()
03:04:51 <lambdabot>   6
03:05:44 <rostayob> > fmap (+ 1) (5 ())
03:05:45 <lambdabot>   No instance for (GHC.Num.Num (f a))
03:05:45 <lambdabot>    arising from a use of `e_115' at <in...
03:05:49 <rostayob> no, wait a second
03:05:53 <ksf> what's a StateT with runStateT :: st -> m (a, st') called?
03:06:01 <rostayob> :t 5 ()
03:06:02 <lambdabot> forall t. (Num (() -> t)) => t
03:06:08 <ksf> is there such a thing, does it make sense or am I thinking out of my ass?
03:06:13 <Saizan> > fmap (+ 1) (5 ()) ()
03:06:14 <lambdabot>   6
03:06:41 <Saizan> ksf: there is
03:06:42 <rostayob> :t fmap
03:06:43 <ksf> hmmm.
03:06:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:06:44 <ksf> arrows?
03:06:50 <rostayob> what's the (a -> b) here :P?
03:07:05 <Saizan> ksf: indexed state monad
03:07:05 <rostayob> (+ 1) right?
03:07:13 <Saizan> yes
03:07:33 <rostayob> ok, then why do you need the () at the end?
03:07:34 <shachaf> Substiture "r -> a" for "f a", and you get (a -> b) -> (r -> a) -> r -> b
03:07:42 <rostayob> I mean why do I get a type error with
03:07:47 <rostayob> > fmap (+ 1) 5
03:07:48 <lambdabot>   No instance for (GHC.Num.Num (f a))
03:07:48 <lambdabot>    arising from a use of `e_115' at <in...
03:07:53 <shachaf> No you don't.
03:07:59 <Saizan> rostayob: because it doesn't know what to pick for 'f'
03:08:02 * ksf always thought of an indexed state monad as st -> m i j (a, st)
03:08:16 <Saizan> rostayob: that expression alone is too ambiguous
03:08:34 <rostayob> :t fmap (+1) 5 ()
03:08:34 <shachaf> > not . const True -- Type error? No, it's just a function.
03:08:35 <lambdabot> forall a. (Num a) => a
03:08:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> GHC.Bool.Bool)
03:08:35 <lambdabot>    arising fro...
03:09:18 <Saizan> ksf: that's a plain state monad with some indexing on top, see http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-State.html
03:09:41 <rostayob> where can I get some docs on Cale?
03:09:47 <jonkri> in http://learnyouahaskell.com/for-a-few-monads-more#state in the "instance Monad (State s) where" part, where does the s value come from in the return function?
03:10:12 <shachaf> rostayob: Let's see what we can get.
03:10:14 <shachaf> @localtime Cale
03:10:15 <lambdabot> Local time for Cale is Fri Apr 22 06:28:16
03:10:27 <shachaf> @quote Calr
03:10:27 <lambdabot> No quotes match.
03:10:28 <shachaf> @quote Cale
03:10:29 <lambdabot> Cale says: Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
03:10:45 <rostayob> no I meant Caleskell :P
03:10:57 <shachaf> It's just... What's in lambdabot.
03:11:19 <shachaf> Secrets. No one, not even Cale, quite knows.
03:11:35 <rostayob> ok.
03:12:16 <rostayob> is there a way to see how Num a => Functor a is defined?
03:12:35 <shachaf> I think it's on Hackage somewhere.
03:12:40 <shachaf> But it's a good exercise for the reader.
03:12:55 <Saizan> jonkri: return :: a -> s -> (a,s), so it's just returning the 's' that's given to it as an argument
03:13:23 <rostayob> because I still don't get how this thing works. what's the type of "fmap (+1) 5"
03:13:32 <rostayob> it should be something like
03:13:37 <shachaf> fmap is just (.)!
03:13:57 <rostayob> shachaf: fmap (+1) 5 == (+1) . 5?
03:14:02 <shachaf> Yes.
03:14:17 <shachaf> Just like any other functions.
03:14:23 <shachaf> 5, in that context, is a function.
03:14:37 <rostayob> shachaf: what's its type?
03:14:41 <shachaf> It doesn't get its own special Functor instances. Saying "numbers are functors" is just misleading.
03:14:44 <Saizan> it's "const 5" in particular :)
03:14:48 <rostayob> ok so
03:14:52 <rostayob> it's a function
03:14:56 <shachaf> @ty let x = 5 in x undefined
03:14:56 <rostayob> but ghc can't infer a type on it?
03:14:57 <lambdabot> forall a t. (Num (a -> t)) => t
03:15:07 <shachaf> GHC *can* infer a type on it.
03:15:16 <shachaf> But it's a function. You need to apply it to something.
03:15:18 <Saizan> wait
03:15:26 <rostayob> > (+1) . 5
03:15:27 <lambdabot>   No instance for (GHC.Num.Num (f a))
03:15:27 <lambdabot>    arising from a use of `e_115' at <in...
03:15:30 <Saizan> fmap (+1) 5 doesn't force 5 to be a function
03:15:48 <rostayob> I don't get this error then.
03:15:54 <Saizan> it can only infer Num (f a) for it
03:16:14 <shachaf> Oh, true.
03:16:21 <shachaf> I was referring to the earlier "1 . 5" case.
03:16:38 <Saizan> 1 . 5 with Prelude's . would
03:16:49 <rostayob> :t (+1) . 5
03:16:49 <lambdabot> forall a (f :: * -> *). (Num a, Num (f a), Functor f) => f a
03:16:53 <jonkri> Saizan, i've bever seen return take two arguments before. the only definition i've seen is return :: a -> m a
03:16:57 <Saizan> :t (.)
03:16:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:17:11 <rostayob> oh, ok...
03:17:24 <shachaf> jonkri: Saizan is simplifying it for you. m a === s -> (a,s)
03:18:16 <rostayob> I still don't get why it gives that error with '(+1) . 5'. if anything, it should complain that it can't show a function
03:18:21 <Saizan> jonkri: newtype State s a = State (s -> (a,s)), so here return :: a -> State s a becomes what i said above if you remove the newtype noise
03:18:59 <shachaf> rostayob: That's just its way of saying that it can't show a function.
03:19:15 <omie> Hi again ! how do I set what to compare when deriving Tweet from Eq ? then List.nub will work great. Right ?
03:19:19 <Saizan> it's actually its way of saying it can't resolve all the typeclass constraints.
03:19:22 <shachaf> rostayob: Except that to implement some Caleskell extensions, a Show instance was defined for functions.
03:19:43 <shachaf> omie: Use nubBy or define your own Eq instance.
03:19:45 <Saizan> > (+1) Prelude.. 5 
03:19:46 <lambdabot>   Not in scope: `Prelude..'
03:19:47 <shachaf> Probably nubBy.
03:19:56 <shachaf> > (+1) P.. 5
03:19:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a1)
03:20:00 <lambdabot>    arising from a use of ...
03:20:09 <jonkri> is runState somehow assumed when dealing with State?
03:20:16 <omie> shachaf: okay. looking at. ty
03:20:19 <rostayob> shachaf: > (+1) Prelude.(.) 5
03:20:21 <rostayob> no sorry
03:20:25 <Saizan> jonkri: no
03:20:36 <rostayob>  > Prelude.(.) (+1) 5
03:20:49 <rostayob> > Prelude.(.) (+1) 5
03:20:50 <lambdabot>   Not in scope: data constructor `Prelude'
03:21:02 <shachaf> It's spelled (Prelude..), except it's actually (P..).
03:21:14 <rostayob> oh ok, I was trying since Prelude.. didn't work
03:21:17 <shachaf> Except it still isn't going to be able to show it.
03:21:22 <merijn> omie: As long as all types in Tweet support Eq you can derive it automatically with deriving (like show)
03:21:27 <rostayob> > (+1) P.. 5
03:21:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a1)
03:21:28 <lambdabot>    arising from a use of ...
03:21:45 <rostayob> oh, ok
03:22:02 <merijn> omie: If you use a type which is not an instance of Eq in your type (such as a file handle?) you have to create your own implementation
03:24:16 <omie> merijn:  okay. but then it will match all elements of 1 tweet to another tweet to determine equality ? I want it to say Equal only if tId are equal
03:25:19 <merijn> omie: You could write your own implementation of Eq which only matches on tid (although, that could be considered evil) or use nubBy as others suggested
03:25:35 <merijn> It could be a good exercise on how to implement your own typeclass, though :)
03:27:23 <omie> it sounds much similar to implementing IEqualityComparer in .NET
03:28:24 <merijn> omie: Yeah, a little similar. Although much less verbose and you can actually have polymorphic return values (which Java/.NET interfaces typically don't support)
03:29:18 <merijn> For example, the read type class has the function "read :: (Read a) => String -> a"
03:30:01 <merijn> (LYAH chapter 8 has some nice example code on implementing a typeclass)
03:30:27 <merijn> Including an example of Eq
03:35:54 <merijn> omie: Another difference with Java (and .NET as far as I know) is that if you have a class Foo you have to make it an instance of an interface at declaration time. i.e. if I have a library which returns values of class Foo and Foo is not an instance of Eq I'd have to hack the original code to make it an instance (which you can't always do). In haskell if a library returns a data type Foo I can make Foo an instance of Eq without changing the
03:35:54 <merijn> original code.
03:36:37 <dobblego> with an orphan instance
03:38:08 <omie> hmm
03:38:22 <rostayob> dobblego: not if you define the class, which happens most of the times
03:38:37 <dobblego> rostayob: for the case given (Eq)
03:38:41 <rostayob> oh, yes
03:42:36 <jonkri> can a state monad context be used in multiple threads?
03:43:00 <shachaf> jonkri: State isn't magic. It's just passing an argument into a function.
03:43:12 <merijn> jonkri: Yes, but the info in it won't be consistent in all threads
03:43:48 <merijn> The state monads just creates new states which it passes along. Using it in multiple threads, start with common state and then diverges if you change it in the threads
03:44:06 * hackagebot combinatorial-problems 0.0.3 - A number of data structures to represent and allow the manipulation of standard combinatorial problems, used as test problems in computer science.  http://hackage.haskell.org/package/combinatorial-problems-0.0.3 (RichardSenington)
03:44:13 <merijn> Unless you have something like an MVar/Chan in the state monad which you use to communicate between the threads
03:44:22 <shachaf> merijn: ...So in other words, no.
03:44:46 <merijn> shachaf: Well, more "yes, but it won't do what you think it will" :p
03:45:41 <merijn> jonkri: Anyhoo, for communicating state between threads you probably want a Chan instead.
03:45:50 <merijn> Or something fancier from Control.Concurrent
03:45:50 <shachaf> merijn: Useless. The state won't be shared across threads, and if it was, State still wouldn't help you.
03:46:30 <norm2782> hmm.. how would I parse JSON with aeson? I would guess using the `json` function, but it doesn't accept any arguments?
03:47:50 <shachaf> If it doesn't accept any arguments, it's not a function.
03:49:15 <norm2782> everything is a function ;)
03:49:41 <shachaf> norm2782: No!
03:49:45 <shachaf> @smack norm2782
03:49:45 * lambdabot jabs norm2782 with a C pointer
03:49:51 <norm2782> hehe
03:49:54 <shachaf> @google everything is a function in haskell
03:49:56 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
03:49:56 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
03:50:29 <flamingspinach> I remember reading that
03:50:51 <flamingspinach> as someone who doesn't know any haskell and only "plans to learn it", I guess I fall squarely into the "Church's lambda calculus" camp :P
03:51:46 <shachaf> flamingspinach: The camp that thinks that everything is encoded as functions?
03:52:12 <shachaf> The statement isn't "everything is isomorphic to a function", which is trivial; it's "everything is a function".
03:52:30 <flamingspinach> the camp of people who might misunderstand, until reading that article, that in haskell everything was a function, particularly for the reason that they were thinking of the lambda calculus and supposing haskell was essentially an implementation of it
03:52:35 <flamingspinach> without actually knowing anything about the details
03:53:05 <flamingspinach> as opposed to the camp of people who just think "in OOP everything is an object, so in functional programming everything is a function!" :P
03:53:16 <flamingspinach> since all these camps are wrong, I don't suppose it really matters what camp you're in though
03:53:24 <Jafet> Java oriented programming
03:53:34 <merijn> Sure it does, lambda calculus or death! :<
03:53:35 <shachaf> norm2782: An example seems to be here: https://github.com/mailrank/aeson/blob/master/tests/Properties.hs
03:54:23 <shachaf> Data.Attoparsec.Lazy.parse json (Data.ByteString.Lazy.pack "[1,2]")
03:54:45 <merijn> flamingspinach: I like SPJ's description. In one of his talks he calls it value oriented programming, rather then functional programming. It just happens that functions are also values
03:55:06 <shachaf> Everything is a value. Except for things that aren't.
03:55:27 <norm2782> shachaf: ah right, thanks.. I was missing the attoparsec bit :x
03:56:29 <merijn> Funny people of #haskell, I need bad puns and jokes about dependent typing, help me out :>
03:56:42 <c1de0x> merijn: that was pretty funny.
03:56:46 <c1de0x> use that ;)
03:56:51 <c1de0x> ohai folks. the whimsy is in ;)
03:57:46 <shachaf> Dependent typing is no laughing matter, merijn.
03:58:44 <c1de0x> sooo much easier to idle here and make stupid comments than actually do any work.
03:58:47 <merijn> shachaf: I figure my presentation is going to be boring enough as-is. Need something to keep people semi-awake/amused :p
03:59:02 <c1de0x> merijn: may i recommend pron?
03:59:03 <c1de0x> :)
03:59:41 <merijn> Yeah, that's going to go over well in something that's crucial for me graduating >.>
03:59:47 <ormaaj> wow bash of all languages sure has a handy syntax for recursing over args. implicit numbering (like tuple unpacking). Too bad they look very limited.
03:59:59 <c1de0x> merijn: it mihgt.
04:00:04 <c1de0x> you never know till you try.
04:00:27 <geheimdienst> ormaaj: what does it look like?
04:00:28 <merijn> "Whoops, wrong Coq..."
04:01:12 <crystal-cola> "folks", let them sleep
04:02:12 <ormaaj> geheimdienst: f(){ [[ $1 ]] || return;  echo "$1"; f "${@:2}"; }; f {1..10}
04:02:24 <ormaaj> basic counter
04:03:16 <ormaaj> there's even a command to throw away the first arg and continue... equivalent func: f(){ [[ $1 ]] || return;  echo "$1"; shift; f "$@"; }; f {1..10}
04:03:38 <c1de0x> ormaaj: how is this news?
04:03:54 <shachaf> bash didn't invent shift.
04:04:01 <geheimdienst> hm yeah, i knew about shift ... the $@:2 stuff looks bizarre
04:04:39 <ClaudiusMaximus> ormaaj: i'd write that as f(){ for x do echo "$x" ; done }; f {1..10}
04:05:03 <shachaf> bash has a lot of weird variable expansion syntax and what not. It's rather ad-hoc and inconsistent.
04:05:20 <ormaaj> It's weird and hard to understand yes
04:05:25 <osfameron> @hoogle (a -> Bool) -> [a] -> Bool
04:05:26 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
04:05:26 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
04:05:26 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
04:05:31 <ClaudiusMaximus> and if you get the quotes wrong it can explode
04:06:54 <Egbert9e9> what's a rigid variable type?
04:07:21 <Twey> One that has been fixed by a type annotation
04:07:30 <Egbert9e9> ah!
04:07:57 <Egbert9e9> so inferred type is non-rigid
04:08:10 <c1de0x> merijn see. this language totally lends itself to double entendre
04:08:11 <Egbert9e9> even "a"?
04:08:22 <Egbert9e9> c1de0x: O_o
04:10:39 <cheater99> hello
04:11:29 <cheater99> i need to convince people why haskell is a better platform than anything else for monte carlo method problems of very high volume (as in, very many iterations)
04:11:43 <c1de0x> good luck.
04:11:46 <cheater99> what arguments do i have? are there any known projects that do that?
04:20:46 <ksf> what's the status on heterogenous records?
04:20:56 <ksf> still HList and grapefruit-records the only options?
04:21:16 <shachaf> There's always record syntax.
04:21:34 <ksf> that's not particularily heterogenous, though.
04:22:09 <ksf> and we really, really ought to split the data category on hackage.
04:22:30 <ClaudiusMaximus> @hoogle Data.Data.Data
04:22:31 <lambdabot> module Data.Data
04:22:31 <lambdabot> Data.Data class Typeable a => Data a
04:22:31 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
04:22:37 <ksf> split it into data, serialisation and data-structure
04:23:18 <osfameron> @pl \(a,b) (a',b') -> (a+a', b+b')
04:23:18 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
04:23:22 <osfameron> eeeek
04:23:25 <rostayob> wow
04:23:26 <FUZxxl> Are there any devs of hugs?
04:23:29 <osfameron> is there a function that does that?
04:23:36 <osfameron> something in Control.Arrow, maybe?
04:23:51 <rostayob> no but that's beautiful, just use it
04:23:58 <rostayob> i'm sure readers will appreciate
04:24:03 <osfameron> hah, yes
04:24:18 <ClaudiusMaximus> :t (^^) *** (^)
04:24:19 <lambdabot> forall b b1 b' b2. (Fractional b, Integral b1, Num b', Integral b2) => (b, b') -> (b1 -> b, b2 -> b')
04:24:44 <ClaudiusMaximus> hm, i might have got the wrong one
04:25:47 <osfameron> @hoogle (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
04:25:47 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
04:25:47 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
04:27:04 <fryguybob> > (2,5) + (2,-3)
04:27:05 <lambdabot>   (4,2)
04:27:12 <osfameron> oh
04:27:20 <osfameron> that didn't work on mine.  Where do you get the instances for that?
04:27:28 <fryguybob> @hackage vector-space
04:27:28 <lambdabot> http://hackage.haskell.org/package/vector-space
04:27:30 <shachaf> Cale.
04:28:05 <ClaudiusMaximus> > (1,1,1,1) + 5
04:28:06 <lambdabot>   (6,6,6,6)
04:28:08 <Egbert9e9> elk
04:28:29 <omie> hard luck. not getting nubBy thingi :-(
04:29:03 <aristid> > (1,1) == 1
04:29:04 <lambdabot>   True
04:29:09 <aristid> > (1,2) == 1
04:29:10 <lambdabot>   False
04:29:18 <aristid> > (1,2) < 1
04:29:19 <lambdabot>   False
04:29:23 <omie> all examples I found about defining equality test were about Color
04:30:56 <omie> tweetEq :: Tweet -> Tweet -> Bool
04:30:58 <omie> tweetEq (Tweet t1) (Tweet t2) = (getTid t1) == (getTid t2)
04:30:59 <omie> does this make sense ?
04:31:36 <ClaudiusMaximus> what's the type of getTid ?
04:31:51 <omie> getTid :: Tweet -> String
04:31:57 <shachaf> omie: No, because you're trying to pattern-match (Tweet t1).
04:32:04 <shachaf> That's not where you specify the type.
04:32:11 <shachaf> Just say tweetEq t1 t2 = ...
04:32:11 <omie> returns id from Tweet(id,name,time,msg)
04:32:19 <omie> okay
04:32:27 <shachaf> (There are clearer ways to express this, but that'll at least make it work.)
04:33:34 <omie> so this function tweetEq works as equality comparer ? but how does haskell know this function to use when comparing 2 tweets ?
04:34:06 <omie> do I need to use deriving(tweetEq) instead of deriving(Eq) ?
04:34:36 <ClaudiusMaximus> you use the ...By functions instead of the ... functions, if they exist
04:34:49 <aristid> instance Eq Tweet where t1 == t2 = getTid t1 == getTid t2
04:35:05 <shachaf> I doubt you actually want to define that instance.
04:35:13 <aristid> shachaf: why?
04:35:15 <ClaudiusMaximus> or, instance Eq Tweet where (==) = tweetEq
04:35:51 <shachaf> aristid: Because this is just for running a specific nub, and it doesn't seem like a general-case comparison function.
04:36:07 <aristid> shachaf: from what i know about tweets, it would be general
04:36:25 <omie> Sorry but I am very much confused now.
04:36:26 <aristid> AFAIK tweets are never changed, only deleted
04:36:39 <ClaudiusMaximus> @type nubBy
04:36:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
04:36:59 <shachaf> aristid: OK, but still, that could be a very misleading Eq instance.
04:37:03 <aristid> but there's always this option: nubBy ((==) `on` getTid)
04:37:15 <aristid> shachaf: because it only compares the TID?
04:37:17 <shachaf> aristid: That's clearer but I don't think you're helping. :-)
04:37:26 <shachaf> aristid: Yes. Is that just for efficiency, or what?
04:37:51 <Jafet> map head . groupBy ((==) `on` getTid) . sortBy (compare `on` getTid)
04:37:57 <aristid> shachaf: i think it's because it's supposed to suffice. if twitter guarantees that tweets are immutable, then i think using that guarantee is reasonable
04:38:12 <Jafet> There should be an alias for that function already.
04:38:17 <aristid> shachaf: now i haven't read whether they EXPLICITLY guarantee this, so i admit it's somewhat sketchy
04:38:30 <Jafet> @pl \get -> map head . groupBy ((==) `on` get) . sortBy (compare `on` get)
04:38:31 <lambdabot> (map head .) . ap ((.) . groupBy . ((==) `on`)) (sortBy . (compare `on`))
04:38:45 <shachaf> aristid: I think that as a recommendation to someone who doesn't know how Eq works, and wants to use this comparison for a specific purpose, it's probably not a good idea. :-)
04:38:58 <aristid> well maybe :D
04:39:04 <ClaudiusMaximus> omie: tweetEq :: Tweet -> Tweet -> Bool, so you can put that as first argument to nubBy, unifying 'a' with 'Tweet', which makes (nubBy tweetEq) :: [Tweet] -> [Tweet]
04:43:13 <ClaudiusMaximus> Jafet: http://hackage.haskell.org/packages/archive/data-ordlist/0.4.4/doc/html/Data-List-Ordered.html#v:nubSortOn perhaps
04:43:18 <omie> oh, great ! Thanks ClaudiusMaximus :-)
04:43:57 <ClaudiusMaximus> :)
04:44:24 <Jafet> Okay, now I'm worrying over whether they have the same semantics.
04:44:40 <Jafet> sortBy should be stable, so it should work.
04:46:48 <osfameron> working in a monad is fun!
04:47:12 * osfameron writes the next part of takeQuiz for his upcoming "haskell/real world example" talk at local geekup https://github.com/osfameron/geekup-talk-haskell/blob/master/quiz.hs
04:47:27 <osfameron> (which is a bit of a cheat, as I'm not *actually* using that Haskell code in the real world)
04:47:42 <osfameron> though it's effectively prototyping something I'm going to have to implement in Perl, so it's arguably a real-world example
04:47:54 * osfameron doesn't feel quite brave enough to port the whole codebase to Haskell just yet ;-)
04:53:29 <randomwords> would be nice if build-depends in cabal was case insensitive - or at least warned if you were making a case error
04:54:06 <dcoutts> the latter is plausible
04:54:32 <randomwords> shouldn't be too hard to add
04:54:35 <randomwords> right?
04:55:56 <pmurias> i'm using aeson and i'm writing a fromJSON to convert by JSON into a sensible data structure, how can i get a helpfull error message when thing go wrong?
04:56:26 <FrederikVds> hi, while cabal-installing happstack-server and happstack-state i get the following error message, any ideas?
04:56:27 <FrederikVds> Loading package network-2.2.1.10 ... linking ... ghc.exe: C:\...\Roaming\cabal\network-2.2.1.10\ghc-7.0.3\HSnetwork-2.2.1.10.o: unknown symbol `_getWSErrorDescr'
04:57:41 <dcoutts> randomwords: if you could file a ticket, that'd stop us forgetting about it. The main question is what is the appropriate place to put such a check.
04:58:06 <dcoutts> randomwords: http://hackage.haskell.org/trac/hackage/newticket
04:58:43 <randomwords> dcoutts: Sure thing
04:58:48 <dcoutts> ta
05:00:28 <HelloSzzzzz> so, what's Haskell?
05:00:38 <crystal-cola> it's a programming language for computing fibonacci numbers
05:01:08 <HelloSzzzzz> do you think it's easier than python?
05:01:14 <crystal-cola> for me it is easier
05:01:19 <crystal-cola> I am only one person
05:01:33 <anincog> crystal-cola: Strange, I thought it was the largest privately held construction company in Florida
05:01:52 <hpc> Haskell is also the coolest first name ever
05:02:19 <aristid> almost as cool as the last name Curry
05:02:37 <Egbert9e9> i'm not sure i've ever had curry
05:02:44 <hpc> it's delicious
05:02:55 <Yvemath> i actually like haskell, just depressed enough to learn it.
05:03:34 <anincog> HelloSzzzzz: To be serious for a bit, whether language x is easier than language y is of course very subjective. The same goes for whether language x is better than language y.
05:04:01 <anincog> HelloSzzzzz: The very vague and useless answer I'd give to your question is thus "it depends on how you prefer to think".
05:04:03 <Yvemath> language is just a language. Get addicted :-)
05:04:08 <crystal-cola> anincog: I think I got that across
05:04:14 <rtharper> better is any universal sense is impossible, imo
05:04:17 <crystal-cola> at least I tried
05:04:24 <rtharper> it's like saying a hammer is the best tool for every task
05:04:25 <HelloSzzzzz> anincog, Yes you're right
05:04:26 <anincog> crystal-cola: I agree, I guess :)
05:05:00 <HelloSzzzzz> ok guys
05:05:02 <HelloSzzzzz> time to leave
05:05:04 <HelloSzzzzz> cya
05:10:06 <omie> Hi
05:10:26 <omie> i used sortBy to sort the data depending on time field
05:10:49 <omie> works fine. was easy and similar to nubBy
05:10:56 <omie> but there is a problem :-P
05:11:04 <omie> its sorting in ascending order
05:11:10 <omie> and requirement is descending
05:11:15 <omie> I am using
05:11:28 <omie> tweetOrd :: Tweet -> Tweet -> Ordering
05:11:30 <omie> tweetOrd t1 t2 = compare (time t1) (time t2)
05:11:45 <omie> and call it like - let sDup = List.sortBy tweetOrd nDup
05:11:52 <c1de0x> switch t1 and t2 in the rhs
05:12:17 <randomwords> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/834 - I wasn't sure what to do with the severity, priority etc so I left everything as default - hope this doesn't cause too many problems for you guys
05:12:17 <c1de0x> (of tweetOrd)
05:12:36 <omie> excellent !
05:12:57 <c1de0x> omie do you understand WHY that works?
05:12:58 <omie> finally its done. as in output is fine :-)
05:12:59 <aristid> or sortBy (flip tweetOrd)
05:13:02 <omie> certainly
05:13:13 <c1de0x> aristid yeah. that's nicer ;)
05:13:47 <c1de0x> randomwords dcoutts: http://hackage.haskell.org/trac/hackage/ticket/834 - I wasn't sure what to do with the severity, priority etc so I left everything as default - hope this doesn't cause too many problems for you guys
05:13:56 <c1de0x> (noticed you missed it ;)
05:13:59 <omie> I mean I figured it must be in similar way as in .net [sorry for bringing it up again but I've a very strong .net background]
05:15:08 <randomwords> c1de0x: I'm confused
05:15:22 <Egbert9e9> i'm stuck in http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
05:15:29 <randomwords> c1de0x: Worked it out
05:15:31 <randomwords> c1de0x: Thanks!"
05:15:34 <c1de0x> good.
05:15:37 <Egbert9e9> i have no clue how to learn what's the Reader monad
05:15:49 <c1de0x> i was trying to formulate my reasoning into a sentence and failing hard ;)
05:16:24 <aristid> Egbert9e9: Reader a b is basically just a -> b.
05:16:34 <Egbert9e9> o-o
05:16:51 <Egbert9e9> okay, lets re-read that part
05:17:02 <omie> although I am almost done with my target, and output is fine, I'd like to do some modifications to program. my Tweet{} record is String,String,String,String where as it should be int,int,String,String
05:17:17 <aristid> well it is wrapped in a newtype. but the Monad instances of (->) e and Reader e are identical
05:17:48 <Egbert9e9> there are several Reader's
05:17:58 <c1de0x> i think you mean Readers
05:17:58 <Egbert9e9> ReaderM, ReaderT and... maybe more?
05:18:22 <Egbert9e9> i don't know how to pluralize something outside of haskell syntax
05:18:30 <Egbert9e9> i guess i should say "Reader"-s
05:18:35 <c1de0x> no.
05:18:36 <omie> am I allowed to do type casting ? [I guess no :-S]
05:18:37 <Egbert9e9> <_<
05:18:42 <c1de0x> it would have to be 'Reader's
05:18:44 <crystal-cola> omie: what is type casting?
05:18:48 <c1de0x> which is bad sauce
05:19:01 <omie> crystal-cola: converting String to int
05:19:05 <omie> or like that
05:19:06 <crystal-cola> omie: yes you can do that
05:19:11 <omie> how ?
05:19:20 <c1de0x> crystal-cola it's like die-casting, but wiht less metal.
05:19:21 <crystal-cola> > read "3" + 7
05:19:21 <Egbert9e9> c1de0x: please don't take it personally but i'm now even more confused o-o
05:19:22 <lambdabot>   10
05:19:32 <crystal-cola> that function read :: String -> Int
05:19:32 <c1de0x> Egbert9e9 i kno. i was messing with your.
05:19:56 <omie> give me a min, brb
05:20:04 <Egbert9e9> x_x
05:20:10 <c1de0x> Reader's is bad english, as the apostrophe should only be used to indicate possession or contractions.
05:20:22 <aristid> Egbert9e9: well, ReaderM does not exist in transformers + mtl (the "standard" transformers libraries), so i don't know what you're talking about :)
05:20:35 <c1de0x> the possessive form: Bob's Reader
05:20:56 <c1de0x> the contracted form: Reader's a type which ...
05:21:00 <Egbert9e9> c1de0x: ya, i know all that, but i was... wait, i'm being distracted with English
05:21:13 <Egbert9e9> we're trying to haskell here
05:21:27 <c1de0x> the first form says that Reader is Bobs.
05:21:44 <Egbert9e9> oh, Intro only mentions ReaderT
05:21:59 <c1de0x> the second should be read as the contraction of 'Reader is'
05:22:24 <omie> umm no. there is a [String] and I need to store ([String] !! 0) into a field that is of type Int. It gives error for direct assignment
05:22:37 <pmurias> why doesn't hoogle for for all the hackage packages?
05:22:42 <aristid> Egbert9e9: does intro mention the (->) monad?
05:22:43 <c1de0x> although the second is not commonly used outside certain expected well-known contractions
05:22:43 <c1de0x> such as "won't", "don't", "he's", "she's", "can't", etc.
05:22:51 <crystal-cola> omie: you didn't understand what I wrote?
05:23:26 <c1de0x> omie: you need to use the read function, which parses strings into other types.
05:23:34 <Egbert9e9> aristid: uhm... no
05:23:44 <Egbert9e9> it only says ReaderT
05:23:53 <aristid> Egbert9e9: that's weird. but ReaderT is indeed slightly more involved than Reader
05:23:58 <aristid> or (->) for that matter
05:24:15 <c1de0x> aristid: ReaderT is a transformation to Reader?
05:24:25 <c1de0x> @hoogle ReaderT
05:24:25 <lambdabot> Control.Monad.Reader newtype ReaderT r m a
05:24:25 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r m a
05:24:25 <lambdabot> Control.Monad.Reader mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
05:24:28 <aristid> c1de0x: no. it's a transformation, but not to Reader.
05:25:01 <dmwit> pmurias: It knows about them all, but you have to ask it to search particular packages if you want them.
05:25:04 <c1de0x> wow. i thought the convention was that StateT was a transformation into State, etc.
05:25:24 <pmurias> dmwit: how do i do it?
05:25:39 <Egbert9e9> @hoogle <3
05:25:40 <lambdabot> Parse error:
05:25:40 <lambdabot>   --count=20 <3
05:25:40 <lambdabot>              ^
05:25:53 <Egbert9e9> hoogle things my love for it is an error ;_;
05:25:55 <Egbert9e9> thinks
05:26:05 <c1de0x> Egbert9e9 forbidden love ;)
05:26:10 <Jafet> @vixen <3
05:26:11 <lambdabot> I hear ya!
05:26:17 <Egbert9e9> O_o
05:26:57 <dmwit> ummm....
05:27:10 <omie> okay. got it. but 'let line = (read(tid x)) ++ "|" ++ (read(time x)) ++ "|" ++ (name x) ++ "|" ++ (message x)' says Couldn't match String with Int. tid and time are Int, name,message are strings
05:27:35 <Egbert9e9> how do you call functions that look like (a -> m b)... or (r -> m a), for that matter?
05:28:17 <Egbert9e9> hey, what's this convention of sometimes calling type.. uh.. arguments(?) "r" and sometimes "a", "b", "c" etc
05:28:17 <dmwit> pmurias: According to the user manual, I lied to you. If you want to search particular packages other than the defaults, you have to install it locally.
05:28:26 <crystal-cola> omie: what's the problem?
05:28:42 <crystal-cola> omie: What is the type of x?
05:28:46 <aristid> omie: show (tid x), not read (tid x)
05:28:54 <dmwit> omie: If you want to convert Int to String, you want show, not read.
05:29:08 <c1de0x> omie ++ works on strings.
05:29:16 <omie> oh alright so Read for String > anything and Show for Anything to String. Correct ?
05:29:18 <c1de0x> you can't read :: Int and then ++ it
05:29:22 <dmwit> pmurias: More information here: http://www.haskell.org/haskellwiki/Hoogle
05:29:22 <aristid> omie: yes.
05:29:30 <omie> crystal-cola: x is custom type Tweet
05:29:35 <dmwit> omie: Well, not quite anything. But most things, yes.
05:29:37 <omie> okay
05:29:49 <aristid> omie: you can also drop most of the parens
05:29:56 <c1de0x> :t read
05:29:56 <lambdabot> forall a. (Read a) => String -> a
05:30:00 <aristid> omie: function application binds tighter than ALL operators.
05:30:01 <c1de0x> :t show
05:30:02 <lambdabot> forall a. (Show a) => a -> String
05:30:09 <merijn> omie: Well, show for anything (which is an instance of Show) to string, and read for String to anything (which is an instance of Read)
05:30:22 <c1de0x> merijn what i said ;)
05:30:25 <aristid>  ++ (name x) ++  could be ++ name x ++
05:31:23 <merijn> True haskellers have a parenthesis allergy :>
05:31:33 <c1de0x> makes sense.
05:31:39 <aristid> merijn: heh, yeah
05:31:51 <aristid> makes us the anti-lispers
05:32:04 <omie> merijn: hmm. I had to derive Tweet from show when it gave error :-)
05:32:07 <c1de0x> that's why all the lispers have.... lisps.
05:32:11 <c1de0x> too many paranthesis.
05:32:29 <omie> umm.. now program works fine but ends with this never-seen-before error
05:32:30 <c1de0x> omie may i recommend reading LYAH?
05:32:31 <omie> pune.hs: Prelude.read: no parse
05:32:31 <aristid> omie: http://hpaste.org
05:32:58 <hpc> merijn: parens work for resolving visually ambiguous fixity
05:33:05 <hpc> even if to GHC it is obvious
05:33:06 <aristid> omie: "no parse" means that the input was not valid for the output type. for example:
05:33:10 <aristid> > read "x" :: Int
05:33:11 <lambdabot>   *Exception: Prelude.read: no parse
05:33:12 <cheater99> bah
05:33:19 <merijn> hpc: Then you're not using enough $'s :>
05:33:25 <c1de0x> lol
05:33:31 <cheater99> i ask a question, search for two hours, and dons has already written a paper answering it in full, twenty years ago
05:33:34 <aristid> hpc: right, but "operators bind tighter than anything else" is NOT ambiguous
05:33:52 * cheater99 cÜ dons
05:33:53 <omie> http://hpaste.org/45944/pune_final
05:33:57 <aristid> i mean functions
05:33:57 <aristid> bah
05:34:07 <c1de0x> humbug
05:34:10 <hpc> aristid: right, forgot about that rule
05:34:11 <aristid> i hate it when i say the opposite of what i mean
05:34:12 <omie> c1de0x: thanks but I am referring it at times. and hae got RWH in hands too :-)
05:34:29 <hpc> i haven't touched haskell in so long
05:34:30 <c1de0x> omie i recommend reading it all the way through
05:34:59 <Jafet> The precedence of function application... it goes to eleven.
05:35:02 <c1de0x> as a lot of the questions you are answering seem to involve fairly fundemental stuff, which is explained nicely there.
05:35:03 <aristid> hpc: despite being active in #haskell :P
05:35:09 <omie> c1de0x: sure ! going through it. this is my first meaningful program. wanted to do something
05:35:33 <aristid> tweetEq t1 t2 = (tid t1) == (tid t2)
05:35:38 <aristid> again, unnecessary parens :D
05:35:40 <pmurias> how can i convert a Word8 into a Char?
05:35:50 <Jafet> pmurias: that sounds unwise
05:35:52 <c1de0x> yeah. i get the desire to dive in... but haskell is not like any other (imperative) language you've ever coded (.net particularly)
05:35:59 <c1de0x> and the differences are fundemental.
05:36:27 <Jafet> > (fromIntegral (maxBound :: Word8), fromIntegral (maxBound :: Char))
05:36:28 <aristid> c1de0x: huh? bad advice. diving in IS the right way.
05:36:29 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
05:36:29 <lambdabot>    arising from a use of...
05:36:42 <aristid> maybe not with particularly difficult programs, of course
05:36:46 <c1de0x> aristid difference of opinions?
05:36:54 <c1de0x> i think it's important to grok the basics first
05:36:57 <aristid> but omie's program seems to be pretty trivial
05:37:02 <c1de0x> like the type system
05:37:10 <aristid> c1de0x: ghci helps with that.
05:37:20 <pmurias> Jafet: i want to pass a bytestring to Data.Trace.trace
05:37:21 <Jafet> > (fromIntegral (maxBound :: Word8), fromIntegral (last ['\NUL'..])) -- snarky comment here
05:37:23 <aristid> nothing as helpful for understanding like small experiments
05:37:23 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Char)
05:37:23 <lambdabot>    arising from a use of...
05:37:25 <hpc> aristid: yeah, all my coding recently has been in java and perl
05:37:26 <c1de0x> yeah. but only if you know how to interpret what it tell syou.
05:37:29 <Jafet> Oh.
05:37:36 <hpc> too much stuff to do before i can even think of coding for fun
05:37:42 <aristid> hpc: always keep a ghci open to keep your mind fresh!
05:37:53 <c1de0x> aristid experimentation is only useful as a tool once you have the ability to reason about the results of said experiments.
05:37:57 <omie> aristid: I have so many language influences. my path is C > C++ > Java > vb.net > [fork] > c#.net and php > again so much of c++ > again java and finally haskell ..
05:38:01 <merijn> aristid: Yes, but small experiments in ghci are different from writing an actual program before you get the basics :p
05:38:02 <c1de0x> otherwise, you're just making things go bang.
05:38:07 <dmwit> omie: By bash program is a one-liner... "sort -n input | uniq > output"
05:38:12 <Jafet> pmurias: ByteStrings are exactly what it says on the tin, byte-strings. You can decode the bytes to Text using one of the Data.Text.Encoding.
05:38:56 <Jafet> pmurias: oh, trace. You can just print the bytes, however you like
05:38:59 <aristid> merijn: it also depends on the size of the program
05:39:04 <dmwit> omie: Anyway.
05:39:07 <dmwit> omie: More helpfully:
05:39:08 <omie> okay. but whats with that prelude error ? I am not able to figure out whats wrong
05:39:13 <c1de0x> omie all except haskell are imperative. and there's a big difference.
05:39:20 <c1de0x> paradigm-wise
05:39:25 <dmwit> > (read "3.0", read "3.0") :: (Double, Int)
05:39:26 <lambdabot>   (3.0,*Exception: Prelude.read: no parse
05:39:31 <dmwit> omie: Does that help?
05:39:40 <merijn> omie: It's an exception thrown by read (as someone mentioned earlier) which is caused by you giving it something it doesn't understand
05:39:42 <c1de0x> aristid, this is exactly what i mean.
05:39:47 <c1de0x> ^^
05:40:02 <omie> okay. let me see
05:40:03 <Jafet> pmurias: what do the byte-strings represent?
05:40:52 <aristid> omie: can you also add the input file to the paste?
05:41:02 <merijn> omie: Most likely whatever you're reading as tid/time is not a number
05:41:15 <merijn> :t split
05:41:16 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:41:16 <omie> its http://punetech.com/apply/input.txt
05:41:23 <pmurias> Jafet: json
05:41:29 <pmurias> in ascii i think
05:41:31 <omie> expected output > http://punetech.com/apply/output.txt
05:41:44 <c1de0x> lambdabot wait what?
05:41:46 <hpc> @src split
05:41:47 <lambdabot> Source not found. Maybe you made a typo?
05:41:49 <Jafet> pmurias: if it represents encoded text, then you should use Text.Encoding as above
05:41:56 <c1de0x> @hoogle split
05:41:56 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
05:41:56 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
05:41:56 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
05:42:04 <hpc> (i take it split /= join (,))
05:42:06 <c1de0x> :t split
05:42:07 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:42:29 <c1de0x> @undef
05:42:32 <c1de0x> :t split
05:42:33 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:42:35 <pmurias> Jafet: how do i turn a lazy one into a non-lazy one i can encode?
05:42:37 <merijn> omie: I think your split implementation might be wrong
05:42:38 <c1de0x> i'm confuzed
05:42:53 <omie> problem statement says both are Integers so I trusted data is fine
05:42:58 <Jafet> pmurias: there's a function to do that, I'm sure...
05:43:00 <hpc> c1de0x: hoogle doesn't search everything, and @hoogle doesn't show all the results
05:43:01 <merijn> :t splitAt
05:43:01 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:43:12 <aristid> omie: time should be Double, not Int :)
05:43:14 <Jafet> @hoogle Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString
05:43:14 <lambdabot> Parse error:
05:43:14 <lambdabot>   --count=20 "Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString"
05:43:14 <lambdabot>                  ^
05:43:20 <c1de0x> hpc ok.
05:43:21 <Jafet> @slap lambdabot
05:43:21 * lambdabot smacks lambdabot about with a large trout
05:43:31 <merijn> @hoogle a -> [a] -> [[a]]
05:43:32 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:43:32 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:43:32 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:43:44 <merijn> @hoogle [a] -> a -> [[a]]
05:43:44 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:43:44 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:43:44 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:43:50 <merijn> meh
05:43:57 <dmwit> omie: Trust is a bad idea.
05:44:11 <merijn> omie: Load your file into ghci and manually call split with your input
05:44:17 <c1de0x> @hoogle splitAt
05:44:17 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
05:44:17 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
05:44:17 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
05:44:19 <dmwit> omie: Especially when you have evidence in front of your eyes that contradicts something the "trusted" person is saying.
05:44:25 <omie> Trust is a weakness too :-P [Uplink ;-D]
05:44:27 <merijn> See if it works correctly (it might, but I suspect it may be wrong)
05:44:34 <omie> Double worked
05:44:35 <pmurias> why can't the bytestrings form a typeclass?
05:44:36 <omie> wait
05:44:47 <aristid> pmurias: because they're types, not classes
05:44:59 <omie> yup! Double works good
05:45:19 <omie> this is another difference
05:45:23 <merijn> omie: Oh, of course
05:45:30 <aristid> merijn: http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/Data-List-Utils.html#g:5
05:45:30 <merijn> The second column is: 850535.0
05:45:41 <merijn> That can't be an int
05:45:47 <omie> in C or vb/c#.net when I used Integer. it simply discarded trailing .0
05:45:58 <merijn> > read "850535.0" :: Int
05:45:59 <lambdabot>   *Exception: Prelude.read: no parse
05:46:04 <merijn> > read "850535.0" :: Double
05:46:04 <c1de0x> oooh aristid. why is that not in the core lib?
05:46:04 <lambdabot>   850535.0
05:46:05 <dmwit> You guys are all too slow.
05:46:07 <dmwit> 08:57 < dmwit> > (read "3.0", read "3.0") :: (Double, Int)
05:46:12 <aristid> c1de0x: no idea :)
05:46:14 <merijn> > fromIntegral $ read "850535.0" :: Double
05:46:14 <lambdabot>   *Exception: Prelude.read: no parse
05:46:15 <merijn> eh
05:46:18 <merijn> fail
05:46:19 <c1de0x> aristid it really should be.
05:46:27 <dmwit> > floor 850535.0
05:46:28 <lambdabot>   850535
05:46:29 <merijn> > floor $ read "850535.0"
05:46:30 <lambdabot>   850535
05:46:37 <aristid> c1de0x: i did not make the standard library!
05:46:45 <merijn> dmwit: Yeah, I saw that. But I didn't check his input file sooner :p
05:46:48 <c1de0x> aristid heh ;)
05:47:31 <omie> finally its working great ! feels awesome :-D
05:47:34 <merijn> omie: Anyway, you can use Int in your Tweet type, but you have to read as double then convert :)
05:47:50 <omie> got to find something else for tomorrow
05:48:21 <omie> my first #haskell adventure is ending good. now I need to Tweet that :-P
05:48:45 <merijn> omie: You can replace the getTweets part by making Tweet an instance of the Read typeclass as well, btw
05:49:13 <dmwit> omie: You should spend a bit of time cleaning up what you've got before you move on.
05:49:22 <merijn> ^^
05:49:24 <dmwit> omie: You're re-creating a *lot* of standard library functions.
05:49:40 <merijn> I agree, would be very useful and educational to clean things up a little :)
05:49:51 <omie> hmm
05:49:55 <dmwit> omie: For example, check out "readFile", "writeFile", "map", and "mapM_".
05:49:58 <omie> before going to cleanup, another doubt
05:50:12 <omie> in printTweets
05:50:13 <omie> printTweets tweets = mapM_ (putStrLn . tid) tweets
05:50:22 <omie> now shows error as tid is int
05:50:38 <dmwit> :t show
05:50:39 <lambdabot> forall a. (Show a) => a -> String
05:50:40 <merijn> (putStrLn . show . tid)
05:50:41 <omie> how to fix that ? read tid would work there too ?
05:50:47 <omie> or sorry show
05:51:12 <omie> hmm
05:51:13 <dmwit> You'll also like the "split" package on Hackage.
05:51:15 <dmwit> ?hackage split
05:51:16 <lambdabot> http://hackage.haskell.org/package/split
05:52:38 <dmwit> If you're feeling adventurous, learn a bit about pattern-matching and think about how to write the whole thing without a single (!!), head, or tail; check out Data.Function.on; and after you've tried all these suggestions, come back to #haskell and ask for more. =)
05:52:42 <dmwit> I guarantee you'll get them. =)
05:53:41 <pmurias> Jafet: unpack . decodeASCII . B.pack . BL.unpack . encode finally converted Data.Aeson.Value into a String
05:54:03 <sm> morning all
05:54:06 <merijn> And if you see a part of your code/function where you think "Well, this seems like someone should have already written this function...", try and use Hoogle to see whether someone in fact has :)
05:54:19 <brbr> which linux distro has the best support for haskell?
05:54:22 <merijn> :t Data.Function.on
05:54:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:54:33 <sm> is it reasonable that fromGregorian silently clips  invalid month and day numbers ? 
05:54:42 <merijn> dmwit: I didn't know about on, that function rocks!
05:54:45 <Jafet> pmurias: looks about right
05:54:55 <omie> hmm.. I am going out for a while. have noted down  changes. will try to clean up once I get back.
05:55:37 <ksf> I firmly believe that the records package can support looking up a statically non-existing field and getting back a value-level Nothing, but damn is that beast a type hell.
05:56:13 <sm> oh, I guess it is, since the doc says so and fromGregorianValid is also provided
05:56:15 <ksf> didn't even figure out yet how to give a function parameter to zipWith
05:56:21 <sm> not sure when you'd want the clipping, but nice
05:56:25 <merijn> omie: One list hint for you, then: Meditate on your getTweets functions and the function "map"
05:56:26 <aristid> brbr: presumably Arch linux
05:56:28 <merijn> :t map
05:56:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:56:44 <ksf> sm, nothing concerning the gregorian calendar is sane.
05:56:47 <merijn> I meant to say "last", but I suppose "list" also works :>
05:56:48 <Itkovian_> brbr: What aristid said
05:56:56 <ksf> if you want a calendar that is'nt confused as hell, try the discordian.
05:57:30 <omie> merijn: noted
05:57:31 <brbr> is that the best distro to hack on ghc?
05:57:32 <aristid> ksf: it is possible to do calculations with the gregorian calendar. that can't be said of the islamic calendar ;)
05:57:35 <brbr> what about fedora?
05:58:02 <aristid> brbr: i think it's quite possible to do that with all distros
05:58:10 <omie> bbl. Thanks alot everyone :-)
05:58:16 <ksf> gah. the gregorian doesn't even have a constant day of the year -> weekday mapping.
05:58:25 <aristid> brbr: if you hack ghc you need to compile ghc by hand anyways, so the package manager isn't really that important there
05:58:31 <sm> ksf: discordian looks fun :)
05:58:36 <Jafet> ksf: blame god!
05:58:42 <aristid> ksf: so?
05:58:56 <ksf> the only thing you can be reasonably sure of is that in non-leap years, march 4th is going to be the same weekday as febuary 4th
05:59:19 <aristid> ksf: the time package really helps you there.
05:59:28 <ksf> also, the discordian week is shorter. which means more free days.
05:59:33 <aristid> it's just DST rules that really suck
05:59:36 <Jafet> "So... is it six solar days, or sidereal days?"
06:00:11 <ksf> sidereal.
06:00:20 <ksf> the discordian calendar knows leapyears, too
06:00:39 <ksf> ...the leapday doesn't belong to any month, though, and thus doesn't mess up the numbering.
06:00:48 <dmwit> Hey, have I mentioned that all of you should come to Hac Phi!
06:01:23 <dmwit> http://www.haskell.org/haskellwiki/Hac_%CF%86/Register + /join #haskell-hacphi
06:02:05 <Itkovian_> dmwit: If you pay for my flight :-)
06:02:25 <dmwit> ha!
06:02:41 <dmwit> Well, I'll pay for your meals while you're here...
06:05:13 <ksf> sm, if you don't mind brain damage, you can have a look at the source of ddate
06:05:22 <ksf> ...to be found within linuxutils.
06:08:27 <anincog> Hmm, what's the real name of this function? I just wrote it because I had a need for it... http://hpaste.org/45945/whats_the_function_called
06:09:59 <anincog> (it's sort of like map, the difference being that the function it takes can look both at the elements already processed and the ones that remain, in addition to the currently processed element)
06:10:12 <Jafet> Doesn't look like it deserves a real name...
06:10:28 <anincog> hmm, it felt like a very natural thing, so I just assumed it had a name
06:11:00 <Jafet> Well, it looks potentially inefficient, for one thing
06:11:20 <Jafet> You're doing what looks like a zipper, but a little wrongly
06:12:13 <anincog> hmm, that sounds familiar... a zipper is something that maintains a "focus" while traversing a structure, right?
06:13:02 <cdsmithus-mobile> Hmm... looks like it could be simplified a tad... try looking at (zip (inits xs) (tails xs)), and see if that's what you wanted.
06:13:46 <anincog> cdsmithus-mobile: Thanks, that's a good idea
06:14:21 <fryguybob> @type \f -> zipWith f <$> inits <*> tails
06:14:21 <lambdabot> forall c a. ([a] -> [a] -> c) -> [a] -> [c]
06:15:42 <anincog> fryguybob: That's nice :)
06:19:22 <Jafet> But f has to deal with an empty list...
06:19:31 <fryguybob> > (\f -> zipWith f <$> inits <*> tails) (\xs ys -> concat [xs, "|", ys]) "Hello world"
06:19:32 <lambdabot>   ["|Hello world","H|ello world","He|llo world","Hel|lo world","Hell|o world"...
06:21:53 <cdsmithus-mobile> That's cute, but Jafet has a point,too... in its is rather inefficient.  If you can stand to have the left hand list in reverse order, a lot of allocations can be saved
06:22:22 <anincog> cdsmithus-mobile: I actually can, and in my case I do actually add to the beginning of the left hand list
06:22:40 <anincog> (I just felt the order-preserving version was more natural, so that's the one I posted)
06:22:42 <Jafet> > (\f -> zipWith (\sx (x:xs) -> f sx x xs) <$> inits <*> init.tails) (\sx x xs) -> sum (sx ++ xs) / x) [1..10]
06:22:43 <lambdabot>   <no location info>: parse error on input `)'
06:22:49 <Jafet> > (\f -> zipWith (\sx (x:xs) -> f sx x xs) <$> inits <*> init.tails) (\sx x xs -> sum (sx ++ xs) / x) [1..10]
06:22:51 <lambdabot>   [54.0,26.5,17.333333333333332,12.75,10.0,8.166666666666666,6.85714285714285...
06:23:07 <Jafet> anincog: in that case, you do have a zipper
06:23:39 <anincog> Jafet: OK -- thanks for informing me :)
06:24:51 <shapr> Howdy!
06:24:51 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
06:25:01 <shapr> I'm trying the in-browser irc chat with tryhaskell.org, that's pretty awesome!
06:25:43 <Jafet> Welcome, shapr! Haskell is widely used in academia and industry.
06:26:46 <shapr> Jafet: So you think I could build web pages with Haskell?
06:27:31 <Jafet> You should know that it's a theoretically flawed approach, that is unfortunately popular in other languages.
06:27:44 <Jafet> Here, we build languages that build programs that build web pages with Haskell.
06:27:44 <shapr> What, the web? I'm confused.
06:27:47 <shapr> oh
06:29:21 <shapr> My coworker told me today that he likes tryhaskell.org
06:29:33 * shapr decides to reconnect with his actual irc client
06:30:11 <cathper> tryhaskell.org is "just" using qwebirc ...
06:30:32 <Jafet> I don't think it's allowed to use anything else.
06:33:41 <cathper> Well, I mean, it's JavaScript magic done by Chris Porter, not Haskell magic.
06:33:50 <cathper> It's neat anyway :-)
06:34:26 <luite> oh no, I hope tryhaskell will not bring in too many noobs like shapr. surely that cannot be good for the channel
06:34:58 <bjornbuckwalter> \join ghc
06:35:56 <Saizan> luite: were you here when it got on reddit's frontpage?
06:37:13 <luite> uh no, but that was a joke, shapr has been around for a long time :)
06:37:16 <jonkri> how can i declare a monad transformer which is a StateT with an  initial state of "state" that goes on top of an arbitrary MonadIO?
06:38:33 <Saizan> i know, but we got a "wtf is this? why should i care?" crowd that time
06:39:55 <Saizan> jonkri: just use StateT and pass "state" when you're going to use runStateT
06:45:48 <jonkri> why does hoogle specify "runStateT :: s -> m (a, s)" and ghci "S.runStateT :: S.StateT s m a -> s -> m (a, s)"?
06:46:15 <jonkri> in ghci, it looks like runStateT takes two arguments
06:46:46 <mekeor> i want to use the function "intersect" (http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:intersect), typing ":t intersect" GHCI says "Not in scope". how to solve this?
06:46:58 <applicative> @unmtl StateT s m a
06:46:59 <lambdabot> s -> m (a, s)
06:47:09 <Lemmih> mekeor: :m Data.List
06:47:10 <ClaudiusMaximus> mekeor: :m + Data.List
06:47:24 <fryguybob> mekeor: import Data.List
06:47:31 <mekeor> Lemmih, ClaudiusMaximus, fryguybob: THX
06:47:36 <jonkri> appamatto, what's unmtl?
06:48:04 <Saizan> jonkri: hoogle is buggy
06:48:16 <jonkri> "applicative", sorry appamatto 
06:48:17 <applicative> StateT s m a is  a newtype wrapper, unmtl is just a lambabot machine for showing you what it wraps
06:48:30 <Saizan> jonkri: runStateT does take two arguments
06:49:09 <applicative> maybe it should just be @unwrap and apply to all the newtyped things around?
06:49:21 <fryguybob> @hoogle runStateT
06:49:21 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
06:49:21 <lambdabot> Control.Monad.State.Strict runStateT :: StateT s m a -> s -> m (a, s)
06:50:16 <applicative> fryguybob, jonkri that's what my hoogle says ^^^
06:51:08 <fryguybob> applicative: mine too.
06:51:35 <shapr> So I heard about this awesome programming language called Haskell.
06:51:40 <applicative> anyway, runStateT stt just strips of the newtype wrapper, like most runBlah things around.  I don't really like this tradition
06:51:48 <jonkri> this was the constructor that i was confused about: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html#v:StateT
06:51:51 <shapr> mekeor: Are you experienced with Haskell?
06:51:54 <applicative> shapr: oh, we can explain it to you
06:52:02 <shapr> applicative: Tell me about Haskell!
06:52:18 <Saizan> jonkri: are you familiar with record syntax?
06:52:26 <applicative> 1. Haskell is beautiful
06:52:32 <jonkri> Saizan, yes
06:52:38 <applicative> 2. shapr writes Haskell
06:52:55 <Saizan> jonkri: e.g. data Point = Point { x :: Int, y :: Int} ? runStateT is like 'x' there
06:52:58 <jonkri> "3. ???????"? :)
06:53:06 <Saizan> jonkri: x :: Point -> Int
06:53:07 <djahandarie> 4. PROFIT
06:53:10 <jonkri> >D
06:53:11 <jonkri> :D
06:53:12 <cheater99> what is the physically smallest complete computer that haskell will run on and perform well?
06:53:16 <applicative> 3. Haskell doesn't have menacing first class modules!
06:53:42 <fryguybob> 1. 2. => shapr is awesome.
06:53:49 <cheater99> let's not include the power source (battery, psu) in the size
06:54:00 <applicative> cheater99: oh i thought the ambient FUD was it perform well on really existing hardware.  
06:54:08 <applicative> was it doesn't perform
06:54:13 <Saizan> rebranding missing functionality as features, that's very apple-ish :)
06:54:21 <cheater99> what?
06:54:28 <cheater99> ghci is very fast
06:54:33 <cheater99> ghci/ghc
06:54:56 <applicative> just kidding.  wasn't there a discussion on cafe about the Olde Days when they ran gofer on absurdly small cpus
06:55:07 <cheater99> they still do
06:55:13 <cheater99> anyways, for example, does ghc work well on an atom? are there good optimizations for that?
06:55:27 * cheater99 wishes mauke were here
06:55:33 <shapr> applicative: So, you have experience with OCaml or something?
06:56:03 <Saizan> i don't think they have done anything to target atom specifically
06:56:12 <applicative> shapr, no I'm studying up in order to make sense of Professor R. Harper's haskell bashing of last week.
06:56:25 <shapr> Oh, where was that?
06:56:26 <cheater99> Saizan: hmm
06:56:30 <cheater99> Saizan: what about ghc for arm?
06:56:38 <cheater99> is there anything like this at all?
06:56:41 <shapr> Last I heard there's not much ARM support.
06:56:45 <applicative> shapr, there was a lot of gnashing of teeth about our lack of a True module system
06:57:14 <merijn> applicative: Haskell is a sucky language anyway. No dependent types, partial functions, no constraint typing :>
06:57:26 <crystal-cola> What is constraint typing?
06:57:34 <cheater99> what are partial functions?
06:57:36 <jonkri> Saizan, if runStateT essentially gets a field of a record, where is the record created?
06:57:43 <ksf> applicative, there'd be no gnashing about that if we had a proper record system.
06:57:49 <merijn> cheater99: Head is a partial function (not defined for the empty lists)
06:57:53 <djahandarie> merijn, huh? We have partial functions. :p
06:58:00 <djahandarie> Oh
06:58:01 <applicative> crystal-cola: sounds good, we're f*cked for not having it surely
06:58:02 <cheater99> oh ok
06:58:03 <Saizan> cheater99: i think there's a way to make executables for ARM but it's not so well supported
06:58:07 <crystal-cola> lol!
06:58:08 <merijn> djahandarie: That's why there's no no in front of partial functions :p
06:58:09 <djahandarie> You meant that we DO have partial functions
06:58:11 <djahandarie> Yeah lol
06:58:22 <crystal-cola> Can anyone tell me about constraint type??
06:58:24 <applicative> yeah, man agda has dependent types, but where are the partial functions, it sux
06:58:27 <cheater99> Saizan: aha.. that's not too good
06:58:28 <Saizan> jonkri: "StateT s m a" is the record type here
06:58:31 <shapr> crystal-cola: http://ww2.cs.mu.oz.au/~sulzmann/chameleon/download/haskell.html
06:58:45 <crystal-cola> I tried to compile chameleon but it does not build
06:58:54 <cheater99> are there any other "small" cpu families that ghc *is* supporting?
06:58:57 <applicative> shapr, our depraved lack of True Modules http://existentialtype.wordpress.com/2011/04/16/modules-matter-most
06:59:04 <merijn> crystal-cola: Constraint typing means a type can be constrained to part of it's possible values. i.e. I can define a type which is "all lists, except the empty one'
06:59:05 <shapr> Martin Sulzmann did a bunch of stuff with CHR in Chameleon.
06:59:20 <crystal-cola> merijn: oh right, I call that subset types
06:59:26 <crystal-cola> although "subset" is a horrible name
06:59:45 <applicative> shapr, he's mostly making excellent points, maybe even that one.  But somehow championing sml-nj over a possible utopian haskell of tomorrow, bugs me
06:59:49 <merijn> crystal-cola: It's just a set of constraints on the possible values propagated by the compiler
07:00:04 <jonkri> Saizan, how is the record initialized?
07:00:06 <shapr> applicative: From what I've understood by listening to edwardk, 'real' modules would be a nice feature. From looking at hackage, I think it's not required for popularity.
07:00:33 <merijn> Also, I can't even proof my programs terminate in Haskell :(
07:01:04 <applicative> The masters seem to agree it would be good, I'm still trying to figure it out.  
07:01:19 <Saizan> jonkri: StateT something; where something :: s -> m (a,s) 
07:01:25 <merijn> Turing completeness is overrated, strong termination is a nice feature. (Provided you have a proper coprogramming abstraction)
07:01:28 <applicative> merijn, well lets cook up a sub-haskell, pre-haskell with totality!
07:01:44 <applicative> merijn, but where is this to be found
07:02:07 <Saizan> applicative: agda has a true module system too, btw
07:02:11 <shapr> merijn: Can you get general recursion if you can prove termination?
07:02:13 <Saizan> lacks typeclasses still.
07:02:25 <jonkri> so a record Record { x :: Int } can be initialized with Record 5?
07:02:34 <applicative> Saizan yes, that's the most I know of them so far, my ML studies havent got to modules yet
07:02:37 <merijn> shapr: No, but who cares if you have another way to do coprogramming
07:02:38 <shapr> I'm a big fan of turing completeness.
07:02:42 <shapr> merijn: Like what?
07:02:45 <Saizan> jonkri: yes, though i'd say "created"
07:02:59 <merijn> I didn't say I knew what the solution was ;p
07:03:03 <jonkri> that's a better word :)
07:03:18 <applicative> shapr why do you want general recursion?
07:03:20 <shapr> merijn: What are other existing ways to do coprogramming?
07:03:31 <Saizan> shapr, merijn: actually you can program in the "non-termination" monad and prove termination separately if you want :)
07:03:31 <applicative> shapr, well Haskell is
07:03:34 <merijn> applicative: My mind has been poisoned by Epigram's papers and Conor's PhD thesis. I think it'll be *a little while* before any of that is practical :p
07:03:37 <applicative> only you cant program in it
07:04:02 <shapr> I do very much like Epigram!
07:04:33 <merijn> shapr: A non-termination monad is a good example. Most useful coprograms are effectively infinite loops calling terminating programs
07:04:37 <shapr> applicative: Haskell is an existing way to do coprogramming?
07:04:38 <adamvh> applicative: Harper seems to dislike laziness as much he likes OCaml's modules, so it makes sense that "Haskell of tomorrow" is not his ideal solution
07:04:46 <applicative> merijn, same here.  also D. Turner .  Have you seen the CPL interpreter on hackage? 
07:04:55 <shapr> merijn: That would work fine for me.
07:04:59 <merijn> Shouldn't be to hard to proof such a loop is correct if your terminating programs can be proved terminating
07:04:59 <adamvh> applicative: I can't evaluate his preference, of course
07:05:10 <shapr> merijn: Er wait, are you sure about that?
07:05:43 <merijn> Well, if the components are proven to terminate you only have to proof the loop is infinite, that shouldn't be that hard, should it?
07:05:54 <applicative> adamvh, I don't know, why shouldn't a language be both lazy and not.  One default for codata, the other for data, etc
07:05:59 <shapr> merijn: I don't know.
07:06:09 <merijn> Me neither, I'm not Conor :>
07:06:23 <shapr> applicative: Do you need to explicitly mark data and codata?
07:06:37 <adamvh> applicative: We're already wandering out of my depth, I was just pointing out another reason why he prefers SML-NJ
07:06:55 <applicative> shapr it is so in CPL, but uh, that's not too practical.
07:06:59 <shapr> I was out of my depth when I joined the channel! I've been writing Python for weeks!
07:07:01 <Philippa> shapr: you would if you did that. They're isomorphic in a typical turing-complete functional language though
07:07:25 <shapr> Philippa: Right, makes sense.
07:07:50 <Necrosporus> crystal-cola, I have used your tip to compute 1st euler problem: http://paste.org.ru/?auyise
07:07:59 <Saizan> merijn: proof is a noun, you should use prove :)
07:08:12 <jonkri> why do i create StateTs with "s -> m (a,s)" functions? (what's the computation?)
07:08:16 <Necrosporus> This code seems faster, but it's more long
07:08:31 <crystal-cola> Necrosporus: good 
07:08:47 <merijn> Saizan: My mind has a tendency to use phonetically similar words interchangeably if I don't proofread >.>
07:08:51 <aristid> jonkri: most of the time you don't use the StateT constructor directly, but put and get
07:08:55 <crystal-cola> Necrosporus: don't worry about making things short
07:08:56 <ksf> jonkri, look at the definition of >>=
07:09:31 <ksf> jonkri, the monad part of the whole thing just cares about passing through the state
07:10:34 <Necrosporus> crystal-cola, I want to see shortest possible code if it's fast enough to see the result within several seconds
07:10:48 <Saizan> jonkri: the point is that something of type State s a; is a way to transform a state of type 's' and also produce a value of type 'a', they are transformations because otherwise you couldn't make later computations use the state produced by earlier ones (once they are given an input state at the start)
07:10:52 <ksf> modifyState f = StateT $ \st -> return ((), f st)
07:11:11 <alfa_y_omega> hi guys, my mind got the horrible theory
07:12:27 <ksf> return x = StateT $ \st -> return (x, st)
07:12:29 <jonkri> hmm... i know what ">>=" and monads are...
07:12:39 <ksf> somewhere between those two and >>= should lie enlightenment.
07:12:45 <jonkri> so a State is not a state? it's more like a "state transformer"
07:12:47 <alfa_y_omega> i'll need many years due to this horribility
07:12:49 <Saizan> anyhow, have someone reminded harper that you can have inductive datatypes in haskell too? using strict fields everywhere :)
07:12:54 <ksf> jonkri, exactly.
07:12:59 <crystal-cola> Necrosporus: Finding the shortest program for a given specification is Extremely difficult
07:13:06 <Necrosporus> crystal-cola, why aren't you on #jsoftware ?
07:13:09 <ksf> ...a computation that has access to state
07:13:19 <merijn> alfa_y_omega: Which theory?
07:13:24 <Necrosporus> crystal-cola, it's what makes it interesting
07:13:32 <crystal-cola> Necrosporus: I guess :)
07:13:40 <alfa_y_omega> merijn, exponential computation of lambda calculus
07:13:52 <alfa_y_omega> exponential overflow
07:14:25 <applicative> shapr Hagino's cpl, makes you mark it, the imaginary ml version would be : codatatype ?a inflist = head is ?a & tail is ?a inflist;
07:16:48 <jonkri> i still don't see how i can create an initial state to use with StateT. should i create a transformation function that ignores its input?
07:17:19 <ChibaPet> Good morning all. And... Woot, my Learn You a Haskell just came from Amazon.
07:17:35 <shapr> I want a copy of that!
07:17:51 <ChibaPet> I didn't realize it was from the same publisher as Land of Lisp. Interesting, that.
07:19:24 <applicative> in cpl "left object Moo.." introduces data, "right object Baaah..." introduces codata.  then you give constructors in the one case destructors in the other case/
07:19:30 <applicative> a boring example:
07:19:38 <applicative> right object prod(a,b) with pair is; pi1: prod -> a;  pi2: prod -> b; end object;
07:19:48 <applicative> left object coprod(a,b) with case is;  in1: a -> coprod; in2: b -> coprod; end object;
07:20:00 <crystal-cola> how to extend CPL for dependent types?
07:20:43 <applicative> crystal-cola, the trouble is that this sort of thing was never investigated adequately before dependent types became sexy, so now clarity will never be attained
07:21:57 <shapr> applicative: Wait what?
07:22:02 <applicative> dependent types stand in the way of genuine progress, I think, despite their wonderfulness
07:23:14 <applicative> for example the lazy / strict opposition where it is not simply a calculation expedient presupposes non-totality turingland etc
07:23:44 * applicative hasn't thought about this for a while
07:23:47 * shapr hugs confound
07:23:48 <shapr> ahem
07:23:51 * shapr hugs conal
07:24:17 <conal> awww. :)
07:25:23 <applicative> crystal-cola: the dependent type systems want to introduce 'codata', but its a chronic crisis.  this is because there was never adequate investigation of this (much more interesting) opposition, in a simpler nondependent framework.
07:26:33 <crystal-cola> oh really??
07:26:49 <crystal-cola> I thought the simple codata was not problematic
07:27:59 <applicative> yes, but we would like a whole programming language with e.g. uh IO for example, which is no where in sight with the proof assistants etc
07:28:27 <applicative> and with the strict/lazy struggle wiped out for good, except as a calculational expedient.
07:30:16 <applicative> for me agda e.g. is principally of interest on account of its totality.  it is only in the presence of totality that thought is possible.
07:32:07 <applicative> crystal-cola: my cranky thought was: it is only in a system like that that each definition in my module is actually the definition of a concept, one that I can employ in my own thinking. the dependent types are a complete distraction, though of course interesting.
07:32:52 <rothwell> i don't like losing the phase distinction
07:32:54 <crystal-cola> I don't really get it, if your language is total then you can give the whole thing meaning
07:33:03 <crystal-cola> but if you don't have a total language you can still mean things sometimes
07:33:17 <jonkri> are your funcitons that modifies a monadic state value usually taking a value with HOW to change the state, in addition to the current state?
07:33:40 <kwantam> what happened to everything non-wiki at haskell.org? e.g., haskell.org/th is referenced in a lot of places, but doesn't exist any more. Is the setup broken, or did the wiki move to a new machine and lose its old content?
07:34:13 <jonkri> oh, sorry, i should probably use get and put :)
07:34:27 <applicative> kwantam there was a huge shuffle and a new machine a few months back.  right?
07:34:39 <jmcarthur> rothwell: i've been pretty negative about lack of phase distinction for a long time, but i've slightly warmed up to it. i'm still not sold on it completely, but it seems to not be so weird in practice
07:35:08 <kwantam> applicative, perhaps. and in the shuffle, it would appear much was lost, then?
07:35:16 <kwantam> or is there a canonical place for old stuff to have been repositioned?
07:39:04 <jeffz> kwantam: you can try the wayback machine, someone else asked on -cafe about some template haskell tutorials under /bz/ which have disappeared too
07:39:20 <kwantam> oh yeah I saw that
07:39:25 <kwantam> I'm trying to restore that page to functionality
07:39:35 <kwantam> I've gotten the HTML, but I was seeking out the papers et cetera
07:39:52 <kwantam> google is being mostly helpful, but it's somewhat tedious
07:40:20 <kwantam> also, I don't particularly want to convert the tutorials to Wiki format, but perhaps I'll have to since it won't just let me upload raw HTML files
07:44:02 <omie> and I am back :-D
07:44:20 <omie> friend asking if its possible to create dlls in haskell
07:45:01 <jeffz> omie: yes.
07:45:32 <jeffz> omie: http://blogs.msdn.com/b/satnam_singh/archive/2011/04/19/creating-a-windows-dll-from-a-haskell-program-and-calling-it-from-c.aspx
07:45:40 <aristid> omie: not easily at least.
07:45:42 <Jafet> You can make DLLs of nearly anything
07:45:47 <Jafet> If you try hard enough
07:45:48 <jeffz> aristid: it's quite easy.
07:45:55 <aristid> jeffz: it is?
07:46:01 <jeffz> sure, see the blog.
07:46:10 <kwantam> yeah it works in modern GHCs
07:46:30 <kwantam> in 6.{6?,8?} and earlier it was broken iirc
07:47:39 <omie> hmm interesting
08:01:50 <mm_freak> is there a simple, portable way to disable the SIGPIPE signal?
08:02:08 <mm_freak> i'd like to disable the signal on unix-like systems and just do nothing on windows
08:02:59 <kwantam> install a handler for it that does nothing except reinstall itself
08:03:22 <kwantam> the proper way is SIG_IGN but perhaps for some reason that doesn't work on windows?
08:03:55 <kwantam> however, what are you really trying to do?
08:06:00 <kwantam> damnit, someone with access to the wiki internals and a stomach for PHP should find out why it can't generate summary pages about uploaded PDFs
08:06:16 <kwantam> is there such a person here?
08:06:54 <jeffz> I've hacked on mediawiki before but not for fun.
08:07:05 * jeffz runs off to the land of nod.
08:08:38 <jonkri> any idea why i get "Could not deduce (MonadIO Data.Functor.Identity.Identity) arising from a use of `liftIO'" here:
08:08:39 <jonkri> stateLoop :: MonadIO m => Chan InternalEvent -> State (m a) InternalState
08:08:39 <jonkri> stateLoop c = liftIO (readChan c) >>= \ event -> processEvent event >>= \ _ -> stateLoop c
08:10:02 <kwantam> jonkri can you temporarily give it a more specific type and see if there is some other problem?
08:10:37 <kwantam> (I admit that's a really long way to spell "no" but I'm tryin' :) )
08:11:05 <jonkri> :)
08:11:05 <parcs> jonkri: State s is an alias for StateT s Identity
08:11:46 <parcs> thus your return value is MonadIO m => StateT InternalState Identity (m a)
08:11:49 <parcs> which makes no sense
08:12:15 <parcs> you probably want MonadIO m => StateT InternalState m a
08:12:53 <scree> am I unreasonable to want a version of -fwarn-incomplete-patterns that doesn't complain inside do notation or list comprehensions?
08:13:18 <mm_freak> kwantam: the 'unix' package is not portable
08:13:24 <mm_freak> kwantam: the signal handling functions are there
08:13:24 <scree> I'm trying to write warning-free code, and it's annoying that wonders such as [a | Just a <- l] aren't allowed
08:13:32 <crystal-cola> How tdo I compute a^b really quickly in haskell?
08:13:49 <kwantam> mm_freak : use CPP
08:13:56 <crystal-cola> mod m
08:13:59 <kwantam> #ifdef POSIX or something?
08:14:00 <rostayob> @pl \m1 m2 -> compare (score m1) (score m2)
08:14:00 <lambdabot> (. score) . compare . score
08:14:39 <luite> crystal-cola: use (a*b) `mod` m = a `mod` m * b `mod` m
08:14:43 <kwantam> a^b mod m quickly is covered in... the first chapter of SICP
08:14:46 <mm_freak> scree: you can use combinators for that
08:14:52 <mm_freak> scree: see the 'maybe' combinator
08:15:09 <kwantam> luite has the right of it
08:15:33 <luite> crystal-cola: combine that with the typical exponentation algorithm by repeated squaring, using the binary expansion of the exponent
08:15:34 <kwantam> except it's ((a mod m) * (b mod m)) mod m
08:15:48 <mm_freak> crystal-cola: either write a Mod type (which is a science in itself), then you can use the usual (^) operator
08:16:00 <luite> oh right
08:16:09 <mm_freak> crystal-cola: or you have to write the algorithm yourself (square and multiply)
08:16:52 <scree> mm_freak: I know I *can* use maybe; are you saying what you get is as neat as these (completely safe) incomplete patterns?
08:16:53 <fryguybob> > comparing negate 1 2
08:16:55 <lambdabot>   GT
08:17:45 <jonkri> changing the type worked. thanks kwantam and parcs 
08:18:00 <kwantam> crystal-cola
08:18:03 <kwantam> see http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.6
08:18:16 <kwantam> scroll down to "The Fermat test"
08:18:26 <kwantam> their definition of expmod is what you want
08:19:02 <crystal-cola> cool
08:19:19 <mm_freak> scree: well, it's more explicit
08:19:33 <mm_freak> scree: haskellers have mixed feelings for the "fail" function
08:19:43 <mm_freak> personally i never use it, even if it would be perfectly safe
08:19:54 <copumpkin> mixed? I thought everyone hated it
08:20:08 <Saizan> fail doesn't matter for list comprehensions 
08:20:12 <mm_freak> it makes understanding the code harder, because you need to look up the implementation of "fail" in the corresponding monad
08:20:25 <kwantam> crystal-cola, if you hate scheme syntax then http://hpaste.org/45947/fast_expmod
08:20:34 <mm_freak> Saizan: oh?
08:20:35 <jmcarthur> i've reluctantly used fail
08:20:37 <kwantam> I had that lying around somewhere
08:20:40 <jonkri> what does this error mean? (code included) http://hpaste.org/45948/statet_error
08:20:43 <jmcarthur> i don't dislike fail. i dislike it being in Monad
08:20:59 <jonkri> processEvent should run in the same monad as stateLoop
08:21:07 <copumpkin> jmcarthur: epic fail
08:21:18 <jmcarthur> it's very convenient with do notation, but Monad shouldn't be just "the type class for do notation," IMO
08:21:19 <Saizan> mm_freak: list comprehensions are just going to return a [] if the pattern doesn't match, there's nothing to look up
08:21:40 <Jafet> scree: for that comprehension, you could also use catMaybes
08:21:56 <Jafet> ... or just don't use -Wall, like me!
08:22:28 <Jafet> Do Haskellers have mixed feelings for -Wall?
08:22:43 <rostayob> what's wrong with -Wall?
08:22:59 <lispy> Jafet: the only thing about wall that I don't like is the ignored monadic return thingy
08:23:03 <rostayob> actually I do -Wall + -fno-warn-unused-do-bind
08:23:12 <rostayob> lispy: yeah, exactly
08:23:31 <lispy> rostayob: I don't think anyone likes that feature except the original bug reporter
08:23:33 <Jafet> The assumption that any build process that uses it must finish with no warnings
08:23:37 <scree> Jafet: sure (should really explain I'm not a beginner); though my actual example was [(b, a) | (Just b, a) <- l] which has no such handy solution
08:24:10 <rostayob> I's also like an option to supress warnings when the compiler automatically infers Int or String
08:24:20 <rostayob> when you write a number or a string when using OverloadedStrings
08:24:32 <lispy> Jafet: -Wall is fine but -Werror + -Wall is extremely problematic with ghc because they add and modify how warnings are generated quite frequently.  So you can have perfectly valid code on ghc 6.10 that breaks spuriously on 6.12
08:24:36 <ksf> -Wall -fno-warn-name-shadowing
08:24:45 <rostayob> ksf: that does what I want?
08:24:52 <ksf> there's a couple of useful warnings that aren't in -Wall, too.
08:25:09 <ksf> like the monomorphism thingie.
08:25:15 <ksf> so I remember to turn the restriction off.
08:25:28 <scree> I'd be happy to have this only in list comprehensions if someone also invented a Maybe comprehension
08:25:38 <ClaudiusMaximus> -fno-warn-type-defaults perhaps
08:25:38 <lispy> ksf: do you turn on MonoLocalBinds?
08:25:56 <ksf> it usually turns out to be turned on, anyway.
08:26:01 <scree> and possibly a MonadPlus comprehension (or MonadZero comprehension if you like)
08:26:06 <ksf> too much language pragmas in my code.
08:27:00 <Jafet> I find it useful to quote GNU http://www.gnu.org/prep/standards/standards.html#Syntactic-Conventions
08:27:13 <Jafet> "Some programmers like to use the GCC ‘-Wall’ option, and change the code whenever it issues a warning.  If you want to do this, then do. Other programmers prefer not to use ‘-Wall’, because it gives warnings for valid and legitimate code which they do not want to change. If you want to do this, then do.  The compiler should be your servant, not your master."
08:28:01 <lispy> Jafet: we have hlint BTW
08:28:23 <lispy> Jafet: so you can use that to get extended analysis about things that might be weird
08:28:33 * ksf never thought he'd agree to a part of gnu's C conventions
08:28:35 <Jafet> hlint seems to give useful suggestions – though I've never used it outside of hpaste.
08:29:12 <rostayob> that's all very true, i mostly use -Wall to force myself to add meaningful type signatures
08:29:22 <lispy> with gcc I tend to use -Wall and -pendantic as much as possible because I've had them catch bugs early
08:29:38 <lispy> with ghc, I find -Wall less important, but I still like it
08:29:39 <ksf> that, and -std=C99
08:29:49 <rostayob> and -Wall in gcc is way more important then -Wall in ghc, all those implicit casts ehe
08:30:24 <ksf> back in the days, we had to make our exercises build with -Wall -Werror -pedantic -ansi
08:30:32 <parcs> i see a lot of c projects using -pedantic too
08:30:44 <rostayob> wow
08:30:46 <lispy> ksf: I had some code that was fine but didn't compile with C99 due to something weird (CPP issues?) and the issue was in a header file on my linux distro so I didn't endup using it.
08:30:56 <rostayob> they make us run some *absurd* java version of lint
08:31:04 <rostayob> it complains about objects being created in loops.
08:31:11 <rostayob> can't remember what it's called
08:31:33 <rostayob> this: http://pmd.sourceforge.net/
08:31:43 <Ke> -Wall -pedantic -Wextra -std=c99 is the recommendation at our C course
08:31:51 <rostayob> pmd is ridicolous
08:32:02 <rostayob> it complains about one letter variables
08:32:09 <lispy> ke: do they also recommend following the CERT C guide lines?
08:32:17 <ksf> hlint is very, very sensible.
08:32:36 <ksf> though possibly a bit harsh on newbies.
08:32:39 <Ke> heh, no idea what that even is
08:32:40 <lispy> Someone at work showed me this recently: https://www.securecoding.cert.org/confluence/display/seccode/CERT+C+Secure+Coding+Standard
08:32:49 <ksf> Ke, haskell lint.
08:33:19 <ksf> which includes things like making you use cromulent pointless style.
08:33:46 <Ke> lispy: well no idea, whether there is an automatic checker for that
08:33:46 <rostayob> hlint is not bad
08:34:14 <Ke> no valgrind errors is obviously also enforced
08:34:27 <lispy> ke: oh yeah, I don't know if there is either, but you can still aspire to follow it :)
08:35:20 <ksf> I'd like to have a {-# SUPPRESS_WARNING #-} pragma, though.
08:35:30 <ksf> sometimes it's just that one line in a file.
08:35:48 <pmurias> rostayob: are you forced to respect it's recommendations?
08:36:53 * osfameron perpetrates https://github.com/osfameron/geekup-talk-haskell/blob/master/quiz.hs
08:37:15 <osfameron> (which is my longest, marginally non-trivial, actually functioning haskell program ;-)
08:37:47 <rostayob> pmurias: no I'm not
08:37:56 <rostayob> pmurias: but they mark stuff with the corrections that it makes
08:38:45 <rostayob> I mean I don't thing they even believe in it, but whatever. in theory we should follow what it says.
08:39:42 <jmcarthur> lispy: there is no automatic checker for everything in CERT
08:41:27 <mm_freak> Saizan: then i wonder why GHC gives a warning for incomplete patterns in a list comprehension (assuming scree is right and it does)
08:42:18 <jmcarthur> i doubt even something like coverity can declare a program CERT compliant
08:43:35 <lispy> jmcarthur: right.  It looks like each recommendation lists if there are tools that are known to check for it
08:43:44 <rothwell> i can declare anything you need compliant
08:43:59 <lispy> jmcarthur: like this one lists Compass/ROSE: https://www.securecoding.cert.org/confluence/display/seccode/DCL00-C.+Const-qualify+immutable+objects
08:44:56 <Jafet> That CERT standard doesn't really give security advice
08:45:28 <Jafet> It's just a listing of a small fraction of things that people think they know about standard C but don't
08:45:49 <jmcarthur> no it also includes stuff like making sure to wipe a sensitive buffer before freeing it and stuff
08:46:27 <jmcarthur> i think even some fairly domain specific things like preventing SQL injection
08:46:54 <Jafet> SQL injection is really just a consequence of people using cross-language eval.
08:47:09 <jmcarthur> yep
08:48:34 <ClaudiusMaximus> i found my graphics drivers (well, whatever version i had in december) don't clear memory when allocating it, so information can leak between programs.. http://claudiusmaximus.goto10.org/g/glitch/glitch-6.png
08:48:55 <Heffalump> eval of any form would be dangerous, presumably?
08:49:27 <ricky> Hehe, nice find, that's pretty horrible though :/-/
08:50:19 <jmcarthur> ClaudiusMaximus: that's pretty typical for graphics drivers, actually
08:51:22 <ClaudiusMaximus> jmcarthur: makes me scared about webgl (that and the potential to hang the gpu and/or os with silly shader code - did that to myself once by accident...)
08:52:05 <Jafet> Nah, they'll probably invent GPGPU virtualization or something
08:53:16 <ClaudiusMaximus> what's the etiquette about uploading to hackage in this situation?  i have 1 haskell program, and 11 programs in a mix of C and C++, and 1 huge bash script to make the 12 programs do useful things
08:54:01 <ClaudiusMaximus> the haskell program might be mildly entertaining on its own, so i could split it out i suppose...
08:54:50 <maltem> ClaudiusMaximus, people usually expect that packages on hackage consist of Haskell code only (modulo binding code)
08:54:58 <ClaudiusMaximus> it also requires a ghc compiled with integer-simple, at least while hmpfr still requires that
08:55:28 <ClaudiusMaximus> maltem: makes sense i guess :)
08:56:17 <Saizan> if you can wrap it up as a cabal package..
08:57:13 <maltem> Right, it's not like people go nuts if they see a shell script or something ;)
08:58:01 <maltem> I suppose that we just lack an etiquette here
09:01:11 <Taslem> @pl elemCount a b = length $ elemIndices a b
09:01:11 <lambdabot> elemCount = (length .) . elemIndices
09:01:59 * ksf is fine with type-level programming, in general.
09:02:10 <FUZxxl> @hackage haskelline
09:02:11 <lambdabot> http://hackage.haskell.org/package/haskelline
09:02:16 <Taslem> Why is it that the point-free version it gave me registered a type error, requiring an explicit definition, where the original did not?
09:02:17 <ksf> but there definitely *can* be too much of it.
09:02:44 <ksf> more importantly, people who write those libraries seem to have a different notion of useful documentation and examples than me.
09:02:45 <Saizan> Taslem: the monomorphism restriction
09:03:35 <Taslem> Hm. Seems evil to me.
09:03:49 <ksf> to top the whole thing, there's then those that say "well, heterogenous, extensible records can obviously be implemented with type magic, so there's nothing to be done on the language side"
09:05:45 <Saizan> Taslem: it is
09:06:06 <Saizan> Taslem: the best description of it is in the language report btw
09:09:57 * hackagebot fuzzytime 0.7.3 - A clock and timer that tell the time in a more human way  http://hackage.haskell.org/package/fuzzytime-0.7.3 (KamilStachowski)
09:17:35 <sm> morning all. Could someone remind me how to import things in ghc -e one-liners ?
09:18:05 <lispy> sm: You use the full name.  Foo.Bar.Baz.x
09:18:27 <lispy> sm: but it's kind of a bad idea because who knows what version of the Foo library you'll get
09:18:33 <sm> ahh, thanks
09:18:46 <lispy> sm: and you may need to pass -package if it's not a package that ghc automatically gives you
09:20:56 * ksf wonders whether there's anyone except wolfgang who understands his code.
09:21:02 <ksf> I certainly feel pity for his students.
09:21:13 <lispy> ksf: what code are you referring to?
09:21:49 <ksf> records, type-functions/kinds in particular
09:23:00 <lispy> ksf: do you have a link?
09:25:14 <ksf> http://hackage.haskell.org/package/records
09:25:41 <ksf> it's grapefruit-records, generalised.
09:33:32 <sm> all this time I've been importing individual time modules, but a simple import Data.Time will do
09:33:50 <sm> time++
09:35:16 <Taslem> If you call the same function with the same arguments twice in an expression, does Haskell optimize? or GHC, I mean?
09:35:36 <Saizan> usually no
09:35:53 <Tomsik> Huh
09:35:56 <Philippa> there are specific reasons not to do it under lazy evaluation
09:36:00 <Tomsik> No common call optimization?
09:36:02 <jmcarthur> ghc will perform CSE sometimes, but only rarely
09:36:27 <maurer_> Philippa: Why would CSE be dangerous for lazy evaluation?
09:36:41 <Philippa> maurer_: because it can introduce space leaks
09:36:42 <jmcarthur> you don't necessarily want it to. it might cause your program to hold onto a lot of memory when it would be cheaper to just recompute it
09:36:44 <mauke> because it makes stuff hang around
09:37:24 <ksf> if you care about sharing a result, bind the result to a variable.
09:37:26 <jmcarthur> if you have a local subexpression that you want shared, you can just use let
09:37:45 <ksf> it's better style, anyways.
09:37:58 <maurer_> Yeah, I know how to manually do sharing, I was just curious as to why our compiler couldn't do it for us, and I suppose it makes sense.
09:38:25 <pmetzger> what is considered good style for picking an expression based on several different possible strings? say I have a variable that might have one of several string values and I want to dispatch on that. are equality tests in guards preferred?
09:38:48 <Philippa> maurer_: it's particularly bad if the second use only needs, say, 10% of the structure
09:38:54 <pmetzger> (I realize this is the question of an inexperienced haskell user, but I am an inexperienced haskell user...)
09:38:55 * ksf wouldn't consider dispatching on strings (outside of a parser) good style, in any case.
09:39:02 <pmetzger> this is a parser.
09:39:05 <pmetzger> though a really simple one.
09:39:16 <ksf> well, then use parser combinators
09:39:35 <Philippa> you can just use straight string patterns if you're matching on the whole string
09:39:38 <pmetzger> this seems simpler than that. I'm just reading some lines and doing something based on the word at the start of the line.
09:39:46 <pmetzger> I am matching on the whole string.
09:40:07 <pmetzger> so just use straight string patterns? seems reasonable.
09:40:09 <Philippa> > case "flibble" of "flibble" -> True; _ -> False
09:40:10 <lambdabot>   True
09:40:14 <ksf> @hoogle startsWith
09:40:14 <lambdabot> No results found
09:40:20 <mauke> :t isPrefixOf
09:40:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:40:25 <ksf> oh, yes.
09:40:52 <Philippa> mauke: must stick that + view patterns in my bag of tricks for next time I have a use for it
09:40:58 <ksf> if you want it to be fast, build a trie out of your key / function pairs and then lookup.
09:41:16 <pmetzger> philippa: yah, in retrospect that seems like the obvious answer. 
09:41:16 <mauke> view patterns are deliciously evil
09:41:25 <KirinDave> Today's #1 post on hacker news is brutal to watch.
09:41:27 <pmetzger> ksf: speed is unneeded here at all. it is a negative concern. :)
09:41:43 <Philippa> I'm not convinced they're evil at all, given that we already don't have pattern coverage checking
09:41:57 <pmetzger> I'm just playing with doing something that I'd otherwise do with a trivial perl script.
09:42:01 <lispy> if I wanted to make an operator for Storable a => Ptr a -> Int -> a, I was thinking (*>) might be a decent way to go, but I think that's taken in applicative.  Is there a way to reuse applicative for this?
09:42:09 <lispy> Basically, I want to say, (*>) = peekByteOffset
09:42:17 <lispy> But it's hard to think of a good operator name since I can't use []
09:42:20 <lispy> :t (*>)
09:42:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
09:42:22 <ksf> well, you can do match xs = Prelude.lookup [("foo", doStuff),("bar",doOtherStuff)] 
09:42:38 <ksf> it's not far from there to using a fast data structure.
09:43:06 <lispy> Perhaps I could write Applicative (Ptr a)
09:43:13 <lispy> Oh, that would be Applicative Ptr
09:43:17 <crystal-cola> "Yes, I generalize. Don't we all?"
09:43:30 * lispy now wonders if Applicative is a Ptr
09:43:35 <pmetzger> you know, it ia a shame that IRC doesn't permit real time conversation threading so you can see which replies are to which messages...
09:43:36 <lispy> er, Ptr is an applicative /me can't type
09:43:38 <jmcarthur> lispy: would require making a new Ptr whenever you modify it
09:43:42 <pmetzger> would make segregating several conversations easier.
09:43:52 <ksf> pmetzger, you get used to it
09:44:06 <lispy> jmcarthur: Oh right.  You'd need a Ptr monad otherwise
09:44:12 <crystal-cola> the only problem is when people start bitching about it and trying to send everyone to different channels
09:44:13 <jmcarthur> also, i don't think you can even have  Ptr (a -> b)
09:44:19 <pmetzger> I've been using IRC for something like 22 years now and I haven't. :)
09:44:25 <jmcarthur> in fact....
09:44:35 <jmcarthur> you can't make Ptr an instance of Applicative at all due to the Storable constraint
09:45:02 <crystal-cola> something like a real time reddit would be interesting but how would you know when to erase old messages?
09:45:26 <KirinDave> crystal-cola: Simple solution: Never erase messages
09:45:27 <luite> realtime reddit, teh horror ;p
09:45:51 <pmetzger> Just color coding messages that are a particular thread would be enough or some such.
09:46:00 <crystal-cola> but then you would have too messages to deal with propery?
09:46:41 <KirinDave> crystal-cola: Ask Google. ;)
09:47:08 <crystal-cola> The reason reddit is so good is because they rewrote their program from lisp to python
09:47:27 <KirinDave> crystal-cola: Aren't you supposed to state that in the form of an inception image macro?
09:47:36 <KirinDave> Perhaps with a link to that guy singing "trolololo"
09:47:41 <crystal-cola> lol
09:48:29 <luite> crystal-cola: I hear that the next version is goign to be php, it will be so much better
09:49:07 <KirinDave> You're just bitter because haskell isn't webscale. ;)
09:50:51 <lispy> KirinDave: c'mon.  We support sharding.  What more do you need?
09:51:14 <KirinDave> lispy: Oh I'm sorry, you failed to answer the troll in the form of an image macro. Any other contestants?
09:51:50 <KirinDave> Actaully, as I learn Haskell, I'm trying to wrap my head around how I _would_ write real infrastructure in it.
09:52:13 <lispy> KirinDave: Yo dawg, I heard you like webscale so I put shards in your sharding.
09:52:37 <luite> lispy: hmm, sharding? which package or framework?
09:52:39 <KirinDave> I know O'Sullivan is going to town with that stuff, but I don't get how he gets there.
09:52:46 <lispy> KirinDave: I think haskell programs get written the same as in any language.  You put one leg in at a time...er something like that.
09:53:03 <KirinDave> Like, a normal app has threading, logging, metrics accumulation, usually multiple servers and outbound connections.
09:53:08 <KirinDave> All sorts of shit is flying around everywhere
09:53:28 <KirinDave> And then I see the chapter in RWH on monad transformers to get this shit to work together in the context of IO, and I go "lolwut?"
09:53:42 <KirinDave> You have to write everything remembering the order in which you put the MonadTs in.
09:53:48 <lispy> KirinDave: Read the XMonad source and architecture.
09:54:00 <KirinDave> lispy: Link please? Google...
09:54:14 <KirinDave> This?
09:54:15 <KirinDave> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
09:54:18 <luite> KirinDave: it's usually better to write your own if you have to use a huge monad stack otherwise
09:54:42 <Philippa> KirinDave: you don't have to remember the transformer order at all
09:54:49 <lispy> KirinDave: http://lmgtfy.com/?q=xmonad+source+tour
09:55:09 <KirinDave> lispy: See, right now google.com goes to fucking AT&T for me.
09:55:10 <luite> Philippa: well if you have multiple stacked state monads or something like that
09:55:10 <lispy> KirinDave: :)  I'll stop being condescending now.
09:55:14 <Philippa> rather than writing one from scratch, you can newtype it and write "lift to layer $foo" functions
09:55:14 <KirinDave> They've got some DNS error.
09:55:22 <lispy> KirinDave: You might want to fix your dns
09:55:28 <KirinDave> lispy: Not mine.
09:55:40 <KirinDave> lispy: See, I am not allowed to use any DNS but what my router provides.
09:55:54 <KirinDave> Yes. THat sucks. No, I have no other options. I'd rather not be reminded. Service call is in, they're fixing it.
09:55:54 <Philippa> luite: I do that regularly, the point is to abstract out the layer ordering so you don't care so long as the monad has the intended semantics
09:56:19 <KirinDave> Philippa: But then you need to go like lift lift lift lift whatever, right?
09:56:27 <Philippa> KirinDave: no, you go liftToWriter
09:56:31 <KirinDave> Philippa: The modern equivalent of drawing a square with a turtle.
09:56:35 <Philippa> liftToWriter happens to be lift lift lift lift lift
09:56:39 <KirinDave> Right
09:56:48 <KirinDave> Doesn't that sort of coding become brittle over time?
09:56:54 <Philippa> but liftToWriter could even be id
09:56:55 <KirinDave> Or does it not come up in practice?
09:57:23 <Philippa> it only gets brittle if you insist on writing everything in one monad. If you get practiced at 'bridging' between layers, it's staggeringly flexible
09:57:29 <luite> hmm, I personally don't really like larger stacks
09:57:50 <luite> but I'm ok with an "application" monad transformer over IO
09:58:04 <Philippa> I don't like /seeing/ larger stacks, but if that's what has the semantics I need, that's what I'll do. That said, usually you can go a stage further and wrap it up with the operations you really want instead of the base monadic ones
09:58:10 <Philippa> so "log" rather than tell, etc etc
09:58:14 <ClaudiusMaximus> anyone here with a ghc with integer-simple ?  also interested in fractals ?  want to test my code ?  http://claudiusmaximus.goto10.org/code/emndl/emndl-autotune-0.1.tar.gz
09:58:36 <Philippa> luite: if you don't have to manipulate it directly, what's not to like?
09:58:42 <KirinDave> Philippa: And that's robust in the face of changes over time, etc?
09:58:55 <Twey> KirinDave: google.com can be reached at 209.85.146.106
09:59:13 <KirinDave> Twey: Yeah, I was just editing my hosts right now. Ty tho
09:59:37 <Twey> Welcome
10:00:28 <Philippa> KirinDave: yeah, you've got an interface bulkhead 'tween what your monad client code does and what the monad is underneath at every level and you're not tied to any one monad
10:00:46 <luite> Philippa: with the right "accessor" functions it's not that bad, but I'd be wary about performance
10:01:00 <Philippa> having code spread about running in different monads (all built on IO) starts to bear an interesting relationship to OO, even
10:01:17 <Philippa> er, resemblance. I haven't cranked out what the formal relationship is yet ;-)
10:01:29 <KirinDave> I think the problem is so much code I see in haskell is not what I'd call production code.
10:01:34 <KirinDave> It logs to stdout, for example
10:01:36 <Philippa> but you can run "local logs", things like that
10:02:36 <luite> KirinDave: yes it's also difficult to see which hackage packages are more production quality. the "Stability" property isn't of much help
10:02:39 <Philippa> yeah, you still need for a logging infrastructure to exist. You have to decide how you're actually doing things. And the wiring's a little bit more complex than in an impure language. It's abstractable once you have a strategy though - and you can abstract out most of the details of a given strategy too
10:02:39 <KirinDave> As much as I get angry at the endless poopsoup of java log frameworks, it's pretty fincredible that you can just say, "Yeah log here, rotate like so, and use this file to figure that all out" and then suddenly you have a robust logging setup. I wonder what that's like in the haskell world.
10:02:47 <agent15> hello all. how can i put ghc 7 into haskell 98 mode? it seems to be rejecting n+k patterns
10:03:36 <Philippa> KirinDave: use concurrency to provide 'pipes' you can flush log data down to a logging thread, then off you go. At least, if the library exists. I know a number of people've done it - not really my area though
10:03:56 <Philippa> (that and Writer are the two interesting strategies, anyway)
10:04:14 <osfameron> can you get a function like "trace" to do logging?
10:04:18 <shapr> thewhitenoise: y0 y0
10:04:21 <osfameron> i.e. one that works in otherwise pure functions?
10:04:24 <KirinDave> Writer, in this case, seems like a fun way to run out of memory.
10:04:31 <Philippa> osfameron: yeah
10:04:41 <Philippa> KirinDave: that's a case of what you have demanding the logs on the other end
10:04:54 <thewhitenoise> shapr: thanks for the invite to the channel, man. excited to play with some haskell
10:05:02 <maurer_> agent15: Don't use n+k patterns?
10:05:14 <KirinDave> Well if "put" gets a message sent to another thread that is sinking things to storage and ditching the memory quickly, then it's fine.
10:05:16 <Philippa> (which is probably something that flushes 'em down the pipe to a logging thread, or something handing them off to something like writeFile)
10:05:16 <agent15> maurer_: don't be stupid
10:05:24 <shapr> thewhitenoise: Sure man, Haskell is awesome, I think you'll enjoy it.
10:05:41 <Philippa> KirinDave: lazy evaluation and all that - the Writer itself is abstracted against demand patterns, provide a suitable one
10:05:43 <ClaudiusMaximus> agent15: :set -XHaskell98   or {-# LANGUAGE Haskell98 #-} at the top of the file
10:06:01 <KirinDave> Philippa: I am not sure my haskell fu is great enough to do that, for now.
10:06:05 <Philippa> the problem's not "can you?", it's "where's the structure that helps me put it together right?"
10:06:08 <agent15> ClaudiusMaximus: thanks sir. that documented anywhere? i couldn't find it in the 7.0.2 documentation
10:06:37 <KirinDave> Philippa: Well the problem _could_ be a "can you" problem
10:06:44 <Philippa> okay, some pseudocode: do (log, result) <- runWriter foo; writeFile "log" log; -- rest of program
10:06:47 <KirinDave> Philippa: For example, until about 2005 "can you" for Ruby meant "no."
10:06:48 <ClaudiusMaximus> agent15: dunno, but "ghc --supported-languages" prints a whole lot of stuff
10:06:55 <mauke> http://haskell.org/ghc/docs/7.0.2/html/libraries/Cabal/Language-Haskell-Extension.html
10:07:06 <Philippa> yeah. Haskell has the tools to build it on, that much is certain
10:07:09 <KirinDave> Philippa: The system implementation matters.
10:07:28 <Philippa> which system?
10:07:38 <Philippa> do you mean the logging system, or the one it's built on top of?
10:07:50 <shapr> I like Ruby's object model, it's really better than Python's object model.
10:08:06 <shapr> I don't much like the explicit END I have to add in Ruby code, but that's personal preference.
10:08:15 <Philippa> shapr: Python's is barely any better than Perl's
10:08:23 * shapr shrugs
10:08:30 <shapr> At least I'm familiar with Python's object model :-)
10:08:40 <osfameron> mostly if you're doing OO in Perl you'll be using Moose in any case
10:08:47 <Philippa> Perl's is "anything that looks like I can do message lookup" - most objects are hashes
10:09:09 <Philippa> KirinDave: I'm not trying to be funny, for what it's worth
10:09:13 <pmurias> Perl's OO model was inspired by python
10:09:18 <KirinDave> I do not think you are.
10:09:25 <osfameron> Philippa: only Perl's core OO is.  Moose is rather more capable (Smalltalk traits etc.)
10:09:43 <KirinDave> Philippa: I mean the runtime system itself
10:09:46 <Philippa> osfameron: greenspun :-)
10:09:58 <KirinDave> For example, you will never have very fast code on Io.
10:10:04 <KirinDave> It just isn't written that way
10:10:25 <Philippa> KirinDave: yeah. That's up to it: the concurrency system's in the same ballpark as Erlang
10:11:02 <osfameron> Philippa: that's a little unfair ;-)  it's a language extension, in a programming language.
10:11:27 <mauke> inspired by CLOS, sure
10:11:29 <Philippa> osfameron: ah, it's not just a library?
10:11:49 <mauke> libraries are language extensions
10:11:50 <Philippa> (if it's "embed a better OO system", then yes, it's greenspun)
10:11:57 <osfameron> mauke: yes, exactly
10:12:09 <Philippa> mauke: not in the same sense that fundeps are one, though
10:12:18 <mauke> isn't that a good thing?
10:12:19 <pmetzger> where in the haskell documentation would I find the type of "main"?
10:12:27 <mauke> that you can write an object system in the language itself, I mean
10:12:33 <pmetzger> (note that I'm not asking what the type is.)
10:12:41 <osfameron> Philippa: it turns out that Perl's object system requires very little "cleverness" to turn it into something useful
10:12:42 <Philippa> sure. Needing to isn't necessarily one, though
10:12:46 <osfameron> I think that's a good thing too
10:13:09 <Philippa> osfameron: sure, I'm guessing Moose is mostly a MOP on top of it?
10:13:19 <mauke> Philippa: does it count as greenspun if it's the same in lisp? :-)
10:13:36 <osfameron> Philippa: yeah, there's quite a well-defined MOP layer (which you could theoretically build other OO systems on top of, though the only real target is, I think, Moose)
10:14:06 <osfameron> mauke: is lisp an acceptable lisp? ;-)
10:14:12 <mauke> osfameron: no
10:14:27 <Philippa> mauke: well, Common Lisp specifies it as part of the 'language' in the sense that if you don't have it, it's not actually Common Lisp
10:14:35 <ClaudiusMaximus> pmetzger: in the report, probably?  http://www.haskell.org/onlinereport/modules.html second paragraph
10:14:42 <Philippa> how much of it's primitive is another matter, of course...
10:14:48 <pmetzger> thanks!
10:15:04 <Philippa> (how many object systems does Haskell have at last count?)
10:15:24 <osfameron> are the OO Haskell extensions worth looking at?
10:15:37 <osfameron> I had a quick look for them, wasn't sure if they were abandoned or not
10:19:23 <lispy> osfameron: they are not in use.  I'm reasonably confident they are abandoned
10:19:45 <danharaj> I am convinced that whoever designed the number types in Haskell did not care about linear algebra.
10:19:52 <lispy> osfameron: You can get the good bits of OO without using them anyway, IMO
10:20:23 <lispy> danharaj: they wanted something that brought in a bit of math but mostly would be reasonably familiar to people from other languages.  At least, I think that's the case.
10:20:41 <pmetzger> hrm. turning hoogle into a lookup keyword for my browser turns out to be a very good idea.
10:20:47 <beastaugh> that's why http://www.haskell.org/haskellwiki/Numeric_Prelude exists
10:20:51 <lispy> danharaj: what is your specific observation based on?
10:20:55 <osfameron> well, subtype polymorphism (if I got the terminology right) can be useful in some cases
10:20:58 <pmetzger> now I can just type "hoogle foo" in the URL box
10:21:03 <danharaj> lispy: well for instance. Defining Num instances for vectors forces you to define "fromInteger"
10:21:15 <ClaudiusMaximus> pmetzger: i use it so much that i just type "h foo" in the URL box
10:21:22 <danharaj> lispy: I just want to add vectors :(
10:21:37 <pmetzger> I have wikipedia set up as "wp", but I'll wait and see how much I use hoogle. :)
10:22:35 <danharaj> lispy: anyway. I've been hunting for a graphics oriented linear algebra package and I can't say I like the ones I've tried already (Vec and Vect). They both seem like they're trying too hard to do type gymnastics and all I want is a lightweight library. I have resigned to rolling my own.
10:22:46 <sm> what is usually the best "overall" figure for test coverage from a test coverage report ? expressions used, or top-level declarations used, or ?
10:22:49 <osfameron> danharaj: http://hackage.haskell.org/package/vector-space was what someone pointed me at earlier
10:23:11 <osfameron> which I used purely to be able to do:  (a,b) + (a,b) ... which I guess is overkill but hey
10:23:17 <jmcarthur> vector-space is pretty nice
10:23:20 <sm> I think expressions used
10:23:29 <osfameron> well, I only imported Data.NumInstances
10:23:35 <jmcarthur> it doesn't really provide much as far as operations though. mainly just some generic type classes
10:24:30 <danharaj> osfameron: good to know about. It also looks like overkill to me.
10:24:48 <pmetzger> question: given that the arguments to a program don't change during execution, why is getArgs an IO [String] and not a [String]?
10:25:24 <danharaj> My "perfect" vector library supports Float and Double vectors of dim 1, 2, 3, 4 and has efficient unboxed representations for them.
10:25:29 <mauke> pmetzger: good question
10:25:31 <ClaudiusMaximus> danharaj: i rolled my own once, was a bit boring, then I switched to Vec i think - my old horrific code is still here though: https://gitorious.org/polytopiary/reflex/blobs/master/Vector.hs
10:25:47 <jmcarthur> pmetzger: good catch! although i'm more bothered by the reverse situation. i don't like that things that are different from run to run are sometimes considered pure
10:26:01 <mauke> pmetzger: they're not actually constant, though, so I'd have preferred main :: [String] -> IO ()
10:26:25 <danharaj> pmetzger: They are not referentially transparent.
10:26:26 <ksf> pmetzger, because you can write to them.
10:26:30 <ksf> at least from the C side.
10:26:40 <jmcarthur> ah there's that too
10:26:50 <pmetzger> yes, but you can do all sorts of things in C code that violate the normal constraints
10:27:00 <pmetzger> you could reach in to the run time and modify a constant value...
10:27:03 <Lemmih> And from the Haskell side using withArgs.
10:27:11 <mauke> why does withArgs exist?
10:27:16 <danharaj> ClaudiusMaximus: I've tried to use Vec but when I make a type error I get like a page of indecipherable type erros :[
10:27:24 <ksf> pmetzger, if you wanted, for example, to get the args before some C lib messes with them.
10:27:48 <mauke> that would happen anyway
10:27:49 <ClaudiusMaximus> danharaj: yeah, that is a drawback - and annotating the types is nightmarish
10:27:59 <jmcarthur> the System.Info module makes me sad
10:28:05 <edwardk> danharaj: did you see roman's post about how to deal with efficient generic traversals of such short unboxed vectors?
10:28:14 <danharaj> edwardk: nope.
10:28:23 <pmetzger> I suppose I just have to accept things as they are, but it feels weird. I, too, would intuitively prefer main :: [String] -> IO ()
10:28:36 <edwardk> http://unlines.wordpress.com/2010/11/15/generics-for-small-fixed-size-vectors/
10:29:05 <pmetzger> btw, this brings up another question, how do I set the exit code for a haskell program running on unix?
10:29:14 <dcoutts> exitWith n
10:29:27 <edwardk> danharaj: i have some simple numeric types using that approach that i've used for some gpgpu stuff, but i don't have anything packaged
10:29:45 <osfameron> why doesn't haskell's main return Int ?
10:29:46 <pmetzger> that isn't in system.environment, where does it live? (I suppose I can ask hoogle)
10:29:53 <mauke> @index exitWith
10:29:53 <lambdabot> System.Exit
10:29:57 <pmetzger> osfameron: because it can do i/o...
10:30:01 <copumpkin> osfameron: it's horrible
10:30:10 <mauke> osfameron: did you mean: IO Word
10:30:16 <copumpkin> IO Word8
10:30:17 <mauke> well, Word8
10:30:37 <danharaj> edwardk: Thanks. I kind of recoiled when he started using type level naturals. I sincerely think this is overkill for any realistic use of such a library, at least in the domain I'm trying to play around in.
10:30:43 <mauke> _main :: [ByteString] -> [ByteString] -> IO Word8
10:30:46 <edwardk> osfameron: because what guarantee do you have that the system is posix'ish at all? and which Int?
10:30:57 <osfameron> heh, ok, fair enough
10:31:11 <mauke> edwardk: why, 0, exitSuccess, and exitFailure of course
10:31:19 <edwardk> danharaj: once you get past the initial reaction, it works well and importantly generates very efficient core4
10:31:46 <danharaj> edwardk: I'll read on and see. If I ever have to annotate the type of a vector, I'm going to toss it out the window like Vec :)
10:32:22 <edwardk> danharaj: he gives examples of using it with Complex Double for instance.
10:32:45 <edwardk> as in treating a complex double as a vector of 2 doubles
10:33:02 <pmetzger> ew! exitWith doesn't flush i/o other than stdout/stderr? how unfriendly...
10:33:31 <edwardk> pmetzger: let me get this straight. you are complaining because you forget to flush?
10:33:34 <mauke> really?
10:33:35 <pmetzger> I'm surprised, I would expect it would either flush nothing or flush everything...
10:33:41 <mauke> yeah, me too
10:33:53 <shapr> edwardk: o hey, is kata working?
10:34:07 <edwardk> shapr: pchiusano is hacking on it at the moment
10:34:10 <lispy> edwardk: so does that vector thing have a package on hackage?
10:34:12 <edwardk> shapr: not yet
10:34:19 <edwardk> lispy: not to my knowledge
10:34:22 <lispy> edwardk: (I only glanced at the blog post0
10:34:24 <shapr> edwardk: source repo online?
10:34:34 <edwardk> lispy: like i said, i stole the approach, but never packaged mine
10:35:00 <lispy> edwardk: gotcha
10:35:17 <edwardk> shapr: github/ekmett/kata is the one he cloned from but that one doesn't build iirc, too many changes to cmdargs, and the terminfo package explodes on a mac
10:35:22 <shapr> :-(
10:36:22 <edwardk> we are using bits and pieces of it at work though ;)
10:36:25 <danharaj> (+) and (*) really really should have been put in their own type classes. le sigh.
10:36:56 <copumpkin> LE STFU
10:37:24 <danharaj> :o
10:37:34 <copumpkin> :)
10:37:36 <jmcarthur> i pronounced that in a french accent
10:37:48 <jmcarthur> and sounded out STFU instead of deabbreviating it
10:37:51 <jmcarthur> it was awesome
10:38:03 <danharaj> What the hell is "fromInteger" supposed to be for vectors. Or signum.
10:38:07 <osfameron> danharaj: just rewrite your own Prologue!
10:38:16 <jmcarthur> danharaj: replicate and fmap signum, respectively
10:38:19 <jmcarthur> err
10:38:24 <jmcarthur> replicate n, for n = number of dimensions
10:38:26 <edwardk> danharaj: replicate. and signum is elementwise signum
10:38:36 <danharaj> fair enough.
10:38:44 <edwardk> that way when multiplied (elementwise) with elementwise abs it yields the original
10:39:12 <danharaj> I still contend that no one sane will ever use these functions in this context.
10:39:21 <edwardk> technically you want an MPTC to describe a metric-space-like construction, but that wouldn't be '98.
10:39:26 <jmcarthur> danharaj: you can lift any Num through Applicative if you are willing to ignore potentially stupid Show and Eq instances
10:39:49 <danharaj> jmcarthur: eh?
10:39:55 <jmcarthur> danharaj: i use fromIntegral with vectors a lot, actually
10:40:05 <danharaj> because you are a wizard
10:40:09 <edwardk> it lets you use '0' as a vector.
10:40:09 <danharaj> and wizards are not sane
10:40:12 <copumpkin> abracadabra
10:40:28 <edwardk> and that doesn't suck ;)
10:40:31 <jmcarthur> danharaj: (+) = liftA2 (+), (*) = liftA2 (*), abs = fmap abs, fromIntegral = pure . fromIntegral   ...  and so on
10:40:34 <pmetzger> do not meddle in the affairs of wizards. for you are crunchy, and good with ketchup.
10:41:01 <edwardk> pmetzger: usually works better with dragons. never met a cannibal wizard
10:41:02 <jmcarthur> danharaj: the fromIntegral definition lets me do scalar multiplication with literals easily, for one example
10:41:14 <pmetzger> edwardk: you haven't met enough.
10:41:15 <jmcarthur> v*3
10:41:28 <danharaj> jmcarthur: I define an operator (^*). I guess that may be considered uglier than lifting with fromIntegral
10:41:42 <jmcarthur> depends
10:42:02 <jmcarthur> fromIntegral of course only applies when you are using a literal (or, of course, converting from an integral)
10:44:49 <ryant5000> what are these SpecConstr warnings i've started seeing?
10:44:54 <ryant5000> i see a bug relating to them: http://hackage.haskell.org/trac/ghc/ticket/5125
10:45:02 <copumpkin> they're not important at all
10:45:08 <copumpkin> just random debug output iirc
10:45:41 <ryant5000> good to know
10:45:49 <ryant5000> but, out of curiosity, do you know what it means?
10:46:15 <danharaj> so hm, this is my first time encountering this error. I have an instance that looks like this: Floating a => Vector a. GHC says that the constraint is no smaller than the instance head. What does that mean and what am I thinking about wrong? Because this looks perfectly reasonable to me.
10:47:24 <cheater99> mauke: how do i do that?
10:47:45 <mauke> I got bored of trolling
10:48:35 <edwardk> ryant5000: using -fspec-constr all over your code?
10:49:08 <shapr> edwardk: Any idea when pchiusano will have a public kata repo?
10:50:00 <edwardk> ryant5000: spec-constr is an optimization that turns out to be really useful for stuff like stream fusion, etc. where you wind up calling the same function with known constructors, it allows you to inline that heap allocation away in many cases
10:50:02 <ryant5000> edwardk: no, actually, which makes the warning especially unexpected
10:50:21 <ryant5000> ah, that sounds quite useful
10:50:46 <cheater99> mauke: ?
10:50:51 <cheater99> mauke: i'm not trolling.
10:51:25 <crystal-cola> not trolling just trolling
10:51:26 <jmcarthur> i think -Odph enables that flag
10:51:45 <mauke> well, one of us was
10:51:47 <jmcarthur> -O2 might as well, now, but i'm leaning toward not
10:52:03 <edwardk> ryant5000: it can get noisy if there are too many cases for it to apply, but it should be fine. they are just warnings and are completely harmless
10:52:11 <cheater99> mauke: btw.. i was wondering if you have had any experience on using ghc with atom. are there any big disadvantages? things that ghc could be doing better?
10:52:22 <cheater99> atom as in intel atom for the target
10:52:37 <mauke> no idea
10:52:45 <jmcarthur> try it and see!
10:52:46 <mauke> I barely speak x86 asm
10:52:47 <edwardk> ryant5000: btw- long time no see ;)
10:52:58 <ryant5000> edwardk: yeah, i've been busy :P
10:53:29 <edwardk> ryant5000: so when can we get you down to boston haskell to give an ipwn status report? =)
10:53:33 <cheater99> mauke: who would be a good person to ask?
10:53:35 <ryant5000> pretty soon
10:53:39 <edwardk> sweet =)
10:54:13 <ryant5000> where are the meetings being held now? still at MIT?
10:54:35 <edwardk> just say when, and i'll set up a meeting. i have almost but not quite enough content to fill the next one, so have been looking for something half-hour ish
10:54:39 <edwardk> yeah
10:55:04 <ryant5000> ah, alright
10:55:27 <ryant5000> i'll let you know :)
10:55:31 <ryant5000> i should have something to talk about pretty soon
10:55:40 <edwardk> i've even gotten bored enough to start hacking on the iphone/ipad ;)
10:55:56 <pmetzger> hacking in objectionable c?
10:56:10 <edwardk> pmetzger: as little as possible, but sadly, yes.
10:56:22 <copumpkin> objectivist c
10:56:29 <ryant5000> haha
10:56:39 <pmetzger> no, objectivist C is the language you can only use if you promise never to use another language.
10:56:50 <pmetzger> because it is the one true language, and to use any other would be to be anti-life.
10:57:00 <ryant5000> edwardk: is there a decent binding lib these days?
10:57:02 <edwardk> pmetzger: but it is okay if you go and do so anyways, as long as your public policy is to never use another
10:57:16 <pmetzger> then again, apple's policies on the iphone/ipad sound rather like that...
10:57:31 <ryant5000> pmetzger: well, the prohibition on other languages was lifted a while back
10:57:35 <edwardk> ryant5000: i've mostly been playing with opencv and doing some headtracking for better immersive 3d
10:57:49 <pmetzger> it was? but they still don't allow flash...
10:57:54 <ryant5000> edwardk: cool; so not heavy use of Objective-C-based APIs
10:58:01 <ryant5000> pmetzger: yeah, i don't know; their relationship with Adobe is complicatec
10:58:03 <Jafet> I wouldn't allow flash.
10:58:05 <jmcarthur> they simply reworded it to be a bit more specific
10:58:21 <ryant5000> all i know is that Haskell is officially OK now :)
10:58:32 <edwardk> actually, flash is okay even, the flash -> obj c compiler is back on, etc.
10:58:33 <pmetzger> there is a haskell dev environment for the iphone?
10:58:48 <edwardk> pmetzger: yeah ryant5000 and company released one a while back but tis a bit dated
10:58:50 <ryant5000> pmetzger: indeed, produced by my company, iPwn Studios
10:58:56 <ryant5000> yes, it's quite dated
10:59:00 <ryant5000> GHC 6.10.4
10:59:26 <ryant5000> it's BSD3
10:59:37 <edwardk> iirc kmc did an android ghc port for them as well.
10:59:55 <ryant5000> indeed, though that's not quite finished yet
11:00:04 <edwardk> have you talked to him lately?
11:00:25 <pmetzger> I've played with using MacRuby a bunch, but it won't work on iOS, only OS X.
11:00:28 <ryant5000> on and off - i haven't heard back from him in a while
11:00:34 <edwardk> he was trying to get in touch with you a while back and sounded done.
11:01:07 <ryant5000> edwardk: yeah, i've sent him some emails since then; perhaps i'll try IRC instead
11:01:27 <edwardk> fair nuff
11:02:19 <ryant5000> anyhow, for anyone interested in trying it out, ghc-iphone is at http://projects.haskell.org/ghc-iphone/downloads/
11:02:45 <edwardk> right now i'm wrestling with the general dearth of decent 3d engines that support opengl es2 and which let me tune certain camera parameters. =/
11:02:57 <ryant5000> ah
11:03:11 <ryant5000> well, OpenGL on hackage works
11:03:20 <ryant5000> just don't accidentally use an unsupported API :P
11:03:27 <edwardk> as i'm not in a hurry to add yet another 3d engine to my resume ;)
11:03:30 <ryant5000> haha
11:04:36 <djahandarie> edwardk, make dolio present something for the last 30 minutes :)
11:04:37 <ryant5000> edwardk: well, there is definitely a need for some more haskellish graphics engine
11:05:00 <ryant5000> i always need to take a shower after writing OpenGL code
11:05:29 <jmcarthur> even low level opengl isn't so bad once you write a thin wrapper
11:05:52 <jmcarthur> like, i'll complain about it every day, but still not as bad as it sometimes appears
11:06:01 <ryant5000> jmcarthur: well, it's a very well-designed library
11:06:07 <ryant5000> as far as standardized things go
11:06:13 <edwardk> ryant5000: there is a proposal for better opengl bindings for this summer of code, we'll have to see if it gets approved
11:06:16 <jmcarthur> err... for some definition of "well designed" ;)
11:06:17 <ryant5000> but it's just so violently stateful
11:06:37 <ryant5000> jmcarthur: haha, well, compare it to other things standardized through that sort of process
11:06:43 <ryant5000> at least it gets the job done more often than not
11:06:44 <jmcarthur> i don't even mind the statefulness except where it hinders my attempts to make a pure wrapper
11:06:58 <Jafet> OpenGL is a thin wrapper to the hardware
11:07:14 <jmcarthur> Jafet: if only it was really all that thin!
11:07:31 <Jafet> Too thin for me
11:07:41 <ksf> Jafet, to the graphics driver.
11:07:42 <jmcarthur> most drivers have very unpredictable optimizers
11:07:47 <edwardk> the real issue is i don't really care about most of the random opengl level stuff, its all about animation, boning, physics, collision, that is what makes the difference between a rendering engine like ogre and something more like the unreal sdk or unity.
11:07:52 <ksf> jmcarthur, well, don't use intel.
11:08:20 <edwardk> jmcarthur: the 'slow path' nonsense differing for every gpu is somewhat maddening, yes.
11:08:20 <jmcarthur> ksf: that's a pretty good rule except when you're targetting the lowest denominator :\
11:08:23 <ksf> edwardk, we do have bullet bindings, don't we?
11:08:55 <ksf> jmcarthur, well, people with intel chips shouldn't expect to get any kind of quality *and* decent performance, at the same time.
11:09:26 <jmcarthur> heck, i can't even use uniform buffers with my intel driver :(
11:09:40 <ksf> jmcarthur, anyways, the lowest common denominator is a 3dfx Monster 3d.
11:09:44 <jmcarthur> or floating point render targets :(
11:09:47 <ksf> or rather, software mesa on a c64
11:10:01 <danharaj> the lowest common denominator is a piece of paper and some crayons.
11:10:14 <edwardk> bullet is fine for dealing with the ragdoll bits, but it is still 6 months of work to go from that to something that deals well with blending animation sequences, etc. if you don't aspire to any greater notion of collision than hamster ball, i guess that works ;)
11:10:26 <ksf> well, gallium-llvm shouldn't be exactly *slow* on a decent quadcore.
11:10:41 <crystal-cola> whab touab analytic data type theory?
11:10:58 <jmcarthur> is gallium-llvm a software renderer?
11:11:19 <ksf> yes and no.
11:11:40 <jmcarthur> i mostly understand what the gallium project is about, but i don't know all the little offshoots and subprojects and stuff
11:11:55 <ksf> it compiles glsl down to an intermediate driver language, that then is send either to the gfx card (vendor-independent) or compiled to x86
11:12:14 <ksf> ...or what counts as glsl or cuda inside of mesa.
11:13:02 <ksf> that is, it's a jit compiler, not a vm.
11:13:37 <jmcarthur> ah
11:15:01 <shapr> @hackage search llvm
11:15:01 <lambdabot> http://hackage.haskell.org/package/search llvm
11:15:05 * shapr shrugs
11:15:26 <jmcarthur> good job lambdabot 
11:17:54 <danharaj> someone sanity check me. I have a list of lists of numbers of equal length, and I want to sum up all the 1st elements, then all the 2nd elements, etc. and return that list: foldl (zipWith (+)) (repeat 0) xss?
11:18:35 <jmcarthur> danharaj: or you could transpose it and map sum it
11:18:45 * danharaj stabs his own eyes
11:18:50 <jmcarthur> lol
11:19:03 <shapr> :t transpose
11:19:03 <lambdabot> forall a. [[a]] -> [[a]]
11:19:05 <danharaj> I really really should just read the entire prelude once at least.
11:19:15 * hackagebot archlinux 1.0 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-1.0 (PeterSimons)
11:19:18 <shapr> danharaj: Yah, it'll totally save you hours of thinking up your own versions.
11:19:31 <shapr> oboy! Peter Simons is writing Haskell again!
11:19:35 <shapr> I wonder how postmaster is doing?
11:19:39 <jmcarthur> woot
11:19:46 <danharaj> on the other hand, playing combinator gymnastics must be making me better at functional programming in some way... maybe...
11:19:51 <hpc> :t transpose `asTypeOf` flip
11:19:51 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a1 -> b'
11:19:51 <lambdabot>       Expected type: [[a]]
11:19:51 <lambdabot>       Inferred type: [a1 -> b]
11:19:55 <ryant5000> danharaj: i find that guessing type signatures and putting them into hayoo is fairly effective, too
11:20:00 <hpc> er
11:20:06 <hpc> :t flip id
11:20:07 <lambdabot> forall a b. a -> (a -> b) -> b
11:20:09 <shapr> howdy ryant5000, how's iPwn going?
11:20:16 * hackagebot cabal2arch 1.0 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-1.0 (PeterSimons)
11:20:29 <pmetzger> I plan on reading the whole prelude at some point when I'm feeling a bit more comfortable with the language overall. I'm still not there.
11:20:43 <shapr> pmetzger: Eh, if you can write basic Haskell at all the Prelude is good reading.
11:20:46 <ryant5000> shapr: hey :) it's going well!
11:20:53 <shapr> pmetzger: Though I enjoyed the Hugs Prelude way more.
11:20:58 <pmetzger> probably, but it isn't yet my highest priority...
11:21:01 <shapr> ryant5000: awesome!
11:21:18 <pmetzger> why is the Hugs prelude more interesting?
11:21:31 <hpc> shapr: also if you can tolerate oodles of pragmas
11:21:36 <shapr> pmetzger: Last I checked, it's a single file and nothing is particularly optimized.
11:21:54 <hpc> lots of #ifdef _GHC
11:22:23 <pmetzger> is there a reference version in the standard that isn't optimized?
11:23:56 <shapr> pmetzger: I don't know... would be nice if it doesn't already exist.
11:24:19 <pmetzger> that's another thing for the list: someday, read the standard
11:25:50 <crystal-cola> haskell = ?
11:26:10 <shapr> crystal-cola: awesome!
11:26:21 <companion_cube> haskell = haskell
11:26:27 <mauke> how bottom
11:26:40 <mauke> .oO( nice bottom! )
11:26:52 <companion_cube> nice ⊥ ?
11:28:04 <shapr> tail call == booty call?
11:29:55 <ion> nice \bot
11:33:11 <Nolrai23> Is IOArray a good module for implementing a hastable. (for a Transposition Table)
11:33:41 <mauke> why would you implement your own hashtable?
11:35:01 <ksf> last time I tried, I didn't manage to be faster than the shootout
11:35:04 <ksf> ...which is a shame
11:36:31 <Nolrai23> mauke: is there a better option?
11:36:44 <mauke> Nolrai23: ... yes?
11:36:54 <mauke> it is: don't implement your own hashtable
11:37:55 <Nolrai23> mauke: and use what?
11:38:15 <mauke> well, depends on the operations you need
11:38:24 <mauke> you could use a hashtable or a lookup tree or whatever
11:40:32 <Nolrai23> Well I need fast lookup and fast replace/insert.  I also need a way to keep it from growing past a cirtian size.  Where would I find haskell hashtables.
11:41:25 <mauke> did you try Data.Map?
11:42:50 <Philippa> yeah, a quick wrapper around Data.Map ought to do the trick nicely enough
11:42:53 <jmcarthur> Nolrai23: there's Data.Map, Data.IntMap, Data.HashTable (ew), unordered-containers, and others
11:43:44 <jmcarthur> Data.IntMap was included because if you have a cheap mapping to Int you can do fast lookups with it. unordered-containers is basically like IntMap but streamlined for hashing
11:43:49 <ksf> ...it primarily depends on what keys you use.
11:44:05 <ksf> don't forget tries
11:44:18 <companion_cube> IntMap is based on Tries, right ?
11:44:22 <ksf> yep
11:44:23 <jmcarthur> yeah. tries are great, but don't usually have the kind of speed you would hope for :\
11:44:32 <jmcarthur> well yeah, IntMap is a fast specialized trie
11:44:46 <Nolrai23> I will look, any of those have hasle free ways to limit how big they get? 
11:44:48 <companion_cube> patricia trie, iirc
11:45:00 <ksf> Hashing to an IntMap isn't a bad idea
11:45:09 <jmcarthur> Nolrai23: everything suggested is trees instead of arrays, so resizing isn't a problem at all
11:45:09 <ksf> unless your keys are really long
11:45:18 <ksf> in which case you definitely want to use a trie
11:45:49 <Philippa> Nolrai23: the obvious way to limit size is just to write a lightweight wrapper around the accessors. Shouldn't take you more than five minutes, good enough?
11:46:44 <Nolrai23> Philippa: Just have it delete a random spot when ever you insert something? (0nce its at max size that is)
11:46:46 <ksf> also, what do you mean with "limit size"? refuse to insert new elements, or throw out old ones?
11:47:00 <jmcarthur> why delete stuff?
11:47:12 <Philippa> Nolrai23: oh, I thought you just wanted insertion to fail
11:47:17 <Philippa> jmcarthur: cache, I'm guessing
11:47:17 <jmcarthur> Nolrai23: i'm curious. why do you need to keep it below a certain size?
11:47:46 <ksf> a PSQ?
11:47:52 <Philippa> Nolrai23: what do you want to happen when the structure's full?
11:48:08 <Philippa> (I'd expect the default, unless told otherwise, to be for insertion to fail and tell me it's failed)
11:48:30 <Nolrai23> Philippa: I want it to make room for the new data, new stuff is going to be used a lot more.
11:49:04 <ryant5000> Nolrai23: perhaps you're looking for this: http://hackage.haskell.org/package/lrucache
11:49:56 <Philippa> Nolrai23: okay, that's not a complete spec though - any ideas about how you want it to make room?
11:50:16 <Philippa> I mean, is it okay for it to throw the whole thing away and start from an empty map each time? :p
11:51:30 <Nolrai23> I would like it to act as a cash. Keep recent stuff, though it doesn't have to be to presise, if some old stuff says a while thats fine.
11:51:59 <jmcarthur> Nolrai23: that lrucache package ryant5000 linked to sounds ideal for you then
11:52:26 <FUZxxl> @hackage compiler98
11:52:27 <lambdabot> http://hackage.haskell.org/package/compiler98
11:52:36 <Nolrai23> Yep it does.
11:52:41 <Nolrai23> Thanks All!
11:52:54 <Philippa> Nolrai23: in future, it's much better to ask for cache implement...
11:52:56 <Philippa> bah
11:56:29 * ksf fears data structures 101 isn't taught, anymore.
11:56:36 <dankna> I fear you may be right
11:57:10 <ksf> back in my days, I *invented* data structures to fit my algorithm
11:57:13 <ksf> ...more or less.
11:57:20 <luite> uphill, right?
11:57:44 <Jafet> It's the third millennium. SQL alleviates all this data-structures nonsense.
11:58:06 <ksf> the most massive overkill was a combined doubly-linked binary tree/linked list, totalling 5 pointers per node.
11:58:06 <luite> ksf: but were your data structures webscale?
11:58:07 <DevHC> SQL can scrape the shit off my asstube walls
11:58:08 <ryant5000> ksf: in the real world, everyone seems to use nothing but "hashes"
11:58:10 <Jafet> Let's not dawdle on the fiddly details of how data is stored – let the experts do it.
11:58:21 <ksf> ...used to generate huffman codes.
11:59:03 <ksf> thinking about it, it was massive overkill. could've recursed down it and saved a lot of pointers.
11:59:09 <ksf> but then, it was c.
12:03:52 <luite> caching pure functions in haskell is annoying imho, I've used unsafePerformIO and lrucache, but there doesn't seem to be a proper, neat, way, while keeping things pure
12:04:21 <pmetzger> There is a reasonable argument to be made that most problems don't need exotic data structures. "The Practice of Programming" has a nice section on that.
12:04:56 <luite> having automatic memory management reduces the need for lots of specialized data structures
12:07:58 <cheater99> hey guys, why doesn't this "work" ? http://hpaste.org/45954/typejuggling
12:09:08 <crystal-cola> cheater99: uh
12:09:10 <crystal-cola> what
12:09:17 <rootnode> lazy eval?
12:09:25 <crystal-cola> why would you expect 5 + 1 to be 6>
12:09:34 <crystal-cola> you just defined it to be 51
12:09:48 <rootnode> define proper types
12:09:49 <cheater99> i know. i want it to be 6. how do i get it to be 6?
12:09:55 <crystal-cola> use addition
12:10:00 <rootnode> g :: Int -> Int
12:10:34 <cheater99> what if my objective is not to have to define the type for f or g?
12:10:41 <luite> having 51 apples is clearly better than having 6
12:10:50 <cheater99> not if they're rotten
12:10:55 <cheater99> :(
12:10:59 <TheZimm> heh
12:11:01 <TheZimm> true
12:11:02 <luite> yeah that's true
12:11:03 <copumpkin> cheater99: so you want (+) to be both what you said it is and what you hid from the file explicitly at the beginning?
12:11:12 <cheater99> copumpkin: yes
12:11:24 <copumpkin> then make a typeclass
12:11:28 <copumpkin> but that's fucking ugly :P
12:11:30 <cheater99> how?
12:11:30 <copumpkin> (behavior)
12:11:33 <cheater99> aha
12:11:34 <crystal-cola> it's also stupid
12:11:56 <copumpkin> I agree
12:11:58 <Jafet> You can't use the typeclass, anyway, since the instances overlap
12:12:07 <Jafet> ...but there are further ways around that
12:12:34 <crystal-cola> "how do I call something something else and still have it be the other thing"
12:13:31 <jmcarthur> foo = bar
12:13:47 <cheater99> alright
12:14:10 <Jafet> Sufficiently advanced magic is indistinguishable from madness.
12:16:15 <cheater99> Sol Robeson: This is insanity, Max.      Maximillian Cohen: Or maybe it's genius. 
12:18:00 <cheater99> hey guys.. i am performing cabal install cabal-install, but it's failing without telling me why... basically this is what it says: "cabal: Error: some packages failed to install:    "
12:18:16 <cheater99> then it says the exception was ExitFailure 9
12:18:59 <cheater99> what do i do? i have skimmed the stderr but can't find anything except for warnings (warnings aren't bad, right?)
12:19:10 <cheater99> they were warnings about functions that are declared but not used.
12:23:32 <cheater99> here is the complete log: http://hpaste.org/45956/cabal_error
12:25:20 <acowley> Perhaps upgrading cabal-install is not the path of least resistance
12:26:14 <acowley> I've never done it on Windows. Just install the newest HP, then cabal-install something with a lot of your favorite dependencies, then do something else for a little while
12:27:00 <parcs> i don
12:27:18 <parcs> i don't think you're supposed to upgrade cabal-install with cabal
12:27:37 <Heffalump> yes, you are
12:28:13 <acowley> you can, but it is not uncommon to encounter troubles
12:28:17 <tommd> cabal update ; cabal install cabal --reinstall ; cabal install cabal-install
12:28:33 <Heffalump> cabal install Cabal ?
12:29:31 <tommd> cabal isn't so picky about capitalization.
12:30:28 <kwantam> > take 4 $ intersperse "install" $ repeat "cabal"
12:30:29 <lambdabot>   ["cabal","install","cabal","install"]
12:31:14 <kwantam> use ghci to produce a commandline that will cause cabal to install ghci
12:31:21 <kwantam> I'm pretty sure everything will work out in the end
12:31:29 <kwantam> you just have to really believe in your base case
12:31:35 <acowley> metacircular HP
12:31:36 <saati> what happens if you try to print out an infinite list with lambdabot?
12:31:44 <mauke> > [0 ..]
12:31:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:31:49 <mauke> that
12:32:08 <tommd> Sometimes the earth collapses into a black hole.  Very rarely though.
12:32:34 <mauke> > fix (("what happens if you try to print " ++) . show)
12:32:35 <lambdabot>   "what happens if you try to print \"what happens if you try to print \\\"wh...
12:32:39 <acowley> I heard that's what knocked out the EC2 availability zone
12:33:38 <saati> infinite lists took down reddit?
12:33:46 <kwantam> fix (("I wonder if EC2 can handle... " ++) . show )
12:33:50 <kwantam> > fix (("I wonder if EC2 can handle... " ++) . show )
12:33:51 <kwantam> even
12:33:52 <lambdabot>   "I wonder if EC2 can handle... \"I wonder if EC2 can handle... \\\"I wonder...
12:34:08 <tommd> EC2 should have been using mueval I guess.
12:34:18 <kwantam> saati, it seems somehow appropriate that such a thing would happen
12:36:02 <acowley> lambdabot is responsible for most of the character accounts on reddit
12:37:12 <tommd> elitistpumpkin?
12:38:01 <elitist> are you worthy of the answer?
12:40:42 <aristid> no he's not.
12:40:44 <tommd> Are you questioning my standing? I won't respond to such an absurdity.
12:41:08 <aristid> elitist: you're only allowed to answer to ddarius.
12:42:22 <mikmorg> hi all
12:43:18 <dons> hi mikmorg. welcome
12:43:36 <mikmorg> i'm brand new to this language, and i'm trying to do something simple that i haven't been able to figure out yet; it's driving me nuts. thought i'd join here :)
12:43:48 <dons> its a good place to ask questions :-)
12:43:49 <tommd> mikmorg: ask away
12:43:51 <mauke> :t join ?here
12:43:52 <lambdabot> forall (m :: * -> *) a. (?here::m (m a), Monad m) => m a
12:43:58 <mikmorg> heh
12:44:15 <SirFrancisDrake> hey there. How does ghci make definition for -, given definition for +? I'm experimenting with Num class and keep getting some strange phenomenon.
12:44:20 <mikmorg> so as a starter, i'm trying to create a list of line lengths of a file
12:44:34 <mauke> SirFrancisDrake: a - b = a + negate b
12:44:35 <mikmorg> this isn't working because of the IO type: map length $ fmap lines $ readFile "/proc/i
12:44:59 <dons> right. things that have side effects are treated a bit specially in haskel
12:45:03 <mauke> fmap (map length . lines)
12:45:08 <mikmorg> yeah;
12:45:10 <kwantam> mikmorg: you have to compose this kind of thing in the IO Monad
12:45:22 <mikmorg> ok,
12:45:30 <mikmorg> so the whole function has to be within IO?
12:45:39 <dons> main = do s <- readFile "/proc/i"; print . map length . map lines $ s 
12:45:48 <dons> well, you can call pure functions all your want
12:45:53 <kwantam> you can imagine creating a pure function that will give you a list of lengths of strings in a list
12:45:58 <dons> but reading a file will be in IO.
12:46:04 <kwantam> but yes, it has to be composed inside IO with the file read
12:46:17 <edwardk> mikmorg: if you want something more imperative looking: do x <- readFile "/proc..."; return $ map length (lines x) -- then after using haskell for a while you'll intuitively replace that with fmap (length . lines) $ readFile ...
12:46:21 <mikmorg> hmm
12:46:38 <mikmorg> ok so i'm aware of the 'do' method, i suppose,
12:47:12 <edwardk> mikmorg: yes, effectively the 'IO' there says that the meaning can change over time.
12:47:22 <mikmorg> hmm
12:47:29 <SirFrancisDrake> mauke, thanks. And what does negate depend upon?
12:47:32 <edwardk> so it describes an 'action' that will yield a list of lengths, rather than a list of lengths per se
12:47:34 <dons> it will be worth your time to read a quick tutorial on haskell io and monads;  http://learnyouahaskell.com/input-and-output 
12:47:39 <mikmorg> ah ok
12:47:46 <mauke> SirFrancisDrake: negate x = 0 - x
12:47:48 <mikmorg> so i need to pull out readFile from my function to keep it pure
12:47:55 <edwardk> yeah
12:47:57 <cheater99> hey guys, i'm having a problem installing ghc 7 from binary, the configure script seems to be broken
12:48:04 <cheater99> i'm on ubuntu 10.04
12:48:11 <edwardk> you could for instance make a function that just performed the map length . lines -- and that is a pure function
12:48:55 <cheater99> # ./configure                     checking for path to top of build tree... ./configure: line 1792: utils/ghc-pwd/dist/build/tmp/ghc-pwd: No such file or directory                            # [ -d utils/ghc-pwd/dist/build/tmp/ghc-pwd ]; echo $?                 1
12:49:11 <edwardk> and then you could fmap that over the IO action that reads the file, taking the IO action that reads your file, to a new IO action that reads the file then gives you the lengths of all the lines in it
12:49:15 <SirFrancisDrake> mauke, is that a circle definition? Can't do 0 - x without knowing -
12:49:18 <mee> SirFrancisDrake: http://www.haskell.org/tutorial/numbers.html might be useful reading here
12:49:25 <mauke> SirFrancisDrake: yes
12:49:27 <ion> I like the similarity between f $ pureFunctionThatReturnsAString, f <$> impureFunctionThatResultsInAString. I tend to use <$> for fmap.
12:49:36 <mauke> SirFrancisDrake: you're supposed to define negate or - or both in your instance
12:49:46 <edwardk> ion: likewise
12:50:21 <mikmorg> aha.
12:50:30 <acowley> fmap is nice for compositions with a partial application
12:50:31 <cheater99> oh and also     [ -f utils/ghc-pwd/dist/build/tmp/ghc-pwd ]; echo $?       gives me 0
12:50:35 <cheater99> (of course)
12:50:37 <elitist> ion: well
12:50:42 <SirFrancisDrake> mauke, oh. I see. Thanks. For some reason ghci doesn't mind leaving negate and - aside, but hangs with stack overflow, when asked to deduct.
12:50:43 <elitist> ion: $ is more like =<<
12:50:53 <SirFrancisDrake> mee, thanks. I'll RTFM. Sorry.
12:50:56 <kwantam> mikmorg, are you familiar with the operator >>= ? I find it's pretty intuitive to think about the actual sequence of operations going on, which >>= illustrates more clearly (to me) than "do"
12:50:58 <copumpkin> although I guess it depends how you see it
12:51:32 <mauke> SirFrancisDrake: yeah, because they're defined. it's just an infinite recursive loop
12:51:59 <kwantam> mikmorg, e.g.,
12:52:03 <mikmorg> kwantam: Yeah, i've seen it
12:52:05 <cheater99> no ideas on the ghc 7 configure script bug? :(
12:52:19 <kwantam> readFile "/etc/passwd" >>= \x -> return $ map length $ lines x
12:52:40 <kwantam> your pure operation becomes bound inside the monadic operations, >>= and return
12:52:44 <litb> hello all
12:52:55 <edwardk> @do readFile "/etc/passwd" >>= \x -> return $ map length $ lines x
12:52:55 <lambdabot> do { x <- readFile "/etc/passwd"; return $ map length $ lines x}
12:53:13 <mauke> @pl readFile "/etc/passwd" >>= \x -> return $ map length $ lines x
12:53:13 <lambdabot> (map length . lines) `fmap` readFile "/etc/passwd"
12:53:14 <mikmorg> oh so >>= basically removes the IO?
12:53:22 <mauke> mikmorg: locally, yes
12:53:23 <kwantam> ehhhh
12:53:26 <kwantam> yeah
12:53:27 <acowley> mikmorg: it lets you peek inside
12:53:31 <mikmorg> aha
12:53:32 <mauke> mikmorg: in the bigger picture you're still trapped in IO
12:53:33 <edwardk> mikmorg: kinda
12:53:35 <ion> :t (>>=)
12:53:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:53:37 <kwantam> "removes the IO" kind of depends on your point of view
12:53:38 <mikmorg> right that makes sense, totally
12:53:40 <litb> it removes it for the action but then wraps the result in IO again
12:53:41 <mikmorg> thanks
12:53:41 <edwardk> mikmorg: IO a -> (a -> IO b) -> IO b
12:53:47 <mikmorg> is return required/
12:53:48 <kwantam> from another frame of reference, it pushes the pure stuff into IO
12:53:53 <mauke> I've been thinking about this
12:54:00 <kwantam> yes
12:54:01 <edwardk> it takes one IO action, and a function from its results to another IO action, then chains those actions together sequentially
12:54:06 <mauke> "monads as magic chests from zelda"
12:54:10 <kwantam> return is what causes your pure function to put something back into the monad
12:54:16 <ion> The second parameter (a -> IO b) needs to return an IO b. return is one way to do that.
12:54:17 <mikmorg> got it now
12:54:21 <mikmorg> sweet
12:54:23 <edwardk> >>= is more general and works for other monads than just IO, but that is the intuition for the IO monad
12:54:48 <edwardk> on the other hand, fmap for IO looks like (a -> b) -> IO a -> IO b
12:55:02 <acowley> Is there a syntactically light way to tell GHC that virtually everything in a module is inlinable? :/
12:55:10 <dons> nope
12:55:14 <mikmorg> is there something more syntatically ... fluid than doing the curry thing and return?
12:55:24 <mikmorg> ie. do i need \x?
12:55:26 <edwardk> it takes a pure function from a -> b, and an IO action, and yields a new action, that will run the IO action given, then apply the pure function to the result
12:55:45 <mikmorg> hmm
12:55:57 <kwantam> mikmorg, yes
12:56:03 <acowley> I kind of wish we could tell GHC to compile a given set of modules in one unit
12:56:04 <kwantam> you can use something like liftM
12:56:08 <ion> fmap f m is equivalent to m >>= return . f (assuming a sane Functor instance for the monad)
12:56:12 <edwardk> mikmorg: map length . lines <$> readFile "/proc/i"     is the same as fmap (map length . lines) (readFile "/proc/i")
12:56:24 <acowley> so it could do cross-module inlining aggressively between coupled modules
12:56:34 <mikmorg> sweet
12:56:37 <kwantam> something like readFile "/etc/passwd" >>= liftM (map length . lines)
12:56:38 <litb> can ghc not compile stuff to llvm code?
12:56:41 <mikmorg> glad i finally decided to come here
12:56:48 <litb> i'm trying ghc --help but it hasn't an llvm option
12:56:51 <kwantam> not quite that but
12:56:55 <acowley> litb: -fllvm
12:57:11 <edwardk> kwantam: liftM (map length . lines) (readFile "/etc/passwd")
12:57:16 <kwantam> yes
12:57:19 <kwantam> more like that
12:57:36 <edwardk> liftM, fmap and <$> are interchangeable for IO
12:57:43 <ion> liftM is the same as fmap (assuming a sane Functor instance for the monad)
12:58:02 <qwr> hm. <$> comes from what?
12:58:03 <mikmorg> ahh i was thinking they were all very similar
12:58:10 <ion> Control.Applicative
12:58:17 <edwardk> Control.Applicative or Data.Functor
12:58:21 <qwr> ok
12:58:54 <kwantam> you gotta be func(tor)y to use <$> baby
12:59:26 <carpi> Hi. The statement "himm (x:xs) = x" produces an error. Could someone please tell me why?
12:59:37 <mauke> carpi: where?
12:59:43 <edwardk> carpi: are you just trying to type that into ghci?
13:00:00 <carpi> no.. in a seperate hs file
13:00:00 <ion> carpi: Let me look up the error you got from my crystal ball and i’ll come back to reply, a moment…
13:00:09 <kwantam> :t \(x:xs) -> x
13:00:10 <lambdabot> forall t. [t] -> t
13:00:21 <edwardk> carpo: then my next question is are you trying to apply it to [] ? =)
13:00:25 <mauke> carpi: what error?
13:00:25 <Lemmih> carpi: We need more information.
13:00:29 <kwantam> are you sure you're not applying it to an empty list? :)
13:00:49 <carpi> sorry.. one moment.. i will put on paste bin... both code and error. 
13:03:00 <carpi> oh. Here it is pastebin.com/q4BQeT0W
13:03:38 <carpi> am i doing something wrong?
13:03:57 <mikmorg> thanks for your help
13:03:58 <edwardk> carpi: the type of himm is [[a]] -> [a]
13:04:21 <litb> acowley: oh. hm, i'm trying -fllvm -S, but it outputs machine assembler -.- i expected LLVM IR. am I doing something wrong?
13:04:32 <edwardk> you're applying it to a list of numbers, so it is looking for Num instance for a list
13:04:33 <rostayob> carpi: you're returning an empty list if the list is empty. i don't think that's your intention
13:05:00 <edwardk> himm [] = [] -- means that the result type is a list.
13:05:16 <edwardk> himm (x:xs) = x -- requires that the _elements_ of your list argument be lists.
13:05:22 <carpi> rostayob: im following the learn u a haskell for good resource and just trying out a few things
13:05:30 <litb> i thought   himm [] = []  is a pattern match definition always yielidn gan empty list?
13:05:57 <edwardk> litb: given an empty list it yields an empty list, yes.
13:05:57 <carpi> litb: only when the argument passed to himm is an empty list
13:06:01 <acowley> litb: how about something like -keep-llvm-files
13:06:17 <litb> acowley: how can I explore those options?
13:06:17 <edwardk> carpi: in ghci type:    :type himm
13:06:24 <acowley> litb: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/flag-reference.html
13:06:33 <danharaj> yay!
13:06:38 <danharaj> I have a simulation of the three body problem
13:06:39 <acowley> carpi: or just :t himm
13:06:39 <carpi> edwardk: its says [[a]] -> [a]
13:06:41 <danharaj> it is fun to watch
13:06:43 <rostayob> carpi: the thing is that, the himm (x : xs) = x part returns the head of the list. himm [] = [] returns an empty list. so himm must take al list of lists to be consistent 
13:06:45 <danharaj> I am so pleased with myself right now.
13:06:49 <carpi> :) now i think i know why its giving error
13:06:51 <litb> acowley: ohh thanks!
13:06:56 <edwardk> carpi: exactly. now, you are passing it arguments that don't comply =)
13:07:17 <carpi> thats because.. himm returns only a list.. not single variable
13:07:25 <edwardk> carpi: yep
13:07:33 <edwardk> you could use himm (x:xs) = [x]
13:07:58 <rostayob> carpi: that's why if you try to do head [] you get a runtime error
13:08:00 <edwardk> then you'd get [a] -> [a] -- where it returns the list consisting of the first element of the list
13:08:14 <edwardk> ... if present, or the empty list if not
13:08:16 <acowley> danharaj: congrats!
13:08:28 <edwardk> of course, then, i'd recommend himm = take 1
13:08:34 <edwardk> > take 1 [1,2,3]
13:08:35 <lambdabot>   [1]
13:08:50 <aristid> > drop 1 [1,2,3]
13:08:51 <lambdabot>   [2,3]
13:09:05 <acowley> edwardk: or you'd recommend a handy type that only represents empty or singleton lists
13:09:20 <carpi> koob. thank you all. noob here. haskell rocks... so far. but like with anything else.. you learn better with an instructor. :(
13:09:25 <edwardk> acowley: or that
13:09:26 <companion_cube> acowley, so, Maybe ?
13:09:30 <acowley> companion_cube: right
13:09:34 <danharaj> of course it seems to be obscenely slow.
13:09:38 <acowley> carpi: that's what #haskell is for
13:10:15 <danharaj> oh wait. It's slow because I'm running it in ghci :D
13:10:17 <edwardk> > Data.Maybe.listToMaybe [1,2,3]
13:10:18 <lambdabot>   Just 1
13:10:25 <edwardk> > Data.Maybe.listToMaybe []
13:10:26 <lambdabot>   Nothing
13:10:30 <carpi> this is out of curiosity.. but shouldn't "head []" logically return 0?
13:10:35 <acowley> !
13:10:44 <parcs> blasphemy!
13:10:46 <edwardk> carpi: 0 isn't a member of all types
13:10:48 <Space_> hmmm
13:10:50 <luite> carpi: that would mean that head only worked for types that have a 0
13:11:00 <carpi> oh shite.. my bad.. i confused head with length..
13:11:06 <tom_> hey, is anyone here familiar with the enumerators package?
13:11:08 <edwardk> > length []
13:11:08 <lambdabot>   0
13:11:10 <carpi> sorry sorry. length returns 0 as expected for []
13:11:15 <edwardk> np =)
13:11:27 <edwardk> > let ones = 1 : ones in length ones
13:11:29 * acowley shares the smelling salts with parcs
13:11:43 <lambdabot>   thread killed
13:12:02 <kwantam> edwardk stop trying to kill ec2 >:-)
13:12:12 <edwardk> kwantam: too late =/
13:12:14 <acowley> saying "head [] = 0" here is like saying pi = 3 in less-geeky circles :)
13:12:20 <kwantam> no kidding :(
13:12:26 <kwantam> but pi does equal 3
13:12:31 <edwardk> geez, who knew the cloud was just some place in Virginia?
13:12:37 <kwantam> c'mon who is killing themselves over 5%
13:12:47 <kwantam> interestingly, when you learn to let go, pi equals sqrt(10)
13:12:53 <carpi> kwantam: NASA )
13:13:02 <litb> acowley: i'm using  ghci -fllvm -ddump-llvm. but it doesn't print the llvm IR code for each interactive input. is LLVM not used in interactive mode?
13:13:06 <acowley> pi = delicious
13:13:06 <kwantam> carpi, touche
13:13:15 <kwantam> acowley, type mismatch
13:13:27 <Lemmih> litb: ghci generates bytecode.
13:13:38 <kwantam> (no one would say pi = delicious if we actually pronounced "pi" the way the greeks did)
13:13:44 <kwantam> (or still do)
13:13:45 <kwantam> (even)
13:13:53 <litb> Lemmih: oh it has its own virtual machine internally running that bytecode?
13:13:58 <acowley> (ok, but, seriously, pie is delicious)
13:14:06 <kwantam> (well yeah)
13:14:14 <Lemmih> litb: Yep.
13:14:44 <acowley> litb: out of curiosity, what are you hoping to get from GHCi? Just isolated snippets of LLVM IR?
13:16:28 <dons> http://news.ycombinator.com/item?id=2475349 good review
13:16:29 <litb> acowley: yeah. i thought it would generate a function for each interactive line of input and execute that with llvm JIT
13:19:39 <Lemmih> I am so looking forward to reading the book.
13:19:42 <carpi> are errors the only statements that are allowed to not conform to the return type of a function?
13:20:53 <hpc> carpi: eh?
13:21:03 <hpc> :t error
13:21:04 <lambdabot> forall a. [Char] -> a
13:21:11 <Lemmih> carpi: Nope, see the type of 'error'.
13:21:17 <hpc> :t undefined
13:21:18 <lambdabot> forall a. a
13:21:18 <Lemmih> carpi: It can be anything.
13:21:20 <hpc> :t unsafeCoerce
13:21:21 <lambdabot> Not in scope: `unsafeCoerce'
13:21:28 <hpc> @let unsafeCoerce = fix ($)
13:21:29 <lambdabot>  Defined.
13:21:31 <hpc> :t unsafeCoerce
13:21:32 <lambdabot> forall a b. a -> b
13:21:44 <hpc> (not actual implementation, but it matches the type)
13:22:26 <hpc> :t error "oh crap!"
13:22:26 <lambdabot> forall a. a
13:22:44 <carpi> what i meant is this.. pastebin.com/JP3g5aFM
13:23:14 <hpc> carpi: the type of error is String -> a
13:23:19 <hpc> so error "something" :: a
13:23:26 <dons> Lemmih: by luck, i have two copies
13:23:28 <hpc> so it doesn't "not conform to the type"
13:23:32 <dons> i think i will give one away at phihac
13:23:33 <ClaudiusMaximus> :t error "5" `asTypeOf` 5
13:23:33 <lambdabot> forall a. (Num a) => a
13:23:34 <hpc> it actually conforms to any type
13:23:48 <carpi> so error can be (a)nything too?
13:24:05 <hpc> yes
13:24:09 <hpc> undefined :: a
13:24:20 <Philippa> but it can because its type says it can
13:24:26 <hpc> you can use it anywhere and it will specialize the type when it needs to
13:24:30 <hpc> :t (undefined :: Int)
13:24:31 <lambdabot> Int
13:24:33 <acowley> dons: you're coming to phihac?
13:24:37 <hpc> :t (error "AAAAAAH" :: Int)
13:24:37 <lambdabot> Int
13:24:47 <hpc> :t (error "AAAAAAH" :: IO Bool)
13:24:48 <lambdabot> IO Bool
13:27:02 <kwantam> :t (error "the bees they're in my eyes" :: StateT Int IO (Int,Int))
13:27:03 <lambdabot> StateT Int IO (Int, Int)
13:27:39 <kwantam> I'll admit, I just wanted to type that thing about the bees. There are none here, however.
13:29:20 <aristid> :t (not $ error "the bees they're in my eyes")
13:29:21 <lambdabot> Bool
13:29:40 <ion> :t error "bla" + 1
13:29:41 <lambdabot> forall a. (Num a) => a
13:29:43 <hpc> :t (fix error)
13:29:44 <lambdabot> [Char]
13:29:48 <hpc> > fix error
13:29:48 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:29:51 <jmcarthur> :t error "the bees they're in my eyes" `asTypeOf` 5
13:29:52 <lambdabot> forall a. (Num a) => a
13:30:48 <dons> acowley: yeah, i reckon
13:39:38 <aristid> hpc: not only does haskell's type system often prevent programs from running that would have errors, it also allows you to fix errors automatically ;)
13:39:50 <hpc> ;)
13:39:52 <acowley> dons: Awesome! We had a nice group last year; I'm looking forward to this year's edition.
13:40:29 <copumpkin> acowley: phihac!
13:40:33 <copumpkin> surely it's hacphi
13:41:06 <dons> haven't been to a hackathon on the east coast, so should be fun
13:41:31 <ksf> it also allows you to bang your head against the desk because some people are just too smart
13:43:33 <ksf> ...and others are dumb enough to see "yay, let's just implement a monad instance for an extensible record" as a good approach.
13:44:12 <kwantam> first, let's split the problem up into its representative moads
13:44:14 <kwantam> monads, even
13:44:33 <ksf> well, yes.
13:44:37 <kwantam> :)
13:45:05 <kwantam> the Monad is the new Object! Monad-Oriented Programming! Solve all problems!
13:45:20 <kwantam> actually, sometimes I'm glad Haskell isn't more popular
13:45:21 <kwantam> :)
13:45:27 <ksf> this bogs down to having one Cont for the bulk of the work, and allowing some of those actions to offer another Cont that takes a different parameter.
13:45:41 <djahandarie> kwantam, "avoid success at all costs"
13:45:45 <kwantam> ^^
13:46:22 <ksf> I think I'm going to try again with HList, while oleg's code doesn't look as clean, it's usable for mere mortals...
13:46:53 <kwantam> imagine a dog as a monad. Now, let's say we want to join another ear to a dog. Then we just have to say "dog >>= \a -> return $ dog ++ ear
13:47:14 <kwantam> sorry, I can't make this metaphor work
13:47:26 <kwantam> apparently the world is not made of monads ;)
13:47:30 <hpc> it's because monads are burritos
13:47:37 <hpc> dogs are obviously monoids
13:47:38 <djahandarie> kwantam, you'd be surprised at the analogies people have come up with
13:47:39 <acowley> oops, yes, I think "Hacφ" is the approved notation
13:47:40 <hpc> dog `mappend` ear
13:47:58 <djahandarie> HacPhi sounds like it's going to be fun
13:48:10 <ksf> ...or I could try and formulate the whole thing in Control.Coroutine.
13:51:20 <SirFrancisDrake> kwantam, you're obviously missing something. Imagine dog as a comonad instance instead. You set aside imperative thinking. You're relaxed. You take an object World and get a dog from it. (Or maybe an (++ ear) <$> dog or something like that.)
13:52:21 <kwantam> haha SirFrancisDrake 
13:53:40 <kwantam> Let's consider StateT in terms of a bank robbery. You transform the state of the bank by monadically removing money from it.
13:56:31 <luite> kwantam: that doesn't add up... you'd expect to be able to use "get" to get the money, but that leaves the state the same!
13:57:23 <kwantam> no no no the idea here is that we're taking the bank's normal State and adding the ability for us (as robbers) to remove money from the bank without starting our own bank.
13:58:20 <kwantam> anyway c'mon we're not "getting" money, we're just, ah, "examining" it :)
14:01:30 <acowley> kwantam: which is fine, since this is a monad and join will just be used for the inevitable bank merger
14:01:48 <kwantam> so what happens when our bank becomes too big to fail?
14:02:27 <acowley> escape continuation
14:02:53 <kwantam> indeed
14:03:05 <kwantam> the kind of escape continuation that involves a private jet methinks
14:03:53 <kwantam> now there's some Hacker News link bait: "The 2008 stock market crash explained with Monads"
14:04:08 <kwantam> or perhaps the inverse would be better: "Monads explained with the 2008 stock market crash."
14:04:48 <kwantam> perhaps some kind of mutually explanatory device is in order
14:04:49 <merijn> >.>
14:05:04 <SirFrancisDrake> you could also shorten it. To sound more sensational, you know
14:05:32 <SirFrancisDrake> "Monads explained!" (written in uppercase)
14:05:42 <merijn> Monads are like portals, really confusing until you get the hang of 'em :p
14:05:59 <kwantam> I think perhaps for best success we should use "how to ace a YC interview using Monads"
14:06:08 <SirFrancisDrake> you mean portals with columns?
14:06:14 <companion_cube> scientists finally understand what monads are for!
14:06:16 <Tomsik> Portals are just F-algebras, man
14:07:52 <merijn> I suppose that makes perfect sense, if you know what an F-algebra is :p
14:08:27 <kwantam> speaking of fake hacker news headlines, http://twitter.com/fakehackernews is reasonably entertaining in this respect (full disclosure: a buddy of mine writes some of them)
14:10:26 <Tomsik> F-algebras are just sigma-algebras defined in language of category theory in terms of functors and initial objects
14:12:47 <acowley> portals seem kind of endofunctorial to me as you don't move between different realities, and you can merge the reality through the portal with the one you're in, so they're monoidal... so they're monads.
14:13:34 <acowley> and with that insight, adieu for now
14:13:35 <merijn> Ha! I was right! (apparently...)
14:13:44 <Tomsik> Hm, this is kind of weird then
14:13:54 <Tomsik> because algebra gives F a -> a
14:14:07 <Tomsik> so this means that you can escape from the monad
14:14:12 <Tomsik> Portal monad
14:14:49 <kwantam> well yeah, (fix glAdOS) will let you escape
14:15:23 <Tomsik> I think it's GLadOS
14:15:36 <Tomsik> or something like this
14:15:45 <merijn> GLaDOS
14:15:52 <Tomsik> I don't have a computer that could run portal 2 :(
14:15:55 <merijn> Genetic Life and Disk Operating System :>
14:16:06 <djahandarie> Who is in charge of Hackage btw? Would be nice to see what's up with the documentation generation
14:16:08 <Tomsik> planning on getting one soon though
14:17:09 <merijn> Tomsik: I got it thursday, runs pretty well on my machine (which did only okay with Portal itself) about 30FPS in both
14:18:19 <aristid> kwantam: i don't want to spoiler too much for you, but defeating GlaDOS will NOT be the end of the game :P
14:19:17 <merijn> Story is brilliant, puzzles could've been somewhat harder, imo. But hopefully downloads will fix that issue...
14:19:36 <Tomsik> The pain is that you need two comps that can run it for coop >_>
14:19:40 <aristid> merijn: the fact that the puzzles are not too hard is good, otherwise i would never be able to solve them :P
14:20:25 <Tomsik> aristid: come on, puzzles are just like making the type system do the right thing :p
14:20:30 <merijn> Well, I raced through the game in 2 afternoons, and my portal experience meant most of the puzzles felt fairly easy. And unlike Portal it didn't have any challenge maps...
14:20:55 <Tomsik> merijn: Don't tell me it's easy :(
14:21:22 <merijn> Tomsik: Depends on how easy you thought Portal was
14:21:41 <aristid> merijn: i spent 2.5 afternoons already, and i only just discovered repulsion gel...
14:21:46 <Tomsik> Portal was pretty easy, yeah
14:22:15 <Tomsik> Mostly because you could just bang turrets down
14:22:15 <merijn> Tomsik: It's at about the same level as the later Portal levels I'd say, haven't tried co-op yet, though
14:22:27 <aristid> Tomsik: turrets play much less of a role
14:22:43 <Tomsik> aristid: huh, rest is just jumping around
14:22:51 <aristid> Tomsik: no, there's new stuff.
14:22:59 <merijn> Hmm, maybe I'm just fast then.
14:23:33 <aristid> Tomsik: and some levels are HUGE
14:23:37 <merijn> Tomsik: Well, the new mechanics add a lot of difference from Portal. It will be possible to make challenge maps which are a complete pain
14:23:53 <aristid> like there's a level with three doors, and it took me ages to only find these 3 doors (well, i'm also bad at spotting stuff :D)
14:24:20 <merijn> aristid: Right before the repulsion gel?
14:24:24 <aristid> merijn: yup
14:24:48 <merijn> With the one door cracked open? Took me ages before it dawned on me it was not an insanely hard puzzle but just a simple one portal job :p
14:24:51 <aristid> merijn: actually i only found it when somebody else told me "i'm stuck at the level with the 3 doors"
14:25:00 <Tomsik> Hmm, though portal might not be the first game I'll play, Amenesia has higher priority probably :p
14:25:51 <aristid> merijn: well, not that precise part
14:25:54 <luite> merijn: hehe that took me a while too... I first thought that you had to get to the tower in the water somehow
14:25:59 <aristid> merijn: although i had problems with tat too
14:26:19 <aristid> luite: yes!!
14:26:24 <merijn> luite: At least I'm not significantly more stupid then the rest of civilization then
14:26:55 <Tomsik> It's kind of sad that there's no hard puzzle games that don't feel like NP-complete
14:26:58 <luite> nah don't get your hopes up, I'm pretty high on the stupidity scale ;)
14:28:08 <aristid> Tomsik: i don't think it's like exhaustive search at all :P
14:28:29 <aristid> luite: yeah why else would you be in #haskell
14:29:06 <Tomsik> aristid: first portal surely wasn't
14:30:34 <aristid> Tomsik: anyway. the way to find out is to get the game. it is certainly not a bad game :P
14:30:53 <Tomsik> I need to get a computer first :p
14:31:02 <aristid> or a PS3.
14:31:03 <luite> it also runs on xbox or ps3
14:32:09 * merijn is idling in game for the "You've made your point" achievement, only 20 minutes or so to go...
14:32:37 <aristid> merijn: huh?
14:33:52 <merijn> aristid: At one point you get in a situation "solve the test! I'll be back in one hour if you haven't!" at which point you get an achievement for being stubborn enough not to solve it :p
14:34:21 <aristid> merijn: lol, ok. not there yet :D
14:37:13 <Tyr42> Portal 2?
14:40:06 <aristid> Tyr42: yes. not even #haskell is immune :D
14:40:18 <ymasory> is it possible to write functions in haskell that work on tuples of any length? like for example a function that takes a tuple T and returns (T, T)
14:40:34 <hpc> wow, can we [SPOILER] this stuff?
14:40:35 <aristid> ymasory: not on any length, but on many lengths.
14:40:44 <hpc> also -blah it?
14:40:53 <ymasory> aristid: meaning the funciton has to be written for each tuple length from 1 to 66?
14:40:57 <Tomsik> ymasory: T -> (T, T) is trivial
14:41:09 <djahandarie> ymasory, well, (1,2) |-> ((1,2), (1,2)) is easy to write
14:41:12 <Tomsik> I mean, \x -> (x, x)
14:41:16 <copumpkin> ymasory: with type-level numerals it's easy
14:41:19 <aristid> ymasory: probably tuples longer than 9 are not really important.
14:41:28 <copumpkin> but otherwise yeah, you have to write them individually
14:41:32 <copumpkin> but note that you're not really using tuples as tuples
14:41:33 <ymasory> err, let me make it more difficult. (T1, ..., Tn) -> (0, T1, ..., Tn)
14:41:35 <copumpkin> tuples are heterogeneous
14:42:01 <Tyr42> not really
14:42:03 <Tomsik> if you've got more than 4-tuple you probably should write a separate datatape
14:42:05 <Tomsik> type
14:42:14 <copumpkin> you seem to be using them as vectors with statically known length
14:42:15 <aristid> hpc: there's a level where you have to put a broken turret into a machine that compares two turrets to check if they're broken. if you stand in that spot, you get an achievement.
14:42:36 <copumpkin> which we can do in haskell with some extensions, fairly easily
14:42:39 <ymasory> oh i agree, i was just trying to get a decent example of how it's difficult to abstract over tuples with the haskell and scala type systems. i think  (T1, ..., Tn) -> (0, T1, ..., Tn) might be a decent example
14:42:49 <aristid> hpc: do you hate me now? :P
14:42:49 <Tyr42> what could the receiver do with the new tuple?
14:42:50 <copumpkin> yeah, tuples are completely separate types
14:42:56 <copumpkin> (,,) vs (,) 
14:43:03 <copumpkin> those are completely unrelated, despite sharing similar syntax
14:43:15 <aristid> you can typeclass them to some extent :)
14:43:16 <copumpkin> so the answer is that there isn't a way to use those
14:43:18 <copumpkin> yeah
14:43:20 <copumpkin> @hackage tuples
14:43:21 <lambdabot> http://hackage.haskell.org/package/tuples
14:43:32 <copumpkin> @hackage tuple
14:43:32 <lambdabot> http://hackage.haskell.org/package/tuple
14:43:52 <aristid> ymasory: another way is to nest tuples. instead of (a, b, c) you can do (a, (b, c))
14:44:02 <copumpkin> but still, I don't think it's particularly useful to treat them as vectors
14:44:11 <copumpkin> aristid: that tends to be nicer if you have an explicit terminator
14:44:16 <copumpkin> like (a, (b, (c, ()))
14:44:29 <aristid> copumpkin: heh, more list-like
14:44:31 <copumpkin> but then you start writing type functions and the like
14:44:38 <copumpkin> and it gets painful
14:44:44 <aristid> oleg loves that
14:44:51 <copumpkin> I love it too
14:44:57 <ymasory> yeah you could do (T1, ..., Tn) -> (0, (T1, ..., Tn))
14:44:59 <aristid> you love pain?
14:45:04 <copumpkin> yep
14:45:41 <copumpkin> ymasory: if you don't enforce some kind of shape it turns into a tree of types which can get even hairier to deal with
14:48:33 <pmetzger> This brings something to mind I've been meaning to ask. Strings are technically lists, but are they actually implemented as traditional lists or are they implemented as sequences of memory locations with the compiler just DTRT with the list primitives?
14:48:49 <pmetzger> I mean in ghc of course -- different compilers could do differently.
14:49:03 <companion_cube> basic strings are really lists, afaik
14:49:09 <luite> they are actual lists, and quite slow
14:49:13 <companion_cube> but you can use ByteString if you wish performance
14:49:27 <pmetzger> so if I slurp a big file in, I'm dealing with quite slow operations, eh?
14:49:45 <luite> yes
14:49:47 <pmetzger> I'm a bit surprised, since given the strong typing, one need not do things as inefficiently as lisp has to...
14:49:55 <luite> you can overload string literals with the OverloadedStrings extension
14:50:08 <pmetzger> cdr coding or what have you would be easily practical...
14:50:28 <copumpkin> pmetzger: I think they're reluctant to put special-case optimizations in
14:50:37 <copumpkin> and you could still easily make an infinite string
14:50:42 <copumpkin> or efficiently cons something on
14:50:50 <pmetzger> sure, but in many cases...
14:50:51 <copumpkin> so it's hard for the compiler to know statically that you won't do that
14:50:56 <pmetzger> that's why cdr coding and things like that win.
14:50:57 <copumpkin> well, how is it to reason about tha?
14:51:31 <pmetzger> you lose a bit if you're doing something like cdr coding in the bad case and you win in the common case.
14:51:42 <pmetzger> though I wonder how efficient you could make it on a normal architecture. hrm.
14:51:44 <copumpkin> how about infinite strings?
14:52:18 <pmetzger> you would need a different representation.
14:52:29 <pmetzger> but that's implicit when you use a hack like cdr coding
14:52:42 <copumpkin> I guess it'd be possible to do something like lazy bytestrings
14:52:53 <copumpkin> but still, I think they're reluctant to put knowledge about particular types like that into the compiler
14:52:55 <pmetzger> in cdr coding, you have a special way of saying "the cdr cell is not a pointer, it is the actual data value"
14:53:00 <copumpkin> without a general mechanism for anyone to be able to do the same thing
14:53:15 <pmetzger> basically you use type tags with extra meanings
14:53:33 <pmetzger> or rather, you represent this way of laying out a list with a special tag
14:54:18 <KirinDave> pmetzger: I see what you're saying. I think the reason people are happy with the current state of affairs is that it's not abnormal at all to wrap types in other types.
14:54:30 <KirinDave> pmetzger: So in daily usage, switching to bytestring doesn't feel like a huge deal.
14:55:17 <KirinDave> pmetzger: It confused me a lot at first as well.
14:55:28 <KirinDave> pmetzger: "Why not just have string performant by default?"
14:55:32 <pmetzger> I imagine that juggling thunks and other fun like that probably overwhelms the overhead of little things like this...
14:55:57 <c_wraith> not if the string is large.  large strings are definitely *bad* for performance.
14:56:02 <KirinDave> pmetzger: Eh, it is important. using ByteString can be a huge deal.
14:56:22 <c_wraith> small strings, not so big of a deal
14:56:25 <pmetzger> I imagine this will be more obvious after I've been using the language more.
14:56:37 <saml> hey, is there nginx module for haskell?  
14:56:48 <KirinDave> pmetzger: Once you start seeing newtype used, you go, "Oh. So I guess this is normal;."
14:57:01 <KirinDave> Like the Sum and Product and Any and All monoids in LYAH really confused me at first.
14:57:06 <KirinDave> Still not sure I "love" them
14:57:18 <c_wraith> I mean, if you want to read a 300 MB file into memory...  The overhead of reading it as a String is really pretty bad.
14:57:36 <pmetzger> much of why I'm doing my current project in haskell is to get a feel for haskell more than to produce a final production compiler.
14:57:41 <KirinDave> c_wraith: On a 64 bit machine. ;)
14:57:49 <pmetzger> though the semantics of the language look really nice for things like compilers.
14:58:05 <dons> saml: check on hackage.haskell.org
14:58:07 <KirinDave> c_wraith: You should try it in erlang. :D
14:58:19 <dons> pmetzger: there are *tons* of compilers written in haskell too, so you get to benefit from that
14:58:27 <pmetzger> so I've noticed.
14:58:50 <djahandarie> dons, random poke, do you know what's up with the hackage haddock builder, or who I can email to figure it out? It seems to not be generating any docs
14:59:00 <saml> dons, can't find nginx there. i know of snap and yesod
14:59:18 <dons> djahandarie: not sure. worth a mail to libraries@haskell.org cc'ing ross paterson
14:59:31 <dons> 2991 packages on hackage. 9 more to go
14:59:33 <djahandarie> Okay, I'll go ahead and do that.
14:59:52 <saml> i was thinking something like fastcgi  but without opening a socket. but use dlopen instead
15:00:08 <danharaj> So I made a verlet integrator that simulates n particles with mutual gravitation. But it's really really slow, even for two particles. I figure I need to do some heavy optimization of the numerics. Where should I start?
15:00:22 <pmetzger> I have been getting the impression that to some extent, haskell encourages people to "just throw it in a list" or "just throw it in an association list" etc., which is probably not great for performance but is nice because everything can be written fast with a few composed functions.
15:00:23 <dons> danharaj: post the code
15:00:27 <dons> danharaj: so we can look at the types
15:00:46 <dons> danharaj: and some obvious questions: are you using ghc? with -O2? using vector/repa arrays? Doubles? 
15:00:55 <pmetzger> I really should finally read my copy of "purely functional data structures", it has been gathering dust for a couple of years on my shelf.
15:01:18 <Philippa> pmetzger: better to throw it in a Seq, throw it in a Map
15:01:20 <danharaj> dons: I will post all of the code tonight once I clean it up, set up a blog, place the proper copyright notices for borrowed bsd code, etc :)
15:01:28 <dons> danharaj: and you can read matt sottile's blog for hints too:  http://syntacticsalt.com/2011/03/10/functional-flocks/ 
15:01:46 <Philippa> faster structures exist for day-to-day stuff too, lists just got all the sugar
15:01:56 <tommd> pmetzger: Some people do complain that Haskell list notation is "too easy".  Its an understandable stand point.  About the tenth time you see an association list where a Map is needed you scream.
15:01:58 <osfameron> is it possible to define a class instance for functions of a particular type? (for example (a -> Bool)) ?
15:02:06 <dons> there are often lots of common errors when writing simulation/numerical code in haskell: using lists, using slow types, laziness issues, ...
15:02:08 <danharaj> dons: I am using ghc, -O2, I'm using a type that looks like Vector Float Float for my vector arithmetic. I am processing everything in lists.
15:02:14 <danharaj> heh. using lists eh.
15:02:33 <kwantam> how much GC and alloc time are you seeing?
15:02:33 <dons> danharaj: yeah, lists==bad; 2D repa arrays == good;
15:02:38 <Philippa> tommd: the worst bit is you still use association lists to initialise constant maps
15:02:46 <pmetzger> I also still have no sense at all when I'm accidentally leaking space. I imagine I won't get that for a long time.
15:02:47 <dons> don't encode 2 dimensional arrays as lists, for example. common error
15:03:12 <danharaj> dons: Alright then. So which array libraries should I look at? I know there are a couple. I haven't looked at any yet.
15:03:15 <copumpkin> also keep in mind that something like foldl' won't do the right thing if you're folding over a pair
15:03:19 <dons> repa or vector
15:03:29 <dons> depending on if you need 1d , or 2d and parallel.
15:03:32 <dons> 2d .. Nd
15:03:34 <danharaj> ok great!
15:03:40 <danharaj> copumpkin: good to know.
15:03:58 <copumpkin> or any complex non-strict type :)
15:04:02 <roconnor> does repa work in GHC 7 yet?
15:04:18 <roconnor> not that I'm using GHC 7 yet
15:04:24 <dons> yes.
15:04:29 <roconnor> :O
15:04:29 <danharaj> another question: how can I tell ghc to store a product type in as flat a structure as possible?
15:04:44 <danharaj> since I guess that's another low-hanging optimization fruit.
15:04:51 <dons> roconnor:  http://disciple-devel.blogspot.com/2011/03/real-time-edge-detection-in-haskell.html  
15:05:09 <copumpkin> danharaj: if it isn't polymorphic, you can ask it to unpack 
15:05:17 <copumpkin> danharaj: if it is, then you're kind of screwed :P
15:05:18 <dons> danharaj: data T = T {-# UNPACK #-}!Double {-# UNPACK #-} !Double
15:05:31 <dons> danharaj: read  http://book.realworldhaskell.org/read/profiling-and-optimization.htmlfor hints
15:05:59 * danharaj puts on the reading goggles
15:06:32 <dons> reading goggles sound cool
15:07:04 <danharaj> I also have a blackboard cape.
15:07:07 <pmetzger> best if they're made of milled brass with leather padding and straps, for that steampunk look.
15:07:25 <dons> something like this? http://www.wired.com/images/slideshow/2007/06/gallery_steampunk/atomefabrikGoggles.jpg  
15:07:33 <pmetzger> not bad.
15:07:35 <danharaj> and a type gymnastics leotard
15:07:58 <c_wraith> that picture hurts my eyes.  why is his face motion-blurred, but the goggles are not?
15:08:19 <pmetzger> because it is cooler that way, and steampunk is all about cool, and not at all about function.
15:08:35 <Tyr42> zee goggles, they do nothing!
15:08:39 <danharaj> ah there's a great Beaton comic about that
15:09:07 <pmetzger> yah, it has a time traveller harassing isambard brunel about something while wearing useless gears on his boots
15:09:08 <danharaj> http://www.harkavagrant.com/index.php?id=266
15:09:14 <pmetzger> that one. :)
15:09:27 <kwantam> danharaj, how much data mutation are you doing? The other thing I've found a huge optimization help is wiring ST through the heavy mutation functions and stringing together updates between unfreeze and freeze
15:09:37 <pmetzger> isambard brunel is kind of a hero of mine.
15:09:48 <danharaj> kwantam: I am updating 4 floats per particle per frame
15:09:52 <kwantam> e.g., when doing image processing on large images
15:09:59 <danharaj> Not too much mutation.
15:10:06 <kwantam> eh, yeah
15:10:27 <danharaj> I'm sure by using arrays I'll get real time simulation for small n. Right now I don't have real time for one n! I have no idea why.
15:10:31 <pmetzger> http://upload.wikimedia.org/wikipedia/commons/4/43/IKBrunelChains.jpg
15:10:34 <danharaj> er, n =1
15:10:46 <pmetzger> total badass engineer from when engineers could be really badass.
15:11:02 <kwantam> needs more facial hair
15:11:15 <pmetzger> that's him in front of the giant launching chains he had to design for the giant ship he designed
15:11:27 <kwantam> friendly mutton chops, for example, are the mark of a true engineering giant
15:11:40 <pmetzger> which ended up being useless until they decided it was perfect for laying the first successful transatlantic telegraph cable
15:11:52 <kwantam> nice
15:13:26 <pmetzger> that was back when all the tools of modern machining and metalurgy and engines were new and people could say "hey, no one has ever built a steam hammer capable of driving 100 foot piles into the ground before, lets try it!"
15:13:47 <danharaj> engineering for science
15:15:08 * osfameron gets as far as http://hpaste.org/45960/typeclass_confusion
15:15:16 <osfameron> that's just a silly sketch to get my head round typeclasses
15:15:20 <osfameron> but it doesn't work.  Any suggestions?
15:16:55 <ryant5000> osfameron: what's the meaning of your 'b' variable supposed to be, on line 3?
15:17:43 <doserj> I guess you need a functional dependancy, or an associated type
15:18:16 <osfameron> ryant5000: it's meant to be an "any type" thing, but then I guess that doesn't mesh with the specific (a -> Bool), where it would have to be "a" specifically
15:18:17 <Twey> osfameron: IIUC, your typeclass asserts that runPred can take any type b
15:18:43 <Twey> But your instance requires that it be of type , so it doesn't match the type defined in the class
15:18:46 <ryant5000> osfameron: right; there aren't too many useful predicates you can write that will work on *any* input type
15:19:19 <doserj> class Predicate a where type Testable a; runPred :: a -> Testable a -> Bool
15:19:22 <osfameron> and of course the Regex idea will only work on Stringlike types
15:19:42 <Twey> Er that it be of type a**
15:19:57 <osfameron> doserj: yeah, maybe.  except different values will be testable by different predicates
15:20:05 <osfameron> ok, so that wasn't a simple sketch after all ;-)
15:20:20 <Twey> No, not so simple
15:20:31 <osfameron> out of interest, is it possible?
15:20:34 <Twey> Yes
15:20:47 <Twey> I think it would involve a multiparameter typeclass
15:20:51 <elliotstern> I'm having a weird stack overflow: http://hpaste.org/45961/weird_stack_overflow
15:20:56 <osfameron> cool.  I'll come back to it when I'm more comfortable with type stuff ;-)
15:21:00 <Twey> Or possibly an associated type; I don't really understand those
15:21:04 <elliotstern> What am I doing wrong?
15:21:39 <Twey> Heh, map (\x -> "Or possibly a " ++ x ++ "; I don't really understand those") half_the_GHC_type_extensions
15:23:47 * osfameron twitches at LYAH again
15:24:17 <osfameron> it's just that bit expensive in Kindle format
15:24:25 <djahandarie> Blah, libraries@haskell.org blocked my message. Guess I need to subscribe to it
15:24:40 <osfameron> maybe I should buy in in dead-tree instead, somehow that feels more worth it
15:25:00 <Saizan> or use the website?
15:25:09 <luite> or get the pdf
15:25:12 <osfameron> yeah, or that.
15:25:14 <luite> with color pictures
15:25:25 <osfameron> pdf on kindle is terrible
15:25:31 <kwantam> yeah, it's not the best
15:25:32 <osfameron> well, non-optimal, anyway
15:25:32 <luite> although the kindle version might have color as well, don't know
15:25:40 <kwantam> no color on kindles
15:25:51 <osfameron> and the pdf->.mobi conversion doesn't work very well
15:25:57 <kwantam> eInk rules, but not that hard :)
15:25:57 <osfameron> in calibre
15:26:00 <Saizan> elliotstern: pretty weird, can you reproduce it with a compiled program?
15:26:15 <luite> kwantam: the images could still be color
15:26:19 <kwantam> yeah, I haven't found calibre particularly useful honestly. I'm sure it's great for some things, just not what I want it for. I use htmldoc
15:26:23 <kwantam> luite, point taken :)
15:26:25 <luite> since you can view the same files with the kindle app on tablets
15:26:50 <osfameron> kwantam: it works very well for epub<=>mobi
15:26:57 <kwantam> interesting, guess I've never tried that one.
15:27:02 <osfameron> it does as good a job as you'd expect from pdf (i.e. a bad one)
15:27:18 <osfameron> and not great from a directory of html files
15:27:18 <elliotstern> Saizan: well, when I call the compiled function in ghci that creates the Board (and force it), it also stack overflows
15:27:32 <luite> I was thinking of buying a kindle for reading outdoors (using an ipad at the moment), but most of my books are pdf, and the kindle is just a bit too small to read them comfortably :(
15:27:57 <Saizan> elliotstern: can you show the whole code?
15:27:59 <kwantam> kindle dx might do the trick
15:28:23 <luite> kwantam: yeah a bit expensive though, for the few times a year that I'd use it
15:28:26 <osfameron> ooo, LYAH is CC-licensed after all, so it'd be legal to scrape and make my own .mobi file from it
15:28:53 <osfameron> luite: heh, if you already have a tablet, then it's probably fine for occasional reading
15:29:00 * osfameron does like the e-ink screen outdoors though
15:29:37 <luite> I like tft indoors better, don't need as much light, but for outdoors, eink can't be beaten :)
15:31:56 <lispy> luite: the dx is nice for pdfs.  I can even comfortably read 2-column conference papers
15:32:11 <lispy> luite: But, if you only read indoors, the ipad2 is probably better, although twice the price
15:32:18 <elliotstern> Saizan: The whole code is in a somewhat early and provisional state, but here it is: http://hpaste.org/45962/the_whole_code
15:32:29 <luite> lispy: I already have an ipad (1)
15:33:16 <luite> if the dx was $200 or so, then it would've been an easy choice
15:33:36 <luite> but at $379 it's rather steep for a second device
15:34:01 <lispy> luite: The dx is a bit spendy, but since I don't have  a regular kindle or an ipad so it hit the sweet spot for me
15:35:00 <luite> oh can you put pdfs in folders now, on the kindle or the dx?
15:35:53 <elliotstern> So, does anyone have any ideas of what the problem is?
15:37:03 <luite> lispy: I like the extra features of the ipad and the fact that you can also read epub and other formats (with or without drm), having it sync with mendeley is also very useful
15:37:54 <Saizan> elliotstern: so you're calling genBoard?
15:38:20 <ksf> luite, and that it's big enough to be able to beat down your hardon you get from touching it? (scnr)
15:38:47 <elliotstern> Saizan: Yes
15:38:54 <Saizan> elliotstern: ah, i think i see, indent show on line 29 a little
15:38:59 <luite> ksf: I don't think it's bigger than the dx actually
15:39:19 <ksf> well, it's bigger than a pandora.
15:39:41 <ksf> and comes with less keys and nubs.
15:40:15 <luite> yeah but with a bigger screen... I think that might be important for some applications, like reading pdfs...
15:41:09 <aristid> luite: and annoying for others
15:41:11 <elliotstern> Saizan:  Yes, that works now
15:41:22 <aristid> like you can very easily carry a kindle 3 around.
15:41:22 <elliotstern> What was it doing before that confused it so?
15:41:51 <Saizan> elliotstern: your show was understood as a separate toplevel definition, not as an implementation of the method of the Show typeclass
15:42:46 <Saizan> elliotstern: the Show typeclass has circular default definitions i guess, so that if you define just one method all the others are defined too, so the stack overflow was just the result of this infinite recursion with no base case
15:42:55 <elliotstern> Ah
15:42:58 <elliotstern> Makes sense
15:43:02 <elliotstern> Thanks!
15:43:07 <luite> aristid: yes I'm considering buying a kindle for reading outdoors, but since most of my books and papers are pdf, I wonder if its really going to be usable
15:43:08 <Saizan> np
15:43:30 <aristid> luite: well it's true. i do print papers... but i got a stapler, so that's no problem!
15:43:34 <aristid> staplers are awesome.
15:43:50 <aristid> and a duplex laserprinter.
15:43:55 <luite> hehe I have a huge stabler that can staple more than 50 pages, but I don't want to print anymore if not necessary :p
15:44:02 <luite> stapler
15:47:25 <kwantam> hole punches and binders are my go-to
15:47:35 <kwantam> or perhaps they're my goto, and they're somehow harmful
15:47:45 * ddarius just does other stuff outdoors.
15:48:20 <luite> oh I didn't know that there was more stuff to do than reading papers
15:48:33 <luite> perhaps I should read some book on what you can doo outdoors
15:48:38 <ddarius> luite: It's a hazard of Haskell.
15:50:26 <aristid> luite: maybe ddarius knows a paper on that topic.
15:51:05 <luite> aristid: he probably does, how else could he know?
15:51:25 <aristid> indeed.
15:51:46 <luite> I think i'd best start with an introductory paper or a survey
15:51:49 <geheimdienst> is there any papers concerning a giant fireball in the sky? i've been trying to find peer-reviewed information that's not rumors
15:51:52 <aristid> luite: it sounds like a topic so crazy it must have been written about by oleg.
15:52:14 <djahandarie> Oleg goes outdoors in the type system
15:52:50 <luite> geheimdienst: I've seen a few, but none have the amount of rigor in their proofs that I've come to expect, so I've rejected their conclusions so far
15:53:14 <geheimdienst> oleg bends the type system so that indoors is really outdoors 
15:53:22 <ddarius> They didn't formalize the existence proof in Coq?
15:53:31 <ddarius> @google outside-in simon peyton jones
15:53:32 <lambdabot> http://research.microsoft.com/en-us/people/dimitris/
15:53:32 <lambdabot> Title: Dimitrios Vytiniotis - Microsoft Research
15:54:18 <ksf> reddit is up again!
15:54:22 <ksf> \o/
15:54:28 <dons> quick . upboats!!
15:54:29 <ksf> more time wasted!
15:55:52 * hackagebot hledger-lib 0.14 - Reusable types and utilities for the hledger accounting tool and financial apps in general.  http://hackage.haskell.org/package/hledger-lib-0.14 (SimonMichael)
15:55:54 * hackagebot hledger 0.14 - A robust command-line accounting tool with a simple human-editable data format, similar to ledger.  http://hackage.haskell.org/package/hledger-0.14 (SimonMichael)
15:56:52 * hackagebot hledger-web 0.14 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.14 (SimonMichael)
15:56:54 * hackagebot hledger-vty 0.14 - A curses-style interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.14 (SimonMichael)
15:56:56 * hackagebot hledger-chart 0.14 - A pie chart generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.14 (SimonMichael)
15:57:23 <dylukes> *sigh*
15:57:25 <dylukes> trying to do homework
15:57:27 <dylukes> distracted by lisp
15:57:28 <dylukes> ._.
15:57:39 <dylukes> I have the most homework I've had in months,
15:57:46 <dylukes> and I decide to try to figure out emacs and SLIME.
15:57:53 <dylukes> (this is a bad idea, I fear)
15:58:17 <ion> hledger, huh? Can it provide this function? I wouldn’t mind a better UI than a SQL REPL, but can’t be bothered to do it myself. https://github.com/ion1/money-sql#readme
15:59:21 <dons> http://news.ycombinator.com/item?id=2475753  <- talk on haskell powering the janrain services.  
16:01:25 <gnut> hi all
16:01:26 <ion> I‘m probably being blind, but i have hard time seeing a link to the video in the corp.galois.com page. :-)
16:02:03 <sm> ion: no hledger doesn't automatically calculate group-balancing transfers for you. There is another tool which does, I think it's http://darcsden.com/dbp/housetab-multi   
16:02:08 <gnut> I'm trying to call a function that takes a list of arguments that are passed by reference... so say blah(&a, &b, &c) is how you would call it in C++... 
16:02:13 <ion> sm: Thanks! I’ll take a look.
16:02:38 <gnut> can I do "withMany with [a,b,c] (\pa pb pc -> blah pa pb pc)" ?
16:02:43 <sm> if you'd like to add it some time, let's do it
16:02:55 <dylukes> gnut: The concept of "pass by value" or "pass by reference" doesn't quite work in haskell… given lazy evaluation
16:03:14 <dons> ion: the big [>] button?
16:03:18 <dylukes> I think the word is call-by-need
16:03:22 <djahandarie> ion, it's Flash
16:03:22 <dylukes> instead of call-by-val or ref
16:03:36 <dons> http://vimeo.com/21210266 ?
16:03:54 <gnut> dylukes: okay... hmm..
16:04:11 <dylukes> gnut: rather than describe an analog in an unrelated language, describe what you want to do
16:04:16 <dylukes> on a larger scale :)
16:04:30 <ksf> well, you *can* pass MVars or IORefs or stuff, but I'm going to get slapped if I recommend that.
16:04:41 * dylukes slaps ksf.
16:05:05 <ksf> hey!
16:05:06 <c_wraith> I pass mutable cells sometimes.  They're not all bad.
16:05:09 <gnut> dylukes: I have a library I want to use functions from. I did it in C before, but they have since changed to C++, and all the prototypes are int *n, int *m, etc...
16:05:12 <ksf> I didn't even mention Ptr a
16:05:14 <sipa> gnut: i think you can consider it as passing "foo(const type& arg)" C++-wise, it's not copied around, but neither can you modify it
16:05:42 <sipa> gnut: you want the FFI, which provides ways of interacting with C libraries
16:05:46 <gnut> so I have my haskell foreign import use Ptr CInt -> Ptr CInt -> IO ()
16:05:47 <sipa> including passing pointers around
16:05:56 <gnut> sipa: yeah. I'm using the FFI
16:06:13 <ksf> gnut, that'd be Int -> Int -> (Int, Int) when it's done.
16:06:15 <gnut> so before, if I had a function in C called blah, I would foreign import ccall blah
16:06:32 <ksf> get some memory with alloca, poke it before calling the c function, and peek it afterwards.
16:06:47 <gnut> but now that the library maker is using C++, I read that we can use "with" under foreign.marshal.utils
16:07:06 <gnut> but with a long list of arguments, I thought withMany would be useful.
16:07:21 <gnut> ksf: yeah. I think that's what "with" does
16:08:23 <gnut> but there's not much description about withMany
16:08:27 <gnut> so I came here to ask. :)
16:08:31 <ksf> gnut, wrapping those ptrs on the haskell side in a sensible way would mean using ForeignPtrs, so the memory can get garbage collected
16:08:45 <gnut> ksf: yeah.
16:08:51 <ksf> ...in short, you don't want to do that for small chunks of memory.
16:09:24 * ksf tries to remember how to do it manually
16:09:29 <ksf> usually, I just use c2hs
16:09:38 <ryant5000> does anyone here have a recommendation as far as F# tutorials go?
16:09:39 <ksf> ...which takes care of most of the boilerplate
16:09:48 <gnut> http://www.mail-archive.com/ffi@haskell.org/msg01671.html
16:09:57 <gnut> ksf: that's the thing I'm trying to do
16:10:01 <shachaf> dylukes: Oh, you're revenantphx.
16:10:14 <dylukes> shachaf: yeah.
16:10:37 <djahandarie> shachaf, we wanted to confuse you with more d- nicknames
16:10:46 <ksf> well, yes, his function seems to look alright.
16:10:50 <gnut> see but they're doing it with only two arguments... which is nice and easy
16:10:59 <gnut> what if I had say 10 arguments.
16:11:23 <gnut> I guess he arranges it where it's on top of each other, but if I could do it in list form, it would be nicer. Does withMany do this?
16:11:33 <gnut> http://www.haskell.org/onlinereport/haskell2010/haskellch34.html
16:11:41 <gnut> am I reading the documentation right?
16:12:02 <ksf> gnut, yes, but you'd still have to unpack the list and pass each element as a single parameter
16:12:28 <fosskers> hello ^^
16:12:38 <gnut> ksf: so something like... withMany with [a,b,c] (\pa pb pc -> function that works on the pointers pa pb pc)
16:12:51 <gnut> that sound right?
16:13:24 <gnut> okay. I will try this out. Thanks for the sounding board guys!
16:13:34 <ion> dons: For me <http://news.ycombinator.com/item?id=2475753> links to <http://corp.galois.com/blog/2011/3/8/tech-talk-haskell-and-the-social-web.html> which doesn’t seem to provide either an embedded video or a link to a video at vimeo.com to me. On the other hand there’s http://corp.galois.com/blog/2011/4/22/tech-talk-video-haskell-and-the-social-web.html which does contain a video.
16:14:04 <ksf> doStuff x y = withMany with [x,y] (\[px,py] -> doStuffC px py)
16:14:08 <ksf> in short, it's not very useful.
16:14:26 <gnut> with two variables, maybe not so
16:14:31 <ksf> gnut, if you have more involved ffi needs, have a look at c2hs
16:14:37 <fosskers> hey guys, im having some foldl woes
16:14:43 <gnut> but with many more, it lets you write it as a list as opposed to having to write the word "with" many many times
16:15:06 <gnut> ksf: yeah. I probably should look at it. :) 
16:15:19 <gnut> ksf: it can probably make things easier for me in the long run.
16:16:25 <ksf> with c2hs, you'd have lines that look like "alloca- `Int' peek"
16:16:41 <ksf> ...or even less, because you can default Ptr Int to use alloca and peek.
16:17:39 <ksf> short of writing your own haskell code generator, it's the most versitile you're going to get.
16:18:07 <gnut> ksf: I should look into it. I'm currently using a perl script to read the headers and write the haskell source that imports all the functions in the library
16:18:12 <ksf> the "write your own generator" approach would be sensible if you have an api description as xml or such
16:18:34 <luite> sounds enterprise
16:18:46 <ksf> xhb does exactly that.
16:18:55 <ksf> it in fact generates the whole library from xml.
16:19:00 <luite> cool, so now we are enterprise too?
16:19:06 <luite> we were already webscale and sharding ;p
16:19:07 <fosskers> Can anyone help me with foldl? The explanations I've been reading have been a bit lack-lustre....
16:19:21 <ksf> @src foldl
16:19:21 <lambdabot> foldl f z []     = z
16:19:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:19:39 * ksf thinks that answers any question anyone could ever come up with
16:19:43 <parcs> > foldl f z [a, b, c, d]
16:19:43 <lambdabot>   f (f (f (f z a) b) c) d
16:19:52 <fosskers> okay, but for f
16:20:02 <fosskers> the function applied to all elements
16:20:20 <fosskers> things like this: foldl (+5) 0 [1..10] explode
16:20:28 <luite> > foldl (+) z [a, b, c, d]
16:20:29 <lambdabot>   z + a + b + c + d
16:20:42 <c_wraith> fosskers: you need f to be of the right type.  (+5) only takes one argument.  It needs to take 2
16:20:46 <luite> oh I was hoping that that would use parentheses
16:20:56 <ksf> > foldl (+5) z [a, b, c, d]
16:20:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
16:21:00 <ksf> grrr
16:21:01 <fosskers> right
16:21:08 <ksf> :t (+5)
16:21:09 <lambdabot> forall a. (Num a) => a -> a
16:21:18 <fosskers> so, let's say im trying to add together all the elements of a list together using foldl
16:21:24 <fosskers> but i also want to add 5 to all of those as i go
16:21:27 <ksf> that doesnt' typecheck.
16:21:29 <fosskers> what needs to happen?
16:21:49 <c_wraith> You could make that part of your function.  you could do a separate map pass.  many other options
16:21:55 <luite> fosskers: map (+5) first, or do something like foldl (\x y -> x + y + 5) 0 xs
16:22:11 <c_wraith> note that those two are not completely equivalent
16:22:15 <c_wraith> their output will differ by 5
16:22:48 <ksf> ...just don't do "+ length xs * 5"
16:22:53 <fosskers> the reason im asking is that i was stumped by an exercise in 'Programming in Haskell
16:23:06 <ksf> (that would traverse the list twice)
16:23:13 <fosskers> using foldl, turn a list of ints into the equivalent int
16:23:18 <fosskers> ex. [2,3,4,5] -> 2345
16:23:24 <luite> c_wraith: ?
16:23:33 <c_wraith> luite: try it.  :)
16:23:37 <luite> > foldl (+) 0 (map (+5) [1..10])
16:23:38 <lambdabot>   105
16:23:44 <c_wraith> luite: oh, crap, I was thinking of foldl1.  whoops.
16:23:45 <luite> > foldl (\x y -> x + y + 5) 0 [1..10]
16:23:46 <lambdabot>   105
16:24:15 <ksf> that's not a good exercise.
16:24:22 <c_wraith> fosskers: So...  foldl, from a more theoretical standpoint, models a computation on a list with an accumulator
16:24:22 <ksf> the natural way to do it would be
16:24:31 <fosskers> yeah
16:24:34 <ion> > foldl (\n x -> 10*n + x) 0 [2..5]
16:24:35 <lambdabot>   2345
16:24:40 <ion> @pl \n x -> 10*n + x
16:24:41 <lambdabot> (+) . (10 *)
16:25:10 <c_wraith> wow, ion, way to jump to the result without showing the thought process in the middle :)
16:25:20 <ksf> > sum . zipWith (*) [1,10...] $ reverse [2,3,4,5]
16:25:21 <lambdabot>   A section must be enclosed in parentheses thus: (10 ...)Not in scope: `...'
16:25:30 <ksf> > sum . zipWith (*) [1,10..] $ reverse [2,3,4,5]
16:25:33 <lambdabot>   158
16:25:36 <ksf> erm.
16:25:40 <c_wraith> that list you're zipping with is wrong
16:25:42 <fosskers> why is the lambda taking two args?
16:25:51 <c_wraith> you'd need iterate (*10)
16:25:54 <fosskers> in here: foldl (\n x -> 10*n + x) 0 [2..5]
16:25:59 <luite> fosskers: one is the accumulator, the other is the list element
16:26:00 <c_wraith> :t foldl
16:26:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:26:09 <ksf> > sum . zipWith (*) (iterate (*10)) $ reverse [2,3,4,5]
16:26:09 <c_wraith> The function, f, takes two arguments
16:26:10 <lambdabot>   Couldn't match expected type `[a]'
16:26:10 <lambdabot>         against inferred type `a1 -> [a1]'
16:26:13 <fosskers> oh that sneaky accumulator
16:26:17 <c_wraith> ksf, need the base case of 1
16:26:17 <c_wraith> :)
16:26:19 <ksf> let's make this simpler.
16:26:22 <ksf> > sum . zipWith (*) (iterate 1 (*10)) $ reverse [2,3,4,5]
16:26:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:26:23 <lambdabot>    arising from a use of `...
16:26:28 <ksf> > sum . zipWith (*) (iterate (*10) 1) $ reverse [2,3,4,5]
16:26:30 <lambdabot>   2345
16:26:37 <ksf> (I *hate* iterate, for some reason)
16:27:06 <ksf> > sum . zipWith (\p n -> 10^p * n) [1..] $ reverse [2,3,4,5]
16:27:07 <lambdabot>   23450
16:27:15 <ksf> > sum . zipWith (\p n -> 10^p * n) [0,1..] $ reverse [2,3,4,5]
16:27:17 <lambdabot>   2345
16:27:26 <sipa> > read (concatMap show [2,3,4,5]) :: Integer
16:27:27 <lambdabot>   2345
16:27:40 <fosskers> you guys are wizards
16:27:46 <luite> sipa: hehe that's not the same
16:27:47 <c_wraith> sipa's cheating :)
16:27:50 <fosskers> can't wait til i have all that figured out
16:28:30 <c_wraith> sipa's algorithm would totally give a different answer for the list [2,13,4,5] :)
16:28:33 <luite> fosskers: it's not terribly difficult, you probably just need to do it a few times
16:28:59 <fosskers> luite: i was just getting pretty confused about what 'f' needed to be
16:29:13 <fosskers> the examples given in this book were just (*) or (+) pretty much
16:29:38 <fosskers> i get the concept, but the execution was a little fuzy
16:29:45 <c_wraith> > foldl (flip (:)) [1..5]
16:29:46 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [b])
16:29:47 <lambdabot>    arising from a use ...
16:29:58 <c_wraith> > foldl (flip (:)) [] [1..5]
16:29:59 <lambdabot>   [5,4,3,2,1]
16:30:09 <luite> fosskers: map is easier to read than fold by the way, so if you want to do something to each list element and sum the results, then you'd usually use: sum (map f xs), instead of a fold
16:30:53 <fosskers> luite: yeah eh? the exercise was calling for foldl, though
16:31:01 <c_wraith> :t Data.Traverseable.foldrM
16:31:02 <lambdabot> Couldn't find qualified module.
16:31:05 <fosskers> luite: and somehow ive come to think it a bad example, lol
16:31:19 <ion> fosskers: After encountering the 3 the accumulator should be 23, right? After encountering the 4 the accumulator should be 234, shouldn’t it? The first parameter of foldl is a function that takes the previous accumulator (e.g. 23) and the current iteratee (e.g. 4). For this, it should obviously return the previous accumulator (23) times ten (= 230) added to the current iteratee (4).
16:32:24 <ion> The return value of the function is going to be the accumulator value for the next iteration, or the result value of the entire function at the end of the input list.
16:32:25 <fosskers> moral of the story: use a closure?
16:32:42 <fosskers> because (\a n -> a*10 + n) worked beautifully
16:32:54 <luite> fosskers: nah wasn't that bad. do keep in mind that you'd often want to use foldl' instead of foldl
16:33:07 <aristid> @pl (\a n -> a*10 + n
16:33:07 <lambdabot> (line 1, column 18):
16:33:07 <lambdabot> unexpected end of input
16:33:07 <lambdabot> expecting letter or digit, variable, "(", operator, "+", "-" or ")"
16:33:09 <aristid> @pl (\a n -> a*10 + n)
16:33:09 <lambdabot> (+) . (10 *)
16:33:20 <fosskers> luite: haha don't tell me those things, im still getting my feet wet
16:33:22 <luite> fosskers: foldl can give you stack overflows sometimes
16:33:48 <fosskers> luite: i was just reading an article about how haskell is bogged by a million versions of fold(r/l) and map
16:34:04 <ksf> ...for different reasons, thouh.
16:34:26 <luite> fosskers: the folds are genuinely different, there's only one map for lists
16:34:44 <luite> but both functions have more general equivalents, that work on more types than just lists
16:34:50 <pmetzger> does lambdabot have documentation?
16:35:04 <merijn> pmetzger: What sort of documentation?
16:35:10 <pmetzger> any. :)
16:35:13 <merijn> You can PM her @help
16:35:34 <merijn> Source is also available, that probably has some docs as well
16:35:50 <fosskers> so: foldr -> goes all the way down, then winds back doing all the operations
16:35:58 <fosskers> foldl -> does all the operations as it goes
16:36:02 <luite> foldl does that actually
16:36:02 <fosskers> with said accumulator
16:36:08 <ksf> define "as it goes"
16:36:17 <merijn> pmetzger: http://haskell.org/haskellwiki/Lambdabot
16:36:19 <fosskers> "as it goes" = each step in the recursion
16:36:32 <luite> foldl f z [a,b,c,d]
16:36:34 <luite> oops
16:36:36 <luite> > foldl f z [a,b,c,d]
16:36:37 <lambdabot>   f (f (f (f z a) b) c) d
16:36:40 <luite> > foldr f z [a,b,c,d]
16:36:41 <lambdabot>   f a (f b (f c (f d z)))
16:36:53 <ksf> seen from the travelling down the spine or generating results side?
16:37:12 <luite> you see that the foldr has an f a (something) on the outside
16:37:16 <fosskers> yeah
16:37:32 <luite> so if f doesn't use its second argument, it can immediately compute its value
16:37:38 <luite> even for an infinite lists
16:37:46 <fosskers> oh
16:38:05 <pmetzger> @type map
16:38:05 <fosskers> when wouldnt it have a second argument?
16:38:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:38:12 <pmetzger> cool
16:38:33 <ksf> fosskers, it could just ignore it.
16:38:44 <ksf> ...for any reason you can think of.
16:38:52 <merijn> fosskers: short circuiting boolean logic for example
16:39:01 <ddarius> @src and
16:39:01 <lambdabot> and   =  foldr (&&) True
16:39:04 <merijn> if the first is true, no need to evaluate the second argument
16:39:11 <luite> fosskers: while outside expression of the foldl has as second argument the last element of the list. obviously that doesn't work for infinite lists
16:39:22 <fosskers> merjin: cool, thanks
16:39:46 <fosskers> luite: yeah
16:40:06 <fosskers> so -> foldl (+) 0 repeat 5
16:40:11 <fosskers> would cause problems?
16:40:27 <ksf> > foldl (+) 0 repeat 5
16:40:28 <lambdabot>   Couldn't match expected type `[a]'
16:40:28 <lambdabot>         against inferred type `a1 -> [a1]'
16:40:29 <luite> you need some parentheses there :)
16:40:34 <ksf> > foldl (+) 0 % repeat 5
16:40:35 <lambdabot>   Couldn't match expected type `[a] -> a' against inferred type `[t]'
16:40:37 <ksf> > foldl (+) 0 $ repeat 5
16:40:38 <fosskers> hm
16:40:42 <lambdabot>   mueval-core: Time limit exceeded
16:40:46 <fosskers> hahah
16:41:00 <fosskers> okay, and the difference between . and $ is still confusing me
16:41:00 <ksf> > foldl (+) 0 $ [1..100000]
16:41:04 <lambdabot>   mueval-core: Time limit exceeded
16:41:08 <ksf> > foldl' (+) 0 $ [1..100000]
16:41:09 <fosskers> they seem interspersed
16:41:09 <lambdabot>   5000050000
16:41:09 <luite> fosskers: but the foldr wouldn't work either, because (+) always consumes its second argument
16:41:13 <merijn> Cale had some nice diagrams showing folds on his website, but since his site went down they are gone :\
16:41:31 <MorpheusReject> how do you call it when you put stuff that are not general in code? like filenames and web urls
16:41:31 <fosskers> merjin: aww :(
16:41:32 <merijn> fosskers: Easy
16:41:37 <merijn> @src ($)
16:41:37 <lambdabot> f $ x = f x
16:41:40 <merijn> @src (.)
16:41:40 <lambdabot> (f . g) x = f (g x)
16:41:40 <lambdabot> NB: In lambdabot,  (.) = fmap
16:41:43 <FauxFaux> merijn: Also Vacuum.
16:41:54 <ksf> in the foldl case, lambdabot first transformed the list into a big expression in memory, then forced that expression.
16:41:58 <MorpheusReject> like, all the CONSTs
16:42:20 <ksf> MorpheusReject, evil.
16:42:22 <merijn> fosskers: It also helps to meditate on the type of .
16:42:33 <fosskers> function composition... yes
16:42:46 <merijn> $ is just for avoiding parenthesis, since we haskellers are allergic to those :>
16:42:56 <luite> and we love $ ;)
16:43:04 <fosskers> but it seems to me like . and $ mitigate the same problem...?
16:43:16 <fosskers> yeah the compiler yells at me all the time for trying them...?
16:43:18 <fosskers> *yet
16:43:21 <MorpheusReject> ksf: but it's much more comfortable
16:43:43 <ion> (potentially long expression) (another potentially long expression) → potentially long expression $ another potentially long expression
16:43:51 <merijn> . can be used for some of the problems $ is used for, but . also does unrelated things
16:44:00 <fosskers> map (*5) . reverse [1..10]
16:44:01 <ion> “\x → f (g x)” → “f . g”
16:44:08 <ion> Not really the same thing at all.
16:44:09 <MorpheusReject> ion: you've line wrapped here
16:44:35 <fosskers> map (*5) $ reverse [1..10]   ?
16:44:49 <ion> $ is especially nice when one of the potentially long expressions spans multiple lines.
16:44:50 <fosskers> the . there is piping the output, i get that
16:44:52 <merijn> fosskers: That tries to compose "map (*5)" with "reverse [1..10]" and the latter is not a function
16:45:17 <merijn> fosskers: Function application *always* binds more tightly then operators
16:45:24 <merijn> You'd want
16:45:28 <fosskers> oh, wait yeah. i see it now
16:45:40 <merijn> > map (*5) . reverse $ [1..10]
16:45:41 <fosskers> or do i?
16:45:44 <lambdabot>   mueval-core: Time limit exceeded
16:46:07 <merijn> hmm, odd...
16:46:10 <merijn> > map (*5) . reverse $ [1..10]
16:46:12 <ion> Try again.
16:46:13 <lambdabot>   [50,45,40,35,30,25,20,15,10,5]
16:46:22 <merijn> > (map (*5) . reverse) [1..10]
16:46:24 <lambdabot>   [50,45,40,35,30,25,20,15,10,5]
16:46:39 <fosskers> waaaaaait a miniute
16:46:45 <fosskers> hold the trains. and the phone. and the bus
16:46:57 <shachaf> > (.) ((*5).) reverse [1..10]
16:46:59 <fosskers> (reverse [1..10]) == reverse $ [1..10]   ??
16:47:00 <lambdabot>   [50,45,40,35,30,25,20,15,10,5]
16:47:05 <merijn> fosskers: Yes
16:47:11 <fosskers> sweet lord
16:47:13 <merijn> @src ($)
16:47:13 <lambdabot> f $ x = f x
16:47:16 <shachaf> Oh, whoops.
16:47:35 <merijn> $ has very low (lowest, even) priority of all operators
16:47:35 <fosskers> all has become clear
16:47:46 <fosskers> oh?
16:48:12 <fosskers> aaah so in:
16:48:14 <monochrom> "f . g $ x" = "(f . g) x"
16:48:24 <fosskers> map (*5) . reverse [1..10]
16:48:31 <fosskers> reverse [1..10] is not occuring first
16:48:36 <fosskers> or rather...
16:48:46 <ion> In what monochrom said the . binds to f and g more tightly than the $ to everything around it.
16:49:04 <ksf> and " " binds even tighter.
16:49:08 <monochrom> "f . g x" = "f . (g x)"
16:49:09 <ksf> :t reverse [1..10]
16:49:10 <lambdabot> forall t. (Num t, Enum t) => [t]
16:49:13 <fosskers> wait, why does reverse [1..10] need to be bracketed at all here?
16:49:17 <merijn> fosskers: . is getting two arguments, "map (*5)" and "reverse [1..10]", however "reverse [1..10]" is not a function.
16:49:21 <ksf> that's a list, and doesnt' fit as second parameter into
16:49:22 <fosskers> why doesnt the output pipe nicely?
16:49:26 <ksf> :t (.)
16:49:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:49:26 <monochrom> precedence
16:49:34 <ksf> :t Prelude.(.)
16:49:35 <lambdabot> Not in scope: data constructor `Prelude'
16:49:37 <ksf> :t Prelude..
16:49:38 <lambdabot> parse error on input `Prelude..'
16:49:42 <fosskers> aaah
16:49:47 <ksf> :t (Prelude..)
16:49:48 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:49:52 <ksf> (damn that syntax)
16:49:56 <monochrom> do not trust your eyes
16:49:59 <fosskers> merjin: but (reverse [1..10]) isnt a function either
16:50:04 <ion> Just like in 2*3+4 the * binds more tightly to 2 and 3 than + to its arguments, so it’s equivalent to (2*3)+4.
16:50:06 <merijn> fosskers: Whereas "map (*5) . reverse $ [1..10]" has $ getting two arguments "map (*5) . reverse" and "[1..10]"
16:50:34 <merijn> (Which means . gets "map (*5)" and "reverse" which are both functions)
16:50:54 <monochrom> you can write an expression and ask me to add redundant parentheses to show how it's parsed
16:51:05 <fosskers> aaah
16:51:05 <MorpheusReject> [03:05] <shachaf> > (.) ((*5).) reverse [1..10]
16:51:12 <copumpkin> ddarius: food?
16:51:16 <MorpheusReject> shachaf: that's extremely weird
16:51:20 <fosskers> okay okay
16:51:29 <parcs> > (*5) . [1..10]
16:51:31 <lambdabot>   [5,10,15,20,25,30,35,40,45,50]
16:51:33 <merijn> "map (*5) . reverse [1..10]" == "(map (*5)) . (reverse [1..10])"
16:51:36 <fosskers> map (*5) . reverse $ [1..10] 
16:51:48 <fosskers> IS (map (*5) . reverse) [1..10]
16:51:51 <MorpheusReject> that's extremely weird.
16:51:58 <merijn> fosskers: Yes
16:51:59 <fosskers> NOT map (*5) . (reverse [1..10])
16:52:11 <fosskers> that was confusing me
16:52:13 <parcs> MorpheusReject: it's because (.) is fmap in lambdabot, and fmap is map for lists
16:52:20 <ksf> ((map (*5)) . (reverse)) [1..10]
16:52:36 <parcs> so (*5) . [1..10] is (*5) `map` [1..10] which is map (*5) [1..10]
16:52:38 <fosskers> . needs functions
16:52:43 <MorpheusReject> parcs: oh. sorry then. nothing weird about that.
16:52:46 <fosskers> . needs functions is the bottom line
16:52:52 <merijn> fosskers: Yes
16:52:52 <ksf> well, yes.
16:52:58 <ksf> or, in lambdabot's case, any functor.
16:53:04 <merijn> :t (Prelude..)
16:53:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:53:08 <fosskers> dont say the word functor yet, im not there
16:53:19 <ksf> nono you're here. not there.
16:53:21 <merijn> Meditate on that signature :)
16:53:30 <ksf> and here is where we're going to blow your mind, right now.
16:53:40 <MorpheusReject> hey, what's this "forall" thing?
16:53:48 <ion> ksf: No, he’s not here *or* there, he’s in Japan.
16:53:53 <MorpheusReject> i don't see that in ghc
16:53:58 <fosskers> who told you >.>
16:54:05 <merijn> MorpheusReject: "For all possible types a we have: "
16:54:10 <ksf> you can write it with extensions, though.
16:54:18 <ksf> it's usually implicit.
16:54:50 <ksf> nagasaki, to be precise.
16:55:16 <MorpheusReject> (.) for me is like the human centipede
16:55:27 <MorpheusReject> well, connection points of the human centipede
16:55:39 <pmetzger> references to "the human centipede" will result in nuclear missile launches.
16:55:43 <ksf> that'd be fix.
16:55:49 <ksf> > fix error
16:55:50 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:55:50 <ion> fosskers: We’ve been tracking your movements for a while now.
16:55:57 <MorpheusReject> pmetzger: is that a common reference here?
16:56:09 <fosskers> shit, they're on to me!
16:56:12 <pmetzger> no. and I'd prefer that.
16:56:24 <pmetzger> it took me months to expunge the mere existence of that movie from my mind.
16:56:27 <fosskers> *starts pulling out mother boards like that scene from Goldeneye)
16:56:30 <copumpkin> human centipede, mmm
16:56:49 <copumpkin> a most excellent movie indeed
16:57:05 <fosskers> i was always boris in the n64 game
16:57:29 <ion> fosskers: How are things in Nagasaki, btw?
16:57:42 <danharaj> how do you ask ghc on the command line for its version number?
16:57:43 <sully> I was always oddjob; then we insituted a "no oddjob" rule
16:58:08 <jeffz> danharaj: like most programs, ghc --version
16:58:21 <MorpheusReject> hey, in portal they should have had a scene where Nameless Protagonist (were she named? i don't remember) pulls out the MOTHER boards... get it?
16:58:25 <Igloo> You might want "ghc --numeric-version"
16:58:36 <danharaj> jeffz: derp. mind fart
16:58:40 <danharaj> (thanks)
16:58:49 <danharaj> Her name is Chell.
16:58:58 <danharaj> And her tenacity is three standard deviations higher than the mean.
16:59:00 <djahandarie> Nagasaki? fosskers is in Japan?
16:59:00 <MorpheusReject> danharaj: -_- sorry then
16:59:05 <fosskers> ion: Fine
16:59:23 <fosskers> i just beat portal 2 the other day...
16:59:31 <fosskers> and yeah, i live in japan
16:59:35 <MorpheusReject> no spoilers
16:59:37 <fosskers> nagasaki prefecture but not nagasaki city
16:59:54 <fosskers> i work here but coding is my hobby
17:00:08 <fosskers> and functional programming seems like the bees knees these days
17:00:08 <ksf> well, damn those inaccurate dns entries.
17:00:13 <djahandarie> Are you Japanese? Or did you move there to work?
17:00:26 <MorpheusReject> fosskers: hey hey, did you write stuff useful?
17:00:33 <MorpheusReject> fosskers: or maybe, artsy useful?
17:00:39 <fosskers> what do you mean?
17:00:42 <merijn> MorpheusReject: Spoiler, it contains portals :>
17:00:42 <ion> ksf: Yes, they should provide everyone’s physical address accurately.
17:00:47 <MorpheusReject> fosskers: computer games
17:00:57 <fosskers> no ive never made a game
17:01:18 <MorpheusReject> merijn: oh uhm... wow! into xen?! wait, no. don't answer.
17:01:44 <danharaj> oi... doesn't seem like there's any guides to repa
17:01:49 <MorpheusReject> fosskers: what about things which you use?
17:02:14 * ksf would be content with a bug-free fallout game.
17:02:37 <co_dh> greeting . in ghci,  after you say :set -package blah , will the names in blah be imported ? 
17:02:48 <ksf> not necessarily bugfree as in "doesnt' crash at least once every three hours" but bugfree as in "the quest scripting is flawless"
17:02:49 <MorpheusReject> fosskers: do you commandline script?
17:02:52 <BMeph> danharaj: Who needs a guide, when they've written a paper on it? ;þ
17:02:54 <ddarius> ksf: If you didn't play games, you could just be content.
17:03:07 <danharaj> BMeph: there's a paper? I can't find that on Google :p
17:03:09 <fosskers> ive made an xkcd commandline app
17:03:20 <fosskers> im working on a unix-reddit interface
17:03:36 <MorpheusReject> fosskers: how do you use it?
17:03:38 <ksf> yay
17:03:49 <ksf> so I could automatically answer "NO U" to every post?
17:03:49 <danharaj> BMeph: I found it. Thanks for the hint :p
17:04:16 <fosskers> yeah you could
17:04:49 <MorpheusReject> fosskers: how does it work? what language?
17:04:51 <fosskers> its basically a combination of HTML parser with text browser
17:04:57 <fosskers> im writing it in python
17:05:04 <ksf> or pull random pics off 4chan and post it on r/pics
17:05:05 <fosskers> on account of thats my strongest language
17:05:11 <djahandarie> Haskell isn't too bad for shell scripting
17:05:23 <ksf> that'd be the first automatic, as well as highly talented, karma whore in the world.
17:05:26 <djahandarie> Relevant: http://donsbot.wordpress.com/2010/08/17/practical-haskell/
17:05:35 <ddarius> djahandarie: I would say most Haskell code wouldn't parse as shell.
17:05:40 <djahandarie> Hah
17:05:53 <djahandarie> I mean for the same domain of problems that shell scripting usually tackles :)
17:06:04 <MorpheusReject> fosskers: your mind will get totally flipped over soon
17:06:12 <fosskers> whys that?
17:06:17 <MorpheusReject> fosskers: haskell
17:06:21 <ksf> hmmm. we could use a cache for compiled scripts.
17:06:28 <fosskers> MorpheusReject:  haha well im liking it so far
17:06:29 <shachaf> djahandarie: Surely by "shell scripting" you meant "scripting a shell" -- i.e., generating shell scripts?
17:06:55 <MorpheusReject> fosskers: how long is your python unix-reddit code?
17:07:00 <fosskers> right now?
17:07:02 <ksf> my system would boot in 1ms less if the init scripts weren't written in sh!
17:07:11 <djahandarie> I don't know if there is sh DSL in Haskell
17:07:17 <MorpheusReject> fosskers: i'm curious because i've rarely written >100 lines -_-
17:07:23 <fosskers> not 300 lines yet
17:07:28 <ddarius> There's a few.
17:08:05 <MorpheusReject> haskell makes me write less code, so my line number is skewed :<
17:08:17 <fosskers> haha yeah i guess eh
17:08:53 <fosskers> two things: i think ive yet to hit the 'this is why functional programming is so different' stage
17:09:10 <fosskers> so far everything seems like just a spin on syntax with a little bit of philosophy
17:10:23 <merijn> fosskers: Well, if you already know python it is slightly less mind warping
17:10:42 <merijn> Because people go "functions are values!" and you're all like "yeah, so?"
17:10:57 <ddarius> merijn: That's true in most languages nowadays.
17:10:59 <fosskers> yeah passing functions around is old news
17:11:04 <merijn> Whereas C/Java people go "Oh My God! My mind is blown!"
17:11:12 <fosskers> c -> function pointers?
17:11:42 * ddarius doesn't consider higher order functions particularly "functional."
17:11:53 <monochrom> const is a function that satisfies const x y = x. for example
17:11:56 <merijn> I have to say coming from python the most awesome thing I learned in haskell was the type system and type classes
17:11:58 <monochrom> > const 4 'x'
17:11:59 <lambdabot>   4
17:12:12 <monochrom> the following blows some people's minds
17:12:13 <fosskers> merjin: yeah i agree that the type system is pretty cool
17:12:15 <merijn> Type classes are awesome
17:12:16 <pmetzger> real C programmers use function pointers constantly. 
17:12:23 <monochrom> > const 4 (div 1 0)
17:12:24 <lambdabot>   4
17:12:41 <fosskers> @type const
17:12:42 <lambdabot> forall a b. a -> b -> a
17:12:43 <MorpheusReject> fosskers: hey hey, consider (x, y)
17:12:46 <shachaf> > 4 (div 1 0)
17:12:47 <lambdabot>   4
17:12:57 <MorpheusReject> (i'm reading some guide now telling me to consider (x, y))
17:13:05 <fosskers> oh shit! lazy evaluation!
17:13:15 <MorpheusReject> fosskers: x can be computed first, y can be.. yah
17:13:15 <djahandarie> shachaf, -_-
17:13:38 <MorpheusReject> fosskers: x AND y an be computed in parallel
17:13:42 <pmetzger> I tried to teach my cat about lazy evaluation since I thought she'd like it, but she apparently thinks she can put off learning until she needs to know about it for some reason.
17:13:53 <merijn> pmetzger: :)
17:13:54 <fosskers> hahahah
17:14:12 <fosskers> guys, thanks for all the help
17:14:14 <fosskers> i gotta run though
17:14:21 <merijn> pmetzger: I told my advisor I'd have the measurements for our paper tomorrow, as long as he doesn't look at them >.>
17:14:25 <fosskers> *favourites this channel*
17:14:27 <MorpheusReject> fosskers: because it doesn't really matter. the computation's result is like... it was decided by teh laws of logic
17:14:35 * ksf is putting hiring pmetzger into a thunk wrapped in learnStrictnessAnalysis
17:14:49 <fosskers> > 4 || div 1 0
17:14:51 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
17:14:51 <lambdabot>    arising from a use of ...
17:14:51 <shachaf> pmetzger: Cats walk by themselves, and all places are alike to them.
17:15:20 <MorpheusReject> pmetzger: YAY! that's my philosophy to life, yo!
17:15:22 <merijn> fosskers: || wants booleans
17:15:27 <fosskers> right right. type system
17:15:41 <fosskers> 4 /= True :P
17:15:49 <merijn> > 4 /= 0 || div 1 0 /= 0
17:15:50 <lambdabot>   True
17:16:11 <merijn> Actually
17:16:23 <shachaf> ddarius: What do you consider to be "functional"?
17:16:40 <ddarius> Purity primarily.
17:16:42 <mauke> don't make me define === again
17:17:07 <fosskers> k guys, gotta run
17:17:09 <fosskers> ill be back
17:17:19 <fosskers> if all the radiation doesnt get to me
17:17:22 <aruckus> I am trying to write a quick primes finding function in haskell, but I want to cap the recursion at the square root of the number i am checking is prime. But haskell wont let me take the sqrt of an integer. Is there a better way of doing this? Here is some code. http://codepad.org/VjAe3Yn9 Line 4 has the commeted out line that I would like to do, but haskell no like.
17:17:34 <ksf> let x === y = (unsafeCoerce x :: Ptr ()) == (unsafeCoerce y :: Ptr ())
17:17:44 <merijn> aruckus: "fromIntegral"
17:17:55 <merijn> > sqrt (5:: Int)
17:17:56 <MorpheusReject> fosskers: :<
17:17:56 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
17:17:56 <lambdabot>    arising from a use of...
17:18:02 <merijn> > sqrt fromIntegral (5:: Int)
17:18:04 <lambdabot>   2.23606797749979
17:18:18 <mauke> aruckus: n > p*p
17:18:22 <merijn> > sqrt $ fromIntegral (5:: Int)
17:18:23 <lambdabot>   2.23606797749979
17:18:26 <fosskers> MorpheusReject: nagasaki is very far from all that reactor business
17:18:30 <fosskers> no problems
17:18:37 <danharaj> > floor $ sqrt (fromIntegral (5:: Int))
17:18:38 <lambdabot>   2
17:18:49 <MorpheusReject> fosskers: but there's food contamination
17:18:58 <danharaj> banana equivalent dose.
17:18:59 <merijn> :t sqrt
17:19:00 <MorpheusReject> fosskers: right?
17:19:00 <lambdabot> forall a. (Floating a) => a -> a
17:19:09 <MorpheusReject> danharaj: oh
17:19:11 <fosskers> MorpheusReject: nope. everything here is running at 100%
17:19:35 <merijn> aruckus: As you can see, sqrt expects Floats and Ints are not floats, but fromIntegral will turn an Int into a float for you
17:19:40 <MorpheusReject> fosskers: hmm..
17:19:41 <ksf> well... there's radioactive wild pigs in bavaria...
17:19:43 <fosskers> MorpheusReject: there may have been food contamination (a little bit) in tokyo a while ago, but i live 1000km from that
17:19:45 <ksf> (still)
17:19:47 <copumpkin> ddarius: dan and I are leaving prudential nowish
17:19:54 <copumpkin> ddarius: so Le's in maybe half an hour?
17:20:08 <danharaj> The nuclear issue in Japan is orders of magnitude less severe than the earthquake, which is also orders of magnitude less severe than the tsunami it caused.
17:20:08 <fosskers> MorpheusReject: don't believe western news
17:20:14 <danharaj> (or so I have been led to believe)
17:20:28 <MorpheusReject> fosskers: i don't know who and what to believe
17:20:38 <fosskers> MorpheusReject: believe me, and that nothing is wrong
17:20:41 <MorpheusReject> this is an ongoing event, so i really don't know
17:20:41 <aruckus> merijn thanks
17:21:11 <ksf> (chernobyl <-> munich is more than 1000 km)
17:21:23 <MorpheusReject> fosskers: well, i guess private guys with geigers would have made news about RADIOACTIVE PRODUCE longago
17:21:47 <MorpheusReject> fosskers: so it is safe
17:22:00 <fosskers> MorpheusReject: i feel absolutely no danger
17:22:14 <MorpheusReject> unless ninjas take them out long before they can post it online! :-D
17:22:43 <fosskers> alright, gotta go
17:22:47 <MorpheusReject> fosskers: bye
17:22:48 <fosskers> see you guys later
17:22:53 <fosskers> thanks for the help
17:23:28 <MorpheusReject> oh, right. how could i had forget what's purity.
17:23:37 <MorpheusReject> i have forget
17:24:30 <MorpheusReject> so now the banana radiation meme was spread even more?
17:25:34 <MorpheusReject> oh, i see. it's an xkcd thing
17:25:47 <danharaj> eh?
17:26:04 <MorpheusReject> xkcd had jumped the shark and landed on its belly years ago
17:26:21 <MorpheusReject> danharaj: https://secure.wikimedia.org/wikipedia/en/wiki/Banana_equivalent_dose#History
17:26:40 <Tyr42> and is installing lazerbeams on the shark
17:27:29 <MorpheusReject> how can it do that if its innads were spilled all over after the fall and were eaten by the shark?
17:27:30 <parcs> > 2.3 / 3.9
17:27:31 <lambdabot>   0.5897435897435898
17:27:51 <danharaj> that's an asinine line in the wiki page
17:28:13 <danharaj> neither xkcd nor slashdot is relevant today.
17:28:18 <danharaj> also xkcd has always sucked.
17:28:26 <MorpheusReject> danharaj: HIGH FIVE
17:28:39 <MorpheusReject> danharaj: let me recall that high five
17:28:40 <Nisstyre> danharaj, do you enjoy hating fun?
17:28:45 <MorpheusReject> xkcd was good
17:29:16 <MorpheusReject> that's why i'm so mad at randall for ruining it
17:29:24 <danharaj> Nisstyre: I made this video with my friend, tell me what you think: http://www.youtube.com/watch?v=IE3lIg6lXWM
17:29:47 <mauke> I wrote a shell script in haskell
17:30:10 <mauke> http://mauke.dyndns.org/stuff/haskell/sh.hs
17:30:12 <MorpheusReject> mauke: what does it do?
17:30:14 <Nisstyre> danharaj, liked
17:30:22 <danharaj> I hope that answered your question.
17:30:27 <Nisstyre> :P
17:30:58 <MorpheusReject> oh
17:31:09 <shachaf> mauke: poly.poly was better.
17:31:15 <mauke> ddarius: it was surprisingly hard
17:32:04 <hpc> mauke: it would have been even more amazing if it was a palindrome like the file name
17:32:27 <Nisstyre> danharaj, how long have you been using Haskell?
17:32:40 <MorpheusReject> that is insane.
17:32:45 <mauke> shachaf: what about http://mauke.dyndns.org/stuff/haskell/yes.hs ?
17:32:47 <danharaj> Nisstyre: I might be coming up on the year mark?
17:32:56 <Nisstyre> ah cool, I'm just starting
17:33:00 <danharaj> be warned
17:33:01 <Nisstyre> got 'Real World Haskell'
17:33:06 <danharaj> I can't go back to C++
17:33:10 <Nisstyre> I never used C++
17:33:13 <Nisstyre> I'm coming from python
17:33:18 <danharaj> you won't be able to go back to python.
17:33:26 <Nisstyre> danharaj, even functional python?
17:33:27 <danharaj> once you drink the kool-aid
17:33:35 <danharaj> well, true.
17:33:37 <danharaj> whatever the case
17:33:41 <Nisstyre> I've been using iterators, generators, lists, etc.. a lot
17:33:41 <danharaj> your python will never be the same
17:33:57 <Nisstyre> lazy python is actually pretty cool
17:34:00 <hpc> oh god: http://mauke.dyndns.org/stuff/haskell/hell.hs
17:34:07 <MorpheusReject> lazy python...?
17:34:16 <Nisstyre> MorpheusReject, python with lazy evaluation
17:34:29 <Nisstyre> using generators and iterators and such
17:34:36 <MorpheusReject> Nisstyre: exists?
17:34:39 <Nisstyre> yep
17:34:39 <aristid> Nisstyre: how can that work? I/O does not mix well with lazy evaluation
17:34:50 <Nisstyre> aristid, I know, it's not the greatest
17:34:52 <Nisstyre> mmap works ok
17:34:58 <tauntaun> I'm having trouble defining sub-sub-modules.  Some questions: 1) Can I not declare the name of a module that is more than one level deep, as in "module A.B.C.D"?  2) Must the directory hierarchy mirror the module hierarchy? And 3) Must the directory names be capitalized?
17:35:18 <shachaf> hpc: Doesn't work here.
17:35:24 * shachaf should be nervous about having just run that.
17:35:25 <danharaj> 2) Yes.
17:35:28 <mauke> tauntaun: 1) how am I supposed to answer negated questions? 2) yes 3) yes
17:35:42 <mauke> shachaf: x86 linux
17:35:56 <tomb__> getContents/hGetContents are lazy I/O, and they're great
17:36:03 <mauke> kill the witch
17:36:09 <hpc> hGetContents++
17:36:18 <hpc> even if you can't write to that handle anymore
17:36:34 <tauntaun> mauke: Thanks for the sass.  You're supposed to answer negated questions with (in this case) "Yes you can" or "No you can't."  Have a pleasant evening.
17:36:44 <tomb__> you actually can, I think
17:36:51 <MorpheusReject> guys, what should i write if i want to nail the monad concept?
17:37:00 <mauke> tauntaun: yes, you can
17:37:00 <shachaf> mauke: Yes, I guessed that.
17:37:12 <MorpheusReject> totally grok the haskell monad
17:37:15 <shachaf> Port it to amd64. :-)
17:37:21 <hpc> tomb__: no; getContents leaves the handle in a semi-closed state; you can't do anything else with it but keep reading contents
17:37:26 <danharaj> MorpheusReject: Write a parser using parsec. That'll help.
17:37:28 <hpc> tomb__: when you reach the end, it closes
17:37:44 <mauke> MorpheusReject: nothing; you should ignore "the monad concept"
17:37:47 <tauntaun> Then does anyone have any ideas why GHCI isn't letting me declare "module A.B.C" ?
17:38:00 <mauke> tauntaun: because you ghci isn't a file
17:38:02 <mauke> er
17:38:04 <mauke> s/you //
17:38:10 <hpc> tomb__: i forget where i read that; it's been a while since i looked at the docs for Handle
17:38:12 <tomb__> hpc: I just implemented a redis client library that makes requests by hPut-ing data to a semi-closed handle
17:38:21 <hpc> tomb__: huh
17:38:23 <MorpheusReject> mauke: is that one of those karate kid advices?
17:38:40 <tomb__> hpc: but you're right that the hPutContents doc says that
17:38:49 <tomb__> hpc: I was surprised that it worked
17:39:04 <tauntaun> mauke: the module is defined in a file.  I'm only using the repl to load it.
17:39:20 <mauke> tauntaun: what's the error message?
17:39:49 <MorpheusReject> hey, is there a game haskellers particularly fond of?
17:39:52 <tauntaun> mauke: "Parse error on input '.'"  This is the period that separates B from C, in "module A.B.C"
17:40:06 <mauke> o_O
17:40:07 <hpc> MorpheusReject: monadius is objectively fun
17:40:10 <Nisstyre> MorpheusReject, not much of a Haskeller, but I really like Baldur's Gate II
17:40:10 <hpc> it's a gradius clone
17:40:28 <mauke> tauntaun: how did you do that?
17:40:38 <monochrom> tauntaun: did you put that in a file? and loaded it with ":load"?
17:41:34 <tauntaun> yes
17:41:43 <tauntaun> specifically,
17:41:49 <tauntaun> ":load A/B/C.hs"
17:42:04 <tauntaun> ah wait
17:42:17 <tauntaun> I haven't defined the intermediate module B.
17:42:25 <tauntaun> That must be a problem, right?
17:42:35 <mauke> no
17:42:36 * tauntaun checks
17:43:08 <tauntaun> actually I can't define an intermediate module, because B is a directory
17:43:55 <hpc> sure you can
17:44:05 <tauntaun> hpc: how, as "B.hs"?
17:44:16 <hpc> A.hs, A/B.hs, A/B/C.hs
17:44:24 <hpc> you can import A, A.B, A.B.C
17:44:31 <tauntaun> OK, but is that arrangement required?
17:44:34 <monochrom> I just tried, it is done perfectly
17:44:53 <mauke> tauntaun: no
17:44:54 <hpc> tauntaun: just make a B.hs and you can import A.B
17:45:00 <hpc> dunno why A.B.C isn't working though
17:45:16 <monochrom> echo 'module D.B.Y where y=False' > D/B/Y.hs
17:45:26 <monochrom> (of course mkdir -p D/B first)
17:45:34 <monochrom> :load D/B/Y.hs works
17:45:53 <monochrom> :load D.B.Y also works if you like
17:46:38 <monochrom> both ghc 7.0.2 and 7.0.3
17:46:44 <MorpheusReject> http://www.pages.drexel.edu/~kmk592/rants/lazy-python/index.html
17:46:59 <tauntaun> just to be clear: is one required to defined B.hs in addition to the B directory?
17:47:06 <monochrom> 7.0.3 has a ghci "import" bug but we aren't even using it
17:47:12 <monochrom> no
17:48:04 <monochrom> mkdir -p D/B; echo 'module D.B.Y where y=False' > D/B/Y.hs; ghci D/B/Y.hs
17:48:08 <monochrom> try that
17:48:23 <jho> ey guys, is offtopic allowed here because the guys on #defocus are mean and take ages to voice you and i'm feeling talkactive now
17:48:53 <mauke> try #haskell-blah
17:49:30 <jho> thanks
17:57:07 <shachaf> mauke: quine.hs hardly counts.
17:57:22 <shachaf> Oh, you can run it with runghc. I guess you can argue that it does.
17:57:53 <mauke> you got quine'd
17:58:17 <tomb__> hey does anyone know to make a module re-export all of the symbols from a given module that it imports? without listing each symbol individually?
17:58:29 <shachaf> I like my #!/bin/cat quine.
17:58:36 <mauke> put 'module Bar' in the export list
17:58:51 <shachaf> It's harder to mess it up.
17:59:01 <mauke> shachaf: how about http://mauke.dyndns.org/stuff/c/quine.c
17:59:23 <mauke> it only requires string concatenation, and we all know C is excellent at strings
17:59:45 <monochrom> tomb__: like this: module Mine(module Yours) where import Yours ...
18:02:12 <tomb__> monochrom & mauke: perfect. thank you.
18:02:18 <monochrom> \∩/
18:09:13 <solrize> http://en.wikipedia.org/wiki/Oleg_Kiselyov   <--  Oleg already did it
18:09:41 <monochrom> hahah!
18:10:19 <hpc> at first i thought "wtf it has a talk page"
18:10:23 <hpc> then it was all headers
18:10:59 <aristid> solrize: that's not _the_ oleg tho?!
18:11:26 <sshc> Why does "mtl" use FunctionalDependencies?  Why doesn't it define, for example, MonadState without functional dependencies?
18:11:56 <solrize> he is everywhere and does everything.   did you hear about his jet propelled snowmobile?
18:12:56 <aristid> sshc: i think it helps with deducing the type of the function get, for example
18:12:57 <aristid> :t get
18:12:58 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
18:13:24 <aristid> sshc: without the fundep, you would always have to explicitly tell the compiler which type you actually want to get out
18:14:52 <acowley> does anyone know how to use emacs artist mode without a middle mouse button?
18:16:10 <sshc> aristid: I'm not sure I understand how that's an issue.  Could you exemplify?
18:17:36 <aristid> f :: StateT Int Double; f = do x <- get; return $ fromInteger i * pi
18:17:55 <aristid> without the fundep that would require you to tell it the type of x
18:18:21 <sshc> aristid: Do you mean "State"?
18:18:27 <aristid> i do
18:18:57 <sshc> Interesting.  I'll test that to confirm that.  Thanks for the example.
18:19:40 <sshc> aristid: Actually, that's not a problem provided that the type of "x" can be inferred from context, right?
18:20:04 <sshc> I'd expect it to be the case that, when you do "x <- get", you usually do something with "x".
18:21:06 <aristid> sshc: not always.
18:21:17 <aristid> sshc: why do you have a problem with functional dependencies?
18:21:42 <sshc> < aristid> sshc: not always. — To which sentence does that respond?
18:21:53 <aristid> <sshc> I'd expect it to be the case that, when you do "x <- get", you usually do something with "x".
18:22:18 <aristid> well you do something
18:22:21 <sshc> If you don't use "x", then it's redundant?
18:22:31 <aristid> but it may not be possible to infer the EXACT type.
18:22:32 <sshc> Well, yes, the type of "x" can't *always* be inferred
18:22:57 <aristid> fundeps resolve that pointless ambiguity.
18:23:07 <aristid> again, why do you ave a problem with them?
18:23:32 <sshc> I'm still writing
18:23:47 <sshc> < aristid> sshc: why do you have a problem with functional dependencies? — As I understand it, by removing the functional dependency, I would enable type-dependent lifting of the oprations ofState (ie, get and put)
18:24:22 <aristid> well in the specific case of MonadState this may work to some degree
18:24:42 <aristid> as long as you have a nested StateT with multiple different state types
18:24:49 <aristid> but there are two problems:
18:24:55 <aristid> 1. all state types need to be different
18:24:59 <sshc> For example, if I have multiple State's in the same monad stack, I expect that I'd be able to manage the different states individually depending on their type without having to mess with a bunch of explicit "lift"s
18:25:06 <monochrom> so that "StateT Int IO ()" is at the same time both "MonadState Int" and "MonadState String"?
18:25:32 <aristid> 2. nesting transformers deeply is a bad idea for performance reasons. use a single StateT with all the types in one combined type.
18:25:50 <aristid> monochrom: is your type incomplete?
18:26:29 <monochrom> complete. perhaps more than complete
18:26:43 <monochrom> we say "Maybe is a Monad", not "Maybe is a Monad Maybe"
18:26:51 <sshc> aristid: I've already talked about those two issues specifically in this channel before.  If you have logs, you can search for something like "sshc.*multiple.*states"
18:26:52 <aristid> monochrom: i don't see a point at which StateT Int IO () could be MonadState String
18:26:55 <monochrom> and in fact we don't say "Maybe () is a Monad either"
18:27:15 <monochrom> and so I should have said "StateT Int IO is MonadState String?"
18:27:19 <aristid> sshc: but nothing stops you from writing a new type class MonadState2 without a fundep.
18:27:50 <sshc> That's true.
18:27:52 <monochrom> you are right, there is no point, and it shows how removing the fundep is questionable
18:28:59 <aristid> sshc: i mean, the transformers themselves are not even in mtl. you don't have to use mtl to use the transformers...
18:39:20 <MuazinHeadache> in the :k thingie, what's a *, * ->* and * -> * -> *?
18:39:50 <sshc> aristid: Huh, I was wrong.  Removing the functional dependency doesn't let me manage inner state.  I still can only manage the outermost state.
18:39:54 <sshc> "No instance for (MonadState Integer (StateT Double (State Integer)))"
18:40:24 <sshc> aristid: Do you know why it fails with that?
18:40:42 <aristid> sshc: you need to have forwarding instances
18:40:47 <aristid> i guess those would be overlapping
18:43:38 <sshc> aristid: What do you mean by "forwarding instances", specifically?
18:44:43 <sshc> aristid: instance (MonadState s m) => MonadState (m) where{get = lift get; put = lift put}?
18:45:23 <sshc> Except that wouldn't work with just "m"
18:47:52 <sshc> aristid: I have a feeling "forwarding instances", whatever that means, isn't possible with mtl's MonadState
19:03:21 <monkeyking> i'm on ubuntu 11.04; I have ghc 7.0.2; how do I install X11-xft? (it complains about utf8-string, which I appear to ahve installed)
19:05:46 <sshc> monkeyking: I'd install cabal with "cabal-install", and then use cabal to install "X11-xft" (cabal update && cabal install X11-xft)
19:06:16 <monkeyking> cabal --version
19:06:17 <monkeyking> cabal-install version 0.10.2
19:06:17 <monkeyking> using version 1.10.1.0 of the Cabal library 
19:06:19 <monkeyking> is that not good enough?
19:06:34 <sshc> That should be fine
19:06:37 <sshc> monkeyking: cabal install X11-xtf
19:06:44 <sshc> s/tf/ft/
19:07:04 <sshc> monkeyking: cabal should resolve the dependencies nicely if you only give it one package at a time
19:07:22 <monkeyking> cabal update
19:07:22 <monkeyking> Downloading the latest package list from hackage.haskell.org
19:07:23 <sshc> aristid: Again, I request that you clarify what is meant by "forwarding instances"; you said "you need to have forwarding instances".
19:07:46 <monkeyking> sshc: it's working nw; thanks
19:19:08 <dylukes> oh god...
19:19:14 <dylukes> learning common lisp at 10:30 ._.
19:19:18 <dylukes> macros, splices
19:19:21 <dylukes> god my head.
19:19:22 <dylukes> >_>
19:19:42 <shachaf> ?
19:19:45 <tauntaun> Newbie Q: why is the repl giving me "Couldn't match expected type `Int' against inferred type `Integer'"
19:20:11 <shachaf> tauntaun: Becuase you're using an Int as an Integer.
19:20:16 <shachaf> Or the other way around, I can never remember.
19:20:32 <ski> (the other way around)
19:20:37 <tauntaun> shachaf: yes, I surmised as much.  But what is the fix?
19:20:43 <shachaf> @ty fromIntegral
19:20:44 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:20:49 <shachaf> Or give us more context.
19:21:05 <shachaf> So we can say something like "use genericLength instead of length".
19:21:14 <tauntaun> let a = array ((0,0),(1,1)) [((0,0), 1.0), ((0,1),2.0), ((1,0),3.0), ((1,1),4.0)]
19:21:23 <ski> or provide a more polymorphic signature ..
19:21:24 <tauntaun> If I do "det a" I get the error.
19:21:42 <tauntaun> Are you familiar with the signatures of Array and det?
19:21:52 <ski> @type array
19:21:52 <tauntaun> oops
19:21:53 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
19:22:02 <tauntaun> I'm using Doubles in the example I just pasted.
19:22:10 <shachaf> dylukes: Aren't macros supposed to be the simplest thing in LISP?
19:22:13 <tauntaun> oh, actually it doesn't matter.
19:22:24 <tauntaun> The complaint is about the indices.
19:22:40 <ski> tauntaun> :t det
19:22:57 <tauntaun> det :: Array (Int, Int) Double -> Double
19:23:39 <ski> why not `det :: (Integral i,Fractional n) => Array (i,i) n -> n', or something like that ?
19:23:42 <tauntaun> I really don't know why those integers are being typed as Ints and not Integers.
19:23:57 <tauntaun> ski: I didn't write det; it's part of the DSP package.
19:24:04 <ski> oh, ok
19:24:13 <ski> well, give an explicit type signature for `a'
19:24:23 <tauntaun> ah
19:24:34 <ski> you get a monomorphic one because you have a value binding, and the DMR kicks in
19:25:15 <ski> but you can give an explicit signature (with `Int' instead of `Integer' if you want, or a polymorphic one, using `Integral i => ...')
19:25:32 <tauntaun> what's DMR
19:25:51 <ski> (you can also disable the DMR with `{-# LANGUAGE NoMonomorphismRestriction #-}')
19:26:01 <ski> the Dreaded Monomorphism Restriction
19:26:17 <djahandarie> щ(ﾟдﾟщ)
19:26:36 <ski> it's a rule that says that bindings that are syntactically value (as opposed to function) bindings can't be overloaded, unless you give an explicit signature
19:27:02 <ski> lots of people dislike that rule, and you can disable it in GHC if you want (with the above pragma i mentioned)
19:27:14 <tauntaun> thanks
19:27:23 <ski> (the rule was supposed to make code easier to reason about for newbies)
19:27:36 <pmetzger> λ : the ultimate food processor
19:28:01 <shachaf> ghci doesn't accepts {-# LANGUAGE #-} pragmas. :-(
19:29:52 <monochrom> at ghci prompt use :set -XNoMonomorphismRestriction
19:30:07 <monochrom> or -XNomNomNomYummy
19:30:13 <djahandarie> Or start it with ghci -XNoMonomorphismRestriction
19:31:43 <solrize> hey, does anyone know how cons works in the threaded rts?  is there a lock around the free pool or what?
19:32:49 <mikmorg> is there an easy way to evaluate two expressions and have the function be the result of the second?
19:33:05 <shachaf> monochrom: Yes, but it's not the same.
19:33:24 <shachaf> mikmorg: You mean seq?
19:33:42 <shachaf> > seq undefined 5
19:33:43 <lambdabot>   *Exception: Prelude.undefined
19:34:02 <mikmorg> probably :)
19:34:16 <mikmorg> yes, exactly.. thank you!
19:34:16 <solrize> mikmorg, what are you trying to do?
19:34:43 <solrize> are you just getting started with haskell?
19:35:01 <solrize> your question looks like something someone might ask if they wanted the first expression to do a side effect
19:35:23 <mikmorg> yeah... i am
19:35:25 <solrize> which in haskell you'd only do by sequencing in IO or the like
19:35:35 <solrize> do { print "hello"; print "world" }
19:35:40 <solrize> > do { print "hello"; print "world" }
19:35:44 <lambdabot>   <IO ()>
19:35:44 <solrize> oops
19:35:56 <mikmorg> grah yeah, you're probably right...
19:36:03 <shachaf> > do { putStr "<IO"; putStrLn " ()>" }
19:36:03 <solrize> expressions (as opposed to i/o actions) in haskell don't have side effects
19:36:04 <lambdabot>   <IO ()>
19:36:09 <ion> In that case, the <* and *> combiners are useful. The memory rule: the side effects happen from left to right; the arrow points to the one whose result value applies.
19:36:26 <solrize> so combining them the way you're asking doesn't make sense
19:36:42 <mikmorg> hm
19:36:46 <solrize> if it's an i/o action you'd probably just use do
19:36:56 <solrize> what side effect are you trying to write?
19:37:01 <monochrom> seq (putStrLn "hi") (putStrLn "hello") means something you don't expect
19:37:19 <ion> ghci> putStr "a" *> return 42 <* putStr "b"
19:37:19 <ion> ab42
19:37:20 <solrize> right, you'd use >> instead of seq
19:37:32 <shachaf> mikmorg: Yes, seq is something that want to avoid except in special cases.
19:37:58 <solrize> if you have two actions a and b, you can do both with (a >> b)
19:38:14 <mikmorg> that does make sense.. this is my first functional language so i'm still trying to switch my mindset from imperitive languages for the past 15 years
19:38:19 <solrize> >> in IO is sort of like semicolon in an imperative language
19:39:03 <Axman6> in do notation, they're almost exactly the same too
19:42:31 <ion> solrize: In Haskell, an IO action is just a value like any other. Things like print "foo" or readFile "/etc/motd" don’t themselves do anything but return such a value which represents a promise to do side-effectful computation and generate a result value. Only when an IO action is assigned to ‘main’ (directly or indirectly) the runtime system actually runs the IO actions.
19:44:17 <solrize> yes i know that, i think you're talking to mikmorg :)
19:44:24 <ion> Hah, whoops
19:46:44 <ion> mikmorg: When you have two IO actions ‘a’ and ‘b’ you can do ‘a >> b’ to combine them to a new IO action that (when finally executed) runs ‘a’, ignores its result value, then runs ‘b’ and results in its result value: the combined IO action ‘print "foo" >> readFile "/etc/motd"’ prints "foo" and has the contents of /etc/motd as its result value.
19:48:13 <ion> :t print "foo"
19:48:14 <lambdabot> IO ()
19:48:57 <ion> That means it’s an IO action that results in () (since print doesn’t have a meaningful result value, we only use it for its side effect).
19:49:02 <ion> :t readFile "/etc/motd"
19:49:03 <lambdabot> IO String
19:49:16 <ion> That means it’s an IO action that results in a string (the contents of the file).
19:49:26 <ion> :t print "foo" >> readFile "/etc/motd"
19:49:27 <lambdabot> IO String
19:49:55 <ion> And finally, this action results in the string generated by readFile "/etc/motd".
19:50:15 * applicative wonders, what is that string?
19:50:32 <ion> It’s obviously "Welcome to Ubuntu 11.04 (GNU/Linux 2.6.38-8-generic-pae i686)\n\n * Documentation:  https://help.ubuntu.com/\n\n37 packages can be updated.\n0 updates are security updates.\n\n"
19:51:24 * applicative is getting: *** Exception: /etc/motd: openFile: does not exist (No such file or directory)
19:52:23 <ion> Strange. It’s almost as if readFile arbitraryFilename doesn’t result in the same value on all systems.
19:52:57 <shachaf> applicative: Well, do you get "*** Exception: /etc/motd: openFile: does not exist (No such file or directory)" when you log in?
19:53:35 <applicative> shachaf, maybe i can arrange for that
19:54:18 <applicative> "man motd" is telling me about it.  i think the system administrator, viz. myself, is a little lazy.
19:58:57 <tauntaun> Has anyone here played with the Matrix package?
20:03:11 <applicative> Matrix, which Matrix package?
20:14:22 <mikmorg> if i have data Foo=Foo { bar :: M.Map Int String, baz :: String }, and I want a function to modify Foo's bar map to insert, how can i make this read better? addBar f i s = Foo (M.insert i s (bar f)) (baz f)
20:15:19 <sshc> mikmorg: See fclabels, the package
20:15:58 <sshc> mikmorg: There's a way to do it without fclabels using record syntax, but it's not first class it can get pretty messy.
20:16:23 <mikmorg> sshc: thanks. is this a problem that creeps up a lot?
20:16:45 <mikmorg> aka. modifying a single member meaning you have to manually copy the ignored members?
20:16:53 <mikmorg> seems inefficient
20:18:14 <mikmorg> er oh
20:18:23 <jeffz> addBar f i s = f { bar = M.insert i s (bar f)}
20:18:25 <jeffz> if i'm not mistaken
20:18:50 <mikmorg> ooh
20:19:13 <mikmorg> really; so f {} is syntax for modifying then
20:19:21 <jeffz> well, producing a new one from the old
20:19:25 <jeffz> not modifying
20:19:26 <mikmorg> yeah, gotchya
20:19:33 <mikmorg> thanks a ton
20:34:13 <ion> mikmorg: With fclabels, insertBar f i s = modL bar (M.insert i s) f
20:34:59 <mikmorg> oooh
20:35:01 <mikmorg> awesome
20:35:04 <mikmorg> thanks
20:47:27 <ion> mikmorg: Btw, if you put f as the last parameter (‘insertBar i s f = modL bar (M.insert i s) f’ or just ‘insertBar i s = modL bar $ M.insert i s’) you can compose insertBars like insertBar 43 "quux" . insertBar 42 "bla" $ foo
20:54:13 <mikmorg> ion: Thanks, i noticed that a bit ago... think i'll get the hang of this ;)
20:54:21 <mikmorg> good night!
20:54:34 <ion> (And incidentally with Data.Functor.Syntax, ‘insertBar = modL bar .: M.insert’)
20:55:44 <mikmorg> oh that's sweet
20:56:09 <mikmorg> geeze though
20:56:35 <mikmorg> the amount of functional syntax in this language... omg.
20:56:48 <mikmorg> this is gonna take a while :/
20:57:25 <mikmorg> thanks for your help though
20:57:29 <mikmorg> later.
20:57:54 <ion> The amount of syntax in this language is quite small, but the amount of abstraction any code (including libraries) can provide is quite great. :-)
20:58:19 <ion> (f . g) a = f (g a)
20:58:25 <ion> (f .: g) a b = f (g a b)
20:58:33 <ion> That’s what .: basically means.
20:58:54 <ion> Function composition where the second one takes two parameters instead of one.
21:10:38 <solrize> "implementing STM in Haskell was done over a long weekend by SPJ"   <--- izzat true?
21:25:03 <NemesisD> anyone ever use authenticate?
21:26:12 <pnema> Hi All. Looking for developers interested in language development. We are working on a new language: Falcon (www.falconpl.org or #falcon).  If you like challenges check it out
21:27:00 <solrize> Falcon provides six integrated programming paradigms: procedural, object oriented, prototype oriented, functional, tabular and message oriented. -->   i'm not sure you're in the right channel ;)
21:27:20 <ion> :-)
21:27:40 <ion> Yay, another language with mutation of data.
21:27:49 <djahandarie> I've never seen one like that!
21:28:18 <kmc> are we still talking about 'paradigms'?
21:28:31 <djahandarie> Haha yes, kmc was summoned
21:28:34 <kmc> i thought those went obsolete like 30 years ago
21:28:38 <kmc> :D
21:28:45 <pnema> Just throwing it out there for those that may be interested, wrong group to do that I see :)
21:28:53 <ion> Or “yay, another CLispScript”, borrowing a phrase from http://www.jerf.org/iri/post/2908
21:28:58 <solrize> yeah, we're into the new paradigm of "non-paradigmatic programming"
21:30:14 <djahandarie> pnema, come in here with a language sharing some of Haskell's ideals and you'd probably get a better response
21:30:33 <kmc> troll'd
21:30:39 <pnema> tough crowd!
21:30:47 <djahandarie> That wasn't meant to be snarky
21:31:14 <pnema> But I do like haskell. Lots of great stuff
21:31:58 <djahandarie> Anyways, there are plenty of PL folks in here so you might still end up finding someone interested
21:32:59 <pnema> Yup, targeting those peeps, sorry to bug all others
21:34:02 <pnema> take care
21:34:26 <Axman6> i remember looking ay falcon a while ago
21:34:32 <luite> hehe raw loop speed
21:36:33 <Axman6> the example on the homepage is pretty confusing
21:36:46 <jeffz> falcon doesn't use a dvcs, minus ten points!
21:38:16 <luite> I'm not quite sure what new things (or unique combination of old things) falcon brings to the table
21:38:16 <pnema> jeffv u mean: distributed version control
21:44:17 <ddarius> copumpkin: You just get back?
21:44:45 <solrize> list = [ "person", 1, 3.5, int( "123" ), var1 ]
21:44:59 <solrize> list3 = list[0:3]   // "person", 1, 3.5
21:45:02 <solrize> looks like python
21:45:06 <solrize> latent types
21:45:20 <solrize> the index 0 is the first element, and the index 1 (or -1) is the last.
21:45:25 <solrize> that is a huge bug in python
21:45:26 <pnema> thanks for that link (its a good read): http://www.jerf.org/iri/post/2908
21:45:36 <ddarius> So any nice, fast quasi-random number generators on Hackage?
21:45:46 <solrize> mersenne twister is very fast
21:45:59 <ddarius> solrize: And also not a quasi-random number generator.
21:46:06 <ddarius> And also the fast bindings aren't nice.
21:46:09 <solrize> what do you mean by quasi-random?
21:46:16 <ddarius> @google quasi-random
21:46:17 <lambdabot> http://en.wikipedia.org/wiki/Low-discrepancy_sequence
21:46:17 <lambdabot> Title: Low-discrepancy sequence - Wikipedia, the free encyclopedia
21:46:58 <solrize> ddarius, MT doesnt satisfy that?  i thought it was supposed to pass most statistical tests
21:47:03 <solrize> it's not a cryptographic rng
21:47:22 <solrize> i think somebody wrote a monadrandom wrapper for AES if you want that
21:47:45 <ddarius> solrize: Quasi-random is a different criteria than pseudorandom.  It's "less" random, but more "uniform."
21:48:52 <solrize> oh i see, for small n you want less clustering than an actual random sequence would give you
21:49:34 <illlogic> Hi all. I'm trying to figure out why read returns a instead of Maybe a. I'm trying to read an Integer, but I'd like to do it safely. There's no isInteger or isInt. Just isNumber for a single Char. What am I missing here?
21:49:46 <solrize> http://en.wikipedia.org/wiki/Constructions_of_low-discrepancy_sequences
21:49:49 <solrize> those look code-able
21:50:54 <dolio> I got mugged in Boston!
21:50:58 <dolio> By ddarius!
21:51:06 <solrize> ?
21:51:25 <djahandarie> Hahaha
21:51:35 <ddarius> I'm not sure if we were ever technically in Boston, but we might have been when we were on Commonwealth.
21:51:44 <djahandarie> I can't keep track of this mugging anymore...
21:51:54 <jeffz> illlogic: consider using parsec or another parsing package
21:52:22 <dolio> It's all Boston to me.
21:52:26 <dolio> Don't tell the natives.
21:53:36 <ddarius> I don't know if I know any Boston natives.
21:53:48 <jeffz> illlogic: or, you might be interested in 'reads' rather than 'read'
21:54:03 <ddarius> @hackage safe
21:54:03 <lambdabot> http://hackage.haskell.org/package/safe
21:55:24 <pnema> ok peeps chat wit ya all later, thanks for the time
21:56:54 <illlogic> jeffz: really? I would think that there would be something in between parsing text and accepting exceptions, and jumping all the way to a parsing framework
21:57:50 <jeffz> > reads "42a" :: [(Int, String)]
21:57:51 <lambdabot>   [(42,"a")]
21:58:04 <jeffz> illlogic: ddarius pointed out the safe package too.
21:59:01 <illlogic> oh sorry, didn't realize that was for me. thanks ddarius 
22:00:30 <copumpkin> ddarius: yep!
22:00:58 <illlogic> so, and I'm sorry to belabor the point, but what is read even good for? when you're absolutely sure that your text is what you expect? like if you wrote the file ourself?
22:01:17 <illlogic> I'm a beginner, but I can't imagine even wanting to use it
22:01:24 <ion> “Jumping all the way to a parsing framework” makes it sound like a bvigger deal than it actually is.
22:02:03 <illlogic> ion: ok. I've not looked into parsec, but my impression was that it was sortof heavy duty.
22:02:04 <jeffz> illlogic: read is useful if you derive both Read Show for things
22:04:44 <jeffz> it's not really meant for user input, I've used 'reads' for user input before since you can pattern match on an empty list for parse failure, using parsec isn't really that hard either though.
22:07:05 * ddarius wrote a parser for the lambda calculus in three lines of code using only pattern matching and one or two built-in functions.
22:08:03 <ddarius> Where by "built-in" I mean Prelude functions here.
22:09:31 <dolio> I wrote a Haskell lexer in one token using a built-in function.
22:10:31 <ddarius> @index lex
22:10:32 <lambdabot> Text.Read, Prelude, Text.Read.Lex
22:13:10 <koninkje_away> illlogic: attoparsec is a bit less heavy than parsec, and still eminently powerful enough for most parsing
22:13:10 <lambdabot> koninkje_away: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:13:25 <djahandarie> copumpkin, it worked! ;)
22:13:35 <djahandarie> ...
22:13:43 <illlogic> it just hit me how cool lambdabot is :)
22:13:47 <djahandarie> copumpkin, it worked! ;)
22:13:48 <copumpkin> djahandarie?
22:14:00 <djahandarie> Your @telling of koninkje_away
22:14:14 <ion> An example of parsing integers consisting of digits only: > let p :: Parser Integer; p = read <$> many1 digit in parse (p <* eof) "" "0123"
22:14:17 <ion> Right 123
22:14:43 <dolio> Oh right, the comic.
22:16:08 <koninkje> copumpkin: So the short answer is that free semirings aren't graphs per se, though they're closely related
22:16:45 <koninkje> You have to get the graph into a normal form in order to abstract over the equalities that semirings impose
22:16:53 <ion> You get nice error messages from parse errors, too.
22:16:55 <copumpkin> ah, yeah
22:17:01 <koninkje> Namely acyclic DFA, IIRC
22:17:17 <koninkje> er, acyclic *minimal* DFA
22:17:45 <ion> line 1, column 2: unexpected "x", expecting digit
22:18:10 <koninkje> Which is the same as just thinking of free semirings as the language produced by such an automaton (since sets of strings normalize themselves)
22:19:27 <ion> illlogic: ↑
22:21:36 <koninkje> copumpkin: another benefit of thinking of free semirings as the languages rather than the automata is that it works around the corner cases where there are multiple minimal automata but no unique minimum
22:22:51 <copumpkin> ah, fair enough
22:23:05 <copumpkin> how does that fit in with the language-like seminearrings?
22:23:40 * djahandarie wonders who named seminearrings
22:23:49 <ion> :t Text.Parsec.Prim.parse -- I take it lambdabot doesn’t import Parsec?
22:23:49 <lambdabot> Couldn't find qualified module.
22:24:12 <copumpkin> semin earrings
22:25:14 <koninkje> hmm, I haven't thought about that one.
22:25:38 <koninkje> One major difference is that (+) isn't commutative, so it's not union
22:26:07 <tomb__> hey, does anyone know if a lazy string containing, e.g., "abc" will always pattern match "abc", even if contains multiple chunks?
22:26:22 <tomb__> lazy bytestring, rather
22:26:55 <tomb__> this is my first time using OverloadedStrings with lazy bytestrings
22:29:20 <dolio> Micro Center has significantly more locations than I thought.
22:29:34 <koninkje> copumpkin: the free near-semiring has to be something like PCP tilings, excepting that they can have as many rows as they like
22:29:52 <copumpkin> I hear PCP is scary
22:30:20 * koninkje loves it when people prove type systems undecidable by encoding the PCP in them
22:31:38 <solrize> pcp?
22:32:04 <koninkje> http://en.wikipedia.org/wiki/Post_correspondence_problem
22:33:07 <koninkje> A tile is essentially a pair of strings, where (a,b)*(c,d) = (ac,bd)
22:33:35 <koninkje> so we'd generalize that to arbitrary widths, but still unstructured like tuples
22:34:10 <koninkje> Though the (*) would be more like the table-join operation, or a cartesian product
22:37:11 <dolio> Don't tell edwardk. He'll start using them at work.
22:40:10 <koninkje> That's actually a rather interesting idea there, thanks for bringing it up copumpkin 
22:41:04 * koninkje wonders what it means that there's no known 1 element...
22:42:15 <copumpkin> koninkje: np, this free structure stuff is pretty fascinating :) I'll compose another rage comic eventually when I get more revelations!
22:42:53 <koninkje> I'm not sure I can really think of what near-semirings would be good for in my area of research
22:43:20 <copumpkin> what is your area of research? the only exposure I've had to them was in ken shan's series of blog posts
22:43:45 <koninkje> computational linguistics
22:44:09 <koninkje> more specifically, applying type theory, category theory, etc, to computational linguistics
22:44:45 <copumpkin> you've seen ken shan's blog posts I hope!
22:45:08 <koninkje> I've seen a few of them, not recently though
22:45:15 <copumpkin> and/or Dylan I guess
22:45:18 <copumpkin> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
22:45:22 <copumpkin> that's the first of four iirc
22:46:54 <koninkje> Yes I could see how they'd be used there
22:47:22 <koninkje> it's just that for most of the stuff I do, having a non-commutative (+) doesn't make a whole lot of sense
22:47:33 <copumpkin> it's a pretty fun series of posts
22:47:44 <copumpkin> not really sure how I'd have solved that problem before reading it
22:47:59 <copumpkin> with much thought I guess :P
22:48:56 <koninkje> Hmm, his version of seminearring has a 1, whereas wikipedia's doesn't...
22:49:35 <ddarius> We must now call it seminearringwithunit.
22:52:36 <dolio> Wouldn't it be more highfalutin to say "unital"?
22:55:30 <shachaf> "united"?
23:01:28 <koninkje> copumpkin: with Ken's unital definition, the free seminearring is almost the same as the free semiring with the set of words replaced by a list of words. The one-sided distribution is the only other difference
23:07:36 <koninkje> Well, I'm off to bed
23:07:48 <copumpkin> cool
23:07:52 <copumpkin> thanks for the information :)
23:08:43 <luite> hmm it took me a while to realize that you guys weren't talking about semiearrings...
23:12:21 <tomb__> to answer my question from above, a lazy bytestring like `Chunk "a" (Chunk "bc" Empty)` does pattern match "abc" under OverloadedStrings, somehow
23:12:56 <tomb__> though I don't see how that's possible if pattern matching is based on data constructors
23:13:40 <copumpkin> I'd imagine with overloaded strings, strings in patterns are just equality guards?
23:13:42 <copumpkin> not sure
23:15:08 <tomb__> I guess that must be it
23:20:22 <shachaf> copumpkin: Yep.
23:31:03 <mjrosenb> how does chunk work?
23:31:15 <mjrosenb> that seems like it should require backtracking
23:38:43 <danharaj> Can anyone explain to me how to write an Unbox instance for the Vector library for a one-constructor type whose elements are all Unbox?
23:48:58 <ion> ghci> "False" || 1.5 + "2.4" > 0  -- php?
23:48:58 <ion> True
23:49:14 <danharaj> dear god why can you do that
23:49:34 <danharaj> what profane magic are you doing
23:49:54 <ion> OverloadedStrings and a couple of stupid IsString instances where fromString = read :-P
23:55:20 <ion> <trollface>
23:55:30 <danharaj> oh man
23:55:35 <danharaj> I think I just had an "aha!" moment
23:55:41 <danharaj> and Repa is looking amazing.
