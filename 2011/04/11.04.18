00:00:30 <roconnor> ah opps
00:00:37 <roconnor> ChongLi: there are no lists in your code
00:00:38 <shachaf> What's a compact way to say "all the elements of this array are equal"?
00:00:41 <shachaf> Er.
00:00:45 <shachaf> By array I mean list.
00:00:55 * shachaf blames this confusion on roconnor.
00:00:56 <ChongLi> roconnor: sure, but I'd like to build one
00:01:05 <luqui> shachaf, and $ zipWith (==) xs (tail xs)
00:01:27 <shachaf> Hmm... I guess.
00:01:30 <ChongLi> the list [a,b,aa,ab,ba,bb]
00:01:53 <shachaf> Seems weird to compare them to their neighbor rather than all to the first element, but I suppose it works.
00:02:15 <ChongLi> well, not sure how else it'd work
00:02:18 <luqui> shachaf, allEqual (x:xs) = all (x ==) xs ?
00:02:25 <roconnor> ChongLi: like concat [[(p ! i) + j,(p ! (i+1) + j] | (i,j) <- [(x,y), (a,z), (b, z)]]
00:02:42 <shachaf> luqui: Sure, and also a case for []. But that's not compact anymore. :-)
00:02:48 <shachaf> Your way works, anyway.
00:02:53 <roconnor> ChongLi: or do { (i,j) <- [(x,y), (a,z), (b, z)]]; return [(p ! i) + j,(p ! (i+1) + j] }
00:02:53 <rothwell> http://okmij.org/ftp/Haskell/Zipper1.lhs   <- this oleg post references a second part, but it doesn't seem to exist... anyone got it?
00:02:59 <luqui> shachaf, well, actually my case fails for the empty list too
00:03:16 <luqui> er wait maybe not
00:03:21 <luqui> > zipWith (==) [] undefined
00:03:22 <lambdabot>   []
00:03:26 <luqui> hooray it's actually ok!
00:03:53 <shachaf> Yep.
00:04:15 <roconnor> > zipWith (==) [] (undefined:[()])
00:04:16 <lambdabot>   []
00:04:24 <roconnor> @type zipWith (==) [] (undefined:[()])
00:04:25 <lambdabot> [Bool]
00:04:31 <roconnor> ah right
00:04:53 <shachaf> @pl \foo -> zipWith f foo (tail foo)
00:04:53 <lambdabot> ap (zipWith f) tail
00:05:01 <luqui> follows from monotonicity?  or were you checking defaulting?
00:05:03 <shachaf> That's such a nice idiom.
00:05:47 <luqui> :t zipWith (==) <*> tail
00:05:47 <lambdabot> forall a. (Eq a) => [a] -> [Bool]
00:06:10 <luqui> purdy
00:06:18 <ddarius> > zipWith (==) undefined []
00:06:19 <lambdabot>   *Exception: Prelude.undefined
00:09:18 <ChongLi> roconnor: it works!
00:09:34 <ChongLi> thanks
00:10:05 <roconnor> ChongLi: there are a couple other variations
00:10:27 <roconnor> ChongLi: I think this would be most useful: [((p ! i) + j,(p ! (i+1) + j) | (i,j) <- [(x,y), (a,z), (b, z)]]
00:10:50 <ChongLi> is it possible to make it not depend on a or b?
00:10:59 <ChongLi> just x y z and p
00:11:00 <ChongLi> ?
00:11:30 <roconnor> ChongLi: well, since a and b occur in your hpaste and your result depends on them, I don't see why you expect to be able to do it without depending on a and b
00:11:40 <roconnor> oh wait
00:11:46 <roconnor> a and b were your previous values
00:11:47 <roconnor> heh
00:11:50 <roconnor> I totally missed that
00:12:44 <roconnor> ChongLi: iterate (\(i,j) -> ((p ! i) + j,(p ! (i+1) + j)) (x,y)
00:12:55 <roconnor> er
00:13:01 <roconnor> actually
00:13:03 <roconnor> not quite that
00:13:20 <roconnor> ChongLi: it can be done but someone else will have to help you.  I need to go
00:13:25 <ChongLi> ok
00:13:29 <roconnor> it is a little bit complicated
00:13:34 <ChongLi> thanks for your help so far
00:13:37 <roconnor> not very though
00:13:55 <ChongLi> it's pretty weird
00:14:15 <ChongLi> but that's what happens when you try to port old crazy C algorithms to Haskell
00:14:28 <roconnor> ChongLi: is it literally 6 items
00:14:32 <roconnor> or do you want to keep going?
00:14:53 <ChongLi> it is those 6 items
00:14:54 <ChongLi> yeah
00:15:15 <ChongLi> I suppose it's probably easiest just to leave it like this
00:15:31 <ChongLi> I just found myself annoyed at how the code looked
00:16:01 <ChongLi> and was hoping to learn some functional way of implementing what appears to be a very imperative series of steps
00:19:13 <ivanm> @tell roconnor did you see http://bramcohen.livejournal.com/74462.html ?
00:19:14 <lambdabot> Consider it noted.
00:27:44 <ion> Does anyone have a ~/.ghci setup that adds e.g. Control.Applicative and Control.Monad to the environment when running without a file parameter but not otherwise?
00:30:28 * Baughn just implemented the sieve of erastothenes. Bliss...
00:30:43 <Baughn> Even if it's not the most efficient algorithm around, the sheer elegance of this code.. :3
00:32:40 <Baughn> ion: It's not answering your question, but just in case you didn't know, importing extra modules in GHCi doesn't affect its interpretation of the file you load, just the pseudo-module your interpreter commands operate in.
00:34:02 <ion> Yeah, but it might be nice to have a default environment “polluted” with all kinds of stuff for quick oneliners and a clean environment when actually operating on files.
00:34:38 <Baughn> ion: I can't imagine a situation in which I wouldn't want Control.Applicative. I import it in every file I write. :P
00:34:42 <ion> I guess i could just create a .hs file that exports such an environment and create a shell alias that runs ghci with that file.
00:34:57 <Baughn> Well, every file I write that touches monads. And then some.
00:35:15 <Baughn> ..that's still most of them
00:48:10 * hackagebot system-uuid 2.1.0 - Bindings to system UUID functions.  http://hackage.haskell.org/package/system-uuid-2.1.0 (JasonDusek)
01:13:45 <osfameron> in https://gist.github.com/924535 is there something more elegant I can do with the "case ls of" section (lines 16-18)
01:13:48 <osfameron> ?
01:14:16 <osfameron> e.g. ls :: Maybe >>= something or other ?
01:14:36 <dankna> well, Maybe is not a constructor, it's a type
01:14:44 <dankna> let me look at your paste
01:15:23 <dankna> no more elegant formulation is coming to mind offhand
01:15:26 <osfameron> yeah, I'm handwaving ;-)  (I know this is bad form with a language like haskell)
01:15:32 <quicksilver> move return outside the case
01:15:39 <quicksilver> and inline the filter into the case
01:15:40 <quicksilver> IMO
01:16:31 <osfameron> except ls is used twice, inlining it would mean repeating it, no?
01:17:02 <quicksilver> oh
01:17:19 <quicksilver> yup
01:17:24 <quicksilver> ignore that part :)
01:17:28 <osfameron> ;-)
01:17:33 <quicksilver> it's fine, although you might as well factor the return to the left of the case
01:17:52 <aleator> I have troubles building ghc 7.0.3. It fails in building /utils/hsc2hs with "cannot satisfy -package base-4.2.0.0". My current ghc has base-4.2.0.2.
01:17:56 <osfameron> I thought using a case to get Nothing/Just might be inelegant, as there are already list->Maybe transformations
01:18:00 <osfameron> quicksilver: yeah, will do, ta
01:18:01 <luite> you could use    fmap (f,) . listToMaybe $ ...    to avoid repeating it
01:18:05 <aleator> Any ideas why this happens?
01:18:17 <luite> oh wait
01:18:18 <luite> sorry
01:18:20 <luite> that's wrong
01:18:31 <osfameron> yeah, listToMaybe only uses one value in the list doesn't it?
01:18:38 <luite> yeah...
01:19:51 <companion_cube> cloud haskell seems exciting!
01:20:16 <monqy> did someone say cloud haskell? sounds exciting.
01:20:35 <sm> how do I resolve code.haskell.org login saying Permission denied (publickey) ?
01:20:51 <ivanm> sm: you should have provided a key when you requested an account
01:20:57 <ivanm> you _have_ to log in using a public key
01:20:57 <companion_cube> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/ ← first paper
01:21:15 <blackh> companion_cube: I agree.  I think it's really exciting!
01:21:25 <sm> I did once, I presume things changed with the crack attempt
01:21:45 <ivanm> sm: you need to reset your account
01:21:51 <merijn> companion_cube: Are they going to let you serialize and send functions between nodes too? :>
01:21:52 * ivanm is reminded that he still has to do so as well...
01:21:55 <ion> ‘hoogle data’ fails with 404 when trying to download <http://code.haskell.org/haskell-platform/haskell-platform.cabal>. PEBKAC?
01:21:59 <luite> > let f xs = guard (not.null $ xs) >> return (1,xs) in f [] :: Maybe (Int, [Int]) -- if you want to use the Maybe a monad
01:22:00 <companion_cube> merijn, it seems so
01:22:01 <lambdabot>   Nothing
01:22:09 <merijn> companion_cube: Awesome :>
01:22:21 <companion_cube> i'm reading the paper
01:22:39 <blackh> merijn, companion_cube: Yes, they do, but the code itself doesn't move.  You have to have the code on the far end of the connection.
01:22:48 <companion_cube> seems that erlang-style concurrency with type safety could be available one day *_*
01:22:55 <ion> I have a somewhat old haskell-platform (2010.1.0.0.1) from my distribution in case that’s the problem.
01:22:56 <companion_cube> uh, ok
01:23:10 <ion> And i installed hoogle with cabal.
01:23:59 * sm finds it.. email support@community.haskell.org. Give your real name, your unix user name and attach your current ssh public key. 
01:24:02 <sm> thanks ivanm
01:25:48 <aleator> Argh "Cannot find the program 'hscolour' at '' or on the path"
01:26:21 <luite> osfameron: oh and shorter, but not more clear:  fmap (f,) . find (not.null) . (:[])
01:26:58 <sm> aleator: cabal install HsColour
01:27:04 <osfameron> luite: heh, ok, definitely less clea
01:27:25 <sm> or if you already have it, the problem may be that the executable is HsColour
01:27:37 <aleator> sm: Well, thats rather difficult as the lib failing to compile _is_ Cabal :/
01:28:52 <quicksilver> blackh: on the other hand, the advantage of the code not moving is that it is architecture independent.
01:29:04 <quicksilver> maybe.
01:29:20 <quicksilver> but it looks like it's ABI / compiler version dependent
01:29:30 <blackh> quicksilver: :) Well, I think what they've done already is enough to make it very, very useful.
01:30:29 <blackh> The improvements they're planning will make it really great.
01:31:01 <quicksilver> blackh: jeff epstein doesn't IRC, does he?
01:31:10 <quicksilver> he doesn't even appear to have a web page which is a bit weird for a @cam.ac.uk bod
01:31:24 <quicksilver> I keep meaning to email him and pointing out his prior work survey is incomplete.
01:32:01 <HugoDaniel> hi
01:32:14 <blackh> Hi, HugoDaniel
01:32:22 <HugoDaniel> what typeclass says that my datatype is traversable ?
01:32:33 <blackh> Err.. Traversable?
01:32:39 <HugoDaniel> hmm
01:34:42 <ion> Is http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal likely to ever happen? :-)
01:36:48 <HugoDaniel> :/
01:37:10 <HugoDaniel> well, bytestrings are neither functors, foldables traversable or sequence
01:38:24 <quicksilver> they cannot be functor, traversable because they can only hold one type
01:38:28 <merijn> ion: God, I hope so
01:38:36 <quicksilver> they simply aren't sequence - sequence is a type.
01:38:44 <quicksilver> the could be something like Foldable
01:38:52 <quicksilver> except for annoying detail that Foldable has the wrong kind
01:39:03 <quicksilver> but, in principle with a modified version of Foldable which used associated types.
01:39:34 <HugoDaniel> so there is no way to say that my datatype has a map function ?
01:40:54 <ion> I have a vague memory of a module on Hackage that just imports and re-exports a bunch of modules that are useful for most code (Applicative, Monad etc). My Google-fu isn’t good enough to find it. Does it exist or do i remember incorrectly?
01:42:07 <ion> Ah, prelude-plus
01:42:24 <HugoDaniel> cool
01:42:32 <HugoDaniel> prelude++ :)
01:42:43 <HugoDaniel> thats seems just what haskell needs
01:43:03 <ion> http://hackage.haskell.org/packages/archive/prelude-plus/0.0.0.6/doc/html/Prelude-Plus.html
01:45:39 <ion> :t null -- does λbot use it?
01:45:39 <lambdabot> forall a. [a] -> Bool
01:45:48 <ion> Nope, it doesn’t.
01:46:21 <shachaf> Calude > Prelude.Plus, clearly.
01:46:50 <shachaf> Actually it looks like they don't intersect much.
01:53:04 <c_wraith> :t lift
01:53:05 <lambdabot>     Ambiguous occurrence `lift'
01:53:05 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
01:53:05 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
02:04:08 <chillitom> how can I iterate over a list passing the element and all of the remaining elements to a function?  something like :: [x] -> (x -> [x] -> x) -> [x]
02:11:47 <chillitom> anyone around?
02:12:03 <pacak> chillitom: map f . map tail
02:12:29 <pacak> > map sum . map tail $ [1,2,3,4]
02:12:29 <lambdabot>   No instance for (GHC.Num.Num [a])
02:12:30 <lambdabot>    arising from a use of `e_11234' at <in...
02:12:44 <pacak> :t map tail $ [1,2,3,4]
02:12:44 <lambdabot> forall a. (Num [a]) => [[a]]
02:14:22 <pacak> map sum . takeWhile ((>0) . length)  $ iterate tail $ [1,2,3,4]
02:14:25 <pacak> > map sum . takeWhile ((>0) . length)  $ iterate tail $ [1,2,3,4]
02:14:27 <lambdabot>   [10,9,7,4]
02:15:12 <chillitom> pacak: i have a list of numbers and I want to transform the list to the list of minimum distances between numbers
02:15:55 <pacak> chillitom: If list is [1,2,3,4] then what is the minimum distance?
02:16:12 <chillitom> would be 1
02:16:32 <chillitom> [1,2,2.5,3,4] would be 0.5
02:16:49 <chillitom> as min dist is 2.5-2
02:17:01 <shachaf> Is it only for adjacent numbers?
02:17:10 <chillitom> no for all numbers
02:17:28 <chillitom> it's been driving me crazy all morning
02:17:32 <pacak> chillitom: minDistance [1.1, 4, 2, 1]  = 0.1?
02:17:48 <chillitom> pacak: yes
02:18:33 <chillitom> but what I actually want to do is for each element in the list calc it's min distance to the others
02:18:41 <sonoflilit> Hi
02:19:07 <sonoflilit> I have a monadic loop (forM_) that reads stuff from DB, processes and prints to disk
02:19:19 <chillitom> so [1.1, 4, 2, 1] -> [0.1, 2, 0.9, 0.1]
02:19:35 <shachaf> > minimum . ap (zipWith subtract) tail . sort $ [1.1,4,2,1]
02:19:36 <lambdabot>   0.10000000000000009
02:19:46 <sonoflilit> the loop takes so much memory that it starts using swap, and from there, performance is a dead cause
02:19:57 <pacak> > (\l -> mininum . map abs . zipWith (-) (sort l) $ (tail . sort $ l))  [0.1, 2, 0.9, 0.1]
02:19:58 <lambdabot>   Not in scope: `mininum'
02:19:59 <sonoflilit> my profiling shows that the loop runs in parallel
02:20:02 <pacak> > (\l -> min . map abs . zipWith (-) (sort l) $ (tail . sort $ l))  [0.1, 2, 0.9, 0.1]
02:20:03 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
02:20:03 <lambdabot>    arising from a use ...
02:20:14 <pacak> (\l -> head . sort . map abs . zipWith (-) (sort l) $ (tail . sort $ l))  [1.1,4,2,1]
02:20:20 <pacak> > (\l -> head . sort . map abs . zipWith (-) (sort l) $ (tail . sort $ l))  [1.1,4,2,1]
02:20:22 <lambdabot>   0.10000000000000009
02:20:29 <pacak> chillitom like this?
02:20:30 <sonoflilit> as in, I added logigng on beginning and end of every loop iteration, and there's overlap
02:20:38 <shachaf> pacak: It's "minimum". :-)
02:20:49 <sonoflilit> how do I make the loop run only serially, or otherwise limit memory consumption?
02:20:52 <pacak> shachaf: Whatever :)
02:21:03 <companion_cube> ok, i definitely want typed actors in haskell, with matching on types...
02:21:45 <chillitom> pacak: something like that.. but returning the list.. 
02:22:25 <pacak> chillitom: Do you want distances between all possible pairs?
02:22:32 <merijn> sonoflilit: Maybe you want something like iteratees?
02:22:55 <shachaf> chillitom: Well, you should be able to figure it out from this.
02:22:57 <sonoflilit> merijn: I might. But isn't there something simpler?
02:23:01 <chillitom> pacak: yeah i think so
02:23:09 <chillitom> shachaf: trying ;-)
02:23:22 <merijn> sonoflilit: There might be, but I don't do that much IO so I wouldn't know if there is :>
02:23:35 <pacak> >  (\l -> sort $ (-) <$> l <*> l) [1,3, 2,3.1]
02:23:35 <lambdabot>   [-2.1,-2.0,-1.1,-1.0,-1.0,-0.10000000000000009,0.0,0.0,0.0,0.0,0.1000000000...
02:23:37 <shachaf> Is there a function that maps "abc" to [('a',"bc"),('b',"ac"),('c',"ab")]?
02:23:38 <sonoflilit> anyone else? a simple way to sequence an IO loop?
02:23:42 <pacak> chillitom: like this?
02:23:53 <sonoflilit> it runs in Yesod's Handler monad, if it is of any help
02:24:23 <shachaf> pacak: No, it wants the minimum for each element to all the others.
02:24:56 <chillitom> pacak: ahh sorry.. no.. it should return a list of the same length as the input list..   i.e. for each position return the min dist from all other positions
02:25:19 <shachaf> chillitom: Why do you need this function?
02:25:36 <pacak> Is it your homework? :)
02:25:40 <chillitom> shachaf: filtering outliers
02:25:46 <chillitom> not home work..
02:25:48 <chillitom> work ;-)
02:26:35 <shachaf> If this is for the purpose of learning Haskell, you're probably better off figuring it out from what's been said so far.
02:27:37 <chillitom> shachaf: I'll be sure to understand it.. don't worry..  but at the moment I've converted all the other parts of this algorithm but this bit is beyond me.
02:28:40 <chillitom> pacak: shachaf : thanks for the help
02:32:00 <chillitom> can we go back a step? given [1,2,3,4] how could i iterate to get this [(1,[2,3,4]), (2, [1,3,4]), (3, [1,2,4]), (4, [1,2,3])]?
02:35:26 <pacak> chillitom: rotate list N times, then map over (p:ps)
02:35:44 <chillitom> pacak: thanks
02:36:21 <sonoflilit> does anyone have example code for using the enumerator package to do simple I/O sequencing?
02:36:54 <sonoflilit> I'm getting a bit lost in Michael Snoyman's tutorial
02:37:05 <sonoflilit> which is also too complicated for my use case...
02:37:16 <merijn> sonoflilit: Yeah, it's a bit hard to grok. I'm still trying to figure it out :\
02:37:53 <pacak> sonoflilit: This tutorial is the simpliest of them all.
02:38:12 <pacak> sonoflilit: If you want - you can try your luck with Oleg's papers :)
02:38:16 <sonoflilit> wait, maybe hFlush would guarantee sequencing for me?
02:38:26 <sonoflilit> would it?
02:38:44 <pacak> If you understand iteratee package - you will master enumerator as well.
02:39:20 <pacak> sonoflilit: What are you trying to invent?
02:40:53 <sonoflilit> pacak: I have a fomM_ loop that is taking too much memory and swapping, making my code too slow. I inserted some logs and I saw that loop iterations are interleaved, which would explain the high memory footprint. I want to sequence the loop so that each step is performed after the previous one
02:42:01 <mauke> forM_ does that
02:42:14 <mauke> how did you get it to interleave stuff?
02:42:32 <sonoflilit> by doing nothing special
02:42:41 <sonoflilit> I want it not to interleave stuff
02:42:49 <mauke> forM_ does that
02:42:56 <pacak> Haskell memory management is not as stupid as you think. Actually i also had some kind of trouble with memory usage. And reimplementing all with iteratee did not solved anything. Later i found a bug :)
02:43:38 <pacak> But on the other hand - i understood iteratee. And it gave 3x performance boost to fixed version.
02:43:53 <pacak> (against lazy bytestring)
02:43:55 <pacak> reading
02:46:21 <pacak> sonoflilit: So if you really want to study iteratee/enumerator - you can start from here: http://okmij.org/ftp/Haskell/Iteratee/IterateeIO-talk-notes.pdf 
02:46:45 <pacak> Then http://okmij.org/ftp/Haskell/Iteratee/Iteratee.hs and http://okmij.org/ftp/Haskell/Iteratee/IterateeMCPS.hs
02:48:17 <sonoflilit> pacak: I don't, I just want my code to not swap memory
02:48:51 <sonoflilit> I need a simple example of sequencing reading and writing with Iteratee
02:50:52 <pacak> http://hackage.haskell.org/trac/ghc/ticket/5060 - the simpliest example with iteratee package :)
02:51:47 <pacak> from that you can check implementation of printLines and fileDriver
02:52:03 <sonoflilit> I need advice
02:52:17 <sonoflilit> I found a solution to my problem: run my yesod app with -M500M
02:52:41 <sonoflilit> but now I fear that in some state, it would actually need 500M heap, and then it would die silently
02:53:10 * hackagebot epic 0.1.11 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.1.11 (EdwinBrady)
02:53:45 <sonoflilit> is there something like a "weak" -M setting?
02:53:51 <pacak> sonoflilit: You can enforce some strictness with $! and seq
02:54:10 * hackagebot ivor 0.1.14 - Theorem proving library based on dependent type theory  http://hackage.haskell.org/package/ivor-0.1.14 (EdwinBrady)
02:54:14 <sonoflilit> "RTS, please really prefer not to let my heap grow above this, but don't do anything dramatic if it does"?
02:54:26 <sonoflilit> pacak: how do I use seq with monadic code?
02:54:46 <pacak> It depends on your code :)
02:55:10 * hackagebot idris 0.1.7 - Dependently Typed Functional Programming Language  http://hackage.haskell.org/package/idris-0.1.7 (EdwinBrady)
02:55:44 <pacak>         go p b k e@(Chunk c) = case (feed (feed (parse p b) c) B.empty) of
02:55:44 <pacak>                 (Done rest result) -> do
02:55:44 <pacak>                         iter' <- lift (enumChunk (Chunk . map f $ result) k)
02:55:44 <pacak>                         liftI (go p rest $! iter')
02:55:57 <sonoflilit> can I, say, "mapM (seq () . monadicActionThatIdLikeToSequece) list"?
02:55:59 <pacak> Something like that for example.
02:56:37 <sonoflilit> have you read my newer question, about -M? It would solve my problem...
02:56:37 <pacak> sonoflilit: Did you tried to use hp2ps to profile your app?
02:56:54 <sonoflilit> I found a solution to my problem: run my yesod app with -M500M
02:56:58 <sonoflilit> but now I fear that in some state, it would actually need 500M heap, and then it would die silently
02:57:03 <sonoflilit> is there something like a "weak" -M setting?
02:57:06 <sonoflilit> "RTS, please really prefer not to let my heap grow above this, but don't do anything dramatic if it does"?
02:57:53 <pacak> sonoflilit: ghc tries very hard to keep heap in some sane range.
02:58:12 <pacak> And if it grows over that value - something is wrong with your code.
02:58:15 <pacak> Probably.
02:58:40 <sebfisch> > [minimum [abs (x-y) | y <- ys] | (x:ys) <- take 4 [take 4 xs | xs <- tails (cycle [1.1,4,2,1])]]
02:58:41 <lambdabot>   [0.10000000000000009,2.0,0.8999999999999999,0.10000000000000009]
02:58:56 <sonoflilit> pacak: but my code runs multithreaded handling multiple requests. I don't want to kill everything because there's something wrong in one place
03:02:48 <pacak> sonoflilit: Did you tried hp2ps?
03:25:57 <args0> hey guys, I'm very new to functional programming/haskell, i have a question: Are variables saved in haskell? (as oppsoed to van neumann langauges)
03:26:10 <mauke> wat
03:26:19 <pacak> there are no variables in haskell.
03:26:24 <args0> mauke: did this make sense?
03:26:26 <pacak> There are only constants.
03:26:34 <mauke> there are variables in haskell
03:26:34 <args0> pacak: thanks, but how are they saved?
03:26:39 <mauke> args0: no
03:26:47 <mauke> what do you mean by "saved"?
03:26:50 <mauke> what do you mean by "van neumann languages"?
03:27:04 <args0> are they in memorry?
03:27:08 <osoleve> so, I have an array indexed by (Char, Int). Is that bad? Because whenever I try to do anything with the array (retrieve indices, get an element) i get "Exception: Error in array index."
03:27:13 <mauke> as opposed to on disk or what?
03:27:23 <args0> no, variables in use
03:27:26 <mauke> what
03:27:38 <args0> constants"*
03:27:40 * andras thinks "v. Neumann" refers to the Backus paper
03:27:53 <mauke> args0: make more sense
03:27:54 <shachaf> osoleve: How does that work as an index, exactly?
03:28:02 <andras> args0: you don't use variables in haskell at all
03:28:02 <args0> yep
03:28:08 <mauke> andras: yes, I do
03:28:12 <quicksilver> (Char,Int)
03:28:14 <shachaf> Oh.
03:28:17 <quicksilver> is a fine instance of Ix
03:28:21 <quicksilver> I think
03:28:25 <args0> okay, when i create a value.. is it saved anywhere?
03:28:33 <andras> args0: you have functions like in maths
03:28:35 <mauke> args0: what does that mean?
03:29:23 <args0> value1::int
03:29:27 <args0> value1=1
03:29:31 <args0> is this saved anywhere?
03:29:34 <mauke> args0: what does that mean?
03:29:35 <quicksilver> it might be, it might not be, depends on optimisation.
03:29:41 <mauke> what do you mean by "saved"?
03:29:45 <quicksilver> which is exactly the same answer as it would be in C.
03:30:08 <args0> is it stored in any memory location on primary/secondary
03:30:20 <shachaf> quicksilver: Yes, but C is a high-level language. :-)
03:30:21 <mauke> what do you mean by "primary/secondary"?
03:30:40 <andras> args0: think of it as this: when you write a program, you're not really interested in values stored in memory. you can't see memory anyway.
03:30:56 <args0> memory
03:31:02 <mauke> wat
03:31:29 <andras> args0: you're interested in the results of the calculation, where the computer stores them or whether it does at all is of no concern at all
03:31:57 <args0> andras: what if this concerns me? i want to know where this is "stored"
03:32:09 <andras> args0: what exactly for?
03:32:24 <quicksilver> args0: that's not a question about haskell, it's a question about any particular compiler, and set of optimisation options, etc.
03:32:28 <shachaf> It might not be stored anywhere, if you don't use it.
03:32:39 <mauke> haskell is not a macro preprocessor for asm
03:32:48 <args0> I defined value1, when a function refers to value1... is it creating it through the function or is it referencing that value from somewhere?
03:32:52 <quicksilver> but this is not unique to haskell - other languages with optimising compilers behave in the same way.
03:33:02 <mauke> args0: what difference does it make?
03:33:06 <osoleve> is there something glaringly, obviously wrong with this array? http://hpaste.org/45803/array_indices_error
03:33:28 <quicksilver> osoleve: yes.
03:33:28 <mauke> osoleve: 'C' > 'B'
03:33:32 <mauke> osoleve: how big is that array?
03:33:37 <quicksilver> osoleve: 'B' doesn't come after 'C'.
03:34:01 <osoleve> ...oh.
03:34:03 <shachaf> Ugh, don't use characters for note names!
03:34:10 <quicksilver> the Ix indices for tuples are based on a cuboidal shape, not the kind of lexicographic ordering you seem to be hoping for.
03:34:14 <args0> mauke: as a computer scientist, i'd like to know... might not make any difference or sense
03:35:22 <mauke> args0: ok, then the answer is "yes"
03:35:29 <osoleve> yeah, that fixed it. thanks guys.
03:35:56 <args0> mauke: yes to what? sorry
03:36:15 <mauke> you said a nonsensical answer would be fine
03:36:32 <shachaf> osoleve: But, seriously, characters for note names are evil.
03:36:41 <osoleve> shachaf, why?
03:37:08 <shachaf> Because the whole system is... Bah, never mind.
03:37:25 <osoleve> okay?
03:37:31 <quicksilver> if you'd used data Note = C | D | E | F | G | A | B deriving (Ix) then you would have had B > C and it would have worked like you wanted, I suspect.
03:37:45 <quicksilver> although it seems odd to omit the #s but I'm not sure what you're up to :)
03:38:07 <andras> args0: in Haskell, most of the time system RAM is used to cache results, at least that's the way I try to think of it -- there are no "named memory locations" called variables in other languages
03:38:13 <osoleve> quicksilver, markov generator!
03:38:21 <shachaf> Just use numbers from 1 to 12 or something instead?
03:38:39 <shachaf> The standard note naming system is completely arbitrary and ridiculous.
03:38:43 <mauke> andras: yes, there is
03:38:46 <args0> andras: thank you, that's what I was asking for :)
03:39:10 <Twey> Or just absolute frequencies?
03:39:29 <mauke> andras: could you please stop giving out misinformation?
03:39:38 <andras> mauke: what misinformation?
03:39:47 <zygoloid> shachaf: that still sounds pretty arbitrary. how do you pick which note is 1?
03:39:51 <shachaf> Well, yes, relying on the 12-tone system is somewhat silly too. But probably less so.
03:39:56 <mauke> that there are no variables, that you can't change stuff, that there are no pointers
03:40:20 <shachaf> zygoloid: I know, but I wanted to suggest the smallest change that would get rid of the characters-as-note-names thing.
03:40:24 <Twey> If you're trying to simplify it, surely you'd just store a Float of frequency
03:40:31 <Twey> Ah, okay
03:40:47 <zygoloid> shachaf: you just made it less familiar without removing the fundamental problem with it :)
03:40:47 <osoleve> shachaf, I have another program that converts the string representations into absolute frequencies, and has support for compound notes
03:40:55 <Twey> Hm, or maybe an exponent of 2
03:41:58 <andras> mauke: in pure haskell there aren't, if you use monads to construct an "imperative" program from within haskell, then of course the situation is quite different -- or am I completely wrong on this one?
03:42:12 <mauke> what do monads have to do with this :-(
03:42:23 <Twey> Heh
03:42:27 <mauke> f = \x -> x + 1  -- x is a variable
03:42:50 <Twey> andras: Haskell has true variables.  Other languages only have cells.  ;)
03:42:58 <mauke> IORef is mutable variables, Ptr a is pointers
03:43:28 <shachaf> zygoloid: I removed at least one problem with it, which is that the difference between 'B' and 'C' isn't the same as the difference between 'C' and 'D'.
03:43:33 <Twey> andras: To some extent what you say is true, but it's a distinction we often ignore in practice, for simplicity and brevity
03:44:12 <Jafet> If osoleve has used lilypond before, I pray that he will not design his music-DSL like they did.
03:44:35 <Twey> shachaf: But doesn't that apply to 1 and 2 and 2 and 3 just as well?
03:44:40 <ivanm> preflex: seen ezyang 
03:44:41 <preflex>  ezyang was last seen on #haskell 12 hours, 51 minutes and 47 seconds ago, saying: Oooh, I bet Don is going through and editing all the old post, and consequently filling up my RSS feed :-( 
03:45:02 <osoleve> Jafet, i have no idea what lilypond is, but... i'll try to keep it from being... that.
03:45:10 <shachaf> Twey: Well, no, because the numbers should be evenly distributed.
03:45:30 <andras> Twey: I agree... but most often, variables are understood as something you can assign a value to, overwriting its previous contents, and that concept doesn't exist in pure haskell
03:45:30 <shachaf> 1,2,3,4 instead of B,C,C#,D
03:45:32 <shachaf> Or something.
03:45:45 <mauke> define "pure haskell"
03:45:57 <osoleve> shachaf, I have another program that makes those conversions
03:45:59 <andras> mauke: non-monadic
03:46:04 <Twey> shachaf: Oh, I see
03:46:07 <mauke> define "non-monadic"
03:46:26 <Twey> andras: Monads have nothing to do with purity, IO, or anything else. (except that the IO type happens to be a Monad, for convenience)
03:46:28 <mauke> because functions form a monad
03:46:55 <shachaf> osoleve: OK, but these don't even make sense as internal representations. The whole music-writing system is evil.
03:47:00 <Twey> andras: A variable, in the original sense, is something that can change between invocations of a function.
03:47:22 <Twey> > let f x = x * 5 in (f 1, f 3) -- Look, the value of x changed
03:47:23 <lambdabot>   (5,15)
03:49:46 <sonoflilit> Is there an optimized (groupBy f . sortBy f)?
03:50:02 <ivanm> not that I know of
03:50:08 <ivanm> but I doubt that it would need much optimisation
03:50:13 <sonoflilit> there should be, I think
03:50:18 <sonoflilit> since it is a very common pattern
03:50:27 <ivanm> sonoflilit: what optimisations are needed?
03:50:32 <sonoflilit> and f might be expensive
03:50:43 <ivanm> sonoflilit: schwarzian transform!
03:50:49 <sonoflilit> ivanm: huh?
03:50:51 <ivanm> @google schwarzian transform
03:50:54 <lambdabot> http://www.perlmonks.org/?node_id=476700
03:50:55 <lambdabot> Title: What is "Schwarzian Transform" (aka Schwartzian)
03:51:00 <mauke> schwartzian, please
03:51:06 <ivanm> mauke: sorry :s
03:51:10 <ivanm> couldn't remember the spelling
03:51:19 <ivanm> it's also known as decorate-undecorate or something
03:52:03 <ivanm> http://en.wikipedia.org/wiki/Schwartzian_transform
03:52:06 <lantti> shachaf: The CDEFGAHC system makes pretty much sense if you are working under the assumption that the musical modes commonly used in western music is all that there is.
03:53:06 <lantti> Then you can just say in which mode you are writing in and there is no need for expicite sharps or flats.
03:54:12 <zygoloid> lantti: are you talking about the german system or did you mean B rather than H?
03:54:14 <shachaf> lantti: H? Are you German or something?
03:54:53 <lantti> Ah, sorry. B for all the Americans of course.
03:55:03 <zygoloid> umm, not just the americans.
03:55:10 <shachaf> lantti: Are you Finnish?
03:55:10 <lantti> I know :)
03:55:23 <shachaf> I thought H was more or less exclusively German.
03:55:44 <zygoloid> i thought even in germany it was becoming much less common :)
03:55:50 * hackagebot hakyll 3.1.1.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.1.1 (JasperVanDerJeugt)
03:55:57 <shachaf> Anyway, I have a similar objection to the standard piano keyboard layout.
03:56:11 <shachaf> Which is completely arbitrarily based on the diatonic scale (and C-major in particular).
03:56:32 <Jafet> The layout weeds out the weak.
03:56:45 <mornfall> Oh c'mon. :)
03:56:57 <zygoloid> it'd certainly be a lot easier to transpose if the keys had a strict black-white alternation (so there's only two different major scales to learn)
03:57:11 * shachaf would advise covering the keys with contact poison to weed out the unworthy.
03:57:12 <zygoloid> but it'd be a lot harder to play without some other indication of which notes are which :)
03:57:15 <quicksilver> harder to find your place on the piano though.
03:57:31 <lantti> But again if you work with strictly modal music it works just fine.
03:57:37 <shachaf> zygoloid: There's the Jankó keyboard.
03:57:39 <quicksilver> although presumably you could just mark every 12th note in pink
03:57:45 <shachaf> Or chromatic button accordions, for instance.
03:58:08 <mornfall> The downside of chromatic whatever is that it's too thin to be practical.
03:58:12 <mornfall> Diatonic is a good compromise.
03:58:15 <shachaf> Thin?
03:58:28 <mornfall> shachaf: Things you actually need are too far apart.
03:58:35 <lantti> I think the piano layout was fixed somewhere in middle ages so should be no big surprise that it reflects the music composed then...
03:58:50 <ivanm> sonoflilit: anyway, the more common idiom I use is \ f -> groupBy ((==) `on` f) . sortBy (compare `on` f)
03:58:55 <shachaf> mornfall: Huh? Keys are actually *closer* in the Jankó keyboard.
03:59:23 <sonoflilit> ivanm: yes, when my code didn't compile I noticed that one wants an ordering and the other equality
03:59:37 <zygoloid> quicksilver: i think being able to feel where you are on the keyboard is very important too.
03:59:42 <shachaf> mornfall: Since it's like having evenly-interleaved white and black keys, rather than the occasional double white keys (which only widen things).
03:59:44 <ivanm> yes; your code won't work ;)
03:59:56 <mornfall> shachaf: Music is mostly tonal.
04:00:10 <Jafet> This is what happens when a programmer-musician meets Dvorak.
04:00:25 <mornfall> Jafet: I type Dvorak and play traditional piano. :P
04:00:26 <ivanm> sonoflilit: as such, using the schwartzian transform, you typically do something like: map (map fst) . groupBy ((==) `on` snd) . sortBy (compare `on` snd) . map (\ x -> (x, f x))
04:00:36 <shachaf> There is so much historical tradition and "this is how it's done" and resistance to change in this sort of thing, what with it having been this way for hundreds of years.
04:00:41 <Jafet> Play Dvorák, too!
04:00:50 * zygoloid suddenly ponders what proportion of #haskell plays the piano ;)
04:00:52 <mornfall> Dvořák, actulaly.
04:00:55 <mornfall> actually*
04:00:59 <quicksilver> zygoloid: not just pink, then. Fluffy and pink.
04:01:05 <zygoloid> haha :D
04:01:06 <shachaf> I play no musical instruments, by the way; I just complain. :-(
04:01:12 <ivanm> zygoloid: I played the electronic organ; close enough?
04:01:19 <quicksilver> zygoloid: (yeah, I'm fine with the current layout. It makes it easy to see and feel where you are)
04:01:28 <mornfall> shachaf: That's the problem. I thought it was illogical and stupid until I actually started playing. :)
04:01:33 <mornfall> shachaf: It makes a lot more sense now.
04:01:41 <shachaf> mornfall: Most things do once you get used to them.
04:01:50 <quicksilver> zygoloid: it also makes playing music in different keys 'feel' different because of the different patterns of black vs white notes in each key.
04:02:04 <quicksilver> I suspect this is quite helpful.
04:02:29 <sonoflilit> mornfall: Me too. I still feel it's arbitrary, but I see some advantages now
04:02:31 <mornfall> Well, irregularity gives you a lot of helpful cues when trying to orient on a big keyboard.
04:02:34 <mornfall> Make it uniform and you are lost.
04:02:47 <zygoloid> yeah. though since i've never tried another piano layout, it's hard to judge how effective the standard layout is
04:02:50 <shachaf> quicksilver: I think you can introduce arbitrariness anywhere, and get used to it, and claim that it's good.
04:03:06 <quicksilver> shachaf: the particular choice of asymmetry is arbitrary.
04:03:11 <mornfall> shachaf: Everything is, at some level, arbitrary.
04:03:12 <zygoloid> there are fixed-string instruments where the notes are not in order, for instance, which are apparently quite natural to play
04:03:28 <quicksilver> shachaf: actually *having* asymmetry is not arbitrary - having asymmetry gives you more ways of finding yourself.
04:03:49 <mornfall> (But anyway, I am a bassoonist. Piano is extremely regular and thought out compared to that.)
04:03:58 <quicksilver> if every city block was architecturally identical, it would be hard to find your way around a city
04:04:02 <quicksilver> landmarks are useful.
04:04:24 <shachaf> People who play the chromatic button accordion seem to do fine.
04:04:35 <quicksilver> sure.
04:04:39 <mornfall> Well, everything is logical compared to woodwinds, really.
04:04:44 <quicksilver> lots of people do lots of things fine
04:04:52 <quicksilver> which doesn't mean that other things don't have advantages :)
04:04:58 <quicksilver> people who program in PHP seem to do fine.
04:05:02 <shachaf> Sure.
04:05:04 <mornfall> quicksilver: Touché.
04:05:05 <sonoflilit> mornfall: The saxophone is quite regular, actually, except for really corner cases
04:05:32 <Boxo> color the keys, problem solved
04:05:35 <mornfall> sonoflilit: Didn't seem to be when I actually tried to blow it, though. :) Fingerings, probably.
04:05:46 <shachaf> quicksilver: You're like someone who programs in assembly complaining about not having explicit control the layout of his data in memory.
04:05:47 <mornfall> Boxo: Doesn't help with tactile feedback.
04:05:53 <shachaf> ...That analogy made sense a little while ago.
04:06:04 <lantti> mornfall: Well bassoon is anyway the "we can make it bigger and are ready to suffer for it"-instrument. Piano for example also plays the notes approximately in the same rhythm as you press the keys for example...
04:06:08 <quicksilver> I'm not complaining about anything :)
04:06:13 <sonoflilit> mornfall: blowing it is actually pretty easy, almost everyone who tried mine did well within a few minutes. Try again some time
04:06:16 <quicksilver> I'm just speculating about what advantages the asymmetry might bring.
04:06:28 <shachaf> Fair enough.
04:06:31 <mornfall> sonoflilit: It was admittedly a rather poor approximation of a sax.
04:06:43 <Jafet> I say again, it weeds out the weak.
04:06:47 <mornfall> sonoflilit: But I couldn't get anything close enough to an in-tune scale.
04:07:27 <ivanm> since we're bragging about which instruments we played, I played the French Horn in school
04:08:01 <sonoflilit> ivanm: I own one, I barely play it :(
04:08:04 <sonoflilit> (sax)
04:08:10 <Jafet> "This on time, at band camp..."
04:08:12 <quicksilver> for example, I suspect (but have no actual idea) that people who have only ever played chromatic accordion or other chromatic instrument will feel that 'all keys feel the same - choice of key is essential arbitrary'
04:08:36 <quicksilver> whereas people who play heavily asymmetric instruments (which is after all, most of them) find some keys easier and some keys hard and have emotional associations with them.
04:08:37 <ivanm> quicksilver: I actually didn't notice any difference between the various keys *shrug*
04:08:46 <ivanm> oh, and I also sing
04:09:01 <mornfall> quicksilver: That, and unless you have a piano in the orchestra, you don't actually keep equal temperament most of the time.
04:09:10 * quicksilver nods
04:09:14 <mornfall> quicksilver: So different keys sound slightly different anyway.
04:09:38 <Jafet> Yeah, you just tune your A and start playing.
04:09:46 <Jafet> It adds colour.
04:10:25 <shachaf> quicksilver: I don't think that's completely true.
04:10:39 <shachaf> quicksilver: People have associations with keys beyond how it feels to play a piece.
04:11:20 <quicksilver> shachaf: Of course. Some people more than others. Depends how good their native pitch is too.
04:11:26 <Jafet> The association has nearly nothing to do with the key. It has to do with all the pieces that have ever been written in that key.
04:11:40 <Jafet> (That the musician knows about, anyway.)
04:11:56 <mornfall> Doesn't work for me like that (about the pieces for a key).
04:12:05 <mornfall> And few pieces stay in a single key anyway.
04:12:13 <mornfall> (That's the kind of a point of having multiple, afterall.)
04:12:56 <Jafet> It's only a big thing in European tradition, anyway, because they fix pieces to keys.
04:14:07 <lantti> Or have a fixation about a musical piece in the first place...
04:14:09 <mornfall> Jafet: There's nothing much besides European tradition, in terms of art music.
04:14:43 <andras> mauke: what do you mean by "functions form a monad"? everything else you said I understand, but this one puzzles me a bit
04:15:02 <mauke> andras: ((->) e) is a monad
04:15:03 <shachaf> andras: instance Monad ((->) r).
04:15:58 <shachaf> andras: "Monads" have nothing to do with imperativeness or state or anything like that.
04:16:52 <Jafet> I think art music has been defined to be practically synonymous with European traditional music, so there it is.
04:18:35 <companion_cube> a performance question: are there ways: 1) to indicate that some fields (Double, Int) should be unboxed 2) to have the compiler use SIMD instructions?
04:18:50 <mornfall> Jafet: The thing is that outside of that, there's basically just folk music (which is everywhere, including Europe). But there's arguably a difference between one and the other.
04:19:03 <Jafet> I presume you've read the ghc core already?
04:19:18 <andras> shachaf: I know, but that's how they are often described, at least in two tutorials I read while getting started with haskell
04:19:20 <Jafet> (For 1), that is)
04:19:53 <shachaf> andras: That's how specific instances of Monad are described. If you're talking about IO, say IO, not "monad".
04:20:48 <companion_cube> Jafet, that's a general questions for the future :s
04:21:06 <companion_cube> i should have precised, I just want to know whether it's possible or not
04:21:11 <andras> shachaf: OK, makes sense
04:22:06 <quicksilver> companion_cube: for (2) the answer is "No"
04:22:36 <Jafet> mornfall: outside Europe, there is a substantial amount of complexity in Indian raga and tala, gamelan patterns, etc.
04:22:46 <companion_cube> even with the C compiler, i guess :/... but ok
04:22:47 <companion_cube> thanks
04:23:39 <Jafet> Far below the complexity of a fugue, of course
04:23:55 <Jafet> Would ghc-llvm use SIMD instructions?
04:24:00 <quicksilver> no.
04:24:10 <quicksilver> AFAIK.
04:24:44 <quicksilver> there are people interested in generating SIMD code but it doesn't happen yet
04:24:58 <quicksilver> unless the vectoriser in DPH can do it? but that's not general purpose even so.
04:25:11 <Jafet> companion_cube: dump the ghc core; it may been done for you already
04:25:16 <Jafet> (unboxing, that is)
04:25:25 <companion_cube> ok, I will
04:25:28 <quicksilver> but the short answer to companion_cube's (1) was "Yes"
04:25:33 <companion_cube> thank you for your answers! :)
04:25:35 <quicksilver> there is an unpack pragma.
04:32:21 <mrcarrot> i am comparing haskell with ocaml for the naive version of fibonacci and i found that the same algorithm in both languages are performing significantly differently. i wonder why?
04:32:29 <mrcarrot> this is the code for haskell:
04:32:31 <mrcarrot> fib 0 = 1
04:32:32 <mrcarrot> fib 1 = 1
04:32:32 <mrcarrot> fib n = fib (n-1) + fib (n-2)
04:33:08 <mrcarrot> for n=40 it takes a bit more than 10 seconds for ghc 7 (native code)
04:33:19 <mrcarrot> for ocaml it takes about 2 seconds
04:33:41 <quicksilver> your haskell code is for Integer
04:33:42 <companion_cube> did you put a signature for fib ?
04:33:48 <quicksilver> the ocaml code is probably for a fixed-size type
04:33:52 <companion_cube> fib :: Int -> Int should be faster
04:33:59 <quicksilver> exactly.
04:34:01 <mrcarrot> okay, i will try
04:34:18 <quicksilver> make sure you are compiling with -O2
04:34:48 <unfo-> mrcarrot, see also: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
04:35:25 <quicksilver> but I imagine he doesn't actaully care about the fibonacci sequence, he's just trying to compare compileres.
04:35:38 <mrcarrot> Int -> Int gives 3.43 s... so a lot better, still not around 2 though
04:35:46 <quicksilver> that's about what I'd expect.
04:35:54 <mrcarrot> yes, i try to compare the compilers, nothing else
04:35:54 <quicksilver> the ocaml compiler is often faster
04:36:01 <quicksilver> especially for short numeric microbenchmarks
04:36:06 <unfo-> quicksilver, sure. just thought it might be relevant to his interests :)
04:36:12 <quicksilver> that code does no allocation in ocaml
04:36:20 <quicksilver> and it allocates quite some in haskell
04:36:38 <quicksilver> (or so I expect - you'd have to display RTS output to check)
04:36:54 <unfo-> if you do fib 40 the second time, is ocaml 2 + 2 and haskell 3.43 + 0 ?
04:37:06 <quicksilver> no, it won't be.
04:37:09 <quicksilver> that code doesn't memoise.
04:37:19 <unfo-> ok
04:37:37 <quicksilver> for a collection of not very interesting microbenchmarks, see also the shootout.
04:37:47 <mrcarrot> with many repeates, haskell is doing it now in 3.43 and ocaml in 1.73
04:37:59 <shachaf> quicksilver: What are examples of interesting microbenchmarks?
04:38:34 <quicksilver> shachaf: to my mind, there are none.
04:38:43 <quicksilver> shachaf: of course, interest is subjective.
04:38:46 <quicksilver> mrcarrot: see http://shootout.alioth.debian.org/u32q/which-programming-languages-are-fastest.php?ghc=on&ocaml=on&calc=chart
04:38:48 <mrcarrot> okay, then the next question: what should i in general avoid to do in my source in haskell? i mean, for performance
04:39:02 <shachaf> Avoid writing slow code.
04:39:07 <mrcarrot> :)
04:39:09 <quicksilver> which demonstrates that haskell players are more interested that ocaml players in binding the rules to get better scores.
04:39:27 <mrcarrot> i mean, are there any common things to avoid to not get slow code
04:39:27 <shachaf> In general, premature optimization is a good thing to avoid.
04:39:29 <quicksilver> and therefore haskell does better.
04:46:13 <roelvandijk> I agree about premature optimization, first write a program that does what you want (minus the performance part)
04:46:48 <roelvandijk> You can do a suprising amount of optimization later, without significantly changing the structure of the program
04:47:34 <roelvandijk> If necessary, do the heavy lifting in C. Haskell's excellent foreign function interface makes this easy.
04:48:33 <roelvandijk> One thing I learned about optimizing Haskell is that time is usually not spent where you expect it, mostly due to laziness
05:05:08 <Philonous> "Avoid premature optimisation" always sounds like "Never mind design, just hack the damn thing together and botch in some 'optimisations' later" to me
05:05:47 <hpc> "avoid premature hacky optimisation" != "start the design with a fast algorithm"
05:05:51 <ivan> avoiding premature optimizations often helps design
05:06:30 <zygoloid> i love how people say "avoid premature optimization" and think they're channeling Knuth, when in fact he was saying almost exactly the opposite
05:07:18 <Jafet> @dict premature
05:07:19 <lambdabot> Supported dictionary-lookup commands:
05:07:19 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
05:07:20 <lambdabot> Use "dict-help [cmd...]" for more.
05:07:27 <Jafet> @wn premature
05:07:28 <lambdabot> *** "premature" wn "WordNet (r) 2.0"
05:07:28 <lambdabot> premature
05:07:28 <lambdabot>      adj 1: born after a gestation period of less than the normal time;
05:07:28 <lambdabot>             "a premature infant" [ant: {full-term}]
05:07:30 <lambdabot>      2: too soon or too hasty; "our condemnation of him was a bit
05:07:32 <lambdabot> [4 @more lines]
05:07:37 <Palmik> @more
05:07:38 <lambdabot>         previous"; "a premature judgment" [syn: {previous(p)}]
05:07:38 <lambdabot>      3: uncommonly early or before the expected time; "illness led
05:07:38 <lambdabot>         to his premature death"; "alcohol brought him to an
05:07:40 <lambdabot>         untimely end" [syn: {untimely}]
05:07:53 <Jafet> You shouldn't do premature optimization by definition...
05:08:39 <shachaf> zygoloid: He was?
05:09:32 <mrcarrot> out of curiousity, why is nextMove in this code slow for heaps with numbers bigger than 1000? http://pastebin.com/3Uh5fTwV
05:10:33 <zygoloid> shachaf: Knuth's point was that optimization should be used when it's appropriate (which Knuth suggested was about 3% of the time)
05:10:52 <mrcarrot> if you go up to sizes with about 10000 it taks many minutes to finish... even though the lazyness should take care of it as i only want the head from the list
05:11:04 <mrcarrot> s/taks/takes/
05:11:24 <shachaf> zygoloid: Yes, but not premature optimization.
05:11:31 <zygoloid> i guess it really depends on how you interpret 'premature'. "too early" optimization is too early by definition, but "uncommonly early" optimization is not
05:11:57 <shachaf> I don't know if you can read that out of the quote either.
05:12:00 <zygoloid> and in any case, knuth is /only/ talking about "small inefficiencies"
05:12:12 <shachaf> Well, yes.
05:12:39 <shachaf> It seems to make sense to read it as "97% of the time, the small inefficiencies aren't going to matter; so figure out if the matter before you start worrying about them".
05:13:20 <Jafet> 97% of inefficiencies are small.
05:13:34 <hpc> 97% of statistics are made up on the spot
05:13:59 <unfo-> hpc, i think you meant 68% ;)
05:14:07 <Jafet> The other 5% are poorly computed from the made-up ones.
05:14:09 <hpc> :P
05:14:50 <zygoloid> shachaf: right. but if they do matter, then optimizing for them unusually early is not necessarily a bad thing
05:15:06 <mrcarrot> in this code that i pasted with nextMove, i have only tested it through the ghci
05:15:33 <shachaf> zygoloid: But how will you know if they matter at the "unusually early" point? :-)
05:15:46 <Jafet> mrcarrot: if each number ranges up to n, allMoves generates up to n^3 triples.
05:16:29 <hpc> > 1000**3
05:16:30 <lambdabot>   1.0e9
05:16:34 <mrcarrot> yes, but it only does need to search until it find one fulfilling the conditions? isn't that right?
05:16:39 <zygoloid> shachaf: because you're an intelligent programmer and have some idea of where your program should spend its time :)
05:17:03 <Jafet> So, does it have to search very long?
05:17:07 <mrcarrot> it should not go through all of them, or is it?
05:17:18 <Jafet> That depends on the conditions.
05:20:32 <quicksilver> mrcarrot: remember it searches in lexicographic order
05:20:43 <quicksilver> all the way up to (1,1,1000) before trying (1,2,anything)
05:20:59 <quicksilver> for many problems that's not an efficient search order.
05:21:25 <mrcarrot> quicksilver: how could i make it search in other orders?
05:21:29 <Jafet> Looks like nim.
05:21:40 <mrcarrot> Jafet: yes, it is nim
05:22:22 <quicksilver> by generating the list in the order you want it to search
05:22:41 <Jafet> Or by generating much smaller lists
05:22:48 <quicksilver> list comps are not magic - but the bad news is they look like magic
05:22:53 <quicksilver> luring you into thinking they are :)
05:22:56 <Jafet> For example, it looks like c is uniquely determined by a and b.
05:23:31 <Jafet> Well, only for large numbers.
05:24:58 <Jafet> In fact, it looks like allMoves only have one degree of freedom, not three.
05:35:08 <rostayob> @pl \x -> [x]
05:35:08 <lambdabot> return
05:35:14 <rostayob> oh, right ehe
05:57:28 <Boxo> also known as (:[])
06:00:48 <hpc> also known as the biglips combinator :P
06:01:32 <ivanm> I thought it was the monkey...
06:03:32 <lars9> @pl \a b c d -> c a d b
06:03:32 <lambdabot> flip . (flip .) . flip id
06:06:11 <lars9> @pl \a b c d e f g-> f c a e a g d b
06:06:12 <lambdabot> flip . ((flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)) .) . (flip =<< ((flip . (flip .) . flip) .) . flip (flip . flip id))
06:14:48 <lars9> @hlint
06:14:48 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:14:57 <lars9> @hlint \x -> x + 1
06:14:58 <lambdabot> No module "\x -> x + 1" loaded
06:15:08 <lars9> @pl \x -> x + 1
06:15:08 <lambdabot> (1 +)
06:15:15 <lars9> can we run hlint here?
06:17:13 <quicksilver> no, although hpaste can do it
06:18:53 <lars9> yeah hpaste can do it.
06:19:18 <lars9> i uninstalled it from my arch because it's updated very frequently and takes a lot of time to compile
06:20:17 <Axman6> eh?
06:20:46 <ivanm> lars9: hlint isn't that big....
06:20:53 <ivanm> and isn't updated that often nowadays AFAIK
06:21:21 <ivanm> latest release 3 April; previous release 31 Jan
06:21:29 <lars9> really? i need to stop everything for it to compile (1G mem)
06:21:30 <ivanm> doesn't sound like frequent updates to me...
06:21:57 <ivanm> lars9: for _hlint_? :o
06:22:04 <ivanm> what kind of hardware do you have?
06:22:13 <ivanm> OK, there were a spate of released at the end of Jan
06:23:04 <lars9> ivanm: yeah. my thinkpad x200s with 1G mem.
06:23:13 <ivanm> what CPU?
06:23:47 <lars9> low voltage cpu, about 1.3G 
06:24:05 <ivanm> ahhhhh
06:24:11 <ivanm> that must suck for _any_ kind of development
06:25:52 <lars9> uhhh that's why i rarely install things in aur. i need to use ocaml a lot in my work and i found it compiles faster than ghc
06:27:49 <ivanm> lars9: my suggestion: get a better machine :p
06:28:52 <quicksilver> my suggestion : don't use a distribution which recompiles pacakges all the time on a slow machine.
06:32:05 <xplat> or at least set it up with distcc on a faster machine
06:32:41 <lars9> this is scary to me: http://stackoverflow.com/questions/4626884/improving-treap-implementation
06:32:52 <ksf> http://www.haskell.org/haskellwiki/Hoare_Property
06:33:02 <ksf> http://www.haskell.org/haskellwiki/Vogonism
06:33:04 <ksf> discuss.
06:33:06 <xplat> (and do updates when you are on a lan with the fast machine)
06:33:41 <lars9> if it's so complicated to tune such a small program's performance, how to tune a 10K lines of code's?
06:34:15 <Jafet> Find the small program hiding inside the code and tune it.
06:34:28 <shachaf> You'll find that people spend a disproportionate amount of time on small pieces of code like this in most languages.
06:34:47 <ivanm> @slap ksf 
06:34:47 <lambdabot> I don't perform such side effects on command!
06:34:51 <ivanm> wtf is that doing on the wiki?
06:35:16 <Jafet> Or, well, hire dons.
06:35:20 <ksf> the wiki *is* a place to collect things about the property of code.
06:35:34 <ksf> cf. "do-notation considered harmful"
06:35:44 <ivanm> reads more like flamebait to me IMHO
06:35:47 <ksf> as to the hoare property, there's not a single source on the web actually explaining it.
06:35:51 <ivanm> and there's nothing haskell-specific there
06:35:58 <ivanm> ksf: isn't that what wikipedia is for?
06:36:04 <xplat> Vogonism has at best a vague relation to code
06:36:30 <ksf> oh, I see, you're all going into the basement to laugh.
06:36:48 <Saizan> i don't get the last period of the vogonism article
06:36:50 <Jafet> We have a basement?
06:36:57 <ivanm> besides, I hate it when people just paste links and say "discuss"
06:37:10 <xplat> #haskell-blah is the basement?
06:37:12 <opqdonut_> how about when they say "discus"?
06:37:18 <Jafet> No, that's abasement.
06:37:27 <Axman6> lars9: what Don did there is basically what he does for a living, he's very good at it. not everyone needs to do that. but if you want performance, yoy need more than basic understanding of haskell^Wany language
06:37:34 <ivanm> Saizan: it's there to finish off the phrase "Constrast Hoare Property"
06:38:19 <ksf> ivanm, the wiki isn't only about haskell, it's also about the haskell community.
06:38:30 <ksf> Now I have something to link to when information hits the fan.
06:39:36 <ksf> to get that "beware of the tiger" reference you have to have read the first or second chapter of the hitchhiker's guide
06:40:09 <ivanm> that reads as something better put into a blog post
06:40:25 <ivanm> "Being a general and absolute truth" <-- where does that even come from?
06:41:02 <lars9> Axman6: thanks, that's a big relief
06:41:36 <xplat> ivanm: i think that's just bad english.
06:42:17 <ksf> well, as it's a characterisation of a system, it can hardly be false.
06:42:29 <ksf> it could only be never-occuring, which I doubt.
06:42:43 <ksf> or rather, category of systems.
06:42:44 <ivanm> ksf: reads too much as "it's true because"
06:43:27 <xplat> ksf: in english we would use the word 'concept' rather than 'truth' there
06:43:30 <ksf> well, that's not completely unintended. to trip over people who don't even snigger before going into the cellar to laught...
06:43:48 <ksf> xplat, good call.
06:44:22 <xplat> and 'universal' instead of 'absolute'
06:44:57 <ivanm> that makes more sense then
06:45:09 <ksf> .oO( "a", not "an" universial concept, as "yoo" isn't a vowel but affricative )
06:45:14 <ivanm> still, it reads too much as a rant that someone has put up about some random topic that they have no authority about
06:45:29 <quicksilver> ivanm: (welcome to the interent;)
06:45:49 <ksf> ivanm, I actually just translated it from the german definition.
06:46:22 <cheater> are there any haskell related meetups in southern germany? maybe in munich?
06:46:45 <ivanm> quicksilver: right, I'm just arguing that it shouldn't be on the haskell wiki
06:46:54 <ivanm> since it isn't even a random _haskell_ topic
06:47:34 <ksf> ivanm, so you want to hide it somewhere where it's more "public"?
06:47:49 <Jafet> Unless I have to mirror the haskellwiki with floppy drives, I don't really care
06:48:00 <ivanm> Jafet: heh
06:48:14 <ivanm> ksf: it just doesn't read like something that should be there
06:48:54 <ivanm> and tbh it doesn't seem to make much sense or be relevant
06:48:55 <ksf> ivanm, well, one could possibly arrange the wording as to be more explicit about the relation to code
06:49:04 <ivanm> right
06:49:17 <ksf> but I'm gonna need to zen about that, first.
06:49:20 <ivanm> after re-reading a few times, I guess you're referring to "hidden knowledge" of how to profile, etc. ?
06:50:07 <ksf> I'm more claiming that people who don't consciously work towards the hoare property are undercover vogon agents.
06:50:40 <xplat> having Vogonism defined on haskellwiki almost seems like an example of it since it's something i'd more expect to find somewhere like wiktionary or c3, haskellwiki isn't a place that i would look for general concepts like these
06:50:40 <crystal-cola> what's the hoare property?
06:50:53 <ivanm> ksf: but since the hoare property seems to be your own "metric"
06:50:58 <ksf> crystal-cola,  http://www.haskell.org/haskellwiki/Hoare_Property
06:51:03 <ivanm> and I doubt it is possible to fulfil in general
06:51:09 <ivanm> especially if you want performance
06:51:16 <ivanm> xplat: heh, yup
06:51:21 <ksf> ivanm, just because you didn't hear about it doesn't mean that I invented it.
06:51:36 <xplat> Hoare property = 'so simple there are obviously no bugs in it'
06:51:48 <ivanm> ksf: googling for "hoare property" _with_ quotes just returns links about realtors
06:52:09 <ksf> I first came across it in a haskell paper.
06:52:38 <ivanm> oh?
06:52:42 <xplat> if you aggressively use formal methods you can do things like have a Hoare Property-possessing implementation as a runnable spec and prove your optimized version equivalent to it
06:52:58 <ksf> the quote is on the net in several wordings, that's a strong indicator for it having been transferred a lot
06:53:03 <cheater> no haskell in germany? :(
06:53:33 <ksf> or his birthday talks?
06:53:38 <ksf> don't remember.
06:54:08 <ksf> ...it's not like I'm quoting stroustrup, after all.
06:54:11 <ivanm> ksf: seems to be a term used by a select group of haskellers then
06:54:41 <ivanm> I've found one mention on proggit by barsoap; and a couple of mentions by SPJ
06:54:50 <xplat> i do think i remember this being referred to in a birthday talk/paper that used a functional language and it might have been haskell
06:54:57 <ksf> well, barsoap'd be me.
06:55:02 <ivanm> ahhh
06:55:17 <ivanm> OK, possibly a paper by Hughes
06:55:20 <xplat> although i don't know if the precise phrase 'Hoare property' was used
06:55:30 <ivanm> http://www.google.com.au/search?hl=en&safe=off&q=%22hoare+property%22+haskell&aq=f&aqi=&aql=&oq=
06:55:37 <Saizan> that quote is often cited here by monochrom :)
06:56:09 <ivanm> Saizan: hoare's quote?
06:56:13 <ivanm> or the term "hoare property" ?
06:56:44 <CADD> hi guys, so i am working on a little text gui for my program that i wrote, but for some reason it does not seem to be passing the variables between functions.. Ive been trying to use the ghci debugger to no avial, but it seem that the variables are no where to be found.. example code coming asap
06:56:59 <Saizan> ivanm: hoare's quote
06:57:09 <ivanm> Saizan: *nod*
06:57:12 * ivanm -> land of nod
06:58:31 <CADD> main::IO()  putStr "I need a variable"  variableOne <- getLine funtionFoo (read variableOne::Int)
06:59:15 <CADD> but it seems when i pass the variable into functionFoo that the variable doesnt even exist, even though it all interperates fine..
06:59:21 <xplat> CADD: that doesn't look like haskell code
06:59:37 <CADD> xplat: in what wat?
06:59:44 <CADD> way*
06:59:55 <ion> Perhaps it got broken when pasted to the IRC client. Try hpaste.
06:59:58 <ion> @where hpaste
06:59:58 <lambdabot> http://hpaste.org/
07:00:08 <CADD> haha, will do
07:00:19 <xplat> well, main :: IO() looks like you're trying to define 'main' but there is no 'main ='
07:00:26 <lunaris> It's putStr "" >> getLine >>= \variableOne -> functionFoo (read variableOne :: Int)
07:00:40 <lunaris> I'm guessing is how the line breaks should be appearing
07:01:05 <jonkri> is there someone here that i can talk to about planet haskell? i've been trying to send two e-mails to planet@community.haskell.org but have not received a reply
07:04:17 <CADD> www.hpaste.org/45807/io_problems
07:04:23 <CADD> thanks guys
07:05:09 <CADD> im just doing do notation for right now, just for its simplicity
07:05:30 <siracusa> jonkri: What was your question to Planet Haskell? Maybe we can help you out.
07:07:29 <CADD> so say i choose the default coins options and go straight to addCoinsToPopulation, in ghci after i have hit a breakpoint it just seems like coins does not exist
07:07:29 <BONUS> hpc: ping
07:07:58 <Palmik> Hmm, can you somehow make parsec fail if not the whole string was proccessed?
07:08:31 <CADD> Palmik: was that at me?
07:08:32 <Saizan> Palmik: see the "eof" parser
07:08:38 <CADD> nvm
07:09:06 <Palmik> Saizan, thanks
07:09:43 <Saizan> CADD: maybe you'd have more luck just by adding print statements to show coins
07:10:05 <CADD> hmm.. alright, ill do that
07:10:17 <tarrasch> Hello. I'm an Ubuntu user, Ubuntu provides cabal-install through repo, but it seem a little bit old. Is it a wise idea to replace that with the later cabal by issuing cabal install cabal-install?
07:11:44 <stepkut> why does, show "foo", work when OverloadingStrings is enabled. I would expect it to get an ambigious instance because we have: show ("foo" :: (IsString a) => a), and so it does not know which Show instances to use..
07:11:59 <Saizan> tarrasch: the only problem is that it'll install a new Cabal (the lib) too, probably, and that might cause problems, also it'll get installed in ~/.cabal/bin so check your PATH
07:13:37 <tarrasch> stepkut, is that different from '5 + 3'? Just which num to choose. I think ghci defaults to Integer in num cases or something. Here it probably to defaultes to String. Just gessing
07:14:18 <Saizan> yeah, it's probably defaulting
07:14:23 <dcoutts> ghci has relaxed defaulting rules
07:14:36 <dcoutts> stepkut: see if it works in a compiled prog :-)
07:14:56 <Saizan> also, see if you get a defaulting warning
07:15:05 <siracusa> CADD: In addCoinsToPopulation your define 3 let bindings but never use them. Is that intended?
07:15:22 <stepkut> dcoutts: ah right. 
07:15:32 <stepkut> dcoutts: i knew that for a few seconds, but then forgot
07:16:07 <stepkut> dcoutts: though, it works in a compiled program as well..
07:16:54 <tarrasch> I just wiped out my .cabal in $HOME to get a fresh start. Still `cabal install cabal-install` fails. I highly suspect I've used --global sometime that clogs things. Where does cabal store its global files?
07:17:35 <tarrasch> stepkut, With a monomorphic signature inferenced implicitly? 
07:18:20 <CADD> siracusa: I do, i use them in the commented line, but it doesnt matter in the scope of the problem
07:19:12 <stepkut> tarrasch: 'main = putStrLn $ show "foo"' and 'main = putStrLn $ show ("foo" :: (IsString a) => a)', both compile fine
07:19:47 <rostayob> stepkut: in ghci, with -Wall, it warns you that is defaulting to String
07:20:03 <rostayob> Warning: Defaulting the following constraint(s) to type `String'
07:20:07 <tarrasch> I think he means for compiled programs
07:21:14 <tarrasch> stepkut, hmm, That's a mystery for me aswell, but I'm far from any expert around here :)
07:23:10 <rostayob> tarrasch: I get the same warning while compiling
07:24:00 <rostayob> the same happens with Num, it defaults to Integer
07:24:00 <tarrasch> Ah. You mean that the defaulting happens not only to the interactive environment.
07:24:02 <Saizan> tarrasch: ~/.cabal is where cabal-install keeps its files, ~/.ghc/ is where the databases of the user-installed packages are kept
07:24:19 <rostayob> tarrasch: yeah
07:25:01 <dcoutts> stepkut: perhaps they just added IsString to the classes that defaulting happens for, with String as the default.
07:25:31 <tarrasch> Saizan, isn't there a --global command that installs it somewhere else but  ~/.cabal ?
07:25:47 <rostayob> yeah actually it wasn't like that a few weeks ago... but it's better this way I guess
07:26:10 <tarrasch> rostayob, The defaulting was implemented a few weeks ago?
07:26:38 <rostayob> tarrasch: idk, but I remember having to specify the monomorphic type when using OverloadedStrings with functions that required IsString
07:26:44 <Saizan> tarrasch: anything that matters is manages by ghc-pkg, so look at ghc-pkg list
07:26:51 <Saizan> *managed
07:27:43 <Cin> thoughtpolice: How do you create an object literal with hjscript?
07:35:23 <mpiechotka> @pl \x y -> f (g x) (g y)
07:35:24 <lambdabot> (. g) . f . g
07:35:51 <mpiechotka> @pl \g x y -> f (g x) (g y)
07:35:51 <lambdabot> flip =<< (((.) . f) .)
07:36:37 <siracusa> :t on
07:36:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:36:55 <rostayob> speaking of HJScript, I'm reading the thesis about hsp + hjscript
07:36:55 <ion> @pl \x y -> f (($x) g) (($y) g)
07:36:55 <lambdabot> (. g) . f . g
07:37:01 <rostayob> and things seem to be quite different
07:37:05 <ion> @pl \x y -> f (x g) (y g)
07:37:05 <lambdabot> (. ($ g)) . f . ($ g)
07:37:08 <rostayob> for example, the function example
07:37:27 <rostayob> function $ \(a, b) -> a .+. b
07:37:29 <rostayob> doesn't work
07:37:39 <rostayob> is there any other documentation at all?
07:37:56 <siracusa> > ((==) `on` fst) (1, 2) (1, 3)
07:37:57 <lambdabot>   True
07:38:14 <siracusa> mpiechotka: ^ this?
07:39:51 <ion> > ((f :: Expr -> Expr -> Expr) `on` g) a b
07:39:52 <lambdabot>   f (g a) (g b)
07:40:37 <sipa> :t on
07:40:38 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:41:04 <mpiechotka> siracusa: Yes
07:41:31 <CADD> Saizan: Thanks for the printing idea, made me find out that I wasnt hitting my edge case in one of my funtions!! You guys are great
07:41:39 <mpiechotka> @hoogle on
07:41:39 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:41:39 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
07:41:40 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:42:02 <rostayob> mpiechotka: ahah are you maciej piechotka? I think I'm in the same course as you at imperial ehe
07:45:59 <mpiechotka> rostayob: Yes
07:47:19 <rostayob> mpiechotka: yeah, we're in the same course. I'm francesco
07:52:43 <BONUS> last call for free review copies of LYAH!
07:52:59 <BONUS> if you want a free copy & want to review it on amazon, msg me!
07:59:34 <tromp_> :t fromEnum
07:59:35 <lambdabot> forall a. (Enum a) => a -> Int
08:00:13 <Twey> Should've been Integer
08:04:08 <tromp_> :t sgn
08:04:09 <lambdabot> Not in scope: `sgn'
08:04:34 <copumpkin> :t signum
08:04:35 <lambdabot> forall a. (Num a) => a -> a
08:04:41 <tromp_> thx
08:04:59 <copumpkin> :t subtraheo
08:05:00 <lambdabot> Not in scope: `subtraheo'
08:05:07 <copumpkin> :t subtractio
08:05:08 <lambdabot> Not in scope: `subtractio'
08:05:45 <c_wraith> copumpkin, those look like spell names from Harry Potter
08:05:54 <Silvah> c_wraith: :D
08:06:07 <copumpkin> the power of latin to evoke thoughts of harry potter!
08:06:15 * copumpkin wields the great power with great responsibility
08:06:34 <c_wraith> Most of the harry potter spell names were fake latin.
08:06:41 <copumpkin> indeed
08:06:44 <c_wraith> In the case where real latin looks like fake latin... :)
08:06:57 <Twey> Heh
08:11:04 <Quex> buy purpouse mugs, tshirts and magnets. A common misspelling of the word ... -What is the purpouse of this mindless experimentation, Bob?
08:12:49 <Axman6> oh god, the junkies have finally found IRC
08:13:14 <Boxo> ...what
08:13:31 --- mode: ChanServ set +o copumpkin
08:13:45 --- mode: copumpkin set +q Quex!*@*
08:13:51 --- mode: copumpkin set -o copumpkin
08:16:03 <ion> A Markov chain talkbot or similar?
08:16:09 <copumpkin> probably
08:16:20 <copumpkin> with a username of haha and spouting that kind of shit, it doesn't seem too unlikely
08:19:33 <djahandarie> copumpkin, I fear that you have matched that exact criteria before
08:20:27 <copumpkin> no username of haha
08:20:36 <copumpkin> what if it's a japanese mom though?!?
08:21:14 <djahandarie> No one would call themselves 母 :p
08:21:40 <copumpkin> djahandarie: what if you are your own mom?
08:21:48 <razieliyo> what?
08:21:52 <djahandarie> Hahahaha
08:22:03 <copumpkin> razieliyo: welcome to #haskell!!
08:22:08 <razieliyo> hi copumpkin 
08:22:10 <razieliyo> you scared me
08:22:26 <Jafet> occurs check: your mom is infinite
08:22:55 <zygoloid> razieliyo: don't worry, it's just a fixed point. don't apply a strict fold to djahandarie's mom though!
08:23:36 <mxc> X is a type function and may not be injective.  but I am injective.  into your mom
08:23:41 <djahandarie> My Mom got me a _cat_amorphism and I realized that I was my own Mom...
08:23:44 <ion> copumpkin = a where a = Person { mother = a }
08:23:49 <razieliyo> well, I can't really understand your jokes because I'm starting
08:23:53 <copumpkin> if you marry your divorced dad, and are a female, are you your own stepmom?
08:24:02 <razieliyo> and ion, that where is the point because of that I'm here
08:24:06 <razieliyo> where clause
08:24:11 <razieliyo> when is it used?
08:24:17 <mxc> copumpkin: maybe, maybe not.  but you're defeinitely in kansas
08:24:22 <mxc> definitely
08:24:31 <copumpkin> :)
08:25:01 <ion> razieliyo: With ‘foo = bar’ style definitions to define local names available in the scope of ‘bar’.
08:25:13 <razieliyo> "Anyone need a medic?"
08:25:23 <razieliyo> ok, so, I think I understand
08:26:22 <ion> oHai name = pre ++ name ++ post where pre = "o hai, "; post = "!"  -- contrived
08:42:46 <Cin> Is there a way to get GHCi to load all the packages it needs before I evaluate an expression?
08:43:11 <hpc> BONUS: pong
08:43:14 <Cin> It kind of loads packages lazily until I evaluate an expression using a module in the package.
08:46:10 <Jafet> Cin: you can load them manually with -package
08:47:27 <elventear> Hello I am trying to do a query using Takusen and I don't seem to be able to get GHC to like my code. http://hpaste.org/45808/ here is a sample code and the error output, I would appreciate any help in understanding what is wrong with that code.
08:57:11 <mjrosenb> elventear it looks like you just want to get rid of Monad m =>, and replace m with IO in the signature
09:07:20 <elventear> mjrosenb: withSession has IO output, but doQuery has  output DBM, another Monad, output and it calls iter which uses Either to guide the iteration. Changing the signature didn't help.
09:10:52 <jonkri> if someone here have a couple of minutes to spare, i would really appreciate some architectural feedback on my logging library so that i can continue to improve it... i asked on the haskell-cafe list but no one answered :P http://hackage.haskell.org/package/hlogger/ thanks!
09:12:00 <JuanDaugherty> does it conform to the log4X pattern?
09:12:32 <xplat> el ventear: probably best just to get rid of the type signature for iter
09:12:36 <osoleve> are there any libraries that offer weighted random number generation aside from random-extras? (it fails to build)
09:13:13 <xplat> JuanDaugherty: just look at the package name: obviously it conforms to the Xlogger pattern
09:14:54 <roconnor> will takeMVar and modifyMVar_ block when the MVar is empty?
09:14:54 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
09:15:06 <mm_freak> roconnor: yes
09:15:10 <roconnor> ah
09:15:27 <roconnor> so I sjord's code is thread safe even though it looks scary :D
09:15:34 <JuanDaugherty> xplat: I would not have made such an inference.
09:15:53 <roconnor> ivan: I did, but I didn't understand Bram's post.
09:17:11 <wolverian> how is the semigroups package's Option's Monoid instance better than Maybe's? 
09:17:49 <wolverian> (FWIW, saying your implementation is better than another without saying exactly how is a big fuck you to prospective users of your module.)
09:19:13 <quicksilver> because it requires a Semigroup instance?
09:19:14 <jmcarthur> wolverian: it says right in the docs: "[...] built off of an underlying Semigroup instead of an underlying Monoid."
09:19:16 <quicksilver> as the docs say
09:20:03 <jonkri> JuanDaugherty, sorry, didn't see your message sooner. you mean formatting the logging events according to a "conversation pattern"?
09:20:07 <wolverian> well, given that Semigroup is undocumented, figuring that out is nontrivial. :)
09:20:20 <wolverian> (for me, anyway.)
09:20:50 <jmcarthur> Semigroup's name is the documentation
09:21:04 <c_wraith> only for people who know enough algebra
09:21:12 <JuanDaugherty> jonkri, no I meant following the general conventions of the most popular family of logging packages the original of which I think was called log4j and was for java
09:21:14 <wolverian> jmcarthur: that's the attitude that makes me hate haskell just a bit.
09:21:29 <jmcarthur> wolverian: the attitude that says if you don't know what something means you should look it up?
09:21:52 <JuanDaugherty> wolverian, stick around, your animosity will ripen like a fine wine
09:22:00 <jmcarthur> i've never seen library documentation explain what addition is
09:22:18 <wolverian> jmcarthur: the attitude that the meaning of algebraic names is self-evident in the context of haskell.
09:23:22 <jonkri> JuanDaugherty, it doesn't have much more than log levels, and the log levels are based on syslog
09:23:31 <JuanDaugherty> ah
09:23:33 <jmcarthur> we already have the vocabulary. to explain every little detail that isn't haskell- or library-specific would be overly verbose, IMO
09:24:21 <jmcarthur> there are tons of maths that people *don't* explain in library documentation
09:24:26 <jmcarthur> haskell or otherwise
09:24:36 <jmcarthur> even more obscure maths
09:24:43 <jonkri> will take a look at log4j though :)
09:24:51 <jmcarthur> e.g. i don't think i've ever seen a physics or graphics library explain what a quaternion is
09:25:46 <wolverian> jmcarthur: right. but it would be nice to see why semigroups are useful *in the context of haskell* and, more specifically, in the context of Option/Maybe, in the package's documentation.
09:26:11 <jmcarthur> wolverian: because it is more general than Monoid. that's about it
09:26:34 <jmcarthur> sometimes you just don't need an identity element
09:26:37 <wolverian> jmcarthur: saying that much in the documentation would be helpful. :)
09:26:47 <jmcarthur> but that's the definition of a semigroup
09:27:57 <wolverian> then elaborate on what it is useful for in the context of haskell.
09:28:08 <jonkri> i have to bring this up again... what is the problem with lgpl and haskell binaries again?
09:28:10 <wolverian> or is haskell so close to algebra that you don't think it's necessary?
09:28:11 <jmcarthur> i would be in favor of linking to some information on semigroups, but there isn't really anything interesting about haskell specifically
09:28:15 <jonkri> lgpl libraries, that is
09:28:35 <wolverian> because then you're basically saying "learn algebra".
09:28:43 <jmcarthur> wolverian: the only unusual thing about haskell in this case is _|_, but it works pretty naturally with algebras anyway
09:28:43 * JuanDaugherty agree's that DRY is good and any unambiguously identified mathematices needn't be further documented.
09:28:47 <jmcarthur> wolverian: exactly
09:28:58 <JuanDaugherty> *mathematics
09:29:01 <jmcarthur> hard to be effective with algebra without knowing it anyway
09:29:29 <wolverian> I'm symphatetic to that view, but it's a lot of work, and it's work that doesn't get you immediate results *in haskell*, which makes it pedagogically awkward.
09:29:52 <beastaugh> that's true of a lot of things
09:30:01 <jmcarthur> wolverian: if you google semigroup you will find a pretty clear explanation in very few words on wikipedia
09:30:04 <beastaugh> people are forever talking about category theory, for example
09:30:15 <jmcarthur> "In mathematics, a semigroup is an algebraic structure consisting of a set together with an associative binary operation. A semigroup differs from a group in that there might not exist an identity element; further, for each of its elements there might not exist an inverse."
09:30:23 <jmcarthur> not sure how to be much more clear
09:30:36 <Jafet> Semigroups aren't webscale
09:31:00 <hpc> jmcarthur: besides define a few of the terms in the article :P
09:31:17 <wolverian> jmcarthur: I suppose I just haven't internalised the view that haskell is algebra disguised in a programming language's clothes.
09:31:18 <hpc> wolverian: do you know what a monoid is? a semigroup is basically a monoid without mempty
09:31:25 <jmcarthur> hpc: terms that are commonly used in programming already, like "associative"?
09:31:29 <wolverian> hpc: I do, yes. I'm trying to make a more general point.
09:31:55 <jmcarthur> honestly i use these words in languages other than haskell, too
09:32:23 <jmcarthur> if not in my code then in my explanation of the code
09:32:42 <wolverian> jmcarthur: you're exceptional.
09:32:48 <Jafet> "You could have invented semigroups! Really!"
09:32:48 <jmcarthur> not really
09:32:52 <wolverian> (in the wider programming language community, if not in haskell.)
09:32:53 <traviscline> cleanest way to get the tuple from a list that has the max second element? e.g. (1,11) from [(3,10),(4,9),(1,11)]
09:33:25 <jmcarthur> i find it unfortunate that so many programmers have the attitude that nothing is worth learning unless your boss tells you to
09:33:47 <wolverian> I'm looking at this from a university teacher's viewpoint.
09:33:47 <JuanDaugherty> the wider programming language community is next to meaningless it's so vast
09:34:04 <amalloy> fwiw, i never took any abstract-algebra/group-theory in school, and i find the definition of semi-group cited pretty clear
09:34:10 <wolverian> JuanDaugherty: we can focus it to e.g. our next freshman programming class. :)
09:34:15 <Jafet> wolverian: you expect people to stop thinking with advanced concepts, because you find that offensive to yourself?
09:34:20 <jmcarthur> :t maximumBy
09:34:20 <zygoloid> > maximumBy (comparing snd) [(3,10), (4,9), (1,11)]
09:34:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:34:21 <lambdabot>   (1,11)
09:34:23 <Jafet> wolverian: okay, fuck you.
09:34:24 <amalloy> eg, addition over the integers is a group; addition over the positive integers is a semi-group (i think?)
09:34:35 <jmcarthur> woah
09:34:36 <traviscline> thanks
09:34:43 <wolverian> amalloy: sure, the definition is not cited, though.
09:34:57 <amalloy> wolverian: so? you don't have google?
09:35:07 <jmcarthur> wolverian: addition is not explained. do you need it to be explained?
09:35:33 <wolverian> jmcarthur: if it were unfamiliar to me, yes. 
09:35:36 <c_wraith> jmcarthur: would it be really awful if the one function in the class just said "this operation must be associative"?
09:35:55 <jmcarthur> c_wraith: i'm not against documentation
09:36:01 <wolverian> Jafet: what makes you think advanced concepts are offensive to me?
09:36:02 <c_wraith> Since that's the only relevant part of the definition for implementing the class
09:36:02 <jmcarthur> c_wraith: i'm against bitching about math
09:36:06 <amalloy> if i saw some code say "this typeclass is like Rings in group theory" i'd be like, "oh noes, rings, what, i don't know anything about those and i wish they were explained here. oh well, guess i'll spend ten seconds looking them up on google"
09:36:14 <wolverian> jmcarthur: I'm sorry if I sounded like bitching about math. that wasn't my intention.
09:37:04 <jmcarthur> wolverian: i'm all for saying something about what a semigroup is. i just disagree that it's worth complaining about if it's not there, considering that it's one of the easiest math things to google for
09:37:39 <wolverian> jmcarthur: I suppose we agree. I meant to mainly ask for clarification, the bitching was incidental.
09:37:43 <jmcarthur> wolverian: and to answer a previous question more directly, yes, i do think its applications to haskell are self-evident if you are used to using other algebras in haskell like Monoid
09:37:53 <wolverian> a pull request on github would be more constructive, I agree. :)
09:38:58 <Jafet> Blaming people for "not explaining to me what a semigroup is" is an excellent sign of chronic anti-intellectualism.
09:39:15 <jmcarthur> i don't think that's the only possible explanation, Jafet 
09:39:21 <jmcarthur> it could just be laziness ;)
09:40:03 <jmcarthur> perhaps those are the same thing sometimes
09:40:45 <Jafet> Being lazy, I just promise myself to look up the terms... eventually
09:40:49 <wolverian> Jafet: that's now exactly what I was complaining about. my question was roughly this: why is Option's Monad instance better than Maybe's? I still think the documentation could be more clear on this.
09:41:04 <hpc> @src Option
09:41:05 <lambdabot> Source not found. Maybe you made a typo?
09:41:08 <wolverian> s/Monad/Monoid/
09:41:58 <jmcarthur> wolverian: it is clear on it:  "[...] built off of an underlying Semigroup instead of an underlying Monoid."
09:42:21 <c_wraith> hmm.
09:42:30 <jmcarthur> wolverian: which if you know what a semigroup is tells you that the monoid instance uses semigroup instead of monoid for the underlying instance
09:42:38 <c_wraith> > mempty :: Maybe String
09:42:39 <lambdabot>   Nothing
09:42:58 <c_wraith> Ah, I see.  depending on Monoid is unneeded, since it never uses mempty
09:43:04 <jmcarthur> right
09:43:12 <jmcarthur> > Nothing `mappend` Just "foo"
09:43:13 <lambdabot>   Just "foo"
09:43:21 <jmcarthur> hmm
09:43:26 <wolverian> right. that was not clear to me immediately. asking here made it clear to me very quickly. :)
09:43:32 <jmcarthur> yeah that's right
09:44:21 <c_wraith> mempty could also be Just mempty and satisfy the Monoid laws...
09:44:38 <c_wraith> woo, ambiguity!
09:45:16 <hpc> c_wraith: what would Nothing `mappend` Just mempty be?
09:45:19 <zygoloid> "Option turns a Semigroup into a Monoid by adding an empty value." ?
09:45:22 <hpc> Nothing, or Just mempty?
09:45:33 <hpc> oh, nvm
09:45:36 <c_wraith> hpc: Just mempty, by the monoid laws :)
09:45:42 <jmcarthur> zygoloid: yeah that might be more clear at least
09:45:47 <c_wraith> err, actually, Nothing, by the monoid laws
09:45:52 <c_wraith> Ok, that's confusing
09:45:57 <c_wraith> But it would satisfy the laws
09:46:14 <jaspervdj> I don't think Nothing would satisfy `mappend x mempty = x`
09:46:36 <jaspervdj> Therefore, mempty = Just mempty
09:46:36 <jmcarthur> no it would work
09:46:48 <jmcarthur> it's the instance you get from   mempty = pure mempty; mappend = liftA2 mappend
09:47:10 <c_wraith> It satisfies the laws, but it's a very unusual way to view the type
09:47:26 <jmcarthur> you can lift any Applicative to a Monoid that way
09:47:32 <jmcarthur> err
09:47:39 <jmcarthur> lift any Monoid using Applicative
09:47:46 <jmcarthur> my phrasing needs work
09:48:29 <jmcarthur> > liftA2 mappend Nothing (Just mempty) :: Maybe String
09:48:30 <lambdabot>   Nothing
09:50:27 <heatsink> I've seen a couple papers like the Stream Fusion paper that carefully design libraries so that compiler optimizations will eliminate most or all of the abstraction overhead.
09:50:57 <heatsink> Is there a paper, book, or something about this methodology?
09:51:10 <heatsink> Or just lots of papers about specific instances of this methodology?
09:51:45 <jmcarthur> stream fusion is a specific case of deforestation, if you just want something more general to google
09:52:04 <hpc> and get gobs of environmental websites
09:52:10 <heatsink> haha
09:52:27 <jmcarthur> g2g
09:52:45 <heatsink> ok, bye
09:53:22 <heatsink> I'm not looking for papers about the optimization methodology so much as the library design methodology
09:54:04 <heatsink> The central message of the stream fusion paper was on how to design streams to enable deforestation
09:54:25 <heatsink> Theres a Repa paper that does something similar for stencils
09:54:55 <heatsink> And DPH apparently has a similar design methodology, though I haven't seen a paper about the deforestation aspect of it.
09:54:58 <xplat> you have 'fusion' and 'deforestation' which are related
09:55:24 <xplat> actually they're pretty much the same thing looked at from different viewpoints
09:55:48 <heatsink> Fusion and deforestation?
09:56:00 <xplat> either you are fusing two functions together, or you are eliminating an intermediate 'forest'
09:56:17 <heatsink> Right
09:56:37 <xplat> but they are basically the same thing
09:57:11 <xplat> deforestation is less ungooglable than fusion though
09:57:32 <tromp_> there's no nuclear deforestation for one
09:57:32 <xplat> although they are both pretty bad
09:58:26 <xplat> wow, you just came up with a way to make being a lumberjack even more dangerous
09:58:31 <tromp_> oops; i spoke too soon; 61 results:(
09:58:43 <hpc> tromp_: any interesting ones?
09:58:51 <tromp_> seems not
10:00:16 <fryguybob> @tell Mathnerd314 There is an updated filestore now: http://code.google.com/p/gitit/issues/detail?id=115
10:00:17 <lambdabot> Consider it noted.
10:01:47 <xplat> in practice fusion is generally used to talk about more specific techniques, like buildr/fold fusion
10:02:20 <xplat> both for semantic reasons and because it's shorter
10:07:06 <heatsink> I'll read this query deforestation paper
10:09:28 <heatsink> Deforestation papers seem to be about optimizing a given kind of code, rather than writing code for a given optimizer
10:09:55 <tensorpudding> does gtk2hs still exist?
10:10:17 <tensorpudding> it doesn't seem to be on the haskell.org site anymore
10:10:20 <Jafet> Philosophically speaking?
10:10:29 <c_wraith> tensorpudding: it's in cabal now
10:10:34 <c_wraith> tensorpudding: well, hackage
10:10:37 <tensorpudding> oh
10:10:42 <c_wraith> meaning it can be cabal-installed
10:10:44 <tensorpudding> as gtk i imagine?
10:10:51 <c_wraith> I think it's still gtk2hs
10:10:51 <tensorpudding> this is an improvement
10:11:02 <dafis> tensorpudding: several subpackages
10:11:13 <tensorpudding> gtk works
10:11:17 <dafis> tensorpudding: cairo, pango, gtksourceview, ...
10:11:21 <tensorpudding> it's grabbing cairo now
10:11:29 <Jafet> You need to work around cabal's dizziness around binary dependencies, though
10:11:29 <tensorpudding> reasonable for them to break it up
10:12:16 <tensorpudding> ugh
10:12:22 <tensorpudding> stupid path manipulations
10:13:48 <djahandarie> AFAIK there are two ways to generalize deforestation. One is to monads, another is to Mu-recursive types
10:17:55 <djahandarie> See Johann, P.'s "A generalization of short-cut fusion and its correctness proof." for the prior, and http://unlines.wordpress.com/2009/09/29/squinting-at-fusion/ for the later
10:18:03 <dons> tensorpudding: its on hackage.
10:18:30 <tensorpudding> why isn't gtk2hs-buildtools listed as a dep for gtk?
10:18:52 <hpc> because it's a binary
10:18:55 <Jafet> cabal dizziness
10:18:56 <hpc> cabal only does haskell
10:19:05 <tensorpudding> that's pretty unfortunate
10:19:40 <dcoutts_> tensorpudding: it is listed as a dependency, but the current cabal-install package dependency solver only considers library dependencies, not build tools.
10:19:54 <tensorpudding> okay
10:19:58 <dons> it lists them as build tools
10:20:00 <tensorpudding> is this a wishlist item?
10:20:03 <dcoutts_> yes
10:21:38 <djahandarie> Also something interesting to look at is "Asymptotic Improvement of Computations over Free Monads"
10:22:43 <djahandarie> It works over a smaller subset of monads but tends to do better in getting asymptotic improvement than the other paper
10:24:41 <djahandarie> (btw, that last paper I linked is basically what is wrapped up as the 'codensity monad' in edwardk's category-extras)
10:40:21 <djahandarie> You know, we should just start adding rewrite rules to Monad to force people to fix their instances so their programs don't blow up when they -O
10:41:34 <Jafet> Wait, which instances are broken?
10:41:49 <djahandarie> All that stuff that abuses the do notation
10:42:09 <c_wraith> which stuff?
10:42:48 <djahandarie> blazehtml is one I can think of off the top of my head, but I know there is more
10:43:54 <c_wraith> Oh.  Things that actually aren't monads, but implement Monad just for do notation
10:44:05 <djahandarie> Yeah
10:44:15 <djahandarie> We should really find a better solution to this
10:44:30 <c_wraith> the rebindable syntax extension!
10:44:38 <djahandarie> Like, something for people to use to introduce nicer syntax WITHOUT invoking the glory of TH
10:44:41 <djahandarie> Oh yeah
10:45:05 <byorgey> Or mixfix operators ;)
10:46:26 <copumpkin> THE POWER OF MIXFIX COMPELS YOU
10:46:34 <copumpkin> (to not use it much)
10:48:58 <Jafet> _<-_;_ = ...
10:49:13 <byorgey> @remember copumpkin THE POWER OF MIXFIX COMPELS YOU (to not use it much)
10:49:13 <lambdabot> It is stored.
10:51:33 <Xaratas> hi, are there language elements to write this: http://hpaste.org/45814/trie_remove with more beauty?
10:52:07 <aavogt> you can use the syntax to update a record:
10:52:33 <aavogt>  remove [] x = x { value = Nothing }
10:52:35 <Xaratas> ok, second and third let are a bit useless
10:53:16 <twanvl> use guards instead of the if
10:54:30 <twanvl> or maybe pattern matching
10:57:46 <elliottt> dons: time to turn hmp3 into an xmms2 client
10:58:48 <aavogt> Xaratas: http://hpaste.org/paste/45814/trie_remove_annotation#p45816 lots of the changes are pretty arbitrary
10:59:18 <aavogt> one helpful thing is to avoid intermediate variables like   subtrie   vs.  subtrie'
10:59:54 <aavogt> at least if they only get used in one place
11:01:06 <aavogt> oh, and you can drop the   value = val too
11:01:26 <zygoloid> is hmp3 supposed to be pronounced something like 'Humphrey'?
11:02:04 <dons> elliottt: it has been suggested. need to decouple it from its mp3 backend
11:02:47 <dons> zygoloid: Aitch-Em-Pee-Three
11:03:34 <RichardO> @pl f x y z = g (h (i x) y) z
11:03:34 <lambdabot> f = (g .) . h . i
11:03:36 <djahandarie> "Humpthree"
11:04:05 <djahandarie> RichardO, which is g .: h . i if you define (.:) = (.).(.)
11:04:10 <int-e> Xaratas: another attempt, but I have not tried the code: http://hpaste.org/paste/45814/does_this_typecheck#p45817
11:04:58 <int-e> (and found the first mistake already, the }) on line 8 should be } )
11:05:17 <RichardO> djahandarie: What is the precedent of (.)?
11:05:48 <djahandarie> Precedent? Do you mean fixity? It's infixr 9 .
11:05:59 <xplat> > (f .: g) x y z
11:06:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:06:01 <lambdabot>    `GHC.Show.Show a'
11:06:01 <lambdabot>      a...
11:06:07 <xplat> > (f .: g) x y z :: Expr
11:06:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:06:08 <lambdabot>    `SimpleReflect.FromExpr ...
11:06:09 <int-e> hmm, it's function composition in math.
11:06:15 <xplat> :(
11:07:45 <byorgey> > (f .: g) x y :: Expr
11:07:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:07:46 <lambdabot>    `SimpleReflect.FromExpr ...
11:08:18 <djahandarie> I think the real problem is that it doesn't like two functions
11:10:29 <aristid> :t f .: (g :: Expr -> Expr)
11:10:32 <lambdabot>     Couldn't match expected type `g a' against inferred type `Expr'
11:10:36 <aristid> :t f .: (g :: Expr -> Expr -> Expr)
11:10:38 <lambdabot>       Expected type: Expr -> g a
11:10:39 <ski> > ((f :: Expr -> Expr) .: g) x y
11:10:40 <xplat> > let b f = (f :: Expr -> Expr -> Expr) in ((b f .: b g) .: b h) x y z w
11:10:44 <lambdabot> forall b. (SimpleReflect.FromExpr b) => Expr -> Expr -> b
11:10:46 <lambdabot>   f (g x y)
11:10:48 <lambdabot>   f (g (h x y) z) w
11:10:49 <djahandarie> Haha
11:11:21 <Xaratas> thanks aavogt and int-e
11:11:57 <ion> Criterion seems nice for benchmarking stuff.
11:12:45 <c_wraith> criterion is excellent, except in the case where you want to benchmark an implementation with a wide variety of input as a single test.
11:12:47 <TomMD> s/seems/is/
11:12:48 <xplat> > (((+) .: (+)) .: (+)) x y z w
11:12:50 <lambdabot>   x + y + z + w
11:13:03 <c_wraith> Though I guess you could use an IO test for that
11:13:15 <Kaidelong> @ty (.:)
11:13:16 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
11:13:53 <Kaidelong> @ty (.).(.)
11:13:54 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:14:03 <int-e> Xaratas: sorry, too many mistakes.  trie@Trie{ children = child }  is how you simultaneously match a variable with the whole and extract a field.
11:14:25 <azaq23> @type let b f = (f :: Expr -> Expr -> Expr) in b
11:14:26 <lambdabot> (Expr -> Expr -> Expr) -> Expr -> Expr -> Expr
11:15:09 <man> Hello, does anyone know why my Criterion installation complains that no (window|svg|png) support is available?
11:16:24 <dcoutts> man: presumably you built it without cairo graph support
11:17:07 <Kaidelong> what's an example of something that isn't Typeable/Typeable1/Typeable2 etc?
11:17:11 <Kaidelong> and can't be?
11:17:25 <c_wraith> I don't think anything can't be
11:17:32 <man> dcoutts: that could be it, yes...
11:17:34 <dons> you can always write an instance, it will just be shallow
11:17:41 <dons> e.g. for rank-N types
11:17:51 <dons> they can't be derived typeable "deeply"
11:17:57 <man> to my defense, there was no note of that anywhere I could see :P
11:17:59 <dons> (or at all), but you can write an instance
11:18:01 <Kaidelong> hmm
11:18:24 <int-e> man: there are 'Chart' and 'gtk' flags for building Criterion. Not sure whether they work (hmm, enabling gtk adds no new dependencies? odd.)
11:18:30 <Kaidelong> so you could make a general set that works pretty well by having it use typereps as keys
11:19:01 <man> I dunno. 'cabal install criterion' gave me this half cooked installation :S
11:19:20 <man> will I have to compile by source? (no cabal).
11:19:36 <man> (I'm willing to, btw, it's just that I don't wanna if it can be avoided)
11:19:52 <int-e> cabal install criterion -fgtk -fChart  might do better? or just -fgtk, it says that -fChart is broken in the cabal file.
11:19:57 <roconnor> ivanm: I did, but I didn't understand Bram's post.
11:20:37 <man> int-e: thanks, I'll try that.
11:20:58 <dcoutts> man: both Chart and gtk flags default to off in the current criterion release.
11:21:26 <man> dcoutts: that explains it. Thanks, dcoutts
11:22:17 <Skola> is there a place to get "offline" documentation for Haskell (for the standard libraries)?
11:22:25 <Kaidelong> I see that TypeRep is Show but not Read. This because of ambiguity?
11:22:41 <merijn> Skola: Your printer most likely :\
11:23:08 <monochrom> Skola: if you installed ghc, you already have the docs on your hard disk
11:23:09 <int-e> man: ah, the gtk flag is new in 0.5.0.7, possibly work in progress, so that may not work either. :-/
11:23:22 <Skola> ah, thanks monochrom
11:23:45 <monochrom> (why is this such a secret?)
11:24:14 <monochrom> (is it because these days people look for docs on twitter only?)
11:24:49 <Skola> Because the Haskell documentation is available so nicely online
11:24:53 <int-e> monochrom: it's not true if you compile ghc from source and don't also install a lot of tools ;) (or, worse, explicitely disable it in build.mk)
11:25:17 <Skola> hm I did compile it from source
11:25:30 <Skola> do the docs come with the haskell platform?
11:25:37 <monochrom> yes
11:26:25 <applicative> Xaratas: I didn't see everyone else had simplified, or 'beautified'.  Here's my feeble entrant: http://hpaste.org/paste/45814/trie_remove_annotation#p45818
11:27:05 <roconnor> dons: do you understand Bram's post?
11:29:13 <monochrom> (perhaps I'm looking at the exactly same behaviour as why we spend money to go to the moon but not the same amount of money to go to ocean floor or underground. people would spend whole lives browsing the outside web and not one second browsing their own disks)
11:29:30 * hackagebot criterion 0.5.0.8 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.8 (BryanOSullivan)
11:29:54 <Jafet> Can't really plant flags on ocean floors
11:30:08 <applicative> roconnor, I noticed luke palmer seems to understand it
11:30:30 <roconnor> applicative: what makes you think that?
11:31:03 <applicative> he makes comments at the bottom, 
11:31:25 <applicative> including "Very nice, simple example by the way."
11:32:02 <applicative> I couldn't generate a script like dcoutts' that went just that way though. 
11:32:12 <robnik> Is it possible to use `f' here for both Int -> Int and Float -> Float?  http://hpaste.org/45819/type_question
11:32:22 <robnik> As it is it fails type checking.
11:33:18 <merijn> robnik: It would be if you generalize the type of f, I think
11:33:38 <applicative> hm, robnik, it typechecks, might be I have monomorphism restiction off
11:34:11 <applicative> yeah. 
11:35:30 <roconnor> applicative: like dcoutts' ?
11:35:44 * dcoutts is confused too :-)
11:36:39 <applicative> oh, sorry, your post linked a little script of dcoutts that was making test/ and test/ 
11:37:13 <applicative> I was thinking that's what he was saying was 'too complicated' or whatever, so I was trying to simplify, and to get his result. 
11:37:35 <roconnor> applicative: simon's script
11:37:36 <applicative> or maybe i'm misremember it as dcoutts.  --sorry for waking you up sir!
11:37:44 <dcoutts> :-) np
11:38:00 <applicative> oh really,  okay.   "some guy over by Central"
11:38:09 <robnik> Okay, NoMonomorphismRestriction did it.
11:38:24 <icuucme> hi
11:38:50 <robnik> merijn: What did you mean by "generalize" the type of f?
11:38:51 <applicative> icuucme: hi, what are your expected and inferred types, respectively?
11:39:30 <merijn> robnik: Was just a guess, if it was the Dread Monomorphism Restriction it was wrong anyway :>
11:39:32 <applicative> robnik, the type inferencer was trying to attach a definite meaning to f, rather than a blur.
11:40:27 <Xaratas> applicative: do you think the first pattern (remove []     trie = trie) does the same? should this not be: remove []     trie = trie { value = Nothing } ?
11:41:39 <man> int-e: no luck. Have not tried Chart, but -fgtk hasn't done any good.
11:41:55 <man> int-e: thanks for the help, though. I'll try again later on.
11:43:08 <dcoutts> man: Chart is the important one
11:43:20 <dcoutts> gtk just lets you view charts in a window
11:44:33 * hackagebot cake 0.0.1 - A build-system library  http://hackage.haskell.org/package/cake-0.0.1 (JeanPhilippeBernardy)
11:44:49 <applicative> robnik, if you replace the f line with let f :: (Num a) => a -> a ; f = if neg then negate else id  then it passes the MonomorphismRestriction
11:45:16 <Xaratas> applicative: but yours looks best :)
11:45:40 <man> dcoutts: -fchar is the one I'm interested in, but alas... it appears to be broken for some time now.
11:46:23 <applicative> robnik, the problem, was that in MyFloat (f (read cs))   and  MyInt (f (read cs)), f is 'returning' different types, and presumably consuming different types
11:46:45 <roconnor> applicative: anyhow, nothing in Bram's post convinced me that git must necessarily be inconsistent.
11:46:49 <applicative> robnik: since MyFloat wants a Float, and MyInt wants an int
11:46:59 <roconnor> @tell ivanm anyhow, nothing in Bram's post convinced me that git must necessarily be inconsistent.
11:46:59 <lambdabot> Consider it noted.
11:47:20 <robnik> applicative: thanks, I'm trying to fit this into my "real" code ... the snipped I posted was a bit simpler.   I may post another one in a minute.  I had f <- [... from monad ...] as opposed to let f = ...
11:48:16 <Xaratas> jip
11:48:30 <xplat> roconnor: it seems like he says the case of pulling a change out of a branch and then sticking it back in is common enough that 'eventual consistency' will cause more headaches than it solves
11:48:52 <xplat> or at least, in the opinion of git's designers
11:49:19 <Xaratas> thanks :) learned that case in haskell is usefull compared to the dumb thing which is called switch case in java
11:49:33 <roconnor> xplat: huh?
11:49:56 <applicative> Xaratas right sorry, i messed up the first , remove []  , case as you said.
11:49:59 <KirinDave> xplat: Historically the git folks like history rewriting. I've heard a lot of unconvincing explanations why.
11:50:11 <merijn> Xaratas: Case isn't the only thing :p
11:50:14 <robnik> This has a similar error, even with the NoMonomorphismRestriction at the top.  http://hpaste.org/45820/monomorphism
11:50:37 <xplat> because an undone change wiping out the same change on another branch can only happen in a small window for git's design, but for a consistent, history-sensitive merge it will lie there like a landmine and undo the change you wanted to keep when you finally merge your experimental branch back in
11:50:43 <roconnor> xplat: if git followed an associative merge algorithm, both would end up with A.
11:50:45 <roconnor> xplat: as desired
11:50:59 <shachaf> preflex: seen ezyang
11:51:00 <preflex>  ezyang was last seen on #haskell 20 hours, 58 minutes and 16 seconds ago, saying: Oooh, I bet Don is going through and editing all the old post, and consequently filling up my RSS feed :-( 
11:51:29 <KirinDave> Is this one of those conversations where people are baffled by why so many software engineers trust git?
11:51:34 <xplat> roconnor: i don't think A was the desired outcome
11:51:42 <roconnor> sure it is
11:51:55 <roconnor> xplat: bram even compliained about A magically disappearing
11:53:19 <xplat> he complained about A disappearing in the case with X
11:54:01 <xplat> but in the simpler case he said B was right
11:54:22 <xplat> (or more precisely, he said it was usually right)
11:54:38 <roconnor> that's not how I read it
11:55:14 <xplat> So the preferred answer is that it should clean merge to B, the way 3 way merge does it.
11:55:25 <robnik> applicative: I tried your type annotation in http://hpaste.org/45820/monomorphism.   "signFun :: (Num a => a->a) <- sign"  But get errors that are beyond me, about RankNTypes.  
11:55:39 <xplat> ^ last sentence of the paragraph after the first figure
11:55:49 <robnik> Do you know how to fix that snippet as you did the first?
11:56:09 <roconnor> > Hey, where'd the A go? Everybody reverted their changes from B back to A, and then via the dark magic of merging the B came back out of the ether, and no amount of further merging will get rid of it again!
11:56:10 <lambdabot>   <no location info>: parse error on input `,'
11:56:21 <roconnor> xplat: that doesn't sound like he is saying it is prefered
11:56:59 <dafis> roconnor: that's the other case, not the one xplat was referring to
11:58:01 <xplat> roconnor: yes, i was referring to the first case.  he calls the case you are referring to 'massively busted', but he also says 'he solution to this problem in practice is Don't Do That.'
11:58:08 <xplat> *The
11:58:40 <roconnor> xplat: I didn't have any cross merges in my case
11:59:08 <roconnor> and in the first X case they are both cherry picking B from each other, so naturally the result is B.
12:00:04 <roconnor> in the first X case if they were not cherry picking they'd both get A.
12:01:16 <xplat> roconnor: i'm not sure he's RIGHT about the X case being unimportant since 'Having multiple branches which are constantly pulling in each others's changes at a slight lag' is what github is all about, but he definitely is saying that he thinks the first case is worth having the X case to deal with
12:01:40 <roconnor> I don't understand the point of the first case
12:01:51 <roconnor> Obviously in this case both sides should clean merge to A
12:01:53 <roconnor> I get taht
12:01:58 <roconnor> but what if people merge like this?
12:02:04 <roconnor> merge like what?
12:02:56 <xplat> that's not the first case, it's the second case
12:03:05 <roconnor> what is the fisr case?
12:03:30 <monochrom> @tell applicative http://www.vex.net/~trebla/tmp/what.jpg
12:03:30 <lambdabot> Consider it noted.
12:03:39 <xplat> the first case is the A -> B -> A and A -> B
12:04:20 <siracusa> Is there a way to disable warnings only for a single module?
12:04:38 <roconnor> xplat: well those two B's are different
12:04:42 <monochrom> some ghc-specific {-# blahblah #-}
12:04:58 <xplat> no, the whole point here is that B is the same
12:05:12 <roconnor> xplat: if they were the same they would be from the same source
12:05:25 <roconnor> xplat: git will give two instances of the same commit different hashes
12:05:30 <roconnor> they have different identities
12:06:25 <siracusa> monochrom: What blahblah? There's a warning pragma, but it seems to do something else.
12:06:36 <roconnor> xplat: and so such a merge should produce a conflict
12:06:49 <xplat> someone added a patch to the trunk, they realized it was too experimental and reverted the application to trunk, but decided it was worth experimenting with so applied it to the experimental branch
12:06:50 <roconnor> because both people are making the changes (the same change) to the same lines of code
12:07:12 <monochrom> {-# OPTIONS_GHC -fnowarn-incomplete-patterns #-}
12:07:20 <roconnor> xplat: the it would have been cherry picked into the experimental branch
12:07:25 <roconnor> *then it
12:07:36 <dafis> siracusa: {-# OPTIONS_GHC -fno-warn-unused-do-bind #-}
12:07:39 <roconnor> xplat: there be a conneciton between the B's in the two branches
12:07:45 <roconnor> xplat: and the result of the merge will be clear
12:08:03 <siracusa> monochrom, dafis: thanks!
12:08:14 <monochrom> {-# OPTIONS_GHC -w #-}
12:08:17 <xplat> roconnor: i don't think git works like that
12:08:39 <dafis> siracusa: if you want to turn off al warnigs, I think that was -w, but don't do that
12:08:49 <dafis> *wrnings
12:08:54 <roconnor> xplat: git could work like that
12:08:54 <dafis> *warnings
12:08:57 <dafis> grrrr
12:09:09 <monochrom> do that. use -w
12:09:14 <monochrom> :)
12:09:35 <roconnor> xplat: thanks for explaining.  I really appreciate it
12:09:38 <roconnor> I was so confused
12:09:40 <monochrom> {-# OPTIONS_GHC -w #-} {-:-}
12:09:43 <siracusa> I will do that, "I know what I'm doing" :-)
12:10:47 <dafis> siracusa: famous last words
12:12:04 <siracusa> dafis: It's for a happy-generated file actually, so there's better way I guess
12:14:32 <xplat> one thing that interests me though
12:17:01 <xplat> even though git and darcs have very different views of the world, i wonder if darcs could become able to understand git's repository format and be able to push and pull to/from it
12:18:29 <Heffalump> we plan to make a bridge
12:19:02 <roconnor> xplat: https://github.com/droundy/iolaus
12:19:34 <nyingen_> is there a haskell idiom for processing a directory full of files and building up a result? a naive approach with execState and mapM_ is resulting in too many open files
12:20:09 <parcs> are you forgetting to close the file handles?
12:21:41 <monochrom> that would be indeed naïve
12:23:39 <nyingen_> laziness from readFile
12:23:53 <xplat> anyway the obvious use case is 'host a darcs project on github'
12:24:17 <monochrom> you could do yourself a great service by using withFile instead
12:24:44 <xplat> i'm not sure if iolaus' approach would be suitable for that or not
12:25:32 <Heffalump> xplat: I'm hoping a bridge will make that reasonably pleasant
12:33:53 <Eduard_Munteanu> Is there any public free hosting for darcs repos, like github?
12:34:02 <Eduard_Munteanu> (like github for git)
12:34:11 <parcs> patch-tag, for one
12:34:35 <parcs> darcsden too
12:34:40 <Eduard_Munteanu> I see.
12:41:49 <aristid> it's no github tho :P
12:56:23 <rostayob> is there a way to have emacs haskell mode indent well with template haskell?
12:57:55 <td123> is there a function that takes to numbers and divides them, returning a tuple with the result and a remainder?
12:58:22 <mauke> :t divMod
12:58:23 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:58:34 <td123> mauke: ty
12:59:17 <aristid> :t quotRem
12:59:18 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:59:53 <merijn> > divMod 19 3
12:59:55 <lambdabot>   (6,1)
13:00:02 <merijn> > quotRem 19 3
13:00:04 <lambdabot>   (6,1)
13:00:16 <merijn> What's the difference? Negative rounding direction?
13:00:28 <Twey> Yes
13:00:29 <monochrom> yes
13:01:10 <aristid> YeS
13:01:47 <monochrom> > sequence ["Yy", "Es", "Ss"]
13:01:47 <lambdabot>   ["YES","YEs","YsS","Yss","yES","yEs","ysS","yss"]
13:01:54 <monochrom> > sequence ["Yy", "Ee", "Ss"]
13:01:55 <lambdabot>   ["YES","YEs","YeS","Yes","yES","yEs","yeS","yes"]
13:04:16 <c_wraith> specifically, quotRem uses the direction most hardware provides.  divMod is what mathematicians expect.  If both your args are going to be positive, quotRem is usually faster
13:06:02 <td123> also, how do I convert from a Word8 type to an Int?
13:06:19 <c_wraith> :t fromIntegral
13:06:20 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:06:34 <td123> k thx
13:06:53 <c_wraith> fromIntegral is the generic conversion function for most cases you'll care about.  Combined with floor, ceiling, and round
13:08:37 <td123> c_wraith: thanks (fromIntegral (1 :: Word8)) :: Int works
13:15:01 <akamaus> hi, is it possible to use hxt to parse non-unicode xhtml?
13:15:25 <akamaus> I get this: fatal error: encoding scheme not supported: "WINDOWS-1251"
13:16:04 <byorgey> using darcs trackdown for the first time, woo
13:16:34 <Heffalump> has it done what you want?
13:16:46 * Heffalump is not very happy with its ease of use
13:18:43 <beastaugh> byorgey: is that like git bisect?
13:18:51 <byorgey> beastaugh: yeah
13:19:12 <byorgey> Heffalump: I dunno, it seems to be doing something
13:19:16 <byorgey> still haven't found the bug yet
13:19:30 <nihtml> @pl with_tags li = li ++ map show [(1 + length li)..9]
13:19:30 <lambdabot> with_tags = ap (++) (map show . flip enumFromTo 9 . (1 +) . length)
13:20:07 <byorgey> it wasn't too hard to figure out how to use it, although I'm a little confused about what directories it's doing stuff in and whether it's actually making any changes to my repo or just doing it in some scratch space
13:20:10 <nihtml> @type ap
13:20:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:21:46 <byorgey> Heffalump: it's actually quite annoying that I can't stop it once it starts, short of closing the terminal
13:22:01 <byorgey> Heffalump: if I hit Ctrl-C it interprets that as the test failing and moves on to the next patch
13:22:05 <KirinDave> Whoah. Wait.
13:22:15 <KirinDave> Did lambabot just transform code?
13:22:30 <aristid> KirinDave: you mean @pl?
13:22:33 <KirinDave> Yeah
13:22:38 <KirinDave> What does @pl do?
13:22:41 <aristid> yeah it makes code point-free
13:22:48 <merijn> KirinDave: Remove "useless" name bindings
13:23:04 <aristid> it's pretty hilarious what comes out sometimes
13:23:05 <monochrom> akamaus: yes it is possible for a bunch of encodings like iso-5589-3. unfortunately windows-1251 is not one of them. the full list is at http://hackage.haskell.org/packages/archive/hxt-unicode/9.0.1/doc/html/Data-String-EncodingNames.html
13:23:15 <monochrom> s/5589/8859/
13:24:12 <merijn> KirinDave: So if you have a function which is mostly composing/combining other functions and you want to figure out if you can do it in a compacter way/eliminating the function arguments you ask @pl and you'll usually get incomprehensible code. But occasionally it'll be nicer and clearer code :p
13:24:52 <merijn> :t liftM
13:24:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:25:11 <akamaus> monochrom, well, cp1251 is ubiquitous in the Russian segment of Internet. I can't believe I'm the first one to run into this..
13:25:51 <monochrom> hxt was not made in russia or from russia with love! :)
13:26:54 <monochrom> in fact old ghc versions just assumed iso-8859-1 (couldn't even do utf8) because that was ubiquitous in the western imperalist bloc
13:28:14 <monochrom> clearly, GB18030 is the only politically correct standard for the whole world! :)
13:28:33 <merijn> UTF-8 or death!
13:31:20 <xplat> akamaus: is it easier to believe you're the first one to run into it and submit a GHC patch?
13:32:15 <monochrom> no no, not ghc problem, hxt problem
13:32:57 <monochrom> ghc's i/o lib actually does windows-1251 just fine. but hxt circumvents that
13:32:59 <akamaus> xplat, I filed several ghc bug reports and all turned out to be duplicates :)
13:33:08 <monochrom> (if you use hxt's own i/o lib)
13:33:18 <xplat> monochrom: oh?  well that sounds easier to patch too ...
13:33:20 <aristid> monochrom: xml's encoding support is broken
13:33:35 <nyingen_> monochrom: I rewrote my program to use 'withFile', but now I get 'filehandle is closed' errors...clearly I have much to learn about lazy I/O
13:33:38 <mzero> xml's? or hxt's?
13:33:42 <aristid> xml's.
13:33:48 <mzero> ! how?
13:33:49 <aristid> as in the language
13:34:09 <aristid> mzero: who the fuck dreamed up <?xml encoding="foo"?>?
13:34:12 <monochrom> nyingen_: don't use lazy i/o. use explicit hGetLine hGetChar etc.
13:34:17 <mzero> XML has a pretty rigorous definition  about how to handle encoding?
13:34:20 <mzero> what is wrong with that?
13:34:51 <aristid> mzero: how do you even know that you read <?xml without knowing the encoding?
13:35:03 <xplat> xml's encoding support makes infinitely more sense than HTML's
13:35:10 <mzero> it is quite well defined by the spec.... other than the oddness that therefore XML can only be represented in encodings that include ASCII as a subset... which isn't practically a problem
13:35:32 <aristid> utf-16 does not include ascii as a subset
13:35:51 <mzero> aristid - XML is only defined to be encoded in encodings for which ASCII is a subset --- the <?xml encoding="xxxx"?> is exactly the same in any legal encoding 
13:36:05 <aristid> mzero: no, it _is_ defined on utf-16
13:36:10 <mzero> ah true, but there is provision in XML for detecting UTF-16
13:36:29 <aristid> that's just a painful amount of complexity
13:36:34 <mzero> sure it is - you can tell from the first two bytes of an XML data set if it is UTF-16 and if so which flavor
13:36:45 <xplat> in practice there are only two double-byte encodings that are double-byte all the time and don't have ascii as a subset, and besides being self-marking usually, well, there are just two of them
13:36:52 <aristid> mzero: now what about utf-32?
13:37:00 <monochrom> well then, we should argue the semantics of the word "broken" instead
13:37:00 <mzero> well- I for one would have said "It is UTF-8. The end." but... 
13:37:20 <monochrom> it seems some people take "broken" to mean "works fine but complicated"
13:37:41 <mzero> XML isn't defined to support UTF-32
13:37:44 <monochrom> by that standard, 99% of math is broken, actually
13:38:22 <akamaus> my particular use case is trivial. I just have an xhtml page in cp1251, it's specified in meta tag
13:38:27 <aristid> monochrom: we _were_ talking about a problem with hxt. and many other libraries are even worse at supporting xml encodings. the xml package for example does not support encodings at all
13:38:45 <xplat> well, there's also the issue 'what if you have a self-marking encoding like UTF-16 and encoding= saysi something else'
13:38:53 <aristid> akamaus: then convert cp1251 to utf-8
13:39:02 <aristid> mzero: there is another problem with xml's encoding support
13:39:14 <xplat> akamaus: it's not legal to specify the xhtmls encoding only in a meta tag
13:39:21 <aristid> mzero: if you run iconv (or any encoding converter) on an xml file, you get a broken result
13:39:42 <xplat> that's only legal for html native syntax
13:39:45 <aristid> akamaus: make sure to remove the <?xml encoding=xxx?> stuff after converting
13:40:10 <mzero> ah - THAT problem .... well, many systems have this issue
13:40:18 <mzero> but yes, iconv is not a valid XML processor
13:40:26 <nyingen_> monochrom: I actually need hGetContents, since the file is XML and I'm applying a parser to it to return a small data structure 
13:40:36 <mzero> turns out iconv isn't a valid HTML processor either
13:40:47 <mzero> (and we don't EVEN want to get into HTML5....)
13:41:01 <akamaus> xplat, I guess so, but we're talking about quite a big site :) I have to adapt somehow
13:41:09 <nyingen_> monochrom: I actually have about 1500 small XML files that I want to apply some calculations over and build up a result
13:41:11 <aristid> mzero: i think it would be better if xml had no encoding support at all, other than saying "unless you have better information, assume that an xml file is utf-8".
13:41:31 <byorgey> Heffalump: hah! found the bug. =)
13:41:37 <xplat> akamaus: convert into utf-8 before you feed the data to the parser
13:41:37 <monochrom> nyingen_: within the lifetime of withFile, force the data structure using "seq" or "$!" cleverly
13:41:50 <aristid> mzero: well, it's entirely possible that HTML is worse than XML
13:42:14 * hackagebot floatshow 0.1 - Alternative faster String representations for Double and Float  http://hackage.haskell.org/package/floatshow-0.1 (DanielFischer)
13:42:15 <rostayob> @hoogle DiffTime -> Integer
13:42:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:42:16 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
13:42:16 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
13:42:34 <nyingen_> monochrom: ok, I'll try that
13:42:40 <mzero> it is also part of the XML spec that says if you have encoding information from the surrounding transport protocol, then you are to ignore the encoding= attribute
13:42:43 <xplat> aristid: i agree that would be better, every text file format trying to specify its own encoding in band is a losing battle as well as a layering violation
13:43:10 <xplat> as these things go, though, xml's is not especially broken
13:43:19 <aristid> xplat: maybe the layering violation is what offends me so deeply
13:43:23 <nyingen_> monochrom: aha, worked :)
13:43:26 <akamaus> xplat, looks like it is the meta tag inside the tree who triggers the error. Of course, I can replace it too. But it looks horrible
13:43:31 <mzero> so, an HTTP transport, for example, can transcode an XML body, thus making the encoding= attribute wrong, but that is still legal, as the HTTP transport will declare an overriding encoding
13:43:39 <nyingen_> monochrom: thanks for the tips
13:43:45 <monochrom> nice
13:44:07 <nyingen_> I guess I'm used to thinking of $! and co as efficiency tools, rather than being necessary to avoid certain I/O bugs
13:44:22 <aristid> nyingen_: do you use lazy I/O?
13:44:26 <rostayob> @hoogle Floating a => Int -> a
13:44:26 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:44:27 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:44:27 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
13:44:41 <rostayob> :t fromInteger . toInteger
13:44:42 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
13:44:53 <mzero> now, HTML5's situation of which encoding information takes precedence is much more complicated (and IMHO *is* broken) -- but XML, while perhaps not pure, is quite workable
13:45:00 <nyingen_> aristid: I was using ByteString.hGetContents since the file contains a small XML document
13:45:31 <aristid> nyingen_: i thought ByteString.hGetContents is strict
13:45:50 <xplat> for HTML5 it is legal for two decoders to choose different encodings
13:45:52 <monochrom> well there are altogether 4 ByteString.hGetContents's
13:46:03 <Saizan> nyingen_: you could use Data.ByteString.hGetContents instead of the .Lazy one, which doesn't have this problem
13:46:14 <Saizan> 4? i'm pretty sure there are only 2
13:46:25 <xplat> depending on a buffer size parameter
13:46:31 <Heffalump> byorgey: cool
13:46:42 <aristid> xplat: due to the <meta encoding> stuff?
13:47:13 <aristid> xplat: whoever dreamed that up should be ... i prefer not to say
13:47:22 <xplat> yes, you're allowed to pick a number for how far into the file to look for it
13:47:41 <nyingen_> Saizan: I thought about that, but the XML library I'm using seems to use lazy bytestrings internally
13:48:08 <aristid> nyingen_: you can easily convert strict bytestrings to lazy bytestrings.
13:48:13 <Saizan> nyingen_: you can convert with .Lazy.fromChunks . (:[])
13:48:37 <Saizan> nyingen_: the only downside is that you'll have the whole file in memory from the start, but if they are small..
13:48:40 <aristid> Saizan: there should be a dedicated function for that
13:49:15 <aristid> well if he wants to work with larger files, i'd recommend going iteratee :)
13:49:31 <xplat> well, the original intent of <meta encoding=> was that the http server would use it to choose a MIME encoding parameter and either it would be stripped out by the server or ignored by the client
13:50:09 <nyingen_> Saizan: I see, that's good to know
13:50:30 <aristid> xplat: but that didn't happen that way?
13:50:33 <xplat> but in practice you would have servers that would blit the disk buffers to the network cards and browsers that would try to make up for the missing functionality
13:53:04 <xplat> and it became the huge mess we know today
13:53:43 <aristid> xplat: the dominance of utf-8 is making things improve somewhat
13:54:17 <kuznero> Hi All!
13:54:57 <rien> folks, I'm reading Bird's Intro to functional programming book, and he says mapm :: Monad m => (a -> b) -> (m a -> mb), but defines mapm f p = ... - doesn't he mean mapm :: Monad m => (a -> b) -> m a -> m b, like fmap but for monads? I never know hwen I can get rid of parentheses in type sigs
13:55:29 <xplat> aristid: yes, once again humanity is saved from a problem it is too stupid to solve by it becoming moot
13:55:44 <monochrom> eh? akamaus goes to haskell-cafe for help :)
13:55:59 * monochrom goes to haskell-cafe to continue the pointless xml wars
13:56:00 <akamaus> yeah )
13:56:34 * monochrom posts, "xml does it wrong, html does it wrong, the whole world is wrong, etc"
13:56:36 <aristid> rien: it's easy. -> brackets to the right. so a -> b -> c is really a -> (b -> c)
13:56:50 <aristid> rien: so if you want (a -> b) -> c, you cannot remove the parens
13:57:11 <hpc> rien: to answer the question, you were correct in how you removed the parens
13:57:16 <akamaus> monochrom, I believe, but.. it's the real world in the end. Who says it must be right? ;)
13:57:20 <hpc> and correct in the connection to fmap
13:57:48 <rien> monochrom: you should watch some Alan Kay lectures, he has stuff to say about those things :)
13:57:50 <aristid> monochrom: you know, i thought you could sympathise with "the world is wrong" feelings given your take on the dominance of text files in programming :P
13:58:07 <monochrom> oh, I completely don't care about the xml war we just saw here. I'm just joking
13:58:11 <rien> aristid, hpc: that makes sense, thanks!
13:58:52 <monochrom> I don't sympathize with "debates"
13:59:03 <monochrom> @quote monochrom debates
13:59:03 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
13:59:38 <aristid> monochrom: it's not a war. it's just a rant, and a monochrom who goes meta by talking about the meaning of the word "broken".
14:00:03 <aristid> rants may be pointless if viewed as a debate, but that's because they aren't.
14:01:45 <monochrom> a debate is the composition of 1 or more rants
14:02:25 <aristid> that would imply that all debates are pointless :D
14:02:44 <aristid> @pl debate
14:02:44 <lambdabot> debate
14:02:45 <akamaus> monochrom, I guess the difference is in the goal. A debate must be constructive, imho
14:03:12 <merijn> Eh, no. That would be a discussion. Debates are contests with winners
14:03:19 <merijn> The point is to win, not to be right
14:03:30 <akamaus> and rants at least should be fun
14:03:37 <Philippa> that's not the sole definition, merijn
14:03:57 <Saizan> let's have a meta-debate!
14:04:01 <aristid> somehow this reminds me of concurrency vs parallelism :P
14:04:07 <aristid> Saizan: we already do
14:04:08 <monochrom> rebate > debate
14:04:14 <Philippa> Saizan: in fact, let's debate the value of all meta-debates!
14:04:29 <aristid> or let's revert to silliness
14:04:55 <merijn> aristid: Revert? I think #haskell never leaves the silly state
14:05:04 <merijn> It's because we don't do mutable state, I guess?
14:05:19 <aristid> aren't we in ST?
14:05:25 <monochrom> STM
14:05:30 <merijn> Maybe you are, but I'm in IO :>
14:05:41 <akamaus> I feel the same )
14:05:55 <aristid> merijn: i think i just admitted to being an irc bot
14:07:24 <akamaus> well, time to suspend the computations and go to sleep
14:07:32 <merijn> Is there an algebraic construct like monoid but instead of "a `mappend` mzero = a" it is "a `mappend` mzero = mzero" (pretend I changed the name to something less wrong)
14:08:14 <akamaus> good bye
14:08:21 <RichardO> @pl f a = g b (c, d, a)
14:08:21 <lambdabot> f = g b . (,,) c d
14:08:25 <xplat> that's a semigroup with an absorptive element
14:08:41 <c_wraith> the structure of multiplication, but with the special element being zero instead of one.
14:08:45 <merijn> xplat: Somehow not as concise as I was hoping for :p
14:09:28 <merijn> I was thinking "procrastination monoid" (replacing monoid with the proper term), doesn't matter what you add into it, no results come out :p
14:09:57 <Philippa> monoid's sufficient
14:10:30 <Philippa> you just want the monoid such that id (and everything else) = _|_
14:10:37 <merijn> "mzero `mappend` work = work", instead of "mzero `mappend` work = mzero" :p
14:11:08 <Philippa> *the* monoid over {_|_}, basically
14:19:35 * hackagebot improve 0.3.4 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.3.4 (TomHawkins)
14:20:39 <bos> does anyone know of a "run cabal on this project" command or the like for emacs?
14:22:26 <lispy> bos: there is a flymake mode that supports cabal, IIRC
14:22:40 <bos> lispy: hmm
14:22:41 <lispy> bos: are you an emacs user or is this for someone else?
14:22:50 <bos> i use emacs, but not flymake
14:22:53 <osfameron> > groupBy (/=) [1,1,1,4,4,3,2,2]
14:22:54 <lambdabot>   [[1],[1],[1,4,4,3,2,2]]
14:23:14 <osfameron> I'm surprised by that
14:23:25 <lispy> bos: I prefer to interact with my system via a terminal (outside of emacs), so I haven't used such things but I'm pretty confident they exist for Haskell.
14:23:34 <lispy> osfameron: it only does adjacent elements
14:23:37 <dafis> osfameron: groupBy tests elements against the first of the group
14:23:46 <lispy> osfameron: it's actually documented that way in the standard report
14:24:00 <lispy> osfameron: and yes, it can be shocking the first time you hit that
14:24:05 <osfameron> why are [4,4] grouped together, and [2,2] ?
14:24:06 <dafis> osfameron: groupBy requires an equivalence relation
14:24:09 <osfameron> they're adjacent, no?
14:24:24 <dafis> osfameron: they're tested against 1
14:24:34 <lispy> osfameron: oh, well you're relation is things not equal to themselves
14:24:41 <lispy> well, not equal to adjacent things
14:24:56 <lispy> ?src groupBy
14:24:56 <lambdabot> groupBy _  []       =  []
14:24:56 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:24:56 <lambdabot>     where (ys,zs) = span (eq x) xs
14:25:03 <osfameron> ah
14:25:16 <osfameron> ok
14:26:02 <osfameron> and http://coder.bsimmons.name/blog/2010/02/an-alternative-definition-for-datalistgroupby/ gives an alternate definition which might be ore what I want
14:29:51 <merijn> Question for the academics here, is it safe to assume PL researchers/profs are aware of/familiar with LtU?
14:30:35 <djahandarie> Depends what sort of PL stuff they are into
14:30:51 <djahandarie> Anything functional and I'd imagine that they would have heard of it at least or something
14:31:12 <djahandarie> I can say for sure that non-functional people would not have heard of it though
14:31:25 <merijn> Well, Habit (the strict, systems programming dialect of Haskell), in this case
14:31:46 <djahandarie> Oh yeah, no doubt
14:32:01 <accel> merijn: link to cool projects done in Habit?
14:32:16 <merijn> accel: http://hasp.cs.pdx.edu/
14:32:22 <lispy> accel: the language itself is still being developed
14:32:32 <merijn> It is work in progress, the preliminary language report got posted to LtU in february
14:33:03 <merijn> accel: You might be interested in House (bare metal Haskell runtime, for writing OS code in Haskell), think it is by a lot of the same people
14:33:21 <lispy> or halvm.org
14:33:30 <accel> hmm
14:33:32 <merijn> Yeah, Galois is doing nifty stuff too
14:33:35 <accel> call by value = nuking laziness?
14:33:46 <merijn> accel: It is non-lazy, yes
14:33:48 <lispy> accel: call by value = C
14:34:01 <merijn> accel: But that is not the same as call by value
14:34:05 <accel> http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf <-- I hate this documents like this
14:34:15 <accel> it should start with a section that is "how we differe from haskell"
14:34:20 <accel> rather than describing the language itself
14:34:32 <djahandarie> accel, there is a galois presentation on it
14:34:34 <merijn> Language reports are all about defining the language :p
14:34:37 <djahandarie> Which attacks it like that
14:34:41 <accel> djahandarie: link?
14:34:50 <thoughtpolice> accel: www.vimeo.com/galois
14:34:51 <thoughtpolice> iirc
14:34:54 <djahandarie> @google galois good habits
14:34:55 <lambdabot> http://corp.galois.com/blog/2010/5/12/tech-talk-developing-good-habits-for-bare-metal-programming.html
14:34:55 <lambdabot> Title: Galois
14:35:15 <thoughtpolice> it's one of the older galois videos, one of the first.
14:35:19 <accel> lambdabot++
14:35:26 <accel> djahandarie++
14:35:37 <aristid> google++
14:35:42 <aristid> to be fair and complete
14:35:42 <djahandarie> internet++
14:35:45 <merijn> @karma google
14:35:45 <lambdabot> google has a karma of -1
14:35:48 <aristid> galois++
14:35:49 <djahandarie> Haha
14:35:51 <merijn> @karma internet
14:35:52 <lambdabot> internet has a karma of 3
14:36:12 <djahandarie> This must all come from #perl, no one uses karma in here that often
14:36:17 <djahandarie> (It is mutation after all...)
14:36:24 <aristid> is the karma shared between channels?
14:36:32 <djahandarie> @karma aristid
14:36:32 <lambdabot> aristid has a karma of 3
14:36:33 <merijn> aristid: Yes
14:36:39 <accel> ARGH
14:36:41 <djahandarie> @karma aristid
14:36:41 <aristid> djahandarie: i'm not in #perl
14:36:41 <lambdabot> aristid has a karma of 2
14:36:44 <accel> why the fuck do people puts slides 2 to a page
14:36:47 <merijn> I just use it in privmsg to find out how awesome people think I am :p
14:36:50 <accel> so I can't view them in "page mode" in my pdf viewser
14:36:57 <aristid> @karma merijn
14:36:57 <lambdabot> merijn has a karma of 8
14:37:07 <aristid> merijn-- for checking karma in privmsg :P
14:37:12 <merijn> :(
14:37:34 <aristid> :)
14:37:45 <djahandarie> (:
14:38:07 <dafis> ):
14:38:22 <accel> is ahbit GC-ed , or manual memory management?
14:38:37 <merijn> GC
14:38:53 <accel> so by system then mean not-kernel 
14:39:02 <merijn> Well, there might be a way to do manual memory management, I guess
14:39:27 <accel> habit reminds me of the exact type of shit
14:39:28 <accel> academics do
14:39:34 <accel> I'll believe Haskell is ready for systems program
14:39:38 <accel> when Linus uses it for the linux kernel
14:39:54 <djahandarie> They made Habit specifically because Haskell doesn't work well for systems programming.
14:40:01 <djahandarie> I'm not sure what that classifies under "shit" in your book.
14:40:03 <djahandarie> why*
14:40:12 <merijn> They also have a paper on "high-level low-level programming" which discusses how to do things like manual memory management from within a high level language
14:40:57 <merijn> accel: Sure, you can call it "the type of shit academics do", but if we had to wait for people like Linus to do innovation we'd be nowhere
14:42:00 <merijn> The 'state-of-the-art' additions to fancy languages like Python/Ruby/Go/whatever is popular now, is basically just googling for 20 year old research papers on GC/virtual machines/interpreters and stealing that
14:42:15 <djahandarie> lol
14:42:47 <merijn> djahandarie: Last time we had this discussion here I dared the other guy to name one innovations which was less then 10 years old, he didn't succeed :p
14:42:57 <merijn> s/innovations/innovation
14:43:14 <lispy> just because someone is ignorant doesn't prove anything
14:43:27 <djahandarie> (Except his ignorance)
14:43:35 <lispy> Now if there really are none (which I have no idea, because I don't care about that sort of thing) then that would be different
14:44:15 <merijn> lispy: Just because it is hyperbole doesn't mean a point is entirely without merit :)
14:44:20 <lispy> accel: So, who invented C?
14:44:58 <merijn> There are probably some new inventions, but a lot are very old things people decried as useless academic nonsense years ago. You can never tell in advance :>
14:45:11 <lispy> accel: was it possibly invented by people at a research lab?  Perhaps, Bell labs?
14:45:23 <lispy> accel:  does that make C the kind of shit that academics do?
14:45:38 <xplat> moses brought C down from mount sinai on a stone tablet, but then he got mad and broke it, so we had to wait for 1974 or some shit
14:45:39 <shachaf> Calling Bell Labs academia is stretching it somewhat, isn't it?
14:45:45 <merijn> lispy: Pfft, as if Bell Labs ever produced anything worthwhile :>
14:46:38 <xplat> bell labs produced excellent new ways to light a christmas tree
14:46:39 <accel> lispy: C was created to write Unix
14:46:53 <accel> there are people who build frameworks/langauges out of building shit that nas never been built
14:47:14 <accel> then there are shitty people that build shitty languages/frameworks for their shitty imaginations, thinking that their shit will be the shit, when it really is just shit
14:47:25 <companion_cube> interesting
14:47:38 * djahandarie notes that overusage of 'shit' may perhaps be dulling accel's point slightly
14:47:39 <accel> languages/frameworks evolved out of big projects
14:47:43 <accel> I approve of
14:47:45 <companion_cube> how do i vote "-" to your comment ?
14:47:46 <xplat> and then there are shitty shits who shit shit on shit, and shit shit shit shits.
14:47:49 <merijn> accel: And this only applies to academics?
14:48:06 <accel> merijn: no, but academics tend to be able to getaway with it
14:48:09 <companion_cube> spam, spam spam spam spam, bacon, sausage, eggs, and spam
14:48:18 <accel> merijn: and then often pat each other on the back for their "novel ideas"
14:48:21 <companion_cube> spam, spam, spam spam and spam, with spam and spam
14:48:23 <merijn> accel: Linus has been getting away with it quite well too
14:48:40 <accel> merijn: linus getting away with what? his work is all practical
14:49:02 <xplat> accel: some of it doesn't really take off
14:49:26 <merijn> Just because it is practical and popular doesn't mean its not shit
14:49:31 * lispy thinks accel is trolling us again
14:49:37 <merijn> The linux kernel's code quality is god awful.
14:49:42 * lispy leaves the discussion
14:49:44 <accel> no no; I'm a student
14:49:56 <accel> and I think most of the stuff that comes out of academia is crap
14:50:06 <accel> open soruce software atleast tends to be used
14:50:14 <accel> whereas research prototypes .... are meant to crank out papers and vanish
14:50:20 <nazgjunk> A large portion of it barely is :P
14:50:30 <merijn> Well, feel free to start yet another web startup or crummy open source project instead :)
14:50:35 <lispy> accel: http://russelldavies.typepad.com/planning/2007/02/quantity_equals.html
14:50:45 <merijn> I'll bet 99% of all open source has maybe 5 users
14:51:00 <companion_cube> accel, in some domains this is really false, e.g. databases or solvers
14:51:13 <xplat> accel: so you're another kid who just discovered another instance of sturgeon's law, got all indignant, but still failed to generalize
14:52:03 <merijn> accel: Speaking of which, postgres happens to be an academic project. Now compare with MySQL...
14:52:10 <znutar> I want to make a project that generates open source projects and puts them up on github or something, and finds out if a random walk through the space of compilable C programs gets downloaded much
14:52:36 <xplat> accel: an occurrence that probably happened a thousand times in various parts of the world while i was typing that sentence
14:52:40 <companion_cube> znutar, or genetic algorithms for social network websites :>
14:53:23 <merijn> companion_cube: Oh! Web app that uses facebook likes as a fitness function for evolutionary algorithms :>
14:53:42 <tafryn> Why does the memory usage of the following example seem to increase without bound? http://hpaste.org/45821/vtyui_date_display
14:53:50 <lispy> merijn: isn't that how lolcats got started :)
14:53:58 <xplat> merijn: and cranks out xss exploits
14:54:12 <companion_cube> farmGeneticALgorithmVille
14:54:33 <merijn> lispy: I prefer lambdacats :>
14:54:34 <companion_cube> I CAN HAZ MUTASHION ?
14:54:57 <lispy> merijn: oh yeah, but is that still around?  I liked the cat that was too dumb to haskell
14:55:14 <merijn> xplat: Just use PHP and you get the XSS and SQL injections for free :>
14:55:19 <merijn> @where lambdacats
14:55:19 <lambdabot> http://tinyurl.com/lambdacats
14:55:33 <rien> no, you can't. ;)
14:55:53 <lispy> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526257_bBDEY-A-LB  <-- my favorite
14:55:53 <companion_cube> omg, i just discovered that some people can do lolcats with category theory oO
14:56:25 <xplat> merijn: i meant that the easiest way to get facebook likes with simple code is to forcibly extract likes via xss
14:56:26 <merijn> companion_cube: Of course :)
14:57:36 <xplat> ceiling hat watches you evaluate
14:58:09 <companion_cube> flip concatMap oO
14:59:59 <aristid> lispy: it included philosophy, even
15:02:39 <xplat> 84MB of trace
15:02:50 <xplat> no sign of slowing down
15:03:37 * xplat starts it over without the tee to xterm, that will probably go way faster
15:07:30 <xplat> er, wrong channel T_T
15:17:16 <lispy> aristid: what included philosophy?
15:17:45 <aristid> lispy: http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526257_bBDEY-A-LB
15:17:50 <aristid> lispy: Kant is a philosopher... :P
15:18:03 <lispy> aaah
15:18:07 <lispy> yes :)
15:20:54 <osfameron> gah, that was a lot of work: https://github.com/osfameron/Ach/blob/master/ach.hs
15:21:29 <osfameron> I'm sure that recursive definition of grepc (with the before and after functions) isn't very good
15:21:46 * osfameron wonders if it should be done with a fold or whatnot instead
15:24:27 * dafis 's favourite lambdacat was Simon sez "Iz fixed in teh HEAD"
15:27:29 <rostayob> how do I convert something that's an instance of Fractional to Float?
15:27:50 <rostayob> specifically, how do I convert NominalDiffTime to float?
15:28:01 <lispy> rostayob: does realToFrac work?
15:28:17 <lispy> rostayob: realToFrac can be really slow in some cases
15:28:45 <hpc> who cares about speed, we are academics! :P
15:28:49 <rostayob> lispy: yes, it works, thanks. is that the only method?
15:28:49 <dafis> lispy: it's probably better in 7.2
15:29:05 <lispy> rostayob: it's the most general way, but maybe there are other ways I'm not aware of
15:29:19 <lispy> dafis: yeah, I saw the thread on the libraries@ list
15:29:24 <lispy> dafis: good times
15:29:50 <lispy> ?hoogle (Fractional f) => f -> Float
15:29:50 <lambdabot> Prelude recip :: Fractional a => a -> a
15:29:50 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
15:29:50 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
15:29:50 <mzero> fromRational . toRational
15:30:04 <mzero> :t fromRational . toRational
15:30:04 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
15:30:09 <lispy> mzero: that's the default for realToFrac actually
15:30:11 <lispy> ?src realToFrac
15:30:12 <lambdabot> realToFrac = fromRational . toRational
15:30:17 <mzero> ah - never mind then
15:30:28 <mzero> that is, actually, pretty gnarly!
15:30:38 <lispy> mzero: it's painfully slow when translating between types of Floats like GLfloat and Float
15:30:59 <lispy> But in the case of GLfloat and Float it should be a no-op because GLfloat is a newtype :(
15:31:02 <dafis> lispy: I thought you added rules for that?
15:31:12 <lispy> dafis: Right, not released yet
15:31:20 <dafis> 'kay
15:32:02 <lispy> I can't remember the multipler but in some example code I had it was either 10x or 100x
15:32:05 <lispy> Huge difference
15:32:50 * hackagebot monadcryptorandom 0.3.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.3.1 (ThomasDuBuisson)
15:33:11 <dafis> lispy: 100x wouldn't be surprising
15:34:12 <hpc> lispy: it's a newtype for GLInt, but i think GLFloat is just a type
15:34:16 <hpc> @src GLFloat
15:34:16 <lambdabot> Source not found. My mind is going. I can feel it.
15:34:18 <hpc> er
15:34:23 <hpc> @hoogle GLFloat
15:34:23 <lambdabot> No results found
15:34:33 <lispy> lowcase F
15:34:41 <lispy> ?hoogle GLfloat
15:34:41 <lambdabot> No results found
15:35:42 <dafis> hpc: it was a type in OpenGL-2.1, it became a newtype I think in 2.2, maybe 2.3
15:35:51 <hpc> ghci> :info GLfloat
15:35:51 <hpc> type GLfloat = Float -- Defined in Graphics.Rendering.OpenGL.GL.BasicTypes
15:35:54 <hpc> oh
15:36:37 <dafis> hpc which version have you?
15:37:02 <hpc> uh
15:37:16 <hpc> latest in the ubuntu repos
15:37:35 <lispy> oh, that's the old way
15:37:41 <lispy> It's not a type anymore for sure
15:38:12 <hpc> hmm, hackage says the most recent version has a debian build
15:38:18 <hpc> which would imply it is also on ubuntu
16:16:00 <razieliyo> how's that
16:16:28 <djahandarie> razieliyo, hmm?
16:17:04 <razieliyo> djahandarie, just greeting
16:17:12 <djahandarie> Oh. Hello then. :)
16:17:20 <djahandarie> "That" is doing very well. ;)
16:17:22 <razieliyo> hahaha
16:19:58 <dafis> anybody knows whether hlint can handle unboxed tuples and magic hashes?
16:20:41 <djahandarie> I don't think it can tell you anything about them, but it shouldn't complain afaik
16:21:24 <dafis> djahandarie: I got some strange output from hlint, and that's the only explanation I can think of atm
16:28:07 <tswett> Math is deep and inscrutable until you learn it, at which point it becomes shallow and obvious.
16:28:46 <djahandarie> I'm not sure I'd call it shallow and obvious. :p
16:29:01 <djahandarie> Unless by 'learn' you mean 'master', at which point that applies to anything.
16:29:11 <luite> hmm, either you haven't learned enough math then, or you are much smarter than me :p
16:29:28 <shachaf> djahandarie: It's just tautologies.
16:29:51 <luite> but finding the right tautologies is difficult :p
16:31:27 <tswett> Okay, "slightly obvious".  :P
16:31:43 <shachaf> "trivial", in the Feynman sense?
16:32:09 <tswett> shachaf: yeah!
16:32:21 <luite> what's triviaial in the feynman sense?
16:32:24 <luite> trivial
16:32:29 <tswett> It's now slightly obvious to me why the golden ratio to a large integer power is almost an integer.
16:32:38 <tswett> luite: "proven".
16:32:44 <tswett> All theorems are trivial; nothing else is.
16:33:12 <shachaf> Lemmas are trivial too!
16:33:32 <mauke> I'm not a lemma; I'm a free theorem!
16:33:51 <shachaf> luite: http://vamsionnet.tripod.com/syjmf/adbt.htm
16:33:55 * dafis runs to the hills
16:33:59 <acowley> I was Admitted.
16:34:01 <jfmiller28> tswett: when you find tensor calculus "shallow and obvious" let me know.  I want to invent interstellar travel with you.
16:34:54 <JuanDaugherty> well it is sort of a standard undergrad engineering course 
16:35:06 <luite> shachaf: ah I vaguely remember reading that page :)
16:35:26 <JuanDaugherty> (or a part thereof, at least in my time)
16:35:51 <dons> ?pl \f g x -> (f x) && (g x) 
16:35:51 <lambdabot> liftM2 (&&)
16:36:16 <djahandarie> Jeez dons, haven't even memorized that one yet? ;-)
16:36:27 <luite> I bet he as just testing lambdabot ;p
16:36:30 <luite> was
16:36:33 <djahandarie> Haha
16:37:06 <jfmiller28> I bet he(dons) is trying to answer my SO question before anyone else
16:37:10 <dons> hehe
16:37:31 <djahandarie> Haha
16:38:32 <djahandarie> I actually avoid using these sort of complex (a ->) Monad instance golfs if I can
16:39:14 <shachaf> djahandarie: liftM2 is pretty standard, though.
16:39:31 <djahandarie> Sure. But when it's in the middle of some other code without a type signature, it can be confusing as hell
16:39:35 <shachaf> Does GHC have idiom bracket support yet?
16:40:18 <ddarius> @google Eugenia Cheng mathematical morality
16:40:20 <lambdabot> http://www.cheng.staff.shef.ac.uk/morality/morality.pdf
16:40:20 <lambdabot> Title: Mathematics, morally
16:41:22 <ddarius> Wrong one.
16:41:23 <tswett> jfmiller28: tensors are just vectors and vector calculus is just ordinary calculus performed componentwise, so it's trivial.  :P
16:41:34 <tswett> (I'm sure I'm revealing my ignorance there.)
16:41:51 <ddarius> @google Eugenia Cheng Is mathematics easy
16:41:52 <lambdabot> http://cheng.staff.shef.ac.uk/illogic/illogic-web.pdf
16:41:52 <lambdabot> Title: Logic vs illogic: why mathematics is easy and life is hard
16:42:16 <ddarius> tswett: Tensors are multilinear transformations.
16:42:45 <dafis> Tensors are sections in a tensor bundle
16:42:51 * ddarius finds tensors rather unstructured.
16:43:04 <acowley> djahandarie: is it okay if we use liftA2 instead?
16:44:19 <djahandarie> acowley, it'd be better in fact ;)
16:44:38 <c_wraith> @pl \f x y -> f (g x y) (h x y)
16:44:38 <lambdabot> (`ap` h) . (ap .) . (. g) . (.)
16:44:42 <djahandarie> I still don't want to find that in the middle of some code though
16:44:54 <acowley> well
16:45:02 <acowley> I think we should try to get better at it
16:45:26 <acowley> They're all just kind of function application
16:45:33 <c_wraith> I used liftA2 (<$>) in code once. :)
16:45:34 <jfmiller28> tswett: You will enjoy Misner, Thorne and Wheeler's "Gravitation" 
16:45:51 <tswett> ddarius: the most general definition is that tensors are elements of tensor products, isn't it?  But yeah.
16:46:06 <BMeph> jfmiller28: Not me; the ending is obvious... ;þ
16:46:50 <jfmiller28> BMeph: but the plot will blow your mind.
16:47:03 <tswett> jfmiller28: does that have any geometry in it?  I haven't taken a geometry class in at least six years.  :P
16:47:25 <ddarius> That's actually less general as the purpose of a tensor product is to allow a multilinear function to be represented as a linear function (from the tensor product.)
16:47:26 <jfmiller28> tswett: :)
16:47:50 <ddarius> I.e. Bilin(X,Y;Z) ~ Lin(X⊗Y;Z)
16:47:59 <tswett> A multilinear map R^3 -> R^3 -> R has nine coefficients, right?
16:48:51 <robnik> > show 0.001
16:48:52 <lambdabot>   "1.0e-3"
16:49:03 <robnik> Is there a way to print that as "0.001" ?
16:49:13 <robnik> Or control when the "e" is used?
16:50:11 <Twey> :t showFFloat -- robnik
16:50:12 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
16:50:34 <Twey> > showFFloat (Just 4) 0.001 ""
16:50:35 <lambdabot>   "0.0010"
16:50:38 <Twey> > showFFloat (Just 3) 0.001 ""
16:50:39 <lambdabot>   "0.001"
16:50:56 <djahandarie> > showFFloat Nothing 0.001 ""
16:50:57 <lambdabot>   "0.001"
16:51:18 <dafis> > shoeFFloat Nothing (1/pi) ""
16:51:19 <lambdabot>   Not in scope: `shoeFFloat'
16:51:23 <Twey> Heh
16:51:24 <dafis> > showFFloat Nothing (1/pi) ""
16:51:25 <lambdabot>   "0.3183098861837907"
16:51:43 <dafis> > showEFloat Nothing (1/pi) ""
16:51:44 <lambdabot>   "3.183098861837907e-1"
16:52:41 <robnik> Thanks.
16:53:46 <dafis> > [0.1, 0.2 .. 2]
16:53:47 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600000...
16:54:00 <tswett> > length [0.1, 0.2 .. 2]
16:54:01 <lambdabot>   20
16:54:04 <Twey> > map showFFloat [0.1, 0.2 .. 2]
16:54:05 <dafis> > [0.1, 0.3 .. 2]
16:54:05 <lambdabot>   No instance for (GHC.Real.Fractional
16:54:05 <lambdabot>                     (Data.Maybe.Maybe ...
16:54:06 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999,1.2999999999999998,1...
16:54:09 <tswett> At least it has the right length.
16:54:10 <Twey> Er
16:54:15 <Twey> > map (showFFloat Nothing) [0.1, 0.2 .. 2]
16:54:15 <lambdabot>   Overlapping instances for GHC.Show.Show
16:54:15 <lambdabot>                              (GHC.B...
16:54:24 <Twey> > map (flip (showFFloat Nothing) "") [0.1, 0.2 .. 2]
16:54:26 <lambdabot>   ["0.1","0.2","0.30000000000000004","0.4000000000000001","0.5000000000000001...
16:54:30 <Twey> Hrm
16:54:45 <tswett> > showFFloat (Just 2) 0.001 ""
16:54:45 <Twey> > map (flip (showFFloat $ Just 3) "") [0.1, 0.2 .. 2]
16:54:46 <lambdabot>   "0.00"
16:54:47 <lambdabot>   ["0.100","0.200","0.300","0.400","0.500","0.600","0.700","0.800","0.900","1...
16:55:17 <mauke> preflex: calc '2 0.1
16:55:17 <preflex>  0.00011001100110011001100110011001100110011001100110011
16:55:46 * BMeph declares Twey the Winner in a (decimal-point-started) avalanche! ;þ
16:56:07 <Twey> Heh
16:56:33 <dafis> > 0.1+0.1 == 0.2
16:56:33 <mauke> preflex: calc '9 pi
16:56:33 <preflex>  3.124188124074427
16:56:34 <lambdabot>   True
16:56:45 <dons> > 1.1 + 2.2 == 3.3
16:56:45 <lambdabot>   False
16:56:50 <dafis> > 0.1+0.1 == (0.2 :: Float)
16:56:51 <lambdabot>   True
16:57:00 <mauke> > 1.1 + 2.2 == (3.3 :: Rational)
16:57:00 <lambdabot>   True
16:58:30 <dafis> preflex: calc '3 pi
16:58:31 <preflex>  10.010211012222010211002111110221
16:58:47 <shachaf> preflex: calc '1 pi
16:58:47 <preflex>  Invalid number base
16:59:02 <dafis> preflex: calc '2 pi
16:59:03 <preflex>  11.001001000011111101101010100010001000010110100011
16:59:17 <shachaf> preflex: calc '12 2*pi
16:59:18 <preflex>  6.349416967b635
16:59:28 <dafis> preflex: calc '2 (exp 1)
16:59:28 <preflex>  10.101101111110000101010001011000101000101011101101
16:59:44 <dafis> preflex: calc '3 (exp 1)
16:59:45 <preflex>  2.201101121221102011012222102011
16:59:52 <luite>  /query lambdabot 
16:59:53 <dafis> preflex: calc '4 (exp 1)
16:59:54 <preflex>  2.231332011101120220223231
16:59:54 <luite> oops
17:00:42 * shachaf will take luite's statement as a subtle hint.
17:00:51 <luite> :)
17:01:02 * BMeph wonders if shachaf will be the only one...
17:01:24 <luite> let us know if you find patterns in the digits of pi or e in some base :p
17:01:33 <mauke> I'd prefer #haskell-blah
17:01:36 * shachaf already has a /query window open to lambdabot. Window 3.
17:01:43 <ddarius> preflex: calc 'pi pi
17:01:43 <preflex>  Lexical error
17:01:53 <tswett> pi is exactly 10 in base pi.
17:02:00 <mauke> no, 1
17:02:04 <mauke> no, wait
17:02:05 <tswett> No, 10.
17:02:11 <mauke> I admit defeat.
17:02:14 <tswett> But that's a silly base.  Base e is much less silly.
17:03:14 <Twey> Why?
17:03:58 <tswett> You see e^n more often than pi^n, don't you?
17:04:07 <Twey> Touché
17:05:21 <jfmiller28> In base e trig function would be rational for all rational inputs would they not?
17:06:41 <tswett> I wonder what it really means for a number to be rational in base e.  I mean, it would have a repeating decimal, but what does that entail?
17:07:24 <tswett> Anyway, I see no obvious reason for that to be the case, but I wouldn't be surprised, either.  I don't know much of complex trigonometry.
17:07:28 <Twey> That it's a multiple of a power of e?
17:07:53 <tswett> Twey: that's for a terminating decimal, isn't it?
17:08:03 <tswett> 1.01010101... in base e is not a power of e.
17:08:09 <Twey> I presumed that's what jfmiller28 meant
17:08:22 <tswett> Oh.
17:08:23 <Twey> ‘Rational in base n’ is not a valid concept for the value of ‘rational’ I know.
17:08:50 <tswett> Well, being a rational number is the same as having a repeating expansion in any "normal" base.
17:09:19 <tswett> So I assume "rational" here means "having a repeating expansion".
17:09:30 <Twey> Oh, I see.
17:14:24 <xplat> tswett: when your base is not rational a repeating expansion is not enough to ensure rationality
17:14:56 <tswett> xplat: right.  Using the word "rational" to mean "having a repeating expansion" changes the meaning of it.
17:15:28 <Rotaerk> ddarius, this article on morality in mathematics is good, imo
17:15:33 <xplat> i think for algebraic bases it probably ensures the number is in the field extension of Q generated by your base
17:15:35 <Rotaerk> even if it was the "wrong one"
17:15:52 <tswett> xplat: do rational numbers have repeating expansions in irrational bases?
17:15:54 <Rotaerk> and the moral of it is more generic than just math, too
17:16:00 <xplat> i'm not sure it has any real significance in transcendental bases
17:16:23 <tswett> Oh, right, you said algebraic.
17:17:06 <BrianHV> at the risk of asking a FAQ, anyone know what's up with docs.yesodweb.com?
17:17:58 <xplat> Rotaerk: i'm not too tempted to read that since i wasn't too impressed by the discussion of morality in the other article
17:18:32 <Rotaerk> I think a better word is "intuition"
17:18:37 <Rotaerk> for what she's trying to convey
17:18:56 <Rotaerk> the intuition of what should be correct, regardless of whether you can rigorously prove it
17:19:21 <shachaf> Raymond Smullyan has fun discussions of "morality".
17:20:26 <Rotaerk> it's kind of how a book that is meant to teach need not *prove* what it is saying; it just needs to give you the information that you use to convince yourself
17:21:05 <RichardO> @pl f x = g (h i x)
17:21:05 <lambdabot> f = g . h i
17:21:34 <tswett> The math textbooks I read these days tend to prove, or at least sketch proofs of, most of what they say.  History, on the other hand...
17:21:52 <tswett> There are no historical theorems.
17:22:04 <Rotaerk> proofs don't convince you that something ought to be true though
17:22:34 <tswett> You mean they can tell you that it's true, but they can't tell you *why* it's true?
17:22:42 <tswett> (Or, at least, that they don't?)
17:23:05 <xplat> no, proofs convince you that something is true, not that it ought to be
17:23:26 <Rotaerk> the analogy that this article presents, for those of you who aren't going to read it, is morality versus legality
17:23:29 * tswett nods.
17:23:46 <Rotaerk> in theory, what is legal *should* strongly correlate with what is right
17:23:52 <Rotaerk> but it doesn't necessarily...
17:24:03 <xplat> there are all kinds of reasons for that ...
17:24:21 <Rotaerk> and if it doesn't, then the law itself *should* be changed to more closely match the moral notion
17:24:33 <dafis> whose moral notion?
17:24:39 <dafis> mine?
17:24:44 <dafis> or the pope's?
17:24:49 <xplat> jr "bob
17:24:53 <xplat> " dobbs's
17:25:43 <Rotaerk> well that's part of the reason why morality and legality don't exactly match
17:26:03 <xplat> no, it should be changed to match the correct moral notion.  regardless of whether anyone actually believes it :)
17:26:23 <xplat> (this spec is difficult to implement)
17:26:29 <Rotaerk> "However, a moralist thinks that morality is more important than legality. He thinks that the most important thing is to do what he thinks is morally right, which may or may not coincide with what the law says is right. Just because the law says something is not enough to convince him of the rightness or wrongness of it. However, a law-abiding moralist still believes he should try to stay within the law, albeit grudgingl"
17:26:38 <dafis> Rotaerk: the fact that some people have a lot of influence on the lawmakers and others don't is a much larger part, I think
17:26:59 <Rotaerk> true
17:27:10 <xplat> and a lot of people don't think that the law should have anything to do with morality
17:27:53 <xplat> or at least not in that direction of dependence (a common cause is when people think the law defines morality)
17:28:31 <Rotaerk> xplat, true; I sure don't want law defined by, say, a religion's moral code
17:28:35 <ddarius> It would be a sad person that thought that the law defined morality.
17:29:10 <Rotaerk> yea I think the focus isn't that law "should" be defined by morality, so much as that morality shouldn't be defined by law
17:29:22 <ddarius> Rotaerk: What if that religion's moral code coincided with yours?
17:29:32 <sm> could someone remind me how to preview your cabal file's haddock markup rendering before uploading to hackage ?
17:29:38 <xplat> and even people who think the law should enforce (either certain or all) moral precepts feel it should be used for a lot of other things too
17:30:36 <Rotaerk> and similarly being convinced of some mathematical truth shouldn't be based solely on a proof, but given a conceptual intuitive understanding of why it makes sense ... i.e. even without a proof you'd feel confident that such a proof should exist
17:30:45 <xplat> like encouraging economic efficiency
17:30:50 <sm> it doesn't look like haddock can read stdin
17:31:36 <dafis> Rotaerk: a proof is sufficient for believing som proposition holds, but not necessary?
17:31:42 <dafis> *some
17:31:48 <xplat> Rotaerk: now that i'm not at all sure that it's necessarily true.  well, i should say fundamentally true.  in the context of humans it's certainly helpful.
17:32:39 <xplat> but in this case it seems like if intuition and cold, hard, formalist computation do not reconcile it should be the former that gives way
17:32:53 <Rotaerk> dafis, I believe that quantum computers are possible, but I don't understand the theory well enough to have an intuitive understanding of why it SHOULD be possible
17:33:13 <xplat> if your intuition gives you the wrong answer, you need a new intuition
17:33:26 <Rotaerk> xplat, depends; if they don't reconcile, neither should "give way"; instead, you should reevaluate both
17:33:38 <Rotaerk> perhaps there was a mistake in the proof, OR perhaps you're intuitively approaching it the wrong way
17:33:41 <Rotaerk> either could be at fault
17:34:01 <xplat> Rotaerk: maybe if you're dealing with informal proofs
17:35:31 <Rotaerk> dafis, so I'd say proof is sufficient for belief, but that intuition is needed for complete understanding and mastery of it
17:35:50 <Rotaerk> and that this intuition is the source of the ideas which are proven in the first place
17:36:08 <Rotaerk> it should be true, therefore I'm going to try to rigorously prove it
17:36:51 <dafis> well, yes that's how a lot of theorems came to be
17:37:13 <Rotaerk> and that sense of "should be true" is what she calls "morally true"
17:37:25 <Rotaerk> though I don't like that choice of word, myself
17:37:32 <dafis> but I'm rigorously going to bed now, night all
17:37:38 <Rotaerk> :P night
17:44:36 <Rotaerk> hmm... interesting point; the notion that because intuitive understandings which result in belief aren't easily transferrable from person to person, so a proof serves as a way to communicate that intuitive understanding in its rawest form
18:10:07 <espringe> http://hpaste.org/45824/syntax_error
18:10:15 <espringe> Anyone have any ideas? (syntax error included as annotation)
18:10:40 <espringe> Ohhhh. nvm
18:10:41 <espringe> I see
18:11:04 <espringe> I'm missing the -> in the lambdas
18:14:28 <ivanm> is it just me, or are the Haskell tracs missing all CSS, etc. ?
18:14:59 <accel> is there a haskell tool that will list of all the fcuntions that are not called ?
18:15:11 <accel> i.e. if somehwere I decalre a foo:: Int -> Int
18:15:15 <accel> but foo is not called from anywhere
18:15:21 <accel> is there a way haskell can inform me of this?
18:15:24 <accel> I like to kill dead code
18:15:50 <ivanm> accel: -Wall
18:16:12 <ivanm> doesn't work if that function is exported though
18:16:27 <rothwell> accel: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/hpc.html
18:16:27 <ivanm> (i.e. it only works on intra-module basis)
18:16:41 <ivanm> SourceGraph can tell you this across an entire project, but I don't know how valid it is
18:20:43 <siracusa> rothwell: Is that new in GHC 7?
18:20:52 <rothwell> siracusa: nope
18:23:00 <ivanm> RWH covers it in the testing section if memory serves
18:27:56 <RichardO> How can I cast a Word8 to a Int8?
18:28:39 <accel> ivanm , rothwell : thanks
18:29:31 <c_wraith> RichardO: fromIntegral.  it (nearly) always works
18:29:44 <napping> careful with overflow, though
18:30:18 <c_wraith> > fromIntegral (255 :: Word8) :: Int8
18:30:19 <lambdabot>   -1
18:30:24 <RichardO> Yea, the number I'm using are pretty small
18:30:34 <c_wraith> looks like it's a pure bitwise conversion
18:30:36 <RichardO> And I'll probably add quickcheck test to make sure
18:31:41 <c_wraith> > fromIntegral 3.5 :: Int8
18:31:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:31:42 <lambdabot>    `GHC.Real.Fractional t'
18:31:42 <lambdabot> ...
18:31:49 <c_wraith> That's the case it doesn't work for :)
18:33:42 <siracusa> > map (fromIntegral :: Word8 -> Int8) [0,1,127,128,254,255]
18:33:43 <lambdabot>   [0,1,127,-128,-2,-1]
18:33:55 <siracusa> works :-P
18:48:50 <rien> c_wraith: ok, so reads, I think the haskell.org page I'm reading mentions that, or maybe it was something else...
18:48:58 <c_wraith> :t reads
18:48:59 <lambdabot> forall a. (Read a) => String -> [(a, String)]
18:49:05 <rien> I want to do it the pretty way :)
18:49:10 <c_wraith> > reads "foo" :: Int
18:49:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:49:11 <lambdabot>         against inferred type ...
18:49:23 <c_wraith> > reads "foo" :: [(Int, String)]
18:49:24 <lambdabot>   []
18:49:29 <c_wraith> > reads "5" :: [(Int, String)]
18:49:30 <lambdabot>   [(5,"")]
18:49:38 <c_wraith> and, the case you need to be wary of...
18:49:43 <c_wraith> > reads "5foo" :: [(Int, String)]
18:49:44 <lambdabot>   [(5,"foo")]
18:49:47 <rien> hmm, very interesting
18:50:22 <solrize> hi, i've encountered this before but forgot the fix.... i just installed new platform 7.0.3 and now it can't find a lot of the standard modules
18:50:27 <solrize> do i have to change PATH or something?
18:50:29 <rien> oh, I thought the String was for the error... silly me
18:50:43 <parcs> why is it called reads, anyway?
18:50:57 <c_wraith> it can return multiple parses, if that makes sense for the type
18:51:08 <JuanDaugherty> does anybody use noweb with haskell?
18:51:51 <c_wraith> like, if you were parsing some sort of expression tree type, and the input was "a+b+c", reads could return both potential parses for that ambiguous input.
18:52:00 <ivanm> JuanDaugherty: don't think you can
18:52:04 <c_wraith> ...  I don't know of any type that actually has implemented it that way, though
18:52:11 <JuanDaugherty> highlighting-kate is the only thing I've found
18:52:13 <ivanm> "literate haskell" doesn't allow you to chop up functions like noweb does with C, etc.
18:52:23 <accel> is there a 1 line way of writing: t <- get \n case t of ... \n
18:52:28 <ivanm> JuanDaugherty: highlighting-kate is just for syntax highlighting...
18:52:34 <ivanm> I think you want lhs2tex
18:52:39 <ivanm> @where lhs2tex
18:52:40 <lambdabot> http://www.cs.uu.nl/~andres/lhs2tex
18:52:40 <JuanDaugherty> yeah, I saw something about "semi-literate"
18:52:47 <ivanm> JuanDaugherty: ^^
18:52:49 <c_wraith> accel: nope.  It's an ever-present feature request
18:53:04 <ivanm> yeah, anonymous case statements
18:53:07 <xplat> haskellers are only semi-literate, but we're great at math!
18:53:11 <accel> holy shit
18:53:18 <accel> have I finally moved from newb to asking interesting questions?
18:53:21 <accel> i.e. questions others also ask
18:53:26 <accel> accel++
18:53:30 <accel> I deserve a beer.
18:53:37 <ivanm> accel: giving yourself karma is cheating you know...
18:53:54 <monochrom> @karma accel
18:53:54 <lambdabot> accel has a karma of 3
18:54:00 <xplat> accel: get >>= \t -> case t of ...
18:54:29 <xplat> (not exactly great, but it's on one line)
18:54:30 <accel> xplat++ # for a technically correct solution
18:54:44 <accel> t <- get ; case t of ... # while we're at it
18:54:53 <JuanDaugherty> thx, ivanm 
18:55:01 <ivanm> np
18:55:37 <ivanm> @google haskell anonymous case statement
18:55:38 <lambdabot> http://www.haskell.org/haskellwiki/Anonymous_function
18:55:38 <lambdabot> Title: Anonymous function - HaskellWiki
18:55:55 <ivanm> no, pretty sure there was a feature request bug for it
18:58:08 <accel> @src modify
18:58:08 <lambdabot> Source not found. I feel much better now.
18:58:10 <accel> @type modify
18:58:11 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
19:08:27 <dmwit> ?karma dmwit
19:08:28 <lambdabot> You have a karma of 6
19:08:30 <dmwit> dmwit++
19:08:33 <dmwit> ?karma dmwit
19:08:33 <lambdabot> You have a karma of 6
19:08:45 <dmwit> \bot is smarter than that, ivanm. =)
19:09:12 <dmwit> ...but not much smarter
19:09:18 <dmwit_> dmwit++
19:09:21 <dmwit_> ?karma dmwit
19:09:21 <lambdabot> dmwit has a karma of 7
19:09:24 <dmwit_> dmwit--
19:09:50 <djahandarie> lol
19:12:57 <accel> @type execState
19:12:57 <lambdabot> forall s a. State s a -> s -> s
19:13:25 <accel> @type runState
19:13:26 <lambdabot> forall s a. State s a -> s -> (a, s)
19:13:42 <parcs> :t tail .: (:)
19:13:43 <lambdabot> forall a. a -> [a] -> [a]
19:15:19 <accel> haskell is the only programming language
19:15:27 <accel> where I feel proud when I write a bunch of code and it doesn't have a compiler error
19:17:22 <accel>   if ((curIndent t) <= 2)
19:17:22 <accel>      then addVal(String ln "\n")
19:17:22 <accel>      else addVal(String ln "\\\\\n")
19:17:25 <accel> can I make that shorter?
19:17:31 <accel> I would really like a ? : opeartor
19:17:36 <shachaf> accel: Clearly what you want to be doing is writing compilers.
19:17:38 <ddarius> accel: Then define one.
19:17:49 <ddarius> And use less parentheses.
19:17:50 <ivanm> accel: ++ "\n"
19:18:02 <ivanm> @src if'
19:18:02 <lambdabot> Source not found.
19:18:04 <ivanm> bah
19:18:19 <ivanm> if' p t f = if p then t else f
19:18:30 <ivanm> though I prefer to write it as a fold: bool f t p = if p then t else f
19:19:19 <ivanm> accel: flip (++) "\n" . addVal . String ln $ if curIndent t <= 2 then "" else "\\\\"
19:19:19 <accel> ivanm: holy shit
19:19:21 <accel> if' is amazing
19:19:44 <accel> ivanm ++
19:20:02 <ivanm> if you're trying to give me karma, I think you want to get rid of the space
19:20:06 <ivanm> note that if' is used by @pl
19:20:09 <ivanm> so I didn't make it up
19:20:43 <parcs> addVal (String ln (if ... then \n else \\\\\n)) ?
19:20:52 <ddarius> ivanm: But @pl did.
19:21:10 <ivanm> parcs: ^^ I already had something along those lines above
19:21:28 <ivanm> ddarius: wow, @pl wrote it's own code? :o
19:21:29 <ivanm> :p
19:30:12 <maxims_atif> this is my first time on the #haskell channel. Hi guys!
19:30:21 <accel> http://www.haskell.org/onlinereport/index98.html <-- where in this is guards defined?
19:30:24 <parcs> hellO!
19:30:28 <accel> i.e. i have 3 cases, where the types are the same
19:30:35 <accel> but I want to dispatch on boolean functions of the varaibles
19:30:38 <maxims_atif> Hello!
19:30:53 <maxims_atif> What's the best place to get started on Haskell
19:31:11 <accel> http://hackage.haskell.org/trac/ghc/wiki/Commentary
19:31:23 <accel> I meant: http://book.realworldhaskell.org/
19:31:32 <mauke> preflex: ? lyah
19:31:32 <preflex>  http://learnyouahaskell.com/
19:32:12 <mauke> accel: 3.13
19:32:13 <raininja> Hello
19:32:17 <maxims_atif> Yeah learnyouhaskell is pretty solid..started on that just few days back! any other suggestions?
19:32:50 <raininja> I am trying to compile stuff with ghc but I am getting Preulde module not loaded errors. How do I fix this?
19:33:14 <tolkad> I wanted to know how haskell's parser was implemented. this is the worst code I have ever seen: http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.3/doc/html/src/Language-Haskell-Parser.html
19:33:19 <mauke> raininja: what's the error message?
19:33:49 <mauke> tolkad: what's your point?
19:34:26 <tolkad> mauke: is there a better example of a programming language parser written in haskell?
19:34:42 <napping> tolkad: you could look at the actual grammar in GHC
19:34:44 <mauke> it would probably help if you look at the source file
19:35:11 <tolkad> I am
19:35:21 <mauke> no
19:35:27 <peeler> that's generated code, right? like saying reading what yacc spits out?
19:35:28 <mauke> the link you pasted was autogenerated code
19:35:43 <ivanm> peeler: yeah, it's generated by happy
19:35:47 <raininja> mauke: <command line>: module `Prelude' is not loaded
19:36:04 <mauke> raininja: what command are you using?
19:40:56 <rien> tolkad: look at "Write a Scheme in 48 hours"
19:41:47 <appamatto> rien, how was your search for the Scheme to C videos?
19:42:29 <raininja> mauke: runghc Setup.hs configure
19:42:44 <ivanm> raininja: for which package?
19:43:27 <raininja> ivanm:  base-4.3.1.0
19:43:38 <ivanm> raininja: oh, don't do that
19:43:50 <ivanm> you should never try to ugprade a library that comes with GHC (with the exception of Cabal)
19:44:07 <raininja> i have to upgrade all of GHC??
19:44:29 <raininja> i can build this 
19:44:29 <ivanm> if you want to get a new version of base, yes: get a new GHC
19:44:35 <raininja> thanks
19:45:20 <accel> > replicate 10 "x"
19:45:21 <lambdabot>   ["x","x","x","x","x","x","x","x","x","x"]
19:45:26 <accel> > replicate -1 "x"
19:45:27 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Types.Int -> a -> [a])
19:45:27 <lambdabot>    aris...
19:45:36 <accel> wtf, why does -1 fail?
19:45:55 <accel> > max 0 -1
19:45:56 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
19:45:56 <lambdabot>    arising from a use of `...
19:46:00 <accel> ???
19:46:04 <accel> @type max
19:46:05 <lambdabot> forall a. (Ord a) => a -> a -> a
19:46:08 <ivanm> accel: brackets
19:46:10 <accel> > max 0 (-1)
19:46:11 <ivanm> > max 0 (-1)
19:46:11 <lambdabot>   0
19:46:12 <lambdabot>   0
19:46:14 <peeler> > max 0 (-1)
19:46:15 <lambdabot>   0
19:46:16 <accel> > replicate (-1) "x"
19:46:16 <lambdabot>   []
19:46:19 <accel> point taken
19:46:20 <raininja> building 6.10.4
19:46:21 <accel> thanks everyone
19:46:26 <ivanm> accel: it's interpreting the - as being unary minus operator
19:46:31 <ivanm> raininja: which OS are you using?
19:46:38 <raininja> Sysinfo for 'silmaril': Linux 2.6.35.11-2m.mo7.x86_64 running KDE Development Platform 4.6.2-3m.mo7.Icarus Momonga Linux (KDE 4.6.2), CPU: Intel(R) Core i7 CPU         920  @ 2.67GHz at 2659 MHz (5319 bogomips), HD: 24/50GB, RAM: 1882/5975MB, 227 proc's, 31.36min up
19:46:50 <ivanm> raininja: which distro?
19:47:04 <raininja> Momonga Linux
19:47:08 <ivanm> never heard of it
19:47:14 <raininja> it is Japanese
19:47:26 <ivanm> raininja: first of all, why are you only building 6.10.4? Also, there are pre-built binaries available if you don't want to build it
19:47:36 <ivanm> but I highly recommend you go with a newer GHC
19:47:45 <ivanm> at the very least 6.12.3 if not 7.0.3
19:47:45 <raininja> ivanm: ok. what is the latest?
19:47:49 <ivanm> 7.0.3
19:47:59 <raininja> ok i modify this spec
19:48:04 <raininja> thanks
19:49:00 <raininja> ivanm: btw momonga is a fedora spin, japanese, which uses a ruby build script to enable easy building of rpms.  i came from gentoo so i like to build things :)
19:49:15 <ivanm> raininja: oh, there are newer fedora packages
19:49:19 <ivanm> and why did you leave gentoo?
19:50:50 <accel> http://hpaste.org/45827/indent <-- what is the correct indent for this?
19:51:29 <rien> appamatto: I was able to download them from google videos
19:51:31 <raininja> ivanm: I left when drobbins left and portage began to fail 
19:51:43 <rien> appamatto: if you want them you gotta be quick, they'll take everything down by april 29th
19:51:48 <rien> appamatto: gtg now, ttyl :)
19:52:12 <mauke> accel: | must be indented more than _
19:52:18 <mauke> accel: either move | right or _ left
19:52:59 <accel> mauke: nice; thanks
19:53:17 <accel> mauke: you're quite helpful when I'm not trolling
19:53:18 <accel> mauke++
19:53:19 <ivanm> raininja: the first or second time?
19:55:38 <peeler> so I have some raytracing code here, where 'rtrace :: Ray -> Color', and currently I generate an image with 'map rtrace rays', where 'rays' has length corresponding to the image resolution (e.g. 640 * 480)
19:55:46 <peeler> i would *love* to do this in parallel
19:56:14 <peeler> and it seems to my uneducated mind that it should be quite simple, since each 'rtrace' is independent of the others
19:57:23 <peeler> but if i replace 'map' with 'parMap r0' or 'parMap rseq', etc... and compile with -threaded -rtsopts, and run with +RTS -N -RTS...
19:57:34 <peeler> it ends up about half as fast as it was.
19:57:56 <ddarius> @hoogle parChunk
19:57:56 <lambdabot> No results found
19:58:02 <ddarius> @hoogle parMapChunk
19:58:02 <lambdabot> No results found
19:58:03 <raininja> ivanm: first :)
19:58:14 <peeler> parListChunk?
19:58:34 <ivanm> raininja: well, until recently I was using gentoo.... and failed to notice problems for the most part
19:59:09 <peeler> i tried using that, with the integer argument (xres * yres / (expected # cores))
19:59:32 <ddarius> peeler: Yeah, you probably want something more like that.  Otherwise you are attempting to spark 640*480 threads.
19:59:52 <peeler> better than parMap, but still slower than plain old single-threaded map...
20:00:25 <ddarius> It takes a chunk size.  What chunk size did you give it?
20:00:57 <peeler> ddarius: (xres * yres `div` 4)
20:01:20 <ddarius> You'll want smaller chunks than that.
20:02:29 <peeler> ddarius: I'll give that a go - makes sense, that way it can redistribute work as chunks finish, right?
20:02:34 <ddarius> Yes.
20:07:28 <robnik> I have a data type that deriving Show.  I just added one alternative that breaks the automatic deriving.   Can I fix this without a full definition of Show.  Ie, just for the alternative that can be automatically derived?  http://hpaste.org/45828/deriving
20:08:19 <monochrom> no, not so easily
20:09:02 <monochrom> but in this case, manully written Show code is pretty easy, just boring
20:09:18 <robnik> Yeah, it's not bad.
20:10:12 <raininja> ivanm: why did you change
20:10:51 <siracusa> robnik: If you don't care what the output for the function alternative looks like, you can import the Show instance for (->) and get a Show instance for the complete type.
20:11:06 <ivanm> I'm playing with exherbo now because I liked some of the cool stuff they were doing, and I had one too many run-ins with stupid gentoo devs
20:11:38 <ivanm> (I found out afterwards that the dev in question got reprimanded for similar things, but had already decided to jump ship)
20:11:53 <ivanm> too much politics going on *shrug*
20:12:17 <ivanm> of course, a Show instance for a function is a fugly hack
20:12:43 <ivanm> since Show/Read are meant to produce/parse valid Haskell code
20:13:11 <robnik> siracusa: thanks, I didn't know about that.
20:13:18 <tolkad> robnik: you could use template haskell to write code to generate the show instance!
20:13:44 <robnik> tolkad: I may be too new to Haskell to do that. :)
20:14:11 <tolkad> robnik: lol, it wouldn't be a very good idea for just one show instance anyway :P
20:17:03 <peeler> ddarius: using chunks of about 1000 rays each does indeed net enough of an improvement to noticably beat the single-thread version, thanks
20:17:27 <robnik> Is there a way to get an Eq instance for functions, like you can get a Show instance from Text.Show.Functions?
20:18:15 <robnik> I want to know if it's the identical function or not.  Like eq? in scheme.
20:21:59 <monochrom> we don't have identity equality
20:24:17 <ddarius> robnik: The show instance is Trivial.  You can, if you want, make a trivial Eq instance.  You can't get eq? though because that would discriminate between things that should be the same.
20:25:16 <bd_> robnik: Determining whether two functions are identical is undecidable :)
20:26:10 <bd_> What's more, the haskell execution model allows the compiler to create two distinct thunks for your lambda; so with your hypothetical eq? this could be false: let x = \_ -> 42; y = x in y `eq?` x
20:26:42 <bd_> This is because it's a legal transformation for the compiler to make this into: let x = \_ -> 42; y = \_ -> 42 in x `eq?` y
20:28:07 <robnik> okay, thanks, that makes sense
20:39:22 <bos> @src partitionEithers
20:39:22 <lambdabot> Source not found. :(
20:43:19 <JuanDaugherty> ivanm, there's nothing blocking using noweb with haskell chunks SFAICT except that you can't do indexing or pretty printing in noweb, but the basic tools should be as applicable as to any other lang not so supported
20:44:07 * hackagebot silently 1.1.2 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.1.2 (TrystanSpangler)
20:45:40 <_bitbucket> Where can I find good introductory documentation on HaskellDB? There really doesn't seem to be much out there.
20:50:53 <JuanDaugherty> _bitbucket, that on hackage is supposed to be definitive and sufficient, I think, besides the sources of course.
20:51:26 <JuanDaugherty> (e.g. http://hackage.haskell.org/package/haskelldb )
20:52:16 <_bitbucket> Yeah, I was hoping there was more of a tutoral somewhere, but it looks like I'll just have to try and grok the API docs on Hackage
20:55:51 <dons> is there an equational reasoning proof-search tool for haskell? if not, there should be one. 
20:56:10 <JuanDaugherty> perhaps HDBC would be a better choice as there's a chapter on it in RWH
20:56:12 <dons> state the start and end functions, it it states the rewrites to get from one to the other.
20:57:17 <ddarius> dons: I think there may be one or two, and who knows, maybe Sparkle works for Haskell now as well.
20:59:50 <dons> i vaguely recall one, but can't seem to find it on hackage. 
21:00:31 <dons> guess i could use an smt solver to do equivalence checking. but i like seeing the proof script
21:01:44 <lispy_> dons: that sounds really familiar to me as well
21:02:13 <lispy_> dons: http://www.haskell.org/haskellwiki/Haskell_Equational_Reasoning_Assistant
21:02:18 <lispy_> dons: I think HERA is what I recall
21:02:49 <_bitbucket> JuanDaugherty: HDBC operates at a lower level of abstraction though, where you basically just write raw SQL strings. I like the idea that HaskellDB enables static type checking of your queries, it just doesn't appear to have much documentation outside of that on Hackage
21:03:22 <dons> andy's tool.
21:03:22 <napping> You might try the paper
21:03:38 <lispy_> dons: yeah, he presnted it at ICFP when I was there...
21:04:06 <JuanDaugherty> bitbucket, right, I don't think much of relational algebra in Haskell for reasons I'm not entirely clear about
21:04:45 <JuanDaugherty> but don't feel I need to be ATM
21:30:12 * hackagebot silently 1.1.3 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.1.3 (TrystanSpangler)
21:33:12 * hackagebot kit 0.6.8 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.8 (NickPartridge)
21:44:12 <Guest65826> Can somone help me with my error :  http://codepad.org/T9akBQ2Y
21:44:19 <Guest65826> nick shadghost
21:44:21 <Guest65826> err
21:45:47 <blomqvist> shatly, missed `where' in line 5?
21:46:32 <shatly> blomqvist: wow thank you i feel retarted now
21:46:53 <blomqvist> you're welcome
21:47:34 <shatly> EX4A.hs:17:19: Not in scope: `even''
21:47:42 <shatly> uhmmm
21:48:29 <shatly> lol i am also new to vim and i deleted a '
21:50:55 <jargonjustin> Does runghc use the GHC compiler or interpreter?
21:52:18 <tolkad> Uh I'm having some trouble using monads-tf and Parsec
21:52:40 <tolkad> Parsec is deciding to use mtl 1.1.0.2
21:52:53 <tolkad> how can I force it to use mtl 2.*?
21:54:38 <tolkad> I'm getting type errors because pre-2.* mtl declared its own data types
21:55:11 <tolkad> but how can I tell a package dependency to use a certain version of a third package?
21:58:37 <blackh> tolkad: Basically you can't, unless you want to hack it.  Can you use parsec-3?
21:59:12 <tolkad> I am
21:59:43 <blackh> Well that wasn't very good advice, then.
22:00:05 <tolkad> hmm, maybe if I cabal install a newer version of mtl manually
22:00:17 * hackagebot hspec 0.4.3 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.4.3 (TrystanSpangler)
22:00:20 <tolkad> I think that worked
22:00:28 <tolkad> yay it worked
22:00:32 <blackh> Well, parsec-3.1.1 doesn't require the old one
22:00:57 <tolkad> I thought it would automatically install the latest version of mtl
22:01:20 <tolkad> this is silly, if you just try to install parsec and don't have mtl, it will download the newest version
22:01:32 <tolkad> but if you first install a package depending on an old version of mtl
22:01:33 <blackh> Actually I suppose it won't.  That would be a bug in parsec, then, if it depends on a package that makes the build break.
22:01:39 <tolkad> and then install parsec
22:01:50 <tolkad> it will just use the old version of mtl
22:02:24 <blackh> Well, it's not that silly - you might want to use the two packages together, and the dependencies don't say you can't.
22:02:26 <tolkad> blackh: the bug seems to be that cabal prefers local old versions over remote newer versions
22:02:45 <blackh> tolkad: It's always worked that way.
22:02:55 <blackh> Seems sensible to me.
22:03:17 <tolkad> blackh: the problem is you can't write a preference for a package you can't depend on
22:03:30 <tolkad> blackh: I can't depend directly on mtl because it conflicts with monads-tf
22:04:00 <tolkad> blackh: so depending on what local copy of mtl someone compiling my package has, it might fail
22:04:19 <blackh> Ah, yes.
22:04:42 <tolkad> blackh: so... how do I fix it?
22:05:22 <tolkad> randomly having the build fail because of the order someone installed completely unrelated packages is not acceptable
22:05:26 <blackh> Maybe it can be fixed in cabal easily - maybe it can't.
22:05:52 <blackh> Well, I fixed something in cabal once.  Maybe you can too. :)
22:05:53 <tolkad> the only two options I see are using package qualified imports (bleh)
22:06:12 <tolkad> or depending on a third package in hackage with an mtl 2.* dependency
22:06:47 <tolkad> so all we need to fix this problem is put a dummy package on hackage that depends on mtl 2.*
22:08:38 <tolkad> someone with a hackage account want to do that?
22:10:03 <td123> I'm reading "yet another haskell tutorial" and it mentions Data.FiniteMap, and I get an error when I do "import Data.FiniteMap" in ghci, any explanations for this?
22:10:35 <shachaf> YAHT is quite old.
22:10:36 <tolkad> Déjà vu
22:10:45 <ddarius> td123: That module has been obsolete for like five years.
22:10:52 <td123> oh :(
22:11:09 <td123> what has it been replaced with?
22:12:00 <ddarius> Data.Map
22:12:29 <ivanm> what was so "finite" about FiniteMap?
22:12:45 <ddarius> ivanm: The same thing that's finite about Data.Map.
22:14:08 <tolkad> ivanm: the fact it uses an Int to keep track of size
22:14:34 <ivanm> fair enough
22:14:44 <tolkad> ivanm: so don't try to put more items in there than could even fit in RAM
22:15:23 <ivanm> Is the main reason for not using Word for these things just the inefficiency of converting to/from Int (since most things use Int) since it goes via Integer?
22:15:24 <td123> so.. does anyone have a recommended tutorial for me?
22:15:25 <ivanm> tolkad: heh
22:15:42 <ivanm> td123: LYAH, tryhaskell.org (which is very much incomplete), the wikibook
22:15:46 <tolkad> ivanm: no, that gets optimized
22:15:54 <tolkad> ivanm: the reason is a convention
22:16:02 <taotree> I could use some monadic help. http://hpaste.org/45829/hint  Using Hint Interpreter monad. Need to understand how to initialize it (set imports and such) and then use it many times to test various expressions
22:16:03 <ivanm> or get an actual book like Programming Haskell, Craft of Functional Programming, etc.
22:16:07 <ivanm> tolkad: internally I mean
22:16:08 <ddarius> ivanm: It's just cuz.  And the fact that Int is in the Prelude and Word isn't.
22:16:17 <tolkad> ivanm: yeah it's a convention
22:16:20 <ivanm> ddarius: heh
22:16:46 <ivanm> after all, wouldn't using the appropriate Word over Int let you be twice as FInite? :p
22:17:07 <ivanm> (as in can have more things in the Map)
22:17:32 <shachaf> Presumably Data.Map is finite because you have to explicitly insert mappings into it, which means it can only have a finite number of them?
22:17:54 <shachaf> As opposed to an infinite map like (+1) :: Integer -> Integer
22:18:26 <tolkad> ivanm: for example: http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Integer_Types
22:18:48 <tolkad> ivanm: there's a convention of just using Int and not worrying about all the other integer types, just for simplicity
22:19:00 <ivanm> tolkad: yeah, I know
22:19:13 <ivanm> and I'm guessing that implementation predated Word* in Haskell
22:19:22 <ivanm> I suppose it's the same thing as how length returns an Int
22:19:59 <shachaf> ivanm: Well, Integral/Integer is in the Prelude, unlike Word.
22:20:15 <ivanm> shachaf: does it matter for _internal_ usage?
22:20:22 <tolkad> in C I actually like to use words sometimes
22:20:24 <ivanm> for Map, I was talking about internal definition
22:20:37 <tolkad> there are more guarantees about how unsigned types behave
22:20:37 <ivanm> tolkad: as opposed to single letters? :p
22:20:45 <tolkad> ivanm: lol I mean unsigned types
22:21:08 <mzero> I've finally wrapped my mind around why (.) can be defined as fmap (given a Functor instance for (a ->)) and find myself wondering if there would be any downside to that being in the Prelude
22:21:24 <ivanm> tolkad: yeah, I know
22:21:24 <shachaf> @ty (.) -- It isn't already?
22:21:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:21:33 <ivanm> mzero: confusion
22:21:37 <RayNbow`TU> shachaf: that's only lambdabot's definition
22:21:42 <mzero> I don't think it would be performance hit - since any existing use of (.) wouldn't be polymorphic, and so would compile to the same code
22:21:43 <ivanm> shachaf: it isn't in the Prelude; that's just Caleskell
22:21:43 <shachaf> RayNbow`TU: Spoilsport.
22:21:52 <ivanm> @type fmap . flip
22:21:53 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) b. (Functor f, Functor f1) => f1 (a -> b) -> f a -> f (f1 b)
22:21:59 <mzero> but, would it cause somethings to need to be type annotated?
22:22:02 <ivanm> mzero: ^^ wtf does that mean? ;)
22:22:11 <shachaf> mzero: It could lead to more confusing types/error messages.
22:22:12 <tolkad> does anyone with a hackage account want to upload a dummy package that depends on mtl >= 2? it would help with some dependency issues
22:22:14 <ivanm> mzero: it would make it harder for us mere humans to understand it
22:22:22 <tolkad> between mtl and monads-tf
22:22:32 <ivanm> tolkad: "dummy package"? I didn't think they were allowed
22:23:03 <tolkad> ivanm: I mean it would have an empty library with a dependency on mtl >= 2
22:23:07 <mzero> well - what I mean is -- is there existing code that compiles that wouldn't if . = fmap? In particular because the type inference wouldn't be able to use the more restricted type of the traditional (.)?
22:23:15 <tolkad> ivanm: and nothing else
22:23:28 <ivanm> tolkad: as in no modules? I don't think hackage would allow it
22:23:34 <ivanm> and what good would it do?
22:23:40 <ivanm> mzero: I doubt it
22:23:44 <tolkad> ivanm: uh it would fix this dependency issue I'm having
22:23:52 <ivanm> what issue?
22:23:57 <mzero> then the only confusion we'd be worried about would be for code that doesn't compile? 
22:24:01 <ivanm> why not just force it at some point?
22:24:10 <shachaf> mzero: There are also other possible generalizations of (.).
22:24:12 <mzero> in those error messages - which is an important point, I agree
22:24:13 <ivanm> mzero: and developer mental confusion
22:24:33 <ivanm> mzero: remember, we also like to typecheck valid code sometimes to see what the type _is_
22:24:38 <mzero> well, on the one hand I admit the difficulty of developer mental confusion
22:24:40 <ivanm> also, one of Haskell's uses is for _teaching_
22:24:56 <ivanm> things like that make it harder for students to understand wtf is going on IMHO
22:24:56 <tolkad> ivanm: if I require Parsec >= 3, and monads-tf, and try to use the monad-tf Identity monad, and the person compiling my package has previously installed a version of mtl < 2, the build will fail because the two Identity monads are different types
22:25:02 <mzero> on the other hand...
22:25:03 <mzero> >  (*3) . [1..10]
22:25:04 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
22:25:10 <mzero> that is somewhat compelling!
22:25:18 <ivanm> tolkad: does your .cabal file say to use monads-tf ?
22:25:22 <tolkad> ivanm: and I can't add an mtl >= 2 dependency because its module names conflict with monads-tf
22:25:24 <shachaf> mzero: Some people argue that that could lead to a lot of confusion too.
22:25:26 <tolkad> ivanm: yes
22:25:40 <shachaf> mzero: Admittedly it's nice that (.) stays associative. :-)
22:25:47 <mzero> as is replacing the somewhat ugly   `fmap` I litter my code with 
22:25:51 <ivanm> tolkad: then it shouldn't be bringing in mtl at all, let alone mtl < 2
22:25:56 <shachaf> mzero: There's <$> for that.
22:26:00 <tolkad> ivanm: It's not, Parsec is
22:26:06 <tolkad> ivanm: for the Identity monad
22:26:06 <shachaf> > (*3) <$> [1..10]
22:26:06 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
22:26:20 <Boxo> :t (<$>)
22:26:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:26:32 <td123> mzero: interesting.. ghci doesn't like your previous statement
22:26:51 <ivanm> td123: the (*3) . [1..10] one? it's only valid for lambdabot 
22:26:51 <shachaf> td123: As was just discussed, this is a lambdabot-exclusive bonus.
22:26:58 <ivanm> as it's been infected by Caleskell!
22:26:58 <tolkad> ivanm: mtl < 2 is being installed because Parsec doesn't ask for any particular version of mtl and the person building the package already has a local old version of mtl for some reason
22:27:02 <ivanm> @type flip -- wtf?
22:27:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:27:03 <tolkad> ivanm: how can I fix this?
22:27:04 <mzero> True, though begins to smell of TIMTOWDI .... how many ways can we spell fmap????
22:27:23 <td123> ivanm: shachaf: k
22:27:31 <mzero> td123: lambdabot has a different definition of (.) than the Prelude
22:27:31 <shachaf> mzero: There's probably a two-digit number in the standard libraries. :-)
22:27:39 <ivanm> tolkad: I'm still trying to work out why it uses the mtl instance
22:27:46 <ivanm> you sure you're importing things correctly?
22:27:53 <ivanm> admittedly, I don't use parsec myself
22:28:10 <ivanm> tolkad: does it work with mtl-2 though?
22:28:15 <tolkad> ivanm: yes
22:28:17 <ivanm> I would have thought you'd get the same problem
22:28:27 <ivanm> or is it because it's now an alias as opposed to a newtype?
22:28:31 <tolkad> ivanm: yes
22:28:38 <ivanm> huh
22:28:45 <shachaf> liftM, liftA, fmap, (.), map, (<$>), etc.
22:28:59 <ivanm> tolkad: you could always use --constraint="mtl >= 2"
22:29:13 <tolkad> how do I put that in my cabal file so it works for anyone?
22:29:17 <ivanm> but a better idea is to push to get rid of the defaulting of mtl versioning
22:29:23 <ivanm> tolkad: you can't, unfortunately
22:29:24 <mzero> exactly --- having so many is also confusing
22:29:29 <ivanm> that's a cabal-install -ism
22:29:44 <mzero> even most newbies to Haskell quickly question why there is map and fmap
22:29:44 <tolkad> ivanm: so the only solution is my mtl dummy package idea
22:30:01 <shachaf> mzero: Only after they figure out what type classes are. :-)
22:30:19 <shachaf> mzero: I think having just map, with (.) as an alias, is reasonable.
22:30:39 <mzero> and having them both be the only member of the class Functor?
22:30:55 <mzero> that would be nice.... if it didn't induce more required type annotations
22:31:21 <shachaf> Well, no, we should add fail :: String -> f a to Functor.
22:31:49 <tolkad> ivanm: or using package qualified imports for monads-tf modules throughout my entire package
22:31:49 <ivanm> mzero: IMHO, the distinction is quite simple: we want something with a simpler type for learning/teaching purposes
22:31:50 <mzero> bleh!
22:31:55 <ivanm> unless we use something like Helium
22:32:02 <shachaf> mzero: What would require more type annotations?
22:32:05 <tolkad> ivanm: so I can add the mtl dependency
22:32:10 <ivanm> tolkad: yeah :s
22:32:23 <tolkad> ivanm: so uh, I guess you might have a hackage account
22:32:26 <ivanm> tolkad: or just find some other package with minimal deps?
22:32:31 <ivanm> I do.....
22:32:32 <ivanm> >_>
22:32:47 <mzero> ivanm - I'm not sure I buy that.... if it is better for writing real programs, then I think it is better for teaching
22:32:51 * shachaf gets a strange sense of déjà vu about this discussion.
22:33:11 <ivanm> mzero: type classes are difficult to get through student's heads
22:33:12 <mzero> Oh, I'm sure it's been had a zillion times
22:33:15 <tolkad> shachaf: when td123 asked his question I could have sworn I had already seen him ask it
22:33:30 <tolkad> shachaf: proving I'm a time traveller
22:33:39 <mzero> both discussions, that is!  :-)
22:33:59 <mzero> ivanm - really? I can't see why - they seem quite simple enough to teach to me.... 
22:34:07 <shachaf> tolkad: Can you travel backward or just forward?
22:34:26 <ivanm> mzero: there's a difference between "I actually care about this and want to learn" to "*sigh* wtf am I doing in this class, and what is this shit?"
22:34:37 <shachaf> mzero: How is it you only "finally wrapped [your] mind around" it now, then? :-)
22:34:40 <mzero> but, I admit my Haskell teaching system hasn't got them integrated into the tutorial yet
22:35:48 <tolkad> shachaf: my conciousness can travel back in time but the only memories I can carry with me are vague recollections that randomly give me déjà vu
22:35:55 <mzero> not typeclasses, shachaf, but (.) as being fmap .... and it took this long because, of course, I was taught that (.) was this simple function composition thing - and (a ->) as a Functor is notably "not discussed" early on
22:35:58 <tolkad> shachaf: it's all very scientific
22:36:20 <shachaf> mzero: Yes -- and do you think discussing it early on would have been helpful?
22:36:39 <mzero> Yes - actually - 
22:37:29 <tolkad> ivanm: the most confusing thing about typeclasses for me was the conceptual difference between forall and exists. I didn't know first-order logic back then
22:37:31 <RayNbow`TU> :t \f a -> fmap ($a) f
22:37:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
22:37:50 <td123> tolkad: sorry :)
22:37:55 <td123> tolkad: deja vu?
22:38:16 <RayNbow`TU> flip :: Functor f => (f.(a->)) b -> ((a->).f) b -- right?
22:38:37 <td123> tolkad: tbf, I did ask about an unrelated ghci error beforehand
22:38:39 <tolkad> td123: A vague sense that what is happening now has occurred before. It's some sort of cognition artifact
22:39:02 <tolkad> td123: but it's not in my irc logs
22:39:28 <td123> "Data.FiniteMap, and I get an error when I do "import...
22:39:46 <td123> tolkad: should be about 30 minutes ago
22:40:37 <RayNbow`TU> > flip [succ,pred] 3
22:40:39 <lambdabot>   [4,2]
22:40:44 <RayNbow`TU> > sequence [succ,pred] 3
22:40:45 <lambdabot>   [4,2]
22:40:58 <tolkad> td123: uh sorry, I've kind of derailed the channel discussion
22:43:11 <td123> tolkad: it's ok, you just took us into a different fork in reality :)
22:43:21 <td123> no turning back now
22:56:53 <gh0st> Hello
22:58:18 <Cale> hello
23:02:14 <BleuM937> gday
23:02:36 <mzero> welcome
23:03:04 <BleuM937> This is my first time here
23:03:08 <BleuM937> What does one generally discuss?
23:03:25 <mzero> ...Haskell.... strangely enough
23:05:05 <gh0st> Lol
23:05:40 <BleuM937> Is there a way to automatically update all of Haskell Platform on Windows?
23:05:48 <luite> sometimes other stuffs, like the morality of mathematical proofs
23:06:19 <mzero> so, you have an older HP installed, and you want the latest? Generally, one just reinstalls HP again
23:06:40 <mzero> because with most HP releases, the whole compiler chain has changed to a newer version - and that is the bulk of the release
23:07:21 <BleuM937> I have HP2010.2
23:07:44 <BleuM937> I just noticed HP2011 is out... so I thought I should upgrade?
23:07:52 <dankna> you probably do want to upgrade
23:07:58 <mzero> yes, 2011 is based on GHC 7.0 whereas you have GHC 6.12 
23:08:08 <BleuM937> Indeed
23:08:43 <BleuM937> So just uninstall/ install then?
23:08:44 <mzero> Mind you - if you're just tinkering, it's not all that different -- mostly there is a new IO subsystem under the covers, and some new extentions...
23:08:51 <mzero> but yes, just uninstall and install --- 
23:09:01 <mzero> (not sure if HP for Windows comes with an uninstaller)
23:09:18 <gh0st> Curious, what is the most frequent application of haskell?
23:09:36 <mzero> if you have projects that need other packages, you'll end up pulling and recompilng them when you do cabal install 
23:09:48 <jeffz> Add/Remove programs in Windows has an entry for Haskell Platform
23:09:57 <luite> gh0st: difficult to say since there are so many applications. what would be the most frequent application for java for example?
23:10:09 <BleuM937> except that cabal doesn't work too well when it needs foreign packages :/
23:10:21 * BleuM937 needs a *nix dev environment
23:10:25 <mzero> gh0st: "most frequent"? it is a general purpose language -- I see a pretty wide variety of domains being solved with Haskell these days
23:11:34 <BleuM937> @luite how do proofs have morality?
23:11:35 <lambdabot> Maybe you meant: elite gsite quit quote
23:11:37 * mzero tries to suppress all the snarky Java lines he's thinking....
23:13:14 <gh0st> The most frequent application of Java is currently android app development.
23:13:32 <companion_cube> more than web development ?
23:13:35 <mzero> ? how could you possibly substantiate that?
23:14:21 <gh0st> What I'm wondering is are more people using Haskell to run servers, for personal scripts, web applications, etc
23:14:36 <jeffz> what does it matter?
23:15:35 <gh0st> Because the most popular use is usually the simplest in design based on the accessibility of the functions of the languange.
23:15:42 <mzero> Judging from the packages on Hackage, and the discussions in various fora, I'd say all of those things, and many more, are being done frequently with haskell.... but "most frequent" is going to be difficult to assess
23:15:51 <luite> BleuM937: oh that was a discussion last night about an article about whether proofs convey only the truth of a certain statement, or also some intuition about whether the statement "ought to be true"
23:15:52 <gh0st> And I want to know if I should pick it up...
23:15:56 <BleuM937> @gh0st http://www.haskell.org/haskellwiki/Haskell_in_industry
23:15:56 <lambdabot> Unknown command, try @list
23:15:57 <companion_cube> gh0st, the most frequent use of haskell is extending haskell for proof of concept in research ;)
23:16:16 <mzero> gh0st - I think that is only true for narrow languages
23:16:52 <gh0st> Thanks Bleu, Resources :D
23:17:02 <mzero> what is the "most frequent application" for C++? 
23:17:18 <luite> BleuM937: a proof that also gives the right intuition is somehow more moral or something :) (haven't read the article myself, so I'm not sure if that's really the point the author tries to make)
23:17:43 <mzero> If you enjoy programming, then you *should* pick up Haskell, gh0st, it is a wonderful language.
23:17:48 <luite> BleuM937: it's not terribly important, but that's the most recent off topic discussion in here that I recall :)
23:17:56 <gasche> hello
23:18:04 <gasche> I'm afraid I may have sent a paste here by mistake
23:18:13 <mzero> we didn't see it
23:18:36 <BleuM937> luite: Interesting... I haven't had anything to do with proofs or morality before so I can't really comment on the matter :P
23:18:36 <luite> gh0st: people are at least using it for server side things like building websites
23:18:56 <BleuM937> luite: sounds like a good read though, do you have it floating round somewhere?
23:19:15 <luite> BleuM937: http://www.cheng.staff.shef.ac.uk/morality/morality.pdf
23:19:22 <gasche> I have a bug with hpaste : when asking "preview", the "channel", even when sent to nothing, is reset to #haskell after preview
23:19:30 <gh0st> C++ is not frequently used in web development or in scripts so I would have to say ... Large applications and scripts that require quick completion, Servers, and Most Competitive Proprietary Software.
23:20:10 <BleuM937> gh0st: I don't actually *use* Haskell for anything, but it is tremendous fun to learn and will vastly improve your programming in any other language
23:20:25 <BleuM937> luite: cheers
23:20:28 <gh0st> coolio
23:20:36 <gh0st> Well cya
23:21:45 <luite> gh0st: people are using haskell for web development, but I believe it's fair to say that the web frameworks in use are in their infancy, there are no huge frameworks with everything but the kitchen sink (that's not really haskell's style anyway), and api's should be excpected to change
23:21:51 <luite> hmm
23:22:20 <gasche> luite: your link looks cool, but I object to the use of the name "morality" here
23:22:36 <gasche> I've never heard anyone talk about "morality" in this context, they only say "morally"
23:22:41 <luite> I should've stuck with a shorter reply that fits within the attention span of modern people ;p
23:22:44 <gasche> and I think there's an important distinction to be made
23:22:44 * hackagebot gloss-examples 1.3.2.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.3.2.1 (BenLippmeier)
23:23:01 <BleuM937> Quick question: what do people here do? Student, academic, developer?
23:23:18 <luite> I think the short answer is all of them ;p
23:23:33 <luite> pretty sure there are lots of people for all categories here
23:24:30 <BleuM937> I'm first year uni... Nobody else at my uni has even heard of Haskell :/
23:24:49 <BleuM937> Well, nobody that I've spoken to at least :P
23:26:06 <companion_cube> same here (but there are people who use scala)
23:26:30 <RayNbow`TU> it's a shame Haskell has been dropped from the curriculum in Delft
23:27:12 <roconnor> I thought Delft was one of the main Haskell places
23:27:17 <roconnor> or am I thinking Utrecht
23:27:22 <RayNbow`TU> roconnor: Utrecht
23:27:23 <luite> RayNbow`TU: yes in times of budget cuts they have to stick to teaching actually useful stuffs ;)
23:27:32 <BleuM937> Utrecht have a compiler project
23:27:43 <BleuM937> so I'd say they're pretty big
23:28:34 <BleuM937> well, nobody likes Haskell in Australia
23:28:51 <ddarius> Other than all those that do.
23:29:04 <kfish> haskell is bloody awesome
23:29:10 <BleuM937> All the unis want to teach in compsci is C
23:29:11 <luite> hmm, dons did his PhD in australia I believe, so there must have been a few that know haskell there :p
23:29:32 <kfish> BleuM937, what uni are you at?
23:29:37 <gasche> australia is a category land, so there is some place for Haskell there
23:29:47 <BleuM937> Swinburne
23:29:59 <BleuM937> It's not really the place for Haskell :P
23:30:05 <gasche> luite: is "Eugenia Cheng" the same person that did the great category lectures on Youtube some years ago?
23:30:07 <RayNbow`TU> Haskell's awesome, but we need more packages :p
23:30:07 <BleuM937> I'm not even doing a compsci course
23:30:19 <kfish> maybe time for a transfer :)
23:30:33 <ddarius> gasche: Yes.
23:30:52 <BleuM937> haha, I'm on a scholarship for my current course
23:30:53 <luite> gasche: yes, the catsters
23:30:58 <BleuM937> I'll stick with it a while longer
23:32:11 <luite> BleuM937: what are you doing instead? math? engineering?
23:32:25 <gasche> (if it's math, keep doing it)
23:32:30 <BleuM937> BIT
23:32:40 <BleuM937> it's sorta business/ IS/ IT nonsense
23:32:51 <luite> yeah for math you might have some chance of doing haskell, for engineering, better install matlab ;)
23:33:09 <BleuM937> I've got some mates in engineering
23:33:12 <BleuM937> it looks gross :P
23:33:45 * hackagebot gloss-examples 1.3.2.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.3.2.2 (BenLippmeier)
23:36:58 <jeffz> BleuM937: pretty common for anyone not interested in plt or out of the reddit loop to not have heard of haskell, but it's certainly false that "nobody likes Haskell in Australia"
23:37:54 <BleuM937> jeffz: haha yes it was quite a shocking piece of hyperbole
23:38:14 <jeffz> BleuM937: people teaching first year digital electronics hadn't heard of Haskell where I study for example, but the cs lecturers certainly have.
23:39:15 <luite> just wait for the courses where you can pick your own language for implementing the assignments :)
23:39:58 <jeffz> luite: that's only really suitable for final year projects though isn't it?
23:40:26 <BleuM937> yep
23:40:54 <BleuM937> first-semester programming is in Pascal
23:40:57 <jeffz> I asked why we couldn't use Haskell for first year assignments in a language agnostic fashion to which the response was that the markers only know Java and C++.
23:41:03 <luite> probably yes... perhaps for smaller group projects in the first years, although you'd probably be the only one in your group doing haskell :)
23:41:31 <BleuM937> oh wells
23:42:01 <BleuM937> I'm doing a research report on typing systems for my subject portfolio
23:42:22 <BleuM937> I say research report in the first-year undergrad sense, not the *research report* sense :P
23:43:28 <BleuM937> anyways
23:43:40 <BleuM937> I need to get ready for dinner
23:44:01 <luite> BleuM937: you should pick up types and programming languages by benjamin pierce then
23:44:19 * RayNbow`TU still needs to finish reading TaPL
23:44:22 <BleuM937> luite: I'll have a look tomorrow :)
23:44:29 * BleuM937 departs
23:44:32 <RayNbow`TU> (way too many books that I need to finish reading)
23:48:41 <accel> destructuring + : as a list constructor = way too fucking cool
23:48:47 <accel> this is the shit
